{
  "title": {
    "text": "RFC 3951 - Internet Low Bit Rate Codec (iLBC)",
    "ja": "RFC 3951 - インターネット低ビットレートコーデック（iLBCの）"
  },
  "number": 3951,
  "created_at": "2019-10-25 18:05:27.409982+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        S. Andersen\nRequest for Comments: 3951                            Aalborg University\nCategory: Experimental                                          A. Duric\n                                                                   Telio\n                                                               H. Astrom\n                                                                R. Hagen\n                                                               W. Kleijn\n                                                               J. Linden\n                                                         Global IP Sound\n                                                           December 2004",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Internet Low Bit Rate Codec (iLBC)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004).",
      "ja": "著作権（C）インターネット協会（2004）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a speech codec suitable for robust voice communication over IP. The codec is developed by Global IP Sound (GIPS). It is designed for narrow band speech and results in a payload bit rate of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s for 20 ms frames. The codec enables graceful speech quality degradation in the case of lost frames, which occurs in connection with lost or delayed IP packets.",
      "ja": "この文書では、IP上の堅牢な音声通信に適した音声コーデックを指定します。コーデックは、グローバルIPサウンド（GIPS）によって開発されています。これは、20ミリ秒のフレームのための30ミリ秒のフレーム及び15.20キロビット/秒のため13.33キロビット/秒のペイロードのビットレートで狭帯域音声及び結果のために設計されています。コーデックは、損失または遅延したIPパケットに関連して発生する失われたフレームの場合には、優雅な音声品質の劣化を可能にします。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Outline of the Codec . . . . . . . . . . . . . . . . . . . . .  5\n    2.1.  Encoder. . . . . . . . . . . . . . . . . . . . . . . . .  5\n    2.2.  Decoder. . . . . . . . . . . . . . . . . . . . . . . . .  7\n3.  Encoder Principles . . . . . . . . . . . . . . . . . . . . . .  7\n    3.1.  Pre-processing . . . . . . . . . . . . . . . . . . . . .  9\n    3.2.  LPC Analysis and Quantization. . . . . . . . . . . . . .  9\n          3.2.1.  Computation of Autocorrelation Coefficients. . . 10\n          3.2.2.  Computation of LPC Coefficients. . . . . . . . . 11\n          3.2.3.  Computation of LSF Coefficients from LPC\n                  Coefficients . . . . . . . . . . . . . . . . . . 11\n          3.2.4.  Quantization of LSF Coefficients . . . . . . . . 12\n          3.2.5.  Stability Check of LSF Coefficients. . . . . . . 13\n          3.2.6.  Interpolation of LSF Coefficients. . . . . . . . 13\n          3.2.7.  LPC Analysis and Quantization for 20 ms Frames . 14\n    3.3.  Calculation of the Residual. . . . . . . . . . . . . . . 15\n    3.4.  Perceptual Weighting Filter. . . . . . . . . . . . . . . 15\n    3.5.  Start State Encoder. . . . . . . . . . . . . . . . . . . 15\n          3.5.1.  Start State Estimation . . . . . . . . . . . . . 16\n          3.5.2.  All-Pass Filtering and Scale Quantization. . . . 17\n          3.5.3.  Scalar Quantization. . . . . . . . . . . . . . . 18\n    3.6.  Encoding the Remaining Samples . . . . . . . . . . . . . 19\n          3.6.1.  Codebook Memory. . . . . . . . . . . . . . . . . 20\n          3.6.2.  Perceptual Weighting of Codebook Memory\n                  and Target . . . . . . . . . . . . . . . . . . . 22\n          3.6.3.  Codebook Creation. . . . . . . . . . . . . . . . 23\n                  3.6.3.1. Creation of a Base Codebook . . . . . . 23\n                  3.6.3.2. Codebook Expansion. . . . . . . . . . . 24\n                  3.6.3.3. Codebook Augmentation . . . . . . . . . 24\n          3.6.4.  Codebook Search. . . . . . . . . . . . . . . . . 26\n                  3.6.4.1. Codebook Search at Each Stage . . . . . 26\n                  3.6.4.2. Gain Quantization at Each Stage . . . . 27\n                  3.6.4.3. Preparation of Target for Next Stage. . 28\n    3.7.  Gain Correction Encoding . . . . . . . . . . . . . . . . 28\n    3.8.  Bitstream Definition . . . . . . . . . . . . . . . . . . 29\n4.  Decoder Principles . . . . . . . . . . . . . . . . . . . . . . 32\n    4.1.  LPC Filter Reconstruction. . . . . . . . . . . . . . . . 33\n    4.2.  Start State Reconstruction . . . . . . . . . . . . . . . 33\n    4.3.  Excitation Decoding Loop . . . . . . . . . . . . . . . . 34\n    4.4.  Multistage Adaptive Codebook Decoding. . . . . . . . . . 35\n          4.4.1.  Construction of the Decoded Excitation Signal. . 35\n    4.5.  Packet Loss Concealment. . . . . . . . . . . . . . . . . 35\n          4.5.1.  Block Received Correctly and Previous Block\n                  Also Received. . . . . . . . . . . . . . . . . . 35\n          4.5.2.  Block Not Received . . . . . . . . . . . . . . . 36",
      "raw": true
    },
    {
      "indent": 3,
      "text": "          4.5.3.  Block Received Correctly When Previous Block\n                  Not Received . . . . . . . . . . . . . . . . . . 36\n    4.6.  Enhancement. . . . . . . . . . . . . . . . . . . . . . . 37\n          4.6.1.  Estimating the Pitch . . . . . . . . . . . . . . 39\n          4.6.2.  Determination of the Pitch-Synchronous\n                  Sequences. . . . . . . . . . . . . . . . . . . . 39\n          4.6.3.  Calculation of the Smoothed Excitation . . . . . 41\n          4.6.4.  Enhancer Criterion . . . . . . . . . . . . . . . 41\n          4.6.5.  Enhancing the Excitation . . . . . . . . . . . . 42\n    4.7.  Synthesis Filtering. . . . . . . . . . . . . . . . . . . 43\n    4.8.  Post Filtering . . . . . . . . . . . . . . . . . . . . . 43\n5.  Security Considerations. . . . . . . . . . . . . . . . . . . . 43\n6.  Evaluation of the iLBC Implementations . . . . . . . . . . . . 43\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n    7.1.  Normative References . . . . . . . . . . . . . . . . . . 43\n    7.2.  Informative References . . . . . . . . . . . . . . . . . 44\n8.  ACKNOWLEDGEMENTS . . . . . . . . . . . . . . . . . . . . . . . 44\nAPPENDIX A: Reference Implementation . . . . . . . . . . . . . . . 45\n    A.1.  iLBC_test.c. . . . . . . . . . . . . . . . . . . . . . . 46\n    A.2   iLBC_encode.h. . . . . . . . . . . . . . . . . . . . . . 52\n    A.3.  iLBC_encode.c. . . . . . . . . . . . . . . . . . . . . . 53\n    A.4.  iLBC_decode.h. . . . . . . . . . . . . . . . . . . . . . 63\n    A.5.  iLBC_decode.c. . . . . . . . . . . . . . . . . . . . . . 64\n    A.6.  iLBC_define.h. . . . . . . . . . . . . . . . . . . . . . 76\n    A.7.  constants.h. . . . . . . . . . . . . . . . . . . . . . . 80\n    A.8.  constants.c. . . . . . . . . . . . . . . . . . . . . . . 82\n    A.9.  anaFilter.h. . . . . . . . . . . . . . . . . . . . . . . 96\n    A.10. anaFilter.c. . . . . . . . . . . . . . . . . . . . . . . 97\n    A.11. createCB.h . . . . . . . . . . . . . . . . . . . . . . . 98\n    A.12. createCB.c . . . . . . . . . . . . . . . . . . . . . . . 99\n    A.13. doCPLC.h . . . . . . . . . . . . . . . . . . . . . . . .104\n    A.14. doCPLC.c . . . . . . . . . . . . . . . . . . . . . . . .104\n    A.15. enhancer.h . . . . . . . . . . . . . . . . . . . . . . .109\n    A.16. enhancer.c . . . . . . . . . . . . . . . . . . . . . . .110\n    A.17. filter.h . . . . . . . . . . . . . . . . . . . . . . . .123\n    A.18. filter.c . . . . . . . . . . . . . . . . . . . . . . . .125\n    A.19. FrameClassify.h. . . . . . . . . . . . . . . . . . . . .128\n    A.20. FrameClassify.c. . . . . . . . . . . . . . . . . . . . .129\n    A.21. gainquant.h. . . . . . . . . . . . . . . . . . . . . . .131\n    A.22. gainquant.c. . . . . . . . . . . . . . . . . . . . . . .131\n    A.23. getCBvec.h . . . . . . . . . . . . . . . . . . . . . . .134\n    A.24. getCBvec.c . . . . . . . . . . . . . . . . . . . . . . .134\n    A.25. helpfun.h. . . . . . . . . . . . . . . . . . . . . . . .138\n    A.26. helpfun.c. . . . . . . . . . . . . . . . . . . . . . . .140\n    A.27. hpInput.h. . . . . . . . . . . . . . . . . . . . . . . .146\n    A.28. hpInput.c. . . . . . . . . . . . . . . . . . . . . . . .146\n    A.29. hpOutput.h . . . . . . . . . . . . . . . . . . . . . . .148\n    A.30. hpOutput.c . . . . . . . . . . . . . . . . . . . . . . .148",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    A.31. iCBConstruct.h . . . . . . . . . . . . . . . . . . . . .149\n    A.32. iCBConstruct.c . . . . . . . . . . . . . . . . . . . . .150\n    A.33. iCBSearch.h. . . . . . . . . . . . . . . . . . . . . . .152\n    A.34. iCBSearch.c. . . . . . . . . . . . . . . . . . . . . . .153\n    A.35. LPCdecode.h. . . . . . . . . . . . . . . . . . . . . . .163\n    A.36. LPCdecode.c. . . . . . . . . . . . . . . . . . . . . . .164\n    A.37. LPCencode.h. . . . . . . . . . . . . . . . . . . . . . .167\n    A.38. LPCencode.c. . . . . . . . . . . . . . . . . . . . . . .167\n    A.39. lsf.h. . . . . . . . . . . . . . . . . . . . . . . . . .172\n    A.40. lsf.c. . . . . . . . . . . . . . . . . . . . . . . . . .172\n    A.41. packing.h. . . . . . . . . . . . . . . . . . . . . . . .178\n    A.42. packing.c. . . . . . . . . . . . . . . . . . . . . . . .179\n    A.43. StateConstructW.h. . . . . . . . . . . . . . . . . . . .182\n    A.44. StateConstructW.c. . . . . . . . . . . . . . . . . . . .183\n    A.45. StateSearchW.h . . . . . . . . . . . . . . . . . . . . .185\n    A.46. StateSearchW.c . . . . . . . . . . . . . . . . . . . . .186\n    A.47. syntFilter.h . . . . . . . . . . . . . . . . . . . . . .190\n    A.48. syntFilter.c . . . . . . . . . . . . . . . . . . . . . .190\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . .192\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . .194",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document contains the description of an algorithm for the coding of speech signals sampled at 8 kHz. The algorithm, called iLBC, uses a block-independent linear-predictive coding (LPC) algorithm and has support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms at 13.33 kbit/s. When the codec operates at block lengths of 20 ms, it produces 304 bits per block, which SHOULD be packetized as in [1]. Similarly, for block lengths of 30 ms it produces 400 bits per block, which SHOULD be packetized as in [1]. The two modes for the different frame sizes operate in a very similar way. When they differ it is explicitly stated in the text, usually with the notation x/y, where x refers to the 20 ms mode and y refers to the 30 ms mode.",
      "ja": "この文書では、8kHzでサンプリングされた音声信号の符号化のためのアルゴリズムの記述を含みます。 iLBCのと呼ばれるアルゴリズムは、ブロックに依存しない線形予測符号化（LPC）アルゴリズムを使用し、二つの基本的なフレーム長のためのサポートがあります15.2キロビット/秒で20秒および13.33キロビット/秒で30ミリ秒。コーデックは、20ミリ秒のブロック長で動作するとき、それは、[1]のようにパケット化されるべきであるブロック当たり304ビットを生成します。同様に、30ミリ秒のブロック長のためには、[1]のようにパケット化されるべきであるブロック当たり400ビットを生成します。異なるフレームサイズのための2つのモードは非常に似た方法で動作します。それらが異なる場合には、明示的に、xは20ミリ秒モードとyを指す表記X / Yは、30ミリ秒のモードを指し、通常と、テキストに記載されています。"
    },
    {
      "indent": 3,
      "text": "The described algorithm results in a speech coding system with a controlled response to packet losses similar to what is known from pulse code modulation (PCM) with packet loss concealment (PLC), such as the ITU-T G.711 standard [4], which operates at a fixed bit rate of 64 kbit/s. At the same time, the described algorithm enables fixed bit rate coding with a quality-versus-bit rate tradeoff close to state-of-the-art. A suitable RTP payload format for the iLBC codec is specified in [1].",
      "ja": "例えばITU-T G.711規格としてパケット損失隠蔽（PLC）のパルス符号変調（PCM）から知られているものと同様のパケット損失に対する制御応答を有するシステムを音声符号化で説明したアルゴリズムの結果[4]これは64キロビット/秒の固定ビットレートで動作します。同時に、説明されたアルゴリズムは、最先端に近い品質対ビットレートのトレードオフを有する固定ビットレート符号化を可能にします。 iLBCのコーデックに適したRTPペイロードフォーマットは、[1]で指定されています。"
    },
    {
      "indent": 3,
      "text": "Some of the applications for which this coder is suitable are real time communications such as telephony and videoconferencing, streaming audio, archival, and messaging.",
      "ja": "このコーダは適しているアプリケーションのいくつかは、電話やテレビ会議、ストリーミングオーディオ、アーカイブ、およびメッセージングなどのリアルタイム通信です。"
    },
    {
      "indent": 3,
      "text": "Cable Television Laboratories (CableLabs(R)) has adopted iLBC as a mandatory PacketCable(TM) audio codec standard for VoIP over Cable applications [3].",
      "ja": "ケーブルテレビ・ラボラトリーズ（CableLabsの（R））は、ケーブルのアプリケーション上のVoIPのために必須のPacketCable（TM）オーディオコーデック規格としてiLBCのを採用している[3]。"
    },
    {
      "indent": 3,
      "text": "This document is organized as follows. Section 2 gives a brief outline of the codec. The specific encoder and decoder algorithms are explained in sections 3 and 4, respectively. Appendix A provides a c-code reference implementation.",
      "ja": "次のようにこの文書は、組織化されています。第2節では、コーデックの簡単な概要を提供します。特定のエンコーダおよびデコーダのアルゴリズムは、それぞれ、セクション3と4で説明されています。付録Aは、Cコードのリファレンス実装を提供します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [2].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119に記載されるように解釈される[2]。"
    },
    {
      "indent": 0,
      "text": "2. Outline of the Codec",
      "section_title": true,
      "ja": "コーデックの概要"
    },
    {
      "indent": 3,
      "text": "The codec consists of an encoder and a decoder as described in sections 2.1 and 2.2, respectively.",
      "ja": "それぞれのセクション2.1および2.2に記載のコーデックは、エンコーダとデコーダで構成されています。"
    },
    {
      "indent": 3,
      "text": "The essence of the codec is LPC and block-based coding of the LPC residual signal. For each 160/240 (20 ms/30 ms) sample block, the following major steps are performed: A set of LPC filters are computed, and the speech signal is filtered through them to produce the residual signal. The codec uses scalar quantization of the dominant part, in terms of energy, of the residual signal for the block. The dominant state is of length 57/58 (20 ms/30 ms) samples and forms a start state for dynamic codebooks constructed from the already coded parts of the residual signal. These dynamic codebooks are used to code the remaining parts of the residual signal. By this method, coding independence between blocks is achieved, resulting in elimination of propagation of perceptual degradations due to packet loss. The method facilitates high-quality packet loss concealment (PLC).",
      "ja": "コーデックの本質は、LPCおよびLPC残差信号のブロックベースの符号化です。 LPCフィルタのセットが計算され、音声信号は、残余信号を生成するためにそれらを介して濾過され：各240分の160（20ミリ秒/ 30秒）サンプルブロックに対して、以下の主要なステップが実行されます。コーデックは、ブロックの残差信号のエネルギーの点で、支配的な部分のスカラー量子化を使用します。支配的な状態は、長さの57/58（20秒/ 30秒）のサンプルであり、残差信号の既に符号化された部分から構成された動的なコードブックの開始状態を形成します。これらの動的コードブックは、残差信号の残りの部分を符号化するために使用されます。この方法により、ブロック間の独立性をコーディングすることは、パケット損失による知覚劣化の伝播の排除をもたらす、達成されます。この方法は、高品質のパケット損失隠蔽（PLC）を容易にします。"
    },
    {
      "indent": 0,
      "text": "2.1. Encoder",
      "section_title": true,
      "ja": "2.1。エンコーダ"
    },
    {
      "indent": 3,
      "text": "The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8 kHz. It SHOULD be partitioned into blocks of BLOCKL=160/240 samples for the 20/30 ms frame size. Each block is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each. For 30 ms frame size, the encoder performs two LPC_FILTERORDER=10 linear-predictive coding (LPC) analyses. The first analysis applies a smooth window centered over the second sub-block and extending to the middle of the fifth sub-block. The second LPC analysis applies a smooth asymmetric window centered over the fifth sub-block and extending to the end of the sixth sub-block. For 20 ms frame size, one LPC_FILTERORDER=10 linear-predictive coding (LPC) analysis is performed with a smooth window centered over the third sub-frame.",
      "ja": "エンコーダへの入力は8kHzでサンプリングされた16ビットの均一なPCMであるべきです。これは20/30ミリ秒のフレームサイズに対してBLOCKL = 240分の160サンプルのブロックに分割されるべきです。各ブロックはSUBL = 40個のサンプル毎のNSUB = 4/6つの連続サブブロックに分割されます。 30ミリ秒のフレームサイズのために、エンコーダは= 10、線形予測符号化（LPC）分析2 LPC_FILTERORDERを行います。最初の分析は、第2のサブブロックおよび第5サブブロックの中央に延びる上に中心滑らかなウィンドウを適用します。第LPC分析は、第5サブブロック及び第6サブブロックの端部に延びる上に中心滑らかな非対称ウィンドウを適用します。 20ミリ秒のフレームサイズ、一LPC_FILTERORDER = 10線形予測符号化（LPC）分析を、第3サブフレーム上に中心滑らかなウィンドウを用いて行われます。"
    },
    {
      "indent": 3,
      "text": "For each of the LPC analyses, a set of line-spectral frequencies (LSFs) are obtained, quantized, and interpolated to obtain LSF coefficients for each sub-block. Subsequently, the LPC residual is computed by using the quantized and interpolated LPC analysis filters.",
      "ja": "LPCの各分析のため、線スペクトル周波数（のLSF）のセットは、各サブブロックのLSF係数を得るために、得られた量子化、および補間されます。その後、LPC残差が量子化され、補間LPC分析フィルタを使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "The two consecutive sub-blocks of the residual exhibiting the maximal weighted energy are identified. Within these two sub-blocks, the start state (segment) is selected from two choices: the first 57/58 samples or the last 57/58 samples of the two consecutive sub-blocks. The selected segment is the one of higher energy. The start state is encoded with scalar quantization.",
      "ja": "最大の重み付けされたエネルギーを示す残差の2連続したサブブロックが識別されます。第57/58試料又は二つの連続するサブブロックの最後57/58サンプル：これら2つのサブブロック内で、開始状態（セグメント）は、2つの選択肢の中から選択されます。選択されたセグメントは、より高いエネルギーの一つです。開始状態は、スカラー量子化を用いて符号化されます。"
    },
    {
      "indent": 3,
      "text": "A dynamic codebook encoding procedure is used to encode 1) the 23/22 (20 ms/30 ms) remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the two sub-blocks containing the start state or a 40-sample sub-block. This target can consist of samples indexed forward in time or backward in time, depending on the location of the start state.",
      "ja": "動的コードブック符号化手順は、開始状態を含む2つのサブブロックで1）22分の23（20ミリ秒/ 30秒）残りのサンプルを符号化するために使用されます。 2）時間内の開始状態後のサブブロック。そして3）時間の開始状態の前にサブブロック。これにより、符号化対象は、開始状態を含む2つのサブブロックの残りの22分の23個のサンプルまたは40サンプルのサブブロックのいずれかとすることができます。このターゲットは、開始状態の位置に応じて、時間の時間または後方に前方にインデックス付けのサンプルからなることができます。"
    },
    {
      "indent": 3,
      "text": "The codebook coding is based on an adaptive codebook built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as the target vector, ending at the sample instant prior to the first sample instant represented in the target vector. The codebook is used in CB_NSTAGES=3 stages in a successive refinement approach, and the resulting three code vector gains are encoded with 5-, 4-, and 3-bit scalar quantization, respectively.",
      "ja": "コードブック符号化ブロックの既に符号化部から復号LPC励振サンプルを含むコードブックメモリから構築された適応コードブックに基づいています。これらのサンプルは、標的ベクターに示される第1のサンプル瞬間の前に、サンプル時点で終わる、標的ベクターと同じ時間方向にインデックスされます。コードブックは、連続するリファインメント手法でCB_NSTAGES = 3つの段階で使用され、得られた3つのコードベクトルのゲインはそれぞれ、5-、4-、及び3ビットスカラー量子化で符号化されます。"
    },
    {
      "indent": 3,
      "text": "The codebook search method employs noise shaping derived from the LPC filters, and the main decision criterion is to minimize the squared error between the target vector and the code vectors. Each code vector in this codebook comes from one of CB_EXPAND=2 codebook sections. The first section is filled with delayed, already encoded residual vectors. The code vectors of the second codebook section are constructed by predefined linear combinations of vectors in the first section of the codebook.",
      "ja": "コードブック探索方法は、LPCフィルタに由来する雑音シェーピングを使用し、メイン判定基準は、ターゲットベクトルとコード・ベクトルとの間の二乗誤差を最小にすることです。このコードブックの各コードベクトルはCB_EXPAND = 2コードブックのセクションのいずれかから来ています。最初のセクションは、遅延、既に符号化された残差ベクトルが充填されています。第二のコードブック区間のコードベクトルは、コードブックの最初のセクション内のベクトルの所定の線形結合により構成されています。"
    },
    {
      "indent": 3,
      "text": "As codebook encoding with squared-error matching is known to produce a coded signal of less power than does the scalar quantized start state signal, a gain re-scaling method is implemented by a refined search for a better set of codebook gains in terms of power matching after encoding. This is done by searching for a higher value of the gain factor for the first stage codebook, as the subsequent stage codebook gains are scaled by the first stage gain.",
      "ja": "二乗誤差マッチングとコードブック符号化は、スカラー量子化された開始状態信号の場合よりも少ない電力の符号化信号を生成するために知られているように、利得再スケーリング方法は、電力の点でコードブック利得のより良いセットに対する洗練探索することによって実現されます符号化の後に一致します。これは後段コードブック利得は第一段階ゲインによってスケーリングされるように、第1段目のコードブックのゲイン係数の高い値を検索することによって行われます。"
    },
    {
      "indent": 0,
      "text": "2.2. Decoder",
      "section_title": true,
      "ja": "2.2。デコーダ"
    },
    {
      "indent": 3,
      "text": "Typically for packet communications, a jitter buffer placed at the receiving end decides whether the packet containing an encoded signal block has been received or lost. This logic is not part of the codec described here. For each encoded signal block received the decoder performs a decoding. For each lost signal block, the decoder performs a PLC operation.",
      "ja": "典型的には、パケット通信のため、受信端に配置されたジッタバッファは、符号化された信号ブロックを含むパケットを受信し、または失われているか否かを判断します。このロジックは、ここで説明したコーデックの一部ではありません。各符号化された信号ブロックについて、デコーダは、復号化を行う受信しました。各失われた信号ブロックについて、デコーダは、PLCの動作を行います。"
    },
    {
      "indent": 3,
      "text": "The decoding for each block starts by decoding and interpolating the LPC coefficients. Subsequently the start state is decoded.",
      "ja": "各ブロックの復号は、復号及びLPC係数を補間することによって開始します。その後、スタート状態が復号されます。"
    },
    {
      "indent": 3,
      "text": "For codebook-encoded segments, each segment is decoded by constructing the three code vectors given by the received codebook indices in the same way that the code vectors were constructed in the encoder. The three gain factors are also decoded and the resulting decoded signal is given by the sum of the three codebook vectors scaled with respective gain.",
      "ja": "コードブックに符号化されたセグメントについて、各セグメントは、コードベクトルは、エンコーダで構築されたのと同じ方法で受信されたコードブックインデックスにより指定された3つのコードベクトルを構築することによって復号されます。 3つの利得係数もデコードされ、得られた復号された信号は、それぞれの利得でスケーリング3つのコードブックベクトルの和によって与えられます。"
    },
    {
      "indent": 3,
      "text": "An enhancement algorithm is applied to the reconstructed excitation signal. This enhancement augments the periodicity of voiced speech regions. The enhancement is optimized under the constraint that the modification signal (defined as the difference between the enhanced excitation and the excitation signal prior to enhancement) has a short-time energy that does not exceed a preset fraction of the short-time energy of the excitation signal prior to enhancement.",
      "ja": "強調アルゴリズムは、再構成された励起信号に適用されます。この拡張は、有声音声領域の周期性を増強します。増強は（前向上に向上励起と励起信号との間の差として定義される）修正信号は、励起の短時間エネルギーの予め設定された割合を超えない短時間エネルギーを持つという制約の下で最適化されています信号エンハンスメントの前。"
    },
    {
      "indent": 3,
      "text": "A packet loss concealment (PLC) operation is easily embedded in the decoder. The PLC operation can, e.g., be based on repeating LPC filters and obtaining the LPC residual signal by using a long-term prediction estimate from previous residual blocks.",
      "ja": "パケット損失隠蔽（PLC）操作が容易デコーダに埋め込まれています。 PLCの動作は、例えば、LPCフィルタを繰り返し、前の残差ブロックから長期間予測推定値を用いてLPC残差信号を得ることに基づくことができます。"
    },
    {
      "indent": 0,
      "text": "3. Encoder Principles",
      "section_title": true,
      "ja": "3.エンコーダの原則"
    },
    {
      "indent": 3,
      "text": "The following block diagram is an overview of all the components of the iLBC encoding procedure. The description of the blocks contains references to the section where that particular procedure is further described.",
      "ja": "次のブロック図がiLBCの符号化手順のすべてのコンポーネントの概要です。ブロックの説明は、その特定の手順がさらに説明されるセクションへの参照を含みます。"
    },
    {
      "indent": 3,
      "text": "          +-----------+    +---------+    +---------+\nspeech -> | 1. Pre P  | -> | 2. LPC  | -> | 3. Ana  | ->\n          +-----------+    +---------+    +---------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "   +---------------+   +--------------+\n-> | 4. Start Sel  | ->| 5. Scalar Qu | ->\n   +---------------+   +--------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "      +--------------+    +---------------+\n   -> |6. CB Search  | -> | 7. Packetize  | -> payload\n   |  +--------------+ |  +---------------+\n   ----<---------<------\nsub-frame 0..2/4 (20 ms/30 ms)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.1. Flow chart of the iLBC encoder",
      "ja": "図3.1。 iLBCのエンコーダのフローチャート"
    },
    {
      "indent": 3,
      "text": "1. Pre-process speech with a HP filter, if needed (section 3.1).",
      "section_title": true,
      "ja": "HPフィルタ1.前処理された音声、（セクション3.1）必要な場合。"
    },
    {
      "indent": 3,
      "text": "2. Compute LPC parameters, quantize, and interpolate (section 3.2).",
      "section_title": true,
      "ja": "2.計算LPCパラメータ、量子化、および補間（セクション3.2）。"
    },
    {
      "indent": 3,
      "text": "3. Use analysis filters on speech to compute residual (section 3.3).",
      "section_title": true,
      "ja": "スピーチの3.分析フィルタは、残留（セクション3.3）を計算します。"
    },
    {
      "indent": 3,
      "text": "4. Select position of 57/58-sample start state (section 3.5).",
      "section_title": true,
      "ja": "58分の57サンプルの開始状態の4.位置（セクション3.5）。"
    },
    {
      "indent": 3,
      "text": "5. Quantize the 57/58-sample start state with scalar quantization (section 3.5).",
      "ja": "5.クオンタイズスカラー量子化（セクション3.5）と58分の57サンプルの開始状態。"
    },
    {
      "indent": 3,
      "text": "6. Search the codebook for each sub-frame. Start with 23/22 sample block, then encode sub-blocks forward in time, and then encode sub-blocks backward in time. For each block, the steps in Figure 3.4 are performed (section 3.6).",
      "ja": "前記各サブフレームのためのコードブックを検索します。 22分の23サンプルブロックで始まり、その後、時間的に前方のサブブロックを符号化し、次に時間的に逆方向のサブブロックを符号化します。各ブロックについて、図3.4の手順（セクション3.6）が行われます。"
    },
    {
      "indent": 3,
      "text": "7. Packetize the bits into the payload specified in Table 3.2.",
      "section_title": true,
      "ja": "7.パケット化表3.2に指定されたペイロードにビット。"
    },
    {
      "indent": 3,
      "text": "The input to the encoder SHOULD be 16-bit uniform PCM sampled at 8 kHz. Also it SHOULD be partitioned into blocks of BLOCKL=160/240 samples. Each block input to the encoder is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each.",
      "ja": "エンコーダへの入力は8kHzでサンプリングされた16ビットの均一なPCMであるべきです。また、それはBLOCKL = 240分の160サンプルのブロックに分割されるべきです。エンコーダの各ブロック入力はSUBL = 40個のサンプル毎のNSUB = 4/6つの連続サブブロックに分割されます。"
    },
    {
      "indent": 13,
      "text": "0        39        79       119       159\n+---------------------------------------+\n|    1    |    2    |    3    |    4    |\n+---------------------------------------+\n               20 ms frame",
      "raw": true
    },
    {
      "indent": 3,
      "text": "0        39        79       119       159       199       239\n+-----------------------------------------------------------+\n|    1    |    2    |    3    |    4    |    5    |    6    |\n+-----------------------------------------------------------+\n                               30 ms frame\nFigure 3.2. One input block to the encoder for 20 ms (with four sub-\nframes) and 30 ms (with six sub-frames).",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1. Pre-processing",
      "section_title": true,
      "ja": "3.1。前処理"
    },
    {
      "indent": 3,
      "text": "In some applications, the recorded speech signal contains DC level and/or 50/60 Hz noise. If these components have not been removed prior to the encoder call, they should be removed by a high-pass filter. A reference implementation of this, using a filter with a cutoff frequency of 90 Hz, can be found in Appendix A.28.",
      "ja": "いくつかの用途では、記録された音声信号は、DCレベルおよび/または50/60 Hzのノイズを含んでいます。これらのコンポーネントは、エンコーダの呼び出し前に除去されていない場合は、それらが高域通過フィルタによって除去されなければなりません。 90ヘルツのカットオフ周波数を持つフィルタを使用して、この基準の実装は、付録A.28に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "3.2. LPC Analysis and Quantization",
      "section_title": true,
      "ja": "3.2。 LPC分析および量子化"
    },
    {
      "indent": 3,
      "text": "The input to the LPC analysis module is a possibly high-pass filtered speech buffer, speech_hp, that contains 240/300 (LPC_LOOKBACK + BLOCKL = 80/60 + 160/240 = 240/300) speech samples, where samples 0 through 79/59 are from the previous block and samples 80/60 through 239/299 are from the current block. No look-ahead into the next block is used. For the very first block processed, the look-back samples are assumed to be zeros.",
      "ja": "LPC分析モジュールに入力/ 300分の240（LPC_LOOKBACK + BLOCKL = 60分の80 + 240分の160 = 300分の240）音声サンプル、サンプル0〜79を含有する可能性のハイパスフィルタリングさ音声バッファ、speech_hp、あります図59は、前のブロックからのもので、サンプル299分の239を介して、60分の80は、現在のブロックからのものです。次のブロックに何の先読みが使用されていません。処理された非常に最初のブロックについて、ルックバックサンプルがゼロであると仮定されます。"
    },
    {
      "indent": 3,
      "text": "For each input block, the LPC analysis calculates one/two set(s) of LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation method and the Levinson-Durbin recursion. These coefficients are converted to the Line Spectrum Frequency representation. In the 20 ms case, the single lsf set represents the spectral characteristics as measured at the center of the third sub-block. For 30 ms frames, the first set, lsf1, represents the spectral properties of the input signal at the center of the second sub-block, and the other set, lsf2, represents the spectral characteristics as measured at the center of the fifth sub-block. The details of the computation for 30 ms frames are described in sections 3.2.1 through 3.2.6. Section 3.2.7 explains how the LPC Analysis and Quantization differs for 20 ms frames.",
      "ja": "各入力ブロックについて、LPC分析は、自己相関法とレビンソン - ダービン再帰を使用してLPC_FILTERORDER = 10 LPCフィルタ係数の一/ 2セット（S）を算出します。これらの係数は、線スペクトル周波数表現に変換されます。 20ミリ秒の場合には、単一のLSFセットは、第3サブブロックの中心で測定したスペクトル特性を表します。 30ミリ秒のフレーム、第一セット、LSF1、第2のサブブロックの中心、及び他方の組の入力信号のスペクトル特性を表し、lsf2、第5サブの中心で測定したスペクトル特性を表します。ブロック。 30ミリ秒のフレームの計算の詳細については、セクション3.2.6を介して3.2.1に記載されています。セクション3.2.7は、LPC分析および量子化は、20ミリ秒のフレームのためにどのように異なるかを説明しています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Computation of Autocorrelation Coefficients",
      "section_title": true,
      "ja": "3.2.1。自己相関係数の計算"
    },
    {
      "indent": 3,
      "text": "The first step in the LPC analysis procedure is to calculate autocorrelation coefficients by using windowed speech samples. This windowing is the only difference in the LPC analysis procedure for the two sets of coefficients. For the first set, a 240-sample-long standard symmetric Hanning window is applied to samples 0 through 239 of the input data. The first window, lpc_winTbl, is defined as",
      "ja": "LPC分析手順の最初のステップは、ウィンドウ音声サンプルを用いて自己相関係数を計算することです。このウィンドウは、係数の二組のためのLPC分析手順における唯一の違いです。最初のセットのために、240サンプルの長さの標準対称ハニング窓は、入力データ239を介してサンプルを0に適用されます。第一の窓、lpc_winTblは、のように定義されます"
    },
    {
      "indent": 6,
      "text": "lpc_winTbl[i]= 0.5 * (1.0 - cos((2*PI*(i+1))/(BLOCKL+1))); i=0,...,119 lpc_winTbl[i] = winTbl[BLOCKL - i - 1]; i=120,...,239",
      "ja": "lpc_winTbl [I] = 0.5×（1.0  -  COS（（2 * PI×（I + 1））/（BLOCKL + 1）））。 I = 0、...、119 lpc_winTbl [I] = winTbl [BLOCKL  -  I  -  1]。 I = 120、...、239"
    },
    {
      "indent": 3,
      "text": "The windowed speech speech_hp_win1 is then obtained by multiplying the first 240 samples of the input speech buffer with the window coefficients:",
      "ja": "窓音声speech_hp_win1は、次にウィンドウ係数を用いて入力音声バッファの最初の240個のサンプルを乗算することによって得られます。"
    },
    {
      "indent": 6,
      "text": "speech_hp_win1[i] = speech_hp[i] * lpc_winTbl[i]; i=0,...,BLOCKL-1",
      "ja": "speech_hp_win1 [I] = speech_hp [I] * lpc_winTbl [i]は、 I = 0、...、BLOCKL-1"
    },
    {
      "indent": 3,
      "text": "From these 240 windowed speech samples, 11 (LPC_FILTERORDER + 1) autocorrelation coefficients, acf1, are calculated:",
      "ja": "これら240個のウィンドウ音声サンプルから、11（LPC_FILTERORDER + 1）自己相関係数、ACF1は、計算されます。"
    },
    {
      "indent": 6,
      "text": "acf1[lag] += speech_hp_win1[n] * speech_hp_win1[n + lag]; lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1",
      "ja": "ACF1 [遅れ] + = speech_hp_win1 [N] * speech_hp_win1 [N +ラグ]。ラグ= 0、...、LPC_FILTERORDER。 N = 0、...、BLOCKL-LAG-1"
    },
    {
      "indent": 3,
      "text": "In order to make the analysis more robust against numerical precision problems, a spectral smoothing procedure is applied by windowing the autocorrelation coefficients before the LPC coefficients are computed. Also, a white noise floor is added to the autocorrelation function by multiplying coefficient zero by 1.0001 (40dB below the energy of the windowed speech signal). These two steps are implemented by multiplying the autocorrelation coefficients with the following window:",
      "ja": "数値精度の問題に対する分析をより堅牢にするために、スペクトル平滑化手順は、LPC係数が計算される前に、自己相関係数をウィンドウ処理によって適用されます。また、ホワイトノイズフロアは1.0001（窓音声信号のエネルギー以下40デシベル）で係数がゼロを乗じることによって自己相関関数に追加されます。これらの2つのステップは以下のウィンドウで自己相関係数を乗じて実装されています。"
    },
    {
      "indent": 6,
      "text": "lpc_lagwinTbl[0] = 1.0001;\nlpc_lagwinTbl[i] = exp(-0.5 * ((2 * PI * 60.0 * i) /FS)^2);\n         i=1,...,LPC_FILTERORDER\n         where FS=8000 is the sampling frequency",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Then, the windowed acf function acf1_win is obtained by",
      "ja": "次に、ウィンドウACF関数acf1_winをすることによって得られます"
    },
    {
      "indent": 6,
      "text": "acf1_win[i] = acf1[i] * lpc_lagwinTbl[i]; i=0,...,LPC_FILTERORDER",
      "ja": "acf1_win [I] = ACF1 [I] * lpc_lagwinTbl [i]は、 I = 0、...、LPC_FILTERORDER"
    },
    {
      "indent": 3,
      "text": "The second set of autocorrelation coefficients, acf2_win, are obtained in a similar manner. The window, lpc_asymwinTbl, is applied to samples 60 through 299, i.e., the entire current block. The window consists of two segments, the first (samples 0 to 219) being half a Hanning window with length 440 and the second a quarter of a cycle of a cosine wave. By using this asymmetric window, an LPC analysis centered in the fifth sub-block is obtained without the need for any look-ahead, which would add delay. The asymmetric window is defined as",
      "ja": "自己相関係数の第2のセットは、acf2_win、同様の方法で得られます。窓、lpc_asymwinTblは、60 299、すなわち、全体の現在のブロックを介してサンプルに適用されます。ウィンドウは、長さ440及び余弦波の周期の第二期を有する半ハニング窓されている2つのセグメント、第一（219サンプル0）から成ります。この非対称ウィンドウを使用することにより、第5サブブロックを中心にLPC分析は、遅延を追加する任意の先読みを必要とせずに得られます。非対称ウインドウは以下のように定義されます"
    },
    {
      "indent": 6,
      "text": "lpc_asymwinTbl[i] = (sin(PI * (i + 1) / 441))^2; i=0,...,219",
      "ja": "lpc_asymwinTbl [I] =（SIN（PI×（I + 1）/ 441））^ 2。 I = 0、...、219"
    },
    {
      "indent": 6,
      "text": "lpc_asymwinTbl[i] = cos((i - 220) * PI / 40); i=220,...,239",
      "ja": "lpc_asymwinTbl [I] = COS（（I  -  220）* PI / 40）。 I = 220、...、239"
    },
    {
      "indent": 3,
      "text": "and the windowed speech is computed by",
      "ja": "そして、ウィンドウスピーチをすることにより計算されます"
    },
    {
      "indent": 6,
      "text": "speech_hp_win2[i] = speech_hp[i + LPC_LOOKBACK] * lpc_asymwinTbl[i]; i=0,....BLOCKL-1",
      "ja": "speech_hp_win2は[I] = speech_hp [iがLPC_LOOKBACK +] * lpc_asymwinTbl [I]。 I = 0、... BLOCKL-1"
    },
    {
      "indent": 3,
      "text": "The windowed autocorrelation coefficients are then obtained in exactly the same way as for the first analysis instance.",
      "ja": "窓自己相関係数は、その後、第1の解析例とまったく同じ方法で得られます。"
    },
    {
      "indent": 3,
      "text": "The generation of the windows lpc_winTbl, lpc_asymwinTbl, and lpc_lagwinTbl are typically done in advance, and the arrays are stored in ROM rather than repeating the calculation for every block.",
      "ja": "窓lpc_winTbl、lpc_asymwinTbl、及びlpc_lagwinTblの世代は、典型的には、事前に行われ、そして配列はなくブロックごとに計算を繰り返すよりも、ROMに格納されています。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Computation of LPC Coefficients",
      "section_title": true,
      "ja": "3.2.2。 LPC係数の計算"
    },
    {
      "indent": 3,
      "text": "From the 2 x 11 smoothed autocorrelation coefficients, acf1_win and acf2_win, the 2 x 11 LPC coefficients, lp1 and lp2, are calculated in the same way for both analysis locations by using the well known Levinson-Durbin recursion. The first LPC coefficient is always 1.0, resulting in ten unique coefficients.",
      "ja": "2×11平滑化自己相関係数、acf1_win及びacf2_win、2×11 LPC係数、LP1とLP2から、周知のレビンソン - ダービン再帰を使用して、両方の分析の位置について同様に計算されます。最初のLPC係数は、10のユニーク係数が得られ、常に1.0です。"
    },
    {
      "indent": 3,
      "text": "After determining the LPC coefficients, a bandwidth expansion procedure is applied to smooth the spectral peaks in the short-term spectrum. The bandwidth addition is obtained by the following modification of the LPC coefficients:",
      "ja": "LPC係数を決定した後に、帯域幅拡張手順は、短期スペクトルにおけるスペクトルピークを平滑化するために適用されます。帯域幅の付加は、LPC係数の次の改変により得られます。"
    },
    {
      "indent": 6,
      "text": "lp1_bw[i] = lp1[i] * chirp^i; i=0,...,LPC_FILTERORDER lp2_bw[i] = lp2[i] * chirp^i; i=0,...,LPC_FILTERORDER",
      "ja": "lp1_bw [I] = LP1 [I] *チャープ^ I; I = 0、...、LPC_FILTERORDER lp2_bw [I] = LP2 [I] *チャープ^ I; I = 0、...、LPC_FILTERORDER"
    },
    {
      "indent": 3,
      "text": "where \"chirp\" is a real number between 0 and 1. It is RECOMMENDED to use a value of 0.9.",
      "ja": "「チャープ」は、0と1の間の実数である場合には0.9の値を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Computation of LSF Coefficients from LPC Coefficients",
      "section_title": true,
      "ja": "3.2.3。 LPC係数からLSF係数の計算"
    },
    {
      "indent": 3,
      "text": "Thus far, two sets of LPC coefficients that represent the short-term spectral characteristics of the speech signal for two different time locations within the current block have been determined. These coefficients SHOULD be quantized and interpolated. Before this is done, it is advantageous to convert the LPC parameters into another type of representation called Line Spectral Frequencies (LSF). The LSF parameters are used because they are better suited for quantization and interpolation than the regular LPC coefficients. Many computationally efficient methods for calculating the LSFs from the LPC coefficients have been proposed in the literature. The detailed implementation of one applicable method can be found in Appendix A.26. The two arrays of LSF coefficients obtained, lsf1 and lsf2, are of dimension 10 (LPC_FILTERORDER).",
      "ja": "これまでのところ、現在のブロック内の二つの異なる時間位置について音声信号の短期スペクトル特性を表すLPC係数の二組が決定されています。これらの係数は、量子化と補間されるべきです。これが行われる前に、線スペクトル周波数（LSF）と呼ばれる表現の別の型にLPCパラメータに変換することが有利です。彼らは通常のLPC係数よりも量子化と補間に適しているので、LSFパラメータが使用されています。 LPC係数からのLSFを算出するための多くの計算上効率的な方法は、文献に提案されています。 1つの適用可能な方法の詳細な実装は、付録A.26に記載されています。得られたLSF係数の二つの配列、LSF1とlsf2は、寸法10（LPC_FILTERORDER）です。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Quantization of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.4。 LSF係数の量子化"
    },
    {
      "indent": 3,
      "text": "Because the LPC filters defined by the two sets of LSFs are also needed in the decoder, the LSF parameters need to be quantized and transmitted as side information. The total number of bits required to represent the quantization of the two LSF representations for one block of speech is 40, with 20 bits used for each of lsf1 and lsf2.",
      "ja": "LSFの二組によって定義されたLPCフィルタもデコーダで必要とされるため、LSFパラメータは、量子化及びサイド情報として送信される必要があります。 20ビットがLSF1とlsf2のそれぞれに使用してスピーチの一つのブロックのための2つのLSF表現の量子化を表すのに必要なビットの総数は、40です。"
    },
    {
      "indent": 3,
      "text": "For computational and storage reasons, the LSF vectors are quantized using three-split vector quantization (VQ). That is, the LSF vectors are split into three sub-vectors that are each quantized with a regular VQ. The quantized versions of lsf1 and lsf2, qlsf1 and qlsf2, are obtained by using the same memoryless split VQ. The length of each of these two LSF vectors is 10, and they are split into three sub-vectors containing 3, 3, and 4 values, respectively.",
      "ja": "計算および貯蔵の理由から、LSFベクト​​ルは三分割ベクトル量子化（VQ）を使用して量子化されます。すなわち、LSFベクト​​ルは、各正規VQで量子化する3つのサブベクトルに分割されます。 LSF1とlsf2、qlsf1とqlsf2の量子化されたバージョンは、同じメモリレス分割VQを使用することによって得られます。これら二つのLSFベクト​​ルのそれぞれの長さは10であり、それらは、それぞれ、3,3、および4の値を含む3つのサブベクトルに分割されます。"
    },
    {
      "indent": 3,
      "text": "For each of the sub-vectors, a separate codebook of quantized values has been designed with a standard VQ training method for a large database containing speech from a large number of speakers recorded under various conditions. The size of each of the three codebooks associated with the split definitions above is",
      "ja": "サブベクトルのそれぞれについて、量子化された値の別個のコードブックは、様々な条件下で記録されたスピーカーの多数からの音声を含む大規模なデータベースの標準VQ学習法を用いて設計されています。分割定義に関連する3つのコードブックの各々のサイズは、上記で"
    },
    {
      "indent": 6,
      "text": "int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};",
      "ja": "INT size_lsfCbTbl [LSF_NSPLIT] = {64128128}。"
    },
    {
      "indent": 3,
      "text": "The actual values of the vector quantization codebook that must be used can be found in the reference code of Appendix A. Both sets of LSF coefficients, lsf1 and lsf2, are quantized with a standard memoryless split vector quantization (VQ) structure using the squared error criterion in the LSF domain. The split VQ quantization consists of the following steps:",
      "ja": "付録Aの参照符号でLSF係数、LSF1とlsf2、両方のセットを見つけることができる使用されなければならないベクトル量子化コードブックの実際の値は、二乗誤差を使用して、標準メモリレス分割ベクトル量子化（VQ）の構造を有する量子化されますLSFドメイン内の基準。スプリットVQの量子化は、次の手順で構成されます。"
    },
    {
      "indent": 3,
      "text": "1) Quantize the first three LSF coefficients (1 - 3) with a VQ codebook of size 64. 2) Quantize the next three LSF coefficients 4 - 6 with VQ a codebook of size 128. 3) Quantize the last four LSF coefficients (7 - 10) with a VQ codebook of size 128.",
      "ja": "）サイズ64 2のVQコードブックを有する3）4次の3つのLSF係数を量子化する -   -  1）最初の三つのLSF係数（1を量子化VQと6サイズ128 3のコードブック）の最後の4つのLSF係数を量子化する（7 - サイズ128のVQコードブック10）。"
    },
    {
      "indent": 3,
      "text": "This procedure, repeated for lsf1 and lsf2, gives six quantization indices and the quantized sets of LSF coefficients qlsf1 and qlsf2. Each set of three indices is encoded with 6 + 7 + 7 = 20 bits. The total number of bits used for LSF quantization in a block is thus 40 bits.",
      "ja": "LSF1とlsf2について繰り返し、この手順は、六の量子化インデックスとqlsf1とqlsf2 LSF係数の量子化されたセットを与えます。 3つのインデックスの各セットは、6 + 7 + 7 = 20ビットで符号化されます。ブロックでLSFの量子化に使用されるビットの総数は、したがって40ビットです。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Stability Check of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.5。 LSF係数の安定性を確認"
    },
    {
      "indent": 3,
      "text": "The LSF representation of the LPC filter has the convenient property that the coefficients are ordered by increasing value, i.e., lsf(n-1) < lsf(n), 0 < n < 10, if the corresponding synthesis filter is stable. As we are employing a split VQ scheme, it is possible that at the split boundaries the LSF coefficients are not ordered correctly and hence that the corresponding LP filter is unstable. To ensure that the filter used is stable, a stability check is performed for the quantized LSF vectors. If it turns out that the coefficients are not ordered appropriately (with a safety margin of 50 Hz to ensure that formant peaks are not too narrow), they will be moved apart. The detailed method for this can be found in Appendix A.40. The same procedure is performed in the decoder. This ensures that exactly the same LSF representations are used in both encoder and decoder.",
      "ja": "LPCフィルタのLSF表現は、対応する合成フィルタが安定である場合、係数は、nは増加する値、すなわち、LSF（N-1）<LSF（n）は、0 <a <10によって順序付けられる便利な特性を有しています。我々は、スプリットVQ方式を採用しているとして、分割境界でLSF係数は、対応するLPフィルタが不安定であることを正しくので、注文されていない可能性があります。使用されるフィルタが安定であることを保証するために、安定性チェックは、量子化されたLSFベクト​​ルに対して行われます。それは係数が（フォルマントピークが狭すぎないことを保証するために、50ヘルツの安全マージンで）適切に順序付けされていないことが判明した場合、それらは離れて移動することになります。このための具体的な方法は、付録A.40に記載されています。同じ手順が、デコーダで行われます。これは、全く同じLSF表現は、エンコーダおよびデコーダの両方で使用されることを保証します。"
    },
    {
      "indent": 0,
      "text": "3.2.6. Interpolation of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.6。 LSF係数の補間"
    },
    {
      "indent": 3,
      "text": "From the two sets of LSF coefficients that are computed for each block of speech, different LSFs are obtained for each sub-block by means of interpolation. This procedure is performed for the original LSFs (lsf1 and lsf2), as well as the quantized versions qlsf1 and qlsf2, as both versions are used in the encoder. Here follows a brief summary of the interpolation scheme; the details are found in the c-code of Appendix A. In the first sub-block, the average of the second LSF vector from the previous block and the first LSF vector in the current block is used. For sub-blocks two through five, the LSFs used are obtained by linear interpolation from lsf1 (and qlsf1) to lsf2 (and qlsf2), with lsf1 used in sub-block two and lsf2 in sub-block five. In the last sub-block, lsf2 is used. For the very first block it is assumed that the last LSF vector of the previous block is equal to a predefined vector, lsfmeanTbl, obtained by calculating the mean LSF vector of the LSF design database.",
      "ja": "スピーチの各ブロックについて計算されるLSF係数の二組から、異なるのLSFは、補間によって各サブブロックについて得られます。両方のバージョンは、エンコーダで使用されているように、この手順は、元のLSF（LSF1とlsf2）、ならびにqlsf1とqlsf2量子化されたバージョンに対して実行されます。ここで補間スキームの概要は、以下;詳細は最初のサブブロックの付録AのCコードで発見され、前のブロックと現在のブロックの最初のLSFベクト​​ルから第LSFベクト​​ルの平均値が使用されます。サブブロック5を介して2つのために、使用のLSFはlsf2（及びqlsf2）にLSF1（及びqlsf1）から線形補間によって得られる、サブブロック5サブブロック2とlsf2に使用LSF1有します。最後のサブブロックにおいて、lsf2が使用されます。非常に最初のブロックのためには、前のブロックの最後のLSFベクト​​ルは、LSF設計データベースの平均LSFベクト​​ルを計算することによって得られた事前定義されたベクトル、lsfmeanTbl、に等しいと仮定されます。"
    },
    {
      "indent": 3,
      "text": "lsfmeanTbl[LPC_FILTERORDER] = {0.281738, 0.445801, 0.663330, 0.962524, 1.251831, 1.533081, 1.850586, 2.137817, 2.481445, 2.777344}",
      "ja": "lsfmeanTbl [LPC_FILTERORDER] = {0.281738、0.445801、0.663330、0.962524、1.251831、1.533081、1.850586、2.137817、2.481445、2.777344}"
    },
    {
      "indent": 3,
      "text": "The interpolation method is standard linear interpolation in the LSF domain. The interpolated LSF values are converted to LPC coefficients for each sub-block. The unquantized and quantized LPC coefficients form two sets of filters respectively. The unquantized analysis filter for sub-block k is defined as follows",
      "ja": "補間方法は、LSFドメインにおける標準的な線形補間です。補間LSF値は、各サブブロックのためのLPC係数に変換されます。非量子化及び量子化されたLPC係数はそれぞれフィルタの二組を形成します。次のようにサブブロックkの量子化されていない分析フィルタが定義されています"
    },
    {
      "indent": 6,
      "text": "          ___\n          \\\nAk(z)= 1 + > ak(i)*z^(-i)\n          /__\n       i=1...LPC_FILTERORDER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The quantized analysis filter for sub-block k is defined as follows\n              ___\n              \\\n   A~k(z)= 1 + > a~k(i)*z^(-i)\n              /__\n          i=1...LPC_FILTERORDER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A reference implementation of the lsf encoding is given in Appendix A.38. A reference implementation of the corresponding decoding can be found in Appendix A.36.",
      "ja": "LSF符号化のリファレンス実装は、付録A.38で与えられます。対応する復号のリファレンス実装は、付録A.36に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "3.2.7. LPC Analysis and Quantization for 20 ms Frames",
      "section_title": true,
      "ja": "3.2.7。 20ミリ秒のフレームのLPC分析および量子化"
    },
    {
      "indent": 3,
      "text": "As previously stated, the codec only calculates one set of LPC parameters for the 20 ms frame size as opposed to two sets for 30 ms frames. A single set of autocorrelation coefficients is calculated on the LPC_LOOKBACK + BLOCKL = 80 + 160 = 240 samples. These samples are windowed with the asymmetric window lpc_asymwinTbl, centered over the third sub-frame, to form speech_hp_win. Autocorrelation coefficients, acf, are calculated on the 240 samples in speech_hp_win and then windowed exactly as in section 3.2.1 (resulting in acf_win).",
      "ja": "先に述べたように、コーデックは、30ミリ秒のフレームのための2つのセットとは対照的に、20msのフレームサイズのLPCパラメータの一組を算出します。自己相関係数の単一セットがLPC_LOOKBACK + BLOCKL = 80 + 160 = 240個のサンプルに基づいて計算されます。これらのサンプルはspeech_hp_win形成するために、第3のサブフレーム上に中心非対称ウィンドウlpc_asymwinTblと窓れます。自己相関係数ACFは、speech_hp_winで240個のサンプルに基づいて計算した後（acf_winもたらす）セクション3.2.1のように正確に窓れます。"
    },
    {
      "indent": 3,
      "text": "This single set of windowed autocorrelation coefficients is used to calculate LPC coefficients, LSF coefficients, and quantized LSF coefficients in exactly the same manner as in sections 3.2.3 through 3.2.4. As for the 30 ms frame size, the ten LSF coefficients are divided into three sub-vectors of size 3, 3, and 4 and quantized by using the same scheme and codebook as in section 3.2.4 to finally get 3 quantization indices. The quantized LSF coefficients are stabilized with the algorithm described in section 3.2.5.",
      "ja": "ウィンドウの自己相関係数のこの単一のセットは、セクション3.2.4を介して3.2.3と全く同様にLPC係数、LSF係数、及び量子化されたLSF係数を計算するために使用されます。 30ミリ秒のフレームサイズについては、10のLSF係数は、最終的に3量子化インデックスを取得するために、セクション3.2.4と同じスキームとコードブックを使用して、サイズ3,3、及び4と量子化の三つのサブベクトルに分割されます。量子化されたLSF係数は、セクション3.2.5で説明したアルゴリズムを用いて安定化されます。"
    },
    {
      "indent": 3,
      "text": "From the set of LSF coefficients computed for this block and those from the previous block, different LSFs are obtained for each sub-block by means of interpolation. The interpolation is done linearly in the LSF domain over the four sub-blocks, so that the n-th sub- frame uses the weight (4-n)/4 for the LSF from old frame and the weight n/4 of the LSF from the current frame. For the very first block the mean LSF, lsfmeanTbl, is used as the LSF from the previous block. Similarly as seen in section 3.2.6, both unquantized, A(z), and quantized, A~(z), analysis filters are calculated for each of the four sub-blocks.",
      "ja": "このブロックと前のブロックからのものに対して計算LSF係数のセットから、別のLSFは、補間によって各サブブロックについて得られます。 n番目のサブフレームが古いフレームからLSFおよびLSFの重量N / 4の重み（4-N）/ 4を使用するよう補間は、4つのサブブロック上LSF領域において直線的に行われます現在のフレームから。非常に最初のブロックについての平均LSF、lsfmeanTblは、前のブロックからのLSFとして使用されます。同様に、量子化されていない（z）の両方、セクション3.2.6に見られ、そしてA〜（z）は、量子化されたように、分析フィルタは、4つのサブブロックの各々に対して計算されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Calculation of the Residual",
      "section_title": true,
      "ja": "3.3。残留の計算"
    },
    {
      "indent": 3,
      "text": "The block of speech samples is filtered by the quantized and interpolated LPC analysis filters to yield the residual signal. In particular, the corresponding LPC analysis filter for each 40 sample sub-block is used to filter the speech samples for the same sub-block. The filter memory at the end of each sub-block is carried over to the LPC filter of the next sub-block. The signal at the output of each LP analysis filter constitutes the residual signal for the corresponding sub-block.",
      "ja": "音声サンプルのブロックは、残差信号を生成する量子化と補間LPC分析フィルタによってフィルタリングされます。具体的には、各40サンプルのサブブロックのための対応するLPC分析フィルタは、同一のサブブロックのための音声サンプルをフィルタリングするために使用されます。各サブブロックの終了時にフィルタメモリは、次のサブブロックのLPCフィルタに持ち越されます。各LP分析フィルタの出力での信号は、対応するサブブロックの残差信号を構成します。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the LPC analysis filters is given in Appendix A.10.",
      "ja": "LPC分析フィルタのリファレンス実装は、付録A.10に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.4. Perceptual Weighting Filter",
      "section_title": true,
      "ja": "3.4。聴覚重み付けフィルタ"
    },
    {
      "indent": 3,
      "text": "In principle any good design of a perceptual weighting filter can be applied in the encoder without compromising this codec definition. However, it is RECOMMENDED to use the perceptual weighting filter Wk for sub-block k specified below:",
      "ja": "原理的には聴覚重み付けフィルタの良いデザインは、このコーデック定義を損なうことなく、エンコーダにも適用することができます。しかし、以下の指定されたサブブロックkに対して知覚的重み付けフィルタWkのを使用することが推奨されます。"
    },
    {
      "indent": 6,
      "text": "Wk(z)=1/Ak(z/LPC_CHIRP_WEIGHTDENUM), where LPC_CHIRP_WEIGHTDENUM = 0.4222",
      "ja": "週（Z）= 1 / Akは（Z / LPC_CHIRP_WEIGHTDENUM）、LPC_CHIRP_WEIGHTDENUM = 0.4222"
    },
    {
      "indent": 3,
      "text": "This is a simple design with low complexity that is applied in the LPC residual domain. Here Ak(z) is the filter obtained for sub-block k from unquantized but interpolated LSF coefficients.",
      "ja": "これは、LPC残差のドメインに適用される低複雑とシンプルなデザインです。ここでAkは（z）は量子化されていないが、補間されたLSF係数からサブブロックkについて得られたフィルタです。"
    },
    {
      "indent": 0,
      "text": "3.5. Start State Encoder",
      "section_title": true,
      "ja": "3.5。スタートステートエンコーダ"
    },
    {
      "indent": 3,
      "text": "The start state is quantized by using a common 6-bit scalar quantizer for the block and a 3-bit scalar quantizer operating on scaled samples in the weighted speech domain. In the following we describe the state encoding in greater detail.",
      "ja": "開始状態は、ブロックのための一般的な6ビットのスカラ量子化加重音声ドメインにスケーリングサンプル上で動作する3ビットスカラー量子化器を用いて量子化されます。以下では、我々は、より詳細に状態エンコーディングを記述する。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Start State Estimation",
      "section_title": true,
      "ja": "3.5.1。スタート状態推定"
    },
    {
      "indent": 3,
      "text": "The two sub-blocks containing the start state are determined by finding the two consecutive sub-blocks in the block having the highest power. Advantageously, down-weighting is used in the beginning and end of the sub-frames, i.e., the following measure is computed (NSUB=4/6 for 20/30 ms frame size):",
      "ja": "開始状態を含む2つのサブブロックは、最高パワーを持つブロックに二つの連続するサブブロックを見つけることによって決定されます。ダウン重み付けを開始し、サブフレームの最後に使用され、有利には、すなわち、以下の尺度は（20/30ミリ秒のフレームサイズのNSUB = 4/6）で計算されます。"
    },
    {
      "indent": 6,
      "text": "nsub=1,...,NSUB-1\nssqn[nsub] = 0.0;\nfor (i=(nsub-1)*SUBL; i<(nsub-1)*SUBL+5; i++)\n         ssqn[nsub] += sampEn_win[i-(nsub-1)*SUBL]*\n                           residual[i]*residual[i];\nfor (i=(nsub-1)*SUBL+5; i<(nsub+1)*SUBL-5; i++)\n         ssqn[nsub] += residual[i]*residual[i];\nfor (i=(nsub+1)*SUBL-5; i<(nsub+1)*SUBL; i++)\n         ssqn[nsub] += sampEn_win[(nsub+1)*SUBL-i-1]*\n                           residual[i]*residual[i];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where sampEn_win[5]={1/6, 2/6, 3/6, 4/6, 5/6}; MAY be used. The sub-frame number corresponding to the maximum value of ssqEn_win[nsub-1]*ssqn[nsub] is selected as the start state indicator. A weighting of ssqEn_win[]={0.8,0.9,1.0,0.9,0.8} for 30 ms frames and ssqEn_win[]={0.9,1.0,0.9} for 20 ms frames; MAY advantageously be used to bias the start state towards the middle of the frame.",
      "ja": "ここsampEn_win [5] = {1/6、2/6、3/6、4/6、5/6}。使用されるかもしれません。 ssqEn_winの最大値に対応するサブフレームの番号が[NSUB-1] * ssqn [NSUB]開始状態インジケータとして選択されます。 ssqEn_winの重み付け30ミリ秒のフレームの[] = {0.8,0.9,1.0,0.9,0.8}及び20msのフレームに対するssqEn_win [] = {0.9,1.0,0.9}。有利には、フレームの中央に向かって開始状態バイアスするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "For 20 ms frames there are three possible positions for the two-sub-block length maximum power segment; the start state position is encoded with 2 bits. The start state position, start, MUST be encoded as",
      "ja": "20msの二サブブロック長の最大電力セグメントのための3つの可能な位置があるフレーム。開始状態位置が2ビットで符号化されます。状態の開始位置、開始、として符号化されなければなりません"
    },
    {
      "indent": 6,
      "text": "start=1: start state in sub-frame 0 and 1 start=2: start state in sub-frame 1 and 2 start=3: start state in sub-frame 2 and 3",
      "ja": "サブフレーム1及び2スタート= 3で開始状態：サブフレーム0及び1つの開始= 2状態を開始：= 1を起動し、サブフレーム2及び3において開始状態"
    },
    {
      "indent": 3,
      "text": "For 30 ms frames there are five possible positions of the two-sub-block length maximum power segment, the start state position is encoded with 3 bits. The start state position, start, MUST be encoded as",
      "ja": "30ミリ秒のフレームのための二サブブロック長の最大電力セグメントの5つの位置があり、開始状態位置は、3ビットで符号化されます。状態の開始位置、開始、として符号化されなければなりません"
    },
    {
      "indent": 6,
      "text": "start=1: start state in sub-frame 0 and 1 start=2: start state in sub-frame 1 and 2 start=3: start state in sub-frame 2 and 3 start=4: start state in sub-frame 3 and 4 start=5: start state in sub-frame 4 and 5",
      "ja": "サブフレーム2及び3開始= 4で開始状態：サブフレーム1及び2スタート= 3で開始状態：サブフレーム0及び1つの開始= 2状態を開始：= 1を起動し、サブフレーム3の開始状態そして4スタート= 5：サブフレーム4及び5に開始状態"
    },
    {
      "indent": 3,
      "text": "Hence, in both cases, index 0 is not used. In order to shorten the start state for bit rate efficiency, the start state is brought down to STATE_SHORT_LEN=57 samples for 20 ms frames and STATE_SHORT_LEN=58 samples for 30 ms frames. The power of the first 23/22 and last 23/22 samples of the two sub-frame blocks identified above is computed as the sum of the squared signal sample values, and the 23/22-sample segment with the lowest power is excluded from the start state. One bit is transmitted to indicate which of the two possible 57/58 sample segments is used. The start state position within the two sub-frames determined above, state_first, MUST be encoded as",
      "ja": "したがって、両方の場合において、インデックス0が使用されません。ビットレート効率の開始状態を短縮するために、開始状態は、30ミリ秒のフレームを20ミリ秒のフレームとSTATE_SHORT_LEN = 58個のサンプルについてSTATE_SHORT_LEN = 57個のサンプルに倒されます。上記識別される2つのサブフレームブロックの最初の22分の23と最後の22分の23個のサンプルの電力は、二乗信号サンプル値の和として計算され、最小の消費電力と22分の23サンプルセグメントは対象から除外されます開始状態。 1ビットが使用される二つの可能な57/58試料セグメントのかを示すために送信されます。上記決定された2つのサブフレーム内の開始状態位置は、state_first、として符号化されなければなりません"
    },
    {
      "indent": 6,
      "text": "state_first=1: start state is first STATE_SHORT_LEN samples state_first=0: start state is last STATE_SHORT_LEN samples",
      "ja": "state_first = 1：開始状態は、第STATE_SHORT_LENサンプルstate_first = 0：状態は最後STATE_SHORT_LENサンプルで開始します"
    },
    {
      "indent": 0,
      "text": "3.5.2. All-Pass Filtering and Scale Quantization",
      "section_title": true,
      "ja": "3.5.2。オールパスフィルタリングとスケール量子化"
    },
    {
      "indent": 3,
      "text": "The block of residual samples in the start state is first filtered by an all-pass filter with the quantized LPC coefficients as denominator and reversed quantized LPC coefficients as numerator. The purpose of this phase-dispersion filter is to get a more even distribution of the sample values in the residual signal. The filtering is performed by circular convolution, where the initial filter memory is set to zero.",
      "ja": "開始状態の残留サンプルのブロックは、最初の分母として量子化されたLPC係数を有する全通過フィルタによってフィルタリングし、分子として量子化されたLPC係数を反転させます。この位相分散フィルタの目的は、残差信号のサンプル値のより均一な分布を得ることです。フィルタリングは、初期フィルタメモリがゼロに設定されている円形の畳み込みによって行われます。"
    },
    {
      "indent": 6,
      "text": "res(0..(STATE_SHORT_LEN-1)) = uncoded start state residual res((STATE_SHORT_LEN)..(2*STATE_SHORT_LEN-1)) = 0",
      "ja": "RES（0 ..（STATE_SHORT_LEN-1））=未符号化開始状態残留RES（（STATE_SHORT_LEN）..（2 * STATE_SHORT_LEN-1））= 0"
    },
    {
      "indent": 6,
      "text": "Pk(z) = A~rk(z)/A~k(z), where\n                             ___\n                             \\\nA~rk(z)= z^(-LPC_FILTERORDER)+>a~k(i+1)*z^(i-(LPC_FILTERORDER-1))\n                             /__\n                         i=0...(LPC_FILTERORDER-1)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "and A~k(z) is taken from the block where the start state begins",
      "ja": "開始状態が始まるとA〜K（z）は、ブロックから取られます"
    },
    {
      "indent": 6,
      "text": "res -> Pk(z) -> filtered",
      "ja": "真 - > Pkの（Z） - >フィルター処理"
    },
    {
      "indent": 6,
      "text": "ccres(k) = filtered(k) + filtered(k+STATE_SHORT_LEN), k=0..(STATE_SHORT_LEN-1)",
      "ja": "CCRES（K）=濾過（A）+（+ STATE_SHORT_LENに）、濾過し、K = 0 ..（STATE_SHORT_LEN-1）"
    },
    {
      "indent": 3,
      "text": "The all-pass filtered block is searched for its largest magnitude sample. The 10-logarithm of this magnitude is quantized with a 6-bit quantizer, state_frgqTbl, by finding the nearest representation.",
      "ja": "オールパスフィルタブロックは、その最大の大きさのサンプルを探しています。この大きさの10対数は、最も近い表現を見つけることによって、6ビットの量子化器、state_frgqTblで量子化されます。"
    },
    {
      "indent": 3,
      "text": "This results in an index, idxForMax, corresponding to a quantized value, qmax. The all-pass filtered residual samples in the block are then multiplied with a scaling factor scal=4.5/(10^qmax) to yield normalized samples.",
      "ja": "これはQmaxと、量子化値に対応する、インデックス、idxForMaxもたらします。ブロック内のすべてのパスの濾過残留サンプルを次にスケーリング係数年度と乗算さ= 4.5 /（10 ^ Qmaxの）正規化されたサンプルを得ました。"
    },
    {
      "indent": 3,
      "text": "state_frgqTbl[64] = {1.000085, 1.071695, 1.140395, 1.206868, 1.277188, 1.351503, 1.429380, 1.500727, 1.569049, 1.639599, 1.707071, 1.781531, 1.840799, 1.901550, 1.956695, 2.006750, 2.055474, 2.102787, 2.142819, 2.183592, 2.217962, 2.257177, 2.295739, 2.332967, 2.369248, 2.402792, 2.435080, 2.468598, 2.503394, 2.539284, 2.572944, 2.605036, 2.636331, 2.668939, 2.698780, 2.729101, 2.759786, 2.789834, 2.818679, 2.848074, 2.877470, 2.906899, 2.936655, 2.967804, 3.000115, 3.033367, 3.066355, 3.104231, 3.141499, 3.183012, 3.222952, 3.265433, 3.308441, 3.350823, 3.395275, 3.442793, 3.490801, 3.542514, 3.604064, 3.666050, 3.740994, 3.830749, 3.938770, 4.101764}",
      "ja": "state_frgqTbl [64] = {1.000085、1.071695、1.140395、1.206868、1.277188、1.351503、1.429380、1.500727、1.569049、1.639599、1.707071、1.781531、1.840799、1.901550、1.956695、2.006750、2.055474、2.102787、2.142819、2.183592、2.217962、2.257177、 2.295739、2.332967、2.369248、2.402792、2.435080、2.468598、2.503394、2.539284、2.572944、2.605036、2.636331、2.668939、2.698780、2.729101、2.759786、2.789834、2.818679、2.848074、2.877470、2.906899、2.936655、2.967804、3.000115、3.033367、3.066355、 3.104231、3.141499、3.183012、3.222952、3.265433、3.308441、3.350823、3.395275、3.442793、3.490801、3.542514、3.604064、3.666050、3.740994、3.830749、3.938770、4.101764}"
    },
    {
      "indent": 0,
      "text": "3.5.3. Scalar Quantization",
      "section_title": true,
      "ja": "3.5.3。スカラ量子化"
    },
    {
      "indent": 3,
      "text": "The normalized samples are quantized in the perceptually weighted speech domain by a sample-by-sample scalar DPCM quantization as depicted in Figure 3.3. Each sample in the block is filtered by a weighting filter Wk(z), specified in section 3.4, to form a weighted speech sample x[n]. The target sample d[n] is formed by subtracting a predicted sample y[n], where the prediction filter is given by",
      "ja": "図3.3に示すように正規化されたサンプルは、サンプル毎のスカラーDPCM量子化による知覚的に重み付けされた音声ドメインにおける量子化されます。ブロック内の各サンプルは、重み付けされた音声サンプルx [n]を形成するために、セクション3.4で指定され、重み付けフィルタ週（Z）によってフィルタリングされます。標的試料D [n]は予測フィルタは次式で与えられ、予測サンプルy [n]を減算することにより形成されます"
    },
    {
      "indent": 11,
      "text": "Pk(z) = 1 - 1 / Wk(z).",
      "ja": "P kの（Z）= 1  -  1 /週（Z）。"
    },
    {
      "indent": 3,
      "text": "            +-------+  x[n] +    d[n] +-----------+ u[n]\nresidual -->| Wk(z) |-------->(+)---->| Quantizer |------> quantized\n            +-------+       - /|\\     +-----------+    |   residual\n                               |                      \\|/\n                          y[n] +--------------------->(+)\n                               |                       |\n                               |        +------+       |\n                               +--------| Pk(z)|<------+\n                                        +------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.3. Quantization of start state samples by DPCM in weighted speech domain.",
      "ja": "図3.3。重み付き音声領域におけるDPCMによって開始状態のサンプルの量子化。"
    },
    {
      "indent": 3,
      "text": "The coded state sample u[n] is obtained by quantizing d[n] with a 3- bit quantizer with quantization table state_sq3Tbl.",
      "ja": "符号化された状態の試料のu [n]は量子化テーブルstate_sq3Tblと3-ビット量子化器と、D [n]を量子化することによって得られます。"
    },
    {
      "indent": 3,
      "text": "state_sq3Tbl[8] = {-3.719849, -2.177490, -1.130005, -0.309692, 0.444214, 1.329712, 2.436279, 3.983887}",
      "ja": "state_sq3Tbl [8] = {-3.719849、-2.177490、-1.130005、-0.309692、0.444214、1.329712、2.436279、3.983887}"
    },
    {
      "indent": 3,
      "text": "The quantized samples are transformed back to the residual domain by 1) scaling with 1/scal; 2) time-reversing the scaled samples; 3) filtering the time-reversed samples by the same all-pass filter, as in section 3.5.2, by using circular convolution; and 4) time-reversing the filtered samples. (More detail is in section 4.2.)",
      "ja": "量子化されたサンプルは、1 /年度でスケーリング）1バック残留ドメインに変換されます。 2）時間反転スケーリングされたサンプルを、 3）巡回畳み込みを使用して、セクション3.5.2のように、同一のオールパスフィルタにより時間反転サンプルをフィルタリングします。 4）時間反転フィルタリングされたサンプルを。 （さらなる詳細は、セクション4.2です。）"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the start-state encoding can be found in Appendix A.46.",
      "ja": "開始状態の符号化のリファレンス実装は、付録A.46に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "3.6. Encoding the Remaining Samples",
      "section_title": true,
      "ja": "3.6。残りのサンプルをコードします"
    },
    {
      "indent": 3,
      "text": "A dynamic codebook is used to encode 1) the 23/22 remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the 2 sub-blocks containing the start state, or a 40-sample sub-block. This target can consist of samples that are indexed forward in time or backward in time, depending on the location of the start state. The length of the target is denoted by lTarget.",
      "ja": "動的コードブックは、開始状態を含む2つのサブブロックで1）22分の23個の残りのサンプルを符号化するために使用されます。 2）時間内の開始状態後のサブブロック。そして3）時間の開始状態の前にサブブロック。これにより、符号化対象は、開始状態、または40サンプルのサブブロックを含む2サブブロックの残りの22分の23個のサンプルのいずれかとすることができます。このターゲットは、開始状態の位置に応じて、時間の時間または後方に前方にインデックス付けされたサンプルからなることができます。ターゲットの長さはLtargetにで示されています。"
    },
    {
      "indent": 3,
      "text": "The coding is based on an adaptive codebook that is built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as is the target vector and end at the sample instant prior to the first sample instant represented in the target vector. The codebook memory has length lMem, which is equal to CB_MEML=147 for the two/four 40-sample sub-blocks and 85 for the 23/22-sample sub-block.",
      "ja": "符号化は、ブロックの既に符号化部から復号LPC励振サンプルを含むコードブックメモリから構築された適応コードブックに基づいています。これらのサンプルは、前の標的ベクターで示される第1のサンプル瞬間にサンプル瞬間対象ベクトルと終了されるのと同じ時間方向にインデックスされます。コードブックメモリ23/22サンプルのサブブロックのための2つの/ 4の40サンプルのサブブロック85のため= 147 CB_MEMLに等しい長さLMEMを有します。"
    },
    {
      "indent": 3,
      "text": "The following figure shows an overview of the encoding procedure.",
      "ja": "次の図は、符号化手順の概要を示しています。"
    },
    {
      "indent": 6,
      "text": "   +------------+    +---------------+    +-------------+\n-> | 1. Decode  | -> | 2. Mem setup  | -> | 3. Perc. W. | ->\n   +------------+    +---------------+    +-------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "   +------------+    +-----------------+\n-> | 4. Search  | -> | 5. Upd. Target  | ------------------>\n | +------------+    +------------------ |\n ----<-------------<-----------<----------\n               stage=0..2",
      "raw": true
    },
    {
      "indent": 6,
      "text": "   +----------------+\n-> | 6. Recalc G[0] | ---------------> gains and CB indices\n   +----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.4. Flow chart of the codebook search in the iLBC encoder.",
      "ja": "図3.4。 iLBCのエンコーダでコードブック検索のチャートフロー。"
    },
    {
      "indent": 3,
      "text": "1. Decode the part of the residual that has been encoded so far, using the codebook without perceptual weighting.",
      "ja": "1.聴覚重み付けなしのコードブックを用いて、これまで符号化された残余の部分をデコードします。"
    },
    {
      "indent": 3,
      "text": "2. Set up the memory by taking data from the decoded residual. This memory is used to construct codebooks. For blocks preceding the start state, both the decoded residual and the target are time reversed (section 3.6.1). 3. Filter the memory + target with the perceptual weighting filter (section 3.6.2).",
      "ja": "2.復号された残差からのデータを取ることによって、メモリを設定します。このメモリは、コードブックを構築するために使用されます。開始状態に先行するブロック、復号残差とターゲットの両方の時間（セクション3.6.1）が逆になっています。前記知覚的重み付けフィルタ（セクション3.6.2）とメモリ+標的フィルター。"
    },
    {
      "indent": 3,
      "text": "4. Search for the best match between the target and the codebook vector. Compute the optimal gain for this match and quantize that gain (section 3.6.4).",
      "ja": "ターゲットとコードブックベクトル間のベストマッチ4.検索。この試合のために最適なゲインを計算し、そのゲイン（セクション3.6.4）に量子化します。"
    },
    {
      "indent": 3,
      "text": "5. Update the perceptually weighted target by subtracting the contribution from the selected codebook vector from the perceptually weighted memory (quantized gain times selected vector). Repeat 4 and 5 for the two additional stages.",
      "ja": "前記知覚的に重み付けされたメモリ（ベクトルを選択し、量子化利得回）から選択されたコードブックベクトルからの寄与を減算することにより知覚的に重み付けされたターゲットを更新します。二つの追加のステージ4と5を繰り返します。"
    },
    {
      "indent": 3,
      "text": "6. Calculate the energy loss due to encoding of the residual. If needed, compensate for this loss by an upscaling and requantization of the gain for the first stage (section 3.7).",
      "ja": "前記残差の符号化に起因するエネルギー損失を計算します。必要に応じて、第一段階（セクション3.7）のゲインのアップスケーリングと再量子化することによって、この損失を補償します。"
    },
    {
      "indent": 3,
      "text": "The following sections provide an in-depth description of the different blocks of Figure 3.4.",
      "ja": "以下のセクションでは、図3.4の異なるブロックの詳細な記述を提供します。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Codebook Memory",
      "section_title": true,
      "ja": "3.6.1。コードブックメモリ"
    },
    {
      "indent": 3,
      "text": "The codebook memory is based on the already encoded sub-blocks, so the available data for encoding increases for each new sub-block that has been encoded. Until enough sub-blocks have been encoded to fill the codebook memory with data, it is padded with zeros. The following figure shows an example of the order in which the sub-blocks are encoded for the 30 ms frame size if the start state is located in the last 58 samples of sub-block 2 and 3.",
      "ja": "コードブックメモリは、既に符号化されたサブブロックので、符号化された新しい各サブブロックの符号化増大のために利用可能なデータに基づくものです。十分なサブブロックはデータとコードブックのメモリを埋めるために、符号化されるまで、それがゼロで埋められます。次の図は、開始状態はサブブロック2及び3の最後の58個のサンプルに位置している場合、サブブロックは30ミリ秒のフレームサイズのために符号化される順序の例を示しています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------------+\n|  5     | 1  |///|////////|    2   |    3   |    4   |\n+-----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.5. The order from 1 to 5 in which the sub-blocks are encoded. The slashed area is the start state.",
      "ja": "図3.5。サブブロックが符号化された1から5まで順番。削減面積は開始状態です。"
    },
    {
      "indent": 3,
      "text": "The first target sub-block to be encoded is number 1, and the corresponding codebook memory is shown in the following figure. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed; thus, after the block has been time reversed the search algorithm can be reused. As only the start state has been encoded so far, the last samples of the codebook memory are padded with zeros.",
      "ja": "符号化される最初のターゲットサブブロックは、数1であり、対応するコードブック・メモリは、以下の図に示されています。ターゲットベクトルが時間内に開始状態の前に来ると、コードブックメモリとターゲットベクトルは、時間反転しています。このように、ブロックがされた後の時間は、検索アルゴリズムを再利用することができ逆転しました。のみ開始状態は、これまで符号化されているように、コードブックメモリの最後のサンプルがゼロでパディングされます。"
    },
    {
      "indent": 3,
      "text": "+-------------------------\n|zeros|\\\\\\\\\\\\\\\\|\\\\\\\\|  1 |\n+-------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.6. The codebook memory, length lMem=85 samples, and the target vector 1, length 22 samples.",
      "ja": "図3.6。コードブックメモリ、長LMEM = 85個のサンプル、及び目標ベクトル1、長さ22個のサンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 2 by using the memory that now has increased since sub-block 1 has been encoded. The following figure shows the codebook memory for encoding of sub-block 2.",
      "ja": "次のステップは、現在のサブブロック1が符号化されているので、増加したメモリを使用して、サブブロック2を符号化することです。次の図は、サブブロック2の符号化のためのコードブックメモリを示しています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------\n| zeros | 1  |///|////////|    2   |\n+-----------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.7. The codebook memory, length lMem=147 samples, and the target vector 2, length 40 samples.",
      "ja": "図3.7。コードブックメモリ、長LMEM = 147個のサンプル、及び目標ベクトル2、長さ40個のサンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 3 by using the memory which has been increased yet again since sub-blocks 1 and 2 have been encoded, but the sub-block still has to be padded with a few zeros. The following figure shows the codebook memory for encoding of sub-block 3.",
      "ja": "次のステップは、サブブロック1が再び増加しており、2は符号化されたメモリを使用して、サブブロック3を符号化することであるが、サブブロックは、まだいくつかのゼロでパディングされなければなりません。次の図は、サブブロック3の符号化のためのコードブックメモリを示します。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------------\n|zeros| 1  |///|////////|    2   |   3    |\n+------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.8. The codebook memory, length lMem=147 samples, and the target vector 3, length 40 samples.",
      "ja": "図3.8。コードブックメモリ、長LMEM = 147個のサンプル、及び目標ベクトル3、長さ40個のサンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 4 by using the memory which now has increased yet again since sub-blocks 1, 2, and 3 have been encoded. This time, the memory does not have to be padded with zeros. The following figure shows the codebook memory for encoding of sub-block 4.",
      "ja": "次のステップは、現在のサブブロック1、2が再び増加しており、そして3が符号化されたメモリを使用して、サブブロック4を符号化することです。今回は、メモリがゼロでパディングする必要はありません。次の図は、サブブロック4の符号化のためのコードブックメモリを示します。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------------\n|1|///|////////|    2   |   3    |   4    |\n+------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.9. The codebook memory, length lMem=147 samples, and the target vector 4, length 40 samples.",
      "ja": "図3.9。コードブックメモリ、長LMEM = 147個のサンプル、および標的ベクター4、長さ40個のサンプル。"
    },
    {
      "indent": 3,
      "text": "The final target sub-block to be encoded is number 5, and the following figure shows the corresponding codebook memory. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed.",
      "ja": "符号化すべき最終目標サブブロックは、数5であり、そして次の図は、対応するコードブック・メモリを示しています。ターゲットベクトルが時間内に開始状態の前に来ると、コードブックメモリとターゲットベクトルは、時間反転しています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------\n|  3  |   2    |\\\\\\\\\\\\\\\\|\\\\\\\\|  1 |   5    |\n+-------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.10. The codebook memory, length lMem=147 samples, and the target vector 5, length 40 samples.",
      "ja": "図3.10。コードブックメモリ、長LMEM = 147個のサンプル、及び目標ベクトル5、長さ40個のサンプル。"
    },
    {
      "indent": 3,
      "text": "For the case of 20 ms frames, the encoding procedure looks almost exactly the same. The only difference is that the size of the start state is 57 samples and that there are only three sub-blocks to be encoded. The encoding order is the same as above, starting with the 23-sample target and then encoding the two remaining 40-sample sub-blocks, first going forward in time and then going backward in time relative to the start state.",
      "ja": "20ミリ秒フレームの場合には、符号化手順はほとんど同じに見えます。唯一の違いは、開始状態の大きさは57個のサンプルであり、符号化すべき3つだけのサブブロックが存在することということです。符号化順序は、23サンプルのターゲットで開始し、最初の時間内に前進した後、開始状態に対して時間的に後方に行く、残りの2つの40サンプルのサブブロックを符号化する、上記と同様です。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Perceptual Weighting of Codebook Memory and Target",
      "section_title": true,
      "ja": "3.6.2。コードブックメモリとターゲットの聴覚重み付け"
    },
    {
      "indent": 3,
      "text": "To provide a perceptual weighting of the coding error, a concatenation of the codebook memory and the target to be coded is all-pole filtered with the perceptual weighting filter specified in section 3.4. The filter state of the weighting filter is set to zero.",
      "ja": "コーディングエラーの知覚的重み付けを提供するために、コードブックメモリと符号化されるべき対象の連結は、セクション3.4で指定された知覚的重み付けフィルタで濾過全極です。重み付けフィルタのフィルタ状態はゼロに設定されます。"
    },
    {
      "indent": 6,
      "text": "in(0..(lMem-1)) = unweighted codebook memory in(lMem..(lMem+lTarget-1)) = unweighted target signal",
      "ja": "（0 ..（LMEM-1））（LMEM ..（LMEM + Ltargetに-1））で重み付けされていないコードブックメモリを=には、非加重目標信号を="
    },
    {
      "indent": 6,
      "text": "in -> Wk(z) -> filtered, where Wk(z) is taken from the sub-block of the target",
      "ja": "中 - >週（Z） - >、濾過週（z）は目標のサブブロックから採取されます"
    },
    {
      "indent": 6,
      "text": "weighted codebook memory = filtered(0..(lMem-1)) weighted target signal = filtered(lMem..(lMem+lTarget-1))",
      "ja": "濾過加重コードブックメモリ=（0 ..（LMEM-1））の加重目標信号=濾過（LMEM ..（LMEM + Ltargetに-1））"
    },
    {
      "indent": 3,
      "text": "The codebook search is done with the weighted codebook memory and the weighted target, whereas the decoding and the codebook memory update uses the unweighted codebook memory.",
      "ja": "復号およびコードブックメモリ更新が重み付けされていないコードブック・メモリを使用するのに対し、コードブック検索は、重み付けされたコードブックメモリ加重ターゲットを用いて行われます。"
    },
    {
      "indent": 0,
      "text": "3.6.3. Codebook Creation",
      "section_title": true,
      "ja": "3.6.3。コードブックの作成"
    },
    {
      "indent": 3,
      "text": "The codebook for the search is created from the perceptually weighted codebook memory. It consists of two sections, where the first is referred to as the base codebook and the second as the expanded codebook, as it is created by linear combinations of the first. Each of these two sections also has a subsection referred to as the augmented codebook. The augmented codebook is only created and used for the coding of the 40-sample sub-blocks and not for the 23/22- sample sub-block case. The codebook size used for the different sub-blocks and different stages are summarized in the table below.",
      "ja": "検索のためのコードブックは知覚的に重み付けされたコードブックメモリから作成されます。それは第一の線形結合によって作成されるように、第1に、ベースコードブックと拡張ブックとしての第2と呼ばれる2つのセクションから構成されています。これら二つの部分のそれぞれはまた、増強、コードブックと呼ばれるサブセクションを有しています。拡張コードブックにのみ作成され、40サンプルのサブブロックの符号化のためではなく23 / 22-サンプルのサブブロックの場合に使用されます。異なるサブブロックと異なる段階のために使用されるコードブックのサイズは以下の表にまとめます。"
    },
    {
      "indent": 3,
      "text": "                           Stage\n                     1               2 & 3\n        --------------------------------------------\n             22     128  (64+0)*2     128 (64+0)*2\nSub-    1:st 40     256  (108+20)*2   128 (44+20)*2\nBlocks  2:nd 40     256  (108+20)*2   256 (108+20)*2\n        3:rd 40     256  (108+20)*2   256 (108+20)*2\n        4:th 40     256  (108+20)*2   256 (108+20)*2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 3.1. Codebook sizes for the 30 ms mode.",
      "ja": "表3.1。コードブックは、30ミリ秒モード用サイズ。"
    },
    {
      "indent": 3,
      "text": "Table 3.1 shows the codebook size for the different sub-blocks and stages for 30 ms frames. Inside the parentheses it shows how the number of codebook vectors is distributed, within the two sections, between the base/expanded codebook and the augmented base/expanded codebook. It should be interpreted in the following way: (base/expanded cb + augmented base/expanded cb). The total number of codebook vectors for a specific sub-block and stage is given by the following formula:",
      "ja": "表3.1は、30ミリ秒のフレームのための異なるサブブロックとステージのためのコードブックサイズを示します。かっこ内はコードブック・ベクトルの数は、ベース/拡張コードブックと拡張ベース/拡張コードブック間、二つのセクション内で、分散される様子を示しています。 （ベース/拡張CB +拡張ベース/拡張CB）：これは、以下のように解釈されるべきです。特定のサブブロックとステージのためのコードブック・ベクトルの総数は次式で与えられます。"
    },
    {
      "indent": 3,
      "text": "Tot. cb vectors = base cb + aug. base cb + exp. cb + aug. exp. cb",
      "ja": "トット。 CBベクトル=ベースCB + 8月ベースCB + EXP。 CB + 8月EXP。 CB"
    },
    {
      "indent": 3,
      "text": "The corresponding values to Figure 3.1 for 20 ms frames are only slightly modified. The short sub-block is 23 instead of 22 samples, and the 3:rd and 4:th sub-frame are not present.",
      "ja": "20ミリ秒のフレームについて図3.1に対応する値のみがわずかに変更されています。 RD及び4：存在しないサブフレーム目のショートサブブロックは、23の代わりに22のサンプル、及び3です。"
    },
    {
      "indent": 0,
      "text": "3.6.3.1. Creation of a Base Codebook",
      "section_title": true,
      "ja": "3.6.3.1。ベースコードブックの作成"
    },
    {
      "indent": 3,
      "text": "The base codebook is given by the perceptually weighted codebook memory that is mentioned in section 3.5.3. The different codebook vectors are given by sliding a window of length 23/22 or 40, given by variable lTarget, over the lMem-long perceptually weighted codebook memory. The indices are ordered so that the codebook vector containing sample (lMem-lTarget-n) to (lMem-n-1) of the codebook memory vector has index n, where n=0..lMem-lTarget. Thus the total number of base codebook vectors is lMem-lTarget+1, and the indices are ordered from sample delay lTarget (23/22 or 40) to lMem+1 (86 or 148).",
      "ja": "ベースコードブックは、セクション3.5.3に記載されて知覚的に重み付けされたコードブックのメモリによって与えられます。異なるコードブックベクトルは、LMEM長知覚的に重み付けされたコードブックのメモリ上に、可変Ltargetにによって与えられ、長さ22分の23または40のウィンドウをスライドさせることによって与えられます。 （LMEM-N-1）コードブックメモリベクトルのために、サンプル（LMEM-Ltargetに-N）を含むコードブックベクトルインデックスN、N = 0..lMem-Ltargetにを有するようにインデックスが順序づけられます。したがって、ベースコードブック・ベクトルの総数はLMEM-Ltargetに+ 1であり、インデックスはLMEM + 1（86又は148）にサンプル遅延Ltargetに（22分の23または40）から注文されています。"
    },
    {
      "indent": 0,
      "text": "3.6.3.2. Codebook Expansion",
      "section_title": true,
      "ja": "3.6.3.2。コードブック拡張"
    },
    {
      "indent": 3,
      "text": "The base codebook is expanded by a factor of 2, creating an additional section in the codebook. This new section is obtained by filtering the base codebook, base_cb, with a FIR filter with filter length CB_FILTERLEN=8. The construction of the expanded codebook compensates for the delay of four samples introduced by the FIR filter.",
      "ja": "ベースコードブックは、コードブック内の追加セクションを作成する、2倍に拡大されます。この新しいセクションでは、フィルタ長CB_FILTERLEN = 8を有するFIRフィルタを用いて、ベースコードブック、base_cbをフィルタリングすることによって得られます。拡張コードブックの構成は、FIRフィルタによって導入される4個のサンプルの遅延を補償します。"
    },
    {
      "indent": 3,
      "text": "cbfiltersTbl[CB_FILTERLEN]={-0.033691, 0.083740, -0.144043, 0.713379, 0.806152, -0.184326, 0.108887, -0.034180};",
      "ja": "cbfiltersTbl [CB_FILTERLEN] = { -  0.033691、0.083740、-0.144043、0.713379、0.806152、-0.184326、0.108887、-0.034180}。"
    },
    {
      "indent": 6,
      "text": "             ___\n             \\\nexp_cb(k)=  + > cbfiltersTbl(i)*x(k-i+4)\n             /__\n       i=0...(LPC_FILTERORDER-1)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "where x(j) = base_cb(j) for j=0..lMem-1 and 0 otherwise",
      "ja": "ここで、x（j）= base_cb（J）はJ = 0..lMem-1,0さもなければ"
    },
    {
      "indent": 3,
      "text": "The individual codebook vectors of the new filtered codebook, exp_cb, and their indices are obtained in the same fashion as described above for the base codebook.",
      "ja": "ベースコードブックのために上記のように新しいコードブック濾過、exp_cb、およびそれらのインデックスの個々のコードブックベクトルが同様に得られます。"
    },
    {
      "indent": 0,
      "text": "3.6.3.3. Codebook Augmentation",
      "section_title": true,
      "ja": "3.6.3.3。コードブックの増加"
    },
    {
      "indent": 3,
      "text": "For cases where encoding entire sub-blocks, i.e., cbveclen=40, the base and expanded codebooks are augmented to increase codebook richness. The codebooks are augmented by vectors produced by interpolation of segments. The base and expanded codebook, constructed above, consists of vectors corresponding to sample delays in the range from cbveclen to lMem. The codebook augmentation attempts to augment these codebooks with vectors corresponding to sample delays from 20 to 39. However, not all of these samples are present in the base codebook and expanded codebook, respectively. Therefore, the augmentation vectors are constructed as linear combinations between samples corresponding to sample delays in the range 20 to 39. The general idea of this procedure is presented in the following figures and text. The procedure is performed for both the base codebook and the expanded codebook.",
      "ja": "全体のサブブロックを符号化する、すなわち、= 40 cbveclenケースでは、ベース及び拡張コードブックは、コードブック豊かさを増加させるために拡張されています。コードブックは、セグメントの補間によって生成されるベクトルによって増大されます。上記構成の基材と拡張コードブックは、cbveclenからLMEMの範囲の遅延をサンプルに対応するベクトルで構成されています。コードブック増強は、それぞれ、ただし、すべてではないこれらのサンプルは、ベースコードブックと拡張ブックに存在する39に20から遅延をサンプルに対応するベクトルと、これらのコードブックを増強することを試みます。したがって、増強ベクターは、この手順の一般的な考え方は、以下の図面および本文に提示されている20 39の範囲の遅延をサンプルに対応するサンプル間の線形の組み合わせとして構成されています。手順は、基本コードブックと拡張ブックの両方に対して行われます。"
    },
    {
      "indent": 4,
      "text": "   - - ------------------------|\ncodebook memory                |\n   - - ------------------------|\n              |-5-|---15---|-5-|\n              pi  pp       po",
      "raw": true
    },
    {
      "indent": 22,
      "text": "|        |                       Codebook vector\n|---15---|-5-|-----20-----|   <- corresponding to\n    i     ii      iii            sample delay 20",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.11. Generation of the first augmented codebook.",
      "ja": "図3.11。最初の増補コードブックの生成。"
    },
    {
      "indent": 3,
      "text": "Figure 3.11 shows the codebook memory with pointers pi, pp, and po, where pi points to sample 25, pp to sample 20, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 20 is drawn. Segment i consists of fifteen samples from pointer pp and forward in time. Segment ii consists of five interpolated samples from pi and forward and from po and forward. The samples are linearly interpolated with weights [0.0, 0.2, 0.4, 0.6, 0.8] for pi and weights [1.0, 0.8, 0.6, 0.4, 0.2] for po. Segment iii consists of twenty samples from pp and forward. The augmented codebook vector corresponding to sample delay 21 is produced by moving pointers pp and pi one sample backward in time. This gives us the following figure.",
      "ja": "図3.11は、コードブックメモリ下に5をサンプリングするコードブック20をサンプリングするポインタPI、PP、及びPO、PI点25をサンプリングする、PPとメモリ、及びPOを示し、20を遅延サンプルに対応する拡張コードブックベクトルが描かれています。セグメント私は時間内にポインタPPと前方からの15個のサンプルで構成されています。セグメントIIは、5つの補間されたPIからのサンプルとフォワードおよびPOから前方から成ります。サンプルを直線経口用のPIと重み[1.0、0.8、0.6、0.4、0.2]の重み[0.0、0.2、0.4、0.6、0.8]を用いて補間されます。セグメントIIIは、PPと前方から20個のサンプルから成ります。遅延21をサンプルに対応する拡張コードブックベクトルは、時間的に逆方向ポインタPPとPIつのサンプルを移動させることによって製造されます。これは、私たちに次の図に示します。"
    },
    {
      "indent": 4,
      "text": "   - - ------------------------|\ncodebook memory                |\n   - - ------------------------|\n              |-5-|---16---|-5-|\n              pi  pp       po",
      "raw": true
    },
    {
      "indent": 22,
      "text": "|        |                       Codebook vector\n|---16---|-5-|-----19-----|   <- corresponding to\n    i     ii      iii            sample delay 21",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.12. Generation of the second augmented codebook.",
      "ja": "図3.12。第二増補コードブックの生成。"
    },
    {
      "indent": 3,
      "text": "Figure 3.12 shows the codebook memory with pointers pi, pp and po where pi points to sample 26, pp to sample 21, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 21 is drawn. Segment i now consists of sixteen samples from pp and forward. Segment ii consists of five interpolated samples from pi and forward and from po and forward, and the interpolation weights are the same throughout the procedure. Segment iii consists of nineteen samples from pp and forward. The same procedure of moving the two pointers is continued until the last augmented vector corresponding to sample delay 39 has been created. This gives a total of twenty new codebook vectors to each of the two sections. Thus the total number of codebook vectors for each of the two sections, when including the augmented codebook, becomes lMem-SUBL+1+SUBL/2. This is provided that augmentation is evoked, i.e., that lTarget=SUBL.",
      "ja": "3.12ポインタPI、PI点26をサンプリングするPPとPO、PP 21をサンプリングする、及びPOは、コードブックメモリ下5をサンプリングすると、コードブックメモリを示し、21を遅延サンプルに対応する拡張コードブックベクトルが描かれています。セグメント私は今、PPと前方からの16個のサンプルで構成されています。セグメントIIは、前方及びPOから前方5つの補間PIからのサンプルとで構成され、補間の重みは、プロシージャ全体で同じです。セグメントIIIは、PPと前方からの19個のサンプルから成ります。遅延39をサンプルに対応する最後の拡張ベクトルが作成されるまで二つのポインタを移動させるのと同じ手順が続けられます。これには2つのセクションのそれぞれに20個の新しいコードブックベクトルの合計を提供します。したがって増強コードブックを含む二つのセクションの各々に対するコードブック・ベクトルの総数は、LMEM-SUBL + 1 + SUBL / 2となります。これはすなわち、Ltargetには= SUBLこと、増強が誘発されることが提供されます。"
    },
    {
      "indent": 0,
      "text": "3.6.4. Codebook Search",
      "section_title": true,
      "ja": "3.6.4。コードブック検索"
    },
    {
      "indent": 3,
      "text": "The codebook search uses the codebooks described in the sections above to find the best match of the perceptually weighted target, see section 3.6.2. The search method is a multi-stage gain-shape matching performed as follows. At each stage the best shape vector is identified, then the gain is calculated and quantized, and finally the target is updated in preparation for the next codebook search stage. The number of stages is CB_NSTAGES=3.",
      "ja": "コードブック検索は、セクション3.6.2を参照して、知覚的に重み付けされたターゲットのベストマッチを見つけるために、上記のセクションで説明したコードブックを使用しています。検索方法は、以下のように行う多段利得形状マッチングです。最高の形のベクトルが識別され、各段階で、その後、ゲインを算出し、量子化され、最終的にターゲットは、次のコードブック探索段階の準備のために更新されています。段の数はCB_NSTAGES = 3です。"
    },
    {
      "indent": 3,
      "text": "If the target is the 23/22-sample vector the codebooks are indexed so that the base codebook is followed by the expanded codebook. If the target is 40 samples the order is as follows: base codebook, augmented base codebook, expanded codebook, and augmented expanded codebook. The size of each codebook section and its corresponding augmented section is given by Table 3.1 in section 3.6.3.",
      "ja": "ターゲットは、ベースコードブックは拡張コードブックが続くようにコードブックにインデックスされている22分の23サンプルベクトルである場合。ターゲットは40個のサンプルである場合、次のように順序は、ベースコードブック、拡張ベースコードブック、拡張コードブック、及び増補拡張コードブック。各コードブック部の大きさ及びその対応する拡張セクションは、セクション3.6.3の表3.1で与えられます。"
    },
    {
      "indent": 3,
      "text": "For example, when the second 40-sample sub-block is coded, indices 0 - 107 correspond to the base codebook, 108 - 127 correspond to the augmented base codebook, 128 - 235 correspond to the expanded codebook, and indices 236 - 255 correspond to the augmented expanded codebook. The indices are divided in the same fashion for all stages in the example. Only in the case of coding the first 40-sample sub-block is there a difference between stages (see Table 3.1).",
      "ja": "例えば、第40サンプルのサブブロックが符号化される場合、0インデックス -  107は、ベースコードブックに対応し、108から235まで拡張コードブックに対応し、236インデックス -   -  127 128は、増補ベースコードブックに対応する255が対応します増補拡大ブックへ。インデックスは、例のすべての段階のために同様に分割されています。最初の40サンプルのサブブロックを符号化する場合には段間差が存在する（表3.1参照）。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1. Codebook Search at Each Stage",
      "section_title": true,
      "ja": "3.6.4.1。各段階でのコードブック検索"
    },
    {
      "indent": 3,
      "text": "The codebooks are searched to find the best match to the target at each stage. When the best match is found, the target is updated and the next-stage search is started. The three chosen codebook vectors and their corresponding gains constitute the encoded sub-block. The best match is decided by the following three criteria:",
      "ja": "コードブックは、各段階での目標にベストマッチを見つけるために検索されます。最良の一致が見つかった場合は、ターゲットが更新され、次の段階の検索が開始されます。 3つの選択されたコードブックベクトルとそれに対応する利得は符号化されたサブブロックを構成しています。ベストマッチは、次の3つの基準によって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. Compute the measure",
      "section_title": true,
      "ja": "1.測定を計算"
    },
    {
      "indent": 6,
      "text": "(target*cbvec)^2 / ||cbvec||^2",
      "ja": "（ターゲット* cbvec）^ 2 / || || cbvec ^ 2"
    },
    {
      "indent": 3,
      "text": "for all codebook vectors, cbvec, and choose the codebook vector maximizing the measure. The expression (target*cbvec) is the dot product between the target vector to be coded and the codebook vector for which we compute the measure. The norm, ||x||, is defined as the square root of (x*x).",
      "ja": "すべてのためのベクター、cbvecコードブック、および指標を最大化コードブックベクトルを選択してください。式（ターゲット* cbvec）が符号化されるべき対象ベクトルと、我々は測定値を計算する対象のコードブック・ベクトルとのドット積です。ノルムは、|| X ||、（Xの* x）からの平方根として定義されます。"
    },
    {
      "indent": 3,
      "text": "2. The absolute value of the gain, corresponding to the chosen codebook vector, cbvec, must be smaller than a fixed limit, CB_MAXGAIN=1.3:",
      "ja": "2.選択されたコードブック・ベクトルに対応するゲインの絶対値が、cbvecは、CB_MAXGAIN = 1.3一定の限界よりも小さくなければなりません。"
    },
    {
      "indent": 12,
      "text": "|gain| < CB_MAXGAIN",
      "ja": "|ゲイン| <CB_MAXGAIN"
    },
    {
      "indent": 6,
      "text": "where the gain is computed in the following way:",
      "ja": "ゲインは次のように計算されます："
    },
    {
      "indent": 12,
      "text": "gain = (target*cbvec) / ||cbvec||^2",
      "ja": "ゲイン=（目標* cbvec）/ || || cbvec ^ 2"
    },
    {
      "indent": 3,
      "text": "3. For the first stage, the dot product of the chosen codebook vector and target must be positive:",
      "ja": "3.第一段階では、選択されたコードブック・ベクトルとターゲットのドット積が正でなければなりません。"
    },
    {
      "indent": 6,
      "text": "target*cbvec > 0",
      "ja": "対象* cbvec> 0"
    },
    {
      "indent": 3,
      "text": "In practice the above criteria are used in a sequential search through all codebook vectors. The best match is found by registering a new max measure and index whenever the previously registered max measure is surpassed and all other criteria are fulfilled. If none of the codebook vectors fulfill (2) and (3), the first codebook vector is selected.",
      "ja": "実際には上記の基準は、すべてのコードブックベクトルを通じて順次検索に使用されています。ベストマッチは、以前に登録された最大対策が突破され、他のすべての基準が満たされるたびに新しい最大指標とインデックスを登録することによって発見されました。コードブック・ベクトルのいずれも満たしていない場合（2）及び（3）に示すように、第1のコードブックベクトルを選択します。"
    },
    {
      "indent": 0,
      "text": "3.6.4.2. Gain Quantization at Each Stage",
      "section_title": true,
      "ja": "3.6.4.2。各段階での利得量子化"
    },
    {
      "indent": 3,
      "text": "The gain follows as a result of the computation",
      "ja": "利得は、演算の結果として、以下"
    },
    {
      "indent": 6,
      "text": "gain = (target*cbvec) / ||cbvec||^2",
      "ja": "ゲイン=（目標* cbvec）/ || || cbvec ^ 2"
    },
    {
      "indent": 3,
      "text": "for the optimal codebook vector found by the procedure in section 3.6.4.1.",
      "ja": "セクション3.6.4.1の手順で見つかった最適なコードブックベクトルのため。"
    },
    {
      "indent": 3,
      "text": "The three stages quantize the gain, using 5, 4, and 3 bits, respectively. In the first stage, the gain is limited to positive values. This gain is quantized by finding the nearest value in the quantization table gain_sq5Tbl.",
      "ja": "三の段階は、それぞれ、5,4、及び3ビットを使用して、ゲインを量子化します。第一段階では、利得は、正の値に制限されています。このゲインは、量子化テーブルgain_sq5Tblに最も近い値を見つけることによって量子化されます。"
    },
    {
      "indent": 3,
      "text": "gain_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012, 0.487488, 0.525024, 0.562500, 0.599976, 0.637512, 0.674988, 0.712524, 0.750000, 0.787476, 0.825012, 0.862488, 0.900024, 0.937500, 0.974976, 1.012512, 1.049988, 1.087524, 1.125000, 1.162476, 1.200012}",
      "ja": "gain_sq5Tbl [32] = {0.037476、0.075012、0.112488、0.150024、0.187500、0.224976、0.262512、0.299988、0.337524、0.375000、0.412476、0.450012、0.487488、0.525024、0.562500、0.599976、0.637512、0.674988、0.712524、0.750000、0.787476、0.825012、 0.862488、0.900024、0.937500、0.974976、1.012512、1.049988、1.087524、1.125000、1.162476、1.200012}"
    },
    {
      "indent": 3,
      "text": "The gains of the subsequent two stages can be either positive or negative. The gains are quantized by using a quantization table times a scale factor. The second stage uses the table gain_sq4Tbl, and the third stage uses gain_sq3Tbl. The scale factor equates 0.1 or the absolute value of the quantized gain representation value obtained in the previous stage, whichever is larger. Again, the resulting gain index is the index to the nearest value of the quantization table times the scale factor.",
      "ja": "その後の2段階のゲインは、正または負のいずれかになります。ゲインは、量子化テーブル倍のスケールファクタを使用することによって量子化されます。第二段階は、テーブルgain_sq4Tblを使用して、3段目はgain_sq3Tblを使用します。スケール係数は0.1以上である方前の段階で得られた量子化ゲイン表現値の絶対値が等しいです。再度、得られた利得インデックスは、量子化テーブル時間スケールファクタの最も近い値へのインデックスです。"
    },
    {
      "indent": 8,
      "text": "gainQ = scaleFact * gain_sqXTbl[index]",
      "ja": "gainQ = scaleFact * gain_sqXTbl [インデックス]"
    },
    {
      "indent": 3,
      "text": "gain_sq4Tbl[16]={-1.049988, -0.900024, -0.750000, -0.599976, -0.450012, -0.299988, -0.150024, 0.000000, 0.150024, 0.299988, 0.450012, 0.599976, 0.750000, 0.900024, 1.049988, 1.200012}",
      "ja": "gain_sq4Tbl [16] = { -  1.049988、-0.900024、-0.750000、-0.599976、-0.450012、-0.299988、-0.150024、0.000000、0.150024、0.299988、0.450012、0.599976、0.750000、0.900024、1.049988、1.200012}"
    },
    {
      "indent": 3,
      "text": "gain_sq3Tbl[8]={-1.000000, -0.659973, -0.330017,0.000000, 0.250000, 0.500000, 0.750000, 1.00000}",
      "ja": "gain_sq3Tbl [8] = { -  1.000000、-0.659973、-0.330017,0.000000、0.250000、0.500000、0.750000、1.00000}"
    },
    {
      "indent": 0,
      "text": "3.6.4.3. Preparation of Target for Next Stage",
      "section_title": true,
      "ja": "3.6.4.3。次のステージのためのターゲットの作製"
    },
    {
      "indent": 3,
      "text": "Before performing the search for the next stage, the perceptually weighted target vector is updated by subtracting from it the selected codebook vector (from the perceptually weighted codebook) times the corresponding quantized gain.",
      "ja": "次の段階のために検索を実行する前に、知覚的に重み付けされた標的ベクトルがそこから選択されたコードブックベクトル（知覚的に重み付けされたコードブックから）回対応する量子化利得を減算することにより更新されます。"
    },
    {
      "indent": 6,
      "text": "target[i] = target[i] - gainQ * selected_vec[i];",
      "ja": "標的[I] =目標[I]  -  gainQ * selected_vec [I]。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the codebook encoding is found in Appendix A.34.",
      "ja": "コードブック符号化のリファレンス実装は、付録A.34に見出されます。"
    },
    {
      "indent": 0,
      "text": "3.7. Gain Correction Encoding",
      "section_title": true,
      "ja": "3.7。ゲイン補正エンコーディング"
    },
    {
      "indent": 3,
      "text": "The start state is quantized in a relatively model independent manner using 3 bits per sample. In contrast, the remaining parts of the block are encoded by using an adaptive codebook. This codebook will produce high matching accuracy whenever there is a high correlation between the target and the best codebook vector. For unvoiced speech segments and background noises, this is not necessarily so, which, due to the nature of the squared error criterion, results in a coded signal with less power than the target signal. As the coded start state has good power matching to the target, the result is a power fluctuation within the encoded frame. Perceptually, the main problem with this is that the time envelope of the signal energy becomes unsteady. To overcome this problem, the gains for the codebooks are re-scaled after the codebook encoding by searching for a new gain factor for the first stage codebook that provides better power matching.",
      "ja": "開始状態はサンプル当たり3ビットを使用して、比較的モデルに依存しない方法で量子化されます。対照的に、ブロックの残りの部分は、適応コードブックを用いて符号化されます。ターゲットと最良のコードブックベクトルとの間の高い相関関係があるときはいつでも、このコードブックは、高いマッチング精度を生成します。無声音声セグメントとバックグラウンドノイズのために、これは、必ずしもそう二乗誤差基準の性質に起因しており、目標信号より少ない電力で符号化された信号における結果ではありません。符号化された開始状態は、ターゲットへの良好な電力整合を有するように、結果は、符号化されたフレーム内のパワー変動です。知覚的に、この主な問題は、信号エネルギーの時間エンベロープが不安定になることです。この問題を克服するために、コードブックのゲインは、より良好な電力マッチングを提供する第一段階のコードブックのための新たな利得係数を検索することにより、コードブック符号化後に再スケーリングされます。"
    },
    {
      "indent": 3,
      "text": "First, the energy for the target signal, tene, is computed along with the energy for the coded signal, cene, given by the addition of the three gain scaled codebook vectors. Because the gains of the second and third stage scale with the gain of the first stage, when the first stage gain is changed from gain[0] to gain_sq5Tbl[i] the energy of the coded signal changes from cene to",
      "ja": "まず、対象信号のエネルギー、teneは3つの利得スケーリングコードブックベクトルの添加によって与えられる符号化信号のためのエネルギー、cene、一緒に計算されます。第一段階ゲインがゲインから変更された最初のステージの利得を有する第二及び第三段階スケールのゲイン、なぜなら[0] gain_sq5Tblに[I] ceneからの符号化された信号変化のエネルギーを"
    },
    {
      "indent": 6,
      "text": "cene*(gain_sq5Tbl[i]*gain_sq5Tbl[i])/(gain[0]*gain[0])",
      "ja": "cene×（gain_sq5Tbl [I] * gain_sq5Tbl [I]）/（ゲイン[0] *利得[0]）"
    },
    {
      "indent": 3,
      "text": "where gain[0] is the gain for the first stage found in the original codebook search. A refined search is performed by testing the gain indices i=0 to 31, and as long as the new codebook energy as given above is less than tene, the gain index for stage 1 is increased. A restriction is applied so that the new gain value for stage 1 cannot be more than two times higher than the original value found in the codebook search. Note that by using this method we do not change the shape of the encoded vector, only the gain or amplitude.",
      "ja": "ゲイン[0]は、元のコードブック検索で見つかった最初のステージのゲインです。洗練された検索は、I = 0 31にゲイン指標を試験することによって行われ、そして限りtene未満である、上記のように新しいコードブックエネルギーとして、ステージ1のゲイン指標が増加します。ステージ1のための新たなゲイン値がコードブック検索で見つかった元の値よりも2倍以上高いことができないように制限が適用されます。この方法を使用することによって、我々はエンコードされたベクトルの形状、ゲインのみまたは振幅を変更しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.8. Bitstream Definition",
      "section_title": true,
      "ja": "3.8。ビットストリームの定義"
    },
    {
      "indent": 3,
      "text": "The total number of bits used to describe one frame of 20 ms speech is 304, which fits in 38 bytes and results in a bit rate of 15.20 kbit/s. For the case of a frame length of 30 ms speech, the total number of bits used is 400, which fits in 50 bytes and results in a bit rate of 13.33 kbit/s. In the bitstream definition, the bits are distributed into three classes according to their bit error or loss sensitivity. The most sensitive bits (class 1) are placed first in the bitstream for each frame. The less sensitive bits (class 2) are placed after the class 1 bits. The least sensitive bits (class 3) are placed at the end of the bitstream for each frame.",
      "ja": "20ミリ秒の音声の一つのフレームを記述するために使用されるビットの総数は、15.20キロビット/秒のビットレートでは38のバイトと結果に収まる304、です。 30ミリ秒の音声のフレーム長の場合のために、使用されるビットの総数は、13.33キロビット/秒のビットレートでは50のバイトと結果に収まる400、です。ビットストリーム定義では、ビットは、そのビット誤りまたは損失の感度に応じて3つのクラスに分配されます。最も敏感なビット（クラス1）は、フレーム毎にビットストリーム内に最初に配置されています。あまり敏感なビット（クラス2）はクラス1ビットの後に配置されています。前記敏感なビット（クラス3）は、各フレームのビットストリームの末尾に配置されています。"
    },
    {
      "indent": 3,
      "text": "In the 20/30 ms frame length cases for each class, the following hold true: The class 1 bits occupy a total of 6/8 bytes (48/64 bits), the class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3 bits occupy 24/30 bytes (191/239 bits). This distribution of the bits enables the use of uneven level protection (ULP) as is exploited in the payload format definition for iLBC [1]. The detailed bit allocation is shown in the table below. When a quantization index is distributed between more classes, the more significant bits belong to the lowest class.",
      "ja": "各クラスの20/30ミリ秒のフレーム長の場合には、次のホールド真：クラス1ビットは6/8バイト（64分の48ビット）の合計を占め、クラス2ビットが8/12バイト（96分の64を占めビット）、およびクラス3ビットが24/30バイト（239分の191ビット）を占めます。ビットのこの分布は、不均一なレベルの保護（ULP）の使用を可能にiLBCのためのペイロードフォーマット定義に利用される[1]。詳細ビット割り当てを以下の表に示されています。量子化インデックスは、複数のクラス間で分散されている場合、上位ビットは最も低いクラスに属します。"
    },
    {
      "indent": 3,
      "text": "Bitstream structure:",
      "ja": "ビットストリーム構造："
    },
    {
      "indent": 3,
      "text": "------------------------------------------------------------------+\nParameter                         |       Bits Class <1,2,3>      |\n                                  |  20 ms frame  |  30 ms frame  |\n----------------------------------+---------------+---------------+\n                         Split 1  |   6 <6,0,0>   |   6 <6,0,0>   |\n                LSF 1    Split 2  |   7 <7,0,0>   |   7 <7,0,0>   |\nLSF                      Split 3  |   7 <7,0,0>   |   7 <7,0,0>   |\n                ------------------+---------------+---------------+\n                         Split 1  | NA (Not Appl.)|   6 <6,0,0>   |\n                LSF 2    Split 2  |      NA       |   7 <7,0,0>   |\n                         Split 3  |      NA       |   7 <7,0,0>   |\n                ------------------+---------------+---------------+\n                Sum               |  20 <20,0,0>  |  40 <40,0,0>  |\n----------------------------------+---------------+---------------+\nBlock Class                       |   2 <2,0,0>   |   3 <3,0,0>   |\n----------------------------------+---------------+---------------+\nPosition 22 sample segment        |   1 <1,0,0>   |   1 <1,0,0>   |\n----------------------------------+---------------+---------------+\nScale Factor State Coder          |   6 <6,0,0>   |   6 <6,0,0>   |\n----------------------------------+---------------+---------------+\n                Sample 0          |   3 <0,1,2>   |   3 <0,1,2>   |\nQuantized       Sample 1          |   3 <0,1,2>   |   3 <0,1,2>   |\nResidual           :              |   :    :      |   :    :      |\nState              :              |   :    :      |   :    :      |\nSamples            :              |   :    :      |   :    :      |\n                Sample 56         |   3 <0,1,2>   |   3 <0,1,2>   |\n                Sample 57         |      NA       |   3 <0,1,2>   |\n                ------------------+---------------+---------------+\n                Sum               | 171 <0,57,114>| 174 <0,58,116>|\n----------------------------------+---------------+---------------+\n                         Stage 1  |   7 <6,0,1>   |   7 <4,2,1>   |\nCB for 22/23             Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\nsample block             Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n                ------------------+---------------+---------------+\n                Sum               |  21 <6,0,15>  |  21 <4,2,15>  |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   5 <2,0,3>   |   5 <1,1,3>   |\nGain for 22/23           Stage 2  |   4 <1,1,2>   |   4 <1,1,2>   |\nsample block             Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                Sum               |  12 <3,1,8>   |  12 <2,2,8>   |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   8 <7,0,1>   |   8 <6,1,1>   |\n            sub-block 1  Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\n                         Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n                ------------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                         Stage 1  |   8 <0,0,8>   |   8 <0,7,1>   |\n            sub-block 2  Stage 2  |   8 <0,0,8>   |   8 <0,0,8>   |\nIndices                  Stage 3  |   8 <0,0,8>   |   8 <0,0,8>   |\nfor CB          ------------------+---------------+---------------+\nsub-blocks               Stage 1  |      NA       |   8 <0,7,1>   |\n            sub-block 3  Stage 2  |      NA       |   8 <0,0,8>   |\n                         Stage 3  |      NA       |   8 <0,0,8>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |      NA       |   8 <0,7,1>   |\n            sub-block 4  Stage 2  |      NA       |   8 <0,0,8>   |\n                         Stage 3  |      NA       |   8 <0,0,8>   |\n                ------------------+---------------+---------------+\n                Sum               |  46 <7,0,39>  |  94 <6,22,66> |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   5 <1,2,2>   |   5 <1,2,2>   |\n            sub-block 1  Stage 2  |   4 <1,1,2>   |   4 <1,2,1>   |\n                         Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |   5 <1,1,3>   |   5 <0,2,3>   |\n            sub-block 2  Stage 2  |   4 <0,2,2>   |   4 <0,2,2>   |\n                         Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\nGains for       ------------------+---------------+---------------+\nsub-blocks               Stage 1  |      NA       |   5 <0,1,4>   |\n            sub-block 3  Stage 2  |      NA       |   4 <0,1,3>   |\n                         Stage 3  |      NA       |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |      NA       |   5 <0,1,4>   |\n            sub-block 4  Stage 2  |      NA       |   4 <0,1,3>   |\n                         Stage 3  |      NA       |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                Sum               |  24 <3,6,15>  |  48 <2,12,34> |\n----------------------------------+---------------+---------------+\nEmpty frame indicator             |   1 <0,0,1>   |   1 <0,0,1>   |\n-------------------------------------------------------------------\nSUM                                 304 <48,64,192> 400 <64,96,240>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 3.2. The bitstream definition for iLBC for both the 20 ms frame size mode and the 30 ms frame size mode.",
      "ja": "表3.2。 20ミリ秒のフレームサイズモードと30ミリ秒のフレームサイズモードの両方のためにiLBCのためのビットストリーム定義。"
    },
    {
      "indent": 3,
      "text": "When packetized into the payload, the bits MUST be sorted as follows: All the class 1 bits in the order (from top to bottom) as specified in the table, all the class 2 bits (from top to bottom), and all the class 3 bits in the same sequential order. The last bit, the empty frame indicator, SHOULD be set to zero by the encoder. If this bit is set to 1 the decoder SHOULD treat the data as a lost frame. For example, this bit can be set to 1 to indicate lost frame for file storage format, as in [1].",
      "ja": "（上から下へ）テーブルで指定されるように、全てのクラス2ビット（上から下へ）ために、すべてのクラス1ビット、およびすべてのクラス：ペイロードにパケット化するとき、ビットは次のようにソートする必要があります同じ順番に3ビット。最後のビットは、空のフレームインジケータは、エンコーダによってゼロに設定されるべきです。このビットが1に設定されている場合、復号器は、失われたフレームのデータを扱うべきです。例えば、このビットが[1]のように、ファイルの格納フォーマットの失われたフレームを示すために1に設定することができます。"
    },
    {
      "indent": 0,
      "text": "4. Decoder Principles",
      "section_title": true,
      "ja": "4.デコーダの原則"
    },
    {
      "indent": 3,
      "text": "This section describes the principles of each component of the decoder algorithm.",
      "ja": "このセクションでは、デコーダアルゴリズムの各成分の原理を説明しています。"
    },
    {
      "indent": 3,
      "text": "           +-------------+    +--------+    +---------------+\npayload -> | 1. Get para | -> | 2. LPC | -> | 3. Sc Dequant | ->\n           +-------------+    +--------+    +---------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "   +-------------+    +------------------+\n-> | 4. Mem setup| -> | 5. Construct res |------->\n|  +-------------+    +-------------------   |\n---------<-----------<-----------<------------\n          Sub-frame 0...2/4 (20 ms/30 ms)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "   +----------------+    +----------+\n-> | 6. Enhance res | -> | 7. Synth | ------------>\n   +----------------+    +----------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "   +-----------------+\n-> | 8. Post Process | ----------------> decoded speech\n   +-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 4.1. Flow chart of the iLBC decoder. If a frame was lost, steps 1 to 5 SHOULD be replaced by a PLC algorithm.",
      "ja": "図4.1。 iLBCのデコーダのチャートを流れます。フレームが失われた場合は、1〜5は、PLCアルゴリズムによって交換する必要があります繰り返します。"
    },
    {
      "indent": 3,
      "text": "1. Extract the parameters from the bitstream.",
      "section_title": true,
      "ja": "1.ビットストリームからパラメータを抽出します。"
    },
    {
      "indent": 3,
      "text": "2. Decode the LPC and interpolate (section 4.1).",
      "section_title": true,
      "ja": "2. LPCを復号し（セクション4.1）を補間します。"
    },
    {
      "indent": 3,
      "text": "3. Construct the 57/58-sample start state (section 4.2).",
      "section_title": true,
      "ja": "3. 58分の57サンプルの開始状態（セクション4.2）を構築。"
    },
    {
      "indent": 3,
      "text": "4. Set up the memory by using data from the decoded residual. This memory is used for codebook construction. For blocks preceding the start state, both the decoded residual and the target are time reversed. Sub-frames are decoded in the same order as they were encoded.",
      "ja": "4.復号された残差からのデータを使用してメモリを設定します。このメモリは、コードブックの構築のために使用されます。開始状態に先行するブロック、残差復号化とターゲットの両方のための時間が逆になっています。サブフレームは、それらが符号化されたと同じ順序で復号されます。"
    },
    {
      "indent": 3,
      "text": "5. Construct the residuals of this sub-frame (gain[0]*cbvec[0] + gain[1]*cbvec[1] + gain[2]*cbvec[2]). Repeat 4 and 5 until the residual of all sub-blocks has been constructed.",
      "ja": "5.このサブフレームの残差構築物（ゲイン[0] * cbvec [0] +ゲイン[1] * cbvecを[1] +ゲイン[2] * cbvec [2]）。すべてのサブブロックの残差が構築されるまで4及び5を繰り返します。"
    },
    {
      "indent": 3,
      "text": "6. Enhance the residual with the post filter (section 4.6).",
      "section_title": true,
      "ja": "前記ポストフィルタ（セクション4.6）を用いて残留を増強します。"
    },
    {
      "indent": 3,
      "text": "7. Synthesis of the residual (section 4.7).",
      "section_title": true,
      "ja": "残留（セクション4.7）に記載の合成。"
    },
    {
      "indent": 3,
      "text": "8. Post process with HP filter, if desired (section 4.8).",
      "section_title": true,
      "ja": "HPフィルタ8.ポストプロセスは、必要に応じて（セクション4.8）。"
    },
    {
      "indent": 0,
      "text": "4.1. LPC Filter Reconstruction",
      "section_title": true,
      "ja": "4.1。 LPCフィルタの復興"
    },
    {
      "indent": 3,
      "text": "The decoding of the LP filter parameters is very straightforward. For a set of three/six indices, the corresponding LSF vector(s) are found by simple table lookup. For each of the LSF vectors, the three split vectors are concatenated to obtain qlsf1 and qlsf2, respectively (in the 20 ms mode only one LSF vector, qlsf, is constructed). The next step is the stability check described in section 3.2.5 followed by the interpolation scheme described in section 3.2.6 (3.2.7 for 20 ms frames). The only difference is that only the quantized LSFs are known at the decoder, and hence the unquantized LSFs are not processed.",
      "ja": "LPフィルタパラメータの復号化は非常に簡単です。 3/6インデックスのセットに対して、対応するLSFベクト​​ル（S）は、単純なテーブル・ルックアップによって見出されます。 LSFベクト​​ルのそれぞれについて、3つの分割されたベクターは、（一方のみLSFベクト​​ル、qlsfが、構築される20ミリ秒モードで）は、それぞれ、qlsf1とqlsf2を得るために連結されています。次のステップは、セクション3.2.6（20ミリ秒のフレームについて3.2.7）に記載の補間スキームが続くセクション3.2.5に記載の安定性チェックです。唯一の違いは、量子化されたLSFがデコーダに知られており、したがって量子化されていないのLSFが処理されないということです。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the LPC filter reconstruction is given in Appendix A.36.",
      "ja": "LPCフィルタの再構成のリファレンス実装は、付録A.36で与えられます。"
    },
    {
      "indent": 0,
      "text": "4.2. Start State Reconstruction",
      "section_title": true,
      "ja": "4.2。国家再建を開始します"
    },
    {
      "indent": 3,
      "text": "The scalar encoded STATE_SHORT_LEN=58 (STATE_SHORT_LEN=57 in the 20 ms mode) state samples are reconstructed by 1) forming a set of samples (by table lookup) from the index stream idxVec[n], 2) multiplying the set with 1/scal=(10^qmax)/4.5, 3) time reversing the 57/58 samples, 4) filtering the time reversed block with the dispersion (all-pass) filter used in the encoder (as described in section 3.5.2); this compensates for the phase distortion of the earlier filter operation, and 5 reversing the 57/58 samples from the previous step.",
      "ja": "スカラー/ 1でSTATE_SHORT_LEN = 58（STATE_SHORT_LEN =モード20ミリ秒57）の状態のサンプルは索引ストリームidxVec [N]からテーブル検索によるサンプルのセット（）を形成する）1によって再構成され、2）乗算セットをコード年度=（10 ^ Qmaxの）/4.5、3）時間57/58試料を逆転、4）（セクション3.5.2で説明したように）エンコーダで使用される分散液（全通過）フィルタを用いて時間反転ブロックをフィルタリングします。これは、以前のフィルタ演算の位相歪みを補償し、及び5は、前のステップから57/58の試料を逆転します。"
    },
    {
      "indent": 3,
      "text": "in(0..(STATE_SHORT_LEN-1)) = time reversed samples from table look-up, idxVecDec((STATE_SHORT_LEN-1)..0)",
      "ja": "（0 ..（STATE_SHORT_LEN-1））に=時間idxVecDec（（STATE_SHORT_LEN-1）.. 0）、テーブルルックアップからサンプルを逆"
    },
    {
      "indent": 3,
      "text": "in(STATE_SHORT_LEN..(2*STATE_SHORT_LEN-1)) = 0",
      "ja": "（STATE_SHORT_LEN ..（2 * STATE_SHORT_LEN-1））= 0で"
    },
    {
      "indent": 3,
      "text": "Pk(z) = A~rk(z)/A~k(z), where\n                               ___\n                               \\\nA~rk(z)= z^(-LPC_FILTERORDER) + > a~ki*z^(i-(LPC_FILTERORDER-1))\n                               /__\n                           i=0...(LPC_FILTERORDER-1)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and A~k(z) is taken from the block where the start state begins",
      "ja": "開始状態が始まるとA〜K（z）は、ブロックから取られます"
    },
    {
      "indent": 3,
      "text": "in -> Pk(z) -> filtered",
      "ja": "そして - > Pkの（Z） - >濾過"
    },
    {
      "indent": 3,
      "text": "out(k) = filtered(STATE_SHORT_LEN-1-k) + filtered(2*STATE_SHORT_LEN-1-k), k=0..(STATE_SHORT_LEN-1)",
      "ja": "OUT（k）は、濾過（STATE_SHORT_LEN-1-A）+ろ過=（2 * STATE_SHORT_LEN-1-K）、K = 0 ..（STATE_SHORT_LEN-1）"
    },
    {
      "indent": 3,
      "text": "The remaining 23/22 samples in the state are reconstructed by the same adaptive codebook technique described in section 4.3. The location bit determines whether these are the first or the last 23/22 samples of the 80-sample state vector. If the remaining 23/22 samples are the first samples, then the scalar encoded STATE_SHORT_LEN state samples are time-reversed before initialization of the adaptive codebook memory vector.",
      "ja": "状態のまま22分の23個のサンプルはセクション4.3に記載したのと同じ適応コードブック技術によって再構築されます。位置ビットは、これらが第一または80サンプルの状態ベクトルの最後の22分の23個のサンプルであるか否かを判断します。残りの22分の23個のサンプルが最初のサンプルである場合、スカラーはSTATE_SHORT_LEN状態サンプルは適応コードブックメモリベクトルの初期化の前に時間反転されている符号化されました。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the start state reconstruction is given in Appendix A.44.",
      "ja": "開始状態の再構成のリファレンス実装は、付録A.44で与えられます。"
    },
    {
      "indent": 0,
      "text": "4.3. Excitation Decoding Loop",
      "section_title": true,
      "ja": "4.3。励起デコードループ"
    },
    {
      "indent": 3,
      "text": "The decoding of the LPC excitation vector proceeds in the same order in which the residual was encoded at the encoder. That is, after the decoding of the entire 80-sample state vector, the forward sub-blocks (corresponding to samples occurring after the state vector samples) are decoded, and then the backward sub-blocks (corresponding to samples occurring before the state vector) are decoded, resulting in a fully decoded block of excitation signal samples.",
      "ja": "LPC励振ベクトルの復号化は、残差を符号器で符号化されたのと同じ順序で進行します。すなわち、全体の80サンプルの状態ベクトルの復号後、フォワードサブブロックは、状態ベクトルの前に発生するサンプルに対応する復号化され、そして次に下位サブブロック（（状態ベクトルサンプルの後に生じるサンプルに相当します） ）励起信号サンプルの完全に復号されたブロックが得られる、復号されます。"
    },
    {
      "indent": 3,
      "text": "In particular, each sub-block is decoded by using the multistage adaptive codebook decoding module described in section 4.4. This module relies upon an adaptive codebook memory constructed before each run of the adaptive codebook decoding. The construction of the adaptive codebook memory in the decoder is identical to the method outlined in section 3.6.3, except that it is done on the codebook memory without perceptual weighting.",
      "ja": "具体的には、各サブブロックは、セクション4.4で説明した多段適応コードブック復号化モジュールを用いてデコードされます。このモジュールは、適応コードブック復号化の各実行の前に構築された適応コードブックメモリに依存しています。デコーダにおける適応コードブックメモリの構造は、それが知覚的重み付けなしコードブックメモリで行われることを除いて、セクション3.6.3に概説された方法と同一です。"
    },
    {
      "indent": 3,
      "text": "For the initial forward sub-block, the last STATE_LEN=80 samples of the length CB_LMEM=147 adaptive codebook memory are filled with the samples of the state vector. For subsequent forward sub-blocks, the first SUBL=40 samples of the adaptive codebook memory are discarded, the remaining samples are shifted by SUBL samples toward the beginning of the vector, and the newly decoded SUBL=40 samples are placed at the end of the adaptive codebook memory. For backward sub-blocks, the construction is similar, except that every vector of samples involved is first time reversed.",
      "ja": "初期フォワードサブブロックのために、長さCB_LMEM = 147適応コードブックメモリの最後STATE_LEN = 80個のサンプルは、状態ベクトルのサンプルが充填されています。後続のフォワードサブブロックについて、最初SUBL =適応コードブックメモリの40個のサンプルが廃棄されるが、残りのサンプルは、ベクトルの始めに向かってSUBLサンプルだけシフトされ、新たに復号されたSUBL = 40サンプルをの端部に配置されています適応コードブックメモリ。下位サブブロックのために、構造が関与するサンプルのすべてのベクトルが初めて反転されることを除いて、同様です。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the excitation decoding loop is found in Appendix A.5.",
      "ja": "励起復号ループのリファレンス実装は、付録A.5に見出されます。"
    },
    {
      "indent": 0,
      "text": "4.4. Multistage Adaptive Codebook Decoding",
      "section_title": true,
      "ja": "4.4。多段適応コードブックのデコード"
    },
    {
      "indent": 3,
      "text": "The Multistage Adaptive Codebook Decoding module is used at both the sender (encoder) and the receiver (decoder) ends to produce a synthetic signal in the residual domain that is eventually used to produce synthetic speech. The module takes the index values used to construct vectors that are scaled and summed together to produce a synthetic signal that is the output of the module.",
      "ja": "多段適応コードブック復号化モジュールは、両方の送信者（エンコーダ）で使用され、受信機（復号器）は、最終的に合成音声を生成するために使用される残余ドメインにおいて合成信号を生成するために終了します。モジュールは、スケーリングされ、モジュールの出力である合成信号を生成するために一緒に合計されるベクターを構築するために使用されるインデックス値をとります。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Construction of the Decoded Excitation Signal",
      "section_title": true,
      "ja": "4.4.1。復号音源信号の構築"
    },
    {
      "indent": 3,
      "text": "The unpacked index values provided at the input to the module are references to extended codebooks, which are constructed as described in section 3.6.3, except that they are based on the codebook memory without the perceptual weighting. The unpacked three indices are used to look up three codebook vectors. The unpacked three gain indices are used to decode the corresponding 3 gains. In this decoding, the successive rescaling, as described in section 3.6.4.2, is applied.",
      "ja": "モジュールへの入力に設けられたアンパック指標値は、それらが知覚的重み付けなしのコードブックメモリに基づいていることを除いて、セクション3.6.3に記載されるように構成されている拡張コードブックへの参照です。アンパック3つの指数は3つのコードブックベクトルをルックアップするために使用されています。アンパック3つの利得インデックスは、対応する3つの利益を復号するために使用されます。この復号では、連続した再スケーリングは、セクション3.6.4.2に記載されているように、適用されます。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the adaptive codebook decoding is listed in Appendix A.32.",
      "ja": "適応コードブック復号のリファレンス実装は、付録A.32に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.5. Packet Loss Concealment",
      "section_title": true,
      "ja": "4.5。パケット損失隠蔽"
    },
    {
      "indent": 3,
      "text": "If packet loss occurs, the decoder receives a signal saying that information regarding a block is lost. For such blocks it is RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create a decoded signal that masks the effect of that packet loss. In the following we will describe an example of a PLC unit that can be used with the iLBC codec. As the PLC unit is used only at the decoder, the PLC unit does not affect interoperability between implementations. Other PLC implementations MAY therefore be used.",
      "ja": "パケットロスが発生した場合、デコーダは、ブロックに関する情報が失われたという信号を受信します。このようなブロックのためにそのマスクそのパケット損失の影響を復号信号を作成するために、パケット損失隠蔽（PLC）ユニットを使用することが推奨されます。以下では、iLBCのコーデックと共に使用することができるPLCユニットの一例を説明します。 PLCユニットは、デコーダでのみ使用されるように、PLCユニットは、実装間の相互運用性に影響を及ぼしません。他のPLCの実装は、したがって、使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The PLC described operates on the LP filters and the excitation signals and is based on the following principles:",
      "ja": "LPフィルタ励起信号で動作し、以下の原則に基づいて説明したPLC："
    },
    {
      "indent": 0,
      "text": "4.5.1. Block Received Correctly and Previous Block Also Received",
      "section_title": true,
      "ja": "4.5.1。ブロックが正しく受信し、前のブロックはまた、受信します"
    },
    {
      "indent": 3,
      "text": "If the block is received correctly, the PLC only records state information of the current block that can be used in case the next block is lost. The LP filter coefficients for each sub-block and the entire decoded excitation signal are all saved in the decoder state structure. All of this information will be needed if the following block is lost.",
      "ja": "ブロックが正しく受信された場合、PLCは、次のブロックが失われた場合にも使用することができる現在のブロックの状態情報を記録します。各サブブロック及び全体の復号化励起信号のLPフィルタ係数は全てのデコーダ状態構造に保存されています。次のブロックが失われた場合、この情報のすべてが必要になります。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Block Not Received",
      "section_title": true,
      "ja": "4.5.2。ブロックを受信しません"
    },
    {
      "indent": 3,
      "text": "If the block is not received, the block substitution is based on a pitch-synchronous repetition of the excitation signal, which is filtered by the last LP filter of the previous block. The previous block's information is stored in the decoder state structure.",
      "ja": "ブロックが受信されない場合、ブロック置換は、前のブロックの最後のLPフィルタによってフィルタリングされた励起信号のピッチ同期反復に基づいています。前のブロックの情報は、デコーダ状態構造に格納されます。"
    },
    {
      "indent": 3,
      "text": "A correlation analysis is performed on the previous block's excitation signal in order to detect the amount of pitch periodicity and a pitch value. The correlation measure is also used to decide on the voicing level (the degree to which the previous block's excitation was a voiced or roughly periodic signal). The excitation in the previous block is used to create an excitation for the block to be substituted, such that the pitch of the previous block is maintained. Therefore, the new excitation is constructed in a pitch-synchronous manner. In order to avoid a buzzy-sounding substituted block, a random excitation is mixed with the new pitch periodic excitation, and the relative use of the two components is computed from the correlation measure (voicing level).",
      "ja": "相関分析は、ピッチ周期とピッチ値の量を検出するために前のブロックの励起信号に対して実行されます。相関測度はまた、発声レベル（前のブロックの励起が有声または略周期的な信号であった程度）を決定するために使用されます。前のブロックにおける励起は、前のブロックのピッチが維持されるように、置換すべきブロックの励起を作成するために使用されます。したがって、新たな励起はピッチ同期して構成されています。 buzzy響き置換ブロックを避けるために、ランダム励起は新しいピッチ周期的励起と混合され、2つの成分の相対的な使用は、相関測度（発声レベル）から計算されます。"
    },
    {
      "indent": 3,
      "text": "For the block to be substituted, the newly constructed excitation signal is then passed through the LP filter to produce the speech that will be substituted for the lost block.",
      "ja": "置換すべきブロックに対して、新たに構築された励起信号は、失われたブロックを置換する音声を生成するLPフィルタに通されます。"
    },
    {
      "indent": 3,
      "text": "For several consecutive lost blocks, the packet loss concealment continues in a similar manner. The correlation measure of the last block received is still used along with the same pitch value. The LP filters of the last block received are also used again. The energy of the substituted excitation for consecutive lost blocks is decreased, leading to a dampened excitation, and therefore to dampened speech.",
      "ja": "いくつかの連続した失われたブロックの場合、パケット損失隠蔽は、同様の方法で継続します。受信された最後のブロックの相関測度は、依然として同じピッチ値と共に使用されています。受け取った最後のブロックのLPフィルタも再び使用されています。連続する失われたブロックの置換された励起のエネルギーは、音声を減衰することが湿らせた励起につながる、減少、およびれます。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Block Received Correctly When Previous Block Not Received",
      "section_title": true,
      "ja": "4.5.3。前のブロックが受信されない場合にはブロックが正しく受信しました"
    },
    {
      "indent": 3,
      "text": "For the case in which a block is received correctly when the previous block was not, the correctly received block's directly decoded speech (based solely on the received block) is not used as the actual output. The reason for this is that the directly decoded speech does not necessarily smoothly merge into the synthetic speech generated for the previous lost block. If the two signals are not smoothly merged, an audible discontinuity is accidentally produced. Therefore, a correlation analysis between the two blocks of excitation signal (the excitation of the previous concealed block and that of the current received block) is performed to find the best phase match. Then a simple overlap-add procedure is performed to merge the previous excitation smoothly into the current block's excitation.",
      "ja": "前ブロックがなかった場合にブロックが正しく受信された場合のために、（単独で受信されたブロックに基づいて）正常に受信されたブロックの直接復号された音声は、実際の出力として使用されていません。この理由は、直接復号された音声は、必ずしもスムーズ以前失われたブロックに対して生成された合成音声にマージしないことです。 2つの信号はスムーズにマージされていない場合は、可聴不連続が誤って生成されます。したがって、励起信号（前の隠蔽ブロックの励磁、現在受信されたブロックのこと）の2つのブロック間の相関分析は、最良の位相マッチを見つけるために実行されます。単純なオーバーラップ加算手順は、現在のブロックの励起に円滑に前励起をマージするために行われます。"
    },
    {
      "indent": 3,
      "text": "The exact implementation of the packet loss concealment does not influence interoperability of the codec.",
      "ja": "パケット損失隠蔽の正確な実装は、コーデックの相互運用性に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the packet loss concealment is suggested in Appendix A.14. Exact compliance with this suggested algorithm is not needed for a reference implementation to be fully compatible with the overall codec specification.",
      "ja": "パケット損失隠蔽のリファレンス実装は、付録A.14で提案されます。この提案アルゴリズムで正確なコンプライアンスは、全体的なコーデックの仕様に完全に互換性があるように、リファレンス実装には必要ありません。"
    },
    {
      "indent": 0,
      "text": "4.6. Enhancement",
      "section_title": true,
      "ja": "4.6。エンハンスメント"
    },
    {
      "indent": 3,
      "text": "The decoder contains an enhancement unit that operates on the reconstructed excitation signal. The enhancement unit increases the perceptual quality of the reconstructed signal by reducing the speech-correlated noise in the voiced speech segments. Compared to traditional postfilters, the enhancer has an advantage in that it can only modify the excitation signal slightly. This means that there is no risk of over enhancement. The enhancer works very similarly for both the 20 ms frame size mode and the 30 ms frame size mode.",
      "ja": "デコーダは、再構成された励起信号上で動作する拡張部を含んでいます。強調部は、有声音音声セグメントにおける音声相関ノイズを低減することによって再構成された信号の知覚品質を向上させます。伝統的なポストフィルタと比較すると、エンハンサーは、それがわずかに励起信号を修正することができるという利点がでています。これは、エンハンスメントオーバーの危険がないことを意味します。エンハンサーは、20ミリ秒のフレームサイズモードと30ミリ秒のフレームサイズモードの両方のために非常に似ています。"
    },
    {
      "indent": 3,
      "text": "For the mode with 20 ms frame size, the enhancer uses a memory of six 80-sample excitation blocks prior in time plus the two new 80-sample excitation blocks. For each block of 160 new unenhanced excitation samples, 160 enhanced excitation samples are produced. The enhanced excitation is 40-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.",
      "ja": "20ミリ秒のフレームサイズのモードのために、エンハンサーは、前の時間の6つの80サンプルの励起ブロックと2つの新しい80サンプルの励起ブロックのメモリを使用します。 160個の新しい未強調音源サンプルのブロック毎に、160個の拡張音源サンプルが生成されます。エンハンサーアルゴリズムは、先読みを使用するように拡張励起は、未強調励起に比べ遅延40サンプルです。"
    },
    {
      "indent": 3,
      "text": "For the mode with 30 ms frame size, the enhancer uses a memory of five 80-sample excitation blocks prior in time plus the three new 80-sample excitation blocks. For each block of 240 new unenhanced excitation samples, 240 enhanced excitation samples are produced. The enhanced excitation is 80-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.",
      "ja": "30ミリ秒のフレームサイズのモードのために、エンハンサーは、時間的に前プラスつの新しい80サンプル励起ブロック5 80サンプルの励起ブロックのメモリを使用します。 240個の新しい未強調音源サンプルのブロック毎に、240個の拡張音源サンプルが生成されます。エンハンサーアルゴリズムは、先読みを使用するように拡張励起は、未強調励起に比べ遅延80サンプルです。"
    },
    {
      "indent": 3,
      "text": "Outline of Enhancer",
      "ja": "エンハンサーの概要"
    },
    {
      "indent": 3,
      "text": "The speech enhancement unit operates on sub-blocks of 80 samples, which means that there are two/three 80 sample sub-blocks per frame. Each of these two/three sub-blocks is enhanced separately, but in an analogous manner.",
      "ja": "音声強調部は、フレーム当たり2つ/ 3 80サンプルのサブブロックが存在することを意味する、80個のサンプルのサブブロック上で動作します。これら二つ/三つのサブブロックの各々を別々に向上するが、同様の方法でされています。"
    },
    {
      "indent": 3,
      "text": "unenhanced residual\n        |\n        |   +---------------+    +--------------+\n        +-> | 1. Pitch Est  | -> | 2. Find PSSQ | -------->\n            +---------------+  | +--------------+\n                               +-----<-------<------<--+\n            +------------+         enh block 0..1/2    |\n         -> | 3. Smooth  |                             |\n            +------------+                             |\n              \\                                        |\n              /\\                                       |\n             /  \\   Already                            |\n            / 4. \\----------->----------->-----------+ |\n            \\Crit/ Fulfilled                         | |\n             \\? /                                    v |\n              \\/                                     | |\n               \\  +-----------------+    +---------+ | |\n           Not +->| 5. Use Constr.  | -> | 6. Mix  | ----->\n        Fulfilled +-----------------+    +---------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "---------------> enhanced residual",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 4.2. Flow chart of the enhancer.",
      "ja": "図4.2。エンハンサーのチャートフロー。"
    },
    {
      "indent": 3,
      "text": "1. Pitch estimation of each of the two/three new 80-sample blocks.",
      "section_title": true,
      "ja": "2/3の新しい80-サンプルブロックのそれぞれの1ピッチ推定。"
    },
    {
      "indent": 3,
      "text": "2. Find the pitch-period-synchronous sequence n (for block k) by a search around the estimated pitch value. Do this for n=1,2,3, -1,-2,-3.",
      "ja": "前記推定されたピッチ値の周りに検索することによって（ブロックkの）ピッチ周期同期シーケンスnを探します。 、N = 1,2,3、-1、-2のためにこれを行う-3。"
    },
    {
      "indent": 3,
      "text": "3. Calculate the smoothed residual generated by the six pitch-period-synchronous sequences from prior step.",
      "ja": "3.前ステップから六ピッチ周期同期シーケンスによって生成された平滑化された残差を計算します。"
    },
    {
      "indent": 3,
      "text": "4. Check if the smoothed residual satisfies the criterion (section 4.6.4).",
      "ja": "4.チェック平滑化残留満たしていれば基準（セクション4.6.4）。"
    },
    {
      "indent": 3,
      "text": "5. Use constraint to calculate mixing factor (section 4.6.5).",
      "section_title": true,
      "ja": "5.制約因子（セクション4.6.5）の混合算出します。"
    },
    {
      "indent": 3,
      "text": "6. Mix smoothed signal with unenhanced residual (pssq(n) n=0).",
      "section_title": true,
      "ja": "6.ミックス平滑未強調残差の信号（pssq（N）= 0）。"
    },
    {
      "indent": 3,
      "text": "The main idea of the enhancer is to find three 80 sample blocks before and three 80-sample blocks after the analyzed unenhanced sub-block and to use these to improve the quality of the excitation in that sub-block. The six blocks are chosen so that they have the highest possible correlation with the unenhanced sub-block that is being enhanced. In other words, the six blocks are pitch-period-synchronous sequences to the unenhanced sub-block.",
      "ja": "エンハンサーの主なアイデアは、分析非増強サブブロックの後に前3つの80サンプルブロックと3 80-サンプルブロックを見つけて、そのサブブロックに励起の品質を向上させるためにこれらを使用することです。彼らは強化されている未強調サブブロックと可能な限り高い相関を有するように6つのブロックが選択されます。換言すれば、6つのブロックは未強調サブブロックにピッチ周期同期配列です。"
    },
    {
      "indent": 3,
      "text": "A linear combination of the six pitch-period-synchronous sequences is calculated that approximates the sub-block. If the squared error between the approximation and the unenhanced sub-block is small enough, the enhanced residual is set equal to this approximation. For the cases when the squared error criterion is not fulfilled, a linear combination of the approximation and the unenhanced residual forms the enhanced residual.",
      "ja": "6ピッチ周期同期シーケンスの線形組み合わせは、サブブロックを近似するように計算されます。近似と未強調サブブロックとの間の二乗誤差が十分に小さい場合、拡張残差はこの近似に等しく設定されます。二乗誤差基準が満たされない場合のために、近似の線形結合と非造影残留フォームが残留強化します。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Estimating the Pitch",
      "section_title": true,
      "ja": "4.6.1。ピッチの推定"
    },
    {
      "indent": 3,
      "text": "Pitch estimates are needed to determine the locations of the pitch-period-synchronous sequences in a complexity-efficient way. For each of the new two/three sub-blocks, a pitch estimate is calculated by finding the maximum correlation in the range from lag 20 to lag 120. These pitch estimates are used to narrow down the search for the best possible pitch-period-synchronous sequences.",
      "ja": "ピッチ推定は複雑さ、効率的な方法でピッチ周期同期シーケンスの位置を決定するために必要とされます。新しい2/3のサブブロックの各々に対して、ピッチ推定値は、これらのピッチ推定値が、可能な限り最高のピッチ期の検索を絞り込むために使用される120をラグするラグ20の範囲の最大相関を求めることにより算出されます同期シーケンス。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Determination of the Pitch-Synchronous Sequences",
      "section_title": true,
      "ja": "4.6.2。ピッチ同期シーケンスの決意"
    },
    {
      "indent": 3,
      "text": "Upon receiving the pitch estimates from the prior step, the enhancer analyzes and enhances one 80-sample sub-block at a time. The pitch-period-synchronous-sequences pssq(n) can be viewed as vectors of length 80 samples each shifted n*lag samples from the current sub-block. The six pitch-period-synchronous-sequences, pssq(-3) to pssq(-1) and pssq(1) to pssq(3), are found one at a time by the steps below:",
      "ja": "前工程からのピッチ推定値を受信すると、エンハンサーは、分析し、一度に80サンプルのサブブロックを増強します。ピッチ周期同期系列のpssq（n）は、長さのベクトルそれぞれが現在のサブブロックからN *遅れサンプルをシフトさ80のサンプルとみなすことができます。 6ピッチ周期同期系列、pssq（-3）pssqする（-1）とpssq（1）pssq〜（3）以下の手順により、一度に一つを発見しています。"
    },
    {
      "indent": 3,
      "text": "1) Calculate the estimate of the position of the pssq(n). For pssq(n) in front of pssq(0) (n > 0), the location of the pssq(n) is estimated by moving one pitch estimate forward in time from the exact location of pssq(n-1). Similarly, pssq(n) behind pssq(0) (n < 0) is estimated by moving one pitch estimate backward in time from the exact location of pssq(n+1). If the estimated pssq(n) vector location is totally within the enhancer memory (Figure 4.3), steps 2, 3, and 4 are performed, otherwise the pssq(n) is set to zeros.",
      "ja": "1）pssq（N）の位置の推定値を計算します。 pssqの正面（0）でpssq（N）（N> 0）の場合、pssqの位置（n）はpssq（N-1）の正確な位置から時間的に前方に1つのピッチ推定値を移動することによって推定されます。同様に、pssq後ろpssq（N）（0）（N <0）pssq（N + 1）の正確な位置から時間的に後方に1つのピッチ推定値を移動することによって推定されます。推定pssq（n）のベクトル位置は、完全エンハンサーメモリ（図4.3）の範囲内である、2ステップ、および4が実行される場合、そうでない場合pssq（n）はゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "2) Compute the correlation between the unenhanced excitation and vectors around the estimated location interval of pssq(n). The correlation is calculated in the interval estimated location +/- 2 samples. This results in five correlation values.",
      "ja": "2）pssq（N）の推定位置の間隔の周りに未強調励起とベクトル間の相関を計算します。相関は、間隔推定位置+/- 2サンプルにおいて計算されます。これは、5つの相関値になります。"
    },
    {
      "indent": 3,
      "text": "3) The five correlation values are upsampled by a factor of 4, by using four simple upsampling filters (MA filters with coefficients upsFilter1.. upsFilter4). Within these the maximum value is found, which specifies the best pitch-period with a resolution of a quarter of a sample.",
      "ja": "3）5つの相関値は、4つの単純なアップサンプリングフィルタ（係数upsFilter1 .. upsFilter4とMAフィルタ）を用いて、4倍にアップサンプリングされます。これらの中で最大値は、サンプルの四半期の解像度を持つ最高のピッチ期間を指定する、発見されました。"
    },
    {
      "indent": 6,
      "text": "upsFilter1[7]={0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000} upsFilter2[7]={0.015625 -0.076904 0.288330 0.862061 -0.106445 0.018799 -0.015625} upsFilter3[7]={0.023682 -0.124268 0.601563 0.601563 -0.124268 0.023682 -0.023682} upsFilter4[7]={0.018799 -0.106445 0.862061 0.288330 -0.076904 0.015625 -0.018799}",
      "ja": "upsFilter1 [7] = {0.000000 0.000000 0.000000 1.000000 0.000000 0.000000 0.000000} upsFilter2 [7] = {0.015625 -0.076904 0.288330 0.862061 -0.106445 0.018799 -0.015625} upsFilter3 [7] = {0.023682 -0.124268 0.601563 0.601563 -0.124268 0.023682 -0.023682} upsFilter4 [ 7] = {0.018799 -0.106445 0.862061 0.288330 -0.076904 0.015625 -0.018799}"
    },
    {
      "indent": 3,
      "text": "4) Generate the pssq(n) vector by upsampling of the excitation memory and extracting the sequence that corresponds to the lag delay that was calculated in prior step.",
      "ja": "4）励起メモリのアップサンプリングによってpssq（n）のベクトルを生成し、前のステップで計算されたラグ遅延に対応する配列を抽出します。"
    },
    {
      "indent": 3,
      "text": "With the steps above, all the pssq(n) can be found in an iterative manner, first moving backward in time from pssq(0) and then forward in time from pssq(0).",
      "ja": "以上の工程で、全てpssq（n）は第一pssq（0）から時間的に前方に、次にpssq（0）から時間的に後方に移動すると、反復的に求めることができます。"
    },
    {
      "indent": 3,
      "text": "0              159             319             479             639\n+---------------------------------------------------------------+\n|  -5   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |\n+---------------------------------------------------------------+\n                                            |pssq 0 |\n                                       |pssq -1| |pssq 1 |\n                                    |pssq -2|       |pssq 2 |\n                                 |pssq -3|             |pssq 3 |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 4.3. Enhancement for 20 ms frame size.",
      "ja": "図4.3。 20ミリ秒のフレームサイズの向上。"
    },
    {
      "indent": 3,
      "text": "Figure 4.3 depicts pitch-period-synchronous sequences in the enhancement of the first 80 sample block in the 20 ms frame size mode. The unenhanced signal input is stored in the last two sub-blocks (1 - 2), and the six other sub-blocks contain unenhanced residual prior-in-time. We perform the enhancement algorithm on two blocks of 80 samples, where the first of the two blocks consists of the last 40 samples of sub-block 0 and the first 40 samples of sub-block 1. The second 80-sample block consists of the last 40 samples of sub-block 1 and the first 40 samples of sub-block 2.",
      "ja": "図4.3は、20ミリ秒のフレームサイズモードにおける第1の80サンプルブロックの増強におけるピッチ周期同期シーケンスを示します。未強調信号入力は、最後の2つのサブブロック（1  -  2）に格納されており、他の6つのサブブロックが未強調残留前・イン・タイムを含みます。第80サンプルのブロックは、から成る1。我々は、2つのブロックの最初のサブブロック0の最後の40のサンプルとサブブロックの最初の40個のサンプルから成る80個のサンプル、の二つのブロックに拡張アルゴリズムを実行しますサブブロック1の最後の40のサンプルとサブブロック2の最初の40個のサンプル。"
    },
    {
      "indent": 3,
      "text": "0              159             319             479             639\n+---------------------------------------------------------------+\n|  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |   3   |\n+---------------------------------------------------------------+\n                                |pssq 0 |\n                           |pssq -1| |pssq 1 |\n                        |pssq -2|       |pssq 2 |\n                     |pssq -3|             |pssq 3 |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 4.4. Enhancement for 30 ms frame size.",
      "ja": "図4.4。 30ミリ秒のフレームサイズの向上。"
    },
    {
      "indent": 3,
      "text": "Figure 4.4 depicts pitch-period-synchronous sequences in the enhancement of the first 80-sample block in the 30 ms frame size mode. The unenhanced signal input is stored in the last three sub-blocks (1 - 3). The five other sub-blocks contain unenhanced residual prior-in-time. The enhancement algorithm is performed on the three 80 sample sub-blocks 0, 1, and 2.",
      "ja": "図4.4は、30ミリ秒のフレームサイズモードにおける第1の80サンプルブロックの増強におけるピッチ周期同期シーケンスを示します。未強調信号入力は、最後の三つのサブブロック（3  -  1）に格納されています。他の5つのサブブロックが非増強残留前・イン・タイムが含まれています。強調アルゴリズムは、三個の80サンプルのサブブロック0,1、および2に対して行われます。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Calculation of the Smoothed Excitation",
      "section_title": true,
      "ja": "4.6.3。平滑化励起の計算"
    },
    {
      "indent": 3,
      "text": "A linear combination of the six pssq(n) (n!=0) form a smoothed approximation, z, of pssq(0). Most of the weight is put on the sequences that are close to pssq(0), as these are likely to be most similar to pssq(0). The smoothed vector is also rescaled so that the energy of z is the same as the energy of pssq(0).",
      "ja": "6 pssqの線形組み合わせは、（N）（N！= 0）（0）pssqの平滑化近似、Zを形成します。これらは（0）pssqに最も類似である可能性が高いと重量のほとんどは、（0）pssqに近い配列に置かれています。 Zのエネルギーがpssq（0）のエネルギーと同じになるように平滑化されたベクターはまた、再スケーリングされます。"
    },
    {
      "indent": 3,
      "text": "   ___\n   \\\ny = > pssq(i) * pssq_weight(i)\n   /__\ni=-3,-2,-1,1,2,3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "pssq_weight(i) = 0.5*(1-cos(2*pi*(i+4)/(2*3+2)))",
      "ja": "pssq_weight（I）= 0.5×（1-COS（2 *パイ*（I + 4）/（2 * 3 + 2）））"
    },
    {
      "indent": 3,
      "text": "z = C * y, where C = ||pssq(0)||/||y||",
      "ja": "Z = Cの* yを、C = || pssq（0）|| / || Y ||"
    },
    {
      "indent": 0,
      "text": "4.6.4. Enhancer Criterion",
      "section_title": true,
      "ja": "4.6.4。エンハンサー基準"
    },
    {
      "indent": 3,
      "text": "The criterion of the enhancer is that the enhanced excitation is not allowed to differ much from the unenhanced excitation. This criterion is checked for each 80-sample sub-block.",
      "ja": "エンハンサーの基準が強化され、励起は非造影励起から多くの異なるすることは許されないということです。この基準は、各80サンプルのサブブロックのためにチェックされます。"
    },
    {
      "indent": 3,
      "text": "e < (b * ||pssq(0)||^2), where b=0.05 and (Constraint 1)",
      "ja": "E <（B * || pssq（0）|| ^ 2）、B = 0.05（制約1）"
    },
    {
      "indent": 3,
      "text": "e = (pssq(0)-z)*(pssq(0)-z), and \"*\" means the dot product",
      "ja": "E =（pssq（0）-Z）*（pssq（0）-Z）、 \"*\" はドット積を意味します"
    },
    {
      "indent": 0,
      "text": "4.6.5. Enhancing the excitation",
      "section_title": true,
      "ja": "4.6.5。励起を強化"
    },
    {
      "indent": 3,
      "text": "From the criterion in the previous section, it is clear that the excitation is not allowed to change much. The purpose of this constraint is to prevent the creation of an enhanced signal significantly different from the original signal. This also means that the constraint limits the numerical size of the errors that the enhancement procedure can make. That is especially important in unvoiced segments and background noise segments for which increased periodicity could lead to lower perceived quality.",
      "ja": "前節の基準から、励起が大きく変化することが許可されていないことは明らかです。この制約の目的は、元の信号と著しく異なる強化信号の生成を防止することです。これはまた、制約は拡張プロシージャを作ることができるエラーの数値サイズを制限することを意味します。すなわち、周期性が低い知覚品質につながる可能性が増加したため無声セグメント、背景雑音区間において特に重要です。"
    },
    {
      "indent": 3,
      "text": "When the constraint in the prior section is not met, the enhanced residual is instead calculated through a constrained optimization by using the Lagrange multiplier technique. The new constraint is that",
      "ja": "前セクションの制約が満たされない場合、拡張残留代わりにラグランジュ乗数法を用いて、制約付き最適化を介して計算されます。新しい制約は、ということです"
    },
    {
      "indent": 6,
      "text": "e = (b * ||pssq(0)||^2) (Constraint 2)",
      "ja": "E =（B * || pssq（0）|| ^ 2）（制約2）"
    },
    {
      "indent": 3,
      "text": "We distinguish two solution regions for the optimization: 1) the region where the first constraint is fulfilled and 2) the region where the first constraint is not fulfilled and the second constraint must be used.",
      "ja": "第1の制約が満たされておらず、第2の制約を使用しなければならない最初の制約条件が満たされた1）領域および2）領域：我々は、最適化のための2つのソリューションの領域を区別する。"
    },
    {
      "indent": 3,
      "text": "In the first case, where the second constraint is not needed, the optimized re-estimated vector is simply z, the energy-scaled version of y.",
      "ja": "第2の制約が必要とされない最初のケースでは、最適化された再推定ベクトルは、Yのエネルギースケーリングされたバージョン単にZです。"
    },
    {
      "indent": 3,
      "text": "In the second case, where the second constraint is activated and becomes an equality constraint, we have",
      "ja": "第2の制約が活性化し、等式制約となっている第二の場合では、我々は持っています"
    },
    {
      "indent": 6,
      "text": "z= A*y + B*pssq(0)",
      "ja": "Z = Y + a * b *表pssq（0）"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 6,
      "text": "A = sqrt((b-b^2/4)*(w00*w00)/ (w11*w00 + w10*w10)) and",
      "ja": "=のSQRT（（B-B ^ 2/4）*（W00の*のW00）/（W11 * W00 + W10 * W10））と"
    },
    {
      "indent": 6,
      "text": "w11 = pssq(0)*pssq(0) w00 = y*y w10 = y*pssq(0) (* symbolizes the dot product)",
      "ja": "W11 = pssq（0）* pssq（0）W00 = Y * Y W10 = Y *のpssq（0）（*内積を象徴）"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "B = 1 - b/2 - A * w10/w00",
      "ja": "B = 1  -  B / 2  -  A * W10 / W00"
    },
    {
      "indent": 3,
      "text": "Appendix A.16 contains a listing of a reference implementation for the enhancement method.",
      "ja": "付録A.16は強調方法のリファレンス実装のリストが含まれています。"
    },
    {
      "indent": 0,
      "text": "4.7. Synthesis Filtering",
      "section_title": true,
      "ja": "4.7。合成フィルタリング"
    },
    {
      "indent": 3,
      "text": "Upon decoding or PLC of the LP excitation block, the decoded speech block is obtained by running the decoded LP synthesis filter, 1/A~k(z), over the block. The synthesis filters have to be shifted to compensate for the delay in the enhancer. For 20 ms frame size mode, they SHOULD be shifted one 40-sample sub-block, and for 30 ms frame size mode, they SHOULD be shifted two 40-sample sub-blocks. The LP coefficients SHOULD be changed at the first sample of every sub-block while keeping the filter state. For PLC blocks, one solution is to apply the last LP coefficients of the last decoded speech block for all sub-blocks.",
      "ja": "LP励起ブロックの復号またはPLCの際に、復号された音声ブロックは、ブロックの上に、1 / A〜K（z）を復号化されたLP合成フィルタを実行することによって得られます。合成フィルタは、エンハンサーでの遅延を補償するようにシフトする必要があります。 20ミリ秒のフレームサイズモードのために、彼らは、一つの40サンプルのサブブロックをシフトする必要があり、30ミリ秒のフレームサイズモードのため、それらは2つの40サンプルのサブブロックにシフトされるべきです。フィルタ状態を維持したままLP係数は、各サブブロックの最初のサンプルで変更する必要があります。 PLCのブロックについて、一つの解決策は、すべてのサブブロックの最後の復号された音声ブロックの最後のLP係数を適用することです。"
    },
    {
      "indent": 3,
      "text": "The reference implementation for the synthesis filtering can be found in Appendix A.48.",
      "ja": "合成フィルタリングのためのリファレンス実装は、付録A.48に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "4.8. Post Filtering",
      "section_title": true,
      "ja": "4.8。ポストフィルタリング"
    },
    {
      "indent": 3,
      "text": "If desired, the decoded block can be filtered by a high-pass filter. This removes the low frequencies of the decoded signal. A reference implementation of this, with cutoff at 65 Hz, is shown in Appendix A.30.",
      "ja": "所望であれば、復号されたブロックは、ハイパスフィルタによってフィルタリングすることができます。これは、復号化された信号の低周波数を除去します。このリファレンス実装は、65 Hzのカットオフを有する、付録A.30に示されています。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This algorithm for the coding of speech signals is not subject to any known security consideration; however, its RTP payload format [1] is subject to several considerations, which are addressed there. Confidentiality of the media streams is achieved by encryption; therefore external mechanisms, such as SRTP [5], MAY be used for that purpose.",
      "ja": "音声信号の符号化のために、このアルゴリズムは、任意の既知のセキュリティの考慮の対象となりません。しかし、そのRTPペイロードフォーマット[1]がアドレス指定されるいくつかの考慮の対象です。メディアストリームの機密性は、暗号化によって達成されます。したがって、そのようなSRTPなどの外部メカニズムは、[5]、その目的に使用することができます。"
    },
    {
      "indent": 0,
      "text": "6. Evaluation of the iLBC Implementations",
      "section_title": true,
      "ja": "iLBCの実装の6評価"
    },
    {
      "indent": 3,
      "text": "It is possible and suggested to evaluate certain iLBC implementation by utilizing methodology and tools available at http://www.ilbcfreeware.org/evaluation.html",
      "ja": "それは可能であるとhttp://www.ilbcfreeware.org/evaluation.htmlで利用できる方法論やツールを利用して、特定のiLBCの実装を評価することが示唆しました"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Duric, A. and S. Andersen, \"Real-time Transport Protocol (RTP) Payload Format for internet Low Bit Rate Codec (iLBC) Speech\", RFC 3952, December 2004.",
      "ja": "[1] Duric、A.とS.アンデルセン、 \"インターネット低ビットレートコーデック（iLBCの）スピーチのためのリアルタイム転送プロトコル（RTP）ペイロードフォーマット\"、RFC 3952、2004年12月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[2]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[3] PacketCable(TM) Audio/Video Codecs Specification, Cable Television Laboratories, Inc.",
      "ja": "[3]のPacketCable（TM）オーディオ/ビデオコーデック仕様、ケーブルテレビラボラトリーズ社"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[4] ITU-T Recommendation G.711, available online from the ITU bookstore at http://www.itu.int.",
      "ja": "[4] ITU-T勧告G.711、ITU http://www.itu.intで書店からオンラインで入手可能。"
    },
    {
      "indent": 3,
      "text": "[5] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norman, \"The Secure Real Time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[5] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK.ノーマン、 \"セキュアリアルタイムトランスポートプロトコル（SRTP）\"、RFC 3711、2004年3月。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "This extensive work, besides listed authors, has the following authors, who could not have been listed among \"official\" authors (due to IESG restrictions in the number of authors who can be listed):",
      "ja": "この大規模な作品は、リストされた著者のほかに、（原因を挙げることができる多くの著者でIESG制限の）「公式」の作者の中に挙げられていることができなかった以下の著者を、持っています："
    },
    {
      "indent": 6,
      "text": "Manohar N. Murthi (Department of Electrical and Computer Engineering, University of Miami), Fredrik Galschiodt, Julian Spittka, and Jan Skoglund (Global IP Sound).",
      "ja": "ManoharさんN. Murthi（電気・コンピュータ工学、マイアミ大学の学部）、フレドリックGalschiodt、ジュリアンSpittka、とJan Skoglund（グローバルIPサウンド）。"
    },
    {
      "indent": 3,
      "text": "The authors are deeply indebted to the following people and thank them sincerely:",
      "ja": "著者は次の方々に深く恩義あると心から彼らに感謝します："
    },
    {
      "indent": 6,
      "text": "Henry Sinnreich, Patrik Faltstrom, Alan Johnston, and Jean-Francois Mule for great support of the iLBC initiative and for valuable feedback and comments.",
      "ja": "ヘンリーSinnreich、パトリックFaltstrom、アラン・ジョンストン、そしてジャン・フランソワ・ミュールiLBCのイニシアチブの素晴らしいサポートのための貴重なフィードバックやコメントについて。"
    },
    {
      "indent": 6,
      "text": "Peter Vary, Frank Mertz, and Christoph Erdmann (RWTH Aachen); Vladimir Cuperman (Niftybox LLC); Thomas Eriksson (Chalmers Univ of Tech), and Gernot Kubin (TU Graz), for thorough review of the iLBC document and their valuable feedback and remarks.",
      "ja": "ピーターは、フランク・メルツを変え、そしてクリストフ・エルドマン（アーヘン）。ウラジミールCuperman（Niftybox LLC）。トーマス・エリクソン（テックのチャルマーズ大学）、およびiLBCの文書の徹底的な見直しのためのゲルノットKubinの（TUグラーツ）、そして彼らの貴重なフィードバックと発言。"
    },
    {
      "indent": 0,
      "text": "APPENDIX A. Reference Implementation",
      "ja": "付録A.リファレンス実装"
    },
    {
      "indent": 3,
      "text": "This appendix contains the complete c-code for a reference implementation of encoder and decoder for the specified codec.",
      "ja": "この付録では、指定されたコーデックのエンコーダおよびデコーダのリファレンス実装のための完全なCコードを含んでいます。"
    },
    {
      "indent": 3,
      "text": "The c-code consists of the following files with highest-level functions:",
      "ja": "Cコードは、最高レベルの機能を持つ以下のファイルで構成されています。"
    },
    {
      "indent": 9,
      "text": "iLBC_test.c: main function for evaluation purpose\niLBC_encode.h: encoder header\niLBC_encode.c: encoder function\niLBC_decode.h: decoder header\niLBC_decode.c: decoder function",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following files contain global defines and constants:",
      "ja": "以下のファイルは、グローバル定義と定数が含まれています。"
    },
    {
      "indent": 9,
      "text": "iLBC_define.h: global defines\nconstants.h: global constants header\nconstants.c: global constants memory allocations",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following files contain subroutines:",
      "ja": "以下のファイルは、サブルーチンが含まれています。"
    },
    {
      "indent": 9,
      "text": "anaFilter.h: lpc analysis filter header\nanaFilter.c: lpc analysis filter function\ncreateCB.h: codebook construction header\ncreateCB.c: codebook construction function\ndoCPLC.h: packet loss concealment header\ndoCPLC.c: packet loss concealment function\nenhancer.h: signal enhancement header\nenhancer.c: signal enhancement function\nfilter.h: general filter header\nfilter.c: general filter functions\nFrameClassify.h: start state classification header\nFrameClassify.c: start state classification function\ngainquant.h: gain quantization header\ngainquant.c: gain quantization function\ngetCBvec.h: codebook vector construction header\ngetCBvec.c: codebook vector construction function\nhelpfun.h: general purpose header\nhelpfun.c: general purpose functions\nhpInput.h: input high pass filter header\nhpInput.c: input high pass filter function\nhpOutput.h: output high pass filter header\nhpOutput.c: output high pass filter function\niCBConstruct.h: excitation decoding header\niCBConstruct.c: excitation decoding function\niCBSearch.h: excitation encoding header\niCBSearch.c: excitation encoding function",
      "raw": true
    },
    {
      "indent": 9,
      "text": "LPCdecode.h: lpc decoding header LPCdecode.c: lpc decoding function LPCencode.h: lpc encoding header LPCencode.c: lpc encoding function lsf.h: line spectral frequencies header lsf.c: line spectral frequencies functions packing.h: bitstream packetization header packing.c: bitstream packetization functions StateConstructW.h: state decoding header StateConstructW.c: state decoding functions StateSearchW.h: state encoding header StateSearchW.c: state encoding function syntFilter.h: lpc synthesis filter header syntFilter.c: lpc synthesis filter function",
      "ja": "LPCdecode.h：LPC復号ヘッダLPCdecode.c：LPC復号関数LPCencode.h：LPC符号化ヘッダLPCencode.c：LPC符号化関数lsf.h：線スペクトル周波数はlsf.cヘッダー：ラインスペクトル周波数関数はpacking.h：ビットストリームのパケットをヘッダpacking.c：ビットストリームのパケット化機能StateConstructW.h：状態デコードヘッダStateConstructW.c：状態デコード機能StateSearchW.h：状態エンコーディングヘッダStateSearchW.c：状態エンコーディング関数syntFilter.h：LPC合成フィルタヘッダsyntFilter.c：LPC合成フィルタ機能"
    },
    {
      "indent": 3,
      "text": "The implementation is portable and should work on many different platforms. However, it is not difficult to optimize the implementation on particular platforms, an exercise left to the reader.",
      "ja": "実装は、ポータブルであり、多くの異なるプラットフォーム上で動作するはずです。しかし、それは特定のプラットフォーム上での実装を最適化することは困難ではない、運動は読者に任せます。"
    },
    {
      "indent": 0,
      "text": "A.1. iLBC_test.c",
      "ja": "A.1。 iLBC_test.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_test.c",
      "ja": "iLBC_test.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <stdlib.h> #include <stdio.h> #include <string.h> #include \"iLBC_define.h\" #include \"iLBC_encode.h\" #include \"iLBC_decode.h\"",
      "ja": "書式#include <math.h>の書式#include <stdlib.h>に含まする#include <stdio.hに>する#include <string.hの>の#include \"iLBC_define.h\" の#include \"iLBC_encode.h\" の#include \"iLBC_decode.h\""
    },
    {
      "indent": 3,
      "text": "/* Runtime statistics */\n#include <time.h>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define ILBCNOOFWORDS_MAX (NO_OF_BYTES_30MS/2)",
      "ja": "#define ILBCNOOFWORDS_MAX（NO_OF_BYTES_30MS / 2）"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Encoder interface function",
      "raw": true
    },
    {
      "indent": 4,
      "text": "*---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "short encode(   /* (o) Number of bytes encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                                /* (i/o) Encoder instance */\n    short *encoded_data,    /* (o) The encoded bytes */\n    short *data                 /* (i) The signal block to encode*/\n){\n    float block[BLOCKL_MAX];\n    int k;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* convert signal to float */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (k=0; k<iLBCenc_inst->blockl; k++) block[k] = (float)data[k];",
      "ja": "（; K <weBCenter_inst->ブロック、C ++、K = 0）ブロック[K] =（FLOAT）データ[K]のために、"
    },
    {
      "indent": 7,
      "text": "/* do the actual encoding */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC_encode((unsigned char *)encoded_data, block, iLBCenc_inst);",
      "ja": "iLBC_encode（（unsigned char型*）encoded_data、ブロック、iLBCenc_inst）。"
    },
    {
      "indent": 3,
      "text": " return (iLBCenc_inst->no_of_bytes); }",
      "ja": "リターン（iLBCenc_inst-> no_of_bytes）; }"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Decoder interface function\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "short decode(       /* (o) Number of decoded samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    short *decoded_data,        /* (o) Decoded signal block*/\n    short *encoded_data,        /* (i) Encoded bytes */\n    short mode                       /* (i) 0=PL, 1=Normal */\n){\n    int k;\n    float decblock[BLOCKL_MAX], dtmp;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* check if mode is valid */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (mode<0 || mode>1) { printf(\"\\nERROR - Wrong mode - 0, 1 allowed\\n\"); exit(3);}",
      "ja": "IF（モード<0 ||モード> 1）{のprintf（ \"\\のnエラー - 間違ったモード -  0、1つの許可する\\ n\"）;出口（3）;}"
    },
    {
      "indent": 7,
      "text": "/* do actual decoding of block */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC_decode(decblock, (unsigned char *)encoded_data, iLBCdec_inst, mode);",
      "ja": "iLBC_decode（decblock、（unsigned char型*）encoded_data、iLBCdec_inst、モード）。"
    },
    {
      "indent": 7,
      "text": "/* convert to short */ for (k=0; k<iLBCdec_inst->blockl; k++){\n    dtmp=decblock[k];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if (dtmp<MIN_SAMPLE)\n        dtmp=MIN_SAMPLE;\n    else if (dtmp>MAX_SAMPLE)\n        dtmp=MAX_SAMPLE;\n    decoded_data[k] = (short) dtmp;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return (iLBCdec_inst->blockl); }",
      "ja": "リターン（iLBCdec_inst-> blockl）; }"
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  Main program to test iLBC encoding and decoding\n *\n *  Usage:\n *    exefile_name.exe <infile> <bytefile> <outfile> <channel>\n *\n *    <infile>   : Input file, speech for encoder (16-bit pcm file)\n *    <bytefile> : Bit stream output from the encoder\n *    <outfile>  : Output file, decoded speech (16-bit pcm file)\n *    <channel>  : Bit error file, optional (16-bit)\n *                     1 - Packet received correctly\n *                     0 - Packet Lost\n *\n *--------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int main(int argc, char* argv[]) {",
      "ja": "（int型ARGC、チャー*のARGV []）{int型メイン"
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "float starttime;\nfloat runtime;\nfloat outtime;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "FILE *ifileid,*efileid,*ofileid, *cfileid;\nshort data[BLOCKL_MAX];\nshort encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];\nint len;\nshort pli, mode;\nint blockcount = 0;\nint packetlosscount = 0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Create structs */\niLBC_Enc_Inst_t Enc_Inst;\niLBC_Dec_Inst_t Dec_Inst;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* get arguments and open files */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if ((argc!=5) && (argc!=6)) {\n    fprintf(stderr,\n    \"\\n*-----------------------------------------------*\\n\");\n    fprintf(stderr,\n    \"   %s <20,30> input encoded decoded (channel)\\n\\n\",\n        argv[0]);\n    fprintf(stderr,\n    \"   mode    : Frame size for the encoding/decoding\\n\");\n    fprintf(stderr,\n    \"                 20 - 20 ms\\n\");\n    fprintf(stderr,\n    \"                 30 - 30 ms\\n\");\n    fprintf(stderr,\n    \"   input   : Speech for encoder (16-bit pcm file)\\n\");\n    fprintf(stderr,\n    \"   encoded : Encoded bit stream\\n\");\n    fprintf(stderr,\n    \"   decoded : Decoded speech (16-bit pcm file)\\n\");\n    fprintf(stderr,\n    \"   channel : Packet loss pattern, optional (16-bit)\\n\");\n    fprintf(stderr,\n    \"                  1 - Packet received correctly\\n\");\n    fprintf(stderr,\n    \"                  0 - Packet Lost\\n\");\n    fprintf(stderr,\n    \"*-----------------------------------------------*\\n\\n\");\n    exit(1);\n}\nmode=atoi(argv[1]);\nif (mode != 20 && mode != 30) {\n    fprintf(stderr,\"Wrong mode %s, must be 20, or 30\\n\",\n        argv[1]);\n    exit(2);\n}\nif ( (ifileid=fopen(argv[2],\"rb\")) == NULL) {\n    fprintf(stderr,\"Cannot open input file %s\\n\", argv[2]);\n    exit(2);}\nif ( (efileid=fopen(argv[3],\"wb\")) == NULL) {\n    fprintf(stderr, \"Cannot open encoded file %s\\n\",\n        argv[3]); exit(1);}\nif ( (ofileid=fopen(argv[4],\"wb\")) == NULL) {\n    fprintf(stderr, \"Cannot open decoded file %s\\n\",\n        argv[4]); exit(1);}\nif (argc==6) {\n    if( (cfileid=fopen(argv[5],\"rb\")) == NULL) {\n        fprintf(stderr, \"Cannot open channel file %s\\n\",",
      "raw": true
    },
    {
      "indent": 7,
      "text": "            argv[5]);\n        exit(1);\n    }\n} else {\n    cfileid=NULL;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* print info */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "fprintf(stderr, \"\\n\");\nfprintf(stderr,\n    \"*---------------------------------------------------*\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*      iLBC test program                            *\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*---------------------------------------------------*\\n\");\nfprintf(stderr,\"\\nMode           : %2d ms\\n\", mode);\nfprintf(stderr,\"Input file     : %s\\n\", argv[2]);\nfprintf(stderr,\"Encoded file   : %s\\n\", argv[3]);\nfprintf(stderr,\"Output file    : %s\\n\", argv[4]);\nif (argc==6) {\n    fprintf(stderr,\"Channel file   : %s\\n\", argv[5]);\n}\nfprintf(stderr,\"\\n\");",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Initialization */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "initEncode(&Enc_Inst, mode);\ninitDecode(&Dec_Inst, mode, 1);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "starttime=clock()/(float)CLOCKS_PER_SEC;",
      "ja": "STARTTIME =クロック（）/（フロート）CLOCKS_PER_SEC。"
    },
    {
      "indent": 7,
      "text": "/* loop over input blocks */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)== Enc_Inst.blockl) {",
      "ja": "一方、（関数fread（データはsizeof（ショート）、Enc_Inst.blockl、ifileid）== Enc_Inst.blockl）{"
    },
    {
      "indent": 11,
      "text": "blockcount++;",
      "ja": "ブロックカウント++;"
    },
    {
      "indent": 11,
      "text": "/* encoding */ fprintf(stderr, \"--- Encoding block %i --- \",blockcount);\nlen=encode(&Enc_Inst, encoded_data, data);\nfprintf(stderr, \"\\r\");",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* write byte file */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "fwrite(encoded_data, sizeof(unsigned char), len, efileid);",
      "ja": "fwriteの（encoded_data、はsizeof（unsigned char型）、LEN、efileid）。"
    },
    {
      "indent": 11,
      "text": "/* get channel data if provided */\nif (argc==6) {\n    if (fread(&pli, sizeof(short), 1, cfileid)) {\n        if ((pli!=0)&&(pli!=1)) {\n            fprintf(stderr, \"Error in channel file\\n\");\n            exit(0);\n        }\n        if (pli==0) {\n            /* Packet loss -> remove info from frame */\n            memset(encoded_data, 0,\n                sizeof(short)*ILBCNOOFWORDS_MAX);\n            packetlosscount++;\n        }\n    } else {\n        fprintf(stderr, \"Error. Channel file too short\\n\");\n        exit(0);\n    }\n} else {\n    pli=1;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* decoding */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "fprintf(stderr, \"--- Decoding block %i --- \",blockcount);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "len=decode(&Dec_Inst, decoded_data, encoded_data, pli);\nfprintf(stderr, \"\\r\");",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* write output file */",
      "raw": true
    },
    {
      "indent": 7,
      "text": " fwrite(decoded_data,sizeof(short),len,ofileid); }",
      "ja": "fwriteの（decoded_data、はsizeof（ショート）、LEN、ofileid）。 }"
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);\nouttime = (float)((float)blockcount*(float)mode/1000.0);\nprintf(\"\\n\\nLength of speech file: %.1f s\\n\", outtime);\nprintf(\"Packet loss          : %.1f%%\\n\",\n    100.0*(float)packetlosscount/(float)blockcount);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "printf(\"Time to run iLBC     :\");\nprintf(\" %.1f s (%.1f %% of realtime)\\n\\n\", runtime,\n    (100*runtime/outtime));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* close files */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    fclose(ifileid);  fclose(efileid); fclose(ofileid);\n    if (argc==6) {\n        fclose(cfileid);\n    }\n    return(0);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2. iLBC_encode.h",
      "ja": "A.2。 iLBC_encode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_encode.h",
      "ja": "iLBC_encode.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCENCODE_H #define __iLBC_ILBCENCODE_H",
      "ja": "#ifndefの__iLBC_ILBCENCODE_Hの#define __iLBC_ILBCENCODE_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "short initEncode(                   /* (o) Number of bytes\n                                           encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */\n    int mode                    /* (i) frame size mode */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iLBC_encode(",
      "ja": "無効iLBC_encode（"
    },
    {
      "indent": 3,
      "text": "    unsigned char *bytes,           /* (o) encoded data bits iLBC */\n    float *block,                   /* (o) speech vector to\n                                           encode */\n    iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder\n                                           state */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.3. iLBC_encode.c",
      "ja": "A.3。 iLBC_encode.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_encode.c",
      "ja": "iLBC_encode.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <stdlib.h> #include <string.h>",
      "ja": "書式#include <math.h>の書式#include <stdlib.h>に含ま書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"LPCencode.h\" #include \"FrameClassify.h\" #include \"StateSearchW.h\" #include \"StateConstructW.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"iCBSearch.h\" #include \"iCBConstruct.h\" #include \"hpInput.h\" #include \"anaFilter.h\" #include \"syntFilter.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"LPCencode.h\" の#include \"FrameClassify.h\" の#include \"StateSearchW.h\" の#include \"StateConstructW.h\" の#include \"helpfun.h\" の#include \"constants.h\" ＃ \"packing.h\" の#include \"iCBSearch.h\" の#include \"iCBConstruct.h\" の#include \"hpInput.h\" の#include \"anaFilter.h\" の#include \"syntFilter.h\" が含ま"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Initiation of encoder instance.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "short initEncode(                   /* (o) Number of bytes\n                                           encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */\n    int mode                    /* (i) frame size mode */\n){\n    iLBCenc_inst->mode = mode;\n    if (mode==30) {\n        iLBCenc_inst->blockl = BLOCKL_30MS;\n        iLBCenc_inst->nsub = NSUB_30MS;\n        iLBCenc_inst->nasub = NASUB_30MS;\n        iLBCenc_inst->lpc_n = LPC_N_30MS;\n        iLBCenc_inst->no_of_bytes = NO_OF_BYTES_30MS;\n        iLBCenc_inst->no_of_words = NO_OF_WORDS_30MS;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    iLBCenc_inst->state_short_len=STATE_SHORT_LEN_30MS;\n    /* ULP init */\n    iLBCenc_inst->ULP_inst=&ULP_30msTbl;\n}\nelse if (mode==20) {\n    iLBCenc_inst->blockl = BLOCKL_20MS;\n    iLBCenc_inst->nsub = NSUB_20MS;\n    iLBCenc_inst->nasub = NASUB_20MS;\n    iLBCenc_inst->lpc_n = LPC_N_20MS;\n    iLBCenc_inst->no_of_bytes = NO_OF_BYTES_20MS;\n    iLBCenc_inst->no_of_words = NO_OF_WORDS_20MS;\n    iLBCenc_inst->state_short_len=STATE_SHORT_LEN_20MS;\n    /* ULP init */\n    iLBCenc_inst->ULP_inst=&ULP_20msTbl;\n}\nelse {\n    exit(2);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset((*iLBCenc_inst).anaMem, 0,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCenc_inst).lsfold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCenc_inst).lsfdeqold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));\nmemset((*iLBCenc_inst).lpc_buffer, 0,\n    (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));\nmemset((*iLBCenc_inst).hpimem, 0, 4*sizeof(float));",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return (iLBCenc_inst->no_of_bytes); }",
      "ja": "リターン（iLBCenc_inst-> no_of_bytes）; }"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  main encoder function\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iLBC_encode(\n    unsigned char *bytes,           /* (o) encoded data bits iLBC */\n    float *block,                   /* (o) speech vector to\n                                           encode */\n    iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder\n                                           state */\n){",
      "raw": true
    },
    {
      "indent": 7,
      "text": "float data[BLOCKL_MAX];\nfloat residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "int start, idxForMax, idxVec[STATE_LEN];",
      "ja": "int型開始、idxForMax、idxVec [STATE_LEN]。"
    },
    {
      "indent": 7,
      "text": "float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\nint n, k, meml_gotten, Nfor, Nback, i, pos;\nint gain_index[CB_NSTAGES*NASUB_MAX],\n    extra_gain_index[CB_NSTAGES];\nint cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];\nint lsf_i[LSF_NSPLIT*LPC_N_MAX];\nunsigned char *pbytes;\nint diff, start_pos, state_first;\nfloat en1, en2;\nint index, ulp, firstpart;\nint subcount, subframe;\nfloat weightState[LPC_FILTERORDER];\nfloat syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\nfloat weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\nfloat decresidual[BLOCKL_MAX];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* high pass filtering of input signal if such is not done\n       prior to calling this function */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "hpInput(block, iLBCenc_inst->blockl, data, (*iLBCenc_inst).hpimem);",
      "ja": "hpInput（ブロック、iLBCenc_inst-> blockl、データ、（* iLBCenc_inst）.hpimem）。"
    },
    {
      "indent": 7,
      "text": "/* otherwise simply copy */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/*memcpy(data,block,iLBCenc_inst->blockl*sizeof(float));*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* LPC of hp filtered input data */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "LPCencode(syntdenum, weightdenum, lsf_i, data, iLBCenc_inst);",
      "ja": "LPCencode（syntdenum、weightdenum、lsf_i、データ、iLBCenc_inst）。"
    },
    {
      "indent": 7,
      "text": "/* inverse filter to get residual */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (n=0; n<iLBCenc_inst->nsub; n++) { anaFilter(&data[n*SUBL], &syntdenum[n*(LPC_FILTERORDER+1)], SUBL, &residual[n*SUBL], iLBCenc_inst->anaMem); }",
      "ja": "{anaFilter（＆データ[N * SUBL]、＆syntdenum [N×（LPC_FILTERORDER + 1）]、SUBL、＆残留[N * SUBL]、iLBCenc_inst-> anaMem）のための（N ++ N = 0; N <iLBCenc_inst-> NSUB） ; }"
    },
    {
      "indent": 7,
      "text": "/* find state location */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "start = FrameClassify(iLBCenc_inst, residual);",
      "ja": "開始= FrameClassify（残留iLBCenc_inst）。"
    },
    {
      "indent": 7,
      "text": "/* check if state should be in first or last part of the\ntwo subframes */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "diff = STATE_LEN - iLBCenc_inst->state_short_len;\nen1 = 0;\nindex = (start-1)*SUBL;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < iLBCenc_inst->state_short_len; i++) {\n    en1 += residual[index+i]*residual[index+i];\n}\nen2 = 0;\nindex = (start-1)*SUBL+diff;\nfor (i = 0; i < iLBCenc_inst->state_short_len; i++) {\n    en2 += residual[index+i]*residual[index+i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (en1 > en2) {\n    state_first = 1;\n    start_pos = (start-1)*SUBL;\n} else {\n    state_first = 0;\n    start_pos = (start-1)*SUBL + diff;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* scalar quantization of state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "StateSearchW(iLBCenc_inst, &residual[start_pos], &syntdenum[(start-1)*(LPC_FILTERORDER+1)], &weightdenum[(start-1)*(LPC_FILTERORDER+1)], &idxForMax, idxVec, iLBCenc_inst->state_short_len, state_first);",
      "ja": "StateSearchW（iLBCenc_inst、＆残留[start_pos]、＆syntdenumの[（開始-1）*（LPC_FILTERORDER + 1）]、＆weightdenum [（開始-1）*（LPC_FILTERORDER + 1）]、＆idxForMax、idxVec、iLBCenc_inst-> state_short_len、state_first） ;"
    },
    {
      "indent": 7,
      "text": "StateConstructW(idxForMax, idxVec, &syntdenum[(start-1)*(LPC_FILTERORDER+1)], &decresidual[start_pos], iLBCenc_inst->state_short_len);",
      "ja": "StateConstructW（idxForMax、idxVec、＆syntdenum [（開始-1）*（LPC_FILTERORDER + 1）]、＆decresidual [start_pos]、iLBCenc_inst-> state_short_len）。"
    },
    {
      "indent": 7,
      "text": "/* predictive quantization in state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (state_first) { /* put adaptive part in the end */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memset(mem, 0,\n    (CB_MEML-iLBCenc_inst->state_short_len)*sizeof(float));\nmemcpy(mem+CB_MEML-iLBCenc_inst->state_short_len,\n    decresidual+start_pos,\n    iLBCenc_inst->state_short_len*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* encode sub-frames */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, &residual[start_pos+iLBCenc_inst->state_short_len], mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES,",
      "ja": "iCBSearch（iLBCenc_inst、extra_cb_index、extra_gain_index、＆残留[start_pos + iLBCenc_inst-> state_short_len]、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES、"
    },
    {
      "indent": 15,
      "text": "&weightdenum[start*(LPC_FILTERORDER+1)],\nweightState, 0);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBConstruct( &decresidual[start_pos+iLBCenc_inst->state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct（＆decresidual [start_pos + iLBCenc_inst-> state_short_len]、extra_cb_index、extra_gain_index、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES）。"
    },
    {
      "indent": 7,
      "text": "}\nelse { /* put adaptive part in the beginning */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* create reversed vectors for prediction */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) { reverseResidual[k] = residual[(start+1)*SUBL-1 -(k+iLBCenc_inst->state_short_len)]; }",
      "ja": "用（K = 0; K <差分; ++ K）{reverseResidual [k]が残留= [（スタート+ 1）* SUBL-1  - （K + iLBCenc_inst-> state_short_len）]。 }"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "meml_gotten = iLBCenc_inst->state_short_len;\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[start_pos + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* encode sub-frames */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES, &weightdenum[(start-1)*(LPC_FILTERORDER+1)], weightState, 0);",
      "ja": "iCBSearch（iLBCenc_inst、extra_cb_index、extra_gain_index、reverseResidual、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES、＆weightdenum [（開始-1）*（LPC_FILTERORDER + 1）]、weightState、0）;"
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct（reverseDecresidual、extra_cb_index、extra_gain_index、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES）。"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) { decresidual[start_pos-1-k] = reverseDecresidual[k];",
      "ja": "用（K = 0; K <差分K ++）{decresidual [start_pos-1-K] = reverseDecresidual [K]。"
    },
    {
      "indent": 7,
      "text": " } }",
      "ja": "｝ ｝"
    },
    {
      "indent": 7,
      "text": "/* counter for predicted sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "subcount=0;",
      "ja": "サブのカウント= 0;"
    },
    {
      "indent": 7,
      "text": "/* forward prediction of sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Nfor = iLBCenc_inst->nsub-start-1;",
      "ja": "Nforの= iLBCenc_inst-> NSUBスタート-1。"
    },
    {
      "indent": 7,
      "text": "if ( Nfor > 0 ) {",
      "ja": "{（> 0）であれば"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));\nmemcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,\n    STATE_LEN*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nfor; subframe++) {",
      "ja": "{（;サブ<ためのサブフレームサブフレーム= 0）のための"
    },
    {
      "indent": 15,
      "text": "/* encode sub-frame */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES, gain_index+subcount*CB_NSTAGES, &residual[(start+1+subframe)*SUBL], mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount], SUBL, CB_NSTAGES, &weightdenum[(start+1+subframe)* (LPC_FILTERORDER+1)], weightState, subcount+1);",
      "ja": "iCBSearch（iLBCenc_inst、cb_index +サブカウント* CB_NSTAGES、gain_index +サブカウント* CB_NSTAGES、＆残留[（* SUBL）+ 1つの+サブフレームスタート]、MEM + CB_MEML-memLfTbl [サブカウント]、memLfTbl [サブカウント]、SUBL、CB_NSTAGES、＆weightdenum [（起動+ 1 +サブフレーム）*（LPC_FILTERORDER + 1）]、weightState、サブカウント+ 1）。"
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&decresidual[(start+1+subframe)*SUBL], cb_index+subcount*CB_NSTAGES, gain_index+subcount*CB_NSTAGES, mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "ja": "iCBConstruct（＆decresidual [（+ 1つの+サブフレーム開始）* SUBL]、cb_index +サブカウント* CB_NSTAGES、gain_index +サブカウント* CB_NSTAGES、MEM + CB_MEML-memLfTbl [サブカウント]、memLfTbl [サブカウント]、SUBL、CB_NSTAGES）。"
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,",
      "ja": "memcpy（MEM、MEM + SUBL、（CB_MEML-SUBL）*はsizeof（フロート））。 memcpy（MEM + CB_MEML-SUBL、"
    },
    {
      "indent": 15,
      "text": "    &decresidual[(start+1+subframe)*SUBL],\n    SUBL*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": " subcount++; } }",
      "ja": "サブカウント++; }}"
    },
    {
      "indent": 7,
      "text": "/* backward prediction of sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Nback = start-1;",
      "ja": "バック=開始-1;"
    },
    {
      "indent": 7,
      "text": "if ( Nback > 0 ) {",
      "ja": "IF（Nバック課題> 0）{"
    },
    {
      "indent": 11,
      "text": "/* create reverse order vectors */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (n=0; n<Nback; n++) {\n    for (k=0; k<SUBL; k++) {\n        reverseResidual[n*SUBL+k] =\n            residual[(start-1)*SUBL-1-n*SUBL-k];\n        reverseDecresidual[n*SUBL+k] =\n            decresidual[(start-1)*SUBL-1-n*SUBL-k];\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "meml_gotten = SUBL*(iLBCenc_inst->nsub+1-start);",
      "ja": "meml_gotten = SUBL *（iLBCenc_inst-> NSUB + 1スタート）。"
    },
    {
      "indent": 11,
      "text": "if ( meml_gotten > CB_MEML ) {\n    meml_gotten=CB_MEML;\n}\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nback; subframe++) {",
      "ja": "ため（サブフレーム0、サブフレーム<ブラック、サブフレーム）{"
    },
    {
      "indent": 15,
      "text": "/* encode sub-frame */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,",
      "ja": "iCBSearch（iLBCenc_inst、cb_index +サブカウント* CB_NSTAGES、"
    },
    {
      "indent": 19,
      "text": "gain_index+subcount*CB_NSTAGES,\n&reverseResidual[subframe*SUBL],\nmem+CB_MEML-memLfTbl[subcount],\nmemLfTbl[subcount], SUBL, CB_NSTAGES,\n&weightdenum[(start-2-subframe)*\n            (LPC_FILTERORDER+1)],\nweightState, subcount+1);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&reverseDecresidual[subframe*SUBL], cb_index+subcount*CB_NSTAGES, gain_index+subcount*CB_NSTAGES, mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "ja": "iCBConstruct（＆reverseDecresidual [サブ* SUBL]、cb_index +サブカウント* CB_NSTAGES、gain_index +サブカウント* CB_NSTAGES、MEM + CB_MEML-memLfTbl [サブカウント]、memLfTbl [サブカウント]、SUBL、CB_NSTAGES）。"
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\nmemcpy(mem+CB_MEML-SUBL,\n    &reverseDecresidual[subframe*SUBL],\n    SUBL*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 15,
      "text": "subcount++;",
      "ja": "サブカウント++;"
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    for (i=0; i<SUBL*Nback; i++) {\n        decresidual[SUBL*Nback - i - 1] =\n            reverseDecresidual[i];\n    }\n}\n/* end encoding part */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* adjust index */\nindex_conv_enc(cb_index);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* pack bytes */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pbytes=bytes;\npos=0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* loop over the 3 ULP classes */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (ulp=0; ulp<3; ulp++) {",
      "ja": "用（DIP = 0;ディップ<3; ULP ++）{"
    },
    {
      "indent": 11,
      "text": "/* LSF */\nfor (k=0; k<LSF_NSPLIT*iLBCenc_inst->lpc_n; k++) {\n    packsplit(&lsf_i[k], &firstpart, &lsf_i[k],\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp],\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp]+\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp], &pos);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Start block info */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "packsplit(&start, &firstpart, &start,\n    iLBCenc_inst->ULP_inst->start_bits[ulp],\n    iLBCenc_inst->ULP_inst->start_bits[ulp]+\n    iLBCenc_inst->ULP_inst->start_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->start_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->start_bits[ulp], &pos);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "packsplit(&state_first, &firstpart, &state_first,\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp],\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp]+\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp], &pos);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "packsplit(&idxForMax, &firstpart, &idxForMax,\n    iLBCenc_inst->ULP_inst->scale_bits[ulp],\n    iLBCenc_inst->ULP_inst->scale_bits[ulp]+\n    iLBCenc_inst->ULP_inst->scale_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->scale_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->scale_bits[ulp], &pos);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0; k<iLBCenc_inst->state_short_len; k++) {\n    packsplit(idxVec+k, &firstpart, idxVec+k,\n        iLBCenc_inst->ULP_inst->state_bits[ulp],\n        iLBCenc_inst->ULP_inst->state_bits[ulp]+\n        iLBCenc_inst->ULP_inst->state_bits[ulp+1]+\n        iLBCenc_inst->ULP_inst->state_bits[ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->state_bits[ulp], &pos);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* 23/22 (20ms/30ms) sample block */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0;k<CB_NSTAGES;k++) {\n    packsplit(extra_cb_index+k, &firstpart,\n        extra_cb_index+k,\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp]+\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n        &pos);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0;k<CB_NSTAGES;k++) {\n    packsplit(extra_gain_index+k, &firstpart,\n        extra_gain_index+k,\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp]+\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n        &pos);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* The two/four (20ms/30ms) 40 sample sub-blocks */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (i=0; i<iLBCenc_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        packsplit(cb_index+i*CB_NSTAGES+k, &firstpart,\n            cb_index+i*CB_NSTAGES+k,\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp]+\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+1]+\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+2]);\n        dopack( &pbytes, firstpart,\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n            &pos);\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    for (i=0; i<iLBCenc_inst->nasub; i++) {\n        for (k=0; k<CB_NSTAGES; k++) {\n            packsplit(gain_index+i*CB_NSTAGES+k, &firstpart,\n                gain_index+i*CB_NSTAGES+k,\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp]+ iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+1]+\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+2]);\n            dopack( &pbytes, firstpart,\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n                &pos);\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    /* set the last bit to zero (otherwise the decoder\n       will treat it as a lost frame) */\n    dopack( &pbytes, 0, 1, &pos);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4. iLBC_decode.h",
      "ja": "A.4。 iLBC_decode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_decode.h",
      "ja": "iLBC_decode.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCDECODE_H #define __iLBC_ILBCDECODE_H",
      "ja": "#ifndefの__iLBC_ILBCDECODE_Hの#define __iLBC_ILBCDECODE_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "short initDecode(                   /* (o) Number of decoded\n                                           samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    int mode,                       /* (i) frame size mode */\n    int use_enhancer                /* (i) 1 to use enhancer\n                                           0 to run without\n                                             enhancer */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iLBC_decode(\n    float *decblock,            /* (o) decoded signal block */\n    unsigned char *bytes,           /* (i) encoded signal bits */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    int mode                    /* (i) 0: bad packet, PLC,\n                                           1: normal */",
      "raw": true
    },
    {
      "indent": 3,
      "text": ");",
      "ja": "）；"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.5. iLBC_decode.c",
      "ja": "A.5。 iLBC_decode.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_decode.c",
      "ja": "iLBC_decode.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <stdlib.h>",
      "ja": "書式#include <math.h>の書式#include <stdlib.h>に含ま"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"StateConstructW.h\" #include \"LPCdecode.h\" #include \"iCBConstruct.h\" #include \"doCPLC.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"string.h\" #include \"enhancer.h\" #include \"hpOutput.h\" #include \"syntFilter.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"StateConstructW.h\" の#include \"LPCdecode.h\" の#include \"iCBConstruct.h\" の#include \"doCPLC.h\" の#include \"helpfun.h\" の#include \"constants.h\" ＃ \"packing.h\" の#include \"string.hの\" の#include \"enhancer.h\" の#include \"hpOutput.h\" の#include \"syntFilter.h\" が含ま"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Initiation of decoder instance.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "short initDecode(                   /* (o) Number of decoded\n                                           samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    int mode,                       /* (i) frame size mode */\n    int use_enhancer                /* (i) 1 to use enhancer\n                                           0 to run without\n                                             enhancer */\n){\n    int i;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->mode = mode;",
      "ja": "iLBCdec_inst->モード=モード。"
    },
    {
      "indent": 7,
      "text": "if (mode==30) {\n    iLBCdec_inst->blockl = BLOCKL_30MS;\n    iLBCdec_inst->nsub = NSUB_30MS;\n    iLBCdec_inst->nasub = NASUB_30MS;\n    iLBCdec_inst->lpc_n = LPC_N_30MS;\n    iLBCdec_inst->no_of_bytes = NO_OF_BYTES_30MS;\n    iLBCdec_inst->no_of_words = NO_OF_WORDS_30MS;\n    iLBCdec_inst->state_short_len=STATE_SHORT_LEN_30MS;\n    /* ULP init */\n    iLBCdec_inst->ULP_inst=&ULP_30msTbl;\n}\nelse if (mode==20) {\n    iLBCdec_inst->blockl = BLOCKL_20MS;\n    iLBCdec_inst->nsub = NSUB_20MS;\n    iLBCdec_inst->nasub = NASUB_20MS;\n    iLBCdec_inst->lpc_n = LPC_N_20MS;\n    iLBCdec_inst->no_of_bytes = NO_OF_BYTES_20MS;\n    iLBCdec_inst->no_of_words = NO_OF_WORDS_20MS;\n    iLBCdec_inst->state_short_len=STATE_SHORT_LEN_20MS;\n    /* ULP init */\n    iLBCdec_inst->ULP_inst=&ULP_20msTbl;\n}\nelse {\n    exit(2);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->syntMem, 0,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCdec_inst).lsfdeqold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->old_syntdenum, 0,\n    ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));\nfor (i=0; i<NSUB_MAX; i++)\n    iLBCdec_inst->old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->last_lag = 20;",
      "ja": "iLBCdec_inst-> last_lag = 20。"
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prevLag = 120;\niLBCdec_inst->per = 0.0;\niLBCdec_inst->consPLICount = 0;\niLBCdec_inst->prevPLI = 0;\niLBCdec_inst->prevLpc[0] = 1.0;\nmemset(iLBCdec_inst->prevLpc+1,0,\n    LPC_FILTERORDER*sizeof(float));\nmemset(iLBCdec_inst->prevResidual, 0, BLOCKL_MAX*sizeof(float));\niLBCdec_inst->seed=777;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->hpomem, 0, 4*sizeof(float));",
      "ja": "memsetの（iLBCdec_inst-> hpomem、0、4 *のはsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->use_enhancer = use_enhancer;\nmemset(iLBCdec_inst->enh_buf, 0, ENH_BUFL*sizeof(float));\nfor (i=0;i<ENH_NBLOCKS_TOT;i++)\n    iLBCdec_inst->enh_period[i]=(float)40.0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prev_enh_pl = 0;",
      "ja": "iLBCdec_inst-> prev_enh_pl = 0;"
    },
    {
      "indent": 3,
      "text": " return (iLBCdec_inst->blockl); }",
      "ja": "リターン（iLBCdec_inst-> blockl）; }"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  frame residual decoder function (subrutine to iLBC_decode)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void Decode(\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    float *decresidual,             /* (o) decoded residual frame */\n    int start,                      /* (i) location of start\n                                           state */\n    int idxForMax,                  /* (i) codebook index for the\n                                           maximum value */\n    int *idxVec,                /* (i) codebook indexes for the\n                                           samples  in the start\n                                           state */\n    float *syntdenum,               /* (i) the decoded synthesis\n                                           filter coefficients */\n    int *cb_index,                  /* (i) the indexes for the\n                                           adaptive codebook */\n    int *gain_index,            /* (i) the indexes for the\n                                           corresponding gains */\n    int *extra_cb_index,        /* (i) the indexes for the\n                                           adaptive codebook part\n                                           of start state */\n    int *extra_gain_index,          /* (i) the indexes for the\n                                           corresponding gains */\n    int state_first                 /* (i) 1 if non adaptive part\n                                           of start state comes\n                                           first 0 if that part\n                                           comes last */\n){\n    float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\n    int k, meml_gotten, Nfor, Nback, i;\n    int diff, start_pos;\n    int subcount, subframe;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "diff = STATE_LEN - iLBCdec_inst->state_short_len;",
      "ja": "差分= STATE_LEN  -  iLBCdec_inst-> state_short_len。"
    },
    {
      "indent": 7,
      "text": "if (state_first == 1) {\n    start_pos = (start-1)*SUBL;\n} else {\n    start_pos = (start-1)*SUBL + diff;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* decode scalar part of start state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "StateConstructW(idxForMax, idxVec, &syntdenum[(start-1)*(LPC_FILTERORDER+1)], &decresidual[start_pos], iLBCdec_inst->state_short_len);",
      "ja": "StateConstructW（idxForMax、idxVec、＆syntdenum [（開始-1）*（LPC_FILTERORDER + 1）]、＆decresidual [start_pos]、iLBCdec_inst-> state_short_len）。"
    },
    {
      "indent": 7,
      "text": "if (state_first) { /* put adaptive part in the end */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memset(mem, 0,\n    (CB_MEML-iLBCdec_inst->state_short_len)*sizeof(float));\nmemcpy(mem+CB_MEML-iLBCdec_inst->state_short_len,\n    decresidual+start_pos,\n    iLBCdec_inst->state_short_len*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBConstruct( &decresidual[start_pos+iLBCdec_inst->state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct（＆decresidual [start_pos + iLBCdec_inst-> state_short_len]、extra_cb_index、extra_gain_index、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES）。"
    },
    {
      "indent": 7,
      "text": "}\nelse {/* put adaptive part in the beginning */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* create reversed vectors for prediction */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) { reverseDecresidual[k] = decresidual[(start+1)*SUBL-1- (k+iLBCdec_inst->state_short_len)]; }",
      "ja": "用（K = 0; K <差分; ++ K）{reverseDecresidual [K] = decresidual [（スタート+ 1）* SUBL -1-（K + iLBCdec_inst-> state_short_len）]。 }"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "meml_gotten = iLBCdec_inst->state_short_len;\nfor (k=0; k<meml_gotten; k++){\n    mem[CB_MEML-1-k] = decresidual[start_pos + k];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "} memset(mem, 0, (CB_MEML-k)*sizeof(float));",
      "ja": "}のmemset（MEM、0、（CB_MEML-K）*はsizeof（フロート））。"
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct（reverseDecresidual、extra_cb_index、extra_gain_index、MEM + CB_MEML-stMemLTbl、stMemLTbl、差分、CB_NSTAGES）。"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true
    },
    {
      "indent": 7,
      "text": " for (k=0; k<diff; k++) { decresidual[start_pos-1-k] = reverseDecresidual[k]; } }",
      "ja": "用（K = 0; K <差分K ++）{decresidual [start_pos-1-K] = reverseDecresidual [K]。 }}"
    },
    {
      "indent": 7,
      "text": "/* counter for predicted sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "subcount=0;",
      "ja": "サブのカウント= 0;"
    },
    {
      "indent": 7,
      "text": "/* forward prediction of sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Nfor = iLBCdec_inst->nsub-start-1;",
      "ja": "Nforの= iLBCdec_inst-> NSUBスタート-1。"
    },
    {
      "indent": 7,
      "text": "if ( Nfor > 0 ){",
      "ja": "{（> 0）であれば"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));\nmemcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,\n    STATE_LEN*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nfor; subframe++) {",
      "ja": "{（;サブ<ためのサブフレームサブフレーム= 0）のための"
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&decresidual[(start+1+subframe)*SUBL], cb_index+subcount*CB_NSTAGES, gain_index+subcount*CB_NSTAGES, mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "ja": "iCBConstruct（＆decresidual [（+ 1つの+サブフレーム開始）* SUBL]、cb_index +サブカウント* CB_NSTAGES、gain_index +サブカウント* CB_NSTAGES、MEM + CB_MEML-memLfTbl [サブカウント]、memLfTbl [サブカウント]、SUBL、CB_NSTAGES）。"
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,",
      "ja": "memcpy（MEM、MEM + SUBL、（CB_MEML-SUBL）*はsizeof（フロート））。 memcpy（MEM + CB_MEML-SUBL、"
    },
    {
      "indent": 19,
      "text": "&decresidual[(start+1+subframe)*SUBL],\nSUBL*sizeof(float));",
      "raw": true
    },
    {
      "indent": 15,
      "text": "subcount++;",
      "ja": "サブカウント++;"
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* backward prediction of sub-frames */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Nback = start-1;",
      "ja": "バック=開始-1;"
    },
    {
      "indent": 7,
      "text": "if ( Nback > 0 ) {",
      "ja": "IF（Nバック課題> 0）{"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "meml_gotten = SUBL*(iLBCdec_inst->nsub+1-start);",
      "ja": "meml_gotten = SUBL *（iLBCdec_inst-> NSUB + 1スタート）。"
    },
    {
      "indent": 11,
      "text": "if ( meml_gotten > CB_MEML ) {\n    meml_gotten=CB_MEML;\n}\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over subframes to decode */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nback; subframe++) {",
      "ja": "ため（サブフレーム0、サブフレーム<ブラック、サブフレーム）{"
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&reverseDecresidual[subframe*SUBL], cb_index+subcount*CB_NSTAGES, gain_index+subcount*CB_NSTAGES, mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "ja": "iCBConstruct（＆reverseDecresidual [サブ* SUBL]、cb_index +サブカウント* CB_NSTAGES、gain_index +サブカウント* CB_NSTAGES、MEM + CB_MEML-memLfTbl [サブカウント]、memLfTbl [サブカウント]、SUBL、CB_NSTAGES）。"
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\nmemcpy(mem+CB_MEML-SUBL,\n    &reverseDecresidual[subframe*SUBL],\n    SUBL*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": " subcount++; }",
      "ja": "サブカウント++; }"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " for (i=0; i<SUBL*Nback; i++) decresidual[SUBL*Nback - i - 1] = reverseDecresidual[i]; } }",
      "ja": "[I] = reverseDecresidual decresidual [1  -   -  I SUBL * Nバック課題];（私は++; iはSUBL * Nバック課題を<I = 0）のための}}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  main decoder function\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iLBC_decode(\n    float *decblock,            /* (o) decoded signal block */\n    unsigned char *bytes,           /* (i) encoded signal bits */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    int mode                    /* (i) 0: bad packet, PLC,\n                                           1: normal */\n){\n    float data[BLOCKL_MAX];\n    float lsfdeq[LPC_FILTERORDER*LPC_N_MAX];\n    float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER + 1];\n    float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];\n    int k, i, start, idxForMax, pos, lastpart, ulp;\n    int lag, ilag;\n    float cc, maxcc;\n    int idxVec[STATE_LEN];\n    int check;\n    int gain_index[NASUB_MAX*CB_NSTAGES],\n        extra_gain_index[CB_NSTAGES];\n    int cb_index[CB_NSTAGES*NASUB_MAX], extra_cb_index[CB_NSTAGES];\n    int lsf_i[LSF_NSPLIT*LPC_N_MAX];\n    int state_first;\n    int last_bit;\n    unsigned char *pbytes;\n    float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];\n    int order_plus_one;\n    float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\n    float decresidual[BLOCKL_MAX];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (mode>0) { /* the data are good */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* decode data */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "pbytes=bytes;\npos=0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Set everything to zero before decoding */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (k=0; k<LSF_NSPLIT*LPC_N_MAX; k++) {\n    lsf_i[k]=0;\n}\nstart=0;\nstate_first=0;\nidxForMax=0;\nfor (k=0; k<iLBCdec_inst->state_short_len; k++) {\n    idxVec[k]=0;\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    extra_cb_index[k]=0;\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    extra_gain_index[k]=0;\n}\nfor (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        cb_index[i*CB_NSTAGES+k]=0;\n    }\n}\nfor (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        gain_index[i*CB_NSTAGES+k]=0;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over ULP classes */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (ulp=0; ulp<3; ulp++) {",
      "ja": "用（DIP = 0;ディップ<3; ULP ++）{"
    },
    {
      "indent": 15,
      "text": "/* LSF */\nfor (k=0; k<LSF_NSPLIT*iLBCdec_inst->lpc_n; k++){\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->lsf_bits[k][ulp], &pos);\n    packcombine(&lsf_i[k], lastpart,\n        iLBCdec_inst->ULP_inst->lsf_bits[k][ulp]);\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* Start block info */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,\n    iLBCdec_inst->ULP_inst->start_bits[ulp], &pos);\npackcombine(&start, lastpart,\n    iLBCdec_inst->ULP_inst->start_bits[ulp]);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,",
      "ja": "lastpart（＆pbytes、＆解凍し、"
    },
    {
      "indent": 15,
      "text": "    iLBCdec_inst->ULP_inst->startfirst_bits[ulp], &pos);\npackcombine(&state_first, lastpart,\n    iLBCdec_inst->ULP_inst->startfirst_bits[ulp]);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,\n    iLBCdec_inst->ULP_inst->scale_bits[ulp], &pos);\npackcombine(&idxForMax, lastpart,\n    iLBCdec_inst->ULP_inst->scale_bits[ulp]);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "for (k=0; k<iLBCdec_inst->state_short_len; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->state_bits[ulp], &pos);\n    packcombine(idxVec+k, lastpart,\n        iLBCdec_inst->ULP_inst->state_bits[ulp]);\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* 23/22 (20ms/30ms) sample block */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "for (k=0; k<CB_NSTAGES; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp],\n        &pos);\n    packcombine(extra_cb_index+k, lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp]);\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp],\n        &pos);\n    packcombine(extra_gain_index+k, lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp]);\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* The two/four (20ms/30ms) 40 sample sub-blocks */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "for (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->cb_index[i][k][ulp],\n            &pos);\n        packcombine(cb_index+i*CB_NSTAGES+k, lastpart,\n        iLBCdec_inst->ULP_inst->cb_index[i][k][ulp]);\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    for (i=0; i<iLBCdec_inst->nasub; i++) {\n        for (k=0; k<CB_NSTAGES; k++) {\n            unpack( &pbytes, &lastpart, iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp],\n                &pos);\n            packcombine(gain_index+i*CB_NSTAGES+k, lastpart,\n                iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp]);\n        }\n    }\n}\n/* Extract last bit. If it is 1 this indicates an\n   empty/lost frame */\nunpack( &pbytes, &last_bit, 1, &pos);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Check for bit errors or empty/lost frames */\nif (start<1)\n    mode = 0;\nif (iLBCdec_inst->mode==20 && start>3)\n    mode = 0;\nif (iLBCdec_inst->mode==30 && start>5)\n    mode = 0;\nif (last_bit==1)\n    mode = 0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (mode==1) { /* No bit errors was detected,\n                  continue decoding */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* adjust index */\nindex_conv_dec(cb_index);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* decode the lsf */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "SimplelsfDEQ(lsfdeq, lsf_i, iLBCdec_inst->lpc_n);\ncheck=LSF_check(lsfdeq, LPC_FILTERORDER,\n    iLBCdec_inst->lpc_n);\nDecoderInterpolateLSF(syntdenum, weightdenum,\n    lsfdeq, LPC_FILTERORDER, iLBCdec_inst);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Decode(iLBCdec_inst, decresidual, start, idxForMax, idxVec, syntdenum, cb_index, gain_index, extra_cb_index, extra_gain_index, state_first);",
      "ja": "デコード（iLBCdec_inst、decresidual、開始、idxForMax、idxVec、syntdenum、cb_index、gain_index、extra_cb_index、extra_gain_index、state_first）。"
    },
    {
      "indent": 15,
      "text": "/* preparing the plc for a future loss! */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "doThePLC(PLCresidual, PLClpc, 0, decresidual, syntdenum + (LPC_FILTERORDER + 1)*(iLBCdec_inst->nsub - 1), (*iLBCdec_inst).last_lag, iLBCdec_inst);",
      "ja": "doThePLC（PLCresidual、PLClpc、0、decresidual、syntdenum +（LPC_FILTERORDER + 1）*（iLBCdec_inst-> NSUB  -  1）、（* iLBCdec_inst）.last_lag、iLBCdec_inst）。"
    },
    {
      "indent": 11,
      "text": " memcpy(decresidual, PLCresidual, iLBCdec_inst->blockl*sizeof(float)); }",
      "ja": "memcpyを（decresidual、PLCresidual、iLBCdec_inst-> blocklの*のはsizeof（フロート））; }"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "if (mode == 0) {\n    /* the data is bad (either a PLC call\n     * was made or a severe bit error was detected)\n     */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* packet loss conceal */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memset(zeros, 0, BLOCKL_MAX*sizeof(float));",
      "ja": "memsetの（ゼロ、0、BLOCKL_MAX *はsizeof（フロート））。"
    },
    {
      "indent": 11,
      "text": "one[0] = 1;\nmemset(one+1, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true
    },
    {
      "indent": 11,
      "text": "start=0;",
      "ja": "= 0を起動します。"
    },
    {
      "indent": 11,
      "text": "doThePLC(PLCresidual, PLClpc, 1, zeros, one,\n    (*iLBCdec_inst).last_lag, iLBCdec_inst);\nmemcpy(decresidual, PLCresidual,\n    iLBCdec_inst->blockl*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    order_plus_one = LPC_FILTERORDER + 1;\n    for (i = 0; i < iLBCdec_inst->nsub; i++) {\n        memcpy(syntdenum+(i*order_plus_one), PLClpc,\n            order_plus_one*sizeof(float));\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->use_enhancer == 1) {",
      "ja": "IF（iLBCdec_inst-> use_enhancer == 1）{"
    },
    {
      "indent": 11,
      "text": "/* post filtering */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->last_lag = enhancerInterface(data, decresidual, iLBCdec_inst);",
      "ja": "iLBCdec_inst-> last_lag = enhancerInterface（データ、decresidual、iLBCdec_inst）。"
    },
    {
      "indent": 11,
      "text": "/* synthesis filtering */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (iLBCdec_inst->mode==20) {\n    /* Enhancer has 40 samples delay */\n    i=0;\n    syntFilter(data + i*SUBL,\n        iLBCdec_inst->old_syntdenum +\n        (i+iLBCdec_inst->nsub-1)*(LPC_FILTERORDER+1),\n        SUBL, iLBCdec_inst->syntMem);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    for (i=1; i < iLBCdec_inst->nsub; i++) {\n        syntFilter(data + i*SUBL,\n            syntdenum + (i-1)*(LPC_FILTERORDER+1),\n            SUBL, iLBCdec_inst->syntMem);\n    }\n} else if (iLBCdec_inst->mode==30) {\n    /* Enhancer has 80 samples delay */\n    for (i=0; i < 2; i++) {\n        syntFilter(data + i*SUBL,\n            iLBCdec_inst->old_syntdenum +\n            (i+iLBCdec_inst->nsub-2)*(LPC_FILTERORDER+1),\n            SUBL, iLBCdec_inst->syntMem);\n    }\n    for (i=2; i < iLBCdec_inst->nsub; i++) {\n        syntFilter(data + i*SUBL,\n            syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,\n            iLBCdec_inst->syntMem);\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "} else {",
      "ja": "}他{"
    },
    {
      "indent": 11,
      "text": "/* Find last lag */\nlag = 20;\nmaxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],\n    &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (ilag=21; ilag<120; ilag++) { cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL], &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag], ENH_BLOCKL);",
      "ja": "（層= 21;レイヤー<120;層++）用{CC = xCorrCoef（＆decresidual [BLOCKL_MAX-ENH_BLOCKL]＆decresidual [BLOCKL_MAX-ENH_BLOCKL-層] ENH_BLOCKL）。"
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}\niLBCdec_inst->last_lag = lag;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* copy data and run synthesis filter */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memcpy(data, decresidual,\n    iLBCdec_inst->blockl*sizeof(float));\nfor (i=0; i < iLBCdec_inst->nsub; i++) {\n    syntFilter(data + i*SUBL,\n        syntdenum + i*(LPC_FILTERORDER+1), SUBL,\n        iLBCdec_inst->syntMem);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* high pass filtering on output if desired, otherwise\n   copy to out */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "hpOutput(data, iLBCdec_inst->blockl, decblock,iLBCdec_inst->hpomem);",
      "ja": "hpOutput（データ、iLBCdec_inst-> blockl、decblock、iLBCdec_inst-> hpomem）。"
    },
    {
      "indent": 7,
      "text": "/* memcpy(decblock,data,iLBCdec_inst->blockl*sizeof(float));*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memcpy(iLBCdec_inst->old_syntdenum, syntdenum,",
      "ja": "memcpy（iLBCdec_inst-> old_syntdenum、syntdenum、"
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->nsub*(LPC_FILTERORDER+1)*sizeof(float));",
      "ja": "iLBCdec_inst-> NSUB *（LPC_FILTERORDER + 1）*はsizeof（フロート））;"
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prev_enh_pl=0;",
      "ja": "iLBCdec_inst-> prev_enh_pl = 0;"
    },
    {
      "indent": 3,
      "text": "    if (mode==0) { /* PLC was used */\n        iLBCdec_inst->prev_enh_pl=1;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.6. iLBC_define.h",
      "ja": "A.6。 iLBC_define.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iLBC_define.h",
      "ja": "iLBC_define.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/ #include <string.h>",
      "ja": "************************************************** **************** /書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCDEFINE_H #define __iLBC_ILBCDEFINE_H",
      "ja": "#ifndefの__iLBC_ILBCDEFINE_Hの#define __iLBC_ILBCDEFINE_H"
    },
    {
      "indent": 3,
      "text": "/* general codec settings */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define FS (float)8000.0 #define BLOCKL_20MS 160 #define BLOCKL_30MS 240 #define BLOCKL_MAX 240 #define NSUB_20MS 4 #define NSUB_30MS 6 #define NSUB_MAX 6 #define NASUB_20MS 2",
      "ja": "#define FS（フロート）8000.0の#define BLOCKL_20MS 160の#define BLOCKL_30MS 240の#define BLOCKL_MAX 240の#define NSUB_20MS 4の#define NSUB_30MS 6の#define NSUB_MAX 6の#define NASUB_20MS 2"
    },
    {
      "indent": 3,
      "text": "#define NASUB_30MS 4 #define NASUB_MAX 4 #define SUBL 40 #define STATE_LEN 80 #define STATE_SHORT_LEN_30MS 58 #define STATE_SHORT_LEN_20MS 57",
      "ja": "#define NASUB_30MS 4の#define NASUB_MAX 4の#define SUBL 40の#define STATE_LEN 80の#define STATE_SHORT_LEN_30MS 58の#define STATE_SHORT_LEN_20MS 57"
    },
    {
      "indent": 3,
      "text": "/* LPC settings */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define LPC_FILTERORDER 10 #define LPC_CHIRP_SYNTDENUM (float)0.9025 #define LPC_CHIRP_WEIGHTDENUM (float)0.4222 #define LPC_LOOKBACK 60 #define LPC_N_20MS 1 #define LPC_N_30MS 2 #define LPC_N_MAX 2 #define LPC_ASYMDIFF 20 #define LPC_BW (float)60.0 #define LPC_WN (float)1.0001 #define LSF_NSPLIT 3 #define LSF_NUMBER_OF_STEPS 4 #define LPC_HALFORDER (LPC_FILTERORDER/2)",
      "ja": "#define LPC_FILTERORDER 10の#define LPC_CHIRP_SYNTDENUM（フロート）（フロート）0.4222の#define LPC_LOOKBACK 60の#define LPC_N_20MS 1の#define LPC_N_30MS 2の#define LPC_N_MAX 2の#define LPC_ASYMDIFF 20の#define LPC_BW（フロート）60.0の#define LPC_WN 0.9025の#define LPC_CHIRP_WEIGHTDENUM（フロート#define LSF_NSPLIT 3の#define LSF_NUMBER_OF_STEPS 4の#define LPC_HALFORDER（LPC_FILTERORDER / 2）1.0001）"
    },
    {
      "indent": 3,
      "text": "/* cb settings */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define CB_NSTAGES 3 #define CB_EXPAND 2 #define CB_MEML 147 #define CB_FILTERLEN 2*4 #define CB_HALFFILTERLEN 4 #define CB_RESRANGE 34 #define CB_MAXGAIN (float)1.3",
      "ja": "#define CB_NSTAGES 3の#define CB_EXPAND 2の#define CB_MEML 147の#define CB_FILTERLEN 2 * 4の#define CB_HALFFILTERLEN 4の#define CB_RESRANGE 34の#define CB_MAXGAIN（フロート）1.3"
    },
    {
      "indent": 3,
      "text": "/* enhancer */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define ENH_BLOCKL              80  /* block length */\n#define ENH_BLOCKL_HALF         (ENH_BLOCKL/2)\n#define ENH_HL                  3   /* 2*ENH_HL+1 is number blocks\n                                       in said second sequence */\n#define ENH_SLOP            2   /* max difference estimated and\n                                       correct pitch period */\n#define ENH_PLOCSL              20  /* pitch-estimates and pitch-\n                                       locations buffer length */\n#define ENH_OVERHANG        2\n#define ENH_UPS0            4   /* upsampling rate */\n#define ENH_FL0                 3   /* 2*FLO+1 is the length of\n                                       each filter */\n#define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define ENH_CORRDIM             (2*ENH_SLOP+1)\n#define ENH_NBLOCKS             (BLOCKL_MAX/ENH_BLOCKL)\n#define ENH_NBLOCKS_EXTRA       5\n#define ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +\n                                       ENH_NBLOCKS_EXTRA */\n#define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL\n#define ENH_ALPHA0              (float)0.05",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Down sampling */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define FILTERORDER_DS 7 #define DELAY_DS 3 #define FACTOR_DS 2",
      "ja": "#define FILTERORDER_DS 7の#define DELAY_DS 3の#define FACTOR_DS 2"
    },
    {
      "indent": 3,
      "text": "/* bit stream defs */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define NO_OF_BYTES_20MS 38 #define NO_OF_BYTES_30MS 50 #define NO_OF_WORDS_20MS 19 #define NO_OF_WORDS_30MS 25 #define STATE_BITS 3 #define BYTE_LEN 8 #define ULP_CLASSES 3",
      "ja": "#define NO_OF_BYTES_20MS 38の#define NO_OF_BYTES_30MS 50の#define NO_OF_WORDS_20MS 19の#define NO_OF_WORDS_30MS 25の#define STATE_BITS 3の#define BYTE_LEN 8の#define ULP_CLASSES 3"
    },
    {
      "indent": 3,
      "text": "/* help parameters */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define FLOAT_MAX (float)1.0e37 #define EPS (float)2.220446049250313e-016 #define PI (float)3.14159265358979323846 #define MIN_SAMPLE -32768 #define MAX_SAMPLE 32767 #define TWO_PI (float)6.283185307 #define PI2 (float)0.159154943",
      "ja": "#define FLOAT_MAX（フロート）1.0e37の#define EPS（フロート）2.220446049250313e-016の#define PI（フロート）3.14159265358979323846の#define MIN_SAMPLE -32768の#define MAX_SAMPLE 32767の#define TWO_PI（フロート）6.283185307の#define PI2（フロート）0.159154943"
    },
    {
      "indent": 3,
      "text": "/* type definition encoder instance */\ntypedef struct iLBC_ULP_Inst_t_ {\n    int lsf_bits[6][ULP_CLASSES+2];\n    int start_bits[ULP_CLASSES+2];\n    int startfirst_bits[ULP_CLASSES+2];\n    int scale_bits[ULP_CLASSES+2];\n    int state_bits[ULP_CLASSES+2];\n    int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];\n    int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];\n    int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n    int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n} iLBC_ULP_Inst_t;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* type definition encoder instance */ typedef struct iLBC_Enc_Inst_t_ {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* flag for frame size mode */\nint mode;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* basic parameters for different frame sizes */\nint blockl;\nint nsub;\nint nasub;\nint no_of_bytes, no_of_words;\nint lpc_n;\nint state_short_len;\nconst iLBC_ULP_Inst_t *ULP_inst;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* analysis filter state */\nfloat anaMem[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* old lsf parameters for interpolation */\nfloat lsfold[LPC_FILTERORDER];\nfloat lsfdeqold[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* signal buffer for LP analysis */\nfloat lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* state of input HP filter */\nfloat hpimem[4];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "} iLBC_Enc_Inst_t;",
      "ja": "} iLBC_Enc_Inst_t。"
    },
    {
      "indent": 3,
      "text": "/* type definition decoder instance */\ntypedef struct iLBC_Dec_Inst_t_ {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* flag for frame size mode */\nint mode;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* basic parameters for different frame sizes */\nint blockl;\nint nsub;\nint nasub;\nint no_of_bytes, no_of_words;\nint lpc_n;\nint state_short_len;\nconst iLBC_ULP_Inst_t *ULP_inst;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* synthesis filter state */\nfloat syntMem[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* old LSF for interpolation */ float lsfdeqold[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* pitch lag estimated in enhancer and used in PLC */\nint last_lag;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* PLC state information */\nint prevLag, consPLICount, prevPLI, prev_enh_pl;\nfloat prevLpc[LPC_FILTERORDER+1];\nfloat prevResidual[NSUB_MAX*SUBL];\nfloat per;\nunsigned long seed;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* previous synthesis filter parameters */\nfloat old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* state of output HP filter */\nfloat hpomem[4];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* enhancer state information */\nint use_enhancer;\nfloat enh_buf[ENH_BUFL];\nfloat enh_period[ENH_NBLOCKS_TOT];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "} iLBC_Dec_Inst_t;",
      "ja": "} iLBC_Dec_Inst_t。"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.7. constants.h",
      "ja": "A.7。 constants.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "constants.h",
      "ja": "constants.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_CONSTANTS_H #define __iLBC_CONSTANTS_H",
      "ja": "#ifndefの__iLBC_CONSTANTS_Hの#define __iLBC_CONSTANTS_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/* ULP bit allocation */ extern const iLBC_ULP_Inst_t ULP_20msTbl;\nextern const iLBC_ULP_Inst_t ULP_30msTbl;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* high pass filters */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern float hpi_zero_coefsTbl[];\nextern float hpi_pole_coefsTbl[];\nextern float hpo_zero_coefsTbl[];\nextern float hpo_pole_coefsTbl[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* low pass filters */\nextern float lpFilt_coefsTbl[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* LPC analysis and quantization */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern float lpc_winTbl[];\nextern float lpc_asymwinTbl[];\nextern float lpc_lagwinTbl[];\nextern float lsfCbTbl[];\nextern float lsfmeanTbl[];\nextern int   dim_lsfCbTbl[];\nextern int   size_lsfCbTbl[];\nextern float lsf_weightTbl_30ms[];\nextern float lsf_weightTbl_20ms[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* state quantization tables */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern float state_sq3Tbl[];\nextern float state_frgqTbl[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* gain quantization tables */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern float gain_sq3Tbl[];\nextern float gain_sq4Tbl[];\nextern float gain_sq5Tbl[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* adaptive codebook definitions */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern int search_rangeTbl[5][CB_NSTAGES];\nextern int memLfTbl[];\nextern int stMemLTbl;\nextern float cbfiltersTbl[CB_FILTERLEN];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* enhancer definitions */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extern float polyphaserTbl[];\nextern float enh_plocsTbl[];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.8. constants.c",
      "ja": "A.8。 constants.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "constants.c",
      "ja": "constants.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/* ULP bit allocation */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* 20 ms frame */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const iLBC_ULP_Inst_t ULP_20msTbl = {\n    /* LSF */\n    {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},\n        {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n    /* Start state location, gain and samples */\n    {2,0,0,0,0},\n    {1,0,0,0,0},\n    {6,0,0,0,0},\n    {0,1,2,0,0},\n    /* extra CB index and extra CB gain */\n    {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n    {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n    /* CB index and CB gain */\n    {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n        {{0,0,8,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},\n    {   {{1,2,2,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n        {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}}\n};",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* 30 ms frame */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const iLBC_ULP_Inst_t ULP_30msTbl = {\n    /* LSF */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},\n        {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},\n    /* Start state location, gain and samples */\n    {3,0,0,0,0},\n    {1,0,0,0,0},\n    {6,0,0,0,0},\n    {0,1,2,0,0},\n    /* extra CB index and extra CB gain */\n    {{4,2,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n    {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n    /* CB index and CB gain */\n    {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},\n    {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},\n        {{0,2,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},\n        {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},\n        {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* HP Filters */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float hpi_zero_coefsTbl[3] = {\n    (float)0.92727436, (float)-1.8544941, (float)0.92727436\n};\nfloat hpi_pole_coefsTbl[3] = {\n    (float)1.0, (float)-1.9059465, (float)0.9114024\n};\nfloat hpo_zero_coefsTbl[3] = {\n    (float)0.93980581, (float)-1.8795834, (float)0.93980581\n};\nfloat hpo_pole_coefsTbl[3] = {\n    (float)1.0, (float)-1.9330735, (float)0.93589199\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* LP Filter */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float lpFilt_coefsTbl[FILTERORDER_DS]={ (float)-0.066650, (float)0.125000, (float)0.316650, (float)0.414063, (float)0.316650, (float)0.125000, (float)-0.066650 };",
      "ja": "フロートlpFilt_coefsTbl [FILTERORDER_DS] = {（フロート）-0.066650、（フロート）0.125000（フロート）0.316650（フロート）0.414063（フロート）0.316650（フロート）0.125000（フロート）-0.066650}。"
    },
    {
      "indent": 3,
      "text": "/* State quantization tables */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float state_sq3Tbl[8] = { (float)-3.719849, (float)-2.177490, (float)-1.130005, (float)-0.309692, (float)0.444214, (float)1.329712, (float)2.436279, (float)3.983887 };",
      "ja": "フロートstate_sq3Tbl [8] = {（フロート）-3.719849、（フロート）-2.177490、（フロート）-1.130005、（フロート）-0.309692、（フロート）0.444214（フロート）1.329712（フロート）2.436279（フロート）3.983887 }。"
    },
    {
      "indent": 3,
      "text": "float state_frgqTbl[64] = { (float)1.000085, (float)1.071695, (float)1.140395, (float)1.206868, (float)1.277188, (float)1.351503, (float)1.429380, (float)1.500727, (float)1.569049, (float)1.639599, (float)1.707071, (float)1.781531, (float)1.840799, (float)1.901550, (float)1.956695, (float)2.006750, (float)2.055474, (float)2.102787, (float)2.142819, (float)2.183592, (float)2.217962, (float)2.257177, (float)2.295739, (float)2.332967, (float)2.369248, (float)2.402792, (float)2.435080, (float)2.468598, (float)2.503394, (float)2.539284, (float)2.572944, (float)2.605036, (float)2.636331, (float)2.668939, (float)2.698780, (float)2.729101, (float)2.759786, (float)2.789834, (float)2.818679, (float)2.848074, (float)2.877470, (float)2.906899, (float)2.936655, (float)2.967804, (float)3.000115, (float)3.033367, (float)3.066355, (float)3.104231, (float)3.141499, (float)3.183012, (float)3.222952, (float)3.265433, (float)3.308441, (float)3.350823, (float)3.395275, (float)3.442793, (float)3.490801, (float)3.542514, (float)3.604064, (float)3.666050, (float)3.740994, (float)3.830749, (float)3.938770, (float)4.101764 };",
      "ja": "フロートstate_frgqTbl [64] = {（フロート）1.000085（フロート）1.071695（フロート）1.140395（フロート）1.206868（フロート）1.277188（フロート）1.351503（フロート）1.429380（フロート）1.500727（フロート） 1.569049、（フロート）1.639599（フロート）1.707071（フロート）1.781531（フロート）1.840799（フロート）1.901550（フロート）1.956695（フロート）2.006750（フロート）2.055474（フロート）2.102787（フロート） 2.142819、（フロート）2.183592（フロート）2.217962（フロート）2.257177（フロート）2.295739（フロート）2.332967（フロート）2.369248（フロート）2.402792（フロート）2.435080（フロート）2.468598（フロート） 2.503394、（フロート）2.539284（フロート）2.572944（フロート）2.605036（フロート）2.636331（フロート）2.668939（フロート）2.698780（フロート）2.729101（フロート）2.759786（フロート）2.789834（フロート） 2.818679、（フロート）2.848074（フロート）2.877470（フロート）2.906899（フロート）2.936655（フロート）2.967804（フロート）3.000115（フロート）3.033367（フロート）3.066355（フロート）3.104231（フロート） 3.141499、（フロート）3.183012（フロート）3.222952（フロート）3.265433（フロート）3.308441（フロート）3.350823（フロート）3.395275（フロート）3.442793（フロート）3.490801（FLオート麦）3.542514（フロート）3.604064（フロート）3.666050（フロート）3.740994（フロート）3.830749（フロート）3.938770（フロート）4.101764}。"
    },
    {
      "indent": 3,
      "text": "/* CB tables */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int search_rangeTbl[5][CB_NSTAGES]={{58,58,58}, {108,44,44},\n            {108,108,108}, {108,108,108}, {108,108,108}};\nint stMemLTbl=85;\nint memLfTbl[NASUB_MAX]={147,147,147,147};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* expansion filter(s) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float cbfiltersTbl[CB_FILTERLEN]={ (float)-0.034180, (float)0.108887, (float)-0.184326, (float)0.806152, (float)0.713379, (float)-0.144043, (float)0.083740, (float)-0.033691 };",
      "ja": "フロートcbfiltersTbl [CB_FILTERLEN] = {（フロート）-0.034180、（フロート）0.108887（フロート）-0.184326、（フロート）0.806152（フロート）0.713379（フロート）-0.144043、（フロート）0.083740（フロート）-0.033691 }。"
    },
    {
      "indent": 3,
      "text": "/* Gain Quantization */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float gain_sq3Tbl[8]={ (float)-1.000000, (float)-0.659973, (float)-0.330017, (float)0.000000, (float)0.250000, (float)0.500000, (float)0.750000, (float)1.00000};",
      "ja": "フロートgain_sq3Tbl [8] = {（フロート）-1.000000、（フロート）-0.659973、（フロート）-0.330017、（フロート）0.000000（フロート）0.250000（フロート）0.500000（フロート）0.750000（フロート）1.00000} ;"
    },
    {
      "indent": 3,
      "text": "float gain_sq4Tbl[16]={ (float)-1.049988, (float)-0.900024, (float)-0.750000, (float)-0.599976, (float)-0.450012, (float)-0.299988, (float)-0.150024, (float)0.000000, (float)0.150024, (float)0.299988, (float)0.450012, (float)0.599976, (float)0.750000, (float)0.900024, (float)1.049988, (float)1.200012};",
      "ja": "フロートgain_sq4Tbl [16] = {（フロート）-1.049988、（フロート）-0.900024、（フロート）-0.750000、（フロート）-0.599976、（フロート）-0.450012、（フロート）-0.299988、（フロート）-0.150024、（フロート）0.000000（フロート）0.150024（フロート）0.299988（フロート）0.450012（フロート）0.599976（フロート）0.750000（フロート）0.900024（フロート）1.049988（フロート）1.200012}。"
    },
    {
      "indent": 3,
      "text": "float gain_sq5Tbl[32]={ (float)0.037476, (float)0.075012, (float)0.112488, (float)0.150024, (float)0.187500, (float)0.224976, (float)0.262512, (float)0.299988, (float)0.337524, (float)0.375000, (float)0.412476, (float)0.450012, (float)0.487488, (float)0.525024, (float)0.562500, (float)0.599976, (float)0.637512, (float)0.674988, (float)0.712524, (float)0.750000, (float)0.787476, (float)0.825012, (float)0.862488, (float)0.900024, (float)0.937500, (float)0.974976, (float)1.012512, (float)1.049988, (float)1.087524, (float)1.125000, (float)1.162476, (float)1.200012};",
      "ja": "フロートgain_sq5Tbl [32] = {（フロート）0.037476（フロート）0.075012（フロート）0.112488（フロート）0.150024（フロート）0.187500（フロート）0.224976（フロート）0.262512（フロート）0.299988（フロート） 0.337524、（フロート）0.375000（フロート）0.412476（フロート）0.450012（フロート）0.487488（フロート）0.525024（フロート）0.562500（フロート）0.599976（フロート）0.637512（フロート）0.674988（フロート） 0.712524、（フロート）0.750000（フロート）0.787476（フロート）0.825012（フロート）0.862488（フロート）0.900024（フロート）0.937500（フロート）0.974976（フロート）1.012512（フロート）1.049988（フロート） 1.087524、（フロート）1.125000（フロート）1.162476（フロート）1.200012}。"
    },
    {
      "indent": 3,
      "text": "/* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */\nfloat polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={\n    (float)0.000000, (float)0.000000, (float)0.000000,\n(float)1.000000,\n        (float)0.000000, (float)0.000000, (float)0.000000,\n    (float)0.015625, (float)-0.076904, (float)0.288330,\n(float)0.862061,\n        (float)-0.106445, (float)0.018799, (float)-0.015625,\n    (float)0.023682, (float)-0.124268, (float)0.601563,\n(float)0.601563,\n        (float)-0.124268, (float)0.023682, (float)-0.023682,\n    (float)0.018799, (float)-0.106445, (float)0.862061,\n(float)0.288330,\n        (float)-0.076904, (float)0.015625, (float)-0.018799};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float enh_plocsTbl[ENH_NBLOCKS_TOT] = {(float)40.0, (float)120.0, (float)200.0, (float)280.0, (float)360.0, (float)440.0, (float)520.0, (float)600.0};",
      "ja": "フロートenh_plocsTbl [ENH_NBLOCKS_TOT] = {（フロート）40.0、（フロート）120.0、（フロート）200.0、（フロート）280.0、（フロート）360.0、（フロート）440.0、（フロート）520.0、（フロート）600.0}。"
    },
    {
      "indent": 3,
      "text": "/* LPC analysis and quantization */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};\nint size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float lsfmeanTbl[LPC_FILTERORDER] = { (float)0.281738, (float)0.445801, (float)0.663330, (float)0.962524, (float)1.251831, (float)1.533081, (float)1.850586, (float)2.137817, (float)2.481445, (float)2.777344};",
      "ja": "フロートlsfmeanTbl [LPC_FILTERORDER] = {（フロート）0.281738（フロート）0.445801（フロート）0.663330（フロート）0.962524（フロート）1.251831（フロート）1.533081（フロート）1.850586（フロート）2.137817（フロート） 2.481445、（フロート）2.777344}。"
    },
    {
      "indent": 3,
      "text": "float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0), (float)1.0, (float)(2.0/3.0), (float)(1.0/3.0), (float)0.0, (float)0.0};",
      "ja": "フロートlsf_weightTbl_30ms [6] = {（フロート）（1.0 / 2.0）、（フロート）1.0、（フロート）（2.0 / 3.0）、（フロート）（1.0 / 3.0）、（フロート）0.0、（フロート）0.0}。"
    },
    {
      "indent": 3,
      "text": "float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0), (float)(1.0/4.0), (float)(0.0)};",
      "ja": "フロートlsf_weightTbl_20ms [4] = {（フロート）（3.0 / 4.0）、（フロート）（2.0 / 4.0）、（フロート）（1.0 / 4.0）、（フロート）（0.0）}。"
    },
    {
      "indent": 3,
      "text": "/* Hanning LPC window */\nfloat lpc_winTbl[BLOCKL_MAX]={\n    (float)0.000183, (float)0.000671, (float)0.001526,\n    (float)0.002716, (float)0.004242, (float)0.006104,\n    (float)0.008301, (float)0.010834, (float)0.013702,\n    (float)0.016907, (float)0.020416, (float)0.024261,\n    (float)0.028442, (float)0.032928, (float)0.037750,\n    (float)0.042877, (float)0.048309, (float)0.054047,\n    (float)0.060089, (float)0.066437, (float)0.073090,\n    (float)0.080017, (float)0.087219, (float)0.094727,\n    (float)0.102509, (float)0.110535, (float)0.118835,\n    (float)0.127411, (float)0.136230, (float)0.145294,\n    (float)0.154602, (float)0.164154, (float)0.173920,\n    (float)0.183899, (float)0.194122, (float)0.204529,\n    (float)0.215149, (float)0.225952, (float)0.236938,\n    (float)0.248108, (float)0.259460, (float)0.270966,\n    (float)0.282654, (float)0.294464, (float)0.306396,\n    (float)0.318481, (float)0.330688, (float)0.343018,\n    (float)0.355438, (float)0.367981, (float)0.380585,\n    (float)0.393280, (float)0.406067, (float)0.418884,\n    (float)0.431763, (float)0.444702, (float)0.457672,\n    (float)0.470673, (float)0.483704, (float)0.496735,\n    (float)0.509766, (float)0.522797, (float)0.535828,\n    (float)0.548798, (float)0.561768, (float)0.574677,\n    (float)0.587524, (float)0.600342, (float)0.613068,\n    (float)0.625732, (float)0.638306, (float)0.650787,\n    (float)0.663147, (float)0.675415, (float)0.687561,\n    (float)0.699585, (float)0.711487, (float)0.723206,\n    (float)0.734802, (float)0.746216, (float)0.757477,\n    (float)0.768585, (float)0.779480, (float)0.790192,\n    (float)0.800720, (float)0.811005, (float)0.821106,\n    (float)0.830994, (float)0.840668, (float)0.850067,\n    (float)0.859253, (float)0.868225, (float)0.876892,\n    (float)0.885345, (float)0.893524, (float)0.901428,\n    (float)0.909058, (float)0.916412, (float)0.923492, (float)0.930267, (float)0.936768, (float)0.942963,\n    (float)0.948853, (float)0.954437, (float)0.959717,\n    (float)0.964691, (float)0.969360, (float)0.973694,\n    (float)0.977692, (float)0.981384, (float)0.984741,\n    (float)0.987762, (float)0.990479, (float)0.992828,\n    (float)0.994873, (float)0.996552, (float)0.997925,\n    (float)0.998932, (float)0.999603, (float)0.999969,\n    (float)0.999969, (float)0.999603, (float)0.998932,\n    (float)0.997925, (float)0.996552, (float)0.994873,\n    (float)0.992828, (float)0.990479, (float)0.987762,\n    (float)0.984741, (float)0.981384, (float)0.977692,\n    (float)0.973694, (float)0.969360, (float)0.964691,\n    (float)0.959717, (float)0.954437, (float)0.948853,\n    (float)0.942963, (float)0.936768, (float)0.930267,\n    (float)0.923492, (float)0.916412, (float)0.909058,\n    (float)0.901428, (float)0.893524, (float)0.885345,\n    (float)0.876892, (float)0.868225, (float)0.859253,\n    (float)0.850067, (float)0.840668, (float)0.830994,\n    (float)0.821106, (float)0.811005, (float)0.800720,\n    (float)0.790192, (float)0.779480, (float)0.768585,\n    (float)0.757477, (float)0.746216, (float)0.734802,\n    (float)0.723206, (float)0.711487, (float)0.699585,\n    (float)0.687561, (float)0.675415, (float)0.663147,\n    (float)0.650787, (float)0.638306, (float)0.625732,\n    (float)0.613068, (float)0.600342, (float)0.587524,\n    (float)0.574677, (float)0.561768, (float)0.548798,\n    (float)0.535828, (float)0.522797, (float)0.509766,\n    (float)0.496735, (float)0.483704, (float)0.470673,\n    (float)0.457672, (float)0.444702, (float)0.431763,\n    (float)0.418884, (float)0.406067, (float)0.393280,\n    (float)0.380585, (float)0.367981, (float)0.355438,\n    (float)0.343018, (float)0.330688, (float)0.318481,\n    (float)0.306396, (float)0.294464, (float)0.282654,\n    (float)0.270966, (float)0.259460, (float)0.248108,\n    (float)0.236938, (float)0.225952, (float)0.215149,\n    (float)0.204529, (float)0.194122, (float)0.183899,\n    (float)0.173920, (float)0.164154, (float)0.154602,\n    (float)0.145294, (float)0.136230, (float)0.127411,\n    (float)0.118835, (float)0.110535, (float)0.102509,\n    (float)0.094727, (float)0.087219, (float)0.080017,\n    (float)0.073090, (float)0.066437, (float)0.060089,\n    (float)0.054047, (float)0.048309, (float)0.042877,\n    (float)0.037750, (float)0.032928, (float)0.028442,\n    (float)0.024261, (float)0.020416, (float)0.016907,\n    (float)0.013702, (float)0.010834, (float)0.008301,\n    (float)0.006104, (float)0.004242, (float)0.002716,\n    (float)0.001526, (float)0.000671, (float)0.000183\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Asymmetric LPC window */\nfloat lpc_asymwinTbl[BLOCKL_MAX]={\n    (float)0.000061, (float)0.000214, (float)0.000458,\n    (float)0.000824, (float)0.001282, (float)0.001831,\n    (float)0.002472, (float)0.003235, (float)0.004120,\n    (float)0.005066, (float)0.006134, (float)0.007294,\n    (float)0.008545, (float)0.009918, (float)0.011383,\n    (float)0.012939, (float)0.014587, (float)0.016357,\n    (float)0.018219, (float)0.020172, (float)0.022217,\n    (float)0.024353, (float)0.026611, (float)0.028961,\n    (float)0.031372, (float)0.033905, (float)0.036530,\n    (float)0.039276, (float)0.042084, (float)0.044983,\n    (float)0.047974, (float)0.051086, (float)0.054260,\n    (float)0.057526, (float)0.060883, (float)0.064331,\n    (float)0.067871, (float)0.071503, (float)0.075226,\n    (float)0.079010, (float)0.082916, (float)0.086884,\n    (float)0.090942, (float)0.095062, (float)0.099304,\n    (float)0.103607, (float)0.107971, (float)0.112427,\n    (float)0.116974, (float)0.121582, (float)0.126282,\n    (float)0.131073, (float)0.135895, (float)0.140839,\n    (float)0.145813, (float)0.150879, (float)0.156006,\n    (float)0.161224, (float)0.166504, (float)0.171844,\n    (float)0.177246, (float)0.182709, (float)0.188263,\n    (float)0.193848, (float)0.199524, (float)0.205231,\n    (float)0.211029, (float)0.216858, (float)0.222778,\n    (float)0.228729, (float)0.234741, (float)0.240814,\n    (float)0.246918, (float)0.253082, (float)0.259308,\n    (float)0.265564, (float)0.271881, (float)0.278259,\n    (float)0.284668, (float)0.291107, (float)0.297607,\n    (float)0.304138, (float)0.310730, (float)0.317322,\n    (float)0.323975, (float)0.330658, (float)0.337372,\n    (float)0.344147, (float)0.350922, (float)0.357727,\n    (float)0.364594, (float)0.371460, (float)0.378357,\n    (float)0.385284, (float)0.392212, (float)0.399170,\n    (float)0.406158, (float)0.413177, (float)0.420197,\n    (float)0.427246, (float)0.434296, (float)0.441376,\n    (float)0.448456, (float)0.455536, (float)0.462646,\n    (float)0.469757, (float)0.476868, (float)0.483978,\n    (float)0.491089, (float)0.498230, (float)0.505341,\n    (float)0.512451, (float)0.519592, (float)0.526703,\n    (float)0.533813, (float)0.540924, (float)0.548004,\n    (float)0.555084, (float)0.562164, (float)0.569244,\n    (float)0.576294, (float)0.583313, (float)0.590332,\n    (float)0.597321, (float)0.604309, (float)0.611267,\n    (float)0.618195, (float)0.625092, (float)0.631989,\n    (float)0.638855, (float)0.645660, (float)0.652466,\n    (float)0.659241, (float)0.665985, (float)0.672668,\n    (float)0.679352, (float)0.685974, (float)0.692566, (float)0.699127, (float)0.705658, (float)0.712128,\n    (float)0.718536, (float)0.724945, (float)0.731262,\n    (float)0.737549, (float)0.743805, (float)0.750000,\n    (float)0.756134, (float)0.762238, (float)0.768280,\n    (float)0.774261, (float)0.780182, (float)0.786072,\n    (float)0.791870, (float)0.797638, (float)0.803314,\n    (float)0.808960, (float)0.814514, (float)0.820038,\n    (float)0.825470, (float)0.830841, (float)0.836151,\n    (float)0.841400, (float)0.846558, (float)0.851654,\n    (float)0.856689, (float)0.861633, (float)0.866516,\n    (float)0.871338, (float)0.876068, (float)0.880737,\n    (float)0.885315, (float)0.889801, (float)0.894226,\n    (float)0.898560, (float)0.902832, (float)0.907013,\n    (float)0.911102, (float)0.915100, (float)0.919037,\n    (float)0.922882, (float)0.926636, (float)0.930328,\n    (float)0.933899, (float)0.937408, (float)0.940796,\n    (float)0.944122, (float)0.947357, (float)0.950470,\n    (float)0.953522, (float)0.956482, (float)0.959351,\n    (float)0.962097, (float)0.964783, (float)0.967377,\n    (float)0.969849, (float)0.972229, (float)0.974518,\n    (float)0.976715, (float)0.978821, (float)0.980835,\n    (float)0.982727, (float)0.984528, (float)0.986237,\n    (float)0.987854, (float)0.989380, (float)0.990784,\n    (float)0.992096, (float)0.993317, (float)0.994415,\n    (float)0.995422, (float)0.996338, (float)0.997162,\n    (float)0.997864, (float)0.998474, (float)0.998962,\n    (float)0.999390, (float)0.999695, (float)0.999878,\n    (float)0.999969, (float)0.999969, (float)0.996918,\n    (float)0.987701, (float)0.972382, (float)0.951050,\n    (float)0.923889, (float)0.891022, (float)0.852631,\n    (float)0.809021, (float)0.760406, (float)0.707092,\n    (float)0.649445, (float)0.587799, (float)0.522491,\n    (float)0.453979, (float)0.382690, (float)0.309021,\n    (float)0.233459, (float)0.156433, (float)0.078461\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Lag window for LPC */\nfloat lpc_lagwinTbl[LPC_FILTERORDER + 1]={\n    (float)1.000100, (float)0.998890, (float)0.995569,\n        (float)0.990057, (float)0.982392,\n    (float)0.972623, (float)0.960816, (float)0.947047,\n        (float)0.931405, (float)0.913989, (float)0.894909};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* LSF quantization*/\nfloat lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {\n(float)0.155396, (float)0.273193, (float)0.451172,\n(float)0.390503, (float)0.648071, (float)1.002075,\n(float)0.440186, (float)0.692261, (float)0.955688, (float)0.343628, (float)0.642334, (float)1.071533,\n(float)0.318359, (float)0.491577, (float)0.670532,\n(float)0.193115, (float)0.375488, (float)0.725708,\n(float)0.364136, (float)0.510376, (float)0.658691,\n(float)0.297485, (float)0.527588, (float)0.842529,\n(float)0.227173, (float)0.365967, (float)0.563110,\n(float)0.244995, (float)0.396729, (float)0.636475,\n(float)0.169434, (float)0.300171, (float)0.520264,\n(float)0.312866, (float)0.464478, (float)0.643188,\n(float)0.248535, (float)0.429932, (float)0.626099,\n(float)0.236206, (float)0.491333, (float)0.817139,\n(float)0.334961, (float)0.625122, (float)0.895752,\n(float)0.343018, (float)0.518555, (float)0.698608,\n(float)0.372803, (float)0.659790, (float)0.945435,\n(float)0.176880, (float)0.316528, (float)0.581421,\n(float)0.416382, (float)0.625977, (float)0.805176,\n(float)0.303223, (float)0.568726, (float)0.915039,\n(float)0.203613, (float)0.351440, (float)0.588135,\n(float)0.221191, (float)0.375000, (float)0.614746,\n(float)0.199951, (float)0.323364, (float)0.476074,\n(float)0.300781, (float)0.433350, (float)0.566895,\n(float)0.226196, (float)0.354004, (float)0.507568,\n(float)0.300049, (float)0.508179, (float)0.711670,\n(float)0.312012, (float)0.492676, (float)0.763428,\n(float)0.329956, (float)0.541016, (float)0.795776,\n(float)0.373779, (float)0.604614, (float)0.928833,\n(float)0.210571, (float)0.452026, (float)0.755249,\n(float)0.271118, (float)0.473267, (float)0.662476,\n(float)0.285522, (float)0.436890, (float)0.634399,\n(float)0.246704, (float)0.565552, (float)0.859009,\n(float)0.270508, (float)0.406250, (float)0.553589,\n(float)0.361450, (float)0.578491, (float)0.813843,\n(float)0.342651, (float)0.482788, (float)0.622437,\n(float)0.340332, (float)0.549438, (float)0.743164,\n(float)0.200439, (float)0.336304, (float)0.540894,\n(float)0.407837, (float)0.644775, (float)0.895142,\n(float)0.294678, (float)0.454834, (float)0.699097,\n(float)0.193115, (float)0.344482, (float)0.643188,\n(float)0.275757, (float)0.420776, (float)0.598755,\n(float)0.380493, (float)0.608643, (float)0.861084,\n(float)0.222778, (float)0.426147, (float)0.676514,\n(float)0.407471, (float)0.700195, (float)1.053101,\n(float)0.218384, (float)0.377197, (float)0.669922,\n(float)0.313232, (float)0.454102, (float)0.600952,\n(float)0.347412, (float)0.571533, (float)0.874146,\n(float)0.238037, (float)0.405396, (float)0.729492,\n(float)0.223877, (float)0.412964, (float)0.822021,\n(float)0.395264, (float)0.582153, (float)0.743896, (float)0.247925, (float)0.485596, (float)0.720581,\n(float)0.229126, (float)0.496582, (float)0.907715,\n(float)0.260132, (float)0.566895, (float)1.012695,\n(float)0.337402, (float)0.611572, (float)0.978149,\n(float)0.267822, (float)0.447632, (float)0.769287,\n(float)0.250610, (float)0.381714, (float)0.530029,\n(float)0.430054, (float)0.805054, (float)1.221924,\n(float)0.382568, (float)0.544067, (float)0.701660,\n(float)0.383545, (float)0.710327, (float)1.149170,\n(float)0.271362, (float)0.529053, (float)0.775513,\n(float)0.246826, (float)0.393555, (float)0.588623,\n(float)0.266846, (float)0.422119, (float)0.676758,\n(float)0.311523, (float)0.580688, (float)0.838623,\n(float)1.331177, (float)1.576782, (float)1.779541,\n(float)1.160034, (float)1.401978, (float)1.768188,\n(float)1.161865, (float)1.525146, (float)1.715332,\n(float)0.759521, (float)0.913940, (float)1.119873,\n(float)0.947144, (float)1.121338, (float)1.282471,\n(float)1.015015, (float)1.557007, (float)1.804932,\n(float)1.172974, (float)1.402100, (float)1.692627,\n(float)1.087524, (float)1.474243, (float)1.665405,\n(float)0.899536, (float)1.105225, (float)1.406250,\n(float)1.148438, (float)1.484741, (float)1.796265,\n(float)0.785645, (float)1.209839, (float)1.567749,\n(float)0.867798, (float)1.166504, (float)1.450684,\n(float)0.922485, (float)1.229858, (float)1.420898,\n(float)0.791260, (float)1.123291, (float)1.409546,\n(float)0.788940, (float)0.966064, (float)1.340332,\n(float)1.051147, (float)1.272827, (float)1.556641,\n(float)0.866821, (float)1.181152, (float)1.538818,\n(float)0.906738, (float)1.373535, (float)1.607910,\n(float)1.244751, (float)1.581421, (float)1.933838,\n(float)0.913940, (float)1.337280, (float)1.539673,\n(float)0.680542, (float)0.959229, (float)1.662720,\n(float)0.887207, (float)1.430542, (float)1.800781,\n(float)0.912598, (float)1.433594, (float)1.683960,\n(float)0.860474, (float)1.060303, (float)1.455322,\n(float)1.005127, (float)1.381104, (float)1.706909,\n(float)0.800781, (float)1.363892, (float)1.829102,\n(float)0.781860, (float)1.124390, (float)1.505981,\n(float)1.003662, (float)1.471436, (float)1.684692,\n(float)0.981323, (float)1.309570, (float)1.618042,\n(float)1.228760, (float)1.554321, (float)1.756470,\n(float)0.734375, (float)0.895752, (float)1.225586,\n(float)0.841797, (float)1.055664, (float)1.249268,\n(float)0.920166, (float)1.119385, (float)1.486206,\n(float)0.894409, (float)1.539063, (float)1.828979,\n(float)1.283691, (float)1.543335, (float)1.858276, (float)0.676025, (float)0.933105, (float)1.490845,\n(float)0.821289, (float)1.491821, (float)1.739868,\n(float)0.923218, (float)1.144653, (float)1.580566,\n(float)1.057251, (float)1.345581, (float)1.635864,\n(float)0.888672, (float)1.074951, (float)1.353149,\n(float)0.942749, (float)1.195435, (float)1.505493,\n(float)1.492310, (float)1.788086, (float)2.039673,\n(float)1.070313, (float)1.634399, (float)1.860962,\n(float)1.253296, (float)1.488892, (float)1.686035,\n(float)0.647095, (float)0.864014, (float)1.401855,\n(float)0.866699, (float)1.254883, (float)1.453369,\n(float)1.063965, (float)1.532593, (float)1.731323,\n(float)1.167847, (float)1.521484, (float)1.884033,\n(float)0.956055, (float)1.502075, (float)1.745605,\n(float)0.928711, (float)1.288574, (float)1.479614,\n(float)1.088013, (float)1.380737, (float)1.570801,\n(float)0.905029, (float)1.186768, (float)1.371948,\n(float)1.057861, (float)1.421021, (float)1.617432,\n(float)1.108276, (float)1.312500, (float)1.501465,\n(float)0.979492, (float)1.416992, (float)1.624268,\n(float)1.276001, (float)1.661011, (float)2.007935,\n(float)0.993042, (float)1.168579, (float)1.331665,\n(float)0.778198, (float)0.944946, (float)1.235962,\n(float)1.223755, (float)1.491333, (float)1.815674,\n(float)0.852661, (float)1.350464, (float)1.722290,\n(float)1.134766, (float)1.593140, (float)1.787354,\n(float)1.051392, (float)1.339722, (float)1.531006,\n(float)0.803589, (float)1.271240, (float)1.652100,\n(float)0.755737, (float)1.143555, (float)1.639404,\n(float)0.700928, (float)0.837280, (float)1.130371,\n(float)0.942749, (float)1.197876, (float)1.669800,\n(float)0.993286, (float)1.378296, (float)1.566528,\n(float)0.801025, (float)1.095337, (float)1.298950,\n(float)0.739990, (float)1.032959, (float)1.383667,\n(float)0.845703, (float)1.072266, (float)1.543823,\n(float)0.915649, (float)1.072266, (float)1.224487,\n(float)1.021973, (float)1.226196, (float)1.481323,\n(float)0.999878, (float)1.204102, (float)1.555908,\n(float)0.722290, (float)0.913940, (float)1.340210,\n(float)0.673340, (float)0.835938, (float)1.259521,\n(float)0.832397, (float)1.208374, (float)1.394165,\n(float)0.962158, (float)1.576172, (float)1.912842,\n(float)1.166748, (float)1.370850, (float)1.556763,\n(float)0.946289, (float)1.138550, (float)1.400391,\n(float)1.035034, (float)1.218262, (float)1.386475,\n(float)1.393799, (float)1.717773, (float)2.000244,\n(float)0.972656, (float)1.260986, (float)1.760620,\n(float)1.028198, (float)1.288452, (float)1.484619, (float)0.773560, (float)1.258057, (float)1.756714,\n(float)1.080322, (float)1.328003, (float)1.742676,\n(float)0.823975, (float)1.450806, (float)1.917725,\n(float)0.859009, (float)1.016602, (float)1.191895,\n(float)0.843994, (float)1.131104, (float)1.645020,\n(float)1.189697, (float)1.702759, (float)1.894409,\n(float)1.346680, (float)1.763184, (float)2.066040,\n(float)0.980469, (float)1.253784, (float)1.441650,\n(float)1.338135, (float)1.641968, (float)1.932739,\n(float)1.223267, (float)1.424194, (float)1.626465,\n(float)0.765747, (float)1.004150, (float)1.579102,\n(float)1.042847, (float)1.269165, (float)1.647461,\n(float)0.968750, (float)1.257568, (float)1.555786,\n(float)0.826294, (float)0.993408, (float)1.275146,\n(float)0.742310, (float)0.950439, (float)1.430542,\n(float)1.054321, (float)1.439819, (float)1.828003,\n(float)1.072998, (float)1.261719, (float)1.441895,\n(float)0.859375, (float)1.036377, (float)1.314819,\n(float)0.895752, (float)1.267212, (float)1.605591,\n(float)0.805420, (float)0.962891, (float)1.142334,\n(float)0.795654, (float)1.005493, (float)1.468506,\n(float)1.105347, (float)1.313843, (float)1.584839,\n(float)0.792236, (float)1.221802, (float)1.465698,\n(float)1.170532, (float)1.467651, (float)1.664063,\n(float)0.838257, (float)1.153198, (float)1.342163,\n(float)0.968018, (float)1.198242, (float)1.391235,\n(float)1.250122, (float)1.623535, (float)1.823608,\n(float)0.711670, (float)1.058350, (float)1.512085,\n(float)1.204834, (float)1.454468, (float)1.739136,\n(float)1.137451, (float)1.421753, (float)1.620117,\n(float)0.820435, (float)1.322754, (float)1.578247,\n(float)0.798706, (float)1.005005, (float)1.213867,\n(float)0.980713, (float)1.324951, (float)1.512939,\n(float)1.112305, (float)1.438843, (float)1.735596,\n(float)1.135498, (float)1.356689, (float)1.635742,\n(float)1.101318, (float)1.387451, (float)1.686523,\n(float)0.849854, (float)1.276978, (float)1.523438,\n(float)1.377930, (float)1.627563, (float)1.858154,\n(float)0.884888, (float)1.095459, (float)1.287476,\n(float)1.289795, (float)1.505859, (float)1.756592,\n(float)0.817505, (float)1.384155, (float)1.650513,\n(float)1.446655, (float)1.702148, (float)1.931885,\n(float)0.835815, (float)1.023071, (float)1.385376,\n(float)0.916626, (float)1.139038, (float)1.335327,\n(float)0.980103, (float)1.174072, (float)1.453735,\n(float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,\n(float)1.797119, (float)2.016846, (float)2.445679, (float)2.701904,\n(float)1.990356, (float)2.219116, (float)2.576416, (float)2.813477, (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083,\n(float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,\n(float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,\n(float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854,\n(float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408,\n(float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987,\n(float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,\n(float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,\n(float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781,\n(float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416,\n(float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288,\n(float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,\n(float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,\n(float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508,\n(float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206,\n(float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086,\n(float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,\n(float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,\n(float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703,\n(float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094,\n(float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450,\n(float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,\n(float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,\n(float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723,\n(float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634,\n(float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494,\n(float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,\n(float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,\n(float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091,\n(float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346,\n(float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219,\n(float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,\n(float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,\n(float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198,\n(float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104,\n(float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892,\n(float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,\n(float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,\n(float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286,\n(float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127,\n(float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748,\n(float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,\n(float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,\n(float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555,\n(float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023,\n(float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851,\n(float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,\n(float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307, (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637,\n(float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643,\n(float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968,\n(float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,\n(float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,\n(float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818,\n(float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466,\n(float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945,\n(float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,\n(float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,\n(float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922,\n(float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794,\n(float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570,\n(float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,\n(float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,\n(float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925,\n(float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984,\n(float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904,\n(float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,\n(float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,\n(float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602,\n(float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331,\n(float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999,\n(float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,\n(float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,\n(float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771,\n(float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076,\n(float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058,\n(float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,\n(float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,\n(float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021,\n(float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693,\n(float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760,\n(float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,\n(float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,\n(float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058,\n(float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929,\n(float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892,\n(float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,\n(float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,\n(float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666,\n(float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521,\n(float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646,\n(float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,\n(float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,\n(float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876,\n(float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465,\n(float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253, (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,\n(float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,\n(float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406,\n(float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807,\n(float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414,\n(float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,\n(float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,\n(float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414,\n(float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647,\n(float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145,\n(float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,\n(float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,\n(float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576,\n(float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705,\n(float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007,\n(float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,\n(float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,\n(float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873,\n(float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558,\n(float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791,\n(float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,\n(float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,\n(float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127,\n(float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545,\n(float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259,\n(float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,\n(float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,\n(float)1.786499, (float)2.041748, (float)2.290405, (float)2.650757,\n(float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.9. anaFilter.h",
      "ja": "A.9。 anaFilter.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "anaFilter.h",
      "ja": "anaFilter.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ANAFILTER_H #define __iLBC_ANAFILTER_H",
      "ja": "#ifndefの__iLBC_ANAFILTER_Hの#define __iLBC_ANAFILTER_H"
    },
    {
      "indent": 3,
      "text": "void anaFilter(",
      "ja": "無効anaFilter（"
    },
    {
      "indent": 3,
      "text": "    float *In,  /* (i) Signal to be filtered */\n    float *a,   /* (i) LP parameters */\n    int len,/* (i) Length of signal */\n    float *Out, /* (o) Filtered signal */\n    float *mem  /* (i/o) Filter state */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.10. anaFilter.c",
      "ja": "A.10。 anaFilter.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "anaFilter.c",
      "ja": "anaFilter.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <string.h> #include \"iLBC_define.h\"",
      "ja": "書式#include <string.hの>の#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  LP analysis filter.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void anaFilter(\n    float *In,  /* (i) Signal to be filtered */\n    float *a,   /* (i) LP parameters */\n    int len,/* (i) Length of signal */\n    float *Out, /* (o) Filtered signal */\n    float *mem  /* (i/o) Filter state */\n){\n    int i, j;\n    float *po, *pi, *pm, *pa;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "po = Out;",
      "ja": "=アウトした後、"
    },
    {
      "indent": 7,
      "text": "/* Filter first part using memory from past */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    pi = &In[i];\n    pm = &mem[LPC_FILTERORDER-1];\n    pa = a;\n    *po=0.0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (j=0; j<=i; j++) {\n    *po+=(*pa++)*(*pi--);\n}\nfor (j=i+1; j<LPC_FILTERORDER+1; j++) {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "        *po+=(*pa++)*(*pm--);\n    }\n    po++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Filter last part where the state is entirely\n   in the input vector */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=LPC_FILTERORDER; i<len; i++) {\n    pi = &In[i];\n    pa = a;\n    *po=0.0;\n    for (j=0; j<LPC_FILTERORDER+1; j++) {\n        *po+=(*pa++)*(*pi--);\n    }\n    po++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Update state vector */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " memcpy(mem, &In[len-LPC_FILTERORDER], LPC_FILTERORDER*sizeof(float)); }",
      "ja": "memcpy（MEM、＆IN [lenの-LPC_FILTERORDER]、LPC_FILTERORDERの*のはsizeof（フロート））。 }"
    },
    {
      "indent": 0,
      "text": "A.11. createCB.h",
      "ja": "A.11。 createCB.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "createCB.h",
      "ja": "createCB.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_CREATECB_H #define __iLBC_CREATECB_H",
      "ja": "#ifndefの__iLBC_CREATECB_Hの#define __iLBC_CREATECB_H"
    },
    {
      "indent": 3,
      "text": "void filteredCBvecs(\n    float *cbvectors,   /* (o) Codebook vector for the\n                               higher section */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    float *mem,         /* (i) Buffer to create codebook\n                               vectors from */\n    int lMem        /* (i) Length of buffer */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void searchAugmentedCB(\n    int low,        /* (i) Start index for the search */\n    int high,           /* (i) End index for the search */\n    int stage,          /* (i) Current stage */\n    int startIndex,     /* (i) CB index for the first\n                               augmented vector */\n    float *target,      /* (i) Target vector for encoding */\n    float *buffer,      /* (i) Pointer to the end of the\n                               buffer for augmented codebook\n                               construction */\n    float *max_measure, /* (i/o) Currently maximum measure */\n    int *best_index,/* (o) Currently the best index */\n    float *gain,    /* (o) Currently the best gain */\n    float *energy,      /* (o) Energy of augmented\n                               codebook vectors */\n    float *invenergy/* (o) Inv energy of aug codebook\n                               vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void createAugmentedVec(\n    int index,          /* (i) Index for the aug vector\n                               to be created */\n    float *buffer,      /* (i) Pointer to the end of the\n                               buffer for augmented codebook\n                               construction */\n    float *cbVec    /* (o) The construced codebook vector */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.12. createCB.c",
      "ja": "A.12。 createCB.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "createCB.c",
      "ja": "createCB.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include <string.h> #include <math.h>",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\" の#include <string.hの>書式#include <math.h>の"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct an additional codebook vector by filtering the\n *  initial codebook buffer. This vector is then used to expand\n *  the codebook with an additional section.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void filteredCBvecs(\n    float *cbvectors,   /* (o) Codebook vectors for the\n                               higher section */\n    float *mem,         /* (i) Buffer to create codebook\n                               vector from */\n    int lMem        /* (i) Length of buffer */\n){\n    int j, k;\n    float *pp, *pp1;\n    float tempbuff2[CB_MEML+CB_FILTERLEN];\n    float *pos;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Create codebook vector for higher section by filtering */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    /* do filtering */\n    pos=cbvectors;\n    memset(pos, 0, lMem*sizeof(float));\n    for (k=0; k<lMem; k++) {\n        pp=&tempbuff2[k];\n        pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n        for (j=0;j<CB_FILTERLEN;j++) {\n            (*pos)+=(*pp++)*(*pp1--);\n        }\n        pos++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Search the augmented part of the codebook to find the best\n *  measure.\n *----------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void searchAugmentedCB(\n    int low,        /* (i) Start index for the search */\n    int high,           /* (i) End index for the search */\n    int stage,          /* (i) Current stage */\n    int startIndex,     /* (i) Codebook index for the first\n                               aug vector */\n    float *target,      /* (i) Target vector for encoding */\n    float *buffer,      /* (i) Pointer to the end of the buffer for\n                               augmented codebook construction */\n    float *max_measure, /* (i/o) Currently maximum measure */\n    int *best_index,/* (o) Currently the best index */\n    float *gain,    /* (o) Currently the best gain */\n    float *energy,      /* (o) Energy of augmented codebook\n                               vectors */\n    float *invenergy/* (o) Inv energy of augmented codebook\n                               vectors */\n) {\n    int icount, ilow, j, tmpIndex;\n    float *pp, *ppo, *ppi, *ppe, crossDot, alfa;\n    float weighted, measure, nrjRecursive;\n    float ftmp;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Compute the energy for the first (low-5)\n   noninterpolated samples */\nnrjRecursive = (float) 0.0;\npp = buffer - low + 1;\nfor (j=0; j<(low-5); j++) {\n    nrjRecursive += ( (*pp)*(*pp) );\n    pp++;\n}\nppe = buffer - low;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (icount=low; icount<=high; icount++) {",
      "ja": "{（ICOUNT ++; ICOUNT <=ハイロー= ICOUNT）のために"
    },
    {
      "indent": 11,
      "text": "/* Index of the codebook vector used for retrieving\n   energy values */\ntmpIndex = startIndex+icount-20;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "ilow = icount-4;",
      "ja": "忘れる= ICOUNT-4。"
    },
    {
      "indent": 11,
      "text": "/* Update the energy recursively to save complexity */\nnrjRecursive = nrjRecursive + (*ppe)*(*ppe);\nppe--;\nenergy[tmpIndex] = nrjRecursive;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Compute cross dot product for the first (low-5)\n   samples */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "crossDot = (float) 0.0;\npp = buffer-icount;\nfor (j=0; j<ilow; j++) {\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* interpolation */\nalfa = (float) 0.2;\nppo = buffer-4;\nppi = buffer-icount-4;\nfor (j=ilow; j<icount; j++) {\n    weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n    ppo++;\n    ppi++;\n    energy[tmpIndex] += weighted*weighted;\n    crossDot += target[j]*weighted;\n    alfa += (float)0.2;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Compute energy and cross dot product for the\n   remaining samples */\npp = buffer - icount;\nfor (j=icount; j<SUBL; j++) {\n    energy[tmpIndex] += (*pp)*(*pp);\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (energy[tmpIndex]>0.0) {\n    invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);\n} else {\n    invenergy[tmpIndex] = (float) 0.0;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (stage==0) { measure = (float)-10000000.0;",
      "ja": "IF（ステージ== 0）{尺度は=（FLOAT）-10000000.0。"
    },
    {
      "indent": 11,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*invenergy[tmpIndex];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[tmpIndex];\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[tmpIndex];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if ((measure>*max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {",
      "ja": "IF（（尺度> * max_measure）&&（ファブ（ftmp）<CB_MAXGAIN））{"
    },
    {
      "indent": 3,
      "text": "            *best_index = tmpIndex;\n            *max_measure = measure;\n            *gain = ftmp;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Recreate a specific codebook vector from the augmented part.\n *\n *----------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void createAugmentedVec(\n    int index,      /* (i) Index for the augmented vector\n                           to be created */\n    float *buffer,  /* (i) Pointer to the end of the buffer for\n                           augmented codebook construction */\n    float *cbVec/* (o) The construced codebook vector */\n) {\n    int ilow, j;\n    float *pp, *ppo, *ppi, alfa, alfa1, weighted;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ilow = index-5;",
      "ja": "ILOW =インデックス5。"
    },
    {
      "indent": 7,
      "text": "/* copy the first noninterpolated part */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pp = buffer-index;\nmemcpy(cbVec,pp,sizeof(float)*index);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* interpolation */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "alfa1 = (float)0.2;\nalfa = 0.0;\nppo = buffer-5;\nppi = buffer-index-5;\nfor (j=ilow; j<index; j++) {\n    weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n    ppo++;\n    ppi++;\n    cbVec[j] = weighted;\n    alfa += alfa1;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* copy the second noninterpolated part */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pp = buffer - index;\nmemcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "A.13. doCPLC.h",
      "ja": "A.13。 doCPLC.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "doCPLC.h",
      "ja": "doCPLC.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_DOLPC_H #define __iLBC_DOLPC_H",
      "ja": "#ifndefの__iLBC_DOLPC_Hの#define __iLBC_DOLPC_H"
    },
    {
      "indent": 3,
      "text": "void doThePLC(\n    float *PLCresidual, /* (o) concealed residual */\n    float *PLClpc,      /* (o) concealed LP parameters */\n    int PLI,        /* (i) packet loss indicator\n                               0 - no PL, 1 = PL */\n    float *decresidual, /* (i) decoded residual */\n    float *lpc,         /* (i) decoded LPC (only used for no PL) */\n    int inlag,          /* (i) pitch lag */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) decoder instance */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.14. doCPLC.c",
      "ja": "A.14。 doCPLC.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "doCPLC.c",
      "ja": "doCPLC.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h> #include <stdio.h>",
      "ja": "書式#include <math.h>の書式#include <string.hの>書式#include <stdio.hに>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Compute cross correlation and pitch gain for pitch prediction\n *  of last subframe at given lag.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void compCorr(\n    float *cc,      /* (o) cross correlation coefficient */\n    float *gc,      /* (o) gain */\n    float *pm,\n    float *buffer,  /* (i) signal buffer */\n    int lag,    /* (i) pitch lag */\n    int bLen,       /* (i) length of buffer */\n    int sRange      /* (i) correlation search length */\n){\n    int i;\n    float ftmp1, ftmp2, ftmp3;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Guard against getting outside buffer */\nif ((bLen-sRange-lag)<0) {\n    sRange=bLen-lag;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ftmp1 = 0.0;\nftmp2 = 0.0;\nftmp3 = 0.0;\nfor (i=0; i<sRange; i++) {\n    ftmp1 += buffer[bLen-sRange+i] *\n        buffer[bLen-sRange+i-lag];\n    ftmp2 += buffer[bLen-sRange+i-lag] *\n            buffer[bLen-sRange+i-lag];\n    ftmp3 += buffer[bLen-sRange+i] *\n            buffer[bLen-sRange+i];\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    if (ftmp2 > 0.0) {\n        *cc = ftmp1*ftmp1/ftmp2;\n        *gc = (float)fabs(ftmp1/ftmp2);\n        *pm=(float)fabs(ftmp1)/\n            ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));\n    }\n    else {\n        *cc = 0.0;\n        *gc = 0.0;\n        *pm=0.0;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Packet loss concealment routine. Conceals a residual signal\n *  and LP parameters. If no packet loss, update state.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void doThePLC(\n    float *PLCresidual, /* (o) concealed residual */\n    float *PLClpc,      /* (o) concealed LP parameters */\n    int PLI,        /* (i) packet loss indicator\n                               0 - no PL, 1 = PL */\n    float *decresidual, /* (i) decoded residual */\n    float *lpc,         /* (i) decoded LPC (only used for no PL) */\n    int inlag,          /* (i) pitch lag */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) decoder instance */\n){\n    int lag=20, randlag;\n    float gain, maxcc;\n    float use_gain;\n    float gain_comp, maxcc_comp, per, max_per;\n    int i, pick, use_lag;\n    float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Packet Loss */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (PLI == 1) {",
      "ja": "IF（MORE == 1）{"
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->consPLICount += 1;",
      "ja": "iLBCdec_inst-> consPLICount + = 1;"
    },
    {
      "indent": 11,
      "text": "/* if previous frame not lost,\n   determine pitch pred. gain */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (iLBCdec_inst->prevPLI != 1) {",
      "ja": "もし（iLBCdec_inst-> prevPLI！= 1）{"
    },
    {
      "indent": 15,
      "text": "/* Search around the previous lag to find the\n   best pitch period */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "lag=inlag-3;\ncompCorr(&maxcc, &gain, &max_per,\n    iLBCdec_inst->prevResidual,\n    lag, iLBCdec_inst->blockl, 60);\nfor (i=inlag-2;i<=inlag+3;i++) {\n    compCorr(&maxcc_comp, &gain_comp, &per,\n        iLBCdec_inst->prevResidual,\n        i, iLBCdec_inst->blockl, 60);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "if (maxcc_comp>maxcc) {\n    maxcc=maxcc_comp;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "        gain=gain_comp;\n        lag=i;\n        max_per=per;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 11,
      "text": "/* previous frame lost, use recorded lag and periodicity */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "else {\n    lag=iLBCdec_inst->prevLag;\n    max_per=iLBCdec_inst->per;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* downscaling */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "use_gain=1.0;\nif (iLBCdec_inst->consPLICount*iLBCdec_inst->blockl>320)\n    use_gain=(float)0.9;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>2*320)\n    use_gain=(float)0.7;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>3*320)\n    use_gain=(float)0.5;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>4*320)\n    use_gain=(float)0.0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* mix noise and pitch repeatition */\nftmp=(float)sqrt(max_per);\nif (ftmp>(float)0.7)\n    pitchfact=(float)1.0;\nelse if (ftmp>(float)0.4)\n    pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);\nelse\n    pitchfact=0.0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* avoid repetition of same pitch cycle */\nuse_lag=lag;\nif (lag<80) {\n    use_lag=2*lag;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* compute concealed residual */ energy = 0.0;\nfor (i=0; i<iLBCdec_inst->blockl; i++) {",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* noise component */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "iLBCdec_inst->seed=(iLBCdec_inst->seed*69069L+1) &\n    (0x80000000L-1);\nrandlag = 50 + ((signed long) iLBCdec_inst->seed)%70;\npick = i - randlag;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (pick < 0) {\n    randvec[i] =\n        iLBCdec_inst->prevResidual[\n                    iLBCdec_inst->blockl+pick];\n} else {\n    randvec[i] =  randvec[pick];\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* pitch repeatition component */\npick = i - use_lag;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (pick < 0) {\n    PLCresidual[i] =\n        iLBCdec_inst->prevResidual[\n                    iLBCdec_inst->blockl+pick];\n} else {\n    PLCresidual[i] = PLCresidual[pick];\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* mix random and periodicity component */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (i<80)\n    PLCresidual[i] = use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);\nelse if (i<160)\n    PLCresidual[i] = (float)0.95*use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);\nelse\n    PLCresidual[i] = (float)0.9*use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);",
      "raw": true
    },
    {
      "indent": 11,
      "text": " energy += PLCresidual[i] * PLCresidual[i]; }",
      "ja": "エネルギー+ = PLCresidual [I] * PLCresidual [i]は、 }"
    },
    {
      "indent": 11,
      "text": "/* less than 30 dB, use only noise */ if (sqrt(energy/(float)iLBCdec_inst->blockl) < 30.0) {\n    gain=0.0;\n    for (i=0; i<iLBCdec_inst->blockl; i++) {\n        PLCresidual[i] = randvec[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* use old LPC */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memcpy(PLClpc,iLBCdec_inst->prevLpc, (LPC_FILTERORDER+1)*sizeof(float));",
      "ja": "memcpy（PLClpc、iLBCdec_inst-> prevLpc、（LPC_FILTERORDER + 1）*はsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* no packet loss, copy input */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "else {\n    memcpy(PLCresidual, decresidual,\n        iLBCdec_inst->blockl*sizeof(float));\n    memcpy(PLClpc, lpc, (LPC_FILTERORDER+1)*sizeof(float));\n    iLBCdec_inst->consPLICount = 0;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* update state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (PLI) {\n    iLBCdec_inst->prevLag = lag;\n    iLBCdec_inst->per=max_per;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    iLBCdec_inst->prevPLI = PLI;\n    memcpy(iLBCdec_inst->prevLpc, PLClpc,\n        (LPC_FILTERORDER+1)*sizeof(float));\n    memcpy(iLBCdec_inst->prevResidual, PLCresidual,\n        iLBCdec_inst->blockl*sizeof(float));\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.15. enhancer.h",
      "ja": "A.15。 enhancer.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "enhancer.h",
      "ja": "enhancer.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __ENHANCER_H #define __ENHANCER_H",
      "ja": "#ifndefの__ENHANCER_Hの#define __ENHANCER_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "float xCorrCoef(\n    float *target,      /* (i) first array */\n    float *regressor,   /* (i) second array */\n    int subl        /* (i) dimension arrays */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int enhancerInterface(\n    float *out,         /* (o) the enhanced recidual signal */\n    float *in,          /* (i) the recidual signal to enhance */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) the decoder state structure */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.16. enhancer.c",
      "ja": "A.16。 enhancer.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "enhancer.c",
      "ja": "enhancer.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h> #include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\"",
      "ja": "書式#include <math.h>の書式#include <string.hの>の#include \"iLBC_define.h\" の#include \"constants.h\" の#include \"filter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * Find index in array such that the array element with said\n * index is the element of said array closest to \"value\"\n * according to the squared-error criterion\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void NearestNeighbor(",
      "ja": "無効NearestNeighbor（"
    },
    {
      "indent": 3,
      "text": "    int   *index,   /* (o) index of array element closest\n                           to value */\n    float *array,   /* (i) data array */\n    float value,/* (i) value */\n    int arlength/* (i) dimension of data array */\n){\n    int i;\n    float bestcrit,crit;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "crit=array[0]-value;\nbestcrit=crit*crit;\n*index=0;\nfor (i=1; i<arlength; i++) {\n    crit=array[i]-value;\n    crit=crit*crit;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        if (crit<bestcrit) {\n            bestcrit=crit;\n            *index=i;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * compute cross correlation between sequences\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void mycorr1(\n    float* corr,    /* (o) correlation of seq1 and seq2 */\n    float* seq1,    /* (i) first sequence */\n    int dim1,           /* (i) dimension first seq1 */\n    const float *seq2,  /* (i) second sequence */\n    int dim2        /* (i) dimension seq2 */\n){\n    int i,j;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    for (i=0; i<=dim1-dim2; i++) {\n        corr[i]=0.0;\n        for (j=0; j<dim2; j++) {\n            corr[i] += seq1[i+j] * seq2[j];\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * upsample finite array assuming zeros outside bounds\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void enh_upsample(\n    float* useq1,   /* (o) upsampled output sequence */\n    float* seq1,/* (i) unupsampled sequence */\n    int dim1,       /* (i) dimension seq1 */\n    int hfl         /* (i) polyphase filter length=2*hfl+1 */\n){\n    float *pu,*ps;\n    int i,j,k,q,filterlength,hfl2;\n    const float *polyp[ENH_UPS0]; /* pointers to\n                                     polyphase columns */\n    const float *pp;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* define pointers for filter */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "filterlength=2*hfl+1;",
      "ja": "filterlength = 2 * HFL + 1。"
    },
    {
      "indent": 7,
      "text": "if ( filterlength > dim1 ) {\n    hfl2=(int) (dim1/2);\n    for (j=0; j<ENH_UPS0; j++) {\n        polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;\n    }\n    hfl=hfl2;\n    filterlength=2*hfl+1;\n}\nelse {\n    for (j=0; j<ENH_UPS0; j++) {\n        polyp[j]=polyphaserTbl+j*filterlength;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* filtering: filter overhangs left side of sequence */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pu=useq1;\nfor (i=hfl; i<filterlength; i++) {\n    for (j=0; j<ENH_UPS0; j++) {\n        *pu=0.0;\n        pp = polyp[j];\n        ps = seq1+i;\n        for (k=0; k<=i; k++) {\n            *pu += *ps-- * *pp++;\n        }\n        pu++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* filtering: simple convolution=inner products */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=filterlength; i<dim1; i++) {",
      "ja": "{（; iは<DIM1 I ++はI = filterlength）のために"
    },
    {
      "indent": 7,
      "text": "    for (j=0;j<ENH_UPS0; j++){\n        *pu=0.0;\n        pp = polyp[j];\n        ps = seq1+i;\n        for (k=0; k<filterlength; k++) {\n            *pu += *ps-- * *pp++;\n        }\n        pu++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* filtering: filter overhangs right side of sequence */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    for (q=1; q<=hfl; q++) {\n        for (j=0; j<ENH_UPS0; j++) {\n            *pu=0.0;\n            pp = polyp[j]+q;\n            ps = seq1+dim1-1;\n            for (k=0; k<filterlength-q; k++) {\n                *pu += *ps-- * *pp++;\n            }\n            pu++;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * find segment starting near idata+estSegPos that has highest\n * correlation with idata+centerStartPos through\n * idata+centerStartPos+ENH_BLOCKL-1 segment is found at a\n * resolution of ENH_UPSO times the original of the original\n * sampling rate\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void refiner(\n    float *seg,         /* (o) segment array */\n    float *updStartPos, /* (o) updated start point */\n    float* idata,       /* (i) original data buffer */\n    int idatal,         /* (i) dimension of idata */\n    int centerStartPos, /* (i) beginning center segment */\n    float estSegPos,/* (i) estimated beginning other segment */\n    float period    /* (i) estimated pitch period */\n){\n    int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;\n    int tloc,tloc2,i,st,en,fraction;\n    float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;\n    float corrVecUps[ENH_CORRDIM*ENH_UPS0];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* defining array bounds */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "estSegPosRounded=(int)(estSegPos - 0.5);",
      "ja": "estSegPosRounded =（INT）（estSegPos  -  0.5）。"
    },
    {
      "indent": 7,
      "text": "searchSegStartPos=estSegPosRounded-ENH_SLOP;",
      "ja": "searchSegStartPos = estSegPosRounded-ENH_SLOP。"
    },
    {
      "indent": 7,
      "text": "if (searchSegStartPos<0) {\n    searchSegStartPos=0;\n}\nsearchSegEndPos=estSegPosRounded+ENH_SLOP;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (searchSegEndPos+ENH_BLOCKL >= idatal) {\n    searchSegEndPos=idatal-ENH_BLOCKL-1;\n}\ncorrdim=searchSegEndPos-searchSegStartPos+1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* compute upsampled correlation (corr33) and find\n   location of max */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "mycorr1(corrVec,idata+searchSegStartPos,\n    corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);\nenh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);\ntloc=0; maxv=corrVecUps[0];\nfor (i=1; i<ENH_UPS0*corrdim; i++) {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if (corrVecUps[i]>maxv) {\n        tloc=i;\n        maxv=corrVecUps[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* make vector can be upsampled without ever running outside\n   bounds */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "*updStartPos= (float)searchSegStartPos +\n    (float)tloc/(float)ENH_UPS0+(float)1.0;\ntloc2=(int)(tloc/ENH_UPS0);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (tloc>tloc2*ENH_UPS0) {\n    tloc2++;\n}\nst=searchSegStartPos+tloc2-ENH_FL0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (st<0) {\n    memset(vect,0,-st*sizeof(float));\n    memcpy(&vect[-st],idata, (ENH_VECTL+st)*sizeof(float));\n}\nelse {",
      "raw": true
    },
    {
      "indent": 11,
      "text": "en=st+ENH_VECTL;",
      "ja": "そして= ST + ENH_VECTL。"
    },
    {
      "indent": 7,
      "text": "    if (en>idatal) {\n        memcpy(vect, &idata[st],\n            (ENH_VECTL-(en-idatal))*sizeof(float));\n        memset(&vect[ENH_VECTL-(en-idatal)], 0,\n            (en-idatal)*sizeof(float));\n    }\n    else {\n        memcpy(vect, &idata[st], ENH_VECTL*sizeof(float));\n    }\n}\nfraction=tloc2*ENH_UPS0-tloc;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* compute the segment (this is actually a convolution) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction, 2*ENH_FL0+1); }",
      "ja": "mycorr1（SEG、VECT、ENH_VECTL、polyphaserTbl +（2 * ENH_FL0 + 1）*分数、2 * ENH_FL0 + 1）。 }"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * find the smoothed output data\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void smath(\n    float *odata,   /* (o) smoothed output */\n    float *sseq,/* (i) said second sequence of waveforms */\n    int hl,         /* (i) 2*hl+1 is sseq dimension */\n    float alpha0/* (i) max smoothing energy fraction */\n){\n    int i,k;\n    float w00,w10,w11,A,B,C,*psseq,err,errs;\n    float surround[BLOCKL_MAX]; /* shape contributed by other than\n                                   current */\n    float wt[2*ENH_HL+1];       /* waveform weighting to get\n                                   surround shape */\n    float denom;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* create shape of contribution from all waveforms except the\n   current one */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=1; i<=2*hl+1; i++) {\n    wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));\n}\nwt[hl]=0.0; /* for clarity, not used */\nfor (i=0; i<ENH_BLOCKL; i++) {\n    surround[i]=sseq[i]*wt[0];\n} for (k=1; k<hl; k++) {\n    psseq=sseq+k*ENH_BLOCKL;\n    for(i=0;i<ENH_BLOCKL; i++) {\n        surround[i]+=psseq[i]*wt[k];\n    }\n}\nfor (k=hl+1; k<=2*hl; k++) {\n    psseq=sseq+k*ENH_BLOCKL;\n    for(i=0;i<ENH_BLOCKL; i++) {\n        surround[i]+=psseq[i]*wt[k];\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* compute some inner products */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "w00 = w10 = w11 = 0.0;\npsseq=sseq+hl*ENH_BLOCKL; /* current block  */\nfor (i=0; i<ENH_BLOCKL;i++) {\n    w00+=psseq[i]*psseq[i];\n    w11+=surround[i]*surround[i];\n    w10+=surround[i]*psseq[i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (fabs(w11) < 1.0) {\n    w11=1.0;\n}\nC = (float)sqrt( w00/w11);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* first try enhancement without power-constraint */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "errs=0.0;\npsseq=sseq+hl*ENH_BLOCKL;\nfor (i=0; i<ENH_BLOCKL; i++) {\n    odata[i]=C*surround[i];\n    err=psseq[i]-odata[i];\n    errs+=err*err;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* if constraint violated by first try, add constraint */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (errs > alpha0 * w00) {\n    if ( w00 < 1) {\n        w00=1;\n    }\n    denom = (w11*w00-w10*w10)/(w00*w00);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (denom > 0.0001) { /* eliminates numerical problems\n                         for if smooth */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);\n    B = -alpha0/2 - A * w10/w00;\n    B = B+1;\n}\nelse { /* essentially no difference between cycles;\n          smoothing not needed */\n    A= 0.0;\n    B= 1.0;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* create smoothed sequence */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        psseq=sseq+hl*ENH_BLOCKL;\n        for (i=0; i<ENH_BLOCKL; i++) {\n            odata[i]=A*surround[i]+B*psseq[i];\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * get the pitch-synchronous sample sequence\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void getsseq(\n    float *sseq,    /* (o) the pitch-synchronous sequence */\n    float *idata,       /* (i) original data */\n    int idatal,         /* (i) dimension of data */\n    int centerStartPos, /* (i) where current block starts */\n    float *period,      /* (i) rough-pitch-period array */\n    float *plocs,       /* (i) where periods of period array\n                               are taken */\n    int periodl,    /* (i) dimension period array */\n    int hl              /* (i) 2*hl+1 is the number of sequences */\n){\n    int i,centerEndPos,q;\n    float blockStartPos[2*ENH_HL+1];\n    int lagBlock[2*ENH_HL+1];\n    float plocs2[ENH_PLOCSL];\n    float *psseq;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "centerEndPos=centerStartPos+ENH_BLOCKL-1;",
      "ja": "centerEndPos = centerStartPos + ENH_BLOCKL-1。"
    },
    {
      "indent": 7,
      "text": "/* present */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "NearestNeighbor(lagBlock+hl,plocs, (float)0.5*(centerStartPos+centerEndPos),periodl);",
      "ja": "最近傍（lagBlock +のHL、plocs、（フロート）0.5×（中心StartPos + centerEndPos）、ピリオド）。"
    },
    {
      "indent": 7,
      "text": "blockStartPos[hl]=(float)centerStartPos;",
      "ja": "blockStartPos [HL] =（FLOAT）centerStartPos。"
    },
    {
      "indent": 7,
      "text": "psseq=sseq+ENH_BLOCKL*hl;\nmemcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* past */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (q=hl-1; q>=0; q--) {\n    blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];\n    NearestNeighbor(lagBlock+q,plocs,\n        blockStartPos[q]+\n        ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if (blockStartPos[q]-ENH_OVERHANG>=0) {\n        refiner(sseq+q*ENH_BLOCKL, blockStartPos+q, idata,\n            idatal, centerStartPos, blockStartPos[q],\n            period[lagBlock[q+1]]);\n    } else {\n        psseq=sseq+q*ENH_BLOCKL;\n        memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* future */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<periodl; i++) {\n    plocs2[i]=plocs[i]-period[i];\n}\nfor (q=hl+1; q<=2*hl; q++) {\n    NearestNeighbor(lagBlock+q,plocs2,\n        blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];\n        if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG<idatal) {\n            refiner(sseq+ENH_BLOCKL*q, blockStartPos+q, idata,\n                idatal, centerStartPos, blockStartPos[q],\n                period[lagBlock[q]]);\n        }\n        else {\n            psseq=sseq+q*ENH_BLOCKL;\n            memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * perform enhancement on idata+centerStartPos through\n * idata+centerStartPos+ENH_BLOCKL-1\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void enhancer(\n    float *odata,       /* (o) smoothed block, dimension blockl */\n    float *idata,       /* (i) data buffer used for enhancing */\n    int idatal,         /* (i) dimension idata */\n    int centerStartPos, /* (i) first sample current block\n                               within idata */\n    float alpha0,       /* (i) max correction-energy-fraction\n                              (in [0,1]) */\n    float *period,      /* (i) pitch period array */\n    float *plocs,       /* (i) locations where period array\n                               values valid */\n    int periodl         /* (i) dimension of period and plocs */\n){\n    float sseq[(2*ENH_HL+1)*ENH_BLOCKL];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* get said second sequence of segments */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "getsseq(sseq,idata,idatal,centerStartPos,period, plocs,periodl,ENH_HL);",
      "ja": "getsseq（sseq、IDATA、idatal、centerStartPos、期間、plocs、periodl、ENH_HL）。"
    },
    {
      "indent": 7,
      "text": "/* compute the smoothed output from said second sequence */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "smath(odata,sseq,ENH_HL,alpha0);",
      "ja": "できる（ODTA、圧縮、Enh_hl、ALPH 0）。"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * cross correlation\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float xCorrCoef(\n    float *target,      /* (i) first array */\n    float *regressor,   /* (i) second array */\n    int subl        /* (i) dimension arrays */\n){\n    int i;\n    float ftmp1, ftmp2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ftmp1 = 0.0;\nftmp2 = 0.0;\nfor (i=0; i<subl; i++) {\n    ftmp1 += target[i]*regressor[i];\n    ftmp2 += regressor[i]*regressor[i];\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    if (ftmp1 > 0.0) {\n        return (float)(ftmp1*ftmp1/ftmp2);\n    } else {\n        return (float)0.0;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * interface for enhancer\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int enhancerInterface(\n    float *out,                     /* (o) enhanced signal */\n    float *in,                      /* (i) unenhanced signal */\n    iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */\n){\n    float *enh_buf, *enh_period;\n    int iblock, isample;\n    int lag=0, ilag, i, ioffset;\n    float cc, maxcc;\n    float ftmp1, ftmp2;\n    float *inPtr, *enh_bufPtr1, *enh_bufPtr2;\n    float plc_pred[ENH_BLOCKL];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];\nint inLen=ENH_NBLOCKS*ENH_BLOCKL+120;\nint start, plc_blockl, inlag;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "enh_buf=iLBCdec_inst->enh_buf;\nenh_period=iLBCdec_inst->enh_period;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memmove(enh_buf, &enh_buf[iLBCdec_inst->blockl], (ENH_BUFL-iLBCdec_inst->blockl)*sizeof(float));",
      "ja": "MEMMOVE（enh_buf、＆enh_buf [iLBCdec_inst-> blockl]、（ENH_BUFL-iLBCdec_inst-> blockl）*はsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "memcpy(&enh_buf[ENH_BUFL-iLBCdec_inst->blockl], in, iLBCdec_inst->blockl*sizeof(float));",
      "ja": "memcpy（＆enh_buf [ENH_BUFL-iLBCdec_inst-> blockl]、blocklの*のはsizeof（フロート）> iLBCdec_inst-、IN）。"
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30)\n    plc_blockl=ENH_BLOCKL;\nelse\n    plc_blockl=40;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* when 20 ms frame, move processing one block */\nioffset=0;\nif (iLBCdec_inst->mode==20) ioffset=1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "i=3-ioffset;\nmemmove(enh_period, &enh_period[i],\n    (ENH_NBLOCKS_TOT-i)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Set state information to the 6 samples right before\n   the samples to be downsampled. */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memcpy(lpState, enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126, 6*sizeof(float));",
      "ja": "memcpy（lpState、enh_buf +（ENH_NBLOCKS_EXTRA +がioffset）* ENH_BLOCKL-126、6 *のはsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "/* Down sample a factor 2 to save computations */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120, lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL, lpState, downsampled);",
      "ja": "ダウンサンプリング（enh_buf +（ENH_NBLOCKS_EXTRA +がioffset）* ENH_BLOCKL-120、lpFilt_coefsTbl、inLen-IOFFSET * ENH_BLOCKL、lpState、ダウンサンプリング）。"
    },
    {
      "indent": 7,
      "text": "/* Estimate the pitch in the down sampled domain. */\nfor (iblock = 0; iblock<ENH_NBLOCKS-ioffset; iblock++) {",
      "raw": true
    },
    {
      "indent": 11,
      "text": "lag = 10;\nmaxcc = xCorrCoef(downsampled+60+iblock*\n    ENH_BLOCKL_HALF, downsampled+60+iblock*\n    ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF);\nfor (ilag=11; ilag<60; ilag++) {\n    cc = xCorrCoef(downsampled+60+iblock*\n        ENH_BLOCKL_HALF, downsampled+60+iblock*\n        ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Store the estimated lag in the non-downsampled domain */\nenh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset] = (float)lag*2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* PLC was performed on the previous packet */\nif (iLBCdec_inst->prev_enh_pl==1) {",
      "raw": true
    },
    {
      "indent": 11,
      "text": "inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];",
      "ja": "inlag =（INT）enh_period [ENH_NBLOCKS_EXTRA +がioffset]。"
    },
    {
      "indent": 11,
      "text": "lag = inlag-1;\nmaxcc = xCorrCoef(in, in+lag, plc_blockl);\nfor (ilag=inlag; ilag<=inlag+1; ilag++) {\n    cc = xCorrCoef(in, in+ilag, plc_blockl);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;",
      "ja": "enh_period [ENH_NBLOCKS_EXTRA +がioffset-1] =（FLOAT）遅れ。"
    },
    {
      "indent": 11,
      "text": "/* compute new concealed residual for the old lookahead,\n   mix the forward PLC with a backward PLC from\n   the new frame */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "inPtr=&in[lag-1];",
      "ja": "INPTR = IN [LAG-1]。"
    },
    {
      "indent": 11,
      "text": "enh_bufPtr1=&plc_pred[plc_blockl-1];",
      "ja": "enh_bufPtr1 =＆plc_pred [plc_blockl-1]。"
    },
    {
      "indent": 11,
      "text": "if (lag>plc_blockl) {\n    start=plc_blockl;\n} else {\n    start=lag;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (isample = start; isample>0; isample--) { *enh_bufPtr1-- = *inPtr--; }",
      "ja": "（isample =開始; isample> 0; isample--）のために{* enh_bufPtr1-- = * inPtr--。 }"
    },
    {
      "indent": 11,
      "text": "enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\nfor (isample = (plc_blockl-1-lag); isample>=0; isample--) {\n    *enh_bufPtr1-- = *enh_bufPtr2--;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* limit energy change */\nftmp2=0.0;\nftmp1=0.0;\nfor (i=0;i<plc_blockl;i++) {\n    ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i]*\n        enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i];\n    ftmp1+=plc_pred[i]*plc_pred[i];\n}\nftmp1=(float)sqrt(ftmp1/(float)plc_blockl);\nftmp2=(float)sqrt(ftmp2/(float)plc_blockl);\nif (ftmp1>(float)2.0*ftmp2 && ftmp1>0.0) {\n    for (i=0;i<plc_blockl-10;i++) {\n        plc_pred[i]*=(float)2.0*ftmp2/ftmp1;\n    }\n    for (i=plc_blockl-10;i<plc_blockl;i++) {\n        plc_pred[i]*=(float)(i-plc_blockl+10)*\n            ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+ (float)2.0*ftmp2/ftmp1;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\n    for (i=0; i<plc_blockl; i++) {\n        ftmp1 = (float) (i+1) / (float) (plc_blockl+1);\n        *enh_bufPtr1 *= ftmp1;\n        *enh_bufPtr1 += ((float)1.0-ftmp1)*\n                            plc_pred[plc_blockl-1-i];\n        enh_bufPtr1--;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==20) {\n    /* Enhancer with 40 samples delay */\n    for (iblock = 0; iblock<2; iblock++) {\n        enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n            ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,\n            ENH_ALPHA0, enh_period, enh_plocsTbl,\n                ENH_NBLOCKS_TOT);\n    }\n} else if (iLBCdec_inst->mode==30) {\n    /* Enhancer with 80 samples delay */\n    for (iblock = 0; iblock<3; iblock++) {\n        enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n            ENH_BUFL, (4+iblock)*ENH_BLOCKL,\n            ENH_ALPHA0, enh_period, enh_plocsTbl,\n                ENH_NBLOCKS_TOT);\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return (lag*2); }",
      "ja": "リターン（ラグ* 2）。 }"
    },
    {
      "indent": 0,
      "text": "A.17. filter.h",
      "ja": "A.17。 filter.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "filter.h",
      "ja": "filter.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_FILTER_H #define __iLBC_FILTER_H",
      "ja": "#ifndefの__iLBC_FILTER_Hの#define __iLBC_FILTER_H"
    },
    {
      "indent": 3,
      "text": "void AllPoleFilter(\n    float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to\n                           InOut[-1] contain the state of the\n                           filter (delayed samples). InOut[0] to\n                           InOut[lengthInOut-1] contain the filter\n                           input, on en exit InOut[-orderCoef] to\n                           InOut[-1] is unchanged and InOut[0] to\n                           InOut[lengthInOut-1] contain filtered\n                           samples */\n    float *Coef,/* (i) filter coefficients, Coef[0] is assumed\n                           to be 1.0 */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef   /* (i) number of filter coefficients */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void AllZeroFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples */\n    float *Coef,/* (i) filter coefficients (Coef[0] is assumed\n                           to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain the filter state, on exit Out[0]\n                           to Out[lengthInOut-1] contain filtered\n                           samples */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void ZeroPoleFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain filter\n                           input samples In[-orderCoef] to In[-1]\n                           contain state of all-zero section */\n    float *ZeroCoef,/* (i) filter coefficients for all-zero\n                           section (ZeroCoef[0] is assumed to\n                           be 1.0) */\n    float *PoleCoef,/* (i) filter coefficients for all-pole section\n                           (ZeroCoef[0] is assumed to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain state of all-pole section. On\n                           exit Out[0] to Out[lengthInOut-1]\n                           contain filtered samples */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void DownSample (\n    float  *In,     /* (i) input samples */\n    float  *Coef,   /* (i) filter coefficients */\n    int lengthIn,   /* (i) number of input samples */\n    float  *state,  /* (i) filter state */\n    float  *Out     /* (o) downsampled output */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.18. filter.c",
      "ja": "A.18。 filter.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "filter.c",
      "ja": "filter.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  all-pole filter\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void AllPoleFilter(\n    float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to\n                           InOut[-1] contain the state of the\n                           filter (delayed samples). InOut[0] to\n                           InOut[lengthInOut-1] contain the filter\n                           input, on en exit InOut[-orderCoef] to\n                           InOut[-1] is unchanged and InOut[0] to\n                           InOut[lengthInOut-1] contain filtered\n                           samples */\n    float *Coef,/* (i) filter coefficients, Coef[0] is assumed\n                           to be 1.0 */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef   /* (i) number of filter coefficients */\n){\n    int n,k;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for(n=0;n<lengthInOut;n++){\n    for(k=1;k<=orderCoef;k++){\n        *InOut -= Coef[k]*InOut[-k];",
      "raw": true
    },
    {
      "indent": 3,
      "text": " } InOut++; } }",
      "ja": "}のInOut ++。 }}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  all-zero filter\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void AllZeroFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples */\n    float *Coef,/* (i) filter coefficients (Coef[0] is assumed\n                           to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain the filter state, on exit Out[0]\n                           to Out[lengthInOut-1] contain filtered\n                           samples */\n){\n    int n,k;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    for(n=0;n<lengthInOut;n++){\n        *Out = Coef[0]*In[0];\n        for(k=1;k<=orderCoef;k++){\n            *Out += Coef[k]*In[-k];\n        }\n        Out++;\n        In++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  pole-zero filter\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void ZeroPoleFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples In[-orderCoef] to\n                           In[-1] contain state of all-zero\n                           section */\n    float *ZeroCoef,/* (i) filter coefficients for all-zero\n                           section (ZeroCoef[0] is assumed to\n                           be 1.0) */\n    float *PoleCoef,/* (i) filter coefficients for all-pole section\n                           (ZeroCoef[0] is assumed to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */ int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain state of all-pole section. On\n                           exit Out[0] to Out[lengthInOut-1]\n                           contain filtered samples */\n){\n    AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);\n    AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * downsample (LP filter and decimation)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void DownSample (\n    float  *In,     /* (i) input samples */\n    float  *Coef,   /* (i) filter coefficients */\n    int lengthIn,   /* (i) number of input samples */\n    float  *state,  /* (i) filter state */\n    float  *Out     /* (o) downsampled output */\n){\n    float   o;\n    float *Out_ptr = Out;\n    float *Coef_ptr, *In_ptr;\n    float *state_ptr;\n    int i, j, stop;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* LP filter and decimate at the same time */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = DELAY_DS; i < lengthIn; i+=FACTOR_DS)\n{\n    Coef_ptr = &Coef[0];\n    In_ptr = &In[i];\n    state_ptr = &state[FILTERORDER_DS-2];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "o = (float)0.0;",
      "ja": "O =（FLOAT）0.0。"
    },
    {
      "indent": 11,
      "text": "stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;",
      "ja": "（私はFILTERORDER_DSを<）=停止？ I + 1：FILTERORDER_DS。"
    },
    {
      "indent": 11,
      "text": "for (j = 0; j < stop; j++)\n{\n    o += *Coef_ptr++ * (*In_ptr--);\n}\nfor (j = i + 1; j < FILTERORDER_DS; j++)\n{\n    o += *Coef_ptr++ * (*state_ptr--);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": " *Out_ptr++ = o; }",
      "ja": "* Out_ptr ++ = O; }"
    },
    {
      "indent": 7,
      "text": "/* Get the last part (use zeros as input for the future) */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=(lengthIn+FACTOR_DS); i<(lengthIn+DELAY_DS); i+=FACTOR_DS) {",
      "ja": "以下のために（+ FACTOR DSでiは=（長さ）、iが（長く+ DELAY_MS）<; I + = FACTOR_DS）{"
    },
    {
      "indent": 11,
      "text": "o=(float)0.0;",
      "ja": "O =（FLOAT）0.0。"
    },
    {
      "indent": 3,
      "text": "        if (i<lengthIn) {\n            Coef_ptr = &Coef[0];\n            In_ptr = &In[i];\n            for (j=0; j<FILTERORDER_DS; j++) {\n                    o += *Coef_ptr++ * (*Out_ptr--);\n            }\n        } else {\n            Coef_ptr = &Coef[i-lengthIn];\n            In_ptr = &In[lengthIn-1];\n            for (j=0; j<FILTERORDER_DS-(i-lengthIn); j++) {\n                    o += *Coef_ptr++ * (*In_ptr--);\n            }\n        }\n        *Out_ptr++ = o;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.19. FrameClassify.h",
      "ja": "A.19。 FrameClassify.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "FrameClassify.h",
      "ja": "FrameClassify.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_FRAMECLASSIFY_H #define __iLBC_FRAMECLASSIFY_H",
      "ja": "#ifndefの__iLBC_FRAMECLASSIFY_Hの#define __iLBC_FRAMECLASSIFY_H"
    },
    {
      "indent": 3,
      "text": "int FrameClassify(      /* index to the max-energy sub-frame */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i/o) the encoder state structure */\n    float *residual     /* (i) lpc residual signal */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.20. FrameClassify.c",
      "ja": "A.20。 FrameClassify.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "FrameClassify.c",
      "ja": "FrameClassify.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  Classification of subframes to localize start state\n *--------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int FrameClassify(      /* index to the max-energy sub-frame */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i/o) the encoder state structure */\n    float *residual     /* (i) lpc residual signal */\n) {\n    float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;\n    int n, l, max_ssqEn_n;\n    const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,\n        (float)1.0,(float)0.9,(float)0.8};\n    const float sampEn_win[5]={(float)1.0/(float)6.0,\n        (float)2.0/(float)6.0, (float)3.0/(float)6.0,\n        (float)4.0/(float)6.0, (float)5.0/(float)6.0};",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* init the front and back energies to zero */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(fssqEn, 0, NSUB_MAX*sizeof(float));\nmemset(bssqEn, 0, NSUB_MAX*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Calculate front of first seqence */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "n=0;\npp=residual;\nfor (l=0; l<5; l++) {\n    fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);\n    pp++;\n}\nfor (l=5; l<SUBL; l++) {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    fssqEn[n] += (*pp) * (*pp);\n    pp++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Calculate front and back of all middle sequences */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (n=1; n<iLBCenc_inst->nsub-1; n++) {\n    pp=residual+n*SUBL;\n    for (l=0; l<5; l++) {\n        fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);\n        bssqEn[n] += (*pp) * (*pp);\n        pp++;\n    }\n    for (l=5; l<SUBL-5; l++) {\n        fssqEn[n] += (*pp) * (*pp);\n        bssqEn[n] += (*pp) * (*pp);\n        pp++;\n    }\n    for (l=SUBL-5; l<SUBL; l++) {\n        fssqEn[n] += (*pp) * (*pp);\n        bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);\n        pp++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Calculate back of last seqence */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "n=iLBCenc_inst->nsub-1;\npp=residual+n*SUBL;\nfor (l=0; l<SUBL-5; l++) {\n    bssqEn[n] += (*pp) * (*pp);\n    pp++;\n}\nfor (l=SUBL-5; l<SUBL; l++) {\n    bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);\n    pp++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* find the index to the weighted 80 sample with\n   most energy */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==20) l=1;\nelse                        l=0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];\nmax_ssqEn_n=1;\nfor (n=2; n<iLBCenc_inst->nsub; n++) {",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    l++;\n    if ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] > max_ssqEn) {\n        max_ssqEn=(fssqEn[n-1]+bssqEn[n]) *\n                        ssqEn_win[l];\n        max_ssqEn_n=n;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return max_ssqEn_n; }",
      "ja": "max_ssqEn_nを返します。 }"
    },
    {
      "indent": 0,
      "text": "A.21. gainquant.h",
      "ja": "A.21。 gainquant.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "gainquant.h",
      "ja": "gainquant.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_GAINQUANT_H #define __iLBC_GAINQUANT_H",
      "ja": "#ifndefの__iLBC_GAINQUANT_Hの#define __iLBC_GAINQUANT_H"
    },
    {
      "indent": 3,
      "text": "float gainquant(/* (o) quantized gain value */\n    float in,       /* (i) gain value */\n    float maxIn,/* (i) maximum of gain value */\n    int cblen,      /* (i) number of quantization indices */\n    int *index      /* (o) quantization index */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float gaindequant(  /* (o) quantized gain value */\n    int index,      /* (i) quantization index */\n    float maxIn,/* (i) maximum of unquantized gain */\n    int cblen       /* (i) number of quantization indices */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.22. gainquant.c",
      "ja": "A.22。 gainquant.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code gainquant.c",
      "ja": "iLBCのスピーチコーダANSI-Cソースコードgainquant.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <string.h> #include <math.h> #include \"constants.h\" #include \"filter.h\"",
      "ja": "書式#include <string.hの>書式#include <math.h>の書式#include \"constants.h\" の#include \"filter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  quantizer for the gain in the gain-shape coding of residual\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float gainquant(/* (o) quantized gain value */\n    float in,       /* (i) gain value */\n    float maxIn,/* (i) maximum of gain value */\n    int cblen,      /* (i) number of quantization indices */\n    int *index      /* (o) quantization index */\n){\n    int i, tindex;\n    float minmeasure,measure, *cb, scale;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* ensure a lower bound on the scaling factor */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "scale=maxIn;",
      "ja": "規模=マックスの。"
    },
    {
      "indent": 7,
      "text": "if (scale<0.1) { scale=(float)0.1; }",
      "ja": "IF（スケール<0.1）{尺度=（FLOAT）0.1。 }"
    },
    {
      "indent": 7,
      "text": "/* select the quantization table */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (cblen == 8) {\n    cb = gain_sq3Tbl;\n} else if (cblen == 16) {\n    cb = gain_sq4Tbl;\n} else  {\n    cb = gain_sq5Tbl;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* select the best index in the quantization table */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "minmeasure=10000000.0;\ntindex=0;\nfor (i=0; i<cblen; i++) {",
      "raw": true
    },
    {
      "indent": 11,
      "text": "measure=(in-scale*cb[i])*(in-scale*cb[i]);",
      "ja": "尺度=（中規模*のCB [I]）*（中規模*のCB [I]）。"
    },
    {
      "indent": 7,
      "text": "    if (measure<minmeasure) {\n        tindex=i;\n        minmeasure=measure;\n    }\n}\n*index=tindex;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* return the quantized value */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return scale*cb[tindex]; }",
      "ja": "リターンスケール*のCB [tindex]。 }"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  decoder for quantized gains in the gain-shape coding of\n *  residual\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "float gaindequant(  /* (o) quantized gain value */\n    int index,      /* (i) quantization index */\n    float maxIn,/* (i) maximum of unquantized gain */\n    int cblen       /* (i) number of quantization indices */\n){\n    float scale;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* obtain correct scale factor */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "scale=(float)fabs(maxIn);",
      "ja": "尺度=（FLOAT）ファブ（MAXIN）。"
    },
    {
      "indent": 7,
      "text": "if (scale<0.1) { scale=(float)0.1; }",
      "ja": "IF（スケール<0.1）{尺度=（FLOAT）0.1。 }"
    },
    {
      "indent": 7,
      "text": "/* select the quantization table and return the decoded value */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (cblen==8) {\n    return scale*gain_sq3Tbl[index];\n} else if (cblen==16) {\n    return scale*gain_sq4Tbl[index];\n}\nelse if (cblen==32) {\n    return scale*gain_sq5Tbl[index];\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0.0; }",
      "ja": "0.0を返します。 }"
    },
    {
      "indent": 0,
      "text": "A.23. getCBvec.h",
      "ja": "A.23。 getCBvec.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "getCBvec.h",
      "ja": "getCBvec.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_GETCBVEC_H #define __iLBC_GETCBVEC_H",
      "ja": "#ifndefの__iLBC_GETCBVEC_Hの#define __iLBC_GETCBVEC_H"
    },
    {
      "indent": 3,
      "text": "void getCBvec(\n    float *cbvec,   /* (o) Constructed codebook vector */\n    float *mem,     /* (i) Codebook buffer */\n    int index,      /* (i) Codebook index */\n    int lMem,       /* (i) Length of codebook buffer */\n    int cbveclen/* (i) Codebook vector length */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.24. getCBvec.c",
      "ja": "A.24。 getCBvec.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "getCBvec.c",
      "ja": "getCBvec.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include <string.h>",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\" の#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct codebook vector for given index.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void getCBvec(",
      "ja": "無効getCBvec（"
    },
    {
      "indent": 3,
      "text": "    float *cbvec,   /* (o) Constructed codebook vector */\n    float *mem,     /* (i) Codebook buffer */\n    int index,      /* (i) Codebook index */\n    int lMem,       /* (i) Length of codebook buffer */\n    int cbveclen/* (i) Codebook vector length */\n){\n    int j, k, n, memInd, sFilt;\n    float tmpbuf[CB_MEML];\n    int base_size;\n    int ilow, ihigh;\n    float alfa, alfa1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Determine size of codebook sections */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "base_size=lMem-cbveclen+1;",
      "ja": "base_size = LMEM-cbveclen + 1。"
    },
    {
      "indent": 7,
      "text": "if (cbveclen==SUBL) { base_size+=cbveclen/2; }",
      "ja": "IF（cbveclen == SUBL）{base_size + = cbveclen / 2。 }"
    },
    {
      "indent": 7,
      "text": "/* No filter -> First codebook section */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (index<lMem-cbveclen+1) {",
      "ja": "IF（インデックス<LMEM-cbveclen + 1）{"
    },
    {
      "indent": 11,
      "text": "/* first non-interpolated vectors */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "k=index+cbveclen;\n/* get vector */\nmemcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "} else if (index < base_size) {",
      "ja": "}そうであれば（インデックス<base_size）{"
    },
    {
      "indent": 11,
      "text": "k=2*(index-(lMem-cbveclen+1))+cbveclen;",
      "ja": "K = 2 *（index-（LMEM-cbveclen + 1））+ cbveclen。"
    },
    {
      "indent": 11,
      "text": "ihigh=k/2;\nilow=ihigh-5;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Copy first noninterpolated part */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));",
      "ja": "memcpy（cbvec、MEM + LMEM-K / 2、ILOWの*のはsizeof（フロート））。"
    },
    {
      "indent": 11,
      "text": "/* interpolation */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "alfa1=(float)0.2;\nalfa=0.0;\nfor (j=ilow; j<ihigh; j++) {\n    cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+\n        alfa*mem[lMem-k+j];",
      "raw": true
    },
    {
      "indent": 11,
      "text": " alfa+=alfa1; }",
      "ja": "+アルファ=アルファ1。 }"
    },
    {
      "indent": 11,
      "text": "/* Copy second noninterpolated part */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "memcpy(cbvec+ihigh, mem+lMem-k+ihigh, (cbveclen-ihigh)*sizeof(float));",
      "ja": "memcpy（cbvec + IHIGH、MEM + LMEM-K + IHIGH、（cbveclen-IHIGH）*はsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* Higher codebook section based on filtering */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "else {",
      "ja": "他の{"
    },
    {
      "indent": 11,
      "text": "/* first non-interpolated vectors */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (index-base_size<lMem-cbveclen+1) {\n    float tempbuff2[CB_MEML+CB_FILTERLEN+1];\n    float *pos;\n    float *pp, *pp1;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memset(tempbuff2, 0,\n    CB_HALFFILTERLEN*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN], mem,\n    lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 15,
      "text": "k=index-base_size+cbveclen;\nsFilt=lMem-k;\nmemInd=sFilt+1-CB_HALFFILTERLEN;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    /* do filtering */\n    pos=cbvec;\n    memset(pos, 0, cbveclen*sizeof(float));\n    for (n=0; n<cbveclen; n++) {\n        pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN];\n        pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n        for (j=0; j<CB_FILTERLEN; j++) {\n            (*pos)+=(*pp++)*(*pp1--);\n        }\n        pos++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* interpolated vectors */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "else {",
      "ja": "他の{"
    },
    {
      "indent": 15,
      "text": "float tempbuff2[CB_MEML+CB_FILTERLEN+1];",
      "ja": "フロートtempbuff2 [CB_MEML + CB_FILTERLEN + 1]。"
    },
    {
      "indent": 15,
      "text": "float *pos;\nfloat *pp, *pp1;\nint i;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memset(tempbuff2, 0,\n    CB_HALFFILTERLEN*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN], mem,\n    lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 15,
      "text": "k=2*(index-base_size-\n    (lMem-cbveclen+1))+cbveclen;\nsFilt=lMem-k;\nmemInd=sFilt+1-CB_HALFFILTERLEN;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* do filtering */\npos=&tmpbuf[sFilt];\nmemset(pos, 0, k*sizeof(float));\nfor (i=0; i<k; i++) {\n    pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN];\n    pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n    for (j=0; j<CB_FILTERLEN; j++) {\n        (*pos)+=(*pp++)*(*pp1--);\n    }\n    pos++;\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "ihigh=k/2;\nilow=ihigh-5;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* Copy first noninterpolated part */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "memcpy(cbvec, tmpbuf+lMem-k/2, ilow*sizeof(float));",
      "ja": "memcpy（cbvec、tmpbuf + LMEM-K / 2、ILOWの*のはsizeof（フロート））。"
    },
    {
      "indent": 15,
      "text": "/* interpolation */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "alfa1=(float)0.2;\nalfa=0.0;\nfor (j=ilow; j<ihigh; j++) {\n    cbvec[j]=((float)1.0-alfa)*\n        tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];\n    alfa+=alfa1;\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* Copy second noninterpolated part */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh, (cbveclen-ihigh)*sizeof(float)); } } }",
      "ja": "memcpy（cbvec + IHIGH、tmpbuf + LMEM-K + IHIGH、（cbveclen-IHIGH）*はsizeof（フロート））。 }}}"
    },
    {
      "indent": 0,
      "text": "A.25. helpfun.h",
      "ja": "A.25。 helpfun.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "helpfun.h",
      "ja": "helpfun.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HELPFUN_H #define __iLBC_HELPFUN_H",
      "ja": "#ifndefの__iLBC_HELPFUN_Hの#define __iLBC_HELPFUN_H"
    },
    {
      "indent": 3,
      "text": "void autocorr(\n    float *r,       /* (o) autocorrelation vector */\n    const float *x, /* (i) data vector */\n    int N,          /* (i) length of data vector */\n    int order       /* largest lag for calculated\n                       autocorrelations */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void window(\n    float *z,       /* (o) the windowed data */\n    const float *x, /* (i) the original data vector */\n    const float *y, /* (i) the window */\n    int N           /* (i) length of all vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void levdurb(\n    float *a,       /* (o) lpc coefficient vector starting\n                           with 1.0 */\n    float *k,       /* (o) reflection coefficients */\n    float *r,       /* (i) autocorrelation vector */\n    int order       /* (i) order of lpc filter */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void interpolate(",
      "ja": "空補間（"
    },
    {
      "indent": 3,
      "text": "    float *out,     /* (o) the interpolated vector */\n    float *in1,     /* (i) the first vector for the\n                           interpolation */\n    float *in2,     /* (i) the second vector for the\n                           interpolation */\n    float coef,     /* (i) interpolation weights */\n    int length      /* (i) length of all vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void bwexpand(\n    float *out,     /* (o) the bandwidth expanded lpc\n                           coefficients */\n    float *in,      /* (i) the lpc coefficients before bandwidth\n                           expansion */\n    float coef,     /* (i) the bandwidth expansion factor */\n    int length      /* (i) the length of lpc coefficient vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void vq(\n    float *Xq,      /* (o) the quantized vector */\n    int *index,     /* (o) the quantization index */\n    const float *CB,/* (i) the vector quantization codebook */\n    float *X,       /* (i) the vector to quantize */\n    int n_cb,       /* (i) the number of vectors in the codebook */\n    int dim         /* (i) the dimension of all vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SplitVQ(\n    float *qX,      /* (o) the quantized vector */\n    int *index,     /* (o) a vector of indexes for all vector\n                           codebooks in the split */\n    float *X,       /* (i) the vector to quantize */\n    const float *CB,/* (i) the quantizer codebook */\n    int nsplit,     /* the number of vector splits */\n    const int *dim, /* the dimension of X and qX */\n    const int *cbsize /* the number of vectors in the codebook */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void sort_sq(\n    float *xq,      /* (o) the quantized value */\n    int *index,     /* (o) the quantization index */\n    float x,    /* (i) the value to quantize */\n    const float *cb,/* (i) the quantization codebook */\n    int cb_size     /* (i) the size of the quantization codebook */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int LSF_check(      /* (o) 1 for stable lsf vectors and 0 for",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                           nonstable ones */\n    float *lsf,     /* (i) a table of lsf vectors */\n    int dim,    /* (i) the dimension of each lsf vector */\n    int NoAn    /* (i) the number of lsf vectors in the\n                           table */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.26. helpfun.c",
      "ja": "A.26。 helpfun.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "helpfun.c",
      "ja": "helpfun.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "ja": "書式#include <math.h>の"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  calculation of auto correlation\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void autocorr(\n    float *r,       /* (o) autocorrelation vector */\n    const float *x, /* (i) data vector */\n    int N,          /* (i) length of data vector */\n    int order       /* largest lag for calculated\n                       autocorrelations */\n){\n    int     lag, n;\n    float   sum;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (lag = 0; lag <= order; lag++) {\n    sum = 0;\n    for (n = 0; n < N - lag; n++) {\n        sum += x[n] * x[n+lag];\n    }\n    r[lag] = sum;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  window multiplication\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void window(\n    float *z,       /* (o) the windowed data */\n    const float *x, /* (i) the original data vector */\n    const float *y, /* (i) the window */\n    int N           /* (i) length of all vectors */\n){\n    int     i;",
      "raw": true
    },
    {
      "indent": 3,
      "text": " for (i = 0; i < N; i++) { z[i] = x[i] * y[i]; } }",
      "ja": "用（i = 0; iがN <、iは++）{Z [I] = Xの[I] * Y [i]は、 }}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  levinson-durbin solution for lpc coefficients\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void levdurb(\n    float *a,       /* (o) lpc coefficient vector starting\n                           with 1.0 */\n    float *k,       /* (o) reflection coefficients */\n    float *r,       /* (i) autocorrelation vector */\n    int order       /* (i) order of lpc filter */\n){\n    float  sum, alpha;\n    int     m, m_h, i;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "a[0] = 1.0;",
      "ja": "[0] = 1.0。"
    },
    {
      "indent": 3,
      "text": "    if (r[0] < EPS) { /* if r[0] <= 0, set LPC coeff. to zero */\n        for (i = 0; i < order; i++) {\n            k[i] = 0;\n            a[i+1] = 0;\n        }\n    } else {\n        a[1] = k[0] = -r[1]/r[0];\n        alpha = r[0] + r[1] * k[0];\n        for (m = 1; m < order; m++){\n            sum = r[m + 1];\n            for (i = 0; i < m; i++){\n                sum += a[i+1] * r[m - i];\n            } k[m] = -sum / alpha;\n            alpha += k[m] * sum;\n            m_h = (m + 1) >> 1;\n            for (i = 0; i < m_h; i++){\n                sum = a[i+1] + k[m] * a[m - i];\n                a[m - i] += k[m] * a[i+1];\n                a[i+1] = sum;\n            }\n            a[m+1] = k[m];\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  interpolation between vectors\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void interpolate(\n    float *out,      /* (o) the interpolated vector */\n    float *in1,     /* (i) the first vector for the\n                           interpolation */\n    float *in2,     /* (i) the second vector for the\n                           interpolation */\n    float coef,      /* (i) interpolation weights */\n    int length      /* (i) length of all vectors */\n){\n    int i;\n    float invcoef;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    invcoef = (float)1.0 - coef;\n    for (i = 0; i < length; i++) {\n        out[i] = coef * in1[i] + invcoef * in2[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc bandwidth expansion\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void bwexpand(\n    float *out,      /* (o) the bandwidth expanded lpc\n                           coefficients */\n    float *in,      /* (i) the lpc coefficients before bandwidth\n                           expansion */\n    float coef,     /* (i) the bandwidth expansion factor */\n    int length      /* (i) the length of lpc coefficient vectors */\n){\n    int i;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "float chirp;",
      "ja": "フロートチャープ。"
    },
    {
      "indent": 7,
      "text": "chirp = coef;",
      "ja": "チャープ= COEF。"
    },
    {
      "indent": 3,
      "text": "    out[0] = in[0];\n    for (i = 1; i < length; i++) {\n        out[i] = chirp * in[i];\n        chirp *= coef;\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  vector quantization\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void vq(\n    float *Xq,      /* (o) the quantized vector */\n    int *index,     /* (o) the quantization index */\n    const float *CB,/* (i) the vector quantization codebook */\n    float *X,       /* (i) the vector to quantize */\n    int n_cb,       /* (i) the number of vectors in the codebook */\n    int dim         /* (i) the dimension of all vectors */\n){\n    int     i, j;\n    int     pos, minindex;\n    float   dist, tmp, mindist;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pos = 0;\nmindist = FLOAT_MAX;\nminindex = 0;\nfor (j = 0; j < n_cb; j++) {\n    dist = X[0] - CB[pos];\n    dist *= dist;\n    for (i = 1; i < dim; i++) {\n        tmp = X[i] - CB[pos + i];\n        dist += tmp*tmp;\n    }",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if (dist < mindist) {\n        mindist = dist;\n        minindex = j;\n    }\n    pos += dim;\n}\nfor (i = 0; i < dim; i++) {\n    Xq[i] = CB[minindex*dim + i];\n}\n*index = minindex;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  split vector quantization\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SplitVQ(\n    float *qX,      /* (o) the quantized vector */\n    int *index,     /* (o) a vector of indexes for all vector\n                           codebooks in the split */\n    float *X,       /* (i) the vector to quantize */\n    const float *CB,/* (i) the quantizer codebook */\n    int nsplit,     /* the number of vector splits */\n    const int *dim, /* the dimension of X and qX */\n    const int *cbsize /* the number of vectors in the codebook */\n){\n    int    cb_pos, X_pos, i;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    cb_pos = 0;\n    X_pos= 0;\n    for (i = 0; i < nsplit; i++) {\n        vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,\n            cbsize[i], dim[i]);\n        X_pos += dim[i];\n        cb_pos += dim[i] * cbsize[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  scalar quantization\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void sort_sq(\n    float *xq,      /* (o) the quantized value */\n    int *index,     /* (o) the quantization index */\n    float x,    /* (i) the value to quantize */\n    const float *cb,/* (i) the quantization codebook */\n    int cb_size      /* (i) the size of the quantization codebook */\n){\n    int i;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (x <= cb[0]) {\n    *index = 0;\n    *xq = cb[0];\n} else {\n    i = 0;\n    while ((x > cb[i]) && i < cb_size - 1) {\n        i++;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "        if (x > ((cb[i] + cb[i - 1])/2)) {\n            *index = i;\n            *xq = cb[i];\n        } else {\n            *index = i - 1;\n            *xq = cb[i - 1];\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  check for stability of lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for\n                           nonstable ones */\n    float *lsf,     /* (i) a table of lsf vectors */\n    int dim,    /* (i) the dimension of each lsf vector */\n    int NoAn    /* (i) the number of lsf vectors in the\n                           table */\n){\n    int k,n,m, Nit=2, change=0,pos;\n    float tmp;\n    static float eps=(float)0.039; /* 50 Hz */\n    static float eps2=(float)0.0195;\n    static float maxlsf=(float)3.14; /* 4000 Hz */\n    static float minlsf=(float)0.01; /* 0 Hz */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* LSF separation check*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (n=0; n<Nit; n++) { /* Run through a couple of times */\n    for (m=0; m<NoAn; m++) { /* Number of analyses per frame */\n        for (k=0; k<(dim-1); k++) {\n            pos=m*dim+k;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "if ((lsf[pos+1]-lsf[pos])<eps) {",
      "ja": "IF（（LSF [POS + 1] -lsf [POS]）<EPS）{"
    },
    {
      "indent": 23,
      "text": "if (lsf[pos+1]<lsf[pos]) {\n    tmp=lsf[pos+1];\n    lsf[pos+1]= lsf[pos]+eps2;\n    lsf[pos]= lsf[pos+1]-eps2;\n} else {\n    lsf[pos]-=eps2;\n    lsf[pos+1]+=eps2;\n}\nchange=1;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 19,
      "text": "if (lsf[pos]<minlsf) {\n    lsf[pos]=minlsf;\n    change=1;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "            if (lsf[pos]>maxlsf) {\n                lsf[pos]=maxlsf;\n                change=1;\n            }\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return change; }",
      "ja": "変更を返します。 }"
    },
    {
      "indent": 0,
      "text": "A.27. hpInput.h",
      "ja": "A.27。 hpInput.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "hpInput.h",
      "ja": "hpInput.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HPINPUT_H #define __iLBC_HPINPUT_H",
      "ja": "#ifndefの__iLBC_HPINPUT_Hの#define __iLBC_HPINPUT_H"
    },
    {
      "indent": 3,
      "text": "void hpInput(\n    float *In,  /* (i) vector to filter */\n    int len,    /* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.28. hpInput.c",
      "ja": "A.28。 hpInput.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code hpInput.c",
      "ja": "iLBCのスピーチコーダANSI-CソースコードhpInput.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"constants.h\"",
      "ja": "#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Input high-pass filter\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void hpInput(\n    float *In,  /* (i) vector to filter */\n    int len,    /* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n){\n    int i;\n    float *pi, *po;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* all-zero section*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pi = &In[0];\npo = &Out[0];\nfor (i=0; i<len; i++) {\n    *po = hpi_zero_coefsTbl[0] * (*pi);\n    *po += hpi_zero_coefsTbl[1] * mem[0];\n    *po += hpi_zero_coefsTbl[2] * mem[1];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "mem[1] = mem[0];\nmem[0] = *pi;\npo++;\npi++;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* all-pole section*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "po = &Out[0];\nfor (i=0; i<len; i++) {\n    *po -= hpi_pole_coefsTbl[1] * mem[2];\n    *po -= hpi_pole_coefsTbl[2] * mem[3];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "mem[3] = mem[2];\nmem[2] = *po;\npo++;",
      "raw": true
    },
    {
      "indent": 3,
      "text": " } }",
      "ja": "｝ ｝"
    },
    {
      "indent": 0,
      "text": "A.29. hpOutput.h",
      "ja": "A.29。 hpOutput.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "hpOutput.h",
      "ja": "hpOutput.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HPOUTPUT_H #define __iLBC_HPOUTPUT_H",
      "ja": "#ifndefの__iLBC_HPOUTPUT_Hの#define __iLBC_HPOUTPUT_H"
    },
    {
      "indent": 3,
      "text": "void hpOutput(\n    float *In,  /* (i) vector to filter */\n    int len,/* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.30. hpOutput.c",
      "ja": "A.30。 hpOutput.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "hpOutput.c",
      "ja": "hpOutput.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"constants.h\"",
      "ja": "#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Output high-pass filter\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void hpOutput(",
      "ja": "無効hpOutput（"
    },
    {
      "indent": 3,
      "text": "    float *In,  /* (i) vector to filter */\n    int len,/* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n){\n    int i;\n    float *pi, *po;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* all-zero section*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pi = &In[0];\npo = &Out[0];\nfor (i=0; i<len; i++) {\n    *po = hpo_zero_coefsTbl[0] * (*pi);\n    *po += hpo_zero_coefsTbl[1] * mem[0];\n    *po += hpo_zero_coefsTbl[2] * mem[1];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "mem[1] = mem[0];\nmem[0] = *pi;\npo++;\npi++;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 7,
      "text": "/* all-pole section*/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "po = &Out[0];\nfor (i=0; i<len; i++) {\n    *po -= hpo_pole_coefsTbl[1] * mem[2];\n    *po -= hpo_pole_coefsTbl[2] * mem[3];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        mem[3] = mem[2];\n        mem[2] = *po;\n        po++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.31. iCBConstruct.h",
      "ja": "A.31。 iCBConstruct.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iCBConstruct.h",
      "ja": "iCBConstruct.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ICBCONSTRUCT_H #define __iLBC_ICBCONSTRUCT_H",
      "ja": "#ifndefの__iLBC_ICBCONSTRUCT_Hの#define __iLBC_ICBCONSTRUCT_H"
    },
    {
      "indent": 3,
      "text": "void index_conv_enc(\n    int *index          /* (i/o) Codebook indexes */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void index_conv_dec(\n    int *index          /* (i/o) Codebook indexes */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iCBConstruct(\n    float *decvector,   /* (o) Decoded vector */\n    int *index,         /* (i) Codebook indices */\n    int *gain_index,/* (i) Gain quantization indices */\n    float *mem,         /* (i) Buffer for codevector construction */\n    int lMem,           /* (i) Length of buffer */\n    int veclen,         /* (i) Length of vector */\n    int nStages         /* (i) Number of codebook stages */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.32. iCBConstruct.c",
      "ja": "A.32。 iCBConstruct.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iCBConstruct.c",
      "ja": "iCBConstruct.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "ja": "書式#include <math.h>の"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"getCBvec.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"gainquant.h\" の#include \"getCBvec.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Convert the codebook indexes to make the search easier\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void index_conv_enc(\n    int *index          /* (i/o) Codebook indexes */\n){\n    int k;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (k=1; k<CB_NSTAGES; k++) {",
      "ja": "（; K <CB_NSTAGESあり、k ++ K = 1）{用"
    },
    {
      "indent": 3,
      "text": "        if ((index[k]>=108)&&(index[k]<172)) {\n            index[k]-=64;\n        } else if (index[k]>=236) {\n            index[k]-=128;\n        } else {\n            /* ERROR */\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void index_conv_dec(\n    int *index          /* (i/o) Codebook indexes */\n){\n    int k;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (k=1; k<CB_NSTAGES; k++) {",
      "ja": "（; K <CB_NSTAGESあり、k ++ K = 1）{用"
    },
    {
      "indent": 3,
      "text": "        if ((index[k]>=44)&&(index[k]<108)) {\n            index[k]+=64;\n        } else if ((index[k]>=108)&&(index[k]<128)) {\n            index[k]+=128;\n        } else {\n            /* ERROR */\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct decoded vector from codebook and gains.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iCBConstruct(\n    float *decvector,   /* (o) Decoded vector */\n    int *index,         /* (i) Codebook indices */\n    int *gain_index,/* (i) Gain quantization indices */\n    float *mem,         /* (i) Buffer for codevector construction */\n    int lMem,           /* (i) Length of buffer */\n    int veclen,         /* (i) Length of vector */\n    int nStages         /* (i) Number of codebook stages */\n){\n    int j,k;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "float gain[CB_NSTAGES];\nfloat cbvec[SUBL];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* gain de-quantization */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "gain[0] = gaindequant(gain_index[0], 1.0, 32);\nif (nStages > 1) {\n    gain[1] = gaindequant(gain_index[1],\n        (float)fabs(gain[0]), 16);\n}\nif (nStages > 2) {\n    gain[2] = gaindequant(gain_index[2],\n        (float)fabs(gain[1]), 8);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* codebook vector construction and construction of\ntotal vector */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    getCBvec(cbvec, mem, index[0], lMem, veclen);\n    for (j=0;j<veclen;j++){\n        decvector[j] = gain[0]*cbvec[j];\n    }\n    if (nStages > 1) {\n        for (k=1; k<nStages; k++) {\n            getCBvec(cbvec, mem, index[k], lMem, veclen);\n            for (j=0;j<veclen;j++) {\n                decvector[j] += gain[k]*cbvec[j];\n            }\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.33. iCBSearch.h",
      "ja": "A.33。 iCBSearch.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iCBSearch.h",
      "ja": "iCBSearch.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ICBSEARCH_H\n#define __iLBC_ICBSEARCH_H void iCBSearch(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) the encoder state structure */\n    int *index,         /* (o) Codebook indices */\n    int *gain_index,/* (o) Gain quantization indices */\n    float *intarget,/* (i) Target vector for encoding */\n    float *mem,         /* (i) Buffer for codebook construction */\n    int lMem,           /* (i) Length of buffer */\n    int lTarget,    /* (i) Length of vector */\n    int nStages,    /* (i) Number of codebook stages */\n    float *weightDenum, /* (i) weighting filter coefficients */\n    float *weightState, /* (i) weighting filter state */\n    int block           /* (i) the sub-block number */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.34. iCBSearch.c",
      "ja": "A.34。 iCBSearch.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "iCBSearch.c",
      "ja": "iCBSearch.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h>",
      "ja": "書式#include <math.h>の書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"createCB.h\" #include \"filter.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"gainquant.h\" の#include \"createCB.h\" の#include \"filter.h\" の#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Search routine for codebook encoding and gain quantization.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void iCBSearch(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) the encoder state structure */\n    int *index,         /* (o) Codebook indices */\n    int *gain_index,/* (o) Gain quantization indices */ float *intarget,/* (i) Target vector for encoding */\n    float *mem,         /* (i) Buffer for codebook construction */\n    int lMem,           /* (i) Length of buffer */\n    int lTarget,    /* (i) Length of vector */\n    int nStages,    /* (i) Number of codebook stages */\n    float *weightDenum, /* (i) weighting filter coefficients */\n    float *weightState, /* (i) weighting filter state */\n    int block           /* (i) the sub-block number */\n){\n    int i, j, icount, stage, best_index, range, counter;\n    float max_measure, gain, measure, crossDot, ftmp;\n    float gains[CB_NSTAGES];\n    float target[SUBL];\n    int base_index, sInd, eInd, base_size;\n    int sIndAug=0, eIndAug=0;\n    float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];\n    float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];\n    float *pp, *ppi=0, *ppo=0, *ppe=0;\n    float cbvectors[CB_MEML];\n    float tene, cene, cvec[SUBL];\n    float aug_vec[SUBL];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(cvec,0,SUBL*sizeof(float));",
      "ja": "memsetの（cvec、0、SUBLの*のはsizeof（フロート））;"
    },
    {
      "indent": 7,
      "text": "/* Determine size of codebook sections */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "base_size=lMem-lTarget+1;",
      "ja": "base_size = LMEM-Ltargetに+ 1。"
    },
    {
      "indent": 7,
      "text": "if (lTarget==SUBL) { base_size=lMem-lTarget+1+lTarget/2; }",
      "ja": "（Ltargetに== SUBL）であれば{base_size = LMEM-Ltargetに+ 1 + Ltargetに/ 2。 }"
    },
    {
      "indent": 7,
      "text": "/* setup buffer for weighting */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);\nmemcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));\nmemcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* weighting */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "AllPoleFilter(buf+LPC_FILTERORDER, weightDenum, lMem+lTarget, LPC_FILTERORDER);",
      "ja": "AllPoleFilter（BUF + LPC_FILTERORDER、weightDenum、LMEM + Ltargetに、LPC_FILTERORDER）。"
    },
    {
      "indent": 7,
      "text": "/* Construct the codebook and target needed */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));",
      "ja": "memcpy（ターゲット、BUF + LPC_FILTERORDER + LMEM、Ltargetに*はsizeof（フロート））。"
    },
    {
      "indent": 7,
      "text": "tene=0.0;",
      "ja": "A = 0.0。"
    },
    {
      "indent": 7,
      "text": "for (i=0; i<lTarget; i++) { tene+=target[i]*target[i]; }",
      "ja": "用（i = 0; iは<Ltargetに、iは++）{tene + =目標[I] *ターゲット[I]。 }"
    },
    {
      "indent": 7,
      "text": "/* Prepare search over one more codebook section. This section\n   is created by filtering the original buffer with a filter. */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);",
      "ja": "filteredCBvecs（cbvectors、BUF + LPC_FILTERORDER、LMEM）。"
    },
    {
      "indent": 7,
      "text": "/* The Main Loop over stages */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (stage=0; stage<nStages; stage++) {",
      "ja": "用（ステージ0、ステージ<nStages;ステージ++）{"
    },
    {
      "indent": 11,
      "text": "range = search_rangeTbl[block][stage];",
      "ja": "範囲= search_rangeTbl [ブロック] [段階]。"
    },
    {
      "indent": 11,
      "text": "/* initialize search measure */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "max_measure = (float)-10000000.0;\ngain = (float)0.0;\nbest_index = 0;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Compute cross dot product between the target\n   and the CB memory */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "crossDot=0.0;\npp=buf+LPC_FILTERORDER+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (stage==0) {",
      "ja": "IF（ステージ== 0）{"
    },
    {
      "indent": 15,
      "text": "/* Calculate energy in the first block of\n  'lTarget' samples. */\nppe = energy;\nppi = buf+LPC_FILTERORDER+lMem-lTarget-1;\nppo = buf+LPC_FILTERORDER+lMem-1;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "*ppe=0.0;\npp=buf+LPC_FILTERORDER+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    *ppe+=(*pp)*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (*ppe>0.0) {\n    invenergy[0] = (float) 1.0 / (*ppe + EPS);\n} else {\n    invenergy[0] = (float) 0.0;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "} ppe++;",
      "ja": "PE} ++;"
    },
    {
      "indent": 15,
      "text": "measure=(float)-10000000.0;",
      "ja": "=（FLOAT）-10000000.0を測定します。"
    },
    {
      "indent": 11,
      "text": "    if (crossDot > 0.0) {\n           measure = crossDot*crossDot*invenergy[0];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[0];\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[0];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n    best_index = 0;\n    max_measure = measure;\n    gain = ftmp;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over the main first codebook section,\n   full search */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (icount=1; icount<range; icount++) {",
      "ja": "（ICOUNT = 1; ICOUNT <範囲; ICOUNT ++）のために{"
    },
    {
      "indent": 15,
      "text": "/* calculate measure */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "crossDot=0.0;\npp = buf+LPC_FILTERORDER+lMem-lTarget-icount;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "for (j=0; j<lTarget; j++) { crossDot += target[j]*(*pp++); }",
      "ja": "用（J = 0; J <Ltargetにあり、j ++）{crossDot + =目標[J] *（* PP ++）。 }"
    },
    {
      "indent": 15,
      "text": "if (stage==0) {\n    *ppe++ = energy[icount-1] + (*ppi)*(*ppi) -\n        (*ppo)*(*ppo);\n    ppo--;\n    ppi--;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "if (energy[icount]>0.0) {\n    invenergy[icount] =\n        (float)1.0/(energy[icount]+EPS);\n} else {\n    invenergy[icount] = (float) 0.0;\n} measure=(float)-10000000.0;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*invenergy[icount];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[icount];\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[icount];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n        best_index = icount;\n        max_measure = measure;\n        gain = ftmp;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Loop over augmented part in the first codebook\n * section, full search.\n * The vectors are interpolated.\n */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (lTarget==SUBL) {",
      "ja": "IF（Ltargetに== SUBL）{"
    },
    {
      "indent": 11,
      "text": "    /* Search for best possible cb vector and\n       compute the CB-vectors' energy. */\n    searchAugmentedCB(20, 39, stage, base_size-lTarget/2,\n        target, buf+LPC_FILTERORDER+lMem,\n        &max_measure, &best_index, &gain, energy,\n        invenergy);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* set search range for following codebook sections */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "base_index=best_index;",
      "ja": "base_index = best_index。"
    },
    {
      "indent": 11,
      "text": "/* unrestricted search */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (CB_RESRANGE == -1) {\n    sInd=0;\n    eInd=range-1;\n    sIndAug=20;\n    eIndAug=39;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* restricted search around best index from first\ncodebook section */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "else {\n    /* Initialize search indices */\n    sIndAug=0;\n    eIndAug=0;\n    sInd=base_index-CB_RESRANGE/2;\n    eInd=sInd+CB_RESRANGE;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (lTarget==SUBL) {",
      "ja": "IF（Ltargetに== SUBL）{"
    },
    {
      "indent": 19,
      "text": "if (sInd<0) {",
      "ja": "IF（れる<0）{"
    },
    {
      "indent": 23,
      "text": "sIndAug = 40 + sInd;\neIndAug = 39;\nsInd=0;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "} else if ( base_index < (base_size-20) ) {",
      "ja": "}そうであれば（base_index <（base_size-20））{"
    },
    {
      "indent": 19,
      "text": "    if (eInd > range) {\n        sInd -= (eInd-range);\n        eInd = range;\n    }\n} else { /* base_index >= (base_size-20) */",
      "raw": true
    },
    {
      "indent": 23,
      "text": "if (sInd < (base_size-20)) {\n    sIndAug = 20;\n    sInd = 0;\n    eInd = 0;\n    eIndAug = 19 + CB_RESRANGE;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "        if(eIndAug > 39) {\n            eInd = eIndAug-39;\n            eIndAug = 39;\n        }\n    } else {\n        sIndAug = 20 + sInd - (base_size-20);\n        eIndAug = 39;\n        sInd = 0;\n        eInd = CB_RESRANGE - (eIndAug-sIndAug+1);\n    }\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "} else { /* lTarget = 22 or 23 */",
      "raw": true
    },
    {
      "indent": 19,
      "text": "if (sInd < 0) {\n    eInd -= sInd;",
      "raw": true
    },
    {
      "indent": 19,
      "text": " sInd = 0; }",
      "ja": "= 0; }"
    },
    {
      "indent": 11,
      "text": "        if(eInd > range) {\n            sInd -= (eInd - range);\n            eInd = range;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* search of higher codebook section */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* index search range */\ncounter = sInd;\nsInd += base_size;\neInd += base_size;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (stage==0) {\n    ppe = energy+base_size;\n    *ppe=0.0;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "pp=cbvectors+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    *ppe+=(*pp)*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "ppi = cbvectors + lMem - 1 - lTarget;\nppo = cbvectors + lMem - 1;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    for (j=0; j<(range-1); j++) {\n        *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);\n        ppo--;\n        ppi--;\n        ppe++;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* loop over search range */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (icount=sInd; icount<eInd; icount++) {",
      "ja": "ログ（ICOUNT =シンド; ICOUNT <END; ICOUNT ++）{"
    },
    {
      "indent": 15,
      "text": "/* calculate measure */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "crossDot=0.0;\npp=cbvectors + lMem - (counter++) - lTarget;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "for (j=0;j<lTarget;j++) {",
      "ja": "用（J = 0; J <Ltargetにあり、j ++）{"
    },
    {
      "indent": 15,
      "text": " crossDot += target[j]*(*pp++); }",
      "ja": "crossDot + =目標[J] *（* PP ++）。 }"
    },
    {
      "indent": 15,
      "text": "if (energy[icount]>0.0) {\n    invenergy[icount] =(float)1.0/(energy[icount]+EPS);\n} else {\n    invenergy[icount] =(float)0.0;\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (stage==0) {",
      "ja": "IF（ステージ== 0）{"
    },
    {
      "indent": 19,
      "text": "measure=(float)-10000000.0;",
      "ja": "=（FLOAT）-10000000.0を測定します。"
    },
    {
      "indent": 15,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*\n            invenergy[icount];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[icount];\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[icount];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n        best_index = icount;\n        max_measure = measure;\n        gain = ftmp;\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Search the augmented CB inside the limited range. */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if ((lTarget==SUBL)&&(sIndAug!=0)) { searchAugmentedCB(sIndAug, eIndAug, stage, 2*base_size-20, target, cbvectors+lMem, &max_measure, &best_index, &gain, energy, invenergy); }",
      "ja": "IF（！（Ltargetに== SUBL）&&（sIndAug = 0））{searchAugmentedCB（sIndAug、eIndAug、ステージ、2 * base_size-20、ターゲット、cbvectors + LMEM、＆max_measure、＆best_index、＆ゲイン、エネルギー、invenergy）。 }"
    },
    {
      "indent": 11,
      "text": "/* record best index */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "index[stage] = best_index;",
      "ja": "索引[段階] = best_index。"
    },
    {
      "indent": 11,
      "text": "/* gain quantization */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (stage==0){",
      "ja": "IF（ステージ== 0）{"
    },
    {
      "indent": 15,
      "text": "if (gain<0.0){\n    gain = 0.0;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    if (gain>CB_MAXGAIN) {\n        gain = (float)CB_MAXGAIN;\n    }\n    gain = gainquant(gain, 1.0, 32, &gain_index[stage]);\n}\nelse {\n    if (stage==1) {\n        gain = gainquant(gain, (float)fabs(gains[stage-1]),\n            16, &gain_index[stage]);\n    } else {\n        gain = gainquant(gain, (float)fabs(gains[stage-1]),\n            8, &gain_index[stage]);\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Extract the best (according to measure)\n   codebook vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (lTarget==(STATE_LEN-iLBCenc_inst->state_short_len)) {",
      "ja": "IF（Ltargetに==（STATE_LEN-iLBCenc_inst-> state_short_len））{"
    },
    {
      "indent": 11,
      "text": "    if (index[stage]<base_size) {\n        pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];\n    } else {\n        pp=cbvectors+lMem-lTarget-\n            index[stage]+base_size;\n    }\n} else {",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (index[stage]<base_size) {\n    if (index[stage]<(base_size-20)) {\n        pp=buf+LPC_FILTERORDER+lMem-\n            lTarget-index[stage];\n    } else {\n        createAugmentedVec(index[stage]-base_size+40,\n                buf+LPC_FILTERORDER+lMem,aug_vec);\n        pp=aug_vec;\n    }\n} else {\n    int filterno, position;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "filterno=index[stage]/base_size;\nposition=index[stage]-filterno*base_size;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "        if (position<(base_size-20)) {\n            pp=cbvectors+filterno*lMem-lTarget-\n                index[stage]+filterno*base_size;\n        } else {\n            createAugmentedVec(\n                index[stage]-(filterno+1)*base_size+40,\n                cbvectors+filterno*lMem,aug_vec);\n            pp=aug_vec;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Subtract the best codebook vector, according\n   to measure, from the target vector */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (j=0;j<lTarget;j++) {\n    cvec[j] += gain*(*pp);\n    target[j] -= gain*(*pp++);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* record quantized gain */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "gains[stage]=gain;",
      "ja": "ゲイン[段階] =ゲイン。"
    },
    {
      "indent": 7,
      "text": "}/* end of Main Loop. for (stage=0;... */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Gain adjustment for energy matching */\ncene=0.0;\nfor (i=0; i<lTarget; i++) {\n    cene+=cvec[i]*cvec[i];\n}\nj=gain_index[0];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=gain_index[0]; i<32; i++) { ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];",
      "ja": "以下のための（I = gain_index [0]; iは32 <; I ++）{ftmp = ceneを* gain_sq5Tbl [I] * gain_sq5Tbl [I]。"
    },
    {
      "indent": 3,
      "text": "        if ((ftmp<(tene*gains[0]*gains[0])) &&\n            (gain_sq5Tbl[j]<(2.0*gains[0]))) {\n            j=i;\n        }\n    }\n    gain_index[0]=j;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.35. LPCdecode.h",
      "ja": "A.35。 LPCdecode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "LPC_decode.h",
      "ja": "LPC_decode.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LPC_DECODE_H #define __iLBC_LPC_DECODE_H",
      "ja": "#ifndefの__iLBC_LPC_DECODE_Hの#define __iLBC_LPC_DECODE_H"
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_dec(\n    float *a,           /* (o) lpc coefficients for a sub-frame */\n    float *lsf1,    /* (i) first lsf coefficient vector */\n    float *lsf2,    /* (i) second lsf coefficient vector */\n    float coef,         /* (i) interpolation weight */\n    int length          /* (i) length of lsf vectors */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SimplelsfDEQ(\n    float *lsfdeq,      /* (o) dequantized lsf coefficients */\n    int *index,         /* (i) quantization index */\n    int lpc_n           /* (i) number of LPCs */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void DecoderInterpolateLSF(\n    float *syntdenum,   /* (o) synthesis filter coefficients */\n    float *weightdenum, /* (o) weighting denumerator\n                               coefficients */\n    float *lsfdeq,      /* (i) dequantized lsf coefficients */\n    int length,         /* (i) length of lsf coefficient vector */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i) the decoder state structure */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.36. LPCdecode.c",
      "ja": "A.36。 LPCdecode.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "LPC_decode.c",
      "ja": "LPC_decode.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h>",
      "ja": "書式#include <math.h>の書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"helpfun.h\" #include \"lsf.h\" #include \"iLBC_define.h\" #include \"constants.h\"",
      "ja": "#include \"helpfun.h\" の#include \"lsf.h\" の#include \"iLBC_define.h\" の#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  interpolation of lsf coefficients for the decoder\n *--------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_dec(\n    float *a,           /* (o) lpc coefficients for a sub-frame */\n    float *lsf1,    /* (i) first lsf coefficient vector */\n    float *lsf2,    /* (i) second lsf coefficient vector */\n    float coef,         /* (i) interpolation weight */\n    int length          /* (i) length of lsf vectors */\n){\n    float  lsftmp[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    interpolate(lsftmp, lsf1, lsf2, coef, length);\n    lsf2a(a, lsftmp);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  obtain dequantized lsf coefficients from quantization index\n *--------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SimplelsfDEQ(\n    float *lsfdeq,    /* (o) dequantized lsf coefficients */\n    int *index,         /* (i) quantization index */\n    int lpc_n           /* (i) number of LPCs */\n){\n    int i, j, pos, cb_pos;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* decode first LSF */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pos = 0;\ncb_pos = 0;\nfor (i = 0; i < LSF_NSPLIT; i++) {\n    for (j = 0; j < dim_lsfCbTbl[i]; j++) {\n        lsfdeq[pos + j] = lsfCbTbl[cb_pos +\n            (long)(index[i])*dim_lsfCbTbl[i] + j];\n    }\n    pos += dim_lsfCbTbl[i];\n    cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (lpc_n>1) {",
      "ja": "IF（lpc_n> 1）{"
    },
    {
      "indent": 11,
      "text": "/* decode last LSF */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        pos = 0;\n        cb_pos = 0;\n        for (i = 0; i < LSF_NSPLIT; i++) {\n            for (j = 0; j < dim_lsfCbTbl[i]; j++) {\n                lsfdeq[LPC_FILTERORDER + pos + j] =\n                    lsfCbTbl[cb_pos +\n                    (long)(index[LSF_NSPLIT + i])*\n                    dim_lsfCbTbl[i] + j];\n            }\n            pos += dim_lsfCbTbl[i];\n            cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  obtain synthesis and weighting filters form lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void DecoderInterpolateLSF(\n    float *syntdenum, /* (o) synthesis filter coefficients */\n    float *weightdenum, /* (o) weighting denumerator\n                               coefficients */\n    float *lsfdeq,       /* (i) dequantized lsf coefficients */\n    int length,         /* (i) length of lsf coefficient vector */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i) the decoder state structure */\n){\n    int    i, pos, lp_length;\n    float  lp[LPC_FILTERORDER + 1], *lsfdeq2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "lsfdeq2 = lsfdeq + length;\nlp_length = length + 1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30) {\n    /* sub-frame 1: Interpolation between old and first */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold, lsfdeq,\n    lsf_weightTbl_30ms[0], length);\nmemcpy(syntdenum,lp,lp_length*sizeof(float));\nbwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,\n    lp_length);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* sub-frames 2 to 6: interpolation between first\n   and last LSF */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    pos = lp_length;\n    for (i = 1; i < 6; i++) {\n        LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,\n            lsf_weightTbl_30ms[i], length);\n        memcpy(syntdenum + pos,lp,lp_length*sizeof(float));\n        bwexpand(weightdenum + pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}\nelse {\n    pos = 0;\n    for (i = 0; i < iLBCdec_inst->nsub; i++) {\n        LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold,\n            lsfdeq, lsf_weightTbl_20ms[i], length);\n        memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n        bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,\n            lp_length);\n        pos += lp_length;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30)\n    memcpy(iLBCdec_inst->lsfdeqold, lsfdeq2,\n                length*sizeof(float));\nelse\n    memcpy(iLBCdec_inst->lsfdeqold, lsfdeq,\n                length*sizeof(float));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "A.37. LPCencode.h",
      "ja": "A.37。 LPCencode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "LPCencode.h",
      "ja": "LPCencode.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LPCENCOD_H #define __iLBC_LPCENCOD_H",
      "ja": "#ifndefの__iLBC_LPCENCOD_Hの#define __iLBC_LPCENCOD_H"
    },
    {
      "indent": 3,
      "text": "void LPCencode(\n    float *syntdenum,   /* (i/o) synthesis filter coefficients\n                               before/after encoding */\n    float *weightdenum, /* (i/o) weighting denumerator coefficients\n                               before/after encoding */\n    int *lsf_index,     /* (o) lsf quantization index */\n    float *data,    /* (i) lsf coefficients to quantize */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.38. LPCencode.c",
      "ja": "A.38。 LPCencode.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "LPCencode.c",
      "ja": "LPCencode.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <string.h>",
      "ja": "書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"helpfun.h\" #include \"lsf.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"helpfun.h\" の#include \"lsf.h\" の#include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc analysis (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SimpleAnalysis(\n    float *lsf,         /* (o) lsf coefficients */\n    float *data,    /* (i) new data vector */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    int k, is;\n    float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];\n    float lp2[LPC_FILTERORDER + 1];\n    float r[LPC_FILTERORDER + 1];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\nmemcpy(iLBCenc_inst->lpc_buffer+is,data,\n    iLBCenc_inst->blockl*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* No lookahead, last window is asymmetric */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (k = 0; k < iLBCenc_inst->lpc_n; k++) {",
      "ja": "以下のために{（K = 0; K <iLBCenc_inst-> lpc_n ++ K）"
    },
    {
      "indent": 11,
      "text": "is = LPC_LOOKBACK;",
      "ja": "= LPC_LOOKBACKです。"
    },
    {
      "indent": 11,
      "text": "if (k < (iLBCenc_inst->lpc_n - 1)) {\n    window(temp, lpc_winTbl,\n        iLBCenc_inst->lpc_buffer, BLOCKL_MAX);\n} else {\n    window(temp, lpc_asymwinTbl,\n        iLBCenc_inst->lpc_buffer + is, BLOCKL_MAX);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);\nwindow(r, r, lpc_lagwinTbl, LPC_FILTERORDER + 1);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "levdurb(lp, temp, r, LPC_FILTERORDER);\nbwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        a2lsf(lsf + k*LPC_FILTERORDER, lp2);\n    }\n    is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\n    memmove(iLBCenc_inst->lpc_buffer,\n        iLBCenc_inst->lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,\n        is*sizeof(float));\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*",
      "raw": true
    },
    {
      "indent": 4,
      "text": "*  lsf interpolator and conversion from lsf to a coefficients\n*  (subrutine to SimpleInterpolateLSF)\n*---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_enc(\n    float *a,       /* (o) lpc coefficients */\n    float *lsf1,/* (i) first set of lsf coefficients */\n    float *lsf2,/* (i) second set of lsf coefficients */\n    float coef,     /* (i) weighting coefficient to use between\n                           lsf1 and lsf2 */\n    long length      /* (i) length of coefficient vectors */\n){\n    float  lsftmp[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    interpolate(lsftmp, lsf1, lsf2, coef, length);\n    lsf2a(a, lsftmp);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lsf interpolator (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SimpleInterpolateLSF(\n    float *syntdenum,   /* (o) the synthesis filter denominator\n                               resulting from the quantized\n                               interpolated lsf */\n    float *weightdenum, /* (o) the weighting filter denominator\n                               resulting from the unquantized\n                               interpolated lsf */\n    float *lsf,         /* (i) the unquantized lsf coefficients */\n    float *lsfdeq,      /* (i) the dequantized lsf coefficients */\n    float *lsfold,      /* (i) the unquantized lsf coefficients of\n                               the previous signal frame */\n    float *lsfdeqold, /* (i) the dequantized lsf coefficients of\n                               the previous signal frame */\n    int length,         /* (i) should equate LPC_FILTERORDER */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    int    i, pos, lp_length;\n    float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "lsf2 = lsf + length;\nlsfdeq2 = lsfdeq + length;\nlp_length = length + 1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==30) {\n    /* sub-frame 1: Interpolation between old and first",
      "raw": true
    },
    {
      "indent": 14,
      "text": "set of lsf coefficients */",
      "ja": "LSF係数のセット* /"
    },
    {
      "indent": 11,
      "text": "LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,\n    lsf_weightTbl_30ms[0], length);\nmemcpy(syntdenum,lp,lp_length*sizeof(float));\nLSFinterpolate2a_enc(lp, lsfold, lsf,\n    lsf_weightTbl_30ms[0], length);\nbwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM, lp_length);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* sub-frame 2 to 6: Interpolation between first\n   and second set of lsf coefficients */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "pos = lp_length;\nfor (i = 1; i < iLBCenc_inst->nsub; i++) {\n    LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,\n        lsf_weightTbl_30ms[i], length);\n    memcpy(syntdenum + pos,lp,lp_length*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "        LSFinterpolate2a_enc(lp, lsf, lsf2,\n            lsf_weightTbl_30ms[i], length);\n        bwexpand(weightdenum + pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}\nelse {\n    pos = 0;\n    for (i = 0; i < iLBCenc_inst->nsub; i++) {\n        LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,\n            lsf_weightTbl_20ms[i], length);\n        memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n        LSFinterpolate2a_enc(lp, lsfold, lsf,\n            lsf_weightTbl_20ms[i], length);\n        bwexpand(weightdenum+pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* update memory */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==30) {\n    memcpy(lsfold, lsf2, length*sizeof(float));\n    memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));\n}\nelse {\n    memcpy(lsfold, lsf, length*sizeof(float));\n    memcpy(lsfdeqold, lsfdeq, length*sizeof(float));",
      "raw": true
    },
    {
      "indent": 3,
      "text": " } }",
      "ja": "｝ ｝"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lsf quantizer (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void SimplelsfQ(\n    float *lsfdeq,    /* (o) dequantized lsf coefficients\n                           (dimension FILTERORDER) */\n    int *index,     /* (o) quantization index */\n    float *lsf,      /* (i) the lsf coefficient vector to be\n                           quantized (dimension FILTERORDER ) */\n    int lpc_n     /* (i) number of lsf sets to quantize */\n){\n    /* Quantize first LSF with memoryless split VQ */\n    SplitVQ(lsfdeq, index, lsf, lsfCbTbl, LSF_NSPLIT,\n        dim_lsfCbTbl, size_lsfCbTbl);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    if (lpc_n==2) {\n        /* Quantize second LSF with memoryless split VQ */\n        SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,\n            lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,\n            dim_lsfCbTbl, size_lsfCbTbl);\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc encoder\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void LPCencode(\n    float *syntdenum, /* (i/o) synthesis filter coefficients\n                               before/after encoding */\n    float *weightdenum, /* (i/o) weighting denumerator\n                               coefficients before/after\n                               encoding */\n    int *lsf_index,     /* (o) lsf quantization index */\n    float *data,    /* (i) lsf coefficients to quantize */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    float lsf[LPC_FILTERORDER * LPC_N_MAX];\n    float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];\n    int change=0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "SimpleAnalysis(lsf, data, iLBCenc_inst);\nSimplelsfQ(lsfdeq, lsf_index, lsf, iLBCenc_inst->lpc_n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst->lpc_n);\n    SimpleInterpolateLSF(syntdenum, weightdenum,\n        lsf, lsfdeq, iLBCenc_inst->lsfold,\n        iLBCenc_inst->lsfdeqold, LPC_FILTERORDER, iLBCenc_inst);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.39. lsf.h",
      "ja": "A.39。 lsf.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "lsf.h",
      "ja": "lsf.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LSF_H #define __iLBC_LSF_H",
      "ja": "#ifndefの__iLBC_LSF_Hの#define __iLBC_LSF_H"
    },
    {
      "indent": 3,
      "text": "void a2lsf(\n    float *freq,/* (o) lsf coefficients */\n    float *a    /* (i) lpc coefficients */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void lsf2a(\n    float *a_coef,  /* (o) lpc coefficients */\n    float *freq     /* (i) lsf coefficients */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.40. lsf.c",
      "ja": "A.40。 lsf.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "lsf.c",
      "ja": "lsf.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <string.h>",
      "ja": "書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "ja": "書式#include <math.h>の"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  conversion from lpc coefficients to lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void a2lsf(\n    float *freq,/* (o) lsf coefficients */\n    float *a    /* (i) lpc coefficients */\n){\n    float steps[LSF_NUMBER_OF_STEPS] =\n        {(float)0.00635, (float)0.003175, (float)0.0015875,\n        (float)0.00079375};\n    float step;\n    int step_idx;\n    int lsp_index;\n    float p[LPC_HALFORDER];\n    float q[LPC_HALFORDER];\n    float p_pre[LPC_HALFORDER];\n    float q_pre[LPC_HALFORDER];\n    float old_p, old_q, *old;\n    float *pq_coef;\n    float omega, old_omega;\n    int i;\n    float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER - i]);\n    q[i] = a[LPC_FILTERORDER - i] - a[i + 1];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "p_pre[0] = (float)-1.0 - p[0];\np_pre[1] = - p_pre[0] - p[1];\np_pre[2] = - p_pre[1] - p[2];\np_pre[3] = - p_pre[2] - p[3];\np_pre[4] = - p_pre[3] - p[4];\np_pre[4] = p_pre[4] / 2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "q_pre[0] = (float)1.0 - q[0];\nq_pre[1] = q_pre[0] - q[1];\nq_pre[2] = q_pre[1] - q[2];\nq_pre[3] = q_pre[2] - q[3];\nq_pre[4] = q_pre[3] - q[4];\nq_pre[4] = q_pre[4] / 2;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "omega = 0.0;",
      "ja": "おめが ＝ ０。０；"
    },
    {
      "indent": 7,
      "text": "old_omega = 0.0;",
      "ja": "old_omega = 0.0。"
    },
    {
      "indent": 7,
      "text": "old_p = FLOAT_MAX;\nold_q = FLOAT_MAX;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Here we loop through lsp_index to find all the\n   LPC_FILTERORDER roots for omega. */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (lsp_index = 0; lsp_index<LPC_FILTERORDER; lsp_index++) {",
      "ja": "用（lsp_index = 0; lsp_index <LPC_FILTERORDER; lsp_index ++）{"
    },
    {
      "indent": 11,
      "text": "/* Depending on lsp_index being even or odd, we\nalternatively solve the roots for the two LSP equations. */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if ((lsp_index & 0x1) == 0) {\n    pq_coef = p_pre;\n    old = &old_p;\n} else {\n    pq_coef = q_pre;\n    old = &old_q;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Start with low resolution grid */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (step_idx = 0, step = steps[step_idx]; step_idx < LSF_NUMBER_OF_STEPS;){",
      "ja": "（; step_idx <LSF_NUMBER_OF_STEPS; step_idx = 0、ステップ=ステップ[step_idx]）{用"
    },
    {
      "indent": 15,
      "text": "/*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +\npq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */",
      "raw": true
    },
    {
      "indent": 15,
      "text": "hlp = (float)cos(omega * TWO_PI);\nhlp1 = (float)2.0 * hlp + pq_coef[0];\nhlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +\n    pq_coef[1];\nhlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];\nhlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];\nhlp5 = hlp * hlp4 - hlp3 + pq_coef[4];",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (((hlp5 * (*old)) <= 0.0) || (omega >= 0.5)){",
      "ja": "IF（（（hlp5 *（*旧））<= 0.0）||（オメガ> = 0.5））{"
    },
    {
      "indent": 19,
      "text": "if (step_idx == (LSF_NUMBER_OF_STEPS - 1)){",
      "ja": "IF（step_idx ==（LSF_NUMBER_OF_STEPS  -  1））{"
    },
    {
      "indent": 23,
      "text": "if (fabs(hlp5) >= fabs(*old)) {\n    freq[lsp_index] = omega - step;\n} else {\n    freq[lsp_index] = omega;\n} if ((*old) >= 0.0){\n    *old = (float)-1.0 * FLOAT_MAX;\n} else {\n    *old = FLOAT_MAX;\n}",
      "raw": true
    },
    {
      "indent": 23,
      "text": "omega = old_omega;\nstep_idx = 0;",
      "raw": true
    },
    {
      "indent": 19,
      "text": " step_idx = LSF_NUMBER_OF_STEPS; } else {",
      "ja": "step_idx = LSF_NUMBER_OF_STEPS。 }他{"
    },
    {
      "indent": 23,
      "text": "if (step_idx == 0) {\n    old_omega = omega;\n}",
      "raw": true
    },
    {
      "indent": 23,
      "text": "step_idx++;\nomega -= steps[step_idx];",
      "raw": true
    },
    {
      "indent": 23,
      "text": "/* Go back one grid step */",
      "raw": true
    },
    {
      "indent": 15,
      "text": " step = steps[step_idx]; } } else {",
      "ja": "ステップ=ステップ[step_idx]。 }}他{"
    },
    {
      "indent": 7,
      "text": "        /* increment omega until they are of different sign,\n        and we know there is at least one root between omega\n        and old_omega */\n            *old = hlp5;\n            omega += step;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " for (i = 0; i<LPC_FILTERORDER; i++) { freq[i] = freq[i] * TWO_PI; } }",
      "ja": "用（i = 0; iはLPC_FILTERORDERを<; iは++）{FREQ [I] = FREQ [I] * TWO_PI。 }}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  conversion from lsf coefficients to lpc coefficients\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void lsf2a(\n    float *a_coef,  /* (o) lpc coefficients */\n    float *freq     /* (i) lsf coefficients */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "){\n    int i, j;\n    float hlp;\n    float p[LPC_HALFORDER], q[LPC_HALFORDER];\n    float a[LPC_HALFORDER + 1], a1[LPC_HALFORDER],\n        a2[LPC_HALFORDER];\n    float b[LPC_HALFORDER + 1], b1[LPC_HALFORDER],\n        b2[LPC_HALFORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    freq[i] = freq[i] * PI2;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Check input for ill-conditioned cases.  This part is not\nfound in the TIA standard.  It involves the following 2 IF\nblocks.  If \"freq\" is judged ill-conditioned, then we first\nmodify freq[0] and freq[LPC_HALFORDER-1] (normally\nLPC_HALFORDER = 10 for LPC applications), then we adjust\nthe other \"freq\" values slightly */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if ((freq[0] <= 0.0) || (freq[LPC_FILTERORDER - 1] >= 0.5)){",
      "ja": "IF（（FREQ [0] <= 0.0）||（FREQ [LPC_FILTERORDER  -  1]> = 0.5））{"
    },
    {
      "indent": 11,
      "text": "if (freq[0] <= 0.0) {\n    freq[0] = (float)0.022;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (freq[LPC_FILTERORDER - 1] >= 0.5) { freq[LPC_FILTERORDER - 1] = (float)0.499; }",
      "ja": "IF（FREQ [LPC_FILTERORDER  -  1]> = 0.5）{FREQ [LPC_FILTERORDER  -  1] =（FLOAT）0.499。 }"
    },
    {
      "indent": 11,
      "text": "hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) / (float) (LPC_FILTERORDER - 1);",
      "ja": "HLP =（FREQ [LPC_FILTERORDER  -  1]  -  FREQ [0]）/（フロート）（LPC_FILTERORDER  -  1）。"
    },
    {
      "indent": 7,
      "text": " for (i=1; i<LPC_FILTERORDER; i++) { freq[i] = freq[i - 1] + hlp; } }",
      "ja": "用（i = 1; iはLPC_FILTERORDERを<; iは++）{FREQ [I] = FREQ [I  -  1] + HLP。 }}"
    },
    {
      "indent": 7,
      "text": "memset(a1, 0, LPC_HALFORDER*sizeof(float));\nmemset(a2, 0, LPC_HALFORDER*sizeof(float));\nmemset(b1, 0, LPC_HALFORDER*sizeof(float));\nmemset(b2, 0, LPC_HALFORDER*sizeof(float));\nmemset(a, 0, (LPC_HALFORDER+1)*sizeof(float));\nmemset(b, 0, (LPC_HALFORDER+1)*sizeof(float));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* p[i] and q[i] compute cos(2*pi*omega_{2j}) and\ncos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1 and 4.2.2.2-2.\nNote that for this code p[i] specifies the coefficients\nused in .Q_A(z) while q[i] specifies the coefficients used\nin .P_A(z) */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    p[i] = (float)cos(TWO_PI * freq[2 * i]);\n    q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "a[0] = 0.25;\nb[0] = 0.25;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i= 0; i<LPC_HALFORDER; i++) {\n    a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n    b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n    a2[i] = a1[i];\n    a1[i] = a[i];\n    b2[i] = b1[i];\n    b1[i] = b[i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (j=0; j<LPC_FILTERORDER; j++) {",
      "ja": "用（J = 0; J <LPC_FILTERORDER; J ++）{"
    },
    {
      "indent": 11,
      "text": "if (j == 0) {\n    a[0] = 0.25;\n    b[0] = -0.25;\n} else {\n    a[0] = b[0] = 0.0;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n    b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n    a2[i] = a1[i];\n    a1[i] = a[i];\n    b2[i] = b1[i];\n    b1[i] = b[i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": " a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]); }",
      "ja": "a_coef [J + 1] = 2 *（[LPC_HALFORDER] + B [LPC_HALFORDER]）。 }"
    },
    {
      "indent": 3,
      "text": " a_coef[0] = 1.0; }",
      "ja": "a_coef [0] = 1.0。 }"
    },
    {
      "indent": 0,
      "text": "A.41. packing.h",
      "ja": "A.41。 packing.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "packing.h",
      "ja": "packing.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __PACKING_H #define __PACKING_H",
      "ja": "#ifndefの__PACKING_Hの#define __PACKING_H"
    },
    {
      "indent": 3,
      "text": "void packsplit(\n    int *index,                 /* (i) the value to split */\n    int *firstpart,             /* (o) the value specified by most\n                                       significant bits */\n    int *rest,                  /* (o) the value specified by least\n                                       significant bits */\n    int bitno_firstpart,    /* (i) number of bits in most\n                                       significant part */\n    int bitno_total             /* (i) number of bits in full range\n                                       of value */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void packcombine(\n    int *index,                 /* (i/o) the msb value in the\n                                       combined value out */\n    int rest,                   /* (i) the lsb value */\n    int bitno_rest              /* (i) the number of bits in the\n                                       lsb part */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void dopack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to pack\n                                       new data, on exit pointer\n                                       to place in bitstream to\n                                       pack future data */\n    int index,                  /* (i) the value to pack */\n    int bitno,                  /* (i) the number of bits that the\n                                       value will fit within */\n    int *pos                /* (i/o) write position in the\n                                       current byte */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void unpack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to\n                                       unpack new data from, on\n                                       exit pointer to place in\n                                       bitstream to unpack future\n                                       data from */\n    int *index,                 /* (o) resulting value */\n    int bitno,                  /* (i) number of bits used to\n                                       represent the value */\n    int *pos                /* (i/o) read position in the\n                                       current byte */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.42. packing.c",
      "ja": "A.42。 packing.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "packing.c",
      "ja": "packing.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <stdlib.h>",
      "ja": "書式#include <math.h>の書式#include <stdlib.h>に含ま"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"helpfun.h\" #include \"string.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\" の#include \"helpfun.h\" の#include \"string.hの\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  splitting an integer into first most significant bits and\n *  remaining least significant bits\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void packsplit(\n    int *index,                 /* (i) the value to split */\n    int *firstpart,             /* (o) the value specified by most\n                                       significant bits */\n    int *rest,                  /* (o) the value specified by least\n                                       significant bits */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    int bitno_firstpart,    /* (i) number of bits in most\n                                       significant part */\n    int bitno_total             /* (i) number of bits in full range\n                                       of value */\n){\n    int bitno_rest = bitno_total-bitno_firstpart;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    *firstpart = *index>>(bitno_rest);\n    *rest = *index-(*firstpart<<(bitno_rest));\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  combining a value corresponding to msb's with a value\n *  corresponding to lsb's\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void packcombine(\n    int *index,                 /* (i/o) the msb value in the\n                                       combined value out */\n    int rest,                   /* (i) the lsb value */\n    int bitno_rest              /* (i) the number of bits in the\n                                       lsb part */\n){\n    *index = *index<<bitno_rest;\n    *index += rest;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  packing of bits into bitstream, i.e., vector of bytes\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void dopack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to pack\n                                       new data, on exit pointer\n                                       to place in bitstream to\n                                       pack future data */\n    int index,                  /* (i) the value to pack */\n    int bitno,                  /* (i) the number of bits that the\n                                       value will fit within */\n    int *pos                /* (i/o) write position in the\n                                       current byte */\n){\n    int posLeft;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Clear the bits before starting in a new byte */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if ((*pos)==0) {",
      "ja": "IF（（* POS）== 0）{"
    },
    {
      "indent": 7,
      "text": " **bitstream=0; }",
      "ja": "**ビットストリーム= 0; }"
    },
    {
      "indent": 7,
      "text": "while (bitno>0) {",
      "ja": "一方、（本質的に> 0）{"
    },
    {
      "indent": 11,
      "text": "/* Jump to the next byte if end of this byte is reached*/",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (*pos==8) {\n    *pos=0;\n    (*bitstream)++;\n    **bitstream=0;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "posLeft=8-(*pos);",
      "ja": "posLeft = 8  - （*ポスト）。"
    },
    {
      "indent": 11,
      "text": "/* Insert index into the bitstream */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (bitno <= posLeft) {\n    **bitstream |= (unsigned char)(index<<(posLeft-bitno));\n    *pos+=bitno;\n    bitno=0;\n} else {\n    **bitstream |= (unsigned char)(index>>(bitno-posLeft));",
      "raw": true
    },
    {
      "indent": 15,
      "text": "*pos=8;\nindex-=((index>>(bitno-posLeft))<<(bitno-posLeft));",
      "raw": true
    },
    {
      "indent": 3,
      "text": " bitno-=posLeft; } } }",
      "ja": "=ビットposLeft。 }}}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  unpacking of bits from bitstream, i.e., vector of bytes\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void unpack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to\n                                       unpack new data from, on\n                                       exit pointer to place in\n                                       bitstream to unpack future\n                                       data from */\n    int *index,                 /* (o) resulting value */\n    int bitno,                  /* (i) number of bits used to\n                                       represent the value */\n    int *pos                /* (i/o) read position in the\n                                       current byte */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "){ int BitsLeft;",
      "ja": "）{int型BitsLeft。"
    },
    {
      "indent": 7,
      "text": "*index=0;",
      "ja": "*インデックス= 0;"
    },
    {
      "indent": 7,
      "text": "while (bitno>0) {",
      "ja": "一方、（本質的に> 0）{"
    },
    {
      "indent": 11,
      "text": "/* move forward in bitstream when the end of the\n   byte is reached */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (*pos==8) {\n    *pos=0;\n    (*bitstream)++;\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "BitsLeft=8-(*pos);",
      "ja": "BitsLeft = 8  - （* POS）。"
    },
    {
      "indent": 11,
      "text": "/* Extract bits to index */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if (BitsLeft>=bitno) { *index+=((((**bitstream)<<(*pos)) & 0xFF)>>(8-bitno));",
      "ja": "IF（BitsLeft> = bitno）{*指数+ =（（（（**ビットストリーム）<<（* POS））＆0xFFの）>>（8-bitno））。"
    },
    {
      "indent": 11,
      "text": "    *pos+=bitno;\n    bitno=0;\n} else {",
      "raw": true
    },
    {
      "indent": 3,
      "text": "            if ((8-bitno)>0) {\n                *index+=((((**bitstream)<<(*pos)) & 0xFF)>>\n                    (8-bitno));\n                *pos=8;\n            } else {\n                *index+=(((int)(((**bitstream)<<(*pos)) & 0xFF))<<\n                    (bitno-8));\n                *pos=8;\n            }\n            bitno-=BitsLeft;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.43. StateConstructW.h",
      "ja": "A.43。 StateConstructW.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "StateConstructW.h",
      "ja": "StateConstructW.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_STATECONSTRUCTW_H #define __iLBC_STATECONSTRUCTW_H",
      "ja": "#ifndefの__iLBC_STATECONSTRUCTW_Hの#define __iLBC_STATECONSTRUCTW_H"
    },
    {
      "indent": 3,
      "text": "void StateConstructW(\n    int idxForMax,      /* (i) 6-bit index for the quantization of\n                               max amplitude */\n    int *idxVec,    /* (i) vector of quantization indexes */\n    float *syntDenum,   /* (i) synthesis filter denumerator */\n    float *out,         /* (o) the decoded state vector */\n    int len             /* (i) length of a state vector */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.44. StateConstructW.c",
      "ja": "A.44。 StateConstructW.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "StateConstructW.c",
      "ja": "StateConstructW.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h>",
      "ja": "書式#include <math.h>の書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\" の#include \"filter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  decoding of the start state\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void StateConstructW(\n    int idxForMax,      /* (i) 6-bit index for the quantization of\n                               max amplitude */\n    int *idxVec,    /* (i) vector of quantization indexes */\n    float *syntDenum,   /* (i) synthesis filter denumerator */ float *out,         /* (o) the decoded state vector */\n    int len             /* (i) length of a state vector */\n){\n    float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN], *tmp,\n        numerator[LPC_FILTERORDER+1];\n    float foutbuf[LPC_FILTERORDER+2*STATE_LEN], *fout;\n    int k,tmpi;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* decoding of the maximum value */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "maxVal = state_frgqTbl[idxForMax];\nmaxVal = (float)pow(10,maxVal)/(float)4.5;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* initialization of buffers and coefficients */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));\nmemset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\nfor (k=0; k<LPC_FILTERORDER; k++) {\n    numerator[k]=syntDenum[LPC_FILTERORDER-k];\n}\nnumerator[LPC_FILTERORDER]=syntDenum[0];\ntmp = &tmpbuf[LPC_FILTERORDER];\nfout = &foutbuf[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* decoding of the sample values */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (k=0; k<len; k++) {\n    tmpi = len-1-k;\n    /* maxVal = 1/scal */\n    tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* circular convolution with all-pass filter */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    memset(tmp+len, 0, len*sizeof(float));\n    ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,\n        LPC_FILTERORDER, fout);\n    for (k=0;k<len;k++) {\n        out[k] = fout[len-1-k]+fout[2*len-1-k];\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.45. StateSearchW.h",
      "ja": "A.45。 StateSearchW.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "StateSearchW.h",
      "ja": "StateSearchW.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_STATESEARCHW_H #define __iLBC_STATESEARCHW_H",
      "ja": "#ifndefの__iLBC_STATESEARCHW_Hの#define __iLBC_STATESEARCHW_H"
    },
    {
      "indent": 3,
      "text": "void AbsQuantW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *in,          /* (i) vector to encode */\n    float *syntDenum,   /* (i) denominator of synthesis filter */\n    float *weightDenum, /* (i) denominator of weighting filter */\n    int *out,           /* (o) vector of quantizer indexes */\n    int len,        /* (i) length of vector to encode and\n                               vector of quantizer indexes */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void StateSearchW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *residual,/* (i) target residual vector */\n    float *syntDenum,   /* (i) lpc synthesis filter */\n    float *weightDenum, /* (i) weighting filter denuminator */\n    int *idxForMax,     /* (o) quantizer index for maximum\n                               amplitude */\n    int *idxVec,    /* (o) vector of quantization indexes */\n    int len,        /* (i) length of all vectors */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.46. StateSearchW.c",
      "ja": "A.46。 StateSearchW.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "StateSearchW.c",
      "ja": "StateSearchW.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include <math.h> #include <string.h>",
      "ja": "書式#include <math.h>の書式#include <string.hの>"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\" #include \"helpfun.h\"",
      "ja": "#include \"iLBC_define.h\" の#include \"constants.h\" の#include \"filter.h\" の#include \"helpfun.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  predictive noise shaping encoding of scaled start state\n *  (subrutine for StateSearchW)\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void AbsQuantW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *in,          /* (i) vector to encode */\n    float *syntDenum,   /* (i) denominator of synthesis filter */\n    float *weightDenum, /* (i) denominator of weighting filter */\n    int *out,           /* (o) vector of quantizer indexes */\n    int len,        /* (i) length of vector to encode and\n                               vector of quantizer indexes */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n){\n    float *syntOut;\n    float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];\n    float toQ, xq;\n    int n;\n    int index;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* initialization of buffer for filtering */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));",
      "ja": "memsetの（syntOutBuf、0、LPC_FILTERORDER *はsizeof（フロート））;"
    },
    {
      "indent": 7,
      "text": "/* initialization of pointer for filtering */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "syntOut = &syntOutBuf[LPC_FILTERORDER];",
      "ja": "syntOut =＆syntOutBuf [LPC_FILTERORDER]。"
    },
    {
      "indent": 7,
      "text": "/* synthesis and weighting filters on input */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (state_first) {\n    AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);\n} else {\n    AllPoleFilter (in, weightDenum,\n        iLBCenc_inst->state_short_len-SUBL,\n        LPC_FILTERORDER);\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* encoding loop */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (n=0; n<len; n++) {",
      "ja": "ため（N = 0、N <LENあり; n ++）{"
    },
    {
      "indent": 11,
      "text": "/* time update of filter coefficients */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "if ((state_first)&&(n==SUBL)){\n    syntDenum += (LPC_FILTERORDER+1);\n    weightDenum += (LPC_FILTERORDER+1);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* synthesis and weighting filters on input */\nAllPoleFilter (&in[n], weightDenum, len-n,\n    LPC_FILTERORDER);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "} else if ((state_first==0)&&\n    (n==(iLBCenc_inst->state_short_len-SUBL))) {\n    syntDenum += (LPC_FILTERORDER+1);\n    weightDenum += (LPC_FILTERORDER+1);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "/* synthesis and weighting filters on input */\nAllPoleFilter (&in[n], weightDenum, len-n,\n    LPC_FILTERORDER);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 11,
      "text": "/* prediction of synthesized and weighted input */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "syntOut[n] = 0.0;\nAllPoleFilter (&syntOut[n], weightDenum, 1,\n    LPC_FILTERORDER);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* quantization */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "toQ = in[n]-syntOut[n];",
      "ja": "TOQ = [n]は-syntOut [N]で、"
    },
    {
      "indent": 11,
      "text": "sort_sq(&xq, &index, toQ, state_sq3Tbl, 8);\nout[n]=index;\nsyntOut[n] = state_sq3Tbl[out[n]];",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* update of the prediction filter */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " AllPoleFilter(&syntOut[n], weightDenum, 1, LPC_FILTERORDER); } }",
      "ja": "AllPoleFilter（＆syntOut [n]は、weightDenum、1、LPC_FILTERORDER）。 }}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  encoding of start state\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void StateSearchW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *residual,/* (i) target residual vector */\n    float *syntDenum,   /* (i) lpc synthesis filter */\n    float *weightDenum, /* (i) weighting filter denuminator */\n    int *idxForMax,     /* (o) quantizer index for maximum\n                               amplitude */\n    int *idxVec,    /* (o) vector of quantization indexes */\n    int len,        /* (i) length of all vectors */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n){\n    float dtmp, maxVal;\n    float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];\n    float *tmp, numerator[1+LPC_FILTERORDER];\n    float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS], *fout;\n    int k;\n    float qmax, scal;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* initialization of buffers and filter coefficients */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));\nmemset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\nfor (k=0; k<LPC_FILTERORDER; k++) {\n    numerator[k]=syntDenum[LPC_FILTERORDER-k];\n}\nnumerator[LPC_FILTERORDER]=syntDenum[0];\ntmp = &tmpbuf[LPC_FILTERORDER];\nfout = &foutbuf[LPC_FILTERORDER];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* circular convolution with the all-pass filter */ memcpy(tmp, residual, len*sizeof(float));\nmemset(tmp+len, 0, len*sizeof(float));\nZeroPoleFilter(tmp, numerator, syntDenum, 2*len,\n    LPC_FILTERORDER, fout);\nfor (k=0; k<len; k++) {\n    fout[k] += fout[k+len];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* identification of the maximum amplitude value */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "maxVal = fout[0]; for (k=1; k<len; k++) {",
      "ja": "MAXVAL FOUT = [0]。 {;（K ++、K = 1、K <LEN）のために"
    },
    {
      "indent": 7,
      "text": "    if (fout[k]*fout[k] > maxVal*maxVal){\n        maxVal = fout[k];\n    }\n}\nmaxVal=(float)fabs(maxVal);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* encoding of the maximum amplitude value */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (maxVal < 10.0) {\n    maxVal = 10.0;\n}\nmaxVal = (float)log10(maxVal);\nsort_sq(&dtmp, idxForMax, maxVal, state_frgqTbl, 64);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* decoding of the maximum amplitude representation value,\n   and corresponding scaling of start state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "maxVal=state_frgqTbl[*idxForMax];\nqmax = (float)pow(10,maxVal);\nscal = (float)(4.5)/qmax;\nfor (k=0; k<len; k++){\n    fout[k] *= scal;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* predictive noise shaping encoding of scaled start state */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " AbsQuantW(iLBCenc_inst, fout,syntDenum, weightDenum,idxVec, len, state_first); }",
      "ja": "AbsQuantW（iLBCenc_inst、FOUT、syntDenum、weightDenum、idxVec、LEN、state_first）。 }"
    },
    {
      "indent": 0,
      "text": "A.47. syntFilter.h",
      "ja": "A.47。 syntFilter.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "syntFilter.h",
      "ja": "syntFilter.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_SYNTFILTER_H #define __iLBC_SYNTFILTER_H",
      "ja": "#ifndefの__iLBC_SYNTFILTER_Hの#define __iLBC_SYNTFILTER_H"
    },
    {
      "indent": 3,
      "text": "void syntFilter(\n    float *Out,     /* (i/o) Signal to be filtered */\n    float *a,       /* (i) LP parameters */\n    int len,    /* (i) Length of signal */\n    float *mem      /* (i/o) Filter state */\n);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "A.48. syntFilter.c",
      "ja": "A.48。 syntFilter.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBCのスピーチコーダANSI-Cソースコード"
    },
    {
      "indent": 7,
      "text": "syntFilter.c",
      "ja": "syntFilter.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "ja": "******************************************************************/"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  LP synthesis filter.\n *---------------------------------------------------------------*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "void syntFilter(\n    float *Out,     /* (i/o) Signal to be filtered */\n    float *a,       /* (i) LP parameters */\n    int len,    /* (i) Length of signal */ float *mem      /* (i/o) Filter state */\n){\n    int i, j;\n    float *po, *pi, *pa, *pm;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "po=Out;",
      "ja": "=アウトした後、"
    },
    {
      "indent": 7,
      "text": "/* Filter first part using memory from past */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    pi=&Out[i-1];\n    pa=&a[1];\n    pm=&mem[LPC_FILTERORDER-1];\n    for (j=1; j<=i; j++) {\n        *po-=(*pa++)*(*pi--);\n    }\n    for (j=i+1; j<LPC_FILTERORDER+1; j++) {\n        *po-=(*pa++)*(*pm--);\n    }\n    po++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Filter last part where the state is entirely in\n   the output vector */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i=LPC_FILTERORDER; i<len; i++) {\n    pi=&Out[i-1];\n    pa=&a[1];\n    for (j=1; j<LPC_FILTERORDER+1; j++) {\n        *po-=(*pa++)*(*pi--);\n    }\n    po++;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* Update state vector */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " memcpy(mem, &Out[len-LPC_FILTERORDER], LPC_FILTERORDER*sizeof(float)); }",
      "ja": "memcpy（MEM、＆OUT [lenの-LPC_FILTERORDER]、LPC_FILTERORDERの*のはsizeof（フロート））。 }"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Soren Vang Andersen Department of Communication Technology Aalborg University Fredrik Bajers Vej 7A 9200 Aalborg Denmark",
      "ja": "通信技術オールボー大学フレデリックBajers道路7A 9200オールボーデンマークのソレン・ヴァン・アンデルセン部門"
    },
    {
      "indent": 3,
      "text": "Phone: ++45 9 6358627 EMail: sva@kom.auc.dk",
      "ja": "電話：++ 45 9 6358627 Eメール：sva@kom.auc.dk"
    },
    {
      "indent": 3,
      "text": "Alan Duric Telio AS Stoperigt. 2 Oslo, N-0250 Norway",
      "ja": "Stoperigt ASアランDuric Telio。 2オスロ、N-0250ノルウェー"
    },
    {
      "indent": 3,
      "text": "Phone: +47 21673555 EMail: alan.duric@telio.no",
      "ja": "電話：+47 21673555 Eメール：alan.duric@telio.no"
    },
    {
      "indent": 3,
      "text": "Henrik Astrom Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "ヘンリック・アストロームグローバルIPサウンドAB Olandsgatan 42ストックホルム、S-11663スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 54553040 EMail: henrik.astrom@globalipsound.com",
      "ja": "電話：+46 8 54553040 Eメール：henrik.astrom@globalipsound.com"
    },
    {
      "indent": 3,
      "text": "Roar Hagen Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "ロア・ハーゲングローバルIPサウンドAB Olandsgatan 42ストックホルム、S-11663スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 54553040 EMail: roar.hagen@globalipsound.com",
      "ja": "電話：+46 8 54553040 Eメール：roar.hagen@globalipsound.com"
    },
    {
      "indent": 3,
      "text": "W. Bastiaan Kleijn Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "W. Bastiaan KleijnグローバルIPサウンドAB Olandsgatan 42ストックホルム、S-11663スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 54553040 EMail: bastiaan.kleijn@globalipsound.com",
      "ja": "電話：+46 8 54553040 Eメール：bastiaan.kleijn@globalipsound.com"
    },
    {
      "indent": 3,
      "text": "Jan Linden Global IP Sound Inc. 900 Kearny Street, suite 500 San Francisco, CA-94133 USA",
      "ja": "ヤンリンデングローバルIPサウンド・インク900カーニーストリート、スイート500サンフランシスコ、CA-94133 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 415 397 2555 EMail: jan.linden@globalipsound.com",
      "ja": "電話：+1 415 397 2555 Eメール：jan.linden@globalipsound.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004).",
      "ja": "著作権（C）インターネット協会（2004）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF's procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 IETF文書の権利に関するIETFの手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}