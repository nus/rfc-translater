{
  "title": {
    "text": "RFC 3385 - Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations",
    "ja": "RFC 3385 - インターネット・プロトコル小型コンピュータシステムインタフェース（iSCSIの）巡回冗長検査（CRC）/チェックサムの考慮事項"
  },
  "number": 3385,
  "created_at": "2019-10-27 16:40:55.073089+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       D. Sheinwald\nRequest for Comments: 3385                                     J. Satran\nCategory: Informational                                              IBM\n                                                               P. Thaler\n                                                              V. Cavanna\n                                                                 Agilent\n                                                          September 2002",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Internet Protocol Small Computer System Interface (iSCSI)\n  Cyclic Redundancy Check (CRC)/Checksum Considerations",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "In this memo, we attempt to give some estimates for the probability of undetected errors to facilitate the selection of an error detection code for the Internet Protocol Small Computer System Interface (iSCSI).",
      "ja": "このメモでは、私たちは、インターネット・プロトコル小型コンピュータシステムインタフェース（iSCSIの）のためのエラー検出コードの選択を容易にするために検出されないエラーの確率のためのいくつかの推定値を与えることを試みます。"
    },
    {
      "indent": 3,
      "text": "We will also attempt to compare Cyclic Redundancy Checks (CRCs) with other checksum forms (e.g., Fletcher, Adler, weighted checksums), as permitted by available data.",
      "ja": "我々はまた、利用可能なデータによって許容されるように、他のチェックサムの形式（例えば、フレッチャー、アドラー、重み付けされたチェックサム）と巡回冗長検査（CRCを）を比較しようとします。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Cyclic Redundancy Check (CRC) codes [Peterson] are shortened cyclic codes used for error detection. A number of CRC codes have been adopted in standards: ATM, IEC, IEEE, CCITT, IBM-SDLC, and more [Baicheva]. The most important expectation from this kind of code is a very low probability for undetected errors. The probability of undetected errors in such codes has been, and still is, subject to extensive studies that have included both analytical models and simulations. Those codes have been used extensively in communications and magnetic recording as they demonstrate good \"burst error\" detection capabilities, but are also good at detecting several independent bit errors. Hardware implementations are very simple and well known; their simplicity has made them popular with hardware developers for many years. However, algorithms and software for effective implementations of CRC are now also widely available [Williams].",
      "ja": "巡回冗長検査（CRC）符号[ピーターソン]は、エラー検出に使用される巡回符号を短縮しています。より【Baicheva] ATM、IEC、IEEE、CCITT、IBM-SDLC、および：CRCコードの数は、規格で採用されています。この種のコードから、最も重要な期待が検出されないエラーのための非常に低い確率です。そのようなコードで検出されないエラーの確率は、解析モデルとシミュレーションの両方が含まれている広範な研究の対象となって、まだあるしました。それらは、良好な「バーストエラー」検出能力を実証するだけでなく、いくつかの独立したビットエラーの検出に優れているとして、これらのコードは、通信及び磁気記録に広く使用されてきました。ハードウェアの実装は非常にシンプルでよく知られています。そのシンプルさは、長年のハードウェア開発者と彼らが人気になりました。しかしながら、CRCの効果的な実装のためのアルゴリズムおよびソフトウェアは、今[ウィリアムズ]広く入手可能です。"
    },
    {
      "indent": 3,
      "text": "The probability of undetected errors depends on the polynomial selected to generate the code, the error distribution (error model), and the data length.",
      "ja": "未検出誤り確率は、コード、エラー分布（エラーモデル）、及びデータ長を生成するために選択された多項式に依存します。"
    },
    {
      "indent": 0,
      "text": "2. Error Models and Goals",
      "section_title": true,
      "ja": "2.エラーモデルと目標"
    },
    {
      "indent": 3,
      "text": "We will analyze the code behavior under two conditions:",
      "ja": "我々は2つの条件の下で、コードの振る舞いを分析します。"
    },
    {
      "indent": 6,
      "text": "- noisy channel - burst errors with an average length of n bits - low noise channel - independent single bit errors",
      "ja": " - 騒々しいチャネル -  nビットの平均長を有するバーストエラー - 低雑音チャネル - 独立したシングルビットエラー"
    },
    {
      "indent": 3,
      "text": "Burst errors are the prevalent natural phenomenon on communication lines and recording media. The numbers quoted for them revolve around the BER (bit error rate). However, those numbers are frequently nothing more than a reflection of the Burst Error Rate multiplied by the average burst length. In field engineering tests, three numbers are usually quoted together -- BER, error-free-seconds and severely-error-seconds; this illustrates our point.",
      "ja": "バーストエラーは、通信回線や記録メディアに蔓延自然現象です。彼らのために引用された数字は、BER（ビット誤り率）を中心に展開します。しかし、これらの数字は、しばしば平均バースト長を乗じたバーストエラー率の反射以外の何物でもありません。フィールドエンジニアリングのテストでは、3つの数字は、通常は一緒に引用されている -  BER、エラーのない-秒と厳しく誤り秒。これは私たちのポイントを示しています。"
    },
    {
      "indent": 3,
      "text": "Even beyond communication and recording media, the effects of errors will be bursty. An example of this is a memory error that will affect more than a single bit and the total effect will not be very different from the communication error, or software errors that occur while manipulating packets will have a burst effect. Software errors also result in burst errors. In addition, serial internal interconnects will make this type of error the most common within machines as well.",
      "ja": "でも、コミュニケーションや記録メディアを超えて、誤差の影響がバースト的になります。この例は、単一のビットよりも多くの影響を与えるメモリ・エラーであり、合計の効果は、通信エラーとは非常に異なることはないであろう、またはパケットを操作するときに発生するソフトエラーがバースト効果を有するであろう。ソフトウェアのエラーもバーストエラーになります。また、シリアル内部の配線も同様にマシン内で最も一般的なこのタイプのエラーを行います。"
    },
    {
      "indent": 3,
      "text": "We also analyze the effects of single independent bit errors, since these may be caused by certain defects.",
      "ja": "これらは、特定の欠陥に起因することができるので、我々はまた、単一の独立したビット・エラーの影響を分析します。"
    },
    {
      "indent": 3,
      "text": "On burst, we assume an average burst error duration of bd, which at a given transmission rate s, will result in an average burst of a = bd*s bits. (E.g., an average burst duration of 3 ns at 1Gbs gives an average burst of 3 bits.)",
      "ja": "バーストに、我々は、与えられた伝送速度Sで、BD = * Sビットの平均バーストをもたらすBDの平均バーストエラー期間を、仮定しています。 （例えば、1Gbsで3ナノ秒の平均バースト期間は、3ビットの平均バーストを与えます。）"
    },
    {
      "indent": 3,
      "text": "For the burst error rate, we will take 10^-10. The numbers quoted for BER on wired communication channels are between 10^-10 to 10^-12 and we consider the BER as burst-error-rate*average-burst-length. Nevertheless, please keep in mind that if the channel includes wireless links, the error rates may be substantially higher.",
      "ja": "バーストエラー率のために、我々は10 ^ -10かかります。有線通信チャネル上のBERのために引用された数字は、10 ^ 10 ^ -10の間で-12、我々は、バースト誤り率*平均バースト長としてBERを考えます。それにも関わらず、チャネルは、無線リンクが含まれている場合、エラー率が実質的に高くなる可能性がありますのでご注意ください。"
    },
    {
      "indent": 3,
      "text": "For independent single bit errors, we assume a 10^-11 error rate.",
      "ja": "独立したシングルビットエラーのために、我々は10 ^ -11のエラーレートを前提としています。"
    },
    {
      "indent": 3,
      "text": "Because the error detection mechanisms will have to transport large amounts of data (petabytes=10^16 bits) without errors, we will target very low probabilities for undetected errors for all block lengths (at 10Gb/s that much data can be sent in less than 2 weeks on a single link).",
      "ja": "エラー検出メカニズムがエラーなしで大量のデータ（ペタバイト= 10 ^ 16ビット）を搬送しなければならないので、我々は多くのデータが少ないで送信することができることの10Gb / sで（全ブロック長のために検出されないエラーの非常に低い確率を標的とします）単一のリンク上の2週間以上。"
    },
    {
      "indent": 3,
      "text": "Alternatively, as iSCSI has to perform efficiently, we will require that the error detection capability of a selected protection mechanism be very good, at least up to block lengths of 8k bytes (64kbits).",
      "ja": "iSCSIは効率的に実行しなければ別法として、我々は、選択された保護機構のエラー検出能力は8Kバイト（ある64k）の長さをブロックするために、少なくともまで、非常に良好であることを必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "The error detection capability should keep the probability of undetected errors at values that would be \"next-to-impossible\". We recognize, however, that such attributes are hard to quantify and we resorted to physics. The value 10^23 is the Avogadro number while 10^45 is the number of atoms in the known Universe (or it was many years ago when we read about it) and those are the bounds of incertitude we could live with. (10^-23 at worst and 10^-45 if we can afford it.) For 8k blocks, the per/bit equivalent would be (10^-28 to 10^-50).",
      "ja": "エラー検出機能は、「次のツー不可能」だろう値で検出されないエラーの確率を維持する必要があります。我々は認識し、しかし、そのような属性は、定量化が困難であり、私たちは物理学に頼っ。 10 ^ 45は、既知の宇宙の原子の数（または我々はそれについて読んだとき、それは何年も前だった）で、それらは私たちが一緒に暮らすことができ不確実の境界している間値10 ^ 23はアボガドロ数です。 （10 ^ -23我々はそれを余裕がある場合。最悪の場合、10 ^ -45）8kのブロックについては、あたり/ビット相当するものは（10 ^ -50〜10 ^ -28）になります。"
    },
    {
      "indent": 0,
      "text": "3. Background and Literature Survey",
      "section_title": true,
      "ja": "3.背景と文学調査"
    },
    {
      "indent": 3,
      "text": "Each codeword of a binary (n,k) CRC code C consists of n = k+r bits. The block of r parity bits is computed from the block of k information bits. The code has a degree r generator polynomial g(x).",
      "ja": "バイナリの各コードワードは、（n、k）はCRC符号Cは、N = K + Rビットからなります。 r個のパリティビットのブロックは、k個の情報ビットのブロックから計算されます。コードは、次数rの生成多項式G（X）を有します。"
    },
    {
      "indent": 3,
      "text": "The code is linear in the sense that the bitwise addition of any two codewords yields a codeword.",
      "ja": "コードは、任意の2つのコードワードのビット単位の添加は、符号語を生成するという意味で線形です。"
    },
    {
      "indent": 3,
      "text": "For the minimal m such that g(x) divides (x^m)-1, either n=m, and the code C comprises the set D of all the multiplications of g(x) modulo (x^m)-1, or n<m, and C is obtained from D by shortening each word in the latter in m-n specific positions. (This also reduces the number of words since all zero words are then discarded and duplicates are not maintained.)",
      "ja": "最小MのためのそのようなG（x）の除算（X ^ M）-1、M、コードCのいずれかで、nは= Gの全ての乗算のセットD（x）はモジュロ（X ^ M）-1を含むこと、又はN <M、及びCは、MN特定の位置における後者の各単語を短くしてDから得られます。 （全てゼロの単語は、その後廃棄され、重複が維持されないので、これはまた、単語の数を減少させます。）"
    },
    {
      "indent": 3,
      "text": "Error detection at the receiving end is made by computing the parity bits from the received information block, and comparing them with the received parity bits.",
      "ja": "受信側で誤り検出は、受信した情報ブロックからパリティビットを計算し、受信したパリティビットと比較することによって行われます。"
    },
    {
      "indent": 3,
      "text": "An undetected error occurs when the received word c' is a codeword, but is different from the c that is transmitted.",
      "ja": "未検出誤りは受信語C」が符号語である場合に生じるが、送信され、Cとは異なります。"
    },
    {
      "indent": 3,
      "text": "This is only possible when the error pattern e=c'-c is a codeword by itself (because of the linearity of the code). The performance of a CRC code is measured by the probability Pud of undetected channel errors.",
      "ja": "これは、誤りパターンE = C'-Cは（理由コードの直線の）自身が符号語である場合にのみ可能です。 CRCコードの性能は未検出チャンネルエラーの確率PUDによって測定されます。"
    },
    {
      "indent": 3,
      "text": "Let Ai denote the number of codewords of weight i, (i.e., with i 1- bits). For a binary symmetric channel (BSC), with sporadic, independent bit error ratio of probability 0<=epsilon<=0.5, the probability of undetected errors for the code C is thus given by:",
      "ja": "Aiは重量の符号語iの数を示すものと、（すなわち、I 1-ビットで）。バイナリ対称チャネル（BSC）のために、確率0の散発的な、独立したビット誤り率<=イプシロン<= 0.5で、コードCの未検出誤り確率は、従って次式で与えられます。"
    },
    {
      "indent": 0,
      "text": "Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))",
      "ja": "[iに対する= NにD] PUD（C、ε）=シグマ（AI *（イプシロン^ I）*（1-イプシロン）^（I N-））"
    },
    {
      "indent": 3,
      "text": "where d is the distance of the code: the minimal weight difference between two codewords in C which, by the linearity of the code, is also the minimal weight of any codeword in the code. Pud can also be expressed by the weight distribution of the dual code: the set of words each of which is orthogonal (bitwise AND yields an even number of 1-bits) to every word of C. The fact that Pud can be computed using the dual code is extremely important; while the number of codewords in the code is 2^k, the number of codewords in the dual code is 2^r. k is in the orders of thousands, and r in the order of 16 or 24 or 32. If we use Bi to denote the number of codewords in the dual code which are of weight i, then ([LinCostello]):",
      "ja": "符号の線形性によって、また、コード内の任意の符号語の最小重量であり、Cで2つの符号語間の最小重量差：Dはコードの距離です。 C.のすべての単語と直交する方向（ビット単位のAND 1ビットの偶数を生じる）でそれぞれが単語のセットPUDを用いて計算することができるという事実を：PUDは、デュアルコードの重量分布によって表すことができます。デュアルコードは非常に重要です。コード内のコードワードの数が2 ^ Kである、デュアルコードにおけるコードワードの数は2 ^ Rです。 kは数千のオーダーであり、16または24または32の順にR、我々は重量であるデュアルコードにおけるコードワードの数を示すためのBiを使用する場合、Iは、（[LinCostello]）："
    },
    {
      "indent": 0,
      "text": "Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i - (1-epsilon)^n",
      "ja": "PUD（C、ε）= 2 ^ -rシグマ[用I = 0からn]ビ*（1-2 *イプシロン）^ I  - （1-イプシロン）^ n個"
    },
    {
      "indent": 3,
      "text": "Wolf [Wolf94o] introduced an efficient algorithm for enumerating all the codewords of a code and finding their weight distribution.",
      "ja": "ウルフ[Wolf94o]はコードのすべてのコードワードを列挙し、その重量分布を求めるための効率的なアルゴリズムを導入しました。"
    },
    {
      "indent": 3,
      "text": "Wolf [Wolf82] found that, counter to what was assumed, (1) there exist codes for which Pud(C,epsilon)>Pud(C,0.5) for some epsilon not=0.5 and (2) Pud is not always increasing for 0<=epsilon<=0.5. The value of what was assumed to be the worst Pud is Pud(C,0.5)=(2^- r) - (2^-n). This stems from the fact that with epsilon=0.5, all 2^n received words are equally likely and out of them 2^(n-r)-1 will be accepted as codewords of no errors, although they are different from the codeword transmitted. Previously Pud had been assumed to equal [2^(n-r)-1]/(2^n-1) or the ratio of the number of non-zero multiples of the polynomial of degree less than n (each such multiple is undetected) and the number of possible error polynomials. With either formula Pud approaches 1/2^r as n approaches infinity, but Wolf's formula is more accurate.",
      "ja": "ウルフ[Wolf82]と仮定したものにカウンタが、（1）PUD（C、イプシロン）> PUD（C、0.5）をコード= 0.5一部イプシロンためない存在と（2）PUDは常にために増加されていないことがわかっ0 <=イプシロン<= 0.5。 （2 ^ -n） - 最悪PUDであると仮定されたものの値は、PUD（C、0.5）=（ -  R 2 ^）です。それらが送信された符号語は異なるが、これは、ε= 0.5で、すべての2 ^ N個の受信ワードが等しく可能性があり、それらのうちの2 ^（N-R）という事実から生じる-1、エラーなしのコードワードとして受け入れられるであろう。以前PUDが等しいと仮定していた[2 ^（NR）-1] /（2 N-1 ^）n以下の多項式のゼロ以外の倍数の数の比（それぞれ、複数が未検出です）そして、考えられるエラー多項式の数。 nが無限大に近づくが、ウルフの式はより正確であるようにいずれかの式でPUDは、1/2 ^ Rに近づきます。"
    },
    {
      "indent": 3,
      "text": "Wolf [Wolf94j] investigated the CCITT code of r=16 parity bits. This code is a member of the family of (shortened codes of) BCH codes of length 2^(r-1) -1 (r=16 in the CCITT 16-bit case) generated by a polynomial of the form g(x) =(x+1)p(x) with p(x) being a primitive polynomial of degree r-1 (=15 in this case). These codes have a BCH design distance of 4. That is, the minimal distance between any two codewords in the code is at least 4 bits (which is earned by the fact that the sequence of powers of alpha, the root of p(x), which are roots of g(x), includes three consecutive powers -- alpha^0, alpha^1, alpha^2). Hence, every 3 single bit errors are detectable.",
      "ja": "ウルフ[Wolf94j] R = 16パリティビットのCCITTコードを調べました。このコードは、長さが2 ^（R-1）のBCH符号（の短縮コード）のファミリーのメンバーである-1（CCITT 16ビットの場合にはR = 16）形態G（X）の多項式によって生成します= Pと（X + 1）、P（x）は（x）の次数R-1（ここで= 15）の原始多項式です。これらのコードが4のBCH設計距離を有し、コード内の任意の2つの符号語間の最小距離は、αの累乗の配列という事実によって獲得された少なくとも4ビット（Pのルート（x）はアルファ^ 0、アルファ^ 1、アルファ^ 2） - 、G（X）の根であるが三つの連続パワーを含んでいます。したがって、すべての3つのビットエラーが検出可能です。"
    },
    {
      "indent": 3,
      "text": "Wolf found that different shortened versions of a given code, of the same codeword length, perform the same (independent of which specific indexes are omitted from the original code). He also found that for the unshortened codes, all primitive polynomials yield codes of the same performance. But for the shortened versions, the choice of the primitive polynomial does make a difference. Wolf [Wolf94j] found a primitive polynomial which (when multiplied by x+1) yields a generating polynomial that outperforms the CCITT one by an order of magnitude. For 32-bit redundancy bits, he found an example of two polynomials that differ in their probability of undetected burst of length 33 by 4 orders of magnitude.",
      "ja": "狼は、与えられたコードの異なる短縮バージョンは、同一の符号語長の、同じ（特定のインデックスが元のコードから省略されているとは無関係に）を実行することを見出しました。彼はまた、unshortenedコードのために、すべての原始多項式は、同じ性能のコードが得られることがわかりました。しかし、短縮バージョンについては、原始多項式の選択は違いを生むん。ウルフ[Wolf94j]（X + 1を掛けた）原始多項式を発見した桁CCITTいずれかよりも優れ生成多項式が得られます。 32ビットの冗長ビットのために、彼は4桁によって長さ33の未検出バーストのそれらの確率が異なる2つの多項式の例を発見しました。"
    },
    {
      "indent": 3,
      "text": "It so happens, that for some shortened codes, the minimum distance, or the distribution of the weights, is better than for others derived from different unshortened codes.",
      "ja": "そのように、いくつかの短縮コード、最小距離、または重みの分布のために、異なるunshortenedコードに由来する他のものよりも優れていることが、発生します。"
    },
    {
      "indent": 3,
      "text": "Baicheva, et. al. [Baicheva] made a comprehensive comparison of different generating polynomials of degree 16 of the form g(x) = (x+1)p(x), and of other forms. They computed their Pud for code lengths up to 1024 bits. They measured their \"goodness\" -- if Pud(C,epsilon) <= Pud(C,0.5) and being \"well-behaved\" -- if Pud(C,epsilon) increases with epsilon in the range (0,0.5). The paper gives a comprehensive table that lists which of the polynomials is good and which is well-behaved for different length ranges.",
      "ja": "Baicheva、ら。アル。 【Baicheva】フォームG（X）=（X + 1）P（X）、及び他の形態の度合い16の異なる生成多項式の包括的比較を行いました。コードは、1024ビットまでの長さのために、彼らは彼らのPUDを計算しました。彼らは \"良\" を測定 -  PUD（C、ε）<= PUD（C、0.5）とは、 \"行儀の良い\" された場合 -  PUD（C、イプシロン）は範囲（0,0.5）でイプシロンと共に増加する場合。紙は良好であり、これは、異なる長さの範囲については行儀さ多項式のどの示しています包括的なテーブルを提供します。"
    },
    {
      "indent": 3,
      "text": "For a single burst error, Wolf [Wolf94J] suggested the model of (b:p) burst -- the errors only occur within a span of b bits, and within that span, the errors occur randomly, with a bit error probability 0 <= p <= 1.",
      "ja": "エラーはBビットのスパン内でのみ起こり、そのスパン内で、エラーがランダムに発生し、ビット誤り確率0 <とともに - バースト：単一バーストエラーのため、ウルフ[Wolf94J]（P B）のモデルが提案しました= p <= 1。"
    },
    {
      "indent": 3,
      "text": "For p=0.5, which used to be considered the worst case, it is well known [Wolf94J] that the probability of undetected one burst error of length b <= r is 0, of length b=r+1 is 2^-(r-1), and of b > r+1, is 2^-r, independently of the choice of the primitive polynomial.",
      "ja": "P = 0.5、最悪の場合を考慮しなければ使用されるため、それはよく知られている[Wolf94J]長さbの未検出1つのバースト誤りの確率が<= rは長さbの、0であること= R + 1は2 ^  - （ R-1）、及びBの> R + 1は、独立して原始多項式の選択の、2 ^ -rです。"
    },
    {
      "indent": 3,
      "text": "With Wolf's definition, where p can be different from 0.5, indeed it was found that for a given b there are values of p, different from 0.5 which maximize the probability of undetected (b:p) burst error.",
      "ja": "バーストエラー：pは0.5と異なっていてもよいウルフの定義と、実際には、所与のために検出されない（P B）の確率を最大0.5異なるPの値は、あるbのことがわかりました。"
    },
    {
      "indent": 3,
      "text": "Wolf proved that for a given code, for all b in the range r < b < n, the conditional probability of undetected error for the (n, n-r) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.",
      "ja": "バースト発生に等しい：狼は、与えられたコードに対して、範囲Rにおける全てのBの<bが<N、（N、NR）符号の未検出誤りの条件付き確率は、（P B）は、その与えられたことを証明しましたこの短縮コードはチャネルとバイナリ対称チャネル（散発、独立）のビット誤り確率pで使用される長さbをブロックするために短縮同じコード（同じ生成多項式）、のための未検出誤り確率。"
    },
    {
      "indent": 3,
      "text": "For the IEEE-802.3 used CRC32, Fujiwara et al. [Fujiwara89] measured the weights of all words of all shortened versions of the IEEE 802.3 code of 32 check bits. This code is generated by a primitive polynomial of degree 32:",
      "ja": "IEEE-802.3使用CRC32ため、藤原ら。 【Fujiwara89] 32チェックビットのIEEE 802.3コードのすべての短縮バージョンのすべての単語の重量を測定しました。このコードは32度の原始多項式により生成されます。"
    },
    {
      "indent": 3,
      "text": "g(x) = x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 and hence the designed distance of it is only 3. This distance holds for codes as long as 2^32-1. However, the frame format of the MAC (Media Access Control) of the data link layer in IEEE 802.3, as well as that of the data link layer for the Ethernet (1980) forbid lengths exceeding 12,144 bits. Thus, only such bounded lengths are investigated in [Fujiwara89]. For shortened versions, the minimum distance was found to be 4 for lengths 4096 to 12,144; 5 for lengths 512 to 2048; and even 15 for lengths 33 through 42. A chart of results of calculations of Pud is presented in [Fujiwara89] from which we can see that for codes of length 12,144 and BSC of epsilon = 10^-5 - 10^-4, Pud(12,144,epsilon)= 10^-14 - 10^-13 and for epsilon = 10^-4 - 10^-3, Pud(512,epsilon) = 10^-15, Pud(1024,epsilon) = 10^-14, Pud(2048,epsilon) = 10^-13, Pud(4096,epsilon) = 10^-12 - 10^-11, and Pud(8192,epsilon) = 10^-10 which is rather close to 2^-32.",
      "ja": "G（X）= X ^ 32 + X ^ 26 + X ^ 23 + X ^ 22 + X ^ 16 + X ^ 12 + X ^ 11 + X ^ 10 + X ^ 8 + X ^ 7 + X ^ 5 + X ^ 4 + X ^ 2 + X + 1、従ってそれの設計距離だけ3.この距離は32-1 ^ 2限りコードを保持します。しかし、フレームのIEEE 802.3におけるデータリンク層のMAC（Media Access Control）のフォーマット、ならびにイーサネット（登録商標）のためのデータリンク層の（1980）12144ビットを超える長さを禁じます。したがって、唯一のそのような境界長は[Fujiwara89]で検討されています。短縮バージョンについて、最小距離は、長さ12144の4096のために4であることが見出されました。長さが2048から512 5。さらには15我々は長さ12144及びイプシロンのBSCのコードのためにそれを見ることができるから、PUDの計算の結果のグラフが[Fujiwara89]に提示されている33 42を介して長さ= 10 ^ -5のための -  ^ -4 10、PUD （12144、イプシロン）= 10 ^ -14  -  10 ^ -13及びイプシロンのため= 10 ^ -4  -  10 ^ -3、PUD（512、ε）= 10 ^ -15、PUD（1024、ε）= 10 ^ -14、PUD（2048、イプシロン）= 10 ^ -13、PUD（4096、イプシロン）= 10 ^ -12  -  10 ^ -11、およびPUD（8192、イプシロン）= 2にかなり近いです10 ^ -10 ^ -32。"
    },
    {
      "indent": 3,
      "text": "Castagnoli, et. al. [Castagnoli93] extended Fujiwara's technique for efficiently calculating the minimum distance through the weight distribution of the dual code and explored a large number of CRC codes with 24 and 32 redundancy bit. They explored several codes built as a multiplication of several lower degree irreducible polynomials.",
      "ja": "Castagnoli、ら。アル。 【Castagnoli93】効率的にデュアルコードの重量配分を介して最小距離を計算するための藤原の技術を拡張し、24及び32冗長ビットとCRCコードの多数を探求。彼らは、いくつかの低い程度の既約多項式の乗算として構築されたいくつかのコードを検討しました。"
    },
    {
      "indent": 3,
      "text": "In the popular class of (x+1)*deg31-irreducible-polynomial they explored 47000 polynomials (not all the possible ones). The best they found has d=6 up to block lengths of 5275 and d=4 up to 2^31-1 (bits).",
      "ja": "（X + 1）* deg31-既約多項式の人気のクラスでは、彼らは47000個の多項式（すべてではない可能性のもの）を検討しました。それらが発見された最良の5275の長さ、およびd = 4 31-1 ^ 2まで（ビット）をブロックするまで= 6日間ました。"
    },
    {
      "indent": 3,
      "text": "The investigation was done in 1993 with a special purpose processor.",
      "ja": "調査は特別な目的のプロセッサで、1993年に行われました。"
    },
    {
      "indent": 3,
      "text": "By comparison, the IEEE-802 code has d=4 up to at least 64,000 bits (Fujikura stopped looking at 12,144) and d=3 up to 2^32-1 bits.",
      "ja": "比較により、IEEE-802コードは、D = 4いる少なくとも64,000ビット（フジクラは、12144を見て停止）およびd = 3まで2 ^ 32-1ビットまで。"
    },
    {
      "indent": 3,
      "text": "CRC32/4 (we will refer to it as CRC32C for the remainder of this memo) is 11EDC6F41; IEEE-802 CRC is 104C11DB7, denoting the coefficients as a bit vector.",
      "ja": "CRC32 / 4（このメモの残りのCRC32Cとしてそれを参照する）11EDC6F41あります。 IEEE-802 CRCビットベクトルとして係数を示す、104C11DB7あります。"
    },
    {
      "indent": 3,
      "text": "[Stone98] evaluated the performance of CRC (the AAL5 CRC that is the same as IEEE802) and the TCP and Fletcher checksums on large amounts of data. The results of this experiment indicate a serious weakness of the checksums on real-data that stems from the fact that checksums do not spread the \"hot spots\" in input data. However, the results show that Fletcher behaves by a factor of 2 better than the regular TCP checksum.",
      "ja": "【Stone98】大量のデータにCRCの性能（IEEE802と同じであるAAL5 CRC）とTCPとフレッチャーチェックサムを評価しました。この実験の結果は、チェックサムは、入力データの「ホットスポット」を普及していないという事実から生じる実データのチェックサムの重大な弱点を示しています。しかし、結果はフレッチャーは、通常のTCPチェックサムよりも2よりよい倍に振る舞うことを示しています。"
    },
    {
      "indent": 0,
      "text": "4. Probability of Undetected Errors - Burst Error",
      "section_title": true,
      "ja": "4.未検出エラーの確率 - バーストエラー"
    },
    {
      "indent": 0,
      "text": "4.1 CRC32C (Derivations from [Wolf94j])",
      "section_title": true,
      "ja": "4.1 CRC32C（[Wolf94j]から派生の）"
    },
    {
      "indent": 3,
      "text": "Wolf [Wolf94j] found a 32-bit polynomial of the form g(x) = (1+x)p(x) for which the conditional probability of undetected error, given that a burst of length 33 occurred, is at most (i.e., maximized over all possible channel bit error probabilities within the burst) 4 * 10^- 10.",
      "ja": "ウルフ[Wolf94j】長さ33のバーストが発生したことを所定の未検出誤りの条件付き確率は、最大であるため、フォームG（X）=（1 + x）をP（X）（すなわち、32ビット多項式を発見しました10  - 、4 * 10 ^）バースト内のすべての可能なチャネルのビット誤り確率を超える最大。"
    },
    {
      "indent": 3,
      "text": "We will now figure the probability of undetected error, given that a burst of length 34 occurred, using the result derived in this paper, namely that for a given code, for all b in the range 32 < b < n, the conditional probability of undetected error for the (n, n-32) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.",
      "ja": "現在、範囲32 <B <N、の条件付き確率で全てのBのために、すなわち、所与のコードについて、長さ34のバーストが、この論文で導出結果を使用して、発生したことを考えると、未検出誤り確率を把握します（N、N-32）コードの未検出誤りは、（B：P）は、所与のバーストが発生したときに、長さbをブロックするために短縮同じコード（同じ生成多項式）のための未検出誤り確率に等しいですこの短縮コードは、チャネル（散発、独立）のビット誤り確率pを持つ2元対称通信路で使用されます。"
    },
    {
      "indent": 3,
      "text": "The approximation formula for Pud of sporadic errors, if the weights Ai are distributed binomially, is:",
      "ja": "重みAiは二項分布している場合は散発エラーのPUDのための近似式は、です。"
    },
    {
      "indent": 3,
      "text": "Pud(C, epsilon) =~= Sigma[for i=d to n] ((n choose i) / 2^r )*(1- epsilon)^(n-i) * epsilon^i .",
      "ja": "PUD（C、ε）=〜=シグマ[NへのI =日間]（（n iは選択）/ 2 ^ R）*（1-イプシロン）^（N-I）*イプシロン^ I。"
    },
    {
      "indent": 3,
      "text": "Assuming a very small epsilon, this expression is dominated by i=d. From [Fujiwara89] we know that for 32-bit CRC, for such small n, d=15. Thus, when n grows from 33 to 34, we find that the approximation of Pud grows by (34 choose 15) / (33 choose 15) = 34/19; when n grows further to 35, Pud grows by another 35/20.",
      "ja": "非常に小さなイプシロンと仮定すると、この式は、I = Dによって支配されています。 【Fujiwara89]から、我々は32ビットのCRCのための、そのような小さいnについて、D = 15ということを知っています。このように、nは33から34まで成長、我々は、PUDの近似が（34 15を選択）/（33 15を選択）によって成長= 19分の34が見付かります。 nが35にさらに成長したときに、PUDは、別の35/20によって成長します。"
    },
    {
      "indent": 3,
      "text": "Taking, from Wolf [Wolf94j], the most generous conditional probability, computed with the bit error probability p* that maximizes Pub(p|b), we derive: Pud(p*|33) = 4 x 10^{-10}, yielding Pud(p*|34) = 7.15 x 10^{-10} and Pud(p*|35) = 1.25 x 10^{-9}.",
      "ja": "ウルフ[Wolf94j]、ビット誤り確率P *を用いて計算最も寛大な条件付き確率は、パブが最大化とは、服用（P | B）、我々は派生：PUD（P * | 33）= 4×10 ^ { -  10} = 1.25×10 ^ { -  10} |  -  {10}とPUD（35 P *）= 7.15×10 ^ |、PUD（34 P *）を得ました。"
    },
    {
      "indent": 3,
      "text": "For the density function of the burst length, we assume the Rayleigh density function (the discretization thereof to integers), which is the density of the absolute values of complex numbers of Gauss distribution:",
      "ja": "バースト長の密度関数のために、我々は、ガウス分布の複素数の絶対値の密度であるレイリー密度関数（その整数に離散化）を前提としています"
    },
    {
      "indent": 6,
      "text": "f(x) = x / a^2 exp {-x^2 / 2a^2 } , x>0 .",
      "ja": "F（X）= X / A ^ 2 EXP {-x ^ 2/2（A）^ 2}、X> 0。"
    },
    {
      "indent": 3,
      "text": "This density function has a peak at the parameter a and it decreases smoothly as x increases.",
      "ja": "この密度関数は、パラメータaのピークを有しており、それは、xが増加するにつれて滑らかに減少します。"
    },
    {
      "indent": 3,
      "text": "We take three consecutive bits as the most common burst event once an error does occur, and thus a=3.",
      "ja": "そこで我々は、最も一般的なバーストエラーが発生した後、イベント、および= 3のように三つの連続ビットを取ります。"
    },
    {
      "indent": 3,
      "text": "Now, the probability that a burst of length b occurs in a specific position is the burst error rate, which we estimate as 10^{-10}, times f(b). Calculating for b=33 we find f(33) = 1.94 x 10^{-26}. Together, we found that the probability that a burst of length 33 occurred, starting at a specific position, is 1.94 x 10^{-36}.",
      "ja": "{ -  10}今、長さbのバーストが特定の位置で起こる確率は我々が10 ^として推定バースト誤り率を、ある時間F（B）。 { -  26}、B = 33のために計算我々は、F×10 ^（33）= 1.94を見つけます。 { -  36}一緒に、我々は、長さ33のバーストが特定の位置から始まる、発生確率は、1.94×10 ^であることを見出しました。"
    },
    {
      "indent": 3,
      "text": "Multiplying this by the generous upper bound on the probability that this burst error is not detected, Pud(p*|33), we get that the probability that a burst occurred at a specific position, and is not detected, is 7.79 x 10 ^{-46}.",
      "ja": "このバーストエラーが検出されない確率、PUD（P * | 33）上に結合した寛大な上部のことで、これを掛ける、我々は、バーストが特定の位置で発生し、検出されない確率は、7.79×10 ^であることを取得します{-46}。"
    },
    {
      "indent": 3,
      "text": "Going again along this path of calculations, this time for b=34 we find that f(34) = 4.85*10^{-28}. Multiplying by 10^{-10} and by Pud(p*|34) = 7.15*10^{-10} we find that the probability that a burst of length 34 occurred at a specific position, and is not detected, is 3.46*10^{-47}.",
      "ja": "計算のこの経路に沿って再び行き、B = 34の​​ためのこの時間は、我々は見つけることはf（34）= 4.85×10 ^ { -  28}。 { -  10}およびPUD（P * | 34）で10 ^掛ける= 7.15 * 10 ^ { -  10}我々は長さ34のバーストが特定の位置で発生し、検出されない確率は、3.46であることがわかり* 10 ^ { -  47}。"
    },
    {
      "indent": 3,
      "text": "Last, computing for b=35, we get 1*10^{-29} * 10^{-10} * 1.25*10^{-9} = 1.25*10^{-48}.",
      "ja": "最後に、B = 35のためのコンピューティングは、我々は、^ 1 * 10を取得{ -  29} * 10 ^ { -  10} * 1.25 * 10 ^ { -  10} = 1.25 * 10 ^ { -  48}。"
    },
    {
      "indent": 3,
      "text": "It looks like the total can be approximated at 10^-45 which is within the bounds of what we are looking for.",
      "ja": "合計は、我々が探しているものの範囲内である10 ^ -45で近似することができるように見えます。"
    },
    {
      "indent": 3,
      "text": "When we multiply this by the length of the code (because thus far we calculated for a specific position) we have 10^-45 * 6.5*10^4 = 6.5*10^-41 as an upper bound on the probability of undetected burst error for a code of length 8K Bytes.",
      "ja": "（これまで、我々は、特定の位置のために計算されるため）、我々は、コードの長さによって、これを乗算するとき、我々は未検出バーストの確率の上限として^ -45 * 6.5 * 10 ^ 4 = 6.5×10 ^ -41 10を有しています長8Kバイトコードのエラー。"
    },
    {
      "indent": 3,
      "text": "We can also apply this overestimation for IEEE 802.3.",
      "ja": "また、IEEE 802.3のために、この過大評価を適用することができます。"
    },
    {
      "indent": 3,
      "text": "Comment: 2^{-32} = 2.33*10^{-10}.",
      "ja": "コメント：2 ^ { -  32} = 2.33 * 10 ^ { -  10}。"
    },
    {
      "indent": 0,
      "text": "5. Probability of Undetected Errors - Independent Errors",
      "section_title": true,
      "ja": "未検出エラーの確率5  - 独立したエラー"
    },
    {
      "indent": 0,
      "text": "5.1 CRC (Derivations from [])",
      "section_title": true,
      "ja": "5.1 CRC（[]から派生の）"
    },
    {
      "indent": 3,
      "text": "It is reported in [Castagnoli93] that for BER = epsilon=10^-6, Pud for a single bit error, for a code of length 8KB, for both cases, IEEE-802.3 and CRC32C is 10^{-20}. They also report that CRC32C has distance 4, and IEEE either 3 or 4 for this code length. From this, and the minimum distance of the code of this length, we conclude that with our estimation of epsilon, namely 10^{-11}, we should multiply the reported result by {10^{-5}}^4 = 10^{-20} for CRC32C, and either 10^{-15} or 10^{-20} for IEEE802.3.",
      "ja": "{ -  20} BER =イプシロン= 10 ^ -6ため、単一ビットエラーのPUDは、長さ8キロバイトのコードのため、両方の場合のために、IEEE-802.3とCRC32C 10 ^であること[Castagnoli93]に報告されています。彼らはまた、CRC32C距離4を有することを報告し、この符号長のIEEEは、3又は4のいずれか。 { -  11}、我々はによって報告された結果を乗算する必要があり、この、およびこの長さの符号の最小距離から、我々は、イプシロンの推計で、すなわち10 ^と結論{10 ^ { -  5}} ^ 4 = 10 ^ { -  20} CRC32Cため、及び10のいずれか^ { -  15}または10 ^ { -  20} IEEE802.3ため。"
    },
    {
      "indent": 0,
      "text": "5.2 Checksums",
      "section_title": true,
      "ja": "5.2チェックサム"
    },
    {
      "indent": 3,
      "text": "For independent bit errors, Pud of CRC is approximately 12,000 better than Fletcher, and 22,000 better than Adler. For burst errors, by the simple examples that exist for three consecutive values that can produce an undetected burst, we take the factor to be at least the same.",
      "ja": "独立したビットエラーの場合は、CRCのPUDは、約12,000フレッチャーよりも良い、とアドラーより22,000優れています。バーストエラーのために、未検出のバーストを生成することができる3つの連続した値のために存在する単純な例により、我々は、少なくとも同じになるように係数を取ります。"
    },
    {
      "indent": 3,
      "text": "If in three consecutive bytes, the error values are x, -2x, x then the error is undetected. Even for this error pattern alone, the conditional probability of undetected error, assuming a uniform distribution of data, is 2^-16 = 1.5 * 10^-5. The probability that a burst of length 3 bytes occurs, is f(24) = 3*10^-14. Together: 4.5*10^-19. Multiplying this by the length of the code, we get close to 4.5*10^-16, way worse than the vicinity of 10^-40.",
      "ja": "三つの連続バイトに、エラー値がXであれば、-2X、エラーが検出されないxは。偶数データの均一な分布を仮定すると、単独でこのエラーパターン、未検出誤りの条件付き確率のために、2 ^ -16 = 1.5×10 ^ -5です。長さ3バイトのバーストが発生する確率は、F（24）= 3×10 ^ -14です。一緒：4.5 * 10 ^ -19。コードの長さによって、これを掛ける、我々は10 ^ -40付近より道悪化し、4.5 * 10 ^ -16に近づきます。"
    },
    {
      "indent": 3,
      "text": "The numbers in the table in Section 7 below reflect a more \"tolerant\" difference (10*4).",
      "ja": "第7の表中の数字は、以下でより「寛容」の差（10 * 4）を反映します。"
    },
    {
      "indent": 0,
      "text": "6. Incremental CRC Updates",
      "section_title": true,
      "ja": "6.インクリメンタルCRCアップデート"
    },
    {
      "indent": 3,
      "text": "In some protocols the packet header changes frequently. If the CRC includes the changing part, the CRC will have to be recomputed. This raises two issues:",
      "ja": "いくつかのプロトコルでは、パケットヘッダが頻繁に変化します。 CRCが変化する部分が含まれている場合、CRCが再計算する必要があります。これには二つの問題が発生します。"
    },
    {
      "indent": 6,
      "text": "- the complete computation is expensive - the packet is not protected against unwanted changes between the last check and the recomputation",
      "ja": " - 完全な計算は高価です - パケットが最後のチェックと再計算の間に不要な変更から保護されていません"
    },
    {
      "indent": 3,
      "text": "Fortunately, changes in the header do not imply a need for completed CRC computation. The reason is the linearity of the CRC function. Namely, with I1 and I2 denoting two equal-length blocks of information bits, CRC(I) denoting the CRC check bits calculated for I, and + denoting bitwise modulo-2 addition, we have CRC(I1+I2) = CRC(I1)+CRC(I2).",
      "ja": "幸いなことに、ヘッダの変更が完了したCRC計算の必要性を意味するものではありません。その理由は、CRC関数の直線性です。すなわち、情報ビットの2つの等しい長さのブロックを表すI1とI2と、CRC（I）Iのために計算されたCRCチェックビットを表す、および+示すビット単位のモジュロ2加算、我々はCRC（I1 + I2）= CRC（I1 ）+ CRC（I2）。"
    },
    {
      "indent": 3,
      "text": "Hence, for an IP packet, made of a header h followed by data d followed by CRC bits c = CRC(h d), arriving at a node, which updates header h to become h', the implied update of c is an addition of CRC(h'-h 0), where 0 is an all 0 block of the length of the data block d, and addition and subtraction are bitwise modulo 2.",
      "ja": "データが続くヘッダHからなるIPパケットは、CRCビットC = CRC（HD）、続い日間したがって、H」になるためにヘッダHを更新ノードに到着、Cの暗黙の更新は、添加され0は、すべて0のデータブロックDの長さのブロック、及び加減算であるCRC（H'-H 0）は、ビット単位のモジュロ2です。"
    },
    {
      "indent": 3,
      "text": "We know that a predetermined permutation of bits does not change distance and weight statistics of the codewords. It follows that such a transformation does not change the probability of undetected errors.",
      "ja": "私たちは、所定のビット順列が、コードワードの距離と重量の統計情報を変更しないことを知っています。このような変換が検出されないエラーの確率を変更しないことになります。"
    },
    {
      "indent": 3,
      "text": "We can then conceive the packet as if it was built from data d followed by header h, compute the CRC accordingly, c=CRC(d h), and update at the node with an addition of CRC(0 h'-h)=CRC(h'-h), but on transmission, send the header part before the data and the CRC bits. This will allow a faster computation of the CRC, while still letting the header part lead (no change to the protocol).",
      "ja": "我々は、それがデータから構築されたかのように、ヘッダHに続くdのパケットを考える従ってCRCを計算し、C = CRC（DH）、及びCRC（0 H'-H）= CRCを付加したノードで更新することができ（H'-H）が、送信に、データとCRCビットの前にヘッダ部分を送信します。依然としてヘッダ部リード（プロトコルの変更なしに）させながら、これは、CRCの高速計算を可能にします。"
    },
    {
      "indent": 3,
      "text": "Error detection, i.e., computing the CRC bits by the data and header parts that arrive, and comparing them with the CRC part that arrives together with them, can be done at the final, end-target node only, and the detected errors will include unwanted changes introduced by the intermediate nodes.",
      "ja": "エラー検出は、すなわち、到着するデータとヘッダ部分によってCRCビットを計算し、それらと一緒に到着するCRC部と比較する、唯一の最終エンドターゲットノードで行うことができ、検出されたエラーが含まれます中間ノードによって導入不要な変更。"
    },
    {
      "indent": 3,
      "text": "The analysis of the undetected error probability remains valid according to the following rationale:",
      "ja": "未検出誤り確率の分析は、以下の根拠に基づいて、有効なままです。"
    },
    {
      "indent": 3,
      "text": "The packet started its way as a codeword. On its way, several codewords were added to it (any information followed by the corresponding CRC is a codeword). Let e denote the totality of errors added to the packet, on its long, multi-hop journey. Because the code is linear (i.e., the sum of two codewords is also a codeword) the packet arriving to the end-target node is some codeword + e, and hence, as in our preceding analysis, e is undetected if and only if it is a codeword by itself. This fact is the basis of our above analysis, and hence that analysis applies here too. (See a detailed discussion at [braun01].)",
      "ja": "パケットは、符号語としての道を開始しました。その途中で、いくつかのコードワードは、（対応するCRCに続く任意の情報が符号語である）をそれに加えました。 eはその長い、マルチホップ旅に、パケットに付加エラーの全体を示すものとします。コードは線形であるため、エンドターゲットノードに到着するパケットは、いくつかのコードワード+ E、したがって、我々の前の分析のように、eは場合のみなら未検出である（すなわち、2つの符号語の和は符号語でもある）はそれ自体でコードワードです。この事実は、私たちの上記の分析の基礎であるので、その分析はここにも適用されます。 （[braun01]に詳細な議論を参照）。"
    },
    {
      "indent": 0,
      "text": "7. Complexity of Hardware Implementation",
      "section_title": true,
      "ja": "ハードウェア実装の複雑さ7。"
    },
    {
      "indent": 3,
      "text": "Comparing the cost of various CRC polynomials, we used a tool available at http://www.easics.com/webtools/crctool to implement CRC generators/checkers for various CRC polynomials. The program gives either Verilog or VHDL code after specifying a polynomial, as well as the number of data bits, k, to be handled in one clock cycle. For a serial implementation, k would be one.",
      "ja": "様々なCRC多項式のコストを比較すると、我々は様々なCRC多項式のためのCRCジェネレータ/チェッカーを実装するためにhttp://www.easics.com/webtools/crctoolで利用可能なツールを使用していました。プログラムは、多項式、ならびに1回のクロックサイクルで処理すべきデータビット、K、の数を指定した後VerilogまたはVHDLコードのいずれかを与えます。シリアル実装では、kは1になります。"
    },
    {
      "indent": 3,
      "text": "The cost for either one generator or checker is shown in the following table.",
      "ja": "1つの発電機またはチェッカのいずれかのためのコストは、以下の表に示されています。"
    },
    {
      "indent": 3,
      "text": "The number of 2-input XOR gates, for an un-optimized implementation, required for various values of k:",
      "ja": "kの各値のために必要な非最適化された実装用の2入力XORゲートの数："
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------+\n| Polynomial  | k=32     | k=64     | k=128    |\n+----------------------------------------------+\n| CCITT-CRC32 | 488      | 740      | 1430     |\n+----------------------------------------------+\n| IEEE-802    | 872      | 1390     | 2518     |\n+----------------------------------------------+\n| CRC32Q(Wolf)| 944      | 1444     | 2534     |\n+----------------------------------------------+\n| CRC32C      | 1036     | 1470     | 2490     |\n+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "After optimizing (sharing terms) and in terms of Cells (4 cells per 2 input AND, 7 cells per 2 input XOR, 3 cells per inverter) the cost for two candidate polynomials is shown in the following table.",
      "ja": "（共有用語）を最適化した後、および細胞（2入力当たり4個の細胞及び、2入力XOR当たり7個の細胞、インバータあたり3個の細胞）の観点から2つの候補多項式のためのコストを以下の表に示されています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------+\n| Polynomial  | k=32     | k=64     |\n+-----------------------------------+\n| CCITT-CRC32 | 1855     | 3572     |\n+-----------------------------------+\n| CRC32C      | 4784     | 7111     |\n+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For 32-bit datapath, CCITT-CRC32 requires 40% of the number of cells required by the CRC32C. For a 64-bit datapath, CCITT-CRC32 requires 50% of the number of cells.",
      "ja": "32ビットのデータパスのために、CCITT-CRC32はCRC32Cによって必要とされる細胞の数の40％を必要とします。 64ビットデータパスのために、CCITT-CRC32は、細胞の数の50％を必要とします。"
    },
    {
      "indent": 3,
      "text": "The total size of one of our smaller chips is roughly 1 million cells. The fraction represented by the CRC circuit is less than 1%.",
      "ja": "私たちの小さなチップの1つの合計サイズは、およそ100万個の細胞です。 CRC回路で表される画分が1％未満です。"
    },
    {
      "indent": 0,
      "text": "8. Implementation of CRC32C",
      "section_title": true,
      "ja": "CRC32Cの8.実装"
    },
    {
      "indent": 0,
      "text": "8.1 A Serial Implementation in Hardware",
      "section_title": true,
      "ja": "8.1ハードウェアで実装シリアル"
    },
    {
      "indent": 3,
      "text": "A serial implementation that processes one data bit at a time and performs simultaneous multiplication of the data polynomial by x^32 and division by the CRC32C polynomial is described in the following Verilog [ieee1364] code.",
      "ja": "一度に1つのデータビットを処理し、CRC32C多項式でX ^ 32と分割することにより、データ多項式の同時乗算を行うシリアル実装は、以下のVerilog [ieee1364]コードに記載されています。"
    },
    {
      "indent": 3,
      "text": "/////////////////////////////////////////////////////////////////////\n//File: CRC32_D1.v\n//Date: Tue Feb 26 02:47:05 2002\n//\n//Copyright (C) 1999 Easics NV.\n//This source file may be used and distributed without restriction\n//provided that this copyright statement is not removed from the file\n//and that any derivative work contains the original copyright notice\n//and the associated disclaimer.\n//\n//THIS SOURCE FILE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS\n//OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n//WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n//\n//Purpose: Verilog module containing a synthesizable CRC function\n//* polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)\n//* data width: 1\n//\n//Info: jand@easics.be (Jan Decaluwe)\n//http://www.easics.com\n/////////////////////////////////////////////////////////////////////\nmodule CRC32_D1;\n// polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)\n// data width: 1\nfunction [31:0] nextCRC32_D1;\ninput Data;\ninput [31:0] CRC;\nreg [0:0] D;\nreg [31:0] C;\nreg [31:0] NewCRC;\nbegin\nD[0] = Data;\nC = CRC;\nNewCRC[0] = D[0] ^ C[31];\nNewCRC[1] = D[0] ^ C[0] ^ C[31];\nNewCRC[2] = D[0] ^ C[1] ^ C[31];\nNewCRC[3] = C[2];\nNewCRC[4] = D[0] ^ C[3] ^ C[31];\nNewCRC[5] = D[0] ^ C[4] ^ C[31];\nNewCRC[6] = C[5];\nNewCRC[7] = D[0] ^ C[6] ^ C[31];\nNewCRC[8] = D[0] ^ C[7] ^ C[31];\nNewCRC[9] = C[8];\nNewCRC[10] = D[0] ^ C[9] ^ C[31];\nNewCRC[11] = D[0] ^ C[10] ^ C[31];\nNewCRC[12] = D[0] ^ C[11] ^ C[31];\nNewCRC[13] = C[12];\nNewCRC[14] = C[13];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NewCRC[15] = C[14];\nNewCRC[16] = D[0] ^ C[15] ^ C[31];\nNewCRC[17] = C[16];\nNewCRC[18] = C[17];\nNewCRC[19] = C[18];\nNewCRC[20] = C[19];\nNewCRC[21] = C[20];\nNewCRC[22] = D[0] ^ C[21] ^ C[31];\nNewCRC[23] = D[0] ^ C[22] ^ C[31];\nNewCRC[24] = C[23];\nNewCRC[25] = C[24];\nNewCRC[26] = D[0] ^ C[25] ^ C[31];\nNewCRC[27] = C[26];\nNewCRC[28] = C[27];\nNewCRC[29] = C[28];\nNewCRC[30] = C[29];\nNewCRC[31] = C[30];\nnextCRC32_D1 = NewCRC;\nend\nendfunction\nendmodule",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.2 A Parallel Implementation in Hardware",
      "section_title": true,
      "ja": "8.2ハードウェアでの並列化"
    },
    {
      "indent": 3,
      "text": "A parallel implementation that processes 32 data bits at a time is described in the following Verilog [ieee1364] code. In software implementations, the next state logic is typically implemented by means of tables indexed by the input and the current state.",
      "ja": "一度に32個のデータビットを処理する並列実装は、次のVerilog [ieee1364]コードに記載されています。ソフトウェア実装では、次の状態ロジックは、典型的には、入力及び現在状態によってインデックス付けテーブルを用いて実現されます。"
    },
    {
      "indent": 3,
      "text": "/////////////////////////////////////////////////////////////////////\n//File: CRC32_D32.v\n//Date: Tue Feb 26 02:50:08 2002\n//\n//Copyright (C) 1999 Easics NV.\n//This source file may be used and distributed without restriction\n//provided that this copyright statement is not removed from the file\n//and that any derivative work contains the original copyright notice\n//and the associated disclaimer.\n//\n//THIS SOURCE FILE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS\n//OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n//WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n//\n//Purpose: Verilog module containing a synthesizable CRC function\n//* polynomial: p(0 to 32) := \"100000101111011000111011011110001\"\n//* data width: 32\n//\n//Info: jand@easics.be (Jan Decaluwe)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "//http://www.easics.com\n/////////////////////////////////////////////////////////////////////\nmodule CRC32_D32;\n// polynomial: p(0 to 32) := \"100000101111011000111011011110001\"\n// data width: 32\n// convention: the first serial data bit is D[31]\nfunction [31:0] nextCRC32_D32;\ninput [31:0] Data;\ninput [31:0] CRC;\nreg [31:0] D;\nreg [31:0] C;\nreg [31:0] NewCRC;\nbegin\nD = Data;\nC = CRC;\nNewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^ D[23]\n^\nD[21] ^ D[18] ^ D[17] ^ D[16] ^ D[12] ^ D[9] ^ D[8] ^\nD[7] ^ D[6] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^\nC[6] ^ C[7] ^ C[8] ^ C[9] ^ C[12] ^ C[16] ^ C[17] ^\nC[18] ^ C[21] ^ C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^\nC[30] ^ C[31];\nNewCRC[1] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[26] ^ D[24] ^ D[22]\n^\nD[19] ^ D[18] ^ D[17] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^\nD[7] ^ D[6] ^ D[5] ^ D[1] ^ C[1] ^ C[5] ^ C[6] ^ C[7] ^\nC[8] ^ C[9] ^ C[10] ^ C[13] ^ C[17] ^ C[18] ^ C[19] ^\nC[22] ^ C[24] ^ C[26] ^ C[27] ^ C[28] ^ C[29] ^ C[31];\nNewCRC[2] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[23] ^ D[20]\n^\nD[19] ^ D[18] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^\nD[7] ^ D[6] ^ D[2] ^ C[2] ^ C[6] ^ C[7] ^ C[8] ^ C[9] ^\nC[10] ^ C[11] ^ C[14] ^ C[18] ^ C[19] ^ C[20] ^ C[23] ^\nC[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];\nNewCRC[3] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[24] ^ D[21]\n^\nD[20] ^ D[19] ^ D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^\nD[8] ^ D[7] ^ D[3] ^ C[3] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^\nC[11] ^ C[12] ^ C[15] ^ C[19] ^ C[20] ^ C[21] ^ C[24] ^\nC[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];\nNewCRC[4] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[25] ^ D[22] ^ D[21]\n^\nD[20] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^\nD[8] ^ D[4] ^ C[4] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^\nC[12] ^ C[13] ^ C[16] ^ C[20] ^ C[21] ^ C[22] ^ C[25] ^\nC[27] ^ C[29] ^ C[30] ^ C[31];\nNewCRC[5] = D[31] ^ D[30] ^ D[28] ^ D[26] ^ D[23] ^ D[22] ^ D[21]\n^",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^\nD[5] ^ C[5] ^ C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^\nC[14] ^ C[17] ^ C[21] ^ C[22] ^ C[23] ^ C[26] ^ C[28] ^\nC[30] ^ C[31];\nNewCRC[6] = D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[22]\n^\nD[21] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[11] ^\nD[10] ^ D[9] ^ D[8] ^ D[7] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^\nC[4] ^ C[5] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^\nC[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[21] ^ C[22] ^\nC[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30];\nNewCRC[7] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23]\n^\nD[22] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[12] ^\nD[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^ D[5] ^ D[1] ^\nC[1] ^ C[5] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^\nC[12] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[18] ^ C[22] ^\nC[23] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30] ^ C[31];\nNewCRC[8] = D[25] ^ D[24] ^ D[21] ^ D[19] ^ D[15] ^ D[13] ^ D[11]\n^\nD[10] ^ D[8] ^ D[5] ^ D[4] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^\nC[4] ^ C[5] ^ C[8] ^ C[10] ^ C[11] ^ C[13] ^ C[15] ^\nC[19] ^ C[21] ^ C[24] ^ C[25];\nNewCRC[9] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[23] ^ D[22] ^ D[21]\n^\nD[20] ^ D[18] ^ D[17] ^ D[14] ^ D[11] ^ D[8] ^ D[7] ^\nD[4] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[4] ^\nC[7] ^ C[8] ^ C[11] ^ C[14] ^ C[17] ^ C[18] ^ C[20] ^\nC[21] ^ C[22] ^ C[23] ^ C[27] ^ C[28] ^ C[30] ^ C[31];\nNewCRC[10] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^\nD[22] ^\nD[19] ^ D[17] ^ D[16] ^ D[15] ^ D[7] ^ D[6] ^ D[2] ^\nD[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[6] ^ C[7] ^ C[15] ^\nC[16] ^ C[17] ^ C[19] ^ C[22] ^ C[24] ^ C[25] ^ C[26] ^\nC[27] ^ C[29] ^ C[30];\nNewCRC[11] = D[21] ^ D[20] ^ D[12] ^ D[9] ^ D[6] ^ D[5] ^ D[4] ^\nD[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[3] ^\nC[4] ^ C[5] ^ C[6] ^ C[9] ^ C[12] ^ C[20] ^ C[21];\nNewCRC[12] = D[22] ^ D[21] ^ D[13] ^ D[10] ^ D[7] ^ D[6] ^ D[5] ^\nD[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^\nC[5] ^ C[6] ^ C[7] ^ C[10] ^ C[13] ^ C[21] ^ C[22];\nNewCRC[13] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^\nD[22] ^\nD[21] ^ D[18] ^ D[17] ^ D[16] ^ D[14] ^ D[12] ^ D[11] ^\nD[9] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[9] ^\nC[11] ^ C[12] ^ C[14] ^ C[16] ^ C[17] ^ C[18] ^ C[21] ^\nC[22] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^ C[30] ^ C[31];\nNewCRC[14] = D[30] ^ D[29] ^ D[25] ^ D[22] ^ D[21] ^ D[19] ^",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D[16] ^\nD[15] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[6] ^\nD[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^\nC[6] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[15] ^\nC[16] ^ C[19] ^ C[21] ^ C[22] ^ C[25] ^ C[29] ^ C[30];\nNewCRC[15] = D[31] ^ D[30] ^ D[26] ^ D[23] ^ D[22] ^ D[20] ^\nD[17] ^\nD[16] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^\nD[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^\nC[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^ C[14] ^ C[16] ^\nC[17] ^ C[20] ^ C[22] ^ C[23] ^ C[26] ^ C[30] ^ C[31];\nNewCRC[16] = D[31] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^ D[18] ^\nD[17] ^\nD[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^\nD[5] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[5] ^ C[7] ^ C[8] ^\nC[9] ^ C[10] ^ C[11] ^ C[12] ^ C[15] ^ C[17] ^ C[18] ^\nC[21] ^ C[23] ^ C[24] ^ C[27] ^ C[31];\nNewCRC[17] = D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[19] ^ D[18] ^\nD[16] ^\nD[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^\nD[4] ^ D[3] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^\nC[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^ C[19] ^ C[22] ^\nC[24] ^ C[25] ^ C[28];\nNewCRC[18] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[21] ^\nD[20] ^\nD[19] ^ D[18] ^ D[16] ^ D[14] ^ D[13] ^ D[11] ^ D[10] ^\nD[8] ^ D[6] ^ D[0] ^ C[0] ^ C[6] ^ C[8] ^ C[10] ^ C[11] ^\nC[13] ^ C[14] ^ C[16] ^ C[18] ^ C[19] ^ C[20] ^ C[21] ^\nC[27] ^ C[28] ^ C[29] ^ C[30] ^ C[31];\nNewCRC[19] = D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23] ^ D[22] ^\nD[20] ^\nD[19] ^ D[18] ^ D[16] ^ D[15] ^ D[14] ^ D[11] ^ D[8] ^\nD[6] ^ D[5] ^ D[4] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[4] ^\nC[5] ^ C[6] ^ C[8] ^ C[11] ^ C[14] ^ C[15] ^ C[16] ^\nC[18] ^ C[19] ^ C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[26] ^\nC[27] ^ C[29];\nNewCRC[20] = D[31] ^ D[25] ^ D[24] ^ D[20] ^ D[19] ^ D[18] ^\nD[15] ^\nD[8] ^ D[4] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^\nC[4] ^ C[8] ^ C[15] ^ C[18] ^ C[19] ^ C[20] ^ C[24] ^\nC[25] ^ C[31];\nNewCRC[21] = D[26] ^ D[25] ^ D[21] ^ D[20] ^ D[19] ^ D[16] ^ D[9]\n^\nD[5] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[5] ^\nC[9] ^ C[16] ^ C[19] ^ C[20] ^ C[21] ^ C[25] ^ C[26];\nNewCRC[22] = D[31] ^ D[30] ^ D[28] ^ D[25] ^ D[23] ^ D[22] ^\nD[20] ^\nD[18] ^ D[16] ^ D[12] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D[5] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[5] ^\nC[7] ^ C[8] ^ C[9] ^ C[10] ^ C[12] ^ C[16] ^ C[18] ^\nC[20] ^ C[22] ^ C[23] ^ C[25] ^ C[28] ^ C[30] ^ C[31];\nNewCRC[23] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^\nD[19] ^\nD[18] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[7] ^\nD[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^\nC[7] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^\nC[19] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];\nNewCRC[24] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^\nD[20] ^\nD[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[8] ^\nD[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^\nC[8] ^ C[11] ^ C[12] ^ C[13] ^ C[14] ^ C[17] ^ C[19] ^\nC[20] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];\nNewCRC[25] = D[29] ^ D[28] ^ D[25] ^ D[23] ^ D[20] ^ D[17] ^\nD[16] ^\nD[15] ^ D[14] ^ D[13] ^ D[8] ^ D[6] ^ D[4] ^ D[3] ^\nD[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^\nC[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^ C[23] ^\nC[25] ^ C[28] ^ C[29];\nNewCRC[26] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^\nD[23] ^\nD[15] ^ D[14] ^ D[12] ^ D[8] ^ D[6] ^ D[3] ^ D[1] ^\nD[0] ^ C[0] ^ C[1] ^ C[3] ^ C[6] ^ C[8] ^ C[12] ^ C[14] ^\nC[15] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^\nC[31];\nNewCRC[27] = D[31] ^ D[29] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^\nD[18] ^\nD[17] ^ D[15] ^ D[13] ^ D[12] ^ D[8] ^ D[6] ^ D[5] ^\nD[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[5] ^ C[6] ^\nC[8] ^ C[12] ^ C[13] ^ C[15] ^ C[17] ^ C[18] ^ C[21] ^\nC[23] ^ C[24] ^ C[27] ^ C[29] ^ C[31];\nNewCRC[28] = D[31] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^\nD[21] ^\nD[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[8] ^ D[5] ^\nD[4] ^ D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^\nC[3] ^ C[4] ^ C[5] ^ C[8] ^ C[12] ^ C[13] ^ C[14] ^\nC[17] ^ C[19] ^ C[21] ^ C[22] ^ C[23] ^ C[24] ^ C[26] ^\nC[27] ^ C[31];\nNewCRC[29] = D[28] ^ D[27] ^ D[25] ^ D[24] ^ D[23] ^ D[22] ^\nD[20] ^\nD[18] ^ D[15] ^ D[14] ^ D[13] ^ D[9] ^ D[6] ^ D[5] ^\nD[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^\nC[5] ^ C[6] ^ C[9] ^ C[13] ^ C[14] ^ C[15] ^ C[18] ^\nC[20] ^ C[22] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28];\nNewCRC[30] = D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[23] ^\nD[21] ^",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D[19] ^ D[16] ^ D[15] ^ D[14] ^ D[10] ^ D[7] ^ D[6] ^\nD[5] ^ D[4] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[4] ^ C[5] ^\nC[6] ^ C[7] ^ C[10] ^ C[14] ^ C[15] ^ C[16] ^ C[19] ^\nC[21] ^ C[23] ^ C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29];\nNewCRC[31] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^\nD[22] ^\nD[20] ^ D[17] ^ D[16] ^ D[15] ^ D[11] ^ D[8] ^ D[7] ^\nD[6] ^ D[5] ^ D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[5] ^ C[6] ^\nC[7] ^ C[8] ^ C[11] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^\nC[22] ^ C[24] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30];\nnextCRC32_D32 = NewCRC;\nend\nendfunction",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.3 Some Hardware Implementation Comments",
      "section_title": true,
      "ja": "8.3いくつかのハードウェア実装のコメント"
    },
    {
      "indent": 3,
      "text": "The iSCSI spec specifies that the most significant 32 bits of the data be complemented prior to performing the CRC computation. For most implementations of the CRC algorithm, such as the ones described here, which perform simultaneous multiplication by x^32 and division by the CRC polynomial, this is equivalent to initializing the CRC register to ones regardless of the CRC polynomial. For other implementations, in particular one that only performs division by the CRC polynomial (and for which the prescribed multiplication by x^32 is performed externally) initializing the CRC register to ones does not have the same effect as complementing the most significant 32 bits of the message. With such implementations, for the CRC32c polynomial, initializing the CRC register to 0x2a26f826 has the same effect as complementing the most significant 32 bits of the data. See reference [Tuikov&Cavanna] for more details.",
      "ja": "iSCSIの仕様は、データの上位32ビットがCRC演算を実行する前に補完するように指定します。このようなCRC多項式でX ^ 32及び分割により同時乗算を実行ここで説明されたもののようなCRCアルゴリズムのほとんどの実装については、これはCRCに関係なくCRC多項式のものに登録する初期化に相当します。のみCRC多項式で除算を行う特定の一つに他の実装のための最も重要な32ビットを補完するようにCRCが同じ効果を有していないものに登録する初期化（及びそのためのX ^ 32により所定の乗算が外部で実行されます）メッセージ。 0x2a26f826にCRCレジスタを初期化CRC32C多項式のためのそのような実装、とデータの最上位32ビットを補完するのと同じ効果を有します。詳細は、リファレンス[Tuikov＆Cavanna]を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.4 Fast Hardware Implementation References",
      "section_title": true,
      "ja": "8.4高速ハードウェア実装参照"
    },
    {
      "indent": 3,
      "text": "Fast hardware implementations start from a canonic scheme (as the one presented in 7.2) and optimize it based on different criteria. Two classic papers on this subject are [Albertengo1990] and [Glaise1997]. A more modern (and systematic) approach can be found in [Shie2001] and [Sprachman2001].",
      "ja": "高速ハードウェア実装は（7.2に提示された1つのような）カノンスキームから開始し、異なる基準に基づいて最適化します。この主題上の2本の古典的な論文が[Albertengo1990]で、[Glaise1997]。より現代的な（かつ体系）アプローチは、[Sprachman2001] [Shie2001]に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "9. Summary and Conclusions",
      "section_title": true,
      "ja": "9.まとめと結論"
    },
    {
      "indent": 3,
      "text": "The following table is a summary of the error detection capabilities of the different codes analyzed. In the table, d is the minimal distance at block length block (in bits), i/byte - software instructions/byte, Table size (if table lookup needed), T-look number of lookups/byte, Pudb - Pud burst and Puds - Pud sporadic:",
      "ja": "次の表は、分析異なるコードのエラー検出機能の概要です。検索/バイトのTルック番号、Pudb、ソフトウェア命令/バイト、テーブルサイズ（テーブルルックアップが必要な場合） -   - 表において、Dは、ブロック長ブロック（ビットで）、I /バイトに最小距離でPUDバーストとたPUD  -  PUDは散発："
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------------------+\n| Code      |d| Block |i/Byte|Tsize|T-look| Pudb   | Puds   |\n+-----------------------------------------------------------+\n| Fletcher32|3| 2^19  | 2    |  -  | -    | 10^-37 | 10^-36 |\n+-----------------------------------------------------------+\n| Adler32   |3| 2^19  | 3    |  -  | -    | 10^-36 | 10^-35 |\n+-----------------------------------------------------------+\n| IEEE-802  |3| 2^16  | 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |\n+-----------------------------------------------------------+\n| CRC32C    |3| 2^31-1| 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |\n+-----------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The probabilities for undetected errors in the above table are computed assuming uniformly distributed data. For real data - that can be biased - [Stone98], checksums behave substantially worse than CRCs.",
      "ja": "上記表中の未検出のエラーの確率は一様に分布データを仮定して計算されます。バイアスをかけることができます -   - 実際のデータについて[Stone98]、チェックサムは、CRCのよりも実質的に悪化振る舞います。"
    },
    {
      "indent": 3,
      "text": "Considering the protection level it offers, the lack of sensitivity for biased data and the large block it can protect, we think that CRC32C is a good choice as a basic error detection mechanism for iSCSI.",
      "ja": "それが提供する保護レベルを考慮すると、バイアスされたデータと、それが保護することができ、大きなブロックの感度の欠如は、我々はCRC32Cは、iSCSIの基本的なエラー検出メカニズムとしては良い選択だと思います。"
    },
    {
      "indent": 3,
      "text": "Please observe also that burst errors characterized by a fixed average time will have a higher impact on error detection capability as the speed of the channels (machines and networks) increases. The only way to keep the Pud within bounds for the long-term is to reduce the BER by using better coding of lower levels of the channel.",
      "ja": "チャネル（マシンとネットワーク）の速度が増加するように固定された平均時間によって特徴付けそのバーストエラーは、エラー検出能力に高い影響を与えるも遵守してください。長期の境界内PUDを維持する唯一の方法は、チャネルのより低いレベルのより良好な符号化を用いてBERを低減することです。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "These codes detect unintentional changes to data such as those caused by noise. In an environment where an attacker can change the data, it can also change the error-detection code to match the new data. Therefore, the error-detection codes overviewed here do not provide protection against attacks. Indeed, these codes are not intended for security purposes; they are meant to be used within some application, and the application's threat model and security design control the security considerations for the use of the CRC.",
      "ja": "これらのコードは、このようなノイズに起因するもののようなデータへの意図しない変更を検出します。攻撃者がデータを変更することができる環境では、それはまた、新しいデータを一致させるために、エラー検出コードを変更することができます。したがって、ここで概観エラー検出コードは、攻撃に対する保護を提供していません。確かに、これらのコードは、セキュリティ目的のために意図されていません。彼らはいくつかのアプリケーション内で使用されることを意味し、そしてアプリケーションの脅威モデルとセキュリティ設計は、CRCを使用するためのセキュリティの考慮事項を制御しています。"
    },
    {
      "indent": 0,
      "text": "11. References and Bibliography",
      "section_title": true,
      "ja": "11.参考文献と文献目録"
    },
    {
      "indent": 3,
      "text": "[Albertengo1990] G. Albertengo, R. Sisto, \"Parallel CRC Generation IEEE Micro\", Vol. 10, No. 5, October 1990, pp. 63- 71.",
      "ja": "[Albertengo1990] G. Albertengo、R.シスト、 \"パラレルCRCジェネレーションIEEEマイクロ\"、巻。 10、第5号、1990年10月、頁。63- 71。"
    },
    {
      "indent": 3,
      "text": "[Arazi] B Arazi, \"A commonsense Approach to the Theory of Error Correcting codes\".",
      "ja": "【Arazi] B Arazi、「誤り訂正符号の理論に常識的なアプローチ」。"
    },
    {
      "indent": 3,
      "text": "[Baicheva] T Baicheva, S Dodunekov and P Kazakov, \"Undetected error probability performance of cyclic redundancy-check codes of 16-bit redundancy\", IEEE Proceedings on Communications, 147:253-256, October 2000.",
      "ja": "【Baicheva] T Baicheva、S Dodunekov及びP Kazakov、「16ビットの冗長性の巡回冗長検査符号の未検出誤り確率性能」、通信に関するIEEE会報、147：253-256、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[Black] \"Fast CRC32 in Software\" by Richard Black, 1994, at www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crc. html.",
      "ja": "www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crcでリチャード・ブラック、1994による「ソフトウェアにおける高速CRC32」[ブラック]、。 HTML。"
    },
    {
      "indent": 3,
      "text": "[Castagnoli93] Guy Castagnoli, Stefan Braeuer and Martin Herrman \"Optimization of Cyclic Redundancy-Check Codes with 24 and 32 Parity Bits\", IEEE Transact. on Communications, Vol. 41, No. 6, June 1993.",
      "ja": "[Castagnoli93]ガイCastagnoli、ステファンBraeuerとマーティンHerrman「24と32パリティビットと巡回冗長検査符号の最適化」、IEEEのTransact。コミュニケーション、巻上。 41、第6号、1993年6月。"
    },
    {
      "indent": 3,
      "text": "[braun01] Florian Braun and Marcel Waldvogel, \"Fast Incremental CRC Updates for IP over ATM Networks\", IEEE, High Performance Switching and Routing, 2001, pp. 48-52.",
      "ja": "[braun01]フロリアン・ブラウンとマルセルWaldvogel、 \"ATMネットワーク上のIPのための高速増分CRC更新\"、IEEE、高性能スイッチングおよびルーティング、2001年、頁48-52。"
    },
    {
      "indent": 3,
      "text": "[FITS] \"NASA FITS documents\" at http://heasarc.gsfc.nasa. gov/docs/heasarc/ofwg/docs/general/checksum/node26. html.",
      "ja": "[FITS]のhttpで \"NASAは、文書をFITS\"：//heasarc.gsfc.nasaを。 GOV /ドキュメント/ heasarc / ofwg /ドキュメント/一般/サム/ node26。 HTML。"
    },
    {
      "indent": 3,
      "text": "[Fujiwara89] Toru Fujiwara, Tadao Kasami, and Shu Lin, \"Error detecting capabilities of the shortened hamming codes adopted forerror detection in IEEE standard 802.3\", IEEE Transactions on Communications, COM-37:986989, September 1989.",
      "ja": "【Fujiwara89]徹藤原、嵩忠雄、及びシュウリン、「IEEEで検出forerror採用短縮ハミング符号の誤り検出能力標準802.3」、コミュニケーションズ、COM-37上のIEEEトランザクション：986989、1989年9月。"
    },
    {
      "indent": 3,
      "text": "[Glaise1997] Glaise, R. J., \"A two-step computation of cyclic redundancy code CRC-32 for ATM networks\", IBM Journal of Research and Development, Volume 41, Number 6, 1997.",
      "ja": "【Glaise1997] Glaise、R. J.、 \"ATMネットワークのための巡回冗長コードCRC-32の二段階の計算\"、研究開発のIBMジャーナル、41巻、第6号、1997。"
    },
    {
      "indent": 3,
      "text": "[ieee1364] IEEE Standard Hardware Description Language Based on the Verilog Hardware Description Language, IEEE Standard 1364-1995, December 1995.",
      "ja": "Verilogのハードウェア記述言語に基づいて、[ieee1364] IEEE標準のハードウェア記述言語、IEEE規格1364年から1995年、1995年12月。"
    },
    {
      "indent": 3,
      "text": "[LinCostello] S. Lin and D.J. Costello, Jr., \"Error Control Coding: Fundamentals and Applications\", Englewood Cliffs, NJ: Prentice Hall, 1983.",
      "ja": "【LinCostello] S.リンおよびD.J.コステロ、ジュニア、「エラー制御コーディング：基礎と応用」、イングルウッドクリフス、ニュージャージー州：プレンティスホール、1983。"
    },
    {
      "indent": 3,
      "text": "[Peterson] W Wesley Peterson & E J Weldon - Error Correcting Codes - First Edition 1961/Second Edition 1972.",
      "ja": "[ピーターソン] Wウェズリー・ピーターソン＆E Jウェルドン - 誤り訂正符号 -  1972初版1961年/第二版。"
    },
    {
      "indent": 3,
      "text": "[RFC2026] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP 9, RFC 2026, October 1996.",
      "ja": "[RFC2026]ブラドナーの、S.、 \"インターネット標準化プロセス - リビジョン3\"、BCP 9、RFC 2026、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[Ritter] Ritter, T. 1986. The Great CRC Mystery. Dr. Dobb's Journal of Software Tools. February. 11(2): 26-34, 76-83.",
      "ja": "[リッター]リッター、T. 1986年グレートCRCミステリー。ソフトウェアツールの博士ドッブのジャーナル。 2月。 11（2）：26-34、76-83。"
    },
    {
      "indent": 3,
      "text": "[Polynomials] \"Information on Primitive and Irreducible Polynomials\" at http://www.theory.csc.uvic.ca/~cos/ inf/neck/PolyInfo.html.",
      "ja": "[多項式] http://www.theory.csc.uvic.ca/~cos/ INF /首/ PolyInfo.htmlで「原始及び既約多項式に関する情報」。"
    },
    {
      "indent": 3,
      "text": "[RFC1146] Zweig, J. and C. Partridge, \"TCP Alternate Checksum Options\", RFC 1146, March 1990.",
      "ja": "[RFC1146]ツヴァイク、J.とC.ヤマウズラ、 \"TCP代替チェックサムオプション\"、RFC 1146、1990年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツ、P.およびJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[Shie2001] Ming-Der Shieh, et. al, \"A Systematic Approach for Parallel CRC Computations\", Journal of Information Science and Engineering, Vol.17 No.3, pp.445-461.",
      "ja": "【Shie2001]明デアShiehら。ら、「並列CRC計算のための体系的なアプローチ」、情報科学や工学ジャーナル、Vol.17 3号、pp.445-461。"
    },
    {
      "indent": 3,
      "text": "[Sprachman2001] Michael Sprachman, \"Automatic Generation of Parallel CRC Circuits\", IEEE Design & Test May-June 2001.",
      "ja": "[Sprachman2001]マイケルSprachman、「並列CRC回路の自動生成、」IEEEデザイン＆テスト月 -  6月の第二千一"
    },
    {
      "indent": 3,
      "text": "[Stone98] J. Stone et. al., \"Performance of Checksums and CRC's over Real Data\", IEEE/ACM Transactions on Networking, Vol. 6, No. 5, October 1998.",
      "ja": "【Stone98] J.ストーンら。ら、「実データオーバーチェックサムとCRCののパフォーマンス」、ネットワーキング、巻上のIEEE / ACM取引。 6、第5号、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[Williams] Ross Williams - A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS widely available on the net - (e.g., ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt)",
      "ja": "【ウィリアムズ】ロス・ウィリアムズ - （例えば、ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt） - ネット上で広く利用可能なCRCエラー検出アルゴリズム無痛GUIDE"
    },
    {
      "indent": 3,
      "text": "[Wolf82] J.K. Wolf, Arnold Michelson and Allen Levesque, \"On the probability of undetected error for linear block codes\", IEEE Transactions on Communications, COM-30: 317-324, 1982.",
      "ja": "【Wolf82] J.K.ウルフ、アーノルド・マイケルソンとアレンレベスク、「線形ブロック符号の見逃し誤り確率について」、通信に関するIEEEトランザクション、COM-30：317-324、1982。"
    },
    {
      "indent": 3,
      "text": "[Wolf88] J.K. Wolf, R.D. Blackeney, \"An Exact Evaluation of the Probability of Undetected Error for Certain Shortened Binary CRC Codes\", Proc. MILCOM - IEEE 1988.",
      "ja": "【Wolf88] J.K.ウルフ、R.D. Blackeney、「特定の短縮バイナリCRCコードのための見逃し誤り確率の正確な評価」、PROC。 MILCOM  -  IEEE 1988。"
    },
    {
      "indent": 3,
      "text": "[Wolf94J] J.K. Wolf and Dexter Chun, \"The single burst error detection performance of binary cyclic codes\", IEEE Transactions on Communications COM-42:11-13, January 1994.",
      "ja": "【Wolf94J] J.K.通信COM-42に狼とデクスターチョン、「二進巡回符号の単一バースト誤り検出性能」、IEEEトランザクション：11-13、1994年1月。"
    },
    {
      "indent": 3,
      "text": "[Wolf94O] Dexter Chun and J.K. Wolf, \"Special Hardware for computing the probability of undetected error for certain binary crc codes and test results\", IEEE Transactions on Communications, COM-42:2769-2772.",
      "ja": "【Wolf94O]デクスターチュンとJ.K.オオカミ、「特定のバイナリCRCコードとテスト結果の未検出誤り確率を計算するための特別なハードウェア」、通信に関するIEEEトランザクション、COM-42：2769から2772。"
    },
    {
      "indent": 3,
      "text": "[Tuikov&Cavanna] Luben Tuikov and Vicente Cavanna, \"The iSCSI CRC32C Digest and the Simultaneous Multiply and Divide Algorithm\", January 30, 2002. White paper distributed to the IETF ips iSCSI reflector.",
      "ja": "【Tuikov＆Cavanna] Luben TuikovとビセンテCavanna、「iSCSIのCRC32Cダイジェストと同時乗アルゴリズムを分割」、1月30日IETF IPSのiSCSIリフレクタに配布2002ホワイトペーパー。"
    },
    {
      "indent": 0,
      "text": "12. Acknowledgements",
      "section_title": true,
      "ja": "12.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Matt Wakeley for providing us with the motivation to co-author this paper and for helpful discussions on the subject matter, during his employment with Agilent.",
      "ja": "私たちは、アジレントとの彼の雇用の間に、共著者にモチベーションでこの論文を私たちに提供するための主題に有用な議論のためのマットWakeleyに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "13. Authors' Addresses",
      "section_title": true,
      "ja": "13.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Julian Satran IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: julian_satran@il.ibm.com",
      "ja": "ジュリアンSatran IBM、ハイファ研究所マタム - アドバンスト・テクノロジー・センターハイファ31905、イスラエルメール：julian_satran@il.ibm.com"
    },
    {
      "indent": 3,
      "text": "Dafna Sheinwald IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: Dafna_Sheinwald@il.ibm.com",
      "ja": "DAFNA Sheinwald IBM、ハイファ研究所マタム - アドバンスト・テクノロジー・センターハイファ31905、イスラエルメール：Dafna_Sheinwald@il.ibm.com"
    },
    {
      "indent": 3,
      "text": "Pat Thaler Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: pat_thaler@agilent.com",
      "ja": "パットターラーアジレント・テクノロジー1101クリークサイドリッジドライブスイート100、M / S RH21ローズ、CA 95661 Eメール：pat_thaler@agilent.com"
    },
    {
      "indent": 3,
      "text": "Vicente Cavanna Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: vince_cavanna@agilent.com",
      "ja": "ビセンテCavannaアジレント・テクノロジー1101クリークサイドリッジドライブスイート100、M / S RH21ローズ、CA 95661 Eメール：vince_cavanna@agilent.com"
    },
    {
      "indent": 0,
      "text": "14. Full Copyright Statement",
      "section_title": true,
      "ja": "14.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}