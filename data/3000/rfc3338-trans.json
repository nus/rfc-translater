{
  "title": {
    "text": "RFC 3338 - Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)",
    "ja": "RFC 3338 - デュアルスタックは、（BIA）の \"bump-in-the-API\" 使用しているホスト"
  },
  "number": 3338,
  "created_at": "2019-10-27 03:34:26.471980+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             S. Lee\nRequest for Comments: 3338                                     M-K. Shin\nCategory: Experimental                                          Y-J. Kim\n                                                                    ETRI\n                                                             E. Nordmark\n                                                               A. Durand\n                                                        Sun Microsystems\n                                                            October 2002",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a mechanism of dual stack hosts using a technique called \"Bump-in-the-API\"(BIA) which allows for the hosts to communicate with other IPv6 hosts using existing IPv4 applications. The goal of this mechanism is the same as that of the Bump-in-the-stack mechanism, but this mechanism provides the translation method between the IPv4 APIs and IPv6 APIs. Thus, the goal is simply achieved without IP header translation.",
      "ja": "このドキュメントと呼ばれる技術を使用して、デュアルスタックホストの機構を指定の「bump-in-the-API」ホストは、既存のIPv4アプリケーションを使用して、他のIPv6ホストと通信することを可能にする（BIA）。この機構の目的は、バンプ・イン・スタック機構と同じであるが、この機構は、IPv4とIPv6のAPIのAPIとの間の変換方法を提供します。したがって、目標は、単にIPヘッダの変換なしに達成されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents:",
      "ja": "目次："
    },
    {
      "indent": 3,
      "text": "1.  Introduction ................................................  2\n2.  Applicability and Disclaimer ................................  3\n2.1 Applicability ...............................................  3\n2.2 Disclaimer ..................................................  4\n3.  Dual Stack Host Architecture Using BIA ......................  4\n3.1 Function Mapper .............................................  4\n3.2 Name Resolver ...............................................  5\n3.3 Address Mapper ..............................................  5\n4.  Behavior Example ............................................  6\n4.1 Originator Behavior .........................................  6\n4.2 Recipient Behavior ..........................................  8\n5.  Considerations  ............................................. 10\n5.1 Socket API Conversion ....................................... 10\n5.2 ICMP Messages Handling ...................................... 10\n5.3 IPv4 Address Pool and Mapping Table ......................... 10\n5.4 Internally Assigned IPv4 Addresses .......................... 10\n5.5 Mismatch Between DNS Result and Peer Application Version .... 11\n5.6 Implementation Issues ....................................... 11\n6.  Limitations ................................................. 12\n7.  Security Considerations ..................................... 12\n8.  Acknowledgments ............................................. 12\n9.  References .................................................. 12\nAppendix:  API list intercepted by BIA .......................... 14\nAuthors Addresses ............................................... 16\nFull Copyright Statement ........................................ 17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "RFC2767 [BIS] specifies a host translation mechanism using a technique called \"Bump-in-the-Stack\". It translates IPv4 into IPv6, and vice versa using the IP conversion mechanism defined in [SIIT]. BIS allows hosts to communicate with other IPv6 hosts using existing IPv4 applications. However, this approach is to use an API translator which is inserted between the TCP/IP module and network card driver, so that it has the same limitations as the [SIIT] based IP header translation methods. In addition, its implementation is dependent upon the network interface driver.",
      "ja": "RFC2767は、[BIS]の \"bump-in-the-スタック\" と呼ばれる技術を使用して、ホスト変換メカニズムを指定します。それは、IPv6内IPv4のを変換し、そして[SIIT]で定義されたIP変換機構を用いて、その逆。 BISは、ホストは、既存のIPv4アプリケーションを使用して、他のIPv6ホストと通信することを可能にします。しかし、このアプローチは、それが[SIIT]ベースのIPヘッダ変換方法と同じ制限を有するように、TCP / IPモジュールとネットワークカードドライバの間に挿入されるAPIトランスレータを使用することです。加えて、その実装は、ネットワーク・インタフェース・ドライバに依存しています。"
    },
    {
      "indent": 3,
      "text": "This document specifies a new mechanism of dual stack hosts called Bump-in-the-API(BIA) technique. The BIA technique inserts an API translator between the socket API module and the TCP/IP module in the dual stack hosts, so that it translates the IPv4 socket API function into IPv6 socket API function and vice versa. With this mechanism, the translation can be simplified without IP header translation.",
      "ja": "この文書では、バンプ・イン・-API（BIA）技術と呼ばれるデュアルスタックホストの新しいメカニズムを指定します。それは、IPv6ソケットAPI関数とその逆にIPv4ソケットAPI関数を変換するようにBIA技術は、ソケットAPIモジュールとデュアルスタックホストにTCP / IPモジュールとの間のAPIの翻訳を挿入します。このメカニズムでは、翻訳は、IPヘッダ変換せずに単純化することができます。"
    },
    {
      "indent": 3,
      "text": "Using BIA, the dual stack host assumes that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks on the local node.",
      "ja": "BIAを使用して、デュアルスタックホストは、TCP（UDP）/ IPv4とTCP（UDP）の両方が存在することを前提として/ IPv6は、ローカル・ノード上でスタックします。"
    },
    {
      "indent": 3,
      "text": "When IPv4 applications on the dual stack communicate with other IPv6 hosts, the API translator detects the socket API functions from IPv4 applications and invokes the IPv6 socket API functions to communicate with the IPv6 hosts, and vice versa. In order to support communication between IPv4 applications and the target IPv6 hosts, pooled IPv4 addresses will be assigned through the name resolver in the API translator.",
      "ja": "デュアルスタック上のIPv4アプリケーションが他のIPv6ホストと通信するとき、APIトランスレータは、IPv4アプリケーションからソケットAPI関数を検出し、IPv6ホストと通信するためのIPv6ソケットAPI関数を呼び出し、その逆も同様です。 IPv4アプリケーションとターゲットIPv6ホストとの間の通信をサポートするために、IPv4アドレスがAPIトランスレータにおけるネームリゾルバを介して割り当てられるプール。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC 2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC 2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses terms defined in [IPv6],[TRANS-MECH] and [BIS].",
      "ja": "この文書は、[IPv6の]で定義された用語を使用して[TRANS-MECH]及び[BIS]。"
    },
    {
      "indent": 0,
      "text": "2. Applicability and Disclaimer",
      "section_title": true,
      "ja": "2.適用性および免責事項"
    },
    {
      "indent": 0,
      "text": "2.1 Applicability",
      "section_title": true,
      "ja": "2.1適用性"
    },
    {
      "indent": 3,
      "text": "The main purposes of BIA are the same as BIS [BIS]. It makes IPv4 applications communicate with IPv6 hosts without any modification of those IPv4 applications. However, while BIS is for systems with no IPv6 stack, BIA is for systems with an IPv6 stack, but on which some applications are not yet available on IPv6 and source code is not available preventing the application from being ported. It's good for early adopters who do not have all applications handy, but not for mainstream production usage.",
      "ja": "BIAの主な目的は、ビス[ビス]と同じです。これは、IPv4アプリケーションは、それらのIPv4アプリケーションの変更なしでIPv6ホストと通信します。 BISはないIPv6スタックを備えたシステムのためであるがしかし、BIAは、IPv6スタックを備えたシステムのためのものであるが、その上にいくつかのアプリケーションは、IPv6にまだ利用できないとソースコードが移植されるのアプリケーションを防止できません。それは主流の生産の使用に便利ではなく、すべてのアプリケーションを持っていない早期導入のために良いことです。"
    },
    {
      "indent": 3,
      "text": "There is an issue about a client node running BIA trying to contact a dual stack node on a port number that is only associated with an IPv4 application (see section 5.5). There are 2 approaches.",
      "ja": "IPv4のみのアプリケーションに関連付けられているポート番号でデュアルスタックノードに連絡しようとしているBIAを実行しているクライアントノードについての問題があります（セクション5.5を参照してください）。 2つのアプローチがあります。"
    },
    {
      "indent": 3,
      "text": "- The client application SHOULD cycle through all the addresses and end up trying the IPv4 one.",
      "ja": " - クライアント・アプリケーションは、必要があるすべてのアドレスを循環し、IPv4 1をしようとしてしまいます。"
    },
    {
      "indent": 3,
      "text": "- BIA SHOULD do the work.",
      "ja": " -  BIAは、作業を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "It is not clear at this time which behavior is desirable (it may very well be application dependent), so we need to get feedback from experimentation.",
      "ja": "それは行動が（それは非常によくアプリケーション依存する可能性がある）ことが望ましい。この時点では明らかではないので、我々は実験からのフィードバックを取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2 Disclaimer",
      "section_title": true,
      "ja": "2.2免責事項"
    },
    {
      "indent": 3,
      "text": "BIA SHOULD NOT be used for an IPv4 application for which source code is available. We strongly recommend that application programmers SHOULD NOT use this mechanism when application source code is available. As well, it SHOULD NOT be used as an excuse not to port software or delay porting.",
      "ja": "BIAは、ソースコードが利用可能であるIPv4のアプリケーションには使用できません。私たちは強く、アプリケーションのソースコードが利用可能な場合にアプリケーションプログラマは、このメカニズムを使用してはならないことをお勧めします。同様に、それはないポートソフトウェアまたは遅延移植への言い訳として使用しないでください。"
    },
    {
      "indent": 0,
      "text": "3. Dual Stack Host Architecture Using BIA",
      "section_title": true,
      "ja": "BIAを使用3.デュアルスタックホストのアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the architecture of the host in which BIA is installed.",
      "ja": "図1は、BIAがインストールされているホストのアーキテクチャを示しています。"
    },
    {
      "indent": 15,
      "text": "+----------------------------------------------+\n| +------------------------------------------+ |\n| |                                          | |\n| |             IPv4 applications            | |\n| |                                          | |\n| +------------------------------------------+ |\n| +------------------------------------------+ |\n| |           Socket API (IPv4, IPv6)        | |\n| +------------------------------------------+ |\n| +-[ API translator]------------------------+ |\n| | +-----------+ +---------+ +------------+ | |\n| | | Name      | | Address | | Function   | | |\n| | | Resolver  | | Mapper  | | Mapper     | | |\n| | +-----------+ +---------+ +------------+ | |\n| +------------------------------------------+ |\n| +--------------------+ +-------------------+ |\n| |                    | |                   | |\n| |    TCP(UDP)/IPv4   | |   TCP(UDP)/IPv6   | |\n| |                    | |                   | |\n| +--------------------+ +-------------------+ |\n+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 1 Architecture of the dual stack host using BIA",
      "ja": "BIAを使用するデュアルスタックホストの図1のアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Dual stack hosts defined in RFC2893 [TRANS-MECH] need applications, TCP/IP modules and addresses for both IPv4 and IPv6. The proposed hosts in this document have an API translator to communicate with other IPv6 hosts using existing IPv4 applications. The API translator consists of 3 modules, a name resolver, an address mapper and a function mapper.",
      "ja": "RFC2893 [TRANS-MECH]で定義されたデュアルスタックホストがIPv4とIPv6の両方のためのアプリケーション、TCP / IPモジュールとアドレスを必要とします。この文書で提案されているホストは既存のIPv4アプリケーションを使用して、他のIPv6ホストと通信するためのAPIトランスレータを持っています。 APIトランスレータは3つのモジュール、名前解決、アドレスマッパーと関数マッパーで構成されています。"
    },
    {
      "indent": 0,
      "text": "3.1 Function Mapper",
      "section_title": true,
      "ja": "3.1機能マッパー"
    },
    {
      "indent": 3,
      "text": "It translates an IPv4 socket API function into an IPv6 socket API function, and vice versa.",
      "ja": "これは、IPv6ソケットAPI関数、およびその逆にIPv4ソケットAPI関数を変換します。"
    },
    {
      "indent": 3,
      "text": "When detecting the IPv4 socket API functions from IPv4 applications, it intercepts the function call and invokes new IPv6 socket API functions which correspond to the IPv4 socket API functions. Those IPv6 API functions are used to communicate with the target IPv6 hosts. When detecting the IPv6 socket API functions from the data received from the IPv6 hosts, it works symmetrically in relation to the previous case.",
      "ja": "IPv4アプリケーションからIPv4ソケットAPI関数を検出した場合、それは関数呼び出しをインターセプトし、IPv4ソケットAPI関数に対応する新たなIPv6ソケットAPI関数を呼び出します。それらのIPv6 API関数は、ターゲットのIPv6ホストとの通信に使用されます。 IPv6ホストから受信したデータからIPv6ソケットAPI関数を検出した場合、それは前の場合との関係で対称的に動作します。"
    },
    {
      "indent": 0,
      "text": "3.2 Name Resolver",
      "section_title": true,
      "ja": "3.2ネームリゾルバ"
    },
    {
      "indent": 3,
      "text": "It returns a proper answer in response to the IPv4 application's request.",
      "ja": "これは、IPv4アプリケーションの要求に応じて、適切な答えを返します。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application tries to resolve names via the resolver library (e.g. gethostbyname()), BIA intercept the function call and instead call the IPv6 equivalent functions (e.g. getnameinfo()) that will resolve both A and AAAA records.",
      "ja": "IPv4のアプリケーションはリゾルバライブラリを介して名を解決しようとすると（例えばのgethostbyname（））、BIA関数呼び出しインターセプトし、代わりに両方のAとAAAAレコードを解決するIPv6の同等の機能を（例えばてgetnameinfo（））を呼び出します。"
    },
    {
      "indent": 3,
      "text": "If the AAAA record is available, it requests the address mapper to assign an IPv4 address corresponding to the IPv6 address, then creates the A record for the assigned IPv4 address, and returns the A record to the application.",
      "ja": "AAAAレコードが利用可能である場合、それは、次に、割り当てられたIPv4アドレスのレコードを作成し、IPv6アドレスに対応するIPv4アドレスを割り当てるアドレスマッパを要求し、アプリケーションにレコードを返します。"
    },
    {
      "indent": 0,
      "text": "3.3 Address Mapper",
      "section_title": true,
      "ja": "3.3アドレスマッパ"
    },
    {
      "indent": 3,
      "text": "It internally maintains a table of the pairs of an IPv4 address and an IPv6 address. The IPv4 addresses are assigned from an IPv4 address pool. It uses the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255).",
      "ja": "これは、内部的にIPv4アドレスとIPv6アドレスのペアのテーブルを維持します。 IPv4アドレスはIPv4アドレスプールから割り当てられます。これは、未割り当てのIPv4アドレスを使用しています（例えば、0.0.0.1〜0.0.0.255）。"
    },
    {
      "indent": 3,
      "text": "When the name resolver or the function mapper requests it to assign an IPv4 address corresponding to an IPv6 address, it selects and returns an IPv4 address out of the pool, and registers a new entry into the table dynamically. The registration occurs in the following 2 cases:",
      "ja": "ネームリゾルバまたは関数マッパーは、IPv6アドレスに対応するIPv4アドレスを割り当てることを要求すると、それが選択し返しIPv4アドレスプールから、及び動的テーブルに新規エントリを登録します。登録は以下の2つの場合に発生します。"
    },
    {
      "indent": 3,
      "text": "(1) When the name resolver gets only an 'AAAA' record for the target host name and there is not a mapping entry for the IPv6 address.",
      "ja": "（1）名前解決がターゲットホスト名に対してのみ「AAAA」レコードを取得したIPv6アドレスのマッピングエントリが存在しない場合。"
    },
    {
      "indent": 3,
      "text": "(2) When the function mapper gets a socket API function call from the data received and there is not a mapping entry for the IPv6 source address.",
      "ja": "（2）関数マッパーは、受信したデータからソケットAPI関数呼び出しを取得し、IPv6ソースアドレスのマッピングエントリが存在しない場合。"
    },
    {
      "indent": 3,
      "text": "NOTE: This is the same as that of the Address Mapper in [BIS].",
      "ja": "注：これは[BIS]でアドレスマッパのと同じです。"
    },
    {
      "indent": 0,
      "text": "4. Behavior Examples",
      "section_title": true,
      "ja": "4.動作例"
    },
    {
      "indent": 3,
      "text": "This section describes behaviors of the proposed dual stack host called \"dual stack\", which communicates with an IPv6 host called \"host6\" using an IPv4 application.",
      "ja": "このセクションでは、IPv4アプリケーションを使用して「host6」と呼ばれるIPv6ホストと通信し、「デュアルスタック」と呼ばれる提案デュアルスタックホストの振る舞いを記述しています。"
    },
    {
      "indent": 3,
      "text": "In this section, the meanings of arrows are as follows:",
      "ja": "次のようにこのセクションでは、矢印の意味は以下の通りであります："
    },
    {
      "indent": 7,
      "text": "---> A DNS message for name resolving created by the applications\n     and the name resolver in the API translator.\n+++> An IPv4 address request to and reply from the address mapper\n     for the name resolver and the function mapper.\n===> Data flow by socket API functions created by the\n     applications and the function mapper in the API translator.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1 Originator Behavior",
      "section_title": true,
      "ja": "4.1発信行動"
    },
    {
      "indent": 3,
      "text": "This sub-section describes the behavior when the \"dual stack\" sends data to \"host6\".",
      "ja": "このサブセクションでは、「デュアルスタック」は「host6」にデータを送信する動作について説明します。"
    },
    {
      "indent": 3,
      "text": "When an IPv4 application sends a DNS query to its name server, the name resolver intercepts the query and then creates a new query to resolve both A and AAAA records. When only the AAAA record is resolved, the name resolver requests the address mapper to assign an IPv4 address corresponding to the IPv6 address.",
      "ja": "IPv4のアプリケーションはそのネームサーバにDNSクエリを送信すると、ネームリゾルバは、クエリを傍受して、両方のAとAAAAレコードを解決するために、新しいクエリを作成します。唯一のAAAAレコードが解決されると、名前リゾルバはIPv6アドレスに対応するIPv4アドレスを割り当てるために、アドレスマッパーを要求します。"
    },
    {
      "indent": 3,
      "text": "The name resolver creates an A record for the assigned IPv4 address and returns it to the IPv4 applications.",
      "ja": "ネームリゾルバは、割り当てられたIPv4アドレスのAレコードを作成し、IPv4アプリケーションに返します。"
    },
    {
      "indent": 3,
      "text": "In order for the IPv4 application to send IPv4 packets to host6, it calls the IPv4 socket API function.",
      "ja": "host6にIPv4パケットを送信するためにIPv4のアプリケーションのためには、IPv4ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "The function mapper detects the socket API function from the application. If the result is from IPv6 applications, it skips the translation. In the case of IPv4 applications, it requires an IPv6 address to invoke the IPv6 socket API function, thus the function mapper requests an IPv6 address to the address mapper. The address mapper selects an IPv4 address from the table and returns the destination IPv6 address. Using this IPv6 address, the function mapper invokes an IPv6 socket API function corresponding to the IPv4 socket API function.",
      "ja": "関数マッパーは、アプリケーションからソケットAPI関数を検出します。結果は、IPv6アプリケーションからのものである場合、それが翻訳をスキップします。 IPv4アプリケーションの場合には、このように関数マッパーは、アドレスマッパにIPv6アドレスを要求し、IPv6ソケットAPI関数を呼び出すためにIPv6アドレスを必要とします。アドレスマッピングテーブルからIPv4アドレスを選択し、宛先IPv6アドレスを返します。このIPv6アドレスを使用して、関数マッパーは、IPv4ソケットAPI関数に対応するIPv6ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "When the function mapper receives an IPv6 function call,it requests the IPv4 address to the address mapper in order to translate the IPv6 socket API function into an IPv4 socket API function. Then, the function mapper invokes the socket API function for the IPv4 applications.",
      "ja": "関数マッパーは、IPv6の関数呼び出しを受けたとき、それは、IPv4ソケットAPI関数にIPv6ソケットAPI関数を変換するために、アドレスマッパーにIPv4アドレスを要求します。次に、関数マッパーは、IPv4アプリケーション用のソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates the behavior described above:",
      "ja": "図2は、上述した挙動を示します。"
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                                \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP          Name\nappli-  API    |Name      Address  Function| (v6/v4)             Server\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |       |\n<<Resolve an IPv4 address for \"host6\".>>       |              |       |\n |        |        |        |        |         |              |       |\n |--------|------->|  Query of 'A' records for host6.         |       |\n |        |        |        |        |         |              |       |\n |        |        |--------|--------|---------|--------------|------>|\n |        |        |  Query of 'A' records and 'AAAA' for host6       |\n |        |        |        |        |         |              |       |\n |        |        |<-------|--------|---------|--------------|-------|\n |        |        |  Reply with the 'AAAA' record.           |       |\n |        |        |        |        |         |              |\n |        |        |<<The 'AAAA' record is resolved.>>        |\n |        |        |        |        |         |              |\n |        |        |+++++++>|  Request one IPv4 address       |\n |        |        |        |  corresponding to the IPv6 address.\n |        |        |        |        |         |              |\n |        |        |        |<<Assign one IPv4 address.>>     |\n |        |        |        |        |         |              |\n |        |        |<+++++++|  Reply with the IPv4 address.   |\n |        |        |        |        |         |              |\n |        |        |<<Create 'A' record for the IPv4 address.>>\n |        |        |        |        |         |              |\n |<-------|--------| Reply with the 'A' record.|              |\n |        |        |        |        |         |              |",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (1/2)",
      "ja": "発信元の図2の動作（1/2）"
    },
    {
      "indent": 0,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Call IPv4 Socket API function >>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|An IPv4 Socket API function Call\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv4 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|=========|=============>|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Reply an IPv6 data    |\n |        |        |        |        |  to dual stack.>>      |\n |        |        |        |        |         |              |\n |  An IPv6 Socket API function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the  |\n |        |        |        |        |  IPv6 addresses.       |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 Socket function call.\n |        |        |        |        |         |              |",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 2 Behavior of the originator (2/2)",
      "ja": "発信元の図2の動作（2/2）"
    },
    {
      "indent": 0,
      "text": "4.2 Recipient Behavior",
      "section_title": true,
      "ja": "4.2受信者の挙動"
    },
    {
      "indent": 3,
      "text": "This subsection describes the recipient behavior of \"dual stack\". The communication is triggered by \"host6\".",
      "ja": "ここでは、「デュアルスタック」の受信者の動作について説明します。通信は「host6」によってトリガされます。"
    },
    {
      "indent": 3,
      "text": "\"host6\" resolves the address of \"dual stack\" with 'AAAA' records through its name server, and then sends an IPv6 packet to the \"dual stack\".",
      "ja": "「host6」は、その名前のサーバを経由して「AAAA」レコードを持つ「デュアルスタック」のアドレスを解決し、その後、「デュアルスタック」にIPv6パケットを送信します。"
    },
    {
      "indent": 3,
      "text": "The IPv6 packet reaches the \"dual stack\" and the function mapper detects it.",
      "ja": "IPv6パケットは、「デュアルスタック」に達すると関数マッパーはそれを検出します。"
    },
    {
      "indent": 3,
      "text": "The function mapper requests the IPv4 address to the address mapper in order to invoke the IPv4 socket API function to communicate with the IPv4 application. Then the function mapper invokes the corresponding IPv4 socket API function for the IPv4 applications corresponding to the IPv6 functions.",
      "ja": "関数マッパーは、IPv4アプリケーションと通信するためのIPv4ソケットAPI関数を呼び出すためにアドレスマッパにIPv4アドレスを要求します。次に、関数マッパーは、IPv6機能に対応するIPv4アプリケーションのための対応するIPv4ソケットAPI関数を呼び出します。"
    },
    {
      "indent": 3,
      "text": "Figure 3 illustrates the behavior described above:",
      "ja": "図3は、上述した挙動を示します。"
    },
    {
      "indent": 3,
      "text": "\"dual stack\"                                               \"host6\"\nIPv4    Socket |     [ API Translator ]    | TCP(UDP)/IP\nappli-  API    |Name      Address  Function| (v6/v4)\ncation         |Resolver  Mapper   Mapper  |\n |        |        |        |        |         |              |\n<<Receive data from \"host6\".>>       |         |              |\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|<========|==============|\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv4 addresses|\n |        |        |        |        |  corresponding to the IPv6\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv4 addresses.\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv6 into IPv4.>>\n |        |        |        |        |         |              |\n |<=======|========|========|========|  An IPv4 function call |\n |        |        |        |        |         |              |\n<<Reply an IPv4 data to \"host6\".>>   |         |              |\n |        |        |        |        |         |              |\n |========|========|========|=======>|  An IPv4 function call |\n |        |        |        |        |         |              |\n |        |        |        |        |<<Translate IPv4 into IPv6.>>\n |        |        |        |        |         |              |\n |        |        |        |<+++++++|  Request IPv6 addresses|\n |        |        |        |        |  corresponding to the IPv4\n |        |        |        |        |  addresses.            |\n |        |        |        |        |         |              |\n |        |        |        |+++++++>| Reply with the IPv6 addresses.\n |        |        |        |        |         |              |\n |      An IPv6 Socket function call.|=========|=============>|\n |        |        |        |        |         |              |",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 3 Behavior of Receiving data from IPv6 host",
      "ja": "IPv6ホストからのデータを受信し、図3の挙動"
    },
    {
      "indent": 0,
      "text": "5. Considerations",
      "section_title": true,
      "ja": "5.検討事項"
    },
    {
      "indent": 0,
      "text": "5.1 Socket API Conversion",
      "section_title": true,
      "ja": "5.1ソケットAPIの変換"
    },
    {
      "indent": 3,
      "text": "IPv4 socket API functions are translated into semantically the same IPv6 socket API functions and vice versa. See Appendix A for the API list intercepted by BIA. IP addresses embedded in application layer protocols (e.g., FTP) can be translated in API functions. Its implementation depends on operating systems.",
      "ja": "IPv4のソケットAPI関数は、意味的に同一のIPv6ソケットAPI関数およびその逆に翻訳されます。 BIAによってインターセプトAPIのリストについては、付録Aを参照してください。アプリケーション層プロトコル（例えば、FTP）に埋め込まれたIPアドレスは、API関数に翻訳することができます。その実装は、オペレーティング・システムによって異なります。"
    },
    {
      "indent": 3,
      "text": "NOTE: Basically, IPv4 socket API functions are not fully compatible with IPv6 since the IPv6 has new advanced features.",
      "ja": "注：IPv6は新しい高度な機能を持っているので、基本的にはIPv4ソケットAPI関数は、IPv6と完全に互換性がありません。"
    },
    {
      "indent": 0,
      "text": "5.2 ICMP Message Handling",
      "section_title": true,
      "ja": "5.2 ICMPメッセージの処理"
    },
    {
      "indent": 3,
      "text": "When an application needs ICMP messages values (e.g., Type, Code, etc.) sent from a network layer, ICMPv4 message values MAY be translated into ICMPv6 message values based on [SIIT], and vice versa. It can be implemented using raw socket.",
      "ja": "アプリケーションは、ネットワーク層から送信されたICMPメッセージ値（等例えば、タイプ、コードなど）を必要とするとき、ICMPv4のメッセージの値は[SIIT]、およびその逆に基づいて、ICMPv6メッセージ値に変換することができます。これは、生のソケットを使用して実装することができます。"
    },
    {
      "indent": 0,
      "text": "5.3 IPv4 Address Pool and Mapping Table",
      "section_title": true,
      "ja": "5.3 IPv4アドレスプールとのマッピング表"
    },
    {
      "indent": 3,
      "text": "The address pool consists of the unassigned IPv4 addresses. This pool can be implemented at different granularity in the node e.g., a single pool per node, or at some finer granularity such as per user or per process. However, if a number of IPv4 applications communicate with IPv6 hosts, the available address spaces will be exhausted. As a result, it will be impossible for IPv4 applications to communicate with IPv6 nodes. It requires smart management techniques for address pool. For example, it is desirable for the mapper to free the oldest entry and reuse the IPv4 address for creating a new entry. This issues is the same as [BIS]. In case of a per-node address mapping table, it MAY cause a larger risk of running out of address.",
      "ja": "アドレスプールが割り当てられていないIPv4アドレスで構成されています。このプールは、ノード、例えば、ノードごと、あるいはユーザごとまたはプロセスごとのようないくつかのより細かい粒度で単一のプールに異なる粒度で実現することができます。 IPv4アプリケーションの数は、IPv6ホストと通信する場合は、利用可能なアドレス空間を排気します。 IPv4アプリケーションがIPv6ノードと通信するための結果として、それは不可能であろう。これは、アドレスプールのためのスマートな管理技術が必要です。例えば、マッパーは最も古いエントリを解放し、新しいエントリを作成するためのIPv4アドレスを再利用するために望ましいです。この問題は、[BIS]と同じです。ノードごとのアドレスマッピングテーブルの場合は、アドレスが不足するより大きなリスクを引き起こす可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.4 Internally Assigned IPv4 Addresses",
      "section_title": true,
      "ja": "5.4内部的に割り当てられたIPv4アドレス"
    },
    {
      "indent": 3,
      "text": "The IPv4 addresses, which are internally assigned to IPv6 target hosts out of the pool, are the unassigned IPv4 addresses (e.g., 0.0.0.1 ~ 0.0.0.255). There is no potential collision with another use of the private address space when the IPv4 address flows out from the host.",
      "ja": "内部プールからのIPv6ターゲットホストに割り当てられるIPv4アドレスは、割り当てられていないIPv4アドレスである（例えば、0.0.0.1〜0.0.0.255）。 IPv4アドレスは、ホストから流出プライベートアドレス空間の別の使用と潜在的な衝突はありません。"
    },
    {
      "indent": 0,
      "text": "5.5 Mismatch between DNS result(AAAA) and Peer Application Version(v4)",
      "ja": "DNSの結果（AAAA）とピアアプリケーションのバージョン（V4）との間に5.5不一致"
    },
    {
      "indent": 3,
      "text": "If a server application you are using does not support IPv6 yet, but runs on a machine that supports other IPv6 services and this is listed with a AAAA record in the DNS, a client IPv4 application using BIA might fail to connect to the server application, because there is a mismatch between DNS query result (i.e., AAAA) and a server application version(i.e., IPv4). A solution is to try all the addresses listed in the DNS and just not fail after the first attempt. We have two approaches: the client application itself SHOULD cycle through all the addresses and end up trying the IPv4 one. Or it SHOULD be done by some extensions of name resolver and API translator in BIA. For this, BIA SHOULD do iterated jobs for finding the working address used by the other application out of addresses returned by the extended name resolver. It may very well be application dependent. Note that BIA might be able to do the iteraction over all addresses for TCP sockets, since BIA can observe when the connect call fails. But for UDP sockets it is hard if not impossible for BIA to know which address worked, hence the application must do the iteraction over all addresses until it finds a working address.",
      "ja": "使用しているサーバ・アプリケーションがまだIPv6をサポートしていますが、他のIPv6サービスをサポートし、これはDNSにAAAAレコードにリストされているマシン上で実行されていない場合は、BIAを使用してクライアントのIPv4アプリケーションは、サーバーアプリケーションへの接続に失敗することがありますDNSクエリの結果（すなわち、AAAA）およびサーバーアプリケーションのバージョン（すなわち、IPv4）の間に不一致がありますので。ソリューションは、DNSにリストされているすべてのアドレスを試してみて、ちょうど最初の試みの後に失敗しないことです。我々は2つのアプローチがあります：クライアントアプリケーション自体SHOULDサイクルすべてのアドレススルーとIPv4のいずれかをしようとしてしまいます。それとも、BIAでネームリゾルバとAPI翻訳者のいくつかの拡張機能によって行われるべきです。このために、BIAは、拡張ネームリゾルバによって返されるアドレスのうち、他のアプリケーションで使用される作業用アドレスを見つけるためのジョブを繰り返し行う必要があります。それは非常によく依存アプリケーションであってもよいです。接続コールが失敗したときにBIAを観察することができるので、BIAは、TCPソケットのためのすべてのアドレス上iteractionを行うことができるかもしれないことに注意してください。 BIAは、それが作業アドレスを見つけるまで、したがって、アプリケーションがすべてのアドレスを超えるiteractionを行う必要があり、働いているアドレスを知ることは不可能ではない場合でも、UDPソケットのは難しいです。"
    },
    {
      "indent": 3,
      "text": "Another way to avoid this type of problems is to make BIA only come into effect when no A records exist for the peer. Thus traffic from an application using BIA on a dual-stack host to a dual-stack host would use IPv4.",
      "ja": "問題のこのタイプを避けるための別の方法には、Aレコードが、ピアのために存在しない場合にBIAにのみ発効することです。したがって、デュアルスタックホスト上のBIAを使用して、アプリケーションからデュアルスタックホストへのトラフィックは、IPv4を使用します。"
    },
    {
      "indent": 0,
      "text": "5.6 Implementation Issues",
      "section_title": true,
      "ja": "5.6実装の問題"
    },
    {
      "indent": 3,
      "text": "Some operating systems support the preload library functions, so it is easy to implement the API translator by using it. For example, the user can replace all existing socket API functions with user-defined socket API functions which translate the socket API function. In this case, every IPv4 application has its own translation library using a preloaded library which will be bound into the application before executing it dynamically.",
      "ja": "一部のオペレーティングシステムは、プリロード・ライブラリ関数をサポートしているので、それを使ってAPIトランスレータを実装することは容易です。例えば、ユーザはソケットAPI関数を翻訳し、ユーザ定義のソケットAPI関数で、すべての既存のソケットAPI関数を置き換えることができます。この場合、すべてのIPv4のアプリケーションが動的にそれを実行する前に、アプリケーションにバインドされますプリロードライブラリを使用して、独自の翻訳ライブラリーを持っています。"
    },
    {
      "indent": 3,
      "text": "Some other operating systems support the user-defined layered protocol allowing a user to develop some additional protocols and put them in the existing protocol stack. In this case, the API translator can be implemented as a layered protocol module.",
      "ja": "いくつかの他のオペレーティングシステムには、いくつかの追加のプロトコルを開発し、既存のプロトコルスタックでそれらを置くために、ユーザーを許可するユーザー定義の階層化プロトコルをサポートしています。この場合、APIトランスレータは、層状プロトコル・モジュールとして実装することができます。"
    },
    {
      "indent": 3,
      "text": "In the above two approaches, it is assumed that there exists both TCP(UDP)/IPv4 and TCP(UDP)/IPv6 stacks and there is no need to modify or to add a new TCP-UDP/IPv6 stack.",
      "ja": "上記二つのアプローチでは、それはTCP（UDP）/ IPv4およびTCP（UDP）の両方が存在することが想定される/ IPv6はスタックおよび変更したり、新しいTCP-UDP / IPv6スタックを追加する必要がありません。"
    },
    {
      "indent": 0,
      "text": "6. Limitations",
      "section_title": true,
      "ja": "6.制限事項"
    },
    {
      "indent": 3,
      "text": "In common with [NAT-PT], BIA needs to translate IP addresses embedded in application layer protocols, e.g., FTP. So it may not work for new applications which embed addresses in payloads.",
      "ja": "[NAT-PT]と共通して、BIAは、アプリケーション層プロトコル、例えば、FTPに埋め込まれたIPアドレスを変換する必要があります。だから、ペイロードにアドレスを埋め込む新しいアプリケーションのために動作しない場合があります。"
    },
    {
      "indent": 3,
      "text": "This mechanism supports unicast communications only. In order to support multicast functions, some other additional functionalities must be considered in the function mapper module.",
      "ja": "このメカニズムは、ユニキャスト通信のみをサポートしています。マルチキャスト機能をサポートするために、他のいくつかの追加機能は、機能マッパーモジュールに考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 API has new advanced features, it is difficult to translate such kinds of IPv6 APIs into IPv4 APIs. Thus, IPv6 inbound communication with advanced features may be discarded.",
      "ja": "IPv6のAPIが新しい高度な機能を持っているので、IPv4のAPIへのIPv6のAPIのように種類を変換することは困難です。このように、高度な機能を備えたIPv6のインバウンド通信が破棄されることがあります。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security consideration of BIA mostly relies on that of [NAT-PT]. The differences are due to the address translation occurring at the API and not in the network layer. That is, since the mechanism uses the API translator at the socket API level, hosts can utilize the security of the network layer (e.g., IPsec) when they communicate with IPv6 hosts using IPv4 applications via the mechanism. As well, there isn't a DNS ALG as in NAT-PT, so there is no interference with DNSSEC.",
      "ja": "BIAのセキュリティの考慮事項は、主に[NAT-PT]のものに依存しています。違いは、アドレス変換は、ネットワーク層にAPIで発生していないに起因するものです。その機構は、ソケットAPIレベルAPIトランスレータを使用するので、それらが機構を介してIPv4アプリケーションを使用して、IPv6ホストと通信する場合、ホストはネットワーク層（例えば、IPsecの）のセキュリティを利用することが可能です。同様に、NAT-PTのようにDNS ALGがないので、DNSSECとの干渉がありません。"
    },
    {
      "indent": 3,
      "text": "The use of address pooling may open a denial of service attack vulnerability. So BIA should employ the same sort of protection techniques as [NAT-PT] does.",
      "ja": "アドレスプールを使用すると、サービス攻撃拒否の脆弱性を開くことができます。だから、BIAはありません[NAT-PT]として保護技術の同じ種類を採用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to acknowledge the implementation contributions by Wanjik Lee (wjlee@arang.miryang.ac.kr) and i2soft Corporation (www.i2soft.net).",
      "ja": "我々はWanjikリー（wjlee@arang.miryang.ac.kr）とi2softコーポレーション（www.i2soft.net）によって実装拠出を承認したいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 3,
      "text": "[TRANS-MECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for IPv6 Hosts and Routers\", RFC 2893, August 2000.",
      "ja": "[TRANS-MECH]ギリガン、R.およびE. Nordmarkと、 \"IPv6ホストとルータの移行メカニズム\"、RFC 2893、2000年8月。"
    },
    {
      "indent": 3,
      "text": "[SIIT] Nordmark, E., \"Stateless IP/ICMP Translator (SIIT)\", RFC 2765, February 2000.",
      "ja": "[SIIT] Nordmarkと、E.、 \"ステートレスIP / ICMPトランスレータ（SIIT）\"、RFC 2765、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[FTP] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC 959, October 1985.",
      "ja": "[FTP]ポステル、J.とJ.レイノルズ、 \"ファイル転送プロトコル\"、STD 9、RFC 959、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[NAT] Srisuresh, P. and K. Egevang, \"Traditional IP Network Address Translator (Traditional NAT)\", RFC 3022, January 2001.",
      "ja": "[NAT] Srisuresh、P.とK. Egevang、 \"伝統的なIPネットワークアドレス変換（NAT繁体字）\"、RFC 3022、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[IPV4] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[IPV4]ポステル、J.、 \"インターネットプロトコル\"、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[IPV6] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[IPV6]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[NAT-PT] Tsirtsis, G. and P. Srisuresh, \"Network Address Translation - Protocol Translation (NAT-PT)\", RFC 2766, February 2000.",
      "ja": "[NAT-PT] Tsirtsis、G.とP. Srisuresh、 \"ネットワークアドレス変換 - プロトコル変換（NAT-PT）\"、RFC 2766、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[BIS] Tsuchiya, K., Higuchi, H. and Y. Atarashi, \"Dual Stack Hosts using the \"Bump-In-the-Stack\" Technique (BIS)\", RFC 2767, February 2000.",
      "ja": "[BIS]土屋、K.、樋口、H.及びY. Atarashi、バンプ・イン・スタック \"技術（BIS） \" RFC 2767、2000年2月\" を使用してデュアルスタックホスト\"。"
    },
    {
      "indent": 3,
      "text": "[SOCK-EXT] Gilligan, R., Thomson, S., Bound, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2553, March 1999.",
      "ja": "[SOCK-EXT]ギリガン、R.、トムソン、S.、バウンド、J.とW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 2553、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC 2119] Bradner S., \"Key words for use in RFCs to indicate Requirement Levels\", RFC 2119, March 1997.",
      "ja": "[RFC 2119]ブラドナーのS.、 \"要件レベルを示すRFCsにおける使用のためのキーワード\"、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "Appendix A : API list intercepted by BIA",
      "ja": "付録A：BIAによってインターセプトAPIリスト"
    },
    {
      "indent": 3,
      "text": "The following functions are the API list which SHOULD be intercepted by BIA module.",
      "ja": "以下の機能は、BIAモジュールによって傍受されるべきであるAPIの一覧です。"
    },
    {
      "indent": 3,
      "text": "The functions that the application uses to pass addresses into the system are:",
      "ja": "アプリケーションがシステムにアドレスを渡すために使用する機能は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "ja": "バインド（）（接続）にsendmsg（）はsendto（）"
    },
    {
      "indent": 3,
      "text": "The functions that return an address from the system to an application are:",
      "ja": "システムからアプリケーションにアドレスを返す関数は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "ja": "受け入れる（）のrecvfrom（）のrecvmsg（）getpeername（）のgetsockname（）"
    },
    {
      "indent": 3,
      "text": "The functions that are related to socket options are:",
      "ja": "ソケット・オプションに関連している機能は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "getsocketopt() setsocketopt()",
      "ja": "getsockopt（）のsetsockopt（）"
    },
    {
      "indent": 3,
      "text": "The functions that are used for conversion of IP addresses embedded in application layer protocol (e.g., FTP, DNS, etc.) are:",
      "ja": "アプリケーション層プロトコル（例えば、FTP、DNS、等）に埋め込まれたIPアドレスの変換に使用される関数は、以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "recv() send() read() write()",
      "ja": "RECV（））（）（読み書き）（送信"
    },
    {
      "indent": 3,
      "text": "As well, raw sockets for IPv4 and IPv6 MAY be intercepted.",
      "ja": "同様に、IPv4とIPv6の生のソケットが傍受される可能性が。"
    },
    {
      "indent": 3,
      "text": "Most of the socket functions require a pointer to the socket address structure as an argument. Each IPv4 argument is mapped into corresponding an IPv6 argument, and vice versa.",
      "ja": "ソケット関数のほとんどは、引数としてソケットアドレス構造体へのポインタが必要です。各IPv4の引数は、IPv6引数、およびその逆を対応するにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "According to [SOCK-EXT], the following new IPv6 basic APIs and structures are required.",
      "ja": "[SOCK-EXT]によると、以下の新しいIPv6の基本的なAPIと構造が必要とされています。"
    },
    {
      "indent": 6,
      "text": "IPv4                     new IPv6\n------------------------------------------------\nAF_INET                  AF_INET6\nsockaddr_in              sockaddr_in6\ngethostbyname()          getaddrinfo()\ngethostbyaddr()          getnameinfo()\ninet_ntoa()/inet_addr()  inet_pton()/inet_ntop()\nINADDR_ANY               in6addr_any",
      "raw": true
    },
    {
      "indent": 3,
      "text": "BIA MAY intercept inet_ntoa() and inet_addr() and use the address mapper for those. Doing that enables BIA to support literal IP addresses.",
      "ja": "BIAは、（INET_NTOAをインターセプト）とのinet_addr（）およびそれらのアドレスマッパーを使用するかもしれません。こうそれは文字通りのIPアドレスをサポートするために、BIAを可能にします。"
    },
    {
      "indent": 3,
      "text": "The gethostbyname() call return a list of addresses. When the name resolver function invokes getaddrinfo() and getaddrinfo() returns multiple IP addresses, whether IPv4 or IPv6, they SHOULD all be represented in the addresses returned by gethostbyname(). Thus if getaddrinfo() returns multiple IPv6 addresses, this implies that multiple address mappings will be created; one for each IPv6 address.",
      "ja": "gethostbyname（）の呼び出しは、アドレスのリストを返します。ネームリゾルバ機能のgetaddrinfo呼び出したとき（）とはgetaddrinfo（）、それらは全てのgethostbynameによって返されたアドレス（）で表現されるべきであるIPv4またはIPv6かどうか、複数のIPアドレスを返します。複数のIPv6アドレスを返すのgetaddrinfo（）場合はこのように、これは複数のアドレスマッピングが作成されることを意味します。各IPv6アドレスのための1つ。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Seungyun Lee ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 5508 Fax: +82 42 861 5404 EMail: syl@pec.etri.re.kr",
      "ja": "リードン・エントリpesi siunyuna kayam 161、yusanga区、temjana 305から350、韓国電話：82 4 860 5508ファックス：82 4 861 5404 Eメール：silapisietirekara"
    },
    {
      "indent": 3,
      "text": "Myung-Ki Shin ETRI PEC 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 4847 Fax: +82 42 861 5404 EMail: mkshin@pec.etri.re.kr",
      "ja": "ミョン-KIシンETRI PEC 161 Kajong洞儒城区、大田305から350、韓国電話：+82 42 860 4847ファックス：+82 42 861 5404 Eメール：mkshin@pec.etri.re.kr"
    },
    {
      "indent": 3,
      "text": "Yong-Jin Kim ETRI 161 Kajong-Dong, Yusong-Gu, Taejon 305-350, Korea Tel: +82 42 860 6564 Fax: +82 42 861 1033 EMail: yjkim@pec.etri.re.kr",
      "ja": "ヤム・ジンキム・エントリkayam 161、yusanga区、temjana 305から350、韓国電話：82 4 860 6564ファックス：82 4 861 1033 Eメール：yahkimpisietirekara"
    },
    {
      "indent": 3,
      "text": "Alain Durand Sun Microsystems, inc. 25 Network circle Menlo Park, CA 94025, USA Fax: +1 650 786 5896 EMail: Alain.Durand@sun.com",
      "ja": "アラン・デュランサン・マイクロシステムズ、株式会社。 25ネットワーク円メンロパーク、CA 94025、USAファックス：+1 650 786 5896 Eメール：Alain.Durand@sun.com"
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems Laboratories 180, avenue de l'Europe 38334 SAINT ISMIER Cedex, France Tel: +33 (0)4 76 18 88 03 Fax: +33 (0)4 76 18 88 88 EMail: erik.nordmark@sun.com",
      "ja": "エリックNordmarkとSun Microsystemsの研究所180 38334ヨーロッパアベニューSAINT ISMIERセデックス、France電話：+33（0）4 76 18 88 03ファックス：+33（0）4 76 18 88 88 Eメール：erik.nordmark@sun。コム"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}