{
  "title": {
    "text": "RFC 3174 - US Secure Hash Algorithm 1 (SHA1)",
    "ja": "RFC 3174 - 米国は、ハッシュアルゴリズム1（SHA1）を確保"
  },
  "number": 3174,
  "created_at": "2019-10-24 15:38:28.651174+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                   D. Eastlake, 3rd\nRequest for Comments: 3174                                      Motorola\nCategory: Informational                                         P. Jones\n                                                           Cisco Systems\n                                                          September 2001",
      "raw": true
    },
    {
      "indent": 19,
      "text": "US Secure Hash Algorithm 1 (SHA1)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to make the SHA-1 (Secure Hash Algorithm 1) hash algorithm conveniently available to the Internet community. The United States of America has adopted the SHA-1 hash algorithm described herein as a Federal Information Processing Standard. Most of the text herein was taken by the authors from FIPS 180-1. Only the C code implementation is \"original\".",
      "ja": "このドキュメントの目的は、インターネットコミュニティにSHA-1（セキュアハッシュアルゴリズム1）ハッシュアルゴリズムは、便利な利用できるようにすることです。アメリカ合衆国は、連邦情報処理規格としてここに記載SHA-1ハッシュアルゴリズムを採用しています。テキストのほとんどはここFIPS 180-1からの著者によって撮影されました。唯一のCコードの実装は、「オリジナル」です。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Most of the text herein was taken from [FIPS 180-1]. Only the C code implementation is \"original\" but its style is similar to the previously published MD4 and MD5 RFCs [RFCs 1320, 1321].",
      "ja": "テキストのほとんどはここ[FIPS 180-1]から取られました。唯一のCコードの実装は、「オリジナル」であるが、そのスタイルは、以前に発表されたMD4とMD5のRFC [RFCの1320、1321]と同様です。"
    },
    {
      "indent": 3,
      "text": "The SHA-1 is based on principles similar to those used by Professor Ronald L. Rivest of MIT when designing the MD4 message digest algorithm [MD4] and is modeled after that algorithm [RFC 1320].",
      "ja": "SHA-1はMD4メッセージを設計する際のアルゴリズム[MD4]をダイジェストMITのRonald L. Rivest教授によって使用されるものと同様の原理に基づいており、そのアルゴリズム[RFC 1320]の後にモデル化されます。"
    },
    {
      "indent": 3,
      "text": "Useful comments from the following, which have been incorporated herein, are gratefully acknowledged:",
      "ja": "本明細書に組み込まれている以下、より有益なコメント、深く感謝しています。"
    },
    {
      "indent": 6,
      "text": "Tony Hansen Garrett Wollman",
      "ja": "トニー・ハンセンギャレットウォルマン"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Overview of Contents...........................................  2\n2. Definitions of Bit Strings and Integers........................  3\n3. Operations on Words............................................  3\n4. Message Padding................................................  4\n5. Functions and Constants Used...................................  6\n6. Computing the Message Digest...................................  6\n6.1 Method 1......................................................  6\n6.2 Method 2......................................................  7\n7. C Code.........................................................  8\n7.1 .h file.......................................................  8\n7.2 .c file....................................................... 10\n7.3 Test Driver................................................... 18\n8. Security Considerations........................................ 20\nReferences........................................................ 21\nAuthors' Addresses................................................ 21\nFull Copyright Statement.......................................... 22",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Overview of Contents",
      "section_title": true,
      "ja": "内容の概要"
    },
    {
      "indent": 3,
      "text": "NOTE: The text below is mostly taken from [FIPS 180-1] and assertions therein of the security of SHA-1 are made by the US Government, the author of [FIPS 180-1], and not by the authors of this document.",
      "ja": "注：以下のテキストは主に[FIPS 180-1]から取得され、その中にSHA-1のセキュリティのアサーションが米国政府、[FIPS 180-1]の著者によってではなく、この文書の著者によって作られています。"
    },
    {
      "indent": 3,
      "text": "This document specifies a Secure Hash Algorithm, SHA-1, for computing a condensed representation of a message or a data file. When a message of any length < 2^64 bits is input, the SHA-1 produces a 160-bit output called a message digest. The message digest can then, for example, be input to a signature algorithm which generates or verifies the signature for the message. Signing the message digest rather than the message often improves the efficiency of the process because the message digest is usually much smaller in size than the message. The same hash algorithm must be used by the verifier of a digital signature as was used by the creator of the digital signature. Any change to the message in transit will, with very high probability, result in a different message digest, and the signature will fail to verify.",
      "ja": "この文書は、メッセージまたはデータファイルの圧縮表現を計算するため、セキュアハッシュアルゴリズム、SHA-1を指定します。任意の長さ<2 ^ 64ビットのメッセージが入力されると、SHA-1メッセージダイジェストと呼ばれる160ビットの出力を生成します。メッセージダイジェストは、次いで、例えば、生成する、またはメッセージの署名を検証する署名アルゴリズムに入力することができます。メッセージダイジェストは、メッセージよりもサイズが通常はるかに小さいため、メッセージダイジェストではなく、メッセージに署名することは、多くの場合、プロセスの効率を向上させることができます。デジタル署名の作成者によって使用されたものと同じハッシュアルゴリズムは、デジタル署名の検証者によって使用されなければなりません。任意の輸送中のメッセージに変更、非常に高い確率で、ダイジェスト異なるメッセージが表示され、署名が検証に失敗します。"
    },
    {
      "indent": 3,
      "text": "The SHA-1 is called secure because it is computationally infeasible to find a message which corresponds to a given message digest, or to find two different messages which produce the same message digest. Any change to a message in transit will, with very high probability, result in a different message digest, and the signature will fail to verify.",
      "ja": "与えられたメッセージダイジェスト、又は同一のメッセージダイジェストを生成する2つの異なるメッセージを見つけることに対応するメッセージを見つけることが計算上不可能であるため、SHA-1は、セキュア呼ばれます。任意の輸送中のメッセージに変更、非常に高い確率で、ダイジェスト異なるメッセージが表示され、署名が検証に失敗します。"
    },
    {
      "indent": 3,
      "text": "Section 2 below defines the terminology and functions used as building blocks to form SHA-1.",
      "ja": "以下のセクション2は、SHA-1を形成するためのビルディングブロックとして使用される用語および機能を定義します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions of Bit Strings and Integers",
      "section_title": true,
      "ja": "ビット文字列と整数の2の定義"
    },
    {
      "indent": 3,
      "text": "The following terminology related to bit strings and integers will be used:",
      "ja": "ビット列と整数に関連する以下の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "a. A hex digit is an element of the set {0, 1, ... , 9, A, ... , F}. A hex digit is the representation of a 4-bit string. Examples: 7 = 0111, A = 1010.",
      "ja": "A。 16進数は、集合の要素である{0、1、...、9、A、...、F}。 16進数は、4ビット列の表現です。例：= 0111 7、A = 1010。"
    },
    {
      "indent": 3,
      "text": "b. A word equals a 32-bit string which may be represented as a sequence of 8 hex digits. To convert a word to 8 hex digits each 4-bit string is converted to its hex equivalent as described in (a) above. Example:",
      "ja": "B。ワードは、8進数字の列として表すことができる32ビットのビット列と等しいです。上記（a）で説明したように8進数字に単語を変換するために、各4ビットのビット列は、そのヘクス等価に変換されます。例："
    },
    {
      "indent": 6,
      "text": "1010 0001 0000 0011 1111 1110 0010 0011 = A103FE23.",
      "ja": "1010 0001 0000 0011 1111 1110 0010 0011 = 103 A Vaaと。"
    },
    {
      "indent": 3,
      "text": "c. An integer between 0 and 2^32 - 1 inclusive may be represented as a word. The least significant four bits of the integer are represented by the right-most hex digit of the word representation. Example: the integer 291 = 2^8+2^5+2^1+2^0 = 256+32+2+1 is represented by the hex word, 00000123.",
      "ja": "C。 0から2 ^ 32の間の整数 -  1包括ワードとして表すことができます。整数の最下位4ビットは、ワード表現の右端の16進数で表されます。例：整数291 = 2 ^ 8 + 2 ^ 5 + 2 ^ 1 + 2 ^ 0 = 256 + 32 + 2 + 1は、00000123が進ワードによって表されます。"
    },
    {
      "indent": 6,
      "text": "If z is an integer, 0 <= z < 2^64, then z = (2^32)x + y where 0 <= x < 2^32 and 0 <= y < 2^32. Since x and y can be represented as words X and Y, respectively, z can be represented as the pair of words (X,Y).",
      "ja": "zが整数である場合、0 <= Z <2 ^ 64は、Z =（2 ^ 32）X + Y 0 <= xの<2 ^ 32及び0 <= Y <2 ^ 32。 xおよびyはそれぞれワードXとY、として表現することができるので、zは単語（X、Y）の対として表すことができます。"
    },
    {
      "indent": 3,
      "text": "d. block = 512-bit string. A block (e.g., B) may be represented as a sequence of 16 words.",
      "ja": "D。ブロック= 512ビットのストリング。ブロック（例えば、B）は、16ワードのシーケンスとして表すことができます。"
    },
    {
      "indent": 0,
      "text": "3. Operations on Words",
      "section_title": true,
      "ja": "言葉3.操作"
    },
    {
      "indent": 3,
      "text": "The following logical operators will be applied to words:",
      "ja": "以下の論理演算子は言葉に適用されます。"
    },
    {
      "indent": 3,
      "text": "a. Bitwise logical word operations",
      "ja": "A。ビット単位の論理ワード演算"
    },
    {
      "indent": 6,
      "text": "X AND Y = bitwise logical \"and\" of X and Y.",
      "ja": "XとYは、XとYのビット単位の論理「と」="
    },
    {
      "indent": 6,
      "text": "X OR Y = bitwise logical \"inclusive-or\" of X and Y.",
      "ja": "X OR Yは、ビット単位の論理「を含め、または」XとYの="
    },
    {
      "indent": 6,
      "text": "X XOR Y = bitwise logical \"exclusive-or\" of X and Y.",
      "ja": "X XOR Y = XとYのビット単位の論理「排他的または」"
    },
    {
      "indent": 6,
      "text": "NOT X = bitwise logical \"complement\" of X.",
      "ja": "X.のNOT X =ビット単位の論理「補数」"
    },
    {
      "indent": 6,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 9,
      "text": "      01101100101110011101001001111011\nXOR   01100101110000010110100110110111\n      --------------------------------\n  =   00001001011110001011101111001100",
      "raw": true
    },
    {
      "indent": 3,
      "text": "b. The operation X + Y is defined as follows: words X and Y represent integers x and y, where 0 <= x < 2^32 and 0 <= y < 2^32. For positive integers n and m, let n mod m be the remainder upon dividing n by m. Compute",
      "ja": "B。次のように演算X + Yが定義される：ワードXとYは整数xとyを表し、0 <= xで<2 ^ 32及び0 <= Y <2 ^ 32。正の整数n及びmのために、MOD mはmでnは分割時の余りであるNましょう。計算"
    },
    {
      "indent": 9,
      "text": "z = (x + y) mod 2^32.",
      "ja": "Z =（X + Y）2 ^ 32 MOD。"
    },
    {
      "indent": 6,
      "text": "Then 0 <= z < 2^32. Convert z to a word, Z, and define Z = X + Y.",
      "ja": "次いで、0 <= Z <2 ^ 32。単語のZ変換、Z、およびZ = X + Yを定義します"
    },
    {
      "indent": 3,
      "text": "c. The circular left shift operation S^n(X), where X is a word and n is an integer with 0 <= n < 32, is defined by",
      "ja": "C。 Xは単語であり、nが0の整数であり、円形の左シフト演算S ^ N（X）、<= N <32は、によって定義されます"
    },
    {
      "indent": 9,
      "text": "S^n(X) = (X << n) OR (X >> 32-n).",
      "ja": "S ^ N（X）=（X << N）または（X >> 32-N）。"
    },
    {
      "indent": 6,
      "text": "In the above, X << n is obtained as follows: discard the left-most n bits of X and then pad the result with n zeroes on the right (the result will still be 32 bits). X >> n is obtained by discarding the right-most n bits of X and then padding the result with n zeroes on the left. Thus S^n(X) is equivalent to a circular shift of X by n positions to the left.",
      "ja": "パッドを右にn個のゼロ（結果は依然として32ビットである）で結果をXの最も左側のnビットを破棄して：上記において、X << Nは、以下のように得られます。 X >> nはXの最も右にnビットを破棄した後、左側のn個のゼロで結果をパディングすることによって得られます。こうしてS ^ N（X）が左にn個の位置によってXの循環シフトと等価です。"
    },
    {
      "indent": 0,
      "text": "4. Message Padding",
      "section_title": true,
      "ja": "4.メッセージパディング"
    },
    {
      "indent": 3,
      "text": "SHA-1 is used to compute a message digest for a message or data file that is provided as input. The message or data file should be considered to be a bit string. The length of the message is the number of bits in the message (the empty message has length 0). If the number of bits in a message is a multiple of 8, for compactness we can represent the message in hex. The purpose of message padding is to make the total length of a padded message a multiple of 512. SHA-1 sequentially processes blocks of 512 bits when computing the message digest. The following specifies how this padding shall be performed. As a summary, a \"1\" followed by m \"0\"s followed by a 64- bit integer are appended to the end of the message to produce a padded message of length 512 * n. The 64-bit integer is the length of the original message. The padded message is then processed by the SHA-1 as n 512-bit blocks.",
      "ja": "SHA-1は、入力として提供されるメッセージまたはデータファイルのメッセージダイジェストを計算するために使用されます。メッセージやデータファイルには、ビット列であると考えるべきです。メッセージの長さは、メッセージのビット数（空のメッセージの長さ0を有する）です。メッセージのビット数が8の倍数である場合は、コンパクトのために我々はヘクスにメッセージを表すことができます。メッセージパディングの目的は、パディングされたメッセージの全体の長さを作ることであるメッセージダイジェストを計算する際に512 SHA-1順次の複数は512ビットのブロックを処理します。以下は、このパディングが行われなければならないかを指定します。要約として、64ビットの整数に続くM続く「1」「0」は、長さ512×n個のパディングされたメッセージを生成するメッセージの最後に追加されています。 64ビット整数は、元のメッセージの長さです。パディングされたメッセージは、その後、N 512ビットのブロックとしてSHA-1によって処理されます。"
    },
    {
      "indent": 3,
      "text": "Suppose a message has length l < 2^64. Before it is input to the SHA-1, the message is padded on the right as follows:",
      "ja": "メッセージは、長さl <2 ^ 64を有していると仮定する。それはSHA-1に入力される前に、次のように、メッセージが右側に埋め込まれています。"
    },
    {
      "indent": 3,
      "text": "a. \"1\" is appended. Example: if the original message is \"01010000\", this is padded to \"010100001\".",
      "ja": "A。 「1」が付加されます。例：元のメッセージが「01010000」であれば、これは「010100001」に水増しされます。"
    },
    {
      "indent": 3,
      "text": "b. \"0\"s are appended. The number of \"0\"s will depend on the original length of the message. The last 64 bits of the last 512-bit block are reserved",
      "ja": "B。 「0」が追加されます。 「0」の数は、メッセージの元の長さに依存するであろう。最後の512ビットブロックの最後の64ビットは予約されています"
    },
    {
      "indent": 6,
      "text": "for the length l of the original message.",
      "ja": "元のメッセージの長さlのため。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is the bit string",
      "ja": "例：元のメッセージがビット列であると仮定"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101.",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１。"
    },
    {
      "indent": 6,
      "text": "After step (a) this gives",
      "ja": "ステップ（a）の後にこれを提供します"
    },
    {
      "indent": 9,
      "text": "01100001 01100010 01100011 01100100 01100101 1.",
      "ja": "０１１００００１ ０１１０００１０ ０１１０００１１ ０１１００１００ ０１１００１０１ １。"
    },
    {
      "indent": 6,
      "text": "Since l = 40, the number of bits in the above is 41 and 407 \"0\"s are appended, making the total now 448. This gives (in hex)",
      "ja": "L = 40は、上記のビット数は41と407「0」が付加されている、448今合計を製造するこれが（16進数）が得られます"
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000.",
      "ja": "６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００。"
    },
    {
      "indent": 3,
      "text": "c. Obtain the 2-word representation of l, the number of bits in the original message. If l < 2^32 then the first word is all zeroes. Append these two words to the padded message.",
      "ja": "C。 Lの2ワードの表現を、元のメッセージ内のビット数を得ます。 Lの場合<2 ^ 32は、第1のワードはすべてゼロです。パディングされたメッセージにこれら二つの単語を追加します。"
    },
    {
      "indent": 6,
      "text": "Example: Suppose the original message is as in (b). Then l = 40 (note that l is computed before any padding). The two-word representation of 40 is hex 00000000 00000028. Hence the final padded message is hex",
      "ja": "例：元のメッセージが（B）のようであると仮定する。その後、L = 40（Lは、任意のパディングの前に計算されることに留意されたいです）。 40の2ワードの表現は、したがって、最終的なパディングメッセージがヘクスあるヘクス00000000 00000028.あります"
    },
    {
      "indent": 9,
      "text": "61626364 65800000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000028.",
      "ja": "６１６２６３６４ ６５８０００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００００ ００００００２８。"
    },
    {
      "indent": 6,
      "text": "The padded message will contain 16 * n words for some n > 0. The padded message is regarded as a sequence of n blocks M(1) , M(2), first characters (or bits) of the message.",
      "ja": "パディングされたメッセージは、パディングメッセージがメッセージのn個のブロックのシーケンスM（1）、M（2）と、第1文字（またはビット）と見なされる> 0一部nに対して16 * n個の単語を含むであろう。"
    },
    {
      "indent": 0,
      "text": "5. Functions and Constants Used",
      "section_title": true,
      "ja": "使用される5.関数や定数"
    },
    {
      "indent": 3,
      "text": "A sequence of logical functions f(0), f(1),..., f(79) is used in SHA-1. Each f(t), 0 <= t <= 79, operates on three 32-bit words B, C, D and produces a 32-bit word as output. f(t;B,C,D) is defined as follows: for words B, C, D,",
      "ja": "論理関数f（0）、Fのシーケンスは、（1）、...、F（79）は、SHA-1で使用されています。各F（t）は、0 <= T <= 79は、3つの32ビットワードB、C、Dで動作し、出力として32ビット・ワードを生成します。 F（T、B、C、D）は以下のように定義される：ワードB、C、Dのために、"
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = (B AND C) OR ((NOT B) AND D) ( 0 <= t <= 19)",
      "ja": "F（T、B、C、D）=（B AND C）OR（（NOT B）AND D）（0 <= T <= 19）"
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = B XOR C XOR D (20 <= t <= 39)",
      "ja": "F（T、B、C、D）= B XOR C XOR D（20 <= T <= 39）"
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = (B AND C) OR (B AND D) OR (C AND D) (40 <= t <= 59)",
      "ja": "F（T、B、C、D）=（B AND C）OR（B AND D）OR（C AND D）（40 <= T <= 59）"
    },
    {
      "indent": 6,
      "text": "f(t;B,C,D) = B XOR C XOR D (60 <= t <= 79).",
      "ja": "F（T、B、C、D）= B XOR C XOR D（60 <= T <= 79）。"
    },
    {
      "indent": 3,
      "text": "A sequence of constant words K(0), K(1), ... , K(79) is used in the SHA-1. In hex these are given by",
      "ja": "定数ワードのシーケンスK（0）、K（1）、...、K（79）は、SHA-1で使用されています。六角では、これらは以下の式で与えられ"
    },
    {
      "indent": 6,
      "text": "K(t) = 5A827999 ( 0 <= t <= 19)",
      "ja": "K（T）= 5A827999（0 <= T <= 19）"
    },
    {
      "indent": 6,
      "text": "K(t) = 6ED9EBA1 (20 <= t <= 39)",
      "ja": "K（T）= 6ED9EBA1（20 <= T <= 39）"
    },
    {
      "indent": 6,
      "text": "K(t) = 8F1BBCDC (40 <= t <= 59)",
      "ja": "K（T）= 8F1BBCDC（40 <= T <= 59）"
    },
    {
      "indent": 6,
      "text": "K(t) = CA62C1D6 (60 <= t <= 79).",
      "ja": "K（T）= CA62C1D6（60 <= T <= 79）。"
    },
    {
      "indent": 0,
      "text": "6. Computing the Message Digest",
      "section_title": true,
      "ja": "6.メッセージダイジェストを計算"
    },
    {
      "indent": 3,
      "text": "The methods given in 6.1 and 6.2 below yield the same message digest. Although using method 2 saves sixty-four 32-bit words of storage, it is likely to lengthen execution time due to the increased complexity of the address computations for the { W[t] } in step (c). There are other computation methods which give identical results.",
      "ja": "6.1以下6.2で与えられた方法は、同じメッセージダイジェストを得ます。方法2を使用してストレージ六十 -  4つの32ビットワードを保存しているが、原因工程（c）において、{W [T]}のためのアドレス計算の増加した複雑さの実行時間を長くする可能性があります。同じ結果が得られ、他の計算方法があります。"
    },
    {
      "indent": 0,
      "text": "6.1 Method 1",
      "section_title": true,
      "ja": "6.1方法1"
    },
    {
      "indent": 3,
      "text": "The message digest is computed using the message padded as described in section 4. The computation is described using two buffers, each consisting of five 32-bit words, and a sequence of eighty 32-bit words. The words of the first 5-word buffer are labeled A,B,C,D,E. The words of the second 5-word buffer are labeled H0, H1, H2, H3, H4. The words of the 80-word sequence are labeled W(0), W(1),..., W(79). A single word buffer TEMP is also employed.",
      "ja": "メッセージダイジェストは、計算は、2つのバッファを用いて説明するセクション4で説明したように、それぞれ5つの32ビットワードからなる、パディングメッセージを使用して計算され、80の32ビットワードのシーケンスです。第5ワードバッファのワードはA、B、C、D、E標識されます。第5ワードバッファのワードはH0、H1、H2、H3、H4標識されます。 80ワード・シーケンスのワードはW（0）、W（1）、...、W（79）標識されます。単一ワードバッファTEMPも使用されます。"
    },
    {
      "indent": 3,
      "text": "To generate the message digest, the 16-word blocks M(1), M(2),..., M(n) defined in section 4 are processed in order. The processing of each M(i) involves 80 steps.",
      "ja": "メッセージダイジェストを生成するために、16ワードブロックM（1）、M（2）、...、セクション4で定義されたM（n）は順に処理されます。各M（i）の処理は、80個のステップを含みます。"
    },
    {
      "indent": 3,
      "text": "Before processing any blocks, the H's are initialized as follows: in hex,",
      "ja": "次のように任意のブロックを処理する前に、Hさんが初期化されています六角で、"
    },
    {
      "indent": 6,
      "text": "H0 = 67452301",
      "ja": "H0 = 67452301"
    },
    {
      "indent": 6,
      "text": "H1 = EFCDAB89",
      "ja": "E 1 = Vkzds"
    },
    {
      "indent": 6,
      "text": "H2 = 98BADCFE",
      "ja": "H2 = 98BADCFE"
    },
    {
      "indent": 6,
      "text": "H3 = 10325476",
      "ja": "ハ= 10325476"
    },
    {
      "indent": 6,
      "text": "H4 = C3D2E1F0.",
      "ja": "H4 = C3D2E1F0。"
    },
    {
      "indent": 3,
      "text": "Now M(1), M(2), ... , M(n) are processed. To process M(i), we proceed as follows:",
      "ja": "今、M（1）、M（2）、...、M（n）が処理されます。次のようにM（i）を処理するために、我々は続行します："
    },
    {
      "indent": 6,
      "text": "a. Divide M(i) into 16 words W(0), W(1), ... , W(15), where W(0) is the left-most word.",
      "ja": "A。 16個のワードW（0）、一番左の単語であるW（0）、W（1）、...、W（15）にM（i）を分割します。"
    },
    {
      "indent": 6,
      "text": "b. For t = 16 to 79 let",
      "ja": "B。 T = 16から79 LETため"
    },
    {
      "indent": 9,
      "text": "W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)).",
      "ja": "W（T）= S ^ 1（W（T-3）XOR W（T-8）XOR W（T-14）XOR W（T-16））。"
    },
    {
      "indent": 6,
      "text": "c. Let A = H0, B = H1, C = H2, D = H3, E = H4.",
      "ja": "C。 A = H0、B = H1、C = H2、D = H3、E = H4をしましょう。"
    },
    {
      "indent": 6,
      "text": "d. For t = 0 to 79 do",
      "ja": "D。 79トン= 0のために行います"
    },
    {
      "indent": 9,
      "text": "TEMP = S^5(A) + f(t;B,C,D) + E + W(t) + K(t);",
      "ja": "TEMP = S ^ 5（A）+ F（T、B、C、D）+ E + W（T）+ K（T）。"
    },
    {
      "indent": 9,
      "text": "E = D; D = C; C = S^30(B); B = A; A = TEMP;",
      "ja": "E = D。 D = C。 C = S ^ 30（B）。 B = A。 A = TEMP。"
    },
    {
      "indent": 6,
      "text": "e. Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.",
      "ja": "電子。 H0 = H0 + Aをさせ、H1 = H1 + B、H2 = H2 + C、H3 = H3 + D、H4 = H4 + E."
    },
    {
      "indent": 3,
      "text": "After processing M(n), the message digest is the 160-bit string represented by the 5 words",
      "ja": "M（n）を処理した後、メッセージダイジェストは5つのワードで表される160ビット列であります"
    },
    {
      "indent": 9,
      "text": "H0 H1 H2 H3 H4.",
      "ja": "H0 H1 H2 H3 H4。"
    },
    {
      "indent": 0,
      "text": "6.2 Method 2",
      "section_title": true,
      "ja": "6.2方法2"
    },
    {
      "indent": 3,
      "text": "The method above assumes that the sequence W(0), ... , W(79) is implemented as an array of eighty 32-bit words. This is efficient from the standpoint of minimization of execution time, since the addresses of W(t-3), ... ,W(t-16) in step (b) are easily computed. If space is at a premium, an alternative is to regard { W(t) } as a circular queue, which may be implemented using an array of sixteen 32-bit words W[0], ... W[15]. In this case, in hex let",
      "ja": "この方法は、上記配列W（0）、...、W（79）は80の32ビットワードのアレイとして実現されることを想定しています。これは、（b）は、容易に計算されるステップで...、W（T-16）、W（T-3）のアドレスため、実行時間の最小化の観点から効率的です。スペースが限られている場合、別のは、16個の32ビットワードW [0]、... W [15]の配列を使用して実装することができる、円形待ち​​行列として、{W（t）を}考えることです。この場合、六角にしましょう"
    },
    {
      "indent": 3,
      "text": "MASK = 0000000F. Then processing of M(i) is as follows:",
      "ja": "MASK = 0000000F。次のようにM（i）の処理です。"
    },
    {
      "indent": 6,
      "text": "a. Divide M(i) into 16 words W[0], ... , W[15], where W[0] is the left-most word.",
      "ja": "A。 16個のワードW [0]一番左の単語であるW [0]、...、W [15]にM（i）を分割します。"
    },
    {
      "indent": 6,
      "text": "b. Let A = H0, B = H1, C = H2, D = H3, E = H4.",
      "ja": "B。 A = H0、B = H1、C = H2、D = H3、E = H4をしましょう。"
    },
    {
      "indent": 6,
      "text": "c. For t = 0 to 79 do",
      "ja": "C。 79トン= 0のために行います"
    },
    {
      "indent": 9,
      "text": "s = t AND MASK;",
      "ja": "S = TとMASK。"
    },
    {
      "indent": 9,
      "text": "if (t >= 16) W[s] = S^1(W[(s + 13) AND MASK] XOR W[(s + 8) AND MASK] XOR W[(s + 2) AND MASK] XOR W[s]);",
      "ja": "もし（T> = 16）W [S] = S ^ 1（W [（S + 13）AND MASK] XOR W [（S + 8）AND MASK] XOR W [（S + 2）AND MASK] XOR W [S]）。"
    },
    {
      "indent": 9,
      "text": "TEMP = S^5(A) + f(t;B,C,D) + E + W[s] + K(t);",
      "ja": "TEMP = S ^ 5（A）+ F（T、B、C、D）+ E + W [S] + K（T）。"
    },
    {
      "indent": 9,
      "text": "E = D; D = C; C = S^30(B); B = A; A = TEMP;",
      "ja": "E = D。 D = C。 C = S ^ 30（B）。 B = A。 A = TEMP。"
    },
    {
      "indent": 6,
      "text": "d. Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E.",
      "ja": "D。 H0 = H0 + Aをさせ、H1 = H1 + B、H2 = H2 + C、H3 = H3 + D、H4 = H4 + E."
    },
    {
      "indent": 0,
      "text": "7. C Code",
      "section_title": true,
      "ja": "7. Cコード"
    },
    {
      "indent": 3,
      "text": "Below is a demonstration implementation of SHA-1 in C. Section 7.1 contains the header file, 7.2 the C code, and 7.3 a test driver.",
      "ja": "以下C.セクション7.1にSHA-1のデモンストレーションの実装では、ヘッダファイル、7.2 Cコード、および7.3テストドライバーが含まれます。"
    },
    {
      "indent": 0,
      "text": "7.1 .h file",
      "section_title": true,
      "ja": "7.1 .hファイル"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1.h\n *\n *  Description:\n *      This is the header file for code which implements the Secure\n *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published\n *      April 17, 1995.\n *\n *      Many of the variable names in this code, especially the\n *      single character names, were used because those were the names\n *      used in the publication.\n *\n *      Please read the file sha1.c for more information.\n *\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA1_H_ #define _SHA1_H_",
      "ja": "#ifndefの_SHA1_H_の#define _SHA1_H_"
    },
    {
      "indent": 0,
      "text": "#include <stdint.h>\n/*\n * If you do not have the ISO standard stdint.h header file, then you\n * must typdef the following:\n *    name              meaning\n *  uint32_t         unsigned 32 bit integer\n *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)\n *  int_least16_t    integer of >= 16 bits\n *\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#ifndef _SHA_enum_\n#define _SHA_enum_\nenum\n{\n    shaSuccess = 0,\n    shaNull,            /* Null pointer parameter */\n    shaInputTooLong,    /* input data too long */\n    shaStateError       /* called Input after Result */\n};\n#endif\n#define SHA1HashSize 20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n *  This structure will hold context information for the SHA-1\n *  hashing operation\n */\ntypedef struct SHA1Context\n{\n    uint32_t Intermediate_Hash[SHA1HashSize/4]; /* Message Digest  */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "uint32_t Length_Low;            /* Message length in bits      */\nuint32_t Length_High;           /* Message length in bits      */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "                           /* Index into message block array   */\nint_least16_t Message_Block_Index;\nuint8_t Message_Block[64];      /* 512-bit message blocks      */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "    int Computed;               /* Is the digest computed?         */\n    int Corrupted;             /* Is the message digest corrupted? */\n} SHA1Context;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n *  Function Prototypes\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "int SHA1Reset(  SHA1Context *);\nint SHA1Input(  SHA1Context *,\n                const uint8_t *,\n                unsigned int);\nint SHA1Result( SHA1Context *,\n                uint8_t Message_Digest[SHA1HashSize]);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 0,
      "text": "7.2 .c file",
      "section_title": true,
      "ja": "7.2 .Cファイル"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1.c\n *\n *  Description:\n *      This file implements the Secure Hashing Algorithm 1 as\n *      defined in FIPS PUB 180-1 published April 17, 1995.\n *\n *      The SHA-1, produces a 160-bit message digest for a given\n *      data stream.  It should take about 2**n steps to find a\n *      message with the same digest as a given message and\n *      2**(n/2) to find any two messages with the same digest,\n *      when n is the digest size in bits.  Therefore, this\n *      algorithm can serve as a means of providing a\n *      \"fingerprint\" for a message.\n *\n *  Portability Issues:\n *      SHA-1 is defined in terms of 32-bit \"words\".  This code\n *      uses <stdint.h> (included via \"sha1.h\" to define 32 and 8\n *      bit unsigned integer types.  If your C compiler does not\n *      support 32 bit unsigned integers, this code is not\n *      appropriate.\n *\n *  Caveats:\n *      SHA-1 is designed to work with messages less than 2^64 bits\n *      long.  Although SHA-1 allows a message digest to be generated\n *      for messages of any number of bits less than 2^64, this\n *      implementation only works with messages with a length that is\n *      a multiple of the size of an 8-bit character.\n *\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#include \"sha1.h\"",
      "ja": "#include \"sha1.h\""
    },
    {
      "indent": 0,
      "text": "/*\n *  Define the SHA1 circular left shift macro\n */\n#define SHA1CircularShift(bits,word) \\\n                (((word) << (bits)) | ((word) >> (32-(bits))))",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Local Function Prototyptes */\nvoid SHA1PadMessage(SHA1Context *);\nvoid SHA1ProcessMessageBlock(SHA1Context *);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Reset\n *\n *  Description:\n *      This function will initialize the SHA1Context in preparation\n *      for computing a new SHA1 message digest.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to reset.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Reset(SHA1Context *context)\n{\n    if (!context)\n    {\n        return shaNull;\n    }",
      "raw": true
    },
    {
      "indent": 4,
      "text": "context->Length_Low             = 0;\ncontext->Length_High            = 0;\ncontext->Message_Block_Index    = 0;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "context->Intermediate_Hash[0]   = 0x67452301;\ncontext->Intermediate_Hash[1]   = 0xEFCDAB89;\ncontext->Intermediate_Hash[2]   = 0x98BADCFE;\ncontext->Intermediate_Hash[3]   = 0x10325476;\ncontext->Intermediate_Hash[4]   = 0xC3D2E1F0;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "context->Computed   = 0;\ncontext->Corrupted  = 0;",
      "raw": true
    },
    {
      "indent": 0,
      "text": " return shaSuccess; }",
      "ja": "shaSuccessリターン。 }"
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Result\n *\n *  Description:\n *      This function will return the 160-bit message digest into the\n *      Message_Digest array  provided by the caller.\n *      NOTE: The first octet of hash is stored in the 0th element,\n *            the last octet of hash in the 19th element.\n *\n *  Parameters:\n *      context: [in/out]\n *          The context to use to calculate the SHA-1 hash.\n *      Message_Digest: [out]\n *          Where the digest is returned.\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Result( SHA1Context *context,\n                uint8_t Message_Digest[SHA1HashSize])\n{\n    int i;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (!context || !Message_Digest)\n{\n    return shaNull;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (context->Corrupted) { return context->Corrupted; }",
      "ja": "（、コンテキスト>破損した）場合は、コンテキスト{>破損を返します。 }"
    },
    {
      "indent": 4,
      "text": "if (!context->Computed)\n{\n    SHA1PadMessage(context);\n    for(i=0; i<64; ++i)\n    {\n        /* message may be sensitive, clear it out */\n        context->Message_Block[i] = 0;\n    }\n    context->Length_Low = 0;    /* and clear length */\n    context->Length_High = 0;\n    context->Computed = 1;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 4,
      "text": "for(i = 0; i < SHA1HashSize; ++i) { Message_Digest[i] = context->Intermediate_Hash[i>>2] >> 8 * ( 3 - ( i & 0x03 ) ); }",
      "ja": "用（i = 0; I <SHA1HashSize; ++ I）{Message_Digest [i]は、コンテキスト=> Intermediate_Hash [I >> 2] >> 8 *（3  - （I＆0×03））。 }"
    },
    {
      "indent": 0,
      "text": " return shaSuccess; }",
      "ja": "shaSuccessリターン。 }"
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1Input\n *\n *  Description:\n *      This function accepts an array of octets as the next portion\n *      of the message.\n *\n *  Parameters:\n *      context: [in/out]\n *          The SHA context to update\n *      message_array: [in]\n *          An array of characters representing the next portion of\n *          the message.\n *      length: [in]\n *          The length of the message in message_array\n *\n *  Returns:\n *      sha Error Code.\n *\n */\nint SHA1Input(    SHA1Context    *context,\n                  const uint8_t  *message_array,\n                  unsigned       length)\n{\n    if (!length)\n    {\n        return shaSuccess;\n    }",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (!context || !message_array)\n{\n    return shaNull;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (context->Computed) { context->Corrupted = shaStateError;",
      "ja": "（、コンテキスト>計算された）場合、コンテキスト{>破損= shaStateError。"
    },
    {
      "indent": 4,
      "text": " return shaStateError; }",
      "ja": "shaStateErrorを返します。 }"
    },
    {
      "indent": 4,
      "text": "if (context->Corrupted)\n{\n     return context->Corrupted;\n}\nwhile(length-- && !context->Corrupted)\n{\ncontext->Message_Block[context->Message_Block_Index++] =\n                (*message_array & 0xFF);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "context->Length_Low += 8;\nif (context->Length_Low == 0)\n{\n    context->Length_High++;\n    if (context->Length_High == 0)\n    {\n        /* Message is too long */\n        context->Corrupted = 1;\n    }\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (context->Message_Block_Index == 64) { SHA1ProcessMessageBlock(context); }",
      "ja": "IF（、コンテキスト> Message_Block_Index == 64）{SHA1ProcessMessageBlock（コンテキスト）。 }"
    },
    {
      "indent": 4,
      "text": "message_array++; }",
      "ja": "++ message_array; }"
    },
    {
      "indent": 0,
      "text": " return shaSuccess; }",
      "ja": "shaSuccessリターン。 }"
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1ProcessMessageBlock\n *\n *  Description:\n *      This function will process the next 512 bits of the message\n *      stored in the Message_Block array.\n *\n *  Parameters:\n *      None.\n *\n *  Returns:\n *      Nothing.\n *\n *  Comments:",
      "raw": true
    },
    {
      "indent": 0,
      "text": " *      Many of the variable names in this code, especially the\n *      single character names, were used because those were the\n *      names used in the publication.\n *\n *\n */\nvoid SHA1ProcessMessageBlock(SHA1Context *context)\n{\n    const uint32_t K[] =    {       /* Constants defined in SHA-1   */\n                            0x5A827999,\n                            0x6ED9EBA1,\n                            0x8F1BBCDC,\n                            0xCA62C1D6\n                            };\n    int           t;                 /* Loop counter                */\n    uint32_t      temp;              /* Temporary word value        */\n    uint32_t      W[80];             /* Word sequence               */\n    uint32_t      A, B, C, D, E;     /* Word buffers                */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n *  Initialize the first 16 words in the array W\n */\nfor(t = 0; t < 16; t++)\n{\n    W[t] = context->Message_Block[t * 4] << 24;\n    W[t] |= context->Message_Block[t * 4 + 1] << 16;\n    W[t] |= context->Message_Block[t * 4 + 2] << 8;\n    W[t] |= context->Message_Block[t * 4 + 3];\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for(t = 16; t < 80; t++) { W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]); }",
      "ja": "用（T = 16、T <80; T ++）{W [T] = SHA1CircularShift（1、W [T-3] ^ W [T-8] ^ W [T-14] ^ W [T-16]） ; }"
    },
    {
      "indent": 4,
      "text": "A = context->Intermediate_Hash[0];\nB = context->Intermediate_Hash[1];\nC = context->Intermediate_Hash[2];\nD = context->Intermediate_Hash[3];\nE = context->Intermediate_Hash[4];",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for(t = 0; t < 20; t++)\n{\n    temp =  SHA1CircularShift(5,A) +\n            ((B & C) | ((~B) & D)) + E + W[t] + K[0];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    B = A;\n    A = temp;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for(t = 20; t < 40; t++)\n{\n    temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for(t = 40; t < 60; t++)\n{\n    temp = SHA1CircularShift(5,A) +\n           ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for(t = 60; t < 80; t++)\n{\n    temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];\n    E = D;\n    D = C;\n    C = SHA1CircularShift(30,B);\n    B = A;\n    A = temp;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "context->Intermediate_Hash[0] += A;\ncontext->Intermediate_Hash[1] += B;\ncontext->Intermediate_Hash[2] += C;\ncontext->Intermediate_Hash[3] += D;\ncontext->Intermediate_Hash[4] += E;",
      "raw": true
    },
    {
      "indent": 0,
      "text": " context->Message_Block_Index = 0; }",
      "ja": "、コンテキスト> Message_Block_Index = 0; }"
    },
    {
      "indent": 0,
      "text": "/*\n *  SHA1PadMessage\n *",
      "raw": true
    },
    {
      "indent": 1,
      "text": "* Description: * According to the standard, the message must be padded to an even * 512 bits. The first padding bit must be a '1'. The last 64 * bits represent the length of the original message. All bits in * between should be 0. This function will pad the message * according to those rules by filling the Message_Block array * accordingly. It will also call the ProcessMessageBlock function * provided appropriately. When it returns, it can be assumed that * the message digest has been computed. * * Parameters: * context: [in/out] * The context to pad * ProcessMessageBlock: [in] * The appropriate SHA*ProcessMessageBlock function * Returns: * Nothing. * */",
      "ja": "*説明：*標準によれば、メッセージがあっても* 512ビットにパディングされなければなりません。最初のパディングビットが「1」でなければなりません。最後の64の*ビットは、元のメッセージの長さを表します。間*のすべてのビットは、それに応じて* Message_Blockアレイを充填することにより、これらの規則に従って*この関数は意志パッドメッセージ0でなければなりません。また、*適切に提供さProcessMessageBlock関数を呼び出します。それが戻るとき、*メッセージダイジェストが計算されていると仮定することができます。 * *パラメータ：*コンテキスト：パッド*のProcessMessageBlockにコンテキスト* [/アウト]：戻り値*適切なSHA * ProcessMessageBlock機能* [中]：*何もありません。 * * /"
    },
    {
      "indent": 0,
      "text": "void SHA1PadMessage(SHA1Context *context)\n{\n    /*\n     *  Check to see if the current message block is too small to hold\n     *  the initial padding bits and length.  If so, we will pad the\n     *  block, process it, and then continue padding into a second\n     *  block.\n     */\n    if (context->Message_Block_Index > 55)\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0x80;\n        while(context->Message_Block_Index < 64)\n        {\n            context->Message_Block[context->Message_Block_Index++] = 0;\n        }",
      "raw": true
    },
    {
      "indent": 8,
      "text": "SHA1ProcessMessageBlock(context);",
      "ja": "SHA1ProcessMessageBlock（コンテキスト）。"
    },
    {
      "indent": 4,
      "text": "    while(context->Message_Block_Index < 56)\n    {\n        context->Message_Block[context->Message_Block_Index++] = 0;\n    }\n}\nelse\n{\n    context->Message_Block[context->Message_Block_Index++] = 0x80;\n    while(context->Message_Block_Index < 56)\n    {",
      "raw": true
    },
    {
      "indent": 4,
      "text": " context->Message_Block[context->Message_Block_Index++] = 0; } }",
      "ja": "、コンテキスト> Message_Block【、コンテキスト> Message_Block_Index ++] = 0; }}"
    },
    {
      "indent": 4,
      "text": "/*\n *  Store the message length as the last 8 octets\n */\ncontext->Message_Block[56] = context->Length_High >> 24;\ncontext->Message_Block[57] = context->Length_High >> 16;\ncontext->Message_Block[58] = context->Length_High >> 8;\ncontext->Message_Block[59] = context->Length_High;\ncontext->Message_Block[60] = context->Length_Low >> 24;\ncontext->Message_Block[61] = context->Length_Low >> 16;\ncontext->Message_Block[62] = context->Length_Low >> 8;\ncontext->Message_Block[63] = context->Length_Low;",
      "raw": true
    },
    {
      "indent": 0,
      "text": " SHA1ProcessMessageBlock(context); }",
      "ja": "SHA1ProcessMessageBlock（コンテキスト）。 }"
    },
    {
      "indent": 0,
      "text": "7.3 Test Driver",
      "section_title": true,
      "ja": "7.3テストドライバ"
    },
    {
      "indent": 3,
      "text": "The following code is a main program test driver to exercise the code in sha1.c.",
      "ja": "次のコードは、sha1.c.内のコードを行使するために、メインプログラムのテストドライバーであります"
    },
    {
      "indent": 0,
      "text": "/*\n *  sha1test.c\n *\n *  Description:\n *      This file will exercise the SHA-1 code performing the three\n *      tests documented in FIPS PUB 180-1 plus one which calls\n *      SHA1Input with an exact multiple of 512 bits, plus a few\n *      error test checks.\n *\n *  Portability Issues:\n *      None.\n *\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#include <stdint.h> #include <stdio.h> #include <string.h> #include \"sha1.h\"",
      "ja": "書式#include <stdint.h>の#include <stdio.hに>する#include <string.hの>の#include \"sha1.h\""
    },
    {
      "indent": 0,
      "text": "/*\n *  Define patterns for testing\n */\n#define TEST1   \"abc\"\n#define TEST2a  \"abcdbcdecdefdefgefghfghighijhi\"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define TEST2b  \"jkijkljklmklmnlmnomnopnopq\"\n#define TEST2   TEST2a TEST2b\n#define TEST3   \"a\"\n#define TEST4a  \"01234567012345670123456701234567\"\n#define TEST4b  \"01234567012345670123456701234567\"\n    /* an exact multiple of 512 bits */\n#define TEST4   TEST4a TEST4b\nchar *testarray[4] =\n{\n    TEST1,\n    TEST2,\n    TEST3,\n    TEST4\n};\nlong int repeatcount[4] = { 1, 1, 1000000, 10 };\nchar *resultarray[4] =\n{\n    \"A9 99 3E 36 47 06 81 6A BA 3E 25 71 78 50 C2 6C 9C D0 D8 9D\",\n    \"84 98 3E 44 1C 3B D2 6E BA AE 4A A1 F9 51 29 E5 E5 46 70 F1\",\n    \"34 AA 97 3C D4 C4 DA A4 F6 1E EB 2B DB AD 27 31 65 34 01 6F\",\n    \"DE A3 56 A2 CD DD 90 C7 A7 EC ED C5 EB B5 63 93 4F 46 04 52\"\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "int main()\n{\n    SHA1Context sha;\n    int i, j, err;\n    uint8_t Message_Digest[20];",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n *  Perform SHA-1 tests\n */\nfor(j = 0; j < 4; ++j)\n{\n    printf( \"\\nTest %d: %d, '%s'\\n\",\n            j+1,\n            repeatcount[j],\n            testarray[j]);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "err = SHA1Reset(&sha);\nif (err)\n{\n    fprintf(stderr, \"SHA1Reset Error %d.\\n\", err );\n    break;    /* out of for j loop */\n}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "for(i = 0; i < repeatcount[j]; ++i) {",
      "ja": "用（i = 0; iはrepeatCountに[j]を<; ++ I）{"
    },
    {
      "indent": 8,
      "text": "    err = SHA1Input(&sha,\n          (const unsigned char *) testarray[j],\n          strlen(testarray[j]));\n    if (err)\n    {\n        fprintf(stderr, \"SHA1Input Error %d.\\n\", err );\n        break;    /* out of for i loop */\n    }\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    err = SHA1Result(&sha, Message_Digest);\n    if (err)\n    {\n        fprintf(stderr,\n        \"SHA1Result Error %d, could not compute message digest.\\n\",\n        err );\n    }\n    else\n    {\n        printf(\"\\t\");\n        for(i = 0; i < 20 ; ++i)\n        {\n            printf(\"%02X \", Message_Digest[i]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"Should match:\\n\");\n    printf(\"\\t%s\\n\", resultarray[j]);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "    /* Test some error returns */\n    err = SHA1Input(&sha,(const unsigned char *) testarray[1], 1);\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaStateError );\n    err = SHA1Reset(0);\n    printf (\"\\nError %d. Should be %d.\\n\", err, shaNull );\n    return 0;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is intended to provide convenient open source access by the Internet community to the United States of America Federal Information Processing Standard Secure Hash Function SHA-1 [FIPS 180-1]. No independent assertion of the security of this hash function by the authors for any particular use is intended.",
      "ja": "この文書は、アメリカの連邦情報処理標準セキュアハッシュ関数SHA-1 [FIPS 180-1]にインターネットコミュニティによって、便利なオープンソースへのアクセスを提供することを意図しています。任意の特定の使用のための著者によって、このハッシュ関数の安全保障のない独立したアサーションは意図していません。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[FIPS 180-1] \"Secure Hash Standard\", United States of American, National Institute of Science and Technology, Federal Information Processing Standard (FIPS) 180-1, April 1993.",
      "ja": "[FIPS 180-1]、アメリカの米国、技術総合研究所、連邦情報処理標準（FIPS）180-1、1993年4月「ハッシュ標準セキュア」。"
    },
    {
      "indent": 3,
      "text": "[MD4] \"The MD4 Message Digest Algorithm,\" Advances in Cryptology - CRYPTO '90 Proceedings, Springer-Verlag, 1991, pp. 303-311.",
      "ja": "[MD4 \"MD4メッセージダイジェストアルゴリズムは、\" 暗号理論における進歩 -  CRYPTO '90の予稿集、シュプリンガー・フェアラーク、1991、頁303-311。"
    },
    {
      "indent": 3,
      "text": "[RFC 1320] Rivest, R., \"The MD4 Message-Digest Algorithm\", RFC 1320, April 1992.",
      "ja": "[RFC 1320]のRivest、R.、 \"MD4メッセージダイジェストアルゴリズム\"、RFC 1320、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC 1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[RFC 1321]のRivest、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC 1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Requirements for Security\", RFC 1750, December 1994.",
      "ja": "[RFC 1750]イーストレイク、D.、クロッカー、S.とJ.シラー、 \"セキュリティのためのランダム性の要件\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Donald E. Eastlake, 3rd Motorola 155 Beaver Street Milford, MA 01757 USA",
      "ja": "ドナルドE.イーストレイク、第三モトローラ155ビーバー通りミルフォード、MA 01757 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 508-634-2066 (h) +1 508-261-5434 (w) Fax: +1 508-261-4777 EMail: Donald.Eastlake@motorola.com",
      "ja": "電話：+1 508-634-2066（H）+1 508-261-5434（W）FAX番号：+1 508-261-4777電子メール：Donald.Eastlake@motorola.com"
    },
    {
      "indent": 3,
      "text": "Paul E. Jones Cisco Systems, Inc. 7025 Kit Creek Road Research Triangle Park, NC 27709 USA",
      "ja": "ポール・E.ジョーンズシスコシステムズ社7025キットクリーク道路リサーチトライアングルパーク、NC 27709 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 919 392 6948 EMail: paulej@packetizer.com",
      "ja": "電話：+1 919 392 6948 Eメール：paulej@packetizer.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}