{
  "title": {
    "text": "RFC 3493 - Basic Socket Interface Extensions for IPv6",
    "ja": "RFC 3493 - IPv6のための基本的なソケットインタフェース拡張"
  },
  "number": 3493,
  "created_at": "2019-10-29 06:05:57.347661+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        R. Gilligan\nRequest for Comments: 3493                                Intransa, Inc.\nObsoletes: 2553                                               S. Thomson\nCategory: Informational                                            Cisco\n                                                                J. Bound\n                                                               J. McCann\n                                                         Hewlett-Packard\n                                                              W. Stevens\n                                                           February 2003",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Basic Socket Interface Extensions for IPv6",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The de facto standard Application Program Interface (API) for TCP/IP applications is the \"sockets\" interface. Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non-Unix systems. TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications. But changes are required to the sockets API to support IPv6 and this memo describes these changes. These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options. These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications. Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document.",
      "ja": "TCP / IPアプリケーションのための事実上の標準アプリケーション・プログラム・インターフェース（API）は、「ソケット」のインターフェースです。このAPIは、1980年代初頭のUnix用に開発されましたが、それはまた、非Unixシステムの多種多様に実装されています。ソケットAPIを使って書かれたTCP / IPアプリケーションは、過去に移植性の高い学位を享受してきたし、我々は、IPv6アプリケーションと同じポータビリティをしたいと思います。しかし、変更はIPv6をサポートするためのソケットAPIに必要とこのメモは、これらの変更について説明しています。これらは、IPv6アドレス、新しいアドレス変換機能、およびいくつかの新しいソケットオプションを運ぶために新しいソケットアドレス構造体が含まれます。システムへの変更の最小値を導入し、既存のIPv4アプリケーションのための完全な互換性を提供しながら、これらの拡張機能は、マルチキャストなどのTCPおよびUDPアプリケーションで必要な機能の基本的なIPv6へのアクセスを提供するように設計されています。高度なIPv6機能（rawソケットとIPv6拡張ヘッダーへのアクセス）のための追加の拡張機能は、別の文書で定義されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction................................................3\n2.  Design Considerations.......................................4\n    2.1  What Needs to be Changed...............................4\n    2.2  Data Types.............................................6\n    2.3  Headers................................................6\n    2.4  Structures.............................................6\n3.  Socket Interface............................................6\n    3.1  IPv6 Address Family and Protocol Family................6\n    3.2  IPv6 Address Structure.................................7\n    3.3  Socket Address Structure for 4.3BSD-Based Systems......7\n    3.4  Socket Address Structure for 4.4BSD-Based Systems......9\n    3.5  The Socket Functions...................................9\n    3.6  Compatibility with IPv4 Applications..................10\n    3.7  Compatibility with IPv4 Nodes.........................11\n    3.8  IPv6 Wildcard Address.................................11\n    3.9  IPv6 Loopback Address.................................13\n    3.10 Portability Additions.................................14\n4.  Interface Identification...................................16\n    4.1  Name-to-Index.........................................17\n    4.2  Index-to-Name.........................................17\n    4.3  Return All Interface Names and Indexes................18\n    4.4  Free Memory...........................................18\n5.  Socket Options.............................................18\n    5.1  Unicast Hop Limit.....................................19\n    5.2  Sending and Receiving Multicast Packets...............19\n    5.3  IPV6_V6ONLY option for AF_INET6 Sockets...............22\n6.  Library Functions..........................................22\n    6.1  Protocol-Independent Nodename and\n         Service Name Translation..............................23\n    6.2  Socket Address Structure to Node Name\n         and Service Name......................................28\n    6.3  Address Conversion Functions..........................31\n    6.4  Address Testing Macros................................33\n7.  Summary of New Definitions.................................33\n8.  Security Considerations....................................35\n9.  Changes from RFC 2553......................................35\n10. Acknowledgments............................................36\n11. References.................................................37\n12. Authors' Addresses.........................................38\n13. Full Copyright Statement...................................39",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "While IPv4 addresses are 32 bits long, IPv6 addresses are 128 bits long. The socket interface makes the size of an IP address quite visible to an application; virtually all TCP/IP applications for BSD-based systems have knowledge of the size of an IP address. Those parts of the API that expose the addresses must be changed to accommodate the larger IPv6 address size. IPv6 also introduces new features, some of which must be made visible to applications via the API. This memo defines a set of extensions to the socket interface to support the larger address size and new features of IPv6. It defines \"basic\" extensions that are of use to a broad range of applications. A companion document, the \"advanced\" API [4], covers extensions that are of use to more specialized applications, examples of which include routing daemons, and the \"ping\" and \"traceroute\" utilities.",
      "ja": "IPv4アドレスは32ビット長であるが、IPv6アドレスは128ビット長です。ソケットインタフェースは、アプリケーションへのIPアドレスのサイズが非常に見えます。 BSDベースのシステムのため、事実上すべてのTCP / IPアプリケーションは、IPアドレスのサイズの知識を持っています。アドレスを公開するAPIの部分は、より大きなIPv6アドレスのサイズに適応するように変更する必要があります。 IPv6はまた、APIを介してアプリケーションに見えるようにしなければならないそのうちのいくつかの新機能が導入されています。このメモは、より大きなアドレスサイズとIPv6の新機能をサポートするためにソケットインタフェースへの拡張機能のセットを定義します。これは、幅広いアプリケーションに有用である「基本」の拡張機能を定義します。仲間ドキュメント、「高度」API [4]は、より専門的なアプリケーション、その例には、ルーティングデーモンを含むことが有用である拡張を覆い、「ピング」と「トレースルート」ユーティリティ。"
    },
    {
      "indent": 3,
      "text": "The development of this API was started in 1994 in the IETF IPng working group. The API has evolved over the years, published first in RFC 2133, then again in RFC 2553, and reaching its final form in this document.",
      "ja": "このAPIの開発は、IETFのIPngワーキンググループでは1994年に開始されました。 APIは、RFC 2553で再度、RFC 2133で最初に出版され、長年にわたって進化しており、この文書にその最終形態に到達しました。"
    },
    {
      "indent": 3,
      "text": "As the API matured and stabilized, it was incorporated into the Open Group's Networking Services (XNS) specification, issue 5.2, which was subsequently incorporated into a joint Open Group/IEEE/ISO standard [3].",
      "ja": "APIが成熟し、安定したとして、それがその後の共同オープングループ/ IEEE / ISO標準に組み込まれたOpen Groupのネットワーキング・サービス（XNS）仕様、問題5.2に組み込まれた[3]。"
    },
    {
      "indent": 3,
      "text": "Effort has been made to ensure that this document and [3] contain the same information with regard to the API definitions. However, the reader should note that this document is for informational purposes only, and that the official standard specification of the sockets API is [3].",
      "ja": "努力は、このドキュメントと[3]はAPIの定義に関して同じ情報が含まれていることを確認するために行われています。しかし、読者はこの文書は情報提供のみを目的としており、かつ[3]ソケットAPIの正式な標準仕様があることことに注意してください。"
    },
    {
      "indent": 3,
      "text": "It is expected that any future standardization work on this API would be done by the Open Group Base Working Group [6].",
      "ja": "このAPI上の任意の将来の標準化作業は、Open Groupのベースワーキンググループによって行われることが期待される[6]。"
    },
    {
      "indent": 3,
      "text": "It should also be noted that this document describes only those portions of the API needed for IPv4 and IPv6 communications. Other potential uses of the API, for example the use of getaddrinfo() and getnameinfo() with the AF_UNIX address family, are beyond the scope of this document.",
      "ja": "また、この文書は、IPv4とIPv6の通信に必要なAPIの部分のみを記述することに注意すべきです。 APIの他の潜在的な用途、AF_UNIXアドレスファミリとgetaddrinfo（）とgetnameinfo（）の例については、使用することは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "2. Design Considerations",
      "section_title": true,
      "ja": "2.設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of important considerations in designing changes to this well-worn API:",
      "ja": "このよく着用APIへの変更を設計する上で考慮すべき重要な点がいくつかあります："
    },
    {
      "indent": 3,
      "text": "- The API changes should provide both source and binary compatibility for programs written to the original API. That is, existing program binaries should continue to operate when run on a system supporting the new API. In addition, existing applications that are re-compiled and run on a system supporting the new API should continue to operate. Simply put, the API changes for IPv6 should not break existing programs. An additional mechanism for implementations to verify this is to verify the new symbols are protected by Feature Test Macros as described in [3]. (Such Feature Test Macros are not defined by this RFC.)",
      "ja": " -  APIの変更は、元のAPIに書き込まれたプログラムのソースとバイナリ互換性の両方を提供しなければなりません。これは、既存のプログラムのバイナリは、新しいAPIをサポートするシステム上で実行したときに作動し続ける必要があります。また、再コンパイルして、新しいAPIをサポートするシステム上で実行されている既存のアプリケーションは動作を継続する必要があります。簡単に言えば、IPv6のためのAPIの変更は、既存のプログラムを壊すべきではありません。これを確認するために実装するための追加の機構は、[3]に記載のように新しいシンボルが機能テストマクロによって保護されていることを確認することです。 （このような機能試験マクロはこのRFCによって定義されていません。）"
    },
    {
      "indent": 3,
      "text": "- The changes to the API should be as small as possible in order to simplify the task of converting existing IPv4 applications to IPv6.",
      "ja": " -  APIの変更は、IPv6に既存のIPv4アプリケーションを変換するタスクを簡単にするためにできるだけ小さくすべきです。"
    },
    {
      "indent": 3,
      "text": "- Where possible, applications should be able to use this API to interoperate with both IPv6 and IPv4 hosts. Applications should not need to know which type of host they are communicating with.",
      "ja": " - 可能な場合、アプリケーションはIPv6とIPv4の両方のホストと相互運用するために、このAPIを使用することができるはずです。アプリケーションは、彼らが通信しているホストのタイプを知っておく必要はありません。"
    },
    {
      "indent": 3,
      "text": "- IPv6 addresses carried in data structures should be 64-bit aligned. This is necessary in order to obtain optimum performance on 64-bit machine architectures.",
      "ja": " - データ構造で運ばれたIPv6アドレスは、64ビットの整列されなければなりません。これは、64ビットマシンアーキテクチャ上で最適なパフォーマンスを得るために必要です。"
    },
    {
      "indent": 3,
      "text": "Because of the importance of providing IPv4 compatibility in the API, these extensions are explicitly designed to operate on machines that provide complete support for both IPv4 and IPv6. A subset of this API could probably be designed for operation on systems that support only IPv6. However, this is not addressed in this memo.",
      "ja": "そのため、APIでのIPv4互換性を提供することの重要性のため、これらの拡張機能は、明示的にIPv4とIPv6の両方のための完全なサポートを提供するマシン上で動作するように設計されています。このAPIのサブセットは、おそらく唯一のIPv6をサポートするシステム上で動作するように設計することができます。しかし、これはこのメモで扱われていません。"
    },
    {
      "indent": 0,
      "text": "2.1 What Needs to be Changed",
      "section_title": true,
      "ja": "変更する必要がありますどのような2.1"
    },
    {
      "indent": 3,
      "text": "The socket interface API consists of a few distinct components:",
      "ja": "ソケットインタフェースAPIは、いくつかの異なるコンポーネントで構成されます。"
    },
    {
      "indent": 3,
      "text": "- Core socket functions.",
      "ja": " - コアソケット機能。"
    },
    {
      "indent": 3,
      "text": "- Address data structures.",
      "ja": " - アドレスデータ構造。"
    },
    {
      "indent": 3,
      "text": "- Name-to-address translation functions.",
      "ja": " - 名前からアドレスへの変換機能。"
    },
    {
      "indent": 3,
      "text": "- Address conversion functions.",
      "ja": " - アドレス変換機能。"
    },
    {
      "indent": 3,
      "text": "The core socket functions -- those functions that deal with such things as setting up and tearing down TCP connections, and sending and receiving UDP packets -- were designed to be transport independent. Where protocol addresses are passed as function arguments, they are carried via opaque pointers. A protocol-specific address data structure is defined for each protocol that the socket functions support. Applications must cast pointers to these protocol-specific address structures into pointers to the generic \"sockaddr\" address structure when using the socket functions. These functions need not change for IPv6, but a new IPv6-specific address data structure is needed.",
      "ja": "コアソケット機能 - 設定とTCPコネクションを切断し、UDPパケットを送受信するようなものを扱うそれらの機能は - 輸送に依存しないように設計されました。プロトコルアドレスが関数の引数として渡される場合、それらは不透明なポインタを経由して運ばれます。プロトコル固有のアドレスデータ構造は、ソケット関数がサポートするプロトコルごとに定義されています。ソケット関数を使用するときにアプリケーションは、一般的な「のsockaddr」アドレス構造体へのポインタにこれらのプロトコル固有のアドレス構造体へのポインタをキャストする必要があります。これらの機能は、IPv6のために変更する必要はありませんが、新しいIPv6固有のアドレスデータ構造が必要とされています。"
    },
    {
      "indent": 3,
      "text": "The \"sockaddr_in\" structure is the protocol-specific data structure for IPv4. This data structure actually includes 8-octets of unused space, and it is tempting to try to use this space to adapt the sockaddr_in structure to IPv6. Unfortunately, the sockaddr_in structure is not large enough to hold the 16-octet IPv6 address as well as the other information (address family and port number) that is needed. So a new address data structure must be defined for IPv6.",
      "ja": "「のsockaddr_in」構造は、IPv4のプロトコル固有のデータ構造です。このデータ構造は、実際に使用されていないスペースの8オクテットを含み、そしてIPv6へのsockaddr_in構造体を適応させるために、このスペースを使用しようとする魅力的です。残念ながら、sockaddr_in構造体は、16オクテットのIPv6アドレスだけでなく、必要とされているその他の情報（アドレスファミリおよびポート番号）を保持するのに十分な大きさではありません。だから、新しいアドレスデータ構造は、IPv6のために定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses are scoped [2] so they could be link-local, site, organization, global, or other scopes at this time undefined. To support applications that want to be able to identify a set of interfaces for a specific scope, the IPv6 sockaddr_in structure must support a field that can be used by an implementation to identify a set of interfaces identifying the scope for an IPv6 address.",
      "ja": "IPv6アドレスは、[2]にスコープされているので、彼らは未定義この時点で、リンクローカル、サイト、組織、グローバル、または他のスコープである可能性があります。特定のスコープのインターフェイスのセットを識別できるようにするアプリケーションをサポートする、のIPv6 sockaddr_in構造体は、IPv6アドレスの範囲を特定するインタフェースのセットを識別するために実装して使用することができるフィールドをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The IPv4 name-to-address translation functions in the socket interface are gethostbyname() and gethostbyaddr(). These are left as is, and new functions are defined which support both IPv4 and IPv6.",
      "ja": "ソケットインタフェースでIPv4の名前からアドレスへの変換機能は、gethostbyname（）およびgethostbyaddr（）です。これらはそのまま残され、そして新しい機能は、IPv4とIPv6の両方をサポートする定義されています。"
    },
    {
      "indent": 3,
      "text": "The IPv4 address conversion functions -- inet_ntoa() and inet_addr() -- convert IPv4 addresses between binary and printable form. These functions are quite specific to 32-bit IPv4 addresses. We have designed two analogous functions that convert both IPv4 and IPv6 addresses, and carry an address type parameter so that they can be extended to other protocol families as well.",
      "ja": "IPv4のアドレス変換関数 -  inet_ntoa（）とinet_addr（） - バイナリと印刷可能な形式の間でIPv4アドレスを変換します。これらの関数は、32ビットのIPv4アドレスに非常に特異的です。私たちは、IPv4とIPv6の両方のアドレスを変換する2つの類似の機能を設計し、そして、彼らは同様に他のプロトコルファミリに拡張することができるように、アドレスタイプパラメータを運ぶしています。"
    },
    {
      "indent": 3,
      "text": "Finally, a few miscellaneous features are needed to support IPv6. A new interface is needed to support the IPv6 hop limit header field. New socket options are needed to control the sending and receiving of IPv6 multicast packets.",
      "ja": "最後に、いくつかの雑多な機能がIPv6をサポートするために必要とされます。新しいインターフェイスは、IPv6ホップ限界ヘッダーフィールドをサポートするために必要とされます。新しいソケットオプションを送信し、IPv6マルチキャストパケットの送受信を制御するために必要とされています。"
    },
    {
      "indent": 3,
      "text": "The socket interface will be enhanced in the future to provide access to other IPv6 features. Some of these extensions are described in [4].",
      "ja": "ソケットインタフェースは、他のIPv6機能へのアクセスを提供するために、将来的に強化されます。これらの拡張機能の一部は、[4]で説明されています。"
    },
    {
      "indent": 0,
      "text": "2.2 Data Types",
      "section_title": true,
      "ja": "2.2データ型"
    },
    {
      "indent": 3,
      "text": "The data types of the structure elements given in this memo are intended to track the relevant standards. uintN_t means an unsigned integer of exactly N bits (e.g., uint16_t). The sa_family_t and in_port_t types are defined in [3].",
      "ja": "このメモで与えられた構造要素のデータ型は、関連する規格を追跡することを意図しています。 uintN_tは正確にNビットの符号なし整数（例えば、uint16_t）を意味します。 sa_family_tとin_port_tタイプは[3]で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.3 Headers",
      "section_title": true,
      "ja": "2.3ヘッダ"
    },
    {
      "indent": 3,
      "text": "When function prototypes and structures are shown we show the headers that must be #included to cause that item to be defined.",
      "ja": "関数のプロトタイプと構造が示されている場合、我々はその項目が定義させるようにインクルードされなければならないヘッダを示しています。"
    },
    {
      "indent": 0,
      "text": "2.4 Structures",
      "section_title": true,
      "ja": "2.4構造"
    },
    {
      "indent": 3,
      "text": "When structures are described the members shown are the ones that must appear in an implementation. Additional, nonstandard members may also be defined by an implementation. As an additional precaution nonstandard members could be verified by Feature Test Macros as described in [3]. (Such Feature Test Macros are not defined by this RFC.)",
      "ja": "構造が説明されているときに示した部材は実装に現れなければならないものです。追加の、非標準のメンバーも実装によって定義することができます。追加の予防措置非標準メンバーが機能テストマクロによって確認することができるように記載されているように、[3]。 （このような機能試験マクロはこのRFCによって定義されていません。）"
    },
    {
      "indent": 3,
      "text": "The ordering shown for the members of a structure is the recommended ordering, given alignment considerations of multibyte members, but an implementation may order the members differently.",
      "ja": "構造体のメンバーのために示す順序が推奨順序、マルチバイトメンバーの所定のアライメントの考慮であるが、実装が異なるメンバーを命ずることができます。"
    },
    {
      "indent": 0,
      "text": "3. Socket Interface",
      "section_title": true,
      "ja": "3.ソケットインタフェース"
    },
    {
      "indent": 3,
      "text": "This section specifies the socket interface changes for IPv6.",
      "ja": "このセクションでは、IPv6用ソケットインターフェイスの変更を指定します。"
    },
    {
      "indent": 0,
      "text": "3.1 IPv6 Address Family and Protocol Family",
      "section_title": true,
      "ja": "3.1 IPv6のアドレスファミリとプロトコルファミリ"
    },
    {
      "indent": 3,
      "text": "A new address family name, AF_INET6, is defined in <sys/socket.h>. The AF_INET6 definition distinguishes between the original sockaddr_in address data structure, and the new sockaddr_in6 data structure.",
      "ja": "新しいアドレスファミリ名、AF_INET6は、<SYS / socket.h>に定義されています。 AF_INET6の定義は、元のsockaddr_inアドレスデータ構造、および新しいのsockaddr_in6データ構造を区別します。"
    },
    {
      "indent": 3,
      "text": "A new protocol family name, PF_INET6, is defined in <sys/socket.h>. Like most of the other protocol family names, this will usually be defined to have the same value as the corresponding address family name:",
      "ja": "新しいプロトコルファミリ名、PF_INET6は、<SYS / socket.h>に定義されています。他のプロトコルファミリ名のほとんどのように、これは通常、対応するアドレスファミリ名と同じ値を持つように定義されます。"
    },
    {
      "indent": 6,
      "text": "#define PF_INET6 AF_INET6",
      "ja": "#define PF_INET6 AF_INET6"
    },
    {
      "indent": 3,
      "text": "The AF_INET6 is used in the first argument to the socket() function to indicate that an IPv6 socket is being created.",
      "ja": "AF_INET6はIPv6ソケットが作成されていることを示すためにソケット（）関数の最初の引数に使用されます。"
    },
    {
      "indent": 0,
      "text": "3.2 IPv6 Address Structure",
      "section_title": true,
      "ja": "3.2 IPv6アドレスの構造"
    },
    {
      "indent": 3,
      "text": "A new in6_addr structure holds a single IPv6 address and is defined as a result of including <netinet/in.h>:",
      "ja": "新しいin6_addr構造体は、単一のIPv6アドレスを保持し、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "struct in6_addr {\n    uint8_t  s6_addr[16];      /* IPv6 address */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data structure contains an array of sixteen 8-bit elements, which make up one 128-bit IPv6 address. The IPv6 address is stored in network byte order.",
      "ja": "このデータ構造は、1つの128ビットのIPv6アドレスを構成する16個の8ビット要素のアレイを含んでいます。 IPv6アドレスは、ネットワークバイト順に格納されます。"
    },
    {
      "indent": 3,
      "text": "The structure in6_addr above is usually implemented with an embedded union with extra fields that force the desired alignment level in a manner similar to BSD implementations of \"struct in_addr\". Those additional implementation details are omitted here for simplicity.",
      "ja": "上記のin6_addr構造体は、通常、「構造体in_addr形式」のBSDの実装と同様に、所望の整合レベルを強制的に余分なフィールドを持つ埋め込み組合で実現されます。これらの追加実装の詳細を簡単にするため、ここでは省略されています。"
    },
    {
      "indent": 3,
      "text": "An example is as follows:",
      "ja": "次のように例を示します。"
    },
    {
      "indent": 3,
      "text": "struct in6_addr {\n     union {\n         uint8_t  _S6_u8[16];\n         uint32_t _S6_u32[4];\n         uint64_t _S6_u64[2];\n     } _S6_un;\n};\n#define s6_addr _S6_un._S6_u8",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3 Socket Address Structure for 4.3BSD-Based Systems",
      "section_title": true,
      "ja": "3.3のソケットアドレス構造体4.3BSDベースシステムの"
    },
    {
      "indent": 3,
      "text": "In the socket interface, a different protocol-specific data structure is defined to carry the addresses for each protocol suite. Each protocol-specific data structure is designed so it can be cast into a protocol-independent data structure -- the \"sockaddr\" structure. Each has a \"family\" field that overlays the \"sa_family\" of the sockaddr data structure. This field identifies the type of the data structure.",
      "ja": "ソケットインタフェースで、異なるプロトコル固有のデータ構造は、各プロトコルスイートのアドレスを運ぶために定義されています。 「なsockaddr」構造 - それは、プロトコルに依存しないデータ構造にキャストすることができるように、各プロトコル固有のデータ構造が設計されています。それぞれがsockaddrデータ構造体の「sa_familyを」オーバーレイ「ファミリ」フィールドを持っています。このフィールドは、データ構造の種類を識別します。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_in structure is the protocol-specific address data structure for IPv4. It is used to pass addresses between applications and the system in the socket functions. The following sockaddr_in6 structure holds IPv6 addresses and is defined as a result of including the <netinet/in.h> header:",
      "ja": "sockaddr_in構造体は、IPv4のプロトコル固有のアドレスデータ構造です。ソケット関数でアプリケーションとシステムの間のアドレスを渡すために使用されます。以下SOCKADDR_IN6構造は、IPv6アドレスを保持し、<netinetの/ in.h>ヘッダを含めた結果のように定義されます。"
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This structure is designed to be compatible with the sockaddr data structure used in the 4.3BSD release.",
      "ja": "この構造は、4.3BSDリリースで使用されるsockaddrデータ構造に適合するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The sin6_family field identifies this as a sockaddr_in6 structure. This field overlays the sa_family field when the buffer is cast to a sockaddr data structure. The value of this field must be AF_INET6.",
      "ja": "sin6_familyフィールドは、sockaddr_in6構造体としてこれを識別します。バッファがsockaddrデータ構造体にキャストされた場合、このフィールドはsa_familyにフィールドをオーバーレイします。このフィールドの値はAF_INET6でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sin6_port field contains the 16-bit UDP or TCP port number. This field is used in the same way as the sin_port field of the sockaddr_in structure. The port number is stored in network byte order.",
      "ja": "sin6_portフィールドは16ビットのUDPまたはTCPポート番号が含まれています。このフィールドは、sockaddr_in構造体のsin_portフィールドと同じように使用されています。ポート番号はネットワークバイト順に格納されます。"
    },
    {
      "indent": 3,
      "text": "The sin6_flowinfo field is a 32-bit field intended to contain flow-related information. The exact way this field is mapped to or from a packet is not currently specified. Until such time as its use is specified, applications should set this field to zero when constructing a sockaddr_in6, and ignore this field in a sockaddr_in6 structure constructed by the system.",
      "ja": "sin6_flowinfoフィールドは、フローに関連する情報を含むように意図された32ビットのフィールドです。このフィールドは、パケットにまたはからマッピングされている正確な方法は、現在指定されていません。その使用のような時間が指定されるまで、アプリケーションはSOCKADDR_IN6を構築するときにゼロにこのフィールドを設定して、システムによって構築sockaddr_in6構造体では、このフィールドを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "The sin6_addr field is a single in6_addr structure (defined in the previous section). This field holds one 128-bit IPv6 address. The address is stored in network byte order.",
      "ja": "sin6_addrではフィールドは、（前のセクションで定義された）単一のin6_addr構造体です。このフィールドは、1つの128ビットのIPv6アドレスを保持しています。アドレスはネットワークバイト順に格納されます。"
    },
    {
      "indent": 3,
      "text": "The ordering of elements in this structure is specifically designed so that when sin6_addr field is aligned on a 64-bit boundary, the start of the structure will also be aligned on a 64-bit boundary. This is done for optimum performance on 64-bit architectures.",
      "ja": "sin6_addrではフィールドは64ビット境界で整列されたときに、構造の開始は、64ビット境界で整列されるように、この構造内の要素の順序は特別に設計されています。これは、64ビットアーキテクチャ上で最適なパフォーマンスのために行われます。"
    },
    {
      "indent": 3,
      "text": "The sin6_scope_id field is a 32-bit integer that identifies a set of interfaces as appropriate for the scope [2] of the address carried in the sin6_addr field. The mapping of sin6_scope_id to an interface or set of interfaces is left to implementation and future specifications on the subject of scoped addresses.",
      "ja": "ではsin6_scope_idフィールドスコープに適切なようにインターフェースのセットを識別する32ビットの整数である[2] sin6_addrではフィールドで運ばアドレス。インタフェースまたはインタフェースのセットにではsin6_scope_idのマッピングは、スコープアドレスの主題に実装と将来の仕様に任されています。"
    },
    {
      "indent": 3,
      "text": "Notice that the sockaddr_in6 structure will normally be larger than the generic sockaddr structure. On many existing implementations the sizeof(struct sockaddr_in) equals sizeof(struct sockaddr), with both being 16 bytes. Any existing code that makes this assumption needs to be examined carefully when converting to IPv6.",
      "ja": "sockaddr_in6構造体は、通常一般的なsockaddr構造体よりも大きくなることに注意してください。多くの既存の実装ではsizeof（構造体のsockaddr_in）は両方とも16バイトで、はsizeof（いるsockaddr）に等しいです。この仮定を作る任意の既存のコードは、IPv6に変換するときに慎重に検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4 Socket Address Structure for 4.4BSD-Based Systems",
      "section_title": true,
      "ja": "3.4のソケットアドレス構造体4.4BSDベースシステムの"
    },
    {
      "indent": 3,
      "text": "The 4.4BSD release includes a small, but incompatible change to the socket interface. The \"sa_family\" field of the sockaddr data structure was changed from a 16-bit value to an 8-bit value, and the space saved used to hold a length field, named \"sa_len\". The sockaddr_in6 data structure given in the previous section cannot be correctly cast into the newer sockaddr data structure. For this reason, the following alternative IPv6 address data structure is provided to be used on systems based on 4.4BSD. It is defined as a result of including the <netinet/in.h> header.",
      "ja": "4.4BSDリリースは、ソケットインタフェースに小さいが、互換性のない変更が含まれています。 sockaddrデータ構造体の「sa_family」フィールドは、8ビット値に16-ビット値から変更、及び空間「SA_LEN」という名前の長さフィールドを保持するために使用される保存されました。前節で与えられたsockaddr_in6データ構造は正しく、新しいsockaddrデータ構造体にキャストすることはできません。この理由のために、以下の代替的なIPv6アドレスデータ構造は4.4BSDに基づくシステムで使用されるように設けられています。これは、<netinetの/ in.h>ヘッダを含めた結果として定義されます。"
    },
    {
      "indent": 0,
      "text": "struct sockaddr_in6 {\n    uint8_t         sin6_len;       /* length of this struct */\n    sa_family_t     sin6_family;    /* AF_INET6 */\n    in_port_t       sin6_port;      /* transport layer port # */\n    uint32_t        sin6_flowinfo;  /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The only differences between this data structure and the 4.3BSD variant are the inclusion of the length field, and the change of the family field to a 8-bit data type. The definitions of all the other fields are identical to the structure defined in the previous section.",
      "ja": "このデータ構造体と4.3BSD変異体との間の唯一の違いは、長さフィールドの包含、及び8ビットのデータ型へファミリーフィールドの変化です。他のすべてのフィールドの定義は、前のセクションで定義された構造と同一です。"
    },
    {
      "indent": 3,
      "text": "Systems that provide this version of the sockaddr_in6 data structure must also declare SIN6_LEN as a result of including the <netinet/in.h> header. This macro allows applications to determine whether they are being built on a system that supports the 4.3BSD or 4.4BSD variants of the data structure.",
      "ja": "SOCKADDR_IN6データ構造のこのバージョンを提供するシステムは、また、<netinetの/ in.h>ヘッダを含めた結果としてSIN6_LENを宣言しなければなりません。このマクロは、アプリケーションが、彼らはデータ構造の4.3BSDや4.4BSD変種をサポートするシステム上に構築されているかどうかを判断することができます。"
    },
    {
      "indent": 0,
      "text": "3.5 The Socket Functions",
      "section_title": true,
      "ja": "3.5ソケット関数"
    },
    {
      "indent": 3,
      "text": "Applications call the socket() function to create a socket descriptor that represents a communication endpoint. The arguments to the socket() function tell the system which protocol to use, and what format address structure will be used in subsequent functions. For example, to create an IPv4/TCP socket, applications make the call:",
      "ja": "アプリケーションは、通信エンドポイントを表しソケット記述子を作成するためのソケット（）関数を呼び出します。ソケット（）関数の引数は、プロトコルを使用するようにシステムに指示し、どのような形式のアドレス構造は、後続の関数で使用されるであろう。例えば、IPv4 / TCPソケットを作成するには、アプリケーションは電話をかけます："
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_STREAM, 0);",
      "ja": "S =ソケット（AF_INET、SOCK_STREAM、0）;"
    },
    {
      "indent": 3,
      "text": "To create an IPv4/UDP socket, applications make the call:",
      "ja": "IPv4の/ UDPソケットを作成するには、アプリケーションは電話をかけます："
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_DGRAM, 0);",
      "ja": "S =ソケット（AF_INET、SOCK_DGRAM、0）;"
    },
    {
      "indent": 3,
      "text": "Applications may create IPv6/TCP and IPv6/UDP sockets (which may also handle IPv4 communication as described in section 3.7) by simply using the constant AF_INET6 instead of AF_INET in the first argument. For example, to create an IPv6/TCP socket, applications make the call:",
      "ja": "アプリケーションは、単に最初の引数に代わりAF_INETの定数AF_INET6を用いてIPv6 / TCPと（セクション3.7で説明したように、またIPv4の通信を処理することができる）は、IPv6 / UDPソケットを作成することができます。例えば、IPv6 / TCPソケットを作成するには、アプリケーションは電話をかけます："
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET6, SOCK_STREAM, 0);",
      "ja": "S =ソケット（AF_INET6、SOCK_STREAM、0）;"
    },
    {
      "indent": 3,
      "text": "To create an IPv6/UDP socket, applications make the call:",
      "ja": "IPv6の/ UDPソケットを作成するには、アプリケーションは電話をかけます："
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET6, SOCK_DGRAM, 0);",
      "ja": "S =ソケット（AF_INET6、SOCK_DGRAM、0）;"
    },
    {
      "indent": 3,
      "text": "Once the application has created a AF_INET6 socket, it must use the sockaddr_in6 address structure when passing addresses in to the system. The functions that the application uses to pass addresses into the system are:",
      "ja": "アプリケーションがAF_INET6ソケットを作成した後は、システムにアドレスを渡すとき、それはSOCKADDR_IN6アドレス構造体を使用する必要があります。アプリケーションがシステムにアドレスを渡すために使用する機能は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "bind() connect() sendmsg() sendto()",
      "ja": "バインド（）（接続）にsendmsg（）はsendto（）"
    },
    {
      "indent": 3,
      "text": "The system will use the sockaddr_in6 address structure to return addresses to applications that are using AF_INET6 sockets. The functions that return an address from the system to an application are:",
      "ja": "システムは、AF_INET6ソケットを使用しているアプリケーションにアドレスを返すためにSOCKADDR_IN6アドレス構造を使用します。システムからアプリケーションにアドレスを返す関数は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "accept() recvfrom() recvmsg() getpeername() getsockname()",
      "ja": "受け入れる（）のrecvfrom（）のrecvmsg（）getpeername（）のgetsockname（）"
    },
    {
      "indent": 3,
      "text": "No changes to the syntax of the socket functions are needed to support IPv6, since all of the \"address carrying\" functions use an opaque address pointer, and carry an address length as a function argument.",
      "ja": "機能を「運ぶアドレス」のすべてが不透明なアドレスポインタを使用して、関数の引数としてアドレスの長さを運ぶため、ソケット関数の構文への変更は、IPv6をサポートするために必要ではありません。"
    },
    {
      "indent": 0,
      "text": "3.6 Compatibility with IPv4 Applications",
      "section_title": true,
      "ja": "IPv4アプリケーションとの互換性3.6"
    },
    {
      "indent": 3,
      "text": "In order to support the large base of applications using the original API, system implementations must provide complete source and binary compatibility with the original API. This means that systems must continue to support AF_INET sockets and the sockaddr_in address structure. Applications must be able to create IPv4/TCP and IPv4/UDP sockets using the AF_INET constant in the socket() function, as described in the previous section. Applications should be able to hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets simultaneously within the same process.",
      "ja": "元のAPIを使用するアプリケーションの大きなベースをサポートするために、システムの実装は、元のAPIとの完全なソースおよびバイナリ互換性を提供しなければなりません。これは、システムがAF_INETソケットとsockaddr_inアドレス構造体をサポートし続けなければならないことを意味します。アプリケーションは、前のセクションで説明したように、のIPv4 / TCPソケット（）関数でAF_INET定数を用いたIPv4 / UDPソケットを作成することができなければなりません。アプリケーションは、同じプロセス内で同時に、IPv4の/ UDP、IPv6の/ TCPとIPv6 / UDPソケットのIPv4 / TCPの組み合わせを保持することができるはずです。"
    },
    {
      "indent": 3,
      "text": "Applications using the original API should continue to operate as they did on systems supporting only IPv4. That is, they should continue to interoperate with IPv4 nodes.",
      "ja": "オリジナルのAPIを使用するアプリケーションは、彼らがIPv4のみをサポートしているシステム上で行ったように動作し続ける必要があります。つまり、彼らは、IPv4ノードと相互運用を継続する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7 Compatibility with IPv4 Nodes",
      "section_title": true,
      "ja": "IPv4のノードと3.7の互換性"
    },
    {
      "indent": 3,
      "text": "The API also provides a different type of compatibility: the ability for IPv6 applications to interoperate with IPv4 applications. This feature uses the IPv4-mapped IPv6 address format defined in the IPv6 addressing architecture specification [2]. This address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF. IPv4-mapped addresses are written as follows:",
      "ja": "IPv4アプリケーションと相互運用するIPv6アプリケーションのための能力：APIも互換性の異なる種類を提供します。この機能は、IPv6アドレス体系仕様[2]で定義されたIPv4マップIPv6アドレス形式を使用します。このアドレス形式は、IPv4ノードのIPv4アドレスは、IPv6アドレスとして表現することが可能になります。 IPv4アドレスは、IPv6アドレスの下位32ビットと上位96ビットに符号化された固定プレフィックス0ホールド：0：0：0：0 FFFFを。次のようにIPv4マップアドレスが書かれています："
    },
    {
      "indent": 6,
      "text": "::FFFF:<IPv4-address>",
      "ja": ":: FFFF：<IPv4のアドレス>"
    },
    {
      "indent": 3,
      "text": "These addresses can be generated automatically by the getaddrinfo() function, as described in Section 6.1.",
      "ja": "セクション6.1で説明したようにこれらのアドレスは、はgetaddrinfo（）関数によって自動的に生成することができます。"
    },
    {
      "indent": 3,
      "text": "Applications may use AF_INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by simply encoding the destination's IPv4 address as an IPv4-mapped IPv6 address, and passing that address, within a sockaddr_in6 structure, in the connect() or sendto() call. When applications use AF_INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system returns the peer's address to the application in the accept(), recvfrom(), or getpeername() call using a sockaddr_in6 structure encoded this way.",
      "ja": "アプリケーションは、IPv4ノードへのTCP接続を開くために、AF_INET6ソケットを使用し、または（単に接続で、IPv4マップIPv6アドレスとして送信先のIPv4アドレスをコードし、sockaddr_in6構造体の中に、そのアドレスを渡すことによって、IPv4ノードにUDPパケットを送信することができます）またはのsendto（）呼び出し。アプリケーションがIPv4ノードからのTCP接続を受け入れる、またはIPv4ノードからのUDPパケットを受信するAF_INET6ソケットを使用する場合、システムは、符号化されたsockaddr_in6構造体を使用して、）（のrecvfrom（）、あるいはgetpeername（）コールを受け入れるアプリケーションにピアのアドレスを返しますこちらです。"
    },
    {
      "indent": 3,
      "text": "Few applications will likely need to know which type of node they are interoperating with. However, for those applications that do need to know, the IN6_IS_ADDR_V4MAPPED() macro, defined in Section 6.4, is provided.",
      "ja": "いくつかのアプリケーションは、おそらく、彼らがと相互運用されているノードの種類を知っておく必要があります。しかし、知っておく必要がありますそれらのアプリケーションのために、6.4節で定義されたIN6_IS_ADDR_V4MAPPED（）マクロは、提供されます。"
    },
    {
      "indent": 0,
      "text": "3.8 IPv6 Wildcard Address",
      "section_title": true,
      "ja": "3.8 IPv6のワイルドカードアドレス"
    },
    {
      "indent": 3,
      "text": "While the bind() function allows applications to select the source IP address of UDP packets and TCP connections, applications often want the system to select the source address for them. With IPv4, one specifies the address as the symbolic constant INADDR_ANY (called the \"wildcard\" address) in the bind() call, or simply omits the bind() entirely.",
      "ja": "バインド（）関数は、アプリケーションがUDPパケットやTCPコネクションの送信元IPアドレスを選択することができますが、アプリケーションは多くの場合、システムはそれらの送信元アドレスを選択します。 IPv4では、1はバインド（）の呼び出しで（「ワイルドカード」と呼ばれるアドレス）シンボリック定数INADDR_ANYとしてアドレスを指定する、または単に完全に）（バインドを省略します。"
    },
    {
      "indent": 3,
      "text": "Since the IPv6 address type is a structure (struct in6_addr), a symbolic constant can be used to initialize an IPv6 address variable, but cannot be used in an assignment. Therefore systems provide the IPv6 wildcard address in two forms.",
      "ja": "IPv6アドレスタイプは構造体（構造体のin6_addr）であるため、記号定数はIPv6アドレス変数を初期化するために使用することができるが、割り当てには使用できません。したがって、システムは、2つの形式でのIPv6ワイルドカードアドレスを提供しています。"
    },
    {
      "indent": 3,
      "text": "The first version is a global variable named \"in6addr_any\" that is an in6_addr structure. The extern declaration for this variable is defined in <netinet/in.h>:",
      "ja": "最初のバージョンは、in6_addr構造体である「IN6ADDR_ANY」という名前のグローバル変数です。この変数のextern宣言は、<netinetの/ in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_any;",
      "ja": "IN6ADDR_ANYのin6_addrにextern constの構造体。"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_any similarly to the way they use INADDR_ANY in IPv4. For example, to bind a socket to port number 23, but let the system select the source address, an application could use the following code:",
      "ja": "アプリケーションは、彼らがIPv4でINADDR_ANYを使用する方法と同様にIN6ADDR_ANY使用しています。例えば、ポート番号23にソケットをバインドしますが、システムは、送信元アドレスを選択できるように、アプリケーションは以下のコードを使用することができます。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_any;  /* structure assignment */\n . . .\nif (bind(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The other version is a symbolic constant named IN6ADDR_ANY_INIT and is defined in <netinet/in.h>. This constant can be used to initialize an in6_addr structure:",
      "ja": "他のバージョンはIN6ADDR_ANY_INITという名前のシンボル定数で、<netinetの/ in.h>で定義されています。この定数は、in6_addr構造体を初期化するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "struct in6_addr anyaddr = IN6ADDR_ANY_INIT;",
      "ja": "構造体のin6_addr anyaddr = IN6ADDR_ANY_INIT。"
    },
    {
      "indent": 3,
      "text": "Note that this constant can be used ONLY at declaration time. It can not be used to assign a previously declared in6_addr structure. For example, the following code will not work:",
      "ja": "この定数はONLY宣言時に使用できることに注意してください。以前のin6_addr宣言された構造体を割り当てるために使用することはできません。たとえば、次のコードは動作しません。"
    },
    {
      "indent": 6,
      "text": "/* This is the WRONG way to assign an unspecified address */\nstruct sockaddr_in6 sin6;\n . . .\nsin6.sin6_addr = IN6ADDR_ANY_INIT; /* will NOT compile */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Be aware that the IPv4 INADDR_xxx constants are all defined in host byte order but the IPv6 IN6ADDR_xxx constants and the IPv6 in6addr_xxx externals are defined in network byte order.",
      "ja": "IPv4のINADDR_xxx定数は全てホストバイトオーダで定義されていますが、IPv6のIN6ADDR_xxx定数とIPv6 in6addr_xxx外部宣言は、ネットワークバイト順で定義されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.9 IPv6 Loopback Address",
      "section_title": true,
      "ja": "3.9 IPv6のループバックアドレス"
    },
    {
      "indent": 3,
      "text": "Applications may need to send UDP packets to, or originate TCP connections to, services residing on the local node. In IPv4, they can do this by using the constant IPv4 address INADDR_LOOPBACK in their connect(), sendto(), or sendmsg() call.",
      "ja": "アプリケーションは、ローカル・ノード上にあるサービスへのTCP接続をするUDPパケットを送信し、または発信する必要があるかもしれません。 IPv4では、彼らは彼らの接続（）、のsendto（）、またはにsendmsg（）呼び出しで一定のIPv4アドレスINADDR_LOOPBACKを使用してこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "IPv6 also provides a loopback address to contact local TCP and UDP services. Like the unspecified address, the IPv6 loopback address is provided in two forms -- a global variable and a symbolic constant.",
      "ja": "IPv6は、ローカルTCPおよびUDPサービスに連絡するためにループバックアドレスを提供します。グローバル変数とシンボル定数 - 未指定アドレスと同じように、IPv6ループバックアドレスは、2つの形式で提供されています。"
    },
    {
      "indent": 3,
      "text": "The global variable is an in6_addr structure named \"in6addr_loopback.\" The extern declaration for this variable is defined in <netinet/in.h>:",
      "ja": "グローバル変数は、名前のin6_addr構造体である「in6addr_loopback。」この変数のextern宣言は、<netinetの/ in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "extern const struct in6_addr in6addr_loopback;",
      "ja": "in6addr_loopbackのin6_addrにextern constの構造体。"
    },
    {
      "indent": 3,
      "text": "Applications use in6addr_loopback as they would use INADDR_LOOPBACK in IPv4 applications (but beware of the byte ordering difference mentioned at the end of the previous section). For example, to open a TCP connection to the local telnet server, an application could use the following code:",
      "ja": "アプリケーションは、IPv4アプリケーションでINADDR_LOOPBACKを使用する（ただし、前のセクションの最後に言及したバイト順序の違いに注意）と同じようにin6addr_loopback使用します。たとえば、ローカルのtelnetサーバへのTCP接続を開くために、アプリケーションは以下のコードを使用することができます。"
    },
    {
      "indent": 3,
      "text": "struct sockaddr_in6 sin6;\n . . .\nsin6.sin6_family = AF_INET6;\nsin6.sin6_flowinfo = 0;\nsin6.sin6_port = htons(23);\nsin6.sin6_addr = in6addr_loopback;  /* structure assignment */\n . . .\nif (connect(s, (struct sockaddr *) &sin6, sizeof(sin6)) == -1)\n        . . .",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The symbolic constant is named IN6ADDR_LOOPBACK_INIT and is defined in <netinet/in.h>. It can be used at declaration time ONLY; for example:",
      "ja": "シンボリック定数はIN6ADDR_LOOPBACK_INITという名前で、<netinetの/ in.h>で定義されています。それが唯一の宣言時に使用することができます。例えば："
    },
    {
      "indent": 6,
      "text": "struct in6_addr loopbackaddr = IN6ADDR_LOOPBACK_INIT;",
      "ja": "構造体のin6_addr loopbackaddr = IN6ADDR_LOOPBACK_INIT。"
    },
    {
      "indent": 3,
      "text": "Like IN6ADDR_ANY_INIT, this constant cannot be used in an assignment to a previously declared IPv6 address variable.",
      "ja": "IN6ADDR_ANY_INITと同様に、この定数は前に宣言IPv6アドレス変数への代入に使用することはできません。"
    },
    {
      "indent": 0,
      "text": "3.10 Portability Additions",
      "section_title": true,
      "ja": "3.10移植性の追加"
    },
    {
      "indent": 3,
      "text": "One simple addition to the sockets API that can help application writers is the \"struct sockaddr_storage\". This data structure can simplify writing code that is portable across multiple address families and platforms. This data structure is designed with the following goals.",
      "ja": "アプリケーション作成者を助けることができるソケットAPIへの一つの簡単な追加は、「構造体SOCKADDR_STORAGE」です。このデータ構造は、複数のアドレスファミリーとプラットフォーム間で移植性がある書き込みコードを簡素化することができます。このデータ構造は、以下の目的で設計されています。"
    },
    {
      "indent": 3,
      "text": "- Large enough to accommodate all supported protocol-specific address structures.",
      "ja": " - サポートされているすべてのプロトコル固有のアドレス構造体を収容するのに十分な大きさ。"
    },
    {
      "indent": 3,
      "text": "- Aligned at an appropriate boundary so that pointers to it can be cast as pointers to protocol specific address structures and used to access the fields of those structures without alignment problems.",
      "ja": " - それへのポインタは、プロトコル固有のアドレス構造体へのポインタとしてキャストし、位置合わせの問題なしにこれらの構造のフィールドにアクセスするために使用することができるように、適切な境界で整列されます。"
    },
    {
      "indent": 3,
      "text": "The sockaddr_storage structure contains field ss_family which is of type sa_family_t. When a sockaddr_storage structure is cast to a sockaddr structure, the ss_family field of the sockaddr_storage structure maps onto the sa_family field of the sockaddr structure. When a sockaddr_storage structure is cast as a protocol specific address structure, the ss_family field maps onto a field of that structure that is of type sa_family_t and that identifies the protocol's address family.",
      "ja": "SOCKADDR_STORAGE構造は、型sa_family_tのあるフィールドss_familyをが含まれています。 SOCKADDR_STORAGE構造はsockaddr構造体にキャストされた場合、SOCKADDR_STORAGE構造のss_familyをフィールドはsockaddr構造体のsa_familyにフィールド上にマッピングします。 SOCKADDR_STORAGE構造は、プロトコル固有のアドレス構造体としてキャストされた場合、ss_familyをフィールドの型はsa_family_tであり、それは、プロトコルのアドレスファミリを識別し、その構造体のフィールド上にマッピングされます。"
    },
    {
      "indent": 3,
      "text": "An example implementation design of such a data structure would be as follows.",
      "ja": "次のようにこのようなデータ構造の例示的な実装設計があろう。"
    },
    {
      "indent": 0,
      "text": "/*\n * Desired design of maximum size and alignment\n */\n#define _SS_MAXSIZE    128  /* Implementation specific max size */\n#define _SS_ALIGNSIZE  (sizeof (int64_t))\n                         /* Implementation specific desired alignment */\n/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE   (_SS_ALIGNSIZE - sizeof (sa_family_t))\n#define _SS_PAD2SIZE   (_SS_MAXSIZE - (sizeof (sa_family_t) +\n                              _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    sa_family_t  ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char      __ss_pad1[_SS_PAD1SIZE];\n              /* 6 byte pad, this is to make implementation\n              /* specific pad up to alignment field that */\n              /* follows explicit in the data structure */\n    int64_t   __ss_align;     /* field to force desired structure */\n               /* storage alignment */\n    char      __ss_pad2[_SS_PAD2SIZE];\n              /* 112 byte pad to achieve desired size, */\n              /* _SS_MAXSIZE value minus size of ss_family */\n              /* __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above example implementation illustrates a data structure which will align on a 64-bit boundary. An implementation-specific field \"__ss_align\" along with \"__ss_pad1\" is used to force a 64-bit alignment which covers proper alignment good enough for the needs of sockaddr_in6 (IPv6), sockaddr_in (IPv4) address data structures. The size of padding field __ss_pad1 depends on the chosen alignment boundary. The size of padding field __ss_pad2 depends on the value of overall size chosen for the total size of the structure. This size and alignment are represented in the above example by implementation specific (not required) constants _SS_MAXSIZE (chosen value 128) and _SS_ALIGNSIZE (with chosen value 8). Constants _SS_PAD1SIZE (derived value 6) and _SS_PAD2SIZE (derived value 112) are also for illustration and not required. The derived values assume sa_family_t is 2 bytes. The implementation specific definitions and structure field names above start with an underscore to denote implementation private namespace. Portable code is not expected to access or reference those fields or constants.",
      "ja": "上記の例の実装では、64ビット境界に整列するデータ構造を示す図です。実装固有のフィールド「__ss_align」「__ss_pad1」と一緒に、のsockaddr_in（IPv4）のアドレスデータ構造（IPv6）のSOCKADDR_IN6のニーズには十分適切な整列をカバーする64ビットのアライメントを強制するために使用されます。パディングフィールド__ss_pad1のサイズは、選択された整列境界に依存します。パディングフィールド__ss_pad2のサイズは、構造体の合計サイズのために選択された全体的な大きさの値に依存します。このサイズとアライメントは、実装特定することにより、上記の例に示されている（必須ではない）_SS_MAXSIZE（選択された値128）と_SS_ALIGNSIZE（選択された値8を有する）を定数。定数_SS_PAD1SIZE（派生値6）と_SS_PAD2SIZE（派生値112）は説明のためでもあるし、必要ではありません。得られた値は2バイトであるsa_family_t仮定する。実装プライベート名前空間を表すために、アンダースコアで開始上記の実装固有の定義と構造体のフィールド名。ポータブルコードがアクセスしたり、それらのフィールドまたは定数を参照することが期待されていません。"
    },
    {
      "indent": 3,
      "text": "On implementations where the sockaddr data structure includes a \"sa_len\" field this data structure would look like this:",
      "ja": "sockaddrデータ構造体は、このデータ構造「SA_LEN」フィールドを含む実装では、次のようになります。"
    },
    {
      "indent": 0,
      "text": "/*\n * Definitions used for sockaddr_storage structure paddings design.\n */\n#define _SS_PAD1SIZE (_SS_ALIGNSIZE -\n                            (sizeof (uint8_t) + sizeof (sa_family_t))\n#define _SS_PAD2SIZE (_SS_MAXSIZE -\n                            (sizeof (uint8_t) + sizeof (sa_family_t) +\n                             _SS_PAD1SIZE + _SS_ALIGNSIZE))\nstruct sockaddr_storage {\n    uint8_t      ss_len;        /* address length */\n    sa_family_t  ss_family;     /* address family */\n    /* Following fields are implementation specific */\n    char         __ss_pad1[_SS_PAD1SIZE];\n                  /* 6 byte pad, this is to make implementation\n                  /* specific pad up to alignment field that */\n                  /* follows explicit in the data structure */\n    int64_t      __ss_align;  /* field to force desired structure */\n                  /* storage alignment */\n    char         __ss_pad2[_SS_PAD2SIZE];\n                  /* 112 byte pad to achieve desired size, */\n                  /* _SS_MAXSIZE value minus size of ss_len, */\n                  /* __ss_family, __ss_pad1, __ss_align fields is 112 */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Interface Identification",
      "section_title": true,
      "ja": "4.インタフェース識別"
    },
    {
      "indent": 3,
      "text": "This API uses an interface index (a small positive integer) to identify the local interface on which a multicast group is joined (Section 5.2). Additionally, the advanced API [4] uses these same interface indexes to identify the interface on which a datagram is received, or to specify the interface on which a datagram is to be sent.",
      "ja": "このAPIは、マルチキャストグループが接合されているローカルインターフェース（5.2節）を識別するために、インターフェイスインデックス（小さな正の整数）を使用します。また、高度なAPI [4]は、データグラムが受信されたインターフェイスを識別するために、これらの同じインターフェイスインデックスを使用し、又はデータグラムが送信されるインターフェイスを指定します。"
    },
    {
      "indent": 3,
      "text": "Interfaces are normally known by names such as \"le0\", \"sl1\", \"ppp2\", and the like. On Berkeley-derived implementations, when an interface is made known to the system, the kernel assigns a unique positive integer value (called the interface index) to that interface. These are small positive integers that start at 1. (Note that 0 is never used for an interface index.) There may be gaps so that there is no current interface for a particular positive interface index.",
      "ja": "インタフェースは通常、「le0」、「SL1」、「PPP2」などの名前で知られています。バークレー由来の実装に、インターフェイスがシステムに知られた場合、カーネルは、そのインターフェイスに（インターフェイスインデックスと呼ばれる）一意の正の整数値を割り当てます。これらは、1から始まり、小さな正の整数である（0はインターフェイスインデックスに使用されることはないことに留意されたい。）特定の正のインタフェースインデックスのための現在のインタフェースが存在しないように隙間があってもよいです。"
    },
    {
      "indent": 3,
      "text": "This API defines two functions that map between an interface name and index, a third function that returns all the interface names and indexes, and a fourth function to return the dynamic memory allocated by the previous function. How these functions are implemented is left up to the implementation. 4.4BSD implementations can implement these functions using the existing sysctl() function with the NET_RT_IFLIST command. Other implementations may wish to use ioctl() for this purpose.",
      "ja": "このAPIは、以前の関数によって割り当てられた動的メモリを返却するために2つのインタフェース名とインデックスとの間のマッピング関数は、全てのインターフェイス名とインデックスを返す第三の機能、及び第4の機能を定義します。どのようにこれらの機能が実装されていることは実装に任されています。 4.4BSDの実装はNET_RT_IFLISTコマンドで既存のsysctl（）関数を使用してこれらの機能を実現することができます。他の実装は、この目的のためにioctl（）を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.1 Name-to-Index",
      "section_title": true,
      "ja": "4.1名前からインデックス"
    },
    {
      "indent": 3,
      "text": "The first function maps an interface name into its corresponding index.",
      "ja": "最初の関数は、対応するインデックスにインタフェース名をマッピングします。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "ja": "書式#include <ネット/ if.h>"
    },
    {
      "indent": 6,
      "text": "unsigned int if_nametoindex(const char *ifname);",
      "ja": "unsigned int型if_nametoindex（のconst char型*のifnameの）;"
    },
    {
      "indent": 3,
      "text": "If ifname is the name of an interface, the if_nametoindex() function shall return the interface index corresponding to name ifname; otherwise, it shall return zero. No errors are defined.",
      "ja": "ifNameはインターフェースの名前である場合、if_nametoindex（）関数のifNameの名に対応するインターフェイスインデックスを返します。それ以外の場合は、ゼロを返します。エラーは定義されていません。"
    },
    {
      "indent": 0,
      "text": "4.2 Index-to-Name",
      "section_title": true,
      "ja": "4.2インデックス・ツー・名前"
    },
    {
      "indent": 3,
      "text": "The second function maps an interface index into its corresponding name.",
      "ja": "第二の機能は、対応する名前にインタフェースインデックスをマッピングします。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "ja": "書式#include <ネット/ if.h>"
    },
    {
      "indent": 6,
      "text": "char *if_indextoname(unsigned int ifindex, char *ifname);",
      "ja": "CHAR * if_indextoname（unsigned int型のifIndex、のchar *のifnameの）;"
    },
    {
      "indent": 3,
      "text": "When this function is called, the ifname argument shall point to a buffer of at least IF_NAMESIZE bytes. The function shall place in this buffer the name of the interface with index ifindex. (IF_NAMESIZE is also defined in <net/if.h> and its value includes a terminating null byte at the end of the interface name.) If ifindex is an interface index, then the function shall return the value supplied in ifname, which points to a buffer now containing the interface name. Otherwise, the function shall return a NULL pointer and set errno to indicate the error. If there is no interface corresponding to the specified index, errno is set to ENXIO. If there was a system error (such as running out of memory), errno would be set to the proper value (e.g., ENOMEM).",
      "ja": "この関数が呼び出されると、ifnameの引数は、少なくともIF_NAMESIZEバイトのバッファを指しているものとします。この関数は、インデックスのifIndexとのインタフェースの名前をバッファリングし、この中に置くものとします。 （IF_NAMESIZEも<ネット/ if.h>で定義され、その値はインタフェース名の末尾に終端のNULLバイトを含む。）のifIndexインターフェイスインデックスである場合、関数は、のifNameに供給された値を返すものとし、その点今インタフェース名を含むバッファへ。それ以外の場合、この関数はNULLポインタを返し、エラーを示すためにerrnoを設定しなければなりません。指定されたインデックスに対応するインターフェイスがない場合、errnoはENXIOに設定されています。 （そのようなメモリの不足など）、システムエラーが発生した場合、errnoが適切な値（例えば、ENOMEM）に設定されることになります。"
    },
    {
      "indent": 0,
      "text": "4.3 Return All Interface Names and Indexes",
      "section_title": true,
      "ja": "4.3戻りすべてのインタフェース名とインデックス"
    },
    {
      "indent": 3,
      "text": "The if_nameindex structure holds the information about a single interface and is defined as a result of including the <net/if.h> header.",
      "ja": "if_nameindex構造体は、単一のインタフェースに関する情報を保持し、<ネット/ if.h>ヘッダを含めた結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "struct if_nameindex {\n  unsigned int   if_index;  /* 1, 2, ... */\n  char          *if_name;   /* null terminated name: \"le0\", ... */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The final function returns an array of if_nameindex structures, one structure per interface.",
      "ja": "最終的な関数は、if_nameindex構造、インタフェースごとに構造体の配列を返します。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "ja": "書式#include <ネット/ if.h>"
    },
    {
      "indent": 6,
      "text": "struct if_nameindex *if_nameindex(void);",
      "ja": "構造体if_nameindex * if_nameindex（無効）。"
    },
    {
      "indent": 3,
      "text": "The end of the array of structures is indicated by a structure with an if_index of 0 and an if_name of NULL. The function returns a NULL pointer upon an error, and would set errno to the appropriate value.",
      "ja": "構造体の配列の端部が0のif_index及びNULLののif_nameた構造で示されています。関数は、エラー時にNULLポインタを返し、適切な値をerrnoに設定します。"
    },
    {
      "indent": 3,
      "text": "The memory used for this array of structures along with the interface names pointed to by the if_name members is obtained dynamically. This memory is freed by the next function.",
      "ja": "if_nameメンバによって指さインタフェース名と共に構造のこのアレイに使用されるメモリが動的に取得されます。このメモリは次の関数によって解放されます。"
    },
    {
      "indent": 0,
      "text": "4.4 Free Memory",
      "section_title": true,
      "ja": "4.4空きメモリ"
    },
    {
      "indent": 3,
      "text": "The following function frees the dynamic memory that was allocated by if_nameindex().",
      "ja": "以下の関数は）if_nameindex（によって割り当てられた動的メモリを解放します。"
    },
    {
      "indent": 6,
      "text": "#include <net/if.h>",
      "ja": "書式#include <ネット/ if.h>"
    },
    {
      "indent": 6,
      "text": "void if_freenameindex(struct if_nameindex *ptr);",
      "ja": "空if_freenameindex（構造体if_nameindexの*のPTR）;"
    },
    {
      "indent": 3,
      "text": "The ptr argument shall be a pointer that was returned by if_nameindex(). After if_freenameindex() has been called, the application shall not use the array of which ptr is the address.",
      "ja": "PTR引数はif_nameindex（）で返されたポインタでなければなりません。後if_freenameindex（）は、アプリケーションがptrがアドレスであるのアレイを使用してはならない、と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "5. Socket Options",
      "section_title": true,
      "ja": "5.ソケットオプション"
    },
    {
      "indent": 3,
      "text": "A number of new socket options are defined for IPv6. All of these new options are at the IPPROTO_IPV6 level. That is, the \"level\" parameter in the getsockopt() and setsockopt() calls is IPPROTO_IPV6 when using these options. The constant name prefix IPV6_ is used in all of the new socket options. This serves to clearly identify these options as applying to IPv6.",
      "ja": "新しいソケットオプションの数は、IPv6のために定義されています。これらの新しいオプションのすべてがIPPROTO_IPV6レベルです。それは、「レベル」のgetsockoptにおけるパラメータ（）とのsetsockopt（）で、これらのオプションを使用するときにIPPROTO_IPV6で呼び出します。定数名の接頭辞IPV6_は新しいソケットオプションのすべてで使用されています。これは明らかに、IPv6への適用として、これらのオプションを識別するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The declaration for IPPROTO_IPV6, the new IPv6 socket options, and related constants defined in this section are obtained by including the header <netinet/in.h>.",
      "ja": "IPPROTO_IPV6の宣言、新しいIPv6ソケットオプション、このセクションで定義された関連する定数は、ヘッダ<netinetの/ in.h>を含むことによって得られます。"
    },
    {
      "indent": 0,
      "text": "5.1 Unicast Hop Limit",
      "section_title": true,
      "ja": "5.1ユニキャストホップ制限"
    },
    {
      "indent": 3,
      "text": "A new setsockopt() option controls the hop limit used in outgoing unicast IPv6 packets. The name of this option is IPV6_UNICAST_HOPS, and it is used at the IPPROTO_IPV6 layer. The following example illustrates how it is used:",
      "ja": "新規のsetsockopt（）オプションは、発信ユニキャストIPv6パケットで使用されるホップリミットを制御します。このオプションの名前はIPV6_UNICAST_HOPSで、IPPROTO_IPV6層で使用されています。次の例では、それが使用されている方法を示しています。"
    },
    {
      "indent": 3,
      "text": "int hoplimit = 10;",
      "ja": "hoplimit INT = 10;"
    },
    {
      "indent": 3,
      "text": "if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS, (char *) &hoplimit, sizeof(hoplimit)) == -1) perror(\"setsockopt IPV6_UNICAST_HOPS\");",
      "ja": "IF（のsetsockopt（s、IPPROTO_IPV6、IPV6_UNICAST_HOPS、（CHAR *）＆hoplimit、はsizeof（hoplimit））== -1）にperror（ \"のsetsockopt IPV6_UNICAST_HOPS\"）。"
    },
    {
      "indent": 3,
      "text": "When the IPV6_UNICAST_HOPS option is set with setsockopt(), the option value given is used as the hop limit for all subsequent unicast packets sent via that socket. If the option is not set, the system selects a default value. The integer hop limit value (called x) is interpreted as follows:",
      "ja": "IPV6_UNICAST_HOPSのオプションのsetsockopt（）で設定されている場合、所定のオプションの値は、そのソケットを介して送信されるすべての後続のユニキャストパケットのホップ制限として使用されます。オプションが設定されていない場合、システムはデフォルト値を選択します。次のように（Xと呼ばれる）整数ホップ限界値が解釈されます。"
    },
    {
      "indent": 6,
      "text": "x < -1: return an error of EINVAL x == -1: use kernel default 0 <= x <= 255: use x x >= 256: return an error of EINVAL",
      "ja": "X <-1：使用のカーネルのデフォルト0 <= xの<= 255：使用X X> = 256：EINVALのx == -1のエラーを返すEINVALのエラーを返します"
    },
    {
      "indent": 3,
      "text": "The IPV6_UNICAST_HOPS option may be used with getsockopt() to determine the hop limit value that the system will use for subsequent unicast packets sent via that socket. For example:",
      "ja": "IPV6_UNICAST_HOPSオプションは、システムがそのソケットを介して送信される後続のユニキャストパケットに使用するホップ制限値を決定するためのgetsockopt（）と共に使用することができます。例えば："
    },
    {
      "indent": 6,
      "text": "int  hoplimit;\nsocklen_t  len = sizeof(hoplimit);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if (getsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n               (char *) &hoplimit, &len) == -1)\n    perror(\"getsockopt IPV6_UNICAST_HOPS\");\nelse\n    printf(\"Using %d for hop limit.\\n\", hoplimit);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.2 Sending and Receiving Multicast Packets",
      "section_title": true,
      "ja": "5.2マルチキャストパケットを送受信します"
    },
    {
      "indent": 3,
      "text": "IPv6 applications may send multicast packets by simply specifying an IPv6 multicast address as the destination address, for example in the destination address argument of the sendto() function.",
      "ja": "IPv6アプリケーションは、単にのsendto（）関数の宛先アドレス引数に、例えば、宛先アドレスとしてIPv6マルチキャストアドレスを指定してマルチキャストパケットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Three socket options at the IPPROTO_IPV6 layer control some of the parameters for sending multicast packets. Setting these options is not required: applications may send multicast packets without using these options. The setsockopt() options for controlling the sending of multicast packets are summarized below. These three options can also be used with getsockopt().",
      "ja": "IPPROTO_IPV6層で3つのソケットオプションは、マルチキャストパケットを送信するためのいくつかのパラメータを制御します。これらのオプションを設定する必要はありません。アプリケーションは、これらのオプションを使用せずにマルチキャストパケットを送信することができます。マルチキャストパケットの送信を制御するためにsetsockopt（）のオプションは以下のとおりです。これらの3つのオプションはまたのgetsockoptで使用することができます（）。"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_IF",
      "ja": "IPV6_MULTICAST_IF"
    },
    {
      "indent": 9,
      "text": "Set the interface to use for outgoing multicast packets. The argument is the index of the interface to use. If the interface index is specified as zero, the system selects the interface (for example, by looking up the address in a routing table and using the resulting interface).",
      "ja": "送出マルチキャストパケットに使用するインターフェイスを設定します。引数は、使用するインタフェースのインデックスです。インターフェースインデックスがゼロに指定されている場合、システムは、（例えば、ルーティングテーブルにアドレスを検索し、得られたインターフェイスを使用して）インタフェースを選択します。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "ja": "引数のタイプ：unsigned int型"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_HOPS",
      "ja": "IPV6_MULTICAST_HOPS"
    },
    {
      "indent": 9,
      "text": "Set the hop limit to use for outgoing multicast packets. (Note a separate option - IPV6_UNICAST_HOPS - is provided to set the hop limit to use for outgoing unicast packets.)",
      "ja": "送信マルチキャストパケットに使用するホップリミットを設定します。 （ -  IPV6_UNICAST_HOPS  - 発信ユニキャストパケットに使用するホップ制限を設定するために提供される別のオプションは、注意してください。）"
    },
    {
      "indent": 9,
      "text": "The interpretation of the argument is the same as for the IPV6_UNICAST_HOPS option:",
      "ja": "引数の解釈はIPV6_UNICAST_HOPSオプションと同じです。"
    },
    {
      "indent": 12,
      "text": "x < -1: return an error of EINVAL x == -1: use kernel default 0 <= x <= 255: use x x >= 256: return an error of EINVAL",
      "ja": "X <-1：使用のカーネルのデフォルト0 <= xの<= 255：使用X X> = 256：EINVALのx == -1のエラーを返すEINVALのエラーを返します"
    },
    {
      "indent": 12,
      "text": "If IPV6_MULTICAST_HOPS is not set, the default is 1 (same as IPv4 today)",
      "ja": "IPV6_MULTICAST_HOPSが設定されていない場合、デフォルトは1（今日はIPv4と同じ）であります"
    },
    {
      "indent": 9,
      "text": "Argument type: int",
      "ja": "引数の型：int"
    },
    {
      "indent": 6,
      "text": "IPV6_MULTICAST_LOOP",
      "ja": "IPV6_MULTICAST_LOOP"
    },
    {
      "indent": 9,
      "text": "If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is looped back by the IP layer for local delivery if this option is set to 1. If this option is set to 0 a copy is not looped back. Other option values return an error of EINVAL.",
      "ja": "マルチキャストデータグラムが送信ホスト自体が（発信インターフェイス上で）属するグループに送信された場合、このオプションがある場合は、このオプションが1に設定されている場合、データグラムのコピーがローカル配信のためにIP層によってループバックされ0に設定コピーがループバックされていません。その他のオプション値はEINVALのエラーを返します。"
    },
    {
      "indent": 9,
      "text": "If IPV6_MULTICAST_LOOP is not set, the default is 1 (loopback; same as IPv4 today).",
      "ja": "IPV6_MULTICAST_LOOPが設定されていない場合、デフォルトは1（;はIPv4と同じ今日ループバック）です。"
    },
    {
      "indent": 9,
      "text": "Argument type: unsigned int",
      "ja": "引数のタイプ：unsigned int型"
    },
    {
      "indent": 3,
      "text": "The reception of multicast packets is controlled by the two setsockopt() options summarized below. An error of EOPNOTSUPP is returned if these two options are used with getsockopt().",
      "ja": "マルチキャストパケットの受信を以下にまとめる2つのsetsockopt（）オプションによって制御されます。これら二つのオプションがgetsockoptのに使用されている場合EOPNOTSUPPのエラーが返されます（）。"
    },
    {
      "indent": 6,
      "text": "IPV6_JOIN_GROUP",
      "ja": "IPV6_JOIN_GROUP"
    },
    {
      "indent": 9,
      "text": "Join a multicast group on a specified local interface. If the interface index is specified as 0, the kernel chooses the local interface. For example, some kernels look up the multicast group in the normal IPv6 routing table and use the resulting interface.",
      "ja": "指定されたローカルインタフェース上のマルチキャストグループに参加。インタフェースインデックスに0が指定されている場合は、カーネルは、ローカルインタフェースを選択します。例えば、いくつかのカーネルは通常のIPv6ルーティングテーブルにマルチキャストグループをルックアップし、得られたインターフェイスを使用しています。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "ja": "引数のタイプ：構造体ipv6_mreq"
    },
    {
      "indent": 6,
      "text": "IPV6_LEAVE_GROUP",
      "ja": "IPV6_LEAVE_GROUP"
    },
    {
      "indent": 9,
      "text": "Leave a multicast group on a specified interface. If the interface index is specified as 0, the system may choose a multicast group membership to drop by matching the multicast address only.",
      "ja": "指定されたインターフェイス上でマルチキャストグループを脱退。インターフェースインデックスが0として指定されている場合、システムは、マルチキャストアドレスを照合することによって削除するマルチキャストグループメンバーシップを選択することができます。"
    },
    {
      "indent": 9,
      "text": "Argument type: struct ipv6_mreq",
      "ja": "引数のタイプ：構造体ipv6_mreq"
    },
    {
      "indent": 3,
      "text": "The argument type of both of these options is the ipv6_mreq structure, defined as a result of including the <netinet/in.h> header;",
      "ja": "これらのオプションの両方の引数の型は、<netinetの/ in.h>ヘッダを含めた結果として定義ipv6_mreq構造、です。"
    },
    {
      "indent": 3,
      "text": "struct ipv6_mreq {\n    struct in6_addr ipv6mr_multiaddr; /* IPv6 multicast addr */\n    unsigned int    ipv6mr_interface; /* interface index */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that to receive multicast datagrams a process must join the multicast group to which datagrams will be sent. UDP applications must also bind the UDP port to which datagrams will be sent. Some processes also bind the multicast group address to the socket, in addition to the port, to prevent other datagrams destined to that same port from being delivered to the socket.",
      "ja": "マルチキャストグループに参加しなければならないプロセスは、データグラムが送信されるマルチキャストデータグラムを受信することに注意してください。 UDPアプリケーションは、データグラムが送信されるとUDPポートをバインドする必要があります。いくつかのプロセスはまた、ソケットに配信され、同じポート宛他のデータグラムを防止するために、ポートに加えて、ソケットにマルチキャストグループアドレスをバインドします。"
    },
    {
      "indent": 0,
      "text": "5.3 IPV6_V6ONLY option for AF_INET6 Sockets",
      "section_title": true,
      "ja": "AF_INET6ソケット用5.3 IPV6_V6ONLYオプション"
    },
    {
      "indent": 3,
      "text": "This socket option restricts AF_INET6 sockets to IPv6 communications only. As stated in section <3.7 Compatibility with IPv4 Nodes>, AF_INET6 sockets may be used for both IPv4 and IPv6 communications. Some applications may want to restrict their use of an AF_INET6 socket to IPv6 communications only. For these applications the IPV6_V6ONLY socket option is defined. When this option is turned on, the socket can be used to send and receive IPv6 packets only. This is an IPPROTO_IPV6 level option. This option takes an int value. This is a boolean option. By default this option is turned off.",
      "ja": "このソケットオプションは、IPv6のみの通信にAF_INET6ソケットを制限します。 <IPv4のノードと3.7の互換性>の項で述べたように、AF_INET6ソケットは、IPv4とIPv6の両方の通信のために使用することができます。一部のアプリケーションでは、IPv6のみの通信にAF_INET6ソケットの使用を制限したいことがあります。これらのアプリケーションではIPV6_V6ONLYソケットオプションが定義されています。このオプションをオンにすると、ソケットはIPv6パケットを送受信するために使用することができます。これはIPPROTO_IPV6レベルのオプションです。このオプションでは、int型の値をとります。これはブール値のオプションです。デフォルトでは、このオプションがオフになっています。"
    },
    {
      "indent": 3,
      "text": "Here is an example of setting this option:",
      "ja": "ここでは、このオプションを設定する例を示します。"
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "= 1の整数;"
    },
    {
      "indent": 6,
      "text": "if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,\n               (char *)&on, sizeof(on)) == -1)\n    perror(\"setsockopt IPV6_V6ONLY\");\nelse\n    printf(\"IPV6_V6ONLY set\\n\");",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note - This option has no effect on the use of IPv4 Mapped addresses which enter a node as a valid IPv6 addresses for IPv6 communications as defined by Stateless IP/ICMP Translation Algorithm (SIIT) [5].",
      "ja": "注 - このオプションは、ステートレスIP / ICMP翻訳アルゴリズム（SIIT）によって定義されるような有効なIPv6は、IPv6通信のためのアドレスとしてノードを入力アドレスをマッピングされたIPv4の使用に影響を及ぼさない[5]。"
    },
    {
      "indent": 3,
      "text": "An example use of this option is to allow two versions of the same server process to run on the same port, one providing service over IPv6, the other providing the same service over IPv4.",
      "ja": "このオプションの使用例は、同じサーバープロセスの2つのバージョンが同じポート上で実行できるようにすることです一つは、他のは、IPv4の上に同じサービスを提供し、IPv6の上でサービスを提供します。"
    },
    {
      "indent": 0,
      "text": "6. Library Functions",
      "section_title": true,
      "ja": "6.ライブラリ関数"
    },
    {
      "indent": 3,
      "text": "New library functions are needed to perform a variety of operations with IPv6 addresses. Functions are needed to lookup IPv6 addresses in the Domain Name System (DNS). Both forward lookup (nodename-to-address translation) and reverse lookup (address-to-nodename translation) need to be supported. Functions are also needed to convert IPv6 addresses between their binary and textual form.",
      "ja": "新しいライブラリ関数は、IPv6アドレスでさまざまな操作を実行するために必要とされています。関数は、ドメインネームシステム（DNS）でIPv6アドレスをルックアップするために必要とされています。どちら正引き（ノード名からアドレスへの変換）とルックアップ（アドレスからノード名翻訳）逆サポートする必要があります。機能はまた、そのバイナリとテキスト形式の間でIPv6アドレスを変換するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "We note that the two existing functions, gethostbyname() and gethostbyaddr(), are left as-is. New functions are defined to handle both IPv4 and IPv6 addresses.",
      "ja": "私たちは、あるように、2つの既存の機能と、gethostbyname（）とはgethostbyaddr（）は、残っていることに注意してください。新機能は、IPv4とIPv6の両方のアドレスを扱うように定義されています。"
    },
    {
      "indent": 3,
      "text": "The commonly used function gethostbyname() is inadequate for many applications, first because it provides no way for the caller to specify anything about the types of addresses desired (IPv4 only, IPv6 only, IPv4-mapped IPv6 are OK, etc.), and second because many implementations of this function are not thread safe. RFC 2133",
      "ja": "一般的に使用される関数のgethostbyname（）は、所望のアドレスの種類について何も指定し、発信者のための方法を提供していない最初のため、多くの用途には不十分である（IPv4のみのIPv6のみ、IPv4マップのIPv6等、OKである）、及び二本機能の多くの実装は、スレッドセーフではありませんので。 RFC 2133"
    },
    {
      "indent": 3,
      "text": "defined a function named gethostbyname2() but this function was also inadequate, first because its use required setting a global option (RES_USE_INET6) when IPv6 addresses were required, and second because a flag argument is needed to provide the caller with additional control over the types of addresses required. The gethostbyname2() function was deprecated in RFC 2553 and is no longer part of the basic API.",
      "ja": "この関数は（gethostbyname2の名前）が、この機能は、その使用は、IPv6アドレスが必要とされたグローバルオプション（RES_USE_INET6）の設定に必要なので、最初、また不十分であった、と規定される第2のフラグ引数は種類以上の追加の制御で発呼者に提供するために必要とされるので、アドレスに要求。 gethostbyname2（）関数は、RFC 2553で非推奨と基本的なAPIの一部ではなくなりました。"
    },
    {
      "indent": 0,
      "text": "6.1 Protocol-Independent Nodename and Service Name Translation",
      "section_title": true,
      "ja": "6.1プロトコル独立ノード名およびサービス名翻訳"
    },
    {
      "indent": 3,
      "text": "Nodename-to-address translation is done in a protocol-independent fashion using the getaddrinfo() function.",
      "ja": "ノード名からアドレスへの変換は、のgetaddrinfo（）関数を使用して、プロトコルに依存しない方法で行われます。"
    },
    {
      "indent": 0,
      "text": "#include <sys/socket.h> #include <netdb.h>",
      "ja": "書式#include <sysの/ socket.h>にする#include <netdb.h>"
    },
    {
      "indent": 0,
      "text": "int getaddrinfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res);",
      "ja": "int型のgetaddrinfo（のconstのchar *ノード名、CONSTするchar * servnameの、constの構造体のaddrinfo *ヒント、構造体のaddrinfo ** RES）。"
    },
    {
      "indent": 0,
      "text": "void freeaddrinfo(struct addrinfo *ai);",
      "ja": "空freeaddrinfo（構造体のaddrinfo * AI）。"
    },
    {
      "indent": 0,
      "text": "struct addrinfo {\n  int     ai_flags;     /* AI_PASSIVE, AI_CANONNAME,\n                           AI_NUMERICHOST, .. */\n  int     ai_family;    /* AF_xxx */\n  int     ai_socktype;  /* SOCK_xxx */\n  int     ai_protocol;  /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n  socklen_t  ai_addrlen;   /* length of ai_addr */\n  char   *ai_canonname; /* canonical name for nodename */\n  struct sockaddr  *ai_addr; /* binary address */\n  struct addrinfo  *ai_next; /* next structure in linked list */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() function translates the name of a service location (for example, a host name) and/or a service name and returns a set of socket addresses and associated information to be used in creating a socket with which to address the specified service.",
      "ja": "getaddrinfo（）関数は、サービス・ロケーションの名前（例えば、ホスト名）、および/またはサービス名を変換し、指定されたサービスに対処するとともに、ソケットを作成する際に使用するソケット・アドレスのセットと関連付けられた情報を返します。"
    },
    {
      "indent": 3,
      "text": "The nodename and servname arguments are either null pointers or pointers to null-terminated strings. One or both of these two arguments must be a non-null pointer.",
      "ja": "ノード名とservnameの引数はnullで終わる文字列へのヌルポインタまたはポインタのいずれかです。 1つまたは複数のこれらの二つの引数の両方が非NULLポインタでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format of a valid name depends on the address family or families. If a specific family is not given and the name could be interpreted as valid within multiple supported families, the implementation will attempt to resolve the name in all supported families and, in absence of errors, one or more results shall be returned.",
      "ja": "有効な名前の形式は、アドレスファミリまたはファミリに依存します。特定の家族が与えられていないと名前が複数のサポート家族内有効と解釈することができれば、実装はエラーがない場合には、一つ以上の結果が返されなければならない、サポートされているすべての家庭で名前を解決しようとします。"
    },
    {
      "indent": 3,
      "text": "If the nodename argument is not null, it can be a descriptive name or can be an address string. If the specified address family is AF_INET, AF_INET6, or AF_UNSPEC, valid descriptive names include host names. If the specified address family is AF_INET or AF_UNSPEC, address strings using Internet standard dot notation as specified in inet_addr() are valid. If the specified address family is AF_INET6 or AF_UNSPEC, standard IPv6 text forms described in inet_pton() are valid.",
      "ja": "ノード名引数がnullでない場合は、わかりやすい名前にすることができますまたはアドレスの文字列を指定できます。指定されたアドレスファミリはAF_INET、AF_INET6、またはAF_UNSPECであるならば、有効なわかりやすい名前は、ホスト名が含まれています。指定されたアドレスファミリはAF_INETかAF_UNSPECであるならば、アドレス文字列のinet_addrで指定されているインターネット標準ドット表記を使用して（）有効です。指定されたアドレスファミリがAF_INET6かAF_UNSPECであるならば、はinet_pton（）で説明した標準のIPv6テキスト形式が有効です。"
    },
    {
      "indent": 3,
      "text": "If nodename is not null, the requested service location is named by nodename; otherwise, the requested service location is local to the caller.",
      "ja": "ノード名がnullでない場合、要求されたサービスの場所は、ノード名で命名されました。そうでない場合は、要求されたサービスの場所は、呼び出し元にローカルです。"
    },
    {
      "indent": 3,
      "text": "If servname is null, the call shall return network-level addresses for the specified nodename. If servname is not null, it is a null-terminated character string identifying the requested service. This can be either a descriptive name or a numeric representation suitable for use with the address family or families. If the specified address family is AF_INET, AF_INET6 or AF_UNSPEC, the service can be specified as a string specifying a decimal port number.",
      "ja": "servnameのがnullの場合、呼び出しは、指定されたノード名のネットワーク・レベルのアドレスを返します。 servnameのがnullでない場合は、要求されたサービスを識別するヌル終端文字列です。これは、わかりやすい名前や住所、家族やご家族での使用に適した数値表現のいずれかになります。指定されたアドレスファミリはAF_INET、AF_INET6かAF_UNSPECであるならば、サービスは、10進数のポート番号を指定する文字列として指定することができます。"
    },
    {
      "indent": 3,
      "text": "If the argument hints is not null, it refers to a structure containing input values that may direct the operation by providing options and by limiting the returned information to a specific socket type, address family and/or protocol. In this hints structure every member other than ai_flags, ai_family, ai_socktype and ai_protocol shall be set to zero or a null pointer. A value of AF_UNSPEC for ai_family means that the caller shall accept any address family. A value of zero for ai_socktype means that the caller shall accept any socket type. A value of zero for ai_protocol means that the caller shall accept any protocol. If hints is a null pointer, the behavior shall be as if it referred to a structure containing the value zero for the ai_flags, ai_socktype and ai_protocol fields, and AF_UNSPEC for the ai_family field.",
      "ja": "引数ヒントがnullでない場合、それはオプションを提供することによって、特定のソケットタイプ、アドレスファミリおよび/またはプロトコルに返される情報を制限することによって動作を指示することができる入力値を含む構造を指します。これはai_flags以外のすべてのメンバーの構造をヒントに、ai_familyが、ai_socktypeとai_protocolは、ゼロまたはヌルポインタに設定されます。 ai_familyがためAF_UNSPECの値は、呼び出し側がどのアドレスファミリを受け入れるものとすることを意味します。 ai_socktypeゼロの値は、呼び出し元が、任意のソケットタイプを受け入れなければならないことを意味します。 ai_protocolゼロの値は、呼び出し元が、任意のプロトコルを受け入れなければならないことを意味します。ヒントがヌルポインタである場合、それはai_familyがフィールドのai_flags、ai_socktypeとai_protocolフィールドに値ゼロを含む構造と呼ばれ、AF_UNSPECかのように、挙動がなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note:",
      "ja": "注意："
    },
    {
      "indent": 3,
      "text": "1. If the caller handles only TCP and not UDP, for example, then the ai_protocol member of the hints structure should be set to IPPROTO_TCP when getaddrinfo() is called.",
      "ja": "1.発信者がTCPだけではなくUDPを処理する場合、例えば、次にヒント構造のai_protocol部材のgetaddrinfo（）が呼び出されたときIPPROTO_TCPに設定されるべきです。"
    },
    {
      "indent": 3,
      "text": "2. If the caller handles only IPv4 and not IPv6, then the ai_family member of the hints structure should be set to AF_INET when getaddrinfo() is called.",
      "ja": "2.発信者がIPv4のみとしないIPv6を処理する場合はgetaddrinfo（）が呼び出されたとき、その後、ヒント構造体のai_familyがメンバーはAF_INETに設定されるべきです。"
    },
    {
      "indent": 3,
      "text": "The ai_flags field to which hints parameter points shall be set to zero or be the bitwise-inclusive OR of one or more of the values AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG.",
      "ja": "パラメータ点をヒントするai_flagsフィールドがゼロにセットまたはビット単位込みOR値AI_PASSIVE、AI_CANONNAME、AI_NUMERICHOST、AI_NUMERICSERV、AI_V4MAPPED、AI_ALL、及びAI_ADDRCONFIGの一つ以上のものとすることがなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the AI_PASSIVE flag is specified, the returned address information shall be suitable for use in binding a socket for accepting incoming connections for the specified service (i.e., a call to bind()). In this case, if the nodename argument is null, then the IP address portion of the socket address structure shall be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address. If the AI_PASSIVE flag is not specified, the returned address information shall be suitable for a call to connect() (for a connection-mode protocol) or for a call to connect(), sendto() or sendmsg() (for a connectionless protocol). In this case, if the nodename argument is null, then the IP address portion of the socket address structure shall be set to the loopback address. This flag is ignored if the nodename argument is not null.",
      "ja": "AI_PASSIVEフラグが指定されている場合、返されたアドレス情報が指定されたサービスの着信接続を受け入れるためのソケットの結合に使用するのに適したものでなければならない（即ち、コールが結合します（））。ノード名引数がヌルである場合、この場合には、その後、ソケットアドレス構造体のIPアドレス部分はIPv6アドレスのIPv4アドレスまたはIN6ADDR_ANY_INITためINADDR_ANYに設定されます。 AI_PASSIVEフラグが指定されていない場合、返されたアドレス情報（接続先の呼び出しに適していなければならない））（接続モードプロトコルの場合）または（接続する呼のため、（）（（のsendto）またはsendmsgのコネクションのためにプロトコル）。ノード名引数がnullの場合この場合は、その後、ソケットアドレス構造体のIPアドレス部分はループバックアドレスを設定しなければなりません。ノード名引数がnullでない場合、このフラグは無視されます。"
    },
    {
      "indent": 3,
      "text": "If the AI_CANONNAME flag is specified and the nodename argument is not null, the function shall attempt to determine the canonical name corresponding to nodename (for example, if nodename is an alias or shorthand notation for a complete name).",
      "ja": "AI_CANONNAMEフラグが指定され、ノード名引数がヌルでない場合、関数は、（ノード名は、完全な名前の別名または省略表記である場合、例えば、）ノード名に対応する正規名を決定しようとしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the AI_NUMERICHOST flag is specified, then a non-null nodename string supplied shall be a numeric host address string. Otherwise, an [EAI_NONAME] error is returned. This flag shall prevent any type of name resolution service (for example, the DNS) from being invoked.",
      "ja": "AI_NUMERICHOSTフラグが指定されている場合は、付属null以外のノード名の文字列が数値ホストアドレス文字列でなければなりません。そうでない場合は、[EAI_NONAME]エラーが返されます。このフラグは、起動されること（例えば、DNS）の名前解決サービスの任意のタイプのを防止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the AI_NUMERICSERV flag is specified, then a non-null servname string supplied shall be a numeric port string. Otherwise, an [EAI_NONAME] error shall be returned. This flag shall prevent any type of name resolution service (for example, NIS+) from being invoked.",
      "ja": "AI_NUMERICSERVフラグが指定されている場合は、付属の非NULLでないservname文字列は数値のポート文字列でなければなりません。そうでない場合は、[EAI_NONAME]エラーが返されなければなりません。このフラグは、起動されることから名前解決サービス（例えば、NIS +）の任意のタイプのを防止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the AI_V4MAPPED flag is specified along with an ai_family of AF_INET6, then getaddrinfo() shall return IPv4-mapped IPv6 addresses on finding no matching IPv6 addresses (ai_addrlen shall be 16).",
      "ja": "AI_V4MAPPEDフラグがAF_INET6のai_familyが一緒に指定された場合、のgetaddrinfo（）は、IPv4射影IPv6が一致するIPv6アドレスを（ai_addrlen 16でなければならない）発見ない上のアドレス返します。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, if no AAAA records are found then a query is made for A records and any found are returned as IPv4- mapped IPv6 addresses.",
      "ja": "DNSを使用するときに何AAAAレコードが見つかられない場合、例えば、クエリが記録のために作られた、任意のIPv4-がIPv6アドレスにマッピングとして返される見出されます。"
    },
    {
      "indent": 3,
      "text": "The AI_V4MAPPED flag shall be ignored unless ai_family equals AF_INET6.",
      "ja": "ai_familyがAF_INET6のに等しい場合を除きAI_V4MAPPEDフラグは無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the AI_ALL flag is used with the AI_V4MAPPED flag, then getaddrinfo() shall return all matching IPv6 and IPv4 addresses.",
      "ja": "AI_ALLフラグはAI_V4MAPPEDフラグと一緒に使用されている場合、のgetaddrinfo（）は、一致するすべてのIPv6とIPv4アドレスを返します。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, queries are made for both AAAA records and A records, and getaddrinfo() returns the combined results of both queries. Any IPv4 addresses found are returned as IPv4-mapped IPv6 addresses.",
      "ja": "例えば、DNSを使用する場合、クエリは、AAAAレコードとレコードの両方のために作られ、はgetaddrinfo（）の両方のクエリの組み合わされた結果を返します。見つかったIPv4アドレスはIPv4射影IPv6アドレスとして返されます。"
    },
    {
      "indent": 3,
      "text": "The AI_ALL flag without the AI_V4MAPPED flag is ignored.",
      "ja": "AI_V4MAPPEDフラグなしAI_ALLフラグは無視されます。"
    },
    {
      "indent": 6,
      "text": "Note:",
      "ja": "注意："
    },
    {
      "indent": 6,
      "text": "When ai_family is not specified (AF_UNSPEC), AI_V4MAPPED and AI_ALL flags will only be used if AF_INET6 is supported.",
      "ja": "ai_familyがが（AF_UNSPEC）指定されていない場合はAF_INET6がサポートされている場合、AI_V4MAPPEDとAI_ALLフラグにのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system. The loopback address is not considered for this case as valid as a configured address.",
      "ja": "AI_ADDRCONFIGフラグが指定されている場合、IPv4アドレスは、IPv4アドレスがローカルシステム上に設定されている場合にのみ戻されなければならない、とIPv6アドレスは、IPv6アドレスがローカルシステム上に設定されている場合にのみ戻されなければなりません。ループバックアドレスが設定されたアドレスとして有効なものとしてこのような場合のために考慮されていません。"
    },
    {
      "indent": 6,
      "text": "For example, when using the DNS, a query for AAAA records should occur only if the node has at least one IPv6 address configured (other than IPv6 loopback) and a query for A records should occur only if the node has at least one IPv4 address configured (other than the IPv4 loopback).",
      "ja": "DNSを使用する場合、例えば、AAAAレコードのクエリは、ノードが（IPv6ループバック以外の）構成された少なくとも1つのIPv6アドレスを持ち、レコードのクエリは、ノードは、少なくとも1つのIPv4アドレスを持っている場合にのみ発生した場合にのみ行われるべき（IPv4のループバック以外の）構成。"
    },
    {
      "indent": 3,
      "text": "The ai_socktype field to which argument hints points specifies the socket type for the service, as defined for socket(). If a specific socket type is not given (for example, a value of zero) and the service name could be interpreted as valid with multiple supported socket types, the implementation shall attempt to resolve the service name for all supported socket types and, in the absence of errors, all possible results shall be returned. A non-zero socket type value shall limit the returned information to values with the specified socket type.",
      "ja": "引数がポイントヒントれるai_socktypeフィールドはソケットについて定義したとおり、サービスのソケットタイプを指定（）。特定のソケットタイプは、（例えば、ゼロの値）とサービス名は、複数のサポートソケットタイプに有効であると解釈される可能性が与えられていない場合、実装はで、すべてのサポートされているソケットタイプのサービス名を解決しようとするものエラーがない場合は、すべての可能な結果が返されなければなりません。非ゼロのソケットタイプの値が指定されたソケットタイプの値に戻される情報を制限しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the ai_family field to which hints points has the value AF_UNSPEC, addresses shall be returned for use with any address family that can be used with the specified nodename and/or servname. Otherwise, addresses shall be returned for use only with the specified address family. If ai_family is not AF_UNSPEC and ai_protocol is not zero, then addresses are returned for use only with the specified address family and protocol; the value of ai_protocol shall be interpreted as in a call to the socket() function with the corresponding values of ai_family and ai_protocol.",
      "ja": "ポイントをヒントにai_familyがフィールドに値AF_UNSPECを持っている場合は、アドレスが指定されたノード名および/またはservnameので使用できるすべてのアドレスファミリで使用するために返却されなければなりません。そうでなければ、アドレスは必ず指定のアドレスファミリで使用するために返却されなければなりません。 ai_familyがAF_UNSPECでなく、ai_protocolがゼロでない場合、アドレスは必ず指定のアドレスファミリおよびプロトコルで使用するために返されます。 ai_protocolの値はai_familyがとai_protocolの対応する値を有するソケット（）関数への呼び出しであると解釈されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The freeaddrinfo() function frees one or more addrinfo structures returned by getaddrinfo(), along with any additional storage associated with those structures (for example, storage pointed to by the ai_canonname and ai_addr fields; an application must not reference this storage after the associated addrinfo structure has been freed). If the ai_next field of the structure is not null, the entire list of structures is freed. The freeaddrinfo() function must support the freeing of arbitrary sublists of an addrinfo list originally returned by getaddrinfo().",
      "ja": "freeaddrinfo（）関数はこれらの構造に関連する任意の追加のストレージと一緒に、）（のgetaddrinfoによって返さ一つ以上のaddrinfo構造体を解放し（例えば、ストレージはAI_CANONNAMEとai_addrフィールドによって指さ、アプリケーションが関連付けられた後に、このストレージを参照してはなりませんaddrinfo構造体）が解放されました。構造体のフィールドのai_nextがnullでない場合は、構造体の全体リストが解放されます。 freeaddrinfo（）関数は、もともとのgetaddrinfoによって返されたaddrinfoリスト（）の任意のサブリストの解放をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "Functions getaddrinfo() and freeaddrinfo() must be thread-safe.",
      "ja": "機能はのgetaddrinfo（）とfreeaddrinfo（）はスレッドセーフでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A zero return value for getaddrinfo() indicates successful completion; a non-zero return value indicates failure. The possible values for the failures are listed below under Error Return Values.",
      "ja": "getaddrinfo（）のためにゼロの戻り値は、正常に完了したことを示しています。ゼロ以外の戻り値は失敗を示します。失敗の可能な値は、エラーの戻り値の下に下に記載されています。"
    },
    {
      "indent": 3,
      "text": "Upon successful return of getaddrinfo(), the location to which res points shall refer to a linked list of addrinfo structures, each of which shall specify a socket address and information for use in creating a socket with which to use that socket address. The list shall include at least one addrinfo structure. The ai_next field of each structure contains a pointer to the next structure on the list, or a null pointer if it is the last structure on the list. Each structure on the list shall include values for use with a call to the socket() function, and a socket address for use with the connect() function or, if the AI_PASSIVE flag was specified, for use with the bind() function. The fields ai_family, ai_socktype, and ai_protocol shall be usable as the arguments to the socket() function to create a socket suitable for use with the returned address. The fields ai_addr and ai_addrlen are usable as the arguments to the connect() or bind() functions with such a socket, according to the AI_PASSIVE flag.",
      "ja": "getaddrinfo（）の正常終了時には、位置は、解像度の点は、ソケット・アドレスを使用すると、ソケットを作成する際に使用するためのソケットアドレスと情報を指定しなければならないそれらの各々のaddrinfo構造のリンクされたリストを指すものとしています。リストには、少なくとも1つのaddrinfo構造体を含むものとします。それはリストの最後の構造体である場合には、各構造体のフィールドのai_nextは、リスト上の次の構造体、またはNULLポインタへのポインタが含まれています。 AI_PASSIVEフラグがバインド（）関数で使用するために、指定された場合は、リスト上の各構造は、CONNECT（）関数でソケット（）関数の呼び出し、および使用のためのソケット・アドレスを使用するための値を含むか、しなければなりません。 ai_familyがフィールド、ai_socktype、ソケット（）関数の引数は、返されたアドレスと共に使用するのに適したソケットを作成するようai_protocolが使用可能でなければなりません。フィールドはai_addrとai_addrlenはAI_PASSIVEフラグに応じて、このようなソケットに接続する引数（）またはバインド（）関数として使用可能です。"
    },
    {
      "indent": 3,
      "text": "If nodename is not null, and if requested by the AI_CANONNAME flag, the ai_canonname field of the first returned addrinfo structure shall point to a null-terminated string containing the canonical name corresponding to the input nodename; if the canonical name is not available, then ai_canonname shall refer to the nodename argument or a string with the same contents. The contents of the ai_flags field of the returned structures are undefined.",
      "ja": "ノード名がnullでない場合、およびAI_CANONNAMEフラグによって要求された場合、第一のAI_CANONNAMEフィールドはADDRINFO構造は、入力ノード名に対応する正規名を含むヌル終了文字列を指すものと戻されます。正規名が使用できない場合は、AI_CANONNAMEは、ノード名引数または同じ内容を持つ文字列を指すものとします。返された構造体のai_flagsフィールドの内容は未定義です。"
    },
    {
      "indent": 3,
      "text": "All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument (for example, sin6_flowinfo) shall be set to zero.",
      "ja": "明示的な引数（例えば、sin6_flowinfo）を介して充填されていないのgetaddrinfo（によって返されたソケットアドレス構造体）のすべてのフィールドがゼロに設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: This makes it easier to compare socket address structures.",
      "ja": "注意：これは、それが簡単にソケットアドレス構造を比較することができます。"
    },
    {
      "indent": 3,
      "text": "Error Return Values:",
      "ja": "エラー戻り値："
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() function shall fail and return the corresponding value if:",
      "ja": "getaddrinfo（）関数があれば対応する値を失敗し、返還しなければなりません："
    },
    {
      "indent": 3,
      "text": "[EAI_AGAIN] The name could not be resolved at this time. Future attempts may succeed.",
      "ja": "[EAI_AGAIN]名前は、この時に解決することができませんでした。将来の試みが成功する可能性があります。"
    },
    {
      "indent": 3,
      "text": "[EAI_BADFLAGS] The flags parameter had an invalid value.",
      "ja": "[EAI_BADFLAGS] flagsパラメータには、無効な値を持っていました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAIL] A non-recoverable error occurred when attempting to resolve the name.",
      "ja": "名前を解決しようとすると、[EAI_FAIL]回復不能なエラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAMILY] The address family was not recognized.",
      "ja": "[EAI_FAMILY]アドレスファミリーが認識されませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_MEMORY] There was a memory allocation failure when trying to allocate storage for the return value.",
      "ja": "[EAI_MEMORY]戻り値のためのストレージを割り当てしようとしているメモリ割り当ての失敗がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_NONAME] The name does not resolve for the supplied parameters. Neither nodename nor servname were supplied. At least one of these must be supplied.",
      "ja": "[EAI_NONAME]名前が指定されたパラメータのために解決しません。どちらのノード名もservnameのは、供給されました。これらの少なくとも一方が供給されなければなりません。"
    },
    {
      "indent": 3,
      "text": "[EAI_SERVICE] The service passed was not recognized for the specified socket type.",
      "ja": "[EAI_SERVICE]渡されたサービスは、指定されたソケットタイプのために認識されませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_SOCKTYPE] The intended socket type was not recognized.",
      "ja": "【EAI_SOCKTYPE]意図ソケットタイプが認識されませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_SYSTEM] A system error occurred; the error code can be found in errno.",
      "ja": "【EAI_SYSTEM】システムエラーが発生しました。エラーコードはerrnoに見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The gai_strerror() function provides a descriptive text string corresponding to an EAI_xxx error value.",
      "ja": "gai_strerror（）関数はEAI_xxxエラー値に対応する記述テキスト文字列を提供します。"
    },
    {
      "indent": 6,
      "text": "#include <netdb.h>",
      "ja": "書式#include <netdb.h>"
    },
    {
      "indent": 6,
      "text": "const char *gai_strerror(int ecode);",
      "ja": "constのchar * gai_strerror（int型ECODE）。"
    },
    {
      "indent": 3,
      "text": "The argument is one of the EAI_xxx values defined for the getaddrinfo() and getnameinfo() functions. The return value points to a string describing the error. If the argument is not one of the EAI_xxx values, the function still returns a pointer to a string whose contents indicate an unknown error.",
      "ja": "引数は（）関数はgetaddrinfo（）とgetnameinfoはのために定義されEAI_xxx値の一つです。エラーを説明する文字列への戻り値のポイント。引数がEAI_xxx値の一つではない場合、この関数は、まだその内容が不明なエラーを示す文字列へのポインタを返します。"
    },
    {
      "indent": 0,
      "text": "6.2 Socket Address Structure to Node Name and Service Name",
      "section_title": true,
      "ja": "ノード名およびサービス名に6.2のソケットアドレス構造体"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function is used to translate the contents of a socket address structure to a node name and/or service name.",
      "ja": "getnameinfo（）関数は、ノード名および/またはサービス名へのソケットアドレス構造体の内容を変換するために使用されます。"
    },
    {
      "indent": 3,
      "text": "#include <sys/socket.h> #include <netdb.h>",
      "ja": "書式#include <sysの/ socket.h>にする#include <netdb.h>"
    },
    {
      "indent": 3,
      "text": "int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *node, socklen_t nodelen, char *service, socklen_t servicelen, int flags);",
      "ja": "INTてgetnameinfo（CONSTいるsockaddrの* SAと、のsocklen_tサレン、CHAR *ノード、のsocklen_t nodelen、チャー*サービスのsocklen_t servicelenは、フラグINT）。"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall translate a socket address to a node name and service location, all of which are defined as in getaddrinfo().",
      "ja": "getnameinfo（）関数はgetaddrinfo（のように定義されているすべてが、ノード名とサービス位置にソケットアドレスを変換しなければなりません）。"
    },
    {
      "indent": 3,
      "text": "The sa argument points to a socket address structure to be translated.",
      "ja": "ソケットアドレス構造体へのsa引数ポイントは、翻訳されます。"
    },
    {
      "indent": 3,
      "text": "The salen argument holds the size of the socket address structure pointed to by sa.",
      "ja": "サレン引数は、ソケットアドレス構造体のサイズは、SAによって指さ保持しています。"
    },
    {
      "indent": 3,
      "text": "If the socket address structure contains an IPv4-mapped IPv6 address or an IPv4-compatible IPv6 address, the implementation shall extract the embedded IPv4 address and lookup the node name for that IPv4 address.",
      "ja": "ソケットアドレス構造体は、IPv4マップIPv6アドレスまたはIPv4互換IPv6アドレスが含まれている場合、実装は、埋め込まれたIPv4アドレスを抽出し、そのIPv4アドレスのノード名を検索しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: The IPv6 unspecified address (\"::\") and the IPv6 loopback address (\"::1\") are not IPv4-compatible addresses. If the address is the IPv6 unspecified address (\"::\"), a lookup is not performed, and the [EAI_NONAME] error is returned.",
      "ja": "注：IPv6の未指定アドレス（「::」）とIPv6ループバックアドレス（「:: 1」）は、IPv4互換アドレスではありません。アドレスがIPv6未指定アドレス（「::」）である場合、検索が行われず、[EAI_NONAME]エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the node argument is non-NULL and the nodelen argument is nonzero, then the node argument points to a buffer able to contain up to nodelen characters that receives the node name as a null-terminated string. If the node argument is NULL or the nodelen argument is zero, the node name shall not be returned. If the node's name cannot be located, the numeric form of the node's address is returned instead of its name.",
      "ja": "ノード引数が非NULLであるとnodelen引数がゼロで、NULLで終わる文字列としてノード名を受信nodelen文字まで格納できるバッファにそのノードの引数のポイント場合。ノードの引数がNULLであるかnodelen引数がゼロの場合、ノード名が返されてはなりません。ノードの名前が見つからない場合は、ノードのアドレスの数値形式は、名前の代わりに返されます。"
    },
    {
      "indent": 3,
      "text": "If the service argument is non-NULL and the servicelen argument is non-zero, then the service argument points to a buffer able to contain up to servicelen bytes that receives the service name as a null-terminated string. If the service argument is NULL or the servicelen argument is zero, the service name shall not be returned. If the service's name cannot be located, the numeric form of the service address (for example, its port number) shall be returned instead of its name.",
      "ja": "サービス引数が非NULLであるとservicelen引数は、サービスの引数はポイントnullで終わる文字列としてサービス名を受け取り、バイトをservicelenまで格納できるバッファに、ゼロでない場合。サービスの引数がNULLであるかservicelen引数がゼロの場合、サービス名は返されてはなりません。サービスの名前が見つからない場合は、サービスアドレスの数値形式は、（例えば、ポート番号）は、その名の代わりに返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The arguments node and service cannot both be NULL.",
      "ja": "引数ノードとサービスの両方がNULLにすることはできません。"
    },
    {
      "indent": 3,
      "text": "The flags argument is a flag that changes the default actions of the function. By default the fully-qualified domain name (FQDN) for the host shall be returned, but:",
      "ja": "flags引数は、関数のデフォルトアクションを変更するフラグです。デフォルトでは、ホストの完全修飾ドメイン名（FQDN）が返されますが、なければなりません。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NOFQDN is set, only the node name portion of the FQDN shall be returned for local hosts.",
      "ja": " - フラグビットNI_NOFQDNが設定されている場合、FQDNの唯一のノード名の部分は、ローカルホストのために戻さなければなりません。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NUMERICHOST is set, the numeric form of the host's address shall be returned instead of its name, under all circumstances.",
      "ja": " - フラグビットNI_NUMERICHOSTが設定されている場合は、ホストのアドレスの数値形式は、すべての状況下で、その名の代わりに返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NAMEREQD is set, an error shall be returned if the host's name cannot be located.",
      "ja": " - フラグビットNI_NAMEREQDが設定されている場合は、ホストの名前が見つからない場合は、エラーが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_NUMERICSERV is set, the numeric form of the service address shall be returned (for example, its port number) instead of its name, under all circumstances.",
      "ja": " - フラグビットNI_NUMERICSERVが設定されている場合、サービスアドレスの数値形式は、すべての状況下で、代わりにその名前（例えば、ポート番号）が返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "- If the flag bit NI_DGRAM is set, this indicates that the service is a datagram service (SOCK_DGRAM). The default behavior shall assume that the service is a stream service (SOCK_STREAM).",
      "ja": " - フラグビットNI_DGRAMが設定されている場合、これは、サービスがデータグラムサービス（SOCK_DGRAM）であることを示しています。デフォルトの動作では、サービスがストリームサービス（SOCK_STREAM）であることを前提としなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note:",
      "ja": "注意："
    },
    {
      "indent": 3,
      "text": "1. The NI_NUMERICxxx flags are required to support the \"-n\" flags that many commands provide.",
      "ja": "1.のNI_NUMERICxxxフラグは、多くのコマンドが提供する「-n」のフラグをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The NI_DGRAM flag is required for the few AF_INET and AF_INET6 port numbers (for example, [512,514]) that represent different services for UDP and TCP.",
      "ja": "2. NI_DGRAMフラグが少ないAF_INETとAF_INET6ポート番号に必要とされる（例えば、[512,514]）UDPおよびTCPのための様々なサービスを表します。"
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall be thread safe.",
      "ja": "getnameinfo（）関数はスレッドセーフでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A zero return value for getnameinfo() indicates successful completion; a non-zero return value indicates failure.",
      "ja": "getnameinfo（）のためにゼロの戻り値は、正常に完了したことを示しています。ゼロ以外の戻り値は失敗を示します。"
    },
    {
      "indent": 3,
      "text": "Upon successful completion, getnameinfo() shall return the node and service names, if requested, in the buffers provided. The returned names are always null-terminated strings.",
      "ja": "要求された場合は正常に完了すると、getnameinfoを（）が提供するバッファに、ノード名およびサービス名を返還しなければなりません。返された名前は、常にヌル終端文字列です。"
    },
    {
      "indent": 3,
      "text": "Error Return Values:",
      "ja": "エラー戻り値："
    },
    {
      "indent": 3,
      "text": "The getnameinfo() function shall fail and return the corresponding value if:",
      "ja": "getnameinfo（）関数があれば対応する値を失敗し、返還しなければなりません："
    },
    {
      "indent": 3,
      "text": "[EAI_AGAIN] The name could not be resolved at this time. Future attempts may succeed.",
      "ja": "[EAI_AGAIN]名前は、この時に解決することができませんでした。将来の試みが成功する可能性があります。"
    },
    {
      "indent": 3,
      "text": "[EAI_BADFLAGS] The flags had an invalid value.",
      "ja": "[EAI_BADFLAGS]フラグが無効な値を持っていました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAIL] A non-recoverable error occurred.",
      "ja": "【EAI_FAIL非回復可能なエラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "[EAI_FAMILY] The address family was not recognized or the address length was invalid for the specified family.",
      "ja": "[EAI_FAMILY]アドレスファミリーが認識またはアドレスの長さが指定された家族のために無効ですいませんでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_MEMORY] There was a memory allocation failure.",
      "ja": "[EAI_MEMORY]メモリ割り当ての失敗がありました。"
    },
    {
      "indent": 3,
      "text": "[EAI_NONAME] The name does not resolve for the supplied parameters. NI_NAMEREQD is set and the host's name cannot be located, or both nodename and servname were null.",
      "ja": "[EAI_NONAME]名前が指定されたパラメータのために解決しません。 NI_NAMEREQDが設定され、ホストの名前が見つからない、またはノード名とservnameの両方がnullでした。"
    },
    {
      "indent": 3,
      "text": "[EAI_OVERFLOW] An argument buffer overflowed.",
      "ja": "【EAI_OVERFLOW]引数バッファがオーバーフロー。"
    },
    {
      "indent": 3,
      "text": "[EAI_SYSTEM] A system error occurred. The error code can be found in errno.",
      "ja": "【EAI_SYSTEM】システムエラーが発生しました。エラーコードはerrnoに見つけることができます。"
    },
    {
      "indent": 0,
      "text": "6.3 Address Conversion Functions",
      "section_title": true,
      "ja": "6.3アドレス変換関数"
    },
    {
      "indent": 3,
      "text": "The two IPv4 functions inet_addr() and inet_ntoa() convert an IPv4 address between binary and text form. IPv6 applications need similar functions. The following two functions convert both IPv6 and IPv4 addresses:",
      "ja": "2つのIPv4機能のinet_addr（）とINET_NTOA（）バイナリとテキスト形式の間でIPv4アドレスを変換します。 IPv6アプリケーションは、同様の機能を必要とします。次の2つの関数は、IPv6とIPv4の両方のアドレスを変換します。"
    },
    {
      "indent": 3,
      "text": "#include <arpa/inet.h>",
      "ja": "書式#include <ARPA / inet.h>"
    },
    {
      "indent": 3,
      "text": "int inet_pton(int af, const char *src, void *dst);",
      "ja": "int型はinet_pton（int型AF、CONSTするchar * SRC、void *型DST）;"
    },
    {
      "indent": 3,
      "text": "const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);",
      "ja": "constのchar * inet_ntop（int型AF、CONSTのvoid *のSRC、するchar * dstの、のsocklen_tサイズ）。"
    },
    {
      "indent": 3,
      "text": "The inet_pton() function shall convert an address in its standard text presentation form into its numeric binary form. The af argument shall specify the family of the address. The AF_INET and AF_INET6 address families shall be supported. The src argument points to the string being passed in. The dst argument points to a buffer into which the function stores the numeric address; this shall be large enough to hold the numeric address (32 bits for AF_INET, 128 bits for AF_INET6). The inet_pton() function shall return 1 if the conversion succeeds, with the address pointed to by dst in network byte order. It shall return 0 if the input is not a valid IPv4 dotted-decimal string or a valid IPv6 address string, or -1 with errno set to EAFNOSUPPORT if the af argument is unknown.",
      "ja": "inet_pton（）関数は、その数字のバイナリ形式にその標準的なテキストプレゼンテーション形式でアドレスを変換するものとします。 AF引数はアドレスファミリを指定しなければなりません。 AF_INETとAF_INET6アドレスファミリがサポートされなければなりません。渡される文字列にSRC引数ポイント機能が数値アドレスを格納するバッファへのDST引数ポイント。これは、数値アドレス（AF_INET 32ビット、AF_INET6 128ビット）を保持するのに十分な大きさでなければなりません。変換が成功した場合、アドレスは、ネットワークバイト順でDSTによって指さではinet_pton（）関数は、1を返します。入力がない場合は0を返す有効なIPv4ドット付き十進文字列または有効なIPv6アドレス文字列、または-1 AF引数が不明な場合はerrnoを設定してEAFNOSUPPORTします。"
    },
    {
      "indent": 3,
      "text": "If the af argument of inet_pton() is AF_INET, the src string shall be in the standard IPv4 dotted-decimal form:",
      "ja": "inet_ptonのAF引数は（）AF_INETであるならば、SRC文字列は、標準IPv4のドット-進形式でなければなりません。"
    },
    {
      "indent": 6,
      "text": "ddd.ddd.ddd.ddd",
      "ja": "ddd.ddd.ddd.ddd"
    },
    {
      "indent": 3,
      "text": "where \"ddd\" is a one to three digit decimal number between 0 and 255. The inet_pton() function does not accept other formats (such as the octal numbers, hexadecimal numbers, and fewer than four numbers that inet_addr() accepts).",
      "ja": "「DDD」は（）は、のinet_addr 8進数、16進数、およびより少ない4つの数字として（受け入れる）1〜3個の桁の10進数はinet_pton 0と255の間（）関数は、他の形式を受け入れていないです。"
    },
    {
      "indent": 3,
      "text": "If the af argument of inet_pton() is AF_INET6, the src string shall be in one of the standard IPv6 text forms defined in Section 2.2 of the addressing architecture specification [2].",
      "ja": "inet_ptonのAF引数は（）AF_INET6である場合、SRC列アドレッシングアーキテクチャ仕様のセクション2.2で定義された標準のIPv6テキスト形式のいずれかでなければならない[2]。"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function shall convert a numeric address into a text string suitable for presentation. The af argument shall specify the family of the address. This can be AF_INET or AF_INET6. The src argument points to a buffer holding an IPv4 address if the af argument is AF_INET, or an IPv6 address if the af argument is AF_INET6; the address must be in network byte order. The dst argument points to a buffer where the function stores the resulting text string; it shall not be NULL. The size argument specifies the size of this buffer, which shall be large enough to hold the text string (INET_ADDRSTRLEN characters for IPv4, INET6_ADDRSTRLEN characters for IPv6).",
      "ja": "inet_ntop（）関数は、プレゼンテーションに適したテキスト文字列に数値アドレスを変換するものとします。 AF引数はアドレスファミリを指定しなければなりません。これは、AF_INETまたはAF_INET6ことができます。バッファへのsrc引数点AF引数がAF_INET6である場合、AF引数がAF_INET、またはIPv6アドレスである場合、IPv4アドレスを保持します。アドレスは、ネットワークバイト順でなければなりません。関数は結果のテキスト文字列を格納するバッファへのDST引数ポイント。それがNULLであってはなりません。サイズ引数は、（IPv6のIPv4のINET_ADDRSTRLEN文字、INET6_ADDRSTRLEN文字）テキスト文字列を保持するのに十分な大きさでなければならないこのバッファのサイズを指定します。"
    },
    {
      "indent": 3,
      "text": "In order to allow applications to easily declare buffers of the proper size to store IPv4 and IPv6 addresses in string form, the following two constants are defined in <netinet/in.h>:",
      "ja": "アプリケーションが容易に文字列形式でIPv4とIPv6のアドレスを格納するために適切なサイズのバッファを宣言することを可能にするために、以下の2つの定数は、<netinetの/ in.h>で定義されています。"
    },
    {
      "indent": 6,
      "text": "#define INET_ADDRSTRLEN 16 #define INET6_ADDRSTRLEN 46",
      "ja": "#define INET_ADDRSTRLEN 16の#define INET6_ADDRSTRLEN 46"
    },
    {
      "indent": 3,
      "text": "The inet_ntop() function shall return a pointer to the buffer containing the text string if the conversion succeeds, and NULL otherwise. Upon failure, errno is set to EAFNOSUPPORT if the af argument is invalid or ENOSPC if the size of the result buffer is inadequate.",
      "ja": "inet_ntop（）関数は、そうでない場合、変換が成功した場合、テキスト文字列を含むバッファへのポインタを返し、NULLなければなりません。故障時には、errnoは結果バッファのサイズが不十分な場合、AF引数が無効またはENOSPCある場合EAFNOSUPPORTに設定されています。"
    },
    {
      "indent": 0,
      "text": "6.4 Address Testing Macros",
      "section_title": true,
      "ja": "6.4アドレステストマクロ"
    },
    {
      "indent": 3,
      "text": "The following macros can be used to test for special IPv6 addresses.",
      "ja": "次のマクロは、特別なIPv6アドレスをテストするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "#include <netinet/in.h>",
      "ja": "書式#include <netinetの/ in.h>"
    },
    {
      "indent": 3,
      "text": "int  IN6_IS_ADDR_UNSPECIFIED (const struct in6_addr *);\nint  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr *);\nint  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);\nint  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_SITELOCAL   (const struct in6_addr *);\nint  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);\nint  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\nint  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);\nint  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first seven macros return true if the address is of the specified type, or false otherwise. The last five test the scope of a multicast address and return true if the address is a multicast address of the specified scope or false if the address is either not a multicast address or not of the specified scope.",
      "ja": "アドレスが指定された型であるか、そうでない場合はfalse場合は最初の7つのマクロはtrueを返します。最後の5つのテストのマルチキャストアドレスの範囲やアドレスが指定された範囲または偽のマルチキャストアドレスである場合にはアドレスが指定されたスコープのマルチキャストアドレスかどうかのどちらかでない場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "Note that IN6_IS_ADDR_LINKLOCAL and IN6_IS_ADDR_SITELOCAL return true only for the two types of local-use IPv6 unicast addresses (Link-Local and Site-Local) defined in [2], and that by this definition, the IN6_IS_ADDR_LINKLOCAL macro returns false for the IPv6 loopback address (::1). These two macros do not return true for IPv6 multicast addresses of either link-local scope or site-local scope.",
      "ja": "IN6_IS_ADDR_LINKLOCALとは、ローカル使用IPv6ユニキャストアドレス（リンクローカルおよびサイトローカル）[2]で定義され、そしてこの定義により、その2種類のIPv6ループバックアドレスの偽IN6_IS_ADDR_LINKLOCALマクロ戻るた​​めにtrueを返すIN6_IS_ADDR_SITELOCALことに注意してください（:: 1）。これら二つのマクロは、リンクローカルスコープまたはサイトローカルスコープのいずれかのIPv6マルチキャストアドレスにはtrueを返しません。"
    },
    {
      "indent": 0,
      "text": "7. Summary of New Definitions",
      "section_title": true,
      "ja": "新しい定義の概要7"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants, structure, and extern definitions discussed in this memo, sorted by header.",
      "ja": "以下のリストは、定数、構造、およびヘッダでソートこのメモで議論のextern定義をまとめたものです。"
    },
    {
      "indent": 0,
      "text": "<net/if.h> IF_NAMESIZE <net/if.h> struct if_nameindex{};",
      "ja": "<ネット/ if.h> IF_NAMESIZE <ネット/ if.h>構造体if_nameindex {}。"
    },
    {
      "indent": 0,
      "text": "<netdb.h> AI_ADDRCONFIG <netdb.h> AI_ALL <netdb.h> AI_CANONNAME <netdb.h> AI_NUMERICHOST <netdb.h> AI_NUMERICSERV <netdb.h> AI_PASSIVE <netdb.h> AI_V4MAPPED",
      "ja": "<netdb.h> AI_ADDRCONFIG <netdb.h> AI_ALL <netdb.h> AI_CANONNAME <netdb.h> AI_NUMERICHOST <netdb.h> AI_NUMERICSERV <netdb.h> AI_PASSIVE <netdb.h> AI_V4MAPPED"
    },
    {
      "indent": 0,
      "text": "<netdb.h> EAI_AGAIN <netdb.h> EAI_BADFLAGS <netdb.h> EAI_FAIL <netdb.h> EAI_FAMILY <netdb.h> EAI_MEMORY <netdb.h> EAI_NONAME <netdb.h> EAI_OVERFLOW <netdb.h> EAI_SERVICE <netdb.h> EAI_SOCKTYPE <netdb.h> EAI_SYSTEM <netdb.h> NI_DGRAM <netdb.h> NI_NAMEREQD <netdb.h> NI_NOFQDN <netdb.h> NI_NUMERICHOST <netdb.h> NI_NUMERICSERV <netdb.h> struct addrinfo{};",
      "ja": "<Netdb.h> EAI_AGAIN <netdb.h> EAI_BADFLAGS <netdb.h> EAI_FAIL <netdb.h> EAI_FAMILY <netdb.h> EAI_MEMORY <netdb.h> EAI_NONAME <netdb.h> EAI_OVERFLOW <netdb.h> EAI_SERVICE <netdb .H> EAI_SOCKTYPE <netdb.h> EAI_SYSTEM <netdb.h> NI_DGRAM <netdb.h> NI_NAMEREQD <netdb.h> NI_NOFQDN <netdb.h> NI_NUMERICHOST <netdb.h> NI_NUMERICSERV <netdb.h>構造体のaddrinfo {}。"
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  IN6ADDR_ANY_INIT\n<netinet/in.h>  IN6ADDR_LOOPBACK_INIT\n<netinet/in.h>  INET6_ADDRSTRLEN\n<netinet/in.h>  INET_ADDRSTRLEN\n<netinet/in.h>  IPPROTO_IPV6\n<netinet/in.h>  IPV6_JOIN_GROUP\n<netinet/in.h>  IPV6_LEAVE_GROUP\n<netinet/in.h>  IPV6_MULTICAST_HOPS\n<netinet/in.h>  IPV6_MULTICAST_IF\n<netinet/in.h>  IPV6_MULTICAST_LOOP\n<netinet/in.h>  IPV6_UNICAST_HOPS\n<netinet/in.h>  IPV6_V6ONLY\n<netinet/in.h>  SIN6_LEN\n<netinet/in.h>  extern const struct in6_addr in6addr_any;\n<netinet/in.h>  extern const struct in6_addr in6addr_loopback;\n<netinet/in.h>  struct in6_addr{};\n<netinet/in.h>  struct ipv6_mreq{};\n<netinet/in.h>  struct sockaddr_in6{};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<sys/socket.h> AF_INET6 <sys/socket.h> PF_INET6 <sys/socket.h> struct sockaddr_storage;",
      "ja": "<sys / socket.h>にAF_INET6は<sys / socket.h>にPF_INET6は<sys / socket.h>に構造体SOCKADDR_STORAGE。"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "ja": "以下のリストは、ヘッダによってソートこのメモで議論機能とマクロプロトタイプをまとめたものです。"
    },
    {
      "indent": 0,
      "text": "<arpa/inet.h>   int inet_pton(int, const char *, void *);\n<arpa/inet.h>   const char *inet_ntop(int, const void *,\n                               char *, socklen_t);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<net/if.h>      char *if_indextoname(unsigned int, char *);\n<net/if.h>      unsigned int if_nametoindex(const char *);\n<net/if.h>      void if_freenameindex(struct if_nameindex *);\n<net/if.h>      struct if_nameindex *if_nameindex(void);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<netdb.h>       int getaddrinfo(const char *, const char *,\n                                const struct addrinfo *,\n                                struct addrinfo **);\n<netdb.h>       int getnameinfo(const struct sockaddr *, socklen_t,\n                  char *, socklen_t, char *, socklen_t, int);\n<netdb.h>       void freeaddrinfo(struct addrinfo *);\n<netdb.h>       const char *gai_strerror(int);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>  int IN6_IS_ADDR_LINKLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_LOOPBACK(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_GLOBAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_ORGLOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_MULTICAST(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_SITELOCAL(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_UNSPECIFIED(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4COMPAT(const struct in6_addr *);\n<netinet/in.h>  int IN6_IS_ADDR_V4MAPPED(const struct in6_addr *);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "IPv6 provides a number of new security mechanisms, many of which need to be accessible to applications. Companion memos detailing the extensions to the socket interfaces to support IPv6 security are being written.",
      "ja": "IPv6は、アプリケーションにアクセスできるようにする必要があるそれらの多くは新しいセキュリティ・メカニズムの数を提供します。 IPv6のセキュリティをサポートするために、ソケットインタフェースへの拡張を詳述コンパニオンメモが書かれています。"
    },
    {
      "indent": 1,
      "text": "9. Changes from",
      "section_title": true,
      "ja": "9.変更から"
    },
    {
      "indent": 3,
      "text": "1. Add brief description of the history of this API and its relation to the Open Group/IEEE/ISO standards.",
      "ja": "1.このAPIの歴史とオープングループ/ IEEE / ISO規格との関係の簡単な説明を追加します。"
    },
    {
      "indent": 3,
      "text": "2. Alignments with [3].",
      "section_title": true,
      "ja": "[3] 2.アラインメント。"
    },
    {
      "indent": 3,
      "text": "3. Removed all references to getipnodebyname() and getipnodebyaddr(), which are deprecated in favor of getaddrinfo() and getnameinfo().",
      "ja": "3.はgetaddrinfo（）とgetnameinfoはの賛成で推奨されていません（）関数とgetipnodebyaddrを（）、getipnodebynameするすべての参照を削除しました（）。"
    },
    {
      "indent": 3,
      "text": "4. Added IPV6_V6ONLY IP level socket option to permit nodes to not process IPv4 packets as IPv4 Mapped addresses in implementations.",
      "ja": "4.追加IPV6_V6ONLY IPレベルのソケットオプションは、IPv4の実装でアドレスをマップされたとして、IPv4パケットを処理しないようにノードを許可します。"
    },
    {
      "indent": 3,
      "text": "5. Added SIIT to references and added new contributors.",
      "section_title": true,
      "ja": "5.参照にSIITを追加し、新しい貢献者を追加しました。"
    },
    {
      "indent": 3,
      "text": "6. In previous versions of this specification, the sin6_flowinfo field was associated with the IPv6 traffic class and flow label, but its usage was not completely specified. The complete definition of the sin6_flowinfo field, including its association with the traffic class or flow label, is now deferred to a future specification.",
      "ja": "本明細書の以前のバージョンでは6は、sin6_flowinfoフィールドは、IPv6のトラフィッククラス、フローラベルと関連していたが、その使用は完全に指定されませんでした。トラフィッククラスまたはフローラベルとの関連を含めsin6_flowinfoフィールドの完全な定義は、現在、将来の仕様に延期されます。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "This specification's evolution and completeness were significantly influenced by the efforts of Richard Stevens, who has passed on. Richard's wisdom and talent made the specification what it is today. The co-authors will long think of Richard with great respect.",
      "ja": "この仕様の進化と完全性を大幅に過ぎたリチャード・スティーブンスの努力、影響を受けました。リチャードの知恵と才能はそれが今日である何の仕様を作りました。共著者は長い偉大に関してリチャードを考えるでしょう。"
    },
    {
      "indent": 3,
      "text": "Thanks to the many people who made suggestions and provided feedback to this document, including:",
      "ja": "提案を作り、このドキュメントにフィードバックを提供し、多くの人々のおかげで、含みます："
    },
    {
      "indent": 3,
      "text": "Werner Almesberger, Ran Atkinson, Fred Baker, Dave Borman, Andrew Cherenson, Alex Conta, Alan Cox, Steve Deering, Richard Draves, Francis Dupont, Robert Elz, Brian Haberman, Jun-ichiro itojun Hagino, Marc Hasson, Tom Herbert, Bob Hinden, Wan-Yen Hsu, Christian Huitema, Koji Imada, Markus Jork, Ron Lee, Alan Lloyd, Charles Lynn, Dan McDonald, Dave Mitton, Finnbarr Murphy, Thomas Narten, Josh Osborne, Craig Partridge, Jean-Luc Richier, Bill Sommerfield, Erik Scoredos, Keith Sklower, JINMEI Tatuya, Dave Thaler, Matt Thomas, Harvey Thompson, Dean D. Throop, Karen Tracey, Glenn Trewitt, Paul Vixie, David Waitzman, Carl Williams, Kazu Yamamoto, Vlad Yasevich, Stig Venaas, and Brian Zill.",
      "ja": "ワーナー・アルムズバーガーは、アトキンソン、フレッド・ベイカー、デイブ・ボーマン、アンドリューCherenson、アレックスコンタ、Alan Cox氏、スティーブデアリング、リチャードDraves、フランシスデュポン、ロバート・エルツ、ブライアンハーバーマン、Jun-ichiro itojun Haginoは、マルク・Hasson、トム・ハーバート、ボブHindenと蘭、ワン・円・スー、クリスチャンのHuitema、今田耕司、マルクスJorkの、ロン・リー、アラン・ロイド、チャールズ・リン、ダン・マクドナルド、デイブ・ミトン、Finnbarrマーフィー、トーマスNarten氏、ジョシュ・オズボーン、クレイグ・パートリッジ、ジャン=リュック・リシエ、ビルSommerfield、エリックScoredos、キースSklower、神明達也、デーブターラー、マット・トーマス、ハーヴェイ・トンプソン、ディーンD. Throop、カレン・トレイシー、グレンTrewitt、ポール・ヴィクシー、デビッドWaitzman、カール・ウィリアムズ、カズ山本、ヴラドYasevich、スティグVenaas、およびブライアンZill 。"
    },
    {
      "indent": 3,
      "text": "The getaddrinfo() and getnameinfo() functions are taken from an earlier document by Keith Sklower. As noted in that document, William Durst, Steven Wise, Michael Karels, and Eric Allman provided many useful discussions on the subject of protocol-independent name-to-address translation, and reviewed early versions of Keith Sklower's original proposal. Eric Allman implemented the first prototype of getaddrinfo(). The observation that specifying the pair of name and service would suffice for connecting to a service independent of protocol details was made by Marshall Rose in a proposal to X/Open for a \"Uniform Network Interface\".",
      "ja": "getaddrinfo（）とgetnameinfo（）関数は、キースSklowerによって以前の文書から取られます。その文書で述べたように、ウィリアム・ダースト、スティーブン・ワイズ、マイケルKarels、そしてエリック・オールマンは、プロトコルに依存しない名前からアドレスへの変換をテーマに多くの有用な議論を提供し、そしてキースSklowerの当初の提案の初期バージョンを検討しました。エリック・オールマンは）（のgetaddrinfoの最初のプロトタイプを実装しました。名前とサービスのペアを指定すると、プロトコルの詳細の独立したサービスに接続するために十分であるという観察は、「統一ネットワーク・インタフェース」の提案には、X / Openにマーシャルローズによって作られました。"
    },
    {
      "indent": 3,
      "text": "Craig Metz, Jack McCann, Erik Nordmark, Tim Hartrick, and Mukesh Kacker made many contributions to this document. Ramesh Govindan made a number of contributions and co-authored an earlier version of this memo.",
      "ja": "クレイグ・メッツ、ジャック・マッキャン、エリックNordmarkと、ティムHartrick、およびムケシュKackerは、この文書に多くの貢献をしました。ラメシュ・ガバインダンは貢献の数を作り、このメモの以前のバージョンを共同執筆しました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[1]デアリング、S.とR. Hindenと \"インターネットプロトコル、バージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[2] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[2] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[3] IEEE Std. 1003.1-2001 Standard for Information Technology -- Portable Operating System Interface (POSIX). Open Group Technical Standard: Base Specifications, Issue 6, December 2001. ISO/IEC 9945:2002. http://www.opengroup.org/austin",
      "ja": "[3] IEEE STD。 1003.1-2001規格情報技術 - ポータブルオペレーティングシステムインタフェース（POSIX）。 Open Groupの技術標準：基本仕様、6号、2001年12月ISO / IEC 9945：2002。 http://www.opengroup.org/austin"
    },
    {
      "indent": 3,
      "text": "[4] Stevens, W. and M. Thomas, \"Advanced Sockets API for IPv6\", RFC 2292, February 1998.",
      "ja": "[4]スティーブンス、W。およびM.トーマス、 \"IPv6用の拡張ソケットAPI\"、RFC 2292、1998年2月。"
    },
    {
      "indent": 3,
      "text": "[5] Nordmark, E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\", RFC 2765, February 2000.",
      "ja": "[5] Nordmarkと、E.、 \"ステートレスIP / ICMP翻訳アルゴリズム（SIIT）\"、RFC 2765、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[6] The Open Group Base Working Group http://www.opengroup.org/platform/base.html",
      "ja": "[6] Open Groupの基本ワーキンググループhttp://www.opengroup.org/platform/base.html"
    },
    {
      "indent": 0,
      "text": "12. Authors' Addresses",
      "section_title": true,
      "ja": "12.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Bob Gilligan Intransa, Inc. 2870 Zanker Rd. San Jose, CA 95134",
      "ja": "ボブギリガンIntransa、Inc.の2870 Zanker Rdを。サンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "Phone: 408-678-8647 EMail: gilligan@intransa.com",
      "ja": "電話：408-678-8647 Eメール：gilligan@intransa.com"
    },
    {
      "indent": 3,
      "text": "Susan Thomson Cisco Systems 499 Thornall Street, 8th floor Edison, NJ 08837",
      "ja": "スーザン・トムソンシスコシステムズ499 Thornallストリート、8階エジソン、NJ 08837"
    },
    {
      "indent": 3,
      "text": "Phone: 732-635-3086 EMail: sethomso@cisco.com",
      "ja": "電話：732-635-3086 Eメール：sethomso@cisco.com"
    },
    {
      "indent": 3,
      "text": "Jim Bound Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 Nashua, NH 03062",
      "ja": "ジム・バウンド米国Hewlett-Packard Company 110 SpitbrookロードZKO3-3 / W20ナシュア、ニューハンプシャー03062"
    },
    {
      "indent": 3,
      "text": "Phone: 603-884-0062 EMail: Jim.Bound@hp.com",
      "ja": "電話：603-884-0062 Eメール：Jim.Bound@hp.com"
    },
    {
      "indent": 3,
      "text": "Jack McCann Hewlett-Packard Company 110 Spitbrook Road ZKO3-3/W20 Nashua, NH 03062",
      "ja": "ジャック・マッキャン、米国Hewlett-Packard Company 110 SpitbrookロードZKO3-3 / W20ナシュア、ニューハンプシャー03062"
    },
    {
      "indent": 3,
      "text": "Phone: 603-884-2608 EMail: Jack.McCann@hp.com",
      "ja": "電話：603-884-2608 Eメール：Jack.McCann@hp.com"
    },
    {
      "indent": 0,
      "text": "13. Full Copyright Statement",
      "section_title": true,
      "ja": "13.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}