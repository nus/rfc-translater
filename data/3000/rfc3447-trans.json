{
  "title": {
    "text": "RFC 3447 - Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1",
    "ja": "RFC 3447 - 公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1"
  },
  "number": 3447,
  "created_at": "2019-10-28 12:00:15.756437+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         J. Jonsson\nRequest for Comments: 3447                                    B. Kaliski\nObsoletes: 2437                                         RSA Laboratories\nCategory: Informational                                    February 2003",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography\n                 Specifications Version 2.1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo represents a republication of PKCS #1 v2.1 from RSA Laboratories' Public-Key Cryptography Standards (PKCS) series, and change control is retained within the PKCS process. The body of this document is taken directly from the PKCS #1 v2.1 document, with certain corrections made during the publication process.",
      "ja": "このメモはRSA Laboratoriesの公開鍵暗号規格（PKCS）シリーズからPKCS＃1 V2.1の再発行を表し、および制御を変更するPKCSプロセス内に保持されます。この文書の本体は、公開プロセス中に行われた特定の修正と、PKCS＃1 V2.1文書から直接取得されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.       Introduction...............................................2\n2.       Notation...................................................3\n3.       Key types..................................................6\n   3.1      RSA public key..........................................6\n   3.2      RSA private key.........................................7\n4.       Data conversion primitives.................................8\n   4.1      I2OSP...................................................9\n   4.2      OS2IP...................................................9\n5.       Cryptographic primitives..................................10\n   5.1      Encryption and decryption primitives...................10\n   5.2      Signature and verification primitives..................12\n6.       Overview of schemes.......................................14\n7.       Encryption schemes........................................15\n   7.1      RSAES-OAEP.............................................16\n   7.2      RSAES-PKCS1-v1_5.......................................23\n8.       Signature schemes with appendix...........................27\n   8.1      RSASSA-PSS.............................................29\n   8.2      RSASSA-PKCS1-v1_5......................................32\n9.       Encoding methods for signatures with appendix.............35",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   9.1      EMSA-PSS...............................................36\n   9.2      EMSA-PKCS1-v1_5........................................41\nAppendix A. ASN.1 syntax...........................................44\n   A.1      RSA key representation.................................44\n   A.2      Scheme identification..................................46\nAppendix B. Supporting techniques..................................52\n   B.1      Hash functions.........................................52\n   B.2      Mask generation functions..............................54\nAppendix C. ASN.1 module...........................................56\nAppendix D. Intellectual Property Considerations...................63\nAppendix E. Revision history.......................................64\nAppendix F. References.............................................65\nAppendix G. About PKCS.............................................70\nAppendix H. Corrections Made During RFC Publication Process........70\nSecurity Considerations............................................70\nAcknowledgements...................................................71\nAuthors' Addresses.................................................71\nFull Copyright Statement...........................................72",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm [42], covering the following aspects:",
      "ja": "この文書は、以下の側面をカバーする、RSAアルゴリズムに基づく公開鍵暗号を実施するための[42]の推奨事項を提供します。"
    },
    {
      "indent": 4,
      "text": "* Cryptographic primitives",
      "ja": "*暗号プリミティブ"
    },
    {
      "indent": 4,
      "text": "* Encryption schemes",
      "ja": "*暗号化方式"
    },
    {
      "indent": 4,
      "text": "* Signature schemes with appendix",
      "ja": "付録付き*署名方式"
    },
    {
      "indent": 4,
      "text": "* ASN.1 syntax for representing keys and for identifying the schemes",
      "ja": "キーを表すと方式を識別するため* ASN.1構文"
    },
    {
      "indent": 3,
      "text": "The recommendations are intended for general application within computer and communications systems, and as such include a fair amount of flexibility. It is expected that application standards based on these specifications may include additional constraints. The recommendations are intended to be compatible with the standard IEEE-1363-2000 [26] and draft standards currently being developed by the ANSI X9F1 [1] and IEEE P1363 [27] working groups.",
      "ja": "勧告は、コンピュータおよび通信システム内の一般的な用途のために意図され、そのようなものとして、柔軟性のかなりの量が含まれます。これらの仕様に基づいてアプリケーションの基準は、追加の制約を含むことができることが期待されています。勧告は、現在ANSI X9F1 [1]、IEEE P1363 [27]ワーキンググループによって開発され、標準的なIEEE-1363から2000 [26]及びドラフト規格と互換性があるように意図されています。"
    },
    {
      "indent": 3,
      "text": "This document supersedes PKCS #1 version 2.0 [35][44] but includes compatible techniques.",
      "ja": "この文書では、PKCS＃1バージョン2.0 [35] [44]を取って代わるが、互換性のある技術を含みます。"
    },
    {
      "indent": 3,
      "text": "The organization of this document is as follows:",
      "ja": "次のように本書の構成は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "* Section 1 is an introduction.",
      "ja": "*第1節のご紹介です。"
    },
    {
      "indent": 4,
      "text": "* Section 2 defines some notation used in this document.",
      "ja": "*第2節では、本書で使用されるいくつかの表記法を定義します。"
    },
    {
      "indent": 4,
      "text": "* Section 3 defines the RSA public and private key types.",
      "ja": "*第3節では、RSA公開鍵と秘密鍵のタイプを定義します。"
    },
    {
      "indent": 4,
      "text": "* Sections 4 and 5 define several primitives, or basic mathematical operations. Data conversion primitives are in Section 4, and cryptographic primitives (encryption-decryption, signature-verification) are in Section 5.",
      "ja": "*セクション4および5には、いくつかのプリミティブ、または基本的な数学演算を定義します。データ変換プリミティブは、セクション4であり、そして暗号プリミティブ（暗号復号、署名検証）はセクション5です。"
    },
    {
      "indent": 4,
      "text": "* Sections 6, 7, and 8 deal with the encryption and signature schemes in this document. Section 6 gives an overview. Along with the methods found in PKCS #1 v1.5, Section 7 defines an OAEP-based [3] encryption scheme and Section 8 defines a PSS-based [4][5] signature scheme with appendix.",
      "ja": "*セクション6、7、及びこの文書の暗号化および署名スキーム8取引。第6節では概要を説明します。 PKCS＃1 V1.5で見つかった方法と共に、第7章は、OAEPベースの[3]の暗号化方式を定義し、セクション8付録とPSS系[4] [5]署名方式を定義します。"
    },
    {
      "indent": 4,
      "text": "* Section 9 defines the encoding methods for the signature schemes in Section 8.",
      "ja": "*部9は、第8章の署名方式の符号化方法を規定します。"
    },
    {
      "indent": 4,
      "text": "* Appendix A defines the ASN.1 syntax for the keys defined in Section 3 and the schemes in Sections 7 and 8.",
      "ja": "*付録Aは、セクション3で定義されたキーとセクション7および8におけるスキームのASN.1構文を定義します。"
    },
    {
      "indent": 4,
      "text": "* Appendix B defines the hash functions and the mask generation function used in this document, including ASN.1 syntax for the techniques.",
      "ja": "*付録Bは、技術のためのASN.1構文を含む、ハッシュ関数と本書で使用されるマスク生成関数を定義します。"
    },
    {
      "indent": 4,
      "text": "* Appendix C gives an ASN.1 module.",
      "ja": "*付録Cは、ASN.1モジュールを提供します。"
    },
    {
      "indent": 4,
      "text": "* Appendices D, E, F and G cover intellectual property issues, outline the revision history of PKCS #1, give references to other publications and standards, and provide general information about the Public-Key Cryptography Standards.",
      "ja": "*付録D、E、F及びGは、知的財産の問題をカバーし、他の出版物や標準への参照を与えて、PKCS＃1の改訂履歴を概説し、公開鍵暗号規格に関する一般的な情報を提供しています。"
    },
    {
      "indent": 0,
      "text": "2. Notation",
      "section_title": true,
      "ja": "2.記法"
    },
    {
      "indent": 3,
      "text": "c ciphertext representative, an integer between 0 and n-1",
      "ja": "C暗号文代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "C ciphertext, an octet string",
      "ja": "Cの暗号文、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "d RSA private exponent d_i additional factor r_i's CRT exponent, a positive integer such that",
      "ja": "D RSA秘密指数D_I追加の因子R_iとのCRT指数、その結果、正の整数"
    },
    {
      "indent": 20,
      "text": "e * d_i == 1 (mod (r_i-1)), i = 3, ..., u",
      "ja": "E * D_I == 1（MOD（R_iと-1））、I = 3、...、uの"
    },
    {
      "indent": 3,
      "text": "dP p's CRT exponent, a positive integer such that",
      "ja": "DP PのCRT指数、そのように正の整数"
    },
    {
      "indent": 20,
      "text": "e * dP == 1 (mod (p-1))",
      "ja": "E *のdP == 1（MOD（P-1））"
    },
    {
      "indent": 3,
      "text": "dQ q's CRT exponent, a positive integer such that",
      "ja": "DQ QのCRT指数、そのように正の整数"
    },
    {
      "indent": 20,
      "text": "e * dQ == 1 (mod (q-1))",
      "ja": "E *のDQ == 1（MOD（Q-1））"
    },
    {
      "indent": 3,
      "text": "e RSA public exponent",
      "ja": "電子RSA公開指数"
    },
    {
      "indent": 3,
      "text": "EM encoded message, an octet string",
      "ja": "EMエンコードされたメッセージ、オクテットストリング"
    },
    {
      "indent": 3,
      "text": "emBits (intended) length in bits of an encoded message EM",
      "ja": "エンコードされたメッセージEMのビットでemBits（意図）の長さ"
    },
    {
      "indent": 3,
      "text": "emLen (intended) length in octets of an encoded message EM",
      "ja": "エンコードされたメッセージEMのオクテットでemLen（意図）の長さ"
    },
    {
      "indent": 3,
      "text": "GCD(. , .) greatest common divisor of two nonnegative integers",
      "ja": "GCD（。、。）は、2つの非負の整数の最大公約数"
    },
    {
      "indent": 3,
      "text": "Hash hash function",
      "ja": "ハッシュハッシュ関数"
    },
    {
      "indent": 3,
      "text": "hLen output length in octets of hash function Hash",
      "ja": "ハッシュ関数HashのオクテットさhLen出力長"
    },
    {
      "indent": 3,
      "text": "k length in octets of the RSA modulus n",
      "ja": "RSAモジュラスNのオクテットにおけるk長"
    },
    {
      "indent": 3,
      "text": "K RSA private key",
      "ja": "K RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "L optional RSAES-OAEP label, an octet string",
      "ja": "LオプションRSAES-OAEPラベル、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "LCM(., ..., .) least common multiple of a list of nonnegative integers",
      "ja": "LCM（。、...、。）非負整数のリストの最小公倍数"
    },
    {
      "indent": 3,
      "text": "m message representative, an integer between 0 and n-1",
      "ja": "m個のメッセージ代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "M message, an octet string",
      "ja": "Mメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "mask MGF output, an octet string",
      "ja": "MGF出力、オクテット文字列を隠します"
    },
    {
      "indent": 3,
      "text": "maskLen (intended) length of the octet string mask",
      "ja": "オクテットストリングマスクのmaskLen（意図）の長さ"
    },
    {
      "indent": 3,
      "text": "MGF mask generation function",
      "ja": "MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "mgfSeed seed from which mask is generated, an octet string mLen length in octets of a message M",
      "ja": "マスクが生成されるからmgfSeed種、メッセージMのオクテットオクテットストリングMLEN長"
    },
    {
      "indent": 3,
      "text": "n RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2",
      "ja": "nはRSAモジュラス、N = R_1 * R_2 * ... * r_u、U> = 2"
    },
    {
      "indent": 3,
      "text": "(n, e) RSA public key",
      "ja": "（N、e）はRSA公開鍵"
    },
    {
      "indent": 3,
      "text": "p, q first two prime factors of the RSA modulus n",
      "ja": "P、RSAモジュラスNのQ最初の二つの素因数"
    },
    {
      "indent": 3,
      "text": "qInv CRT coefficient, a positive integer less than p such that",
      "ja": "qInv CRT係数、そのようなp以下の正の整数"
    },
    {
      "indent": 20,
      "text": "q * qInv == 1 (mod p)",
      "ja": "Q * qInv == 1（モッズP）"
    },
    {
      "indent": 3,
      "text": "r_i prime factors of the RSA modulus n, including r_1 = p, r_2 = q, and additional factors if any",
      "ja": "R_1 = P、R_2 = Q含むRSAモジュラスNのR_iを素因数、およびさらなる因子があれば"
    },
    {
      "indent": 3,
      "text": "s signature representative, an integer between 0 and n-1",
      "ja": "S署名代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "S signature, an octet string",
      "ja": "S署名、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "sLen length in octets of the EMSA-PSS salt",
      "ja": "EMSA-PSS塩のオクテットでSLEN長"
    },
    {
      "indent": 3,
      "text": "t_i additional prime factor r_i's CRT coefficient, a positive integer less than r_i such that",
      "ja": "追加の素因数R_iとのCRT係数、R_iをより小さい正の整数T_Iよう"
    },
    {
      "indent": 20,
      "text": "r_1 * r_2 * ... * r_(i-1) * t_i == 1 (mod r_i) ,",
      "ja": "R_1 * R_2 * ... * R_（I-1）* T_I == 1（MOD R_iと）、"
    },
    {
      "indent": 18,
      "text": "i = 3, ... , u",
      "ja": "I = 3、...、で"
    },
    {
      "indent": 3,
      "text": "u number of prime factors of the RSA modulus, u >= 2",
      "ja": "RSAモジュラスの素因数の数U、U> = 2"
    },
    {
      "indent": 3,
      "text": "x a nonnegative integer",
      "ja": "X非負整数"
    },
    {
      "indent": 3,
      "text": "X an octet string corresponding to x",
      "ja": "xに対応Xオクテットストリング"
    },
    {
      "indent": 3,
      "text": "xLen (intended) length of the octet string X",
      "ja": "オクテットストリングXのXLEN（意図）の長さ"
    },
    {
      "indent": 3,
      "text": "0x indicator of hexadecimal representation of an octet or an octet string; \"0x48\" denotes the octet with hexadecimal value 48; \"(0x)48 09 0e\" denotes the string of three consecutive octets with hexadecimal value 48, 09, and 0e, respectively",
      "ja": "オクテットまたはオクテットストリングの16進表現の0Xインジケータ。 「0x48」は16進数の値48を持つオクテットを表します。 「（0X）48 09 0E」は、それぞれ、進値48、09、及び0E有する三つの連続オクテットストリングを示し"
    },
    {
      "indent": 3,
      "text": "\\lambda(n) LCM(r_1-1, r_2-1, ... , r_u-1)",
      "ja": "\\ラムダ（N）LCM（r_1-1、r_2-1、...、r_u-1）"
    },
    {
      "indent": 3,
      "text": "\\xor bit-wise exclusive-or of two octet strings",
      "ja": "\\のXORビット単位の排他的論理和の2つのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "\\ceil(.) ceiling function; \\ceil(x) is the smallest integer larger than or equal to the real number x",
      "ja": "（。）\\切り上げ天井機能; \\ CEIL（x）はxの実数への最小の整数より大きいか等しいです"
    },
    {
      "indent": 3,
      "text": "|| concatenation operator",
      "ja": "||連結演算子"
    },
    {
      "indent": 3,
      "text": "== congruence symbol; a == b (mod n) means that the integer n divides the integer a - b",
      "ja": "==合同シンボル。 ==のB（mod n）を計算する整数nは、整数A分割することを意味する -  Bを"
    },
    {
      "indent": 3,
      "text": "Note. The CRT can be applied in a non-recursive as well as a recursive way. In this document a recursive approach following Garner's algorithm [22] is used. See also Note 1 in Section 3.2.",
      "ja": "注意。 CRTは、非再帰ならびに再帰的な方法で適用することができます。この文書ではガーナーのアルゴリズム以下の再帰的なアプローチは、[22]は使用されています。 3.2節で注記1をも参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Key types",
      "section_title": true,
      "ja": "3.キータイプ"
    },
    {
      "indent": 3,
      "text": "Two key types are employed in the primitives and schemes defined in this document: RSA public key and RSA private key. Together, an RSA public key and an RSA private key form an RSA key pair.",
      "ja": "RSA公開鍵とRSA秘密鍵：二つのキータイプは、この文書で定義されたプリミティブとのスキームで採用されています。一緒に、RSA公開鍵とRSA鍵ペアの形RSA秘密鍵。"
    },
    {
      "indent": 3,
      "text": "This specification supports so-called \"multi-prime\" RSA where the modulus may have more than two prime factors. The benefit of multi-prime RSA is lower computational cost for the decryption and signature primitives, provided that the CRT (Chinese Remainder Theorem) is used. Better performance can be achieved on single processor platforms, but to a greater extent on multiprocessor platforms, where the modular exponentiations involved can be done in parallel.",
      "ja": "この仕様は、弾性率が二つ以上の素因数を有していてもよく、いわゆる「マルチプライム」RSAをサポートしています。マルチプライムRSAの利点は、復号化および署名のプリミティブのためのより低い計算コストは​​、CRT（中国の剰余定理）が使用されることが提供されます。良好な性能は、単一のプロセッサ・プラットフォーム上で、しかし関与モジュラ累乗を並行して行うことができるマルチプロセッサ・プラットフォーム上でより大きな程度に達成することができます。"
    },
    {
      "indent": 3,
      "text": "For a discussion on how multi-prime affects the security of the RSA cryptosystem, the reader is referred to [49].",
      "ja": "RSA暗号の安全性をどのように影響するか、マルチプライムの議論について、読者は[49]と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.1 RSA public key",
      "section_title": true,
      "ja": "3.1 RSA公開鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA public key consists of two components:",
      "ja": "このドキュメントの目的のためには、RSA公開鍵は、次の2つのコンポーネントで構成されています。"
    },
    {
      "indent": 6,
      "text": "n the RSA modulus, a positive integer e the RSA public exponent, a positive integer",
      "ja": "nはRSAモジュラス、正の整数は、正の整数をRSA公開指数eは"
    },
    {
      "indent": 3,
      "text": "In a valid RSA public key, the RSA modulus n is a product of u distinct odd primes r_i, i = 1, 2, ..., u, where u >= 2, and the RSA public exponent e is an integer between 3 and n - 1 satisfying GCD(e, \\lambda(n)) = 1, where \\lambda(n) = LCM(r_1 - 1, ..., r_u - 1). By convention, the first two primes r_1 and r_2 may also be denoted p and q respectively.",
      "ja": "U> = 2、及びRSA公開指数eは3の整数であり、有効なRSA公開鍵は、RSAモジュラスN Uの積異なる奇数の素数R_iとで、I = 1、2、...、U、そしてn  -  1満足GCD（E、\\ラムダ（N））= 1、\\ラムダ（N）= LCM（R_1  -  1、...、r_u  -  1）。慣例により、最初の二つの素数R_1とR_2は、それぞれpとqと表すことができます。"
    },
    {
      "indent": 3,
      "text": "A recommended syntax for interchanging RSA public keys between implementations is given in Appendix A.1.1; an implementation's internal representation may differ.",
      "ja": "実装間RSA公開鍵を交換するための推奨構文は、付録A.1.1に与えられています。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2 RSA private key",
      "section_title": true,
      "ja": "3.2 RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA private key may have either of two representations.",
      "ja": "このドキュメントの目的のために、RSA秘密鍵は、2つの表現のいずれかを有することができます。"
    },
    {
      "indent": 3,
      "text": "1. The first representation consists of the pair (n, d), where the components have the following meanings:",
      "ja": "1.第1の表現は、成分は以下の意味を有する対（N、D）、から構成されています。"
    },
    {
      "indent": 9,
      "text": "n        the RSA modulus, a positive integer\nd        the RSA private exponent, a positive integer",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. The second representation consists of a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (r_i, d_i, t_i), i = 3, ..., u, one for each prime not in the quintuple, where the components have the following meanings:",
      "ja": "前記第2の表現は、五重（P、Q、DP、dQの、qInv）及びトリプレットの（おそらく空の）配列（R_iを、D_I、T_I）から成り、I = 3、...、U、それぞれに1つずつコンポーネントは以下の意味を有する五重、中に素数でありません。"
    },
    {
      "indent": 9,
      "text": "p        the first factor, a positive integer\nq        the second factor, a positive integer\ndP       the first factor's CRT exponent, a positive integer\ndQ       the second factor's CRT exponent, a positive integer\nqInv     the (first) CRT coefficient, a positive integer\nr_i      the i-th factor, a positive integer\nd_i      the i-th factor's CRT exponent, a positive integer\nt_i      the i-th factor's CRT coefficient, a positive integer",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In a valid RSA private key with the first representation, the RSA modulus n is the same as in the corresponding RSA public key and is the product of u distinct odd primes r_i, i = 1, 2, ..., u, where u >= 2. The RSA private exponent d is a positive integer less than n satisfying",
      "ja": "第1の表現のある有効なRSA秘密鍵は、RSAモジュラスN対応するRSA公開鍵と同じであり、uの積異なる奇数の素数R_iとで、I = 1、2、...、U、ここで、u > = 2 RSA秘密指数dは、nを満たすより小さい正の整数であります"
    },
    {
      "indent": 6,
      "text": "e * d == 1 (mod \\lambda(n)),",
      "ja": "E * D == 1（MOD \\ラムダ（N））、"
    },
    {
      "indent": 3,
      "text": "where e is the corresponding RSA public exponent and \\lambda(n) is defined as in Section 3.1.",
      "ja": "eは対応するRSA公開指数と\\ラムダである場合（n）はセクション3.1で定義した通りです。"
    },
    {
      "indent": 3,
      "text": "In a valid RSA private key with the second representation, the two factors p and q are the first two prime factors of the RSA modulus n (i.e., r_1 and r_2), the CRT exponents dP and dQ are positive integers less than p and q respectively satisfying",
      "ja": "第二の表現のある有効なRSA秘密鍵では、二つの要因p及びqはRSAモジュラスN（すなわち、R_1とR_2）、CRTは、DP及びDQは指数の最初の二つの素因数は、pおよびq未満の正の整数でありますそれぞれ満足"
    },
    {
      "indent": 6,
      "text": "e * dP == 1 (mod (p-1)) e * dQ == 1 (mod (q-1)) ,",
      "ja": "E *のDP == 1（MOD（P-1））E *のDQ == 1（MOD（Q-1））、"
    },
    {
      "indent": 3,
      "text": "and the CRT coefficient qInv is a positive integer less than p satisfying",
      "ja": "そしてCRT係数qInvは、p満たすより小さい正の整数であります"
    },
    {
      "indent": 6,
      "text": "q * qInv == 1 (mod p).",
      "ja": "Q * qInv == 1（モッズP）。"
    },
    {
      "indent": 3,
      "text": "If u > 2, the representation will include one or more triplets (r_i, d_i, t_i), i = 3, ..., u. The factors r_i are the additional prime factors of the RSA modulus n. Each CRT exponent d_i (i = 3, ..., u) satisfies",
      "ja": "U> 2ならば、表現は一つ以上のトリプレット（R_iと、D_I、T_I）、I = 3、...、Uが含まれます。因子R_iとは、RSAモジュラスNの追加の素因数です。各CRT指数D_I（I = 3、...、U）を満たします"
    },
    {
      "indent": 6,
      "text": "e * d_i == 1 (mod (r_i - 1)).",
      "ja": "E * D_I == 1（MOD（R_iと -  1））。"
    },
    {
      "indent": 3,
      "text": "Each CRT coefficient t_i (i = 3, ..., u) is a positive integer less than r_i satisfying",
      "ja": "各CRT係数T_I（I = 3、...、U）を満足R_iをより小さい正の整数であります"
    },
    {
      "indent": 6,
      "text": "R_i * t_i == 1 (mod r_i) ,",
      "ja": "R_iと* T_I == 1（MOD R_iと）、"
    },
    {
      "indent": 3,
      "text": "where R_i = r_1 * r_2 * ... * r_(i-1).",
      "ja": "R_iと= R_1 * R_2 * ... * R_（I-1）。"
    },
    {
      "indent": 3,
      "text": "A recommended syntax for interchanging RSA private keys between implementations, which includes components from both representations, is given in Appendix A.1.2; an implementation's internal representation may differ.",
      "ja": "両方の表現から構成要素を含む実装の間のRSA秘密鍵を交換するための推奨構文は、付録A.1.2で与えられます。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "Notes.",
      "ja": "ノート。"
    },
    {
      "indent": 3,
      "text": "1. The definition of the CRT coefficients here and the formulas that use them in the primitives in Section 5 generally follow Garner's algorithm [22] (see also Algorithm 14.71 in [37]). However, for compatibility with the representations of RSA private keys in PKCS #1 v2.0 and previous versions, the roles of p and q are reversed compared to the rest of the primes. Thus, the first CRT coefficient, qInv, is defined as the inverse of q mod p, rather than as the inverse of R_1 mod r_2, i.e., of p mod q.",
      "ja": "1.ここでCRT係数及びセクション5でプリミティブにそれらを使用する式の定義は、一般ガーナーのアルゴリズムに従う[22]（[37]にも、アルゴリズム14.71を参照のこと）。しかしながら、PKCS＃1 V2.0と以前のバージョンのRSA秘密鍵の表現との互換性のために、pおよびqの役割は、素数の残りの部分に比べて逆になっています。したがって、第一CRT係数、qInvは、P MOD qは、すなわち、Q MOD Pの逆数としてではなく、R_1 MOD R_2の逆数として定義されます。"
    },
    {
      "indent": 3,
      "text": "2. Quisquater and Couvreur [40] observed the benefit of applying the Chinese Remainder Theorem to RSA operations.",
      "ja": "2. QuisquaterのとCouvreur [40] RSA操作に中国の剰余定理を適用することの利点を観察しました。"
    },
    {
      "indent": 0,
      "text": "4. Data conversion primitives",
      "section_title": true,
      "ja": "4.データ変換プリミティブ"
    },
    {
      "indent": 3,
      "text": "Two data conversion primitives are employed in the schemes defined in this document:",
      "ja": "二つのデータ変換プリミティブは、この文書で定義されたスキームで採用されています。"
    },
    {
      "indent": 6,
      "text": "* I2OSP - Integer-to-Octet-String primitive",
      "ja": "* I2OSP  - 整数ツーオクテット文字列プリミティブ"
    },
    {
      "indent": 6,
      "text": "* OS2IP - Octet-String-to-Integer primitive",
      "ja": "* OS2IP  - オクテット文字列から整数プリミティブ"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, and consistent with ASN.1 syntax, an octet string is an ordered sequence of octets (eight-bit bytes). The sequence is indexed from first (conventionally, leftmost) to last (rightmost). For purposes of conversion to and from integers, the first octet is considered the most significant in the following conversion primitives.",
      "ja": "ASN.1構文で、かつ一貫したこのドキュメントの目的のためには、オクテット文字列はオクテット（8ビットバイト）の順序付けられたシーケンスです。配列（右端）が最後第1（従来は、左端）からインデックス付けされます。整数にしてからの変換のためには、最初のオクテットは、次の変換プリミティブの中で最も重要と考えられています。"
    },
    {
      "indent": 0,
      "text": "4.1 I2OSP",
      "section_title": true,
      "ja": "4.1 I2OSP"
    },
    {
      "indent": 3,
      "text": "I2OSP converts a nonnegative integer to an octet string of a specified length.",
      "ja": "I2OSPは、指定された長さのオクテットストリングに非負の整数に変換します。"
    },
    {
      "indent": 3,
      "text": "I2OSP (x, xLen)",
      "ja": "I2OSP（X、XLEN）"
    },
    {
      "indent": 3,
      "text": "Input: x nonnegative integer to be converted xLen intended length of the resulting octet string",
      "ja": "入力：得られたオクテットストリングのXLEN意図長さを変換するX非負整数"
    },
    {
      "indent": 3,
      "text": "Output: X corresponding octet string of length xLen",
      "ja": "出力：長さXLENのオクテット文字列を対応するX"
    },
    {
      "indent": 3,
      "text": "Error: \"integer too large\"",
      "ja": "エラー：「あまりにも大きな整数」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If x >= 256^xLen, output \"integer too large\" and stop.",
      "section_title": true,
      "ja": "1. X> = 256 ^ XLEN、出力 \"あまりにも大きな整数\" と停止した場合。"
    },
    {
      "indent": 3,
      "text": "2. Write the integer x in its unique xLen-digit representation in base 256:",
      "ja": "2.ベース256に独自XLEN桁表現で整数xを書きます"
    },
    {
      "indent": 9,
      "text": "x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...\n+ x_1 256 + x_0,",
      "raw": true
    },
    {
      "indent": 6,
      "text": "where 0 <= x_i < 256 (note that one or more leading digits will be zero if x is less than 256^(xLen-1)).",
      "ja": "ここで、0 <= X_I <256（xは256未満^（XLEN-1）である場合、一つ以上の先頭の数字がゼロになることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "3. Let the octet X_i have the integer value x_(xLen-i) for 1 <= i <= xLen. Output the octet string",
      "ja": "3.オクテットX_I 1 <= I <= XLENための整数値X_（XLEN-I）を有しう。オクテット文字列を出力"
    },
    {
      "indent": 9,
      "text": "X = X_1 X_2 ... X_xLen.",
      "ja": "X = X_1 X_2 ... X_xLen。"
    },
    {
      "indent": 0,
      "text": "4.2 OS2IP",
      "section_title": true,
      "ja": "4.2 OS2IP"
    },
    {
      "indent": 3,
      "text": "OS2IP converts an octet string to a nonnegative integer.",
      "ja": "OS2IPは非負整数のオクテット列に変換します。"
    },
    {
      "indent": 3,
      "text": "OS2IP (X)",
      "ja": "OS2IP（X）"
    },
    {
      "indent": 3,
      "text": "Input: X octet string to be converted",
      "ja": "入力：Xオクテット文字列を変換します"
    },
    {
      "indent": 3,
      "text": "Output: x corresponding nonnegative integer",
      "ja": "出力：X対応する非負の整数"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Let X_1 X_2 ... X_xLen be the octets of X from first to last, and let x_(xLen-i) be the integer value of the octet X_i for 1 <= i <= xLen.",
      "ja": "1. X_xLen最後まで最初からXのオクテットである... X_1 X_2をしよう、とX_（XLEN-i）が1 <= I <= XLENためオクテットX_Iの整数値とします。"
    },
    {
      "indent": 3,
      "text": "2. Let x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ... + x_1 256 + x_0.",
      "ja": "2. X = X_（XLEN-1）256 ^（XLEN-1）+ X_（XLEN-2）256 ^（XLEN-2）+ ... + 256 + X_0 X_1う。"
    },
    {
      "indent": 3,
      "text": "3. Output x.",
      "section_title": true,
      "ja": "3.出力X。"
    },
    {
      "indent": 0,
      "text": "5. Cryptographic primitives",
      "section_title": true,
      "ja": "5.暗号プリミティブ"
    },
    {
      "indent": 3,
      "text": "Cryptographic primitives are basic mathematical operations on which cryptographic schemes can be built. They are intended for implementation in hardware or as software modules, and are not intended to provide security apart from a scheme.",
      "ja": "暗号プリミティブは、暗号化スキームが構築できる基本的な数学的な操作です。彼らはハードウェアまたはソフトウェアモジュールとして実装することを意図しており、スキームから離れてセキュリティを提供することを意図していません。"
    },
    {
      "indent": 3,
      "text": "Four types of primitive are specified in this document, organized in pairs: encryption and decryption; and signature and verification.",
      "ja": "プリミティブの4種類の、この文書で指定されたペアで編成されています暗号化と復号化。署名と検証。"
    },
    {
      "indent": 3,
      "text": "The specifications of the primitives assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid.",
      "ja": "プリミティブの仕様は、特定の条件がRSA公開鍵と秘密鍵が有効であること、特に、入力で満たされていることを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.1 Encryption and decryption primitives",
      "section_title": true,
      "ja": "5.1暗号化と復号化のプリミティブ"
    },
    {
      "indent": 3,
      "text": "An encryption primitive produces a ciphertext representative from a message representative under the control of a public key, and a decryption primitive recovers the message representative from the ciphertext representative under the control of the corresponding private key.",
      "ja": "プリミティブ暗号化は、公開鍵の制御下でメッセージ代表から暗号文代表を生成し、原始的復号化は、対応する秘密鍵の制御下で暗号文代表からのメッセージ代表を回復します。"
    },
    {
      "indent": 3,
      "text": "One pair of encryption and decryption primitives is employed in the encryption schemes defined in this document and is specified here: RSAEP/RSADP. RSAEP and RSADP involve the same mathematical operation, with different keys as input.",
      "ja": "暗号化と復号化プリミティブの一つのペアは、この文書で定義された暗号化方式で採用されており、ここで指定されていますRSAEP / RSADP。 RSAEPとRSADPは、入力として、異なるキーを使用して、同じ数学的な操作を必要とします。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as IFEP-RSA/IFDP-RSA in IEEE Std 1363-2000 [26] (except that support for multi-prime RSA has been added) and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されたプリミティブは、IEEE STD 1363から2000 [26]（マルチプライムRSAのためにそのサポートが追加されている以外）にIFEP-RSA / IFDP-RSAと同じであり、PKCS＃1 V1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation.",
      "ja": "各プリミティブの主な数学的な操作は累乗です。"
    },
    {
      "indent": 0,
      "text": "5.1.1 RSAEP",
      "section_title": true,
      "ja": "5.1.1 RSAEP"
    },
    {
      "indent": 3,
      "text": "RSAEP ((n, e), m)",
      "ja": "RSAEP（（N、E）、M）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key m message representative, an integer between 0 and n - 1",
      "ja": "入力：（N、e）はRSA公開鍵Mメッセージ代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Output: c ciphertext representative, an integer between 0 and n - 1",
      "ja": "出力：C暗号文代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Error: \"message representative out of range\"",
      "ja": "エラー：「範囲外のメッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumption: RSA public key (n, e) is valid",
      "ja": "アサンプション：RSA公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the message representative m is not between 0 and n - 1, output \"message representative out of range\" and stop.",
      "ja": "1.メッセージ代表mが0とnの間にない場合は -  1、出力「範囲外のメッセージを表す」と停止。"
    },
    {
      "indent": 3,
      "text": "2. Let c = m^e mod n.",
      "section_title": true,
      "ja": "2. C = M ^ E mod nをしましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output c.",
      "section_title": true,
      "ja": "3.出力c。"
    },
    {
      "indent": 0,
      "text": "5.1.2 RSADP",
      "section_title": true,
      "ja": "5.1.2 RSADP"
    },
    {
      "indent": 3,
      "text": "RSADP (K, c)",
      "ja": "RSADP（K、C）"
    },
    {
      "indent": 3,
      "text": "Input: K RSA private key, where K has one of the following forms: - a pair (n, d) - a quintuple (p, q, dP, dQ, qInv) and a possibly empty sequence of triplets (r_i, d_i, t_i), i = 3, ..., u c ciphertext representative, an integer between 0 and n - 1",
      "ja": "入力：K RSA秘密鍵Kは、以下のいずれかの形式を有している： - 対（N、D） - 五重の（P、Q、DP、dQの、qInv）及びトリプレットの可能性が空のシーケンス（R_iを、D_I、 T_I）、I = 3、···、UC暗号文代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n - 1",
      "ja": "出力：Mメッセージ代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Error: \"ciphertext representative out of range\"",
      "ja": "エラー：「範囲外の暗号文代表」"
    },
    {
      "indent": 3,
      "text": "Assumption: RSA private key K is valid",
      "ja": "アサンプション：RSA秘密鍵Kが有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the ciphertext representative c is not between 0 and n - 1, output \"ciphertext representative out of range\" and stop.",
      "ja": "1.暗号文代表cが0とNの間にない場合は -  1、出力「範囲外の暗号文代表」と停止。"
    },
    {
      "indent": 3,
      "text": "2. The message representative m is computed as follows.",
      "section_title": true,
      "ja": "2.次のように表すメッセージmが計算されます。"
    },
    {
      "indent": 6,
      "text": "a. If the first form (n, d) of K is used, let m = c^d mod n.",
      "ja": "A。 Kの第一の形態（N、D）が使用される場合、M = C ^ D mod nをしましょう。"
    },
    {
      "indent": 6,
      "text": "b. If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i) of K is used, proceed as follows:",
      "ja": "B。 Kの第二の形態（P、Q、DP、dQの、qInv）及び（R_iを、D_I、T_I）が使用されている場合は、次のように進みます。"
    },
    {
      "indent": 9,
      "text": "i. Let m_1 = c^dP mod p and m_2 = c^dQ mod q.",
      "ja": "私。 M_1 = C ^のdPモッズpとM_2 = C ^ dQのモッズQましょう。"
    },
    {
      "indent": 9,
      "text": "ii. If u > 2, let m_i = c^(d_i) mod r_i, i = 3, ..., u.",
      "ja": "II。 uが> 2、M_I = C ^（D_I）モッズR_iと、I = 3、...、uのを聞かせてください。"
    },
    {
      "indent": 9,
      "text": "iii. Let h = (m_1 - m_2) * qInv mod p.",
      "ja": "III。 * qInvモッズP  -  H =（M_2 M_1）してみましょう。"
    },
    {
      "indent": 9,
      "text": "iv. Let m = m_2 + q * h.",
      "ja": "IV。 M = M_2 + Q * Hをしましょう。"
    },
    {
      "indent": 9,
      "text": "v. If u > 2, let R = r_1 and for i = 3 to u do",
      "ja": "U> 2場合は、V。、R = R_1とのuに対するI = 3のためにやってみましょう"
    },
    {
      "indent": 18,
      "text": "1. Let R = R * r_(i-1).",
      "section_title": true,
      "ja": "1. Rは= R * R_（I-1）してみましょう。"
    },
    {
      "indent": 18,
      "text": "2. Let h = (m_i - m) * t_i mod r_i.",
      "section_title": true,
      "ja": "* T_I MOD R_iを -  2、H =（M M_I）ましょう。"
    },
    {
      "indent": 18,
      "text": "3. Let m = m + R * h.",
      "section_title": true,
      "ja": "3. M = M + R * hでみましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "section_title": true,
      "ja": "3.出力メートル。"
    },
    {
      "indent": 3,
      "text": "Note. Step 2.b can be rewritten as a single loop, provided that one reverses the order of p and q. For consistency with PKCS #1 v2.0, however, the first two primes p and q are treated separately from the additional primes.",
      "ja": "注意。ステップ2.Bは、1つのpとqの順序を逆にすることを提供、単一ループのように書き換えることができます。 PKCS＃1 V2.0との整合性のために、しかし、最初の二つの素数pおよびqは、追加の素数とは別に処理されます。"
    },
    {
      "indent": 0,
      "text": "5.2 Signature and verification primitives",
      "section_title": true,
      "ja": "5.2署名と検証プリミティブ"
    },
    {
      "indent": 3,
      "text": "A signature primitive produces a signature representative from a message representative under the control of a private key, and a verification primitive recovers the message representative from the signature representative under the control of the corresponding public key. One pair of signature and verification primitives is employed in the signature schemes defined in this document and is specified here: RSASP1/RSAVP1.",
      "ja": "プリミティブ署名は、秘密鍵の制御下でメッセージ代表から署名代表を生成し、原始的検証は、対応する公開鍵の制御下で署名代表からのメッセージ代表を回復します。署名と検証プリミティブの一組は、この文書で定義された署名方式に採用されており、ここで指定されている：RSASP1 / RSAVP1。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as IFSP-RSA1/IFVP-RSA1 in IEEE 1363-2000 [26] (except that support for multi-prime RSA has been added) and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されたプリミティブは、IEEE 1363から2000にIFSP  -  RSA1 / IFVP-RSA1 [26]（マルチプライムRSAのためにそのサポートが追加された以外は）と同じであり、PKCS＃1 V1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation, as in the encryption and decryption primitives of Section 5.1. RSASP1 and RSAVP1 are the same as RSADP and RSAEP except for the names of their input and output arguments; they are distinguished as they are intended for different purposes.",
      "ja": "各プリミティブの主な数学的な操作は、セクション5.1の暗号化と復号化プリミティブのように、累乗です。 RSASP1とRSAVP1は、その入力と出力引数の名前を除いてRSADPとRSAEPと同じです。それらは異なる目的のために意図されているとして、彼らは区別されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1 RSASP1",
      "section_title": true,
      "ja": "5.2.1 RSASP1"
    },
    {
      "indent": 3,
      "text": "RSASP1 (K, m)",
      "ja": "RSASP1（K、M）"
    },
    {
      "indent": 3,
      "text": "Input: K RSA private key, where K has one of the following forms: - a pair (n, d) - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (r_i, d_i, t_i), i = 3, ..., u m message representative, an integer between 0 and n - 1",
      "ja": "入力：K Kは、以下のいずれかの形式を有するRSAプライベートキー、 - ペア（N、D） - 五重（P、Q、DP、dQの、qInv）及びトリプレットの（おそらく空の）配列（R_iを、 D_I、T_I）、I = 3、...、UMメッセージ代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Output: s signature representative, an integer between 0 and n - 1",
      "ja": "出力：S署名代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Error: \"message representative out of range\"",
      "ja": "エラー：「範囲外のメッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumption: RSA private key K is valid",
      "ja": "アサンプション：RSA秘密鍵Kが有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the message representative m is not between 0 and n - 1, output \"message representative out of range\" and stop.",
      "ja": "1.メッセージ代表mが0とnの間にない場合は -  1、出力「範囲外のメッセージを表す」と停止。"
    },
    {
      "indent": 3,
      "text": "2. The signature representative s is computed as follows.",
      "section_title": true,
      "ja": "2.次のように署名代表sが計算されます。"
    },
    {
      "indent": 6,
      "text": "a. If the first form (n, d) of K is used, let s = m^d mod n.",
      "ja": "A。 Kの第一の形態（N、D）が使用される場合、SはM ^ D mod nを計算してみましょう=。"
    },
    {
      "indent": 9,
      "text": "b. If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i) of K is used, proceed as follows:",
      "ja": "B。 Kの第二の形態（P、Q、DP、dQの、qInv）及び（R_iを、D_I、T_I）が使用されている場合は、次のように進みます。"
    },
    {
      "indent": 9,
      "text": "i. Let s_1 = m^dP mod p and s_2 = m^dQ mod q.",
      "ja": "私。 S_1 = M ^のdPのmod pとS_2 = M ^ dQのモッズQましょう。"
    },
    {
      "indent": 9,
      "text": "ii. If u > 2, let s_i = m^(d_i) mod r_i, i = 3, ..., u.",
      "ja": "II。 U> 2場合は、S_I = M ^（D_I）モッズR_iと、I = 3、...、uとしましょう。"
    },
    {
      "indent": 9,
      "text": "iii. Let h = (s_1 - s_2) * qInv mod p.",
      "ja": "III。 * qInvモッズP  -  H =（S_2 S_1）してみましょう。"
    },
    {
      "indent": 9,
      "text": "iv. Let s = s_2 + q * h.",
      "ja": "IV。 S = S_2 + Q * Hをしてみましょう。"
    },
    {
      "indent": 9,
      "text": "v. If u > 2, let R = r_1 and for i = 3 to u do",
      "ja": "U> 2場合は、V。、R = R_1とのuに対するI = 3のためにやってみましょう"
    },
    {
      "indent": 18,
      "text": "1. Let R = R * r_(i-1).",
      "section_title": true,
      "ja": "1. Rは= R * R_（I-1）してみましょう。"
    },
    {
      "indent": 18,
      "text": "2. Let h = (s_i - s) * t_i mod r_i.",
      "section_title": true,
      "ja": "2.レッツさh =（S_I  -  S）* T_IモッズR_iと。"
    },
    {
      "indent": 18,
      "text": "3. Let s = s + R * h.",
      "section_title": true,
      "ja": "3. S = Sで+ Rの* hをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output s.",
      "section_title": true,
      "ja": "3.出力S。"
    },
    {
      "indent": 3,
      "text": "Note. Step 2.b can be rewritten as a single loop, provided that one reverses the order of p and q. For consistency with PKCS #1 v2.0, however, the first two primes p and q are treated separately from the additional primes.",
      "ja": "注意。ステップ2.Bは、1つのpとqの順序を逆にすることを提供、単一ループのように書き換えることができます。 PKCS＃1 V2.0との整合性のために、しかし、最初の二つの素数pおよびqは、追加の素数とは別に処理されます。"
    },
    {
      "indent": 0,
      "text": "5.2.2 RSAVP1",
      "section_title": true,
      "ja": "5.2.2 RSAVP1"
    },
    {
      "indent": 3,
      "text": "RSAVP1 ((n, e), s)",
      "ja": "RSAVP1（（N、E）、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key s signature representative, an integer between 0 and n - 1",
      "ja": "入力：（N、e）はRSA公開鍵の署名を表す、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n - 1",
      "ja": "出力：Mメッセージ代表、0とnの間の整数 -  1"
    },
    {
      "indent": 3,
      "text": "Error: \"signature representative out of range\"",
      "ja": "エラー：「範囲外の署名代表」"
    },
    {
      "indent": 3,
      "text": "Assumption: RSA public key (n, e) is valid",
      "ja": "アサンプション：RSA公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the signature representative s is not between 0 and n - 1, output \"signature representative out of range\" and stop.",
      "ja": "1.署名代表sは0とnの間にない場合は - 、1出力「範囲外署名代表」と停止。"
    },
    {
      "indent": 3,
      "text": "2. Let m = s^e mod n.",
      "section_title": true,
      "ja": "2.メートル= S ^ E mod nをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "section_title": true,
      "ja": "3.出力メートル。"
    },
    {
      "indent": 0,
      "text": "6. Overview of schemes",
      "section_title": true,
      "ja": "スキームの概要6."
    },
    {
      "indent": 3,
      "text": "A scheme combines cryptographic primitives and other techniques to achieve a particular security goal. Two types of scheme are specified in this document: encryption schemes and signature schemes with appendix.",
      "ja": "スキームは、特定のセキュリティ目標を達成するために暗号プリミティブおよび他の技術を兼ね備えています。スキームの2種類が、この文書で指定されています。暗号化方式と署名方式を付録に。"
    },
    {
      "indent": 3,
      "text": "The schemes specified in this document are limited in scope in that their operations consist only of steps to process data with an RSA public or private key, and do not include steps for obtaining or validating the key. Thus, in addition to the scheme operations, an application will typically include key management operations by which parties may select RSA public and private keys for a scheme operation. The specific additional operations and other details are outside the scope of this document.",
      "ja": "この文書で指定されたスキームは、その操作のみRSA公開鍵または秘密鍵でデータを処理するためのステップで構成されていることに範囲が限定されており、取得またはキーを検証するための手順が含まれていません。このように、制度の運用に加えて、アプリケーションは通常、当事者がスキームの操作のためのRSA公開鍵と秘密鍵を選択することができることにより、キー管理操作が含まれます。固有の追加操作やその他の詳細は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "As was the case for the cryptographic primitives (Section 5), the specifications of scheme operations assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid. The behavior of an implementation is thus unspecified when a key is invalid. The impact of such unspecified behavior depends on the application. Possible means of addressing key validation include explicit key validation by the application; key validation within the public-key infrastructure; and assignment of liability for operations performed with an invalid key to the party who generated the key.",
      "ja": "暗号プリミティブ（セクション5）の場合と同様に、スキーム動作の仕様は特定の条件がRSA公開鍵と秘密鍵が有効であること、特に、入力で満たされていると仮定する。キーが無効であるとき、実装の振る舞いは、このように指定されていません。不特定の行動の影響は、アプリケーションによって異なります。キーの検証に取り組むの可能な手段は、アプリケーションによる明示的なキーの検証が含まれます。公開鍵インフラストラクチャ内のキーの検証。そして、キーを生成した当事者に無効なキーで実行された操作のための責任の割り当て。"
    },
    {
      "indent": 3,
      "text": "A generally good cryptographic practice is to employ a given RSA key pair in only one scheme. This avoids the risk that vulnerability in one scheme may compromise the security of the other, and may be essential to maintain provable security. While RSAES-PKCS1-v1_5 (Section 7.2) and RSASSA-PKCS1-v1_5 (Section 8.2) have traditionally been employed together without any known bad interactions (indeed, this is the model introduced by PKCS #1 v1.5), such a combined use of an RSA key pair is not recommended for new applications.",
      "ja": "一般的に良い暗号プラクティスは、一つだけの方式で与えられたRSAキーのペアを使用することです。これは、1つの方式の脆弱性は、他のセキュリティを損なう可能性があり、かつ証明可能安全性を維持するために不可欠かもしれないリスクを回避することができます。 RSAES-PKCS1-v1_5の（セクション7.2）とRSASSA-PKCS1-v1_5の（セクション8.2）は、伝統的に、任意の既知の不良な相互作用（実際、これは、PKCS＃1 V1.5によって導入されたモデルである）ことなく、一緒に使用されてきたが、そのような組み合わせRSA鍵ペアを使用することは、新しいアプリケーションのために推奨されていません。"
    },
    {
      "indent": 3,
      "text": "To illustrate the risks related to the employment of an RSA key pair in more than one scheme, suppose an RSA key pair is employed in both RSAES-OAEP (Section 7.1) and RSAES-PKCS1-v1_5. Although RSAES-OAEP by itself would resist attack, an opponent might be able to exploit a weakness in the implementation of RSAES-PKCS1-v1_5 to recover messages encrypted with either scheme. As another example, suppose an RSA key pair is employed in both RSASSA-PSS (Section 8.1) and RSASSA-PKCS1-v1_5. Then the security proof for RSASSA-PSS would no longer be sufficient since the proof does not account for the possibility that signatures might be generated with a second scheme. Similar considerations may apply if an RSA key pair is employed in one of the schemes defined here and in a variant defined elsewhere.",
      "ja": "以上のスキームにおけるRSA鍵ペアの使用に関連するリスクを説明するために、RSA鍵ペアはRSAES-OAEP（セクション7.1）及びRSAES-PKCS1-v1_5の両方で使用されると仮定する。それ自体でRSAES-OAEPが攻撃に抵抗するだろうが、相手はどちらかの方式で暗号化されたメッセージを回復するRSAES-PKCS1-v1_5のの実装の弱点を悪用することができるかもしれません。別の例として、RSA鍵ペアはRSASSA-PSS（セクション8.1）とRSASSA-PKCS1-v1_5の両方で使用されると仮定する。証明は署名が第2の方式で生成されるかもしれない可能性を考慮していないので、次にRSASSA-PSSのセキュリティ証明は、もはや十分ではないだろう。 RSA鍵ペアは、ここで定義されたスキームの一つにし、他の場所で定義されたバリアントで採用されている場合も同様の考察が適用される場合があります。"
    },
    {
      "indent": 0,
      "text": "7. Encryption schemes",
      "section_title": true,
      "ja": "7.暗号化方式"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an encryption scheme consists of an encryption operation and a decryption operation, where the encryption operation produces a ciphertext from a message with a recipient's RSA public key, and the decryption operation recovers the message from the ciphertext with the recipient's corresponding RSA private key.",
      "ja": "このドキュメントの目的のために、暗号化方式は、暗号化操作は、受信者のRSA公開鍵でメッセージから暗号文を生成した暗号化操作と復号化操作、で構成され、復号化操作は、受信者と暗号文からのメッセージを回復しますRSA秘密鍵に対応します。"
    },
    {
      "indent": 3,
      "text": "An encryption scheme can be employed in a variety of applications. A typical application is a key establishment protocol, where the message contains key material to be delivered confidentially from one party to another. For instance, PKCS #7 [45] employs such a protocol to deliver a content-encryption key from a sender to a recipient; the encryption schemes defined here would be suitable key-encryption algorithms in that context.",
      "ja": "暗号化方式は、種々の用途に使用することができます。典型的なアプリケーションは、メッセージが別の関係者から秘密に配信されるキー材料を含む鍵確立プロトコルです。例えば、PKCS＃7 [45]は送信者から受信者へコンテンツ暗号化キーを提供するためにそのようなプロトコルを採用し、ここで定義された暗号化方式は、そのコンテキストに適した鍵暗号化アルゴリズムになります。"
    },
    {
      "indent": 3,
      "text": "Two encryption schemes are specified in this document: RSAES-OAEP and RSAES-PKCS1-v1_5. RSAES-OAEP is recommended for new applications; RSAES-PKCS1-v1_5 is included only for compatibility with existing applications, and is not recommended for new applications.",
      "ja": "2つの暗号化方式は、この文書で指定されていますRSAES-OAEPおよびRSAES-PKCS1-v1_5のを。 RSAES-OAEPは、新しいアプリケーションのために推奨されます。 RSAES-PKCS1-v1_5のは、既存のアプリケーションとの互換性のために含まれ、そして新しいアプリケーションのために推奨されていません。"
    },
    {
      "indent": 3,
      "text": "The encryption schemes given here follow a general model similar to that employed in IEEE Std 1363-2000 [26], combining encryption and decryption primitives with an encoding method for encryption. The encryption operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. An encryption primitive is applied to the message representative to produce the ciphertext. Reversing this, the decryption operations apply a decryption primitive to the ciphertext to recover a message representative, which is then converted to an octet string encoded message. A message decoding operation is applied to the encoded message to recover the message and verify the correctness of the decryption.",
      "ja": "ここで所定の暗号化方式は、暗号化のための符号化方式で暗号化と復号化プリミティブを組み合わせ、IEEE STD 1363から2000 [26]で用いたものと同様の一般的なモデルに従います。暗号化操作は、次に整数を表すメッセージに変換され、エンコードされたメッセージを生成するメッセージに、メッセージ符号化演算を適用します。プリミティブ暗号化は、暗号文を生成することを表すメッセージに適用されます。この反転、復号動作は、次にオクテットストリング符号化されたメッセージに変換されたメッセージ代表を回復する暗号文にプリミティブ復号化を適用します。メッセージ復号動作は、メッセージを復元および復号の正当性を検証するために符号化されたメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": "To avoid implementation weaknesses related to the way errors are handled within the decoding operation (see [6] and [36]), the encoding and decoding operations for RSAES-OAEP and RSAES-PKCS1-v1_5 are embedded in the specifications of the respective encryption schemes rather than defined in separate specifications. Both encryption schemes are compatible with the corresponding schemes in PKCS #1 v2.0.",
      "ja": "エラーが復号動作内で処理される方法に関連する実装の弱点を回避するために、RSAES-OAEP及びRSAES-PKCS1-v1_5のための符号化及び復号化操作は、それぞれの暗号化の仕様に埋め込まれている（[6]、[36]参照）スキームではなく、個別の仕様で定義されています。両方の暗号化方式は、PKCS＃1 V2.0で対応する方式と互換性があります。"
    },
    {
      "indent": 0,
      "text": "7.1 RSAES-OAEP",
      "section_title": true,
      "ja": "7.1 RSAES-OAEP"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME-OAEP encoding method (step 1.b in Section 7.1.1 and step 3 in Section 7.1.2). EME-OAEP is based on Bellare and Rogaway's Optimal Asymmetric Encryption scheme [3]. (OAEP stands for \"Optimal Asymmetric Encryption Padding.\"). It is compatible with the IFES scheme defined in IEEE Std 1363-2000 [26], where the encryption and decryption primitives are IFEP-RSA and IFDP-RSA and the message encoding method is EME-OAEP. RSAES-OAEP can operate on messages of length up to k - 2hLen - 2 octets, where hLen is the length of the output from the underlying hash function and k is the length in octets of the recipient's RSA modulus.",
      "ja": "RSAES-OAEPは、EME-OAEP符号化方法（セクション7.1.1及び7.1.2項のステップ3におけるステップ1.B）でRSAEPとRSADPプリミティブ（セクション5.1.1と5.1.2）を組み合わせました。 EME-OAEPは、[3]ベラーとRogawayの最適な非対称暗号方式に基づいています。 （OAEPの略、「最適な非対称暗号パディング。」）。これは、暗号化と復号化プリミティブはIFEP-RSAおよびIFDP-RSAであり、メッセージの符号化方法は、EME-OAEPであるIEEE STD 1363から2000 [26]で定義されIFES方式と互換性があります。 2hLenを -   - さhLenは、基礎となるハッシュ関数と、Kの出力の長さは、受信者のRSAモジュラスのオクテットの長さである2つのオクテット、RSAES-OAEPは、k個までの長さのメッセージ上で動作することができます。"
    },
    {
      "indent": 3,
      "text": "Assuming that computing e-th roots modulo n is infeasible and the mask generation function in RSAES-OAEP has appropriate properties, RSAES-OAEP is semantically secure against adaptive chosen-ciphertext attacks. This assurance is provable in the sense that the difficulty of breaking RSAES-OAEP can be directly related to the difficulty of inverting the RSA function, provided that the mask generation function is viewed as a black box or random oracle; see [21] and the note below for further discussion.",
      "ja": "電子番目の根をモジュロNを計算することは実行不可能であるとRSAES-OAEPのマスク生成機能は、適切な特性を有する、RSAES-OAEPは、適応的選択暗号文攻撃に対する意味的に安全であると仮定。この保証はRSAES-OAEPを破壊することの難しさは、直接RSA関数を反転することの難しさに関係することができるという意味で、マスク生成関数をブラックボックス又はランダムオラクルとみなされることが証明可能に設けられています。 [21]と、さらなる議論のために、以下の注意事項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Both the encryption and the decryption operations of RSAES-OAEP take the value of a label L as input. In this version of PKCS #1, L is the empty string; other uses of the label are outside the scope of this document. See Appendix A.2.1 for the relevant ASN.1 syntax.",
      "ja": "RSAES-OAEPの暗号化と復号化の両方の操作は、入力としてラベルLの値をとります。 PKCS＃1のこのバージョンでは、Lは、空の文字列です。ラベルの他の用途は、この文書の範囲外です。関連するASN.1構文については、付録A.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP is parameterized by the choice of hash function and mask generation function. This choice should be fixed for a given RSA key. Suggested hash and mask generation functions are given in Appendix B.",
      "ja": "RSAES-OAEPはハッシュ関数とマスク生成関数の選択によってパラメータ化されます。この選択は、与えられたRSAキーのために固定されなければなりません。提案ハッシュとマスク生成機能は、付録Bに記載されています"
    },
    {
      "indent": 3,
      "text": "Note. Recent results have helpfully clarified the security properties of the OAEP encoding method [3] (roughly the procedure described in step 1.b in Section 7.1.1). The background is as follows. In 1994, Bellare and Rogaway [3] introduced a security concept that they denoted plaintext awareness (PA94). They proved that if a deterministic public-key encryption primitive (e.g., RSAEP) is hard to invert without the private key, then the corresponding OAEP-based encryption scheme is plaintext-aware (in the random oracle model), meaning roughly that an adversary cannot produce a valid ciphertext without actually \"knowing\" the underlying plaintext. Plaintext awareness of an encryption scheme is closely related to the resistance of the scheme against chosen-ciphertext attacks. In such attacks, an adversary is given the opportunity to send queries to an oracle simulating the decryption primitive. Using the results of these queries, the adversary attempts to decrypt a challenge ciphertext.",
      "ja": "注意。最近の結果は、親切OAEP符号化方式のセキュリティの特性を明らかにした[3]（おおよそセクション7.1.1のステップ1.Bに記載の手順）。次のような背景があります。 1994年には、ベラーとRogaway [3]彼らは平文意識（PA94）で示さセキュリティコンセプトを導入しました。彼らは、敵対することを大まかに意味、原始的な決定論、公開鍵暗号は、（例えば、RSAEP）は、秘密鍵なしで反転させることは困難である場合には、対応するOAEPベースの暗号化方式は（ランダムオラクルモデルで）平文を意識していることを証明しました実際に基礎となる平文を「知っている」せずに、有効な暗号文を生成することはできません。暗号化方式の平文意識は選択暗号文攻撃に対してスキームの耐性に密接に関連しています。このような攻撃では、攻撃者は、原始的な復号化をシミュレートするオラクルにクエリを送信する機会が与えられます。これらのクエリの結果を使用して、敵がチャレンジ暗号文を解読しようとします。"
    },
    {
      "indent": 3,
      "text": "However, there are two flavors of chosen-ciphertext attacks, and PA94 implies security against only one of them. The difference relies on what the adversary is allowed to do after she is given the challenge ciphertext. The indifferent attack scenario (denoted CCA1) does not admit any queries to the decryption oracle after the adversary is given the challenge ciphertext, whereas the adaptive scenario (denoted CCA2) does (except that the decryption oracle refuses to decrypt the challenge ciphertext once it is published). In 1998, Bellare and Rogaway, together with Desai and Pointcheval [2], came up with a new, stronger notion of plaintext awareness (PA98) that does imply security against CCA2.",
      "ja": "しかし、そこに選択暗号文攻撃の2種類があり、PA94は、いずれか一方のみに対してセキュリティを意味します。違いは、敵対者は、彼女がチャレンジ暗号文が与えられた後行うことが許されているものに依存しています。敵がチャレンジ暗号文が与えられた後、無関心の攻撃シナリオ（表記CCA1）は、適応シナリオ（表記CCA2）は復号オラクルはそれが一度チャレンジ暗号文を解読することを拒否していることを除いて（ないのに対し、復号オラクルへのクエリを認めていません公表）。 1998年には、一緒にデサイとPointchevalとベラーとRogawayは、[2]、CCA2に対するセキュリティを意味するものではない平文意識の新しい、より強力な概念（PA98）を思い付きました。"
    },
    {
      "indent": 3,
      "text": "To summarize, there have been two potential sources for misconception: that PA94 and PA98 are equivalent concepts; or that CCA1 and CCA2 are equivalent concepts. Either assumption leads to the conclusion that the Bellare-Rogaway paper implies security of OAEP against CCA2, which it does not.",
      "ja": "要約すると、誤解のための2つの潜在的な原因があった：PA94およびPA98は同等の概念であること。またはそのCCA1およびCCA2は同等の概念です。どちらの仮定はそうでないベラー-Rogaway紙がCCA2に対してOAEPの安全性を暗示という結論を導きます。"
    },
    {
      "indent": 3,
      "text": "(Footnote: It might be fair to mention that PKCS #1 v2.0 cites [3] and claims that \"a chosen ciphertext attack is ineffective against a plaintext-aware encryption scheme such as RSAES-OAEP\" without specifying the kind of plaintext awareness or chosen ciphertext attack considered.)",
      "ja": "（脚注：PKCS＃1 v2.0のは、引用していることに言及し、公正であるかもしれない[3]とは、平文の意識の種類を指定せずに「選択暗号文攻撃は、このようなRSAES-OAEPとして平文対応の暗号化方式に対しては無効である」と主張しますまたは選択暗号文攻撃は考えました。）"
    },
    {
      "indent": 3,
      "text": "OAEP has never been proven secure against CCA2; in fact, Victor Shoup [48] has demonstrated that such a proof does not exist in the general case. Put briefly, Shoup showed that an adversary in the CCA2 scenario who knows how to partially invert the encryption primitive but does not know how to invert it completely may well be able to break the scheme. For example, one may imagine an attacker who is able to break RSAES-OAEP if she knows how to recover all but the first 20 bytes of a random integer encrypted with RSAEP. Such an attacker does not need to be able to fully invert RSAEP, because she does not use the first 20 octets in her attack.",
      "ja": "OAEPはCCA2に対して安全で証明されたことがありません。実際には、ビクター・シャウプ[48]そのような証拠は、一般的な場合には存在しないことを実証しました。簡単に言えば、シャウプは、部分的に原始的な暗号化を反転させる方法を知っているが、それを完全に反転する方法を知りませんCCA2のシナリオで敵がうまくスキームを破ることができるかもしれことを示しました。例えば、一つは、彼女はすべてが、RSAEPで暗号化されたランダムな整数の最初の20のバイトを回復する方法を知っている場合はRSAES-OAEPを破ることが可能である攻撃者を想像します。彼女は攻撃の最初の20個のオクテットを使用していないため、このような攻撃者は、完全にRSAEPを反転することができるようにする必要はありません。"
    },
    {
      "indent": 3,
      "text": "Still, RSAES-OAEP is secure against CCA2, which was proved by Fujisaki, Okamoto, Pointcheval, and Stern [21] shortly after the announcement of Shoup's result. Using clever lattice reduction techniques, they managed to show how to invert RSAEP completely given a sufficiently large part of the pre-image. This observation, combined with a proof that OAEP is secure against CCA2 if the underlying encryption primitive is hard to partially invert, fills the gap between what Bellare and Rogaway proved about RSAES-OAEP and what some may have believed that they proved. Somewhat paradoxically, we are hence saved by an ostensible weakness in RSAEP (i.e., the whole inverse can be deduced from parts of it).",
      "ja": "それでも、RSAES-OAEPはまもなくシャウプの結果の発表後藤崎、岡本、Pointcheval、とスターン[21]により証明されたCCA2、に対して安全です。巧妙な格子縮小技術を使用して、彼らは完全に前の画像の十分に大きな部分与えRSAEPを反転する方法を示すことができました。 OAEPプリミティブ基本暗号化が部分的に反転しにくい場合CCA2に対して安全であることの証明と組み合わせるこの観察は、ベラーとRogawayはRSAES-OAEPとどのようないくつかは、彼らが証明すると考えられている可能性について証明するものの間のギャップを埋めます。いくらか逆説的に、我々はしたがってRSAEPに表向き弱によって保存される（すなわち、全体の逆は、それの部分から推定することができます）。"
    },
    {
      "indent": 3,
      "text": "Unfortunately however, the security reduction is not efficient for concrete parameters. While the proof successfully relates an adversary Adv against the CCA2 security of RSAES-OAEP to an algorithm Inv inverting RSA, the probability of success for Inv is only approximately \\epsilon^2 / 2^18, where \\epsilon is the probability of success for Adv.",
      "ja": "残念ながらしかし、セキュリティの低下は、具体的なパラメータのための効率的ではありません。証拠が正常にRSAを反転InvのアルゴリズムにRSAES-OAEPのCCA2安全保障に対する敵対前売を関連するが、Invのための成功の確率は\\イプシロンはの成功の確率はわずかに約\\イプシロン^ 2/2 ^ 18であり、前売。"
    },
    {
      "indent": 3,
      "text": "(Footnote: In [21] the probability of success for the inverter was \\epsilon^2 / 4. The additional factor 1 / 2^16 is due to the eight fixed zero bits at the beginning of the encoded message EM, which are not present in the variant of OAEP considered in [21] (Inv must apply Adv twice to invert RSA, and each application corresponds to a factor 1 / 2^8).)",
      "ja": "（脚注：[21]において、インバータの成功の確率は\\イプシロン^ 2/4の追加の因子1/2 ^ 16ではない符号化されたメッセージEMの先頭に8ビットの固定ゼロに起因するました[21]において考慮OAEPの変異体中に存在する（INVは二回RSAを反転する広告主を適用する必要があり、各アプリケーションは、係数1/2 ^ 8に対応）。）"
    },
    {
      "indent": 3,
      "text": "In addition, the running time for Inv is approximately t^2, where t is the running time of the adversary. The consequence is that we cannot exclude the possibility that attacking RSAES-OAEP is considerably easier than inverting RSA for concrete parameters. Still, the existence of a security proof provides some assurance that the RSAES-OAEP construction is sounder than ad hoc constructions such as RSAES-PKCS1-v1_5.",
      "ja": "また、Invのための実行時間は約tは敵の実行時間であるT ^ 2です。その結果、我々はRSAES-OAEPを攻撃することは、具体的なパラメータのためにRSAを反転さよりもかなり容易であるという可能性を排除できないということです。それでも、安全性証明の存在はRSAES-OAEPの建設は、RSAES-PKCS1-v1_5のアドホックの構造よりも健全であることを、いくつかの保証を提供します。"
    },
    {
      "indent": 3,
      "text": "Hybrid encryption schemes based on the RSA-KEM key encapsulation paradigm offer tight proofs of security directly applicable to concrete parameters; see [30] for discussion. Future versions of PKCS #1 may specify schemes based on this paradigm.",
      "ja": "RSA-KEM鍵カプセル化パラダイムに基づいたハイブリッド暗号化方式は、具体的なパラメータに直接適用可能なセキュリティのタイトな証拠を提供します。議論のための[30]を参照してください。 PKCS＃1の将来のバージョンでは、このパラダイムに基づくスキームを指定することもできます。"
    },
    {
      "indent": 0,
      "text": "7.1.1 Encryption operation",
      "section_title": true,
      "ja": "7.1.1暗号化の操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-ENCRYPT ((n, e), M, L)",
      "ja": "RSAES-OAEP-ENCRYPT（（N、E）、M、L）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octets of the hash function output) MGF mask generation function",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示す）MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key (k denotes the length in octets of the RSA modulus n) M message to be encrypted, an octet string of length mLen, where mLen <= k - 2hLen - 2 L optional label to be associated with the message; the default value for L, if L is not provided, is the empty string",
      "ja": "入力： -  2hLen  -  2 Lオプションのラベルに（N、E）受信者のRSA公開鍵は暗号化されるMメッセージ、長MLENのオクテットストリング、MLEN <= k個（kはRSAモジュラスNのオクテットの長さを示します）メッセージに関連付けられます。 Lが提供されていない場合はLの既定値は、空の文字列であります"
    },
    {
      "indent": 3,
      "text": "Output: C ciphertext, an octet string of length k",
      "ja": "出力：C暗号文、長さkのオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"label too long\"",
      "ja": "エラー：「メッセージが長すぎます」。 「あまりにも長いラベル」"
    },
    {
      "indent": 3,
      "text": "Assumption: RSA public key (n, e) is valid",
      "ja": "アサンプション：RSA公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking:",
      "section_title": true,
      "ja": "1.長さのチェック："
    },
    {
      "indent": 6,
      "text": "a. If the length of L is greater than the input limitation for the hash function (2^61 - 1 octets for SHA-1), output \"label too long\" and stop.",
      "ja": "A。 Lの長さは、ハッシュ関数の入力制限よりも大きい場合には（2 ^ 61  -  SHA-1の1オクテット）、出力「長すぎるラベル」と停止。"
    },
    {
      "indent": 6,
      "text": "b. If mLen > k - 2hLen - 2, output \"message too long\" and stop.",
      "ja": "B。 2hLen  -   -  MLEN> kであれば2、出力 \"のメッセージが長すぎる\" と止めます。"
    },
    {
      "indent": 3,
      "text": "2. EME-OAEP encoding (see Figure 1 below):",
      "section_title": true,
      "ja": "2. EME-OAEP符号化（以下、図1を参照）。"
    },
    {
      "indent": 6,
      "text": "a. If the label L is not provided, let L be the empty string. Let lHash = Hash(L), an octet string of length hLen (see the note below).",
      "ja": "A。ラベルLが提供されていない場合、Lは、空の文字列とします。してみましょうlHash =ハッシュ（L）、長さhLenのオクテット文字列（下記の注を参照）。"
    },
    {
      "indent": 6,
      "text": "b. Generate an octet string PS consisting of k - mLen - 2hLen - 2 zero octets. The length of PS may be zero.",
      "ja": "B。 MLEN  -   -  2hLen  -  2ゼロオクテットKからなるオクテット列PSを生成します。 PSの長さはゼロであってもよいです。"
    },
    {
      "indent": 6,
      "text": "c. Concatenate lHash, PS, a single octet with hexadecimal value 0x01, and the message M to form a data block DB of length k - hLen - 1 octets as",
      "ja": "C。さhLen  -   -  1つのオクテットとして連結しlHash、PS、16進数の値0x01を有する単一のオクテット、およびメッセージMは長さkのデータブロックDBを形成します"
    },
    {
      "indent": 12,
      "text": "DB = lHash || PS || 0x01 || M.",
      "ja": "DB = lHash || PS || 0x01の|| M."
    },
    {
      "indent": 6,
      "text": "d. Generate a random octet string seed of length hLen.",
      "ja": "D。長さhLenのランダムオクテット文字列の種を生成します。"
    },
    {
      "indent": 6,
      "text": "e. Let dbMask = MGF(seed, k - hLen - 1).",
      "ja": "電子。ましょうdbMask = MGF（種子、K  - さhLen  -  1）。"
    },
    {
      "indent": 6,
      "text": "f. Let maskedDB = DB \\xor dbMask.",
      "ja": "F。 maskedDB = DB \\ XOR dbMaskをしてみましょう。"
    },
    {
      "indent": 6,
      "text": "g. Let seedMask = MGF(maskedDB, hLen).",
      "ja": "グラム。 seedMask = MGF（maskedDB、さhLen）をしてみましょう。"
    },
    {
      "indent": 6,
      "text": "h. Let maskedSeed = seed \\xor seedMask.",
      "ja": "時間。 maskedSeed =シード\\の排他的論理和seedMaskをしてみましょう。"
    },
    {
      "indent": 6,
      "text": "i. Concatenate a single octet with hexadecimal value 0x00, maskedSeed, and maskedDB to form an encoded message EM of length k octets as",
      "ja": "私。 16進数の値0x00を有する単一のオクテットを連結し、maskedSeed、及びmaskedDBは、長さKオクテットの符号化されたメッセージEMなどを形成します"
    },
    {
      "indent": 12,
      "text": "EM = 0x00 || maskedSeed || maskedDB.",
      "ja": "EMは$ 00を= || maskedSeed || maskedDB。"
    },
    {
      "indent": 3,
      "text": "3. RSA encryption:",
      "section_title": true,
      "ja": "3. RSA暗号化："
    },
    {
      "indent": 6,
      "text": "a. Convert the encoded message EM to an integer message representative m (see Section 4.2):",
      "ja": "A。整数を表すメッセージmにコード化されたメッセージEMを変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "m = OS2IP (EM).",
      "ja": "M = OS2IP（MS）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA public key (n, e) and the message representative m to produce an integer ciphertext representative c:",
      "ja": "B。 RSAEP暗号化は、RSA公開鍵（N、e）及び整数暗号文代表cを生成することを表すメッセージmに（セクション5.1.1）プリミティブ適用されます。"
    },
    {
      "indent": 12,
      "text": "c = RSAEP ((n, e), m).",
      "ja": "C = RSAEP（（N、E）、M）。"
    },
    {
      "indent": 6,
      "text": "c. Convert the ciphertext representative c to a ciphertext C of length k octets (see Section 4.1):",
      "ja": "C。長さKオクテット（セクション4.1を参照）の暗号文Cに暗号文代表cを変換します。"
    },
    {
      "indent": 12,
      "text": "C = I2OSP (c, k).",
      "ja": "C = I2OSP（C、K）。"
    },
    {
      "indent": 3,
      "text": "4. Output the ciphertext C.",
      "section_title": true,
      "ja": "4.出力暗号文C."
    },
    {
      "indent": 3,
      "text": "Note. If L is the empty string, the corresponding hash value lHash has the following hexadecimal representation for different choices of Hash:",
      "ja": "注意。 Lが空の文字列である場合、対応するハッシュ値lHashハッシュの異なる選択肢については、次の16進表現を有します。"
    },
    {
      "indent": 3,
      "text": "SHA-1: (0x)da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709 SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c a495991b 7852b855 SHA-384: (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743 4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b SHA-512: (0x)cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc 83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f 63b931bd 47417a81 a538327a f927da3e",
      "ja": "SHA-1：（0X）da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709 SHA-256：（0X）e3b0c442 98fc1c14 9afbf4c8 996fb924 27ae41e4 649b934c a495991b 7852b855 SHA-384：（0X）38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743 4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b SHA-512： （0X）cf83e135 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc 83f4a921 d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f 63b931bd 47417a81 a538327a f927da3e"
    },
    {
      "indent": 3,
      "text": "__________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                          +----------+---------+-------+\n                     DB = |  lHash   |    PS   |   M   |\n                          +----------+---------+-------+\n                                         |\n               +----------+              V\n               |   seed   |--> MGF ---> xor\n               +----------+              |\n                     |                   |\n            +--+     V                   |\n            |00|    xor <----- MGF <-----|\n            +--+     |                   |\n              |      |                   |\n              V      V                   V\n            +--+----------+----------------------------+\n      EM =  |00|maskedSeed|          maskedDB          |\n            +--+----------+----------------------------+\n__________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1: EME-OAEP encoding operation. lHash is the hash of the optional label L. Decoding operation follows reverse steps to recover M and verify lHash and PS.",
      "ja": "図1：EME-OAEP符号化操作。 lHashはL.復号動作がMを回復し、lHashとPSを確認するための手順を逆に次のオプションのラベルのハッシュです。"
    },
    {
      "indent": 0,
      "text": "7.1.2 Decryption operation",
      "section_title": true,
      "ja": "7.1.2復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-DECRYPT (K, C, L)",
      "ja": "RSAES-OAEP-DECRYPT（K、C、L）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octets of the hash function output) MGF mask generation function",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示す）MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key (k denotes the length in octets of the RSA modulus n) C ciphertext to be decrypted, an octet string of length k, where k = 2hLen + 2 L optional label whose association with the message is to be verified; the default value for L, if L is not provided, is the empty string",
      "ja": "入力：K受信者のRSA秘密鍵（kはRSAモジュラスNのオクテットの長さを表す）復号化するC暗号文、長さkのオクテットストリング、関連メッセージであることであるK = 2hLen + 2 Lオプションラベル検証; Lが提供されていない場合はLの既定値は、空の文字列であります"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length mLen, where mLen <= k - 2hLen - 2",
      "ja": "出力：Mメッセージ、MLEN <= kの長MLENのオクテットストリング -  2  -  2hLen"
    },
    {
      "indent": 3,
      "text": "Error: \"decryption error\"",
      "ja": "エラー：「解読エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking:",
      "section_title": true,
      "ja": "1.長さのチェック："
    },
    {
      "indent": 6,
      "text": "a. If the length of L is greater than the input limitation for the hash function (2^61 - 1 octets for SHA-1), output \"decryption error\" and stop.",
      "ja": "A。 Lの長さは、ハッシュ関数の入力制限よりも大きい場合には（2 ^ 61  -  SHA-1の1オクテット）、出力「復号エラー」と止めます。"
    },
    {
      "indent": 6,
      "text": "b. If the length of the ciphertext C is not k octets, output \"decryption error\" and stop.",
      "ja": "B。暗号文Cの長さがオクテットをK、出力「復号エラー」と停止されていない場合。"
    },
    {
      "indent": 6,
      "text": "c. If k < 2hLen + 2, output \"decryption error\" and stop.",
      "ja": "C。 K <2hLen + 2、出力 \"解読エラー\" の場合と停止します。"
    },
    {
      "indent": 3,
      "text": "2. RSA decryption:",
      "section_title": true,
      "ja": "2. RSA復号："
    },
    {
      "indent": 6,
      "text": "a. Convert the ciphertext C to an integer ciphertext representative c (see Section 4.2):",
      "ja": "A。整数暗号文代表cに暗号文Cに変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "c = OS2IP (C).",
      "ja": "C = OS2IP（C）。"
    },
    {
      "indent": 9,
      "text": "b. Apply the RSADP decryption primitive (Section 5.1.2) to the RSA private key K and the ciphertext representative c to produce an integer message representative m:",
      "ja": "B。 RSA秘密鍵KにプリミティブRSADP復号（セクション5.1.2）と整数を表すメッセージmを生成する暗号文代表cを適用します。"
    },
    {
      "indent": 12,
      "text": "m = RSADP (K, c).",
      "ja": "M = RSADP（K、C）。"
    },
    {
      "indent": 9,
      "text": "If RSADP outputs \"ciphertext representative out of range\" (meaning that c >= n), output \"decryption error\" and stop.",
      "ja": "RSADPが「範囲外の暗号文代表」を出力する場合（その意味> = N C）、出力「復号エラー」と止めます。"
    },
    {
      "indent": 6,
      "text": "c. Convert the message representative m to an encoded message EM of length k octets (see Section 4.1):",
      "ja": "C。長さKオクテット（セクション4.1を参照）の符号化されたメッセージEMを表すメッセージmを変換します。"
    },
    {
      "indent": 12,
      "text": "EM = I2OSP (m, k).",
      "ja": "I2OSP EM =（MのK）。"
    },
    {
      "indent": 3,
      "text": "3. EME-OAEP decoding:",
      "section_title": true,
      "ja": "3. STAND-OAEPデコード："
    },
    {
      "indent": 6,
      "text": "a. If the label L is not provided, let L be the empty string. Let lHash = Hash(L), an octet string of length hLen (see the note in Section 7.1.1).",
      "ja": "A。ラベルLが提供されていない場合、Lは、空の文字列とします。してみましょうlHash =ハッシュ（L）、長さhLenのオクテット文字列（7.1.1項の注を参照）。"
    },
    {
      "indent": 6,
      "text": "b. Separate the encoded message EM into a single octet Y, an octet string maskedSeed of length hLen, and an octet string maskedDB of length k - hLen - 1 as",
      "ja": "B。 -  1つのオクテットY、長さhLenのオクテットストリングmaskedSeed、にエンコードされたメッセージEMを分離し、長さkのオクテットストリングmaskedDB  - さhLen"
    },
    {
      "indent": 12,
      "text": "EM = Y || maskedSeed || maskedDB.",
      "ja": "EM = Y || maskedSeed || maskedDB。"
    },
    {
      "indent": 6,
      "text": "c. Let seedMask = MGF(maskedDB, hLen).",
      "ja": "C。 seedMask = MGF（maskedDB、さhLen）をしてみましょう。"
    },
    {
      "indent": 6,
      "text": "d. Let seed = maskedSeed \\xor seedMask.",
      "ja": "D。シード= maskedSeed \\ XOR seedMaskをしてみましょう。"
    },
    {
      "indent": 6,
      "text": "e. Let dbMask = MGF(seed, k - hLen - 1).",
      "ja": "電子。ましょうdbMask = MGF（種子、K  - さhLen  -  1）。"
    },
    {
      "indent": 6,
      "text": "f. Let DB = maskedDB \\xor dbMask.",
      "ja": "F。 DB = maskedDB \\ XOR dbMaskをしてみましょう。"
    },
    {
      "indent": 6,
      "text": "g. Separate DB into an octet string lHash' of length hLen, a (possibly empty) padding string PS consisting of octets with hexadecimal value 0x00, and a message M as",
      "ja": "グラム。長さhLen 16進数の値0x00を持つオクテットからなる（おそらく空の）パディング列PS、メッセージMとしてのオクテット列lHash」に分離DB"
    },
    {
      "indent": 12,
      "text": "DB = lHash' || PS || 0x01 || M.",
      "ja": "DB = lHash」|| PS || 0x01の|| M."
    },
    {
      "indent": 9,
      "text": "If there is no octet with hexadecimal value 0x01 to separate PS from M, if lHash does not equal lHash', or if Y is nonzero, output \"decryption error\" and stop. (See the note below.)",
      "ja": "MからPSを分離する進値が0x01とはオクテットがない場合、lHashが等しくないlHashしない場合」、またはYがゼロ以外の場合、出力 『復号エラー』と止めます。 （下記の注を参照してください。）"
    },
    {
      "indent": 3,
      "text": "4. Output the message M.",
      "section_title": true,
      "ja": "4.出力メッセージM."
    },
    {
      "indent": 3,
      "text": "Note. Care must be taken to ensure that an opponent cannot distinguish the different error conditions in Step 3.g, whether by error message or timing, or, more generally, learn partial information about the encoded message EM. Otherwise an opponent may be able to obtain useful information about the decryption of the ciphertext C, leading to a chosen-ciphertext attack such as the one observed by Manger [36].",
      "ja": "注意。ケアは、より一般的には、エラー・メッセージまたはタイミング、または、によって、符号化されたメッセージのEMに関する部分的な情報を知るかどうかを相手が、ステップ3.gに異なるエラー条件を区別することができないことを保証するために注意しなければなりません。そうでなければ相手は、マネージャ[36]によって観察されたものとして選択暗号文攻撃に導く、暗号文Cの解読に関する有用な情報を得ることができるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.2 RSAES-PKCS1-v1_5",
      "section_title": true,
      "ja": "7.2 RSAES-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME-PKCS1-v1_5 encoding method (step 1 in Section 7.2.1 and step 3 in Section 7.2.2). It is mathematically equivalent to the encryption scheme in PKCS #1 v1.5. RSAES-PKCS1- v1_5 can operate on messages of length up to k - 11 octets (k is the octet length of the RSA modulus), although care should be taken to avoid certain attacks on low-exponent RSA due to Coppersmith, Franklin, Patarin, and Reiter when long messages are encrypted (see the third bullet in the notes below and [10]; [14] contains an improved attack). As a general rule, the use of this scheme for encrypting an arbitrary message, as opposed to a randomly generated key, is not recommended.",
      "ja": "RSAES-PKCS1-v1_5のは、EME-PKCS1-v1_5の符号化方法（7.2.1項及び第7.2.2項のステップ3の手順1）でRSAEPとRSADPプリミティブ（セクション5.1.1と5.1.2）を組み合わせました。これは、PKCS＃1 v1.5の中の暗号化方式と数学的に等価です。 RSAES-PKCS1- v1_5のは、k個までの長さのメッセージ上で動作することができる - 注意が原因銅細工、フランクリン、Patarinを低指数RSA上の特定の攻撃を避けるために注意しなければならないが、11個のオクテット（kはRSAモジュラスのオクテット長です）長いメッセージが暗号化されたとき、及びライター（下記ノートに第三弾を参照し、[10]、[14]改良された攻撃を含んでいます）。原則として、任意のメッセージを暗号化するためのこのスキームを使用するように、ランダムに生成されたキーとは対照的に、推奨されません。"
    },
    {
      "indent": 3,
      "text": "It is possible to generate valid RSAES-PKCS1-v1_5 ciphertexts without knowing the corresponding plaintexts, with a reasonable probability of success. This ability can be exploited in a chosen- ciphertext attack as shown in [6]. Therefore, if RSAES-PKCS1-v1_5 is to be used, certain easily implemented countermeasures should be taken to thwart the attack found in [6]. Typical examples include the addition of structure to the data to be encoded, rigorous checking of PKCS #1 v1.5 conformance (and other redundancy) in decrypted messages, and the consolidation of error messages in a client-server protocol based on PKCS #1 v1.5. These can all be effective countermeasures and do not involve changes to a PKCS #1 v1.5-based protocol. See [7] for a further discussion of these and other countermeasures. It has recently been shown that the security of the SSL/TLS handshake protocol [17], which uses RSAES-PKCS1-v1_5 and certain countermeasures, can be related to a variant of the RSA problem; see [32] for discussion.",
      "ja": "成功の合理的な確率で、対応する平文を知らなくても、有効なRSAES-PKCS1-v1_5の暗号文を生成することが可能です。 [6]に示すように、この能力はchosen-暗号文攻撃に利用することができます。 RSAES-PKCS1-v1_5のを使用する場合したがって、特定の容易に実現対策[6]に見られる攻撃を阻止するために取られるべきです。典型的な例は、符号化されるデータの構造のほか、復号化されたメッセージにPKCS＃1 V1.5適合性（及び他の冗長性）の厳密な検査、およびPKCS＃1に基づいて、クライアント・サーバ・プロトコルのエラー・メッセージの統合を含みますV1.5。これらはすべて、効果的な対策することができ、PKCS＃1 v1.5のベースのプロトコルへの変更を伴いません。これらおよびその他の対策の更なる議論については[7]を参照してください。最近RSAES-PKCS1-v1_5のおよび特定の対策を使用するSSL / TLSハンドシェイクプロトコル[17]のセキュリティは、RSA問題の変異体に関連することが示されています。議論のための[32]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note. The following passages describe some security recommendations pertaining to the use of RSAES-PKCS1-v1_5. Recommendations from version 1.5 of this document are included as well as new recommendations motivated by cryptanalytic advances made in the intervening years.",
      "ja": "注意。以下の節ではRSAES-PKCS1-v1_5の使用に関連するいくつかのセキュリティ勧告を記述する。このドキュメントのバージョン1.5からの勧告を介在年間に作られた暗号解読の進歩によって動機づけ新しい勧告だけでなく、含まれています。"
    },
    {
      "indent": 4,
      "text": "* It is recommended that the pseudorandom octets in step 2 in Section 7.2.1 be generated independently for each encryption process, especially if the same data is input to more than one encryption process. Haastad's results [24] are one motivation for this recommendation.",
      "ja": "*セクション7.2.1のステップ2において、擬似ランダムオクテットは、同じデータが複数の暗号化プロセスへの入力である場合は特に、各暗号化処理のために独立して生成することが推奨されます。 Haastadの結果[24]は、この勧告のための1つの動機です。"
    },
    {
      "indent": 4,
      "text": "* The padding string PS in step 2 in Section 7.2.1 is at least eight octets long, which is a security condition for public-key operations that makes it difficult for an attacker to recover data by trying all possible encryption blocks.",
      "ja": "*セクション7.2.1のステップ2でパディング文字列PSは、それが困難な攻撃者がすべての可能な暗号化ブロックを試みることによってデータを回復できるようになり、公開鍵操作のためのセキュリティ条件である、長い少なくとも8つのオクテットです。"
    },
    {
      "indent": 4,
      "text": "* The pseudorandom octets can also help thwart an attack due to Coppersmith et al. [10] (see [14] for an improvement of the attack) when the size of the message to be encrypted is kept small. The attack works on low-exponent RSA when similar messages are encrypted with the same RSA public key. More specifically, in one flavor of the attack, when two inputs to RSAEP agree on a large fraction of bits (8/9) and low-exponent RSA (e = 3) is used to encrypt both of them, it may be possible to recover both inputs with the attack. Another flavor of the attack is successful in decrypting a single ciphertext when a large fraction (2/3) of the input to RSAEP is already known. For typical applications, the message to be encrypted is short (e.g., a 128-bit symmetric key) so not enough information will be known or common between two messages to enable the attack. However, if a long message is encrypted, or if part of a message is known, then the attack may be a concern. In any case, the RSAES-OAEP scheme overcomes the attack.",
      "ja": "*擬似ランダムオクテットはまた、銅細工らによる攻撃を阻止することができます。暗号化されるメッセージのサイズが小さく維持される、[10]（攻撃の改善のための[14]を参照）。同様のメッセージが同じRSA公開鍵で暗号化されている場合、攻撃は、低指数RSA上で動作します。より具体的には、攻撃の1種のフレーバーで、RSAEPの2つの入力は、それらの両方を暗号化するために使用される（8/9）ビットの大部分に同意し、低指数RSA（E = 3）の場合、それが可能であってもよいです攻撃で両方の入力を回復します。攻撃のもう一つの味はRSAEPへの入力の大部分（2/3）が既にわかっている場合、単一の暗号文を解読することに成功しています。典型的な用途のために、暗号化されるメッセージが短い（例えば、128ビットの対称鍵）が十分な情報が攻撃を有効にするために、2つのメッセージ間で知られているか、または一般的であろう。しかし、もし長いメッセージは暗号化されている、またはメッセージの一部がわかっている場合、その攻撃が問題となる場合があります。いずれにせよ、RSAES-OAEP方式は、攻撃を克服します。"
    },
    {
      "indent": 0,
      "text": "7.2.1 Encryption operation",
      "section_title": true,
      "ja": "7.2.1暗号化の操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)",
      "ja": "RSAES-PKCS1-v1_5の暗号化（（N、E）、M）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key (k denotes the length in octets of the modulus n) M message to be encrypted, an octet string of length mLen, where mLen <= k - 11",
      "ja": "入力：（N、E）受信者のRSA公開鍵（kは係数nのオクテットの長さを示す）MLEN <= kで暗号化されるMメッセージ、長MLENのオクテットストリング、 -  11"
    },
    {
      "indent": 3,
      "text": "Output: C ciphertext, an octet string of length k",
      "ja": "出力：C暗号文、長さkのオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Error: \"message too long\"",
      "ja": "エラー：「あまりにも長いメッセージ」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking: If mLen > k - 11, output \"message too long\" and stop.",
      "ja": "1.長さのチェック：MLEN> Kの場合 -  11、出力「メッセージが長すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. EME-PKCS1-v1_5 encoding:",
      "section_title": true,
      "ja": "2. EME-PKCS1-v1_5のエンコーディング："
    },
    {
      "indent": 6,
      "text": "a. Generate an octet string PS of length k - mLen - 3 consisting of pseudo-randomly generated nonzero octets. The length of PS will be at least eight octets.",
      "ja": "A。 MLEN  -   -  3擬似ランダムに生成された非ゼロオクテットからなる長さkのオクテット列PSを生成します。 PSの長さは少なくとも8つのオクテットになります。"
    },
    {
      "indent": 6,
      "text": "b. Concatenate PS, the message M, and other padding to form an encoded message EM of length k octets as",
      "ja": "B。 CONCATENATE PS、メッセージM、及び他の詰め物は、長さKオクテットの符号化されたメッセージEMなどを形成します"
    },
    {
      "indent": 12,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "ja": "EMは$ 00を= || 0x02の|| PS || 0x00の|| M."
    },
    {
      "indent": 3,
      "text": "3. RSA encryption:",
      "section_title": true,
      "ja": "3. RSA暗号化："
    },
    {
      "indent": 6,
      "text": "a. Convert the encoded message EM to an integer message representative m (see Section 4.2):",
      "ja": "A。整数を表すメッセージmにコード化されたメッセージEMを変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "m = OS2IP (EM).",
      "ja": "M = OS2IP（MS）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA public key (n, e) and the message representative m to produce an integer ciphertext representative c:",
      "ja": "B。 RSAEP暗号化は、RSA公開鍵（N、e）及び整数暗号文代表cを生成することを表すメッセージmに（セクション5.1.1）プリミティブ適用されます。"
    },
    {
      "indent": 12,
      "text": "c = RSAEP ((n, e), m).",
      "ja": "C = RSAEP（（N、E）、M）。"
    },
    {
      "indent": 6,
      "text": "c. Convert the ciphertext representative c to a ciphertext C of length k octets (see Section 4.1):",
      "ja": "C。長さKオクテット（セクション4.1を参照）の暗号文Cに暗号文代表cを変換します。"
    },
    {
      "indent": 15,
      "text": "C = I2OSP (c, k).",
      "ja": "C = I2OSP（C、K）。"
    },
    {
      "indent": 3,
      "text": "4. Output the ciphertext C.",
      "section_title": true,
      "ja": "4.出力暗号文C."
    },
    {
      "indent": 0,
      "text": "7.2.2 Decryption operation",
      "section_title": true,
      "ja": "7.2.2復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-DECRYPT (K, C)",
      "ja": "RSAES-PKCS1-v1_5の-DECRYPT（K、C）"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key C ciphertext to be decrypted, an octet string of length k, where k is the length in octets of the RSA modulus n",
      "ja": "入力：kはRSAモジュラスNのオクテット長で復号化されるべきK個の受信者のRSA秘密鍵暗号文Cを、長さkのオクテットストリング、"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length at most k - 11",
      "ja": "出力：Mメッセージ、最もkの長さのオクテット文字列 -  11"
    },
    {
      "indent": 3,
      "text": "Error: \"decryption error\"",
      "ja": "エラー：「解読エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking: If the length of the ciphertext C is not k octets (or if k < 11), output \"decryption error\" and stop.",
      "ja": "1.長さのチェック：暗号文Cの長さがオクテット（又はもしK <11）、出力「復号エラーを」Kおよび停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. RSA decryption:",
      "section_title": true,
      "ja": "2. RSA復号："
    },
    {
      "indent": 6,
      "text": "a. Convert the ciphertext C to an integer ciphertext representative c (see Section 4.2):",
      "ja": "A。整数暗号文代表cに暗号文Cに変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "c = OS2IP (C).",
      "ja": "C = OS2IP（C）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSADP decryption primitive (Section 5.1.2) to the RSA private key (n, d) and the ciphertext representative c to produce an integer message representative m:",
      "ja": "B。 RSA秘密鍵（N、D）と整数を表すメッセージmを生成する暗号文代表cに（セクション5.1.2）プリミティブRSADP復号を適用します。"
    },
    {
      "indent": 12,
      "text": "m = RSADP ((n, d), c).",
      "ja": "M = RSADP（（N、D）、C）。"
    },
    {
      "indent": 9,
      "text": "If RSADP outputs \"ciphertext representative out of range\" (meaning that c >= n), output \"decryption error\" and stop.",
      "ja": "RSADPが「範囲外の暗号文代表」を出力する場合（その意味> = N C）、出力「復号エラー」と止めます。"
    },
    {
      "indent": 6,
      "text": "c. Convert the message representative m to an encoded message EM of length k octets (see Section 4.1):",
      "ja": "C。長さKオクテット（セクション4.1を参照）の符号化されたメッセージEMを表すメッセージmを変換します。"
    },
    {
      "indent": 12,
      "text": "EM = I2OSP (m, k).",
      "ja": "I2OSP EM =（MのK）。"
    },
    {
      "indent": 3,
      "text": "3. EME-PKCS1-v1_5 decoding: Separate the encoded message EM into an octet string PS consisting of nonzero octets and a message M as",
      "ja": "3. EME-PKCS1-v1_5の復号：非ゼロオクテットと、メッセージMとで構成されるオクテットストリングPSにエンコードされたメッセージEMを分離"
    },
    {
      "indent": 9,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "ja": "EMは$ 00を= || 0x02の|| PS || 0x00の|| M."
    },
    {
      "indent": 6,
      "text": "If the first octet of EM does not have hexadecimal value 0x00, if the second octet of EM does not have hexadecimal value 0x02, if there is no octet with hexadecimal value 0x00 to separate PS from M, or if the length of PS is less than 8 octets, output \"decryption error\" and stop. (See the note below.)",
      "ja": "EMの最初のオクテットは16進数の値0x00をしていない場合はMとPSを分離する進値は0x00とはオクテットが存在しない場合、EMの2番目のオクテットは、進値0×02を有していない場合、またはPSの長さ未満である場合8つのオクテット、出力「解読エラー」とストップ。 （下記の注を参照してください。）"
    },
    {
      "indent": 3,
      "text": "4. Output M.",
      "section_title": true,
      "ja": "4.出力M."
    },
    {
      "indent": 3,
      "text": "Note. Care shall be taken to ensure that an opponent cannot distinguish the different error conditions in Step 3, whether by error message or timing. Otherwise an opponent may be able to obtain useful information about the decryption of the ciphertext C, leading to a strengthened version of Bleichenbacher's attack [6]; compare to Manger's attack [36].",
      "ja": "注意。注意が相手かどうか、エラー・メッセージまたはタイミングにより、ステップ3で異なるエラー条件を区別することができないように注意しなければなりません。そうでなければ相手はBleichenbacherのの攻撃の強化バージョンにつながる、暗号文Cの解読に関する有用な情報を得ることができるかもしれない[6]。マネージャの攻撃[36]と比較します。"
    },
    {
      "indent": 0,
      "text": "8. Signature schemes with appendix",
      "section_title": true,
      "ja": "付録8.署名方式"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, a signature scheme with appendix consists of a signature generation operation and a signature verification operation, where the signature generation operation produces a signature from a message with a signer's RSA private key, and the signature verification operation verifies the signature on the message with the signer's corresponding RSA public key. To verify a signature constructed with this type of scheme it is necessary to have the message itself. In this way, signature schemes with appendix are distinguished from signature schemes with message recovery, which are not supported in this document.",
      "ja": "このドキュメントの目的のために、付録付き署名方式は、署名生成処理、署名生成動作は、署名者のRSA秘密鍵でメッセージから署名を生成し、署名検証操作が署名を検証署名検証作業、で構成されてい署名者の対応するRSA公開鍵でメッセージに。スキームのこのタイプで構成署名を検証するために、メッセージ自体を有することが必要です。このように、付録付き署名方式については、このドキュメントではサポートされていないメッセージの回復、と署名方式とは区別されています。"
    },
    {
      "indent": 3,
      "text": "A signature scheme with appendix can be employed in a variety of applications. For instance, the signature schemes with appendix defined here would be suitable signature algorithms for X.509 certificates [28]. Related signature schemes could be employed in PKCS #7 [45], although for technical reasons the current version of PKCS #7 separates a hash function from a signature scheme, which is different than what is done here; see the note in Appendix A.2.3 for more discussion.",
      "ja": "付録付き署名方式は、種々の用途に使用することができます。例えば、ここで定義された付録付き署名方式は、X.509証明書[28]に適した署名アルゴリズムであろう。技術的な理由のためにPKCS＃7の現在のバージョンはここで行われているものとは異なる署名方式、からハッシュ関数を分離しているが関連する署名方式は、PKCS＃7 [45]に使用することができます。より多くの議論については、付録A.2.3でノートを参照してください。"
    },
    {
      "indent": 3,
      "text": "Two signature schemes with appendix are specified in this document: RSASSA-PSS and RSASSA-PKCS1-v1_5. Although no attacks are known against RSASSA-PKCS1-v1_5, in the interest of increased robustness, RSASSA-PSS is recommended for eventual adoption in new applications. RSASSA-PKCS1-v1_5 is included for compatibility with existing applications, and while still appropriate for new applications, a gradual transition to RSASSA-PSS is encouraged.",
      "ja": "RSASSA-PSSとRSASSA-PKCS1-v1_5の：付録を持つ2つの署名方式は、この文書で指定されています。何の攻撃が増加した堅牢性の利益のために、RSASSA-PKCS1-v1_5のに対して知られていないが、RSASSA-PSSは、新しいアプリケーションでは、最終的に採用することをお勧めします。 RSASSA-PKCS1-v1_5のは、既存のアプリケーションとの互換性のために含まれ、そして新しいアプリケーションのまだ適切ながら、RSASSA-PSSへの段階的移行を奨励しています。"
    },
    {
      "indent": 3,
      "text": "The signature schemes with appendix given here follow a general model similar to that employed in IEEE Std 1363-2000 [26], combining signature and verification primitives with an encoding method for signatures. The signature generation operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. A signature primitive is applied to the message representative to produce the signature. Reversing this, the signature verification operations apply a signature verification primitive to the signature to recover a message representative, which is then converted to an octet string encoded message. A verification operation is applied to the message and the encoded message to determine whether they are consistent.",
      "ja": "ここで指定された付録付き署名方式は、署名の符号化方式で署名と検証プリミティブを組み合わせ、IEEE STD 1363から2000 [26]で用いたものと同様の一般的なモデルに従います。署名生成操作は、次に整数を表すメッセージに変換され、エンコードされたメッセージを生成するメッセージに、メッセージ符号化演算を適用します。プリミティブ署名は、署名を生成することを表すメッセージに適用されます。この反転、署名検証動作は、次にオクテットストリング符号化されたメッセージに変換されたメッセージ代表を回復するために署名にプリミティブ署名検証を適用します。ベリファイ動作は、それらが一致しているかどうかを決定するためにメッセージとエンコードされたメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": "If the encoding method is deterministic (e.g., EMSA-PKCS1-v1_5), the verification operation may apply the message encoding operation to the message and compare the resulting encoded message to the previously derived encoded message. If there is a match, the signature is considered valid. If the method is randomized (e.g., EMSA-PSS), the verification operation is typically more complicated. For example, the verification operation in EMSA-PSS extracts the random salt and a hash output from the encoded message and checks whether the hash output, the salt, and the message are consistent; the hash output is a deterministic function in terms of the message and the salt.",
      "ja": "符号化方式が決定論的である場合（例えば、EMSA-PKCS1-v1_5の）は、ベリファイ動作は、メッセージにメッセージエンコーディング動作を適用して、以前に由来する符号化されたメッセージに、得られた符号化されたメッセージを比較することができます。一致がある場合は、署名が有効であると考えられます。この方法は、（例えば、EMSA-PSS）ランダム化された場合、ベリファイ動作は、典型的には、より複雑です。例えば、EMSA-PSSで検証動作は、ランダムな塩およびエンコードされたメッセージとハッシュ出力、塩、及びメッセージが一貫しているかどうかをチェックからハッシュ出力を取り出します。ハッシュ出力は、メッセージと塩の面で決定的関数です。"
    },
    {
      "indent": 3,
      "text": "For both signature schemes with appendix defined in this document, the signature generation and signature verification operations are readily implemented as \"single-pass\" operations if the signature is placed after the message. See PKCS #7 [45] for an example format in the case of RSASSA-PKCS1-v1_5.",
      "ja": "署名がメッセージの後に配置されている場合は、この文書で定義された付録の両方署名方式は、署名生成および署名検証動作が容易に「シングルパス」演算として実装されます。 RSASSA-PKCS1-v1_5の場合の例フォーマットのPKCS＃7 [45]を参照。"
    },
    {
      "indent": 0,
      "text": "8.1 RSASSA-PSS",
      "section_title": true,
      "ja": "8.1 RSASSA-PSS"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS combines the RSASP1 and RSAVP1 primitives with the EMSA-PSS encoding method. It is compatible with the IFSSA scheme as amended in the IEEE P1363a draft [27], where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1 as defined in IEEE Std 1363-2000 [26] and the message encoding method is EMSA4. EMSA4 is slightly more general than EMSA-PSS as it acts on bit strings rather than on octet strings. EMSA-PSS is equivalent to EMSA4 restricted to the case that the operands as well as the hash and salt values are octet strings.",
      "ja": "RSASSA-PSSは、EMSA-PSS符号化方式でRSASP1とRSAVP1プリミティブを組み合わせ。 1363-2000 [26]と、メッセージ・エンコーディング方法はEMSA4あるIEEE規格で定義されている署名と検証プリミティブはIFSP  -  RSA1とIFVP-RSA1あるIEEE P1363aドラフト[27]に修正され、それはIFSSA方式と互換性があります。それはビット列ではなく、オクテットストリングに作用するようEMSA4はEMSA-PSSよりもわずかにより一般的です。 EMSA-PSSは、オペランドとしてだけでなく、ハッシュとソルト値はオクテット文字列である場合に限らEMSA4に相当します。"
    },
    {
      "indent": 3,
      "text": "The length of messages on which RSASSA-PSS can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA-PSS encoding method.",
      "ja": "RSASSA-PSSが動作可能にメッセージの長さは無制限またはEMSA-PSS符号化方式の基礎となるハッシュ関数に応じて、非常に大きな数によって制約のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Assuming that computing e-th roots modulo n is infeasible and the hash and mask generation functions in EMSA-PSS have appropriate properties, RSASSA-PSS provides secure signatures. This assurance is provable in the sense that the difficulty of forging signatures can be directly related to the difficulty of inverting the RSA function, provided that the hash and mask generation functions are viewed as black boxes or random oracles. The bounds in the security proof are essentially \"tight\", meaning that the success probability and running time for the best forger against RSASSA-PSS are very close to the corresponding parameters for the best RSA inversion algorithm; see [4][13][31] for further discussion.",
      "ja": "電子番目の根のモジュロNを計算することは不可能であり、EMSA-PSS内のハッシュとマスク生成関数は、適切な特性を有すると仮定すると、RSASSA-PSSは、安全な署名を提供します。この保証は、署名を偽造の難しさは、直接RSA関数を反転することの難しさに関係することができるという意味で証明可能であり、ハッシュマスク生成関数をブラックボックスやランダムオラクルとみなされるものとします。セキュリティ証明における境界はRSASSA-PSSに対する最善の偽造者のための成功確率と実行している時間が最高のRSA反転アルゴリズムの対応するパラメータに非常に近いことを意味し、基本的に「きつい」です。参照[4] [13] [31]さらなる議論のために。"
    },
    {
      "indent": 3,
      "text": "In contrast to the RSASSA-PKCS1-v1_5 signature scheme, a hash function identifier is not embedded in the EMSA-PSS encoded message, so in theory it is possible for an adversary to substitute a different (and potentially weaker) hash function than the one selected by the signer. Therefore, it is recommended that the EMSA-PSS mask generation function be based on the same hash function. In this manner the entire encoded message will be dependent on the hash function and it will be difficult for an opponent to substitute a different hash function than the one intended by the signer. This matching of hash functions is only for the purpose of preventing hash function substitution, and is not necessary if hash function substitution is addressed by other means (e.g., the verifier accepts only a designated hash function). See [34] for further discussion of these points. The provable security of RSASSA-PSS does not rely on the hash function in the mask generation function being the same as the hash function applied to the message.",
      "ja": "RSASSA-PKCS1-v1_5の署名方式とは対照的に、ハッシュ関数識別子は、敵が1より異なる（及び潜在的により弱い）ハッシュ関数を置換するために理論的には可能であるので、EMSA-PSS符号化されたメッセージに埋め込まれていません署名者によって選択されました。したがって、EMSA-PSSマスク生成機能は、同一のハッシュ関数に基づくことが推奨されます。このようにして全体の符号化されたメッセージは、ハッシュ関数に依存するであろうと、相手が署名者が意図したものとは異なるハッシュ関数を代入することは困難であろう。ハッシュ関数のこのマッチングは、ハッシュ関数の置換を防止するためであり、ハッシュ関数置換が他の手段（例えば、検証者のみ指定ハッシュ関数を受け入れる）によってアドレス指定された場合に必要ではありません。これらの点の更なる議論については[34]を参照。 RSASSA-PSSの証明可能なセキュリティがメッセージに適用されるハッシュ関数と同じであるマスク生成関数でハッシュ関数に依存しません。"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS is different from other RSA-based signature schemes in that it is probabilistic rather than deterministic, incorporating a randomly generated salt value. The salt value enhances the security of the scheme by affording a \"tighter\" security proof than deterministic alternatives such as Full Domain Hashing (FDH); see [4] for discussion. However, the randomness is not critical to security. In situations where random generation is not possible, a fixed value or a sequence number could be employed instead, with the resulting provable security similar to that of FDH [12].",
      "ja": "それはランダムに生成された塩の価値を組み込んだ、確率ではなく、決定論的であるという点でRSASSA-PSSは、他のRSAベースの署名方式とは異なります。ソルト値は、完全なドメインハッシュ（FDH）として決定論の選択肢より「タイト」のセキュリティ証明を提供することによりスキームのセキュリティを強化します。議論のための[4]を参照してください。しかし、ランダム性は、セキュリティにとって重要ではありません。ランダム生成が不可能な状況では、固定値又はシーケンス番号がFDH [12]と同様、得られた証明可能なセキュリティを、代わりに使用することができます。"
    },
    {
      "indent": 0,
      "text": "8.1.1 Signature generation operation",
      "section_title": true,
      "ja": "8.1.1署名生成動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS-SIGN (K, M)",
      "ja": "RSASSA-PSS-SIGN（K、M）"
    },
    {
      "indent": 3,
      "text": "Input: K signer's RSA private key M message to be signed, an octet string",
      "ja": "入力：Kの署名者のRSA秘密鍵Mのメッセージに署名する、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: S signature, an octet string of length k, where k is the length in octets of the RSA modulus n",
      "ja": "出力：S署名、長さkのオクテットストリング、kはRSAモジュラスNのオクテットの長さであります"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long;\" \"encoding error\"",
      "ja": "エラー：「あまりにも長いメッセージ;」 「エンコーディングエラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. EMSA-PSS encoding: Apply the EMSA-PSS encoding operation (Section 9.1.1) to the message M to produce an encoded message EM of length \\ceil ((modBits - 1)/8) octets such that the bit length of the integer OS2IP (EM) (see Section 4.2) is at most modBits - 1, where modBits is the length in bits of the RSA modulus n:",
      "ja": "1. EMSA-PSS符号化：符号化されたメッセージ長の\\ CEILのEMを生成するために、メッセージMにEMSA-PSS符号化操作（9.1.1項）を適用（（modBits  -  1）/ 8）ビット長のオクテットよう整数OS2IP（EM）は、最もmodBitsである（セクション4.2を参照） -  1、modBitsはRSAモジュラスNのビットの長さです。"
    },
    {
      "indent": 9,
      "text": "EM = EMSA-PSS-ENCODE (M, modBits - 1).",
      "ja": "EMは、EMSA-PSS-ENCODE =（M、modBits  -  1）。"
    },
    {
      "indent": 6,
      "text": "Note that the octet length of EM will be one less than k if modBits - 1 is divisible by 8 and equal to k otherwise. If the encoding operation outputs \"message too long,\" output \"message too long\" and stop. If the encoding operation outputs \"encoding error,\" output \"encoding error\" and stop.",
      "ja": "modBits場合EMのオクテット長がkより一つ少なくなることに注意してください -  1と、それ以外の場合はkに8で割り切れると同じです。符号化動作を出力する場合、「メッセージが長すぎる、」出力「のメッセージが長すぎる」と止めます。符号化操作の出力が「エラーコード」出力「符号化誤差」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. RSA signature:",
      "section_title": true,
      "ja": "2. RSA署名："
    },
    {
      "indent": 6,
      "text": "a. Convert the encoded message EM to an integer message representative m (see Section 4.2):",
      "ja": "A。整数を表すメッセージmにコード化されたメッセージEMを変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "m = OS2IP (EM).",
      "ja": "M = OS2IP（MS）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and the message representative m to produce an integer signature representative s:",
      "ja": "B。 RSA秘密鍵Kと整数署名代表Sを生成することを表すメッセージmにRSASP1署名プリミティブ（5.2.1）を適用します。"
    },
    {
      "indent": 12,
      "text": "s = RSASP1 (K, m).",
      "ja": "S = RSASP1（K、M）。"
    },
    {
      "indent": 6,
      "text": "c. Convert the signature representative s to a signature S of length k octets (see Section 4.1):",
      "ja": "C。署名代表Sは、長さKオクテット（セクション4.1を参照）の署名Sに変換します。"
    },
    {
      "indent": 12,
      "text": "S = I2OSP (s, k).",
      "ja": "S = I2OSP（S、K）。"
    },
    {
      "indent": 3,
      "text": "3. Output the signature S.",
      "section_title": true,
      "ja": "3.出力署名S."
    },
    {
      "indent": 0,
      "text": "8.1.2 Signature verification operation",
      "section_title": true,
      "ja": "8.1.2署名検証動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PSS-VERIFY ((n, e), M, S)",
      "ja": "RSASSA-PSS-VERIFY（（N、E）、M、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) signer's RSA public key M message whose signature is to be verified, an octet string S signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n",
      "ja": "入力：その署名を検証する（N、E）、署名者のRSA公開鍵Mメッセージ、検証すべきオクテットストリングS署名、kはRSAモジュラスNのオクテットの長さである長さkのオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Output: \"valid signature\" or \"invalid signature\"",
      "ja": "出力：「有効な署名」または「無効な署名」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking: If the length of the signature S is not k octets, output \"invalid signature\" and stop.",
      "ja": "1.長さのチェック：署名Sの長さはオクテット、出力「無効な署名」をkおよび停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. RSA verification:",
      "section_title": true,
      "ja": "2. RSA検証："
    },
    {
      "indent": 6,
      "text": "a. Convert the signature S to an integer signature representative s (see Section 4.2):",
      "ja": "A。 （セクション4.2参照）整数署名代表sの署名Sを変換します。"
    },
    {
      "indent": 12,
      "text": "s = OS2IP (S).",
      "ja": "C = OS2IP（C）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e) and the signature representative s to produce an integer message representative m:",
      "ja": "B。 RSA公開鍵（N、e）及び整数を表すメッセージmを生成する署名代表sまでRSAVP1確認プリミティブ（5.2.2項）を適用します。"
    },
    {
      "indent": 12,
      "text": "m = RSAVP1 ((n, e), s).",
      "ja": "M = RSAVP1（（N、E）、S）。"
    },
    {
      "indent": 9,
      "text": "If RSAVP1 output \"signature representative out of range,\" output \"invalid signature\" and stop.",
      "ja": "RSAVP1出力「範囲外の署名を表す、」出力「無効な署名」する場合と停止。"
    },
    {
      "indent": 6,
      "text": "c. Convert the message representative m to an encoded message EM of length emLen = \\ceil ((modBits - 1)/8) octets, where modBits is the length in bits of the RSA modulus n (see Section 4.1):",
      "ja": "C。符号化されたメッセージ長emLen = \\ CEILのEMを表すメッセージmを変換する（（modBits  -  1）/ 8）オクテット、modBitsはRSAモジュラスNのビットの長さである（4.1節を参照します）。"
    },
    {
      "indent": 12,
      "text": "EM = I2OSP (m, emLen).",
      "ja": "EM = I2OSP（M emLen）。"
    },
    {
      "indent": 9,
      "text": "Note that emLen will be one less than k if modBits - 1 is divisible by 8 and equal to k otherwise. If I2OSP outputs \"integer too large,\" output \"invalid signature\" and stop.",
      "ja": "modBits場合emLenがkより一つ少なくなることに注意してください -  1と、それ以外の場合はkに8で割り切れると同じです。 I2OSP出力が「整数が大きすぎ、」出力「無効な署名」する場合と停止。"
    },
    {
      "indent": 3,
      "text": "3. EMSA-PSS verification: Apply the EMSA-PSS verification operation (Section 9.1.2) to the message M and the encoded message EM to determine whether they are consistent:",
      "ja": "3. EMSA-PSS検証：メッセージMと、それらが一致しているかどうかを決定するために、符号化されたメッセージEMにEMSA-PSS検証動作（9.1.2項）を適用します。"
    },
    {
      "indent": 9,
      "text": "Result = EMSA-PSS-VERIFY (M, EM, modBits - 1).",
      "ja": "結果= EMSA-PSS-VERIFY（M、EM、modBits  -  1）。"
    },
    {
      "indent": 3,
      "text": "4. If Result = \"consistent,\" output \"valid signature.\" Otherwise, output \"invalid signature.\"",
      "ja": "4.結果=「一貫性のある、」出力「の有効な署名。」の場合それ以外の場合は、出力「無効な署名。」"
    },
    {
      "indent": 0,
      "text": "8.2. RSASSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "8.2。 RSASSA-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives with the EMSA-PKCS1-v1_5 encoding method. It is compatible with the IFSSA scheme defined in IEEE Std 1363-2000 [26], where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1 and the message encoding method is EMSA-PKCS1-v1_5 (which is not defined in IEEE Std 1363-2000, but is in the IEEE P1363a draft [27]).",
      "ja": "RSASSA-PKCS1-v1_5のは、EMSA-PKCS1-v1_5の符号化方式でRSASP1とRSAVP1プリミティブを組み合わせ。それは署名と検証プリミティブはIFSP  -  RSA1とIFVP-RSA1あるIEEE STD 1363から2000 [26]で定義されIFSSA方式と互換性があり、メッセージの符号化方式は、IEEEで定義されていないEMSA-PKCS1-v1_5の（ありますSTD 1363-2000しかし、IEEE P1363aドラフトである[27]）。"
    },
    {
      "indent": 3,
      "text": "The length of messages on which RSASSA-PKCS1-v1_5 can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA-PKCS1-v1_5 method.",
      "ja": "RSASSA-PKCS1-v1_5のが動作可能にメッセージの長さは無制限またはEMSA-PKCS1-v1_5の方法の基礎となるハッシュ関数に応じて、非常に大きな数によって制約のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Assuming that computing e-th roots modulo n is infeasible and the hash function in EMSA-PKCS1-v1_5 has appropriate properties, RSASSA-PKCS1-v1_5 is conjectured to provide secure signatures. More precisely, forging signatures without knowing the RSA private key is conjectured to be computationally infeasible. Also, in the encoding method EMSA-PKCS1-v1_5, a hash function identifier is embedded in the encoding. Because of this feature, an adversary trying to find a message with the same signature as a previously signed message must find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary. See [34] for further discussion.",
      "ja": "電子番目の根のモジュロNを計算することは不可能であり、EMSA-PKCS1-v1_5の中にハッシュ関数は適切な特性を有すると仮定すると、RSASSA-PKCS1-v1_5のは、安全な署名を提供するように推測されます。より正確には、RSA秘密鍵を知らずに署名を鍛造することは計算上実行不可能であることを推測されます。また、符号化方法EMSA-PKCS1-v1_5の中で、ハッシュ関数識別子は、符号化に埋め込まれます。この機能により、敵対者は、使用される特定のハッシュ関数の衝突を見つける必要があり、以前に署名されたメッセージと同じ署名付きメッセージを見つけよう。署名者によって選択されたものとは異なるハッシュ関数を攻撃することは敵に有用ではありません。さらなる議論のための[34]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note. As noted in PKCS #1 v1.5, the EMSA-PKCS1-v1_5 encoding method has the property that the encoded message, converted to an integer message representative, is guaranteed to be large and at least somewhat \"random\". This prevents attacks of the kind proposed by",
      "ja": "注意。 PKCS＃1 V1.5で述べたように、EMSA-PKCS1-v1_5の符号化方法は、整数を表すメッセージに変換するエンコードされたメッセージ、プロパティは、大きく、少なくとも幾分「ランダム」であることが保証されています。これはによって提案された種類の攻撃を防ぎ"
    },
    {
      "indent": 3,
      "text": "Desmedt and Odlyzko [16] where multiplicative relationships between message representatives are developed by factoring the message representatives into a set of small values (e.g., a set of small primes). Coron, Naccache, and Stern [15] showed that a stronger form of this type of attack could be quite effective against some instances of the ISO/IEC 9796-2 signature scheme. They also analyzed the complexity of this type of attack against the EMSA-PKCS1-v1_5 encoding method and concluded that an attack would be impractical, requiring more operations than a collision search on the underlying hash function (i.e., more than 2^80 operations). Coppersmith, Halevi, and Jutla [11] subsequently extended Coron et al.'s attack to break the ISO/IEC 9796-1 signature scheme with message recovery. The various attacks illustrate the importance of carefully constructing the input to the RSA signature primitive, particularly in a signature scheme with message recovery. Accordingly, the EMSA-PKCS-v1_5 encoding method explicitly includes a hash operation and is not intended for signature schemes with message recovery. Moreover, while no attack is known against the EMSA-PKCS-v1_5 encoding method, a gradual transition to EMSA-PSS is recommended as a precaution against future developments.",
      "ja": "DesmedtとOdlyzko [16]メッセージ代表間の乗法的関係は、小さな値（小さい素数の例えば、セット）のセットにメッセージ代表を因数分解することによって開発されます。コロン、Naccache、およびスターン[15]このタイプの攻撃の強力な形式は、ISO / IEC 9796から2署名方式のいくつかの例に対して非常に有効であることを示しました。彼らはまた、EMSA-PKCS1-v1_5の符号化方法に対するこのタイプの攻撃の複雑さを分析し、攻撃は非現実的であろうと結論付け、基礎となるハッシュ関数（すなわち、以上2 ^ 80の操作）に衝突検索以上の操作を必要とします。銅細工、Halevi、及びJutla [11]続いて、メッセージ回復とISO / IEC 9796から1署名方式を破るコロンらの攻撃を拡張しました。様々な攻撃は、特にメッセージ復元を持つ署名方式では、慎重にRSA署名プリミティブへの入力を構成することの重要性を示しています。従って、EMSA-PKCS-v1_5の符号化方法は、明示的にハッシュ演算を含み、メッセージ回復と署名方式のために意図されていません。いかなる攻撃がEMSA-PKCS-v1_5の符号化方式に対して知られていないながら、また、EMSA-PSSへ徐々に移行は、今後の開発に対する予防策として推奨されています。"
    },
    {
      "indent": 0,
      "text": "8.2.1 Signature generation operation",
      "section_title": true,
      "ja": "8.2.1署名生成動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-SIGN (K, M)",
      "ja": "RSASSA-PKCS1-v1_5の-SIGN（K、M）"
    },
    {
      "indent": 3,
      "text": "Input: K signer's RSA private key M message to be signed, an octet string",
      "ja": "入力：Kの署名者のRSA秘密鍵Mのメッセージに署名する、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: S signature, an octet string of length k, where k is the length in octets of the RSA modulus n",
      "ja": "出力：S署名、長さkのオクテットストリング、kはRSAモジュラスNのオクテットの長さであります"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"RSA modulus too short\"",
      "ja": "エラー：「メッセージが長すぎます」。 「RSAは短すぎるモジュラス」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2) to the message M to produce an encoded message EM of length k octets:",
      "ja": "1. EMSA-PKCS1-v1_5のエンコーディング：長さkオクテットの符号化されたメッセージEMを生成するメッセージMにEMSA-PKCS1-v1_5のエンコード動作（セクション9.2）を適用します。"
    },
    {
      "indent": 9,
      "text": "EM = EMSA-PKCS1-V1_5-ENCODE (M, k).",
      "ja": "EM = EMSA-PKCS1-v1_5のエンコード（M、K）。"
    },
    {
      "indent": 6,
      "text": "If the encoding operation outputs \"message too long,\" output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short,\" output \"RSA modulus too short\" and stop.",
      "ja": "符号化動作を出力する場合、「メッセージが長すぎる、」出力「のメッセージが長すぎる」と止めます。符号化演算の出力が「意図エンコードされたメッセージの長さが短すぎる、」IF出力「RSAモジュラス短すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. RSA signature:",
      "section_title": true,
      "ja": "2. RSA署名："
    },
    {
      "indent": 6,
      "text": "a. Convert the encoded message EM to an integer message representative m (see Section 4.2):",
      "ja": "A。整数を表すメッセージmにコード化されたメッセージEMを変換する（セクション4.2を参照）。"
    },
    {
      "indent": 12,
      "text": "m = OS2IP (EM).",
      "ja": "M = OS2IP（MS）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and the message representative m to produce an integer signature representative s:",
      "ja": "B。 RSA秘密鍵Kと整数署名代表Sを生成することを表すメッセージmにRSASP1署名プリミティブ（5.2.1）を適用します。"
    },
    {
      "indent": 12,
      "text": "s = RSASP1 (K, m).",
      "ja": "S = RSASP1（K、M）。"
    },
    {
      "indent": 6,
      "text": "c. Convert the signature representative s to a signature S of length k octets (see Section 4.1):",
      "ja": "C。署名代表Sは、長さKオクテット（セクション4.1を参照）の署名Sに変換します。"
    },
    {
      "indent": 12,
      "text": "S = I2OSP (s, k).",
      "ja": "S = I2OSP（S、K）。"
    },
    {
      "indent": 3,
      "text": "3. Output the signature S.",
      "section_title": true,
      "ja": "3.出力署名S."
    },
    {
      "indent": 0,
      "text": "8.2.2 Signature verification operation",
      "section_title": true,
      "ja": "8.2.2署名検証動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)",
      "ja": "RSASSA-PKCS1-v1_5のベリファイ（（N、E）、M、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) signer's RSA public key M message whose signature is to be verified, an octet string S signature to be verified, an octet string of length k, where k is the length in octets of the RSA modulus n",
      "ja": "入力：その署名を検証する（N、E）、署名者のRSA公開鍵Mメッセージ、検証すべきオクテットストリングS署名、kはRSAモジュラスNのオクテットの長さである長さkのオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Output: \"valid signature\" or \"invalid signature\"",
      "ja": "出力：「有効な署名」または「無効な署名」"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"RSA modulus too short\"",
      "ja": "エラー：「メッセージが長すぎます」。 「RSAは短すぎるモジュラス」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Length checking: If the length of the signature S is not k octets, output \"invalid signature\" and stop.",
      "ja": "1.長さのチェック：署名Sの長さはオクテット、出力「無効な署名」をkおよび停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. RSA verification:",
      "section_title": true,
      "ja": "2. RSA検証："
    },
    {
      "indent": 6,
      "text": "a. Convert the signature S to an integer signature representative s (see Section 4.2):",
      "ja": "A。 （セクション4.2参照）整数署名代表sの署名Sを変換します。"
    },
    {
      "indent": 12,
      "text": "s = OS2IP (S).",
      "ja": "C = OS2IP（C）。"
    },
    {
      "indent": 6,
      "text": "b. Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e) and the signature representative s to produce an integer message representative m:",
      "ja": "B。 RSA公開鍵（N、e）及び整数を表すメッセージmを生成する署名代表sまでRSAVP1確認プリミティブ（5.2.2項）を適用します。"
    },
    {
      "indent": 12,
      "text": "m = RSAVP1 ((n, e), s).",
      "ja": "M = RSAVP1（（N、E）、S）。"
    },
    {
      "indent": 9,
      "text": "If RSAVP1 outputs \"signature representative out of range,\" output \"invalid signature\" and stop.",
      "ja": "RSAVP1出力「範囲外署名代表」出力「無効な署名」と停止します。"
    },
    {
      "indent": 6,
      "text": "c. Convert the message representative m to an encoded message EM of length k octets (see Section 4.1):",
      "ja": "C。長さKオクテット（セクション4.1を参照）の符号化されたメッセージEMを表すメッセージmを変換します。"
    },
    {
      "indent": 12,
      "text": "EM' = I2OSP (m, k).",
      "ja": "EM「I2OSP =（MのK）。"
    },
    {
      "indent": 9,
      "text": "If I2OSP outputs \"integer too large,\" output \"invalid signature\" and stop.",
      "ja": "I2OSP出力が「整数が大きすぎ、」出力「無効な署名」する場合と停止。"
    },
    {
      "indent": 3,
      "text": "3. EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2) to the message M to produce a second encoded message EM' of length k octets:",
      "ja": "3. EMSA-PKCS1-v1_5のエンコーディング：長さkオクテットの第2の符号化メッセージEM」を生成するメッセージMにEMSA-PKCS1-v1_5のエンコード動作（セクション9.2）を適用します。"
    },
    {
      "indent": 12,
      "text": "EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).",
      "ja": "EM」= EMSA-PKCS1-v1_5のエンコード（M、K）。"
    },
    {
      "indent": 6,
      "text": "If the encoding operation outputs \"message too long,\" output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short,\" output \"RSA modulus too short\" and stop.",
      "ja": "符号化動作を出力する場合、「メッセージが長すぎる、」出力「のメッセージが長すぎる」と止めます。符号化演算の出力が「意図エンコードされたメッセージの長さが短すぎる、」IF出力「RSAモジュラス短すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "4. Compare the encoded message EM and the second encoded message EM'. If they are the same, output \"valid signature\"; otherwise, output \"invalid signature.\"",
      "ja": "4.エンコードされたメッセージEMおよび第2の符号化されたメッセージEM」を比較。それらが同じである場合、出力は「有効な署名」。それ以外の場合は、出力「無効な署名。」"
    },
    {
      "indent": 3,
      "text": "Note. Another way to implement the signature verification operation is to apply a \"decoding\" operation (not specified in this document) to the encoded message to recover the underlying hash value, and then to compare it to a newly computed hash value. This has the advantage that it requires less intermediate storage (two hash values rather than two encoded messages), but the disadvantage that it requires additional code.",
      "ja": "注意。署名検証動作を実現する別の方法は、基礎となるハッシュ値を回復するために、その後新たに計算されたハッシュ値と比較するために符号化されたメッセージに（この文書で指定されていない）「デコーディング」操作を適用することです。これは、より少ない中間ストレージ（2つのハッシュ値ではなく2つの符号化メッセージ）、それは追加のコードを必要とするという欠点を必要とするという利点を有します。"
    },
    {
      "indent": 0,
      "text": "9. Encoding methods for signatures with appendix",
      "section_title": true,
      "ja": "付録付き署名9.エンコード方法"
    },
    {
      "indent": 3,
      "text": "Encoding methods consist of operations that map between octet string messages and octet string encoded messages, which are converted to and from integer message representatives in the schemes. The integer message representatives are processed via the primitives. The encoding methods thus provide the connection between the schemes, which process messages, and the primitives.",
      "ja": "符号化方法は、オクテットストリングメッセージ及びスキームで整数メッセージ代表にから変換されるオクテットストリング符号化されたメッセージ、の間でマッピング操作から成ります。整数メッセージ代表は、プリミティブを介して処理されます。符号化方法は、このようにメッセージを処理する方式、およびプリミティブとの間の接続を提供します。"
    },
    {
      "indent": 3,
      "text": "An encoding method for signatures with appendix, for the purposes of this document, consists of an encoding operation and optionally a verification operation. An encoding operation maps a message M to an encoded message EM of a specified length. A verification operation determines whether a message M and an encoded message EM are consistent, i.e., whether the encoded message EM is a valid encoding of the message M.",
      "ja": "付録と署名の符号化方法は、この文書の目的のために、符号化処理および必要に応じて検証動作から成ります。符号化動作は、指定された長さの符号化されたメッセージEMにメッセージMをマッピングします。ベリファイ動作は、メッセージMと、符号化されたメッセージEMは、EMは、メッセージMの正当なエンコーディングでエンコードされたメッセージかどうか、即ち、一致しているか否かを判断します"
    },
    {
      "indent": 3,
      "text": "The encoding operation may introduce some randomness, so that different applications of the encoding operation to the same message will produce different encoded messages, which has benefits for provable security. For such an encoding method, both an encoding and a verification operation are needed unless the verifier can reproduce the randomness (e.g., by obtaining the salt value from the signer). For a deterministic encoding method only an encoding operation is needed.",
      "ja": "同じメッセージに符号化動作の異なるアプリケーションが証明可能なセキュリティのために利点を有し、異なる符号化されたメッセージを生成するように符号化処理は、いくつかのランダム性を導入することができます。検証者は、ランダム性を再現することができない限り、そのような符号化方法は、符号化および検証動作の両方（例えば、署名者からソルト値を取得することによって）必要とされています。決定論的符号化方式についてのみ符号化処理が必要とされています。"
    },
    {
      "indent": 3,
      "text": "Two encoding methods for signatures with appendix are employed in the signature schemes and are specified here: EMSA-PSS and EMSA-PKCS1- v1_5.",
      "ja": "付録と署名のための二つの符号化方式は、署名方式に採用されており、ここで指定されている：EMSA-PSSとEMSA-PKCS1- v1_5の。"
    },
    {
      "indent": 0,
      "text": "9.1 EMSA-PSS",
      "section_title": true,
      "ja": "9.1 EMSA-PSS"
    },
    {
      "indent": 3,
      "text": "This encoding method is parameterized by the choice of hash function, mask generation function, and salt length. These options should be fixed for a given RSA key, except that the salt length can be variable (see [31] for discussion). Suggested hash and mask generation functions are given in Appendix B. The encoding method is based on Bellare and Rogaway's Probabilistic Signature Scheme (PSS) [4][5]. It is randomized and has an encoding operation and a verification operation.",
      "ja": "この符号化方式は、ハッシュ関数の選択、マスク生成関数、および塩長によってパラメータ化されます。塩長は可変とすることができることを除いて、これらのオプションは、指定されたRSAキーに固定されるべきである（議論のための[31]を参照）。提案ハッシュマスク生成関数は、符号化方式がベラーとRogawayの確率署名方式（PSS）に基づいている付録Bに示されている[4] [5]。これは、無作為化され、符号化動作と検証作業があります。"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates the encoding operation.",
      "ja": "図2は、符号化動作を示します。"
    },
    {
      "indent": 3,
      "text": "__________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                               +-----------+\n                               |     M     |\n                               +-----------+\n                                     |\n                                     V\n                                   Hash\n                                     |\n                                     V\n                       +--------+----------+----------+\n                  M' = |Padding1|  mHash   |   salt   |\n                       +--------+----------+----------+\n                                      |\n            +--------+----------+     V\n      DB =  |Padding2|maskedseed|   Hash\n            +--------+----------+     |\n                      |               |\n                      V               |    +--+\n                     xor <--- MGF <---|    |bc|\n                      |               |    +--+\n                      |               |      |\n                      V               V      V\n            +-------------------+----------+--+\n      EM =  |    maskedDB       |maskedseed|bc|\n            +-------------------+----------+--+\n__________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2: EMSA-PSS encoding operation. Verification operation follows reverse steps to recover salt, then forward steps to recompute and compare H.",
      "ja": "図2：EMSA-PSS符号化演算。検証作業は、塩を回収するための逆の手順、H.を再計算し、比較するために、次に前方の手順に従います"
    },
    {
      "indent": 3,
      "text": "Notes.",
      "ja": "ノート。"
    },
    {
      "indent": 3,
      "text": "1. The encoding method defined here differs from the one in Bellare and Rogaway's submission to IEEE P1363a [5] in three respects:",
      "ja": "1.ここで定義された符号化方法は、3つの点でIEEE P1363a [5]にベラーとRogawayの提出におけるものと異なります。"
    },
    {
      "indent": 6,
      "text": "* It applies a hash function rather than a mask generation function to the message. Even though the mask generation function is based on a hash function, it seems more natural to apply a hash function directly.",
      "ja": "*これは、メッセージにハッシュ関数ではなく、マスク生成関数を適用します。マスク生成関数は、ハッシュ関数に基づいているにもかかわらず、直接ハッシュ関数を適用するために、より自然なようです。"
    },
    {
      "indent": 6,
      "text": "* The value that is hashed together with the salt value is the string (0x)00 00 00 00 00 00 00 00 || mHash rather than the message M itself. Here, mHash is the hash of M. Note that the hash function is the same in both steps. See Note 3 below for further discussion. (Also, the name \"salt\" is used instead of \"seed\", as it is more reflective of the value's role.)",
      "ja": "*塩の値と共にハッシュされた値は、文字列（0X）00 00 00 00 00 00 00 00 || mhashではなく、メッセージMそのもの。ここで、はmhashは、Mのハッシュは、ハッシュ関数は、両方の手順で同じであることに留意されたいです。さらなる議論については、以下の注3を参照してください。 （それは価値の役割をより反映しているとも、名前「塩」、代わりに「シード」の使用されています。）"
    },
    {
      "indent": 6,
      "text": "* The encoded message in EMSA-PSS has nine fixed bits; the first bit is 0 and the last eight bits form a \"trailer field\", the octet 0xbc. In the original scheme, only the first bit is fixed. The rationale for the trailer field is for compatibility with the Rabin-Williams IFSP-RW signature primitive in IEEE Std 1363-2000 [26] and the corresponding primitive in the draft ISO/IEC 9796-2 [29].",
      "ja": "* EMSA-PSSでエンコードされたメッセージは、9つの固定されたビットを有します。最初のビットは0であり、最後の8ビットは「トレーラフィールド」、オクテットの0xBCを形成します。元の方式では、最初のビットが固定されています。トレーラフィールドの理論的根拠は、IEEE STD 1363から2000 [26]におけるプリミティブラビン - ウィリアムズIFSP-RW署名及びドラフトISO / IEC 9796から2 [29]に対応するプリミティブとの互換性のためです。"
    },
    {
      "indent": 3,
      "text": "2. Assuming that the mask generation function is based on a hash function, it is recommended that the hash function be the same as the one that is applied to the message; see Section 8.1 for further discussion.",
      "ja": "前記マスク生成関数は、ハッシュ関数に基づいていると仮定すると、ハッシュ関数がメッセージに適用されるものと同じであることが推奨されます。さらなる議論については、セクション8.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "3. Without compromising the security proof for RSASSA-PSS, one may perform steps 1 and 2 of EMSA-PSS-ENCODE and EMSA-PSS-VERIFY (the application of the hash function to the message) outside the module that computes the rest of the signature operation, so that mHash rather than the message M itself is input to the module. In other words, the security proof for RSASSA-PSS still holds even if an opponent can control the value of mHash. This is convenient if the module has limited I/O bandwidth, e.g., a smart card. Note that previous versions of PSS [4][5] did not have this property. Of course, it may be desirable for other security reasons to have the module process the full message. For instance, the module may need to \"see\" what it is signing if it does not trust the component that computes the hash value.",
      "ja": "3. RSASSA-PSSのセキュリティ証明を損なうことなく、残りの計算モジュールの外部（メッセージにハッシュ関数を適用する）、一方はEMSA-PSS-ENCODEのステップ1および2を実行してもよいし、EMSA-PSS-VERIFY署名操作は、そのようにはmhashなく、メッセージM自体がモジュールに入力されます。言い換えれば、RSASSA-PSSのセキュリティ証明はまだ対戦相​​手ははmhashの値を制御することができる場合であっても成立します。モジュールは、I / O帯域幅、例えば、スマートカードが限定されている場合、これは便利です。 PSSの以前のバージョンでは、[4] [5]この特性を持っていなかったことに注意してください。他のセキュリティ上の理由は、モジュール工程に完全なメッセージを持っているもちろん、それが望ましいことがあります。例えば、モジュールは、ハッシュ値を計算コンポーネントを信頼していない場合、それが署名されたものを「見る」必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "4. Typical salt lengths in octets are hLen (the length of the output of the hash function Hash) and 0. In both cases the security of RSASSA-PSS can be closely related to the hardness of inverting RSAVP1. Bellare and Rogaway [4] give a tight lower bound for the security of the original RSA-PSS scheme, which corresponds roughly to the former case, while Coron [12] gives a lower bound for the related Full Domain Hashing scheme, which corresponds roughly to the latter case. In [13] Coron provides a general treatment with various salt lengths ranging from 0 to hLen; see [27] for discussion. See also [31], which adapts the security proofs in [4][13] to address the differences between the original and the present version of RSA-PSS as listed in Note 1 above.",
      "ja": "オクテット4の典型的な塩の長さは、両方の場合においてRSASSA-PSSのセキュリティはRSAVP1反転の硬さに密接に関連することができるさhLen（ハッシュ関数Hashの出力の長さ）及び0です。コロン[12]概ね対応関係する完全なドメインハッシュ方式、の下限を与えながらベラーとRogaway [4]は、前者の場合にほぼ相当する元のRSA-PSS方式のセキュリティのために厳しい下限を与えます後者の場合に。 [13]コロンは、0からさhLenの範囲の種々の塩長を有する一般的な治療法を提供します。議論のための[27]を参照してください。上記注1に記載されているオリジナルとRSA-PSSの現在のバージョンの違いに対処するために、[4]のセキュリティ証明を適応させる[31]、[13]も参照。"
    },
    {
      "indent": 3,
      "text": "5. As noted in IEEE P1363a [27], the use of randomization in signature schemes - such as the salt value in EMSA-PSS - may provide a \"covert channel\" for transmitting information other than the message being signed. For more on covert channels, see [50].",
      "ja": "5. IEEE P1363a [27]で述べたように、署名方式におけるランダム化の使用 - このようなEMSA-PSS中の塩の値としては、 - 署名されたメッセージ以外の情報を送信するために「隠れチャネル」を提供してもよいです。隠れチャネルの詳細については、[50]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1.1 Encoding operation",
      "section_title": true,
      "ja": "9.1.1符号化動作"
    },
    {
      "indent": 3,
      "text": "EMSA-PSS-ENCODE (M, emBits)",
      "ja": "EMSA-PSS-ENCODE（M、emBits）"
    },
    {
      "indent": 3,
      "text": "Options:",
      "ja": "オプション："
    },
    {
      "indent": 3,
      "text": "Hash hash function (hLen denotes the length in octets of the hash function output) MGF mask generation function sLen intended length in octets of the salt",
      "ja": "ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示す）SLENが塩のオクテットの長さを意図MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded, an octet string emBits maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen + 8sLen + 9",
      "ja": "入力：符号化するMメッセージ、整数OS2IP（EM）のオクテットストリングemBits最大ビット長（4.2節を参照）、少なくとも8hLen + 8sLen + 9"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen = \\ceil (emBits/8)",
      "ja": "出力：EM符号化されたメッセージ、長emLen = \\ CEILのオクテットストリング（emBi​​ts / 8）"
    },
    {
      "indent": 3,
      "text": "Errors: \"encoding error\"; \"message too long\"",
      "ja": "エラー：「エンコーディングエラー」; 「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of M is greater than the input limitation for the hash function (2^61 - 1 octets for SHA-1), output \"message too long\" and stop.",
      "ja": "1 Mの長さは、ハッシュ関数の入力制限よりも大きい場合には（2 ^ 61  -  SHA-1の1オクテット）、出力「メッセージが長すぎる」と停止。"
    },
    {
      "indent": 3,
      "text": "2. Let mHash = Hash(M), an octet string of length hLen.",
      "section_title": true,
      "ja": "2.はmhash =ハッシュ（M）、長さhLenのオクテットストリングをしましょう。"
    },
    {
      "indent": 3,
      "text": "3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop.",
      "section_title": true,
      "ja": "3. emLen <さhLen + SLEN + 2、出力 \"符号化誤差\" と停止します。"
    },
    {
      "indent": 3,
      "text": "4. Generate a random octet string salt of length sLen; if sLen = 0, then salt is the empty string.",
      "ja": "4.長さSLENのランダムオクテット文字列の塩を生成します。 SLEN = 0の場合、塩は空の文字列です。"
    },
    {
      "indent": 3,
      "text": "5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;",
      "ja": "5. M」=（0X）00 00 00 00 00 00 00 00う|| mhash ||塩;"
    },
    {
      "indent": 7,
      "text": "M' is an octet string of length 8 + hLen + sLen with eight\ninitial zero octets.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Let H = Hash(M'), an octet string of length hLen.",
      "section_title": true,
      "ja": "6. H =ハッシュ（M '）、長さhLenのオクテットストリングをしましょう。"
    },
    {
      "indent": 3,
      "text": "7. Generate an octet string PS consisting of emLen - sLen - hLen - 2 zero octets. The length of PS may be 0.",
      "ja": "SLEN  -   - さhLen  -  2ゼロオクテット7 emLenからなるオクテット列PSを生成します。 PSの長さは0であってもよいです。"
    },
    {
      "indent": 3,
      "text": "8. Let DB = PS || 0x01 || salt; DB is an octet string of length emLen - hLen - 1.",
      "ja": "8. DB = PSをしてみましょう|| 0x01の||塩;さhLen  -   -  1 DBは、長emLenのオクテット列です。"
    },
    {
      "indent": 3,
      "text": "9. Let dbMask = MGF(H, emLen - hLen - 1).",
      "section_title": true,
      "ja": "9. dbMask = MGF（ - さhLen  -  1 H、emLen）をしてみましょう。"
    },
    {
      "indent": 3,
      "text": "10. Let maskedDB = DB \\xor dbMask.",
      "section_title": true,
      "ja": "10.レッツmaskedDB = DB \\ XOR dbMask。"
    },
    {
      "indent": 3,
      "text": "11. Set the leftmost 8emLen - emBits bits of the leftmost octet in maskedDB to zero.",
      "ja": "11.セット左端8emLen  - ゼロにmaskedDBの左端のオクテットのemBitsビット。"
    },
    {
      "indent": 3,
      "text": "12. Let EM = maskedDB || H || 0xbc.",
      "section_title": true,
      "ja": "12.レッツEM = maskedDB || H || 0xBC。"
    },
    {
      "indent": 3,
      "text": "13. Output EM.",
      "section_title": true,
      "ja": "13.出力EM。"
    },
    {
      "indent": 0,
      "text": "9.1.2 Verification operation",
      "section_title": true,
      "ja": "9.1.2検証操作"
    },
    {
      "indent": 3,
      "text": "EMSA-PSS-VERIFY (M, EM, emBits)",
      "ja": "（M、EM、emBits）EMSA-PSS-VERIFY"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octets of the hash function output) MGF mask generation function sLen intended length in octets of the salt",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示す）SLENが塩のオクテットの長さを意図MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input: M message to be verified, an octet string EM encoded message, an octet string of length emLen = \\ceil (emBits/8) emBits maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen + 8sLen + 9",
      "ja": "入力：Mメッセージは、オクテットストリングEM符号化されたメッセージ、長emLen = \\ CEILのオクテット列を検証する（emBi​​ts / 8）の整数OS2IP（EM）の最大ビット長をemBits、（セクション4.2を参照）は、少なくとも8hLen + 8sLen + 9"
    },
    {
      "indent": 3,
      "text": "Output: \"consistent\" or \"inconsistent\"",
      "ja": "出力：「一貫性」または「矛盾」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of M is greater than the input limitation for the hash function (2^61 - 1 octets for SHA-1), output \"inconsistent\" and stop.",
      "ja": "1 Mの長さは、ハッシュ関数の入力制限よりも大きい場合には（2 ^ 61  -  SHA-1の1オクテット）、出力「矛盾」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Let mHash = Hash(M), an octet string of length hLen.",
      "section_title": true,
      "ja": "2.はmhash =ハッシュ（M）、長さhLenのオクテットストリングをしましょう。"
    },
    {
      "indent": 3,
      "text": "3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop.",
      "section_title": true,
      "ja": "3. emLen <さhLen + SLEN + 2、出力 \"矛盾\" と停止します。"
    },
    {
      "indent": 3,
      "text": "4. If the rightmost octet of EM does not have hexadecimal value 0xbc, output \"inconsistent\" and stop.",
      "ja": "4. EMの一番右のオクテットは、16進数値の0xBCを持つ出力「矛盾」と停止しない場合。"
    },
    {
      "indent": 3,
      "text": "5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and let H be the next hLen octets.",
      "ja": "さhLen  -   -  5. maskedDBは左端のemLenとするEMの1つのオクテット、及びHは、次のさhLenオクテットとします。"
    },
    {
      "indent": 3,
      "text": "6. If the leftmost 8emLen - emBits bits of the leftmost octet in maskedDB are not all equal to zero, output \"inconsistent\" and stop.",
      "ja": "左端8emLen場合6  -  maskedDBの左端のオクテットのemBitsビットは、すべての出力「矛盾」がゼロに等しくないと停止します。"
    },
    {
      "indent": 3,
      "text": "7. Let dbMask = MGF(H, emLen - hLen - 1).",
      "section_title": true,
      "ja": "7. dbMask = MGF（ - さhLen  -  1 H、emLen）をしましょう。"
    },
    {
      "indent": 3,
      "text": "8. Let DB = maskedDB \\xor dbMask.",
      "section_title": true,
      "ja": "8.レッツDB = maskedDB \\ XOR dbMask。"
    },
    {
      "indent": 3,
      "text": "9. Set the leftmost 8emLen - emBits bits of the leftmost octet in DB to zero.",
      "ja": "ゼロにDBの左端オクテットのemBitsビット -  9.左端8emLenを設定します。"
    },
    {
      "indent": 3,
      "text": "10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero or if the octet at position emLen - hLen - sLen - 1 (the leftmost position is \"position 1\") does not have hexadecimal value 0x01, output \"inconsistent\" and stop.",
      "ja": "10. emLenは場合 - さhLen  -  SLEN  - さhLen  -   -  SLEN  -  1（左端が「位置1」である）進値が0x01を有していない、出力「DBの2つの左端のオクテット位置emLenでゼロ又は場合オクテットではありません一貫性のない」とストップ。"
    },
    {
      "indent": 3,
      "text": "11. Let salt be the last sLen octets of DB.",
      "section_title": true,
      "ja": "11.塩がDBの最後SLENオクテットとします。"
    },
    {
      "indent": 3,
      "text": "12. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;",
      "ja": "12.レッツM」=（0X）00 00 00 00 00 00 00 00 || mhash ||塩 ;"
    },
    {
      "indent": 7,
      "text": "M' is an octet string of length 8 + hLen + sLen with eight\ninitial zero octets.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13. Let H' = Hash(M'), an octet string of length hLen.",
      "section_title": true,
      "ja": "13.レッツH '=ハッシュ（M'）、長さhLenのオクテットストリング。"
    },
    {
      "indent": 3,
      "text": "14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\"",
      "section_title": true,
      "ja": "14. HはH」、出力をIF = \"一致\"。それ以外の場合は、出力「矛盾」。"
    },
    {
      "indent": 0,
      "text": "9.2 EMSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "9.2 EMSA-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "This encoding method is deterministic and only has an encoding operation.",
      "ja": "この符号化方式は、決定論的であり、唯一の符号化動作を持っています。"
    },
    {
      "indent": 3,
      "text": "EMSA-PKCS1-v1_5-ENCODE (M, emLen)",
      "ja": "EMSA-PKCS1-v1_5のエンコード（M、emLen）"
    },
    {
      "indent": 3,
      "text": "Option: Hash hash function (hLen denotes the length in octets of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded emLen intended length in octets of the encoded message, at least tLen + 11, where tLen is the octet length of the DER encoding T of a certain value computed during the encoding operation",
      "ja": "入力：MメッセージはemLenはTLENは、符号化動作中に計算された一定値のDER符号化Tのオクテット長で符号化されたメッセージ、少なくともTLEN + 11のオクテットの長さを意図符号化します"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen",
      "ja": "出力：EMエンコードされたメッセージ、長さemLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"intended encoded message length too short\"",
      "ja": "エラー：「メッセージが長すぎます」。 「意図した符号化されたメッセージの長さが短すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Apply the hash function to the message M to produce a hash value H:",
      "ja": "1ハッシュ値Hを生成するために、メッセージMにハッシュ関数を適用します。"
    },
    {
      "indent": 9,
      "text": "H = Hash(M).",
      "ja": "H =ハッシュ（M）。"
    },
    {
      "indent": 6,
      "text": "If the hash function outputs \"message too long,\" output \"message too long\" and stop.",
      "ja": "ハッシュ関数の出力した場合、「メッセージが長すぎる、」出力「のメッセージが長すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Encode the algorithm ID for the hash function and the hash value into an ASN.1 value of type DigestInfo (see Appendix A.2.4) with the Distinguished Encoding Rules (DER), where the type DigestInfo has the syntax",
      "ja": "2. DigestInfo構文を有する場合、識別符号化規則（DER）と（付録A.2.4を参照）タイプDigestInfoのASN.1値にハッシュ関数のアルゴリズムIDとハッシュ値をエンコード"
    },
    {
      "indent": 6,
      "text": "DigestInfo ::= SEQUENCE {\n    digestAlgorithm AlgorithmIdentifier,\n    digest OCTET STRING\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The first field identifies the hash function and the second contains the hash value. Let T be the DER encoding of the DigestInfo value (see the notes below) and let tLen be the length in octets of T.",
      "ja": "最初のフィールドは、ハッシュ関数を識別し、第二のハッシュ値を含みます。 TはDigestInfo値のDERエンコーディングとする（下記の注意事項を参照）、TLENはT.のオクテットの長さであるとします"
    },
    {
      "indent": 3,
      "text": "3. If emLen < tLen + 11, output \"intended encoded message length too short\" and stop.",
      "ja": "3.「短すぎる符号化されたメッセージの長さを意図」emLen <TLEN + 11、出力Ifと止めます。"
    },
    {
      "indent": 3,
      "text": "4. Generate an octet string PS consisting of emLen - tLen - 3 octets with hexadecimal value 0xff. The length of PS will be at least 8 octets.",
      "ja": "TLEN  -   -  16進値の0xFFと3つのオクテット4 emLenからなるオクテット列PSを生成します。 PSの長さは少なくとも8つのオクテットになります。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as",
      "ja": "5.連結しPS、DERエンコーディングT、およびなどのコード化されたメッセージEMを形成する他のパディング"
    },
    {
      "indent": 9,
      "text": "EM = 0x00 || 0x01 || PS || 0x00 || T.",
      "ja": "EMは$ 00を= || 0x01の|| PS || 0x00の|| T."
    },
    {
      "indent": 3,
      "text": "6. Output EM.",
      "section_title": true,
      "ja": "6.出力EM。"
    },
    {
      "indent": 3,
      "text": "Notes.",
      "ja": "ノート。"
    },
    {
      "indent": 3,
      "text": "1. For the six hash functions mentioned in Appendix B.1, the DER encoding T of the DigestInfo value is equal to the following:",
      "ja": "付録B.1で述べた6つのハッシュ関数、DigestInfo値のDER符号化Tについて1.以下に等しいです。"
    },
    {
      "indent": 6,
      "text": "MD2: (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04 10 || H. MD5: (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04 10 || H. SHA-1: (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H. SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H. SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30 || H. SHA-512: (0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H.",
      "ja": "MD2：0D（0X）30 20 30 0C 06 08 2A 86 48 86 F7 02 05 00 04 10 02 || H. MD5：02 05 05 00 04 10 0D（0X）30 20 30 0C 06 08 2A 86 48 86 F7 || H. SHA-1：（0X）30 21 30 09 06 05 0E 2B 03 02 1A 05 00 04 14 || H. SHA-256：（0X）30 31 30 0D 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H. SHA-384：（0X）30 41 30 0D 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30 || H. SHA-512：（0X）30 51 30 0D 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H."
    },
    {
      "indent": 3,
      "text": "2. In version 1.5 of this document, T was defined as the BER encoding, rather than the DER encoding, of the DigestInfo value. In particular, it is possible - at least in theory - that the verification operation defined in this document (as well as in version 2.0) rejects a signature that is valid with respect to the specification given in PKCS #1 v1.5. This occurs if other rules than DER are applied to DigestInfo (e.g., an indefinite length encoding of the underlying SEQUENCE type). While this is unlikely to be a concern in practice, a cautious implementer may choose to employ a verification operation based on a BER decoding operation as specified in PKCS #1 v1.5. In this manner, compatibility with any valid implementation based on PKCS #1 v1.5 is obtained. Such a verification operation should indicate whether the underlying BER encoding is a DER encoding and hence whether the signature is valid with respect to the specification given in this document.",
      "ja": "この文書のバージョン1.5 2.は、TはDigestInfo値のBER符号化ではなく、DERエンコーディング、と定義しました。特に、それは可能である - 少なくとも理論的に - （バージョン2.0ならびに）本書で定義された検証動作は、PKCS＃1 V1.5で指定された仕様に対して有効な署名を拒否していること。 DER以外のルールが（例えば、基礎となるSEQUENCE型の不定長符号化）DigestInfoに適用される場合に発生します。これは実際には心配なさそうですが、慎重な実装は、PKCS＃1 V1.5で指定されたBERデコード操作に基づいて検証作業を採用することもできます。このようにして、PKCS＃1 V1.5に基づいて、任意の有効な実装との互換性が得られます。そのような検証動作は、基礎となるBERエンコーディングが署名はこの文書で指定された仕様に対して有効であるかどうか、したがってDER符号化であるかどうかを示すべきです。"
    },
    {
      "indent": 0,
      "text": "Appendix A. ASN.1 syntax",
      "ja": "付録A. ASN.1構文"
    },
    {
      "indent": 0,
      "text": "A.1 RSA key representation",
      "ja": "A.1 RSAキー表現"
    },
    {
      "indent": 3,
      "text": "This section defines ASN.1 object identifiers for RSA public and private keys, and defines the types RSAPublicKey and RSAPrivateKey. The intended application of these definitions includes X.509 certificates, PKCS #8 [46], and PKCS #12 [47].",
      "ja": "このセクションでは、RSA公開鍵と秘密鍵のASN.1オブジェクト識別子を定義し、タイプのRSAPublicKeyとRSAPrivateKeyを定義します。これらの定義の意図された用途は、X.509証明書、PKCS＃8 [46]、およびPKCS＃12 [47]を含みます。"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption identifies RSA public and private keys as defined in Appendices A.1.1 and A.1.2. The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type NULL.",
      "ja": "付録のA.1.1及びA.1.2に定義されているオブジェクト識別子rsaEncryptionは、RSA公開鍵と秘密鍵を識別する。タイプのAlgorithmIdentifierの価値のこのOIDに関連したパラメータフィールドは、タイプNULLの値を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The definitions in this section have been extended to support multi-prime RSA, but are backward compatible with previous versions.",
      "ja": "このセクションの定義は、マルチプライムRSAをサポートするように拡張が、以前のバージョンとの下位互換性がありますされています。"
    },
    {
      "indent": 0,
      "text": "A.1.1 RSA public key syntax",
      "ja": "A.1.1 RSA公開鍵構文"
    },
    {
      "indent": 3,
      "text": "An RSA public key should be represented with the ASN.1 type RSAPublicKey:",
      "ja": "RSA公開鍵はASN.1タイプのRSAPublicKeyで表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "RSAPublicKey ::= SEQUENCE {\n    modulus           INTEGER,  -- n\n    publicExponent    INTEGER   -- e\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPublicKey have the following meanings:",
      "ja": "タイプのRSAPublicKeyのフィールドは以下の意味があります。"
    },
    {
      "indent": 4,
      "text": "* modulus is the RSA modulus n.",
      "ja": "*モジュラスは、RSAモジュラスNです。"
    },
    {
      "indent": 4,
      "text": "* publicExponent is the RSA public exponent e.",
      "ja": "* publicExponentは、RSA公開指数eです。"
    },
    {
      "indent": 0,
      "text": "A.1.2 RSA private key syntax",
      "ja": "A.1.2 RSA秘密鍵の構文"
    },
    {
      "indent": 3,
      "text": "An RSA private key should be represented with the ASN.1 type RSAPrivateKey:",
      "ja": "RSA秘密鍵はASN.1タイプのRSAPrivateKeyで表現する必要があります。"
    },
    {
      "indent": 6,
      "text": "RSAPrivateKey ::= SEQUENCE {\n    version           Version,\n    modulus           INTEGER,  -- n\n    publicExponent    INTEGER,  -- e\n    privateExponent   INTEGER,  -- d\n    prime1            INTEGER,  -- p\n    prime2            INTEGER,  -- q\n    exponent1         INTEGER,  -- d mod (p-1)\n    exponent2         INTEGER,  -- d mod (q-1)\n    coefficient       INTEGER,  -- (inverse of q) mod p\n    otherPrimeInfos   OtherPrimeInfos OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPrivateKey have the following meanings:",
      "ja": "型RSAPrivateKeyの各フィールドの意味は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "* version is the version number, for compatibility with future revisions of this document. It shall be 0 for this version of the document, unless multi-prime is used, in which case it shall be 1.",
      "ja": "*バージョンは、このドキュメントの今後の改正との互換性のためのバージョン番号です。マルチプライムが使用されていない限りそれは1でなければならない、その場合には、ドキュメントのこのバージョンのため0でなければなりません。"
    },
    {
      "indent": 12,
      "text": "Version ::= INTEGER { two-prime(0), multi(1) }\n   (CONSTRAINED BY\n   {-- version must be multi if otherPrimeInfos present --})",
      "raw": true
    },
    {
      "indent": 4,
      "text": "* modulus is the RSA modulus n.",
      "ja": "*モジュラスは、RSAモジュラスNです。"
    },
    {
      "indent": 4,
      "text": "* publicExponent is the RSA public exponent e.",
      "ja": "* publicExponentは、RSA公開指数eです。"
    },
    {
      "indent": 4,
      "text": "* privateExponent is the RSA private exponent d.",
      "ja": "* privateExponentは、RSA秘密指数dです。"
    },
    {
      "indent": 4,
      "text": "* prime1 is the prime factor p of n.",
      "ja": "* prime1は、nの素因数pがあります。"
    },
    {
      "indent": 4,
      "text": "* prime2 is the prime factor q of n.",
      "ja": "* prime2は、nの素因数qがあります。"
    },
    {
      "indent": 4,
      "text": "* exponent1 is d mod (p - 1).",
      "ja": "* exponent1あるDのMOD（P  -  1）。"
    },
    {
      "indent": 4,
      "text": "* exponent2 is d mod (q - 1).",
      "ja": "* exponent2あるDのMOD（Q  -  1）。"
    },
    {
      "indent": 4,
      "text": "* coefficient is the CRT coefficient q^(-1) mod p.",
      "ja": "（ -  1）MOD P *係数は、CRT係数q ^です。"
    },
    {
      "indent": 4,
      "text": "* otherPrimeInfos contains the information for the additional primes r_3, ..., r_u, in order. It shall be omitted if version is 0 and shall contain at least one instance of OtherPrimeInfo if version is 1.",
      "ja": "* otherPrimeInfosは順番に、追加の素数r_3のための情報が含まれています...、r_u。バージョンが0であり、バージョンが1の場合OtherPrimeInfoの少なくとも1つのインスタンスを含まなければならない場合には省略するものとします。"
    },
    {
      "indent": 9,
      "text": "OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo",
      "raw": true
    },
    {
      "indent": 9,
      "text": "OtherPrimeInfo ::= SEQUENCE {\n    prime             INTEGER,  -- ri\n    exponent          INTEGER,  -- di\n    coefficient       INTEGER   -- ti\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type OtherPrimeInfo have the following meanings:",
      "ja": "タイプOtherPrimeInfoのフィールドは以下の意味があります。"
    },
    {
      "indent": 4,
      "text": "* prime is a prime factor r_i of n, where i >= 3.",
      "ja": "*プライムは、Nの素因数R_iを、I> = 3です。"
    },
    {
      "indent": 4,
      "text": "* exponent is d_i = d mod (r_i - 1).",
      "ja": "*指数はD_Iある= DのMOD（R_iを -  1）。"
    },
    {
      "indent": 4,
      "text": "* coefficient is the CRT coefficient t_i = (r_1 * r_2 * ... * r_(i-1))^(-1) mod r_i.",
      "ja": "（ -  1）MOD R_iを*係数は、CRT係数T_I =（R_1 * R_2 * ... * R_（I-1））^です。"
    },
    {
      "indent": 3,
      "text": "Note. It is important to protect the RSA private key against both disclosure and modification. Techniques for such protection are outside the scope of this document. Methods for storing and distributing private keys and other cryptographic data are described in PKCS #12 and #15.",
      "ja": "注意。公開と修正の両方に対してRSA秘密鍵を保護することが重要です。このような保護のための技術は、この文書の範囲外です。格納および秘密鍵や他の暗号データ​​を配信するための方法は、PKCS＃12と＃15に記述されています。"
    },
    {
      "indent": 0,
      "text": "A.2 Scheme identification",
      "ja": "A.2スキームの識別"
    },
    {
      "indent": 3,
      "text": "This section defines object identifiers for the encryption and signature schemes. The schemes compatible with PKCS #1 v1.5 have the same definitions as in PKCS #1 v1.5. The intended application of these definitions includes X.509 certificates and PKCS #7.",
      "ja": "このセクションでは、暗号化および署名スキームのためのオブジェクト識別子を定義します。 PKCS＃1 V1.5と互換性スキームは、PKCS＃1 V1.5と同じ定義を有します。これらの定義の意図する用途には、X.509証明書およびPKCS＃7を含んでいます。"
    },
    {
      "indent": 3,
      "text": "Here are type identifier definitions for the PKCS #1 OIDs:",
      "ja": "ここでPKCS＃1のOIDのためのタイプ識別子の定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID rsaEncryption              PARAMETERS NULL } |\n    { OID md2WithRSAEncryption       PARAMETERS NULL } |\n    { OID md5WithRSAEncryption       PARAMETERS NULL } |\n    { OID sha1WithRSAEncryption      PARAMETERS NULL } |\n    { OID sha256WithRSAEncryption    PARAMETERS NULL } |\n    { OID sha384WithRSAEncryption    PARAMETERS NULL } |\n    { OID sha512WithRSAEncryption    PARAMETERS NULL } |\n    { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |\n    PKCS1PSourceAlgorithms                             |\n    { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params } ,\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2.1 RSAES-OAEP",
      "ja": "A.2.1 RSAES-OAEP"
    },
    {
      "indent": 3,
      "text": "The object identifier id-RSAES-OAEP identifies the RSAES-OAEP encryption scheme.",
      "ja": "オブジェクト識別子ID-RSAES-OAEPはRSAES-OAEP暗号化方式を識別する。"
    },
    {
      "indent": 6,
      "text": "id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type RSAES-OAEP-params:",
      "ja": "タイプのAlgorithmIdentifierの価値のこのOIDに関連したパラメータフィールドは、タイプRSAES-OAEP-のparamsの値を持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "RSAES-OAEP-params ::= SEQUENCE {\n    hashAlgorithm     [0] HashAlgorithm    DEFAULT sha1,\n    maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1,\n    pSourceAlgorithm  [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSAES-OAEP-params have the following meanings:",
      "ja": "タイプRSAES-OAEP-のparamsの分野には、以下の意味を持っています："
    },
    {
      "indent": 4,
      "text": "* hashAlgorithm identifies the hash function. It shall be an algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms. For a discussion of supported hash functions, see Appendix B.1.",
      "ja": "* hashAlgorithmは、ハッシュ関数を識別します。これは、設定されたOAEP-PSSDigestAlgorithmsでOIDを持つアルゴリズムのIDでなければなりません。サポートされるハッシュ関数の議論については、付録B.1を参照してください。"
    },
    {
      "indent": 9,
      "text": "HashAlgorithm ::= AlgorithmIdentifier {\n   {OAEP-PSSDigestAlgorithms}\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-sha1 PARAMETERS NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS NULL }|\n    { OID id-sha512 PARAMETERS NULL },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The default hash function is SHA-1:",
      "ja": "デフォルトのハッシュ関数はSHA-1です。"
    },
    {
      "indent": 9,
      "text": "sha1    HashAlgorithm ::= {\n    algorithm   id-sha1,\n    parameters  SHA1Parameters : NULL\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "SHA1Parameters ::= NULL",
      "raw": true
    },
    {
      "indent": 4,
      "text": "* maskGenAlgorithm identifies the mask generation function. It shall be an algorithm ID with an OID in the set PKCS1MGFAlgorithms, which for this version shall consist of id-mgf1, identifying the MGF1 mask generation function (see Appendix B.2.1). The parameters field associated with id-mgf1",
      "ja": "* maskGenAlgorithmはマスク生成関数を特定します。これは、このバージョンのMGF1マスク生成機能（付録B.2.1参照）を識別するID-MGF1で構成するセットPKCS1MGFAlgorithmsでOIDとアルゴリズムIDでなければなりません。 ID-MGF1に関連するパラメータフィールド"
    },
    {
      "indent": 6,
      "text": "shall be an algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms, identifying the hash function on which MGF1 is based.",
      "ja": "MGF1が基づいているハッシュ関数の識別、設定OAEP-PSSDigestAlgorithmsにおけるOIDとアルゴリズムIDでなければなりません。"
    },
    {
      "indent": 9,
      "text": "MaskGenAlgorithm ::= AlgorithmIdentifier {\n   {PKCS1MGFAlgorithms}\n}\nPKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-mgf1 PARAMETERS HashAlgorithm },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The default mask generation function is MGF1 with SHA-1:",
      "ja": "デフォルトのマスク生成関数はSHA-1とMGF1です。"
    },
    {
      "indent": 9,
      "text": "mgf1SHA1    MaskGenAlgorithm ::= {\n    algorithm   id-mgf1,\n    parameters  HashAlgorithm : sha1\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "* pSourceAlgorithm identifies the source (and possibly the value) of the label L. It shall be an algorithm ID with an OID in the set PKCS1PSourceAlgorithms, which for this version shall consist of id-pSpecified, indicating that the label is specified explicitly. The parameters field associated with id-pSpecified shall have a value of type OCTET STRING, containing the label. In previous versions of this specification, the term \"encoding parameters\" was used rather than \"label\", hence the name of the type below.",
      "ja": "* pSourceAlgorithmは、このバージョンのラベルを明示的に指定されていることを示す、ID-pSpecifiedで構成するセットPKCS1PSourceAlgorithmsでOIDとアルゴリズムIDでなければならないラベルLの源（および恐らく値）を特定します。 ID-pSpecifiedに関連するパラメータのフィールドは、ラベルを含む、タイプOCTET文字列の値を持たなければなりません。本明細書の以前のバージョンでは、用語「符号化パラメータは、」むしろ「標識」は、以下のタイプのその名よりも使用しました。"
    },
    {
      "indent": 9,
      "text": "PSourceAlgorithm ::= AlgorithmIdentifier {\n   {PKCS1PSourceAlgorithms}\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-pSpecified PARAMETERS EncodingParameters },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }",
      "raw": true
    },
    {
      "indent": 9,
      "text": "EncodingParameters ::= OCTET STRING(SIZE(0..MAX))",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The default label is an empty string (so that lHash will contain the hash of the empty string):",
      "ja": "デフォルトのラベルは、空の文字列（lHashが空の文字列のハッシュが含まれていますように）次のとおりです。"
    },
    {
      "indent": 9,
      "text": "pSpecifiedEmpty    PSourceAlgorithm ::= {\n    algorithm   id-pSpecified,\n    parameters  EncodingParameters : emptyString\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "emptyString    EncodingParameters ::= ''H",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If all of the default values of the fields in RSAES-OAEP-params are used, then the algorithm identifier will have the following value:",
      "ja": "RSAES-OAEP-のparams内のフィールドのデフォルト値のすべてが使用されている場合には、アルゴリズム識別子は、次の値を持つことになります。"
    },
    {
      "indent": 9,
      "text": "rSAES-OAEP-Default-Identifier  RSAES-AlgorithmIdentifier ::= {\n    algorithm   id-RSAES-OAEP,\n    parameters  RSAES-OAEP-params : {\n        hashAlgorithm       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        pSourceAlgorithm    pSpecifiedEmpty\n    }\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier {\n   {PKCS1Algorithms}\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2.2 RSAES-PKCS1-v1_5",
      "ja": "A.2.2のRSAES-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption (see Appendix A.1) identifies the RSAES-PKCS1-v1_5 encryption scheme. The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type NULL. This is the same as in PKCS #1 v1.5.",
      "ja": "オブジェクト識別子rsaEncryptionは（付録A.1参照）RSAES-PKCS1-v1_5の暗号化スキームを識別する。タイプのAlgorithmIdentifierの価値のこのOIDに関連したパラメータフィールドは、タイプNULLの値を持たなければなりません。これは、PKCS＃1 v1.5のと同じです。"
    },
    {
      "indent": 6,
      "text": "rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2.3 RSASSA-PSS",
      "ja": "A.2.3 RSASSA-PSS"
    },
    {
      "indent": 3,
      "text": "The object identifier id-RSASSA-PSS identifies the RSASSA-PSS encryption scheme.",
      "ja": "オブジェクト識別子ID-RSASSA-PSSはRSASSA-PSSの暗号化スキームを識別する。"
    },
    {
      "indent": 6,
      "text": "id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type RSASSA-PSS-params:",
      "ja": "タイプのAlgorithmIdentifierの値にこのOIDに関連したパラメータフィールドは、タイプRSASSA-PSS-のparamsの値を持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "RSASSA-PSS-params ::= SEQUENCE {\n    hashAlgorithm      [0] HashAlgorithm    DEFAULT sha1,\n    maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1,\n    saltLength         [2] INTEGER          DEFAULT 20,\n    trailerField       [3] TrailerField     DEFAULT trailerFieldBC\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSASSA-PSS-params have the following meanings:",
      "ja": "タイプRSASSA-PSS-のparamsの分野には、以下の意味を持っています："
    },
    {
      "indent": 4,
      "text": "* hashAlgorithm identifies the hash function. It shall be an algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms (see Appendix A.2.1). The default hash function is SHA-1.",
      "ja": "* hashAlgorithmは、ハッシュ関数を識別します。これは、設定されたOAEP-PSSDigestAlgorithms（付録A.2.1を参照）でOIDを持つアルゴリズムのIDでなければなりません。デフォルトのハッシュ関数はSHA-1です。"
    },
    {
      "indent": 4,
      "text": "* maskGenAlgorithm identifies the mask generation function. It shall be an algorithm ID with an OID in the set",
      "ja": "* maskGenAlgorithmはマスク生成関数を特定します。これは、セット内のOIDを持つアルゴリズムIDでなければなりません"
    },
    {
      "indent": 6,
      "text": "PKCS1MGFAlgorithms (see Appendix A.2.1). The default mask generation function is MGF1 with SHA-1. For MGF1 (and more generally, for other mask generation functions based on a hash function), it is recommended that the underlying hash function be the same as the one identified by hashAlgorithm; see Note 2 in Section 9.1 for further comments.",
      "ja": "PKCS1MGFAlgorithms（付録A.2.1を参照）。デフォルトマスク生成関数は、SHA-1とMGF1です。 MGF1ため（より一般的と、ハッシュ関数に基づいて、他のマスク生成機能のため）には、基礎となるハッシュ関数がhashAlgorithmにより同定したものと同じであることが推奨されます。さらに、コメントについては、セクション9.1で注2を参照してください。"
    },
    {
      "indent": 4,
      "text": "* saltLength is the octet length of the salt. It shall be an integer. For a given hashAlgorithm, the default value of saltLength is the octet length of the hash value. Unlike the other fields of type RSASSA-PSS-params, saltLength does not need to be fixed for a given RSA key pair.",
      "ja": "* saltLengthは、塩のオクテット長です。これは、整数でなければなりません。所与hashAlgorithmため、saltLengthのデフォルト値は、ハッシュ値のオクテット長です。タイプRSASSA-PSS-のparamsの他の分野とは異なり、saltLengthは、与えられたRSA鍵ペアのために固定する必要はありません。"
    },
    {
      "indent": 4,
      "text": "* trailerField is the trailer field number, for compatibility with the draft IEEE P1363a [27]. It shall be 1 for this version of the document, which represents the trailer field with hexadecimal value 0xbc. Other trailer fields (including the trailer field HashID || 0xcc in IEEE P1363a) are not supported in this document.",
      "ja": "* trailerFieldは、ドラフトIEEE P1363a [27]との互換性のためのトレーラフィールドの数、です。これは、16進数値の0xBCとトレーラフィールドを表す文書のこのバージョンの1でなければなりません。 （IEEE P1363aにおけるトレーラフィールドHashID || 0xccを含む）その他のトレーラーフィールドは、この文書ではサポートされていません。"
    },
    {
      "indent": 9,
      "text": "TrailerField ::= INTEGER { trailerFieldBC(1) }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If the default values of the hashAlgorithm, maskGenAlgorithm, and trailerField fields of RSASSA-PSS-params are used, then the algorithm identifier will have the following value:",
      "ja": "RSASSA-PSS-のparamsのhashAlgorithm、maskGenAlgorithm、およびtrailerFieldフィールドのデフォルト値が使用されている場合には、アルゴリズム識別子は、次の値を持つことになります。"
    },
    {
      "indent": 9,
      "text": "rSASSA-PSS-Default-Identifier  RSASSA-AlgorithmIdentifier ::= {\n    algorithm   id-RSASSA-PSS,\n    parameters  RSASSA-PSS-params : {\n        hashAlgorithm       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        saltLength          20,\n        trailerField        trailerFieldBC\n    }\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "RSASSA-AlgorithmIdentifier ::=\n    AlgorithmIdentifier { {PKCS1Algorithms} }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note. In some applications, the hash function underlying a signature scheme is identified separately from the rest of the operations in the signature scheme. For instance, in PKCS #7 [45], a hash function identifier is placed before the message and a \"digest encryption\" algorithm identifier (indicating the rest of the operations) is carried with the signature. In order for PKCS #7 to support the RSASSA-PSS signature scheme, an object identifier would need to be defined for the operations in RSASSA-PSS after the hash function (analogous to the RSAEncryption OID for the RSASSA-PKCS1-v1_5 scheme). S/MIME CMS [25] takes a different approach. Although a hash function identifier is placed before the message, an algorithm identifier for the full signature scheme may be carried with a CMS signature (this is done for DSA signatures). Following this convention, the id-RSASSA-PSS OID can be used to identify RSASSA-PSS signatures in CMS. Since CMS is considered the successor to PKCS #7 and new developments such as the addition of support for RSASSA-PSS will be pursued with respect to CMS rather than PKCS #7, an OID for the \"rest of\" RSASSA-PSS is not defined in this version of PKCS #1.",
      "ja": "注意。いくつかの用途では、署名方式の基礎となるハッシュ関数は署名方式における操作の残りの部分とは別個に識別されます。例えば、PKCS＃7 [45]において、ハッシュ関数識別子は、メッセージの前に配置され（操作の残りの部分を示す）「暗号化ダイジェスト」アルゴリズム識別子は署名で実施されます。 RSASSA-PSS署名方式をサポートするためにPKCS＃7ためには、オブジェクト識別子は、（RSASSA-PKCS1-v1_5のスキームのRSAEncryption OIDに類似）ハッシュ関数の後RSASSA-PSSの動作のために定義される必要があるであろう。 S / MIME CMS [25]別のアプローチをとります。ハッシュ関数識別子がメッセージの前に配置されているが、完全な署名方式のためのアルゴリズム識別子は（これはDSA署名について行われる）CMS署名で実施することができます。この大会に続き、ID-RSASSA-PSS OIDは、CMSにRSASSA-PSS署名を識別するために使用することができます。 CMSは、PKCS＃7の後継とみなされ、そのようなRSASSA-PSSのサポートの追加など新たな開発はRSASSA-PSS「の残り」のOIDが定義されていない、CMSに対してではなくPKCS＃7で追求するためPKCS＃1のこのバージョンインチ"
    },
    {
      "indent": 0,
      "text": "A.2.4 RSASSA-PKCS1-v1_5",
      "ja": "A.2.4 RSASSA-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "The object identifier for RSASSA-PKCS1-v1_5 shall be one of the following. The choice of OID depends on the choice of hash algorithm: MD2, MD5, SHA-1, SHA-256, SHA-384, or SHA-512. Note that if either MD2 or MD5 is used, then the OID is just as in PKCS #1 v1.5. For each OID, the parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type NULL. The OID should be chosen in accordance with the following table:",
      "ja": "RSASSA-PKCS1-v1_5のためのオブジェクト識別子は、次のいずれかでなければなりません。 MD2、MD5、SHA-1、SHA-256、SHA-384、またはSHA-512：OIDの選択は、ハッシュアルゴリズムの選択に依存します。 MD2またはMD5のいずれかが使用されている場合、OIDはちょうどPKCS＃1 v1.5ののようであることに注意してください。各OIDのために、タイプのAlgorithmIdentifierの値でこのOIDに関連付けられたパラメータフィールドは、タイプNULLの値を持たなければなりません。 OIDは、次の表に応じて選択する必要があります。"
    },
    {
      "indent": 6,
      "text": "Hash algorithm   OID\n--------------------------------------------------------\nMD2              md2WithRSAEncryption    ::= {pkcs-1 2}\nMD5              md5WithRSAEncryption    ::= {pkcs-1 4}\nSHA-1            sha1WithRSAEncryption   ::= {pkcs-1 5}\nSHA-256          sha256WithRSAEncryption ::= {pkcs-1 11}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "SHA-384          sha384WithRSAEncryption ::= {pkcs-1 12}\nSHA-512          sha512WithRSAEncryption ::= {pkcs-1 13}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The EMSA-PKCS1-v1_5 encoding method includes an ASN.1 value of type DigestInfo, where the type DigestInfo has the syntax",
      "ja": "EMSA-PKCS1-v1_5の符号化方式は、タイプDigestInfo構文を有するタイプDigestInfoのASN.1値を含みます"
    },
    {
      "indent": 6,
      "text": "DigestInfo ::= SEQUENCE {\n    digestAlgorithm DigestAlgorithm,\n    digest OCTET STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "digestAlgorithm identifies the hash function and shall be an algorithm ID with an OID in the set PKCS1-v1-5DigestAlgorithms. For a discussion of supported hash functions, see Appendix B.1.",
      "ja": "digestAlgorithmは、ハッシュ関数を特定し、セットPKCS1-v1-5DigestAlgorithmsにおけるOIDとアルゴリズムIDでなければなりません。サポートされるハッシュ関数の議論については、付録B.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "DigestAlgorithm ::=\n    AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-md2 PARAMETERS NULL    }|\n    { OID id-md5 PARAMETERS NULL    }|\n    { OID id-sha1 PARAMETERS NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS NULL }|\n    { OID id-sha512 PARAMETERS NULL }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. Supporting techniques",
      "ja": "付録B.サポート技術"
    },
    {
      "indent": 3,
      "text": "This section gives several examples of underlying functions supporting the encryption schemes in Section 7 and the encoding methods in Section 9. A range of techniques is given here to allow compatibility with existing applications as well as migration to new techniques. While these supporting techniques are appropriate for applications to implement, none of them is required to be implemented. It is expected that profiles for PKCS #1 v2.1 will be developed that specify particular supporting techniques.",
      "ja": "このセクションでは、セクション7で暗号化方式をサポートする基礎となる機能のいくつかの例を与え、第9の符号化方法は、技術の範囲は、既存のアプリケーションと同様に、新しい技術への移行との互換性を可能にするためにここに与えられています。これらの支援技術は実装するアプリケーションに適していますが、それらのどれを実装する必要がありません。 PKCS＃1 v2.1のためのプロファイルは、それが特定の支援技術を指定する開発されると予想されます。"
    },
    {
      "indent": 3,
      "text": "This section also gives object identifiers for the supporting techniques.",
      "ja": "このセクションでは、支援技術のためのオブジェクト識別子を提供します。"
    },
    {
      "indent": 0,
      "text": "B.1 Hash functions",
      "ja": "B.1ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "Hash functions are used in the operations contained in Sections 7 and 9. Hash functions are deterministic, meaning that the output is completely determined by the input. Hash functions take octet strings of variable length, and generate fixed length octet strings.",
      "ja": "ハッシュ関数は、セクション7,9ハッシュ関数に含まれる操作に使用される出力は、完全に入力することによって決定されることを意味する、決定論的です。ハッシュ関数は、可変長のオクテット文字列を取り、固定長のオクテット文字列を生成します。"
    },
    {
      "indent": 3,
      "text": "The hash functions used in the operations contained in Sections 7 and 9 should generally be collision-resistant. This means that it is infeasible to find two distinct inputs to the hash function that produce the same output. A collision-resistant hash function also has the desirable property of being one-way; this means that given an output, it is infeasible to find an input whose hash is the specified output. In addition to the requirements, the hash function should yield a mask generation function (Appendix B.2) with pseudorandom output.",
      "ja": "セクション7,9に含まれる操作に使用されるハッシュ関数は、一般に、衝突耐性であるべきです。同じ出力を生成するハッシュ関数への2つの異なる入力を見つけることは不可能であることを意味します。衝突困難ハッシュ関数は、一方向であるという望ましい特性を有しています。これは、出力が与えられると、そのハッシュ指定された出力である入力を見つけることが不可能であることを意味します。要件に加えて、ハッシュ関数は擬似ランダム出力を有するマスク生成関数（付録B.2）を得なければなりません。"
    },
    {
      "indent": 3,
      "text": "Six hash functions are given as examples for the encoding methods in this document: MD2 [33], MD5 [41], SHA-1 [38], and the proposed algorithms SHA-256, SHA-384, and SHA-512 [39]. For the RSAES-OAEP encryption scheme and EMSA-PSS encoding method, only SHA-1 and SHA-256/384/512 are recommended. For the EMSA-PKCS1-v1_5 encoding method, SHA-1 or SHA-256/384/512 are recommended for new applications. MD2 and MD5 are recommended only for compatibility with existing applications based on PKCS #1 v1.5.",
      "ja": "六つのハッシュ関数は、この文書に記載されている符号化方式のための例として与えられている：MD2 [33]、MD5 [41]、SHA-1 [38]、及び提案されたアルゴリズムSHA-256、SHA-384およびSHA-512 [39 ]。 RSAES-OAEP暗号化方式とEMSA-PSS符号化方式のため、唯一のSHA-1、SHA-256/512分の384が推奨されます。 EMSA-PKCS1-v1_5の符号化方法については、SHA-1やSHA-256/512分の384は、新たなアプリケーションのために推奨されています。 MD2とMD5だけPKCS＃1 v1.5のに基づいて既存のアプリケーションとの互換性のために推奨されています。"
    },
    {
      "indent": 3,
      "text": "The object identifiers id-md2, id-md5, id-sha1, id-sha256, id-sha384, and id-sha512, identify the respective hash functions:",
      "ja": "オブジェクト識別子ID-MD2、ID-MD5、ID-SHA1、ID-SHA256、ID-SHA384、及びID-SHA512は、それぞれのハッシュ関数を識別する。"
    },
    {
      "indent": 6,
      "text": "id-md2      OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549)\n    digestAlgorithm(2) 2\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "id-md5      OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549)\n    digestAlgorithm(2) 5\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "id-sha1    OBJECT IDENTIFIER ::= {\n    iso(1) identified-organization(3) oiw(14) secsig(3)\n    algorithms(2) 26\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "id-sha256    OBJECT IDENTIFIER ::= {\n    joint-iso-itu-t(2) country(16) us(840) organization(1)\n    gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "id-sha384    OBJECT IDENTIFIER ::= {\n    joint-iso-itu-t(2) country(16) us(840) organization(1)\n    gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2\n} id-sha512    OBJECT IDENTIFIER ::= {\n    joint-iso-itu-t(2) country(16) us(840) organization(1)\n    gov(101) csor(3) nistalgorithm(4) hashalgs(2) 3\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field associated with id-md2 and id-md5 in a value of type AlgorithmIdentifier shall have a value of type NULL.",
      "ja": "タイプのAlgorithmIdentifierの値でID-MD2及びID-MD5に関連するパラメータのフィールドは、タイプNULLの値を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameters field associated with id-sha1, id-sha256, id-sha384, and id-sha512 should be omitted, but if present, shall have a value of type NULL.",
      "ja": "ID-SHA1、ID-SHA256、ID-SHA384、及びID-SHA512に関連するパラメータのフィールドを省略しなければならないが、存在する場合、タイプNULLの値を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note. Version 1.5 of PKCS #1 also allowed for the use of MD4 in signature schemes. The cryptanalysis of MD4 has progressed significantly in the intervening years. For example, Dobbertin [18] demonstrated how to find collisions for MD4 and that the first two rounds of MD4 are not one-way [20]. Because of these results and others (e.g., [8]), MD4 is no longer recommended. There have also been advances in the cryptanalysis of MD2 and MD5, although not enough to warrant removal from existing applications. Rogier and Chauvaud [43] demonstrated how to find collisions in a modified version of MD2. No one has demonstrated how to find collisions for the full MD5 algorithm, although partial results have been found (e.g., [9][19]).",
      "ja": "注意。 PKCS＃1のバージョン1.5はまた、署名方式におけるMD4の使用を可能にしました。 MD4の暗号解読は、介在年で大幅に進歩しています。例えば、[20] Dobbertin [18] MD4のために衝突を見つける方法を実証し、MD4の最初の2ラウンドは、一方向ではないこと。なぜなら、これらの結果と他の（例えば、[8]）、MD4はもはや推奨されません。また、既存のアプリケーションから除去することを保証するものの十分ではなく、MD2とMD5の暗号解読の進展がありました。ロジェとChauvaud [43] MD2の修正バージョンで衝突を見つける方法を実証しました。誰もが、部分的な結果が発見されているが、完全なMD5アルゴリズムの衝突を発見する方法を示さなかった（例えば、[9] [19]）。"
    },
    {
      "indent": 3,
      "text": "To address these concerns, SHA-1, SHA-256, SHA-384, or SHA-512 are recommended for new applications. As of today, the best (known) collision attacks against these hash functions are generic attacks with complexity 2^(L/2), where L is the bit length of the hash output. For the signature schemes in this document, a collision attack is easily translated into a signature forgery. Therefore, the value L / 2 should be at least equal to the desired security level in bits of the signature scheme (a security level of B bits means that the best attack has complexity 2^B). The same rule of thumb can be applied to RSAES-OAEP; it is recommended that the bit length of the seed (which is equal to the bit length of the hash output) be twice the desired security level in bits.",
      "ja": "これらの懸念に対処するために、SHA-1、SHA-256、SHA-384、またはSHA-512は、新しいアプリケーションのために推奨されています。今日のように、これらのハッシュ関数に対する最善の（既知の）衝突攻撃は、Lは、ハッシュ出力のビット長である複雑さ2 ^（L / 2）、との一般的な攻撃です。この文書の署名方式の場合は、衝突攻撃は簡単に署名偽造に翻訳されています。したがって、値L / 2（Bビットのセキュリティレベルが最高の攻撃が複雑2 ^ Bを有することを意味する）署名方式のビットで所望のセキュリティレベルに少なくとも等しくなければなりません。親指の同じルールがRSAES-OAEPに適用することができます。 （ハッシュ出力のビット長に等しい）シードのビット長がビットで二回、所望のセキュリティレベルであることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "B.2 Mask generation functions",
      "ja": "B.2マスク生成関数"
    },
    {
      "indent": 3,
      "text": "A mask generation function takes an octet string of variable length and a desired output length as input, and outputs an octet string of the desired length. There may be restrictions on the length of the input and output octet strings, but such bounds are generally very large. Mask generation functions are deterministic; the octet string output is completely determined by the input octet string. The output of a mask generation function should be pseudorandom: Given one part of the output but not the input, it should be infeasible to predict another part of the output. The provable security of RSAES-OAEP and RSASSA-PSS relies on the random nature of the output of the mask generation function, which in turn relies on the random nature of the underlying hash.",
      "ja": "マスク生成関数は、入力として、可変長と所望の出力長のオクテット列を受け取り、所望の長さのオクテット列を出力します。そこ入出力オクテット文字列の長さに制限があることが、そのような境界は、一般的に非常に大きいことがあります。マスク生成関数は決定されています。オクテットストリングの出力が完全に入力されたオクテットストリングによって決定されます。マスク生成関数の出力は、擬似ランダムであるべきである：一つの出力の一部ではなく、入力が与えられると、出力の他の一部を予測することが不可能であるべきです。 RSAES-OAEPとRSASSA-PSSの証明可能安全性は順番に基本的なハッシュのランダム性に依存しているマスク生成関数の出力のランダムな性質に依存しています。"
    },
    {
      "indent": 3,
      "text": "One mask generation function is given here: MGF1, which is based on a hash function. MGF1 coincides with the mask generation functions defined in IEEE Std 1363-2000 [26] and the draft ANSI X9.44 [1]. Future versions of this document may define other mask generation functions.",
      "ja": "一つのマスク生成関数は、ここで与えられる：ハッシュ関数に基づいてMGF1を、。 MGF1は、IEEE STD 1363から2000 [26]で定義されたマスク生成機能とドラフトANSI X9.44 [1]と一致します。この文書の将来のバージョンは、他のマスク生成関数を定義することができます。"
    },
    {
      "indent": 0,
      "text": "B.2.1 MGF1",
      "ja": "B.2.1 MGF1"
    },
    {
      "indent": 3,
      "text": "MGF1 is a Mask Generation Function based on a hash function.",
      "ja": "MGF1はハッシュ関数に基づいて、マスク生成関数です。"
    },
    {
      "indent": 3,
      "text": "MGF1 (mgfSeed, maskLen)",
      "ja": "MGF1（mgfSeed、maskLen）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octets of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: mgfSeed seed from which mask is generated, an octet string maskLen intended length in octets of the mask, at most 2^32 hLen",
      "ja": "入力：マスクは最大で2 ^ 32さhLen、オクテットストリングmaskLenマスクのオクテットの長さを意図し、生成されたmgfSeed種"
    },
    {
      "indent": 3,
      "text": "Output: mask mask, an octet string of length maskLen",
      "ja": "出力：マスクマスク、長さmaskLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Error: \"mask too long\"",
      "ja": "エラー：「マスクが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If maskLen > 2^32 hLen, output \"mask too long\" and stop.",
      "section_title": true,
      "ja": "1. maskLen> 2 ^ 32さhLen場合は、出力が \"長すぎるマスク\" と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Let T be the empty octet string.",
      "section_title": true,
      "ja": "2. Tが空のオクテット文字列とします。"
    },
    {
      "indent": 3,
      "text": "3. For counter from 0 to \\ceil (maskLen / hLen) - 1, do the following:",
      "ja": "0からの\\はceil（maskLen / hlen）フィールドにカウンタ3.  -  1、次の操作を行います。"
    },
    {
      "indent": 6,
      "text": "a. Convert counter to an octet string C of length 4 octets (see Section 4.1):",
      "ja": "A。長さが4つのオクテット（セクション4.1を参照）のオクテット列Cにカウンタを変換します。"
    },
    {
      "indent": 12,
      "text": "C = I2OSP (counter, 4) .",
      "ja": "C = I2OSP（カウンタ、4）。"
    },
    {
      "indent": 6,
      "text": "b. Concatenate the hash of the seed mgfSeed and C to the octet string T:",
      "ja": "B。オクテットストリングTにシードmgfSeed及びCのハッシュを連結します。"
    },
    {
      "indent": 12,
      "text": "T = T || Hash(mgfSeed || C) .",
      "ja": "T = T ||ハッシュ（mgfSeed || C）。"
    },
    {
      "indent": 3,
      "text": "4. Output the leading maskLen octets of T as the octet string mask.",
      "section_title": true,
      "ja": "4.出力オクテット文字列マスクとしてTの大手maskLenオクテット。"
    },
    {
      "indent": 3,
      "text": "The object identifier id-mgf1 identifies the MGF1 mask generation function:",
      "ja": "オブジェクト識別子ID-MGF1はMGF1マスク生成機能を識別する。"
    },
    {
      "indent": 3,
      "text": "id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type hashAlgorithm, identifying the hash function on which MGF1 is based.",
      "ja": "タイプのAlgorithmIdentifierの値でこのOIDに関連付けられたパラメータフィールドはMGF1が基づいているハッシュ関数の識別、タイプhashAlgorithmの値を持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix C. ASN.1 module",
      "ja": "付録C. ASN.1モジュール"
    },
    {
      "indent": 0,
      "text": "PKCS-1 { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) modules(0) pkcs-1(1) }",
      "ja": "PKCS-1 {ISO（1）部材本体（2）米国（840）RSADSI（113549）PKCS（1）PKCS-1（1）モジュール（0）PKCS-1（1）}"
    },
    {
      "indent": 0,
      "text": "-- $ Revision: 2.1r1 $",
      "ja": " -  $リビジョン：2.1r1の$"
    },
    {
      "indent": 0,
      "text": "-- This module has been checked for conformance with the ASN.1 -- standard by the OSS ASN.1 Tools",
      "ja": " - このモジュールは、ASN.1に準拠するためにチェックされている -  OSSのASN.1ツールによって標準"
    },
    {
      "indent": 0,
      "text": "DEFINITIONS EXPLICIT TAGS ::=",
      "raw": true
    },
    {
      "indent": 0,
      "text": "BEGIN",
      "ja": "ベギン"
    },
    {
      "indent": 0,
      "text": "-- EXPORTS ALL -- All types and values defined in this module are exported for use -- in other ASN.1 modules.",
      "ja": " - すべてのエクスポート - このモジュールで定義されたすべてのタイプと値を使用するためにエクスポートされている - 他のASN.1モジュールに。"
    },
    {
      "indent": 0,
      "text": "IMPORTS",
      "ja": "輸入"
    },
    {
      "indent": 0,
      "text": "id-sha256, id-sha384, id-sha512 FROM NIST-SHA2 { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) modules(0) sha2(1) };",
      "ja": "ID-SHA256、ID-SHA384、NIST-SHA2 {関節イソITU-TからID-SHA512（2）国（16）米国（840）組織（1）GOV（101）csor（3）nistalgorithm（4）モジュール（0）SHA2（1）}。"
    },
    {
      "indent": 0,
      "text": "-- ============================\n--   Basic object identifiers\n-- ============================",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- The DER encoding of this in hexadecimal is:\n-- (0x)06 08\n--        2A 86 48 86 F7 0D 01 01\n--\npkcs-1    OBJECT IDENTIFIER ::= {",
      "raw": true
    },
    {
      "indent": 0,
      "text": " iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }",
      "ja": "ISO（1）部材本体（2）米国（840）RSADSI（113549）PKCS（1）1}"
    },
    {
      "indent": 0,
      "text": "--\n-- When rsaEncryption is used in an AlgorithmIdentifier the\n-- parameters MUST be present and MUST be NULL.\n--\nrsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- When id-RSAES-OAEP is used in an AlgorithmIdentifier the\n-- parameters MUST be present and MUST be RSAES-OAEP-params.\n--\nid-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- When id-pSpecified is used in an AlgorithmIdentifier the\n-- parameters MUST be an OCTET STRING.\n--\nid-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- When id-RSASSA-PSS is used in an AlgorithmIdentifier the\n-- parameters MUST be present and MUST be RSASSA-PSS-params.\n--\nid-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- When the following OIDs are used in an AlgorithmIdentifier the\n-- parameters MUST be present and MUST be NULL.\n--\nmd2WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 2 }\nmd5WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 4 }\nsha1WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 5 }\nsha256WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 11 }\nsha384WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 12 }\nsha512WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 13 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- This OID really belongs in a module with the secsig OIDs.\n--\nid-sha1    OBJECT IDENTIFIER ::= {\n    iso(1) identified-organization(3) oiw(14) secsig(3)\n    algorithms(2) 26\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- OIDs for MD2 and MD5, allowed only in EMSA-PKCS1-v1_5.\n-- id-md2 OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 2\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "id-md5 OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2) 5\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- When id-mgf1 is used in an AlgorithmIdentifier the parameters MUST\n-- be present and MUST be a HashAlgorithm, for example sha1.\n--\nid-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ================\n--   Useful types\n-- ================",
      "raw": true
    },
    {
      "indent": 0,
      "text": "ALGORITHM-IDENTIFIER ::= CLASS {\n    &id    OBJECT IDENTIFIER  UNIQUE,\n    &Type  OPTIONAL\n}\n    WITH SYNTAX { OID &id [PARAMETERS &Type] }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Note: the parameter InfoObjectSet in the following definitions\n-- allows a distinct information object set to be specified for sets\n-- of algorithms such as:\n-- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n--     { OID id-md2  PARAMETERS NULL }|\n--     { OID id-md5  PARAMETERS NULL }|\n--     { OID id-sha1 PARAMETERS NULL }\n-- }\n--",
      "raw": true
    },
    {
      "indent": 0,
      "text": "AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=\nSEQUENCE {\n    algorithm  ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),\n    parameters\n        ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})\n            OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ==============\n--   Algorithms\n-- ==============",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--",
      "ja": "--"
    },
    {
      "indent": 0,
      "text": "-- Allowed EME-OAEP and EMSA-PSS digest algorithms.\n--\nOAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-sha1 PARAMETERS NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS NULL }|\n    { OID id-sha512 PARAMETERS NULL },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Allowed EMSA-PKCS1-v1_5 digest algorithms.\n--\nPKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-md2 PARAMETERS NULL    }|\n    { OID id-md5 PARAMETERS NULL    }|\n    { OID id-sha1 PARAMETERS NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS NULL }|\n    { OID id-sha512 PARAMETERS NULL }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- When id-md2 and id-md5 are used in an AlgorithmIdentifier the -- parameters MUST be present and MUST be NULL.",
      "ja": " -  ID-MD2及びID-MD5をのAlgorithmIdentifierで使用される場合 - パラメータが存在しなければならず、NULLでなければなりません。"
    },
    {
      "indent": 0,
      "text": "-- When id-sha1, id-sha256, id-sha384 and id-sha512 are used in an -- AlgorithmIdentifier the parameters (which are optional) SHOULD -- be omitted. However, an implementation MUST also accept -- AlgorithmIdentifier values where the parameters are NULL.",
      "ja": " -  ID-SHA1、ID-SHA256、ID-SHA384およびID-SHA512のに使用される場合 - を省略することが - （任意である）のAlgorithmIdentifierパラメータべきです。パラメータがNULLのAlgorithmIdentifier値を - しかし、実装も受け入れなければなりません。"
    },
    {
      "indent": 0,
      "text": "sha1    HashAlgorithm ::= {\n    algorithm   id-sha1,\n    parameters  SHA1Parameters : NULL  -- included for compatibility\n                                       -- with existing implementations\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SHA1Parameters ::= NULL",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Allowed mask generation function algorithms.\n-- If the identifier is id-mgf1, the parameters are a HashAlgorithm.\n--\nPKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-mgf1 PARAMETERS HashAlgorithm },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and\n-- id-RSASSA-PSS.maskGenAlgorithm.\n--\nmgf1SHA1    MaskGenAlgorithm ::= {\n    algorithm   id-mgf1,\n    parameters  HashAlgorithm : sha1\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Allowed algorithms for pSourceAlgorithm.\n--\nPKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-pSpecified PARAMETERS EncodingParameters },\n    ...  -- Allows for future expansion --\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "EncodingParameters ::= OCTET STRING(SIZE(0..MAX))",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- This identifier means that the label L is an empty string, so the\n-- digest of the empty string appears in the RSA block before\n-- masking.\n--\npSpecifiedEmpty    PSourceAlgorithm ::= {\n    algorithm   id-pSpecified,\n    parameters  EncodingParameters : emptyString\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "emptyString    EncodingParameters ::= ''H",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Type identifier definitions for the PKCS #1 OIDs.\n--\nPKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID rsaEncryption              PARAMETERS NULL } |\n    { OID md2WithRSAEncryption       PARAMETERS NULL } |\n    { OID md5WithRSAEncryption       PARAMETERS NULL } |\n    { OID sha1WithRSAEncryption      PARAMETERS NULL } |\n    { OID sha256WithRSAEncryption    PARAMETERS NULL } |\n    { OID sha384WithRSAEncryption    PARAMETERS NULL } |\n    { OID sha512WithRSAEncryption    PARAMETERS NULL } |\n    { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |\n    PKCS1PSourceAlgorithms                             |",
      "raw": true
    },
    {
      "indent": 0,
      "text": " { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params } , ... -- Allows for future expansion -- }",
      "ja": "{OIDのID-RSASSA-PSS PARAMETERS RSASSA-PSS-paramsは}、...  - 将来の拡張を可能にします - }"
    },
    {
      "indent": 0,
      "text": "-- ===================\n--   Main structures\n-- ===================",
      "raw": true
    },
    {
      "indent": 0,
      "text": "RSAPublicKey ::= SEQUENCE {\n    modulus           INTEGER,  -- n\n    publicExponent    INTEGER   -- e\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Representation of RSA private key with information for the CRT\n-- algorithm.\n--\nRSAPrivateKey ::= SEQUENCE {\n    version           Version,\n    modulus           INTEGER,  -- n\n    publicExponent    INTEGER,  -- e\n    privateExponent   INTEGER,  -- d\n    prime1            INTEGER,  -- p\n    prime2            INTEGER,  -- q\n    exponent1         INTEGER,  -- d mod (p-1)\n    exponent2         INTEGER,  -- d mod (q-1)\n    coefficient       INTEGER,  -- (inverse of q) mod p\n    otherPrimeInfos   OtherPrimeInfos OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Version ::= INTEGER { two-prime(0), multi(1) }\n    (CONSTRAINED BY {\n        -- version must be multi if otherPrimeInfos present --\n    })",
      "raw": true
    },
    {
      "indent": 0,
      "text": "OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo",
      "raw": true
    },
    {
      "indent": 0,
      "text": "OtherPrimeInfo ::= SEQUENCE {\n    prime             INTEGER,  -- ri\n    exponent          INTEGER,  -- di\n    coefficient       INTEGER   -- ti\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- AlgorithmIdentifier.parameters for id-RSAES-OAEP.\n-- Note that the tags in this Sequence are explicit.\n--\nRSAES-OAEP-params ::= SEQUENCE {",
      "raw": true
    },
    {
      "indent": 0,
      "text": " hashAlgorithm [0] HashAlgorithm DEFAULT sha1, maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1, pSourceAlgorithm [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty }",
      "ja": "hashAlgorithm [0] HashAlgorithmデフォルトSHA1、maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1、pSourceAlgorithm [2] PSourceAlgorithmデフォルトpSpecifiedEmpty}"
    },
    {
      "indent": 0,
      "text": "-- -- Identifier for default RSAES-OAEP algorithm identifier. -- The DER Encoding of this is in hexadecimal: -- (0x)30 0D -- 06 09 -- 2A 86 48 86 F7 0D 01 01 07 -- 30 00 -- Notice that the DER encoding of default values is \"empty\". --",
      "ja": " -   - デフォルトRSAES-OAEPアルゴリズム識別子の識別子。 - 本のDERエンコーディングは16進数である： - （0X）30 0D  -  06 09  -  2A 86 48 86 F7 0D 01 01 07から30 00  - デフォルト値のDER符号化は「空であることに注意してください」。 - "
    },
    {
      "indent": 0,
      "text": "rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {\n    algorithm   id-RSAES-OAEP,\n    parameters  RSAES-OAEP-params : {\n        hashAlgorithm       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        pSourceAlgorithm    pSpecifiedEmpty\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "RSAES-AlgorithmIdentifier ::=\n    AlgorithmIdentifier { {PKCS1Algorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- AlgorithmIdentifier.parameters for id-RSASSA-PSS.\n-- Note that the tags in this Sequence are explicit.\n--\nRSASSA-PSS-params ::= SEQUENCE {\n    hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,\n    maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,\n    saltLength         [2] INTEGER            DEFAULT 20,\n    trailerField       [3] TrailerField       DEFAULT trailerFieldBC\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "TrailerField ::= INTEGER { trailerFieldBC(1) }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- -- Identifier for default RSASSA-PSS algorithm identifier -- The DER Encoding of this is in hexadecimal: -- (0x)30 0D -- 06 09 -- 2A 86 48 86 F7 0D 01 01 0A -- 30 00 -- Notice that the DER encoding of default values is \"empty\".",
      "ja": " -   - デフォルトRSASSA-PSSアルゴリズム識別子の識別子 - 本のDERエンコーディングは16進数である： - （0X）30 0D  -  06 09  -  2A 86 48 86 F7 0D 01 0A 01  -  30 00  -  - デフォルト値のDERエンコーディングが「空」であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "--\nrSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {\n    algorithm   id-RSASSA-PSS,\n    parameters  RSASSA-PSS-params : {\n        hashAlgorithm       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        saltLength          20,\n        trailerField        trailerFieldBC\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "RSASSA-AlgorithmIdentifier ::=\n    AlgorithmIdentifier { {PKCS1Algorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "--\n-- Syntax for the EMSA-PKCS1-v1_5 hash identifier.\n--\nDigestInfo ::= SEQUENCE {\n    digestAlgorithm DigestAlgorithm,\n    digest OCTET STRING\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "DigestAlgorithm ::=\n    AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "END -- PKCS1Definitions",
      "ja": "END  -  PKCS1Definitions"
    },
    {
      "indent": 0,
      "text": "Appendix D. Intellectual Property Considerations",
      "ja": "付録D.知的財産権に関する注意事項"
    },
    {
      "indent": 3,
      "text": "The RSA public-key cryptosystem is described in U.S. Patent 4,405,829, which expired on September 20, 2000. RSA Security Inc. makes no other patent claims on the constructions described in this document, although specific underlying techniques may be covered.",
      "ja": "特定の基礎となる技術が覆われていてもよいが、RSA公開鍵暗号は、9月20日に期限が切れた米国特許4405829に記載されている、2000年RSAセキュリティ社は、この文書で説明する構造上の他の特許クレームを行いません。"
    },
    {
      "indent": 3,
      "text": "Multi-prime RSA is described in U.S. Patent 5,848,159.",
      "ja": "マルチプライムRSAは、米国特許第5848159に記載されています。"
    },
    {
      "indent": 3,
      "text": "The University of California has indicated that it has a patent pending on the PSS signature scheme [5]. It has also provided a letter to the IEEE P1363 working group stating that if the PSS signature scheme is included in an IEEE standard, \"the University of California will, when that standard is adopted, FREELY license any conforming implementation of PSS as a technique for achieving a digital signature with appendix\" [23]. The PSS signature scheme is specified in the IEEE P1363a draft [27], which was in ballot resolution when this document was published.",
      "ja": "カリフォルニア大学は、PSS署名方式[5]に係属中の特許を有していることを示しています。また、PSS署名方式は、IEEE標準に含まれている場合、「カリフォルニアの大学は、その標準が採用されたときに、自由にするための技術として、PSSの任意の適合実装をライセンスすることを示すIEEE P1363ワーキンググループに手紙を提供してきました「付録でデジタル署名を達成する[23]。 PSS署名方式は、この文書が発行されたときに投票解像度であったIEEE P1363aドラフト[27]で指定されています。"
    },
    {
      "indent": 3,
      "text": "License to copy this document is granted provided that it is identified as \"RSA Security Inc. Public-Key Cryptography Standards (PKCS)\" in all material mentioning or referencing this document.",
      "ja": "この文書をコピーするためのライセンスは、この文書に言及または参照するすべての材料で、それが「RSA Security Inc.の公開鍵暗号規格（PKCS）」として識別されていることを提供付与されます。"
    },
    {
      "indent": 3,
      "text": "RSA Security Inc. makes no other representations regarding intellectual property claims by other parties. Such determination is the responsibility of the user.",
      "ja": "RSA Security Inc.のは、他の当事者による知的財産の請求に関していかなる他の表現を行うものではありません。このような決定は、利用者の責任です。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Revision history",
      "ja": "付録E.更新履歴"
    },
    {
      "indent": 3,
      "text": "Versions 1.0 - 1.3",
      "ja": "バージョン1.0から1.3"
    },
    {
      "indent": 6,
      "text": "Versions 1.0 - 1.3 were distributed to participants in RSA Data Security, Inc.'s Public-Key Cryptography Standards meetings in February and March 1991.",
      "ja": "バージョン1.0から1.3は、2月と1991年3月、RSA Data Security社の公開鍵暗号規格会議の参加者に配布しました。"
    },
    {
      "indent": 3,
      "text": "Version 1.4",
      "ja": "バージョン1.4"
    },
    {
      "indent": 6,
      "text": "Version 1.4 was part of the June 3, 1991 initial public release of PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop document SEC-SIG-91-18.",
      "ja": "バージョン1.4はPKCSの1991年6月3日、最初のパブリックリリースの一部でした。バージョン1.4は、NIST / OSI実装者ワークショップのドキュメントSEC-SIG-91-18として出版されました。"
    },
    {
      "indent": 3,
      "text": "Version 1.5",
      "ja": "バージョン1.5"
    },
    {
      "indent": 6,
      "text": "Version 1.5 incorporated several editorial changes, including updates to the references and the addition of a revision history. The following substantive changes were made:",
      "ja": "バージョン1.5は、参照への更新および改訂履歴の追加など、いくつかの編集上の変更を、組み込まれています。以下の実質的な変更が行われました。"
    },
    {
      "indent": 6,
      "text": "- Section 10: \"MD4 with RSA\" signature and verification processes were added. - Section 11: md4WithRSAEncryption object identifier was added.",
      "ja": " - 第10章：「MD4 RSAと」署名と検証のプロセスを加えました。 - セクション11：md4WithRSAEncryptionオブジェクト識別子を加えました。"
    },
    {
      "indent": 6,
      "text": "Version 1.5 was republished as IETF RFC 2313.",
      "ja": "バージョン1.5は、IETFのRFC 2313として再版されました。"
    },
    {
      "indent": 3,
      "text": "Version 2.0",
      "ja": "バージョン2.0"
    },
    {
      "indent": 6,
      "text": "Version 2.0 incorporated major editorial changes in terms of the document structure and introduced the RSAES-OAEP encryption scheme. This version continued to support the encryption and signature processes in version 1.5, although the hash algorithm MD4 was no longer allowed due to cryptanalytic advances in the intervening years. Version 2.0 was republished as IETF RFC 2437 [35].",
      "ja": "バージョン2.0は、文書構造の面で主要な編集上の変更が組み込まれ、RSAES-OAEP暗号化方式を導入しました。ハッシュアルゴリズムMD4がもはやによる介入年間で暗号解読進歩させたが、このバージョンは、バージョン1.5での暗号化と署名のプロセスをサポートし続けていません。バージョン2.0は、IETFのRFC 2437 [35]として再発行されました。"
    },
    {
      "indent": 3,
      "text": "Version 2.1",
      "ja": "バージョン2.1"
    },
    {
      "indent": 6,
      "text": "Version 2.1 introduces multi-prime RSA and the RSASSA-PSS signature scheme with appendix along with several editorial improvements. This version continues to support the schemes in version 2.0.",
      "ja": "バージョン2.1は、マルチプライムRSAおよびいくつかの編集上の改良に伴い、付録とRSASSA-PSS署名方式を導入しています。このバージョンは、バージョン2.0でのスキームをサポートし続けています。"
    },
    {
      "indent": 0,
      "text": "Appendix F: References",
      "ja": "付録F：参考文献"
    },
    {
      "indent": 3,
      "text": "[1] ANSI X9F1 Working Group. ANSI X9.44 Draft D2: Key Establishment Using Integer Factorization Cryptography. Working Draft, March 2002.",
      "ja": "[1] ANSI X9F1ワーキンググループ。 ANSI X9.44ドラフトD2：鍵確立整数の因数分解暗号を使用。ワーキングドラフト、2002年3月。"
    },
    {
      "indent": 3,
      "text": "[2] M. Bellare, A. Desai, D. Pointcheval and P. Rogaway. Relations Among Notions of Security for Public-Key Encryption Schemes. In H. Krawczyk, editor, Advances in Cryptology - Crypto '98, volume 1462 of Lecture Notes in Computer Science, pp. 26 - 45. Springer Verlag, 1998.",
      "ja": "[2] M.ベラー、A.デサイ、D. PointchevalおよびP. Rogaway。公開鍵暗号化方式のセキュリティの観念の関係。暗号'98、コンピュータサイエンスの講義ノートの音量1462、頁26  -   - 。45スプリンガーVerlag社、1998 H. Krawczyk、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[3] M. Bellare and P. Rogaway. Optimal Asymmetric Encryption - How to Encrypt with RSA. In A. De Santis, editor, Advances in Cryptology - Eurocrypt '94, volume 950 of Lecture Notes in Computer Science, pp. 92 - 111. Springer Verlag, 1995.",
      "ja": "[3] M.ベラー及びP. Rogaway。最適な非対称暗号化 -  RSAで暗号化する方法。 EUROCRYPT '94、コンピュータサイエンスの講義ノートのボリューム950頁92  -   - 。111スプリンガーVerlag社、1995 A.デ・センティス、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[4] M. Bellare and P. Rogaway. The Exact Security of Digital Signatures - How to Sign with RSA and Rabin. In U. Maurer, editor, Advances in Cryptology - Eurocrypt '96, volume 1070 of Lecture Notes in Computer Science, pp. 399 - 416. Springer Verlag, 1996.",
      "ja": "[4] M.ベラー及びP. Rogaway。デジタル署名の正確なセキュリティ - どのようにRSAとラビンでサインインしてください。 EUROCRYPT '96、コンピュータサイエンスの講義ノートの音量1070、頁399  -   - 。416スプリンガーVerlag社、1996 U.マウラー、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[5] M. Bellare and P. Rogaway. PSS: Provably Secure Encoding Method for Digital Signatures. Submission to IEEE P1363 working group, August 1998. Available from http://grouper.ieee.org/groups/1363/.",
      "ja": "[5] M.ベラー及びP. Rogaway。 PSS：デジタル署名用証明可能セキュアな符号化方式。 IEEE P1363ワーキンググループ、http://grouper.ieee.org/groups/1363/から1998年8月に利用可能に提出。"
    },
    {
      "indent": 3,
      "text": "[6] D. Bleichenbacher. Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1. In H. Krawczyk, editor, Advances in Cryptology - Crypto '98, volume 1462 of Lecture Notes in Computer Science, pp. 1 - 12. Springer Verlag, 1998.",
      "ja": "[6] D. Bleichenbacherの。 RSA暗号化規格PKCS＃1に基づくプロトコルに対する選択暗号文攻撃。暗号'98、コンピュータサイエンスの講義ノートの音量1462、頁1  -   - 。12スプリンガーVerlag社、1998 H. Krawczyk、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[7] D. Bleichenbacher, B. Kaliski and J. Staddon. Recent Results on PKCS #1: RSA Encryption Standard. RSA Laboratories' Bulletin No. 7, June 1998.",
      "ja": "[7] D. Bleichenbacherの、B. Kaliski及びJ. Staddon。 RSA暗号化規格：PKCS＃1の最近の結果。 RSA Laboratoriesの会報7号、1998年6月。"
    },
    {
      "indent": 3,
      "text": "[8] B. den Boer and A. Bosselaers. An Attack on the Last Two Rounds of MD4. In J. Feigenbaum, editor, Advances in Cryptology - Crypto '91, volume 576 of Lecture Notes in Computer Science, pp. 194 - 203. Springer Verlag, 1992.",
      "ja": "[8] B.デンボーア及びA. Bosselaers。 MD4の最後の2ラウンドで攻撃。頁194暗号'91、コンピュータサイエンスの講義ノートのボリューム576、 -   -  203シュプリンガーフェアラーク、1992 J.ファイゲンバウム、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[9] B. den Boer and A. Bosselaers. Collisions for the Compression Function of MD5. In T. Helleseth, editor, Advances in Cryptology - Eurocrypt '93, volume 765 of Lecture Notes in Computer Science, pp. 293 - 304. Springer Verlag, 1994.",
      "ja": "[9] B.デンボーア及びA. Bosselaers。 MD5の圧縮機能のための衝突。 EUROCRYPT '93、コンピュータサイエンスの講義ノートのボリューム765頁293  -   - 。304スプリンガーVerlag社、1994 T. Helleseth、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[10] D. Coppersmith, M. Franklin, J. Patarin and M. Reiter. Low-Exponent RSA with Related Messages. In U. Maurer, editor, Advances in Cryptology - Eurocrypt '96, volume 1070 of Lecture Notes in Computer Science, pp. 1 - 9. Springer Verlag, 1996.",
      "ja": "[10] D.銅細工、M.フランクリン、J. Patarin及びM.ライター。関連メッセージによる低指数RSA。 EUROCRYPT '96、コンピュータサイエンスの講義ノートの音量1070、頁1  -   - 。9.シュプリンガーフェアラーク、1996 U.マウラー、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[11] D. Coppersmith, S. Halevi and C. Jutla. ISO 9796-1 and the New Forgery Strategy. Presented at the rump session of Crypto '99, August 1999.",
      "ja": "[11] D.銅細工、S. Halevi及びC. Jutla。 ISO 9796から1新偽造戦略。暗号'99、1999年8月のランプセッションで発表。"
    },
    {
      "indent": 3,
      "text": "[12] J.-S. Coron. On the Exact Security of Full Domain Hashing. In M. Bellare, editor, Advances in Cryptology - Crypto 2000, volume 1880 of Lecture Notes in Computer Science, pp. 229 - 235. Springer Verlag, 2000.",
      "ja": "[12] J.-S.コロン。完全なドメインハッシュの厳密なセキュリティ上。暗号2000年、コンピュータサイエンスの講義ノートの音量1880、頁229  -   - 。235シュプリンガーフェアラーク、2000 M.ベラー、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[13] J.-S. Coron. Optimal Security Proofs for PSS and Other Signature Schemes. In L. Knudsen, editor, Advances in Cryptology - Eurocrypt 2002, volume 2332 of Lecture Notes in Computer Science, pp. 272 - 287. Springer Verlag, 2002.",
      "ja": "[13] J.-S.コロン。 PSSと他の署名方式に最適なセキュリティ証明。 EUROCRYPT 2002、コンピュータサイエンスの講義ノートの音量2332、頁272  -   - 。287スプリンガーVerlag社、2002 L.クヌーセン、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[14] J.-S. Coron, M. Joye, D. Naccache and P. Paillier. New Attacks on PKCS #1 v1.5 Encryption. In B. Preneel, editor, Advances in Cryptology - Eurocrypt 2000, volume 1807 of Lecture Notes in Computer Science, pp. 369 - 379. Springer Verlag, 2000.",
      "ja": "[14] J.-S.コロン島、M. Joye、D. NaccacheおよびP. Paillier。 PKCS＃1 v1.5の暗号化の新しい攻撃。 EUROCRYPT 2000、コンピュータサイエンスの講義ノートの音量1807、頁369  -   - 。379シュプリンガーフェアラーク、2000 B. Preneel、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[15] J.-S. Coron, D. Naccache and J. P. Stern. On the Security of RSA Padding. In M. Wiener, editor, Advances in Cryptology - Crypto '99, volume 1666 of Lecture Notes in Computer Science, pp. 1 - 18. Springer Verlag, 1999.",
      "ja": "[15] J.-S.コロン、D. NaccacheおよびJ. P.スターン。 RSAパディングのセキュリティに。暗号'99、コンピュータサイエンスの講義ノートの音量1666、頁1  -   - 。18スプリンガーVerlag社、1999 M.ウィーン、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[16] Y. Desmedt and A.M. Odlyzko. A Chosen Text Attack on the RSA Cryptosystem and Some Discrete Logarithm Schemes. In H.C. Williams, editor, Advances in Cryptology - Crypto '85, volume 218 of Lecture Notes in Computer Science, pp. 516 - 522. Springer Verlag, 1986.",
      "ja": "[16] Y. DesmedtとA.M. Odlyzko。 RSA暗号といくつかの離散対数方式で選択したテキストアタック。 H.C.で暗号'85、コンピュータサイエンスの講義ノートのボリューム218頁516  -   - 。522スプリンガーVerlag社、1986年ウィリアムズ、編集者は、暗号学の進歩します。"
    },
    {
      "indent": 3,
      "text": "[17] Dierks, T. and C. Allen, \"The TLS Protocol, Version 1.0\", RFC 2246, January 1999.",
      "ja": "[17]ダークス、T.とC.アレン、 \"TLSプロトコル、バージョン1.0\"、2246 RFC、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[18] H. Dobbertin. Cryptanalysis of MD4. In D. Gollmann, editor, Fast Software Encryption '96, volume 1039 of Lecture Notes in Computer Science, pp. 55 - 72. Springer Verlag, 1996.",
      "ja": "[18] H. Dobbertin。 MD4の暗号解読。 。72.スプリンガーVerlag社、1996  -  D. Gollmann、エディタ、高速ソフトウェア暗号化'96、コンピュータサイエンスの講義ノートの音量1039、頁55で。"
    },
    {
      "indent": 3,
      "text": "[19] H. Dobbertin. Cryptanalysis of MD5 Compress. Presented at the rump session of Eurocrypt '96, May 1996.",
      "ja": "[19] H. Dobbertin。 MD5圧縮の暗号解読。 EUROCRYPT '96、1996年5月のランプセッションで発表。"
    },
    {
      "indent": 3,
      "text": "[20] H. Dobbertin. The First Two Rounds of MD4 are Not One-Way. In S. Vaudenay, editor, Fast Software Encryption '98, volume 1372 in Lecture Notes in Computer Science, pp. 284 - 292. Springer Verlag, 1998.",
      "ja": "[20] H. Dobbertin。 MD4の最初の2ラウンドは、ワンウェイではありません。 。292スプリンガーVerlag社、1998  -  S. Vaudenay、エディタ、高速ソフトウェア暗号化'98、コンピュータサイエンスの講義ノートでボリューム1372、頁284で。"
    },
    {
      "indent": 3,
      "text": "[21] E. Fujisaki, T. Okamoto, D. Pointcheval and J. Stern. RSA-OAEP is Secure under the RSA Assumption. In J. Kilian, editor, Advances in Cryptology - Crypto 2001, volume 2139 of Lecture Notes in Computer Science, pp. 260 - 274. Springer Verlag, 2001.",
      "ja": "[21] E.藤崎、T.岡本、D. Pointcheval及びJ.スターン。 RSA-OAEPはRSA仮定の下でセキュアです。暗号2001年、コンピュータサイエンスの講義ノートの音量2139、頁260  -   - 。274スプリンガーVerlag社、2001 J.キリアン、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[22] H. Garner. The Residue Number System. IRE Transactions on Electronic Computers, EC-8 (6), pp. 140 - 147, June 1959.",
      "ja": "[22] H.ガーナー。剰余数システム。電子計算機上のIREトランザクション、EC-8（6）、頁140  -  147、1959年6月。"
    },
    {
      "indent": 3,
      "text": "[23] M.L. Grell. Re: Encoding Methods PSS/PSS-R. Letter to IEEE P1363 working group, University of California, June 15, 1999. Available from http://grouper.ieee.org/groups/1363/P1363/patents.html.",
      "ja": "[23] M.L.グレル。再：エンコーディング方法PSS / PSS-R。 IEEE P1363ワーキンググループ、カリフォルニア大学、6月15日、http://grouper.ieee.org/groups/1363/P1363/patents.htmlから利用可能な1999年への手紙。"
    },
    {
      "indent": 3,
      "text": "[24] J. Haastad. Solving Simultaneous Modular Equations of Low Degree. SIAM Journal of Computing, volume 17, pp. 336 - 341, 1988.",
      "ja": "[24] J. Haastad。低度の同時モジュラー方程式を解きます。コンピューティングSIAMジャーナル、17巻、頁336  - 。341、1988。"
    },
    {
      "indent": 3,
      "text": "[25] Housley, R., \"Cryptographic Message Syntax (CMS)\", RFC 3369, August 2002. Housley, R., \"Cryptographic Message Syntax (CMS) Algorithms\", RFC 3370, August 2002.",
      "ja": "[25] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、RFC 3369、2002年8月にHousley氏、R.、 \"暗号メッセージ構文（CMS）アルゴリズム\"、RFC 3370、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[26] IEEE Std 1363-2000: Standard Specifications for Public Key Cryptography. IEEE, August 2000.",
      "ja": "[26] IEEE STD 1363年から2000年：公開鍵暗号のための標準仕様。 IEEE、2000年8月。"
    },
    {
      "indent": 3,
      "text": "[27] IEEE P1363 working group. IEEE P1363a D11: Draft Standard Specifications for Public Key Cryptography -- Amendment 1: Additional Techniques. December 16, 2002. Available from http://grouper.ieee.org/groups/1363/.",
      "ja": "[27] IEEE P1363ワーキンググループ。 IEEE P1363aのD11：公開鍵暗号のための標準仕様案 - 修正1：追加のテクニック。 12月16日、http://grouper.ieee.org/groups/1363/から利用可能な2002年。"
    },
    {
      "indent": 3,
      "text": "[28] ISO/IEC 9594-8:1997: Information technology - Open Systems Interconnection - The Directory: Authentication Framework. 1997.",
      "ja": "[28] ISO / IEC 9594から8：1997：情報技術 - 開放型システム間相互接続 - ディレクトリ：認証フレームワーク。 1997。"
    },
    {
      "indent": 3,
      "text": "[29] ISO/IEC FDIS 9796-2: Information Technology - Security Techniques - Digital Signature Schemes Giving Message Recovery - Part 2: Integer Factorization Based Mechanisms. Final Draft International Standard, December 2001.",
      "ja": "[29] ISO / IEC FDIS 9796から2：情報技術 - セキュリティ技術 - メッセージ・リカバリを与えるデジタル署名方式 - パート2：素因数分解ベースのメカニズム。最終国際規格案、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[30] ISO/IEC 18033-2: Information Technology - Security Techniques - Encryption Algorithms - Part 2: Asymmetric Ciphers. V. Shoup, editor, Text for 2nd Working Draft, January 2002.",
      "ja": "[30] ISO / IEC 18033-2：情報技術 - セキュリティ技術 - 暗号化アルゴリズム - パート2：非対称暗号。 V.シャウプ、編集者、第二ワーキングドラフト、2002年1月のためのテキスト。"
    },
    {
      "indent": 3,
      "text": "[31] J. Jonsson. Security Proof for the RSA-PSS Signature Scheme (extended abstract). Second Open NESSIE Workshop. September 2001. Full version available from http://eprint.iacr.org/2001/053/.",
      "ja": "[31] J.ジョンソン。 RSA-PSS署名方式のセキュリティ証明（抽象拡張します）。第二にNESSIEワークショップを開きます。 http://eprint.iacr.org/2001/053/から入手2001年9月フルバージョン。"
    },
    {
      "indent": 3,
      "text": "[32] J. Jonsson and B. Kaliski. On the Security of RSA Encryption in TLS. In M. Yung, editor, Advances in Cryptology - CRYPTO 2002, vol. 2442 of Lecture Notes in Computer Science, pp. 127 - 142. Springer Verlag, 2002.",
      "ja": "[32] J.ジョンソン及びB. Kaliski。 TLSでのRSA暗号化のセキュリティに。 CRYPTO 2002、巻 -  M.ヨン、エディタでは、暗号学の進歩。 。142スプリンガーVerlag社、2002  - コンピュータサイエンスの講義ノート、頁127の2442。"
    },
    {
      "indent": 3,
      "text": "[33] Kaliski, B., \"The MD2 Message-Digest Algorithm\", RFC 1319, April 1992.",
      "ja": "[33] Kaliski、B.、 \"MD2メッセージダイジェストアルゴリズム\"、RFC 1319、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[34] B. Kaliski. On Hash Function Identification in Signature Schemes. In B. Preneel, editor, RSA Conference 2002, Cryptographers' Track, volume 2271 of Lecture Notes in Computer Science, pp. 1 - 16. Springer Verlag, 2002.",
      "ja": "[34] B. Kaliski。署名スキームにおけるハッシュ関数の同定に関する。 16.スプリンガーVerlag社、2002  -  B. Preneel、エディタ、RSAコンファレンス2002、暗号学者トラック、コンピュータサイエンスの講義ノートの音量2271、頁1に。"
    },
    {
      "indent": 3,
      "text": "[35] Kaliski, B. and J. Staddon, \"PKCS #1: RSA Cryptography Specifications Version 2.0\", RFC 2437, October 1998.",
      "ja": "[35] Kaliski、B.及びJ. Staddon、 \"PKCS＃1：RSA暗号仕様バージョン2.0\"、RFC 2437、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[36] J. Manger. A Chosen Ciphertext Attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as Standardized in PKCS #1 v2.0. In J. Kilian, editor, Advances in Cryptology - Crypto 2001, volume 2139 of Lecture Notes in Computer Science, pp. 260 - 274. Springer Verlag, 2001.",
      "ja": "[36] J.マネージャ。 RSA最適な非対称暗号パディング（OAEP）の選択暗号文攻撃PKCS＃1 v2.0の中で標準化されたとして。暗号2001年、コンピュータサイエンスの講義ノートの音量2139、頁260  -   - 。274スプリンガーVerlag社、2001 J.キリアン、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[37] A. Menezes, P. van Oorschot and S. Vanstone. Handbook of Applied Cryptography. CRC Press, 1996.",
      "ja": "[37] A.メネゼス、P.バンOorschotとS. Vanstone著。応用暗号のハンドブック。 CRCプレス、1996。"
    },
    {
      "indent": 3,
      "text": "[38] National Institute of Standards and Technology (NIST). FIPS Publication 180-1: Secure Hash Standard. April 1994.",
      "ja": "[38]米国国立標準技術研究所（NIST）。 FIPS 180-1文献：セキュアハッシュ標準。 1994年4月。"
    },
    {
      "indent": 3,
      "text": "[39] National Institute of Standards and Technology (NIST). Draft FIPS 180-2: Secure Hash Standard. Draft, May 2001. Available from http://www.nist.gov/sha/.",
      "ja": "[39]米国国立標準技術研究所（NIST）。ドラフトは180-2 FIPS：セキュアハッシュ標準を。ドラフト、http://www.nist.gov/sha/から2001年5月に利用できます。"
    },
    {
      "indent": 3,
      "text": "[40] J.-J. Quisquater and C. Couvreur. Fast Decipherment Algorithm for RSA Public-Key Cryptosystem. Electronics Letters, 18 (21), pp. 905 - 907, October 1982.",
      "ja": "[40] J.-J. QuisquaterのとC. Couvreur。 RSA公開鍵暗号の高速解読アルゴリズム。エレクトロニクスレターズ、18（21）、頁905  -  907、1982年10月。"
    },
    {
      "indent": 3,
      "text": "[41] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[41]リベスト、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[42] R. Rivest, A. Shamir and L. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Communications of the ACM, 21 (2), pp. 120-126, February 1978.",
      "ja": "[42] R.リベスト、A.シャミル及びL.エーデルマン。デジタル署名と公開鍵暗号を得るための方法。 ACMの通信、21（2）、頁120-126、1978年2月。"
    },
    {
      "indent": 3,
      "text": "[43] N. Rogier and P. Chauvaud. The Compression Function of MD2 is not Collision Free. Presented at Selected Areas of Cryptography '95. Carleton University, Ottawa, Canada. May 1995.",
      "ja": "[43] N.ロジェ及びP. Chauvaud。 MD2の圧縮機能は、衝突フリーではありません。暗号'95の選択された領域で発表。カールトン大学、オタワ、カナダ。 1995年5月。"
    },
    {
      "indent": 3,
      "text": "[44] RSA Laboratories. PKCS #1 v2.0: RSA Encryption Standard. October 1998.",
      "ja": "[44] RSA研究所。 PKCS＃1 v2.0の：RSA暗号化規格。 1998年10月。"
    },
    {
      "indent": 3,
      "text": "[45] RSA Laboratories. PKCS #7 v1.5: Cryptographic Message Syntax Standard. November 1993. (Republished as IETF RFC 2315.)",
      "ja": "[45] RSA研究所。 PKCS＃7 V1.5：暗号メッセージ構文標準。 （IETFのRFC 2315として再発行）1993年11月"
    },
    {
      "indent": 3,
      "text": "[46] RSA Laboratories. PKCS #8 v1.2: Private-Key Information Syntax Standard. November 1993.",
      "ja": "[46] RSA研究所。 PKCS＃8 V1.2：プライベート・キー情報の構文標準。 1993年11月。"
    },
    {
      "indent": 3,
      "text": "[47] RSA Laboratories. PKCS #12 v1.0: Personal Information Exchange Syntax Standard. June 1999.",
      "ja": "[47] RSA研究所。 PKCS＃12 v1.0を：個人情報交換シンタックス標準。 1999年6月。"
    },
    {
      "indent": 3,
      "text": "[48] V. Shoup. OAEP Reconsidered. In J. Kilian, editor, Advances in Cryptology - Crypto 2001, volume 2139 of Lecture Notes in Computer Science, pp. 239 - 259. Springer Verlag, 2001.",
      "ja": "[48] V.シャウプ。 OAEP再考。暗号2001年、コンピュータサイエンスの講義ノートの音量2139、頁239  -   - 。259スプリンガーVerlag社、2001 J.キリアン、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 3,
      "text": "[49] R. D. Silverman. A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths. RSA Laboratories Bulletin No. 13, April 2000. Available from http://www.rsasecurity.com.rsalabs/bulletins/.",
      "ja": "[49] R. D.シルバー。対称および非対称キーの長さのコストベースのセキュリティ分析。 HTTPから2000年4月には利用可能なRSA研究所会報13号：//www.rsasecurity.com.rsalabs/bulletins/。"
    },
    {
      "indent": 3,
      "text": "[50] G. J. Simmons. Subliminal communication is easy using the DSA. In T. Helleseth, editor, Advances in Cryptology - Eurocrypt '93, volume 765 of Lecture Notes in Computer Science, pp. 218- 232. Springer-Verlag, 1993.",
      "ja": "[50] G. J.シモンズ。サブリミナル通信は、DSAを使用して簡単です。 EUROCRYPT '93、コンピュータサイエンスの講義ノートのボリューム765頁218- 232シュプリンガー・フェアラーク、1993  - 。T. Helleseth、エディタでは、暗号学の進歩。"
    },
    {
      "indent": 0,
      "text": "Appendix G: About PKCS",
      "ja": "付録G：PKCSについて"
    },
    {
      "indent": 3,
      "text": "The Public-Key Cryptography Standards are specifications produced by RSA Laboratories in cooperation with secure systems developers worldwide for the purpose of accelerating the deployment of public-key cryptography. First published in 1991 as a result of meetings with a small group of early adopters of public-key technology, the PKCS documents have become widely referenced and implemented. Contributions from the PKCS series have become part of many formal and de facto standards, including ANSI X9 and IEEE P1363 documents, PKIX, SET, S/MIME, SSL/TLS, and WAP/WTLS.",
      "ja": "公開鍵暗号規格は、公開鍵暗号の展開を促進する目的のために、世界中の安全なシステムの開発者と協力してRSA研究所によって生成仕様です。まず、公開鍵技術の早期導入の小グループとの会合の結果として、1991年に出版され、PKCSドキュメントは、広く参照され、実装になってきました。 PKCSシリーズからの拠出金は、ANSI X9とIEEE P1363ドキュメント、PKIX、SET、S / MIME、SSL / TLS、およびWAP / WTLSを含む多くの正式なデファクトスタンダードの一部となっています。"
    },
    {
      "indent": 3,
      "text": "Further development of PKCS occurs through mailing list discussions and occasional workshops, and suggestions for improvement are welcome. For more information, contact:",
      "ja": "PKCSのさらなる開発は、メーリングリストでの議論と時折ワークショップを介して行われ、改善のための提案を歓迎します。詳細については、お問い合わせください："
    },
    {
      "indent": 6,
      "text": "PKCS Editor RSA Laboratories 174 Middlesex Turnpike Bedford, MA 01730 USA pkcs-editor@rsasecurity.com http://www.rsasecurity.com/rsalabs/pkcs",
      "ja": "PKCSエディタRSA Laboratories社174ミドルターンパイクベッドフォード、MA 01730 USA pkcs-editor@rsasecurity.com http://www.rsasecurity.com/rsalabs/pkcs"
    },
    {
      "indent": 0,
      "text": "Appendix H: Corrections Made During RFC Publication Process",
      "ja": "付録H：RFCの公開プロセス中に行われた訂正"
    },
    {
      "indent": 3,
      "text": "The following corrections were made in converting the PKCS #1 v2.1 document to this RFC:",
      "ja": "次の修正は、このRFCにPKCS＃1 V2.1文書を変換する際に行われました。"
    },
    {
      "indent": 3,
      "text": "* The requirement that the parameters in an AlgorithmIdentifier value for id-sha1, id-sha256, id-sha384, and id-sha512 be NULL was changed to a recommendation that the parameters be omitted (while still allowing the parameters to be NULL). This is to align with the definitions originally promulgated by NIST. Implementations MUST accept AlgorithmIdentifier values both without parameters and with NULL parameters.",
      "ja": "*（まだパラメータがNULLであることを可能にしながら）ID-SHA1、ID-SHA256、ID-SHA384、及びID-SHA512のためのAlgorithmIdentifier値のパラメータがNULLパラメータを省略することが推奨に変更したことが要件。これは、もともとNISTによって公布の定義と整合するようになります。実装は、パラメータなしとNULLパラメータで両方のAlgorithmIdentifier値を受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The notes after RSADP and RSASP1 (Secs. 5.1.2 and 5.2.1) were corrected to refer to step 2.b rather than 2.a.",
      "ja": "* RSADPとRSASP1（秒数。5.1.2および5.2.1）後のリアクションは2.a.節ではなく2.Bのステップを参照して補正しました"
    },
    {
      "indent": 3,
      "text": "* References [25], [27] and [32] were updated to reflect new publication data.",
      "ja": "*参考文献[25]、[27]及び[32]新しいパブリケーション・データを反映するように更新されました。"
    },
    {
      "indent": 3,
      "text": "These corrections will be reflected in future editions of PKCS #1 v2.1.",
      "ja": "これらの修正は、PKCS＃1 v2.1のの将来の版に反映されます。"
    },
    {
      "indent": 0,
      "text": "Security Considerations",
      "ja": "セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ中で議論されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is based on a contribution of RSA Laboratories, the research center of RSA Security Inc. Any substantial use of the text from this document must acknowledge RSA Security Inc. RSA Security Inc. requests that all material mentioning or referencing this document identify this as \"RSA Security Inc. PKCS #1 v2.1\".",
      "ja": "このドキュメントは、RSA Laboratories社、RSA Security Inc.のすべての材料は言及またはこの文書はこれを識別する参照するRSA Security Inc.のRSA Security Inc.の要求を確認する必要があり、この文書からテキストの実質的な使用の研究センターの貢献度に基づいています\"RSA Security Inc.のPKCS＃1 V2.1\"。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jakob Jonsson Philipps-Universitaet Marburg Fachbereich Mathematik und Informatik Hans Meerwein Strasse, Lahnberge DE-35032 Marburg Germany",
      "ja": "数学のヤコブ・ヨンソンフィリップス - 大学マールブルグ部門とコンピュータサイエンスメーヤワイン道路Lahnberge DE-35032マールブルクドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 6421 28 25672 EMail: jonsson@mathematik.uni-marburg.de",
      "ja": "電話：+49 6421 28 25672 Eメール：jonsson@mathematik.uni-marburg.de"
    },
    {
      "indent": 3,
      "text": "Burt Kaliski RSA Laboratories 174 Middlesex Turnpike Bedford, MA 01730 USA",
      "ja": "バート・カリスキーRSA Laboratories社174ミドルターンパイクベッドフォード、MA 01730 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 781 515 7073 EMail: bkaliski@rsasecurity.com",
      "ja": "電話：+1 781 515 7073 Eメール：bkaliski@rsasecurity.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society 2003. All Rights Reserved.",
      "ja": "著作権（C）インターネット協会2003.すべての権利を保有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others provided that the above copyright notice and this paragraph are included on all such copies. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、他人にコピーして提出することができる上記の著作権表示とこの段落は、このようなすべてのコピーに含まれていることを条件とします。しかし、この文書自体は、英語以外の言語に翻訳するために必要な場合を除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}