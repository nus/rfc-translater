{
  "title": {
    "text": "RFC 3552 - Guidelines for Writing RFC Text on Security Considerations",
    "ja": "RFC 3552 - セキュリティの考慮事項にRFCテキストを書くためのガイドライン"
  },
  "number": 3552,
  "created_at": "2019-10-19 14:46:34.080864+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        E. Rescorla\nRequest for Comments: 3552                                    RTFM, Inc.\nBCP: 72                                                        B. Korver\nCategory: Best Current Practice                          Xythos Software\n                                             Internet Architecture Board\n                                                                     IAB\n                                                               July 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Guidelines for Writing RFC Text on Security Considerations",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントはインターネットコミュニティのためのインターネットBest Current Practicesを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak. This document provides guidelines to RFC authors on how to write a good Security Considerations section.",
      "ja": "すべてのRFCは、Security Considerations部を有することが要求されています。歴史的に、そのようなセクションが比較的弱いとなっています。この文書では、良いSecurity Considerations部を書き込む方法についてのRFCの作者にガイドラインを提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction . . . . . . . . . . . . . . . . . . . . . . .   3\n   1.1. Requirements. . . . . . . . . . . . . . . . . . . . .   3\n2. The Goals of Security. . . . . . . . . . . . . . . . . . .   3\n   2.1. Communication Security. . . . . . . . . . . . . . . .   3\n        2.1.1. Confidentiality. . . . . . . . . . . . . . . .   4\n        2.1.2. Data Integrity . . . . . . . . . . . . . . . .   4\n        2.1.3. Peer Entity authentication . . . . . . . . . .   4\n   2.2. Non-Repudiation . . . . . . . . . . . . . . . . . . .   5\n   2.3. Systems Security. . . . . . . . . . . . . . . . . . .   5\n        2.3.1. Unauthorized Usage . . . . . . . . . . . . . .   6\n        2.3.2. Inappropriate Usage. . . . . . . . . . . . . .   6\n        2.3.3. Denial of Service. . . . . . . . . . . . . . .   6\n3. The Internet Threat Model. . . . . . . . . . . . . . . . .   6\n   3.1. Limited Threat Models . . . . . . . . . . . . . . . .   7\n   3.2. Passive Attacks . . . . . . . . . . . . . . . . . . .   7\n        3.2.1. Confidentiality Violations . . . . . . . . . .   8\n        3.2.2. Password Sniffing. . . . . . . . . . . . . . .   8\n        3.2.3. Offline Cryptographic Attacks. . . . . . . . .   9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   3.3. Active Attacks. . . . . . . . . . . . . . . . . . . .   9\n        3.3.1. Replay Attacks . . . . . . . . . . . . . . . .  10\n        3.3.2. Message Insertion. . . . . . . . . . . . . . .  10\n        3.3.3. Message Deletion . . . . . . . . . . . . . . .  11\n        3.3.4. Message Modification . . . . . . . . . . . . .  11\n        3.3.5. Man-In-The-Middle. . . . . . . . . . . . . . .  12\n   3.4. Topological Issues. . . . . . . . . . . . . . . . . .  12\n   3.5. On-path versus off-path . . . . . . . . . . . . . . .  13\n   3.6. Link-local. . . . . . . . . . . . . . . . . . . . . .  13\n4. Common Issues. . . . . . . . . . . . . . . . . . . . . . .  13\n   4.1. User Authentication . . . . . . . . . . . . . . . . .  14\n        4.1.1. Username/Password. . . . . . . . . . . . . . .  14\n        4.1.2. Challenge Response and One Time Passwords. . .  14\n        4.1.3. Shared Keys. . . . . . . . . . . . . . . . . .  15\n        4.1.4. Key Distribution Centers . . . . . . . . . . .  15\n        4.1.5. Certificates . . . . . . . . . . . . . . . . .  15\n        4.1.6. Some Uncommon Systems. . . . . . . . . . . . .  15\n        4.1.7. Host Authentication. . . . . . . . . . . . . .  16\n   4.2. Generic Security Frameworks . . . . . . . . . . . . .  16\n   4.3. Non-repudiation . . . . . . . . . . . . . . . . . . .  17\n   4.4. Authorization vs. Authentication. . . . . . . . . . .  18\n        4.4.1. Access Control Lists . . . . . . . . . . . . .  18\n        4.4.2. Certificate Based Systems. . . . . . . . . . .  18\n   4.5. Providing Traffic Security. . . . . . . . . . . . . .  19\n        4.5.1. IPsec. . . . . . . . . . . . . . . . . . . . .  19\n        4.5.2. SSL/TLS. . . . . . . . . . . . . . . . . . . .  20\n        4.5.3. Remote Login . . . . . . . . . . . . . . . . .  22\n   4.6. Denial of Service Attacks and Countermeasures . . . .  22\n        4.6.1. Blind Denial of Service. . . . . . . . . . . .  23\n        4.6.2. Distributed Denial of Service. . . . . . . . .  23\n        4.6.3. Avoiding Denial of Service . . . . . . . . . .  24\n        4.6.4. Example: TCP SYN Floods. . . . . . . . . . . .  24\n        4.6.5. Example: Photuris. . . . . . . . . . . . . . .  25\n   4.7. Object vs. Channel Security . . . . . . . . . . . . .  25\n   4.8. Firewalls and Network Topology. . . . . . . . . . . .  26\n5. Writing Security Considerations Sections . . . . . . . . .  26\n6. Examples . . . . . . . . . . . . . . . . . . . . . . . . .  28\n   6.1. SMTP. . . . . . . . . . . . . . . . . . . . . . . . .  29\n        6.1.1. Security Considerations. . . . . . . . . . . .  29\n        6.1.2. Communications security issues . . . . . . . .  34\n        6.1.3. Denial of Service. . . . . . . . . . . . . . .  36\n   6.2. VRRP. . . . . . . . . . . . . . . . . . . . . . . . . .36\n        6.2.1. Security Considerations. . . . . . . . . . . .  36\n7. Acknowledgments. . . . . . . . . . . . . . . . . . . . . .  38\n8. Normative References . . . . . . . . . . . . . . . . . . .  39\n9. Informative References . . . . . . . . . . . . . . . . . .  41\n10.Security Considerations. . . . . . . . . . . . . . . . . .  42\nAppendix A. . . . . . . . . . . . . . . . . . . . . . . . . .  43",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Authors' Addresses. . . . . . . . . . . . . . . . . . . . . .  43\nFull Copyright Statement. . . . . . . . . . . . . . . . . . .  44",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "All RFCs are required by RFC 2223 to contain a Security Considerations section. The purpose of this is both to encourage document authors to consider security in their designs and to inform the reader of relevant security issues. This memo is intended to provide guidance to RFC authors in service of both ends.",
      "ja": "すべてのRFCは、Security Considerations部を含むようにRFC 2223で必要とされています。この目的は、自分たちのデザインで、セキュリティを考慮した文書の作成者を奨励するために、関連するセキュリティ問題の読者に知らせることもあります。このメモは、両端のサービスでRFC著者にガイダンスを提供することを意図しています。"
    },
    {
      "indent": 3,
      "text": "This document is structured in three parts. The first is a combination security tutorial and definition of common terms; the second is a series of guidelines for writing Security Considerations; the third is a series of examples.",
      "ja": "この文書は、3つの部分で構成されています。最初は、組み合わせのセキュリティチュートリアルと一般的な用語の定義です。第二には、セキュリティの考慮事項を記述するためのガイドラインのシリーズです。第三は、一連の実施例です。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements",
      "section_title": true,
      "ja": "1.1。必要条件"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [KEYWORDS].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119 [KEYWORDS]で説明されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The Goals of Security",
      "section_title": true,
      "ja": "2.セキュリティの目標"
    },
    {
      "indent": 3,
      "text": "Most people speak of security as if it were a single monolithic property of a protocol or system, however, upon reflection, one realizes that it is clearly not true. Rather, security is a series of related but somewhat independent properties. Not all of these properties are required for every application.",
      "ja": "それは、プロトコルやシステムの単一のモノリシック財産であるかのようにほとんどの人がセキュリティの話、しかし、反射時に、人はそれが明確に真実ではないことを実現しています。むしろ、セキュリティが関連しているが、やや独立した一連のプロパティです。これらの性質のすべては、すべてのアプリケーションのために必要なわけではありません。"
    },
    {
      "indent": 3,
      "text": "We can loosely divide security goals into those related to protecting communications (COMMUNICATION SECURITY, also known as COMSEC) and those relating to protecting systems (ADMINISTRATIVE SECURITY or SYSTEM SECURITY). Since communications are carried out by systems and access to systems is through communications channels, these goals obviously interlock, but they can also be independently provided.",
      "ja": "我々は緩く通信（またCOMSECとして知られている通信セキュリティ）及びシステム（管理セキュリティ又はシステムセキュリティ）を保護に関するもの保護に関連するものにセキュリティ目標を分割することができます。通信は、通信チャネルを介して行われ、これらの目標は明らかに連動システムおよびシステムにアクセスすることによって行われているが、彼らはまた、独立して提供することができます。ので、"
    },
    {
      "indent": 0,
      "text": "2.1. Communication Security",
      "section_title": true,
      "ja": "2.1。通信セキュリティ"
    },
    {
      "indent": 3,
      "text": "Different authors partition the goals of communication security differently. The partitioning we've found most useful is to divide them into three major categories: CONFIDENTIALITY, DATA INTEGRITY and PEER ENTITY AUTHENTICATION.",
      "ja": "別の著者は、異なる通信セキュリティの目標を分割します。機密性、データの整合性とピアエンティティ認証：我々は最も有用見つけたパーティショニングは、三つの主要なカテゴリにそれらを分割することです。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Confidentiality",
      "section_title": true,
      "ja": "2.1.1。機密性"
    },
    {
      "indent": 3,
      "text": "When most people think of security, they think of CONFIDENTIALITY. Confidentiality means that your data is kept secret from unintended listeners. Usually, these listeners are simply eavesdroppers. When an adversary taps your phone, it poses a risk to your confidentiality.",
      "ja": "ほとんどの人は、セキュリティについて考えるとき、彼らは守秘義務を考えます。機密性は、あなたのデータが意図しないリスナーから秘密に保たれていることを意味します。通常、これらのリスナーは単純に盗聴されています。敵があなたの携帯電話をタップすると、それはあなたの機密性へのリスクをもたらします。"
    },
    {
      "indent": 3,
      "text": "Obviously, if you have secrets, then you are probably concerned about others discovering them. Thus, at the very least, you want to maintain confidentiality. When you see spies in the movies go into the bathroom and turn on all the water to foil bugging, the property they're looking for is confidentiality.",
      "ja": "あなたは秘密を持っている場合は明らかに、あなたはおそらくそれらを発見し、他を懸念しています。このように、非常に少なくとも、あなたは、機密性を維持したいです。あなたは映画の中でスパイトイレに行くと盗聴箔にすべての水をオンに見ると、彼らが探しているプロパティが機密です。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Data Integrity",
      "section_title": true,
      "ja": "2.1.2。データの整合性"
    },
    {
      "indent": 3,
      "text": "The second primary goal is DATA INTEGRITY. The basic idea here is that we want to make sure that the data we receive is the same data that the sender has sent. In paper-based systems, some data integrity comes automatically. When you receive a letter written in pen you can be fairly certain that no words have been removed by an attacker because pen marks are difficult to remove from paper. However, an attacker could have easily added some marks to the paper and completely changed the meaning of the message. Similarly, it's easy to shorten the page to truncate the message.",
      "ja": "第二の主要な目標は、データの整合性です。ここでの基本的な考え方は、我々は、受信データが送信者が送信した同じデータであることを確認するということです。紙ベースのシステムでは、いくつかのデータの整合性を自動的に来ます。あなたはペンで書かれた手紙を受け取った場合、あなたはペンマークが紙から除去することが困難であるため、何も言葉が攻撃者によって削除されていないことをかなり確信することができます。しかし、攻撃者が簡単に紙にいくつかのマークを追加している可能性があり、完全にメッセージの意味を変更しました。同様に、メッセージを切り捨てるようにページを短くするのは簡単です。"
    },
    {
      "indent": 3,
      "text": "On the other hand, in the electronic world, since all bits look alike, it's trivial to tamper with messages in transit. You simply remove the message from the wire, copy out the parts you like, add whatever data you want, and generate a new message of your choosing, and the recipient is no wiser. This is the moral equivalent of the attacker taking a letter you wrote, buying some new paper and recopying the message, changing it as he does it. It's just a lot easier to do electronically since all bits look alike.",
      "ja": "すべてのビットが似ているので一方、電子の世界では、それは輸送中のメッセージを改ざんする些細なのです。あなたは、単に、ワイヤーからのメッセージを削除するには、好きなパーツをコピーし、あなたが好きなデータを追加し、あなたが選んだの新しいメッセージを生成し、受信者には賢明ではありません。これは、あなたが、彼はそれをしないようにそれを変更する、いくつかの新しい紙を購入し、メッセージを再コピー、書いた文字を取って攻撃者の道徳的等価です。すべてのビットが同じように見えるので、それは電子的に行うには、単にはるかに簡単です。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Peer Entity authentication",
      "section_title": true,
      "ja": "2.1.3。エンティティ認証ピア"
    },
    {
      "indent": 3,
      "text": "The third property we're concerned with is PEER ENTITY AUTHENTICATION. What we mean by this is that we know that one of the endpoints in the communication is the one we intended. Without peer entity authentication, it's very difficult to provide either confidentiality or data integrity. For instance, if we receive a message from Alice, the property of data integrity doesn't do us much good unless we know that it was in fact sent by Alice and not the attacker. Similarly, if we want to send a confidential message to Bob, it's not of much value to us if we're actually sending a confidential message to the attacker.",
      "ja": "私たちはと懸念している第三特性は、ピアエンティティ認証です。私たちはこれで意味することは、我々は通信におけるエンドポイントの1つは、私たちが意図したものであることを知っているということです。ピア・エンティティ認証がなければ、それは機密性やデータの整合性のいずれかを提供することは非常に困難です。私たちはアリスからのメッセージを受信した場合、我々はそれが実際にはアリスといない攻撃者によって送信されたことを知っている限りたとえば、データの整合性のプロパティは、私たちに多くの良いを行いません。我々はボブに秘密のメッセージを送信したい場合は、我々は実際に攻撃者に機密メッセージを送信している場合同様に、それは私たちにあまり価値がありません。"
    },
    {
      "indent": 3,
      "text": "Note that peer entity authentication can be provided asymmetrically. When you call someone on the phone, you can be fairly certain that you have the right person -- or at least that you got a person who's actually at the phone number you called. On the other hand, if they don't have caller ID, then the receiver of a phone call has no idea who's calling them. Calling someone on the phone is an example of recipient authentication, since you know who the recipient of the call is, but they don't know anything about the sender.",
      "ja": "ピア・エンティティ認証を非対称的に提供できることに注意してください。あなたが呼ばれる電話番号で、実際だ人を得たか、少なくとも、 - あなたが電話で誰かを呼び出すと、あなたは右の人を持っていることをかなり確信することができます。彼らは、発信者IDをお持ちでない場合一方、その後、電話の受信機は、それらを呼び出していないアイデアを持っていません。電話で誰かを呼び出すと、あなたは、コールの受信者が誰であるか知っているので、受信者認証の一例であるが、彼らは、送信者について何も知りません。"
    },
    {
      "indent": 3,
      "text": "In messaging situations, you often wish to use peer entity authentication to establish the identity of the sender of a certain message. In such contexts, this property is called DATA ORIGIN AUTHENTICATION.",
      "ja": "メッセージングの状況では、多くの場合、特定のメッセージの送信者のアイデンティティを確立するために、ピアエンティティ認証を使用したいです。そのような状況では、このプロパティは、データ源認証と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "2.2. Non-Repudiation",
      "section_title": true,
      "ja": "2.2。否認防止"
    },
    {
      "indent": 3,
      "text": "A system that provides endpoint authentication allows one party to be certain of the identity of someone with whom he is communicating. When the system provides data integrity a receiver can be sure of both the sender's identity and that he is receiving the data that that sender meant to send. However, he cannot necessarily demonstrate this fact to a third party. The ability to make this demonstration is called NON-REPUDIATION.",
      "ja": "エンドポイントの認証を提供するシステムは、一方の当事者が、彼が通信している誰と誰かの身元の特定にすることができます。システムは、データの整合性を提供すると受信側は送信者の両方の身元の確認することができますし、彼がデータを受信して​​いることを意味している送信者が送信すること。しかし、彼は必ずしも第三者にこの事実を立証することはできません。このデモを作る能力は、否認防止と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "There are many situations in which non-repudiation is desirable. Consider the situation in which two parties have signed a contract which one party wishes to unilaterally abrogate. He might simply claim that he had never signed it in the first place. Non-repudiation prevents him from doing so, thus protecting the counterparty.",
      "ja": "否認防止が望まれる多くの状況があります。 2人の当事者が一方の当事者が一方的に廃止することを希望する契約を締結している状況を考えてみましょう。彼は単に彼が最初の場所でそれに署名したことがなかったと主張するかもしれません。否認防止は、このように、相手方を保護し、そうすることから彼を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, non-repudiation can be very difficult to achieve in practice and naive approaches are generally inadequate. Section 4.3 describes some of the difficulties, which generally stem from the fact that the interests of the two parties are not aligned -- one party wishes to prove something that the other party wishes to deny.",
      "ja": "残念ながら、否認防止は、実際に達成し、素朴なアプローチは、一般的に不十分であることは非常に困難な場合があります。 4.3節は、一般的に2つの政党の利害が揃っていないという事実から生じる困難のいくつかを説明 - 一方の当事者が他の当事者は否定したい何かを証明したいです。"
    },
    {
      "indent": 0,
      "text": "2.3. Systems Security",
      "section_title": true,
      "ja": "2.3。システムセキュリティ"
    },
    {
      "indent": 3,
      "text": "In general, systems security is concerned with protecting one's machines and data. The intent is that machines should be used only by authorized users and for the purposes that the owners intend. Furthermore, they should be available for those purposes. Attackers should not be able to deprive legitimate users of resources.",
      "ja": "一般に、システムのセキュリティは、自分のマシンとデータを保護するとの懸念です。その意図は、マシンが唯一許可されたユーザによってと所有者が意図する目的のために使用されるべきであるということです。さらに、彼らはそれらの目的のために利用可能であるべきです。攻撃者は、リソースの正当なユーザーを奪うことはできないはずです。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Unauthorized Usage",
      "section_title": true,
      "ja": "2.3.1。不正な使用法"
    },
    {
      "indent": 3,
      "text": "Most systems are not intended to be completely accessible to the public. Rather, they are intended to be used only by certain authorized individuals. Although many Internet services are available to all Internet users, even those servers generally offer a larger subset of services to specific users. For instance, Web Servers often will serve data to any user, but restrict the ability to modify pages to specific users. Such modifications by the general public would be UNAUTHORIZED USAGE.",
      "ja": "ほとんどのシステムは、公衆に完全にアクセスできるように意図されていません。むしろ、彼らは唯一の特定の許可された個人が使用することを意図しています。多くのインターネットサービスは、すべてのインターネットユーザーに利用可能であるが、でも、これらのサーバーは、通常、特定のユーザーにサービスのより大きなサブセットを提供します。たとえば、Webサーバーは、多くの場合、すべてのユーザにデータを提供しますが、特定のユーザーにページを修正する能力を制限します。一般市民によってこのような修飾は、不正使用になります。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Inappropriate Usage",
      "section_title": true,
      "ja": "2.3.2。不適切な使用法"
    },
    {
      "indent": 3,
      "text": "Being an authorized user does not mean that you have free run of the system. As we said above, some activities are restricted to authorized users, some to specific users, and some activities are generally forbidden to all but administrators. Moreover, even activities which are in general permitted might be forbidden in some cases. For instance, users may be permitted to send email but forbidden from sending files above a certain size, or files which contain viruses. These are examples of INAPPROPRIATE USAGE.",
      "ja": "許可されたユーザであることは、あなたがシステムのフリーランを持っていることを意味するものではありません。我々は上記の言ったように、いくつかの活動が許可されたユーザー、特定のユーザーにいくつかに制限され、そしていくつかの活動は、一般的に、管理者以外のすべてに禁止されています。また、一般的に許可されていても活動は、いくつかのケースでは禁止される可能性があります。たとえば、ユーザーが電子メールを送信することを許可することができるが、ウイルスが含まれている一定規模以上のファイル、またはファイルを送信することを禁止します。これらは、不適切な使用例です。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Denial of Service",
      "section_title": true,
      "ja": "2.3.3。サービス拒否"
    },
    {
      "indent": 3,
      "text": "Recall that our third goal was that the system should be available to legitimate users. A broad variety of attacks are possible which threaten such usage. Such attacks are collectively referred to as DENIAL OF SERVICE attacks. Denial of service attacks are often very easy to mount and difficult to stop. Many such attacks are designed to consume machine resources, making it difficult or impossible to serve legitimate users. Other attacks cause the target machine to crash, completely denying service to users.",
      "ja": "私たちの3番目の目標は、システムが正規のユーザに利用可能であるべきであるということであったことを思い出してください。攻撃の幅広いような使い方を脅かすている可能です。そのような攻撃をまとめてサービス拒否攻撃と呼ばれています。サービス妨害攻撃は、多くの場合、非常にマウントしやすくして停止することは困難です。多くのこのような攻撃は、それが困難または不可能正当なユーザーにサービスを提供すること、マシンのリソースを消費するように設計されています。他の攻撃は完全にユーザーへのサービスを拒否、ターゲットマシンがクラッシュします。"
    },
    {
      "indent": 0,
      "text": "3. The Internet Threat Model",
      "section_title": true,
      "ja": "3.インターネットの脅威モデル"
    },
    {
      "indent": 3,
      "text": "A THREAT MODEL describes the capabilities that an attacker is assumed to be able to deploy against a resource. It should contain such information as the resources available to an attacker in terms of information, computing capability, and control of the system. The purpose of a threat model is twofold. First, we wish to identify the threats we are concerned with. Second, we wish to rule some threats explicitly out of scope. Nearly every security system is vulnerable to a sufficiently dedicated and resourceful attacker.",
      "ja": "脅威モデルは、攻撃者がリソースに対して展開することができると想定される機能を記述しています。これは、情報の点で攻撃、計算能力、およびシステムの制御に使用可能なリソースなどの情報を含むべきです。脅威モデルの目的は2つです。まず、我々は我々が関係している脅威を識別したいです。第二に、我々はスコープ外に明示的にいくつかの脅威を支配したいです。ほぼすべてのセキュリティシステムは十分に献身的で機知に攻撃に対して脆弱です。"
    },
    {
      "indent": 3,
      "text": "The Internet environment has a fairly well understood threat model. In general, we assume that the end-systems engaging in a protocol exchange have not themselves been compromised. Protecting against an attack when one of the end-systems has been compromised is extraordinarily difficult. It is, however, possible to design protocols which minimize the extent of the damage done under these circumstances.",
      "ja": "インターネット環境はかなりよく理解脅威モデルを持っています。一般的に、我々は、プロトコル交換に従事するエンドシステム自体が危険にさらされていないことを前提としています。エンドシステムのいずれかが侵害された攻撃に対する保護は非常に困難です。このような状況下で行わ損傷の程度を最小限にプロトコルを設計することは可能です。"
    },
    {
      "indent": 3,
      "text": "By contrast, we assume that the attacker has nearly complete control of the communications channel over which the end-systems communicate. This means that the attacker can read any PDU (Protocol Data Unit) on the network and undetectably remove, change, or inject forged packets onto the wire. This includes being able to generate packets that appear to be from a trusted machine. Thus, even if the end-system with which you wish to communicate is itself secure, the Internet environment provides no assurance that packets which claim to be from that system in fact are.",
      "ja": "対照的に、我々は、攻撃者は、エンドシステムが通信するための通信チャネルのほぼ完全な制御を有すると仮定する。これは、攻撃者がネットワーク上の任意のPDU（プロトコルデータユニット）を読み、検出できない、削除、変更、またはワイヤ上に偽造パケットを注入することができることを意味します。これは、信頼できるマシンからのように見えるパケットを生成することが可能であることを含みます。あなたが通信したいとエンドシステムが安全そのものであってもこのように、インターネット環境は、実際にそのシステムからのものであると主張するパケットであることを保証するものではなく。"
    },
    {
      "indent": 3,
      "text": "It's important to realize that the meaning of a PDU is different at different levels. At the IP level, a PDU means an IP packet. At the TCP level, it means a TCP segment. At the application layer, it means some kind of application PDU. For instance, at the level of email, it might either mean an RFC-822 message or a single SMTP command. At the HTTP level, it might mean a request or response.",
      "ja": "これは、PDUの意味が異なるレベルで異なっていることを認識することが重要です。 IPレベルでは、PDUは、IPパケットを意味しています。 TCPレベルでは、TCPセグメントを意味しています。アプリケーション層では、アプリケーションPDUのいくつかの種類を意味します。例えば、電子メールのレベルでは、それはどちらかRFC-822メッセージまたは単一のSMTPコマンドを意味するかもしれません。 HTTPレベルでは、要求または応答を意味するかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.1. Limited Threat Models",
      "section_title": true,
      "ja": "3.1。限定脅威モデル"
    },
    {
      "indent": 3,
      "text": "As we've said, a resourceful and dedicated attacker can control the entire communications channel. However, a large number of attacks can be mounted by an attacker with fewer resources. A number of currently known attacks can be mounted by an attacker with limited control of the network. For instance, password sniffing attacks can be mounted by an attacker who can only read arbitrary packets. This is generally referred to as a PASSIVE ATTACK [INTAUTH].",
      "ja": "我々が言ったように、機知と専用の攻撃者は、全体の通信チャネルを制御することができます。しかし、攻撃の大多数は、少ないリソースで、攻撃者によってマウントすることができます。現在知られている攻撃の数は、ネットワークの限られた制御を持つ攻撃者によって実装することができます。たとえば、パスワード盗聴攻撃が唯一の任意のパケットを読み取ることができ、攻撃者によってマウントすることができます。これは、一般PASSIVE ATTACK [INTAUTH]と呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "By contrast, Morris' sequence number guessing attack [SEQNUM] can be mounted by an attacker who can write but not read arbitrary packets. Any attack which requires the attacker to write to the network is known as an ACTIVE ATTACK.",
      "ja": "対照的に、攻撃を推測モリスのシーケンス番号は[SEQNUM】書き込みが、任意のパケットを読み取ることができない攻撃者によって装着することができます。ネットワークへの書き込みに、攻撃者が必要とするあらゆる攻撃は積極的な攻撃として知られています。"
    },
    {
      "indent": 3,
      "text": "Thus, a useful way of organizing attacks is to divide them based on the capabilities required to mount the attack. The rest of this section describes these categories and provides some examples of each category.",
      "ja": "このように、攻撃を整理するのに有用な方法は、攻撃をマウントするのに必要な機能に基づいて、それらを分割することです。このセクションの残りの部分は、これらのカテゴリについて説明し、各カテゴリのいくつかの例を提供します。"
    },
    {
      "indent": 0,
      "text": "3.2. Passive Attacks",
      "section_title": true,
      "ja": "3.2。受動的攻撃"
    },
    {
      "indent": 3,
      "text": "In a passive attack, the attacker reads packets off the network but does not write them. The simplest way to mount such an attack is to simply be on the same LAN as the victim. On most common LAN configurations, including Ethernet, 802.3, and FDDI, any machine on the wire can read all traffic destined for any other machine on the same LAN. Note that switching hubs make this sort of sniffing substantially more difficult, since traffic destined for a machine only goes to the network segment which that machine is on.",
      "ja": "受動的攻撃では、攻撃者がネットワークからパケットを読み取りますが、それらを書き込みません。このような攻撃をマウントする最も簡単な方法は、単に被害者と同じLAN上にあることです。イーサネット、802.3、およびFDDIなど、最も一般的なLANの設定、で、ワイヤ上の任意のマシンが同じLAN上の他のマシン宛のすべてのトラフィックを読むことができます。マシン宛てのトラフィックのみ、そのマシンがオンになっているネットワークセグメントになるので、スイッチングハブは、実質的に困難な盗聴のこの種を作ることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Similarly, an attacker who has control of a host in the communications path between two victim machines is able to mount a passive attack on their communications. It is also possible to compromise the routing infrastructure to specifically arrange that traffic passes through a compromised machine. This might involve an active attack on the routing infrastructure to facilitate a passive attack on a victim machine.",
      "ja": "同様に、2台の被害者のマシン間の通信経路にホストを制御している攻撃者は、彼らのコミュニケーション上の受動的な攻撃を仕掛けることが可能です。特にトラフィックが侵入したマシンを通過することを手配するために、ルーティングインフラストラクチャを妥協することも可能です。これは、被害者のマシン上の受動的攻撃を容易にするために、ルーティングインフラストラクチャへの積極的な攻撃を伴うかもしれません。"
    },
    {
      "indent": 3,
      "text": "Wireless communications channels deserve special consideration, especially with the recent and growing popularity of wireless-based LANs, such as those using 802.11. Since the data is simply broadcast on well known radio frequencies, an attacker simply needs to be able to receive those transmissions. Such channels are especially vulnerable to passive attacks. Although many such channels include cryptographic protection, it is often of such poor quality as to be nearly useless [WEP].",
      "ja": "ワイヤレス通信チャネルは、特に、802.11を使用したものなどの無線ベースのLANの最近の人気の高まりとともに、特別な配慮に値します。データは単純によく知られて無線周波数を上に放送されるので、攻撃者は、単にそれらの送信を受信できるようにする必要があります。このようなチャンネルは、受動的攻撃に対して特に脆弱です。このような多くのチャンネルが暗号保護を含むが、ほとんど役に立たない[WEP]なるように、それは多くの場合、このような低品質のです。"
    },
    {
      "indent": 3,
      "text": "In general, the goal of a passive attack is to obtain information which the sender and receiver would prefer to remain private. This private information may include credentials useful in the electronic world and/or passwords or credentials useful in the outside world, such as confidential business information.",
      "ja": "一般的には、受動的攻撃の目的は、送信者と受信者がプライベート残ることを好むだろうな情報を得ることです。この個人情報は、業務上の機密情報として外の世界で有用な電子世界で有用資格情報および/またはパスワードや認証情報を含むことができます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Confidentiality Violations",
      "section_title": true,
      "ja": "3.2.1。守秘義務違反"
    },
    {
      "indent": 3,
      "text": "The classic example of passive attack is sniffing some inherently private data off of the wire. For instance, despite the wide availability of SSL, many credit card transactions still traverse the Internet in the clear. An attacker could sniff such a message and recover the credit card number, which can then be used to make fraudulent transactions. Moreover, confidential business information is routinely transmitted over the network in the clear in email.",
      "ja": "受動的攻撃の古典的な例は、ワイヤのオフにいくつかの本質的に個人データを盗聴されています。たとえば、SSLの幅広い利用可能性にもかかわらず、多くのクレジットカード取引は、まだ明らかにインターネットを横断します。攻撃者は、このようなメッセージを盗聴して、不正取引を行うために使用することができますクレジットカード番号を、回復することができます。また、業務上の機密情報を定期メールで明らかにネットワークを介して送信されます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Password Sniffing",
      "section_title": true,
      "ja": "3.2.2。パスワードのスニッフィング"
    },
    {
      "indent": 3,
      "text": "Another example of a passive attack is PASSWORD SNIFFING. Password sniffing is directed towards obtaining unauthorized use of resources. Many protocols, including [TELNET], [POP], and [NNTP] use a shared password to authenticate the client to the server. Frequently, this password is transmitted from the client to the server in the clear over the communications channel. An attacker who can read this traffic can therefore capture the password and REPLAY it. In other words, the attacker can initiate a connection to the server and pose as the client and login using the captured password.",
      "ja": "受動的攻撃の別の例は、パスワードの盗聴です。パスワードの盗聴は、資源の不正利用を取得に向けられています。多くの[TELNET]、[POP]を含むプロトコル、および[NNTP]サーバにクライアントを認証するために、共有パスワードを使用します。多くの場合、このパスワードは、通信チャネルを介して平文でクライアントからサーバに送信されます。このトラフィックを読むことができる攻撃者は、したがって、パスワードをキャプチャし、それを再生することができます。つまり、攻撃者がサーバーへの接続を開始することができ、取り込んだパスワードを使用して、クライアントとログインとして提起します。"
    },
    {
      "indent": 3,
      "text": "Note that although the login phase of the attack is active, the actual password capture phase is passive. Moreover, unless the server checks the originating address of connections, the login phase does not require any special control of the network.",
      "ja": "攻撃のログインフェーズがアクティブになっているものの、実際のパスワードのキャプチャ段階は、受動的であることに注意してください。サーバが接続の発信元アドレスをチェックしない限り、また、ログインフェーズでは、ネットワークの任意の特別な制御を必要としません。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Offline Cryptographic Attacks",
      "section_title": true,
      "ja": "3.2.3。オフライン暗号攻撃"
    },
    {
      "indent": 3,
      "text": "Many cryptographic protocols are subject to OFFLINE ATTACKS. In such a protocol, the attacker recovers data which has been processed using the victim's secret key and then mounts a cryptanalytic attack on that key. Passwords make a particularly vulnerable target because they are typically low entropy. A number of popular password-based challenge response protocols are vulnerable to DICTIONARY ATTACK. The attacker captures a challenge-response pair and then proceeds to try entries from a list of common words (such as a dictionary file) until he finds a password that produces the right response.",
      "ja": "多くの暗号プロトコルがOFFLINE攻撃の対象となっています。このようなプロトコルでは、攻撃者は被害者の秘密鍵を使用して処理されたデータを回復し、そのキーの暗号解読攻撃をマウントします。彼らは一般的に、低エントロピーであるため、パスワードは特に脆弱ターゲットを作ります。人気のパスワードベースのチャレンジレスポンスプロトコルの数は、辞書攻撃に対して脆弱です。攻撃者は、チャレンジ・レスポンスペアを取り込み、その後、彼は右の応答を生成したパスワードが見つかるまで（例えば、辞書ファイルなど）一般的な単語のリストからエントリを試しに進みます。"
    },
    {
      "indent": 3,
      "text": "A similar such attack can be mounted on a local network when NIS is used. The Unix password is crypted using a one-way function, but tools exist to break such crypted passwords [KLEIN]. When NIS is used, the crypted password is transmitted over the local network and an attacker can thus sniff the password and attack it.",
      "ja": "NISを使用する場合に同様のそのような攻撃は、ローカルネットワーク上に取り付けることができます。 Unixのパスワードは、一方向関数を用いて暗号化されますが、ツールは、そのような暗号化されたパスワード[KLEIN]を破るために存在しています。 NISを使用する場合は、暗号化されたパスワードは、ローカルネットワークを介して送信されると、攻撃者は、このように、パスワードを盗聴し、それを攻撃することができます。"
    },
    {
      "indent": 3,
      "text": "Historically, it has also been possible to exploit small operating system security holes to recover the password file using an active attack. These holes can then be bootstrapped into an actual account by using the aforementioned offline password recovery techniques. Thus we combine a low-level active attack with an offline passive attack.",
      "ja": "歴史的に、また、積極的な攻撃を使用してパスワードファイルを回復するために小型のオペレーティングシステムのセキュリティホールを悪用することが可能でした。これらの穴は、その後、前述のオフラインパスワード回復技術を使用することにより、実際の口座にブートストラップすることができます。したがって、私たちは、オフラインでの受動的攻撃と低レベルの積極的な攻撃を兼ね備えています。"
    },
    {
      "indent": 0,
      "text": "3.3. Active Attacks",
      "section_title": true,
      "ja": "3.3。アクティブな攻撃"
    },
    {
      "indent": 3,
      "text": "When an attack involves writing data to the network, we refer to this as an ACTIVE ATTACK. When IP is used without IPsec, there is no authentication for the sender address. As a consequence, it's straightforward for an attacker to create a packet with a source address of his choosing. We'll refer to this as a SPOOFING ATTACK.",
      "ja": "攻撃がネットワークへのデータの書き込みを必要とするとき、私たちは積極的な攻撃としてこれを参照してください。 IPは、IPsecのなしで使用される場合、送信者アドレスのための認証はありません。結果として、それは彼が選んだの送信元アドレスを持つパケットを作成するには、攻撃者のための簡単です。私たちは、スプーフィング攻撃としてこれを参照します。"
    },
    {
      "indent": 3,
      "text": "Under certain circumstances, such a packet may be screened out by the network. For instance, many packet filtering firewalls screen out all packets with source addresses on the INTERNAL network that arrive on the EXTERNAL interface. Note, however, that this provides no protection against an attacker who is inside the firewall. In general, designers should assume that attackers can forge packets.",
      "ja": "特定の状況下では、そのようなパケットは、ネットワークによってスクリーニングすることができます。例えば、多くのパケットフィルタリングファイアウォールは、外部インターフェイスに到達し、内部ネットワーク上のソースアドレスを持つすべてのパケットを選別します。これは、ファイアウォールの内側にある攻撃に対する保護を提供しないこと、しかし、注意してください。一般的には、設計者は、攻撃者がパケットを偽造することができていることを前提とすべきです。"
    },
    {
      "indent": 3,
      "text": "However, the ability to forge packets does not go hand in hand with the ability to receive arbitrary packets. In fact, there are active attacks that involve being able to send forged packets but not receive the responses. We'll refer to these as BLIND ATTACKS.",
      "ja": "しかし、パケットを偽造する機能は、任意のパケットを受信する能力を持つ手をつないで行くことはありません。実際には、偽造パケットを送信したが応答を受信しないことができるという伴う活発な攻撃があります。私たちは、これらのようなBLIND攻撃を呼びます。"
    },
    {
      "indent": 3,
      "text": "Note that not all active attacks require forging addresses. For instance, the TCP SYN denial of service attack [TCPSYN] can be mounted successfully without disguising the sender's address. However, it is common practice to disguise one's address in order to conceal one's identity if an attack is discovered.",
      "ja": "いないすべてのアクティブな攻撃は鍛造アドレスを必要とすることに注意してください。例えば、サービスの攻撃[TCPSYN]のTCP SYN拒否は、送信者のアドレスを偽装することなく、正常にマウントすることができます。しかし、攻撃が発見された場合は、1つの身元を隠すために自分のアドレスを偽装するのが一般的です。"
    },
    {
      "indent": 3,
      "text": "Each protocol is susceptible to specific active attacks, but experience shows that a number of common patterns of attack can be adapted to any given protocol. The next sections describe a number of these patterns and give specific examples of them as applied to known protocols.",
      "ja": "各プロトコルは、特定のアクティブな攻撃を受けやすいが、経験は、攻撃の一般的なパターンの数は任意のプロトコルに適合させることができることを示しています。次のセクションでは、これらのパターンの数を記述し、既知のプロトコルに適用されるようなそれらの具体的な例を与えます。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Replay Attacks",
      "section_title": true,
      "ja": "3.3.1。リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "In a REPLAY ATTACK, the attacker records a sequence of messages off of the wire and plays them back to the party which originally received them. Note that the attacker does not need to be able to understand the messages. He merely needs to capture and retransmit them.",
      "ja": "リプレイ攻撃では、攻撃者は、ワイヤの切断メッセージのシーケンスを記録し、元々それらを受け取った当事者に戻ってそれらを果たしています。攻撃者がメッセージを理解できるようにする必要がないことに注意してください。彼は単にキャプチャし、それらを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, consider the case where an S/MIME message is being used to request some service, such as a credit card purchase or a stock trade. An attacker might wish to have the service executed twice, if only to inconvenience the victim. He could capture the message and replay it, even though he can't read it, causing the transaction to be executed twice.",
      "ja": "例えば、S / MIMEメッセージは、クレジットカードの購入や株式取引などの一部のサービスを要求するために使用されている場合を考えます。唯一の犠牲者を迷惑している場合、攻撃者は、サービスが2回実行していることを望むかもしれません。彼は、トランザクションが2回実行させる、それを読むことができないにもかかわらず、メッセージをキャプチャし、それを再生することができます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Message Insertion",
      "section_title": true,
      "ja": "3.3.2。メッセージ挿入"
    },
    {
      "indent": 3,
      "text": "In a MESSAGE INSERTION attack, the attacker forges a message with some chosen set of properties and injects it into the network. Often this message will have a forged source address in order to disguise the identity of the attacker.",
      "ja": "メッセージ挿入攻撃では、攻撃者は、プロパティの一部の選択されたセットを使用して、メッセージを偽造し、ネットワークにそれを注入します。多くの場合、このメッセージは、攻撃者の身元を偽装するために、偽造送信元アドレスを持つことになります。"
    },
    {
      "indent": 3,
      "text": "For example, a denial-of-service attack can be mounted by inserting a series of spurious TCP SYN packets directed towards the target host. The target host responds with its own SYN and allocates kernel data structures for the new connection. The attacker never completes the 3-way handshake, so the allocated connection endpoints just sit there taking up kernel memory. Typical TCP stack implementations only allow some limited number of connections in this \"half-open\" state and when this limit is reached, no more connections can be initiated, even from legitimate hosts. Note that this attack is a blind attack, since the attacker does not need to process the victim's SYNs.",
      "ja": "例えば、サービス拒否攻撃は、ターゲットホストに向けスプリアスTCPのSYNパケットのシリーズを挿入することによって実装することができます。ターゲットホストは、独自のSYNで応答し、新しい接続のためのカーネルデータ構造体を割り当てます。攻撃者は、3ウェイハンドシェイクが完了したことがないので、割り当てられた接続エンドポイントは、ちょうどカーネルメモリを占有してそこに座って。典型的なTCPスタックの実装は、この「ハーフオープン」状態の接続のいくつかの限られた数のみを許可し、この制限に達すると、それ以上の接続がさえ正当なホストから、開始することができます。攻撃者は被害者ののSYNを処理する必要がないため、この攻撃は、盲目の攻撃であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Message Deletion",
      "section_title": true,
      "ja": "3.3.3。メッセージの削除"
    },
    {
      "indent": 3,
      "text": "In a MESSAGE DELETION attack, the attacker removes a message from the wire. Morris' sequence number guessing attack [SEQNUM] often requires a message deletion attack to be performed successfully. In this blind attack, the host whose address is being forged will receive a spurious TCP SYN packet from the host being attacked. Receipt of this SYN packet generates a RST, which would tear the illegitimate connection down. In order to prevent this host from sending a RST so that the attack can be carried out successfully, Morris describes flooding this host to create queue overflows such that the SYN packet is lost and thus never responded to.",
      "ja": "メッセージ削除攻撃では、攻撃者は、ワイヤからのメッセージを削除します。モリスのシーケンス番号推測攻撃は[SEQNUM]多くの場合、正常に実行されるようにメッセージ削除攻撃が必要です。この盲目の攻撃では、アドレスが偽造されているホストが攻撃されているホストからのスプリアスTCP SYNパケットを受信します。このSYNパケットの受信ダウン不正な接続を引き裂くだろうRSTを生成します。攻撃が成功して行うことができるようにRSTを送信してから、このホストを防ぐために、モリスは、SYNパケットが失われたため、応答されることはありませんようキューのオーバーフローを作成するには、このホストを氾濫について説明します。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Message Modification",
      "section_title": true,
      "ja": "3.3.4。メッセージを変更します"
    },
    {
      "indent": 3,
      "text": "In a MESSAGE MODIFICATION attack, the attacker removes a message from the wire, modifies it, and reinjects it into the network. This sort of attack is particularly useful if the attacker wants to send some of the data in the message but also wants to change some of it.",
      "ja": "メッセージ修正攻撃では、攻撃者がそれを変更し、ワイヤからメッセージを削除し、ネットワークにそれを再注入します。攻撃者は、メッセージ内のデータの一部を送信したいだけでなく、その一部を変更したい場合は、この種の攻撃は特に便利です。"
    },
    {
      "indent": 3,
      "text": "Consider the case where the attacker wants to attack an order for goods placed over the Internet. He doesn't have the victim's credit card number so he waits for the victim to place the order and then replaces the delivery address (and possibly the goods description) with his own. Note that this particular attack is known as a CUT-AND-PASTE attack since the attacker cuts the credit card number out of the original message and pastes it into the new message.",
      "ja": "攻撃者は、インターネット上に置かれた商品の注文を攻撃したい場合を考えてみましょう。彼は順序を置くために被害者を待ち、その後、彼自身で配信アドレス（そしておそらく商品説明）を置き換えるので、彼は被害者のクレジットカード番号を持っていません。攻撃者は元のメッセージのうち、クレジットカード番号をカットして、新しいメッセージにそれを貼り付けするので、この特定の攻撃をカットアンドペースト攻撃として知られていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Another interesting example of a cut-and-paste attack is provided by [IPSPPROB]. If IPsec ESP is used without any MAC then it is possible for the attacker to read traffic encrypted for a victim on the same machine. The attacker attaches an IP header corresponding to a port he controls onto the encrypted IP packet. When the packet is received by the host it will automatically be decrypted and forwarded to the attacker's port. Similar techniques can be used to mount a session hijacking attack. Both of these attacks can be avoided by always using message authentication when you use encryption. Note that this attack only works if (1) no MAC check is being used, since this attack generates damaged packets (2) a host-to-host SA is being used, since a user-to-user SA will result in an inconsistency between the port associated with the SA and the target port. If the receiving machine is single-user than this attack is infeasible.",
      "ja": "カットアンドペースト攻撃の別の興味深い例は、[IPSPPROB]によって提供されます。 IPsecのESPは、任意のMACなしで使用されている場合、攻撃者が同じマシン上で被害者のために暗号化されたトラフィックを読むこと、それが可能です。攻撃者は、彼が暗号化されたIPパケットに制御するポートに対応したIPヘッダを付加します。パケットがホストによって受信されると、それは自動的に復号化し、攻撃者のポートに転送されます。同様の技術は、セッションハイジャック攻撃をマウントするために使用することができます。これらの攻撃の両方を使用すると、暗号化を使用するときは、常にメッセージ認証を使用することによって回避することができます。 （1）は、MACチェックが使用されていない場合は、この攻撃が破損したパケットを生成するため、この攻撃にのみ、動作することに注意ユーザ対ユーザSAが矛盾をもたらすので、（2）ホストツーホストSAは、使用されていますSAとターゲットポートに関連付けられたポート間。受信機は、シングルユーザーである場合、この攻撃よりも実行不可能です。"
    },
    {
      "indent": 0,
      "text": "3.3.5. Man-In-The-Middle",
      "section_title": true,
      "ja": "3.3.5。真ん中の男"
    },
    {
      "indent": 3,
      "text": "A MAN-IN-THE-MIDDLE attack combines the above techniques in a special form: The attacker subverts the communication stream in order to pose as the sender to receiver and the receiver to the sender:",
      "ja": "MAN-IN-THE-middle攻撃は、特殊な形式で上記の技術を組み合わせ：攻撃者は、受信機に送信者と送信者に受信機としてポーズするために、通信ストリームを覆します。"
    },
    {
      "indent": 6,
      "text": "What Alice and Bob think:\nAlice  <---------------------------------------------->  Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "What's happening:\nAlice  <---------------->  Attacker  <---------------->  Bob",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This differs fundamentally from the above forms of attack because it attacks the identity of the communicating parties, rather than the data stream itself. Consequently, many techniques which provide integrity of the communications stream are insufficient to protect against man-in-the-middle attacks.",
      "ja": "それは、データがストリーム自体ではなく、通信当事者の身元を攻撃するので、これは攻撃の上記のフォームは基本的に異なります。その結果、通信ストリームの整合性を提供する多くの技術がman-in-the-middle攻撃を防御するには不十分です。"
    },
    {
      "indent": 3,
      "text": "Man-in-the-middle attacks are possible whenever a protocol lacks PEER ENTITY AUTHENTICATION. For instance, if an attacker can hijack the client TCP connection during the TCP handshake (perhaps by responding to the client's SYN before the server does), then the attacker can open another connection to the server and begin a man-in-the-middle attack. It is also trivial to mount man-in-the-middle attacks on local networks via ARP spoofing -- the attacker forges an ARP with the victim's IP address and his own MAC address. Tools to mount this sort of attack are readily available.",
      "ja": "プロトコルは、ピアエンティティ認証を欠いたびman-in-the-middle攻撃が可能です。攻撃者は（おそらく、サーバーが行う前に、クライアントのSYNに応答することによって）TCPハンドシェイク中にクライアントのTCP接続を乗っ取ることができる場合たとえば、その後、攻撃者は、サーバーへの別の接続を開き、のman-in-the-middleを開始することができます攻撃。 ARPスプーフィングを介してローカルネットワーク上のman-in-the-middle攻撃をマウントすることも簡単です - 攻撃者は、被害者のIPアドレスと自身のMACアドレスを持つARPを偽造します。この種の攻撃をマウントするツールが容易に入手可能です。"
    },
    {
      "indent": 3,
      "text": "Note that it is only necessary to authenticate one side of the transaction in order to prevent man-in-the-middle attacks. In such a situation the the peers can establish an association in which only one peer is authenticated. In such a system, an attacker can initiate an association posing as the unauthenticated peer but cannot transmit or access data being sent on a legitimate connection. This is an acceptable situation in contexts such as Web e-commerce where only the server needs to be authenticated (or the client is independently authenticated via some non-cryptographic mechanism such as a credit card number).",
      "ja": "man-in-the-middle攻撃を防ぐために、トランザクションの片側を認証するために必要なだけであることに注意してください。このような状況では、ピアは、唯一のピアが認証された関連付けを確立することができます。このようなシステムでは、攻撃者が認証されていないピアを装っアソシエーションを開始することができるが、送信することができない、またはアクセスデータが正当な接続上で送信されます。これは、サーバーのみが認証する必要があります（またはクライアントが独立して、クレジットカード番号などのいくつかの非暗号化機構を介して認証されている）は、Web、Eコマースなどの状況で許容できる状況です。"
    },
    {
      "indent": 0,
      "text": "3.4. Topological Issues",
      "section_title": true,
      "ja": "3.4。トポロジカル問題"
    },
    {
      "indent": 3,
      "text": "In practice, the assumption that it's equally easy for an attacker to read and generate all packets is false, since the Internet is not fully connected. This has two primary implications.",
      "ja": "インターネットが完全に接続されていないため、実際には、攻撃者が読んで、すべてのパケットを生成するためにも同様に簡単だという仮定は、falseです。これは、主に次の2つの意味があります。"
    },
    {
      "indent": 0,
      "text": "3.5. On-path versus off-path",
      "section_title": true,
      "ja": "3.5。パス・オン対オフパス"
    },
    {
      "indent": 3,
      "text": "In order for a datagram to be transmitted from one host to another, it generally must traverse some set of intermediate links and gateways. Such gateways are naturally able to read, modify, or remove any datagram transmitted along that path. This makes it much easier to mount a wide variety of attacks if you are on-path.",
      "ja": "別のホストから送信されるデータグラムのためには、一般に中間リンクとゲートウェイのいくつかのセットを横断しなければなりません。そのようなゲートウェイは、当然、その経路に沿って送信されたデータグラムを読み取り、変更、または削除することができます。これは、あなたが上でパスされている場合、それははるかに簡単に攻撃の多種多様をマウントすることができます。"
    },
    {
      "indent": 3,
      "text": "Off-path hosts can, of course, transmit arbitrary datagrams that appear to come from any hosts but cannot necessarily receive datagrams intended for other hosts. Thus, if an attack depends on being able to receive data, off-path hosts must first subvert the topology in order to place themselves on-path. This is by no means impossible but is not necessarily trivial.",
      "ja": "オフパスホストは、当然のことながら、任意のホストから来るように見えるが、必ずしも他のホストのために意図されたデータグラムを受信することができない任意のデータグラムを送信することができます。攻撃は、データを受信することができることに依存している場合このように、オフパスホストは最初にパス自身を配置するためにトポロジを破壊しなければなりません。これはノーであることは不可能を意味するが、必ずしも容易ではありません。"
    },
    {
      "indent": 3,
      "text": "Applications protocol designers MUST NOT assume that all attackers will be off-path. Where possible, protocols SHOULD be designed to resist attacks from attackers who have complete control of the network. However, designers are expected to give more weight to attacks which can be mounted by off-path attackers as well as on-path ones.",
      "ja": "アプリケーションプロトコルの設計者は、すべての攻撃者は、オフパスになりますと仮定してはいけません。可能であれば、プロトコルは、ネットワークの完全な制御を持つ攻撃者からの攻撃に耐えるように設計する必要があります。しかし、設計者は、オフパスの攻撃だけでなく、上のパスのもので取り付けることができ、攻撃に多くの重量を与えることが期待されています。"
    },
    {
      "indent": 0,
      "text": "3.6. Link-local",
      "section_title": true,
      "ja": "3.6。リンクローカル"
    },
    {
      "indent": 3,
      "text": "One specialized case of on-path is being on the same link. In some situations, it's desirable to distinguish between hosts who are on the local network and those who are not. The standard technique for this is verifying the IP TTL value [IP]. Since the TTL must be decremented by each forwarder, a protocol can demand that TTL be set to 255 and that all receivers verify the TTL. A receiver then has some reason to believe that conforming packets are from the same link. Note that this technique must be used with care in the presence of tunneling systems, since such systems may pass packets without decrementing TTL.",
      "ja": "上のパスの一つの特殊な場合には、同じリンク上にあるされています。いくつかの状況では、ローカルネットワーク上のホストとそうでない人たちの間で区別することが望ましいです。このための標準的な技術は、IP TTL値[IP]を検証します。 TTLは、各フォワーダだけデクリメントされなければならないので、プロトコルは、255に設定し、すべての受信機がTTLを確認することであることがTTLを要求することができます。次に、受信機は、適合するパケットが同じリンクからであると考えているためにいくつかの理由があります。このようなシステムはTTLをデクリメントせずにパケットを渡すことができるので、この技術は、トンネリングシステムの存在下で、注意して使用しなければならないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "4. Common Issues",
      "section_title": true,
      "ja": "4.一般的な問題"
    },
    {
      "indent": 3,
      "text": "Although each system's security requirements are unique, certain common requirements appear in a number of protocols. Often, when naive protocol designers are faced with these requirements, they choose an obvious but insecure solution even though better solutions are available. This section describes a number of issues seen in many protocols and the common pieces of security technology that may be useful in addressing them.",
      "ja": "各システムのセキュリティ要件がユニークですが、一定の共通要件は、プロトコルの数で表示されます。ナイーブプロトコル設計者は、これらの要件に直面しているとき、多くの場合、彼らはより良いソリューションが利用可能であっても明白が、不安定なソリューションを選択してください。このセクションでは、多くのプロトコルとそれらに対処する上で有用である可能性があるセキュリティ技術の共通部分で見られる多くの問題を説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. User Authentication",
      "section_title": true,
      "ja": "4.1。ユーザ認証"
    },
    {
      "indent": 3,
      "text": "Essentially every system which wants to control access to its resources needs some way to authenticate users. A nearly uncountable number of such mechanisms have been designed for this purpose. The next several sections describe some of these techniques.",
      "ja": "基本的にそのリソースへのアクセスを制御したいすべてのシステムは、ユーザを認証するためにいくつかの方法が必要です。そのようなメカニズムのほとんど無数には、この目的のために設計されています。次のいくつかのセクションでは、これらの技術のいくつかを説明します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Username/Password",
      "section_title": true,
      "ja": "4.1.1。ユーザー名パスワード"
    },
    {
      "indent": 3,
      "text": "The most common access control mechanism is simple USERNAME/PASSWORD The user provides a username and a reusable password to the host which he wishes to use. This system is vulnerable to a simple passive attack where the attacker sniffs the password off the wire and then initiates a new session, presenting the password. This threat can be mitigated by hosting the protocol over an encrypted connection such as TLS or IPSEC. Unprotected (plaintext) username/password systems are not acceptable in IETF standards.",
      "ja": "最も一般的なアクセス制御機構は、単純なユーザー名/パスワードは、ユーザは、ユーザ名と、彼が使用したいホストに再利用可能なパスワードを提供しています。このシステムは、攻撃者は、ワイヤ外れパスワードを盗聴し、パスワードを提示し、新しいセッションを開始し、単純な受動的攻撃に対して脆弱です。この脅威は、TLSまたはIPSECなどの暗号化接続を介してプロトコルをホストすることによって緩和することができます。保護されていない（平文）ユーザ名/パスワードシステムは、IETF標準では許容されません。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Challenge Response and One Time Passwords",
      "section_title": true,
      "ja": "4.1.2。チャレンジレスポンスとワンタイムパスワード"
    },
    {
      "indent": 3,
      "text": "Systems which desire greater security than USERNAME/PASSWORD often employ either a ONE TIME PASSWORD [OTP] scheme or a CHALLENGE-RESPONSE. In a one time password scheme, the user is provided with a list of passwords, which must be used in sequence, one time each. (Often these passwords are generated from some secret key so the user can simply compute the next password in the sequence.) SecureID and DES Gold are variants of this scheme. In a challenge-response scheme, the host and the user share some secret (which often is represented as a password). In order to authenticate the user, the host presents the user with a (randomly generated) challenge. The user computes some function based on the challenge and the secret and provides that to the host, which verifies it. Often this computation is performed in a handheld device, such as a DES Gold card.",
      "ja": "USERNAME / PASSWORDよりもより高いセキュリティを望むシステムは、しばしば、ワンタイムパスワード[OTP]スキームかチャレンジレスポンスのいずれかを採用します。ワンタイムパスワード方式では、ユーザーは、シーケンスで使用されなければならないパスワード、1時間ごとのリストを備えています。 （ユーザーは単に順序で次のパスワードを計算することができるように多くの場合、これらのパスワードは、いくつかの秘密鍵から生成されている。）SecureIDのとDES金は、このスキームの変異体です。チャレンジ・レスポンス方式では、ホストおよびユーザーは、（多くの場合、パスワードのように表されている）、いくつかの秘密を共有しています。ユーザを認証するために、ホストは、（ランダムに生成）の挑戦をユーザに提示します。ユーザーはチャレンジと秘密に基づいていくつかの関数を計算し、それを検証するホスト、にそれを提供します。多くの場合、この計算は、このようなDESゴールドカードとして、ハンドヘルドデバイスで実行されます。"
    },
    {
      "indent": 3,
      "text": "Both types of scheme provide protection against replay attack, but often still vulnerable to an OFFLINE KEYSEARCH ATTACK (a form of passive attack): As previously mentioned, often the one-time password or response is computed from a shared secret. If the attacker knows the function being used, he can simply try all possible shared secrets until he finds one that produces the right output. This is made easier if the shared secret is a password, in which case he can mount a DICTIONARY ATTACK -- meaning that he tries a list of common words (or strings) rather than just random strings.",
      "ja": "スキームの両方のタイプは、リプレイ攻撃に対する保護を提供しますが、OFFLINE KEYSEARCH ATTACK（受動的攻撃の形）に、多くの場合、まだ脆弱：前述したように、多くの場合、ワンタイムパスワードまたは応答が共有シークレットから計算されます。攻撃者が使用している機能を知っている場合、彼は右の出力を生成を見つけるまで、彼は単純にすべての可能な共有秘密を試すことができます。彼は一般的な単語（または文字列）だけではなく、ランダムな文字列のリストを試みることを意味 - 共有秘密は、彼が辞書攻撃を仕掛けることができ、その場合には、パスワード、ある場合にはこれが容易になります。"
    },
    {
      "indent": 3,
      "text": "These systems are also often vulnerable to an active attack. Unless communication security is provided for the entire session, the attacker can simply wait until authentication has been performed and hijack the connection.",
      "ja": "また、これらのシステムは、アクティブな攻撃に対して脆弱であることが多いです。通信セキュリティがセッション全体のために提供されていない限り、攻撃者は、単に認証が実行されるまで待ってから接続をハイジャックすることができます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Shared Keys",
      "section_title": true,
      "ja": "4.1.3。共有鍵"
    },
    {
      "indent": 3,
      "text": "CHALLENGE-RESPONSE type systems can be made secure against dictionary attack by using randomly generated shared keys instead of user-generated passwords. If the keys are sufficiently large then keysearch attacks become impractical. This approach works best when the keys are configured into the end nodes rather than memorized and typed in by users, since users have trouble remembering sufficiently long keys.",
      "ja": "チャレンジ・レスポンス型のシステムではなく、ユーザーが生成したパスワードのランダムに生成された共有鍵を使用することにより、辞書攻撃に対して安全で行うことができます。キーが十分に大きい場合、keysearch攻撃は非現実的になります。キーがエンド・ノードに構成されたのではなく記憶し、ユーザーが入力したされている場合、ユーザーがトラブル十分に長いキーを覚えるを持っているので、このアプローチは、最も適しています。"
    },
    {
      "indent": 3,
      "text": "Like password-based systems, shared key systems suffer from management problems. Each pair of communicating parties must have their own agreed-upon key, which leads to there being a lot of keys.",
      "ja": "パスワードベースのシステムと同様に、共有キーシステムは、管理の問題に苦しんでいます。通信当事者の各ペアは、自分が合意されたキーがたくさんあることにつながるキー、持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Key Distribution Centers",
      "section_title": true,
      "ja": "4.1.4。キー配布センター"
    },
    {
      "indent": 3,
      "text": "One approach to solving the large number of keys problem is to use an online \"trusted third party\" that mediates between the authenticating parties. The trusted third party (generally called a a KEY DISTRIBUTION CENTER (KDC)) shares a symmetric key or password with each party in the system. It first contacts the KDC which gives it a TICKET containing a randomly generated symmetric key encrypted under both peer's keys. Since only the proper peers can decrypt the symmetric key the ticket can be used to establish a trusted association. By far the most popular KDC system is Kerberos [KERBEROS].",
      "ja": "キーの問題の多数を解決するための1つのアプローチは、オンラインで認証する当事者間で仲介する「第三者を信頼さ」を使用することです。 （一般的にキー配布センター（KDC）と呼ばれる）信頼できるサードパーティは、システム内の各当事者との対称鍵やパスワードを共有しています。これは、最初の接点はそれに両方のピアの鍵で暗号化され、ランダムに生成された対称鍵を含むチケットを与えますKDC。唯一の適切なピアは、対称鍵を復号化することができますので、チケットは、信頼できるアソシエーションを確立するために使用することができます。圧倒的に最も人気のあるKDCシステムは、Kerberos [KERBEROS]です。"
    },
    {
      "indent": 0,
      "text": "4.1.5. Certificates",
      "section_title": true,
      "ja": "4.1.5。証明書"
    },
    {
      "indent": 3,
      "text": "A simple approach is to have all users have CERTIFICATES [PKIX] which they then use to authenticate in some protocol-specific way, as in [TLS] or [S/MIME]. A certificate is a signed credential binding an entity's identity to its public key. The signer of a certificate is a CERTIFICATE AUTHORITY (CA), whose certificate may itself be signed by some superior CA. In order for this system to work, trust in one or more CAs must be established in an out-of-band fashion. Such CAs are referred to as TRUSTED ROOTS or ROOT CAS. The primary obstacle to this approach in client-server type systems is that it requires clients to have certificates, which can be a deployment problem.",
      "ja": "単純なアプローチは、すべてのユーザーが、その後、[TLS]または[S / MIME]のように、いくつかのプロトコル固有の方法で認証に使用する証明書[PKIX]を持っていることです。証明書には、その公開鍵に主体のアイデンティティを結合署名した資格です。証明書の署名者は、その証明書自体は、いくつかの優れたCAによって署名することができる証明機関（CA）、ありますこのシステムが動作するためには、一の以上のCAの信頼は、帯域外の方法で確立されなければなりません。そのようなCAは、信頼されたルートまたはルートCASと呼ばれます。クライアント・サーバ型のシステムでは、このアプローチの主要な障害は、それが展開問題になることが証明書を持っているクライアントを必要とすることです。"
    },
    {
      "indent": 0,
      "text": "4.1.6. Some Uncommon Systems",
      "section_title": true,
      "ja": "4.1.6。いくつかの珍しいシステム"
    },
    {
      "indent": 3,
      "text": "There are ways to do a better job than the schemes mentioned above, but they typically don't add much security unless communications security (at least message integrity) will be employed to secure the connection, because otherwise the attacker can merely hijack the connection after authentication has been performed. A number of protocols ([EKE], [SPEKE], [SRP]) allow one to securely bootstrap a",
      "ja": "そこ上記のスキームよりも良い仕事をするための方法がありますが、通信セキュリティ（少なくとも、メッセージの整合性が）接続を確保するために使用される場合を除きそれ以外の場合は、攻撃者が単に後に接続をハイジャックすることができますので、彼らは一般的に、多くのセキュリティを追加しません認証が行われています。プロトコルの数（[EKE]、[SPEKE]、[SRP]）は、一方が確実にブートストラップすることを可能にします"
    },
    {
      "indent": 3,
      "text": "user's password into a shared key which can be used as input to a cryptographic protocol. One major obstacle to the deployment of these protocols has been that their Intellectual Property status is extremely unclear. Similarly, the user can authenticate using public key certificates (e.g., S-HTTP client authentication). Typically these methods are used as part of a more complete security protocol.",
      "ja": "暗号プロトコルへの入力として使用することができます共有キーにユーザーのパスワード。これらのプロトコルの展開に一つの大きな障害は、彼らの知的財産の状態が非常に不明確であるということでした。同様に、ユーザは、公開鍵証明書（例えば、S-HTTPクライアント認証）を使用して認証することができます。典型的には、これらの方法は、より完全なセキュリティプロトコルの一部として使用されます。"
    },
    {
      "indent": 0,
      "text": "4.1.7. Host Authentication",
      "section_title": true,
      "ja": "4.1.7。ホスト認証"
    },
    {
      "indent": 3,
      "text": "Host authentication presents a special problem. Quite commonly, the addresses of services are presented using a DNS hostname, for instance as a URL [URL]. When requesting such a service, one has to ensure that the entity that one is talking to not only has a certificate but that that certificate corresponds to the expected identity of the server. The important thing to have is a secure binding between the certificate and the expected hostname.",
      "ja": "ホスト認証は、特別な問題を提示しています。かなり一般的に、サービスのアドレスは、URL [URL]として、たとえば、DNSホスト名を使用して提示されています。このようなサービスを要求する場合、1は1つが話しているエンティティが証明書を持っていないだけでなく、その証明書がサーバの予想身元に対応することを保証しなければなりません。持っている重要なことは、証明書と予想されるホスト名の間の安全な結合です。"
    },
    {
      "indent": 3,
      "text": "For instance, it is usually not acceptable for the certificate to contain an identity in the form of an IP address if the request was for a given hostname. This does not provide end-to-end security because the hostname-IP mapping is not secure unless secure name resolution [DNSSEC] is being used. This is a particular problem when the hostname is presented at the application layer but the authentication is performed at some lower layer.",
      "ja": "要求が与えられたホスト名のためだった場合、証明書は、IPアドレスの形式でIDを格納するために例えば、それは通常は許容できません。安全な名前解決[DNSSEC]が使用されていない限り、ホスト名、IPマッピングが確保されていないので、これは、エンドツーエンドのセキュリティを提供しません。ホスト名がアプリケーション層で提示されているが、認証は、いくつかの下位層で実行されるとき、これは特に問題です。"
    },
    {
      "indent": 0,
      "text": "4.2. Generic Security Frameworks",
      "section_title": true,
      "ja": "4.2。一般的なセキュリティフレームワーク"
    },
    {
      "indent": 3,
      "text": "Providing security functionality in a protocol can be difficult. In addition to the problem of choosing authentication and key establishment mechanisms, one needs to integrate it into a protocol. One response to this problem (embodied in IPsec and TLS) is to create a lower-level security protocol and then insist that new protocols be run over that protocol. Another approach that has recently become popular is to design generic application layer security frameworks. The idea is that you design a protocol that allows you to negotiate various security mechanisms in a pluggable fashion. Application protocol designers then arrange to carry the security protocol PDUs in their application protocol. Examples of such frameworks include GSS-API [GSS] and SASL [SASL].",
      "ja": "プロトコルのセキュリティ機能を提供することは困難な場合があります。認証と鍵確立メカニズムを選択する問題に加えて、1は、プロトコルに統合する必要があります。 （IPsecとTLSに具現）この問題に対する一つの回答は、低レベルのセキュリティプロトコルを作成することですし、新しいプロトコルがそのプロトコル上で実行することを主張します。最近人気となっている別のアプローチは、一般的なアプリケーション層のセキュリティフレームワークを設計することです。アイデアは、あなたがプラグイン可能な形式で様々なセキュリティメカニズムを交渉することを可能にするプロトコルを設計することです。アプリケーションプロトコルの設計者は、彼らのアプリケーションプロトコルのセキュリティプロトコルのPDUを運ぶためにアレンジ。そのようなフレームワークの例には、GSS-API [GSS]とSASL [SASL]を含みます。"
    },
    {
      "indent": 3,
      "text": "The generic framework approach has a number of problems. First, it is highly susceptible to DOWNGRADE ATTACKS. In a downgrade attack, an active attacker tampers with the negotiation in order to force the parties to negotiate weaker protection than they otherwise would. It's possible to include an integrity check after the negotiation and key establishment have both completed, but the strength of this integrity check is necessarily limited to the weakest common algorithm. This problem exists with any negotiation approach, but generic frameworks exacerbate it by encouraging the application protocol author to just specify the framework rather than think hard about the appropriate underlying mechanisms, particularly since the mechanisms can very widely in the degree of security offered.",
      "ja": "一般的なフレームワークのアプローチは、多くの問題があります。まず、攻撃をダウングレードする非常に敏感です。ダウングレード攻撃では、活発な攻撃者は、彼らが他の場合よりも弱い保護を交渉するために、当事者を強制するために交渉を改ざん。それは交渉と鍵確立の両方が完了した後に整合性チェックを含めることは可能ですが、この整合性チェックの強さは、必ずしも最も弱い、共通のアルゴリズムに限定されています。この問題は、任意の交渉アプローチで存在するが、一般的なフレームワークは、特にメカニズムは非常に広くすることができます提供されるセキュリティの程度であるため、単にフレームワークを指定するのではなく、適切な基礎となるメカニズムについてハード考えるようにアプリケーションプロトコルの作者を奨励することにより、それを悪化させます。"
    },
    {
      "indent": 3,
      "text": "Another problem is that it's not always obvious how the various security features in the framework interact with the application layer protocol. For instance, SASL can be used merely as an authentication framework -- in which case the SASL exchange occurs but the rest of the connection is unprotected, but can also negotiate traffic protection, such as via GSS, as a mechanism. Knowing under what circumstances traffic protection is optional and which it is required requires thinking about the threat model.",
      "ja": "もう一つの問題は、枠組みの中で、さまざまなセキュリティ機能は、アプリケーション層プロトコルと対話する方法、それは必ずしも明確ではないということです。例えば、SASLは、認証フレームワークとしてのみ使用することができる -  SASL交換が発生するが、接続の残りの部分は保護されていないですが、また機構として、そのようなGSS介しとして、トラフィック保護をネゴシエートすることができ、その場合。どのような状況のトラフィックの保護下に知ることはオプションであり、それが必要とされる脅威モデルを考える必要です。"
    },
    {
      "indent": 3,
      "text": "In general, authentication frameworks are most useful in situations where new protocols are being added to systems with pre-existing legacy authentication systems. A framework allows new installations to provide better authentication while not forcing existing sites completely redo their legacy authentication systems. When the security requirements of a system can be clearly identified and only a few forms of authentication are used, choosing a single security mechanism leads to greater simplicity and predictability. In situations where a framework is to be used, designers SHOULD carefully examine the framework's options and specify only the mechanisms that are appropriate for their particular threat model. If a framework is necessary, designers SHOULD choose one of the established ones instead of designing their own.",
      "ja": "一般的には、認証フレームワークは、新しいプロトコルが既存のレガシー認証システムをシステムに追加されている状況で最も有用です。フレームワークは完全に彼らの従来の認証システムをやり直し、既存のサイトを強制されていないが、新規インストールでは、より良い認証を提供することができます。システムのセキュリティ要件が明確に識別することができ、認証の唯一の少数のフォームは、単一のセキュリティメカニズムを選択し、使用している場合は大きいシンプルさと予測可能性につながります。フレームワークが使用される状況では、設計者は慎重にフレームワークのオプションを検討し、その特定の脅威モデルのための適切なメカニズムのみを指定する必要があります。フレームワークが必要な場合、設計者は、代わりに自分自身を設計の確立のもののいずれかを選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Non-repudiation",
      "section_title": true,
      "ja": "4.3。否認防止"
    },
    {
      "indent": 3,
      "text": "The naive approach to non-repudiation is simply to use public-key digital signatures over the content. The party who wishes to be bound (the SIGNING PARTY) digitally signs the message in question. The counterparty (the RELYING PARTY) can later point to the digital signature as proof that the signing party at one point agreed to the disputed message. Unfortunately, this approach is insufficient.",
      "ja": "否認防止の単純なアプローチは、単にコンテンツ上に公開鍵デジタル署名を使用することです。拘束されることに希望党（署名者）は、デジタルで問題のメッセージに署名します。相手方（依拠当事者）は、後に一点で署名者が係争メッセージに同意したことの証明としてデジタル署名を指すことができます。残念ながら、このアプローチは不十分です。"
    },
    {
      "indent": 3,
      "text": "The easiest way for the signing party to repudiate the message is by claiming that his private key has been compromised and that some attacker (though not necessarily the relying party) signed the disputed message. In order to defend against this attack the relying party needs to demonstrate that the signing party's key had not been compromised at the time of the signature. This requires substantial infrastructure, including archival storage of certificate revocation information and timestamp servers to establish the time that the message was signed.",
      "ja": "メッセージを否認する署名者のための最も簡単な方法は、自分の秘密鍵が侵害されたと主張することによって、一部の攻撃者が（必ずしも依存者が）係争メッセージに署名したということです。この攻撃を防御するために証明書利用者は、署名者の鍵が署名の時点で損なわれていなかったことを立証する必要があります。これは、メッセージが署名されたことを時間を確立するための証明書の失効情報とタイムスタンプサーバのアーカイブストレージを含め、かなりのインフラストラクチャが必要です。"
    },
    {
      "indent": 3,
      "text": "Additionally, the relying party might attempt to trick the signing party into signing one message while thinking he's signing another. This problem is particularly severe when the relying party controls the infrastructure that the signing party uses for signing, such as in kiosk situations. In many such situations the signing party's key is kept on a smartcard but the message to be signed is displayed by the relying party.",
      "ja": "また、証明書利用者は、彼が別の署名の思考しながら、一つのメッセージに署名に署名者をだまししようとする場合があります。依拠当事者が署名者は、このようなキオスクの状況のように、署名に使用するインフラを制御すると、この問題は特に深刻です。多くのこのような状況では署名者のキーは、スマートカード上に保存されますが、署名されるメッセージは、証明書利用者により表示されます。"
    },
    {
      "indent": 3,
      "text": "All of these complications make non-repudiation a difficult service to deploy in practice.",
      "ja": "これらの合併症のすべてが実際に展開する非拒否困難なサービスを作ります。"
    },
    {
      "indent": 0,
      "text": "4.4. Authorization vs. Authentication",
      "section_title": true,
      "ja": "4.4。認証対承認"
    },
    {
      "indent": 3,
      "text": "AUTHORIZATION is the process by which one determines whether an authenticated party has permission to access a particular resource or service. Although tightly bound, it is important to realize that authentication and authorization are two separate mechanisms. Perhaps because of this tight coupling, authentication is sometimes mistakenly thought to imply authorization. Authentication simply identifies a party, authorization defines whether they can perform a certain action.",
      "ja": "AUTHORIZATIONは1つが認証された当事者が特定のリソースやサービスにアクセスする権限を持っているかどうかを決定するプロセスです。強固に結合したが、認証と認可を2つの別々のメカニズムであることを認識することが重要です。おそらく、この密結合の、認証は時々誤って許可を意味すると考えられています。認証は、単純承認は、彼らが特定のアクションを実行できるかどうかを定義し、パーティを識別します。"
    },
    {
      "indent": 3,
      "text": "Authorization necessarily relies on authentication, but authentication alone does not imply authorization. Rather, before granting permission to perform an action, the authorization mechanism must be consulted to determine whether that action is permitted.",
      "ja": "認可は、必ずしも認証に依存している、それだけで認証が承認を意味するものではありません。むしろ、アクションを実行する権限を付与する前に、認証機構は、そのアクションが許可されているかどうかを判断するために相談する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Access Control Lists",
      "section_title": true,
      "ja": "4.4.1。アクセス制御リスト"
    },
    {
      "indent": 3,
      "text": "One common form of authorization mechanism is an access control list (ACL), which lists users that are permitted access to a resource. Since assigning individual authorization permissions to each resource is tedious, resources are often hierarchically arranged so that the parent resource's ACL is inherited by child resources. This allows administrators to set top level policies and override them when necessary.",
      "ja": "認可メカニズムの一つの一般的な形式は、リソースへのアクセスを許可されたユーザーをリストアクセス制御リスト（ACL）、です。各リソースに個別の許可権限を割り当てることは面倒なので、親リソースのACLは、子リソースによって継承されるように、リソースは、多くの場合、階層的に配置されています。これにより、管理者は、トップレベルのポリシーを設定し、必要なときにそれらを上書きすることができます。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Certificate Based Systems",
      "section_title": true,
      "ja": "4.4.2。証明書ベースのシステム"
    },
    {
      "indent": 3,
      "text": "While the distinction between authentication and authorization is intuitive when using simple authentication mechanisms such as username and password (i.e., everyone understands the difference between the administrator account and a user account), with more complex authentication mechanisms the distinction is sometimes lost.",
      "ja": "ユーザー名やパスワードなどの単純な認証メカニズムを使用している場合、認証と認可の区別は（つまり、誰もが管理者アカウントとユーザーアカウントの違いを理解して）直感的ですが、より複雑な認証メカニズムと区別が時々失われます。"
    },
    {
      "indent": 3,
      "text": "With certificates, for instance, presenting a valid signature does not imply authorization. The signature must be backed by a certificate chain that contains a trusted root, and that root must be trusted in the given context. For instance, users who possess certificates issued by the Acme MIS CA may have different web access privileges than users who possess certificates issued by the Acme Accounting CA, even though both of these CAs are \"trusted\" by the Acme web server.",
      "ja": "証明書で、例えば、有効な署名を提示することは許可を意味するものではありません。署名は、信頼されたルートを含む証明書チェーンに支えなければならず、そのルートは、指定されたコンテキストで信頼されなければなりません。例えば、アクメMIS CAによって発行された証明書を保有するユーザーは、これらのCAの両方がアクメのWebサーバーによって「信頼できる」であっても、アクメ会計CAによって発行された証明書を持って、ユーザーは別のWebアクセス権限を持っていることがあります。"
    },
    {
      "indent": 3,
      "text": "Mechanisms for enforcing these more complicated properties have not yet been completely explored. One approach is simply to attach policies to ACLs describing what sorts of certificates are trusted. Another approach is to carry that information with the certificate, either as a certificate extension/attribute [PKIX, SPKI] or as a separate \"Attribute Certificate\".",
      "ja": "これらのより複雑な性質を強化するためのメカニズムはまだ完全に探求されていません。一つのアプローチは、信頼された証明書のどのような種類の記述のACLにポリシーを添付するだけです。別のアプローチは、証明書拡張/属性[PKIX、SPKI]として、または別の「属性証明書」のいずれかとして、証明書を使用して、その情報を運ぶことです。"
    },
    {
      "indent": 0,
      "text": "4.5. Providing Traffic Security",
      "section_title": true,
      "ja": "4.5。トラフィックのセキュリティを提供"
    },
    {
      "indent": 3,
      "text": "Securely designed protocols should provide some mechanism for securing (meaning integrity protecting, authenticating, and possibly encrypting) all sensitive traffic. One approach is to secure the protocol itself, as in [DNSSEC], [S/MIME] or [S-HTTP]. Although this provides security which is most fitted to the protocol, it also requires considerable effort to get right.",
      "ja": "安全に設計されたプロトコルは、（完全性、保護、認証、および暗号化可能性を意味する）すべての機密トラフィックを保護するためのいくつかのメカニズムを提供する必要があります。一つのアプローチは、[S / MIME]または[S-HTTP]、[DNSSEC]のように、プロトコル自体を確保するためです。これはプロトコルに最もフィットでセキュリティを提供しますが、それはまた、権利を取得するにはかなりの努力が必要です。"
    },
    {
      "indent": 3,
      "text": "Many protocols can be adequately secured using one of the available channel security systems. We'll discuss the two most common, IPsec [AH, ESP] and [TLS].",
      "ja": "多くのプロトコルは、適切に利用可能なチャネルセキュリティシステムのいずれかを使用して固定することができます。我々は2つの最も一般的な、IPsecの[AH、ESP]および[TLS]を説明します。"
    },
    {
      "indent": 0,
      "text": "4.5.1. IPsec",
      "section_title": true,
      "ja": "4.5.1。 IPsecの"
    },
    {
      "indent": 3,
      "text": "The IPsec protocols (specifically, AH and ESP) can provide transmission security for all traffic between two hosts. The IPsec protocols support varying granularities of user identification, including for example \"IP Subnet\", \"IP Address\", \"Fully Qualified Domain Name\", and individual user (\"Mailbox name\"). These varying levels of identification are employed as inputs to access control facilities that are an intrinsic part of IPsec. However, a given IPsec implementation might not support all identity types. In particular, security gateways may not provide user-to-user authentication or have mechanisms to provide that authentication information to applications.",
      "ja": "IPsecプロトコル（具体的には、AHとESP）は、2つのホスト間のすべてのトラフィックの送信のセキュリティを提供することができます。 IPsecプロトコルは、例えば、「IPサブネット」、「IPアドレス」、「完全修飾ドメイン名」、および個々のユーザ（「メールボックス名」）を含むユーザ識別種々の粒度を、サポート。識別のこれらのさまざまなレベルは、IPsecの本質的な部分である制御機能にアクセスするための入力として使用されます。しかし、与えられたIPsec実装は、すべてのIDの種類をサポートしていない可能性があります。具体的には、セキュリティゲートウェイはユーザ対ユーザ認証を提供するか、またはアプリケーションへの認証情報を提供するための機構を有していなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "When AH or ESP is used, the application programmer might not need to do anything (if AH or ESP has been enabled system-wide) or might need to make specific software changes (e.g., adding specific setsockopt() calls) -- depending on the AH or ESP implementation being used. Unfortunately, APIs for controlling IPsec implementations are not yet standardized.",
      "ja": "応じて -  AHまたはESPを使用する場合（AHまたはESPは、システム全体で有効になっている場合）、または特定のソフトウェアの変更（例えば、特定のsetsockoptを追加する（）の呼び出し）を作成する必要があるかもしれません、アプリケーションプログラマは何もする必要はないかもしれませんAHまたはESP実装が使用されています。残念ながら、IPsec実装を制御するためのAPIはまだ標準化されていません。"
    },
    {
      "indent": 3,
      "text": "The primary obstacle to using IPsec to secure other protocols is deployment. The major use of IPsec at present is for VPN applications, especially for remote network access. Without extremely tight coordination between security administrators and application developers, VPN usage is not well suited to providing security services for individual applications since it is difficult for such applications to determine what security services have in fact been provided.",
      "ja": "他のプロトコルを確保するためにIPsecを使用する主な障害は、展開です。現時点でのIPsecの主な用途は、特にリモートネットワークアクセスのために、VPNアプリケーション用です。セキュリティ管理者やアプリケーション開発者の間で非常にタイトな連携がなければ、VPNの使用量は、セキュリティサービスが実際に提供されているかどうかを判断するために、このような用途のために困難であるため、個々のアプリケーションのためのセキュリティサービスを提供するには適していません。"
    },
    {
      "indent": 3,
      "text": "IPsec deployment in host-to-host environments has been slow. Unlike application security systems such as TLS, adding IPsec to a non-IPsec system generally involves changing the operating system, either by modifying with the kernel or installing new drivers. This is a substantially greater undertaking than simply installing a new application. However, recent versions of a number of commodity operating systems include IPsec stacks, so deployment is becoming easier.",
      "ja": "ホスト間の環境でのIPsecの展開が遅れています。 TLSなどのアプリケーション・セキュリティ・システムとは異なり、非IPsecのシステムにIPsecを追加することは、一般的にカーネルで変更または新しいドライバをインストールすることによってのいずれかで、オペレーティングシステムを変更することを含みます。これは、単純に新しいアプリケーションをインストールするよりも実質的に大きい仕事です。しかし、コモディティオペレーティングシステムの数の最近のバージョンは、IPsecスタックを含め、その展開が容易になってきています。"
    },
    {
      "indent": 3,
      "text": "In environments where IPsec is sure to be available, it represents a viable option for protecting application communications traffic. If the traffic to be protected is UDP, IPsec and application-specific object security are the only options. However, designers MUST NOT assume that IPsec will be available. A security policy for a generic application layer protocol SHOULD NOT simply state that IPsec must be used, unless there is some reason to believe that IPsec will be available in the intended deployment environment. In environments where IPsec may not be available and the traffic is solely TCP, TLS is the method of choice, since the application developer can easily ensure its presence by including a TLS implementation in his package.",
      "ja": "IPsecが利用可能になるはずである環境では、アプリケーションの通信トラフィックを保護するための実行可能な選択肢を表します。保護されるべきトラフィックはUDPである場合は、IPsecとアプリケーション固有のオブジェクトセキュリティは唯一のオプションです。しかし、設計者は、IPsecが利用可能になると仮定してはいけません。 IPsecが意図したデプロイメント環境で利用できるようになりますことを信じるためにいくつかの理由がない限り、一般的なアプリケーション層プロトコルのためのセキュリティポリシーは、単純に、IPsecを使用しなければならないことを述べるべきではありません。アプリケーション開発者は簡単に彼のパッケージでTLSの実装を含むことにより、その存在を確保することができますので、IPsecが使用できない場合があり、トラフィックが単にTCPである環境では、TLSは、選択の方法です。"
    },
    {
      "indent": 3,
      "text": "In the special-case of IPv6, both AH and ESP are mandatory to implement. Hence, it is reasonable to assume that AH/ESP are already available for IPv6-only protocols or IPv6-only deployments. However, automatic key management (IKE) is not required to implement so protocol designers SHOULD not assume it will be present. [USEIPSEC] provides quite a bit of guidance on when IPsec is a good choice.",
      "ja": "IPv6の特殊なケースでは、AHとESPの両方を実装するために必須です。したがって、AH / ESPは、すでにIPv6のみのプロトコルまたはIPv6のみの展開で使用可能であると仮定するのが合理的です。しかし、自動鍵管理（IKE）を実装するために必要とされないので、プロトコル設計者は、それが存在すると仮定してはなりません。 [USEIPSEC] IPsecは良い選択であるときに指針のかなりを提供します。"
    },
    {
      "indent": 0,
      "text": "4.5.2. SSL/TLS",
      "section_title": true,
      "ja": "4.5.2。 SSL / TLS"
    },
    {
      "indent": 3,
      "text": "Currently, the most common approach is to use SSL or its successor TLS. They provide channel security for a TCP connection at the application level. That is, they run over TCP. SSL implementations typically provide a Berkeley Sockets-like interface for easy programming. The primary issue when designing a protocol solution around TLS is to differentiate between connections protected using TLS and those which are not.",
      "ja": "現在、最も一般的なアプローチは、SSLまたはその後継TLSを使用することです。彼らは、アプリケーションレベルでのTCP接続のためのチャネルセキュリティを提供します。つまり、彼らは、TCP上で実行します。 SSLの実装は通常、簡単なプログラミングのためのバークレーソケットのようなインターフェイスを提供します。 TLSプロトコルの周りのソリューションを設計する主な問題は、TLSを使用して保護された接続とそうでないものを区別することです。"
    },
    {
      "indent": 3,
      "text": "The two primary approaches used have a separate well-known port for TLS connections (e.g., the HTTP over TLS port is 443) [HTTPTLS] or to have a mechanism for negotiating upward from the base protocol to TLS as in [UPGRADE] or [STARTTLS]. When an upward negotiation strategy is used, care must be taken to ensure that an attacker can not force a clear connection when both parties wish to use TLS.",
      "ja": "使用される二つの主要なアプローチは、TLS接続の別の周知のポートを有している（例えば、TLSポート上のHTTPは443である）[HTTPTLS]または同様TLSに基本プロトコルから上方に交渉するための機構を有すること[バージョンアップ]または[ STARTTLS]。上向きの交渉戦略を使用する場合は、注意が双方の当事者がTLSを使用したいとき、攻撃者が明確な接続を強制することはできませんように注意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that TLS depends upon a reliable protocol such as TCP or SCTP. This produces two notable difficulties. First, it cannot be used to secure datagram protocols that use UDP. Second, TLS is susceptible to IP layer attacks that IPsec is not. Typically, these attacks take some form of denial of service or connection assassination. For instance, an attacker might forge a TCP RST to shut down SSL connections. TLS has mechanisms to detect truncation attacks but these merely allow the victim to know he is being attacked and do not provide connection survivability in the face of such attacks. By contrast, if IPsec were being used, such a forged RST could be rejected without affecting the TCP connection. If forged RSTs or other such attacks on the TCP connection are a concern, then AH/ESP or the TCP MD5 option [TCPMD5] are the preferred choices.",
      "ja": "TLSは、TCPやSCTPなど信頼性の高いプロトコルに依存することに注意してください。これは、二つの顕著な困難を生じさせます。まず、UDPを使用するデータグラム・プロトコルを保護するために使用することはできません。第二に、TLSは、IPsecではないことをIP層の攻撃を受けやすいです。一般的に、これらの攻撃は、サービスまたは接続暗殺の拒否のいくつかの形をとります。例えば、攻撃者がSSL接続をシャットダウンするTCP RSTを偽造することがあります。 TLSは切り捨て攻撃を検出するためのメカニズムを持っているが、これらは単に犠牲者は、彼が攻撃されていると、このような攻撃に直面して接続サバイバビリティを提供していない知ることができます。 IPsecが使用されていた場合はこれとは対照的に、このような鍛造RSTは、TCPコネクションに影響を与えることなく、拒否することができます。偽造のRSTまたはTCP接続上の他のこのような攻撃が懸念される場合には、AH / ESPまたはTCP MD5オプションは、[TCPMD5】好ましい選択肢です。"
    },
    {
      "indent": 0,
      "text": "4.5.2.1. Virtual Hosts",
      "section_title": true,
      "ja": "4.5.2.1。仮想ホスト"
    },
    {
      "indent": 3,
      "text": "If the \"separate ports\" approach to TLS is used, then TLS will be negotiated before any application-layer traffic is sent. This can cause a problem with protocols that use virtual hosts, such as [HTTP], since the server does not know which certificate to offer the client during the TLS handshake. The TLS hostname extension [TLSEXT] can be used to solve this problem, although it is too new to have seen wide deployment.",
      "ja": "TLSに「別個のポート」アプローチが使用される場合、任意のアプリケーション層のトラフィックが送信される前に、その後、TLSがネゴシエートされます。サーバがTLSハンドシェイク中にクライアントを提供する証明書を知らないので、これは、そのような[HTTP]などの仮想ホストを使用するプロトコルに問題を引き起こす可能性があります。広い展開を見ているにはあまりにも新しいですが、TLSのホスト名の拡張子は、[TLSEXT]、この問題を解決するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.5.2.2. Remote Authentication and TLS",
      "section_title": true,
      "ja": "4.5.2.2。リモート認証とTLS"
    },
    {
      "indent": 3,
      "text": "One difficulty with using TLS is that the server is authenticated via a certificate. This can be inconvenient in environments where previously the only form of authentication was a password shared between client and server. It's tempting to use TLS without an authenticated server (i.e., with anonymous DH or a self-signed RSA certificate) and then authenticate via some challenge-response mechanism such as SASL with CRAM-MD5.",
      "ja": "TLSを使用して1つの困難な点は、サーバーが証明書を介して認証されていることです。これは、以前の認証の唯一の形式は、クライアントとサーバの間で共有パスワードた環境では不便なことができます。それは（すなわち、匿名DHまたは自己署名RSA証明書を使用して）認証サーバーなしでTLSを使用し、その後、CRAM-MD5とSASLなどのいくつかのチャレンジ - レスポンス機構を介して認証するために魅力的です。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, this composition of SASL and TLS is less strong than one would expect. It's easy for an active attacker to hijack this connection. The client man-in-the-middles the SSL connection (remember we're not authenticating the server, which is what ordinarily prevents this attack) and then simply proxies the SASL handshake. From then on, it's as if the connection were in the clear, at least as far as that attacker is concerned. In order to prevent this attack, the client needs to verify the server's certificate.",
      "ja": "残念ながら、SASLとTLSのこの組成物は、1つが期待するほど強力です。アクティブな攻撃者がこの接続をハイジャックするのは簡単です。クライアントのman-in-中学SSL接続して、簡単にSASLハンドシェイクをプロキシ（私たちは通常、この攻撃を防ぐ何である、サーバーを認証していない覚えておいてください）。接続は、少なくとも限り、その攻撃者は懸念しているとして、明らかにしたかのようにその時から、それはです。この攻撃を防ぐために、クライアントはサーバーの証明書を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, if the server is authenticated, challenge-response becomes less desirable. If you already have a hardened channel then simple passwords are fine. In fact, they're arguably superior to challenge-response since they do not require that the password be stored in the clear on the server. Thus, compromise of the key file with challenge-response systems is more serious than if simple passwords were used.",
      "ja": "サーバーが認証された場合には、チャレンジ・レスポンスはあまり望ましくなります。すでに硬化チャンネルをお持ちの場合は、単純なパスワードは大丈夫です。実際に、彼らはパスワードがサーバー上に平文で保存されることを必要としないため、応答に挑戦して、間違いなく優れています。このように、チャレンジレスポンスシステムとキーファイルの妥協は、単純なパスワードを使用した場合よりも深刻です。"
    },
    {
      "indent": 3,
      "text": "Note that if the client has a certificate than SSL-based client authentication can be used. To make this easier, SASL provides the EXTERNAL mechanism, whereby the SASL client can tell the server \"examine the outer channel for my identity\". Obviously, this is not subject to the layering attacks described above.",
      "ja": "クライアントは、SSLベースのクライアント認証よりも証明書を持っている場合に使用できることに注意してください。これを簡単にするために、SASLは、SASLクライアントがサーバに伝える「私のアイデンティティのための外部チャネルを調べる」ことができる、EXTERNALメカニズムを提供します。明らかに、これは前述した積層攻撃の対象ではありません。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Remote Login",
      "section_title": true,
      "ja": "4.5.3。リモートログイン"
    },
    {
      "indent": 3,
      "text": "In some special cases it may be worth providing channel-level security directly in the application rather than using IPSEC or SSL/TLS. One such case is remote terminal security. Characters are typically delivered from client to server one character at a time. Since SSL/TLS and AH/ESP authenticate and encrypt every packet, this can mean a data expansion of 20-fold. The telnet encryption option [ENCOPT] prevents this expansion by foregoing message integrity.",
      "ja": "いくつかの特殊なケースでは、アプリケーションで直接チャンネルレベルのセキュリティを提供するのではなくIPSECまたはSSL / TLSを使用して価値があるかもしれません。そのような場合は、リモート端末のセキュリティです。文字は、典型的には、一度にサーバー1つの文字にクライアントから配信されています。 SSL / TLSとAH / ESPので、すべてのパケットを認証および暗号化し、これは20倍のデータ拡張を意味することができます。 telnet暗号化オプションは、[ENCOPT]メッセージの整合性を前述のことで、この拡大を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "When using remote terminal service, it's often desirable to securely perform other sorts of communications services. In addition to providing remote login, SSH [SSH] also provides secure port forwarding for arbitrary TCP ports, thus allowing users run arbitrary TCP-based applications over the SSH channel. Note that SSH Port Forwarding can be security issue if it is used improperly to circumvent firewall and improperly expose insecure internal applications to the outside world.",
      "ja": "リモート端末サービスを使用する場合は、安全に通信サービスの他の種類を実行することが望ましいことが多いのです。リモートログインを提供することに加えて、SSHは、[SSH]また、このようにして、ユーザーがSSHチャネルを介して任意のTCPベースのアプリケーションを実行可能にする、任意のTCPポートのセキュアなポート転送を提供します。ファイアウォールを回避し、不適切に外の世界に安全ではない内部アプリケーションを公開するために不適切に使用されている場合、SSHポートフォワーディングは、セキュリティ上の問題になる可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.6. Denial of Service Attacks and Countermeasures",
      "section_title": true,
      "ja": "4.6。サービス拒否攻撃とその対策の拒否"
    },
    {
      "indent": 3,
      "text": "Denial of service attacks are all too frequently viewed as an fact of life. One problem is that an attacker can often choose from one of many denial of service attacks to inflict upon a victim, and because most of these attacks cannot be thwarted, common wisdom frequently assumes that there is no point protecting against one kind of denial of service attack when there are many other denial of service attacks that are possible but that cannot be prevented.",
      "ja": "サービス妨害攻撃は、あまりにも頻繁に生活の事実と見ています。一つの問題は、攻撃者が、多くの場合、被害者時に負わせるサービス攻撃の多くの拒否のいずれかから選択することができ、そしてこれらの攻撃のほとんどは阻止することができないので、一般的な知恵が頻繁にサービス拒否の一種に対する保護はポイントが存在しないことを前提としていることです可能であるが、それは防止できないサービス攻撃の他の多くの否定がある攻撃。"
    },
    {
      "indent": 3,
      "text": "However, not all denial of service attacks are equal and more importantly, it is possible to design protocols so that denial of service attacks are made more difficult, if not impractical. Recent SYN flood attacks [TCPSYN] demonstrate both of these properties: SYN flood attacks are so easy, anonymous, and effective that they are more attractive to attackers than other attacks; and because the design of TCP enables this attack.",
      "ja": "しかし、サービス攻撃のすべてではない否定は等しく、もっと重要なのは、非現実的でない場合は、サービス拒否攻撃は、より困難になるされているようにプロトコルを設計することが可能です。最近のSYNフラッド攻撃は、[TCPSYN]これらの特性の両方を示します。SYNフラッド攻撃は、彼らが他の攻撃よりも攻撃者にとってより魅力的であるように、簡単に匿名で、かつ効果的です。そして、TCPのデザインは、この攻撃が可能になるため。"
    },
    {
      "indent": 3,
      "text": "Because complete DoS protection is so difficult, security against DoS must be dealt with pragmatically. In particular, some attacks which would be desirable to defend against cannot be defended against economically. The goal should be to manage risk by defending against attacks with sufficiently high ratios of severity to cost of defense. Both severity of attack and cost of defense change as technology changes and therefore so does the set of attacks which should be defended against.",
      "ja": "完全なDoS保護は非常に困難であるため、DoS攻撃に対するセキュリティを実践的に対処する必要があります。具体的には、身を守ることが望ましいであろういくつかの攻撃は、経済的に反対擁護することはできません。目標は、防衛のコストへの重症度の十分に高い比率の攻撃に対して防御によってリスクを管理する必要があります。したがって、攻撃や技術の変化として防衛変更コストとの両方の重症度はそれほどに対して擁護しなければならない攻撃のセットを行います。"
    },
    {
      "indent": 3,
      "text": "Authors of internet standards MUST describe which denial of service attacks their protocol is susceptible to. This description MUST include the reasons it was either unreasonable or out of scope to attempt to avoid these denial of service attacks.",
      "ja": "インターネット標準の著者は、サービス拒否がそのプロトコルが影響を受けやすい攻撃する説明しなければなりません。この説明は、サービス攻撃のこれらの拒否を回避するために試みることが不合理または範囲外のいずれかであった理由が含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Blind Denial of Service",
      "section_title": true,
      "ja": "4.6.1。サービスのブラインド拒否"
    },
    {
      "indent": 3,
      "text": "BLIND denial of service attacks are particularly pernicious. With a blind attack the attacker has a significant advantage. If the attacker must be able to receive traffic from the victim, then he must either subvert the routing fabric or use his own IP address. Either provides an opportunity for the victim to track the attacker and/or filter out his traffic. With a blind attack the attacker can use forged IP addresses, making it extremely difficult for the victim to filter out his packets. The TCP SYN flood attack is an example of a blind attack. Designers should make every attempt possible to prevent blind denial of service attacks.",
      "ja": "サービス攻撃のBLIND拒否は特に有害です。盲目の攻撃で、攻撃者は大きな利点があります。攻撃者は、被害者からのトラフィックを受け取ることができなければならない場合は、その後、彼は、ルーティング・ファブリックを覆すか、自分自身のIPアドレスを使用する必要があります。どちらの被害者が攻撃を追跡および/または彼のトラフィックをフィルタリングする機会を提供します。盲目の攻撃で、攻撃者は、それが非常に困難被害者が自分のパケットをフィルタリングできるようにすること、偽造IPアドレスを使用することができます。 TCP SYNフラッド攻撃はブラインド攻撃の一例です。設計者は、サービス攻撃のブラインド拒否を防ぐために可能なあらゆる試みを行う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Distributed Denial of Service",
      "section_title": true,
      "ja": "4.6.2。分散型サービス拒否"
    },
    {
      "indent": 3,
      "text": "Even more dangerous are DISTRIBUTED denial of service attacks (DDoS) [DDOS]. In a DDoS the attacker arranges for a number of machines to attack the target machine simultaneously. Usually this is accomplished by infecting a large number of machines with a program that allows remote initiation of attacks. The machines actually performing the attack are called ZOMBIEs and are likely owned by unsuspecting third parties in an entirely different location from the true attacker. DDoS attacks can be very hard to counter because the zombies often appear to be making legitimate protocol requests and simply crowd out the real users. DDoS attacks can be difficult to thwart, but protocol designers are expected to be cognizant of these forms of attack while designing protocols.",
      "ja": "さらに危険がサービス拒否攻撃（DDoS攻撃）の拒否[DDOS]配布されます。 DDoS攻撃では、攻撃者は、同時にターゲットマシンを攻撃するマシンの数を手配します。通常、これは攻撃のリモート起動を可能にするプログラムで多数のマシンに感染することによって達成されます。実際に攻撃を実行するマシンはゾンビと呼ばれ、おそらく本当の攻撃とは全く別の場所に疑うことを知らない第三者が所有しています。ゾンビは、多くの場合、正当なプロトコル要求を行っているように見えるし、単に実際のユーザーを締め出すため、DDoS攻撃は、対抗するのは非常に難しいことができます。 DDoS攻撃は阻止するのが難しいことができますが、プロトコル設計者は、プロトコルを設計しながら、攻撃のこれらの形を認識することが期待されています。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Avoiding Denial of Service",
      "section_title": true,
      "ja": "4.6.3。サービス拒否の回避"
    },
    {
      "indent": 3,
      "text": "There are two common approaches to making denial of service attacks more difficult:",
      "ja": "サービス拒否攻撃をより困難に2つの一般的なアプローチがあります。"
    },
    {
      "indent": 0,
      "text": "4.6.3.1. Make your attacker do more work than you do",
      "section_title": true,
      "ja": "4.6.3.1。あなたの攻撃者は、あなたがより多くの作業を行うください"
    },
    {
      "indent": 3,
      "text": "If an attacker consumes more of his resources than yours when launching an attack, attackers with fewer resources than you will be unable to launch effective attacks. One common technique is to require the attacker perform a time-intensive operation, such as a cryptographic operation. Note that an attacker can still mount a denial of service attack if he can muster substantially sufficient CPU power. For instance, this technique would not stop the distributed attacks described in [TCPSYN].",
      "ja": "攻撃を開始する場合、攻撃者があなたより彼のリソースの多くを消費した場合、より少ないリソースで、攻撃者は、効果的な攻撃を開始することができません。一つの一般的な技術は、攻撃者は、このような暗号演算として時間がかかる操作を行う必要です。彼は、実質的に十分なCPUパワーを集めることができた場合、攻撃者がまだサービス拒否攻撃をマウントできることに注意してください。例えば、この技術は、[TCPSYN]に記載の分散型の攻撃を停止しないであろう。"
    },
    {
      "indent": 0,
      "text": "4.6.3.2. Make your attacker prove they can receive data from you",
      "section_title": true,
      "ja": "4.6.3.2。あなたの攻撃者は、彼らはあなたからのデータを受信できることを証明してください"
    },
    {
      "indent": 3,
      "text": "A blind attack can be subverted by forcing the attacker to prove that they can can receive data from the victim. A common technique is to require that the attacker reply using information that was gained earlier in the message exchange. If this countermeasure is used, the attacker must either use his own address (making him easy to track) or to forge an address which will be routed back along a path that traverses the host from which the attack is being launched.",
      "ja": "ブラインド攻撃は、彼らが被害者からのデータを受信できることを証明するために、攻撃者が強制的に堕落することができます。一般的な技術は、攻撃者が以前のメッセージ交換で得た情報を使用して返信することを要求することです。この対策が使用されている場合、攻撃者は、いずれか、または攻撃が起動されているからホストを横断通路に沿ってルートバックされるアドレスを偽造するために（彼は簡単に追跡すること）、自分のアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Hosts on small subnets are thus useless to the attacker (at least in the context of a spoofing attack) because the attack can be traced back to a subnet (which should be sufficient for locating the attacker) so that anti-attack measures can be put into place (for instance, a boundary router can be configured to drop all traffic from that subnet). A common technique is to require that the attacker reply using information that was gained earlier in the message exchange.",
      "ja": "攻撃が抗攻撃対策を置くことができるように、（攻撃者の位置を特定するために十分であるべきである）サブネットにさかのぼることができるので、小さなサブネット上のホストは、（スプーフィング攻撃の文脈において少なくとも）攻撃することが役に立ちません所定の場所に（例えば、境界ルータはそのサブネットからのすべてのトラフィックをドロップするように設定することができます）。一般的な技術は、攻撃者が以前のメッセージ交換で得た情報を使用して返信することを要求することです。"
    },
    {
      "indent": 0,
      "text": "4.6.4. Example: TCP SYN Floods",
      "section_title": true,
      "ja": "4.6.4。例：TCP SYNフラッド"
    },
    {
      "indent": 3,
      "text": "TCP/IP is vulnerable to SYN flood attacks (which are described in section 3.3.2) because of the design of the 3-way handshake. First, an attacker can force a victim to consume significant resources (in this case, memory) by sending a single packet. Second, because the attacker can perform this action without ever having received data from the victim, the attack can be performed anonymously (and therefore using a large number of forged source addresses).",
      "ja": "TCP / IPは、理由は3ウェイハンドシェイクの設計（セクション3.3.2で説明されている）SYNフラッド攻撃に対して脆弱です。まず、攻撃者は、単一のパケットを送信することにより（この場合、メモリには）かなりのリソースを消費するように被害者を強制することができます。攻撃者がこれまで被害者から受信したデータを有することなく、このアクションを実行することができるので、第二、攻撃は匿名で行うことができる（したがって、偽造ソースアドレスを多数使用して）。"
    },
    {
      "indent": 0,
      "text": "4.6.5. Example: Photuris",
      "section_title": true,
      "ja": "4.6.5。例：Photuris"
    },
    {
      "indent": 3,
      "text": "[PHOTURIS] specifies an anti-clogging mechanism that prevents attacks on Photuris that resemble the SYN flood attack. Photuris employs a time-variant secret to generate a \"cookie\" which is returned to the attacker. This cookie must be returned in subsequent messages for the exchange to progress. The interesting feature is that this cookie can be regenerated by the victim later in the exchange, and thus no state need be retained by the victim until after the attacker has proven that he can receive packets from the victim.",
      "ja": "[PHOTURIS]はSYNフラッド攻撃に似ているPhoturisへの攻撃を防ぐ目詰まり防止メカニズムを指定します。 Photurisは、攻撃者に返され、「クッキー」を生成する時変秘密を採用しています。このクッキーは、進歩への交換のために後続のメッセージで返さなければなりません。興味深い機能は、このクッキーは、後で引き換えに被害者によって再生することができるので、何の状態は、攻撃者が、彼は被害者からのパケットを受信できることを証明した後まで、被害者によって保持される必要がないということです。"
    },
    {
      "indent": 0,
      "text": "4.7. Object vs. Channel Security",
      "section_title": true,
      "ja": "4.7。チャネルのセキュリティ対オブジェクト"
    },
    {
      "indent": 3,
      "text": "It's useful to make the conceptual distinction between object security and channel security. Object security refers to security measures which apply to entire data objects. Channel security measures provide a secure channel over which objects may be carried transparently but the channel has no special knowledge about object boundaries.",
      "ja": "これは、オブジェクトセキュリティとチャネルセキュリティの間の概念的な区別をするために便利です。オブジェクトのセキュリティは、全体のデータオブジェクトに適用するセキュリティ対策を指します。チャネルのセキュリティ対策は、オブジェクトを透過的に行うことができる、その上安全なチャネルを提供しますが、チャネルは、オブジェクトの境界に関する特別な知識を持っていません。"
    },
    {
      "indent": 3,
      "text": "Consider the case of an email message. When it's carried over an IPSEC or TLS secured connection, the message is protected during transmission. However, it is unprotected in the receiver's mailbox, and in intermediate spool files along the way. Moreover, since mail servers generally run as a daemon, not a user, authentication of messages generally merely means authentication of the daemon not the user. Finally, since mail transport is hop-by-hop, even if the user authenticates to the first hop relay the authentication can't be safely verified by the receiver.",
      "ja": "電子メールメッセージの場合を考えてみましょう。それはIPSECかTLSセキュアな接続を介して行われます場合は、メッセージが送信中に保護されています。しかし、それは、受信者のメールボックスで保護されていない、と道に沿った中間スプールファイルです。メールサーバは、一般的にデーモンではなく、ユーザーとして実行ので、メッセージの認証は、一般的に、単にデーモンないユーザの認証を意味しています。最後に、メール転送するので、ユーザは認証を安全に受信機によって確認することができない最初のホップ中継を認証する場合であっても、ホップバイホップです。"
    },
    {
      "indent": 3,
      "text": "By contrast, when an email message is protected with S/MIME or OpenPGP, the entire message is encrypted and integrity protected until it is examined and decrypted by the recipient. It also provides strong authentication of the actual sender, as opposed to the machine the message came from. This is object security. Moreover, the receiver can prove the signed message's authenticity to a third party.",
      "ja": "これとは対照的に、電子メールメッセージは、S / MIMEまたはOpenPGPので保護されている場合、メッセージ全体が暗号化され、それが検査され、受信者によって復号化されるまで、整合性が保護されています。メッセージがどこから来たのマシンとは対照的に、それはまた、実際の送信者の強力な認証を提供します。これは、オブジェクトのセキュリティです。また、受信機は、第三者に署名されたメッセージの真正性を証明することができます。"
    },
    {
      "indent": 3,
      "text": "Note that the difference between object and channel security is a matter of perspective. Object security at one layer of the protocol stack often looks like channel security at the next layer up. So, from the perspective of the IP layer, each packet looks like an individually secured object. But from the perspective of a web client, IPSEC just provides a secure channel.",
      "ja": "対象とチャネルセキュリティの違いは視点の問題であることに注意してください。プロトコルスタックの1層でのオブジェクトのセキュリティは、多くの場合、次の層を上にチャネルセキュリティのように見えます。そのため、IPレイヤの観点から、各パケットは個別にセキュリティで保護されたオブジェクトのように見えます。しかし、Webクライアントの観点から、IPSECはちょうど安全なチャネルを提供します。"
    },
    {
      "indent": 3,
      "text": "The distinction isn't always clear-cut. For example, S-HTTP provides object level security for a single HTTP transaction, but a web page typically consists of multiple HTTP transactions (the base page and numerous inline images). Thus, from the perspective of the total web page, this looks rather more like channel security. Object security for a web page would consist of security for the transitive closure of the page and all its embedded content as a single unit.",
      "ja": "区別が常に明確ではありません。例えば、S-HTTPは、単一のHTTPトランザクションのオブジェクトレベルのセキュリティを提供するが、ウェブページは、典型的には、複数のHTTPトランザクション（基本ページと数多くのインライン画像）から成ります。したがって、総ウェブページの観点から、これはかなり多くのチャネルセキュリティのように見えます。 Webページのオブジェクトのセキュリティは、ページの推移閉包と単一ユニットとして、そのすべての埋め込まれたコンテンツのためのセキュリティで構成されます。"
    },
    {
      "indent": 0,
      "text": "4.8. Firewalls and Network Topology",
      "section_title": true,
      "ja": "4.8。ファイアウォールとネットワークトポロジ"
    },
    {
      "indent": 3,
      "text": "It's common security practice in modern networks to partition the network into external and internal networks using a firewall. The internal network is then assumed to be secure and only limited security measures are used there. The internal portion of such a network is often called a WALLED GARDEN.",
      "ja": "これは、ファイアウォールを使用して外部および内部ネットワークにネットワークを分割するために現代のネットワークに共通のセキュリティプラクティスです。内部ネットワークがセキュアであると想定されており、限られたセキュリティ対策がそこに使用されています。そのようなネットワークの内部部分は、多くの場合、壁に囲まれた庭園と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Internet protocol designers cannot safely assume that their protocols will be deployed in such an environment, for three reasons. First, protocols which were originally designed to be deployed in closed environments often are later deployed on the Internet, thus creating serious vulnerabilities.",
      "ja": "インターネットプロトコルの設計者は、安全に自分のプロトコルは三つの理由のために、このような環境に配備されると仮定することはできません。まず、もともと多くの場合、閉じられた環境で展開されるように設計されたプロトコルは、後でので、深刻な脆弱性を作成し、インターネット上に展開されています。"
    },
    {
      "indent": 3,
      "text": "Second, networks which appear to be topologically disconnected may not be. One reason may be that the network has been reconfigured to allow access by the outside world. Moreover, firewalls are increasingly passing generic application layer protocols such as [SOAP] or [HTTP]. Network protocols which are based on these generic protocols cannot in general assume that a firewall will protect them. Finally, one of the most serious security threats to systems is from insiders, not outsiders. Since insiders by definition have access to the internal network, topological protections such as firewalls will not protect them.",
      "ja": "第二に、位相幾何学的に切断されるように見えるネットワークがないかもしれません。一つの理由は、ネットワークが外の世界からのアクセスを許可するように再構成されている可能性があります。また、ファイアウォールは、ますますそのような[HTTP] [SOAP]又は汎用アプリケーション層プロトコルを渡します。これらの一般的なプロトコルに基づいており、ネットワークプロトコルは、一般的にファイアウォールがそれらを保護することを仮定することはできません。最後に、システムへの最も深刻なセキュリティ上の脅威の一つはインサイダーではない部外者からです。定義により、インサイダーは、内部ネットワークへのアクセスを持っているので、ファイアウォールなどのトポロジカル保護はそれらを保護しません。"
    },
    {
      "indent": 0,
      "text": "5. Writing Security Considerations Sections",
      "section_title": true,
      "ja": "5.書き込みセキュリティの考慮事項のセクション"
    },
    {
      "indent": 3,
      "text": "While it is not a requirement that any given protocol or system be immune to all forms of attack, it is still necessary for authors to consider as many forms as possible. Part of the purpose of the Security Considerations section is to explain what attacks are out of scope and what countermeasures can be applied to defend against them. In",
      "ja": "それが任意のプロトコルまたはシステムが攻撃のあらゆる形態への免疫であるという要件はありませんが、著者は、できるだけ多くの形態を検討するために、それはまだ必要です。セキュリティの考慮事項のセクションの目的の一部は、攻撃が範囲外であると、どのような対策がそれらを防御するために適用できるかを説明することです。に"
    },
    {
      "indent": 3,
      "text": "There should be a clear description of the kinds of threats on the described protocol or technology. This should be approached as an effort to perform \"due diligence\" in describing all known or foreseeable risks and threats to potential implementers and users.",
      "ja": "記載されているプロトコルまたは技術上の脅威の種類の明確な記述があるはずです。これは、潜在的な実装し、ユーザーにすべての既知または予見可能なリスクと脅威を記述する際に「デューデリジェンス」を実行するための努力として近づいされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Authors MUST describe",
      "ja": "著者は、説明しなければなりません。"
    },
    {
      "indent": 6,
      "text": "1. which attacks are out of scope (and why!) 2. which attacks are in-scope 2.1 and the protocol is susceptible to 2.2 and the protocol protects against",
      "ja": "攻撃は範囲外である1。（そしてなぜ！）2.攻撃で、範囲2.1であり、プロトコルが2.2の影響を受けやすいとプロトコルはから保護"
    },
    {
      "indent": 3,
      "text": "At least the following forms of attack MUST be considered: eavesdropping, replay, message insertion, deletion, modification, and man-in-the-middle. Potential denial of service attacks MUST be identified as well. If the protocol incorporates cryptographic protection mechanisms, it should be clearly indicated which portions of the data are protected and what the protections are (i.e., integrity only, confidentiality, and/or endpoint authentication, etc.). Some indication should also be given to what sorts of attacks the cryptographic protection is susceptible. Data which should be held secret (keying material, random seeds, etc.) should be clearly labeled.",
      "ja": "少なくとも、攻撃の次の形式を考えなければなりません：盗聴、リプレイ、メッセージ挿入、削除、変更、およびのman-in-the-middle。サービス拒否攻撃は、同様に識別されなければなりません。プロトコルは、暗号保護機構を組み込んでいる場合、それは明確に示されなければならないデータのどの部分が保護されており、どのような保護（すなわち、完全性のみ、機密性、及び/又はエンドポイント認証、等）です。いくつかの表示も暗号保護が受けやすい攻撃のどのような種類に与えられるべきです。 （材料等、ランダムシードを、キーイング）秘密保持すべきデータが明確に表示しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the technology involves authentication, particularly user-host authentication, the security of the authentication method MUST be clearly specified. That is, authors MUST document the assumptions that the security of this authentication method is predicated upon. For instance, in the case of the UNIX username/password login method, a statement to the effect of:",
      "ja": "技術は、認証、特にユーザーのホスト認証を必要とする場合は、認証方式のセキュリティは、明確に指定されなければなりません。それは著者がこの認証方式のセキュリティは時に予測される仮定を文書化しなければならない、です。たとえば、UNIXユーザー名/パスワードのログイン方法、の旨の場合："
    },
    {
      "indent": 6,
      "text": "Authentication in the system is secure only to the extent that it is difficult to guess or obtain a ASCII password that is a maximum of 8 characters long. These passwords can be obtained by sniffing telnet sessions or by running the 'crack' program using the contents of the /etc/passwd file. Attempts to protect against on-line password guessing by (1) disconnecting after several unsuccessful login attempts and (2) waiting between successive password prompts is effective only to the extent that attackers are impatient.",
      "ja": "システムでの認証は、長い最大8つの文字であるASCIIのパスワードを推測または得ることが困難であるという程度に安全です。これらのパスワードは、telnetセッションを盗聴するか、/ etc / passwdファイルの内容を使用して「亀裂」プログラムを実行することによって得ることができます。 （1）いくつかの失敗したログイン試行後に切断することで推測し、（2）の連続したパスワードの間待っているオンラインのパスワードを保護するための試みは、攻撃者はせっかちている程度に効果的である要求されます。"
    },
    {
      "indent": 6,
      "text": "Because the /etc/passwd file maps usernames to user ids, groups, etc. it must be world readable. In order to permit this usage but make running crack more difficult, the file is often split into /etc/passwd and a 'shadow' password file. The shadow file is not world readable and contains the encrypted password. The regular /etc/passwd file contains a dummy password in its place.",
      "ja": "/ etc / passwdファイルは、ユーザーID、グループなどにユーザ名をマッピングしているので、それは世界が読み取り可能でなければなりません。この使用を許可するが、実行中のクラックをより困難にするために、ファイルは、多くの場合、/ etc / passwdファイルと「影」パスワードファイルに分割されます。 shadowファイルには、世界で読めるものではなく、暗号化されたパスワードが含まれています。通常の/ etc / passwdファイルは、その場所にダミーのパスワードが含まれています。"
    },
    {
      "indent": 3,
      "text": "It is insufficient to simply state that one's protocol should be run over some lower layer security protocol. If a system relies upon lower layer security services for security, the protections those services are expected to provide MUST be clearly specified. In addition, the resultant properties of the combined system need to be specified.",
      "ja": "単に1のプロトコルは、いくつかの下位層のセキュリティプロトコル上で実行する必要があることを述べるには不十分です。システムはセキュリティのために、下位層のセキュリティサービスに依存している場合は、それらのサービスを提供することが期待されている保護は明確に指定されなければなりません。また、合成系の得られた特性を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: In general, the IESG will not approve standards track protocols which do not provide for strong authentication, either internal to the protocol or through tight binding to a lower layer security protocol.",
      "ja": "注意：一般的に、IESGは、基準が内部プロトコルやタイトな下位層のセキュリティプロトコルへの結合を介してのいずれか、強力な認証を提供しないのプロトコルを追跡し、承認しません。"
    },
    {
      "indent": 3,
      "text": "The threat environment addressed by the Security Considerations section MUST at a minimum include deployment across the global Internet across multiple administrative boundaries without assuming that firewalls are in place, even if only to provide justification for why such consideration is out of scope for the protocol. It is not acceptable to only discuss threats applicable to LANs and ignore the broader threat environment. All IETF standards-track protocols are considered likely to have deployment in the global Internet. In some cases, there might be an Applicability Statement discouraging use of a technology or protocol in a particular environment. Nonetheless, the security issues of broader deployment should be discussed in the document.",
      "ja": "最低でもSecurity Considerations部のMUSTによって対処脅威環境は、ファイアウォールだけで、このような配慮は、プロトコルの範囲外である理由のための正当化を提供する場合であっても、所定の位置にあると仮定することなく、複数の行政境界を越えたグローバルなインターネット全体の展開が含まれます。唯一のLANに適用される脅威を議論し、より広範な脅威環境を無視することは受け入れられません。すべてのIETF標準トラックプロトコルは、グローバルなインターネットでの展開を持っている可能性が考えられています。いくつかのケースでは、特定の環境での技術やプロトコルの使用を思いとどまら適用性に関する声明があるかもしれません。それにもかかわらず、より広範な展開のセキュリティ問題は文書で議論されるべきです。"
    },
    {
      "indent": 3,
      "text": "There should be a clear description of the residual risk to the user or operator of that protocol after threat mitigation has been deployed. Such risks might arise from compromise in a related protocol (e.g., IPsec is useless if key management has been compromised), from incorrect implementation, compromise of the security technology used for risk reduction (e.g., a cipher with a 40-bit key), or there might be risks that are not addressed by the protocol specification (e.g., denial of service attacks on an underlying link protocol). Particular care should be taken in situations where the compromise of a single system would compromise an entire protocol. For instance, in general protocol designers assume that end-systems are inviolate and don't worry about physical attack. However, in cases (such as a certificate authority) where compromise of a single system could lead to widespread compromises, it is appropriate to consider systems and physical security as well.",
      "ja": "脅威の軽減が展開された後、そのプロトコルの利用者やオペレータに残存リスクの明確な記述があるはずです。このようなリスクは、間違った実装から、（鍵管理が侵害された場合など、IPsecは無用である）に関連するプロトコルで妥協からリスク低減（例えば、40ビットのキーで暗号）に使用するセキュリティ技術の妥協を生じる可能性があります、またはプロトコル仕様によって対処されていないリスクがあるかもしれません（例えば、基本的なリンクプロトコル上のサービス妨害攻撃）。特に注意は、単一のシステムの妥協がプロトコル全体を危うくするような状況に注意する必要があります。例えば、一般的なプロトコルでは、設計者は、エンドシステムが犯さであり、物理的な攻撃を心配していないことを前提としています。単一システムの妥協が普及妥協につながる可能性がどこしかし、（例えば、認証局など）の場合には、同様のシステムと物理的なセキュリティを考慮することが適切です。"
    },
    {
      "indent": 3,
      "text": "There should also be some discussion of potential security risks arising from potential misapplications of the protocol or technology described in the RFC. This might be coupled with an Applicability Statement for that RFC.",
      "ja": "また、RFCに記載されているプロトコルや技術の潜在的な誤用から生じる潜在的なセキュリティリスクのいくつかの議論があるはずです。これは、RFCのための適用性に関する声明と結合することがあります。"
    },
    {
      "indent": 0,
      "text": "6. Examples",
      "section_title": true,
      "ja": "6.例"
    },
    {
      "indent": 3,
      "text": "This section consists of some example security considerations sections, intended to give the reader a flavor of what's intended by this document.",
      "ja": "このセクションでは、読者に、この文書が意図しているものの味を与えることを意図したいくつかの例のセキュリティに関する考慮事項のセクションで構成されています。"
    },
    {
      "indent": 3,
      "text": "The first example is a 'retrospective' example, applying the criteria of this document to an existing widely deployed protocol, SMTP. The second example is a good security considerations section clipped from a current protocol.",
      "ja": "最初の例では、既存の広く展開プロトコル、SMTPには、この文書の基準を適用し、「遡及的」例です。第二の例では、現在のプロトコルから切り出され、良好なセキュリティ問題部です。"
    },
    {
      "indent": 0,
      "text": "6.1. SMTP",
      "section_title": true,
      "ja": "6.1。 SMTP"
    },
    {
      "indent": 3,
      "text": "When RFC 821 was written, Security Considerations sections were not required in RFCs, and none is contained in that document. [RFC 2821] updated RFC 821 and added a detailed security considerations section. We reproduce here the Security Considerations section from that document (with new section numbers). Our comments are indented and prefaced with 'NOTE:'. We also add a number of new sections to cover topics we consider important. Those sections are marked with [NEW] in the section header.",
      "ja": "RFC 821が書かれたときに、セキュリティの考慮セクションは、RFCで要求されていなかった、といずれもその文書に含まれていません。 [RFC 2821]はRFC 821を更新し、詳細なセキュリティの考慮事項のセクションを追加しました。ここでは（新しいセクション番号を持つ）、その文書からSecurity Considerations部を再現します。私たちのコメントはインデントとと前置きされている「NOTE：」。我々はまた、私たちが重要と考えるのトピックをカバーするために、新しいセクションの番号を追加します。これらのセクションは、セクションヘッダの[NEW]とマークされています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Security Considerations",
      "section_title": true,
      "ja": "6.1.1。セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1.1.1. Mail Security and Spoofing",
      "section_title": true,
      "ja": "6.1.1.1。メールセキュリティとなりすまし"
    },
    {
      "indent": 3,
      "text": "SMTP mail is inherently insecure in that it is feasible for even fairly casual users to negotiate directly with receiving and relaying SMTP servers and create messages that will trick a naive recipient into believing that they came from somewhere else. Constructing such a message so that the \"spoofed\" behavior cannot be detected by an expert is somewhat more difficult, but not sufficiently so as to be a deterrent to someone who is determined and knowledgeable. Consequently, as knowledge of Internet mail increases, so does the knowledge that SMTP mail inherently cannot be authenticated, or integrity checks provided, at the transport level. Real mail security lies only in end-to-end methods involving the message bodies, such as those which use digital signatures (see [14] and, e.g., PGP [4] or S/MIME [31]).",
      "ja": "SMTPメールでもかなりカジュアルなユーザーが受信し、SMTPサーバを中継すると直接交渉し、彼らはどこか他の場所から来たことを信じるように素朴な受信者をだますますメッセージを作成することが可能であることを本質的に安全です。 「詐称」行動は、専門家では検出できないようなメッセージを構築することはやや困難ではなく、十分に決定され、知識の豊富さ、誰かに抑止力になるようです。その結果、インターネットメールは増加の知識として、そのSMTPメールは本質的に認証することができない、または整合性チェックは、トランスポートレベルで、提供した知識を行います。実際のメールセキュリティは、（[14]参照、例えば、PGP [4]またはS / MIME [31]）は、デジタル署名を使用するもののようなメッセージ本体を含むエンドツーエンドの方法、にあります。"
    },
    {
      "indent": 6,
      "text": "NOTE: One bad approach to sender authentication is [IDENT] in which the receiving mail server contacts the alleged sender and asks for the username of the sender. This is a bad idea for a number of reasons, including but not limited to relaying, TCP connection hijacking, and simple lying by the origin server. Aside from the fact that IDENT is of low security value, use of IDENT by receiving sites can lead to operational problems. Many sending sites blackhole IDENT requests, thus causing mail to be held until the receiving server's IDENT request times out.",
      "ja": "注：送信者認証に一つの悪いアプローチがある[IDENT]で受信したメールサーバの連絡先疑惑の送信者と送信者のユーザー名を要求します。これは含むが、中継TCPコネクションの乗っ取り、および、オリジンサーバによる簡単な嘘に限定されるものではなく、多くの理由のために悪い考えです。別にIDENTが低いセキュリティ価値があるという事実から、サイトを受けてIDENTを使用すると、操作上の問題につながることができます。多くの送信サイトでは、このようにメールが出て受信サーバのIDENT要求時間まで保持させる、IDENT要求をブラックホール。"
    },
    {
      "indent": 3,
      "text": "Various protocol extensions and configuration options that provide authentication at the transport level (e.g., from an SMTP client to an SMTP server) improve somewhat on the traditional situation described above. However, unless they are accompanied by careful handoffs of responsibility in a carefully-designed trust environment, they remain inherently weaker than end-to-end mechanisms which use digitally signed messages rather than depending on the integrity of the transport system.",
      "ja": "様々なプロトコル拡張と上記従来の状況に幾分改善トランスポートレベル（例えば、SMTPクライアントからSMTPサーバへ）で認証を提供するコンフィグレーションオプション。彼らは慎重に設計された信頼環境における責任の慎重なハンドオフを伴っている場合を除きしかし、彼らはデジタル署名されたメッセージを使用して、エンドツーエンドのメカニズムではなくより輸送システムの整合性に応じて、本質的に弱いまま。"
    },
    {
      "indent": 3,
      "text": "Efforts to make it more difficult for users to set envelope return path and header \"From\" fields to point to valid addresses other than their own are largely misguided: they frustrate legitimate applications in which mail is sent by one user on behalf of another or in which error (or normal) replies should be directed to a special address. (Systems that provide convenient ways for users to alter these fields on a per-message basis should attempt to establish a primary and permanent mailbox address for the user so that Sender fields within the message data can be generated sensibly.)",
      "ja": "自分自身以外の有効なアドレスを指すように、フィールド「から」ユーザーが封筒のリターンパスとヘッダーを設定することがより困難にする努力は大部分が誤っている：彼らは、メールが別のまたは内に代わって一人のユーザーによって送信された正当なアプリケーションをくじきますどのエラー（または正常）応答特別なアドレスに送られるべきです。 （ユーザーがメッセージごとに、これらのフィールドを変更するための便利な方法を提供するシステムは、メッセージデータ内の送信者フィールドが賢明生成することができるように、ユーザーのプライマリおよび永久的なメールボックスアドレスを確立することを試みる必要があります。）"
    },
    {
      "indent": 3,
      "text": "This specification does not further address the authentication issues associated with SMTP other than to advocate that useful functionality not be disabled in the hope of providing some small margin of protection against an ignorant user who is trying to fake mail.",
      "ja": "偽メールにしようとしている無知なユーザーに対する保護のいくつかの小さなマージンを提供することを期待して無効にすることはないという便利な機能を提唱するよりも、この仕様は、他のSMTPに関連した認証の問題に対処していません。"
    },
    {
      "indent": 6,
      "text": "NOTE: We have added additional material on communications security and SMTP in Section 6.1.2 In a final specification, the above text would be edited somewhat to reflect that fact.",
      "ja": "注：私たちは、最終的な仕様は、セクション6.1.2で通信セキュリティおよびSMTPに追加の材料を追加して、上記のテキストは、その事実を反映するために、多少編集することでしょう。"
    },
    {
      "indent": 0,
      "text": "6.1.1.2. Blind Copies",
      "section_title": true,
      "ja": "6.1.1.2。ブラインドコピー"
    },
    {
      "indent": 3,
      "text": "Addresses that do not appear in the message headers may appear in the RCPT commands to an SMTP server for a number of reasons. The two most common involve the use of a mailing address as a \"list exploder\" (a single address that resolves into multiple addresses) and the appearance of \"blind copies\". Especially when more than one RCPT command is present, and in order to avoid defeating some of the purpose of these mechanisms, SMTP clients and servers SHOULD NOT copy the full set of RCPT command arguments into the headers, either as part of trace headers or as informational or private-extension headers. Since this rule is often violated in practice, and cannot be enforced, sending SMTP systems that are aware of \"bcc\" use MAY find it helpful to send each blind copy as a separate message transaction containing only a single RCPT command.",
      "ja": "メッセージヘッダに表示されていないアドレスがいくつかの理由のためにSMTPサーバーへのRCPTコマンドで表示されることがあります。二つの最も一般的なのは（複数のアドレスに解決単一のアドレス）「リストエクスプローダ」と「ブラインドコピー」の外観として、メールアドレスの使用を含みます。特に、複数のRCPTコマンドが存在し、これらのメカニズムの目的の一部を破っ避けるために、SMTPクライアントとサーバは、いずれかのトレースヘッダの一部として、またはとして、ヘッダにRCPTコマンドの引数のフルセットをコピーすべきではありませんとき情報提供や民間の拡張ヘッダー。このルールは、多くの場合、実際には破られ、それが役に立つだけで、単一のRCPTコマンドを含む別のメッセージトランザクションとして各ブラインドコピーを送信するかもしれない「BCC」の使用を認識しているSMTPシステムを送信、強制することはできませんので。"
    },
    {
      "indent": 3,
      "text": "There is no inherent relationship between either \"reverse\" (from MAIL, SAML, etc., commands) or \"forward\" (RCPT) addresses in the SMTP transaction (\"envelope\") and the addresses in the headers. Receiving systems SHOULD NOT attempt to deduce such relationships and use them to alter the headers of the message for delivery. The popular \"Apparently-to\" header is a violation of this principle as well as a common source of unintended information disclosure and SHOULD NOT be used.",
      "ja": "「リバース」（などMAIL、SAML、から、コマンド）または「フォワード」（RCPT）SMTPトランザクション（「エンベロープ」）のアドレスとヘッダ内のアドレスのいずれかとの間には固有の関係はありません。システムを受信すると、そのような関係を推定し、配信のためにメッセージのヘッダを変更するためにそれらを使用することを試みるべきではありません。人気の「どうやら-に」ヘッダはこの原則の違反だけでなく、意図しない情報開示の一般的な原因であるため、使用しないでください。"
    },
    {
      "indent": 0,
      "text": "6.1.1.3. VRFY, EXPN, and Security",
      "section_title": true,
      "ja": "6.1.1.3。 VRFY、EXPN、およびセキュリティ"
    },
    {
      "indent": 3,
      "text": "As discussed in section 3.5, individual sites may want to disable either or both of VRFY or EXPN for security reasons. As a corollary to the above, implementations that permit this MUST NOT appear to have verified addresses that are not, in fact, verified. If a site disables these commands for security reasons, the SMTP server MUST return a 252 response, rather than a code that could be confused with successful or unsuccessful verification.",
      "ja": "セクション3.5で説明したように、個々のサイトでは、セキュリティ上の理由でVRFYまたはEXPNのいずれかまたは両方を無効にすることができます。上記の当然の結果として、これを許可する実装が確認され、実際には、ないアドレスを確認しているように見えてはなりません。サイトはセキュリティ上の理由から、これらのコマンドを無効にした場合は、SMTPサーバーではなく、成功または失敗した検証と混同される可能性がコードよりも、252応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Returning a 250 reply code with the address listed in the VRFY command after having checked it only for syntax violates this rule. Of course, an implementation that \"supports\" VRFY by always returning 550 whether or not the address is valid is equally not in conformance.",
      "ja": "構文のみのためにそれを確認した後、VRFYコマンドに記載されているアドレスを使用して250応答コードを返すことは、この規則に違反します。もちろん、常にアドレスが有効であるか否かが550を返すことによってVRFYを「サポート」という実装が適合しても同様ではありません。"
    },
    {
      "indent": 3,
      "text": "Within the last few years, the contents of mailing lists have become popular as an address information source for so-called \"spammers.\" The use of EXPN to \"harvest\" addresses has increased as list administrators have installed protections against inappropriate uses of the lists themselves. Implementations SHOULD still provide support for EXPN, but sites SHOULD carefully evaluate the tradeoffs. As authentication mechanisms are introduced into SMTP, some sites may choose to make EXPN available only to authenticated requesters.",
      "ja": "過去数年以内に、メーリングリストの内容は、いわゆるのためのアドレス情報源として広く普及している「スパマー。」リスト管理者は、リスト自身の不適切な使用に対する保護がインストールされているようEXPNに「収穫」のアドレスの使用が増加しています。実装はまだEXPNのサポートを提供する必要がありますが、サイトは慎重にトレードオフを評価する必要があります。認証メカニズムは、SMTPに導入されたように、いくつかのサイトでは唯一、認証要求者へのEXPNを利用可能にすることもできます。"
    },
    {
      "indent": 6,
      "text": "NOTE: It's not clear that disabling VRFY adds much protection, since it's often possible to discover whether an address is valid using RCPT TO.",
      "ja": "注：それはそれはアドレスがRCPT TOを使用して有効であるかどうかを発見することが多いことが可能ですので、VRFYを無効にすると、多くの保護を追加していることは明らかではありません。"
    },
    {
      "indent": 0,
      "text": "6.1.1.4. Information Disclosure in Announcements",
      "section_title": true,
      "ja": "6.1.1.4。アナウンスで情報開示"
    },
    {
      "indent": 3,
      "text": "There has been an ongoing debate about the tradeoffs between the debugging advantages of announcing server type and version (and, sometimes, even server domain name) in the greeting response or in response to the HELP command and the disadvantages of exposing information that might be useful in a potential hostile attack. The utility of the debugging information is beyond doubt. Those who argue for making it available point out that it is far better to actually secure an SMTP server rather than hope that trying to conceal known vulnerabilities by hiding the server's precise identity will provide more protection. Sites are encouraged to evaluate the tradeoff with that issue in mind; implementations are strongly encouraged to minimally provide for making type and version information available in some way to other network hosts.",
      "ja": "グリーティング応答またはHELPコマンドに応答して、サーバーの種類とバージョンを発表（そして、時には、でも、サーバーのドメイン名）のデバッグ利点と役に立つかもしれない情報を暴露するの欠点の間のトレードオフに関する議論が続いてきました潜在的な敵対的な攻撃インチデバッグ情報の有用性は疑いを超えています。それを利用可能にするために主張する人たちは、実際にSMTPサーバーを保護ではなく、サーバの正確な身元を隠すことで、既知の脆弱性を隠蔽しようとしていることは多くの保護を提供することを願っていますし、はるかに良いであることを指摘しています。サイトは念頭に置いてその問題とのトレードオフを評価することをお勧めします。実装は強く最小限に他のネットワークホストに何らかの方法で種類とバージョン情報を利用可能にするために提供することが奨励されています。"
    },
    {
      "indent": 0,
      "text": "6.1.1.5. Information Disclosure in Trace Fields",
      "section_title": true,
      "ja": "6.1.1.5。トレースフィールドにおける情報開示"
    },
    {
      "indent": 3,
      "text": "In some circumstances, such as when mail originates from within a LAN whose hosts are not directly on the public Internet, trace (\"Received\") fields produced in conformance with this specification may disclose host names and similar information that would not normally be available. This ordinarily does not pose a problem, but sites with special concerns about name disclosure should be aware of it. Also, the optional FOR clause should be supplied with caution or not at all when multiple recipients are involved lest it inadvertently disclose the identities of \"blind copy\" recipients to others.",
      "ja": "そのようなメールはそのホスト公共のインターネット上で直接ではありませんLAN内から発信する場合など、いくつかの状況では、この仕様に準拠して作成トレース（「受信」）フィールドが正常に利用できないでしょうホスト名と同様の情報を開示することがあります。これは、通常は問題にならないが、名前の開示に関する特別な懸念を持つサイトは、それを認識する必要があります。それがうっかり他人に「ブラインドコピー」の受取人の身元を開示しないように複数の受信者が含まれている場合にも、オプションのFOR句は全く注意して供給したりする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1.6. Information Disclosure in Message Forwarding",
      "section_title": true,
      "ja": "6.1.1.6。メッセージ転送における情報開示"
    },
    {
      "indent": 3,
      "text": "As discussed in section 3.4, use of the 251 or 551 reply codes to identify the replacement address associated with a mailbox may inadvertently disclose sensitive information. Sites that are concerned about those issues should ensure that they select and configure servers appropriately.",
      "ja": "セクション3.4で議論したように、メールボックスに関連付けられた代替アドレスを識別するために251のまたは551応答コードの使用は、誤っ機密情報を開示することができます。これらの問題を懸念しているサイトでは、彼らが選択していることを確認し、適切なサーバを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1.7. Scope of Operation of SMTP Servers",
      "section_title": true,
      "ja": "6.1.1.7。 SMTPサーバーの運用の範囲"
    },
    {
      "indent": 3,
      "text": "It is a well-established principle that an SMTP server may refuse to accept mail for any operational or technical reason that makes sense to the site providing the server. However, cooperation among sites and installations makes the Internet possible. If sites take excessive advantage of the right to reject traffic, the ubiquity of email availability (one of the strengths of the Internet) will be threatened; considerable care should be taken and balance maintained if a site decides to be selective about the traffic it will accept and process.",
      "ja": "SMTPサーバが提供サーバサイトに理にかなっている任意の運用や技術的な理由のためにメールを受け入れることを拒否することが十分に確立原則です。しかし、サイトやインスタレーション間の協力は、インターネットが可能になります。サイトがトラフィックを拒否する権利を過度に活用する場合は、電子メールの利用可能性（インターネットの強みの1つ）の偏在性が脅かされます。サイトはそれが受け入れるトラフィックやプロセスについて選択的であることが決定した場合、かなりの注意が必要とのバランスを維持しました。"
    },
    {
      "indent": 3,
      "text": "In recent years, use of the relay function through arbitrary sites has been used as part of hostile efforts to hide the actual origins of mail. Some sites have decided to limit the use of the relay function to known or identifiable sources, and implementations SHOULD provide the capability to perform this type of filtering. When mail is rejected for these or other policy reasons, a 550 code SHOULD be used in response to EHLO, MAIL, or RCPT as appropriate.",
      "ja": "近年では、任意のサイトを通じてリレー機能を使用すると、メールの実際の起源を隠すために敵対的な取り組みの一環として使用されています。いくつかのサイトは、既知の又は識別可能なソースへの中継機能の使用を制限することを決定しており、実装は、この種のフィルタリングを実行する能力を提供すべきです。メールがこれら又は他のポリシー上の理由で拒否された場合、550コードが適宜EHLO、MAIL、またはRCPTに応じて使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.1.1.8. Inappropriate Usage [NEW]",
      "section_title": true,
      "ja": "6.1.1.8。不適切な使い方[NEW]"
    },
    {
      "indent": 3,
      "text": "SMTP itself provides no protection is provided against unsolicited commercial mass e-mail (aka spam). It is extremely difficult to tell a priori whether a given message is spam or not. From a protocol perspective, spam is indistinguishable from other e-mail -- the distinction is almost entirely social and often quite subtle. (For instance, is a message from a merchant from whom you've purchased items before advertising similar items spam?) SMTP spam-suppression mechanisms are generally limited to identifying known spam senders and either refusing to service them or target them for punishment/disconnection. [RFC-2505] provides extensive guidance on making SMTP servers spam-resistant. We provide a brief discussion of the topic here.",
      "ja": "SMTP自体は（別名スパム）迷惑な商用大量の電子メールに対して提供される保護機能はありません。与えられたメッセージがスパムであるかどうかを先験的に伝えることは非常に困難です。プロトコルの観点から、スパムは、他の電子メールと区別できない - の区別はほぼ完全に社会的、しばしば非常に微妙です。 （たとえば、あなたが広告関連商品のスパムの前にアイテムを購入した人からの商人からのメッセージである？）SMTPスパム-抑制メカニズムは、一般的に既知のスパム送信者とのいずれか、それらをサービスまたは罰のためにそれらを対象とすることを拒否/切断を同定することに限定されています。 [RFC-2505] SMTPサーバがスパム耐性作ることに豊富なガイダンスを提供します。ここでは、トピックの簡単な説明を提供しています。"
    },
    {
      "indent": 3,
      "text": "The primary tool for refusal to service spammers is the blacklist. Some authority such as [MAPS] collects and publishes a list of known spammers. Individual SMTP servers then block the blacklisted offenders (generally by IP address).",
      "ja": "サービススパマーに拒否するための主要なツールは、ブラックリストです。こうした[MAPS]のようないくつかの権限が収集し、既知のスパマーのリストを公開しています。個々のSMTPサーバは、（一般的にIPアドレスによる）ブラックリストに載って犯罪者をブロックします。"
    },
    {
      "indent": 3,
      "text": "In order to avoid being blacklisted or otherwise identified, spammers often attempt to obscure their identity, either simply by sending a false SMTP identity or by forwarding their mail through an Open Relay -- an SMTP server which will perform mail relaying for any sender. As a consequence, there are now blacklists [ORBS] of open relays as well.",
      "ja": "ブラックリストに載っあるいは特定されないようにするために、スパマーは多くの場合、単純に偽のSMTP IDを送信することによって、またはオープン・リレーを介して自分のメールを転送することにより、いずれか、自分のアイデンティティをあいまいにしよう - 任意の送信者のメール中継を行いますSMTPサーバを。その結果、同様のオープンリレーの[ORBS]ブラックリストが存在することになります。"
    },
    {
      "indent": 0,
      "text": "6.1.1.8.1. Closed Relaying [NEW]",
      "section_title": true,
      "ja": "6.1.1.8.1。クローズリレー[NEW]"
    },
    {
      "indent": 3,
      "text": "To avoid being used for spam forwarding, many SMTP servers operate as closed relays, providing relaying service only for clients who they can identify. Such relays should generally insist that senders advertise a sending address consistent with their known identity. If the relay is providing service for an identifiable network (such as a corporate network or an ISP's network) then it is sufficient to block all other IP addresses). In other cases, explicit authentication must be used. The two standard choices for this are TLS [STARTTLS] and SASL [SASLSMTP].",
      "ja": "スパム転送に使用されないようにするには、多くのSMTPサーバーでは、彼らだけが識別できるクライアントのための中継サービスを提供し、クローズドリレーとして動作します。このようなリレーは、一般的に、送信者は、それらの既知のアイデンティティと一致し、送信アドレスを宣伝することを主張すべきです。リレーは、（例えば、企業ネットワークやISPのネットワークなど）を特定できるネットワークのためのサービスを提供している場合、他のすべてのIPアドレスをブロックするのに十分です）。他の例では、明示的な認証を使用する必要があります。このための2つの標準的な選択肢は、TLS [STARTTLS]とSASL [SASLSMTP]です。"
    },
    {
      "indent": 0,
      "text": "6.1.1.8.2. Endpoints [NEW]",
      "section_title": true,
      "ja": "6.1.1.8.2。エンドポイント[NEW]"
    },
    {
      "indent": 3,
      "text": "Realistically, SMTP endpoints cannot refuse to deny service to unauthenticated senders. Since the vast majority of senders are unauthenticated, this would break Internet mail interoperability. The exception to this is when the endpoint server should only be receiving mail from some other server which can itself receive unauthenticated messages. For instance, a company might operate a public gateway but configure its internal servers to only talk to the gateway.",
      "ja": "現実的には、SMTPエンドポイントは、認証されていない送信者へのサービスを拒否することを拒否することはできません。送信者の大半が認証されていますので、これはインターネットメールの相互運用性を破ります。エンドポイントサーバーのみ自体が認証されていないメッセージを受け取ることができますいくつかの他のサーバーからメールを受信する必要がある場合は例外です。例えば、会社が公共ゲートウェイを操作するだけでゲートウェイと通信するために、内部サーバーを構成することがあります。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Communications security issues [NEW]",
      "section_title": true,
      "ja": "6.1.2。コミュニケーションセキュリティの問題[NEW]"
    },
    {
      "indent": 3,
      "text": "SMTP itself provides no communications security, and therefore a large number of attacks are possible. A passive attack is sufficient to recover the text of messages transmitted with SMTP. No endpoint authentication is provided by the protocol. Sender spoofing is trivial, and therefore forging email messages is trivial. Some implementations do add header lines with hostnames derived through reverse name resolution (which is only secure to the extent that it is difficult to spoof DNS -- not very), although these header lines are normally not displayed to users. Receiver spoofing is also fairly straight-forward, either using TCP connection hijacking or DNS spoofing. Moreover, since email messages often pass through SMTP gateways, all intermediate gateways must be trusted, a condition nearly impossible on the global Internet.",
      "ja": "SMTP自体は、通信のセキュリティを提供しないので、攻撃の多数が可能です。受動的攻撃はSMTPで送信されたメッセージのテキストを回復するのに十分です。いいえエンドポイント認証は、プロトコルによって提供されていません。送信者のなりすましは自明であるため、電子メールメッセージを偽造することは簡単です。これらのヘッダー行は、通常、ユーザーに表示されていないものの、 - いくつかの実装では（ない非常にのみ、それがスプーフィングDNSすることが困難であるという程度に安全である）逆名前解決を介して誘導されたホスト名を持つヘッダ行を追加行います。レシーバスプーフィングは、TCPコネクションハイジャックまたはDNS詐称のいずれかを使用して、またかなりストレートフォワードです。電子メールメッセージは、多くの場合、SMTPゲートウェイを通過するので、すべての中間ゲートウェイは、グローバルなインターネット上の条件はほぼ不可能、信頼されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Several approaches are available for alleviating these threats. In order of increasingly high level in the protocol stack, we have:",
      "ja": "いくつかのアプローチが、これらの脅威を軽減するために用意されています。プロトコルスタックのますますハイレベルのために、我々は持っています："
    },
    {
      "indent": 6,
      "text": "SMTP over IPSEC SMTP/TLS S/MIME and PGP/MIME",
      "ja": "IPSEC SMTP / TLS、S / MIMEやPGP / MIMEを超えるSMTP"
    },
    {
      "indent": 0,
      "text": "6.1.2.1. SMTP over IPSEC [NEW]",
      "section_title": true,
      "ja": "6.1.2.1。 IPSECを超えるSMTP [NEW]"
    },
    {
      "indent": 3,
      "text": "An SMTP connection run over IPSEC can provide confidentiality for the message between the sender and the first hop SMTP gateway, or between any pair of connected SMTP gateways. That is to say, it provides channel security for the SMTP connections. In a situation where the message goes directly from the client to the receiver's gateway, this may provide substantial security (though the receiver must still trust the gateway). Protection is provided against replay attacks, since the data itself is protected and the packets cannot be replayed.",
      "ja": "IPSEC上で実行SMTP接続は、送信者と最初のホップSMTPゲートウェイ、または接続されたSMTPゲートウェイの任意の対の間の間のメッセージの機密性を提供することができます。つまり、SMTP接続のためのチャネルのセキュリティを提供し、言うことです。 （受信機がまだゲートウェイを信頼しなければなりませんが）、メッセージが受信者のゲートウェイにクライアントから直接行くような状況では、これはかなりのセキュリティを提供することができます。データ自体は保護されているため保護は、リプレイ攻撃に対して提供され、パケットが再生することができません。"
    },
    {
      "indent": 3,
      "text": "Endpoint identification is a problem, however, unless the receiver's address can be directly cryptographically authenticated. Sender identification is not generally available, since generally only the sender's machine is authenticated, not the sender himself. Furthermore, the identity of the sender simply appears in the From header of the message, so it is easily spoofable by the sender. Finally, unless the security policy is set extremely strictly, there is also an active downgrade to cleartext attack.",
      "ja": "受信者のアドレスを直接暗号認証できない限り、エンドポイント識別は、しかし、問題です。送信者の識別は、一般的にのみ、送信者のマシンがいない送信者に、自分自身を認証されているので、一般的には使用できません。また、送信者の身元は、単にメッセージのFromヘッダに現れるので、送信者によって容易に偽造される可能性があり。セキュリティポリシーが非常に厳しく設定されていない限り、最後に、また、平文攻撃へのアクティブなダウングレードがあります。"
    },
    {
      "indent": 3,
      "text": "Another problem with IPsec as a security solution for SMTP is the lack of a standard IPsec API. In order to take advantage of IPsec, applications in general need to be able to instruct the IPsec implementation about their security policies and discover what protection has been applied to their connections. Without a standard API this is very difficult to do portably.",
      "ja": "SMTPのためのセキュリティソリューションとしてのIPsecのもう一つの問題は、標準のIPsec APIの欠如です。 IPsecのを活用するためには、一般的な必要としているアプリケーションは、セキュリティポリシーについてIPsec実装を指示し、保護はその接続に適用されているものを発見することができるようにします。標準のAPIがなければ、これは移植性行うことは非常に困難です。"
    },
    {
      "indent": 3,
      "text": "Implementors of SMTP servers or SMTP administrators MUST NOT assume that IPsec will be available unless they have reason to believe that it will be (such as the existence of preexisting association between two machines). However, it may be a reasonable procedure to attempt to create an IPsec association opportunistically to a peer server when mail is delivered. Note that in cases where IPsec is used to provide a VPN tunnel between two sites, this is of substantial security value, particularly to the extent that confidentiality is provided, subject to the caveats mentioned above. Also see [USEIPSEC] for general guidance on the applicability of IPsec.",
      "ja": "SMTPサーバーまたはSMTP管理者の実装者は、彼らはそれが（例えば2台のマシン間の既存の関連の有無など）になると信じる理由がない限り、IPsecが利用可能になると仮定してはいけません。しかし、メールが配信されたときに、ピアサーバーに日和​​見IPsecアソシエーションを作成しようとする合理的な手順かもしれません。 IPsecは2つのサイト間のVPNトンネルを提供するために使用される場合には、これは特に機密性は、上記の警告を受ける提供される程度まで、実質的なセキュリティ値であることに留意されたいです。また、IPsecのの適用上の一般的なガイダンスのために[USEIPSEC]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1.2.2. SMTP/TLS [NEW]",
      "section_title": true,
      "ja": "6.1.2.2。 SMTP / TLS [NEW]"
    },
    {
      "indent": 3,
      "text": "SMTP can be combined with TLS as described in [STARTTLS]. This provides similar protection to that provided when using IPSEC. Since TLS certificates typically contain the server's host name, recipient authentication may be slightly more obvious, but is still susceptible to DNS spoofing attacks. Notably, common implementations of TLS contain a US exportable (and hence low security) mode. Applications desiring high security should ensure that this mode is disabled. Protection is provided against replay attacks, since the data itself is protected and the packets cannot be replayed. [Note: The Security Considerations section of the SMTP over TLS document is quite good and bears reading as an example of how to do things.]",
      "ja": "[STARTTLS]に記載されるようにSMTPは、TLSと組み合わせることができます。これはIPSECを使用する際に提供されるものと同様の保護を提供します。 TLS証明書は通常、サーバーのホスト名が含まれているため、受信者認証は、わずかにより明白であるが、それでもDNSスプーフィング攻撃を受けやすいことがあります。注目すべきは、TLSの一般的な実装は、米国のエクスポート（ひいては低セキュリティ）モードが含まれています。高いセキュリティを希望するアプリケーションは、このモードが無効になっていることを確認する必要があります。データ自体は保護されているため保護は、リプレイ攻撃に対して提供され、パケットが再生することができません。 [注：TLSの文書の上にSMTPのSecurity Considerations部はかなり良いですし、クマは物事を行う方法の一例として読んで。]"
    },
    {
      "indent": 0,
      "text": "6.1.2.3. S/MIME and PGP/MIME [NEW]",
      "section_title": true,
      "ja": "6.1.2.3。 S / MIMEおよびPGP / MIME [NEW]"
    },
    {
      "indent": 3,
      "text": "S/MIME and PGP/MIME are both message oriented security protocols. They provide object security for individual messages. With various settings, sender and recipient authentication and confidentiality may be provided. More importantly, the identification is not of the sending and receiving machines, but rather of the sender and recipient themselves. (Or, at least, of cryptographic keys corresponding to the sender and recipient.) Consequently, end-to-end security may be obtained. Note, however, that no protection is provided against replay attacks. Note also that S/MIME and PGP/MIME generally provide identifying marks for both sender and receiver. Thus even when confidentiality is provided, traffic analysis is still possible.",
      "ja": "S / MIMEやPGP / MIMEは、両方のメッセージ指向のセキュリティプロトコルです。彼らは、個々のメッセージのためのオブジェクトのセキュリティを提供します。さまざまな設定では、送信者と受信者の認証と機密性を提供することができます。さらに重要なのは、識別は、送信と受信機のではなく、送信者と受信者自身のものではありません。 （または、少なくとも、送信者と受信者に対応する暗号鍵の。）これにより、エンドツーエンドのセキュリティを得ることができます。何の保護がリプレイ攻撃提供されていないこと、しかし、注意してください。注意また、そのS / MIMEおよびPGP / MIMEは、一般的に送信側と受信側の両方にマークを識別提供します。機密性が提供されている場合でもこのように、トラフィック分析は可能です。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Denial of Service [NEW]",
      "section_title": true,
      "ja": "6.1.3。サービス妨害[NEW]"
    },
    {
      "indent": 3,
      "text": "None of these security measures provides any real protection against denial of service. SMTP connections can easily be used to tie up system resources in a number of ways, including excessive port consumption, excessive disk usage (email is typically delivered to disk files), and excessive memory consumption (sendmail, for instance, is fairly large, and typically forks a new process to deal with each message.)",
      "ja": "これらのセキュリティ対策はいずれも、サービス拒否に対する任意の実際の保護を提供しません。 SMTP接続が簡単に過度のポートの消費量、過度のディスクの使用状況（電子メールは、通常のディスク・ファイルに配信される）、および過度のメモリ消費を含め、いくつかの方法でシステムリソースをタイアップするために使用することができます（sendmailは、例えば、かなり大きく、典型的には、各メッセージに対処するための新しいプロセスをフォーク。）"
    },
    {
      "indent": 3,
      "text": "If transport- or application-layer security is used for SMTP connections, it is possible to mount a variety of attacks on individual connections using forged RSTs or other kinds of packet injection.",
      "ja": "transport-またはアプリケーションレイヤセキュリティはSMTP接続に使用されている場合、偽造のRSTパケットまたは注入の他の種類を使用して、個々の接続に関するさまざまな攻撃を搭載することが可能です。"
    },
    {
      "indent": 0,
      "text": "6.2. VRRP",
      "section_title": true,
      "ja": "6.2。 VRRP"
    },
    {
      "indent": 3,
      "text": "The second example is from VRRP, the Virtual Router Redundance Protocol ([VRRP]). We reproduce here the Security Considerations section from that document (with new section numbers). Our comments are indented and prefaced with 'NOTE:'.",
      "ja": "第二の例では、VRRP、仮想ルータ冗長プロトコル（[VRRP]）からのものです。ここでは（新しいセクション番号を持つ）、その文書からSecurity Considerations部を再現します。私たちのコメントはインデントとと前置きされている「NOTE：」。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Security Considerations",
      "section_title": true,
      "ja": "6.2.1。セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "VRRP is designed for a range of internetworking environments that may employ different security policies. The protocol includes several authentication methods ranging from no authentication, simple clear text passwords, and strong authentication using IP Authentication with MD5 HMAC. The details on each approach including possible attacks and recommended environments follows.",
      "ja": "VRRPは、異なるセキュリティポリシーを使用することができる環境をインターネットワーキングの範囲のために設計されています。プロトコルは、MD5 HMACとIP認証を使用して、認証なし、簡単なクリアテキストのパスワード、および強力な認証に至るまで、いくつかの認証方法を含んでいます。攻撃の可能性や、推奨環境は以下を含む各アプローチの詳細。"
    },
    {
      "indent": 3,
      "text": "Independent of any authentication type VRRP includes a mechanism (setting TTL=255, checking on receipt) that protects against VRRP packets being injected from another remote network. This limits most vulnerabilities to local attacks.",
      "ja": "任意の認証タイプの独立したVRRPはVRRPパケットが別のリモートネットワークから注入されるから保護する（TTL = 255を設定し、受信時に検査する）機構を含みます。これは、ローカルの攻撃に最も脆弱性を制限します。"
    },
    {
      "indent": 6,
      "text": "NOTE: The security measures discussed in the following sections only provide various kinds of authentication. No confidentiality is provided at all. This should be explicitly described as outside the scope.",
      "ja": "注：次のセクションで説明したセキュリティ対策は、認証のみの様々な種類を提供します。なし機密性は全く提供されていません。これは、明示的に範囲外として記述する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. No Authentication",
      "section_title": true,
      "ja": "6.2.1.1。認証なし"
    },
    {
      "indent": 3,
      "text": "The use of this authentication type means that VRRP protocol exchanges are not authenticated. This type of authentication SHOULD only be used in environments were there is minimal security risk and little chance for configuration errors (e.g., two VRRP routers on a LAN).",
      "ja": "この認証タイプを使用すると、VRRPプロトコル交換が認証されていないことを意味します。このタイプの認証はのみの環境で使用されるべき最低限のセキュリティリスクと設定エラー（LAN上の例えば、2つのVRRPルータ）のために少しのチャンスがありました。"
    },
    {
      "indent": 0,
      "text": "6.2.1.2. Simple Text Password",
      "section_title": true,
      "ja": "6.2.1.2。単純なテキストのパスワード"
    },
    {
      "indent": 3,
      "text": "The use of this authentication type means that VRRP protocol exchanges are authenticated by a simple clear text password.",
      "ja": "この認証タイプを使用すると、VRRPプロトコル交換が簡単なクリアテキストのパスワードによって認証されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "This type of authentication is useful to protect against accidental misconfiguration of routers on a LAN. It protects against routers inadvertently backing up another router. A new router must first be configured with the correct password before it can run VRRP with another router. This type of authentication does not protect against hostile attacks where the password can be learned by a node snooping VRRP packets on the LAN. The Simple Text Authentication combined with the TTL check makes it difficult for a VRRP packet to be sent from another LAN to disrupt VRRP operation.",
      "ja": "このタイプの認証は、LAN上のルータの偶然の設定ミスから保護するのに便利です。これは、ルータが不注意に別のルータをバックアップから保護します。それは別のルータでVRRPを実行する前に、新しいルータは、最初に正しいパスワードを設定する必要があります。このタイプの認証は、パスワードはLAN上のVRRPパケットをスヌーピングノードによって学習することができ敵対的な攻撃から保護することはできません。 TTLチェックと組み合わせたシンプルなテキスト認証は、VRRPパケットは、VRRPの動作が中断して別のLANから送信されるためにそれを困難にしています。"
    },
    {
      "indent": 3,
      "text": "This type of authentication is RECOMMENDED when there is minimal risk of nodes on a LAN actively disrupting VRRP operation. If this type of authentication is used the user should be aware that this clear text password is sent frequently, and therefore should not be the same as any security significant password.",
      "ja": "このタイプの認証は、積極的にVRRP操作を中断するLAN上のノードの最小限のリスクがある場合に推奨されます。このタイプの認証が使用されている場合、ユーザーは、このクリアテキストのパスワードが頻繁に送られていることに注意する必要があり、したがって、すべてのセキュリティの重要なパスワードと同じであってはなりません。"
    },
    {
      "indent": 6,
      "text": "NOTE: This section should be clearer. The basic point is that no authentication and Simple Text are only useful for a very limited threat model, namely that none of the nodes on the local LAN are hostile. The TTL check prevents hostile nodes off-LAN from posing as valid nodes, but nothing stops hostile nodes on-LAN from impersonating authorized nodes. This is not a particularly realistic threat model in many situations. In particular, it's extremely brittle: the compromise of any node the LAN allows reconfiguration of the VRRP nodes.",
      "ja": "注：このセクションでは、明確にする必要があります。基本的なポイントは認証とシンプルなテキストは、ローカルLAN上のノードのどれもが敵対的ではない、すなわちことを、非常に限られた脅威モデルにのみ有用ではないということです。 TTLチェックが有効なノードを装っからオフLAN敵対的なノードを防ぎ、何も認可ノードになりすますオンLAN敵対的なノードを停止しません。これは、多くの状況で特に現実的な脅威モデルではありません。特に、それは非常に脆いです：任意のノードの妥協はLANは、VRRPノードの再構成を可能にします。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3. IP Authentication Header",
      "section_title": true,
      "ja": "6.2.1.3。 IP認証ヘッダ"
    },
    {
      "indent": 3,
      "text": "The use of this authentication type means the VRRP protocol exchanges are authenticated using the mechanisms defined by the IP Authentication Header [AH] using [HMAC]. This provides strong protection against configuration errors, replay attacks, and packet corruption/modification.",
      "ja": "この認証タイプを使用することは、VRRPプロトコル交換は、[HMAC]を使用してIP認証ヘッダ[AH]で定義されたメカニズムを使用して認証されることを意味します。これは、構成エラー、リプレイ攻撃、およびパケット破損/変更に対する強力な保護を提供します。"
    },
    {
      "indent": 3,
      "text": "This type of authentication is RECOMMENDED when there is limited control over the administration of nodes on a LAN. While this type of authentication does protect the operation of VRRP, there are other types of attacks that may be employed on shared media links (e.g., generation of bogus ARP replies) which are independent from VRRP and are not protected.",
      "ja": "LAN上のノードの管理を超える制限された制御があるときにこのタイプの認証をお勧めします。このタイプの認証は、VRRPの動作を保護しながら、共有メディアリンク上で使用することができる攻撃の他のタイプは、VRRPから独立しており、保護されていない（例えば、偽のARPの発生が返信）があります。"
    },
    {
      "indent": 6,
      "text": "NOTE: It's a mistake to have AH be a RECOMMENDED in this context. Since AH is the only mechanism that protects VRRP against attack from other nodes on the same LAN, it should be a MUST for cases where there are untrusted nodes on the same network. In any case, AH should be a MUST implement.",
      "ja": "注：これは、AH、この文脈で推奨されていのは間違いです。 AHは同じLAN上の他のノードからの攻撃に対してVRRPを保護する唯一のメカニズムであるので、同じネットワーク上の信頼できないノードが存在する場合には必須であるべきです。いずれにせよ、AHは実装しなければならないはずです。"
    },
    {
      "indent": 6,
      "text": "NOTE: There's an important piece of security analysis that's only hinted at in this document, namely the cost/benefit tradeoff of VRRP authentication.",
      "ja": "注：このドキュメントだけでほのめかしのセキュリティ分析の重要な部分、VRRP認証のすなわちコスト/利益のトレードオフがあります。"
    },
    {
      "indent": 3,
      "text": "[The rest of this section is NEW material] The threat that VRRP authentication is intended to prevent is an attacker arranging to be the VRRP master. This would be done by joining the group (probably multiple times), gagging the master and then electing oneself master. Such a node could then direct traffic in arbitrary undesirable ways.",
      "ja": "VRRP認証を防止することを意図している脅威はVRRPマスターであることが配置攻撃である[このセクションの残りの部分は、新しい材料です]。これは、マスターを吐き気、その後、自分のマスターを選出、グループ（おそらく複数回）参加して行われます。このようなノードは、任意の望ましくない方法でトラフィックを指示できます。"
    },
    {
      "indent": 3,
      "text": "However, it is not necessary for an attacker to be the VRRP master to do this. An attacker can do similar kinds of damage to the network by forging ARP packets or (on switched networks) fooling the switch VRRP authentication offers no real protection against these attacks.",
      "ja": "攻撃者はこれを行うにはVRRPマスターするためにしかし、それは必要ありません。攻撃者は、ARPパケットを鍛造するか、これらの攻撃に対しては、実際の保護を提供していないスイッチのVRRP認証をだます（スイッチドネットワーク上の）ネットワークへの損傷の同様の種類を行うことができます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, authentication makes VRRP networks very brittle in the face of misconfiguration. Consider what happens if two nodes are configured with different passwords. Each will reject messages from the other and therefore both will attempt to be master. This creates substantial network instability.",
      "ja": "残念ながら、認証が設定ミスの顔にVRRPのネットワークは非常にもろくなります。 2つのノードが異なるパスワードが設定されている場合は何が起こるか考えてみましょう。それぞれ、他からのメッセージを拒否しますので、両方のマスターにしようとします。これはかなりのネットワークが不安定を作成します。"
    },
    {
      "indent": 3,
      "text": "This set of cost/benefit tradeoffs suggests that VRRP authentication is a bad idea, since the incremental security benefit is marginal but the incremental risk is high. This judgment should be revisited if the current set of non-VRRP threats are removed.",
      "ja": "コスト/利益のトレードオフのこのセットは、増分セキュリティ上の利点が限界ですが、増分リスクが高いので、VRRPの認証は、悪い考えであることを示唆しています。非VRRP脅威の現在のセットが削除される場合には、この判断は再検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgments",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is heavily based on a note written by Ran Atkinson in 1997. That note was written after the IAB Security Workshop held in early 1997, based on input from everyone at that workshop. Some of the specific text above was taken from Ran's original document, and some of that text was taken from an email message written by Fred Baker. The other primary source for this document is specific comments received from Steve Bellovin. Early review of this document was done by Lisa Dusseault and Mark Schertler. Other useful comments were received from Bill Fenner, Ned Freed, Lawrence Greenfield, Steve Kent, Allison Mankin and Kurt Zeilenga.",
      "ja": "この文書は、多額のノートがそのワークショップでみんなからの入力に基づいて、初期の1997年に開催されたIABセキュリティワークショップの後に書かれたことが1997年に蘭アトキンソンによって書かれたノートに基づいています。特定のテキストの一部は、上記の蘭の原稿から採取し、そのテキストの一部は、フレッド・ベイカーによって書かれた電子メールメッセージから取られました。この文書の他の主要な供給源は、スティーブBellovin氏から受け取った特定のコメントです。このドキュメントの初期のレビューはリサDusseaultとマークSchertlerによって行われました。他の有用なコメントはビルフェナー、ネッドフリード、ローレンス・グリーンフィールド、スティーブ・ケント、アリソンマンキンとクルトZeilengaから受け取りました。"
    },
    {
      "indent": 0,
      "text": "8. Normative References",
      "section_title": true,
      "ja": "8.引用規格"
    },
    {
      "indent": 3,
      "text": "[AH] Kent, S. and R. Atkinson, \"IP Authentication Header\", RFC 2402, November 1998.",
      "ja": "[AH]ケント、S.とR.アトキンソン、 \"IP認証ヘッダー\"、RFC 2402、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[DNSSEC] Eastlake, D., \"Domain Name System Security Extensions\", RFC 2535, March 1999.",
      "ja": "[DNSSEC]イーストレイク、D.、 \"ドメインネームシステムのセキュリティ拡張機能\"、RFC 2535、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[ENCOPT] Tso, T., \"Telnet Data Encryption Option\", RFC 2946, September, 2000.",
      "ja": "[ENCOPT] TSO、T.、 \"Telnetのデータ暗号化オプション\"、RFC 2946、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[ESP] Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998.",
      "ja": "[ESP]ケント、S.とR.アトキンソン、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 2406、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[GSS] Linn, J., \"Generic Security Services Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[GSS]リン、J.、 \"ジェネリックセキュリティサービスアプリケーションプログラムインタフェースバージョン2、アップデート1\"、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"HyperText Transfer Protocol\", RFC 2616, June 1999.",
      "ja": "[HTTP]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル\"、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[HTTPTLS] Rescorla, E., \"HTTP over TLS\", RFC 2818, May 2000.",
      "ja": "[HTTPTLS]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[HMAC] Madson, C. and R. Glenn, \"The Use of HMAC-MD5-96 within ESP and AH\", RFC 2403, November 1998.",
      "ja": "[HMAC] Madson、C.とR.グレン、 \"ESPおよびAH内のHMAC-MD5-96の使用\"、RFC 2403、1998年11月。"
    },
    {
      "indent": 3,
      "text": "KERBEROS] Kohl, J. and C. Neuman, \"The Kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "KERBEROS]コールズ、J.及びC.ノイマン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[OTP] Haller, N., Metz, C., Nesser, P. and M. Straw, \"A One-Time Password System\", STD 61, RFC 2289, February 1998.",
      "ja": "[OTP]ハラー、N.、メス、C.、Nesser、P.とM.わら、 \"ワンタイムパスワードシステム\"、STD 61、RFC 2289、1998年2月。"
    },
    {
      "indent": 3,
      "text": "[PHOTURIS] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[PHOTURIS]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Polk, W., Ford, W. and D. Solo, \"Internet X.509 \"Public Key Infrastructure Certificate and Certificate Restoration List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[PKIX] Housley氏、R.、ポーク、W.、フォード、W.およびD.ソロ、「インターネットX.509 \"公開鍵暗号基盤証明書と証明修復リスト（CRL）プロフィール\"、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2223] Postel J. and J. Reynolds, \"Instructions to RFC Authors\", RFC 2223, October 1997.",
      "ja": "[RFC-2223]ポステルJ.およびJ.レイノルズ、 \"RFC作者への指示\"、RFC 2223、1997年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2505] Lindberg, G., \"Anti-Spam Recommendations for SMTP MTAs\", BCP 30, RFC 2505, February 1999.",
      "ja": "[RFC-2505]リンドバーグ、G.、 \"SMTP MTAのアンチスパムの提言\"、BCP 30、RFC 2505、1999年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2821] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 2821, April 2001.",
      "ja": "[RFC-2821] Klensin、J.、 \"簡易メール転送プロトコル\"、RFC 2821、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[SASL] Myers, J., \"Simple Authentication and Security Layer (SASL)\", RFC 2222, October 1997.",
      "ja": "[SASL]マイヤーズ、J.、 \"簡易認証セキュリティー層（SASL）\"、RFC 2222、1997年10月。"
    },
    {
      "indent": 3,
      "text": "[SPKI] Ellison, C., Frantz, B., Lampson, B., Rivest, R., Thomas, B. and T. Ylonen, \"SPKI Certificate Theory\", RFC 2693, September 1999.",
      "ja": "【SPKI]エリソン、C.、フランツ、B.、Lampson、B.、リベスト、R.、トーマス、B.及びT. Ylonenと、 \"SPKI証明理論\"、RFC 2693、1999年9月。"
    },
    {
      "indent": 3,
      "text": "[SSH] Ylonen, T., \"SSH - Secure Login Connections Over the Internet\", 6th USENIX Security Symposium, p. 37-42, July 1996.",
      "ja": "[SSH] Ylonenと、T.、 \"SSH  - インターネットを介したセキュアなログインの接続\"、第六USENIXセキュリティシンポジウム、P。 37-42、1996年7月。"
    },
    {
      "indent": 3,
      "text": "[SASLSMTP] Myers, J., \"SMTP Service Extension for Authentication\", RFC 2554, March 1999.",
      "ja": "[SASLSMTP]マイヤーズ、J.、 \"認証のためのSMTPサービス拡張子\"、RFC 2554、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[STARTTLS] Hoffman, P., \"SMTP Service Extension for Secure SMTP over Transport Layer Security\", RFC 3207, February 2002.",
      "ja": "[STARTTLS]ホフマン、P.、 \"トランスポート層セキュリティの安全なSMTPのためのSMTPサービス拡張子\"、RFC 3207、2002年2月。"
    },
    {
      "indent": 3,
      "text": "[S-HTTP] Rescorla, E. and A. Schiffman, \"The Secure HyperText Transfer Protocol\", RFC 2660, August 1999.",
      "ja": "[S-HTTP]レスコラ、E.、およびA.シフマン、 \"セキュアハイパーテキスト転送プロトコル\"、RFC 2660、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[S/MIME] Ramsdell, B., Editor, \"S/MIME Version 3 Message Specification\", RFC 2633, June 1999.",
      "ja": "[S / MIME] Ramsdell、B.、エディタ、 \"S / MIMEバージョン3メッセージ仕様\"、RFC 2633、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[TELNET] Postel, J. and J. Reynolds, \"Telnet Protocol Specification\", STD 8, RFC 854, May 1983.",
      "ja": "[TELNET]ポステル、J.、およびJ.レイノルズ、 \"テルネットプロトコル仕様\"、STD 8、RFC 854、1983年5月。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[TLSEXT] Blake-Wilson, S., Nystrom, M., Hopwood, D. and J. Mikkelsen, \"Transport Layer Security (TLS) Extensions\", RFC 3546, May 2003.",
      "ja": "[TLSEXT]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.とJ.ミケルセン、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 3546、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[TCPSYN] \"TCP SYN Flooding and IP Spoofing Attacks\", CERT Advisory CA-1996-21, 19 September 1996, CERT. http://www.cert.org/advisories/CA-1996-21.html",
      "ja": "[TCPSYN] \"TCP SYNフラッドとIPスプーフィング攻撃\"、CERT勧告CA-1996から1921年、1996年9月19日、CERT。 http://www.cert.org/advisories/CA-1996-21.html"
    },
    {
      "indent": 3,
      "text": "[UPGRADE] Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\", RFC 2817, May 2000.",
      "ja": "[アップグレード] Khare、R.およびS.ローレンス、 \"HTTP / 1.1内でTLSへのアップグレード\"、RFC 2817、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[URL] Berners-Lee, T., Masinter, M. and M. McCahill, \"Uniform Resource Locators (URL)\", RFC 1738, December 1994.",
      "ja": "[URL]バーナーズ=リー、T.、Masinter、M.とM. McCahill、 \"ユニフォームリソースロケータ（URL）\"、RFC 1738、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[VRRP] Knight, S., Weaver, D., Whipple, D., Hinden, R., Mitzel, D., Hunt, P., Higginson, P., Shand, M. and A. Lindemn, \"Virtual Router Redundancy Protocol\", RFC 2338, April 1998.",
      "ja": "[VRRP]ナイト、S.、ウィーバー、D.、ウィップル、D.、HindenとR.、Mitzel、D.、ハント、P.、ヒギンソン、P.、シャンド、M.及びA. Lindemn、「仮想ルータ冗長プロトコル」、RFC 2338、1998年4月。"
    },
    {
      "indent": 0,
      "text": "9. Informative References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 3,
      "text": "[DDOS] \"Denial-Of-Service Tools\" CERT Advisory CA-1999-17, 28 December 1999, CERT http://www.cert.org/advisories/CA-1999-17.html",
      "ja": "[DDOS] \"サービス拒否ツール\" CERT勧告CA-1999から17、1999年12月28日、CERT http://www.cert.org/advisories/CA-1999-17.html"
    },
    {
      "indent": 3,
      "text": "[EKE] Bellovin, S., Merritt, M., \"Encrypted Key Exchange: Password-based protocols secure against dictionary attacks\", Proceedings of the IEEE Symposium on Research in Security and Privacy, May 1992.",
      "ja": "[EKE] Bellovin氏、S.、メリット、M.、「暗号化鍵交換：辞書攻撃に対して安全なパスワードベースのプロトコル」、セキュリティとプライバシー、1992年5月の研究上のIEEEシンポジウム。"
    },
    {
      "indent": 3,
      "text": "[IDENT] St. Johns, M. and M. Rose, \"Identification Protocol\", RFC 1414, February 1993.",
      "ja": "[IDENT]セントジョンズ、M.とM.ローズ、 \"識別プロトコル\"、RFC 1414、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[INTAUTH] Haller, N. and R. Atkinson, \"On Internet Authentication\", RFC 1704, October 1994.",
      "ja": "[INTAUTH]ハラー、N.とR.アトキンソン、 \"インターネット認証について\"、RFC 1704、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[IPSPPROB] Bellovin, S. M., \"Problem Areas for the IP Security Protocols\", Proceedings of the Sixth Usenix UNIX Security Symposium, July 1996.",
      "ja": "[IPSPPROB] Bellovin氏、S. M.、 \"IPセキュリティプロトコルの問題領域\"、第六のUsenix UNIXセキュリティシンポジウム、1996年7月の議事。"
    },
    {
      "indent": 3,
      "text": "[KLEIN] Klein, D.V., \"Foiling the Cracker: A Survey of and Improvements to Password Security\", 1990.",
      "ja": "[KLEIN]クライン、D.V.、 \"クラッカーFoiling：パスワードセキュリティへの調査と改善を\"、1990年。"
    },
    {
      "indent": 3,
      "text": "[NNTP] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC 977, February 1986.",
      "ja": "[NNTP]カンター、B.およびP.ラプスリー、 \"ネットワークニュース転送プロトコル\"、RFC 977、1986年2月。"
    },
    {
      "indent": 3,
      "text": "[POP] Myers, J. and M. Rose, \"Post Office Protocol - Version 3\", STD 53, RFC 1939, May 1996.",
      "ja": "[POP]マイヤーズ、J.とM.ローズ、 \"ポストオフィスプロトコル - バージョン3\"、STD 53、RFC 1939、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[SEQNUM] Morris, R.T., \"A Weakness in the 4.2 BSD UNIX TCP/IP Software\", AT&T Bell Laboratories, CSTR 117, 1985.",
      "ja": "[SEQNUM]モリス、R.T.、 \"4.2 BSD UNIX TCP / IPソフトウェアで弱さ\"、AT＆Tベル研究所、CSTR 117、1985。"
    },
    {
      "indent": 3,
      "text": "[SOAP] Box, D., Ehnebuske, D., Kakivaya, G., Layman, A., Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., \"Simple Object Access Protocol (SOAP) 1.1\", May 2000.",
      "ja": "[SOAP]ボックス、D.、Ehnebuske、D.、Kakivaya、G.、素人、A.、Mendelsoh、N.、ニールセン、H.、Thatte、S.、ワイナー、D.、「シンプルオブジェクトアクセスプロトコル（SOAP ）1.1\" 、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[SPEKE] Jablon, D., \"Strong Password-Only Authenticated Key Exchange\", Computer Communication Review, ACM SIGCOMM, vol. 26, no. 5, pp. 5-26, October 1996.",
      "ja": "[SPEKE] Jablon、D.、 \"強力なパスワードのみによる認証鍵交換\"、コンピュータコミュニケーションレビュー、ACM SIGCOMM、巻。 26、ありません。 5頁5-26、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[SRP] Wu T., \"The Secure Remote Password Protocol\", ISOC NDSS Symposium, 1998.",
      "ja": "[SRP]呉T.、 \"セキュアリモートパスワードプロトコル\"、ISOC NDSSシンポジウム、1998。"
    },
    {
      "indent": 3,
      "text": "[USEIPSEC] Bellovin, S., \"Guidelines for Mandating the Use of IPsec\", Work in Progress.",
      "ja": "[USEIPSEC] Bellovin氏、S.、 \"IPsecのの使用を義務付けるためのガイドライン\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[WEP] Borisov, N., Goldberg, I., Wagner, D., \"Intercepting Mobile Communications: The Insecurity of 802.11\", http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf",
      "ja": "[WEP]ボリソフ、N.、ゴールドバーグ、I.、ワグナー、D.、 \"インターセプトモバイルコミュニケーションズ：802.11の不安\"、http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document is about security considerations.",
      "ja": "この全体のドキュメントは、セキュリティ上の考慮事項についてです。"
    },
    {
      "indent": 0,
      "text": "Appendix A.",
      "ja": "付録A."
    },
    {
      "indent": 3,
      "text": "IAB Members at the time of this writing",
      "ja": "この記事の執筆時点でのIABメンバー"
    },
    {
      "indent": 3,
      "text": "Harald Alvestrand Ran Atkinson Rob Austein Fred Baker Leslie Daigle Steve Deering Sally Floyd Ted Hardie Geoff Huston Charlie Kaufman James Kempf Eric Rescorla Mike St. Johns",
      "ja": "ハラルドAlvestrandはアトキンソンロブAusteinとフレッド・ベイカーレスリーDaigle氏スティーブデアリングサリーフロイドテッドハーディージェフ・ヒューストンチャーリー・カウフマンジェームス・ケンプ、エリックレスコラマイク・セントジョンズ蘭"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2439 Alvin Drive Mountain View, CA 94043",
      "ja": "エリックレスコラRTFM、Inc.の2439アルビンドライブマウンテンビュー、CA 94043"
    },
    {
      "indent": 3,
      "text": "Phone: (650)-320-8549 EMail: ekr@rtfm.com",
      "ja": "電話：（650）-320-8549 Eメール：ekr@rtfm.com"
    },
    {
      "indent": 3,
      "text": "Brian Korver Xythos Software, Inc. 77 Maiden Lane, 6th Floor San Francisco, CA, 94108",
      "ja": "ブライアン・コーバーのXythos Software社77メイデン・レーン、6階サンフランシスコ、CA、94108"
    },
    {
      "indent": 3,
      "text": "Phone: (415)-248-3800 EMail: briank@xythos.com",
      "ja": "電話：（415）-248-3800 Eメール：briank@xythos.com"
    },
    {
      "indent": 3,
      "text": "Internet Architecture Board IAB EMail: iab@iab.org",
      "ja": "インターネットアーキテクチャ委員会IAB Eメール：iab@iab.org"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}