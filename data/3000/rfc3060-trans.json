{
  "title": {
    "text": "RFC 3060 - Policy Core Information Model -- Version 1 Specification",
    "ja": "RFC 3060 - 方針コア情報モデル - バージョン1つの仕"
  },
  "number": 3060,
  "created_at": "2019-10-22 07:51:15.074782+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           B. Moore\nRequest for Comments: 3060                                           IBM\nCategory: Standards Track                                    E. Ellesson\n                                                         LongBoard, Inc.\n                                                            J. Strassner\n                                                           A. Westerinen\n                                                           Cisco Systems\n                                                           February 2001",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Policy Core Information Model -- Version 1 Specification",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document presents the object-oriented information model for representing policy information developed jointly in the IETF Policy Framework WG and as extensions to the Common Information Model (CIM) activity in the Distributed Management Task Force (DMTF). This model defines two hierarchies of object classes: structural classes representing policy information and control of policies, and association classes that indicate how instances of the structural classes are related to each other. Subsequent documents will define mappings of this information model to various concrete implementations, for example, to a directory that uses LDAPv3 as its access protocol.",
      "ja": "この文書は、IETFポリシーフレームワークWGにし、分散管理タスクフォース（DMTF）で共通情報モデル（CIM）の活動への拡張として共同開発したポリシー情報を表現するためのオブジェクト指向の情報モデルを提示します。ポリシー情報と構造ク​​ラスのインスタンスが互いにどのように関連しているかを示すポリシー、および関連クラスの制御を表す構造クラス：このモデルは、2つのオブジェクトクラスの階層を定義します。以降の文書は、例えば、そのアクセスプロトコルとしてのLDAPv3を使用したディレクトリに、様々な具体的な実装にこの情報モデルのマッピングを定義します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction.................................................... 4\n2. Modeling Policies............................................... 5\n   2.1. Policy Scope............................................... 8\n   2.2. Declarative versus Procedural Model........................ 8\n3. Overview of the Policy Core Information Model.................. 10\n4. Inheritance Hierarchies for the Policy Core Information Model.. 13\n   4.1. Implications of CIM Inheritance........................... 15\n5. Details of the Model........................................... 15",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   5.1. Reusable versus Rule-Specific Conditions and Actions...... 15\n   5.2. Roles..................................................... 17\n   5.2.1. Roles and Role Combinations............................. 17\n   5.2.2. The PolicyRoles Property................................ 21\n   5.3. Local Time and UTC Time in PolicyTimePeriodConditions..... 21\n   5.4. CIM Data Types............................................ 23\n   5.5. Comparison between CIM and LDAP Class Specifications...... 24\n6. Class Definitions.............................................. 25\n   6.1. The Abstract Class \"Policy\"............................... 25\n   6.1.1. The Property \"CommonName (CN)\".......................... 26\n   6.1.2. The Multi-valued Property \"PolicyKeywords\".............. 26\n   6.1.3. The Property \"Caption\" (Inherited from ManagedElement).. 27\n   6.1.4. The Property \"Description\" (Inherited from\n          ManagedElement)......................................... 27\n   6.2. The Class \"PolicyGroup\"................................... 27\n   6.3. The Class \"PolicyRule\".................................... 29\n   6.3.1. The Property \"Enabled\".................................. 31\n   6.3.2. The Property \"ConditionListType\"........................ 31\n   6.3.3. The Property \"RuleUsage\"................................ 31\n   6.3.4. The Property \"Priority\"................................. 32\n   6.3.5. The Property \"Mandatory\"................................ 32\n   6.3.6. The Property \"SequencedActions\"......................... 33\n   6.3.7. The Multi-valued Property \"PolicyRoles\"................. 33\n   6.4. The Abstract Class \"PolicyCondition\"...................... 34\n   6.5. The Class \"PolicyTimePeriodCondition\"..................... 36\n   6.5.1. The Property \"TimePeriod\"............................... 38\n   6.5.2. The Property \"MonthOfYearMask\".......................... 39\n   6.5.3. The Property \"DayOfMonthMask\"........................... 39\n   6.5.4. The Property \"DayOfWeekMask\"............................ 40\n   6.5.5. The Property \"TimeOfDayMask\"............................ 41\n   6.5.6. The Property \"LocalOrUtcTime\"........................... 42\n   6.6. The Class \"VendorPolicyCondition\"......................... 42\n   6.6.1. The Multi-valued Property \"Constraint\".................. 43\n   6.6.2. The Property \"ConstraintEncoding\"....................... 43\n   6.7. The Abstract Class \"PolicyAction\"......................... 44\n   6.8. The Class \"VendorPolicyAction\"............................ 45\n   6.8.1. The Multi-valued Property \"ActionData\".................. 45\n   6.8.2. The Property \"ActionEncoding\"........................... 46\n   6.9. The Class \"PolicyRepository\".............................. 46\n7. Association and Aggregation Definitions........................ 46\n   7.1. Associations.............................................. 47\n   7.2. Aggregations.............................................. 47\n   7.3. The Abstract Aggregation \"PolicyComponent................. 47\n   7.4. The Aggregation \"PolicyGroupInPolicyGroup\"................ 47\n   7.4.1. The Reference \"GroupComponent\".......................... 48\n   7.4.2. The Reference \"PartComponent\"........................... 48\n   7.5. The Aggregation \"PolicyRuleInPolicyGroup\"................. 48\n   7.5.1. The Reference \"GroupComponent\".......................... 49",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   7.5.2. The Reference \"PartComponent\"........................... 49\n   7.6. The Aggregation \"PolicyConditionInPolicyRule\"............. 49\n   7.6.1. The Reference \"GroupComponent\".......................... 50\n   7.6.2. The Reference \"PartComponent\"........................... 50\n   7.6.3. The Property \"GroupNumber\".............................. 50\n   7.6.4. The Property \"ConditionNegated\"......................... 51\n   7.7. The Aggregation \"PolicyRuleValidityPeriod\"................ 51\n   7.7.1. The Reference \"GroupComponent\".......................... 52\n   7.7.2. The Reference \"PartComponent\"........................... 52\n   7.8. The Aggregation \"PolicyActionInPolicyRule\"................ 52\n   7.8.1. The Reference \"GroupComponent\".......................... 53\n   7.8.2. The Reference \"PartComponent\"........................... 53\n   7.8.3. The Property \"ActionOrder\".............................. 53\n   7.9. The Abstract Association \"PolicyInSystem\"................. 54\n   7.10. The Weak Association \"PolicyGroupInSystem\"............... 55\n   7.10.1. The Reference \"Antecedent\"............................. 55\n   7.10.2. The Reference \"Dependent\".............................. 55\n   7.11. The Weak Association \"PolicyRuleInSystem\"................ 56\n   7.11.1. The Reference \"Antecedent\"............................. 56\n   7.11.2. The Reference \"Dependent\".............................. 56\n   7.12. The Association \"PolicyConditionInPolicyRepository\"...... 56\n   7.12.1. The Reference \"Antecedent\"............................. 57\n   7.12.2. The Reference \"Dependent\".............................. 57\n   7.13. The Association \"PolicyActionInPolicyRepository\"......... 57\n   7.13.1. The Reference \"Antecedent\"............................. 58\n   7.13.2. The Reference \"Dependent\".............................. 58\n   7.14. The Aggregation \"PolicyRepositoryInPolicyRepository\"..... 58\n   7.14.1. The Reference \"GroupComponent\"......................... 58\n   7.14.2. The Reference \"PartComponent\".......................... 59\n8. Intellectual Property.......................................... 59\n9. Acknowledgements............................................... 59\n10. Security Considerations....................................... 60\n11. References.................................................... 62\n12. Authors' Addresses............................................ 64\n13. Appendix A:  Class Identification in a Native CIM\n    Implementation................................................ 65\n   13.1. Naming Instances of PolicyGroup and PolicyRule........... 65\n   13.1.1. PolicyGroup's CIM Keys................................. 65\n   13.1.2. PolicyRule's CIM Keys.................................. 66\n   13.2. Naming Instances of PolicyCondition and Its Subclasses... 67\n   13.2.1. PolicyCondition's CIM Keys............................. 69\n   13.3. Naming Instances of PolicyAction and Its Subclasses...... 71\n   13.4. Naming Instances of PolicyRepository..................... 72\n   13.5. Role of the CreationClassName Property in Naming......... 73\n   13.6. Object References........................................ 73\n14. Appendix B:  The Core Policy MOF.............................. 75\n15. Full Copyright Statement..................................... 100",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document presents the object-oriented information model for representing policy information currently under joint development in the IETF Policy Framework WG and as extensions to the Common Information Model (CIM) activity in the Distributed Management Task Force (DMTF). This model defines two hierarchies of object classes: structural classes representing policy information and control of policies, and association classes that indicate how instances of the structural classes are related to each other. Subsequent documents will define mappings of this information model to various concrete implementations, for example, to a directory that uses LDAPv3 as its access protocol. The components of the CIM schema are available via the following URL: http://www.dmtf.org/spec/cims.html [1].",
      "ja": "この文書は、IETFポリシーフレームワークWGでの共同開発中と分散管理タスクフォース（DMTF）で共通情報モデル（CIM）の活動への拡張として、現在のポリシー情報を表現するためのオブジェクト指向の情報モデルを提示します。ポリシー情報と構造ク​​ラスのインスタンスが互いにどのように関連しているかを示すポリシー、および関連クラスの制御を表す構造クラス：このモデルは、2つのオブジェクトクラスの階層を定義します。以降の文書は、例えば、そのアクセスプロトコルとしてのLDAPv3を使用したディレクトリに、様々な具体的な実装にこの情報モデルのマッピングを定義します。 CIMスキーマの構成要素は、以下のURLを介して利用可能である：http://www.dmtf.org/spec/cims.html [1]。"
    },
    {
      "indent": 3,
      "text": "The policy classes and associations defined in this model are sufficiently generic to allow them to represent policies related to anything. However, it is expected that their initial application in the IETF will be for representing policies related to QoS (DiffServ and IntServ) and to IPSec. Policy models for application-specific areas such as these may extend the Core Model in several ways. The preferred way is to use the PolicyGroup, PolicyRule, and PolicyTimePeriodCondition classes directly, as a foundation for representing and communicating policy information. Then, specific subclasses derived from PolicyCondition and PolicyAction can capture application-specific definitions of conditions and actions of policies.",
      "ja": "このモデルで定義されたポリシーのクラスと関連は、彼らが何に関連するポリシーを表現することを可能にするために十分に一般的なものです。しかし、IETFでの最初のアプリケーションがQoS（DiffServのとIntServの）へとIPSecに関連するポリシーを表すためであることが期待されます。このようなアプリケーション固有の領域のポリシーモデルは、いくつかの方法でコアモデルを拡張することができます。好ましい方法は、ポリシー情報を表すと通信するための基礎として、直接のPolicyGroup、PolicyRuleの、及びPolicyTimePeriodConditionクラスを使用することです。その後、PolicyConditionとPolicyAction由来の特定のサブクラスが条件とポリシーのアクションのアプリケーション固有の定義をキャプチャすることができます。"
    },
    {
      "indent": 3,
      "text": "Two subclasses, VendorPolicyCondition and VendorPolicyAction, are also included in this document, to provide a standard extension mechanism for vendor-specific extensions to the Policy Core Information Model.",
      "ja": "2つのサブクラス、VendorPolicyConditionとVendorPolicyActionは、また方針コア情報モデルにベンダー固有の拡張のための標準拡張メカニズムを提供するために、本文書に含まれています。"
    },
    {
      "indent": 3,
      "text": "This document fits into the overall framework for representing, deploying, and managing policies being developed by the Policy Framework Working Group. It traces its origins to work that was originally done for the Directory-enabled Networks (DEN) specification, reference [5]. Work on the DEN specification by the DEN Ad-Hoc Working Group itself has been completed. Further work to standardize the models contained in it will be the responsibility of selected working groups of the CIM effort in the Distributed Management Task Force (DMTF). DMTF standardization of the core policy model is the responsibility of the SLA Policy working group in the DMTF.",
      "ja": "この文書では、代表展開、およびポリシーフレームワークワーキンググループによって開発されたポリシーを管理するための全体的な枠組みに収まります。それはそれは、もともとディレクトリ対応ネットワークのために行われた仕事にその起源をトレース（DEN）仕様、リファレンス[5]。 DENアドホック・ワーキンググループ自体によってDEN仕様の作業は完了しました。その中に含まれているモデルを標準化するための更なる作業は、Distributed Management Task Force（DMTF）でのCIMの努力の選択ワーキンググループの責任になります。コアポリシーモデルのDMTF標準化は、DMTFでのSLA政策ワーキンググループの責任です。"
    },
    {
      "indent": 3,
      "text": "This document is organized in the following manner:",
      "ja": "この文書は、次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o Section 2 provides a general overview of policies and how they are modeled.",
      "ja": "O部2は、ポリシーの一般的な概要を提供し、彼らがどのようにモデル化されています。"
    },
    {
      "indent": 3,
      "text": "o Section 3 presents a high-level overview of the classes and associations comprising the Policy Core Information Model.",
      "ja": "O部3は、ポリシーコア情報モデルを備えたクラスと関連の高レベルの概要を示します。"
    },
    {
      "indent": 3,
      "text": "o The remainder of the document presents the detailed specifications for each of the classes and associations.",
      "ja": "O文書の残りの部分は、クラスと関連のそれぞれについて、詳細な仕様を提示します。"
    },
    {
      "indent": 3,
      "text": "o Appendix A overviews naming for native CIM implementations. Other mappings, such as LDAPv3, will have their own naming mechanisms.",
      "ja": "ネイティブのCIM実装のための命名O付録Aの概要。などのLDAPv3のような他のマッピングは、独自の命名メカニズムを持っています。"
    },
    {
      "indent": 3,
      "text": "o Appendix B reproduces the DMTF's Core Policy MOF specification.",
      "ja": "O付録BはDMTFの基本方針MOF仕様を再現します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119, reference [3].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈されるべきで、文献[3]。"
    },
    {
      "indent": 0,
      "text": "2. Modeling Policies",
      "section_title": true,
      "ja": "2.モデル化方針"
    },
    {
      "indent": 3,
      "text": "The classes comprising the Policy Core Information Model are intended to serve as an extensible class hierarchy (through specialization) for defining policy objects that enable application developers, network administrators, and policy administrators to represent policies of different types.",
      "ja": "方針コア情報モデルを含むクラスは、異なるタイプのポリシーを表すために、アプリケーション開発者、ネットワーク管理者、およびポリシー管理者を有効にするポリシー・オブジェクトを定義するための（特殊を介して）、拡張可能なクラス階層として機能するように意図されています。"
    },
    {
      "indent": 3,
      "text": "One way to think of a policy-controlled network is to first model the network as a state machine and then use policy to control which state a policy-controlled device should be in or is allowed to be in at any given time. Given this approach, policy is applied using a set of policy rules. Each policy rule consists of a set of conditions and a set of actions. Policy rules may be aggregated into policy groups. These groups may be nested, to represent a hierarchy of policies.",
      "ja": "ポリシー制御ネットワークを考える一つの方法は、最初のモデルにステートマシンとしてネットワークであり、次いで、ポリシー制御装置は、でなければならない、または任意の時点でであることが許容されている状態を制御するためにポリシーを使用します。このアプローチを考えると、ポリシーは、ポリシールールのセットを使用して適用されます。各ポリシールールは、条件のセットとアクションのセットで構成されています。ポリシールールはポリシー・グループに集約することができます。これらのグループは、ポリシーの階層を表現するために、入れ子にすることができます。"
    },
    {
      "indent": 3,
      "text": "The set of conditions associated with a policy rule specifies when the policy rule is applicable. The set of conditions can be expressed as either an ORed set of ANDed sets of condition statements or an ANDed set of ORed sets of statements. Individual condition statements can also be negated. These combinations are termed, respectively, Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF) for the conditions.",
      "ja": "ポリシールールが適用されるときに、ポリシールールに関連付けられている条件のセットを指定します。条件のセットは、条件文の論理積集合の論理和集合または文の論理和集合の論理積集合のいずれかとして表すことができます。個々の条件文も否定することができます。これらの組み合わせは、条件のために、それぞれ、論理和標準フォーム（DNF）と連言標準形（CNF）と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "If the set of conditions associated with a policy rule evaluates to TRUE, then a set of actions that either maintain the current state of the object or transition the object to a new state may be executed.",
      "ja": "ポリシールールに関連付けられた一組の条件がTRUEと評価された場合、オブジェクトの現在の状態を維持するか、または新しい状態にオブジェクトを移行いずれかことアクションのセットを実行するようにしてもよいです。"
    },
    {
      "indent": 3,
      "text": "For the set of actions associated with a policy rule, it is possible to specify an order of execution, as well as an indication of whether the order is required or merely recommended. It is also possible to indicate that the order in which the actions are executed does not matter.",
      "ja": "ポリシールールに関連付けられたアクションのセットのために、実行の順序、ならびに順序が必要または単に推奨されているかどうかの指示を指定することが可能です。アクションが実行される順序は重要ではないことを示すことも可能です。"
    },
    {
      "indent": 3,
      "text": "Policy rules themselves can be prioritized. One common reason for doing this is to express an overall policy that has a general case with a few specific exceptions.",
      "ja": "ポリシー自体は優先順位を付けることができるルール。これを行うための1つの一般的な理由は、いくつかの特定の例外を除いて、一般的なケースを持って、全体的な方針を表明することにあります。"
    },
    {
      "indent": 3,
      "text": "For example, a general QoS policy rule might specify that traffic originating from members of the engineering group is to get Bronze Service. A second policy rule might express an exception: traffic originating from John, a specific member of the engineering group, is to get Gold Service. Since traffic originating from John satisfies the conditions of both policy rules, and since the actions associated with the two rules are incompatible, a priority needs to be established. By giving the second rule (the exception) a higher priority than the first rule (the general case), a policy administrator can get the desired effect: traffic originating from John gets Gold Service, and traffic originating from all the other members of the engineering group gets Bronze Service.",
      "ja": "例えば、一般的なQoSポリシールールは、エンジニアリンググループのメンバーから発信されるトラフィックはブロンズサービスを取得することであることを指定できます。第2のポリシールールは例外を表現するかもしれません：ジョン、エンジニアリンググループの特定のメンバーから発信されるトラフィックは、ゴールドサービスを得ることです。トラフィックジョン由来するので、両方のポリシールールの条件を満足すると、2つのルールに関連付けられたアクションに互換性がないので、優先順位を確立する必要があります。二番目のルール（例外に）最初のルール（一般の場合）よりも高い優先順位を与えることによって、ポリシー管理者は、所望の効果を得ることができます：ジョンから発信されるトラフィックは、ゴールドサービスを取得し、トラフィックエンジニアリングの他のすべてのメンバーから発信しますグループはブロンズサービスを取得します。"
    },
    {
      "indent": 3,
      "text": "Policies can either be used in a stand-alone fashion or aggregated into policy groups to perform more elaborate functions. Stand-alone policies are called policy rules. Policy groups are aggregations of policy rules, or aggregations of policy groups, but not both. Policy groups can model intricate interactions between objects that have complex interdependencies. Examples of this include a sophisticated user logon policy that sets up application access, security, and reconfigures network connections based on a combination of user identity, network location, logon method and time of day. A policy group represents a unit of reusability and manageability in that its management is handled by an identifiable group of administrators and its policy rules would be consistently applied",
      "ja": "ポリシーは、どちらかのスタンドアロン方式で使用またはより精巧な機能を実行するためのポリシー・グループに集約することができます。スタンドアローンのポリシーは、ポリシールールと呼ばれています。ポリシーグループはポリシールールの集合体、またはポリシーグループの集計、両方ではないです。ポリシーグループは、複雑な相互依存性を持っているオブジェクト間の複雑な相互作用をモデル化することができます。この例では、アプリケーションへのアクセス、セキュリティを設定し、ユーザーのアイデンティティ、ネットワーク上の場所、ログオン方法や一日の時間の組み合わせに基づいて、ネットワーク接続を再構成、洗練されたユーザーのログオンポリシーが含まれます。その管理は、管理者とそのポリシールールの識別可能なグループによって処理されたポリシー・グループは、一貫して適用される再利用および管理の単位を表します。"
    },
    {
      "indent": 3,
      "text": "Stand-alone policies are those that can be expressed in a simple statement. They can be represented effectively in schemata or MIBs. Examples of this are VLAN assignments, simple YES/NO QoS requests, and IP address allocations. A specific design goal of this model is to support both stand-alone and aggregated policies.",
      "ja": "スタンドアローンのポリシーは、簡単な文で表現することができるものです。彼らは、スキーマまたはMIBの中で効果的に表現することができます。この例は、VLAN割り当て、シンプルなYES / NOのQoS要求、およびIPアドレスの割り当てです。このモデルの具体的な設計目標は、両方のスタンドアローンおよび集約ポリシーをサポートすることです。"
    },
    {
      "indent": 3,
      "text": "Policy groups and rules can be classified by their purpose and intent. This classification is useful in querying or grouping policy rules. It indicates whether the policy is used to motivate when or how an action occurs, or to characterize services (that can then be used, for example, to bind clients to network services). Describing each of these concepts in more detail, o Motivational Policies are solely targeted at whether or how a policy's goal is accomplished. Configuration and Usage Policies are specific kinds of Motivational Policies. Another example is the scheduling of file backup based on disk write activity from 8am to 3pm, M-F.",
      "ja": "ポリシー・グループおよびルールは、その目的や意図によって分類することができます。この分類は、照会またはポリシールールをグループ化する際に有用です。これは、ポリシーは（ネットワークサービスにクライアントをバインドするために、例えば、それはその後、使用することができます）、アクションが発生したどのようにするときややる気にさせる、またはサービスを特徴づけるために使用されているかどうかを示します。より詳細にこれらの概念のそれぞれを説明すると、Oモチベーションポリシーは、単に政策の目標が達成されているかどうか、またはどのようにターゲットとしています。構成と使用ポリシーは、モチベーション政策の具体的な種類があります。別の例は、午前8時から午後3時、M-Fにディスク書き込みアクティビティに基づいて、ファイルのバックアップのスケジューリングです。"
    },
    {
      "indent": 3,
      "text": "o Configuration Policies define the default (or generic) setup of a managed entity (for example, a network service). Examples of Configuration Policies are the setup of a network forwarding service or a network-hosted print queue.",
      "ja": "O構成ポリシーは、（例えば、ネットワーク・サービス）の管理エンティティの設定をデフォルト（または汎用）を定義します。構成ポリシーの例としては、ネットワークの転送サービスやネットワークホスト型のプリントキューの設定です。"
    },
    {
      "indent": 3,
      "text": "o Installation Policies define what can and cannot be put on a system or component, as well as the configuration of the mechanisms that perform the install. Installation policies typically represent specific administrative permissions, and can also represent dependencies between different components (e.g., to complete the installation of component A, components B and C must be previously successfully installed or uninstalled).",
      "ja": "Oインストールポリシーは、システムやコンポーネントだけでなく、インストールを実行するメカニズムの構成に置くことはできませんができるかを定義します。インストールポリシーは、典型的には、特定の管理権限を表し、また、（成分B及びCは、以前に正常にインストールまたはアンインストールする必要があり、成分Aのインストールを完了するために、例えば）異なるコンポーネント間の依存性を表すことができます。"
    },
    {
      "indent": 3,
      "text": "o Error and Event Policies. For example, if a device fails between 8am and 9pm, call the system administrator, otherwise call the Help Desk.",
      "ja": "Oエラーおよびイベントポリシー。例えば、デバイスは、午前8時から午後9時の間で障害が発生した場合、システム管理者を呼び出し、そうでない場合はヘルプデスクを呼び出します。"
    },
    {
      "indent": 3,
      "text": "o Usage Policies control the selection and configuration of entities based on specific \"usage\" data. Configuration Policies can be modified or simply re-applied by Usage Policies. Examples of Usage Policies include upgrading network forwarding services after a user is verified to be a member of a \"gold\" service group, or reconfiguring a printer to be able to handle the next job in its queue.",
      "ja": "O使用ポリシーは、特定の「使用」データに基づいて、エンティティの選択および構成を制御します。構成ポリシーを変更または単に使用ポリシーによって再適用することができます。使用ポリシーの例としては、ユーザが「ゴールド」のサービスグル​​ープのメンバーであることが確認された後にアップグレードネットワーク転送サービスを含む、またはそのキューの中の次のジョブを処理できるようにプリンタを再設定します。"
    },
    {
      "indent": 3,
      "text": "o Security Policies deal with verifying that the client is actually who the client purports to be, permitting or denying access to resources, selecting and applying appropriate authentication mechanisms, and performing accounting and auditing of resources.",
      "ja": "Oセキュリティポリシーは、許可または拒否リソースへのアクセスを、選択し、適切な認証メカニズムを適用し、資源の会計・監査を行うことにより、クライアントは、クライアントがあることを主張する人実際にあることを確認して対処します。"
    },
    {
      "indent": 3,
      "text": "o Service Policies characterize network and other services (not use them). For example, all wide-area backbone interfaces shall use a specific type of queuing.",
      "ja": "Oサービスポリシーは、ネットワークや他のサービスを（それらを使用していない）特徴づけます。例えば、すべての広域バックボーンインタフェースは、キューイングの特定のタイプを使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Service policies describe services available in the network. Usage policies describe the particular binding of a client of the network to services available in the network.",
      "ja": "サービスポリシーは、ネットワーク内で利用可能なサービスについて説明します。使用ポリシーは、ネットワーク内で利用可能なサービスへのネットワークのクライアントの特定の結合を説明します。"
    },
    {
      "indent": 3,
      "text": "These categories are represented in the Policy Core Information Model by special values defined for the PolicyKeywords property of the abstract class Policy.",
      "ja": "これらのカテゴリは抽象クラスポリシーのPolicyKeywordsプロパティに定義された特別な値で方針コア情報モデルで表現されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Policy Scope",
      "section_title": true,
      "ja": "2.1. ポリシー適用範囲"
    },
    {
      "indent": 3,
      "text": "Policies represent business goals and objectives. A translation must be made between these goals and objectives and their realization in the network. An example of this could be a Service Level Agreement (SLA), and its objectives and metrics (Service Level Objectives, or SLOs), that are used to specify services that the network will provide for a given client. The SLA will usually be written in high-level business terminology. SLOs address more specific metrics in support of the SLA. These high-level descriptions of network services and metrics must be translated into lower-level, but also vendor-and device-independent specifications. The Policy Core Information Model classes are intended to serve as the foundation for these lower-level, vendor- and device-independent specifications.",
      "ja": "ポリシーは、ビジネスの目標と目的を表しています。翻訳は、これらの目標と目的、およびネットワークにおけるその実現の間でなされなければなりません。この例では、ネットワークは、特定のクライアントのために提供するサービスを指定するために使用される、サービスレベル契約（SLA）、およびその目的やメトリクス（サービスレベル目標、またはのSLO）である可能性があります。 SLAは、通常、高レベルのビジネス用語で書かれます。 SLOには、SLAのサポートで、より具体的な指標を扱います。ネットワークサービスとメトリックのこれらの高レベルの説明は、低レベルに変換するだけでなく、ベンダーやデバイスに依存しない仕様にする必要があります。方針コア情報モデルクラスは、これらの低レベル、ベンダーやデバイスに依存しない仕様のための基盤として機能することを目的としています。"
    },
    {
      "indent": 3,
      "text": "It is envisioned that the definition of the Policy Core Informational Model in this document is generic in nature and is applicable to Quality of Service (QoS), to non-QoS networking applications (e.g., DHCP and IPSec), and to non-networking applications (e.g., backup policies, auditing access, etc.).",
      "ja": "この文書の方針コア情報モデルの定義は本質的に汎用的であり、非QoSのネットワークアプリケーション（例えば、DHCPおよびIPSec）、および非ネットワーキング・アプリケーションにするには、サービス品質（QoS）にも適用可能であることが想定されます（例えば、バックアップポリシー、監査アクセス、など）。"
    },
    {
      "indent": 0,
      "text": "2.2. Declarative versus Procedural Model",
      "section_title": true,
      "ja": "2.2. 手続きモデル対の宣言"
    },
    {
      "indent": 3,
      "text": "The design of the Policy Core Information Model is influenced by a declarative, not procedural, approach. More formally, a declarative language is used to describe relational and functional languages. Declarative languages describe relationships between variables in terms of functions or inference rules, to which the interpreter or compiler can apply a fixed algorithm in order to produce a result. An imperative (or procedural) language specifies an explicit sequence of steps to follow in order to produce a result.",
      "ja": "方針コア情報モデルの設計は、手続き上、宣言型でないアプローチに影響されます。より正式に、宣言型言語は、リレーショナルと関数型言語を記述するために使用されます。宣言型言語はこれにインタープリタまたはコンパイラが結果を生成するために、固定されたアルゴリズムを適用することができ、機能または推論ルールの点で変数間の関係を記述する。命令的（または手続き）言語は、結果を生成するために従うべき手順の明示的な順序を指定します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that this information model does not rule out the use of procedural languages. Rather, it recognizes that both declarative as well as procedural languages can be used to implement policy. This information model is better viewed as being declarative because the sequence of steps for doing the processing of declarative statements tends to be left to the implementer. However, we have provided the option of expressing the desired order of action execution in this policy information model, and for expressing whether the order is mandatory or not. In addition, rather than trying to define algorithms or sets of instructions or steps that must be followed by a policy rule, we instead define a set of modular building blocks and relationships that can be used in a declarative or procedural fashion to define policies.",
      "ja": "この情報モデルは、手続き型言語の使用を排除しないことに注意することが重要です。むしろ、それは、宣言だけでなく、手続き型言語の両方がポリシーを実装するために使用することができることを認識しています。この情報モデルは、より良い、宣言文の処理を行うための一連のステップは、実装者に委ねられる傾向があるため、宣言型であるものとして見られています。しかし、我々は、注文が必須であるかどうかを表現するため、このポリシー情報モデルにおけるアクション実行の所望の順序を表現するためのオプションを提供しています。また、むしろ政策ルールが続かなければなりませんアルゴリズムまたは命令またはステップのセットを定義しようとするよりも、我々は代わりにポリシーを定義するために、宣言や手続きの方法で使用することができますモジュラービルディングブロックと関係のセットを定義します。"
    },
    {
      "indent": 3,
      "text": "Compare this to a strictly procedural model. Taking such an approach would require that we specify the condition testing sequence, and the action execution sequence, in the policy repository itself. This would, indeed, constrain the implementer. This is why the policy model is characterized as a declarative one. That is, the information model defines a set of attributes, and a set of entities that contain these attributes. However, it does NOT define either the algorithm to produce a result using the attributes or an explicit sequence of steps to produce a result.",
      "ja": "厳密に手続きモデルにこれを比較してください。このようなアプローチを取ることは、我々はポリシー・リポジトリ自体に、条件のテスト・シーケンス、およびアクションの実行順序を指定する必要があります。これは、確かに、実装を制約するでしょう。ポリシーモデルは、宣言型の一つとして特徴付けられるのはこのためです。つまり、情報モデルは、属性のセット、およびこれらの属性を含むエンティティのセットを定義します。しかし、それは属性や結果を生成するための手順の明示的なシーケンスを使用して結果を生成するためのアルゴリズムのいずれかを定義していません。"
    },
    {
      "indent": 3,
      "text": "There are several design considerations and trade-offs to make in this respect.",
      "ja": "この点で作るには、いくつかの設計上の考慮事項とトレードオフがあります。"
    },
    {
      "indent": 3,
      "text": "1. On the one hand, we would like a policy definition language to be reasonably human-friendly for ease of definitions and diagnostics. On the other hand, given the diversity of devices (in terms of their processing capabilities) which could act as policy decision points, we would like to keep the language somewhat machine-friendly. That is, it should be relatively simple to automate the parsing and processing of the language in network elements. The approach taken is to provide a set of classes and attributes that can be combined in either a declarative or procedural approach to express policies that manage network elements and services. The key point is to avoid trying to standardize rules or sets of steps to be followed in defining a policy. These must be left up to an implementation. Interoperability is achieved by standardizing the building blocks that are used to represent policy data and information.",
      "ja": "1.一方で、我々は合理的に人間に優しいの定義および診断を容易にするためであることをポリシー定義言語をしたいと思います。一方、ポリシー決定ポイントとして作用することができる（その処理能力の点で）デバイスの多様性を考えると、我々はやや機械に優しい言葉を維持したいと思います。つまり、ネットワーク要素内の言語の構文解析および処理を自動化するために比較的簡単であるべきです。取られたアプローチは、ネットワーク要素およびサービスを管理ポリシーを表現するために、宣言または手続き型アプローチのいずれかで組み合わせることができるクラスと属性のセットを提供することです。キーポイントは、ルールやポリシーを定義する際に従うべき手順のセットを標準化しようとしないようにすることです。これらは実装に任されている必要があります。相互運用性は、ポリシーデータと情報を表すために使用されるビルディングブロックを標準化することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "2. An important decision to make is the semantic style of the representation of the information.",
      "ja": "作る2.重要な決定は、情報の表現の意味スタイルです。"
    },
    {
      "indent": 6,
      "text": "The declarative approach that we are describing falls short of being a \"true\" declarative model. Such a model would also specify the algorithms used to combine the information and policy rules to achieve particular behavior. We avoid specifying algorithms for the same reason that we avoid specifying sets of steps to be followed in a policy rule. However, the design of the information model more closely follows that of a declarative language, and may be easier to understand if such a conceptual model is used. This leads to our third point, acknowledging a lack of \"completeness\" and instead relying on presenting information that the policy processing entity will work with.",
      "ja": "私たちが記述されている宣言的なアプローチは、「真」の宣言型モデルであることを下回ります。このようなモデルは、特定の動作を実現するための情報とポリシールールを組み合わせるために使用するアルゴリズムを指定します。我々は政策ルールに従うべき手順のセットを指定しないよう、同じ理由のためのアルゴリズムを指定することは避けてください。しかし、情報モデルのデザインは、より密接に宣言型言語のことを、以下、そのような概念モデルが使用されている場合は理解しやすいかもしれません。これは、「完全」の欠如を認め、代わりにポリシー処理エンティティと連携するという情報を提示するに頼って、私たちの三点目につながります。"
    },
    {
      "indent": 3,
      "text": "3. It is important to control the complexity of the specification, trading off richness of expression of data in the core information model for ease of implementation and use. It is important to acknowledge the collective lack of experience in the field regarding policies to control and manage network services and hence avoid the temptation of aiming for \"completeness\". We should instead strive to facilitate definition of a set of common policies that customers require today (e.g., VPN and QoS) and allow migration paths towards supporting complex policies as customer needs and our understanding of these policies evolve with experience. Specifically, in the context of the declarative style language discussed above, it is important to avoid having full blown predicate calculus as the language, as it would render many important problems such as consistency checking and policy decision point algorithms intractable. It is useful to consider a reasonably constrained language from these perspectives.",
      "ja": "3.実装と使いやすさのためにコア情報モデルでのデータの表現の豊かさをトレードオフ、仕様の複雑さを制御することが重要です。制御およびネットワークサービスを管理するので、「完全性」を目指すの誘惑を避けるために、政策に関する分野での経験集団的不足を認識することが重要です。私たちは、代わりに、顧客が今日（例えば、VPNおよびQoS）を必要と共通のポリシーセットの定義を容易にし、顧客のニーズとこれらのポリシーの我々の理解のような複雑な政策の経験と進化を支援に向けて移行パスを許可するように努力すべきです。それは、このような一貫性をチェックし、ポリシー決定ポイントアルゴリズム難治性など、多くの重要な問題をレンダリングうとして具体的には、前述の宣言型スタイル言語の文脈では、言語として本格的な述語計算を避けることが重要です。これらの観点から合理的に制約言語を考慮することが有用です。"
    },
    {
      "indent": 3,
      "text": "The Policy Core Information Model strikes a balance between complexity and lack of power by using the well understood logical concepts of Disjunctive Normal Form and Conjunctive Normal Form for combining simple policy conditions into more complex ones.",
      "ja": "方針コア情報モデルは、より複雑なものに、単純なポリシー条件を組み合わせるための論理和標準形と連言標準形のよく理解論理的な概念を使用することによって複雑さとパワーの不足との間のバランスを打ちます。"
    },
    {
      "indent": 0,
      "text": "3. Overview of the Policy Core Information Model",
      "section_title": true,
      "ja": "方針コア情報モデルの3の概要"
    },
    {
      "indent": 3,
      "text": "The following diagram provides an overview of the five central classes comprising the Policy Core Information Model, their associations to each other, and their associations to other classes in the overall CIM model. Note that the abstract class Policy and the two extension classes VendorPolicyCondition and VendorPolicyAction are not shown.",
      "ja": "次の図は、全体的なCIMモデルの他のクラスへのポリシーコア情報モデル、互いの団体、およびその関連性を備えた5つの中央のクラスの概要を説明します。抽象クラスポリシーと2つの拡張クラスVendorPolicyConditionとVendorPolicyActionが示されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "NOTE: For cardinalities, \"*\" is an abbreviation for \"0..n\".",
      "ja": "注：カーディナリティについては、「*」「0..N」の略称です。"
    },
    {
      "indent": 9,
      "text": "                      +-----------+\n                      |  System   |\n   .....              +--^-----^--+       .....\n   .   .                1.    1.          .   .\n  *.(a).*                .(b)  .(c)      *.(d).*\n+--v---v---------+       .     .        +-v---v------------+\n|  PolicyGroup   <........     .        | PolicyRepository |\n|                | w *         .        |                  |\n+------^---------+             .        +-----^---------^--+\n      *.                       .         0..1 .    0..1 .\n       .(e)                    .              .(f)      .(g)\n      *.                       .              .         .\n+------v------+ w *            .              .         .\n|             <.................              .         .\n| PolicyRule  |                               .         .\n|             |                               .         .\n|             |                               .         .\n|             <........................       .         .\n|             |*      (h)             .       .         .\n|             |                       .       .         .\n|             |                       .       .         .\n|             |                       .       .         .\n|             |                       .       .         .\n|             |                       .       .         .\n|             |                       .       .         .\n|             |                       .*      .*        .\n|             |             +---------v-------v--+      .\n|             |             |  PolicyCondition   |      .\n|             |            *+--------------------+      .\n|             |       (i)             ^                 .\n|             <..............         I                 .\n|             |*            .         I                 .\n|             |             .*        ^                 .\n|             |        +----v----------------------+    .\n|             |        | PolicyTimePeriodCondition |    .\n|             |        +---------------------------+    .\n|             |       (j)                               .\n|             <.........................                .\n|             |*                       .                .\n|             |                        .*               .\n|             |             +----------v---------+*     .\n|             |             | PolicyAction       <.......\n+-------------+             +--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1. Overview of the Core Policy Classes and Relationships",
      "ja": "基本方針のクラスとの関係の図1.概要"
    },
    {
      "indent": 3,
      "text": "In this figure the boxes represent the classes, and the dotted arrows represent the associations. The following associations appear:",
      "ja": "この図ではボックスはクラスを表し、点線の矢印は関連付けを表します。次のアソシエーションが表示されます。"
    },
    {
      "indent": 3,
      "text": "(a) PolicyGroupInPolicyGroup",
      "ja": "（A）PolicyGroupInPolicyGroup"
    },
    {
      "indent": 3,
      "text": "(b) PolicyGroupInSystem",
      "ja": "（B）PolicyGroupInSystem"
    },
    {
      "indent": 3,
      "text": "(c) PolicyRuleInSystem",
      "ja": "（C）PolicyRuleInSystem"
    },
    {
      "indent": 3,
      "text": "(d) PolicyRepositoryInPolicyRepository",
      "ja": "（D）PolicyRepositoryInPolicyRepository"
    },
    {
      "indent": 3,
      "text": "(e) PolicyRuleInPolicyGroup",
      "ja": "（e）にPolicyRuleInPolicyGroup"
    },
    {
      "indent": 3,
      "text": "(f) PolicyConditionInPolicyRepository",
      "ja": "（F）PolicyConditionInPolicyRepository"
    },
    {
      "indent": 3,
      "text": "(g) PolicyActionInPolicyRepository",
      "ja": "（G）PolicyActionInPolicyRepository"
    },
    {
      "indent": 3,
      "text": "(h) PolicyConditionInPolicyRule",
      "ja": "（H）PolicyConditionInPolicyRule"
    },
    {
      "indent": 3,
      "text": "(i) PolicyRuleValidityPeriod",
      "ja": "（I）PolicyRuleValidityPeriod"
    },
    {
      "indent": 3,
      "text": "(j) PolicyActionInPolicyRule",
      "ja": "（J）PolicyActionInPolicyRule"
    },
    {
      "indent": 3,
      "text": "An association always connects two classes. The \"two\" classes may, however, be the same class, as is the case with the PolicyGroupInPolicyGroup association, which represents the recursive containment of PolicyGroups in other PolicyGroups. The PolicyRepositoryInPolicyRepository association is recursive in the same way.",
      "ja": "協会は、常に2つのクラスを結びます。他のPolicyGroupsにPolicyGroupsの再帰的封じ込めを表すPolicyGroupInPolicyGroup協会、の場合と同様に「二」のクラスは、しかし、同じクラスであってもよいです。 PolicyRepositoryInPolicyRepository協会は、同じように再帰的です。"
    },
    {
      "indent": 3,
      "text": "An association includes cardinalities for each of the related classes. These cardinalities indicate how many instances of each class may be related to an instance of the other class. For example, the PolicyRuleInPolicyGroup association has the cardinality range \"*' (that is, \"0..n\") for both the PolicyGroup and PolicyRule classes. These ranges are interpreted as follows:",
      "ja": "会合は、関連するクラスの各々に対するカーディナリティを含みます。これらのカーディナリティは、各クラスの多くのインスタンスが他のクラスのインスタンスに関連することができる方法を示しています。例えば、PolicyRuleInPolicyGroup会合はのPolicyGroupとPolicyRuleのクラスの両方のためのカーディナリティ範囲「*」を（すなわち、 『0..N』）を有するこれらの範囲は、以下のように解釈されます："
    },
    {
      "indent": 3,
      "text": "o The \"*\" written next to PolicyGroup indicates that a PolicyRule may be related to no PolicyGroups, to one PolicyGroup, or to more than one PolicyGroup via the PolicyRuleInPolicyGroup association. In other words, a PolicyRule may be contained in no PolicyGroups, in one PolicyGroups, or in more than one PolicyGroup.",
      "ja": "O「*」次のPolicyGroupに書き込まれたPolicyRuleは、1つのPolicyGroupに、又はPolicyRuleInPolicyGroupアソシエーションを介して複数のPolicyGroupに、無PolicyGroupsに関連し得ることを示しています。換言すれば、のPolicyRuleはないPolicyGroupsで一PolicyGroupsで、または複数のPolicyGroupに含まれていてもよいです。"
    },
    {
      "indent": 3,
      "text": "o The \"*\" written next to PolicyRule indicates that a PolicyGroup may be related to no PolicyRules, to one PolicyRule, or to more than one PolicyRule via the PolicyRuleInPolicyGroup association. In other words, a PolicyGroup may contain no PolicyRules, one PolicyRule, or more than one PolicyRule.",
      "ja": "O「*」次のPolicyRuleに書き込まれたPolicyGroupが1たPolicyRuleに、又はPolicyRuleInPolicyGroupアソシエーションを介して複数のPolicyRuleに、無PolicyRulesに関連し得ることを示しています。換言すれば、のPolicyGroupにはPolicyRules一つのPolicyRule、又は複数のPolicyRuleを含まなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "The \"w\" written next to the PolicyGroupInSystem and PolicyRuleInSystem indicates that these are what CIM terms \"aggregations with weak references\", or more briefly, \"weak aggregations\". A weak aggregation is simply an indication of a naming scope. Thus these two aggregations indicate that an instance of a PolicyGroup or PolicyRule is named within the scope of a System object. A weak aggregation implicitly has the cardinality 1..1 at the end opposite the 'w'.",
      "ja": "PolicyGroupInSystemとPolicyRuleInSystemの隣に書かれた「W」は、これらがより簡単にどのようなCIMの用語「弱い参照を持つ集計」、または、「弱い集計」であることを示しています。弱い凝集は単に命名範囲の指標です。従ってこれら二つの集計は、のPolicyGroupまたはPolicyRuleのインスタンスは、システムオブジェクトの範囲内で命名されたことを示します。弱い凝集が暗黙「W」反対側の端部にカーディナリティ1..1を有しています。"
    },
    {
      "indent": 3,
      "text": "The associations shown in Figure 1 are discussed in more detail in Section 7.",
      "ja": "図1に示される関連付けは、第7節で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "4. Inheritance Hierarchies for the Policy Core Information Model",
      "section_title": true,
      "ja": "方針コア情報モデル4.継承階層"
    },
    {
      "indent": 3,
      "text": "The following diagram illustrates the inheritance hierarchy for the core policy classes:",
      "ja": "次の図は、コアポリシークラスの継承階層を示しています。"
    },
    {
      "indent": 6,
      "text": "ManagedElement (abstract)\n |\n +--Policy (abstract)\n |  |\n |  +---PolicyGroup\n |  |\n |  +---PolicyRule\n |  |\n |  +---PolicyCondition (abstract)\n |  |          |\n |  |          +---PolicyTimePeriodCondition\n |  |          |\n |  |          +---VendorPolicyCondition\n |  |\n |  +---PolicyAction (abstract)\n |             |\n |             +---VendorPolicyAction\n |\n +--ManagedSystemElement (abstract)\n    |\n    +--LogicalElement (abstract)\n       |\n       +--System (abstract)\n          |\n          +--AdminDomain (abstract)\n             |\n             +---PolicyRepository",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2. Inheritance Hierarchy for the Core Policy Classes",
      "ja": "基本方針のクラスの継承階層2.図"
    },
    {
      "indent": 3,
      "text": "ManagedElement, ManagedSystemElement, LogicalElement, System, and AdminDomain are defined in the CIM schema [1]. These classes are not discussed in detail in this document.",
      "ja": "管理対象要素、ManagedSystemElement、LogicalElement、システム、およびいるAdminDomainは、CIMスキーマで定義されている[1]。これらのクラスは、この文書で詳しく説明されていません。"
    },
    {
      "indent": 3,
      "text": "In CIM, associations are also modeled as classes. For the Policy Core Information Model, the inheritance hierarchy for the associations is as follows:",
      "ja": "CIMでは、協会はまた、クラスとしてモデル化されています。次のように方針コア情報モデルについては、団体の継承階層は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "[unrooted]\n |\n +---PolicyComponent (abstract)\n |   |\n |   +---PolicyGroupInPolicyGroup\n |   |\n |   +---PolicyRuleInPolicyGroup\n |   |\n |   +---PolicyConditionInPolicyRule\n |   |\n |   +---PolicyRuleValidityPeriod\n |   |\n |   +---PolicyActionInPolicyRule\n |\n +---Dependency (abstract)\n |   |\n |   +---PolicyInSystem (abstract)\n |       |\n |       +---PolicyGroupInSystem\n |       |\n |       +---PolicyRuleInSystem\n |       |\n |       +---PolicyConditionInPolicyRepository\n |       |\n |       +---PolicyActionInPolicyRepository\n |\n +---Component (abstract)\n     |\n     +---SystemComponent\n         |\n         +---PolicyRepositoryInPolicyRepository",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3. Inheritance Hierarchy for the Core Policy Associations",
      "ja": "基本方針アソシエーションの図3.継承階層"
    },
    {
      "indent": 3,
      "text": "The Dependency, Component, and SystemComponent associations are defined in the CIM schema [1], and are not discussed further in this document.",
      "ja": "依存性、コンポーネント、およびSystemComponentの関連付けは、CIMスキーマ[1]で定義されており、この文書でさらに説明されません。"
    },
    {
      "indent": 0,
      "text": "4.1. Implications of CIM Inheritance",
      "section_title": true,
      "ja": "4.1.  CIMの継承の意味"
    },
    {
      "indent": 3,
      "text": "From the CIM schema, both properties and associations are inherited to the Policy classes. For example, the class ManagedElement is referenced in the associations Dependency, Statistics and MemberOfCollection. And, the Dependency association is in turn referenced in the DependencyContext association. At this very abstract and high level in the inheritance hierarchy, the number of these associations is very small and their semantics are quite general.",
      "ja": "CIMスキーマからは、両方の性質との関連付けはポリシークラスに継承されます。たとえば、クラスの管理対象要素は、団体の依存関係、統計とMemberOfCollectionで参照されています。そして、依存関係の関連はDependencyContext協会で参照順番です。継承階層のこの非常に抽象的で高いレベルでは、これらの団体の数は非常に少なく、その意味は非常に一般的です。"
    },
    {
      "indent": 3,
      "text": "Many of these inherited associations convey additional semantics that are not needed in understanding the Policy Core Information Model. In fact, they are defined as OPTIONAL in the CIM Schema - since their cardinality is \"0..n\" on all references. The PCIM document specifically discusses what is necessary to support and instantiate. For example, through subclassing of the Dependency association, the exact Dependency semantics in PCIM are described.",
      "ja": "これらの継承された団体の多くは、方針コア情報モデルを理解する上で必要とされていない追加の意味を伝えます。彼らのカーディナリティは「0..Nは、」すべての参照上にあるため - 実際に、彼らは、CIMスキーマでオプションとして定義されています。 PCIM文書は、特にサポートしてインスタンス化するためには何が必要かを説明します。例えば、依存性関連のサブクラスを介して、PCIMの正確な依存性セマンティクスが記載されています。"
    },
    {
      "indent": 3,
      "text": "So, one may wonder what to do with these other inherited associations. The answer is \"ignore them unless you need them\". You would need them to describe additional information and semantics for policy data. For example, it may be necessary to capture statistical data for a PolicyRule (either for the rule in a repository or for when it is executing in a policy system). Some examples of statistical data for a rule are the number of times it was downloaded, the number of times its conditions were evaluated, and the number of times its actions were executed. (These types of data would be described in a subclass of CIM_StatisticalInformation.) In these cases, the Statistics association inherited from ManagedElement to PolicyRule may be used to describe the tie between an instance of a PolicyRule and the set of statistics for it.",
      "ja": "だから、1は、これらの他の継承された団体をどうするか疑問に思うことがあります。答えは「あなたがそれらを必要としない限り、それらを無視」です。あなたは、ポリシーデータのための追加情報や意味を記述するためにそれらを必要とします。例えば、（リポジトリ内のルールのか、ポリシーシステムで実行された場合のいずれか）PolicyRuleのための統計データを取得する必要があるかもしれません。ルールの統計データのいくつかの例は、それがダウンロードされた回数、その条件が評価された回数、およびそのアクションが実行された回数です。 （データのこれらのタイプはCIM_StatisticalInformationのサブクラスに記載されるであろう。）これらの場合には、統計協会はPolicyRuleのに管理対象要素から継承されたPolicyRuleのインスタンスとの統計のセットとの間の結束を説明するために使用されてもよいです。"
    },
    {
      "indent": 0,
      "text": "5. Details of the Model",
      "section_title": true,
      "ja": "モデルの詳細5."
    },
    {
      "indent": 3,
      "text": "The following subsections discuss several specific issues related to the Policy Core Information Model.",
      "ja": "以下のサブセクションでは、ポリシーコア情報モデルに関連するいくつかの特定の問題を議論します。"
    },
    {
      "indent": 0,
      "text": "5.1. Reusable versus Rule-Specific Conditions and Actions",
      "section_title": true,
      "ja": "5.1. ルール固有の条件とアクション対再利用可能"
    },
    {
      "indent": 3,
      "text": "Policy conditions and policy actions can be partitioned into two groups: ones associated with a single policy rule, and ones that are reusable, in the sense that they may be associated with more than one policy rule. Conditions and actions in the first group are termed \"rule-specific\" conditions and actions; those in the second group are characterized as \"reusable\".",
      "ja": "単一のポリシールールに関連付けられているもの、そして彼らは、複数のポリシールールに関連付けすることができるという意味で、再利用可能なもの：ポリシーの条件とポリシーアクションは二つのグループに分割することができます。第1グループの条件とアクションは、「ルール固有」の条件とアクションと呼ばれます。第2グループのものは「再利用可能」として特徴付けられます。"
    },
    {
      "indent": 3,
      "text": "It is important to understand that the difference between a rule-specific condition or action and a reusable one is based on the intent of the policy administrator for the condition or action, rather than on the current associations in which the condition or action participates. Thus a reusable condition or action (that is, one that a policy administrator has created to be reusable) may at some point in time be associated with exactly one policy rule, without thereby becoming rule-specific.",
      "ja": "ルール固有の条件またはアクションと、再利用可能なものの違いは、条件またはアクションのためではなく、条件またはアクションが参加している現在の団体のポリシー管理者の意図に基づいていることを理解することが重要です。したがって、再利用可能な条件またはアクション（すなわち、ポリシー管理者が再利用できるように作成されたものである）は、時間のある時点で、これによりルール固有になることなく、正確に1つのポリシールールに関連付けられてもよいです。"
    },
    {
      "indent": 3,
      "text": "There is no inherent difference between a rule-specific condition or action and a reusable one. There are, however, differences in how they are treated in a policy repository. For example, it's natural to make the access permissions for a rule-specific condition or action identical to those for the rule itself. It's also natural for a rule-specific condition or action to be removed from the policy repository at the same time the rule is. With reusable conditions and actions, on the other hand, access permissions and existence criteria must be expressible without reference to a policy rule.",
      "ja": "ルール固有の条件またはアクションと、再利用可能な1の間には固有の違いはありません。これらはポリシー・リポジトリでどのように扱われるかをの違いは、しかし、があります。例えば、それはルール自体のものと同一のルール固有の条件またはアクションのためのアクセス許可を作成するのが自然です。ルール固有の条件またはアクションはルールがあると同時に、ポリシーリポジトリから削除することも自然なことです。再利用可能な条件とアクションでは、一方で、アクセス許可と存在基準は、ポリシールールを参照することなく表現可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The preceding paragraph does not contain an exhaustive list of the ways in which reusable and rule-specific conditions should be treated differently. Its purpose is merely to justify making a semantic distinction between rule-specific and reusable, and then reflecting this distinction in the policy model itself.",
      "ja": "前項の規定は、再利用可能とルール固有の条件が異なって扱われるべき方法の完全なリストが含まれていません。その目的は、ポリシー・モデル自体でこの区別を反映し、ルール固有の再利用可能な、との間の意味的な区別を行うことを正当化することだけです。"
    },
    {
      "indent": 3,
      "text": "An issue is highlighted by reusable and rule-specific policy conditions and policy actions: the lack of a programmatic capability for expressing complex constraints involving multiple associations. Taking PolicyCondition as an example, there are two aggregations to look at. PolicyConditionInPolicyRule has the cardinality * at both ends, and PolicyConditionInPolicyRepository has the cardinality * at the PolicyCondition end, and [0..1] at the PolicyRepository end.",
      "ja": "複数の団体が関与する複雑な制約を表現するためのプログラムの能力の欠如：問題は、再利用可能とルール固有のポリシー条件と政策措置によって強調されています。例としてPolicyConditionを取って、見て2件の集計があります。 PolicyConditionInPolicyRuleは両端*基数を有し、PolicyConditionInPolicyRepositoryはPolicyCondition端で*基数を有し、[0..1] PolicyRepository終わりに。"
    },
    {
      "indent": 3,
      "text": "Globally, these cardinalities are correct. However, there's more to the story, which only becomes clear if we examine the cardinalities separately for the two cases of a rule-specific PolicyCondition and a reusable one.",
      "ja": "世界的には、これらのカーディナリティが正しいです。しかし、我々はルール固有のPolicyConditionと再利用可能な1の2例に対して個別にカーディナリティを調べる場合にのみ明確になる話、ではありません。"
    },
    {
      "indent": 3,
      "text": "For a rule-specific PolicyCondition, the cardinality of PolicyConditionInPolicyRule at the PolicyRule end is [1..1], rather than [0..n] (recall that * is an abbreviation for [0..n]), since the condition is unique to one policy rule. And the cardinality of PolicyConditionInPolicyRepository at the PolicyRepository end is [0..0], since the condition is not in the \"re-usable\" repository. This is OK, since these are both subsets of the specified cardinalities.",
      "ja": "ルール固有PolicyConditionため、PolicyRuleの端PolicyConditionInPolicyRuleの基数は条件ので、むしろ[0..N]（*は[0..N]の略語であるリコール）より、[1..1]であります1つのポリシールールに固有のものです。状態が「再利用可能」のリポジトリにないのでPolicyRepository端におけるPolicyConditionInPolicyRepositoryの基数は、[0..0]です。これらは、指定されたカーディナリティの両方のサブセットであるため、これはOKです。"
    },
    {
      "indent": 3,
      "text": "For a reusable PolicyCondition, however, the cardinality of PolicyConditionInPolicyRepository at the PolicyRepository end is [1..1], since the condition must be in the repository. And, the cardinality of PolicyConditionInPolicyRule at the PolicyRule end is [0..n]. This last point is important: a reusable PolicyCondition may be associated with 0, 1, or more than 1 PolicyRules, via exactly the same association PolicyConditionInPolicyRule that binds a rule-specific condition to its PolicyRule.",
      "ja": "条件は、リポジトリ内になければならないため、再利用可能なPolicyConditionのために、しかし、PolicyRepository端におけるPolicyConditionInPolicyRepositoryの基数は、[1..1]です。そして、PolicyRuleの端でPolicyConditionInPolicyRuleのカーディナリティは[0..N]です。この最後の点は重要である：再使用可能なPolicyCondition、そのPolicyRuleのにルール特定の条件に結合する全く同じアソシエーションPolicyConditionInPolicyRule介して、0、1、又は1以上PolicyRulesに関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "Currently the only way to document constraints of this type is textually. More formal methods for documenting complex constraints are needed.",
      "ja": "現在、このタイプの制約を文書化する唯一の方法は、テキストです。複雑な制約を文書化するためのより正式な方法が必要とされています。"
    },
    {
      "indent": 0,
      "text": "5.2. Roles",
      "section_title": true,
      "ja": "5.2. 役割"
    },
    {
      "indent": 0,
      "text": "5.2.1. Roles and Role Combinations",
      "section_title": true,
      "ja": "5.2.1. 役割と役割の組み合わせ"
    },
    {
      "indent": 3,
      "text": "The concept of role is central to the design of the entire Policy Framework. The idea behind roles is a simple one. Rather than configuring, and then later having to update the configuration of, hundreds or thousands (or more) of resources in a network, a policy administrator assigns each resource to one or more roles, and then specifies the policies for each of these roles. The Policy Framework is then responsible for configuring each of the resources associated with a role in such a way that it behaves according to the policies specified for that role. When network behavior must be changed, the policy administrator can perform a single update to the policy for a role, and the Policy Framework will ensure that the necessary configuration updates are performed on all the resources playing that role.",
      "ja": "役割の概念は全体のポリシーフレームワークの設計の中心です。役割の背後にある考え方は単純なものです。むしろ設定し、後でネットワークに数百またはリソースの何千もの（またはそれ以上）の構成を更新するより、ポリシー管理者は、1つ以上のロールに各リソースを割り当て、その後、これらの役割のそれぞれのポリシーを指定します。ポリシーフレームワークは、それがその役割のために指定されたポリシーに従って動作するような方法でロールに関連付けられたリソースのそれぞれを設定する責任があります。ネットワークの動作を変更しなければならない場合には、ポリシー管理者は、ロールのポリシーに単一の更新を行うことができ、およびポリシーフレームワークは、必要な設定のアップデートがその役割を果たしているすべてのリソース上で実行されていることを確認します。"
    },
    {
      "indent": 3,
      "text": "A more formal definition of a role is as follows:",
      "ja": "次のような役割のより正式な定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "A role is a type of attribute that is used to select one or more policies for a set of entities and/or components from among a much larger set of available policies.",
      "ja": "役割は、エンティティおよび/または使用可能なポリシーのはるかに大きいセットの中からコンポーネントのセットのための1つ以上のポリシーを選択するために使用される属性のタイプです。"
    },
    {
      "indent": 3,
      "text": "Roles can be combined together. Here is a formal definition of a \"role- combination\":",
      "ja": "ロールは一緒に組み合わせることができます。ここでは、「ロールベースの組み合わせ」の正式な定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "A role-combination is a set of attributes that are used to select one or more policies for a set of entities and/or components from among a much larger set of available policies. As the examples below illustrate, the selection process for a role combination chooses policies associated with the combination itself, policies associated with each of its sub-combinations, and policies associated with each of the individual roles in the role-combination.",
      "ja": "役割の組み合わせは、エンティティおよび/または使用可能なポリシーのはるかに大きいセットの中からコンポーネントのセットのための1つ以上のポリシーを選択するために使用されている属性のセットです。以下の例が示すように、ロールの組合せの選択プロセスは、組み合わせ自体に関連付けられたポリシー、そのサブコンビネーションの各々に関連付けられたポリシー、および役割組み合わせの個々の役割の各々に関連付けられたポリシーを選択します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that a role is more than an attribute. A role defines a particular function of an entity or component that can be used to identify particular behavior associated with that entity or component. This difference is critical, and is most easily understood by thinking of a role as a selector. When used in this manner, one role (or role-combination) selects a different set of policies than a different role (or role-combination) does.",
      "ja": "役割が属性を超えていることに注意することが重要です。役割は、そのエンティティまたはコンポーネントに関連付けられた特定の行動を識別するために使用することができるエンティティまたはコンポーネントの特定の機能を定義します。この違いは重要であり、かつ最も簡単セレクタとしての役割を考えて理解されています。このようにして使用される場合、ある役割（又は役割の組み合わせ）は、異なる役割（または役割の組み合わせ）よりも政策の異なるセットを選択します。"
    },
    {
      "indent": 3,
      "text": "Roles and role-combinations are especially useful in selecting which policies are applicable to a particular set of entities or components when the policy repository can store thousands or hundreds of thousands of policies. This use emphasizes the ability of the role (or role- combination) to select the small subset of policies that are applicable from a huge set of policies that are available.",
      "ja": "役割と役割の組み合わせは、ポリシーがポリシー・リポジトリは、数千またはポリシーの数十万人を保存することができますエンティティやコンポーネントの特定のセットに適用可能な選択に特に有用です。この使用は、利用可能なポリシーの巨大なセットから適用されたポリシーの小さなサブセットを選択するための役割（またはロールベースの組み合わせ）の能力を強調しています。"
    },
    {
      "indent": 3,
      "text": "An example will illustrate how role-combinations actually work. Suppose an installation has three roles defined for interfaces: \"Ethernet\", \"Campus\", and \"WAN\". In the Policy Repository, some policy rules could be associated with the role \"Ethernet\"; these rules would apply to all Ethernet interfaces, regardless of whether they were on the campus side or the WAN side. Other rules could be associated with the role-combination \"Campus\"+\"Ethernet\"; these rules would apply to the campus-side Ethernet interfaces, but not to those on the WAN side. Finally, a third set of rules could be associated with the role-combination \"Ethernet\"+\"WAN\"; these rules would apply to the WAN-side Ethernet interfaces, but not to those on the campus side. (The roles in a role-combination appear in alphabetical order in these examples, because that is how they appear in the information model.)",
      "ja": "例では、役割の組み合わせが実際にどのように機能するかを説明します。 「イーサネット」、「キャンパス」、および「WAN」：インストールがインターフェイス用に定義された3つの役割を持っていると仮定する。ポリシーリポジトリでは、いくつかのポリシールールは、ロール「イーサネット」に関連付けることができ、これらのルールは関係なく、キャンパス側またはWAN側にあったかどうかに、すべてのイーサネットインターフェイスに適用されます。他のルールは役割組み合わせ「キャンパス」+「イーサネット」に関連付けることができ、これらのルールはなく、WAN側のものに、キャンパス側イーサネットインターフェイスに適用されます。最後に、ルールの第三のセットは、役割組み合わせ「イーサネット」+「WAN」に関連付けられていることができます。これらのルールはなく、キャンパス側のものに、WAN側のイーサネットインターフェイスに適用されます。 （それは、彼らが情報モデルで表示する方法であるため、役割の組み合わせにおける役割は、これらの例では、アルファベット順に表示されます。）"
    },
    {
      "indent": 3,
      "text": "If we have a specific interface A that's associated with the role-combination \"Ethernet\"+\"WAN\", we see that it should have three categories of policy rules applied to it: those for the \"Ethernet\" role, those for the \"WAN\" role, and those for the role-combination \"Ethernet\"+\"WAN\". Going one step further, if interface B is associated with the role- combination \"branch-office\"+\"Ethernet\"+\"WAN\", then B should have seven categories of policy rules applied to it - those associated with the following role-combinations:",
      "ja": "「イーサネット」役割のもの、「WANのもの：私たちは役割組み合わせ「イーサネット」+「WAN」に関連付けられている特定のインターフェイスAを持っている場合、我々はそれがそれに適用されるポリシールールの三つのカテゴリーを持つべきであることを確認します「役割、および役割の組み合わせのため、これらの 『イーサネット』 +」WAN」。以下の役割の組み合わせに関連するもの - インタフェースBは、その後、Bがそれに適用されるポリシールールの7つのカテゴリを持っている必要があり、ロールベースの組み合わせ「ブランチ・オフィス」+「イーサネット」+「WAN」に関連付けられている場合、さらに一歩行きます："
    },
    {
      "indent": 6,
      "text": "o \"branch-office\" o \"Ethernet\" o \"WAN\" o \"branch-office\"+\"Ethernet\" o \"branch-office\"+\"WAN\" o \"Ethernet\"+\"WAN\" o \"branch-office\"+\"Ethernet\"+\"WAN\".",
      "ja": "「ブランチオフィスの」o「イーサネット」+「WAN」o「のブランチオフィス」+「WAN」+」o「のブランチオフィス」+「イーサネット」O「WAN」O「イーサネット」O O「ブランチオフィス」イーサネット \"+\" WAN」。"
    },
    {
      "indent": 3,
      "text": "In order to get all of the right policy rules for a resource like interface B, a PDP must expand the single role-combination it receives for B into this list of seven role-combinations, and then retrieve from the Policy Repository the corresponding seven sets of policy rules. Of course this example is unusually complicated: the normal case will involve expanding a two-role combination into three values identifying three sets of policy rules.",
      "ja": "インタフェースBなどのリソースのための適切な政策ルールのすべてを取得するためには、PDPは、それが7役割の組み合わせのこのリストにBのための受信シングルロールの組み合わせを展開する必要があり、その後、ポリシーリポジトリから対応する7セットを検索しますポリシールールの。もちろん、この例は非常に複雑です：通常の場合は、ポリシールールの三組を特定する三つの値に2-役割の組み合わせを拡大伴います。"
    },
    {
      "indent": 3,
      "text": "Role-combinations also help to simplify somewhat the problem of identifying conflicts between policy rules. With role-combinations, it is possible for a policy administrator to specify one set of policy rules for campus-side Ethernet interfaces, and a second set of policy rules for WAN-side Ethernet interfaces, without having to worry about conflicts between the two sets of rules. The policy administrator simply \"turns off\" conflict detection for these two sets of rules, by telling the policy management system that the roles \"Campus\" and \"WAN\" are incompatible with each other. This indicates that the role combination will never occur, and therefore conflicts will never occur. In some cases the technology itself might identify incompatible roles: \"Ethernet\" and \"FrameRelay\", for example. But for less precise terms like \"Campus\" and \"WAN\", the policy administrator must say whether they identify incompatible roles.",
      "ja": "役割組み合わせも幾分ポリシールール間の競合を識別するの問題を単純化するのに役立ちます。ポリシー管理者は2つのセットの間のコンフリクトを心配することなく、1つのキャンパス側イーサネットインターフェイスのポリシールールのセット、およびWAN側イーサネットインターフェイスのポリシールールの第2のセットを指定するための役割組み合わせで、それが可能ですルールの。ポリシー管理者は、単にロール「キャンパス」および「WAN」は相互に互換性のないポリシー管理システムに伝えることによって、ルールのこれら二組の競合検出を「オフにします」。これは、役割の組み合わせが発生することはありませんので、競合が発生しないことを示しています。 「イーサネット」および「フレームリレー」、例えば：いくつかのケースでは技術自体は、互換性のない役割を識別することがあります。しかし、「キャンパス」と「WAN」のようにそれほど厳密な条件のため、ポリシー管理者は、彼らが互換性のない役割を識別するかどうかを言わなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the policy administrator does this, there are three effects:",
      "ja": "ポリシー管理者がこれを行う場合には、3つの効果があります。"
    },
    {
      "indent": 3,
      "text": "1. If an interface has assigned to it a role-combination involving both \"Campus\" and \"WAN\", then the policy management system can flag it as an error.",
      "ja": "インタフェースは、ポリシー管理システムはエラーとしてフラグをすることができ、これに「キャンパス」および「WAN」の両方を含む役割組み合わせが割り当てられている場合1。"
    },
    {
      "indent": 3,
      "text": "2. If a policy rule is associated with a role-combination involving both \"Campus\" and \"WAN\", then the policy management system can flag it as an error.",
      "ja": "2.ポリシールールは、ポリシー管理システムはエラーとしてフラグをすることができ、「キャンパス」および「WAN」の両方を含むロールの組合せに関連付けられている場合。"
    },
    {
      "indent": 3,
      "text": "3. If the policy management system sees two policy rules, where one is tied to the role \"Campus\" (or to a role-combination that includes the role \"Campus\") and the other is tied to the role \"WAN\" (or to a role- combination that includes the role \"WAN\"), then the system does not need to look for conflicts between the two policy rules: because of the incompatible roles, the two rules cannot possibly conflict.",
      "ja": "3.ポリシー管理システムは、1つの役割「キャンパス」（またはロール「キャンパス」を含む役割組み合わせ）（および他のロール「WAN」に接続されているのか、に接続された2つのポリシールールを見る場合役割「WAN」）を含むロールベースの組み合わせに、システムは、2つのポリシールール間の競合を探す必要はありませんので、互換性のない役割の、二つの規則ができていない可能性が競合を。"
    },
    {
      "indent": 24,
      "text": "+-------------------+\n| Policy Repository |\n+-------------------+\n          V\n          V retrieval of policy\n          V\n     +---------+\n     | PDP/PEP |\n     +---------+\n          v\n          v application of policy\n          v\n  +----------------+\n  | Network Entity |\n  +----------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 4. Retrieval and Application of a Policy",
      "ja": "図4.検索とポリシーの適用"
    },
    {
      "indent": 6,
      "text": "Figure 4, which is introduced only as an example of how the Policy Framework might be implemented by a collection of network components, illustrates how roles operate within the Policy Framework. Because the distinction between them is not important to this discussion, the PDP and the PEP are combined in one box. The points illustrated here apply equally well, though, to an environment where the PDP and the PEP are implemented separately.",
      "ja": "唯一のポリシーフレームワークは、ネットワーク構成要素の集合によって実現されるかもしれない方法の例として紹介されている。図4は、ロールがポリシーフレームワーク内で動作する方法を示す図です。それらの間の区別がこの議論に重要ではありませんので、PDPとPEPは1箱にまとめています。ここで例示ポイントPDPとPEPが別々に実装されている環境に、しかし、等しく良好に適用されます。"
    },
    {
      "indent": 6,
      "text": "A role represents a functional characteristic or capability of a resource to which policies are applied. Examples of roles include Backbone interface, Frame Relay interface, BGP-capable router, web server, firewall, etc. The multiple roles assigned to a single resource are combined to form that resource's role combination. Role combinations are represented in the PCIM by values of the PolicyRoles property in the PolicyRule class. A PDP uses policy roles as follows to identify the policies it needs to be aware of:",
      "ja": "役割は、ポリシーが適用されるリソースの機能的特徴または機能を表します。役割の例としては、単一のリソースに割り当てられた複数の役割は、そのリソースの役割の組み合わせを形成するために結合されているバックボーン・インタフェース、フレームリレーインターフェイス、BGP対応ルータ、Webサーバ、ファイアウォールなどが含まれます。役割の組み合わせはPolicyRuleのクラスのPolicyRolesプロパティの値によってPCIMに示されています。それが注意する必要があるポリシーを識別するために、次のようにPDPは、ポリシーの役割を使用しています。"
    },
    {
      "indent": 6,
      "text": "1. The PDP learns in some way the list of roles that its PEPs play. This information might be configured at the PDP, the PEPs might supply it to the PDP, or the PDP might retrieve it from a repository.",
      "ja": "1. PDPは、何らかの方法でそののPEPが果たす役割のリストを学習します。この情報は、PDPで構成されている場合があり、PEPには、PDPに供給可能性がある、またはPDPは、リポジトリからそれを取得することがあります。"
    },
    {
      "indent": 6,
      "text": "2. Using repository-specific means, the PDP determines where to look for policy rules that might apply to it.",
      "ja": "2.リポジトリ固有の手段を用いて、PDPはどこに適用される場合がありますポリシールールを検索する場所を決定します。"
    },
    {
      "indent": 6,
      "text": "3. Using the roles and role-combinations it received from its PEPs as indicated in the examples above, the PDP is able to locate and retrieve the policy rules that are relevant to it.",
      "ja": "3.上記実施例に示されるように、そののPEPから受信したロールとロールの組み合わせを使用して、PDPは、それに関連するポリシールールを見つけて検索することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.2. The PolicyRoles Property",
      "section_title": true,
      "ja": "5.2.2.  PolicyRolesプロパティ"
    },
    {
      "indent": 3,
      "text": "As indicated earlier, PolicyRoles is a property associated with a policy rule. It is an array holding \"role combinations\" for the policy rule, and correlates with the roles defined for a network resource. Using the PolicyRoles property, it is possible to mark a policy rule as applying, for example, to a Frame Relay interface or to a backbone ATM interface. The PolicyRoles property take strings of the form:",
      "ja": "先に示したように、PolicyRolesは、ポリシールールに関連付けられた特性です。これは、ポリシールールは、「役割の組み合わせ」を保持する配列であり、ネットワークリソースに定義された役割と相関します。 PolicyRolesプロパティを使用して、適用として、例えば、フレームリレーインターフェイスまたはバックボーンATMインターフェイスにポリシールールをマークすることが可能です。 PolicyRolesプロパティは、フォームの文字列を取ります："
    },
    {
      "indent": 6,
      "text": "<RoleName>[&&<RoleName>]*",
      "ja": "<ロール名> [&& <ロール名>] *"
    },
    {
      "indent": 3,
      "text": "Each value of this property represents a role combination, including the special case of a \"combination\" containing only one role. As the format indicates, the role names in a role combination are ANDed together to form a single selector. The multiple values of the PolicyRoles property are logically ORed, to make it possible for a policy rule to have multiple selectors.",
      "ja": "このプロパティの各値は、1つのロールのみを含む「組み合わせ」の特別な場合を含む役割の組み合わせを表します。フォーマットが示すように、役割の組み合わせにおいてロール名は、単一のセレクタを形成するために一緒にAND演算されます。 PolicyRolesプロパティの複数の値は、ポリシールールは、複数のセレクタを有することを可能にするために、論理的論理和です。"
    },
    {
      "indent": 3,
      "text": "The individual role names in a role combination must appear in alphabetical order (according to the collating sequence for UCS-2 characters), to make the string matches work correctly. The role names used in an environment are specified by the policy administrator.",
      "ja": "役割の組み合わせにおける個々の役割名は、文字列の一致を正しく動作させるために、アルファベット順に（UCS-2文字の照合順序に従って）に表示されなければなりません。環境で使用されるロール名は、ポリシー管理者が指定されています。"
    },
    {
      "indent": 0,
      "text": "5.3. Local Time and UTC Time in PolicyTimePeriodConditions",
      "section_title": true,
      "ja": "5.3. ポリシー時間帯の条件での現地時間とUTC時間"
    },
    {
      "indent": 3,
      "text": "An instance of PolicyTimePeriodCondition has up to five properties that represent times: TimePeriod, MonthOfYearMask, DayOfMonthMask, DayOfWeekMask, and TimeOfDayMask. All of the time-related properties in an instance of PolicyTimePeriodCondition represent one of two types of times: local time at the place where a policy rule is applied, or UTC time. The property LocalOrUtcTime indicates which time representation applies to an instance of PolicyTimePeriodCondition.",
      "ja": "時間期間、MonthOfYearMask、DayOfMonthMask、DayOfWeekMask、およびTimeOfDayMask：PolicyTimePeriodConditionのインスタンスは、時刻を表す最大5つの特性を有しています。ポリシールールが適用される場所で現地時間、またはUTC時間：PolicyTimePeriodConditionのインスタンスの時間関連特性の全ては時間の二つのタイプのいずれかを表します。プロパティLocalOrUtcTimeはPolicyTimePeriodConditionのインスタンスに適用される時間の表現を示しています。"
    },
    {
      "indent": 3,
      "text": "Since the PCIM provides only for local time and UTC time, a Policy Management Tool that provides for other time representations (for example, a fixed time at a particular location) will need to map from these other representations to either local time or UTC time. An example will illustrate the nature of this mapping.",
      "ja": "PCIMは、ローカル時刻とUTC時間を提供するので、他の時間の表現を提供するポリシー管理ツール（例えば、特定の位置に固定された時間）は、ローカル時間またはUTC時間のいずれかに、これらの他の表現からマッピングする必要があります。例では、このマッピングの本質を説明します。"
    },
    {
      "indent": 3,
      "text": "Suppose a policy rule is tied to the hours of operation for a Help Desk: 0800 to 2000 Monday through Friday [US] Eastern Time. In order to express these times in PolicyTimePeriodCondition, a management tool must convert them to UTC times. (They are not local times, because they refer to a single time interval worldwide, not to intervals tied to the local clocks at the locations where the",
      "ja": "ポリシールールは、ヘルプデスクのための操作の時間に縛られていると仮定します。月曜日から金曜日までの2000年に0800 [US]東部標準時。 PolicyTimePeriodConditionでこれらの時間を表現するために、管理ツールは、UTC時間に変換する必要があります。彼らはインターバル世界的に単一の時間に、いない場所でのローカルクロックに結び付けられた間隔を参照するため、（彼らは、現地時間ではありません"
    },
    {
      "indent": 3,
      "text": "PolicyRule is being applied.) As reference [10] points out, mapping from [US] Eastern Time to UTC time is not simply a matter of applying an offset: the offset between [US] Eastern Time and UTC time switches between -0500 and -0400 depending on whether Daylight Savings Time is in effect in the US.",
      "ja": "。PolicyRuleのが適用されている）を基準として[10]は、UTC時間に[US]東部標準時からのマッピングは、単に適用の問題ではない指摘オフセット：-0500との間[US]東部時間とUTC時間スイッチとの間のオフセット-0400夏時間は米国で有効であるかどうかによって異なります。"
    },
    {
      "indent": 3,
      "text": "Suppose the policy administrator's goal is to have a policy rule be valid from 0800 until 1200 [US] Eastern Time on every Monday, within the overall time period from the beginning of 2000 until the end of 2001. The Policy Management Tool could either be configured with the definition of what [US] Eastern Time means, or it could be configured with knowledge of where to go to get this information. Reference [10] contains further discussion of time zone definitions and where they might reside.",
      "ja": "ポリシー管理者の目標は、どちらかに構成することができ、2001年ポリシー管理ツールの終了時まで2000年の初めから、全体的な期間内に、毎週月曜日の1200 [US]東部標準時まで0800からも有効なポリシールールを持つことであると仮定何[US]東部標準時の定義と意味、またはそれは、この情報を取得するにはどこへ行くの知識をもって構成することができます。リファレンス[10]はさらにタイムゾーン定義の議論とどこに存在する可能性が含まれています。"
    },
    {
      "indent": 3,
      "text": "Armed with knowledge about [US] Eastern Time, the Policy Management Tool would create however many instances of PolicyTimePeriodCondition it needed to represent the desired intervals. Note that while there is an increased number of PolicyTimePeriodCondition instances, there is still just one PolicyRule, which is tied to all the PolicyTimePeriodCondition instances via the aggregation PolicyRuleValidityPeriod. Here are the first two of these instances:",
      "ja": "[US]東部時間についての知識を武器に、ポリシー管理ツールは、それが所望の間隔を表現するために必要なPolicyTimePeriodConditionのしかし、多くのインスタンスを作成します。 PolicyTimePeriodConditionインスタンス数の増加があるが、集約PolicyRuleValidityPeriodを経由して、すべてのPolicyTimePeriodConditionインスタンスに関連付けられているただ一つのPolicyRuleが、まだあることに注意してください。ここではこれらのインスタンスの最初の二つは、以下のとおりです。"
    },
    {
      "indent": 9,
      "text": "1. TimePeriod:  20000101T050000/20000402T070000\n   DayOfWeekMask:  { Monday }\n   TimeOfDayMask:  T130000/T170000\n   LocalOrUtcTime:  UTC",
      "raw": true
    },
    {
      "indent": 9,
      "text": "2. TimePeriod: 20000402T070000/20001029T070000 DayOfWeekMask: { Monday } TimeOfDayMask: T120000/T160000 LocalOrUtcTime: UTC",
      "ja": "2.時間期間：20000402T070000 / 20001029T070000 DayOfWeekMask：{月曜日} TimeOfDayMask：T120000 / T160000のLocalOrUtcTime：UTC"
    },
    {
      "indent": 3,
      "text": "There would be three more similar instances, for winter 2000-2001, summer 2001, and winter 2001 up through December 31.",
      "ja": "12月31日まで、最大の冬2000年から2001年、2001年夏、冬2001年の3つの類似した事例、あるでしょう。"
    },
    {
      "indent": 3,
      "text": "Had the example been chosen differently, there could have been even more instances of PolicyTimePeriodCondition. If, for example, the",
      "ja": "例はPolicyTimePeriodConditionのさらに多くの事例があった可能性があり、異なっ連ねました。 、たとえば、"
    },
    {
      "indent": 3,
      "text": "time interval had been from 0800 - 2200 [US] Eastern Time on Mondays, instance 1 above would have split into two instances: one with a UTC time interval of T130000/T240000 on Mondays, and another with a UTC time interval of T000000/T030000 on Tuesdays. So the end result would have been ten instances of PolicyTimePeriodCondition, not five.",
      "ja": "月曜日のT130000 / T240000のUTC時間間隔で1、およびT000000 / T030000のUTC時間間隔で別： - 時間間隔は0800からだった月曜日に2200 [US]東部標準時、インスタンス1は、上記の2つのインスタンスに分かれているだろう毎週火曜日に。だから、最終的な結果はPolicyTimePeriodConditionの10のインスタンスではなく、5だったでしょう。"
    },
    {
      "indent": 3,
      "text": "By restricting PolicyTimePeriodCondition to local time and UTC time, the PCIM places the difficult and expensive task of mapping from \"human\" time representations to machine-friendly ones in the Policy",
      "ja": "現地時間とUTC時刻にPolicyTimePeriodConditionを制限することにより、PCIMは、ポリシー内のマシンに優しいものに「ヒト」の時間表現からマッピングの困難かつ高価タスクを配置します"
    },
    {
      "indent": 3,
      "text": "Management Tool. Another approach would have been to place in PolicyTimePeriodCondition a means of representing a named time zone, such as [US] Eastern Time. This, however, would have passed the difficult mapping responsibility down to the PDPs and PEPs. It is better to have a mapping such as the one described above done once in a Policy Management Tool, rather than having it done over and over in each of the PDPs (and possibly PEPs) that need to apply a PolicyRule.",
      "ja": "管理ツール。別のアプローチは、このような[US]東部標準時として、PolicyTimePeriodConditionで名付けられた時間帯を表現する手段を配置することであっただろう。これは、しかし、プラズマディスプレイパネルとのPEPまで困難マッピング責任を合格しています。このような、むしろそれがのPolicyRuleを適用する必要があります（おそらくとのPEP）のPDPのそれぞれに何度も行われたよりも、ポリシー管理ツールで一度前述行わ一つとしてマッピングを持っている方が良いです。"
    },
    {
      "indent": 0,
      "text": "5.4. CIM Data Types",
      "section_title": true,
      "ja": "5.4.  CIMデータ型"
    },
    {
      "indent": 3,
      "text": "Since PCIM extends the CIM Schema, a correspondence between data types used in both CIM and PCIM is needed. The following CIM data types are used in the class definitions that follow in Sections 6 and 7:",
      "ja": "PCIMは、CIMスキーマを拡張するため、CIMとPCIMの両方で使用されるデータ・タイプとの対応が必要です。以下CIMデータ型はセクション6および7に従うクラス定義で使用されています。"
    },
    {
      "indent": 3,
      "text": "o uint8 unsigned 8-bit integer",
      "ja": "O UINT8符号なし8ビット整数"
    },
    {
      "indent": 3,
      "text": "o uint16 unsigned 16-bit integer",
      "ja": "O uint16の符号なし16ビット整数"
    },
    {
      "indent": 3,
      "text": "o boolean Boolean",
      "ja": "Oブールブール"
    },
    {
      "indent": 3,
      "text": "o string UCS-2 string.",
      "ja": "O列UCS-2文字列。"
    },
    {
      "indent": 3,
      "text": "Strings in CIM are stored as UCS-2 characters, where each character is encoded in two octets. Thus string values may need to be converted when moving between a CIM environment and one that uses a different string encoding. For example, in an LDAP-accessible directory, attributes of type DirectoryString are stored in UTF-8 format. RFC 2279 [7] explains how to convert between these two formats.",
      "ja": "CIMにおける文字列は、各文字が2つのオクテットで符号化されたUCS-2文字として格納されています。こうして文字列値は、CIM環境と異なる文字列エンコーディングを使用するものとの間で移動する際に変換する必要があるかもしれません。たとえば、LDAPアクセス可能なディレクトリに、タイプDirectoryStringの属性は、UTF-8形式で保存されます。 RFC 2279 [7]これら二つのフォーマット間の変換する方法を説明します。"
    },
    {
      "indent": 3,
      "text": "When it is applied to a CIM string, a MaxLen value refers to the maximum number of characters in the string, rather than to the maximum number of octets.",
      "ja": "それはCIMストリングに適用した場合、のMaxLen値ではなくオクテットの最大数に比べて、文字列内の文字の最大数を指します。"
    },
    {
      "indent": 3,
      "text": "In addition to the CIM data types listed above, the association classes in Section 7 use the following type:",
      "ja": "上記CIMデータ型に加えて、第7の関連クラスは、以下のタイプを使用します。"
    },
    {
      "indent": 3,
      "text": "o <classname> ref strongly typed reference.",
      "ja": "O <クラス名> refは、強く型付けされた参照を。"
    },
    {
      "indent": 3,
      "text": "There is one obvious omission from this list of CIM data types: octet strings. This is because CIM treats octet strings as a derived data type. There are two forms of octet strings in CIM - an ordered uint8 array for single-valued strings, and a string array for multi-valued properties. Both are described by adding an \"OctetString\" qualifier (meta-data) to the property. This qualifier functions exactly like an SMIv2 (SNMP) Textual Convention, refining the syntax and semantics of the existing CIM data type.",
      "ja": "オクテット文字列：CIMデータの種類のリストから1つの明白な省略があります。 CIMは、派生データ型としてオクテット文字列を扱うためです。単一値の文字列のための注文のuint8配列、および複数値プロパティの文字列配列 -  CIMにおけるオクテット文字列の2つの形式があります。両方がプロパティに「OctetStringに」修飾子（メタデータ）を添加することによって記載されています。既存のCIMデータ型の構文とセマンティクスを洗練正確のSMIv2（SNMP）テキストの表記法のようなこの修飾子は、関数、。"
    },
    {
      "indent": 3,
      "text": "The first four numeric elements of both of the \"OctetString\" representations are a length field. (The reason that the \"numeric\" adjective is added to the previous sentence is that the string property also includes '0' and 'x', as its first characters.) In both cases, these 4 numeric elements (octets) are included in calculating the length. For example, a single-valued octet string property having the value X'7C' would be represented by the uint8 array, X'00 00 00 05 7C'.",
      "ja": "「OctetStringに」表現の両方の最初の4つの数値要素は、長さフィールドです。 （「数値」形容詞が前の文に追加されていることを理由は、文字列プロパティは、その最初の文字として、「0」と「X」を含むことがある。）の両方の場合において、これらの4つの数値要素（オクテット）に含まれています長さを計算します。例えば、値X'7Cを有する単一値オクテット文字列プロパティが「UINT8アレイ、X'00 00 00 05（c）で表されることになります」。"
    },
    {
      "indent": 3,
      "text": "The strings representing the individual values of a multi-valued property qualified with the \"OctetString\" qualifier are constructed similarly:",
      "ja": "「OctetStringに」修飾子で修飾多値プロパティの個々の値を表す文字列は同様に構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Take a value to be encoded as an octet string (we'll use X'7C' as above), and prepend to it a four-octet length. The result is the same, X'00 00 00 05 7C'.",
      "ja": "1.（私たちは、上記のようにX'7C」を使用します）オクテット文字列としてエンコードされる値を取り、それに4オクテット長を先頭に追加。結果は同じで、X'00 00 00 05（c）」です。"
    },
    {
      "indent": 3,
      "text": "2. Convert this to a character string by introducing '0' and 'x' at the front, and removing all white space. Thus we have the 12- character string \"0x000000057C\". This string is the value of one of the array elements in the CIM string array. Since CIM uses the UCS-2 character set, it will require 24 octets to encode this 12- character string.",
      "ja": "2.フロントで「0」と「X」を導入し、すべての空白を除去することにより、文字列にこれを変換します。したがって、私たちは、12文字の文字列「0x000000057C」を持っています。この文字列は、CIMの文字列配列の配列要素のいずれかの値です。 CIMがUCS-2文字セットを使用しているため、それがこの、12文字の文字列をエンコードするために24オクテットが必要になります。"
    },
    {
      "indent": 3,
      "text": "Mappings of the PCIM to particular data models are not required to follow this CIM technique of representing multi-valued octet strings as length- prefixed character strings. In an LDAP mapping, for example, it would be much more natural to simply use the Octet String syntax, and omit the prepended length octets.",
      "ja": "特定のデータモデルへのPCIMのマッピングは、長さ - 接頭辞文字列として複数の値を持つオクテット文字列を表すこのCIM技術に従うことが必要とされていません。 LDAPマッピングでは、例えば、それは単にオクテット文字列の構文を使用し、プリペンド長さオクテットを省略することがはるかに自然なことでしょう。"
    },
    {
      "indent": 0,
      "text": "5.5. Comparison between CIM and LDAP Class Specifications",
      "section_title": true,
      "ja": "5.5.  CIMとLDAPクラス仕様の比較"
    },
    {
      "indent": 3,
      "text": "There are a number of differences between CIM and LDAP class specifications. The ones that are relevant to the abbreviated class specifications in this document are listed below. These items are included here to help introduce the IETF community, which is already familiar with LDAP, to CIM modeling, and by extension, to information modeling in general.",
      "ja": "CIMとLDAPクラス仕様の違いがいくつかあります。このドキュメントの省略クラスの仕様に関連するものは以下のとおりです。これらの項目は、CIMのモデリング、および拡張によって、一般的な情報モデリングに、すでにLDAPに精通しているIETFコミュニティを、ご紹介を助けるためにここに含まれています。"
    },
    {
      "indent": 3,
      "text": "o Instead of LDAP's three class types (abstract, auxiliary, structural), CIM has only two: abstract and instantiable. The type of a CIM class is indicated by the Boolean qualifier ABSTRACT.",
      "ja": "抽象的でインスタンス化：Oの代わりにLDAPの3クラスタイプ（抽象的、補助的、構造的）、CIMは2つだけあります。 CIMクラスのタイプは、ブール修飾子ABSTRACTで示されています。"
    },
    {
      "indent": 3,
      "text": "o CIM uses the term \"property\" for what LDAP terms an \"attribute\".",
      "ja": "O CIMは何LDAP用語「属性」の用語「プロパティ」を使用しています。"
    },
    {
      "indent": 3,
      "text": "o CIM uses the array notation \"[ ]\" to indicate that a property is multi-valued. CIM defines three types of arrays: bags (contents are unordered, duplicates allowed), ordered bags (contents are ordered but duplicates are allowed) and indexed arrays (contents are ordered and no duplicates are allowed).",
      "ja": "O CIMは、配列表記を使用して、「[]」プロパティは多値であることを示します。 CIMは、配列の3種類の定義：バッグ（内容は、許容重複順不同である）、（内容は順序付けされない重複が許されない）バッグ（内容は順序付けされているが、重複が許可されている）とインデックス付きアレイを注文しました。"
    },
    {
      "indent": 3,
      "text": "o CIM classes and properties are identified by name, not by OID.",
      "ja": "O CIMクラスおよびプロパティは名前ではなく、OIDで識別されます。"
    },
    {
      "indent": 3,
      "text": "o CIM classes use a different naming scheme for native implementations, than LDAP. The CIM naming scheme is documented in Appendix A since it is not critical to understanding the information model, and only applies when communicating with a native CIM implementation.",
      "ja": "O CIMクラスは、LDAPよりも、ネイティブ実装のためのさまざまな命名規則を使用します。 CIMの命名規則は、情報モデルを理解する上で重要ではないので、付録Aに記載され、ネイティブのCIM実装との通信時にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "o In LDAP, attribute definitions are global, and the same attribute may appear in multiple classes. In CIM, a property is defined within the scope of a single class definition. The property may be inherited into subclasses of the class in which it is defined, but otherwise it cannot appear in other classes. One side effect of this difference is that CIM property names tend to be much shorter than LDAP attribute names, since they are implicitly scoped by the name of the class in which they are defined.",
      "ja": "O LDAPでは、属性の定義はグローバルであり、同じ属性が複数のクラスに表示されることがあります。 CIMでは、プロパティは、単一のクラス定義の範囲内で定義されています。プロパティは、それが定義されているクラスのサブクラスに継承されてもよいが、そうでない場合は、他のクラスでは使用できません。この違いの1つの副作用は、それらが暗黙のうちに、それらが定義されているクラスの名前によってスコープされているので、CIMプロパティ名は、LDAP属性名よりもはるかに短いことが多いということです。"
    },
    {
      "indent": 3,
      "text": "There is also a notational convention that this document follows, to improve readability. In CIM, all class and property names are prefixed with the characters \"CIM_\". These prefixes have been omitted throughout this document, with one exception regarding naming, documented in Appendix A.",
      "ja": "このドキュメントでは、読みやすくするために、次の表記規則もあります。 CIMでは、すべてのクラスとプロパティ名は文字「CIM_」で始まります。これらのプレフィックスは、付録Aに文書化、命名に関する一つの例外を除いて、本書では省略されています"
    },
    {
      "indent": 3,
      "text": "For the complete definition of the CIM specification language, see reference [2].",
      "ja": "CIM仕様言語の完全な定義については、[2]参照を参照。"
    },
    {
      "indent": 0,
      "text": "6. Class Definitions",
      "section_title": true,
      "ja": "6.クラス定義"
    },
    {
      "indent": 3,
      "text": "The following sections contain the definitions of the PCIM classes.",
      "ja": "次のセクションでは、PCIMクラスの定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.1. The Abstract Class \"Policy\"",
      "section_title": true,
      "ja": "6.1. 抽象クラス「ポリシー」"
    },
    {
      "indent": 3,
      "text": "The abstract class Policy collects several properties that may be included in instances of any of the Core Policy classes (or their subclasses). For convenience, the two properties that Policy inherits from ManagedElement in the CIM schema are shown here as well.",
      "ja": "抽象クラスポリシーは、基本方針のクラス（またはそのサブクラス）のいずれかのインスタンスに含まれることができるいくつかのプロパティを収集します。便宜上、ポリシーは、CIMスキーマで管理対象要素から継承する2つのプロパティがここにも示されています。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME Policy DESCRIPTION An abstract class with four properties for describing a policy-related instance. DERIVED FROM ManagedElement ABSTRACT TRUE PROPERTIES CommonName (CN) PolicyKeywords[ ] // Caption (inherited) // Description (inherited)",
      "ja": "ポリシー関連のインスタンスを記述するための4つの性質を有するNAMEポリシー記述抽象クラス。管理対象要素ABSTRACT TRUE PROPERTIESのCommonName（CN）PolicyKeywords [] //キャプション（継承）//説明（継承）に由来"
    },
    {
      "indent": 0,
      "text": "6.1.1. The Property \"CommonName (CN)\"",
      "section_title": true,
      "ja": "6.1.1. プロパティ \"のCommonName（CN）\""
    },
    {
      "indent": 3,
      "text": "The CN, or CommonName, property corresponds to the X.500 attribute commonName (cn). In X.500 this property specifies one or more user-friendly names (typically only one name) by which an object is commonly known, names that conform to the naming conventions of the country or culture with which the object is associated. In the CIM model, however, the CommonName property is single-valued.",
      "ja": "CN、またはのCommonNameは、プロパティは、X.500属性のcommonName（CN）に対応します。 X.500では、このプロパティは、オブジェクトが一般的に知られている1つ以上のユーザーフレンドリー名（通常は1つの名前のみ）、オブジェクトが関連付けられている国や文化の命名規則に準拠する名前を指定します。 CIMモデルでは、しかし、のCommonNameプロパティは単一値です。"
    },
    {
      "indent": 6,
      "text": "NAME CN DESCRIPTION A user-friendly name of a policy-related object. SYNTAX string",
      "ja": "ポリシー関連のオブジェクトのNAME CN DESCRIPTIONのAユーザフレンドリー名。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.1.2. The Multi-valued Property \"PolicyKeywords\"",
      "section_title": true,
      "ja": "6.1.2. 多値プロパティ「PolicyKeywords」"
    },
    {
      "indent": 3,
      "text": "This property provides a set of one or more keywords that a policy administrator may use to assist in characterizing or categorizing a policy object. Keywords are of one of two types:",
      "ja": "このプロパティは、ポリシー管理者はポリシーオブジェクトを特徴付けるまたは分類を支援するために使用することができ、1つ以上のキーワードのセットを提供します。キーワードは、2つのタイプの一つであります："
    },
    {
      "indent": 3,
      "text": "o Keywords defined in this document, or in documents that define subclasses of the classes defined in this document. These keywords provide a vendor-independent, installation-independent way of characterizing policy objects.",
      "ja": "この文書で定義されたキーワードO、またはこのドキュメントで定義されたクラスのサブクラスを定義する文書インチこれらのキーワードは、ポリシーオブジェクトを特徴づけるのベンダーに依存しない、インストールに依存しない方法を提供します。"
    },
    {
      "indent": 3,
      "text": "o Installation-dependent keywords for characterizing policy objects. Examples include \"Engineering\", \"Billing\", and \"Review in December 2000\".",
      "ja": "ポリシーオブジェクトを特徴づけるためのOインストール依存のキーワード。例としては、「工学」、「課金」、および「2000年12月レビュー」が挙げられます。"
    },
    {
      "indent": 3,
      "text": "This document defines the following keywords: \"UNKNOWN\", \"CONFIGURATION\", \"USAGE\", \"SECURITY\", \"SERVICE\", \"MOTIVATIONAL\", \"INSTALLATION\", and \"EVENT\". These concepts were defined earlier in Section 2.",
      "ja": "「UNKNOWN」、「設定」、「利用」、「セキュリティ」、「サービス」、「モチベーション」、「インストール」、および「EVENT」：このドキュメントでは、次のキーワードを定義します。これらの概念は、以前のセクション2で定義されていました。"
    },
    {
      "indent": 3,
      "text": "One additional keyword is defined: \"POLICY\". The role of this keyword is to identify policy-related instances that would not otherwise be identifiable as being related to policy. It may be needed in some repository implementations.",
      "ja": "一つの追加のキーワードが定義されています。「ポリシー」。このキーワードの役割は、それ以外の政策に関連しているとは識別ではないであろう政策関連のインスタンスを識別することです。これは、いくつかのリポジトリの実装に必要となる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Documents that define subclasses of the Policy Core Information Model classes SHOULD define additional keywords to characterize instances of these subclasses. By convention, keywords defined in conjunction with class definitions are in uppercase. Installation-defined keywords can be in any case.",
      "ja": "方針コア情報モデルクラスのサブクラスを定義するドキュメントは、これらのサブクラスのインスタンスを特徴付けるために追加のキーワードを定義する必要があります。慣例では、クラス定義と関連して定義されているキーワードは大文字です。インストール定義キーワードは、どのような場合にすることができます。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyKeywords DESCRIPTION A set of keywords for characterizing /categorizing policy objects. SYNTAX string",
      "ja": "NAMEのPolicyKeywords説明ポリシーオブジェクトを分類/特徴付けるためのキーワードのセット。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.1.3. The Property \"Caption\" (Inherited from ManagedElement)",
      "section_title": true,
      "ja": "6.1.3.  （管理対象要素から継承されます）プロパティ「キャプション」"
    },
    {
      "indent": 3,
      "text": "This property provides a one-line description of a policy-related object.",
      "ja": "このプロパティは、ポリシー関連オブジェクトの1行の説明を提供します。"
    },
    {
      "indent": 3,
      "text": "NAME Caption DESCRIPTION A one-line description of this policy-related object. SYNTAX string",
      "ja": "NAMEキャプション説明このポリシーに関連するオブジェクトの1行の説明。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.1.4. The Property \"Description\" (Inherited from ManagedElement)",
      "section_title": true,
      "ja": "6.1.4.  （管理対象要素から継承されます）プロパティ「説明」"
    },
    {
      "indent": 3,
      "text": "This property provides a longer description than that provided by the caption property.",
      "ja": "このプロパティは、キャプションプロパティによって提供されるものよりも長い説明を提供します。"
    },
    {
      "indent": 3,
      "text": "NAME Description DESCRIPTION A long description of this policy-related object. SYNTAX string",
      "ja": "NAME説明説明このポリシー関連オブジェクトの長い説明。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.2. The Class \"PolicyGroup\"",
      "section_title": true,
      "ja": "6.2. クラス「のPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "This class is a generalized aggregation container. It enables either PolicyRules or PolicyGroups to be aggregated in a single container. Loops, including the degenerate case of a PolicyGroup that contains itself, are not allowed when PolicyGroups contain other PolicyGroups.",
      "ja": "このクラスは、一般的な集約コンテナです。これは、単一の容器内で凝集するPolicyRules又はPolicyGroupsのいずれかを可能にします。 PolicyGroupsが他のPolicyGroupsが含まれている場合、それ自体が含まれていたPolicyGroupの退化場合を含むループは、許可されていません。"
    },
    {
      "indent": 3,
      "text": "PolicyGroups and their nesting capabilities are shown in Figure 5 below. Note that a PolicyGroup can nest other PolicyGroups, and there is no restriction on the depth of the nesting in sibling PolicyGroups.",
      "ja": "PolicyGroupsとそのネスティング機能は、以下の図5に示されています。 PolicyGroupネストすることができ、他のPolicyGroupsことに注意してください、そしてPolicyGroups兄弟におけるネストの深さに制限はありません。"
    },
    {
      "indent": 9,
      "text": "+---------------------------------------------------+\n|                    PolicyGroup                    |\n|                                                   |\n| +--------------------+       +-----------------+  |\n| |    PolicyGroup A   |       |  PolicyGroup X  |  |\n| |                    |       |                 |  |\n| | +----------------+ |  ooo  |                 |  |\n| | | PolicyGroup A1 | |       |                 |  |\n| | +----------------+ |       |                 |  |\n| +--------------------+       +-----------------+  |\n+---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 5. Overview of the PolicyGroup class",
      "ja": "PolicyGroupクラスの図5.概要"
    },
    {
      "indent": 3,
      "text": "As a simple example, think of the highest level PolicyGroup shown in Figure 5 above as a logon policy for US employees of a company. This PolicyGroup may be called USEmployeeLogonPolicy, and may aggregate several PolicyGroups that provide specialized rules per location. Hence, PolicyGroup A in Figure 5 above may define logon rules for employees on the West Coast, while another PolicyGroup might define logon rules for the Midwest (e.g., PolicyGroup X), and so forth.",
      "ja": "簡単な例として、上記の同社の米国の従業員のためのログオンポリシーとして、図5に示す最高レベルののPolicyGroupを考えます。これのPolicyGroupはUSEmployeeLogonPolicyと呼ばれることもある、と場所ごとに特化した規則を提供するいくつかPolicyGroupsを集約することができます。別のPolicyGroupが等中西部のログオンルールを定義する（例えば、のPolicyGroup X）、およびかもしれないが故に、図5でのPolicyGroup A以上が、西海岸の従業員のログオンルールを定義することができます。"
    },
    {
      "indent": 3,
      "text": "Note also that the depth of each PolicyGroup does not need to be the same. Thus, the WestCoast PolicyGroup might have several additional layers of PolicyGroups defined for any of several reasons (different locales, number of subnets, etc..). The PolicyRules are therefore contained at n levels from the USEmployeeLogonPolicyGroup. Compare this to the Midwest PolicyGroup (PolicyGroup X), which might directly contain PolicyRules.",
      "ja": "各のPolicyGroupの深さは同じである必要はないことにも注意してください。したがって、コーストのPolicyGroupは、いくつかの理由のいずれかのために定義されPolicyGroupsのいくつかの追加の層かもしれない（異なるロケール、サブネットの数、など...）。 PolicyRulesしたがってUSEmployeeLogonPolicyGroupからn個のレベルで含まれます。直接PolicyRulesが含まれている可能性がある中西部のPolicyGroup（のPolicyGroup X）、これを比較してください。"
    },
    {
      "indent": 3,
      "text": "The class definition for PolicyGroup is as follows:",
      "ja": "次のようにのPolicyGroupのためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyGroup DESCRIPTION A container for either a set of related PolicyRules or a set of related PolicyGroups. DERIVED FROM Policy ABSTRACT FALSE PROPERTIES NONE",
      "ja": "関連PolicyRulesのセットまたは関連PolicyGroupsのセットのいずれかの名前のPolicyGroup説明Aコンテナ。ポリシーABSTRACT FALSE PROPERTIESのNONEから派生して"
    },
    {
      "indent": 3,
      "text": "No properties are defined for this class since it inherits all its properties from Policy. The class exists to aggregate PolicyRules or other PolicyGroups. It is directly instantiable. In an implementation, various key/identification properties MUST be defined. The keys for a native CIM implementation are defined in Appendix A, Section 13.1.1. Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].",
      "ja": "それはポリシーからすべてのプロパティを継承するので、何のプロパティは、このクラスに定義されていません。クラスはPolicyRulesまたは他のPolicyGroupsを集約するために存在します。これは、直接インスタンス化です。インプリメンテーションでは、様々なキー/識別特性が定義されなければなりません。ネイティブのCIM実装のためのキーは、付録A、13.1.1項で定義されています。 LDAP実装の鍵は、この情報モデル[11]のLDAPマッピングで定義されます。"
    },
    {
      "indent": 0,
      "text": "6.3. The Class \"PolicyRule\"",
      "section_title": true,
      "ja": "6.3. クラス「のPolicyRule」"
    },
    {
      "indent": 3,
      "text": "This class represents the \"If Condition then Action\" semantics associated with a policy. A PolicyRule condition, in the most general sense, is represented as either an ORed set of ANDed conditions (Disjunctive Normal Form, or DNF) or an ANDed set of ORed conditions (Conjunctive Normal Form, or CNF). Individual conditions may either be negated (NOT C) or unnegated (C). The actions specified by a PolicyRule are to be performed if and only if the PolicyRule condition (whether it is represented in DNF or CNF) evaluates to TRUE.",
      "ja": "このクラスは、ポリシーに関連付けられている「If条件[アクション」の意味を表します。 PolicyRuleの条件は、最も一般的な意味で、論理積条件（選言標準形、またはDNF）の論理和集合又は論理和条件の論理積集合（連言標準形、又はCNF）のいずれかとして表されます。個々の条件のいずれか（NOT C）またはunnegated（C）ネゲートされてもよいです。そして（それがDNFまたはCNFで表現されているか否か）PolicyRuleの条件がTRUEと評価された場合にのみ場合のPolicyRuleによって指定されたアクションが実行されます。"
    },
    {
      "indent": 3,
      "text": "The conditions and actions associated with a policy rule are modeled, respectively, with subclasses of the classes PolicyCondition and PolicyAction. These condition and action objects are tied to instances of PolicyRule by the PolicyConditionInPolicyRule and PolicyActionInPolicyRule aggregations.",
      "ja": "政策ルールに関連した条件とアクションはクラスのPolicyConditionとPolicyActionのサブクラスで、それぞれ、モデル化されています。これらの条件とアクションオブジェクトがPolicyConditionInPolicyRuleとPolicyActionInPolicyRule集計でのPolicyRuleのインスタンスに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "As illustrated above in Section 3, a policy rule may also be associated with one or more policy time periods, indicating the schedule according to which the policy rule is active and inactive. In this case it is the PolicyRuleValidityPeriod aggregation that provides the linkage.",
      "ja": "第3節で上に示したように、ポリシールールは、ポリシールールがアクティブおよび非アクティブであるに係るスケジュールを示す、1つまたは複数のポリシーの期間に関連付けることができます。この場合、リンケージを提供PolicyRuleValidityPeriod集合です。"
    },
    {
      "indent": 3,
      "text": "A policy rule is illustrated conceptually in Figure 6. below.",
      "ja": "ポリシールールは、以下の図6に概念的に示されています。"
    },
    {
      "indent": 12,
      "text": "+------------------------------------------------+\n|                    PolicyRule                  |\n|                                                |\n| +--------------------+     +-----------------+ |\n| | PolicyCondition(s) |     | PolicyAction(s) | |\n| +--------------------+     +-----------------+ |\n|                                                |\n|        +------------------------------+        |\n|        | PolicyTimePeriodCondition(s) |        |\n|        +------------------------------+        |\n+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 6. Overview of the PolicyRule Class",
      "ja": "PolicyRuleのクラスの図6.概要"
    },
    {
      "indent": 3,
      "text": "The PolicyRule class uses the property ConditionListType, to indicate whether the conditions for the rule are in DNF or CNF. The PolicyConditionInPolicyRule aggregation contains two additional properties to complete the representation of the rule's conditional expression. The first of these properties is an integer to partition the referenced conditions into one or more groups, and the second is a Boolean to indicate whether a referenced condition is negated. An example shows how ConditionListType and these two additional properties provide a unique representation of a set of conditions in either DNF or CNF.",
      "ja": "PolicyRuleのクラスは、ルールの条件がDNFかCNFにあるかどうかを示すために、プロパティConditionListTypeを使用しています。 PolicyConditionInPolicyRuleアグリゲーションは、ルールの条件式の表現を完了するために2つの追加プロパティが含まれています。これらの特性の第一は、一の以上のグループに参照される条件を分割する整数であり、第二は、参照条件が否定されているかどうかを示すブール値です。例はConditionListType、これら二つの追加のプロパティがDNFまたはCNFのいずれかの状況のセットの一意な表現を提供する方法を示しています。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a PolicyRule that aggregates five PolicyConditions C1 through C5, with the following values in the properties of the five PolicyConditionInPolicyRule associations:",
      "ja": "我々は5つのPolicyConditionInPolicyRule団体のプロパティで以下の値で、C5を通じて5 PolicyConditions C1を集約したPolicyRuleがあるとします。"
    },
    {
      "indent": 6,
      "text": "C1: GroupNumber = 1, ConditionNegated = FALSE C2: GroupNumber = 1, ConditionNegated = TRUE C3: GroupNumber = 1, ConditionNegated = FALSE C4: GroupNumber = 2, ConditionNegated = FALSE C5: GroupNumber = 2, ConditionNegated = FALSE",
      "ja": "C1：GroupNumber = 1、ConditionNegated = FALSE C2：GroupNumber = 1、ConditionNegated = TRUE C3：GroupNumber = 1、ConditionNegated = FALSE C4：GroupNumber = 2、ConditionNegated = FALSE C5：GroupNumber = 2、ConditionNegated = FALSE"
    },
    {
      "indent": 3,
      "text": "If ConditionListType = DNF, then the overall condition for the PolicyRule is:",
      "ja": "ConditionListType = DNF場合は、PolicyRuleのための全体的な状態は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "(C1 AND (NOT C2) AND C3) OR (C4 AND C5)",
      "ja": "（C1 AND（NOT C2）AND C3）又は（C4及びC5）"
    },
    {
      "indent": 3,
      "text": "On the other hand, if ConditionListType = CNF, then the overall condition for the PolicyRule is:",
      "ja": "一方、ConditionListType = CNF場合、PolicyRuleのための全体的な状態です。"
    },
    {
      "indent": 6,
      "text": "(C1 OR (NOT C2) OR C3) AND (C4 OR C5)",
      "ja": "（C1 OR（NOT C2）OR C3）および（C4 OR C5）"
    },
    {
      "indent": 3,
      "text": "In both cases, there is an unambiguous specification of the overall condition that is tested to determine whether to perform the actions associated with the PolicyRule.",
      "ja": "両方の場合において、のPolicyRuleに関連付けられたアクションを実行するかどうかを決定するために試験された全体的な状態の明確な指定があります。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRule DESCRIPTION The central class for representing the \"If Condition then Action\" semantics associated with a policy rule. DERIVED FROM Policy ABSTRACT FALSE PROPERTIES Enabled ConditionListType RuleUsage Priority Mandatory SequencedActions PolicyRoles",
      "ja": "ポリシールールに関連付けられている「条件であれば、その後のアクション」の意味を表すためのNAMEのPolicyRuleの説明中央のクラス。ポリシーABSTRACT FALSE PROPERTIES有効ConditionListTypeのRuleUsage優先必須SequencedActionsのPolicyRolesから派生して"
    },
    {
      "indent": 3,
      "text": "The PolicyRule class is directly instantiable. In an implementation, various key/identification properties MUST be defined. The keys for a native CIM implementation are defined in Appendix A, Section 13.1.2. Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].",
      "ja": "PolicyRuleのクラスは直接インスタンス化です。インプリメンテーションでは、様々なキー/識別特性が定義されなければなりません。ネイティブのCIM実装のためのキーは、付録A、13.1.2項で定義されています。 LDAP実装の鍵は、この情報モデル[11]のLDAPマッピングで定義されます。"
    },
    {
      "indent": 0,
      "text": "6.3.1. The Property \"Enabled\"",
      "section_title": true,
      "ja": "6.3.1.  「有効」プロパティ"
    },
    {
      "indent": 3,
      "text": "This property indicates whether a policy rule is currently enabled, from an administrative point of view. Its purpose is to allow a policy administrator to enable or disable a policy rule without having to add it to, or remove it from, the policy repository.",
      "ja": "このプロパティは、管理の観点から、政策ルールが現在有効になっているかどうかを示します。その目的は、ポリシー管理者にそれを追加、またはポリシーリポジトリから削除することなく、ポリシールールを有効または無効にできるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The property also supports the value 'enabledForDebug'. When the property has this value, the entity evaluating the policy condition(s) is being told to evaluate the conditions for the policy rule, but not to perform the actions if the conditions evaluate to TRUE. This value serves as a debug vehicle when attempting to determine what policies would execute in a particular scenario, without taking any actions to change state during the debugging.",
      "ja": "プロパティは、値「enabledForDebug」をサポートしています。プロパティは、この値を持っている場合は、ポリシーの条件（複数可）を評価するエンティティは、ポリシールールの条件を評価するように言われているが、条件がTRUEと評価された場合のアクションを実行しません。デバッグ中の状態を変更するために、任意のアクションを取ることなく、特定のシナリオで実行するだろうか方針を決定しようとしたとき、この値は、デバッグ車両として機能します。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME Enabled DESCRIPTION An enumeration indicating whether a policy rule is administratively enabled, administratively disabled, or enabled for debug mode. SYNTAX uint16 VALUES enabled(1), disabled(2), enabledForDebug(3) DEFAULT VALUE enabled(1)",
      "ja": "NAME説明有効ポリシールールが管理上、有効な管理上無効、またはデバッグモードを有効にするかどうかを示す列挙。構文uint16のの値は、（1）enabledForDebug（3）デフォルト値は有効、（2）無効、（1）有効"
    },
    {
      "indent": 0,
      "text": "6.3.2. The Property \"ConditionListType\"",
      "section_title": true,
      "ja": "6.3.2. プロパティ「ConditionListType」"
    },
    {
      "indent": 3,
      "text": "This property is used to specify whether the list of policy conditions associated with this policy rule is in disjunctive normal form (DNF) or conjunctive normal form (CNF). If this property is not present, the list type defaults to DNF. The property definition is as follows:",
      "ja": "このプロパティは、このポリシールールに関連付けられているポリシー条件のリストは、選言標準形（DNF）または連言標準形（CNF）であるか否かを指定するために使用されます。このプロパティが存在しない場合、DNFのリストタイプがデフォルトになります。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME ConditionListType DESCRIPTION Indicates whether the list of policy conditions associated with this policy rule is in disjunctive normal form (DNF) or conjunctive normal form (CNF). SYNTAX uint16 VALUES DNF(1), CNF(2) DEFAULT VALUE DNF(1)",
      "ja": "NAME Con​​ditionListType説明このポリシールールに関連付けられているポリシー条件のリストは、選言標準形（DNF）または連言標準形（CNF）にあるかどうかを示します。 DNF（1）、CNF（2）デフォルト値DNF（1）の値uint16のSYNTAX"
    },
    {
      "indent": 0,
      "text": "6.3.3. The Property \"RuleUsage\"",
      "section_title": true,
      "ja": "6.3.3. プロパティ「RuleUsage」"
    },
    {
      "indent": 3,
      "text": "This property is a free-form string that recommends how this policy should be used. The property definition is as follows:",
      "ja": "このプロパティは、このポリシーを使用する方法を推奨しています自由形式の文字列です。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME RuleUsage DESCRIPTION This property is used to provide guidelines on how this policy should be used. SYNTAX string",
      "ja": "このプロパティは、このポリシーを使用する方法に関するガイドラインを提供するために使用されRuleUsage DESCRIPTIONという名前を付けます。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.3.4. The Property \"Priority\"",
      "section_title": true,
      "ja": "6.3.4. プロパティ「優先順位」"
    },
    {
      "indent": 3,
      "text": "This property provides a non-negative integer for prioritizing policy rules relative to each other. Larger integer values indicate higher priority. Since one purpose of this property is to allow specific, ad hoc policy rules to temporarily override established policy rules, an instance that has this property set has a higher priority than all instances that use or set the default value of zero.",
      "ja": "このプロパティは、互いに対してポリシールールに優先順位を付けるための非負整数を提供します。より大きな整数値は、より高い優先順位を示します。このプロパティの目的は、一時的に確立されたポリシールールをオーバーライドする特定、アドホックポリシールールを可能にすることであるので、このプロパティが設定されているインスタンスを使用するか、またはゼロのデフォルト値を設定し、すべてのインスタンスよりも高い優先度を有しています。"
    },
    {
      "indent": 3,
      "text": "Prioritization among policy rules provides a basic mechanism for resolving policy conflicts.",
      "ja": "ポリシールールの中で優先順位付けは、ポリシーの競合を解決するための基本的なメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME Priority DESCRIPTION A non-negative integer for prioritizing this PolicyRule relative to other PolicyRules. A larger value indicates a higher priority. SYNTAX uint16 DEFAULT VALUE 0",
      "ja": "NAME優先DESCRIPTION他PolicyRulesに対してこのPolicyRuleのを優先するための非負整数。大きな値は、より高い優先度を示します。構文uint16のデフォルト値0"
    },
    {
      "indent": 0,
      "text": "6.3.5. The Property \"Mandatory\"",
      "section_title": true,
      "ja": "6.3.5. プロパティ「必須」"
    },
    {
      "indent": 3,
      "text": "This property indicates whether evaluation (and possibly action execution) of a PolicyRule is mandatory or not. Its concept is similar to the ability to mark packets for delivery or possible discard, based on network traffic and device load.",
      "ja": "このプロパティは、PolicyRuleの評価（及びおそらくアクションの実行）が必須であるか否かを示します。そのコンセプトは、ネットワークトラフィックとデバイスの負荷に基づいて、配信または可能な廃棄のためのパケットをマークする機能に似ています。"
    },
    {
      "indent": 3,
      "text": "The evaluation of a PolicyRule MUST be attempted if the Mandatory property value is TRUE. If the Mandatory property value of a PolicyRule is FALSE, then the evaluation of the rule is \"best effort\" and MAY be ignored.",
      "ja": "必須プロパティの値がTRUEの場合のPolicyRuleの評価が試みられなければなりません。 PolicyRuleのの必須プロパティの値がFALSEの場合は、ルールの評価は「ベストエフォート」であり、無視されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME Mandatory DESCRIPTION A flag indicating that the evaluation of the PolicyConditions and execution of PolicyActions (if the condition list evaluates to TRUE) is required. SYNTAX boolean DEFAULT VALUE TRUE",
      "ja": "（条件リストがTRUEと評価された場合）PolicyConditionsとPolicyActionsの実行の評価が必要であることを示す必須のAフラグに名前を付けます。 TRUE SYNTAXブールデフォルトのVALUE"
    },
    {
      "indent": 0,
      "text": "6.3.6. The Property \"SequencedActions\"",
      "section_title": true,
      "ja": "6.3.6. プロパティ「SequencedActions」"
    },
    {
      "indent": 3,
      "text": "This property gives a policy administrator a way of specifying how the ordering of the policy actions associated with this PolicyRule is to be interpreted. Three values are supported:",
      "ja": "このプロパティは、ポリシー管理者は、こののPolicyRuleに関連した政策行動の順序を解釈する方法を指定する方法を提供します。 3つの値がサポートされています。"
    },
    {
      "indent": 3,
      "text": "o mandatory(1): Do the actions in the indicated order, or don't do them at all.",
      "ja": "O必須（1）：指定された順序でアクションを実行し、または全くそれをしません。"
    },
    {
      "indent": 3,
      "text": "o recommended(2): Do the actions in the indicated order if you can, but if you can't do them in this order, do them in another order if you can.",
      "ja": "O（2）推奨：可能な場合は指示された順序でアクションを実行していますが、この順序でそれらを行うことができない場合ができれば、別の順序でそれらを行います。"
    },
    {
      "indent": 3,
      "text": "o dontCare(3): Do them -- I don't care about the order.",
      "ja": "O DONTCAREは（3）：それらを行う - 私は順序を気にしないでください。"
    },
    {
      "indent": 3,
      "text": "When error / event reporting is addressed for the Policy Framework, suitable codes will be defined for reporting that a set of actions could not be performed in an order specified as mandatory (and thus were not performed at all), that a set of actions could not be performed in a recommended order (and moreover could not be performed in any order), or that a set of actions could not be performed in a recommended order (but were performed in a different order). The property definition is as follows:",
      "ja": "エラー/イベントの報告がポリシーフレームワークのためにアドレス指定される場合、適切なコードは、アクションのセットが必須と指定された順序で実行することができなかった（したがって、全く行われなかった）ことを報告するために定義されたアクションのセットができることであろう推奨される順序で実行されていない（かつ任意の順序で実行することができなかった）、又は一連のアクションを推奨順序で実行することができなかった（しかし、異なる順序で実施された）こと。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME SequencedActions DESCRIPTION An enumeration indicating how to interpret the action ordering indicated via the PolicyActionInPolicyRule aggregation. SYNTAX uint16 VALUES mandatory(1), recommended(2), dontCare(3) DEFAULT VALUE dontCare(3)",
      "ja": "NAME SequencedActions DESCRIPTION PolicyActionInPolicyRule凝集を介して示されたアクションの順序を解釈するかを示す列挙。 （1）必須値uint16のSYNTAX、DONTCARE（3）デフォルト値DONTCARE（3）、（2）推奨"
    },
    {
      "indent": 0,
      "text": "6.3.7. The Multi-valued Property \"PolicyRoles\"",
      "section_title": true,
      "ja": "6.3.7. 多値プロパティ「PolicyRoles」"
    },
    {
      "indent": 3,
      "text": "This property represents the roles and role combinations associated with a policy rule. Each value represents one role combination. Since this is a multi-valued property, more than one role combination can be associated with a single policy rule. Each value is a string of the form",
      "ja": "このプロパティは、ポリシールールに関連付けられている役割と役割の組み合わせを表します。各値は1つの役割の組み合わせを表します。これは多値性であるため、複数の役割の組み合わせは、単一のポリシールールに関連付けることができます。各値は、フォームの文字列です。"
    },
    {
      "indent": 6,
      "text": "<RoleName>[&&<RoleName>]*",
      "ja": "<ロール名> [&& <ロール名>] *"
    },
    {
      "indent": 3,
      "text": "where the individual role names appear in alphabetical order (according to the collating sequence for UCS-2). The property definition is as follows:",
      "ja": "個々のロール名をアルファベット順に表示される場所（UCS-2の照合順序に従います）。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRoles DESCRIPTION A set of strings representing the roles and role combinations associated with a policy rule. Each value represents one role combination. SYNTAX string",
      "ja": "NAMEのPolicyRoles説明ポリシールールに関連付けられている役割と役割の組み合わせを表す文字列のセット。各値は1つの役割の組み合わせを表します。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.4. The Abstract Class \"PolicyCondition\"",
      "section_title": true,
      "ja": "6.4. 抽象クラス「PolicyCondition」"
    },
    {
      "indent": 3,
      "text": "The purpose of a policy condition is to determine whether or not the set of actions (aggregated in the PolicyRule that the condition applies to) should be executed or not. For the purposes of the Policy Core Information Model, all that matters about an individual PolicyCondition is that it evaluates to TRUE or FALSE. (The individual PolicyConditions associated with a PolicyRule are combined to form a compound expression in either DNF or CNF, but this is accomplished via the ConditionListType property, discussed above, and by the properties of the PolicyConditionInPolicyRule aggregation, introduced above and discussed further in Section 7.6 below.) A logical structure within an individual PolicyCondition may also be introduced, but this would have to be done in a subclass of PolicyCondition.",
      "ja": "ポリシー条件の目的は、（条件が適用されるのPolicyRuleに集約）一連のアクションを実行するか否かかを決定することです。方針コア情報モデルの目的のためには、個々のPolicyConditionに関して重要なことはすべて、それがTRUEまたはFALSEに評価されていることです。 （のPolicyRuleに関連する個々のPolicyConditionsはDNFまたはCNFのいずれかにおける化合物の発現を形成するために結合されているが、これはConditionListTypeプロパティを介して達成される、上述の、とPolicyConditionInPolicyRule凝集の特性によって、上に導入され、セクション7.6でさらに議論しました以下。）個々のPolicyCondition内の論理構造も導入することができるが、これはPolicyConditionのサブクラスで行われなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because it is general, the PolicyCondition class does not itself contain any \"real\" conditions. These will be represented by properties of the domain-specific subclasses of PolicyCondition.",
      "ja": "それが一般的なので、PolicyConditionのクラス自体は任意の「本物」の条件が含まれていません。これらは、PolicyConditionのドメイン固有のサブクラスのプロパティで表現されます。"
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|                    Policy Conditions in DNF                   |\n| +-------------------------+         +-----------------------+ |\n| |       AND list          |         |      AND list         | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  | |\n| |  +-------------------+  |   ORed  |  +-----------------+  | |\n| |          ...            |         |         ...           | |\n| |         ANDed           |         |        ANDed          | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| +-------------------------+         +-----------------------+ |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 7. Overview of Policy Conditions in DNF",
      "ja": "DNFでのポリシー条件の図7.概要"
    },
    {
      "indent": 3,
      "text": "This figure illustrates that when policy conditions are in DNF, there are one or more sets of conditions that are ANDed together to form AND lists. An AND list evaluates to TRUE if and only if all of its constituent conditions evaluate to TRUE. The overall condition then evaluates to TRUE if and only if at least one of its constituent AND lists evaluates to TRUE.",
      "ja": "この図は、ポリシー条件がDNFにあるとき、フォームとリストするために一緒にAND演算された条件の1つ以上のセットがあることを示しています。およびその構成要素のすべての条件がTRUEにのみを評価する場合はifとリストがTRUEと評価されます。全体的な状態は続いた場合にTRUEと評価し、その構成やリストの少なくとも一方がTRUEと評価された場合にのみ。"
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|                    Policy Conditions in CNF                   |\n| +-------------------------+         +-----------------------+ |\n| |        OR list          |         |       OR list         | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |   ...   |  | PolicyCondition |  | |\n| |  +-------------------+  |  ANDed  |  +-----------------+  | |\n| |          ...            |         |         ...           | |\n| |         ORed            |         |         ORed          | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| |  |  PolicyCondition  |  |         |  | PolicyCondition |  | |\n| |  +-------------------+  |         |  +-----------------+  | |\n| +-------------------------+         +-----------------------+ |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 8. Overview of Policy Conditions in CNF",
      "ja": "CNFでのポリシー条件の図8.概要"
    },
    {
      "indent": 3,
      "text": "In this figure, the policy conditions are in CNF. Consequently, there are one or more OR lists, each of which evaluates to TRUE if and only if at least one of its constituent conditions evaluates to TRUE. The overall condition then evaluates to TRUE if and only if ALL of its constituent OR lists evaluate to TRUE.",
      "ja": "この図では、ポリシー条件は、CNFです。したがって、場合にTRUEと評価し、その構成条件のうちの少なくとも1つがTRUEと評価された場合にのみ、それぞれが1つ以上のORリストがあります。全体的な状態は続いた場合にTRUEと評価し、その構成やリストのすべてがTRUEと評価されている場合のみ。"
    },
    {
      "indent": 3,
      "text": "The class definition of PolicyCondition is as follows:",
      "ja": "次のようにPolicyConditionのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyCondition DESCRIPTION A class representing a rule-specific or reusable policy condition to be evaluated in conjunction with a policy rule. DERIVED FROM Policy ABSTRACT TRUE PROPERTIES NONE",
      "ja": "NAME PolicyCondition説明は、ルール固有のまたは再利用可能なポリシー条件を表すクラスは、ポリシールールに関連して評価されます。ポリシーABSTRACT TRUE PROPERTIESのNONEから派生して"
    },
    {
      "indent": 3,
      "text": "No properties are defined for this class since it inherits all its properties from Policy. The class exists as an abstract superclass for domain-specific policy conditions, defined in subclasses. In an implementation, various key/identification properties MUST be defined for the class or its instantiable subclasses. The keys for a native",
      "ja": "それはポリシーからすべてのプロパティを継承するので、何のプロパティは、このクラスに定義されていません。このクラスはサブクラスで定義されたドメイン固有のポリシー条件、抽象スーパークラスとして存在します。インプリメンテーションでは、様々なキー/識別プロパティは、クラスまたはそのサブクラスインスタンス化のために定義されなければなりません。ネイティブのためのキー"
    },
    {
      "indent": 3,
      "text": "CIM implementation are defined in Appendix A, Section 13.2. Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].",
      "ja": "CIMの実装は、付録A、13.2節で定義されています。 LDAP実装の鍵は、この情報モデル[11]のLDAPマッピングで定義されます。"
    },
    {
      "indent": 3,
      "text": "When identifying and using the PolicyCondition class, it is necessary to remember that a condition can be rule-specific or reusable. This was discussed above in Section 5.1. The distinction between the two types of policy conditions lies in the associations in which an instance can participate, and in how the different instances are named. Conceptually, a reusable policy condition resides in a policy repository, and is named within the scope of that repository. On the other hand, a rule-specific policy condition is, as the name suggests, named within the scope of the single policy rule to which it is related.",
      "ja": "識別しPolicyConditionのクラスを使用する場合、その条件は、ルール固有の又は再使用可能とすることができることを覚えておくことが必要です。これは、セクション5.1で前述しました。ポリシー条件の2種類の区別は、インスタンスが参加できる団体であり、および異なるインスタンスの名前の付け方インチ概念的には、再利用可能なポリシー条件は、ポリシー・リポジトリ内に存在し、そのリポジトリの範囲内で命名されています。名前が示唆する一方、ルール固有のポリシー条件は、それが関連する単一のポリシールールの範囲内で命名されています。"
    },
    {
      "indent": 3,
      "text": "The distinction between rule-specific and reusable PolicyConditions affects the CIM naming, defined in Appendix A, and the LDAP mapping [11].",
      "ja": "ルール固有の再利用可能なポリシー条件との間の区別は、付録Aで定義されたCIM命名、およびLDAPマッピング[11]影響を及ぼす。"
    },
    {
      "indent": 0,
      "text": "6.5. The Class \"PolicyTimePeriodCondition\"",
      "section_title": true,
      "ja": "6.5. クラス「PolicyTimePeriodCondition」"
    },
    {
      "indent": 3,
      "text": "This class provides a means of representing the time periods during which a policy rule is valid, i.e., active. At all times that fall outside these time periods, the policy rule has no effect. A policy rule is treated as valid at all times if it does not specify a PolicyTimePeriodCondition.",
      "ja": "このクラスは、アクティブなポリシールールが有効である時間の期間、すなわち、表現する手段を提供します。これらの期間外にあるすべての回で、ポリシールールの効果はありません。それはPolicyTimePeriodConditionを指定しない場合、ポリシールールは常に有効なものとして扱われます。"
    },
    {
      "indent": 3,
      "text": "In some cases a PDP may need to perform certain setup / cleanup actions when a policy rule becomes active / inactive. For example, sessions that were established while a policy rule was active might need to be taken down when the rule becomes inactive. In other cases, however, such sessions might be left up: in this case, the effect of deactivating the policy rule would just be to prevent the establishment of new sessions. Setup / cleanup behaviors on validity period transitions are not currently addressed by the PCIM, and must be specified in 'guideline' documents, or via subclasses of PolicyRule, PolicyTimePeriodCondition or other concrete subclasses of Policy. If such behaviors need to be under the control of the policy administrator, then a mechanism to allow this control must also be specified in the subclass.",
      "ja": "いくつかのケースではPDPは、ポリシールールが非アクティブ/アクティブになったときに、特定のセットアップ/クリーンアップアクションを実行する必要があるかもしれません。たとえば、ポリシールールがアクティブな間に確立されたセッションは、ルールが非アクティブになったときにダウン取られる必要があるかもしれません。他の例では、しかし、このようなセッションを任される可能性があります。この場合には、ポリシールールを無効化の効果は、単に新しいセッションの確立を防ぐことであろう。有効期間遷移上のセットアップ/クリーンアップ行動は、現在PCIMによって対処されていない、と 'ガイドラインのドキュメント、またはPolicyRuleの、PolicyTimePeriodConditionまたはポリシーの他の具象サブクラスのサブクラスで指定する必要があります。このような行動は、ポリシー管理者の制御下にする必要がある場合は、この制御を可能にするメカニズムは、サブクラスで指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "PolicyTimePeriodCondition is defined as a subclass of PolicyCondition. This is to allow the inclusion of time-based criteria in the AND/OR condition definitions for a PolicyRule.",
      "ja": "PolicyTimePeriodConditionはPolicyConditionのサブクラスとして定義されます。これはPolicyRuleのためのAND / OR条件の定義では、時間ベースの基準を含めることができるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Instances of this class may have up to five properties identifying time periods at different levels. The values of all the properties present in an instance are ANDed together to determine the validity period(s) for the instance. For example, an instance with an overall validity range of January 1, 2000 through December 31, 2000; a month mask that selects March and April; a day-of-the-week mask that selects Fridays; and a time of day range of 0800 through 1600 would represent the following time periods:",
      "ja": "このクラスのインスタンスは、異なるレベルの期間を識別する最大5つの特性を有していてもよいです。インスタンス内に存在するすべてのプロパティの値は、インスタンスの有効期間（S）を決定するために一緒にAND演算されます。例えば、2000年12月31日を経て2000年1月1日の全体的な有効範囲を持つインスタンス。 3月と4月を選択月のマスク。金曜日を選択した曜日のマスク。そして1600年を通じて0800の日の範囲の時間には、次の期間に相当するであろう："
    },
    {
      "indent": 6,
      "text": "Friday, March  5, 2000, from 0800 through 1600;\nFriday, March 12, 2000, from 0800 through 1600;\nFriday, March 19, 2000, from 0800 through 1600;\nFriday, March 26, 2000, from 0800 through 1600;\nFriday, April  2, 2000, from 0800 through 1600;\nFriday, April  9, 2000, from 0800 through 1600;\nFriday, April 16, 2000, from 0800 through 1600;\nFriday, April 23, 2000, from 0800 through 1600;\nFriday, April 30, 2000, from 0800 through 1600.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Properties not present in an instance of PolicyTimePeriodCondition are implicitly treated as having their value \"always enabled\". Thus, in the example above, the day-of-the-month mask is not present, and so the validity period for the instance implicitly includes a day-of-the-month mask that selects all days of the month. If we apply this \"missing property\" rule to its fullest, we see that there is a second way to indicate that a policy rule is always enabled: have it point to an instance of PolicyTimePeriodCondition whose only properties are its naming properties.",
      "ja": "PolicyTimePeriodConditionのインスタンスに存在しないプロパティは暗黙的に「常に有効」自分の価値を持つものとして扱われます。したがって、上記の例では、日の-月マスクは存在せず、したがって、インスタンスの有効期間は、暗黙的に月のすべての日を選択する日の-月マスクを含みます。私たちは最大限にこの「行方不明プロパティ」ルールを適用した場合、我々は政策ルールが常に有効になっていることを示すために、第二の方法があることを参照してください。それが唯一のプロパティの命名プロパティですPolicyTimePeriodConditionのインスタンスを指すしています。"
    },
    {
      "indent": 3,
      "text": "The property LocalOrUtcTime indicates whether the times represented in the other five time-related properties of an instance of PolicyTimePeriodCondition are to be interpreted as local times for the location where a policy rule is being applied, or as UTC times.",
      "ja": "プロパティLocalOrUtcTimeはPolicyTimePeriodConditionのインスタンスの他の5つの時間関連特性で表される時間は、ポリシールールが適用され、またはUTC時間などされている場所のための現地時間として解釈されるべきであるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows.",
      "ja": "次のようにクラス定義があります。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyTimePeriodCondition DESCRIPTION A class that provides the capability of enabling / disabling a policy rule according to a pre-determined schedule. DERIVED FROM PolicyCondition ABSTRACT FALSE PROPERTIES TimePeriod MonthOfYearMask DayOfMonthMask DayOfWeekMask TimeOfDayMask LocalOrUtcTime",
      "ja": "NAME PolicyTimePeriodCondition DESCRIPTION /イネーブル予め決定されたスケジュールに従ってポリシールールを無効にする機能を提供するクラス。 PolicyCondition ABSTRACT FALSE PROPERTIES時間期間MonthOfYearMask DayOfMonthMask DayOfWeekMask TimeOfDayMask LocalOrUtcTimeから、派生"
    },
    {
      "indent": 0,
      "text": "6.5.1. The Property \"TimePeriod\"",
      "section_title": true,
      "ja": "6.5.1. プロパティ「時間帯」"
    },
    {
      "indent": 3,
      "text": "This property identifies an overall range of calendar dates and times over which a policy rule is valid. It reuses the format for an explicit time period defined in RFC 2445 (reference [10]): a string representing a starting date and time, in which the character 'T' indicates the beginning of the time portion, followed by the solidus character '/', followed by a similar string representing an end date and time. The first date indicates the beginning of the range, while the second date indicates the end. Thus, the second date and time must be later than the first. Date/times are expressed as substrings of the form \"yyyymmddThhmmss\". For example:",
      "ja": "このプロパティは、政策ルールが有効である上、カレンダーの日付と時刻の全体の範囲を特定します。これは、RFC 2445で定義された明示的な期間のフォーマットを再利用し（参考文献[10]）：固相線文字に続く文字「T」は時間部分の開始を指示する開始日時を表す文字列、 ' /」、終了日時を表す同様の文字列が続きます。第二日の終わりを示しながら、最初の日は、範囲の始まりを示しています。したがって、第2の日付と時刻は、最初より後である必要があります。日付/時刻の形式は「YYYYMMDDTHHMMSS」の部分文字列として表現されています。例えば："
    },
    {
      "indent": 6,
      "text": "20000101T080000/20000131T120000",
      "ja": "20000101T080000 / 20000131T120000"
    },
    {
      "indent": 9,
      "text": "January 1, 2000, 0800 through January 31, 2000, noon",
      "ja": "2000年1月31日、正午を通じて2000年1月1日、0800"
    },
    {
      "indent": 3,
      "text": "There are also two special cases in which one of the date/time strings is replaced with a special string defined in RFC 2445.",
      "ja": "日付/時刻文字列の1つは、RFC 2445で定義された特別な文字列に置換された2つの特殊なケースもあります。"
    },
    {
      "indent": 3,
      "text": "o If the first date/time is replaced with the string \"THISANDPRIOR\", then the property indicates that a policy rule is valid [from now] until the date/time that appears after the '/'.",
      "ja": "最初の日付/時刻を文字列「THISANDPRIOR」に置き換えている場合は、O、そしてプロパティが「/」の後に表示された日付/時刻まで[今から]ポリシールールが有効であることを示しています。"
    },
    {
      "indent": 3,
      "text": "o If the second date/time is replaced with the string \"THISANDFUTURE\", then the property indicates that a policy rule becomes valid on the date/time that appears before the '/', and remains valid from that point on.",
      "ja": "第二の日付/時刻を文字列「THISANDFUTURE」に置き換えている場合は、O、そのプロパティは、ポリシールールが「/」の前に表示された日付/時刻に有効になることを示し、その時点から有効です。"
    },
    {
      "indent": 3,
      "text": "Note that RFC 2445 does not use these two strings in connection with explicit time periods. Thus the PCIM is combining two elements from RFC 2445 that are not combined in the RFC itself.",
      "ja": "そのRFC 2445には、明示的な時間帯に関連して、これら2つの文字列を使用しません。したがってPCIMはRFC自体で結合されていないRFC 2445の2つの要素を組み合わせています。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME TimePeriod DESCRIPTION The range of calendar dates on which a policy rule is valid. SYNTAX string FORMAT yyyymmddThhmmss/yyyymmddThhmmss, where the first date/time may be replaced with the string \"THISANDPRIOR\" or the second date/time may be replaced with the string \"THISANDFUTURE\"",
      "ja": "NAME時間期間の説明政策ルールが有効である上、カレンダーの日付の範囲。最初の日付/時刻は、文字列「THISANDPRIOR」又は第二の日付/時刻に置き換えてもよいSYNTAX文字列形式のYYYYMMDDTHHMMSS / YYYYMMDDTHHMMSSは、文字列「THISANDFUTURE」と置き換えてもよいです"
    },
    {
      "indent": 0,
      "text": "6.5.2. The Property \"MonthOfYearMask\"",
      "section_title": true,
      "ja": "6.5.2. プロパティ「MonthOfYearMask」"
    },
    {
      "indent": 3,
      "text": "The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property, by explicitly specifying the months when the policy is valid. These properties work together, with the TimePeriod used to specify the overall time period during which the policy might be valid, and the MonthOfYearMask used to pick out the specific months within that time period when the policy is valid.",
      "ja": "このプロパティの目的は、ポリシーが有効であるとき、明示的に数ヶ月を指定することで、時間期間プロパティによって定義された有効期間の定義を洗練することです。これらのプロパティは、ポリシーが有効であるかもしれない間、全体的な期間を指定するために使用される時間期間で、一緒に働く、とMonthOfYearMaskは、ポリシーが有効であるとき、その期間内に特定の数ヶ月を選び出すために使用されます。"
    },
    {
      "indent": 3,
      "text": "This property is formatted as an octet string of size 2, consisting of 12 bits identifying the 12 months of the year, beginning with January and ending with December, followed by 4 bits that are always set to '0'. For each month, the value '1' indicates that the policy is valid for that month, and the value '0' indicates that it is not valid. The value X'08 30', for example, indicates that a policy rule is valid only in the months May, November, and December.",
      "ja": "このプロパティは常に「0」に設定されている4ビットに続いて、1月に始まり、12月で終わる、今年の12ヶ月を特定する12ビットからなる、サイズ2のオクテット文字列として書式設定されています。各月の場合、値は「1」方針がその月に有効であることを示し、値が「0」、それが有効でないことを示しています。値X'08 30' は、例えば、ポリシールールのみヶ月月、11月、12月に有効であることを示しています。"
    },
    {
      "indent": 3,
      "text": "See section 5.4 for details of how CIM represents a single-valued octet string property such as this one. (Basically, CIM prepends a 4-octet length to the octet string.)",
      "ja": "CIMは、この一つとして、単一値のオクテット文字列プロパティを表し方法の詳細については5.4節を参照してください。 （基本的に、CIMは、オクテットストリングに4オクテットの長さを付加します。）"
    },
    {
      "indent": 3,
      "text": "If this property is omitted, then the policy rule is treated as valid for all twelve months. The property definition is as follows:",
      "ja": "このプロパティを省略すると、ポリシールールは、すべての12ヶ月間有効として扱われます。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME MonthOfYearMask DESCRIPTION A mask identifying the months of the year in which a policy rule is valid. SYNTAX octet string FORMAT X'hh h0'",
      "ja": "政策ルールが有効である年の月を特定するNAME MonthOfYearMask説明Aマスク。 SYNTAXオクテット文字列形式X'hh H0'"
    },
    {
      "indent": 0,
      "text": "6.5.3. The Property \"DayOfMonthMask\"",
      "section_title": true,
      "ja": "6.5.3. プロパティ「DayOfMonthMask」"
    },
    {
      "indent": 3,
      "text": "The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property, by explicitly specifying the days of the month when the policy is valid. These properties work together, with the TimePeriod used to specify the overall time period during which the policy might be valid, and the DayOfMonthMask used to pick out the specific days of the month within that time period when the policy is valid.",
      "ja": "このプロパティの目的は、ポリシーが有効であるとき、明示的に月の日数を指定することで、時間期間プロパティによって定義された有効期間の定義を洗練することです。これらのプロパティは、ポリシーが有効であるかもしれない間、全体的な期間を指定するために使用される時間期間、およびポリシーが有効であるとき、その期間内の月の特定の日を選ぶために使用されるDayOfMonthMaskと、一緒に働きます。"
    },
    {
      "indent": 3,
      "text": "This property is formatted as an octet string of size 8, consisting of 31 bits identifying the days of the month counting from the beginning, followed by 31 more bits identifying the days of the month counting from the end, followed by 2 bits that are always set to '0'. For each day, the value '1' indicates that the policy is valid for that day, and the value '0' indicates that it is not valid.",
      "ja": "このプロパティは、常に2ビット続いて、端から月計数の日識別する31ビット以上続いて、最初から月計数の日を特定する31ビットからなる、サイズ8のオクテット文字列としてフォーマットされ「0」に設定してください。毎日のために、値が「1」政策は、その日のために有効であることを示し、値が「0」、それが有効でないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The value X'80 00 00 01 00 00 00 00', for example, indicates that a policy rule is valid on the first and last days of the month.",
      "ja": "値X'80 00 00 01 00 00 00 00' は、例えば、政策ルールは、月の最初と最後の日に有効であることを示しています。"
    },
    {
      "indent": 3,
      "text": "For months with fewer than 31 days, the digits corresponding to days that the months do not have (counting in both directions) are ignored.",
      "ja": "未満31日と数ヶ月のために、月は（両方の方向に数えて）持っていないことを日に対応する数字は無視されます。"
    },
    {
      "indent": 3,
      "text": "The encoding of the 62 significant bits in the octet string matches that used for the schedDay object in the DISMAN-SCHEDULE-MIB. See reference [8] for more details on this object.",
      "ja": "DISMAN-SCHEDULE-MIBにおけるschedDayオブジェクトに使用されるオクテットストリングの一致62の最下位ビットの符号化。このオブジェクトの詳細については、[8]の参照を参照してください。"
    },
    {
      "indent": 3,
      "text": "See section 5.4 for details of how CIM represents a single-valued octet string property such as this one. (Basically, CIM prepends a 4-octet length to the octet string.)",
      "ja": "CIMは、この一つとして、単一値のオクテット文字列プロパティを表し方法の詳細については5.4節を参照してください。 （基本的に、CIMは、オクテットストリングに4オクテットの長さを付加します。）"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME DayOfMonthMask DESCRIPTION A mask identifying the days of the month on which a policy rule is valid. SYNTAX octet string FORMAT X'hh hh hh hh hh hh hh hh'",
      "ja": "月間マスク記述の名前日の政策ルールが有効である月の日数を特定するマスク。 SYNTAXオクテット文字列形式HH HH HH HH HH HHのHh H-H」"
    },
    {
      "indent": 0,
      "text": "6.5.4. The Property \"DayOfWeekMask\"",
      "section_title": true,
      "ja": "6.5.4. プロパティ「DayOfWeekMask」"
    },
    {
      "indent": 3,
      "text": "The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property by explicitly specifying the days of the week when the policy is valid. These properties work together, with the TimePeriod used to specify the overall time period when the policy might be valid, and the DayOfWeekMask used to pick out the specific days of the week in that time period when the policy is valid.",
      "ja": "このプロパティの目的は、ポリシーが有効であるとき、明示的に曜日を指定することで、時間期間プロパティによって定義された有効期間の定義を洗練することです。これらのプロパティは、ポリシーが有効である可能性がある場合、全体的な期間を指定するために使用される時間期間で、一緒に働く、とDayOfWeekMaskは、ポリシーが有効であるとき、その期間中に特定の曜日を選ぶために使用されます。"
    },
    {
      "indent": 3,
      "text": "This property is formatted as an octet string of size 1, consisting of 7 bits identifying the 7 days of the week, beginning with Sunday and ending with Saturday, followed by 1 bit that is always set to '0'. For each day of the week, the value '1' indicates that the policy is valid for that day, and the value '0' indicates that it is not valid.",
      "ja": "このプロパティは常に「0」に設定されている1ビットに続いて、日曜日に始まり、土曜日で終わる週の7日を特定する7ビットからなる、サイズ1のオクテット文字列として書式設定されています。曜日ごとに、値が「1」政策は、その日のために有効であることを示し、値が「0」、それが有効でないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The value X'7C', for example, indicates that a policy rule is valid Monday through Friday.",
      "ja": "値X'7Cは」、例えば、政策ルールは、月曜日から金曜日まで有効であることを示しています。"
    },
    {
      "indent": 3,
      "text": "See section 5.4 for details of how CIM represents a single-valued octet string property such as this one. (Basically, CIM prepends a 4-octet length to the octet string.)",
      "ja": "CIMは、この一つとして、単一値のオクテット文字列プロパティを表し方法の詳細については5.4節を参照してください。 （基本的に、CIMは、オクテットストリングに4オクテットの長さを付加します。）"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME DayOfWeekMask DESCRIPTION A mask identifying the days of the week on which a policy rule is valid. SYNTAX octet string FORMAT B'bbbb bbb0'",
      "ja": "政策ルールが有効である曜日を特定するNAME DayOfWeekMask説明Aマスク。 SYNTAXオクテット文字列形式B'bbbbのbbb0'"
    },
    {
      "indent": 0,
      "text": "6.5.5. The Property \"TimeOfDayMask\"",
      "section_title": true,
      "ja": "6.5.5. プロパティ「TimeOfDayMask」"
    },
    {
      "indent": 3,
      "text": "The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property by explicitly specifying a range of times in a day the policy is valid for. These properties work together, with the TimePeriod used to specify the overall time period that the policy is valid for, and the TimeOfDayMask used to pick out which range of time periods in a given day of that time period the policy is valid for.",
      "ja": "このプロパティの目的は、明示的ポリシーが有効です日に倍の範囲を指定することで、時間期間プロパティによって定義された有効期間の定義を洗練することです。これらのプロパティは、ポリシーがために有効であることを全体的な期間を指定するために使用される時間期間で、一緒に働く、とTimeOfDayMaskポリシーが有効ですその期間の特定の日に時間帯のどの範囲を選ぶために使用されます。"
    },
    {
      "indent": 3,
      "text": "This property is formatted in the style of RFC 2445 [10]: a time string beginning with the character 'T', followed by the solidus character '/', followed by a second time string. The first time indicates the beginning of the range, while the second time indicates the end. Times are expressed as substrings of the form \"Thhmmss\".",
      "ja": "このプロパティは、[10] RFC 2445のスタイルでフォーマットされた：時刻文字列が二度目の文字列が続くソリダス文字「/」に続く文字「T」、、で始まります。第二の時間が終わりを示しつつ、第1時間は、範囲の始まりを示しています。タイムズ紙は、フォーム「Thhmmss」の部分文字列として表現されています。"
    },
    {
      "indent": 3,
      "text": "The second substring always identifies a later time than the first substring. To allow for ranges that span midnight, however, the value of the second string may be smaller than the value of the first substring. Thus, \"T080000/T210000\" identifies the range from 0800 until 2100, while \"T210000/T080000\" identifies the range from 2100 until 0800 of the following day.",
      "ja": "第二のサブストリングは、常に最初のサブストリングより後の時間を特定します。真夜中にまたがる範囲を可能にするために、しかし、2番目の文字列の値は、最初のサブストリングの値よりも小さくてもよいです。 「T080000 / T210000」は0800から2100までの範囲を特定したがって、一方「T210000 / T080000」は翌日の2100から0800までの範囲を特定します。"
    },
    {
      "indent": 3,
      "text": "When a range spans midnight, it by definition includes parts of two successive days. When one of these days is also selected by either the MonthOfYearMask, DayOfMonthMask, and/or DayOfWeekMask, but the other day is not, then the policy is active only during the portion of the range that falls on the selected day. For example, if the range extends from 2100 until 0800, and the day of week mask selects Monday and Tuesday, then the policy is active during the following three intervals:",
      "ja": "範囲が真夜中にまたがる場合は、定義により、2日連続の部品が含まれています。これらの日のいずれも、いずれかMonthOfYearMask、DayOfMonthMask、及び/又はDayOfWeekMaskによって選択されたが、他の日ではない場合、そのポリシーは、選択された日に当たる範囲の部分の間アクティブです。範囲は2100から0800まで延びており、週マスクの日が月曜日と火曜日を選択した場合、そのポリシーは、次の3回のインターバル中にアクティブであります："
    },
    {
      "indent": 6,
      "text": "From midnight Sunday until 0800 Monday;\nFrom 2100 Monday until 0800 Tuesday;\nFrom 2100 Tuesday until 23:59:59 Tuesday.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME TimeOfDayMask DESCRIPTION The range of times at which a policy rule is valid. If the second time is earlier than the first, then the interval spans midnight. SYNTAX string FORMAT Thhmmss/Thhmmss",
      "ja": "TimeOfDayMask説明ポリシールールが有効であるで倍の範囲に名前を付けます。二回目は、最初よりも前である場合には、間隔が深夜に及びます。 SYNTAX列FORMAT Thhmmss / Thhmmss"
    },
    {
      "indent": 0,
      "text": "6.5.6. The Property \"LocalOrUtcTime\"",
      "section_title": true,
      "ja": "6.5.6. プロパティ「LocalOrUtcTime」"
    },
    {
      "indent": 3,
      "text": "This property indicates whether the times represented in the TimePeriod property and in the various Mask properties represent local times or UTC times. There is no provision for mixing of local times and UTC times: the value of this property applies to all of the other time-related properties.",
      "ja": "このプロパティは、時間期間性および様々なマスクプロパティで表される時間はローカル時間またはUTC時間を表しているかどうかを示します。このプロパティの値は、他の時間に関連するすべてのプロパティに適用されます：ローカル時間とUTC時間の混合のための規定はありません。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME LocalOrUtcTime DESCRIPTION An indication of whether the other times in this instance represent local times or UTC times. SYNTAX uint16 VALUES localTime(1), utcTime(2) DEFAULT VALUE utcTime(2)",
      "ja": "NAME LocalOrUtcTime説明このインスタンス内の他の回は、ローカル時間またはUTC時間を表しているかどうかの表示。 LOCALTIME（1）、UTC時刻（2）デフォルト値UTC時刻（2）の値uint16のSYNTAX"
    },
    {
      "indent": 0,
      "text": "6.6. The Class \"VendorPolicyCondition\"",
      "section_title": true,
      "ja": "6.6. クラス「VendorPolicyCondition」"
    },
    {
      "indent": 3,
      "text": "The purpose of this class is to provide a general extension mechanism for representing policy conditions that have not been modeled with specific properties. Instead, the two properties Constraint and ConstraintEncoding are used to define the content and format of the condition, as explained below.",
      "ja": "このクラスの目的は、特定の性質でモデル化されていないポリシー条件を表す一般的な拡張メカニズムを提供することです。以下に説明するよう代わりに、二つの特性制約とConstraintEncodingは、条件の内容と形式を定義するために使用されます。"
    },
    {
      "indent": 3,
      "text": "As its name suggests, this class is intended for vendor-specific extensions to the Policy Core Information Model. Standardized extensions are not expected to use this class.",
      "ja": "その名のとおり、このクラスは方針コア情報モデルにベンダー固有の拡張を目的としています。標準化された拡張は、このクラスを使用することが期待されていません。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME VendorPolicyCondition DESCRIPTION A class that defines a registered means to describe a policy condition. DERIVED FROM PolicyCondition ABSTRACT FALSE PROPERTIES Constraint[ ] ConstraintEncoding",
      "ja": "NAME VendorPolicyCondition説明ポリシー条件を記述するために登録された手段を定義するクラス。制約は、[] ConstraintEncoding PolicyCondition ABSTRACT FALSEの施設から派生"
    },
    {
      "indent": 0,
      "text": "6.6.1. The Multi-valued Property \"Constraint\"",
      "section_title": true,
      "ja": "6.6.1. 多値プロパティの「制約」"
    },
    {
      "indent": 3,
      "text": "This property provides a general extension mechanism for representing policy conditions that have not been modeled with specific properties. The format of the octet strings in the array is left unspecified in this definition. It is determined by the OID value stored in the property ConstraintEncoding. Since ConstraintEncoding is single-valued, all the values of Constraint share the same format and semantics.",
      "ja": "このプロパティは、特定の性質でモデル化されていないポリシー条件を表す一般的な拡張メカニズムを提供します。配列内のオクテット文字列の形式は、この定義に指定されていないままです。これは、プロパティConstraintEncodingに格納されたOID値によって決定されます。 ConstraintEncodingは単一値であるため、制約のすべての値が同じ形式と意味論を共有します。"
    },
    {
      "indent": 3,
      "text": "See Section 5.4 for a description of how CIM encodes an array of octet strings like this one.",
      "ja": "CIMは、このようなオクテット文字列の配列をコード化する方法については、5.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A policy decision point can readily determine whether it supports the values stored in an instance of Constraint by checking the OID value from ConstraintEncoding against the set of OIDs it recognizes. The action for the policy decision point to take in case it does not recognize the format of this data could itself be modeled as a policy rule, governing the behavior of the policy decision point.",
      "ja": "ポリシー決定ポイントは、容易にそれが認識OIDのセットに対してConstraintEncodingからOID値をチェックすることによって、制約のインスタンスに格納された値をサポートするかどうかを決定することができます。それは、このデータの形式を認識しない場合にとるべき政策決定ポイントのためのアクションは、それ自体は、ポリシー決定ポイントの振る舞いを支配する、ポリシールールとしてモデル化することができます。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME Constraint DESCRIPTION Extension mechanism for representing constraints that have not been modeled as specific properties. The format of the values is identified by the OID stored in the property ConstraintEncoding. SYNTAX octet string",
      "ja": "特定のプロパティとしてモデル化されていない制約を表すためのNAME制約説明拡張メカニズム。値のフォーマットは、プロパティConstraintEncodingに格納されたOIDによって識別されます。 SYNTAXオクテット文字列"
    },
    {
      "indent": 0,
      "text": "6.6.2. The Property \"ConstraintEncoding\"",
      "section_title": true,
      "ja": "6.6.2. プロパティ「ConstraintEncoding」"
    },
    {
      "indent": 3,
      "text": "This property identifies the encoding and semantics of the Constraint property values in this instance. The value of this property is a single string, representing a single OID.",
      "ja": "このプロパティは、この場合の符号化および制約プロパティ値の意味を識別する。このプロパティの値は、単一のOIDを表す単一の文字列です。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME ConstraintEncoding DESCRIPTION An OID encoded as a string, identifying the format and semantics for this instance's Constraint property. The value is a dotted sequence of decimal digits (for example, \"1.2.100.200\") representing the arcs of the OID. The characters in the string are the UCS-2 characters corresponding to the US ASCII encodings of the numeric characters and the period. SYNTAX string",
      "ja": "NAME Con​​straintEncoding説明アンOIDは、このインスタンスの制約プロパティのフォーマット及びセマンティクスを識別する文字列として符号化されます。値は、OIDの弧を表す桁の点線の配列（例えば、「1.2.100.200」）です。文字列内の文字には、数字と期間の米国のASCIIエンコーディングに対応するUCS-2文字です。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.7. The Abstract Class \"PolicyAction\"",
      "section_title": true,
      "ja": "6.7. 抽象クラス「PolicyAction」"
    },
    {
      "indent": 3,
      "text": "The purpose of a policy action is to execute one or more operations that will affect network traffic and/or systems, devices, etc., in order to achieve a desired state. This (new) state provides one or more (new) behaviors. A policy action ordinarily changes the configuration of one or more elements.",
      "ja": "ポリシーアクションの目的は、所望の状態を達成するために、等、ネットワークトラフィック及び/又はシステム、デバイスに影響を与える1つ以上の操作を実行することです。この（新しい）状態は、一つ以上の（新しい）の動作を提供します。ポリシーアクションは、通常、1つの以上の要素の構成を変更します。"
    },
    {
      "indent": 3,
      "text": "A PolicyRule contains one or more policy actions. A policy administrator can assign an order to the actions associated with a PolicyRule, complete with an indication of whether the indicated order is mandatory, recommended, or of no significance. Ordering of the actions associated with a PolicyRule is accomplished via a property in the PolicyActionInPolicyRule aggregation.",
      "ja": "PolicyRuleのは、1つまたは複数のポリシーアクションが含まれています。ポリシー管理者は、示された順序は、必須で推奨、または全く有意のかどうかの指示とのPolicyRuleに関連付けられたアクション、完全に順序を割り当てることができます。 PolicyRuleの関連付けられたアクションの順序はPolicyActionInPolicyRule集合内のプロパティを介して達成されます。"
    },
    {
      "indent": 3,
      "text": "The actions associated with a PolicyRule are executed if and only if the overall condition(s) of the PolicyRule evaluates to TRUE.",
      "ja": "PolicyRuleの全体的な状態（複数可）がTRUEと評価する場合にのみ場合のPolicyRuleに関連付けられたアクションが実行されます。"
    },
    {
      "indent": 3,
      "text": "The class definition of PolicyAction is as follows:",
      "ja": "次のようにPolicyActionのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyAction DESCRIPTION A class representing a rule-specific or reusable policy action to be performed if the condition for a policy rule evaluates to TRUE. DERIVED FROM Policy ABSTRACT TRUE PROPERTIES NONE",
      "ja": "ポリシールールの条件がTRUEと評価された場合NAME PolicyAction説明は、ルール固有または再利用可能なポリシーアクションを表すクラスが実行されます。ポリシーABSTRACT TRUE PROPERTIESのNONEから派生して"
    },
    {
      "indent": 3,
      "text": "No properties are defined for this class since it inherits all its properties from Policy. The class exists as an abstract superclass for domain-specific policy actions, defined in subclasses. In an implementation, various key/identification properties MUST be defined for the class or its instantiable subclasses. The keys for a native CIM implementation are defined in Appendix A, Section 13.3. Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].",
      "ja": "それはポリシーからすべてのプロパティを継承するので、何のプロパティは、このクラスに定義されていません。クラスは、サブクラスで定義されたドメイン固有のポリシーアクションのための抽象スーパークラスとして存在しています。インプリメンテーションでは、様々なキー/識別プロパティは、クラスまたはそのサブクラスインスタンス化のために定義されなければなりません。ネイティブのCIM実装のためのキーは、付録A、13.3節で定義されています。 LDAP実装の鍵は、この情報モデル[11]のLDAPマッピングで定義されます。"
    },
    {
      "indent": 3,
      "text": "When identifying and using the PolicyAction class, it is necessary to remember that an action can be rule-specific or reusable. This was discussed above in Section 5.1. The distinction between the two types of policy actions lies in the associations in which an instance can participate, and in how the different instances are named. Conceptually, a reusable policy action resides in a policy repository, and is named within the scope of that repository. On the other hand, a rule-specific policy action is named within the scope of the single policy rule to which it is related.",
      "ja": "識別とPolicyActionのクラスを使用する場合は、アクションは、ルール固有の又は再使用可能とすることができることを覚えておくことが必要です。これは、セクション5.1で前述しました。ポリシーアクションの2種類の区別は、インスタンスが参加できる団体で、かつ異なるインスタンスは付けの方法です。概念的には、再利用可能なポリシーアクションは、ポリシー・リポジトリ内に存在し、そのリポジトリの範囲内で命名されました。一方、ルール固有のポリシー・アクションは、それが関連する単一のポリシールールの範囲内で命名されています。"
    },
    {
      "indent": 3,
      "text": "The distinction between rule-specific and reusable PolicyActions affects the CIM naming, defined in Appendix A, and the LDAP mapping [11].",
      "ja": "ルール固有の再利用可能なポリシーアクションの区別は、付録Aで定義されたCIM命名、およびLDAPマッピング[11]に影響します。"
    },
    {
      "indent": 0,
      "text": "6.8. The Class \"VendorPolicyAction\"",
      "section_title": true,
      "ja": "6.8. クラス「VendorPolicyAction」"
    },
    {
      "indent": 3,
      "text": "The purpose of this class is to provide a general extension mechanism for representing policy actions that have not been modeled with specific properties. Instead, the two properties ActionData and ActionEncoding are used to define the content and format of the action, as explained below.",
      "ja": "このクラスの目的は、特定の性質でモデル化されていないポリシーアクションを表現するための一般的な拡張メカニズムを提供することです。以下に説明するよう代わりに、二つの特性ActionDataとActionEncodingは、アクションの内容と形式を定義するために使用されます。"
    },
    {
      "indent": 3,
      "text": "As its name suggests, this class is intended for vendor-specific extensions to the Policy Core Information Model. Standardized extensions are not expected to use this class.",
      "ja": "その名のとおり、このクラスは方針コア情報モデルにベンダー固有の拡張を目的としています。標準化された拡張は、このクラスを使用することが期待されていません。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME VendorPolicyAction DESCRIPTION A class that defines a registered means to describe a policy action. DERIVED FROM PolicyAction ABSTRACT FALSE PROPERTIES ActionData[ ] ActionEncoding",
      "ja": "NAME VendorPolicyAction説明ポリシーアクションを記述するために登録された手段を定義するクラス。 PolicyAction ABSTRACT FALSEの施設から派生ActionData [] ActionEncoding"
    },
    {
      "indent": 0,
      "text": "6.8.1. The Multi-valued Property \"ActionData\"",
      "section_title": true,
      "ja": "6.8.1. 多値プロパティ「ActionData」"
    },
    {
      "indent": 3,
      "text": "This property provides a general extension mechanism for representing policy actions that have not been modeled with specific properties. The format of the octet strings in the array is left unspecified in this definition. It is determined by the OID value stored in the property ActionEncoding. Since ActionEncoding is single-valued, all the values of ActionData share the same format and semantics. See Section 5.4 for a discussion of how CIM encodes an array of octet strings like this one.",
      "ja": "このプロパティは、特定の性質でモデル化されていないポリシーアクションを表現するための一般的な拡張メカニズムを提供します。配列内のオクテット文字列の形式は、この定義に指定されていないままです。これは、プロパティActionEncodingに格納されたOID値によって決定されます。 ActionEncodingは単一値であるため、ActionDataのすべての値が同じ形式と意味論を共有します。 CIMは、このようなオクテット文字列の配列をエンコードする方法についての説明は、5.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A policy decision point can readily determine whether it supports the values stored in an instance of ActionData by checking the OID value from ActionEncoding against the set of OIDs it recognizes. The action for the policy decision point to take in case it does not recognize the format of this data could itself be modeled as a policy rule, governing the behavior of the policy decision point.",
      "ja": "ポリシー決定ポイントは、容易にそれが認識OIDのセットに対してActionEncodingからOID値をチェックすることによってActionDataのインスタンスに格納された値をサポートするかどうかを決定することができます。それは、このデータの形式を認識しない場合にとるべき政策決定ポイントのためのアクションは、それ自体は、ポリシー決定ポイントの振る舞いを支配する、ポリシールールとしてモデル化することができます。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME ActionData DESCRIPTION Extension mechanism for representing actions that have not been modeled as specific properties. The format of the values is identified by the OID stored in the property ActionEncoding. SYNTAX octet string",
      "ja": "特定のプロパティとしてモデル化されていないアクションを表すためActionData DESCRIPTION拡張メカニズムに名前を付けます。値のフォーマットは、プロパティActionEncodingに格納されたOIDによって識別されます。 SYNTAXオクテット文字列"
    },
    {
      "indent": 0,
      "text": "6.8.2. The Property \"ActionEncoding\"",
      "section_title": true,
      "ja": "6.8.2. プロパティ「ActionEncoding」"
    },
    {
      "indent": 3,
      "text": "This property identifies the encoding and semantics of the ActionData property values in this instance. The value of this property is a single string, representing a single OID.",
      "ja": "このプロパティは、この場合の符号化およびActionDataプロパティ値の意味を識別する。このプロパティの値は、単一のOIDを表す単一の文字列です。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME ActionEncoding DESCRIPTION An OID encoded as a string, identifying the format and semantics for this instance's ActionData property. The value is a dotted sequence of decimal digits (for example, \"1.2.100.200\") representing the arcs of the OID. The characters in the string are the UCS-2 characters corresponding to the US ASCII encodings of the numeric characters and the period. SYNTAX string",
      "ja": "NAME ActionEncoding説明アンOIDは、このインスタンスのActionDataプロパティのフォーマット及びセマンティクスを識別する文字列として符号化されます。値は、OIDの弧を表す桁の点線の配列（例えば、「1.2.100.200」）です。文字列内の文字には、数字と期間の米国のASCIIエンコーディングに対応するUCS-2文字です。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.9. The Class \"PolicyRepository\"",
      "section_title": true,
      "ja": "6.9. クラス「PolicyRepository」"
    },
    {
      "indent": 3,
      "text": "The class definition of PolicyRepository is as follows:",
      "ja": "次のようにPolicyRepositoryのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRepository DESCRIPTION A class representing an administratively defined container for reusable policy-related information. This class does not introduce any additional properties beyond those in its superclass AdminDomain. It does, however, participate in a number of unique associations. DERIVED FROM AdminDomain ABSTRACT FALSE",
      "ja": "NAME PolicyRepository DESCRIPTION再利用可能なポリシー関連情報のための管理者が定義コンテナを表すクラス。このクラスは、そのスーパークラスのいるAdminDomainのものを超えて追加のプロパティを導入しません。それは、しかし、ユニークな関連付けの数に参加しません。 FALSEいるAdminDomain ABSTRACTから、派生"
    },
    {
      "indent": 0,
      "text": "7. Association and Aggregation Definitions",
      "section_title": true,
      "ja": "7.協会と集約の定義"
    },
    {
      "indent": 3,
      "text": "The first two subsections of this section introduce associations and aggregations as they are used in CIM. The remaining subsections present the class definitions for the associations and aggregations that are part of the Policy Core Information Model.",
      "ja": "これらはCIMに使用されているように、このセクションの最初の2つのサブセクションには、団体や集計を紹介します。残りのサブセクションでは、ポリシーコア情報モデルの一部である団体や集計のためのクラス定義を提示します。"
    },
    {
      "indent": 0,
      "text": "7.1. Associations",
      "section_title": true,
      "ja": "7.1. 協会"
    },
    {
      "indent": 3,
      "text": "An association is a CIM construct representing a relationship between two (or theoretically more) objects. It is modeled as a class containing typically two object references. Associations can be defined between classes without affecting any of the related classes. That is, addition of an association does not affect the interface of the related classes.",
      "ja": "関連は、2つ（またはそれ以上の理論的に）オブジェクト間の関係を表すCIM構築物です。これは、一般的に2つのオブジェクト参照を含むクラスとしてモデル化されます。協会は、関連するクラスのいずれかに影響を与えることなく、クラスの間で定義することができます。つまり、関連の追加は、関連するクラスのインタフェースには影響を与えません。"
    },
    {
      "indent": 0,
      "text": "7.2. Aggregations",
      "section_title": true,
      "ja": "7.2. 集計"
    },
    {
      "indent": 3,
      "text": "An aggregation is a strong form of an association, which usually represents a \"whole-part\" or a \"collection\" relationship. For example, CIM uses an aggregation to represent the containment relationship between a system and the components that make up the system. Aggregation as a \"whole-part\" relationship often implies, but does not require, that the aggregated objects have mutual dependencies.",
      "ja": "凝集は通常、「全部分」または「コレクション」の関係を表す関連の強い形態です。例えば、CIMは、システムとシステムを構成するコンポーネント間の包含関係を表すために集合を使用します。 「全体の部分」の関係として集約は多くの場合、集約されたオブジェクトが相互依存関係を持っていること、を意味しますが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "7.3. The Abstract Aggregation \"PolicyComponent",
      "section_title": true,
      "ja": "7.3. 抽象集約「PolicyComponent"
    },
    {
      "indent": 3,
      "text": "This abstract aggregation defines two object references that will be overridden in each of five subclasses, to become references to the concrete policy classes PolicyGroup, PolicyRule, PolicyCondition, PolicyAction, and PolicyTimePeriodCondition. The value of the abstract superclass is to convey that all five subclasses have the same \"whole- part\" semantics, and for ease of query to locate all \"components\" of a PolicyGroup or PolicyRule.",
      "ja": "この抽象集合コンクリートポリシークラスのPolicyGroup、PolicyRuleの、PolicyCondition、PolicyAction、及びPolicyTimePeriodConditionへの参照になるように、5つのサブクラスの各々でオーバーライドされる2つのオブジェクト参照を定義します。抽象スーパークラスの値は、すべての5つのサブクラスが同じ「whole-部」の意味を持っていることを伝えることで、クエリを容易にするためのPolicyGroupかPolicyRuleのすべての「コンポーネント」を検索します。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyComponent DESCRIPTION A generic aggregation used to establish 'part of' relationships between the subclasses of Policy. For example, the PolicyConditionInPolicyRule aggregation defines that PolicyConditions are part of a PolicyRule. ABSTRACT TRUE PROPERTIES GroupComponent[ref Policy[0..n]] PartComponent[ref Policy[0..n]]",
      "ja": "NAME PolicyComponent説明ポリシーのサブクラスの関係「の部分を」確立するために使用される一般的な集合。例えば、PolicyConditionInPolicyRule凝集はPolicyConditionsがPolicyRuleの一部であることを規定しています。 ABSTRACT TRUE PROPERTIES GroupComponent [参照ポリシー[0..N]] PartComponent [参照ポリシー[0..N]]"
    },
    {
      "indent": 0,
      "text": "7.4. The Aggregation \"PolicyGroupInPolicyGroup\"",
      "section_title": true,
      "ja": "7.4. 集計「PolicyGroupInPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "The PolicyGroupInPolicyGroup aggregation enables policy groups to be nested. This is critical for scalability and manageability, as it enables complex policies to be constructed from multiple simpler policies for administrative convenience. For example, a policy group representing policies for the US might have nested within it policy groups for the Eastern and Western US.",
      "ja": "PolicyGroupInPolicyGroup集約は、ポリシーグループを入れ子にすることができます。それは複雑なポリシーが管理者の利便のために複数の単純なポリシーから構築することができますので、これは、拡張性と管理性のために重要です。例えば、米国のポリシーを表すポリシー・グループは、東洋と西洋の米国向けITポリシーグループ内にネストされている場合があります。"
    },
    {
      "indent": 3,
      "text": "A PolicyGroup may aggregate other PolicyGroups via this aggregation, or it may aggregate PolicyRules via the PolicyRuleInPolicyGroup aggregation. Note that it is assumed that this aggregation is used to form directed acyclic graphs and NOT ring structures.The class definition for the aggregation is as follows:",
      "ja": "PolicyGroupがこの集合を介して他PolicyGroupsを集約することができる、またはそれはPolicyRuleInPolicyGroup凝集介しPolicyRulesを集約することができます。この凝集は有向非循環グラフを形成するために使用され、凝集は以下の通りであるためstructures.Theクラス定義を環ではないことが想定されることに注意してください。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyGroupInPolicyGroup DESCRIPTION A class representing the aggregation of PolicyGroups by a higher-level PolicyGroup. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyGroup[0..n]] PartComponent[ref PolicyGroup[0..n]]",
      "ja": "NAME PolicyGroupInPolicyGroup DESCRIPTION上位のPolicyGroupによってPolicyGroupsの集合を表すクラス。 PolicyComponent ABSTRACT FALSE施設から派生GroupComponent [参考文献のPolicyGroup [0..N] PartComponent [参考文献のPolicyGroup [0..N]"
    },
    {
      "indent": 0,
      "text": "7.4.1. The Reference \"GroupComponent\"",
      "section_title": true,
      "ja": "7.4.1. リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup that contains one or more other PolicyGroups. Note that for any single instance of the aggregation class PolicyGroupInPolicyGroup, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyGroups that contain any given PolicyGroup.",
      "ja": "このプロパティは、PolicyComponentから継承され、そして一つ以上の他のPolicyGroupsを含有たPolicyGroupへのオブジェクト参照になるように上書きされます。集約クラスPolicyGroupInPolicyGroupの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、または任意の所与のPolicyGroupを含む複数PolicyGroupsが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.4.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.4.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup contained by one or more other PolicyGroups. Note that for any single instance of the aggregation class PolicyGroupInPolicyGroup, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyGroup may contain 0, 1, or more than one other PolicyGroups.",
      "ja": "このプロパティは、PolicyComponentから継承され、そして一つ以上の他のPolicyGroupsによって含まれたPolicyGroupへのオブジェクト参照になるように上書きされます。集約クラスPolicyGroupInPolicyGroupの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyGroupは0、1、又は複数の他のPolicyGroupsを含んでいてもよいことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.5. The Aggregation \"PolicyRuleInPolicyGroup\"",
      "section_title": true,
      "ja": "7.5. 集計「PolicyRuleInPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "A policy group may aggregate one or more policy rules, via the PolicyRuleInPolicyGroup aggregation. Grouping of policy rules into a policy group is again for administrative convenience; a policy rule may also be used by itself, without belonging to a policy group.",
      "ja": "ポリシーグループはPolicyRuleInPolicyGroup凝集を介して、1つまたは複数のポリシー・ルールを集約することができます。ポリシーグループへのポリシールールのグループ化は、行政の便宜のために再びです。ポリシールールは、ポリシー・グループに属することなく、単独で使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "A PolicyGroup may aggregate PolicyRules via this aggregation, or it may aggregate other PolicyGroups via the PolicyGroupInPolicyGroup aggregation.",
      "ja": "PolicyGroupがこの集合を介しPolicyRulesを集約することができる、またはそれはPolicyGroupInPolicyGroup凝集を介して他PolicyGroupsを集約することができます。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRuleInPolicyGroup DESCRIPTION A class representing the aggregation of PolicyRules by a PolicyGroup. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyGroup[0..n]] PartComponent[ref PolicyRule[0..n]]",
      "ja": "NAME PolicyRuleInPolicyGroup DESCRIPTIONのPolicyGroupによってPolicyRulesの集合を表すクラス。 PolicyComponent ABSTRACT FALSE施設から派生GroupComponent [参考文献のPolicyGroup [0..N] PartComponent [PolicyRuleの[0..N]参考文献]"
    },
    {
      "indent": 0,
      "text": "7.5.1. The Reference \"GroupComponent\"",
      "section_title": true,
      "ja": "7.5.1. リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup that contains one or more PolicyRules. Note that for any single instance of the aggregation class PolicyRuleInPolicyGroup, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyGroups that contain any given PolicyRule.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyRulesを含有たPolicyGroupへのオブジェクト参照になるように上書きされます。集約クラスPolicyRuleInPolicyGroupの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、または任意の所与のPolicyRuleを含む複数PolicyGroupsが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.5.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.5.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule contained by one or more PolicyGroups. Note that for any single instance of the aggregation class PolicyRuleInPolicyGroup, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyGroup may contain 0, 1, or more than one PolicyRules.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyGroupsによって含まれたPolicyRuleへのオブジェクト参照になるように上書きされます。集約クラスPolicyRuleInPolicyGroupの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyGroupは0、1、又は複数のPolicyRulesを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.6. The Aggregation \"PolicyConditionInPolicyRule\"",
      "section_title": true,
      "ja": "7.6. 集計「PolicyConditionInPolicyRule」"
    },
    {
      "indent": 3,
      "text": "A policy rule aggregates zero or more instances of the PolicyCondition class, via the PolicyConditionInPolicyRule association. A policy rule that aggregates zero policy conditions must indicate in its class definition what \"triggers\" the performance of its actions. In short, it must describe its implicit PolicyConditions, since none are explicitly associated. For example, there might be a subclass of PolicyRule named \"HttpPolicyRule\", where the class definition assumes that the condition, \"If HTTP traffic,\" is true before the rule's actions would be performed. There is no need to formalize and instantiate this condition, since it is obvious in the semantics of the PolicyRule.",
      "ja": "ポリシー・ルールはPolicyConditionInPolicyRule会合を介して、PolicyConditionのクラスのゼロ以上のインスタンスを集約します。ゼロポリシー条件を集約ポリシールールは、そのアクションのパフォーマンスを「トリガー」何そのクラス定義で指定する必要があります。何も明示的に関連付けられていないので、要するに、それは、その暗黙のPolicyConditionsを記述する必要があります。たとえば、という名前のPolicyRuleのサブクラスがあるかもしれない「HttpPolicyRule」、クラス定義は、ルールのアクションが実行される前の状態は、「HTTPトラフィックの場合は、」真実であることを前提としています。正式それはPolicyRuleの意味論の中に明らかであるから、この条件をインスタンス化する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The conditions aggregated by a policy rule are grouped into two levels of lists: either an ORed set of ANDed sets of conditions (DNF, the default) or an ANDed set of ORed sets of conditions (CNF). Individual conditions in these lists may be negated. The property ConditionListType (in PolicyRule) specifies which of these two grouping schemes applies to a particular PolicyRule. The conditions are used to determine whether to perform the actions associated with the PolicyRule.",
      "ja": "ポリシールールによって集約条件はリストの2つのレベルに分類されます条件の論理積集合（DNF、デフォルト）または条件の論理和集合の論理積集合（CNF）のいずれかの論理和集合。これらのリスト内の個々の条件は否定することができます。 （PolicyRuleの中の）プロパティConditionListTypeは、特定のPolicyRuleに適用されるこれら二つのグループ化スキームのかを指定します。条件はPolicyRuleの関連付けられたアクションを実行するかどうかを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "One or more policy time periods may be among the conditions associated with a policy rule via the PolicyConditionInPolicyRule association. In this case, the time periods are simply additional conditions to be evaluated along with any other conditions specified for the rule.",
      "ja": "1つまたは複数のポリシー期間はPolicyConditionInPolicyRuleアソシエーションを介してポリシールールに関連付けられた条件の中であってもよいです。この場合には、期間は、単にルールに対して指定された任意の他の条件に沿って評価されるべき追加の条件です。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyConditionInPolicyRule DESCRIPTION A class representing the aggregation of PolicyConditions by a PolicyRule. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRule[0..n]] PartComponent[ref PolicyCondition[0..n]] GroupNumber ConditionNegated",
      "ja": "NAME PolicyConditionInPolicyRule DESCRIPTIONのPolicyRuleによってPolicyConditionsの集合を表すクラス。 PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent [参考文献のPolicyRule [0..N] PartComponent [REF PolicyCondition [0..N] GroupNumber ConditionNegatedから、派生"
    },
    {
      "indent": 0,
      "text": "7.6.1. The Reference \"GroupComponent\"",
      "section_title": true,
      "ja": "7.6.1. リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyConditions. Note that for any single instance of the aggregation class PolicyConditionInPolicyRule, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyCondition.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyConditionsが含まPolicyRuleのへのオブジェクト参照になるように上書きされます。集約クラスPolicyConditionInPolicyRuleの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、又は任意のPolicyConditionを含む複数PolicyRulesが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.6.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.6.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyCondition contained by one or more PolicyRules. Note that for any single instance of the aggregation class PolicyConditionInPolicyRule, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one PolicyConditions.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyRulesによって含まPolicyConditionへのオブジェクト参照になるように上書きされます。集約クラスPolicyConditionInPolicyRuleの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRuleは0、1、又は複数のPolicyConditionsを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.6.3. The Property \"GroupNumber\"",
      "section_title": true,
      "ja": "7.6.3. プロパティ「GroupNumber」"
    },
    {
      "indent": 3,
      "text": "This property contains an integer identifying the group to which the condition referenced by the PartComponent property is assigned in forming the overall conditional expression for the policy rule identified by the GroupComponent reference.",
      "ja": "このプロパティは、PartComponentプロパティによって参照される状態がGroupComponent参照によって識別ポリシールールのための全体的な条件式を形成する際に割り当てられているグループを特定する整数を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME GroupNumber DESCRIPTION Unsigned integer indicating the group to which the condition identified by the PartComponent property is to be assigned. SYNTAX uint16 DEFAULT 0",
      "ja": "PartComponentプロパティによって識別された条件が割り当てられる先のグループを示すNAME GroupNumber説明符号なし整数。構文uint16のはDEFAULT 0"
    },
    {
      "indent": 0,
      "text": "7.6.4. The Property \"ConditionNegated\"",
      "section_title": true,
      "ja": "7.6.4. プロパティ「ConditionNegated」"
    },
    {
      "indent": 3,
      "text": "This property is a boolean, indicating whether the condition referenced by the PartComponent property is negated in forming the overall conditional expression for the policy rule identified by the GroupComponent reference.",
      "ja": "このプロパティは、PartComponentプロパティによって参照される条件がGroupComponent参照によって識別ポリシールールのための全体的な条件式を形成する際に否定されているかどうかを示すブール値です。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME ConditionNegated DESCRIPTION Indication of whether the condition identified by the PartComponent property is negated. (TRUE indicates that the condition is negated, FALSE indicates that it is not negated.) SYNTAX boolean DEFAULT FALSE",
      "ja": "PartComponentプロパティによって識別された条件が否定されているかどうかのNAME Con​​ditionNegated説明指示。 FALSE（TRUEはFALSEは、それが否定されていないことを示し、条件が否定されていることを示す。）構文ブールDEFAULT"
    },
    {
      "indent": 0,
      "text": "7.7. The Aggregation \"PolicyRuleValidityPeriod\"",
      "section_title": true,
      "ja": "7.7. 集計「PolicyRuleValidityPeriod」"
    },
    {
      "indent": 3,
      "text": "A different relationship between a policy rule and a policy time period (than PolicyConditionInPolicyRule) is represented by the PolicyRuleValidityPeriod aggregation. The latter describes scheduled activation and deactivation of the policy rule.",
      "ja": "ポリシールールおよびポリシー時間（PolicyConditionInPolicyRuleより）との間の異なる関係がPolicyRuleValidityPeriodアグリゲーションによって表されます。後者は、ポリシールールのスケジュールされたアクティブ化および非アクティブ化を記載しています。"
    },
    {
      "indent": 3,
      "text": "If a policy rule is associated with multiple policy time periods via this association, then the rule is active if at least one of the time periods indicates that it is active. (In other words, the time periods are ORed to determine whether the rule is active.) A policy time period may be aggregated by multiple policy rules. A rule that does not point to a policy time period via this aggregation is, from the point of view of scheduling, always active. It may, however, be inactive for other reasons.",
      "ja": "ポリシールールがこの関連付けを介して複数のポリシーの期間に関連付けられている場合の期間のうちの少なくとも一つは、それがアクティブであることを示す場合、その後、ルールがアクティブです。 （換言すれば、期間は、ルールがアクティブであるかどうかを決定するために論理和される。）ポリシー期間が複数のポリシールールによって集約されてもよいです。この集合を経由してポリシーの期間を指していないルールは常に、スケジューリングの観点から、アクティブです。それは、しかし、他の理由のために不活性であり得ます。"
    },
    {
      "indent": 3,
      "text": "Time periods are a general concept that can be used in other applications. However, they are mentioned explicitly here in this specification since they are frequently used in policy applications.",
      "ja": "期間は、他のアプリケーションで使用することができ、一般的な概念です。彼らは頻繁にポリシーアプリケーションで使用されているので、しかし、彼らはこの仕様書で明示的にここに記載されています。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRuleValidityPeriod DESCRIPTION A class representing the aggregation of PolicyTimePeriodConditions by a PolicyRule. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRule[0..n]] PartComponent[ref PolicyTimePeriodCondition[0..n]]",
      "ja": "NAME PolicyRuleValidityPeriod DESCRIPTIONのPolicyRuleによってPolicyTimePeriodConditionsの集合を表すクラス。 PolicyComponent ABSTRACT FALSE施設から派生GroupComponent PartComponent [PolicyRuleの[0..N]参考文献] [PolicyTimePeriodCondition [0..N]参考文献]"
    },
    {
      "indent": 0,
      "text": "7.7.1. The Reference \"GroupComponent\"",
      "section_title": true,
      "ja": "7.7.1. リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyTimePeriodConditions. Note that for any single instance of the aggregation class PolicyRuleValidityPeriod, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyTimePeriodCondition.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyTimePeriodConditionsが含まPolicyRuleのへのオブジェクト参照になるように上書きされます。集約クラスPolicyRuleValidityPeriodの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、又は任意のPolicyTimePeriodConditionを含む複数PolicyRulesが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.7.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.7.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyTimePeriodCondition contained by one or more PolicyRules. Note that for any single instance of the aggregation class PolicyRuleValidityPeriod, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one PolicyTimePeriodConditions.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyRulesによって含まPolicyTimePeriodConditionへのオブジェクト参照になるように上書きされます。集約クラスPolicyRuleValidityPeriodの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRuleは0、1、又は複数のPolicyTimePeriodConditionsを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.8. The Aggregation \"PolicyActionInPolicyRule\"",
      "section_title": true,
      "ja": "7.8. 集計「PolicyActionInPolicyRule」"
    },
    {
      "indent": 3,
      "text": "A policy rule may aggregate zero or more policy actions. A policy rule that aggregates zero policy actions must indicate in its class definition what actions are taken when the rule's conditions evaluate to TRUE. In short, it must describe its implicit PolicyActions, since none are explicitly associated. For example, there might be a subclass of PolicyRule representing a Diffserv absolute dropper, where the subclass itself indicates the action to be taken. There is no need to formalize and instantiate this action, since it is obvious in the semantics of the PolicyRule.",
      "ja": "ポリシールールは、ゼロ以上のポリシーアクションを集約することができます。ゼロ政策行動を集約ポリシールールは、ルールの条件がTRUEに評価したときのアクションが取られているか、そのクラス定義で指定する必要があります。何も明示的に関連付けられていないので、要するに、それは、その暗黙のPolicyActionsを記述する必要があります。例えば、サブクラス自体が実行するアクションを示すDiffservの絶対点滴器を表すPolicyRuleのサブクラスがあるかもしれません。正式それはPolicyRuleの意味論の中に明らかであることから、このアクションをインスタンス化する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The actions associated with a PolicyRule may be given a required order, a recommended order, or no order at all. For actions represented as separate objects, the PolicyActionInPolicyRule aggregation can be used to express an order.",
      "ja": "PolicyRuleの関連付けられたアクションが必要順、推奨順序、または全く順序を与えることができます。別個のオブジェクトとして表されるアクションのために、PolicyActionInPolicyRule凝集が順序を発現するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "This aggregation does not indicate whether a specified action order is required, recommended, or of no significance; the property SequencedActions in the aggregating instance of PolicyRule provides this indication.",
      "ja": "この凝集は、指定されたアクションの順序は、必要な推奨、または重要ではないかどうかを示すものではありません。 PolicyRuleの凝集のインスタンス内のプロパティSequencedActionsは、この指標を提供します。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyActionInPolicyRule DESCRIPTION A class representing the aggregation of PolicyActions by a PolicyCondition. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRule[0..n]] PartComponent[ref PolicyAction[0..n]] ActionOrder",
      "ja": "NAME PolicyActionInPolicyRule DESCRIPTION PolicyConditionによってPolicyActionsの集合を表すクラス。 PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent [参考文献のPolicyRule [0..N] PartComponent [REF PolicyAction [0..N] ActionOrderから、派生"
    },
    {
      "indent": 0,
      "text": "7.8.1. The Reference \"GroupComponent\"",
      "section_title": true,
      "ja": "7.8.1. リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyActions. Note that for any single instance of the aggregation class PolicyActionInPolicyRule, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyAction.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyActionsが含まPolicyRuleのへのオブジェクト参照になるように上書きされます。集約クラスPolicyActionInPolicyRuleの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、又は任意のPolicyActionを含む複数PolicyRulesが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.8.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.8.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyAction contained by one or more PolicyRules. Note that for any single instance of the aggregation class PolicyActionInPolicyRule, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one PolicyActions.",
      "ja": "このプロパティは、PolicyComponentから継承、および1つまたは複数のPolicyRulesによって含まPolicyActionへのオブジェクト参照になるように上書きされます。集約クラスPolicyActionInPolicyRuleの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRuleは0、1、又は複数のPolicyActionsを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.8.3. The Property \"ActionOrder\"",
      "section_title": true,
      "ja": "7.8.3. プロパティ「ActionOrder」"
    },
    {
      "indent": 3,
      "text": "This property provides an unsigned integer 'n' that indicates the relative position of an action in the sequence of actions associated with a policy rule. When 'n' is a positive integer, it indicates a place in the sequence of actions to be performed, with smaller integers indicating earlier positions in the sequence. The special value '0' indicates \"don't care\". If two or more actions have the same non-zero sequence number, they may be performed in any order, but they must all be performed at the appropriate place in the overall action sequence.",
      "ja": "このプロパティは、ポリシールールに関連付けられたアクションのシーケンスにおける作用の相対的位置を示す符号なし整数「N」を提供します。場合「n」は正の整数であり、それは配列で、以前の位置を示す小さな整数で、実行されるべきアクションのシーケンスで行わを示します。特別な値は「0」「気にしない」を示しています。二つ以上のアクションは同じ非ゼロのシーケンス番号を持っている場合、彼らは任意の順序で実行することができるが、それらはすべて、全体的なアクションシーケンスの適切な場所で実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "A series of examples will make ordering of actions clearer:",
      "ja": "一連の例は、アクションの順序付けをより明確になります。"
    },
    {
      "indent": 3,
      "text": "o If all actions have the same sequence number, regardless of whether it is '0' or non-zero, any order is acceptable.",
      "ja": "すべてのアクションが同じシーケンス番号を有する場合、Oかかわらず、それは「0」または非ゼロであるかどうか、任意の順序が許容されます。"
    },
    {
      "indent": 3,
      "text": "o The values",
      "ja": "値O"
    },
    {
      "indent": 6,
      "text": "1:ACTION A 2:ACTION B 1:ACTION C 3:ACTION D",
      "ja": "1：ACTION A 2：アクションB 1：ACTION C 3：ACTION D"
    },
    {
      "indent": 6,
      "text": "indicate two acceptable orders: A,C,B,D or C,A,B,D, since A and C can be performed in either order, but only at the '1' position.",
      "ja": "AとCはだけ '1' の位置で、いずれかの順序で行うことができるので、D、B、A、A、C、B、DまたはC 2件の許容されるオーダーを示します。"
    },
    {
      "indent": 3,
      "text": "o The values",
      "ja": "値O"
    },
    {
      "indent": 6,
      "text": "0:ACTION A 2:ACTION B 3:ACTION C 3:ACTION D",
      "ja": "0：ACTION A 2：アクションB 3：ACTION C 3：ACTION D"
    },
    {
      "indent": 6,
      "text": "require that B,C, and D occur either as B,C,D or as B,D,C. Action A may appear at any point relative to B,C, and D. Thus the complete set of acceptable orders is: A,B,C,D; B,A,C,D; B,C,A,D; B,C,D,A; A,B,D,C; B,A,D,C; B,D,A,C; B,D,C,A.",
      "ja": "B、C、及びDは、B、C、Dとして、またはB、D、Cのいずれかとして発生することを必要とします。アクションAはB、C、およびDに対する任意の時点で表示されることがこのように許容される注文の完全なセットである：A、B、C、D。 B、A、C、D。 B、C、A、D。 B、C、D、A。 、B、D、C。 B、A、D、C。 B、D、A、C。 B、D、C、A。"
    },
    {
      "indent": 6,
      "text": "Note that the non-zero sequence numbers need not start with '1', and they need not be consecutive. All that matters is their relative magnitude.",
      "ja": "非ゼロのシーケンス番号が「1」で始める必要はないことに注意してください、そして、彼らは連続している必要はありません。重要なのは、それらの相対的な大きさです。"
    },
    {
      "indent": 6,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 6,
      "text": "NAME ActionOrder DESCRIPTION Unsigned integer indicating the relative position of an action in the sequence of actions aggregated by a policy rule. SYNTAX uint16",
      "ja": "ポリシールールによって集約アクションのシーケンスにおける作用の相対的位置を示すNAME ActionOrder説明符号なし整数。構文uint16の"
    },
    {
      "indent": 0,
      "text": "7.9. The Abstract Association \"PolicyInSystem\"",
      "section_title": true,
      "ja": "7.9. 抽象協会「PolicyInSystem」"
    },
    {
      "indent": 3,
      "text": "This abstract association inherits two object references from a higher- level CIM association class, Dependency. It overrides these object references to make them references to instances of the classes System and Policy. Subclasses of PolicyInSystem then override these object references again, to make them references to concrete policy classes.",
      "ja": "この抽象協会はに上位CIM関連クラス、依存関係から、2つのオブジェクト参照を継承します。それは彼らのクラスのシステムと政策のインスタンスへの参照を作成するには、これらのオブジェクト参照を上書きします。 PolicyInSystemのサブクラスは、その後、それらを具体的な政策のクラスへの参照をするために、再度、これらのオブジェクト参照を上書きします。"
    },
    {
      "indent": 3,
      "text": "The value of the abstract superclass is to convey that all subclasses have the same \"dependency\" semantics, and for ease of query to locate all policy \"dependencies\" on a System. These dependencies are related to scoping or hosting of the Policy.",
      "ja": "抽象スーパークラスの値は、すべてのサブクラスは、同じ「依存」の意味を持っていることを伝えることで、クエリを容易にするために、システム上のすべてのポリシー「依存関係」を検索します。これらの依存関係は、スコープやポリシーのホスティングに関連しています。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyInSystem DESCRIPTION A generic association used to establish dependency relationships between Policies and the Systems that host them. DERIVED FROM Dependency ABSTRACT TRUE PROPERTIES Antecedent[ref System[0..1]] Dependent[ref Policy[0..n]]",
      "ja": "NAME PolicyInSystem説明Aは、一般的な関連は、ポリシーおよびそれらをホストシステム間の依存関係を確立するために使用されます。依存関係ABSTRACT TRUE PROPERTIES前例[審判システム[0..1]]依存から派生して、[参照ポリシー[0..N]]"
    },
    {
      "indent": 0,
      "text": "7.10. The Weak Association \"PolicyGroupInSystem\"",
      "section_title": true,
      "ja": "7.10. 弱い協会「PolicyGroupInSystem」"
    },
    {
      "indent": 3,
      "text": "This association links a PolicyGroup to the System in whose scope the PolicyGroup is defined.",
      "ja": "この関連付けはのPolicyGroupが定義されているその範囲でのシステムへのPolicyGroupをリンクします。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyGroupInSystem DESCRIPTION A class representing the fact that a PolicyGroup is defined within the scope of a System. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref System[1..1]] Dependent[ref PolicyGroup[weak]]",
      "ja": "NAME PolicyGroupInSystem DESCRIPTIONのPolicyGroupがシステムの範囲内で定義されていることを表すクラス。 PolicyInSystem ABSTRACT FALSE施設から派生前例[REFシステム[1..1]依存性[参考文献のPolicyGroup [弱]"
    },
    {
      "indent": 0,
      "text": "7.10.1. The Reference \"Antecedent\"",
      "section_title": true,
      "ja": "7.10.1. リファレンス「という先行詞」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to restrict its cardinality to [1..1]. It serves as an object reference to a System that provides a scope for one or more PolicyGroups. Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyGroup is always defined within the scope of exactly one System.",
      "ja": "このプロパティは、PolicyInSystemから継承され、そして[1..1]にカーディナリティを制限するためにオーバーライドされます。これは、1つまたは複数のPolicyGroupsのスコープを提供するシステムへのオブジェクト参照として機能します。これは、弱い関連があるので、このオブジェクト参照の基数はのPolicyGroupは、常に正確に一つのシステムの範囲内で定義されている、つまり、常に1です。"
    },
    {
      "indent": 0,
      "text": "7.10.2. The Reference \"Dependent\"",
      "section_title": true,
      "ja": "7.10.2. 参考「依存」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyGroup defined within the scope of a System. Note that for any single instance of the association class PolicyGroupInSystem, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyGroups defined within its scope.",
      "ja": "このプロパティは、PolicyInSystemから継承、及びシステムの範囲内で定義されたPolicyGroupへのオブジェクト参照になるように上書きされます。関連クラスPolicyGroupInSystemの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたシステムは、その範囲内に定義された0,1、または複数のPolicyGroupsを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.11. The Weak Association \"PolicyRuleInSystem\"",
      "section_title": true,
      "ja": "7.11. 弱い協会「PolicyRuleInSystem」"
    },
    {
      "indent": 3,
      "text": "Regardless of whether it belongs to a PolicyGroup (or to multiple PolicyGroups), a PolicyRule is itself defined within the scope of a System. This association links a PolicyRule to the System in whose scope the PolicyRule is defined.",
      "ja": "関係なく（又は複数PolicyGroupsに）のPolicyGroupに属しているかどうか、のPolicyRule自体がシステムの範囲内で定義されています。この協会はPolicyRuleのが定義されているその範囲でのシステムへのPolicyRuleをリンクします。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRuleInSystem DESCRIPTION A class representing the fact that a PolicyRule is defined within the scope of a System. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref System[1..1]] Dependent[ref PolicyRule[weak]]",
      "ja": "PolicyRuleInSystem説明をPolicyRuleのは、システムの範囲内で定義されていることを表すクラスに名前を付けます。 PolicyInSystem抽象FALSE PROPERTIES前例[REFシステム[1..1]依存性[参考文献のPolicyRule [弱]から、派生"
    },
    {
      "indent": 0,
      "text": "7.11.1. The Reference \"Antecedent\"",
      "section_title": true,
      "ja": "7.11.1. リファレンス「という先行詞」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to restrict its cardinality to [1..1]. It serves as an object reference to a System that provides a scope for one or more PolicyRules. Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyRule is always defined within the scope of exactly one System.",
      "ja": "このプロパティは、PolicyInSystemから継承され、そして[1..1]にカーディナリティを制限するためにオーバーライドされます。これは、1つまたは複数のPolicyRulesのスコープを提供するシステムへのオブジェクト参照として機能します。これは、弱い関連があるので、このオブジェクト参照の基数はPolicyRuleのは常に1つのシステムの範囲内で定義されている、つまり、常に1です。"
    },
    {
      "indent": 0,
      "text": "7.11.2. The Reference \"Dependent\"",
      "section_title": true,
      "ja": "7.11.2. 参考「依存」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRule defined within the scope of a System. Note that for any single instance of the association class PolicyRuleInSystem, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyRules defined within its scope.",
      "ja": "このプロパティは、PolicyInSystemから継承、及びシステムの範囲内で定義されたPolicyRuleへのオブジェクト参照になるように上書きされます。関連クラスPolicyRuleInSystemの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたシステムは、その範囲内に定義された0,1、または複数のPolicyRulesを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.12. The Association \"PolicyConditionInPolicyRepository\"",
      "section_title": true,
      "ja": "7.12. 協会「PolicyConditionInPolicyRepository」"
    },
    {
      "indent": 3,
      "text": "A reusable policy condition is always related to a single PolicyRepository, via the PolicyConditionInPolicyRepository association. This is not true for all PolicyConditions, however. An instance of PolicyCondition that represents a rule-specific condition is not related to any policy repository via this association.",
      "ja": "再利用可能なポリシー条件は常にPolicyConditionInPolicyRepository会合を介して、単一のPolicyRepositoryに関連しています。しかしこれは、すべてのPolicyConditionsには当てはまりません。ルール固有状態を表すPolicyConditionのインスタンスは、この関連付けを介して任意のポリシーリポジトリに関連しません。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyConditionInPolicyRepository DESCRIPTION A class representing the inclusion of a reusable PolicyCondition in a PolicyRepository. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref PolicyRepository[0..1]] Dependent[ref PolicyCondition[0..n]]",
      "ja": "NAME PolicyConditionInPolicyRepository DESCRIPTION PolicyRepositoryに再利用可能なPolicyConditionの包含を表すクラス。 PolicyInSystem ABSTRACT FALSE施設から派生前例[REF PolicyRepository [0..1]従属[REF PolicyCondition [0..N]"
    },
    {
      "indent": 0,
      "text": "7.12.1. The Reference \"Antecedent\"",
      "section_title": true,
      "ja": "7.12.1. リファレンス「という先行詞」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRepository containing one or more PolicyConditions. A reusable PolicyCondition is always related to exactly one PolicyRepository via the PolicyConditionInPolicyRepository association. The [0..1] cardinality for this property covers the two types of PolicyConditions: 0 for a rule-specific PolicyCondition, 1 for a reusable one.",
      "ja": "このプロパティは、PolicyInSystemから継承、および1つまたは複数のPolicyConditionsを含むPolicyRepositoryへのオブジェクト参照になるように上書きされます。再利用可能なPolicyConditionは常にPolicyConditionInPolicyRepositoryの会合を介して正確に一つのPolicyRepositoryに関連しています。再利用可能ないずれかのルール固有PolicyCondition 0、1：このプロパティの[0..1]基数はPolicyConditionsの二つのタイプをカバーします。"
    },
    {
      "indent": 0,
      "text": "7.12.2. The Reference \"Dependent\"",
      "section_title": true,
      "ja": "7.12.2. 参考「依存」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyCondition included in a PolicyRepository. Note that for any single instance of the association class PolicyConditionInPolicyRepository, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one PolicyConditions.",
      "ja": "このプロパティは、PolicyInSystemから継承、及びPolicyRepositoryに含まPolicyConditionへのオブジェクト参照になるように無視されています。関連クラスPolicyConditionInPolicyRepositoryの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRepositoryは0、1、又は複数のPolicyConditionsを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.13. The Association \"PolicyActionInPolicyRepository\"",
      "section_title": true,
      "ja": "7.13. 協会「PolicyActionInPolicyRepository」"
    },
    {
      "indent": 3,
      "text": "A reusable policy action is always related to a single PolicyRepository, via the PolicyActionInPolicyRepository association. This is not true for all PolicyActions, however. An instance of PolicyAction that represents a rule-specific action is not related to any policy repository via this association.",
      "ja": "再利用可能なポリシーアクションは常にPolicyActionInPolicyRepositoryの会合を介して、単一PolicyRepositoryに関連しています。しかしこれは、すべてのPolicyActionsには当てはまりません。ルール固有のアクションを表すPolicyActionのインスタンスは、この関連付けを介して任意のポリシーリポジトリに関連しません。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NAME PolicyActionInPolicyRepository DESCRIPTION A class representing the inclusion of a reusable PolicyAction in a PolicyRepository. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref PolicyRepository[0..1]] Dependent[ref PolicyAction[0..n]]",
      "ja": "NAME PolicyActionInPolicyRepository DESCRIPTION PolicyRepositoryに再利用可能なPolicyActionの包含を表すクラス。 PolicyInSystem ABSTRACT FALSE施設から派生前例[REF PolicyRepository [0..1]従属[REF PolicyAction [0..N]"
    },
    {
      "indent": 0,
      "text": "7.13.1. The Reference \"Antecedent\"",
      "section_title": true,
      "ja": "7.13.1. リファレンス「という先行詞」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRepository containing one or more PolicyActions. A reusable PolicyAction is always related to exactly one PolicyRepository via the PolicyActionInPolicyRepository association. The [0..1] cardinality for this property covers the two types of PolicyActions: 0 for a rule-specific PolicyAction, 1 for a reusable one.",
      "ja": "このプロパティは、PolicyInSystemから継承、および1つまたは複数のPolicyActionsを含むPolicyRepositoryへのオブジェクト参照になるように上書きされます。再利用可能なPolicyActionは常にPolicyActionInPolicyRepositoryの会合を介して正確に一つのPolicyRepositoryに関連しています。再利用可能ないずれかのルール固有PolicyAction 0、1：このプロパティの[0..1]基数はPolicyActionsの二つのタイプをカバーします。"
    },
    {
      "indent": 0,
      "text": "7.13.2. The Reference \"Dependent\"",
      "section_title": true,
      "ja": "7.13.2. 参考「依存」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyAction included in a PolicyRepository. Note that for any single instance of the association class PolicyActionInPolicyRepository, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one PolicyActions.",
      "ja": "このプロパティは、PolicyInSystemから継承、及びPolicyRepositoryに含まPolicyActionへのオブジェクト参照になるように無視されています。関連クラスPolicyActionInPolicyRepositoryの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRepositoryは0、1、又は複数のPolicyActionsを含有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.14. The Aggregation \"PolicyRepositoryInPolicyRepository\"",
      "section_title": true,
      "ja": "7.14. 集計「PolicyRepositoryInPolicyRepository」"
    },
    {
      "indent": 3,
      "text": "The PolicyRepositoryInPolicyRepository aggregation enables policy repositories to be nested. This derives from the higher level CIM association, CIM_SystemComponent, describing that Systems contain other ManagedSystemElements. This superclass could not be used for the other Policy aggregations, since Policies are not ManagedSystemElements, but ManagedElements. Note that it is assumed that this aggregation is used to form directed acyclic graphs and NOT ring structures.",
      "ja": "PolicyRepositoryInPolicyRepository集約は、ポリシーリポジトリが入れ子にすることができます。これは、システムが他のManagedSystemElementsを含むことを記述する、より高いレベルCIM協会、CIM_SystemComponent由来します。ポリシーのManagedSystemElementsが、ManagedElementsではありませんので、このスーパークラスは、他のポリシーの集計に使用することができませんでした。この凝集は有向非巡回グラフとNOT環構造を形成するために使用されることが想定されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 0,
      "text": " NAME PolicyRepositoryInPolicyRepository DESCRIPTION A class representing the aggregation of PolicyRepositories by a higher-level PolicyRepository. DERIVED FROM SystemComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRepository[0..n]] PartComponent[ref PolicyRepository[0..n]] 7.14.1. The Reference \"GroupComponent\"",
      "ja": "NAME PolicyRepositoryInPolicyRepository DESCRIPTION上位PolicyRepositoryによってPolicyRepositoriesの集合を表すクラス。 SystemComponent ABSTRACT FALSE PROPERTIES GroupComponent [REF PolicyRepository [0..N] PartComponent [REF PolicyRepository [0..N] 7.14.1。由来リファレンス「GroupComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from the CIM class SystemComponent, and overridden to become an object reference to a PolicyRepository that contains one or more other PolicyRepositories. Note that for any single instance of the aggregation class PolicyRepositoryInPolicyRepository, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRepositories that contain any given PolicyRepository.",
      "ja": "このプロパティは、CIMクラスSystemComponentから継承され、そして一つ以上の他のPolicyRepositoriesが含まPolicyRepositoryへのオブジェクト参照になるように上書きされます。集約クラスPolicyRepositoryInPolicyRepositoryの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、0,1、又は任意のPolicyRepositoryを含む複数PolicyRepositoriesが存在し得ることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.14.2. The Reference \"PartComponent\"",
      "section_title": true,
      "ja": "7.14.2. リファレンス「PartComponent」"
    },
    {
      "indent": 3,
      "text": "This property is inherited from the CIM class SystemComponent, and overridden to become an object reference to a PolicyRepository contained by one or more other PolicyRepositories. Note that for any single instance of the aggregation class PolicyRepositoryInPolicyRepository, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one other PolicyRepositories.",
      "ja": "このプロパティは、CIMクラスSystemComponentから継承され、そして一つ以上の他のPolicyRepositoriesによって含まPolicyRepositoryへのオブジェクト参照になるように上書きされます。集約クラスPolicyRepositoryInPolicyRepositoryの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたPolicyRepositoryは0、1、又は複数の他のPolicyRepositoriesを含んでいてもよいことを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Intellectual Property",
      "section_title": true,
      "ja": "8.知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11.",
      "ja": "IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、あるいは本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "The Policy Core Information Model in this document is closely based on the work of the DMTF's Service Level Agreements working group, so thanks are due to the members of that working group. Several of the policy classes in this model first appeared in early drafts on IPSec policy and QoS policy. The authors of these drafts were Partha Bhattacharya, Rob Adams, William Dixon, Roy Pereira, Raju Rajan, Jean-Christophe Martin, Sanjay Kamat, Michael See, Rajiv Chaudhury, Dinesh Verma, George Powers, and Raj Yavatkar. Some other elements of the model originated in work done by Yoram Snir, Yoram Ramberg, and Ron Cohen. In addition, we would like to thank Harald Alvestrand for conducting a thorough review of this document and providing many helpful suggestions, and Luis Sanchez and Russ Mundy for their help with the document's Security Considerations.",
      "ja": "おかげでそのワーキンググループのメンバーによるものであるので、この文書の方針コア情報モデルは密接に、DMTFのサービス・レベル・アグリーメントワーキンググループの作業に基づいています。このモデルで政策のクラスのいくつかは、最初のIPSecポリシーとQoSポリシーの早期ドラフトで登場しました。これらのドラフトの著者はParthaバッタチャリヤ、ロブ・アダムス、ウィリアムディクソン、ロイ・ペレイラ、ラジュ・ラジャン、ジャン=クリストフ・マーティン、サンジャイKamat、マイケルを参照してください、ラジブChaudhury、ディネッシュバーマ、ジョージ・パワーズ、およびラジYavatkarました。モデルのいくつかの他の要素はYoram SNIR、Yoram Ramberg、およびロンコーエンによって行われる作業で始まりました。また、当社は、文書のセキュリティについての考慮事項と彼らの助けのために、このドキュメントの徹底的な見直しを行い、多くの有用な提案を提供するためのハラルドAlvestrand、およびルイス・サンチェスとラス・マンディに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Policy Core Information Model (PCIM) presented in this document provides an object-oriented model for describing policy information. It provides a basic framework for describing the structure of policy information, in a form independent of any specific repository or access protocol, for use by an operational system. PCIM is not intended to represent any particular system design or implementation, nor does it define a protocol, and as such it does not have any specific security requirements.",
      "ja": "方針コア情報モデル（PCIM）は、この文書のポリシー情報を記述するためのオブジェクト指向モデルを提供します。これは運用システムで使用するために、任意の特定のリポジトリまたはアクセスプロトコルの形式から独立に、ポリシー情報の構造を記述するための基本的なフレームワークを提供します。 PCIMは、特定のシステム設計や実装を表すことを意図していない、またそれは、プロトコルを定義しない、そのようにそれはどんな特定のセキュリティ要件はありません。"
    },
    {
      "indent": 3,
      "text": "However, it should also be noted that certain derivative documents, which use PCIM as a base, will need to convey more specific security considerations. In order to communicate the nature of what will be expected in these follow-on derivative documents, it is necessary to review the reasons that PCIM, as defined in this document, is neither implementable, nor representative of any real-world system, as well as the nature of the expected follow-on extensions and mappings.",
      "ja": "しかし、また、ベースとしてPCIMを使用する特定のデリバティブの文書は、より具体的なセキュリティ上の考慮事項を伝えるために必要となることに留意すべきです。これらの後続の派生文書に期待されるものの性質を通信するためには、PCIMは、この文書で定義されているだけでなく、実現可能な、また任意の実世界のシステムの代表でもないの理由を検討する必要があります予想される後続の拡張とマッピングの性質として。"
    },
    {
      "indent": 3,
      "text": "There are three independent reasons that PCIM, as defined here, is neither implementable nor representative of any real-world system:",
      "ja": "PCIMは、ここで定義されるように、どちらも実装可能でも任意の実世界のシステムの代表である三つの独立した理由があります。"
    },
    {
      "indent": 6,
      "text": "1. Its classes are independent of any specific repository that uses any specific access protocol. Therefore, its classes are designed not to be implemented directly. PCIM should instead be viewed as a schematic that directs how information should be represented, independent of any specific model implementation constraints.",
      "ja": "1.そのクラスは、特定のアクセスプロトコルを使用して任意の特定のリポジトリから独立しています。したがって、そのクラスが直接実装されないように設計されています。 PCIMは、代わりに情報は、任意の特定のモデルの実装上の制約から独立して表現する方法を導く概略として見られるべきです。"
    },
    {
      "indent": 6,
      "text": "2. Its classes were designed to be independent of any specific policy domain. For example, DiffServ and IPSec represent two different policy domains. Each document which extends PCIM to one of these domains will derive subclasses from the classes and relationships defined in PCIM, in order to represent extensions of a generic model to cover specific technical domains.",
      "ja": "2.そのクラスは、任意の特定のポリシー・ドメインに依存しないように設計されました。例えば、DiffServのおよびIPSecは、二つの異なるポリシー・ドメインを表しています。これらのドメインのいずれかにPCIMを拡張し、各文書には、特定の技術領域をカバーするために、一般的なモデルの拡張を表現するために、PCIMで定義されたクラスとの関係からサブクラスを導出します。"
    },
    {
      "indent": 6,
      "text": "3. It's an information model, which must be mapped to a specific data model (native CIM schema, LDAP schema, MIB, whatever) before it can be implemented. Derivative documents will map the extended information models noted in item 2, above, to specific types of data model implementations.",
      "ja": "3.それは、それを実装することができる前に、特定のデータモデル（ネイティブのCIMスキーマ、LDAPスキーマ、MIB、何でも）にマッピングされなければならない情報モデル、です。誘導体ドキュメントは、データモデルの実装の特定のタイプに、上記の項目2で述べた拡張情報モデルをマッピングします。"
    },
    {
      "indent": 3,
      "text": "Even though specific security requirements are not appropriate for PCIM, specific security requirements MUST be defined for each operational real- world application of PCIM. Just as there will be a wide range of operational, real-world systems using PCIM, there will also be a wide range of security requirements for these systems. Some operational, real-world systems that are deployed using PCIM may have extensive security requirements that impact nearly all classes and subclasses utilized by such a system, while other systems' security requirements might have very little impact.",
      "ja": "特定のセキュリティ要件がPCIMに適していないにもかかわらず、特定のセキュリティ要件は、PCIMの各動作実世界のアプリケーションに定義されなければなりません。 PCIMを使用して運用、実世界のシステムの広い範囲があるだろうと同じように、また、これらのシステムのセキュリティ要件の広い範囲があるでしょう。他のシステムのセキュリティ要件が非常にほとんど影響を持っているかもしれないがPCIMを使用して展開されているいくつかの操作、実世界のシステムは、そのインパクトようなシステムが利用するほぼすべてのクラスとサブクラスを豊富なセキュリティ要件を有することができます。"
    },
    {
      "indent": 3,
      "text": "The derivative documents, discussed above, will create the context for applying operational, real-world, system-level security requirements against the various models which derive from PCIM.",
      "ja": "上記の派生文書は、PCIMから派生する様々なモデルに対する操作、現実世界、システムレベルのセキュリティ要件を適用するためのコンテキストを作成します。"
    },
    {
      "indent": 3,
      "text": "For example, in some real-world scenarios, the values associated with certain properties, within certain instantiated classes, may represent information associated with scarce, and/or costly (and therefore valuable) resources. It may be the case that these values must not be disclosed to, or manipulated by, unauthorized parties. As long as the derived model remains an information model (as opposed to a data model), it is not possible to discuss the data model-specific tools and mechanisms that are available for achieving the authentication and authorization implicit in a requirement that restricts read and/or read- write access to these values. Therefore, these mechanisms will need to be discussed in each of the data models to which the derived information models are mapped. If there are any general security requirements that can be identified and can be applied across multiple types of data models, it would be appropriate to discuss those at the information model level, rather than the data model level. In any case, any identified security requirements that are not dealt with in the information model document, MUST be dealt with in the derivative data model documents.",
      "ja": "例えば、いくつかの現実世界のシナリオでは、特定のプロパティに関連付けられた値は、特定のインスタンス化されたクラス内で、不足、および/または費用のかかる（したがって、貴重な）リソースに関連する情報を表すことができます。これは、これらの値はに開示され、または権限のない者によって操作されてはならないという場合があり得ます。 （データ・モデルとは対照的に）誘導されるモデルは、情報モデルのままとして、読み取り制限し要件に暗黙の認証および認可を達成するために利用可能であるデータ・モデル固有のツールとメカニズムを議論することができない限り、そして/またはこれらの値の読み取り書き込みアクセス。したがって、これらのメカニズムは、導出された情報モデルがマッピングされたデータモデルのそれぞれに議論する必要があります。識別することができ、データモデルの複数のタイプの間に印加することができます任意の一般的なセキュリティ要件がある場合は、むしろ、データモデルのレベルよりも情報モデルレベルでそれらを議論するのが適切でしょう。いずれにせよ、情報モデルドキュメントで対処されていない任意の識別されたセキュリティ要件は、派生データモデルドキュメントで対処しなければなりません。"
    },
    {
      "indent": 3,
      "text": "We can illustrate these points by extending the example from Section 2. A real-world system that provides QoS Gold Service to John would likely need to provide at least the following security-related capabilities and mechanisms (see [12] for definitions of security related terms):",
      "ja": "私たちは、関連するセキュリティの定義を参照（おそらく、少なくとも以下のセキュリティ関連機能とメカニズムを提供する必要があるでしょうジョンへのQoSゴールドサービスを提供して第2節から現実世界のシステムの例を拡張することにより、[12]これらのポイントを説明することができます条項）："
    },
    {
      "indent": 3,
      "text": "o Data integrity for the information (e.g., property values and instantiated relationships) that specify that John gets QoS Gold Service, from the point(s) that the information is entered into the system to the point(s) where network components actually provide that Service.",
      "ja": "Oそれはジョンが情報のネットワークコンポーネントが実際にあることを提供ポイント（複数可）をシステムに入力されている点（複数可）から、QoSのゴールドサービスを取得する情報のためのデータの整合性（例えば、プロパティ値とインスタンス化関係）を指定しますサービス。"
    },
    {
      "indent": 3,
      "text": "o Authentication and Authorization methods to ensure that only system administrators (and not John or other engineers) can remotely administer components of the system.",
      "ja": "システム管理者のみ（およびいないジョンまたは他の技術）がリモートシステムのコンポーネントを管理できるようにするO認証及び認可する方法。"
    },
    {
      "indent": 3,
      "text": "o An Authentication method to insure that John receives Gold Service, and the other members of the engineering group receive Bronze Service.",
      "ja": "ジョンは、ゴールドサービスを受信して​​、エンジニアリンググループの他のメンバーがブロンズサービスを受けることを保証するための認証方法O。"
    },
    {
      "indent": 3,
      "text": "These are one possible set of requirements associated with an example real-world system which delivers Gold Service, and the appropriate place to document these would be in some combination of the information model and the derivative data models for QoS Policy. Each of the data models would also need to discuss how these requirements are satisfied, using the mechanisms typically available to such a data model, given the particular technology or set of technologies which it may employ.",
      "ja": "これらは、ゴールドサービスを提供する例、実世界システム、およびこれらの情報モデルとQoSポリシーのための微分データモデルのいくつかの組み合わせになります文書化するための適切な場所に関連付けられている要件の一つの可能​​なセットです。データモデルの各々はまた、このようなデータモデルに一般的に利用可能なメカニズム、特定の技術を与えられたか、それは使用することができる技術のセットを使用して、これらの要件が満たされているか議論する必要があるだろう。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Distributed Management Task Force, Inc., \"DMTF Technologies: CIM Standards << CIM Schema: Version 2.4\", available via links on the following DMTF web page: http://www.dmtf.org/spec/cim_schema_v24.html.",
      "ja": "[1]分散管理タスクフォース株式会社、 \"DMTF技術：CIM規格<< CIMスキーマ：バージョン2.4\" には、次のDMTFのWebページ上のリンクを介して利用可能：http://www.dmtf.org/spec/cim_schema_v24。 HTML。"
    },
    {
      "indent": 3,
      "text": "[2] Distributed Management Task Force, Inc., \"Common Information Model (CIM) Specification, version 2.2, June 1999. This document is available on the following DMTF web page: http://www.dmtf.org/spec/cims.html.",
      "ja": "[2]分散管理タスクフォース株式会社、「共通情報モデル（CIM）仕様、バージョン2.2、1999年6月。この文書は、次のDMTFのWebページで提供されています：http://www.dmtf.org/spec/cims .htmlを。"
    },
    {
      "indent": 3,
      "text": "[3] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[3]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[4] Hovey, R. and S. Bradner, \"The Organizations Involved in the IETF Standards Process\", BCP 11, RFC 2028, October 1996.",
      "ja": "[4] Hovey、R.およびS.ブラドナー、BCP 11、RFC 2028、1996年10月 \"IETF標準化プロセスに関与する組織\"。"
    },
    {
      "indent": 3,
      "text": "[5] J. Strassner and S. Judd, \"Directory-Enabled Networks\", version 3.0c5 (August 1998). A PDF file is available at http://www.murchiso.com/den/#denspec.",
      "ja": "[5] J. StrassnerとS.ジャッド、 \"ディレクトリ対応ネットワーク\"、バージョン3.0c5（1998年8月）。 PDFファイルはhttp://www.murchiso.com/den/#denspecで入手可能です。"
    },
    {
      "indent": 3,
      "text": "[6] J. Strassner, policy architecture BOF presentation, 42nd IETF Meeting, Chicago, Illinois, October, 1998. Minutes of this BOF are available at the following location: http://www.ietf.org/proceedings/98aug/index.html.",
      "ja": "[6] J. Strassner、ポリシーアーキテクチャBOFプレゼンテーション、第42回IETF会議、シカゴ、イリノイ州10月、このBOFの1998分の次の場所で利用可能である：http://www.ietf.org/proceedings/98aug/index .htmlを。"
    },
    {
      "indent": 3,
      "text": "[7] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[7] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、RFC 2279、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[8] Levi, D. and J. Schoenwaelder, \"Definitions of Managed Objects for Scheduling Management Operations\", RFC 2591, May 1999.",
      "ja": "[8]レビとD.とJ. Schoenwaelder、 \"スケジュール管理操作のための管理オブジェクトの定義\"、RFC 2591、1999年5月を。"
    },
    {
      "indent": 3,
      "text": "[9] Yavatkar, R., Pendarakis, D. and R. Guerin, \"A Framework for Policy-based Admission Control\", RFC 2753, January 2000.",
      "ja": "[9] Yavatkar、R.、Pendarakis、D.とR.ゲラン、 \"ポリシーベースのアドミッション制御のためのフレームワーク\"、RFC 2753、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[10] Dawson, F. and D. Stenerson, \"Internet Calendaring and Scheduling Core Object Specification (iCalendar)\", RFC 2445, November 1998.",
      "ja": "[10]ドーソン、F.とD. Stenerson、 \"インターネットカレンダーおよびスケジューリング中核オブジェクト仕様（iCalendar形式）\"、RFC 2445、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[11] Strassner, J., and E. Ellesson, B. Moore, R. Moats, \"Policy Core LDAP Schema\", Work in Progress.",
      "ja": "[11] Strassner、J.、およびE. Ellesson、B.ムーア、R.堀、 \"ポリシーコアLDAPスキーマ\"、ProgressのWork。"
    },
    {
      "indent": 3,
      "text": "[12] Shirey, R., \"Internet Security Glossary\", FYI 36, RFC 2828, May 2000.",
      "ja": "[12] Shirey、R.、 \"インターネットセキュリティ用語集\"、FYI 36、RFC 2828、2000年5月。"
    },
    {
      "indent": 3,
      "text": "Note: the CIM 2.4 Schema specification is defined by the following set of MOF files, available from the following URL:",
      "ja": "注意：CIM 2.4スキーマ仕様は、MOFファイルの次のセットによって定義され、以下のURLから入手可能："
    },
    {
      "indent": 6,
      "text": "http://www.dmtf.org/spec/CIM_Schema24/CIM_Schema24.zip",
      "ja": "ｈっｔｐ：／／ｗっｗ。ｄｍｔｆ。おｒｇ／ｓぺｃ／しＭ＿Ｓちぇま２４／しＭ＿Ｓちぇま２４。じｐ"
    },
    {
      "indent": 0,
      "text": "12. Authors' Addresses",
      "section_title": true,
      "ja": "12.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ed Ellesson LongBoard, Inc. 2505 Meridian Pkwy, #100 Durham, NC 27713",
      "ja": "エドEllessonロングボード社2505メリディアンパークウェイ、＃100ダーラム、ノースカロライナ27713"
    },
    {
      "indent": 3,
      "text": "Phone: +1 919-361-3230 Fax: +1 919-361-3299 EMail: eellesson@lboard.com",
      "ja": "電話：+1 919-361-3230ファックス：+1 919-361-3299電子メール：eellesson@lboard.com"
    },
    {
      "indent": 3,
      "text": "Bob Moore IBM Corporation, BRQA/502 4205 S. Miami Blvd. Research Triangle Park, NC 27709",
      "ja": "ボブ・ムーアIBM社、BRQA / 502 4205 S.マイアミブルバードリサーチトライアングルパーク、NC 27709"
    },
    {
      "indent": 3,
      "text": "Phone: +1 919-254-4436 Fax: +1 919-254-6243 EMail: remoore@us.ibm.com",
      "ja": "電話：+1 919-254-4436ファックス：+1 919-254-6243電子メール：remoore@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "John Strassner Cisco Systems, Bldg 15 170 West Tasman Drive San Jose, CA 95134",
      "ja": "ジョンStrassnerシスコシステムズ、ビル15 170西タスマン・ドライブサンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408-527-1069 Fax: +1 408-527-6351 EMail: johns@cisco.com",
      "ja": "電話：+1 408-527-1069ファックス：+1 408-527-6351電子メール：johns@cisco.com"
    },
    {
      "indent": 3,
      "text": "Andrea Westerinen Cisco Systems 170 West Tasman Drive San Jose, CA 95134",
      "ja": "アンドレアWesterinenシスコシステムズ170西タスマン・ドライブサンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408-853-8294 Fax: +1 408-527-6351 EMail: andreaw@cisco.com",
      "ja": "電話：+1 408-853-8294ファックス：+1 408-527-6351電子メール：andreaw@cisco.com"
    },
    {
      "indent": 0,
      "text": "13. : Class Identification in a Native CIM Implementation",
      "section_title": true,
      "ja": "13.：ネイティブのCIM実装のクラスの識別"
    },
    {
      "indent": 3,
      "text": "While the CommonName property is present in the abstract superclass Policy, and is thus available in all of its instantiable subclasses, CIM does not use this property for naming instances. The following subsections discuss how naming is handled in a native CIM implementation for each of the instantiable classes in the Policy Core Information Model.",
      "ja": "CommonNameプロパティは抽象スーパー・ポリシーに存在し、そのインスタンス化サブクラスのすべてで利用できるようですが、CIMは、インスタンスに名前を付けるために、このプロパティを使用していません。以下のサブセクションでは、ネーミングが方針コア情報モデルでのインスタンス化の各クラスのネイティブのCIM実装でどのように扱われるかを議論します。"
    },
    {
      "indent": 3,
      "text": "Two things should be noted regarding CIM naming:",
      "ja": "二つのことは、CIMの命名について注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When a CIM association is specified as \"weak\", this is a statement about naming scopes: an instance of the class at the weak end of the association is named within the scope of an instance of the class at the other end of the association. This is accomplished by propagation of keys from the instance of the scoping class to the instance of the weak class. Thus the weak class has, via key propagation, all the keys from the scoping class, and it also has one or more additional keys for distinguishing instances of the weak class, within the context of the scoping class.",
      "ja": "クラスのインスタンスを協会の弱い終わり協会のもう一方の端に、クラスのインスタンスの範囲内で命名された：CIM協会が「弱い」として指定されている場合は、O、これはスコープの名前付けに関するステートメントがあります。これは、弱いクラスのインスタンスにスコープクラスのインスタンスから鍵の伝播によって達成されます。従って弱いクラスは、キー伝播を介して、スコープクラスからすべてのキーを有し、そしてそれはまた、スコープクラスのコンテキスト内で弱いクラスのインスタンスを区別するための1つまたは複数の追加のキーを有しています。"
    },
    {
      "indent": 3,
      "text": "o All class names in CIM are limited to alphabetic and numeric characters plus the underscore, with the restriction that the first character cannot be numeric. Refer to Appendix F \"Unicode Usage\" in reference [2] for an exact specification of how CIM class names are encoded in CIM strings.",
      "ja": "O CIMのすべてのクラス名は、最初の文字は数字にすることはできません制限、英数字とアンダースコアに制限されています。 CIMクラス名がCIM文字列に符号化する方法の正確な仕様については参考文献[2]の付録Fに「Unicodeの使用」を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.1. Naming Instances of PolicyGroup and PolicyRule",
      "section_title": true,
      "ja": "13.1.  PolicyGroupとPolicyRuleのインスタンスの命名"
    },
    {
      "indent": 3,
      "text": "A policy group always exists in the context of a system. In the Policy Core Information Model, this is captured by the weak aggregation PolicyGroupInSystem between a PolicyGroup and a System. Note that System serves as the base class for describing network devices and administrative domains.",
      "ja": "ポリシーグループは、常にシステムのコンテキストに存在します。方針コア情報モデルでは、これはのPolicyGroupとシステム間の弱い集約PolicyGroupInSystemによって捕獲されます。システムは、ネットワーク装置と管理ドメインを記述するための基底クラスとして機能することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A policy rule also exists in the context of a system. In the Policy Core Information Model, this is captured by the weak association PolicyRuleInSystem between a PolicyRule and a System.",
      "ja": "ポリシールールは、システムのコンテキスト内に存在します。方針コア情報モデルでは、これはPolicyRuleのとシステム間の弱い関連PolicyRuleInSystemによって捕獲されます。"
    },
    {
      "indent": 3,
      "text": "The following sections define the CIM keys for PolicyGroup and PolicyRule.",
      "ja": "次のセクションでは、ポリシーグループとポリシールールのためのCIMのキーを定義します。"
    },
    {
      "indent": 0,
      "text": "13.1.1. PolicyGroup's CIM Keys",
      "section_title": true,
      "ja": "13.1.1. ポリシーグループのCIMのキー"
    },
    {
      "indent": 3,
      "text": "The CIM keys of the PolicyGroup class are:",
      "ja": "ポリシーグループクラスのCIMのキーは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o SystemCreationClassName (A CIM_System key, propagated due to the weak association, PolicyGroupInSystem)",
      "ja": "O SystemCreationClassName（弱い会合に伝播CIM_Systemキー、PolicyGroupInSystem）"
    },
    {
      "indent": 3,
      "text": "o SystemName (A CIM_System key, propagated due to the weak association, PolicyGroupInSystem) o CreationClassName o PolicyGroupName",
      "ja": "OのSystemName（弱い会合、PolicyGroupInSystemに伝播CIM_Systemキー）OのCreationClassName O PolicyGroupName"
    },
    {
      "indent": 3,
      "text": "They are defined in Reference [1] as follows:",
      "ja": "次のように彼らは、[1]参考に定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME SystemCreationClassName DESCRIPTION SystemCreationClassName represents the class name of the CIM System object providing the naming scope for the instance of PolicyGroup. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "NAME SystemCreationClassNameの説明SystemCreationClassNameはのPolicyGroupのインスタンスの命名範囲を提供するCIMシステムオブジェクトのクラス名を表します。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME SystemName DESCRIPTION SystemName represent the individual name of the particular System object, providing the naming scope for the instance of PolicyGroup. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "NAMEのSystemNameの説明のSystemNameはのPolicyGroupのインスタンスの命名範囲を提供し、特定のシステムオブジェクトの個々の名前を表します。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME CreationClassName DESCRIPTION This property is set to \"CIM_PolicyGroup\", if the PolicyGroup object is directly instantiated. Or, it is equal to the class name of the PolicyGroup subclass that is instantiated. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyGroupオブジェクトを直接インスタンス化される場合、名前のCreationClassName説明は、このプロパティは、「CIM_PolicyGroup」に設定されています。それとも、それがインスタンス化されたPolicyGroupサブクラスのクラス名と同じです。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyGroupName DESCRIPTION The identifying name of this policy group. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyGroupName説明をこのポリシーグループの識別名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 0,
      "text": "13.1.2. PolicyRule's CIM Keys",
      "section_title": true,
      "ja": "13.1.2.  PolicyRuleののCIMキーズ"
    },
    {
      "indent": 3,
      "text": "The CIM keys of the PolicyRule class are:",
      "ja": "ポリシールールのクラスのCIMのキーは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o SystemCreationClassName (A CIM_System key, propagated due to the weak association PolicyRuleInSystem) o SystemName (A CIM_System key, propagated due to the weak association PolicyRuleInSystem) o CreationClassName o PolicyRuleName",
      "ja": "SystemName（弱い会合PolicyRuleInSystemに伝播CIM_Systemキー）OのCreationClassName O PolicyRuleName O O SystemCreationClassName（弱い会合PolicyRuleInSystemに伝播CIM_Systemキー）"
    },
    {
      "indent": 3,
      "text": "SystemCreationClassName and SystemName work the same as defined for the class PolicyGroup. See Section 13.1.1 for details.",
      "ja": "クラスのPolicyGroupのために定義されているようSystemCreationClassNameとのSystemNameは、同じように機能します。詳細については、13.1.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The other two properties are defined in Reference [1] as follows:",
      "ja": "他の二つの特性は、リファレンスで定義されている[1]以下のよう"
    },
    {
      "indent": 6,
      "text": "NAME CreationClassName DESCRIPTION This property is set to \"CIM_PolicyRule\", if the PolicyRule object is directly instantiated. Or, it is equal to the class name of the PolicyRule subclass that is instantiated. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyRuleのオブジェクトを直接インスタンス化される場合、名前のCreationClassName説明は、このプロパティは、「CIM_PolicyRule」に設定されています。それとも、それがインスタンス化されたPolicyRuleのサブクラスのクラス名と同じです。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 6,
      "text": "NAME PolicyRuleName DESCRIPTION The identifying name of this policy rule. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyRuleName説明をこのポリシールールの識別名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 0,
      "text": "13.2. Naming Instances of PolicyCondition and Its Subclasses",
      "section_title": true,
      "ja": "13.2.  PolicyConditionとそのサブクラスのインスタンスに名前を付けます"
    },
    {
      "indent": 3,
      "text": "The CIM keys of the PolicyCondition class are:",
      "ja": "ポリシー条件クラスのCIMのキーは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "o SystemCreationClassName o SystemName o PolicyRuleCreationClassName o PolicyRuleName o CreationClassName o PolicyConditionName",
      "ja": "O SystemCreationClassName OのSystemName O PolicyRuleCreationClassName O PolicyRuleName OのCreationClassName O PolicyConditionName"
    },
    {
      "indent": 3,
      "text": "Note that none of the keys are defined as propagated, although they appear to fit this convention. The reason for this difference is because (as indicated in Sections 5.1 and 6.4) the PolicyCondition class is used to represent both reusable and rule-specific conditions. This, in turn, affects what associations are valid for an instance of PolicyCondition, and how that instance is named.",
      "ja": "伝播として、彼らはこの規則に合うように思われるが、キーのいずれも定義されていないことに注意してください。 PolicyConditionクラスは、再利用可能及びルール固有の両方の条件を表すために使用される（セクション5.1および6.4に示されるように）ので、この違いの理由です。これは、順番に、協会はPolicyConditionのインスタンスの有効な、そしてどのようにそのインスタンスの名前が何であるかに影響します。"
    },
    {
      "indent": 3,
      "text": "In an ideal world, an instance of the PolicyCondition class would be scoped either by its PolicyRepository (for a reusable condition) or by its PolicyRule (for a rule-specific condition). However, CIM has the restriction that a given class can only be \"weak\" to one other class (i.e., defined by one weak association).",
      "ja": "理想的な世界では、PolicyConditionのクラスのインスタンスは、そのPolicyRepositoryによって（再利用可能な状態の場合）または（規則特定の状態のために）そのPolicyRuleのいずれかによってスコープされるであろう。しかし、CIMは、所与のクラスのみ（すなわち1回の弱い会合によって定義された）一つの他のクラスに「弱い」とすることができる制限を有しています。"
    },
    {
      "indent": 3,
      "text": "To work within the restrictions of CIM naming, it is necessary to \"simulate\" weak associations between PolicyCondition and PolicyRule, and between PolicyCondition and PolicyRepository, through a technique we'll call manual key propagation. Strictly speaking, manual key propagation isn't key propagation at all. But it has the same effect as (true) key propagation, so the name fits.",
      "ja": "CIM命名の制限内で動作するためには、PolicyConditionとPolicyRuleの間に弱い関連を「シミュレート」する必要があり、PolicyConditionとPolicyRepositoryの間で、技術を通じて、私たちは手動鍵伝播を呼ぶことにします。厳密に言えば、手動鍵伝播は、すべての主要な伝播ではありません。しかし、それは（真の）キーの伝播と同じ効果を持っているので、名前が収まります。"
    },
    {
      "indent": 3,
      "text": "Figure 9 illustrates how manual propagation works in the case of PolicyCondition. (Note that only the key properties are shown for each of the classes.) In the figure, the line composed of 'I's indicates class inheritance, the one composed of 'P's indicates (true) key propagation via the weak aggregation PolicyRuleInSystem, and the ones composed of 'M's indicate manual key propagation.",
      "ja": "図9は、PolicyConditionの場合にどのように機能するかを手動伝播示します。 （唯一の重要な特性は、クラスの各々について示されていることに注意してください。）図では、からなる線「Iのクラスの継承を示し、から構成される1」Pのは（真の）キー弱い凝集PolicyRuleInSystemを介して伝播し、示し「M年代で構成するものでは手動鍵の伝播を示しています。"
    },
    {
      "indent": 6,
      "text": "+------------------+\n|      System      |\n+------------------+\n|CreationClassName |\n|Name              |\n+------------------+\n          ^     P\n          I     PPPPPPPPPPPPPPPPPPPPPPPPPPPP\n          I                                P\n+------------------+       +---------------v--------------+\n|    AdminDomain   |       |         PolicyRule           |\n+------------------+       +------------------------------+\n|CreationClassName |       | System.CreationClassName     |\n|Name              |       | System.Name                  |\n+------------------+       | CreationClassName            |\n          ^                | PolicyRuleName               |\n          I                +------------------------------+\n          I                         M\n          I                         M\n+------------------+                M\n| PolicyRepository |                M\n+------------------+                M\n|CreationClassName |                M\n|Name              |                M\n+------------------+                M\n                M                   M\n                M                   M\n                M                   M\n           +----v-------------------v----+\n           |       PolicyCondition       |\n           +-----------------------------+\n           | SystemCreationClassName     |\n           | SystemName                  |\n           | PolicyRuleCreationClassName |\n           | PolicyRuleName              |\n           | CreationClassName           |\n           | PolicyConditionName         |\n           +-----------------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 9. Manual Key Propagation for Naming PolicyConditions",
      "ja": "PolicyConditionsの命名図9.手動鍵の伝播"
    },
    {
      "indent": 3,
      "text": "Looking at Figure 9, we see that two key properties, CreationClassName and Name, are defined in the System class, and inherited by its subclasses AdminDomain and PolicyRepository. Since PolicyRule is weak to System, these two keys are propagated to it; it also has its own keys CreationClassName and PolicyRuleName.",
      "ja": "図9を見ると、私たちは二つの重要な特性、のCreationClassNameとNameは、Systemクラスで定義され、そしてそのサブクラスいるAdminDomainとPolicyRepositoryによって継承されていることがわかります。 PolicyRuleのは、システムに弱いので、これら2つのキーがそれに伝播されます。それはまた、独自のキーのCreationClassNameとPolicyRuleNameを持っています。"
    },
    {
      "indent": 3,
      "text": "A similar approach, though not automatic, is used in \"manual key propagation\". Here is the approach for rule-specific and reusable PolicyConditions:",
      "ja": "同様のアプローチが、自動ではないが、「手動キー伝播」に使用されます。ここではルール固有の再利用可能なPolicyConditionsためのアプローチは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The manual propagation of keys from PolicyRule to PolicyCondition involves copying the values of PolicyRule's four key properties into four similarly named key properties in PolicyCondition. From the point of view of the CIM specification language, the property SystemName in PolicyCondition is a completely new key property. However, the relationship to the Name property in System is defined in the description of SystemName.",
      "ja": "PolicyConditionへのPolicyRuleからキーを手動で伝播oをPolicyConditionの4つの類似した名前のキープロパティにPolicyRuleのの4つの重要なプロパティの値をコピーすることを伴います。 CIM仕様言語の観点から、PolicyConditionの不動産のSystemNameは、全く新しいキープロパティです。しかし、システムでNameプロパティとの関係は、SystemNameをの記述で定義されています。"
    },
    {
      "indent": 3,
      "text": "o The manual propagation of keys from PolicyRepository to PolicyCondition works in exactly the same way for the first two key properties. However, since PolicyRepository doesn't include PolicyRule properties, the PolicyRuleCreationClassName and PolicyRuleName have no values. A special value, \"No Rule\", is assigned to both of these properties in this case, indicating that this instance of PolicyCondition is not named within the scope of any particular policy rule.",
      "ja": "oをPolicyConditionへPolicyRepositoryからキーを手動で伝播は、最初の2つの重要な特性のためにまったく同じように動作します。 PolicyRepositoryがPolicyRuleのプロパティが含まれていないので、PolicyRuleCreationClassNameとPolicyRuleNameは値を持ちません。特別な値、「いいえルール」は、PolicyConditionのこのインスタンスは、任意の特定のポリシールールの範囲内で命名されていないことを示し、この場合、これらの特性の両方に割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The following section defines the specific CIM keys for PolicyCondition.",
      "ja": "以下のセクションでは、PolicyConditionのために、特定のCIMキーを定義します。"
    },
    {
      "indent": 0,
      "text": "13.2.1. PolicyCondition's CIM Keys",
      "section_title": true,
      "ja": "13.2.1. ポリシー条件CIMキー"
    },
    {
      "indent": 3,
      "text": "PolicyCondition's key properties are defined in Reference [1] as follows:",
      "ja": "PolicyConditionのキープロパティは、リファレンスで定義されている[1]次のように："
    },
    {
      "indent": 3,
      "text": "NAME SystemCreationClassName DESCRIPTION SystemCreationClassName represents the class name of the CIM System object providing the naming scope for the instance of PolicyCondition. For a rule-specific policy condition, this is the type of system (e.g., the name of the class that created this instance) in whose context the policy rule is defined. For a reusable policy condition, this is set to \"CIM_PolicyRepository\", if the PolicyRepository object is directly instantiated. Or, it is equal to the class name of the PolicyRepository subclass that is instantiated. SYNTAX string [MaxLen 256]",
      "ja": "NAME SystemCreationClassNameの説明SystemCreationClassNameはPolicyConditionのインスタンスの命名範囲を提供するCIMシステムオブジェクトのクラス名を表します。ルール固有のポリシー条件のために、このポリシールールが定義され、そのコンテキスト内でシステムの種類（このインスタンスを作成したクラスの例えば、名前）です。 PolicyRepositoryオブジェクトを直接インスタンス化されている場合、再利用可能なポリシーの条件の場合、これは、「CIM_PolicyRepository」に設定されています。それとも、それがインスタンス化されたPolicyRepositoryサブクラスのクラス名と同じです。構文string [のMaxLen 256]"
    },
    {
      "indent": 3,
      "text": "QUALIFIER key",
      "ja": "QUALIFIERキー"
    },
    {
      "indent": 3,
      "text": "NAME SystemName DESCRIPTION The name of the System object in whose scope this policy condition is defined. This property completes the identification of the System object. For a rule-specific policy condition, this is the name of the instance of the system in whose context the policy rule is defined. For a reusable policy condition, this is name of the instance of PolicyRepository that holds the policy condition. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "SystemName説明にこのポリシー条件が定義され、その範囲内のシステム・オブジェクトの名前。このプロパティは、システムオブジェクトの識別を完了します。ルール固有のポリシー条件のために、このポリシールールが定義され、そのコンテキスト内でシステムのインスタンスの名前です。再利用可能なポリシーの条件の場合、これは、ポリシー条件を保持しているPolicyRepositoryのインスタンスの名前です。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleCreationClassName DESCRIPTION For a rule-specific policy condition, this property identifies the class name of the policy rule instance, in whose scope this instance of PolicyCondition exists. For a reusable policy condition, this property is set to a special value, \"No Rule\", indicating that this instance of PolicyCondition is not unique to one policy rule. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "ルール固有のポリシー条件の名前PolicyRuleCreationClassNameの説明は、このプロパティは、ポリシールールインスタンスのクラス名を識別し、その範囲PolicyConditionのこのインスタンスが存在します。再利用可能なポリシーの条件の場合、このプロパティは、PolicyConditionのこのインスタンスが1つのポリシールールに特有のものではないことを示す、特別な値、「いいえルール」に設定されています。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleName DESCRIPTION For a rule-specific policy condition, PolicyRuleName completes the identification of the PolicyRule object with which this condition is associated. For a reusable policy condition, a special value, \"No Rule\", is used to indicate that this condition is reusable. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "ルール固有のポリシー条件の名前PolicyRuleName説明は、PolicyRuleNameは、この条件が関連付けられているPolicyRuleのオブジェクトの識別を完了する。再利用可能なポリシー条件のために、特別な値、「いいえルール」、この条件は再利用可能であることを示すために使用されます。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME CreationClassName DESCRIPTION The class name of the PolicyCondition subclass that is instantiated. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "NAME CreationClassNameは説明インスタンス化されたPolicyConditionサブクラスのクラス名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyConditionName DESCRIPTION The identifying name of this policy condition. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyConditionName説明をこのポリシー条件の識別名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 0,
      "text": "13.3. Naming Instances of PolicyAction and Its Subclasses",
      "section_title": true,
      "ja": "13.3.  PolicyActionとそのサブクラスのインスタンスに名前を付けます"
    },
    {
      "indent": 3,
      "text": "From the point of view of naming, the PolicyAction class and its subclasses work exactly like the PolicyCondition class and its subclasses. See Section 13.2 and 13.2.1 for details.",
      "ja": "命名の観点から、PolicyActionのクラスとそのサブクラスは、PolicyConditionのクラスとそのサブクラスとまったく同じように動作します。詳細については、セクション13.2および13.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Specifically, the CIM keys of PolicyAction are:",
      "ja": "具体的には、ポリシーアクションのCIMのキーは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "o SystemCreationClassName o SystemName o PolicyRuleCreationClassName o PolicyRuleName o CreationClassName o PolicyActionName",
      "ja": "O SystemCreationClassName OのSystemName O PolicyRuleCreationClassName O PolicyRuleName OのCreationClassName O PolicyActionName"
    },
    {
      "indent": 3,
      "text": "They are defined in Reference [1] as follows:",
      "ja": "次のように彼らは、[1]参考に定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME SystemCreationClassName DESCRIPTION SystemCreationClassName represents the class name of the CIM System object providing the naming scope for the instance of PolicyAction. For a rule-specific policy action, this is the type of system (e.g., the name of the class that created this instance) in whose context the policy rule is defined. For a reusable policy action, this is set to \"CIM_PolicyRepository\", if the PolicyRepository object is directly instantiated. Or, it is equal to the class name of the PolicyRepository subclass that is instantiated. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "NAME SystemCreationClassNameの説明SystemCreationClassNameはPolicyActionのインスタンスの命名範囲を提供するCIMシステムオブジェクトのクラス名を表します。ルール固有のポリシー・アクションのために、このポリシールールが定義され、そのコンテキスト内でシステムの種類（このインスタンスを作成したクラスの例えば、名前）です。 PolicyRepositoryオブジェクトを直接インスタンス化されている場合、再利用可能なポリシーアクションの場合、これは、「CIM_PolicyRepository」に設定されています。それとも、それがインスタンス化されたPolicyRepositoryサブクラスのクラス名と同じです。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME SystemName DESCRIPTION The name of the System object in whose scope this policy action is defined. This property completes the identification of the System object. For a rule-specific policy action, this is the name of the instance of the system in whose context the policy rule is defined. For a reusable policy action, this is name of the instance of PolicyRepository that holds the policy action. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "SystemName説明をこのポリシーアクションが定義され、その範囲内のシステム・オブジェクトの名前。このプロパティは、システムオブジェクトの識別を完了します。ルール固有のポリシー・アクションのために、このポリシールールが定義され、そのコンテキスト内でシステムのインスタンスの名前です。再利用可能なポリシーアクションの場合、これはポリシーアクションを保持しているPolicyRepositoryのインスタンスの名前です。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleCreationClassName DESCRIPTION For a rule-specific policy action, this property identifies the class name of the policy rule instance, in whose scope this instance of",
      "ja": "ルール固有のポリシーアクションの名前PolicyRuleCreationClassName説明は、このプロパティは、ポリシールールインスタンスのクラス名を識別し、その範囲のこのインスタンスで"
    },
    {
      "indent": 3,
      "text": " PolicyAction exists. For a reusable policy action, this property is set to a special value, \"No Rule\", indicating that this instance of PolicyAction is not unique to one policy rule. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyActionが存在します。再利用可能なポリシーアクションの場合、このプロパティはPolicyActionのこのインスタンスが1つのポリシールールに特有のものではないことを示す、特別な値、「いいえルール」に設定されています。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleName DESCRIPTION For a rule-specific policy action, PolicyRuleName completes the identification of the PolicyRule object with which this action is associated. For a reusable policy action, a special value, \"No Rule\", is used to indicate that this action is reusable. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "ルール固有のポリシーアクションの名前PolicyRuleName説明は、PolicyRuleNameは、このアクションが関連付けられているPolicyRuleのオブジェクトの識別を完了する。再利用可能なポリシーアクションの場合、特別な値、「いいえルール」、このアクションは、再利用可能であることを示すために使用されます。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME CreationClassName DESCRIPTION The class name of the PolicyAction subclass that is instantiated. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "NAME CreationClassNameは説明インスタンス化されたPolicyActionサブクラスのクラス名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 3,
      "text": "NAME PolicyActionName DESCRIPTION The identifying name of this policy action. SYNTAX string [MaxLen 256] QUALIFIER key",
      "ja": "PolicyActionName説明にこのポリシーアクションの識別名。構文string [のMaxLen 256]修飾子キー"
    },
    {
      "indent": 0,
      "text": "13.4. Naming Instances of PolicyRepository",
      "section_title": true,
      "ja": "13.4.  PolicyRepositoryのインスタンスに名前を付けます"
    },
    {
      "indent": 3,
      "text": "An instance of PolicyRepository is named by the two key properties CreationClassName and Name that it inherits from its superclass AdminDomain. These properties are actually defined in AdminDomain's superclass, System, and then inherited by AdminDomain.",
      "ja": "PolicyRepositoryのインスタンスは、それがそのスーパークラスから継承いるAdminDomainという二つの重要な特性のCreationClassNameとNameで命名されます。これらのプロパティは、実際にいるAdminDomainのスーパー、システムで定義され、その後、いるAdminDomainによって継承されています。"
    },
    {
      "indent": 3,
      "text": "For instances of PolicyRepository itself, the value of CreationClassName must be \"CIM_PolicyRepository\". (Recall that for readability the prefix \"CIM_\" has been omitted from all class names in this document). If a subclass of PolicyRepository (perhaps QosPolicyRepository) is defined and instantiated, then the class name \"CIM_QosPolicyRepository\" is used in CreationClassName.",
      "ja": "PolicyRepository自体のインスタンスについて、CreationClassNameはの値が「CIM_PolicyRepository」でなければなりません。 （接頭辞「CIM_が」このドキュメント内のすべてのクラス名から省略された可読性のためにそれを思い出してください）。 PolicyRepository（おそらくQosPolicyRepository）のサブクラスを定義してインスタンス化される場合には、クラス名「CIM_QosPolicyRepositoryは」のCreationClassNameに使用されます。"
    },
    {
      "indent": 3,
      "text": "The Name property simply completes the identification of the instance of PolicyRepository.",
      "ja": "Nameプロパティは、単純にPolicyRepositoryのインスタンスの識別を完了します。"
    },
    {
      "indent": 0,
      "text": "13.5. Role of the CreationClassName Property in Naming",
      "section_title": true,
      "ja": "13.5. 命名中のCreationClassNameプロパティの役割"
    },
    {
      "indent": 3,
      "text": "To provide for more flexibility in instance naming, CIM makes use of a property called CreationClassName. The idea of CreationClassName is to provide another dimension that can be used to avoid naming collisions, in the specific case of instances belonging to two different subclasses of a common superclass. An example will illustrate how CreationClassName works.",
      "ja": "インスタンスの命名でより多くの柔軟性を提供するために、CIMはCreationClassNameですというプロパティを使用します。 CreationClassNameはのアイデアは、共通のスーパークラスの二つの異なるサブクラスに属するインスタンスの特定の場合には、名前の衝突を回避するために使用することができる別の次元を提供することです。例はCreationClassNameですがどのように動作するかを説明します。"
    },
    {
      "indent": 3,
      "text": "Suppose we have instances of two different subclasses of PolicyCondition, FrameRelayPolicyCondition and BgpPolicyCondition, and that these instances apply to the same context. If we had only the single key property PolicyConditionName available for distinguishing the two instances, then a collision would result from naming both of the instances with the key value PCName = \"PC-1\". Thus policy administrators from widely different disciplines would have to coordinate their naming of PolicyConditions for this context.",
      "ja": "我々はPolicyCondition、FrameRelayPolicyConditionとBgpPolicyConditionの二つの異なるサブクラスのインスタンスを持っていると仮定し、これらのインスタンスは、同じコンテキストに適用されていること。我々は2つのインスタンスを区別するために利用可能な唯一の単一のキーのプロパティPolicyConditionNameを持っていた場合、衝突がキー値PCName =「PC-1」でのインスタンスの両方に名前を付けることから生じます。このように、広くさまざまな分野からのポリシー管理者は、このコンテキストのPolicyConditionsの彼らの命名を調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "With CreationClassName, collisions of this type can be eliminated, without requiring coordination among the policy administrators. The two instances can be distinguished by giving their CreationClassNames different values. One instance is now identified with the two keys",
      "ja": "CreationClassNameと、この種の衝突は、ポリシー管理者間の調整を必要とせずに、除去することができます。 2つのインスタンスは、そのCreationClassNamesに異なる値を与えることによって区別することができます。 1つのインスタンスが、今2つのキーで識別されます"
    },
    {
      "indent": 3,
      "text": "CreationClassName = \"FrameRelayPolicyCondition\" + PCName = \"PC-1\",",
      "ja": "CreationClassName = \"FrameRelayPolicyCondition\" + PCName = \"PC-1\"、"
    },
    {
      "indent": 3,
      "text": "while the other is identified with",
      "ja": "他はで識別されている間"
    },
    {
      "indent": 3,
      "text": "CreationClassName = \"BgpPolicyCondition\" + PCName = \"PC-1\".",
      "ja": "CreationClassName = \"BgpPolicyCondition\" + PCName = \"PC-1\"。"
    },
    {
      "indent": 3,
      "text": "Each of the instantiable classes in the Core Model includes the CreationClassName property as a key in addition to its own class-specific key property.",
      "ja": "コアモデルでのインスタンス化の各クラスは、独自のクラス固有のキープロパティに加えて、キーとしてのCreationClassNameプロパティが含まれています。"
    },
    {
      "indent": 0,
      "text": "13.6. Object References",
      "section_title": true,
      "ja": "13.6. オブジェクト参照"
    },
    {
      "indent": 3,
      "text": "Today, all CIM associations involve two object references. CIM decomposes an object reference into two parts: a high-order part that identifies an object manager and namespace, and a model path that identifies an object instance within a namespace. The model path, in turn, can be decomposed into an object class identifier and a set of key values needed to identify an instance of that class.",
      "ja": "今日では、すべてのCIMの関連は2つのオブジェクト参照を伴います。オブジェクト・マネージャと名前空間、および名前空間内のオブジェクトインスタンスを識別するモデルパスを識別する上位部分：CIMは、2つの部分にオブジェクト参照を分解する。モデル・パスは、次に、オブジェクトクラス識別子と、そのクラスのインスタンスを識別するのに必要なキー値の組に分解することができます。"
    },
    {
      "indent": 3,
      "text": "Because the object class identifier is part of the model path, a CIM object reference is strongly typed. The GroupComponent object reference in the PolicyGroupInPolicyGroup association, for example, can only point to an instance of PolicyGroup, or to an instance of a subclass of PolicyGroup. Contrast this with LDAP, where a DN pointer is completely untyped: it identifies (by DN) an entry, but places no restriction on that entry's object class(es).",
      "ja": "オブジェクトクラス識別子は、モデル・パスの一部であるため、CIMオブジェクト参照は、強く型付けされています。 PolicyGroupInPolicyGroupアソシエーションにおけるGroupComponentオブジェクト参照は、例えば、唯一のPolicyGroupのインスタンスへの、またはのPolicyGroupのサブクラスのインスタンスを指すことができます。 DNポインタが完全に型なしでLDAPとは対照的：それは（DNによって）エントリを識別するが、そのエントリのオブジェクトクラス（ES）に制限を配置しません。"
    },
    {
      "indent": 3,
      "text": "An important difference between CIM property definitions and LDAP attribute type definitions was identified earlier in Section 6: while an LDAP attribute type definition has global scope, a CIM property definition applies only to the class in which it is defined. Thus properties having the same name in two different classes are free to have different data types. CIM takes advantage of this flexibility by allowing the data type of an object reference to be overridden in a subclass of the association class in which it was initially defined.",
      "ja": "CIMプロパティの定義とLDAP属性タイプの定義の重要な違いは、以前の第6節で同定された：LDAPの属性タイプ定義はグローバルスコープを持ちながら、CIMのプロパティ定義は、それが定義されているクラスに適用されます。このように2つの異なるクラスに同じ名前を持つプロパティは、異なるデータ型を持つことは自由です。 CIMは、オブジェクト参照のデータ・タイプは、それが最初に定義された関連クラスのサブクラスでオーバーライドできるようにすることによって、この柔軟性を利用します。"
    },
    {
      "indent": 3,
      "text": "For example, the object reference GroupComponent is defined in the abstract aggregation class PolicyComponent to be a reference to an instance of the class Policy. This data type for GroupComponent is then overridden in subclasses of PolicyComponent. In PolicyGroupInPolicyGroup, for example, GroupComponent becomes a reference to an instance of PolicyGroup. But in PolicyConditionInPolicyRule it becomes a reference to an instance of PolicyRule. Of course there is not total freedom in this overriding of object references. In order to remain consistent with its abstract superclass, a subclass of PolicyComponent can only override GroupComponent to be a reference to a subclass of Policy. A Policy class is the generic context for the GroupComponent reference in PolicyComponent.",
      "ja": "例えば、オブジェクト参照GroupComponentは、クラスポリシーのインスタンスへの参照であることが抽象集約クラスPolicyComponentに定義されています。 GroupComponentのためのこのデータ型は、その後PolicyComponentのサブクラスでオーバーライドされます。 PolicyGroupInPolicyGroupでは、例えば、GroupComponentはのPolicyGroupのインスタンスへの参照となります。しかしPolicyConditionInPolicyRuleで、それはPolicyRuleのインスタンスへの参照になります。もちろん、完全な自由は、オブジェクト参照のこのオーバーライドではありません。その抽象スーパークラスとの一貫性を維持するためには、PolicyComponentのサブクラスでは、唯一の政策のサブクラスへの参照であることをGroupComponentを上書きすることができます。ポリシークラスはPolicyComponentでGroupComponent参照するための一般的な文脈です。"
    },
    {
      "indent": 0,
      "text": "14. : The Core Policy MOF",
      "section_title": true,
      "ja": "14.：基本方針MOF"
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// Title:     Core Policy MOF Specification 2.4\n// Filename:  CIM_Policy24.MOF\n// Version:   2.4\n// Release:   0\n// Description: The object classes below are listed in an order that\n//              avoids forward references.  Required objects, defined\n//        by other working groups, are omitted.\n// Date: 06/27/2000\n//     CIMCR516a - Rooted the model associations under Policy\n//        Component or PolicyInSystem.  Corrected PolicyCondition/\n//        PolicyActionInPolicyRepository to subclass from\n//        PolicyInSystem (similar to Groups and Roles 'InSystem')\n// ==================================================================\n// Author:    DMTF SLA (Service Level Agreement) Working Group\n// ==================================================================\n// Pragmas\n// ==================================================================\n#pragma Locale (\"en-US\")",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// Policy\n// ==================================================================\n   [Abstract, Description (\n         \"An abstract class describing common properties of all \"\n         \"policy rule-related subclasses, such as PolicyGroup, Policy\"\n         \"Rule and PolicyCondition. All instances of policy rule-\"\n         \"related entities will be created from subclasses of CIM_\"\n         \"Policy.  The exception to this statement is PolicyRepository \"\n         \"which is a type of CIM_System.\")\n   ]\nclass CIM_Policy : CIM_ManagedElement\n{\n      [Description (\n         \"A user-friendly name of this policy-related object.\")\n      ]\n   string CommonName;\n      [Description (\n         \"An array of keywords for characterizing / categorizing \"\n         \"policy objects.  Keywords are of one of two types: \\n\"\n         \"  o Keywords defined in this and other MOFs, or in DMTF \"\n         \"    white papers.  These keywords provide a vendor-\"\n         \"    independent, installation-independent way of \"\n         \"    characterizing policy objects. \\n\"\n         \"  o Installation-dependent keywords for characterizing \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"    policy objects.  Examples include 'Engineering', \"\n         \"    'Billing', and 'Review in December 2000'.  \\n\"\n         \"This MOF defines the following keywords:  'UNKNOWN', \"\n         \"'CONFIGURATION', 'USAGE', 'SECURITY', 'SERVICE', \"\n         \"'MOTIVATIONAL', 'INSTALLATION', and 'EVENT'.  These \"\n         \"concepts are self-explanatory and are further discussed \"\n         \"in the SLA/Policy White Paper.  One additional keyword \"\n         \"is defined: 'POLICY'.  The role of this keyword is to \"\n         \"identify policy-related instances that may not be otherwise \"\n         \"identifiable, in some implementations.  The keyword 'POLICY' \"\n         \"is NOT mutually exclusive of the other keywords \"\n         \"specified above.\")\n      ]\n   string PolicyKeywords [];\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyComponent\n// ==================================================================\n   [Association, Abstract, Aggregation, Description (\n         \"CIM_PolicyComponent is a generic association used to \"\n         \"establish 'part of' relationships between the subclasses of \"\n         \"CIM_Policy.  For example, the PolicyConditionInPolicyRule \"\n         \"association defines that PolicyConditions are part of a \"\n         \"PolicyRule.\")\n   ]\nclass CIM_PolicyComponent\n{\n       [Aggregate, Key, Description (\n         \"The parent Policy in the association.\")\n       ]\n    CIM_Policy REF GroupComponent;\n       [Key, Description (\n         \"The child/part Policy in the association.\")\n       ]\n    CIM_Policy REF PartComponent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyInSystem\n// ==================================================================\n   [Association, Abstract, Description (\n         \"  CIM_PolicyInSystem is a generic association used to \"\n         \"establish dependency relationships between Policies and the \"\n         \"Systems that host them.  These Systems may be ComputerSystems \"\n         \"where Policies are 'running' or they may be Policy\"\n         \"Repositories where Policies are stored.  This relationship \"\n         \"is similar to the concept of CIM_Services being dependent \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"on CIM_Systems as defined by the HostedService \"\n         \"association.  \\n\"\n         \"  Cardinality is Max(1) for the Antecedent/System \"\n         \"reference since Policies can only be hosted in at most one \"\n         \"System context.  Some subclasses of the association will \"\n         \"further refine this definition to make the Policies Weak \"\n         \"to Systems.  Other subclasses of PolicyInSystem will \"\n         \"define an optional hosting relationship.  Examples of each \"\n         \"of these are the PolicyRuleInSystem and PolicyConditionIn\"\n         \"PolicyRepository associations, respectively.\")\n   ]\nclass CIM_PolicyInSystem : CIM_Dependency\n{\n       [Override (\"Antecedent\"), Max (1), Description (\n         \"The hosting System.\")\n       ]\n    CIM_System REF Antecedent;\n       [Override (\"Dependent\"), Description (\n         \"The hosted Policy.\")\n       ]\n    CIM_Policy REF Dependent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// PolicyGroup\n// ==================================================================\n   [Description (\n         \"A container for either a set of related PolicyGroups \"\n         \"or a set of related PolicyRules, but not both.  Policy\"\n         \"Groups are defined and named relative to the CIM_System \"\n         \"which provides their context.\")\n   ]\nclass CIM_PolicyGroup : CIM_Policy\n{\n      [Propagated(\"CIM_System.CreationClassName\"),\n         Key, MaxLen (256),\n         Description (\"The scoping System's CreationClassName.\")\n      ]\n   string SystemCreationClassName;\n      [Propagated(\"CIM_System.Name\"),\n         Key, MaxLen (256),\n         Description (\"The scoping System's Name.\")\n      ]\n   string SystemName;\n      [Key, MaxLen (256), Description (\n         \"CreationClassName indicates the name of the class or the \"\n         \"subclass used in the creation of an instance.  When used \"\n         \"with the other key properties of this class, this property \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"allows all instances of this class and its subclasses to \"\n         \"be uniquely identified.\") ]\n   string CreationClassName;\n      [Key, MaxLen (256), Description (\n         \"A user-friendly name of this PolicyGroup.\")\n      ]\n   string PolicyGroupName;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyGroupInPolicyGroup\n// ==================================================================\n   [Association, Aggregation, Description (\n         \"A relationship that aggregates one or more lower-level \"\n         \"PolicyGroups into a higher-level Group.  A Policy\"\n         \"Group may aggregate either PolicyRules or other Policy\"\n         \"Groups, but not both.\")\n   ]\nclass CIM_PolicyGroupInPolicyGroup : CIM_PolicyComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A PolicyGroup that aggregates other Groups.\")\n        ]\n    CIM_PolicyGroup REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A PolicyGroup aggregated by another Group.\")\n        ]\n    CIM_PolicyGroup REF PartComponent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyGroupInSystem\n// ==================================================================\n   [Association, Description (\n         \"An association that links a PolicyGroup to the System \"\n         \"in whose scope the Group is defined.\")\n   ]\nclass CIM_PolicyGroupInSystem : CIM_PolicyInSystem\n{\n        [Override (\"Antecedent\"), Min(1), Max(1), Description (\n         \"The System in whose scope a PolicyGroup is defined.\")\n        ]\n    CIM_System REF Antecedent;\n        [Override (\"Dependent\"), Weak, Description (\n         \"A PolicyGroup named within the scope of a System.\")\n        ]\n    CIM_PolicyGroup REF Dependent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// PolicyRule\n// ==================================================================\n   [Description (\n        \"  The central class for representing the 'If Condition then \"\n         \"Action' semantics associated with a policy rule. \"\n         \"A PolicyRule condition, in the most general sense, is \"\n         \"represented as either an ORed set of ANDed conditions \"\n         \"(Disjunctive Normal Form, or DNF) or an ANDed set of ORed \"\n         \"conditions (Conjunctive Normal Form, or CNF). Individual \"\n         \"conditions may either be negated (NOT C) or unnegated (C). \"\n         \"The actions specified by a PolicyRule are to be performed \"\n         \"if and only if the PolicyRule condition (whether it is \"\n         \"represented in DNF or CNF) evaluates to TRUE.\\n\\n\"\n         \"  \"\n         \"The conditions and actions associated with a PolicyRule \"\n         \"are modeled, respectively, with subclasses of Policy\"\n         \"Condition and PolicyAction.  These condition and action \"\n         \"objects are tied to instances of PolicyRule by the Policy\"\n         \"ConditionInPolicyRule and PolicyActionInPolicyRule \"\n         \"aggregations.\\n\\n\"\n         \"  \"\n         \"A PolicyRule may also be associated with one or more policy \"\n         \"time periods, indicating the schedule according to which the \"\n         \"policy rule is active and inactive.  In this case it is the \"\n         \"PolicyRuleValidityPeriod aggregation that provides this \"\n         \"linkage.\\n\\n\"\n         \"  \"\n         \"The PolicyRule class uses the property ConditionListType, to \"\n         \"indicate whether the conditions for the rule are in DNF or \"\n         \"CNF.  The PolicyConditionInPolicyRule aggregation contains \"\n         \"two additional properties to complete the representation of \"\n         \"the Rule's conditional expression.  The first of these \"\n         \"properties is an integer to partition the referenced \"\n         \"PolicyConditions into one or more groups, and the second is a \"\n         \"Boolean to indicate whether a referenced Condition is \"\n         \"negated.  An example shows how ConditionListType and these \"\n         \"two additional properties provide a unique representation \"\n         \"of a set of PolicyConditions in either DNF or CNF.\\n\\n\"\n         \"  \"\n         \"Suppose we have a PolicyRule that aggregates five \"\n         \"PolicyConditions C1  through C5, with the following values \"\n         \"in the properties of the five PolicyConditionInPolicyRule \"\n         \"associations:\\n\"\n         \"    C1:  GroupNumber = 1, ConditionNegated = FALSE\\n \"\n         \"    C2:  GroupNumber = 1, ConditionNegated = TRUE\\n  \"\n         \"    C3:  GroupNumber = 1, ConditionNegated = FALSE\\n \"\n         \"    C4:  GroupNumber = 2, ConditionNegated = FALSE\\n \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"    C5:  GroupNumber = 2, ConditionNegated = FALSE\\n\\n \"\n         \"  \"\n         \"If ConditionListType = DNF, then the overall condition for \"\n         \"the PolicyRule is:\\n\"\n         \"        (C1 AND (NOT C2) AND C3) OR (C4 AND C5)\\n\\n\"\n         \"  \"\n         \"On the other hand, if ConditionListType = CNF, then the \"\n         \"overall condition for the PolicyRule is:\\n\"\n         \"        (C1 OR (NOT C2) OR C3) AND (C4 OR C5)\\n\\n\"\n         \"  \"\n         \"In both cases, there is an unambiguous specification of \"\n         \"the overall condition that is tested to determine whether \"\n         \"to perform the PolicyActions associated with the PolicyRule.\")\n   ]\nclass CIM_PolicyRule : CIM_Policy\n{\n        [Propagated(\"CIM_System.CreationClassName\"),\n         Key, MaxLen (256),\n         Description (\"The scoping System's CreationClassName.\")\n        ]\n    string SystemCreationClassName;\n        [Propagated(\"CIM_System.Name\"),\n         Key, MaxLen (256),\n         Description (\"The scoping System's Name.\")\n        ]\n    string SystemName;\n        [Key, MaxLen (256), Description (\n           \"CreationClassName indicates the name of the class or the \"\n           \"subclass used in the creation of an instance.  When used \"\n           \"with the other key properties of this class, this property \"\n           \"allows all instances of this class and its subclasses to \"\n           \"be uniquely identified.\") ]\n    string CreationClassName;\n        [Key, MaxLen (256), Description (\n           \"A user-friendly name of this PolicyRule.\")\n        ]\n    string PolicyRuleName;\n        [Description (\n           \"Indicates whether this PolicyRule is administratively \"\n           \"enabled, administratively disabled, or enabled for \"\n           \"debug.  When the property has the value 3 (\\\"enabledFor\"\n           \"Debug\\\"), the entity evaluating the PolicyConditions is \"\n           \"instructed to evaluate the conditions for the Rule, but not \"\n           \"to perform the actions if the PolicyConditions evaluate to \"\n           \"TRUE.  This serves as a debug vehicle when attempting to \"\n           \"determine what policies would execute in a particular \"\n           \"scenario, without taking any actions to change state \"\n           \"during the debugging.  The default value is 1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "(\\\"enabled\\\").\"),\n         ValueMap { \"1\", \"2\", \"3\" },\n         Values { \"enabled\", \"disabled\", \"enabledForDebug\" }\n        ]\n    uint16 Enabled;\n        [Description (\n           \"Indicates whether the list of PolicyConditions \"\n           \"associated with this PolicyRule is in disjunctive \"\n           \"normal form (DNF) or conjunctive normal form (CNF).\"\n           \"The default value is 1 (\\\"DNF\\\").\"),\n         ValueMap { \"1\", \"2\" },\n         Values { \"DNF\", \"CNF\" }\n        ]\n    uint16 ConditionListType;\n        [Description (\n           \"A free-form string that can be used to provide \"\n           \"guidelines on how this PolicyRule should be used.\")\n        ]\n    string RuleUsage;\n        [Description (\n           \"A non-negative integer for prioritizing this Policy\"\n           \"Rule relative to other Rules.  A larger value \"\n           \"indicates a higher priority.  The default value is 0.\")\n        ]\n    uint16 Priority;\n        [Description (\n           \"A flag indicating that the evaluation of the Policy\"\n           \"Conditions and execution of PolicyActions (if the \"\n           \"Conditions evaluate to TRUE) is required.  The \"\n           \"evaluation of a PolicyRule MUST be attempted if the \"\n           \"Mandatory property value is TRUE.  If the Mandatory \"\n           \"property is FALSE, then the evaluation of the Rule \"\n           \"is 'best effort' and MAY be ignored.\")\n        ]\n    boolean Mandatory;\n        [Description (\n           \"This property gives a policy administrator a way \"\n           \"of specifying how the ordering of the PolicyActions \"\n           \"associated with this PolicyRule is to be interpreted. \"\n           \"Three values are supported:\\n\"\n           \"  o mandatory(1): Do the actions in the indicated \"\n           \"    order, or don't do them at all.\\n\"\n           \"  o recommended(2): Do the actions in the indicated \"\n           \"    order if you can, but if you can't do them in this \"\n           \"    order, do them in another order if you can.\\n\"\n           \"  o dontCare(3): Do them -- I don't care about the \"\n           \"    order.\\n\"\n           \"The default value is 3 (\\\"dontCare\\\").\"),",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         ValueMap { \"1\", \"2\", \"3\" },\n         Values { \"mandatory\", \"recommended\", \"dontCare\" }\n        ]\n    uint16 SequencedActions;\n        [Description (\n         \"This property represents the roles and role combinations \"\n         \"associated with a PolicyRule.  Each value represents one \"\n         \"role or role combination.  Since this is a multi-valued \"\n         \"property, more than one role or combination can be associated \"\n         \"with a single policy rule.  Each value is a string of the \"\n         \"form:\\n\"\n         \"  <RoleName>[&&<RoleName>]*\\n\"\n         \"where the individual role names appear in alphabetical order \"\n         \"(according to the collating sequence for UCS-2).\")\n        ]\n    string PolicyRoles [];\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyRuleInPolicyGroup\n// ==================================================================\n   [Association, Aggregation, Description (\n         \"A relationship that aggregates one or more PolicyRules \"\n         \"into a PolicyGroup.  A PolicyGroup may aggregate either \"\n         \"PolicyRules or other PolicyGroups, but not both.\")\n   ]\nclass CIM_PolicyRuleInPolicyGroup : CIM_PolicyComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A PolicyGroup that aggregates one or more PolicyRules.\")\n        ]\n    CIM_PolicyGroup REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A PolicyRule aggregated by a PolicyGroup.\")\n        ]\n    CIM_PolicyRule REF PartComponent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyRuleInSystem\n// ==================================================================\n   [Association, Description (\n         \"An association that links a PolicyRule to the System \"\n         \"in whose scope the Rule is defined.\")\n   ]\nclass CIM_PolicyRuleInSystem : CIM_PolicyInSystem\n{\n        [Override (\"Antecedent\"), Min(1), Max(1), Description (",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"The System in whose scope a PolicyRule is defined.\")\n        ]\n    CIM_System REF Antecedent;\n        [Override (\"Dependent\"), Weak, Description (\n         \"A PolicyRule named within the scope of a System.\")\n        ]\n    CIM_PolicyRule REF Dependent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// PolicyRepository\n// ==================================================================\n   [Description (\n         \"A class representing an administratively defined \"\n         \"container for reusable policy-related information. \"\n         \"This class does not introduce any additional \"\n         \"properties beyond those in its superclass \"\n         \"AdminDomain.  It does, however, participate in a \"\n         \"number of unique associations.\"\n         \"\\n\\n\"\n         \"An instance of this class uses the NameFormat value\"\n         \"\\\"PolicyRepository\\\", which is defined in the AdminDomain\"\n         \"class.\")\n   ]\nclass CIM_PolicyRepository : CIM_AdminDomain\n{\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyRepositoryInPolicyRepository\n// ==================================================================\n   [Association, Aggregation, Description (\n         \"A relationship that aggregates one or more lower-level \"\n         \"PolicyRepositories into a higher-level Repository.\")\n   ]\nclass CIM_PolicyRepositoryInPolicyRepository : CIM_SystemComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"A PolicyRepository that aggregates other Repositories.\")\n        ]\n    CIM_PolicyRepository REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"A PolicyRepository aggregated by another Repository.\")\n        ]\n    CIM_PolicyRepository REF PartComponent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// PolicyCondition\n// ==================================================================\n   [Abstract, Description (\n         \"A class representing a rule-specific or reusable policy \"\n         \"condition to be evaluated in conjunction with a Policy\"\n         \"Rule.  Since all operational details of a PolicyCondition \"\n         \"are provided in subclasses of this object, this class is \"\n         \"abstract.\")\n   ]\nclass CIM_PolicyCondition : CIM_Policy\n{\n        [Key, MaxLen (256), Description (\n          \"  The name of the class or the subclass used in the \"\n          \"creation of the System object in whose scope this \"\n          \"PolicyCondition is defined.\\n\\n\"\n          \"  \"\n          \"This property helps to identify the System object in \"\n          \"whose scope this instance of PolicyCondition exists. \"\n          \"For a rule-specific PolicyCondition, this is the System \"\n          \"in whose context the PolicyRule is defined.  For a \"\n          \"reusable PolicyCondition, this is the instance of \"\n          \"PolicyRepository (which is a subclass of System) that \"\n          \"holds the Condition.\\n\\n\"\n          \"  \"\n          \"Note that this property, and the analogous property \"\n          \"SystemName, do not represent propagated keys from an \"\n          \"instance of the class System.  Instead, they are \"\n          \"properties defined in the context of this class, which \"\n          \"repeat the values from the instance of System to which \"\n          \"this PolicyCondition is related, either directly via the \"\n          \"PolicyConditionInPolicyRepository aggregation or indirectly \"\n          \"via the PolicyConditionInPolicyRule aggregation.\")\n        ]\n    string SystemCreationClassName;\n        [Key, MaxLen (256), Description (\n         \"  The name of the System object in whose scope this \"\n         \"PolicyCondition is defined.\\n\\n\"\n         \"  \"\n         \"This property completes the identification of the System \"\n         \"object in whose scope this instance of PolicyCondition \"\n         \"exists.  For a rule-specific PolicyCondition, this is the \"\n         \"System in whose context the PolicyRule is defined.  For a \"\n         \"reusable PolicyCondition, this is the instance of \"\n         \"PolicyRepository (which is a subclass of System) that \"\n         \"holds the Condition.\")\n        ]\n    string SystemName;\n        [Key, MaxLen (256), Description (",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"For a rule-specific PolicyCondition, the \"\n         \"CreationClassName of the PolicyRule object with which \"\n         \"this Condition is associated.  For a reusable Policy\"\n         \"Condition, a special value, 'NO RULE', should be used to \"\n         \"indicate that this Condition is reusable and not \"\n         \"associated with a single PolicyRule.\")\n        ]\n    string PolicyRuleCreationClassName;\n        [Key, MaxLen (256), Description (\n         \"For a rule-specific PolicyCondition, the name of \"\n         \"the PolicyRule object with which this Condition is \"\n         \"associated.  For a reusable PolicyCondition, a \"\n         \"special value, 'NO RULE', should be used to indicate \"\n         \"that this Condition is reusable and not associated \"\n         \"with a single PolicyRule.\")\n        ]\n    string PolicyRuleName;\n        [Key, MaxLen (256), Description (\n           \"CreationClassName indicates the name of the class or the \"\n           \"subclass used in the creation of an instance.  When used \"\n           \"with the other key properties of this class, this property \"\n           \"allows all instances of this class and its subclasses to \"\n           \"be uniquely identified.\") ]\n    string CreationClassName;\n        [Key, MaxLen (256), Description (\n           \"A user-friendly name of this PolicyCondition.\")\n        ]\n    string PolicyConditionName;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyConditionInPolicyRule\n// ==================================================================\n   [Association, Aggregation, Description (\n        \"  A PolicyRule aggregates zero or more instances of the \"\n        \"PolicyCondition class, via the PolicyConditionInPolicyRule \"\n        \"association.  A Rule that aggregates zero Conditions is not \"\n        \"valid -- it may, however, be in the process of being entered \"\n        \"into a PolicyRepository or being defined for a System.  Note \"\n        \"that a PolicyRule should have no effect until it is valid.\\n\\n\"\n        \"  \"\n        \"The Conditions aggregated by a PolicyRule are grouped into \"\n        \"two levels of lists: either an ORed set of ANDed sets of \"\n        \"conditions (DNF, the default) or an ANDed set of ORed sets \"\n        \"of conditions (CNF).  Individual PolicyConditions in these \"\n        \"lists may be negated.  The property ConditionListType \"\n        \"specifies which of these two grouping schemes applies to a \"\n        \"particular PolicyRule.\\n\\n\"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        \"  \"\n        \"In either case, PolicyConditions are used to determine whether \"\n        \"to perform the PolicyActions associated with the\nPolicyRule.\\n\\n\"\n        \"  \"\n        \"One or more PolicyTimePeriodConditions may be among the \"\n        \"conditions associated with a PolicyRule via the Policy\"\n        \"ConditionInPolicyRule association.  In this case, the time \"\n        \"periods are simply additional Conditions to be evaluated \"\n        \"along with any others that are specified for the Rule. \")\n   ]\nclass CIM_PolicyConditionInPolicyRule : CIM_PolicyComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This property represents the PolicyRule that \"\n         \"contains one or more PolicyConditions.\")\n        ]\n    CIM_PolicyRule REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"This property holds the name of a PolicyCondition \"\n         \"contained by one or more PolicyRules.\")\n        ]\n    CIM_PolicyCondition REF PartComponent;\n        [Description (\n         \"Unsigned integer indicating the group to which the \"\n         \"PolicyCondition identified by the ContainedCondition \"\n         \"property belongs.  This integer segments the Conditions \"\n         \"into the ANDed sets (when the ConditionListType is \"\n         \"\\\"DNF\\\") or similarly the ORed sets (when the Condition\"\n         \"ListType is \\\"CNF\\\") that are then evaluated.\")\n        ]\n    uint16 GroupNumber;\n        [Description (\n         \"Indication of whether the Condition identified by \"\n         \"the ContainedCondition property is negated.  TRUE \"\n         \"indicates that the PolicyCondition IS negated, FALSE \"\n         \"indicates that it IS NOT negated.\")\n        ]\n    boolean ConditionNegated;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyConditionInPolicyRepository\n// ==================================================================\n   [Association, Description (\n         \"  A class representing the hosting of reusable \"\n         \"PolicyConditions by a PolicyRepository.  A reusable Policy\"\n         \"Condition is always related to a single PolicyRepository, \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"via this aggregation.\\n\\n\"\n         \"  \"\n         \"Note, that an instance of PolicyCondition can be either \"\n         \"reusable or rule-specific.  When the Condition is rule-\"\n         \"specific, it shall not be related to any \"\n         \"PolicyRepository via the PolicyConditionInPolicyRepository \"\n         \"aggregation.\")\n   ]\nclass CIM_PolicyConditionInPolicyRepository : CIM_PolicyInSystem\n{\n        [Override (\"Antecedent\"), Max(1), Description (\n         \"This property identifies a PolicyRepository \"\n         \"hosting one or more PolicyConditions.  A reusable \"\n         \"PolicyCondition is always related to exactly one \"\n         \"PolicyRepository via the PolicyConditionInPolicyRepository \"\n         \"aggregation.  The [0..1] cardinality for this property \"\n         \"covers the two types of PolicyConditions:  0 for a \"\n         \"rule-specific PolicyCondition, 1 for a reusable one.\")\n        ]\n    CIM_PolicyRepository REF Antecedent;\n        [Override (\"Dependent\"), Description (\n         \"This property holds the name of a PolicyCondition\"\n         \"hosted in the PolicyRepository. \")\n        ]\n    CIM_PolicyCondition REF Dependent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// PolicyTimePeriodCondition\n// ==================================================================\n   [Description (\n         \"  This class provides a means of representing the time \"\n         \"periods during which a PolicyRule is valid, i.e., active. \"\n         \"At all times that fall outside these time periods, the \"\n         \"PolicyRule has no effect.  A Rule is treated as valid \"\n         \"at ALL times, if it does not specify a \"\n         \"PolicyTimePeriodCondition.\\n\\n\"\n         \"  \"\n         \"In some cases a Policy Consumer may need to perform \"\n         \"certain setup / cleanup actions when a PolicyRule becomes \"\n         \"active / inactive.  For example, sessions that were \"\n         \"established while a Rule was active might need to \"\n         \"be taken down when the Rule becomes inactive.  In other \"\n         \"cases, however, such sessions might be left up.  In this \"\n         \"case, the effect of deactivating the PolicyRule would \"\n         \"just be to prevent the establishment of new sessions. \\n\\n\"\n         \"  \"\n         \"Setup / cleanup behaviors on validity period \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": " \"transitions are not currently addressed by the Policy \" \"Model, and must be specified in 'guideline' documents or \" \"via subclasses of CIM_PolicyRule, CIM_PolicyTimePeriod\" \"Condition or other concrete subclasses of CIM_Policy. If \" \"such behaviors need to be under the control of the policy \" \"administrator, then a mechanism to allow this control \" \"must also be specified in the subclasses.\\n\\n\" \" \" \"PolicyTimePeriodCondition is defined as a subclass of \" \"PolicyCondition. This is to allow the inclusion of \" \"time-based criteria in the AND/OR condition definitions \" \"for a PolicyRule.\\n\\n\" \" \" \"Instances of this class may have up to five properties \" \"identifying time periods at different levels. The values \" \"of all the properties present in an instance are ANDed \" \"together to determine the validity period(s) for the \" \"instance. For example, an instance with an overall \" \"validity range of January 1, 2000 through December 31, \" \"2000; a month mask that selects March and April; a \" \"day-of-the-week mask that selects Fridays; and a time \" \"of day range of 0800 through 1600 would be represented \" \"using the following time periods:\\n\" \" Friday, March 5, 2000, from 0800 through 1600;\\n \" \" Friday, March 12, 2000, from 0800 through 1600;\\n \" \" Friday, March 19, 2000, from 0800 through 1600;\\n \" \" Friday, March 26, 2000, from 0800 through 1600;\\n \" \" Friday, April 2, 2000, from 0800 through 1600;\\n \" \" Friday, April 9, 2000, from 0800 through 1600;\\n \" \" Friday, April 16, 2000, from 0800 through 1600;\\n \" \" Friday, April 23, 2000, from 0800 through 1600;\\n \" \" Friday, April 30, 2000, from 0800 through 1600.\\n\\n\" \" \" \"Properties not present in an instance of \" \"PolicyTimePeriodCondition are implicitly treated as having \" \"their value 'always enabled'. Thus, in the example above, \" \"the day-of-the-month mask is not present, and so the \" \"validity period for the instance implicitly includes a \" \"day-of-the-month mask that selects all days of the month. \" \"If this 'missing property' rule is applied to its fullest, we \" \"see that there is a second way to indicate that a Policy\" \"Rule is always enabled: associate with it an instance of \" \"PolicyTimePeriodCondition whose only properties with \" \"specific values are its key properties.\") ] class CIM_PolicyTimePeriodCondition : CIM_PolicyCondition { [Description (",
      "ja": "「モデル「遷移は、現在のポリシーによって対処されていない」、および「条件またはCIM_Policyの他の具象サブクラス「CIM_PolicyRule、CIM_PolicyTimePeriodのサブクラスを経由して」」 『ガイドライン』の文書で指定したりする必要があります。そのような行動が下にする必要があります」」場合ポリシー「『その後、管理者、この制御を可能にする仕組み』のコントロール 『もサブクラスに指定する必要があります\\ n \\ n』は」「」PolicyCondition 『PolicyTimePeriodConditionはのサブクラスとして定義されている』。これができるようにすることですPolicyRuleのための 『AND / OR条件の定義における時間ベースの基準』、「含める 『\\ N \\ n』は」「異なるレベル期間を識別する」 『このクラスのインスタンスは、最大5つの特性を有していてもよい』。値「2000年1月1日の」有効範囲 『全体とインスタンス、インスタンス、例えば、』 『の有効期間（S）を決定するために一緒に』 『インスタンス内に存在するすべてのプロパティを論理積しているの』 12月31日まで、 「 『2000; 3月と4月を選択月のマスク;』金曜日を選択し、「曜日マスク。そして「時間以下の時間帯を使用して 『『1600年を通じて0800の日の範囲のが表現される』：\\ n』は」2000年3月5日（金曜日）、0800から1600年を通して; \\ n「」この2000年3月12日（金曜日）、 \\ n \"は\" 0800から1600年を通じて2000年3月19日（金曜日）、;; \\ n \"は、0800からの\\ n \"\" 2000年4月2日（金曜日）、\" 0800から1600年を通じて2000年3月26日（金曜日）、1600年を通じて0800から1600年を通して; \\ n \"は\" 0800から1600年を通じて2000年4月9日（金曜日）、; \\ n \"は\" 0800から1600年を通じて2000年4月16日（金曜日）、; \\ n \"\" この2000年4月23日（金曜日）、0800から1600年を通して; \\ 『のインスタンスに存在しないn「は」2000年4月30日（金曜日）、0800から1600経由のn \\ nを\\「『』』プロパティその値は 『常に有効』」 『PolicyTimePeriodConditionは、暗黙的に持つものとして扱われます』。したがって、上記の例では、「『日の-ヶ月のマスクは存在せず、そのため』例えば 『の有効期間は、暗黙のうちのすべての日を選択し、』」日・オブ・-月マスクを含み月。 『この『不足しているプロパティ』ルールが最大限に適用されている場合は、私たちは』「『ポリシー』ことを示すために、第二の方法があることがわかり、 『ルールは常に有効になっている：仲間をそれとのインスタンス』プロパティのみを持つPolicyTimePeriodConditionを」 \" \"特定の値は、そのキー特性である。\"）]クラスCIM_PolicyTimePeriodCondition：CIM_PolicyCondition {[説明（"
    },
    {
      "indent": 4,
      "text": "     \"  This property identifies an overall range of calendar \"\n     \"dates and times over which a PolicyRule is valid.  It is \"\n     \"formatted as a string representing a start date and time, \"\n     \"in which the character 'T' indicates the beginning of the \"\n     \"time portion, followed by the solidus character '/', \"\n     \"followed by a similar string representing an end date and \"\n     \"time.  The first date indicates the beginning of the range, \"\n     \"while the second date indicates the end.  Thus, the second \"\n     \"date and time must be later than the first.  Date/times are \"\n     \"expressed as substrings of the form yyyymmddThhmmss.  For \"\n     \"example: \\n\"\n     \"   20000101T080000/20000131T120000 defines \\n\"\n     \"   January 1, 2000, 0800 through January 31, 2000, noon\\n\\n\"\n     \"  \"\n     \"There are also two special cases in which one of the \"\n     \"date/time strings is replaced with a special string defined \"\n     \"in RFC 2445.\\n \"\n     \"   o If the first date/time is replaced with the string \"\n     \"     'THISANDPRIOR', then the property indicates that a \"\n     \"     PolicyRule is valid [from now] until the date/time \"\n     \"     that appears after the '/'.\\n\"\n     \"   o If the second date/time is replaced with the string \"\n     \"     'THISANDFUTURE', then the property indicates that a \"\n     \"     PolicyRule becomes valid on the date/time that \"\n     \"     appears before the '/', and remains valid from that \"\n     \"     point on. \"),\n     ModelCorrespondence {\n    \"CIM_PolicyTimePeriodCondition.MonthOfYearMask\",\n    \"CIM_PolicyTimePeriodCondition.DayOfMonthMask\",\n    \"CIM_PolicyTimePeriodCondition.DayOfWeekMask\",\n    \"CIM_PolicyTimePeriodCondition.TimeOfDayMask\",\n    \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n    ]\nstring TimePeriod;\n    [Octetstring, Description (\n     \"  The purpose of this property is to refine the valid time \"\n     \"period that is defined by the TimePeriod property, by \"\n     \"explicitly specifying in which months the PolicyRule is \"\n     \"valid.  These properties work together, with the \"\n     \"TimePeriod used to specify the overall time period in \"\n     \"which the PolicyRule is valid, and the MonthOfYearMask used \"\n     \"to pick out the months during which the Rule is valid.\\n\\n\"\n     \"  \"\n     \"This property is formatted as an octet string, structured \"\n     \"as follows:\\n\"\n     \"   o a 4-octet length field, indicating the length of the \"\n     \"    entire octet string; this field is always set to \"\n     \"    0x00000006 for this property;\\n\"",
      "raw": true
    },
    {
      "indent": 4,
      "text": " \" o a 2-octet field consisting of 12 bits identifying the \" \" 12 months of the year, beginning with January and \" \" ending with December, followed by 4 bits that are \" \" always set to '0'. For each month, the value '1' \" \" indicates that the policy is valid for that month, \" \" and the value '0' indicates that it is not valid.\\n\\n\" \" \" \"The value 0x000000060830, for example, indicates that a \" \"PolicyRule is valid only in the months May, November, \" \"and December.\\n\\n\" \" \" \"If a value for this property is not provided, then the \" \"PolicyRule is treated as valid for all twelve months, and \" \"only restricted by its TimePeriod property value and the \" \"other Mask properties.\"), ModelCorrespondence { \"CIM_PolicyTimePeriodCondition.TimePeriod\", \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"} ] uint8 MonthOfYearMask[]; [Octetstring, Description ( \" The purpose of this property is to refine the valid time \" \"period that is defined by the TimePeriod property, by \" \"explicitly specifying in which days of the month the Policy\" \"Rule is valid. These properties work together, \" \"with the TimePeriod used to specify the overall time period \" \"in which the PolicyRule is valid, and the DayOfMonthMask used \" \"to pick out the days of the month during which the Rule \" \"is valid.\\n\\n \" \" \" \"This property is formatted as an octet string, structured \" \"as follows:\\n\" \" o a 4-octet length field, indicating the length of the \" \" entire octet string; this field is always set to \" \" 0x0000000C for this property; \\n\" \" o an 8-octet field consisting of 31 bits identifying \" \" the days of the month counting from the beginning, \" \" followed by 31 more bits identifying the days of the \" \" month counting from the end, followed by 2 bits that \" \" are always set to '0'. For each day, the value '1' \" \" indicates that the policy is valid for that day, and \" \" the value '0' indicates that it is not valid. \\n\\n\" \" \" \"The value 0x0000000C8000000100000000, for example, \" \"indicates that a PolicyRule is valid on the first and \" \"last days of the month.\\n\\n \" \" \" \"For months with fewer than 31 days, the digits corresponding \"",
      "ja": "各月について。「常に 『0』に設定「されている4ビットに続いて、12月で終わる」「1月から始まると、今年の」12ヶ月「OA 2オクテットフィールドが識別12ビットからなります」、値が「1」「「0」」と値「政策は、その月に有効であることを示し、」それが有効でないことを示しています。\\ n \\ n」は 『』 『値0x000000060830は、例えば、ことを示しています』 「PolicyRuleのは、唯一ヶ月月、11月に有効であり、」「12月。\\ N \\ N」「」「このプロパティの値が提供されていない場合は、」「PolicyRuleのは、すべての12ヶ月間有効なものとして扱われ、 \" \"他のマスク特性 \"のみ、その時間期間のプロパティ値とによって制限\"\"）、ModelCorrespondence { \"CIM_PolicyTimePeriodCondition.TimePeriod\"、 \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}] UINT8 MonthOfYearMask []。 [OCTETSTRING、説明（「この特性の目的は有効な時間を洗練することです」「時間期間プロパティによって定義された期間、」「明示的ポリシー月のどの日に指定する」によって、「ルールが有効である。これらのプロパティは、仕事一緒に、「PolicyRuleのが有効である 『とDayOfMonthMask『全体的な期間を指定するために使用される時間期間で』』使用」は有効です。\\ nは\\ n 『は月の日を選ぶためにどのルールの中に』 「」「次のように 『『この特性は、オクテット文字列としてフォーマット構成されている』：「全体のオクテット列』の長さを示すOA 4オクテットの長さフィールド、」\\ n」を、このフィールドは常に0x0000000C「」に設定されていますこのプロパティの;の\\ n「『O識別する31ビットからなる8オクテットフィールド』 『」月の終わりから数え『の日識別する31ビット以上続く』先頭から数え月』の日、2ビットが続く「は、」常に「0」に設定されている毎日、値「1」の場合は「」ポリシーことを示しますその日のために有効であり、そして「」値「0」、それが有効でないことを示しています。 \\ N \\ N「『』 『値0x0000000C8000000100000000は、例えば、』 『第一及び』上のPolicyRuleが有効であることを示し、 『月の最後の日。\\ N \\ N』 『』」数ヶ月のために31日より少ないと、数字は「対応します"
    },
    {
      "indent": 4,
      "text": "     \"to days that the months do not have (counting in both \"\n     \"directions) are ignored.\\n\\n\"\n     \"  \"\n     \"If a value for this property is not provided, then the \"\n     \"PolicyRule is treated as valid for all days of the month, and \"\n     \"only restricted by its TimePeriod property value and the \"\n     \"other Mask properties.\"),\n    ModelCorrespondence {\n    \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n    \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n    ]\nuint8 DayOfMonthMask[];\n    [Octetstring, Description (\n     \"  The purpose of this property is to refine the valid time \"\n     \"period that is defined by the TimePeriod property, by \"\n     \"explicitly specifying in which days of the month the Policy\"\n     \"Rule is valid.  These properties work together, \"\n     \"with the TimePeriod used to specify the overall time period \"\n     \"in which the PolicyRule is valid, and the DayOfWeekMask used \"\n     \"to pick out the days of the week during which the Rule \"\n     \"is valid.\\n\\n \"\n     \"  \"\n     \"This property is formatted as an octet string, structured \"\n     \"as follows:\\n \"\n     \"  o a 4-octet length field, indicating the length of the \"\n     \"    entire octet string; this field is always set to \"\n     \"    0x00000005 for this property;\\n\"\n     \"  o a 1-octet field consisting of 7 bits identifying the 7 \"\n     \"    days of the week, beginning with Sunday and ending with \"\n     \"    Saturday, followed by 1 bit that is always set to '0'. \"\n     \"    For each day of the week, the value '1' indicates that \"\n     \"    the policy is valid for that day, and the value '0' \"\n     \"    indicates that it is not valid. \\n\\n\"\n     \"  \"\n     \"The value 0x000000057C, for example, indicates that a \"\n     \"PolicyRule is valid Monday through Friday.\\n\\n\"\n     \"  \"\n     \"If a value for this property is not provided, then the \"\n     \"PolicyRule is treated as valid for all days of the week, \"\n     \"and only restricted by its TimePeriod property value and \"\n     \"the other Mask properties.\"),\n    ModelCorrespondence {\n    \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n    \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"}\n    ]\nuint8 DayOfWeekMask[];\n    [Description (\n     \"  The purpose of this property is to refine the valid time \"",
      "raw": true
    },
    {
      "indent": 4,
      "text": " \"period that is defined by the TimePeriod property, by \" \"explicitly specifying a range of times in a day during which \" \"the PolicyRule is valid. These properties work \" \"together, with the TimePeriod used to specify the overall \" \"time period in which the PolicyRule is valid, and the \" \"TimeOfDayMask used to pick out the range of time periods \" \"in a given day of during which the Rule is valid. \\n\\n\" \" \" \"This property is formatted in the style of RFC 2445: a \" \"time string beginning with the character 'T', followed by \" \"the solidus character '/', followed by a second time string. \" \"The first time indicates the beginning of the range, while \" \"the second time indicates the end. Times are expressed as \" \"substrings of the form 'Thhmmss'. \\n\\n\" \" \" \"The second substring always identifies a later time than \" \"the first substring. To allow for ranges that span \" \"midnight, however, the value of the second string may be \" \"smaller than the value of the first substring. Thus, \" \"'T080000/T210000' identifies the range from 0800 until 2100, \" \"while 'T210000/T080000' identifies the range from 2100 until \" \"0800 of the following day. \\n\\n\" \" \" \"When a range spans midnight, it by definition includes \" \"parts of two successive days. When one of these days is \" \"also selected by either the MonthOfYearMask, \" \"DayOfMonthMask, and/or DayOfWeekMask, but the other day is \" \"not, then the policy is active only during the portion of \" \"the range that falls on the selected day. For example, if \" \"the range extends from 2100 until 0800, and the day of \" \"week mask selects Monday and Tuesday, then the policy is \" \"active during the following three intervals:\\n\" \" From midnight Sunday until 0800 Monday; \\n\" \" From 2100 Monday until 0800 Tuesday; \\n\" \" From 2100 Tuesday until 23:59:59 Tuesday. \\n\\n\" \" \" \"If a value for this property is not provided, then the \" \"PolicyRule is treated as valid for all hours of the day, \" \"and only restricted by its TimePeriod property value and \" \"the other Mask properties.\"), ModelCorrespondence { \"CIM_PolicyTimePeriodCondition.TimePeriod\", \"CIM_PolicyTimePeriodCondition.LocalOrUtcTime\"} ] string TimeOfDayMask; [Description ( \" This property indicates whether the times represented \" \"in the TimePeriod property and in the various Mask \"",
      "ja": "明示的に「その間、一日中時間の範囲を指定する「のPolicyRuleが有効である。これらのプロパティは仕事」時間期間は、全体的な「「期間を指定するために使用して、一緒に」」「によって、時間期間プロパティによって定義された期間、」ここでのPolicyRuleは有効であり、かつ「ルールが有効で、その間の特定の日に 『『TimeOfDayMaskは、期間の範囲を選び出すために使用される』。\\ N \\ N』」 \"「このプロパティは、スタイルでフォーマットされRFC 2445の：二度目の文字列が続く 『ソリダス文字『/』「『に続く文字 『T』で始まる時刻の文字列、』、』」 『初めてながら、範囲の始まりを示します』第二時間が終了を示す。タイムズ「として表される 『形態『Thhmmss』のサブストリング\\ n \\ n』は」「『第二のサブストリングは、常に最初のサブストリング』」より後の時間を識別する。及ぶ範囲を可能にするために「『最初のサブストリングの値よりも小さい『真夜中は、しかし、2番目の文字列の値であってもよい』。従って、』」 'T080000 / T210000' 「は、0800から2100までの範囲を特定する 『ながら『次の日の0800」』T210000 / T080000 2100までの範囲を特定します』。 \\ N \\ N「『』」2日連続の部分を 『範囲が真夜中にまたがる場合は、それは定義によって含まれます』。これらの日のいずれかが「ある場合 『DayOfMonthMask、及び/又はDayOfWeekMask『もMonthOfYearMask、のいずれかで選択された』が、他の日には、上で落ちる範囲」『ではない場合、ポリシーのみの部分の間アクティブである』』であります選択された日。 「『範囲は2100から0800まで延びており、一日の』 『週マスクは月曜日と火曜日を選択した場合、そのポリシーは』 『次の三つの間隔中にアクティブます：\\ n』である」真夜中の日曜日から0800まで、月曜日; \\ 2100月曜日から火曜日0800までのn」 \";午後11時59分59秒火曜日まで火曜日2100年からの\\ n」 \"。 \\ N \\ N「『』 『このプロパティの値が提供されていない場合は、』 『PolicyRuleのは』、その日のすべての時間のために有効なものとして扱われている 『とだけその時間期間のプロパティ値とによって制限』」他のマスク。プロパティ「）、ModelCorrespondence { 『CIM_PolicyTimePeriodCondition.TimePeriod』、 『CIM_PolicyTimePeriodCondition.LocalOrUtcTime』}]ストリングTimeOfDayMask; [説明（」このプロパティは、 『時間期間性および様々なマスクの』 \"時間が表されるかどうかを示します"
    },
    {
      "indent": 0,
      "text": "         \"properties represent local times or UTC times.  There is \"\n         \"no provision for mixing of local times and UTC times:  the \"\n         \"value of this property applies to all of the other \"\n         \"time-related properties.\"),\n         ValueMap { \"1\", \"2\" },\n         Values { \"localTime\", \"utcTime\" },\n         ModelCorrespondence {\n         \"CIM_PolicyTimePeriodCondition.TimePeriod\",\n         \"CIM_PolicyTimePeriodCondition.MonthOfYearMask\",\n         \"CIM_PolicyTimePeriodCondition.DayOfMonthMask\",\n         \"CIM_PolicyTimePeriodCondition.DayOfWeekMask\",\n         \"CIM_PolicyTimePeriodCondition.TimeOfDayMask\"}\n        ]\n    uint16 LocalOrUtcTime;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyRuleValidityPeriod\n// ==================================================================\n   [Association, Aggregation, Description (\n         \"The PolicyRuleValidityPeriod aggregation represents \"\n         \"scheduled activation and deactivation of a PolicyRule. \"\n         \"If a PolicyRule is associated with multiple policy time \"\n         \"periods via this association, then the Rule is active if \"\n         \"at least one of the time periods indicates that it is \"\n         \"active.  (In other words, the PolicyTimePeriodConditions \"\n         \"are ORed to determine whether the Rule is active.)  A Time\"\n         \"Period may be aggregated by multiple PolicyRules.  A Rule \"\n         \"that does not point to a PolicyTimePeriodCondition via this \"\n         \"association is, from the point of view of scheduling, \"\n         \"always active.  It may, however, be inactive for other \"\n         \"reasons.  For example, the Rule's Enabled property may \"\n         \"be set to \\\"disabled\\\" (value=2).\")\n   ]\nclass CIM_PolicyRuleValidityPeriod : CIM_PolicyComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This property contains the name of a PolicyRule that \"\n         \"contains one or more PolicyTimePeriodConditions.\")\n        ]\n    CIM_PolicyRule REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"This property contains the name of a \"\n         \"PolicyTimePeriodCondition defining the valid time periods \"\n         \"for one or more PolicyRules.\")\n        ]\n    CIM_PolicyTimePeriodCondition REF PartComponent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// VendorPolicyCondition\n// ==================================================================\n   [Description (\n         \"  A class that provides a general extension mechanism for \"\n         \"representing PolicyConditions that have not been modeled \"\n         \"with specific properties.  Instead, the two properties \"\n         \"Constraint and ConstraintEncoding are used to define the \"\n         \"content and format of the Condition, as explained below.\\n\\n\"\n         \"  \"\n         \"As its name suggests, VendorPolicyCondition is intended for \"\n         \"vendor-specific extensions to the Policy Core Information \"\n         \"Model.  Standardized extensions are not expected to use \"\n         \"this class.\")\n   ]\nclass CIM_VendorPolicyCondition : CIM_PolicyCondition\n{\n        [Octetstring, Description (\n         \"This property provides a general extension mechanism for \"\n         \"representing PolicyConditions that have not been \"\n         \"modeled with specific properties.  The format of the \"\n         \"octet strings in the array is left unspecified in \"\n         \"this definition.  It is determined by the OID value \"\n         \"stored in the property ConstraintEncoding.  Since \"\n         \"ConstraintEncoding is single-valued, all the values of \"\n         \"Constraint share the same format and semantics.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyCondition.ConstraintEncoding\"}\n        ]\n    string Constraint [];\n        [Description (\n         \"An OID encoded as a string, identifying the format \"\n         \"and semantics for this instance's Constraint property.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyCondition.Constraint\"}\n        ]\n    string ConstraintEncoding;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// PolicyAction\n// ==================================================================\n   [Abstract, Description (\n         \"A class representing a rule-specific or reusable policy \"\n         \"action to be performed if the PolicyConditions for a Policy\"\n         \"Rule evaluate to TRUE.  Since all operational details of a \"\n         \"PolicyAction are provided in subclasses of this object, \"\n         \"this class is abstract.\")",
      "raw": true
    },
    {
      "indent": 0,
      "text": "   ]\nclass CIM_PolicyAction : CIM_Policy\n{\n        [Key, MaxLen (256), Description (\n         \"  The name of the class or the subclass used in the \"\n         \"creation of the System object in whose scope this \"\n         \"PolicyAction is defined. \\n\\n\"\n         \"  \"\n         \"This property helps to identify the System object in \"\n         \"whose scope this instance of PolicyAction exists. \"\n         \"For a rule-specific PolicyAction, this is the System \"\n         \"in whose context the PolicyRule is defined.  For a \"\n         \"reusable PolicyAction, this is the instance of \"\n         \"PolicyRepository (which is a subclass of System) that \"\n         \"holds the Action. \\n\\n\"\n         \"  \"\n         \"Note that this property, and the analogous property \"\n         \"SystemName, do not represent propagated keys from an \"\n         \"instance of the class System.  Instead, they are \"\n         \"properties defined in the context of this class, which \"\n         \"repeat the values from the instance of System to which \"\n         \"this PolicyAction is related, either directly via the \"\n         \"PolicyActionInPolicyRepository aggregation or indirectly \"\n         \"via the PolicyActionInPolicyRule aggregation.\")\n        ]\n    string SystemCreationClassName;\n        [Key, MaxLen (256), Description (\n         \"  The name of the System object in whose scope this \"\n         \"PolicyAction is defined. \\n\\n\"\n         \"  \"\n         \"This property completes the identification of the System \"\n         \"object in whose scope this instance of PolicyAction \"\n         \"exists.  For a rule-specific PolicyAction, this is the \"\n         \"System in whose context the PolicyRule is defined.  For \"\n         \"a reusable PolicyAction, this is the instance of \"\n         \"PolicyRepository (which is a subclass of System) that \"\n         \"holds the Action.\")\n        ]\n    string SystemName;\n        [Key, MaxLen (256), Description (\n         \"For a rule-specific PolicyAction, the CreationClassName \"\n         \"of the PolicyRule object with which this Action is \"\n         \"associated.  For a reusable PolicyAction, a \"\n         \"special value, 'NO RULE', should be used to \"\n         \"indicate that this Action is reusable and not \"\n         \"associated with a single PolicyRule.\")\n        ]\n    string PolicyRuleCreationClassName;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        [Key, MaxLen (256), Description (\n         \"For a rule-specific PolicyAction, the name of \"\n         \"the PolicyRule object with which this Action is \"\n         \"associated.  For a reusable PolicyAction, a \"\n         \"special value, 'NO RULE', should be used to \"\n         \"indicate that this Action is reusable and not \"\n         \"associated with a single PolicyRule.\")\n        ]\n    string PolicyRuleName;\n        [Key, MaxLen (256), Description (\n           \"CreationClassName indicates the name of the class or the \"\n           \"subclass used in the creation of an instance.  When used \"\n           \"with the other key properties of this class, this property \"\n           \"allows all instances of this class and its subclasses to \"\n           \"be uniquely identified.\") ]\n    string CreationClassName;\n        [Key, MaxLen (256), Description (\n         \"A user-friendly name of this PolicyAction.\")\n        ]\n    string PolicyActionName;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyActionInPolicyRepository\n// ==================================================================\n   [Association, Description (\n         \"  A class representing the hosting of reusable \"\n         \"PolicyActions by a PolicyRepository.  A reusable Policy\"\n         \"Action is always related to a single PolicyRepository, \"\n         \"via this aggregation.\\n\\n\"\n         \"  \"\n         \"Note, that an instance of PolicyAction can be either \"\n         \"reusable or rule-specific.  When the Action is rule-\"\n         \"specific, it shall not be related to any \"\n         \"PolicyRepository via the PolicyActionInPolicyRepository \"\n         \"aggregation.\")\n   ]\nclass CIM_PolicyActionInPolicyRepository : CIM_PolicyInSystem\n{\n        [Override (\"Antecedent\"), Max(1), Description (\n         \"This property represents a PolicyRepository \"\n         \"hosting one or more PolicyActions.  A reusable \"\n         \"PolicyAction is always related to exactly one \"\n         \"PolicyRepository via the PolicyActionInPolicyRepository \"\n         \"aggregation.  The [0..1] cardinality for this property \"\n         \"covers the two types of PolicyActions:  0 for a \"\n         \"rule-specific PolicyAction, 1 for a reusable one.\")\n        ]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "    CIM_PolicyRepository REF Antecedent;\n        [Override (\"Dependent\"), Description (\n         \"This property holds the name of a PolicyAction\"\n         \"hosted in the PolicyRepository. \")\n        ]\n    CIM_PolicyAction REF Dependent;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n//    PolicyActionInPolicyRule\n// ==================================================================\n   [Association, Aggregation, Description (\n        \"  A PolicyRule aggregates zero or more instances of the \"\n        \"PolicyAction class, via the PolicyActionInPolicyRule \"\n        \"association.  A Rule that aggregates zero Actions is not \"\n        \"valid -- it may, however, be in the process of being entered \"\n        \"into a PolicyRepository or being defined for a System. \"\n        \"Alternately, the actions of the policy may be explicit in \"\n        \"the definition of the PolicyRule.  Note that a PolicyRule \"\n        \"should have no effect until it is valid.\\n\\n\"\n        \"  \"\n        \"The Actions associated with a PolicyRule may be given a \"\n        \"required order, a recommended order, or no order at all.  For \"\n        \"Actions represented as separate objects, the PolicyActionIn\"\n        \"PolicyRule aggregation can be used to express an order. \\n\\n\"\n        \"  \"\n        \"This aggregation does not indicate whether a specified \"\n        \"action order is required, recommended, or of no significance; \"\n        \"the property SequencedActions in the aggregating instance of \"\n        \"PolicyRule provides this indication.\")\n   ]\nclass CIM_PolicyActionInPolicyRule : CIM_PolicyComponent\n{\n        [Override (\"GroupComponent\"), Aggregate, Description (\n         \"This property represents the PolicyRule that \"\n         \"contains one or more PolicyActions.\")\n        ]\n    CIM_PolicyRule REF GroupComponent;\n        [Override (\"PartComponent\"), Description (\n         \"This property holds the name of a PolicyAction \"\n         \"contained by one or more PolicyRules.\")\n        ]\n    CIM_PolicyAction REF PartComponent;\n        [Description (\n         \"  This property provides an unsigned integer 'n' that\"\n         \"indicates the relative position of a PolicyAction in the \"\n         \"sequence of actions associated with a PolicyRule. \"\n         \"When 'n' is a positive integer, it indicates a place \"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"in the sequence of actions to be performed, with \"\n         \"smaller integers indicating earlier positions in the \"\n         \"sequence.  The special value '0' indicates 'don't care'. \"\n         \"If two or more PolicyActions have the same non-zero \"\n         \"sequence number, they may be performed in any order, but \"\n         \"they must all be performed at the appropriate place in the \"\n         \"overall action sequence. \\n\\n\"\n         \"  \"\n         \"A series of examples will make ordering of PolicyActions \"\n         \"clearer: \\n\"\n         \"   o If all actions have the same sequence number, \"\n         \"     regardless of whether it is '0' or non-zero, any \"\n         \"     order is acceptable.\\n \"\n         \"   o The values: \\n\"\n         \"         1:ACTION A \\n\"\n         \"         2:ACTION B \\n\"\n         \"         1:ACTION C \\n\"\n         \"         3:ACTION D \\n\"\n         \"     indicate two acceptable orders: A,C,B,D or C,A,B,D, \"\n         \"     since A and C can be performed in either order, but \"\n         \"     only at the '1' position. \\n\"\n         \"   o The values: \\n\"\n         \"         0:ACTION A \\n\"\n         \"         2:ACTION B \\n\"\n         \"         3:ACTION C \\n\"\n         \"         3:ACTION D \\n\"\n         \"     require that B,C, and D occur either as B,C,D or as \"\n         \"     B,D,C.  Action A may appear at any point relative to \"\n         \"     B, C, and D.  Thus the complete set of acceptable \"\n         \"     orders is:  A,B,C,D; B,A,C,D; B,C,A,D; B,C,D,A; \"\n         \"     A,B,D,C; B,A,D,C; B,D,A,C; B,D,C,A. \\n\\n\"\n         \"  \"\n         \"Note that the non-zero sequence numbers need not start \"\n         \"with '1', and they need not be consecutive.  All that \"\n         \"matters is their relative magnitude.\")\n        ]\n    uint16 ActionOrder;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ==================================================================\n// VendorPolicyAction\n// ==================================================================\n   [Description (\n         \"  A class that provides a general extension mechanism for \"\n         \"representing PolicyActions that have not been modeled \"\n         \"with specific properties.  Instead, the two properties \"\n         \"ActionData and ActionEncoding are used to define the \"\n         \"content and format of the Action, as explained below.\\n\\n\"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "         \"  \"\n         \"As its name suggests, VendorPolicyAction is intended for \"\n         \"vendor-specific extensions to the Policy Core Information \"\n         \"Model.  Standardized extensions are not expected to use \"\n         \"this class.\")  ]\nclass CIM_VendorPolicyAction : CIM_PolicyAction\n{\n        [Octetstring, Description (\n         \"This property provides a general extension mechanism for \"\n         \"representing PolicyActions that have not been \"\n         \"modeled with specific properties.  The format of the \"\n         \"octet strings in the array is left unspecified in \"\n         \"this definition.  It is determined by the OID value \"\n         \"stored in the property ActionEncoding.  Since \"\n         \"ActionEncoding is single-valued, all the values of \"\n         \"ActionData share the same format and semantics.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyAction.ActionEncoding\"}\n        ]\n    string ActionData [];\n        [Description (\n         \"An OID encoded as a string, identifying the format \"\n         \"and semantics for this instance's ActionData property.\"),\n         ModelCorrespondence {\n            \"CIM_VendorPolicyAction.ActionData\"}\n        ]\n    string ActionEncoding;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "// ===================================================================\n// end of file\n// ===================================================================",
      "raw": true
    },
    {
      "indent": 0,
      "text": "15. Full Copyright Statement",
      "section_title": true,
      "ja": "15.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}