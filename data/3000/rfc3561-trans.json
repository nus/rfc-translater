{
  "title": {
    "text": "RFC 3561 - Ad hoc On-Demand Distance Vector (AODV) Routing",
    "ja": "RFC 3561 - アドホックオンデマンド距離ベクトル（AODV）ルーティング"
  },
  "number": 3561,
  "created_at": "2019-10-19 16:38:27.104293+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         C. Perkins\nRequest for Comments: 3561                         Nokia Research Center\nCategory: Experimental                                  E. Belding-Royer\n                                 University of California, Santa Barbara\n                                                                  S. Das\n                                                University of Cincinnati\n                                                               July 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Ad hoc On-Demand Distance Vector (AODV) Routing",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Ad hoc On-Demand Distance Vector (AODV) routing protocol is intended for use by mobile nodes in an ad hoc network. It offers quick adaptation to dynamic link conditions, low processing and memory overhead, low network utilization, and determines unicast routes to destinations within the ad hoc network. It uses destination sequence numbers to ensure loop freedom at all times (even in the face of anomalous delivery of routing control messages), avoiding problems (such as \"counting to infinity\") associated with classical distance vector protocols.",
      "ja": "アドホックオンデマンド距離ベクトル（AODV）ルーティングプロトコルは、アドホックネットワーク内のモバイルノードによる使用のために意図されています。これは、ダイナミックリンク条件、低処理およびメモリのオーバーヘッド、低ネットワーク使用率への迅速な適応を提供し、アドホックネットワーク内の宛先へのユニキャストルートを決定します。これは、古典的な距離ベクトルプロトコルに関連付けられている（例えば、「無限にカウント」のような）問題を回避すること、（たとえ制御メッセージをルーティングする異常送達の面で）常にループの自由度を確保するために、宛先シーケンス番号を使用します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction ...............................................  2\n2.  Overview  ..................................................  3\n3.  AODV Terminology ...........................................  4\n4.  Applicability Statement ....................................  6\n5.  Message Formats ............................................  7\n    5.1. Route Request (RREQ) Message Format ...................  7\n    5.2. Route Reply (RREP) Message Format .....................  8\n    5.3. Route Error (RERR) Message Format ..................... 10\n    5.4. Route Reply Acknowledgment (RREP-ACK) Message Format .. 11\n6.  AODV Operation ............................................. 11\n    6.1. Maintaining Sequence Numbers .......................... 11\n    6.2. Route Table Entries and Precursor Lists ............... 13",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    6.3. Generating Route Requests ............................. 14\n    6.4. Controlling Dissemination of Route Request Messages ... 15\n    6.5. Processing and Forwarding Route Requests .............. 16\n    6.6. Generating Route Replies .............................. 18\n         6.6.1. Route Reply Generation by the Destination ...... 18\n         6.6.2. Route Reply Generation by an Intermediate\n                Node ........................................... 19\n         6.6.3. Generating Gratuitous RREPs .................... 19\n    6.7. Receiving and Forwarding Route Replies ................ 20\n    6.8. Operation over Unidirectional Links ................... 21\n    6.9. Hello Messages ........................................ 22\n    6.10 Maintaining Local Connectivity ........................ 23\n    6.11 Route Error (RERR) Messages, Route Expiry and Route\n         Deletion .............................................. 24\n    6.12 Local Repair .......................................... 26\n    6.13 Actions After Reboot  ................................. 27\n    6.14 Interfaces ............................................ 28\n7.  AODV and Aggregated Networks ............................... 28\n8.  Using AODV with Other Networks ............................. 29\n9.  Extensions ................................................. 30\n    9.1. Hello Interval Extension Format ....................... 30\n10. Configuration Parameters ................................... 31\n11. Security Considerations .................................... 33\n12. IANA Considerations ........................................ 34\n13. IPv6 Considerations ........................................ 34\n14. Acknowledgments ............................................ 34\n15. Normative References ....................................... 35\n16. Informative References ..................................... 35\n17. Authors' Addresses ......................................... 36\n18. Full Copyright Statement ................................... 37",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Ad hoc On-Demand Distance Vector (AODV) algorithm enables dynamic, self-starting, multihop routing between participating mobile nodes wishing to establish and maintain an ad hoc network. AODV allows mobile nodes to obtain routes quickly for new destinations, and does not require nodes to maintain routes to destinations that are not in active communication. AODV allows mobile nodes to respond to link breakages and changes in network topology in a timely manner. The operation of AODV is loop-free, and by avoiding the Bellman-Ford \"counting to infinity\" problem offers quick convergence when the ad hoc network topology changes (typically, when a node moves in the network). When links break, AODV causes the affected set of nodes to be notified so that they are able to invalidate the routes using the lost link.",
      "ja": "アドホックオンデマンド距離ベクトル（AODV）アルゴリズムは、アドホックネットワークを確立し、維持することを望むモバイルノードが参加するとの自己始動、マルチホップルーティングを動的に有効になります。 AODVは、モバイルノードが新たな目的地のためにすぐにルートを取得することができ、かつアクティブな通信ではない宛先へのルートを維持するために、ノードを必要としません。 AODVは、モバイルノードがタイムリーにネットワークトポロジの破損や変更をリンクに応答することができます。 AODVの動作がループフリーで、「無限カウント」ベルマン・フォードを回避することによって問題が迅速に収束するとき、アドホックネットワークのトポロジの変更（通常は、ノードがネットワークに移動するとき）を提供しています。リンクが壊れたとき、彼らは失われたリンクを使用してルートを無効にすることができるように、AODVはノードの影響を受けたセットが通知されます。"
    },
    {
      "indent": 3,
      "text": "One distinguishing feature of AODV is its use of a destination sequence number for each route entry. The destination sequence number is created by the destination to be included along with any route information it sends to requesting nodes. Using destination sequence numbers ensures loop freedom and is simple to program. Given the choice between two routes to a destination, a requesting node is required to select the one with the greatest sequence number.",
      "ja": "AODVの一の特徴は、各ルートエントリの宛先シーケンス番号の使用です。宛先シーケンス番号は、それが要求元のノードに送信する任意の経路情報と一緒に含まれることが先によって作成されます。先のシーケンス番号を使用すると、ループの自由度を確保し、プログラムに簡単です。宛先への2つの経路間の選択を与え、要求ノードが最大シーケンス番号を有するものを選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2.概要"
    },
    {
      "indent": 3,
      "text": "Route Requests (RREQs), Route Replies (RREPs), and Route Errors (RERRs) are the message types defined by AODV. These message types are received via UDP, and normal IP header processing applies. So, for instance, the requesting node is expected to use its IP address as the Originator IP address for the messages. For broadcast messages, the IP limited broadcast address (255.255.255.255) is used. This means that such messages are not blindly forwarded. However, AODV operation does require certain messages (e.g., RREQ) to be disseminated widely, perhaps throughout the ad hoc network. The range of dissemination of such RREQs is indicated by the TTL in the IP header. Fragmentation is typically not required.",
      "ja": "ルート要求（のRREQ）、ルート（たRREP）を返信し、経路エラー（RERRs）はAODVによって定義されたメッセージ・タイプです。これらのメッセージタイプは、UDPを介して受信され、そして通常のIPヘッダ処理が適用されます。だから、例えば、要求ノードは、メッセージのための発信IPアドレスとして、そのIPアドレスを使用することが期待されています。ブロードキャストメッセージの場合、IP制限されたブロードキャストアドレス（255.255.255.255）が使用されています。これは、このようなメッセージが盲目的に転送されないことを意味します。しかしながら、AODV動作が特定のメッセージ（例えば、RREQ）おそらくアドホックネットワーク全体に、広く普及されることを必要とします。このようなのRREQの普及の範囲は、IPヘッダーのTTLで示されています。断片化は一般的に必要とされていません。"
    },
    {
      "indent": 3,
      "text": "As long as the endpoints of a communication connection have valid routes to each other, AODV does not play any role. When a route to a new destination is needed, the node broadcasts a RREQ to find a route to the destination. A route can be determined when the RREQ reaches either the destination itself, or an intermediate node with a 'fresh enough' route to the destination. A 'fresh enough' route is a valid route entry for the destination whose associated sequence number is at least as great as that contained in the RREQ. The route is made available by unicasting a RREP back to the origination of the RREQ. Each node receiving the request caches a route back to the originator of the request, so that the RREP can be unicast from the destination along a path to that originator, or likewise from any intermediate node that is able to satisfy the request.",
      "ja": "限り通信接続のエンドポイントが相互に有効なルートを持っているとして、AODVはどんな役割を果たしていません。新しい目的地へのルートが必要な場合は、ノードが目的地までのルートを見つけるために、RREQをブロードキャストします。 RREQが宛先自体、又は先に「新鮮十分」経路を有する中間ノードのいずれかに達したときに経路を決定することができます。 「新鮮な十分な」ルートは関連するシーケンス番号がRREQに含まれるものと少なくとも同じである宛先に対する有効なルートエントリです。ルートバックRREQの発信にRREPをユニキャストすることによって利用可能にされます。 RREPは、その発信元に、または同様の要求を満たすことができる任意の中間ノードからの経路に沿って宛先からのユニキャストすることができるように、要求を受信する各ノードは、バック要求の発信元への経路をキャッシュします。"
    },
    {
      "indent": 3,
      "text": "Nodes monitor the link status of next hops in active routes. When a link break in an active route is detected, a RERR message is used to notify other nodes that the loss of that link has occurred. The RERR message indicates those destinations (possibly subnets) which are no longer reachable by way of the broken link. In order to enable this reporting mechanism, each node keeps a \"precursor list\", containing the IP address for each its neighbors that are likely to use it as a next hop towards each destination. The information in the precursor lists is most easily acquired during the processing for generation of a RREP message, which by definition has to be sent to a node in a precursor list (see section 6.6). If the RREP has a nonzero prefix",
      "ja": "ノードはアクティブなルートの次のホップのリンク状態を監視します。アクティブルートにリンク断が検出された場合、RERRメッセージは、そのリンクの損失が発生している他のノードに通知するために使用されます。 RERRメッセージはもはや壊れたリンクを介して到達可能であるそれらの宛先（おそらくサブネット）を示しています。この報告メカニズムを有効にするために、各ノードは、それぞれの宛先へのネクストホップとしてそれを使用する可能性があり、それぞれそのネイバーのIPアドレスを含む、「前駆物質リスト」を保持します。前駆リストの情報は、最も簡単に定義することにより、前駆体リスト内のノードに送信されなければならないRREPメッセージ（セクション6.6を参照）を生成するための処理中に取得されます。 RREPはゼロ以外の接頭辞を持っている場合"
    },
    {
      "indent": 3,
      "text": "length, then the originator of the RREQ which solicited the RREP information is included among the precursors for the subnet route (not specifically for the particular destination).",
      "ja": "長さは、RREP情報を要請RREQの発信元がサブネット経路の前駆体の中に含まれている（ない具体特定の宛先用）。"
    },
    {
      "indent": 3,
      "text": "A RREQ may also be received for a multicast IP address. In this document, full processing for such messages is not specified. For example, the originator of such a RREQ for a multicast IP address may have to follow special rules. However, it is important to enable correct multicast operation by intermediate nodes that are not enabled as originating or destination nodes for IP multicast addresses, and likewise are not equipped for any special multicast protocol processing. For such multicast-unaware nodes, processing for a multicast IP address as a destination IP address MUST be carried out in the same way as for any other destination IP address.",
      "ja": "RREQは、マルチキャストIPアドレスを受信することができます。この文書では、このようなメッセージの完全な処理が指定されていません。たとえば、マルチキャストIPアドレスのため、このようなRREQの創始者は、特別な規則に従わなければならないかもしれません。しかし、IPマルチキャストアドレスの発信元または宛先ノードとして有効になっていない、と同様に、特別なマルチキャストプロトコル処理のために装備されていない中間ノードによって正しいマルチキャスト動作を可能にすることが重要です。そのようなマルチキャスト非対応ノードの場合、宛先IPアドレスとしてマルチキャストIPアドレスに対する処理は、他の送信先IPアドレスと同じ方法で行わなければなりません。"
    },
    {
      "indent": 3,
      "text": "AODV is a routing protocol, and it deals with route table management. Route table information must be kept even for short-lived routes, such as are created to temporarily store reverse paths towards nodes originating RREQs. AODV uses the following fields with each route table entry:",
      "ja": "AODVはルーティングプロトコルであり、それは、ルートテーブルの管理を扱います。ルートテーブル情報であっても、このような一時的のRREQを発信ノードに向けて逆方向のパスを格納するために作成されているような短命の経路のために保持しなければなりません。 AODVは、各ルートテーブルエントリで、次のフィールドを使用しています："
    },
    {
      "indent": 3,
      "text": "- Destination IP Address - Destination Sequence Number - Valid Destination Sequence Number flag - Other state and routing flags (e.g., valid, invalid, repairable, being repaired) - Network Interface - Hop Count (number of hops needed to reach destination) - Next Hop - List of Precursors (described in Section 6.2) - Lifetime (expiration or deletion time of the route)",
      "ja": " - 宛先IPアドレス - デスティネーションシーケンス番号 - 有効な宛先シーケンス番号フラグ - その他の状態とルーティングのフラグ（例えば、有効、無効、修理、修理中） - ネットワークインタフェース - ホップカウント（宛先に到達するために必要なホップ数） - 次ホップ - （セクション6.2を参照）の前駆体のリスト - 寿命（経路の満了または削除時間）"
    },
    {
      "indent": 3,
      "text": "Managing the sequence number is crucial to avoiding routing loops, even when links break and a node is no longer reachable to supply its own information about its sequence number. A destination becomes unreachable when a link breaks or is deactivated. When these conditions occur, the route is invalidated by operations involving the sequence number and marking the route table entry state as invalid. See section 6.1 for details.",
      "ja": "リンクが壊れていないと、ノードがもはやそのシーケンス番号に関する独自の情報を提供して到達可能である場合でも、シーケンス番号を管理することは、ルーティングループを避けるために重要です。リンクが壊れたり非アクティブ化されたときに、宛先が到達不能になりました。これらの条件が発生した場合、ルートは、シーケンス番号を含む操作によって無効、無効としてルートテーブルエントリの状態をマーキングされています。詳細については、6.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. AODV Terminology",
      "section_title": true,
      "ja": "3. AODV用語"
    },
    {
      "indent": 3,
      "text": "This protocol specification uses conventional meanings [1] for capitalized words such as MUST, SHOULD, etc., to indicate requirement levels for various protocol features. This section defines other terminology used with AODV that is not already defined in [3].",
      "ja": "このプロトコル仕様は、様々なプロトコル機能に対する要求レベルを示すために、等MUST、SHOULD、として大文字の単語を[1]従来の意味を使用します。このセクションでは、すでに[3]で定義されていないAODVで使用される他の用語を定義します。"
    },
    {
      "indent": 6,
      "text": "active route",
      "ja": "アクティブルート"
    },
    {
      "indent": 9,
      "text": "A route towards a destination that has a routing table entry that is marked as valid. Only active routes can be used to forward data packets.",
      "ja": "有効としてマークされているルーティングテーブルエントリを持って目的地へのルート。唯一のアクティブなルートは、データパケットを転送するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "broadcast",
      "ja": "放送"
    },
    {
      "indent": 9,
      "text": "Broadcasting means transmitting to the IP Limited Broadcast address, 255.255.255.255. A broadcast packet may not be blindly forwarded, but broadcasting is useful to enable dissemination of AODV messages throughout the ad hoc network.",
      "ja": "放送は、IPリミテッドブロードキャストアドレス、255.255.255.255への送信を意味します。ブロードキャストパケットは盲目的に転送されないかもしれませんが、放送は、アドホックネットワーク全体AODVメッセージの普及を可能にするのに便利です。"
    },
    {
      "indent": 6,
      "text": "destination",
      "ja": "先"
    },
    {
      "indent": 9,
      "text": "An IP address to which data packets are to be transmitted. Same as \"destination node\". A node knows it is the destination node for a typical data packet when its address appears in the appropriate field of the IP header. Routes for destination nodes are supplied by action of the AODV protocol, which carries the IP address of the desired destination node in route discovery messages.",
      "ja": "データパケットが送信される先のIPアドレス。 「宛先ノード」と同じです。ノードは、そのアドレスはIPヘッダの適切なフィールドに表示されたとき、それは典型的なデータパケットの宛先ノードであることを知っています。宛先ノードのルートは、ルート発見メッセージに所望の宛先ノードのIPアドレスを運ぶAODVプロトコルの作用によって供給されます。"
    },
    {
      "indent": 6,
      "text": "forwarding node",
      "ja": "転送ノード"
    },
    {
      "indent": 9,
      "text": "A node that agrees to forward packets destined for another node, by retransmitting them to a next hop that is closer to the unicast destination along a path that has been set up using routing control messages.",
      "ja": "ルーティング制御メッセージを使用して設定された経路に沿ってユニキャスト宛先に近い次のホップにそれらを再送信することによって、他のノード宛てのパケットを転送することに同意するノード。"
    },
    {
      "indent": 6,
      "text": "forward route",
      "ja": "往路"
    },
    {
      "indent": 9,
      "text": "A route set up to send data packets from a node originating a Route Discovery operation towards its desired destination.",
      "ja": "ルートは、その所望の目的地に向かって経路探索動作を発信ノードからデータパケットを送信するように設定しました。"
    },
    {
      "indent": 6,
      "text": "invalid route",
      "ja": "無効なルート"
    },
    {
      "indent": 9,
      "text": "A route that has expired, denoted by a state of invalid in the routing table entry. An invalid route is used to store previously valid route information for an extended period of time. An invalid route cannot be used to forward data packets, but it can provide information useful for route repairs, and also for future RREQ messages.",
      "ja": "ルーティング・テーブル・エントリ内の無効の状態で示される有効期限が切れているルート、。無効なルートは長期間以前に有効なルート情報を格納するために使用されます。無効なルートは、データパケットを転送するために使用することはできませんが、それはルートの修理のために有用な情報を提供し、また将来のRREQメッセージのことができます。"
    },
    {
      "indent": 6,
      "text": "originating node",
      "ja": "発信元ノード"
    },
    {
      "indent": 9,
      "text": "A node that initiates an AODV route discovery message to be processed and possibly retransmitted by other nodes in the ad hoc network. For instance, the node initiating a Route Discovery process and broadcasting the RREQ message is called the originating node of the RREQ message.",
      "ja": "AODVルート発見メッセージを開始ノードが処理され、おそらくはアドホックネットワーク内の他のノードによって再送信されます。例えば、経路探索プロセスを開始し、RREQメッセージをブロードキャストするノードは、RREQメッセージの発信元ノードと呼ばれます。"
    },
    {
      "indent": 6,
      "text": "reverse route",
      "ja": "逆のルート"
    },
    {
      "indent": 9,
      "text": "A route set up to forward a reply (RREP) packet back to the originator from the destination or from an intermediate node having a route to the destination.",
      "ja": "ルートバック先から、または目的地までの経路を有する中間ノードから発信に対する応答（RREP）パケットを転送するように設定します。"
    },
    {
      "indent": 6,
      "text": "sequence number",
      "ja": "シーケンス番号"
    },
    {
      "indent": 9,
      "text": "A monotonically increasing number maintained by each originating node. In AODV routing protocol messages, it is used by other nodes to determine the freshness of the information contained from the originating node.",
      "ja": "各発信ノードによって維持される単調に増加する数。 AODVルーティングプロトコルのメッセージには、発信元ノードから含まれている情報の鮮度を決定するために、他のノードによって使用されます。"
    },
    {
      "indent": 6,
      "text": "valid route",
      "ja": "有効なルート"
    },
    {
      "indent": 9,
      "text": "See active route.",
      "ja": "アクティブなルートを参照してください。"
    },
    {
      "indent": 0,
      "text": "4. Applicability Statement",
      "section_title": true,
      "ja": "4.適用性に関する声明"
    },
    {
      "indent": 3,
      "text": "The AODV routing protocol is designed for mobile ad hoc networks with populations of tens to thousands of mobile nodes. AODV can handle low, moderate, and relatively high mobility rates, as well as a variety of data traffic levels. AODV is designed for use in networks where the nodes can all trust each other, either by use of preconfigured keys, or because it is known that there are no malicious intruder nodes. AODV has been designed to reduce the dissemination of control traffic and eliminate overhead on data traffic, in order to improve scalability and performance.",
      "ja": "AODVルーティングプロトコルは、移動ノードの数千に数十の集団とモバイルアドホックネットワークのために設計されています。 AODVは、低、中程度、および比較的高い移動度率だけでなく、データトラフィックレベルの多様性を扱うことができます。 AODVは、ノードは、すべてのいずれかの事前設定されたキーを使用することによって、お互いを信頼することができ、または何の悪意の侵入者のノードが存在しないことが知られているので、ネットワークで使用するために設計されています。 AODVは、制御トラフィックの普及を削減し、スケーラビリティとパフォーマンスを向上させるためには、データトラフィックのオーバーヘッドを排除するために設計されています。"
    },
    {
      "indent": 0,
      "text": "5. Message Formats",
      "section_title": true,
      "ja": "5.メッセージフォーマット"
    },
    {
      "indent": 0,
      "text": "5.1. Route Request (RREQ) Message Format",
      "section_title": true,
      "ja": "5.1. ルート要求（RREQ）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type |J|R|G|D|U| Reserved | Hop Count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | RREQ ID | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination IP Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Originator IP Address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Originator Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ| J | R | G | D | U |予約|ホップカウント| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | RREQのID | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |宛先IPアドレス| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |宛先シーケンス番号| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |発信元IPアドレス| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |発信元シーケンス番号| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "The format of the Route Request message is illustrated above, and contains the following fields:",
      "ja": "経路要求メッセージのフォーマットは、上記に例示し、以下のフィールドが含まれます。"
    },
    {
      "indent": 6,
      "text": "Type 1",
      "ja": "タイプ1"
    },
    {
      "indent": 6,
      "text": "J Join flag; reserved for multicast.",
      "ja": "Jは、旗に参加します。マルチキャストのために予約。"
    },
    {
      "indent": 6,
      "text": "R Repair flag; reserved for multicast.",
      "ja": "R修復フラグ。マルチキャストのために予約。"
    },
    {
      "indent": 6,
      "text": "G Gratuitous RREP flag; indicates whether a gratuitous RREP should be unicast to the node specified in the Destination IP Address field (see sections 6.3, 6.6.3).",
      "ja": "G無償RREPフラグ。 （セクション6.3、6.6.3参照）無償RREPは、宛先IPアドレスフィールドで指定されたノードにユニキャストされなければならないかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "D Destination only flag; indicates only the destination may respond to this RREQ (see section 6.5).",
      "ja": "D宛先のみフラグ。このRREQに応答することができるだけ先を示す（セクション6.5を参照してください）。"
    },
    {
      "indent": 6,
      "text": "U Unknown sequence number; indicates the destination sequence number is unknown (see section 6.3).",
      "ja": "U不明なシーケンス番号。 （セクション6.3を参照）、宛先シーケンス番号が不明であることを示します。"
    },
    {
      "indent": 6,
      "text": "Reserved Sent as 0; ignored on reception.",
      "ja": "0として送ら予約済み。レセプションで無視。"
    },
    {
      "indent": 6,
      "text": "Hop Count The number of hops from the Originator IP Address to the node handling the request.",
      "ja": "ホップは、要求を処理ノードに発信IPアドレスからのホップ数をカウントします。"
    },
    {
      "indent": 6,
      "text": "RREQ ID A sequence number uniquely identifying the particular RREQ when taken in conjunction with the originating node's IP address.",
      "ja": "発信元ノードのIPアドレスと併せてシーケンス番号が一意に特定RREQを特定のRREQ ID。"
    },
    {
      "indent": 6,
      "text": "Destination IP Address The IP address of the destination for which a route is desired.",
      "ja": "送信先IPは、ルートが望まれている送信先のIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Destination Sequence Number The latest sequence number received in the past by the originator for any route towards the destination.",
      "ja": "宛先シーケンス番号先へのすべてのルートの発信者によって過去に受信​​した最新のシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "Originator IP Address The IP address of the node which originated the Route Request.",
      "ja": "発信元IPは、ルート要求を発信したノードのIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Originator Sequence Number The current sequence number to be used in the route entry pointing towards the originator of the route request.",
      "ja": "発信シーケンス番号現在のシーケンス番号は、ルート要求の発信元に向いルートエントリに使用されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Route Reply (RREP) Message Format",
      "section_title": true,
      "ja": "5.2. 経路応答（RREP）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type |R|A| Reserved |Prefix Sz| Hop Count | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination IP address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Destination Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Originator IP address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Lifetime | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ| R | A |予約|プレフィックスSzを|ホップカウント| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |宛先IPアドレス| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |宛先シーケンス番号| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |発信元IPアドレス| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |生涯| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "The format of the Route Reply message is illustrated above, and contains the following fields:",
      "ja": "経路応答メッセージのフォーマットは、上記に例示し、以下のフィールドが含まれます。"
    },
    {
      "indent": 6,
      "text": "Type 2",
      "ja": "タイプ2"
    },
    {
      "indent": 6,
      "text": "R Repair flag; used for multicast.",
      "ja": "R修復フラグ。マルチキャストに使用。"
    },
    {
      "indent": 6,
      "text": "A Acknowledgment required; see sections 5.4 and 6.7.",
      "ja": "謝辞が必要。セクション5.4と6.7を参照してください。"
    },
    {
      "indent": 6,
      "text": "Reserved Sent as 0; ignored on reception.",
      "ja": "0として送ら予約済み。レセプションで無視。"
    },
    {
      "indent": 6,
      "text": "Prefix Size If nonzero, the 5-bit Prefix Size specifies that the indicated next hop may be used for any nodes with the same routing prefix (as defined by the Prefix Size) as the requested destination.",
      "ja": "プレフィックスサイズゼロ以外の場合は、5ビットのプレフィックスサイズ（プレフィックスサイズによって定義されるように）示され、次のホップが要求された宛先と同じ経路プレフィックスを有する任意のノードのために使用することができることを指定します。"
    },
    {
      "indent": 6,
      "text": "Hop Count The number of hops from the Originator IP Address to the Destination IP Address. For multicast route requests this indicates the number of hops to the multicast tree member sending the RREP.",
      "ja": "ホップは、宛先IPアドレスに発信IPアドレスからのホップ数をカウントします。マルチキャストルート要求については、これはRREPを送信するマルチキャストツリーのメンバーへのホップ数を示します。"
    },
    {
      "indent": 6,
      "text": "Destination IP Address The IP address of the destination for which a route is supplied.",
      "ja": "送信先IPルートが供給されるため、宛先のIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Destination Sequence Number The destination sequence number associated to the route.",
      "ja": "宛先シーケンス番号ルートに関連付けられた宛先シーケンス番号。"
    },
    {
      "indent": 6,
      "text": "Originator IP Address The IP address of the node which originated the RREQ for which the route is supplied.",
      "ja": "発信元IPルートが供給されるためのRREQを発信したノードのIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Lifetime The time in milliseconds for which nodes receiving the RREP consider the route to be valid.",
      "ja": "生涯RREPを受信ノードいるミリ秒単位の時間が有効であるためにルートを考えます。"
    },
    {
      "indent": 3,
      "text": "Note that the Prefix Size allows a subnet router to supply a route for every host in the subnet defined by the routing prefix, which is determined by the IP address of the subnet router and the Prefix Size. In order to make use of this feature, the subnet router has to guarantee reachability to all the hosts sharing the indicated subnet prefix. See section 7 for details. When the prefix size is nonzero, any routing information (and precursor data) MUST be kept with respect to the subnet route, not the individual destination IP address on that subnet.",
      "ja": "プレフィックスサイズがサブネット・ルータは、サブネット・ルータとプレフィックスサイズのIPアドレスによって決定されたルーティングプレフィックス、によって定義されたサブネット内のすべてのホストのための経路を提供することを可能にすることに留意されたいです。この機能を利用するために、サブネットルータは、指定されたサブネットプレフィックスを共有するすべてのホストに到達可能性を保証しなければなりません。詳細については、セクション7を参照してください。プレフィックスサイズがゼロである場合、任意のルーティング情報（および前駆データ）サブネット経路ではなく、そのサブネット上の個々の宛先IPアドレスに対して維持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The 'A' bit is used when the link over which the RREP message is sent may be unreliable or unidirectional. When the RREP message contains the 'A' bit set, the receiver of the RREP is expected to return a RREP-ACK message. See section 6.8.",
      "ja": "RREPメッセージが送信されるリンクが信頼できないまたは単方向とすることができる場合「」ビットが使用されます。 RREPメッセージは「」ビットセットを含む場合、RREPの受信機は、RREP-ACKメッセージを返すことが期待されます。セクション6.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. Route Error (RERR) Message Format",
      "section_title": true,
      "ja": "5.3. 経路エラー（RERR）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type |N| Reserved | DestCount | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unreachable Destination IP Address (1) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unreachable Destination Sequence Number (1) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-| | Additional Unreachable Destination IP Addresses (if needed) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |Additional Unreachable Destination Sequence Numbers (if needed)| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ| N |予約| DestCount | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |到達不能宛先IPアドレス（1）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |宛先到達不能シーケンス番号（1）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  | |追加の到達不能宛先IPアドレス（必要な場合）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |追加宛先到達不能のシーケンス番号（必要な場合）| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "The format of the Route Error message is illustrated above, and contains the following fields:",
      "ja": "経路エラーメッセージのフォーマットは、上記に例示し、以下のフィールドが含まれます。"
    },
    {
      "indent": 6,
      "text": "Type 3",
      "ja": "タイプ3"
    },
    {
      "indent": 6,
      "text": "N No delete flag; set when a node has performed a local repair of a link, and upstream nodes should not delete the route.",
      "ja": "Nなしフラグを削除しません。ノードはリンクのローカル修復を行ったときに設定され、上流のノードは、ルートを削除してはなりません。"
    },
    {
      "indent": 6,
      "text": "Reserved Sent as 0; ignored on reception.",
      "ja": "0として送ら予約済み。レセプションで無視。"
    },
    {
      "indent": 6,
      "text": "DestCount The number of unreachable destinations included in the message; MUST be at least 1.",
      "ja": "到達不能な目的地の数がメッセージに含まDestCount。少なくとも1でなければなりません。"
    },
    {
      "indent": 6,
      "text": "Unreachable Destination IP Address The IP address of the destination that has become unreachable due to a link break.",
      "ja": "宛先到達不能IPによるリンクブレークに到達不能になった送信先のIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Unreachable Destination Sequence Number The sequence number in the route table entry for the destination listed in the previous Unreachable Destination IP Address field.",
      "ja": "宛先到達不能シーケンス番号以前の到達不能宛先IPアドレスフィールドにリストされた目的地のためのルートテーブルエントリ内のシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "The RERR message is sent whenever a link break causes one or more destinations to become unreachable from some of the node's neighbors. See section 6.2 for information about how to maintain the appropriate records for this determination, and section 6.11 for specification about how to create the list of destinations.",
      "ja": "リンクブレークが1つの以上の宛先ノードの隣人の一部から到達不能になったために発生したときにRERRメッセージが送信されます。この決意のための適切な記録を維持する方法については、セクション6.2、および宛先のリストを作成する方法についての仕様のセクション6.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Route Reply Acknowledgment (RREP-ACK) Message Format",
      "section_title": true,
      "ja": "5.4. ルート応答（RREP-ACK）メッセージフォーマットを返信"
    },
    {
      "indent": 3,
      "text": "The Route Reply Acknowledgment (RREP-ACK) message MUST be sent in response to a RREP message with the 'A' bit set (see section 5.2). This is typically done when there is danger of unidirectional links preventing the completion of a Route Discovery cycle (see section 6.8).",
      "ja": "ルート応答（RREP-ACK）メッセージ（セクション5.2を参照） 'ビットがセットされたRREPメッセージに応答して送信されなければならない返信。経路探索サイクルの完了を防止単方向リンクの危険性がある場合には、一般的に行われている（6.8節を参照してください）。"
    },
    {
      "indent": 3,
      "text": " 0 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ|予約| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 6,
      "text": "Type 4",
      "ja": "タイプ4"
    },
    {
      "indent": 6,
      "text": "Reserved Sent as 0; ignored on reception.",
      "ja": "0として送ら予約済み。レセプションで無視。"
    },
    {
      "indent": 0,
      "text": "6. AODV Operation",
      "section_title": true,
      "ja": "6. AODV操作"
    },
    {
      "indent": 3,
      "text": "This section describes the scenarios under which nodes generate Route Request (RREQ), Route Reply (RREP) and Route Error (RERR) messages for unicast communication towards a destination, and how the message data are handled. In order to process the messages correctly, certain state information has to be maintained in the route table entries for the destinations of interest.",
      "ja": "このセクションでは、ノードは宛先に向かってユニキャスト通信のためのルート要求（RREQ）、ルート応答（RREP）と経路エラー（RERR）メッセージを生成し、その下のシナリオを説明し、そしてメッセージデータがどのように扱われます。メッセージを正しく処理するために、特定の状態情報は、関心のある目的地のためのルートテーブルエントリに維持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "All AODV messages are sent to port 654 using UDP.",
      "ja": "すべてのAODVメッセージはUDPを使用してポート654に送信されます。"
    },
    {
      "indent": 0,
      "text": "6.1. Maintaining Sequence Numbers",
      "section_title": true,
      "ja": "6.1. シーケンス番号を維持します"
    },
    {
      "indent": 3,
      "text": "Every route table entry at every node MUST include the latest information available about the sequence number for the IP address of the destination node for which the route table entry is maintained. This sequence number is called the \"destination sequence number\". It is updated whenever a node receives new (i.e., not stale) information about the sequence number from RREQ, RREP, or RERR messages that may be received related to that destination. AODV depends on each node in the network to own and maintain its destination sequence number to guarantee the loop-freedom of all routes towards that node. A destination node increments its own sequence number in two circumstances:",
      "ja": "すべてのノードのすべてのルートテーブルエントリは、ルートテーブルエントリが維持されている宛先ノードのIPアドレスのシーケンス番号に関する最新の情報を含まなければなりません。このシーケンス番号は、「宛先シーケンス番号」と呼ばれています。ノードは、その宛先に関連する受信されても​​よいRREQ、RREP、又はRERRメッセージのシーケンス番号についての新しい（すなわち、古くなっていない）情報を受信するたびに、それが更新されます。 AODVは、そのノードに向かうすべての経路のループの自由を保証するために、その宛先シーケンス番号を所有し、維持するために、ネットワーク内の各ノードに依存します。宛先ノードは、2つの状況で、独自のシーケンス番号をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "- Immediately before a node originates a route discovery, it MUST increment its own sequence number. This prevents conflicts with previously established reverse routes towards the originator of a RREQ.",
      "ja": " - ノードがルート発見を発信する直前に、それは自身のシーケンス番号を増加しなければなりません。これは、RREQの創始者に向けた、以前に確立逆のルートとの競合を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "- Immediately before a destination node originates a RREP in response to a RREQ, it MUST update its own sequence number to the maximum of its current sequence number and the destination sequence number in the RREQ packet.",
      "ja": " - 宛先ノードがRREQに応答してRREPを発信する直前に、その現在のシーケンス番号と、RREQパケットの宛先シーケンス番号の最大値に独自のシーケンス番号を更新しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the destination increments its sequence number, it MUST do so by treating the sequence number value as if it were an unsigned number. To accomplish sequence number rollover, if the sequence number has already been assigned to be the largest possible number representable as a 32-bit unsigned integer (i.e., 4294967295), then when it is incremented it will then have a value of zero (0). On the other hand, if the sequence number currently has the value 2147483647, which is the largest possible positive integer if 2's complement arithmetic is in use with 32-bit integers, the next value will be 2147483648, which is the most negative possible integer in the same numbering system. The representation of negative numbers is not relevant to the increment of AODV sequence numbers. This is in contrast to the manner in which the result of comparing two AODV sequence numbers is to be treated (see below).",
      "ja": "宛先は、そのシーケンス番号をインクリメントするとき、それは符号なしの数であるかのように、シーケンス番号値を処理することによって、そうしなければなりません。それがインクリメントされたときにシーケンス番号が既に32ビットの符号なし整数として可能な最大数の表現であることに割り当てられている場合、シーケンス番号のロールオーバを達成するために（すなわち、4294967295）が、それはゼロの値を有するであろう（0） 。シーケンス番号は、現在、2の補数演算は32ビット整数とともに使用されている場合に可能な最大の正の整数値2147483647を有し、一方、次の値は、最も負の可能な整数である2147483648、あろう同じナンバリングシステム。負の数の表現はAODVのシーケンス番号の増加に関連していません。これは、二つのAODVのシーケンス番号を比較した結果（下記参照）で処理される方法とは対照的です。"
    },
    {
      "indent": 3,
      "text": "In order to ascertain that information about a destination is not stale, the node compares its current numerical value for the sequence number with that obtained from the incoming AODV message. This comparison MUST be done using signed 32-bit arithmetic, this is necessary to accomplish sequence number rollover. If the result of subtracting the currently stored sequence number from the value of the incoming sequence number is less than zero, then the information related to that destination in the AODV message MUST be discarded, since that information is stale compared to the node's currently stored information.",
      "ja": "先についての情報を確認するために古くなっていない場合、ノードは、着信AODVメッセージから得られたものとシーケンス番号の現在の数値とを比較します。この比較は、符号付き32ビット演算を使用して行う必要があり、これは、シーケンス番号のロールオーバを達成するために必要です。受信シーケンス番号の値から現在格納されているシーケンス番号を減算結果がゼロ未満である場合、その情報は、ノードの現在格納されている情報と比較して古くなっているので、その後、AODVメッセージにその宛先に関連する情報は、破棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The only other circumstance in which a node may change the destination sequence number in one of its route table entries is in response to a lost or expired link to the next hop towards that destination. The node determines which destinations use a particular next hop by consulting its routing table. In this case, for each destination that uses the next hop, the node increments the sequence number and marks the route as invalid (see also sections 6.11, 6.12). Whenever any fresh enough (i.e., containing a sequence number at least equal to the recorded sequence number) routing information for an affected destination is received by a node that has marked that route table entry as invalid, the node SHOULD update its route table information according to the information contained in the update.",
      "ja": "ノードは、そのルートテーブルエントリの1つに宛先シーケンス番号を変更することができた唯一の他の状況は、その宛先に向かう次のホップに紛失または期限切れのリンクに応答します。ノードは、宛先がそのルーティングテーブルを参照することにより特定の次のホップを使用するかを決定します。この場合には、次のホップを使用して、各宛先に対して、ノードは、シーケンス番号をインクリメントし（セクション6.11、6.12も参照）無効としてルートをマーク。影響を受けた宛先のいずれかに十分な新鮮な（すなわち、記録されたシーケンス番号に少なくとも等しいシーケンス番号を含む）経路情報を無効としてそのルートテーブルエントリをマークしているノードによって受信されるたびに、ノードは、に従ってそのルートテーブル情報を更新します情報への更新に含まれています。"
    },
    {
      "indent": 3,
      "text": "A node may change the sequence number in the routing table entry of a destination only if:",
      "ja": "ノードは、場合にのみ、先のルーティングテーブルエントリ内のシーケンス番号を変更してもよいです。"
    },
    {
      "indent": 3,
      "text": "- it is itself the destination node, and offers a new route to itself, or",
      "ja": " - それは、それ自体、宛先ノードであり、それ自体に新しいルートを提供していますか"
    },
    {
      "indent": 3,
      "text": "- it receives an AODV message with new information about the sequence number for a destination node, or",
      "ja": " - それは、宛先ノードのシーケンス番号についての新しい情報をAODVメッセージを受信し、又は"
    },
    {
      "indent": 3,
      "text": "- the path towards the destination node expires or breaks.",
      "ja": " - 宛先ノードへのパスの有効期限が切れたり破損。"
    },
    {
      "indent": 0,
      "text": "6.2. Route Table Entries and Precursor Lists",
      "section_title": true,
      "ja": "6.2. ルートテーブルエントリと前駆リスト"
    },
    {
      "indent": 3,
      "text": "When a node receives an AODV control packet from a neighbor, or creates or updates a route for a particular destination or subnet, it checks its route table for an entry for the destination. In the event that there is no corresponding entry for that destination, an entry is created. The sequence number is either determined from the information contained in the control packet, or else the valid sequence number field is set to false. The route is only updated if the new sequence number is either",
      "ja": "ノードは、ネイバーからAODV制御パケットを受信し、または作成または特定の宛先またはサブネットのルートを更新するとき、それは先のエントリのためにそのルートテーブルをチェック。その先には、対応するエントリが存在しないと場合には、エントリが作成されます。シーケンス番号は、いずれかの制御パケットに含まれる情報から判断され、または他の有効なシーケンス番号フィールドがfalseに設定されています。新しいシーケンス番号がいずれかの場合は、ルートにのみ更新されます"
    },
    {
      "indent": 3,
      "text": "(i) higher than the destination sequence number in the route table, or",
      "ja": "（I）ルートテーブル内の宛先シーケンス番号よりも大きい、または"
    },
    {
      "indent": 3,
      "text": "(ii) the sequence numbers are equal, but the hop count (of the new information) plus one, is smaller than the existing hop count in the routing table, or",
      "ja": "（ii）のシーケンス番号が同じであるが、ホップ（新しい情報の）カウントプラスワンは、ルーティングテーブル内の既存のホップ数よりも小さい場合、または"
    },
    {
      "indent": 3,
      "text": "(iii) the sequence number is unknown.",
      "ja": "（iii）のシーケンス番号が不明です。"
    },
    {
      "indent": 3,
      "text": "The Lifetime field of the routing table entry is either determined from the control packet, or it is initialized to ACTIVE_ROUTE_TIMEOUT. This route may now be used to send any queued data packets and fulfills any outstanding route requests.",
      "ja": "ルーティングテーブルエントリの有効期間フィールドがいずれかの制御パケットから決定された、またはそれがACTIVE_ROUTE_TIMEOUTに初期化されます。このルートは、今どのキューに入れられたデータパケットを送信するために使用され、未解決のルート要求を満たしていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Each time a route is used to forward a data packet, its Active Route Lifetime field of the source, destination and the next hop on the path to the destination is updated to be no less than the current time plus ACTIVE_ROUTE_TIMEOUT. Since the route between each originator and destination pair is expected to be symmetric, the Active Route Lifetime for the previous hop, along the reverse path back to the IP source, is also updated to be no less than the current time plus ACTIVE_ROUTE_TIMEOUT. The lifetime for an Active Route is updated each time the route is used regardless of whether the destination is a single node or a subnet.",
      "ja": "ルートは、データパケットを転送するために使用されるたびに、ソース、宛先及び目的地までの経路上の次のホップのそのアクティブな経路寿命フィールドは、現在の時間とACTIVE_ROUTE_TIMEOUTよりも少なくならないように更新されます。各発信元と宛先のペアの間のルートは、前のホップのためにアクティブな経路寿命対称であることが期待されているので、バックIPソースへの逆の経路に沿って、また現在時刻プラスACTIVE_ROUTE_TIMEOUT未満でないことがないように更新されます。アクティブルートの有効期間は、経路に関係なく、宛先が単一のノードまたはサブネットであるかどうかに使用されるたびに更新されます。"
    },
    {
      "indent": 3,
      "text": "For each valid route maintained by a node as a routing table entry, the node also maintains a list of precursors that may be forwarding packets on this route. These precursors will receive notifications from the node in the event of detection of the loss of the next hop link. The list of precursors in a routing table entry contains those neighboring nodes to which a route reply was generated or forwarded.",
      "ja": "ルーティングテーブルエントリとしてノードによって維持各有効なルートのため、ノードはまた、この経路上のパケットを転送することができる前駆体のリストを維持します。これらの前駆体は、次のホップリンクの損失を検出した場合に、ノードからの通知を受信します。ルーティング・テーブル・エントリ内の前駆体のリストは、ルート応答が生成され、または転送された先のものの隣接ノードを含みます。"
    },
    {
      "indent": 0,
      "text": "6.3. Generating Route Requests",
      "section_title": true,
      "ja": "6.3. ルート要求の生成"
    },
    {
      "indent": 3,
      "text": "A node disseminates a RREQ when it determines that it needs a route to a destination and does not have one available. This can happen if the destination is previously unknown to the node, or if a previously valid route to the destination expires or is marked as invalid. The Destination Sequence Number field in the RREQ message is the last known destination sequence number for this destination and is copied from the Destination Sequence Number field in the routing table. If no sequence number is known, the unknown sequence number flag MUST be set. The Originator Sequence Number in the RREQ message is the node's own sequence number, which is incremented prior to insertion in a RREQ. The RREQ ID field is incremented by one from the last RREQ ID used by the current node. Each node maintains only one RREQ ID. The Hop Count field is set to zero.",
      "ja": "それは目的地までの経路を必要とし、利用可能なものを持っていないと判断した場合、ノードは、RREQを発信します。宛先がノードに以前に不明な場合、または宛先への以前に有効なルートが期限切れになるか、無効としてマークされている場合に発生することがあります。 RREQメッセージの宛先シーケンス番号フィールドは、この宛先の最後の既知の宛先シーケンス番号であり、ルーティングテーブルに宛先シーケンス番号フィールドからコピーされます。シーケンス番号が知られていない場合は、未知の配列番号フラグを設定しなければなりません。 RREQメッセージ内の発信シーケンス番号はRREQに挿入する前にインクリメントされ、ノード自身のシーケンス番号です。 RREQ IDフィールドは、現在のノードによって使用される最後のRREQ IDから1だけインクリメントされます。各ノードは一つだけRREQのIDを維持します。ホップカウントフィールドがゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "Before broadcasting the RREQ, the originating node buffers the RREQ ID and the Originator IP address (its own address) of the RREQ for PATH_DISCOVERY_TIME. In this way, when the node receives the packet again from its neighbors, it will not reprocess and re-forward the packet.",
      "ja": "RREQを放送する前に、発信ノードはPATH_DISCOVERY_TIMEのためのRREQのRREQのIDと発信IPアドレス（自身のアドレス）をバッファリング。このように、パケットをノードがネイバーから再びパケットを受信したとき、それは再処理せず、再転送します。"
    },
    {
      "indent": 3,
      "text": "An originating node often expects to have bidirectional communications with a destination node. In such cases, it is not sufficient for the originating node to have a route to the destination node; the destination must also have a route back to the originating node. In order for this to happen as efficiently as possible, any generation of a RREP by an intermediate node (as in section 6.6) for delivery to the originating node SHOULD be accompanied by some action that notifies the destination about a route back to the originating node. The originating node selects this mode of operation in the intermediate nodes by setting the 'G' flag. See section 6.6.3 for details about actions taken by the intermediate node in response to a RREQ with the 'G' flag set.",
      "ja": "発信ノードは、多くの場合、宛先ノードとの双方向通信を持っていることを想定しています。発信元ノードが宛先ノードへのルートを持っているような場合には、十分ではありません。先にも戻って発信ノードへのルートを持っている必要があります。これは、できるだけ効率的に発生するために、発信元ノードへの送達のために（セクション6.6のように）、中間ノードによるRREPの生成は、バック発信ノードまでの経路について先に通知する何らかのアクションを伴うことSHOULD 。発信元ノードは、「G」フラグを設定することによって、中間ノードにこの動作モードを選択します。 「G」フラグが設定されたRREQに応答して、中間ノードが取った行動の詳細については、セクション6.6.3を参照。"
    },
    {
      "indent": 3,
      "text": "A node SHOULD NOT originate more than RREQ_RATELIMIT RREQ messages per second. After broadcasting a RREQ, a node waits for a RREP (or other control message with current information regarding a route to the appropriate destination). If a route is not received within NET_TRAVERSAL_TIME milliseconds, the node MAY try again to discover a route by broadcasting another RREQ, up to a maximum of RREQ_RETRIES times at the maximum TTL value. Each new attempt MUST increment and update the RREQ ID. For each attempt, the TTL field of the IP header is set according to the mechanism specified in section 6.4, in order to enable control over how far the RREQ is disseminated for the each retry.",
      "ja": "ノードは、毎秒RREQ_RATELIMIT RREQメッセージよりも多くを発信すべきではありません。 RREQをブロードキャストした後、ノードは、RREP（または適切な目的地までの経路に関する現在の情報を他の制御メッセージ）を待ちます。ルートはNET_TRAVERSAL_TIMEミリ秒以内に受信されない場合、ノードは最大TTL値でRREQ_RETRIES時間の最大値まで、別のRREQをブロードキャストすることにより、経路を発見するためにもう一度試してください。それぞれの新しい試みはRREQのIDをインクリメントして更新しなければなりません。各試みのために、IPヘッダのTTLフィールドは、RREQが各再試行のために配布されるどの程度の制御を可能にするために、セクション6.4で指定されたメカニズムに応じて設定されます。"
    },
    {
      "indent": 3,
      "text": "Data packets waiting for a route (i.e., waiting for a RREP after a RREQ has been sent) SHOULD be buffered. The buffering SHOULD be \"first-in, first-out\" (FIFO). If a route discovery has been attempted RREQ_RETRIES times at the maximum TTL without receiving any RREP, all data packets destined for the corresponding destination SHOULD be dropped from the buffer and a Destination Unreachable message SHOULD be delivered to the application.",
      "ja": "ルートを待っているデータ・パケット（すなわち、RREQが送信された後にRREPを待っている）緩衝化されるべきです。バッファリングは、「先入れ先出し」（FIFO）であるべきです。ルート発見は、任意のRREPを受信せずに最大TTLでRREQ_RETRIES回試みられた場合、対応する宛先に宛てたすべてのデータパケットがバッファから削除されるべきであり、宛先到達不能メッセージがアプリケーションに送達されるべきです。"
    },
    {
      "indent": 3,
      "text": "To reduce congestion in a network, repeated attempts by a source node at route discovery for a single destination MUST utilize a binary exponential backoff. The first time a source node broadcasts a RREQ, it waits NET_TRAVERSAL_TIME milliseconds for the reception of a RREP. If a RREP is not received within that time, the source node sends a new RREQ. When calculating the time to wait for the RREP after sending the second RREQ, the source node MUST use a binary exponential backoff. Hence, the waiting time for the RREP corresponding to the second RREQ is 2 * NET_TRAVERSAL_TIME milliseconds. If a RREP is not received within this time period, another RREQ may be sent, up to RREQ_RETRIES additional attempts after the first RREQ. For each additional attempt, the waiting time for the RREP is multiplied by 2, so that the time conforms to a binary exponential backoff.",
      "ja": "ネットワークの輻輳を低減するために、二進指数バックオフを利用しなければならない単一の宛先のためのルート発見のソースノードによって試行を繰り返します。ソースノードがRREQをブロードキャストする最初の時間は、それがRREPの受信NET_TRAVERSAL_TIMEミリ秒待機します。 RREPがその時間内に受信されない場合は、ソースノードは、新たなRREQを送信します。第RREQを送信した後にRREPを待つ時間を算出する際に、ソースノードは2進指数バックオフを使用しなければなりません。従って、RREPが第RREQに対応するための待ち時間は2 * NET_TRAVERSAL_TIMEミリ秒です。 RREPは、この時間内に受信されない場合、別のRREQは、RREQ最初後RREQ_RETRIES追加の試みまで、送信されても​​よいです。時間は2進指数バックオフに一致するように各追加の試みのため、RREPのための待機時間が、2で乗算されます。"
    },
    {
      "indent": 0,
      "text": "6.4. Controlling Dissemination of Route Request Messages",
      "section_title": true,
      "ja": "6.4. 経路要求メッセージの制御普及"
    },
    {
      "indent": 3,
      "text": "To prevent unnecessary network-wide dissemination of RREQs, the originating node SHOULD use an expanding ring search technique. In an expanding ring search, the originating node initially uses a TTL = TTL_START in the RREQ packet IP header and sets the timeout for receiving a RREP to RING_TRAVERSAL_TIME milliseconds. RING_TRAVERSAL_TIME is calculated as described in section 10. The TTL_VALUE used in calculating RING_TRAVERSAL_TIME is set equal to the value of the TTL field in the IP header. If the RREQ times out without a corresponding RREP, the originator broadcasts the RREQ again with the TTL incremented by TTL_INCREMENT. This continues until the TTL set in the RREQ reaches TTL_THRESHOLD, beyond which a TTL = NET_DIAMETER is used for each attempt. Each time, the timeout for receiving a RREP is RING_TRAVERSAL_TIME. When it is desired to have all retries traverse the entire ad hoc network, this can be achieved by configuring TTL_START and TTL_INCREMENT both to be the same value as NET_DIAMETER.",
      "ja": "RREQの不要なネットワーク全体の普及を防ぐために、発信ノードは、拡張リング検索技術を使用すべきです。拡張リング検索では、発信元ノードは、最初にRREQパケットのIPヘッダ内のTTL = TTL_STARTを使用して、ミリ秒RING_TRAVERSAL_TIMEするRREPを受信するためのタイムアウトを設定します。部10 RING_TRAVERSAL_TIMEの計算に使用TTL_VALUEに記載のIPヘッダ内のTTLフィールドの値に等しく設定されるRING_TRAVERSAL_TIMEが算出されます。対応するRREPのないアウトRREQ時間は、発信者はTTL_INCREMENTずつ増加TTLで再びRREQをブロードキャストした場合。 RREQに設定されたTTLはTTL = NET_DIAMETER各試行のために使用される超えTTL_THRESHOLDに達するまで続きます。たびに、RREPを受信するためのタイムアウトはRING_TRAVERSAL_TIMEです。それが有することが望まれるときに、すべての試行全体アドホックネットワークを横断する、これはNET_DIAMETERと同じ値にTTL_STARTとTTL_INCREMENTの両方を構成することによって達成することができます。"
    },
    {
      "indent": 3,
      "text": "The Hop Count stored in an invalid routing table entry indicates the last known hop count to that destination in the routing table. When a new route to the same destination is required at a later time (e.g., upon route loss), the TTL in the RREQ IP header is initially set to the Hop Count plus TTL_INCREMENT. Thereafter, following each timeout the TTL is incremented by TTL_INCREMENT until TTL = TTL_THRESHOLD is reached. Beyond this TTL = NET_DIAMETER is used. Once TTL = NET_DIAMETER, the timeout for waiting for the RREP is set to NET_TRAVERSAL_TIME, as specified in section 6.3.",
      "ja": "無効なルーティングテーブルエントリに格納されたホップカウントは、ルーティングテーブル内のその宛先への最後の既知のホップ数を示しています。同じ宛先への新しい経路が後で必要とされる場合（例えば、経路損失時）、RREQのIPヘッダ内のTTLは、最初ホップカウントプラスTTL_INCREMENTに設定されています。 TTL = TTL_THRESHOLDに達するまでその後、各タイムアウト以下TTLをTTL_INCREMENTだけインクリメントされます。このTTLを超え= NET_DIAMETERが使用されます。セクション6.3で指定されるようにTTL = NET_DIAMETERたら、RREPを待つタイムアウトは、NET_TRAVERSAL_TIMEに設定されています。"
    },
    {
      "indent": 3,
      "text": "An expired routing table entry SHOULD NOT be expunged before (current_time + DELETE_PERIOD) (see section 6.11). Otherwise, the soft state corresponding to the route (e.g., last known hop count) will be lost. Furthermore, a longer routing table entry expunge time MAY be configured. Any routing table entry waiting for a RREP SHOULD NOT be expunged before (current_time + 2 * NET_TRAVERSAL_TIME).",
      "ja": "期限切れのルーティングテーブルエントリは（セクション6.11を参照してください）（CURRENT_TIME + DELETE_PERIOD）の前に抹消されるべきではありません。そうでなければ、経路（例えば、最後の既知のホップ数）に対応するソフト状態が失われることになります。さらに、より長いルーティングテーブルエントリEXPUNGE時間を構成してもよいです。 RREPを待っている任意のルーティングテーブルエントリは（CURRENT_TIME + 2 * NET_TRAVERSAL_TIME）の前に抹消されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "6.5. Processing and Forwarding Route Requests",
      "section_title": true,
      "ja": "6.5. ルート要求を処理し、転送"
    },
    {
      "indent": 3,
      "text": "When a node receives a RREQ, it first creates or updates a route to the previous hop without a valid sequence number (see section 6.2) then checks to determine whether it has received a RREQ with the same Originator IP Address and RREQ ID within at least the last PATH_DISCOVERY_TIME. If such a RREQ has been received, the node silently discards the newly received RREQ. The rest of this subsection describes actions taken for RREQs that are not discarded.",
      "ja": "ノードがRREQを受信すると、それは最初に（セクション6.2を参照）は、有効なシーケンス番号のない前のホップへのルートを作成または更新し、次に、それは少なくとも内の同じ発信元のIPアドレスとRREQ IDにRREQを受信したかどうかを決定するためにチェック最後PATH_DISCOVERY_TIME。そのようなRREQを受信した場合、ノードは静かに新たに受信したRREQを破棄する。このサブセクションの残りの部分は破棄されていないのRREQのために取らアクションについて説明します。"
    },
    {
      "indent": 3,
      "text": "First, it first increments the hop count value in the RREQ by one, to account for the new hop through the intermediate node. Then the node searches for a reverse route to the Originator IP Address (see section 6.2), using longest-prefix matching. If need be, the route is created, or updated using the Originator Sequence Number from the RREQ in its routing table. This reverse route will be needed if the node receives a RREP back to the node that originated the RREQ (identified by the Originator IP Address). When the reverse route is created or updated, the following actions on the route are also carried out:",
      "ja": "まず、第一の中間ノードを介して、新たなホップを説明するために、1でRREQ中のホップカウント値をインクリメントします。次に、発信元IPアドレスへの逆方向経路のノード検索は最長プレフィックスマッチングを使用して、（セクション6.2を参照します）。必要であれば、ルートが作成され、またはそのルーティングテーブルにRREQから発信シーケンス番号を使用して更新されます。ノードが（発信IPアドレスで識別される）RREQを発信ノードに戻ってRREPを受信した場合には、この逆のルートが必要になります。逆のルートが作成または更新されると、ルート上の次のアクションも行われています。"
    },
    {
      "indent": 3,
      "text": "1. the Originator Sequence Number from the RREQ is compared to the corresponding destination sequence number in the route table entry and copied if greater than the existing value there",
      "ja": "1. RREQから発信シーケンス番号はルートテーブルエントリに対応する宛先シーケンス番号と比較し、そこに既存の値よりも大きい場合にコピーされます"
    },
    {
      "indent": 3,
      "text": "2. the valid sequence number field is set to true;",
      "ja": "2.有効なシーケンス番号フィールドがtrueに設定されています。"
    },
    {
      "indent": 3,
      "text": "3. the next hop in the routing table becomes the node from which the RREQ was received (it is obtained from the source IP address in the IP header and is often not equal to the Originator IP Address field in the RREQ message);",
      "ja": "前記ルーティングテーブル内の次ホップはRREQを（それはIPヘッダの送信元IPアドレスから得られ、多くの場合、RREQメッセージ内の発信元IPアドレスのフィールドに等しくない場合）受信されたノードとなります。"
    },
    {
      "indent": 3,
      "text": "4. the hop count is copied from the Hop Count in the RREQ message;",
      "ja": "4.ホップ数はRREQメッセージ内のホップカウントからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Whenever a RREQ message is received, the Lifetime of the reverse route entry for the Originator IP address is set to be the maximum of (ExistingLifetime, MinimalLifetime), where",
      "ja": "RREQメッセージが受信されるたびに、発信元IPアドレスの逆ルートエントリの寿命は（ExistingLifetime、MinimalLifetime）の最大値に設定されています"
    },
    {
      "indent": 6,
      "text": "MinimalLifetime = (current time + 2*NET_TRAVERSAL_TIME - 2*HopCount*NODE_TRAVERSAL_TIME).",
      "ja": "MinimalLifetime =（現在の時間+ 2 * NET_TRAVERSAL_TIME  -  2 *ホップカウント* NODE_TRAVERSAL_TIME）。"
    },
    {
      "indent": 3,
      "text": "The current node can use the reverse route to forward data packets in the same way as for any other route in the routing table.",
      "ja": "現在のノードは、ルーティングテーブル内の他の経路と同じ方法でデータパケットを転送するために逆のルートを使用することができます。"
    },
    {
      "indent": 3,
      "text": "If a node does not generate a RREP (following the processing rules in section 6.6), and if the incoming IP header has TTL larger than 1, the node updates and broadcasts the RREQ to address 255.255.255.255 on each of its configured interfaces (see section 6.14). To update the RREQ, the TTL or hop limit field in the outgoing IP header is decreased by one, and the Hop Count field in the RREQ message is incremented by one, to account for the new hop through the intermediate node. Lastly, the Destination Sequence number for the requested destination is set to the maximum of the corresponding value received in the RREQ message, and the destination sequence value currently maintained by the node for the requested destination. However, the forwarding node MUST NOT modify its maintained value for the destination sequence number, even if the value received in the incoming RREQ is larger than the value currently maintained by the forwarding node.",
      "ja": "ノードは、（セクション6.6の処理規則に従って）RREPを生成し、受信IPヘッダが1より大きいTTL、ノードの更新を有し、その設定されたインターフェイスの各々に255.255.255.255に対処するRREQをブロードキャストする場合（参照しない場合セクション6.14）。 RREQを更新するには、発信IPヘッダーのTTL又はホップ限界フィールドが1減少し、RREQメッセージ内のホップカウントフィールドは、中間ノードを介して新たなホップを考慮するために、1だけインクリメントされます。最後に、要求された宛先の宛先シーケンス番号がRREQメッセージで受信した対応する値の最大値に設定され、宛先シーケンス値は、現在要求された宛先のノードによって維持されます。しかし、転送ノードは、着信RREQに受信された値は、現在転送ノードによって維持される値よりも大きい場合であっても、宛先シーケンス番号のためにその保持値を変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if a node does generate a RREP, then the node discards the RREQ. Notice that, if intermediate nodes reply to every transmission of RREQs for a particular destination, it might turn out that the destination does not receive any of the discovery messages. In this situation, the destination does not learn of a route to the originating node from the RREQ messages. This could cause the destination to initiate a route discovery (for example, if the originator is attempting to establish a TCP session). In order that the destination learn of routes to the originating node, the originating node SHOULD set the \"gratuitous RREP\" ('G') flag in the RREQ if for any reason the destination is likely to need a route to the originating node. If, in response to a RREQ with the 'G' flag set, an intermediate node returns a RREP, it MUST also unicast a gratuitous RREP to the destination node (see section 6.6.3).",
      "ja": "ノードがRREPを生成しない場合はそれ以外の場合は、そのノードはRREQを破棄します。中間ノードは、特定の宛先用のRREQのすべての伝送に返信すれば、それは宛先が発見メッセージのいずれかを受信して​​いないことが判明するかもしれない、ということに注意してください。このような状況では、宛先はRREQメッセージから発信ノードへの経路を学習しません。これは、（発信者がTCPセッションを確立しようとしている場合、たとえば）ルート発見を開始するために、先を引き起こす可能性があります。宛先が発信ノードへのルートを必要とする可能性がある何らかの理由であれば宛先が発信ノードへのルートを知るようにするために、発信元ノードは、RREQ内の「無償RREP」（「G」）フラグを設定する必要があります。 、「G」フラグが設定されたRREQに応答して、中間ノードがRREPを返す場合、それは、宛先ノードへ無償RREPをユニキャストしなければならない（セクション6.6.3を参照）。"
    },
    {
      "indent": 0,
      "text": "6.6. Generating Route Replies",
      "section_title": true,
      "ja": "6.6. ルート返信を生成します"
    },
    {
      "indent": 3,
      "text": "A node generates a RREP if either:",
      "ja": "いずれかの場合、ノードは、RREPを生成します。"
    },
    {
      "indent": 3,
      "text": "(i) it is itself the destination, or",
      "ja": "（I）それ自体が宛先である、又は"
    },
    {
      "indent": 3,
      "text": "(ii) it has an active route to the destination, the destination sequence number in the node's existing route table entry for the destination is valid and greater than or equal to the Destination Sequence Number of the RREQ (comparison using signed 32-bit arithmetic), and the \"destination only\" ('D') flag is NOT set.",
      "ja": "（ii）は、それが先にアクティブなルートを有し、宛先のノードの既存のルートテーブルエントリの宛先シーケンス番号が有効であり、より大きいまたはRREQのデスティネーションシーケンス番号（比較符号付き32ビット演算を使用して）に等しいです。 、および「宛先のみ」（「D」）フラグがセットされていません。"
    },
    {
      "indent": 3,
      "text": "When generating a RREP message, a node copies the Destination IP Address and the Originator Sequence Number from the RREQ message into the corresponding fields in the RREP message. Processing is slightly different, depending on whether the node is itself the requested destination (see section 6.6.1), or instead if it is an intermediate node with an fresh enough route to the destination (see section 6.6.2).",
      "ja": "RREPメッセージの対応するフィールドにRREQメッセージからRREPメッセージは、ノードのコピー宛先IPアドレス及び発信元シーケンス番号を生成する場合。処理ノードが要求された宛先（セクション6.6.1を参照）自体であるかどうかに応じて、わずかに異なっている、またはそれが目的地までの新たに十分な経路を有する中間ノードである代わり場合（セクション6.6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Once created, the RREP is unicast to the next hop toward the originator of the RREQ, as indicated by the route table entry for that originator. As the RREP is forwarded back towards the node which originated the RREQ message, the Hop Count field is incremented by one at each hop. Thus, when the RREP reaches the originator, the Hop Count represents the distance, in hops, of the destination from the originator.",
      "ja": "作成されると、その発信のためのルートテーブルエントリによって示されるように、RREPは、RREQの発信元に向けて次のホップにユニキャストです。 RREPは、RREQメッセージを発信したノードに向かって戻って転送されるように、ホップカウントフィールドは、各ホップで1だけインクリメントされます。 RREPは、発信に達したときにこのように、ホップカウントは、発信元から宛先のホップでの距離を表します。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Route Reply Generation by the Destination",
      "section_title": true,
      "ja": "6.6.1. ルートは目的地によって生成返信"
    },
    {
      "indent": 3,
      "text": "If the generating node is the destination itself, it MUST increment its own sequence number by one if the sequence number in the RREQ packet is equal to that incremented value. Otherwise, the destination does not change its sequence number before generating the RREP message. The destination node places its (perhaps newly incremented) sequence number into the Destination Sequence Number field of the RREP, and enters the value zero in the Hop Count field of the RREP.",
      "ja": "発生ノードが宛先自体である場合、RREQパケットのシーケンス番号は、そのインクリメントされた値に等しい場合、これは、1つによってそれ自体のシーケンス番号をインクリメントしなければなりません。そうでなければ、先がRREPメッセージを生成する前に、そのシーケンス番号は変更されません。宛先ノードは、RREPの宛先シーケンス番号フィールドにその（おそらく新たにインクリメント）シーケンス番号を配置し、RREPのホップカウントフィールドの値がゼロに入ります。"
    },
    {
      "indent": 3,
      "text": "The destination node copies the value MY_ROUTE_TIMEOUT (see section 10) into the Lifetime field of the RREP. Each node MAY reconfigure its value for MY_ROUTE_TIMEOUT, within mild constraints (see section 10).",
      "ja": "RREPの寿命フィールドに宛先ノードコピー値MY_ROUTE_TIMEOUT（セクション10を参照）。各ノードは、軽度の制約の範囲内（セクション10を参照）、MY_ROUTE_TIMEOUTためにその値を再構成することができます。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Route Reply Generation by an Intermediate Node",
      "section_title": true,
      "ja": "6.6.2. ルートは、中間ノードによって生成返信"
    },
    {
      "indent": 3,
      "text": "If the node generating the RREP is not the destination node, but instead is an intermediate hop along the path from the originator to the destination, it copies its known sequence number for the destination into the Destination Sequence Number field in the RREP message.",
      "ja": "RREPを生成するノードが宛先ノードではなく、先に発信元からの経路に沿った中間ホップである場合、RREPメッセージの宛先シーケンス番号フィールドに宛先にコピーし、その既知のシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "The intermediate node updates the forward route entry by placing the last hop node (from which it received the RREQ, as indicated by the source IP address field in the IP header) into the precursor list for the forward route entry -- i.e., the entry for the Destination IP Address. The intermediate node also updates its route table entry for the node originating the RREQ by placing the next hop towards the destination in the precursor list for the reverse route entry -- i.e., the entry for the Originator IP Address field of the RREQ message data.",
      "ja": "すなわち、エントリ - 中間ノードがフォワード経路エントリの前駆リストに（IPヘッダ内の送信元IPアドレスフィールドによって示されるように、それは、RREQを受信し、そこから）最終ホップノードを配置することによって、前方ルートエントリを更新します宛先IPアドレスのために。すなわちRREQメッセージデータの発信元IPアドレスのフィールドのエントリを - 中間ノードは、逆ルートエントリのための前駆体のリストで宛先に向け次のホップを配置することによって、RREQを発信するノードのためにそのルートテーブルエントリを更新します。"
    },
    {
      "indent": 3,
      "text": "The intermediate node places its distance in hops from the destination (indicated by the hop count in the routing table) Count field in the RREP. The Lifetime field of the RREP is calculated by subtracting the current time from the expiration time in its route table entry.",
      "ja": "中間ノードは、RREPのフィールドカウント（ルーティングテーブルのホップ数によって示される）宛先からのホップでの距離を置きます。 RREPの寿命フィールドは、そのルートテーブルエントリの有効期限時刻から現在時刻を減算することによって計算されます。"
    },
    {
      "indent": 0,
      "text": "6.6.3. Generating Gratuitous RREPs",
      "section_title": true,
      "ja": "6.6.3. 無償たRREPの生成"
    },
    {
      "indent": 3,
      "text": "After a node receives a RREQ and responds with a RREP, it discards the RREQ. If the RREQ has the 'G' flag set, and the intermediate node returns a RREP to the originating node, it MUST also unicast a gratuitous RREP to the destination node. The gratuitous RREP that is to be sent to the desired destination contains the following values in the RREP message fields:",
      "ja": "ノードがRREQを受信し、RREPで応答した後、それはRREQを破棄する。 RREQは、「G」フラグがセットされている、中間ノードが発信ノードへRREPを返す場合、それはまた、宛先ノードへ無償RREPをユニキャストしなければなりません。所望の宛先に送信される無償RREPは、RREPメッセージフィールドに以下の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "Hop Count The Hop Count as indicated in the node's route table entry for the originator",
      "ja": "発信のために、ノードのルーティングテーブルエントリに示されるように、ホップはホップカウントをカウント"
    },
    {
      "indent": 3,
      "text": "Destination IP Address The IP address of the node that originated the RREQ",
      "ja": "宛先IPは、RREQを発信したノードのIPアドレス"
    },
    {
      "indent": 3,
      "text": "Destination Sequence Number The Originator Sequence Number from the RREQ",
      "ja": "RREQから先のシーケンス番号発信シーケンス番号"
    },
    {
      "indent": 3,
      "text": "Originator IP Address The IP address of the Destination node in the RREQ",
      "ja": "発信元IPはRREQ内の宛先ノードのIPアドレス"
    },
    {
      "indent": 3,
      "text": "Lifetime The remaining lifetime of the route towards the originator of the RREQ, as known by the intermediate node.",
      "ja": "中間ノードに知られているよう寿命RREQの発信元に向けて経路の残り寿命、。"
    },
    {
      "indent": 3,
      "text": "The gratuitous RREP is then sent to the next hop along the path to the destination node, just as if the destination node had already issued a RREQ for the originating node and this RREP was produced in response to that (fictitious) RREQ. The RREP that is sent to the originator of the RREQ is the same whether or not the 'G' bit is set.",
      "ja": "無償RREPは、宛先ノードが既に発信ノードのRREQを発行したこのRREPがその（架空）RREQに応答して産生されたかのように、宛先ノードへの経路に沿った次のホップに送信されます。 RREQの発信者に送信されたRREP「はG」ビットが設定されているか否か同じです。"
    },
    {
      "indent": 0,
      "text": "6.7. Receiving and Forwarding Route Replies",
      "section_title": true,
      "ja": "6.7. ルート返信を受信および転送"
    },
    {
      "indent": 3,
      "text": "When a node receives a RREP message, it searches (using longest-prefix matching) for a route to the previous hop. If needed, a route is created for the previous hop, but without a valid sequence number (see section 6.2). Next, the node then increments the hop count value in the RREP by one, to account for the new hop through the intermediate node. Call this incremented value the \"New Hop Count\". Then the forward route for this destination is created if it does not already exist. Otherwise, the node compares the Destination Sequence Number in the message with its own stored destination sequence number for the Destination IP Address in the RREP message. Upon comparison, the existing entry is updated only in the following circumstances:",
      "ja": "ノードは、RREPメッセージを受信した場合、それは前のホップへのルートのために（最長プレフィックスマッチングを使用して）検索します。必要に応じて、ルートは前のホップのために作成されていますが、有効なシーケンス番号のない（セクション6.2を参照してください）。次に、ノードは、中間ノードを通して新しいホップを考慮して、いずれかによってRREPにおけるホップカウント値をインクリメントします。 「新しいホップカウント」このインクリメントされた値を呼び出します。それはまだ存在しない場合、この宛先の往路が作成されます。そうしないと、ノードはRREPメッセージの宛先IPアドレスのために、独自の保存先のシーケンス番号とメッセージの宛先シーケンス番号を比較します。比較すると、既存のエントリは、以下の状況でのみ更新されます。"
    },
    {
      "indent": 3,
      "text": "(i) the sequence number in the routing table is marked as invalid in route table entry.",
      "ja": "（I）ルーティングテーブル内のシーケンス番号はルートテーブルエントリに無効とマークされています。"
    },
    {
      "indent": 3,
      "text": "(ii) the Destination Sequence Number in the RREP is greater than the node's copy of the destination sequence number and the known value is valid, or",
      "ja": "（ⅱ）RREPのDestinationシーケンス番号は、先のシーケンス番号のノードのコピーよりも大きくなると知られている値が有効ですか、"
    },
    {
      "indent": 3,
      "text": "(iii) the sequence numbers are the same, but the route is is marked as inactive, or",
      "ja": "（iii）のシーケンス番号が同じであるが、ルートは非アクティブとしてマークされている、又は"
    },
    {
      "indent": 3,
      "text": "(iv) the sequence numbers are the same, and the New Hop Count is smaller than the hop count in route table entry.",
      "ja": "（ⅳ）シーケンス番号は同じであり、新しいホップカウントは、ルートテーブルエントリ内のホップ数よりも小さくなっています。"
    },
    {
      "indent": 3,
      "text": "If the route table entry to the destination is created or updated, then the following actions occur:",
      "ja": "目的地までのルートテーブルエントリが作成または更新された場合は、次のアクションが発生します。"
    },
    {
      "indent": 3,
      "text": "- the route is marked as active,",
      "ja": " - ルートがアクティブとしてマークされ、"
    },
    {
      "indent": 3,
      "text": "- the destination sequence number is marked as valid,",
      "ja": " - 先のシーケンス番号が有効とマークされ、"
    },
    {
      "indent": 3,
      "text": "- the next hop in the route entry is assigned to be the node from which the RREP is received, which is indicated by the source IP address field in the IP header,",
      "ja": " - ルートエントリの次ホップは、IPヘッダ内の送信元IPアドレスフィールドによって示されるRREPが受信されたノードに割り当てています"
    },
    {
      "indent": 3,
      "text": "- the hop count is set to the value of the New Hop Count,",
      "ja": " - ホップ数は、新しいホップカウントの値に設定されています"
    },
    {
      "indent": 3,
      "text": "- the expiry time is set to the current time plus the value of the Lifetime in the RREP message,",
      "ja": " - 有効期限が、現在時刻プラスRREPメッセージにおける寿命の値に設定されています"
    },
    {
      "indent": 3,
      "text": "- and the destination sequence number is the Destination Sequence Number in the RREP message.",
      "ja": " - と宛先シーケンス番号がRREPメッセージの宛先シーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "The current node can subsequently use this route to forward data packets to the destination.",
      "ja": "現在のノードは、その後、宛先にデータパケットを転送するために、このルートを使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the current node is not the node indicated by the Originator IP Address in the RREP message AND a forward route has been created or updated as described above, the node consults its route table entry for the originating node to determine the next hop for the RREP packet, and then forwards the RREP towards the originator using the information in that route table entry. If a node forwards a RREP over a link that is likely to have errors or be unidirectional, the node SHOULD set the 'A' flag to require that the recipient of the RREP acknowledge receipt of the RREP by sending a RREP-ACK message back (see section 6.8).",
      "ja": "現在のノードが上記のようにRREPメッセージとフォワード経路における発信IPアドレスが示すノードが作成または更新されていない場合、ノードは、RREPのための次のホップを決定するために、発信元ノードのためにそのルートテーブルエントリを参照しますパケット、およびそのルートテーブルエントリの情報を使用して発信元に向けてRREPを転送します。ノードがエラーを持っているか、一方向性である可能性が高いリンクを介してRREPを転送する場合、ノードは、RREPの受信者は、（バックRREP-ACKメッセージを送信することにより、RREPの受信を確認することを要求する「」フラグを設定すべきです）のセクション6.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "When any node transmits a RREP, the precursor list for the corresponding destination node is updated by adding to it the next hop node to which the RREP is forwarded. Also, at each node the (reverse) route used to forward a RREP has its lifetime changed to be the maximum of (existing-lifetime, (current time + ACTIVE_ROUTE_TIMEOUT). Finally, the precursor list for the next hop towards the destination is updated to contain the next hop towards the source.",
      "ja": "任意のノードがRREPを送信すると、対応する宛先ノードのための前駆体のリストは、それにRREPを転送された次ホップノードを追加することによって更新されます。また、各ノードにRREPを転送するために使用される（逆）ルート（既存の寿命を最大になるように変更寿命、（現在時刻+ ACTIVE_ROUTE_TIMEOUTは）。最後に、先に向かって次のホップのための前駆体のリストが更新されていますソースに向けて次のホップが含まれています。"
    },
    {
      "indent": 0,
      "text": "6.8. Operation over Unidirectional Links",
      "section_title": true,
      "ja": "6.8. 単方向リンク上での操作"
    },
    {
      "indent": 3,
      "text": "It is possible that a RREP transmission may fail, especially if the RREQ transmission triggering the RREP occurs over a unidirectional link. If no other RREP generated from the same route discovery attempt reaches the node which originated the RREQ message, the originator will reattempt route discovery after a timeout (see section 6.3). However, the same scenario might well be repeated without any improvement, and no route would be discovered even after repeated retries. Unless corrective action is taken, this can happen even when bidirectional routes between originator and destination do exist. Link layers using broadcast transmissions for the RREQ will not be able to detect the presence of such unidirectional links. In AODV, any node acts on only the first RREQ with the same RREQ ID and ignores any subsequent RREQs. Suppose, for example, that the first",
      "ja": "RREPをトリガーRREQの送信は単方向リンク上で発生した場合は特に、RREP送信が失敗する可能性があります。同じルート発見の試みから生成された他のRREPは、RREQメッセージを発信したノードに到達しない場合、発信者はタイムアウト後に経路発見を再試行します（セクション6.3を参照）。しかし、同じシナリオがうまく任意の改善なしに繰り返されるかもしれない、と何のルートが繰り返しても再試行の後に発見されないであろう。是正措置が取られない限り、これは発信元と宛先の間の双方向のルートが存在しない場合にも発生することがあります。 RREQ用のブロードキャスト伝送を使用して、リンク層は、単方向リンクの存在を検出することができません。 AODVでは、任意のノードが同一のRREQ IDを持つ最初のRREQに作用し、それ以降のRREQを無視します。最初のことを、例えば、仮定"
    },
    {
      "indent": 3,
      "text": "RREQ arrives along a path that has one or more unidirectional link(s). A subsequent RREQ may arrive via a bidirectional path (assuming such paths exist), but it will be ignored.",
      "ja": "RREQは、一つ以上の単方向リンクを持っているの経路に沿って到着しました。後続のRREQは、双方向パス（仮定そのようなパスが存在する）を介して到着することがあり、それは無視されます。"
    },
    {
      "indent": 3,
      "text": "To prevent this problem, when a node detects that its transmission of a RREP message has failed, it remembers the next-hop of the failed RREP in a \"blacklist\" set. Such failures can be detected via the absence of a link-layer or network-layer acknowledgment (e.g., RREP-ACK). A node ignores all RREQs received from any node in its blacklist set. Nodes are removed from the blacklist set after a BLACKLIST_TIMEOUT period (see section 10). This period should be set to the upper bound of the time it takes to perform the allowed number of route request retry attempts as described in section 6.3.",
      "ja": "ノードは、RREPメッセージをその送信が失敗したことを検出すると、この問題を防止するために、それは「ブラックリスト」セットに失敗したRREPのネクストホップを記憶しています。そのような障害は、リンク層またはネットワーク層の応答（例えば、RREP-ACK）の不存在を介して検出することができます。ノードは、そのブラックリストのセット内の任意のノードから受信したすべてのRREQを無視します。ノードはBLACKLIST_TIMEOUT期間後に設定ブラックリストから除去される（セクション10を参照）。この期間は、セクション6.3で説明したようにルート要求の許容数は、再試行の実行にかかる時間の上限を設定すべきです。"
    },
    {
      "indent": 3,
      "text": "Note that the RREP-ACK packet does not contain any information about which RREP it is acknowledging. The time at which the RREP-ACK is received will likely come just after the time when the RREP was sent with the 'A' bit. This information is expected to be sufficient to provide assurance to the sender of the RREP that the link is currently bidirectional, without any real dependence on the particular RREP message being acknowledged. However, that assurance typically cannot be expected to remain in force permanently.",
      "ja": "RREP-ACKパケットが、それは認めているRREPかについてのすべての情報が含まれていないことに注意してください。 RREP-ACKが受信された時刻は、おそらくちょうどRREPは「」ビットで送信された時間の後に来ます。この情報は、リンクが確認されている特定のRREPメッセージ上の任意の実際の依存せず、現在は双方向であることをRREPの送信者に保証を提供するのに十分であると期待されています。しかし、その保証は通常、永久に存続すると期待することはできません。"
    },
    {
      "indent": 0,
      "text": "6.9. Hello Messages",
      "section_title": true,
      "ja": "6.9.  helloメッセージ"
    },
    {
      "indent": 3,
      "text": "A node MAY offer connectivity information by broadcasting local Hello messages. A node SHOULD only use hello messages if it is part of an active route. Every HELLO_INTERVAL milliseconds, the node checks whether it has sent a broadcast (e.g., a RREQ or an appropriate layer 2 message) within the last HELLO_INTERVAL. If it has not, it MAY broadcast a RREP with TTL = 1, called a Hello message, with the RREP message fields set as follows:",
      "ja": "ノードはローカルHelloメッセージをブロードキャストすることにより、接続情報を提供することがあります。それはアクティブな経路の一部である場合、ノードは、ハローメッセージを使用すべきです。それが最後HELLO_INTERVAL内のブロードキャスト（例えば、RREQまたは適切なレイヤ2メッセージ）を送信したかどうかをすべてのHELLO_INTERVALミリ秒、ノードをチェックします。 RREPメッセージが設定されたフィールドを持つ次のようにしていない場合、それはTTL = 1とRREPをブロードキャストしてもよい、Helloメッセージと呼ばれます。"
    },
    {
      "indent": 6,
      "text": "Destination IP Address The node's IP address.",
      "ja": "送信先IPノードのIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Destination Sequence Number The node's latest sequence number.",
      "ja": "宛先シーケンス番号ノードの最新のシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "Hop Count 0",
      "ja": "ホップカウント0"
    },
    {
      "indent": 6,
      "text": "Lifetime ALLOWED_HELLO_LOSS * HELLO_INTERVAL",
      "ja": "生涯ALLOWED_HELLO_LOSS * HELLO_INTERVAL"
    },
    {
      "indent": 3,
      "text": "A node MAY determine connectivity by listening for packets from its set of neighbors. If, within the past DELETE_PERIOD, it has received a Hello message from a neighbor, and then for that neighbor does not receive any packets (Hello messages or otherwise) for more than",
      "ja": "ノードは、隣人のセットからのパケットを受信して​​接続を決定することができます。場合は、過去DELETE_PERIOD以内に、より多くのため（それ以外のHelloメッセージや）それは隣人からHelloメッセージを受信したし、その隣には、任意のパケットを受信しないために"
    },
    {
      "indent": 3,
      "text": "ALLOWED_HELLO_LOSS * HELLO_INTERVAL milliseconds, the node SHOULD assume that the link to this neighbor is currently lost. When this happens, the node SHOULD proceed as in Section 6.11.",
      "ja": "ALLOWED_HELLO_LOSS * HELLO_INTERVALミリ秒は、ノードは、この隣人へのリンクが現在失われていることを前提とすべきです。この場合、ノードは、6.11のように進めるべき。"
    },
    {
      "indent": 3,
      "text": "Whenever a node receives a Hello message from a neighbor, the node SHOULD make sure that it has an active route to the neighbor, and create one if necessary. If a route already exists, then the Lifetime for the route should be increased, if necessary, to be at least ALLOWED_HELLO_LOSS * HELLO_INTERVAL. The route to the neighbor, if it exists, MUST subsequently contain the latest Destination Sequence Number from the Hello message. The current node can now begin using this route to forward data packets. Routes that are created by hello messages and not used by any other active routes will have empty precursor lists and would not trigger a RERR message if the neighbor moves away and a neighbor timeout occurs.",
      "ja": "ノードがネイバーからHelloメッセージを受信するたびに、ノードは、それが隣人にアクティブなルートが設定されていることを確認する必要があり、必要な場合は、1つを作成します。ルートがすでに存在する場合は、必要に応じて、その後、ルートの有効期間は、少なくともALLOWED_HELLO_LOSS * HELLO_INTERVALであることを、増やす必要があります。隣人へのルートは、それが存在する場合は、その後にHelloメッセージから最新のデスティネーションシーケンス番号を含まなければなりません。現在のノードは現在、データ・パケットを転送するために、このルートを使用して開始することができます。他のアクティブなルートで使用されるhelloメッセージによって作成されていないルートは空の前駆物質のリストを持っていますし、隣人が離れると隣人タイムアウトが発生した場合、RERRメッセージをトリガしないでしょう。"
    },
    {
      "indent": 0,
      "text": "6.10. Maintaining Local Connectivity",
      "section_title": true,
      "ja": "6.10. ローカル接続を維持"
    },
    {
      "indent": 3,
      "text": "Each forwarding node SHOULD keep track of its continued connectivity to its active next hops (i.e., which next hops or precursors have forwarded packets to or from the forwarding node during the last ACTIVE_ROUTE_TIMEOUT), as well as neighbors that have transmitted Hello messages during the last (ALLOWED_HELLO_LOSS * HELLO_INTERVAL). A node can maintain accurate information about its continued connectivity to these active next hops, using one or more of the available link or network layer mechanisms, as described below.",
      "ja": "各転送ノードは、最後の時にhelloメッセージを送信したそのアクティブ次（ネクストホップまたはその前駆体が最後ACTIVE_ROUTE_TIMEOUTの間にまたは転送ノードからのパケットを転送しているすなわち、）ホップだけでなく、近隣諸国への継続的な接続性を追跡すべきです（ALLOWED_HELLO_LOSS * HELLO_INTERVAL）。以下に説明するように、ノードは、利用可能なリンクまたはネットワーク層メカニズムの一つまたは複数を用いて、これらの活性のネクストホップへの継続的な接続性についての正確な情報を維持することができます。"
    },
    {
      "indent": 3,
      "text": "- Any suitable link layer notification, such as those provided by IEEE 802.11, can be used to determine connectivity, each time a packet is transmitted to an active next hop. For example, absence of a link layer ACK or failure to get a CTS after sending RTS, even after the maximum number of retransmission attempts, indicates loss of the link to this active next hop.",
      "ja": " - そのようなIEEE 802.11によって提供されるような任意の適切なリンク層通知は、接続性、パケットがアクティブ次のホップに送信されるたびに決定することができます。例えば、リンクレイヤACKあるいは再送の最大試行回数後に、RTSを送信した後にCTSを取得する故障が存在しないことは、このアクティブな次のホップへのリンクの損失を示します。"
    },
    {
      "indent": 3,
      "text": "- If layer-2 notification is not available, passive acknowledgment SHOULD be used when the next hop is expected to forward the packet, by listening to the channel for a transmission attempt made by the next hop. If transmission is not detected within NEXT_HOP_WAIT milliseconds or the next hop is the destination (and thus is not supposed to forward the packet) one of the following methods SHOULD be used to determine connectivity:",
      "ja": " - レイヤ2通知が利用できない場合、次のホップが次のホップ製送信試行のためのチャネルを聞くことによって、パケットを転送することが予想される場合、受動肯定応答が使用されるべきです。送信がNEXT_HOP_WAITミリ秒内に検出またはネクストホップが宛先である（したがって、パケットを転送するために想定されていない）されていない場合、次のいずれかの方法は、接続性を決定するために使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "* Receiving any packet (including a Hello message) from the next hop.",
      "ja": "*次のホップから（Helloメッセージを含む）すべてのパケットを受信しました。"
    },
    {
      "indent": 6,
      "text": "* A RREQ unicast to the next hop, asking for a route to the next hop.",
      "ja": "*次のホップへのルートを求める次のホップへRREQユニキャスト。"
    },
    {
      "indent": 6,
      "text": "* An ICMP Echo Request message unicast to the next hop.",
      "ja": "*次のホップにICMPエコー要求メッセージをユニキャスト。"
    },
    {
      "indent": 3,
      "text": "If a link to the next hop cannot be detected by any of these methods, the forwarding node SHOULD assume that the link is lost, and take corrective action by following the methods specified in Section 6.11.",
      "ja": "次のホップへのリンクは、これらのいずれかの方法で検出することができない場合は、転送ノードは、リンクが失われたと仮定して、セクション6.11で指定された方法に従うことによって是正措置をとるべきです。"
    },
    {
      "indent": 0,
      "text": "6.11. Route Error (RERR) Messages, Route Expiry and Route Deletion",
      "section_title": true,
      "ja": "6.11. 経路エラー（RERR）メッセージ、ルートの有効期限とルートの削除"
    },
    {
      "indent": 3,
      "text": "Generally, route error and link breakage processing requires the following steps:",
      "ja": "一般的には、経路エラーやリンク切れの処理は、次の手順を実行する必要があります"
    },
    {
      "indent": 3,
      "text": "- Invalidating existing routes",
      "ja": " - 既存のルートを無効に"
    },
    {
      "indent": 3,
      "text": "- Listing affected destinations",
      "ja": " - リストの影響を受ける目的地"
    },
    {
      "indent": 3,
      "text": "- Determining which, if any, neighbors may be affected",
      "ja": " - 決定され、もしあれば、隣人が影響を受ける可能性があり"
    },
    {
      "indent": 3,
      "text": "- Delivering an appropriate RERR to such neighbors",
      "ja": " - そのような隣人への適切なRERRを届けます"
    },
    {
      "indent": 3,
      "text": "A Route Error (RERR) message MAY be either broadcast (if there are many precursors), unicast (if there is only 1 precursor), or iteratively unicast to all precursors (if broadcast is inappropriate). Even when the RERR message is iteratively unicast to several precursors, it is considered to be a single control message for the purposes of the description in the text that follows. With that understanding, a node SHOULD NOT generate more than RERR_RATELIMIT RERR messages per second.",
      "ja": "経路エラー（RERR）メッセージは、すべての前駆体（放送が不適切である場合）にユニキャスト、ブロードキャスト（多くの前駆体が存在する場合）、ユニキャスト（1つだけの前駆体が存在する場合）、または反復のいずれであってもよいです。 RERRメッセージは、いくつかの前駆体へのユニキャスト繰り返しであっても、以下のテキストでの説明の目的のための単一の制御メッセージであると考えられます。ことを理解した上で、ノードは、毎秒RERR_RATELIMIT RERRメッセージよりも多くを生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "A node initiates processing for a RERR message in three situations:",
      "ja": "ノードは、3つの状況にRERRメッセージの処理を開始します。"
    },
    {
      "indent": 3,
      "text": "(i) if it detects a link break for the next hop of an active route in its routing table while transmitting data (and route repair, if attempted, was unsuccessful), or",
      "ja": "データ送信中に、そのルーティングテーブル内のアクティブなルートのネクストホップのリンク断を検出した場合（I）（および経路修復を試みた場合、失敗した）、または"
    },
    {
      "indent": 3,
      "text": "(ii) if it gets a data packet destined to a node for which it does not have an active route and is not repairing (if using local repair), or",
      "ja": "（ii）は、それがアクティブなルートを持っていないと（ローカル修復を使用している場合）修復されていないノード宛のデータパケットを取得する場合、または"
    },
    {
      "indent": 3,
      "text": "(iii) if it receives a RERR from a neighbor for one or more active routes.",
      "ja": "（iii）は、それが1つまたは複数のアクティブルートのネイバーからRERRを受信した場合。"
    },
    {
      "indent": 3,
      "text": "For case (i), the node first makes a list of unreachable destinations consisting of the unreachable neighbor and any additional destinations (or subnets, see section 7) in the local routing table that use the unreachable neighbor as the next hop. In this case, if a subnet route is found to be newly unreachable, an IP destination address for the subnet is constructed by appending zeroes to the subnet prefix as shown in the route table entry. This is unambiguous, since the precursor is known to have route table information with a compatible prefix length for that subnet.",
      "ja": "ケース（i）について、ノードが最初に到達できない隣人と任意の追加の宛先からなる到達不能な目的地のリストなるネクストホップとして到達不能隣人を使用するローカルルーティングテーブル内の（またはサブネットを、セクション7を参照）。サブネットルートが新たに到達不能であることがわかっている場合この場合、サブネットのIP宛先アドレスがルートテーブルエントリに示されるようにサブネットプレフィックスにゼロを付加することによって構成されています。前駆体は、そのサブネットの互換性のプレフィックス長を持つルートテーブル情報を有することが知られているので、このことは、明白です。"
    },
    {
      "indent": 3,
      "text": "For case (ii), there is only one unreachable destination, which is the destination of the data packet that cannot be delivered. For case (iii), the list should consist of those destinations in the RERR for which there exists a corresponding entry in the local routing table that has the transmitter of the received RERR as the next hop.",
      "ja": "ケース（ii）のために、配信できないデータ・パケットの宛先である唯一の到達不能宛先があります。ケース（iii）のために、リストが次のホップとして受信RERRの送信機を有するローカルルーティングテーブル内の対応するエントリが存在するためにRERRのそれらの宛先で構成すべきです。"
    },
    {
      "indent": 3,
      "text": "Some of the unreachable destinations in the list could be used by neighboring nodes, and it may therefore be necessary to send a (new) RERR. The RERR should contain those destinations that are part of the created list of unreachable destinations and have a non-empty precursor list.",
      "ja": "リスト中の到達不能目的地の一部は隣接ノードで使用することができ、それゆえ（新しい）RERRを送信する必要があるかもしれません。 RERRは到達不能宛先の作成したリストの一部であり、非空の前駆体のリストを持っているそれらの宛先を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The neighboring node(s) that should receive the RERR are all those that belong to a precursor list of at least one of the unreachable destination(s) in the newly created RERR. In case there is only one unique neighbor that needs to receive the RERR, the RERR SHOULD be unicast toward that neighbor. Otherwise the RERR is typically sent to the local broadcast address (Destination IP == 255.255.255.255, TTL == 1) with the unreachable destinations, and their corresponding destination sequence numbers, included in the packet. The DestCount field of the RERR packet indicates the number of unreachable destinations included in the packet.",
      "ja": "RERRを受信する隣接ノード（単数または複数）は、新しく作成されたRERRに到達できない宛先（複数可）の少なくとも一つの前駆リストに属するすべてのものです。 RERRを受信する必要がある唯一のユニークな隣人があった場合には、RERRはその隣人に向かってユニキャストされるべきである（SHOULD）。そうでなければRERRは、典型的には、到達不能な目的地、及びパケットに含まれるそれらの対応する宛先シーケンス番号とローカルブロードキャストアドレス（宛先IP == 255.255.255.255、TTL == 1）に送られます。 RERRパケットのDestCountフィールドが到達不能宛先の数は、パケットに含まを示しています。"
    },
    {
      "indent": 3,
      "text": "Just before transmitting the RERR, certain updates are made on the routing table that may affect the destination sequence numbers for the unreachable destinations. For each one of these destinations, the corresponding routing table entry is updated as follows:",
      "ja": "ただ、RERRを送信する前に、特定の更新プログラムは到達不能の送信先の宛先シーケンス番号に影響を与える可能性があり、ルーティングテーブルの上に作られています。次のようにこれらの宛先のそれぞれについて、対応するルーティングテーブルエントリが更新されます。"
    },
    {
      "indent": 3,
      "text": "1. The destination sequence number of this routing entry, if it exists and is valid, is incremented for cases (i) and (ii) above, and copied from the incoming RERR in case (iii) above.",
      "ja": "それが存在し、有効であれば1.このルーティングエントリの宛先シーケンス番号は、ケース（i）および（ii）上記、および（iii）上記の場合、着信RERRからコピーするためにインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "2. The entry is invalidated by marking the route entry as invalid",
      "ja": "2.エントリは無効としてルートエントリをマークすることによって無効化されます"
    },
    {
      "indent": 3,
      "text": "3. The Lifetime field is updated to current time plus DELETE_PERIOD. Before this time, the entry SHOULD NOT be deleted.",
      "ja": "3. Lifetimeフィールドは、現在の時刻プラスDELETE_PERIODに更新されます。この時間の前に、エントリを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "Note that the Lifetime field in the routing table plays dual role -- for an active route it is the expiry time, and for an invalid route it is the deletion time. If a data packet is received for an invalid route, the Lifetime field is updated to current time plus DELETE_PERIOD. The determination of DELETE_PERIOD is discussed in Section 10.",
      "ja": "アクティブなルートのためには、有効期限で、無効なルートのためには、削除時間である - ルーティングテーブルのLifetimeフィールドは、二重の役割を果たしていることに注意してください。データパケットが無効なルートのために受信された場合、寿命フィールドは、現在の時刻プラスDELETE_PERIODに更新されます。 DELETE_PERIODの決意は、セクション10で説明されています。"
    },
    {
      "indent": 0,
      "text": "6.12. Local Repair",
      "section_title": true,
      "ja": "6.12. 現地修理"
    },
    {
      "indent": 3,
      "text": "When a link break in an active route occurs, the node upstream of that break MAY choose to repair the link locally if the destination was no farther than MAX_REPAIR_TTL hops away. To repair the link break, the node increments the sequence number for the destination and then broadcasts a RREQ for that destination. The TTL of the RREQ should initially be set to the following value:",
      "ja": "アクティブなルートでリンクブレークが発生すると、そのブレークの上流ノードは、先がまったく遠くMAX_REPAIR_TTLが離れホップよりも、なかった場合は、ローカルリンクを修復することを選択するかもしれません。リンクブレークを修復するには、ノードが送信先のシーケンス番号をインクリメントし、その宛先に対するRREQをブロードキャストします。 RREQのTTLは、最初に次の値に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "max(MIN_REPAIR_TTL, 0.5 * #hops) + LOCAL_ADD_TTL,",
      "ja": "MAX（MIN_REPAIR_TTL、0.5 * #hops）+ LOCAL_ADD_TTL、"
    },
    {
      "indent": 3,
      "text": "where #hops is the number of hops to the sender (originator) of the currently undeliverable packet. Thus, local repair attempts will often be invisible to the originating node, and will always have TTL >= MIN_REPAIR_TTL + LOCAL_ADD_TTL. The node initiating the repair then waits the discovery period to receive RREPs in response to the RREQ. During local repair data packets SHOULD be buffered. If, at the end of the discovery period, the repairing node has not received a RREP (or other control message creating or updating the route) for that destination, it proceeds as described in Section 6.11 by transmitting a RERR message for that destination.",
      "ja": "ここ#hops現在配信不能パケットの送信元（発信元）までのホップ数です。このように、地元の修理試みは、多くの場合、発信ノードには見えないだろう、と常にTTL> = MIN_REPAIR_TTL + LOCAL_ADD_TTLを持つことになります。修復を開始するノードはRREQに応答したRREPを受信するためのディスカバリ期間を待機します。ローカルリペアデータ中にパケットがバッファリングされるべきである（SHOULD）。ディスカバリ期間の終わりに、修復ノードは、その宛先の（ルートを作成または更新または他の制御メッセージ）RREPを受信して​​いない、場合にその宛先のRERRメッセージを送信することによって、セクション6.11に記載されているように、それが進行します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, if the node receives one or more RREPs (or other control message creating or updating the route to the desired destination) during the discovery period, it first compares the hop count of the new route with the value in the hop count field of the invalid route table entry for that destination. If the hop count of the newly determined route to the destination is greater than the hop count of the previously known route the node SHOULD issue a RERR message for the destination, with the 'N' bit set. Then it proceeds as described in Section 6.7, updating its route table entry for that destination.",
      "ja": "ノードは、1つ以上たRREP（または所望の目的地へのルートを作成または更新他の制御メッセージ）ディスカバリ期間中に受信する一方、それは最初のホップ数の値を使用して新しいルートのホップ数を比較しますその先に無効なルートテーブルエントリのフィールド。目的地までの新たに決定された経路のホップ数が既知の経路のホップカウントよりも大きい場合、ノードは、「N」ビットセットで、送信先のRERRメッセージを発行すべきです。セクション6.7で説明したように、それは、その宛先のためにそのルートテーブルエントリを更新し、進みます。"
    },
    {
      "indent": 3,
      "text": "A node that receives a RERR message with the 'N' flag set MUST NOT delete the route to that destination. The only action taken should be the retransmission of the message, if the RERR arrived from the next hop along that route, and if there are one or more precursor nodes for that route to the destination. When the originating node receives a RERR message with the 'N' flag set, if this message came from its next hop along its route to the destination then the originating node MAY choose to reinitiate route discovery, as described in Section 6.3.",
      "ja": "「N」フラグを設定してRERRメッセージを受信するノードは、その目的地へのルートを削除してはいけません。 RERRがその経路に沿った次のホップから到着した場合、宛先へのルートのための1つ以上の前駆体ノードがある場合に取らのみアクションは、メッセージの再送信であるべきです。発信元ノードが「N」フラグが設定されたRERRメッセージを受信すると、このメッセージが宛先への経路に沿って次のホップから来た場合、発信元ノードは、セクション6.3で説明したように、ルート発見を再開することを選ぶかもしれ。"
    },
    {
      "indent": 3,
      "text": "Local repair of link breaks in routes sometimes results in increased path lengths to those destinations. Repairing the link locally is likely to increase the number of data packets that are able to be delivered to the destinations, since data packets will not be dropped as the RERR travels to the originating node. Sending a RERR to the originating node after locally repairing the link break may allow the originator to find a fresh route to the destination that is better, based on current node positions. However, it does not require the originating node to rebuild the route, as the originator may be done, or nearly done, with the data session.",
      "ja": "ルート内のリンク切断のローカル修理は時々それらの宛先に増加し、パスの長さになります。ローカルリンクを修復するRERRが発信ノードに移動するデータパケットがドロップされないので、宛先に配信されることが可能であるデータパケットの数を増加させる可能性があります。ローカルリンクブレークを修復した後、元のノードにRERRを送信すると、発信者が現在のノードの位置に基づいて、優れている目的地への新鮮なルートを見つけることを可能にします。発信が行われ、またはほぼ行われ、データ・セッションとすることができるようにしかし、それは、経路を再構築する発信ノードを必要としません。"
    },
    {
      "indent": 3,
      "text": "When a link breaks along an active route, there are often multiple\ndestinations that become unreachable.  The node that is upstream of\nthe lost link tries an immediate local repair for only the one\ndestination towards which the data packet was traveling.  Other\nroutes using the same link MUST be marked as invalid, but the node\nhandling the local repair MAY flag each such newly lost route as\nlocally repairable; this local repair flag in the route table MUST be\nreset when the route times out (e.g., after the route has been not\nbeen active for ACTIVE_ROUTE_TIMEOUT).  Before the timeout occurs,\nthese other routes will be repaired as needed when packets arrive for\nthe other destinations.  Hence, these routes are repaired as needed;\nif a data packet does not arrive for the route, then that route will\nnot be repaired.  Alternatively, depending upon local congestion, the\nnode MAY begin the process of establishing local repairs for the\nother routes, without waiting for new packets to arrive.  By\nproactively repairing the routes that have broken due to the loss of\nthe link, incoming data packets for those routes will not be subject\nto the delay of repairing the route and can be immediately forwarded.\nHowever, repairing the route before a data packet is received for it\nruns the risk of repairing routes that are no longer in use.\nTherefore, depending upon the local traffic in the network and\nwhether congestion is being experienced, the node MAY elect to\nproactively repair the routes before a data packet is received;\notherwise, it can wait until a data is received, and then commence\nthe repair of the route.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.13. Actions After Reboot",
      "section_title": true,
      "ja": "6.13. 再起動後にアクション"
    },
    {
      "indent": 3,
      "text": "A node participating in the ad hoc network must take certain actions after reboot as it might lose all sequence number records for all destinations, including its own sequence number. However, there may be neighboring nodes that are using this node as an active next hop. This can potentially create routing loops. To prevent this possibility, each node on reboot waits for DELETE_PERIOD before transmitting any route discovery messages. If the node receives a RREQ, RREP, or RERR control packet, it SHOULD create route entries as appropriate given the sequence number information in the control packets, but MUST not forward any control packets. If the node receives a data packet for some other destination, it SHOULD broadcast a RERR as described in subsection 6.11 and MUST reset the waiting timer to expire after current time plus DELETE_PERIOD.",
      "ja": "それは、独自のシーケンス番号を含むすべての宛先のためのすべてのシーケンス番号のレコードを失うかもしれないとして、アドホックネットワークに参加するノードは、再起動後に特定のアクションを取る必要があります。しかし、アクティブ次ホップとしてこのノードを使用している隣接ノードが存在してもよいです。これは、潜在的なルーティングループを作成することができます。この可能性を防止するために、再起動時に各ノードは、任意の経路発見メッセージを送信する前にDELETE_PERIOD待ちます。ノードがRREQ、RREP、又はRERR制御パケットを受信した場合、それは適切な制御パケットのシーケンス番号の情報を与えられるようにルートエントリを作成する必要はなく、任意の制御パケットを転送してはいけません。ノードが他の宛先にデータパケットを受信した場合、それはサブセクション6.11で説明したようにRERRを放送すべきであり、現在の時刻プラスDELETE_PERIOD後に期限切れを待っているタイマーをリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "It can be shown [4] that by the time the rebooted node comes out of the waiting phase and becomes an active router again, none of its neighbors will be using it as an active next hop any more. Its own sequence number gets updated once it receives a RREQ from any other node, as the RREQ always carries the maximum destination sequence number seen en route. If no such RREQ arrives, the node MUST initialize its own sequence number to zero.",
      "ja": "時間によって再起動ノードが次それ以上ホップ待機相から出て再びアクティブルータになり、その隣人のどれもアクティブとしてそれを使用しないことを[4]に示すことができます。 RREQは、常に途中で見られる最大宛先シーケンス番号を運ぶように、それは、他のノードからRREQを受信すると、自身のシーケンス番号が更新されます。そのようなRREQが到着しない場合、ノードは、ゼロに独自のシーケンス番号を初期化しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.14. Interfaces",
      "section_title": true,
      "ja": "6.14. インタフェース"
    },
    {
      "indent": 3,
      "text": "Because AODV should operate smoothly over wired, as well as wireless, networks, and because it is likely that AODV will also be used with multiple wireless devices, the particular interface over which packets arrive must be known to AODV whenever a packet is received. This includes the reception of RREQ, RREP, and RERR messages. Whenever a packet is received from a new neighbor, the interface on which that packet was received is recorded into the route table entry for that neighbor, along with all the other appropriate routing information. Similarly, whenever a route to a new destination is learned, the interface through which the destination can be reached is also recorded into the destination's route table entry.",
      "ja": "AODVは、有線、ならびに無線、ネットワーク上で円滑に動作しなければならない、そしてそれはAODVはまた、複数の無線デバイスに使用される可能性があるので、パケットが到着その上、特定のインタフェースがパケットを受信するたびにAODVすることが知られなければならないからです。これはRREQ、RREP、RERRおよびメッセージの受信を含んでいます。パケットが新規ネイバーから受信されるたびに、そのパケットを受信したインタフェースは、そのネイバーのためのルートテーブルエントリに記録されたすべての他の適切なルーティング情報と一緒にされています。新たな目的地へのルートを学習するときはいつでも同様に、宛先に到達するためのインターフェイスはまた、先のルートテーブルエントリに記録されます。"
    },
    {
      "indent": 3,
      "text": "When multiple interfaces are available, a node retransmitting a RREQ message rebroadcasts that message on all interfaces that have been configured for operation in the ad-hoc network, except those on which it is known that all of the nodes neighbors have already received the RREQ For instance, for some broadcast media (e.g., Ethernet) it may be presumed that all nodes on the same link receive a broadcast message at the same time. When a node needs to transmit a RERR, it SHOULD only transmit it on those interfaces that have neighboring precursor nodes for that route.",
      "ja": "複数のインタフェースが利用可能である場合、RREQメッセージを再送信するノードは、ノードのすべてのネイバーが既にためRREQを受信したことが知られたものを除いて、アドホックネットワークで動作するように構成されているすべてのインタフェース上でそのメッセージを再ブロードキャストインスタンスは、いくつかの放送メディア（例えば、イーサネット）のためには、同じリンク上のすべてのノードが同時にブロードキャストメッセージを受け取ることが推測されます。ノードは、RERRを送信する必要がある場合、それだけで、そのルートのための前駆体ノードに隣接しているこれらのインターフェイス上で送信すべきです。"
    },
    {
      "indent": 0,
      "text": "7. AODV and Aggregated Networks",
      "section_title": true,
      "ja": "7. AODVと集約ネットワーク"
    },
    {
      "indent": 3,
      "text": "AODV has been designed for use by mobile nodes with IP addresses that are not necessarily related to each other, to create an ad hoc network. However, in some cases a collection of mobile nodes MAY operate in a fixed relationship to each other and share a common subnet prefix, moving together within an area where an ad hoc network has formed. Call such a collection of nodes a \"subnet\". In this case, it is possible for a single node within the subnet to advertise reachability for all other nodes on the subnet, by responding with a RREP message to any RREQ message requesting a route to any node with the subnet routing prefix. Call the single node the \"subnet router\". In order for a subnet router to operate the AODV protocol for the whole subnet, it has to maintain a destination sequence number for the entire subnet. In any such RREP message sent by the subnet router, the Prefix Size field of the RREP message MUST be set to the length of the subnet prefix. Other nodes sharing the subnet prefix SHOULD NOT issue RREP messages, and SHOULD forward RREQ messages to the subnet router.",
      "ja": "AODVは、アドホックネットワークを作成するには、必ずしも相互に関連していないIPアドレスを持つモバイルノードによって使用するために設計されています。しかし、いくつかのケースでは、モバイルノードの集合は、アドホックネットワークが形成された領域内で一緒に移動する、相互に固定された関係で動作し、共通のサブネットプレフィックスを共有することができます。ノード「サブネット」のようにコレクションを呼び出します。サブネット内の単一のノードがサブネットルーティングプレフィックスを持つ任意のノードへの経路を要求する任意のRREQメッセージに対するRREPメッセージで応答することにより、サブネット上の他のすべてのノードの到達可能性をアドバタイズするため、この場合には、可能です。 「サブネットルータ」単一のノードを呼び出します。全サブネットのAODVプロトコルを動作させるためのサブネットルータのためには、サブネット全体の宛先シーケンス番号を維持しなければなりません。サブネット・ルータによって送信された任意のこのようなRREPメッセージに、RREPメッセージのプレフィックスサイズフィールドは、サブネットプレフィックスの長さに設定しなければなりません。サブネットプレフィックスを共有する他のノードはRREPメッセージを発行するべきではありません、とサブネットルータにRREQメッセージを転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "The processing for RREPs that give routes to subnets (i.e., have nonzero prefix length) is the same as processing for host-specific RREP messages. Every node that receives the RREP with prefix size information SHOULD create or update the route table entry for the subnet, including the sequence number supplied by the subnet router, and including the appropriate precursor information. Then, in the future the node can use the information to avoid sending future RREQs for other nodes on the same subnet.",
      "ja": "サブネットへのルートを与えたRREP処理（すなわち、非ゼロプレフィックス長を有する）ホスト固有のRREPメッセージの処理と同様です。プレフィックスサイズ情報とRREPを受信するすべてのノードが作成または更新サブネット・ルータによって供給されたシーケンス番号を含むサブネットのルートテーブルエントリを、適切な前駆情報を含むべきです。その後、将来のノードは、同じサブネット上の他のノードのための将来のRREQを送信することを避けるために情報を使用することができます。"
    },
    {
      "indent": 3,
      "text": "When a node uses a subnet route it may be that a packet is routed to an IP address on the subnet that is not assigned to any existing node in the ad hoc network. When that happens, the subnet router MUST return ICMP Host Unreachable message to the sending node. Upstream nodes receiving such an ICMP message SHOULD record the information that the particular IP address is unreachable, but MUST NOT invalidate the route entry for any matching subnet prefix.",
      "ja": "ノードはサブネットルートを使用する場合には、パケットは、アドホックネットワーク内の既存のノードに割り当てられていないサブネット上のIPアドレスにルーティングされている可能性があります。これが発生すると、サブネットルータは、送信ノードにICMPホスト到達不能メッセージを返さなければなりません。このようなICMPメッセージを受信した上流ノードは、特定のIPアドレスが到達不能である旨の情報を記録する必要がありますが、任意の一致するサブネット・プレフィックスのルートエントリを無効にしてはいけません。"
    },
    {
      "indent": 3,
      "text": "If several nodes in the subnet advertise reachability to the subnet defined by the subnet prefix, the node with the lowest IP address is elected to be the subnet router, and all other nodes MUST stop advertising reachability.",
      "ja": "サブネット内の複数のノードがサブネットプレフィックスにより定義されたサブネットに到達可能性をアドバタイズする場合、最小のIPアドレスを持つノードは、サブネットルータであることを選択され、そして他のすべてのノードは、広告到達可能性を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "The behavior of default routes (i.e., routes with routing prefix length 0) is not defined in this specification. Selection of routes sharing prefix bits should be according to longest match first.",
      "ja": "デフォルトルート（ルーティングプレフィックス長が0の、すなわち、ルート）の動作は、本明細書に定義されていません。プレフィックスビットを共有するルートの選択は、最初の最長一致に記載されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. Using AODV with Other Networks",
      "section_title": true,
      "ja": "8.他のネットワークとAODVを使用します"
    },
    {
      "indent": 3,
      "text": "In some configurations, an ad hoc network may be able to provide connectivity between external routing domains that do not use AODV. If the points of contact to the other networks can act as subnet routers (see Section 7) for any relevant networks within the external routing domains, then the ad hoc network can maintain connectivity to the external routing domains. Indeed, the external routing networks can use the ad hoc network defined by AODV as a transit network.",
      "ja": "いくつかの構成では、アドホックネットワークは、AODVを使用しない外部のルーティングドメイン間の接続を提供することができます。他のネットワークへの接触点がサブネット・ルータとして働くことができるならば、アドホックネットワークは、外部ルーティングドメインへの接続を維持することができ、外部のルーティングドメイン内の任意の関連ネットワークのため（セクション7参照）。確かに、外部ルーティングネットワークは、トランジットネットワークとしてAODVによって定義されたアドホックネットワークを使用することができます。"
    },
    {
      "indent": 3,
      "text": "In order to provide this feature, a point of contact to an external network (call it an Infrastructure Router) has to act as the subnet router for every subnet of interest within the external network for which the Infrastructure Router can provide reachability. This includes the need for maintaining a destination sequence number for that external subnet.",
      "ja": "この機能を提供するために、外部ネットワークへの接触のポイントは、（インフラストラクチャルータそれを呼び出す）インフラルータが到達可能性を提供することができるため、外部ネットワーク内の関心のすべてのサブネットのサブネットルータとして動作することがあります。これは、外部のサブネットの宛先シーケンス番号を維持する必要性を含んでいます。"
    },
    {
      "indent": 3,
      "text": "If multiple Infrastructure Routers offer reachability to the same external subnet, those Infrastructure Routers have to cooperate (by means outside the scope of this specification) to provide consistent AODV semantics for ad hoc access to those subnets.",
      "ja": "複数のインフラストラクチャのルータが同じ外部サブネットに到達可能性を提供する場合、これらのインフラストラクチャルータは、これらのサブネットへのアドホックアクセスするために一貫性のあるAODVセマンティクスを提供するために、（この仕様の範囲外の手段によって）協力しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Extensions",
      "section_title": true,
      "ja": "9.拡張機能"
    },
    {
      "indent": 3,
      "text": "In this section, the format of extensions to the RREQ and RREP messages is specified. All such extensions appear after the message data, and have the following format:",
      "ja": "このセクションでは、RREQの拡張とRREPメッセージのフォーマットが指定されています。すべてのそのような拡張は、メッセージデータの後に表示され、次の形式を持っています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | type-specific data ... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ|長さ|タイプ固有のデータ... +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  + -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "Type 1-255",
      "ja": "タイプ1から255"
    },
    {
      "indent": 3,
      "text": "Length The length of the type-specific data, not including the Type and Length fields of the extension in bytes.",
      "ja": "長さをバイト単位で拡張のタイプと長さフィールドを含まないタイプ固有のデータの長さ。"
    },
    {
      "indent": 3,
      "text": "Extensions with types between 128 and 255 may NOT be skipped. The rules for extensions will be spelled out more fully, and conform to the rules for handling IPv6 options.",
      "ja": "128と255の間のタイプの拡張機能はスキップされないことがあります。拡張のためのルールは、より完全に綴られ、およびIPv6オプションを処理するための規則に準拠します。"
    },
    {
      "indent": 0,
      "text": "9.1. Hello Interval Extension Format",
      "section_title": true,
      "ja": "9.1. ハロー間隔拡張フォーマット"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | Hello Interval ... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | ... Hello Interval, continued | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - + |タイプ|長さ|ハロー間隔... | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | ...こんにちは間隔、継続的な| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "Type 1",
      "ja": "タイプ1"
    },
    {
      "indent": 3,
      "text": "Length 4",
      "ja": "長さ4"
    },
    {
      "indent": 3,
      "text": "Hello Interval The number of milliseconds between successive transmissions of a Hello message.",
      "ja": "ハロー間隔Helloメッセージの連続送信間のミリ秒数。"
    },
    {
      "indent": 3,
      "text": "The Hello Interval extension MAY be appended to a RREP message with TTL == 1, to be used by a neighboring receiver in determine how long to wait for subsequent such RREP messages (i.e., Hello messages; see section 6.9).",
      "ja": "ハロー間隔延長は、TTL == 1とRREPメッセージに付加することができるで後続のようなRREPメッセージを待機する時間の長さを決定隣接受信機によって使用される（すなわち、ハローメッセージ、セクション6.9を参照します）。"
    },
    {
      "indent": 0,
      "text": "10. Configuration Parameters",
      "section_title": true,
      "ja": "10.設定パラメータ"
    },
    {
      "indent": 3,
      "text": "This section gives default values for some important parameters associated with AODV protocol operations. A particular mobile node may wish to change certain of the parameters, in particular the NET_DIAMETER, MY_ROUTE_TIMEOUT, ALLOWED_HELLO_LOSS, RREQ_RETRIES, and possibly the HELLO_INTERVAL. In the latter case, the node should advertise the HELLO_INTERVAL in its Hello messages, by appending a Hello Interval Extension to the RREP message. Choice of these parameters may affect the performance of the protocol. Changing NODE_TRAVERSAL_TIME also changes the node's estimate of the NET_TRAVERSAL_TIME, and so can only be done with suitable knowledge about the behavior of other nodes in the ad hoc network. The configured value for MY_ROUTE_TIMEOUT MUST be at least 2 * PATH_DISCOVERY_TIME.",
      "ja": "このセクションでは、AODVプロトコル操作に関連したいくつかの重要なパラメータのデフォルト値を示します。特定のモバイルノードは、特に、NET_DIAMETER、MY_ROUTE_TIMEOUT、ALLOWED_HELLO_LOSS、RREQ_RETRIES、そしておそらくHELLO_INTERVALのパラメータのいくつかを変更することを望むかもしれません。後者の場合、ノードは、RREPメッセージにハロー間隔拡張を追加することによって、そのHelloメッセージにHELLO_INTERVALをアドバタイズすべきです。これらのパラメータの選択は、プロトコルのパフォーマンスに影響を与える可能性があります。 NODE_TRAVERSAL_TIMEを変更すると、NET_TRAVERSAL_TIMEのノードの推定値を変更し、これだけアドホックネットワーク内の他のノードの動作について、適切な知識を持って行うことができます。 MY_ROUTE_TIMEOUTの構成値は、少なくとも2 * PATH_DISCOVERY_TIMEなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameter Name           Value\n----------------------   -----\nACTIVE_ROUTE_TIMEOUT     3,000 Milliseconds\nALLOWED_HELLO_LOSS       2\nBLACKLIST_TIMEOUT        RREQ_RETRIES * NET_TRAVERSAL_TIME\nDELETE_PERIOD            see note below\nHELLO_INTERVAL           1,000 Milliseconds\nLOCAL_ADD_TTL            2\nMAX_REPAIR_TTL           0.3 * NET_DIAMETER\nMIN_REPAIR_TTL           see note below\nMY_ROUTE_TIMEOUT         2 * ACTIVE_ROUTE_TIMEOUT\nNET_DIAMETER             35\nNET_TRAVERSAL_TIME       2 * NODE_TRAVERSAL_TIME * NET_DIAMETER\nNEXT_HOP_WAIT            NODE_TRAVERSAL_TIME + 10\nNODE_TRAVERSAL_TIME      40 milliseconds\nPATH_DISCOVERY_TIME      2 * NET_TRAVERSAL_TIME\nRERR_RATELIMIT           10\nRING_TRAVERSAL_TIME      2 * NODE_TRAVERSAL_TIME *\n                         (TTL_VALUE + TIMEOUT_BUFFER)\nRREQ_RETRIES             2\nRREQ_RATELIMIT           10\nTIMEOUT_BUFFER           2\nTTL_START                1\nTTL_INCREMENT            2\nTTL_THRESHOLD            7\nTTL_VALUE                see note below",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MIN_REPAIR_TTL should be the last known hop count to the destination. If Hello messages are used, then the ACTIVE_ROUTE_TIMEOUT parameter value MUST be more than the value (ALLOWED_HELLO_LOSS * HELLO_INTERVAL). For a given ACTIVE_ROUTE_TIMEOUT value, this may require some adjustment to the value of the HELLO_INTERVAL, and consequently use of the Hello Interval Extension in the Hello messages.",
      "ja": "MIN_REPAIR_TTLは、目的地への最後の既知のホップ数でなければなりません。 Helloメッセージが使用されている場合は、ACTIVE_ROUTE_TIMEOUTパラメータ値は、値（ALLOWED_HELLO_LOSS * HELLO_INTERVAL）よりも多くなければなりません。与えられたACTIVE_ROUTE_TIMEOUT値については、これはHELLO_INTERVALの値にはいくつかの調整が必要な場合があり、その結果、Helloメッセージにハロー間隔延長の使用します。"
    },
    {
      "indent": 3,
      "text": "TTL_VALUE is the value of the TTL field in the IP header while the expanding ring search is being performed. This is described further in section 6.4. The TIMEOUT_BUFFER is configurable. Its purpose is to provide a buffer for the timeout so that if the RREP is delayed due to congestion, a timeout is less likely to occur while the RREP is still en route back to the source. To omit this buffer, set TIMEOUT_BUFFER = 0.",
      "ja": "拡張リング検索が行われている間TTL_VALUEは、IPヘッダ内のTTLフィールドの値です。これは、6.4節でさらに説明されます。 TIMEOUT_BUFFERは設定可能です。その目的は、RREPが輻輳による遅延した場合、タイムアウトがRREPバックソースへの途中である間に発生しにくくなるようにタイムアウトのバッファを提供することです。このバッファを省略するために、TIMEOUT_BUFFER = 0を設定します。"
    },
    {
      "indent": 3,
      "text": "DELETE_PERIOD is intended to provide an upper bound on the time for which an upstream node A can have a neighbor B as an active next hop for destination D, while B has invalidated the route to D. Beyond this time B can delete the (already invalidated) route to D. The determination of the upper bound depends somewhat on the characteristics of the underlying link layer. If Hello messages are used to determine the continued availability of links to next hop nodes, DELETE_PERIOD must be at least ALLOWED_HELLO_LOSS * HELLO_INTERVAL. If the link layer feedback is used to detect loss of link, DELETE_PERIOD must be at least ACTIVE_ROUTE_TIMEOUT. If hello messages are received from a neighbor but data packets to that neighbor are lost (e.g., due to temporary link asymmetry), we have to make more concrete assumptions about the underlying link layer. We assume that such asymmetry cannot persist beyond a certain time, say, a multiple K of HELLO_INTERVAL. In other words, a node will invariably receive at least one out of K subsequent Hello messages from a neighbor if the link is working and the neighbor is sending no other traffic. Covering all possibilities,",
      "ja": "Bは、（既に無効に削除することができ、この時間Bを超えD.へのルートを無効にしていながらDELETE_PERIODは、上流ノードAが宛先Dのための活性ネクストホップとして隣接Bを有することができる時間の上限を提供することを意図していますD.への）経路が上限の決意は、基礎となるリンク層の特性に多少依存します。 Helloメッセージは次のホップノードへのリンクの継続的な可用性を決定するために使用されている場合は、DELETE_PERIODは少なくともALLOWED_HELLO_LOSS * HELLO_INTERVALでなければなりません。リンクレイヤフィードバックは、リンクの損失を検出するために使用されている場合は、DELETE_PERIODは、少なくともACTIVE_ROUTE_TIMEOUTでなければなりません。 helloメッセージは、（例えば、一時的なリンクの非対称性）が失われ、その隣に隣接するが、データパケットから受信している場合、我々は、基礎となるリンク層についてのより具体的な仮定をしなければなりません。私たちは、このような非対称性は、HELLO_INTERVALの複数のKを、一定時間を超えて持続すると言うことができないことを前提としています。リンクが動作していると隣人は他のトラフィックを送信していない場合は、他の言葉では、ノードは常に隣人からK以降のHelloメッセージのうち少なくとも一つを受け取ることになります。あらゆる可能性をカバーし、"
    },
    {
      "indent": 6,
      "text": "DELETE_PERIOD = K * max (ACTIVE_ROUTE_TIMEOUT, HELLO_INTERVAL) (K = 5 is recommended).",
      "ja": "DELETE_PERIOD = Kの*最大（ACTIVE_ROUTE_TIMEOUT、HELLO_INTERVAL）（K = 5が推奨されます）。"
    },
    {
      "indent": 3,
      "text": "NET_DIAMETER measures the maximum possible number of hops between two nodes in the network. NODE_TRAVERSAL_TIME is a conservative estimate of the average one hop traversal time for packets and should include queuing delays, interrupt processing times and transfer times. ACTIVE_ROUTE_TIMEOUT SHOULD be set to a longer value (at least 10,000 milliseconds) if link-layer indications are used to detect link breakages such as in IEEE 802.11 [5] standard. TTL_START should be set to at least 2 if Hello messages are used for local connectivity information. Performance of the AODV protocol is sensitive to the chosen values of these constants, which often depend on the characteristics of the underlying link layer protocol, radio technologies etc. BLACKLIST_TIMEOUT should be suitably increased if an expanding ring search is used. In such cases, it should be {[(TTL_THRESHOLD - TTL_START)/TTL_INCREMENT] + 1 + RREQ_RETRIES} * NET_TRAVERSAL_TIME. This is to account for possible additional route discovery attempts.",
      "ja": "NET_DIAMETERは、ネットワーク内の2つのノード間のホップの最大数を測定します。 NODE_TRAVERSAL_TIMEは、パケットの平均1つのホップトラバーサル時間の控えめな見積もりであり、キューイング遅延、割込み処理時間と転送時間を含むべきです。 ACTIVE_ROUTE_TIMEOUTは、リンク層の指標は、例えばIEEE 802.11 [5]標準とリンク切れを検出するために使用される場合、より長い値（少なくとも10,000ミリ秒）に設定されるべきです。 Helloメッセージは、ローカル接続情報に使用されている場合TTL_STARTは、少なくとも2に設定する必要があります。 AODVプロトコルの性能はしばしば下層のリンク層プロトコルの特性に依存するこれらの定数の選択された値に敏感である拡張リング検索が使用される場合、無線技術等BLACKLIST_TIMEOUTを好適に増加させるべきです。 * NET_TRAVERSAL_TIME  - このような場合には、{+ 1 + RREQ_RETRIES [（TTL_START TTL_THRESHOLD）/ TTL_INCREMENT]}であるべきです。これは、可能な追加ルート発見の試みを考慮するためです。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Currently, AODV does not specify any special security measures. Route protocols, however, are prime targets for impersonation attacks. In networks where the node membership is not known, it is difficult to determine the occurrence of impersonation attacks, and security prevention techniques are difficult at best. However, when the network membership is known and there is a danger of such attacks, AODV control messages must be protected by use of authentication techniques, such as those involving generation of unforgeable and cryptographically strong message digests or digital signatures. While AODV does not place restrictions on the authentication mechanism used for this purpose, IPsec AH is an appropriate choice for cases where the nodes share an appropriate security association that enables the use of AH.",
      "ja": "現在、AODVは、特別なセキュリティ対策を指定していません。ルートプロトコルは、しかし、なりすまし攻撃のための主要な標的です。ノードのメンバーシップが知られていないネットワークでは、なりすまし攻撃の発生を決定することは困難である、およびセキュリティの防止技術は、最高の状態で困難です。ネットワークメンバーシップが知られており、このような攻撃の危険性があるとされている場合しかし、AODV制御メッセージは、偽造や暗号強いメッセージダイジェスト又はデジタル署名の生成に関与するものなどの認証技術の使用によって保護されなければなりません。 AODVは、この目的のために使用される認証メカニズムに制限を課すものではないが、IPsecのAHは、ノードがAHの使用を可能に適切なセキュリティアソシエーションを共有する場合に適した選択肢です。"
    },
    {
      "indent": 3,
      "text": "In particular, RREP messages SHOULD be authenticated to avoid creation of spurious routes to a desired destination. Otherwise, an attacker could masquerade as the desired destination, and maliciously deny service to the destination and/or maliciously inspect and consume traffic intended for delivery to the destination. RERR messages, while less dangerous, SHOULD be authenticated in order to prevent malicious nodes from disrupting valid routes between nodes that are communication partners.",
      "ja": "具体的には、RREPメッセージは、所望の目的地へのスプリアスの経路の生成を回避するために認証されるべきです。そうでなければ、攻撃者が所望の目的地になりすますことができ、及び悪意宛先へのサービスを拒否および/または悪意を持って検査し、宛先への配信のために意図されたトラフィックを消費します。 RERRメッセージは、危険の少ないながら、通信相手のノード間で有効なルートを中断することから悪意のあるノードを防ぐために認証されるべきです。"
    },
    {
      "indent": 3,
      "text": "AODV does not make any assumption about the method by which addresses are assigned to the mobile nodes, except that they are presumed to have unique IP addresses. Therefore, no special consideration, other than what is natural because of the general protocol specifications, can be made about the applicability of IPsec authentication headers or key exchange mechanisms. However, if the mobile nodes in the ad hoc network have pre-established security associations, it is presumed that the purposes for which the security associations are created include that of authorizing the processing of AODV control messages. Given this understanding, the mobile nodes should be able to use the same authentication mechanisms based on their IP addresses as they would have used otherwise.",
      "ja": "AODVは、アドレスが、彼らは固有のIPアドレスを持っていると推定されていることを除いて、モバイルノードに割り当てされる方法についての仮定を行いません。したがって、なぜなら一般的なプロトコル仕様の自然のあるもの以外に特別な配慮は、IPsec認証ヘッダや鍵交換メカニズムの適用性について行うことができません。アドホックネットワークにおけるモバイルノードが事前に確立されたセキュリティ関連を持っている場合は、セキュリティアソシエーションが作成される目的は、AODVコントロールメッセージの処理を許可することが含まれると推測されます。この理解を考えると、モバイルノードは、彼らがそうでない場合は使用していたとして、そのIPアドレスに基づいて、同じ認証メカニズムを使用することができるはずです。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "AODV defines a \"Type\" field for messages sent to port 654. A new registry has been created for the values for this Type field, and the following values have been assigned:",
      "ja": "AODVは、ポート654新しいレジストリは、このタイプのフィールドの値のために作成されたに送信されたメッセージを、「Type」フィールドを定義し、以下の値が割り当てられています："
    },
    {
      "indent": 6,
      "text": "Message Type                    Value\n---------------------------     -----\nRoute Request (RREQ)            1\nRoute Reply (RREP)              2\nRoute Error (RERR)              3\nRoute-Reply Ack (RREP-ACK)      4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AODV control messages can have extensions. Currently, only one extension is defined. A new registry has been created for the Type field of the extensions:",
      "ja": "AODV制御メッセージは、拡張子を持つことができます。現在、唯一の拡張が定義されています。新しいレジストリは、拡張子のTypeフィールドのために作成されています。"
    },
    {
      "indent": 6,
      "text": "Extension Type                  Value\n---------------------------     -----\nHello Interval                  1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Future values of the Message Type or Extension Type can be allocated using standards action [2].",
      "ja": "メッセージタイプまたは拡張タイプの将来の値は標準アクションを使用して割り当てることができる[2]。"
    },
    {
      "indent": 0,
      "text": "13. IPv6 Considerations",
      "section_title": true,
      "ja": "13. IPv6の上の考慮事項"
    },
    {
      "indent": 3,
      "text": "See [6] for detailed operation for IPv6. The only changes to the protocol are that the address fields are enlarged.",
      "ja": "IPv6の詳細な動作のために[6]参照。プロトコルへの唯一の変更は、アドレスフィールドが拡大していることです。"
    },
    {
      "indent": 0,
      "text": "14. Acknowledgments",
      "section_title": true,
      "ja": "14.謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks to Ian Chakeres, UCSB, for his extensive suggestions and contributions to recent revisions.",
      "ja": "彼の豊富な提案や、最近の改正への貢献のためのイアンChakeres、UCSB、に感謝します。"
    },
    {
      "indent": 3,
      "text": "We acknowledge with gratitude the work done at University of Pennsylvania within Carl Gunter's group, as well as at Stanford and CMU, to determine some conditions (especially involving reboots and lost RERRs) under which previous versions of AODV could suffer from routing loops. Contributors to those efforts include Karthikeyan Bhargavan, Joshua Broch, Dave Maltz, Madanlal Musuvathi, and Davor Obradovic. The idea of a DELETE_PERIOD, for which expired routes (and, in particular, the sequence numbers) to a particular destination must be maintained, was also suggested by them.",
      "ja": "私たちは、AODVの以前のバージョンでは、ルーティングのループに苦しむ可能性があり、その下（特に再起動し、失われたRERRsを含む）いくつかの条件を決定するために、感謝の気持ちでスタンフォード大学とCMUのカール・ギュンターのグループ内のペンシルバニア大学で行われた仕事だけでなく、を認めます。これらの努力への寄与はカーティケヤンBhargavan、ジョシュアブロッホ、デイブ・モルツ、Madanlal Musuvathi、およびDavor Obradovicが含まれます。特定の宛先へのルートを有効期限が切れているためDELETE_PERIODの思想、（及び、特に、シーケンス番号）が維持されなければならない、またそれらによって示唆されました。"
    },
    {
      "indent": 3,
      "text": "We also acknowledge the comments and improvements suggested by Sung-Ju Lee (especially regarding local repair), Mahesh Marina, Erik Nordstrom (who provided text for section 6.11), Yves Prelot, Marc Mosko, Manel Guerrero Zapata, Philippe Jacquet, and Fred Baker.",
      "ja": "また、（特に地元の修理について）スン・チュリーによって提案された意見や改善を認め、マヘシュマリーナ、（セクション6.11のためのテキストを提供）エリック・ノードストローム、イヴPrelot、マルク・Mosko、マネルゲレロサパタ、フィリップジャケ、およびフレッド・ベイカー。"
    },
    {
      "indent": 0,
      "text": "15. Normative References",
      "section_title": true,
      "ja": "15.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S. \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーの、S. \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[2] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[2] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 0,
      "text": "16. Informative References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 3,
      "text": "[3] Manner, J., et al., \"Mobility Related Terminology\", Work in Progress, July 2001.",
      "ja": "[3]のようにして、J.ら、 \"モビリティ関連用語\"、進歩、2001年7月ワーク。"
    },
    {
      "indent": 3,
      "text": "[4] Karthikeyan Bhargavan, Carl A. Gunter, and Davor Obradovic. Fault Origin Adjudication. In Proceedings of the Workshop on Formal Methods in Software Practice, Portland, OR, August 2000.",
      "ja": "[4]カーティケヤンBhargavan、カールA.ギュンター、及びDavor Obradovic。起源裁決フォールト。ソフトウェアの実践、オレゴン州ポートランド、2000年8月形式手法に関するワークショップの議事録。"
    },
    {
      "indent": 3,
      "text": "[5] IEEE 802.11 Committee, AlphaGraphics #35, 10201 N.35th Avenue, Phoenix AZ 85051. Wireless LAN Medium Access Control MAC and Physical Layer PHY Specifications, June 1997. IEEE Standard 802.11-97.",
      "ja": "[5] IEEE 802.11委員会、AlphaGraphicsの＃35、10201 N.35thアベニュー、フェニックスAZ 85051.無線LAN媒体アクセス制御MACおよび物理層PHYの仕様、1997年6月IEEE規格802.​​11から97。"
    },
    {
      "indent": 3,
      "text": "[6] Perkins, C., Royer, E. and S. Das, \"Ad hoc on demand distance vector (AODV) routing for ip version 6\", Work in Progress.",
      "ja": "[6]パーキンス、C.、ロイヤー、E.およびS.ダス、 \"アドホックオンデマンド距離ベクトル（AODV）IPバージョン6のルーティングの\" 進行中で働いています。"
    },
    {
      "indent": 0,
      "text": "17. Authors' Addresses",
      "section_title": true,
      "ja": "17.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Charles E. Perkins Communications Systems Laboratory Nokia Research Center 313 Fairchild Drive Mountain View, CA 94303 USA",
      "ja": "チャールズE.パーキンス通信システム研究所ノキア・リサーチセンター313フェアチャイルドドライブマウンテンビュー、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 625 2986 Fax: +1 650 691 2170 (fax) EMail: Charles.Perkins@nokia.com",
      "ja": "電話：+1 650 625 2986ファックス：+1 650 691 2170（FAX）メール：Charles.Perkins@nokia.com"
    },
    {
      "indent": 3,
      "text": "Elizabeth M. Belding-Royer Department of Computer Science University of California, Santa Barbara Santa Barbara, CA 93106",
      "ja": "カリフォルニアのコンピュータサイエンス大学、サンタバーバラ、CA 93106のエリザベス・M.ベルディング・ロイヤー部門"
    },
    {
      "indent": 3,
      "text": "Phone: +1 805 893 3411 Fax: +1 805 893 8553 EMail: ebelding@cs.ucsb.edu",
      "ja": "電話：+1 805 893 3411ファックス：+1 805 893 8553 Eメール：ebelding@cs.ucsb.edu"
    },
    {
      "indent": 3,
      "text": "Samir R. Das Department of Electrical and Computer Engineering & Computer Science University of Cincinnati Cincinnati, OH 45221-0030",
      "ja": "電気のサミールR.ダス部門とシンシナティのコンピュータエンジニアリング＆コンピュータサイエンス大学、OH 45221-0030"
    },
    {
      "indent": 3,
      "text": "Phone: +1 513 556 2594 Fax: +1 513 556 7326 EMail: sdas@ececs.uc.edu",
      "ja": "電話：+1 513 556 2594ファックス：+1 513 556 7326 Eメール：sdas@ececs.uc.edu"
    },
    {
      "indent": 0,
      "text": "18. Full Copyright Statement",
      "section_title": true,
      "ja": "18.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}