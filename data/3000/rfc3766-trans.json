{
  "title": {
    "text": "RFC 3766 - Determining Strengths For Public Keys Used For Exchanging Symmetric Keys",
    "ja": "RFC 3766 - 対称鍵を交換するために使用公開鍵の決定強み"
  },
  "number": 3766,
  "created_at": "2019-10-22 05:26:32.050936+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           H. Orman\nRequest for Comments: 3766                            Purple Streak Dev.\nBCP: 86                                                       P. Hoffman\nCategory: Best Current Practice                           VPN Consortium\n                                                              April 2004",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Determining Strengths For Public Keys Used\n      For Exchanging Symmetric Keys",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントはインターネットコミュニティのためのインターネットBest Current Practicesを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2004）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Implementors of systems that use public key cryptography to exchange symmetric keys need to make the public keys resistant to some predetermined level of attack. That level of attack resistance is the strength of the system, and the symmetric keys that are exchanged must be at least as strong as the system strength requirements. The three quantities, system strength, symmetric key strength, and public key strength, must be consistently matched for any network protocol usage.",
      "ja": "対称鍵を交換するために、公開鍵暗号方式を使用するシステムの実装者は、攻撃のいくつかの所定のレベルに公開鍵が耐性にする必要があります。攻撃性のレベルは、システムの強さであり、そして交換される対称鍵は、システム強度要件と少なくとも同程度に強くなければなりません。 3つの量、システムの強さ、対称鍵強度、及び公開鍵強度は、一貫して、任意のネットワークプロトコルの使用のために一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "While it is fairly easy to express the system strength requirements in terms of a symmetric key length and to choose a cipher that has a key length equal to or exceeding that requirement, it is harder to choose a public key that has a cryptographic strength meeting a symmetric key strength requirement. This document explains how to determine the length of an asymmetric key as a function of a symmetric key strength requirement. Some rules of thumb for estimating equivalent resistance to large-scale attacks on various algorithms are given. The document also addresses how changing the sizes of the underlying large integers (moduli, group sizes, exponents, and so on) changes the time to use the algorithms for key exchange.",
      "ja": "それは対称鍵の長さの点でシステム強度要件を発現し、またはその要件を超えて同じ鍵長を持つ暗号を選択することはかなり容易であるが、暗号強度会議Aを有し、公開鍵を選択することが困難です対称鍵強度要件。この文書では、対称鍵強度要件の関数として非対称鍵の長さを決定する方法について説明します。様々なアルゴリズム上の大規模な攻撃に等価抵抗を推定するための親指のいくつかのルールが与えられています。文書はまた、根底にある大きな整数（モジュラス、グループサイズ、指数など）のサイズを変更すると鍵交換のためのアルゴリズムを使用するための時間をどのように変化するか対応しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Model of Protecting Symmetric Keys with Public Keys. . . . . .  2\n    1.1. The key exchange algorithms . . . . . . . . . . . . . . .  4\n2.  Determining the Effort to Factor . . . . . . . . . . . . . . .  5\n    2.1. Choosing parameters for the equation. . . . . . . . . . .  6\n    2.2. Choosing k from empirical reports . . . . . . . . . . . .  7\n    2.3. Pollard's rho method. . . . . . . . . . . . . . . . . . .  7\n    2.4. Limits of large memory and many machines. . . . . . . . .  8\n    2.5. Special purpose machines. . . . . . . . . . . . . . . . .  9\n3.  Compute Time for the Algorithms. . . . . . . . . . . . . . . . 10\n    3.1. Diffie-Hellman Key Exchange . . . . . . . . . . . . . . . 10\n         3.1.1. Diffie-Hellman with elliptic curve groups. . . . . 11\n    3.2. RSA encryption and decryption . . . . . . . . . . . . . . 11\n    3.3. Real-world examples . . . . . . . . . . . . . . . . . . . 12\n4.  Equivalences of Key Sizes. . . . . . . . . . . . . . . . . . . 13\n    4.1. Key equivalence against special purpose brute force\n         hardware. . . . . . . . . . . . . . . . . . . . . . . . . 15\n    4.2. Key equivalence against conventional CPU brute force\n         attack. . . . . . . . . . . . . . . . . . . . . . . . . . 15\n    4.3. A One Year Attack: 80 bits of strength. . . . . . . . . . 16\n    4.4. Key equivalence for other ciphers . . . . . . . . . . . . 16\n    4.5. Hash functions for deriving symmetric keys from public\n         key algorithms. . . . . . . . . . . . . . . . . . . . . . 17\n    4.6. Importance of randomness. . . . . . . . . . . . . . . . . 19\n5.  Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n    5.1. TWIRL Correction. . . . . . . . . . . . . . . . . . . . . 20\n6.  Security Considerations. . . . . . . . . . . . . . . . . . . . 20\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n    7.1. Informational References. . . . . . . . . . . . . . . . . 20\n8.  Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 22\n9.  Full Copyright Statement . . . . . . . . . . . . . . . . . . . 23",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Model of Protecting Symmetric Keys with Public Keys",
      "section_title": true,
      "ja": "公開鍵と対称鍵の保護の1モデル"
    },
    {
      "indent": 3,
      "text": "Many books on cryptography and security explain the need to exchange symmetric keys in public as well as the many algorithms that are used for this purpose. However, few of these discussions explain how the strengths of the public keys and the symmetric keys are related.",
      "ja": "暗号とセキュリティに関する多くの書籍が公共の場で、対称鍵だけでなく、この目的のために使用される多くのアルゴリズムを交換する必要性を説明します。しかし、これらの議論のいくつかは、公開鍵と対称鍵の強みが関連している方法について説明します。"
    },
    {
      "indent": 3,
      "text": "To understand this, picture a house with a strong lock on the front door. Next to the front door is a small lockbox that contains the key to the front door. A would-be burglar who wants to break into the house through the front door has two options: attack the lock on the front door, or attack the lock on the lockbox in order to retrieve the key. Clearly, the burglar is better off attacking the weaker of the two locks. The homeowner in this situation must make sure that adding the second entry option (the lockbox containing the front door key) is at least as strong as the lock on the front door, in order not to make the burglar's job easier.",
      "ja": "これを理解するために、フロントドアに強いロックと一緒に家を描きます。フロントドアの隣には、フロントドアの鍵が含まれている小さなロックボックスです。フロントドアのロックを攻撃し、またはキーを取得するために、ロックボックスのロックを攻撃：フロントドアから家に侵入しようと-だろう泥棒は2つのオプションがあります。明らかに、泥棒は2つのロックの弱いを攻撃したほうが良いです。このような状況で住宅所有者は、強盗の仕事を楽にさせないために、2番目のエントリオプション（フロントドアの鍵を含むロックボックス）を追加すると、フロントドアのロックと少なくとも同じ強力であることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementor designing a system for exchanging symmetric keys using public key cryptography must make a similar decision. Assume that an attacker wants to learn the contents of a message that is encrypted with a symmetric key, and that the symmetric key was exchanged between the sender and recipient using public key cryptography. The attacker has two options to recover the message: a brute-force attempt to determine the symmetric key by repeated guessing, or mathematical determination of the private key used as the key exchange key. A smart attacker will work on the easier of these two problems.",
      "ja": "同様の決定を下す必要があり、公開鍵暗号を使用して対称鍵を交換するためのシステムを設計、実装。攻撃者は、対称鍵で暗号化されたメッセージの内容を学びたいと仮定し、対称鍵は、公開鍵暗号を使用して、送信者と受信者の間で交換されたこと。繰り返し推測によって対称鍵、または鍵交換鍵として使用される秘密鍵の数学的決意を決定するためにブルートフォース試行：攻撃者は、メッセージを復元するための2つのオプションを有しています。スマート攻撃者は、この2つの問題をより簡単に動作します。"
    },
    {
      "indent": 3,
      "text": "A simple-minded answer to the implementor's problem is to be sure that the key exchange system is always significantly stronger than the symmetric key; this can be done by choosing a very long public key. Such a design is usually not a good idea because the key exchanges become much more expensive in terms of processing time as the length of the public keys go up. Thus, the implementor is faced with the task of trying to match the difficulty of an attack on the symmetric key with the difficulty of an attack on the public key encryption. This analysis is not necessary if the key exchange can be performed with extreme security for almost no cost in terms of elapsed time or CPU effort; unfortunately, this is not the case for public key methods today.",
      "ja": "実装の問題にシンプル志向の答えは、鍵交換システムは常に対称鍵よりもかなり強力であることを確認することです。これは非常に長い公開鍵を選択することによって行うことができます。公開鍵の長さが上がるように、キー交換が、処理時間の面ではるかに高価になるため、このような設計は、通常は良いアイデアではありません。したがって、実装者は、公開鍵暗号への攻撃の難易度と対称鍵への攻撃の難易度に合うようにしようとする課題に直面しています。鍵交換は、経過時間やCPUの労力の面でほとんどコストのために、極端なセキュリティを行うことができる場合は、この分析は必要ありません。残念ながら、これは今日の公開鍵方法の場合はそうではありません。"
    },
    {
      "indent": 3,
      "text": "A third consideration is the minimum security requirement of the user. Assume the user is encrypting with CAST-128 and requires a symmetric key with a resistance time against brute-force attack of 20 years. He might start off by choosing a key with 86 random bits, and then use a one-way function such as SHA-1 to \"boost\" that to a block of 160 bits, and then take 128 of those bits as the key for CAST-128. In such a case, the key exchange algorithm need only match the difficulty of 86 bits, not 128 bits.",
      "ja": "第三の考慮事項は、使用者の最低限のセキュリティ要件です。ユーザーがCAST-128で暗号化し、20年のブルートフォース攻撃に対する耐性時間の対称鍵を必要とされるものとします。彼は、86個のランダムビットの鍵を選択することから始め、その後、160ビットのブロックへの「ブースト」にそのようなSHA-1のように一方向関数を使用し、次いでCASTのキーとしてこれらのビットの128を取るかもしれません-128。このような場合には、鍵交換アルゴリズムは、86ビットではなく、128ビットの難しさに一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "The selection procedure is:",
      "ja": "選択手順は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Determine the attack resistance necessary to satisfy the security requirements of the application. Do this by estimating the minimum number of computer operations that the attacker will be forced to do in order to compromise the security of the system and then take the logarithm base two of that number. Call that logarithm value \"n\".",
      "ja": "1.アプリケーションのセキュリティ要件を満たすために必要な攻撃耐性を決定します。攻撃者がシステムのセキュリティを侵害し、その数の対数の底2を取るために行うことを余儀なくされることを、コンピュータ操作の最小数を推定することによってこれを行います。その対数値「n」を呼び出します。"
    },
    {
      "indent": 6,
      "text": "A 1996 report recommended 90 bits as a good all-around choice for system security. The 90 bit number should be increased by about 2/3 bit/year, or about 96 bits in 2005.",
      "ja": "1996年報告書では、システムのセキュリティのための良好なオールラウンドな選択肢として90ビットをお勧めします。 90ビット数は2005年に96ビットの約2/3ビット/年の増加、又は約されるべきです。"
    },
    {
      "indent": 3,
      "text": "2. Choose a symmetric cipher that has a key with at least n bits and at least that much cryptanalytic strength.",
      "ja": "前記少なくともNビットと、少なくともそれだけ暗号解読強度を有する鍵を有する対称暗号を選択します。"
    },
    {
      "indent": 3,
      "text": "3. Choose a key exchange algorithm with a resistance to attack of at least n bits.",
      "ja": "前記少なくともNビットの攻撃に対する耐性を持つ鍵交換アルゴリズムを選択します。"
    },
    {
      "indent": 3,
      "text": "A fourth consideration might be the public key authentication method used to establish the identity of a user. This might be an RSA digital signature or a DSA digital signature. If the modulus for the authentication method isn't large enough, then the entire basis for trusting the communication might fall apart. The following step is thus added:",
      "ja": "第四対価は、ユーザのアイデンティティを確立するために使用される公開鍵認証方式であるかもしれません。これは、RSAデジタル署名やDSAデジタル署名かもしれません。認証方法のための係数の大きさが十分でない場合は、通信を信頼するための全体の基礎はバラバラになるかもしれません。次のステップは、このように添加されます。"
    },
    {
      "indent": 3,
      "text": "4. Choose an authentication algorithm with a resistance to attack of at least n bits. This ensures that a similar key exchanged cannot be forged between the two parties during the secrecy lifetime of the encrypted material. This may not be strictly necessary if the authentication keys are changed frequently and they have a well-understood usage lifetime, but in lieu of this, the n bit guidance is sound.",
      "ja": "前記少なくともNビットの攻撃に対する耐性を持つ認証アルゴリズムを選択します。これは、交換と同様のキーは暗号化された材料の秘密の寿命の間に2者間鍛造することができないことを保証します。認証キーが頻繁に変更され、それらが十分に理解の使用寿命を持っているが、これの代わりに、n個のビットガイダンスが健全である場合、これは厳密には必要ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "1.1. The key exchange algorithms",
      "section_title": true,
      "ja": "1.1。鍵交換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman method uses a group, a generator, and exponents. In today's Internet standards, the group operation is based on modular multiplication. Here, the group is defined by the multiplicative group of an integer, typically a prime p = 2q + 1, where q is a prime, and the arithmetic is done modulo p; the generator (which is often simply 2) is denoted by g.",
      "ja": "ディフィー・ヘルマン法は基、発電機、および指数を使用します。今日のインターネット標準では、グループ操作が剰余乗算に基づいています。ここで、グループは、qは素数である整数の乗法群、典型的には、素数p = 2Q + 1によって定義され、演算は、pを法として行われます。ジェネレータは、（しばしば単に2である）、Gで示されています。"
    },
    {
      "indent": 3,
      "text": "In Diffie-Hellman, Alice and Bob first agree (in public or in private) on the values for g and p. Alice chooses a secret large random integer (a), and Bob chooses a secret random large integer (b). Alice sends Bob A, which is g^a mod p; Bob sends Alice B, which is g^b mod p. Next, Alice computes B^a mod p, and Bob computes A^b mod p. These two numbers are equal, and the participants use a simple function of this number as the symmetric key k.",
      "ja": "ディフィー・ヘルマン、アリスとボブでは、第一グラムとpの値に（パブリックまたはプライベートに）同意します。アリスは、（a）は、秘密の大きなランダム整数を選択し、ボブは秘密ランダム大きな整数を選択する（B）。アリスはgであるボブA、^ P MODを送信します。ボブは、G ^ B MOD pはアリスBを送信します。次に、アリスは、B ^のmod Pを計算し、ボブは、A ^ Bのmod Pを計算します。これら二つの数は等しく、参加者は、対称鍵kと、この数の単純な関数を使用します。"
    },
    {
      "indent": 3,
      "text": "Note that Diffie-Hellman key exchange can be done over different kinds of group representations. For instance, elliptic curves defined over finite fields are a particularly efficient way to compute the key exchange [SCH95].",
      "ja": "Diffie-Hellman鍵交換は群の表現の異なる種類にわたって行うことができることに留意されたいです。例えば、有限体上で定義される楕円曲線は、鍵交換[SCH95]を計算する特に効率的な方法です。"
    },
    {
      "indent": 3,
      "text": "For RSA key exchange, assume that Bob has a public key (m) which is equal to p*q, where p and q are two secret prime numbers, and an encryption exponent e, and a decryption exponent d. For the key exchange, Alice sends Bob E = k^e mod m, where k is the secret symmetric key being exchanged. Bob recovers k by computing E^d mod m, and the two parties use k as their symmetric key. While Bob's encryption exponent e can be quite small (e.g., 17 bits), his decryption exponent d will have as many bits in it as m does.",
      "ja": "RSA鍵交換のために、ボブは、pおよびqは2つの秘密素数であるP *は、Q、および暗号化指数e、復号指数dに等しい公開鍵（m）を有すると仮定する。鍵交換のために、アリスは、kが交換される秘密対称鍵であるボブE = K ^ E MOD M、送信します。ボブはE ^ Dのmod Mを計算することによってKを回復し、両当事者は、それらの対称鍵としてKを使用します。ボブの暗号化指数eは、（例えば、17ビット）非常に小さくなることができますが、彼の復号指数dは、mはないとして、それにできるだけ多くのビットを持っています。"
    },
    {
      "indent": 0,
      "text": "2. Determining the Effort to Factor",
      "section_title": true,
      "ja": "2.ファクターへの取り組みを決定"
    },
    {
      "indent": 3,
      "text": "The RSA public key encryption method is immune to brute force guessing attacks because the modulus (and thus, the secret exponent d) will have at least 512 bits, and that is too many possibilities to guess. The Diffie-Hellman exchange is also secure against guessing because the exponents will have at least twice as many bits as the symmetric keys that will be derived from them. However, both methods are susceptible to mathematical attacks that determine the structure of the public keys.",
      "ja": "弾性係数（したがって、秘密指数d）は、少なくとも512ビットを持つことになりますので、RSA公開鍵暗号方式は、ブルートフォース推測攻撃に免疫がある、それは推測する、あまりにも多くの可能性です。 Diffie-Hellman交換も指数がそれらに由来します対称鍵として、少なくとも2倍の数のビットを持つことになりますので、推測に対して安全です。しかし、両方の方法は、公開鍵の構造を決定する数学的な攻撃を受けやすいです。"
    },
    {
      "indent": 3,
      "text": "Factoring an RSA modulus will result in complete compromise of the security of the private key. Solving the discrete logarithm problem for a Diffie-Hellman modular exponentiation system will similarly destroy the security of all key exchanges using the particular modulus. This document assumes that the difficulty of solving the discrete logarithm problem is equivalent to the difficulty of factoring numbers that are the same size as the modulus. In fact, it is slightly harder because it requires more operations; based on empirical evidence so far, the ratio of difficulty is at least 20, possibly as high as 64. Solving either problem requires a great deal of memory for the last stage of the algorithm, the matrix reduction step. Whether or not this memory requirement will continue to be the limiting factor in solving larger integer problems remains to be seen. At the current time it is not, and there is active research into parallel matrix algorithms that might mitigate the memory requirements for this problem.",
      "ja": "RSAモジュラスを因数分解することは、秘密鍵のセキュリティを完全に妥協になります。ディフィー・ヘルマンべき乗剰余系のための離散対数問題を解くことは、同様に特定の係数を使用して、すべてのキー交換のセキュリティを破壊します。この文書では、離散対数問題の困難性は、モジュラスと同じ大きさの数字を因数分解することの難しさと同等であることを前提としています。それはより多くの操作を必要とするため、実際には、それは少し難しいです。これまでの実証的証拠に基づいて、難易度の割合は、問題のいずれかを解決するアルゴリズム、行列還元工程の最終段階のために大量のメモリを必要とする可能性の高い64として、少なくとも20です。このメモリ要件は、より大きな整数の問題を解決するための制限要因であり続けるかどうかは見守らなければなりません。現在の時点ではそうではありませんし、この問題のためのメモリ要件を緩和する可能性がある並列行列アルゴリズムへの活発な研究があります。"
    },
    {
      "indent": 3,
      "text": "The number field sieve (NFS) [GOR93] [LEN93] is the best method today for solving the discrete logarithm problem. The formula for estimating the number of simple arithmetic operations needed to factor an integer, n, using the NFS method is:",
      "ja": "数体ふるい（NFS）は、[GOR93] [LEN93]の離散対数問題を解決するための最良の方法今日です。整数を因数分解するのに必要な単純な算術演算の数を推定し、nは、NFSの方法を使用するための式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "L(n) = k * e^((1.92 + o(1)) * cubrt(ln(n) * (ln(ln(n)))^2))",
      "ja": "L（N）= k個* E ^（（1.92 + O（1））* cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "Many people prefer to discuss the number of MIPS years (MYs) that are needed for large operations such as the number field sieve. For such an estimation, an operation in the L(n) formula is one computer instruction. Empirical evidence indicates that 4 or 5 instructions might be a closer match, but this is a minor factor and this document sticks with one operation/one instruction for this discussion.",
      "ja": "多くの人々は、このような数体ふるいとして大規模な操作のために必要とされるMIPS年（MYS）の数を議論することを好みます。このような推定のために、L（n）の式の動作は、1つのコンピュータ命令です。実証的証拠は4つのまたは5命令がより近いマッチであるかもしれないことを示しているが、これはマイナーな要因であり、この文書では、一回の操作/この議論のための1つの命令でスティック。"
    },
    {
      "indent": 0,
      "text": "2.1. Choosing parameters for the equation",
      "section_title": true,
      "ja": "2.1。方程式のパラメータを選択します"
    },
    {
      "indent": 3,
      "text": "The expression above has two parameters that can be estimated by empirical means: k and o(1). For the range of numbers we are interested in, there is little distinction between them.",
      "ja": "KとO（1）上記の式は経験的な手段によって推定することができる2つのパラメータを有しています。我々が興味を持っている番号の範囲については、それらの間にはほとんど区別があります。"
    },
    {
      "indent": 3,
      "text": "One could assume that k is 1 and o(1) is 0. This is reasonably valid if the expression is only used for estimating relative effort (instead of actual effort) and one assumes that the o(1) term is very small over the range of the numbers that are to be factored.",
      "ja": "一つは、Kをとる可能性が1とO（1）0の発現のみ相対的努力を推定するために使用される場合、これは（代わりに実際の作業の）合理的に有効であり、1つはO（1）という用語は、上非常に小さいと仮定されます因数分解される数値の範囲。"
    },
    {
      "indent": 3,
      "text": "Or, one could assume that o(1) is small and roughly constant and thus its value can be folded into k; then estimate k from reported amounts of effort spent factoring large integers in tests.",
      "ja": "または、一つはoは（1）小さく、ほぼ一定であるので、その値がKに折り畳むことができると想定できました。その後、テストで大きな整数を因数分解費やした努力の報告金額からKを推定します。"
    },
    {
      "indent": 3,
      "text": "This document uses the second approach in order to get an estimate of the significance of the factor. It appears to be minor, based on the following calculations.",
      "ja": "この文書では、要因の重要性の推定値を得るために第二のアプローチを使用しています。次の計算に基づいて、マイナーなように見えます。"
    },
    {
      "indent": 3,
      "text": "Sample values from recent work with the number field sieve include:",
      "ja": "数体ふるいと最近の研究からのサンプル値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Test name Number of Number of MYs of effort decimal bits digits RSA130 130 430 500 RSA140 140 460 2000 RSA155 155 512 8000 RSA160 160 528 3000",
      "ja": "努力小数ビット桁RSA130のMYSの数130 430 500 140 460 2000 RSA140 RSA155 155 512 8000 160 528 3000 RSA160のテスト名の数"
    },
    {
      "indent": 3,
      "text": "There are few precise measurements of the amount of time used for these factorizations. In most factorization tests, hundreds or thousands of computers are used over a period of several months, but the number of their cycles were used for the factoring project, the precise distribution of processor types, speeds, and so on are not usually reported. However, in all the above cases, the amount of effort used was far less than the L(n) formula would predict if k was 1 and o(1) was 0.",
      "ja": "これらの因数分解のために使用される時間の量のいくつかの正確な測定があります。ほとんどの因数分解試験では、コンピュータの数百または数千には、数ヶ月の期間にわたって使用されているが、そのサイクル数は、ファクタリング事業、プロセッサの種類、速度の正確な分布のために使用された、というように、通常は報告されません。 kが1であり、oは、（1）0であった場合は、上記のすべての場合において、使用される労力の量は予測するL（n）の式よりもはるかに少なかったです。"
    },
    {
      "indent": 3,
      "text": "A similar estimate of effort, done in 1995, is in [ODL95].",
      "ja": "1995年に行わ努力の同様の推定値は、[ODL95]です。"
    },
    {
      "indent": 3,
      "text": "Results indicating that for the Number Field Sieve factoring method, the actual number of operations is less than expected, are found in [DL].",
      "ja": "ナンバーフィールドふるいファクタリング方法のため、操作の実際の数が予想よりも小さいことを示す結果は、[DL]に見出されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Choosing k from empirical reports",
      "section_title": true,
      "ja": "2.2。経験的なレポートからk個を選びます"
    },
    {
      "indent": 3,
      "text": "By solving for k from the empirical reports, it appears that k is approximately 0.02. This means that the \"effective key strength\" of the RSA algorithm is about 5 or 6 bits less than is implied by the naive application of equation L(n) (that is, setting k to 1 and o(1) to 0). These estimates of k are fairly stable over the numbers reported in the table. The estimate is limited to a single significant digit of k because it expresses real uncertainties; however, the effect of additional digits would have make only tiny changes to the recommended key sizes.",
      "ja": "経験的なレポートからのkについて解くことで、kは約0.02であることが表示されます。これは、（すなわち、0に1とO（1）にKを設定し、である）RSAアルゴリズムの「実効キー強度」は、式L（N）のナイーブアプリケーションによって暗示されるよりも約5または6ビット以下であることを意味します。 kのこれらの推定値は表に報告された数値に対してかなり安定しています。それが本当の不確実性を表現するため、推定値は、k個の単一上位桁に制限されています。しかし、追加の数字の影響は推奨鍵のサイズのみに小さな変更を加える必要があります。"
    },
    {
      "indent": 3,
      "text": "The factorers of RSA130 used about 1700 MYs, but they felt that this was unrealistically high for prediction purposes; by using more memory on their machines, they could have easily reduced the time to 500 MYs. Thus, the value used in preparing the table above was 500. This story does, however, underscore the difficulty in getting an accurate measure of effort. This document takes the reported effort for factoring RSA155 as being the most accurate measure.",
      "ja": "RSA130のfactorersは約1700 MYSを使用し、彼らは、これは、予測の目的のために非現実的に高いと感じました。自分のマシン上でより多くのメモリを使用することによって、彼らは簡単に500 MYSまでの時間が減少している可能性があります。このように、テーブルの作成に使用される値は、上記の500は、この物語は、しかし、努力の正確な測定を得ることの難しさを強調んでした。この文書では、最も正確な尺度であるとしてRSA155を因数分解するための報告手間がかかります。"
    },
    {
      "indent": 3,
      "text": "As a result of examining the empirical data, it appears that the L(n) formula can be used with the o(1) term set to 0 and with k set to 0.02 when talking about factoring numbers in the range of 100 to 200 decimal digits. The equation becomes:",
      "ja": "実験データを調べた結果、L（n）は、式が0と100小数200の範囲の数を因数分解について話すとき、0.02に設定し、K（1）用語セットOを使用することができると思われます数字。式は次のようになります。"
    },
    {
      "indent": 6,
      "text": "L(n) = 0.02 * e^(1.92 * cubrt(ln(n) * (ln(ln(n)))^2))",
      "ja": "L（N）= 0.02 * E ^（1.92 * cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "To convert L(n) from simple math instructions to MYs, divide by 3*10^13. The equation for the number of MYs needed to factor an integer n then reduces to:",
      "ja": "3×10 ^ 13で単純な数学MYSに指示、分割からL（n）を変換します。 MYSの数の式は整数を因数分解するのに必要なNその後に減少します："
    },
    {
      "indent": 6,
      "text": "MYs = 6 * 10^(-16) * e^(1.92 * cubrt(ln(n) * (ln(ln(n)))^2))",
      "ja": "MYS = 6 * 10 ^（ -  16）* E ^（1.92 * cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "With what confidence can this formula be used for predicting the difficulty of factoring slightly larger numbers? The answer is that it should be a close upper bound, but each factorization effort is usually marked by some improvement in the algorithms or their implementations that makes the running time somewhat shorter than the formula would indicate.",
      "ja": "どのような自信を持って、この式はやや大きい数字を因数分解の難しさを予測するために使用することができますか？その答えは、それが近い上限でなければならないことであるが、各因数分解の努力は通常、式が示唆するよりもやや短い走行時間を作るアルゴリズムやその実装におけるいくつかの改善によってマークされています。"
    },
    {
      "indent": 0,
      "text": "2.3. Pollard's rho method",
      "section_title": true,
      "ja": "2.3。ポラードのrho法"
    },
    {
      "indent": 3,
      "text": "In Diffie-Hellman exchanges, there is a second attack, Pollard's rho method [POL78]. The algorithm relies on finding collisions between values computed in a large number space; its success rate is proportional to the square root of the size of the space. Because of Pollard's rho method, the search space in a DH key exchange for the key (the exponent in a g^a term), must be twice as large as the symmetric key. Therefore, to securely derive a key of K bits, an implementation must use an exponent with at least 2*K bits. See [ODL99] for more detail.",
      "ja": "Diffie-Hellman交換では、第二の攻撃、ポラードのrho法[POL78]があります。アルゴリズムは、多数の空間で計算された値との間の衝突を見つけることに依存しています。その成功率はスペースの大きさの平方根に比例しています。そのためポラードのrho法、キー（グラムで指数^期）のためにDH鍵交換における探索空間は、対称鍵の2倍の大きさでなければなりません。したがって、安全な実装は、少なくとも2 * Kビットで指数を使用する必要があり、Kビットの鍵を導出します。詳細は[ODL99]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When the Diffie-Hellman key exchange is done using an elliptic curve method, the NFS methods are of no avail. However, the collision method is still effective, and the need for an exponent (called a multiplier in EC's) with 2*K bits remains. The modulus used for the computation can also be 2*K bits, and this will be substantially smaller than the modulus needed for modular exponentiation methods as the desired security level increases past 64 bits of brute-force attack resistance.",
      "ja": "Diffie-Hellman鍵交換は、楕円曲線法を用いて行われる場合、NFS方法は無駄です。しかし、衝突法が依然として有効であり、2つの* Kビットを有する（ECの乗算器とも呼ばれる）指数の必要性が残っています。計算のために使用される弾性率はまた、2 * Kビットであることができ、これは、ブルートフォース攻撃耐性の64ビットの過去の所望のセキュリティレベルが増加するにつれて、べき乗剰余法に必要な弾性率よりも実質的に小さいであろう。"
    },
    {
      "indent": 3,
      "text": "One might ask, how can you compare the number of computer instructions really needed for a discrete logarithm attack to the number needed to search the keyspace of a cipher? In comparing the efforts, one should consider what a \"basic operation\" is. For brute force search of the keyspace of a symmetric encryption algorithm like DES, the basic operation is the time to do a key setup and the time to do one encryption. For discrete logs, the basic operation is a modular squaring. The log of the ratio of these two operations can be used as a \"normalizing factor\" between the two kinds of computations. However, even for very large moduli (16K bits), this factor amounts to only a few bits of extra effort.",
      "ja": "一つは、どのようにあなたが本当に暗号の鍵空間を探索するために必要な数の離散対数攻撃のために必要なコンピュータ命令の数を比較することができ、頼むかもしれませんか？努力を比較すると、1は「基本的な動作は、」何であるかを検討する必要があります。 DESのような対称暗号化アルゴリズムの鍵空間のブルートフォース検索のために、基本的な操作は、キーのセットアップと1つの暗号化を行うための時間をする時間です。個別のログの場合、基本的な操作は、モジュール式の二乗です。これらの二つの操作の比の対数は、計算の二種類の間の「正規化因子」として使用することができます。しかし、非常に大きな弾性係数（16Kビット）のために、この要因は、余分な努力の数ビットだけになります。"
    },
    {
      "indent": 0,
      "text": "2.4. Limits of large memory and many machines",
      "section_title": true,
      "ja": "2.4。大容量のメモリと多くのマシンの限界"
    },
    {
      "indent": 3,
      "text": "Robert Silverman has examined the question of when it will be practical to factor RSA moduli larger than 512 bits. His analysis is based not only on the theoretical number of operations, but it also includes expectations about the availability of actual machines for performing the work (this document is based only on theoretical number of operations). He examines the question of whether or not we can expect there be enough machines, memory, and communication to factor a very large number.",
      "ja": "ロバート・シルバーは、RSAは、512ビットよりも大きいモジュラスを考慮することは現実的であろう場合の問題を検討しました。彼の分析はないだけの操作の理論的な数に基づいて、それはまた、作業を行うため、実際のマシンの可用性に関する予想が含まれている（この文書は、操作のみの理論的な数に基づいています）。彼は、我々は非常に大きな数を因数分解するのに十分なマシン、メモリ、および通信することが期待できるかどうかの質問を調べます。"
    },
    {
      "indent": 3,
      "text": "The best factoring methods need a lot of random access memory for collecting data relations (sieving) and a critical final step that does a row reduction on a large matrix. The memory requirements are related to the size of the number being factored (or subjected to discrete logarithm solution). Silverman [SILIEEE99] [SIL00] has argued that there is a practical limit to the number of machines and the amount of RAM that can be brought to bear on a single problem in the foreseeable future. He sees two problems in attacking a 1024-bit RSA modulus: the machines doing the sieving will need 64-bit address spaces and the matrix row reduction machine will need several terabytes of memory. Silverman notes that very few 64-bit machines that have the 170 gigabytes of memory needed for sieving have been sold. Nearly a billion such machines are necessary for the sieving in a reasonable amount of time (a year or two).",
      "ja": "最高のファクタリング方式は、データ関係（ふるい分け）と大行列の行の削減を行い、重要な最後のステップを収集するためのランダム・アクセス・メモリを多く必要とします。メモリ要件は、因数分解（又は離散対数溶液にさらさ）される数のサイズに関連しています。シルバーマンは、[SILIEEE99] [SIL00]マシンの数と予見可能な将来において、単一の問題に負担をもたらすことができるRAMの量に実用的な限界があると主張しています。彼は、1024ビットのRSAモジュラスを攻撃に二つの問題を見て：ふるい分けを行うマシンは、64ビットのアドレス空間が必要になりますし、マトリックス行減速機は、メモリの数テラバイトが必要になります。シルバーマンは、ふるい分けに必要なメモリの170ギガバイトを持っている非常に少数の64ビットマシンが販売されていることを指摘しています。近く億ようなマシンは、妥当な時間（1〜2年）にふるい分けのために必要です。"
    },
    {
      "indent": 3,
      "text": "Silverman's conclusion, based on the history of factoring efforts and Moore's Law, is that 1024-bit RSA moduli will not be factored until about 2037. This implies a much longer lifetime to RSA keys than the theoretical analysis indicates. He argues that predictions about how many machines and memory modules will be available can be with great confidence, based on Moore's Law extrapolations and the recent history of factoring efforts.",
      "ja": "ファクタリング努力とムーアの法則の履歴に基づいて、シルバーの結論は、約2037これは理論的な分析が示すよりも、RSA鍵にはるかに長い寿命を暗示するまで、1024ビットのRSAモジュラスを因数分解されないことです。彼はどのように多くのマシンとメモリモジュールについての予測がムーアの法則の外挿とファクタリングの取り組みの最近の履歴に基づいて、大きな自信を持ってすることができ利用できるようになりますと主張しています。"
    },
    {
      "indent": 3,
      "text": "One should give the practical considerations a great deal of weight, but in a risk analysis, the physical world is less predictable than trend graphs would indicate. In considering how much trust to put into the inability of the computer industry to satisfy the voracious needs of factorers, one must have some insight into economic considerations that are more complicated than the mathematics of factoring. The demand for computer memory is hard to predict because it is based on applications: a \"killer app\" might come along any day and send the memory industry into a frenzy of sales. The number of processors available on desktops may be limited by the number of desks, but very capable embedded systems account for more processor sales than desktops. As embedded systems absorb networking functions, it is not unimaginable that millions of 64-bit processors with at least gigabytes of memory will pervade our environment.",
      "ja": "一つは、実際的な考慮に体重の多くを与える必要がありますが、リスク分析では、物理的な世界は、トレンドグラフが示すことになるよりも予測可能です。 factorersの貪欲なニーズを満たすために、コンピュータ業界の無能に入れるためにどのくらいの信頼検討では、1は、ファクタリングの数学よりも複雑な経済的考慮にいくつかの洞察力を持っている必要があります。それはアプリケーションに基づいているため、コンピュータのメモリの需要が予測することは困難である：「キラーアプリ」は、任意の日に一緒に来ると販売の狂乱にメモリ業界を送信することがあります。デスクトップで使用可能なプロセッサの数は、机の数によって制限される場合がありますが、非常に有能な組み込みシステムは、デスクトップよりも多くのプロセッサの売上高を占めています。組み込みシステムは、ネットワーク機能を吸収するとして、メモリの少なくともギガバイトと64ビットプロセッサの数百万人が私たちの環境に浸透することを想像もできないではありません。"
    },
    {
      "indent": 3,
      "text": "The bottom line on this is that the key length recommendations predicted by theory may be overly conservative, but they are what we have used for this document. This question of machine availability is one that should be reconsidered in light of current technology on a regular basis.",
      "ja": "この上の一番下の行は、理論によって予測されたキーの長さの推奨事項は過度に保守的であり得ることであるが、彼らは、我々は、このドキュメントで使用したものです。マシンの可用性のこの質問は、定期的に現在の技術に照らして再考されるべきものです。"
    },
    {
      "indent": 0,
      "text": "2.5. Special purpose machines",
      "section_title": true,
      "ja": "2.5。特別な目的のマシン"
    },
    {
      "indent": 3,
      "text": "In August of 2003, a design for a special-purpose \"sieving machine\" (TWIRL) surfaced [Shamir2003], and it substantially changed the cost estimates for factoring numbers up to 1024 bits in size. By applying many high-speed VLSI components in parallel, such a machine might be able to carry out the sieving of 512-bit numbers in 10 minutes at a cost of $10K for the hardware. A larger version could sieve a 1024- bit number in one year for a cost of $10M. The work cites some advances in approaches to the row reduction step in concluding that the security of 1024-bit RSA moduli is doubtful.",
      "ja": "2003年8月には、特別な目的「ふるい機」（TWIRL）の設計は、[Shamir2003]浮上し、そしてそれは、実質的にサイズが1024ビットまでの数字を因数分解するための費用の見積もりを変更しました。並列に多数の高速VLSI部品を適用することにより、そのようなマシンは、ハードウェアの$ 10,000の費用で10分で512ビット数のふるい分けを行うことができるかもしれません。拡大版は$ 10Mのコストのために一年で1024ビット数をふるいことができます。作業は、1024ビットのRSAモジュラスのセキュリティが疑わしいことを締結の行還元工程のアプローチにおいて、いくつかの進歩を引用します。"
    },
    {
      "indent": 3,
      "text": "The estimates for the time and cost for factoring 512-bit and 1024- bit numbers correspond to a speed-up factor of about 2 million over what can be achieved with commodity processors of a few years ago.",
      "ja": "512ビットおよび1024ビット数を因数分解するための時間と費用の見積もりは数年前のコモディティプロセッサで実現することができるものの上に約2百万円のスピードアップの要因に対応しています。"
    },
    {
      "indent": 0,
      "text": "3. Compute Time for the Algorithms",
      "section_title": true,
      "ja": "アルゴリズム3.計算時間"
    },
    {
      "indent": 3,
      "text": "This section describes how long it takes to use the algorithms to perform key exchanges. Again, it is important to consider the increased time it takes to exchange symmetric keys when increasing the length of public keys. It is important to avoid choosing unfeasibly long public keys.",
      "ja": "このセクションでは、それが鍵交換を実行するためのアルゴリズムを使用するのにかかる時間の長さについて説明します。ここでも、公開鍵の長さを増加させる際に、対称鍵を交換するのにかかる時間の増加を考慮することが重要です。実行不可能長い公開鍵を選択しないようにすることが重要です。"
    },
    {
      "indent": 0,
      "text": "3.1. Diffie-Hellman Key Exchange",
      "section_title": true,
      "ja": "3.1。 Diffie-Hellman鍵交換"
    },
    {
      "indent": 3,
      "text": "A Diffie-Hellman key exchange is done with a finite cyclic group G with a generator g and an exponent x. As noted in the Pollard's rho method section, the exponent has twice as many bits as are needed for the final key. Let the size of the group G be p, let the number of bits in the base 2 representation of p be j, and let the number of bits in the exponent be K.",
      "ja": "Diffie-Hellman鍵交換は、発電機Gと指数Xを有する有限巡回群Gを用いて行われます。ポラードのrho法の項で述べたように、指数は、最終的なキーのために必要とされるの2倍のビットを持っています。 Pのベース2表現のビット数がJであるものとする、グループGの大きさがPであるとすると、指数のビット数は、Kであるとします"
    },
    {
      "indent": 3,
      "text": "In doing the operations that result in a shared key, a generator is raised to a power. The most efficient way to do this involves squaring a number K times and multiplying it several times along the way. Each of the numbers has j/w computer words in it, where w is the number of bits in a computer word (today that will be 32 or 64 bits). A naive assumption is that you will need to do j squarings and j/2 multiplies; fortunately, an efficient implementation will need fewer (NB: for the remainder of this section, n represents j/w).",
      "ja": "共有鍵につながる操作を行うには、発電機を電源に上げられます。これを行うための最も効率的な方法は、数K回を二乗し、道に沿って、それを数回掛けることを伴います。数値のそれぞれは、Wは（32ビットまたは64ビットとなり、今日）コンピュータ・ワード内のビット数であり、その中のJ / Wコンピュータワードを、有しています。素朴な仮定を使用すると、j個のsquaringsとj / 2の乗算を行う必要がありますということです。幸いなことに、効率的な実装は、より少ない必要があります（注：このセクションの残りの部分を、nはJ / Wです）。"
    },
    {
      "indent": 3,
      "text": "A squaring operation does not need to use quite as many operations as a multiplication; a reasonable estimate is that squaring takes .6 the number of machine instructions of a multiply. If one prepares a table ahead of time with several values of small integer powers of the generator g, then only about one fifth as many multiplies are needed as the naive formula suggests. Therefore, one needs to do the work of approximately .8*K multiplies of n-by-n word numbers. Further, each multiply and squaring must be followed by a modular reduction, and a good assumption is that it is as hard to do a modular reduction as it is to do an n-by-n word multiply. Thus, it takes K reductions for the squarings and .2*K reductions for the multiplies. Summing this, the total effort for a Diffie-Hellman key exchange with K bit exponents and a modulus of n words is approximately 2*K n-by-n-word multiplies.",
      "ja": "二乗演算は乗算ほど多くの操作を使用する必要はありません。合理的な見積りは二乗を乗算の機械語命令の0.6数を取ることです。一方はジェネレータGの小さな整数累乗のいくつかの値と事前にテーブルを作成する場合ナイーブ式が示唆するように、その後、わずか約五分の一のような多くの乗算が必要です。したがって、1はn行n単語数の約0.8 * K乗算の作業を行う必要があります。さらに、それぞれが乗算と二乗は、モジュラー化が続かなければならない、との良好な仮定は、それが乗算のn行n単語を行うことであるとして、モジュラー化を行うことなどが困難であるということです。したがって、それはsquaringsと乗算のための0.2 * K削減のK削減をとります。この加算、Kビットの指数とのDiffie-Hellman鍵交換とNワードの係数の合計努力は約2 * Kのn行n-ワード乗算です。"
    },
    {
      "indent": 3,
      "text": "For 32-bit processors, integers that use less than about 30 computer words in their representation require at least n^2 instructions for an n-by-n-word multiply. Larger numbers will use less time, using Karatsuba multiplications, and they will scale as about n^(1.58) for larger n, but that is ignored for the current discussion. Note that 64-bit processors push the \"Karatsuba cross-over\" number out to even more bits.",
      "ja": "32ビットプロセッサのために、彼らの表現では約30のコンピュータ・ワード未満を使用する整数乗算のn行nワードのための少なくともN ^ 2の命令を必要とします。数字が大きいほどカラツバ乗算を使用して、少ない時間を使います、そして、彼らは約N ^（1.58）より大きなnのをスケールしますが、それは、現在の議論では無視されます。 64ビットプロセッサはさらにビットに外「カラツバクロスオーバー」番号を押すことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The basic result is: if you double the size of the Diffie-Hellman modular exponentiation group, you quadruple the number of operations needed for the computation.",
      "ja": "基本的な結果は次のとおりです。あなたがのDiffie-Hellmanのべき乗剰余グループのサイズを2倍ならば、あなたは計算に必要な操作の数を4倍。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Diffie-Hellman with elliptic curve groups",
      "section_title": true,
      "ja": "3.1.1。楕円曲線基とディフィー・ヘルマン"
    },
    {
      "indent": 3,
      "text": "Note that the ratios for computation effort as a function of modulus size hold even if you are using an elliptic curve (EC) group for Diffie-Hellman. However, for equivalent security, one can use smaller numbers in the case of elliptic curves. Assume that someone has chosen an modular exponentiation group with an 2048 bit modulus as being an appropriate security measure for a Diffie-Hellman application and wants to determine what advantage there would be to using an EC group instead. The calculation is relatively straightforward, if you assume that on the average, it is about 20 times more effort to do a squaring or multiplication in an EC group than in a modular exponentiation group. A rough estimate is that an EC group with equivalent security has about 200 bits in its representation. Then, assuming that the time is dominated by n-by-n-word operations, the relative time is computed as:",
      "ja": "弾性率の大きさの関数として計算努力のための比率を使用して、ディフィー・ヘルマンのための楕円曲線（EC）グループを使用している場合でも保持することに注意してください。しかし、同等のセキュリティのために、一方が楕円曲線の場合に小さい番号を使用することができます。誰かがのDiffie-Hellmanアプリケーションのための適切なセキュリティ対策として2048ビットモジュラスとべき乗剰余グループを選択し、代わりにECグループを使用して存在することになるものを利点を決定したいと考えていたとします。あなたは平均的に、べき乗剰余群よりもECグループ内二乗または乗算を行うには約20倍以上の努力であると仮定した場合の計算は、比較的簡単です。概算は、同等のセキュリティをECグループは、その表現に約200ビットを有することです。その後、時間がn行n-ワード操作によって支配されると仮定すると、相対時間は次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "((2048/200)^2)/20 ~= 5",
      "ja": "（（２０４８／２００）＾２）／２０ 〜＝ ５"
    },
    {
      "indent": 3,
      "text": "showing that an elliptic curve implementation should be five times as fast as a modular exponentiation implementation.",
      "ja": "楕円曲線の実装はべき乗剰余演算の実装の5倍の速さでなければならないことを示します。"
    },
    {
      "indent": 0,
      "text": "3.2. RSA encryption and decryption",
      "section_title": true,
      "ja": "3.2。 RSAの暗号化と復号化"
    },
    {
      "indent": 3,
      "text": "Assume that an RSA public key uses a modulus with j bits; its factors are two numbers of about j/2 bits each. The expected computation time for encryption and decryption are different. As before, we denote the number of words in the machine representation of the modulus by the symbol n.",
      "ja": "RSA公開鍵は、jビットとモジュラスを使用すると仮定する。その要因は約J / 2ビットずつの2つの数です。暗号化と復号化に期待される計算時間は異なります。前と同じように、我々は、シンボルnで弾性率の機械表現の単語の数を示します。"
    },
    {
      "indent": 3,
      "text": "Most implementations of RSA use a small exponent for encryption. An encryption may involve as few as 16 squarings and one multiplication, using n-by-n-word operations. Each operation must be followed by a modular reduction, and therefore the time complexity is about 16*(.6 + 1) + 1 + 1 ~= 28 n-by-n-word multiplies.",
      "ja": "RSAのほとんどの実装では、暗号化のための小さな指数を使用しています。暗号化は、n--N-ワードによる操作を使用して、わずか16としてsquaringsと1回の乗算を含むことができます。各操作は、モジュール式還元によって従わなければならないので、時間計算量は、約16×である（。+ 1 6）+ 1 + 1〜= 28のn行n-ワード乗算します。"
    },
    {
      "indent": 3,
      "text": "RSA decryption must use an exponent that has as many bits as the modulus, j. However, the Chinese Remainder Theorem applies, and all the computations can be done with a modulus of only n/2 words and an exponent of only j/2 bits. The computation must be done twice, once for each factor. The effort is equivalent to 2*(j/2) (n/2 by n/2)- word multiplies. Because multiplying numbers with n/2 words is only 1/4 as difficult as multiplying numbers with n words, the equivalent effort for RSA decryption is j/4 n-by-n-word multiplies.",
      "ja": "RSAの暗号解読は、弾性率、Jのように多くのビットを有する指数を使用する必要があります。しかし、中国の剰余定理が適用され、そしてすべての計算は、N / 2ワードの係数のみJ / 2ビットの指数を用いて行うことができます。計算は、各要因のために1回、2回行わなければなりません。ワード乗算 - 努力が2 *（J / 2）（N / 2 N / 2）に相当します。 N / 2個の単語と数字を乗算するn個の単語と数字を乗算としてのみ1/4として困難であるため、RSA復号のための同等の努力がj / 4、N-Nワードによって乗算です。"
    },
    {
      "indent": 3,
      "text": "If you double the size of the modulus for RSA, the n-by-n multiplies will take four times as long. Further, the decryption time doubles because the exponent is larger. The overall scaling cost is a factor of 4 for encryption, a factor of 8 for decryption.",
      "ja": "あなたはRSAのための係数の大きさを倍にした場合は、n行n乗算は限り4倍になります。指数が大きいのでさらに、復号時間が倍になります。全体的なスケーリングのコストは、暗号化のための4倍、復号化のための8倍です。"
    },
    {
      "indent": 0,
      "text": "3.3. Real-world examples",
      "section_title": true,
      "ja": "3.3。実世界の例"
    },
    {
      "indent": 3,
      "text": "To make these numbers more real, here are a few examples of software implementations run on hardware that was current as of a few years before the publication of this document. The examples are included to show rough estimates of reasonable implementations; they are not benchmarks. As with all software, the performance will depend on the exact details of specialization of the code to the problem and the specific hardware.",
      "ja": "これらの数字は、よりリアルにするために、ここでは、本書の出版前に数年現在のものだったのハードウェア上で実行するソフトウェア実装のいくつかの例です。実施例は、合理的な実装の大まかな推定値を示すために含まれます。彼らは、ベンチマークではありません。すべてのソフトウェアと同様に、パフォーマンスが問題と特定のハードウェアへのコードの専門の正確な詳細に依存します。"
    },
    {
      "indent": 3,
      "text": "The best time informally reported for a 1024-bit modular exponentiation (the decryption side of 2048-bit RSA), is 0.9 ms (about 450,000 CPU cycles) on a 500 MHz Itanium processor. This shows that newer processors are not losing ground on big number operations; the number of instructions is less than a 32-bit processor uses for a 256-bit modular exponentiation.",
      "ja": "非公式1024ビットべき乗剰余（2048ビットRSAの復号側）について報告さ最良の時間は、500MHzのItaniumプロセッサに0.9ミリ（約45万CPUサイクル）です。これは、新しいプロセッサが大きな数の操作に地面を失っていないことを示しています。命令の数は、32ビットプロセッサは、256ビットのべき乗剰余演算に使用する未満です。"
    },
    {
      "indent": 3,
      "text": "For less advanced processors timing, the following two tables (computed by Tero Monenen at SSH Communications) for modular exponentiation, such as would be done in a Diffie-Hellman key exchange.",
      "ja": "以下の高度なプロセッサのタイミングのために、などのべき乗剰余演算のための（SSH通信でTERO Monenenによって計算）以下の2つの表は、ディフィー・ヘルマン鍵交換で行われるであろう。"
    },
    {
      "indent": 3,
      "text": "Celeron 400 MHz; compiled with GNU C compiler, optimized, some platform specific coding optimizations:",
      "ja": "セレロン400メガヘルツ。いくつかのプラットフォーム固有のコードの最適化は、最適化された、GNU Cコンパイラでコンパイル："
    },
    {
      "indent": 6,
      "text": "group modulus exponent time type size size mod 768 ~150 18 msec mod 1024 ~160 32 msec mod 1536 ~180 82 msec ecn 155 ~150 35 msec ecn 185 ~200 56 msec",
      "ja": "グループモジュラス指数時間型サイズのサイズMOD〜180 82 768〜150 18秒MOD 1024〜160 32ミリ秒MOD 1536ミリECN 155〜150 35秒ECN 185〜200 56秒"
    },
    {
      "indent": 3,
      "text": "The group type is from [RFC2409] and is either modular exponentiation (\"mod\") or elliptic curve (\"ecn\"). All sizes here and in subsequent tables are in bits.",
      "ja": "グループタイプは[RFC2409]からのものであり、べき乗剰余（「MOD」）や楕円曲線（「ECN」）のいずれかです。すべてのサイズ、ここで、後続のテーブルではビットです。"
    },
    {
      "indent": 3,
      "text": "Alpha 500 MHz compiled with Digital's C compiler, optimized, no platform specific code:",
      "ja": "Digital社のCコンパイラ、最適化され、無プラットフォーム固有のコードを使用してコンパイルアルファ500 MHzの："
    },
    {
      "indent": 6,
      "text": "group modulus exponent time type size size mod 768 ~150 12 msec mod 1024 ~160 24 msec mod 1536 ~180 59 msec ecn 155 ~150 20 msec ecn 185 ~200 27 msec",
      "ja": "グループモジュラス指数時間型サイズのサイズMOD〜180 59 768〜150 12ミリ秒MOD 1024〜160 24ミリMOD 1536ミリECN 155〜150 20ミリ秒ECN 185〜200 27秒"
    },
    {
      "indent": 3,
      "text": "The following two tables (computed by Eric Young) were originally for RSA signing operations, using the Chinese Remainder representation. For ease of understanding, the parameters are presented here to show the interior calculations, i.e., the size of the modulus and exponent used by the software.",
      "ja": "（エリック・ヤングによって計算）以下の2つの表は、中国の剰余表現を使用して、RSA署名操作のために元々ありました。理解を容易にするため、パラメータは内部計算を示すために、ここで提示されている、すなわち、ソフトウェアによって使用される係数と指数の大きさ。"
    },
    {
      "indent": 3,
      "text": "Dual Pentium II-350:",
      "ja": "デュアルのPentium II-350："
    },
    {
      "indent": 6,
      "text": " equiv equiv equiv modulus exponent time size size 256 256 1.5 ms 512 512 8.6 ms 1024 1024 55.4 ms 2048 2048 387 ms",
      "ja": "当当当量係数指数時間径サイズ256 256 1.5 512 512 8.6ミリ秒1024×1024 55.4ミリ2048 2048 387ミリ秒"
    },
    {
      "indent": 3,
      "text": "Alpha 264 600mhz:",
      "ja": "アルファ264の600MHz："
    },
    {
      "indent": 6,
      "text": " equiv equiv equiv modulus exponent time size size 512 512 1.4 ms",
      "ja": "当当当量係数指数時間径サイズ512 512 1.4ミリ"
    },
    {
      "indent": 3,
      "text": "Recent chips that accelerate exponentiation can perform 1024-bit exponentiations (1024 bit modulus, 1024 bit exponent) in about 3 milliseconds or less.",
      "ja": "べき乗を促進最近のチップは、約3ミリ秒以下に1024ビットの累乗（1024ビットモジュラス1024ビット指数）を実行することができます。"
    },
    {
      "indent": 0,
      "text": "4. Equivalences of Key Sizes",
      "section_title": true,
      "ja": "鍵のサイズの4それに相当します"
    },
    {
      "indent": 3,
      "text": "In order to determine how strong a public key is needed to protect a particular symmetric key, you first need to determine how much effort is needed to break the symmetric key. Many Internet security protocols require the use of TripleDES for strong symmetric encryption, and it is expected that the Advanced Encryption Standard (AES) will be adopted on the Internet in the coming years. Therefore, these two algorithms are discussed here. In this section, for illustrative purposes, we will implicitly assume that the system security requirement is 112 bits; this doesn't mean that 112 bits is recommended. In fact, 112 bits is arguably too strong for any practical purpose. It is used for illustration simply because that is the upper bound on the strength of TripleDES.",
      "ja": "公開鍵は、特定の対称鍵を保護するために必要とされるどれくらい強いかを決定するためには、まず対称鍵を破るために必要とされているどのくらいの努力を決定する必要があります。多くのインターネットセキュリティプロトコルは、強力な対称暗号化のためのTripleDESの使用を必要とし、高度暗号化標準（AES）は今後数年間で、インターネット上で採用されることが期待されます。したがって、これら2つのアルゴリズムは、ここで説明されています。このセクションでは、例示の目的のために、我々は、暗黙的に、システムのセキュリティ要件は、112ビットであると仮定する。これは112ビットが推奨されていることを意味するものではありません。実際には、112ビットは、任意の実用的な目的のために、おそらくあまりにも強いです。すなわち、トリプルDESの強さの上限であるという理由だけで、例示のために使用されます。"
    },
    {
      "indent": 3,
      "text": "If one could simply determine the number of MYs it takes to break TripleDES, the task of computing the public key size of equivalent strength would be easy. Unfortunately, that isn't the case here because there are many examples of DES-specific hardware that encrypt faster than DES in software on a standard CPU. Instead, one must determine the equivalent cost for a system to break TripleDES and a system to break the public key protecting a TripleDES key.",
      "ja": "1は、単にそれがTripleDESのを破るのにかかるMYSの数を決定することができれば、同等の強度の公開鍵サイズを計算する作業は簡単だろう。標準のCPU上のソフトウェアで速いDESよりも暗号化DES-特定のハードウェアの多くの例があるので、残念ながら、それはここではそうではありません。その代わり、1はトリプルDESキーを保護する公開鍵を破るためのTripleDESを破るためのシステムのための同等のコストとシステムを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "In 1998, the Electronic Frontier Foundation (EFF) built a DES-cracking machine [GIL98] for US$130,000 that could test about 1e11 DES keys per second (additional money was spent on the machine's design). The machine's builders fully admit that the machine is not well optimized, and it is estimated that ten times the amount of money could probably create a machine about 50 times as fast. Assuming more optimization by guessing that a system to test TripleDES keys runs about as fast as a system to test DES keys, so approximately US$1 million might test 5e12 TripleDES keys per second.",
      "ja": "1998年には、電子フロンティア財団（EFF）は、毎秒約1E11 DES鍵（追加のお金はマシンのデザインに費やされた）をテストすることができDESクラッキングマシン[GIL98】米国のための$ 130,000建て。マシンのビルダーは、完全に機械がうまく最適化されていない、そしてお金の10倍の量は、おそらく約50倍の速マシンを作成することができると推定されていることを認めます。トリプルDESキーをテストするためのシステムがそう約US $ 84百万毎秒5E12のTripleDESキーをテストする可能性がある、程度の速DES鍵をテストするためのシステムとして動作することを推測することで、より最適化を仮定。"
    },
    {
      "indent": 3,
      "text": "In case your adversaries are much richer than EFF, you may want to assume that they have US$1 trillion, enough to test 5e18 keys per second. An exhaustive search of the effective TripleDES space of 2^112 keys with this quite expensive system would take about 1e15 seconds or about 33 million years. (Note that such a system would also need 2^60 bytes of RAM [MH81], which is considered free in this calculation). This seems a needlessly conservative value. However, if computer logic speeds continue to increase in accordance with Moore's Law (doubling in speed every 1.5 years), then one might expect that in about 50 years, the computation could be completed in only one year. For the purposes of illustration, this 50 year resistance against a trillionaire is assumed to be the minimum security requirement for a set of applications.",
      "ja": "場合は、あなたの敵は、EFFよりはるかに豊かです、あなたは彼らが米国の毎秒5E18キーをテストするのに十分な$ 1兆、持っていると仮定することができます。このかなり高価なシステムと2 ^ 112キーの効果的なのTripleDESスペースの徹底的な検索を約1E15秒または約33万年かかるだろう。 （そのようなシステムは、この計算でフリーとみなされるRAMの2 ^ 60バイト[MH81]を、必要があることに留意されたいです）。これは、不控えめな値です。コンピュータのロジック速度が（すべての1.5年の速度で倍増）ムーアの法則に従って増加し続ける場合は、その後1は、約50年で、計算はわずか1年で完了することができることを期待するかもしれません。例示の目的のために、大富豪に対してこの50年の抵抗は、アプリケーションのセットのための最低限のセキュリティ要件であると仮定されます。"
    },
    {
      "indent": 3,
      "text": "If 112 bits of attack resistance is the system security requirement, then the key exchange system for TripleDES should have equivalent difficulty; that is to say, if the attacker has US$1 trillion, you want him to spend all his money to buy hardware today and to know that he will \"crack\" the key exchange in not less than 33 million years. (Obviously, a rational attacker would wait for about 45 years before actually spending the money, because he could then get much better hardware, but all attackers benefit from this sort of wait equally.)",
      "ja": "攻撃耐性の112ビットは、システムのセキュリティ要件である場合は、トリプルDESのための鍵交換システムは、同等の難しさを有していなければなりません。攻撃者は米国のあなたは彼が今日のハードウェアを購入すると、彼は以下億33年以上で鍵交換を「クラック」になることを知っている彼のすべてのお金を費やすしたい$ 1兆、持っている場合には、言うことです。 （もちろん、彼はその後、より良いハードウェアを得ることができるので、合理的な攻撃者は、実際にお金を使う前に、約45年を待つだろうが、すべての攻撃者が平等に待つのこの種の恩恵を受ける。）"
    },
    {
      "indent": 3,
      "text": "It is estimated that a typical PC CPU of just a few years ago can generate over 500 MIPs and could be purchased for about US$100 in quantity; thus you get more than 5 MIPs/US$. Again, this number doubles about every 18 months. For one trillion US dollars, an attacker can get 5e12 MIP years of computer instructions on that recent-vintage hardware. This figure is used in the following estimates of equivalent costs for breaking key exchange systems.",
      "ja": "ほんの数年前の典型的なPCのCPUは、500以上のMIPを生成することができ、数量で約US $ 100で購入できることが推定されています。したがって、あなたは以上の5つのMIP / US $を取得します。繰り返しますが、この数は約18カ月ごとに倍増します。 1兆ドルの場合、攻撃者はその最近のヴィンテージのハードウェア上のコンピュータ命令5E12 MIP年を得ることができます。この図は、鍵交換システムを破壊するための等価コストの次の見積りに使用されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Key equivalence against special purpose brute force hardware",
      "section_title": true,
      "ja": "4.1。特別な目的のブルートフォースハードウェアに対する鍵の方程式"
    },
    {
      "indent": 3,
      "text": "If the trillionaire attacker is to use conventional CPU's to \"crack\" a key exchange for a 112 bit key in the same time that the special purpose machine is spending on brute force search for the symmetric key, the key exchange system must use an appropriately large modulus. Assume that the trillionaire performs 5e12 MIPs of instructions per year. Use the following equation to estimate the modulus size to use with RSA encryption or DH key exchange:",
      "ja": "大富豪の攻撃者が特別な目的のマシンは、対称鍵用力まかせ探索に費やしているのと同じ時間で112ビット鍵の鍵交換を「クラック」するために、従来のCPUのを使用する場合は、鍵交換システムが適切に大きなを使用する必要があります。モジュラス。大富豪は年間命令の5E12 MIPを実行することを前提としています。 RSA暗号やDH鍵交換で使用する係数サイズを推定するために、以下の式を使用します。"
    },
    {
      "indent": 6,
      "text": "5*10^33 = (6*10^-16)*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))",
      "ja": "5 * 10 ^ 33 =（6 * 10 ^ -16）* E ^（1.92 * cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "Solving this approximately for n yields:",
      "ja": "約n利回りのためにこれを解きます："
    },
    {
      "indent": 6,
      "text": "n = 10^(625) = 2^(2077)",
      "ja": "ん ＝ １０＾（６２５） ＝ ２＾（２０７７）"
    },
    {
      "indent": 3,
      "text": "Thus, assuming similar logic speeds and the current efficiency of the number field sieve, moduli with about 2100 bits will have about the same resistance against attack as an 112-bit TripleDES key. This indicates that RSA public key encryption should use a modulus with around 2100 bits; for a Diffie-Hellman key exchange, one could use a slightly smaller modulus, but it is not a significant difference.",
      "ja": "したがって、同様の論理速度および番号フィールドふるいの電流効率を仮定すると、約2100ビットのモジュラスは、112ビットトリプルDESキーと攻撃に対して同じ抵抗について持っているであろう。これは、RSA公開鍵暗号は約2100ビットの係数を使用する必要があることを示しています。 Diffie-Hellman鍵交換のために、1はわずかに小さい弾性係数を使用することができますが、それは有意な差ではありません。"
    },
    {
      "indent": 0,
      "text": "4.2 Key equivalence against conventional CPU brute force attack",
      "section_title": true,
      "ja": "従来のCPUブルートフォース攻撃に対して4.2鍵の方程式"
    },
    {
      "indent": 3,
      "text": "An alternative way of estimating this assumes that the attacker has a less challenging requirement: he must only \"crack\" the key exchange in less time than a brute force key search against the symmetric key would take with general purpose computers. This is an \"apples-to-apples\" comparison, because it assumes that the attacker needs only to have computation donated to his effort, not built from a personal or national fortune. The public key modulus will be larger than the one in 4.1, because the symmetric key is going to be viable for a longer period of time.",
      "ja": "これを推定する別の方法は、攻撃者が少なく挑戦的な要件を持っていることを前提としています。彼は唯一の汎用コンピュータを取ると、対称キーに対するブルートフォースキー検索よりも短い時間で鍵交換を「クラック」しなければなりません。それは攻撃者が唯一の個人や国家の財産から構築されていない彼の努力に寄付計算を、持っている必要があることを前提としていので、これは、「りんご・ツー・リンゴ」の比較です。対称鍵は、時間の長い期間のための実行可能なことを行っているので、公開鍵弾性率は、4.1で1よりも大きくなります。"
    },
    {
      "indent": 3,
      "text": "Assume that the number of CPU instructions to encrypt a block of material using TripleDES is 300. The estimated number of computer instructions to break 112 bit TripleDES key:",
      "ja": "CPU命令の数は、材料使用のTripleDESのブロックを暗号化することを前提としている112ビットのTripleDESを破るためのコンピュータ命令300の推定数キー："
    },
    {
      "indent": 6,
      "text": "300 * 2^112 = 1.6 * 10^(36) = .02*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))",
      "ja": "300 * 2 ^ 112 = 1.6×10 ^（36）= 0.02 * E ^（1.92 * cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "Solving this approximately for n yields:",
      "ja": "約n利回りのためにこれを解きます："
    },
    {
      "indent": 6,
      "text": "n = 10^(734) = 2^(2439)",
      "ja": "ん ＝ １０＾（７３４） ＝ ２＾（２４３９）"
    },
    {
      "indent": 3,
      "text": "Thus, for general purpose CPU attacks, you can assume that moduli with about 2400 bits will have about the same strength against attack as an 112-bit TripleDES key. This indicates that RSA public key encryption should use a modulus with around 2400 bits; for a Diffie-Hellman key exchange, one could use a slightly smaller modulus, but it not a significant difference.",
      "ja": "このように、汎用のCPU攻撃のために、あなたはおよそ2400ビットでその弾性係数を取ることができる112ビットのトリプルDESキーと攻撃に対して同じ強さについて持っているでしょう。これは、RSA公開鍵暗号は約2400ビットの係数を使用する必要があることを示しています。 Diffie-Hellman鍵交換のために、一つは有意差がわずかに小さいモジュラスを使用しますが、それができませんでした。"
    },
    {
      "indent": 3,
      "text": "Note that some authors assume that the algorithms underlying the number field sieve will continue to get better over time. These authors recommend an even larger modulus, over 4000 bits, for protecting a 112-bit symmetric key for 50 years. This points out the difficulty of long-term cryptographic security: it is all but impossible to predict progress in mathematics and physics over such a long period of time.",
      "ja": "一部の著者は数体ふるいの基礎となるアルゴリズムは、時間の経過とともに良くなっていくことを前提としています。これらの著者は50年間112ビット対称鍵を保護するために、4000ビットの上に、さらに大きな弾性率をお勧めします。これは、長期的な暗号化セキュリティの難しさを指摘する：それは時間のような長い期間にわたって数学と物理学の進展を予測することはほとんど不可能です。"
    },
    {
      "indent": 0,
      "text": "4.3. A One Year Attack: 80 bits of strength",
      "section_title": true,
      "ja": "4.3。一年の攻撃：強の80ビット"
    },
    {
      "indent": 3,
      "text": "Assuming a trillionaire spends his money today to buy hardware, what size key exchange numbers could he \"crack\" in one year? He can perform 5*e12 MYs of instructions, or",
      "ja": "鍵交換番号は、彼が一年で「割れ」可能性がどのようなサイズ、大富豪は、ハードウェアを購入するために、今日の彼のお金を費やしていると仮定すると？彼は命令の5 * E12 MYSを実行する、またはすることができます"
    },
    {
      "indent": 6,
      "text": "3*10^13 * 5*10^12 = .02*e^(1.92*cubrt(ln(n)*(ln(ln(n)))^2))",
      "ja": "3×10 ^ 13 * 5 * 10 ^ 12 = 0.02 * E ^（1.92 * cubrt（LN（N）*（LN（LN（N）））^ 2））"
    },
    {
      "indent": 3,
      "text": "Solving for an approximation of n yields",
      "ja": "n個の利回りの近似について解きます"
    },
    {
      "indent": 6,
      "text": "n = 10^(360) = 2^(1195)",
      "ja": "ん ＝ １０＾（３６０） ＝ ２＾（１１９５）"
    },
    {
      "indent": 3,
      "text": "This is about as many operations as it would take to crack an 80-bit symmetric key by brute force.",
      "ja": "それは力ずくで80ビットの対称鍵を解読するのにかかるので、これはおよそとして多くの操作です。"
    },
    {
      "indent": 3,
      "text": "Thus, for protecting data that has a secrecy requirement of one year against an incredibly rich attacker, a key exchange modulus with about 1200 bits protecting an 80-bit symmetric key is safe even against a nation's resources.",
      "ja": "このように、信じられないほどの豊富な攻撃者に対する1年間の機密性の要件を持っているデータを保護するために、80ビットの対称鍵を保護する約1200ビットの鍵交換率がさえ、国家の資源に対して安全です。"
    },
    {
      "indent": 0,
      "text": "4.4. Key equivalence for other ciphers",
      "section_title": true,
      "ja": "4.4。他の暗号の鍵の方程式"
    },
    {
      "indent": 3,
      "text": "Extending this logic to the AES is straightforward. For purposes of estimation for key searching, one can think of the 128-bit AES as being at least 16 bits stronger than TripleDES but about three times as fast. The time and cost for a brute force attack is approximately 2^(16) more than for TripleDES, and thus, under the assumption that 128 bits of strength is the desired security goal, the recommended key exchange modulus size is about 700 bits longer.",
      "ja": "AESにこのロジックを拡張することは簡単です。キー検索のための推定の目的のために、1は、少なくとも16のTripleDESより強いビットが、約3倍の速さであるとして、128ビットAESと考えることができます。ブルートフォース攻撃のための時間とコストがトリプルDESよりも約2 ^（16）以上であるため、強度の128ビットは、所望のセキュリティ目的であるという仮定の下で、推奨される鍵交換係数の大きさは約700ビットの長いです。"
    },
    {
      "indent": 3,
      "text": "If it is possible to design hardware for AES cracking that is considerably more efficient than hardware for DES cracking, then (again under the assumption that the key exchange strength must match the brute force effort) the moduli for protecting the key exchange can be made smaller. However, the existence of such designs is only a matter of speculation at this early moment in the AES lifetime.",
      "ja": "それはAESがそれをクラッキングするためのハードウェアを設計することが可能である場合にDESは、鍵交換を保護するための弾性率を小さくすることができる（再度ブルートフォース努力と一致している必要があり、鍵交換強度という仮定の下で）、次いで、クラッキングのためのハードウェアよりもかなり効率的です。しかし、そのような設計の存在は、AESの寿命のこの初期の時点での投機の問題だけです。"
    },
    {
      "indent": 3,
      "text": "The AES ciphers have key sizes of 128 bits up to 256 bits. Should a prudent minimum security requirement, and thus the key exchange moduli, have similar strengths? The answer to this depends on whether or not one expect Moore's Law to continue unabated. If it continues, one would expect 128 bit keys to be safe for about 60 years, and 256 bit keys would be safe for another 400 years beyond that, far beyond any imaginable security requirement. But such progress is difficult to predict, as it exceeds the physical capabilities of today's devices and would imply the existence of logic technologies that are unknown or infeasible today. Quantum computing is a candidate, but too little is known today to make confident predictions about its applicability to cryptography (which itself might change over the next 100 years!).",
      "ja": "AES暗号は256ビットまでの128ビットのキーサイズを持っています。慎重な最低限のセキュリティ要件、ひいては鍵交換弾性率は、同様の強みを持っているべきですか？これに対する答えは1つがムーアの法則は衰えることなく継続することを期待するか否かに依存します。それが続けば、1は128ビットの鍵は、約60年にわたって安全であることを期待し、256ビットの鍵があれば何でも想像セキュリティ要件を超えて、それを超えた別の400年のために安全であろう。しかし、このような進歩は、それが今日のデバイスの物理的な能力を超えると、予測することは困難であり、今日、未知または実行不可能ですロジック技術の存在を暗示します。量子コンピューティングは候補であるが、今日知られている、あまりにも少しは暗号への適用についての自信を持って予測するために（それ自体は、次の100年にわたって変更されることがあります！）。"
    },
    {
      "indent": 3,
      "text": "If Moore's Law does not continue to hold, if no new computational paradigms emerge, then keys of over 100 bits in length might well be safe \"forever\". Note, however that others have come up with estimates based on assumptions of new computational paradigms emerging. For example, Lenstra and Verheul's web-based paper \"Selecting Cryptographic Key Sizes\" chooses a more conservative analysis than the one in this document.",
      "ja": "ムーアの法則を保持するために継続しない場合は新しい計算パラダイムが出現しない場合、は、長さが100ビット以上の鍵はよく「永遠に」安全かもしれません。しかし、他の人が新興新しい計算パラダイムの仮定に基づいて見積りが出ていることに、注意してください。たとえば、「暗号鍵長の選択」LenstraとVerheulのWebベースの論文は、この文書に記載されているものよりも保守的な分析を選択します。"
    },
    {
      "indent": 0,
      "text": "4.5. Hash functions for deriving symmetric keys from public key algorithms",
      "ja": "4.5。公開鍵のアルゴリズムから対称鍵を導出するためのハッシュ関数"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman algorithm results in a key that is hundreds or thousands of bits long, but ciphers need far fewer bits than that. How can one distill a long key down to a short one without losing strength?",
      "ja": "ビットの数百または数千長いですが、暗号はそれよりもはるかに少ないビットを必要とするキーでのDiffie-Hellmanアルゴリズムの結果。どのようにして強度を失うことなく、短いものと長いダウンキーを蒸留することができますか？"
    },
    {
      "indent": 3,
      "text": "Cryptographic one-way hash functions are the building blocks for this, and so long as they use all of the Diffie-Hellman key to derive each block of the symmetric key, they produce keys with sufficient strength.",
      "ja": "暗号一方向ハッシュ関数は、このためのビルディングブロックであり、限り、彼らは対称鍵の各ブロックを導き出すためのDiffie-Hellmanキーのすべてを使用するように、彼らは十分な強度で鍵を生成します。"
    },
    {
      "indent": 3,
      "text": "The usual recommendation is to use a good one-way hash function applied to he base material (the result of the key exchange) and to use a subset of the hash function output for the key. However, if the desired key length is greater than the output of the hash function, one might wonder how to reconcile the two.",
      "ja": "通常の推薦は、彼の基材に適用し、良好な一方向ハッシュ関数（鍵交換の結果）を使用して、鍵のハッシュ関数出力のサブセットを使用することです。目的のキーの長さがハッシュ関数の出力よりも大きい場合は、1が2を調整する方法を疑問に思うかもしれません。"
    },
    {
      "indent": 3,
      "text": "The step of deriving extra key bits must satisfy these requirements:",
      "ja": "余分なキービットを導出するステップは、これらの要件を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "- The bits must not reveal any information about the key exchange secret",
      "ja": " - ビットは、鍵交換の秘密についての情報を明らかにしてはなりません"
    },
    {
      "indent": 3,
      "text": "- The bits must not be correlated with each other",
      "ja": " - ビットが対応付けされてはなりません"
    },
    {
      "indent": 3,
      "text": "- The bits must depend on all the bits of the key exchange secret",
      "ja": " - ビットは、鍵交換の秘密のすべてのビットに依存しなければなりません"
    },
    {
      "indent": 3,
      "text": "Any good cryptographic hash function satisfies these three requirements. Note that the number of bits of output of the hash function is not specified. That is because even a hash function with a very short output can be iterated to produce more uncorrelated bits with just a little bit of care.",
      "ja": "何かいい暗号ハッシュ関数は、これらの3つの要件を満たしています。ハッシュ関数の出力のビット数が指定されていないことに留意されたいです。非常に短い出力でも、ハッシュ関数は、ケアの少しでより多くの無相関ビットを生成するために反復することができるからです。"
    },
    {
      "indent": 3,
      "text": "For example, SHA-1 has 160 bits of output. For deriving a key of attack resistance of 160 bits or less, SHA(DHkey) produces a good symmetric key.",
      "ja": "例えば、SHA-1は、出力の160ビットを有します。 160ビット以下の攻撃耐性の鍵を導出するため、SHA（DHKeyを）は、良好な対称キーを生成します。"
    },
    {
      "indent": 3,
      "text": "Suppose one wants a key with attack resistance of 160 bits, but it is to be used with a cipher that uses 192 bit keys. One can iterate SHA-1 as follows:",
      "ja": "一つは160ビットの攻撃耐性を有するキーを望んでいるが、それは192ビットキーを使用する暗号で使用されると仮定する。次のように一つは、SHA-1を繰り返すことができます。"
    },
    {
      "indent": 6,
      "text": "Bits 1-160 of the symmetric key = K1 = SHA(DHkey | 0x00) (that is, concatenate a single octet of value 0x00 to the right side of the DHkey, and then hash) Bits 161-192 of the symmetric key = K2 = select_32_bits(SHA(K1 | 0x01))",
      "ja": "ビット対称キー= K1 = SHAの1-160（DHKeyを| 0x00が）（すなわち、DHKeyを右側に値0×00の単一オクテットを連結し、次にハッシュ）対称キー= K2の161から192ビット= select_32_bits（SHA（K1 | 0×01））"
    },
    {
      "indent": 3,
      "text": "But what if one wants 192 bits of strength for the cipher? Then the appropriate calculation is",
      "ja": "しかし、一つは、暗号の強度の192ビットを望んでいますか？その後、適切な計算があります"
    },
    {
      "indent": 6,
      "text": "Bits 1-160 of the symmetric key = SHA(0x00 | DHkey) Bits 161-192 of the symmetric key = select_32_bits(SHA(0x01 | DHkey))",
      "ja": "ビット対称鍵= SHAの1から160（0x00の| DHKeyを）は、対称鍵= select_32_bits（| DHKeyを）SHA（0×01）の161から192ビット"
    },
    {
      "indent": 3,
      "text": "(Note that in the description above, instead of concatenating a full octet, concatenating a single bit would also be sufficient.)",
      "ja": "（代わりにも十分である単一ビットを連結し、完全なオクテットを連結した、上記の説明であることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The important distinction is that in the second case, the DH key is used for each part of the symmetric key. This assures that entropy of the DH key is not lost by iteration of the hash function over the same bits.",
      "ja": "重要な違いは、第二のケースでは、DHキーは対称鍵の各部分のために使用されることです。これは、DHキーのエントロピーが同じビット以上のハッシュ関数の繰り返しによって失われないことを保証します。"
    },
    {
      "indent": 3,
      "text": "From an efficiency point of view, if the symmetric key must have a great deal of entropy, it is probably best to use a cryptographic hash function with a large output block (192 bits or more), rather than iterating a smaller one.",
      "ja": "対称鍵は、エントロピーの多くを有していなければならない場合、ビューの効率の観点から、それはかなり小さい方を繰り返すよりも、大きな出力ブロック（192ビット以上）で暗号ハッシュ関数を使用することがおそらく最良です。"
    },
    {
      "indent": 3,
      "text": "Newer hash algorithms with longer output (such as SHA-256, SHA-384, and SHA-512) can be used with the same level of security as the stretching algorithm described above.",
      "ja": "（例えば、SHA-256、SHA-384およびSHA-512など）より長い出力を有する新しいハッシュアルゴリズムは、上述の延伸アルゴリズムと同じレベルのセキュリティと共に使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.6. Importance of randomness",
      "section_title": true,
      "ja": "4.6。ランダム性の重要性"
    },
    {
      "indent": 3,
      "text": "Some of the calculations described in this document require random inputs; for example, the secret Diffie-Hellman exponents must be chosen based on n truly random bits (where n is the system security requirement). The number of truly random bits is extremely important to determining the strength of the output of the calculations. Using truly random numbers is often overlooked, and many security applications have been significantly weakened by using insufficient random inputs. A much more complete description of the importance of random numbers can be found in [ECS].",
      "ja": "この文書で説明した計算の一部は、ランダムな入力を必要とします。例えば、秘密のDiffie-Hellman指数（Nはシステムのセキュリティ要件である）真にランダムなnビットに基づいて選択しなければなりません。真にランダムなビット数は、計算の出力の強さを決定する非常に重要です。真の乱数を使用すると、しばしば見落とされ、多くのセキュリティアプリケーションが大幅に不足し、ランダムな入力を使用することにより弱体化されています。乱数の重要性のより完全な説明は、[ECS]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "5. Conclusion",
      "section_title": true,
      "ja": "5。結論"
    },
    {
      "indent": 3,
      "text": "In this table it is assumed that attackers use general purpose computers, that the hardware is purchased in the year 2000, and that mathematical knowledge relevant to the problem remains the same as today. This is an pure \"apples-to-apples\" comparison demonstrating how the time for a key exchange scales with respect to the strength requirement. The subgroup size for DSA is included, if that is being used for supporting authentication as part of the protocol; the DSA modulus must be as long as the DH modulus, but the size of the \"q\" subgroup is also relevant.",
      "ja": "この表では、攻撃者がハードウェアが2000年に購入されていることを、汎用コンピュータを使用し、問題に関連する数学的知識が今日と同じままであることを想定しています。これは、鍵交換のための時間は、強度要件に関してスケール方法を示す純粋な「りんご・ツー・リンゴ」の比較です。それはプロトコルの一部として認証をサポートするために使用されている場合、DSA用のサブグループサイズは、含まれています。 DSA弾性率はDH弾性率と同じ長さでなければならないが、「Q」のサブグループの大きさにも関連しています。"
    },
    {
      "indent": 3,
      "text": "+-------------+-----------+--------------+--------------+\n| System      |           |              |              |\n| requirement | Symmetric | RSA or DH    | DSA subgroup |\n| for attack  | key size  | modulus size | size         |\n| resistance  | (bits)    | (bits)       | (bits)       |\n| (bits)      |           |              |              |\n+-------------+-----------+--------------+--------------+\n|     70      |     70    |      947     |     129      |\n|     80      |     80    |     1228     |     148      |\n|     90      |     90    |     1553     |     167      |\n|    100      |    100    |     1926     |     186      |\n|    150      |    150    |     4575     |     284      |\n|    200      |    200    |     8719     |     383      |\n|    250      |    250    |    14596     |     482      |\n+-------------+-----------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.1. TWIRL Correction",
      "section_title": true,
      "ja": "5.1。 TWIRL修正"
    },
    {
      "indent": 3,
      "text": "If the TWIRL machine becomes a reality, and if there are advances in parallelism for row reduction in factoring, then conservative estimates would subtract about 11 bits from the system security column of the table. Thus, in order to get 89 bits of security, one would need an RSA modulus of about 1900 bits.",
      "ja": "TWIRL機が現実となり、ファクタリングの行低減のための並列処理の進歩がある場合、保守的な推定値は、テーブルのシステム・セキュリティ・カラムから約11ビットを引くかどう。このように、セキュリティの89ビットを得るために、1を約1900ビットのRSAモジュラスが必要になります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The equations and values given in this document are meant to be as accurate as possible, based on the state of the art in general purpose computers at the time that this document is being written. No predictions can be completely accurate, and the formulas given here are not meant to be definitive statements of fact about cryptographic strengths. For example, some of the empirical results used in calibrating the formulas in this document are probably not completely accurate, and this inaccuracy affects the estimates. It is the authors' hope that the numbers presented here vary from real world experience as little as possible.",
      "ja": "この文書で与えられる式と値は、この文書が書かれている時間に、汎用コンピュータにおける技術の状態に基づいて、可能な限り正確であることを意味しています。いかなる予測が完全に正確になることはできませんし、ここで与えられた式は、暗号強みに関する事実の決定的な文を意味するものではありません。たとえば、この文書の数式を校正に使用する実証結果の一部は、おそらく完全に正確ではありませんが、この不正確さは見積もりに影響を与えます。これは、ここに示さ数値は、できるだけ現実世界の経験から変化することを作者の希望です。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Informational References",
      "section_title": true,
      "ja": "7.1。情報の参照"
    },
    {
      "indent": 3,
      "text": "[DL] Dodson, B. and A. K. Lenstra, NFS with four large primes: an explosive experiment, Proceedings Crypto 95, Lecture Notes in Comput. Sci. 963, (1995) 372-385.",
      "ja": "爆発実験、議事クリプト95、Computに講義ノート：フォー大きな素数と[DL]ドッドソン、B.、およびA. K. Lenstra、NFS。 SCI。 963、（1995）372から385。"
    },
    {
      "indent": 3,
      "text": "[ECS] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[ECS]イーストレイク、D.、クロッカー、S.とJ.シラー、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[GIL98] Cracking DES: Secrets of Encryption Research, Wiretap Politics & Chip Design , Electronic Frontier Foundation, John Gilmore (Ed.), 272 pages, May 1998, O'Reilly & Associates; ISBN: 1565925203",
      "ja": "[GIL98]クラックDES：暗号研究と盗聴政策＆チップ設計、電子フロンティア財団（EFF）、ジョン・ギルモアの秘密（エド）、272頁、1998年5月、オライリー＆アソシエーツ。 ISBN：1565925203"
    },
    {
      "indent": 3,
      "text": "[GOR93] Gordon, D., \"Discrete logarithms in GF(p) using the number field sieve\", SIAM Journal on Discrete Mathematics, 6 (1993), 124-138.",
      "ja": "【GOR93]ゴードン、D.、離散数学、6（1993）、124~138に、SIAMジャーナル \"ナンバーフィールドふるいを用いてGF（P）における離散対数\"。"
    },
    {
      "indent": 3,
      "text": "[LEN93] Lenstra, A. K. and H. W. Lenstra, Jr. (eds), The development of the number field sieve, Lecture Notes in Math, 1554, Springer Verlag, Berlin, 1993.",
      "ja": "【LEN93] Lenstra、A. K.及びH. W. Lenstra、ジュニア（編）、番号フィールドふるいの開発は、数学、1554年、シュプリンガーフェアラーク、ベルリン、1993年に注意を講義します。"
    },
    {
      "indent": 3,
      "text": "[MH81] Merkle, R.C., and Hellman, M., \"On the Security of Multiple Encryption\", Communications of the ACM, v. 24 n. 7, 1981, pp. 465-467.",
      "ja": "\"複数の暗号化のセキュリティに\" [MH81]マークル、R.C.、及びヘルマン、M.、ACMの通信、V。24、N。 7、1981、頁465から467まで。"
    },
    {
      "indent": 3,
      "text": "[ODL95] RSA Labs Cryptobytes, Volume 1, No. 2 - Summer 1995; The Future of Integer Factorization, A. M. Odlyzko",
      "ja": "【ODL95] RSA研究所Cryptobytes、第1巻、第2号 - 夏1995;整数の因数分解の未来、A. M. Odlyzko"
    },
    {
      "indent": 3,
      "text": "[ODL99] A. M. Odlyzko, Discrete logarithms: The past and the future, Designs, Codes, and Cryptography (1999).",
      "ja": "【ODL99] A. M. Odlyzko、離散対数：過去と未来、デザイン、コード、及び暗号化（1999）。"
    },
    {
      "indent": 3,
      "text": "[POL78] J. Pollard, \"Monte Carlo methods for index computation mod p\", Mathematics of Computation, 32 (1978), 918-924.",
      "ja": "[POL78] J.ポラード、 \"指標算出MOD pのモンテカルロ法\"、計算、32（1978）、918から924までの数学。"
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "ja": "[RFC2409]ハーキンとD.とD.カレル、 \"インターネットキー交換（IKE）\"、RFC 2409、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[SCH95] R. Schroeppel, et al., Fast Key Exchange With Elliptic Curve Systems, In Don Coppersmith, editor, Advances in Cryptology -- CRYPTO 31 August 1995. Springer-Verlag",
      "ja": "[SCH95] R. Schroeppel、ら、ドン・コッパースミス、エディタで楕円曲線システムズ、暗号学の進歩により、高速鍵交換 - 。CRYPTO 1995年8月31日シュプリンガー・フェアラーク"
    },
    {
      "indent": 3,
      "text": "[SHAMIR03] Shamir, Adi and Eran Tromer, \"Factoring Large Numbers with the TWIRL Device\", Advances in Cryptology - CRYPTO 2003, Springer, Lecture Notes in Computer Science 2729.",
      "ja": "コンピュータサイエンス2729でCRYPTO 2003、スプリンガー、講義ノート - 、暗号学の進歩「TWIRLデバイスで多数のファクタリング」[SHAMIR03]シャミール、アディとエランTromer、。"
    },
    {
      "indent": 3,
      "text": "[SIL00] R. D. Silverman, RSA Laboratories Bulletin, Number 13 - April 2000, A Cost-Based Security Analysis of Symmetric and Asymmetric Key Lengths",
      "ja": "[SIL00] R. D.シルバーマン、RSA研究所紀要数13  -  2000年4月、対称のコストベース・セキュリティの分析と非対称キーの長さ"
    },
    {
      "indent": 3,
      "text": "[SILIEEE99] R. D. Silverman, \"The Mythical MIPS Year\", IEEE Computer, August 1999.",
      "ja": "[SILIEEE99] R. D.シルバー、 \"神話MIPS年\"、IEEEコンピュータ、1999年8月。"
    },
    {
      "indent": 0,
      "text": "8. Authors' Addresses",
      "section_title": true,
      "ja": "8.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hilarie Orman Purple Streak Development 500 S. Maple Dr. Salem, UT 84653",
      "ja": "ヒラリーオーマンパープルストリーク開発500 S.メープル博士セーラム、UT 84653"
    },
    {
      "indent": 3,
      "text": "EMail: hilarie@purplestreak.com and ho@alum.mit.edu",
      "ja": "電子メール：hilarie@purplestreak.comとho@alum.mit.edu"
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium 127 Segre Place Santa Cruz, CA 95060 USA",
      "ja": "ポール・ホフマンVPNコンソーシアムセグレ127場所サンタクルス、CA 95060 USA"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "ja": "メールアドレス：paul.hoffman@vpnc.org"
    },
    {
      "indent": 0,
      "text": "9. Full Copyright Statement",
      "section_title": true,
      "ja": "9.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "著作権（C）インターネット協会（2004）。この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}