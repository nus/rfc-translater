{
  "title": {
    "text": "RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)",
    "ja": "RFC 3489 - STUN  - ネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサルは、翻訳者（NATを）に対処します"
  },
  "number": 3489,
  "created_at": "2019-10-29 04:33:47.795833+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       J. Rosenberg\nRequest for Comments: 3489                                 J. Weinberger\nCategory: Standards Track                                    dynamicsoft\n                                                              C. Huitema\n                                                               Microsoft\n                                                                 R. Mahy\n                                                                   Cisco\n                                                              March 2003",
      "raw": true
    },
    {
      "indent": 8,
      "text": "STUN - Simple Traversal of User Datagram Protocol (UDP)\n       Through Network Address Translators (NATs)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs) (STUN) is a lightweight protocol that allows applications to discover the presence and types of NATs and firewalls between them and the public Internet. It also provides the ability for applications to determine the public Internet Protocol (IP) addresses allocated to them by the NAT. STUN works with many existing NATs, and does not require any special behavior from them. As a result, it allows a wide variety of applications to work through existing NAT infrastructure.",
      "ja": "ネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサル翻訳者（NATのを）アドレス（STUN）は、アプリケーションがそれらと公共のインターネット間のNATやファイアウォールの有無と種類を発見することを可能にする軽量なプロトコルです。また、NATによってそれらに割り当てられた公共のインターネットプロトコル（IP）アドレスを決定するアプリケーションのための機能を提供します。 STUNは多くの既存のNATで動作し、それらからの特別な動作を必要としません。その結果、既存のNATのインフラストラクチャを介して動作するため、多種多様なアプリケーションを可能にします。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.   Applicability Statement ...................................    3\n2.   Introduction ..............................................    3\n3.   Terminology ...............................................    4\n4.   Definitions ...............................................    5\n5.   NAT Variations ............................................    5\n6.   Overview of Operation .....................................    6\n7.   Message Overview ..........................................    8\n8.   Server Behavior ...........................................   10\n     8.1   Binding Requests ....................................   10",
      "raw": true
    },
    {
      "indent": 3,
      "text": "     8.2   Shared Secret Requests ..............................   13\n9.   Client Behavior ...........................................   14\n     9.1   Discovery ...........................................   15\n     9.2   Obtaining a Shared Secret ...........................   15\n     9.3   Formulating the Binding Request .....................   17\n     9.4   Processing Binding Responses ........................   17\n10.  Use Cases .................................................   19\n     10.1  Discovery Process ...................................   19\n     10.2  Binding Lifetime Discovery ..........................   21\n     10.3  Binding Acquisition .................................   23\n11.  Protocol Details ..........................................   24\n     11.1  Message Header ......................................   25\n     11.2  Message Attributes ..................................   26\n           11.2.1  MAPPED-ADDRESS ..............................   27\n           11.2.2  RESPONSE-ADDRESS ............................   27\n           11.2.3  CHANGED-ADDRESS .............................   28\n           11.2.4  CHANGE-REQUEST ..............................   28\n           11.2.5  SOURCE-ADDRESS ..............................   28\n           11.2.6  USERNAME ....................................   28\n           11.2.7  PASSWORD ....................................   29\n           11.2.8  MESSAGE-INTEGRITY ...........................   29\n           11.2.9  ERROR-CODE ..................................   29\n           11.2.10 UNKNOWN-ATTRIBUTES ..........................   31\n           11.2.11 REFLECTED-FROM ..............................   31\n12.  Security Considerations ...................................   31\n     12.1  Attacks on STUN .....................................   31\n           12.1.1  Attack I: DDOS Against a Target .............   32\n           12.1.2  Attack II: Silencing a Client ...............   32\n           12.1.3  Attack III: Assuming the Identity of a Client   32\n           12.1.4  Attack IV: Eavesdropping ....................   33\n     12.2  Launching the Attacks ...............................   33\n           12.2.1  Approach I: Compromise a Legitimate\n                   STUN Server .................................   33\n           12.2.2  Approach II: DNS Attacks ....................   34\n           12.2.3  Approach III: Rogue Router or NAT ...........   34\n           12.2.4  Approach IV: MITM ...........................   35\n           12.2.5  Approach V: Response Injection Plus DoS .....   35\n           12.2.6  Approach VI: Duplication ....................   35\n     12.3  Countermeasures .....................................   36\n     12.4  Residual Threats ....................................   37\n13.  IANA Considerations .......................................   38\n14.  IAB Considerations ........................................   38\n     14.1  Problem Definition ..................................   38\n     14.2  Exit Strategy .......................................   39\n     14.3  Brittleness Introduced by STUN ......................   40\n     14.4  Requirements for a Long Term Solution ...............   42\n     14.5  Issues with Existing NAPT Boxes .....................   43\n     14.6  In Closing ..........................................   43",
      "raw": true
    },
    {
      "indent": 3,
      "text": "15.  Acknowledgments ...........................................   44\n16.  Normative References ......................................   44\n17.  Informative References ....................................   44\n18.  Authors' Addresses ........................................   46\n19.  Full Copyright Statement...................................   47",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Applicability Statement",
      "section_title": true,
      "ja": "1.適用性に関する声明"
    },
    {
      "indent": 3,
      "text": "This protocol is not a cure-all for the problems associated with NAT. It does not enable incoming TCP connections through NAT. It allows incoming UDP packets through NAT, but only through a subset of existing NAT types. In particular, STUN does not enable incoming UDP packets through symmetric NATs (defined below), which are common in large enterprises. STUN's discovery procedures are based on assumptions on NAT treatment of UDP; such assumptions may prove invalid down the road as new NAT devices are deployed. STUN does not work when it is used to obtain an address to communicate with a peer which happens to be behind the same NAT. STUN does not work when the STUN server is not in a common shared address realm. For a more complete discussion of the limitations of STUN, see Section 14.",
      "ja": "このプロトコルは、NATに関連する問題のための万能薬ではありません。それは、NAT経由の着信TCP接続を有効にしません。それはしかし、既存のNATタイプのサブセットを通じて、NAT経由の着信UDPパケットを許可します。具体的には、STUNは、大企業で一般的な対称のNAT（以下に定義）を介して受信UDPパケットを有効にしません。 STUNの発見手順は、UDPのNAT治療上の仮定に基づいています。新しいNATデバイスが展開されているような仮定は道の下の無効を証明することがあります。同じNATの背後にあることを起こるピアと通信するためのアドレスを取得するために使用される場合STUNは動作しません。 STUNサーバーは、共通の共有アドレスレルムでないときにSTUNは動作しません。 STUNの制限のより完全な議論については、第14章を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Introduction",
      "section_title": true,
      "ja": "2.はじめに"
    },
    {
      "indent": 3,
      "text": "Network Address Translators (NATs), while providing many benefits, also come with many drawbacks. The most troublesome of those drawbacks is the fact that they break many existing IP applications, and make it difficult to deploy new ones. Guidelines have been developed [8] that describe how to build \"NAT friendly\" protocols, but many protocols simply cannot be constructed according to those guidelines. Examples of such protocols include almost all peer-to-peer protocols, such as multimedia communications, file sharing and games.",
      "ja": "ネットワークアドレス変換器（NAT）、多くの欠点が付属しても、多くの利点を提供しながら。これらの欠点の最も厄介は、彼らは多くの既存のIPアプリケーションを破壊し、それが困難な新しいものを導入するために作るという事実です。ガイドラインは、[8]「NATに優しい」プロトコルを構築する方法について説明しますが、多くのプロトコルは、単にこれらのガイドラインに従って構築することはできませんが開発されています。そのようなプロトコルの例としては、マルチメディア通信、ファイル共有やゲームなど、ほぼすべてのピア・ツー・ピア・プロトコルが含まれます。"
    },
    {
      "indent": 3,
      "text": "To combat this problem, Application Layer Gateways (ALGs) have been embedded in NATs. ALGs perform the application layer functions required for a particular protocol to traverse a NAT. Typically, this involves rewriting application layer messages to contain translated addresses, rather than the ones inserted by the sender of the message. ALGs have serious limitations, including scalability, reliability, and speed of deploying new applications. To resolve these problems, the Middlebox Communications (MIDCOM) protocol is being developed [9]. MIDCOM allows an application entity, such as an end client or network server of some sort (like a Session Initiation Protocol (SIP) proxy [10]) to control a NAT (or firewall), in order to obtain NAT bindings and open or close pinholes. In this way, NATs and applications can be separated once more, eliminating the need for embedding ALGs in NATs, and resolving the limitations imposed by current architectures.",
      "ja": "この問題に対処するために、アプリケーションレイヤゲートウェイ（ALG）は、NATの中に埋め込まれています。 ALGは、NATを横断する特定のプロトコルのために必要なアプリケーション層の機能を実行します。典型的には、これは、どれがメッセージの送信者によって挿入されたのではなく、変換されたアドレスを含むようにアプリケーション層メッセージを書き換えることを含みます。 ALGは、スケーラビリティ、信頼性、および新しいアプリケーションの展開の速さなど、重大な制限を、持っています。これらの問題を解決するために、ミドル・コミュニケーションズ（MIDCOM）プロトコルが開発されている[9]。 MIDCOMはNATバインディングと開閉を得るためには、NAT（またはファイアウォール）を制御する（セッション開始プロトコル（SIP）プロキシ[10]のように）そのようなある種のエンドクライアントまたはネットワークサーバーとして、アプリケーション・エンティティを可能にしますピンホール。このように、NATのアプリケーションはNATの内のALGを埋め込み、そして現在のアーキテクチャによって課される制限を解決するための必要性を排除し、再び分離することができます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, MIDCOM requires upgrades to existing NAT and firewalls, in addition to application components. Complete upgrades of these NAT and firewall products will take a long time, potentially years. This is due, in part, to the fact that the deployers of NAT and firewalls are not the same people who are deploying and using applications. As a result, the incentive to upgrade these devices will be low in many cases. Consider, for example, an airport Internet lounge that provides access with a NAT. A user connecting to the NATed network may wish to use a peer-to-peer service, but cannot, because the NAT doesn't support it. Since the administrators of the lounge are not the ones providing the service, they are not motivated to upgrade their NAT equipment to support it, using either an ALG, or MIDCOM.",
      "ja": "残念ながら、MIDCOMはアプリケーションコンポーネントに加えて、既存のNATやファイアウォールへのアップグレードが必要です。これらのNATやファイアウォール製品の完全なアップグレードは、潜在的に年、長い時間がかかります。これは、NATやファイアウォールのデプロイヤを展開し、アプリケーションを使用している同じ人ではないという事実のために、部分的に起因します。その結果、これらのデバイスをアップグレードする動機は、多くの場合に低くなります。例えば、NATとのアクセスを提供し、空港インターネットラウンジを考えてみましょう。 NATがそれをサポートしていないため、NAT変換ネットワークに接続しているユーザーは、ピア・ツー・ピアのサービスを利用したいが、できないことがあります。ラウンジの管理者がサービスを提供するものではありませんので、彼らはALG、またはMIDCOMのいずれかを使用して、それをサポートするために、彼らのNAT機器をアップグレードする動機づけではありません。"
    },
    {
      "indent": 3,
      "text": "Another problem is that the MIDCOM protocol requires that the agent controlling the middleboxes know the identity of those middleboxes, and have a relationship with them which permits control. In many configurations, this will not be possible. For example, many cable access providers use NAT in front of their entire access network. This NAT could be in addition to a residential NAT purchased and operated by the end user. The end user will probably not have a control relationship with the NAT in the cable access network, and may not even know of its existence.",
      "ja": "もう一つの問題はMIDCOMプロトコルがミドルボックスを制御するエージェントは、これらのミドルボックスの正体を知っている、と制御を可能にする彼らと関係を持っていることを必要とすることです。多くの構成では、これはできません。例えば、多くのケーブルアクセスプロバイダーは、全体のアクセス網の目の前でNATを使用しています。このNATは、エンドユーザが購入し、運営の住宅NATに加えて、可能性があります。エンドユーザーは、おそらくケーブルのアクセスネットワーク内のNATとの制御関係を持っていない、とさえその存在を知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Many existing proprietary protocols, such as those for online games (such as the games described in RFC 3027 [11]) and Voice over IP, have developed tricks that allow them to operate through NATs without changing those NATs. This document is an attempt to take some of those ideas, and codify them into an interoperable protocol that can meet the needs of many applications.",
      "ja": "、多くのこのような（例えばRFC 3027で説明ゲームのような[11]）は、オンラインゲームのためのものと、既存の専用プロトコル、およびボイスオーバーIPは、彼らがそれらのNATを変更することなく、NATを介して動作することを可能にするトリックを開発しました。この文書では、これらのアイデアのいくつかを取り、多くのアプリケーションのニーズを満たすことができる、相互運用可能なプロトコルにそれらを体系化しようとする試みです。"
    },
    {
      "indent": 3,
      "text": "The protocol described here, Simple Traversal of UDP Through NAT (STUN), allows entities behind a NAT to first discover the presence of a NAT and the type of NAT, and then to learn the addresses bindings allocated by the NAT. STUN requires no changes to NATs, and works with an arbitrary number of NATs in tandem between the application entity and the public Internet.",
      "ja": "プロトコルは、ここでNATを通じUDPのシンプルトラバーサル（STUN）を説明し、NATの背後にある実体は、最初のNATの存在とNATの種類を発見し、その後、NATによって割り当てられたアドレスのバインディングを学習することができます。 STUNは、NATを変更する必要はありませんし、アプリケーション実体と公共のインターネット間のタンデムでのNATの任意の数で動作します。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119 [1] and indicate requirement levels for compliant STUN implementations.",
      "ja": "この文書では、キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、および \"オプション\" BCP 14、RFC 2119に記載されているように、[1]に解釈されるべきであり、対応STUNの実装に対する要求レベルを示します。"
    },
    {
      "indent": 0,
      "text": "4. Definitions",
      "section_title": true,
      "ja": "4.定義"
    },
    {
      "indent": 3,
      "text": "STUN Client: A STUN client (also just referred to as a client) is an entity that generates STUN requests. A STUN client can execute on an end system, such as a user's PC, or can run in a network element, such as a conferencing server.",
      "ja": "STUNクライアント：STUNクライアントは、（また、単にクライアントとも呼ばれる）STUN要求を生成するエンティティです。 STUNクライアントは、ユーザのPCとして、エンド・システム上で実行することができ、あるいは、そのような会議サーバとして、ネットワーク要素で実行することができます。"
    },
    {
      "indent": 3,
      "text": "STUN Server: A STUN Server (also just referred to as a server) is an entity that receives STUN requests, and sends STUN responses. STUN servers are generally attached to the public Internet.",
      "ja": "STUNサーバ：STUNサーバーは、（また、単にサーバーとも呼ばれる）STUN要求を受信エンティティであり、そしてSTUN応答を送信します。 STUNサーバは、一般的に、公共のインターネットに接続されています。"
    },
    {
      "indent": 0,
      "text": "5. NAT Variations",
      "section_title": true,
      "ja": "5. NATバリエーション"
    },
    {
      "indent": 3,
      "text": "It is assumed that the reader is familiar with NATs. It has been observed that NAT treatment of UDP varies among implementations. The four treatments observed in implementations are:",
      "ja": "読者がNATを精通しているものとします。 UDPのNAT処理が実装ごとに異なることが観察されています。実装において観察された4つの処理は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Full Cone: A full cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Furthermore, any external host can send a packet to the internal host, by sending a packet to the mapped external address.",
      "ja": "フルコーン：フルコーンNATは、同じ内部IPアドレスとポートからのすべての要求が同じ外部IPアドレスとポートにマッピングされているものです。また、外部のホストは、マップされた外部アドレスにパケットを送信することにより、内部ホストにパケットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Restricted Cone: A restricted cone NAT is one where all requests from the same internal IP address and port are mapped to the same external IP address and port. Unlike a full cone NAT, an external host (with IP address X) can send a packet to the internal host only if the internal host had previously sent a packet to IP address X.",
      "ja": "制限付きコーン：制限コーンNATは、同じ内部IPアドレスとポートからのすべての要求が同じ外部IPアドレスとポートにマッピングされているものです。内部ホストが以前にIPアドレスXにパケットを送信した場合にのみ、内部ホストにパケットを送信することができます（IPアドレスXを持つ）フルコーンNAT、外部ホストとは異なり、"
    },
    {
      "indent": 3,
      "text": "Port Restricted Cone: A port restricted cone NAT is like a restricted cone NAT, but the restriction includes port numbers. Specifically, an external host can send a packet, with source IP address X and source port P, to the internal host only if the internal host had previously sent a packet to IP address X and port P.",
      "ja": "ポート制限コーン：ポート制限付きコーンNATは制限コーンNATに似ているが、制限はポート番号が含まれています。具体的には、外部ホストは内部ホストが以前にIPアドレスX、ポートPにパケットを送信した場合にのみ、内部ホストに、送信元IPアドレスXおよびソースポートPと、パケットを送信することができます"
    },
    {
      "indent": 3,
      "text": "Symmetric: A symmetric NAT is one where all requests from the same internal IP address and port, to a specific destination IP address and port, are mapped to the same external IP address and port. If the same host sends a packet with the same source address and port, but to a different destination, a different mapping is used. Furthermore, only the external host that receives a packet can send a UDP packet back to the internal host.",
      "ja": "対称型：対称型NATは、特定の宛先IPアドレスおよびポートに同じ内部IPアドレスおよびポートからのすべてのリクエストは、同じ外部IPアドレスおよびポートにマップされるものです。同じホストが同じ送信元アドレスとポートを持つパケットを送信すると、しかし、別の宛先に、異なるマッピングが使用されています。さらに、パケットを受信した場合にのみ、外部のホストは、バック内部ホストにUDPパケットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Determining the type of NAT is important in many cases. Depending on what the application wants to do, it may need to take the particular behavior into account.",
      "ja": "NATの種類を決定することは、多くの場合に重要です。アプリケーションが何をしたいのかに応じて、それは考慮に特定の行動を取る必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "6. Overview of Operation",
      "section_title": true,
      "ja": "操作の概要6。"
    },
    {
      "indent": 3,
      "text": "This section is descriptive only. Normative behavior is described in Sections 8 and 9.",
      "ja": "このセクションでは、唯一の記述です。規範的な動作は、セクション8および9に記載されています。"
    },
    {
      "indent": 25,
      "text": "   /-----\\\n // STUN  \\\\\n|   Server  |\n \\\\       //\n   \\-----/",
      "raw": true
    },
    {
      "indent": 7,
      "text": "                +--------------+             Public Internet\n................|     NAT 2    |.......................\n                +--------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "                +--------------+             Private NET 2\n................|     NAT 1    |.......................\n                +--------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "   /-----\\\n // STUN  \\\\\n|   Client  |\n \\\\       //               Private NET 1\n   \\-----/",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 1: STUN Configuration",
      "ja": "図1：STUN設定"
    },
    {
      "indent": 3,
      "text": "The typical STUN configuration is shown in Figure 1. A STUN client is connected to private network 1. This network connects to private network 2 through NAT 1. Private network 2 connects to the public Internet through NAT 2. The STUN server resides on the public Internet.",
      "ja": "典型的なSTUN構成はA STUNクライアントがこのネットワークはNAT 1.プライベートネットワーク2を介してプライベートネットワーク2に接続するプライベートネットワーク1に接続されている。図1に示されているSTUNサーバーは、パブリックに常駐NAT 2を介して公衆インターネットに接続しますインターネット。"
    },
    {
      "indent": 3,
      "text": "STUN is a simple client-server protocol. A client sends a request to a server, and the server returns a response. There are two types of requests - Binding Requests, sent over UDP, and Shared Secret Requests, sent over TLS [2] over TCP. Shared Secret Requests ask the server to return a temporary username and password. This username and password are used in a subsequent Binding Request and Binding Response, for the purposes of authentication and message integrity.",
      "ja": "STUNは、単純なクライアント・サーバ・プロトコルです。クライアントがサーバに要求を送信し、サーバは応答を返します。 UDP経由で送信されるバインディング要求、およびTLSを介して送信される共有シークレット要求、TCPの上に[2]  -  2つの要求の種類があります。共有シークレット要求は、一時的なユーザ名とパスワードを返すようにサーバーを頼みます。このユーザ名とパスワードは、認証とメッセージの完全性のために、その後のバインディング要求とバインディングレスポンスに使用されています。"
    },
    {
      "indent": 3,
      "text": "Binding requests are used to determine the bindings allocated by NATs. The client sends a Binding Request to the server, over UDP. The server examines the source IP address and port of the request, and copies them into a response that is sent back to the client. There are some parameters in the request that allow the client to ask that the response be sent elsewhere, or that the server send the response from a different address and port. There are attributes for providing message integrity and authentication.",
      "ja": "結合要求は、NATをによって割り当てられたバインディングを決定するために使用されます。クライアントがUDP上で、サーバーへのバインディング要求を送信します。サーバーは、送信元IPアドレスとポートリクエストの、およびクライアントに返送される応答にコピーし、それらを調べます。クライアントは応答が別の場所に送信されていること、またはサーバが別のアドレスとポートからの応答を送信することを依頼することができリクエストでいくつかのパラメータがあります。メッセージの整合性と認証を提供するための属性があります。"
    },
    {
      "indent": 3,
      "text": "The trick is using STUN to discover the presence of NAT, and to learn and use the bindings they allocate.",
      "ja": "トリックはNATの存在を発見するためにSTUNを使用している、と彼らは割り当てるバインディングを学習し、使用します。"
    },
    {
      "indent": 3,
      "text": "The STUN client is typically embedded in an application which needs to obtain a public IP address and port that can be used to receive data. For example, it might need to obtain an IP address and port to receive Real Time Transport Protocol (RTP) [12] traffic. When the application starts, the STUN client within the application sends a STUN Shared Secret Request to its server, obtains a username and password, and then sends it a Binding Request. STUN servers can be discovered through DNS SRV records [3], and it is generally assumed that the client is configured with the domain to use to find the STUN server. Generally, this will be the domain of the provider of the service the application is using (such a provider is incented to deploy STUN servers in order to allow its customers to use its application through NAT). Of course, a client can determine the address or domain name of a STUN server through other means. A STUN server can even be embedded within an end system.",
      "ja": "STUNクライアントは、典型的には、データを受信するために使用することができるパブリックIPアドレスとポートを取得する必要があるアプリケーションに埋め込まれています。例えば、それはリアルタイムトランスポートプロトコル（RTP）[12]トラフィックを受信するためにIPアドレスとポートを取得する必要があります。アプリケーションが起動すると、アプリケーション内のSTUNクライアントは、そのサーバへのSTUN共有秘密リクエストを送信し、ユーザー名とパスワードを取得し、それをバインディング要求を送信します。 STUNサーバーは、DNS SRVレコード[3]で発見することができ、一般的に、クライアントがSTUNサーバーを見つけるために使用するドメインで構成されているものとします。一般的に、これは、アプリケーションが使用しているサービスのプロバイダのドメインになります（例えば、プロバイダは、その顧客がNATを通じてアプリケーションを使用することを可能にするためにSTUNサーバーを展開するincentedされます）。もちろん、クライアントは、他の手段を通じてSTUNサーバーのアドレスまたはドメイン名を決定することができます。 STUNサーバもエンドシステム内に埋め込むことができます。"
    },
    {
      "indent": 3,
      "text": "The STUN Binding Request is used to discover the presence of a NAT, and to discover the public IP address and port mappings generated by the NAT. Binding Requests are sent to the STUN server using UDP. When a Binding Request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server. As a result, the source address of the request received by the server will be the mapped address created by the NAT closest to the server. The STUN server copies that source IP address and port into a STUN Binding Response, and sends it back to the source IP address and port of the STUN request. For all of the NAT types above, this response will arrive at the STUN client.",
      "ja": "STUNバインディング要求はNATの存在を発見するために使用され、NATによって生成されたパブリックIPアドレスとポートマッピングを発見します。バインド要求は、UDPを使用して、STUNサーバに送信されます。バインディング要求がSTUNサーバに到着すると、それはSTUNクライアントとSTUNサーバー間の1つの以上のNATを通過している可能性があります。その結果、サーバーが受信したリクエストの送信元アドレスは、サーバーに最も近いNATによって作成されたマップされたアドレスになります。 STUNサーバーのコピー元IPアドレスとポートSTUNバインディングレスポンスに、バックSTUN要求の送信元IPアドレスとポートに送信します。上記のNATタイプのすべてのために、この応答は、STUNクライアントに到着します。"
    },
    {
      "indent": 3,
      "text": "When the STUN client receives the STUN Binding Response, it compares the IP address and port in the packet with the local IP address and port it bound to when the request was sent. If these do not match, the STUN client is behind one or more NATs. In the case of a full-cone NAT, the IP address and port in the body of the STUN response are public, and can be used by any host on the public Internet to send packets to the application that sent the STUN request. An application need only listen on the IP address and port from which the STUN request was sent. Any packets sent by a host on the public Internet to the public address and port learned by STUN will be received by the application.",
      "ja": "STUNクライアントはSTUNバインディングレスポンスを受信すると、それは、要求が送信されたときにバインドされたローカルIPアドレスとポートを持つパケットにIPアドレスとポートを比較します。これらが一致しない場合は、STUNクライアントは、一つ以上のNATの背後にあります。フルコーンNATの場合は、STUNレスポンスのボディにIPアドレスとポートが公開され、そしてSTUN要求を送信したアプリケーションにパケットを送信するために公共のインターネット上の任意のホストで使用することができます。アプリケーションは、STUNリクエストを送信したIPアドレスとポートをリッスンにのみ必要です。 STUNによって学習されたパブリックアドレスとポートに公共のインターネット上のホストによって送信されたパケットは、アプリケーションによって受信されます。"
    },
    {
      "indent": 3,
      "text": "Of course, the host may not be behind a full-cone NAT. Indeed, it doesn't yet know what type of NAT it is behind. To determine that, the client uses additional STUN Binding Requests. The exact procedure is flexible, but would generally work as follows. The client would send a second STUN Binding Request, this time to a different IP address, but from the same source IP address and port. If the IP address and port in the response are different from those in the first response, the client knows it is behind a symmetric NAT. To determine if it's behind a full-cone NAT, the client can send a STUN Binding Request with flags that tell the STUN server to send a response from a different IP address and port than the request was received on. In other words, if the client sent a Binding Request to IP address/port A/B using a source IP address/port of X/Y, the STUN server would send the Binding Response to X/Y using source IP address/port C/D. If the client receives this response, it knows it is behind a full cone NAT.",
      "ja": "もちろん、ホストは、フルコーンNATの背後ではないかもしれません。確かに、それはまだそれが背後にあるNATの種類を知りません。それを判断するには、クライアントが追加STUNバインディング要求を使用しています。正確な手順は、柔軟であるが、次のように一般的に働くだろう。クライアントは、別のIPアドレスに、同じ送信元IPアドレスとポートから、この時間を要求するバインディング二STUNを送信します。応答内のIPアドレスとポートは、最初の応答とは異なっている場合、クライアントは、それは対称NATの背後にあることを知っています。それはフルコーンNATの背後にあるかどうかを判断するには、クライアントは、要求が受信されたものとは異なるIPアドレスとポートからの応答を送信するためにSTUNサーバーを伝えるフラグでSTUNバインディング要求を送信することができます。クライアントは、X / Yの送信元IPアドレス/ポートを使用してIPアドレス/ポートA / Bとの結合要求を送信した言い換えれば、STUNサーバは、送信元IPアドレス/ポートCを使用して、X / Yへの結合応答を送信することになります/ D。クライアントは、この応答を受信した場合、それはフルコーンNATの背後にあることを知っています。"
    },
    {
      "indent": 3,
      "text": "STUN also allows the client to ask the server to send the Binding Response from the same IP address the request was received on, but with a different port. This can be used to detect whether the client is behind a port restricted cone NAT or just a restricted cone NAT.",
      "ja": "STUNはまた、要求が受信されたクライアントが同じIPアドレスからのBindingレスポンスを送信するためにサーバーを依頼することができますが、別のポートを持ちます。これは、クライアントがポート制限付きコーンNATまたは単に制限されたコーンNATの背後にあるかどうかを検出するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the configuration in Figure 1 is not the only permissible configuration. The STUN server can be located anywhere, including within another client. The only requirement is that the STUN server is reachable by the client, and if the client is trying to obtain a publicly routable address, that the server reside on the public Internet.",
      "ja": "図1の構成にのみ許容構成ではないことに留意すべきです。 STUNサーバは別のクライアントの中に含めて、任意の場所に配置することができます。サーバーがパブリックインターネット上に存在することを、唯一の要件は、STUNサーバーがクライアントから到達可能であるということです、そしてクライアントがパブリックにルーティング可能なアドレスを取得しようとしている場合。"
    },
    {
      "indent": 0,
      "text": "7. Message Overview",
      "section_title": true,
      "ja": "7.メッセージの概要"
    },
    {
      "indent": 3,
      "text": "STUN messages are TLV (type-length-value) encoded using big endian (network ordered) binary. All STUN messages start with a STUN header, followed by a STUN payload. The payload is a series of STUN attributes, the set of which depends on the message type. The STUN header contains a STUN message type, transaction ID, and length. The message type can be Binding Request, Binding Response, Binding Error Response, Shared Secret Request, Shared Secret Response, or Shared Secret Error Response. The transaction ID is used to correlate requests and responses. The length indicates the total length of the STUN payload, not including the header. This allows STUN to run over TCP. Shared Secret Requests are always sent over TCP (indeed, using TLS over TCP).",
      "ja": "STUNメッセージは、TLV（タイプ - 長さ - 値）がビッグエンディアン（ネットワークは、順序付けられた）バイナリを使用して符号化されます。すべてのSTUNメッセージは、STUNペイロードが続く、STUNヘッダで始まります。ペイロードは、STUN属性一連のメッセージタイプに依存するのセットです。 STUNヘッダーはSTUNメッセージタイプ、トランザクションID、および長さを含みます。メッセージタイプは、エラー応答、共有シークレット要求、共有秘密応答、または共有秘密エラー応答をバインディングレスポンスを、バインディング、バインディング要求することができます。トランザクションIDは、要求と応答を相関させるために使用されています。長さは、ヘッダを含まない、STUNペイロードの全長を示します。これは、STUNはTCP上で実行することができます。共有シークレット要求は常に（TCP上のTLSを使用して、実際に）TCPを介して送信されます。"
    },
    {
      "indent": 3,
      "text": "Several STUN attributes are defined. The first is a MAPPED-ADDRESS attribute, which is an IP address and port. It is always placed in the Binding Response, and it indicates the source IP address and port the server saw in the Binding Request. There is also a RESPONSE-ADDRESS attribute, which contains an IP address and port. The RESPONSE-ADDRESS attribute can be present in the Binding Request, and indicates where the Binding Response is to be sent. It's optional, and when not present, the Binding Response is sent to the source IP address and port of the Binding Request.",
      "ja": "いくつかのSTUN属性が定義されています。最初は、IPアドレスとポートですMAPPED-ADDRESS属性、です。これは常にバインディングレスポンスに配置し、それが元のIPアドレスとポートバインディング要求でサーバーソーを示しています。 IPアドレスとポートを含む応答-ADDRESS属性もあります。 RESPONSE-ADDRESS属性は、バインディング要求中に存在すること、および結合応答が送信される場所を示すことができます。これはオプションだし、存在する場合ではない、バインディングレスポンスは、バインディング要求の送信元のIPアドレスとポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "The third attribute is the CHANGE-REQUEST attribute, and it contains two flags to control the IP address and port used to send the response. These flags are called \"change IP\" and \"change port\" flags. The CHANGE-REQUEST attribute is allowed only in the Binding Request. The \"change IP\" and \"change port\" flags are useful for determining whether the client is behind a restricted cone NAT or restricted port cone NAT. They instruct the server to send the Binding Responses from a different source IP address and port. The CHANGE-REQUEST attribute is optional in the Binding Request.",
      "ja": "第三属性は、CHANGE-REQUEST属性であり、それは、応答を送信するために使用されるIPアドレスとポートを制御するために2つのフラグが含まれています。これらのフラグは、「IPを変更する」とフラグ「ポートを変更」と呼ばれています。 CHANGE-REQUEST属性は唯一のバインディング要求で許可されています。 「変更IP」と「ポート変更」フラグは、クライアントが制限付きコーンNATまたは制限付きポートコーンNATの背後にあるかどうかを決定するために有用です。彼らは、異なる送信元IPアドレスとポートからのBindingレスポンスを送信するために、サーバーに指示します。 CHANGE-REQUEST属性は、バインディング要求ではオプションです。"
    },
    {
      "indent": 3,
      "text": "The fourth attribute is the CHANGED-ADDRESS attribute. It is present in Binding Responses. It informs the client of the source IP address and port that would be used if the client requested the \"change IP\" and \"change port\" behavior.",
      "ja": "第四属性はCHANGED-ADDRESS属性です。これは、バインディングレスポンスに存在しています。これは、クライアントが「変更IP」と「ポート変更」動作を要求した場合に使用される送信元IPアドレスとポートのクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "The fifth attribute is the SOURCE-ADDRESS attribute. It is only present in Binding Responses. It indicates the source IP address and port where the response was sent from. It is useful for detecting twice NAT configurations.",
      "ja": "第五属性は、SOURCE-ADDRESS属性です。これは、バインディングの回答にのみ存在します。これは、応答がから送信された送信元IPアドレスとポートを示します。それは二度NATの設定を検出するために有用です。"
    },
    {
      "indent": 3,
      "text": "The sixth attribute is the USERNAME attribute. It is present in a Shared Secret Response, which provides the client with a temporary username and password (encoded in the PASSWORD attribute). The USERNAME is also present in Binding Requests, serving as an index to the shared secret used for the integrity protection of the Binding Request. The seventh attribute, PASSWORD, is only found in Shared Secret Response messages. The eight attribute is the MESSAGE-INTEGRITY attribute, which contains a message integrity check over the Binding Request or Binding Response.",
      "ja": "第六属性はUSERNAME属性です。これは、（PASSWORD属性でエンコードされた）一時的なユーザ名とパスワードをクライアントに提供し共有秘密レスポンス、中に存在しています。 USERNAMEは、バインディング要求の完全性保護のために使用する共有秘密の指標となる、また、バインド要求に存在しています。第七属性、PASSWORDは、唯一の共有秘密応答メッセージに含まれています。 8つの属性は、バインディング要求またはバインディングレスポンスを介したメッセージの整合性チェックが含まれているMESSAGE-INTEGRITY属性です。"
    },
    {
      "indent": 3,
      "text": "The ninth attribute is the ERROR-CODE attribute. This is present in the Binding Error Response and Shared Secret Error Response. It indicates the error that has occurred. The tenth attribute is the UNKNOWN-ATTRIBUTES attribute, which is present in either the Binding Error Response or Shared Secret Error Response. It indicates the mandatory attributes from the request which were unknown. The eleventh attribute is the REFLECTED-FROM attribute, which is present in Binding Responses. It indicates the IP address and port of the sender of a Binding Request, used for traceability purposes to prevent certain denial-of-service attacks.",
      "ja": "第九の属性は、ERROR-CODE属性です。これは、結合エラーレスポンスと共有シークレットエラー応答で存在しています。これは、発生したエラーを示します。第十属性はUNKNOWN-ATTRIBUTESが結合エラーレスポンスまたは共有秘密エラー応答のいずれかに存在している、属性です。それは知られていなかった要求から必須属性を示します。第十一の属性は、反射からのバインディングレスポンス内に存在する属性。これは、特定のサービス拒否攻撃を防ぐために、トレーサビリティの目的で使用されるバインディング要求の送信元のIPアドレスとポートを示します。"
    },
    {
      "indent": 0,
      "text": "8. Server Behavior",
      "section_title": true,
      "ja": "8.サーバーの動作"
    },
    {
      "indent": 3,
      "text": "The server behavior depends on whether the request is a Binding Request or a Shared Secret Request.",
      "ja": "サーバーの動作は、要求がバインディング要求または共有シークレット要求であるかどうかに依存します。"
    },
    {
      "indent": 0,
      "text": "8.1 Binding Requests",
      "section_title": true,
      "ja": "8.1バインド要求"
    },
    {
      "indent": 3,
      "text": "A STUN server MUST be prepared to receive Binding Requests on four address/port combinations - (A1, P1), (A2, P1), (A1, P2), and (A2, P2). (A1, P1) represent the primary address and port, and these are the ones obtained through the client discovery procedures below. Typically, P1 will be port 3478, the default STUN port. A2 and P2 are arbitrary. A2 and P2 are advertised by the server through the CHANGED-ADDRESS attribute, as described below.",
      "ja": "（A1、P1）、（A2、P1）、（A1、P2）及び（A2、P2） -  STUNサーバーは、4つのアドレス/ポートの組み合わせのバインディング要求を受信するように準備しなければなりません。 （A1、P1）プライマリアドレスとポートを表し、これらは以下のクライアント発見手順を経て得られたものです。一般的に、P1は、デフォルトのSTUNポート3478ポートになります。 A2及びP2は任意です。後述のようにA2及びP2は、CHANGED-ADDRESS属性を介してサーバによってアドバタイズされています。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the server check the Binding Request for a MESSAGE-INTEGRITY attribute. If not present, and the server requires integrity checks on the request, it generates a Binding Error Response with an ERROR-CODE attribute with response code 401. If the MESSAGE-INTEGRITY attribute was present, the server computes the HMAC over the request as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the request. If the USERNAME attribute was not present, the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 432. If the USERNAME is present, but the server doesn't remember the shared secret for that USERNAME (because it timed out, for example), the server MUST generate a Binding Error Response. The Binding Error Response MUST include an ERROR-CODE attribute with response code 430. If the server does know the shared secret, but the computed HMAC differs from the one in the request, the server MUST generate a Binding Error Response with an ERROR-CODE attribute with response code 431. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.",
      "ja": "サーバがMESSAGE-INTEGRITY属性のバインディング要求を確認することをお勧めします。現在、そしてサーバーではありませんが、リクエストに応じて整合性チェックを必要とする場合、それが説明するように、サーバがリクエストを介してHMACを計算し、MESSAGE-INTEGRITY属性が存在した場合はERROR-CODEとの結合エラーレスポンスがレスポンスコード401で属性を生成しセクション11.2.8インチ使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、キーは要求に存在USERNAMEに関連した一つの属性でなければなりません。 USERNAME属性が存在しない場合は、サーバーはバインドエラー応答を生成しなければなりません。 USERNAMEが存在するが、（それは例えば、タイムアウトしたため）、サーバーはそのUSERNAMEの共有秘密を覚えていない場合は、サーバが生成しなければならない結合エラー応答は応答コード432とERROR-CODE属性を含まなければなりませんエラー応答を結合。サーバが共有秘密を知っているんが、計算されたHMACが要求におけるものと異なる場合ERROR-CODEは応答コード430で属性を含まなければならないバインディングエラー応答は、サーバはERROR-CODEとの結合エラーレスポンスを生成しなければなりません結合エラーレスポンスがバインディング要求がどこから来たIPアドレスとポートに送信され、そしてバインディング要求が送られたIPアドレスとポートから送信された応答コード431で属性。"
    },
    {
      "indent": 3,
      "text": "Assuming the message integrity check passed, processing continues. The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Binding Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code.",
      "ja": "渡されたメッセージの整合性チェックを仮定すると、処理が続行されます。サーバーは、値未満か、それは分かりません0x7FFFのに等しいと要求の中の任意の属性にチェックしなければなりません。それがどんなに遭遇した場合、サーバーは、結合エラーレスポンスを生成しなければならない、そしてそれは420応答コードとERROR-CODE属性を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Binding Error Response is sent to the IP address and port the Binding Request came from, and sent from the IP address and port the Binding Request was sent to.",
      "ja": "その応答はUNKNOWN-属性が値未満又は理解されていなかったは0x7FFFに等しくして属性をリスト属性含まなければなりません。結合エラー応答がバインディング要求から来て、バインディング要求が送られたIPアドレスとポートから送信されたIPアドレスとポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "Assuming the request was correctly formed, the server MUST generate a single Binding Response. The Binding Response MUST contain the same transaction ID contained in the Binding Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Binding Response MUST have a message type of \"Binding Response\".",
      "ja": "要求が正しく形成されたと仮定すると、サーバーは、単一の結合レスポンスを生成しなければなりません。バインディングレスポンスがバインディング要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。バインディングレスポンスは、「結合応答」のメッセージタイプを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MUST add a MAPPED-ADDRESS attribute to the Binding Response. The IP address component of this attribute MUST be set to the source IP address observed in the Binding Request. The port component of this attribute MUST be set to the source port observed in the Binding Request.",
      "ja": "サーバーは、バインディングレスポンスにマッピングされた-ADDRESS属性を追加しなければなりません。この属性のIPアドレスコンポーネントは、バインディング要求で観察された送信元IPアドレスに設定しなければなりません。この属性のポートコンポーネントは、バインディング要求で観察された送信元ポートに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the RESPONSE-ADDRESS attribute was absent from the Binding Request, the destination address and port of the Binding Response MUST be the same as the source address and port of the Binding Request. Otherwise, the destination address and port of the Binding Response MUST be the value of the IP address and port in the RESPONSE-ADDRESS attribute.",
      "ja": "RESPONSE-ADDRESS属性は、バインディング要求を欠席した場合、バインディングレスポンスの送信先アドレスとポートバインディング要求のソースアドレスとポートと同じでなければなりません。それ以外の場合は、バインディングレスポンスの送信先アドレスとポートは、応答-ADDRESS属性にIPアドレスとポートの値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The source address and port of the Binding Response depend on the value of the CHANGE-REQUEST attribute and on the address and port the Binding Request was received on, and are summarized in Table 1.",
      "ja": "送信元アドレスおよび結合応答のポートは、CHANGE-REQUEST属性の値とバインディング要求が受信されたアドレスとポートに依存し、表1にまとめます。"
    },
    {
      "indent": 3,
      "text": "Let Da represent the destination IP address of the Binding Request (which will be either A1 or A2), and Dp represent the destination port of the Binding Request (which will be either P1 or P2). Let Ca represent the other address, so that if Da is A1, Ca is A2. If Da is A2, Ca is A1. Similarly, let Cp represent the other port, so that if Dp is P1, Cp is P2. If Dp is P2, Cp is P1. If the \"change port\" flag was set in CHANGE-REQUEST attribute of the Binding Request, and the \"change IP\" flag was not set, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Cp. If the \"change IP\" flag was set in the Binding Request, and the \"change port\" flag was not set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Dp. When both flags are set, the source IP address of the Binding Response MUST be Ca and the source port of the Binding Response MUST be Cp. If neither flag is set, or if the CHANGE-REQUEST attribute is absent entirely, the source IP address of the Binding Response MUST be Da and the source port of the Binding Response MUST be Dp.",
      "ja": "Daは（A1またはA2のいずれかであろう）バインディング要求の宛先IPアドレスを表し、Dpは（P1又はP2のいずれかであろう）バインディング要求の送信先ポートを表してみましょう。ダがある場合A1、CaはA2となるように、Caが、他のアドレスを表してみましょう。 DaはA2であれば、CaがA1です。同様に、DpがP1である場合、CpはP2になるようにCpは、他のポートを表してみましょう。 DpがP2である場合、CpはP1です。 「ポートの変更」フラグがバインディング要求のCHANGE-REQUEST属性にセットし、「変更IP」フラグが設定されていない場合は、バインディングレスポンスの送信元IPアドレスは、ダとバインディングレスポンスMUSTの送信元ポートでなければなりませんCpとなります。 「変更IP」フラグがバインディング要求にセットし、「変更ポート」フラグが設定されていない場合、バインディングレスポンスの送信元IPアドレスは、Caなければならず、バインディングレスポンスの送信元ポートがdpなければなりません。両方のフラグが設定されている場合、バインディングレスポンスの送信元IPアドレスは、Caなければならず、バインディングレスポンスの送信元ポートはCpとでなければなりません。どちらのフラグが設定されている場合、または変更要求属性が全く存在しない場合、バインディングレスポンスの送信元IPアドレスは、ダなければならず、バインディングレスポンスの送信元ポートがdpなければなりません。"
    },
    {
      "indent": 6,
      "text": "Flags Source Address Source Port CHANGED-ADDRESS none Da Dp Ca:Cp Change IP Ca Dp Ca:Cp Change port Da Cp Ca:Cp Change IP and Change port Ca Cp Ca:Cp",
      "ja": "国旗ソースアドレスソースポートCHANGED-ADDRESSなしダDpのカルシウム：Cpの変更IPカルシウムDpはカルシウム：Cpを変更したポートダのCpカルシウム：Cpの変更IPおよび変更ポートカルシウムのCpカルシウム：Cpは"
    },
    {
      "indent": 3,
      "text": "Table 1: Impact of Flags on Packet Source and CHANGED-ADDRESS",
      "ja": "表1：パケット送信元とCHANGED-ADDRESS上のフラグの影響"
    },
    {
      "indent": 3,
      "text": "The server MUST add a SOURCE-ADDRESS attribute to the Binding Response, containing the source address and port used to send the Binding Response.",
      "ja": "サーバは、アドレスとポートバインディングレスポンスを送信するために使用されるソースを含む、バインディングレスポンスにSOURCE-ADDRESS属性を追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MUST add a CHANGED-ADDRESS attribute to the Binding Response. This contains the source IP address and port that would be used if the client had set the \"change IP\" and \"change port\" flags in the Binding Request. As summarized in Table 1, these are Ca and Cp, respectively, regardless of the value of the CHANGE-REQUEST flags.",
      "ja": "サーバーは、バインディングレスポンスに変更-ADDRESS属性を追加しなければなりません。これは、クライアントがバインディング要求で「変更IP」と「ポート変更」フラグを設定していた場合に使用される送信元IPアドレスとポートが含まれています。表1にまとめたように、これらは関係なく、変更要求フラグの値を、それぞれ、Ca及びCpとです。"
    },
    {
      "indent": 3,
      "text": "If the Binding Request contained both the USERNAME and MESSAGE-INTEGRITY attributes, the server MUST add a MESSAGE-INTEGRITY attribute to the Binding Response. The attribute contains an HMAC [13] over the response, as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be the one associated with the USERNAME attribute present in the Binding Request.",
      "ja": "バインディング要求がUSERNAMEとMESSAGE-INTEGRITY属性の両方が含まれていた場合、サーバーは、バインディングレスポンスにMESSAGE-INTEGRITY属性を追加しなければなりません。セクション11.2.8に記載されているように属性が、対応上HMAC [13]を含んでいます。使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、キーはUSERNAMEに関連する一つのバインディング要求に存在する属性である必要があります。"
    },
    {
      "indent": 3,
      "text": "If the Binding Request contained a RESPONSE-ADDRESS attribute, the server MUST add a REFLECTED-FROM attribute to the response. If the Binding Request was authenticated using a username obtained from a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source IP address and port where that Shared Secret Request came from. If the username present in the request was not allocated using a Shared Secret Request, the REFLECTED-FROM attribute MUST contain the source address and port of the entity which obtained the username, as best can be verified with the mechanism used to allocate the username. If the username was not present in the request, and the server was willing to process the request, the REFLECTED-FROM attribute SHOULD contain the source IP address and port where the request came from.",
      "ja": "バインディング要求応答-ADDRESS属性が含まれていた場合、サーバーは、反射から属性応答にを加えなければなりません。バインディング要求が共有秘密のリクエストから取得したユーザー名を使用して認証された場合は、反射から属性は、その共有シークレット要求が来たソースIPアドレスとポートを含まなければなりません。リクエストに存在するユーザ名が共有シークレット要求を使用して割り当てられていなかった場合は、反射から属性は、最高のユーザー名を割り当てるために使用されるメカニズムを検証することができるよう、ユーザ名を取得したエンティティの送信元アドレスとポートを含まなければなりません。ユーザ名が要求に存在していなかったし、サーバーが要求を処理するために喜んでいた場合は、反射からのリクエストが来たソースIPアドレスとポートを含むべきである属性。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT retransmit the response. Reliability is achieved by having the client periodically resend the request, each of which triggers a response from the server.",
      "ja": "サーバーは応答を再送すべきではありません。信頼性は、クライアントが定期的にサーバからの応答をトリガそれぞれが要求を再送有することによって達成されます。"
    },
    {
      "indent": 0,
      "text": "8.2 Shared Secret Requests",
      "section_title": true,
      "ja": "8.2共有シークレット要求"
    },
    {
      "indent": 3,
      "text": "Shared Secret Requests are always received on TLS connections. When the server receives a request from the client to establish a TLS connection, it MUST proceed with TLS, and SHOULD present a site certificate. The TLS ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA [4] SHOULD be used. Client TLS authentication MUST NOT be done, since the server is not allocating any resources to clients, and the computational burden can be a source of attacks.",
      "ja": "共有シークレット要求は常にTLS接続上で受信されています。サーバはTLS接続を確立するために、クライアントからのリクエストを受信すると、TLSを続行しなければならない、とサイト証明書を提示しなければなりません。 TLS暗号スイートTLS_RSA_WITH_AES_128_CBC_SHA [4]使用されてください。サーバーがクライアントにすべてのリソースを割り当てていないので、クライアントのTLS認証は、してはいけない、と計算負荷は、攻撃のソースにすることができます。"
    },
    {
      "indent": 3,
      "text": "If the server receives a Shared Secret Request, it MUST verify that the request arrived on a TLS connection. If it did not receive the request over TLS, it MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 433 response code. The destination for the error response depends on the transport on which the request was received. If the Shared Secret Request was received over TCP, the Shared Secret Error Response is sent over the same connection the request was received on. If the Shared Secret Request was receive over UDP, the Shared Secret Error Response is sent to the source IP address and port that the request came from.",
      "ja": "サーバが共有秘密のリクエストを受信した場合、その要求はTLS接続に到着したことを確かめなければなりません。それはTLSオーバー要求を受信しなかった場合は、共有秘密エラー応答を生成しなければならない、そしてそれは433応答コードとERROR-CODE属性を含まなければなりません。エラー応答の宛先は要求を受信したトランスポートに依存します。共有シークレット要求がTCPを介して受信された場合は、共有秘密エラー応答は、要求が受信された同じ接続を介して送信されます。共有シークレット要求がUDPを上に受信した場合、共有秘密エラー応答が要求から来たソースIPアドレスとポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "The server MUST check for any attributes in the request with values less than or equal to 0x7fff which it does not understand. If it encounters any, the server MUST generate a Shared Secret Error Response, and it MUST include an ERROR-CODE attribute with a 420 response code. That response MUST contain an UNKNOWN-ATTRIBUTES attribute listing the attributes with values less than or equal to 0x7fff which were not understood. The Shared Secret Error Response is sent over the TLS connection.",
      "ja": "サーバーは、値未満か、それは分かりません0x7FFFのに等しいと要求の中の任意の属性にチェックしなければなりません。それがどんなに遭遇した場合、サーバーは、共有秘密エラー応答を生成しなければならない、そしてそれは420応答コードとERROR-CODE属性を含まなければなりません。その応答はUNKNOWN-属性が値未満又は理解されていなかったは0x7FFFに等しくして属性をリスト属性含まなければなりません。共有秘密エラー応答は、TLS接続を介して送信されます。"
    },
    {
      "indent": 3,
      "text": "All Shared Secret Error Responses MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Error Response MUST have a message type of \"Shared Secret Error Response\" (0x0112).",
      "ja": "すべての共有秘密エラー応答は、共有シークレット要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。共有秘密エラー応答は、「共有秘密エラー応答」（0x0112）のメッセージタイプを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "Assuming the request was properly constructed, the server creates a Shared Secret Response. The Shared Secret Response MUST contain the same transaction ID contained in the Shared Secret Request. The length in the message header MUST contain the total length of the message in bytes, excluding the header. The Shared Secret Response MUST have a message type of \"Shared Secret Response\". The Shared Secret Response MUST contain a USERNAME attribute and a PASSWORD attribute. The USERNAME attribute serves as an index to the password, which is contained in the PASSWORD attribute. The server can use any mechanism it chooses to generate the username. However, the username MUST be valid for a period of at least 10 minutes. Validity means that the server can compute the password for that username. There MUST be a single password for each username. In other words, the server cannot, 10 minutes later, assign a different password to the same username. The server MUST hand out a different username for each distinct Shared Secret Request. Distinct, in this case, implies a different transaction ID. It is RECOMMENDED that the server explicitly invalidate the username after ten minutes. It MUST invalidate the username after 30 minutes. The PASSWORD contains the password bound to that username. The password MUST have at least 128 bits. The likelihood that the server assigns the same password for two different usernames MUST be vanishingly small, and the passwords MUST be unguessable. In other words, they MUST be a cryptographically random function of the username.",
      "ja": "リクエストが適切に構築したと仮定すると、サーバーは、共有秘密レスポンスを作成します。共有秘密レスポンスは共有シークレット要求に含まれている同じトランザクションIDを含まなければなりません。メッセージヘッダーの長さは、ヘッダを除いた、バイト単位でのメッセージの全長を含まなければなりません。共有シークレットレスポンスは、「共有シークレットレスポンス」のメッセージタイプを持たなければなりません。共有秘密レスポンスはUSERNAME属性とパスワード属性を含まなければなりません。 userName属性は、パスワード属性に含まれているパスワードの指標となります。サーバは、ユーザ名を生成することを選択した任意のメカニズムを使用することができます。しかし、ユーザ名は少なくとも10分の期間に対して有効でなければなりません。有効期間は、サーバがそのユーザ名のパスワードを計算することができます。各ユーザ名のための単一のパスワードがあるに違いありません。言い換えれば、サーバは、10分後に、同じユーザー名に別のパスワードを割り当てることはできません。サーバは、各個別の共有秘密要求のための別のユーザー名を配る必要があります。個別では、このような場合には、異なるトランザクションIDを意味します。サーバーが明示的に10分後にユーザ名を無効にすることを推奨されます。これは、30分後にユーザ名を無効にしなければなりません。 PASSWORDは、そのユーザ名にバインドされたパスワードが含まれています。パスワードは少なくとも128ビットを持たなければなりません。サーバーが2つの異なるユーザ名に同じパスワードを割り当て可能性は無視できるほど小さくなければならない、とパスワードが推測できないでなければなりません。言い換えれば、彼らは、ユーザー名の暗号的にランダム関数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "These requirements can still be met using a stateless server, by intelligently computing the USERNAME and PASSWORD. One approach is to construct the USERNAME as:",
      "ja": "これらの要件は、まだインテリジェントUSERNAMEとPASSWORDを計算することによって、ステートレスなサーバを使用して満たすことができます。一つのアプローチは、としてUSERNAMEを構築することです。"
    },
    {
      "indent": 6,
      "text": "USERNAME = <prefix,rounded-time,clientIP,hmac>",
      "ja": "USERNAME = <接頭辞、丸みを帯びた時、クライアントIP、HMAC>"
    },
    {
      "indent": 3,
      "text": "Where prefix is some random text string (different for each shared secret request), rounded-time is the current time modulo 20 minutes, clientIP is the source IP address where the Shared Secret Request came from, and hmac is an HMAC [13] over the prefix, rounded-time, and client IP, using a server private key.",
      "ja": "プレフィックスは（各共有シークレット要求ごとに異なる）いくつかのランダムなテキスト文字列で、丸い時刻が現在時刻モジュロ20分である場合には、クライアントIPは、共有秘密の要求がどこから来た、とHMACはHMAC [13]である以上、送信元IPアドレスでありますサーバーの秘密鍵を使用して接頭辞、丸い時間、およびクライアントIP、。"
    },
    {
      "indent": 3,
      "text": "The password is then computed as:",
      "ja": "パスワードは次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "password = <hmac(USERNAME,anotherprivatekey)>",
      "ja": "パスワード= <HMAC（USERNAME、anotherprivatekey）>"
    },
    {
      "indent": 3,
      "text": "With this structure, the username itself, which will be present in the Binding Request, contains the source IP address where the Shared Secret Request came from. That allows the server to meet the requirements specified in Section 8.1 for constructing the REFLECTED-FROM attribute. The server can verify that the username was not tampered with, using the hmac present in the username.",
      "ja": "この構造により、バインディング要求内に存在するユーザ名自体は、共有シークレット要求が来たソースIPアドレスが含まれています。これは、サーバーが反射から属性を構築するためのセクション8.1で指定された要件を満たすことができます。サーバは、ユーザ名は、ユーザ名に存在HMACを使用して、改ざんされていないことを確認することができます。"
    },
    {
      "indent": 3,
      "text": "The Shared Secret Response is sent over the same TLS connection the request was received on. The server SHOULD keep the connection open, and let the client close it.",
      "ja": "共有秘密応答は要求が受信された同じTLS接続を介して送信されます。サーバが接続を開いたまま、クライアントはそれを閉じるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Client Behavior",
      "section_title": true,
      "ja": "9.クライアントの動作"
    },
    {
      "indent": 3,
      "text": "The behavior of the client is very straightforward. Its task is to discover the STUN server, obtain a shared secret, formulate the Binding Request, handle request reliability, and process the Binding Responses.",
      "ja": "クライアントの動作は非常に簡単です。そのタスクは、STUNサーバを発見し、共有秘密を取得し、バインディング要求を策定し、要求の信頼性を処理し、バインディング応答を処理することです。"
    },
    {
      "indent": 0,
      "text": "9.1 Discovery",
      "section_title": true,
      "ja": "9.1ディスカバリー"
    },
    {
      "indent": 3,
      "text": "Generally, the client will be configured with a domain name of the provider of the STUN servers. This domain name is resolved to an IP address and port using the SRV procedures specified in RFC 2782 [3].",
      "ja": "一般的に、クライアントはSTUNサーバのプロバイダーのドメイン名で構成されます。このドメイン名は、RFC 2782で指定されたSRV手順を使用してIPアドレスとポートに解決される[3]。"
    },
    {
      "indent": 3,
      "text": "Specifically, the service name is \"stun\". The protocol is \"udp\" for sending Binding Requests, or \"tcp\" for sending Shared Secret Requests. The procedures of RFC 2782 are followed to determine the server to contact. RFC 2782 spells out the details of how a set of SRV records are sorted and then tried. However, it only states that the client should \"try to connect to the (protocol, address, service)\" without giving any details on what happens in the event of failure. Those details are described here for STUN.",
      "ja": "具体的には、サービス名は、「スタン」です​​。プロトコルは、共有シークレット要求を送信するためのバインディング要求を送信するための「UDP」、または「TCP」です。 RFC 2782の手順は連絡するサーバーを決定するために続いています。 RFC 2782は、SRVレコードのセットをソートし、次に試される方法の詳細を綴ります。しかし、それだけで、クライアントは、障害が発生した場合に何が起こるか上の任意の詳細を与えることなく「（プロトコル、アドレス、サービス）に接続しよう」すべきであると述べています。これらの詳細はSTUNのためにここで説明されています。"
    },
    {
      "indent": 3,
      "text": "For STUN requests, failure occurs if there is a transport failure of some sort (generally, due to fatal ICMP errors in UDP or connection failures in TCP). Failure also occurs if the transaction fails due to timeout. This occurs 9.5 seconds after the first request is sent, for both Shared Secret Requests and Binding Requests. See Section 9.3 for details on transaction timeouts for Binding Requests. If a failure occurs, the client SHOULD create a new request, which is identical to the previous, but has a different transaction ID and MESSAGE INTEGRITY attribute (the HMAC will change because the transaction ID has changed). That request is sent to the next element in the list as specified by RFC 2782.",
      "ja": "（TCPでのUDPまたは接続不良で致命的なICMPエラーに起因する一般的に、）ある種の輸送障害が発生した場合はSTUN要求のために、障害が発生しました。トランザクションがタイムアウトのために失敗した場合、障害が発生します。最初の要求が共有される秘密の要求とバインド要求の両方のために、送信された後、これが9.5秒を発生します。取引の詳細については、セクション9.3を参照してください。要求を結合するためのタイムアウト。障害が発生した場合、クライアントは以前と同じですが、（トランザクションIDが変更されたため、HMACが変更されます）異なるトランザクションIDとメッセージの完全性属性を持つ新しいリクエストを作成する必要があります。その要求は、RFC 2782で指定されたリスト内の次の要素に送信されます。"
    },
    {
      "indent": 3,
      "text": "The default port for STUN requests is 3478, for both TCP and UDP. Administrators SHOULD use this port in their SRV records, but MAY use others.",
      "ja": "STUN要求のデフォルトポートはTCPとUDPの両方のために、3478です。管理者は、SRVレコードでこのポートを使用する必要がありますが、他の人を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If no SRV records were found, the client performs an A record lookup of the domain name. The result will be a list of IP addresses, each of which can be contacted at the default port.",
      "ja": "何のSRVレコードが見つからなかった場合、クライアントは、ドメイン名のAレコード検索を実行します。結果は、デフォルトポートで接触させることができるそれぞれのIPアドレスのリストになります。"
    },
    {
      "indent": 3,
      "text": "This would allow a firewall admin to open the STUN port, so hosts within the enterprise could access new applications. Whether they will or won't do this is a good question.",
      "ja": "これは、企業内のホストが新しいアプリケーションにアクセスできるようにファイアウォール管理者は、STUNポートを開くことができるようになります。彼らはまたはこれを行うことはありませんかどうかは良い質問です。"
    },
    {
      "indent": 0,
      "text": "9.2 Obtaining a Shared Secret",
      "section_title": true,
      "ja": "9.2共有シークレットの取得"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 12, there are several attacks possible on STUN systems. Many of these are prevented through integrity of requests and responses. To provide that integrity, STUN makes use of a shared secret between client and server, used as the keying material for an HMAC used in both the Binding Request and Binding Response. STUN allows for the shared secret to be obtained in any way (for example, Kerberos [14]). However, it MUST have at least 128",
      "ja": "セクション12で説明したように、STUNシステム上で可能ないくつかの攻撃があります。これらの多くは、要求と応答の整合性によって阻止されます。その整合性を提供するために、STUNは、バインディング要求と応答のバインディングの両方で使用されるHMACのためのキーイング材料として使用されるクライアントとサーバ間の共有秘密を利用します。 STUNは、任意の方法（例えば、ケルベロス[14]）で得られる共有秘密を可能にします。しかし、それは、少なくとも128を持っていなければなりません。"
    },
    {
      "indent": 3,
      "text": "bits of randomness. In order to ensure interoperability, this specification describes a TLS-based mechanism. This mechanism, described in this section, MUST be implemented by clients and servers.",
      "ja": "乱数のビット。相互運用性を確保するために、この仕様はTLSベースのメカニズムを説明しています。このセクションで説明するこのメカニズムは、クライアントとサーバによって実装されなければなりません。"
    },
    {
      "indent": 3,
      "text": "First, the client determines the IP address and port that it will open a TCP connection to. This is done using the discovery procedures in Section 9.1. The client opens up the connection to that address and port, and immediately begins TLS negotiation [2]. The client MUST verify the identity of the server. To do that, it follows the identification procedures defined in Section 3.1 of RFC 2818 [5]. Those procedures assume the client is dereferencing a URI. For purposes of usage with this specification, the client treats the domain name or IP address used in Section 9.1 as the host portion of the URI that has been dereferenced.",
      "ja": "まず、クライアントは、それがへのTCP接続をオープンしますIPアドレスとポートを決定します。これは、9.1節で発見手順を使用して行われます。クライアントは、そのアドレスとポートへの接続を開き、すぐにTLSネゴシエーションを開始します[2]。クライアントはサーバーの身元を確かめなければなりません。これを行うためには、[5] RFC 2818のセクション3.1で定義された識別手順に従います。これらの手順は、クライアントがURIを逆参照されているとします。この仕様と使用法の目的のために、クライアントは、逆参照されたURIのホスト部分としてセクション9.1で使用されるドメイン名やIPアドレスを扱います。"
    },
    {
      "indent": 3,
      "text": "Once the connection is opened, the client sends a Shared Secret request. This request has no attributes, just the header. The transaction ID in the header MUST meet the requirements outlined for the transaction ID in a binding request, described in Section 9.3 below. The server generates a response, which can either be a Shared Secret Response or a Shared Secret Error Response.",
      "ja": "接続が開かれると、クライアントは共有シークレット要求を送信します。この要求には属性、単にヘッダを持っていません。ヘッダ内のトランザクションIDは、以下のセクション9.3に記載した結合要求のトランザクションIDについて概説要件を満たさなければなりません。サーバーは、いずれかの共有秘密レスポンスまたは共有秘密エラー応答することができ、応答を生成します。"
    },
    {
      "indent": 3,
      "text": "If the response was a Shared Secret Error Response, the client checks the response code in the ERROR-CODE attribute. Interpretation of those response codes is identical to the processing of Section 9.4 for the Binding Error Response.",
      "ja": "応答は、共有秘密エラー応答した場合、クライアントはERROR-CODEアトリビュートにおけるレスポンスコードをチェックします。これらのレスポンスコードの解釈は、結合エラー応答については、セクション9.4の処理と同じです。"
    },
    {
      "indent": 3,
      "text": "If a client receives a Shared Secret Response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a Shared Secret Response with an attribute whose type is less than or equal to 0x7fff, the response is ignored.",
      "ja": "クライアントがタイプ0x7FFFをより大きい属性を持つ共有秘密レスポンスを受信した場合、属性は無視しなければなりません。クライアントがそのタイプ以下は0x7FFFに等しい属性を持つ共有秘密レスポンスを受信した場合、応答は無視されます。"
    },
    {
      "indent": 3,
      "text": "If the response was a Shared Secret Response, it will contain a short lived username and password, encoded in the USERNAME and PASSWORD attributes, respectively.",
      "ja": "応答が共有秘密の対応だった場合、それはそれぞれ、USERNAMEとPASSWORD属性でエンコードされた短命のユーザ名とパスワードを、含まれています。"
    },
    {
      "indent": 3,
      "text": "The client MAY generate multiple Shared Secret Requests on the connection, and it MAY do so before receiving Shared Secret Responses to previous Shared Secret Requests. The client SHOULD close the connection as soon as it has finished obtaining usernames and passwords.",
      "ja": "クライアントが接続で複数の共有シークレット要求を生成することができ、それが以前の共有秘密要求に共有秘密の応答を受信する前にそれを行うことができます。クライアントはすぐに、それはユーザ名とパスワードを取得し終えたとの接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 9.3 describes how these passwords are used to provide integrity protection over Binding Requests, and Section 8.1 describes how it is used in Binding Responses.",
      "ja": "セクション9.3は、これらのパスワードは、バインディング要求を介して完全性保護を提供するために使用されている方法について説明し、8.1節は、それがバインド応答で使用されている方法を説明します。"
    },
    {
      "indent": 0,
      "text": "9.3 Formulating the Binding Request",
      "section_title": true,
      "ja": "9.3バインディング要求を策定"
    },
    {
      "indent": 3,
      "text": "A Binding Request formulated by the client follows the syntax rules defined in Section 11. Any two requests that are not bit-wise identical, and not sent to the same server from the same IP address and port, MUST carry different transaction IDs. The transaction ID MUST be uniformly and randomly distributed between 0 and 2**128 - 1. The large range is needed because the transaction ID serves as a form of randomization, helping to prevent replays of previously signed responses from the server. The message type of the request MUST be \"Binding Request\".",
      "ja": "クライアントによって策定バインディング要求が構文規則セクション11に、同一のビット単位ではありません任意の2つの要求を定義し、同じIPアドレスとポートから同じサーバに送信されないが、以下、異なるトランザクションIDを運ばなければなりません。トランザクションIDは、均一かつランダムに0と2の間で分配されなければならない** 128  -  1.トランザクションIDがサーバーから以前に署名された応答のリプレイを防止するのに役立つ、ランダムの形となるため、大きな範囲が必要とされます。要求のメッセージタイプは、「バインディング要求」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RESPONSE-ADDRESS attribute is optional in the Binding Request. It is used if the client wishes the response to be sent to a different IP address and port than the one the request was sent from. This is useful for determining whether the client is behind a firewall, and for applications that have separated control and data components. See Section 10.3 for more details. The CHANGE-REQUEST attribute is also optional. Whether it is present depends on what the application is trying to accomplish. See Section 10 for some example uses.",
      "ja": "RESPONSE-ADDRESS属性は、バインディング要求ではオプションです。クライアントは要求がから送信されたものとは異なるIPアドレスとポートに送信する応答を希望する場合は使用されています。これは、クライアントがファイアウォールの内側にあるかどうかを決定するため、制御およびデータコンポーネントを分離している用途に有用です。詳細については、セクション10.3を参照してください。 CHANGE-REQUEST属性も任意です。それが存在するかどうかは、アプリケーションが達成しようとしているものに依存します。いくつかの例では、使用については、セクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD add a MESSAGE-INTEGRITY and USERNAME attribute to the Binding Request. This MESSAGE-INTEGRITY attribute contains an HMAC [13]. The value of the username, and the key to use in the MESSAGE-INTEGRITY attribute depend on the shared secret mechanism. If the STUN Shared Secret Request was used, the USERNAME must be a valid username obtained from a Shared Secret Response within the last nine minutes. The shared secret for the HMAC is the value of the PASSWORD attribute obtained from the same Shared Secret Response.",
      "ja": "クライアントは、バインディング要求にMESSAGE-INTEGRITYとUSERNAME属性を追加する必要があります。このMESSAGE-INTEGRITY属性は、HMAC [13]を含んでいます。ユーザ名の値、およびMESSAGE-INTEGRITY属性で使用するための鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合、USERNAMEは、最後の9分以内に共有秘密レスポンスから取得した有効なユーザ名でなければなりません。 HMACの共有秘密は、同じ共有秘密レスポンスから取得したパスワード属性の値です。"
    },
    {
      "indent": 3,
      "text": "Once formulated, the client sends the Binding Request. Reliability is accomplished through client retransmissions. Clients SHOULD retransmit the request starting with an interval of 100ms, doubling every retransmit until the interval reaches 1.6s. Retransmissions continue with intervals of 1.6s until a response is received, or a total of 9 requests have been sent. If no response is received by 1.6 seconds after the last request has been sent, the client SHOULD consider the transaction to have failed. In other words, requests would be sent at times 0ms, 100ms, 300ms, 700ms, 1500ms, 3100ms, 4700ms, 6300ms, and 7900ms. At 9500ms, the client considers the transaction to have failed if no response has been received.",
      "ja": "策定後は、クライアントは、バインディング要求を送信します。信頼性は、クライアントの再送信を介して行われます。クライアントは、間隔は1.6秒に達するまで、すべての再送信を倍増、100ミリ秒の間隔で始まる要求を再送信すべきです。再送は、応答が受信されるまで、1.6秒の間隔で継続、または9つの要求の合計が送られてきました。最後の要求が送信された後も応答が1.6秒で受信されない場合、クライアントは、トランザクションが失敗したと考えるべきです。言い換えれば、要求は、時刻0msと、100ミリ秒、300ミリ秒、700ms、1500ms、3100ms、4700ms、6300ms、および7900msで送信されます。 9500msで、クライアントは応答が受信されない場合、トランザクションが失敗したと見なします。"
    },
    {
      "indent": 0,
      "text": "9.4 Processing Binding Responses",
      "section_title": true,
      "ja": "9.4バインディングレスポンスの処理"
    },
    {
      "indent": 3,
      "text": "The response can either be a Binding Response or Binding Error Response. Binding Error Responses are always received on the source address and port the request was sent from. A Binding Response will be received on the address and port placed in the RESPONSE-ADDRESS attribute of the request. If none was present, the Binding Responses will be received on the source address and port the request was sent from.",
      "ja": "応答は、いずれかのBindingレスポンスやバインディングエラー応答することができます。バインディングエラー応答は常に要求がから送信された送信元アドレスとポートで受信されています。バインディングレスポンスはリクエストの応答ADDRESS属性に配置されたアドレスとポートで受信されます。いずれも存在しない場合、結合応答は要求がから送信された送信元アドレスとポートで受信されます。"
    },
    {
      "indent": 3,
      "text": "If the response is a Binding Error Response, the client checks the response code from the ERROR-CODE attribute of the response. For a 400 response code, the client SHOULD display the reason phrase to the user. For a 420 response code, the client SHOULD retry the request, this time omitting any attributes listed in the UNKNOWN-ATTRIBUTES attribute of the response. For a 430 response code, the client SHOULD obtain a new shared secret, and retry the Binding Request with a new transaction. For 401 and 432 response codes, if the client had omitted the USERNAME or MESSAGE-INTEGRITY attribute as indicated by the error, it SHOULD try again with those attributes. For a 431 response code, the client SHOULD alert the user, and MAY try the request again after obtaining a new username and password. For a 500 response code, the client MAY wait several seconds and then retry the request. For a 600 response code, the client MUST NOT retry the request, and SHOULD display the reason phrase to the user. Unknown attributes between 400 and 499 are treated like a 400, unknown attributes between 500 and 599 are treated like a 500, and unknown attributes between 600 and 699 are treated like a 600. Any response between 100 and 399 MUST result in the cessation of request retransmissions, but otherwise is discarded.",
      "ja": "応答が結合エラー応答である場合、クライアントはレスポンスのERROR-CODE属性からの応答コードをチェックします。 400応答コードの場合、クライアントはユーザーに理由フレーズが表示されます。 420応答コードの場合、クライアントはリクエスト、レスポンスのUNKNOWN-ATTRIBUTES属性に記載されているすべての属性を省略し、この時間を再試行する必要があります。 430応答コードの場合、クライアントは新しい共有秘密を取得し、新たな取引にバインディング要求を再試行する必要があります。エラーによって示されるように、クライアントはUSERNAMEまたはMESSAGE-INTEGRITY属性を省略した場合は401と432応答コードについては、それはそれらの属性をもう一度試してみてください。 431応答コードの場合、クライアントはユーザーに警告すべきである、と新しいユーザー名とパスワードを取得した後、要求を再試行してくださいかもしれません。 500応答コードの場合、クライアントは数秒待ってから、要求を再試行してもよい（MAY）。 600応答コードの場合、クライアントは要求を再試行してはならない、とユーザーに理由フレーズが表示されます。 400と499の間の未知の属性は400のように扱われ、500と599の間の未知の属性は500のように扱われ、600と699の間の未知の属性は100と399との間の応答は、要求の停止をもたらさなければなりません600のように扱われます再送信は、それ以外は破棄されます。"
    },
    {
      "indent": 3,
      "text": "If a client receives a response with an attribute whose type is greater than 0x7fff, the attribute MUST be ignored. If the client receives a response with an attribute whose type is less than or equal to 0x7fff, request retransmissions MUST cease, but the entire response is otherwise ignored.",
      "ja": "クライアントがタイプ0x7FFFをより大きい属性を持つレスポンスを受信した場合、属性は無視しなければなりません。クライアントがタイプ以下は0x7FFFに等しい属性を持つレスポンスを受信した場合、要求の再送信は停止する必要がありますが、全体の応答がそうでない場合は無視されます。"
    },
    {
      "indent": 3,
      "text": "If the response is a Binding Response, the client SHOULD check the response for a MESSAGE-INTEGRITY attribute. If not present, and the client placed a MESSAGE-INTEGRITY attribute into the request, it MUST discard the response. If present, the client computes the HMAC over the response as described in Section 11.2.8. The key to use depends on the shared secret mechanism. If the STUN Shared Secret Request was used, the key MUST be same as used to compute the MESSAGE-INTEGRITY attribute in the request. If the computed HMAC differs from the one in the response, the client MUST discard the response, and SHOULD alert the user about a possible attack. If the computed HMAC matches the one from the response, processing continues.",
      "ja": "応答がバインディング応答である場合、クライアントはMESSAGE-INTEGRITY属性の応答をチェックする必要があります。現在、クライアントではないが、要求の中にMESSAGE-INTEGRITYアトリビュートを配置した場合、それは応答を捨てなければなりません。存在する場合は、セクション11.2.8で説明したように、クライアントは応答を介してHMACを計算します。使用する鍵は、共有秘密メカニズムに依存します。 STUN共有シークレット要求を使用した場合は、要求におけるMESSAGE-INTEGRITYアトリビュートを計算するために使用されるように、キーは同じでなければなりません。計算されたHMACが応答したものと異なる場合、クライアントは応答を捨てなければなりませんし、攻撃の可能性についてユーザーに警告すべきです。計算されたHMACが応答からの1つに一致する場合、処理は継続します。"
    },
    {
      "indent": 3,
      "text": "Reception of a response (either Binding Error Response or Binding Response) to a Binding Request will terminate retransmissions of that request. However, clients MUST continue to listen for responses to a Binding Request for 10 seconds after the first response. If it receives any responses in this interval with different message types (Binding Responses and Binding Error Responses, for example) or different MAPPED-ADDRESSes, it is an indication of a possible attack. The client MUST NOT use the MAPPED-ADDRESS from any of the responses it received (either the first or the additional ones), and SHOULD alert the user.",
      "ja": "バインディング要求への応答（バインディングエラー応答または結合応答のいずれか）の受信は、その要求の再送信を終了します。ただし、クライアントは最初の応答の後に10秒間、バインディング要求に対する応答を聞き続けなければなりません。それは、異なるメッセージタイプ（例えば、レスポンスを結合およびエラー応答を結合）、または異なるMAPPED-アドレスを持つこの間隔内の任意の応答を受信した場合、それは可能な攻撃の指標です。クライアントは、それが受信した応答（最初のまたは追加のもののいずれか）のいずれかからMAPPED-ADDRESSを使用してはならない、とユーザーに警告すべきです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, if a client receives more than twice as many Binding Responses as the number of Binding Requests it sent, it MUST NOT use the MAPPED-ADDRESS from any of those responses, and SHOULD alert the user about a potential attack.",
      "ja": "クライアントは、それが送られたバインディング要求の数の2倍の数のバインディング応答以上のものを受信した場合また、それは、それらの応答のいずれかからMAPPED-ADDRESSを使用してはならない、そして潜在的な攻撃についてユーザーに警告すべきです。"
    },
    {
      "indent": 3,
      "text": "If the Binding Response is authenticated, and the MAPPED-ADDRESS was not discarded because of a potential attack, the CLIENT MAY use the MAPPED-ADDRESS and SOURCE-ADDRESS attributes.",
      "ja": "バインディングレスポンスが認証され、マッピングされた-ADDRESSがあるため潜在的な攻撃を捨てていなかった場合、クライアントは、マップされた-ADDRESSとSOURCE-ADDRESS属性を使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "10. Use Cases",
      "section_title": true,
      "ja": "10.ユースケース"
    },
    {
      "indent": 3,
      "text": "The rules of Sections 8 and 9 describe exactly how a client and server interact to send requests and get responses. However, they do not dictate how the STUN protocol is used to accomplish useful tasks. That is at the discretion of the client. Here, we provide some useful scenarios for applying STUN.",
      "ja": "セクション8と9のルールは、クライアントとサーバがリクエストを送信し、応答を取得するために相互作用正確にどのように説明します。しかし、彼らはSTUNプロトコルが有用なタスクを達成するために使用される方法を規定していません。それは、クライアントの裁量です。ここでは、STUNを適用するためのいくつかの有用なシナリオを提供しています。"
    },
    {
      "indent": 0,
      "text": "10.1 Discovery Process",
      "section_title": true,
      "ja": "10.1ディスカバリー・プロセス"
    },
    {
      "indent": 3,
      "text": "In this scenario, a user is running a multimedia application which needs to determine which of the following scenarios applies to it:",
      "ja": "このシナリオでは、ユーザーがそれに適用される次のシナリオのどれかを決定する必要があるマルチメディアアプリケーションを実行しています："
    },
    {
      "indent": 3,
      "text": "o On the open Internet",
      "ja": "オープンなインターネット上でO"
    },
    {
      "indent": 3,
      "text": "o Firewall that blocks UDP",
      "ja": "OブロックUDPというファイアウォール"
    },
    {
      "indent": 3,
      "text": "o Firewall that allows UDP out, and responses have to come back to the source of the request (like a symmetric NAT, but no translation. We call this a symmetric UDP Firewall)",
      "ja": "アウトUDPを可能にし、応答が要求元に戻って来ている（対称型NATのような、ない訳が。我々は、この対称UDPファイアウォールを呼び出していない）Oファイアウォール"
    },
    {
      "indent": 3,
      "text": "o Full-cone NAT",
      "ja": "OフルコーンNAT"
    },
    {
      "indent": 3,
      "text": "o Symmetric NAT",
      "ja": "対称型NAT O"
    },
    {
      "indent": 3,
      "text": "o Restricted cone or restricted port cone NAT",
      "ja": "O制限付きコーンまたは制限付きポートコーンNAT"
    },
    {
      "indent": 3,
      "text": "Which of the six scenarios applies can be determined through the flow chart described in Figure 2. The chart refers only to the sequence of Binding Requests; Shared Secret Requests will, of course, be needed to authenticate each Binding Request used in the sequence.",
      "ja": "6つのシナリオのどのチャート2図で説明したフローチャートにより決定することができるのみ適用バインディング要求の配列を指します。共有シークレット要求は、当然のことながら、シーケンスで使用される各バインディング要求を認証するために必要とされるであろう。"
    },
    {
      "indent": 3,
      "text": "The flow makes use of three tests. In test I, the client sends a STUN Binding Request to a server, without any flags set in the CHANGE-REQUEST attribute, and without the RESPONSE-ADDRESS attribute. This causes the server to send the response back to the address and port that the request came from. In test II, the client sends a Binding Request with both the \"change IP\" and \"change port\" flags from the CHANGE-REQUEST attribute set. In test III, the client sends a Binding Request with only the \"change port\" flag set.",
      "ja": "フローは、3つのテストを使用しています。テストIでは、クライアントはサーバに、CHANGE-REQUEST属性に設定されているすべてのフラグなしに、応答-ADDRESS属性なしSTUNバインディング要求を送信します。これは、サーバーがバック要求から来たアドレスとポートに応答を送信する原因となります。テストIIでは、クライアントは、「変更IP」と設定CHANGE-REQUEST属性から「ポート変更」フラグの両方にバインディング要求を送信します。試験IIIにおいて、クライアントは、「変更ポート」フラグが設定されたバインディング要求を送信します。"
    },
    {
      "indent": 3,
      "text": "The client begins by initiating test I. If this test yields no response, the client knows right away that it is not capable of UDP connectivity. If the test produces a response, the client examines the MAPPED-ADDRESS attribute. If this address and port are the same as the local IP address and port of the socket used to send the request, the client knows that it is not natted. It executes test II.",
      "ja": "このテストは何も応答が得られない場合、クライアントは、クライアントがUDP接続できないことをすぐに知っている、テストIを開始することによって始まります。テストは、応答を生成する場合、クライアントは、マップされ-ADDRESS属性を調べます。このアドレスとポートが要求を送信するために使用されるソケットのローカルIPアドレスとポートと同じである場合、クライアントは、それがnattedされていないことを知っています。これはテストIIを実行します。"
    },
    {
      "indent": 3,
      "text": "If a response is received, the client knows that it has open access to the Internet (or, at least, its behind a firewall that behaves like a full-cone NAT, but without the translation). If no response is received, the client knows its behind a symmetric UDP firewall.",
      "ja": "応答が受信された場合、クライアントは、それが（少なくとも、そのフルコーンNATと同じように動作し、ファイアウォールの背後にあるが、翻訳せずに、または）インターネットへのオープンアクセスを持っていることを知っています。応答がない場合、クライアントはその対称UDPファイアウォールの背後を知っています。"
    },
    {
      "indent": 3,
      "text": "In the event that the IP address and port of the socket did not match the MAPPED-ADDRESS attribute in the response to test I, the client knows that it is behind a NAT. It performs test II. If a response is received, the client knows that it is behind a full-cone NAT. If no response is received, it performs test I again, but this time, does so to the address and port from the CHANGED-ADDRESS attribute from the response to test I. If the IP address and port returned in the MAPPED-ADDRESS attribute are not the same as the ones from the first test I, the client knows its behind a symmetric NAT. If the address and port are the same, the client is either behind a restricted or port restricted NAT. To make a determination about which one it is behind, the client initiates test III. If a response is received, its behind a restricted NAT, and if no response is received, its behind a port restricted NAT.",
      "ja": "ソケットのIPアドレスとポートはIをテストするための応答にマッピング-ADDRESS属性と一致しなかったことをイベントでは、クライアントがNATの背後にあることを知っています。これは、試験IIを実行します。応答が受信された場合、クライアントは、フルコーンNATの背後にあることを知っています。応答がない場合、それは私再度テストを実行しますが、この時間は、IPアドレスとポートをマッピング-ADDRESS属性で返された場合ですI.をテストするために、応答から変更-ADDRESS属性からアドレスとポートにそう最初のテストIからのものは、クライアントがその対称NATの背後に知っているのと同じではありません。アドレスとポートが同じである場合、クライアントはNATを制限し、制限またはポートの後ろのどちらかです。それは背後にある1について決意を行うために、クライアントはテストIIIを開始します。応答を受信した場合に応答がない場合は、その制限付きNATの背後に、そして、そのポートの背後には、NATを制限しました。"
    },
    {
      "indent": 3,
      "text": "This procedure yields substantial information about the operating condition of the client application. In the event of multiple NATs between the client and the Internet, the type that is discovered will be the type of the most restrictive NAT between the client and the Internet. The types of NAT, in order of restrictiveness, from most to least, are symmetric, port restricted cone, restricted cone, and full cone.",
      "ja": "この手順は、クライアント・アプリケーションの動作状態に関するかなりの情報が得られます。クライアントとインターネットとの間に複数のNATの場合には、発見されたタイプは、クライアントとインターネットの間で最も制限のNATのタイプになります。ほとんどの少なくともに限定度の順にNATの種類は、、、対称である、ポート制限コーン制限コーン、およびフルコーン。"
    },
    {
      "indent": 3,
      "text": "Typically, a client will re-do this discovery process periodically to detect changes, or look for inconsistent results. It is important to note that when the discovery process is redone, it should not generally be done from the same local address and port used in the previous discovery process. If the same local address and port are reused, bindings from the previous test may still be in existence, and these will invalidate the results of the test. Using a different local address and port for subsequent tests resolves this problem. An alternative is to wait sufficiently long to be confident that the old bindings have expired (half an hour should more than suffice).",
      "ja": "一般的に、クライアントが変更を検出するために、定期的にこの発見プロセスを再実行する、または矛盾した結果を探します。発見プロセスがやり直されるとき、それは一般的に、以前の発見プロセスで使用したのと同じローカルアドレスとポートから実行すべきではないことに注意することが重要です。同じローカルアドレスとポートが再利用されている場合は、前回のテストからの束縛は、まだ存在していてもよく、これらはテストの結果を無効にします。次の試験のために異なるローカルアドレスとポートを使用することで、この問題を解決します。代替は（時間半べき水準以上のもの）古いバインディングが期限切れになっていることを確信するために十分に長く待つことです。"
    },
    {
      "indent": 0,
      "text": "10.2 Binding Lifetime Discovery",
      "section_title": true,
      "ja": "10.2バインディング生涯発見"
    },
    {
      "indent": 3,
      "text": "STUN can also be used to discover the lifetimes of the bindings created by the NAT. In many cases, the client will need to refresh the binding, either through a new STUN request, or an application packet, in order for the application to continue to use the binding. By discovering the binding lifetime, the client can determine how frequently it needs to refresh.",
      "ja": "STUNはまた、NATによって作成されたバインディングの寿命を発見するために使用することができます。アプリケーションは、バインディングを使用し続けるために多くの場合、クライアントは順番に、新しいSTUN要求、またはアプリケーションパケットのいずれかを介して、結合をリフレッシュする必要があります。結合寿命を発見することで、クライアントはそれをリフレッシュする必要がある頻度を決定することができます。"
    },
    {
      "indent": 3,
      "text": "                     +--------+\n                     |  Test  |\n                     |   I    |\n                     +--------+\n                          |\n                          |\n                          V\n                         /\\              /\\\n                      N /  \\ Y          /  \\ Y             +--------+\n       UDP     <-------/Resp\\--------->/ IP \\------------->|  Test  |\n       Blocked         \\ ?  /          \\Same/              |   II   |\n                        \\  /            \\? /               +--------+\n                         \\/              \\/                    |\n                                          | N                  |\n                                          |                    V\n                                          V                    /\\\n                                      +--------+  Sym.      N /  \\\n                                      |  Test  |  UDP    <---/Resp\\\n                                      |   II   |  Firewall   \\ ?  /\n                                      +--------+              \\  /\n                                          |                    \\/\n                                          V                     |Y\n               /\\                         /\\                    |\nSymmetric  N  /  \\       +--------+   N  /  \\                   V\n   NAT  <--- / IP \\<-----|  Test  |<--- /Resp\\               Open\n             \\Same/      |   I    |     \\ ?  /               Internet\n              \\? /       +--------+      \\  /\n               \\/                         \\/\n               |                           |Y\n               |                           |\n               |                           V\n               |                           Full\n               |                           Cone\n               V              /\\\n           +--------+        /  \\ Y\n           |  Test  |------>/Resp\\---->Restricted\n           |   III  |       \\ ?  /\n           +--------+        \\  /\n                              \\/\n                               |N\n                               |       Port\n                               +------>Restricted",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 2: Flow for type discovery process",
      "ja": "図2：タイプの発見プロセスのためのフロー"
    },
    {
      "indent": 3,
      "text": "To determine the binding lifetime, the client first sends a Binding Request to the server from a particular socket, X. This creates a binding in the NAT. The response from the server contains a MAPPED-ADDRESS attribute, providing the public address and port on the NAT. Call this Pa and Pp, respectively. The client then starts a timer with a value of T seconds. When this timer fires, the client sends another Binding Request to the server, using the same destination address and port, but from a different socket, Y. This request contains a RESPONSE-ADDRESS address attribute, set to (Pa,Pp). This will create a new binding on the NAT, and cause the STUN server to send a Binding Response that would match the old binding, if it still exists. If the client receives the Binding Response on socket X, it knows that the binding has not expired. If the client receives the Binding Response on socket Y (which is possible if the old binding expired, and the NAT allocated the same public address and port to the new binding), or receives no response at all, it knows that the binding has expired.",
      "ja": "結合寿命を決定するために、クライアントはまず、特定のソケットからのサーバーへのバインディング要求を送信し、X.これはNATにバインディングを作成します。サーバーからの応答はNATのパブリックアドレスとポートを提供し、MAPPED-ADDRESS属性が含まれています。それぞれ、このPaとPpのを呼び出します。次に、クライアントは、T秒の値を持つタイマーを開始します。ときにこのタイマーが起動、クライアントが同じ宛先アドレスとポートを使用して、サーバーに別のバインディング要求を送信しますが、異なるソケットから、Y.この要求は、（PA、PP）に設定し、RESPONSE-ADDRESSアドレス属性が含まれています。これはNATに新しいバインディングを作成し、それがまだ存在する場合は、古いバインディングに一致しバインディングレスポンスを送信するためにSTUNサーバーの原因となります。クライアントがソケットX上の結合応答を受信した場合、それは結合の期限が切れていないことを知っています。クライアントは（古いバインディングが期限切れになった場合に可能であり、NATバインディング新に同じパブリックアドレスとポートを割り当てられる）、またはまったく応答がない、それは結合の期限が切れていることを知っているソケットY上の結合応答を受信した場合。"
    },
    {
      "indent": 3,
      "text": "The client can find the value of the binding lifetime by doing a binary search through T, arriving eventually at the value where the response is not received for any timer greater than T, but is received for any timer less than T.",
      "ja": "クライアントは、応答がどのタイマーTよりも大きいために受信されない値で最終的に到着し、Tを通じてバイナリ検索を行うことによって結合寿命の値を見つけることができますが、すべてのタイマーのために受信されたT.未満"
    },
    {
      "indent": 3,
      "text": "This discovery process takes quite a bit of time, and is something that will typically be run in the background on a device once it boots.",
      "ja": "この発見プロセスは、かなりの時間を要し、それが起動すると、通常、デバイスのバックグラウンドで実行されるものです。"
    },
    {
      "indent": 3,
      "text": "It is possible that the client can get inconsistent results each time this process is run. For example, if the NAT should reboot, or be reset for some reason, the process may discover a lifetime than is shorter than the actual one. For this reason, implementations are encouraged to run the test numerous times, and be prepared to get inconsistent results.",
      "ja": "クライアントが一貫性のない結果にこのプロセスが実行されるたびに得ることができることも可能です。 NATは、再起動する必要がある、または何らかの理由でリセットされた場合、プロセスは、実際のものよりも短くなっているよりも、寿命を発見することがあります。このため、実装はテストを何度も実行することが奨励され、かつ一貫性のない結果を得るために準備すること。"
    },
    {
      "indent": 0,
      "text": "10.3 Binding Acquisition",
      "section_title": true,
      "ja": "10.3バインディング買収"
    },
    {
      "indent": 3,
      "text": "Consider once more the case of a VoIP phone. It used the discovery process above when it started up, to discover its environment. Now, it wants to make a call. As part of the discovery process, it determined that it was behind a full-cone NAT.",
      "ja": "もう一度VoIP電話のケースを考えてみましょう。それが起動したときには、その環境を発見するために、上記の検出プロセスを使用していました。さて、それは電話をしたいと考えています。検出プロセスの一環として、それはフルコーンNATの背後にあったと判断しました。"
    },
    {
      "indent": 3,
      "text": "Consider further that this phone consists of two logically separated components - a control component that handles signaling, and a media component that handles the audio, video, and RTP [12]. Both are behind the same NAT. Because of this separation of control and media, we wish to minimize the communication required between them. In fact, they may not even run on the same host.",
      "ja": "シグナリングを処理する制御コンポーネント、オーディオ、ビデオを処理するメディアコンポーネント、およびRTP [12]  - この携帯電話は、2つの論理的に分離された成分からなることをさらに考えます。どちらも、同じNATの背後にあります。そのため制御とメディアのこの分離のため、我々は彼らの間で必要な通信を最小限にしたいです。実際に、彼らも同じホスト上で実行されないことがあります。"
    },
    {
      "indent": 3,
      "text": "In order to make a voice call, the phone needs to obtain an IP address and port that it can place in the call setup message as the destination for receiving audio.",
      "ja": "音声通話を行うために、携帯電話は、それがオーディオを受信するための宛先として呼設定メッセージに置くことができるIPアドレスとポートを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "To obtain an address, the control component sends a Shared Secret Request to the server, obtains a shared secret, and then sends a Binding Request to the server. No CHANGE-REQUEST attribute is present in the Binding Request, and neither is the RESPONSE-ADDRESS attribute. The Binding Response contains a mapped address. The control component then formulates a second Binding Request. This request contains a RESPONSE-ADDRESS, which is set to the mapped address learned from the previous Binding Response. This Binding Request is passed to the media component, along with the IP address and port of the STUN server. The media component sends the Binding Request. The request goes to the STUN server, which sends the Binding Response back to the control component. The control component receives this, and now has learned an IP address and port that will be routed back to the media component that sent the request.",
      "ja": "アドレスを取得するには、コントロールコンポーネントは、サーバーに共有シークレット要求を送信し、共有秘密を取得し、サーバーへのバインディング要求を送信します。いいえCHANGE-REQUEST属性は、バインディング要求に存在しない、とどちらもRESPONSE-ADDRESS属性です。バインディングレスポンスがマッピングされたアドレスが含まれています。制御コンポーネントは、第2のバインディング要求を定式化します。この要求は、マッピングされたアドレスに設定されているRESPONSE-ADDRESSは、以前のバインディングレスポンスから学んだ含まれています。このバインディング要求は、STUNサーバーのIPアドレスとポートとともに、メディアコンポーネントに渡されます。メディアコンポーネントは、バインディング要求を送信します。リクエストは、バック制御コンポーネントへの結合応答を送信STUNサーバー、に行きます。制御コンポーネントは、これを受けて、すぐに戻って、要求を送信したメディアコンポーネントにルーティングされますIPアドレスとポートを学習しています。"
    },
    {
      "indent": 3,
      "text": "The client will be able to receive media from anywhere on this mapped address.",
      "ja": "クライアントは、このマッピングされたアドレス上の任意の場所からメディアを受け取ることができるようになります。"
    },
    {
      "indent": 3,
      "text": "In the case of silence suppression, there may be periods where the client receives no media. In this case, the UDP bindings could timeout (UDP bindings in NATs are typically short; 30 seconds is common). To deal with this, the application can periodically retransmit the query in order to keep the binding fresh.",
      "ja": "無音圧縮の場合には、クライアントが何メディアを受信しない期間があってもよいです。この場合、UDPバインディングはタイムアウト可能性（のNATでUDPバインディングは、典型的には短い、30秒が一般的です）。これに対処するには、アプリケーションは定期的に結合新鮮に保つために、クエリを再送信することができます。"
    },
    {
      "indent": 3,
      "text": "It is possible that both participants in the multimedia session are behind the same NAT. In that case, both will repeat this procedure above, and both will obtain public address bindings. When one sends media to the other, the media is routed to the NAT, and then turns right back around to come back into the enterprise, where it is translated to the private address of the recipient. This is not particularly efficient, and unfortunately, does not work in many commercial NATs. In such cases, the clients may need to retry using private addresses.",
      "ja": "マルチメディアセッションの両方の参加者が同じNATの背後にあることも可能です。その場合、両方とも上記この手順を繰り返すであろう、との両方がパブリックアドレスバインディングを取得します。一方が他方にメディアを送信すると、メディアはNATにルーティングされ、その後、戻ってそれが受信者のプライベートアドレスに変換され、企業、に来て周りの右折り返しています。これは特に効率的ではありません、残念ながら、多くの商用のNATでは動作しません。このような場合には、クライアントがプライベートアドレスを使用して再試行する必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "11. Protocol Details",
      "section_title": true,
      "ja": "11.プロトコルの詳細"
    },
    {
      "indent": 3,
      "text": "This section presents the detailed encoding of a STUN message.",
      "ja": "このセクションでは、STUNメッセージの詳細なエンコーディングを提示しています。"
    },
    {
      "indent": 3,
      "text": "STUN is a request-response protocol. Clients send a request, and the server sends a response. There are two requests, Binding Request, and Shared Secret Request. The response to a Binding Request can either be the Binding Response or Binding Error Response. The response to a Shared Secret Request can either be a Shared Secret Response or a Shared Secret Error Response.",
      "ja": "STUNは、要求 - 応答プロトコルです。クライアントがリクエストを送信し、サーバが応答を送信します。 2つの要求、バインディング要求、および共有シークレット要求があります。バインディング要求への応答は、バインディングレスポンスやバインディングエラー応答のいずれかとすることができます。共有シークレット要求に対する応答は、いずれかの共有秘密レスポンスまたは共有秘密エラー応答することができます。"
    },
    {
      "indent": 3,
      "text": "STUN messages are encoded using binary fields. All integer fields are carried in network byte order, that is, most significant byte (octet) first. This byte order is commonly known as big-endian. The transmission order is described in detail in Appendix B of RFC 791 [6]. Unless otherwise noted, numeric constants are in decimal (base 10).",
      "ja": "STUNメッセージは、バイナリフィールドを使用してエンコードされています。すべての整数フィールドは、最上位バイト（オクテット）最初、つまり、ネットワークバイト順に搬送されます。このバイト順は、一般的にビッグエンディアンとして知られています。送信順序は、RFC 791の付録Bに詳細に記載されている[6]。特に断りのない限り、数値定数は、小数点（基数10）です。"
    },
    {
      "indent": 0,
      "text": "11.1 Message Header",
      "section_title": true,
      "ja": "11.1メッセージのヘッダー"
    },
    {
      "indent": 3,
      "text": "All STUN messages consist of a 20 byte header:",
      "ja": "すべてのSTUNメッセージは、20バイトのヘッダーで構成されています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      STUN Message Type        |         Message Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Transaction ID\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Message Types can take on the following values:",
      "ja": "メッセージタイプは、以下の値を取ることができます。"
    },
    {
      "indent": 6,
      "text": "0x0001 : Binding Request 0x0101 : Binding Response 0x0111 : Binding Error Response 0x0002 : Shared Secret Request 0x0102 : Shared Secret Response 0x0112 : Shared Secret Error Response",
      "ja": "0x0001：バインディング要求0x0101：バインディングレスポンス0x0111：バインディングエラー応答0×0002：共有シークレット要求0x0102：共有シークレット応答0x0112：共有シークレットエラー応答"
    },
    {
      "indent": 3,
      "text": "The message length is the count, in bytes, of the size of the message, not including the 20 byte header.",
      "ja": "メッセージ長は、20バイトのヘッダーを含まないメッセージのサイズのバイト単位の数です。"
    },
    {
      "indent": 3,
      "text": "The transaction ID is a 128 bit identifier. It also serves as salt to randomize the request and the response. All responses carry the same identifier as the request they correspond to.",
      "ja": "トランザクションIDは、128ビットの識別子です。それはまた、要求と応答をランダム化する塩として働きます。すべての応答は、それらが対応要求と同じ識別子を運びます。"
    },
    {
      "indent": 0,
      "text": "11.2 Message Attributes",
      "section_title": true,
      "ja": "11.2メッセージ属性"
    },
    {
      "indent": 3,
      "text": "After the header are 0 or more attributes. Each attribute is TLV encoded, with a 16 bit type, 16 bit length, and variable value:",
      "ja": "ヘッダの後に0以上の属性です。各属性は、TLVは、16ビットのタイプ、16ビット長、及び変数値と、符号化されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Type                  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             ....\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following types are defined:",
      "ja": "次のタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "0x0001: MAPPED-ADDRESS 0x0002: RESPONSE-ADDRESS 0x0003: CHANGE-REQUEST 0x0004: SOURCE-ADDRESS 0x0005: CHANGED-ADDRESS 0x0006: USERNAME 0x0007: PASSWORD 0x0008: MESSAGE-INTEGRITY 0x0009: ERROR-CODE 0x000a: UNKNOWN-ATTRIBUTES 0x000b: REFLECTED-FROM",
      "ja": "0x0001に：MAPPED-ADDRESSの0×0002：RESPONSE-ADDRESSの0x0003：CHANGE-REQUEST 0x0004は：SOURCEアドレス0x0005：CHANGED-ADDRESSの0x0006：USERNAME 0x0007：PASSWORD 0x0008で：MESSAGE-INTEGRITY 0x0009：ERROR-CODE 0x000a：UNKNOWN-ATTRIBUTES 0x000b：REFLECTED-から"
    },
    {
      "indent": 3,
      "text": "To allow future revisions of this specification to add new attributes if needed, the attribute space is divided into optional and mandatory ones. Attributes with values greater than 0x7fff are optional, which means that the message can be processed by the client or server even though the attribute is not understood. Attributes with values less than or equal to 0x7fff are mandatory to understand, which means that the client or server cannot process the message unless it understands the attribute.",
      "ja": "必要であれば、この仕様の将来の改訂は、新しい属性を追加できるようにするには、属性空間は、オプションと必須のものに分かれています。メッセージは属性が理解されていないにもかかわらず、クライアントまたはサーバで処理できることを意味し、0x7FFFのがオプションであるよりも大きな値を持つ属性。未満の値を持つ属性や0x7FFFのに等しいが、それは属性を理解しない限り、クライアントまたはサーバがメッセージを処理できないことを意味し、理解することが必須です。"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute MUST be the last attribute within a message. Any attributes that are known, but are not supposed to be present in a message (MAPPED-ADDRESS in a request, for example) MUST be ignored.",
      "ja": "MESSAGE-INTEGRITY属性は、メッセージ内の最後の属性であるに違いありません。知られているが、（例えば、要求にマッピング-ADDRESS）メッセージに存在することが想定されていない属性は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Table 2 indicates which attributes are present in which messages. An M indicates that inclusion of the attribute in the message is mandatory, O means its optional, C means it's conditional based on some other aspect of the message, and N/A means that the attribute is not applicable to that message type.",
      "ja": "表2は、そのメッセージに存在している属性を示します。 Mは、メッセージ内の属性を含めることが必須であり、Oは、そのオプションを意味していることを示し、Cは、メッセージのいくつかの他の態様に基づいて、条件付きだし、N / Aは、属性はそのメッセージ・タイプに適用されないことを意味します。"
    },
    {
      "indent": 3,
      "text": "                                      Binding  Shared  Shared  Shared\n                    Binding  Binding  Error    Secret  Secret  Secret\nAtt.                Req.     Resp.    Resp.    Req.    Resp.   Error\n                                                               Resp.\n_____________________________________________________________________\nMAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A\nRESPONSE-ADDRESS    O        N/A      N/A      N/A     N/A     N/A\nCHANGE-REQUEST      O        N/A      N/A      N/A     N/A     N/A\nSOURCE-ADDRESS      N/A      M        N/A      N/A     N/A     N/A\nCHANGED-ADDRESS     N/A      M        N/A      N/A     N/A     N/A\nUSERNAME            O        N/A      N/A      N/A     M       N/A\nPASSWORD            N/A      N/A      N/A      N/A     M       N/A\nMESSAGE-INTEGRITY   O        O        N/A      N/A     N/A     N/A\nERROR-CODE          N/A      N/A      M        N/A     N/A     M\nUNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A     C\nREFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 2: Summary of Attributes",
      "ja": "表2：属性の概要"
    },
    {
      "indent": 3,
      "text": "The length refers to the length of the value element, expressed as an unsigned integral number of bytes.",
      "ja": "長さはバイトの符号なし整数として表さ、value要素の長さを指します。"
    },
    {
      "indent": 0,
      "text": "11.2.1 MAPPED-ADDRESS",
      "section_title": true,
      "ja": "11.2.1 MAPPED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The MAPPED-ADDRESS attribute indicates the mapped IP address and port. It consists of an eight bit address family, and a sixteen bit port, followed by a fixed length value representing the IP address.",
      "ja": "MAPPED-ADDRESS属性は、マッピングされたIPアドレスとポートを示します。これは、IPアドレスを表す固定長値が続く8ビット・アドレス・ファミリ、および16ビットポートからなります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The port is a network byte ordered representation of the mapped port. The address family is always 0x01, corresponding to IPv4. The first 8 bits of the MAPPED-ADDRESS are ignored, for the purposes of aligning parameters on natural boundaries. The IPv4 address is 32 bits.",
      "ja": "ポートは、マッピングされたポートのネットワークバイト注文した表現です。アドレスファミリは、IPv4に対応し、常に0x01です。 MAPPED-ADDRESSの最初の8ビットは、自然界にパラメータを配向させる目的のために、無視されます。 IPv4アドレスは32ビットです。"
    },
    {
      "indent": 0,
      "text": "11.2.2 RESPONSE-ADDRESS",
      "section_title": true,
      "ja": "11.2.2 RESPONSE-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The RESPONSE-ADDRESS attribute indicates where the response to a Binding Request should be sent. Its syntax is identical to MAPPED-ADDRESS.",
      "ja": "RESPONSE-ADDRESS属性は、バインディング要求に対する応答が送信されるべき場所を示します。その構文はMAPPED-ADDRESSと同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.3 CHANGED-ADDRESS",
      "section_title": true,
      "ja": "11.2.3 CHANGED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The CHANGED-ADDRESS attribute indicates the IP address and port where responses would have been sent from if the \"change IP\" and \"change port\" flags had been set in the CHANGE-REQUEST attribute of the Binding Request. The attribute is always present in a Binding Response, independent of the value of the flags. Its syntax is identical to MAPPED-ADDRESS.",
      "ja": "CHANGED-ADDRESS属性は、応答は「変更IP」と「ポート変更」フラグがバインディング要求のCHANGE-REQUEST属性に設定されていた場合から送信されたであろうIPアドレスとポートを示します。属性は常にフラグの値の独立した結合応答、中に存在しています。その構文はMAPPED-ADDRESSと同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.4 CHANGE-REQUEST",
      "section_title": true,
      "ja": "11.2.4 CHANGE-REQUEST"
    },
    {
      "indent": 3,
      "text": "The CHANGE-REQUEST attribute is used by the client to request that the server use a different address and/or port when sending the response. The attribute is 32 bits long, although only two bits (A and B) are used:",
      "ja": "CHANGE-REQUEST属性は、応答を送信するときに、サーバーが別のアドレスおよび/またはポートを使用することを要求するためにクライアントによって使用されます。唯一の2ビット（AとB）が使用されるが、属性は、32ビット長です。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 A B 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The meaning of the flags is:",
      "ja": "フラグの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "A: This is the \"change IP\" flag. If true, it requests the server to send the Binding Response with a different IP address than the one the Binding Request was received on.",
      "ja": "：これは、「変更IP」フラグです。 trueの場合、それは、バインディング要求が受信されたものとは異なるIPアドレスを持つバインディングレスポンスを送信するようにサーバに要求します。"
    },
    {
      "indent": 3,
      "text": "B: This is the \"change port\" flag. If true, it requests the server to send the Binding Response with a different port than the one the Binding Request was received on.",
      "ja": "B：これは、「ポート変更」フラグです。 trueの場合、それは、バインディング要求が受信されたものとは異なるポートとバインディングレスポンスを送信するようにサーバに要求します。"
    },
    {
      "indent": 0,
      "text": "11.2.5 SOURCE-ADDRESS",
      "section_title": true,
      "ja": "11.2.5 SOURCE-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The SOURCE-ADDRESS attribute is present in Binding Responses. It indicates the source IP address and port that the server is sending the response from. Its syntax is identical to that of MAPPED-ADDRESS.",
      "ja": "SOURCE-ADDRESS属性は、バインディングレスポンスに存在しています。これは、サーバーからの応答を送信している送信元IPアドレスとポートを示します。その構文はMAPPED-ADDRESSのものと同じです。"
    },
    {
      "indent": 0,
      "text": "11.2.6 USERNAME",
      "section_title": true,
      "ja": "11.2.6 USERNAME"
    },
    {
      "indent": 3,
      "text": "The USERNAME attribute is used for message integrity. It serves as a means to identify the shared secret used in the message integrity check. The USERNAME is always present in a Shared Secret Response, along with the PASSWORD. It is optionally present in a Binding Request when message integrity is used.",
      "ja": "USERNAME属性は、メッセージの完全性のために使用されています。これは、メッセージの整合性チェックに使用される共有秘密を識別するための手段として機能します。 USERNAMEは、パスワードとともに、常に共有秘密応答中に存在しています。これは、メッセージの完全性が使用されるバインディング要求に任意に存在しています。"
    },
    {
      "indent": 3,
      "text": "The value of USERNAME is a variable length opaque value. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.",
      "ja": "USERNAMEの値は可変長の不透明な値です。その長さはワード境界上の属性の整列を保証するために（バイト単位）4の倍数でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.2.7 PASSWORD",
      "section_title": true,
      "ja": "11.2.7 PASSWORD"
    },
    {
      "indent": 3,
      "text": "The PASSWORD attribute is used in Shared Secret Responses. It is always present in a Shared Secret Response, along with the USERNAME.",
      "ja": "PASSWORD属性は、共有秘密応答で使用されています。これは、USERNAMEと一緒に、共有秘密応答に常に存在しています。"
    },
    {
      "indent": 3,
      "text": "The value of PASSWORD is a variable length value that is to be used as a shared secret. Its length MUST be a multiple of 4 (measured in bytes) in order to guarantee alignment of attributes on word boundaries.",
      "ja": "PASSWORDの値は、共有秘密として使用される可変長値です。その長さはワード境界上の属性の整列を保証するために（バイト単位）4の倍数でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.2.8 MESSAGE-INTEGRITY",
      "section_title": true,
      "ja": "11.2.8 MESSAGE-INTEGRITY"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [13] of the STUN message. It can be present in Binding Requests or Binding Responses. Since it uses the SHA1 hash, the HMAC will be 20 bytes. The text used as input to HMAC is the STUN message, including the header, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. That text is then padded with zeroes so as to be a multiple of 64 bytes. As a result, the MESSAGE-INTEGRITY attribute MUST be the last attribute in any STUN message. The key used as input to HMAC depends on the context.",
      "ja": "MESSAGE-INTEGRITY属性は、STUNメッセージのHMAC-SHA1 [13]を含んでいます。これは、バインディングの要求または結合応答の中に存在することができます。それはSHA1ハッシュを使用しているので、HMACは20バイトになります。 HMACへの入力として使用されるテキストはまで、ヘッダを含み、MESSAGE-INTEGRITYアトリビュートを先行属性を含む、STUNメッセージです。 64バイトの倍数になるようにそのテキストは、ゼロで埋められます。その結果、MESSAGE-INTEGRITY属性は、任意のSTUNメッセージの最後の属性であるに違いありません。 HMACへの入力として使用されるキーは、文脈に依存します。"
    },
    {
      "indent": 0,
      "text": "11.2.9 ERROR-CODE",
      "section_title": true,
      "ja": "11.2.9 ERROR-CODE"
    },
    {
      "indent": 3,
      "text": "The ERROR-CODE attribute is present in the Binding Error Response and Shared Secret Error Response. It is a numeric value in the range of 100 to 699 plus a textual reason phrase encoded in UTF-8, and is consistent in its code assignments and semantics with SIP [10] and HTTP [15]. The reason phrase is meant for user consumption, and can be anything appropriate for the response code. The lengths of the reason phrases MUST be a multiple of 4 (measured in bytes). This can be accomplished by added spaces to the end of the text, if necessary. Recommended reason phrases for the defined response codes are presented below.",
      "ja": "ERROR-CODE属性は、バインディングエラー応答と共有シークレットエラー応答に存在しています。これは、699から100までの範囲に加えてUTF-8でエンコードされたテキストの理由句の数値であり、SIPとのコード割り当ておよびセマンティクスに一致している[10]とHTTP [15]。理由フレーズは、ユーザーの消費のために意図されており、応答コードのための適切な何もすることができます。理由フレーズの長さ（バイト単位）、4の倍数でなければなりません。必要な場合、これは、テキストの末尾に追加スペースで達成することができます。定義された応答コードの推奨理由フレーズを以下に示します。"
    },
    {
      "indent": 3,
      "text": "To facilitate processing, the class of the error code (the hundreds digit) is encoded separately from the rest of the code.",
      "ja": "処理を容易にするために、エラーコード（数百の桁）のクラスは、コードの残りの部分とは別個に符号化されます。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   0                     |Class|     Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Reason Phrase (variable)                                ..\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The class represents the hundreds digit of the response code. The value MUST be between 1 and 6. The number represents the response code modulo 100, and its value MUST be between 0 and 99.",
      "ja": "クラスは、応答コードの数百の位を表します。値は1と6の間でなければなりません数が応答コードモジュロ100を示し、その値は0と99の間でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following response codes, along with their recommended reason phrases (in brackets) are defined at this time:",
      "ja": "（カッコ内）は、推奨理由のフレーズと一緒に以下のレスポンスコードは、この時点で定義されています。"
    },
    {
      "indent": 3,
      "text": "400 (Bad Request): The request was malformed. The client should not retry the request without modification from the previous attempt.",
      "ja": "400（不正な要求）：要求が不正な形式でした。クライアントは、以前の試みから変更なしで要求を再試行するべきではありません。"
    },
    {
      "indent": 3,
      "text": "401 (Unauthorized): The Binding Request did not contain a MESSAGE-INTEGRITY attribute.",
      "ja": "401（無許可）：バインディング要求は、MESSAGE-INTEGRITY属性が含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "420 (Unknown Attribute): The server did not understand a mandatory attribute in the request.",
      "ja": "420（未知のアトリビュート）：サーバーは要求で必須の属性を理解していませんでした。"
    },
    {
      "indent": 3,
      "text": "430 (Stale Credentials): The Binding Request did contain a MESSAGE-INTEGRITY attribute, but it used a shared secret that has expired. The client should obtain a new shared secret and try again.",
      "ja": "430（古い資格情報）：バインディング要求は、MESSAGE-INTEGRITYアトリビュートを含んでいたが、それは有効期限が切れた共有秘密鍵を使用していました。クライアントは、新しい共有秘密を取得して、もう一度試してみてください。"
    },
    {
      "indent": 3,
      "text": "431 (Integrity Check Failure): The Binding Request contained a MESSAGE-INTEGRITY attribute, but the HMAC failed verification. This could be a sign of a potential attack, or client implementation error.",
      "ja": "431（整合性チェックの失敗）：バインディング要求は、MESSAGE-INTEGRITYアトリビュートを含んでいますが、HMACは、検証に失敗しました。これは潜在的な攻撃、またはクライアントの実装エラーの兆候かもしれません。"
    },
    {
      "indent": 3,
      "text": "432 (Missing Username): The Binding Request contained a MESSAGE-INTEGRITY attribute, but not a USERNAME attribute. Both must be present for integrity checks.",
      "ja": "432は、（ユーザ名がありません）：バインディング要求はUSERNAME属性MESSAGE-INTEGRITYアトリビュートを含んでいますが、ありません。どちらも、整合性チェックのために存在している必要があります。"
    },
    {
      "indent": 3,
      "text": "433 (Use TLS): The Shared Secret request has to be sent over TLS, but was not received over TLS.",
      "ja": "433（使用TLS）：共有シークレット要求がTLS上で送信される必要がありますが、TLSを介して受信されませんでした。"
    },
    {
      "indent": 3,
      "text": "500 (Server Error): The server has suffered a temporary error. The client should try again.",
      "ja": "500（サーバーエラー）：サーバーは、一時的なエラーを受けました。クライアントは、もう一度試してみてください。"
    },
    {
      "indent": 3,
      "text": "600 (Global Failure:) The server is refusing to fulfill the request. The client should not retry.",
      "ja": "600（グローバル失敗:)サーバーが要求を満たすために拒否しています。クライアントが再試行するべきではありません。"
    },
    {
      "indent": 0,
      "text": "11.2.10 UNKNOWN-ATTRIBUTES",
      "section_title": true,
      "ja": "11.2.10 UNKNOWN-ATTRIBUTES"
    },
    {
      "indent": 3,
      "text": "The UNKNOWN-ATTRIBUTES attribute is present only in a Binding Error Response or Shared Secret Error Response when the response code in the ERROR-CODE attribute is 420.",
      "ja": "UNKNOWN-ATTRIBUTESはERROR-CODEアトリビュートにおけるレスポンスコードが420である場合にのみ結合エラーレスポンスまたは共有秘密エラーレスポンスに存在している属性。"
    },
    {
      "indent": 3,
      "text": "The attribute contains a list of 16 bit values, each of which represents an attribute type that was not understood by the server. If the number of unknown attributes is an odd number, one of the attributes MUST be repeated in the list, so that the total length of the list is a multiple of 4 bytes.",
      "ja": "属性は、サーバによって理解されなかった属性タイプを表し各々が16ビット値のリストを含みます。未知の属性の数が奇数である場合は、リストの合計の長さが4バイトの倍数になるように、属性の1つは、リスト内で繰り返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |      Attribute 1 Type           |     Attribute 2 Type        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |      Attribute 3 Type           |     Attribute 4 Type    ...\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.2.11 REFLECTED-FROM",
      "section_title": true,
      "ja": "11.2.11は反射FROM"
    },
    {
      "indent": 3,
      "text": "The REFLECTED-FROM attribute is present only in Binding Responses, when the Binding Request contained a RESPONSE-ADDRESS attribute. The attribute contains the identity (in terms of IP address) of the source where the request came from. Its purpose is to provide traceability, so that a STUN server cannot be used as a reflector for denial-of-service attacks.",
      "ja": "反射から属性バインディング要求がRESPONSE-ADDRESS属性を含む場合、のみバインド応答に存在しています。属性は、要求が来たから元の（IPアドレスの観点で）アイデンティティが含まれています。その目的は、STUNサーバーは、サービス拒否攻撃のための反射板として使用することはできませんように、トレーサビリティを提供することです。"
    },
    {
      "indent": 3,
      "text": "Its syntax is identical to the MAPPED-ADDRESS attribute.",
      "ja": "その構文はMAPPED-ADDRESS属性と同じです。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1 Attacks on STUN",
      "section_title": true,
      "ja": "STUNの12.1攻撃"
    },
    {
      "indent": 3,
      "text": "Generally speaking, attacks on STUN can be classified into denial of service attacks and eavesdropping attacks. Denial of service attacks can be launched against a STUN server itself, or against other elements using the STUN protocol.",
      "ja": "一般的に言って、STUNへの攻撃は、サービス拒否攻撃や盗聴攻撃の拒否に分類することができます。サービス妨害攻撃は、STUNサーバー自体に対して、またはSTUNプロトコルを使用して他の要素に対して実行することができます。"
    },
    {
      "indent": 3,
      "text": "STUN servers create state through the Shared Secret Request mechanism. To prevent being swamped with traffic, a STUN server SHOULD limit the number of simultaneous TLS connections it will hold open by dropping an existing connection when a new connection request arrives (based on an Least Recently Used (LRU) policy, for example). Similarly, it SHOULD limit the number of shared secrets it will store, in the event that the server is storing the shared secrets.",
      "ja": "STUNサーバは、共有シークレット要求機構を介して状態を作成します。トラフィックが殺到するのを防ぐために、STUNサーバーが新しい接続要求が到着したときに既存の接続をドロップすることによって、オープン開催する同時TLS接続の数を制限する必要があります（例えば、最低使用頻度（LRU）ポリシーに基づいて）。同様に、サーバは共有秘密を記憶している場合には、それが記憶する共有秘密キーの数を制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "The attacks of greater interest are those in which the STUN server and client are used to launch DOS attacks against other entities, including the client itself.",
      "ja": "大きな関心の攻撃は、STUNサーバとクライアントは、クライアント自体を含む他のエンティティに対するDOS攻撃を起動するために使用されているものがあります。"
    },
    {
      "indent": 3,
      "text": "Many of the attacks require the attacker to generate a response to a legitimate STUN request, in order to provide the client with a faked MAPPED-ADDRESS. The attacks that can be launched using such a technique include:",
      "ja": "攻撃の多くは、偽造MAPPED-ADDRESSをクライアントに提供するために、正当なSTUN要求に対する応答を生成するために、攻撃者が必要です。このような技術を使用して起動することができます攻撃は、次のとおりです。"
    },
    {
      "indent": 0,
      "text": "12.1.1 Attack I: DDOS Against a Target",
      "section_title": true,
      "ja": "12.1.1攻撃I：標的に対してDDOS"
    },
    {
      "indent": 3,
      "text": "In this case, the attacker provides a large number of clients with the same faked MAPPED-ADDRESS that points to the intended target. This will trick all the STUN clients into thinking that their addresses are equal to that of the target. The clients then hand out that address in order to receive traffic on it (for example, in SIP or H.323 messages). However, all of that traffic becomes focused at the intended target. The attack can provide substantial amplification, especially when used with clients that are using STUN to enable multimedia applications.",
      "ja": "この場合、攻撃者は、意図した標的を指す同じ偽装MAPPED-ADDRESSと多数のクライアントを提供します。これは、それらのアドレスはターゲットと同等であることを考えることに、すべてのSTUNクライアントをだまします。クライアントは、（例えば、SIPやH.323メッセージ内で）その上でトラフィックを受信するために、そのアドレスを配ります。しかし、そのトラフィックのすべてが意図した目標に焦点を当てた状態になります。攻撃は、マルチメディア・アプリケーションを可能にするために、STUNを使用しているクライアントで使用し、特にかなりの増幅を、提供することができます。"
    },
    {
      "indent": 0,
      "text": "12.1.2 Attack II: Silencing a Client",
      "section_title": true,
      "ja": "12.1.2攻撃II：クライアントを消します"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker seeks to deny a client access to services enabled by STUN (for example, a client using STUN to enable SIP-based multimedia traffic). To do that, the attacker provides that client with a faked MAPPED-ADDRESS. The MAPPED-ADDRESS it provides is an IP address that routes to nowhere. As a result, the client won't receive any of the packets it expects to receive when it hands out the MAPPED-ADDRESS.",
      "ja": "この攻撃では、攻撃者が（例えば、SIPベースのマルチメディアトラフィックを有効にするには、STUNを使用するクライアント）STUNによって対応サービスへのクライアントアクセスを拒否することを目指しています。そのためには、攻撃者が偽造MAPPED-ADDRESSとそのクライアントを提供します。それが提供するMAPPED-ADDRESSは、ルートがどこにIPアドレスです。その結果、クライアントは、それがMAPPED-ADDRESSを渡したときに受信することを期待するパケットのいずれかを受け取ることができません。"
    },
    {
      "indent": 3,
      "text": "This exploitation is not very interesting for the attacker. It impacts a single client, which is frequently not the desired target. Moreover, any attacker that can mount the attack could also deny service to the client by other means, such as preventing the client from receiving any response from the STUN server, or even a DHCP server.",
      "ja": "この開発は、攻撃者にとって非常に興味深いものではありません。それに影響を与える頻繁に所望のターゲットではない単一のクライアント、。また、攻撃を仕掛けることができます任意の攻撃者は、このようなSTUNサーバー、あるいはDHCPサーバからの応答を受信からクライアントを防ぐなど、他の手段によって、クライアントへのサービスを拒否することができます。"
    },
    {
      "indent": 0,
      "text": "12.1.3 Attack III: Assuming the Identity of a Client",
      "section_title": true,
      "ja": "12.1.3攻撃III：クライアントのアイデンティティを仮定すると、"
    },
    {
      "indent": 3,
      "text": "This attack is similar to attack II. However, the faked MAPPED-ADDRESS points to the attacker themself. This allows the attacker to receive traffic which was destined for the client.",
      "ja": "この攻撃は、攻撃IIに似ています。しかし、攻撃者はその人自身にマッピングされた-ADDRESSポイントを偽造。これにより、攻撃者は、クライアント宛てたトラフィックを受信することができます。"
    },
    {
      "indent": 0,
      "text": "12.1.4 Attack IV: Eavesdropping",
      "section_title": true,
      "ja": "12.1.4攻撃IV：盗み聞き"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker forces the client to use a MAPPED-ADDRESS that routes to itself. It then forwards any packets it receives to the client. This attack would allow the attacker to observe all packets sent to the client. However, in order to launch the attack, the attacker must have already been able to observe packets from the client to the STUN server. In most cases (such as when the attack is launched from an access network), this means that the attacker could already observe packets sent to the client. This attack is, as a result, only useful for observing traffic by attackers on the path from the client to the STUN server, but not generally on the path of packets being routed towards the client.",
      "ja": "この攻撃では、攻撃者は、自分自身にマッピングされた-ADDRESSルートを使用するようにクライアントを強制します。それは、それがクライアントに受け取るすべてのパケットを転送します。この攻撃では、攻撃者がクライアントに送信されたすべてのパケットを観察することができるようになります。しかし、攻撃を開始するためには、攻撃者は、すでにSTUNサーバーへのクライアントからのパケットを観察することができたに違いありません。 （このような攻撃は、アクセスネットワークから起動された場合など）、ほとんどの場合、これは、攻撃者は、すでにクライアントに送信されたパケットを観察することができたことを意味します。この攻撃ではなく、一般的にクライアントに向けてルーティングされたパケットのパス上に、クライアントからSTUNサーバーへのパス上の攻撃者がトラフィックを観察するだけで便利、結果として、あります。"
    },
    {
      "indent": 0,
      "text": "12.2 Launching the Attacks",
      "section_title": true,
      "ja": "12.2攻撃を"
    },
    {
      "indent": 3,
      "text": "It is important to note that attacks of this nature (injecting responses with fake MAPPED-ADDRESSes) require that the attacker be capable of eavesdropping requests sent from the client to the server (or to act as a MITM for such attacks). This is because STUN requests contain a transaction identifier, selected by the client, which is random with 128 bits of entropy. The server echoes this value in the response, and the client ignores any responses that don't have a matching transaction ID. Therefore, in order for an attacker to provide a faked response that is accepted by the client, the attacker needs to know what the transaction ID in the request was. The large amount of randomness, combined with the need to know when the client sends a request, precludes attacks that involve guessing the transaction ID.",
      "ja": "（偽のMAPPED-アドレスで応答を注入する）この種の攻撃は、攻撃者がクライアントからサーバに送信された盗聴要求できること（または、そのような攻撃のMITMとして機能する）ことを必要とすることに注意することが重要です。 STUN要求がエントロピーの128ビットのランダムでクライアントによって選択されたトランザクション識別子を含むためです。サーバが応答して、この値をエコー、およびクライアントは、一致するトランザクションIDをお持ちでない任意の応答を無視します。そのため、クライアントによって受け入れられている偽造応答を提供するために、攻撃者のためのためには、攻撃者が要求におけるトランザクションIDが何であったかを知る必要があります。クライアントが要求を送信するときに知る必要と組み合わせてランダ​​ムに大量のは、トランザクションIDを推測伴う攻撃を排除します。"
    },
    {
      "indent": 3,
      "text": "Since all of the above attacks rely on this one primitive - injecting a response with a faked MAPPED-ADDRESS - preventing the attacks is accomplished by preventing this one operation. To prevent it, we need to consider the various ways in which it can be accomplished. There are several:",
      "ja": "偽造MAPPED-ADDRESSと応答を注入 -   - 上記の攻撃のすべてはこのプリミティブに依存しているので、攻撃を防ぐこのいずれかの操作を防止することによって達成されます。それを防ぐために、我々はそれを達成することができるさまざまな方法を検討する必要があります。いくつかあります。"
    },
    {
      "indent": 0,
      "text": "12.2.1 Approach I: Compromise a Legitimate STUN Server",
      "section_title": true,
      "ja": "12.2.1アプローチI：正当なSTUNサーバーを危険にさらします"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker compromises a legitimate STUN server through a virus or Trojan horse. Presumably, this would allow the attacker to take over the STUN server, and control the types of responses it generates.",
      "ja": "この攻撃では、攻撃者は、ウイルスやトロイの木馬によって合法的なSTUNサーバーを損ないます。おそらく、これは、攻撃者がSTUNサーバーを引き継ぎ、そしてそれが生成する反応の種類を制御することができるようになります。"
    },
    {
      "indent": 3,
      "text": "Compromise of a STUN server can also lead to discovery of open ports. Knowledge of an open port creates an opportunity for DoS attacks on those ports (or DDoS attacks if the traversed NAT is a full cone NAT). Discovering open ports is already fairly trivial using port probing, so this does not represent a major threat.",
      "ja": "STUNサーバーの妥協も開いているポートの発見につながることができます。 （トラバースNATがフルコーンNATがある場合やDDoS攻撃）開いているポートの知識は、これらのポート上のDoS攻撃の機会を作成します。開いているポートを発見するプロービングポートを使用して、すでにかなり簡単ですので、これは大きな脅威を表すものではありません。"
    },
    {
      "indent": 0,
      "text": "12.2.2 Approach II: DNS Attacks",
      "section_title": true,
      "ja": "12.2.2アプローチII：DNS攻撃"
    },
    {
      "indent": 3,
      "text": "STUN servers are discovered using DNS SRV records. If an attacker can compromise the DNS, it can inject fake records which map a domain name to the IP address of a STUN server run by the attacker. This will allow it to inject fake responses to launch any of the attacks above.",
      "ja": "STUNサーバーは、DNS SRVレコードを使用して発見されます。攻撃者がDNSを損なうことができれば、それは攻撃者によって実行さSTUNサーバーのドメイン名をIPアドレスにマッピングし、偽のレコードを注入することができます。これは、上記の攻撃のいずれかを起動するために偽の応答を注入することができます。"
    },
    {
      "indent": 0,
      "text": "12.2.3 Approach III: Rogue Router or NAT",
      "section_title": true,
      "ja": "12.2.3アプローチIII：ローグルータまたはNAT"
    },
    {
      "indent": 3,
      "text": "Rather than compromise the STUN server, an attacker can cause a STUN server to generate responses with the wrong MAPPED-ADDRESS by compromising a router or NAT on the path from the client to the STUN server. When the STUN request passes through the rogue router or NAT, it rewrites the source address of the packet to be that of the desired MAPPED-ADDRESS. This address cannot be arbitrary. If the attacker is on the public Internet (that is, there are no NATs between it and the STUN server), and the attacker doesn't modify the STUN request, the address has to have the property that packets sent from the STUN server to that address would route through the compromised router. This is because the STUN server will send the responses back to the source address of the request. With a modified source address, the only way they can reach the client is if the compromised router directs them there. If the attacker is on the public Internet, but they can modify the STUN request, they can insert a RESPONSE-ADDRESS attribute into the request, containing the actual source address of the STUN request. This will cause the server to send the response to the client, independent of the source address the STUN server sees. This gives the attacker the ability to forge an arbitrary source address when it forwards the STUN request.",
      "ja": "STUNサーバーを危険にさらすのではなく、攻撃者がSTUNサーバはSTUNサーバーへのクライアントからのパス上のルータやNATを妥協することにより、間違ったMAPPED-ADDRESSとの応答を生成することがあります。 STUN要求が不正ルータまたはNATを通過するとき、それは所望のMAPPED-ADDRESSとするパケットの送信元アドレスを書き換えます。このアドレスは任意にすることはできません。攻撃者は、公共のインターネット上にある場合（つまり、それとSTUNサーバーの間にNATが存在しない）、およびSTUN要求を変更しない攻撃者が、アドレスがにSTUNサーバから送信されたパケットの特性を持たなければなりませんそのアドレスが損なわルータ経由のルートでしょう。 STUNサーバは、要求の送信元アドレスに応答を送り返すためです。妥協ルータがあり、それらを指示した場合に変更されたソースアドレスを使用すると、彼らはクライアントに到達することができます唯一の方法です。攻撃者は、公共のインターネット上にあるが、彼らはSTUN要求を変更することができれば、彼らはSTUN要求の実際の送信元アドレスを含む、リクエストに応答ADDRESS属性を挿入することができます。これは、サーバーがSTUNサーバが見る元アドレスの独立したクライアントへの応答を送信します。これにより、攻撃者にそれがSTUN要求を転送し、任意の送信元アドレスを偽造することができます。"
    },
    {
      "indent": 3,
      "text": "If the attacker is on a private network (that is, there are NATs between it and the STUN server), the attacker will not be able to force the server to generate arbitrary MAPPED-ADRESSes in responses. They will only be able force the STUN server to generate MAPPED-ADDRESSes which route to the private network. This is because the NAT between the attacker and the STUN server will rewrite the source address of the STUN request, mapping it to a public address that routes to the private network. Because of this, the attacker can only force the server to generate faked mapped addresses that route to the private network. Unfortunately, it is possible that a low quality NAT would be willing to map an allocated public address to another public address (as opposed to an internal private address), in which case the attacker could forge the source address in a STUN request to be an arbitrary public address. This kind of behavior from NATs does appear to be rare.",
      "ja": "攻撃者は（つまり、それとSTUNサーバの間のNATがある）は、プライベートネットワーク上にある場合、攻撃者が回答に任意のMAPPED-住所がを生成するために、サーバーを強制することはできません。彼らはどのルートプライベートネットワークにマッピングされ、アドレスを生成するために、STUNサーバことが力になります。攻撃者とSTUNサーバー間のNATは、そのプライベートネットワークへのルートパブリックアドレスにマッピング、STUN要求の送信元アドレスを書き換えるためです。このため、攻撃者はそのプライベートネットワークへのルート偽造マッピングされたアドレスを生成するために、サーバーを強制することができます。残念ながら、低品質のNATは、攻撃者がSTUN要求のソースアドレスがあることを偽造可能性がある場合には、別のパブリックアドレス（内部プライベートアドレスではなく）、に割り当てられたパブリックアドレスをマッピングすることをいとわないことがあります任意のパブリックアドレス。 NATの行動から、この種の希少なように見えるん。"
    },
    {
      "indent": 0,
      "text": "12.2.4 Approach IV: MITM",
      "section_title": true,
      "ja": "12.2.4アプローチIV：MITM"
    },
    {
      "indent": 3,
      "text": "As an alternative to approach III, if the attacker can place an element on the path from the client to the server, the element can act as a man-in-the-middle. In that case, it can intercept a STUN request, and generate a STUN response directly with any desired value of the MAPPED-ADDRESS field. Alternatively, it can forward the STUN request to the server (after potential modification), receive the response, and forward it to the client. When forwarding the request and response, this attack is subject to the same limitations on the MAPPED-ADDRESS described in Section 12.2.3.",
      "ja": "攻撃者がクライアントからサーバーへのパス上の要素を配置することができれば、IIIにアプローチする別の方法として、要素はのman-in-the-middleとして機能することができます。その場合には、STUN要求をインターセプトすることができ、マッピングされたアドレスフィールドの任意の所望の値を直接STUN応答を生成します。また、それは、（潜在的な改変後）サーバへのSTUN要求を転送し、応答を受け取り、それをクライアントに転送することができます。要求と応答を転送する場合、この攻撃は、セクション12.2.3に記載MAPPED-ADDRESSに同じ制限を受けます。"
    },
    {
      "indent": 0,
      "text": "12.2.5 Approach V: Response Injection Plus DoS",
      "section_title": true,
      "ja": "12.2.5アプローチV：レスポンスインジェクションプラスのDoS"
    },
    {
      "indent": 3,
      "text": "In this approach, the attacker does not need to be a MITM (as in approaches III and IV). Rather, it only needs to be able to eavesdrop onto a network segment that carries STUN requests. This is easily done in multiple access networks such as ethernet or unprotected 802.11. To inject the fake response, the attacker listens on the network for a STUN request. When it sees one, it simultaneously launches a DoS attack on the STUN server, and generates its own STUN response with the desired MAPPED-ADDRESS value. The STUN response generated by the attacker will reach the client, and the DoS attack against the server is aimed at preventing the legitimate response from the server from reaching the client. Arguably, the attacker can do without the DoS attack on the server, so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it's different).",
      "ja": "（III及びIVに近づくように）このアプローチでは、攻撃者がMITMである必要はありません。むしろ、それだけSTUN要求を搬送するネットワークセグメント上に盗聴することができる必要があります。これは、簡単なイーサネットまたは保護されていない802.11など複数のアクセスネットワークで行われます。偽の応答を注入するために、攻撃者がSTUN要求のためのネットワーク上でリッスンします。それが1を見たとき、それは同時にSTUNサーバー上のDoS攻撃を開始し、希望MAPPED-ADDRESS値を持つ独自のSTUN応答を生成します。攻撃者によって生成されたSTUN応答がクライアントに到達し、サーバに対するDoS攻撃は、クライアントに達することから、サーバから正当な応答を防止することを目的としています。間違いなく、攻撃者は、そう長く偽造応答は、クライアントに実際の応答を打つと、クライアントは最初の応答を使用し、（それは違うにもかかわらず）は、第2のを無視して、サーバー上のDoS攻撃せずに行うことができます。"
    },
    {
      "indent": 0,
      "text": "12.2.6 Approach VI: Duplication",
      "section_title": true,
      "ja": "12.2.6アプローチVI：複製"
    },
    {
      "indent": 3,
      "text": "This approach is similar to approach V. The attacker listens on the network for a STUN request. When it sees it, it generates its own STUN request towards the server. This STUN request is identical to the one it saw, but with a spoofed source IP address. The spoofed address is equal to the one that the attacker desires to have placed in the MAPPED-ADDRESS of the STUN response. In fact, the attacker generates a flood of such packets. The STUN server will receive the one original request, plus a flood of duplicate fake ones. It generates responses to all of them. If the flood is sufficiently large for the responses to congest routers or some other equipment, there is a reasonable probability that the one real response is lost (along with many of the faked ones), but the net result is that only the faked responses are received by the STUN client. These responses are all identical and all contain the MAPPED-ADDRESS that the attacker wanted the client to use.",
      "ja": "このアプローチアプローチに似てV.攻撃者がSTUN要求のためのネットワークをリッスン。それを見ているときは、サーバーへの独自のSTUN要求を生成します。このSTUN要求は、それが見たものと同じですが、偽装された送信元のIPアドレスを持ちます。スプーフィングされたアドレスは、攻撃者がSTUN応答のマッピングされた-ADDRESSに配置されていることを望む1に等しいです。実際には、攻撃者がこのようなパケットの洪水を発生させます。 STUNサーバは、1つのオリジナルの要求に加え、重複した偽のものの洪水を受け取ることになります。これは、それらのすべてに対する応答を生成します。洪水がルーターを輻輳する応答またはいくつかの他の機器のために十分に大きい場合、そこに（偽造のものの多くと一緒に）1つの実応答が失われたことを合理的な可能性があるが、最終結果は唯一の偽造応答があるということですSTUNクライアントが受信しました。これらの応答はすべて同一であり、すべては、攻撃者がクライアントを使用していたMAPPED-ADDRESSが含まれています。"
    },
    {
      "indent": 3,
      "text": "The flood of duplicate packets is not needed (that is, only one faked request is sent), so long as the faked response beats the real response back to the client, and the client uses the first response, and ignores the second (even though it's different).",
      "ja": "重複パケットの洪水が必要とされていない限り偽造応答は、クライアントに実際の応答を打つと、クライアントは最初の応答を使用し、たとえ（第2を無視して、（それが唯一の要求が送られる偽造、です）違います）。"
    },
    {
      "indent": 3,
      "text": "Note that, in this approach, launching a DoS attack against the STUN server or the IP network, to prevent the valid response from being sent or received, is problematic. The attacker needs the STUN server to be available to handle its own request. Due to the periodic retransmissions of the request from the client, this leaves a very tiny window of opportunity. The attacker must start the DoS attack immediately after the actual request from the client, causing the correct response to be discarded, and then cease the DoS attack in order to send its own request, all before the next retransmission from the client. Due to the close spacing of the retransmits (100ms to a few seconds), this is very difficult to do.",
      "ja": "送信または受信されてからの有効な応答を防ぐために、STUNサーバやIPネットワークに対するDoS攻撃を開始、このアプローチでは、なお、問題があります。攻撃者は、独自のリクエストを処理するために利用できるようにSTUNサーバーを必要とします。クライアントからの要求の定期的な再送信には、これは機会の非常に小さなウィンドウを残します。攻撃者は、正しい応答を廃棄する原因と、クライアントからの実際の要求の直後にDoS攻撃を開始し、その後、すべてのクライアントからの次の再送信する前に、独自の要求を送信するために、DoS攻撃を停止する必要があります。再送（数秒に100ミリ秒）の近い間隔に、これを行うのは非常に困難です。"
    },
    {
      "indent": 3,
      "text": "Besides DoS attacks, there may be other ways to prevent the actual request from the client from reaching the server. Layer 2 manipulations, for example, might be able to accomplish it.",
      "ja": "DoS攻撃のほかに、サーバーに達することから、クライアントからの実際の要求を防ぐために、他の方法があるかもしれません。レイヤ2つの操作は、例えば、それを達成することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Fortunately, Approach IV is subject to the same limitations documented in Section 12.2.3, which limit the range of MAPPED-ADDRESSes the attacker can cause the STUN server to generate.",
      "ja": "幸いなことに、アプローチIVは、攻撃者がSTUNサーバが生成する可能性がありますMAPPED-アドレスの範囲を制限12.2.3項に記載と同じ制限に従うものとします。"
    },
    {
      "indent": 0,
      "text": "12.3 Countermeasures",
      "section_title": true,
      "ja": "12.3対策"
    },
    {
      "indent": 3,
      "text": "STUN provides mechanisms to counter the approaches described above, and additional, non-STUN techniques can be used as well.",
      "ja": "STUNは、上述のアプローチに対抗するためのメカニズムを提供し、付加的な、非STUN技術も同様に使用することができます。"
    },
    {
      "indent": 3,
      "text": "First off, it is RECOMMENDED that networks with STUN clients implement ingress source filtering (RFC 2827 [7]). This is particularly important for the NATs themselves. As Section 12.2.3 explains, NATs which do not perform this check can be used as \"reflectors\" in DDoS attacks. Most NATs do perform this check as a default mode of operation. We strongly advise people that purchase NATs to ensure that this capability is present and enabled.",
      "ja": "最初のオフ、（[7] RFC 2827）STUNクライアントとネットワークが入力ソースフィルタリングを実装することが推奨されます。これは、NATを自分自身のために特に重要です。 12.2.3項が説明するように、このチェックを実行していないNATは、DDoS攻撃では「反射」として使用することができます。ほとんどのNATはデフォルトの動作モードとしては、このチェックを実行しません。私たちは強く、この機能が存在し、有効であることを確認するために、NATのを購入する人に助言します。"
    },
    {
      "indent": 3,
      "text": "Secondly, it is RECOMMENDED that STUN servers be run on hosts dedicated to STUN, with all UDP and TCP ports disabled except for the STUN ports. This is to prevent viruses and Trojan horses from infecting STUN servers, in order to prevent their compromise. This helps mitigate Approach I (Section 12.2.1).",
      "ja": "第二に、STUNサーバは、STUNポートを除くすべて無効にUDPとTCPポートと、STUNに専用ホスト上で実行することをお勧めします。これは彼らの妥協を防ぐために、STUNサーバに感染するウイルスやトロイの木馬を防ぐためです。これは、I（12.2.1）のアプローチを軽減します。"
    },
    {
      "indent": 3,
      "text": "Thirdly, to prevent the DNS attack of Section 12.2.2, Section 9.2 recommends that the client verify the credentials provided by the server with the name used in the DNS lookup.",
      "ja": "第三に、12.2.2のDNS攻撃を防ぐために、9.2節では、クライアントがDNSルックアップで使用された名前のサーバが提供する資格情報を確認することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Finally, all of the attacks above rely on the client taking the mapped address it learned from STUN, and using it in application layer protocols. If encryption and message integrity are provided within those protocols, the eavesdropping and identity assumption attacks can be prevented. As such, applications that make use of STUN addresses in application protocols SHOULD use integrity and encryption, even if a SHOULD level strength is not specified for that protocol. For example, multimedia applications using STUN addresses to receive RTP traffic would use secure RTP [16].",
      "ja": "最後に、攻撃のすべては、上記のそれはSTUNから学んだマップされたアドレスを取得し、アプリケーション層プロトコルでそれを使用して、クライアントに依存しています。暗号化とメッセージの整合性が、これらのプロトコル内に設けられている場合は、盗聴やアイデンティティ仮定攻撃を防止することができます。そのため、アプリケーションプロトコルでSTUNアドレスを使用するアプリケーションは、SHOULDレベルの強さはそのプロトコル用に指定されていない場合でも、整合性と暗号化を使用すべきです。例えば、RTPトラフィックを受信するためにSTUNアドレスを使用してマルチメディアアプリケーションは、安全なRTP [16]を使用します。"
    },
    {
      "indent": 3,
      "text": "The above three techniques are non-STUN mechanisms. STUN itself provides several countermeasures.",
      "ja": "上記3つの技術は、非STUNメカニズムです。 STUN自体は、いくつかの対策を提供します。"
    },
    {
      "indent": 3,
      "text": "Approaches IV (Section 12.2.4), when generating the response locally, and V (Section 12.2.5) require an attacker to generate a faked response. This attack is prevented using the message integrity mechanism provided in STUN, described in Section 8.1.",
      "ja": "IV（セクション12.2.4）、局所的応答を生成し、V（セクション12.2.5）は偽造応答を生成するために、攻撃者が必要に近づきます。この攻撃は、8.1節で説明STUNに設けられたメッセージ完全性機構を使用して防止することができます。"
    },
    {
      "indent": 3,
      "text": "Approaches III (Section 12.2.3) IV (Section 12.2.4), when using the relaying technique, and VI (12.2.6), however, are not preventable through server signatures. Both approaches are most potent when the attacker can modify the request, inserting a RESPONSE-ADDRESS that routes to the client. Fortunately, such modifications are preventable using the message integrity techniques described in Section 9.3. However, these three approaches are still functional when the attacker modifies nothing but the source address of the STUN request. Sadly, this is the one thing that cannot be protected through cryptographic means, as this is the change that STUN itself is seeking to detect and report. It is therefore an inherent weakness in NAT, and not fixable in STUN. To help mitigate these attacks, Section 9.4 provides several heuristics for the client to follow. The client looks for inconsistent or extra responses, both of which are signs of the attacks described above. However, these heuristics are just that - heuristics, and cannot be guaranteed to prevent attacks. The heuristics appear to prevent the attacks as we know how to launch them today. Implementors should stay posted for information on new heuristics that might be required in the future. Such information will be distributed on the IETF MIDCOM mailing list, midcom@ietf.org.",
      "ja": "中継方式を使用する場合、III（セクション12.2.3）IV（セクション12.2.4）に近づく、及びVI（12.2.6）、しかし、サーバ署名を通じて予防ありません。攻撃者がそのクライアントへのルート応答アドレスを挿入し、要求を変更することができたときに両方のアプローチは、最も強力です。幸いなことに、そのような改変は、セクション9.3で説明したメッセージの完全性技術を用いて予防可能です。攻撃者がSTUN要求の送信元アドレスだけを変更していない場合しかし、これらの3つのアプローチがまだ機能しています。これはSTUN自身が検出してレポートしようとしている変更であるよう悲しいことに、これは、暗号化の手段で保護することができない一つのことです。したがって、本来のNATでの弱さ、そしてSTUNで修正可能ではありません。これらの攻撃を軽減するために、9.4節では、クライアントが追従するためのいくつかのヒューリスティックを提供します。クライアントは、上記の攻撃の兆候ですどちらも矛盾や余分な応答を探します。ヒューリスティック、および攻撃を防ぐために保証することはできません - しかし、これらの経験則はまさにそれです。ヒューリスティックは、私たちが今日、それらを起動する方法を知っているような攻撃を防ぐように見えます。実装者は、将来的に必要になる場合があります新しいヒューリスティックについては、掲載滞在する必要があります。このような情報は、IETF MIDCOMメーリングリスト、midcom@ietf.orgに配布されます。"
    },
    {
      "indent": 0,
      "text": "12.4 Residual Threats",
      "section_title": true,
      "ja": "12.4残留脅威"
    },
    {
      "indent": 3,
      "text": "None of the countermeasures listed above can prevent the attacks described in Section 12.2.3 if the attacker is in the appropriate network paths. Specifically, consider the case in which the attacker wishes to convince client C that it has address V. The attacker needs to have a network element on the path between A and the server (in order to modify the request) and on the path between the server and V so that it can forward the response to C. Furthermore, if there is a NAT between the attacker and the server, V must also be behind the same NAT. In such a situation, the attacker can either gain access to all the application-layer traffic or mount the DDOS attack described in Section 12.1.1. Note that any host which exists in the correct topological relationship can be DDOSed. It need not be using STUN.",
      "ja": "攻撃者は、適切なネットワーク・パスにある場合、上記の対策のいずれも、セクション12.2.3に記載の攻撃を防ぐことはできません。具体的には、攻撃者は、それが攻撃者が（リクエストを修正するために）Aとサーバーとの間の経路上のネットワーク要素を持つ必要アドレスVを有するクライアントCを説得したい場合を考えるとの間の経路に攻撃者とサーバ間のNATがある場合、それは、さらにC.への応答を転送できるように、サーバーおよびVは、Vは、同じNATの背後でなければなりません。このような状況では、攻撃者は、すべてのアプリケーション層のトラフィックへのアクセスを得るか、12.1.1項で説明したDDOS攻撃を仕掛けることができます。正しい位相関係に存在するすべてのホストがDDOSedことができることに注意してください。これは、STUNを使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "13. IANA Considerations",
      "section_title": true,
      "ja": "13. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "STUN cannot be extended. Changes to the protocol are made through a standards track revision of this specification. As a result, no IANA registries are needed. Any future extensions will establish any needed registries.",
      "ja": "STUNを拡張することはできません。プロトコルへの変更は、この仕様の標準化トラック改正を介して行われます。その結果、IANAレジストリは必要ありません。任意の将来の拡張には、必要なレジストリを確立します。"
    },
    {
      "indent": 0,
      "text": "14. IAB Considerations",
      "section_title": true,
      "ja": "14. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of \"Unilateral Self Address Fixing\", which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism (RFC 3424 [17]). STUN is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. This section meets those requirements.",
      "ja": "IABは、クライアントが協調プロトコル反射機構を介してNATの反対側に別の領域にそのアドレスを決定しようとすることによって一般的な方法は「一方的な自己アドレス固定」の問題を研究した（RFC 3424 [17] ）。 STUNは、関数のこのタイプを行うプロトコルの一例です。 IABは、任意のプロトコルは、この目的の文書の検討事項の特定のセットを開発することを義務付けています。ここでは、これらの要件を満たしています。"
    },
    {
      "indent": 0,
      "text": "14.1 Problem Definition",
      "section_title": true,
      "ja": "14.1問題定義"
    },
    {
      "indent": 3,
      "text": "From RFC 3424 [17], any UNSAF proposal must provide:",
      "ja": "RFC 3424 [17]から、任意のUNSAF提案を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short term fix should not be generalized to solve other problems; this is why \"short term fixes usually aren't\".",
      "ja": "UNSAF提案で解決されるべき特定の、限定されたスコープの問題の正確な定義。短期的な修正は、他の問題を解決するために一般化すべきではありません。 「短期の修正は通常はない」理由です。"
    },
    {
      "indent": 3,
      "text": "The specific problems being solved by STUN are:",
      "ja": "STUNによって解決されている具体的な問題は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to detect the presence of one or more NATs between it and a server run by a service provider on the public Internet. The purpose of such detection is to determine additional steps that might be necessary in order to receive service from that particular provider.",
      "ja": "Oそれは、公共のインターネット上のサービスプロバイダによって運営サーバーとの間の1つのまたは複数のNATの存在を検出するためのクライアントのための手段を提供します。そのような検出の目的は、特定のプロバイダからサービスを受信するために必要かもしれない追加のステップを決定することです。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to detect the presence of one or more NATs between it and another client, where the second client is reachable from the first, but it is not known whether the second client resides on the public Internet.",
      "ja": "Oそれと第2のクライアントが最初から到達可能であるが、第2のクライアントは、パブリックインターネット上に存在するかどうかは知られていない別のクライアントとの間の1つのまたは複数のNATの存在を検出するためのクライアントのための手段を提供します。"
    },
    {
      "indent": 3,
      "text": "o Provide a means for a client to obtain an address on the public Internet from a non-symmetric NAT, for the express purpose of receiving incoming UDP traffic from another host, targeted to that address.",
      "ja": "Oクライアントがそのアドレスをターゲットに別のホストからの着信UDPトラフィックを受信する明確な目的のために、非対称NATから公共のインターネット上のアドレスを取得するための手段を提供します。"
    },
    {
      "indent": 3,
      "text": "STUN does not address TCP, either incoming or outgoing, and does not address outgoing UDP communications.",
      "ja": "STUNは、着信または発信のいずれか、TCPには対応していません、および発信UDP通信に対応していません。"
    },
    {
      "indent": 0,
      "text": "14.2 Exit Strategy",
      "section_title": true,
      "ja": "14.2出口戦略"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、任意のUNSAF提案を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Description of an exit strategy/transition plan. The better short term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.",
      "ja": "出口戦略/移行計画の説明。より良い短期間フィックスは、適切な技術が展開されると自然に減って使用が表示されますものです。"
    },
    {
      "indent": 3,
      "text": "STUN comes with its own built in exit strategy. This strategy is the detection operation that is performed as a precursor to the actual UNSAF address-fixing operation. This discovery operation, documented in Section 10.1, attempts to discover the existence of, and type of, any NATS between the client and the service provider network. Whilst the detection of the specific type of NAT may be brittle, the discovery of the existence of NAT is itself quite robust. As NATs are phased out through the deployment of IPv6, the discovery operation will return immediately with the result that there is no NAT, and no further operations are required. Indeed, the discovery operation itself can be used to help motivate deployment of IPv6; if a user detects a NAT between themselves and the public Internet, they can call up their access provider and complain about it.",
      "ja": "STUNは出口戦略に組み込まれた独自の付属しています。この戦略は、実際のUNSAFアドレス定着動作の前駆体として実行される検出動作です。 10.1節に記載この発見操作は、クライアントとサービスプロバイダネットワークの間のいずれかのNATSの存在を発見しようとする、との種類。 NATの特定のタイプの検出が脆くなるかもしれないが、NATの存在の発見は、それ自体は非常に堅牢です。 NATのは、IPv6の展開を通じて段階的に廃止されると、検出操作は、そこにはNATでなく、それ以上の操作は必要ありません、その結果、すぐに戻ります。実際に、検出操作自体は、IPv6の意欲を高める展開を支援するために使用することができます。ユーザーが自分自身と公共のインターネット間のNATを検出した場合、彼らは彼らのアクセスプロバイダを呼び出し、それについて文句を言うことができます。"
    },
    {
      "indent": 3,
      "text": "STUN can also help facilitate the introduction of midcom. As midcom-capable NATs are deployed, applications will, instead of using STUN (which also resides at the application layer), first allocate an address binding using midcom. However, it is a well-known limitation of midcom that it only works when the agent knows the middleboxes through which its traffic will flow. Once bindings have been allocated from those middleboxes, a STUN detection procedure can validate that there are no additional middleboxes on the path from the public Internet to the client. If this is the case, the application can continue operation using the address bindings allocated from midcom. If it is not the case, STUN provides a mechanism for self-address fixing through the remaining midcom-unaware middleboxes. Thus, STUN provides a way to help transition to full midcom-aware networks.",
      "ja": "STUNはまた、MIDCOMの導入を促進することができます。 MIDCOM対応のNATが展開されるように、アプリケーションは、代わりに（また、アプリケーション層に常駐）STUNを使用する、最初のMIDCOMを使用してバインディングアドレスを割り当てます。しかし、それはエージェントがそのトラフィックが流れるミドルボックスを知っているときにのみ動作MIDCOMのよく知られた制限です。バインディングは、これらのミドルボックスから割り当てられた後は、STUN検出手順は、クライアントへのパブリックインターネットからのパスには、追加のミドルボックスが存在しないことを確認することができます。この場合、アプリケーションはMIDCOMから割り当てられたアドレス・バインディングを使用して動作を継続することができます。それがない場合、STUN残りMIDCOM-気付か中間装置を介して定着自己アドレスのためのメカニズムを提供します。このように、STUNはフルMIDCOM対応のネットワークへの移行を支援するための方法を提供します。"
    },
    {
      "indent": 0,
      "text": "14.3 Brittleness Introduced by STUN",
      "section_title": true,
      "ja": "STUNによって導入さ14.3脆性"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、任意のUNSAF提案を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of specific issues that may render systems more \"brittle\". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.",
      "ja": "システムより「脆い」レンダリングすることがあり、特定の問題の議論。たとえば、複数のネットワーク層でデータを使用することを含むアプローチは、デバッグの課題を高め、移行することが難しく、より多くの依存関係を作成します。"
    },
    {
      "indent": 3,
      "text": "STUN introduces brittleness into the system in several ways:",
      "ja": "STUNは、いくつかの方法でシステムにもろさが導入されています。"
    },
    {
      "indent": 3,
      "text": "o The discovery process assumes a certain classification of devices based on their treatment of UDP. There could be other types of NATs that are deployed that would not fit into one of these molds. Therefore, future NATs may not be properly detected by STUN. STUN clients (but not servers) would need to change to accommodate that.",
      "ja": "O発見プロセスは、UDPの彼らの治療に基づいてデバイスの特定の分類を前提としています。これらの金型のいずれかに収まらない展開されているNATの他のタイプがあるかもしれません。したがって、将来のNATは正しくSTUNによって検出されなくてもよいです。 STUNクライアント（ただし、サーバは）そのに適応するように変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The binding acquisition usage of STUN does not work for all NAT types. It will work for any application for full cone NATs only. For restricted cone and port restricted cone NAT, it will work for some applications depending on the application. Application specific processing will generally be needed. For symmetric NATs, the binding acquisition will not yield a usable address. The tight dependency on the specific type of NAT makes the protocol brittle.",
      "ja": "O STUNの結合を取得使用量は、すべてのNATタイプでは動作しません。それは唯一のフルコーンNATのための任意のアプリケーションのために動作します。制限付きコーン、ポート制限付きコーンNATの場合は、アプリケーションに応じて、いくつかの用途のために動作します。アプリケーション固有の処理は、一般的に必要とされるであろう。対称型NATのために、結合の取得は、利用可能なアドレスを得られません。 NATの特定のタイプのタイトな依存性は、プロトコルが脆くなります。"
    },
    {
      "indent": 3,
      "text": "o STUN assumes that the server exists on the public Internet. If the server is located in another private address realm, the user may or may not be able to use its discovered address to communicate with other users. There is no way to detect such a condition.",
      "ja": "O STUNサーバは公共のインターネット上に存在することを前提としています。サーバが別のプライベートアドレスレルムに配置されている場合、ユーザーは、他のユーザと通信するために、その発見されたアドレスを使用することができない場合があります。このような状態を検出する方法はありません。"
    },
    {
      "indent": 3,
      "text": "o The bindings allocated from the NAT need to be continuously refreshed. Since the timeouts for these bindings is very implementation specific, the refresh interval cannot easily be determined. When the binding is not being actively used to receive traffic, but to wait for an incoming message, the binding refresh will needlessly consume network bandwidth.",
      "ja": "NATから割り当てられたバインディングoを継続的にリフレッシュする必要があります。これらのバインディングのためのタイムアウトは非常に実装固有のものですので、リフレッシュ間隔を容易に判断することはできません。バインディングがアクティブにトラフィックを受信することが、着信メッセージを待つために使用されていない場合は、バインディングリフレッシュが不必要なネットワーク帯域幅を消費します。"
    },
    {
      "indent": 3,
      "text": "o The use of the STUN server as an additional network element introduces another point of potential security attack. These attacks are largely prevented by the security measures provided by STUN, but not entirely.",
      "ja": "追加のネットワーク要素としてSTUNサーバーの使用oを潜在的なセキュリティ攻撃の別のポイントを紹介します。これらの攻撃は、主にではなく、完全に、STUNが提供するセキュリティ対策によって阻止されます。"
    },
    {
      "indent": 3,
      "text": "o The use of the STUN server as an additional network element introduces another point of failure. If the client cannot locate a STUN server, or if the server should be unavailable due to failure, the application cannot function.",
      "ja": "追加のネットワーク要素としてSTUNサーバの使用oを故障の別のポイントを導入します。クライアントは、STUNサーバーが見つからない場合、またはサーバーが障害により使用できなくする必要がある場合は、アプリケーションが機能することはできません。"
    },
    {
      "indent": 3,
      "text": "o The use of STUN to discover address bindings will result in an increase in latency for applications. For example, a Voice over IP application will see an increase of call setup delays equal to at least one RTT to the STUN server.",
      "ja": "Oアドレスバインディングを発見するSTUNの使用は、アプリケーションのための待ち時間の増加をもたらすでしょう。例えば、ボイスオーバーIPアプリケーションは、STUNサーバに少なくとも1 RTTに等しい呼設定遅延の増加が表示されます。"
    },
    {
      "indent": 3,
      "text": "o The discovery of binding lifetimes is prone to error. It assumes that the same lifetime will exist for all bindings. This may not be true if the NAT uses dynamic binding lifetimes to handle overload, or if the NAT itself reboots during the discovery process.",
      "ja": "O結合寿命の発見は、エラーを起こしやすいです。これは、同じ寿命はすべてのバインディングのために存在することを前提としています。 NATは、過負荷を処理するために動的結合ライフタイムを使用する場合、またはNAT自体が発見プロセス中に再起動されます場合、これは本当ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o STUN imposes some restrictions on the network topologies for proper operation. If client A obtains an address from STUN server X, and sends it to client B, B may not be able to send to A using that IP address. The address will not work if any of the following is true:",
      "ja": "O STUNは、適切な動作のためのネットワーク・トポロジにはいくつかの制限を課しています。クライアントAは、STUNサーバXからアドレスを取得し、クライアントBに送信した場合、Bは、そのIPアドレスを使用して送信することができない場合があります。以下のいずれかに該当する場合のアドレスは動作しません。"
    },
    {
      "indent": 6,
      "text": "- The STUN server is not in an address realm that is a common ancestor (topologically) of both clients A and B. For example, consider client A and B, both of which have residential NAT devices. Both devices connect them to their cable operators, but both clients have different providers. Each provider has a NAT in front of their entire network, connecting it to the public Internet. If the STUN server used by A is in A's cable operator's network, an address obtained by it will not be usable by B. The STUN server must be in the network which is a common ancestor to both - in this case, the public Internet.",
      "ja": " -  STUNサーバは、たとえば、両方のクライアントAとBの共通の祖先（位相幾何学）であるアドレス領域で、住宅のNATデバイスを持っているどちらも、クライアントAとBを考慮されていません。両デバイスは、彼らのケーブル事業者に接続しますが、両方のクライアントは異なるプロバイダを持っています。各プロバイダは、公衆インターネットに接続し、そのネットワーク全体の前でNATを持っています。この場合、公衆インターネットで -  Aが使用するSTUNサーバがAのケーブルオペレータのネットワーク内にある場合、それによって得られたアドレスは、両方に共通の祖先であるネットワーク内にある必要がありB.ザSTUNサーバによって使用できません。"
    },
    {
      "indent": 6,
      "text": "- The STUN server is in an address realm that is a common ancestor to both clients, but both clients are behind the same NAT connecting to that address realm. For example, if the two clients in the previous example had the same cable operator, that cable operator had a single NAT connecting their network to the public Internet, and the STUN server was on the public Internet, the address obtained by A would not be usable by B. That is because some NATs will not accept an internal packet sent to a public IP address which is mapped back to an internal address. To deal with this, additional protocol mechanisms or configuration parameters need to be introduced which detect this case.",
      "ja": " -  STUNサーバーは、両方のクライアントに共通の祖先であるアドレス領域であるが、両方のクライアントは、そのアドレスレルムに接続し、同じNATの背後にあります。例えば、前の例では2つのクライアントが同じケーブルオペレータを持っていた場合は、そのケーブルオペレータは、公共のインターネットに自分のネットワークを接続する単一のNATを持っていた、とSTUNサーバは公共のインターネット上にあった、Aで得られたアドレスはないだろういくつかのNATは、内部アドレスに戻ってマッピングされているパブリックIPアドレスに送信された内部パケットを受け付けませんので、B.によって使用可能であること。これに対処するために、追加のプロトコル機構又は構成パラメータは、この場合の検出が導入される必要があります。"
    },
    {
      "indent": 3,
      "text": "o Most significantly, STUN introduces potential security threats which cannot be eliminated. This specification describes heuristics that can be used to mitigate the problem, but it is provably unsolvable given what STUN is trying to accomplish. These security problems are described fully in Section 12.",
      "ja": "O最も重要なのは、STUNを排除することができない潜在的なセキュリティ上の脅威を紹介します。この仕様は、問題を軽減するために使用することができヒューリスティックを説明し、それが達成しようとしているものSTUN与えられた証明可能解決不可能です。これらのセキュリティ問題はセクション12で完全に記載されています。"
    },
    {
      "indent": 0,
      "text": "14.4 Requirements for a Long Term Solution",
      "section_title": true,
      "ja": "長期的な解決策のための14.4要件"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、任意のUNSAF提案を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Identify requirements for longer term, sound technical solutions -- contribute to the process of finding the right longer term solution.",
      "ja": "技術的な解決策を鳴らし、長期の要件を特定する - 右の長期的な解決策を見つけるプロセスに貢献します。"
    },
    {
      "indent": 3,
      "text": "Our experience with STUN has led to the following requirements for a long term solution to the NAT problem:",
      "ja": "STUNでの経験は、NAT問題への長期的な解決策のために、次の要件につながっています。"
    },
    {
      "indent": 3,
      "text": "Requests for bindings and control of other resources in a NAT need to be explicit. Much of the brittleness in STUN derives from its guessing at the parameters of the NAT, rather than telling the NAT what parameters to use.",
      "ja": "バインディングやNAT内の他のリソースの制御のための要求は、明示的にする必要があります。 STUNにおける脆性の多くは、そのは、NATのパラメータを推測ではなく、使用するかをパラメータNATを伝えるに由来します。"
    },
    {
      "indent": 3,
      "text": "Control needs to be \"in-band\". There are far too many scenarios in which the client will not know about the location of middleboxes ahead of time. Instead, control of such boxes needs to occur in-band, traveling along the same path as the data will itself travel. This guarantees that the right set of middleboxes are controlled. This is only true for first-party controls; third-party controls are best handled using the midcom framework.",
      "ja": "コントロールは、「インバンド」である必要があります。クライアントは、事前にミドルボックスの場所を知っていないであろうに、あまりにも多くのシナリオがあります。代わりに、このようなボックスの制御は、それ自体が移動するデータと同じ経路に沿って移動する、インバンド発生する必要があります。これは、ミドルボックスの右のセットが制御されていることを保証します。これは、ファーストパーティのコントロールのための唯一の真実です。サードパーティ製のコントロールは、最高のMIDCOMフレームワークを使用して処理されます。"
    },
    {
      "indent": 3,
      "text": "Control needs to be limited. Users will need to communicate through NATs which are outside of their administrative control. In order for providers to be willing to deploy NATs which can be controlled by users in different domains, the scope of such controls needs to be extremely limited - typically, allocating a binding to reach the address where the control packets are coming from.",
      "ja": "コントロールは制限する必要があります。ユーザーは、管理制御の外にあるNATを介して通信する必要があります。典型的には、制御パケットから来ているアドレスに到達するために結合を割り当てる - プロバイダが異なるドメイン内のユーザによって制御することができるのNATを展開することをいとわないようにするために、そのようなコントロールの範囲は極めて限定される必要があります。"
    },
    {
      "indent": 3,
      "text": "Simplicity is Paramount. The control protocol will need to be implement in very simple clients. The servers will need to support extremely high loads. The protocol will need to be extremely robust, being the precursor to a host of application protocols. As such, simplicity is key.",
      "ja": "シンプルさが最も重要です。制御プロトコルは、非常に単純なクライアントに実装する必要があります。サーバーは、非常に高い負荷をサポートする必要があります。プロトコルは、アプリケーションプロトコルのホストへの前駆体である、非常に堅牢である必要があります。そのように、シンプルさが鍵となります。"
    },
    {
      "indent": 0,
      "text": "14.5 Issues with Existing NAPT Boxes",
      "section_title": true,
      "ja": "既存のNAPT箱と14.5の問題"
    },
    {
      "indent": 3,
      "text": "From [17], any UNSAF proposal must provide:",
      "ja": "[17]から、任意のUNSAF提案を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of the impact of the noted practical issues with existing, deployed NA[P]Ts and experience reports.",
      "ja": "既存と述べた実用的な問題の影響の議論は、NA [P] Tsと体験レポートを展開しました。"
    },
    {
      "indent": 3,
      "text": "Several of the practical issues with STUN involve future proofing - breaking the protocol when new NAT types get deployed. Fortunately, this is not an issue at the current time, since most of the deployed NATs are of the types assumed by STUN. The primary usage STUN has found is in the area of VoIP, to facilitate allocation of addresses for receiving RTP [12] traffic. In that application, the periodic keepalives are provided by the RTP traffic itself. However, several practical problems arise for RTP. First, RTP assumes that RTCP traffic is on a port one higher than the RTP traffic. This pairing property cannot be guaranteed through NATs that are not directly controllable. As a result, RTCP traffic may not be properly received. Protocol extensions to SDP have been proposed which mitigate this by allowing the client to signal a different port for RTCP [18]. However, there will be interoperability problems for some time.",
      "ja": "STUNと実用的な問題のいくつかは、今後の校正を必要とする - 新しいNATタイプが展開され得るときのプロトコルを破ります。展開のNATのほとんどはSTUNが想定しているタイプがあるので、幸いなことに、これは、現在の時点での問題ではありません。発見した一次利用STUNはRTP [12]トラフィックを受信するためのアドレスの割り当てを容易にするために、VoIPの領域です。そのアプリケーションでは、定期的なキープアライブはRTPトラフィック自体によって提供されています。しかし、いくつかの実際的な問題は、RTPのために発生します。まず、RTPはRTCPトラフィックはRTPトラフィックよりも高いポート1であることを前提としています。このペアリングプロパティは直接制御できませんNATを経由保証することはできません。その結果、RTCPトラフィックが正常に受信できない場合があります。 SDPのプロトコル拡張は、クライアントは、RTCP [18]のために別のポートをシグナリングすることを可能にすることによってこれを緩和が提案されています。しかし、いくつかの時間のための相互運用性の問題があるでしょう。"
    },
    {
      "indent": 3,
      "text": "For VoIP, silence suppression can cause a gap in the transmission of RTP packets. This could result in the loss of a binding in the middle of a call, if that silence period exceeds the binding timeout. This can be mitigated by sending occasional silence packets to keep the binding alive. However, the result is additional brittleness; proper operation depends on the silence suppression algorithm in use, the usage of a comfort noise codec, the duration of the silence period, and the binding lifetime in the NAT.",
      "ja": "VoIPのために、無音圧縮はRTPパケットの送信のギャップを引き起こす可能性があります。その沈黙期間が結合タイムアウトを超えた場合、これは、コールの途中で結合の損失につながる可能性があります。これは、結合生きを保つために時折無音パケットを送信することにより緩和することができます。しかし、結果は、追加の脆性です。適切な動作は、使用中の無音抑制アルゴリズム、快適雑音コーデック、沈黙期間の継続時間、およびNATに結合ライフタイムの使用に依存します。"
    },
    {
      "indent": 0,
      "text": "14.6 In Closing",
      "section_title": true,
      "ja": "最後に14.6"
    },
    {
      "indent": 3,
      "text": "The problems with STUN are not design flaws in STUN. The problems in STUN have to do with the lack of standardized behaviors and controls in NATs. The result of this lack of standardization has been a proliferation of devices whose behavior is highly unpredictable, extremely variable, and uncontrollable. STUN does the best it can in such a hostile environment. Ultimately, the solution is to make the environment less hostile, and to introduce controls and standardized behaviors into NAT. However, until such time as that happens, STUN provides a good short term solution given the terrible conditions under which it is forced to operate.",
      "ja": "STUNの問題点は、STUNの欠陥を設計されていません。 STUNの問題点は、NATの中に標準化された行動とコントロールの欠如としなければなりません。標準化の欠如の結果は、行動、非常に予測不可能な非常に変数、および制御不能であるデバイスの急増となっています。 STUNは、このような過酷な環境でそれができる最善を尽くします。最終的に、解決策は、環境があまり敵対的にするために、およびNATにコントロールし、標準化された行動を導入することです。しかし、それが起こるような時間まで、STUNは、動作するように強制されたの下でひどい状況与えられた良い短期的ソリューションを提供します。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Cedric Aoun, Pete Cordell, Cullen Jennings, Bob Penfield and Chris Sullivan for their comments, and Baruch Sterman and Alan Hawrylyshen for initial implementations. Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning Schulzrinne for IESG and IAB input on this work.",
      "ja": "著者は、初期の実装のためのセドリックアウン、ピートコーデル、カレン・ジェニングス、ボブペンフィールドとクリス・サリバン彼らのコメントのために、とバルークStermanとアランHawrylyshenに感謝したいと思います。レスリーDaigle氏、アリソンマンキン、エリックレスコラ、およびIESGのためのヘニングSchulzrinneとし、この作品のIAB入力いただきありがとうございます。"
    },
    {
      "indent": 0,
      "text": "16. Normative References",
      "section_title": true,
      "ja": "16.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to indicate requirement levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーの、S.、 \"要件レベルを示すRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月を。"
    },
    {
      "indent": 3,
      "text": "[2] Dierks, T. and C. Allen, \"The TLS protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[2]ダークス、T.及びC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Gulbrandsen, A., Vixie, P. and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[3] Gulbrandsenの、A.、いるVixie、P.及びL. Esibov、 \"（DNSのSRV）サービスの位置を特定するためのDNS RR\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[4] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "[4]、RFC 3268、2002年6月のchown、P.、 \"トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせを\"。"
    },
    {
      "indent": 3,
      "text": "[5] Rescorla, E., \"HTTP over TLS\", RFC 2818, May 2000.",
      "ja": "[5]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月を。"
    },
    {
      "indent": 3,
      "text": "[6] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[6]ポステル、J.、 \"インターネットプロトコル\"、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[7] Ferguson, P. and D. Senie, \"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing\", BCP 38, RFC 2827, May 2000.",
      "ja": "[7]ファーガソン、P.およびD. Senie、 \"ネットワーク入力フィルタリング：IP Source Address Spoofingを使うサービス拒否攻撃を破り\"、BCP 38、RFC 2827、2000年5月。"
    },
    {
      "indent": 0,
      "text": "17. Informative References",
      "section_title": true,
      "ja": "17.参考文献"
    },
    {
      "indent": 3,
      "text": "[8] Senie, D., \"Network Address Translator (NAT)-Friendly Application Design Guidelines\", RFC 3235, January 2002.",
      "ja": "[8] Senie、D.、 \"ネットワークアドレス変換（NAT）フレンドリアプリケーションの設計ガイドライン\"、RFC 3235、2002年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A. and A. Rayhan, \"Middlebox Communication Architecture and Framework\", RFC 3303, August 2002.",
      "ja": "[9] Srisuresh、P.、Kuthan、J.、ローゼンバーグ、J.、モリター、A.とA. Rayhan、 \"ミドル通信アーキテクチャとフレームワーク\"、RFC 3303、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[10] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M. and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[10]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\"、 RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[11] Holdrege, M. and P. Srisuresh, \"Protocol Complications with the IP Network Address Translator\", RFC 3027, January 2001.",
      "ja": "[11]ホールドレッジ、M.とP. Srisuresh、 \"IPネットワークアドレス変換とプロトコルの合併症\"、RFC 3027、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[12] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", RFC 1889, January 1996.",
      "ja": "[12] Schulzrinneと、H.、Casner、S.、フレデリック、R.とV. Jacobson氏、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、RFC 1889、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[13] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[13] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[14] Kohl, J. and C. Neuman, \"The kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[14]コールズ、J.及びC.ノイマン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[15] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[15]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\"、 RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[16] Baugher M., et al., \"The secure real-time transport protocol\", Work in Progress.",
      "ja": "[16] Baugher M.、ら、 \"セキュアリアルタイムトランスポートプロトコル\"、ProgressのWork。"
    },
    {
      "indent": 3,
      "text": "[17] Daigle, L., Editor, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, November 2002.",
      "ja": "[17] Daigle氏、L.、エディタ、 \"一方的な自己アドレス固定するためのIABの考慮事項（UNSAF）ネットワークアドレス変換アクロス\"、RFC 3424、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[18] Huitema, C., \"RTCP attribute in SDP\", Work in Progress.",
      "ja": "[18]のHuitema、C.、 \"SDPにおけるRTCP属性\"、ProgressのWork。"
    },
    {
      "indent": 0,
      "text": "18. Authors' Addresses",
      "section_title": true,
      "ja": "18.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936",
      "ja": "72イーグルロックアベニューまず階イーストハノーバー、NJ 07936 dynamicsoftジョナサン・ローゼンバーグ"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@dynamicsoft.com",
      "ja": "メールアドレス：jdrosen@dynamicsoft.com"
    },
    {
      "indent": 3,
      "text": "Joel Weinberger dynamicsoft 72 Eagle Rock Avenue First Floor East Hanover, NJ 07936",
      "ja": "72イーグルロックアベニューまず階イーストハノーバー、NJ 07936 dynamicsoftジョエル・ワインバーガー"
    },
    {
      "indent": 3,
      "text": "EMail: jweinberger@dynamicsoft.com",
      "ja": "メールアドレス：jweinberger@dynamicsoft.com"
    },
    {
      "indent": 3,
      "text": "Christian Huitema Microsoft Corporation One Microsoft Way Redmond, WA 98052-6399",
      "ja": "クリスチャンのHuitemaマイクロソフト社1つのマイクロソフト道、レドモンド、WA 98052-6399"
    },
    {
      "indent": 3,
      "text": "EMail: huitema@microsoft.com",
      "ja": "メールアドレス：huitema@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Rohan Mahy Cisco Systems 101 Cooper St Santa Cruz, CA 95060",
      "ja": "ロハンマーイシスコシステムズ101クーパーセントサンタクルス、CA 95060"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@cisco.com",
      "ja": "メールアドレス：rohan@cisco.com"
    },
    {
      "indent": 0,
      "text": "19. Full Copyright Statement",
      "section_title": true,
      "ja": "19.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}