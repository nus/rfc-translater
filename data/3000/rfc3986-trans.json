{
  "title": {
    "text": "RFC 3986 - Uniform Resource Identifier (URI): Generic Syntax",
    "ja": "RFC 3986 - 統一資源識別子（URI）：一般的な構文"
  },
  "number": 3986,
  "created_at": "2019-10-26 08:20:42.557293+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                     T. Berners-Lee\nRequest for Comments: 3986                                       W3C/MIT\nSTD: 66                                                      R. Fielding\nUpdates: 1738                                               Day Software\nObsoletes: 2732, 2396, 1808                                  L. Masinter\nCategory: Standards Track                                  Adobe Systems\n                                                            January 2005",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Uniform Resource Identifier (URI): Generic Syntax",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.",
      "ja": "URI（Uniform Resource Identifier）は、抽象的又は物理的リソースを識別する文字のコンパクトな配列です。この仕様は、一般的なURI構文とインターネット上のURIを使用するためのガイドラインとセキュリティの考慮事項とともに、相対的な形であるかもしれないURI参照を解決するためのプロセスを定義します。 URIの構文は、実装がすべての可能な識別子のスキーム固有の要件を知ることなくURI参照の共通の構成要素を解析することができ、すべての有効なURIのスーパーセットである文法を定義します。この仕様は、URIの生成文法を定義していません。そのタスクは、各URIスキームの個々の仕様によって行われます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n    1.1.  Overview of URIs . . . . . . . . . . . . . . . . . . . .  4\n          1.1.1.  Generic Syntax . . . . . . . . . . . . . . . . .  6\n          1.1.2.  Examples . . . . . . . . . . . . . . . . . . . .  7\n          1.1.3.  URI, URL, and URN  . . . . . . . . . . . . . . .  7\n    1.2.  Design Considerations  . . . . . . . . . . . . . . . . .  8\n          1.2.1.  Transcription  . . . . . . . . . . . . . . . . .  8\n          1.2.2.  Separating Identification from Interaction . . .  9\n          1.2.3.  Hierarchical Identifiers . . . . . . . . . . . . 10\n    1.3.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . 11\n2.  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n    2.1.  Percent-Encoding . . . . . . . . . . . . . . . . . . . . 12\n    2.2.  Reserved Characters  . . . . . . . . . . . . . . . . . . 12\n    2.3.  Unreserved Characters  . . . . . . . . . . . . . . . . . 13\n    2.4.  When to Encode or Decode . . . . . . . . . . . . . . . . 14\n    2.5.  Identifying Data . . . . . . . . . . . . . . . . . . . . 14\n3.  Syntax Components  . . . . . . . . . . . . . . . . . . . . . . 16\n    3.1.  Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 17\n    3.2.  Authority  . . . . . . . . . . . . . . . . . . . . . . . 17\n          3.2.1.  User Information . . . . . . . . . . . . . . . . 18\n          3.2.2.  Host . . . . . . . . . . . . . . . . . . . . . . 18\n          3.2.3.  Port . . . . . . . . . . . . . . . . . . . . . . 22\n    3.3.  Path . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n    3.4.  Query  . . . . . . . . . . . . . . . . . . . . . . . . . 23\n    3.5.  Fragment . . . . . . . . . . . . . . . . . . . . . . . . 24\n4.  Usage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n    4.1.  URI Reference  . . . . . . . . . . . . . . . . . . . . . 25\n    4.2.  Relative Reference . . . . . . . . . . . . . . . . . . . 26\n    4.3.  Absolute URI . . . . . . . . . . . . . . . . . . . . . . 27\n    4.4.  Same-Document Reference  . . . . . . . . . . . . . . . . 27\n    4.5.  Suffix Reference . . . . . . . . . . . . . . . . . . . . 27\n5.  Reference Resolution . . . . . . . . . . . . . . . . . . . . . 28\n    5.1.  Establishing a Base URI  . . . . . . . . . . . . . . . . 28\n          5.1.1.  Base URI Embedded in Content . . . . . . . . . . 29\n          5.1.2.  Base URI from the Encapsulating Entity . . . . . 29\n          5.1.3.  Base URI from the Retrieval URI  . . . . . . . . 30\n          5.1.4.  Default Base URI . . . . . . . . . . . . . . . . 30\n    5.2.  Relative Resolution  . . . . . . . . . . . . . . . . . . 30\n          5.2.1.  Pre-parse the Base URI . . . . . . . . . . . . . 31\n          5.2.2.  Transform References . . . . . . . . . . . . . . 31\n          5.2.3.  Merge Paths  . . . . . . . . . . . . . . . . . . 32\n          5.2.4.  Remove Dot Segments  . . . . . . . . . . . . . . 33\n    5.3.  Component Recomposition  . . . . . . . . . . . . . . . . 35\n    5.4.  Reference Resolution Examples  . . . . . . . . . . . . . 35\n          5.4.1.  Normal Examples  . . . . . . . . . . . . . . . . 36\n          5.4.2.  Abnormal Examples  . . . . . . . . . . . . . . . 36",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.  Normalization and Comparison . . . . . . . . . . . . . . . . . 38\n    6.1.  Equivalence  . . . . . . . . . . . . . . . . . . . . . . 38\n    6.2.  Comparison Ladder  . . . . . . . . . . . . . . . . . . . 39\n          6.2.1.  Simple String Comparison . . . . . . . . . . . . 39\n          6.2.2.  Syntax-Based Normalization . . . . . . . . . . . 40\n          6.2.3.  Scheme-Based Normalization . . . . . . . . . . . 41\n          6.2.4.  Protocol-Based Normalization . . . . . . . . . . 42\n7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 43\n    7.1.  Reliability and Consistency  . . . . . . . . . . . . . . 43\n    7.2.  Malicious Construction . . . . . . . . . . . . . . . . . 43\n    7.3.  Back-End Transcoding . . . . . . . . . . . . . . . . . . 44\n    7.4.  Rare IP Address Formats  . . . . . . . . . . . . . . . . 45\n    7.5.  Sensitive Information  . . . . . . . . . . . . . . . . . 45\n    7.6.  Semantic Attacks . . . . . . . . . . . . . . . . . . . . 45\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 46\n9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 46\n10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n    10.1. Normative References . . . . . . . . . . . . . . . . . . 46\n    10.2. Informative References . . . . . . . . . . . . . . . . . 47\nA.  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . 49\nB.  Parsing a URI Reference with a Regular Expression  . . . . . . 50\nC.  Delimiting a URI in Context  . . . . . . . . . . . . . . . . . 51\nD.  Changes from RFC 2396  . . . . . . . . . . . . . . . . . . . . 53\n    D.1.  Additions  . . . . . . . . . . . . . . . . . . . . . . . 53\n    D.2.  Modifications  . . . . . . . . . . . . . . . . . . . . . 53\nIndex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A Uniform Resource Identifier (URI) provides a simple and extensible means for identifying a resource. This specification of URI syntax and semantics is derived from concepts introduced by the World Wide Web global information initiative, whose use of these identifiers dates from 1990 and is described in \"Universal Resource Identifiers in WWW\" [RFC1630]. The syntax is designed to meet the recommendations laid out in \"Functional Recommendations for Internet Resource Locators\" [RFC1736] and \"Functional Requirements for Uniform Resource Names\" [RFC1737].",
      "ja": "URI（Uniform Resource Identifier）は、リソースを識別するための単純で拡張可能な手段を提供します。 URIの構文と意味のこの仕様は、その使用がこれらの識別子日の1990年からと「WWWにおけるユニバーサルリソース識別子」[RFC1630]に記述されているワールド・ワイド・ウェブグローバル情報イニシアティブによって導入概念から導き出されます。構文は、「インターネットリソースロケータのための機能の提言」[RFC1736]および「ユニフォームリソース名の機能要件」[RFC1737]でレイアウトされた勧告を満たすように設計されています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC2396], which merged \"Uniform Resource Locators\" [RFC1738] and \"Relative Uniform Resource Locators\" [RFC1808] in order to define a single, generic syntax for all URIs. It obsoletes [RFC2732], which introduced syntax for an IPv6 address. It excludes portions of RFC 1738 that defined the specific syntax of individual URI schemes; those portions will be updated as separate documents. The process for registration of new URI schemes is defined separately by [BCP35]. Advice for designers of new URI schemes can be found in [RFC2718]. All significant changes from RFC 2396 are noted in Appendix D.",
      "ja": "この文書では、すべてのURIのための単一の、一般的な構文を定義するために「ユニフォームリソースロケータ」を合併し、[RFC2396]、[RFC1738]と「相対ユニフォーム・リソース・ロケータ」[RFC1808]を廃止します。これは、IPv6アドレスの構文を導入しました[RFC2732]を、廃止します。これは、個々のURIスキームの特定のシンタックスを定義RFC 1738の部分を除外する。これらの部分は、別の文書として更新されます。新しいURIスキームの登録のための方法は、[BCP35]で別々に定義されます。新しいURIスキームの設計者のためのアドバイスは、[RFC2718]で見つけることができます。 RFC 2396からのすべての重要な変更は、付録Dに記載されています"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"character\" and \"coded character set\" in accordance with the definitions provided in [BCP19], and \"character encoding\" in place of what [BCP19] refers to as a \"charset\".",
      "ja": "この仕様は、[BCP19]「文字セット」ともいうものの代わりに、[BCP19]、および「文字エンコーディング」で提供される定義に従って用語「文字」および「コード化文字セット」を使用します。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview of URIs",
      "section_title": true,
      "ja": "1.1.  URIの概要"
    },
    {
      "indent": 3,
      "text": "URIs are characterized as follows:",
      "ja": "次のようにURIは特徴付けされています。"
    },
    {
      "indent": 3,
      "text": "Uniform",
      "ja": "制服"
    },
    {
      "indent": 6,
      "text": "Uniformity provides several benefits. It allows different types of resource identifiers to be used in the same context, even when the mechanisms used to access those resources may differ. It allows uniform semantic interpretation of common syntactic conventions across different types of resource identifiers. It allows introduction of new types of resource identifiers without interfering with the way that existing identifiers are used. It allows the identifiers to be reused in many different contexts, thus permitting new applications or protocols to leverage a pre-existing, large, and widely used set of resource identifiers.",
      "ja": "均一性は、いくつかの利点を提供します。これは、これらのリソースにアクセスするために使用されるメカニズムが異なる場合があっても、リソース識別子の異なるタイプが同じ文脈で使用されることを可能にします。これは、リソース識別子の異なるタイプに共通の構文規則の均一な意味解釈することができます。これは、既存の識別子が使用されている方法と干渉することなく、リソース識別子の新しいタイプの導入を可能にします。したがって、リソース識別子の既存の、大規模な、そして広く使われているセットを活用するために、新しいアプリケーションやプロトコルを許可する、識別子は、多くの異なる文脈で再利用することができます。"
    },
    {
      "indent": 3,
      "text": "Resource",
      "ja": "資源"
    },
    {
      "indent": 6,
      "text": "This specification does not limit the scope of what might be a resource; rather, the term \"resource\" is used in a general sense for whatever might be identified by a URI. Familiar examples include an electronic document, an image, a source of information with a consistent purpose (e.g., \"today's weather report for Los Angeles\"), a service (e.g., an HTTP-to-SMS gateway), and a collection of other resources. A resource is not necessarily accessible via the Internet; e.g., human beings, corporations, and bound books in a library can also be resources. Likewise, abstract concepts can be resources, such as the operators and operands of a mathematical equation, the types of a relationship (e.g., \"parent\" or \"employee\"), or numeric values (e.g., zero, one, and infinity).",
      "ja": "この仕様は、リソースであるかもしれないものの範囲を制限するものではありません。むしろ、用語「資源」は、URIで識別されるかもしれないものは何でものための一般的な意味で使用されています。身近な例では、電子文書、画像、一貫した目的との情報源（例えば、「ロサンゼルスのために今日の天気予報」）、サービス（例えば、HTTPツーSMSゲートウェイ）、およびその他のコレクションが含まれます資源。リソースは、インターネットを経由して、必ずしもアクセスすることはできません。例えば、ライブラリ内の人間、企業、および結合した本ものリソースすることができます。同様に、抽象的な概念は、このような数式の演算子およびオペランドとしてリソース、関係（例えば、「親」または「従業員」）のタイプ、または数値（例えば、0個、1個、および無限大）とすることができます。"
    },
    {
      "indent": 3,
      "text": "Identifier",
      "ja": "識別"
    },
    {
      "indent": 6,
      "text": "An identifier embodies the information required to distinguish what is being identified from all other things within its scope of identification. Our use of the terms \"identify\" and \"identifying\" refer to this purpose of distinguishing one resource from all other resources, regardless of how that purpose is accomplished (e.g., by name, address, or context). These terms should not be mistaken as an assumption that an identifier defines or embodies the identity of what is referenced, though that may be the case for some identifiers. Nor should it be assumed that a system using URIs will access the resource identified: in many cases, URIs are used to denote resources without any intention that they be accessed. Likewise, the \"one\" resource identified might not be singular in nature (e.g., a resource might be a named set or a mapping that varies over time).",
      "ja": "識別子は、識別のその範囲内のすべての他のものから識別されているものを区別するために必要な情報を具体化します。用語の私達の使用「特定」と「識別」にかかわらず、その目的が達成される方法の、他のすべてのリソースからの1つのリソースを区別する、この目的を指す（例えば、名前、住所、または文脈によって）。それはいくつかの識別子の場合であってもよいけれども、これらの用語は、識別子が定義または参照されるもののアイデンティティを具現前提として誤解されるべきではありません。また、URIを使用して、システムが特定のリソースにアクセスすることを想定する必要があります。多くの場合、URIはそれらがアクセスすることを任意の意図せずにリソースを示すために使用されています。同様に、特定され、「1」のリソース（例えば、リソースが名前付きセットや経時的に変化するマッピングであるかもしれない）自然の中で特異ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "A URI is an identifier consisting of a sequence of characters matching the syntax rule named <URI> in Section 3. It enables uniform identification of resources via a separately defined extensible set of naming schemes (Section 3.1). How that identification is accomplished, assigned, or enabled is delegated to each scheme specification.",
      "ja": "URIは、命名方式の別途定義拡張可能なセット（セクション3.1）を介してリソースの均一な識別を可能にする第3の<URI>という名前の構文規則に合致する文字の配列からなる識別子です。その識別が達成される方法を、割り当てられた、又は各スキームの仕様に委任されている可能にしました。"
    },
    {
      "indent": 3,
      "text": "This specification does not place any limits on the nature of a resource, the reasons why an application might seek to refer to a resource, or the kinds of systems that might use URIs for the sake of identifying resources. This specification does not require that a URI persists in identifying the same resource over time, though that is a common goal of all URI schemes. Nevertheless, nothing in this specification prevents an application from limiting itself to particular types of resources, or to a subset of URIs that maintains characteristics desired by that application.",
      "ja": "この仕様では、リソースの性質上の任意の制限、アプリケーションがリソースを参照することを求める可能性がある理由、またはリソースを識別するためのURIを使用する場合がありますシステムの種類を置いていません。この仕様は、それがすべてのURIスキームの共通の目標ですが、URIは、時間をかけて同じリソースを特定するに固執する必要はありません。それにもかかわらず、本明細書では何もリソースの特定のタイプ、またはそのアプリケーションによって所望の特性を維持するURIの部分集合に自分自身を制限するからアプリケーションを妨げるものはありません。"
    },
    {
      "indent": 3,
      "text": "URIs have a global scope and are interpreted consistently regardless of context, though the result of that interpretation may be in relation to the end-user's context. For example, \"http://localhost/\" has the same interpretation for every user of that reference, even though the network interface corresponding to \"localhost\" may be different for each end-user: interpretation is independent of access. However, an action made on the basis of that reference will take place in relation to the end-user's context, which implies that an action intended to refer to a globally unique thing must use a URI that distinguishes that resource from all other things. URIs that identify in relation to the end-user's local context should only be used when the context itself is a defining aspect of the resource, such as when an on-line help manual refers to a file on the end-user's file system (e.g., \"file:///etc/hosts\").",
      "ja": "URIはグローバルスコープを持ち、その解釈の結果は、エンドユーザのコンテキストに関連してもよいが、一貫して関係なく、コンテキストの解釈されます。例えば、「HTTP：//は、ローカルホスト/」は、ネットワークインタフェースが「ローカルホスト」に対応していても、その基準のすべてのユーザに対して同じ解釈を有し、各エンドユーザーのために異なっていてもよい：解釈は、アクセスとは無関係です。しかし、その参照に基づいて作られたアクションは、グローバルに一意なものを指すことを意図して、アクションが他のすべてのものからそのリソースを区別URIを使用しなければならないことを意味する、エンドユーザのコンテキストに関連して行われます。このようなオンラインヘルプマニュアルがエンドユーザのファイルシステム上のファイルを参照する場合など、エンドユーザのローカルコンテキストに関連して特定のURIコンテキスト自体がリソースの定義態様である場合にのみ使用すべきである（例えば、 \"ファイル：/// etc / hostsファイル\"）。"
    },
    {
      "indent": 0,
      "text": "1.1.1. Generic Syntax",
      "section_title": true,
      "ja": "1.1.1. 一般的な構文"
    },
    {
      "indent": 3,
      "text": "Each URI begins with a scheme name, as defined in Section 3.1, that refers to a specification for assigning identifiers within that scheme. As such, the URI syntax is a federated and extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme.",
      "ja": "各URIは、そのスキーム内識別子を割り当てるための仕様を指す3.1項で定義されるように、スキーム名で始まります。このように、URIの構文は各スキームの仕様は、さらにその方式を使用して識別子の構文と意味論を制限することができる、請求連合と拡張ネーミングシステムです。"
    },
    {
      "indent": 3,
      "text": "This specification defines those elements of the URI syntax that are required of all URI schemes or are common to many URI schemes. It thus defines the syntax and semantics needed to implement a scheme-independent parsing mechanism for URI references, by which the scheme-dependent handling of a URI can be postponed until the scheme-dependent semantics are needed. Likewise, protocols and data formats that make use of URI references can refer to this specification as a definition for the range of syntax allowed for all URIs, including those schemes that have yet to be defined. This decouples the evolution of identification schemes from the evolution of protocols, data formats, and implementations that make use of URIs.",
      "ja": "この仕様は、すべてのURIスキームの必要や多くのURIスキームに共通しているされているURI構文のこれらの要素を定義します。したがって、スキーム依存のセマンティクスが必要になるまでURIのスキームに依存する処理を延期することが可能なURI参照のためのスキームに依存しない解析メカニズムを実装するために必要な構文とセマンティクスを定義します。同様に、URI参照を利用するプロトコルやデータ形式が定義されては至っていないものをスキームを含むすべてのURIのために許容される構文の範囲の定義としてこの仕様を参照することができます。これは、URIの利用するプロトコル、データ形式、およびインプリメンテーションの進化から識別手法の進化を切り離します。"
    },
    {
      "indent": 3,
      "text": "A parser of the generic URI syntax can parse any URI reference into its major components. Once the scheme is determined, further scheme-specific parsing can be performed on the components. In other words, the URI generic syntax is a superset of the syntax of all URI schemes.",
      "ja": "一般的なURI構文のパーサは、その主要な構成要素に任意のURI参照を解析することができます。スキームが決定されると、さらにスキーム固有の構文解析は、コンポーネント上で実行することができます。言い換えれば、URIの一般的な構文は、すべてのURIスキームの構文のスーパーセットです。"
    },
    {
      "indent": 0,
      "text": "1.1.2. Examples",
      "section_title": true,
      "ja": "1.1.2. 例"
    },
    {
      "indent": 3,
      "text": "The following example URIs illustrate several URI schemes and variations in their common syntax components:",
      "ja": "次の例では、URIは、それらの共通の構文要素でいくつかのURIスキームおよび変形形態を示します。"
    },
    {
      "indent": 6,
      "text": "ftp://ftp.is.co.za/rfc/rfc1808.txt",
      "ja": "ｆｔｐ：／／ｆｔｐ。いｓ。こ。ざ／ｒｆｃ／ｒｆｃ１８０８。ｔｘｔ"
    },
    {
      "indent": 6,
      "text": "http://www.ietf.org/rfc/rfc2396.txt",
      "ja": "ｈっｔｐ：／／ｗっｗ。いえｔｆ。おｒｇ／ｒｆｃ／ｒｆｃ２３９６。ｔｘｔ"
    },
    {
      "indent": 6,
      "text": "ldap://[2001:db8::7]/c=GB?objectClass?one",
      "ja": "LDAP：// [2001：DB8 :: 7]？？/ C = GBオブジェクトクラス1"
    },
    {
      "indent": 6,
      "text": "mailto:John.Doe@example.com",
      "ja": "mailto：John.Doe@example.com"
    },
    {
      "indent": 6,
      "text": "news:comp.infosystems.www.servers.unix",
      "ja": "ニュース：comp.infosystems.www.servers.unix"
    },
    {
      "indent": 6,
      "text": "tel:+1-816-555-1212",
      "ja": "TEL：+ 1-816-555-1212"
    },
    {
      "indent": 6,
      "text": "telnet://192.0.2.16:80/",
      "ja": "telnetの：//192.0.2.16：80 /"
    },
    {
      "indent": 6,
      "text": "urn:oasis:names:specification:docbook:dtd:xml:4.1.2",
      "ja": "URN：オアシス：名前：仕様：DocBook形式：DTD：XML：4.1.2"
    },
    {
      "indent": 0,
      "text": "1.1.3. URI, URL, and URN",
      "section_title": true,
      "ja": "1.1.3.  URI、URL、およびURN"
    },
    {
      "indent": 3,
      "text": "A URI can be further classified as a locator, a name, or both. The term \"Uniform Resource Locator\" (URL) refers to the subset of URIs that, in addition to identifying a resource, provide a means of locating the resource by describing its primary access mechanism (e.g., its network \"location\"). The term \"Uniform Resource Name\" (URN) has been used historically to refer to both URIs under the \"urn\" scheme [RFC2141], which are required to remain globally unique and persistent even when the resource ceases to exist or becomes unavailable, and to any other URI with the properties of a name.",
      "ja": "URIはさらに、ロケータ、名前、またはその両方として分類することができます。用語「ユニフォームリソースロケータ」（URL）は、リソースを識別することに加えて、その主要なアクセス機構（例えば、そのネットワークの「場所」）を記述することでリソースの位置を特定する手段を提供し、URIのサブセットを指します。用語「ユニフォームリソース名」（URN）は、リソースが存在しなくなるか、使用不能になった場合にもグローバルに一意の永続的なままであるために必要とされる「URN」方式[RFC2141]、下の両方のURIを参照するために歴史的に使用され、されてい名前のプロパティを持つ他のURIへ。"
    },
    {
      "indent": 3,
      "text": "An individual scheme does not have to be classified as being just one of \"name\" or \"locator\". Instances of URIs from any given scheme may have the characteristics of names or locators or both, often depending on the persistence and care in the assignment of identifiers by the naming authority, rather than on any quality of the scheme. Future specifications and related documentation should use the general term \"URI\" rather than the more restrictive terms \"URL\" and \"URN\" [RFC3305].",
      "ja": "個々のスキームは、「名前」または「ロケータ」のひとつであると分類されている必要はありません。任意のスキームからのURIのインスタンスは、多くの場合、持続性に応じて、名前やロケータまたは両方の特性を持っているとかなりの方式のいずれかの品質に比べて、命名機関によって識別子の割り当てに気があります。将来の仕様および関連文書は、一般的な用語「URI」というよりも制限用語「URL」と「URN」[RFC3305]を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.2. Design Considerations",
      "section_title": true,
      "ja": "1.2. 設計上の考慮事項"
    },
    {
      "indent": 0,
      "text": "1.2.1. Transcription",
      "section_title": true,
      "ja": "1.2.1. トランスクリプション"
    },
    {
      "indent": 3,
      "text": "The URI syntax has been designed with global transcription as one of its main considerations. A URI is a sequence of characters from a very limited set: the letters of the basic Latin alphabet, digits, and a few special characters. A URI may be represented in a variety of ways; e.g., ink on paper, pixels on a screen, or a sequence of character encoding octets. The interpretation of a URI depends only on the characters used and not on how those characters are represented in a network protocol.",
      "ja": "URIの構文は、その主な検討事項の一つとして、世界的な転写に設計されています。基本的なラテンアルファベットの文字、数字、およびいくつかの特殊文字：URIは非常に限られたセットからの文字のシーケンスです。 URIは、様々な方法で表すことができます。例えば、紙の上のインク、スクリーン、または文字符号化オクテットの配列上の画素。 URIの解釈だけではなく、それらの文字がネットワークプロトコルで表現されている方法で使用される文字に依存します。"
    },
    {
      "indent": 3,
      "text": "The goal of transcription can be described by a simple scenario. Imagine two colleagues, Sam and Kim, sitting in a pub at an international conference and exchanging research ideas. Sam asks Kim for a location to get more information, so Kim writes the URI for the research site on a napkin. Upon returning home, Sam takes out the napkin and types the URI into a computer, which then retrieves the information to which Kim referred.",
      "ja": "転写の目標は、単純なシナリオで記述することができます。 2人の同僚、サム・キム、国際会議でパブに座って、研究のアイデアの交換を想像してみてください。サムはより多くの情報を取得するための場所のキムを要求するので、キムはナプキンの研究サイトのURIを書き込みます。帰宅すると、サムはその後、キムが呼ばれた情報を取得し、コンピュータの中にナプキンや種類URIを取り出します。"
    },
    {
      "indent": 3,
      "text": "There are several design considerations revealed by the scenario:",
      "ja": "シナリオによって明らかにされたいくつかの設計上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "o A URI is a sequence of characters that is not always represented as a sequence of octets.",
      "ja": "O URIは常にオクテットのシーケンスとして表現されていない文字列が表示されます。"
    },
    {
      "indent": 3,
      "text": "o A URI might be transcribed from a non-network source and thus should consist of characters that are most likely able to be entered into a computer, within the constraints imposed by keyboards (and related input devices) across languages and locales.",
      "ja": "URIは、非ネットワークソースから転写されるかもしれないので、言語およびロケールを横切って最も可能性の高いキーボード（及び関連する入力装置）によって課される制約内で、コンピュータに入力することができるされている文字で構成する必要があり、O。"
    },
    {
      "indent": 3,
      "text": "o A URI often has to be remembered by people, and it is easier for people to remember a URI when it consists of meaningful or familiar components.",
      "ja": "O URIは、多くの場合、人によって覚えなければならず、意味のあるまたはおなじみのコンポーネントで構成されたとき、人々はURIを覚えておくために簡単です。"
    },
    {
      "indent": 3,
      "text": "These design considerations are not always in alignment. For example, it is often the case that the most meaningful name for a URI component would require characters that cannot be typed into some systems. The ability to transcribe a resource identifier from one medium to another has been considered more important than having a URI consist of the most meaningful of components.",
      "ja": "これらの設計上の考慮事項は、一直線上に常にではありません。例えば、それは多くの場合、URIコンポーネントの最も意味のある名前にはいくつかのシステムに入力できない文字を必要とする場合です。別の媒体からリソース識別子を転写する能力は、URIコンポーネントの最も有意義で構成有するよりも重要と考えられてきました。"
    },
    {
      "indent": 3,
      "text": "In local or regional contexts and with improving technology, users might benefit from being able to use a wider range of characters; such use is not defined by this specification. Percent-encoded octets (Section 2.1) may be used within a URI to represent characters outside the range of the US-ASCII coded character set if this representation is allowed by the scheme or by the protocol element in which the URI is referenced. Such a definition should specify the character encoding used to map those characters to octets prior to being percent-encoded for the URI.",
      "ja": "地元や地域の状況では、技術を向上させることで、ユーザーが文字の広い範囲を使用することができることから恩恵を受けるかもしれません。そのような使用は、本明細書で定義されていません。パーセントエンコードオクテット（セクション2.1）は、この表現がスキームによって、またはURIが参照されているプロトコル要素によって許可されている場合に設定US-ASCII符号化文字の範囲外の文字を表すためにURI内で使用することができます。このような定義は前URIのためのパーセントエンコードされることにオクテットにこれらの文字をマッピングするために使用される文字コードを指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Separating Identification from Interaction",
      "section_title": true,
      "ja": "1.2.2. 相互作用から識別を分離します"
    },
    {
      "indent": 3,
      "text": "A common misunderstanding of URIs is that they are only used to refer to accessible resources. The URI itself only provides identification; access to the resource is neither guaranteed nor implied by the presence of a URI. Instead, any operation associated with a URI reference is defined by the protocol element, data format attribute, or natural language text in which it appears.",
      "ja": "URIの一般的な誤解は、彼らが唯一のアクセス可能なリソースを参照するために使用されていることです。 URI自体のみ識別を提供します。リソースへのアクセスが保証されていないにもURIの存在によって暗示もされていません。代わりに、URI参照に関連付けられたすべての操作は、プロトコル要素、データフォーマット属性、またはそれが表示される自然言語テキストによって定義されます。"
    },
    {
      "indent": 3,
      "text": "Given a URI, a system may attempt to perform a variety of operations on the resource, as might be characterized by words such as \"access\", \"update\", \"replace\", or \"find attributes\". Such operations are defined by the protocols that make use of URIs, not by this specification. However, we do use a few general terms for describing common operations on URIs. URI \"resolution\" is the process of determining an access mechanism and the appropriate parameters necessary to dereference a URI; this resolution may require several iterations. To use that access mechanism to perform an action on the URI's resource is to \"dereference\" the URI.",
      "ja": "URIを考えると、このような「アクセス」、「更新」などの単語によって特徴付けられるような、システムは、リソース上でさまざまな操作を実行しようとする場合があり、「置換」、または「属性を見つけます」。このような操作は、URIのではなく、この仕様で利用するプロトコルによって定義されています。しかし、我々はURIに基づいて一般的な操作を説明するために、いくつかの一般的な用語を使用して行います。 URI「解像度」とは、URI間接参照に必要なアクセス機構と適切なパラメータを決定するプロセスです。この決議は、数回の反復が必要な場合があります。 URIのリソースに対してアクションを実行するためにそのアクセスメカニズムを使用するには、「間接参照」URIです。"
    },
    {
      "indent": 3,
      "text": "When URIs are used within information retrieval systems to identify sources of information, the most common form of URI dereference is \"retrieval\": making use of a URI in order to retrieve a representation of its associated resource. A \"representation\" is a sequence of octets, along with representation metadata describing those octets, that constitutes a record of the state of the resource at the time when the representation is generated. Retrieval is achieved by a process that might include using the URI as a cache key to check for a locally cached representation, resolution of the URI to determine an appropriate access mechanism (if any), and dereference of the URI for the sake of applying a retrieval operation. Depending on the protocols used to perform the retrieval, additional information might be supplied about the resource (resource metadata) and its relation to other resources.",
      "ja": "URIは情報源を識別するための情報検索システム内で使用される場合、URIの間接参照の最も一般的な形態は、「検索」である：それに関連するリソースの表現を取得するために、URIを利用します。 「表現」は、表現が生成された時点で、リソースの状態のレコードを構成しているそれらのオクテットを記述する表現メタデータと共に、オクテットのシーケンスです。検索がローカルにキャッシュされた表現をチェックするためにキャッシュキーとしてURIを使用することを含むかもしれない方法によって達成される、URIの解像度は、適用のためにURIの適切なアクセス機構（もしあれば）、及び間接参照を決定します検索操作。検索を実行するために使用されるプロトコルに応じて、追加情報は、資源（リソースメタデータ）およびその他のリソースとの関係について、供給される可能性があります。"
    },
    {
      "indent": 3,
      "text": "URI references in information retrieval systems are designed to be late-binding: the result of an access is generally determined when it is accessed and may vary over time or due to other aspects of the interaction. These references are created in order to be used in the future: what is being identified is not some specific result that was obtained in the past, but rather some characteristic that is expected to be true for future results. In such cases, the resource referred to by the URI is actually a sameness of characteristics as observed over time, perhaps elucidated by additional comments or assertions made by the resource provider.",
      "ja": "情報検索システムにおけるURI参照は遅延バインディングであるように設計されている：それはアクセスされ、経時変化または相互作用の他の態様によるできるときに、アクセスの結果は、一般的に決定されます。これらの参照は、将来的に使用するために作成されます。どのような識別されていることは、過去に得られたいくつかの具体的な結果ではなく、将来の結果のために真であることが期待されているいくつかの特徴ではありません。このような場合、リソースは、URIによって参照される、おそらくリソースプロバイダによって作ら追加コメントまたはアサーションによって明らかに、時間をかけて観察されるように実際の特性の同一性です。"
    },
    {
      "indent": 3,
      "text": "Although many URI schemes are named after protocols, this does not imply that use of these URIs will result in access to the resource via the named protocol. URIs are often used simply for the sake of identification. Even when a URI is used to retrieve a representation of a resource, that access might be through gateways, proxies, caches, and name resolution services that are independent of the protocol associated with the scheme name. The resolution of some URIs may require the use of more than one protocol (e.g., both DNS and HTTP are typically used to access an \"http\" URI's origin server when a representation isn't found in a local cache).",
      "ja": "多くのURIスキームは、プロトコルにちなんで命名されているが、これは名前のプロトコルを介したリソースへのアクセスになりますこれらのURIの使用を意味するものではありません。 URIは、多くの場合、識別のために単に使用されています。 URIは、リソースの表現を取得するために使用された場合でも、そのアクセスは、ゲートウェイ、プロキシ、キャッシュ、およびスキーム名に関連するプロトコルから独立している名前解決サービスを介してであるかもしれません。いくつかのURIの解像度（例えば、両方のDNSおよびHTTPは、典型的には、表現がローカル・キャッシュ内に見つからない場合、「HTTP」URIのオリジンサーバにアクセスするために使用されている）複数のプロトコルの使用を必要とし得ます。"
    },
    {
      "indent": 0,
      "text": "1.2.3. Hierarchical Identifiers",
      "section_title": true,
      "ja": "1.2.3. 階層的な識別子"
    },
    {
      "indent": 3,
      "text": "The URI syntax is organized hierarchically, with components listed in order of decreasing significance from left to right. For some URI schemes, the visible hierarchy is limited to the scheme itself: everything after the scheme component delimiter (\":\") is considered opaque to URI processing. Other URI schemes make the hierarchy explicit and visible to generic parsing algorithms.",
      "ja": "URIの構文は左から右への重要性を減少させるためにリストされたコンポーネントで、階層的に組織化されています。いくつかのURIスキームのために、可視階層はスキーム自体に制限されている：スキーム成分デリミタ（「：」）の後にすべてがURI処理に対して不透明であると考えられます。他のURIスキームは、一般的な構文解析アルゴリズムの階層が明示して見えるようにします。"
    },
    {
      "indent": 3,
      "text": "The generic syntax uses the slash (\"/\"), question mark (\"?\"), and number sign (\"#\") characters to delimit components that are significant to the generic parser's hierarchical interpretation of an identifier. In addition to aiding the readability of such identifiers through the consistent use of familiar syntax, this uniform representation of hierarchy across naming schemes allows scheme-independent references to be made relative to that hierarchy.",
      "ja": "一般的な構文は、識別子の一般的なパーサの階層的な解釈に重要なコンポーネントを区切るためにスラッシュ（「/」）、疑問符（「？」）、およびシャープ記号（「＃」）文字を使用しています。馴染みの構文の一貫した使用によってそのような識別子の可読性を助けることに加えて、名前付けスキームを横切る階層のこの均一な表現は、スキームに依存しない参照が、その階層に対して行われることを可能にします。"
    },
    {
      "indent": 3,
      "text": "It is often the case that a group or \"tree\" of documents has been constructed to serve a common purpose, wherein the vast majority of URI references in these documents point to resources within the tree rather than outside it. Similarly, documents located at a particular site are much more likely to refer to other resources at that site than to resources at remote sites. Relative referencing of URIs allows document trees to be partially independent of their location and access scheme. For instance, it is possible for a single set of hypertext documents to be simultaneously accessible and traversable via each of the \"file\", \"http\", and \"ftp\" schemes if the documents refer to each other with relative references. Furthermore, such document trees can be moved, as a whole, without changing any of the relative references.",
      "ja": "これは、これらの文書におけるURI参照の大半は、ツリー内のではなく外部のリソースを指しており、グループやドキュメントの「木」は、共通の目的を果たすために構築されていることが多い場合です。同様に、特定のサイトにある文書がよりリモートサイトのリソースにはるかにそのサイトの他のリソースを参照してくださいする可能性があります。 URIの相対参照は、文書の木がその場所とアクセス方式の部分的に独立することができます。例えば、それはハイパーテキスト文書の単一のセットは、「ファイル」のそれぞれを経由して同時にアクセスやトラバースであるために、可能である「HTTP」、およびドキュメントが相対参照でお互いを参照する場合、「FTP」のスキーム。さらに、そのような文書ツリーは、相対参照のいずれかを変更することなく、全体として移動させることができます。"
    },
    {
      "indent": 3,
      "text": "A relative reference (Section 4.2) refers to a resource by describing the difference within a hierarchical name space between the reference context and the target URI. The reference resolution algorithm, presented in Section 5, defines how such a reference is transformed to the target URI. As relative references can only be used within the context of a hierarchical URI, designers of new URI schemes should use a syntax consistent with the generic syntax's hierarchical components unless there are compelling reasons to forbid relative referencing within that scheme.",
      "ja": "相対参照（セクション4.2）は、基準コンテキストとターゲットURIとの間の階層的な名前空間内の差を説明することにより、リソースを指します。 5章で提示基準解像度アルゴリズムは、そのような参照は、ターゲットURIに変換する方法を定義します。相対参照は、階層URIのコンテキスト内でのみ使用することができるように、そのスキーム内の相対参照を禁止する説得力のある理由がある場合を除き、新しいURIスキームの設計者は、一般的な構文の階層のコンポーネントと一致構文を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "NOTE: Previous specifications used the terms \"partial URI\" and \"relative URI\" to denote a relative reference to a URI. As some readers misunderstood those terms to mean that relative URIs are a subset of URIs rather than a method of referencing URIs, this specification simply refers to them as relative references.",
      "ja": "注：前の仕様は、URIへの相対参照を示すために、用語「部分URI」と「相対URI」を使用しました。一部の読者は、相対URIは、URIの一部ではなく、URIを参照する方法であることを意味するためにこれらの用語を誤解したように、本明細書では単に相対参照としてそれらを指します。"
    },
    {
      "indent": 3,
      "text": "All URI references are parsed by generic syntax parsers when used. However, because hierarchical processing has no effect on an absolute URI used in a reference unless it contains one or more dot-segments (complete path segments of \".\" or \"..\", as described in Section 3.3), URI scheme specifications can define opaque identifiers by disallowing use of slash characters, question mark characters, and the URIs \"scheme:.\" and \"scheme:..\".",
      "ja": "使用すると、すべてのURI参照は、一般的な構文パーサによって解析されます。しかし、ことができる、それは、1つまたは複数のドットセグメント含まれていない限り（完全パスのセグメント「」または「..」の3.3項に記載されているように、）階層処理を参照して、絶対URIに影響を使用しなかったため、URIスキームの仕様スラッシュ文字は、疑問符文字、およびURIの使用できないようにすることで、不透明な識別子を定義する「仕組みを:.」そして \"制度：..\"。"
    },
    {
      "indent": 0,
      "text": "1.3. Syntax Notation",
      "section_title": true,
      "ja": "1.3. 構文記法"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC2234], including the following core ABNF syntax rules defined by that specification: ALPHA (letters), CR (carriage return), DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal digits), LF (line feed), and SP (space). The complete URI syntax is collected in Appendix A.",
      "ja": "この仕様はその仕様によって定義された以下のコアABNF構文規則を含む[RFC2234]の増補バッカス - ナウアフォーム（ABNF）表記を使用：ALPHA（文字）、CR（キャリッジリターン）、数字（桁）、DQUOTE（ダブル引用）、HEXDIG（16進数）、LF（ラインフィード）、およびSP（空間）。完全なURI構文は、付録Aに収集されます"
    },
    {
      "indent": 0,
      "text": "2. Characters",
      "section_title": true,
      "ja": "2.キャラクター"
    },
    {
      "indent": 3,
      "text": "The URI syntax provides a method of encoding data, presumably for the sake of identifying a resource, as a sequence of characters. The URI characters are, in turn, frequently encoded as octets for transport or presentation. This specification does not mandate any particular character encoding for mapping between URI characters and the octets used to store or transmit those characters. When a URI appears in a protocol element, the character encoding is defined by that protocol; without such a definition, a URI is assumed to be in the same character encoding as the surrounding text.",
      "ja": "URIの構文は、文字のシーケンスとして、おそらくリソースを識別のために、データを符号化する方法を提供します。 URI文字は、順番に、頻繁に輸送やプレゼンテーションのためのオクテットとしてエンコードされています。この仕様は、URI文字とその文字を格納または送信するために使用オクテットとの間のマッピングのために、特定の文字エンコーディングを強制しません。 URIがプロトコル要素に表示されたら、文字エンコーディングは、そのプロトコルによって定義されます。このような定義なしに、URIは、周囲のテキストと同じ文字エンコーディングであると仮定されます。"
    },
    {
      "indent": 3,
      "text": "The ABNF notation defines its terminal values to be non-negative integers (codepoints) based on the US-ASCII coded character set [ASCII]. Because a URI is a sequence of characters, we must invert that relation in order to understand the URI syntax. Therefore, the integer values used by the ABNF must be mapped back to their corresponding characters via US-ASCII in order to complete the syntax rules.",
      "ja": "ABNF表記法は、その端末値が[ASCII]セットUS-ASCII符号化文字に基づいて、非負整数（コードポイント）であることを規定しています。 URIは、文字のシーケンスであるので、我々は、URIの構文を理解するために、その関係を反転させる必要があります。そのため、ABNFで使用される整数値は、構文規則を完了するために、US-ASCIIを経由して戻ってそれに対応する文字にマッピングする必要があります。"
    },
    {
      "indent": 3,
      "text": "A URI is composed from a limited set of characters consisting of digits, letters, and a few graphic symbols. A reserved subset of those characters may be used to delimit syntax components within a URI while the remaining characters, including both the unreserved set and those reserved characters not acting as delimiters, define each component's identifying data.",
      "ja": "URIは、数字、文字からなる文字の限定セット、およびいくつかのグラフィックシンボルから構成されています。これらの文字の予約サブセットが予約されていないセットとデリミタとして動作していないもの予約文字の両方を含む残りの文字は、各コンポーネントの識別データを定義しながら、URI内の構文要素を区切るために使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.1. Percent-Encoding",
      "section_title": true,
      "ja": "2.1. パーセントエンコーディング"
    },
    {
      "indent": 3,
      "text": "A percent-encoding mechanism is used to represent a data octet in a component when that octet's corresponding character is outside the allowed set or is being used as a delimiter of, or within, the component. A percent-encoded octet is encoded as a character triplet, consisting of the percent character \"%\" followed by the two hexadecimal digits representing that octet's numeric value. For example, \"%20\" is the percent-encoding for the binary octet \"00100000\" (ABNF: %x20), which in US-ASCII corresponds to the space character (SP). Section 2.4 describes when percent-encoding and decoding is applied.",
      "ja": "パーセントエンコーディング機構は、そのオクテットの対応する文字が許可セット外であるかのデリミタ、または内部成分として使用されている場合に、コンポーネントのデータオクテットを表すために使用されます。パーセントエンコードされたオクテットは、オクテットの数値を表す2桁の16進数字が続くパーセント文字「％」からなる文字トリプレットとして符号化されます。 US-ASCIIに空白文字（SP）に相当する：（％のX20 ABNF）、例えば、 \"20％\" とは、バイナリーオクテット \"00100000\" のパーセントエンコーディングです。パーセント符号化及び復号化が適用されるときにセクション2.4で説明しています。"
    },
    {
      "indent": 6,
      "text": "pct-encoded = \"%\" HEXDIG HEXDIG",
      "ja": "PCTエンコード= \"％\" HEXDIG HEXDIG"
    },
    {
      "indent": 3,
      "text": "The uppercase hexadecimal digits 'A' through 'F' are equivalent to the lowercase digits 'a' through 'f', respectively. If two URIs differ only in the case of hexadecimal digits used in percent-encoded octets, they are equivalent. For consistency, URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings.",
      "ja": "「F」を介して、大文字の16進数「A」は、それぞれ、「」「F」を介して小文字の数字に相当します。 2つのURIは、パーセントエンコードオクテットで使用される16進数の場合にのみ異なる場合、それらは等価です。一貫性のために、URIプロデューサーと正規化は、全てのパーセントエンコーディングのための大文字の16進数字を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Reserved Characters",
      "section_title": true,
      "ja": "2.2. 予約文字"
    },
    {
      "indent": 3,
      "text": "URIs include components and subcomponents that are delimited by characters in the \"reserved\" set. These characters are called \"reserved\" because they may (or may not) be defined as delimiters by the generic syntax, by each scheme-specific syntax, or by the implementation-specific syntax of a URI's dereferencing algorithm. If data for a URI component would conflict with a reserved character's purpose as a delimiter, then the conflicting data must be percent-encoded before the URI is formed.",
      "ja": "URIは、「予約済み」セットの文字で区切られているコンポーネントおよびサブコンポーネントが含まれます。彼らは（またはしない場合があります）各スキーム固有の構文により、一般的な構文で区切り文字として定義され、またはURIの逆参照アルゴリズムの実装固有の構文によってすることができるので、これらの文字は、いわゆる「予約」されています。 URIコンポーネントのデータは、区切り文字として予約文字の目的と競合する場合URIを形成する前に、その後、競合データは、パーセントエンコードされなければなりません。"
    },
    {
      "indent": 6,
      "text": "reserved = gen-delims / sub-delims",
      "ja": "=予約遺伝子delims /サブdelims"
    },
    {
      "indent": 6,
      "text": "gen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"",
      "ja": "遺伝子delims = \"\" / \"/\" / \"？\" / \"＃\" / \"W\" / \"W\" / \"@\""
    },
    {
      "indent": 6,
      "text": "sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
      "ja": "サブdelims = \"！\" / \"$\" / \"＆\" / \"L\" / \"（\" / \"）\" / \"*\" / \"+\" / \"\" / \";\" / \"=\""
    },
    {
      "indent": 3,
      "text": "The purpose of reserved characters is to provide a set of delimiting characters that are distinguishable from other data within a URI. URIs that differ in the replacement of a reserved character with its corresponding percent-encoded octet are not equivalent. Percent-encoding a reserved character, or decoding a percent-encoded octet that corresponds to a reserved character, will change how the URI is interpreted by most applications. Thus, characters in the reserved set are protected from normalization and are therefore safe to be used by scheme-specific and producer-specific algorithms for delimiting data subcomponents within a URI.",
      "ja": "予約文字の目的は、URI内の他のデータと区別されている文字を区切るのセットを提供することです。その対応するパーセントエンコードされたオクテットで予約文字の代わりに異なるURIは等価ではありません。予約文字をパーセントコード、または予約文字に対応するパーセントエンコードされたオクテットを復号する、URIは、ほとんどのアプリケーションによって解釈される方法を変更します。したがって、予約セットの文字は、正規化から保護され、したがって、URI内のデータサブコンポーネントを画定するためのスキーマ固有及びプロデューサ特定のアルゴリズムによって使用される安全です。"
    },
    {
      "indent": 3,
      "text": "A subset of the reserved characters (gen-delims) is used as delimiters of the generic URI components described in Section 3. A component's ABNF syntax rule will not use the reserved or gen-delims rule names directly; instead, each syntax rule lists the characters allowed within that component (i.e., not delimiting it), and any of those characters that are also in the reserved set are \"reserved\" for use as subcomponent delimiters within the component. Only the most common subcomponents are defined by this specification; other subcomponents may be defined by a URI scheme's specification, or by the implementation-specific syntax of a URI's dereferencing algorithm, provided that such subcomponents are delimited by characters in the reserved set allowed within that component.",
      "ja": "予約文字（GEN-delims）のサブセットは、コンポーネントのABNF文法規則を直接予約またはGEN-delims規則名を使用しないであろう項3に記載の一般的なURIコンポーネントの区切り文字として使用されます。代わりに、各文法規則は、その構成要素（すなわち、それを限定しない）内に使用できる文字の一覧を示し、そして予約セットでもあるこれらの文字のいずれかがコンポーネント内のサブコンポーネントの区切り文字として使用するために「予約」されています。唯一の最も一般的なサブコンポーネントは、この仕様で定義されています。他のサブコンポーネントは、URIスキームの仕様で定義され、又はURIの参照解除アルゴリズムの実装固有の構文により、そのようなサブコンポーネントは、そのコンポーネント内で許可予約セット内の文字によって区切られていてもよいです。"
    },
    {
      "indent": 3,
      "text": "URI producing applications should percent-encode data octets that correspond to characters in the reserved set unless these characters are specifically allowed by the URI scheme to represent data in that component. If a reserved character is found in a URI component and no delimiting role is known for that character, then it must be interpreted as representing the data octet corresponding to that character's encoding in US-ASCII.",
      "ja": "URIは、アプリケーションこれらの文字は、特にそのコンポーネント内のデータを表現するURIスキームによって許可されない限り、予約セット内の文字に対応する必要がありパーセントエンコードデータオクテットを生成します。予約文字はURIコンポーネントで発見され、何の区切り役割は、その文字のために知られていない場合、それはUS-ASCIIでその文字のエンコーディングに対応するデータオクテットを表すものとして解釈されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3. Unreserved Characters",
      "section_title": true,
      "ja": "2.3. 非予約文字"
    },
    {
      "indent": 3,
      "text": "Characters that are allowed in a URI but do not have a reserved purpose are called unreserved. These include uppercase and lowercase letters, decimal digits, hyphen, period, underscore, and tilde.",
      "ja": "URIで許可されていますが、予約の目的を持っていない文字は予約されていないと呼ばれています。これらは、大文字と小文字、小数点以下の桁、ハイフン、ピリオド、アンダースコア、およびチルダが含まれます。"
    },
    {
      "indent": 6,
      "text": "unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"",
      "ja": "予約されていない= ALPHA / DIGIT / \" - \" / \"\" / \"_\" / \"〜\""
    },
    {
      "indent": 3,
      "text": "URIs that differ in the replacement of an unreserved character with its corresponding percent-encoded US-ASCII octet are equivalent: they identify the same resource. However, URI comparison implementations do not always perform normalization prior to comparison (see Section 6). For consistency, percent-encoded octets in the ranges of ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should not be created by URI producers and, when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.",
      "ja": "それに対応するパーセントエンコードUS-ASCIIオクテットで予約されていない文字の代わりに異なるURIは等価である：彼らは同じリソースを識別します。しかし、URI比較実装は常に比較する前に正規化を行わない（第6節を参照してください）。一貫性のために、ALPHAの範囲におけるパーセントエンコードオクテット（％41-％5Aおよび％61-％の7A）、数字（％30-％39）、ハイフン（％が2D）、期間（％の2E）、アンダー（％ 5F）、またはチルダ（％の7E）はURIプロデューサによって作成されるべきではないと、URIに見出される場合、URIの正規化により、それらの対応する非予約文字にデコードされなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4. When to Encode or Decode",
      "section_title": true,
      "ja": "2.4. ときにエンコードまたはデコードします"
    },
    {
      "indent": 3,
      "text": "Under normal circumstances, the only time when octets within a URI are percent-encoded is during the process of producing the URI from its component parts. This is when an implementation determines which of the reserved characters are to be used as subcomponent delimiters and which can be safely used as data. Once produced, a URI is always in its percent-encoded form.",
      "ja": "通常の状況下では、URI内のオクテットをパーセントエンコードされた唯一の時間は、その構成部品からURIを生成する過程です。インプリメンテーションは、サブコンポーネントの区切り文字として使用されるべきであり、これは、安全にデータとして使用することができる予約文字のかを決定する場合です。生成されると、URIは、パーセントエンコードされた形式で常に。"
    },
    {
      "indent": 3,
      "text": "When a URI is dereferenced, the components and subcomponents significant to the scheme-specific dereferencing process (if any) must be parsed and separated before the percent-encoded octets within those components can be safely decoded, as otherwise the data may be mistaken for component delimiters. The only exception is for percent-encoded octets corresponding to characters in the unreserved set, which can be decoded at any time. For example, the octet corresponding to the tilde (\"~\") character is often encoded as \"%7E\" by older URI processing implementations; the \"%7E\" can be replaced by \"~\" without changing its interpretation.",
      "ja": "URIが参照解除されたとき、スキーマ固有参照解除処理（もしあれば）に有意なコンポーネントおよびサブコンポーネントは、そうでなければ、データは、コンポーネントと間違われることができるように、解析され、安全に復号することができ、これらの構成要素内のパーセントエンコードされたオクテットの前に分離しなければなりません区切り文字。唯一の例外は、任意の時点で復号することができる非予約セット内の文字に対応するパーセントエンコードされたオクテットのためのものです。例えば、チルダに対応するオクテットが（「〜」）の文字は、多くの場合、古いURI処理実装では「％7E」として符号化されます。 「％の7Eは、」その解釈を変更することなく、「〜」に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "Because the percent (\"%\") character serves as the indicator for percent-encoded octets, it must be percent-encoded as \"%25\" for that octet to be used as data within a URI. Implementations must not percent-encode or decode the same string more than once, as decoding an already decoded string might lead to misinterpreting a percent data octet as the beginning of a percent-encoding, or vice versa in the case of percent-encoding an already percent-encoded string.",
      "ja": "パーセント（「％」）文字はパーセントエンコードされたオクテットのための指標となるので、そのオクテットは、URI内のデータとして使用するために、「％25」として％がエンコードされなければなりません。実装は、パーセントエンコードしない必要がある、または既にデコードされた文字列をデコードするようにした場合のパーセントエンコーディングの開始、またはその逆としてパーセントデータオクテットを誤解を招くかもしれないが、何度も同じ文字列以上を復号化済みパーセントコードパーセントエンコードされた文字列。"
    },
    {
      "indent": 0,
      "text": "2.5. Identifying Data",
      "section_title": true,
      "ja": "2.5. 識別データ"
    },
    {
      "indent": 3,
      "text": "URI characters provide identifying data for each of the URI components, serving as an external interface for identification between systems. Although the presence and nature of the URI production interface is hidden from clients that use its URIs (and is thus beyond the scope of the interoperability requirements defined by this specification), it is a frequent source of confusion and errors in the interpretation of URI character issues. Implementers have to be aware that there are multiple character encodings involved in the production and transmission of URIs: local name and data encoding, public interface encoding, URI character encoding, data format encoding, and protocol encoding.",
      "ja": "URI文字は、システム間の識別のための外部インターフェースとして、URI成分毎に識別データを提供します。 URIの生産・インタフェースの存在と性質はそのURIを使用します（この仕様で定義された相互運用性の要件の範囲を超えことである）クライアントから隠されているが、それは、URI文字の解釈で混乱やエラーの頻繁な源であります問題。ローカル名とデータの符号化、パブリックインタフェースエンコーディング、URI文字エンコーディング、データ形式のエンコード、およびプロトコルのエンコーディング：実装者は、URIの生産及び伝達に関与する複数の文字エンコーディングがあることを認識する必要があります。"
    },
    {
      "indent": 3,
      "text": "Local names, such as file system names, are stored with a local character encoding. URI producing applications (e.g., origin servers) will typically use the local encoding as the basis for producing meaningful names. The URI producer will transform the local encoding to one that is suitable for a public interface and then transform the public interface encoding into the restricted set of URI characters (reserved, unreserved, and percent-encodings). Those characters are, in turn, encoded as octets to be used as a reference within a data format (e.g., a document charset), and such data formats are often subsequently encoded for transmission over Internet protocols.",
      "ja": "このようなファイルシステム名などのローカル名は、ローカルの文字エンコーディングで保存されます。 URI生成アプリケーション（例えば、オリジンサーバ）は、典型的に意味のある名前を生成するための基礎としてローカルエンコーディングを使用します。 URIプロデューサがパブリックインターフェイスに適したものにローカルエンコーディングを変換した後、URI文字の制限されたセットにパブリックインタフェースエンコーディングを変換します（予約されていない、予約、及びパーセントエンコーディング）。これらの文字は、オクテットがデータフォーマット（例えば、文書の文字セット）内の基準として使用するように、順番に、符号化され、そしてそのようなデータ形式は、多くの場合、その後、インターネットプロトコル上での伝送のために符号化されます。"
    },
    {
      "indent": 3,
      "text": "For most systems, an unreserved character appearing within a URI component is interpreted as representing the data octet corresponding to that character's encoding in US-ASCII. Consumers of URIs assume that the letter \"X\" corresponds to the octet \"01011000\", and even when that assumption is incorrect, there is no harm in making it. A system that internally provides identifiers in the form of a different character encoding, such as EBCDIC, will generally perform character translation of textual identifiers to UTF-8 [STD63] (or some other superset of the US-ASCII character encoding) at an internal interface, thereby providing more meaningful identifiers than those resulting from simply percent-encoding the original octets.",
      "ja": "ほとんどのシステムでは、URIコンポーネント内に現れる非予約文字はUS-ASCIIでその文字のエンコーディングに対応するデータオクテットを表すものとして解釈されます。 URIの消費者は、文字「X」はオクテット「01011000」に対応することを前提とし、その仮定が正しくない場合でも、それを作るにしても支障はありません。内部例えばEBCDICなどの異なる文字符号化、の形で識別子を提供するシステムは、一般的に内部でUTF-8 [STD63]（またはUS-ASCII文字エンコーディングのいくつかの他のスーパーセット）にテキスト識別子の文字変換を実行しますインターフェースは、それによって、単に元のオクテットをパーセントエンコーディングから得られるものよりも意味のある識別子を提供します。"
    },
    {
      "indent": 3,
      "text": "For example, consider an information service that provides data, stored locally using an EBCDIC-based file system, to clients on the Internet through an HTTP server. When an author creates a file with the name \"Laguna Beach\" on that file system, the \"http\" URI corresponding to that resource is expected to contain the meaningful string \"Laguna%20Beach\". If, however, that server produces URIs by using an overly simplistic raw octet mapping, then the result would be a URI containing \"%D3%81%87%A4%95%81@%C2%85%81%83%88\". An internal transcoding interface fixes this problem by transcoding the local name to a superset of US-ASCII prior to producing the URI. Naturally, proper interpretation of an incoming URI on such an interface requires that percent-encoded octets be decoded (e.g., \"%20\" to SP) before the reverse transcoding is applied to obtain the local name.",
      "ja": "例えば、HTTPサーバーを介してインターネット上のクライアントに、EBCDICベースのファイルシステムを使用して、ローカルに保存されたデータを、提供する情報サービスを検討してください。著者は、そのファイルシステム上の名前を「ラグナ・ビーチ」を使用してファイルを作成すると、そのリソースに対応する「HTTP」URIは意味のある文字列「ラグナ％20Beach」を含むことが期待されます。しかし、そのサーバーが過度に単純化した生のオクテットマッピングを使用してURIを生成する場合、結果は \"％のC2の％85％81％83％88 @％D3は％81％87％A4は％95％81\" を含むURIであろう。内部トランスコーディング・インターフェースは、URIを生成する前に、US-ASCIIのスーパーセットにローカル名をトランスコードすることにより、この問題を修正します。当然のことながら、そのようなインターフェイスの着信URIの適切な解釈は、パーセントエンコードされたオクテットを復号することが必要（例えば、「20％」SPに）逆トランスコーディングは、ローカル名を取得するために適用される前に。"
    },
    {
      "indent": 3,
      "text": "In some cases, the internal interface between a URI component and the identifying data that it has been crafted to represent is much less direct than a character encoding translation. For example, portions of a URI might reflect a query on non-ASCII data, or numeric coordinates on a map. Likewise, a URI scheme may define components with additional encoding requirements that are applied prior to forming the component and producing the URI.",
      "ja": "いくつかのケースでは、URIのコンポーネントと表すように細工された識別データとの間の内部インターフェイスは、文字エンコーディング変換よりもはるかに少ない直接的です。例えば、URIの部分は、マップ上の非ASCIIデータのクエリ、または数値座標を反映しているのかもしれません。同様に、URIスキームは、従来の成分を形成し、URIを生成するために適用される追加的な符号化の要件とコンポーネントを定義することができます。"
    },
    {
      "indent": 3,
      "text": "When a new URI scheme defines a component that represents textual data consisting of characters from the Universal Character Set [UCS], the data should first be encoded as octets according to the UTF-8 character encoding [STD63]; then only those octets that do not correspond to characters in the unreserved set should be percent-encoded. For example, the character A would be represented as \"A\", the character LATIN CAPITAL LETTER A WITH GRAVE would be represented as \"%C3%80\", and the character KATAKANA LETTER A would be represented as \"%E3%82%A2\".",
      "ja": "新しいURIスキームは[UCS]を設定ユニバーサル文字の文字からなるテキストデータを表すコンポーネントを定義する場合、データは最初の[STD63]コードUTF-8文字に係るオクテットとして符号化されるべきです。その後、予約されていないセットの文字に対応していないだけでそれらのオクテットは、パーセントエンコードする必要があります。例えば、文字Aは「A」と表記される、グレーブ付き文字ラテン大文字Aは、「％のC3％80」として表現される、文字カタカナLETTER Aは％E3の％82％A2」として表現されます」。"
    },
    {
      "indent": 0,
      "text": "3. Syntax Components",
      "section_title": true,
      "ja": "3.構文コンポーネント"
    },
    {
      "indent": 3,
      "text": "The generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment.",
      "ja": "一般的なURI構文はスキーム、権限、パス、クエリー、およびフラグメントと呼ばれるコンポーネントの階層的な配列からなります。"
    },
    {
      "indent": 6,
      "text": "URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "URI =スキーム \"：\" \"？\" のhierパート[クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 6,
      "text": "hier-part = \"//\" authority path-abempty / path-absolute / path-rootless / path-empty",
      "ja": "hier-部分= \"//\" 権威パス-abempty /パス-絶対/パス・ルートレス/パス、空"
    },
    {
      "indent": 3,
      "text": "The scheme and path components are required, though the path may be empty (no characters). When authority is present, the path must either be empty or begin with a slash (\"/\") character. When authority is not present, the path cannot begin with two slash characters (\"//\"). These restrictions result in five different ABNF rules for a path (Section 3.3), only one of which will match any given URI reference.",
      "ja": "パスは（NO文字）が空であってもよいけれども方式および経路の構成要素は、必要とされます。権限が存在する場合、パスが空であるか、スラッシュ（「/」）文字で始める必要があります。権限が存在しない場合、パスは2つのスラッシュ文字（「//」）で始めることはできません。これらの制限は、任意のURI参照に一致する唯一のうちの一つの経路（セクション3.3）のための5つの異なるABNF規則をもたらします。"
    },
    {
      "indent": 3,
      "text": "The following are two example URIs and their component parts:",
      "ja": "以下は、2つの例示的URIとその構成部品です。"
    },
    {
      "indent": 7,
      "text": "  foo://example.com:8042/over/there?name=ferret#nose\n  \\_/   \\______________/\\_________/ \\_________/ \\__/\n   |           |            |            |        |\nscheme     authority       path        query   fragment\n   |   _____________________|__\n  / \\ /                        \\\n  urn:example:animal:ferret:nose",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1. Scheme",
      "section_title": true,
      "ja": "3.1. スキーム"
    },
    {
      "indent": 3,
      "text": "Each URI begins with a scheme name that refers to a specification for assigning identifiers within that scheme. As such, the URI syntax is a federated and extensible naming system wherein each scheme's specification may further restrict the syntax and semantics of identifiers using that scheme.",
      "ja": "各URIは、そのスキーム内識別子を割り当てるための仕様を指すスキーム名で始まります。このように、URIの構文は各スキームの仕様は、さらにその方式を使用して識別子の構文と意味論を制限することができる、請求連合と拡張ネーミングシステムです。"
    },
    {
      "indent": 3,
      "text": "Scheme names consist of a sequence of characters beginning with a letter and followed by any combination of letters, digits, plus (\"+\"), period (\".\"), or hyphen (\"-\"). Although schemes are case-insensitive, the canonical form is lowercase and documents that specify schemes must do so with lowercase letters. An implementation should accept uppercase letters as equivalent to lowercase in scheme names (e.g., allow \"HTTP\" as well as \"http\") for the sake of robustness but should only produce lowercase scheme names for consistency.",
      "ja": "スキーム名は文字で始まる文字列で構成され、文字、数字、プラス（「+」）、期間の任意の組み合わせが続く、またはハイフン（「 -  『）（』。」）。スキームは大文字と小文字を区別しないですが、標準的な形式は小文字とスキームは小文字を使用しなければなりません指定した文書です。実装は、堅牢性のためにスキーム名（例えば、許可「HTTP」ならびに「HTTP」）で小文字と同等に大文字を受け入れるべきであるだけ一貫性のために小文字のスキーム名を生成するべきです。"
    },
    {
      "indent": 6,
      "text": "scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )",
      "ja": "スキーム= ALPHAの*（ALPHA / DIGIT / \"+\" / \" - \" / \"\"）"
    },
    {
      "indent": 3,
      "text": "Individual schemes are not specified by this document. The process for registration of new URI schemes is defined separately by [BCP35]. The scheme registry maintains the mapping between scheme names and their specifications. Advice for designers of new URI schemes can be found in [RFC2718]. URI scheme specifications must define their own syntax so that all strings matching their scheme-specific syntax will also match the <absolute-URI> grammar, as described in Section 4.3.",
      "ja": "個々のスキームは、この文書で指定されていません。新しいURIスキームの登録のための方法は、[BCP35]で別々に定義されます。スキームレジストリは、スキーム名とその仕様の間のマッピングを維持します。新しいURIスキームの設計者のためのアドバイスは、[RFC2718]で見つけることができます。 4.3節で説明したように彼らのスキーム固有の構文に一致するすべての文字列でも、<絶対URI>の文法にマッチするようにURIスキームの仕様は独自の構文を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "When presented with a URI that violates one or more scheme-specific restrictions, the scheme-specific resolution process should flag the reference as an error rather than ignore the unused parts; doing so reduces the number of equivalent URIs and helps detect abuses of the generic syntax, which might indicate that the URI has been constructed to mislead the user (Section 7.6).",
      "ja": "一つ以上の方式固有の制限に違反するURIを提示するとき、スキーマ固有解像度処理フラグの参照はエラーとしてではなく、未使用の部分を無視するべきです。そうすることと等価のURIの数を減らし、URIは、ユーザー（7.6節）を誤解するように構成されていることを示している可能性があります一般的な構文、侵害を検出するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "3.2. Authority",
      "section_title": true,
      "ja": "3.2. 権限"
    },
    {
      "indent": 3,
      "text": "Many URI schemes include a hierarchical element for a naming authority so that governance of the name space defined by the remainder of the URI is delegated to that authority (which may, in turn, delegate it further). The generic syntax provides a common means for distinguishing an authority based on a registered name or server address, along with optional port and user information.",
      "ja": "URIの残りの部分で定義された名前空間の統治は（順番に、さらにそれを委任することができる）という機関に委譲されるように、多くのURIスキームが命名機関のための階層的な要素が含まれています。一般的な構文は、オプションのポートとユーザ情報と共に、登録名またはサーバアドレスに基づいて権限を区別するための一般的な手段を提供します。"
    },
    {
      "indent": 3,
      "text": "The authority component is preceded by a double slash (\"//\") and is terminated by the next slash (\"/\"), question mark (\"?\"), or number sign (\"#\") character, or by the end of the URI.",
      "ja": "権限コンポーネントは、ダブルスラッシュ（「//」）が先行して、次のスラッシュ（「/」）、疑問符（「？」）、または番号記号（「＃」）文字、または終了によって終了されますURIの。"
    },
    {
      "indent": 6,
      "text": "authority = [ userinfo \"@\" ] host [ \":\" port ]",
      "ja": "権限=ホスト[ \"：\" ポート] [ \"@\" のuserinfo]"
    },
    {
      "indent": 3,
      "text": "URI producers and normalizers should omit the \":\" delimiter that separates host from port if the port component is empty. Some schemes do not allow the userinfo and/or port subcomponents.",
      "ja": "「：」ポートコンポーネントが空である場合は、ポートからホストを区切る区切りURIプロデューサーと正規化は省略しなければなりません。いくつかのスキームはのuserinfoおよび/またはポートサブコンポーネントを許可していません。"
    },
    {
      "indent": 3,
      "text": "If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character. Non-validating parsers (those that merely separate a URI reference into its major components) will often ignore the subcomponent structure of authority, treating it as an opaque string from the double-slash to the first terminating delimiter, until such time as the URI is dereferenced.",
      "ja": "URIが権威コンポーネントが含まれている場合は、そのパスコンポーネントが空であるか、スラッシュ（「/」）文字で始める必要があります。 URIであるような時間まで、最初の終了区切り文字にダブルスラッシュから不透明な文字列として扱い、多くの場合、権限のサブコンポーネント構造を無視するパーサー（単にその主要成分にURI参照を分離するもの）を非検証間接参照。"
    },
    {
      "indent": 0,
      "text": "3.2.1. User Information",
      "section_title": true,
      "ja": "3.2.1. ユーザー情報"
    },
    {
      "indent": 3,
      "text": "The userinfo subcomponent may consist of a user name and, optionally, scheme-specific information about how to gain authorization to access the resource. The user information, if present, is followed by a commercial at-sign (\"@\") that delimits it from the host.",
      "ja": "ユーザー情報のサブコンポーネントは、ユーザー名およびリソースにアクセスするための許可を取得する方法については、必要に応じて、スキーム固有の情報から構成されてもよいです。ユーザ情報は、存在する場合、ホストからそれを区切るアットマーク（「@」）コマーシャルが続きます。"
    },
    {
      "indent": 6,
      "text": "userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )",
      "ja": "ユーザー情報= *（予約されていない/ PCTエンコード/サブdelims / \"：\"）"
    },
    {
      "indent": 3,
      "text": "Use of the format \"user:password\" in the userinfo field is deprecated. Applications should not render as clear text any data after the first colon (\":\") character found within a userinfo subcomponent unless the data after the colon is the empty string (indicating no password). Applications may choose to ignore or reject such data when it is received as part of a reference and should reject the storage of such data in unencrypted form. The passing of authentication information in clear text has proven to be a security risk in almost every case where it has been used.",
      "ja": "フォーマットの使用：のUserInfoフィールドに「ユーザーパスワードは」廃止されました。アプリケーションは、最初のコロン（「：」）の後にクリアテキストとしてに任意のデータをレンダリングするべきではないコロン（パスワードがないことを示す）、空の文字列になった後のデータがない限りのUserInfoサブコンポーネント内で見つかった文字。アプリケーションは、それが基準の一部として受信されたときにそのようなデータを無視または拒否することを選択することができ、暗号化されていない形でそのようなデータの記憶を拒否すべきです。クリアテキストでの認証情報の受け渡しは、それが使用されているほぼすべてのケースではセキュリティ上のリスクがあることが証明されています。"
    },
    {
      "indent": 3,
      "text": "Applications that render a URI for the sake of user feedback, such as in graphical hypertext browsing, should render userinfo in a way that is distinguished from the rest of a URI, when feasible. Such rendering will assist the user in cases where the userinfo has been misleadingly crafted to look like a trusted domain name (Section 7.6).",
      "ja": "グラフィカルなハイパーテキストブラウジングのようにユーザーからのフィードバックのためにURIをレンダリングするアプリケーションは、実行可能なときURIの残りの部分と区別された方法でuserinfoをレンダリングする必要があります。このようなレンダリングはuserinfoをは誤解を招く信頼されたドメイン名（7.6節）のように見えるように細工された場合は、ユーザーを支援します。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Host",
      "section_title": true,
      "ja": "3.2.2. ホスト"
    },
    {
      "indent": 3,
      "text": "The host subcomponent of authority is identified by an IP literal encapsulated within square brackets, an IPv4 address in dotted-decimal form, or a registered name. The host subcomponent is case-insensitive. The presence of a host subcomponent within a URI does not imply that the scheme requires access to the given host on the Internet. In many cases, the host syntax is used only for the sake of reusing the existing registration process created and deployed for DNS, thus obtaining a globally unique name without the cost of deploying another registry. However, such use comes with its own costs: domain name ownership may change over time for reasons not anticipated by the URI producer. In other cases, the data within the host component identifies a registered name that has nothing to do with an Internet host. We use the name \"host\" for the ABNF rule because that is its most common purpose, not its only purpose.",
      "ja": "権限のホストサブコンポーネントが角括弧内にカプセル化IPリテラルによって識別され、ドット区切り形式のIPv4アドレス、または登録名。ホストサブコンポーネントは、大文字と小文字を区別しません。 URI内のホストサブコンポーネントの存在は、スキームは、インターネット上の特定のホストへのアクセスを必要とすることを意味するものではありません。多くの場合、ホストの構文は、このように別のレジストリを展開するコストをかけずにグローバルに一意の名前を取得し、唯一のDNSのために作成、展開、既存の登録プロセスを再利用のために使用されています。しかし、そのような使用は、独自のコストが付属しています：ドメイン名の所有権は、URIプロデューサーが予想していない理由のために時間をかけて変更されることがあります。他の例では、ホストコンポーネント内のデータは、インターネットホストとは何の関係もありません登録名を識別します。それは、その最も一般的な目的ではなく、その唯一の目的であるので、我々はABNF規則の名前「ホスト」を使用します。"
    },
    {
      "indent": 6,
      "text": "host = IP-literal / IPv4address / reg-name",
      "ja": "ホスト= IP-リテラル/ IPv4Addressを/ REG-名"
    },
    {
      "indent": 3,
      "text": "The syntax rule for host is ambiguous because it does not completely distinguish between an IPv4address and a reg-name. In order to disambiguate the syntax, we apply the \"first-match-wins\" algorithm: If host matches the rule for IPv4address, then it should be considered an IPv4 address literal and not a reg-name. Although host is case-insensitive, producers and normalizers should use lowercase for registered names and hexadecimal addresses for the sake of uniformity, while only using uppercase letters for percent-encodings.",
      "ja": "それは完全にIPv4AddressをとREG-名を区別しないため、ホストの構文規則があいまいです。構文を明確にするために、我々は「第一試合、勝ち」アルゴリズムを適用します。ホストはIPv4Addressをするためのルールと一致した場合、それはREG-名前リテラルではなく、IPv4アドレスと考えるべきです。ホストは大文字と小文字を区別しないものののみパーセントエンコーディングの大文字を使用しながら、生産者と正規化は、均一性のために登録名と16進アドレスの小文字を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A host identified by an Internet Protocol literal address, version 6 [RFC3513] or later, is distinguished by enclosing the IP literal within square brackets (\"[\" and \"]\"). This is the only place where square bracket characters are allowed in the URI syntax. In anticipation of future, as-yet-undefined IP literal address formats, an implementation may use an optional version flag to indicate such a format explicitly rather than rely on heuristic determination.",
      "ja": "インターネットプロトコルリテラルアドレス、バージョン6 [RFC3513]以降によって識別されるホストは、角括弧内のリテラルIPを封入することによって区別される（「[」と「]」）。これは、角括弧文字がURI構文で許可されている唯一の場所です。将来を見越して、AS-まだ未定義のIPリテラルアドレス形式は、実装は、そのようなフォーマットを示す明示的ではなくヒューリスティック決意に依存するオプションのバージョンフラグを使用することができます。"
    },
    {
      "indent": 6,
      "text": "IP-literal = \"[\" ( IPv6address / IPvFuture ) \"]\"",
      "ja": "IP-リテラル= \"[\"（IPv6address / IPvFuture） \"]\""
    },
    {
      "indent": 6,
      "text": "IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )",
      "ja": "IPvFuture = \"\" 1 * HESDIG \"\" 1 *（inreserved /サブdelims / \"：\"）"
    },
    {
      "indent": 3,
      "text": "The version flag does not indicate the IP version; rather, it indicates future versions of the literal format. As such, implementations must not provide the version flag for the existing IPv4 and IPv6 literal address forms described below. If a URI containing an IP-literal that starts with \"v\" (case-insensitive), indicating that the version flag is present, is dereferenced by an application that does not know the meaning of that version flag, then the application should return an appropriate error for \"address mechanism not supported\".",
      "ja": "バージョンフラグはIPバージョンを示すものではありません。むしろ、それはリテラル形式の将来のバージョンを示します。このように、実装は、以下に記載する既存のIPv4とIPv6のリテラルアドレス形式のバージョンフラグを提供してはなりません。バージョンフラグが存在することを示し、「V」（大文字と小文字を区別しない）で始まり、そのIP-リテラルを含むURIは、そのバージョンフラグの意味を知らないアプリケーションによって参照解除された場合、アプリケーションが返すべき「サポートされていないアドレスメカニズム」のための適切なエラー。"
    },
    {
      "indent": 3,
      "text": "A host identified by an IPv6 literal address is represented inside the square brackets without a preceding version flag. The ABNF provided here is a translation of the text definition of an IPv6 literal address provided in [RFC3513]. This syntax does not support IPv6 scoped addressing zone identifiers.",
      "ja": "IPv6のリテラルアドレスによって識別されるホストは、先行するバージョンフラグなしで角括弧の内部表現されます。ここで提供ABNFは、[RFC3513]で提供IPv6のリテラルアドレスのテキスト定義を翻訳したものです。この構文は、IPv6がゾーン識別子に対処スコープをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "A 128-bit IPv6 address is divided into eight 16-bit pieces. Each piece is represented numerically in case-insensitive hexadecimal, using one to four hexadecimal digits (leading zeroes are permitted). The eight encoded pieces are given most-significant first, separated by colon characters. Optionally, the least-significant two pieces may instead be represented in IPv4 address textual format. A sequence of one or more consecutive zero-valued 16-bit pieces within the address may be elided, omitting all their digits and leaving exactly two consecutive colons in their place to mark the elision.",
      "ja": "128ビットのIPv6アドレスは、8つの16ビットに分割されます。各ピースは、（先行ゼロが許可されている）1〜4個の16進数字を使用して、大文字と小文字を区別しない進数で数値的に表されています。 8つのエンコードされた作品は、コロン文字で区切られ、最初の最上位与えられています。任意に、最下位2枚の代わりにIPv4アドレス、テキスト形式で表現することができます。アドレス内の1つ以上の連続したゼロ値の16ビット片の配列は、すべての数字を省略し、エリジオンをマークするためにその場所に正確に二つの連続するコロンを残し、省略されてもよいです。"
    },
    {
      "indent": 6,
      "text": "IPv6address = 6( h16 \":\" ) ls32 / \"::\" 5( h16 \":\" ) ls32 / [ h16 ] \"::\" 4( h16 \":\" ) ls32 / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32 / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32 / [ *3( h16 \":\" ) h16 ] \"::\" h16 \":\" ls32 / [ *4( h16 \":\" ) h16 ] \"::\" ls32 / [ *5( h16 \":\" ) h16 ] \"::\" h16 / [ *6( h16 \":\" ) h16 ] \"::\"",
      "ja": "IPv6address = 6（H16 \"：\"）ls32 / \"::\" 5（H16 \"：\"）ls32 / [H16] \"::\" 4（H16 \"：\"）ls32 / [* 1（H16 \"：\"）H16 \"::\" 3（H16 \"：\"）ls32 / [* 2（H16 \"：\"）H16 \"::\" 2（H16 \"：\"）ls32 / [* 3（H16 \"：\"）H16]」 :: \"H16 \"：\" ls32 / [* 4（H16 \"：\"）H16 \"::\" ls32 / [* 5（H16 \"：\"）H16 \"::\" H16 / [* 6（H16\"： \"）H16] \"::\""
    },
    {
      "indent": 6,
      "text": "ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address",
      "ja": "ls32 =（H16 \"：\" H16）/ IPv4Addressを。アドレスの最下位32ビット"
    },
    {
      "indent": 6,
      "text": "h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal",
      "ja": "H16 = 1 * 4HEXDIG。進数で表されるアドレスの16ビット"
    },
    {
      "indent": 3,
      "text": "A host identified by an IPv4 literal address is represented in dotted-decimal notation (a sequence of four decimal numbers in the range 0 to 255, separated by \".\"), as described in [RFC1123] by reference to [RFC0952]. Note that other forms of dotted notation may be interpreted on some platforms, as described in Section 7.4, but only the dotted-decimal form of four octets is allowed by this grammar.",
      "ja": "IPv4のリテラルアドレスによって識別されるホストは、ドット付き10進表記で表されている（で区切られた0〜255の範囲内の4つの10進数のシーケンス、「」）、[RFC0952]を参照することにより、[RFC1123]に記載されているように。ドット表記の他の形態は、セクション7.4で説明したように、いくつかのプラットフォーム上で解釈されてもよいが、4つのオクテットのみドット付き十進形態はこの文法によって許可されていることに注意してください。"
    },
    {
      "indent": 6,
      "text": "IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet",
      "ja": "IPv4Addressを= 12月オクテット「」 12月オクテット「」 12月オクテット「」 12月オクテット"
    },
    {
      "indent": 6,
      "text": "dec-octet = DIGIT ; 0-9 / %x31-39 DIGIT ; 10-99 / \"1\" 2DIGIT ; 100-199 / \"2\" %x30-34 DIGIT ; 200-249 / \"25\" %x30-35 ; 250-255",
      "ja": "12月オクテット= DIGIT; 0-9 /％x31-39 DIGIT。 10-99 / \"1\" 2DIGIT。 100-199 / \"2\" ％x30-34 DIGIT。 200から249 / \"25\" ％x30-35。 250-255"
    },
    {
      "indent": 3,
      "text": "A host identified by a registered name is a sequence of characters usually intended for lookup within a locally defined host or service name registry, though the URI's scheme-specific semantics may require that a specific registry (or fixed name table) be used instead. The most common name registry mechanism is the Domain Name System (DNS). A registered name intended for lookup in the DNS uses the syntax defined in Section 3.5 of [RFC1034] and Section 2.1 of [RFC1123]. Such a name consists of a sequence of domain labels separated by \".\", each domain label starting and ending with an alphanumeric character and possibly also containing \"-\" characters. The rightmost domain label of a fully qualified domain name in DNS may be followed by a single \".\" and should be if it is necessary to distinguish between the complete domain name and some local domain.",
      "ja": "URIのスキーム固有の意味は、特定のレジストリ（または固定名称テーブル）を代わりに使用することが必要かもしれませんが、登録名で識別されるホストは、通常、ローカルに定義されたホストまたはサービス名のレジストリ内のルックアップのために意図された文字のシーケンスです。最も一般的な名前のレジストリメカニズムは、ドメインネームシステム（DNS）です。 DNSルックアップのために意図登録名は、[RFC1034]のセクション3.5と[RFC1123]のセクション2.1で定義された構文を使用しています。このような名前がで区切られたドメインラベルの系列から成り、各ドメインラベルが始まり、英数字で終わると、おそらくも含む「」 『 - 』の文字が。 DNSで完全修飾ドメイン名の一番右のドメインラベルは、シングルを続けてもよいです「」そして、完全なドメイン名と、いくつかのローカルドメインを区別する必要がある場合でなければなりません。"
    },
    {
      "indent": 6,
      "text": "reg-name = *( unreserved / pct-encoded / sub-delims )",
      "ja": "REG-NAME = *（予約されていない/ PCTエンコード/サブdelims）"
    },
    {
      "indent": 3,
      "text": "If the URI scheme defines a default for host, then that default applies when the host subcomponent is undefined or when the registered name is empty (zero length). For example, the \"file\" URI scheme is defined so that no authority, an empty host, and \"localhost\" all mean the end-user's machine, whereas the \"http\" scheme considers a missing authority or empty host invalid.",
      "ja": "URIスキームはホストのデフォルト値を定義している場合、ホスト・サブコンポーネントが定義されていない場合、または登録名は、（長さゼロ）が空である場合、そのデフォルトが適用されます。たとえば、「ファイル」URIスキームが定義されている「HTTP」スキームが不足している権限や空のホストが無効と考えるのに対し何の権威、空のホスト、および「localhost」を、すべては、エンドユーザのマシンを意味しないように。"
    },
    {
      "indent": 3,
      "text": "This specification does not mandate a particular registered name lookup technology and therefore does not restrict the syntax of reg-name beyond what is necessary for interoperability. Instead, it delegates the issue of registered name syntax conformance to the operating system of each application performing URI resolution, and that operating system decides what it will allow for the purpose of host identification. A URI resolution implementation might use DNS, host tables, yellow pages, NetInfo, WINS, or any other system for lookup of registered names. However, a globally scoped naming system, such as DNS fully qualified domain names, is necessary for URIs intended to have global scope. URI producers should use names that conform to the DNS syntax, even when use of DNS is not immediately apparent, and should limit these names to no more than 255 characters in length.",
      "ja": "この仕様は、相互運用性のために必要なものを超えたREG-名の構文を制限するものではありませんので、特定の登録名ルックアップ技術を強制していません。代わりに、URI解決を実行する各アプリケーション、およびそのオペレーティングシステムのオペレーティングシステムに登録した名前の構文への準拠の委譲問題は、それがホスト識別の目的のためにできるようになるかを決定します。 URI解決実装は、登録された名前の検索にDNS、ホストテーブル、イエローページ、NetInfoの、WINS、または他のシステムを使用する場合があります。しかし、世界的なDNS完全修飾ドメイン名などのシステムを、命名スコープ、グローバルスコープを持つように意図されたURIのために必要です。 URIプロデューサーは、DNSの使用はすぐに明らかではない、そして、長さが255文字以内にこれらの名前を制限しなければならない場合でも、DNS構文に準拠名を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The reg-name syntax allows percent-encoded octets in order to represent non-ASCII registered names in a uniform way that is independent of the underlying name resolution technology. Non-ASCII characters must first be encoded according to UTF-8 [STD63], and then each octet of the corresponding UTF-8 sequence must be percent-encoded to be represented as URI characters. URI producing applications must not use percent-encoding in host unless it is used to represent a UTF-8 character sequence. When a non-ASCII registered name represents an internationalized domain name intended for resolution via the DNS, the name must be transformed to the IDNA encoding [RFC3490] prior to name lookup. URI producers should provide these registered names in the IDNA encoding, rather than a percent-encoding, if they wish to maximize interoperability with legacy URI resolvers.",
      "ja": "REG-名の構文は、基礎となる名前解決技術とは独立した統一的な方法で非ASCII登録名を表現するために、パーセントエンコードオクテットを可能にします。非ASCII文字は、最初のUTF-8 [STD63]に従って符号化されなければならない、そして、対応するUTF-8シーケンスの各オクテットは、パーセントエンコードされたURI文字として表現することでなければなりません。 UTF-8文字列を表すために使用されていない限り、URI生成アプリケーションは、ホストにパーセントエンコーディングを使用しないでください。非ASCII登録名がDNSを介して解決するためのもの国際化ドメイン名を表す場合、名前は、名前検索の前にIDNAエンコーディング[RFC3490]に転換されなければなりません。彼らはレガシーURIリゾルバとの相互運用性を最大化したい場合は、URIの生産者は、IDNAエンコーディングでこれらの登録された名前ではなく、パーセントエンコーディングを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Port",
      "section_title": true,
      "ja": "3.2.3. 港"
    },
    {
      "indent": 3,
      "text": "The port subcomponent of authority is designated by an optional port number in decimal following the host and delimited from it by a single colon (\":\") character.",
      "ja": "権限のポートサブコンポーネントは、ホスト、以下の小数で、オプションのポート番号で指定し、1つのコロン（「：」）で、そこから区切られた文字。"
    },
    {
      "indent": 6,
      "text": "port = *DIGIT",
      "ja": "ポート= * DIGIT"
    },
    {
      "indent": 3,
      "text": "A scheme may define a default port. For example, the \"http\" scheme defines a default port of \"80\", corresponding to its reserved TCP port number. The type of port designated by the port number (e.g., TCP, UDP, SCTP) is defined by the URI scheme. URI producers and normalizers should omit the port component and its \":\" delimiter if port is empty or if its value would be the same as that of the scheme's default.",
      "ja": "スキームは、デフォルトのポートを定義することもできます。例えば、「HTTP」スキームは、予約されたTCPポート番号に対応し、「80」のデフォルトのポートを定義しています。ポート番号（例えば、TCP、UDP、SCTP）によって指定されたポートのタイプは、URIスキームによって定義されます。ポートが空の場合、区切り文字またはその値がスキームのデフォルトのものと同じであるかどう：「」URIプロデューサーと正規化は、ポート・コンポーネントとその省略すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3. Path",
      "section_title": true,
      "ja": "3.3. 道"
    },
    {
      "indent": 3,
      "text": "The path component contains data, usually organized in hierarchical form, that, along with data in the non-hierarchical query component (Section 3.4), serves to identify a resource within the scope of the URI's scheme and naming authority (if any). The path is terminated by the first question mark (\"?\") or number sign (\"#\") character, or by the end of the URI.",
      "ja": "パス成分は非階層クエリコンポーネント（3.4節）のデータと共に、URIのスキームの範囲と命名権限（存在する場合）内のリソースを識別するのに役立つことが、通常は階層状に編成されたデータを含んでいます。パスは最初の疑問符（「？」）または番号記号（「＃」）文字によって、あるいはURIの終わりで終了します。"
    },
    {
      "indent": 3,
      "text": "If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character. If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\"). In addition, a URI reference (Section 4.1) may be a relative-path reference, in which case the first path segment cannot contain a colon (\":\") character. The ABNF requires five separate rules to disambiguate these cases, only one of which will match the path substring within a given URI reference. We use the generic term \"path component\" to describe the URI substring matched by the parser to one of these rules.",
      "ja": "URIが権威コンポーネントが含まれている場合は、そのパスコンポーネントが空であるか、スラッシュ（「/」）文字で始める必要があります。 URIが権威コンポーネントが含まれていない場合、パスは2つのスラッシュ文字（「//」）で始めることはできません。また、URI参照（セクション4.1）（「：」）最初のパスセグメントはコロンを含むことができない場合には、相対パスの基準とすることができる文字。 ABNFは、所与のURI参照内のサブストリングのパスと一致する唯一の一つはこれらのケースを、明確にするために5つの別々のルールを必要とします。我々は、これらのルールのいずれかにパーサにマッチしたURIの部分文字列を記述するために一般的な用語「パスコンポーネント」を使用します。"
    },
    {
      "indent": 6,
      "text": "path = path-abempty ; begins with \"/\" or is empty / path-absolute ; begins with \"/\" but not \"//\" / path-noscheme ; begins with a non-colon segment / path-rootless ; begins with a segment / path-empty ; zero characters",
      "ja": "パス=パスabempty。 「/」で始まるまたは空/パス絶対あります。 「/」ではなく「//」/パスnoschemeで始まります。非結腸セグメント/パスルートレスで始まります。セグメント/パス空始まります。ゼロの文字"
    },
    {
      "indent": 6,
      "text": "path-abempty = *( \"/\" segment ) path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ] path-noscheme = segment-nz-nc *( \"/\" segment ) path-rootless = segment-nz *( \"/\" segment ) path-empty = 0<pchar> segment = *pchar segment-nz = 1*pchar segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" ) ; non-zero-length segment without any colon \":\"",
      "ja": "パスabempty = *（ \"/\" セグメント）パス絶対= \"/\" [セグメントNZ *（ \"/\" セグメント）]パスnoscheme =セグメント-NZ-NC×（ \"/\" セグメント）パスルートレス=セグメントNZ *（ \"/\" セグメント）パス空= 0 <PChar型>セグメント= * PChar型セグメント-NZ = 1 * PChar型セグメント-NZ-NC = 1 *（未予約/ PCTエンコード/サブdelims /「@ \"）;任意結腸ことなく、非ゼロ長セグメント「：」"
    },
    {
      "indent": 6,
      "text": "pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"",
      "ja": "PChar型=予約されていない/ PCT-エンコード/サブdelims / \"：\" / \"@\""
    },
    {
      "indent": 3,
      "text": "A path consists of a sequence of path segments separated by a slash (\"/\") character. A path is always defined for a URI, though the defined path may be empty (zero length). Use of the slash character to indicate hierarchy is only required when a URI will be used as the context for relative references. For example, the URI <mailto:fred@example.com> has a path of \"fred@example.com\", whereas the URI <foo://info.example.com?fred> has an empty path.",
      "ja": "パスは、スラッシュ（「/」）文字で区切られたパスセグメントの配列からなります。定義されたパスが空（ゼロ長さ）であってもよいけれども経路は常に、URIのために定義されています。 URIは相対参照のコンテキストとして使用されるとき、階層を示すために、スラッシュ文字の使用にのみ必要です。例えば、URIは：<？：//info.example.comフレッドはFOO>空のパスを有する<MAILTO fred@example.com> URIに対し、 \"fred@example.com\" の経路を有します。"
    },
    {
      "indent": 3,
      "text": "The path segments \".\" and \"..\", also known as dot-segments, are defined for relative reference within the path name hierarchy. They are intended for use at the beginning of a relative-path reference (Section 4.2) to indicate relative position within the hierarchical tree of names. This is similar to their role within some operating systems' file directory structures to indicate the current directory and parent directory, respectively. However, unlike in a file system, these dot-segments are only interpreted within the URI path hierarchy and are removed as part of the resolution process (Section 5.2).",
      "ja": "パスセグメント「」そして「..」、また、ドットセグメントとして知られている、パス名階層内の相対的な参照のために定義されています。これらは、名前の階層ツリー内の相対位置を示すために、相対パス参照（セクション4.2）の開始時に使用するために意図されています。これは、それぞれ、現在のディレクトリと親ディレクトリを示すために、いくつかのオペレーティングシステムのファイル・ディレクトリ構造内での役割に似ています。しかし、ファイルシステムとは異なり、これらのドットセグメントは、URIパス階層内で解釈され、解決プロセス（セクション5.2）の一部として除去されます。"
    },
    {
      "indent": 3,
      "text": "Aside from dot-segments in hierarchical paths, a path segment is considered opaque by the generic syntax. URI producing applications often use the reserved characters allowed in a segment to delimit scheme-specific or dereference-handler-specific subcomponents. For example, the semicolon (\";\") and equals (\"=\") reserved characters are often used to delimit parameters and parameter values applicable to that segment. The comma (\",\") reserved character is often used for similar purposes. For example, one URI producer might use a segment such as \"name;v=1.1\" to indicate a reference to version 1.1 of \"name\", whereas another might use a segment such as \"name,1.1\" to indicate the same. Parameter types may be defined by scheme-specific semantics, but in most cases the syntax of a parameter is specific to the implementation of the URI's dereferencing algorithm.",
      "ja": "別に階層パスでドットセグメントから、パスセグメントは、一般的な構文によって不透明であると考えられます。 URI生成アプリケーションは、多くの場合、スキーム固有または間接参照・ハンドラ固有のサブコンポーネントを区切るためにセグメント内で使用できる予約文字を使用します。例えば、セミコロン（「;」）および等号（「=」）予約文字は、多くの場合、そのセグメントに適用可能なパラメータとパラメータ値を区切るために使用されます。カンマ（「」）予約文字は、多くの場合、同様の目的のために使用されています。別の同一のを示すために、このような「名前、1.1」としてセグメントを使用する場合があり、一方、「名前」のバージョン1.1への参照を示すために、「V = 1.1名」例えば、一つのURIプロデューサーのようなセグメントを使用するかもしれません。パラメータタイプは、スキーム固有の意味によって定義することができるが、ほとんどの場合、パラメータの構文は、URIの逆参照アルゴリズムの実装に固有のものです。"
    },
    {
      "indent": 0,
      "text": "3.4. Query",
      "section_title": true,
      "ja": "3.4. 質問"
    },
    {
      "indent": 3,
      "text": "The query component contains non-hierarchical data that, along with data in the path component (Section 3.3), serves to identify a resource within the scope of the URI's scheme and naming authority (if any). The query component is indicated by the first question mark (\"?\") character and terminated by a number sign (\"#\") character or by the end of the URI.",
      "ja": "クエリコンポーネントは、パスコンポーネント（3.3節）のデータと共に、URIのスキームの範囲と命名権限（存在する場合）内のリソースを識別するのに役立つ、非階層データを含みます。クエリコンポーネントは、最初の疑問符（「？」）文字と番号記号（「＃」）で終了する文字によって、あるいはURIの終わりによって示されています。"
    },
    {
      "indent": 6,
      "text": "query = *( pchar / \"/\" / \"?\" )",
      "ja": "クエリ= *（PChar型/ \"/\" / \"？\"）"
    },
    {
      "indent": 3,
      "text": "The characters slash (\"/\") and question mark (\"?\") may represent data within the query component. Beware that some older, erroneous implementations may not handle such data correctly when it is used as the base URI for relative references (Section 5.1), apparently because they fail to distinguish query data from path data when looking for hierarchical separators. However, as query components are often used to carry identifying information in the form of \"key=value\" pairs and one frequently used value is a reference to another URI, it is sometimes better for usability to avoid percent-encoding those characters.",
      "ja": "文字は、クエリコンポーネント内のデータを表すことができる（「/」）と疑問符（「？」）スラッシュ。階層区切りを探しているとき、彼らはパスデータからクエリデータを区別するために失敗し明らかにするので、それは相対参照（5.1節）のためのベースURIとして使用されている場合、一部の古い、誤った実装が正しく、このようなデータを処理できませんので注意してください。クエリコンポーネントは、しばしば、「キー=値」のペアと一つ頻繁に使用される値の形で識別情報を搬送するために使用されるが、他のURIへの参照は、使い勝手がパーセントをコードするそれらの文字を回避することが時々良好です。"
    },
    {
      "indent": 0,
      "text": "3.5. Fragment",
      "section_title": true,
      "ja": "3.5. 断片"
    },
    {
      "indent": 3,
      "text": "The fragment identifier component of a URI allows indirect identification of a secondary resource by reference to a primary resource and additional identifying information. The identified secondary resource may be some portion or subset of the primary resource, some view on representations of the primary resource, or some other resource defined or described by those representations. A fragment identifier component is indicated by the presence of a number sign (\"#\") character and terminated by the end of the URI.",
      "ja": "URIのフラグメント識別子コンポーネントは、一次リソースと追加の識別情報を参照することにより、二次リソースの間接的な同定を可能にします。同定された二次リソースは、一次リソースの一部またはサブセット、プライマリ・リソース、またはそれらの表現によって定義又は説明されるいくつかの他のリソースの表現にいくつかのビューであってもよいです。フラグメント識別子コンポーネントは、番号記号（「＃」）文字の存在によって示され、URIの終わりで終了します。"
    },
    {
      "indent": 6,
      "text": "fragment = *( pchar / \"/\" / \"?\" )",
      "ja": "フラグメント= *（PChar型/ \"/\" / \"？\"）"
    },
    {
      "indent": 3,
      "text": "The semantics of a fragment identifier are defined by the set of representations that might result from a retrieval action on the primary resource. The fragment's format and resolution is therefore dependent on the media type [RFC2046] of a potentially retrieved representation, even though such a retrieval is only performed if the URI is dereferenced. If no such representation exists, then the semantics of the fragment are considered unknown and are effectively unconstrained. Fragment identifier semantics are independent of the URI scheme and thus cannot be redefined by scheme specifications.",
      "ja": "フラグメント識別子の意味は、プライマリリソース上の検索行動から生じるかもしれない表現の集合によって定義されます。断片のフォーマットと解像度がURIが逆参照されている場合、このような検索のみを行っても、従って潜在的に検索表現のメディアタイプ[RFC2046]に依存します。そのような表現が存在しない場合は、フラグメントの意味は不明であると考えられ、効果的に拘束されていないされています。フラグメント識別子の意味は、URIスキームとは無関係であるため、スキームの仕様によって再定義することはできません。"
    },
    {
      "indent": 3,
      "text": "Individual media types may define their own restrictions on or structures within the fragment identifier syntax for specifying different types of subsets, views, or external references that are identifiable as secondary resources by that media type. If the primary resource has multiple representations, as is often the case for resources whose representation is selected based on attributes of the retrieval request (a.k.a., content negotiation), then whatever is identified by the fragment should be consistent across all of those representations. Each representation should either define the fragment so that it corresponds to the same secondary resource, regardless of how it is represented, or should leave the fragment undefined (i.e., not found).",
      "ja": "個々のメディアタイプは、サブセット、ビュー、またはそのメディアタイプによる二次リソースとして識別されている外部参照の異なるタイプを指定するフラグメント識別子構文内に又は構造独自の制限を定義することができます。しばしば表現検索要求（別名、コンテンツネゴシエーション）の属性に基づいて選択されたリソースの場合のように、一次リソースは、複数の表現を持っている場合、断片によって識別されているものは、それらの表現のすべてにわたって一貫しているべきです。各表現は、同じ二次リソースに対応するようにかかわらず、それが表現される方法の、断片を定義すべきか、未定義の断片を残すべきである（すなわち、見出されていません）。"
    },
    {
      "indent": 3,
      "text": "As with any URI, use of a fragment identifier component does not imply that a retrieval action will take place. A URI with a fragment identifier may be used to refer to the secondary resource without any implication that the primary resource is accessible or will ever be accessed.",
      "ja": "任意のURIと同様に、フラグメント識別子コンポーネントの使用は、検索動作が行われることを意味するものではありません。フラグメント識別子を持つURIは、一次リソースがアクセス可能であるか、これまでアクセスされる任意の含意することなく、二次リソースを参照するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Fragment identifiers have a special role in information retrieval systems as the primary form of client-side indirect referencing, allowing an author to specifically identify aspects of an existing resource that are only indirectly provided by the resource owner. As such, the fragment identifier is not used in the scheme-specific processing of a URI; instead, the fragment identifier is separated from the rest of the URI prior to a dereference, and thus the identifying information within the fragment itself is dereferenced solely by the user agent, regardless of the URI scheme. Although this separate handling is often perceived to be a loss of information, particularly for accurate redirection of references as resources move over time, it also serves to prevent information providers from denying reference authors the right to refer to information within a resource selectively. Indirect referencing also provides additional flexibility and extensibility to systems that use URIs, as new media types are easier to define and deploy than new schemes of identification.",
      "ja": "フラグメント識別子は、具体的には間接的にのみ、リソース所有者によって提供される既存のリソースの側面を識別するために著者を可能にする、クライアント側の間接参照の主要形態としての情報検索システムにおいて特別な役割を有します。このように、フラグメント識別子はURIのスキーマ固有の処理には使用されません。代わりに、フラグメント識別子が参照解除に先立っURIの残りの部分から分離され、したがって、断片自体の中の識別情報に関わらず、URIスキームの、ユーザエージェントによってのみ参照解除されます。この別個の取り扱いは、しばしばリソースが時間の経過と共に移動するように特に参考文献の正確なリダイレクションのため、情報の損失であると知覚されるが、それはまた、参照作者を選択リソース内の情報を参照する権利を否定するから情報提供を防止するのに役立ちます。間接参照は、新しいメディアタイプを定義し、識別の新しい方式よりも展開が容易であるように、URIを使用するシステムに追加の柔軟性と拡張性を提供します。"
    },
    {
      "indent": 3,
      "text": "The characters slash (\"/\") and question mark (\"?\") are allowed to represent data within the fragment identifier. Beware that some older, erroneous implementations may not handle this data correctly when it is used as the base URI for relative references (Section 5.1).",
      "ja": "文字はスラッシュ（「/」）と疑問符（「は？」）フラグメント識別子内のデータを表現するために許可されています。それは相対参照（5.1節）のためのベースURIとして使用されている場合、一部の古い、誤った実装がこのデータを正しく処理できませんので注意してください。"
    },
    {
      "indent": 0,
      "text": "4. Usage",
      "section_title": true,
      "ja": "4.使用方法"
    },
    {
      "indent": 3,
      "text": "When applications make reference to a URI, they do not always use the full form of reference defined by the \"URI\" syntax rule. To save space and take advantage of hierarchical locality, many Internet protocol elements and media type formats allow an abbreviation of a URI, whereas others restrict the syntax to a particular form of URI. We define the most common forms of reference syntax in this specification because they impact and depend upon the design of the generic syntax, requiring a uniform parsing algorithm in order to be interpreted consistently.",
      "ja": "アプリケーションはURIへの参照を作成するとき、彼らは常に「URI」構文規則によって定義される基準の完全なフォームを使用しないでください。他の人がURIの特定の形式に構文を制限する一方で、スペースを節約し、階層的局所性を利用するには、多くのインターネットプロトコル要素とメディアタイプのフォーマットは、URIの略語を可能にします。それらは衝撃と一貫して解釈されるために、均一な解析アルゴリズムを必要とする、一般的な構文の設計に依存するので、我々は、本明細書に参照構文の最も一般的な形態を定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. URI Reference",
      "section_title": true,
      "ja": "4.1.  URIリファレンス"
    },
    {
      "indent": 3,
      "text": "URI-reference is used to denote the most common usage of a resource identifier.",
      "ja": "URI参照は、リソース識別子の最も一般的な使用法を示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "URI-reference = URI / relative-ref",
      "ja": "URIリファレンス= URI /相対-REF"
    },
    {
      "indent": 3,
      "text": "A URI-reference is either a URI or a relative reference. If the URI-reference's prefix does not match the syntax of a scheme followed by its colon separator, then the URI-reference is a relative reference.",
      "ja": "URI参照は、URIまたは相対参照のいずれかです。 URI参照の接頭辞は、そのコロンセパレータに続くスキームの構文と一致しない場合は、URI参照が相対参照です。"
    },
    {
      "indent": 3,
      "text": "A URI-reference is typically parsed first into the five URI components, in order to determine what components are present and whether the reference is relative. Then, each component is parsed for its subparts and their validation. The ABNF of URI-reference, along with the \"first-match-wins\" disambiguation rule, is sufficient to define a validating parser for the generic syntax. Readers familiar with regular expressions should see Appendix B for an example of a non-validating URI-reference parser that will take any given string and extract the URI components.",
      "ja": "URI参照は、典型的には、本基準は相対的であるかどうかであるかの成分を決定するために、5つのURI成分に最初に解析されます。次いで、各成分は、そのサブパーツとその検証のために解析されます。 URI参照のABNFは、「第一試合、勝ち」曖昧さ回避ルールと一緒に、一般的な構文について検証パーサーを定義するのに十分です。正規表現に精通している読者は、任意の文字列を取り、URI成分を抽出する非検証URI参照パーサの例については、付録Bを参照すべきです。"
    },
    {
      "indent": 0,
      "text": "4.2. Relative Reference",
      "section_title": true,
      "ja": "4.2. 相対参照"
    },
    {
      "indent": 3,
      "text": "A relative reference takes advantage of the hierarchical syntax (Section 1.2.3) to express a URI reference relative to the name space of another hierarchical URI.",
      "ja": "相対参照は、別の階層URIの名前空間へのURI参照を相対的に表現するために、階層構文（セクション1.2.3）を利用します。"
    },
    {
      "indent": 6,
      "text": "relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "相対-REF =相対パート[ \"？\"クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 6,
      "text": "relative-part = \"//\" authority path-abempty / path-absolute / path-noscheme / path-empty",
      "ja": "相対一部=「//」権限パスabempty /パス絶対/パスnoscheme /パス空"
    },
    {
      "indent": 3,
      "text": "The URI referred to by a relative reference, also known as the target URI, is obtained by applying the reference resolution algorithm of Section 5.",
      "ja": "URIは、ターゲットURIとしても知られている相対参照によって参照される、第5の基準解像度アルゴリズムを適用することによって得られます。"
    },
    {
      "indent": 3,
      "text": "A relative reference that begins with two slash characters is termed a network-path reference; such references are rarely used. A relative reference that begins with a single slash character is termed an absolute-path reference. A relative reference that does not begin with a slash character is termed a relative-path reference.",
      "ja": "2つのスラッシュ文字で始まる相対参照は、ネットワークパス参照と呼ばれます。このような参照はめったに使用されています。単一のスラッシュ文字で始まる相対参照は、絶対パス参照と呼ばれます。スラッシュ文字で始まらない相対参照は、相対パス参照と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "A path segment that contains a colon character (e.g., \"this:that\") cannot be used as the first segment of a relative-path reference, as it would be mistaken for a scheme name. Such a segment must be preceded by a dot-segment (e.g., \"./this:that\") to make a relative-path reference.",
      "ja": "コロン文字を含むパスセグメントが：それはスキーム名と間違えであるように（例えば、「このこと」）、相対パス参照の最初のセグメントとして使用することができません。そのようなセグメントは、相対パス参照を作るためにドットセグメント（例えば、「./this:that」）が先行されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. Absolute URI",
      "section_title": true,
      "ja": "4.3. 絶対URI"
    },
    {
      "indent": 3,
      "text": "Some protocol elements allow only the absolute form of a URI without a fragment identifier. For example, defining a base URI for later use by relative references calls for an absolute-URI syntax rule that does not allow a fragment.",
      "ja": "いくつかのプロトコル要素は、フラグメント識別子なしURIの唯一の絶対的形態を可能にします。例えば、相対参照によって後で使用するためにベースURIを定義するフラグメントを許可しない絶対URIの構文規則を要求します。"
    },
    {
      "indent": 6,
      "text": "absolute-URI = scheme \":\" hier-part [ \"?\" query ]",
      "ja": "絶対URIスキーム= \"：\" \"？\" のhierパート[クエリ]"
    },
    {
      "indent": 3,
      "text": "URI scheme specifications must define their own syntax so that all strings matching their scheme-specific syntax will also match the <absolute-URI> grammar. Scheme specifications will not define fragment identifier syntax or usage, regardless of its applicability to resources identifiable via that scheme, as fragment identification is orthogonal to scheme definition. However, scheme specifications are encouraged to include a wide range of examples, including examples that show use of the scheme's URIs with fragment identifiers when such usage is appropriate.",
      "ja": "そのスキーム固有の構文に一致するすべての文字列でも、<絶対URI>の文法にマッチするようにURIスキームの仕様は独自の構文を定義する必要があります。断片識別スキームの定義に直交するようにスキーム仕様は、そのスキームを介して識別可能なリソースにかかわらず適用可能な、フラグメント識別子構文または使用法を定義しないであろう。しかし、スキーム仕様は、そのような使用が適切である場合、フラグメント識別子を持つスキームのURIの使用を示す例を含む実施例の広い範囲を含むように奨励されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Same-Document Reference",
      "section_title": true,
      "ja": "4.4. 同じドキュメントの参照"
    },
    {
      "indent": 3,
      "text": "When a URI reference refers to a URI that is, aside from its fragment component (if any), identical to the base URI (Section 5.1), that reference is called a \"same-document\" reference. The most frequent examples of same-document references are relative references that are empty or include only the number sign (\"#\") separator followed by a fragment identifier.",
      "ja": "URI参照は、（もしあれば）、そのフラグメントコンポーネントとは別に、あるURIを参照する場合、ベースURI（セクション5.1）と同じで、その基準は、「同一文書」基準と呼ばれています。同じ文書参照の最も頻繁な例は、空であるか、フラグメント識別子に続くだけナンバー記号（「＃」）セパレータを含む相対参照です。"
    },
    {
      "indent": 3,
      "text": "When a same-document reference is dereferenced for a retrieval action, the target of that reference is defined to be within the same entity (representation, document, or message) as the reference; therefore, a dereference should not result in a new retrieval action.",
      "ja": "同じ文書参照が検索動作のために逆参照されると、その基準の対象を基準として同じエンティティ（表現、文書、またはメッセージ）の範囲内であると定義されます。そのため、間接参照は、新たな検索行動につながるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Normalization of the base and target URIs prior to their comparison, as described in Sections 6.2.2 and 6.2.3, is allowed but rarely performed in practice. Normalization may increase the set of same-document references, which may be of benefit to some caching applications. As such, reference authors should not assume that a slightly different, though equivalent, reference URI will (or will not) be interpreted as a same-document reference by any given application.",
      "ja": "ベースとターゲットURIの正規化は、以前の彼らの比較に、セクション6.2.2および6.2.3で説明したように、許可されますが、実際にはほとんど行われません。正規化は、いくつかのキャッシングアプリケーションに有益であり得る同じ文書参照の集合を増大させることができます。このように、基準著者は同等しかし、わずかに異なる、参照URI（またはしない）任意のアプリケーションによって同じ文書参照として解釈されることを前提としてはなりません。"
    },
    {
      "indent": 0,
      "text": "4.5. Suffix Reference",
      "section_title": true,
      "ja": "4.5. サフィックスリファレンス"
    },
    {
      "indent": 3,
      "text": "The URI syntax is designed for unambiguous reference to resources and extensibility via the URI scheme. However, as URI identification and usage have become commonplace, traditional media (television, radio, newspapers, billboards, etc.) have increasingly used a suffix of the",
      "ja": "URIの構文は、URIスキームを介したリソースと拡張性への明確な参照のために設計されています。 URIの識別と使用が一般的になってきたようしかし、従来のメディア（テレビ、ラジオ、新聞、看板等）は、ますますの接尾辞を使用しています"
    },
    {
      "indent": 3,
      "text": "URI as a reference, consisting of only the authority and path portions of the URI, such as",
      "ja": "ようなURIの唯一の権限とパス部分から成る参照としてURI、"
    },
    {
      "indent": 6,
      "text": "www.w3.org/Addressing/",
      "ja": "ｗっｗ。ｗ３。おｒｇ／あっｄれっしんｇ／"
    },
    {
      "indent": 3,
      "text": "or simply a DNS registered name on its own. Such references are primarily intended for human interpretation rather than for machines, with the assumption that context-based heuristics are sufficient to complete the URI (e.g., most registered names beginning with \"www\" are likely to have a URI prefix of \"http://\"). Although there is no standard set of heuristics for disambiguating a URI suffix, many client implementations allow them to be entered by the user and heuristically resolved.",
      "ja": "または単にDNSが独自に名前を登録しました。このような参照は、主にそのコンテキストベースのヒューリスティックは、URI（例を完了するのに十分であるという仮定で、人間の解釈のためではなく、マシンのために意図されている、「WWW」で始まるほとんどの登録名は、http「のURI接頭辞を持っている可能性があり：/ / \"）。 URIサフィックスを一義化のためのヒューリスティクスのない標準セットはありませんが、多くのクライアントの実装では、彼らは、ユーザーが入力したと発見的に解決することができます。"
    },
    {
      "indent": 3,
      "text": "Although this practice of using suffix references is common, it should be avoided whenever possible and should never be used in situations where long-term references are expected. The heuristics noted above will change over time, particularly when a new URI scheme becomes popular, and are often incorrect when used out of context. Furthermore, they can lead to security issues along the lines of those described in [RFC1535].",
      "ja": "サフィックスの参照を使用してのこのような行為が一般的ですが、それは可能な限り避けるべきであるとの長期的な参照が期待されている状況で使用すべきではありません。上記の経験則では、新たなURIスキームが人気となり、特にとき、時間の経過とともに変化し、コンテキストの外に使用されたとき、多くの場合、間違っています。さらに、それらは、[RFC1535]に記載されているものの線に沿ってセキュリティ上の問題につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "As a URI suffix has the same syntax as a relative-path reference, a suffix reference cannot be used in contexts where a relative reference is expected. As a result, suffix references are limited to places where there is no defined base URI, such as dialog boxes and off-line advertisements.",
      "ja": "URIサフィックスが相対パス参照と同じ構文を持つように、接尾語参照が相対参照が期待される状況で使用することができません。その結果、サフィックスの参照は、ダイアログボックスやオフライン広告など一切定義されたベースURIが存在しない場所に制限されています。"
    },
    {
      "indent": 0,
      "text": "5. Reference Resolution",
      "section_title": true,
      "ja": "5.参照の解決"
    },
    {
      "indent": 3,
      "text": "This section defines the process of resolving a URI reference within a context that allows relative references so that the result is a string matching the <URI> syntax rule of Section 3.",
      "ja": "このセクションでは、結果は、第3の<URI>構文規則に合致する文字列があるように相対参照を可能にするコンテキスト内のURI参照を解決するプロセスを定義します。"
    },
    {
      "indent": 0,
      "text": "5.1. Establishing a Base URI",
      "section_title": true,
      "ja": "5.1. ベースURIを確立"
    },
    {
      "indent": 3,
      "text": "The term \"relative\" implies that a \"base URI\" exists against which the relative reference is applied. Aside from fragment-only references (Section 4.4), relative references are only usable when a base URI is known. A base URI must be established by the parser prior to parsing URI references that might be relative. A base URI must conform to the <absolute-URI> syntax rule (Section 4.3). If the base URI is obtained from a URI reference, then that reference must be converted to absolute form and stripped of any fragment component prior to its use as a base URI.",
      "ja": "「相対的」という用語は、「ベースURIは」相対的基準が適用され、それに対して存在することを意味します。脇フラグメント参照のみから（セクション4.4）、相対参照は、ベースURIが既知である場合にのみ使用可能です。ベースURIは、相対かもしれないURI参照を解析する前に、パーサーによって確立されなければなりません。ベースURIは<絶対URI>構文規則（セクション4.3）に適合しなければなりません。ベースURIは、URI参照から得られる場合、その参照は絶対形式に変換され、前にベースURIとしてのその使用に任意のフラグメント成分からストリッピングされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The base URI of a reference can be established in one of four ways, discussed below in order of precedence. The order of precedence can be thought of in terms of layers, where the innermost defined base URI has the highest precedence. This can be visualized graphically as follows:",
      "ja": "参照のベースURIは、優先順位の順に以下に説明する4つの方法で確立することができます。優先順位は、最も内側の定義されたベースURIは、最も高い優先順位を有する場合、層の観点で考えることができます。これは次のようにグラフィカルに可視化することができます。"
    },
    {
      "indent": 9,
      "text": ".----------------------------------------------------------.\n|  .----------------------------------------------------.  |\n|  |  .----------------------------------------------.  |  |\n|  |  |  .----------------------------------------.  |  |  |\n|  |  |  |  .----------------------------------.  |  |  |  |\n|  |  |  |  |       <relative-reference>       |  |  |  |  |\n|  |  |  |  `----------------------------------'  |  |  |  |\n|  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |\n|  |  |  `----------------------------------------'  |  |  |\n|  |  | (5.1.2) Base URI of the encapsulating entity |  |  |\n|  |  |         (message, representation, or none)   |  |  |\n|  |  `----------------------------------------------'  |  |\n|  | (5.1.3) URI used to retrieve the entity            |  |\n|  `----------------------------------------------------'  |\n| (5.1.4) Default Base URI (application-dependent)         |\n`----------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.1.1. Base URI Embedded in Content",
      "section_title": true,
      "ja": "5.1.1. コンテンツに埋め込まれたベースURI"
    },
    {
      "indent": 3,
      "text": "Within certain media types, a base URI for relative references can be embedded within the content itself so that it can be readily obtained by a parser. This can be useful for descriptive documents, such as tables of contents, which may be transmitted to others through protocols other than their usual retrieval context (e.g., email or USENET news).",
      "ja": "それは容易にパーサによって得ることができるように、特定のメディアタイプ内で、相対参照のベースURIは、コンテンツ自体の中に埋め込むことができます。これは、それらの通常の検索のコンテキスト（例えば、電子メールまたはUSENETニュース）以外のプロトコルを介して他人に送信することができるコンテンツのテーブル、として記述文書に有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this specification to specify how, for each media type, a base URI can be embedded. The appropriate syntax, when available, is described by the data format specification associated with each media type.",
      "ja": "これは、各メディアタイプに対して、どのURIを埋め込むことができるベースを指定するには、この明細書の範囲外です。適切な構文は、利用可能な場合、各メディアタイプに関連付けられたデータフォーマット仕様によって記述されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Base URI from the Encapsulating Entity",
      "section_title": true,
      "ja": "5.1.2. カプセル化エンティティからベースURI"
    },
    {
      "indent": 3,
      "text": "If no base URI is embedded, the base URI is defined by the representation's retrieval context. For a document that is enclosed within another entity, such as a message or archive, the retrieval context is that entity. Thus, the default base URI of a representation is the base URI of the entity in which the representation is encapsulated.",
      "ja": "何ベースURIが埋め込まれていない場合、ベースURIは、表現の検索コンテキストによって定義されます。このようなメッセージやアーカイブとして、別のエンティティ内に封入されている文書に対して、検索コンテキストは、エンティティです。したがって、表現のデフォルトのベースURIは、表現がカプセル化されたエンティティのベースURIです。"
    },
    {
      "indent": 3,
      "text": "A mechanism for embedding a base URI within MIME container types (e.g., the message and multipart types) is defined by MHTML [RFC2557]. Protocols that do not use the MIME message header syntax, but that do allow some form of tagged metadata to be included within messages, may define their own syntax for defining a base URI as part of a message.",
      "ja": "MIMEコンテナタイプ内のベースURIを埋め込むための機構（例えば、メッセージとマルチパートタイプ）はMHTML [RFC2557]で定義されます。 MIMEメッセージヘッダ構文を使用していないが、それはタグ付けされたメタデータのいくつかの形態がメッセージ内に含まれることを可能にするかのプロトコルは、メッセージの一部としてベースURIを定義するための独自の構文を定義することができます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Base URI from the Retrieval URI",
      "section_title": true,
      "ja": "5.1.3. 検索URIからベースURI"
    },
    {
      "indent": 3,
      "text": "If no base URI is embedded and the representation is not encapsulated within some other entity, then, if a URI was used to retrieve the representation, that URI shall be considered the base URI. Note that if the retrieval was the result of a redirected request, the last URI used (i.e., the URI that resulted in the actual retrieval of the representation) is the base URI.",
      "ja": "何ベースURIが埋め込まれていないと表現が他のエンティティ内にカプセル化されていない場合は、次に、もしURIがURIをベースURI考慮しなければならないことを、表現を取得するために使用しました。検索がリダイレクトされた要求の結果であった場合、最後のURIが（表現の実際の検索をもたらし、すなわち、URI）は、ベースURIで使用されることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Default Base URI",
      "section_title": true,
      "ja": "5.1.4. デフォルトのベースURI"
    },
    {
      "indent": 3,
      "text": "If none of the conditions described above apply, then the base URI is defined by the context of the application. As this definition is necessarily application-dependent, failing to define a base URI by using one of the other methods may result in the same content being interpreted differently by different types of applications.",
      "ja": "上記の条件のいずれにも該当しない場合は、次にベースURIは、アプリケーションのコンテキストによって定義されます。この定義は必ずしもアプリケーションに依存しているように、同一のコンテンツをもたらすことができる他の方法のいずれかを使用してベースURIを定義するために失敗すると、アプリケーションの異なる種類によって異なって解釈されます。"
    },
    {
      "indent": 3,
      "text": "A sender of a representation containing relative references is responsible for ensuring that a base URI for those references can be established. Aside from fragment-only references, relative references can only be used reliably in situations where the base URI is well defined.",
      "ja": "相対参照を含む表現の送信者は、これらの参照のベースURIを確立することができることを保証する責任があります。脇フラグメント参照のみから、相対参照は、ベースURIが明確に定義されている状況で確実に使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Relative Resolution",
      "section_title": true,
      "ja": "5.2. 相対分解能"
    },
    {
      "indent": 3,
      "text": "This section describes an algorithm for converting a URI reference that might be relative to a given base URI into the parsed components of the reference's target. The components can then be recomposed, as described in Section 5.3, to form the target URI. This algorithm provides definitive results that can be used to test the output of other implementations. Applications may implement relative reference resolution by using some other algorithm, provided that the results match what would be given by this one.",
      "ja": "このセクションでは、参照のターゲットの解析された成分に与えられたベースURIに対して相対かもしれないURI参照を変換するためのアルゴリズムを記載しています。ターゲットURIを形成するために、セクション5.3で説明したようにコンポーネントは次いで、再構成することができます。このアルゴリズムは、他の実装の出力をテストするために使用することができる決定的な結果を提供します。アプリケーションは、いくつかの他のアルゴリズムを用いて、相対基準解像度を実現することができる、結果はこの1つによって与えられるものと一致することを条件とします。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Pre-parse the Base URI",
      "section_title": true,
      "ja": "5.2.1. ベースURIを事前パース"
    },
    {
      "indent": 3,
      "text": "The base URI (Base) is established according to the procedure of Section 5.1 and parsed into the five main components described in Section 3. Note that only the scheme component is required to be present in a base URI; the other components may be empty or undefined. A component is undefined if its associated delimiter does not appear in the URI reference; the path component is never undefined, though it may be empty.",
      "ja": "ベースURI（ベース）は、セクション5.1の手順に従って確立のみスキーム成分がベースURIに存在することが要求される第3のノートに記載の5つの主要コンポーネントに解析されます。他の成分は、空または未定義であってもよいです。その関連デリミタがURI参照に表示されない場合、コンポーネントは未定義です。それが空であるかもしれませんが、パスの構成要素は、決して未定義です。"
    },
    {
      "indent": 3,
      "text": "Normalization of the base URI, as described in Sections 6.2.2 and 6.2.3, is optional. A URI reference must be transformed to its target URI before it can be normalized.",
      "ja": "ベースURIの正規化は、セクション6.2.2および6.2.3に記載したように、任意です。それは正規化することができる前に、URI参照は、そのターゲットURIに変換されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Transform References",
      "section_title": true,
      "ja": "5.2.2. 参考文献を変換"
    },
    {
      "indent": 3,
      "text": "For each URI reference (R), the following pseudocode describes an algorithm for transforming R into its target URI (T):",
      "ja": "各URI参照（R）は、次の擬似コードは、ターゲットURI（T）にRを変換するためのアルゴリズムを説明します。"
    },
    {
      "indent": 6,
      "text": "-- The URI reference is parsed into the five URI components -- (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);",
      "ja": " -  URI参照が5つのURIコンポーネントに解析される - （R.scheme、R.authority、R.path、R.query、R.fragment）=パース（R）。"
    },
    {
      "indent": 6,
      "text": "-- A non-strict parser may ignore a scheme in the reference\n-- if it is identical to the base URI's scheme.\n--\nif ((not strict) and (R.scheme == Base.scheme)) then\n   undefine(R.scheme);\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if defined(R.scheme) then\n   T.scheme    = R.scheme;\n   T.authority = R.authority;\n   T.path      = remove_dot_segments(R.path);\n   T.query     = R.query;\nelse\n   if defined(R.authority) then\n      T.authority = R.authority;\n      T.path      = remove_dot_segments(R.path);\n      T.query     = R.query;\n   else\n      if (R.path == \"\") then\n         T.path = Base.path;\n         if defined(R.query) then\n            T.query = R.query;\n         else\n            T.query = Base.query;\n         endif;\n      else\n         if (R.path starts-with \"/\") then\n            T.path = remove_dot_segments(R.path);\n         else\n            T.path = merge(Base.path, R.path);\n            T.path = remove_dot_segments(T.path);\n         endif;\n         T.query = R.query;\n      endif;\n      T.authority = Base.authority;\n   endif;\n   T.scheme = Base.scheme;\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "T.fragment = R.fragment;",
      "ja": "T.fragment = R.fragment。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Merge Paths",
      "section_title": true,
      "ja": "5.2.3. パスのマージ"
    },
    {
      "indent": 3,
      "text": "The pseudocode above refers to a \"merge\" routine for merging a relative-path reference with the path of the base URI. This is accomplished as follows:",
      "ja": "上記の擬似コードは、ベースURIのパスと相対パス参照をマージするためのルーチンを「マージ」を指します。これは以下のように実現されます。"
    },
    {
      "indent": 3,
      "text": "o If the base URI has a defined authority component and an empty path, then return a string consisting of \"/\" concatenated with the reference's path; otherwise,",
      "ja": "ベースURIは、定義された権限コンポーネントと空のパスを持っている場合、Oは、「/」は、参照のパスと連結からなる文字列を返します。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "o return a string consisting of the reference's path component appended to all but the last segment of the base URI's path (i.e., excluding any characters after the right-most \"/\" in the base URI path, or excluding the entire base URI path if it does not contain any \"/\" characters).",
      "ja": "O（すなわち、場合右端の「/」ベースURIパスにおける後の任意の文字を除いて、全体のベースURIのパスを除く全てが、ベースURIのパスの最後のセグメントに付加基準のパスコンポーネントからなる文字列を返しますそれは）任意の「/」文字が含まれていません。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Remove Dot Segments",
      "section_title": true,
      "ja": "5.2.4. ドットセグメントの削除"
    },
    {
      "indent": 3,
      "text": "The pseudocode also refers to a \"remove_dot_segments\" routine for interpreting and removing the special \".\" and \"..\" complete path segments from a referenced path. This is done after the path is extracted from a reference, whether or not the path was relative, in order to remove any invalid or extraneous dot-segments prior to forming the target URI. Although there are many ways to accomplish this removal process, we describe a simple method using two string buffers.",
      "ja": "擬似コードは、特別な解釈をして除去するため、「remove_dot_segments」ルーチンを指し、「」そして、「..」参照パスからパスセグメントを完了します。パスは、パスの前目標URIを形成する任意の無効または外来ドットセグメントを除去するために、相対的であったか否かを、基準から抽出された後に行われます。この除去プロセスを達成するために多くの方法がありますが、我々は2つの文字列バッファを使用して簡単な方法を説明します。"
    },
    {
      "indent": 3,
      "text": "1. The input buffer is initialized with the now-appended path components and the output buffer is initialized to the empty string.",
      "ja": "1.入力バッファは、現在、添付パス成分で初期化され、出力バッファが空の文字列に初期化されます。"
    },
    {
      "indent": 3,
      "text": "2. While the input buffer is not empty, loop as follows:",
      "section_title": true,
      "ja": "入力バッファが空でないものの2、ループは次のように"
    },
    {
      "indent": 7,
      "text": "A.  If the input buffer begins with a prefix of \"../\" or \"./\",\n    then remove that prefix from the input buffer; otherwise,",
      "raw": true
    },
    {
      "indent": 7,
      "text": "B. if the input buffer begins with a prefix of \"/./\" or \"/.\", where \".\" is a complete path segment, then replace that prefix with \"/\" in the input buffer; otherwise,",
      "ja": "B.入力バッファは、「/./」または接頭辞で始まる場合、「/」、ここで「」完全なパスセグメントであり、次いで、「/」が入力バッファ内でそのプレフィックスを置き換えます。そうでなければ、"
    },
    {
      "indent": 7,
      "text": "C. if the input buffer begins with a prefix of \"/../\" or \"/..\", where \"..\" is a complete path segment, then replace that prefix with \"/\" in the input buffer and remove the last segment and its preceding \"/\" (if any) from the output buffer; otherwise,",
      "ja": "C.は、入力バッファが「/../」または接頭辞で始まる場合、「/ ..」、ここで「は..」は、完全なパスセグメントであり、その後、入力バッファに 『/』で、その接頭辞を交換して取り除きます出力バッファから最後のセグメントとその前の「/」（もしあれば）。そうでなければ、"
    },
    {
      "indent": 7,
      "text": "D. if the input buffer consists only of \".\" or \"..\", then remove that from the input buffer; otherwise,",
      "ja": "D.入力バッファは、のみから構成されている場合は「」または「..」、次に入力バッファからそれを削除します。そうでなければ、"
    },
    {
      "indent": 7,
      "text": "E. move the first path segment in the input buffer to the end of the output buffer, including the initial \"/\" character (if any) and any subsequent characters up to, but not including, the next \"/\" character or the end of the input buffer.",
      "ja": "E.は、最初の「/」文字（もしあれば）およびまでの任意の後続の文字を含む、しかし、次の「/」文字又は端部を含まない、出力バッファの末尾に、入力バッファ内の最初のパスセグメントを移動させます入力バッファ。"
    },
    {
      "indent": 3,
      "text": "3. Finally, the output buffer is returned as the result of remove_dot_segments.",
      "ja": "3.最後に、出力バッファはremove_dot_segmentsの結果として返されます。"
    },
    {
      "indent": 3,
      "text": "Note that dot-segments are intended for use in URI references to express an identifier relative to the hierarchy of names in the base URI. The remove_dot_segments algorithm respects that hierarchy by removing extra dot-segments rather than treat them as an error or leaving them to be misinterpreted by dereference implementations.",
      "ja": "ドットセグメントはベースURIの名前の階層に識別子を相対的に表現するURI参照における使用のために意図されていることに留意されたいです。 remove_dot_segmentsアルゴリズムは、余分なドットセグメントを削除するのではなくエラーとして扱うか、それらを残すことによって、階層をデリファレンス実装によって誤って解釈することを尊重します。"
    },
    {
      "indent": 3,
      "text": "The following illustrates how the above steps are applied for two examples of merged paths, showing the state of the two buffers after each step.",
      "ja": "以下に、上記のステップは、各ステップの後に二つのバッファの状態を示し、マージされた経路の2つの例に適用される様子を示します。"
    },
    {
      "indent": 6,
      "text": "STEP OUTPUT BUFFER INPUT BUFFER",
      "ja": "STEP出力バッファ入力バッファ"
    },
    {
      "indent": 7,
      "text": "1 : /a/b/c/./../../g 2E: /a /b/c/./../../g 2E: /a/b /c/./../../g 2E: /a/b/c /./../../g 2B: /a/b/c /../../g 2C: /a/b /../g 2C: /a /g 2E: /a/g",
      "ja": "1：2Eを/a/b/c/./../../g：/ A / Bの/c/./../：/b/c/./../../g 2E / ../g 2E：/ A / B / C /./../../g 2B：/ A / B / C /../../g 2C：/ A / B /../g 2C ：/ A / G 2E：/ A / G"
    },
    {
      "indent": 6,
      "text": "STEP OUTPUT BUFFER INPUT BUFFER",
      "ja": "STEP出力バッファ入力バッファ"
    },
    {
      "indent": 7,
      "text": "1 : mid/content=5/../6 2E: mid /content=5/../6 2E: mid/content=5 /../6 2C: mid /6 2E: mid/6",
      "ja": "1：ミッド/内容= 5 /../ 6 2E：中間/content=5/../6 2E：ミッド/内容= 5 /../6 2C：ミッド/ 6 2E：ミッド/ 6"
    },
    {
      "indent": 3,
      "text": "Some applications may find it more efficient to implement the remove_dot_segments algorithm by using two segment stacks rather than strings.",
      "ja": "一部のアプリケーションは、より効率的な2つのセグメントスタックではなく、文字列を使用してremove_dot_segmentsアルゴリズムを実装するかもしれません。"
    },
    {
      "indent": 6,
      "text": "Note: Beware that some older, erroneous implementations will fail to separate a reference's query component from its path component prior to merging the base and reference paths, resulting in an interoperability failure if the query component contains the strings \"/../\" or \"/./\".",
      "ja": "「古い、誤実装前のクエリコンポーネントが文字列が含まれている場合、相互運用性の障害の原因となる、ベース及び基準経路を併合へのパスコンポーネントから参照のクエリコンポーネントを分離するために失敗することに注意してください「/../」又は注： /./」。"
    },
    {
      "indent": 0,
      "text": "5.3. Component Recomposition",
      "section_title": true,
      "ja": "5.3. コンポーネントのリダイヤル"
    },
    {
      "indent": 3,
      "text": "Parsed URI components can be recomposed to obtain the corresponding URI reference string. Using pseudocode, this would be:",
      "ja": "解析されたURIコンポーネントは、対応するURI参照文字列を取得するように再構成することができます。擬似コードを使用して、これは次のようになります。"
    },
    {
      "indent": 6,
      "text": "result = \"\"",
      "ja": "結果=「」"
    },
    {
      "indent": 6,
      "text": "if defined(scheme) then\n   append scheme to result;\n   append \":\" to result;\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if defined(authority) then\n   append \"//\" to result;\n   append authority to result;\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "append path to result;",
      "ja": "もたらすためにパスを追加。"
    },
    {
      "indent": 6,
      "text": "if defined(query) then\n   append \"?\" to result;\n   append query to result;\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if defined(fragment) then\n   append \"#\" to result;\n   append fragment to result;\nendif;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "return result;",
      "ja": "結果を返します。"
    },
    {
      "indent": 3,
      "text": "Note that we are careful to preserve the distinction between a component that is undefined, meaning that its separator was not present in the reference, and a component that is empty, meaning that the separator was present and was immediately followed by the next component separator or the end of the reference.",
      "ja": "我々は、そのセパレータは、参照中に存在しなかったことを意味し、未定義である成分及びセパレータが存在し、直ちに次の成分分離を行った、またはつまり、空であるコンポーネント間の区別を維持するように注意していることに注意してください参照の終わり。"
    },
    {
      "indent": 0,
      "text": "5.4. Reference Resolution Examples",
      "section_title": true,
      "ja": "5.4. 参照解決例"
    },
    {
      "indent": 3,
      "text": "Within a representation with a well defined base URI of",
      "ja": "よく定義されたベースのURIと表現内"
    },
    {
      "indent": 6,
      "text": "http://a/b/c/d;p?q",
      "ja": "http：// A / B / C / D、P、Q"
    },
    {
      "indent": 3,
      "text": "a relative reference is transformed to its target URI as follows.",
      "ja": "次のように相対的な基準は、そのターゲットURIに変換されます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Normal Examples",
      "section_title": true,
      "ja": "5.4.1. 通常の例"
    },
    {
      "indent": 6,
      "text": "\"g:h\"           =  \"g:h\"\n\"g\"             =  \"http://a/b/c/g\"\n\"./g\"           =  \"http://a/b/c/g\"\n\"g/\"            =  \"http://a/b/c/g/\"\n\"/g\"            =  \"http://a/g\"\n\"//g\"           =  \"http://g\"\n\"?y\"            =  \"http://a/b/c/d;p?y\"\n\"g?y\"           =  \"http://a/b/c/g?y\"\n\"#s\"            =  \"http://a/b/c/d;p?q#s\"\n\"g#s\"           =  \"http://a/b/c/g#s\"\n\"g?y#s\"         =  \"http://a/b/c/g?y#s\"\n\";x\"            =  \"http://a/b/c/;x\"\n\"g;x\"           =  \"http://a/b/c/g;x\"\n\"g;x?y#s\"       =  \"http://a/b/c/g;x?y#s\"\n\"\"              =  \"http://a/b/c/d;p?q\"\n\".\"             =  \"http://a/b/c/\"\n\"./\"            =  \"http://a/b/c/\"\n\"..\"            =  \"http://a/b/\"\n\"../\"           =  \"http://a/b/\"\n\"../g\"          =  \"http://a/b/g\"\n\"../..\"         =  \"http://a/\"\n\"../../\"        =  \"http://a/\"\n\"../../g\"       =  \"http://a/g\"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.4.2. Abnormal Examples",
      "section_title": true,
      "ja": "5.4.2. 異常例"
    },
    {
      "indent": 3,
      "text": "Although the following abnormal examples are unlikely to occur in normal practice, all URI parsers should be capable of resolving them consistently. Each example uses the same base as that above.",
      "ja": "以下の異常な例は通常の練習で発生する可能性は低いですが、すべてのURIパーサは一貫して、それらを解決することが可能であるべきです。各実施例は、上記と同じベースを使用します。"
    },
    {
      "indent": 3,
      "text": "Parsers must be careful in handling cases where there are more \"..\" segments in a relative-path reference than there are hierarchical levels in the base URI's path. Note that the \"..\" syntax cannot be used to change the authority component of a URI.",
      "ja": "パーサーは、複数が存在する場合を扱うに注意しなければならない「..」ベースURIのパスで、階層レベルがあるよりも、相対パス参照内のセグメント。 「..」構文はURIの権限コンポーネントを変更するために使用することはできないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "\"../../../g\" = \"http://a/g\" \"../../../../g\" = \"http://a/g\"",
      "ja": "\"../../../g\" = \"のhttp：// A / G\" \"../../../../g\" = \"のhttp：// A / G\""
    },
    {
      "indent": 3,
      "text": "Similarly, parsers must remove the dot-segments \".\" and \"..\" when they are complete components of a path, but not when they are only part of a segment.",
      "ja": "同様に、パーサはドットセグメントを削除しなければなりません「」そして、「..」彼らは、パスの完全な要素ですが、ではない彼らは、セグメントの一部のみです。"
    },
    {
      "indent": 6,
      "text": "\"/./g\" = \"http://a/g\" \"/../g\" = \"http://a/g\" \"g.\" = \"http://a/b/c/g.\" \".g\" = \"http://a/b/c/.g\" \"g..\" = \"http://a/b/c/g..\" \"..g\" = \"http://a/b/c/..g\"",
      "ja": "\"/./g\" = \"のhttp：// A / G\" \"/../g\" = \"のhttp：// A / G\"、 \"G。\" = \"のhttp：// A / B / C / gです。\" \".G\" = \"HTTP：//a/b/c/.g\" \"G ..\" = \"HTTP：// A / B / C / G ..\" \"..g\" ​​=「のhttp：/ /a/b/c/..g」"
    },
    {
      "indent": 3,
      "text": "Less likely are cases where the relative reference uses unnecessary or nonsensical forms of the \".\" and \"..\" complete path segments.",
      "ja": "少ない場合は、相対参照が不要なまたは無意味なフォームを使用場所です「」そして、「..」の完全なパスセグメント。"
    },
    {
      "indent": 6,
      "text": "\"./../g\" = \"http://a/b/g\" \"./g/.\" = \"http://a/b/c/g/\" \"g/./h\" = \"http://a/b/c/g/h\" \"g/../h\" = \"http://a/b/c/h\" \"g;x=1/./y\" = \"http://a/b/c/g;x=1/y\" \"g;x=1/../y\" = \"http://a/b/c/y\"",
      "ja": "\"./../g\" = \"のhttp：// A / B / G\" \"./g/\"。 = \"HTTP：// A / B / C / G /\" \"G /./ H\" = \"HTTP：// A / B / C / G / H\" \"Gの/../さh\" =「HTTP： // A / B / C / H \" \"G; X = 1 /./ Y\"= \"HTTP：// A / B / C / G; X = 1 / Y\"\" G; X = 1 / .. / Y」= \"のhttp：// A / B / C / Y\""
    },
    {
      "indent": 3,
      "text": "Some applications fail to separate the reference's query and/or fragment components from the path component before merging it with the base path and removing dot-segments. This error is rarely noticed, as typical usage of a fragment never includes the hierarchy (\"/\") character and the query component is not normally used within relative references.",
      "ja": "一部のアプリケーションでは、ベースパスをマージし、ドットセグメントを削除する前に、パスコンポーネントから参照のクエリおよび/またはそのフラグメントの成分を分離することができません。フラグメントの典型的な使用法は、（「/」）文字とクエリコンポーネントが正常に相対参照内で使用されていません階層を含むことがないよう、このエラーはほとんど、気づいていません。"
    },
    {
      "indent": 6,
      "text": "\"g?y/./x\" = \"http://a/b/c/g?y/./x\" \"g?y/../x\" = \"http://a/b/c/g?y/../x\" \"g#s/./x\" = \"http://a/b/c/g#s/./x\" \"g#s/../x\" = \"http://a/b/c/g#s/../x\"",
      "ja": "\"？G Y /./ X\" = \"HTTP：// A / B / C / G Y /./ X？\" \"G Y /../ X\" =「HTTP：// A / B / C /g?y/../x」 \"G位S /./ X\" = \"HTTP：//a/b/c/g#s/./x\" \"G位S /../ X\" = \"のhttp：//a/b/c/g#s/../x\""
    },
    {
      "indent": 3,
      "text": "Some parsers allow the scheme name to be present in a relative reference if it is the same as the base URI scheme. This is considered to be a loophole in prior specifications of partial URI [RFC1630]. Its use should be avoided but is allowed for backward compatibility.",
      "ja": "一部のパーサは、それがベースURIスキームと同じであればスキーム名は相対参照に存在することを可能にします。これは、部分的なURI [RFC1630]の前仕様の抜け穴であると考えられます。その使用は避けるべきであるが、下位互換性のために許可されています。"
    },
    {
      "indent": 6,
      "text": "\"http:g\" = \"http:g\" ; for strict parsers / \"http://a/b/c/g\" ; for backward compatibility",
      "ja": "\"のhttp：G\" = \"のhttp：G\";厳密パーサ/ \"のhttp：// A / B / C / G\" のために、下位互換性のため"
    },
    {
      "indent": 0,
      "text": "6. Normalization and Comparison",
      "section_title": true,
      "ja": "6.正規化との比較"
    },
    {
      "indent": 3,
      "text": "One of the most common operations on URIs is simple comparison: determining whether two URIs are equivalent without using the URIs to access their respective resource(s). A comparison is performed every time a response cache is accessed, a browser checks its history to color a link, or an XML parser processes tags within a namespace. Extensive normalization prior to comparison of URIs is often used by spiders and indexing engines to prune a search space or to reduce duplication of request actions and response storage.",
      "ja": "URIの上で最も一般的な操作の一つは、単純な比較である：2つのURIは、それぞれのリソースをアクセスするためのURIを使用せずに同等であるかどうかを決定します。比較は、応答キャッシュがアクセスされるたびに実行され、ブラウザがリンクを着色するその歴史をチェックし、またはXMLパーサは、名前空間内のタグを処理します。前のURIの比較に大規模な正規化は、多くの場合、探索空間を剪定したり、要求アクションと応答ストレージの重複を減らすためにスパイダーとインデックスエンジンによって使用されています。"
    },
    {
      "indent": 3,
      "text": "URI comparison is performed for some particular purpose. Protocols or implementations that compare URIs for different purposes will often be subject to differing design trade-offs in regards to how much effort should be spent in reducing aliased identifiers. This section describes various methods that may be used to compare URIs, the trade-offs between them, and the types of applications that might use them.",
      "ja": "URIの比較は、いくつかの特定の目的のために行われます。異なる目的のためにURIを比較するプロトコルや実装は、多くの場合、エイリアス識別子を減らすのに費やされるべきでどれだけの労力に関しては、設計上のトレードオフが異なるの対象となります。このセクションでは、URIを比較するために使用することができる様々な方法、それらの間のトレードオフ、およびそれらを使用する可能性があるアプリケーションの種類について説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Equivalence",
      "section_title": true,
      "ja": "6.1. 等価"
    },
    {
      "indent": 3,
      "text": "Because URIs exist to identify resources, presumably they should be considered equivalent when they identify the same resource. However, this definition of equivalence is not of much practical use, as there is no way for an implementation to compare two resources unless it has full knowledge or control of them. For this reason, determination of equivalence or difference of URIs is based on string comparison, perhaps augmented by reference to additional rules provided by URI scheme definitions. We use the terms \"different\" and \"equivalent\" to describe the possible outcomes of such comparisons, but there are many application-dependent versions of equivalence.",
      "ja": "URIは、リソースを識別するために存在しているので、彼らが同じリソースを識別するとき、おそらく彼らは同等とみなされるべきです。それは完全な知識やそれらのコントロールを持っていない限り、2つのリソースを比較するための実装方法がないようしかし、同値のこの定義は、はるかに実用化ではありません。この理由のため、等価又はURIの差の決定はおそらくURIスキームの定義によって提供される追加のルールを参照することによって拡張文字列の比較に基づいています。私たちは、このような比較の可能な結果を​​記述するために「異なる」と「同等」という用語を使用しますが、同等の多くのアプリケーションに依存するバージョンがあります。"
    },
    {
      "indent": 3,
      "text": "Even though it is possible to determine that two URIs are equivalent, URI comparison is not sufficient to determine whether two URIs identify different resources. For example, an owner of two different domain names could decide to serve the same resource from both, resulting in two different URIs. Therefore, comparison methods are designed to minimize false negatives while strictly avoiding false positives.",
      "ja": "それは2つのURIが等価であることを決定することが可能であっても、URI比較は、2つのURIは、異なるリソースを識別するかどうかを決定するために十分ではありません。例えば、2つの異なるドメイン名の所有者は、二つの異なるのURIで、その結果、両方から同じリソースを提供することを決定することもできます。そのため、比較方法は、厳密に偽陽性を回避しながら、偽陰性を最小限に抑えるように設計されています。"
    },
    {
      "indent": 3,
      "text": "In testing for equivalence, applications should not directly compare relative references; the references should be converted to their respective target URIs before comparison. When URIs are compared to select (or avoid) a network action, such as retrieval of a representation, fragment components (if any) should be excluded from the comparison.",
      "ja": "等価性のテストでは、アプリケーションは直接相対参照を比較するべきではありません。参照は、比較の前に、それぞれのターゲットURIに変換する必要があります。 URIは、このような表現の検索として、ネットワークアクションを選択（または回避）するために比較される場合、断片のコンポーネントは、（もしあれば）の比較から除外されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.2. Comparison Ladder",
      "section_title": true,
      "ja": "6.2. 比較ラダー"
    },
    {
      "indent": 3,
      "text": "A variety of methods are used in practice to test URI equivalence. These methods fall into a range, distinguished by the amount of processing required and the degree to which the probability of false negatives is reduced. As noted above, false negatives cannot be eliminated. In practice, their probability can be reduced, but this reduction requires more processing and is not cost-effective for all applications.",
      "ja": "様々な方法は、URIの等価性をテストするために実際に使用されています。これらの方法は、必要な処理の量および偽陰性の確率が低減される程度によって区別範囲に入ります。上述したように、偽陰性を排除することはできません。実際には、その確率を低減することができますが、この減少は、より多くの処理を必要とし、費用対効果のすべてのアプリケーションではありません。"
    },
    {
      "indent": 3,
      "text": "If this range of comparison practices is considered as a ladder, the following discussion will climb the ladder, starting with practices that are cheap but have a relatively higher chance of producing false negatives, and proceeding to those that have higher computational cost and lower risk of false negatives.",
      "ja": "比較の実践のこの範囲は、ラダーとみなされた場合は、以下の議論は安いですが、偽陰性を生産する比較的高い可能性を持っている慣行で始まる、はしごを登ると、高い計算コストとのリスクが低いものに進めます偽陰性。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Simple String Comparison",
      "section_title": true,
      "ja": "6.2.1. 単純な文字列比較"
    },
    {
      "indent": 3,
      "text": "If two URIs, when considered as character strings, are identical, then it is safe to conclude that they are equivalent. This type of equivalence test has very low computational cost and is in wide use in a variety of applications, particularly in the domain of parsing.",
      "ja": "文字列として考えたときに2つのURIは、同一である場合、彼らが等価であると結論しても安全です。等価テストのこのタイプは非常に低い計算コストを持っており、特に構文解析のドメインでは、様々な用途に広く用いられています。"
    },
    {
      "indent": 3,
      "text": "Testing strings for equivalence requires some basic precautions. This procedure is often referred to as \"bit-for-bit\" or \"byte-for-byte\" comparison, which is potentially misleading. Testing strings for equality is normally based on pair comparison of the characters that make up the strings, starting from the first and proceeding until both strings are exhausted and all characters are found to be equal, until a pair of characters compares unequal, or until one of the strings is exhausted before the other.",
      "ja": "等価のための文字列をテストするいくつかの基本的な予防措置を必要とします。この手順は、しばしば「のためのビットのビット」または潜在的に誤解を招くおそれがあり、「バイト単位」の比較、と呼ばれています。等価のテストストリングは、通常、両方の文字列が排出されると文字のペアが等しくない比較するまで、すべての文字は、同じであることが見出されるまで、第1及び進行から出発して、文字列を構成する文字の対比較に、または1つまで基づいています文字列の他の前に排出されます。"
    },
    {
      "indent": 3,
      "text": "This character comparison requires that each pair of characters be put in comparable form. For example, should one URI be stored in a byte array in EBCDIC encoding and the second in a Java String object (UTF-16), bit-for-bit comparisons applied naively will produce errors. It is better to speak of equality on a character-for-character basis rather than on a byte-for-byte or bit-for-bit basis. In practical terms, character-by-character comparisons should be done codepoint-by-codepoint after conversion to a common character encoding.",
      "ja": "この文字の比較は、文字の各ペアは、比較可能な形で置かれている必要があります。例えば、1つのURIは、EBCDICエンコーディングのバイト配列とJava Stringオブジェクト（UTF-16）、単純印加ビットごとの比較がエラーを生成する第二に格納されるべきです。文字のための文字ベースではなく、バイト単位またはビットごとのベースで平等の話をすることをお勧めします。実用的な面では、文字単位の比較は、コードポイント・バイ・コードポイント共通の文字エンコーディングに変換した後に行う必要があります。"
    },
    {
      "indent": 3,
      "text": "False negatives are caused by the production and use of URI aliases. Unnecessary aliases can be reduced, regardless of the comparison method, by consistently providing URI references in an already-normalized form (i.e., a form identical to what would be produced after normalization is applied, as described below).",
      "ja": "偽陰性は、URIエイリアスの生産と使用によって引き起こされます。不要なエイリアスが一貫して既に正規化された形式でURI参照を提供することにより、関係なく、比較方法の、低減することができる（すなわち、正規化が適用された後、以下に記載されるように、生成されるものと同じ形式）。"
    },
    {
      "indent": 3,
      "text": "Protocols and data formats often limit some URI comparisons to simple string comparison, based on the theory that people and implementations will, in their own best interest, be consistent in providing URI references, or at least consistent enough to negate any efficiency that might be obtained from further normalization.",
      "ja": "プロトコルとデータ形式は、多くの場合、人と実装は、自分の最善の利益に、URI参照を提供するには一貫して、または得られる可能性のある効率性を否定するのに十分な、少なくとも一貫うという理論に基づいて、単純な文字列の比較にはいくつかのURI比較を制限しますさらに正常化から。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Syntax-Based Normalization",
      "section_title": true,
      "ja": "6.2.2. 構文ベースの正規化"
    },
    {
      "indent": 3,
      "text": "Implementations may use logic based on the definitions provided by this specification to reduce the probability of false negatives. This processing is moderately higher in cost than character-for-character string comparison. For example, an application using this approach could reasonably consider the following two URIs equivalent:",
      "ja": "実装は、偽陰性の確率を減らすためにこの仕様によって提供された定義に基づいてロジックを使用することができます。この処理は、文字のための文字列比較よりもコストが適度に高くなっています。例えば、このアプローチを使用するアプリケーションは、合理的に、次の2つのURI相当を考えることができます："
    },
    {
      "indent": 6,
      "text": "example://a/b/c/%7Bfoo%7D eXAMPLE://a/./b/../b/%63/%7bfoo%7d",
      "ja": "例：// A / B / C /％7Bfoo％7D例：//a/./b/../b/%63/%7bfoo%7d"
    },
    {
      "indent": 3,
      "text": "Web user agents, such as browsers, typically apply this type of URI normalization when determining whether a cached response is available. Syntax-based normalization includes such techniques as case normalization, percent-encoding normalization, and removal of dot-segments.",
      "ja": "キャッシュされた応答が利用可能であるかどうかを決定する際にブラウザなどのウェブ・ユーザー・エージェントは、通常、URI正規化のこのタイプを適用します。構文ベース正規化は、ケースの正規化、パーセントエンコーディングの正規化、及びドットセグメントの除去などの技術を含みます。"
    },
    {
      "indent": 0,
      "text": "6.2.2.1. Case Normalization",
      "section_title": true,
      "ja": "6.2.2.1。ケースの正規化"
    },
    {
      "indent": 3,
      "text": "For all URIs, the hexadecimal digits within a percent-encoding triplet (e.g., \"%3a\" versus \"%3A\") are case-insensitive and therefore should be normalized to use uppercase letters for the digits A-F.",
      "ja": "すべてのURIのために、パーセントをコードするトリプレット内の16進数字（「％の3A」対、例えば、「％3aは」）大文字と小文字が区別され、したがって、数字-Fのための大文字を使用するように正規化されるべきです。"
    },
    {
      "indent": 3,
      "text": "When a URI uses components of the generic syntax, the component syntax equivalence rules always apply; namely, that the scheme and host are case-insensitive and therefore should be normalized to lowercase. For example, the URI <HTTP://www.EXAMPLE.com/> is equivalent to <http://www.example.com/>. The other generic syntax components are assumed to be case-sensitive unless specifically defined otherwise by the scheme (see Section 6.2.3).",
      "ja": "URIは、一般的な構文のコンポーネントを使用すると、コンポーネント構文等価性規則は常に適用されます。すなわち、スキームとホストは大文字小文字を区別していること、したがって、小文字に正規化すべきです。例えば、URI <HTTP://www.EXAMPLE.com/は> <http://www.example.com/>と等価です。他の一般的な構文要素は、具体的スキーム（セクション6.2.3を参照）他に定義されない限り、大文字と小文字が区別であると仮定されます。"
    },
    {
      "indent": 0,
      "text": "6.2.2.2. Percent-Encoding Normalization",
      "section_title": true,
      "ja": "6.2.2.2。パーセントエンコーディングの正規化"
    },
    {
      "indent": 3,
      "text": "The percent-encoding mechanism (Section 2.1) is a frequent source of variance among otherwise identical URIs. In addition to the case normalization issue noted above, some URI producers percent-encode octets that do not require percent-encoding, resulting in URIs that are equivalent to their non-encoded counterparts. These URIs should be normalized by decoding any percent-encoded octet that corresponds to an unreserved character, as described in Section 2.3.",
      "ja": "パーセントエンコーディング機構（セクション2.1）、それ以外は同一のURI間分散の頻繁な源です。ケースの正規化の問題に加えて、上記のように、それらの非コードされる対応物に相当するURIをもたらす、パーセントエンコーディングを必要としないいくつかのURI生産パーセントエンコードオクテット。これらのURIは、セクション2.3で説明したように、非予約文字に対応する任意のパーセントエンコードオクテットをデコードすることにより正規化されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.2.2.3. Path Segment Normalization",
      "section_title": true,
      "ja": "6.2.2.3。パスセグメントの正規化"
    },
    {
      "indent": 3,
      "text": "The complete path segments \".\" and \"..\" are intended only for use within relative references (Section 4.1) and are removed as part of the reference resolution process (Section 5.2). However, some deployed implementations incorrectly assume that reference resolution is not necessary when the reference is already a URI and thus fail to remove dot-segments when they occur in non-relative paths. URI normalizers should remove dot-segments by applying the remove_dot_segments algorithm to the path, as described in Section 5.2.4.",
      "ja": "完全なパスセグメント「」そして、「..」のみ相対参照（セクション4.1）内での使用を意図しており、基準解像度処理（セクション5.2）の一部として除去されます。しかし、いくつかの展開の実装が誤って参照が既にURIである場合、基準解像度が不要であると仮定し、したがって、それらは、非相対パスに発生したときのドットセグメントを削除することができません。 5.2.4項で説明したようにURIの正規化は、パスにremove_dot_segmentsアルゴリズムを適用することによってドットセグメントを削除しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Scheme-Based Normalization",
      "section_title": true,
      "ja": "6.2.3. スキームに基づく正規化"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics of URIs vary from scheme to scheme, as described by the defining specification for each scheme. Implementations may use scheme-specific rules, at further processing cost, to reduce the probability of false negatives. For example, because the \"http\" scheme makes use of an authority component, has a default port of \"80\", and defines an empty path to be equivalent to \"/\", the following four URIs are equivalent:",
      "ja": "各スキームの定義書によって記載されるようにURIの構文と意味論は、スキームの方式に変わります。実装は、偽陰性の確率を減少させるために、更なる処理コストで、スキーム固有のルールを使用してもよいです。例えば、「HTTP」方式は、権限コンポーネントを利用するので、「80」のデフォルトのポートを有し、「/」と等価であることが空のパスを定義し、次の4つのURIは等価です。"
    },
    {
      "indent": 6,
      "text": "http://example.com http://example.com/ http://example.com:/ http://example.com:80/",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ ｈっｔｐ：／／えぁｍｐぇ。こｍ／ ｈっｔｐ：／／えぁｍｐぇ。こｍ：／ ｈっｔｐ：／／えぁｍｐぇ。こｍ：８０／"
    },
    {
      "indent": 3,
      "text": "In general, a URI that uses the generic syntax for authority with an empty path should be normalized to a path of \"/\". Likewise, an explicit \":port\", for which the port is empty or the default for the scheme, is equivalent to one where the port and its \":\" delimiter are elided and thus should be removed by scheme-based normalization. For example, the second URI above is the normal form for the \"http\" scheme.",
      "ja": "一般的には、空のパスと権威のための一般的な構文を使用してURIが「/」のパスに正規化する必要があります。同様に、明示的な「：」区切り省略され、従ってスキームに基づく正規化によって除去されなければならないポートが空またはスキームのデフォルトであるため、「ポート」は、ポートとその一つに相当します。例えば、上述した第2のURIは、「HTTP」スキームの正規形です。"
    },
    {
      "indent": 3,
      "text": "Another case where normalization varies by scheme is in the handling of an empty authority component or empty host subcomponent. For many scheme specifications, an empty authority or host is considered an error; for others, it is considered equivalent to \"localhost\" or the end-user's host. When a scheme defines a default for authority and a URI reference to that default is desired, the reference should be normalized to an empty authority for the sake of uniformity, brevity, and internationalization. If, however, either the userinfo or port subcomponents are non-empty, then the host should be given explicitly even if it matches the default.",
      "ja": "正規化スキームによって異なる別の場合には、空の権限コンポーネントまたは空のホストサブコンポーネントの取り扱いです。多くのスキームの仕様については、空の権限またはホストはエラーとみなされます。他人のために、それは「localhost」をまたはエンドユーザのホストと等価であると考えています。スキームは、権限のデフォルトを定義し、そのデフォルトのURI参照が所望される場合、参照は均一、簡潔、及び国際化のために空の権限に正規化されるべきです。しかし、いずれかのuserinfoまたはポートサブコンポーネントが空でない場合、ホストはそれがデフォルトと一致した場合でも、明示的に指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Normalization should not remove delimiters when their associated component is empty unless licensed to do so by the scheme specification. For example, the URI \"http://example.com/?\" cannot be assumed to be equivalent to any of the examples above. Likewise, the presence or absence of delimiters within a userinfo subcomponent is usually significant to its interpretation. The fragment component is not subject to any scheme-based normalization; thus, two URIs that differ only by the suffix \"#\" are considered different regardless of the scheme.",
      "ja": "それらに関連するコンポーネントが空であるときスキーム仕様でそうすることを認可されない限り正規化は、区切り文字を削除しないでください。たとえば、URIは \"http://example.com/？\"上記の例のいずれかと等価であると仮定することはできません。同様に、サブコンポーネントのUserInfo内の区切り文字の有無がその解釈に通常は重要です。フラグメントコンポーネントは、任意のスキームに基づく正規化を受けません。このように、接尾辞「＃」だけが異なる2つのURIは関係なく、スキームの異なると考えられています。"
    },
    {
      "indent": 3,
      "text": "Some schemes define additional subcomponents that consist of case-insensitive data, giving an implicit license to normalizers to convert this data to a common case (e.g., all lowercase). For example, URI schemes that define a subcomponent of path to contain an Internet hostname, such as the \"mailto\" URI scheme, cause that subcomponent to be case-insensitive and thus subject to case normalization (e.g., \"mailto:Joe@Example.COM\" is equivalent to \"mailto:Joe@example.com\", even though the generic syntax considers the path component to be case-sensitive).",
      "ja": "いくつかの方式が一般的な場合（例えば、すべて小文字）にこのデータを変換する正規化への暗黙的なライセンスを与え、大文字と小文字を区別しないデータで構成されて追加のサブコンポーネントを定義します。例えば、パスのサブコンポーネントを定義するURIスキームは、そのような「MAILTO」URI方式として、インターネットホスト名を含むそのサブコンポーネントは大文字と小文字を区別しないと（ケース正規化することが対象とさせるために、例えば、「のmailto：ジョー@例。一般的な構文は、大文字と小文字を区別）するパス成分を考慮しても、Joe@example.com 『：COMは、MAILTO」と同等です』。"
    },
    {
      "indent": 3,
      "text": "Other scheme-specific normalizations are possible.",
      "ja": "その他の方式固有の正規化が可能です。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Protocol-Based Normalization",
      "section_title": true,
      "ja": "6.2.4. プロトコルベースの正規化"
    },
    {
      "indent": 3,
      "text": "Substantial effort to reduce the incidence of false negatives is often cost-effective for web spiders. Therefore, they implement even more aggressive techniques in URI comparison. For example, if they observe that a URI such as",
      "ja": "偽陰性の発生率を減らすために相当な努力は、多くの場合、費用対効果の高いウェブスパイダーのためです。そのため、彼らはURIの比較においても、より積極的な技術を実装します。例えば、彼らは観察した場合、そのようなURI"
    },
    {
      "indent": 6,
      "text": "http://example.com/data",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／だた"
    },
    {
      "indent": 3,
      "text": "redirects to a URI differing only in the trailing slash",
      "ja": "末尾のスラッシュのみが異なるURIにリダイレクト"
    },
    {
      "indent": 6,
      "text": "http://example.com/data/",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／だた／"
    },
    {
      "indent": 3,
      "text": "they will likely regard the two as equivalent in the future. This kind of technique is only appropriate when equivalence is clearly indicated by both the result of accessing the resources and the common conventions of their scheme's dereference algorithm (in this case, use of redirection by HTTP origin servers to avoid problems with relative references).",
      "ja": "彼らは、おそらく将来的には同等のように2つを考えてます。等価が明確に（この場合には、HTTPのオリジンサーバによってリダイレクトの使用は相対参照の問題を回避するため）リソースとそのスキームの逆参照アルゴリズムの一般的な慣習にアクセスした結果の両方で表示されたときにこの種の技術は適切です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "A URI does not in itself pose a security threat. However, as URIs are often used to provide a compact set of instructions for access to network resources, care must be taken to properly interpret the data within a URI, to prevent that data from causing unintended access, and to avoid including data that should not be revealed in plain text.",
      "ja": "URIは、それ自体がセキュリティ上の脅威をもたらすことはありません。 URIは、多くの場合、ネットワークリソースへのアクセスのための命令のコンパクトなセットを提供するために使用されているようしかし、ケアが適切に意図しないアクセスを引き起こしてからそのデータを防ぐために、データを含む避けるために、URI内のデータを解釈するために取られなければならないことはないはずプレーンテキストで明らかにされます。"
    },
    {
      "indent": 0,
      "text": "7.1. Reliability and Consistency",
      "section_title": true,
      "ja": "7.1. 信頼性と一貫性"
    },
    {
      "indent": 3,
      "text": "There is no guarantee that once a URI has been used to retrieve information, the same information will be retrievable by that URI in the future. Nor is there any guarantee that the information retrievable via that URI in the future will be observably similar to that retrieved in the past. The URI syntax does not constrain how a given scheme or authority apportions its namespace or maintains it over time. Such guarantees can only be obtained from the person(s) controlling that namespace and the resource in question. A specific URI scheme may define additional semantics, such as name persistence, if those semantics are required of all naming authorities for that scheme.",
      "ja": "一度URIが情報を取得するために使用されている保証はありませんが、同じ情報が、将来的にそのURIで検索可能になります。 NOR将来的にそのURIを経由して取得可能な情報は、過去に取得したものにobservably同様であろういかなる保証もあります。 URIの構文は、与えられた方式や権威がその名前空間を配分するか、時間をかけて、それを維持してどのように制約はありません。このような保証は、唯一その名前空間と当該のリソースを支配する者（複数可）から入手することができます。これらのセマンティクスは、そのスキームのすべての命名当局に要求される場合は、特定のURIスキームは、そのような名前の永続性などの追加のセマンティクスを定義します。"
    },
    {
      "indent": 0,
      "text": "7.2. Malicious Construction",
      "section_title": true,
      "ja": "7.2. 悪意のある建設"
    },
    {
      "indent": 3,
      "text": "It is sometimes possible to construct a URI so that an attempt to perform a seemingly harmless, idempotent operation, such as the retrieval of a representation, will in fact cause a possibly damaging remote operation. The unsafe URI is typically constructed by specifying a port number other than that reserved for the network protocol in question. The client unwittingly contacts a site running a different protocol service, and data within the URI contains instructions that, when interpreted according to this other protocol, cause an unexpected operation. A frequent example of such abuse has been the use of a protocol-based scheme with a port component of \"25\", thereby fooling user agent software into sending an unintended or impersonating message via an SMTP server.",
      "ja": "そのような表現の検索のような一見無害、冪等操作を実行しようとする試みは、実際にはおそらく損傷遠隔操作を引き起こすであろうように、URIを構築することができる場合があります。危険なURIは、典型的には、当該ネットワークプロトコルのために予約以外のポート番号を指定することによって構成されています。知らず知らずのうちに、クライアントの連絡先URI内の異なるプロトコルサービスを実行しているサイト、およびデータは、この他のプロトコルに従って解釈する場合、予期しない動作を引き起こす命令が含まれています。そのような乱用の頻繁な例は、それによってSMTPサーバを介して意図しないまたはなりすましメッセージを送信中にユーザエージェントソフトウェアをだます、「25」のポート成分とプロトコルベースのスキームの使用でした。"
    },
    {
      "indent": 3,
      "text": "Applications should prevent dereference of a URI that specifies a TCP port number within the \"well-known port\" range (0 - 1023) unless the protocol being used to dereference that URI is compatible with the protocol expected on that well-known port. Although IANA maintains a registry of well-known ports, applications should make such restrictions user-configurable to avoid preventing the deployment of new services.",
      "ja": "URIは、そのよく知られたポート上で予想プロトコルと互換性のあるプロトコルを間接参照するために使用されていない限り - アプリケーション「は、周知のポート」の範囲（1023 0）内のTCPポート番号を指定するURIの逆参照を防ぐべきです。 IANAはwell-knownポートのレジストリを維持しますが、アプリケーションは、新しいサービスの展開を防止することを避けるために、このような制限は、ユーザが設定すべきです。"
    },
    {
      "indent": 3,
      "text": "When a URI contains percent-encoded octets that match the delimiters for a given resolution or dereference protocol (for example, CR and LF characters for the TELNET protocol), these percent-encodings must not be decoded before transmission across that protocol. Transfer of the percent-encoding, which might violate the protocol, is less harmful than allowing decoded octets to be interpreted as additional operations or parameters, perhaps triggering an unexpected and possibly harmful remote operation.",
      "ja": "URIが指定された解像度または間接参照プロトコル（TELNETプロトコルについては、例えば、CRやLF文字）のための区切り文字と一致パーセントエンコードされたオクテットが含まれている場合、これらのパーセントエンコーディングは、そのプロトコルを横切って送信前にデコードされてはなりません。プロトコルに違反する可能性がパーセントエンコーディングの転送は、おそらく予想外そしておそらく有害な遠隔操作をトリガ、デコードオクテットは、追加操作またはパラメータとして解釈されることを可能にするより少ない有害です。"
    },
    {
      "indent": 0,
      "text": "7.3. Back-End Transcoding",
      "section_title": true,
      "ja": "7.3. バックエンドトランスコーディング"
    },
    {
      "indent": 3,
      "text": "When a URI is dereferenced, the data within it is often parsed by both the user agent and one or more servers. In HTTP, for example, a typical user agent will parse a URI into its five major components, access the authority's server, and send it the data within the authority, path, and query components. A typical server will take that information, parse the path into segments and the query into key/value pairs, and then invoke implementation-specific handlers to respond to the request. As a result, a common security concern for server implementations that handle a URI, either as a whole or split into separate components, is proper interpretation of the octet data represented by the characters and percent-encodings within that URI.",
      "ja": "URIが逆参照されている場合、その中のデータは、多くの場合、ユーザエージェントと1つまたは複数のサーバの両方によって解析されます。 HTTPでは、例えば、一般的なユーザーエージェントは、当局のサーバーにアクセスし、その5つの主要なコンポーネントにURIを解析し、それに権限内のデータ、パス、およびクエリコンポーネントを送信します。典型的なサーバは、その情報を取るセグメントに経路及びキー/値のペアにクエリを解析し、その要求に応答するために実装固有のハンドラを呼び出します。結果として、URIを処理するサーバの実装のための一般的なセキュリティ上の問題は、別々の成分への全体または分割のいずれかと、そのURI内の文字とパーセントエンコーディングで表されるオクテットのデータの適切な解釈です。"
    },
    {
      "indent": 3,
      "text": "Percent-encoded octets must be decoded at some point during the dereference process. Applications must split the URI into its components and subcomponents prior to decoding the octets, as otherwise the decoded octets might be mistaken for delimiters. Security checks of the data within a URI should be applied after decoding the octets. Note, however, that the \"%00\" percent-encoding (NUL) may require special handling and should be rejected if the application is not expecting to receive raw data within a component.",
      "ja": "パーセントエンコードオクテットは間接参照プロセス中のある時点でデコードする必要があります。それ以外の場合は、デコードオクテットが区切り文字と間違えられる可能性があるとして、アプリケーションは、オクテットをデコードする前に、そのコンポーネントとサブコンポーネントにURIを分割する必要があります。 URI内のデータのセキュリティチェックは、オクテットをデコードした後に適用されなければなりません。ただし、「％00」パーセントエンコーディング（NUL）特別な処理を必要とするかもしれないし、アプリケーションがコンポーネント内の生データを受信することを期待されていない場合に拒否されるべきであること。"
    },
    {
      "indent": 3,
      "text": "Special care should be taken when the URI path interpretation process involves the use of a back-end file system or related system functions. File systems typically assign an operational meaning to special characters, such as the \"/\", \"\\\", \":\", \"[\", and \"]\" characters, and to special device names like \".\", \"..\", \"...\", \"aux\", \"lpt\", etc. In some cases, merely testing for the existence of such a name will cause the operating system to pause or invoke unrelated system calls, leading to significant security concerns regarding denial of service and unintended data transfer. It would be impossible for this specification to list all such significant characters and device names. Implementers should research the reserved names and characters for the types of storage device that may be attached to their applications and restrict the use of data obtained from URI components accordingly.",
      "ja": "URIパス解釈プロセスは、バックエンド・ファイル・システムまたは関連するシステム機能の使用を必要とする場合には、特別な注意が必要です。 「[」、および「]」、文字を、などの特殊なデバイス名に、「.. 『：「」ファイルシステムは、典型的には、「/」、「\\」などの特殊文字に操作の意味を割り当てます』。」 、「...」、 『AUX』、 『LPT』などいくつかのケースでは、単に拒否に関する重大なセキュリティ上の懸念につながる、一時停止、または無関係のシステムコールを呼び出すために、オペレーティング・システムの原因となります、このような名前の存在をテストしますサービスや意図しないデータ転送。この仕様は、そのようなすべての重要な文字とデバイス名を一覧表示することは不可能であろう。実装者は、そのアプリケーションに取り付けることができるストレージ装置のタイプの予約名や文字を検索し、それに応じてURI成分から得られたデータの使用を制限すべきです。"
    },
    {
      "indent": 0,
      "text": "7.4. Rare IP Address Formats",
      "section_title": true,
      "ja": "7.4. レアIPアドレス形式"
    },
    {
      "indent": 3,
      "text": "Although the URI syntax for IPv4address only allows the common dotted-decimal form of IPv4 address literal, many implementations that process URIs make use of platform-dependent system routines, such as gethostbyname() and inet_aton(), to translate the string literal to an actual IP address. Unfortunately, such system routines often allow and process a much larger set of formats than those described in Section 3.2.2.",
      "ja": "IPv4AddressをするためのURIの構文のみ可能にするがIPv4の共通のドット付き十進形態はURIを処理するプラットフォームに依存するシステムのようにgethostbynameなどのルーチン、（）及びINET_ATON（）を利用するリテラル、多くの実装のアドレスにリテラル文字列を翻訳します実際のIPアドレス。残念ながら、このようなシステムルーチンは、多くの場合、許可すると、セクション3.2.2に記載されているものよりも形式のはるかに大きいセットを処理します。"
    },
    {
      "indent": 3,
      "text": "For example, many implementations allow dotted forms of three numbers, wherein the last part is interpreted as a 16-bit quantity and placed in the right-most two bytes of the network address (e.g., a Class B network). Likewise, a dotted form of two numbers means that the last part is interpreted as a 24-bit quantity and placed in the right-most three bytes of the network address (Class A), and a single number (without dots) is interpreted as a 32-bit quantity and stored directly in the network address. Adding further to the confusion, some implementations allow each dotted part to be interpreted as decimal, octal, or hexadecimal, as specified in the C language (i.e., a leading 0x or 0X implies hexadecimal; a leading 0 implies octal; otherwise, the number is interpreted as decimal).",
      "ja": "たとえば、多くの実装は、最後の部分は、16ビットの量として解釈され、ネットワークアドレス（例えば、クラスBネットワーク）の右端の2バイトに配置される3つの数字の点線形態を可能にします。同様に、2つの数の点線形態は、最後の部分は、24ビットの量として解釈され、ネットワークアドレス（クラスA）の右端の3バイトに入れ、（ドットなし）単数として解釈されることを意味します32ビット量とネットワークアドレスに直接格納。混乱をさらに添加すること、いくつかの実装は、（C言語で指定即ち、先行する0xまたは0Xは16進数を意味し、各点線部分は、10進数、8進数、または16進数として解釈されることを可能にする、0をリードするオクタル意味し、そうでなければ、数）小数として解釈されます。"
    },
    {
      "indent": 3,
      "text": "These additional IP address formats are not allowed in the URI syntax due to differences between platform implementations. However, they can become a security concern if an application attempts to filter access to resources based on the IP address in string literal format. If this filtering is performed, literals should be converted to numeric form and filtered based on the numeric value, and not on a prefix or suffix of the string form.",
      "ja": "これらの追加のIPアドレス形式が原因プラットフォームの実装の違いにURI構文で許可されていません。アプリケーションが文字列リテラル形式のIPアドレスに基づいてリソースへのアクセスをフィルタリングしようとした場合しかし、彼らはセキュリティ上の問題になることができます。このフィルタリングが行われた場合、リテラル文字列形式のプレフィックスまたはサフィックスにない数値形式に変換された数値に基づいて濾過し、すべきです。"
    },
    {
      "indent": 0,
      "text": "7.5. Sensitive Information",
      "section_title": true,
      "ja": "7.5. 機密情報"
    },
    {
      "indent": 3,
      "text": "URI producers should not provide a URI that contains a username or password that is intended to be secret. URIs are frequently displayed by browsers, stored in clear text bookmarks, and logged by user agent history and intermediary applications (proxies). A password appearing within the userinfo component is deprecated and should be considered an error (or simply ignored) except in those rare cases where the 'password' parameter is intended to be public.",
      "ja": "URIプロデューサーは秘密であることを意図しているユーザー名やパスワードを含むURIを提供してはなりません。 URIは頻繁にクリアテキストのブックマークに保存され、ブラウザで表示され、ユーザーエージェントの履歴や仲介アプリケーション（プロキシ）で記録されます。ユーザー情報の成分内に現れるパスワードは、「パスワード」パラメータはパブリックであることを意図しているもの稀な場合を除いて推奨されておらず、エラーと見なさ（または単に無視）されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.6. Semantic Attacks",
      "section_title": true,
      "ja": "7.6. セマンティック攻撃"
    },
    {
      "indent": 3,
      "text": "Because the userinfo subcomponent is rarely used and appears before the host in the authority component, it can be used to construct a URI intended to mislead a human user by appearing to identify one (trusted) naming authority while actually identifying a different authority hidden behind the noise. For example",
      "ja": "UserInfoサブコンポーネントはほとんど使用されないと権限コンポーネントでホストの前に表示されているので、URIを構築するために使用することができ、実際の後ろに隠れて異なる権限を特定しながら、権威を命名（信頼できる）ものを識別するために登場することにより、人間のユーザを欺くためのものノイズ。例えば"
    },
    {
      "indent": 6,
      "text": "ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm",
      "ja": "FTP：//cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm"
    },
    {
      "indent": 3,
      "text": "might lead a human user to assume that the host is 'cnn.example.com', whereas it is actually '10.0.0.1'. Note that a misleading userinfo subcomponent could be much longer than the example above.",
      "ja": "それは実際に'10であるのに対し、ホストは「cnn.example.com」であると仮定することが人間のユーザを導くかもしれない.0.0.1' 。誤解を招くのUserInfoサブコンポーネントは、上記の例よりもはるかに長くなる可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A misleading URI, such as that above, is an attack on the user's preconceived notions about the meaning of a URI rather than an attack on the software itself. User agents may be able to reduce the impact of such attacks by distinguishing the various components of the URI when they are rendered, such as by using a different color or tone to render userinfo if any is present, though there is no panacea. More information on URI-based semantic attacks can be found in [Siedzik].",
      "ja": "誤解を招くようなURIは、その結果、上記のように、URIの意味ではなく、ソフトウェア自体への攻撃について、ユーザーの先入観への攻撃です。ユーザエージェントは、それらがレンダリングされるときにそのような万能薬はないがいずれかが存在する場合にユーザー情報レンダリングするために異なる色またはトーンを使用することなどによって、URIの様々な構成要素を区別することによって、このような攻撃の影響を低減することができるかもしれません。 URIベースのセマンティック攻撃の詳細については、[Siedzik]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "URI scheme names, as defined by <scheme> in Section 3.1, form a registered namespace that is managed by IANA according to the procedures defined in [BCP35]. No IANA actions are required by this document.",
      "ja": "URIスキーム名は、セクション3.1で<スキーム>によって定義されるように、[BCP35]で定義された手順に従ってIANAによって管理されて登録された名前空間を形成します。いいえIANAのアクションは、この文書で必要ありません。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "This specification is derived from RFC 2396 [RFC2396], RFC 1808 [RFC1808], and RFC 1738 [RFC1738]; the acknowledgements in those documents still apply. It also incorporates the update (with corrections) for IPv6 literals in the host syntax, as defined by Robert M. Hinden, Brian E. Carpenter, and Larry Masinter in [RFC2732]. In addition, contributions by Gisle Aas, Reese Anschultz, Daniel Barclay, Tim Bray, Mike Brown, Rob Cameron, Jeremy Carroll, Dan Connolly, Adam M. Costello, John Cowan, Jason Diamond, Martin Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman, Tony Hammond, Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs, Michael Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly, Andrew Main, Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert, Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai Schaetzl, Mark Thomson, Ronald Tschalaer, Norm Walsh, Marc Warne, Stuart Williams, and Henry Zongaro are gratefully acknowledged.",
      "ja": "この仕様は、RFC 2396 [RFC2396]、RFC 1808 [RFC1808]、およびRFC 1738 [RFC1738]に由来します。それらの文書で確認応答が適用されます。また、[RFC2732]にロバートM. HindenとブライアンE.カーペンター、およびラリーMasinterによって定義されるように、ホスト構文でIPv6のリテラルの（修正を含む）更新を組み込みます。また、Gisle Aasが、リースAnschultz、ダニエル・バークレー、ティム・ブレイ、マイク・ブラウン、ロブ・キャメロン、ジェレミー・キャロル、ダン・コノリー、アダム・M.コステロ、ジョン・コーワン、ジェイソン・ダイアモンド、マーティンDuerst、ステファンEissing、クライヴD.W.の貢献フェザー、アルギルマン、トニー・ハモンド、この記事ではElliotteハロルド、パット・ヘイズ、ヘンリー・ホルツマン、イアン・B.ジェイコブス、マイケル・ケイ、ジョンC. Klensin、グラハムKlyne、ダンコーン、ブルース・リリー、アンドリュー・メイン、デイブ・マカルピン、アイラマクドナルド、マイケル・メオーリング、レイMerkert、スティーブンPollei、ジュリアンReschke、トマスRokicki、マイルセービン、甲斐Schaetzl、マーク・トムソン、ロナルドTschalaer、ノーム・ウォルシュ、マルク・ウォーン、スチュアート・ウィリアムズ、そしてヘンリーZongaroは深く感謝しています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ASCII] American National Standards Institute, \"Coded Character Set -- 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "「 - 情報交換のための7ビットの米国標準コードコード化文字セット」、ANSI X3.4、1986 [ASCII]米国規格協会、。"
    },
    {
      "indent": 3,
      "text": "[RFC2234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[RFC2234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、RFC 2234、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[STD63] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[STD63] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[UCS] International Organization for Standardization, \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)\", ISO/IEC 10646:2003, December 2003.",
      "ja": "[UCS]国際標準化機構、 \"情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS）\"、ISO / IEC 10646：2003、2003年12月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BCP19] Freed, N. and J. Postel, \"IANA Charset Registration Procedures\", BCP 19, RFC 2978, October 2000.",
      "ja": "[BCP19]解放され、N.とJ.ポステル、 \"IANA文字セット登録手順\"、BCP 19、RFC 2978、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[BCP35] Petke, R. and I. King, \"Registration Procedures for URL Scheme Names\", BCP 35, RFC 2717, November 1999.",
      "ja": "[BCP35] Petke、R.とI.キング、 \"URLスキーム名の登録手順\"、BCP 35、RFC 2717、1999年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC0952] Harrenstien, K., Stahl, M., and E. Feinler, \"DoD Internet host table specification\", RFC 952, October 1985.",
      "ja": "[RFC0952] Harrenstien、K.、スタール、M.、およびE. Feinler、 \"DoDのインターネットホストテーブル仕様\"、RFC 952、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, October 1989.",
      "ja": "[RFC1123]ブレーデン、R.、 \"インターネットホストのための要件 - 、アプリケーションとサポート\"、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1535] Gavron, E., \"A Security Problem and Proposed Correction With Widely Deployed DNS Software\", RFC 1535, October 1993.",
      "ja": "[RFC1535] Gavron、E.、 \"セキュリティ課題と広く配​​布しているDNSソフトウェアと提案さ補正\"、RFC 1535、1993年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1630] Berners-Lee, T., \"Universal Resource Identifiers in WWW: A Unifying Syntax for the Expression of Names and Addresses of Objects on the Network as used in the World-Wide Web\", RFC 1630, June 1994.",
      "ja": "[RFC1630]バーナーズ=リー、T.、「WWWにおけるユニバーサルリソース識別子：統一構文名およびワールド・ワイド・ウェブで使用されるネットワーク上のオブジェクトのアドレスの発現のために」、RFC 1630、1994年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1736] Kunze, J., \"Functional Recommendations for Internet Resource Locators\", RFC 1736, February 1995.",
      "ja": "[RFC1736]クンツェ、J.、 \"インターネットリソースロケータのための機能の提言\"、RFC 1736、1995年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC1737] Sollins, K. and L. Masinter, \"Functional Requirements for Uniform Resource Names\", RFC 1737, December 1994.",
      "ja": "[RFC1737] Sollins、K.とL. Masinter、 \"統一リソース名のための機能要件\"、RFC 1737、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, \"Uniform Resource Locators (URL)\", RFC 1738, December 1994.",
      "ja": "[RFC1738]バーナーズ=リー、T.、Masinter、L.、およびM. McCahill、 \"ユニフォームリソースロケータ（URL）\"、RFC 1738、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1808] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808, June 1995.",
      "ja": "[RFC1808]フィールディング、R.、 \"相対的なユニフォームリソースロケータ\"、RFC 1808、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2046] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, November 1996.",
      "ja": "[RFC2046]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）パート2：メディアタイプ\"、RFC 2046、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2141] Moats, R., \"URN Syntax\", RFC 2141, May 1997.",
      "ja": "[RFC2141]堀、R.、 \"URN構文\"、RFC 2141、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2396] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[RFC2396]バーナーズ=リー、T.、フィールディング、R.、およびL. Masinter、 \"統一資源識別子（URI）：一般的な構文\"、RFC 2396、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2518] Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D. Jensen, \"HTTP Extensions for Distributed Authoring -- WEBDAV\", RFC 2518, February 1999.",
      "ja": "[RFC2518] Goland、Y.、ホワイトヘッド、E.、フェッチ、A.、カーター、S.、およびD.ジェンセン、 \"分散オーサリングのHTTP拡張 -  WEBDAV\"、RFC 2518、1999年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2557] Palme, J., Hopmann, A., and N. Shelness, \"MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)\", RFC 2557, March 1999.",
      "ja": "[RFC2557]パルメ、J.、Hopmann、A.、およびN. Shelness、RFC 2557、1999年3月 \"は、HTML（MHTML）として集約文書のMIMEカプセル化\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2718] Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke, \"Guidelines for new URL Schemes\", RFC 2718, November 1999.",
      "ja": "[RFC2718] Masinter、L.、Alvestrand、H.、Zigmond、D.、およびR. Petke、 \"新しいURLスキームのためのガイドライン\"、RFC 2718、1999年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2732] Hinden, R., Carpenter, B., and L. Masinter, \"Format for Literal IPv6 Addresses in URL's\", RFC 2732, December 1999.",
      "ja": "\"URLの中にリテラルIPv6アドレスのフォーマット\" [RFC2732] HindenとR.、大工、B.、およびL. Masinter、RFC 2732、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3305] Mealling, M. and R. Denenberg, \"Report from the Joint W3C/IETF URI Planning Interest Group: Uniform Resource Identifiers (URIs), URLs, and Uniform Resource Names (URNs): Clarifications and Recommendations\", RFC 3305, August 2002.",
      "ja": "[RFC3305] Mealling、M.とR. Denenberg、 \"共同W3C / IETF URI計画インタレストグループからのレポート：ユニフォームリソース識別子（URI）、URL、およびユニフォームリソース名（URNの）：明確化と提言\"、RFC 3305、 2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[RFC3490] Faltstrom、P.、ホフマン、P.、およびA.コステロ、 \"アプリケーションにおける国際化ドメイン名（IDNA）\"、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3513] Hinden, R. and S. Deering, \"Internet Protocol Version 6 (IPv6) Addressing Architecture\", RFC 3513, April 2003.",
      "ja": "[RFC3513] HindenとR.とS.デアリング、 \"インターネットプロトコルバージョン6（IPv6）のアドレス指定アーキテクチャ\"、RFC 3513、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[Siedzik] Siedzik, R., \"Semantic Attacks: What's in a URL?\", April 2001, <http://www.giac.org/practical/gsec/ Richard_Siedzik_GSEC.pdf>.",
      "ja": "[Siedzik] Siedzik、R.、 \"セマンティック攻撃：？URLには何が\"、2001年4月<http://www.giac.org/practical/gsec/ Richard_Siedzik_GSEC.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Collected ABNF for URI",
      "ja": "付録A. URIのためのABNFを収集します"
    },
    {
      "indent": 3,
      "text": "URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "URI =スキーム \"：\" \"？\" のhierパート[クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 3,
      "text": "hier-part = \"//\" authority path-abempty / path-absolute / path-rootless / path-empty",
      "ja": "hier-部分= \"//\" 権威パス-abempty /パス-絶対/パス・ルートレス/パス、空"
    },
    {
      "indent": 3,
      "text": "URI-reference = URI / relative-ref",
      "ja": "URIリファレンス= URI /相対-REF"
    },
    {
      "indent": 3,
      "text": "absolute-URI = scheme \":\" hier-part [ \"?\" query ]",
      "ja": "絶対URIスキーム= \"：\" \"？\" のhierパート[クエリ]"
    },
    {
      "indent": 3,
      "text": "relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "相対-REF =相対パート[ \"？\"クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 3,
      "text": "relative-part = \"//\" authority path-abempty / path-absolute / path-noscheme / path-empty",
      "ja": "相対一部=「//」権限パスabempty /パス絶対/パスnoscheme /パス空"
    },
    {
      "indent": 3,
      "text": "scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )",
      "ja": "スキーム= ALPHAの*（ALPHA / DIGIT / \"+\" / \" - \" / \"\"）"
    },
    {
      "indent": 3,
      "text": "authority = [ userinfo \"@\" ] host [ \":\" port ] userinfo = *( unreserved / pct-encoded / sub-delims / \":\" ) host = IP-literal / IPv4address / reg-name port = *DIGIT",
      "ja": "権限=ホスト[ \"：\" ポート] [ \"@\" のuserinfo]のuserinfo = *（予約されていない/ PCT-エンコード/サブdelims / \"：\"）ホスト= IP-リテラル/ IPv4Addressを/ REG-名ポート= * DIGIT"
    },
    {
      "indent": 3,
      "text": "IP-literal = \"[\" ( IPv6address / IPvFuture ) \"]\"",
      "ja": "IP-リテラル= \"[\"（IPv6address / IPvFuture） \"]\""
    },
    {
      "indent": 3,
      "text": "IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )",
      "ja": "IPvFuture = \"\" 1 * HESDIG \"\" 1 *（inreserved /サブdelims / \"：\"）"
    },
    {
      "indent": 3,
      "text": "IPv6address = 6( h16 \":\" ) ls32 / \"::\" 5( h16 \":\" ) ls32 / [ h16 ] \"::\" 4( h16 \":\" ) ls32 / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32 / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32 / [ *3( h16 \":\" ) h16 ] \"::\" h16 \":\" ls32 / [ *4( h16 \":\" ) h16 ] \"::\" ls32 / [ *5( h16 \":\" ) h16 ] \"::\" h16 / [ *6( h16 \":\" ) h16 ] \"::\"",
      "ja": "IPv6address = 6（H16 \"：\"）ls32 / \"::\" 5（H16 \"：\"）ls32 / [H16] \"::\" 4（H16 \"：\"）ls32 / [* 1（H16 \"：\"）H16 \"::\" 3（H16 \"：\"）ls32 / [* 2（H16 \"：\"）H16 \"::\" 2（H16 \"：\"）ls32 / [* 3（H16 \"：\"）H16]」 :: \"H16 \"：\" ls32 / [* 4（H16 \"：\"）H16 \"::\" ls32 / [* 5（H16 \"：\"）H16 \"::\" H16 / [* 6（H16\"： \"）H16] \"::\""
    },
    {
      "indent": 3,
      "text": "h16 = 1*4HEXDIG ls32 = ( h16 \":\" h16 ) / IPv4address IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet dec-octet = DIGIT ; 0-9 / %x31-39 DIGIT ; 10-99 / \"1\" 2DIGIT ; 100-199 / \"2\" %x30-34 DIGIT ; 200-249 / \"25\" %x30-35 ; 250-255",
      "ja": "H16 = 1 * 4HEXDIG ls32 =（H16 \"：\" H16）/ IPv4AddressをIPv4Addressをは= DEC-オクテット \"\" 12月オクテット「」 12月オクテット「」 DEC-オクテットデクオクテット= DIGIT。 0-9 /％x31-39 DIGIT。 10-99 / \"1\" 2DIGIT。 100-199 / \"2\" ％x30-34 DIGIT。 200から249 / \"25\" ％x30-35。 250-255"
    },
    {
      "indent": 3,
      "text": "reg-name = *( unreserved / pct-encoded / sub-delims )",
      "ja": "REG-NAME = *（予約されていない/ PCTエンコード/サブdelims）"
    },
    {
      "indent": 3,
      "text": "path = path-abempty ; begins with \"/\" or is empty / path-absolute ; begins with \"/\" but not \"//\" / path-noscheme ; begins with a non-colon segment / path-rootless ; begins with a segment / path-empty ; zero characters",
      "ja": "パス=パスabempty。 「/」で始まるまたは空/パス絶対あります。 「/」ではなく「//」/パスnoschemeで始まります。非結腸セグメント/パスルートレスで始まります。セグメント/パス空始まります。ゼロの文字"
    },
    {
      "indent": 3,
      "text": "path-abempty = *( \"/\" segment ) path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ] path-noscheme = segment-nz-nc *( \"/\" segment ) path-rootless = segment-nz *( \"/\" segment ) path-empty = 0<pchar>",
      "ja": "パスabempty = *（ \"/\" セグメント）パス絶対= \"/\" [セグメントNZ *（ \"/\" セグメント）]パスnoscheme =セグメント-NZ-NC×（ \"/\" セグメント）パスルートレス=セグメントNZ *（ \"/\" セグメント）パス空= 0 <PChar型>"
    },
    {
      "indent": 3,
      "text": "segment = *pchar segment-nz = 1*pchar segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" ) ; non-zero-length segment without any colon \":\"",
      "ja": "セグメント= * PChar型セグメント-NZ = 1 * PChar型セグメント-NZ-NC = 1 *（未予約/ PCTエンコード/ /サブdelims \"@\"）。任意結腸ことなく、非ゼロ長セグメント「：」"
    },
    {
      "indent": 3,
      "text": "pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"",
      "ja": "PChar型=予約されていない/ PCT-エンコード/サブdelims / \"：\" / \"@\""
    },
    {
      "indent": 3,
      "text": "query = *( pchar / \"/\" / \"?\" )",
      "ja": "クエリ= *（PChar型/ \"/\" / \"？\"）"
    },
    {
      "indent": 3,
      "text": "fragment = *( pchar / \"/\" / \"?\" )",
      "ja": "フラグメント= *（PChar型/ \"/\" / \"？\"）"
    },
    {
      "indent": 3,
      "text": "pct-encoded = \"%\" HEXDIG HEXDIG",
      "ja": "PCTエンコード= \"％\" HEXDIG HEXDIG"
    },
    {
      "indent": 3,
      "text": "unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" reserved = gen-delims / sub-delims gen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\" sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
      "ja": "予約されていない= ALPHA / DIGIT / \" - \" / \"\" / \"_\" / \"〜\" 予約済み= GEN-delims /サブdelims GEN-delims = \"：\" / \"/\" / \"？\" / \"＃\" / \"[\" / \"]\" /サブdelims = \"@\" \"！\" / \"$\" / \"＆\" / \" '' /\"（ \"/\"） \"/\" * \"/\" + \"/\"、 \"/\"; \" / \"=\""
    },
    {
      "indent": 0,
      "text": "Appendix B. Parsing a URI Reference with a Regular Expression",
      "ja": "正規表現でURI参照を解析付録B."
    },
    {
      "indent": 3,
      "text": "As the \"first-match-wins\" algorithm is identical to the \"greedy\" disambiguation method used by POSIX regular expressions, it is natural and commonplace to use a regular expression for parsing the potential five components of a URI reference.",
      "ja": "「最初のマッチ - 勝利」アルゴリズムは、POSIX正規表現で使用される「貪欲」曖昧さ回避方法と同一であるように、URI参照の電位5つの構成要素を解析するための正規表現を使用することが自然で一般的です。"
    },
    {
      "indent": 3,
      "text": "The following line is the regular expression for breaking-down a well-formed URI reference into its components.",
      "ja": "次の行は破壊ダウン整形URI参照をその成分にするための正規表現です。"
    },
    {
      "indent": 6,
      "text": "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))? 12 3 4 5 6 7 8 9",
      "ja": "＾（（「＾：／？＃」＋）：）？（／／（「＾／？＃」＊））？（「＾？＃」＊）（￥？（「＾＃」＊））？（＃（。＊））？ １２ ３ ４ ５ ６ ７ ８ ９"
    },
    {
      "indent": 3,
      "text": "The numbers in the second line above are only to assist readability; they indicate the reference points for each subexpression (i.e., each paired parenthesis). We refer to the value matched for subexpression <n> as $<n>. For example, matching the above expression to",
      "ja": "2行目の数字は、上記の可読性を支援するだけです。彼らは、各部分式（すなわち、各ペア括弧）のための基準点を示します。私たちは、$ <N>として<n>の部分式のために一致した値を参照してください。例えば、上記の式に一致します"
    },
    {
      "indent": 6,
      "text": "http://www.ics.uci.edu/pub/ietf/uri/#Related",
      "ja": "ｈっｔｐ：／／ｗっｗ。いｃｓ。うし。えづ／ぷｂ／いえｔｆ／うり／＃れぁてｄ"
    },
    {
      "indent": 3,
      "text": "results in the following subexpression matches:",
      "ja": "以下の部分式の試合で結果："
    },
    {
      "indent": 6,
      "text": "$1 = http: $2 = http $3 = //www.ics.uci.edu $4 = www.ics.uci.edu $5 = /pub/ietf/uri/ $6 = <undefined> $7 = <undefined> $8 = #Related $9 = Related",
      "ja": "$ 1 = HTTP：$ 2 = HTTP $ 3 = //www.ics.uci.edu $ 4 = www.ics.uci.edu $ = 5 /パブ/ IETF / URI / $ 6 = <不定> $ J = <不定> $ 8 = #Related関連$ 9 ="
    },
    {
      "indent": 3,
      "text": "where <undefined> indicates that the component is not present, as is the case for the query component in the above example. Therefore, we can determine the value of the five components as",
      "ja": "ここで、<不定>上記の例では、クエリコンポーネントの場合のようにコンポーネントが存在しないことを示します。したがって、我々は5つのコンポーネントとしての価値を決定することができます"
    },
    {
      "indent": 6,
      "text": "scheme = $2 authority = $4 path = $5 query = $7 fragment = $9",
      "ja": "スキーム= $ 2権限= $ 4パス= $ 5クエリ= $ 7断片= $ 9"
    },
    {
      "indent": 3,
      "text": "Going in the opposite direction, we can recreate a URI reference from its components by using the algorithm of Section 5.3.",
      "ja": "反対方向に行く、我々は、セクション5.3のアルゴリズムを使用してそのコンポーネントからURI参照を再作成することができます。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Delimiting a URI in Context",
      "ja": "コンテキストでURIを区切る付録C."
    },
    {
      "indent": 3,
      "text": "URIs are often transmitted through formats that do not provide a clear context for their interpretation. For example, there are many occasions when a URI is included in plain text; examples include text sent in email, USENET news, and on printed paper. In such cases, it is important to be able to delimit the URI from the rest of the text, and in particular from punctuation marks that might be mistaken for part of the URI.",
      "ja": "URIは、多くの場合、その解釈の明確なコンテキストを提供していないフォーマットを介して送信されます。たとえば、URIがプレーンテキストに含まれる多くの機会があります。例は、電子メールで送信されたテキスト、USENETニュース、および印刷された紙の上にあります。このような場合には、テキストの残りの部分から、特にURIの一部と誤解されるかもしれない句読点からURIを区切ることができることが重要です。"
    },
    {
      "indent": 3,
      "text": "In practice, URIs are delimited in a variety of ways, but usually within double-quotes \"http://example.com/\", angle brackets <http://example.com/>, or just by using whitespace:",
      "ja": "実際には、URIは山括弧<http://example.com/>、または単に空白を使用することにより、「http://example.com/」が、通常は二重引用符で囲まれた、さまざまな方法で区切られています。"
    },
    {
      "indent": 6,
      "text": "http://example.com/",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／"
    },
    {
      "indent": 3,
      "text": "These wrappers do not form part of the URI.",
      "ja": "これらのラッパーは、URIの一部を形成するものではありません。"
    },
    {
      "indent": 3,
      "text": "In some cases, extra whitespace (spaces, line-breaks, tabs, etc.) may have to be added to break a long URI across lines. The whitespace should be ignored when the URI is extracted.",
      "ja": "いくつかのケースでは、余分な空白（スペース、改行、タブなど）が行にわたって長いURIを破るために追加する必要があります。 URIが抽出されたときに空白は無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "No whitespace should be introduced after a hyphen (\"-\") character. Because some typesetters and printers may (erroneously) introduce a hyphen at the end of line when breaking it, the interpreter of a URI containing a line break immediately after a hyphen should ignore all whitespace around the line break and should be aware that the hyphen may or may not actually be part of the URI.",
      "ja": "文字 - いいえ、空白はハイフン（「」）の後に導入すべきではありません。それを破ったときに、いくつかのタイプセッタやプリンタが（誤って）行の末尾にハイフンを導入することができるので、ハイフンの直後に改行を含むURIのインタプリタは、改行の周りのすべての空白を無視すべきであると認識しておく必要があり、ハイフンがかもしれないことまたは実際にURIの一部ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Using <> angle brackets around each URI is especially recommended as a delimiting style for a reference that contains embedded whitespace.",
      "ja": "使い方<>各URIの周りの角括弧は、特に、埋め込み空白が含まれている参照用の区切りスタイルとして推奨されます。"
    },
    {
      "indent": 3,
      "text": "The prefix \"URL:\" (with or without a trailing space) was formerly recommended as a way to help distinguish a URI from other bracketed designators, though it is not commonly used in practice and is no longer recommended.",
      "ja": "接頭辞「URLは：」それは一般的に実際に使用されていないされていないと、もはや推奨されているが（または末尾にスペースなし）以前は、他の括弧指定子からURIを区別しやすくするための方法として推奨されていました。"
    },
    {
      "indent": 3,
      "text": "For robustness, software that accepts user-typed URI should attempt to recognize and strip both delimiters and embedded whitespace.",
      "ja": "堅牢性のために、ユーザが入力したURIを受け入れソフトウェアは、区切り文字と埋め込まれた空白の両方を認識し、ストリップを試みる必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the text",
      "ja": "たとえば、テキスト"
    },
    {
      "indent": 6,
      "text": "Yes, Jim, I found it under \"http://www.w3.org/Addressing/\", but you can probably pick it up from <ftp://foo.example. com/rfc/>. Note the warning in <http://www.ics.uci.edu/pub/ ietf/uri/historical.html#WARNING>.",
      "ja": "はい、ジムは、私が「http://www.w3.org/Addressing/」の下でそれを見つけましたが、あなたはおそらく、FTP <からそれを拾うことができます。//foo.example。 COM / RFC />。 <http://www.ics.uci.edu/pub/ IETF / URI / historical.html＃警告>での警告に注意してください。"
    },
    {
      "indent": 3,
      "text": "contains the URI references",
      "ja": "URI参照が含まれています"
    },
    {
      "indent": 6,
      "text": "http://www.w3.org/Addressing/ ftp://foo.example.com/rfc/ http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING",
      "ja": "ｈっｔｐ：／／ｗっｗ。ｗ３。おｒｇ／あっｄれっしんｇ／ ｆｔｐ：／／ふぉお。えぁｍｐぇ。こｍ／ｒｆｃ／ ｈっｔｐ：／／ｗっｗ。いｃｓ。うし。えづ／ぷｂ／いえｔｆ／うり／ひｓとりかｌ。ｈｔｍｌ＃わＲにんＧ"
    },
    {
      "indent": 1,
      "text": "Appendix D. Changes from",
      "ja": "付録D.変更から"
    },
    {
      "indent": 0,
      "text": "D.1. Additions",
      "ja": "D.1。追加"
    },
    {
      "indent": 3,
      "text": "An ABNF rule for URI has been introduced to correspond to one common usage of the term: an absolute URI with optional fragment.",
      "ja": "任意の断片と絶対URI：URIのためのABNF規則は、用語の一般的な使用に対応するために導入されています。"
    },
    {
      "indent": 3,
      "text": "IPv6 (and later) literals have been added to the list of possible identifiers for the host portion of an authority component, as described by [RFC2732], with the addition of \"[\" and \"]\" to the reserved set and a version flag to anticipate future versions of IP literals. Square brackets are now specified as reserved within the authority component and are not allowed outside their use as delimiters for an IP literal within host. In order to make this change without changing the technical definition of the path, query, and fragment components, those rules were redefined to directly specify the characters allowed.",
      "ja": "[RFC2732]で説明したようにIPv6の（およびそれ以降）リテラルは、予約セットとバージョンフラグに「[」と「]」を加えて、権限コンポーネントのホスト部分の可能な識別子のリストに追加されていますIPリテラルの将来のバージョンを予想します。権限コンポーネント内に確保し、ホスト内のリテラルIPのための区切り文字としての使用の外に許可されていないとして、角カッコは、現在指定されています。パス、クエリー、およびフラグメントコンポーネントの技術的な定義を変更することなく、この変更を行うためには、これらのルールは、直接使用できる文字を指定するために再定義されました。"
    },
    {
      "indent": 3,
      "text": "As [RFC2732] defers to [RFC3513] for definition of an IPv6 literal address, which, unfortunately, lacks an ABNF description of IPv6address, we created a new ABNF rule for IPv6address that matches the text representations defined by Section 2.2 of [RFC3513]. Likewise, the definition of IPv4address has been improved in order to limit each decimal octet to the range 0-255.",
      "ja": "[RFC2732]は、残念ながら、IPv6addressのABNFの記述を欠いたIPv6リテラルアドレスの定義については、[RFC3513]に延期するように、我々は[RFC3513]のセクション2.2で定義されたテキスト表現にマッチするIPv6addressための新たなABNF規則を作成しました。同様に、IPv4Addressをの定義は0〜255の範囲にそれぞれ進オクテットを制限するために改善されています。"
    },
    {
      "indent": 3,
      "text": "Section 6, on URI normalization and comparison, has been completely rewritten and extended by using input from Tim Bray and discussion within the W3C Technical Architecture Group.",
      "ja": "第6節では、URIの正規化との比較に、完全に書き直されましたし、ティム・ブレイとW3Cテクニカルアーキテクチャグループ内での議論からの入力を使用することによって拡張しました。"
    },
    {
      "indent": 0,
      "text": "D.2. Modifications",
      "ja": "D.2。修正"
    },
    {
      "indent": 3,
      "text": "The ad-hoc BNF syntax of RFC 2396 has been replaced with the ABNF of [RFC2234]. This change required all rule names that formerly included underscore characters to be renamed with a dash instead. In addition, a number of syntax rules have been eliminated or simplified to make the overall grammar more comprehensible. Specifications that refer to the obsolete grammar rules may be understood by replacing those rules according to the following table:",
      "ja": "RFC 2396のアドホックBN​​F構文は、[RFC2234]のABNFに置き換えられました。この変更は、以前の代わりにダッシュで名前を変更するアンダースコア文字を含むすべてのルール名を必要としていました。また、構文規則の数を排除又は全体的な文法をより理解するために簡略化されています。廃止された文法規則を参照仕様は以下の表に従ってこれらのルールを置換することによって理解することができます。"
    },
    {
      "indent": 3,
      "text": "+----------------+--------------------------------------------------+\n| obsolete rule  | translation                                      |\n+----------------+--------------------------------------------------+\n| absoluteURI    | absolute-URI                                     |\n| relativeURI    | relative-part [ \"?\" query ]                      |\n| hier_part      | ( \"//\" authority path-abempty /                  |\n|                | path-absolute ) [ \"?\" query ]                    |\n|                |                                                  |\n| opaque_part    | path-rootless [ \"?\" query ]                      |\n| net_path       | \"//\" authority path-abempty                      |\n| abs_path       | path-absolute                                    |\n| rel_path       | path-rootless                                    |\n| rel_segment    | segment-nz-nc                                    |\n| reg_name       | reg-name                                         |\n| server         | authority                                        |\n| hostport       | host [ \":\" port ]                                |\n| hostname       | reg-name                                         |\n| path_segments  | path-abempty                                     |\n| param          | *<pchar excluding \";\">                           |\n|                |                                                  |\n| uric           | unreserved / pct-encoded / \";\" / \"?\" / \":\"       |\n|                |  / \"@\" / \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \"/\"       |\n|                |                                                  |\n| uric_no_slash  | unreserved / pct-encoded / \";\" / \"?\" / \":\"       |\n|                |  / \"@\" / \"&\" / \"=\" / \"+\" / \"$\" / \",\"             |\n|                |                                                  |\n| mark           | \"-\" / \"_\" / \".\" / \"!\" / \"~\" / \"*\" / \"'\"          |\n|                |  / \"(\" / \")\"                                     |\n|                |                                                  |\n| escaped        | pct-encoded                                      |\n| hex            | HEXDIG                                           |\n| alphanum       | ALPHA / DIGIT                                    |\n+----------------+--------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Use of the above obsolete rules for the definition of scheme-specific syntax is deprecated.",
      "ja": "スキーム固有の構文の定義については、上記の時代遅れの規則の使用は推奨されません。"
    },
    {
      "indent": 3,
      "text": "Section 2, on characters, has been rewritten to explain what characters are reserved, when they are reserved, and why they are reserved, even when they are not used as delimiters by the generic syntax. The mark characters that are typically unsafe to decode, including the exclamation mark (\"!\"), asterisk (\"*\"), single-quote (\"'\"), and open and close parentheses (\"(\" and \")\"), have been moved to the reserved set in order to clarify the distinction between reserved and unreserved and, hopefully, to answer the most common question of scheme designers. Likewise, the section on percent-encoded characters has been rewritten, and URI normalizers are now given license to decode any percent-encoded octets corresponding to unreserved characters. In general, the terms \"escaped\" and \"unescaped\" have been replaced with \"percent-encoded\" and \"decoded\", respectively, to reduce confusion with other forms of escape mechanisms.",
      "ja": "第2節では、文字の上に、それらは一般的な構文で区切り文字として使用されていない場合でも、それらが予約されていたときに、予約されており、そしてなぜ彼らが予約されているものを文字説明するために、書き直されました。マーク感嘆符を含む一般的にデコードすることが安全ではない文字（「！」）、アスタリスク（「*」）、単一引用符（「' 『）、及び開閉括弧（』（」と 『）』） 、うまくいけば、制度設計の最も一般的な質問に答えるために、予約されたと予約されていないとの区別を明確にするために予約されたセットに移動されました。同様に、パーセントエンコードされた文字の部分が書き換えられている、とURIの正規化は現在、非予約文字に対応する任意のパーセントエンコードオクテットを復号化するためにライセンスを与えられています。一般に、エスケープ機構の他の形態との混乱を低減するために、それぞれ、「エスケープ」、および「エスケープ」という用語は、「パーセントエンコード」で置換されており、「デコード」。"
    },
    {
      "indent": 3,
      "text": "The ABNF for URI and URI-reference has been redesigned to make them more friendly to LALR parsers and to reduce complexity. As a result, the layout form of syntax description has been removed, along with the uric, uric_no_slash, opaque_part, net_path, abs_path, rel_path, path_segments, rel_segment, and mark rules. All references to \"opaque\" URIs have been replaced with a better description of how the path component may be opaque to hierarchy. The relativeURI rule has been replaced with relative-ref to avoid unnecessary confusion over whether they are a subset of URI. The ambiguity regarding the parsing of URI-reference as a URI or a relative-ref with a colon in the first segment has been eliminated through the use of five separate path matching rules.",
      "ja": "URIとURI参照のためのABNFは、パーサーをLALRすると複雑さを軽減するためにそれらをより使いやすくするために再設計されました。その結果、構文記述の配置形態は、尿、uric_no_slash、opaque_part、net_path、腹筋_経路、rel_path、path_segments、rel_segment、マークルールとともに、除去されています。 「不透明」のURIへのすべての参照は、パスコンポーネントが階層に不透明であってもよいかをよりよく説明に置き換えられました。 relativeURIルールは、彼らはURIのサブセットであるかどうかを介して不必要な混乱を避けるために、相対参照に置き換えられました。 URIまたは最初のセグメントにコロン相対-REFとしてURI参照の構文解析に関する曖昧さは、5つの別々のパスに一致するルールを使用することによって排除されています。"
    },
    {
      "indent": 3,
      "text": "The fragment identifier has been moved back into the section on generic syntax components and within the URI and relative-ref rules, though it remains excluded from absolute-URI. The number sign (\"#\") character has been moved back to the reserved set as a result of reintegrating the fragment syntax.",
      "ja": "それは絶対URIから除外残るものの断片識別子は、一般的な構文要素上及びURIと相対-REFルール内でバック部に移動されています。番号記号（「＃」）は文字がフラグメントの構文を再統合の結果として、背面の予約セットに移動されました。"
    },
    {
      "indent": 3,
      "text": "The ABNF has been corrected to allow the path component to be empty. This also allows an absolute-URI to consist of nothing after the \"scheme:\", as is present in practice with the \"dav:\" namespace [RFC2518] and with the \"about:\" scheme used internally by many WWW browser implementations. The ambiguity regarding the boundary between authority and path has been eliminated through the use of five separate path matching rules.",
      "ja": "ABNFは、パスコンポーネントが空であることを許可するように修正されました。 、「DAV：」で実際に存在しているとして、名前空間[RFC2518]と「について：」と多くのWWWブラウザの実装によって内部的に使用スキーム：これも絶対URIは「スキーム」の後に何から構成することができます。権限とパスとの境界に関する曖昧さは、5つの別々のパスマッチング規則を使用することによって排除されています。"
    },
    {
      "indent": 3,
      "text": "Registry-based naming authorities that use the generic syntax are now defined within the host rule. This change allows current implementations, where whatever name provided is simply fed to the local name resolution mechanism, to be consistent with the specification. It also removes the need to re-specify DNS name formats here. Furthermore, it allows the host component to contain percent-encoded octets, which is necessary to enable internationalized domain names to be provided in URIs, processed in their native character encodings at the application layers above URI processing, and passed to an IDNA library as a registered name in the UTF-8 character encoding. The server, hostport, hostname, domainlabel, toplabel, and alphanum rules have been removed.",
      "ja": "一般的な構文を使用して、レジストリベースの命名当局は現在、ホストルール内で定義されています。この変更は、どのような名前提供さを単に仕様と一致するように、ローカル名前解決機構に供給される電流の実装を可能にします。また、ここでDNS名の形式を再指定する必要がなくなります。さらに、それはのようにIDNAライブラリに、URIの中に設けられたURI処理上のアプリケーション層でそれらの固有の文字エンコーディングで処理され、通過する国際化ドメイン名を有効にする必要があるパーセントエンコードされたオクテットを含有するホストコンポーネントを、可能にしますUTF-8文字エンコーディングで登録名。サーバー、ホスト側、ホスト名、domainlabel、toplabel、およびalphanumルールは削除されました。"
    },
    {
      "indent": 3,
      "text": "The resolving relative references algorithm of [RFC2396] has been rewritten with pseudocode for this revision to improve clarity and fix the following issues: o [RFC2396] section 5.2, step 6a, failed to account for a base URI with no path.",
      "ja": "[RFC2396]の解決相対参照アルゴリズムは、透明性を改善し、次の問題を解決するために、この改正のための擬似コードで書き換えられた：[RFC2396]セクション5.2、ステップ6aとO、ないフリーベースURIを考慮することができませんでした。"
    },
    {
      "indent": 3,
      "text": "o Restored the behavior of [RFC1808] where, if the reference contains an empty path and a defined query component, the target URI inherits the base URI's path component.",
      "ja": "O参照が空のパスと定義されたクエリーコンポーネントを含む場合、ターゲットURIは、ベースURIのパスコンポーネントを継承し、[RFC1808]の動作を回復しました。"
    },
    {
      "indent": 3,
      "text": "o The determination of whether a URI reference is a same-document reference has been decoupled from the URI parser, simplifying the URI processing interface within applications in a way consistent with the internal architecture of deployed URI processing implementations. The determination is now based on comparison to the base URI after transforming a reference to absolute form, rather than on the format of the reference itself. This change may result in more references being considered \"same-document\" under this specification than there would be under the rules given in RFC 2396, especially when normalization is used to reduce aliases. However, it does not change the status of existing same-document references.",
      "ja": "O URI参照が同じ文書の参照であるか否かの判定は、配備URI処理の実装の内部アーキテクチャと一致するようにアプリケーション内のURI処理インタフェースを簡素化、URIパーサから切り離されています。決意について絶対形式への参照を変換した後ではなく、参照そのものの形式にベースURIとの比較に基づいています。この変化は、正規化がエイリアスを低減するために使用される場合は特に、RFC 2396に指定されたルールの下に存在するであろうよりも、この明細書の下で、「同一文書」とみなされている複数の参照をもたらすことができます。しかし、それは既存の同じ文書参照のステータスを変更しません。"
    },
    {
      "indent": 3,
      "text": "o Separated the path merge routine into two routines: merge, for describing combination of the base URI path with a relative-path reference, and remove_dot_segments, for describing how to remove the special \".\" and \"..\" segments from a composed path. The remove_dot_segments algorithm is now applied to all URI reference paths in order to match common implementations and to improve the normalization of URIs in practice. This change only impacts the parsing of abnormal references and same-scheme references wherein the base URI has a non-hierarchical path.",
      "ja": "O 2つのルーチンにパスマージルーチン分離：特別を削除する方法を説明するために、相対パス参照、及びremove_dot_segmentsとベースURIパスの組み合わせを記述するため、マージ「」合成経路からと「..」セグメント。 remove_dot_segmentsアルゴリズムは、現在の一般的な実装に合わせて、実際にURIの正規化を向上させるために、すべてのURI参照パスに適用されます。この変更は、影響異常な参照とベースURIは、非階層経路を有する同じスキーム参照の解析。"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "指数"
    },
    {
      "indent": 3,
      "text": "A ABNF 11 absolute 27 absolute-path 26 absolute-URI 27 access 9 authority 17, 18",
      "ja": "ABNF 11アブソリュート27の絶対パス26絶対URI 27のアクセス権限9 17、18"
    },
    {
      "indent": 3,
      "text": "B base URI 28",
      "ja": "Ｂ ばせ うり ２８"
    },
    {
      "indent": 3,
      "text": "C character encoding 4 character 4 characters 8, 11 coded character set 4",
      "ja": "C文字エンコード4つの文字4つの文字8、11符号化文字セット4"
    },
    {
      "indent": 3,
      "text": "D dec-octet 20 dereference 9 dot-segments 23",
      "ja": "D DEC-オクテット20参照解除9ドットセグメント23"
    },
    {
      "indent": 3,
      "text": "F fragment 16, 24",
      "ja": "F断片16、24"
    },
    {
      "indent": 3,
      "text": "G gen-delims 13 generic syntax 6",
      "ja": "G GEN-delims 13汎用構文6"
    },
    {
      "indent": 3,
      "text": "H h16 20 hier-part 16 hierarchical 10 host 18",
      "ja": "HのH16 20 HIER-部16階層10ホスト18"
    },
    {
      "indent": 3,
      "text": "I identifier 5 IP-literal 19 IPv4 20 IPv4address 19, 20 IPv6 19 IPv6address 19, 20 IPvFuture 19",
      "ja": "私は5 IPリテラル19のIPv4 20 IPv4Addressを19、20のIPv6 19 IPv6address 19、20 IPvFuture 19がidentifier"
    },
    {
      "indent": 3,
      "text": "L locator 7 ls32 20",
      "ja": "Lロケータ7 ls32 20"
    },
    {
      "indent": 3,
      "text": "M merge 32",
      "ja": "私は32を行きます"
    },
    {
      "indent": 3,
      "text": "N name 7 network-path 26",
      "ja": "N 7ネットワークパス26に名前を付けます"
    },
    {
      "indent": 3,
      "text": "P path 16, 22, 26 path-abempty 22 path-absolute 22 path-empty 22 path-noscheme 22 path-rootless 22 path-abempty 16, 22, 26 path-absolute 16, 22, 26 path-empty 16, 22, 26 path-rootless 16, 22 pchar 23 pct-encoded 12 percent-encoding 12 port 22",
      "ja": "Pパス16、22、26パスabempty 22パス絶対22パス空22パスnoscheme 22パスルートレス22パスabempty 16、22、26パス絶対22、16、26パス空22、16、 26パス・ルートレス16,22 PChar型23 PCTエンコード12パーセントエンコーディング12ポート22"
    },
    {
      "indent": 3,
      "text": "Q query 16, 23",
      "ja": "Qクエリ16、23"
    },
    {
      "indent": 3,
      "text": "R reg-name 21 registered name 20 relative 10, 28 relative-path 26 relative-ref 26 remove_dot_segments 33 representation 9 reserved 12 resolution 9, 28 resource 5 retrieval 9",
      "ja": "R REG-名21登録名20に対して10、28相対パス26の相対-REF 26 remove_dot_segments 33表現9は、12解像度9、28リソース5検索9予約しました"
    },
    {
      "indent": 3,
      "text": "S same-document 27 sameness 9 scheme 16, 17 segment 22, 23 segment-nz 23 segment-nz-nc 23 sub-delims 13 suffix 27",
      "ja": "S同じ文書27個の同一9スキーム16、17、セグメント22、23セグメントNZ 23セグメントNZ-NC 23サブdelims 13サフィックス27"
    },
    {
      "indent": 3,
      "text": "T transcription 8",
      "ja": "T転写8"
    },
    {
      "indent": 3,
      "text": "U uniform 4 unreserved 13 URI grammar absolute-URI 27 ALPHA 11 authority 18 CR 11 dec-octet 20 DIGIT 11 DQUOTE 11 fragment 24 gen-delims 13 h16 20 HEXDIG 11 hier-part 16 host 19 IP-literal 19 IPv4address 20 IPv6address 20 IPvFuture 19 LF 11 ls32 20 OCTET 11 path 22 path-abempty 22 path-absolute 22 path-empty 22 path-noscheme 22 path-rootless 22 pchar 23 pct-encoded 12 port 22 query 24 reg-name 21 relative-ref 26 reserved 13 scheme 17 segment 23 segment-nz 23 segment-nz-nc 23 SP 11 sub-delims 13 unreserved 13 URI 16 URI-reference 25 userinfo 18 URI 16 URI-reference 25 URL 7 URN 7 userinfo 18",
      "ja": "U均一4予約されていない13 URI文法絶対URI 27 ALPHA 11権威18 CR 11デクオクテット20 DIGIT 11 DQUOTE 11断片24 GEN-delims 13 H16 20 HEXDIG 11 HIER-部16ホスト19 IP-リテラル19 IPv4Addressを20 IPv6address 20 IPvFuture 19 LF 11 ls32 20オクテット11パス22の経路abempty 22パス絶対22パス空22パスnoscheme 22パスルートレス22 PChar型23 PCTエンコード12ポート22、クエリ13スキーム予約21相対-REF 26 24 REG-名17セグメント23セグメントNZ 23セグメントNZ-NC 23 SP 11サブdelims 13無遠慮13 URI 16 URIリファレンス25ユーザー情報18 URI 16 URIリファレンス25 URL 7 URN 7~18ユーザー情報"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tim Berners-Lee World Wide Web Consortium Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139 USA",
      "ja": "テクノロジーのティム・バーナーズ=リーのWorld Wide Web Consortiumのマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、MA 02139 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-617-253-5702 Fax: +1-617-258-5999 EMail: timbl@w3.org URI: http://www.w3.org/People/Berners-Lee/",
      "ja": "電話：+ 1-617-253-5702ファックス：+ 1-617-258-5999 Eメール：timbl@w3.org URI：http://www.w3.org/People/Berners-Lee/"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding Day Software 5251 California Ave., Suite 110 Irvine, CA 92617 USA",
      "ja": "ロイT.フィールディングデーソフトウェア5251カリフォルニアアベニュー、スイート110アーバイン、CA 92617 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-949-679-2960 Fax: +1-949-679-2972 EMail: fielding@gbiv.com URI: http://roy.gbiv.com/",
      "ja": "電話：+ 1-949-679-2960ファックス：+ 1-949-679-2972 Eメール：fielding@gbiv.com URI：http://roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Larry Masinter Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA",
      "ja": "ラリーMasinter Adob​​e Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-408-536-3024 EMail: LMM@acm.org URI: http://larry.masinter.net/",
      "ja": "電話：+ 1-408-536-3024 Eメール：LMM@acm.org URI：http://larry.masinter.net/"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF's procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 IETF文書の権利に関するIETFの手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}