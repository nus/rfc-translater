{
  "title": {
    "text": "RFC 3089 - A SOCKS-based IPv6/IPv4 Gateway Mechanism",
    "ja": "RFC 3089 - SOCKSベースのIPv6 / IPv4のゲートウェイ機構"
  },
  "number": 3089,
  "created_at": "2019-10-23 12:01:03.951670+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        H. Kitamura\nRequest for Comments: 3089                               NEC Corporation\nCategory: Informational                                       April 2001",
      "raw": true
    },
    {
      "indent": 15,
      "text": "A SOCKS-based IPv6/IPv4 Gateway Mechanism",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a SOCKS-based IPv6/IPv4 gateway mechanism that enables smooth heterogeneous communications between the IPv6 nodes and IPv4 nodes.",
      "ja": "この文書は、IPv6ノードとIPv4ノード間の円滑な異質の通信を可能にするSOCKSベースのIPv6 / IPv4のゲートウェイ機構が記載されています。"
    },
    {
      "indent": 3,
      "text": "It is based on the SOCKS protocol [SOCKSv5]. By applying the SOCKS mechanism to the heterogeneous communications and relaying two \"terminated\" IPv4 and IPv6 connections at the \"application layer\" (the SOCKS server), the SOCKS-based IPv6/IPv4 gateway mechanism is accomplished.",
      "ja": "これは、[SocksV5の】SOCKSプロトコルに基づいています。異種通信にSOCKS機構を適用し、「アプリケーション層」（SOCKSサーバ）における2つの「終了」IPv4およびIPv6接続を中継することにより、SOCKSベースのIPv6 / IPv4のゲートウェイ機構が達成されます。"
    },
    {
      "indent": 3,
      "text": "Since it is accomplished without introducing new protocols, it provides the same communication environment that is provided by the SOCKS mechanism. The same appearance is provided to the heterogeneous communications. No conveniences or functionalities of current communications are sacrificed.",
      "ja": "それは新たなプロトコルを導入することなく達成されるので、SOCKSメカニズムによって提供される同一の通信環境を提供します。同じ外観が不均一通信に提供されます。いいえ便利または現在の通信の機能が犠牲にされていません。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The SOCKS-based IPv6/IPv4 gateway mechanism is based on a mechanism that relays two \"terminated\" IPv4 and IPv6 connections at the \"application layer\" (the SOCKS server); its characteristics are inherited from those of the connection relay mechanism at the application layer and those of the native SOCKS mechanism.",
      "ja": "SOCKSベースのIPv6 / IPv4のゲートウェイ機構は「アプリケーション層」（SOCKSサーバ）の2つの「終了」IPv4およびIPv6接続を中継する機構に基づいています。その特性は、アプリケーション層での接続用リレー機構のものとネイティブSOCKS機構のものから継承されています。"
    },
    {
      "indent": 0,
      "text": "2. Basic SOCKS-based Gateway Mechanism",
      "section_title": true,
      "ja": "2.基本SOCKSベースのゲートウェイメカニズム"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the basic SOCKS-based gateway mechanism.",
      "ja": "図1は、基本的なSOCKSベースのゲートウェイ機構を示しています。"
    },
    {
      "indent": 6,
      "text": "            Client C       Gateway G     Destination D\n         +-----------+     (Server)\n         |Application|\n     +-->+===========+  +-------------+  +-----------+\nsame-+   |*SOCKS Lib*|  |  *Gateway*  |  |Application|\n API +-->+===========+  +=====---=====+  +-----------+\n         | Socket DNS|  | Socket  DNS |  | Socket DNS|\n         +-----------+  +-------------+  +-----------+\n         | [ IPv X ] |  |[IPvX]|(IPvY)|  | ( IPv Y ) |\n         +-----------+  +-------------+  +-----------+\n         |Network I/F|  | Network I/F |  |Network I/F|\n         +-----+-----+  +---+-----+---+  +-----+-----+\n               |            |     |            |\n               +============+     +------------+\n                 socksified           normal\n                 connection         connection\n                (ctrl)+data          data only",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Fig. 1 Basic SOCKS-based Gateway Mechanism",
      "ja": "図1の基本的なSOCKSベースのゲートウェイメカニズム"
    },
    {
      "indent": 3,
      "text": "In this figure, the Client C initiates the communication to the Destination D. Two new functional blocks are introduced and they compose the mechanism.",
      "ja": "この図では、クライアントCは、二つの新しい機能ブロックが導入され、彼らはメカニズムを構成しているD.先への通信を開始します。"
    },
    {
      "indent": 3,
      "text": "One, *Socks Lib*, is introduced into the client side (Client C) (this procedure is called \"socksifying\"). The *Socks Lib* is located between the application layer and the socket layer, and can replace applications' socket APIs and DNS name resolving APIs (e.g., gethostbyname(), getaddrinfo() etc.). There is a mapping table in it for a \"DNS name resolving delegation\" feature (described below). Each socksified application has its own *Socks Lib*.",
      "ja": "一つ、*ソックスのLib *は、（この手順は、「Socks化」と呼ばれている）、クライアント側（クライアントC）に導入されます。 *ソックスのLib *は、アプリケーション層とソケット層との間に配置され、そしてアプリケーションのソケットAPIおよびAPIを解決するDNS名（例えば、のgethostbyname（）はgetaddrinfo（）等）を交換することができます。マッピングテーブルは、（後述の）「DNS名の解決委任」機能のためにそれです。各ソケット化アプリケーションは*独自の*ソックスのLibを持っています。"
    },
    {
      "indent": 3,
      "text": "The other, *Gateway*, is installed on the IPv6 and IPv4 dual stack node (Gateway G). It is an enhanced SOCKS server that enables any types of protocol combination relays between Client C (IPvX) and Destination D (IPvY). When the *Socks Lib* invokes a relay, one corresponding *Gateway* process (thread) is spawned from the parent *Gateway* to take charge of the relay connection.",
      "ja": "その他、*ゲートウェイ*、IPv6およびIPv4デュアルスタックノード（ゲートウェイG）にインストールされています。これは、クライアントC（IPvX）と宛先D（IPvY）との間のプロトコルの組み合わせリレーの任意のタイプのを可能に拡張SOCKSサーバです。 *ソックスのLib *リレーを呼び出すと、1つの対応*ゲートウェイ・プロセス（スレッド）は、中継接続を担当する親*ゲートウェイ*から生み出されます。"
    },
    {
      "indent": 3,
      "text": "The following four types of combinations of IPvX and IPvY are possible in the mechanism.",
      "ja": "IPvXとIPvYの組み合わせの次の4つのタイプの機構が可能です。"
    },
    {
      "indent": 4,
      "text": "type C ------ G ------ D\n       [IPvX]   (IPvY)\n A      IPv4     IPv4       homogeneous (normal SOCKS)\n B      IPv4     IPv6     * heterogeneous *\n C      IPv6     IPv4     * heterogeneous *\n D      IPv6     IPv6       homogeneous",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Type A is supported by the normal SOCKS mechanism. Type B and C are the main targets for the SOCKS-based IPv6/IPv4 gateway mechanism. They provide heterogeneous communications. Type D can be supported by the natural extension of the SOCKS mechanism, because it is a homogeneous communication.",
      "ja": "タイプAは、通常のSOCKSメカニズムによってサポートされています。タイプB及びCは、SOCKSベースのIPv6 / IPv4のゲートウェイ機構のための主要な標的です。彼らは、異種の通信を提供します。それは、均質な通信であるので、タイプDは、SOCKS機構の自然な拡張によってサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "Since the *Socks Lib* communicates with the *Gateway* by using SOCKS protocol [SOCKSv5], the connection between them (the Client C and the Gateway G) is a special connection and is called a \"socksified connection\". It can transfer not only data but also control information (e.g., the location information of Destination D).",
      "ja": "*ソックスのLib *がSOCKSプロトコル[SocksV5の]を使用して*ゲートウェイと通信するので、それらの間の接続（クライアントCとゲートウェイG）は、特殊な接続であり、「socks化接続」と呼ばれています。それだけではないデータを転送するだけでなく、情報を制御することができる（例えば、宛先Dの位置情報）。"
    },
    {
      "indent": 3,
      "text": "The connection between the Gateway G and the Destination D is a normal connection. It is not modified (socksified). A server application that runs on Destination D does not notice the existence of the Client C. It recognizes that the peer node of the connection is the Gateway G (not Client C).",
      "ja": "ゲートウェイGと宛先Dの間の接続は通常の接続です。それは、（socks化）に変更されていません。宛先D上で動作するサーバアプリケーションは、接続のピア・ノードがゲートウェイG（ないクライアントC）であることを認識し、クライアントCの存在に気づきません。"
    },
    {
      "indent": 3,
      "text": "No new protocols are introduced to the SOCKS protocol [SOCKSv5] to accomplish the mechanism.",
      "ja": "新しいプロトコルは、機構を達成するためにSOCKSプロトコル[SocksV5の]に導入されていません。"
    },
    {
      "indent": 3,
      "text": "* Packet Size Adjustment",
      "ja": "*パケットサイズ調整"
    },
    {
      "indent": 5,
      "text": "Since the length of the IPv6 header is different from that of the IPv4 header, it is necessary to consider the packet size adjustment in heterogeneous communications. If this is not taken into consideration, the packet size may exceed the MTU of the network.",
      "ja": "IPv6ヘッダーの長さは、IPv4ヘッダーのものとは異なるので、異種通信におけるパケットサイズ調整を考慮する必要があります。これを考慮していない場合、パケットサイズはネットワークのMTUを超えてもよいです。"
    },
    {
      "indent": 5,
      "text": "In the SOCKS-based IPv6/IPv4 gateway mechanism, it never exceeds the MTU, because the mechanism is based on relaying two \"terminated\" connections at the \"application layer\". The relayed data is a simple data stream for the application, and the packet size is naturally adjusted at each relayed connection side.",
      "ja": "機構は、「アプリケーション層」の2つの「終了」接続を中継に基づいているためSOCKSベースのIPv6 / IPv4のゲートウェイ機構においては、MTUを超えることはありません。中継されたデータは、アプリケーションのための単純なデータストリームであり、パケットサイズは当然、各中継接続側に調整されます。"
    },
    {
      "indent": 3,
      "text": "* Authenticated Relay",
      "ja": "*認証リレー"
    },
    {
      "indent": 5,
      "text": "Since the SOCKS is originally designed for firewall systems and it has various authentication methods, the relayed connections can be authenticated by the native SOCKS authentication methods.",
      "ja": "SOCKSは、もともとファイアウォールシステム用に設計されており、それがさまざまな認証方法を持っているので、中継接続は、ネイティブのSOCKSの認証方法によって認証することができます。"
    },
    {
      "indent": 0,
      "text": "3. DNS Name Resolving Procedure",
      "section_title": true,
      "ja": "3. DNS名前解決手順"
    },
    {
      "indent": 3,
      "text": "In all communication applications, it is a necessary to obtain destination IP address information to start a communication. It is, however, theoretically impossible for the heterogeneous communications to obtain correct information, because an existing IPv4 application can not deal with an IPv6 address. It prepares only a 4-byte address space to store an IP address information, and it can not store an IPv6 address information into there. This is a critical problem caused by differences in address length.",
      "ja": "すべての通信アプリケーションでは、通信を開始する宛先IPアドレス情報を取得する必要があります。既存のIPv4アプリケーションがIPv6アドレスを扱うことができないので、異種通信は、正しい情報を取得することは、しかし、理論的には不可能です。これは、IPアドレス情報を格納するための唯一の4バイトのアドレス空間を作成し、そこにIPv6アドレス情報を格納することはできません。これは、アドレスの長さの違いに起因する重大な問題です。"
    },
    {
      "indent": 3,
      "text": "In order to solve the problem, a feature called \"DNS name resolving delegation\" is used in the SOCKS-based IPv6/IPv4 gateway mechanism. The feature involves the delegating of DNS name resolving actions at the source node (Client C) to the relay server (Gateway G). Since the relay server is an IPv4 and IPv6 dual stack node, DNS name resolving queries for any address family types of destinations can be made without causing any problems. Therefore, it is not necessary to modify the existing DNS mechanism at all.",
      "ja": "この問題を解決するために、「DNSの名前解決の委任」と呼ばれる機能は、SOCKSベースのIPv6 / IPv4のゲートウェイメカニズムで使用されています。特徴は、中継サーバ（ゲートウェイG）にソースノード（クライアントC）でのDNS名解決アクションの委任を含みます。リレーサーバは、IPv4とIPv6のデュアルスタックノードであるので、目的地のいずれかのアドレスファミリータイプのためのクエリを解決するDNS名は問題なく行うことができます。したがって、すべての既存のDNSの仕組みを変更する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The feature supports not only the case in which a destination logical host name (FQDN) information is given but also the case in which a destination literal (numerical) IP address is given. The latter case is supported in almost the same way as the former case. Since the literal IPv6 address expression includes colons (\":\"), it is identified as an FQDN (not a literal IPv4 address) for the IPv4 application.",
      "ja": "特徴は、宛先論理ホスト名（FQDN）の情報が与えられた場合も先リテラル（数値）IPアドレスが与えられている場合だけでなく、サポートしています。後者の場合は、前者の場合とほぼ同じ方法で支持されています。リテラルIPv6アドレス式はコロン（「：」）を含むので、IPv4のアプリケーションのFQDN（ないリテラルIPv4アドレス）として識別されます。"
    },
    {
      "indent": 3,
      "text": "The SOCKS protocol specification [SOCKSv5] defines that IPv4 address, IPv6 address, and DOMAINNAME (FQDN) information can be used in the ATYP (address type) field of the SOCKS protocol format. In the \"DNS name resolving delegation\" feature, the DOMAINNAME (FQDN) information is used in the ATYP (address type) field. The FQDN information is transferred from the Client C to the Gateway G to indicate the Destination D.",
      "ja": "SOCKSプロトコル仕様[SocksV5の]は、IPv4アドレス、IPv6アドレス、およびDOMAINNAME（FQDN）情報がSOCKSプロトコルフォーマットのATYP（アドレスタイプ）フィールドで使用することができることを規定しています。 「DNS名の解決委任」機能では、DOMAINNAME（FQDN）の情報がATYP（アドレスタイプ）フィールドで使用されています。 FQDN情報は、宛先Dを示すために、ゲートウェイGへのクライアントCから転送され"
    },
    {
      "indent": 3,
      "text": "In order to solve the formerly explained critical problem, an appropriate \"fake IP\" address is introduced in the feature, and it is used as a virtual destination IP address for a socksified application. A mapping table is also introduced in the *Socks Lib* (at the Client C) to manage mappings between \"fake IP\" and \"FQDN\". A \"fake IP\" address is used as a key to look up the corresponding \"FQDN\" information. The mapping table is local and independent of other applications or their *Socks Lib*s.",
      "ja": "以前は重大な問題を説明し解決するために、適切な「偽のIP」アドレスが機能で導入され、それはsocks化アプリケーションの仮想宛先IPアドレスとして使用されます。マッピングテーブルは、「偽IP」と「FQDN」との間のマッピングを管理するために、（クライアントCで）*ソックスのLib *で導入されます。 「偽のIP」アドレスは、対応する「FQDN」の情報を調べるためのキーとして使用されています。マッピングテーブルは、ローカルおよび他のアプリケーションやその*ソックスのLib * Sとは無関係です。"
    },
    {
      "indent": 3,
      "text": "The transparentness to applications is maintained in the feature. Nothing special is required to execute it except socksifying the applications. Since DNS name resolving APIs are replaced by the *Socks Lib*, the \"DNS name resolving delegation\" is executed internally merely by calling the DNS name resolving APIs in ordinal methods.",
      "ja": "アプリケーションへのtransparentnessは機能が維持されます。特別なことは何もアプリケーションをSocks化以外にそれを実行するために必要とされません。 DNS名の解決APIは*ソックスのLib *に置き換えられているので、「委任を解決するDNS名は」序方法でAPIを解決するDNS名を呼び出すことにより、内部だけで実行されます。"
    },
    {
      "indent": 3,
      "text": "The \"DNS name resolving delegation\" is accomplished only when FQDN information is used in the ATYP (address type) field of the SOCKS command. Therefore, it is mandatory to do so for heterogeneous communications. The method of using FQDN information in the ATYP field depends on the configuration setting and implementation of the SOCKS protocol. In order to simplify the discussion, only the case in which the FQDN information is used in the ATYP field is discussed here.",
      "ja": "「委任を解決するDNS名が」FQDN情報がSOCKSコマンドのATYP（アドレスタイプ）分野で使用されている場合にのみ達成されます。したがって、異種通信のためにそうすることが必須です。 ATYPフィールドにFQDN情報を使用する方法は、SOCKSプロトコルの構成設定および実装に依存します。議論を簡単にするために、FQDN情報はATYPフィールドで使用された場合のみ、ここで議論されています。"
    },
    {
      "indent": 3,
      "text": "The detailed internal procedure of the \"DNS name resolving delegation\" and address mapping management related issues are described as follows.",
      "ja": "次のように「DNS名の解決委任」とアドレスマッピング管理に関連する問題の詳細な内部手順が説明されています。"
    },
    {
      "indent": 3,
      "text": "1. An application on the source node (Client C) tries to get the IP address information of the destination node (Destination D) by calling the DNS name resolving function (e.g., gethostbyname()). At this time, the logical host name (\"FQDN\") information of the Destination D is passed to the application's *Socks Lib* as an argument of called APIs.",
      "ja": "1.ソースノード（クライアントC）上のアプリケーションは、DNS名前解決機能（例えば、のgethostbyname（））を呼び出すことによって、宛先ノード（宛先D）のIPアドレス情報を取得しよう。このとき、先Dの論理ホスト名（「FQDN」）の情報が呼び出されたAPIの引数として、アプリケーションの*ソックスのLib *に渡されます。"
    },
    {
      "indent": 3,
      "text": "2. Since the *Socks Lib* has replaced such DNS name resolving APIs, the real DNS name resolving APIs is not called here. The argued \"FQDN\" information is merely registered into a mapping table in *Socks Lib*, and a \"fake IP\" address is selected as information that is replied to the application from a reserved special IP address space that is never used in real communications (e.g., 0.0.0.x). The address family type of the \"fake IP\" address must be suitable for requests called by the applications. Namely, it must belong to the same address family of the Client C, even if the address family of the Destination D is different from it. After the selected \"fake IP\" address is registered into the mapping table as a pair with the \"FQDN\", it is replied to the application.",
      "ja": "2. *ソックスのLib *がAPIを解決するようにDNS名を置き換えていますので、APIを解決本当のDNS名は、ここでは呼び出されません。主張「FQDN」の情報は、単に*ソックスのLib *にマッピングテーブルに登録され、「偽のIP」アドレスは、実際の通信に使用されることはありません予約済みの特殊なIPアドレス空間からアプリケーションに応答する情報として選択されています（たとえば、0.0.0.x）。 「偽のIP」アドレスのアドレスファミリータイプは、アプリケーションによって呼び出された要求に適していなければなりません。すなわち、それは先のDのアドレスファミリーがそれと異なっている場合でも、クライアントCの同じアドレスファミリーに属している必要があります。選択された「偽のIP」アドレスが「FQDN」と対にマッピングテーブルに登録された後、それをアプリケーションに答えています。"
    },
    {
      "indent": 3,
      "text": "3. The application receives the \"fake IP\" address, and prepares a \"socket\". The \"fake IP\" address information is used as an element of the \"socket\". The application calls socket APIs (e.g., connect()) to start a communication. The \"socket\" is used as an argument of the APIs.",
      "ja": "3.アプリケーションは、「偽のIP」アドレスを受け取り、「ソケット」を準備します。 「偽のIP」アドレス情報は、「ソケット」の要素として使用されています。アプリケーションが通信を開始する（例えば、）（接続）ソケットAPIを呼び出します。 「ソケット」は、APIの引数として使用されています。"
    },
    {
      "indent": 3,
      "text": "4. Since the *Socks Lib* has replaced such socket APIs, the real socket function is not called. The IP address information of the argued socket is checked. If the address belongs to the special address space for the fake address, the matched registered \"FQDN\" information of the \"fake IP\" address is obtained from the mapping table.",
      "ja": "4. *ソックスのLib *は、このようなソケットAPIを置き換えているため、実際のソケット関数が呼び出されません。主張ソケットのIPアドレス情報がチェックされます。アドレスは、偽のアドレスのための特別なアドレス空間に属している場合、「偽のIP」アドレスの一致登録「FQDN」の情報は、マッピングテーブルから取得されます。"
    },
    {
      "indent": 3,
      "text": "5. The \"FQDN\" information is transferred to the *Gateway* on the relay server (Gateway G) by using the SOCKS command that is matched to the called socket APIs. (e.g., for connect(), the CONNECT command is used.)",
      "ja": "5.「FQDN」情報と呼ばれるソケットAPIに適合されているSOCKSコマンドを使用して、中継サーバ（ゲートウェイG）上*ゲートウェイ*に転送されます。 （例えば、（）を接続するために、CONNECTコマンドが使用されています。）"
    },
    {
      "indent": 3,
      "text": "6. Finally, the real DNS name resolving API (e.g., getaddrinfo()) is called at the *Gateway*. At this time, the received \"FQDN\" information via the SOCKS protocol is used as an argument of the called APIs.",
      "ja": "6.最後に、APIを解決する本当のDNS名（たとえば、getaddrinfoは（））は、* *ゲートウェイで呼ばれています。この時点で、SOCKSプロトコルを介して受信した「FQDN」情報と呼ばれるのAPIの引数として使用されます。"
    },
    {
      "indent": 3,
      "text": "7. The *Gateway* obtains the \"real IP\" address from a DNS server, and creates a \"socket\". The \"real IP\" address information is used as an element of the \"socket\".",
      "ja": "7. *ゲートウェイ*は、DNSサーバから「本当のIP」アドレスを取得し、「ソケット」を作成します。 「本当のIP」アドレス情報は、「ソケット」の要素として使用されています。"
    },
    {
      "indent": 3,
      "text": "8. The *Gateway* calls socket APIs (e.g., connect()) to communicate with the Destination D. The \"socket\" is used as an argument of the APIs.",
      "ja": "8. *ゲートウェイ*呼び出しソケットAPI（例えば、接続（））のAPIの引数として使用された宛先D.「ソケット」と通信します。"
    },
    {
      "indent": 3,
      "text": "The problem with the feature is that failures of the DNS name resolving process are detected incorrectly at the source node (Client C). They are detected as connection-establishment failures.",
      "ja": "機能の問題点は、DNS名を解決するプロセスの障害がソースノード（クライアントC）で誤検出されることです。これらは、コネクション確立の失敗として検出されます。"
    },
    {
      "indent": 3,
      "text": "(Restrictions on applicability of \"fake IP\" address, etc., are described in Section 5.)",
      "ja": "（「偽のIP」アドレス等の適用性の制限は、第5節で説明されています）"
    },
    {
      "indent": 3,
      "text": "* Operations for Address Management (reservation, mapping etc.)",
      "ja": "*アドレスの管理のためのオペレーション（予約、マッピングなど）"
    },
    {
      "indent": 3,
      "text": "The SOCKS-based gateway mechanism does not require the reserving of a wide global address space for the address mapping, and complex address allocation and garbage-collection mechanisms are not necessary.",
      "ja": "SOCKSベースのゲートウェイ機構は、アドレスマッピングのための広いグローバルアドレス空間の貯留を必要とせず、複雑なアドレスの割り当てとガベージコレクション機構は不要です。"
    },
    {
      "indent": 3,
      "text": "Such address management operations are done at the *Socks Lib* by using the fake IP address and the mapping table for the DNS name resolving delegation. Since the mapping table is prepared in each application, it is locally closed and independent of other applications. Therefore, it is easy to manage the table, and it is not necessary to reserve a wide global address space.",
      "ja": "このようなアドレス管理操作は、偽のIPアドレスと委任を解決するDNS名のマッピングテーブルを使用して*ソックスのLib *で行われます。マッピングテーブルは、各アプリケーションで調製されるので、局所的に閉じられ、他のアプリケーションから独立しています。したがって、テーブルを管理することは容易であり、全体のグローバルアドレス空間を確保する必要はありません。"
    },
    {
      "indent": 0,
      "text": "4. Multiple Chained Relay Mechanism (Advanced usage)",
      "section_title": true,
      "ja": "4.複数の連鎖リレーメカニズム（上級使い方）"
    },
    {
      "indent": 3,
      "text": "The SOCKS-based gateway mechanism has the flexibility to support multiple chained relay topologies. With the mechanism, IPv4 and IPv6 mixed various communication topologies are accomplished.",
      "ja": "SOCKSベースのゲートウェイ機構が、複数の連鎖リレートポロジをサポートするための柔軟性を有します。機構で、IPv4とIPv6の混合様々な通信トポロジが達成されます。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows the structure of the multiple chained relay mechanism.",
      "ja": "図2は、複数の連鎖リレー機構の構造を示します。"
    },
    {
      "indent": 5,
      "text": "   Client C       Gateway G1       Gateway G2    Destination D\n+-----------+     (Server 1)       (Server 2)\n|Application|\n+===========+  +-------------+  +-------------+  +-----------+\n|*SOCKS Lib*|  |  *Gateway1* |  |  *Gateway2* |  |Application|\n+===========+  +=====---=====+  +=====---=====+  +-----------+\n| Socket DNS|  | Socket  DNS |  | Socket  DNS |  | Socket DNS|\n+-----------+  +-------------+  +-------------+  +-----------+\n| [ IPv X ] |  |[IPvX]|(IPvY)|  |(IPvY)|{IPvZ}|  | { IPv Z } |\n+-----------+  +-------------+  +-------------+  +-----------+\n|Network I/F|  | Network I/F |  | Network I/F |  |Network I/F|\n+-----+-----+  +---+-----+---+  +---+-----+---+  +-----+-----+\n      |            |     |          |     |            |\n      +============+     +==========+     +------------+\n        socksified        socksified          normal\n        connection        connection        connection\n       (ctrl)+data       (ctrl)+data         data only",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Fig. 2 Multiple Chained Relay Mechanism",
      "ja": "図2は、複数の連鎖リレー機構"
    },
    {
      "indent": 3,
      "text": "In this figure, the source node (Client C) initiates the communication with the destination (Destination D). Underneath, the connection is replaced with three connections, and they are relayed at the two relay servers (Gateway G1 and G2). The *Gateway* includes the same type of functions of *Socks Lib*. By enabling the *Socks Lib* functions at the *Gateway1* on the first relay server (Gateway G1), the multiple chained relay topology is accomplished.",
      "ja": "この図では、ソースノード（クライアントC）は、デスティネーション（宛先D）との通信を開始します。下に、接続が3つの接続に置き換えられ、これらは2台の中継サーバ（ゲートウェイG1及びG2）に中継されます。 *ゲートウェイは、* * *ソックスのLibの機能の同じタイプを含んでいます。第1中継サーバ（ゲートウェイG1）上* Gateway1で*ソックスのLib *機能を有効にすることによって、複数の連鎖リレートポロジが達成されます。"
    },
    {
      "indent": 3,
      "text": "There is no limitation on the number of relay operations between the source node and the final destination node. It is possible to have more than two intermediate relay servers. To simplify the explanation, a twice-relayed topology is shown here.",
      "ja": "ソースノードと、最終宛先ノードとの間の中継動作の数に制限はありません。二つ以上の中間中継サーバを持つことが可能です。説明を簡単にするため、二回-中継トポロジーがここに表示されます。"
    },
    {
      "indent": 3,
      "text": "Since the multiple chained relay is more complex than one-time relay and causes complexity, it is recommended that the multiple chained relay communication should be used only when it is necessary for some reason (e.g., usable protocols or topologies are limited by routers etc.).",
      "ja": "複数の連鎖リレーワンタイムリレーよりも複雑であり、複雑さの原因となるので、複数の連鎖リレー通信は、それが、例えば、使用可能なプロトコルまたはトポロジ等ルータによって制限されるいくつかの理由（必要である場合にのみ使用されるべきであることが推奨されます）。"
    },
    {
      "indent": 0,
      "text": "5. Applicability statement",
      "section_title": true,
      "ja": "5.適用性声明"
    },
    {
      "indent": 3,
      "text": "The SOCKS-based gateway mechanism requests socksification of applications (install *Socks Lib*) to accomplish heterogeneous communications. It is not necessary to modify (change source codes and recompile them, etc.) the applications, because typical socksification is done by changing the linking order of dynamic link libraries (specifically, by linking the SOCKS dynamic link library before the dynamic link libraries for normal socket and DNS name resolving APIs).",
      "ja": "SOCKSベースのゲートウェイ機構は、異種の通信を達成するために（*ソックスのLib *をインストール）アプリケーションのsocksificationを要求します。典型的socksificationは用のダイナミックリンクライブラリ前SOCKSダイナミック・リンク・ライブラリをリンクすることによって、具体的には、ダイナミックリンクライブラリ（の連結順序を変更することによって行われるため、（等彼ら、変更ソースコード及び再コンパイル）アプリケーションを変更する必要はありません通常のソケットとDNS名の解決のAPI）。"
    },
    {
      "indent": 3,
      "text": "The mechanism does not request modification of the DNS system, because the DNS name resolving procedure at the Client C is delegated to the dual stack node Gateway G.",
      "ja": "クライアントCで手順を解決するDNS名は、デュアルスタックノードゲートウェイGに委任されているため、機構は、DNSシステムの修正を要求しません"
    },
    {
      "indent": 3,
      "text": "Other than the socksification, the SOCKS-based gateway mechanism has the following three types of constraints.",
      "ja": "socksification以外、SOCKSベースのゲートウェイ機構は、制約の次の3種類を有しています。"
    },
    {
      "indent": 3,
      "text": "1. Essential constraints:",
      "section_title": true,
      "ja": "1.エッセンシャル制約："
    },
    {
      "indent": 6,
      "text": "Constraints are caused by the address length difference between IPv4 and IPv6.",
      "ja": "制約は、IPv4とIPv6との間のアドレスの長さの差によって引き起こされます。"
    },
    {
      "indent": 6,
      "text": "Functions that request an IP address as one of the return values (e.g., getpeername() and getsockname() etc.) can not provide the correct IP address as a return value. However, a suitable port value can be provided, because IPv4 and IPv6 use the same size port space and an appropriate port information is transferred by the SOCKS protocol.",
      "ja": "戻り値の一つとして、IPアドレスを要求する機能（例えば、getpeername（）とのgetsockname（）など）が戻り値として正しいIPアドレスを提供することができません。しかし、IPv4とIPv6が同じサイズポートスペースを使用するための適切なポート値を提供することができ、適切なポート情報がSOCKSプロトコルによって転送されます。"
    },
    {
      "indent": 3,
      "text": "2. Constraints of the SOCKS mechanism:",
      "section_title": true,
      "ja": "SOCKSメカニズムの2.制約："
    },
    {
      "indent": 6,
      "text": "Since the current SOCKS system can not socksify all of the tricky applications in which extraordinary manners are used to create connections, the SOCKS-based gateway mechanism can not be applied to them.",
      "ja": "現在SOCKSシステムが異常なマナーが接続を作成するために使用されるトリッキーなアプリケーションの全てをsocksifyことができないので、SOCKSベースのゲートウェイ機構が、それらには適用できません。"
    },
    {
      "indent": 3,
      "text": "3. Constraints to deal with the fake address:",
      "section_title": true,
      "ja": "偽のアドレスに対処する3.制約："
    },
    {
      "indent": 6,
      "text": "The fake address must be dealt with as a temporary value at the application. It is used as a key value in the mapping table for the \"DNS name resolving delegation\" feature. When the application is finished and the mapping table disappears, the fake address information must be also released.",
      "ja": "偽のアドレスは、アプリケーションでの一時的な値として扱われなければなりません。これは、機能「委任を解決するDNS名」のマッピングテーブルのキー値として使用されます。アプリケーションが終了すると、マッピングテーブルが消えているときは、偽のアドレス情報も解放されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Even if it is recorded permanently (e.g., recorded as a bookmark), serious problems will not occur. The recorded fake address information will merely become useless, because fake address information is taken from a reserved special IP address space that is never used in real communications (e.g., 0.0.0.x) and such a information is useless for the normal communication applications. Furthermore, such cases will be rare because most applications usually record FQDN information (not fake IP address information) to the bookmark, etc.",
      "ja": "それは（例えば、ブックマークとして記録）永久に記録されている場合であっても、深刻な問題が発生しません。偽のアドレス情報は、実際の通信（例えば、0.0.0.x）で使用されることはありません予約済みの特殊なIPアドレス空間から取られているので、記録偽のアドレス情報は、単に、無用になり、そのような情報は、通常の通信アプリケーションのための役に立ちません。ほとんどのアプリケーションは通常、ブックマークなどへのFQDN情報（偽のないIPアドレス情報）を記録するのでさらに、このようなケースは稀だろう"
    },
    {
      "indent": 0,
      "text": "5.1 Native SOCKS mechanism considerations",
      "section_title": true,
      "ja": "5.1ネイティブSOCKSメカニズムの検討事項"
    },
    {
      "indent": 3,
      "text": "The characteristics of the SOCKS-based IPv6/IPv4 gateway mechanism are inherited from those of the native SOCKS mechanism. Therefore, consideration issues of the native SOCKS mechanism are discussed in this section.",
      "ja": "SOCKSベースのIPv6 / IPv4のゲートウェイ機構の特性は、ネイティブSOCKS機構のものから継承されています。したがって、ネイティブSOCKSメカニズムの検討の問題は、このセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "The SOCKSv5 protocol is composed of three commands (CONNECT, BIND and UDP ASSOCIATE). All of three commands can be applied in the SOCKS-based IPv6/IPv4 gateway mechanism.",
      "ja": "SocksV5のプロトコルは三つのコマンド（CONNECT、BINDとUDP ASSOCIATE）から構成されています。三つのコマンドの全てがSOCKSベースのIPv6 / IPv4のゲートウェイ機構に適用することができます。"
    },
    {
      "indent": 3,
      "text": "This document is described with assuming the usage of the CONNECT command mainly, because the CONNECT command is the main and most frequently used command in the SOCKS mechanism. Since the CONNECT command does not have clear week points, we can use it freely without considerations.",
      "ja": "CONNECTコマンドはSOCKS機構における主と最も頻繁に使用されるコマンドであるため、この文書は、主にCONNECTコマンドの使用を想定して説明します。 CONNECTコマンドが明確な週のポイントを持っていないので、我々は配慮せずに自由に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The other (BIND and UDP ASSOCIATE) commands have the following weak points. So, we have to consider these points when we use the BIND or UDP ASSOCIATE commands in the mechanism.",
      "ja": "（BINDとUDP ASSOCIATE）他のコマンドは、以下の弱点を持っています。だから、我々はメカニズムでBINDまたはUDP ASSOCIATEコマンドを使用するときは、次の点を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "The BIND command is basically designed to support reverse-channel rendezvous of the FTP type applications. So, general usages of the BIND command may cause problems.",
      "ja": "BINDコマンドは、基本的にFTPのタイプのアプリケーションの逆チャネルランデブーをサポートするように設計されています。だから、BINDコマンドの一般的な使用法は、問題が発生することがあります。"
    },
    {
      "indent": 3,
      "text": "The UDP ASSOCIATE command is basically designed for simple UDP applications (e.g., archie). It is not general enough to support a large class of applications that use both TCP and UDP.",
      "ja": "UDPアソシエイトコマンドは基本的に単純なUDPアプリケーション（例えば、アーチー）のために設計されています。 TCPとUDPの両方を使用するアプリケーションの大規模なクラスをサポートするのに十分な一般的ではありません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Since the SOCKS-based IPv6/IPv4 gateway mechanism is based on SOCKSv5 protocol, the security feature of the mechanism matches that of SOCKSv5. It is described in the Security Considerations section of the SOCKS Protocol Version 5 [SOCKSv5].",
      "ja": "SOCKSベースのIPv6 / IPv4のゲートウェイ機構がSocksV5のプロトコルに基づいているため、機構のセキュリティ機能はSocksV5ののものと一致します。それは、SOCKSプロトコルバージョン5 [SocksV5の]のSecurity Considerations部に記述されています。"
    },
    {
      "indent": 3,
      "text": "The mechanism is based on relaying two \"terminated\" connections at the \"application layer\". The end-to-end security is maintained at each of the relayed connections (i.e., between Client C and Gateway G, and between Gateway G and Destination D). The mechanism does not provide total end-to-end security relay between the original source (Client C) and the final destination (Destination D).",
      "ja": "機構は、「アプリケーション層」の2つの「終了」接続を中継に基づいています。エンドツーエンドのセキュリティ（すなわち、クライアントCとゲートウェイGの間、ゲートウェイGと宛先Dの間の）中継接続のそれぞれで維持されます。機構は、元のソース（クライアントC）と最終的な宛先（宛先D）との合計のエンドツーエンドのセキュリティリレーを提供しません。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Implementations",
      "ja": "付録A.実装"
    },
    {
      "indent": 3,
      "text": "Currently, there are two independent implementations of the SOCKS-based IPv6/IPv4 gateway mechanism. Both of them are open to the public.",
      "ja": "現在、SOCKSベースのIPv6 / IPv4のゲートウェイ機構の二つの独立した実装が存在します。それらの両方は、一般に公開されています。"
    },
    {
      "indent": 3,
      "text": "One is NEC's implementation. Its source codes are available at the following URL.",
      "ja": "一つは、NECの実装です。そのソースコードは、次のURLで入手できます。"
    },
    {
      "indent": 12,
      "text": "http://www.socks.nec.com/",
      "ja": "ｈっｔｐ：／／ｗっｗ。そｃｋｓ。ねｃ。こｍ／"
    },
    {
      "indent": 3,
      "text": "The other is Fujitsu Lab.'s implementation, which is called \"SOCKS64\". Its source codes are available at the following URL.",
      "ja": "他には「SOCKS64」と呼ばれている富士通研。の実装です。そのソースコードは、次のURLで入手できます。"
    },
    {
      "indent": 12,
      "text": "ftp://ftp.kame.net/pub/kame/misc/socks64-...",
      "ja": "ｆｔｐ：／／ｆｔｐ。かめ。ねｔ／ぷｂ／かめ／みｓｃ／そｃｋｓ６４ー。。。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[SOCKSv5] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D. and L. Jones, \"SOCKS Protocol V5\", RFC 1928, April 1996.",
      "ja": "[SocksV5の]リーチ、M.、Ganis、M.、リー、Y.、Kuris、R.、Koblas、D.およびL.ジョーンズ、 \"SOCKSプロトコルV5\"、RFC 1928、1996年4月。"
    },
    {
      "indent": 3,
      "text": "[TRANSMECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for IPv6 Hosts and Routers\", RFC 2893, August 2000.",
      "ja": "【TRANSMECH]ギリガン、R.およびE. Nordmarkと、 \"IPv6ホストとルータの移行メカニズム\"、RFC 2893、2000年8月。"
    },
    {
      "indent": 3,
      "text": "[IPv6] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[IPv6の]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[INET99] H. Kitamura, \"Entering the IPv6 communication world by the SOCKS-based IPv6/IPv4 Translator\", in Proceedings of INET99, July 1999.",
      "ja": "[INET99] H.北村、INET99、1999年7月の議事録では、 \"SOCKSベースのIPv6 / IPv4トランスレータにより、IPv6通信の世界を入力します\"。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hiroshi Kitamura NEC Corporation Development Laboratories (Igarashi Building 4F) 11-5, Shibaura 2-Chome, Minato-Ku, Tokyo 108-8557, JAPAN",
      "ja": "ひろし きたむら ねＣ こｒぽらちおん でゔぇぉｐめんｔ ぁぼらとりえｓ （いがらし ぶいｌぢんｇ ４Ｆ） １１ー５、 しばうら ２ーちょめ、 みなとーく、 ときょ １０８ー８５５７、 じゃぱん"
    },
    {
      "indent": 3,
      "text": "Phone: +81 (3) 5476-1071 Fax: +81 (3) 5476-1005 EMail: kitamura@da.jp.nec.com",
      "ja": "電話：+81（3）5476-1071ファックス：+81（3）5476-1005 Eメール：kitamura@da.jp.nec.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}