{
  "title": {
    "text": "RFC 3539 - Authentication, Authorization and Accounting (AAA) Transport Profile",
    "ja": "RFC 3539 - 認証、認可およびアカウンティング（AAA）のトランスポート・プロファイル"
  },
  "number": 3539,
  "created_at": "2019-10-19 10:10:45.846393+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           B. Aboba\nRequest for Comments: 3539                                     Microsoft\nCategory: Standards Track                                        J. Wood\n                                                  Sun Microsystems, Inc.\n                                                               June 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "Authentication, Authorization and Accounting (AAA) Transport Profile",
      "ja": "認証、認可およびアカウンティング（AAA）のトランスポート・プロファイル"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document discusses transport issues that arise within protocols for Authentication, Authorization and Accounting (AAA). It also provides recommendations on the use of transport by AAA protocols. This includes usage of standards-track RFCs as well as experimental proposals.",
      "ja": "この文書は、認証、認可及びアカウンティング（AAA）のためのプロトコル内で発生輸送の問題を論じています。また、AAAプロトコルによる輸送の使用に関する推奨事項を提供します。これは、標準化過程のRFCの利用だけでなく、実験的な提案を含んでいます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2\n    1.1.  Requirements Language. . . . . . . . . . . . . . . . . .  2\n    1.2.  Terminology. . . . . . . . . . . . . . . . . . . . . . .  2\n2.  Issues in Transport Usage. . . . . . . . . . . . . . . . . . .  5\n    2.1.  Application-driven Versus Network-driven . . . . . . . .  5\n    2.2.  Slow Failover. . . . . . . . . . . . . . . . . . . . . .  6\n    2.3.  Use of Nagle Algorithm . . . . . . . . . . . . . . . . .  7\n    2.4.  Multiple Connections . . . . . . . . . . . . . . . . . .  7\n    2.5.  Duplicate Detection. . . . . . . . . . . . . . . . . . .  8\n    2.6.  Invalidation of Transport Parameter Estimates. . . . . .  8\n    2.7.  Inability to use Fast Re-Transmit. . . . . . . . . . . .  9\n    2.8.  Congestion Avoidance . . . . . . . . . . . . . . . . . .  9\n    2.9.  Delayed Acknowledgments. . . . . . . . . . . . . . . . . 11\n    2.10. Premature Failover . . . . . . . . . . . . . . . . . . . 11\n    2.11. Head of Line Blocking. . . . . . . . . . . . . . . . . . 11\n    2.12. Connection Load Balancing. . . . . . . . . . . . . . . . 12",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3.  AAA Transport Profile. . . . . . . . . . . . . . . . . . . . . 12\n    3.1.  Transport Mappings . . . . . . . . . . . . . . . . . . . 12\n    3.2.  Use of Nagle Algorithm . . . . . . . . . . . . . . . . . 12\n    3.3.  Multiple Connections . . . . . . . . . . . . . . . . . . 13\n    3.4.  Application Layer Watchdog . . . . . . . . . . . . . . . 13\n    3.5.  Duplicate Detection. . . . . . . . . . . . . . . . . . . 19\n    3.6.  Invalidation of Transport Parameter Estimates. . . . . . 20\n    3.7.  Inability to use Fast Re-Transmit. . . . . . . . . . . . 21\n    3.8.  Head of Line Blocking. . . . . . . . . . . . . . . . . . 22\n    3.9.  Congestion Avoidance . . . . . . . . . . . . . . . . . . 23\n    3.10. Premature Failover . . . . . . . . . . . . . . . . . . . 24\n4.  Security Considerations. . . . . . . . . . . . . . . . . . . . 24\n5.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 25\n6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n    6.1.  Normative References . . . . . . . . . . . . . . . . . . 25\n    6.2.  Informative References . . . . . . . . . . . . . . . . . 26\nAppendix A - Detailed Watchdog Algorithm Description . . . . . . . 28\nAppendix B - AAA Agents. . . . . . . . . . . . . . . . . . . . . . 33\n    B.1.  Relays and Proxies . . . . . . . . . . . . . . . . . . . 33\n    B.2.  Re-directs . . . . . . . . . . . . . . . . . . . . . . . 35\n    B.3.  Store and Forward Proxies. . . . . . . . . . . . . . . . 36\n    B.4.  Transport Layer Proxies. . . . . . . . . . . . . . . . . 38\nIntellectual Property Statement. . . . . . . . . . . . . . . . . . 39\nAcknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . 39\nAuthor Addresses . . . . . . . . . . . . . . . . . . . . . . . . . 40\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 41",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document discusses transport issues that arise within protocols for Authentication, Authorization and Accounting (AAA). It also provides recommendations on the use of transport by AAA protocols. This includes usage of standards-track RFCs as well as experimental proposals.",
      "ja": "この文書は、認証、認可及びアカウンティング（AAA）のためのプロトコル内で発生輸送の問題を論じています。また、AAAプロトコルによる輸送の使用に関する推奨事項を提供します。これは、標準化過程のRFCの利用だけでなく、実験的な提案を含んでいます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MAY\", \"MUST, \"MUST NOT\", \"optional\", \"recommended\", \"SHOULD\", and \"SHOULD NOT\", are to be interpreted as described in [RFC2119].",
      "ja": "この文書に記載されている、キーワード \"MAY\"、「MUST、 \"MUST NOT\"、 \"オプション\"、 \"推奨\"、 \"SHOULD\"、および \"the\" はならない、[RFC2119]に記載されているように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "Accounting The act of collecting information on resource usage for the purpose of trend analysis, auditing, billing, or cost allocation.",
      "ja": "トレンド分析、監査、請求、または費用配分の目的のために、リソースの使用状況に関する情報を収集する行為を占めています。"
    },
    {
      "indent": 3,
      "text": "Administrative Domain An internet, or a collection of networks, computers, and databases under a common administration.",
      "ja": "インターネット、または一般的な管理下にあるネットワーク、コンピュータ、およびデータベースの収集管理ドメイン。"
    },
    {
      "indent": 3,
      "text": "Agent A AAA agent is an intermediary that communicates with AAA clients and servers. Several types of AAA agents exist, including Relays, Re-directs, and Proxies.",
      "ja": "エージェントA AAAエージェントは、AAAクライアントとサーバとの通信の仲介です。 AAA剤のいくつかのタイプは、リレー、再指示、およびプロキシを含め、存在します。"
    },
    {
      "indent": 3,
      "text": "Application-driven transport Transport behavior is said to be \"application-driven\" when the rate at which messages are sent is limited by the rate at which the application generates data, rather than by the size of the congestion window. In the most extreme case, the time between transactions exceeds the round-trip time between sender and receiver, implying that the application operates with an effective congestion window of one. AAA transport is typically application driven.",
      "ja": "アプリケーション駆動型輸送トランスポートの動作は、「アプリケーション・ドリブン」メッセージが送信されるレートは、アプリケーションがデータを生成する速度によってではなく、輻輳ウィンドウのサイズによって制限されると言われています。最も極端な場合には、トランザクション間の時間は、アプリケーションが一方の有効な混雑ウィンドウで動作することを意味し、送信者と受信者との間の往復時間を超え。 AAAの輸送は、一般的に駆動型アプリケーションです。"
    },
    {
      "indent": 3,
      "text": "Attribute Value Pair (AVP) The variable length concatenation of a unique Attribute (represented by an integer) and a Value containing the actual value identified by the attribute.",
      "ja": "値ペア（AVP）（整数で表される）固有の属性および属性によって識別される実際の値を含む値の可変長連結属性。"
    },
    {
      "indent": 3,
      "text": "Authentication The act of verifying a claimed identity, in the form of a pre-existing label from a mutually known name space, as the originator of a message (message authentication) or as the end-point of a channel (entity authentication).",
      "ja": "メッセージ（メッセージ認証）の発信元として、またはチャネル（エンティティ認証）のエンドポイントとして、互いに既知の名前空間から既存のラベルの形で、要求されたアイデンティティを検証する行為を認証。"
    },
    {
      "indent": 3,
      "text": "Authorization The act of determining if a particular right, such as access to some resource, can be granted to the presenter of a particular credential.",
      "ja": "認可の場合、このようないくつかのリソースへのアクセスなど、特定の権利を、決定の行為は、特定の資格のプレゼンターに付与することができます。"
    },
    {
      "indent": 3,
      "text": "Billing The act of preparing an invoice.",
      "ja": "請求書を準備する行為を課金。"
    },
    {
      "indent": 3,
      "text": "Network Access Identifier The Network Access Identifier (NAI) is the userID submitted by the host during network access authentication. In roaming, the purpose of the NAI is to identify the user as well as to assist in the routing of the authentication request. The NAI may not necessarily be the same as the user's e-mail address or the user-ID submitted in an application layer authentication.",
      "ja": "ネットワークアクセス識別子[ネットワークアクセス識別子（NAI）はネットワークアクセス認証中にホストから提出されたユーザーIDです。ローミングでは、NAIの目的は、ユーザを識別するために、ならびに認証要求のルーティングを補助することです。 NAIは、必ずしもユーザーの電子メールアドレスまたはアプリケーション層認証に提出し、ユーザーIDと同じではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Network Access Server (NAS) A Network Access Server (NAS) is a device that hosts connect to in order to get access to the network.",
      "ja": "ネットワークアクセスサーバー（NAS）Aネットワークアクセスサーバ（NAS）は、ネットワークへのアクセスを得るためにに接続するホストデバイスです。"
    },
    {
      "indent": 3,
      "text": "Proxy In addition to forwarding requests and responses, proxies enforce policies relating to resource usage and provisioning. This is typically accomplished by tracking the state of NAS devices. While proxies typically do not respond to client Requests prior to receiving a Response from the server, they may originate Reject messages in cases where policies are violated. As a result, proxies need to understand the semantics of the messages passing through them, and may not support all extensions.",
      "ja": "プロキシは、転送要求と応答に加えて、プロキシは、使用してプロビジョニングを資源に関連するポリシーを適用します。これは、典型的には、NASデバイスの状態を追跡することによって達成されます。プロキシは通常、サーバからの応答を受信する前に、クライアントの要求に応答しませんが、彼らは、ポリシーに違反した場合にメッセージを拒否生じてもよいです。その結果、プロキシがそれらを通過するメッセージの意味を理解する必要があり、すべての拡張機能をサポートしていないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Local Proxy A Local Proxy is a proxy that exists within the same administrative domain as the network device (e.g. NAS) that issued the AAA request. Typically a local proxy is used to multiplex AAA messages to and from a large number of network devices, and may implement policy.",
      "ja": "ローカルプロキシAローカルプロキシは、AAA要求を発行したネットワーク装置（例えば、NAS）と同じ管理ドメイン内に存在するプロキシです。典型的には、ローカルプロキシは、ネットワーク機器の数が多いためとからAAAメッセージを多重化するために使用され、ポリシーを実装することができます。"
    },
    {
      "indent": 3,
      "text": "Store and forward proxy Store and forward proxies distinguish themselves from other proxy species by sending a reply to the NAS prior to proxying the request to the server. As a result, store and forward proxies need to implement AAA client and server functionality for the messages that they handle. Store and Forward proxies also typically keep state on conversations in progress in order to assure delivery of proxied Requests and Responses. While store and forward proxies are most frequently deployed for accounting, they also can be used to implement authentication/authorization policy.",
      "ja": "ストアアンドフォワードプロキシストアアンドフォワードプロキシはサーバへのリクエストをプロキシするNAS前に応答を送信することによって、他のプロキシ種から身を区別します。その結果、ストアアンドフォワードプロキシは、彼らが扱うメッセージのためにAAAクライアントとサーバーの機能を実装する必要があります。ストアアンドフォワードプロキシは、典型的には、プロキシ要求および応答の配信を保証するために進行中の会話の状態を保ちます。ストアアンドフォワードプロキシが最も頻繁に会計のために配備されているが、それらはまた、認証/認可ポリシーを実装するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Network-driven transport Transport behavior is said to be \"network driven\" when the rate at which messages are sent is limited by the congestion window, not by the rate at which the application can generate data. File transfer is an example of an application where transport is network driven.",
      "ja": "ネットワーク主導型輸送トランスポートの動作は、メッセージが送信される速度は、輻輳ウィンドウによってではなく、アプリケーションがデータを生成することができる速度によって制限されている場合、「ネットワークが駆動される」と言われています。ファイル転送は、トランスポートがネットワークを駆動するアプリケーションの一例です。"
    },
    {
      "indent": 3,
      "text": "Re-direct Rather than forwarding Requests and Responses between clients and servers, Re-directs refer clients to servers and allow them to communicate directly. Since Re-directs do not sit in the forwarding path, they do not alter any AVPs transitting between client and server. Re-directs do not originate messages and are capable of handling any message type. A Re-direct may be configured only to re-direct messages of certain types, while acting as a Relay or Proxy for other types. As with Relays, re-directs do not keep state with respect to conversations or NAS resources.",
      "ja": "再直接ではなく、クライアントとサーバ間の要求と応答を転送するよりも、サーバーへのクライアントを参照し、それらを直接通信できるように再指示します。再指示は、転送パスに座っていないので、彼らは、クライアントとサーバーの間でtransitting任意のAVPを変更しません。再指示したメッセージを発信し、任意のメッセージタイプを扱うことができるしません。他のタイプのリレーまたはプロキシとして動作しながら、再直接には、特定の種類のみに再直接メッセージを構成することができます。リレーと同様に、再指示会話やNASリソースに関する状態を保持しません。"
    },
    {
      "indent": 3,
      "text": "Relay Relays forward requests and responses based on routing-related AVPs and domain forwarding table entries. Since relays do not enforce policies, they do not examine or alter non-routing AVPs. As a result, relays never originate messages, do not need to understand the semantics of messages or non-routing AVPs, and are capable of handling any extension or message type. Since relays make decisions based on information in routing AVPs and domain forwarding tables they do not keep state on NAS resource usage or conversations in progress.",
      "ja": "ルーティング関連のAVPとドメイン転送テーブルのエントリに基づいてリレーリレー前方要求と応答。リレーはポリシーを強制していないので、彼らは非ルーティングAVPを調べたり、変更されることはありません。その結果、メッセージを発信決してリレー、メッセージまたは非ルーティングのAVPの意味を理解する必要があり、任意の拡張子またはメッセージタイプを処理することができるしません。リレーは、ルーティングのAVPとドメイン転送テーブル内の情報に基づいて意思決定を行うので、彼らは、NASリソースの使用状況や進行中の会話に状態を保持しません。"
    },
    {
      "indent": 0,
      "text": "2. Issues in AAA Transport Usage",
      "section_title": true,
      "ja": "AAA輸送用法2.問題"
    },
    {
      "indent": 3,
      "text": "Issues that arise in AAA transport usage include:",
      "ja": "AAA輸送用法に発生する問題は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Application-driven versus network-driven Slow failover Use of Nagle Algorithm Multiple connections Duplicate detection Invalidation of transport parameter estimates Inability to use fast re-transmit Congestion avoidance Delayed acknowledgments Premature Failover Head of line blocking Connection load balancing",
      "ja": "アプリケーション主導のNagleアルゴリズム複数の接続のネットワーク主導型スローフェイルオーバーの使用に対する接続の負荷分散を遮断未熟フェールオーバヘッドラインの高速再送信輻輳回避遅延確認応答を使用するように、トランスポートパラメータ推定値の無力の検出無効化を重複"
    },
    {
      "indent": 3,
      "text": "We discuss each of these issues in turn.",
      "ja": "私たちは、順番に、これらの問題のそれぞれを議論します。"
    },
    {
      "indent": 0,
      "text": "2.1. Application-driven versus Network-driven",
      "section_title": true,
      "ja": "2.1。アプリケーション主導型ネットワーク主導の対"
    },
    {
      "indent": 3,
      "text": "AAA transport behavior is typically application rather than network driven. This means that the rate at which messages are sent is typically limited by how quickly they are generated by the application, rather than by the size of the congestion window.",
      "ja": "AAA輸送挙動は、一般的に駆動型アプリケーションではなく、ネットワークです。これは、メッセージが送信される速度は、通常、それらがアプリケーションによってではなく、輻輳ウィンドウのサイズによって生成されたどのように迅速で制限されることを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, let us assume a 48-port NAS with an average session time of 20 minutes. This device will, on average, send only 144 authentication/authorization requests/hour, and an equivalent number of accounting requests. This represents an average inter-packet spacing of 25 seconds, which is much larger than the Round Trip Time (RTT) in most networks.",
      "ja": "たとえば、私たちは20分のセッションの平均時間で48ポートNASを想定してみましょう。このデバイスは、平均的に、唯一の144認証/認可要求/時間、およびアカウンティング要求の同等の番号を送信します。これは、ほとんどのネットワークでのラウンドトリップ時間（RTT）よりもはるかに大きい25秒、平均パケット間の間隔を表します。"
    },
    {
      "indent": 3,
      "text": "Even on much larger NAS devices, the inter-packet spacing is often larger than the RTT. For example, consider a 2048-port NAS with an average session time of 10 minutes. It will on average send 3.4 authentication/authorization requests/second, and an equivalent number of accounting requests. This translates to an average inter-packet spacing of 293 ms.",
      "ja": "でも、はるかに大きいNASデバイス上で、パケット間の間隔はRTTよりも大きいことが多いです。例えば、10分の平均セッション時間で2048ポートNASを検討します。これは、平均送信3.4認証/認可リクエスト/秒、およびアカウンティング要求の同等の数になります。これは、293ミリ秒の平均パケット間の間隔に変換されます。"
    },
    {
      "indent": 3,
      "text": "However, even where transport behavior is largely application-driven, periods of network-driven behavior can occur. For example, after a NAS reboot, previously stored accounting records may be sent to the accounting server in rapid succession. Similarly, after recovery from a power failure, users may respond with a large number of simultaneous logins. In both cases, AAA messages may be generated more quickly than the network will allow them to be sent, and a queue will build up.",
      "ja": "しかしながら、輸送挙動は大部分のアプリケーション駆動の場合であっても、ネットワーク主導型の挙動の期間が発生する可能性があります。例えば、NASの再起動後、以前に格納された会計帳簿は矢継ぎ早にアカウンティングサーバに送信することができます。同様に、電源障害から回復した後、ユーザーが同時ログイン数の多い応答することができます。どちらの場合も、AAAメッセージは、ネットワークがそれらを送信することができるようになり、キューが構築されますよりも迅速に生成することができます。"
    },
    {
      "indent": 3,
      "text": "Network congestion can occur when transport behavior is network-driven or application-driven. For example, while a single NAS may not send substantial AAA traffic, many NASes may communicate with a single AAA proxy or server. As a result, routers close to a heavily loaded proxy or server may experience congestion, even though traffic from each individual NAS is light. Such \"convergent congestion\" can result in dropped packets in routers near the AAA server, or even within the AAA server itself.",
      "ja": "輸送の挙動は、ネットワーク主導型またはアプリケーション駆動されると、ネットワークの輻輳が発生する可能性があります。単一のNASは、実質的なAAAトラフィックを送信しないかもしれないが、例えば、多くのNASは、単一のAAAプロキシまたはサーバと通信してもよいです。その結果、高負荷プロキシまたはサーバーに近いルータは、個々のNASからのトラフィックが光であっても、輻輳が発生することがあります。このような「収束渋滞」AAAサーバの近くに、あるいはAAAサーバ自体の内部ルータで破棄されたパケットをもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Let us consider what happens when 10,000 48-ports NASes, each with an average session time of 20 minutes, are configured with the same AAA agent or server. The unfortunate proxy or server would receive 400 authentication/authorization requests/second and an equivalent number of accounting requests. For 1000 octet requests, this would generate 6.4 Mbps of incoming traffic at the AAA agent or server.",
      "ja": "私たちは20分の平均セッション時間10,000 48ポートのNAS、それぞれが、同じAAAのエージェントまたはサーバーで構成されているときに何が起こるかを考えてみましょう。不幸なプロキシまたはサーバが400、認証/認可要求/秒およびアカウンティング要求の同等の数を受け取ることになります。 1000のオクテット要求の場合、これはAAAのエージェントまたはサーバーでの着信トラフィックの6.4 Mbpsのを生成します。"
    },
    {
      "indent": 3,
      "text": "While this transaction load is within the capabilities of the fastest AAA agents and servers, implementations exist that cannot handle such a high load. Thus high queuing delays and/or dropped packets may be experienced at the agent or server, even if routers on the path are not congested. Thus, a well designed AAA protocol needs to be able to handle congestion occurring at the AAA server, as well as congestion experienced within the network.",
      "ja": "このトランザクションの負荷が最速AAAエージェントとサーバの能力の範囲内ですが、実装はそのような高い負荷を処理することはできませんが存在します。このように高いキューイング遅延および/またはドロップされたパケットは、パス上のルータが混雑していない場合であっても、エージェントまたはサーバーで経験することができます。したがって、適切に設計AAAプロトコルは、AAAサーバで発生する輻輳を処理することができる必要があるだけでなく、輻輳がネットワーク内で経験しました。"
    },
    {
      "indent": 0,
      "text": "2.2. Slow Failover",
      "section_title": true,
      "ja": "2.2。スローフェイルオーバー"
    },
    {
      "indent": 3,
      "text": "Where TCP [RFC793] is used as the transport, AAA implementations will experience very slow fail over times if they wait until a TCP connection times out before resending on another connection. This is not an issue for SCTP [RFC2960], which supports endpoint and path failure detection. As described in section 8 of [RFC2960], when the number of retransmissions exceeds the maximum (\"Association.Max.Retrans\"), the peer endpoint is considered unreachable, the association enters the CLOSED state, and the failure is reported to the application. This enables more rapid failure detection.",
      "ja": "TCP [RFC793]トランスポートとして使用する場合には、AAAの実装は非常に遅く発生します、彼らは別の接続に再送信する前に、TCP接続までの時間を待っていれば回以上失敗します。これは、エンドポイントとパス障害検出をサポートしていSCTP [RFC2960]のための問題ではありません。 [RFC2960]のセクション8で説明したように再送回数が最大（「Association.Max.Retrans」）を超えたとき、ピアエンドポイントが到達不能であると考えられる、関連付けは、CLOSED状態に入り、そして障害がアプリケーションに通知されます。これは、より迅速な障害検出を可能にします。"
    },
    {
      "indent": 0,
      "text": "2.3. Use of Nagle Algorithm",
      "section_title": true,
      "ja": "2.3。 Nagleアルゴリズムの使用"
    },
    {
      "indent": 3,
      "text": "AAA protocol messages are often smaller than the maximum segment size (MSS). While exceptions occur when certificate-based authentication messages are issued or where a low path MTU is found, typically AAA protocol messages are less than 1000 octets. Therefore, when using TCP [RFC793], the total packet count and associated network overhead can be reduced by combining multiple AAA messages within a single packet.",
      "ja": "AAAプロトコルメッセージは、最大セグメントサイズ（MSS）よりもしばしば小さいです。証明書ベースの認証メッセージが発行されたときに例外が発生したり、低いパスMTUが発見された場合、通常、AAAプロトコルメッセージは1000未満のオクテットです。一方でTCP [RFC793]を使用する場合したがって、総パケット数と関連するネットワークオーバーヘッドは、単一のパケット内の複数のAAAメッセージを組み合わせることにより低減することができます。"
    },
    {
      "indent": 3,
      "text": "Where AAA runs over TCP and transport behavior is network-driven, such as after a reboot when many users login simultaneously, or many stored accounting records need to be sent, the Nagle algorithm will result in \"transport layer batching\" of AAA messages. While this does not reduce the work required by the application in parsing packets and responding to the messages, it does reduce the number of packets processed by routers along the path. The Nagle algorithm is not used with SCTP.",
      "ja": "AAAは、TCP上で実行され、多くのユーザーが同時にログインする、または多くの保存された会計記録を送信する必要がある場合、トランスポートの動作は、再起動後のように、ネットワーク主導型、などである場合は、Nagleアルゴリズムは、AAAメッセージの「トランスポート層のバッチ処理」になります。これは、パケットを解析し、メッセージへの応答におけるアプリケーションで必要な作業を削減しませんが、それはパスに沿ったルータによって処理されたパケットの数を減らすん。 Nagleアルゴリズムは、SCTPで使用されていません。"
    },
    {
      "indent": 3,
      "text": "Where AAA transport is application-driven, the NAS will typically receive a reply from the home server prior to having another request to send. This implies, for example, that accounting requests will typically be sent individually rather than being batched by the transport layer. As a result, within the application-driven regime, the Nagle algorithm [RFC896] is ineffective.",
      "ja": "AAA輸送がアプリケーション主導型である場合、NASは、一般的に前に送信するための別の要求を有す​​ることにホームサーバーからの応答を受信します。これはアカウンティング要求は、通常、トランスポート層によってバッチ処理されるのではなく、個別に送信されることを、例えば、暗示します。結果として、アプリケーション駆動型レジーム内、Nagleアルゴリズムは、[RFC896]無効です。"
    },
    {
      "indent": 0,
      "text": "2.4. Multiple Connections",
      "section_title": true,
      "ja": "2.4。複数の接続"
    },
    {
      "indent": 3,
      "text": "Since the RADIUS [RFC2865] Identifier field is a single octet, a maximum of 256 requests can be in progress between two endpoints described by a 5-tuple: (Client IP address, Client port, UDP, Server IP address, Server port). In order to get around this limitation, RADIUS clients have utilized more than one sending port, sometimes even going to the extreme of using a different UDP source port for each NAS port.",
      "ja": "（クライアントIPアドレス、クライアントポート、UDP、サーバのIPアドレス、サーバーポート）：RADIUS [RFC2865]識別子フィールドは、単一のオクテットであることから、256の要求の最大値は5タプルによって説明した2つのエンドポイント間で進行中であることができます。この制限を回避するためには、RADIUSクライアントは、時には、各NASポートごとに異なるUDPソースポートを使用しての極端に行く、複数の送信ポートを利用してきました。"
    },
    {
      "indent": 3,
      "text": "Were this behavior to be extended to AAA protocols operating over reliable transport, the result would be multiplication of the effective slow-start ramp-up by the number of connections. For example, if a AAA client had ten connections open to a AAA agent, and used a per-connection initial window [RFC3390] of 2, then the",
      "ja": "この動作は、信頼性の高いトランスポート上で動作するAAAプロトコルに拡張することがあったが、結果は接続数による効果的なスロースタートランプアップの乗算になります。たとえば、AAAクライアントは、その後、AAAエージェントへのオープン10個の接続を持っていた、と2の接続ごとの初期ウィンドウ[RFC3390]を使用した場合"
    },
    {
      "indent": 3,
      "text": "effective initial window would be 20. This is inappropriate, since it would permit the AAA client to send a large burst of packets into the network.",
      "ja": "効果的な初期ウィンドウは、それがネットワークにパケットの大バーストを送信するためにAAAクライアントを可能にするので、これは、不適切である20になります。"
    },
    {
      "indent": 0,
      "text": "2.5. Duplicate Detection",
      "section_title": true,
      "ja": "2.5。重複検出"
    },
    {
      "indent": 3,
      "text": "Where a AAA client maintains connections to multiple AAA agents or servers, and where failover/failback or connection load balancing is supported, it is possible for multiple agents or servers to receive duplicate copies of the same transaction. A transaction may be sent on another connection before expiration of the \"time wait\" interval necessary to guarantee that all packets sent on the original connection have left the network. Therefore it is conceivable that transactions sent on the alternate connection will arrive before those sent on the failed connection. As a result, AAA agents and servers MUST be prepared to handle duplicates, and MUST assume that duplicates can arrive on any connection.",
      "ja": "どこAAAクライアントが複数のAAAエージェントまたはサーバーへの接続を維持し、フェイルオーバー/フェイルバックまたは接続ロード・バランシングがサポートされている複数のエージェントやサーバが同じトランザクションの重複コピーを受信することが可能です。トランザクションは、元の接続で送信されたすべてのパケットがネットワークを残していることを保証するために必要な「時間待ち」期間の満了前に別の接続で送信することができます。したがって、代替接続上で送信されたトランザクションが失敗した接続上で送信され、それらの前に到着することが考えられます。結果として、AAAエージェントとサーバは重複を処理するために準備する必要があり、そして重複が任意の接続で到着できると仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, in billing, it is necessary to be able to weed out duplicate accounting records, based on the accounting session-id, event-timestamp and NAS identification information. Where authentication requests are always idempotent, the resultant duplicate responses from multiple servers will presumably be identical, so that little harm will result.",
      "ja": "例えば、課金では、課金セッションID、イベントタイムスタンプとNAS識別情報に基づいて、重複したアカウンティングレコードを取り除くことができることが必要です。認証要求は常に冪等である場合、ほとんど害が発生するように、複数のサーバからの結果の重複した回答は、おそらく、同じになります。"
    },
    {
      "indent": 3,
      "text": "However, there are situations where the response to an authentication request will depend on a previously established state, such as when simultaneous usage restrictions are being enforced. In such cases, authentication requests will not be idempotent. For example, while an initial request might elicit an Accept response, a duplicate request might elicit a Reject response from another server, if the user were already presumed to be logged in, and only one simultaneous session were permitted. In these situations, the AAA client might receive both Accept and Reject responses to the same duplicate request, and the outcome will depend on which response arrives first.",
      "ja": "しかし、そのような同時使用制限が適用されているときのように、認証要求に対する応答は、以前に確立された状態に依存します状況が、あります。このような場合には、認証要求は冪等されることはありません。最初の要求が受け入れ応答を惹起する可能性がある一方で、ユーザーがすでにログインしていると推定された、そして唯一の同時セッションが許可された場合、例えば、重複したリクエストは、別のサーバからの拒否応答を誘発することがあります。このような状況では、AAAクライアントが両方受信受け入れ、同じ複製要求に対する応答を拒否し、結果は最初に到着する応答に依存しますがあります。"
    },
    {
      "indent": 0,
      "text": "2.6. Invalidation of Transport Parameter Estimates",
      "section_title": true,
      "ja": "2.6。交通パラメータ推定値の無効化"
    },
    {
      "indent": 3,
      "text": "Congestion control principles [Congest],[RFC2914] require the ability of a transport protocol to respond effectively to congestion, as sensed via increasing delays, packet loss, or explicit congestion notification.",
      "ja": "輻輳制御の原理[輻輳]、[RFC2914]増加の遅延、パケット損失、または明示的輻輳通知を介して感知され、渋滞に効果的に対応するトランスポートプロトコルの能力を必要とします。"
    },
    {
      "indent": 3,
      "text": "With network-driven applications, it is possible to respond to congestion on a timescale comparable to the round-trip time (RTT).",
      "ja": "ネットワーク主導型のアプリケーションでは、ラウンドトリップ時間（RTT）に匹敵するタイムスケール上の混雑に対応することができます。"
    },
    {
      "indent": 3,
      "text": "However, with AAA protocols, the time between sends may be longer than the RTT, so that the network conditions can not be assumed to persist between sends. For example, the congestion window may grow during a period in which congestion is being experienced because few packets are sent, limiting the opportunity for feedback. Similarly, after congestion is detected, the congestion window may remain small, even though the network conditions that existed at the time of congestion no longer apply by the time when the next packets are sent. In addition, due to the low sampling interval, estimates of RTT and RTO made via the procedure described in [RFC2988] may become invalid.",
      "ja": "ネットワーク状態が送信する間持続すると仮定することができないように、しかし、AAAプロトコルを用いて、送信間の時間は、長いRTTよりもできます。例えば、輻輳ウィンドウは、いくつかのパケットが送信されるため、輻輳がフィードバックの機会を制限し、経験されている期間中に成長することがあります。輻輳が検出された後、同様に、輻輳ウィンドウはもはや輻輳時に存在していないネットワーク条件は、次のパケットが送信される時間によって適用にもかかわらず、小さいままであり得ます。加えて、低いサンプリング間隔に、RTTとRTOの推定値が無効になることがあり、[RFC2988]に記載の手順を介して行います。"
    },
    {
      "indent": 0,
      "text": "2.7. Inability to Use Fast Re-transmit",
      "section_title": true,
      "ja": "2.7。高速再送信を使用することができません"
    },
    {
      "indent": 3,
      "text": "When congestion window validation [RFC2861] is implemented, the result is that AAA protocols operate much of the time in slow-start with an initial congestion window set to 1 or 2, depending on the implementation [RFC3390]. This implies that AAA protocols gain little benefit from the windowing features of reliable transport.",
      "ja": "輻輳ウィンドウの検証[RFC2861]が実装されている場合、結果は、AAAプロトコルが実装[RFC3390]に応じて、1または2に設定された初期混雑ウィンドウと遅い開始時間の多くを操作することです。これは、AAAプロトコルは、信頼性の高い輸送のウィンドウ機能からほとんど利益を得ることを意味します。"
    },
    {
      "indent": 3,
      "text": "Since the congestion window is so small, it is generally not possible to receive enough duplicate ACKs (3) to trigger fast re-transmit. In addition, since AAA traffic is two-way, ACKs including data will not count as part of the duplicate ACKs necessary to trigger fast re-transmit. As a result, dropped packets will require a retransmission timeout (RTO).",
      "ja": "輻輳ウィンドウは非常に小さいので、十分に重複ACK（3）高速再送信をトリガするために受信するために、一般的には不可能です。また、AAAトラフィックが双方向であることから、ACKを含むデータは、高速再送信をトリガするために必要な重複ACKの一部としてカウントされません。その結果、再送タイムアウト（RTO）が必要となり、パケットを落としました。"
    },
    {
      "indent": 0,
      "text": "2.8. Congestion Avoidance",
      "section_title": true,
      "ja": "2.8。輻輳回避"
    },
    {
      "indent": 3,
      "text": "The law of conservation of packets [Congest] suggests that a client should not send another packet into the network until it can be reasonably sure that a packet has exited the network on the same path. In the case of a AAA client, the law suggests that it should not retransmit to the same server or choose another server until it can be reasonably sure that a packet has exited the network on the same path. If the client advances the window as responses arrive, then the client will \"self clock\", adjusting its transmission rate to the available bandwidth.",
      "ja": "パケットの保存則[混雑は]パケットが同じパス上のネットワークを終了したことを合理的に確認することができますまで、クライアントがネットワークに別のパケットを送るべきではないことを示唆しています。 AAAクライアントの場合は、法律がパケットが同じパスにネットワークを終了したことを合理的に確認することができますまで、それは同じサーバに再送信するか、別のサーバーを選択するべきではないことを示唆しています。応答が到着すると、クライアントはウィンドウを進めた場合、クライアントは、「自己の時計は」、利用可能な帯域幅への伝送速度を調整します。"
    },
    {
      "indent": 3,
      "text": "While a AAA client using a reliable transport such as TCP [RFC793] or SCTP [RFC2960] will self-clock when communicating directly with a AAA-server, end-to-end self-clocking is not assured when AAA agents are present.",
      "ja": "AAAサーバと直接通信する際にAAAエージェントが存在する場合、このようなTCP [RFC793]又はSCTP [RFC2960]などの信頼性の高いトランスポートを使用して、AAAクライアントは、エンドツーエンドの自己クロッキングは、自己クロック保証されないだろうが。"
    },
    {
      "indent": 3,
      "text": "As described in the Appendix, AAA agents include Relays, Proxies, Re-directs, Store and Forward proxies, and Transport proxies. Of these agents, only Transport proxies and Re-directs provide a direct transport connection between the AAA client and server, allowing end-to-end self-clocking to occur.",
      "ja": "付録で説明したように、AAAのエージェントは、リレー、プロキシ、再指示し、ストアアンドフォワードプロキシ、およびTransportプロキシが含まれています。これらの薬剤の、唯一の交通プロキシと再指示は、エンドツーエンドの自己クロッキングが発生することができ、AAAクライアントとサーバの間の直接のトランスポート接続を提供します。"
    },
    {
      "indent": 3,
      "text": "With Relays, Proxies or Store and Forward proxies, two separate and de-coupled transport connections are used. One connection operates between the AAA client and agent, and another between the agent and server. Since the two transport connections are de-coupled, transport layer ACKs do not flow end-to-end, and self-clocking does not occur.",
      "ja": "リレー、プロキシまたはストアアンドフォワードプロキシでは、二つの別々のデ結合された交通機関の接続が使用されています。一方の接続は、エージェントとサーバ間のAAAクライアントとエージェント、および他の間を運行しています。二つの伝送接続は切り離されているため、トランスポート層ACKは、エンドツーエンドの流れず、自己クロッキングは発生しません。"
    },
    {
      "indent": 3,
      "text": "For example, consider what happens when the bottleneck exists between a AAA Relay and a AAA server. Self-clocking will occur between the AAA client and AAA Relay, causing the AAA client to adjust its sending rate to the rate at which transport ACKs flow back from the AAA Relay. However, since this rate is higher than the bottleneck bandwidth, the overall system will not self-clock.",
      "ja": "例えば、ボトルネックがAAAリレーとAAAサーバの間に存在するときに何が起こるかを検討してください。自己クロッキングは、AAAクライアントは、トランスポートACKがAAAリレーから逆流する速度に、その送信レートを調整させる、AAAクライアントとAAAリレーとの間に発生します。このレートは、ボトルネック帯域よりも高くなっているので、全体的なシステムは、自己クロックではないでしょう。"
    },
    {
      "indent": 3,
      "text": "Since there is no direct transport connection between the AAA client and AAA server, the AAA client does not have the ability to estimate end-to-end transport parameters and adjust its sending rate to the bottleneck bandwidth between the Relay and server. As a result, the incoming rate at the AAA Relay can be higher than the rate at which packets can be sent to the AAA server.",
      "ja": "AAAクライアントとAAAサーバの間に直接のトランスポート接続が存在しないため、AAAクライアントは、エンドツーエンドのトランスポートパラメータを推定し、リレーとサーバ間のボトルネック帯域への送信レートを調整する能力を持っていません。結果として、AAAリレーにおける受信レートは、パケットがAAAサーバに送信することができる速度よりも高くすることができます。"
    },
    {
      "indent": 3,
      "text": "In this case, the end-to-end performance will be determined by details of the agent implementation. In general, the end-to-end transport performance in the presence of Relays, Proxies or Store and Forward proxies will always be worse in terms of delay and packet loss than if the AAA client and server were communicating directly.",
      "ja": "この場合には、エンドツーエンドのパフォーマンスは、エージェントの実装の詳細によって決定されるであろう。 AAAクライアントとサーバが直接通信しているかよりも、一般的には、リレー、プロキシまたはストアアンドフォワードプロキシの存在下でのエンド・ツー・エンドの輸送能力は常に遅延やパケットロスの面で悪くなります。"
    },
    {
      "indent": 3,
      "text": "For example, if the agent operates with a large receive buffer, it is possible that a large queue will develop on the receiving side, since the AAA client is able to send packets to the AAA agent more rapidly than the agent can send them to the AAA server. Eventually, the buffer will overflow, causing wholesale packet loss as well as high delay.",
      "ja": "エージェントは、大きな受信バッファで動作した場合、AAAクライアントエージェントがそれらを送信することができますよりも急速にAAAエージェントにパケットを送信することが可能であるため、大規模なキューは、受信側で開発することは可能ですAAAサーバ。最終的に、バッファは卸売パケット損失ならびに高い遅延を引き起こし、オーバーフローします。"
    },
    {
      "indent": 3,
      "text": "Methods to induce fine-grained coupling between the two transport connections are difficult to implement. One possible solution is for the AAA agent to operate with a receive buffer that is no larger than its send buffer. If this is done, \"back pressure\" (closing of the receive window) will cause the agent to reduce the AAA client sending rate when the agent send buffer fills. However, unless multiple connections exist between the AAA client and AAA agent, closing of the receive window will affect all traffic sent by the AAA client, even traffic destined to AAA servers where no bottleneck exists. Since multiple connections between a AAA client and agent result in multiplication of the effective slow-start ramp rate, this is not recommended. As a result, use of \"back pressure\" cannot enable individual AAA client-server conversations to self-clock, and this technique appears impractical for use in AAA.",
      "ja": "2つの交通機関の接続の間できめ細かい結合を誘導する方法は、実施することが困難です。 AAAエージェントがその送信バッファより大きくない受信バッファで動作するための1つの可能なソリューションです。これが行われた場合、「背圧」（受信ウィンドウの閉鎖は）エージェントは、エージェントがいっぱいバッファを送信レートを送信するAAAクライアントを減らすことになります。ただし、複数の接続には、AAAクライアントとAAAのエージェント、AAAクライアントから送信されるすべてのトラフィック、ボトルネックが存在しないAAAサーバ宛てにもトラフィックに影響を及ぼします受信ウィンドウのクローズの間に存在していない限り。効果的なスロースタートのランプ・レートの乗算でAAAクライアントとエージェントの結果との間に複数の接続ので、これはお勧めしません。その結果、「背圧」の使用は、自己クロックに個々のAAAクライアント - サーバの会話を有効にすることはできませんが、この技術はAAAでの使用のために実用的でない表示されます。"
    },
    {
      "indent": 0,
      "text": "2.9. Delayed Acknowledgments",
      "section_title": true,
      "ja": "2.9。遅延謝辞"
    },
    {
      "indent": 3,
      "text": "As described in Appendix B, ACKs may comprise as much as half of the traffic generated in a AAA exchange. This occurs because AAA conversations are typically application-driven, and therefore there is frequently not enough traffic to enable ACK piggybacking. As a result, AAA protocols running over TCP or SCTP transport may experience a doubling of traffic as compared with implementations utilizing UDP transport.",
      "ja": "付録Bに記載されているように、ACKはAAA交換で生成されるトラフィックの半分ほどに含むことができます。 AAAの会話は、通常、アプリケーション主導型であるため、ACKのピギーバックを可能にするために十分なトラフィックが頻繁に存在しないため、これが発生します。その結果、TCPまたはSCTPトランスポート上で実行されているAAAプロトコルはUDPトランスポートを利用し実装と比較して、トラフィックの倍増が発生することがあります。"
    },
    {
      "indent": 3,
      "text": "It is typically not possible to address this issue via the sockets API. ACK parameters (such as the value of the delayed ACK timer) are typically fixed by TCP and SCTP implementations and are therefore not tunable by the application.",
      "ja": "ソケットAPIを介してこの問題に対処するために一般的には不可能です。 （例えば、遅延ACKタイマの値など）ACKのパラメータは、典型的には、TCPとSCTP実装によって固定されており、したがって、アプリケーションによって調整可能れません。"
    },
    {
      "indent": 0,
      "text": "2.10. Premature Failover",
      "section_title": true,
      "ja": "2.10。早期のフェイルオーバー"
    },
    {
      "indent": 3,
      "text": "RADIUS failover implementations are typically based on the concept of primary and secondary servers, in which all traffic flows to the primary server unless it is unavailable. However, the failover algorithm was not specified in [RFC2865] or [RFC2866]. As a result, RADIUS failover implementations vary in quality, with some failing over prematurely, violating the law of \"conservation of packets\".",
      "ja": "RADIUSフェイルオーバーの実装は、一般的に、それが使用できない場合を除き、すべてのトラフィックは、プライマリサーバに流れる、プライマリサーバとセカンダリサーバの概念に基づいています。しかし、フェイルオーバーアルゴリズムは[RFC2865]または[RFC2866]で指定されませんでした。その結果、RADIUSフェイルオーバーの実装はいくつかは、「パケットの保全」の法律を違反し、途中でフェールオーバーすると、品質が異なります。"
    },
    {
      "indent": 3,
      "text": "Where a Relay, Proxy or Store and Forward proxy is present, the AAA client has no direct connection to a AAA server, and is unable to estimate the end-to-end transport parameters. As a result, a AAA client awaiting an application-layer response from the server has no transport-based mechanism for determining an appropriate failover timer.",
      "ja": "リレー、プロキシまたはストア・アンド・フォワードプロキシが存在する場合、AAAクライアントは、AAAサーバに直接接続されていない、とエンドツーエンドのトランスポート・パラメータを推定することができません。結果として、サーバからアプリケーション層の応答を待っているAAAクライアントは、適切なフェイルオーバ・タイマを決定するためのトランスポートベースのメカニズムを有していません。"
    },
    {
      "indent": 3,
      "text": "For example, if the path between the AAA agent and server includes a high delay link, or if the AAA server is very heavily loaded, it is possible that the NAS will failover to another agent while packets are still in flight. This violates the principle of \"conservation of packets\", since the AAA client will inject additional packets into the network before having evidence that a previously sent packet has left the network. Such behavior can result in a worse situation on an already congested link, resulting in congestive collapse [Congest].",
      "ja": "例えば、場合AAAエージェントとサーバ間のパスは、高遅延のリンクが含まれ、またはAAAサーバは非常に負荷が高い場合、パケットが飛行中に残っている間、NASは、別のエージェントにフェイルオーバーする可能性があります。 AAAクライアントが以前に送信されたパケットがネットワークを残しているという証拠を持つ前に、ネットワークに追加パケットを注入しますので、これは、「パケットの保全」の原則に違反します。このような行動は、うっ血性崩壊[輻輳]で、その結果、すでに混雑したリンク上に悪い状況につながることができます。"
    },
    {
      "indent": 0,
      "text": "2.11. Head of Line Blocking",
      "section_title": true,
      "ja": "2.11。ラインブロッキングのヘッド"
    },
    {
      "indent": 3,
      "text": "Head of line blocking occurs during periods of packet loss where the time between sends is shorter than the re-transmission timeout value (RTO). In such situations, packets back up in the send queue until the lost packet can be successfully re-transmitted. This can be an issue for SCTP when using ordered delivery over a single stream, and for TCP.",
      "ja": "ラインブロックの先頭が送信の間の時間は、再送タイムアウト値（RTO）より短いパケット損失の期間中に生じます。このような状況、送信キュー内のパケットのバックアップ失われたパケットが正常に再送信することができるようになるまでには。これは、単一のストリームを超える、およびTCPのための注文の配信を使用してSCTPのための問題になることができます。"
    },
    {
      "indent": 3,
      "text": "Head of line blocking is typically an issue only on larger NASes. For example, a 48-port NAS with an average inter-packet spacing of 25 seconds is unlikely to have an RTO greater than this, unless severe packet loss has been experienced. However, a 2048-port NAS with an average inter-packet spacing of 293 ms may experience head-of-line blocking since the inter-packet spacing is less than the minimum RTO value of 1 second [RFC2988].",
      "ja": "行ブロッキングのヘッドは大きなNASで、一般的な問題です。深刻なパケット損失が経験されていない限り、例えば、25秒間の平均パケット間の間隔が48ポートNASは、これよりも大きいRTOを持っていることはほとんどありません。パケット間間隔が1秒[RFC2988]の最小RTO値未満であるので、293ミリ秒の平均のパケット間間隔を有する2048ポートNASヘッドオブラインブロッキングを経験し得ます。"
    },
    {
      "indent": 0,
      "text": "2.12. Connection Load Balancing",
      "section_title": true,
      "ja": "2.12。接続ロード・バランシング"
    },
    {
      "indent": 3,
      "text": "In order to lessen queuing delays and address head of line blocking, a AAA implementation may wish to load balance between connections to multiple destinations. While it is possible to employ dynamic load balancing techniques, this level of sophistication may not be required. In many situations, adequate reliability and load balancing can be achieved via static load balancing, where traffic is distributed between destinations based on static \"weights\".",
      "ja": "キューイング遅延やラインブロックのアドレスヘッドを軽減するためには、AAAの実装では、複数の宛先への接続との間のバランスをロードしたいことがあります。それは動的負荷分散技術を採用することは可能ですが、洗練されたこのレベルが必要とされないことがあります。多くの状況では、十分な信頼性とロードバランシングは、トラフィックが静的な「重み」に基づいて目的地の間に分散された静的な負荷分散、を介して達成することができます。"
    },
    {
      "indent": 0,
      "text": "3. AAA Transport Profile",
      "section_title": true,
      "ja": "3. AAA輸送プロフィール"
    },
    {
      "indent": 3,
      "text": "In order to address AAA transport issues, it is recommended that AAA protocols make use of standards track as well as experimental techniques. More details are provided in the sections that follow.",
      "ja": "AAA輸送の問題に対処するためには、追跡するだけでなく、実験技術AAAプロトコルが標準規格を利用することをお勧めします。詳細は以下のセクションで提供されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Transport Mappings",
      "section_title": true,
      "ja": "3.1。交通のマッピング"
    },
    {
      "indent": 3,
      "text": "AAA Servers MUST support TCP and SCTP. AAA clients SHOULD support SCTP, but MUST support TCP if SCTP is not available. As support for SCTP improves, it is possible that SCTP support will be required on clients at some point in the future. AAA agents inherit all the obligations of Servers with respect to transport support.",
      "ja": "AAAサーバは、TCPやSCTPをサポートしなければなりません。 AAAクライアントは、SCTPをサポートする必要がありますが、SCTPが利用できない場合、TCPをサポートしなければなりません。 SCTPのサポートが向上したように、SCTPのサポートは、将来のある時点で、クライアント上で必要とされる可能性があります。 AAAエージェントがサポートを輸送に関してサーバーのすべての義務を継承します。"
    },
    {
      "indent": 0,
      "text": "3.2. Use of Nagle Algorithm",
      "section_title": true,
      "ja": "3.2。 Nagleアルゴリズムの使用"
    },
    {
      "indent": 3,
      "text": "While AAA protocols typically operate in the application-driven regime, there are circumstances in which they are network driven. For example, where an NAS reboots, or where connectivity is restored between an NAS and a AAA agent, it is possible that multiple packets will be available for sending.",
      "ja": "AAAプロトコルは、典型的には、アプリケーション駆動型レジームで動作している間、彼らはネットワーク駆動される状況があります。 NASが再起動、または接続がNASとAAAエージェントとの間で復元される場合、例えば、複数のパケットが送信のために利用可能になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "As a result, there are circumstances where the transport-layer batching provided by the Nagle Algorithm (12) is useful, and as a result, AAA implementations running over TCP MUST enable the Nagle algorithm, [RFC896]. The Nagle algorithm is not used with SCTP.",
      "ja": "結果として、Nagleアルゴリズム（12）によって提供されるトランスポート層のバッチが有用であり、その結果として、AAA実装は[RFC896]、Nagleアルゴリズムを有効にする必要があり、TCP上で実行されている状況があります。 Nagleアルゴリズムは、SCTPで使用されていません。"
    },
    {
      "indent": 0,
      "text": "3.3. Multiple Connections",
      "section_title": true,
      "ja": "3.3。複数の接続"
    },
    {
      "indent": 3,
      "text": "AAA protocols SHOULD use only a single persistent connection between a AAA client and a AAA agent or server. They SHOULD provide for pipelining of requests, so that more than one request can be in progress at a time. In order to minimize use of inactive connections in roaming situations, a AAA client or agent MAY bring down a connection to a AAA agent or server if the connection has been unutilized (discounting the watchdog) for a certain period of time, which MUST NOT be less than BRINGDOWN_INTERVAL (5 minutes).",
      "ja": "AAAプロトコルは、AAAクライアントとAAAのエージェントまたはサーバー間の唯一の単一の持続的接続を使用する必要があります。複数の要求が一度に進行中であることができるように彼らは、リクエストのパイプラインを提供すべきです。接続がであってはならない、一定時間（ウォッチドッグを割り引く）未利用された場合の状況をローミングにおける非アクティブな接続の使用を最小限にするためには、AAAクライアントまたはエージェントはAAAのエージェントまたはサーバーへの接続をダウンさせるかもしれませんBRINGDOWN_INTERVAL（5分）よりも少ないです。"
    },
    {
      "indent": 3,
      "text": "While a AAA client/agent SHOULD only use a single persistent connection to a given AAA agent or server, it MAY have connections to multiple AAA agents or servers. A AAA client/agent connected to multiple agents/servers can treat them as primary/secondary or balance load between them.",
      "ja": "AAAクライアント/エージェントのみが与えられたAAAのエージェントまたはサーバーへの単一の持続的接続を使用する必要がありますが、それは複数のAAAエージェントまたはサーバーへの接続を持っているかもしれません。 AAAクライアント/エージェントは複数のエージェント/サーバに接続され、それらの間のプライマリ/セカンダリまたはバランス負荷として扱うことができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Application Layer Watchdog",
      "section_title": true,
      "ja": "3.4。アプリケーション層のウォッチドッグ"
    },
    {
      "indent": 3,
      "text": "In order to enable AAA implementations to more quickly detect transport and application-layer failures, AAA protocols MUST support an application layer watchdog message.",
      "ja": "より迅速輸送およびアプリケーション層の障害を検出するために、AAA実装を可能にするために、AAAプロトコルは、アプリケーション層ウォッチドッグメッセージをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The application layer watchdog message enables failover from a peer that has failed, either because it is unreachable or because its applications functions have failed. This is distinct from the purpose of the SCTP heartbeat, which is to enable failover between interfaces. The SCTP heartbeat may enable a failover to another path to reach the same server, but does not address the situation where the server system or the application service has failed. Therefore both mechanisms MAY be used together.",
      "ja": "アプリケーション層のウォッチドッグ・メッセージは、それが到達不能であるか、そのアプリケーションの機能に障害が発生しているのでどちらかのために、失敗したピアからのフェイルオーバーが可能になります。これは、インターフェイス間のフェイルオーバーを可能にすることであるSCTPハートビートの目的は区別されます。 SCTPハートビートは、同じサーバーに到達するために別のパスへのフェイルオーバーを可能にするかもしれないが、サーバ・システムやアプリケーションサービスに障害が発生した状況に対処しません。したがって、両方のメカニズムを併用してもよいです。"
    },
    {
      "indent": 3,
      "text": "The watchdog is used in order to enable a AAA client or agent to determine when to resend on another connection. It operates on all open connections and is used to suspend and eventually close connections that are experiencing difficulties. The watchdog is also used to re-open and validate connections that have returned to health. The watchdog may be utilized either within primary/secondary or load balancing configurations. However, it is not intended as a cluster heartbeat mechanism.",
      "ja": "ウォッチドッグは、別の接続で再送するかを決定するためにAAAクライアントまたはエージェントを有効にするために使用されています。これは、すべての開いている接続上で動作し、困難を経験している近くの接続を中断し、最終的に使用されます。ウォッチドッグはまた、再オープンし、健康に戻ってきたの接続を検証するために使用されます。ウォッチドッグは、いずれかのプライマリ/セカンダリ又は負荷分散構成内で利用することができます。しかし、クラスタハートビート・メカニズムとして意図されていません。"
    },
    {
      "indent": 3,
      "text": "The application layer watchdog is designed to detect failures of the immediate peer, and not to be affected by failures of downstream proxies or servers. This prevents instability in downstream AAA components from propagating upstream. While the receipt of any AAA Response from a peer is taken as evidence that the peer is up, lack of a Response is insufficient to conclude that the peer is down. Since the lack of Response may be the result of problems with a downstream proxy or server, only after failure to respond to the watchdog message can it be determined that the peer is down.",
      "ja": "アプリケーション層のウォッチドッグはすぐにピアの障害を検出するように設計されており、下流のプロキシまたはサーバの障害によって影響を受けません。これは、上流伝播下流AAAコンポーネントに不安定性を防止します。ピアからのすべてのAAA応答の受信がピアが起動していることを証拠として採用されている間、応答の欠如は、ピアがダウンしていると結論するには不十分です。応答の欠如が下流のプロキシまたはサーバーの問題の結果である可能性がありますので、唯一の障害発生後、ウォッチドッグ・メッセージに応答するには、ピアがダウンしていると判断することができます。"
    },
    {
      "indent": 3,
      "text": "Since the watchdog algorithm takes any AAA Response into account in determining peer liveness, decreases in the watchdog timer interval do not significantly increase the level of watchdog traffic on heavily loaded networks. This is because watchdog messages do not need to be sent where other AAA Response traffic serves as a constant reminder of peer liveness. Watchdog traffic only increases when AAA traffic is light, and therefore a AAA Response \"signal\" is not present. Nevertheless, decreasing the timer interval TWINIT does increase the probability of false failover significantly, and so this decision should be made with care.",
      "ja": "ウォッチドッグ・アルゴリズムは、ピアライブネスを決定する際に考慮に任意のAAA応答がかかるため、かなり負荷の高いネットワーク上のウォッチドッグ・トラフィックのレベルを増加させない、ウォッチドッグタイマ間隔で減少しています。ウォッチドッグ・メッセージは、他のAAA応答トラフィックは、ピアライブネスの定数リマインダとして機能場所を送信する必要がないためです。 AAAトラフィックが光であるため、AAA応答「信号が」存在しない場合、ウォッチドッグ・トラフィックだけ増加します。それにもかかわらず、タイマー間隔TWINITを減少させると大幅に偽のフェイルオーバーの確率を高めるんので、この決定は、慎重になされるべきです。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Algorithm Overview",
      "section_title": true,
      "ja": "3.4.1。アルゴリズムの概要"
    },
    {
      "indent": 3,
      "text": "The watchdog behavior is controlled by an algorithm defined in this section. This algorithm is appropriate for use either within primary/secondary or load balancing configurations. Implementations SHOULD implement this algorithm, which operates as follows:",
      "ja": "ウォッチドッグの動作は、このセクションで定義されたアルゴリズムによって制御されます。このアルゴリズムは、使用に適しているいずれかのプライマリ/セカンダリまたはロードバランシングコンフィギュレーション内。実装は次のように動作する、このアルゴリズムを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "[1] Watchdog behavior is controlled by a single timer (Tw). The initial value of Tw, prior to jittering is Twinit. The default value of Twinit is 30 seconds. This value was selected because it minimizes the probability that failover will be initiated due to a routing flap, as noted in [Paxson].",
      "ja": "[1]ウォッチドッグ挙動は、単一のタイマ（TW）により制御されます。前ジッタへTwの初期値は、Twinitです。 Twinitのデフォルト値は30秒​​です。それは[パクソン]で述べたように、フェイルオーバーが、原因ルーティングフラップに開始される可能性を最小限に抑えるため、この値を選択しました。"
    },
    {
      "indent": 7,
      "text": "While Twinit MAY be set as low as 6 seconds (not including\njitter), it MUST NOT be set lower than this.  Note that setting\nsuch a low value for Twinit is likely to result in an increased\nprobability of duplicates, as well as an increase in spurious\nfailover and failback attempts.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "In order to avoid synchronization behaviors that can occur with fixed timers among distributed systems, each time the watchdog interval is calculated with a jitter by using the Twinit value and randomly adding a value drawn between -2 and 2 seconds. Alternative calculations to create jitter MAY be used. These MUST be pseudo-random, generated by a PRNG seeded as per [RFC1750].",
      "ja": "分散システムの間で固定タイマーで発生する可能性が同期動作を回避するために、それぞれの時間は、ウォッチドッグ間隔はTwinit値を用いてランダム-2と2秒の間に引かれた値を加算することにより、ジッタを算出します。ジッタを作成するための代替の計算が使用されるかもしれません。これらは、擬似ランダム、PRNGは[RFC1750]に従って播種することによって生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "[2] When any AAA message is received, Tw is reset. This need not be a response to a watchdog request. Receiving a watchdog response from a peer constitutes activity, and Tw should be reset. If the watchdog timer expires and no watchdog response is pending, then a watchdog message is sent. On sending a watchdog request, Tw is reset.",
      "ja": "任意AAAメッセージを受信した場合[2]、Twがリセットされます。これは、ウォッチドッグ要求に応答する必要はありません。ピアからのウォッチドッグ・レスポンスを受信すると、アクティビティを構成し、Twがリセットされなければなりません。ウォッチドッグ・タイマーが切れると何のウォッチドッグ応答が保留されていない場合は、ウォッチドッグメッセージが送信されます。ウォッチドッグ・リクエストを送信するには、Twがリセットされます。"
    },
    {
      "indent": 7,
      "text": "Watchdog packets are not retransmitted by the AAA protocol, since\nAAA protocols run over reliable transports that will handle all\nretransmissions internally.  As a result, a watchdog request is\nonly sent when there is no watchdog response pending.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[3] If the watchdog timer expires and a watchdog response is pending, then failover is initiated. In order for a AAA client or agent to perform failover procedures, it is necessary to maintain a pending message queue for a given peer. When an answer message is received, the corresponding request is removed from the queue. The Hop-by-Hop Identifier field MAY be used to match the answer with the queued request.",
      "ja": "ウォッチドッグタイマが満了すると、ウォッチドッグ応答が保留されている場合は、[3]、その後、フェイルオーバーが開始されます。フェイルオーバー手順を実行するためのAAAクライアントまたはエージェントのためには、与えられたピアの保留中のメッセージキューを維持する必要があります。応答メッセージが受信されると、対応する要求をキューから削除されます。ホップバイホップ識別子フィールドは、キューに入れられたリクエストに答えを一致させるために使用されるかもしれません。"
    },
    {
      "indent": 7,
      "text": "When failover is initiated, all messages in the queue are sent to\nan alternate agent, if available.  Multiple identical requests or\nanswers may be received as a result of a failover.  The\ncombination of an end-to-end identifier and the origin host MUST\nbe used to identify duplicate messages.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Note that where traffic is heavy, the application layer watchdog can take as long as 2Tw to determine that a peer has gone down. For peers receiving a high volume of AAA Requests, AAA Responses will continually reset the timer, so that after a failure it will take Tw for the lack of traffic to be noticed, and for the watchdog message to be sent. Another Tw will elapse before failover is initiated.",
      "ja": "トラフィックが重いです2Twは、ピアがダウンしたと判断すると、アプリケーション層のウォッチドッグは限り取ることに注意してください。ピアはAAA要求の高いボリュームを受信するために、AAA応答が失敗した後、それが注目されるべきトラフィックの不足のためTwのがかかりますように、継続的に、タイマーをリセットし、ウォッチドッグ・メッセージを送信します。フェイルオーバーが開始される前に別のTwが経過します。"
    },
    {
      "indent": 7,
      "text": "On a lightly loaded network without much AAA Response traffic, the watchdog timer will typically expire without being reset, so that a watchdog response will be outstanding and failover will be initiated after only a single timer interval has expired.",
      "ja": "ウォッチドッグ応答が優れただろうとフェイルオーバーは、単一のタイマー間隔が経過した後に開始されるように多くのAAAの応答トラフィックのない負荷の軽いネットワークでは、ウォッチドッグタイマは、一般的に、リセットされずに期限切れになります。"
    },
    {
      "indent": 3,
      "text": "[4] The client MUST NOT close the primary connection until the primary's watchdog timer has expired at least twice without a response (note that the watchdog is not sent a second time, however). Once this has occurred, the client SHOULD cause a transport reset or close to be done on the connection.",
      "ja": "主のウォッチドッグタイマは、応答（ただし、ウォッチドッグが二度目に送信されないことに注意）なしで少なくとも二回切れるまで[4]クライアントは、プライマリ接続を閉じてはなりません。これが発生すると、クライアントが接続上で行うことに近いまたはトランスポートリセットが発生する必要があります。"
    },
    {
      "indent": 7,
      "text": "Once the primary connection has failed, subsequent requests are\nsent to the alternate server until the watchdog timer on the\nprimary connection is reset.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Suspension of the primary connection prevents flapping between primary and alternate connections, and ensures that failover behavior remains consistent. The application may not receive a response to the watchdog request message due to a connectivity problem, in which case a transport layer ACK will not have been received, or the lack of response may be due to an application problem. Without transport layer visibility, the application is unable to tell the difference, and must behave conservatively.",
      "ja": "プライマリ接続の懸濁液を、一次および代替接続間羽ばたき防止し、フェイルオーバー動作が一貫したままこ​​とを保証します。アプリケーションが原因トランスポート層ACKが受信されていないか、または応答の欠如は、アプリケーションの問題が原因である可能性があり、その場合、接続の問題にウォッチドッグ要求メッセージに対する応答を受信することができません。トランスポート層の可視性がなければ、アプリケーションは違いを見分けることができない、と控えめに動作する必要があります。"
    },
    {
      "indent": 7,
      "text": "In situations where no transport layer ACK is received on the primary connection after multiple re-transmissions, the RTO will be exponentially backed off as described in [RFC2988]. Due to Karn's algorithm as implemented in SCTP and TCP, the RTO estimator will not be reset until another ACK is received in response to a non-re-transmitted request. Thus, in cases where the problem occurs at the transport layer, after the client fails over to the alternate server, the RTO of the primary will remain at a high value unless an ACK is received on the primary connection.",
      "ja": "[RFC2988]に記載されているように何輸送層ACKは、複数の再送信の後に、一次接続上で受信されていない状況では、RTOは、指数関数的に後退します。別のACKが非再送信された要求に応答して受信されるまでによるSCTPとTCPに実装されるカーンのアルゴリズムに、RTO推定器はリセットされないであろう。 ACKは、一次接続上で受信されていない限り、このように、クライアントが代替サーバにフェイルオーバーした後に問題が、トランスポート層で発生した場合には、一次のRTOは、高い値に留まります。"
    },
    {
      "indent": 7,
      "text": "In the case where the problem occurs at the transport layer, subsequent requests sent on the primary connection will not receive the same service as was originally provided. For example, instead of failover occurring after 3 retransmissions, failover might occur without even a single retransmission if RTO has been sufficiently backed off. Of course, if the lack of a watchdog response was due to an application layer problem, then RTO will not have been backed off. However, without transport layer visibility, there is no way for the application to know this.",
      "ja": "元々提供されたように問題はトランスポート層で発生した場合に、一次接続上で送信された後続の要求は、同一のサービスを受信しないであろう。たとえば、代わりにフェイルオーバーが3つの再送信した後に発生するのは、フェールオーバーは、RTOが十分にオフにバックアップされている場合でも、単一の再送信せずに発生する可能性があります。ウォッチドッグ応答の欠如は、アプリケーション層の問題によるものであった場合はもちろん、その後、RTOはオフにバックアップされていません。しかし、トランスポート層の可視性なしで、アプリケーションがこれを知る方法はありません。"
    },
    {
      "indent": 7,
      "text": "Suspending use of the primary connection until a response to a watchdog message is received guarantees that the RTO timer will have been reset before the primary connection is reused. If no response is received after the second watchdog timer expiration, then the primary connection is closed and the suspension becomes permanent.",
      "ja": "ウォッチドッグ・メッセージへの応答がプライマリ接続が再利用される前に、RTOタイマがリセットされてしまうという保証を受信されるまで、プライマリ接続の使用を一時停止。応答が第二のウォッチドッグタイマの満了後に受信されない場合、プライマリ接続が閉じられ、懸濁液は、永久なります。"
    },
    {
      "indent": 3,
      "text": "[5] While the connection is in the closed state, the AAA client MUST NOT attempt to send further watchdog messages on the connection. However, after the connection is closed, the AAA client continues to periodically attempt to reopen the connection.",
      "ja": "接続が閉じられた状態にある間に、[5]、AAAクライアントが接続でさらにウォッチドッグ・メッセージを送信することを試みてはいけません。接続が閉じられた後しかし、AAAクライアントが定期的に接続を再開しようとし続けています。"
    },
    {
      "indent": 7,
      "text": "The AAA client SHOULD wait for the transport layer to report\nconnection failure before attempting again, but MAY choose to\nbound this wait time by the watchdog interval, Tw.  If the\nconnection is successfully opened, then the watchdog message is\nsent.  Once three watchdog messages have been sent and responded\nto, the connection is returned to service, and transactions are\nonce again sent over it.  Connection validation via receipt of\nmultiple watchdogs is not required when a connection is initially\nbrought up -- in this case, the connection can immediately be put\ninto service.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[6] When using SCTP as a transport, it is not necessary to disable SCTP's transport-layer heartbeats. However, if AAA implementations have access to SCTP's heartbeat parameters, they MAY chose to ensure that SCTP's heartbeat interval is longer than the AAA watchdog interval, Tw. This will ensure that alternate paths are still probed by SCTP, while the primary path has a minimum of heartbeat redundancy.",
      "ja": "トランスポートとしてSCTPを使用する場合は、[6]、SCTPのトランスポート層のハートビートを無効にする必要はありません。 AAAの実装は、SCTPのハートビートパラメータへのアクセスを持っている場合は、彼らはSCTPのハートビート間隔が長くAAAウォッチドッグ間隔、Twよりであることを保証するために選択することができます。これは、プライマリパスがハートビート冗長性の最小値を有している代替パスがまだ、SCTPによってプローブされることを保証します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Primary/Secondary Failover Support",
      "section_title": true,
      "ja": "3.4.2。プライマリ/セカンダリフェールオーバーサポート"
    },
    {
      "indent": 3,
      "text": "The watchdog timer MAY be integrated with primary/secondary style failover so as to provide improved reliability and basic load balancing. In order to balance load among multiple AAA servers, each AAA server is designated the primary for a portion of the clients, and designated as secondaries of varying priority for the remainder. In this way, load can be balanced among the AAA servers.",
      "ja": "信頼性の向上と、基本的な負荷分散を提供するように、ウォッチドッグタイマは、プライマリ/セカンダリスタイルのフェイルオーバーと統合することができます。複数のAAAサーバ間で負荷を分散するために、各AAAサーバは、クライアントの部分のための主要な指定され、残りの優先度を変えるのセカンダリとして指定します。このように、負荷は、AAAサーバの間でバランスをとることができます。"
    },
    {
      "indent": 3,
      "text": "Within primary/secondary configurations, the watchdog timer operates as follows:",
      "ja": "次のようにプライマリ/セカンダリ構成の中では、ウォッチドッグタイマは動作します。"
    },
    {
      "indent": 3,
      "text": "[1] Assume that each client or agent is initially configured with a single primary agent or server, and one or more secondary connections.",
      "ja": "[1]各クライアントまたはエージェントは、最初に単一の一次エージェントまたはサーバ、および1つまたは複数の二次接続で構成されているものとします。"
    },
    {
      "indent": 3,
      "text": "[2] The watchdog mechanism is used to suspend and eventually close primary connections that are experiencing difficulties. It is also used to re-open and validate connections that have returned to health.",
      "ja": "[2]ウォッチドッグ機構が一時停止し、最終的に困難を経験しているプラ​​イマリ接続を閉じるために使用されます。また、再オープンし、健康に戻ってきたの接続を検証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "[3] Once a secondary is promoted to primary status, either on a temporary or permanent basis, the next server on the list of secondaries is promoted to fill the open secondary slot.",
      "ja": "[3]一時的または永続的にのいずれかで、プライマリ状態に昇格された二次たら、セカンダリのリスト上の次のサーバは、オープン二次スロットを埋めるために促進されます。"
    },
    {
      "indent": 3,
      "text": "[4] The client or agent periodically attempts to re-open closed connections, so that it is possible that a previously closed connection can be returned to service and become eligible for use again. Implementations will typically retain a limit on the number of connections open at a time, so that once a previously closed connection is brought online again, the lowest priority secondary connection will be closed. In order to prevent periodic closing and re-opening of secondary connections, it is recommended that functioning connections remain open for a minimum of 5 minutes.",
      "ja": "以前に閉じられた接続がサービスに戻され、再度使用するために対象になることができることが可能となるように[4]クライアントまたはエージェントは、定期的に再オープン接続を閉鎖しようとします。以前クローズ接続が再びオンラインになると、最も低い優先度の二次接続がクローズされるように、実装は、通常、一度にオープン接続数の制限を保持します。周期的な閉鎖とセカンダリ接続の再開放を防止するためには、機能の接続が5分以上開いたままにすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "[5] In order to enable diagnosis of failover behavior, it is recommended that a table of failover events be kept within the MIB. These failover events SHOULD include appropriate transaction identifiers so that client and server data can be compared, providing insight into the cause of the problem (transport or application layer).",
      "ja": "[5]フェイルオーバー動作の診断を可能にするためには、フェイルオーバー・イベントのテーブルをMIB内に維持することが推奨されます。クライアントとサーバーのデータが問題（輸送またはアプリケーション層）の原因への洞察を提供し、比較できるように、これらのフェイルオーバー・イベントは、適切なトランザクション識別子を含むべきです。"
    },
    {
      "indent": 0,
      "text": "3.4.3. Connection Load Balancing",
      "section_title": true,
      "ja": "3.4.3。接続ロード・バランシング"
    },
    {
      "indent": 3,
      "text": "Primary/secondary failover is capable of providing improved resilience and basic load balancing. However, it does not address TCP head of line blocking, since only a single connection is in use at a time.",
      "ja": "プライマリ/セカンダリフェールオーバーが改善された弾力性と基本的な負荷分散を提供することが可能です。唯一の単一の接続が一度に使用されているので、しかし、それは、ラインブロッキングのTCPヘッドに対応していません。"
    },
    {
      "indent": 3,
      "text": "A AAA client or agent maintaining connections to multiple agents or servers MAY load balance between them. Establishing connections to multiple agents or servers reduces, but does not eliminate, head of line blocking issues experienced on TCP connections. This issue does not exist with SCTP connections utilizing multiple streams.",
      "ja": "複数のエージェントまたはサーバーへの接続を維持するAAAクライアントまたはエージェントがそれらの間のバランスをロードします。複数のエージェントまたはサーバーへの接続を確立することは減少しますが、TCP接続上で経験した問題をブロックラインの先頭がなくなるわけではありません。この問題は、複数のストリームを利用SCTP接続には存在しません。"
    },
    {
      "indent": 3,
      "text": "In connection load balancing configurations, the application watchdog operates as follows:",
      "ja": "次のように接続ロード・バランシングの構成では、アプリケーションウォッチドッグが動作します。"
    },
    {
      "indent": 3,
      "text": "[1] Assume that each client or agent is initially configured with connections to multiple AAA agents or servers, with one connection between a given client/agent and an agent/server.",
      "ja": "[1]各クライアントまたはエージェントが最初に与えられたクライアント/エージェントとエージェント/サーバ間の1つの接続と、複数のAAAエージェント、またはサーバへの接続で構成されているものとします。"
    },
    {
      "indent": 3,
      "text": "[2] In static load balancing, transactions are apportioned among the connections based on the total number of connections and a \"weight\" assigned to each connection. Pearson's hash [RFC3074] applied to the NAI [RFC2486] can be used to determine which connection will handle a given transaction. Hashing on the NAI provides highly granular load balancing, while ensuring that all traffic for a given conversation will be sent to the same agent or server. In dynamic load balancing, the value of the \"weight\" can vary based on conditions such as AAA server load. Such techniques, while sophisticated, are beyond the scope of this document.",
      "ja": "[2]静的負荷分散において、トランザクションは、接続の総数と各接続に割り当てられた「重み」に基づいて接続間で配分されます。ピアソンのハッシュ[RFC3074]はNAI [RFC2486]に適用される特定のトランザクションを処理するどの接続を決定するために使用することができます。特定の会話のすべてのトラフィックが同じエージェントまたはサーバーに送信されることを確保しながら、NAIにハッシュする、きめ細かいロード・バランシングを提供します。動的負荷分散では、「重量」の値は、AAAサーバ負荷などの条件に基づいて変化することができます。このような技術は、洗練された一方で、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "[3] Transactions are distributed to connections based on the total number of available connections and their weights. A change in the number of available connections forces recomputation of the hash table. In order not to cause conversations in progress to be switched to new destinations, on recomputation, a transitional period is required in which both old and new hash tables are needed in order to permit aging out of conversations in progress. Note that this requires a way to easily determine whether a Request represents a new conversation or the continuation of an existing conversation. As a result, removing and adding of connections is an expensive operation, and it is recommended that the hash table only be recomputed once a connection is closed or returned to service.",
      "ja": "[3]トランザクションは、利用可能な接続とその重みの合計数に基づいて、接続に分配されます。ハッシュテーブルの使用可能な接続を強制的に再計算の数の変化。進行中の会話は新しい宛先に切り替えることが原因としないようにするためには、再計算の上、移行期間は、新旧両方のハッシュテーブルが進行中の会話のうち、老朽化可能にするために必要とされている必要があります。これは簡単にリクエストが新しい会話したり、既存の会話の継続を表しているかどうかを決定するための方法が必要であることに注意してください。結果として、除去し、接続の追加は高価な操作であり、それは、接続が閉じられ又はサービスに戻されると、ハッシュテーブルのみを再計算することが推奨されます。"
    },
    {
      "indent": 7,
      "text": "Suspended connections, although they are not used, do not force\nhash table reconfiguration until they are closed.  Similarly,\nre-opened connections not accumulating sufficient watchdog\nresponses do not force a reconfiguration until they are returned\nto service.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "While a connection is suspended, transactions that were to have been assigned to it are instead assigned to the next available server. While this results in a momentary imbalance, it is felt that this is a relatively small price to pay in order to reduce hash table thrashing.",
      "ja": "接続が中断されているが、それに割り当てられているためにした取引は、代わりに次の使用可能なサーバーに割り当てられています。これは瞬間的な不均衡につながるが、ハッシュテーブルのスラッシングを減らすために支払うために比較的小さい価格であると感じています。"
    },
    {
      "indent": 3,
      "text": "[4] In order to enable diagnosis of load balancing behavior, it is recommended that in addition to a table of failover events, a table of statistics be kept on each client, indexed by a AAA server. That way, the effectiveness of the load balancing algorithm can be evaluated.",
      "ja": "[4]ロードバランシング動作の診断を可能にするためには、フェイルオーバー・イベントのテーブルに加えて、統計の表をAAAサーバによってインデックス付け、各クライアント上に保持することが推奨されます。こうすることで、負荷分散アルゴリズムの有効性を評価することができます。"
    },
    {
      "indent": 0,
      "text": "3.5. Duplicate Detection",
      "section_title": true,
      "ja": "3.5。重複検出"
    },
    {
      "indent": 3,
      "text": "Multiple facilities are required to enable duplicate detection. These include session identifiers as well as hop-by-hop and end-to-end message identifiers. Hop-by-hop identifiers whose value may change at each hop are not sufficient, since a AAA server may receive the same message from multiple agents. For example, a AAA client can send a request to Agent1, then failover and resend the request to Agent2; both agents forward the request to the home AAA server, with different hop-by-hop identifiers. A Session Identifier is insufficient as it does not distinguish different messages for the the same session.",
      "ja": "複数の施設は、重複検出を有効にする必要があります。これらは、セッション識別子、ならびにホップバイホップとエンドツーエンドのメッセージ識別子を含みます。 AAAサーバは、複数のエージェントから同じメッセージを受信することができるので、その値は各ホップで変更することができるホップバイホップ識別子は、十分ではありません。たとえば、AAAクライアントは、フェイルオーバーおよびエージェント2に要求を再送信し、その後、エージェント1に要求を送信することができます。両方の薬剤は、異なるホップバイホップ識別子と、ホームAAAサーバに要求を転送します。それは同じセッションのために異なるメッセージを区別しないように、セッション識別子は不十分です。"
    },
    {
      "indent": 3,
      "text": "Proper treatment of the end-to-end message identifier ensures that AAA operations are idempotent. For example, without an end-to-end identifier, a AAA server keeping track of simultaneous logins might send an Accept in response to an initial Request, and then a Reject in response to a duplicate Request (where the user was allowed only one simultaneous login). Depending on which Response arrived first, the user might be allowed access or not.",
      "ja": "エンドツーエンドのメッセージ識別子の適切な処置は、AAA操作が冪等であることを保証します。例えば、エンドツーエンドの識別子なしに、同時ログインを追跡するAAAサーバは、最初の要求に応答して受け入れ、そして、ユーザが一つだけが同時せた重複要求（に応答拒否を送信するかもしれませんログインする）。これに応じて応答が、最初に到着したユーザーがアクセスを許可またはいない可能性があります。"
    },
    {
      "indent": 3,
      "text": "However, if the server were to store the end-to-end message identifier along with the simultaneous login information, then the duplicate Request (which utilizes the same end-to-end message identifier) could be identified and the correct response could be returned.",
      "ja": "サーバは、次に同時ログイン情報、（同一のエンド・ツー・エンドのメッセージ識別子を利用する）重複要求と共に、エンドツーエンドのメッセージ識別子を格納した場合しかし、同定することができ、正しい応答を返すことができます。"
    },
    {
      "indent": 0,
      "text": "3.6. Invalidation of Transport Parameter Estimates",
      "section_title": true,
      "ja": "3.6。交通パラメータ推定値の無効化"
    },
    {
      "indent": 3,
      "text": "In order to address invalidation of transport parameter estimates, AAA protocol implementations MAY utilize Congestion Window Validation [RFC2861] and RTO validation when using TCP. This specification also recommends a procedure for RTO validation.",
      "ja": "TCPを使用する場合、トランスポートパラメータ推定値の無効化に対処するために、AAAプロトコルの実装は、輻輳ウィンドウ検証[RFC2861]とRTOの検証を利用することができます。また、この仕様はRTOの検証のための手順を推奨しています。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] and [RFC2861] both recommend that a connection go into slow-start after a period where no traffic has been sent within the RTO interval. [RFC2861] recommends only increasing the congestion window if it was full when the ACK arrived. The congestion window is reduced by half once every RTO interval if no traffic is received.",
      "ja": "[RFC2581]と[RFC2861]は、両方の接続がトラフィックがRTO間隔内に送信されていない期間の後のスロースタートに入ることをお勧めします。 [RFC2861]はACKが到着したとき、それは完全だった場合のみ、輻輳ウィンドウの増加をお勧めします。トラフィックが受信されない場合、輻輳ウィンドウを半分に一度RTO間隔によって低減されます。"
    },
    {
      "indent": 3,
      "text": "When Congestion Window Validation is used, the congestion window will not build during application-driven periods, and instead will be decayed. As a result, AAA applications operating within the application-driven regime will typically run with a congestion window equal to the initial window much of the time, operating in \"perpetual slowstart\".",
      "ja": "輻輳ウィンドウ検証を使用すると、輻輳ウィンドウは、アプリケーション主導の期間中に構築しなくなり、代わりに減衰されます。その結果、アプリケーション主導の政権内で動作するAAAのアプリケーションは、典型的には、「永遠のスロースタート」で動作し、時間の非常に初期の窓に等しい混雑ウィンドウで実行されます。"
    },
    {
      "indent": 3,
      "text": "During periods in which AAA behavior is application-driven this will have no effect. Since the time between packets will be larger than RTT, AAA will operate with an effective congestion window equal to the initial window. However, during network-driven periods, the effect will be to space out sending of AAA packets. Thus instead of being able to send a large burst of packets into the network, a client will need to wait several RTTs as the congestion window builds during slow-start.",
      "ja": "中期間中AAAの動作は、アプリケーション主導型これは効果がありませんです。パケット間の時間がRTTよりも大きくなるので、AAAは、初期画面に等しい有効な混雑ウィンドウで動作します。しかし、ネットワーク主導の期間中、効果はAAAパケットの送信外空間になります。したがって、代わりにネットワークにパケットの大バーストを送信することができるという、クライアントは、輻輳ウィンドウはスロースタート時に構築するなど、いくつかのRTTを待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, a client operating over TCP with an initial window of 2, with 35 AAA requests to send would take approximately 6 RTTs to send them, as the congestion window builds during slow start: 2, 3, 3, 6, 9, 12. After the backlog is cleared, the implementation will once again be application-driven and the congestion window size will decay. If the client were using SCTP, the number of RTTs needed to transmit all requests would usually be less, and would depend on the size of the requests, since SCTP tracks the progress for the opening of the congestion window by bytes, not segments.",
      "ja": "2、3、3、6、9、12：輻輳ウィンドウは、スロースタート中に構築するよう例えば、送信するための35回のAAA要求と2の初期ウィンドウでTCP上で動作するクライアントは、それらを送信するために約6つのRTTを取りますバックログがクリアされた後、実装は再びアプリケーション主導型と減衰します輻輳ウィンドウサイズになります。クライアントがSCTPを使用していた場合、RTTの数がすべての要求を送信するために必要な通常より少なくなり、そしてSCTPはバイトではなく、セグメント別の輻輳ウィンドウのオープンのための進行状況を追跡するので、要求のサイズに依存します。"
    },
    {
      "indent": 3,
      "text": "Note that [RFC2861] and [RFC2988] do not address the issue of RTO validation. This is also a problem, particularly when the Congestion Manager [RFC3124] is implemented. During periods of high packet loss, the RTO may be repeatedly increased via exponential back-off, and may attain a high value. Due to lack of timely feedback on RTT and RTO during application-driven periods, the high RTO estimate may persist long after the conditions that generated it have dissipated.",
      "ja": "[RFC2861]と[RFC2988]はRTOの検証の問題に対処していないことに注意してください。これは、輻輳マネージャ[RFC3124]が実装されている場合は特に、また問題です。高いパケット損失の期間中、RTOが繰り返し指数バックオフを介して増加させることができる、と高い値を達成することができます。それを生成した条件が消失した後にアプリケーション主導の期間中のRTTとRTOのタイムリーなフィードバックの欠如に起因する、高いRTO推定値が長く持続します。"
    },
    {
      "indent": 3,
      "text": "RTO validation MAY be used to address this issue for TCP, via the following procedure:",
      "ja": "RTOの検証は、以下の手順を経て、TCPのために、この問題に対処するために使用することがあります。"
    },
    {
      "indent": 6,
      "text": "After the congestion window is decayed according to [RFC2861], reset the estimated RTO to 3 seconds. After the next packet comes in, re-calculate RTTavg, RTTdev, and RTO according to the method described in [RFC2581].",
      "ja": "輻輳ウィンドウは、[RFC2861]に記載の減衰された後、3秒と推定RTOをリセットします。次のパケットが到着した後、[RFC2581]に記載された方法に従ってRTTavg、RTTdev、及びRTOを再計算します。"
    },
    {
      "indent": 3,
      "text": "To address this issue for SCTP, AAA implementations SHOULD use SCTP heartbeats. [RFC2960] states that heartbeats should be enabled by default, with an interval of 30 seconds. If this interval proves to be too long to resolve this issue, AAA implementations MAY reduce the heartbeat interval.",
      "ja": "SCTPのために、この問題に対処するには、AAA実装はSCTPハートビートを使用すべきです。 [RFC2960]はハートビートが30秒の間隔で、デフォルトで有効にする必要があると述べています。この間隔は、この問題を解決するには長すぎることが判明した場合、AAAの実装は、ハートビート間隔を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "3.7. Inability to Use Fast Re-Transmit",
      "section_title": true,
      "ja": "3.7。高速再送信を使用することができません"
    },
    {
      "indent": 3,
      "text": "When Congestion Window Validation [RFC2861] is used, AAA implementations will operate with a congestion window equal to the initial window much of the time. As a result, the window size will often not be large enough to enable use of fast re-transmit for TCP. In addition, since AAA traffic is two-way, ACKs carrying data will not count towards triggering fast re-transmit. SCTP is less likely to encounter this issue, so the measures described below apply to TCP.",
      "ja": "輻輳ウィンドウ検証[RFC2861]を使用する場合、AAA実装は時間のはるかに初期画面に等しい混雑ウィンドウで動作します。その結果、ウィンドウサイズは、多くの場合、TCPのための高速再送信の使用を可能にするのに十分な大きさではありません。また、AAAトラフィックが双方向であることから、ACKを搬送するデータは、高速再送信をトリガにカウントされません。 SCTPは、この問題が発生する可能性が低いので、下記の対策は、TCPに適用されます。"
    },
    {
      "indent": 3,
      "text": "To address this issue, AAA implementations SHOULD support selective acknowledgement as described in [RFC2018] and [RFC2883]. AAA implementations SHOULD also implement Limited Transmit for TCP, as described in [RFC3042]. Rather than reducing the number of duplicate ACKs required for triggering fast recovery, which would increase the number of inappropriate re-transmissions, Limited Transmit enables the window size be increased, thus enabling the sending of additional packets which in turn may trigger fast re-transmit without a change to the algorithm.",
      "ja": "[RFC2018]及び[RFC2883]に記載されているように、この問題に対処するために、AAA実装は選択的確認応答をサポートしなければなりません。 [RFC3042]に記載されているようにAAA実装はまた、TCPための限られた送信を実装する必要があります。むしろ不適切な再送信の数を増加させるであろう速い回復をトリガするために必要な重複ACKの数を減少させるよりも、限定送信は、このように順番に高速再送信をトリガすることができる追加のパケットの送信を可能にする、ウィンドウサイズを大きくすることが可能アルゴリズムの変更なし。"
    },
    {
      "indent": 3,
      "text": "However, if congestion window validation [RFC2861] is implemented, this proposal will only have an effect in situations where the time between packets is less than the estimated retransmission timeout (RTO). If the time between packets is greater than RTO, additional packets will typically not be available for sending so as to take advantage of the increased window size. As a result, AAA protocols will typically operate with the lowest possible congestion window size, resulting in a re-transmission timeout for every lost packet.",
      "ja": "輻輳ウィンドウの検証[RFC2861]が実装されている場合しかし、この提案は、パケット間の時間は、推定再送タイムアウト（RTO）未満である状況において効果を有するであろう。パケット間の時間がRTOよりも大きい場合は、追加のパケットは、一般的に増加し、ウィンドウサイズを利用するように送信するために使用することはできません。結果として、AAAプロトコルは、典型的には、すべての失われたパケットの再送信タイムアウトになり、可能な最低の輻輳ウィンドウサイズで動作します。"
    },
    {
      "indent": 0,
      "text": "3.8. Head of Line Blocking",
      "section_title": true,
      "ja": "3.8。ラインブロッキングのヘッド"
    },
    {
      "indent": 3,
      "text": "TCP inherently does not provide a solution to the head-of-line blocking problem, although its effects can be lessened by implementation of Limited Transmit [RFC3042], and connection load balancing.",
      "ja": "その効果は限定ミット[RFC3042]、および接続ロード・バランシングの実装によって軽減することができますが、TCPは本質的に、ヘッドオブラインブロッキングの問題に対する解決策を提供していません。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Using SCTP Streams to Prevent Head of Line Blocking",
      "section_title": true,
      "ja": "3.8.1。ラインの先頭の阻止を防ぐために、SCTPストリームの使用"
    },
    {
      "indent": 3,
      "text": "Each AAA node SHOULD distribute its messages evenly across the range of SCTP streams that it and its peer have agreed upon. (A lost message in one stream will not cause any other streams to block.) A trivial and effective implementation of this simply increments a counter for the stream ID to send on. When the counter reaches the maximum number of streams for the association, it resets to 0.",
      "ja": "均等SCTPの範囲にわたって、そのメッセージを配信する各AAAノードは、そのピアが合意されていることをストリーム。 （一つのストリームで失われたメッセージが他のストリームをブロックすることはありません。）この些細なかつ有効な実施は、単に上の送信するストリームIDのためのカウンタをインクリメントします。カウンタは、関連付けのためのストリームの最大数に達すると、0にリセットします。"
    },
    {
      "indent": 3,
      "text": "AAA peers MUST be able to accept messages on any stream. Note that streams are used *solely* to prevent head-of-the-line blocking. All identifying information is carried within the Diameter payload. Messages distributed across multiple streams may not be received in the order they are sent.",
      "ja": "AAAピアがどのストリーム上のメッセージを受け入れることができなければなりません。ストリームは、ヘッドオブラインブロッキングを防ぐために*のみ*を使用していることに注意してください。すべての識別情報は、直径ペイロード内で搬送されます。複数のストリームに分散メッセージは、それらが送信される順序で受信されなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "SCTP peers can allocate up to 65535 streams for an association. The cost for idle streams may or may not be zero, depending on the implementation, and the cost for non-idle streams is always greater than 0. So administrators may wish to limit the number of possible streams on their diameter nodes according to the resources (i.e. memory, CPU power, etc.) of a particular node.",
      "ja": "SCTPピアは、協会のために65535個のまでのストリームを割り当てることができます。アイドル・ストリームのためのコストは、またはしない場合があり、実装に依存して、ゼロであってもよく、非アイドルストリームのコストはいつも管理者がリソースに応じてそれらの直径ノードに可能なストリームの数を制限したい場合が0よりも大きいです特定のノード（すなわち、メモリ、CPUパワー、等）。"
    },
    {
      "indent": 3,
      "text": "On a Diameter client, the number of streams may be determined by the maximum number of peak users on the NAS. If a stream is available per user, then this should be sufficient to prevent head-of-line blocking. On a Diameter proxy, the number of streams may be determined by the maximum number of peak sessions in progress from that proxy to each downstream AAA server.",
      "ja": "Diameterクライアントに、ストリームの数は、NAS上のピークユーザの最大数によって決定することができます。ストリームは、ユーザごとに利用可能である場合、これはヘッドオブラインブロッキングを防ぐのに十分であるべきです。直径プロキシで、ストリームの数は、各ダウンストリームAAAサーバへのプロキシから進行中のピークセッションの最大数によって決定することができます。"
    },
    {
      "indent": 3,
      "text": "Stream IDs do not need to be preserved by relay agents. This simplifies implementation, as agents can easily handle forwarding between two associations with different numbers of streams. For example, consider the following case, where a relay server DRL forwards messages between a NAS and a home server, HMS. The NAS and DRL have agreed upon 1000 streams for their association, and DRL and HMS have agreed upon 2000 streams for their association. The following figure shows the message flow from NAS to HMS via DRL, and the stream ID assignments for each message:",
      "ja": "ストリームIDは、リレーエージェントによって保存する必要はありません。薬剤は容易ストリームの異なる数を有する2つの団体の間での転送を処理することができ、これは、実装を簡素化します。例えば、中継サーバDRLは、NASとホームサーバ、HMS間でメッセージを転送し、次の場合を考えます。 NASとDRLは、その関連付けのために1000個のストリームに合意しており、DRLとHMSは、そのアソシエーションの2000年のストリームに合意しています。次の図は、メッセージごとにDRLを介してHMSにNASからのメッセージフロー、及びストリームIDの割り当てを示しています。"
    },
    {
      "indent": 3,
      "text": "+------+                   +------+                   +------+\n|      |                   |      |                   |      |\n| NAS  |    --------->     | DRL  |     --------->    | HMS  |\n|      |                   |      |                   |      |\n+------+   1000 streams    +------+    2000 streams   +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "msg 1: str id 0             msg 1: str id 0\nmsg 2: str id 1             msg 2: str id 1\n...\nmsg 1000: str id 999        msg 1000: str id 999\nmsg 1001: str id 0          msg 1001: str id 1000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DRL can forward messages 1 through 1000 to HMS using the same stream ID that NAS used to send to DRL. However, since the NAS / DRL association has only 1000 streams, NAS wraps around to stream ID 0 when sending message 1001. The DRL / HMS association, on the other hand, has 2000 streams, so DRL can reassign message 1001 to stream ID 1000 when forwarding it on to HMS.",
      "ja": "DRLは、NASは、DRLに送信するために使用したのと同じストリームIDを使用してHMS 1000を介してメッセージ1を転送することができます。 DRLは、ID 1000をストリーミングするメッセージ1001を再割り当てできるように、NAS / DRLアソシエーションのみ千ストリームを有しているので、NASは、DRL / HMSアソシエーションメッセージ1001を送信するときにID 0をストリーミングするためにラップアラウンドし、一方、2000のストリームを有しますHMSにそれを転送するとき。"
    },
    {
      "indent": 3,
      "text": "This distribution scheme acts like a hash table. It is possible, yet unlikely, that two messages will end up in the same stream, and even less likely that there will be message loss resulting in blocking when this happens. If it does turn out to be a problem, local administrators can increase the number of streams on their nodes to improve performance.",
      "ja": "この配信方式は、ハッシュテーブルのような役割を果たします。これは、2つのメッセージが同じストリームで終わるだろうということ、さらには可能性が低いこの問題が発生したときに、ブロッキングが生じメッセージの損失があることを、まだ、可能性は低い可能です。それが問題になることが判明しない場合は、ローカル管理者は、パフォーマンスを向上させるために、そのノード上でストリームの数を増やすことができます。"
    },
    {
      "indent": 0,
      "text": "3.9. Congestion Avoidance",
      "section_title": true,
      "ja": "3.9。輻輳回避"
    },
    {
      "indent": 3,
      "text": "In order to improve upon default timer estimates, AAA implementations MAY implement the Congestion Manager (CM) [RFC3124]. CM is an end-system module that:",
      "ja": "デフォルトのタイマーの推定を改善するためには、AAA実装は輻輳マネージャ（CM）[RFC3124]を実装してもよい（MAY）。 CMはそのエンド・システム・モジュールです。"
    },
    {
      "indent": 7,
      "text": "(i) Enables an ensemble of multiple concurrent streams from a\n    sender destined to the same receiver and sharing the same\n    congestion properties to perform proper congestion avoidance\n    and control, and",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "(ii) Allows applications to easily adapt to network congestion.",
      "ja": "（ⅱ）のアプリケーションが簡単にネットワークの輻輳に適応することができます。"
    },
    {
      "indent": 3,
      "text": "The CM helps integrate congestion management across all applications and transport protocols. The CM maintains congestion parameters (available aggregate and per-stream bandwidth, per-receiver round-trip times, etc.) and exports an API that enables applications to learn about network characteristics, pass information to the CM, share congestion information with each other, and schedule data transmissions.",
      "ja": "CMは、すべてのアプリケーションおよびトランスポートプロトコル間で輻輳管理を統合するのに役立ちます。 CMは（等利用可能な骨材とあたりストリーム帯域ごとの受信機の往復回）混雑パラメータを維持し、アプリケーションがネットワーク特性について学習を可能にするAPIをエクスポートし、互いにCM、共有渋滞情報に情報を渡します、およびスケジュールデータ伝送。"
    },
    {
      "indent": 3,
      "text": "The CM enables the AAA application to access transport parameters (RTTavg, RTTdev) via callbacks. RTO estimates are currently not available via the callback interface, though they probably should be. Where available, transport parameters SHOULD be used to improve upon default timer values.",
      "ja": "CMは、コールバックを介してトランスポートパラメータ（RTTavg、RTTdev）にアクセスするためのAAAのアプリケーションを可能にします。彼らはおそらくあるべきにもかかわらずRTO推定値は、コールバックインタフェースを介して、現在は利用できません。利用可能な場合、トランスポートパラメータは、デフォルトのタイマー値を改善するために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.10. Premature Failover",
      "section_title": true,
      "ja": "3.10。早期のフェイルオーバー"
    },
    {
      "indent": 3,
      "text": "Premature failover is prevented by the watchdog functionality described above. If the next hop does not return a reply, the AAA client will send a watchdog message to it to verify liveness. If a watchdog reply is received, then the AAA client will know that the next hop server is functioning at the application layer. As a result, it is only necessary to provide terminal error messages, such as the following:",
      "ja": "早期フェイルオーバーは、上記ウォッチドッグ機能によって防止されます。次のホップが応答を返さない場合は、AAAクライアントが生存性を検証するために、それにウォッチドッグ・メッセージを送信します。ウォッチドッグ応答が受信されている場合は、AAAクライアントは、次ホップサーバーは、アプリケーション層で機能していることを知っています。その結果、次のような端末のエラーメッセージを提供することだけが必要です。"
    },
    {
      "indent": 6,
      "text": "\"Busy\": agent/Server too busy to handle additional requests, NAS should failover all requests to another agent/server.",
      "ja": "「忙しい」：追加の要求を処理するにはあまりにも忙しいエージェント/サーバ、NASは、別のエージェント/サーバーへのすべての要求をフェイルオーバーする必要があります。"
    },
    {
      "indent": 6,
      "text": "\"Can't Locate\": agent can't locate the AAA server for the indicated realm; NAS should failover that request to another proxy.",
      "ja": "「検出できない」：エージェントは、指定されたレルムのAAAサーバを見つけることができません。 NASは、別のプロキシにその要求をフェイルオーバーする必要があります。"
    },
    {
      "indent": 6,
      "text": "\"Can't Forward\": agent has tried both primary and secondary AAA servers with no response; NAS should failover the request to another agent.",
      "ja": "「転送することはできません」：エージェントが応答なしでプライマリとセカンダリの両方のAAAサーバを試してみました。 NASは、別のエージェントにリクエストをフェイルオーバーする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that these messages differ in their scope. The \"Busy\" message tells the NAS that the agent/server is too busy for ANY request. The \"Can't Locate\" and \"Can't Forward\" messages indicate that the ultimate destination cannot be reached or isn't responding, implying per-request failover.",
      "ja": "これらのメッセージは、その範囲が異なることに注意してください。 「ビジー」メッセージは、エージェント/サーバはすべての要求のために忙しすぎていることをNASに指示します。 「フォワードできません」というメッセージが最終目的地に到達することができないか、要求ごとのフェイルオーバーを示唆し、応答していないことを示し、「検出できない」と。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Since AAA clients, agents and servers serve as network access gatekeepers, they are tempting targets for attackers. General security considerations concerning TCP congestion control are discussed in [RFC2581]. However, there are some additional considerations that apply to this specification.",
      "ja": "AAAクライアント、エージェントとサーバーがネットワークアクセスゲートキーパーとして機能しているので、彼らは攻撃者のための魅力的な標的です。 TCPの輻輳制御に関する一般的なセキュリティ上の考慮事項は、[RFC2581]で議論されています。しかし、この仕様に適用されるいくつかの追加の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "By enabling failover between AAA agents, this specification improves the resilience of AAA applications. However, it may also open avenues for denial of service attacks.",
      "ja": "AAAエージェントとの間のフェイルオーバーを可能にすることにより、本明細書はAAAアプリケーションの回復力を向上させることができます。しかし、それはまた、サービス拒否攻撃のために道を開く可能性があります。"
    },
    {
      "indent": 3,
      "text": "The failover algorithm is driven by lack of response to AAA requests and watchdog packets. On a lightly loaded network where AAA responses would not be received prior to expiration of the watchdog timer, an attacker can swamp the network, causing watchdog packets to be dropped. This will cause the AAA client to switch to another AAA agent, where the attack can be repeated. By causing the AAA client to cycle between AAA agents, service can be denied to users desiring network access.",
      "ja": "フェイルオーバーアルゴリズムは、AAA要求とウォッチドッグパケットに対する応答の欠如によって駆動されます。 AAAの応答は前にウォッチドッグタイマの満了に受信されない負荷の軽いネットワークでは、攻撃者がウォッチドッグパケットがドロップさせる、ネットワークを圧倒することができます。これは、AAAクライアントは攻撃を繰り返すことができる別のAAAエージェント、に切り替えることになります。 AAAエージェント間のサイクルにAAAクライアントを引き起こすことによって、サービスは、ネットワークアクセスを希望するユーザーに拒否することができます。"
    },
    {
      "indent": 3,
      "text": "Where TLS [RFC2246] is being used to provide AAA security, there will be a vulnerability to spoofed reset packets, as well as other transport layer denial of service attacks (e.g. SYN flooding). Since SCTP offers improved denial of service resilience compared with TCP, where AAA applications run over SCTP, this can be mitigated to some extent.",
      "ja": "TLS [RFC2246]はAAAセキュリティを提供するために使用されている場合、リセットパケットを偽装する脆弱性、ならびにサービス攻撃（例えば、SYNフラッディング）の他のトランスポート層拒否が存在するであろう。 SCTPは、AAAのアプリケーションがSCTP上で実行するTCPと比較サービス回復力の改善拒否を提供していますので、これはある程度緩和することができます。"
    },
    {
      "indent": 3,
      "text": "Where IPsec [RFC2401] is used to provide security, it is important that IPsec policy require IPsec on incoming packets. In order to enable a AAA client to determine what security mechanisms are in use on an agent or server without prior knowledge, it may be tempting to initiate a connection in the clear, and then to have the AAA agent respond with IKE [RFC2409]. While this approach minimizes required client configuration, it increases the vulnerability to denial of service attack, since a connection request can now not only tie up transport resources, but also resources within the IKE implementation.",
      "ja": "IPsecの[RFC2401]は、セキュリティを提供するために使用される場合、IPsecポリシーが着信パケットにIPsecを必要とすることが重要です。セキュリティメカニズムは、事前知識なしエージェントまたはサーバー上で使用されているかを決定するためにAAAクライアントを有効にするためには、AAA剤はIKE [RFC2409]で応答有するように、クリアで接続を開始し、そしてするために魅力的であってもよいです。このアプローチは、必要なクライアント構成を最小限に抑えながら、それはIKE実装内の接続要求は、現在唯一のトランスポートリソースをタイアップすることができないため、サービス拒否攻撃に対する脆弱性を増加させるだけでなく、資源。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not create any new number spaces for IANA administration.",
      "ja": "このドキュメントは、IANAの投与のための任意の新しい番号のスペースを作成しません。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC896] Nagle, J., \"Congestion Control in IP/TCP internetworks\", RFC 896, January 1984.",
      "ja": "[RFC896]ネーグル、J.、 \"IP / TCPインターネットワークにおける輻輳制御\"、RFC 896、1984年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク、D.、クロッカー、S.とJ.シラー、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2486] Aboba, B. and M. Beadles, \"The Network Access Identifier\", RFC 2486, January 1999.",
      "ja": "[RFC2486] Aboba、B.及びM. Beadles、 \"ネットワークアクセス識別子\"、RFC 2486、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V. and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581]オールマン、M.、パクソン、V.とW.スティーブンス、 \"TCP輻輳制御\"、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., Podolsky, M. and A. Romanow, \"An Extension to the Selective Acknowledgment (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、ポドルスキー、M.及びA. Romanow、 \"TCPのための選択的確認応答（SACK）オプションの拡張\"、RFC 2883、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L. and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.およびV.パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988]パクソン、V.とM.オールマン、 \"コンピューティングTCPの再送信タイマー\"、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan H. and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, January 2001.",
      "ja": "[RFC3042]オールマン、M.、バラクリシュナンH.とS.フロイド、 \"株式会社トランスミットを使用したTCPの損失回復の強化\"、RFC 3042、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3074] Volz, B., Gonczi, S., Lemon, T. and R. Stevens, \"DHC Load Balancing Algorithm\", RFC 3074, February 2001.",
      "ja": "[RFC3074]フォルツ、B.、Gonczi、S.、レモン、T.及びR.スティーブンス、 \"DHCロードバランシングアルゴリズム\"、RFC 3074、2001年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion Manager\", RFC 3124, June 2001.",
      "ja": "[RFC3124]バラクリシュナン、H.とS. Seshan、 \"輻輳管理\"、RFC 3124、2001年6月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2246] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[RFC2246]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2401] Atkinson, R. and S. Kent, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401]アトキンソン、R.とS.ケント、「インターネットプロトコルのためのセキュリティー体系」、RFC2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "ja": "[RFC2409]ハーキンとD.とD.カレル、 \"インターネットキー交換（IKE）\"、RFC 2409、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2607] Aboba, B. and J. Vollbrecht, \"Proxy Chaining and Policy Implementation in Roaming\", RFC 2607, June 1999.",
      "ja": "[RFC2607] Aboba、B.、およびJ. Vollbrecht、 \"ローミング中のプロキシ連鎖とポリシー実装\"、RFC 2607、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2861] Handley, M., Padhye, J. and S. Floyd, \"TCP Congestion Window Validation\", RFC 2861, June 2000.",
      "ja": "[RFC2861]ハンドレー、M.、Padhye、J.及びS.フロイド、 \"TCP輻輳ウィンドウ検証\"、RFC 2861、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A. and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.とW.シンプソン、RFC 2865、2000年6月 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2866] Rigney, C., \"RADIUS Accounting\", RFC 2866, June 2000.",
      "ja": "[RFC2866] Rigney、C.、 \"RADIUSアカウンティング\"、RFC 2866、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S.、 \"輻輳制御の原理\"、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2975] Aboba, B., Arkko, J. and D. Harrington, \"Introduction to Accounting Management\", RFC 2975, June 2000.",
      "ja": "[RFC2975] Aboba、B.、Arkko、J.とD.ハリントン、 \"会計管理の概要\"、RFC 2975、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3390] Allman, M., Floyd, S. and C. Partridge, \"Increasing TCP's Initial Window\", RFC 3390, October 2002.",
      "ja": "[RFC3390]オールマン、M.、フロイド、S.とC.ヤマウズラ、 \"増加するTCPの初期ウィンドウ\"、RFC 3390、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[Congest] Jacobson, V., \"Congestion Avoidance and Control\", Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z",
      "ja": "[混雑する]ジェーコブソン、V.、「輻輳回避とコントロール」、コンピュータコミュニケーションレビュー、巻。 18、ありません。 4、頁314から329 8月1988 ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z"
    },
    {
      "indent": 3,
      "text": "[Paxson] Paxson, V., \"Measurement and Analysis of End-to-End Internet Dynamics\", Ph.D. Thesis, Computer Science Division, University of California, Berkeley, April 1997.",
      "ja": "[パクソン]パクソン、V.、「エンドツーエンドのインターネットダイナミクスの測定と分析」、博士論文、コンピュータサイエンス部門、カリフォルニア大学バークレー校、1997年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A - Detailed Watchdog Algorithm",
      "ja": "付録A  - 詳細なウォッチドッグアルゴリズム"
    },
    {
      "indent": 3,
      "text": "In this Appendix, the memory control structure that contains all information regarding a specific peer is referred to as a Peer Control Block, or PCB. The PCB contains the following fields:",
      "ja": "この付録では、特定のピアに関する全ての情報を含むメモリ制御構造は、ピア制御ブロック、又はPCBと呼ばれます。 PCBは、次のフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "Status: OKAY: The connection is up SUSPECT: Failover has been initiated on the connection. DOWN: Connection has been closed. REOPEN: Attempting to reopen a closed connection INITIAL: The initial state of the pcb when it is first created. The pcb has never been opened.",
      "ja": "ステータス：OKAY：接続がSUSPECTアップです：フェールオーバーが接続上で開始されました。 DOWN：接続が閉じられています。 REOPEN：それが最初に作成されたとき、PCBの初期状態：クローズ接続INITIALを再開しようとしています。 PCBが開かれたことがありません。"
    },
    {
      "indent": 3,
      "text": "Variables: Pending: Set to TRUE if there is an outstanding unanswered watchdog request Tw: Watchdog timer value NumDWA: Number of DWAs received during REOPEN",
      "ja": "変数：保留中：ウォッチドッグタイマ値NumDWA：卓越した未回答ウォッチドッグ要求Twが存在する場合にTRUEに設定しDWAsの数がREOPEN中に受信しました"
    },
    {
      "indent": 3,
      "text": "Tw is the watchdog timer, measured in seconds. Every second, Tw is decremented. When it reaches 0, the OnTimerElapsed event (see below) is invoked. Pseudo-code for the algorithm is included on the following pages.",
      "ja": "Twが秒単位で測定されたウォッチドッグタイマ、です。毎秒、Twが減算されます。それが0になると、OnTimerElapsedイベントが（下記参照）が呼び出されます。アルゴリズムの擬似コードは、以下のページに含まれています。"
    },
    {
      "indent": 3,
      "text": "SetWatchdog()\n{\n/*\n SetWatchdog() is called whenever it is necessary\n to reset the watchdog timer Tw.  The value of the\n watchdog timer is calculated based on the default\n initial value TWINIT and a jitter ranging from\n -2 to 2 seconds.  The default for TWINIT is 30 seconds,\n and MUST NOT be set lower than 6 seconds.\n*/\n    Tw=TWINIT -2.0 + 4.0 * random() ;\n    SetTimer(Tw) ;\n    return ;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\n OnReceive() is called whenever a message\n is received from the peer.  This message MAY\n be a request or an answer, and can include\n DWR and DWA messages.  Pending is assumed to\n be a global variable.\n*/\nOnReceive(pcb, msgType)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "{\n   if (msgType == DWA) {\n        Pending = FALSE;\n        }\n   switch (pcb->Status){\n   case OKAY:\n        SetWatchdog();\n        break;\n   case SUSPECT:\n        pcb->Status = OKAY;\n        Failback(pcb);\n        SetWatchdog();\n        break;\n   case REOPEN:\n        if (msgType == DWA) {\n           NumDWA++;\n           if (NumDWA == 3) {\n              pcb->status = OKAY;\n              Failback();\n           }\n        } else {\n           Throwaway(received packet);\n        }\n        break;\n   case INITIAL:\n   case DOWN:\n        Throwaway(received packet);\n        break;\n   default:\n        Error(\"Shouldn't be here!\");\n        break;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\nOnTimerElapsed() is called whenever Tw reaches zero (0).\n*/\nOnTimerElapsed(pcb)\n{\n    switch (pcb->status){\n       case OKAY:\n          if (!Pending) {\n             SendWatchdog(pcb);\n             SetWatchdog();\n             Pending = TRUE;\n             break;\n          }\n          pcb->status = SUSPECT;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "          FailOver(pcb);\n          SetWatchdog();\n          break ;\n       case SUSPECT:\n          pcb->status = DOWN;\n          CloseConnection(pcb);\n          SetWatchdog();\n          break;\n       case INITIAL:\n       case DOWN:\n          AttemptOpen(pcb);\n          SetWatchdog();\n          break;\n       case REOPEN:\n          if (!Pending) {\n             SendWatchdog(pbc);\n             SetWatchdog();\n             Pending = TRUE;\n             break;\n          }\n          if (NumDWA < 0) {\n             pcb->status = DOWN;\n             CloseConnection(pcb);\n          } else {\n             NumDWA = -1;\n          }\n          SetWatchdog();\n          break;\n       default:\n          error(\"Shouldn't be here!);\n          break;\n       }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\nOnConnectionUp() is called whenever a connection comes up\n*/\nOnConnectionUp(pcb)\n{\n    switch (pcb->status){\n       case INITIAL:\n          pcb->status = OKAY;\n          SetWatchdog();\n          break;\n       case DOWN:\n          pcb->status = REOPEN;\n          NumDWA = 0;\n          SendWatchdog(pcb);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "          SetWatchdog();\n          Pending = TRUE;\n          break;\n       default:\n          error(\"Shouldn't be here!);\n          break;\n       }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*\nOnConnectionDown() is called whenever a connection goes down\n*/\nOnConnectionDown(pcb)\n{\n    pcb->status = DOWN;\n    CloseConnection();\n    switch (pcb->status){\n       case OKAY:\n          Failover(pcb);\n          SetWatchdog();\n          break;\n       case SUSPECT:\n       case REOPEN:\n          SetWatchdog();\n          break;\n       default:\n          error(\"Shouldn't be here!);\n          break;\n       }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*  Here is the state machine equivalent to the above code:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "STATE         Event                Actions              New State\n=====         ------               -------              ----------\nOKAY          Receive DWA          Pending = FALSE\n                                   SetWatchdog()        OKAY\nOKAY          Receive non-DWA      SetWatchdog()        OKAY\nSUSPECT       Receive DWA          Pending = FALSE\n                                   Failback()\n                                   SetWatchdog()        OKAY\nSUSPECT       Receive non-DWA      Failback()\n                                   SetWatchdog()        OKAY\nREOPEN        Receive DWA &        Pending = FALSE\n              NumDWA == 2          NumDWA++\n                                   Failback()           OKAY\nREOPEN        Receive DWA &        Pending = FALSE\n              NumDWA < 2           NumDWA++             REOPEN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "STATE         Event                Actions              New State\n=====         ------               -------              ----------\nREOPEN        Receive non-DWA      Throwaway()          REOPEN\nINITIAL       Receive DWA          Pending = FALSE\n                                   Throwaway()          INITIAL\nINITIAL       Receive non-DWA      Throwaway()          INITIAL\nDOWN          Receive DWA          Pending = FALSE\n                                   Throwaway()          DOWN\nDOWN          Receive non-DWA      Throwaway()          DOWN\nOKAY          Timer expires &      SendWatchdog()\n              !Pending             SetWatchdog()\n                                   Pending = TRUE       OKAY\nOKAY          Timer expires &      Failover()\n              Pending              SetWatchdog()        SUSPECT\nSUSPECT       Timer expires        CloseConnection()\n                                   SetWatchdog()        DOWN\nINITIAL       Timer expires        AttemptOpen()\n                                   SetWatchdog()        INITIAL\nDOWN          Timer expires        AttemptOpen()\n                                   SetWatchdog()        DOWN\nREOPEN        Timer expires &      SendWatchdog()\n              !Pending             SetWatchdog()\n                                   Pending = TRUE       REOPEN\nREOPEN        Timer expires &      CloseConnection()\n              Pending &            SetWatchdog()\n              NumDWA < 0                                DOWN\nREOPEN        Timer expires &      NumDWA = -1\n              Pending &            SetWatchdog()\n              NumDWA >= 0                               REOPEN\nINITIAL       Connection up        SetWatchdog()        OKAY\nDOWN          Connection up        NumDWA = 0\n                                   SendWatchdog()\n                                   SetWatchdog()\n                                   Pending = TRUE       REOPEN\nOKAY          Connection down      CloseConnection()\n                                   Failover()\n                                   SetWatchdog()        DOWN\nSUSPECT       Connection down      CloseConnection()\n                                   SetWatchdog()        DOWN\nREOPEN        Connection down      CloseConnection()\n                                   SetWatchdog()        DOWN\n*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B - AAA Agents",
      "ja": "付録B  -  AAAエージェント"
    },
    {
      "indent": 3,
      "text": "As described in [RFC2865] and [RFC2607], AAA agents have become popular in order to support services such as roaming and shared use networks. Such agents are used both for authentication/authorization, as well as accounting [RFC2975].",
      "ja": "[RFC2865]及び[RFC2607]に記載されているように、AAA剤は、ローミングなどのサービスと共用ネットワークをサポートするために普及しています。このような薬剤は、両方の認証/許可、ならびにアカウンティング[RFC2975]のために使用されます。"
    },
    {
      "indent": 3,
      "text": "AAA agents include:",
      "ja": "AAAのエージェントは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Relays Proxies Re-directs Store and Forward proxies Transport layer proxies",
      "ja": "リレープロキシストア＆フォワードプロキシトランスポート層プロキシを再指示"
    },
    {
      "indent": 3,
      "text": "The transport layer behavior of each of these agents is described below.",
      "ja": "これらの薬剤のそれぞれのトランスポート層の動作について説明します。"
    },
    {
      "indent": 0,
      "text": "B.1 Relays and Proxies",
      "ja": "B.1リレーおよびプロキシ"
    },
    {
      "indent": 3,
      "text": "While the application-layer behavior of relays and proxies are different, at the transport layer the behavior is similar. In both cases, two connections are established: one from the AAA client (NAS) to the relay/proxy, and another from the relay/proxy to the AAA server. The relay/proxy does not respond to a client request until it receives a response from the server. Since the two connections are de-coupled, the end-to-end conversation between the client and server may not self clock.",
      "ja": "リレーやプロキシのアプリケーション層の動作が異なっているが、トランスポート層で動作も同様です。中継/プロキシにAAAクライアント（NAS）からの1つを、およびAAAサーバに中継/プロキシから別の：両方の場合において、2つの接続が確立されています。それはサーバからの応答を受信するまでリレー/プロキシは、クライアントの要求に応答しません。 2つの接続が切り離されているので、クライアントとサーバ間のエンドツーエンドの会話は、自己のクロックではないことがあります。"
    },
    {
      "indent": 3,
      "text": "Since AAA transport is typically application-driven, there is frequently not enough traffic to enable ACK piggybacking. As a result, the Nagle algorithm is rarely triggered, and delayed ACKs may comprise nearly half the traffic. Thus AAA protocols running over reliable transport will see packet traffic nearly double that experienced with UDP transport. Since ACK parameters (such as the value of the delayed ACK timer) are typically fixed by the TCP implementation and are not tunable by the application, there is little that can be done about this.",
      "ja": "AAAの輸送は、通常、アプリケーション主導型であるため、ACKのピギーバックを可能にするために十分なトラフィックが頻繁にありません。その結果、Nagleアルゴリズムはほとんど誘発されず、ACKがほぼ半分のトラフィックを含んでいてもよい遅れています。したがって、信頼性の高いトランスポート上で実行されているAAAプロトコルはUDP輸送で経験ほぼ倍増パケットトラフィックが表示されます。 （例えば、遅延ACKタイマの値など）ACKパラメータは、典型的には、TCPの実装によって固定され、アプリケーションによって調整可能ていないので、これについて行うことができ、そのほとんどがあります。"
    },
    {
      "indent": 3,
      "text": "A typical trace of a conversation between a NAS, proxy and server is shown below:",
      "ja": "NAS、プロキシとサーバの間の会話の代表的トレースを以下に示します。"
    },
    {
      "indent": 3,
      "text": "Time            NAS           Relay/Proxy           Server\n------          ---           -----------           ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0               Request\n                ------->\nOTTnp + Tpr                     Request\n                                ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + TdA                     Delayed ACK\n                                <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTps +                                 Reply/ACK\nTpr + Tsr                                       <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTps +\nTpr + Tsr +                     Reply\nOTTsp + TpR                     <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTps +\nTpr + Tsr +                     Delayed ACK\nOTTsp + TdA                     ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTps +\nOTTsp + OTTpn +\nTpr + Tsr +      Delayed ACK\nTpR + TdA        ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key\n---\nOTT   = One-way Trip Time\nOTTnp = One-way trip time (NAS to Relay/Proxy)\nOTTpn = One-way trip time (Relay/Proxy to NAS)\nOTTps = One-way trip time (Relay/Proxy to Server)\nOTTsp = One-way trip time (Server to Relay/Proxy)\nTdA   = Delayed ACK timer\nTpr   = Relay/Proxy request processing time\nTpR   = Relay/Proxy reply processing time\nTsr   = Server request processing time",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "At time 0, the NAS sends a request to the relay/proxy. Ignoring the serialization time, the request arrives at the relay/proxy at time OTTnp, and the relay/proxy takes an additional Tpr in order to forward the request toward the home server. At time TdA after receiving the request, the relay/proxy sends a delayed ACK. The delayed ACK is sent, rather than being piggybacked on the reply, as long as TdA < OTTps + OTTsp + Tpr + Tsr + TpR.",
      "ja": "時間0で、NASは、リレー/プロキシにリクエストを送信します。シリアル化の時間を無視して、要求が時間OTTnpでリレー/プロキシに到着し、リレー/プロキシは、ホームサーバーに向けて要求を転送するために追加Tprのを取ります。当時TDAは、要求を受信した後、リレー/プロキシは、遅延ACKを送信します。遅延ACKをTDA <OTTps + OTTsp + Tprの+ Tsrの+ TPR限り、むしろ応答にピギーバックされるよりも、送信されます。"
    },
    {
      "indent": 3,
      "text": "Typically Tpr < TdA, so that the delayed ACK is sent after the relay/proxy forwards the request toward the server, but before the relay/proxy receives the reply from the server. However, depending on the TCP implementation on the relay/proxy and when the request is received, it is also possible for the delayed ACK to be sent prior to forwarding the request.",
      "ja": "典型的にはTprの<TDA、中継/プロキシがサーバに向けて要求を転送した後、しかし中継/プロキシサーバから応答を受信する前に、遅延されたACKが送信されるようになっています。しかし、TCP中継/プロキシに実装し、要求を受信した場合、また、遅延されたACK要求を転送する前に送信することが可能であるに応じ。"
    },
    {
      "indent": 3,
      "text": "At time OTTnp + OTTps + Tpr, the server receives the request, and Tsr later, it generates the reply. Where Tsr < TdA, the reply will contain a piggybacked ACK. However, depending on the server responsiveness and TCP implementation, the ACK and reply may be sent separately. This can occur, for example, where a slow database or storage system must be accessed prior to sending the reply.",
      "ja": "時間OTTnp + OTTps + Tprので、サーバは要求を受信し、TSRは、後に、それが応答を生成します。どこTsrの<TDAは、返信がピギーバックACKが含まれています。ただし、サーバーの応答性とTCPの実装に依存し、ACKと応答が別々に送信することができます。これは、遅いデータベース又はストレージシステムが応答を送信する前にアクセスする必要があり、例えば、のために、起こり得ます。"
    },
    {
      "indent": 3,
      "text": "At time OTTnp + OTTps + OTTsp + Tpr + Tsr the reply/ACK reaches the relay/proxy, which then takes TpR additional time to forward the reply to the NAS. At TdA after receiving the reply, the relay/proxy generates a delayed ACK. Typically TpR < TdA so that the delayed ACK is sent to the server after the relay/proxy forwards the reply to the NAS. However, depending on the circumstances and the relay/proxy TCP implementation, the delayed ACK may be sent first.",
      "ja": "時間OTTnp + OTTps + OTTsp + Tprの+ Tsrのに応答/ ACKは、次に、NASへの応答を転送するTPR追加の時間がかかる中継/プロキシに到達します。 TDAで返信を受け取った後、リレー/プロキシは、遅延ACKを生成します。典型的には、TPR <TDA中継/プロキシがNASに応答を転送した後に遅延ACKをサーバに送信されるようになっています。しかし、状況及び中継/プロキシTCPの実装に応じて、遅延ACKが最初に送信されても​​よいです。"
    },
    {
      "indent": 3,
      "text": "As with a delayed ACK sent in response to a request, which may be piggybacked if the reply can be received quickly enough, piggybacking of the ACK sent in response to a reply from the server is only possible if additional request traffic is available. However, due to the high inter-packet spacings in typical AAA scenarios, this is unlikely unless the AAA protocol supports a reply ACK.",
      "ja": "応答がサーバからの応答に応じて送信されるACKのピギーバック、十分に迅速に受信することができるならば、ピギーバックすることができるの要求に応答して送信遅延ACKと同様に、追加の要求トラフィックが利用可能な場合にのみ可能です。 AAAプロトコルが応答ACKをサポートしていない限り、しかし、典型的なAAAのシナリオで高いパケット間の間隔に起因し、これはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "At time OTTnp + OTTps + OTTsp + OTTpn + Tpr + Tsr + TpR the NAS receives the reply. TdA later, a delayed ACK is generated.",
      "ja": "当時OTTnp + OTTps + OTTsp + OTTpn + Tprの+ Tsrの+ TPR NASは、応答を受信します。 TDA後に、遅延ACKが生成されます。"
    },
    {
      "indent": 0,
      "text": "B.2 Re-directs",
      "ja": "B.2リダイレクト"
    },
    {
      "indent": 3,
      "text": "Re-directs operate by referring a NAS to the AAA server, enabling the NAS to talk to the AAA server directly. Since a direct transport connection is established, the end-to-end connection will self-clock.",
      "ja": "再指示直接AAAサーバと通信するためにNASを可能にする、AAAサーバにNASを参照することによって動作します。直接トランスポート接続が確立されているため、エンド・ツー・エンドの接続は、自己クロックなります。"
    },
    {
      "indent": 3,
      "text": "With re-directs, delayed ACKs are less frequent than with application-layer proxies since the Re-direct and Server will typically piggyback replies with ACKs.",
      "ja": "再指示で再直接およびサーバは、典型的には、ACKを用いて応答をピギーバックするので、遅延ACKはアプリケーション層プロキシよりも少ない頻度です。"
    },
    {
      "indent": 3,
      "text": "The sequence of events is as follows:",
      "ja": "次のようにイベントの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Time            NAS             Re-direct       Server\n------          ---             ---------       ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0               Request\n                ------->\nOTTnp + Tpr                     Redirect/ACK\n                                <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + Tpr +   Request\nOTTpn + Tnr     ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTpn +\nTpr + Tsr +                                     Reply/ACK\nOTTns                                           <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTpn +\nOTTns + OTTsn +\nTpr + Tsr +      Delayed ACK\nTdA              ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key\n---\nOTT   = One-way Trip Time\nOTTnp = One-way trip time (NAS to Re-direct)\nOTTpn = One-way trip time (Re-direct to NAS)\nOTTns = One-way trip time (NAS to Server)\nOTTsn = One-way trip time (Server to NAS)\nTdA   = Delayed ACK timer\nTpr   = Re-direct processing time\nTnr   = NAS re-direct processing time\nTsr   = Server request processing time",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.3 Store and Forward Proxies",
      "ja": "B.3ストア＆フォワードプロキシ"
    },
    {
      "indent": 3,
      "text": "With a store and forward proxy, the proxy may send a reply to the NAS prior to forwarding the request to the server. While store and forward proxies are most frequently deployed for accounting [RFC2975], they also can be used to implement authentication/authorization policy, as described in [RFC2607].",
      "ja": "ストアアンドフォワードプロキシでは、プロキシサーバに要求を転送するためにNAS前に応答を送信してもよいです。ストアアンドフォワードプロキシが最も頻繁に[RFC2975]を占めるために展開されますが、[RFC2607]で説明したように、彼らはまた、認証/認可ポリシーを実装するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "As noted in [RFC2975], store and forward proxies can have a negative effect on accounting reliability. By sending a reply to the NAS without receiving one from the accounting server, store and forward proxies fool the NAS into thinking that the accounting request had been accepted by the accounting server when this is not the case. As a result, the NAS can delete the accounting packet from non-volatile storage before it has been accepted by the accounting server. That leaves the proxy responsible for delivering accounting packets. If the proxy involves moving parts (e.g. a disk drive) while the NAS does not, overall system reliability can be reduced. As a result, store and forward proxies SHOULD NOT be used.",
      "ja": "[RFC2975]で述べたように、ストアアンドフォワードプロキシは、会計の信頼性に悪影響を与えることができます。会計上のサーバから1つを受信することなく、NASへの応答を送信することにより、ストアアンドフォワードプロキシそうでないときアカウンティング要求は、アカウンティングサーバによって受け入れられていたことを考えることにNASをだまします。それはアカウンティングサーバによって承認された前の結果、NASは、不揮発性ストレージから会計パケットを削除することができます。これはアカウンティングパケットを提供するための責任プロキシを残します。プロキシ部品（例えば、ディスクドライブ）を移動させることを含む場合NASはないが、システム全体の信頼性を低減させることができます。その結果、ストアアンドフォワードプロキシを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The sequence of events is as follows:",
      "ja": "次のようにイベントの順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Time            NAS             Proxy           Server\n------          ---             -----           ------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0               Request\n                ------->\nOTTnp + TpR                     Reply/ACK\n                                <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + Tpr                     Request\n                                ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +                                 Reply/ACK\nTpr + Tsr                                       <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nTpr + Tsr +                     Reply\nOTThp + TpR                     <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nTpr + Tsr +                     Delayed ACK\nOTThp + TdA                     ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nOTThp + OTTpn +\nTpr + Tsr +      Delayed ACK\nTpR + TdA        ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key\n---\nOTT   = One-way Trip Time\nOTTnp = One-way trip time (NAS to Proxy)\nOTTpn = One-way trip time (Proxy to NAS)\nOTTph = One-way trip time (Proxy to Home server)\nOTThp = One-way trip time (Home Server to Proxy)\nTdA   = Delayed ACK timer\nTpr   = Proxy request processing time\nTpR   = Proxy reply processing time\nTsr   = Server request processing time",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "B.4 Transport Layer Proxies",
      "ja": "B.4トランスポート層プロキシ"
    },
    {
      "indent": 3,
      "text": "In addition to acting as proxies at the application layer, transport layer proxies forward transport ACKs between the AAA client and server. This splices together the client-proxy and proxy-server connections into a single connection that behaves as though it operates end-to-end, exhibiting self-clocking. However, since transport proxies operate at the transport layer, they cannot be implemented purely as applications and they are rarely deployed.",
      "ja": "アプリケーション層でのプロキシとして機能に加えて、トランスポート層のプロキシAAAクライアントとサーバ間の順方向輸送のACK。これは、自己クロッキングを呈する、エンドツーエンドを運営しているかのように振る舞う単一の接続にクライアントプロキシおよびプロキシ・サーバー接続を一緒にスプライス。トランスポート・プロキシは、トランスポート層で動作するのでしかし、彼らは、アプリケーションとして、純粋に実装することはできませんし、彼らはほとんど導入されていません。"
    },
    {
      "indent": 3,
      "text": "With a transport proxy, the sequence of events is as follows:",
      "ja": "次のようにトランスポート・プロキシを使用すると、一連のイベントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Time            NAS             Proxy           Home Server\n------          ---             -----           -----------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0               Request\n                ------->\nOTTnp + Tpr                     Request\n                                ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +                                 Reply/ACK\nTpr + Tsr                                       <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nTpr + Tsr +                     Reply/ACK\nOTThp + TpR                     <-------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nOTThp + OTTpn +\nTpr + Tsr +      Delayed ACK\nTpR + TdA        ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OTTnp + OTTph +\nOTThp + OTTpn +\nTpr + Tsr +                     Delayed ACK\nTpR + TpD                       ------->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Key\n---\nOTT   = One-way Trip Time\nOTTnp = One-way trip time (NAS to Proxy)\nOTTpn = One-way trip time (Proxy to NAS)\nOTTph = One-way trip time (Proxy to Home server)\nOTThp = One-way trip time (Home Server to Proxy)\nTdA   = Delayed ACK timer\nTpr   = Proxy request processing time\nTpR   = Proxy reply processing time",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tsr = Server request processing time TpD = Proxy delayed ack processing time",
      "ja": "TSR =サーバー要求処理時間TPD =プロキシは、ACK処理時間を遅らせ"
    },
    {
      "indent": 0,
      "text": "Intellectual Property Statement",
      "ja": "知的財産に関する声明"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、または本仕様の実装者または利用者が、そのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Allison Mankin of AT&T, Barney Wolff of Databus, Steve Rich of Cisco, Randy Bush of AT&T, Bo Landarv of IP Unplugged, Jari Arkko of Ericsson, and Pat Calhoun of Blackstorm Networks for fruitful discussions relating to AAA transport.",
      "ja": "AAA輸送に関する実りある議論のためのAT＆Tのアリソンマンキン、データバスのバーニー・ウルフ、シスコのスティーブ・リッチ、AT＆Tのランディブッシュ、IPアンプラグドのボーLandarv、エリクソンのヤリArkko、およびBlackstormネットワークのパットカルフーンに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Bernard Aboba Microsoft Corporation One Microsoft Way Redmond, WA 98052",
      "ja": "バーナードAbobaマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 706 6605 Fax: +1 425 936 7329 EMail: bernarda@microsoft.com",
      "ja": "電話：+1 425 706 6605ファックス：+1 425 936 7329 Eメール：bernarda@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Jonathan Wood Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303",
      "ja": "ジョナサン・ウッドサン・マイクロシステムズ株式会社901サンアントニオの道パロアルト、CA 94303"
    },
    {
      "indent": 3,
      "text": "EMail: jonwood@speakeasy.net",
      "ja": "メールアドレス：jonwood@speakeasy.net"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}