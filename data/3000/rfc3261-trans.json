{
  "title": {
    "text": "RFC 3261 - SIP: Session Initiation Protocol",
    "ja": "RFC 3261 - SIP：セッション開始プロトコル"
  },
  "number": 3261,
  "created_at": "2019-10-25 17:10:44.070696+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       J. Rosenberg\nRequest for Comments: 3261                                   dynamicsoft\nObsoletes: 2543                                           H. Schulzrinne\nCategory: Standards Track                                    Columbia U.\n                                                            G. Camarillo\n                                                                Ericsson\n                                                             A. Johnston\n                                                                WorldCom\n                                                             J. Peterson\n                                                                 Neustar\n                                                               R. Sparks\n                                                             dynamicsoft\n                                                              M. Handley\n                                                                    ICIR\n                                                             E. Schooler\n                                                                    AT&T\n                                                               June 2002",
      "raw": true
    },
    {
      "indent": 20,
      "text": "SIP: Session Initiation Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants. These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences.",
      "ja": "この文書では、セッション開始プロトコル（SIP）、1人以上の参加者とのセッションを作成、変更、および終了するためのアプリケーション層制御（シグナリング）プロトコルを記載しています。これらのセッションは、インターネット電話、マルチメディア配信、およびマルチメディア会議が含まれます。"
    },
    {
      "indent": 3,
      "text": "SIP invitations used to create sessions carry session descriptions that allow participants to agree on a set of compatible media types. SIP makes use of elements called proxy servers to help route requests to the user's current location, authenticate and authorize users for services, implement provider call-routing policies, and provide features to users. SIP also provides a registration function that allows users to upload their current locations for use by proxy servers. SIP runs on top of several different transport protocols.",
      "ja": "セッションを作成するために使用されるSIP招待状は、参加者が互換性のあるメディアタイプのセットに同意することを可能にするセッション記述を運びます。 SIPは、ユーザの現在の場所への経路要求を助ける認証およびサービスのユーザーを認証し、プロバイダーのコールルーティングポリシーを実装し、ユーザーに機能を提供するために、プロキシサーバと呼ばれる要素を使用しています。 SIPは、ユーザーがプロキシサーバで使用するために彼らの現在の場所をアップロードすることを可能にする登録機能を提供します。 SIPは、いくつかの異なるトランスポートプロトコルの上で動作します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1          Introduction ........................................    8\n2          Overview of SIP Functionality .......................    9\n3          Terminology .........................................   10\n4          Overview of Operation ...............................   10\n5          Structure of the Protocol ...........................   18\n6          Definitions .........................................   20\n7          SIP Messages ........................................   26\n7.1        Requests ............................................   27\n7.2        Responses ...........................................   28\n7.3        Header Fields .......................................   29\n7.3.1      Header Field Format .................................   30\n7.3.2      Header Field Classification .........................   32\n7.3.3      Compact Form ........................................   32\n7.4        Bodies ..............................................   33\n7.4.1      Message Body Type ...................................   33\n7.4.2      Message Body Length .................................   33\n7.5        Framing SIP Messages ................................   34\n8          General User Agent Behavior .........................   34\n8.1        UAC Behavior ........................................   35\n8.1.1      Generating the Request ..............................   35\n8.1.1.1    Request-URI .........................................   35\n8.1.1.2    To ..................................................   36\n8.1.1.3    From ................................................   37\n8.1.1.4    Call-ID .............................................   37\n8.1.1.5    CSeq ................................................   38\n8.1.1.6    Max-Forwards ........................................   38\n8.1.1.7    Via .................................................   39\n8.1.1.8    Contact .............................................   40\n8.1.1.9    Supported and Require ...............................   40\n8.1.1.10   Additional Message Components .......................   41\n8.1.2      Sending the Request .................................   41\n8.1.3      Processing Responses ................................   42\n8.1.3.1    Transaction Layer Errors ............................   42\n8.1.3.2    Unrecognized Responses ..............................   42\n8.1.3.3    Vias ................................................   43\n8.1.3.4    Processing 3xx Responses ............................   43\n8.1.3.5    Processing 4xx Responses ............................   45\n8.2        UAS Behavior ........................................   46\n8.2.1      Method Inspection ...................................   46\n8.2.2      Header Inspection ...................................   46\n8.2.2.1    To and Request-URI ..................................   46\n8.2.2.2    Merged Requests .....................................   47\n8.2.2.3    Require .............................................   47\n8.2.3      Content Processing ..................................   48\n8.2.4      Applying Extensions .................................   49\n8.2.5      Processing the Request ..............................   49",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.2.6      Generating the Response .............................   49\n8.2.6.1    Sending a Provisional Response ......................   49\n8.2.6.2    Headers and Tags ....................................   50\n8.2.7      Stateless UAS Behavior ..............................   50\n8.3        Redirect Servers ....................................   51\n9          Canceling a Request .................................   53\n9.1        Client Behavior .....................................   53\n9.2        Server Behavior .....................................   55\n10         Registrations .......................................   56\n10.1       Overview ............................................   56\n10.2       Constructing the REGISTER Request ...................   57\n10.2.1     Adding Bindings .....................................   59\n10.2.1.1   Setting the Expiration Interval of Contact Addresses    60\n10.2.1.2   Preferences among Contact Addresses .................   61\n10.2.2     Removing Bindings ...................................   61\n10.2.3     Fetching Bindings ...................................   61\n10.2.4     Refreshing Bindings .................................   61\n10.2.5     Setting the Internal Clock ..........................   62\n10.2.6     Discovering a Registrar .............................   62\n10.2.7     Transmitting a Request ..............................   62\n10.2.8     Error Responses .....................................   63\n10.3       Processing REGISTER Requests ........................   63\n11         Querying for Capabilities ...........................   66\n11.1       Construction of OPTIONS Request .....................   67\n11.2       Processing of OPTIONS Request .......................   68\n12         Dialogs .............................................   69\n12.1       Creation of a Dialog ................................   70\n12.1.1     UAS behavior ........................................   70\n12.1.2     UAC Behavior ........................................   71\n12.2       Requests within a Dialog ............................   72\n12.2.1     UAC Behavior ........................................   73\n12.2.1.1   Generating the Request ..............................   73\n12.2.1.2   Processing the Responses ............................   75\n12.2.2     UAS Behavior ........................................   76\n12.3       Termination of a Dialog .............................   77\n13         Initiating a Session ................................   77\n13.1       Overview ............................................   77\n13.2       UAC Processing ......................................   78\n13.2.1     Creating the Initial INVITE .........................   78\n13.2.2     Processing INVITE Responses .........................   81\n13.2.2.1   1xx Responses .......................................   81\n13.2.2.2   3xx Responses .......................................   81\n13.2.2.3   4xx, 5xx and 6xx Responses ..........................   81\n13.2.2.4   2xx Responses .......................................   82\n13.3       UAS Processing ......................................   83\n13.3.1     Processing of the INVITE ............................   83\n13.3.1.1   Progress ............................................   84\n13.3.1.2   The INVITE is Redirected ............................   84",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13.3.1.3   The INVITE is Rejected ..............................   85\n13.3.1.4   The INVITE is Accepted ..............................   85\n14         Modifying an Existing Session .......................   86\n14.1       UAC Behavior ........................................   86\n14.2       UAS Behavior ........................................   88\n15         Terminating a Session ...............................   89\n15.1       Terminating a Session with a BYE Request ............   90\n15.1.1     UAC Behavior ........................................   90\n15.1.2     UAS Behavior ........................................   91\n16         Proxy Behavior ......................................   91\n16.1       Overview ............................................   91\n16.2       Stateful Proxy ......................................   92\n16.3       Request Validation ..................................   94\n16.4       Route Information Preprocessing .....................   96\n16.5       Determining Request Targets .........................   97\n16.6       Request Forwarding ..................................   99\n16.7       Response Processing .................................  107\n16.8       Processing Timer C ..................................  114\n16.9       Handling Transport Errors ...........................  115\n16.10      CANCEL Processing ...................................  115\n16.11      Stateless Proxy .....................................  116\n16.12      Summary of Proxy Route Processing ...................  118\n16.12.1    Examples ............................................  118\n16.12.1.1  Basic SIP Trapezoid .................................  118\n16.12.1.2  Traversing a Strict-Routing Proxy ...................  120\n16.12.1.3  Rewriting Record-Route Header Field Values ..........  121\n17         Transactions ........................................  122\n17.1       Client Transaction ..................................  124\n17.1.1     INVITE Client Transaction ...........................  125\n17.1.1.1   Overview of INVITE Transaction ......................  125\n17.1.1.2   Formal Description ..................................  125\n17.1.1.3   Construction of the ACK Request .....................  129\n17.1.2     Non-INVITE Client Transaction .......................  130\n17.1.2.1   Overview of the non-INVITE Transaction ..............  130\n17.1.2.2   Formal Description ..................................  131\n17.1.3     Matching Responses to Client Transactions ...........  132\n17.1.4     Handling Transport Errors ...........................  133\n17.2       Server Transaction ..................................  134\n17.2.1     INVITE Server Transaction ...........................  134\n17.2.2     Non-INVITE Server Transaction .......................  137\n17.2.3     Matching Requests to Server Transactions ............  138\n17.2.4     Handling Transport Errors ...........................  141\n18         Transport ...........................................  141\n18.1       Clients .............................................  142\n18.1.1     Sending Requests ....................................  142\n18.1.2     Receiving Responses .................................  144\n18.2       Servers .............................................  145\n18.2.1     Receiving Requests ..................................  145",
      "raw": true
    },
    {
      "indent": 3,
      "text": "18.2.2     Sending Responses ...................................  146\n18.3       Framing .............................................  147\n18.4       Error Handling ......................................  147\n19         Common Message Components ...........................  147\n19.1       SIP and SIPS Uniform Resource Indicators ............  148\n19.1.1     SIP and SIPS URI Components .........................  148\n19.1.2     Character Escaping Requirements .....................  152\n19.1.3     Example SIP and SIPS URIs ...........................  153\n19.1.4     URI Comparison ......................................  153\n19.1.5     Forming Requests from a URI .........................  156\n19.1.6     Relating SIP URIs and tel URLs ......................  157\n19.2       Option Tags .........................................  158\n19.3       Tags ................................................  159\n20         Header Fields .......................................  159\n20.1       Accept ..............................................  161\n20.2       Accept-Encoding .....................................  163\n20.3       Accept-Language .....................................  164\n20.4       Alert-Info ..........................................  164\n20.5       Allow ...............................................  165\n20.6       Authentication-Info .................................  165\n20.7       Authorization .......................................  165\n20.8       Call-ID .............................................  166\n20.9       Call-Info ...........................................  166\n20.10      Contact .............................................  167\n20.11      Content-Disposition .................................  168\n20.12      Content-Encoding ....................................  169\n20.13      Content-Language ....................................  169\n20.14      Content-Length ......................................  169\n20.15      Content-Type ........................................  170\n20.16      CSeq ................................................  170\n20.17      Date ................................................  170\n20.18      Error-Info ..........................................  171\n20.19      Expires .............................................  171\n20.20      From ................................................  172\n20.21      In-Reply-To .........................................  172\n20.22      Max-Forwards ........................................  173\n20.23      Min-Expires .........................................  173\n20.24      MIME-Version ........................................  173\n20.25      Organization ........................................  174\n20.26      Priority ............................................  174\n20.27      Proxy-Authenticate ..................................  174\n20.28      Proxy-Authorization .................................  175\n20.29      Proxy-Require .......................................  175\n20.30      Record-Route ........................................  175\n20.31      Reply-To ............................................  176\n20.32      Require .............................................  176\n20.33      Retry-After .........................................  176\n20.34      Route ...............................................  177",
      "raw": true
    },
    {
      "indent": 3,
      "text": "20.35      Server ..............................................  177\n20.36      Subject .............................................  177\n20.37      Supported ...........................................  178\n20.38      Timestamp ...........................................  178\n20.39      To ..................................................  178\n20.40      Unsupported .........................................  179\n20.41      User-Agent ..........................................  179\n20.42      Via .................................................  179\n20.43      Warning .............................................  180\n20.44      WWW-Authenticate ....................................  182\n21         Response Codes ......................................  182\n21.1       Provisional 1xx .....................................  182\n21.1.1     100 Trying ..........................................  183\n21.1.2     180 Ringing .........................................  183\n21.1.3     181 Call Is Being Forwarded .........................  183\n21.1.4     182 Queued ..........................................  183\n21.1.5     183 Session Progress ................................  183\n21.2       Successful 2xx ......................................  183\n21.2.1     200 OK ..............................................  183\n21.3       Redirection 3xx .....................................  184\n21.3.1     300 Multiple Choices ................................  184\n21.3.2     301 Moved Permanently ...............................  184\n21.3.3     302 Moved Temporarily ...............................  184\n21.3.4     305 Use Proxy .......................................  185\n21.3.5     380 Alternative Service .............................  185\n21.4       Request Failure 4xx .................................  185\n21.4.1     400 Bad Request .....................................  185\n21.4.2     401 Unauthorized ....................................  185\n21.4.3     402 Payment Required ................................  186\n21.4.4     403 Forbidden .......................................  186\n21.4.5     404 Not Found .......................................  186\n21.4.6     405 Method Not Allowed ..............................  186\n21.4.7     406 Not Acceptable ..................................  186\n21.4.8     407 Proxy Authentication Required ...................  186\n21.4.9     408 Request Timeout .................................  186\n21.4.10    410 Gone ............................................  187\n21.4.11    413 Request Entity Too Large ........................  187\n21.4.12    414 Request-URI Too Long ............................  187\n21.4.13    415 Unsupported Media Type ..........................  187\n21.4.14    416 Unsupported URI Scheme ..........................  187\n21.4.15    420 Bad Extension ...................................  187\n21.4.16    421 Extension Required ..............................  188\n21.4.17    423 Interval Too Brief ..............................  188\n21.4.18    480 Temporarily Unavailable .........................  188\n21.4.19    481 Call/Transaction Does Not Exist .................  188\n21.4.20    482 Loop Detected ...................................  188\n21.4.21    483 Too Many Hops ...................................  189\n21.4.22    484 Address Incomplete ..............................  189",
      "raw": true
    },
    {
      "indent": 3,
      "text": "21.4.23    485 Ambiguous .......................................  189\n21.4.24    486 Busy Here .......................................  189\n21.4.25    487 Request Terminated ..............................  190\n21.4.26    488 Not Acceptable Here .............................  190\n21.4.27    491 Request Pending .................................  190\n21.4.28    493 Undecipherable ..................................  190\n21.5       Server Failure 5xx ..................................  190\n21.5.1     500 Server Internal Error ...........................  190\n21.5.2     501 Not Implemented .................................  191\n21.5.3     502 Bad Gateway .....................................  191\n21.5.4     503 Service Unavailable .............................  191\n21.5.5     504 Server Time-out .................................  191\n21.5.6     505 Version Not Supported ...........................  192\n21.5.7     513 Message Too Large ...............................  192\n21.6       Global Failures 6xx .................................  192\n21.6.1     600 Busy Everywhere .................................  192\n21.6.2     603 Decline .........................................  192\n21.6.3     604 Does Not Exist Anywhere .........................  192\n21.6.4     606 Not Acceptable ..................................  192\n22         Usage of HTTP Authentication ........................  193\n22.1       Framework ...........................................  193\n22.2       User-to-User Authentication .........................  195\n22.3       Proxy-to-User Authentication ........................  197\n22.4       The Digest Authentication Scheme ....................  199\n23         S/MIME ..............................................  201\n23.1       S/MIME Certificates .................................  201\n23.2       S/MIME Key Exchange .................................  202\n23.3       Securing MIME bodies ................................  205\n23.4       SIP Header Privacy and Integrity using S/MIME:\n           Tunneling SIP .......................................  207\n23.4.1     Integrity and Confidentiality Properties of SIP\n           Headers .............................................  207\n23.4.1.1   Integrity ...........................................  207\n23.4.1.2   Confidentiality .....................................  208\n23.4.2     Tunneling Integrity and Authentication ..............  209\n23.4.3     Tunneling Encryption ................................  211\n24         Examples ............................................  213\n24.1       Registration ........................................  213\n24.2       Session Setup .......................................  214\n25         Augmented BNF for the SIP Protocol ..................  219\n25.1       Basic Rules .........................................  219\n26         Security Considerations: Threat Model and Security\n           Usage Recommendations ...............................  232\n26.1       Attacks and Threat Models ...........................  233\n26.1.1     Registration Hijacking ..............................  233\n26.1.2     Impersonating a Server ..............................  234\n26.1.3     Tampering with Message Bodies .......................  235\n26.1.4     Tearing Down Sessions ...............................  235",
      "raw": true
    },
    {
      "indent": 3,
      "text": "26.1.5     Denial of Service and Amplification .................  236\n26.2       Security Mechanisms .................................  237\n26.2.1     Transport and Network Layer Security ................  238\n26.2.2     SIPS URI Scheme .....................................  239\n26.2.3     HTTP Authentication .................................  240\n26.2.4     S/MIME ..............................................  240\n26.3       Implementing Security Mechanisms ....................  241\n26.3.1     Requirements for Implementers of SIP ................  241\n26.3.2     Security Solutions ..................................  242\n26.3.2.1   Registration ........................................  242\n26.3.2.2   Interdomain Requests ................................  243\n26.3.2.3   Peer-to-Peer Requests ...............................  245\n26.3.2.4   DoS Protection ......................................  246\n26.4       Limitations .........................................  247\n26.4.1     HTTP Digest .........................................  247\n26.4.2     S/MIME ..............................................  248\n26.4.3     TLS .................................................  249\n26.4.4     SIPS URIs ...........................................  249\n26.5       Privacy .............................................  251\n27         IANA Considerations .................................  252\n27.1       Option Tags .........................................  252\n27.2       Warn-Codes ..........................................  252\n27.3       Header Field Names ..................................  253\n27.4       Method and Response Codes ...........................  253\n27.5       The \"message/sip\" MIME type.  .......................  254\n27.6       New Content-Disposition Parameter Registrations .....  255\n28         Changes From RFC 2543 ...............................  255\n28.1       Major Functional Changes ............................  255\n28.2       Minor Functional Changes ............................  260\n29         Normative References ................................  261\n30         Informative References ..............................  262\nA          Table of Timer Values ...............................  265\nAcknowledgments ................................................  266\nAuthors' Addresses .............................................  267\nFull Copyright Statement .......................................  269",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1 Introduction",
      "ja": "1はじめに"
    },
    {
      "indent": 3,
      "text": "There are many applications of the Internet that require the creation and management of a session, where a session is considered an exchange of data between an association of participants. The implementation of these applications is complicated by the practices of participants: users may move between endpoints, they may be addressable by multiple names, and they may communicate in several different media - sometimes simultaneously. Numerous protocols have been authored that carry various forms of real-time multimedia session data such as voice, video, or text messages. The Session Initiation Protocol (SIP) works in concert with these protocols by enabling Internet endpoints (called user agents) to discover one another and to agree on a characterization of a session they would like to share. For locating prospective session participants, and for other functions, SIP enables the creation of an infrastructure of network hosts (called proxy servers) to which user agents can send registrations, invitations to sessions, and other requests. SIP is an agile, general-purpose tool for creating, modifying, and terminating sessions that works independently of underlying transport protocols and without dependency on the type of session that is being established.",
      "ja": "セッションは、参加者の団体間でのデータ交換とみなされるセッションの作成と管理を必要とするインターネットの多くのアプリケーションがあります。これらのアプリケーションの実装では、参加者の慣行によって複雑になる：ユーザーは複数の名前によってアドレスであってもよいし、エンドポイント間で移動することができ、そして、彼らはいくつかの異なるメディアで通信することができる - 時には同時に。多数のプロトコルは、音声、ビデオ、またはテキストメッセージなどのリアルタイムマルチメディアセッションデータの様々な形態を運ぶこと執筆されています。セッション開始プロトコル（SIP）は、互いを発見するために、彼らが共有したいセッションの特性評価に同意するには、インターネットのエンドポイント（と呼ばれるユーザーエージェント）を有効にすることで、これらのプロトコルと協調して動作します。将来のセッション参加者を見つけるための、および他の機能のために、SIPは、ユーザエージェントが登録、セッションへの招待、および他の要求を送信できるネットワークホスト（プロキシサーバと呼ばれる）のインフラストラクチャを作成することができます。 SIPは、確立されたセッションのタイプに独立して、基礎となるトランスポートプロトコルのと依存することなく動作するセッションを作成、変更、および終了するためのアジャイル、汎用ツールです。"
    },
    {
      "indent": 0,
      "text": "2 Overview of SIP Functionality",
      "ja": "SIP機能の概要2"
    },
    {
      "indent": 3,
      "text": "SIP is an application-layer control protocol that can establish, modify, and terminate multimedia sessions (conferences) such as Internet telephony calls. SIP can also invite participants to already existing sessions, such as multicast conferences. Media can be added to (and removed from) an existing session. SIP transparently supports name mapping and redirection services, which supports personal mobility [27] - users can maintain a single externally visible identifier regardless of their network location.",
      "ja": "SIPは、確立、変更、およびこのようなインターネット電話通話などのマルチメディアセッション（会議）を終了することができるアプリケーション層制御プロトコルです。 SIPはまた、参加者に、このようなマルチキャスト会議などの既存のセッションを、招待することができます。メディアは、既存のセッションをに追加（およびから削除）することができます。 SIPは、透過的にパーソナルモビリティをサポートする、[27]名前マッピングとリダイレクションサービスをサポート - ユーザーは関係なく、自分のネットワークの場所の単一外部から見える識別子を維持することができます。"
    },
    {
      "indent": 3,
      "text": "SIP supports five facets of establishing and terminating multimedia communications:",
      "ja": "SIPは、マルチメディア通信を確立し、終了の5面をサポートしています。"
    },
    {
      "indent": 6,
      "text": "User location: determination of the end system to be used for communication;",
      "ja": "ユーザ位置：通信に使用するエンドシステムの決定。"
    },
    {
      "indent": 6,
      "text": "User availability: determination of the willingness of the called party to engage in communications;",
      "ja": "ユーザーの可用性：通信に従事する着信側の意欲を決意。"
    },
    {
      "indent": 6,
      "text": "User capabilities: determination of the media and media parameters to be used;",
      "ja": "ユーザ機能：メディアとメディアパラメータの決意を使用します。"
    },
    {
      "indent": 6,
      "text": "Session setup: \"ringing\", establishment of session parameters at both called and calling party;",
      "ja": "セッションのセットアップ：「リンギング」、両方と呼ばれ、発信側でセッションパラメータを確立します。"
    },
    {
      "indent": 6,
      "text": "Session management: including transfer and termination of sessions, modifying session parameters, and invoking services.",
      "ja": "セッション管理：転送とセッションの終了、セッションパラメータを変更し、呼び出しサービスを含みます。"
    },
    {
      "indent": 3,
      "text": "SIP is not a vertically integrated communications system. SIP is rather a component that can be used with other IETF protocols to build a complete multimedia architecture. Typically, these architectures will include protocols such as the Real-time Transport Protocol (RTP) (RFC 1889 [28]) for transporting real-time data and providing QoS feedback, the Real-Time streaming protocol (RTSP) (RFC 2326 [29]) for controlling delivery of streaming media, the Media",
      "ja": "SIPは、垂直統合通信システムではありません。 SIPはなく、完全なマルチメディアアーキテクチャを構築する他のIETFプロトコルと共に使用することができる成分です。一般的に、これらのアーキテクチャは、リアルタイムのデータを転送し、QoSフィードバックを提供するためのリアルタイム転送プロトコル（RTP）（RFC 1889 [28]）、リアルタイムストリーミングプロトコル（RTSP）（RFC 2326 [29などのプロトコルが含まれます]）、メディアストリーミングメディアの配信を制御するための"
    },
    {
      "indent": 3,
      "text": "Gateway Control Protocol (MEGACO) (RFC 3015 [30]) for controlling gateways to the Public Switched Telephone Network (PSTN), and the Session Description Protocol (SDP) (RFC 2327 [1]) for describing multimedia sessions. Therefore, SIP should be used in conjunction with other protocols in order to provide complete services to the users. However, the basic functionality and operation of SIP does not depend on any of these protocols.",
      "ja": "ゲートウェイ制御プロトコル（MEGACO）パブリックへのゲートウェイを制御するための（RFC 3015 [30]）電話網（PSTN）、およびセッション記述プロトコル（SDP）（RFC 2327 [1]）、マルチメディアセッションを説明します。そのため、SIPは、ユーザーに完全なサービスを提供するために、他のプロトコルと組み合わせて使用​​する必要があります。しかし、SIPの基本的な機能と操作は、これらのプロトコルのいずれかに依存しません。"
    },
    {
      "indent": 3,
      "text": "SIP does not provide services. Rather, SIP provides primitives that can be used to implement different services. For example, SIP can locate a user and deliver an opaque object to his current location. If this primitive is used to deliver a session description written in SDP, for instance, the endpoints can agree on the parameters of a session. If the same primitive is used to deliver a photo of the caller as well as the session description, a \"caller ID\" service can be easily implemented. As this example shows, a single primitive is typically used to provide several different services.",
      "ja": "SIPは、サービスを提供していません。むしろ、SIPは、さまざまなサービスを実現するために用いることができるプリミティブを提供します。例えば、SIPは、ユーザの位置を特定することができ、彼の現在の位置に不透明なオブジェクトを配信します。このプリミティブがSDPで書かれたセッション記述を配信するために使用されている場合は、例えば、エンドポイントは、セッションのパラメータに同意することができます。同じプリミティブは、発信者の写真だけでなく、セッション記述を配信するために使用されている場合は、「発信者ID」サービスを容易に実現することができます。この例に示すように、単一のプリミティブは、典型的には、いくつかの異なるサービスを提供するために使用されます。"
    },
    {
      "indent": 3,
      "text": "SIP does not offer conference control services such as floor control or voting and does not prescribe how a conference is to be managed. SIP can be used to initiate a session that uses some other conference control protocol. Since SIP messages and the sessions they establish can pass through entirely different networks, SIP cannot, and does not, provide any kind of network resource reservation capabilities.",
      "ja": "SIPは、フロアコントロールや投票などの会議制御サービスを提供していないとの会議を管理する方法を規定していません。 SIPは、いくつかの他の会議制御プロトコルを使用してセッションを開始するために使用することができます。彼らは確立SIPメッセージとセッションは完全に異なるネットワークを通過することができるので、SIPはできない、と、ネットワークリソース予約機能のいずれかの種類を提供していません。"
    },
    {
      "indent": 3,
      "text": "The nature of the services provided make security particularly important. To that end, SIP provides a suite of security services, which include denial-of-service prevention, authentication (both user to user and proxy to user), integrity protection, and encryption and privacy services.",
      "ja": "提供するサービスの性質は、セキュリティが特に重要になります。そのために、SIPは、サービス拒否防止、認証（ユーザーへのユーザーおよびプロキシの両方のユーザー）、完全性保護、および暗号化とプライバシーのサービスを含むセキュリティサービスのスイートを提供します。"
    },
    {
      "indent": 3,
      "text": "SIP works with both IPv4 and IPv6.",
      "ja": "SIPは、IPv4とIPv6の両方で動作します。"
    },
    {
      "indent": 0,
      "text": "3 Terminology",
      "ja": "3用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119 [2] and indicate requirement levels for compliant SIP implementations.",
      "ja": "この文書では、キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"推奨NOT\"、 \"MAY\" 、および「OPTIONAL」[2] BCP 14、RFC 2119に記載されるように解釈されるべきであり、準拠SIP実装の要求レベルを示します。"
    },
    {
      "indent": 0,
      "text": "4 Overview of Operation",
      "ja": "操作の4概要"
    },
    {
      "indent": 3,
      "text": "This section introduces the basic operations of SIP using simple examples. This section is tutorial in nature and does not contain any normative statements.",
      "ja": "このセクションでは、簡単な例を使用してSIPの基本的な操作を紹介します。このセクションでは、自然の中でのチュートリアルであり、いかなる規範的な文が含まれていません。"
    },
    {
      "indent": 3,
      "text": "The first example shows the basic functions of SIP: location of an end point, signal of a desire to communicate, negotiation of session parameters to establish the session, and teardown of the session once established.",
      "ja": "最初の例では、SIPの基本的な機能を示します。エンドポイントの位置は、欲望の信号は、セッション・パラメータのネゴシエーションは、セッションを確立するために、通信するために、セッションのティアダウンは、一度確立します。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a typical example of a SIP message exchange between two users, Alice and Bob. (Each message is labeled with the letter \"F\" and a number for reference by the text.) In this example, Alice uses a SIP application on her PC (referred to as a softphone) to call Bob on his SIP phone over the Internet. Also shown are two SIP proxy servers that act on behalf of Alice and Bob to facilitate the session establishment. This typical arrangement is often referred to as the \"SIP trapezoid\" as shown by the geometric shape of the dotted lines in Figure 1.",
      "ja": "図1は、2人のユーザ、アリスとボブの間のSIPメッセージ交換の典型的な例を示しています。 （各メッセージは、文字「F」とテキストによる参照のために番号が付いている。）この例では、アリスは、インターネット上で彼のSIPフォンにボブを呼び出すために（ソフトフォンと呼ばれる）彼女のPC上でSIPアプリケーションを使用しています。また、セッションの確立を容易にするために、アリスとボブのために行動2台のSIPプロキシサーバが示されます。図1の点線の幾何学的形状によって示されるように、この典型的な構成は、しばしば「SIP台形」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Alice \"calls\" Bob using his SIP identity, a type of Uniform Resource Identifier (URI) called a SIP URI. SIP URIs are defined in Section 19.1. It has a similar form to an email address, typically containing a username and a host name. In this case, it is sip:bob@biloxi.com, where biloxi.com is the domain of Bob's SIP service provider. Alice has a SIP URI of sip:alice@atlanta.com. Alice might have typed in Bob's URI or perhaps clicked on a hyperlink or an entry in an address book. SIP also provides a secure URI, called a SIPS URI. An example would be sips:bob@biloxi.com. A call made to a SIPS URI guarantees that secure, encrypted transport (namely TLS) is used to carry all SIP messages from the caller to the domain of the callee. From there, the request is sent securely to the callee, but with security mechanisms that depend on the policy of the domain of the callee.",
      "ja": "アリスは彼のSIP-IDを使用して、ボブ「呼び出す」、統一資源識別子（URI）のタイプは、SIP URIと呼ばれます。 SIP URIは、セクション19.1で定義されています。それは、典型的には、ユーザ名とホスト名を含む、電子メールアドレスに似た形状を有しています。 bob@biloxi.com、biloxi.comはBobのSIPサービスプロバイダのドメインである。この場合、それは一口です。 alice@atlanta.com：アリスは、SIPのSIP URIを持っています。アリスはボブのURIに入力されたか、おそらく、ハイパーリンクやアドレス帳のエントリをクリックした可能性があります。 SIPはまた、SIPS URIと呼ばれるセキュアなURIを提供します。一例では、SIPのようになります。bob@biloxi.com。セキュアSIPS URIの保証に行われたコールは、暗号化されたトランスポート（すなわちTLS）は、呼び出し先のドメインへの発信者からのすべてのSIPメッセージを運ぶために使用されます。そこから、要求はなく、呼び出し先のドメインのポリシーに依存したセキュリティ・メカニズムと、呼び出し先に安全に送信されます。"
    },
    {
      "indent": 3,
      "text": "SIP is based on an HTTP-like request/response transaction model. Each transaction consists of a request that invokes a particular method, or function, on the server and at least one response. In this example, the transaction begins with Alice's softphone sending an INVITE request addressed to Bob's SIP URI. INVITE is an example of a SIP method that specifies the action that the requestor (Alice) wants the server (Bob) to take. The INVITE request contains a number of header fields. Header fields are named attributes that provide additional information about a message. The ones present in an INVITE include a unique identifier for the call, the destination address, Alice's address, and information about the type of session that Alice wishes to establish with Bob. The INVITE (message F1 in Figure 1) might look like this:",
      "ja": "SIPは、HTTPのようなリクエスト/レスポンストランザクションモデルに基づいています。各トランザクションは、サーバと少なくとも1つの応答には、特定のメソッド、または関数を呼び出す要求から成ります。この例では、トランザクションは、AliceのソフトフォンがBobのSIP URI宛INVITEリクエストを送信することから始まります。 INVITE要求者（アリス）は、サーバ（ボブ）が取りたいアクションを指定するSIP方式の一例です。 INVITE要求は、ヘッダフィールドの数を含んでいます。ヘッダーフィールドは、メッセージに関する追加情報を提供する属性を命名しています。存在するものは、コールの一意の識別子、宛先アドレス、アリスのアドレス、およびアリスがボブに確立したいセッションのタイプに関する情報が含まれるINVITE。 INVITE（メッセージ図1のF1）は次のようになります。"
    },
    {
      "indent": 6,
      "text": "               atlanta.com  . . . biloxi.com\n           .      proxy              proxy     .\n         .                                       .\n Alice's  . . . . . . . . . . . . . . . . . . . .  Bob's\nsoftphone                                        SIP Phone\n   |                |                |                |\n   |    INVITE F1   |                |                |\n   |--------------->|    INVITE F2   |                |\n   |  100 Trying F3 |--------------->|    INVITE F4   |\n   |<---------------|  100 Trying F5 |--------------->|\n   |                |<-------------- | 180 Ringing F6 |\n   |                | 180 Ringing F7 |<---------------|\n   | 180 Ringing F8 |<---------------|     200 OK F9  |\n   |<---------------|    200 OK F10  |<---------------|\n   |    200 OK F11  |<---------------|                |\n   |<---------------|                |                |\n   |                       ACK F12                    |\n   |------------------------------------------------->|\n   |                   Media Session                  |\n   |<================================================>|\n   |                       BYE F13                    |\n   |<-------------------------------------------------|\n   |                     200 OK F14                   |\n   |------------------------------------------------->|\n   |                                                  |",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 1: SIP session setup example with SIP trapezoid",
      "ja": "図1：SIP台形とのSIPセッションの設定例"
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds Max-Forwards: 70 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710@pc33.atlanta.com CSeq: 314159 INVITE Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/sdp Content-Length: 142",
      "ja": "bob@biloxi.com SIP / 2.0経由：SIPのINVITE SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bK776asdhdsマックス・フォワード：70：から：アリス<SIP：ボブ<bob@biloxi.com一口>： alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710@pc33.atlanta.comのCSeq：314159連絡先INVITE：<SIP：alice@pc33.atlanta.com>のContent-Type：アプリケーション/ SDPのContent-Length：142"
    },
    {
      "indent": 6,
      "text": "(Alice's SDP not shown)",
      "ja": "（AliceのSDPは示されていません）"
    },
    {
      "indent": 3,
      "text": "The first line of the text-encoded message contains the method name (INVITE). The lines that follow are a list of header fields. This example contains a minimum required set. The header fields are briefly described below:",
      "ja": "テキストエンコードされたメッセージの最初の行は、メソッド名（INVITE）を含みます。続く行は、ヘッダフィールドのリストです。この例では、必要最小限のセットが含まれています。ヘッダフィールドは、以下に簡単に説明されています。"
    },
    {
      "indent": 3,
      "text": "Via contains the address (pc33.atlanta.com) at which Alice is expecting to receive responses to this request. It also contains a branch parameter that identifies this transaction.",
      "ja": "VIAはアリスは、この要求に対する応答を受け取ることを期待されているアドレス（pc33.atlanta.com）が含まれています。また、このトランザクションを識別し、分岐パラメータが含まれています。"
    },
    {
      "indent": 3,
      "text": "To contains a display name (Bob) and a SIP or SIPS URI (sip:bob@biloxi.com) towards which the request was originally directed. Display names are described in RFC 2822 [3].",
      "ja": "要求が最初に向けられた向かって：表示名（ボブ）とSIPまたはURIをSIPS（bob@biloxi.com SIP）を含有します。表示名は、RFC 2822に記載されている[3]。"
    },
    {
      "indent": 3,
      "text": "From also contains a display name (Alice) and a SIP or SIPS URI (sip:alice@atlanta.com) that indicate the originator of the request. This header field also has a tag parameter containing a random string (1928301774) that was added to the URI by the softphone. It is used for identification purposes.",
      "ja": "また、表示名（アリス）とSIPが含まれているか、URI（SIP：alice@atlanta.com）をSIPSからの要求の発信元を示しています。このヘッダーフィールドは、また、ソフトフォンによってURIに追加されたランダムな文字列（1928301774）を含むtagパラメータを有しています。それは識別目的のために使用されています。"
    },
    {
      "indent": 3,
      "text": "Call-ID contains a globally unique identifier for this call, generated by the combination of a random string and the softphone's host name or IP address. The combination of the To tag, From tag, and Call-ID completely defines a peer-to-peer SIP relationship between Alice and Bob and is referred to as a dialog.",
      "ja": "コールIDは、ランダムな文字列とソフトフォンのホスト名またはIPアドレスの組み合わせによって生成された、このコールのためのグローバル一意識別子が含まれています。タグから、タグ、およびCall-IDとの組み合わせは、完全に、アリスとボブの間のピアツーピアのSIP関係を定義し、ダイアログと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "CSeq or Command Sequence contains an integer and a method name. The CSeq number is incremented for each new request within a dialog and is a traditional sequence number.",
      "ja": "CSeqまたはコマンドシーケンスは、整数とメソッド名が含まれています。 CSeq番号は、ダイアログ内の各新しい要求のためにインクリメントされ、伝統的なシーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "Contact contains a SIP or SIPS URI that represents a direct route to contact Alice, usually composed of a username at a fully qualified domain name (FQDN). While an FQDN is preferred, many end systems do not have registered domain names, so IP addresses are permitted. While the Via header field tells other elements where to send the response, the Contact header field tells other elements where to send future requests.",
      "ja": "連絡先は、SIPが含まれているか、完全修飾ドメイン名（FQDN）で、通常はユーザー名で構成アリスを、連絡する直接的なルートを表しURIをSIPS。 FQDNが好ましいが、多くのエンドシステムは、ドメイン名を登録していないので、IPアドレスが許可されています。 Viaヘッダーフィールドはどこ応答を送信するために、他の要素を伝えながら、Contactヘッダーフィールドはどこ将来の要求を送信するために他の要素を伝えます。"
    },
    {
      "indent": 3,
      "text": "Max-Forwards serves to limit the number of hops a request can make on the way to its destination. It consists of an integer that is decremented by one at each hop.",
      "ja": "最大転送し、要求が宛先に向かう途中で行うことができるホップの数を制限するのに役立ちます。これは、各ホップで1ずつデクリメントされる整数から成ります。"
    },
    {
      "indent": 3,
      "text": "Content-Type contains a description of the message body (not shown).",
      "ja": "コンテンツタイプは、メッセージ本体（図示せず）の記述を含みます。"
    },
    {
      "indent": 3,
      "text": "Content-Length contains an octet (byte) count of the message body.",
      "ja": "コンテンツの長さは、メッセージボディのオクテット（バイト）数が含まれています。"
    },
    {
      "indent": 3,
      "text": "The complete set of SIP header fields is defined in Section 20.",
      "ja": "SIPヘッダーフィールドの完全なセットはセクション20で定義されています。"
    },
    {
      "indent": 3,
      "text": "The details of the session, such as the type of media, codec, or sampling rate, are not described using SIP. Rather, the body of a SIP message contains a description of the session, encoded in some other protocol format. One such format is the Session Description Protocol (SDP) (RFC 2327 [1]). This SDP message (not shown in the",
      "ja": "そのようなメディア、コーデック、またはサンプリングレートのタイプとして、セッションの詳細は、SIPを使用して記載されていません。むしろ、SIPメッセージのボディは、いくつかの他のプロトコル形式でエンコードされ、セッションの記述を含みます。そのようなフォーマットは、セッション記述プロトコル（SDP）（RFC 2327 [1]）です。 （には示されていないこのSDPメッセージ"
    },
    {
      "indent": 3,
      "text": "example) is carried by the SIP message in a way that is analogous to a document attachment being carried by an email message, or a web page being carried in an HTTP message.",
      "ja": "例）電子メールメッセージによって運ばれている添付文書、またはHTTPメッセージで搬送されるウェブページに類似しているように、SIPメッセージによって運ばれます。"
    },
    {
      "indent": 3,
      "text": "Since the softphone does not know the location of Bob or the SIP server in the biloxi.com domain, the softphone sends the INVITE to the SIP server that serves Alice's domain, atlanta.com. The address of the atlanta.com SIP server could have been configured in Alice's softphone, or it could have been discovered by DHCP, for example.",
      "ja": "ソフトフォンは、ボブの場所やbiloxi.comドメイン内のSIPサーバを知らないので、ソフトフォンは、アリスのドメイン、atlanta.comを提供していますSIPサーバにINVITEを送信します。 atlanta.comのSIPサーバのアドレスは、Aliceのソフトフォンで構成されている可能性があり、またはそれは、たとえば、DHCPによって発見された可能性があります。"
    },
    {
      "indent": 3,
      "text": "The atlanta.com SIP server is a type of SIP server known as a proxy server. A proxy server receives SIP requests and forwards them on behalf of the requestor. In this example, the proxy server receives the INVITE request and sends a 100 (Trying) response back to Alice's softphone. The 100 (Trying) response indicates that the INVITE has been received and that the proxy is working on her behalf to route the INVITE to the destination. Responses in SIP use a three-digit code followed by a descriptive phrase. This response contains the same To, From, Call-ID, CSeq and branch parameter in the Via as the INVITE, which allows Alice's softphone to correlate this response to the sent INVITE. The atlanta.com proxy server locates the proxy server at biloxi.com, possibly by performing a particular type of DNS (Domain Name Service) lookup to find the SIP server that serves the biloxi.com domain. This is described in [4]. As a result, it obtains the IP address of the biloxi.com proxy server and forwards, or proxies, the INVITE request there. Before forwarding the request, the atlanta.com proxy server adds an additional Via header field value that contains its own address (the INVITE already contains Alice's address in the first Via). The biloxi.com proxy server receives the INVITE and responds with a 100 (Trying) response back to the atlanta.com proxy server to indicate that it has received the INVITE and is processing the request. The proxy server consults a database, generically called a location service, that contains the current IP address of Bob. (We shall see in the next section how this database can be populated.) The biloxi.com proxy server adds another Via header field value with its own address to the INVITE and proxies it to Bob's SIP phone.",
      "ja": "atlanta.comのSIPサーバは、プロキシサーバとしても知られているSIPサーバのタイプです。プロキシサーバは、SIPリクエストを受信し、要求者に代わって、それらを転送します。この例では、プロキシサーバーはINVITEリクエストを受信して​​、Aliceのソフトフォンに戻って100（しよう）応答を送信します。 100（しよう）応答が受信されたINVITEおよびプロキシがルートに彼女に代わって動作していることを先にINVITEことを示しています。 SIPでの応答は、記述句に続く3桁のコードを使用します。この応答は、コールID、のCSeqと分岐パラメータを経由で送信されたINVITEにこの応答を相関させるAliceのソフトフォンを可能にする、INVITEとから、同じへが含まれています。 atlanta.comプロキシサーバは、おそらくbiloxi.comドメインを提供していSIPサーバを検索するためにDNS（ドメインネームサービス）ルックアップの特定のタイプを実行することによって、biloxi.comにプロキシサーバを配置します。これは、[4]に記載されています。その結果、それはbiloxi.comのプロキシサーバーおよび転送、またはプロキシのIPアドレス、そこにINVITE要求を取得します。要求を転送する前に、atlanta.comのプロキシサーバは、自身のアドレスを（すでにINVITE最初のViaにAliceのアドレスが含まれている）が含まれ、追加のViaヘッダーフィールド値を追加します。 biloxi.comプロキシサーバは、INVITEを受信し、バックそれは、INVITEを受信し、要求を処理していることを示すためにatlanta.comプロキシサーバ100（試行）応答で応答します。プロキシサーバは、ボブの現在のIPアドレスが含まれている一般的にロケーションサービスと呼ばれるデータベースを、参照します。 （私たちは、このデータベースを埋めることができるか、次のセクションで参照するものとする。）biloxi.comのプロキシサーバーはINVITEとボブのSIP電話機にプロキシ、それが自身のアドレスで別のViaヘッダーフィールド値を追加します。"
    },
    {
      "indent": 3,
      "text": "Bob's SIP phone receives the INVITE and alerts Bob to the incoming call from Alice so that Bob can decide whether to answer the call, that is, Bob's phone rings. Bob's SIP phone indicates this in a 180 (Ringing) response, which is routed back through the two proxies in the reverse direction. Each proxy uses the Via header field to determine where to send the response and removes its own address from the top. As a result, although DNS and location service lookups were required to route the initial INVITE, the 180 (Ringing) response can be returned to the caller without lookups or without state being maintained in the proxies. This also has the desirable property that each proxy that sees the INVITE will also see all responses to the INVITE.",
      "ja": "ボブのSIPフォンはINVITEを受信し、ボブは、つまり、Bobの電話が鳴るの呼び出しに応答するかどうかを決定できるように、アリスからの着信にボブに警告します。ボブのSIP電話機は、逆方向に戻って2つのプロキシを介してルーティングされる180（リンギング）応答でこれを示しています。各プロキシは、ここで応答を送信するかを決定するためにViaヘッダーフィールドを使用し、上から自身のアドレスを除去します。 DNSとロケーションサービスの検索は、初期INVITEをルーティングするために必要とされたものの結果として、180（リンギング）応答は、ルックアップすることなく、または状態がプロキシに維持されずに呼び出し元に戻すことができます。また、これはINVITEを見て、各プロキシはまた、INVITEへのすべての応答を見ることができます望ましい特性を有しています。"
    },
    {
      "indent": 3,
      "text": "When Alice's softphone receives the 180 (Ringing) response, it passes this information to Alice, perhaps using an audio ringback tone or by displaying a message on Alice's screen.",
      "ja": "Aliceのソフトフォン180（リンギング）応答を受信すると、それはおそらく、オーディオリングバック・トーンを使用するか、アリスの画面にメッセージを表示することにより、アリスにこの情報を渡します。"
    },
    {
      "indent": 3,
      "text": "In this example, Bob decides to answer the call. When he picks up the handset, his SIP phone sends a 200 (OK) response to indicate that the call has been answered. The 200 (OK) contains a message body with the SDP media description of the type of session that Bob is willing to establish with Alice. As a result, there is a two-phase exchange of SDP messages: Alice sent one to Bob, and Bob sent one back to Alice. This two-phase exchange provides basic negotiation capabilities and is based on a simple offer/answer model of SDP exchange. If Bob did not wish to answer the call or was busy on another call, an error response would have been sent instead of the 200 (OK), which would have resulted in no media session being established. The complete list of SIP response codes is in Section 21. The 200 (OK) (message F9 in Figure 1) might look like this as Bob sends it out:",
      "ja": "この例では、ボブは、コールに応答することを決定します。彼は受話器を取ると、彼のSIPフォンは、呼が応答されたことを示すために200（OK）応答を送信します。 200（OK）は、ボブがアリスと確立する意思があるセッションのタイプのSDPのメディア記述とメッセージ本体を含んでいます。結果として、SDPメッセージの二相交流がある：アリスはボブに1を送信し、ボブはアリスに1つのバックを送りました。この二相交換は、基本的な交渉能力を提供し、SDP交換の単純なオファー/アンサーモデルに基づいています。ボブがコールに応答したいか、別のコールに忙しくしていなかった場合は、エラー応答が確立されていないメディアセッションをもたらしたと思われる、200（OK）の代わりに送信されていたであろう。 SIP応答コードの完全なリストは、ボブはそれを送信するように、このようになります。第21 200（OK）（図1のメッセージF9）です。"
    },
    {
      "indent": 6,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP server10.biloxi.com ;branch=z9hG4bKnashds8;received=192.0.2.3 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com ;branch=z9hG4bK77ef4c2312983.1;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com ;branch=z9hG4bK776asdhds ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710@pc33.atlanta.com CSeq: 314159 INVITE Contact: <sip:bob@192.0.2.4> Content-Type: application/sdp Content-Length: 131",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / UDP server10.biloxi.com;ブランチ= z9hG4bKnashds8は、受信= 192.0.2.3経由：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;ブランチ= z9hG4bK77ef4c2312983.1;受け取ら= 192.0.2.2経由：ボブ：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bK776asdhdsはに= 192.0.2.1を受けた<SIP：bob@biloxi.com>;タグ= a6c85cfをから：アリス<SIP：アトランタ@アリス.COM>;タグ= 1928301774のCall-ID：a84b4c76e66710@pc33.atlanta.comのCSeq：314159連絡先をINVITE：<SIP：bob@192.0.2.4>のContent-Type：アプリケーション/ SDPのContent-Length：131"
    },
    {
      "indent": 6,
      "text": "(Bob's SDP not shown)",
      "ja": "（BobのSDPは示されていません）"
    },
    {
      "indent": 3,
      "text": "The first line of the response contains the response code (200) and the reason phrase (OK). The remaining lines contain header fields. The Via, To, From, Call-ID, and CSeq header fields are copied from the INVITE request. (There are three Via header field values - one added by Alice's SIP phone, one added by the atlanta.com proxy, and one added by the biloxi.com proxy.) Bob's SIP phone has added a tag parameter to the To header field. This tag will be incorporated by both endpoints into the dialog and will be included in all future requests and responses in this call. The Contact header field contains a URI at which Bob can be directly reached at his SIP phone. The Content-Type and Content-Length refer to the message body (not shown) that contains Bob's SDP media information.",
      "ja": "応答の最初の行は応答コード（200）と理由フレーズ（OK）を含みます。残りの行は、ヘッダフィールドを含みます。経由、へ、からは、コールID、およびCSeqヘッダーフィールドはINVITEリクエストからコピーされます。 （ヘッダフィールド値を介して3がある - 。アリスのSIPフォン、atlanta.comプロキシによって追加された1加算一つとbiloxi.comプロキシによって追加されたもの）ボブのSIP電話機は、Toヘッダーフィールドにタグパラメータを追加しました。このタグは、ダイアログに両方のエンドポイントによって組み込まれると、このコールでは、将来のすべての要求と応答に含まれます。 Contactヘッダーフィールドは、ボブが直接彼のSIPフォンで到達可能なURIが含まれています。 Content-TypeとContent-Lengthは、BobのSDPメディア情報を含むメッセージ本体（図示せず）を参照してください。"
    },
    {
      "indent": 3,
      "text": "In addition to DNS and location service lookups shown in this example, proxy servers can make flexible \"routing decisions\" to decide where to send a request. For example, if Bob's SIP phone returned a 486 (Busy Here) response, the biloxi.com proxy server could proxy the INVITE to Bob's voicemail server. A proxy server can also send an INVITE to a number of locations at the same time. This type of parallel search is known as forking.",
      "ja": "この例で示すDNSとロケーションサービスのルックアップに加えて、プロキシサーバはどこリクエストを送信することを決定するための柔軟な「ルーティング決定」を作ることができます。ボブのSIPフォンが486（ここで忙しい）応答を返した場合、biloxi.comのプロキシサーバーは、プロキシは、ボブのボイスメールサーバにINVITEことができます。プロキシサーバも同時に位置の数にINVITEを送信することができます。並列検索このタイプのフォークとして知られています。"
    },
    {
      "indent": 3,
      "text": "In this case, the 200 (OK) is routed back through the two proxies and is received by Alice's softphone, which then stops the ringback tone and indicates that the call has been answered. Finally, Alice's softphone sends an acknowledgement message, ACK, to Bob's SIP phone to confirm the reception of the final response (200 (OK)). In this example, the ACK is sent directly from Alice's softphone to Bob's SIP phone, bypassing the two proxies. This occurs because the endpoints have learned each other's address from the Contact header fields through the INVITE/200 (OK) exchange, which was not known when the initial INVITE was sent. The lookups performed by the two proxies are no longer needed, so the proxies drop out of the call flow. This completes the INVITE/200/ACK three-way handshake used to establish SIP sessions. Full details on session setup are in Section 13.",
      "ja": "この場合、200（OK）は、2つのプロキシ経由ルートバックされ、その後、リングバックトーンを停止し、呼が応答されたことを示してAliceのソフトフォンによって受信されます。最後に、Aliceのソフトフォンは、最終応答（200（OK））の受信を確認するために、ボブのSIPフォンに、肯定応答メッセージACKを送信します。この例では、ACKは、2つのプロキシをバイパスし、ボブのSIPフォンにAliceのソフトフォンから直接送信されます。エンドポイントは、最初のINVITEが送られた時には知られていなかったINVITE / 200（OK）の交換を通じて、Contactヘッダーフィールドからお互いのアドレスを学んできたため、これが発生します。 2つのプロキシによって実行されるルックアップはもはや必要ではないので、プロキシは、コールフローの外にドロップします。これは、SIPセッションを確立するために使用されるINVITE / 200 / ACKスリーウェイハンドシェイクを完了します。セッションの設定に関する詳細は、セクション13です。"
    },
    {
      "indent": 3,
      "text": "Alice and Bob's media session has now begun, and they send media packets using the format to which they agreed in the exchange of SDP. In general, the end-to-end media packets take a different path from the SIP signaling messages.",
      "ja": "アリスとボブのメディアセッションは今始まった、と彼らは、SDPの交換で合意する形式を使用してメディアパケットを送信します。一般的に、エンド・ツー・エンドのメディアパケットは、SIPシグナリングメッセージは異なる経路を取ります。"
    },
    {
      "indent": 3,
      "text": "During the session, either Alice or Bob may decide to change the characteristics of the media session. This is accomplished by sending a re-INVITE containing a new media description. This re-INVITE references the existing dialog so that the other party knows that it is to modify an existing session instead of establishing a new session. The other party sends a 200 (OK) to accept the change. The requestor responds to the 200 (OK) with an ACK. If the other party does not accept the change, he sends an error response such as 488 (Not Acceptable Here), which also receives an ACK. However, the failure of the re-INVITE does not cause the existing call to fail - the session continues using the previously negotiated characteristics. Full details on session modification are in Section 14.",
      "ja": "セッション中、アリスまたはボブのどちらかがメディアセッションの特性を変更することもできます。これは新しいメディア記述を含む再INVITEを送ることによって達成されます。他の当事者が、それは新しいセッションを確立するのではなく、既存のセッションを修正することであることを知っているように、この参照に既存のダイアログを再INVITE。相手が変更を受け入れるために（OK）200を送信します。リクエスタはACKで200（OK）に応答します。相手が変更を受け入れない場合、彼はまた、ACKを受け取るように（ここでは許容できない）488などのエラー応答を送信します。しかし、-INVITEの再の失敗は既存の呼び出しが失敗することはありません - セッションが以前に交渉の特性を使用し続けています。セッションの変更に関する完全な詳細は、セクション14です。"
    },
    {
      "indent": 3,
      "text": "At the end of the call, Bob disconnects (hangs up) first and generates a BYE message. This BYE is routed directly to Alice's softphone, again bypassing the proxies. Alice confirms receipt of the BYE with a 200 (OK) response, which terminates the session and the BYE transaction. No ACK is sent - an ACK is only sent in response to a response to an INVITE request. The reasons for this special handling for INVITE will be discussed later, but relate to the reliability mechanisms in SIP, the length of time it can take for a ringing phone to be answered, and forking. For this reason, request handling in SIP is often classified as either INVITE or non-INVITE, referring to all other methods besides INVITE. Full details on session termination are in Section 15.",
      "ja": "コールの終了時に、ボブは切断（ハングアップ）第BYEメッセージを生成します。このBYEは、再びプロキシをバイパスして、Aliceのソフトフォンに直接ルーティングされます。アリスはセッションとBYEトランザクションを終了さ200（OK）応答、とBYEの受信を確認します。何ACKは送信されません -  ACKだけINVITEリクエストに対する応答に応じて送信されます。 INVITEのために、この特別な処理のための理由は後述するが、SIP、それは答えられるために呼び出し中の電話機のために取ることができる時間の長さで信頼性のメカニズムに関連して、フォークされます。このため、SIPの取り扱いリクエストは、多くの場合、ほかにINVITE他のすべてのメソッドを参照すると、INVITEまたは非INVITEのいずれかに分類されます。セッション終了の完全な詳細は、セクション15です。"
    },
    {
      "indent": 3,
      "text": "Section 24.2 describes the messages shown in Figure 1 in full.",
      "ja": "セクション24.2は全額、図1に示すメッセージについて説明します。"
    },
    {
      "indent": 3,
      "text": "In some cases, it may be useful for proxies in the SIP signaling path to see all the messaging between the endpoints for the duration of the session. For example, if the biloxi.com proxy server wished to remain in the SIP messaging path beyond the initial INVITE, it would add to the INVITE a required routing header field known as Record-Route that contained a URI resolving to the hostname or IP address of the proxy. This information would be received by both Bob's SIP phone and (due to the Record-Route header field being passed back in the 200 (OK)) Alice's softphone and stored for the duration of the dialog. The biloxi.com proxy server would then receive and proxy the ACK, BYE, and 200 (OK) to the BYE. Each proxy can independently decide to receive subsequent messages, and those messages will pass through all proxies that elect to receive it. This capability is frequently used for proxies that are providing mid-call features.",
      "ja": "場合によっては、セッションの間のエンドポイント間のすべてのメッセージを見るためにSIPシグナリング経路にプロキシするために有用であり得ます。 biloxi.comプロキシサーバがINVITE初期超えてSIPメッセージング経路に留まることを望む場合、例えば、それはホスト名またはIPアドレスに解決するURIを含んでいたレコードルートとして知られている必要なルーティングヘッダフィールドをINVITEに追加しますプロキシの。この情報は、Aliceのソフトフォン（これはRecord-Routeヘッダフィールドに200（OK）に戻されている）、ダイアログの期間保存された両方のボブのSIP電話機によって受信されるであろう。 biloxi.comのプロキシサーバは、BYEにACK、BYE、および200（OK）を受信し、プロキシでしょう。各プロキシは、独立して、後続のメッセージを受信することを決定することができ、そしてこれらのメッセージは、それを受け取ることを選択するすべてのプロキシを通過します。この機能は、頻繁に通話中の機能を提供しているプロキシのために使用されています。"
    },
    {
      "indent": 3,
      "text": "Registration is another common operation in SIP. Registration is one way that the biloxi.com server can learn the current location of Bob. Upon initialization, and at periodic intervals, Bob's SIP phone sends REGISTER messages to a server in the biloxi.com domain known as a SIP registrar. The REGISTER messages associate Bob's SIP or SIPS URI (sip:bob@biloxi.com) with the machine into which he is currently logged (conveyed as a SIP or SIPS URI in the Contact header field). The registrar writes this association, also called a binding, to a database, called the location service, where it can be used by the proxy in the biloxi.com domain. Often, a registrar server for a domain is co-located with the proxy for that domain. It is an important concept that the distinction between types of SIP servers is logical, not physical.",
      "ja": "登録は、SIP内の別の一般的な操作です。登録はbiloxi.comのサーバーがボブの現在位置を学ぶことができる1つの方法です。初期化時に、定期的な間隔で、ボブのSIPフォンはSIPレジストラとして知られるbiloxi.comドメイン内のサーバにREGISTERメッセージを送信します。 REGISTERメッセージ準BobのSIP URIまたは（SIP：bob@biloxi.com）をSIPS彼は、現在ログインしているマシン（SIPとして伝達またはContactヘッダーフィールドにURIをSIPS）で。レジストラは、この関連付けを書き込み、また、結合と呼ばれるデータベースに、それはbiloxi.comドメインにプロキシによって使用することができるロケーションサービスと呼ばれます。多くの場合、ドメインのレジストラサーバは、そのドメインのプロキシと同じ場所に配置されます。これは、SIPサーバのタイプの間の区別は物理的、論理的ではない重要な概念です。"
    },
    {
      "indent": 3,
      "text": "Bob is not limited to registering from a single device. For example, both his SIP phone at home and the one in the office could send registrations. This information is stored together in the location service and allows a proxy to perform various types of searches to locate Bob. Similarly, more than one user can be registered on a single device at the same time.",
      "ja": "ボブは、単一のデバイスから登録に限定されるものではありません。例えば、オフィスでの彼のSIPの自宅で電話と1の両方が登録を送信することができます。この情報は、位置サービスに一緒に格納され、ボブを見つけるための検索の様々なタイプを実行するためにプロキシを可能にします。同様に、複数のユーザが同時に単一の装置に登録することができます。"
    },
    {
      "indent": 3,
      "text": "The location service is just an abstract concept. It generally contains information that allows a proxy to input a URI and receive a set of zero or more URIs that tell the proxy where to send the request. Registrations are one way to create this information, but not the only way. Arbitrary mapping functions can be configured at the discretion of the administrator.",
      "ja": "ロケーションサービスは、単なる抽象的な概念です。これは、一般的に入力するプロキシURIができますし、リクエストを送信するプロキシを伝えるゼロ以上のURIのセットを受信情報が含まれています。登録は1つの情報を作成する方法ではなく、唯一の方法です。任意のマッピング機能は、管理者の裁量で設定することができます。"
    },
    {
      "indent": 3,
      "text": "Finally, it is important to note that in SIP, registration is used for routing incoming SIP requests and has no role in authorizing outgoing requests. Authorization and authentication are handled in SIP either on a request-by-request basis with a challenge/response mechanism, or by using a lower layer scheme as discussed in Section 26.",
      "ja": "最後に、SIPで、登録が着信SIP要求をルーティングするために使用され、発信要求を承認するには役割を持っていないことに注意することが重要です。許可および認証のいずれかのチャレンジ/応答機構と要求ごとに、またはセクション26で説明したように、下部層スキームを使用してSIPに処理されます。"
    },
    {
      "indent": 3,
      "text": "The complete set of SIP message details for this registration example is in Section 24.1.",
      "ja": "この登録例えばSIPメッセージの詳細の完全なセットは、セクション24.1です。"
    },
    {
      "indent": 3,
      "text": "Additional operations in SIP, such as querying for the capabilities of a SIP server or client using OPTIONS, or canceling a pending request using CANCEL, will be introduced in later sections.",
      "ja": "そのようなオプションを使用して、SIPサーバまたはクライアントの機能の照会、またはCANCEL使用保留中の要求をキャンセルするなどのSIPに追加の操作は、後のセクションで導入されます。"
    },
    {
      "indent": 0,
      "text": "5 Structure of the Protocol",
      "ja": "議定書の5構造"
    },
    {
      "indent": 3,
      "text": "SIP is structured as a layered protocol, which means that its behavior is described in terms of a set of fairly independent processing stages with only a loose coupling between each stage. The protocol behavior is described as layers for the purpose of presentation, allowing the description of functions common across elements in a single section. It does not dictate an implementation in any way. When we say that an element \"contains\" a layer, we mean it is compliant to the set of rules defined by that layer.",
      "ja": "SIPは、その動作が各ステージ間のみ疎結合とかなり独立した処理ステージのセットの観点から説明されていることを意味する階層型プロトコルとして構成されています。プロトコルの動作は、単一のセクション内のエレメント間で共通の機能の説明を可能にする、プレゼンテーションの目的のための層として記載されています。それはどのような方法で実装を規定していません。我々は要素が層「を含む」ことを言うとき、我々はそれがその層によって定義された一連のルールに準拠している意味します。"
    },
    {
      "indent": 3,
      "text": "Not every element specified by the protocol contains every layer. Furthermore, the elements specified by SIP are logical elements, not physical ones. A physical realization can choose to act as different logical elements, perhaps even on a transaction-by-transaction basis.",
      "ja": "プロトコルで指定されていないすべての要素がすべての層が含まれています。また、SIPによって指定された要素は、論理的要素ではなく、物理的なものです。物理的な実現は、おそらくトランザクションごとに、など、さまざまな論理要素として機能するように選択することができます。"
    },
    {
      "indent": 3,
      "text": "The lowest layer of SIP is its syntax and encoding. Its encoding is specified using an augmented Backus-Naur Form grammar (BNF). The complete BNF is specified in Section 25; an overview of a SIP message's structure can be found in Section 7.",
      "ja": "SIPの最下層は、その構文および符号化です。そのコードは、拡張バッカス・ナウアフォーム文法（BNF）を使用して指定されます。完全なBNFはセクション25で指定されています。 SIPメッセージの構造の概要については、第7節で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The second layer is the transport layer. It defines how a client sends requests and receives responses and how a server receives requests and sends responses over the network. All SIP elements contain a transport layer. The transport layer is described in Section 18.",
      "ja": "第二層は、トランスポート層です。これは、クライアントが要求を送信し、レスポンスとどのようにサーバーが要求を受信し、ネットワークを介して応答を送信を受信する方法を定義します。すべてのSIP要素は、トランスポート層を含んでいます。トランスポート層はセクション18に記載されています。"
    },
    {
      "indent": 3,
      "text": "The third layer is the transaction layer. Transactions are a fundamental component of SIP. A transaction is a request sent by a client transaction (using the transport layer) to a server transaction, along with all responses to that request sent from the server transaction back to the client. The transaction layer handles application-layer retransmissions, matching of responses to requests, and application-layer timeouts. Any task that a user agent client (UAC) accomplishes takes place using a series of transactions. Discussion of transactions can be found in Section 17. User agents contain a transaction layer, as do stateful proxies. Stateless proxies do not contain a transaction layer. The transaction layer has a client component (referred to as a client transaction) and a server component (referred to as a server transaction), each of which are represented by a finite state machine that is constructed to process a particular request.",
      "ja": "第3層はトランザクション層です。トランザクションは、SIPの基本的な構成要素です。トランザクションは、クライアントにサーバートランザクションから送信された要求に対するすべての応答と共に、サーバートランザクションに（トランスポート層を使用して）クライアントトランザクションによって送信された要求です。トランザクション層は、アプリケーション層の再送信、要求に対する応答のマッチング、およびアプリケーション層のタイムアウトを処理します。ユーザエージェントクライアント（UAC）を達成し、任意のタスクは、一連のトランザクションを使用して行われます。取引の議論は、ステートフルプロキシがそうであるように17ユーザー・エージェントは、トランザクション層が含まれているセクションで見つけることができます。ステートレスプロキシはトランザクション層を含んでいません。トランザクション層は、特定の要求を処理するように構成された有限状態機械で表されるそれぞれが（クライアントトランザクションと呼ばれる）は、クライアントコンポーネントと、（サーバートランザクションと称する）サーバコンポーネントを有しています。"
    },
    {
      "indent": 3,
      "text": "The layer above the transaction layer is called the transaction user (TU). Each of the SIP entities, except the stateless proxy, is a transaction user. When a TU wishes to send a request, it creates a client transaction instance and passes it the request along with the destination IP address, port, and transport to which to send the request. A TU that creates a client transaction can also cancel it. When a client cancels a transaction, it requests that the server stop further processing, revert to the state that existed before the transaction was initiated, and generate a specific error response to that transaction. This is done with a CANCEL request, which constitutes its own transaction, but references the transaction to be cancelled (Section 9).",
      "ja": "トランザクション層の上の層は、トランザクションユーザー（TU）と呼ばれています。 SIPエンティティのそれぞれは、ステートレスプロキシを除く、トランザクションユーザーです。 TUがリクエストを送信したい場合は、クライアントトランザクションのインスタンスを作成し、それを宛先IPアドレス、ポート、および要求を送信するまでの輸送と一緒に要求を渡します。クライアントのトランザクションを作成TUも、それをキャンセルすることができます。クライアントがトランザクションをキャンセルするときは、サーバーは、さらに処理を停止し、トランザクションが開始された前の状態に戻すと、そのトランザクションに固有のエラー応答を生成することを要求します。これは、独自のトランザクションを構成するCANCELリクエスト、で行われますが、キャンセルされるトランザクション（第9節）を参照しています。"
    },
    {
      "indent": 3,
      "text": "The SIP elements, that is, user agent clients and servers, stateless and stateful proxies and registrars, contain a core that distinguishes them from each other. Cores, except for the stateless proxy, are transaction users. While the behavior of the UAC and UAS cores depends on the method, there are some common rules for all methods (Section 8). For a UAC, these rules govern the construction of a request; for a UAS, they govern the processing of a request and generating a response. Since registrations play an important role in SIP, a UAS that handles a REGISTER is given the special name registrar. Section 10 describes UAC and UAS core behavior for the REGISTER method. Section 11 describes UAC and UAS core behavior for the OPTIONS method, used for determining the capabilities of a UA.",
      "ja": "SIP要素は、つまり、ユーザー・エージェント・クライアントとサーバ、ステートレスとステートフルプロキシおよびレジストラが、お互いからそれらを区別コアが含まれています。コアは、ステートレスプロキシを除き、トランザクションユーザーです。 UACとUASコアの動作は方法に依存するが、すべてのメソッド（セクション8）のためのいくつかの共通のルールがあります。 UACのために、これらのルールは、リクエストの建設を支配します。 UASのために、彼らは、要求と応答を生成する処理を支配します。登録はSIPに重要な役割を果たしているので、REGISTERを処理UASは、特別な名レジストラを与えています。セクション10は、REGISTERメソッドのUACとUASコアの動作を説明します。セクション11は、UAの能力を決定するために使用OPTIONSメソッドのUACとUASコアの動作を、記載されています。"
    },
    {
      "indent": 3,
      "text": "Certain other requests are sent within a dialog. A dialog is a peer-to-peer SIP relationship between two user agents that persists for some time. The dialog facilitates sequencing of messages and proper routing of requests between the user agents. The INVITE method is the only way defined in this specification to establish a dialog. When a UAC sends a request that is within the context of a dialog, it follows the common UAC rules as discussed in Section 8 but also the rules for mid-dialog requests. Section 12 discusses dialogs and presents the procedures for their construction and maintenance, in addition to construction of requests within a dialog.",
      "ja": "特定の他の要求は、ダイアログ内で送信されます。ダイアログは、しばらくの間持続する2つのユーザエージェント間のピアツーピアのSIP関係です。ダイアログには、メッセージやユーザエージェント間の要求の適切なルーティングの順序付けを容易にします。 INVITEメソッドは、ダイアログを確立するために、この仕様で定義された唯一の方法です。 UACダイアログのコンテキスト内で要求を送信すると、それはセクション8で説明したように一般的なUACのルールだけでなく、ダイアログ中のリクエストのための規則に従います。セクション12には、ダイアログを説明し、ダイアログ内のリクエストの構築に加えて、彼らの建設と維持管理のための手順を説明します。"
    },
    {
      "indent": 3,
      "text": "The most important method in SIP is the INVITE method, which is used to establish a session between participants. A session is a collection of participants, and streams of media between them, for the purposes of communication. Section 13 discusses how sessions are initiated, resulting in one or more SIP dialogs. Section 14 discusses how characteristics of that session are modified through the use of an INVITE request within a dialog. Finally, section 15 discusses how a session is terminated.",
      "ja": "SIPの中で最も重要な方法は、参加者間のセッションを確立するために使用されるINVITE方法、です。セッションでは、参加者の集まりであり、通信の目的のために、それらの間のメディアストリーム。第13節は、セッションが一つ以上のSIPダイアログで、その結果、開始されている方法について説明します。第14節は、そのセッションの特性は、ダイアログ内のINVITEリクエストを使用して修正されている方法について説明します。最後に、セクション15は、セッションが終了する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The procedures of Sections 8, 10, 11, 12, 13, 14, and 15 deal entirely with the UA core (Section 9 describes cancellation, which applies to both UA core and proxy core). Section 16 discusses the proxy element, which facilitates routing of messages between user agents.",
      "ja": "セクション8、10、11、12、13、14の手順、及びUAコアと完全に15契約（セクション9はUAコアとプロキシコアの両方に適用解除を記載します）。セクション16は、ユーザエージェント間のメッセージのルーティングを容易にするプロキシ要素を、説明します。"
    },
    {
      "indent": 0,
      "text": "6 Definitions",
      "ja": "6つの定義"
    },
    {
      "indent": 3,
      "text": "The following terms have special significance for SIP.",
      "ja": "次の用語は、SIPのために特別な意味を持っています。"
    },
    {
      "indent": 6,
      "text": "Address-of-Record: An address-of-record (AOR) is a SIP or SIPS URI that points to a domain with a location service that can map the URI to another URI where the user might be available. Typically, the location service is populated through registrations. An AOR is frequently thought of as the \"public address\" of the user.",
      "ja": "アドレス・オブ・レコード：アドレス・オブ・レコード（AOR）はSIPであるか、またはユーザが利用できるかもしれない別のURIにURIをマップすることができ、ロケーションサービスを使用してドメインをポイントするURIをSIPS。典型的には、ロケーションサービスは、登録を介して取り込まれます。 AORはしばしばユーザーの「パブリックアドレス」との考えられています。"
    },
    {
      "indent": 6,
      "text": "Back-to-Back User Agent: A back-to-back user agent (B2BUA) is a logical entity that receives a request and processes it as a user agent server (UAS). In order to determine how the request should be answered, it acts as a user agent client (UAC) and generates requests. Unlike a proxy server, it maintains dialog state and must participate in all requests sent on the dialogs it has established. Since it is a concatenation of a UAC and UAS, no explicit definitions are needed for its behavior.",
      "ja": "バックツーバックユーザエージェント：バックツーバックユーザエージェント（B2BUA）は、要求を受信し、ユーザエージェントサーバ（UAS）としてそれを処理する論理エンティティです。リクエストが答えられるべきかを決定するためには、ユーザエージェントクライアント（UAC）として機能し、要求を生成します。プロキシサーバーとは異なり、それは対話状態を維持し、それが確立しているのダイアログに送られたすべての要求に参加しなければなりません。それはUACとUASを連結したものですので、明示的な定義は、その動作のために必要ではありません。"
    },
    {
      "indent": 6,
      "text": "Call: A call is an informal term that refers to some communication between peers, generally set up for the purposes of a multimedia conversation.",
      "ja": "コール：コールは、一般的に、マルチメディア会話の目的のために設定ピア間の何らかの通信を指し、非公式な用語です。"
    },
    {
      "indent": 6,
      "text": "Call Leg: Another name for a dialog [31]; no longer used in this specification.",
      "ja": "脚を呼び出します：ダイアログの別名[31]。もはやこの仕様で使用されていません。"
    },
    {
      "indent": 6,
      "text": "Call Stateful: A proxy is call stateful if it retains state for a dialog from the initiating INVITE to the terminating BYE request. A call stateful proxy is always transaction stateful, but the converse is not necessarily true.",
      "ja": "ステートフルを呼び出します。それは終端BYE要求にINVITE開始からダイアログの状態を保持している場合、プロキシは、コールステートフルです。コールステートフルプロキシは常にトランザクションステートフルであるが、その逆は必ずしも真ではありません。"
    },
    {
      "indent": 6,
      "text": "Client: A client is any network element that sends SIP requests and receives SIP responses. Clients may or may not interact directly with a human user. User agent clients and proxies are clients.",
      "ja": "クライアント：クライアントは、SIPリクエストを送信し、SIPレスポンスを受信するネットワーク要素です。クライアントは、あるいは人間のユーザと直接対話しない場合があります。ユーザーエージェントクライアントとプロキシはクライアントです。"
    },
    {
      "indent": 6,
      "text": "Conference: A multimedia session (see below) that contains multiple participants.",
      "ja": "会議：複数の参加者が含まれているマルチメディアセッション（下記参照）。"
    },
    {
      "indent": 6,
      "text": "Core: Core designates the functions specific to a particular type of SIP entity, i.e., specific to either a stateful or stateless proxy, a user agent or registrar. All cores, except those for the stateless proxy, are transaction users.",
      "ja": "コア：コアがステートフルまたはステートレスプロキシ、ユーザエージェント、またはレジストラいずれか、すなわち、特定のSIPエンティティの特定のタイプに特定の機能を指定します。すべてのコアは、ステートレスプロキシのものを除いて、トランザクションのユーザーです。"
    },
    {
      "indent": 6,
      "text": "Dialog: A dialog is a peer-to-peer SIP relationship between two UAs that persists for some time. A dialog is established by SIP messages, such as a 2xx response to an INVITE request. A dialog is identified by a call identifier, local tag, and a remote tag. A dialog was formerly known as a call leg in RFC 2543.",
      "ja": "ダイアログ：ダイアログは、しばらくの間持続2つのUA間のピアツーピアのSIP関係です。ダイアログは、INVITEリクエストに対する2xx応答としてSIPメッセージによって確立されます。ダイアログは、呼識別子、ローカルタグ、およびリモートタグで識別されます。ダイアログは、以前はRFC 2543でのコールレッグとして知られていました。"
    },
    {
      "indent": 6,
      "text": "Downstream: A direction of message forwarding within a transaction that refers to the direction that requests flow from the user agent client to user agent server.",
      "ja": "ダウンストリーム：ユーザエージェントサーバへのユーザエージェントクライアントからの流れを要求した方向を指し、トランザクション内のメッセージ転送の方向。"
    },
    {
      "indent": 6,
      "text": "Final Response: A response that terminates a SIP transaction, as opposed to a provisional response that does not. All 2xx, 3xx, 4xx, 5xx and 6xx responses are final.",
      "ja": "最終回答：ない暫定応答とは反対に、SIPトランザクションを終了し、応答。すべての2XX、3XX、4XX、5xxのと6xxの応答が最終的なものです。"
    },
    {
      "indent": 6,
      "text": "Header: A header is a component of a SIP message that conveys information about the message. It is structured as a sequence of header fields.",
      "ja": "ヘッダ：ヘッダは、メッセージに関する情報を伝達するSIPメッセージの構成要素です。これは、ヘッダーフィールドのシーケンスとして構成されています。"
    },
    {
      "indent": 6,
      "text": "Header Field: A header field is a component of the SIP message header. A header field can appear as one or more header field rows. Header field rows consist of a header field name and zero or more header field values. Multiple header field values on a given header field row are separated by commas. Some header fields can only have a single header field value, and as a result, always appear as a single header field row.",
      "ja": "ヘッダフィールド：ヘッダフィールドは、SIPメッセージヘッダの構成要素です。ヘッダフィールドは、一つ以上のヘッダフィールドの行として表示することができます。ヘッダーフィールドの行は、ヘッダフィールド名およびゼロ以上のヘッダフィールド値から成ります。所定のヘッダフィールド行上の複数のヘッダフィールド値はコンマで区切られています。いくつかのヘッダーフィールドは、単一のヘッダフィールド値を有し、その結果、常に単一のヘッダフィールドの行として表示することができます。"
    },
    {
      "indent": 6,
      "text": "Header Field Value: A header field value is a single value; a header field consists of zero or more header field values.",
      "ja": "ヘッダフィールド値：ヘッダフィールド値は単一の値です。ヘッダーフィールドはゼロ以上のヘッダフィールド値から成ります。"
    },
    {
      "indent": 6,
      "text": "Home Domain: The domain providing service to a SIP user. Typically, this is the domain present in the URI in the address-of-record of a registration.",
      "ja": "ホームドメイン：ドメインは、SIPユーザーにサービスを提供します。典型的には、これは登録のアドレス・オブ・レコード内のURIのドメインに存在です。"
    },
    {
      "indent": 6,
      "text": "Informational Response: Same as a provisional response.",
      "ja": "情報対応：暫定応答と同じです。"
    },
    {
      "indent": 6,
      "text": "Initiator, Calling Party, Caller: The party initiating a session (and dialog) with an INVITE request. A caller retains this role from the time it sends the initial INVITE that established a dialog until the termination of that dialog.",
      "ja": "イニシエータ、コーリングパーティ、発信者：INVITEリクエストでセッション（およびダイアログ）を開始するパーティー。呼び出し側は、初期には、そのダイアログが終了するまで、ダイアログを確立し、そのINVITEを送信する時点から、この役割を保持します。"
    },
    {
      "indent": 6,
      "text": "Invitation: An INVITE request.",
      "ja": "招待状：INVITE要求。"
    },
    {
      "indent": 6,
      "text": "Invitee, Invited User, Called Party, Callee: The party that receives an INVITE request for the purpose of establishing a new session. A callee retains this role from the time it receives the INVITE until the termination of the dialog established by that INVITE.",
      "ja": "招待、パーティー、呼び出し先と呼ばれる招待されたユーザー、新しいセッションを確立することを目的に、INVITEリクエストを受け取るパーティー。呼び出し先は、それがそのINVITEによって確立されたダイアログの終了までINVITEを受信した時点から、この役割を保持します。"
    },
    {
      "indent": 6,
      "text": "Location Service: A location service is used by a SIP redirect or proxy server to obtain information about a callee's possible location(s). It contains a list of bindings of address-of-record keys to zero or more contact addresses. The bindings can be created and removed in many ways; this specification defines a REGISTER method that updates the bindings.",
      "ja": "ロケーションサービス：ロケーションサービスは、被呼者の可能な位置（単数または複数）についての情報を得るために、SIPリダイレクトまたはプロキシサーバによって使用されます。それは、ゼロ以上のコンタクトアドレスへのアドレスのレコードキーのバインディングのリストが含まれています。バインディングが作成され、多くの方法で削除することができます。この仕様は、バインディングを更新するREGISTERメソッドを定義します。"
    },
    {
      "indent": 6,
      "text": "Loop: A request that arrives at a proxy, is forwarded, and later arrives back at the same proxy. When it arrives the second time, its Request-URI is identical to the first time, and other header fields that affect proxy operation are unchanged, so that the proxy would make the same processing decision on the request it made the first time. Looped requests are errors, and the procedures for detecting them and handling them are described by the protocol.",
      "ja": "ループ：プロキシに到着した要求は、転送され、後で同じプロキシに戻って到着しています。それが二度目に到着すると、そのRequest-URIが初めてと同一であり、プロキシは、それが最初に行われた要求に同一の処理決定を行うであろうように、プロキシ動作に影響を与える他のヘッダフィールドは、不変です。ループされた要求はエラーであり、それらを検出し、それらを処理するための手順はプロトコルによって記述されています。"
    },
    {
      "indent": 6,
      "text": "Loose Routing: A proxy is said to be loose routing if it follows the procedures defined in this specification for processing of the Route header field. These procedures separate the destination of the request (present in the Request-URI) from the set of proxies that need to be visited along the way (present in the Route header field). A proxy compliant to these mechanisms is also known as a loose router.",
      "ja": "ルーズルーティングは：プロキシは、それがRouteヘッダーフィールドの処理のために本明細書で定義された手順に従う場合ルーズルーティングであると言われます。これらの手順は、方法（Routeヘッダーフィールドに存在する）に沿って訪問する必要があるプロキシの集合から（要求URI中に存在する）要求の宛先を分離します。これらのメカニズムに準拠したプロキシも緩いルータとして知られています。"
    },
    {
      "indent": 6,
      "text": "Message: Data sent between SIP elements as part of the protocol. SIP messages are either requests or responses.",
      "ja": "メッセージ：プロトコルの一部としてSIP要素間で送信されるデータ。 SIPメッセージは、要求または応答のどちらかです。"
    },
    {
      "indent": 6,
      "text": "Method: The method is the primary function that a request is meant to invoke on a server. The method is carried in the request message itself. Example methods are INVITE and BYE.",
      "ja": "方法：この方法は、要求がサーバに呼び出すことが意図される主要な機能です。方法は、要求メッセージ自体に運ばれます。例の方法は、INVITEとBYEされています。"
    },
    {
      "indent": 6,
      "text": "Outbound Proxy: A proxy that receives requests from a client, even though it may not be the server resolved by the Request-URI. Typically, a UA is manually configured with an outbound proxy, or can learn about one through auto-configuration protocols.",
      "ja": "アウトバウンドプロキシ：それは要求URIによって解決サーバでなくても、クライアントからのリクエストを受け取るプロキシ。典型的には、UAは、手動アウトバウンドプロキシで構成されている、あるいは自動設定プロトコルを通じて約いずれかを知ることができます。"
    },
    {
      "indent": 6,
      "text": "Parallel Search: In a parallel search, a proxy issues several requests to possible user locations upon receiving an incoming request. Rather than issuing one request and then waiting for the final response before issuing the next request as in a sequential search, a parallel search issues requests without waiting for the result of previous requests.",
      "ja": "並列検索は：並列検索では、プロキシは、着信要求を受信したときに可能ユーザーの場所にいくつかの要求を発行します。むしろ一つのリクエストを発行し、その後、順次検索のように次のリクエストを発行する前に、最終的な応答を待っているよりも、以前の要求の結果を待たずに並列検索要求を発行。"
    },
    {
      "indent": 6,
      "text": "Provisional Response: A response used by the server to indicate progress, but that does not terminate a SIP transaction. 1xx responses are provisional, other responses are considered final.",
      "ja": "暫定応答：進行状況を示すために、サーバによって使用される応答が、それはSIPトランザクションを終了しません。 1xx応答は暫定的なもので、他の応答は、最終的な考えられています。"
    },
    {
      "indent": 6,
      "text": "Proxy, Proxy Server: An intermediary entity that acts as both a server and a client for the purpose of making requests on behalf of other clients. A proxy server primarily plays the role of routing, which means its job is to ensure that a request is sent to another entity \"closer\" to the targeted user. Proxies are also useful for enforcing policy (for example, making sure a user is allowed to make a call). A proxy interprets, and, if necessary, rewrites specific parts of a request message before forwarding it.",
      "ja": "プロキシ、プロキシサーバー：他のクライアントに代わってリクエストを作成する目的のために、サーバーとクライアントの両方として動作する仲介エンティティ。プロキシサーバは、主にそのジョブが要求をターゲットユーザーに「近い」別のエンティティに送信されることを確実にするためであることを意味し、ルーティングの役割を果たしています。プロキシは、（例えば、ユーザがコールを行うことが許可されていることを確認すること）ポリシーを実施するために有用です。プロキシは、解釈、及び、必要であれば、それを転送する前に、要求メッセージの特定の部分を書き換えます。"
    },
    {
      "indent": 6,
      "text": "Recursion: A client recurses on a 3xx response when it generates a new request to one or more of the URIs in the Contact header field in the response.",
      "ja": "再帰：それは応答でContactヘッダーフィールドにおけるURIの一つ以上に新しい要求を生成するときに、クライアントは3xx応答で再帰します。"
    },
    {
      "indent": 6,
      "text": "Redirect Server: A redirect server is a user agent server that generates 3xx responses to requests it receives, directing the client to contact an alternate set of URIs.",
      "ja": "サーバーのリダイレクト：リダイレクトサーバは、URIの別のセットを連絡するためにクライアントを向ける、それが受け取る要求への3xx応答を生成し、ユーザエージェントサーバです。"
    },
    {
      "indent": 6,
      "text": "Registrar: A registrar is a server that accepts REGISTER requests and places the information it receives in those requests into the location service for the domain it handles.",
      "ja": "レジストラ：レジストラは、REGISTER要求を受け入れ、それが取り扱うドメインのロケーションサービスにそれらの要求に受信情報を配置するサーバです。"
    },
    {
      "indent": 6,
      "text": "Regular Transaction: A regular transaction is any transaction with a method other than INVITE, ACK, or CANCEL.",
      "ja": "通常のトランザクション：通常のトランザクションがACK、INVITE、またはCANCEL以外の方法との取引です。"
    },
    {
      "indent": 6,
      "text": "Request: A SIP message sent from a client to a server, for the purpose of invoking a particular operation.",
      "ja": "リクエスト：特定の操作を呼び出すために、クライアントからサーバに送信されるSIPメッセージ。"
    },
    {
      "indent": 6,
      "text": "Response: A SIP message sent from a server to a client, for indicating the status of a request sent from the client to the server.",
      "ja": "レスポンス：クライアントからサーバに送信された要求のステータスを示すために、サーバからクライアントに送信されるSIPメッセージ。"
    },
    {
      "indent": 6,
      "text": "Ringback: Ringback is the signaling tone produced by the calling party's application indicating that a called party is being alerted (ringing).",
      "ja": "リングバック：リングバックと呼ばれるパーティが（リンギング）を警告されていることを示す発呼者のアプリケーションによって生成さシグナリングトーンです。"
    },
    {
      "indent": 6,
      "text": "Route Set: A route set is a collection of ordered SIP or SIPS URI which represent a list of proxies that must be traversed when sending a particular request. A route set can be learned, through headers like Record-Route, or it can be configured.",
      "ja": "ルートセット：ルートセットは、特定のリクエストを送信するときに横断しなければならないプロキシのリストを表して注文したSIPまたはSIPS URIのコレクションです。ルートセットは、レコードルートヘッダ等を介して、学習することができ、またはそれを構成することができます。"
    },
    {
      "indent": 6,
      "text": "Server: A server is a network element that receives requests in order to service them and sends back responses to those requests. Examples of servers are proxies, user agent servers, redirect servers, and registrars.",
      "ja": "サーバー：サーバーは、それらにサービスを提供するために、要求を受信し、これらの要求に対する応答を返信するネットワーク要素です。サーバの例としては、プロキシ、ユーザエージェントサーバ、サーバにリダイレクトし、レジストラです。"
    },
    {
      "indent": 6,
      "text": "Sequential Search: In a sequential search, a proxy server attempts each contact address in sequence, proceeding to the next one only after the previous has generated a final response. A 2xx or 6xx class final response always terminates a sequential search.",
      "ja": "シーケンシャル検索：シーケンシャルサーチでは、プロキシ・サーバは、前の最終的な応答を生成した後にのみ、次のいずれかに進み、シーケンス内の各連絡先を試みます。 2XXまたはた6xxクラスの最終応答は常にシーケンシャルサーチを終了します。"
    },
    {
      "indent": 6,
      "text": "Session: From the SDP specification: \"A multimedia session is a set of multimedia senders and receivers and the data streams flowing from senders to receivers. A multimedia conference is an example of a multimedia session.\" (RFC 2327 [1]) (A session as defined for SDP can comprise one or more RTP sessions.) As defined, a callee can be invited several times, by different calls, to the same session. If SDP is used, a session is defined by the concatenation of the SDP user name, session id, network type, address type, and address elements in the origin field.",
      "ja": "セッション：SDP仕様からは：「マルチメディアセッションは、マルチメディア送信者と受信者と受信者に送信者から流れるデータストリームのセットであるマルチメディア会議は、マルチメディアセッションの一例です。」。 （RFC 2327 [1]）（SDPについて定義した通りセッションは、1つ以上のRTPセッションを含むことができる。）で定義されるように、被呼者が同じセッションに、異なる呼び出しによって、複数回招待することができます。 SDPが使用される場合、セッションは、SDPユーザー名、セッションID、ネットワークタイプ、アドレスタイプ、および原点フィールドのアドレス要素の連結によって定義されます。"
    },
    {
      "indent": 6,
      "text": "SIP Transaction: A SIP transaction occurs between a client and a server and comprises all messages from the first request sent from the client to the server up to a final (non-1xx) response sent from the server to the client. If the request is INVITE and the final response is a non-2xx, the transaction also includes an ACK to the response. The ACK for a 2xx response to an INVITE request is a separate transaction.",
      "ja": "SIPトランザクション：SIPトランザクションは、クライアントとサーバー間で発生し、サーバからクライアントに送信され、最終的な（非1xxの）応答までのクライアントからサーバに送られた最初の要求からすべてのメッセージを含んでいます。要求がINVITEであり、最終応答が非2xxの場合は、トランザクションは、応答にACKを含みます。 INVITEリクエストに対する2xx応答のためのACKは、別のトランザクションです。"
    },
    {
      "indent": 6,
      "text": "Spiral: A spiral is a SIP request that is routed to a proxy, forwarded onwards, and arrives once again at that proxy, but this time differs in a way that will result in a different processing decision than the original request. Typically, this means that the request's Request-URI differs from its previous arrival. A spiral is not an error condition, unlike a loop. A typical cause for this is call forwarding. A user calls joe@example.com. The example.com proxy forwards it to Joe's PC, which in turn, forwards it to bob@example.com. This request is proxied back to the example.com proxy. However, this is not a loop. Since the request is targeted at a different user, it is considered a spiral, and is a valid condition.",
      "ja": "スパイラル：スパイラル以降は、転送プロキシにルーティングされるSIPリクエスト、あり、そしてそのプロキシに再び到着したが、今回は、元の要求とは異なる処理決定になりますように異なります。通常、これは要求の要求URIが、その前の到着と異なることを意味します。スパイラルは、ループとは異なり、エラー状態ではありません。このため、一般的な原因は、コール転送です。ユーザーはjoe@example.comを呼び出します。 example.comプロキシは今度は、bob@example.comに転送JoeのPCに転送します。この要求は、example.comのプロキシに戻ってプロキシされます。しかし、これはループではありません。要求が別のユーザーをターゲットにしているので、それがスパイラルと考えられ、かつ有効な条件です。"
    },
    {
      "indent": 6,
      "text": "Stateful Proxy: A logical entity that maintains the client and server transaction state machines defined by this specification during the processing of a request, also known as a transaction stateful proxy. The behavior of a stateful proxy is further defined in Section 16. A (transaction) stateful proxy is not the same as a call stateful proxy.",
      "ja": "ステートフルプロキシ：また、トランザクションステートフルプロキシとして知られている要求の処理中にこの仕様で定義され、クライアントとサーバートランザクションステートマシンを維持する論理エンティティ。ステートフルプロキシの動作はさらに、ステートフルプロキシはコールステートフルプロキシと同じではありません部16 A（トランザクション）で定義されています。"
    },
    {
      "indent": 6,
      "text": "Stateless Proxy: A logical entity that does not maintain the client or server transaction state machines defined in this specification when it processes requests. A stateless proxy forwards every request it receives downstream and every response it receives upstream.",
      "ja": "ステートレスプロキシ：それは要求を処理するときに、この仕様で定義されているクライアントまたはサーバのトランザクションステートマシンを維持しない論理エンティティ。ステートレスプロキシは転送し、すべてのそれは、上流受け下流、すべての応答を受信要求します。"
    },
    {
      "indent": 6,
      "text": "Strict Routing: A proxy is said to be strict routing if it follows the Route processing rules of RFC 2543 and many prior work in progress versions of this RFC. That rule caused proxies to destroy the contents of the Request-URI when a Route header field was present. Strict routing behavior is not used in this specification, in favor of a loose routing behavior. Proxies that perform strict routing are also known as strict routers.",
      "ja": "厳密ルーティングは：プロキシは、それがこのRFCの進捗バージョンのRFC 2543と多くの従来の研究のルート処理規則に従った場合、厳密なルーティングであると言われます。そのルールは、Request-URI Routeヘッダーフィールドが存在していた内容を破壊するためにプロキシを引き起こしました。厳格なルーティング動作は緩いルーティング動作の賛成で、本明細書中で使用されていません。厳密なルーティングを行うプロキシはまた、厳密ルータとして知られています。"
    },
    {
      "indent": 6,
      "text": "Target Refresh Request: A target refresh request sent within a dialog is defined as a request that can modify the remote target of the dialog.",
      "ja": "ターゲットリフレッシュ要求：ダイアログ内で送信され、ターゲットリフレッシュリクエストはダイアログのリモートターゲットを変更することができ、要求として定義されます。"
    },
    {
      "indent": 6,
      "text": "Transaction User (TU): The layer of protocol processing that resides above the transaction layer. Transaction users include the UAC core, UAS core, and proxy core.",
      "ja": "トランザクションユーザー（TU）：トランザクション層の上に存在するプロトコル処理の層。トランザクションユーザーは、UACコア、UASコア、およびプロキシコアを含みます。"
    },
    {
      "indent": 6,
      "text": "Upstream: A direction of message forwarding within a transaction that refers to the direction that responses flow from the user agent server back to the user agent client.",
      "ja": "上流：応答はバックユーザエージェントクライアントにユーザエージェントサーバからの流れという方向を指し、トランザクション内のメッセージ転送の方向。"
    },
    {
      "indent": 6,
      "text": "URL-encoded: A character string encoded according to RFC 2396, Section 2.4 [5].",
      "ja": "URLエンコード：RFC 2396に従ってエンコードされた文字列は、セクション2.4 [5]。"
    },
    {
      "indent": 6,
      "text": "User Agent Client (UAC): A user agent client is a logical entity that creates a new request, and then uses the client transaction state machinery to send it. The role of UAC lasts only for the duration of that transaction. In other words, if a piece of software initiates a request, it acts as a UAC for the duration of that transaction. If it receives a request later, it assumes the role of a user agent server for the processing of that transaction.",
      "ja": "ユーザエージェントクライアント（UAC）：ユーザエージェントクライアントが新しい要求を作成し、それを送信するために、クライアントのトランザクション状態機械を使用する論理エンティティです。 UACの役割は、そのトランザクションの期間持続します。ソフトウェアの一部は、要求を開始言い換えれば、それはそのトランザクションの期間UACとして機能します。それは後で要求を受信した場合、そのトランザクションを処理するためのユーザエージェントサーバの役割を前提としています。"
    },
    {
      "indent": 6,
      "text": "UAC Core: The set of processing functions required of a UAC that reside above the transaction and transport layers.",
      "ja": "UACコア：トランザクションおよび輸送層上に常駐するUACに必要な処理機能のセット。"
    },
    {
      "indent": 6,
      "text": "User Agent Server (UAS): A user agent server is a logical entity that generates a response to a SIP request. The response accepts, rejects, or redirects the request. This role lasts only for the duration of that transaction. In other words, if a piece of software responds to a request, it acts as a UAS for the duration of that transaction. If it generates a request later, it assumes the role of a user agent client for the processing of that transaction.",
      "ja": "ユーザエージェントサーバ（UAS）は：ユーザエージェントサーバは、SIP要求に対する応答を生成する論理エンティティです。応答は、受け入れ拒否、あるいは要求をリダイレクトします。この役割は、そのトランザクションの期間持続します。ソフトウェアの一部が要求に応答言い換えれば、それはそのトランザクションの期間中にUASとして動作します。それは後で要求を生成した場合、そのトランザクションを処理するためのユーザエージェントクライアントの役割を前提としています。"
    },
    {
      "indent": 6,
      "text": "UAS Core: The set of processing functions required at a UAS that resides above the transaction and transport layers.",
      "ja": "UASコア：トランザクションおよび輸送層上に常駐UASに必要とされる処理機能のセット。"
    },
    {
      "indent": 6,
      "text": "User Agent (UA): A logical entity that can act as both a user agent client and user agent server.",
      "ja": "ユーザーエージェント（UA）：ユーザー・エージェント・クライアントとユーザエージェントサーバの両方として作用することができる論理エンティティ。"
    },
    {
      "indent": 3,
      "text": "The role of UAC and UAS, as well as proxy and redirect servers, are defined on a transaction-by-transaction basis. For example, the user agent initiating a call acts as a UAC when sending the initial INVITE request and as a UAS when receiving a BYE request from the callee. Similarly, the same software can act as a proxy server for one request and as a redirect server for the next request.",
      "ja": "UACとUASの役割だけでなく、プロキシとサーバーをリダイレクトするには、トランザクションごとに定義されています。例えば、初期の送信時にUACとしてコール作用を開始するユーザエージェントは、被呼者からBYE要求を受信する要求とUASとしてのINVITE。同様に、同じソフトウェアは、1つの要求のプロキシサーバとして、次の要求のリダイレクトサーバとして機能することができます。"
    },
    {
      "indent": 3,
      "text": "Proxy, location, and registrar servers defined above are logical entities; implementations MAY combine them into a single application.",
      "ja": "上記で定義されたプロキシ、場所、およびレジストラサーバーは、論理的なエンティティです。実装では、単一のアプリケーションにそれらを組み合わせることができます。"
    },
    {
      "indent": 0,
      "text": "7 SIP Messages",
      "ja": "7件のSIPメッセージ"
    },
    {
      "indent": 3,
      "text": "SIP is a text-based protocol and uses the UTF-8 charset (RFC 2279 [7]).",
      "ja": "SIPは、テキストベースのプロトコルであり、UTF-8文字セットを使用する（RFC 2279 [7]）。"
    },
    {
      "indent": 3,
      "text": "A SIP message is either a request from a client to a server, or a response from a server to a client.",
      "ja": "SIPメッセージは、クライアントからサーバへの要求、またはサーバからクライアントへの応答のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Both Request (section 7.1) and Response (section 7.2) messages use the basic format of RFC 2822 [3], even though the syntax differs in character set and syntax specifics. (SIP allows header fields that would not be valid RFC 2822 header fields, for example.) Both types of messages consist of a start-line, one or more header fields, an empty line indicating the end of the header fields, and an optional message-body.",
      "ja": "両方の要求（セクション7.1）と応答（セクション7.2）メッセージ構文は、文字セットと構文仕様が異なるにもかかわらず、[3] RFC 2822の基本的な形式を使用します。 （SIPは、例えば、有効なRFC 2822ヘッダーフィールドではないヘッダフィールドを可能にする。）メッセージの両方のタイプは、スタートライン、一つ以上のヘッダフィールド、ヘッダフィールドの終わりを示す空行、およびオプションで構成しますメッセージ本文。"
    },
    {
      "indent": 9,
      "text": "generic-message  =  start-line\n                    *message-header\n                    CRLF\n                    [ message-body ]\nstart-line       =  Request-Line / Status-Line",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The start-line, each message-header line, and the empty line MUST be terminated by a carriage-return line-feed sequence (CRLF). Note that the empty line MUST be present even if the message-body is not.",
      "ja": "スタートラインに、各メッセージヘッダ行、空行がキャリッジリターンラインフィードシーケンス（CRLF）で終了する必要があります。空行は、メッセージボディがない場合でも存在しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Except for the above difference in character sets, much of SIP's message and header field syntax is identical to HTTP/1.1. Rather than repeating the syntax and semantics here, we use [HX.Y] to refer to Section X.Y of the current HTTP/1.1 specification (RFC 2616 [8]).",
      "ja": "文字セットで上記の違いを除いて、SIPのメッセージとヘッダフィールドの構文の多くは、HTTP / 1.1と同じです。むしろ、ここで構文とセマンティクスを繰り返すよりも、私たちは、現在のHTTP / 1.1仕様（RFC 2616 [8]）のセクションX.Yを参照するために[HX.Y]を使用します。"
    },
    {
      "indent": 3,
      "text": "However, SIP is not an extension of HTTP.",
      "ja": "しかし、SIPはHTTPの拡張ではありません。"
    },
    {
      "indent": 0,
      "text": "7.1 Requests",
      "section_title": true,
      "ja": "7.1要求"
    },
    {
      "indent": 3,
      "text": "SIP requests are distinguished by having a Request-Line for a start-line. A Request-Line contains a method name, a Request-URI, and the protocol version separated by a single space (SP) character.",
      "ja": "SIPリクエストは、スタートラインのためのリクエストラインを持つことで区別されています。リクエストラインは、メソッド名、要求URI、および単一のスペース（SP）文字で区切られたプロトコルのバージョンが含まれています。"
    },
    {
      "indent": 3,
      "text": "The Request-Line ends with CRLF. No CR or LF are allowed except in the end-of-line CRLF sequence. No linear whitespace (LWS) is allowed in any of the elements.",
      "ja": "リクエストラインはCRLFで終わります。 CRまたはLF NOが行末CRLFシーケンス以外で許可されていません。いいえ線形空白（LWS）は、要素のいずれかで許可されていません。"
    },
    {
      "indent": 9,
      "text": "Request-Line = Method SP Request-URI SP SIP-Version CRLF",
      "ja": "リクエストライン=メソッドSPのRequest-URI SP SIP-バージョンCRLF"
    },
    {
      "indent": 6,
      "text": "Method: This specification defines six methods: REGISTER for registering contact information, INVITE, ACK, and CANCEL for setting up sessions, BYE for terminating sessions, and OPTIONS for querying servers about their capabilities. SIP extensions, documented in standards track RFCs, may define additional methods.",
      "ja": "方法：この仕様は、6つのメソッドを定義します、連絡先情報を登録するためのREGISTER、INVITE、ACK、およびセッションを設定するためのCANCEL、BYEセッションを終了するため、とその機能についてのサーバーを照会するためのオプション。標準トラックRFCで文書化されたSIPの拡張機能は、追加のメソッドを定義することができます。"
    },
    {
      "indent": 6,
      "text": "Request-URI: The Request-URI is a SIP or SIPS URI as described in Section 19.1 or a general URI (RFC 2396 [5]). It indicates the user or service to which this request is being addressed. The Request-URI MUST NOT contain unescaped spaces or control characters and MUST NOT be enclosed in \"<>\".",
      "ja": "リクエストURI：リクエストURIがSIPであるか、または、セクション19.1または一般URIに記載されるようにURIをSIPS（RFC 2396 [5]）。これは、この要求が対処されている先のユーザまたはサービスを示します。 Request-URIが「> <」エスケープスペースや制御文字を含めることはできませんとで囲むことはできません。"
    },
    {
      "indent": 11,
      "text": "SIP elements MAY support Request-URIs with schemes other than\n\"sip\" and \"sips\", for example the \"tel\" URI scheme of RFC\n2806 [9].  SIP elements MAY translate non-SIP URIs using any\nmechanism at their disposal, resulting in SIP URI, SIPS URI,\nor some other scheme.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "SIP-Version: Both request and response messages include the version of SIP in use, and follow [H3.1] (with HTTP replaced by SIP, and HTTP/1.1 replaced by SIP/2.0) regarding version ordering, compliance requirements, and upgrading of version numbers. To be compliant with this specification, applications sending SIP messages MUST include a SIP-Version of \"SIP/2.0\". The SIP-Version string is case-insensitive, but implementations MUST send upper-case.",
      "ja": "バージョン注文、コンプライアンス要件、およびアップグレードに関する両方の要求と応答メッセージが使用中でSIPのバージョンを含み、そして（SIPで置き換えHTTP、およびHTTP / 1.1 SIP / 2.0に置き換えで）H3.1]をフォロー：SIP-版バージョン番号の。この仕様に準拠するために、SIPメッセージを送信するアプリケーションは、「SIP / 2.0」のSIP-バージョンを含まなければなりません。 SIPバージョンの文字列は、大文字小文字を区別しないが、実装は大文字を送らなければなりません。"
    },
    {
      "indent": 11,
      "text": "Unlike HTTP/1.1, SIP treats the version number as a literal\nstring.  In practice, this should make no difference.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2 Responses",
      "section_title": true,
      "ja": "7.2応答"
    },
    {
      "indent": 3,
      "text": "SIP responses are distinguished from requests by having a Status-Line as their start-line. A Status-Line consists of the protocol version followed by a numeric Status-Code and its associated textual phrase, with each element separated by a single SP character.",
      "ja": "SIP応答は、そのスタートラインとしてのステータスラインを持つことによって要求と区別されます。ステータスラインは、単一のSP文字で区切られた各要素を、数値ステータスコードとそれに関連するテキストフレーズが続くプロトコルバージョンから構成されています。"
    },
    {
      "indent": 3,
      "text": "No CR or LF is allowed except in the final CRLF sequence.",
      "ja": "CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。"
    },
    {
      "indent": 6,
      "text": "Status-Line = SIP-Version SP Status-Code SP Reason-Phrase CRLF",
      "ja": "ステータスライン= SIP-バージョンのSPステータスコードSP理由-フレーズCRLF"
    },
    {
      "indent": 3,
      "text": "The Status-Code is a 3-digit integer result code that indicates the outcome of an attempt to understand and satisfy a request. The Reason-Phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use by automata, whereas the Reason-Phrase is intended for the human user. A client is not required to examine or display the Reason-Phrase.",
      "ja": "ステータスコードを理解し、要求を満たすための試みの結果を示す3桁の整数の結果コードです。理由-フレーズは、ステータスコードの短いテキスト記述を与えることを目的としています。理由-フレーズが人間のユーザのために意図されたのに対し、ステータスコードは、オートマトンによる使用を目的としています。クライアントが理由-フレーズを調べたり、表示するために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "While this specification suggests specific wording for the reason phrase, implementations MAY choose other text, for example, in the language indicated in the Accept-Language header field of the request.",
      "ja": "この仕様が理由フレーズのための特定の文言を提案しているが、実装が要求のたAccept-Languageヘッダフィールドで示された言語では例えば他のテキストを、選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "The first digit of the Status-Code defines the class of response. The last two digits do not have any categorization role. For this reason, any response with a status code between 100 and 199 is referred to as a \"1xx response\", any response with a status code between 200 and 299 as a \"2xx response\", and so on. SIP/2.0 allows six values for the first digit:",
      "ja": "ステータスコードの最初の数字は応答のクラスを定義します。最後の2桁は任意の分類の役割を持っていません。この理由のために、100と199との間のステータスコードを有する任意の応答はそうで「1XX応答」、「2xx応答」として200と299との間のステータスコードを有する任意の応答、およびと呼ばれます。 SIP / 2.0は、最初の桁のために6つの値を使用できます"
    },
    {
      "indent": 6,
      "text": "1xx: Provisional -- request received, continuing to process the request;",
      "ja": "1XX：暫定 - リクエストは、リクエストを処理し続け、受信しました。"
    },
    {
      "indent": 6,
      "text": "2xx: Success -- the action was successfully received, understood, and accepted;",
      "ja": "2XX：成功 - アクションが正常に受信された、理解、および受け入れ;"
    },
    {
      "indent": 6,
      "text": "3xx: Redirection -- further action needs to be taken in order to complete the request;",
      "ja": "300番台：リダイレクション - 更なるアクションが要求を完了するために取られる必要があります。"
    },
    {
      "indent": 6,
      "text": "4xx: Client Error -- the request contains bad syntax or cannot be fulfilled at this server;",
      "ja": "4XX：クライアントエラー - 要求が不正な構文を含む、またはこのサーバーでは実行できません。"
    },
    {
      "indent": 6,
      "text": "5xx: Server Error -- the server failed to fulfill an apparently valid request;",
      "ja": "5xxの：サーバーエラー - サーバーが明らかに有効な要求を満たすために失敗しました。"
    },
    {
      "indent": 6,
      "text": "6xx: Global Failure -- the request cannot be fulfilled at any server.",
      "ja": "6xx：グローバル失敗 - 要求がどのサーバーでも実行できません。"
    },
    {
      "indent": 3,
      "text": "Section 21 defines these classes and describes the individual codes.",
      "ja": "セクション21には、これらのクラスを定義し、個々のコードについて説明します。"
    },
    {
      "indent": 0,
      "text": "7.3 Header Fields",
      "section_title": true,
      "ja": "7.3ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "SIP header fields are similar to HTTP header fields in both syntax and semantics. In particular, SIP header fields follow the [H4.2] definitions of syntax for the message-header and the rules for extending header fields over multiple lines. However, the latter is specified in HTTP with implicit whitespace and folding. This specification conforms to RFC 2234 [10] and uses only explicit whitespace and folding as an integral part of the grammar.",
      "ja": "SIPヘッダフィールドは、構文と意味の両方でHTTPヘッダフィールドに類似しています。具体的には、SIPヘッダフィールドは複数行にわたってヘッダフィールドを拡張するためのメッセージ・ヘッダの構文[H4.2]定義および規則に従います。しかし、後者は暗黙の空白や折りたたみとHTTPに指定されています。この仕様は、RFC 2234 [10]に準拠し、文法の一体部分としてのみ明示的な空白と折り畳みを使用します。"
    },
    {
      "indent": 3,
      "text": "[H4.2] also specifies that multiple header fields of the same field name whose value is a comma-separated list can be combined into one header field. That applies to SIP as well, but the specific rule is different because of the different grammars. Specifically, any SIP header whose grammar is of the form",
      "ja": "[H4.2]も値がカンマで区切られたリストであり、同じフィールド名の複数ヘッダフィールドが1つのヘッダフィールドに組み合わせることができることを指定します。それは、同様にSIPに適用されますが、特定のルールが異なるため文法の異なるものです。具体的には、その文法の任意のSIPヘッダの形式であります"
    },
    {
      "indent": 6,
      "text": "header = \"header-name\" HCOLON header-value *(COMMA header-value)",
      "ja": "ヘッダー=「ヘッダ名」HCOLONヘッダ値*（COMMAヘッダ値）"
    },
    {
      "indent": 3,
      "text": "allows for combining header fields of the same name into a comma-separated list. The Contact header field allows a comma-separated list unless the header field value is \"*\".",
      "ja": "カンマ区切りのリストに同じ名前のヘッダフィールドを組み合わせることを可能にします。 Contactヘッダーフィールドヘッダーフィールドの値が「*」でない限り、カンマ区切りのリストを可能にします。"
    },
    {
      "indent": 0,
      "text": "7.3.1 Header Field Format",
      "section_title": true,
      "ja": "7.3.1ヘッダーフィールドのフォーマット"
    },
    {
      "indent": 3,
      "text": "Header fields follow the same generic header format as that given in Section 2.2 of RFC 2822 [3]. Each header field consists of a field name followed by a colon (\":\") and the field value.",
      "ja": "ヘッダフィールドは、RFC 2822のセクション2.2で与えられたものと同じ一般的なヘッダフォーマットに従う[3]。フィールド値：各ヘッダフィールドは、コロン（「」）が続くフィールド名から成ります。"
    },
    {
      "indent": 6,
      "text": "field-name: field-value",
      "ja": "フィールド名：フィールド値"
    },
    {
      "indent": 3,
      "text": "The formal grammar for a message-header specified in Section 25 allows for an arbitrary amount of whitespace on either side of the colon; however, implementations should avoid spaces between the field name and the colon and use a single space (SP) between the colon and the field-value.",
      "ja": "セクション25で指定されたメッセージ・ヘッダーの形式文法は、結腸の両側に空白の任意の量が可能になります。しかし、実装は、フィールド名とコロンの間にスペースを回避し、コロンとフィールド値の間に単一のスペース（SP）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Subject: lunch Subject : lunch Subject :lunch Subject: lunch",
      "ja": "件名：ランチテーマ：ランチテーマ：ランチ件名：昼食"
    },
    {
      "indent": 3,
      "text": "Thus, the above are all valid and equivalent, but the last is the preferred form.",
      "ja": "したがって、上記はすべて有効と同等ですが、最後は好ましい形態です。"
    },
    {
      "indent": 3,
      "text": "Header fields can be extended over multiple lines by preceding each extra line with at least one SP or horizontal tab (HT). The line break and the whitespace at the beginning of the next line are treated as a single SP character. Thus, the following are equivalent:",
      "ja": "ヘッダフィールドは、少なくとも1つのSPまたは水平タブ（HT）と各追加のラインを先行することによって、複数の行にわたって拡張することができます。改行と、次の行の先頭の空白は、単一のSP文字として扱われます。したがって、以下は等価です。"
    },
    {
      "indent": 6,
      "text": "Subject: I know you're there, pick up the phone and talk to me! Subject: I know you're there, pick up the phone and talk to me!",
      "ja": "件名：私は、私に電話して話を拾う、あなたがそこにいる知っています！件名：私は、私に電話して話を拾う、あなたがそこにいる知っています！"
    },
    {
      "indent": 3,
      "text": "The relative order of header fields with different field names is not significant. However, it is RECOMMENDED that header fields which are needed for proxy processing (Via, Route, Record-Route, Proxy-Require, Max-Forwards, and Proxy-Authorization, for example) appear towards the top of the message to facilitate rapid parsing. The relative order of header field rows with the same field name is important. Multiple header field rows with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list (that is, if follows the grammar defined in Section 7.3). It MUST be possible to combine the multiple header field rows into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The exceptions to this rule are the WWW-Authenticate, Authorization, Proxy-Authenticate, and Proxy-Authorization header fields. Multiple header field rows with these names MAY be present in a message, but since their grammar does not follow the general form listed in Section 7.3, they MUST NOT be combined into a single header field row.",
      "ja": "異なるフィールド名を持つヘッダフィールドの相対的な順序は重要ではありません。しかし、迅速解析を容易にするために、メッセージの先頭に向かって表示され（例えば、ビア、経路レコードルート、プロキシは、要求、最大転送し、プロキシ認証）プロキシ処理に必要とされるヘッダフィールドを推奨されています。同じフィールド名を持つヘッダフィールド行の相対的順序は重要です。そのヘッダフィールドの全体のフィールド値をカンマ区切りのリストとして定義されている場合だけ、同じフィールド名を持つ複数のヘッダフィールドの行は、メッセージ中に存在しているかもしれません（すなわち、7.3節で定義された文法に従う場合） 。カンマで区切られ、最初に後続の各フィールド値を追加することによって、メッセージのセマンティクスを変更することなく、「フィールド値のフィールド名」ペア1つに複数のヘッダフィールドの行を組み合わせることが可能でなければなりません。この規則の例外は、WWW認証、認可、プロキシ認証、およびプロキシ認証ヘッダフィールドです。これらの名前を持つ複数のヘッダフィールドの行は、メッセージ中に存在してもよく、それらの文法は、セクション7.3に記載されている一般的な形式に従わないので、それらは単一のヘッダフィールドの行に結合されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST be able to process multiple header field rows with the same name in any combination of the single-value-per-line or comma-separated value forms.",
      "ja": "実装は、単一値あたりの行またはカンマ区切り形式の任意の組み合わせで同じ名前の複数のヘッダフィールドの行を処理できなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following groups of header field rows are valid and equivalent:",
      "ja": "ヘッダフィールド行の次のグループが有効と等価です。"
    },
    {
      "indent": 6,
      "text": "Route: <sip:alice@atlanta.com> Subject: Lunch Route: <sip:bob@biloxi.com> Route: <sip:carol@chicago.com>",
      "ja": "ルート：<SIP：alice@atlanta.com>件名：ランチルート：<SIP：bob@biloxi.com>ルート：<SIP：carol@chicago.com>"
    },
    {
      "indent": 6,
      "text": "Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com> Route: <sip:carol@chicago.com> Subject: Lunch",
      "ja": "ルート：<SIP：alice@atlanta.com>、<SIP：bob@biloxi.com>ルート：<SIP：carol@chicago.com>件名：ランチ"
    },
    {
      "indent": 6,
      "text": "Subject: Lunch Route: <sip:alice@atlanta.com>, <sip:bob@biloxi.com>, <sip:carol@chicago.com>",
      "ja": "件名：ランチルート：<SIP：alice@atlanta.com>、<SIP：bob@biloxi.com>、<SIP：carol@chicago.com>"
    },
    {
      "indent": 3,
      "text": "Each of the following blocks is valid but not equivalent to the others:",
      "ja": "以下の各ブロックは有効ですが、他のものと同等ではありません。"
    },
    {
      "indent": 6,
      "text": "Route: <sip:alice@atlanta.com> Route: <sip:bob@biloxi.com> Route: <sip:carol@chicago.com>",
      "ja": "ルート：<SIP：alice@atlanta.com>ルート：<SIP：bob@biloxi.com>ルート：<SIP：carol@chicago.com>"
    },
    {
      "indent": 6,
      "text": "Route: <sip:bob@biloxi.com> Route: <sip:alice@atlanta.com> Route: <sip:carol@chicago.com>",
      "ja": "ルート：<SIP：bob@biloxi.com>ルート：<SIP：alice@atlanta.com>ルート：<SIP：carol@chicago.com>"
    },
    {
      "indent": 6,
      "text": "Route: <sip:alice@atlanta.com>,<sip:carol@chicago.com>, <sip:bob@biloxi.com>",
      "ja": "ルート：<SIP：alice@atlanta.com>、<SIP：carol@chicago.com>、<SIP：bob@biloxi.com>"
    },
    {
      "indent": 3,
      "text": "The format of a header field-value is defined per header-name. It will always be either an opaque sequence of TEXT-UTF8 octets, or a combination of whitespace, tokens, separators, and quoted strings. Many existing header fields will adhere to the general form of a value followed by a semi-colon separated sequence of parameter-name, parameter-value pairs:",
      "ja": "ヘッダフィールド値のフォーマットは、ヘッダ名ごとに定義されています。それは、常にTEXT-UTF8オクテットの不透明なシーケンス、または空白文字、トークン、セパレーター、および引用符で囲まれた文字列の組み合わせのいずれかになります。多くの既存のヘッダフィールドは、パラメータ名、パラメータ値のペアのセミコロン分離シーケンスに続く値の一般的な形に付着します。"
    },
    {
      "indent": 9,
      "text": "field-name: field-value *(;parameter-name=parameter-value)",
      "ja": "フィールド名：フィールド値*（;パラメータ名=パラメータ値）"
    },
    {
      "indent": 3,
      "text": "Even though an arbitrary number of parameter pairs may be attached to a header field value, any given parameter-name MUST NOT appear more than once.",
      "ja": "パラメータペアの任意の数のヘッダフィールド値に取り付けることができるにもかかわらず、任意のパラメータ名が複数回現れてはいけません。"
    },
    {
      "indent": 3,
      "text": "When comparing header fields, field names are always case-insensitive. Unless otherwise stated in the definition of a particular header field, field values, parameter names, and parameter values are case-insensitive. Tokens are always case-insensitive. Unless specified otherwise, values expressed as quoted strings are case-sensitive. For example,",
      "ja": "ヘッダフィールドを比較する場合、フィールド名は常に大文字と小文字を区別しません。そうでなければ特定のヘッダフィールドの定義において言及されない限り、フィールドの値、パラメータ名およびパラメータ値は大文字と小文字を区別しません。トークンは、常に大文字と小文字を区別しません。特に指定しない限り、引用符で囲まれた文字列として表現値は、大文字と小文字が区別されます。例えば、"
    },
    {
      "indent": 6,
      "text": "Contact: <sip:alice@atlanta.com>;expires=3600",
      "ja": "連絡先：<SIP：alice@atlanta.comは>; = 3600期限が切れます"
    },
    {
      "indent": 3,
      "text": "is equivalent to",
      "ja": "に相当します"
    },
    {
      "indent": 6,
      "text": "CONTACT: <sip:alice@atlanta.com>;ExPiReS=3600",
      "ja": "CONTACT：<SIP：alice@atlanta.comは>; = 3600期限が切れます"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "Content-Disposition: session;handling=optional",
      "ja": "コンテンツディスポジション：セッション;ハンドリング=オプション"
    },
    {
      "indent": 3,
      "text": "is equivalent to",
      "ja": "に相当します"
    },
    {
      "indent": 6,
      "text": "content-disposition: Session;HANDLING=OPTIONAL",
      "ja": "コンテンツ-処分：セッション;取扱い= OPTIONAL"
    },
    {
      "indent": 3,
      "text": "The following two header fields are not equivalent:",
      "ja": "次の2つのヘッダフィールドは等価ではありません。"
    },
    {
      "indent": 6,
      "text": "Warning: 370 devnull \"Choose a bigger pipe\" Warning: 370 devnull \"CHOOSE A BIGGER PIPE\"",
      "ja": "警告：370 devnull警告 \"大きなパイプを選択し、\"：370 devnullは \"BIGGER PIPEを選択してください\""
    },
    {
      "indent": 0,
      "text": "7.3.2 Header Field Classification",
      "section_title": true,
      "ja": "7.3.2ヘッダーフィールドの分類"
    },
    {
      "indent": 3,
      "text": "Some header fields only make sense in requests or responses. These are called request header fields and response header fields, respectively. If a header field appears in a message not matching its category (such as a request header field in a response), it MUST be ignored. Section 20 defines the classification of each header field.",
      "ja": "いくつかのヘッダフィールドは要求または応答で意味をなします。これらは、それぞれ、リクエストヘッダフィールドとレスポンスヘッダフィールドと呼ばれます。ヘッダフィールドは、（このような応答のリクエストヘッダフィールドのように）そのカテゴリに一致しないメッセージに表示される場合、それは無視しなければなりません。セクション20は、各ヘッダフィールドの分類を定義します。"
    },
    {
      "indent": 0,
      "text": "7.3.3 Compact Form",
      "section_title": true,
      "ja": "7.3.3コンパクトなフォーム"
    },
    {
      "indent": 3,
      "text": "SIP provides a mechanism to represent common header field names in an abbreviated form. This may be useful when messages would otherwise become too large to be carried on the transport available to it (exceeding the maximum transmission unit (MTU) when using UDP, for example). These compact forms are defined in Section 20. A compact form MAY be substituted for the longer form of a header field name at any time without changing the semantics of the message. A header field name MAY appear in both long and short forms within the same message. Implementations MUST accept both the long and short forms of each header name.",
      "ja": "SIPは、省略形で共通ヘッダフィールド名を表すためのメカニズムを提供します。メッセージは、そうでなければ（例えば、UDPを使用した場合の最大伝送単位（MTU）を超える）、それに利用可能なトランスポート上で搬送するには大きすぎるとなる場合に有用であり得ます。これらのコンパクト形はコンパクトな形式は、メッセージの意味を変えることなく、いつでもヘッダフィールド名の長い形態の代わりに用いてもよい項20に定義されています。ヘッダフィールド名は、同じメッセージ内の長いおよび短い形態の両方に表示されることがあります。実装は、各ヘッダ名の長いおよび短い形態の両方を受け入れなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.4 Bodies",
      "section_title": true,
      "ja": "7.4機関"
    },
    {
      "indent": 3,
      "text": "Requests, including new requests defined in extensions to this specification, MAY contain message bodies unless otherwise noted. The interpretation of the body depends on the request method.",
      "ja": "特に断りのない限り、この仕様の拡張で定義された新しい要求を含む要求は、メッセージ本文を含むかもしれません。体の解釈はリクエストメソッドに依存します。"
    },
    {
      "indent": 3,
      "text": "For response messages, the request method and the response status code determine the type and interpretation of any message body. All responses MAY include a body.",
      "ja": "応答メッセージは、要求メソッドとレスポンスステータスコードは、任意のメッセージ本体の種類及び解釈を決定します。すべての応答が体を含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.4.1 Message Body Type",
      "section_title": true,
      "ja": "7.4.1メッセージ本文のタイプ"
    },
    {
      "indent": 3,
      "text": "The Internet media type of the message body MUST be given by the Content-Type header field. If the body has undergone any encoding such as compression, then this MUST be indicated by the Content-Encoding header field; otherwise, Content-Encoding MUST be omitted. If applicable, the character set of the message body is indicated as part of the Content-Type header-field value.",
      "ja": "メッセージボディのインターネットメディアタイプは、Content-Typeヘッダフィールドによって与えられなければなりません。本体は、圧縮等の任意の符号化が施された場合、これは、Content-Encodingヘッダーフィールドによって示さなければなりません。そうでない場合は、コンテンツのエンコーディングを省略しなければなりません。該当する場合、メッセージ本文の文字セットは、コンテンツタイプヘッダフィールド値の一部として示されています。"
    },
    {
      "indent": 3,
      "text": "The \"multipart\" MIME type defined in RFC 2046 [11] MAY be used within the body of the message. Implementations that send requests containing multipart message bodies MUST send a session description as a non-multipart message body if the remote implementation requests this through an Accept header field that does not contain multipart.",
      "ja": "RFC 2046 [11]で定義された「マルチパート」のMIMEタイプは、メッセージの本文内で使用することができます。マルチパートメッセージ本体を含む要求を送信する実装は、非マルチパートメッセージボディとしてセッション記述を送信する必要がある場合、マルチパートを含まないAcceptヘッダーフィールドを介してリモート実装リクエストこの。"
    },
    {
      "indent": 3,
      "text": "SIP messages MAY contain binary bodies or body parts. When no explicit charset parameter is provided by the sender, media subtypes of the \"text\" type are defined to have a default charset value of \"UTF-8\".",
      "ja": "SIPメッセージはバイナリのボディまたは車体部品を含むかもしれません。明示的なcharsetパラメータが送信者によって提供されていない場合は、「テキスト」タイプのメディアサブタイプは、「UTF-8」のデフォルトの文字セット値を持つように定義されています。"
    },
    {
      "indent": 0,
      "text": "7.4.2 Message Body Length",
      "section_title": true,
      "ja": "7.4.2メッセージ本文の長さ"
    },
    {
      "indent": 3,
      "text": "The body length in bytes is provided by the Content-Length header field. Section 20.14 describes the necessary contents of this header field in detail.",
      "ja": "バイト単位の本体の長さはContent-Lengthヘッダフィールドによって提供されます。セクション20.14は、詳細に、このヘッダフィールドの必要な内容を記載しています。"
    },
    {
      "indent": 3,
      "text": "The \"chunked\" transfer encoding of HTTP/1.1 MUST NOT be used for SIP. (Note: The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator.)",
      "ja": "HTTP / 1.1の転送符号化がSIPのために使用してはいけません「チャンク」。 （注：チャンクエンコーディングはそれぞれ独自のサイズインジケータと、一連のチャンクとして転送するためにメッセージの本文を修正します。）"
    },
    {
      "indent": 0,
      "text": "7.5 Framing SIP Messages",
      "section_title": true,
      "ja": "7.5フレーミングSIPメッセージ"
    },
    {
      "indent": 3,
      "text": "Unlike HTTP, SIP implementations can use UDP or other unreliable datagram protocols. Each such datagram carries one request or response. See Section 18 on constraints on usage of unreliable transports.",
      "ja": "HTTPとは異なり、SIPの実装はUDPまたは他の信頼性のないデータグラムプロトコルを使用することができます。このような各データグラムは、一つの要求または応答を搬送します。信頼性の低いトランスポートの使用上の制約上、セクション18を参照してください。"
    },
    {
      "indent": 3,
      "text": "Implementations processing SIP messages over stream-oriented transports MUST ignore any CRLF appearing before the start-line [H4.1].",
      "ja": "ストリーム指向のトランスポート上でSIPメッセージを処理する実装は、スタートライン[H4.1]の前に現れるいかなるCRLFを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Content-Length header field value is used to locate the end of each SIP message in a stream. It will always be present when SIP messages are sent over stream-oriented transports.",
      "ja": "Content-Lengthヘッダフィールド値は、ストリーム中の各SIPメッセージの終わりを見つけるために使用されます。 SIPメッセージはストリーム指向のトランスポートを介して送信されるときには常に存在することになります。"
    },
    {
      "indent": 0,
      "text": "8 General User Agent Behavior",
      "ja": "8一般的なユーザーエージェントの動作"
    },
    {
      "indent": 3,
      "text": "A user agent represents an end system. It contains a user agent client (UAC), which generates requests, and a user agent server (UAS), which responds to them. A UAC is capable of generating a request based on some external stimulus (the user clicking a button, or a signal on a PSTN line) and processing a response. A UAS is capable of receiving a request and generating a response based on user input, external stimulus, the result of a program execution, or some other mechanism.",
      "ja": "ユーザエージェントは、エンドシステムを表します。それはそれらに応答要求を生成し、ユーザエージェントクライアント（UAC）、およびユーザエージェントサーバ（UAS）を、含まれています。 UACは、いくつかの外部刺激（ボタンをクリックするユーザ、またはPSTN回線上の信号）に基づいて要求を生成し、応答を処理することができます。 UASは、要求を受信し、ユーザ入力、外部刺激、プログラムの実行、またはいくつかの他のメカニズムの結果に基づいて応答を生成することができます。"
    },
    {
      "indent": 3,
      "text": "When a UAC sends a request, the request passes through some number of proxy servers, which forward the request towards the UAS. When the UAS generates a response, the response is forwarded towards the UAC.",
      "ja": "UACが要求を送信すると、要求はUASに向けて要求を転送するプロキシサーバ、いくつかの数を通過します。 UASは応答を生成するとき、応答がUACに向けて転送されます。"
    },
    {
      "indent": 3,
      "text": "UAC and UAS procedures depend strongly on two factors. First, based on whether the request or response is inside or outside of a dialog, and second, based on the method of a request. Dialogs are discussed thoroughly in Section 12; they represent a peer-to-peer relationship between user agents and are established by specific SIP methods, such as INVITE.",
      "ja": "UACとUASの手順は、2つの要因に強く依存しています。まず、要求または応答は、要求の方法に基づいて、内部またはダイアログの外側、及び第二であるかどうかに基づきます。ダイアログは、セクション12で徹底的に議論されています。それらは、ユーザエージェント間のピアツーピアの関係を表し、例えば、INVITEのような特定のSIPメソッドによって確立されます。"
    },
    {
      "indent": 3,
      "text": "In this section, we discuss the method-independent rules for UAC and UAS behavior when processing requests that are outside of a dialog. This includes, of course, the requests which themselves establish a dialog.",
      "ja": "ダイアログの外にある要求を処理するとき、この節では、UACとUAS行動のための方法に依存しないルールを議論します。これは、当然のことながら、自身がダイアログを確立するリクエストを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Security procedures for requests and responses outside of a dialog are described in Section 26. Specifically, mechanisms exist for the UAS and UAC to mutually authenticate. A limited set of privacy features are also supported through encryption of bodies using S/MIME.",
      "ja": "ダイアログ外のリクエストとレスポンスのためのセキュリティ手順は、具体的に、セクション26で説明されている、メカニズムが相互に認証するためにUASとUACのために存在します。プライバシー機能の限定されたセットもS / MIMEを使用したボディの暗号化によってサポートされています。"
    },
    {
      "indent": 0,
      "text": "8.1 UAC Behavior",
      "section_title": true,
      "ja": "8.1 UACの動作"
    },
    {
      "indent": 3,
      "text": "This section covers UAC behavior outside of a dialog.",
      "ja": "このセクションでは、ダイアログボックスの外にUACの動作をカバーしています。"
    },
    {
      "indent": 0,
      "text": "8.1.1 Generating the Request",
      "section_title": true,
      "ja": "8.1.1リクエストの生成"
    },
    {
      "indent": 3,
      "text": "A valid SIP request formulated by a UAC MUST, at a minimum, contain the following header fields: To, From, CSeq, Call-ID, Max-Forwards, and Via; all of these header fields are mandatory in all SIP requests. These six header fields are the fundamental building blocks of a SIP message, as they jointly provide for most of the critical message routing services including the addressing of messages, the routing of responses, limiting message propagation, ordering of messages, and the unique identification of transactions. These header fields are in addition to the mandatory request line, which contains the method, Request-URI, and SIP version.",
      "ja": "UACにより処方の有効なSIP要求は、最低限、次のヘッダフィールドを含まなければならない：TO、のCSeq、コールID、最大転送し、ビア、から。これらのヘッダーフィールドのすべては、すべてのSIPリクエストに必須です。彼らは共同で、メッセージのアドレス指定などのサービスをルーティングする重要なメッセージ、応答のルーティング、メッセージの伝播を制限し、メッセージの順序、との一意の識別のほとんどを提供するように、これらの6つのヘッダーフィールドは、SIPメッセージの基本的なビルディングブロックです取引。これらのヘッダーフィールドは、メソッド、要求URI、およびSIPバージョンを含む必須の要求ラインに加えています。"
    },
    {
      "indent": 3,
      "text": "Examples of requests sent outside of a dialog include an INVITE to establish a session (Section 13) and an OPTIONS to query for capabilities (Section 11).",
      "ja": "ダイアログの外に送信されたリクエストの例としては、機能（第11節）を照会するために、セッション（第13節）とOPTIONSを確立するためにINVITE含まれています。"
    },
    {
      "indent": 0,
      "text": "8.1.1.1 Request-URI",
      "section_title": true,
      "ja": "8.1.1.1要求URI"
    },
    {
      "indent": 3,
      "text": "The initial Request-URI of the message SHOULD be set to the value of the URI in the To field. One notable exception is the REGISTER method; behavior for setting the Request-URI of REGISTER is given in Section 10. It may also be undesirable for privacy reasons or convenience to set these fields to the same value (especially if the originating UA expects that the Request-URI will be changed during transit).",
      "ja": "メッセージの最初のRequest-URIは、フィールドにURIの値に設定する必要があります。一つの注目すべき例外は、REGISTERメソッドです。 REGISTERのリクエストURIを設定するための動作は、セクション10に与えられる。また、プライバシー上の理由または発信UAがRequest-URIが通過中に変更されることを期待する場合は特に、同じ値（これらのフィールドを設定するための便宜のために望ましくないことがあります）。"
    },
    {
      "indent": 3,
      "text": "In some special circumstances, the presence of a pre-existing route set can affect the Request-URI of the message. A pre-existing route set is an ordered set of URIs that identify a chain of servers, to which a UAC will send outgoing requests that are outside of a dialog. Commonly, they are configured on the UA by a user or service provider manually, or through some other non-SIP mechanism. When a provider wishes to configure a UA with an outbound proxy, it is RECOMMENDED that this be done by providing it with a pre-existing route set with a single URI, that of the outbound proxy.",
      "ja": "いくつかの特別な状況では、既存のルートセットの存在は、メッセージのRequest-URIに影響を与えることができます。既存のルートセットは、UACダイアログの外にあるの発信要求を送信する先のサーバのチェーンを、特定のURIの順序集合です。一般に、それらは、手動でユーザまたはサービスプロバイダによってUAに設定さ、またはいくつかの他の非SIP機構を介しています。プロバイダがアウトバウンドプロキシとUAを設定したい場合、単一のURIと設定既存の経路とアウトバウンドプロキシとそれを提供することによって行われることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "When a pre-existing route set is present, the procedures for populating the Request-URI and Route header field detailed in Section 12.2.1.1 MUST be followed (even though there is no dialog), using the desired Request-URI as the remote target URI.",
      "ja": "既存のルートセットが存在する場合、セクション12.2.1.1に詳述のRequest-URIとRouteヘッダーフィールドを埋めるための手順は、リモートターゲットとして所望のRequest-URIを使用して、（ないダイアログが存在しなくても）、続いてなければなりませんURI。"
    },
    {
      "indent": 0,
      "text": "8.1.1.2 To",
      "section_title": true,
      "ja": "８。１。１。２ と"
    },
    {
      "indent": 3,
      "text": "The To header field first and foremost specifies the desired \"logical\" recipient of the request, or the address-of-record of the user or resource that is the target of this request. This may or may not be the ultimate recipient of the request. The To header field MAY contain a SIP or SIPS URI, but it may also make use of other URI schemes (the tel URL (RFC 2806 [9]), for example) when appropriate. All SIP implementations MUST support the SIP URI scheme. Any implementation that supports TLS MUST support the SIPS URI scheme. The To header field allows for a display name.",
      "ja": "最初のフィールドをヘッダーと最前要求の所望の「論理的」受信者、またはこの要求の対象となるユーザまたはリソースのアドレス・オブ・レコードを特定します。これは、またはリクエストの最終的な受信者であってもなくてもよいです。 Toヘッダフィールドは、SIPを含むまたはURI SIPS、それはまた、他のURIスキームを使用する場合があり（TELのURL（RFC 2806 [9]）、など）適切な場合。すべてのSIP実装はSIP URIスキームをサポートしなければなりません。 TLSをサポートするすべての実装は、SIPS URIスキームをサポートしなければなりません。 Toヘッダフィールドには、表示名が可能になります。"
    },
    {
      "indent": 3,
      "text": "A UAC may learn how to populate the To header field for a particular request in a number of ways. Usually the user will suggest the To header field through a human interface, perhaps inputting the URI manually or selecting it from some sort of address book. Frequently, the user will not enter a complete URI, but rather a string of digits or letters (for example, \"bob\"). It is at the discretion of the UA to choose how to interpret this input. Using the string to form the user part of a SIP URI implies that the UA wishes the name to be resolved in the domain to the right-hand side (RHS) of the at-sign in the SIP URI (for instance, sip:bob@example.com). Using the string to form the user part of a SIPS URI implies that the UA wishes to communicate securely, and that the name is to be resolved in the domain to the RHS of the at-sign. The RHS will frequently be the home domain of the requestor, which allows for the home domain to process the outgoing request. This is useful for features like \"speed dial\" that require interpretation of the user part in the home domain. The tel URL may be used when the UA does not wish to specify the domain that should interpret a telephone number that has been input by the user. Rather, each domain through which the request passes would be given that opportunity. As an example, a user in an airport might log in and send requests through an outbound proxy in the airport. If they enter \"411\" (this is the phone number for local directory assistance in the United States), that needs to be interpreted and processed by the outbound proxy in the airport, not the user's home domain. In this case, tel:411 would be the right choice.",
      "ja": "UACは、多くの方法で特定の要求のためのフィールドをヘッダーには移入する方法を学ぶことができます。通常、ユーザーは、おそらく手動でURIを入力するか、アドレス帳のいくつかの並べ替えからそれを選択し、ヒューマンインタフェースを介しToヘッダーフィールドに提案します。多くの場合、ユーザーは完全なURIではなく、数字や文字の文字列（例えば、「ボブ」）を入力しないでしょう。これは、この入力を解釈する方法を選択するためにUAの裁量です。ボブ：SIP URIのユーザ部分を形成するために、文字列を使用すると、UAは、AT-SIGN例えばSIP URIで（SIPの右側（RHS）のドメインに解決する名前を望んでいることを意味します@ example.com）。 SIPS URIのユーザ部分を形成するために、文字列を使用すると、UAは、安全に通信したいことを意味し、名前は、サインのRHSにドメインに解決されるべきであること。 RHSは、頻繁に発信要求を処理するために、ホームドメインを可能にし、要求元のホームドメインになります。これは、ホームドメイン内のユーザー部分の解釈を必要とする「スピードダイヤル」のような機能のために有用です。 UAは、ユーザによって入力された電話番号を解釈すべきドメインを指定したくないときのtel URLを使用することができます。むしろ、リクエストが通過する各ドメインは、その機会を与えられるであろう。例として、空港内のユーザーがログイン可能性があり、空港でのアウトバウンドプロキシ経由でリクエストを送信します。彼らは「411」と入力した場合は、空港ではなく、ユーザーのホームドメインにアウトバウンドプロキシによって解釈して処理する必要がある、（これは、米国のローカルディレクトリの支援のための電話番号です）。この場合は、TEL：411は正しい選択だろう。"
    },
    {
      "indent": 3,
      "text": "A request outside of a dialog MUST NOT contain a To tag; the tag in the To field of a request identifies the peer of the dialog. Since no dialog is established, no tag is present.",
      "ja": "ダイアログ外のリクエストは、タグに含まれていてはなりません。リクエストのToフィールド内のタグは、ダイアログのピアを特定します。何のダイアログが確立されていないので、何のタグが存在しません。"
    },
    {
      "indent": 3,
      "text": "For further information on the To header field, see Section 20.39. The following is an example of a valid To header field:",
      "ja": "Toヘッダーフィールドの詳細については、セクション20.39を参照してください。次のフィールドをヘッダへの有効な一例です。"
    },
    {
      "indent": 6,
      "text": "To: Carol <sip:carol@chicago.com>",
      "ja": "To：キャロル<SIP：carol@chicago.com>"
    },
    {
      "indent": 0,
      "text": "8.1.1.3 From",
      "section_title": true,
      "ja": "8.1.1.3から"
    },
    {
      "indent": 3,
      "text": "The From header field indicates the logical identity of the initiator of the request, possibly the user's address-of-record. Like the To header field, it contains a URI and optionally a display name. It is used by SIP elements to determine which processing rules to apply to a request (for example, automatic call rejection). As such, it is very important that the From URI not contain IP addresses or the FQDN of the host on which the UA is running, since these are not logical names.",
      "ja": "Fromヘッダフィールドは、リクエストのイニシエータ、おそらくユーザーのアドレス・オブ・レコードの論理IDを示します。 Toヘッダフィールドのように、それは、URIおよび必要に応じて表示名を含みます。 （例えば、自動着信拒否のために）要求に適用する処理ルールを決定するためにSIP要素によって使用されます。このように、これらの論理名ではありませんので、URIから、IPアドレスまたはUAが実行されているホストのFQDNが含まれていないことが非常に重要です。"
    },
    {
      "indent": 3,
      "text": "The From header field allows for a display name. A UAC SHOULD use the display name \"Anonymous\", along with a syntactically correct, but otherwise meaningless URI (like sip:thisis@anonymous.invalid), if the identity of the client is to remain hidden.",
      "ja": "Fromヘッダフィールドの表示名が可能になります。クライアントのアイデンティティが隠されたままにしておく場合は、：UACは構文的に正しいが、それ以外は無意味URI（thisis@anonymous.invalid SIPのような）と一緒に、表示名「匿名」を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Usually, the value that populates the From header field in requests generated by a particular UA is pre-provisioned by the user or by the administrators of the user's local domain. If a particular UA is used by multiple users, it might have switchable profiles that include a URI corresponding to the identity of the profiled user. Recipients of requests can authenticate the originator of a request in order to ascertain that they are who their From header field claims they are (see Section 22 for more on authentication).",
      "ja": "通常、特定のUAによって生成されたリクエストのヘッダフィールドから移入した値は、ユーザによって、またはユーザのローカルドメインの管理者が事前にプロビジョニングされています。特定のUAが複数のユーザーによって使用されている場合は、プロファイルユーザのアイデンティティに対応するURIが含ま切り替えプロファイルを持っているかもしれません。リクエストの受信者は、彼らが（認証の詳細については、セクション22を参照）している人、そのヘッダフィールドからの請求であることを確認するために、要求の発信元を認証することができます。"
    },
    {
      "indent": 3,
      "text": "The From field MUST contain a new \"tag\" parameter, chosen by the UAC. See Section 19.3 for details on choosing a tag.",
      "ja": "FromフィールドUACが選択した新しい「タグ」のパラメータを含んでいなければなりません。タグの選択の詳細については、セクション19.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "For further information on the From header field, see Section 20.20. Examples:",
      "ja": "Fromヘッダーフィールドの詳細については、セクション20.20を参照してください。例："
    },
    {
      "indent": 6,
      "text": "From: \"Bob\" <sips:bob@biloxi.com> ;tag=a48s From: sip:+12125551212@phone2net.com;tag=887s From: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8",
      "ja": "From： \"ボブ\" <一口：bob@biloxi.com>;タグ=からa48s：SIP：+12125551212@phone2net.com;タグ= 887sから：匿名<SIP：c8oqz84zk7z@privacy.org>;タグ= hyh8"
    },
    {
      "indent": 0,
      "text": "8.1.1.4 Call-ID",
      "section_title": true,
      "ja": "8.1.1.4コールID"
    },
    {
      "indent": 3,
      "text": "The Call-ID header field acts as a unique identifier to group together a series of messages. It MUST be the same for all requests and responses sent by either UA in a dialog. It SHOULD be the same in each registration from a UA.",
      "ja": "Call-IDヘッダーフィールドは、一緒にグループに固有の識別子一連のメッセージとして働きます。これは、ダイアログのいずれかでUAによって送信されたすべての要求と応答で同じでなければなりません。これは、UAからの各登録で同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "In a new request created by a UAC outside of any dialog, the Call-ID header field MUST be selected by the UAC as a globally unique identifier over space and time unless overridden by method-specific behavior. All SIP UAs must have a means to guarantee that the Call-ID header fields they produce will not be inadvertently generated by any other UA. Note that when requests are retried after certain failure responses that solicit an amendment to a request (for example, a challenge for authentication), these retried requests are not considered new requests, and therefore do not need new Call-ID header fields; see Section 8.1.3.5.",
      "ja": "メソッド固有の動作によって上書きされない限り、任意のダイアログの外側UACによって作成された新しい要求に、コールIDヘッダフィールドは、空間と時間をかけてグローバル一意識別子としてUACによって選択されなければなりません。すべてのSIP UAは、彼らが作るのCall-IDヘッダフィールドが誤って他のUAによって生成されないことを保証する手段を持っている必要があります。要求が（例えば、認証のための挑戦）要求の改正を求める特定の障害応答の後に再試行されている場合、これらの再試行要求は、新たな要求とは見なされないので、新しいコール-IDヘッダーフィールドを必要としないことに注意してください。セクション8.1.3.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "Use of cryptographically random identifiers (RFC 1750 [12]) in the generation of Call-IDs is RECOMMENDED. Implementations MAY use the form \"localid@host\". Call-IDs are case-sensitive and are simply compared byte-by-byte.",
      "ja": "コールIDの生成に暗号ランダム識別子（RFC 1750 [12]）の使用が推奨されます。実装は、フォーム「LOCALIDの@ホスト」を使用するかもしれません。コールIDは大文字と小文字が区別され、単純にバイトごとに比較されています。"
    },
    {
      "indent": 6,
      "text": "Using cryptographically random identifiers provides some protection against session hijacking and reduces the likelihood of unintentional Call-ID collisions.",
      "ja": "暗号的にランダムな識別子を使用すると、セッションハイジャックに対するいくつかの保護を提供し、意図しないコール-IDの衝突の可能性を低下させます。"
    },
    {
      "indent": 3,
      "text": "No provisioning or human interface is required for the selection of the Call-ID header field value for a request.",
      "ja": "いいえプロビジョニングまたはヒューマンインタフェースを要求するためのコールIDヘッダフィールド値の選択のために必要とされません。"
    },
    {
      "indent": 3,
      "text": "For further information on the Call-ID header field, see Section 20.8.",
      "ja": "Call-IDヘッダーフィールドの詳細については、セクション20.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com",
      "ja": "コールID：f81d4fae-7dec-11d0-a765-00a0c91e6bf6@foo.bar.com"
    },
    {
      "indent": 0,
      "text": "8.1.1.5 CSeq",
      "section_title": true,
      "ja": "8.1.1.5のCSeq"
    },
    {
      "indent": 3,
      "text": "The CSeq header field serves as a way to identify and order transactions. It consists of a sequence number and a method. The method MUST match that of the request. For non-REGISTER requests outside of a dialog, the sequence number value is arbitrary. The sequence number value MUST be expressible as a 32-bit unsigned integer and MUST be less than 2**31. As long as it follows the above guidelines, a client may use any mechanism it would like to select CSeq header field values.",
      "ja": "CSeqヘッダーフィールドは、トランザクションを識別し、注文する方法として役立ちます。これは、シーケンス番号とメソッドで構成されています。この方法は、要求のものと一致しなければなりません。ダイアログの外側非REGISTER要求のために、シーケンス番号値は任意です。シーケンス番号値は、32ビットの符号なし整数として表現可能でなければなりませんと** 31 2未満でなければなりません。であれば上記のガイドラインを以下のように、クライアントはCSeqヘッダーフィールド値を選択したい任意の機構を使用することができます。"
    },
    {
      "indent": 3,
      "text": "Section 12.2.1.1 discusses construction of the CSeq for requests within a dialog.",
      "ja": "セクション12.2.1.1は、ダイアログ内のリクエストのためのCSeqの構築について説明します。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "CSeq: 4711 INVITE",
      "ja": "CSeq：4711 INVITE"
    },
    {
      "indent": 0,
      "text": "8.1.1.6 Max-Forwards",
      "section_title": true,
      "ja": "8.1.1.6マックス・フォワード"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards header field serves to limit the number of hops a request can transit on the way to its destination. It consists of an integer that is decremented by one at each hop. If the Max-Forwards value reaches 0 before the request reaches its destination, it will be rejected with a 483(Too Many Hops) error response.",
      "ja": "最大Forwardsヘッダフィールドは、ホップ数の目的地までの途中で要求することができ通過を制限するのに役立ちます。これは、各ホップで1ずつデクリメントされる整数から成ります。マックス・フォワード値が0になった場合は、要求が宛先に到達する前に、それは483（ホップ数が多すぎ）エラー応答で拒否されます。"
    },
    {
      "indent": 3,
      "text": "A UAC MUST insert a Max-Forwards header field into each request it originates with a value that SHOULD be 70. This number was chosen to be sufficiently large to guarantee that a request would not be dropped in any SIP network when there were no loops, but not so large as to consume proxy resources when a loop does occur. Lower values should be used with caution and only in networks where topologies are known by the UA.",
      "ja": "UACは、それがこの数は何ループが存在しない場合、要求は、任意のSIPネットワークにドロップされないことを保証するのに十分に大きくなるように選択した70であるべき値で発信リクエストごとにMax-Forwardsヘッダーフィールドを挿入しなければなりませんしかし、ループが発生したときにプロキシリソースを消費するほど大きくはありません。低い値は慎重にのみトポロジがUAによって知られているネットワークで使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "8.1.1.7 Via",
      "section_title": true,
      "ja": "8.1.1.7経由"
    },
    {
      "indent": 3,
      "text": "The Via header field indicates the transport used for the transaction and identifies the location where the response is to be sent. A Via header field value is added only after the transport that will be used to reach the next hop has been selected (which may involve the usage of the procedures in [4]).",
      "ja": "Viaヘッダフィールドは、トランザクションのために使用されるトランスポートを示し、応答が送信される場所を特定します。 Viaヘッダフィールド値のみネクストホップに到達するために使用されるトランスポートの後に追加される（[4]の手順の使用を伴うことがある）が選択されています。"
    },
    {
      "indent": 3,
      "text": "When the UAC creates a request, it MUST insert a Via into that request. The protocol name and protocol version in the header field MUST be SIP and 2.0, respectively. The Via header field value MUST contain a branch parameter. This parameter is used to identify the transaction created by that request. This parameter is used by both the client and the server.",
      "ja": "UACが要求を作成すると、その要求に経由を挿入しなければなりません。ヘッダフィールドにプロトコル名とプロトコルバージョンは、それぞれ、SIPおよび2.0でなければなりません。 Viaヘッダーフィールド値は、分岐パラメータを含まなければなりません。このパラメータは、その要求によって作成されたトランザクションを識別するために使用されます。このパラメータは、クライアントとサーバーの両方で使用されています。"
    },
    {
      "indent": 3,
      "text": "The branch parameter value MUST be unique across space and time for all requests sent by the UA. The exceptions to this rule are CANCEL and ACK for non-2xx responses. As discussed below, a CANCEL request will have the same value of the branch parameter as the request it cancels. As discussed in Section 17.1.1.3, an ACK for a non-2xx response will also have the same branch ID as the INVITE whose response it acknowledges.",
      "ja": "分岐パラメータ値はUAによって送信されたすべての要求のための空間と時間で一意である必要があります。この規則の例外は2xx以外の応答のためにキャンセルとACKです。以下に述べるように、CANCELリクエストは、それが取り消し要求として分岐パラメータの同じ値を持つことになります。セクション17.1.1.3で述べたように、非2xxの応答のためのACKはまた、その応答それが認めINVITEと同じbranch IDを持つことになります。"
    },
    {
      "indent": 6,
      "text": "The uniqueness property of the branch ID parameter, to facilitate its use as a transaction ID, was not part of RFC 2543.",
      "ja": "分岐IDパラメータの一意性プロパティは、トランザクションIDとしての使用を容易にするため、RFC 2543の一部ではありませんでした。"
    },
    {
      "indent": 3,
      "text": "The branch ID inserted by an element compliant with this specification MUST always begin with the characters \"z9hG4bK\". These 7 characters are used as a magic cookie (7 is deemed sufficient to ensure that an older RFC 2543 implementation would not pick such a value), so that servers receiving the request can determine that the branch ID was constructed in the fashion described by this specification (that is, globally unique). Beyond this requirement, the precise format of the branch token is implementation-defined.",
      "ja": "この仕様に準拠した要素が挿入された分岐IDは常に文字「z9hG4bK」で始まる必要があります。要求を受けたサーバは、分岐IDがこれに記載の様式で構築されたと判断することができるように、これらの7つの文字は、マジッククッキー（7古いRFC 2543の実装は、そのような値を選択しないことを保証するのに十分であると考えられる）として使用されています仕様（つまり、グローバルに一意です）。この要件を超えて、分岐トークンの正確なフォーマットは実装定義です。"
    },
    {
      "indent": 3,
      "text": "The Via header maddr, ttl, and sent-by components will be set when the request is processed by the transport layer (Section 18).",
      "ja": "ViaヘッダーMADDR、TTL、および送信されたバイコンポーネント要求は、トランスポート層（第18）によって処理されるときに設定されます。"
    },
    {
      "indent": 3,
      "text": "Via processing for proxies is described in Section 16.6 Item 8 and Section 16.7 Item 3.",
      "ja": "プロキシの処理を介して、第16.6項8及び第16.7項3に記載されています。"
    },
    {
      "indent": 0,
      "text": "8.1.1.8 Contact",
      "section_title": true,
      "ja": "8.1.1.8連絡先"
    },
    {
      "indent": 3,
      "text": "The Contact header field provides a SIP or SIPS URI that can be used to contact that specific instance of the UA for subsequent requests. The Contact header field MUST be present and contain exactly one SIP or SIPS URI in any request that can result in the establishment of a dialog. For the methods defined in this specification, that includes only the INVITE request. For these requests, the scope of the Contact is global. That is, the Contact header field value contains the URI at which the UA would like to receive requests, and this URI MUST be valid even if used in subsequent requests outside of any dialogs.",
      "ja": "Contactヘッダーフィールドは、SIPを提供するか、後続の要求のためのUAの特定のインスタンスに接続するために使用することができるURIをSIPS。 Contactヘッダフィールドが存在し、正確に一つのSIPを含むまたはダイアログの確立をもたらすことができる任意の要求にURIをSIPSしなければなりません。本明細書で定義されたメソッドのために、それだけで、INVITE要求を含みます。これらの要求のために、連絡先のスコープはグローバルです。すなわち、Contactヘッダーフィールド値はUAが要求を受信したい、このURIは、任意のダイアログの外側後続のリクエストで使用される場合にも有効でなければならないでURIが含まれています。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI or top Route header field value contains a SIPS URI, the Contact header field MUST contain a SIPS URI as well.",
      "ja": "要求URIまたはトップRouteヘッダーフィールド値がSIPS URIが含まれている場合は、Contactヘッダーフィールドも同様にSIPS URIを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "For further information on the Contact header field, see Section 20.10.",
      "ja": "Contactヘッダーフィールドの詳細については、セクション20.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.1.1.9 Supported and Require",
      "section_title": true,
      "ja": "8.1.1.9はサポートされていると必要"
    },
    {
      "indent": 3,
      "text": "If the UAC supports extensions to SIP that can be applied by the server to the response, the UAC SHOULD include a Supported header field in the request listing the option tags (Section 19.2) for those extensions.",
      "ja": "UACが応答にサーバーによって適用することができSIPへの拡張をサポートしている場合、UACは、これらの拡張のためのオプションタグ（セクション19.2）をリストアップ要求でサポートされているヘッダフィールドを含むべきです。"
    },
    {
      "indent": 3,
      "text": "The option tags listed MUST only refer to extensions defined in standards-track RFCs. This is to prevent servers from insisting that clients implement non-standard, vendor-defined features in order to receive service. Extensions defined by experimental and informational RFCs are explicitly excluded from usage with the Supported header field in a request, since they too are often used to document vendor-defined extensions.",
      "ja": "記載されているオプションタグは標準トラックRFCで定義された拡張子を参照する必要があります。これは、クライアントがサービスを受けるために、非標準、ベンダー定義の機能を実装することを主張からサーバーを防ぐためです。彼らはあまりにも多くの場合、ベンダー定義の拡張機能を文書化するために使用されているので、実験および情報のRFCで定義された拡張機能は、明示的に、リクエストにSupportedヘッダーフィールドでの使用から除外されています。"
    },
    {
      "indent": 3,
      "text": "If the UAC wishes to insist that a UAS understand an extension that the UAC will apply to the request in order to process the request, it MUST insert a Require header field into the request listing the option tag for that extension. If the UAC wishes to apply an extension to the request and insist that any proxies that are traversed understand that extension, it MUST insert a Proxy-Require header field into the request listing the option tag for that extension.",
      "ja": "UACは、UASはUACが要求を処理するために、要求に適用されること拡張子を理解していることを主張したい場合は、その拡張のためのオプションタグをリストリクエストにRequireヘッダーフィールドを挿入しなければなりません。 UACは、リクエストに拡張を適用し、横断されているすべてのプロキシは、その拡張子を理解していることを主張したい場合は、その拡張のためのオプションタグをリスト要求にプロキシ-Requireヘッダーフィールドを挿入しなければなりません。"
    },
    {
      "indent": 3,
      "text": "As with the Supported header field, the option tags in the Require and Proxy-Require header fields MUST only refer to extensions defined in standards-track RFCs.",
      "ja": "Supportedヘッダーフィールドと同じように、必要とプロキシ-Requireヘッダーフィールドのオプションタグは標準トラックRFCで定義された拡張子を参照する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.1.10 Additional Message Components",
      "section_title": true,
      "ja": "8.1.1.10追加のメッセージコンポーネント"
    },
    {
      "indent": 3,
      "text": "After a new request has been created, and the header fields described above have been properly constructed, any additional optional header fields are added, as are any header fields specific to the method.",
      "ja": "新しいリクエストが作成され、上述したヘッダフィールドが正しく構築された後、方法に固有のヘッダフィールドがそうであるように、任意の追加のオプションのヘッダーフィールドは、追加されます。"
    },
    {
      "indent": 3,
      "text": "SIP requests MAY contain a MIME-encoded message-body. Regardless of the type of body that a request contains, certain header fields must be formulated to characterize the contents of the body. For further information on these header fields, see Sections 20.11 through 20.15.",
      "ja": "SIPリクエストは、MIMEエンコードされたメッセージボディを含むかもしれません。かかわらず、要求に含まれる本体のタイプの、特定のヘッダフィールドは、本体の内容を特徴付けるために製剤化されなければなりません。これらのヘッダーフィールドの詳細については、セクション20.15スルー20.11を参照。"
    },
    {
      "indent": 0,
      "text": "8.1.2 Sending the Request",
      "section_title": true,
      "ja": "8.1.2リクエストの送信"
    },
    {
      "indent": 3,
      "text": "The destination for the request is then computed. Unless there is local policy specifying otherwise, the destination MUST be determined by applying the DNS procedures described in [4] as follows. If the first element in the route set indicated a strict router (resulting in forming the request as described in Section 12.2.1.1), the procedures MUST be applied to the Request-URI of the request. Otherwise, the procedures are applied to the first Route header field value in the request (if one exists), or to the request's Request-URI if there is no Route header field present. These procedures yield an ordered set of address, port, and transports to attempt. Independent of which URI is used as input to the procedures of [4], if the Request-URI specifies a SIPS resource, the UAC MUST follow the procedures of [4] as if the input URI were a SIPS URI.",
      "ja": "要求の宛先が計算されます。そうでなければ特定のローカルポリシーがない限り、先は次のように[4]に記載のDNS手順を適用することによって決定されなければなりません。ルートセット内の最初の要素は（セクション12.2.1.1に記載されるように要求を形成する際に得られた）厳密ルータを示した場合、手続きは、Request-URI要求に適用されなければなりません。 NOルートヘッダーフィールドが存在しない場合はそれ以外の場合、手順は、または要求のリクエストURIへの要求内の最初のRouteヘッダフィールド値（存在する場合）に適用されます。これらの手順は、アドレス、ポートの順序集合を得て、試みることに搬送します。 URIは、Request-URIがSIPSリソースを指定する場合、入力URIがSIPS URIであるかのように、UACは、[4]の手順に従わなければならない、[4]の手順への入力として使用される独立れました。"
    },
    {
      "indent": 3,
      "text": "Local policy MAY specify an alternate set of destinations to attempt. If the Request-URI contains a SIPS URI, any alternate destinations MUST be contacted with TLS. Beyond that, there are no restrictions on the alternate destinations if the request contains no Route header field. This provides a simple alternative to a pre-existing route set as a way to specify an outbound proxy. However, that approach for configuring an outbound proxy is NOT RECOMMENDED; a pre-existing route set with a single URI SHOULD be used instead. If the request contains a Route header field, the request SHOULD be sent to the locations derived from its topmost value, but MAY be sent to any server that the UA is certain will honor the Route and Request-URI policies specified in this document (as opposed to those in RFC 2543). In particular, a UAC configured with an outbound proxy SHOULD",
      "ja": "ローカルポリシーは、試行する送信先の別のセットを指定するかもしれません。リクエスト-URIがSIPS URIが含まれている場合は、いずれかの代替の目的地は、TLSと接触させなければなりません。要求は一切Routeヘッダーフィールドが含まれていない場合はそれを超えて、別の目的地に制限はありません。これは、アウトバウンドプロキシを指定する方法として、既存のルートセットへの単純な代替手段を提供します。しかし、アウトバウンドプロキシを設定するためのそのアプローチは推奨されません。単一のURIと設定既存のルートが代わりに使用されるべきです。リクエストがRouteヘッダーフィールドが含まれている場合、要求は、その最上位の値に由来する場所に送られるべきであるが、UAは、特定の任意のサーバに送信されるかもしれこの文書で指定された経路とRequest-URIのポリシーを尊重する（AS RFC 2543）のものに反対しました。特に、UACは、アウトバウンドプロキシとすべきである構成します"
    },
    {
      "indent": 3,
      "text": "attempt to send the request to the location indicated in the first Route header field value instead of adopting the policy of sending all messages to the outbound proxy.",
      "ja": "代わりに、アウトバウンドプロキシにすべてのメッセージを送信する方針を採用した最初のRouteヘッダフィールド値で示される場所に要求を送信することを試みます。"
    },
    {
      "indent": 6,
      "text": "This ensures that outbound proxies that do not add Record-Route header field values will drop out of the path of subsequent requests. It allows endpoints that cannot resolve the first Route URI to delegate that task to an outbound proxy.",
      "ja": "これはRecord-Routeヘッダーフィールド値を追加しないアウトバウンドプロキシが後続の要求のパスから脱落することを保証します。これは、最初のルートURIを解決できないエンドポイントは、アウトバウンドプロキシにそのタスクを委任することができます。"
    },
    {
      "indent": 3,
      "text": "The UAC SHOULD follow the procedures defined in [4] for stateful elements, trying each address until a server is contacted. Each try constitutes a new transaction, and therefore each carries a different topmost Via header field value with a new branch parameter. Furthermore, the transport value in the Via header field is set to whatever transport was determined for the target server.",
      "ja": "サーバに接続されるまで、UACは、各アドレスを試し、ステートフル要素について[4]で定義された手順に従うべきです。それぞれが新しいトランザクションを構成し、したがって、それぞれが新たな分岐パラメータでヘッダフィールド値のVia異なる最上位を運ぶしてみてください。また、Viaヘッダフィールドの輸送値は、ターゲットサーバについて決定したどのようなトランスポートに設定されています。"
    },
    {
      "indent": 0,
      "text": "8.1.3 Processing Responses",
      "section_title": true,
      "ja": "8.1.3処理の応答"
    },
    {
      "indent": 3,
      "text": "Responses are first processed by the transport layer and then passed up to the transaction layer. The transaction layer performs its processing and then passes the response up to the TU. The majority of response processing in the TU is method specific. However, there are some general behaviors independent of the method.",
      "ja": "応答は、最初のトランスポート層で処理された後、トランザクション層まで渡されます。トランザクション層は、その処理を実行し、TUまでの応答を渡します。 TUにおける応答処理の大部分は、方法特異的です。しかし、この方法の独立したいくつかの一般的な行動があります。"
    },
    {
      "indent": 0,
      "text": "8.1.3.1 Transaction Layer Errors",
      "section_title": true,
      "ja": "8.1.3.1トランザクションレイヤエラー"
    },
    {
      "indent": 3,
      "text": "In some cases, the response returned by the transaction layer will not be a SIP message, but rather a transaction layer error. When a timeout error is received from the transaction layer, it MUST be treated as if a 408 (Request Timeout) status code has been received. If a fatal transport error is reported by the transport layer (generally, due to fatal ICMP errors in UDP or connection failures in TCP), the condition MUST be treated as a 503 (Service Unavailable) status code.",
      "ja": "いくつかのケースでは、トランザクション層によって返される応答は、SIPメッセージではなく、トランザクション層のエラーではありません。タイムアウトエラーがトランザクション層から受信されたとき、それは408（要求タイムアウト）ステータスコードが受信されたかのように扱われなければなりません。致命的な搬送誤差をトランスポート層によって報告された場合（一般に、原因TCPにおけるUDPまたは接続不良に致命的なICMPエラーに）、条件は503（サービス利用不可）ステータスコードとして扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.3.2 Unrecognized Responses",
      "section_title": true,
      "ja": "8.1.3.2認識できない応答"
    },
    {
      "indent": 3,
      "text": "A UAC MUST treat any final response it does not recognize as being equivalent to the x00 response code of that class, and MUST be able to process the x00 response code for all classes. For example, if a UAC receives an unrecognized response code of 431, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 (Bad Request) response code. A UAC MUST treat any provisional response different than 100 that it does not recognize as 183 (Session Progress). A UAC MUST be able to process 100 and 183 responses.",
      "ja": "UACは、そのクラスのX00の応答コードと等価であると認識されない任意の最終的な応答を扱わなければなりません、そして、すべてのクラスのX00の応答コードを処理できなければなりません。たとえば、UACが431の認識できない応答コードを受信した場合、それは安全にその要求に何か問題があったと仮定することができますし、それは400（悪いRequest）応答コードを受け取ったかのように応答を扱います。 UACは、それが183（セッションの進捗状況）として認識していないことを100とは異なる任意の暫定応答を扱わなければなりません。 UACは100と183の応答を処理できなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.3.3 Vias",
      "section_title": true,
      "ja": "8.1.3.3ルート"
    },
    {
      "indent": 3,
      "text": "If more than one Via header field value is present in a response, the UAC SHOULD discard the message.",
      "ja": "複数のViaヘッダフィールド値がレスポンス内に存在する場合、UACは、メッセージを破棄すべきです。"
    },
    {
      "indent": 6,
      "text": "The presence of additional Via header field values that precede the originator of the request suggests that the message was misrouted or possibly corrupted.",
      "ja": "要求の発信元に先行する追加のViaヘッダフィールド値の存在は、メッセージが誤ってルーティングまたはおそらく破損したことを示唆しています。"
    },
    {
      "indent": 0,
      "text": "8.1.3.4 Processing 3xx Responses",
      "section_title": true,
      "ja": "8.1.3.4処理3xx応答"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a redirection response (for example, a 301 response status code), clients SHOULD use the URI(s) in the Contact header field to formulate one or more new requests based on the redirected request. This process is similar to that of a proxy recursing on a 3xx class response as detailed in Sections 16.5 and 16.6. A client starts with an initial target set containing exactly one URI, the Request-URI of the original request. If a client wishes to formulate new requests based on a 3xx class response to that request, it places the URIs to try into the target set. Subject to the restrictions in this specification, a client can choose which Contact URIs it places into the target set. As with proxy recursion, a client processing 3xx class responses MUST NOT add any given URI to the target set more than once. If the original request had a SIPS URI in the Request-URI, the client MAY choose to recurse to a non-SIPS URI, but SHOULD inform the user of the redirection to an insecure URI.",
      "ja": "リダイレクト応答（例えば、301応答ステータスコード）を受信すると、クライアントは、リダイレクトされた要求に基づいて、1つまたは複数の新しい要求を定式化するContactヘッダフィールド内のURI（複数可）を使用すべきです。このプロセスは、セクション16.5及び16.6に詳述するように3xxクラス応答に再帰プロキシと同様です。クライアントは、1つのURI、オリジナルリクエストのRequest-URIを含む初期の目標を設定して起動します。クライアントがそのリクエストに3xxクラスの応答に基づいて、新しい要求を策定することを希望する場合は、ターゲット・セットにしようとするURIを置きます。この仕様で制限を受ける、クライアントは、それが設定した目標に置いている連絡先のURIを選択することができます。プロキシ再帰と同じように、クライアント処理の3xxクラスの応答が複数回設定された目標に任意のURIを追加してはなりません。元の要求がRequest-URIにSIPS URIを持っていた場合、クライアントは非SIPS URIに再帰することを選択するかもしれないが、安全でないURIへのリダイレクトをユーザーに通知する必要があります。"
    },
    {
      "indent": 6,
      "text": "Any new request may receive 3xx responses themselves containing the original URI as a contact. Two locations can be configured to redirect to each other. Placing any given URI in the target set only once prevents infinite redirection loops.",
      "ja": "すべての新しい要求は、自身が連絡先として、元のURIを含む3xx応答を受け取ることができます。二つの位置は、相互にリダイレクトするように構成することができます。一度だけ設定した目標に任意のURIを置くことは、無限のリダイレクトループを防止します。"
    },
    {
      "indent": 3,
      "text": "As the target set grows, the client MAY generate new requests to the URIs in any order. A common mechanism is to order the set by the \"q\" parameter value from the Contact header field value. Requests to the URIs MAY be generated serially or in parallel. One approach is to process groups of decreasing q-values serially and process the URIs in each q-value group in parallel. Another is to perform only serial processing in decreasing q-value order, arbitrarily choosing between contacts of equal q-value.",
      "ja": "ターゲットセットが大きくなると、クライアントは任意の順序でのURIへの新しい要求を生成してもよいです。一般的なメカニズムは、Contactヘッダーフィールド値から「Q」パラメータ値によってセットを注文することです。 URIへの要求は、直列または並列に生成することができます。一つのアプローチは、直列Q値を減少させるのグループを処理し、並列に各Q値グループ内のURIを処理することです。別の任意等しいQ値の接点間の選択、q値の順にだけシリアル処理を実行することです。"
    },
    {
      "indent": 3,
      "text": "If contacting an address in the list results in a failure, as defined in the next paragraph, the element moves to the next address in the list, until the list is exhausted. If the list is exhausted, then the request has failed.",
      "ja": "リストが使い果たされるまで、次の段落で定義されるように、故障中のリスト結果のアドレスを接触させる場合、要素は、リスト内の次のアドレスに移動します。リストが使い果たされている場合は、要求が失敗しました。"
    },
    {
      "indent": 3,
      "text": "Failures SHOULD be detected through failure response codes (codes greater than 399); for network errors the client transaction will report any transport layer failures to the transaction user. Note that some response codes (detailed in 8.1.3.5) indicate that the request can be retried; requests that are reattempted should not be considered failures.",
      "ja": "失敗は失敗応答コード（399より大きいコード）を介して検出されるべきです。ネットワークエラーのためにクライアントトランザクションは、トランザクションのユーザーに任意のトランスポート層の障害を報告します。 （8.1.3.5に詳述）、いくつかの応答コードが要求を再試行することができることを示していることに留意されたいです。再試行されている要求は失敗とみなされるべきではありません。"
    },
    {
      "indent": 3,
      "text": "When a failure for a particular contact address is received, the client SHOULD try the next contact address. This will involve creating a new client transaction to deliver a new request.",
      "ja": "特定の連絡先アドレスのための失敗が受信されると、クライアントは、次の連絡先アドレスを試してみてください。これは、新しい要求を実現するために、新しいクライアントトランザクションを作成が含まれます。"
    },
    {
      "indent": 3,
      "text": "In order to create a request based on a contact address in a 3xx response, a UAC MUST copy the entire URI from the target set into the Request-URI, except for the \"method-param\" and \"header\" URI parameters (see Section 19.1.1 for a definition of these parameters). It uses the \"header\" parameters to create header field values for the new request, overwriting header field values associated with the redirected request in accordance with the guidelines in Section 19.1.5.",
      "ja": "3xx応答のコンタクトアドレスに基づいて要求を作成するために、UACは、「メソッドPARAM」および「ヘッダ」URIパラメータを除いて、リクエストURIに設定された目標からの全体のURIをコピーする必要があり（セクションこれらのパラメータの定義については、19.1.1）。これは、セクション19.1.5のガイドラインに従い、リダイレクトされたリクエストに関連したヘッダフィールドの値を上書きし、新しいリクエストのヘッダーフィールド値を作成するには、「ヘッダ」パラメータを使用しています。"
    },
    {
      "indent": 3,
      "text": "Note that in some instances, header fields that have been communicated in the contact address may instead append to existing request header fields in the original redirected request. As a general rule, if the header field can accept a comma-separated list of values, then the new header field value MAY be appended to any existing values in the original redirected request. If the header field does not accept multiple values, the value in the original redirected request MAY be overwritten by the header field value communicated in the contact address. For example, if a contact address is returned with the following value:",
      "ja": "いくつかの例では、連絡先に通知されたヘッダフィールドではなく、元のリダイレクトされた要求の既存のリクエストヘッダフィールドに追加してもよいことに留意されたいです。ヘッダフィールドは、値のカンマ区切りリストを受け入れることができれば、原則として、新しいヘッダフィールドの値は、元のリダイレクトされた要求内の既存の値に付加することができます。ヘッダフィールドが複数の値を受け入れない場合、元のリダイレクトされた要求の値は、連絡先で通信ヘッダフィールド値によって上書きされるかもしれません。たとえば、連絡先アドレスは、次の値で返された場合："
    },
    {
      "indent": 6,
      "text": "sip:user@host?Subject=foo&Call-Info=<http://www.foo.com>",
      "ja": "SIP：？ユーザー@ホスト件名= FOO＆コール情報= <http://www.foo.com>"
    },
    {
      "indent": 3,
      "text": "Then any Subject header field in the original redirected request is overwritten, but the HTTP URL is merely appended to any existing Call-Info header field values.",
      "ja": "その後、元のリダイレクト要求で任意の件名ヘッダフィールドは上書きされますが、HTTPのURLは、単に既存のCall-Infoヘッダーフィールド値に追加されます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the UAC reuse the same To, From, and Call-ID used in the original redirected request, but the UAC MAY also choose to update the Call-ID header field value for new requests, for example.",
      "ja": "UACから、同じへの再利用、およびオリジナルのリダイレクト要求で使用-IDを呼び出しますが、UACはまた、例えば、新しい要求のためのCall-IDヘッダフィールドの値を更新することを選択するかもしれないことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Finally, once the new request has been constructed, it is sent using a new client transaction, and therefore MUST have a new branch ID in the top Via field as discussed in Section 8.1.1.7.",
      "ja": "最後に、新しい要求が構築された後、それは新しいクライアントトランザクションを使用して送信されるため、セクション8.1.1.7で述べたように、フィールドを経由して、トップで新しいブランチIDを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "In all other respects, requests sent upon receipt of a redirect response SHOULD re-use the header fields and bodies of the original request.",
      "ja": "他のすべての点において、リダイレクト応答の受信時に送信された要求は、元の要求のヘッダフィールドとボディを再使用すべきです。"
    },
    {
      "indent": 3,
      "text": "In some instances, Contact header field values may be cached at UAC temporarily or permanently depending on the status code received and the presence of an expiration interval; see Sections 21.3.2 and 21.3.3.",
      "ja": "いくつかの例では、Contactヘッダーフィールドの値は、ステータスコード受信及び期限切れ間隔の有無に応じて一時的または恒久的にUACにキャッシュすることができます。セクション21.3.2および21.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.1.3.5 Processing 4xx Responses",
      "section_title": true,
      "ja": "8.1.3.5処理の4xx応答"
    },
    {
      "indent": 3,
      "text": "Certain 4xx response codes require specific UA processing, independent of the method.",
      "ja": "特定の4XX応答コードは、方法の独立した特定のUA処理を必要とします。"
    },
    {
      "indent": 3,
      "text": "If a 401 (Unauthorized) or 407 (Proxy Authentication Required) response is received, the UAC SHOULD follow the authorization procedures of Section 22.2 and Section 22.3 to retry the request with credentials.",
      "ja": "401（不正な）または407（プロキシ認証が必要）応答を受信した場合、UACは、資格情報を使用して要求を再試行するために、セクション22.2およびセクション22.3の認可手順に従うべきです。"
    },
    {
      "indent": 3,
      "text": "If a 413 (Request Entity Too Large) response is received (Section 21.4.11), the request contained a body that was longer than the UAS was willing to accept. If possible, the UAC SHOULD retry the request, either omitting the body or using one of a smaller length.",
      "ja": "413（リクエストエンティティが大きすぎます）応答は（セクション21.4.11）を受信した場合、要求は長いUASが受け入れようとした以外だった体を含んでいました。可能な場合、UACは、いずれかの体を省略したり、短い長さのいずれかを使用して、要求を再試行すべきです。"
    },
    {
      "indent": 3,
      "text": "If a 415 (Unsupported Media Type) response is received (Section 21.4.13), the request contained media types not supported by the UAS. The UAC SHOULD retry sending the request, this time only using content with types listed in the Accept header field in the response, with encodings listed in the Accept-Encoding header field in the response, and with languages listed in the Accept-Language in the response.",
      "ja": "415（サポートされていないメディアタイプ）応答は（セクション21.4.13）を受信した場合、要求はUASによってサポートされていないメディアタイプを含んでいました。 UACは、応答して受け入れエンコードをヘッダフィールドにリストされた符号化と、およびで受け入れ言語に記載されている言語と、応答してAcceptヘッダーフィールドにリストされたタイプのコンテンツを使用して、要求を送信し、この時間を再試行すべきです応答。"
    },
    {
      "indent": 3,
      "text": "If a 416 (Unsupported URI Scheme) response is received (Section 21.4.14), the Request-URI used a URI scheme not supported by the server. The client SHOULD retry the request, this time, using a SIP URI.",
      "ja": "416（サポートされていないURIスキーム）応答（セクション21.4.14）を受信した場合、リクエストURIは、サーバでサポートされていないURIスキームを使用します。クライアントは、SIP URIを使用して、この時間は、要求を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a 420 (Bad Extension) response is received (Section 21.4.15), the request contained a Require or Proxy-Require header field listing an option-tag for a feature not supported by a proxy or UAS. The UAC SHOULD retry the request, this time omitting any extensions listed in the Unsupported header field in the response.",
      "ja": "420（悪い拡張）応答は（セクション21.4.15）を受信した場合、要求は、プロキシまたはUASによってサポートされていない機能のオプションタグをリスト要求またはプロキシ要求ヘッダーフィールドを含んでいました。 UACは、この時間は、応答してサポートされていないヘッダーフィールドにリストされた任意の拡張子を省略し、要求を再試行すべきです。"
    },
    {
      "indent": 3,
      "text": "In all of the above cases, the request is retried by creating a new request with the appropriate modifications. This new request constitutes a new transaction and SHOULD have the same value of the Call-ID, To, and From of the previous request, but the CSeq should contain a new sequence number that is one higher than the previous.",
      "ja": "上記の場合の全てにおいて、要求は、適切な変更を加えて新たな要求を作成することによって再試行されます。この新しい要求は、新しいトランザクションを構成しに、コール-IDの同じ値を持つべきであり、前の要求のから、しかしのCSeqは前回よりも1つ大きくなり、新たなシーケンス番号が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "With other 4xx responses, including those yet to be defined, a retry may or may not be possible depending on the method and the use case.",
      "ja": "まだ定義されるものを含む他の4XX応答と、再試行がまたはメソッドとユースケースによっては可能であってもなくてもよいです。"
    },
    {
      "indent": 0,
      "text": "8.2 UAS Behavior",
      "section_title": true,
      "ja": "8.2行動"
    },
    {
      "indent": 3,
      "text": "When a request outside of a dialog is processed by a UAS, there is a set of processing rules that are followed, independent of the method. Section 12 gives guidance on how a UAS can tell whether a request is inside or outside of a dialog.",
      "ja": "ダイアログの外部要求がUASによって処理されると、方法とは無関係に追跡される処理規則のセットがあります。第12節は、UASはリクエストがダイアログの内部または外部にあるかを知ることができる方法に関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Note that request processing is atomic. If a request is accepted, all state changes associated with it MUST be performed. If it is rejected, all state changes MUST NOT be performed.",
      "ja": "要求処理がアトミックであることに留意されたいです。要求が受け入れられた場合、それに関連するすべての状態の変化を実行しなければなりません。それは却下された場合、すべての状態の変更が行われてはなりません。"
    },
    {
      "indent": 3,
      "text": "UASs SHOULD process the requests in the order of the steps that follow in this section (that is, starting with authentication, then inspecting the method, the header fields, and so on throughout the remainder of this section).",
      "ja": "UASは、このセクション（すなわち、ヘッダ・フィールドは、検査方法次に、認証始まるなど、このセクションの残りの部分全体）に次の手順のために要求を処理しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.1 Method Inspection",
      "section_title": true,
      "ja": "8.2.1メソッドの検査"
    },
    {
      "indent": 3,
      "text": "Once a request is authenticated (or authentication is skipped), the UAS MUST inspect the method of the request. If the UAS recognizes but does not support the method of a request, it MUST generate a 405 (Method Not Allowed) response. Procedures for generating responses are described in Section 8.2.6. The UAS MUST also add an Allow header field to the 405 (Method Not Allowed) response. The Allow header field MUST list the set of methods supported by the UAS generating the message. The Allow header field is presented in Section 20.5.",
      "ja": "要求が認証される（または認証がスキップされる）と、UASはリクエストのメソッドを検査しなければなりません。 UASは認識するが、要求の方法をサポートしていない場合、それは405（メソッド許可されていません）レスポンスを生成しなければなりません。応答を生成するための手順は、セクション8.2.6で説明されています。 UASはまた、405（方法不可）応答することを可能にするヘッダフィールドを追加しなければなりません。許可ヘッダフィールドは、メッセージを生成するUASによってサポートされるメソッドのセットをリストする必要があります。 Allowヘッダーフィールドは、セクション20.5に示されています。"
    },
    {
      "indent": 3,
      "text": "If the method is one supported by the server, processing continues.",
      "ja": "この方法は、サーバでサポートされているものである場合、処理が継続されます。"
    },
    {
      "indent": 0,
      "text": "8.2.2 Header Inspection",
      "section_title": true,
      "ja": "8.2.2ヘッダーの検査"
    },
    {
      "indent": 3,
      "text": "If a UAS does not understand a header field in a request (that is, the header field is not defined in this specification or in any supported extension), the server MUST ignore that header field and continue processing the message. A UAS SHOULD ignore any malformed header fields that are not necessary for processing requests.",
      "ja": "UASは、リクエストのヘッダフィールドを理解していない場合（つまり、ヘッダフィールドは、サポートされている任意の拡張子本明細書中でまたはで定義されていない）、サーバは、そのヘッダーフィールドを無視して、メッセージの処理を継続しなければなりません。 UASは、処理要求のために必要ではない任意の不正な形式のヘッダフィールドを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2.2.1 To and Request-URI",
      "section_title": true,
      "ja": "8.2.2.1へとRequest-URI"
    },
    {
      "indent": 3,
      "text": "The To header field identifies the original recipient of the request designated by the user identified in the From field. The original recipient may or may not be the UAS processing the request, due to call forwarding or other proxy operations. A UAS MAY apply any policy it wishes to determine whether to accept requests when the To header field is not the identity of the UAS. However, it is RECOMMENDED that a UAS accept requests even if they do not recognize the URI scheme (for example, a tel: URI) in the To header field, or if the To header field does not address a known or current user of this UAS. If, on the other hand, the UAS decides to reject the request, it SHOULD generate a response with a 403 (Forbidden) status code and pass it to the server transaction for transmission.",
      "ja": "Toヘッダフィールドは、フィールドから識別されたユーザにより指定された要求の元の受信者を識別する。元の受信者または転送または他のプロキシオペレーションを呼び出すことにより、要求を処理するUAS、あってもなくてもよいです。 UASは、ToヘッダーフィールドはUASのIDでないときの要求を受け入れるかどうかを決定することを希望するすべてのポリシーを適用することができます。しかし、それらはURIスキームを認識しない場合でも、UASは要求を受け入れることが推奨される（例えば、TEL：URI）Toヘッダーフィールドで、またはToヘッダーフィールドはこれを知られているか、現在のユーザーに対応していない場合UAS。一方、UASは要求を拒否することを決定した場合、それは403（禁止）ステータスコードで応答を生成及び送信するためのサーバートランザクションに渡すべきです。"
    },
    {
      "indent": 3,
      "text": "However, the Request-URI identifies the UAS that is to process the request. If the Request-URI uses a scheme not supported by the UAS, it SHOULD reject the request with a 416 (Unsupported URI Scheme) response. If the Request-URI does not identify an address that the UAS is willing to accept requests for, it SHOULD reject the request with a 404 (Not Found) response. Typically, a UA that uses the REGISTER method to bind its address-of-record to a specific contact address will see requests whose Request-URI equals that contact address. Other potential sources of received Request-URIs include the Contact header fields of requests and responses sent by the UA that establish or refresh dialogs.",
      "ja": "しかし、Request-URIがリクエストを処理するUASを特定します。要求URIが、UASがサポートしていないスキームを使用している場合、それは416（サポートされていないURIスキーム）応答でリクエストを拒否すべきです。要求URIがUASが要求を受け入れることを喜んでアドレスを識別しない場合、それは404（Not Found）応答でリクエストを拒否すべきです。一般的に、特定の連絡先にそのアドレスのレコードをバインドするためにREGISTERメソッドを使用していますUAは、その要求URIは、その連絡先アドレスに等しい要求が表示されます。受信した要求-URIの他の潜在的なソースは、要求と応答UAによって送ら確立またはリフレッシュダイアログのContactヘッダーフィールドを含みます。"
    },
    {
      "indent": 0,
      "text": "8.2.2.2 Merged Requests",
      "section_title": true,
      "ja": "8.2.2.2マージされた要求"
    },
    {
      "indent": 3,
      "text": "If the request has no tag in the To header field, the UAS core MUST check the request against ongoing transactions. If the From tag, Call-ID, and CSeq exactly match those associated with an ongoing transaction, but the request does not match that transaction (based on the matching rules in Section 17.2.3), the UAS core SHOULD generate a 482 (Loop Detected) response and pass it to the server transaction.",
      "ja": "リクエストがToヘッダーフィールドにはタグを持っていない場合、UASコアは、進行中のトランザクションに対する要求をチェックしなければなりません。タグから、-IDを呼び出しのCSeqが正確に進行中のトランザクションに関連付けられたものと一致するが、要求が（セクション17.2.3中のマッチングルールに基づいて）そのトランザクションと一致しない場合、UASコアは482（ループを生成する必要があります）応答を検出し、サーバートランザクションに渡します。"
    },
    {
      "indent": 6,
      "text": "The same request has arrived at the UAS more than once, following different paths, most likely due to forking. The UAS processes the first such request received and responds with a 482 (Loop Detected) to the rest of them.",
      "ja": "同じ要求が原因フォークに、異なるパス以下、複数回UASで最も可能性の高い到着しました。 UASは、最初のそのような要求を受信処理し、それらの残りの部分482（検出ループ）で応答します。"
    },
    {
      "indent": 0,
      "text": "8.2.2.3 Require",
      "section_title": true,
      "ja": "8.2.2.3が必要"
    },
    {
      "indent": 3,
      "text": "Assuming the UAS decides that it is the proper element to process the request, it examines the Require header field, if present.",
      "ja": "存在する場合UASは要求を処理するための適切な要素であると判断すると仮定すると、それは、必要とヘッダーフィールドを検査します。"
    },
    {
      "indent": 3,
      "text": "The Require header field is used by a UAC to tell a UAS about SIP extensions that the UAC expects the UAS to support in order to process the request properly. Its format is described in Section 20.32. If a UAS does not understand an option-tag listed in a Require header field, it MUST respond by generating a response with status code 420 (Bad Extension). The UAS MUST add an Unsupported header field, and list in it those options it does not understand amongst those in the Require header field of the request.",
      "ja": "Requireヘッダーフィールドは、UACがUASがリクエストを適切に処理するためにサポートすることを期待SIP拡張についてUASに伝えるためにUACによって使用されます。そのフォーマットは、セクション20.32に記載されています。 UAS必要なヘッダーフィールドにリストされたオプションタグを理解していない場合は、ステータスコード420（悪い拡張）との応答を生成することによって応答しなければなりません。 UASはそれにそれがリクエストのRequireヘッダーフィールドのものの中で理解していないこれらのオプションをサポートされていないヘッダフィールド、およびリストを追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that Require and Proxy-Require MUST NOT be used in a SIP CANCEL request, or in an ACK request sent for a non-2xx response. These header fields MUST be ignored if they are present in these requests.",
      "ja": "必要とプロキシ要求ノートはSIPで使用してはいけません要求、または非2XX応答を送信ACKリクエストにCANCEL。彼らはこれらの要求に存在している場合、これらのヘッダーフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An ACK request for a 2xx response MUST contain only those Require and Proxy-Require values that were present in the initial request.",
      "ja": "2xx応答のためにACK要求は、それらが必要とし、最初のリクエスト中に存在した値をプロキシは、要求のみを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "UAC->UAS: INVITE sip:watson@bell-telephone.com SIP/2.0 Require: 100rel",
      "ja": "UAC-> UAS：SIPのINVITE：watson@bell-telephone.com SIP / 2.0は必要：100relを"
    },
    {
      "indent": 6,
      "text": "UAS->UAC: SIP/2.0 420 Bad Extension Unsupported: 100rel",
      "ja": "UAS-> UAC：SIP / 2.0 420不正な拡張サポートされていない：100rel"
    },
    {
      "indent": 6,
      "text": "This behavior ensures that the client-server interaction will proceed without delay when all options are understood by both sides, and only slow down if options are not understood (as in the example above). For a well-matched client-server pair, the interaction proceeds quickly, saving a round-trip often required by negotiation mechanisms. In addition, it also removes ambiguity when the client requires features that the server does not understand. Some features, such as call handling fields, are only of interest to end systems.",
      "ja": "この現象は、すべてのオプションが両側に理解されている場合、クライアント - サーバ対話が遅滞なく進行することを確実にし、オプションが（上記の例のように）理解されていない場合にだけ遅く。よくマッチしたクライアント・サーバ・ペアの場合、相互作用は、多くの場合、交渉メカニズムによって必要なラウンドトリップを保存、すぐに進行します。クライアントがサーバが理解していない機能を必要とする場合に加えて、それはまた、あいまいさを取り除きます。そのようなコール処理場などの一部の機能は、専用システムを終了するには興味深いものです。"
    },
    {
      "indent": 0,
      "text": "8.2.3 Content Processing",
      "section_title": true,
      "ja": "8.2.3コンテンツ処理"
    },
    {
      "indent": 3,
      "text": "Assuming the UAS understands any extensions required by the client, the UAS examines the body of the message, and the header fields that describe it. If there are any bodies whose type (indicated by the Content-Type), language (indicated by the Content-Language) or encoding (indicated by the Content-Encoding) are not understood, and that body part is not optional (as indicated by the Content-Disposition header field), the UAS MUST reject the request with a 415 (Unsupported Media Type) response. The response MUST contain an Accept header field listing the types of all bodies it understands, in the event the request contained bodies of types not supported by the UAS. If the request contained content encodings not understood by the UAS, the response MUST contain an Accept-Encoding header field listing the encodings understood by the UAS. If the request contained content with languages not understood by the UAS, the response MUST contain an Accept-Language header field indicating the languages understood by the UAS. Beyond these checks, body handling depends on the method and type. For further information on the processing of content-specific header fields, see Section 7.4 as well as Section 20.11 through 20.15.",
      "ja": "UASは、クライアントによって要求される任意の拡張を理解すると仮定すると、UASはメッセージの本文を調べ、そしてそれを記述するヘッダフィールド。がそのタイプ（Content-Typeので示される）、言語（コンテンツ言語で示される）、または符号化（コンテンツエンコードによって示される）と理解されていない体であり、で示されるように、その本体部（オプションでない場合Content-Dispositionヘッダーフィールド）、UASは415（サポートされていないメディアタイプ）応答で要求を拒絶しなければなりません。応答は、それが理解し、すべての体のタイプをリストAcceptヘッダーフィールドを含まなければならない、イベントにリクエストがUASによってサポートされていないタイプのボディを含んでいました。要求はUASによって理解されていないコンテンツのエンコーディングが含まれていた場合、応答はUASによって理解エンコーディングをリストのAccept-Encodingヘッダフィールドを含まなければなりません。要求はUASによって理解されていない言語のコンテンツが含まれる場合、応答はUASによって理解される言語を示すのAccept-Languageヘッダーフィールドを含まなければなりません。これらのチェックを越えて、身体の取り扱い方法及び種類によって異なります。コンテンツ固有のヘッダフィールドの処理の詳細については、7.4節と同様に20.15を通る断面20.11を参照。"
    },
    {
      "indent": 0,
      "text": "8.2.4 Applying Extensions",
      "section_title": true,
      "ja": "8.2.4適用する拡張機能"
    },
    {
      "indent": 3,
      "text": "A UAS that wishes to apply some extension when generating the response MUST NOT do so unless support for that extension is indicated in the Supported header field in the request. If the desired extension is not supported, the server SHOULD rely only on baseline SIP and any other extensions supported by the client. In rare circumstances, where the server cannot process the request without the extension, the server MAY send a 421 (Extension Required) response. This response indicates that the proper response cannot be generated without support of a specific extension. The needed extension(s) MUST be included in a Require header field in the response. This behavior is NOT RECOMMENDED, as it will generally break interoperability.",
      "ja": "その拡張子のサポートが要求にSupportedヘッダーフィールドに示されない限り、応答を生成するときに、いくつかの拡張機能を適用することを希望するUASはそうはなりません。希望の拡張がサポートされていない場合、サーバーはベースラインSIPおよびクライアントでサポートされている任意の他の拡張機能にのみ頼るべきです。サーバは拡張せず、要求を処理できないまれな状況では、サーバ421（拡張必須）応答を送信することができます。この応答は、適切な応答は、特定の拡張子のサポートなしで生成することができないことを示しています。必要に応じて拡張（S）は応答要求ヘッダフィールドに含まれなければなりません。それは一般的に相互運用性を壊すので、この動作は、推奨されません。"
    },
    {
      "indent": 3,
      "text": "Any extensions applied to a non-421 response MUST be listed in a Require header field included in the response. Of course, the server MUST NOT apply extensions not listed in the Supported header field in the request. As a result of this, the Require header field in a response will only ever contain option tags defined in standards-track RFCs.",
      "ja": "非421応答に適用された拡張は、応答に含まれるRequireヘッダーフィールドにリストされなければなりません。もちろん、サーバは要求でサポートされているヘッダフィールドにリストされていない拡張子を適用してはなりません。その結果、応答におけるRequireヘッダーフィールドは今まで標準トラックRFCで定義されたオプションタグが含まれています。"
    },
    {
      "indent": 0,
      "text": "8.2.5 Processing the Request",
      "section_title": true,
      "ja": "8.2.5要求の処理"
    },
    {
      "indent": 3,
      "text": "Assuming all of the checks in the previous subsections are passed, the UAS processing becomes method-specific. Section 10 covers the REGISTER request, Section 11 covers the OPTIONS request, Section 13 covers the INVITE request, and Section 15 covers the BYE request.",
      "ja": "前のサブセクションにおけるすべてのチェックに合格していると仮定すると、UAS処理方法特異なります。セクション10は、セクション13は、INVITE要求をカバーし、セクション15は、BYE要求を覆う、REGISTER要求は、セクション11は、OPTIONS要求を覆うカバー。"
    },
    {
      "indent": 0,
      "text": "8.2.6 Generating the Response",
      "section_title": true,
      "ja": "8.2.6応答を生成します"
    },
    {
      "indent": 3,
      "text": "When a UAS wishes to construct a response to a request, it follows the general procedures detailed in the following subsections. Additional behaviors specific to the response code in question, which are not detailed in this section, may also be required.",
      "ja": "UASは、要求に対する応答を作成したい場合は、以下のサブセクションで詳述する一般的な手順に従います。このセクションで詳述されていない問題の応答コードに固有の追加の動作は、必要になることもあります。"
    },
    {
      "indent": 3,
      "text": "Once all procedures associated with the creation of a response have been completed, the UAS hands the response back to the server transaction from which it received the request.",
      "ja": "一度応答の作成に関連するすべての手続きが完了した、UASは、それが要求を受信し、そこからバックサーバートランザクションに応答を渡します。"
    },
    {
      "indent": 0,
      "text": "8.2.6.1 Sending a Provisional Response",
      "section_title": true,
      "ja": "8.2.6.1暫定応答を送信します"
    },
    {
      "indent": 3,
      "text": "One largely non-method-specific guideline for the generation of responses is that UASs SHOULD NOT issue a provisional response for a non-INVITE request. Rather, UASs SHOULD generate a final response to a non-INVITE request as soon as possible.",
      "ja": "応答を生成するための一つの大部分が非メソッド固有のガイドラインはのUASは非INVITEリクエストに対する暫定応答を発行してはならないことです。むしろ、のUASはできるだけ早く非INVITE要求に対する最終応答を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a 100 (Trying) response is generated, any Timestamp header field present in the request MUST be copied into this 100 (Trying) response. If there is a delay in generating the response, the UAS SHOULD add a delay value into the Timestamp value in the response. This value MUST contain the difference between the time of sending of the response and receipt of the request, measured in seconds.",
      "ja": "100（試行）応答が生成されると、リクエスト中に存在する任意のタイムスタンプヘッダフィールドは、この100（試行）応答にコピーされなければなりません。応答を生成する際に遅延がある場合、UASは応答のタイムスタンプ値に遅延値を追加する必要があります。この値は、秒単位で測定されたリクエストの応答と領収書の送信の時刻との差を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.6.2 Headers and Tags",
      "section_title": true,
      "ja": "8.2.6.2ヘッダーとタグ"
    },
    {
      "indent": 3,
      "text": "The From field of the response MUST equal the From header field of the request. The Call-ID header field of the response MUST equal the Call-ID header field of the request. The CSeq header field of the response MUST equal the CSeq field of the request. The Via header field values in the response MUST equal the Via header field values in the request and MUST maintain the same ordering.",
      "ja": "応答のフィールドからの要求のヘッダフィールドから等しくなければなりません。応答のコールIDヘッダフィールドは要求のCall-IDヘッダーフィールドに等しくなければなりません。応答のCSeqヘッダーフィールドは、リクエストのCSeqフィールドに等しくなければなりません。応答のViaヘッダフィールド値は要求のViaヘッダフィールド値を等しくなければならないし、同じ順序付けを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a request contained a To tag in the request, the To header field in the response MUST equal that of the request. However, if the To header field in the request did not contain a tag, the URI in the To header field in the response MUST equal the URI in the To header field; additionally, the UAS MUST add a tag to the To header field in the response (with the exception of the 100 (Trying) response, in which a tag MAY be present). This serves to identify the UAS that is responding, possibly resulting in a component of a dialog ID. The same tag MUST be used for all responses to that request, both final and provisional (again excepting the 100 (Trying)). Procedures for the generation of tags are defined in Section 19.3.",
      "ja": "要求が要求にタグに含まれている場合、応答のフィールドをヘッダへの要求のものと等しくなければなりません。要求のフィールドをヘッダーにタグを含んでいなかった場合は、応答のフィールドをヘッダにURIフィールドをヘッダにURIを等しくなければなりません。さらに、UASは、（タグが存在することができる、100（試行）応答を除いて）応答してヘッダーフィールドするにタグを追加しなければなりません。これは、おそらくはダイアログIDのコンポーネント、その結果、応答するUASを特定するのに役立ちます。同じタグが（再び（）100試行を除く）最終的な仮の両方その要求に対するすべての応答のために使用しなければなりません。タグを生成するための手順は、セクション19.3で定義されています。"
    },
    {
      "indent": 0,
      "text": "8.2.7 Stateless UAS Behavior",
      "section_title": true,
      "ja": "8.2.7ステートレスUASの動作"
    },
    {
      "indent": 3,
      "text": "A stateless UAS is a UAS that does not maintain transaction state. It replies to requests normally, but discards any state that would ordinarily be retained by a UAS after a response has been sent. If a stateless UAS receives a retransmission of a request, it regenerates the response and resends it, just as if it were replying to the first instance of the request. A UAS cannot be stateless unless the request processing for that method would always result in the same response if the requests are identical. This rules out stateless registrars, for example. Stateless UASs do not use a transaction layer; they receive requests directly from the transport layer and send responses directly to the transport layer.",
      "ja": "ステートレスUASはトランザクション状態を維持しないUASです。これは、通常の要求に応答するが、応答が送られた後、通常はUASによって保持されるすべての状態を破棄します。ステートレスUASは要求の再送信を受信した場合、それはリクエストの最初のインスタンスに応答したかのように、応答を再生成し、それを再送信します。リクエストが同一であれば、そのメソッドのリクエスト処理が常に同じ応答につながるしない限り、UASはステートレスすることはできません。これは、例えば、ステートレス登録機関を除外する。ステートレスのUASは、トランザクション層を使用しないでください。彼らは、トランスポート層から直接要求を受信し、トランスポート層に直接応答を送信します。"
    },
    {
      "indent": 3,
      "text": "The stateless UAS role is needed primarily to handle unauthenticated requests for which a challenge response is issued. If unauthenticated requests were handled statefully, then malicious floods of unauthenticated requests could create massive amounts of transaction state that might slow or completely halt call processing in a UAS, effectively creating a denial of service condition; for more information see Section 26.1.5.",
      "ja": "ステートレスUASの役割は、チャレンジ応答が発行された未認証の要求を処理するために主に必要とされています。認証されていない要求がステートフルに処理された場合は、未認証の要求の悪質な洪水が減速または完全に効果的にサービス拒否の状態を作成し、UASに呼処理を停止する可能性があるトランザクション状態を大量に作成することができます。詳細は項26.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The most important behaviors of a stateless UAS are the following:",
      "ja": "ステートレスUASの最も重要な行動は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "o A stateless UAS MUST NOT send provisional (1xx) responses.",
      "ja": "OステートレスUASは暫定（の1xx）応答を送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "o A stateless UAS MUST NOT retransmit responses.",
      "ja": "OステートレスUASは応答を再送してはなりません。"
    },
    {
      "indent": 6,
      "text": "o A stateless UAS MUST ignore ACK requests.",
      "ja": "OステートレスUASはACKリクエストを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "o A stateless UAS MUST ignore CANCEL requests.",
      "ja": "OステートレスUASはCANCELリクエストを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "o To header tags MUST be generated for responses in a stateless manner - in a manner that will generate the same tag for the same request consistently. For information on tag construction see Section 19.3.",
      "ja": "タグToヘッダoはステートレスな方法で応答するために生成しなければなりません - 一貫して同じ要求に対して同じタグを生成する方法で。タグ工事については、セクション19.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "In all other respects, a stateless UAS behaves in the same manner as a stateful UAS. A UAS can operate in either a stateful or stateless mode for each new request.",
      "ja": "他のすべての点において、ステートレスUASはステートフルUASと同様に振る舞います。 UASはそれぞれの新規リクエストに対して、ステートフルまたはステートレスモードのいずれかで動作することができます。"
    },
    {
      "indent": 0,
      "text": "8.3 Redirect Servers",
      "section_title": true,
      "ja": "8.3リダイレクトサーバー"
    },
    {
      "indent": 3,
      "text": "In some architectures it may be desirable to reduce the processing load on proxy servers that are responsible for routing requests, and improve signaling path robustness, by relying on redirection.",
      "ja": "いくつかのアーキテクチャでは、リダイレクションに依存することによって、ルーティングリクエストを担当しているプロキシサーバの処理負荷を低減し、シグナル伝達経路の堅牢性を向上させることが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "Redirection allows servers to push routing information for a request back in a response to the client, thereby taking themselves out of the loop of further messaging for this transaction while still aiding in locating the target of the request. When the originator of the request receives the redirection, it will send a new request based on the URI(s) it has received. By propagating URIs from the core of the network to its edges, redirection allows for considerable network scalability.",
      "ja": "リダイレクトは、まだ要求のターゲットを見つけるのを助けるしつつ、この取引のためにさらにメッセージングのループの外に自分自身を取って、サーバは、クライアントに応答して、要求のルーティング情報をプッシュすることができます。要求の発信元がリダイレクトを受信すると、それが受信したURI（複数可）に基づいて新しい要求を送信します。その縁にネットワークのコアからURIを伝播させることによって、リダイレクションはかなりのネットワークのスケーラビリティを可能にします。"
    },
    {
      "indent": 3,
      "text": "A redirect server is logically constituted of a server transaction layer and a transaction user that has access to a location service of some kind (see Section 10 for more on registrars and location services). This location service is effectively a database containing mappings between a single URI and a set of one or more alternative locations at which the target of that URI can be found.",
      "ja": "リダイレクトサーバーは、論理サーバートランザクション層及びある種のロケーションサービス（レジストラ及びロケーションサービスの詳細については、セクション10を参照）にアクセスしているトランザクション・ユーザーから構成されています。このロケーションサービスを効果的に単一のURIとそのURIのターゲットを見つけることができる1つまたは複数の代替ロケーションのセットとの間のマッピングを含むデータベースです。"
    },
    {
      "indent": 3,
      "text": "A redirect server does not issue any SIP requests of its own. After receiving a request other than CANCEL, the server either refuses the request or gathers the list of alternative locations from the location service and returns a final response of class 3xx. For well-formed CANCEL requests, it SHOULD return a 2xx response. This response ends the SIP transaction. The redirect server maintains transaction state for an entire SIP transaction. It is the responsibility of clients to detect forwarding loops between redirect servers.",
      "ja": "リダイレクトサーバーは、独自の任意のSIP要求を発行しません。 CANCEL以外のリクエストを受信した後、サーバは要求を拒否のいずれかまたは位置サービスから別の場所のリストを収集し、クラス3XXの最終的な応答を返します。 CANCEL整形リクエストの場合、それは2xx応答を返すべきです。この応答はSIPトランザクションを終了します。リダイレクトサーバーは全体のSIPトランザクションのためのトランザクション状態を維持しています。リダイレクトサーバー間で転送ループを検出するために、クライアントの責任です。"
    },
    {
      "indent": 3,
      "text": "When a redirect server returns a 3xx response to a request, it populates the list of (one or more) alternative locations into the Contact header field. An \"expires\" parameter to the Contact header field values may also be supplied to indicate the lifetime of the Contact data.",
      "ja": "リダイレクトサーバーは、要求に3xx応答を返す場合は、Contactヘッダフィールドに（一つ以上）の代替ロケーションのリストを移入します。 Contactヘッダーフィールド値にパラメータが、接触データの寿命を示すために供給することができる「満了します」。"
    },
    {
      "indent": 3,
      "text": "The Contact header field contains URIs giving the new locations or user names to try, or may simply specify additional transport parameters. A 301 (Moved Permanently) or 302 (Moved Temporarily) response may also give the same location and username that was targeted by the initial request but specify additional transport parameters such as a different server or multicast address to try, or a change of SIP transport from UDP to TCP or vice versa.",
      "ja": "ContactヘッダーフィールドはURIがしようとする新しい場所またはユーザー名を与える、または単に追加のトランスポートパラメータを指定することも含まれています。 （一時的に移動）、301（恒久的に移動）、または302応答はまた、最初の要求によって標的化されたのと同じ位置及びユーザ名を与えるが、そのような別のサーバーまたはマルチキャストアドレスしようとする、またはSIP輸送の変化などの追加のトランスポートパラメータを指定することができますUDPからTCPへ、またはその逆。"
    },
    {
      "indent": 3,
      "text": "However, redirect servers MUST NOT redirect a request to a URI equal to the one in the Request-URI; instead, provided that the URI does not point to itself, the server MAY proxy the request to the destination URI, or MAY reject it with a 404.",
      "ja": "しかし、サーバが要求URIの1に等しいURIに要求をリダイレクトしてはならないリダイレクト。代わりに、URIは、それ自体に、サーバーMAYプロキシ先に要求URIを指していない、又は404でそれを拒絶するかもしれないことに提供しました。"
    },
    {
      "indent": 6,
      "text": "If a client is using an outbound proxy, and that proxy actually redirects requests, a potential arises for infinite redirection loops.",
      "ja": "クライアントがアウトバウンドプロキシを使用しており、そのプロキシが実際に要求をリダイレクトする場合、可能性は無限リダイレクションループのために生じます。"
    },
    {
      "indent": 3,
      "text": "Note that a Contact header field value MAY also refer to a different resource than the one originally called. For example, a SIP call connected to PSTN gateway may need to deliver a special informational announcement such as \"The number you have dialed has been changed.\"",
      "ja": "Contactヘッダーフィールド値も元々呼ばれるものとは別のリソースを参照してもよいことに注意してください。例えば、PSTNゲートウェイに接続されたSIPコールは、次のような特別な情報アナウンスを提供する必要があるかもしれません「あなたがダイヤルしている番号が変更されました。」"
    },
    {
      "indent": 3,
      "text": "A Contact response header field can contain any suitable URI indicating where the called party can be reached, not limited to SIP URIs. For example, it could contain URIs for phones, fax, or irc (if they were defined) or a mailto: (RFC 2368 [32]) URL. Section 26.4.4 discusses implications and limitations of redirecting a SIPS URI to a non-SIPS URI.",
      "ja": "問い合わせレスポンスヘッダフィールドは、被呼者がSIP URIに限定されるものではなく、到達することができる場所を示す任意の適切なURIを含むことができます。 （RFC 2368 [32]）URL：たとえば、それは（それが定義されている場合）電話、ファックス、またはIRCのURIまたはmailtoのを含めることができます。セクション26.4.4は非SIPS URIにSIPS URIをリダイレクトの意味と限界について説明します。"
    },
    {
      "indent": 3,
      "text": "The \"expires\" parameter of a Contact header field value indicates how long the URI is valid. The value of the parameter is a number indicating seconds. If this parameter is not provided, the value of the Expires header field determines how long the URI is valid. Malformed values SHOULD be treated as equivalent to 3600.",
      "ja": "Contactヘッダーフィールド値のパラメータは、URIが有効である期間を示し、「期限が切れます」。パラメータの値は、秒を示す番号です。このパラメータが提供されていない場合、有効期限ヘッダーフィールドの値は、URIが有効である期間を決定します。不正な形式の値は3600と同等に扱われるべきです。"
    },
    {
      "indent": 6,
      "text": "This provides a modest level of backwards compatibility with RFC 2543, which allowed absolute times in this header field. If an absolute time is received, it will be treated as malformed, and then default to 3600.",
      "ja": "これは、このヘッダフィールドに絶対時間を許容RFC 2543との下位互換性の適度なレベルを提供します。絶対時間を受信した場合、それは不正な形式として扱われ、その後、3600にデフォルト設定されます。"
    },
    {
      "indent": 3,
      "text": "Redirect servers MUST ignore features that are not understood (including unrecognized header fields, any unknown option tags in Require, or even method names) and proceed with the redirection of the request in question.",
      "ja": "リダイレクトサーバーは、（認識されないヘッダフィールドには、必要とするすべての未知のオプションタグ、あるいはメソッド名を含む）に理解されていない機能を無視して、問題の要求のリダイレクトを続行しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9 Canceling a Request",
      "ja": "9要求のキャンセル"
    },
    {
      "indent": 3,
      "text": "The previous section has discussed general UA behavior for generating requests and processing responses for requests of all methods. In this section, we discuss a general purpose method, called CANCEL.",
      "ja": "前のセクションでは、すべてのメソッドの要求の要求および処理応答を生成するための一般的なUAの動作について議論しています。ここでは、CANCELと呼ばれ、汎用の方法を議論します。"
    },
    {
      "indent": 3,
      "text": "The CANCEL request, as the name implies, is used to cancel a previous request sent by a client. Specifically, it asks the UAS to cease processing the request and to generate an error response to that request. CANCEL has no effect on a request to which a UAS has already given a final response. Because of this, it is most useful to CANCEL requests to which it can take a server long time to respond. For this reason, CANCEL is best for INVITE requests, which can take a long time to generate a response. In that usage, a UAS that receives a CANCEL request for an INVITE, but has not yet sent a final response, would \"stop ringing\", and then respond to the INVITE with a specific error response (a 487).",
      "ja": "名前が示すようにCANCELリクエストを、クライアントから送信された前の要求をキャンセルするために使用されます。具体的には、リクエストの処理を中止し、その要求に対するエラー応答を生成するために、UASに求めます。 CANCEL UASがすでに最終応答を与えた先の要求に影響を及ぼしません。このため、応答するサーバーに長い時間がかかることが先の要求をキャンセルすることが最も有用です。このため、キャンセル応答を生成するのに長い時間がかかることがINVITEリクエストのために最善です。その使用、INVITEのためにCANCEL要求を受信するUAS、でまだ最終的な応答を送信していない、「リンギング停止」であろうと、特定のエラー応答（487）を用いてINVITEに応答します。"
    },
    {
      "indent": 3,
      "text": "CANCEL requests can be constructed and sent by both proxies and user agent clients. Section 15 discusses under what conditions a UAC would CANCEL an INVITE request, and Section 16.10 discusses proxy usage of CANCEL.",
      "ja": "CANCELリクエストを構築し、プロキシとユーザエージェントクライアントの両方で送信することができます。 UACは、INVITEリクエストをキャンセルうどのような条件の下で、第15条について議論し、キャンセルのセクション16.10を議論プロキシの使用。"
    },
    {
      "indent": 3,
      "text": "A stateful proxy responds to a CANCEL, rather than simply forwarding a response it would receive from a downstream element. For that reason, CANCEL is referred to as a \"hop-by-hop\" request, since it is responded to at each stateful proxy hop.",
      "ja": "ステートフルプロキシはCANCELではなく、単にそれが下流要素から受信する応答の転送に応答します。そのため、CANCELそれは各ステートフルプロキシホップで応答されるので、「ホップバイホップ」要求と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "9.1 Client Behavior",
      "section_title": true,
      "ja": "9.1クライアントの動作"
    },
    {
      "indent": 3,
      "text": "A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.",
      "ja": "CANCELリクエストはINVITE以外の要求をキャンセルするために送るべきではありません。"
    },
    {
      "indent": 6,
      "text": "Since requests other than INVITE are responded to immediately, sending a CANCEL for a non-INVITE request would always create a race condition.",
      "ja": "INVITE以外の要求は常に競合状態を作成します非INVITEリクエストに対してCANCEL送信、にすぐに対応しているので。"
    },
    {
      "indent": 3,
      "text": "The following procedures are used to construct a CANCEL request. The Request-URI, Call-ID, To, the numeric part of CSeq, and From header fields in the CANCEL request MUST be identical to those in the request being cancelled, including tags. A CANCEL constructed by a client MUST have only a single Via header field value matching the top Via value in the request being cancelled. Using the same values for these header fields allows the CANCEL to be matched with the request it cancels (Section 9.2 indicates how such matching occurs). However, the method part of the CSeq header field MUST have a value of CANCEL. This allows it to be identified and processed as a transaction in its own right (See Section 17).",
      "ja": "次の手順では、CANCELリクエストを構築するために使用されています。 Request-URI、コールIDを、のCSeqの数字部分に、キャンセル要求のヘッダフィールドからはタグを含む、キャンセルされるリクエストのものと同一でなければなりません。 Aキャンセルされる要求の値を介してトップに一致単一のViaヘッダフィールド値を持つ必要があり、クライアントによって構築CANCEL。これらのヘッダフィールドの同じ値を使用すると、CANCELは、それが（9.2節は、このようなマッチングが起こるかを示す）解除要求に合わせることを可能にします。しかしながら、CSeqヘッダーフィールドの方法の一部は、CANCELの値を有しなければなりません。これは、それが特定され、独自の権利でトランザクションとして処理されることを可能にする（セクション17を参照してください）。"
    },
    {
      "indent": 3,
      "text": "If the request being cancelled contains a Route header field, the CANCEL request MUST include that Route header field's values.",
      "ja": "キャンセルされたリクエストがRouteヘッダーフィールドを含む場合、CANCEL要求は、Routeヘッダーフィールドの値を含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "This is needed so that stateless proxies are able to route CANCEL requests properly.",
      "ja": "ステートレスプロキシがルーティングすることができるようにこれが必要とされ、適切にリクエストをキャンセル。"
    },
    {
      "indent": 3,
      "text": "The CANCEL request MUST NOT contain any Require or Proxy-Require header fields.",
      "ja": "リクエストが必要またはプロキシRequireヘッダーフィールドを含んではならないCANCEL。"
    },
    {
      "indent": 3,
      "text": "Once the CANCEL is constructed, the client SHOULD check whether it has received any response (provisional or final) for the request being cancelled (herein referred to as the \"original request\").",
      "ja": "CANCELが構築されると、クライアントは、（本明細書では「元の要求」と呼ぶ）が解除されて要求を（仮または最終）の応答を受信したかどうかを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If no provisional response has been received, the CANCEL request MUST NOT be sent; rather, the client MUST wait for the arrival of a provisional response before sending the request. If the original request has generated a final response, the CANCEL SHOULD NOT be sent, as it is an effective no-op, since CANCEL has no effect on requests that have already generated a final response. When the client decides to send the CANCEL, it creates a client transaction for the CANCEL and passes it the CANCEL request along with the destination address, port, and transport. The destination address, port, and transport for the CANCEL MUST be identical to those used to send the original request.",
      "ja": "何の暫定応答を受信して​​いない場合は、CANCELリクエストは送ってはいけません。むしろ、クライアントが要求を送信する前に暫定応答の到着を待たなければなりません。元の要求は、最終的な応答を生成した場合は、CANCELはすでに最終応答を生成したリクエストには影響を与えませんCANCELので、それは、効果的な何もしませんよう、送るべきではありません。クライアントが送信キャンセルすることを決定したときは、CANCELのためのクライアントトランザクションを作成し、それは宛先アドレス、ポート、およびトランスポートと一緒にCANCELリクエストを渡します。宛先アドレス、ポート、およびキャンセルのための輸送は、元の要求を送信するために使用されるものと同じでなければなりません。"
    },
    {
      "indent": 6,
      "text": "If it was allowed to send the CANCEL before receiving a response for the previous request, the server could receive the CANCEL before the original request.",
      "ja": "それは以前の要求に対する応答を受信する前にCANCELを送信することを許可された場合、サーバは元の要求の前にCANCELを受け取ることができます。"
    },
    {
      "indent": 3,
      "text": "Note that both the transaction corresponding to the original request and the CANCEL transaction will complete independently. However, a UAC canceling a request cannot rely on receiving a 487 (Request Terminated) response for the original request, as an RFC 2543- compliant UAS will not generate such a response. If there is no final response for the original request in 64*T1 seconds (T1 is defined in Section 17.1.1.1), the client SHOULD then consider the original transaction cancelled and SHOULD destroy the client transaction handling the original request.",
      "ja": "元の要求およびCANCELトランザクションに対応するトランザクションの両方が独立して完了することに注意してください。しかし、要求をキャンセルするUACは、RFCとして2543-準拠UASはそのような応答を生成しない、元の要求のための487（要求末端）応答を受信に頼ることはできません。 64 * T1秒（T1はセクション17.1.1.1で定義されている）で、元の要求のための最終応答がない場合、クライアントは、元のトランザクションがキャンセル検討すべきであると、元の要求を処理するクライアントトランザクションを破棄すべきです。"
    },
    {
      "indent": 0,
      "text": "9.2 Server Behavior",
      "section_title": true,
      "ja": "9.2サーバーの動作"
    },
    {
      "indent": 3,
      "text": "The CANCEL method requests that the TU at the server side cancel a pending transaction. The TU determines the transaction to be cancelled by taking the CANCEL request, and then assuming that the request method is anything but CANCEL or ACK and applying the transaction matching procedures of Section 17.2.3. The matching transaction is the one to be cancelled.",
      "ja": "サーバー側のTUが保留中のトランザクションを取り消す方法要求をキャンセル。 TUはCANCEL要求を取って、その後、要求メソッドが何であると仮定が、CANCELまたはACKおよびセクション17.2.3の手順を一致トランザクションを適用することによってキャンセルされるトランザクションを決定します。マッチング取引をキャンセルするためのものです。"
    },
    {
      "indent": 3,
      "text": "The processing of a CANCEL request at a server depends on the type of server. A stateless proxy will forward it, a stateful proxy might respond to it and generate some CANCEL requests of its own, and a UAS will respond to it. See Section 16.10 for proxy treatment of CANCEL.",
      "ja": "サーバーでのCANCELリクエストの処理は、サーバの種類によって異なります。ステートレスプロキシは、ステートフルプロキシはそれに対応し、いくつかは、独自の要求をキャンセルし、UASはそれに応答します生成することがあります、それを転送します。キャンセルのプロキシ治療については、セクション16.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "A UAS first processes the CANCEL request according to the general UAS processing described in Section 8.2. However, since CANCEL requests are hop-by-hop and cannot be resubmitted, they cannot be challenged by the server in order to get proper credentials in an Authorization header field. Note also that CANCEL requests do not contain a Require header field.",
      "ja": "UASは、最初のセクション8.2に記載の一般的なUAS処理に従ってCANCEL要求を処理します。しかしながら、リクエストによってホップホップされ、再送信することはできませんキャンセル、彼らはAuthorizationヘッダフィールドに適切な資格情報を取得するためにサーバによって挑戦することができません。 Requireヘッダーフィールドを含まない要求をキャンセルことにも注意してください。"
    },
    {
      "indent": 3,
      "text": "If the UAS did not find a matching transaction for the CANCEL according to the procedure above, it SHOULD respond to the CANCEL with a 481 (Call Leg/Transaction Does Not Exist). If the transaction for the original request still exists, the behavior of the UAS on receiving a CANCEL request depends on whether it has already sent a final response for the original request. If it has, the CANCEL request has no effect on the processing of the original request, no effect on any session state, and no effect on the responses generated for the original request. If the UAS has not issued a final response for the original request, its behavior depends on the method of the original request. If the original request was an INVITE, the UAS SHOULD immediately respond to the INVITE with a 487 (Request Terminated). A CANCEL request has no impact on the processing of transactions with any other method defined in this specification.",
      "ja": "UASは、上記の手順に従って、CANCELのためのマッチングトランザクションが見つからなかった場合、それは481（脚/トランザクションが存在しないコール）でキャンセルに応じるべきです。元の要求のためのトランザクションがまだ存在する場合は、CANCELリクエストを受信するUASの動作は、それがすでに元の要求のための最終的な応答を送信したかどうかに依存します。それは持っている場合、CANCEL要求は元の要求、任意のセッション状態に影響を与えず、そして元の要求のために生成された応答に何の影響の処理に影響を及ぼしません。 UASはオリジナルの要求のための最終的な応答を発行していない場合、その動作は、元の要求の方法に依存します。元のリクエストがINVITEだった場合、UASは、すぐに487（終端要求）でINVITEに応答する必要があります。 CANCEL要求は、本明細書で定義された任意の他の方法との取引の処理に影響を及ぼしません。"
    },
    {
      "indent": 3,
      "text": "Regardless of the method of the original request, as long as the CANCEL matched an existing transaction, the UAS answers the CANCEL request itself with a 200 (OK) response. This response is constructed following the procedures described in Section 8.2.6 noting that the To tag of the response to the CANCEL and the To tag in the response to the original request SHOULD be the same. The response to CANCEL is passed to the server transaction for transmission.",
      "ja": "かかわらず、元の要求の方法の、限り既存のトランザクションに一致CANCELように、UASは、200（OK）レスポンスとCANCEL要求自体に応答します。この応答は、CANCELに対する応答のタグ付けし、同じでなければならない元の要求に応答してタグ付けすることに注意セクション8.2.6に記載される手順に従って構成されています。応答は、送信用のサーバートランザクションに渡されるキャンセルします。"
    },
    {
      "indent": 0,
      "text": "10 Registrations",
      "ja": "10件の登録"
    },
    {
      "indent": 0,
      "text": "10.1 Overview",
      "section_title": true,
      "ja": "10.1概要"
    },
    {
      "indent": 3,
      "text": "SIP offers a discovery capability. If a user wants to initiate a session with another user, SIP must discover the current host(s) at which the destination user is reachable. This discovery process is frequently accomplished by SIP network elements such as proxy servers and redirect servers which are responsible for receiving a request, determining where to send it based on knowledge of the location of the user, and then sending it there. To do this, SIP network elements consult an abstract service known as a location service, which provides address bindings for a particular domain. These address bindings map an incoming SIP or SIPS URI, sip:bob@biloxi.com, for example, to one or more URIs that are somehow \"closer\" to the desired user, sip:bob@engineering.biloxi.com, for example. Ultimately, a proxy will consult a location service that maps a received URI to the user agent(s) at which the desired recipient is currently residing.",
      "ja": "SIPは、検出機能を提供しています。ユーザーが別のユーザーとのセッションを開始することを望んでいる場合は、SIPは、宛先ユーザが到達可能である時現在のホスト（複数可）を発見しなければなりません。この発見プロセスは、しばしば、このようなプロキシサーバとしてSIPネットワーク要素によって達成さと、要求を受信した場合、ユーザの位置の知識に基づいてそれを送信する決定、およびそこにそれを送信する責任があるサーバにリダイレクトされます。これを行うには、SIPネットワーク要素は、特定のドメインのアドレスバインディングを提供してロケーションサービスとして知られている抽象的サービスを、ご相談ください。例えば、bob@engineering.biloxi.com：、例えば、所望のユーザ、SIPに何とか「近い」である1つ以上のURIにbob@biloxi.com：これらのアドレスバインディングは、着信SIPをマッピングまたはURIをSIPS、SIP 。最終的には、プロキシは、所望の受信者が現在常駐されたユーザエージェント（複数可）に受信されたURIをマップロケーションサービスを協議します。"
    },
    {
      "indent": 3,
      "text": "Registration creates bindings in a location service for a particular domain that associates an address-of-record URI with one or more contact addresses. Thus, when a proxy for that domain receives a request whose Request-URI matches the address-of-record, the proxy will forward the request to the contact addresses registered to that address-of-record. Generally, it only makes sense to register an address-of-record at a domain's location service when requests for that address-of-record would be routed to that domain. In most cases, this means that the domain of the registration will need to match the domain in the URI of the address-of-record.",
      "ja": "登録は一の以上のコンタクトアドレスをアドレス・オブ・レコードのURIを関連付け、特定のドメインのロケーションサービスにバインディングを作成します。そのドメインのプロキシがその要求URIは、アドレスのレコードに一致する要求を受信したときにこのように、プロキシは、そのアドレス・オブ・レコードに登録された連絡先に要求を転送します。一般的には、それだけでそのアドレス・オブ・レコードの要求がそのドメインにルーティングされる際に、ドメインの位置情報サービスで、アドレスのレコードを登録することは理にかなっています。ほとんどの場合、これは登録のドメインが、アドレス・オブ・レコードのURIにドメインと一致する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "There are many ways by which the contents of the location service can be established. One way is administratively. In the above example, Bob is known to be a member of the engineering department through access to a corporate database. However, SIP provides a mechanism for a UA to create a binding explicitly. This mechanism is known as registration.",
      "ja": "ロケーションサービスの内容を確立することが可能な多くの方法があります。一つの方法は、管理です。上記の例では、ボブは、企業データベースへのアクセスを通じて、エンジニアリング部門のメンバーであることが知られています。しかし、SIPは、明示的にバインディングを作成するには、UAのためのメカニズムを提供します。このメカニズムは、登録として知られています。"
    },
    {
      "indent": 3,
      "text": "Registration entails sending a REGISTER request to a special type of UAS known as a registrar. A registrar acts as the front end to the location service for a domain, reading and writing mappings based on the contents of REGISTER requests. This location service is then typically consulted by a proxy server that is responsible for routing requests for that domain.",
      "ja": "登録はレジストラとして知られているUASの特殊なタイプにREGISTERリクエストを送信することを必要とします。レジストラは、読書とREGISTER要求の内容に基づいてマッピングを書いて、ドメインのロケーションサービスへのフロントエンドとして機能します。このロケーションサービスは、その後、通常そのドメインのリクエストをルーティングする責任があるプロキシサーバによって参照されます。"
    },
    {
      "indent": 3,
      "text": "An illustration of the overall registration process is given in Figure 2. Note that the registrar and proxy server are logical roles that can be played by a single device in a network; for purposes of clarity the two are separated in this illustration. Also note that UAs may send requests through a proxy server in order to reach a registrar if the two are separate elements.",
      "ja": "全体的な登録プロセスの図示はレジストラとプロキシサーバは、ネットワーク内の単一の装置によって再生することができる論理的な役割があることを図2注に示されています。明確にする目的のための2つは、この図では分離されています。また、UAが二つが別々の要素である場合にレジストラに到達するためにプロキシサーバーを介して要求を送信することに注意してください。"
    },
    {
      "indent": 3,
      "text": "SIP does not mandate a particular mechanism for implementing the location service. The only requirement is that a registrar for some domain MUST be able to read and write data to the location service, and a proxy or a redirect server for that domain MUST be capable of reading that same data. A registrar MAY be co-located with a particular SIP proxy server for the same domain.",
      "ja": "SIPは、ロケーションサービスを実装するための特定のメカニズムを強制しません。唯一の要件は、いくつかのドメインのレジストラは、ロケーションサービスにデータを読み書きできなければなりません、そして、そのドメインのプロキシまたはリダイレクトサーバが同じデータを読み取り可能でなければならないことです。レジストラは、同じドメインのための特定のSIPプロキシサーバと同じ場所に配置されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.2 Constructing the REGISTER Request",
      "section_title": true,
      "ja": "10.2 REGISTERリクエストの構築"
    },
    {
      "indent": 3,
      "text": "REGISTER requests add, remove, and query bindings. A REGISTER request can add a new binding between an address-of-record and one or more contact addresses. Registration on behalf of a particular address-of-record can be performed by a suitably authorized third party. A client can also remove previous bindings or query to determine which bindings are currently in place for an address-of-record.",
      "ja": "REGISTERリクエストは、追加、削除、およびクエリのバインディング。 REGISTERリクエストは、のレコードアドレスと1つの以上のコンタクトアドレス間の新しいバインディングを追加することができます。特定のアドレスのレコードに代わって登録が適切に認可された第三者によって行うことができます。また、クライアントは、以前のバインディングを削除するか、アドレス・オブ・レコードの場所に現在どのバインディングを決定するために照会することができます。"
    },
    {
      "indent": 3,
      "text": "Except as noted, the construction of the REGISTER request and the behavior of clients sending a REGISTER request is identical to the general UAC behavior described in Section 8.1 and Section 17.1.",
      "ja": "注目されている場合を除き、REGISTERリクエストの構築とREGISTERリクエストを送信するクライアントの動作は、セクション8.1およびセクション17.1に記載された一般的UACの動作と同一です。"
    },
    {
      "indent": 3,
      "text": "A REGISTER request does not establish a dialog. A UAC MAY include a Route header field in a REGISTER request based on a pre-existing route set as described in Section 8.1. The Record-Route header field has no meaning in REGISTER requests or responses, and MUST be ignored if present. In particular, the UAC MUST NOT create a new route set based on the presence or absence of a Record-Route header field in any response to a REGISTER request.",
      "ja": "REGISTERリクエストは、ダイアログを確立しません。 UACは、8.1節に記載されるように設定され、既存の経路に基づいて、REGISTERリクエストのRouteヘッダフィールドを含んでいてもよいです。 Record-RouteヘッダーフィールドはREGISTER要求または応答では意味を持たず、存在する場合無視しなければなりません。特に、UACはREGISTERリクエストに対する応答でRecord-Routeヘッダフィールドの有無に基づいて、新しいルートセットを作成してはいけません。"
    },
    {
      "indent": 3,
      "text": "The following header fields, except Contact, MUST be included in a REGISTER request. A Contact header field MAY be included:",
      "ja": "次のヘッダーフィールドは、連絡先を除いて、REGISTER要求に含まれなければなりません。 Contactヘッダーフィールドが含まれる場合があります。"
    },
    {
      "indent": 6,
      "text": "Request-URI: The Request-URI names the domain of the location service for which the registration is meant (for example, \"sip:chicago.com\"). The \"userinfo\" and \"@\" components of the SIP URI MUST NOT be present.",
      "ja": "リクエストURI：リクエストURI名登録は（例えば、「SIP：chicago.com」）を意味されているロケーションサービスのドメイン。 SIP URIの「userinfoを」と「@」コンポーネントが存在してはなりません。"
    },
    {
      "indent": 6,
      "text": "To: The To header field contains the address of record whose registration is to be created, queried, or modified. The To header field and the Request-URI field typically differ, as the former contains a user name. This address-of-record MUST be a SIP URI or SIPS URI.",
      "ja": "：Toヘッダーフィールド登録、作成した照会、または変更されるレコードのアドレスを含みます。前者はユーザ名を含むようにToヘッダーフィールドとRequest-URIフィールドは、典型的には異なります。このアドレス・オブ・レコードはSIP URIまたはSIPS URIでなければなりません。"
    },
    {
      "indent": 6,
      "text": "From: The From header field contains the address-of-record of the person responsible for the registration. The value is the same as the To header field unless the request is a third-party registration.",
      "ja": "From：Fromヘッダフィールドアドレス・オブ・レコードの登録のための責任者の含まれています。値は、要求が、サードパーティの登録でない限り、ヘッダーフィールドと同一です。"
    },
    {
      "indent": 6,
      "text": "Call-ID: All registrations from a UAC SHOULD use the same Call-ID header field value for registrations sent to a particular registrar.",
      "ja": "コールIDを：UACからのすべての登録は、特定のレジストラに送信され、登録のために同じCall-IDヘッダフィールドの値を使用する必要があります。"
    },
    {
      "indent": 11,
      "text": "If the same client were to use different Call-ID values, a\nregistrar could not detect whether a delayed REGISTER request\nmight have arrived out of order.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "CSeq: The CSeq value guarantees proper ordering of REGISTER requests. A UA MUST increment the CSeq value by one for each REGISTER request with the same Call-ID.",
      "ja": "CSeq：のCSeq値はREGISTERリクエストの適切な順序付けを保証します。 UAは、同じCall-IDを持つ各REGISTER要求のいずれかでのCSeq値を増加しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Contact: REGISTER requests MAY contain a Contact header field with zero or more values containing address bindings.",
      "ja": "連絡先：REGISTER要求はアドレスバインディングを含むゼロ以上の値を持つContactヘッダーフィールドを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "UAs MUST NOT send a new registration (that is, containing new Contact header field values, as opposed to a retransmission) until they have received a final response from the registrar for the previous one or the previous REGISTER request has timed out.",
      "ja": "UAは、それらがタイムアウトした前のまたは前のREGISTER要求のレジストラからの最終的な応答を受信するまで（再送とは対照的に、それは、新しい連絡先ヘッダフィールド値を含む）で新規登録を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "                                              bob\n                                            +----+\n                                            | UA |\n                                            |    |\n                                            +----+\n                                               |\n                                               |3)INVITE\n                                               |   carol@chicago.com\n      chicago.com        +--------+            V\n      +---------+ 2)Store|Location|4)Query +-----+\n      |Registrar|=======>| Service|<=======|Proxy|sip.chicago.com\n      +---------+        +--------+=======>+-----+\n            A                      5)Resp      |\n            |                                  |\n            |                                  |\n  1)REGISTER|                                  |\n            |                                  |\n         +----+                                |\n         | UA |<-------------------------------+\ncube2214a|    |                            6)INVITE\n         +----+                    carol@cube2214a.chicago.com\n          carol",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2: REGISTER example",
      "ja": "図2：例レジスタ"
    },
    {
      "indent": 6,
      "text": "The following Contact header parameters have a special meaning in REGISTER requests:",
      "ja": "以下のContactヘッダパラメータはREGISTERリクエストに特別な意味を持っています："
    },
    {
      "indent": 6,
      "text": "action: The \"action\" parameter from RFC 2543 has been deprecated. UACs SHOULD NOT use the \"action\" parameter.",
      "ja": "アクション：RFC 2543から「アクション」パラメータが廃止されました。求めるUACは、「アクション」パラメータを使用しないでください。"
    },
    {
      "indent": 6,
      "text": "expires: The \"expires\" parameter indicates how long the UA would like the binding to be valid. The value is a number indicating seconds. If this parameter is not provided, the value of the Expires header field is used instead. Implementations MAY treat values larger than 2**32-1 (4294967295 seconds or 136 years) as equivalent to 2**32-1. Malformed values SHOULD be treated as equivalent to 3600.",
      "ja": "期限が切れる：パラメータは、UAが有効であることを結合たい期間を示し、「期限が切れます」。値は秒を示す数値です。このパラメータが提供されない場合、の値は、ヘッダフィールドが代わりに使用されている有効期限が切れます。実装は** 32-1 2と同等に2 ** 32-1（4294967295秒または136年）よりも大きな値を扱うかもしれ。不正な形式の値は3600と同等に扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "10.2.1 Adding Bindings",
      "section_title": true,
      "ja": "10.2.1追加バインディング"
    },
    {
      "indent": 3,
      "text": "The REGISTER request sent to a registrar includes the contact address(es) to which SIP requests for the address-of-record should be forwarded. The address-of-record is included in the To header field of the REGISTER request.",
      "ja": "レジストラに送信されたREGISTER要求は、アドレス・オブ・レコードのためのSIP要求が転送されるべきとの接触アドレスを含みます。アドレス・オブ・レコードは、REGISTER要求のToヘッダーフィールドに含まれています。"
    },
    {
      "indent": 3,
      "text": "The Contact header field values of the request typically consist of SIP or SIPS URIs that identify particular SIP endpoints (for example, \"sip:carol@cube2214a.chicago.com\"), but they MAY use any URI scheme. A SIP UA can choose to register telephone numbers (with the tel URL, RFC 2806 [9]) or email addresses (with a mailto URL, RFC 2368 [32]) as Contacts for an address-of-record, for example.",
      "ja": "要求のContactヘッダーフィールド値は、典型的には、SIPから成るか、または特定のSIPエンドポイント（例えば、「SIP：carol@cube2214a.chicago.com」）を識別するURIをSIPS、それらは任意のURIスキームを使用するかもしれません。 SIP UAは、電話番号を登録することを選択することができ（TEL URLを使用してRFC 2806 [9]）または電子メールアドレス（mailtoのURLと、RFC 2368 [32]）、例えばアドレス・オブ・レコードの連絡先として。"
    },
    {
      "indent": 3,
      "text": "For example, Carol, with address-of-record \"sip:carol@chicago.com\", would register with the SIP registrar of the domain chicago.com. Her registrations would then be used by a proxy server in the chicago.com domain to route requests for Carol's address-of-record to her SIP endpoint.",
      "ja": "例えば、キャロルは、アドレス・オブ・レコードの「SIP：carol@chicago.com」で、ドメインchicago.comのSIPレジストラに登録します。彼女の登録はその後、キャロルのアドレス・オブ・レコードの彼女のSIPエンドポイントへのルート要求にchicago.comドメインにプロキシサーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Once a client has established bindings at a registrar, it MAY send subsequent registrations containing new bindings or modifications to existing bindings as necessary. The 2xx response to the REGISTER request will contain, in a Contact header field, a complete list of bindings that have been registered for this address-of-record at this registrar.",
      "ja": "クライアントはレジストラでバインディングを確立していたら、それは必要に応じて、既存のバインディングに新しいバインディングや修正を含む、後続の登録を送るかもしれません。 REGISTER要求に対する2xx応答は、Contactヘッダーフィールドで、このレジストラでは、このアドレス・オブ・レコードに登録されているバインディングの完全なリストが含まれます。"
    },
    {
      "indent": 3,
      "text": "If the address-of-record in the To header field of a REGISTER request is a SIPS URI, then any Contact header field values in the request SHOULD also be SIPS URIs. Clients should only register non-SIPS URIs under a SIPS address-of-record when the security of the resource represented by the contact address is guaranteed by other means. This may be applicable to URIs that invoke protocols other than SIP, or SIP devices secured by protocols other than TLS.",
      "ja": "アドレス・オブ・レコードREGISTERリクエストのヘッダーフィールドには、SIPS URIである場合には、要求内の任意のContactヘッダーフィールド値もSIPS URIにあるべきです。連絡先アドレスによって表されるリソースのセキュリティは他の手段によって保証されている場合、クライアントはのみSIPSアドレスのレコードの下に非SIPS URIを登録する必要があります。これは、SIP以外のプロトコル、またはTLS以外のプロトコルによって固定SIPデバイスを呼び出すURIに適用することができます。"
    },
    {
      "indent": 3,
      "text": "Registrations do not need to update all bindings. Typically, a UA only updates its own contact addresses.",
      "ja": "登録はすべてのバインディングを更新する必要はありません。一般的に、UAは、自身の連絡先を更新します。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1 Setting the Expiration Interval of Contact Addresses",
      "section_title": true,
      "ja": "連絡先アドレスの有効期限の間隔の設定10.2.1.1"
    },
    {
      "indent": 3,
      "text": "When a client sends a REGISTER request, it MAY suggest an expiration interval that indicates how long the client would like the registration to be valid. (As described in Section 10.3, the registrar selects the actual time interval based on its local policy.)",
      "ja": "クライアントはREGISTER要求を送信すると、それは、クライアントが有効であるために登録をご希望の期間を示し期限切れ間隔を提案することができます。 （セクション10.3で説明したように、レジストラは、ローカルポリシーに基づいて、実際の時間間隔を選択します。）"
    },
    {
      "indent": 3,
      "text": "There are two ways in which a client can suggest an expiration interval for a binding: through an Expires header field or an \"expires\" Contact header parameter. The latter allows expiration intervals to be suggested on a per-binding basis when more than one binding is given in a single REGISTER request, whereas the former suggests an expiration interval for all Contact header field values that do not contain the \"expires\" parameter.",
      "ja": "クライアントバインディングの有効間隔を提案することが可能な2つの方法があります。ExpiresヘッダーフィールドまたはContactヘッダーパラメータを「期限が切れる」を通じて。後者は、期限切れ間隔が、前者は「期限が切れる」パラメータを含まないすべてのContactヘッダーフィールド値の有効間隔を示唆一方つ以上の結合が、単一のREGISTERリクエストに与えられているあたりの結合に基づいて提案することが可能になります。"
    },
    {
      "indent": 3,
      "text": "If neither mechanism for expressing a suggested expiration time is present in a REGISTER, the client is indicating its desire for the server to choose.",
      "ja": "提案の有効期限を表現するためのどちらのメカニズムは、REGISTERに存在する場合、クライアントはサーバが選択するためにその願望を示しています。"
    },
    {
      "indent": 0,
      "text": "10.2.1.2 Preferences among Contact Addresses",
      "section_title": true,
      "ja": "連絡先のアドレスのうち、10.2.1.2環境設定"
    },
    {
      "indent": 3,
      "text": "If more than one Contact is sent in a REGISTER request, the registering UA intends to associate all of the URIs in these Contact header field values with the address-of-record present in the To field. This list can be prioritized with the \"q\" parameter in the Contact header field. The \"q\" parameter indicates a relative preference for the particular Contact header field value compared to other bindings for this address-of-record. Section 16.6 describes how a proxy server uses this preference indication.",
      "ja": "複数の連絡先をREGISTER要求で送信された場合、登録UAは、Toフィールド内のアドレス・オブ・レコードの存在とこれらのContactヘッダーフィールド値にURIのすべてを関連付けることを意図しています。このリストは、Contactヘッダーフィールドに「Q」パラメータで優先順位を付けることができます。 「Q」パラメータは、このアドレス・オブ・レコードのための他のバインディングに比べ特定のContactヘッダーフィールド値に対する相対的な優先を示します。セクション16.6は、プロキシサーバがこの設定指示を使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "10.2.2 Removing Bindings",
      "section_title": true,
      "ja": "10.2.2削除バインディング"
    },
    {
      "indent": 3,
      "text": "Registrations are soft state and expire unless refreshed, but can also be explicitly removed. A client can attempt to influence the expiration interval selected by the registrar as described in Section 10.2.1. A UA requests the immediate removal of a binding by specifying an expiration interval of \"0\" for that contact address in a REGISTER request. UAs SHOULD support this mechanism so that bindings can be removed before their expiration interval has passed.",
      "ja": "登録はソフトステートであり、リフレッシュされない限り有効期限はなく、明示的に削除することができます。クライアントは、10.2.1項で説明したようにレジストラによって選択された有効期限の間隔に影響を与えることを試みることができます。 UAは、REGISTERリクエストでその連絡先アドレスは「0」の有効期限の間隔を指定することによって、結合の即時削除を要求します。その有効期限間隔が経過する前にバインディングを除去することができるように、UAは、このメカニズムをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "The REGISTER-specific Contact header field value of \"*\" applies to all registrations, but it MUST NOT be used unless the Expires header field is present with a value of \"0\".",
      "ja": "「*」のREGISTER固有のContactヘッダーフィールド値は、すべての登録に適用されますが、ヘッダーフィールドが「0」の値を持つ存在である有効期限がない限り、それを使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Use of the \"*\" Contact header field value allows a registering UA to remove all bindings associated with an address-of-record without knowing their precise values.",
      "ja": "「*」Contactヘッダーフィールド値を使用すると、彼らの正確な値を知ることなく、アドレス・オブ・レコードに関連付けられているすべてのバインディングを削除するために登録するUAができます。"
    },
    {
      "indent": 0,
      "text": "10.2.3 Fetching Bindings",
      "section_title": true,
      "ja": "10.2.3フェッチバインディング"
    },
    {
      "indent": 3,
      "text": "A success response to any REGISTER request contains the complete list of existing bindings, regardless of whether the request contained a Contact header field. If no Contact header field is present in a REGISTER request, the list of bindings is left unchanged.",
      "ja": "任意のREGISTERリクエストに成功応答にかかわらず、要求がContactヘッダーフィールドが含まれているかどうかの、既存のバインディングの完全なリストが含まれています。何のContactヘッダーフィールドはREGISTERリクエストに存在しない場合は、バインディングのリストは変更されません。"
    },
    {
      "indent": 0,
      "text": "10.2.4 Refreshing Bindings",
      "section_title": true,
      "ja": "10.2.4リフレッシュバインディング"
    },
    {
      "indent": 3,
      "text": "Each UA is responsible for refreshing the bindings that it has previously established. A UA SHOULD NOT refresh bindings set up by other UAs.",
      "ja": "各UAは、それが以前に確立したバインディングをリフレッシュする責任があります。 UAは、他のUAによって設定されたバインディングを更新すべきではありません。"
    },
    {
      "indent": 3,
      "text": "The 200 (OK) response from the registrar contains a list of Contact fields enumerating all current bindings. The UA compares each contact address to see if it created the contact address, using comparison rules in Section 19.1.4. If so, it updates the expiration time interval according to the expires parameter or, if absent, the Expires field value. The UA then issues a REGISTER request for each of its bindings before the expiration interval has elapsed. It MAY combine several updates into one REGISTER request.",
      "ja": "レジストラから200（OK）応答は、現在のすべてのバインディングを列挙連絡先フィールドのリストが含まれています。 UAは、セクション19.1.4で比較ルールを使用して、それが連絡先を作成したかどうかを確認するために、各連絡先アドレスを比較します。もしそうなら、それは、フィールド値を有効期限存在しない場合、パラメータは期限切れになるかに応じて有効期限の間隔を更新します。期限切れ間隔が経過する前に、UAは、そのバインディングのそれぞれについて、REGISTER要求を発行します。これは、1つのREGISTERリクエストにいくつかのアップデートを組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "A UA SHOULD use the same Call-ID for all registrations during a single boot cycle. Registration refreshes SHOULD be sent to the same network address as the original registration, unless redirected.",
      "ja": "UAは、単一のブートサイクル中にすべての登録のために同じCall-IDを使用する必要があります。リダイレクトされない限り、登録の更新は、元の登録と同じネットワークアドレスに送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.5 Setting the Internal Clock",
      "section_title": true,
      "ja": "10.2.5内部クロックの設定"
    },
    {
      "indent": 3,
      "text": "If the response for a REGISTER request contains a Date header field, the client MAY use this header field to learn the current time in order to set any internal clocks.",
      "ja": "REGISTER要求に対する応答がDateヘッダーフィールドが含まれている場合、クライアントは任意の内部クロックを設定するために、現在の時刻を学ぶために、このヘッダフィールドを使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.2.6 Discovering a Registrar",
      "section_title": true,
      "ja": "レジストラを発見10.2.6"
    },
    {
      "indent": 3,
      "text": "UAs can use three ways to determine the address to which to send registrations: by configuration, using the address-of-record, and multicast. A UA can be configured, in ways beyond the scope of this specification, with a registrar address. If there is no configured registrar address, the UA SHOULD use the host part of the address-of-record as the Request-URI and address the request there, using the normal SIP server location mechanisms [4]. For example, the UA for the user \"sip:carol@chicago.com\" addresses the REGISTER request to \"sip:chicago.com\".",
      "ja": "UAは登録を送信するアドレスを決定する3つの方法を使用することができます：設定により、アドレスのレコード、およびマルチキャストを使用します。 UAが登録アドレスで、本明細書の範囲を超えた方法で、構成することができます。いかなる構成レジストラアドレスが存在しない場合、UAは、通常のSIPサーバの位置メカニズムを使用して、アドレスのレコードのRequest-URIとしてのホスト部分を使用し、そこ要求に対処すべきである[4]。たとえば、ユーザが「SIP：carol@chicago.com」のUAはREGISTER要求に「：chicago.com SIP」に対応しています。"
    },
    {
      "indent": 3,
      "text": "Finally, a UA can be configured to use multicast. Multicast registrations are addressed to the well-known \"all SIP servers\" multicast address \"sip.mcast.net\" (224.0.1.75 for IPv4). No well-known IPv6 multicast address has been allocated; such an allocation will be documented separately when needed. SIP UAs MAY listen to that address and use it to become aware of the location of other local users (see [33]); however, they do not respond to the request.",
      "ja": "最後に、UAは、マルチキャストを使用するように設定することができます。マルチキャスト登録は、よく知られた「すべてのSIPサーバ」マルチキャストアドレス「sip.mcast.net」（IPv4の224.0.1.75）に宛てています。ノーよく知られているIPv6マルチキャストアドレスが割り当てられています。必要なときに、このような割り当ては、別途記載されます。 SIP UAは、そのアドレスをリッスンし、（[33]参照）、他のローカルユーザの位置に気づくためにそれを使用することができます。しかし、彼らは要求に応答しません。"
    },
    {
      "indent": 6,
      "text": "Multicast registration may be inappropriate in some environments, for example, if multiple businesses share the same local area network.",
      "ja": "複数の企業が同じローカルエリアネットワークを共有している場合、マルチキャスト登録は、例えば、いくつかの環境では不適切であってもよいです。"
    },
    {
      "indent": 0,
      "text": "10.2.7 Transmitting a Request",
      "section_title": true,
      "ja": "10.2.7要求を送信します"
    },
    {
      "indent": 3,
      "text": "Once the REGISTER method has been constructed, and the destination of the message identified, UACs follow the procedures described in Section 8.1.2 to hand off the REGISTER to the transaction layer.",
      "ja": "REGISTERメソッドが構築され、メッセージの宛先が識別されると、求めるUACはトランザクション層にREGISTERをハンドオフするために、セクション8.1.2に記載された手順に従います。"
    },
    {
      "indent": 3,
      "text": "If the transaction layer returns a timeout error because the REGISTER yielded no response, the UAC SHOULD NOT immediately re-attempt a registration to the same registrar.",
      "ja": "REGISTERは何の応答が得られないため、トランザクション層は、タイムアウトエラーを返した場合、UACはすぐに同じレジストラへの登録を再度試みるべきではありません。"
    },
    {
      "indent": 6,
      "text": "An immediate re-attempt is likely to also timeout. Waiting some reasonable time interval for the conditions causing the timeout to be corrected reduces unnecessary load on the network. No specific interval is mandated.",
      "ja": "即時再試行もタイムアウトする可能性があります。修正するタイムアウトを引き起こす状態のためのいくつかの合理的な時間間隔を待って、ネットワーク上の不要な負荷を軽減します。いかなる特定の間隔が義務付けられていません。"
    },
    {
      "indent": 0,
      "text": "10.2.8 Error Responses",
      "section_title": true,
      "ja": "10.2.8エラーレスポンス"
    },
    {
      "indent": 3,
      "text": "If a UA receives a 423 (Interval Too Brief) response, it MAY retry the registration after making the expiration interval of all contact addresses in the REGISTER request equal to or greater than the expiration interval within the Min-Expires header field of the 423 (Interval Too Brief) response.",
      "ja": "UA 423（間隔あまりに簡単な）応答を受信した場合、それは内期限切れ間隔以上REGISTERリクエスト内のすべての連絡先の期限切れ間隔を行った後、登録を再試行することができる423のヘッダフィールド（分、有効期限間隔短すぎる）応答。"
    },
    {
      "indent": 0,
      "text": "10.3 Processing REGISTER Requests",
      "section_title": true,
      "ja": "10.3処理REGISTER要求"
    },
    {
      "indent": 3,
      "text": "A registrar is a UAS that responds to REGISTER requests and maintains a list of bindings that are accessible to proxy servers and redirect servers within its administrative domain. A registrar handles requests according to Section 8.2 and Section 17.2, but it accepts only REGISTER requests. A registrar MUST not generate 6xx responses.",
      "ja": "レジストラは、要求を登録するために応答し、プロキシサーバにアクセス可能であり、その管理ドメイン内のサーバーにリダイレクトバインディングのリストを保持UASです。レジストラは、8.2節と節17.2に応じて要求を処理し、それだけでREGISTERリクエストを受け付けます。レジストラはの6xx応答を生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "A registrar MAY redirect REGISTER requests as appropriate. One common usage would be for a registrar listening on a multicast interface to redirect multicast REGISTER requests to its own unicast interface with a 302 (Moved Temporarily) response.",
      "ja": "レジストラは、必要に応じてREGISTER要求をリダイレクトするかもしれません。マルチキャストインターフェイスをリッスンし、レジストラ302（一時的に移動）応答でそれ自身のユニキャストインターフェースにマルチキャストREGISTERリクエストをリダイレクトするための一つの一般的な使用法は、あろう。"
    },
    {
      "indent": 3,
      "text": "Registrars MUST ignore the Record-Route header field if it is included in a REGISTER request. Registrars MUST NOT include a Record-Route header field in any response to a REGISTER request.",
      "ja": "それはREGISTER要求に含まれていれば、レジストラは、Record-Routeヘッダフィールドを無視しなければなりません。レジストラは、REGISTERリクエストに対する応答にRecord-Routeヘッダフィールドを含んではいけません。"
    },
    {
      "indent": 6,
      "text": "A registrar might receive a request that traversed a proxy which treats REGISTER as an unknown request and which added a Record-Route header field value.",
      "ja": "レジストラは、未知の要求としてレジスタを扱い、Record-Routeヘッダフィールド値を追加したプロキシを横断要求を受信するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A registrar has to know (for example, through configuration) the set of domain(s) for which it maintains bindings. REGISTER requests MUST be processed by a registrar in the order that they are received. REGISTER requests MUST also be processed atomically, meaning that a particular REGISTER request is either processed completely or not at all. Each REGISTER message MUST be processed independently of any other registration or binding changes.",
      "ja": "レジストラは、（例えば、コンフィギュレーションによって）それがバインディングを維持するためのドメインのセット（単数または複数）を知る必要があります。 REGISTERリクエストは、それらが受信されるために、レジストラによって処理しなければなりません。 REGISTERリクエストは、特定のREGISTERリクエストが完全に、または全く処理されるかということを意味し、アトミックに処理しなければなりません。各REGISTERメッセージは、独立して、任意の他の登録または結合変更の処理されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When receiving a REGISTER request, a registrar follows these steps:",
      "ja": "REGISTER要求を受信すると、レジストラは、次の手順を実行します。"
    },
    {
      "indent": 6,
      "text": "1. The registrar inspects the Request-URI to determine whether it has access to bindings for the domain identified in the Request-URI. If not, and if the server also acts as a proxy server, the server SHOULD forward the request to the addressed domain, following the general behavior for proxying messages described in Section 16.",
      "ja": "1.レジストラは、それが要求URIで識別されたドメイン用のバインディングへのアクセス権を持っているかどうかを判断するためのRequest-URIを検査します。ない場合は、サーバーにも、プロキシサーバとして動作している場合、および、サーバは、セクション16で説明したメッセージをプロキシするための一般的な動作以下、対処ドメインに要求を転送すべきです。"
    },
    {
      "indent": 6,
      "text": "2. To guarantee that the registrar supports any necessary extensions, the registrar MUST process the Require header field values as described for UASs in Section 8.2.2.",
      "ja": "レジストラは、必要な拡張をサポートセクション8.2.2でのUASについて説明したように、レジストラはRequireヘッダーフィールド値を処理しなければならないことを保証する2。"
    },
    {
      "indent": 6,
      "text": "3. A registrar SHOULD authenticate the UAC. Mechanisms for the authentication of SIP user agents are described in Section 22. Registration behavior in no way overrides the generic authentication framework for SIP. If no authentication mechanism is available, the registrar MAY take the From address as the asserted identity of the originator of the request.",
      "ja": "3.レジストラはUACを認証する必要があります。 SIPユーザエージェントの認証のためのメカニズムはない方法で、セクション22の登録動作で説明されているSIPのための一般的な認証フレームワークを上書きします。認証メカニズムが利用できない場合、レジストラは要求の発信元のアサートされたアイデンティティとしてアドレスからかかる場合があります。"
    },
    {
      "indent": 6,
      "text": "4. The registrar SHOULD determine if the authenticated user is authorized to modify registrations for this address-of-record. For example, a registrar might consult an authorization database that maps user names to a list of addresses-of-record for which that user has authorization to modify bindings. If the authenticated user is not authorized to modify bindings, the registrar MUST return a 403 (Forbidden) and skip the remaining steps.",
      "ja": "認証されたユーザーは、このアドレス・オブ・レコードの登録を変更することを許可されている場合4.レジストラが判断する必要があります。例えば、レジ​​ストラは、ユーザーがバインディングを変更する権限を持っているアドレス・オブ・レコードのリストにユーザー名をマップする認証データベースを参照すると良いかもしれません。認証されたユーザーは、バインディングを変更することが許可されていない場合は、レジストラは（禁止）403を返し、残りの手順を省略しなければなりません。"
    },
    {
      "indent": 9,
      "text": "In architectures that support third-party registration, one entity may be responsible for updating the registrations associated with multiple addresses-of-record.",
      "ja": "サードパーティの登録をサポートするアーキテクチャでは、一方のエンティティは、複数のアドレス・オブ・レコードに関連付けられた登録を更新する責任があるかもしれません。"
    },
    {
      "indent": 6,
      "text": "5. The registrar extracts the address-of-record from the To header field of the request. If the address-of-record is not valid for the domain in the Request-URI, the registrar MUST send a 404 (Not Found) response and skip the remaining steps. The URI MUST then be converted to a canonical form. To do that, all URI parameters MUST be removed (including the user-param), and any escaped characters MUST be converted to their unescaped form. The result serves as an index into the list of bindings.",
      "ja": "5.レジストラは、要求のToヘッダフィールドからのアドレス・オブ・レコードを抽出します。アドレスのレコードが要求URIにおけるドメインに対して有効でない場合、レジストラは404（Not Found）応答を送信し、残りの手順を省略しなければなりません。 URIは、次に標準形に変換されなければなりません。これを行うには、すべてのURIパラメータは、（ユーザーのparamを含む）が除去されなければならない、と任意の文字が、アンエスケープ形式に変換されなければならないエスケープ。結果は、バインディングのリストへのインデックスとして働きます。"
    },
    {
      "indent": 6,
      "text": "6. The registrar checks whether the request contains the Contact header field. If not, it skips to the last step. If the Contact header field is present, the registrar checks if there is one Contact field value that contains the special value \"*\" and an Expires field. If the request has additional Contact fields or an expiration time other than zero, the request is invalid, and the server MUST return a 400 (Invalid Request) and skip the remaining steps. If not, the registrar checks whether the Call-ID agrees with the value stored for each binding. If not, it MUST remove the binding. If it does agree, it MUST remove the binding only if the CSeq in the request is higher than the value stored for that binding. Otherwise, the update MUST be aborted and the request fails.",
      "ja": "前記登録要求は、コンタクトヘッダフィールドを含むかどうかをチェックします。そうでない場合には、最後のステップにスキップします。 Contactヘッダーフィールドが存在する場合は、レジストラのチェックが特別な値「*」が含まれている1つのContactフィールドの値があると、フィールドを満了した場合。リクエストがゼロ以外の追加の連絡先フィールドや有効期限を持っている場合、要求は無効であり、サーバは400（不正なリクエスト）を返し、残りの手順を省略しなければなりません。そうでない場合、レジストラチェックコールIDは、各結合について格納された値と一致するか否か。そうでない場合には、バインディングを削除する必要があります。それは同意しない場合は、リクエスト中のCSeqがその結合のために保存されている値よりも高い場合にのみ結合削除する必要があります。それ以外の場合、更新は中止されなければならないと要求は失敗します。"
    },
    {
      "indent": 6,
      "text": "7. The registrar now processes each contact address in the Contact header field in turn. For each address, it determines the expiration interval as follows:",
      "ja": "7.レジストラは現在、順番にContactヘッダーフィールド内の各連絡先アドレスを処理します。次のように各アドレスの場合は、有効期限の間隔を決定します。"
    },
    {
      "indent": 9,
      "text": "- If the field value has an \"expires\" parameter, that value MUST be taken as the requested expiration.",
      "ja": " - フィールドの値が「期限が切れる」のパラメータを持っている場合、その値は、要求された有効期限として扱わなければなりません。"
    },
    {
      "indent": 9,
      "text": "- If there is no such parameter, but the request has an Expires header field, that value MUST be taken as the requested expiration.",
      "ja": " - そこにはそのようなパラメータはありませんが、リクエストが期限切れヘッダフィールドを持っている場合、その値は、要求された有効期限として扱わなければなりません。"
    },
    {
      "indent": 9,
      "text": "- If there is neither, a locally-configured default value MUST be taken as the requested expiration.",
      "ja": " - どちらがある場合は、ローカルで構成されたデフォルト値は、要求された有効期限として扱わなければなりません。"
    },
    {
      "indent": 9,
      "text": "The registrar MAY choose an expiration less than the requested expiration interval. If and only if the requested expiration interval is greater than zero AND smaller than one hour AND less than a registrar-configured minimum, the registrar MAY reject the registration with a response of 423 (Interval Too Brief). This response MUST contain a Min-Expires header field that states the minimum expiration interval the registrar is willing to honor. It then skips the remaining steps.",
      "ja": "レジストラは、要求された有効期限の間隔よりも小さい有効期限を選ぶかもしれません。要求された期限切れ間隔は、レジストラ構成最小値よりゼロより大きく1より小さい時間未満である場合にのみ、レジストラ423（間隔すぎるブリーフ）の応答の登録を拒絶することがあります。この応答は、レジストラが尊重する意思がある最小有効期間を述べミン期限切れヘッダフィールドを含まなければなりません。その後、残りのステップをスキップします。"
    },
    {
      "indent": 9,
      "text": "Allowing the registrar to set the registration interval protects it against excessively frequent registration refreshes while limiting the state that it needs to maintain and decreasing the likelihood of registrations going stale. The expiration interval of a registration is frequently used in the creation of services. An example is a follow-me service, where the user may only be available at a terminal for a brief period. Therefore, registrars should accept brief registrations; a request should only be rejected if the interval is so short that the refreshes would degrade registrar performance.",
      "ja": "状態を制限しながらレジストラが登録間隔を設定できるようにすると、それは維持し、古い行く登録の可能性を減少する必要があることを過度に頻繁に登録の更新に対してそれを保護します。登録の有効期間は、頻繁にサービスの作成に使用されます。例では、ユーザーが唯一の短い期間のための端末で利用できるフォローミーサービス、です。したがって、レジストラが簡単な登録を受け入れる必要があります。間隔はリフレッシュがレジストラの性能を低下させるほど短い場合、要求は拒否されなければなりません。"
    },
    {
      "indent": 9,
      "text": "For each address, the registrar then searches the list of current bindings using the URI comparison rules. If the binding does not exist, it is tentatively added. If the binding does exist, the registrar checks the Call-ID value. If the Call-ID value in the existing binding differs from the Call-ID value in the request, the binding MUST be removed if the expiration time is zero and updated otherwise. If they are the same, the registrar compares the CSeq value. If the value is higher than that of the existing binding, it MUST update or remove the binding as above. If not, the update MUST be aborted and the request fails.",
      "ja": "各アドレスについて、レジストラは、URIの比較ルールを使用して、現在のバインディングのリストを検索します。バインディングが存在しない場合は、暫定的に追加されます。結合が存在する場合、レジストラは、Call-ID値をチェックします。有効期限がゼロで、そうでなければ更新された場合、要求のCall-ID値から既存のバインディング異なりのCall-ID値は、バインディングを削除する必要があります。それらが同じである場合、レジストラはのCSeq値を比較します。値が既存の結合よりも高い場合、それは上記のようにバインディングを更新または削除する必要があります。そうでない場合、更新は中止されなければならないと要求は失敗します。"
    },
    {
      "indent": 9,
      "text": "This algorithm ensures that out-of-order requests from the same UA are ignored.",
      "ja": "このアルゴリズムは、同じUAからのアウトオブオーダーの要求が無視されることが保証されます。"
    },
    {
      "indent": 9,
      "text": "Each binding record records the Call-ID and CSeq values from the request.",
      "ja": "各バインディングレコードは、リクエストからのCall-IDとのCSeq値を記録します。"
    },
    {
      "indent": 9,
      "text": "The binding updates MUST be committed (that is, made visible to the proxy or redirect server) if and only if all binding updates and additions succeed. If any one of them fails (for example, because the back-end database commit failed), the request MUST fail with a 500 (Server Error) response and all tentative binding updates MUST be removed.",
      "ja": "バインディングアップデートは、すべての結合の更新や追加が成功した場合だけ（つまり、プロキシに見えるようになるか、サーバーをリダイレクトされる）にコミットしなければなりません。それらのいずれかが（例えば、バックエンドデータベースが失敗したコミットので）失敗した場合、要求は500（サーバーエラー）応答で失敗しなければなりませんし、すべての暫定的なバインディングアップデートを削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "8. The registrar returns a 200 (OK) response. The response MUST contain Contact header field values enumerating all current bindings. Each Contact value MUST feature an \"expires\" parameter indicating its expiration interval chosen by the registrar. The response SHOULD include a Date header field.",
      "ja": "8.レジストラは、200（OK）レスポンスを返します。応答は、現在のすべてのバインディングを列挙するContactヘッダーフィールド値を含まなければなりません。各接点値はレジストラによって選ばれた有効期限間隔を示すパラメータを「期限が切れる」機能しなければなりません。応答はDateヘッダフィールドを含むべきです。"
    },
    {
      "indent": 0,
      "text": "11 Querying for Capabilities",
      "ja": "11能力の問い合わせ"
    },
    {
      "indent": 3,
      "text": "The SIP method OPTIONS allows a UA to query another UA or a proxy server as to its capabilities. This allows a client to discover information about the supported methods, content types, extensions, codecs, etc. without \"ringing\" the other party. For example, before a client inserts a Require header field into an INVITE listing an option that it is not certain the destination UAS supports, the client can query the destination UAS with an OPTIONS to see if this option is returned in a Supported header field. All UAs MUST support the OPTIONS method.",
      "ja": "SIPメソッドのOPTIONSは、UAは、その機能に関して、他のUAまたはプロキシサーバーを照会することができます。これにより、クライアントは、相手を「リンギング」なしでサポートされているメソッド、コンテンツタイプ、拡張子、コーデックなどの情報を発見することができます。クライアントは、それがUASがサポートしている先一定ではないというオプションをリストINVITEにRequireヘッダーフィールドを挿入する前に、たとえば、クライアントは、このオプションがサポートされているヘッダーフィールドで返されたかどうかを確認するためにオプションを使用して、宛先UASを照会することができます。すべてのUAはOPTIONSメソッドをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The target of the OPTIONS request is identified by the Request-URI, which could identify another UA or a SIP server. If the OPTIONS is addressed to a proxy server, the Request-URI is set without a user part, similar to the way a Request-URI is set for a REGISTER request.",
      "ja": "OPTIONS要求のターゲットは、他のUA又はSIPサーバを識別することができるのRequest-URIによって識別されます。 OPTIONSがプロキシサーバーにアドレス指定されている場合は、要求URIは要求URIがREGISTERリクエストのために設定されている方法と同じように、ユーザー部分なしで設定されています。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a server receiving an OPTIONS request with a Max-Forwards header field value of 0 MAY respond to the request regardless of the Request-URI.",
      "ja": "あるいは、0のMax-Forwardsヘッダフィールドの値とOPTIONS要求を受信したサーバに関係なくのRequest-URIの要求に応答することができます。"
    },
    {
      "indent": 6,
      "text": "This behavior is common with HTTP/1.1. This behavior can be used as a \"traceroute\" functionality to check the capabilities of individual hop servers by sending a series of OPTIONS requests with incremented Max-Forwards values.",
      "ja": "この動作は、HTTP / 1.1と共通です。この動作は、インクリメントマックス・フォワード値を持つOPTIONS要求のシリーズを送信することにより、個々のホップサーバーの能力を確認するために、「トレースルート」機能として使用することができます。"
    },
    {
      "indent": 3,
      "text": "As is the case for general UA behavior, the transaction layer can return a timeout error if the OPTIONS yields no response. This may indicate that the target is unreachable and hence unavailable.",
      "ja": "一般的なUA動作の場合のようにOPTIONSが何の応答が得られない場合は、トランザクション層は、タイムアウトエラーを返すことができます。これは、ターゲットに到達でき、したがって使用できないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "An OPTIONS request MAY be sent as part of an established dialog to query the peer on capabilities that may be utilized later in the dialog.",
      "ja": "OPTIONS要求は、ダイアログの後半で利用することができる能力にピアを照会するために設立され、ダイアログの一部として送信することができます。"
    },
    {
      "indent": 0,
      "text": "11.1 Construction of OPTIONS Request",
      "section_title": true,
      "ja": "OPTIONS要求の11.1建設"
    },
    {
      "indent": 3,
      "text": "An OPTIONS request is constructed using the standard rules for a SIP request as discussed in Section 8.1.1.",
      "ja": "セクション8.1.1で説明したようにOPTIONS要求は、SIP要求のための標準的なルールを使用して構築されています。"
    },
    {
      "indent": 3,
      "text": "A Contact header field MAY be present in an OPTIONS.",
      "ja": "Contactヘッダーフィールドは、オプションで存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "An Accept header field SHOULD be included to indicate the type of message body the UAC wishes to receive in the response. Typically, this is set to a format that is used to describe the media capabilities of a UA, such as SDP (application/sdp).",
      "ja": "Acceptヘッダーフィールドは、UACが応答で受信したいメッセージボディのタイプを示すために含まれるべきです。典型的には、これは、SDP（アプリケーション/ SDP）としてUAのメディア機能を記述するために使用されるフォーマットに設定されています。"
    },
    {
      "indent": 3,
      "text": "The response to an OPTIONS request is assumed to be scoped to the Request-URI in the original request. However, only when an OPTIONS is sent as part of an established dialog is it guaranteed that future requests will be received by the server that generated the OPTIONS response.",
      "ja": "OPTIONS要求への応答は、元の要求でのRequest-URIにスコープされているものとします。しかし、OPTIONSが確立し、ダイアログの一部として送信された場合にのみ、それは今後のリクエストがOPTIONS応答を生成し、サーバによって受信されることを保証されています。"
    },
    {
      "indent": 3,
      "text": "Example OPTIONS request:",
      "ja": "例OPTIONS要求："
    },
    {
      "indent": 6,
      "text": "OPTIONS sip:carol@chicago.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKhjhs8ass877 Max-Forwards: 70 To: <sip:carol@chicago.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 63104 OPTIONS Contact: <sip:alice@pc33.atlanta.com> Accept: application/sdp Content-Length: 0",
      "ja": "OPTIONSのSIP：carol@chicago.com SIP / 2.0経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKhjhs8ass877マックス・フォワード：70：<SIP：carol@chicago.com>から：アリス<SIP：アリス@ atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：63104 OPTIONS連絡先：<SIP：alice@pc33.atlanta.com>受け入れ：アプリケーション/ SDPのContent-Length：0"
    },
    {
      "indent": 0,
      "text": "11.2 Processing of OPTIONS Request",
      "section_title": true,
      "ja": "OPTIONS要求の11.2処理"
    },
    {
      "indent": 3,
      "text": "The response to an OPTIONS is constructed using the standard rules for a SIP response as discussed in Section 8.2.6. The response code chosen MUST be the same that would have been chosen had the request been an INVITE. That is, a 200 (OK) would be returned if the UAS is ready to accept a call, a 486 (Busy Here) would be returned if the UAS is busy, etc. This allows an OPTIONS request to be used to determine the basic state of a UAS, which can be an indication of whether the UAS will accept an INVITE request.",
      "ja": "セクション8.2.6で説明したようにOPTIONSへの応答は、SIP応答のための標準的なルールを使用して構築されています。選択した応答コードが選ばれていたであろうものと同じでなければならないINVITE要求されてました。 UASがコールを受け入れる準備ができている場合には、200（OK）これは基本的に決定するために使用するOPTIONS要求を許可するなど、UASがビジー状態の場合（ここではビジー）486が返されます、返されるされますUASは、INVITE要求を受け入れるかどうかの指標であり得るUASの状態。"
    },
    {
      "indent": 3,
      "text": "An OPTIONS request received within a dialog generates a 200 (OK) response that is identical to one constructed outside a dialog and does not have any impact on the dialog.",
      "ja": "OPTIONS要求は、ダイアログ内で受信ダイアログの外側に構成したものと同じであり、ダイアログ上の任意の影響を持っていない200（OK）レスポンスを生成します。"
    },
    {
      "indent": 3,
      "text": "This use of OPTIONS has limitations due to the differences in proxy handling of OPTIONS and INVITE requests. While a forked INVITE can result in multiple 200 (OK) responses being returned, a forked OPTIONS will only result in a single 200 (OK) response, since it is treated by proxies using the non-INVITE handling. See Section 16.7 for the normative details.",
      "ja": "OPTIONSのこの使用は、OPTIONSのプロキシ処理の違いによる制限とINVITEリクエストを持っています。複数の200（OK）応答をもたらすことができるINVITE二股戻されながら、それが取り扱う非INVITE用いプロキシによって処理されるので、二股のオプションは、単一の200（OK）応答をもたらすであろう。規範的な詳細は項16.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the response to an OPTIONS is generated by a proxy server, the proxy returns a 200 (OK), listing the capabilities of the server. The response does not contain a message body.",
      "ja": "OPTIONSに対する応答がプロキシサーバーによって生成されている場合は、プロキシサーバの機能を列挙し、（OK）200を返します。応答は、メッセージ本体が含まれていません。"
    },
    {
      "indent": 3,
      "text": "Allow, Accept, Accept-Encoding, Accept-Language, and Supported header fields SHOULD be present in a 200 (OK) response to an OPTIONS request. If the response is generated by a proxy, the Allow header field SHOULD be omitted as it is ambiguous since a proxy is method agnostic. Contact header fields MAY be present in a 200 (OK) response and have the same semantics as in a 3xx response. That is, they may list a set of alternative names and methods of reaching the user. A Warning header field MAY be present.",
      "ja": "受け入れ言語、符号化を受け入れ、受け入れ、許可、およびサポートされているヘッダフィールドはOPTIONS要求への200（OK）応答で存在すべきです。応答がプロキシによって生成された場合、プロキシは方法とらわれないので、それは曖昧であるように、許可ヘッダーフィールドは省略されるべきです。 Contactヘッダフィールドは200（OK）応答中に存在し、3xx応答と同じ意味を持っているかもしれません。つまり、彼らがユーザーに届くの代替名とメソッドのセットをリストすることがあります。警告ヘッダフィールドが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "A message body MAY be sent, the type of which is determined by the Accept header field in the OPTIONS request (application/sdp is the default if the Accept header field is not present). If the types include one that can describe media capabilities, the UAS SHOULD include a body in the response for that purpose. Details on the construction of such a body in the case of application/sdp are described in [13].",
      "ja": "メッセージ本体は、OPTIONS要求（Acceptヘッダーフィールドが存在しない場合、アプリケーション/ SDPはデフォルトである）でAcceptヘッダーフィールドによって決定されるのタイプを送ってもよいです。タイプはメディア機能を記述することができるものが含まれている場合、UASは、その目的のために反応して体を含むべきです。アプリケーション/ SDPの場合には、身体の構造上の詳細は[13]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Example OPTIONS response generated by a UAS (corresponding to the request in Section 11.1):",
      "ja": "UAS（セクション11.1で要求に対応する）によって生成された実施例OPTIONS応答："
    },
    {
      "indent": 6,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKhjhs8ass877 ;received=192.0.2.4 To: <sip:carol@chicago.com>;tag=93810874 From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 63104 OPTIONS Contact: <sip:carol@chicago.com> Contact: <mailto:carol@chicago.com> Allow: INVITE, ACK, CANCEL, OPTIONS, BYE Accept: application/sdp Accept-Encoding: gzip Accept-Language: en Supported: foo Content-Type: application/sdp Content-Length: 274",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKhjhs8ass877は、受信= 192.0.2.4へ：<SIP：carol@chicago.com>;タグ= 93810874から：アリス<SIP：アリス@ atlanta.com>;タグ= 1928301774のCall-ID：のCSeq a84b4c76e66710：63104 OPTIONS連絡先：<SIP：carol@chicago.com>連絡先：<mailtoの：carol@chicago.com>は許可：BYE、INVITE、ACK、CANCEL、OPTIONS受け入れ：アプリケーション/ SDPは受け入れ-エンコード：gzipでは受け入れ-言語：fooというのContent-Type：アプリケーション/ SDPのContent-Length：274サポートされているエン"
    },
    {
      "indent": 6,
      "text": "(SDP not shown)",
      "ja": "（SDP図示せず）"
    },
    {
      "indent": 0,
      "text": "12 Dialogs",
      "ja": "12のダイアログ"
    },
    {
      "indent": 3,
      "text": "A key concept for a user agent is that of a dialog. A dialog represents a peer-to-peer SIP relationship between two user agents that persists for some time. The dialog facilitates sequencing of messages between the user agents and proper routing of requests between both of them. The dialog represents a context in which to interpret SIP messages. Section 8 discussed method independent UA processing for requests and responses outside of a dialog. This section discusses how those requests and responses are used to construct a dialog, and then how subsequent requests and responses are sent within a dialog.",
      "ja": "ユーザーエージェントのための重要な概念は、ダイアログのものです。ダイアログは、しばらくの間持続する2つのユーザエージェント間のピアツーピアのSIP関係を表しています。ダイアログには、ユーザエージェントと両者の要求の適切なルーティングの間のメッセージの順序付けを容易にします。ダイアログには、SIPメッセージを解釈するコンテキストを表します。第8章では、ダイアログの外で要求と応答のための方法の独立したUA処理について議論しました。ここでは、これらの要求と応答がダイアログを構築するために使用されている方法について説明し、ダイアログ内で送信され、その後どのように後続の要求と応答。"
    },
    {
      "indent": 3,
      "text": "A dialog is identified at each UA with a dialog ID, which consists of a Call-ID value, a local tag and a remote tag. The dialog ID at each UA involved in the dialog is not the same. Specifically, the local tag at one UA is identical to the remote tag at the peer UA. The tags are opaque tokens that facilitate the generation of unique dialog IDs.",
      "ja": "ダイアログは、コールID値、ローカルタグとリモートタグから成るダイアログID、各UAで識別されます。ダイアログに関係する各UAのダイアログIDは同じではありません。具体的には、一UAにおけるローカルタグは、ピアUAにおけるリモートタグと同一です。タグは、ユニークなダイアログIDの生成を容易に不透明なトークンです。"
    },
    {
      "indent": 3,
      "text": "A dialog ID is also associated with all responses and with any request that contains a tag in the To field. The rules for computing the dialog ID of a message depend on whether the SIP element is a UAC or UAS. For a UAC, the Call-ID value of the dialog ID is set to the Call-ID of the message, the remote tag is set to the tag in the To field of the message, and the local tag is set to the tag in the From field of the message (these rules apply to both requests and responses). As one would expect for a UAS, the Call-ID value of the dialog ID is set to the Call-ID of the message, the remote tag is set to the tag in the From field of the message, and the local tag is set to the tag in the To field of the message.",
      "ja": "ダイアログIDは、すべての応答とし、Toフィールド内のタグを含むすべての要求に関連付けられています。メッセージのダイアログIDを計算するためのルールは、SIPエレメントがUACまたはUASであるかどうかに依存します。 UACは、ダイアログIDのコールID値はメッセージのCall-IDに設定されている、遠隔タグは、メッセージのToフィールド内のタグに設定され、ローカルタグは、タグに設定されていますメッセージのFromフィールド（これらのルールは、両方の要求と応答に適用されます）。 1がUASのために予想されるように、ダイアログIDのCall-IDを値はメッセージのCall-IDに設定され、リモートタグはメッセージのFromフィールド内のタグに設定され、地元のタグが設定されていますメッセージのToフィールド内のタグに。"
    },
    {
      "indent": 3,
      "text": "A dialog contains certain pieces of state needed for further message transmissions within the dialog. This state consists of the dialog ID, a local sequence number (used to order requests from the UA to its peer), a remote sequence number (used to order requests from its peer to the UA), a local URI, a remote URI, remote target, a boolean flag called \"secure\", and a route set, which is an ordered list of URIs. The route set is the list of servers that need to be traversed to send a request to the peer. A dialog can also be in the \"early\" state, which occurs when it is created with a provisional response, and then transition to the \"confirmed\" state when a 2xx final response arrives. For other responses, or if no response arrives at all on that dialog, the early dialog terminates.",
      "ja": "ダイアログは、ダイアログ内で、さらにメッセージ送信のために必要な状態の特定の部分が含まれています。この状態は、ダイアログIDで構成され、（そのピアのUAからの要求を注文するために使用される）は、ローカルシーケンス番号（UAのピアからの要求を注文するために使用される）、リモートシーケンス番号、ローカルURI、リモートURI、リモートターゲット、「安全」と呼ばれるブールフラグ、およびURIの順序付きリストであるルートセット、。ルートセットは、ピアへの要求を送信するために横断する必要があるサーバのリストです。ダイアログには、それが暫定応答を使用して作成されたときに発生する「早期」状態であること、そして2XX最終応答が到着したときの状態を「確認」に移行することができます。他の応答のために、または応答がそのダイアログ上ですべて到着していない場合は、初期のダイアログが終了します。"
    },
    {
      "indent": 0,
      "text": "12.1 Creation of a Dialog",
      "section_title": true,
      "ja": "ダイアログの12.1作成"
    },
    {
      "indent": 3,
      "text": "Dialogs are created through the generation of non-failure responses to requests with specific methods. Within this specification, only 2xx and 101-199 responses with a To tag, where the request was INVITE, will establish a dialog. A dialog established by a non-final response to a request is in the \"early\" state and it is called an early dialog. Extensions MAY define other means for creating dialogs. Section 13 gives more details that are specific to the INVITE method. Here, we describe the process for creation of dialog state that is not dependent on the method.",
      "ja": "ダイアログは、特定のメソッドを持つ要求に非障害応答の生成を介して作成されます。リクエストがINVITEだった、タグ、この仕様書の中で、唯一の2xxや101から199応答、ダイアログを確立します。リクエストへの非最終応答によって確立されたダイアログは、「早期」状態にあり、それが早期ダイアログと呼ばれています。拡張機能は、ダイアログを作成するための他の手段を定義することができます。第13節は、INVITEメソッドに固有の詳細を提供します。ここでは、方法に依存しない対話状態を作成するためのプロセスを説明します。"
    },
    {
      "indent": 3,
      "text": "UAs MUST assign values to the dialog ID components as described below.",
      "ja": "以下に説明するようにUAはダイアログIDコンポーネントに値を割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "12.1.1 UAS behavior",
      "section_title": true,
      "ja": "12.1.1 THAT行動"
    },
    {
      "indent": 3,
      "text": "When a UAS responds to a request with a response that establishes a dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route header field values from the request into the response (including the URIs, URI parameters, and any Record-Route header field parameters, whether they are known or unknown to the UAS) and MUST maintain the order of those values. The UAS MUST add a Contact header field to the response. The Contact header field contains an address where the UAS would like to be contacted for subsequent requests in the dialog (which includes the ACK for a 2xx response in the case of an INVITE). Generally, the host portion of this URI is the IP address or FQDN of the host. The URI provided in the Contact header field MUST be a SIP or SIPS URI. If the request that initiated the dialog contained a",
      "ja": "UASは、（例えば、INVITEための2xxのような）ダイアログを確立応答して要求に応答するとき、UASは、URIに、URIパラメータを含む応答（及び任意に要求からすべてのRecord-Routeヘッダフィールド値をコピーする必要がありますそれらが知られているか、またはUASに知られていないかどうかをレコードルートヘッダフィールドパラメータ）とそれらの値の順序を維持しなければなりません。 UASは、応答にContactヘッダーフィールドを追加する必要があります。 Contactヘッダーフィールドは、UASは、（INVITEの場合は2xx応答に対するACKを含む）ダイアログの後続の要求のために接触させることを希望アドレスを含みます。一般的に、このURIのホスト部分は、ホストのIPアドレスまたはFQDNです。 Contactヘッダーフィールド内に設けられたURIは、SIPであるか、またはURIをSIPSしなければなりません。ダイアログを開始した要求が含まれている場合"
    },
    {
      "indent": 3,
      "text": "SIPS URI in the Request-URI or in the top Record-Route header field value, if there was any, or the Contact header field if there was no Record-Route header field, the Contact header field in the response MUST be a SIPS URI. The URI SHOULD have global scope (that is, the same URI can be used in messages outside this dialog). The same way, the scope of the URI in the Contact header field of the INVITE is not limited to this dialog either. It can therefore be used in messages to the UAC even outside this dialog.",
      "ja": "何Record-Routeヘッダフィールドがなかった場合は、任意の、またはContactヘッダーフィールドがあった場合、応答のContactヘッダフィールドはSIPS URIでなければなりません、リクエストURIまたはトップレコードルートヘッダフィールド値にURIをSIPS 。 URIは、グローバルスコープ（つまり、同じURIは、このダイアログ外のメッセージで使用することができます）を持つ必要があります。同じように、INVITEのContactヘッダーフィールドのURIの範囲は、いずれか、このダイアログに限定されるものではありません。したがって、でも、このダイアログ外のUACへのメッセージで使用することができます。"
    },
    {
      "indent": 3,
      "text": "The UAS then constructs the state of the dialog. This state MUST be maintained for the duration of the dialog.",
      "ja": "UASは、ダイアログの状態を構築します。この状態は、ダイアログの間維持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the request arrived over TLS, and the Request-URI contained a SIPS URI, the \"secure\" flag is set to TRUE.",
      "ja": "リクエストがTLS上で到着し、リクエスト-URIがSIPS URIを含んでいた場合は、「安全な」フラグがTRUEに設定されています。"
    },
    {
      "indent": 3,
      "text": "The route set MUST be set to the list of URIs in the Record-Route header field from the request, taken in order and preserving all URI parameters. If no Record-Route header field is present in the request, the route set MUST be set to the empty set. This route set, even if empty, overrides any pre-existing route set for future requests in this dialog. The remote target MUST be set to the URI from the Contact header field of the request.",
      "ja": "ルートセットは、リクエストからRecord-Routeヘッダフィールド内のURIの一覧に設定された順序に入れ、すべてのURIパラメータを維持しなければなりません。何Record-Routeヘッダフィールドがリクエスト中に存在しない場合、ルートセットが空集合に設定しなければなりません。このルートセットは、でも空の場合、このダイアログの今後のリクエストのための任意の既存のルートセットを上書きします。リモートターゲットは、要求のContactヘッダフィールドからURIに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The remote sequence number MUST be set to the value of the sequence number in the CSeq header field of the request. The local sequence number MUST be empty. The call identifier component of the dialog ID MUST be set to the value of the Call-ID in the request. The local tag component of the dialog ID MUST be set to the tag in the To field in the response to the request (which always includes a tag), and the remote tag component of the dialog ID MUST be set to the tag from the From field in the request. A UAS MUST be prepared to receive a request without a tag in the From field, in which case the tag is considered to have a value of null.",
      "ja": "リモートシーケンス番号は、リクエストのCSeqヘッダーフィールド内のシーケンス番号の値に設定しなければなりません。ローカルシーケンス番号は空である必要があります。ダイアログIDの呼識別子のコンポーネントは、リクエストのCall-IDの値に設定しなければなりません。ダイアログIDのローカルタグ要素は、（常にタグを含む）の要求に応じて、フィールドにタグを設定しなければなりません、そしてダイアログIDのリモートタグ要素からからタグに設定しなければなりませんリクエスト内のフィールド。 UASは、タグがNULLの値を持つと考えられる場合には、フィールドからタグなしの要求を受信するように準備しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This is to maintain backwards compatibility with RFC 2543, which did not mandate From tags.",
      "ja": "これはタグから必須ではありませんでしたRFC 2543、との下位互換性を維持することです。"
    },
    {
      "indent": 3,
      "text": "The remote URI MUST be set to the URI in the From field, and the local URI MUST be set to the URI in the To field.",
      "ja": "リモートURIは、FromフィールドにURIに設定しなければならなくて、そして地元のURIはToフィールドにURIを設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.1.2 UAC Behavior",
      "section_title": true,
      "ja": "12.1.2 UACの動作"
    },
    {
      "indent": 3,
      "text": "When a UAC sends a request that can establish a dialog (such as an INVITE) it MUST provide a SIP or SIPS URI with global scope (i.e., the same SIP URI can be used in messages outside this dialog) in the Contact header field of the request. If the request has a Request-URI or a topmost Route header field value with a SIPS URI, the Contact header field MUST contain a SIPS URI.",
      "ja": "UACは、SIPを提供しなければなりません（例えば、INVITEのような）ダイアログを確立する要求を送信するかのContactヘッダーフィールドのグローバルスコープ（すなわち、同じSIP URIこのダイアログ外のメッセージに使用することができる）を有するURIをSIPS場合リクエスト。要求が要求URIまたはSIPS URIを持つ最初のRouteヘッダーフィールド値を持っている場合は、ContactヘッダーフィールドはSIPS URIを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a UAC receives a response that establishes a dialog, it constructs the state of the dialog. This state MUST be maintained for the duration of the dialog.",
      "ja": "UACは、ダイアログを確立し、応答を受信すると、ダイアログの状態を構築します。この状態は、ダイアログの間維持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the request was sent over TLS, and the Request-URI contained a SIPS URI, the \"secure\" flag is set to TRUE.",
      "ja": "リクエストがTLSを介して送信され、そしてリクエスト-URIがSIPS URIを含んでいた場合は、「安全な」フラグがTRUEに設定されています。"
    },
    {
      "indent": 3,
      "text": "The route set MUST be set to the list of URIs in the Record-Route header field from the response, taken in reverse order and preserving all URI parameters. If no Record-Route header field is present in the response, the route set MUST be set to the empty set. This route set, even if empty, overrides any pre-existing route set for future requests in this dialog. The remote target MUST be set to the URI from the Contact header field of the response.",
      "ja": "ルートセットは、応答からRecord-Routeヘッダフィールド内のURIの一覧に設定され、逆の順序で採取し、すべてのURIパラメータを維持しなければなりません。何Record-Routeヘッダフィールドが応答中に存在しない場合、ルートセットが空集合に設定しなければなりません。このルートセットは、でも空の場合、このダイアログの今後のリクエストのための任意の既存のルートセットを上書きします。リモートターゲットは、応答のContactヘッダフィールドからURIに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The local sequence number MUST be set to the value of the sequence number in the CSeq header field of the request. The remote sequence number MUST be empty (it is established when the remote UA sends a request within the dialog). The call identifier component of the dialog ID MUST be set to the value of the Call-ID in the request. The local tag component of the dialog ID MUST be set to the tag in the From field in the request, and the remote tag component of the dialog ID MUST be set to the tag in the To field of the response. A UAC MUST be prepared to receive a response without a tag in the To field, in which case the tag is considered to have a value of null.",
      "ja": "ローカルシーケンス番号は、リクエストのCSeqヘッダーフィールド内のシーケンス番号の値に設定しなければなりません。リモートシーケンス番号は（遠隔UAは、ダイアログ内のリクエストを送信した場合、それは確立されている）が空でなければなりません。ダイアログIDの呼識別子のコンポーネントは、リクエストのCall-IDの値に設定しなければなりません。ダイアログIDのローカルタグ要素は、要求のフィールドからタグに設定しなければなりません、そしてダイアログIDのリモートタグ要素は、応答のToフィールド内のタグに設定しなければなりません。 UACは、タグがNULLの値を持つと考えられる場合に、フィールド内のタグなし応答を受信するように準備しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This is to maintain backwards compatibility with RFC 2543, which did not mandate To tags.",
      "ja": "これは、タグに必須ではありませんでしたRFC 2543、との下位互換性を維持することです。"
    },
    {
      "indent": 3,
      "text": "The remote URI MUST be set to the URI in the To field, and the local URI MUST be set to the URI in the From field.",
      "ja": "リモートURIには、ToフィールドにURIを設定しなければならなくて、地元のURIは、FromフィールドにURIを設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.2 Requests within a Dialog",
      "section_title": true,
      "ja": "ダイアログ内の12.2要望"
    },
    {
      "indent": 3,
      "text": "Once a dialog has been established between two UAs, either of them MAY initiate new transactions as needed within the dialog. The UA sending the request will take the UAC role for the transaction. The UA receiving the request will take the UAS role. Note that these may be different roles than the UAs held during the transaction that established the dialog.",
      "ja": "ダイアログは2つのUA間で確立された後、ダイアログ内で必要として、それらのいずれかは、新しいトランザクションを開始することができます。 UAは、トランザクションのためのUACの役割を取るリクエストを送信します。要求を受信したUAは、UASの役割を担うことになります。これらは、ダイアログを確立し、トランザクション中に開催されたのUAとは異なる役割であってもよいことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Requests within a dialog MAY contain Record-Route and Contact header fields. However, these requests do not cause the dialog's route set to be modified, although they may modify the remote target URI. Specifically, requests that are not target refresh requests do not modify the dialog's remote target URI, and requests that are target refresh requests do. For dialogs that have been established with an",
      "ja": "ダイアログ内のリクエストは録音・ルートおよびContactヘッダーフィールドを含むかもしれません。彼らは、リモートターゲットURIを修正するかもしれないがしかし、これらの要求は、ダイアログのルートセットが変更されることはありません。具体的には、リフレッシュ要求をターゲットとしていないリクエストはダイアログのリモートターゲットURIを変更しないと、ターゲットリフレッシュ要求される要求が行います。で確立されたダイアログの"
    },
    {
      "indent": 3,
      "text": "INVITE, the only target refresh request defined is re-INVITE (see Section 14). Other extensions may define different target refresh requests for dialogs established in other ways.",
      "ja": "INVITE、定義された唯一のターゲットリフレッシュ要求（セクション14を参照）-INVITE再されます。その他の拡張機能は、他の方法で設立されたダイアログのための別のターゲットリフレッシュ要求を定義することもできます。"
    },
    {
      "indent": 6,
      "text": "Note that an ACK is NOT a target refresh request.",
      "ja": "ACKはターゲットリフレッシュ要求ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Target refresh requests only update the dialog's remote target URI, and not the route set formed from the Record-Route. Updating the latter would introduce severe backwards compatibility problems with RFC 2543-compliant systems.",
      "ja": "ターゲットリフレッシュリクエストはダイアログのリモートターゲットURIではなく、レコード・ルートから形成されたルートセットを更新します。後者を更新すると、RFC 2543に準拠したシステムとの深刻な後方互換性の問題を導入します。"
    },
    {
      "indent": 0,
      "text": "12.2.1 UAC Behavior",
      "section_title": true,
      "ja": "12.2.1 UACの動作"
    },
    {
      "indent": 0,
      "text": "12.2.1.1 Generating the Request",
      "section_title": true,
      "ja": "要求の作成12.2.1.1"
    },
    {
      "indent": 3,
      "text": "A request within a dialog is constructed by using many of the components of the state stored as part of the dialog.",
      "ja": "ダイアログ内のリクエストは、ダイアログの一部として格納された状態の構成要素の多くを用いて構成されています。"
    },
    {
      "indent": 3,
      "text": "The URI in the To field of the request MUST be set to the remote URI from the dialog state. The tag in the To header field of the request MUST be set to the remote tag of the dialog ID. The From URI of the request MUST be set to the local URI from the dialog state. The tag in the From header field of the request MUST be set to the local tag of the dialog ID. If the value of the remote or local tags is null, the tag parameter MUST be omitted from the To or From header fields, respectively.",
      "ja": "リクエストのToフィールドにおけるURIは、ダイアログの状態からのリモートURIに設定しなければなりません。リクエストのヘッダにフィールド内のタグは、ダイアログIDのリモートタグに設定しなければなりません。リクエストのURIからダイアログの状態からローカルURIに設定しなければなりません。リクエストのFromヘッダフィールド内のタグは、ダイアログIDのローカルタグに設定しなければなりません。リモートまたはローカルタグの値がnullの場合、タグのパラメータは、それぞれ、Toまたはからヘッダフィールドを省略しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Usage of the URI from the To and From fields in the original request within subsequent requests is done for backwards compatibility with RFC 2543, which used the URI for dialog identification. In this specification, only the tags are used for dialog identification. It is expected that mandatory reflection of the original To and From URI in mid-dialog requests will be deprecated in a subsequent revision of this specification.",
      "ja": "後続の要求内の元の要求のフィールドからURIの使用は、ダイアログ識別のためにURIを使用RFC 2543との後方互換性のために行われます。この仕様では、タグのみをダイアログ識別のために使用されています。ダイアログ中のリクエストでURIへとから元の必須反射がこの仕様のその後の改正で廃止されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The Call-ID of the request MUST be set to the Call-ID of the dialog. Requests within a dialog MUST contain strictly monotonically increasing and contiguous CSeq sequence numbers (increasing-by-one) in each direction (excepting ACK and CANCEL of course, whose numbers equal the requests being acknowledged or cancelled). Therefore, if the local sequence number is not empty, the value of the local sequence number MUST be incremented by one, and this value MUST be placed into the CSeq header field. If the local sequence number is empty, an initial value MUST be chosen using the guidelines of Section 8.1.1.5. The method field in the CSeq header field value MUST match the method of the request.",
      "ja": "リクエストのコール-IDは、ダイアログのコール-IDに設定しなければなりません。ダイアログ内のリクエストは、各方向（増加-ずつ）のCSeqシーケンス番号を増加させ、連続厳密に単調含む（ACKを除くもちろんCANCEL、その番号が確認応答またはキャンセルされる要求を等しく）しなければなりません。ローカルシーケンス番号が空でない場合したがって、ローカルシーケンス番号の値は1だけ増分されなければならない、この値はCSeqヘッダーフィールドに置かれなければなりません。ローカルシーケンス番号が空の場合、初期値は、セクション8.1.1.5のガイドラインを使用して選ばなければなりません。 CSeqヘッダーフィールド値のメソッドフィールドは、要求の方法と一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "With a length of 32 bits, a client could generate, within a single call, one request a second for about 136 years before needing to wrap around. The initial value of the sequence number is chosen so that subsequent requests within the same call will not wrap around. A non-zero initial value allows clients to use a time-based initial sequence number. A client could, for example, choose the 31 most significant bits of a 32-bit second clock as an initial sequence number.",
      "ja": "32ビットの長さでは、クライアントは、単一コール内で、ラップアラウンドする必要が前におよそ136年の二つの要求を生成することができます。同じ呼び出し内の後続の要求がラップアラウンドしないように、シーケンス番号の初期値が選択されています。非ゼロの初期値は、クライアントが時間ベースの初期シーケンス番号を使用することを可能にします。クライアントは、例えば、初期シーケンス番号として32ビットの第2のクロックの31個の最上位ビットを選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "The UAC uses the remote target and route set to build the Request-URI and Route header field of the request.",
      "ja": "UACは、Request-URI、要求のRouteヘッダフィールドを構築するように設定リモートターゲットおよび経路を使用します。"
    },
    {
      "indent": 3,
      "text": "If the route set is empty, the UAC MUST place the remote target URI into the Request-URI. The UAC MUST NOT add a Route header field to the request.",
      "ja": "ルートセットが空の場合、UACは、Request-URIにリモートターゲットURIを置かなければなりません。 UACは、リクエストにRouteヘッダーフィールドを追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the route set is not empty, and the first URI in the route set contains the lr parameter (see Section 19.1.1), the UAC MUST place the remote target URI into the Request-URI and MUST include a Route header field containing the route set values in order, including all parameters.",
      "ja": "ルートセットが空でない、およびルートセットの最初のURIがLRパラメータが含まれている場合、UACがRequest-URIにリモートターゲットURIを配置しなければならない（セクション19.1.1参照）とを含有するRouteヘッダフィールドを含まなければなりませんルートは、すべてのパラメータを含め、順番に値を設定します。"
    },
    {
      "indent": 3,
      "text": "If the route set is not empty, and its first URI does not contain the lr parameter, the UAC MUST place the first URI from the route set into the Request-URI, stripping any parameters that are not allowed in a Request-URI. The UAC MUST add a Route header field containing the remainder of the route set values in order, including all parameters. The UAC MUST then place the remote target URI into the Route header field as the last value.",
      "ja": "ルートセットが空ではない、そしてその最初のURIがLRパラメータが含まれていない場合、UACは、Request-URIで許可されていない任意のパラメータをストリッピング、要求URIに設定された経路からの最初のURIを置かなければなりません。 UACは、すべてのパラメータを含むためにルート設定値の残りを含有するRouteヘッダフィールドを追加しなければなりません。 UACは、最後の値としてRouteヘッダーフィールドにリモートターゲットURIを配置しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, if the remote target is sip:user@remoteua and the route set contains:",
      "ja": "例えば、リモートターゲットは、SIPの場合：ユーザーの@ remoteuaとルートセットが含まれています。"
    },
    {
      "indent": 6,
      "text": "<sip:proxy1>,<sip:proxy2>,<sip:proxy3;lr>,<sip:proxy4>",
      "ja": "<SIP：プロキシ>、<SIP：プロキシ>、<SIP：プロキシ3; LR>、<SIP：proxy4>"
    },
    {
      "indent": 3,
      "text": "The request will be formed with the following Request-URI and Route header field:",
      "ja": "リクエストは、次のRequest-URIとRouteヘッダーフィールドを用いて形成されます。"
    },
    {
      "indent": 3,
      "text": "METHOD sip:proxy1 Route: <sip:proxy2>,<sip:proxy3;lr>,<sip:proxy4>,<sip:user@remoteua>",
      "ja": "METHODのSIP：PROXY1ルート：<SIP：プロキシ>、<SIP：プロキシ3; LR>、<SIP：プロキシ>、<一口ます。user @ remoteua>"
    },
    {
      "indent": 6,
      "text": "If the first URI of the route set does not contain the lr parameter, the proxy indicated does not understand the routing mechanisms described in this document and will act as specified in RFC 2543, replacing the Request-URI with the first Route header field value it receives while forwarding the message. Placing the Request-URI at the end of the Route header field preserves the information in that Request-URI across the strict router (it will be returned to the Request-URI when the request reaches a loose-router).",
      "ja": "ルートセットの最初のURIがLRパラメータが含まれていない場合、示されたプロキシは、本書では説明ルーティングメカニズムを理解していないと、RFC 2543で指定されるように作用し、それは最初のRouteヘッダフィールド値とのRequest-URIを交換しますメッセージを転送しながら受信します。厳密ルータを横断することを要求-URIの情報はRouteヘッダーフィールドの最後でのRequest-URIを保存する配置（要求がルーズルータに到達したときには、Request-URIに戻されます）。"
    },
    {
      "indent": 3,
      "text": "A UAC SHOULD include a Contact header field in any target refresh requests within a dialog, and unless there is a need to change it, the URI SHOULD be the same as used in previous requests within the dialog. If the \"secure\" flag is true, that URI MUST be a SIPS URI. As discussed in Section 12.2.2, a Contact header field in a target refresh request updates the remote target URI. This allows a UA to provide a new contact address, should its address change during the duration of the dialog.",
      "ja": "UACは、ダイアログ内の任意のターゲットリフレッシュ要求にContactヘッダーフィールドを含むべきであるし、それを変更する必要がある場合を除き、URIには、ダイアログ内の以前の要求で使用したものと同じであるべきです。 「安全な」フラグは、URIがSIPS URIでなければならないことを、trueの場合。 12.2.2項で説明したように、ターゲットリフレッシュ要求におけるContactヘッダフィールドは、リモートターゲットURIを更新します。これは、そのアドレスの変更は、ダイアログの期間中、UAは、新しい連絡先アドレスを提供する必要があることができます。"
    },
    {
      "indent": 3,
      "text": "However, requests that are not target refresh requests do not affect the remote target URI for the dialog.",
      "ja": "しかし、リフレッシュ要求をターゲットとしていないリクエストはダイアログのリモートターゲットURIには影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The rest of the request is formed as described in Section 8.1.1.",
      "ja": "セクション8.1.1で説明したように、要求の残りの部分が形成されています。"
    },
    {
      "indent": 3,
      "text": "Once the request has been constructed, the address of the server is computed and the request is sent, using the same procedures for requests outside of a dialog (Section 8.1.2).",
      "ja": "要求が構築されたら、サーバのアドレスが計算され、要求が外部ダイアログ（セクション8.1.2）の要求のために同じ手順を使用して、送信されます。"
    },
    {
      "indent": 6,
      "text": "The procedures in Section 8.1.2 will normally result in the request being sent to the address indicated by the topmost Route header field value or the Request-URI if no Route header field is present. Subject to certain restrictions, they allow the request to be sent to an alternate address (such as a default outbound proxy not represented in the route set).",
      "ja": "セクション8.1.2の手順は、通常、NOルートヘッダーフィールドが存在しない場合、最上位のルートヘッダフィールド値またはリクエストURIが示すアドレスに送信される要求をもたらすであろう。一定の制限を受け、彼らは、要求が（例えば、ルートセットに示されていないデフォルトのアウトバウンドプロキシとして）代替アドレスに送信されることを可能にします。"
    },
    {
      "indent": 0,
      "text": "12.2.1.2 Processing the Responses",
      "section_title": true,
      "ja": "12.2.1.2応答の処理"
    },
    {
      "indent": 3,
      "text": "The UAC will receive responses to the request from the transaction layer. If the client transaction returns a timeout, this is treated as a 408 (Request Timeout) response.",
      "ja": "UACは、トランザクション層からの要求に対する応答を受信します。クライアントトランザクションがタイムアウトを返す場合、これは408（要求タイムアウト）応答として扱われます。"
    },
    {
      "indent": 3,
      "text": "The behavior of a UAC that receives a 3xx response for a request sent within a dialog is the same as if the request had been sent outside a dialog. This behavior is described in Section 8.1.3.4.",
      "ja": "リクエストはダイアログ外で送られてきたかのように、ダイアログ内で送信要求に対する3xx応答を受け取るUACの動作は同じです。この動作は、セクション8.1.3.4に記載されています。"
    },
    {
      "indent": 6,
      "text": "Note, however, that when the UAC tries alternative locations, it still uses the route set for the dialog to build the Route header of the request.",
      "ja": "UACは、代替場所をしようとしたとき、それはまだリクエストのRouteヘッダを構築するためのダイアログのルートセットを使用していること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "When a UAC receives a 2xx response to a target refresh request, it MUST replace the dialog's remote target URI with the URI from the Contact header field in that response, if present.",
      "ja": "UACは、ターゲットリフレッシュリクエストに対する2xx応答を受信した場合に存在する場合、それは、その応答のContactヘッダーフィールドからURIをダイアログのリモートターゲットURIを交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the response for a request within a dialog is a 481 (Call/Transaction Does Not Exist) or a 408 (Request Timeout), the UAC SHOULD terminate the dialog. A UAC SHOULD also terminate a dialog if no response at all is received for the request (the client transaction would inform the TU about the timeout.)",
      "ja": "ダイアログ内のリクエストに対するレスポンスは481（コール/トランザクションが存在しない）または408（要求タイムアウト）である場合、UACはダイアログを終了する必要があります。全く応答が要求のために受信されない場合UACはまた、ダイアログを終了すべきである（クライアントトランザクションがタイムアウトについてTUに通知します。）"
    },
    {
      "indent": 6,
      "text": "For INVITE initiated dialogs, terminating the dialog consists of sending a BYE.",
      "ja": "INVITE開始ダイアログでは、ダイアログを終了すると、BYEを送ることで構成されています。"
    },
    {
      "indent": 0,
      "text": "12.2.2 UAS Behavior",
      "section_title": true,
      "ja": "12.2.2その振る舞い"
    },
    {
      "indent": 3,
      "text": "Requests sent within a dialog, as any other requests, are atomic. If a particular request is accepted by the UAS, all the state changes associated with it are performed. If the request is rejected, none of the state changes are performed.",
      "ja": "ダイアログ内で送信されたリクエストは、他の要求として、アトミックです。特定の要求がUASによって受け入れられた場合、それに関連するすべての状態の変更が行われます。要求が拒否された場合、状態変化のどれも実行されません。"
    },
    {
      "indent": 6,
      "text": "Note that some requests, such as INVITEs, affect several pieces of state.",
      "ja": "などのINVITEなど、いくつかの要求は、状態のいくつかの部分に影響を与えることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The UAS will receive the request from the transaction layer. If the request has a tag in the To header field, the UAS core computes the dialog identifier corresponding to the request and compares it with existing dialogs. If there is a match, this is a mid-dialog request. In that case, the UAS first applies the same processing rules for requests outside of a dialog, discussed in Section 8.2.",
      "ja": "UASは、トランザクション層からのリクエストを受信します。リクエストがToヘッダーフィールドにタグがある場合、UASコアは、要求に対応するダイアログ識別子を計算し、既存のダイアログと比較します。一致がある場合、これは、ダイアログ中のリクエストです。その場合、UASは、第8.2節で説明したダイアログの外部要求に同じ処理ルールを適用します。"
    },
    {
      "indent": 3,
      "text": "If the request has a tag in the To header field, but the dialog identifier does not match any existing dialogs, the UAS may have crashed and restarted, or it may have received a request for a different (possibly failed) UAS (the UASs can construct the To tags so that a UAS can identify that the tag was for a UAS for which it is providing recovery). Another possibility is that the incoming request has been simply misrouted. Based on the To tag, the UAS MAY either accept or reject the request. Accepting the request for acceptable To tags provides robustness, so that dialogs can persist even through crashes. UAs wishing to support this capability must take into consideration some issues such as choosing monotonically increasing CSeq sequence numbers even across reboots, reconstructing the route set, and accepting out-of-range RTP timestamps and sequence numbers.",
      "ja": "要求は、ヘッダーフィールドにタグを有しているが、ダイアログ識別子が既存のダイアログが一致しない、UASはクラッシュして再起動している場合があり、またはそれは異なる（おそらく失敗）UAS（のUAS缶のための要求を受信した可能性がある場合UASは）タグは、それが回復を提供しているUASのためだったことを識別できるように、タグに構築します。別の可能性は、着信要求は単に誤ってルーティングされていることです。タグに基づいて、UASは要求を受け入れるか拒否するかもしれないどちらか。ダイアログがあってもクラッシュを介して持続することができるようにタグに受け入れのための要求を受け入れることは、堅牢性を提供します。この機能をサポートすることを望むUAは、このような単調選択などいくつかの問題があってもリブートしてのCSeqシーケンス番号を増やすルートセットを再構築し、範囲外のRTPタイムスタンプとシーケンス番号を受け入れる考慮に入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the UAS wishes to reject the request because it does not wish to recreate the dialog, it MUST respond to the request with a 481 (Call/Transaction Does Not Exist) status code and pass that to the server transaction.",
      "ja": "UASはそれがダイアログを再作成したくないため、要求を拒否したい場合は、ステータスコードとサーバートランザクションにそれを渡す481（存在しないコール/トランザクション）で要求に応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requests that do not change in any way the state of a dialog may be received within a dialog (for example, an OPTIONS request). They are processed as if they had been received outside the dialog.",
      "ja": "ダイアログの状態は、（例えば、OPTIONS要求）ダイアログボックス内に受信することができる任意の方法で変更しないよう要求します。彼らは、ダイアログ外で受信されたかのように彼らは、処理されます。"
    },
    {
      "indent": 3,
      "text": "If the remote sequence number is empty, it MUST be set to the value of the sequence number in the CSeq header field value in the request. If the remote sequence number was not empty, but the sequence number of the request is lower than the remote sequence number, the request is out of order and MUST be rejected with a 500 (Server Internal Error) response. If the remote sequence number was not empty, and the sequence number of the request is greater than the remote sequence number, the request is in order. It is possible for the CSeq sequence number to be higher than the remote sequence number by more than one. This is not an error condition, and a UAS SHOULD be prepared to receive and process requests with CSeq values more than one higher than the previous received request. The UAS MUST then set the remote sequence number to the value of the sequence number in the CSeq header field value in the request.",
      "ja": "リモートシーケンス番号が空である場合、それはリクエストにCSeqヘッダーフィールド値のシーケンス番号の値に設定しなければなりません。リモートシーケンス番号が空ではありませんでしたが、要求のシーケンス番号がリモートシーケンス番号よりも低い場合、要求は順不同であり、500（サーバ内部エラー）応答で拒否しなければなりません。リモートシーケンス番号が空ではなかった、と要求のシーケンス番号がリモートシーケンス番号よりも大きい場合、要求はオーダーです。 CSeqシーケンス番号が複数によるリモートシーケンス番号よりも高くすることが可能です。これは、エラー状態ではなく、UASはのCSeqは前回受信した要求よりも高いつ以上の値を持つリクエストを受信して​​処理するように準備されるべきです。 UASは、要求におけるCSeqヘッダーフィールド値のシーケンス番号の値にリモートシーケンス番号を設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If a proxy challenges a request generated by the UAC, the UAC has to resubmit the request with credentials. The resubmitted request will have a new CSeq number. The UAS will never see the first request, and thus, it will notice a gap in the CSeq number space. Such a gap does not represent any error condition.",
      "ja": "プロキシがUACによって生成された要求に挑戦する場合は、UACが資格情報を使用して、要求を再提出する必要があります。再送信要求が新しいのCSeq番号を持つことになります。 UASは、最初の要求を参照することはありません、ひいては、それがのCSeq番号空間のギャップに気づくでしょう。そのようなギャップは、任意のエラー状態を表していません。"
    },
    {
      "indent": 3,
      "text": "When a UAS receives a target refresh request, it MUST replace the dialog's remote target URI with the URI from the Contact header field in that request, if present.",
      "ja": "UASがターゲットリフレッシュ要求を受信した場合に存在する場合、それは、その要求にContactヘッダーフィールドからURIを持つダイアログのリモートターゲットURIを交換する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.3 Termination of a Dialog",
      "section_title": true,
      "ja": "ダイアログの12.3終了"
    },
    {
      "indent": 3,
      "text": "Independent of the method, if a request outside of a dialog generates a non-2xx final response, any early dialogs created through provisional responses to that request are terminated. The mechanism for terminating confirmed dialogs is method specific. In this specification, the BYE method terminates a session and the dialog associated with it. See Section 15 for details.",
      "ja": "ダイアログ外のリクエストが非2xxの最終応答を生成した場合の方法とは独立して、その要求への暫定応答を通じて作成された初期のダイアログが終了されます。確認ダイアログを終了するためのメカニズムは、メソッド固有のものです。この仕様では、BYEメソッドがセッションとそれに関連付けられたダイアログを終了します。詳細については、セクション15を参照してください。"
    },
    {
      "indent": 0,
      "text": "13 Initiating a Session",
      "ja": "セッションの開始13"
    },
    {
      "indent": 0,
      "text": "13.1 Overview",
      "section_title": true,
      "ja": "13.1概要"
    },
    {
      "indent": 3,
      "text": "When a user agent client desires to initiate a session (for example, audio, video, or a game), it formulates an INVITE request. The INVITE request asks a server to establish a session. This request may be forwarded by proxies, eventually arriving at one or more UAS that can potentially accept the invitation. These UASs will frequently need to query the user about whether to accept the invitation. After some time, those UASs can accept the invitation (meaning the session is to be established) by sending a 2xx response. If the invitation is not accepted, a 3xx, 4xx, 5xx or 6xx response is sent, depending on the reason for the rejection. Before sending a final response, the UAS can also send provisional responses (1xx) to advise the UAC of progress in contacting the called user.",
      "ja": "ユーザエージェントクライアントは、（例えば、オーディオ、ビデオ、またはゲーム）セッションを開始することを望む場合は、INVITE要求を定式化します。 INVITEリクエストは、セッションを確立するために、サーバーを要求します。この要求は、最終的には潜在的に招待を受け入れることができる1つまたは複数のUASに到着し、プロキシによって転送されてもよいです。これらのUASは、頻繁に招待を受諾するかどうかをユーザーに問い合わせる必要があります。しばらくすると、それらのUASは、2xx応答を送信することにより、（セッションを意味することは確立されている）の招待を受け入れることができます。招待が受け入れられない場合、3XX、4XX、5xxのか6xxの応答は、拒否の理由に応じて、送信されます。最終的な応答を送信する前に、UASはとも呼ばれる、ユーザーとの接触に進捗状況のUACを助言する暫定応答（1xxの）を送ることができます。"
    },
    {
      "indent": 3,
      "text": "After possibly receiving one or more provisional responses, the UAC will get one or more 2xx responses or one non-2xx final response. Because of the protracted amount of time it can take to receive final responses to INVITE, the reliability mechanisms for INVITE transactions differ from those of other requests (like OPTIONS). Once it receives a final response, the UAC needs to send an ACK for every final response it receives. The procedure for sending this ACK depends on the type of response. For final responses between 300 and 699, the ACK processing is done in the transaction layer and follows one set of rules (See Section 17). For 2xx responses, the ACK is generated by the UAC core.",
      "ja": "場合によっては1つまたは複数の暫定応答を受け取った後、UACは、一の以上の2xx応答または一つの非2xxの最終的な応答を取得します。なぜなら、それは、INVITEする最終的な応答を受信するために取ることができる時間の長期化量の、INVITEトランザクションの信頼性メカニズムは、（OPTIONSのような）他の要求のものとは異なります。それが最終的な応答を受信すると、UACは、それが受け取るすべての最終的な応答のためのACKを送信する必要があります。このACKを送信するための手順は、応答の種類によって異なります。 300と699との間の最終的な応答のために、ACK処理は、トランザクション層で行われ、ルール（セクション17を参照）の一組を以下れます。 2XX応答では、ACKはUACコアによって生成されます。"
    },
    {
      "indent": 3,
      "text": "A 2xx response to an INVITE establishes a session, and it also creates a dialog between the UA that issued the INVITE and the UA that generated the 2xx response. Therefore, when multiple 2xx responses are received from different remote UAs (because the INVITE forked), each 2xx establishes a different dialog. All these dialogs are part of the same call.",
      "ja": "INVITEに対する2xx応答はセッションを確立し、それはまた、INVITEを発行したUAと2xx応答を生成したUA間の対話を作成します。 （二股INVITEため）複数の2xx応答が異なるリモートのUAから受信されたときしたがって、それぞれの2xxは異なるダイアログを確立します。これらのすべてのダイアログは同じコールの一部です。"
    },
    {
      "indent": 3,
      "text": "This section provides details on the establishment of a session using INVITE. A UA that supports INVITE MUST also support ACK, CANCEL and BYE.",
      "ja": "このセクションでは、INVITE使用してセッションの確立に関する詳細を提供します。 CANCELとBYE、またACKをサポートしなければならないINVITEをサポートしていUA。"
    },
    {
      "indent": 0,
      "text": "13.2 UAC Processing",
      "section_title": true,
      "ja": "13.2 UACの処理"
    },
    {
      "indent": 0,
      "text": "13.2.1 Creating the Initial INVITE",
      "section_title": true,
      "ja": "13.2.1最初のINVITEを作成します"
    },
    {
      "indent": 3,
      "text": "Since the initial INVITE represents a request outside of a dialog, its construction follows the procedures of Section 8.1.1. Additional processing is required for the specific case of INVITE.",
      "ja": "最初のINVITEダイアログの外部要求を表すので、その構造はセクション8.1.1の手順に従います。追加の処理は、INVITEの特定の場合に必要とされます。"
    },
    {
      "indent": 3,
      "text": "An Allow header field (Section 20.5) SHOULD be present in the INVITE. It indicates what methods can be invoked within a dialog, on the UA sending the INVITE, for the duration of the dialog. For example, a UA capable of receiving INFO requests within a dialog [34] SHOULD include an Allow header field listing the INFO method.",
      "ja": "許可ヘッダフィールド（セクション20.5）がINVITEで存在すべきです。これは、方法は、ダイアログの期間中、INVITEを送るUA上で、ダイアログ内で呼び出すことができるかを示しています。例えば、ダイアログ内のINFO要求を受信することができるUA [34] INFOメソッドをリスト許可ヘッダフィールドを含むべきです。"
    },
    {
      "indent": 3,
      "text": "A Supported header field (Section 20.37) SHOULD be present in the INVITE. It enumerates all the extensions understood by the UAC.",
      "ja": "Supportedヘッダーフィールド（セクション20.37）がINVITEで存在すべきです。これは、UACが理解すべての拡張機能を列挙します。"
    },
    {
      "indent": 3,
      "text": "An Accept (Section 20.1) header field MAY be present in the INVITE. It indicates which Content-Types are acceptable to the UA, in both the response received by it, and in any subsequent requests sent to it within dialogs established by the INVITE. The Accept header field is especially useful for indicating support of various session description formats.",
      "ja": "（セクション20.1）受け入れヘッダフィールドは、INVITE中に存在してもよいです。これは、コンテンツタイプは、それが受信した応答の両方において、そしてINVITEによって確立されたダイアログ内で、それに送信された後続の要求で、UAに許容されるかを示します。 Acceptヘッダーフィールドには、様々なセッション記述形式のサポートを示すために特に有用です。"
    },
    {
      "indent": 3,
      "text": "The UAC MAY add an Expires header field (Section 20.19) to limit the validity of the invitation. If the time indicated in the Expires header field is reached and no final answer for the INVITE has been received, the UAC core SHOULD generate a CANCEL request for the INVITE, as per Section 9.",
      "ja": "UACは、招待の有効性を制限するために、有効期限ヘッダーフィールド（セクション20.19）を加えるかもしれ。で示された時間は、ヘッダフィールドに到達する有効期限と、INVITEのための最終的な回答が受信されていない場合、UACコアは、セクション9に従って、INVITEのためにCANCEL要求を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "A UAC MAY also find it useful to add, among others, Subject (Section 20.36), Organization (Section 20.25) and User-Agent (Section 20.41) header fields. They all contain information related to the INVITE.",
      "ja": "UACはまた、便利な他、件名（セクション20.36）、組織（セクション20.25）とのUser-Agent（セクション20.41）ヘッダフィールドの中で、追加するかもしれません。彼らはすべてのINVITEに関連する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The UAC MAY choose to add a message body to the INVITE. Section 8.1.1.10 deals with how to construct the header fields -- Content-Type among others -- needed to describe the message body.",
      "ja": "UACはINVITEにメッセージボディを追加することを選択するかもしれません。ヘッダフィールドを構築する方法と、セクション8.1.1.10のお得な - 他の人の間でのContent-Type  - メッセージ本文を記述するために必要。"
    },
    {
      "indent": 3,
      "text": "There are special rules for message bodies that contain a session description - their corresponding Content-Disposition is \"session\". SIP uses an offer/answer model where one UA sends a session description, called the offer, which contains a proposed description of the session. The offer indicates the desired communications means (audio, video, games), parameters of those means (such as codec types) and addresses for receiving media from the answerer. The other UA responds with another session description, called the answer, which indicates which communications means are accepted, the parameters that apply to those means, and addresses for receiving media from the offerer. An offer/answer exchange is within the context of a dialog, so that if a SIP INVITE results in multiple dialogs, each is a separate offer/answer exchange. The offer/answer model defines restrictions on when offers and answers can be made (for example, you cannot make a new offer while one is in progress). This results in restrictions on where the offers and answers can appear in SIP messages. In this specification, offers and answers can only appear in INVITE requests and responses, and ACK. The usage of offers and answers is further restricted. For the initial INVITE transaction, the rules are:",
      "ja": "それに対応するContent-Disposition「の場合は、セッション」である - セッション記述が含まれているメッセージ本文のための特別なルールがあります。 SIPは、セッションの提案説明が含まれているプラ​​ンと呼ばれる1 UAは、セッション記述を送るオファー/アンサーモデルを、使用しています。オファーは回答からメディアを受信するための所望の通信手段（オーディオ、ビデオ、ゲーム）、（例えば、コーデックの種類など）、それらの手段のパラメータ及びアドレスを示します。他のUAは、別のセッション記述で応答し、通信手段が受け入れられる示す回答を、と呼ばれる、提供者からメディアを受信するためのそれらの手段に適用されるパラメータ、およびアドレス。 SIPは、複数のダイアログで結果をINVITE場合に、それぞれが別個のオファー/アンサー交換であるようオファー/アンサー交換は、ダイアログのコンテキスト内です。オファー/アンサーモデルは、（1の進行中に、たとえば、あなたは新しい申し出をすることはできません）オファーとアンサーことができるようになった時点で制限を定義します。これは、オファーとアンサーがSIPメッセージに表示されることができる場所の制限につながります。本明細書では、オファーとアンサーはINVITE要求と応答、およびACKに表示することができます。オファーとアンサーの使用がさらに制限されています。最初のINVITEトランザクションのために、ルールは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "o The initial offer MUST be in either an INVITE or, if not there, in the first reliable non-failure message from the UAS back to the UAC. In this specification, that is the final 2xx response.",
      "ja": "最初のオファーがあり、UASからの最初の信頼性の高い非失敗メッセージ中に戻ってUACに招待したり、そうでない場合のいずれかでなければならない（MUST）oを。本明細書では、それは、最終的な2xx応答です。"
    },
    {
      "indent": 6,
      "text": "o If the initial offer is in an INVITE, the answer MUST be in a reliable non-failure message from UAS back to UAC which is correlated to that INVITE. For this specification, that is only the final 2xx response to that INVITE. That same exact answer MAY also be placed in any provisional responses sent prior to the answer. The UAC MUST treat the first session description it receives as the answer, and MUST ignore any session descriptions in subsequent responses to the initial INVITE.",
      "ja": "最初のオファーがINVITEである場合には、O、答えはそのINVITEに相関しているバックUACにUAS​​から信頼できる非失敗メッセージでなければなりません。この仕様のために、それはそのINVITEにのみ、最終的な2xx応答です。その同じ正確な答えはまた、従来の答えに送信された暫定応答中に配置することができます。 UACは、それが答えとして受け取る最初のセッション記述を扱わなければなりませんし、最初のINVITEに、後続の応答のいずれかのセッション記述を無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "o If the initial offer is in the first reliable non-failure message from the UAS back to UAC, the answer MUST be in the acknowledgement for that message (in this specification, ACK for a 2xx response).",
      "ja": "初期オファーがバックUACにUAS​​から最初の信頼性の非失敗メッセージである場合、O、答えはそのメッセージに対する肯定応答にする必要があります（本明細書では、2xx応答のためにACK）。"
    },
    {
      "indent": 6,
      "text": "o After having sent or received an answer to the first offer, the UAC MAY generate subsequent offers in requests based on rules specified for that method, but only if it has received answers to any previous offers, and has not sent any offers to which it hasn't gotten an answer.",
      "ja": "O最初のオファーに対する答えを送信または受信した後、UACは、そのメソッドに対して指定されたルールに基づいて要求の後続のオファーを生成するかもしれないが、それは以前の申し出の答えを受けている、それ先のいずれかのオファーを送信していない場合にのみ、答えを得ていません。"
    },
    {
      "indent": 6,
      "text": "o Once the UAS has sent or received an answer to the initial offer, it MUST NOT generate subsequent offers in any responses to the initial INVITE. This means that a UAS based on this specification alone can never generate subsequent offers until completion of the initial transaction.",
      "ja": "UASが送信または最初のオファーに対する答えを受け取った後、O、それは最初のINVITEへの応答で、その後のオファーを生成してはなりません。これだけで、この仕様に基づいて、UASは最初のトランザクションが完了するまで、後続のオファーを生成することはできませんことを意味します。"
    },
    {
      "indent": 3,
      "text": "Concretely, the above rules specify two exchanges for UAs compliant to this specification alone - the offer is in the INVITE, and the answer in the 2xx (and possibly in a 1xx as well, with the same value), or the offer is in the 2xx, and the answer is in the ACK. All user agents that support INVITE MUST support these two exchanges.",
      "ja": "具体的には、上記の規則は、単独で、この仕様に準拠のUAのための2つの交換を指定 - オファーがINVITEであり、2XXの答（そしておそらく1XXにも、同じ値を有する）、またはオファーであります2XX、そして答えはACKです。 INVITEサポートするすべてのユーザエージェントは、これら二つの交流をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Session Description Protocol (SDP) (RFC 2327 [1]) MUST be supported by all user agents as a means to describe sessions, and its usage for constructing offers and answers MUST follow the procedures defined in [13].",
      "ja": "セッション記述プロトコル（SDP）（RFC 2327 [1]）セッションを記述するための手段として、すべてのユーザエージェントによってサポートされなければならない、とオファーと回答を構築するためのその使用は[13]で定義された手順に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "The restrictions of the offer-answer model just described only apply to bodies whose Content-Disposition header field value is \"session\". Therefore, it is possible that both the INVITE and the ACK contain a body message (for example, the INVITE carries a photo (Content-Disposition: render) and the ACK a session description (Content-Disposition: session)).",
      "ja": "オファーアンサーモデルの制限は、ちょうどそのコンテンツ-Dispositionヘッダーフィールドの値が「セッション」である団体のみに適用されます説明します。したがって、それはINVITEとACKの両方が身体のメッセージを含むことが可能である（：レンダリング）とACKセッション記述（コンテンツの廃棄：セッション）INVITE、例えばする写真を（コンテンツの廃棄運びます）。"
    },
    {
      "indent": 3,
      "text": "If the Content-Disposition header field is missing, bodies of Content-Type application/sdp imply the disposition \"session\", while other content types imply \"render\".",
      "ja": "Content-Dispositionヘッダーフィールドが欠落している場合、他のコンテンツタイプは、「レンダリング」を暗示しながら、Content-Typeのアプリケーション/ SDPの遺体は、処分「セッション」を意味します。"
    },
    {
      "indent": 3,
      "text": "Once the INVITE has been created, the UAC follows the procedures defined for sending requests outside of a dialog (Section 8). This results in the construction of a client transaction that will ultimately send the request and deliver responses to the UAC.",
      "ja": "INVITEが作成されると、UACダイアログ（8節）の外側に要求を送信するために定義された手順に従います。これは、最終的にリクエストを送信し、UACに応答を提供するクライアントトランザクションの構築につながります。"
    },
    {
      "indent": 0,
      "text": "13.2.2 Processing INVITE Responses",
      "section_title": true,
      "ja": "13.2.2処理が応答をINVITE"
    },
    {
      "indent": 3,
      "text": "Once the INVITE has been passed to the INVITE client transaction, the UAC waits for responses for the INVITE. If the INVITE client transaction returns a timeout rather than a response the TU acts as if a 408 (Request Timeout) response had been received, as described in Section 8.1.3.",
      "ja": "INVITEがINVITEクライアントトランザクションに渡された後、UACは、INVITEに対する応答を待ちます。 INVITEクライアントトランザクションが応答するのではなくタイムアウトを返す場合TUは、第8.1.3項で説明したように408（リクエストタイムアウト）応答は、受信されたかのように動作します。"
    },
    {
      "indent": 0,
      "text": "13.2.2.1 1xx Responses",
      "section_title": true,
      "ja": "13.2.2.1の1xx応答"
    },
    {
      "indent": 3,
      "text": "Zero, one or multiple provisional responses may arrive before one or more final responses are received. Provisional responses for an INVITE request can create \"early dialogs\". If a provisional response has a tag in the To field, and if the dialog ID of the response does not match an existing dialog, one is constructed using the procedures defined in Section 12.1.2.",
      "ja": "一つ以上の最終応答が受信される前に、ゼロ、1つまたは複数の暫定的な応答が到着してもよいです。 INVITEリクエストに対する暫定応答は「earlyダイアログ」を作成することができます。暫定応答フィールドにタグを持っている場合、応答のダイアログIDは、既存のダイアログと一致しない場合、及び、一つのセクション12.1.2に定義された手順を用いて構築されています。"
    },
    {
      "indent": 3,
      "text": "The early dialog will only be needed if the UAC needs to send a request to its peer within the dialog before the initial INVITE transaction completes. Header fields present in a provisional response are applicable as long as the dialog is in the early state (for example, an Allow header field in a provisional response contains the methods that can be used in the dialog while this is in the early state).",
      "ja": "UACは最初のINVITEトランザクションが完了する前にダイアログ内のピアに要求を送信する必要がある場合、早期ダイアログにのみ必要になります。ダイアログが初期状態である（例えば、暫定応答のヘッダフィールドを許可これは初期状態にある間に、ダイアログで使用することができる方法を含む）のように暫定応答中に存在するヘッダーフィールドは限り適用可能です。"
    },
    {
      "indent": 0,
      "text": "13.2.2.2 3xx Responses",
      "section_title": true,
      "ja": "13.2.2.2 3xx応答"
    },
    {
      "indent": 3,
      "text": "A 3xx response may contain one or more Contact header field values providing new addresses where the callee might be reachable. Depending on the status code of the 3xx response (see Section 21.3), the UAC MAY choose to try those new addresses.",
      "ja": "3xx応答は、呼び出し先が到達可能であるかもしれない新しいアドレスを提供する1つのまたは複数のContactヘッダーフィールド値が含まれていてもよいです。 3xx応答のステータスコードに応じて、（項21.3を参照）、UACは、これらの新しいアドレスを試すために選ぶかもしれません。"
    },
    {
      "indent": 0,
      "text": "13.2.2.3 4xx, 5xx and 6xx Responses",
      "section_title": true,
      "ja": "13.2.2.3の4xx、5xxのと6xxの応答"
    },
    {
      "indent": 3,
      "text": "A single non-2xx final response may be received for the INVITE. 4xx, 5xx and 6xx responses may contain a Contact header field value indicating the location where additional information about the error can be found. Subsequent final responses (which would only arrive under error conditions) MUST be ignored.",
      "ja": "INVITEのための単一の非2xxの最終的な応答が受信されても​​よいです。 4XX、5xxのと6xxの応答がエラーに関する追加情報を見つけることができる場所を示すContactヘッダーフィールド値を含んでいてもよいです。 （唯一のエラー条件の下で到着する）、その後の最終的な応答は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "All early dialogs are considered terminated upon reception of the non-2xx final response.",
      "ja": "すべてのearlyダイアログは、2xx以外の最終応答の受信時に終了と考えられています。"
    },
    {
      "indent": 3,
      "text": "After having received the non-2xx final response the UAC core considers the INVITE transaction completed. The INVITE client transaction handles the generation of ACKs for the response (see Section 17).",
      "ja": "UACコアはINVITEトランザクションが完了したとみなし、非2xxの最終的な応答を受信した後。 INVITEクライアントトランザクション（セクション17を参照）、応答に対するACKの生成を処理します。"
    },
    {
      "indent": 0,
      "text": "13.2.2.4 2xx Responses",
      "section_title": true,
      "ja": "13.2.2.4 2xx応答"
    },
    {
      "indent": 3,
      "text": "Multiple 2xx responses may arrive at the UAC for a single INVITE request due to a forking proxy. Each response is distinguished by the tag parameter in the To header field, and each represents a distinct dialog, with a distinct dialog identifier.",
      "ja": "複数の2xx応答が原因フォーキングプロキシに単一のINVITE要求のためにUACに到着することができます。各応答はToヘッダーフィールドにtagパラメータによって区別され、それぞれが別個のダイアログ識別子と、別個のダイアログを示しています。"
    },
    {
      "indent": 3,
      "text": "If the dialog identifier in the 2xx response matches the dialog identifier of an existing dialog, the dialog MUST be transitioned to the \"confirmed\" state, and the route set for the dialog MUST be recomputed based on the 2xx response using the procedures of Section 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be constructed using the procedures of Section 12.1.2.",
      "ja": "2xx応答中のダイアログ識別子が既存のダイアログのダイアログ識別子と一致した場合、ダイアログは状態を「確認」、およびダイアログのルートセットは、12.2節の手順を使用して2xx応答に基づいて再計算されなければならないに移行しなければなりません.1.2。それ以外の場合は、「確認」状態の新しいダイアログが12.1.2項の手順を使用して構築されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note that the only piece of state that is recomputed is the route set. Other pieces of state such as the highest sequence numbers (remote and local) sent within the dialog are not recomputed. The route set only is recomputed for backwards compatibility. RFC 2543 did not mandate mirroring of the Record-Route header field in a 1xx, only 2xx. However, we cannot update the entire state of the dialog, since mid-dialog requests may have been sent within the early dialog, modifying the sequence numbers, for example.",
      "ja": "再計算された状態の唯一の部分は、ルートセットであることに留意されたいです。このようなダイアログ内で送信（リモートおよびローカル）最高シーケンス番号などの状態の他の部分が再計算されません。のみ設定ルートは後方互換性のために再計算されます。 RFC 2543は、1xxの中で唯一の2xxをRecord-Routeヘッダーフィールドのミラーリングを強制しませんでした。半ばダイアログの要求は、例えば、シーケンス番号を変更し、早期のダイアログ内で送信された可能性がありますので、しかし、我々は、対話の全体の状態を更新することはできません。"
    },
    {
      "indent": 3,
      "text": "The UAC core MUST generate an ACK request for each 2xx received from the transaction layer. The header fields of the ACK are constructed in the same way as for any request sent within a dialog (see Section 12) with the exception of the CSeq and the header fields related to authentication. The sequence number of the CSeq header field MUST be the same as the INVITE being acknowledged, but the CSeq method MUST be ACK. The ACK MUST contain the same credentials as the INVITE. If the 2xx contains an offer (based on the rules above), the ACK MUST carry an answer in its body. If the offer in the 2xx response is not acceptable, the UAC core MUST generate a valid answer in the ACK and then send a BYE immediately.",
      "ja": "UACコアは、トランザクション層から受信したそれぞれの2xxに対するACK要求を生成しなければなりません。 ACKのヘッダフィールドは、のCSeqと認証に関するヘッダーフィールドを除いて（セクション12を参照）ダイアログ内で送信された要求と同じように構成されています。 CSeqヘッダーフィールドのシーケンス番号が承認されてINVITEと同じでなければならないが、のCSeq方法がACKでなければなりません。 ACKは、INVITEと同じ資格情報を含まなければなりません。 2XXは、（上記のルールに基づいて）のオファーが含まれている場合、ACKは、その本体に答えを運ばなければなりません。 2xx応答中のオファーが受け入れられない場合、UACコアはACK中に有効な回答を生成し、その後すぐにBYEを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the ACK has been constructed, the procedures of [4] are used to determine the destination address, port and transport. However, the request is passed to the transport layer directly for transmission, rather than a client transaction. This is because the UAC core handles retransmissions of the ACK, not the transaction layer. The ACK MUST be passed to the client transport every time a retransmission of the 2xx final response that triggered the ACK arrives.",
      "ja": "ACKが構築されたら、[4]の手順は、宛先アドレス、ポートおよびトランスポートを決定するために使用されます。しかし、要求が直接送信用のトランスポート層ではなく、クライアントのトランザクションに渡されます。 UACコアはACK、ないトランザクション層の再送信を処理するためです。 ACKはクライアントトランスポートにACKをトリガ2XX最終応答の再送が到着するたびに渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "The UAC core considers the INVITE transaction completed 64*T1 seconds after the reception of the first 2xx response. At this point all the early dialogs that have not transitioned to established dialogs are terminated. Once the INVITE transaction is considered completed by the UAC core, no more new 2xx responses are expected to arrive.",
      "ja": "UACコアは64 * T1秒最初の2xx応答の受信が完了した後、INVITEトランザクションを検討します。この時点で確立したダイアログに移行していないすべてのearlyダイアログは終了しています。 INVITEトランザクションがUACコアによって完了したとみなされたら、これ以上新しい2xx応答が到着すると予想されていません。"
    },
    {
      "indent": 3,
      "text": "If, after acknowledging any 2xx response to an INVITE, the UAC does not want to continue with that dialog, then the UAC MUST terminate the dialog by sending a BYE request as described in Section 15.",
      "ja": "、INVITEへの2xx応答を了承のうえ、UACがそのダイアログを続行したくない場合は、UACは、セクション15で説明したようにBYE要求を送信することにより、ダイアログを終えなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.3 UAS Processing",
      "section_title": true,
      "ja": "13.3処理"
    },
    {
      "indent": 0,
      "text": "13.3.1 Processing of the INVITE",
      "section_title": true,
      "ja": "INVITEの13.3.1処理"
    },
    {
      "indent": 3,
      "text": "The UAS core will receive INVITE requests from the transaction layer. It first performs the request processing procedures of Section 8.2, which are applied for both requests inside and outside of a dialog.",
      "ja": "UASコアは、トランザクション層からINVITE要求を受信します。これは、第1内側及びダイアログの外側両方の要求に適用されるセクション8.2の要求処理手順を実行します。"
    },
    {
      "indent": 3,
      "text": "Assuming these processing states are completed without generating a response, the UAS core performs the additional processing steps:",
      "ja": "これらの処理状態が応答を生成せずに終了すると仮定すると、UASコアは、追加の処理ステップを実行します。"
    },
    {
      "indent": 6,
      "text": "1. If the request is an INVITE that contains an Expires header field, the UAS core sets a timer for the number of seconds indicated in the header field value. When the timer fires, the invitation is considered to be expired. If the invitation expires before the UAS has generated a final response, a 487 (Request Terminated) response SHOULD be generated.",
      "ja": "1.リクエストは、そのヘッダフィールドを有効期限含まINVITEの場合、UASコアは、ヘッダフィールド値に示された秒数のタイマーをセットします。ときにタイマーを起動すると、招待状の有効期限が切れていると考えられます。 UASは、最終的な応答を生成する前に招待が満了した場合、487（リクエストを終了）応答が生成されるべきです。"
    },
    {
      "indent": 6,
      "text": "2. If the request is a mid-dialog request, the method-independent processing described in Section 12.2.2 is first applied. It might also modify the session; Section 14 provides details.",
      "ja": "2.要求が中間ダイアログ要求である場合、セクション12.2.2に記載された方法に依存しない処理が最初に適用されます。また、セッションを変更するかもしれません。第14条には、詳細を提供します。"
    },
    {
      "indent": 6,
      "text": "3. If the request has a tag in the To header field but the dialog identifier does not match any of the existing dialogs, the UAS may have crashed and restarted, or may have received a request for a different (possibly failed) UAS. Section 12.2.2 provides guidelines to achieve a robust behavior under such a situation.",
      "ja": "リクエストがToヘッダーフィールド内のタグを有するが、ダイアログ識別子が既存のダイアログのいずれかが、UASはクラッシュして再起動、または別の要求を受信して​​いる場合がありている可能性が一致しない場合3. UASを（おそらく失敗）。 12.2.2は、このような状況の下で堅牢な動作を実現するためのガイドラインを提供します。"
    },
    {
      "indent": 3,
      "text": "Processing from here forward assumes that the INVITE is outside of a dialog, and is thus for the purposes of establishing a new session.",
      "ja": "ここでは、前方からの処理は、ダイアログの外にあるINVITEと仮定して、新しいセッションを確立する目的のためにことです。"
    },
    {
      "indent": 3,
      "text": "The INVITE may contain a session description, in which case the UAS is being presented with an offer for that session. It is possible that the user is already a participant in that session, even though the INVITE is outside of a dialog. This can happen when a user is invited to the same multicast conference by multiple other participants. If desired, the UAS MAY use identifiers within the session description to detect this duplication. For example, SDP contains a session id and version number in the origin (o) field. If the user is already a member of the session, and the session parameters contained in the session description have not changed, the UAS MAY silently accept the INVITE (that is, send a 2xx response without prompting the user).",
      "ja": "UASは、そのセッションのオファーが提示されている場合に、セッション記述を含んでいてもよいINVITE。 INVITEは、ダイアログの外であっても、ユーザーが既にそのセッションに参加している可能性があります。ユーザーが複数の他の参加者が同じマルチキャスト会議に招待されたときに発生することがあります。必要であれば、UASはこの重複を検出するために、セッション記述の中に識別子を使用することができます。例えば、SDPは、原点（O）フィールドにセッションIDとバージョン番号を含みます。ユーザーがすでにセッションのメンバーであり、セッション記述に含まれるセッションパラメータが変更されていない場合、UASは黙って（ユーザーにメッセージを表示せずに2xx応答を送信する、つまり）INVITEを受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "If the INVITE does not contain a session description, the UAS is being asked to participate in a session, and the UAC has asked that the UAS provide the offer of the session. It MUST provide the offer in its first non-failure reliable message back to the UAC. In this specification, that is a 2xx response to the INVITE.",
      "ja": "INVITEはセッション記述が含まれていない場合、UASは、セッションに参加することが求められており、UACはUASがセッションの提供を提供することを求めています。これは、バックUACへの最初の非失敗信頼性の高いメッセージでのオファーを提供しなければなりません。この仕様では、それはINVITEへの2xx応答です。"
    },
    {
      "indent": 3,
      "text": "The UAS can indicate progress, accept, redirect, or reject the invitation. In all of these cases, it formulates a response using the procedures described in Section 8.2.6.",
      "ja": "UASは、進行状況を示す受け入れ、リダイレクト、または招待を拒否することができます。これらの場合の全てにおいて、それは、セクション8.2.6に記載した手順を使用して応答を作成します。"
    },
    {
      "indent": 0,
      "text": "13.3.1.1 Progress",
      "section_title": true,
      "ja": "13.3.1.1進捗状況"
    },
    {
      "indent": 3,
      "text": "If the UAS is not able to answer the invitation immediately, it can choose to indicate some kind of progress to the UAC (for example, an indication that a phone is ringing). This is accomplished with a provisional response between 101 and 199. These provisional responses establish early dialogs and therefore follow the procedures of Section 12.1.1 in addition to those of Section 8.2.6. A UAS MAY send as many provisional responses as it likes. Each of these MUST indicate the same dialog ID. However, these will not be delivered reliably.",
      "ja": "UASはすぐに招待状を答えることができない場合は、（例えば、電話が鳴っていることを示す指標）UACへの進展のいくつかの種類を示すために選択することができます。これは、これらの暫定的な応答は、初期ダイアログを確立し、従って、セクション8.2.6のものに加えて、セクション12.1.1の手順に従う101と199との間の暫定的な応答で達成されます。それが好きなようUASは、多くの暫定応答を送信することができます。これらのそれぞれは、同じダイアログIDを指定する必要があります。しかし、これらが確実に配信されません。"
    },
    {
      "indent": 3,
      "text": "If the UAS desires an extended period of time to answer the INVITE, it will need to ask for an \"extension\" in order to prevent proxies from canceling the transaction. A proxy has the option of canceling a transaction when there is a gap of 3 minutes between responses in a transaction. To prevent cancellation, the UAS MUST send a non-100 provisional response at every minute, to handle the possibility of lost provisional responses.",
      "ja": "UASがINVITEに答える時間の延長期間を希望する場合は、トランザクションを取り消すからプロキシを防ぐために、「拡張子」のために依頼する必要があります。プロキシは、トランザクション内の応答の間の3分のギャップがあるときにトランザクションをキャンセルするオプションがあります。キャンセルを防ぐために、UASは、失われた暫定応答の可能性を処理するために、毎分で非100暫定応答を送らなければなりません。"
    },
    {
      "indent": 6,
      "text": "An INVITE transaction can go on for extended durations when the user is placed on hold, or when interworking with PSTN systems which allow communications to take place without answering the call. The latter is common in Interactive Voice Response (IVR) systems.",
      "ja": "通信が呼に応答せずに場所を取ることができるようにPSTNシステムと相互作用するとき、ユーザーが保留に、またはされている場合、INVITEトランザクションは、拡張された期間のために行くことができます。後者は、対話型音声応答（IVR）システムでは一般的です。"
    },
    {
      "indent": 0,
      "text": "13.3.1.2 The INVITE is Redirected",
      "section_title": true,
      "ja": "リダイレクトされたINVITE 13.3.1.2"
    },
    {
      "indent": 3,
      "text": "If the UAS decides to redirect the call, a 3xx response is sent. A 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved Temporarily) response SHOULD contain a Contact header field containing one or more URIs of new addresses to be tried. The response is passed to the INVITE server transaction, which will deal with its retransmissions.",
      "ja": "UASがコールをリダイレクトすることを決定した場合、3xx応答が送信されます。 300（複数の選択肢）、301（恒久的に移動）または302（一時的に移動）応答が試されるべき新たなアドレスの一つ以上のURIを含むContactヘッダフィールドを含むべきです。応答は、その再送信に対処しますINVITEサーバートランザクションに渡されます。"
    },
    {
      "indent": 0,
      "text": "13.3.1.3 The INVITE is Rejected",
      "section_title": true,
      "ja": "拒否されたINVITE 13.3.1.3"
    },
    {
      "indent": 3,
      "text": "A common scenario occurs when the callee is currently not willing or able to take additional calls at this end system. A 486 (Busy Here) SHOULD be returned in such a scenario. If the UAS knows that no other end system will be able to accept this call, a 600 (Busy Everywhere) response SHOULD be sent instead. However, it is unlikely that a UAS will be able to know this in general, and thus this response will not usually be used. The response is passed to the INVITE server transaction, which will deal with its retransmissions.",
      "ja": "呼び出し先が現在喜んまたはこのエンドシステムに追加コールを取ることができないときの一般的なシナリオが発生します。 486（ここで、ビジー）は、そのようなシナリオで返されるべきです。 UASは、他のエンド・システムは、このコールを受け入れることができないことを知っている場合は、600（どこでもビジー）応答が代わりに送ってください。しかし、UASは、一般的にこのことを知ってできるようになることはほとんどありませんので、この応答は、通常は使用されません。応答は、その再送信に対処しますINVITEサーバートランザクションに渡されます。"
    },
    {
      "indent": 3,
      "text": "A UAS rejecting an offer contained in an INVITE SHOULD return a 488 (Not Acceptable Here) response. Such a response SHOULD include a Warning header field value explaining why the offer was rejected.",
      "ja": "UASは（ここでは許容できない）488を返すべきINVITE応答に含まれているのオファーを拒否します。そのような応答は、オファーが拒否された理由を説明する警告ヘッダフィールド値を含めるべきです。"
    },
    {
      "indent": 0,
      "text": "13.3.1.4 The INVITE is Accepted",
      "section_title": true,
      "ja": "受理されたINVITE 13.3.1.4"
    },
    {
      "indent": 3,
      "text": "The UAS core generates a 2xx response. This response establishes a dialog, and therefore follows the procedures of Section 12.1.1 in addition to those of Section 8.2.6.",
      "ja": "UASコアは2xx応答を生成します。この応答は、ダイアログを確立し、従ってセクション8.2.6のものに加えて、セクション12.1.1の手順に従います。"
    },
    {
      "indent": 3,
      "text": "A 2xx response to an INVITE SHOULD contain the Allow header field and the Supported header field, and MAY contain the Accept header field. Including these header fields allows the UAC to determine the features and extensions supported by the UAS for the duration of the call, without probing.",
      "ja": "AllowヘッダーフィールドとSupportedヘッダーフィールドを含むべきである、とAcceptヘッダーフィールドを含むかもしれINVITEに対する2xx応答。これらのヘッダーフィールドを含むことUACプロービングすることなく、呼の持続時間UASによってサポートされる機能と拡張機能を決定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "If the INVITE request contained an offer, and the UAS had not yet sent an answer, the 2xx MUST contain an answer. If the INVITE did not contain an offer, the 2xx MUST contain an offer if the UAS had not yet sent an offer.",
      "ja": "INVITE要求を提示申し出を含んでいて、UASはまだ答えを送っていなかった場合は、2xxのは、答えを含まなければなりません。 INVITEが申し出が含まれていなかった場合はUASがまだのオファーを送っていなかった場合、2xxのは申し出を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the response has been constructed, it is passed to the INVITE server transaction. Note, however, that the INVITE server transaction will be destroyed as soon as it receives this final response and passes it to the transport. Therefore, it is necessary to periodically pass the response directly to the transport until the ACK arrives. The 2xx response is passed to the transport with an interval that starts at T1 seconds and doubles for each retransmission until it reaches T2 seconds (T1 and T2 are defined in Section 17). Response retransmissions cease when an ACK request for the response is received. This is independent of whatever transport protocols are used to send the response.",
      "ja": "応答が構築されたら、それはINVITEサーバートランザクションに渡されます。 INVITEサーバートランザクションは、すぐにそれは、この最終的な応答を受信し、トランスポートにそれを通過する際に破壊されること、しかし、注意してください。したがって、ACKが到着するまで、定期的に輸送に直接応答を渡す必要があります。 2xx応答は、T1秒で開始し、T2秒（T1とT2はセクション17で定義されている）に達するまで、各再送信のために二倍の間隔で輸送に渡されます。応答のためのACK要求を受信したときの応答の再送信が停止します。これは、プロトコルが応答を送信するために使用されているものは何でも輸送とは無関係です。"
    },
    {
      "indent": 6,
      "text": "Since 2xx is retransmitted end-to-end, there may be hops between UAS and UAC that are UDP. To ensure reliable delivery across these hops, the response is retransmitted periodically even if the transport at the UAS is reliable.",
      "ja": "2XXは、エンドツーエンドで再送されるので、UDPであるUASとUACの間のホップが存在してもよいです。これらのホップ間で信頼性の高い配信を確保するために、応答はUASでの輸送が信頼できる場合でも、定期的に再送信されます。"
    },
    {
      "indent": 3,
      "text": "If the server retransmits the 2xx response for 64*T1 seconds without receiving an ACK, the dialog is confirmed, but the session SHOULD be terminated. This is accomplished with a BYE, as described in Section 15.",
      "ja": "サーバはACKを受信せずに64 * T1秒のための2xx応答を再送する場合は、ダイアログが確認されたが、セッションは終了されるべき。セクション15で説明したように、これは、BYEを用いて達成されます。"
    },
    {
      "indent": 0,
      "text": "14 Modifying an Existing Session",
      "ja": "既存のセッションの変更14"
    },
    {
      "indent": 3,
      "text": "A successful INVITE request (see Section 13) establishes both a dialog between two user agents and a session using the offer-answer model. Section 12 explains how to modify an existing dialog using a target refresh request (for example, changing the remote target URI of the dialog). This section describes how to modify the actual session. This modification can involve changing addresses or ports, adding a media stream, deleting a media stream, and so on. This is accomplished by sending a new INVITE request within the same dialog that established the session. An INVITE request sent within an existing dialog is known as a re-INVITE.",
      "ja": "（セクション13を参照）INVITEリクエストを成功には、2つのユーザーエージェント間の対話とオファーアンサーモデルを使用してセッションの両方を確立します。セクション12は、（例えば、リモートターゲットダイアログのURIを変更する）ターゲットリフレッシュ要求を使用して、既存のダイアログを変更する方法について説明します。このセクションでは、実際のセッションを変更する方法について説明します。この変更は、ように、メディアストリームを追加するメディアストリームを削除、および、アドレスやポートを変更することを含むことができます。これは、セッションを確立し、同じダイアログ内の新しいINVITEリクエストを送信することによって達成されます。既存のダイアログ内で送信INVITE要求が再INVITEとして知られています。"
    },
    {
      "indent": 6,
      "text": "Note that a single re-INVITE can modify the dialog and the parameters of the session at the same time.",
      "ja": "単一の再INVITEを同時にダイアログとセッションのパラメータを変更できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Either the caller or callee can modify an existing session.",
      "ja": "発信者または呼び出し先のどちらかが既存のセッションを変更することができます。"
    },
    {
      "indent": 3,
      "text": "The behavior of a UA on detection of media failure is a matter of local policy. However, automated generation of re-INVITE or BYE is NOT RECOMMENDED to avoid flooding the network with traffic when there is congestion. In any case, if these messages are sent automatically, they SHOULD be sent after some randomized interval.",
      "ja": "メディア障害の検出にUAの挙動は、ローカルポリシーの問題です。しかし、再INVITEかBYEの自動生成は、輻輳があるとき、トラフィックとネットワークのフラッディングを回避するために推奨されていません。これらのメッセージが自動的に送信された場合にどのような場合には、彼らはいくつかのランダム化インターバルの後に送ってください。"
    },
    {
      "indent": 6,
      "text": "Note that the paragraph above refers to automatically generated BYEs and re-INVITEs. If the user hangs up upon media failure, the UA would send a BYE request as usual.",
      "ja": "上の段落は自動的に生成するため不戦勝と再招待いいます。ユーザーは、メディア障害時にハングアップする場合は、UAは、いつものようにBYE要求を送信します。"
    },
    {
      "indent": 0,
      "text": "14.1 UAC Behavior",
      "section_title": true,
      "ja": "14.1 UACの動作"
    },
    {
      "indent": 3,
      "text": "The same offer-answer model that applies to session descriptions in INVITEs (Section 13.2.1) applies to re-INVITEs. As a result, a UAC that wants to add a media stream, for example, will create a new offer that contains this media stream, and send that in an INVITE request to its peer. It is important to note that the full description of the session, not just the change, is sent. This supports stateless session processing in various elements, and supports failover and recovery capabilities. Of course, a UAC MAY send a re-INVITE with no session description, in which case the first reliable non-failure response to the re-INVITE will contain the offer (in this specification, that is a 2xx response).",
      "ja": "INVITEでセッション記述に適用される同じオファーアンサーモデル（セクション13.2.1）が再のINVITEに適用されます。その結果、メディアストリームを追加したいUACは、例えば、このメディアストリームを含む新しいオファーを作成し、そのピアにINVITEリクエストでそれを送ります。セッションだけでなく、変更の完全な説明は、送信されたことに注意することが重要です。これは、さまざまな要素にステートレスセッション処理をサポートし、フェイルオーバーおよびリカバリ機能をサポートしています。もちろん、UACは再INVITEへの最初の信頼性の高い非失敗応答は、（本明細書では、それは2xx応答である）のオファーが含まれています、その場合には、無セッション記述で再INVITEを送信することができます。"
    },
    {
      "indent": 3,
      "text": "If the session description format has the capability for version numbers, the offerer SHOULD indicate that the version of the session description has changed.",
      "ja": "セッション記述形式はバージョン番号のための能力を持っている場合、オファー側は、セッション記述のバージョンが変更されたことを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "The To, From, Call-ID, CSeq, and Request-URI of a re-INVITE are set following the same rules as for regular requests within an existing dialog, described in Section 12.",
      "ja": "するには、からの、のCSeq、とのRequest-URI-IDを呼び出して再招待第12節で説明した既存のダイアログ内の定期的な要求の場合と同じ規則に従って設定されています。"
    },
    {
      "indent": 3,
      "text": "A UAC MAY choose not to add an Alert-Info header field or a body with Content-Disposition \"alert\" to re-INVITEs because UASs do not typically alert the user upon reception of a re-INVITE.",
      "ja": "UASは、一般的に再INVITEを受信したときにユーザーに警告していないので、UACは、招待直すのContent-処分「警告」とAlert-Infoヘッダーフィールドやボディを追加しないこともできます。"
    },
    {
      "indent": 3,
      "text": "Unlike an INVITE, which can fork, a re-INVITE will never fork, and therefore, only ever generate a single final response. The reason a re-INVITE will never fork is that the Request-URI identifies the target as the UA instance it established the dialog with, rather than identifying an address-of-record for the user.",
      "ja": "INVITEとは異なり、決してフォーク、したがって、唯一のこれまで単一の最終的な応答を生成します再INVITE、フォークすることができました。意志は決してフォーク再INVITE理由は、Request-URIが、それはむしろユーザのアドレス・オブ・レコードを識別するより、との対話を確立UAインスタンスとして対象を同定することです。"
    },
    {
      "indent": 3,
      "text": "Note that a UAC MUST NOT initiate a new INVITE transaction within a dialog while another INVITE transaction is in progress in either direction.",
      "ja": "別のトランザクションがいずれかの方向に進行中であるINVITEながら、UACは、ダイアログ内の新しいINVITEトランザクションを開始してはならないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "1. If there is an ongoing INVITE client transaction, the TU MUST wait until the transaction reaches the completed or terminated state before initiating the new INVITE.",
      "ja": "1.現在進行中のINVITEクライアントトランザクションがある場合は、トランザクションが新しいINVITEを開始する前に完了または終了状態に到達するまで、TUは待たなければなりません。"
    },
    {
      "indent": 6,
      "text": "2. If there is an ongoing INVITE server transaction, the TU MUST wait until the transaction reaches the confirmed or terminated state before initiating the new INVITE.",
      "ja": "2.現在進行中のINVITEサーバートランザクションがある場合は、トランザクションが新しいINVITEを開始する前に確認または終了状態に到達するまで、TUは待たなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, a UA MAY initiate a regular transaction while an INVITE transaction is in progress. A UA MAY also initiate an INVITE transaction while a regular transaction is in progress.",
      "ja": "INVITEトランザクションが進行している間しかし、UAは通常のトランザクションを開始することができます。通常のトランザクションの進行中に、UAはまた、INVITEトランザクションを開始することができます。"
    },
    {
      "indent": 3,
      "text": "If a UA receives a non-2xx final response to a re-INVITE, the session parameters MUST remain unchanged, as if no re-INVITE had been issued. Note that, as stated in Section 12.2.1.2, if the non-2xx final response is a 481 (Call/Transaction Does Not Exist), or a 408 (Request Timeout), or no response at all is received for the re-INVITE (that is, a timeout is returned by the INVITE client transaction), the UAC will terminate the dialog.",
      "ja": "UAは、INVITEを再に対する非2xxの最終応答を受信した場合に発行されていた何の再INVITEないかのように、セッションパラメータは、変わらないままでなければなりません。セクション12.2.1.2で述べたように、非2xxの最終応答が481であれば、なお、（コール/トランザクションが存在しない）、または408（要求タイムアウト）、または再INVITEのために全く応答が受信されません（つまり、タイムアウトがINVITEクライアントトランザクションによって返される）、UACはダイアログを終了します。"
    },
    {
      "indent": 3,
      "text": "If a UAC receives a 491 response to a re-INVITE, it SHOULD start a timer with a value T chosen as follows:",
      "ja": "UACは再INVITEへの491応答を受信した場合、次のように、それはTが選ばれた値でタイマーを開始する必要があります。"
    },
    {
      "indent": 6,
      "text": "1. If the UAC is the owner of the Call-ID of the dialog ID (meaning it generated the value), T has a randomly chosen value between 2.1 and 4 seconds in units of 10 ms.",
      "ja": "1. UACは、コールID（それは値を生成意味する）ダイアログIDの所有者である場合、Tは、10ミリ秒の単位で2.1と4秒の間でランダムに選択された値を有します。"
    },
    {
      "indent": 6,
      "text": "2. If the UAC is not the owner of the Call-ID of the dialog ID, T has a randomly chosen value of between 0 and 2 seconds in units of 10 ms.",
      "ja": "UACは、ダイアログIDのコールIDの所有者でない場合は2を、Tは10ミリ秒の単位で0〜2秒のランダムに選択された値を有します。"
    },
    {
      "indent": 3,
      "text": "When the timer fires, the UAC SHOULD attempt the re-INVITE once more, if it still desires for that session modification to take place. For example, if the call was already hung up with a BYE, the re-INVITE would not take place.",
      "ja": "ときにタイマーが起動、UACは、それはまだ場所を取るために、そのセッションの変更のために希望する場合は、もう一度再INVITEを試みるべきです。例えば、場合コールがすでにBYEでハングアップして、再INVITE起こらないでしょう。"
    },
    {
      "indent": 3,
      "text": "The rules for transmitting a re-INVITE and for generating an ACK for a 2xx response to re-INVITE are the same as for the initial INVITE (Section 13.2.1).",
      "ja": "再INVITEを送信するため、再INVITE初期INVITE（セクション13.2.1）と同じであるため2xx応答に対するACKを生成するためのルール。"
    },
    {
      "indent": 0,
      "text": "14.2 UAS Behavior",
      "section_title": true,
      "ja": "14.2挙動"
    },
    {
      "indent": 3,
      "text": "Section 13.3.1 describes the procedure for distinguishing incoming re-INVITEs from incoming initial INVITEs and handling a re-INVITE for an existing dialog.",
      "ja": "セクション13.3.1は、入ってくる初期のINVITEからの着信の再招待区別し、既存のダイアログのために再INVITEを処理するための手順を説明します。"
    },
    {
      "indent": 3,
      "text": "A UAS that receives a second INVITE before it sends the final response to a first INVITE with a lower CSeq sequence number on the same dialog MUST return a 500 (Server Internal Error) response to the second INVITE and MUST include a Retry-After header field with a randomly chosen value of between 0 and 10 seconds.",
      "ja": "それは最初に、最終的な応答は、INVITE第500（サーバ内部エラー）応答を返さなければならない同じダイアログ上に下部のCSeqシーケンス番号にINVITEを送信する前に、第2のINVITEを受信し、再試行の後ヘッダフィールドを含まなければならないUAS 0〜10秒のランダムに選択された値を有します。"
    },
    {
      "indent": 3,
      "text": "A UAS that receives an INVITE on a dialog while an INVITE it had sent on that dialog is in progress MUST return a 491 (Request Pending) response to the received INVITE.",
      "ja": "それは、そのダイアログ上で送信されたINVITEが進行している間ダイアログでINVITEを受信するUASは、INVITE受信に491（要求保留）応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a UA receives a re-INVITE for an existing dialog, it MUST check any version identifiers in the session description or, if there are no version identifiers, the content of the session description to see if it has changed. If the session description has changed, the UAS MUST adjust the session parameters accordingly, possibly after asking the user for confirmation.",
      "ja": "UAが既存のダイアログのために再INVITEを受信した場合、何のバージョン識別子が存在しない場合は、それが変更されているかどうかを確認するために、セッション記述の内容をセッション記述における任意のバージョン識別子をチェックしたりしなければなりません。セッション記述が変更された場合、UASは、おそらくユーザーに確認を求めた後、それに応じてセッションパラメータを調整する必要があります。"
    },
    {
      "indent": 6,
      "text": "Versioning of the session description can be used to accommodate the capabilities of new arrivals to a conference, add or delete media, or change from a unicast to a multicast conference.",
      "ja": "セッション記述のバージョン管理は、会議に新着の機能に対応追加したり、メディアを削除、またはマルチキャスト会議にユニキャストから変更するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the new session description is not acceptable, the UAS can reject it by returning a 488 (Not Acceptable Here) response for the re-INVITE. This response SHOULD include a Warning header field.",
      "ja": "新しいセッション記述が許容されていない場合、UASは再INVITEのための488（ここでは許容できない）応答を返すことで、それを拒否することができます。この応答は、警告ヘッダフィールドを含むべきです。"
    },
    {
      "indent": 3,
      "text": "If a UAS generates a 2xx response and never receives an ACK, it SHOULD generate a BYE to terminate the dialog.",
      "ja": "UASは、2xx応答を生成し、決してACKを受信した場合、それはダイアログを終了するBYEを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "A UAS MAY choose not to generate 180 (Ringing) responses for a re-INVITE because UACs do not typically render this information to the user. For the same reason, UASs MAY choose not to use an Alert-Info header field or a body with Content-Disposition \"alert\" in responses to a re-INVITE.",
      "ja": "UASは求めるUACは、一般的にこの情報をユーザにレンダリングされませんので、再INVITE 180（リンギング）応答を生成しないこともできます。同じ理由で、のUASは再INVITEに対する応答のContent-処分「警告」とAlert-Infoヘッダーフィールドやボディを使用しないことも選択できます。"
    },
    {
      "indent": 3,
      "text": "A UAS providing an offer in a 2xx (because the INVITE did not contain an offer) SHOULD construct the offer as if the UAS were making a brand new call, subject to the constraints of sending an offer that updates an existing session, as described in [13] in the case of SDP. Specifically, this means that it SHOULD include as many media formats and media types that the UA is willing to support. The UAS MUST ensure that the session description overlaps with its previous session description in media formats, transports, or other parameters that require support from the peer. This is to avoid the need for the peer to reject the session description. If, however, it is unacceptable to the UAC, the UAC SHOULD generate an answer with a valid session description, and then send a BYE to terminate the session.",
      "ja": "2XXでのオファーを提供するUAS（理由のオファーが含まれていなかったINVITE）UASは、既存のセッションが更新のオファーを送るの制約を受け、ブランドの新しいコールを、作っていたかのように説明するように、プランを構築すべきですSDPの場合には[13]。具体的には、これはUAがサポートしていく所存ですなど、多くのメディアフォーマットとメディアタイプを含めるべきであることを意味します。 UASは、セッション記述は、メディア形式、トランスポート、またはピアからのサポートを必要とする他のパラメータの以前のセッション記述と重なっていることを確認しなければなりません。これは、セッション記述を拒絶するピアの必要性を回避することです。しかし、それはUACに受け入れられない場合は、UACが有効なセッション記述で解答を生成して、セッションを終了するためにBYEを送るべきです。"
    },
    {
      "indent": 0,
      "text": "15 Terminating a Session",
      "ja": "15セッションの終了"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for terminating a session established by SIP. The state of the session and the state of the dialog are very closely related. When a session is initiated with an INVITE, each 1xx or 2xx response from a distinct UAS creates a dialog, and if that response completes the offer/answer exchange, it also creates a session. As a result, each session is \"associated\" with a single dialog - the one which resulted in its creation. If an initial INVITE generates a non-2xx final response, that terminates all sessions (if any) and all dialogs (if any) that were created through responses to the request. By virtue of completing the transaction, a non-2xx final response also prevents further sessions from being created as a result of the INVITE. The BYE request is used to terminate a specific session or attempted session. In this case, the specific session is the one with the peer UA on the other side of the dialog. When a BYE is received on a dialog, any session associated with that dialog SHOULD terminate. A UA MUST NOT send a BYE outside of a dialog. The caller's UA MAY send a BYE for either confirmed or early dialogs, and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT send a BYE on early dialogs.",
      "ja": "このセクションでは、SIPにより確立されたセッションを終了するための手順を記載しています。セッションや対話の状態の状態は非常に密接に関連しています。セッションがINVITEで開始されると、明確なUASからそれぞれの1xxかの2xx応答がダイアログを作成し、その応答は、オファー/アンサー交換を完了した場合、それはまた、セッションを作成します。その創造の結果1  - その結果、各セッションは、単一のダイアログに「関連する」されます。最初のINVITEをした場合は、すべてのセッション（もしあれば）、要求に対する応答を介して作成されたすべてのダイアログを（もしあれば）を終了2xx以外の最終応答を生成します。トランザクションを完了するのおかげで、非2xxの最終応答はまた、INVITEの結果として作成されることから、さらにセッションを防止します。 BYE要求は、特定のセッションまたは試行セッションを終了するために使用されます。この場合、特定のセッションは、ダイアログの反対側のピアUAを有するものです。 BYEはダイアログ上で受信されると、そのダイアログに関連付けられたすべてのセッションが終了するべきです。 UAは、ダイアログの外でBYEを送ってはいけません。呼び出し側のUAは確認または早期のいずれかのダイアログのためにBYEを送信することができ、および呼び出し先のUAは確認ダイアログ上でBYEを送ることが、早期ダイアログ上でBYEを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "However, the callee's UA MUST NOT send a BYE on a confirmed dialog until it has received an ACK for its 2xx response or until the server transaction times out. If no SIP extensions have defined other application layer states associated with the dialog, the BYE also terminates the dialog.",
      "ja": "それはその2xx応答またはサーバートランザクションがタイムアウトするまで、ACKを受信するまでただし、呼び出し先のUAは確認ダイアログ上でBYEを送ってはいけません。何のSIP拡張は、ダイアログに関連する他のアプリケーション層の状態を定義していない場合は、BYEもダイアログを終了します。"
    },
    {
      "indent": 3,
      "text": "The impact of a non-2xx final response to INVITE on dialogs and sessions makes the use of CANCEL attractive. The CANCEL attempts to force a non-2xx response to the INVITE (in particular, a 487). Therefore, if a UAC wishes to give up on its call attempt entirely, it can send a CANCEL. If the INVITE results in 2xx final response(s) to the INVITE, this means that a UAS accepted the invitation while the CANCEL was in progress. The UAC MAY continue with the sessions established by any 2xx responses, or MAY terminate them with BYE.",
      "ja": "ダイアログおよびセッションでINVITEに対する2xx以外の最終応答の影響はの使用は魅力的CANCELなります。非の2xx応答を強制する試みをキャンセルINVITE（487、特に）。 UACは完全にそのコール試行をあきらめることを希望する場合したがって、それはCANCELを送ることができます。 INVITEへの2xx最終応答（複数可）で結果をINVITE場合、これは、CANCELが進行中であったUASが招待を受け入れたことを意味します。 UACは、任意の2xx応答で確立されたセッションを続行したり、BYEでそれらを終了することができます。"
    },
    {
      "indent": 6,
      "text": "The notion of \"hanging up\" is not well defined within SIP. It is specific to a particular, albeit common, user interface. Typically, when the user hangs up, it indicates a desire to terminate the attempt to establish a session, and to terminate any sessions already created. For the caller's UA, this would imply a CANCEL request if the initial INVITE has not generated a final response, and a BYE to all confirmed dialogs after a final response. For the callee's UA, it would typically imply a BYE; presumably, when the user picked up the phone, a 2xx was generated, and so hanging up would result in a BYE after the ACK is received. This does not mean a user cannot hang up before receipt of the ACK, it just means that the software in his phone needs to maintain state for a short while in order to clean up properly. If the particular UI allows for the user to reject a call before its answered, a 403 (Forbidden) is a good way to express that. As per the rules above, a BYE can't be sent.",
      "ja": "「ハングアップ」の概念は十分にSIP内で定義されていません。これは、一般的に、ユーザインターフェースはいえ、特定の固有のものです。ユーザーがハングアップした場合、通常、それはセッションを確立しようとする試みを終了する願望を示しており、すでに作成されたすべてのセッションを終了します。呼び出し側のUAの場合、これは初期のが最終的な応答の後、すべての確認ダイアログに最終応答、およびBYEを生成していない招待した場合CANCELリクエストを暗示します。呼び出し先のUAの場合、それは通常BYEを暗示します。おそらく、ユーザーが電話を拾ったときに、2XXが発生し、ACKが受信された後にそうハングアップすることはBYEことになります。これにより、ユーザはACKを受信する前にハングアップすることができないという意味ではありません、それだけで彼の電話でのソフトウェアが適切にクリーンアップするために、しばらく状態を維持する必要があることを意味します。特定のUIがその答えの前に呼び出しを拒否するためにユーザを可能にした場合は、403（禁止）がそれを表現するための良い方法です。上記の規則に従って、BYEを送信することはできません。"
    },
    {
      "indent": 0,
      "text": "15.1 Terminating a Session with a BYE Request",
      "section_title": true,
      "ja": "BYEリクエストとセッションの終了15.1"
    },
    {
      "indent": 0,
      "text": "15.1.1 UAC Behavior",
      "section_title": true,
      "ja": "15.1.1 UACの動作"
    },
    {
      "indent": 3,
      "text": "A BYE request is constructed as would any other request within a dialog, as described in Section 12.",
      "ja": "項12に記載のようにBYE要求は、ダイアログ内の他の要求と同じように構成されています。"
    },
    {
      "indent": 3,
      "text": "Once the BYE is constructed, the UAC core creates a new non-INVITE client transaction, and passes it the BYE request. The UAC MUST consider the session terminated (and therefore stop sending or listening for media) as soon as the BYE request is passed to the client transaction. If the response for the BYE is a 481 (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no response at all is received for the BYE (that is, a timeout is returned by the client transaction), the UAC MUST consider the session and the dialog terminated.",
      "ja": "BYEが構築されると、UACコアは新規の非INVITEクライアントトランザクションを作成し、それにBYE要求を渡します。 UACは、すぐにBYE要求がクライアントトランザクションに渡されるように、セッション終了を検討する（したがって、送信またはメディアのリスニングを停止）しなければなりません。 BYEに対する応答は481（コール/トランザクションが存在しない）または408（リクエストタイムアウト）であるか、全く応答が（つまり、タイムアウトがクライアントトランザクションによって返される）BYEのために受信されない、UAC場合セッションと終了ダイアログを考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "15.1.2 UAS Behavior",
      "section_title": true,
      "ja": "15.1.2その振る舞い"
    },
    {
      "indent": 3,
      "text": "A UAS first processes the BYE request according to the general UAS processing described in Section 8.2. A UAS core receiving a BYE request checks if it matches an existing dialog. If the BYE does not match an existing dialog, the UAS core SHOULD generate a 481 (Call/Transaction Does Not Exist) response and pass that to the server transaction.",
      "ja": "UASは、最初のセクション8.2に記載の一般的なUAS処理に従ってBYE要求を処理します。それは既存のダイアログに一致した場合BYE要求のチェックを受けるUASコア。 BYEが既存のダイアログが一致しない場合、UASコアは481（/コールトランザクションが存在しない）応答を生成し、サーバートランザクションにそれを渡す必要があります。"
    },
    {
      "indent": 6,
      "text": "This rule means that a BYE sent without tags by a UAC will be rejected. This is a change from RFC 2543, which allowed BYE without tags.",
      "ja": "このルールは、UACにより、タグなしで送信BYEは拒否されることを意味します。これは、タグなしBYE許さRFC 2543から変更されています。"
    },
    {
      "indent": 3,
      "text": "A UAS core receiving a BYE request for an existing dialog MUST follow the procedures of Section 12.2.2 to process the request. Once done, the UAS SHOULD terminate the session (and therefore stop sending and listening for media). The only case where it can elect not to are multicast sessions, where participation is possible even if the other participant in the dialog has terminated its involvement in the session. Whether or not it ends its participation on the session, the UAS core MUST generate a 2xx response to the BYE, and MUST pass that to the server transaction for transmission.",
      "ja": "既存のダイアログのBYE要求を受信するUASコアは、要求を処理するために、セクション12.2.2の手順に従わなければなりません。一度行われ、UASは、セッションを終了する（したがって、送信とメディアのためのリスニングを停止する）べきです。それは参加は、ダイアログ内の他の参加者がセッションへの関与を終了した場合であっても可能であるマルチキャストセッション、あるしないことを選択することができる唯一のケース。それは、セッションへの参加を終了するか否か、UASコアは、BYEに対する2xx応答を生成しなければなりません、そして送信のためにサーバートランザクションにそれを渡さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The UAS MUST still respond to any pending requests received for that dialog. It is RECOMMENDED that a 487 (Request Terminated) response be generated to those pending requests.",
      "ja": "UASはまだそのダイアログのために受け取ったすべての保留中の要求に応じなければなりません。 487（リクエスト終端）応答は、それらの保留中の要求を生成することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "16 Proxy Behavior",
      "ja": "16プロキシの動作"
    },
    {
      "indent": 0,
      "text": "16.1 Overview",
      "section_title": true,
      "ja": "16.1概要"
    },
    {
      "indent": 3,
      "text": "SIP proxies are elements that route SIP requests to user agent servers and SIP responses to user agent clients. A request may traverse several proxies on its way to a UAS. Each will make routing decisions, modifying the request before forwarding it to the next element. Responses will route through the same set of proxies traversed by the request in the reverse order.",
      "ja": "SIPプロキシは、ユーザエージェントサーバとユーザエージェントクライアントにSIP応答にルーティングするSIP要求をその要素です。リクエストは、UASへ向かう途中で、いくつかのプロキシを横断してもよいです。それぞれ、次の要素に転送する前にリクエストを修正、ルーティングの決定を行います。反応は逆の順序で要求が横断プロキシの同じセットを通るルートであろう。"
    },
    {
      "indent": 3,
      "text": "Being a proxy is a logical role for a SIP element. When a request arrives, an element that can play the role of a proxy first decides if it needs to respond to the request on its own. For instance, the request may be malformed or the element may need credentials from the client before acting as a proxy. The element MAY respond with any appropriate error code. When responding directly to a request, the element is playing the role of a UAS and MUST behave as described in Section 8.2.",
      "ja": "プロキシであることはSIP要素のための論理的な役割です。要求が到着すると、それは自分自身で要求に応答する必要がある場合は、プロキシの役割を果たすことができる要素が最初に決定します。例えば、要求が不正な形式であるか、または要素がプロキシとして動作する前に、クライアントからの認証情報が必要な場合があります。要素は、任意の適切なエラーコードで応答することができます。リクエストに直接応答する場合、要素は、UASの役割を果たしているし、8.2節で説明したように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "A proxy can operate in either a stateful or stateless mode for each new request. When stateless, a proxy acts as a simple forwarding element. It forwards each request downstream to a single element determined by making a targeting and routing decision based on the request. It simply forwards every response it receives upstream. A stateless proxy discards information about a message once the message has been forwarded. A stateful proxy remembers information (specifically, transaction state) about each incoming request and any requests it sends as a result of processing the incoming request. It uses this information to affect the processing of future messages associated with that request. A stateful proxy MAY choose to \"fork\" a request, routing it to multiple destinations. Any request that is forwarded to more than one location MUST be handled statefully.",
      "ja": "プロキシは、それぞれの新しい要求のためのステートフルまたはステートレスモードのいずれかで動作することができます。ときはステートレス、プロキシは、単純な転送要素として機能します。その要求に基づいて、ターゲットとルーティング決定を行うことによって決定単一の要素に下流各要求を転送します。それは単に転送し、すべての応答には、上流受け取ります。メッセージが転送された後、ステートレスプロキシは、メッセージに関する情報を破棄します。ステートフルプロキシは、各着信要求し、それが着信要求を処理結果として送信し、任意の要求に関する情報（具体的には、トランザクションの状態）を記憶しています。これは、その要求に関連した今後のメッセージの処理に影響を与えるために、この情報を使用しています。ステートフルプロキシは、複数の宛先にそれをルーティングする、「フォーク」にリクエストを選ぶかもしれません。複数の場所に転送されるすべての要求をステートフル処理されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, a proxy MAY forward requests using stateful transports (such as TCP) without being transaction-stateful. For instance, a proxy MAY forward a request from one TCP connection to another transaction statelessly as long as it places enough information in the message to be able to forward the response down the same connection the request arrived on. Requests forwarded between different types of transports where the proxy's TU must take an active role in ensuring reliable delivery on one of the transports MUST be forwarded transaction statefully.",
      "ja": "いくつかの状況では、プロキシは、トランザクションステートフルせずに（TCPのような）ステートフルトランスポートを使用して要求を転送することができます。たとえば、プロキシはステートレスであれば、要求が到着した同じ接続ダウン応答を転送できるようにするメッセージに十分な情報を置くよう別のトランザクションに1つのTCP接続からの要求を転送することができます。プロキシのTUは、トランスポートのいずれかで信頼性の高い配信を確保する上で積極的な役割を取る必要がありますトランスポートの異なる種類の間で転送された要求は、ステートフルトランザクションを転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "A stateful proxy MAY transition to stateless operation at any time during the processing of a request, so long as it did not do anything that would otherwise prevent it from being stateless initially (forking, for example, or generation of a 100 response). When performing such a transition, all state is simply discarded. The proxy SHOULD NOT initiate a CANCEL request.",
      "ja": "ステートフルプロキシは、それがそうでなければ最初にステートレスである（例えば、分岐、または100応答の発生）を防ぐであろう何もしなかったように、要求の処理中の任意の時点で、ステートレス動作に移行することができます。そのような移行を行う場合、すべての状態が単に破棄されます。プロキシはCANCEL要求を開始すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Much of the processing involved when acting statelessly or statefully for a request is identical. The next several subsections are written from the point of view of a stateful proxy. The last section calls out those places where a stateless proxy behaves differently.",
      "ja": "要求に対してステートレスまたはステートフルに動作するとき伴う処理の多くは同じです。次のいくつかのサブセクションは、ステートフルプロキシの視点から書かれています。最後のセクションでは、ステートレスプロキシが異なった動作をそれらの場所を呼び出します。"
    },
    {
      "indent": 0,
      "text": "16.2 Stateful Proxy",
      "section_title": true,
      "ja": "16.2ステートフルプロキシ"
    },
    {
      "indent": 3,
      "text": "When stateful, a proxy is purely a SIP transaction processing engine. Its behavior is modeled here in terms of the server and client transactions defined in Section 17. A stateful proxy has a server transaction associated with one or more client transactions by a higher layer proxy processing component (see figure 3), known as a proxy core. An incoming request is processed by a server transaction. Requests from the server transaction are passed to a proxy core. The proxy core determines where to route the request, choosing one or more next-hop locations. An outgoing request for each next-hop location is processed by its own associated client transaction. The proxy core collects the responses from the client transactions and uses them to send responses to the server transaction.",
      "ja": "ときステートフル、プロキシは純粋にSIPトランザクション処理エンジンです。その挙動は、プロキシコアとして知られ、ステートフルプロキシは、上位レイヤプロキシ処理コンポーネントによって、1つまたは複数のクライアント・トランザクションに関連付けられたサーバートランザクションを有する（図3参照）部17で定義されたサーバとクライアントトランザクションの観点ここでモデル化されます。着信要求は、サーバートランザクションによって処理されます。サーバートランザクションからの要求は、プロキシコアに渡されます。プロキシコアは、一つ以上の次のホップの位置を選択すること、ここでルート要求をすることを決定します。各ネクストホップの場所の発信要求は、自身の関連するクライアントトランザクションによって処理されます。プロキシコアはクライアントトランザクションからの応答を収集し、サーバートランザクションに応答を送信するためにそれらを使用しています。"
    },
    {
      "indent": 3,
      "text": "A stateful proxy creates a new server transaction for each new request received. Any retransmissions of the request will then be handled by that server transaction per Section 17. The proxy core MUST behave as a UAS with respect to sending an immediate provisional on that server transaction (such as 100 Trying) as described in Section 8.2.6. Thus, a stateful proxy SHOULD NOT generate 100 (Trying) responses to non-INVITE requests.",
      "ja": "ステートフルプロキシは、受信した各新しい要求のための新しいサーバートランザクションを作成します。要求のいずれか再送信は、プロキシコアは、セクション8.2.6に記載のように（例えば100試行など）即時仮そのサーバー上のトランザクションを送信に対してUASとして動作しなければならない部17あたりのサーバトランザクションによって処理されるであろう。したがって、ステートフルプロキシは非INVITEリクエストに対する100（しよう）応答を生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "This is a model of proxy behavior, not of software. An implementation is free to take any approach that replicates the external behavior this model defines.",
      "ja": "これは、プロキシの挙動のではなく、ソフトウェアのモデルです。実装は、このモデルが定義されて外部の行動を複製どんなアプローチを取るために自由です。"
    },
    {
      "indent": 3,
      "text": "For all new requests, including any with unknown methods, an element intending to proxy the request MUST:",
      "ja": "未知の方法、プロキシにMUST要求を意図要素とのいずれかを含むすべての新しい要求について："
    },
    {
      "indent": 6,
      "text": "1. Validate the request (Section 16.3)",
      "section_title": true,
      "ja": "1.要求を検証します（セクション16.3）"
    },
    {
      "indent": 6,
      "text": "2. Preprocess routing information (Section 16.4)",
      "section_title": true,
      "ja": "2.前処理ルーティング情報（セクション16.4）"
    },
    {
      "indent": 6,
      "text": "3. Determine target(s) for the request (Section 16.5)",
      "section_title": true,
      "ja": "3.要求の対象（複数可）を決定し（セクション16.5）"
    },
    {
      "indent": 6,
      "text": "      +--------------------+\n      |                    | +---+\n      |                    | | C |\n      |                    | | T |\n      |                    | +---+\n+---+ |       Proxy        | +---+   CT = Client Transaction\n| S | |  \"Higher\" Layer    | | C |\n| T | |                    | | T |   ST = Server Transaction\n+---+ |                    | +---+\n      |                    | +---+\n      |                    | | C |\n      |                    | | T |\n      |                    | +---+\n      +--------------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 3: Stateful Proxy Model",
      "ja": "図3：ステートフルプロキシモデル"
    },
    {
      "indent": 6,
      "text": "4. Forward the request to each target (Section 16.6)",
      "section_title": true,
      "ja": "4.各ターゲットに要求を転送（セクション16.6）"
    },
    {
      "indent": 6,
      "text": "5. Process all responses (Section 16.7)",
      "section_title": true,
      "ja": "5.プロセスのすべての回答（16.7項）"
    },
    {
      "indent": 0,
      "text": "16.3 Request Validation",
      "section_title": true,
      "ja": "16.3要求の検証"
    },
    {
      "indent": 3,
      "text": "Before an element can proxy a request, it MUST verify the message's validity. A valid message must pass the following checks:",
      "ja": "要求のプロキシ要素ができる前に、それは、メッセージの有効性を確かめなければなりません。有効なメッセージは、以下のチェックを渡す必要があります。"
    },
    {
      "indent": 6,
      "text": "1. Reasonable Syntax",
      "section_title": true,
      "ja": "1.合理的な構文"
    },
    {
      "indent": 6,
      "text": "2. URI scheme",
      "section_title": true,
      "ja": "2. URIスキーム"
    },
    {
      "indent": 6,
      "text": "3. Max-Forwards",
      "section_title": true,
      "ja": "3.マックス・フォワード"
    },
    {
      "indent": 6,
      "text": "4. (Optional) Loop Detection",
      "section_title": true,
      "ja": "4.（オプション）ループ検出"
    },
    {
      "indent": 6,
      "text": "5. Proxy-Require",
      "section_title": true,
      "ja": "5.プロキシ要求"
    },
    {
      "indent": 6,
      "text": "6. Proxy-Authorization",
      "section_title": true,
      "ja": "6.プロキシ認証"
    },
    {
      "indent": 3,
      "text": "If any of these checks fail, the element MUST behave as a user agent server (see Section 8.2) and respond with an error code.",
      "ja": "これらのチェックのいずれかが失敗した場合、要素は、ユーザエージェントサーバ（8.2節を参照）として動作し、エラーコードで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "Notice that a proxy is not required to detect merged requests and MUST NOT treat merged requests as an error condition. The endpoints receiving the requests will resolve the merge as described in Section 8.2.2.2.",
      "ja": "プロキシがマージされた要求を検出するために必要とされていないとエラー条件としてマージされたリクエストを処理てはならないことに注意してください。 8.2.2.2項で説明するように依頼を受けたエンドポイントは、マージを解決します。"
    },
    {
      "indent": 3,
      "text": "1. Reasonable syntax check",
      "section_title": true,
      "ja": "1.合理的な構文チェック"
    },
    {
      "indent": 6,
      "text": "The request MUST be well-formed enough to be handled with a server transaction. Any components involved in the remainder of these Request Validation steps or the Request Forwarding section MUST be well-formed. Any other components, well-formed or not, SHOULD be ignored and remain unchanged when the message is forwarded. For instance, an element would not reject a request because of a malformed Date header field. Likewise, a proxy would not remove a malformed Date header field before forwarding a request.",
      "ja": "要求がサーバートランザクションで処理されるように十分によく形成しなければなりません。これらの要求の検証手順の残りまたは要求転送部に関与する任意の構成要素は、良く形成しなければなりません。任意の他の成分は、整形式かどうか、無視されるべきであり、メッセージが転送されたときに変わりません。例えば、要素があるため、不正な形式の日付ヘッダフィールドの要求を拒否しないであろう。同様に、プロキシは、要求を転送する前に、不正な日付ヘッダフィールドを削除しないでしょう。"
    },
    {
      "indent": 6,
      "text": "This protocol is designed to be extended. Future extensions may define new methods and header fields at any time. An element MUST NOT refuse to proxy a request because it contains a method or header field it does not know about.",
      "ja": "このプロトコルは拡張できるように設計されています。将来の拡張機能は、いつでも新しいメソッドやヘッダーフィールドを定義することができます。それが知らない方法またはヘッダフィールドが含まれているので、要素は、プロキシに、要求を拒否してはなりません。"
    },
    {
      "indent": 3,
      "text": "2. URI scheme check",
      "section_title": true,
      "ja": "2. URIスキームチェック"
    },
    {
      "indent": 6,
      "text": "If the Request-URI has a URI whose scheme is not understood by the proxy, the proxy SHOULD reject the request with a 416 (Unsupported URI Scheme) response.",
      "ja": "リクエストURIは、そのスキームプロキシによって理解されていないURIを持っている場合、プロキシは416（サポートされていないURIスキーム）応答で要求を拒絶すべきです。"
    },
    {
      "indent": 3,
      "text": "3. Max-Forwards check",
      "section_title": true,
      "ja": "3.マックス・フォワードチェック"
    },
    {
      "indent": 6,
      "text": "The Max-Forwards header field (Section 20.22) is used to limit the number of elements a SIP request can traverse.",
      "ja": "最大Forwardsヘッダーフィールド（セクション20.22）は、SIP要求が通過できる要素の数を制限するために使用されます。"
    },
    {
      "indent": 6,
      "text": "If the request does not contain a Max-Forwards header field, this check is passed.",
      "ja": "リクエストがMax-Forwardsヘッダーフィールドを含んでいない場合は、このチェックが渡されます。"
    },
    {
      "indent": 6,
      "text": "If the request contains a Max-Forwards header field with a field value greater than zero, the check is passed.",
      "ja": "要求がゼロより大きいフィールド値を持つMax-Forwardsヘッダーフィールドを含んでいる場合、チェックが渡されます。"
    },
    {
      "indent": 6,
      "text": "If the request contains a Max-Forwards header field with a field value of zero (0), the element MUST NOT forward the request. If the request was for OPTIONS, the element MAY act as the final recipient and respond per Section 11. Otherwise, the element MUST return a 483 (Too many hops) response.",
      "ja": "要求がゼロ（0）のフィールド値とMax-Forwardsヘッダーフィールドを含んでいる場合、要素は、要求を転送してはいけません。リクエストがOPTIONSのためだった場合は、要素は、最終的な受信者として機能し、それ以外の場合、要素は483（ホップ数が多すぎ）応答を返さなければなりません、セクション11ごとに応答することができます。"
    },
    {
      "indent": 3,
      "text": "4. Optional Loop Detection check",
      "section_title": true,
      "ja": "4.オプションループ検出チェック"
    },
    {
      "indent": 6,
      "text": "An element MAY check for forwarding loops before forwarding a request. If the request contains a Via header field with a sent-by value that equals a value placed into previous requests by the proxy, the request has been forwarded by this element before. The request has either looped or is legitimately spiraling through the element. To determine if the request has looped, the element MAY perform the branch parameter calculation described in Step 8 of Section 16.6 on this message and compare it to the parameter received in that Via header field. If the parameters match, the request has looped. If they differ, the request is spiraling, and processing continues. If a loop is detected, the element MAY return a 482 (Loop Detected) response.",
      "ja": "要素は、要求を転送する前にループを転送するためにチェックすること。要求がプロキシによって以前のリクエストに入れた値に等しい送信バイ値を持つViaヘッダーフィールドが含まれている場合、要求は前にこの要素によって転送されてきました。要求がループしたか、または合法的要素を通してスパイラルれます。要求がループしているかどうかを決定するために、要素は、このメッセージのセクション16.6のステップ8に記載分岐パラメータ計算を実行し、Viaヘッダーフィールドという点で受信したパラメータにそれを比較することができます。パラメータが一致した場合、要求がループしています。それらが異なる場合は、リクエストがスパイラルされ、処理が継続されます。ループが検出された場合、要素482（ループ検出）応答を返すことができます。"
    },
    {
      "indent": 3,
      "text": "5. Proxy-Require check",
      "section_title": true,
      "ja": "5.プロキシ要求チェック"
    },
    {
      "indent": 6,
      "text": "Future extensions to this protocol may introduce features that require special handling by proxies. Endpoints will include a Proxy-Require header field in requests that use these features, telling the proxy not to process the request unless the feature is understood.",
      "ja": "このプロトコルの将来の拡張には、プロキシによって特別な処理を必要とする機能を導入することができます。エンドポイントは、機能が理解されない限り、要求を処理しないようにプロキシを伝える、これらの機能を使用する要求にプロキシRequireヘッダーフィールドが含まれます。"
    },
    {
      "indent": 6,
      "text": "If the request contains a Proxy-Require header field (Section 20.29) with one or more option-tags this element does not understand, the element MUST return a 420 (Bad Extension) response. The response MUST include an Unsupported (Section 20.40) header field listing those option-tags the element did not understand.",
      "ja": "リクエストは、1つまたは複数のオプションタグとプロキシ-Requireヘッダーフィールド（セクション20.29）が含まれている場合、この要素が理解していない、要素は420（悪い拡張）応答を返さなければなりません。応答は、要素が理解していなかったこれらのオプションタグをリストサポートされていない（セクション20.40）ヘッダーフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. Proxy-Authorization check",
      "section_title": true,
      "ja": "6.プロキシ認証チェック"
    },
    {
      "indent": 6,
      "text": "If an element requires credentials before forwarding a request, the request MUST be inspected as described in Section 22.3. That section also defines what the element must do if the inspection fails.",
      "ja": "要素が要求を転送する前に資格情報が必要な場合は、セクション22.3で説明したように、要求を検査しなければなりません。その節はまた、検査が失敗した場合、要素は何をしなければならないかを定義します。"
    },
    {
      "indent": 0,
      "text": "16.4 Route Information Preprocessing",
      "section_title": true,
      "ja": "16.4ルート情報の前処理"
    },
    {
      "indent": 3,
      "text": "The proxy MUST inspect the Request-URI of the request. If the Request-URI of the request contains a value this proxy previously placed into a Record-Route header field (see Section 16.6 item 4), the proxy MUST replace the Request-URI in the request with the last value from the Route header field, and remove that value from the Route header field. The proxy MUST then proceed as if it received this modified request.",
      "ja": "プロキシはリクエストのRequest-URIを検査しなければなりません。要求のリクエストURI（セクション16.6項目4参照）、このプロキシが以前にRecord-Routeヘッダフィールドに置かれた値が含まれている場合、プロキシはRouteヘッダーフィールドの最後の値と要求でのRequest-URIを交換する必要があります、およびRouteヘッダフィールドからその値を削除します。それは、この変更要求を受けたかのようにプロキシは、次に進む必要があります。"
    },
    {
      "indent": 6,
      "text": "This will only happen when the element sending the request to the proxy (which may have been an endpoint) is a strict router. This rewrite on receive is necessary to enable backwards compatibility with those elements. It also allows elements following this specification to preserve the Request-URI through strict-routing proxies (see Section 12.2.1.1).",
      "ja": "（エンドポイントであったかもしれない）プロキシにリクエストを送信する要素は、厳密なルータであるときにのみ発生します。受信時のこのリライトは、これらの要素との下位互換性を有効にする必要があります。また、厳密なルーティングプロキシ（セクション12.2.1.1を参照）を介してのRequest-URIを維持するために、本明細書の以下の要素を可能にします。"
    },
    {
      "indent": 6,
      "text": "This requirement does not obligate a proxy to keep state in order to detect URIs it previously placed in Record-Route header fields. Instead, a proxy need only place enough information in those URIs to recognize them as values it provided when they later appear.",
      "ja": "この要件は、それが以前にRecord-Routeヘッダフィールドに配置されたURIを検出するために状態を維持するプロキシを義務付けません。代わりに、プロキシは、彼らだけが後に表示されたときにそれが提供された値としてそれらを認識するためにそれらのURIに十分な情報を配置する必要が。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI contains a maddr parameter, the proxy MUST check to see if its value is in the set of addresses or domains the proxy is configured to be responsible for. If the Request-URI has a maddr parameter with a value the proxy is responsible for, and the request was received using the port and transport indicated (explicitly or by default) in the Request-URI, the proxy MUST strip the maddr and any non-default port or transport parameter and continue processing as if those values had not been present in the request.",
      "ja": "要求URIがMADDRパラメータが含まれている場合、プロキシはその値がプロキシが責任なるように構成されているアドレスやドメインのセットであるかどうかをチェックしなければなりません。要求URIがプロキシが担当する値を持つMADDRパラメータを持ち、かつ要求が要求URIで示されたポートと輸送を（明示的またはデフォルトで）使用して受信された場合、プロキシはMADDRおよび任意の非を除去しなければなりません-defaultポートまたは輸送パラメータ及びそれらの値は、要求に存在していなかったかのように処理を継続します。"
    },
    {
      "indent": 6,
      "text": "A request may arrive with a maddr matching the proxy, but on a port or transport different from that indicated in the URI. Such a request needs to be forwarded to the proxy using the indicated port and transport.",
      "ja": "要求がプロキシを一致MADDR有するが、URIに示されるものとは異なるポートまたはトランスポートに到着してもよいです。そのような要求は、示されたポートおよびトランスポートを使用してプロキシに転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the first value in the Route header field indicates this proxy, the proxy MUST remove that value from the request.",
      "ja": "Routeヘッダーフィールドの最初の値は、このプロキシを示す場合、プロキシは、要求からその値を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "16.5 Determining Request Targets",
      "section_title": true,
      "ja": "16.5決定のリクエストターゲット"
    },
    {
      "indent": 3,
      "text": "Next, the proxy calculates the target(s) of the request. The set of targets will either be predetermined by the contents of the request or will be obtained from an abstract location service. Each target in the set is represented as a URI.",
      "ja": "次に、プロキシは、要求の対象（複数可）を算出します。ターゲットのセットは、いずれかの要求の内容によって予め決定されるか、抽象位置サービスから得られるであろう。セット内の各ターゲットはURIとして表されます。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI of the request contains an maddr parameter, the Request-URI MUST be placed into the target set as the only target URI, and the proxy MUST proceed to Section 16.6.",
      "ja": "要求のリクエストURIがMADDRパラメータが含まれている場合、リクエストURIは、ターゲットURIとして設定された目標に入れなければならない、及びプロキシは、セクション16.6に進行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the domain of the Request-URI indicates a domain this element is not responsible for, the Request-URI MUST be placed into the target set as the only target, and the element MUST proceed to the task of Request Forwarding (Section 16.6).",
      "ja": "Request-URIのドメインはドメインを示している場合、この要素は、ターゲットとして設定された目標に入れなければならないのRequest-URIの原因ではなく、要素は、要求転送（セクション16.6）のタスクに進んでなければなりません。"
    },
    {
      "indent": 6,
      "text": "There are many circumstances in which a proxy might receive a request for a domain it is not responsible for. A firewall proxy handling outgoing calls (the way HTTP proxies handle outgoing requests) is an example of where this is likely to occur.",
      "ja": "プロキシが、それは責任を負いませんドメインに対する要求を受ける可能性のある多くの状況があります。発信コール（HTTPプロキシが発信要求を処理する方法を）扱うファイアウォールプロキシは、これが発生する可能性がある場合の例です。"
    },
    {
      "indent": 3,
      "text": "If the target set for the request has not been predetermined as described above, this implies that the element is responsible for the domain in the Request-URI, and the element MAY use whatever mechanism it desires to determine where to send the request. Any of these mechanisms can be modeled as accessing an abstract Location Service. This may consist of obtaining information from a location service created by a SIP Registrar, reading a database, consulting a presence server, utilizing other protocols, or simply performing an algorithmic substitution on the Request-URI. When accessing the location service constructed by a registrar, the Request-URI MUST first be canonicalized as described in Section 10.3 before being used as an index. The output of these mechanisms is used to construct the target set.",
      "ja": "上記のように要求するために設定された目標が決まっていない場合、これは、要素が要求URI内のドメインに責任があることを意味し、その要素は、それがどこリクエストの送信先を決定することを望むどんなメカニズムを使用してもよい（MAY）。これらのメカニズムのいずれかが抽象ロケーションサービスにアクセスするようにモデル化することができます。これは、SIPレジストラによって作成されたロケーションサービスから情報を取得するデータベースを読み取る、プレゼンスサーバに相談、他のプロトコルを利用する、または単にのRequest-URIにアルゴリズム的置換を行うことからなっていてもよいです。レジストラによって構築ロケーションサービスにアクセスする際のインデックスとして使用される前に、セクション10.3に記載されているように、Request-URIが最初に正規化されなければなりません。これらの機構の出力は、ターゲットセットを構築するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI does not provide sufficient information for the proxy to determine the target set, it SHOULD return a 485 (Ambiguous) response. This response SHOULD contain a Contact header field containing URIs of new addresses to be tried. For example, an INVITE to sip:John.Smith@company.com may be ambiguous at a proxy whose location service has multiple John Smiths listed. See Section 21.4.23 for details.",
      "ja": "要求URIはターゲットセットを決定するために、プロキシのための十分な情報を提供していない場合、それは485（あいまい）レスポンスを返すべきです。この応答は、試される新しいアドレスのURIを含むContactヘッダーフィールドを含むべきです。例えば、SIPにINVITE：John.Smith@company.comは、そのロケーションサービス複数ジョンスミスは、列挙されたプロキシで曖昧であってもよいです。詳細については、セクション21.4.23を参照してください。"
    },
    {
      "indent": 3,
      "text": "Any information in or about the request or the current environment of the element MAY be used in the construction of the target set. For instance, different sets may be constructed depending on contents or the presence of header fields and bodies, the time of day of the request's arrival, the interface on which the request arrived, failure of previous requests, or even the element's current level of utilization.",
      "ja": "または要求または要素の現在の環境に関するすべての情報は、ターゲットセットの構築に使用されるかもしれません。例えば、異なるセットは、コンテンツ又はヘッダフィールドと体、要求の到着時刻、要求が到着したインターフェイス、以前の要求の失敗、または利用の偶数要素の電流レベルの存在に応じて構築することができます。"
    },
    {
      "indent": 3,
      "text": "As potential targets are located through these services, their URIs are added to the target set. Targets can only be placed in the target set once. If a target URI is already present in the set (based on the definition of equality for the URI type), it MUST NOT be added again.",
      "ja": "潜在的なターゲットは、これらのサービスを介して位置しているとして、そのURIはターゲットセットに追加されます。ターゲットは一度だけ設定した目標に置くことができます。ターゲットURIが既にセットに存在する場合（URIタイプのための平等の定義に基づいて）、再度追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST NOT add additional targets to the target set if the Request-URI of the original request does not indicate a resource this proxy is responsible for.",
      "ja": "オリジナルリクエストのRequest-URIがこのプロキシが担当するリソースを示していない場合、プロキシは、ターゲットセットに追加のターゲットを追加してはなりません。"
    },
    {
      "indent": 6,
      "text": "A proxy can only change the Request-URI of a request during forwarding if it is responsible for that URI. If the proxy is not responsible for that URI, it will not recurse on 3xx or 416 responses as described below.",
      "ja": "プロキシは、それがそのURIに対して責任がある場合は、転送中にリクエストのRequest-URIを変更することができます。プロキシがそのURIを担当していない場合は、以下に説明するように、それは3XXまたは416応答で再帰しません。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI of the original request indicates a resource this proxy is responsible for, the proxy MAY continue to add targets to the set after beginning Request Forwarding. It MAY use any information obtained during that processing to determine new targets. For instance, a proxy may choose to incorporate contacts obtained in a redirect response (3xx) into the target set. If a proxy uses a dynamic source of information while building the target set (for instance, if it consults a SIP Registrar), it SHOULD monitor that source for the duration of processing the request. New locations SHOULD be added to the target set as they become available. As above, any given URI MUST NOT be added to the set more than once.",
      "ja": "オリジナルリクエストのRequest-URIがこのプロキシが担当するリソースを示している場合、プロキシはリクエストの転送を開始した後、セットにターゲットを追加し続けることができます。これは、新しいターゲットを特定するために、その処理中に得られたすべての情報を使用することができます。例えば、プロキシはターゲットセットにリダイレクト応答（3XX）で得られたコンタクトを組み込むことを選択することができます。 （それはSIPレジストラを参照した場合、例えば、）ターゲットセットを構築しながら、プロキシ情報の動的ソースを使用している場合、それは要求を処理の期間中、そのソースを監視する必要があります。新しい場所は、彼らが利用可能になるよう設定された目標に追加する必要があります。上記のように、任意のURIを複数回セットに追加してはいけません。"
    },
    {
      "indent": 6,
      "text": "Allowing a URI to be added to the set only once reduces unnecessary network traffic, and in the case of incorporating contacts from redirect requests prevents infinite recursion.",
      "ja": "URIは、一度だけセットに追加されることを可能にすることは、不必要なネットワークトラフィックが減少し、リダイレクト要求から連絡先を組み込む場合には無限の再帰を防止します。"
    },
    {
      "indent": 3,
      "text": "For example, a trivial location service is a \"no-op\", where the target URI is equal to the incoming request URI. The request is sent to a specific next hop proxy for further processing. During request forwarding of Section 16.6, Item 6, the identity of that next hop, expressed as a SIP or SIPS URI, is inserted as the top-most Route header field value into the request.",
      "ja": "例えば、些細なロケーションサービスは、ターゲットURIは、着信要求URIに等しいが「NO-OP」、ではありません。要求は、さらなる処理のために特定のネクストホッププロキシに送信されます。セクション16.6、項目6の要求の転送時、その次のホップのアイデンティティは、SIPのように表されるまたはURIをSIPS、要求に最上位のルートヘッダフィールド値として挿入されます。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI indicates a resource at this proxy that does not exist, the proxy MUST return a 404 (Not Found) response.",
      "ja": "要求URIが存在しないこのプロキシでリソースを示している場合、プロキシは404（Not Found）応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the target set remains empty after applying all of the above, the proxy MUST return an error response, which SHOULD be the 480 (Temporarily Unavailable) response.",
      "ja": "ターゲットセットは上記のすべてを適用した後、空のままの場合、プロキシは480（一時的に利用できない）応答であるべきでエラー応答を返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "16.6 Request Forwarding",
      "section_title": true,
      "ja": "16.6リクエストの転送"
    },
    {
      "indent": 3,
      "text": "As soon as the target set is non-empty, a proxy MAY begin forwarding the request. A stateful proxy MAY process the set in any order. It MAY process multiple targets serially, allowing each client transaction to complete before starting the next. It MAY start client transactions with every target in parallel. It also MAY arbitrarily divide the set into groups, processing the groups serially and processing the targets in each group in parallel.",
      "ja": "すぐに設定された目標が非空であるとして、プロキシは要求を転送開始することができます。ステートフルプロキシは、任意の順序でセットを処理することができます。これは、各クライアントのトランザクションは、次の開始前に完了することができ、連続的に複数のターゲットを処理することができます。これは、並行して、すべてのターゲットとクライアントのトランザクションを開始することができます。それはまた、任意の連続グループを処理し、並行して、各グループ内のターゲットを処理する、グループに集合を分割してもよいです。"
    },
    {
      "indent": 3,
      "text": "A common ordering mechanism is to use the qvalue parameter of targets obtained from Contact header fields (see Section 20.10). Targets are processed from highest qvalue to lowest. Targets with equal qvalues may be processed in parallel.",
      "ja": "共通の順序付け機構は、Contactヘッダーフィールド（セクション20.10を参照）から得られたターゲットのqvalueパラメータを使用することです。ターゲットは最低に最高のqvalueから処理されます。等しいqvalues持つターゲットを並列に処理することができます。"
    },
    {
      "indent": 3,
      "text": "A stateful proxy must have a mechanism to maintain the target set as responses are received and associate the responses to each forwarded request with the original request. For the purposes of this model, this mechanism is a \"response context\" created by the proxy layer before forwarding the first request.",
      "ja": "ステートフルプロキシは、応答が受信されるように設定された目標を維持し、元の要求と各転送要求に対する応答を関連付けるための機構を有していなければなりません。このモデルの目的のために、この機構は、第1の要求を転送する前に、プロキシ層によって作成された「応答コンテキスト」です。"
    },
    {
      "indent": 3,
      "text": "For each target, the proxy forwards the request following these steps:",
      "ja": "各ターゲットについて、プロキシは、以下の手順に従って、要求を転送します。"
    },
    {
      "indent": 6,
      "text": "1. Make a copy of the received request",
      "section_title": true,
      "ja": "1.受信したリクエストのコピーを作成します"
    },
    {
      "indent": 6,
      "text": "2. Update the Request-URI",
      "section_title": true,
      "ja": "2.アップデートのRequest-URI"
    },
    {
      "indent": 6,
      "text": "3. Update the Max-Forwards header field",
      "section_title": true,
      "ja": "3. Max-Forwardsヘッダーフィールドを更新します"
    },
    {
      "indent": 6,
      "text": "4. Optionally add a Record-route header field value",
      "section_title": true,
      "ja": "4.オプションレコードルートヘッダフィールド値を追加"
    },
    {
      "indent": 6,
      "text": "5. Optionally add additional header fields",
      "section_title": true,
      "ja": "5.必要に応じて追加のヘッダフィールドを追加します"
    },
    {
      "indent": 6,
      "text": "6. Postprocess routing information",
      "section_title": true,
      "ja": "前記後処理ルーティング情報"
    },
    {
      "indent": 6,
      "text": "7. Determine the next-hop address, port, and transport",
      "section_title": true,
      "ja": "7.ネクストホップアドレス、ポート、およびトランスポートを決定します"
    },
    {
      "indent": 6,
      "text": "8. Add a Via header field value",
      "section_title": true,
      "ja": "8. Viaヘッダーフィールド値を追加します。"
    },
    {
      "indent": 6,
      "text": "9. Add a Content-Length header field if necessary",
      "section_title": true,
      "ja": "9.必要に応じてContent-Lengthヘッダフィールドを追加します。"
    },
    {
      "indent": 6,
      "text": "10. Forward the new request",
      "section_title": true,
      "ja": "10.新しい要求を転送"
    },
    {
      "indent": 6,
      "text": "11. Set timer C",
      "section_title": true,
      "ja": "11時間セットC"
    },
    {
      "indent": 3,
      "text": "Each of these steps is detailed below:",
      "ja": "これらの各ステップは、以下に説明されています。"
    },
    {
      "indent": 6,
      "text": "1. Copy request",
      "section_title": true,
      "ja": "1.コピー要求"
    },
    {
      "indent": 9,
      "text": "The proxy starts with a copy of the received request. The copy MUST initially contain all of the header fields from the received request. Fields not detailed in the processing described below MUST NOT be removed. The copy SHOULD maintain the ordering of the header fields as in the received request. The proxy MUST NOT reorder field values with a common field name (See Section 7.3.1). The proxy MUST NOT add to, modify, or remove the message body.",
      "ja": "プロキシは、受信したリクエストのコピーで始まります。コピーは、最初に受信した要求からヘッダフィールドのすべてを含まなければなりません。以下で説明する処理で詳述されていないフィールドを削除してはなりません。コピーは、受信した要求のようなヘッダフィールドの順序を維持する必要があります。プロキシは、（7.3.1項を参照）、共通のフィールド名とフィールド値を並べ替えてはなりません。プロキシは、に追加、変更、またはメッセージ本文を削除してはなりません。"
    },
    {
      "indent": 9,
      "text": "An actual implementation need not perform a copy; the primary requirement is that the processing for each next hop begin with the same request.",
      "ja": "実際の実装では、コピーを実行する必要はありません。主要な要件は、各次のホップの処理が同じ要求で始まるということです。"
    },
    {
      "indent": 6,
      "text": "2. Request-URI",
      "section_title": true,
      "ja": "2.要求URI"
    },
    {
      "indent": 9,
      "text": "The Request-URI in the copy's start line MUST be replaced with the URI for this target. If the URI contains any parameters not allowed in a Request-URI, they MUST be removed.",
      "ja": "リクエスト-URIコピーのスタートラインでは、このターゲットのURIに置き換える必要があります。 URIがRequest-URIで許可されていないすべてのパラメータが含まれている場合は、それらを削除する必要があります。"
    },
    {
      "indent": 9,
      "text": "This is the essence of a proxy's role. This is the mechanism through which a proxy routes a request toward its destination.",
      "ja": "これは、プロキシの役割の本質です。これは、スループロキシルートその宛先に向けて要求メカニズムです。"
    },
    {
      "indent": 9,
      "text": "In some circumstances, the received Request-URI is placed into the target set without being modified. For that target, the replacement above is effectively a no-op.",
      "ja": "いくつかの状況では、受信したリクエストURIは変更されずに設定された目標に置かれます。その目標のために、上記交換が効果的に何もしません。"
    },
    {
      "indent": 6,
      "text": "3. Max-Forwards",
      "section_title": true,
      "ja": "3.マックス・フォワード"
    },
    {
      "indent": 9,
      "text": "If the copy contains a Max-Forwards header field, the proxy MUST decrement its value by one (1).",
      "ja": "コピーがMax-Forwardsヘッダーフィールドを含んでいる場合、プロキシは、一（1）により、その値をデクリメントしなければなりません。"
    },
    {
      "indent": 9,
      "text": "If the copy does not contain a Max-Forwards header field, the proxy MUST add one with a field value, which SHOULD be 70.",
      "ja": "コピーがMax-Forwardsヘッダーフィールドを含んでいない場合は、プロキシが70であるべき、フィールド値で1を加えなければなりません。"
    },
    {
      "indent": 9,
      "text": "Some existing UAs will not provide a Max-Forwards header field in a request.",
      "ja": "いくつかの既存のUAはリクエストにMax-Forwardsヘッダーフィールドを提供することはありません。"
    },
    {
      "indent": 6,
      "text": "4. Record-Route",
      "section_title": true,
      "ja": "4.レコード・ルート"
    },
    {
      "indent": 9,
      "text": "If this proxy wishes to remain on the path of future requests in a dialog created by this request (assuming the request creates a dialog), it MUST insert a Record-Route header field value into the copy before any existing Record-Route header field values, even if a Route header field is already present.",
      "ja": "このプロキシは、この要求によって作成されたダイアログの将来のリクエストのパスに残ることを望む場合、それは既存のRecord-Routeヘッダフィールド値の前にコピーへのRecord-Routeヘッダーフィールド値を挿入しなければならない（要求を仮定すると、ダイアログを作成します） 、Routeヘッダフィールドが既に存在していても。"
    },
    {
      "indent": 9,
      "text": "Requests establishing a dialog may contain a preloaded Route header field.",
      "ja": "ダイアログを確立するリクエストはプリロードされたRouteヘッダーフィールドが含まれていてもよいです。"
    },
    {
      "indent": 9,
      "text": "If this request is already part of a dialog, the proxy SHOULD insert a Record-Route header field value if it wishes to remain on the path of future requests in the dialog. In normal endpoint operation as described in Section 12, these Record-Route header field values will not have any effect on the route sets used by the endpoints.",
      "ja": "この要求は、すでにダイアログの一部である場合、それはダイアログの今後のリクエストのパスに残ることを希望する場合、プロキシはRecord-Routeヘッダーフィールド値を挿入する必要があります。セクション12で説明したように、通常のエンドポイント動作では、これらのRecord-Routeヘッダフィールド値は、エンドポイントによって使用されるルートセットには影響を与えないであろう。"
    },
    {
      "indent": 9,
      "text": "The proxy will remain on the path if it chooses to not insert a Record-Route header field value into requests that are already part of a dialog. However, it would be removed from the path when an endpoint that has failed reconstitutes the dialog.",
      "ja": "それはすでにダイアログの一部であるリクエストにRecord-Routeヘッダーフィールド値を挿入しないことを選択した場合、プロキシは、パス上に残ります。しかし、失敗したエンドポイントがダイアログを再構成するときのパスから削除されます。"
    },
    {
      "indent": 9,
      "text": "A proxy MAY insert a Record-Route header field value into any request. If the request does not initiate a dialog, the endpoints will ignore the value. See Section 12 for details on how endpoints use the Record-Route header field values to construct Route header fields.",
      "ja": "プロキシは、任意のリクエストにRecord-Routeヘッダフィールド値を挿入することができます。リクエストがダイアログを開始しない場合は、エンドポイントは値を無視します。エンドポイントがRouteヘッダーフィールドを構築するためにRecord-Routeヘッダーフィールド値を使用する方法の詳細については、セクション12を参照してください。"
    },
    {
      "indent": 9,
      "text": "Each proxy in the path of a request chooses whether to add a Record-Route header field value independently - the presence of a Record-Route header field in a request does not obligate this proxy to add a value.",
      "ja": "リクエストのパス内の各プロキシは独立にRecord-Routeヘッダフィールド値を追加するかどうかを選択する - 要求内のRecord-Routeヘッダフィールドの存在は、値を追加するには、このプロキシを義務付けません。"
    },
    {
      "indent": 9,
      "text": "The URI placed in the Record-Route header field value MUST be a SIP or SIPS URI. This URI MUST contain an lr parameter (see Section 19.1.1). This URI MAY be different for each destination the request is forwarded to. The URI SHOULD NOT contain the transport parameter unless the proxy has knowledge (such as in a private network) that the next downstream element that will be in the path of subsequent requests supports that transport.",
      "ja": "URIは、SIPでなければなりませんRecord-Routeヘッダフィールド値に置かれ又はURIをSIPS。このURIは、LRパラメータ（項19.1.1を参照）を含まなければなりません。このURIは、要求が転送される宛先ごとに異なる場合があります。プロキシが後続の要求のパスになります次の下流の要素は、そのトランスポートをサポートしていること（たとえば、プライベートネットワークのような）知識を持っていない限り、URIは、トランスポート・パラメータを含めることはできません。"
    },
    {
      "indent": 9,
      "text": "The URI this proxy provides will be used by some other element to make a routing decision. This proxy, in general, has no way of knowing the capabilities of that element, so it must restrict itself to the mandatory elements of a SIP implementation: SIP URIs and either the TCP or UDP transports.",
      "ja": "このプロキシが提供するURIは、ルーティング決定を行うために他のいくつかの要素によって使用されます。このプロキシは、一般的には、その要素の能力を知る方法がないので、SIP実装の必須要素に自分自身を制限する必要があります：SIP URIとTCPまたはUDPトランスポートのいずれか。"
    },
    {
      "indent": 9,
      "text": "The URI placed in the Record-Route header field MUST resolve to the element inserting it (or a suitable stand-in) when the server location procedures of [4] are applied to it, so that subsequent requests reach the same SIP element. If the Request-URI contains a SIPS URI, or the topmost Route header field value (after the post processing of bullet 6) contains a SIPS URI, the URI placed into the Record-Route header field MUST be a SIPS URI. Furthermore, if the request was not received over TLS, the proxy MUST insert a Record-Route header field. In a similar fashion, a proxy that receives a request over TLS, but generates a request without a SIPS URI in the Request-URI or topmost Route header field value (after the post processing of bullet 6), MUST insert a Record-Route header field that is not a SIPS URI.",
      "ja": "URIは、後続の要求が同じSIP要素に到達するように、[4]のサーバーの場所手順は、それに適用されたときにそれを挿入する要素（または適切なスタンドに）に解決される必要がありRecord-Routeヘッダフィールドに置か。リクエストURIがSIPS URI、又は（弾丸6の後処理の後に）最上位のルートヘッダフィールド値を含むSIPS URIを含む場合、URIはSIPS URIでなければなりませんRecord-Routeヘッダフィールドに入れました。リクエストがTLSを介して受信されなかった場合、また、プロキシはRecord-Routeヘッダフィールドを挿入する必要があります。同様に、TLSを介して要求を受信するが、リクエストURIまたは（弾丸6の後処理の後に）最上位のルートヘッダフィールド値にSIPS URIなしで要求を生成するプロキシは、レコードルートヘッダを挿入しなければなりませんSIPS URIではありませんフィールド。"
    },
    {
      "indent": 9,
      "text": "A proxy at a security perimeter must remain on the perimeter throughout the dialog.",
      "ja": "セキュリティ境界でのプロキシは、ダイアログ全体の周囲に残っている必要があります。"
    },
    {
      "indent": 9,
      "text": "If the URI placed in the Record-Route header field needs to be rewritten when it passes back through in a response, the URI MUST be distinct enough to locate at that time. (The request may spiral through this proxy, resulting in more than one Record-Route header field value being added). Item 8 of Section 16.7 recommends a mechanism to make the URI sufficiently distinct.",
      "ja": "Record-Routeヘッダフィールドに配置されたURIは、それが応答を通って戻るときに書き換える必要がある場合、URIはその時点で見つけるのに十分明確でなければなりません。 （要求が追加される複数のRecord-Routeヘッダフィールド値が得られ、このプロキシを介してスパイラルもよいです）。セクション16.7の項目8は、URIが十分に異なるようにするメカニズムを推奨しています。"
    },
    {
      "indent": 9,
      "text": "The proxy MAY include parameters in the Record-Route header field value. These will be echoed in some responses to the request such as the 200 (OK) responses to INVITE. Such parameters may be useful for keeping state in the message rather than the proxy.",
      "ja": "プロキシはRecord-Routeヘッダフィールド値のパラメータを含むことができます。これらは、INVITEに対する200（OK）応答などの要求に、いくつかの応答でエコーされます。このようなパラメータは、プロキシではなく、メッセージの状態を維持するために有用であり得ます。"
    },
    {
      "indent": 9,
      "text": "If a proxy needs to be in the path of any type of dialog (such as one straddling a firewall), it SHOULD add a Record-Route header field value to every request with a method it does not understand since that method may have dialog semantics.",
      "ja": "プロキシは（そのようなファイアウォールをまたぐものとして）ダイアログの任意の種類のパスにする必要がある場合、その方法は、ダイアログ意味を持つ可能性があるので、それが理解しない方法ですべての要求にRecord-Routeヘッダフィールド値を追加すべきです。"
    },
    {
      "indent": 9,
      "text": "The URI a proxy places into a Record-Route header field is only valid for the lifetime of any dialog created by the transaction in which it occurs. A dialog-stateful proxy, for example, MAY refuse to accept future requests with that value in the Request-URI after the dialog has terminated. Non-dialog-stateful proxies, of course, have no concept of when the dialog has terminated, but they MAY encode enough information in the value to compare it against the dialog identifier of future requests and MAY reject requests not matching that information. Endpoints MUST NOT use a URI obtained from a Record-Route header field outside the dialog in which it was provided. See",
      "ja": "Record-Routeヘッダフィールドにプロキシの場所URIは、それが発生したトランザクションによって作成されたダイアログの寿命に対してのみ有効です。ダイアログステートフルプロキシは、例えば、ダイアログが終了した後のRequest-URIにその値を持つ今後のリクエストを受け入れることを拒否することができます。非ダイアログステートフルプロキシは、当然のことながら、ダイアログが終了したときの概念はありませんが、彼らは将来のリクエストのダイアログ識別子に対してそれを比較する値に十分な情報を符号化することができるし、その情報と一致しない要求を拒否するかもしれません。エンドポイントは、それが提供されたダイアログ外Record-Routeヘッダフィールドから得られたURIを使用してはいけません。見る"
    },
    {
      "indent": 9,
      "text": "Section 12 for more information on an endpoint's use of Record-Route header fields.",
      "ja": "Record-Routeヘッダフィールドのエンドポイントの使用に関する詳細については、セクション12。"
    },
    {
      "indent": 9,
      "text": "Record-routing may be required by certain services where the proxy needs to observe all messages in a dialog. However, it slows down processing and impairs scalability and thus proxies should only record-route if required for a particular service.",
      "ja": "レコード・ルーティングは、プロキシは、ダイアログ内のすべてのメッセージを観察する必要がある特定のサービスで必要となる場合があります。しかし、それは処理を遅くし、拡張性を損なうので、プロキシは唯一のレコードルートをすべき特定のサービスのために必要な場合。"
    },
    {
      "indent": 9,
      "text": "The Record-Route process is designed to work for any SIP request that initiates a dialog. INVITE is the only such request in this specification, but extensions to the protocol MAY define others.",
      "ja": "レコード・ルートプロセスは、ダイアログを開始任意のSIPリクエストのために動作するように設計されています。 INVITEは、この仕様では唯一のそのような要求ですが、プロトコルの拡張は、他の人を定義することもできます。"
    },
    {
      "indent": 6,
      "text": "5. Add Additional Header Fields",
      "section_title": true,
      "ja": "5.追加のヘッダフィールドを追加します。"
    },
    {
      "indent": 9,
      "text": "The proxy MAY add any other appropriate header fields to the copy at this point.",
      "ja": "プロキシは、この時点でコピーに他の適切なヘッダフィールドを追加するかもしれません。"
    },
    {
      "indent": 6,
      "text": "6. Postprocess routing information",
      "section_title": true,
      "ja": "前記後処理ルーティング情報"
    },
    {
      "indent": 9,
      "text": "A proxy MAY have a local policy that mandates that a request visit a specific set of proxies before being delivered to the destination. A proxy MUST ensure that all such proxies are loose routers. Generally, this can only be known with certainty if the proxies are within the same administrative domain. This set of proxies is represented by a set of URIs (each of which contains the lr parameter). This set MUST be pushed into the Route header field of the copy ahead of any existing values, if present. If the Route header field is absent, it MUST be added, containing that list of URIs.",
      "ja": "プロキシはリクエストが送信先に配信される前にプロキシの特定のセットを訪問することを義務付けるローカルポリシーを持っているかもしれません。プロキシは、そのようなすべてのプロキシが緩んルータであることを保証しなければなりません。プロキシが同じ管理ドメイン内にある場合は一般的に、これが唯一確実に知ることができます。プロキシのこのセットは（LRパラメータが含まれているそれぞれが）URIの組で表されます。存在する場合、このセットは、先に既存の値のコピーのRouteヘッダーフィールドに押し込まなければなりません。 Routeヘッダーフィールドが存在しない場合は、URIのそのリストを含む、追加されなければなりません。"
    },
    {
      "indent": 9,
      "text": "If the proxy has a local policy that mandates that the request visit one specific proxy, an alternative to pushing a Route value into the Route header field is to bypass the forwarding logic of item 10 below, and instead just send the request to the address, port, and transport for that specific proxy. If the request has a Route header field, this alternative MUST NOT be used unless it is known that next hop proxy is a loose router. Otherwise, this approach MAY be used, but the Route insertion mechanism above is preferred for its robustness, flexibility, generality and consistency of operation. Furthermore, if the Request-URI contains a SIPS URI, TLS MUST be used to communicate with that proxy.",
      "ja": "プロキシは、要求訪問一つの特定のプロキシことを義務付けるローカルポリシーを有する場合、Routeヘッダーフィールドにルート値をプッシュする代わりに、以下の項目10の転送ロジックをバイパスし、代わりに、単にアドレスに要求を送信しますその特定のプロキシのポート、および輸送。リクエストがRouteヘッダーフィールドを持っている場合は、次のホッププロキシが緩んルータであることが知られていない限り、この代替を使用してはいけません。そうでない場合は、このアプローチを使用することができるが、上記ルート挿入機構は、その堅牢性、柔軟性、汎用性と操作の一貫性のために好ましいです。リクエストURIがSIPS URIを含む場合、さらに、TLSは、そのプロキシと通信するために使用されなければなりません。"
    },
    {
      "indent": 9,
      "text": "If the copy contains a Route header field, the proxy MUST inspect the URI in its first value. If that URI does not contain an lr parameter, the proxy MUST modify the copy as follows:",
      "ja": "コピーがRouteヘッダーフィールドを含む場合、プロキシは、その最初の値にURIを検査しなければなりません。そのURIがLRパラメータが含まれていない場合は、次のように、プロキシは、コピーを変更する必要があります。"
    },
    {
      "indent": 9,
      "text": "- The proxy MUST place the Request-URI into the Route header field as the last value.",
      "ja": " - プロキシは、最後の値としてRouteヘッダーフィールド内のRequest-URIを配置しなければなりません。"
    },
    {
      "indent": 9,
      "text": "- The proxy MUST then place the first Route header field value into the Request-URI and remove that value from the Route header field.",
      "ja": " - プロキシは、要求-URIに最初のRouteヘッダフィールド値を配置し、Routeヘッダフィールドからその値を削除する必要があります。"
    },
    {
      "indent": 9,
      "text": "Appending the Request-URI to the Route header field is part of a mechanism used to pass the information in that Request-URI through strict-routing elements. \"Popping\" the first Route header field value into the Request-URI formats the message the way a strict-routing element expects to receive it (with its own URI in the Request-URI and the next location to visit in the first Route header field value).",
      "ja": "RouteヘッダーフィールドにリクエストURIを追加することは、厳密なルーティング要素を介してその要求-URIの情報を渡すために使用される機構の一部です。リクエストURIに最初のRouteヘッダフィールド値を「ポップする」メッセージを厳密ルーティング要素がRequest-URIおよび第Routeヘッダフィールドに訪問する次の位置にそれ自身のURIと（それを受信することを期待する方法をフォーマット値）。"
    },
    {
      "indent": 6,
      "text": "7. Determine Next-Hop Address, Port, and Transport",
      "section_title": true,
      "ja": "7.ネクストホップアドレス、ポート、および輸送を決定"
    },
    {
      "indent": 9,
      "text": "The proxy MAY have a local policy to send the request to a specific IP address, port, and transport, independent of the values of the Route and Request-URI. Such a policy MUST NOT be used if the proxy is not certain that the IP address, port, and transport correspond to a server that is a loose router. However, this mechanism for sending the request through a specific next hop is NOT RECOMMENDED; instead a Route header field should be used for that purpose as described above.",
      "ja": "プロキシはルートとRequest-URIの値とは無関係に特定のIPアドレス、ポート、およびトランスポートにリクエストを送信するためのローカルポリシーを持っているかもしれません。プロキシがIPアドレス、ポート、およびトランスポートが緩んルータであるサーバーに対応する一定でない場合には、このようなポリシーを使用してはいけません。しかし、特定のネクストホップを通じて要求を送信するため、このメカニズムは推奨されていません。上記のように代わりにRouteヘッダフィールドは、その目的のために使用されるべきです。"
    },
    {
      "indent": 9,
      "text": "In the absence of such an overriding mechanism, the proxy applies the procedures listed in [4] as follows to determine where to send the request. If the proxy has reformatted the request to send to a strict-routing element as described in step 6 above, the proxy MUST apply those procedures to the Request-URI of the request. Otherwise, the proxy MUST apply the procedures to the first value in the Route header field, if present, else the Request-URI. The procedures will produce an ordered set of (address, port, transport) tuples. Independently of which URI is being used as input to the procedures of [4], if the Request-URI specifies a SIPS resource, the proxy MUST follow the procedures of [4] as if the input URI were a SIPS URI.",
      "ja": "ここで、要求の送信先を決定するために、以下のようなオーバーライド機構の非存在下では、プロキシは、[4]に記載されている手順を適用します。上記ステップ6で説明したようにプロキシが厳密ルーティング要素に送信するためのリクエストを再フォーマットしている場合、プロキシは、Request-URI要求にそれらの手順を適用しなければなりません。存在する場合それ以外の場合、プロキシは、Request-URI他、Routeヘッダフィールドの第1の値に手順を適用しなければなりません。手順は、（アドレス、ポート、トランスポート）タプルの順序付けられた集合を生成します。独立して、そのURIは、Request-URIがSIPSリソースを指定する場合、入力URIがSIPS URIであるかのように、プロキシは[4]の手順に従わなければならない、[4]の手順への入力として使用されています。"
    },
    {
      "indent": 9,
      "text": "As described in [4], the proxy MUST attempt to deliver the message to the first tuple in that set, and proceed through the set in order until the delivery attempt succeeds.",
      "ja": "記載のように、[4]、プロキシは、そのセット内の最初のタプルにメッセージを配信しようとしなければならない、及び配達の試みが成功するまで順番にセットを通して進みます。"
    },
    {
      "indent": 9,
      "text": "For each tuple attempted, the proxy MUST format the message as appropriate for the tuple and send the request using a new client transaction as detailed in steps 8 through 10.",
      "ja": "試み各タプルのために、プロキシは、タプルに応じてメッセージをフォーマットし、10を介して、ステップ8で詳述するように、新しいクライアントのトランザクションを使用して要求を送信しなければなりません。"
    },
    {
      "indent": 9,
      "text": "Since each attempt uses a new client transaction, it represents a new branch. Thus, the branch parameter provided with the Via header field inserted in step 8 MUST be different for each attempt.",
      "ja": "各試行は、新しいクライアントトランザクションを使用しているので、それは新しいブランチを表します。したがって、ステップ8に挿入されたViaヘッダーフィールドを備えた分岐パラメータは、各試行のために異なっていなければなりません。"
    },
    {
      "indent": 9,
      "text": "If the client transaction reports failure to send the request or a timeout from its state machine, the proxy continues to the next address in that ordered set. If the ordered set is exhausted, the request cannot be forwarded to this element in the target set. The proxy does not need to place anything in the response context, but otherwise acts as if this element of the target set returned a 408 (Request Timeout) final response.",
      "ja": "クライアントトランザクションは、要求またはそのステートマシンからのタイムアウトを送信するために失敗したことを報告した場合、プロキシはその順序集合で次のアドレスに続きます。順序集合が枯渇した場合、要求はターゲットセットでこの要素に転送することはできません。プロキシは応答コンテキストに何かを配置する必要があるが、それ以外のターゲットセットのこの要素は408（要求タイムアウト）最終応答を返したかのように機能していません。"
    },
    {
      "indent": 6,
      "text": "8. Add a Via header field value",
      "section_title": true,
      "ja": "8. Viaヘッダーフィールド値を追加します。"
    },
    {
      "indent": 9,
      "text": "The proxy MUST insert a Via header field value into the copy before the existing Via header field values. The construction of this value follows the same guidelines of Section 8.1.1.7. This implies that the proxy will compute its own branch parameter, which will be globally unique for that branch, and contain the requisite magic cookie. Note that this implies that the branch parameter will be different for different instances of a spiraled or looped request through a proxy.",
      "ja": "プロキシはヘッダーフィールド値を経由して、既存の前に、コピーにViaヘッダーフィールド値を挿入しなければなりません。この値の構築はセクション8.1.1.7と同じガイドラインに従います。これは、プロキシがそのブランチのグローバル一意になり、独自の分岐パラメータを、計算し、必要なマジッククッキーを含んでなることを意味します。これは分岐パラメータは、プロキシ経由で螺旋状またはループ要求の異なるインスタンスに異なるものになることを意味することに注意してください。"
    },
    {
      "indent": 9,
      "text": "Proxies choosing to detect loops have an additional constraint in the value they use for construction of the branch parameter. A proxy choosing to detect loops SHOULD create a branch parameter separable into two parts by the implementation. The first part MUST satisfy the constraints of Section 8.1.1.7 as described above. The second is used to perform loop detection and distinguish loops from spirals.",
      "ja": "ループを検出することを選択するプロキシは、彼らが分岐パラメータの構築に使用する値で追加の制約があります。ループを検出することを選択するプロキシは、実装によって2つの部分に分離可能な分岐パラメータを作成する必要があります。上述したように、第1の部分は、セクション8.1.1.7の制約を満たさなければなりません。第二は、螺旋からループをループ検出を実行し、区別するために使用されます。"
    },
    {
      "indent": 9,
      "text": "Loop detection is performed by verifying that, when a request returns to a proxy, those fields having an impact on the processing of the request have not changed. The value placed in this part of the branch parameter SHOULD reflect all of those fields (including any Route, Proxy-Require and Proxy-Authorization header fields). This is to ensure that if the request is routed back to the proxy and one of those fields changes, it is treated as a spiral and not a loop (see Section 16.3). A common way to create this value is to compute a cryptographic hash of the To tag, From tag, Call-ID header field, the Request-URI of the request received (before translation), the topmost Via header, and the sequence number from the CSeq header field, in addition to any Proxy-Require and Proxy-Authorization header fields that may be present. The algorithm used to compute the hash is implementation-dependent, but MD5 (RFC 1321 [35]), expressed in hexadecimal, is a reasonable choice. (Base64 is not permissible for a token.)",
      "ja": "ループ検出は、要求がプロキシに戻ったとき、要求の処理に影響を有するこれらのフィールドが変更されていない、ことを確認することによって行われます。分岐パラメータのこの部分に配置された値は、（任意のルート、プロキシ必要とプロキシ認証ヘッダフィールドを含む）、それらのフィールドのすべてを反映すべきです。これは、要求がプロキシに戻されると、それらの分野の変化の一つは、それがスパイラルではなくループとして扱われている場合（項16.3を参照）ことを確認することです。この値を作成する一般的な方法は、コールIDヘッダフィールドを、タグからタグへの暗号ハッシュを計算することで、要求のリクエストURIは、（変換前）を受信し、最上位のViaヘッダ、およびからシーケンス番号CSeqヘッダーフィールドに加えて、任意のプロキシ必要とし存在し得るプロキシ認証ヘッダフィールド。ハッシュを計算するために使用されるアルゴリズムは実装依存であるが、MD5（RFC 1321 [35]）は、進数で表現さ、合理的な選択です。 （Base64では、トークンのために許されません。）"
    },
    {
      "indent": 9,
      "text": "If a proxy wishes to detect loops, the \"branch\" parameter it supplies MUST depend on all information affecting processing of a request, including the incoming Request-URI and any header fields affecting the request's admission or routing. This is necessary to distinguish looped requests from requests whose routing parameters have changed before returning to this server.",
      "ja": "プロキシがループを検出したい場合、それが供給する「分岐」パラメータは、着信要求-URIとリクエストの入場またはルーティングに影響を与える任意のヘッダフィールドを含むリクエストの処理に影響を与えるすべての情報に依存しなければなりません。これは、ルーティングパラメータこのサーバーに戻る前に変更したリクエストからループしたリクエストを区別する必要があります。"
    },
    {
      "indent": 9,
      "text": "The request method MUST NOT be included in the calculation of the branch parameter. In particular, CANCEL and ACK requests (for non-2xx responses) MUST have the same branch value as the corresponding request they cancel or acknowledge. The branch parameter is used in correlating those requests at the server handling them (see Sections 17.2.3 and 9.2).",
      "ja": "リクエストメソッドは、分岐パラメータの計算に含めてはなりません。具体的には、CANCELと（2xx以外の応答のための）ACK要求は、彼らがキャンセル対応する要求と同じブランチ値を持っているか確認する必要があります。分岐パラメータが（セクション17.2.3および9.2を参照）、それらを処理するサーバーにそれらの要求を相関に使用されています。"
    },
    {
      "indent": 6,
      "text": "9. Add a Content-Length header field if necessary",
      "section_title": true,
      "ja": "9.必要に応じてContent-Lengthヘッダフィールドを追加します。"
    },
    {
      "indent": 9,
      "text": "If the request will be sent to the next hop using a stream-based transport and the copy contains no Content-Length header field, the proxy MUST insert one with the correct value for the body of the request (see Section 20.14).",
      "ja": "要求は、ストリームベースのトランスポートを使用して、次のホップに送信され、コピーが何Content-Lengthヘッダフィールドが含まれていない場合、プロキシは（セクション20.14を参照）リクエストのボディの正しい値を持つものを挿入する必要があります。"
    },
    {
      "indent": 6,
      "text": "10. Forward Request",
      "section_title": true,
      "ja": "10.フォワード要求"
    },
    {
      "indent": 9,
      "text": "A stateful proxy MUST create a new client transaction for this request as described in Section 17.1 and instructs the transaction to send the request using the address, port and transport determined in step 7.",
      "ja": "17.1項で説明し、ステップ7で決定されたアドレス、ポート、およびトランスポートを使用して要求を送信するために、トランザクションを指示してステートフルプロキシは、この要求のために新しいクライアントトランザクションを作成する必要があります。"
    },
    {
      "indent": 6,
      "text": "11. Set timer C",
      "section_title": true,
      "ja": "11時間セットC"
    },
    {
      "indent": 9,
      "text": "In order to handle the case where an INVITE request never generates a final response, the TU uses a timer which is called timer C. Timer C MUST be set for each client transaction when an INVITE request is proxied. The timer MUST be larger than 3 minutes. Section 16.7 bullet 2 discusses how this timer is updated with provisional responses, and Section 16.8 discusses processing when it fires.",
      "ja": "最終的な応答を生成することはないINVITEリクエストをケースに対処するために、TUはタイマーINVITE要求をプロキシしたときC.タイマCが各クライアントトランザクションのために設定しなければなりませんと呼ばれるタイマーを使用します。タイマーは3分よりも大きくなければなりません。セクション16.7弾丸2は、それが発火するとき、このタイマは暫定応答で更新され、セクション16.8を議論処理される方法について説明します。"
    },
    {
      "indent": 0,
      "text": "16.7 Response Processing",
      "section_title": true,
      "ja": "16.7レスポンス処理"
    },
    {
      "indent": 3,
      "text": "When a response is received by an element, it first tries to locate a client transaction (Section 17.1.3) matching the response. If none is found, the element MUST process the response (even if it is an informational response) as a stateless proxy (described below). If a match is found, the response is handed to the client transaction.",
      "ja": "応答が要素によって受信されると、それは最初の応答に一致するクライアント・トランザクション（セクション17.1.3）を検索しよう。何も見つからない場合、要素は、（後述）ステートレスプロキシとして（それが通知応答であっても）応答を処理しなければなりません。一致が見つかった場合、応答はクライアントトランザクションに渡されます。"
    },
    {
      "indent": 6,
      "text": "Forwarding responses for which a client transaction (or more generally any knowledge of having sent an associated request) is not found improves robustness. In particular, it ensures that \"late\" 2xx responses to INVITE requests are forwarded properly.",
      "ja": "クライアント・トランザクション（またはより一般的に関連したリクエストを送信したのいずれかの知識）が見つかりませんされた応答を転送するロバスト性を向上させることができます。特に、それはINVITEリクエストする「遅い」2xx応答が適切に転送されることが保証されます。"
    },
    {
      "indent": 3,
      "text": "As client transactions pass responses to the proxy layer, the following processing MUST take place:",
      "ja": "顧客取引がプロキシ層に対する応答を渡すと、以下の処理が行われなければなりません。"
    },
    {
      "indent": 6,
      "text": "1. Find the appropriate response context",
      "section_title": true,
      "ja": "1.適切な応答コンテキストを探します"
    },
    {
      "indent": 6,
      "text": "2. Update timer C for provisional responses",
      "section_title": true,
      "ja": "暫定応答2.更新タイマC"
    },
    {
      "indent": 6,
      "text": "3. Remove the topmost Via",
      "section_title": true,
      "ja": "3.一番上の経由を削除します"
    },
    {
      "indent": 6,
      "text": "4. Add the response to the response context",
      "section_title": true,
      "ja": "4.応答コンテキストへの応答を追加します。"
    },
    {
      "indent": 6,
      "text": "5. Check to see if this response should be forwarded immediately",
      "section_title": true,
      "ja": "この応答は、すぐに転送すべきかどうかを確認するために5.チェック"
    },
    {
      "indent": 6,
      "text": "6. When necessary, choose the best final response from the response context",
      "ja": "6.必要な場合、応答コンテキストからの最高の最終的な応答を選択してください"
    },
    {
      "indent": 3,
      "text": "If no final response has been forwarded after every client transaction associated with the response context has been terminated, the proxy must choose and forward the \"best\" response from those it has seen so far.",
      "ja": "応答コンテキストに関連付けられているすべてのクライアントトランザクションが終了した後に何の最終応答が転送されていない場合、プロキシは、それがこれまで見てきたものとは、「最良の」応答を選択して転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following processing MUST be performed on each response that is forwarded. It is likely that more than one response to each request will be forwarded: at least each provisional and one final response.",
      "ja": "以下の処理は、転送される各応答に対して行われなければなりません。少なくとも各暫定と1つの最終的な応答：各要求に対して複数の応答が転送される可能性があります。"
    },
    {
      "indent": 6,
      "text": "7. Aggregate authorization header field values if necessary",
      "section_title": true,
      "ja": "7.集計Authorizationヘッダフィールド値を必要に応じて"
    },
    {
      "indent": 6,
      "text": "8. Optionally rewrite Record-Route header field values",
      "section_title": true,
      "ja": "8.オプションRecord-Routeヘッダフィールド値を書き換えます"
    },
    {
      "indent": 6,
      "text": "9. Forward the response",
      "section_title": true,
      "ja": "9.応答を転送"
    },
    {
      "indent": 6,
      "text": "10. Generate any necessary CANCEL requests",
      "section_title": true,
      "ja": "10.必要なすべてのCANCELリクエストを生成します"
    },
    {
      "indent": 3,
      "text": "Each of the above steps are detailed below:",
      "ja": "上記の各ステップは、以下に詳述します。"
    },
    {
      "indent": 6,
      "text": "1. Find Context",
      "section_title": true,
      "ja": "1.検索コンテキスト"
    },
    {
      "indent": 9,
      "text": "The proxy locates the \"response context\" it created before forwarding the original request using the key described in Section 16.6. The remaining processing steps take place in this context.",
      "ja": "プロキシは、セクション16.6で説明キーを使用して、元の要求を転送する前に作成した「応答コンテキスト」を配置します。残りの処理ステップは、このコンテキストで行われます。"
    },
    {
      "indent": 6,
      "text": "2. Update timer C for provisional responses",
      "section_title": true,
      "ja": "暫定応答2.更新タイマC"
    },
    {
      "indent": 9,
      "text": "For an INVITE transaction, if the response is a provisional response with status codes 101 to 199 inclusive (i.e., anything but 100), the proxy MUST reset timer C for that client transaction. The timer MAY be reset to a different value, but this value MUST be greater than 3 minutes.",
      "ja": "INVITEトランザクションのために、場合に応じては、ステータスコードと暫定応答である101〜199包括（すなわち、100以外のもの）、プロキシはそのクライアントトランザクションのタイマーCをリセットする必要があります。タイマーは異なる値にリセットされてもよいが、この値は3分よりも大きくなければなりません。"
    },
    {
      "indent": 6,
      "text": "3. Via",
      "section_title": true,
      "ja": "3を介して"
    },
    {
      "indent": 9,
      "text": "The proxy removes the topmost Via header field value from the response.",
      "ja": "プロキシは、応答から最上位のViaヘッダフィールド値を除去します。"
    },
    {
      "indent": 9,
      "text": "If no Via header field values remain in the response, the response was meant for this element and MUST NOT be forwarded. The remainder of the processing described in this section is not performed on this message, the UAC processing rules described in Section 8.1.3 are followed instead (transport layer processing has already occurred).",
      "ja": "何のViaヘッダーフィールド値が対応して残っていない場合、応答は、この要素のためのものだったと転送されてはなりません。このセクションで説明した処理の残りは、このメッセージに対して実行されていない、セクション8.1.3に記載UAC処理ルールは、（トランスポート層処理が既に発生している）の代わりに続いています。"
    },
    {
      "indent": 9,
      "text": "This will happen, for instance, when the element generates CANCEL requests as described in Section 10.",
      "ja": "これは、セクション10で説明したように要素が要求をキャンセル生成する場合、例えば、起こります。"
    },
    {
      "indent": 6,
      "text": "4. Add response to context",
      "section_title": true,
      "ja": "4.コンテキストへの応答を追加します。"
    },
    {
      "indent": 9,
      "text": "Final responses received are stored in the response context until a final response is generated on the server transaction associated with this context. The response may be a candidate for the best final response to be returned on that server transaction. Information from this response may be needed in forming the best response, even if this response is not chosen.",
      "ja": "最終応答がこのコンテキストに関連付けられたサーバートランザクション上で生成されるまで、受信された最終的な応答は、応答コンテキストに格納されています。レスポンスは最高の最終的な応答のための候補者は、そのサーバーのトランザクションに返されるかもしれません。この応答からの情報は、この応答が選択されていない場合でも、最適な応答を形成するのに必要とすることができます。"
    },
    {
      "indent": 9,
      "text": "If the proxy chooses to recurse on any contacts in a 3xx response by adding them to the target set, it MUST remove them from the response before adding the response to the response context. However, a proxy SHOULD NOT recurse to a non-SIPS URI if the Request-URI of the original request was a SIPS URI. If the proxy recurses on all of the contacts in a 3xx response, the proxy SHOULD NOT add the resulting contactless response to the response context.",
      "ja": "プロキシがターゲットセットに追加することによって、3xx応答内の任意の連絡先に再帰することを選択した場合、それは応答コンテキストへの応答を追加する前に、応答からそれらを削除する必要があります。オリジナルリクエストのRequest-URIがSIPS URIだった場合は、プロキシは非SIPS URIに再帰すべきではありません。プロキシが3xx応答内の連絡先のすべてで再帰的な処理をした場合、プロキシは応答コンテキストに結果の非接触応答を追加しないでください。"
    },
    {
      "indent": 9,
      "text": "Removing the contact before adding the response to the response context prevents the next element upstream from retrying a location this proxy has already attempted.",
      "ja": "応答コンテキストへの応答を追加する前に、連絡先を削除すると再試行の上流にこのプロキシが既に試みた位置を次の要素を防ぎます。"
    },
    {
      "indent": 9,
      "text": "3xx responses may contain a mixture of SIP, SIPS, and non-SIP URIs. A proxy may choose to recurse on the SIP and SIPS URIs and place the remainder into the response context to be returned, potentially in the final response.",
      "ja": "3xx応答はSIP、SIPS、および非SIP URIの混合物を含んでいてもよいです。プロキシは、SIPとSIPS URIの上に再帰し、潜在的に、最終的な応答で、返される応答コンテキストに残りを配置することを選択することができます。"
    },
    {
      "indent": 9,
      "text": "If a proxy receives a 416 (Unsupported URI Scheme) response to a request whose Request-URI scheme was not SIP, but the scheme in the original received request was SIP or SIPS (that is, the proxy changed the scheme from SIP or SIPS to something else when it proxied a request), the proxy SHOULD add a new URI to the target set. This URI SHOULD be a SIP URI version of the non-SIP URI that was just tried. In the case of the tel URL, this is accomplished by placing the telephone-subscriber part of the tel URL into the user part of the SIP URI, and setting the hostpart to the domain where the prior request was sent. See Section 19.1.6 for more detail on forming SIP URIs from tel URLs.",
      "ja": "プロキシは、Request-URIスキームはSIPではなかったが、元の受信した要求にスキームはSIPまたはSIPS（つまり、プロキシは、SIPからスキームを変更したりするSIPSた要求に対して416（サポートされていないURIスキーム）応答を受信した場合何か他のもの、それはリクエストをプロキシ）、プロキシはターゲットセットに新しいURIを追加する必要があります。このURIは、ちょうど試みた非SIP URIのSIP URIのバージョンである必要があります。 TELのURLの場合、これは、SIP URIのユーザ部分へのTEL URLの電話加入者の一部を配置し、前の要求が送信されたドメインにhostpartを設定することによって達成されます。 TELのURLからSIP URIを形成する上での詳細については、セクション19.1.6を参照してください。"
    },
    {
      "indent": 9,
      "text": "As with a 3xx response, if a proxy \"recurses\" on the 416 by trying a SIP or SIPS URI instead, the 416 response SHOULD NOT be added to the response context.",
      "ja": "SIPを試みることにより、416の代理「再帰的」場合またはその代わりにURIをSIPS 3xx応答と同じように、416応答は、応答コンテキストに追加しないでください。"
    },
    {
      "indent": 6,
      "text": "5. Check response for forwarding",
      "section_title": true,
      "ja": "転送5.確認応答"
    },
    {
      "indent": 9,
      "text": "Until a final response has been sent on the server transaction, the following responses MUST be forwarded immediately:",
      "ja": "最終応答がサーバートランザクションに送信されるまで、次の応答が即座に転送する必要があります："
    },
    {
      "indent": 9,
      "text": "- Any provisional response other than 100 (Trying)",
      "ja": " -  100以外の暫定応答（試行）"
    },
    {
      "indent": 9,
      "text": "- Any 2xx response",
      "ja": " - 任意の2xx応答"
    },
    {
      "indent": 9,
      "text": "If a 6xx response is received, it is not immediately forwarded, but the stateful proxy SHOULD cancel all client pending transactions as described in Section 10, and it MUST NOT create any new branches in this context.",
      "ja": "6xxの応答が受信された場合、それはすぐに転送されていませんが、10節で説明したように、ステートフルプロキシは、すべてのクライアント保留中のトランザクションを取り消す必要があり、それがこのコンテキストで任意の新しい枝を作成してはいけません。"
    },
    {
      "indent": 9,
      "text": "This is a change from RFC 2543, which mandated that the proxy was to forward the 6xx response immediately. For an INVITE transaction, this approach had the problem that a 2xx response could arrive on another branch, in which case the proxy would have to forward the 2xx. The result was that the UAC could receive a 6xx response followed by a 2xx response, which should never be allowed to happen. Under the new rules, upon receiving a 6xx, a proxy will issue a CANCEL request, which will generally result in 487 responses from all outstanding client transactions, and then at that point the 6xx is forwarded upstream.",
      "ja": "これは、プロキシはただちにた6xx応答を転送したことを義務付けRFC 2543から変更されています。 INVITEトランザクションのために、このアプローチは2xx応答はプロキシが2XXを転送する必要があります。その場合には別のブランチ、に到着という問題がありました。結果は、UACが起こることを許可すべきではない2xx応答、続いた6xx応答を受け取ることができるということでした。新規則では、6xxのを受信すると、プロキシは、一般的に、すべての未解決のクライアントトランザクションからの487個の応答になりますCANCELリクエストを発行し、その時点で6xxのは、上流に転送されます。"
    },
    {
      "indent": 9,
      "text": "After a final response has been sent on the server transaction, the following responses MUST be forwarded immediately:",
      "ja": "最終応答がサーバートランザクションに送信された後、次の応答はすぐに転送する必要があります："
    },
    {
      "indent": 9,
      "text": "- Any 2xx response to an INVITE request",
      "ja": " -  INVITEリクエストに対するすべての2xx応答"
    },
    {
      "indent": 9,
      "text": "A stateful proxy MUST NOT immediately forward any other responses. In particular, a stateful proxy MUST NOT forward any 100 (Trying) response. Those responses that are candidates for forwarding later as the \"best\" response have been gathered as described in step \"Add Response to Context\".",
      "ja": "ステートフルプロキシはすぐに他の応答を転送してはなりません。具体的には、ステートフルプロキシは任意100（試行）応答を転送してはいけません。 「コンテキストへの対応を追加」ステップで説明したように「最高」の応答として、後で転送するための候補であるこれらの応答が集まってきました。"
    },
    {
      "indent": 9,
      "text": "Any response chosen for immediate forwarding MUST be processed as described in steps \"Aggregate Authorization Header Field Values\" through \"Record-Route\".",
      "ja": "「レコードルート」を介してステップ「集計認可ヘッダフィールド値」に記載されているように、即時転送のために選択される任意の応答が処理されなければなりません。"
    },
    {
      "indent": 9,
      "text": "This step, combined with the next, ensures that a stateful proxy will forward exactly one final response to a non-INVITE request, and either exactly one non-2xx response or one or more 2xx responses to an INVITE request.",
      "ja": "次組み合わせるこのステップは、ステートフルプロキシは非INVITEリクエストに対して正確に一つの最終応答を転送することを保証し、INVITEリクエストに対して正確に一つの非2XX応答または1つ以上の2xx応答のいずれか。"
    },
    {
      "indent": 6,
      "text": "6. Choosing the best response",
      "section_title": true,
      "ja": "6.最良の応答を選択します"
    },
    {
      "indent": 9,
      "text": "A stateful proxy MUST send a final response to a response context's server transaction if no final responses have been immediately forwarded by the above rules and all client transactions in this response context have been terminated.",
      "ja": "何の最終応答がすぐに上記のルールによって転送されていないと、この応答コンテキスト内のすべてのクライアントトランザクションが終了している場合は、ステートフルプロキシは応答コンテキストのサーバートランザクションに最終的な応答を送らなければなりません。"
    },
    {
      "indent": 9,
      "text": "The stateful proxy MUST choose the \"best\" final response among those received and stored in the response context.",
      "ja": "ステートフルプロキシは応答コンテキストに受信し、保存されているものの中で「最高の」最終的な応答を選択する必要があります。"
    },
    {
      "indent": 9,
      "text": "If there are no final responses in the context, the proxy MUST send a 408 (Request Timeout) response to the server transaction.",
      "ja": "コンテキストには、最終的な応答がない場合、プロキシはサーバートランザクションに408（リクエストタイムアウト）応答を送らなければなりません。"
    },
    {
      "indent": 9,
      "text": "Otherwise, the proxy MUST forward a response from the responses stored in the response context. It MUST choose from the 6xx class responses if any exist in the context. If no 6xx class responses are present, the proxy SHOULD choose from the lowest response class stored in the response context. The proxy MAY select any response within that chosen class. The proxy SHOULD give preference to responses that provide information affecting resubmission of this request, such as 401, 407, 415, 420, and 484 if the 4xx class is chosen.",
      "ja": "それ以外の場合、プロキシは応答コンテキストに保存された応答からの応答を転送する必要があります。任意のコンテキストに存在する場合には、た6xxクラスの応答から選択する必要があります。何の6xxクラス応答が存在しない場合、プロキシは応答コンテキストに保存されている最低のレスポンスクラスから選択する必要があります。プロキシは、その選択したクラス内の任意の応答を選択することができます。 4XXクラスが選択される場合、プロキシは、401、407、415、420、及び484のような、この要求の再送信に影響を与える情報を提供する応答に優先権を与えるべきです。"
    },
    {
      "indent": 9,
      "text": "A proxy which receives a 503 (Service Unavailable) response SHOULD NOT forward it upstream unless it can determine that any subsequent requests it might proxy will also generate a 503. In other words, forwarding a 503 means that the proxy knows it cannot service any requests, not just the one for the Request-URI in the request which generated the 503. If the only response that was received is a 503, the proxy SHOULD generate a 500 response and forward that upstream.",
      "ja": "503（サービス使用不可）レスポンスを受信プロキシは、それはそれ以降の要求は、それはプロキシがまた503は、プロキシは、それがどんな要求にサービスを提供することはできません知っていることを意味し、転送、つまり503が生成されます可能性があると判断できる場合を除き、上流にそれを転送しない（SHOULD NOT） 、ちょうど受信された唯一の応答が503であれば503を生成した要求でのRequest-URIのための1つ、プロキシは500応答を生成し、その上流に転送する必要がありません。"
    },
    {
      "indent": 9,
      "text": "The forwarded response MUST be processed as described in steps \"Aggregate Authorization Header Field Values\" through \"Record-Route\".",
      "ja": "「レコードルート」を介してステップ「集計認可ヘッダフィールド値」で説明したように、転送応答が処理されなければなりません。"
    },
    {
      "indent": 9,
      "text": "For example, if a proxy forwarded a request to 4 locations, and received 503, 407, 501, and 404 responses, it may choose to forward the 407 (Proxy Authentication Required) response.",
      "ja": "例えば、プロキシは、それは407（プロキシ認証が必要）応答を転送することを選択することができる、4つの場所にリクエストを転送し、そして503、407、501、及び404の応答を受信しました。"
    },
    {
      "indent": 9,
      "text": "1xx and 2xx responses may be involved in the establishment of dialogs. When a request does not contain a To tag, the To tag in the response is used by the UAC to distinguish multiple responses to a dialog creating request. A proxy MUST NOT insert a tag into the To header field of a 1xx or 2xx response if the request did not contain one. A proxy MUST NOT modify the tag in the To header field of a 1xx or 2xx response.",
      "ja": "1XXおよび2XX応答はダイアログの確立に関与することができます。リクエストがタグに含まれていない場合は、対応してタグに要求を作成ダイアログボックスに複数の応答を区別するためにUACによって使用されます。プロキシはリクエストが1を保持していなかった場合の1xxまたは2XX応答のToヘッダーフィールドにタグを挿入してはなりません。プロキシは、1XXまたは2XX応答のヘッダーフィールドにタグを変更してはいけません。"
    },
    {
      "indent": 9,
      "text": "Since a proxy may not insert a tag into the To header field of a 1xx response to a request that did not contain one, it cannot issue non-100 provisional responses on its own. However, it can branch the request to a UAS sharing the same element as the proxy. This UAS can return its own provisional responses, entering into an early dialog with the initiator of the request. The UAS does not have to be a discreet process from the proxy. It could be a virtual UAS implemented in the same code space as the proxy.",
      "ja": "プロキシは1が含まれていない要求への1xx応答のToヘッダーフィールドにタグを挿入しない場合がありますので、それは自分自身で非100暫定応答を発行することはできません。しかし、それはプロキシとして同じエレメントを共有するUASにリクエストを分岐することができます。このUASは、リクエストの開始剤と早期の対話に入る、独自の暫定応答を返すことができます。 UASはプロキシから控えめなプロセスである必要はありません。それはプロキシと同じコード空間に実装された仮想UASである可能性があります。"
    },
    {
      "indent": 9,
      "text": "3-6xx responses are delivered hop-by-hop. When issuing a 3-6xx response, the element is effectively acting as a UAS, issuing its own response, usually based on the responses received from downstream elements. An element SHOULD preserve the To tag when simply forwarding a 3-6xx response to a request that did not contain a To tag.",
      "ja": "3-6xx応答は、ホップバイホップに配信されます。 3-6xx応答を発行するとき、要素が効果的に通常下流要素から受け取った応答に基づいて、自身の応答を発行し、UASとして動作しています。要素は、単にタグに含まれていませんでした要求に3-6xx応答を転送するときにタグ付けするには保存すべき。"
    },
    {
      "indent": 9,
      "text": "A proxy MUST NOT modify the To tag in any forwarded response to a request that contains a To tag.",
      "ja": "プロキシは、タグに含まれている要求への転送応じてタグ付けするには変更してはいけません。"
    },
    {
      "indent": 9,
      "text": "While it makes no difference to the upstream elements if the proxy replaced the To tag in a forwarded 3-6xx response, preserving the original tag may assist with debugging.",
      "ja": "それは上流の要素に違いはないものの、プロキシは、デバッグを支援することが元のタグを保存、転送3-6xx応じてタグ付けするために交換した場合。"
    },
    {
      "indent": 9,
      "text": "When the proxy is aggregating information from several responses, choosing a To tag from among them is arbitrary, and generating a new To tag may make debugging easier. This happens, for instance, when combining 401 (Unauthorized) and 407 (Proxy Authentication Required) challenges, or combining Contact values from unencrypted and unauthenticated 3xx responses.",
      "ja": "プロキシは、その中からタグに選ぶことが任意である、いくつかの応答からの情報を集約して、タグに新しいを生成することは容易にデバッグを行うことがあります。場合には401（無許可）と407（プロキシ認証が必要）の挑戦を組み合わせ、または暗号化されていないと認証されていない3xx応答から連絡先値を組み合わせるとき、これは、例えば、発生します。"
    },
    {
      "indent": 6,
      "text": "7. Aggregate Authorization Header Field Values",
      "section_title": true,
      "ja": "7.集約認証ヘッダーフィールド値"
    },
    {
      "indent": 9,
      "text": "If the selected response is a 401 (Unauthorized) or 407 (Proxy Authentication Required), the proxy MUST collect any WWW-Authenticate and Proxy-Authenticate header field values from all other 401 (Unauthorized) and 407 (Proxy Authentication Required) responses received so far in this response context and add them to this response without modification before forwarding. The resulting 401 (Unauthorized) or 407 (Proxy Authentication Required) response could have several WWW-Authenticate AND Proxy-Authenticate header field values.",
      "ja": "選択された応答401（不正な）または407（プロキシ認証が必要）である場合、プロキシは、他のすべての401（不正な）から、任意のWWW認証およびプロキシ認証ヘッダフィールド値を収集する必要があり、および407（プロキシ認証が必要）応答はそう受信しましたここまで応答コンテキスト内および転送する前に修正することなく、この応答に追加します。得られた（不正な）401または407（プロキシ認証が必要）応答は、いくつかのWWW-認証およびプロキシ認証ヘッダフィールド値を有することができます。"
    },
    {
      "indent": 9,
      "text": "This is necessary because any or all of the destinations the request was forwarded to may have requested credentials. The client needs to receive all of those challenges and supply credentials for each of them when it retries the request. Motivation for this behavior is provided in Section 26.",
      "ja": "要求が転送された目的地のいずれかまたは全てが資格情報を要求している可能性がするので、これが必要です。クライアントは、これらの課題の全てを受信して​​、要求を再試行するときにそれらのそれぞれのための資格情報を提供する必要があります。この動作のための動機は、セクション26に設けられています。"
    },
    {
      "indent": 6,
      "text": "8. Record-Route",
      "section_title": true,
      "ja": "8.レコード・ルート"
    },
    {
      "indent": 9,
      "text": "If the selected response contains a Record-Route header field value originally provided by this proxy, the proxy MAY choose to rewrite the value before forwarding the response. This allows the proxy to provide different URIs for itself to the next upstream and downstream elements. A proxy may choose to use this mechanism for any reason. For instance, it is useful for multi-homed hosts.",
      "ja": "選択された応答は、もともとこのプロキシによって提供Record-Routeヘッダフィールドの値が含まれている場合、プロキシは応答を転送する前に値を書き換えることを選ぶかもしれ。これは、プロキシが次の上流と下流の要素に自分自身のために異なるURIを提供することを可能にします。プロキシが何らかの理由でこのメカニズムを使用することもできます。例えば、それは、マルチホームホストのために有用です。"
    },
    {
      "indent": 9,
      "text": "If the proxy received the request over TLS, and sent it out over a non-TLS connection, the proxy MUST rewrite the URI in the Record-Route header field to be a SIPS URI. If the proxy received the request over a non-TLS connection, and sent it out over TLS, the proxy MUST rewrite the URI in the Record-Route header field to be a SIP URI.",
      "ja": "プロキシがTLSを介して要求を受け取り、非TLS接続を介してそれを送信した場合、プロキシはSIPS URIであることがRecord-RouteヘッダフィールドにURIを書き換えなければなりません。プロキシが非TLS接続を介して要求を受け、TLS上にそれを送信した場合、プロキシは、SIP URIであることがRecord-RouteヘッダフィールドにURIを書き換えなければなりません。"
    },
    {
      "indent": 9,
      "text": "The new URI provided by the proxy MUST satisfy the same constraints on URIs placed in Record-Route header fields in requests (see Step 4 of Section 16.6) with the following modifications:",
      "ja": "プロキシによって提供された新しいURIは以下のように変更して（セクション16.6のステップ4を参照）要求にRecord-Routeヘッダフィールドに配置されたURIに同じ制約を満たさなければなりません。"
    },
    {
      "indent": 9,
      "text": "The URI SHOULD NOT contain the transport parameter unless the proxy has knowledge that the next upstream (as opposed to downstream) element that will be in the path of subsequent requests supports that transport.",
      "ja": "プロキシは後続の要求の経路であろう次の上流（下流とは対照的に）要素は、そのトランスポートをサポートすることの知識を持っていない限りURIは、トランスポートパラメータを含むべきではありません。"
    },
    {
      "indent": 9,
      "text": "When a proxy does decide to modify the Record-Route header field in the response, one of the operations it performs is locating the Record-Route value that it had inserted. If the request spiraled, and the proxy inserted a Record-Route value in each iteration of the spiral, locating the correct value in the response (which must be the proper iteration in the reverse direction) is tricky. The rules above recommend that a proxy wishing to rewrite Record-Route header field values insert sufficiently distinct URIs into the Record-Route header field so that the right one may be selected for rewriting. A RECOMMENDED mechanism to achieve this is for the proxy to append a unique identifier for the proxy instance to the user portion of the URI.",
      "ja": "プロキシが応答にRecord-Routeヘッダフィールドを変更することを決定しない場合、それが実行する操作の一つは、それが挿入されたレコードルート値を配置されています。要求が螺旋状、及びプロキシがスパイラルの各反復においてレコードルート値を挿入した場合、（逆方向の適切な反復でなければならない）応答に正しい値を配置することは難しいです。ルールは、上記右の書き換えのために選択することができるように、Record-Routeヘッダフィールド値を書き換えることを望むプロキシがRecord-Routeヘッダフィールドに十分に異なるURIを挿入することをお勧めします。これを達成することを推奨メカニズムは、URIのユーザ部分にプロキシ・インスタンスの一意の識別子を追加するプロキシのためのものです。"
    },
    {
      "indent": 9,
      "text": "When the response arrives, the proxy modifies the first Record-Route whose identifier matches the proxy instance. The modification results in a URI without this piece of data appended to the user portion of the URI. Upon the next iteration, the same algorithm (find the topmost Record-Route header field value with the parameter) will correctly extract the next Record-Route header field value inserted by that proxy.",
      "ja": "応答が到着すると、プロキシは、その識別子プロキシインスタンスに一致する最初のレコードルートを変更します。 URIのユーザ部分に付加されたデータのこの部分せずURIに変更をもたらします。次の反復時に、同じアルゴリズムは、（パラメータを使用して最上位のRecord-Routeヘッダーフィールド値を見つける。）が正しくそのプロキシによって挿入次Record-Routeヘッダフィールド値を抽出します。"
    },
    {
      "indent": 9,
      "text": "Not every response to a request to which a proxy adds a Record-Route header field value will contain a Record-Route header field. If the response does contain a Record-Route header field, it will contain the value the proxy added.",
      "ja": "プロキシへの要求に対するすべての応答がRecord-Routeヘッダーフィールド値はRecord-Routeヘッダーフィールドが含まれます追加されていません。応答がRecord-Routeヘッダフィールドが含まれている場合、それはプロキシが付加価値を含むであろう。"
    },
    {
      "indent": 6,
      "text": "9. Forward response",
      "section_title": true,
      "ja": "9.フォワード応答"
    },
    {
      "indent": 9,
      "text": "After performing the processing described in steps \"Aggregate Authorization Header Field Values\" through \"Record-Route\", the proxy MAY perform any feature specific manipulations on the selected response. The proxy MUST NOT add to, modify, or remove the message body. Unless otherwise specified, the proxy MUST NOT remove any header field values other than the Via header field value discussed in Section 16.7 Item 3. In particular, the proxy MUST NOT remove any \"received\" parameter it may have added to the next Via header field value while processing the request associated with this response. The proxy MUST pass the response to the server transaction associated with the response context. This will result in the response being sent to the location now indicated in the topmost Via header field value. If the server transaction is no longer available to handle the transmission, the element MUST forward the response statelessly by sending it to the server transport. The server transaction might indicate failure to send the response or signal a timeout in its state machine. These errors would be logged for diagnostic purposes as appropriate, but the protocol requires no remedial action from the proxy.",
      "ja": "「レコードルート」を介してステップ「集計認可ヘッダフィールド値」で説明した処理を行った後、プロキシは、選択された応答の任意の機能の特定の操作を実行することができます。プロキシは、に追加、変更、またはメッセージ本文を削除してはなりません。特に断らない限り、プロキシが特定のセクションで16.7項目3.議論Viaヘッダフィールド値以外の任意のヘッダーフィールド値を削除してはいけません、プロキシは、任意のそれは次のViaヘッダフィールドに追加している可能性があり、パラメータ「受信」を削除してはいけません値は、この応答に関連する要求を処理します。プロキシは応答コンテキストに関連付けられたサーバートランザクションに応答を渡す必要があります。これは、現在最上位のViaヘッダーフィールド値で示された場所に送信される応答をもたらすであろう。サーバートランザクションが送信を処理するために使用できなくなった場合、要素は、サーバーのトランスポートに送信することにより、ステートレスに応答を転送してはなりません。サーバートランザクションは、応答を送信したり、その状態のマシンでタイムアウトを合図に失敗したことを示している可能性があります。これらのエラーは、適切な診断目的のために記録されることになるが、このプロトコルは、プロキシからの是正措置を必要としません。"
    },
    {
      "indent": 9,
      "text": "The proxy MUST maintain the response context until all of its associated transactions have been terminated, even after forwarding a final response.",
      "ja": "それに関連するすべてのトランザクションにも最終的な応答を転送した後、終了されるまで、プロキシは応答コンテキストを維持しなければなりません。"
    },
    {
      "indent": 6,
      "text": "10. Generate CANCELs",
      "section_title": true,
      "ja": "10.キャンセルを生成します"
    },
    {
      "indent": 9,
      "text": "If the forwarded response was a final response, the proxy MUST generate a CANCEL request for all pending client transactions associated with this response context. A proxy SHOULD also generate a CANCEL request for all pending client transactions associated with this response context when it receives a 6xx response. A pending client transaction is one that has received a provisional response, but no final response (it is in the proceeding state) and has not had an associated CANCEL generated for it. Generating CANCEL requests is described in Section 9.1.",
      "ja": "転送された応答が最終応答した場合、プロキシは、この応答コンテキストに関連付けられているすべての保留中のクライアントトランザクションに対してCANCEL要求を発生させなければなりません。プロキシは、それがの6xx応答を受信し、この応答コンテキストに関連付けられているすべての保留中のクライアントトランザクションに対してCANCELリクエストを生成する必要があります。保留中のクライアントトランザクションが暫定応答を受信したもの、ない最終応答（それが進行状態にある）であり、それに対して生成CANCEL関連しませんでした。 CANCELリクエストを生成すると、セクション9.1に記載されています。"
    },
    {
      "indent": 9,
      "text": "The requirement to CANCEL pending client transactions upon forwarding a final response does not guarantee that an endpoint will not receive multiple 200 (OK) responses to an INVITE. 200 (OK) responses on more than one branch may be generated before the CANCEL requests can be sent and processed. Further, it is reasonable to expect that a future extension may override this requirement to issue CANCEL requests.",
      "ja": "最終的な応答を転送するときに、保留中のクライアントトランザクションをキャンセルするための要件は、エンドポイントがINVITEに複数の200（OK）応答を受信しないことを保証するものではありません。 CANCELリクエストが送信され、処理することができます前に、複数のブランチで200（OK）応答を生成することができます。さらに、将来の拡張がCANCELリクエストを発行するために、この要件を無効にすることができることを期待するのは合理的です。"
    },
    {
      "indent": 0,
      "text": "16.8 Processing Timer C",
      "section_title": true,
      "ja": "16.8処理タイマC"
    },
    {
      "indent": 3,
      "text": "If timer C should fire, the proxy MUST either reset the timer with any value it chooses, or terminate the client transaction. If the client transaction has received a provisional response, the proxy MUST generate a CANCEL request matching that transaction. If the client transaction has not received a provisional response, the proxy MUST behave as if the transaction received a 408 (Request Timeout) response.",
      "ja": "タイマCが起動する必要がある場合、プロキシは、それが選択した任意の値でタイマーをリセット、またはクライアントのトランザクションを終了する必要があります。クライアントトランザクションが暫定応答を受信した場合、プロキシはそのトランザクションに一致するCANCELリクエストを生成しなければなりません。クライアントトランザクションが暫定応答を受信して​​いない場合は、トランザクションが408（要求タイムアウト）応答を受け取ったかのように、プロキシは振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "Allowing the proxy to reset the timer allows the proxy to dynamically extend the transaction's lifetime based on current conditions (such as utilization) when the timer fires.",
      "ja": "プロキシは、タイマーをリセットできるようにすると、プロキシが動的に（例えば利用など）は、現在の状態タイマーがトリガーに基づいて、トランザクションの存続期間を延長することができます。"
    },
    {
      "indent": 0,
      "text": "16.9 Handling Transport Errors",
      "section_title": true,
      "ja": "トランスポートエラー処理16.9"
    },
    {
      "indent": 3,
      "text": "If the transport layer notifies a proxy of an error when it tries to forward a request (see Section 18.4), the proxy MUST behave as if the forwarded request received a 503 (Service Unavailable) response.",
      "ja": "それは要求を転送しようとすると、トランスポート層（18.4節を参照）、エラーのプロキシを通知した場合は転送された要求は、503（サービス使用不可）応答を受け取ったかのように、プロキシは振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If the proxy is notified of an error when forwarding a response, it drops the response. The proxy SHOULD NOT cancel any outstanding client transactions associated with this response context due to this notification.",
      "ja": "応答を転送するとき、プロキシは、エラーが通知された場合は、応答を廃棄します。プロキシは、この通知のために、この応答コンテキストに関連付けられているすべての未解決のクライアントトランザクションを取り消すべきではありません。"
    },
    {
      "indent": 6,
      "text": "If a proxy cancels its outstanding client transactions, a single malicious or misbehaving client can cause all transactions to fail through its Via header field.",
      "ja": "プロキシはその卓越した顧客取引をキャンセルした場合、単一の悪意のあるまたは不正な動作クライアントは、すべてのトランザクションがそのViaヘッダーフィールドを介して失敗する可能性があります。"
    },
    {
      "indent": 0,
      "text": "16.10 CANCEL Processing",
      "section_title": true,
      "ja": "16.10処理をキャンセル"
    },
    {
      "indent": 3,
      "text": "A stateful proxy MAY generate a CANCEL to any other request it has generated at any time (subject to receiving a provisional response to that request as described in section 9.1). A proxy MUST cancel any pending client transactions associated with a response context when it receives a matching CANCEL request.",
      "ja": "ステートフルプロキシは、それが任意の時点で生成した任意の他の要求（セクション9.1で説明したように、その要求に対する暫定応答を受信した対象）にCANCELを生成するかもしれません。プロキシは、それがマッチング要求をキャンセル受信応答コンテキストに関連付けられている保留中のクライアントトランザクションをキャンセルしなければなりません。"
    },
    {
      "indent": 3,
      "text": "A stateful proxy MAY generate CANCEL requests for pending INVITE client transactions based on the period specified in the INVITE's Expires header field elapsing. However, this is generally unnecessary since the endpoints involved will take care of signaling the end of the transaction.",
      "ja": "ステートフルプロキシはのは、経過ExpiresヘッダーフィールドをINVITEに指定された期間に基づいて、クライアントのトランザクションをINVITE保留中の要求をキャンセル生成してもよいです。関係するエンドポイントがトランザクションの終了を知らせるの世話をしますので、これは一般的に不要です。"
    },
    {
      "indent": 3,
      "text": "While a CANCEL request is handled in a stateful proxy by its own server transaction, a new response context is not created for it. Instead, the proxy layer searches its existing response contexts for the server transaction handling the request associated with this CANCEL. If a matching response context is found, the element MUST immediately return a 200 (OK) response to the CANCEL request. In this case, the element is acting as a user agent server as defined in Section 8.2. Furthermore, the element MUST generate CANCEL requests for all pending client transactions in the context as described in Section 16.7 step 10.",
      "ja": "CANCELリクエストは、独自のサーバーのトランザクションによってステートフルプロキシで処理されますが、新しい応答コンテキストはそれのために作成されていません。代わりに、プロキシ層は、このCANCELに関連付けられた要求を処理するサーバートランザクションのために、既存の応答コンテキストを検索します。マッチング応答コンテキストが見つかった場合、要素は直ちにCANCEL要求に200（OK）レスポンスを返さなければなりません。セクション8.2で定義された、この場合には、要素は、ユーザエージェントサーバとして機能しています。さらに、要素は、セクション16.7のステップ10で説明したように、コンテキスト内のすべての保留中のクライアント・トランザクション要求をキャンセル生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a response context is not found, the element does not have any knowledge of the request to apply the CANCEL to. It MUST statelessly forward the CANCEL request (it may have statelessly forwarded the associated request previously).",
      "ja": "応答コンテキストが見つからない場合、要素はにCANCEL適用する要求のいずれかの知識を持っていません。それはステートレスCANCEL要求を転送しなければならない（それがステートレスに以前に関連付けられた要求を転送している場合があります）。"
    },
    {
      "indent": 0,
      "text": "16.11 Stateless Proxy",
      "section_title": true,
      "ja": "16.11ステートレスプロキシ"
    },
    {
      "indent": 3,
      "text": "When acting statelessly, a proxy is a simple message forwarder. Much of the processing performed when acting statelessly is the same as when behaving statefully. The differences are detailed here.",
      "ja": "ステートレスに動作する場合、プロキシは、単純なメッセージフォワーダです。ステートレスに動作する場合の処理​​の多くは、ステートフルに動作したときと同じです。違いはここに詳述されています。"
    },
    {
      "indent": 3,
      "text": "A stateless proxy does not have any notion of a transaction, or of the response context used to describe stateful proxy behavior. Instead, the stateless proxy takes messages, both requests and responses, directly from the transport layer (See section 18). As a result, stateless proxies do not retransmit messages on their own. They do, however, forward all retransmissions they receive (they do not have the ability to distinguish a retransmission from the original message). Furthermore, when handling a request statelessly, an element MUST NOT generate its own 100 (Trying) or any other provisional response.",
      "ja": "ステートレスプロキシはトランザクションの、またはステートフルプロキシ動作を記述するために使用される応答コンテキストのいずれかの概念を持っていません。代わりに、ステートレスプロキシは直接トランスポート層（セクション18を参照）から、要求と応答の両方をメッセージになります。その結果、ステートレスプロキシは、独自のメッセージを再送しません。彼らは、しかし、彼らは（彼らは、元のメッセージからの再送を区別する能力を持っていない）を受け取るすべての再送を転送します。ステートレス要求を処理するとき、さらに、要素は、それ自身の100（試行）、または任意の他の暫定応答を生成してはいけません。"
    },
    {
      "indent": 3,
      "text": "A stateless proxy MUST validate a request as described in Section 16.3",
      "ja": "セクション16.3で説明したようにステートレスプロキシは、要求を検証しなければなりません"
    },
    {
      "indent": 3,
      "text": "A stateless proxy MUST follow the request processing steps described in Sections 16.4 through 16.5 with the following exception:",
      "ja": "ステートレスプロキシは、以下の例外を除いて16.5を介してセクション16.4に記載の要求処理の手順に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "o A stateless proxy MUST choose one and only one target from the target set. This choice MUST only rely on fields in the message and time-invariant properties of the server. In particular, a retransmitted request MUST be forwarded to the same destination each time it is processed. Furthermore, CANCEL and non-Routed ACK requests MUST generate the same choice as their associated INVITE.",
      "ja": "Oステートレスプロキシは、ターゲットセットから、唯一のターゲットを選択する必要があります。この選択は、サーバのメッセージと時不変のプロパティ内のフィールドに依存しなければなりません。具体的には、再送要求は同じ宛先にそれが処理されるたびに転送されなければなりません。さらに、CANCELとそのINVITEに関連するような非ルーティングACK要求は同じ選択を発生させなければなりません。"
    },
    {
      "indent": 3,
      "text": "A stateless proxy MUST follow the request processing steps described in Section 16.6 with the following exceptions:",
      "ja": "ステートレスプロキシは、以下の例外を除いて、セクション16.6で説明要求処理の手順に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "o The requirement for unique branch IDs across space and time applies to stateless proxies as well. However, a stateless proxy cannot simply use a random number generator to compute the first component of the branch ID, as described in Section 16.6 bullet 8. This is because retransmissions of a request need to have the same value, and a stateless proxy cannot tell a retransmission from the original request. Therefore, the component of the branch parameter that makes it unique MUST be the same each time a retransmitted request is forwarded. Thus for a stateless proxy, the branch parameter MUST be computed as a combinatoric function of message parameters which are invariant on retransmission.",
      "ja": "O空間と時間にわたって一意分岐IDの要件は、同様にプロキシをステートレスに適用されます。しかし、ステートレスプロキシは単にセクションで説明したように、分岐IDの最初のコンポーネントを計算するために乱数ジェネレータを使用することはできません16.6弾丸要求の再送信が同じ値を持っている必要があり、かつステートレスプロキシが言うことができないので、これは8元の要求からの再送。したがって、それはユニークな分岐パラメータの構成要素は、再送要求が転送されるたびに同じでなければなりません。したがってステートレスプロキシの、分岐パラメータは、再送に不変であるメッセージパラメータのcombinatoric関数として計算されなければなりません。"
    },
    {
      "indent": 9,
      "text": "The stateless proxy MAY use any technique it likes to guarantee uniqueness of its branch IDs across transactions. However, the following procedure is RECOMMENDED. The proxy examines the branch ID in the topmost Via header field of the received request. If it begins with the magic cookie, the first component of the branch ID of the outgoing request is computed as a hash of the received branch ID. Otherwise, the first component of the branch ID is computed as a hash of the topmost Via, the tag in the To header field, the tag in the From header field, the Call-ID header field, the CSeq number (but not method), and the Request-URI from the received request. One of these fields will always vary across two different transactions.",
      "ja": "ステートレスプロキシは、トランザクション間の分岐IDの一意性を保証するのが好き任意の技術を使用するかもしれません。ただし、以下の手順を推奨します。プロキシは、受信した要求の最上位ViaヘッダーフィールドにおけるブランチIDを調べます。それはマジッククッキーで始まる場合、発信要求の分岐IDの最初のコンポーネントは、受け取った分岐IDのハッシュとして計算されます。そうでない場合は、分岐IDの第一成分が最上位のVia、Toヘッダーフィールドにタグ、Fromヘッダフィールド内のタグのハッシュとして計算される、Call-IDヘッダーフィールド、のCSeq番号（ただし法） 、受信した要求からのRequest-URI。これらのフィールドのうちの1つは、常に2つの異なるトランザクション間で変化します。"
    },
    {
      "indent": 6,
      "text": "o All other message transformations specified in Section 16.6 MUST result in the same transformation of a retransmitted request. In particular, if the proxy inserts a Record-Route value or pushes URIs into the Route header field, it MUST place the same values in retransmissions of the request. As for the Via branch parameter, this implies that the transformations MUST be based on time-invariant configuration or retransmission-invariant properties of the request.",
      "ja": "Oセクション16.6で指定された他のすべてのメッセージ変換は、再送要求の同じ変換をもたらさなければなりません。プロキシがレコードルート値を挿入またはRouteヘッダーフィールドにURIを押すと、特に、その要求の再送信で同じ値を置かなければなりません。経由の分岐パラメータのように、これは変換がリクエストの時不変な構成または再送信不変の性質に基づいていなければならないことを意味します。"
    },
    {
      "indent": 6,
      "text": "o A stateless proxy determines where to forward the request as described for stateful proxies in Section 16.6 Item 10. The request is sent directly to the transport layer instead of through a client transaction.",
      "ja": "Oステートレスプロキシは、セクション10の要求がトランスポート層に代えて、クライアント・トランザクションを介して直接送信される16.6アイテムのステートフルプロキシに記載したように要求を転送する場所を決定します。"
    },
    {
      "indent": 9,
      "text": "Since a stateless proxy must forward retransmitted requests to the same destination and add identical branch parameters to each of them, it can only use information from the message itself and time-invariant configuration data for those calculations. If the configuration state is not time-invariant (for example, if a routing table is updated) any requests that could be affected by the change may not be forwarded statelessly during an interval equal to the transaction timeout window before or after the change. The method of processing the affected requests in that interval is an implementation decision. A common solution is to forward them transaction statefully.",
      "ja": "ステートレスプロキシは、同じ宛先に再送された要求を転送し、それらのそれぞれに、同一の分岐パラメータを追加する必要がありますので、それだけで、それらの計算のためのメッセージ自体と時不変コンフィギュレーション・データからの情報を使用することができます。設定状態が時不変でない場合（たとえば、ルーティングテーブルが更新された場合）の変化により影響を受ける可能性があるすべての要求は、変更の前または後にトランザクションタイムアウトウィンドウに等しい間隔の間にステートレスに転送されなくてもよいです。その間隔に影響を受けたリクエストを処理する方法は、実装上の決定です。一般的な解決策は、ステートフル彼らにトランザクションを転送することです。"
    },
    {
      "indent": 3,
      "text": "Stateless proxies MUST NOT perform special processing for CANCEL requests. They are processed by the above rules as any other requests. In particular, a stateless proxy applies the same Route header field processing to CANCEL requests that it applies to any other request.",
      "ja": "ステートレスプロキシはCANCELリクエストに対して特別な処理を実行してはなりません。彼らは、任意の他の要求として上記のルールによって処理されています。特に、ステートレスプロキシは、それが他の要求に適用される要求をキャンセルする同じRouteヘッダーフィールド処理を施します。"
    },
    {
      "indent": 3,
      "text": "Response processing as described in Section 16.7 does not apply to a proxy behaving statelessly. When a response arrives at a stateless proxy, the proxy MUST inspect the sent-by value in the first (topmost) Via header field value. If that address matches the proxy, (it equals a value this proxy has inserted into previous requests) the proxy MUST remove that header field value from the response and forward the result to the location indicated in the next Via header field value. The proxy MUST NOT add to, modify, or remove the message body. Unless specified otherwise, the proxy MUST NOT remove any other header field values. If the address does not match the proxy, the message MUST be silently discarded.",
      "ja": "16.7項で説明したように応答処理は、ステートレスに動作し、プロキシには適用されません。応答がステートレスプロキシに到着すると、プロキシはヘッダーフィールド値を介して送信さ-によって最初（一番上）の値を検査しなければなりません。そのアドレスがプロキシと一致した場合、プロキシは応答からそのヘッダーフィールド値を削除し、次のViaヘッダーフィールド値で示された場所に結果を転送しなければならない（それがこのプロキシは、前の要求に挿入した値に等しいです）。プロキシは、に追加、変更、またはメッセージ本文を削除してはなりません。特に指定しない限り、プロキシは、他のヘッダーフィールド値を削除してはなりません。アドレスがプロキシと一致しない場合、メッセージは静かに捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "16.12 Summary of Proxy Route Processing",
      "section_title": true,
      "ja": "プロキシのルート処理の16.12概要"
    },
    {
      "indent": 3,
      "text": "In the absence of local policy to the contrary, the processing a proxy performs on a request containing a Route header field can be summarized in the following steps.",
      "ja": "逆にローカルポリシーがない場合、プロキシはRouteヘッダーフィールドを含む要求に対して行う処理は、以下のステップに要約することができます。"
    },
    {
      "indent": 6,
      "text": "1. The proxy will inspect the Request-URI. If it indicates a resource owned by this proxy, the proxy will replace it with the results of running a location service. Otherwise, the proxy will not change the Request-URI.",
      "ja": "1.プロキシは、Request-URIを検査します。それがこのプロキシが所有するリソースを示している場合、プロキシは、ロケーションサービスを実行した結果でそれを置き換えます。それ以外の場合、プロキシは、Request-URIを変更しません。"
    },
    {
      "indent": 6,
      "text": "2. The proxy will inspect the URI in the topmost Route header field value. If it indicates this proxy, the proxy removes it from the Route header field (this route node has been reached).",
      "ja": "2.プロキシは、最上位のルートヘッダフィールド値にURIを検査します。それはこのプロキシを示す場合、プロキシはRouteヘッダーフィールドから削除し（このルートノードに達しました）。"
    },
    {
      "indent": 6,
      "text": "3. The proxy will forward the request to the resource indicated by the URI in the topmost Route header field value or in the Request-URI if no Route header field is present. The proxy determines the address, port and transport to use when forwarding the request by applying the procedures in [4] to that URI.",
      "ja": "3.プロキシはNOルートヘッダーフィールドが存在しない場合、最上位のルートヘッダフィールド値またはリクエストURIでURIによって示されるリソースに要求を転送します。プロキシは、要求を転送するとき、そのURI〜[4]の手順を適用することによって、使用するアドレス、ポートおよびトランスポートを決定します。"
    },
    {
      "indent": 3,
      "text": "If no strict-routing elements are encountered on the path of the request, the Request-URI will always indicate the target of the request.",
      "ja": "厳密なルーティング要素は、要求のパスに遭遇されていない場合は、Request-URIが常に要求のターゲットを示します。"
    },
    {
      "indent": 0,
      "text": "16.12.1 Examples",
      "section_title": true,
      "ja": "16.12.1例"
    },
    {
      "indent": 0,
      "text": "16.12.1.1 Basic SIP Trapezoid",
      "section_title": true,
      "ja": "16.12.1.1基本的なSIP台形"
    },
    {
      "indent": 3,
      "text": "This scenario is the basic SIP trapezoid, U1 -> P1 -> P2 -> U2, with both proxies record-routing. Here is the flow.",
      "ja": "両方のプロキシ・レコード・ルーティングと> U2、 - > P1  -   - > P2このシナリオでは、基本的なSIP台形、U1です。ここで流れがあります。"
    },
    {
      "indent": 3,
      "text": "U1 sends:",
      "ja": "U1は、送信します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com",
      "ja": "SIPのINVITE：callee@domain.com SIP / 2.0連絡先：SIP：caller@u1.example.com"
    },
    {
      "indent": 3,
      "text": "to P1. P1 is an outbound proxy. P1 is not responsible for domain.com, so it looks it up in DNS and sends it there. It also adds a Record-Route header field value:",
      "ja": "P1へ。 P1はアウトバウンドプロキシです。 P1はdomain.comの責任を負いませんので、DNSでそれを検索し、そこに送信します。また、Record-Routeヘッダーフィールド値を追加します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: <sip:p1.example.com;lr>",
      "ja": "SIPのINVITE：callee@domain.com SIP / 2.0連絡先：SIP：caller@u1.example.com録音-ルート：<SIP：p1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "P2 gets this. It is responsible for domain.com so it runs a location service and rewrites the Request-URI. It also adds a Record-Route header field value. There is no Route header field, so it resolves the new Request-URI to determine where to send the request:",
      "ja": "P2は、これを取得します。これは、domain.comの責任があるので、ロケーションサービスを実行し、要求URIを書き換えます。また、Record-Routeヘッダフィールド値を加算します。そこにはRouteヘッダーフィールドがないので、それはどこリクエストの送信先を決定するために新しいRequest-URIを解決します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@u2.domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: <sip:p2.domain.com;lr> Record-Route: <sip:p1.example.com;lr>",
      "ja": "SIPのINVITE：callee@u2.domain.com SIP / 2.0連絡先：SIP：caller@u1.example.com録音-ルート：<SIP：p2.domain.com; LR>レコード・ルート：<SIP：p1.example。 COM; LR>"
    },
    {
      "indent": 3,
      "text": "The callee at u2.domain.com gets this and responds with a 200 OK:",
      "ja": "u2.domain.comの呼び出し先はこれを取得し、200 OKで応答します。"
    },
    {
      "indent": 6,
      "text": "SIP/2.0 200 OK Contact: sip:callee@u2.domain.com Record-Route: <sip:p2.domain.com;lr> Record-Route: <sip:p1.example.com;lr>",
      "ja": "SIP / 2.0 200 OKお問い合わせ：SIP：callee@u2.domain.com録音-ルート：<SIP：p2.domain.com; LR>レコード・ルート：<SIP：p1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "The callee at u2 also sets its dialog state's remote target URI to sip:caller@u1.example.com and its route set to:",
      "ja": "U2の呼び出し先も一口にその対話状態のリモートターゲットURIを設定します。caller@u1.example.comとに設定されたルート："
    },
    {
      "indent": 6,
      "text": "(<sip:p2.domain.com;lr>,<sip:p1.example.com;lr>)",
      "ja": "（<SIP：p2.domain.com; LR>、<SIP：p1.example.com; LR>）"
    },
    {
      "indent": 3,
      "text": "This is forwarded by P2 to P1 to U1 as normal. Now, U1 sets its dialog state's remote target URI to sip:callee@u2.domain.com and its route set to:",
      "ja": "これは、通常のようにU1にP1にP2によって転送されます。さて、U1は、SIPにその対話状態のリモートターゲットURIを設定します。callee@u2.domain.comとに設定されたルート："
    },
    {
      "indent": 6,
      "text": "(<sip:p1.example.com;lr>,<sip:p2.domain.com;lr>)",
      "ja": "（<SIP：p1.example.com; LR>、<SIP：p2.domain.com; LR>）"
    },
    {
      "indent": 3,
      "text": "Since all the route set elements contain the lr parameter, U1 constructs the following BYE request:",
      "ja": "すべてのルートセットエレメントがLRパラメータを含んでいるので、U1は以下のBYEリクエストを構築します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:callee@u2.domain.com SIP/2.0 Route: <sip:p1.example.com;lr>,<sip:p2.domain.com;lr>",
      "ja": "BYEをSIP：callee@u2.domain.com SIP / 2.0経路：<SIP：p1.example.com; LR>、<SIP：p2.domain.com; LR>"
    },
    {
      "indent": 3,
      "text": "As any other element (including proxies) would do, it resolves the URI in the topmost Route header field value using DNS to determine where to send the request. This goes to P1. P1 notices that it is not responsible for the resource indicated in the Request-URI so it doesn't change it. It does see that it is the first value in the Route header field, so it removes that value, and forwards the request to P2:",
      "ja": "（プロキシを含む）任意の他の要素が行うであろうように、ここで要求を送信するかを決定するためにDNSを使用して最上位のルートヘッダフィールド値にURIを解決します。これは、P1に行きます。 P1は、それはそれはそれを変更しないように要求URIで示されたリソースの責任ではないことに気づきます。それは、その値を削除して、それがRouteヘッダーフィールドの最初の値であることを確認し、およびP2に要求を転送します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:callee@u2.domain.com SIP/2.0 Route: <sip:p2.domain.com;lr>",
      "ja": "BYEをSIP：callee@u2.domain.com SIP / 2.0経路：<SIP：p2.domain.com; LR>"
    },
    {
      "indent": 3,
      "text": "P2 also notices it is not responsible for the resource indicated by the Request-URI (it is responsible for domain.com, not u2.domain.com), so it doesn't change it. It does see itself in the first Route header field value, so it removes it and forwards the following to u2.domain.com based on a DNS lookup against the Request-URI:",
      "ja": "P2はまた、リクエストURI（それがdomain.com、ないu2.domain.comの原因である）で示されるリソースに対して責任を負わない気付くので、それを変更しません。これは、最初のRouteヘッダーフィールド値に自分自身を見ないので、u2.domain.comのRequest-URIに対するDNSルックアップに基づいて以下にそれを削除し、転送します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:callee@u2.domain.com SIP/2.0",
      "ja": "BYEのSIP：callee@u2.domain.com SIP / 2.0"
    },
    {
      "indent": 0,
      "text": "16.12.1.2 Traversing a Strict-Routing Proxy",
      "section_title": true,
      "ja": "厳密-ルーティングプロキシを横断16.12.1.2"
    },
    {
      "indent": 3,
      "text": "In this scenario, a dialog is established across four proxies, each of which adds Record-Route header field values. The third proxy implements the strict-routing procedures specified in RFC 2543 and many works in progress.",
      "ja": "このシナリオでは、ダイアログはRecord-Routeヘッダフィールド値を追加それぞれが4つのプロキシを越えて確立されています。第三のプロキシは、RFC 2543と進行中の多くの作品に指定された厳密なルーティング手順を実装します。"
    },
    {
      "indent": 6,
      "text": "U1->P1->P2->P3->P4->U2",
      "ja": "U1-> P1-> P2-> P3-> P4-> U2"
    },
    {
      "indent": 3,
      "text": "The INVITE arriving at U2 contains:",
      "ja": "INVITE U2に到着含まれています。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@u2.domain.com SIP/2.0 Contact: sip:caller@u1.example.com Record-Route: <sip:p4.domain.com;lr> Record-Route: <sip:p3.middle.com> Record-Route: <sip:p2.example.com;lr> Record-Route: <sip:p1.example.com;lr>",
      "ja": "SIPのINVITE：callee@u2.domain.com SIP / 2.0連絡先：SIP：caller@u1.example.com録音-ルート：<SIP：p4.domain.com; LR>レコード・ルート：<SIP：p3.middle。 COM>レコード・ルート：<SIP：p2.example.com; LR>レコード・ルート：<SIP：p1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "Which U2 responds to with a 200 OK. Later, U2 sends the following BYE request to P4 based on the first Route header field value.",
      "ja": "これはU2が200 OKで応答します。後、U2は、第Routeヘッダーフィールド値に基づいて、P4に次のBYE要求を送信します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:caller@u1.example.com SIP/2.0 Route: <sip:p4.domain.com;lr> Route: <sip:p3.middle.com> Route: <sip:p2.example.com;lr> Route: <sip:p1.example.com;lr>",
      "ja": "BYEをSIP：caller@u1.example.com SIP / 2.0経路：<SIP：p4.domain.com; LR>ルート<SIP：p3.middle.com>ルート<SIP：p2.example.com; LR>ルート：<SIP：p1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "P4 is not responsible for the resource indicated in the Request-URI so it will leave it alone. It notices that it is the element in the first Route header field value so it removes it. It then prepares to send the request based on the now first Route header field value of sip:p3.middle.com, but it notices that this URI does not contain the lr parameter, so before sending, it reformats the request to be:",
      "ja": "P4は、それが単独で残すよう要求URIで示されたリソースについては責任を負いません。それは、それを削除して、それが最初のRouteヘッダーフィールド値の要素があることに気付きます。その後、SIPの今最初のRouteヘッダーフィールド値に基づいて要求送信する準備：p3.middle.comを、それは、このURIがLRパラメータが含まれていないことに気付き、その送信する前に、それは要求があることを再フォーマット："
    },
    {
      "indent": 6,
      "text": "BYE sip:p3.middle.com SIP/2.0 Route: <sip:p2.example.com;lr> Route: <sip:p1.example.com;lr> Route: <sip:caller@u1.example.com>",
      "ja": "BYEをSIP：p3.middle.com SIP / 2.0経路：<SIP：p2.example.com; LR>ルート<SIP：p1.example.com; LR>ルート<SIP：caller@u1.example.com>"
    },
    {
      "indent": 3,
      "text": "P3 is a strict router, so it forwards the following to P2:",
      "ja": "P3は、厳格なルータですので、P2に以下を転送します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:p2.example.com;lr SIP/2.0 Route: <sip:p1.example.com;lr> Route: <sip:caller@u1.example.com>",
      "ja": "BYEをSIP：p2.example.com; LR SIP / 2.0経路：<SIP：p1.example.com; LR>ルート<SIP：caller@u1.example.com>"
    },
    {
      "indent": 3,
      "text": "P2 sees the request-URI is a value it placed into a Record-Route header field, so before further processing, it rewrites the request to be:",
      "ja": "P2は、要求URIを見て、それがRecord-Routeヘッダフィールドに置かれた値であるので、さらなる処理の前に、それがされる要求を書き換えます。"
    },
    {
      "indent": 6,
      "text": "BYE sip:caller@u1.example.com SIP/2.0 Route: <sip:p1.example.com;lr>",
      "ja": "BYEをSIP：caller@u1.example.com SIP / 2.0経路：<SIP：p1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "P2 is not responsible for u1.example.com, so it sends the request to P1 based on the resolution of the Route header field value.",
      "ja": "P2はu1.example.comの責任ではないので、Routeヘッダーフィールド値の解像度に基づいて、P1に要求を送信します。"
    },
    {
      "indent": 3,
      "text": "P1 notices itself in the topmost Route header field value, so it removes it, resulting in:",
      "ja": "最上位のルートヘッダフィールド値のP1通知自体、それは、その結果、それを削除して："
    },
    {
      "indent": 6,
      "text": "BYE sip:caller@u1.example.com SIP/2.0",
      "ja": "BYEのSIP：caller@u1.example.com SIP / 2.0"
    },
    {
      "indent": 3,
      "text": "Since P1 is not responsible for u1.example.com and there is no Route header field, P1 will forward the request to u1.example.com based on the Request-URI.",
      "ja": "P1はu1.example.comの責任ではなく、NOルートヘッダーフィールドが存在しないので、P1は、Request-URIに基づいてu1.example.com要求を転送します。"
    },
    {
      "indent": 0,
      "text": "16.12.1.3 Rewriting Record-Route Header Field Values",
      "section_title": true,
      "ja": "レコード・ルートヘッダーフィールドの値を書き換え16.12.1.3"
    },
    {
      "indent": 3,
      "text": "In this scenario, U1 and U2 are in different private namespaces and they enter a dialog through a proxy P1, which acts as a gateway between the namespaces.",
      "ja": "このシナリオでは、U1およびU2は異なるプライベート名前空間であり、それらは名前空間との間のゲートウェイとして機能するプロキシP1を介してダイアログに入ります。"
    },
    {
      "indent": 6,
      "text": "U1->P1->U2",
      "ja": "U1-> P1-> U2"
    },
    {
      "indent": 3,
      "text": "U1 sends:",
      "ja": "U1は、送信します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@gateway.leftprivatespace.com SIP/2.0 Contact: <sip:caller@u1.leftprivatespace.com>",
      "ja": "SIPのINVITE：callee@gateway.leftprivatespace.com SIP / 2.0連絡先：<SIP：caller@u1.leftprivatespace.com>"
    },
    {
      "indent": 3,
      "text": "P1 uses its location service and sends the following to U2:",
      "ja": "P1は、そのロケーションサービスを使用し、U2に次を送信します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:callee@rightprivatespace.com SIP/2.0 Contact: <sip:caller@u1.leftprivatespace.com> Record-Route: <sip:gateway.rightprivatespace.com;lr>",
      "ja": "callee@rightprivatespace.com SIP / 2.0連絡先：：SIPのINVITE <一口：caller@u1.leftprivatespace.com>レコード・ルート：<SIP：gateway.rightprivatespace.com; LR>"
    },
    {
      "indent": 3,
      "text": "U2 sends this 200 (OK) back to P1:",
      "ja": "U2は、P1に戻って、この200（OK）を送信します。"
    },
    {
      "indent": 6,
      "text": "SIP/2.0 200 OK Contact: <sip:callee@u2.rightprivatespace.com> Record-Route: <sip:gateway.rightprivatespace.com;lr>",
      "ja": "SIP / 2.0 200 OK連絡先：<SIP：callee@u2.rightprivatespace.com>レコード・ルート：<SIP：gateway.rightprivatespace.com; LR>"
    },
    {
      "indent": 3,
      "text": "P1 rewrites its Record-Route header parameter to provide a value that U1 will find useful, and sends the following to U1:",
      "ja": "P1は、U1が有用見つけること値を提供することをRecord-Routeヘッダパラメータを書き換え、U1に以下を送信します。"
    },
    {
      "indent": 6,
      "text": "SIP/2.0 200 OK Contact: <sip:callee@u2.rightprivatespace.com> Record-Route: <sip:gateway.leftprivatespace.com;lr>",
      "ja": "SIP / 2.0 200 OK連絡先：<SIP：callee@u2.rightprivatespace.com>レコード・ルート：<SIP：gateway.leftprivatespace.com; LR>"
    },
    {
      "indent": 3,
      "text": "Later, U1 sends the following BYE request to P1:",
      "ja": "その後、U1は、P1に次のBYEリクエストを送信します。"
    },
    {
      "indent": 6,
      "text": "BYE sip:callee@u2.rightprivatespace.com SIP/2.0 Route: <sip:gateway.leftprivatespace.com;lr>",
      "ja": "BYEをSIP：callee@u2.rightprivatespace.com SIP / 2.0経路：<SIP：gateway.leftprivatespace.com; LR>"
    },
    {
      "indent": 3,
      "text": "which P1 forwards to U2 as:",
      "ja": "U2にどのP1転送のように："
    },
    {
      "indent": 6,
      "text": "BYE sip:callee@u2.rightprivatespace.com SIP/2.0",
      "ja": "BYEのSIP：callee@u2.rightprivatespace.com SIP / 2.0"
    },
    {
      "indent": 0,
      "text": "17 Transactions",
      "ja": "17件の取引"
    },
    {
      "indent": 3,
      "text": "SIP is a transactional protocol: interactions between components take place in a series of independent message exchanges. Specifically, a SIP transaction consists of a single request and any responses to that request, which include zero or more provisional responses and one or more final responses. In the case of a transaction where the request was an INVITE (known as an INVITE transaction), the transaction also includes the ACK only if the final response was not a 2xx response. If the response was a 2xx, the ACK is not considered part of the transaction.",
      "ja": "SIPは、トランザクションプロトコルである：コンポーネント間の相互作用が独立したメッセージ交換の一連で行われます。具体的には、SIPトランザクションは、単一の要求及びゼロ以上の暫定応答および1つまたは複数の最終的な応答を含むことが要求への応答から成ります。要求（INVITEトランザクションとして知られている）INVITEたトランザクションの場合、トランザクションは、最終応答が2xx応答でなかった場合にのみACKを含みます。応答が2XXだった場合、ACKはトランザクションの一部とはみなされません。"
    },
    {
      "indent": 6,
      "text": "The reason for this separation is rooted in the importance of delivering all 200 (OK) responses to an INVITE to the UAC. To deliver them all to the UAC, the UAS alone takes responsibility for retransmitting them (see Section 13.3.1.4), and the UAC alone takes responsibility for acknowledging them with ACK (see Section 13.2.2.4). Since this ACK is retransmitted only by the UAC, it is effectively considered its own transaction.",
      "ja": "この分離の理由はUACに招待し、すべての200（OK）応答を提供することの重要性に根ざしています。 UACにそれらすべてをお届けするために、単独のUAS（項13.3.1.4を参照）、それらを再送信するための責任を取り、単独でUAC（セクション13.2.2.4を参照）ACKとそれらを認めるための責任を取ります。このACKはUACによってのみ再送されているので、それが効果的に独自のトランザクションと考えられています。"
    },
    {
      "indent": 3,
      "text": "Transactions have a client side and a server side. The client side is known as a client transaction and the server side as a server transaction. The client transaction sends the request, and the server transaction sends the response. The client and server transactions are logical functions that are embedded in any number of elements. Specifically, they exist within user agents and stateful proxy servers. Consider the example in Section 4. In this example, the UAC executes the client transaction, and its outbound proxy executes the server transaction. The outbound proxy also executes a client transaction, which sends the request to a server transaction in the inbound proxy. That proxy also executes a client transaction, which in turn sends the request to a server transaction in the UAS. This is shown in Figure 4.",
      "ja": "トランザクションは、クライアント側とサーバー側を持っています。クライアント側はクライアントトランザクションとサーバートランザクションとしてサーバ側として知られています。クライアントトランザクションは、要求を送信し、サーバートランザクションは、応答を送信します。クライアントとサーバーのトランザクションは、任意の数の要素に埋め込まれた論理的な機能です。具体的には、ユーザーエージェントとステートフルプロキシサーバ内に存在します。この例では第4節で例を考えてみましょう、UACがクライアントトランザクションを実行し、そのアウトバウンドプロキシがサーバートランザクションを実行します。アウトバウンドプロキシは、インバウンドプロキシにサーバートランザクションにリクエストを送信するクライアントのトランザクションを実行します。そのプロキシはまた今度にUASにおけるサーバートランザクションに要求を送信したクライアントのトランザクションを実行します。これは、図4に示されています。"
    },
    {
      "indent": 3,
      "text": "+---------+        +---------+        +---------+        +---------+\n|      +-+|Request |+-+   +-+|Request |+-+   +-+|Request |+-+      |\n|      |C||------->||S|   |C||------->||S|   |C||------->||S|      |\n|      |l||        ||e|   |l||        ||e|   |l||        ||e|      |\n|      |i||        ||r|   |i||        ||r|   |i||        ||r|      |\n|      |e||        ||v|   |e||        ||v|   |e||        ||v|      |\n|      |n||        ||e|   |n||        ||e|   |n||        ||e|      |\n|      |t||        ||r|   |t||        ||r|   |t||        ||r|      |\n|      | ||        || |   | ||        || |   | ||        || |      |\n|      |T||        ||T|   |T||        ||T|   |T||        ||T|      |\n|      |r||        ||r|   |r||        ||r|   |r||        ||r|      |\n|      |a||        ||a|   |a||        ||a|   |a||        ||a|      |\n|      |n||        ||n|   |n||        ||n|   |n||        ||n|      |\n|      |s||Response||s|   |s||Response||s|   |s||Response||s|      |\n|      +-+|<-------|+-+   +-+|<-------|+-+   +-+|<-------|+-+      |\n+---------+        +---------+        +---------+        +---------+\n   UAC               Outbound           Inbound              UAS\n                     Proxy               Proxy",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 4: Transaction relationships",
      "ja": "図4：取引関係"
    },
    {
      "indent": 3,
      "text": "A stateless proxy does not contain a client or server transaction. The transaction exists between the UA or stateful proxy on one side, and the UA or stateful proxy on the other side. As far as SIP transactions are concerned, stateless proxies are effectively transparent. The purpose of the client transaction is to receive a request from the element in which the client is embedded (call this element the \"Transaction User\" or TU; it can be a UA or a stateful proxy), and reliably deliver the request to a server transaction.",
      "ja": "ステートレスプロキシは、クライアントまたはサーバのトランザクションが含まれていません。トランザクションは、他の側UA又は片側にステートフルプロキシ、及びUAまたはステートフルプロキシの間に存在します。限りSIPトランザクションを懸念しているとして、ステートレスプロキシは効果的に透明です。 、かつ確実にAに要求を届ける、クライアント・トランザクションの目的は、クライアントが埋め込まれている要素（それはUAまたはステートフルプロキシすることができ、「取引ユーザー」またはTUこの要素を呼び出す）からの要求を受信しますサーバートランザクション。"
    },
    {
      "indent": 3,
      "text": "The client transaction is also responsible for receiving responses and delivering them to the TU, filtering out any response retransmissions or disallowed responses (such as a response to ACK). Additionally, in the case of an INVITE request, the client transaction is responsible for generating the ACK request for any final response accepting a 2xx response.",
      "ja": "クライアントトランザクションも応答を受信し、TUに配信、任意の応答再送信または（例えばACKに対する応答など）許可されない応答をフィルタリングする責任があります。また、INVITEリクエストの場合には、クライアントトランザクションは、2xx応答を受け入れるすべての最終応答に対するACKリクエストを生成するための責任があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, the purpose of the server transaction is to receive requests from the transport layer and deliver them to the TU. The server transaction filters any request retransmissions from the network. The server transaction accepts responses from the TU and delivers them to the transport layer for transmission over the network. In the case of an INVITE transaction, it absorbs the ACK request for any final response excepting a 2xx response.",
      "ja": "同様に、サーバートランザクションの目的は、トランスポート層からの要求を受信し、TUにそれらを提供することです。サーバートランザクションは、ネットワークからの要求の再送信をフィルタリングします。サーバートランザクションは、TUからの応答を受け入れ、ネットワークを介して送信するためのトランスポート層に配信します。 INVITEトランザクションの場合には、2xx応答を除く任意の最終的な応答のためにACK要求を吸収します。"
    },
    {
      "indent": 3,
      "text": "The 2xx response and its ACK receive special treatment. This response is retransmitted only by a UAS, and its ACK generated only by the UAC. This end-to-end treatment is needed so that a caller knows the entire set of users that have accepted the call. Because of this special handling, retransmissions of the 2xx response are handled by the UA core, not the transaction layer. Similarly, generation of the ACK for the 2xx is handled by the UA core. Each proxy along the path merely forwards each 2xx response to INVITE and its corresponding ACK.",
      "ja": "2xx応答とそのACKは特別な扱いを受けます。この応答はUASのみが再送し、そのACKはUACによって生成されます。呼び出し側がコールを受け入れたユーザーのセット全体を知っているように、このエンドツーエンドの処理が必要とされています。このため、特別な処理のため、2xx応答の再送はUAコアではなく、トランザクション層によって処理されます。同様に、2XXのためのACKの生成はUAコアによって処理されます。経路に沿った各プロキシは単にINVITEとそれに対応するACKするそれぞれの2xx応答を転送します。"
    },
    {
      "indent": 0,
      "text": "17.1 Client Transaction",
      "section_title": true,
      "ja": "17.1クライアントトランザクション"
    },
    {
      "indent": 3,
      "text": "The client transaction provides its functionality through the maintenance of a state machine.",
      "ja": "クライアントトランザクションはステートマシンのメンテナンスを通じてその機能を提供します。"
    },
    {
      "indent": 3,
      "text": "The TU communicates with the client transaction through a simple interface. When the TU wishes to initiate a new transaction, it creates a client transaction and passes it the SIP request to send and an IP address, port, and transport to which to send it. The client transaction begins execution of its state machine. Valid responses are passed up to the TU from the client transaction.",
      "ja": "TUは、シンプルなインターフェイスを介してクライアントトランザクションと通信します。 TUは、新しいトランザクションを開始することを希望する場合は、クライアントのトランザクションを作成し、それを送信するためのSIP要求し、それを送信するとIPアドレス、ポート、およびトランスポートを渡します。クライアントトランザクションは、そのステートマシンの実行を開始します。有効な応答はクライアントトランザクションからTUに渡されています。"
    },
    {
      "indent": 3,
      "text": "There are two types of client transaction state machines, depending on the method of the request passed by the TU. One handles client transactions for INVITE requests. This type of machine is referred to as an INVITE client transaction. Another type handles client transactions for all requests except INVITE and ACK. This is referred to as a non-INVITE client transaction. There is no client transaction for ACK. If the TU wishes to send an ACK, it passes one directly to the transport layer for transmission.",
      "ja": "TUによって渡された要求の方法に応じて、クライアントのトランザクション・ステート・マシンの2種類があります。一つはINVITEリクエストのためのクライアントトランザクションを処理します。マシンのこのタイプは、INVITEクライアントトランザクションと呼ばれています。もう一つのタイプはINVITEとACK以外のすべての要求のためのクライアントトランザクションを処理します。これは非INVITEクライアントトランザクションと呼ばれています。 ACKのためのクライアントトランザクションはありません。 TUがACKを送信したい場合は、送信のためのトランスポート層に直接ものを渡します。"
    },
    {
      "indent": 3,
      "text": "The INVITE transaction is different from those of other methods because of its extended duration. Normally, human input is required in order to respond to an INVITE. The long delays expected for sending a response argue for a three-way handshake. On the other hand, requests of other methods are expected to complete rapidly. Because of the non-INVITE transaction's reliance on a two-way handshake, TUs SHOULD respond immediately to non-INVITE requests.",
      "ja": "INVITEトランザクションは、その延長期間の他の方法とは異なっています。通常、人間の入力は、INVITEに対応するために必要とされます。応答を送信するために期待される長い遅延は3ウェイハンドシェイクのために主張しています。一方、他の方法の要求が急速に完了することが期待されています。そのため2ウェイハンドシェイクの非INVITEトランザクションの信頼の、のTUは非INVITE要求に即座に応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "17.1.1 INVITE Client Transaction",
      "section_title": true,
      "ja": "17.1.1クライアントトランザクションをINVITE"
    },
    {
      "indent": 0,
      "text": "17.1.1.1 Overview of INVITE Transaction",
      "section_title": true,
      "ja": "INVITEトランザクションの17.1.1.1概要"
    },
    {
      "indent": 3,
      "text": "The INVITE transaction consists of a three-way handshake. The client transaction sends an INVITE, the server transaction sends responses, and the client transaction sends an ACK. For unreliable transports (such as UDP), the client transaction retransmits requests at an interval that starts at T1 seconds and doubles after every retransmission. T1 is an estimate of the round-trip time (RTT), and it defaults to 500 ms. Nearly all of the transaction timers described here scale with T1, and changing T1 adjusts their values. The request is not retransmitted over reliable transports. After receiving a 1xx response, any retransmissions cease altogether, and the client waits for further responses. The server transaction can send additional 1xx responses, which are not transmitted reliably by the server transaction. Eventually, the server transaction decides to send a final response. For unreliable transports, that response is retransmitted periodically, and for reliable transports, it is sent once. For each final response that is received at the client transaction, the client transaction sends an ACK, the purpose of which is to quench retransmissions of the response.",
      "ja": "INVITEトランザクションは3ウェイハンドシェイクで構成されています。クライアントトランザクションがINVITEを送信、サーバートランザクションは、応答を送信し、クライアントのトランザクションがACKを送信します。 （UDPなど）信頼性の低いトランスポートの場合は、クライアントトランザクションは、T1秒で始まり、すべての再送信後に倍増した間隔で要求を再送信します。 T1は、ラウンドトリップ時間（RTT）の推定値であり、500ミリ秒にデフォルト設定。ほぼすべてここで説明したトランザクションタイマーのは、T1とスケール、そしてT1を変更すると、それらの値を調整します。要求は、信頼性の高いトランスポート上で再送信されません。 1xx応答を受信した後、任意の再送信が完全に停止し、クライアントは、さらに応答を待ちます。サーバートランザクションは、サーバーのトランザクションによって確実に伝達されていない追加の1xx応答を送信することができます。最終的に、サーバートランザクションは、最終的な応答を送信することを決定します。信頼性のないトランスポートについては、その応答が定期的に再送され、かつ信頼性の高いトランスポートのために、それが一度に送信されます。クライアントトランザクションで受信される各最終応答のために、クライアントトランザクションは、応答の再送を急冷することで目的はACKを送信します。"
    },
    {
      "indent": 0,
      "text": "17.1.1.2 Formal Description",
      "section_title": true,
      "ja": "17.1.1.2形式記述"
    },
    {
      "indent": 3,
      "text": "The state machine for the INVITE client transaction is shown in Figure 5. The initial state, \"calling\", MUST be entered when the TU initiates a new client transaction with an INVITE request. The client transaction MUST pass the request to the transport layer for transmission (see Section 18). If an unreliable transport is being used, the client transaction MUST start timer A with a value of T1. If a reliable transport is being used, the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions). For any transport, the client transaction MUST start timer B with a value of 64*T1 seconds (Timer B controls transaction timeouts).",
      "ja": "INVITEクライアントトランザクションのためのステートマシンは、TUがINVITEリクエストで新規クライアントトランザクションを開始したときに入力する必要があり、「呼び出し」、図5の初期状態で示されています。クライアントトランザクションが送信用のトランスポート層への要求を渡す必要があります（セクション18を参照）。信頼性のないトランスポートが使用されている場合、クライアントトランザクションは、T1の値とタイマAを起動する必要があります。信頼性の高いトランスポートが使用されている場合、クライアントトランザクションは、（タイマAコントロールが再送信を要求する）タイマAを始めるべきではありません。任意の輸送のために、クライアントトランザクションは64 * T1秒（タイマーBはトランザクションのタイムアウトを制御）の値とタイマBを起動する必要があります。"
    },
    {
      "indent": 3,
      "text": "When timer A fires, the client transaction MUST retransmit the request by passing it to the transport layer, and MUST reset the timer with a value of 2*T1. The formal definition of retransmit within the context of the transaction layer is to take the message previously sent to the transport layer and pass it to the transport layer once more.",
      "ja": "ときに火災タイマー、クライアントトランザクションはトランスポート層に渡すことで、要求を再送信しなければならない、と2 * T1の値でタイマーをリセットしなければなりません。トランザクション層のコンテキスト内で再送信の正式な定義は以前にトランスポート層に送信されるメッセージを取ると、一回以上のトランスポート層にそれを渡すことです。"
    },
    {
      "indent": 3,
      "text": "When timer A fires 2*T1 seconds later, the request MUST be retransmitted again (assuming the client transaction is still in this state). This process MUST continue so that the request is retransmitted with intervals that double after each transmission. These retransmissions SHOULD only be done while the client transaction is in the \"calling\" state.",
      "ja": "タイマーA火災が2 * T1秒後に、要求が再び再送しなければならないとき（クライアントトランザクションを想定し、この状態のままです）。要求が各送信後に倍増間隔で再送信されるように、このプロセスは継続する必要があります。クライアントトランザクションが「呼び出し」状態にある間、これらの再送信にのみ行われるべきです。"
    },
    {
      "indent": 3,
      "text": "The default value for T1 is 500 ms. T1 is an estimate of the RTT between the client and server transactions. Elements MAY (though it is NOT RECOMMENDED) use smaller values of T1 within closed, private networks that do not permit general Internet connection. T1 MAY be chosen larger, and this is RECOMMENDED if it is known in advance (such as on high latency access links) that the RTT is larger. Whatever the value of T1, the exponential backoffs on retransmissions described in this section MUST be used.",
      "ja": "T1のデフォルト値は500ミリ秒です。 T1は、クライアントとサーバーのトランザクション間のRTTの推定値です。要素MAYは、（それが推奨されていないが）一般的なインターネット接続を許可していない閉じ、プライベートネットワーク内のT1の小さい方の値を使用しています。 RTTが大きいことT1が大きく選択することができる、それが（例えば高遅延アクセスリンク上など）事前に分かっている場合、これは推奨されています。どのようなT1の値は、このセクションで説明再送に指数バックオフを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client transaction is still in the \"Calling\" state when timer B fires, the client transaction SHOULD inform the TU that a timeout has occurred. The client transaction MUST NOT generate an ACK. The value of 64*T1 is equal to the amount of time required to send seven requests in the case of an unreliable transport.",
      "ja": "とき、タイマBの火災クライアントトランザクションは「呼び出し」状態にある場合、クライアントトランザクションがタイムアウトが発生したことをTUに通知する必要があります。クライアントトランザクションがACKを生成してはなりません。 64 * T1の値は信頼できない輸送の場合には7つのリクエストを送信するために必要な時間の量に等しいです。"
    },
    {
      "indent": 3,
      "text": "If the client transaction receives a provisional response while in the \"Calling\" state, it transitions to the \"Proceeding\" state. In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the request any longer. Furthermore, the provisional response MUST be passed to the TU. Any further provisional responses MUST be passed up to the TU while in the \"Proceeding\" state.",
      "ja": "クライアントトランザクションが「呼び出し」状態の間、暫定的な応答を受信した場合、それは「Proceeding」ステートに移行します。 「Proceeding」ステートでは、クライアントトランザクションは、もはや要求を再送すべきではありません。また、暫定的な応答はTUに渡されなければなりません。 「Proceeding」ステートにある間に、任意の更なる暫定応答はTUに渡されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When in either the \"Calling\" or \"Proceeding\" states, reception of a response with status code from 300-699 MUST cause the client transaction to transition to \"Completed\". The client transaction MUST pass the received response up to the TU, and the client transaction MUST generate an ACK request, even if the transport is reliable (guidelines for constructing the ACK from the response are given in Section 17.1.1.3) and then pass the ACK to the transport layer for transmission. The ACK MUST be sent to the same address, port, and transport to which the original request was sent. The client transaction SHOULD start timer D when it enters the \"Completed\" state, with a value of at least 32 seconds for unreliable transports, and a value of zero seconds for reliable transports. Timer D reflects the amount of time that the server transaction can remain in the \"Completed\" state when unreliable transports are used. This is equal to Timer H in the INVITE server transaction, whose default is 64*T1. However, the client transaction does not know the value of T1 in use by the server transaction, so an absolute minimum of 32s is used instead of basing Timer D on T1.",
      "ja": "「通話」または「議事録」の状態のいずれかで、300から699からステータスコードでレスポンスの受信が原因としなければならないときにクライアントトランザクションは「完了」に移行します。クライアントトランザクションは、TUまで受信した応答を渡す必要があり、そしてクライアントトランザクションはトランスポートが通過し、その後、信頼性（応答からACKを構築するためのガイドラインは、セクション17.1.1.3に記載されている）とされていても、ACK要求を発生させなければなりません送信用のトランスポート層にACK。 ACKは、元の要求が送られたのと同じアドレス、ポート、およびトランスポートに送信されなければなりません。それは信頼性の低いトランスポートのために、少なくとも32秒の値、および信頼性の高いトランスポートの0秒の値で、「完了」状態になったとき、クライアントトランザクションはタイマーDを開始する必要があります。タイマーDは、信頼性のないトランスポートが使用されている場合、サーバートランザクションは「完了」状態のままにできる時間の量を反映しています。これは、そのデフォルト64 * T1であるINVITEサーバートランザクションにタイマーHに等しいです。しかし、クライアントのトランザクションは、サーバトランザクションで使用されているT1の値を知らないので、32Sの絶対最小値ではなくT1にタイマDを基づかのに使用されます。"
    },
    {
      "indent": 3,
      "text": "Any retransmissions of the final response that are received while in the \"Completed\" state MUST cause the ACK to be re-passed to the transport layer for retransmission, but the newly received response MUST NOT be passed up to the TU. A retransmission of the response is defined as any response which would match the same client transaction based on the rules of Section 17.1.3.",
      "ja": "「完了」状態の間に受信されている最終的な応答のいずれかの再送信は、ACKが再送のためのトランスポート層に再通過させる原因となる必要がありますが、新たに受信した応答はTUに渡されてはなりません。応答の再送信は、セクション17.1.3のルールに基づいて、同じクライアントトランザクションにマッチする任意の応答として定義されます。"
    },
    {
      "indent": 0,
      "text": "                               |INVITE from TU\n             Timer A fires     |INVITE sent\n             Reset A,          V                      Timer B fires\n             INVITE sent +-----------+                or Transport Err.\n               +---------|           |---------------+inform TU\n               |         |  Calling  |               |\n               +-------->|           |-------------->|\n                         +-----------+ 2xx           |\n                            |  |       2xx to TU     |\n                            |  |1xx                  |\n    300-699 +---------------+  |1xx to TU            |\n   ACK sent |                  |                     |\nresp. to TU |  1xx             V                     |\n            |  1xx to TU  -----------+               |\n            |  +---------|           |               |\n            |  |         |Proceeding |-------------->|\n            |  +-------->|           | 2xx           |\n            |            +-----------+ 2xx to TU     |\n            |       300-699    |                     |\n            |       ACK sent,  |                     |\n            |       resp. to TU|                     |\n            |                  |                     |      NOTE:\n            |  300-699         V                     |\n            |  ACK sent  +-----------+Transport Err. |  transitions\n            |  +---------|           |Inform TU      |  labeled with\n            |  |         | Completed |-------------->|  the event\n            |  +-------->|           |               |  over the action\n            |            +-----------+               |  to take\n            |              ^   |                     |\n            |              |   | Timer D fires       |\n            +--------------+   | -                   |\n                               |                     |\n                               V                     |\n                         +-----------+               |\n                         |           |               |\n                         | Terminated|<--------------+\n                         |           |\n                         +-----------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 5: INVITE client transaction",
      "ja": "図5：クライアントトランザクションをINVITE"
    },
    {
      "indent": 3,
      "text": "If timer D fires while the client transaction is in the \"Completed\" state, the client transaction MUST move to the terminated state.",
      "ja": "クライアントトランザクションは「完了」状態にある間、タイマーDが発火した場合は、クライアントのトランザクションが終了状態に移動する必要があります。"
    },
    {
      "indent": 3,
      "text": "When in either the \"Calling\" or \"Proceeding\" states, reception of a 2xx response MUST cause the client transaction to enter the \"Terminated\" state, and the response MUST be passed up to the TU. The handling of this response depends on whether the TU is a proxy core or a UAC core. A UAC core will handle generation of the ACK for this response, while a proxy core will always forward the 200 (OK) upstream. The differing treatment of 200 (OK) between proxy and UAC is the reason that handling of it does not take place in the transaction layer.",
      "ja": "「呼び出し」または「議事録」の状態のいずれかにすると、2xx応答の受信は、「終端」状態に入るように、クライアントのトランザクションを起こさなければならず（MUST）、応答はTUに渡されなければなりません。この応答の取り扱いは、TUがプロキシコアまたはUACコアであるかどうかに依存します。 UACコアは、この応答のためにACKの生成を処理する一方、プロキシコアは常に順方向上流200（OK）。プロキシとUACの間に200の異なる治療（OK）は、それの取扱いは、トランザクション層では起こらないということの理由です。"
    },
    {
      "indent": 3,
      "text": "The client transaction MUST be destroyed the instant it enters the \"Terminated\" state. This is actually necessary to guarantee correct operation. The reason is that 2xx responses to an INVITE are treated differently; each one is forwarded by proxies, and the ACK handling in a UAC is different. Thus, each 2xx needs to be passed to a proxy core (so that it can be forwarded) and to a UAC core (so it can be acknowledged). No transaction layer processing takes place. Whenever a response is received by the transport, if the transport layer finds no matching client transaction (using the rules of Section 17.1.3), the response is passed directly to the core. Since the matching client transaction is destroyed by the first 2xx, subsequent 2xx will find no match and therefore be passed to the core.",
      "ja": "クライアントトランザクションは、それが「終端」状態に入る瞬間を破壊しなければなりません。これは正しい動作を保証するために、実際に必要です。その理由は、INVITEへの2xx応答が異なって扱われることです。それぞれがプロキシによって転送され、UACにおけるACK処理が異なっています。したがって、それぞれの2xxは、プロキシコアに渡される必要がある（これは転送することができるように）とUACコアに（それが認められることができます）。トランザクション・レイヤの処理は行われません。応答はトランスポートによって受信されるたびに、トランスポート層（セクション17.1.3のルールを使用して）一致するクライアント・トランザクションを見つけない場合、応答は、コアに直接渡されます。一致するクライアント・トランザクションが最初の2xxによって破壊されているので、後続の2xxは一致を見つけない、したがってコアに渡されます。"
    },
    {
      "indent": 0,
      "text": "17.1.1.3 Construction of the ACK Request",
      "section_title": true,
      "ja": "ACK要求の17.1.1.3建設"
    },
    {
      "indent": 3,
      "text": "This section specifies the construction of ACK requests sent within the client transaction. A UAC core that generates an ACK for 2xx MUST instead follow the rules described in Section 13.",
      "ja": "このセクションでは、クライアントのトランザクション内で送信されたACK要求の構築を指定します。 2XXに対するACKを生成するUACコアは代わり項13に記載の規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "The ACK request constructed by the client transaction MUST contain values for the Call-ID, From, and Request-URI that are equal to the values of those header fields in the request passed to the transport by the client transaction (call this the \"original request\"). The To header field in the ACK MUST equal the To header field in the response being acknowledged, and therefore will usually differ from the To header field in the original request by the addition of the tag parameter. The ACK MUST contain a single Via header field, and this MUST be equal to the top Via header field of the original request. The CSeq header field in the ACK MUST contain the same value for the sequence number as was present in the original request, but the method parameter MUST be equal to \"ACK\".",
      "ja": "クライアントトランザクションによって構築されるACK要求からコールIDの値を、含む、およびクライアントトランザクションによってトランスポートに渡された要求におけるそれらのヘッダフィールドの値に等しいのRequest-URIしなければならない（この「元のコール要求\"）。肯定応答され、応答のフィールドをヘッダーに等しくしなければならないので、通常のタグパラメータを添加することにより元の要求のフィールドをヘッダーには異なるであろう。ACKのフィールドをヘッダーにACKは単一のViaヘッダフィールドを含まなければならない、これは、元の要求のヘッダフィールドを介して上部に等しくなければなりません。元の要求に存在していたが、メソッドパラメータが「ACK」に等しくなければならないようにACKでCSeqヘッダーフィールドは、シーケンス番号と同じ値を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the INVITE request whose response is being acknowledged had Route header fields, those header fields MUST appear in the ACK. This is to ensure that the ACK can be routed properly through any downstream stateless proxies.",
      "ja": "その応答認知されているINVITEリクエストがRouteヘッダーフィールドを持っていた場合、それらのヘッダーフィールドはACKに現れなければなりません。これは、ACKは、任意の下流ステートレスプロキシを介して適切にルーティングすることができるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Although any request MAY contain a body, a body in an ACK is special since the request cannot be rejected if the body is not understood. Therefore, placement of bodies in ACK for non-2xx is NOT RECOMMENDED, but if done, the body types are restricted to any that appeared in the INVITE, assuming that the response to the INVITE was not 415. If it was, the body in the ACK MAY be any type listed in the Accept header field in the 415.",
      "ja": "すべての要求は、体が含まれているかもしれないが、本体が理解されていない場合は、要求を拒否することができないため、ACKで体が特別です。したがって、非2xxのためのACKにおける物体の配置は推奨されませんが、行われた場合、ボディタイプは、それが、ボディだった場合、INVITEに対する応答が415でなかったと仮定して、INVITEに登場し、そのいずれかに限定されていますACKは、415でAcceptヘッダーフィールドにリストされた任意の型であってもよいです。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following request:",
      "ja": "たとえば、次の要求を考慮してください。"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKkjshdyff To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=88sja8x Max-Forwards: 70 Call-ID: 987asjd97y7atg CSeq: 986759 INVITE",
      "ja": "ボブ<SIP：bob@biloxi.com>から：アリス<SIP：alice@atlanta.com;：bob@biloxi.com SIP / 2.0経由：ブランチ= z9hG4bKkjshdyffにSIP / 2.0 / UDP pc33.atlanta.com SIPのINVITE >;タグ= 88sja8x最大フォワード：70のCall-ID：987asjd97y7atgのCSeq：986759 INVITEを"
    },
    {
      "indent": 3,
      "text": "The ACK request for a non-2xx final response to this request would look like this:",
      "ja": "このリクエストへの非2xxの最終応答に対するACKリクエストは、次のようになります。"
    },
    {
      "indent": 3,
      "text": "ACK sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKkjshdyff To: Bob <sip:bob@biloxi.com>;tag=99sa0xk From: Alice <sip:alice@atlanta.com>;tag=88sja8x Max-Forwards: 70 Call-ID: 987asjd97y7atg CSeq: 986759 ACK",
      "ja": "ACKのSIP：bob@biloxi.com SIP / 2.0経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKkjshdyffへ：ボブ<SIP：bob@biloxi.com>;タグ= 99sa0xkから：アリス<SIP：アリス@ atlanta.com>;タグ= 88sja8xマックス・フォワード：70のCall-ID：987asjd97y7atgのCSeq：986759 ACK"
    },
    {
      "indent": 0,
      "text": "17.1.2 Non-INVITE Client Transaction",
      "section_title": true,
      "ja": "17.1.2非INVITEクライアントトランザクション"
    },
    {
      "indent": 0,
      "text": "17.1.2.1 Overview of the non-INVITE Transaction",
      "section_title": true,
      "ja": "非INVITEトランザクションの17.1.2.1概要"
    },
    {
      "indent": 3,
      "text": "Non-INVITE transactions do not make use of ACK. They are simple request-response interactions. For unreliable transports, requests are retransmitted at an interval which starts at T1 and doubles until it hits T2. If a provisional response is received, retransmissions continue for unreliable transports, but at an interval of T2. The server transaction retransmits the last response it sent, which can be a provisional or final response, only when a retransmission of the request is received. This is why request retransmissions need to continue even after a provisional response; they are to ensure reliable delivery of the final response.",
      "ja": "非INVITEトランザクションはACKを使用しません。彼らは、単純な要求・応答の相互作用です。信頼性の低いトランスポートのために、要求がT1から始まり、それがT2に達するまで倍増間隔で再送信されます。暫定応答を受信した場合、再送信は、信頼性の低いトランスポートのために続けますが、T2の間隔で。サーバートランザクションは、要求の再送信が受信されるだけ仮または最終応答することができる、それは送信された最後の応答を再送信します。要求の再送信も暫定応答後も継続する必要があるのはこのためです。彼らは、最終的な応答の信頼性の高い配信を確実にするためです。"
    },
    {
      "indent": 3,
      "text": "Unlike an INVITE transaction, a non-INVITE transaction has no special handling for the 2xx response. The result is that only a single 2xx response to a non-INVITE is ever delivered to a UAC.",
      "ja": "INVITEトランザクションとは異なり、非INVITEトランザクションは2xx応答のための特別な取り扱いがありません。その結果、非INVITEにのみ単一の2xx応答がこれまでにUACに配信されていることです。"
    },
    {
      "indent": 0,
      "text": "17.1.2.2 Formal Description",
      "section_title": true,
      "ja": "17.1.2.2形式記述"
    },
    {
      "indent": 3,
      "text": "The state machine for the non-INVITE client transaction is shown in Figure 6. It is very similar to the state machine for INVITE.",
      "ja": "非INVITEクライアントトランザクションのためのステートマシンは、それがINVITEのためのステートマシンに非常に似て、図6に示します。"
    },
    {
      "indent": 3,
      "text": "The \"Trying\" state is entered when the TU initiates a new client transaction with a request. When entering this state, the client transaction SHOULD set timer F to fire in 64*T1 seconds. The request MUST be passed to the transport layer for transmission. If an unreliable transport is in use, the client transaction MUST set timer E to fire in T1 seconds. If timer E fires while still in this state, the timer is reset, but this time with a value of MIN(2*T1, T2). When the timer fires again, it is reset to a MIN(4*T1, T2). This process continues so that retransmissions occur with an exponentially increasing interval that caps at T2. The default value of T2 is 4s, and it represents the amount of time a non-INVITE server transaction will take to respond to a request, if it does not respond immediately. For the default values of T1 and T2, this results in intervals of 500 ms, 1 s, 2 s, 4 s, 4 s, 4 s, etc.",
      "ja": "TUがリクエストで新規クライアントトランザクションを開始したときに「試みる」状態が入力されます。この状態に入ると、クライアント・トランザクションは64 * T1秒で起動するようにタイマーFを設定する必要があります。要求は、送信のためのトランスポート層に渡さなければなりません。信頼性のないトランスポートが使用されている場合、クライアントトランザクションは、T1秒で起動するようにタイマーEを設定しなければなりません。もしタイマE火災まだこの状態では、タイマーはリセットされるが、この時間MINの値（2 * T1、T2）を有します。タイマ起動は再び、それがMIN（4 * T1、T2）にリセットされます。再送がT2でキャップ指数関数的に増加する間隔で発生するように、このプロセスは継続します。 T2のデフォルト値は4秒であり、それは非INVITEサーバートランザクションは、それがすぐに応答しない場合、要求に応答するのにかかる時間の量を表します。 T1とT2のデフォルト値については、これは等500ミリ秒、1秒、2秒、4秒、4秒、4秒の間隔で生じます"
    },
    {
      "indent": 3,
      "text": "If Timer F fires while the client transaction is still in the \"Trying\" state, the client transaction SHOULD inform the TU about the timeout, and then it SHOULD enter the \"Terminated\" state. If a provisional response is received while in the \"Trying\" state, the response MUST be passed to the TU, and then the client transaction SHOULD move to the \"Proceeding\" state. If a final response (status codes 200-699) is received while in the \"Trying\" state, the response MUST be passed to the TU, and the client transaction MUST transition to the \"Completed\" state.",
      "ja": "もし、タイマF火災クライアントトランザクションが「しよう」状態にある一方で、クライアントトランザクションがタイムアウトについてTUに通知するべきであり、それは「終端」状態を入力する必要があります。暫定応答を「試す」状態の間に受信された場合、応答はTUに通過しなければなりませんし、クライアントトランザクションは「Proceeding」ステートに移動する必要があります。 「試行」状態にある間に最終応答（ステータスコード200から699）を受信した場合、応答はTUに渡されなければならない、そしてクライアントトランザクションは「完了」状態に移行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If Timer E fires while in the \"Proceeding\" state, the request MUST be passed to the transport layer for retransmission, and Timer E MUST be reset with a value of T2 seconds. If timer F fires while in the \"Proceeding\" state, the TU MUST be informed of a timeout, and the client transaction MUST transition to the terminated state. If a final response (status codes 200-699) is received while in the \"Proceeding\" state, the response MUST be passed to the TU, and the client transaction MUST transition to the \"Completed\" state.",
      "ja": "「Proceeding」ステートにある間にタイマーE火災場合、要求は、再送信のためのトランスポート層に渡さなければならない、そしてタイマEは、T2秒の値にリセットされなければなりません。 「Proceeding」ステートにある間にタイマーFが発火した場合、TUはタイムアウトを通知しなければならない、とクライアントのトランザクションが終了状態に移行しなければなりません。 「Proceeding」ステートにおいて、応答はTUに渡されなければならないが、最終的な応答（ステータスコード200から699）が受信され、クライアントトランザクションは「完了」状態に移行しなければならない場合。"
    },
    {
      "indent": 3,
      "text": "Once the client transaction enters the \"Completed\" state, it MUST set Timer K to fire in T4 seconds for unreliable transports, and zero seconds for reliable transports. The \"Completed\" state exists to buffer any additional response retransmissions that may be received (which is why the client transaction remains there only for unreliable transports). T4 represents the amount of time the network will take to clear messages between client and server transactions. The default value of T4 is 5s. A response is a retransmission when it matches the same transaction, using the rules specified in Section 17.1.3. If Timer K fires while in this state, the client transaction MUST transition to the \"Terminated\" state.",
      "ja": "クライアントトランザクションが「Completed」ステートに入ると、それは信頼性のないトランスポート用T4秒で起動するようにタイマーKを設定し、かつ信頼性の高いトランスポートの0秒しなければなりません。 「完了」状態は、（クライアントトランザクションは、信頼性の低いトランスポートのみが残る理由である）を受信することができる任意の追加の応答の再送信をバッファリングするために存在します。 T4は、ネットワークが、クライアントとサーバーのトランザクション間のメッセージをクリアするのにかかる時間の量を表します。 T4のデフォルト値は5秒です。それは、セクション17.1.3で指定されたルールを使用して、同じトランザクションと一致したときに応答が再送信です。この状態の間にタイマーK火災た場合、クライアントトランザクションは「終端」状態に移行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the transaction is in the terminated state, it MUST be destroyed immediately.",
      "ja": "トランザクションが終了した状態になると、それはすぐに破棄されなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.1.3 Matching Responses to Client Transactions",
      "section_title": true,
      "ja": "顧客取引に17.1.3のマッチングの対応"
    },
    {
      "indent": 3,
      "text": "When the transport layer in the client receives a response, it has to determine which client transaction will handle the response, so that the processing of Sections 17.1.1 and 17.1.2 can take place. The branch parameter in the top Via header field is used for this purpose. A response matches a client transaction under two conditions:",
      "ja": "クライアントでのトランスポート層は、応答を受信すると、セクション17.1.1と17.1.2の処理を行うことができるように、応答を処理するどのクライアントトランザクションを決定しなければなりません。最初のViaヘッダーフィールドにおける分岐パラメータは、この目的のために使用されます。応答は、次の2つの条件の下でクライアントトランザクションと一致します。"
    },
    {
      "indent": 6,
      "text": "1. If the response has the same value of the branch parameter in the top Via header field as the branch parameter in the top Via header field of the request that created the transaction.",
      "ja": "1.応答は、トランザクションを作成したリクエストの最初のViaヘッダーフィールドにおける分岐パラメータとして最初のViaヘッダーフィールドにおける分岐パラメータの同じ値を持っている場合。"
    },
    {
      "indent": 6,
      "text": "2. If the method parameter in the CSeq header field matches the method of the request that created the transaction. The method is needed since a CANCEL request constitutes a different transaction, but shares the same value of the branch parameter.",
      "ja": "2. CSeqヘッダーフィールドのメソッドパラメータは、トランザクションを作成し、要求の方法と一致した場合。 CANCELリクエストが別のトランザクションを構成しているが、分岐パラメータの同じ値を共有するので、この方法が必要とされています。"
    },
    {
      "indent": 3,
      "text": "If a request is sent via multicast, it is possible that it will generate multiple responses from different servers. These responses will all have the same branch parameter in the topmost Via, but vary in the To tag. The first response received, based on the rules above, will be used, and others will be viewed as retransmissions. That is not an error; multicast SIP provides only a rudimentary \"single-hop-discovery-like\" service that is limited to processing a single response. See Section 18.1.1 for details.",
      "ja": "要求は、マルチキャストを経由して送信された場合、別のサーバーから複数の応答を生成することが可能です。これらの応答は、すべての最上位ヴィア同じブランチパラメータを持っていますが、タグに変化します。上記のルールに基づいて、受信した最初の応答は、使用され、そして他のものは再送信として見られるであろう。これはエラーではありません。マルチキャストSIPは、単一の応答を処理することに限定されるだけ初歩的な「単一ホップ発見のような」サービスを提供します。詳細は項18.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "17.1.4 Handling Transport Errors",
      "section_title": true,
      "ja": "トランスポートエラー処理17.1.4"
    },
    {
      "indent": 9,
      "text": "                          |Request from TU\n                          |send request\n      Timer E             V\n      send request  +-----------+\n          +---------|           |-------------------+\n          |         |  Trying   |  Timer F          |\n          +-------->|           |  or Transport Err.|\n                    +-----------+  inform TU        |\n       200-699         |  |                         |\n       resp. to TU     |  |1xx                      |\n       +---------------+  |resp. to TU              |\n       |                  |                         |\n       |   Timer E        V       Timer F           |\n       |   send req +-----------+ or Transport Err. |\n       |  +---------|           | inform TU         |\n       |  |         |Proceeding |------------------>|\n       |  +-------->|           |-----+             |\n       |            +-----------+     |1xx          |\n       |              |      ^        |resp to TU   |\n       | 200-699      |      +--------+             |\n       | resp. to TU  |                             |\n       |              |                             |\n       |              V                             |\n       |            +-----------+                   |\n       |            |           |                   |\n       |            | Completed |                   |\n       |            |           |                   |\n       |            +-----------+                   |\n       |              ^   |                         |\n       |              |   | Timer K                 |\n       +--------------+   | -                       |\n                          |                         |\n                          V                         |\n    NOTE:           +-----------+                   |\n                    |           |                   |\ntransitions         | Terminated|<------------------+\nlabeled with        |           |\nthe event           +-----------+\nover the action\nto take",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 6: non-INVITE client transaction",
      "ja": "図6：非INVITEクライアントトランザクション"
    },
    {
      "indent": 3,
      "text": "When the client transaction sends a request to the transport layer to be sent, the following procedures are followed if the transport layer indicates a failure.",
      "ja": "クライアントトランザクションを送信するトランスポート層に要求を送信すると、トランスポート層は失敗を示している場合、以下の手順に従います。"
    },
    {
      "indent": 3,
      "text": "The client transaction SHOULD inform the TU that a transport failure has occurred, and the client transaction SHOULD transition directly to the \"Terminated\" state. The TU will handle the failover mechanisms described in [4].",
      "ja": "クライアントトランザクションは、輸送障害が発生したことをTUに通知するべきであり、クライアントトランザクションは「終端」状態に直接遷移すべき。 TUは、[4]に記載のフェイルオーバー機構を処理します。"
    },
    {
      "indent": 0,
      "text": "17.2 Server Transaction",
      "section_title": true,
      "ja": "17.2 Serverトランザクション"
    },
    {
      "indent": 3,
      "text": "The server transaction is responsible for the delivery of requests to the TU and the reliable transmission of responses. It accomplishes this through a state machine. Server transactions are created by the core when a request is received, and transaction handling is desired for that request (this is not always the case).",
      "ja": "サーバートランザクションは、TUと応答の信頼性の高い伝送への要求の配信を担当しています。これは、ステートマシンを介してこれを実現しています。 （これは必ずしもそうではありません）要求を受信したときにサーバーのトランザクションは、コアによって作成され、トランザクション処理がその要求のために望まれています。"
    },
    {
      "indent": 3,
      "text": "As with the client transactions, the state machine depends on whether the received request is an INVITE request.",
      "ja": "クライアントの取引と同様に、ステートマシンは、受信した要求がINVITEリクエストであるかどうかに依存します。"
    },
    {
      "indent": 0,
      "text": "17.2.1 INVITE Server Transaction",
      "section_title": true,
      "ja": "17.2.1 ServerトランザクションをINVITE"
    },
    {
      "indent": 3,
      "text": "The state diagram for the INVITE server transaction is shown in Figure 7.",
      "ja": "INVITEサーバートランザクションの状態図は、図7に示されています。"
    },
    {
      "indent": 3,
      "text": "When a server transaction is constructed for a request, it enters the \"Proceeding\" state. The server transaction MUST generate a 100 (Trying) response unless it knows that the TU will generate a provisional or final response within 200 ms, in which case it MAY generate a 100 (Trying) response. This provisional response is needed to quench request retransmissions rapidly in order to avoid network congestion. The 100 (Trying) response is constructed according to the procedures in Section 8.2.6, except that the insertion of tags in the To header field of the response (when none was present in the request) is downgraded from MAY to SHOULD NOT. The request MUST be passed to the TU.",
      "ja": "サーバートランザクションは、要求のために構築されている場合、それは「Proceeding」ステートに入ります。それはTUが、それは100（試行）応答を生成し得る場合には200ミリ秒以内に暫定的又は最終的な応答を生成することを知っている場合を除き、サーバートランザクションは100（試行）応答を生成しなければなりません。この暫定応答は、ネットワークの輻輳を回避するために、急速に要求の再送信をクエンチするために必要とされます。 100（試行）応答は、（いずれも要求に存在しない）応答のToヘッダーフィールド内のタグの挿入はMAYからべきではないにダウングレードされることを除いて、セクション8.2.6の手順に従って構成されています。リクエストはTUに通過しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The TU passes any number of provisional responses to the server transaction. So long as the server transaction is in the \"Proceeding\" state, each of these MUST be passed to the transport layer for transmission. They are not sent reliably by the transaction layer (they are not retransmitted by it) and do not cause a change in the state of the server transaction. If a request retransmission is received while in the \"Proceeding\" state, the most recent provisional response that was received from the TU MUST be passed to the transport layer for retransmission. A request is a retransmission if it matches the same server transaction based on the rules of Section 17.2.3.",
      "ja": "TUがサーバートランザクションに暫定応答の任意の数を渡します。だから、長いサーバートランザクションは「Proceeding」ステートにあるように、これらのそれぞれは、送信用のトランスポート層に通過しなければなりません。これらは、トランザクション層（彼らはそれによって再送されていない）によって確実に送信されていないと、サーバーのトランザクションの状態の変化を引き起こしません。 「Proceeding」ステートにある間にリクエストの再送を受信した場合、TUから受け取った最新の暫定応答は、再送信のためのトランスポート層に通過しなければなりません。それは、セクション17.2.3のルールに基づいて、同じサーバートランザクションに一致する場合、要求は再送信です。"
    },
    {
      "indent": 3,
      "text": "If, while in the \"Proceeding\" state, the TU passes a 2xx response to the server transaction, the server transaction MUST pass this response to the transport layer for transmission. It is not retransmitted by the server transaction; retransmissions of 2xx responses are handled by the TU. The server transaction MUST then transition to the \"Terminated\" state.",
      "ja": "「Proceeding」ステートに、TUがサーバートランザクションに2xx応答を通過しながら、場合、サーバートランザクションは、送信のためのトランスポート層にこの応答を渡さなければなりません。これは、サーバーのトランザクションによって再送信されません。 2xx応答の再送はTUによって処理されます。サーバートランザクションは、「終端」状態に移行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "While in the \"Proceeding\" state, if the TU passes a response with status code from 300 to 699 to the server transaction, the response MUST be passed to the transport layer for transmission, and the state machine MUST enter the \"Completed\" state. For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for reliable transports.",
      "ja": "「Proceeding」ステートにある間TUがサーバートランザクションに300から699までのステータスコードで応答を渡す場合、応答は、送信のためのトランスポート層に渡さなければならない、と状態マシンは「完了」状態を入力する必要があります。信頼性の低いトランスポートのために、タイマーGは、T1秒で起動するように設定され、かつ信頼性の高いトランスポートのために起動するように設定されていません。"
    },
    {
      "indent": 6,
      "text": "This is a change from RFC 2543, where responses were always retransmitted, even over reliable transports.",
      "ja": "これは、応答があっても、常に信頼性の高いトランスポート上で、再送信されたRFC 2543から変更されています。"
    },
    {
      "indent": 3,
      "text": "When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports. Timer H determines when the server transaction abandons retransmitting the response. Its value is chosen to equal Timer B, the amount of time a client transaction will continue to retry sending a request. If timer G fires, the response is passed to the transport layer once more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on, when timer G fires, the response is passed to the transport again for transmission, and timer G is reset with a value that doubles, unless that value exceeds T2, in which case it is reset with the value of T2. This is identical to the retransmit behavior for requests in the \"Trying\" state of the non-INVITE client transaction. Furthermore, while in the \"Completed\" state, if a request retransmission is received, the server SHOULD pass the response to the transport for retransmission.",
      "ja": "「完了」状態に入ると、タイマーHは、すべてのトランスポートのための64 * T1秒で起動するように設定しなければなりません。サーバートランザクションが応答を再送放棄したときにタイマーHが決定されます。その値が等しいタイマーBに選択され、時間の量は、クライアントトランザクションは、要求の送信を再試行していきます。タイマGが発火した場合、応答は、再送信のために一回以上のトランスポート層に渡され、タイマGはMIN（2 * T1、T2）秒で起動するように設定されています。それ以降、タイマG火災、応答を送信するために再び輸送に渡され、タイマGは、それがT2の値がリセットされる場合にはその値がT2を超えない限り、二倍の値でリセットされます。これは、非INVITEクライアントトランザクションの「試す」状態の要求の再送信動作と同じです。要求の再送が受信された場合また、「完了」状態にある間に、サーバは、再送のための交通機関への応答を通過させなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an ACK is received while the server transaction is in the \"Completed\" state, the server transaction MUST transition to the \"Confirmed\" state. As Timer G is ignored in this state, any retransmissions of the response will cease.",
      "ja": "サーバートランザクションは「完了」状態にあるときにACKを受信した場合、サーバートランザクションは「確認済み」状態に移行しなければなりません。タイマGは、この状態では無視されたように、応答のいずれかの再送信が中止されます。"
    },
    {
      "indent": 3,
      "text": "If timer H fires while in the \"Completed\" state, it implies that the ACK was never received. In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST indicate to the TU that a transaction failure has occurred.",
      "ja": "「完了」状態にある間にタイマーHが発火した場合、それはACKが受信されなかったことを意味します。この場合、サーバートランザクションは「終端」状態に移行しなければならない、とトランザクション障害が発生したことをTUに示す必要があります。"
    },
    {
      "indent": 12,
      "text": "                   |INVITE\n                   |pass INV to TU\nINVITE             V send 100 if TU won't in 200ms\nsend response+-----------+\n    +--------|           |--------+101-199 from TU\n    |        | Proceeding|        |send response\n    +------->|           |<-------+\n             |           |          Transport Err.\n             |           |          Inform TU\n             |           |--------------->+\n             +-----------+                |\n300-699 from TU |     |2xx from TU        |\nsend response   |     |send response      |\n                |     +------------------>+\n                |                         |\nINVITE          V          Timer G fires  |\nsend response+-----------+ send response  |\n    +--------|           |--------+       |\n    |        | Completed |        |       |\n    +------->|           |<-------+       |\n             +-----------+                |\n                |     |                   |\n            ACK |     |                   |\n            -   |     +------------------>+\n                |        Timer H fires    |\n                V        or Transport Err.|\n             +-----------+  Inform TU     |\n             |           |                |\n             | Confirmed |                |\n             |           |                |\n             +-----------+                |\n                   |                      |\n                   |Timer I fires         |\n                   |-                     |\n                   |                      |\n                   V                      |\n             +-----------+                |\n             |           |                |\n             | Terminated|<---------------+\n             |           |\n             +-----------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 7: INVITE server transaction",
      "ja": "図7：サーバーのINVITEトランザクション"
    },
    {
      "indent": 3,
      "text": "The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive, triggered from retransmissions of the final response. When this state is entered, timer I is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.",
      "ja": "「確認済み」状態の目的は、最終的な応答の再送信からトリガ到着、追加のACKメッセージを吸収することです。この状態に入ると、タイマーIは、信頼性の低いトランスポート用のT4秒で起動するように設定、および信頼性の高いトランスポートの0秒です。タイマーI火災たら、サーバは「終端」状態に移行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately. As with client transactions, this is needed to ensure reliability of the 2xx responses to INVITE.",
      "ja": "トランザクションは「終端」状態になると、それはすぐに破棄されなければなりません。クライアントの取引と同じように、これはINVITEに対する2xx応答の信頼性を確保するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "17.2.2 Non-INVITE Server Transaction",
      "section_title": true,
      "ja": "17.2.2非INVITEサーバートランザクション"
    },
    {
      "indent": 3,
      "text": "The state machine for the non-INVITE server transaction is shown in Figure 8.",
      "ja": "非INVITEサーバートランザクションのためのステートマシンは、図8に示します。"
    },
    {
      "indent": 3,
      "text": "The state machine is initialized in the \"Trying\" state and is passed a request other than INVITE or ACK when initialized. This request is passed up to the TU. Once in the \"Trying\" state, any further request retransmissions are discarded. A request is a retransmission if it matches the same server transaction, using the rules specified in Section 17.2.3.",
      "ja": "ステートマシンは、「しよう」状態に初期化され、初期化時に、INVITEまたはACK以外の要求を渡されます。この要求はTUに渡されます。かつて「しよう」の状態で、それ以上の要求の再送信は破棄されます。それは、セクション17.2.3で指定されたルールを使用して、同じサーバートランザクションに一致する場合、要求は再送信です。"
    },
    {
      "indent": 3,
      "text": "While in the \"Trying\" state, if the TU passes a provisional response to the server transaction, the server transaction MUST enter the \"Proceeding\" state. The response MUST be passed to the transport layer for transmission. Any further provisional responses that are received from the TU while in the \"Proceeding\" state MUST be passed to the transport layer for transmission. If a retransmission of the request is received while in the \"Proceeding\" state, the most recently sent provisional response MUST be passed to the transport layer for retransmission. If the TU passes a final response (status codes 200-699) to the server while in the \"Proceeding\" state, the transaction MUST enter the \"Completed\" state, and the response MUST be passed to the transport layer for transmission.",
      "ja": "「試みる」状態にある間TUがサーバートランザクションに暫定応答を渡す場合、サーバートランザクションは「Proceeding」ステートを入力する必要があります。応答は、送信のためのトランスポート層に渡さなければなりません。 「Proceeding」ステートに送信するためのトランスポート層に渡さなければならないがTUから受信される任意のさらなる暫定応答。要求の再送信は「Proceeding」ステートにある間に受信されている場合は、最も最近に送信された暫定応答は、再送信のためのトランスポート層に通過しなければなりません。 TUは「Proceeding」ステートに、トランザクションは「完了」状態を入力する必要があり、その応答は、送信のためのトランスポート層に渡さなければならないが、サーバへの最終応答（ステータスコード200から699）を通過した場合。"
    },
    {
      "indent": 3,
      "text": "When the server transaction enters the \"Completed\" state, it MUST set Timer J to fire in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports. While in the \"Completed\" state, the server transaction MUST pass the final response to the transport layer for retransmission whenever a retransmission of the request is received. Any other final responses passed by the TU to the server transaction MUST be discarded while in the \"Completed\" state. The server transaction remains in this state until Timer J fires, at which point it MUST transition to the \"Terminated\" state.",
      "ja": "サーバートランザクションは「完了」状態になると、それはタイマーJは信頼性の低いトランスポートの64 * T1秒、および信頼性の高いトランスポートの0秒で起動するように設定しなければなりません。 「完了」状態にある間に要求の再送信を受信するたびに、サーバートランザクションは、再送信のためのトランスポート層への最終応答を渡さなければなりません。 「完了」状態の間、サーバーのトランザクションにTUによって渡された任意の他の最終応答を捨てなければなりません。サーバートランザクションは、それが「終端」状態に遷移する必要があり、その時点でタイマーJ火災、までこの状態のままになります。"
    },
    {
      "indent": 3,
      "text": "The server transaction MUST be destroyed the instant it enters the \"Terminated\" state.",
      "ja": "サーバートランザクションは、それが「終端」状態に入る瞬間を破壊しなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.2.3 Matching Requests to Server Transactions",
      "section_title": true,
      "ja": "17.2.3 Serverトランザクションへの要求をマッチング"
    },
    {
      "indent": 3,
      "text": "When a request is received from the network by the server, it has to be matched to an existing transaction. This is accomplished in the following manner.",
      "ja": "要求がサーバによってネットワークから受信されると、それは既存のトランザクションにマッチする必要があります。これは、次のようにして行われます。"
    },
    {
      "indent": 3,
      "text": "The branch parameter in the topmost Via header field of the request is examined. If it is present and begins with the magic cookie \"z9hG4bK\", the request was generated by a client transaction compliant to this specification. Therefore, the branch parameter will be unique across all transactions sent by that client. The request matches a transaction if:",
      "ja": "リクエストの最上位Viaヘッダーフィールドにおける分岐パラメータが検討されています。それが存在し、マジッククッキー「z9hG4bK」で始まる場合、要求はこの仕様に準拠したクライアントトランザクションによって生成されました。したがって、分岐パラメータは、クライアントから送信されたすべてのトランザクション全体で一意になります。要求があれば、トランザクションを一致します。"
    },
    {
      "indent": 6,
      "text": "1. the branch parameter in the request is equal to the one in the top Via header field of the request that created the transaction, and",
      "ja": "1.リクエスト中の分岐パラメータは、トランザクションを作成したリクエストの最初のViaヘッダーフィールドの1に等しく、"
    },
    {
      "indent": 6,
      "text": "2. the sent-by value in the top Via of the request is equal to the one in the request that created the transaction, and",
      "ja": "2.送信され-によって要求のトップ経由での値のトランザクションを作成した要求の1に等しく、"
    },
    {
      "indent": 6,
      "text": "3. the method of the request matches the one that created the transaction, except for ACK, where the method of the request that created the transaction is INVITE.",
      "ja": "3.リクエストのメソッドは、トランザクションを作成したリクエストのメソッドがINVITEであるACKを除き、トランザクションを作成したものと一致しました。"
    },
    {
      "indent": 3,
      "text": "This matching rule applies to both INVITE and non-INVITE transactions alike.",
      "ja": "このマッチングルールを問わず、INVITEと非INVITE取引の両方に適用されます。"
    },
    {
      "indent": 6,
      "text": "The sent-by value is used as part of the matching process because there could be accidental or malicious duplication of branch parameters from different clients.",
      "ja": "異なるクライアントからの分岐パラメータの偶発的または悪質な重複があるかもしれませんので、送られたバイ値はマッチング処理の一部として使用されます。"
    },
    {
      "indent": 3,
      "text": "If the branch parameter in the top Via header field is not present, or does not contain the magic cookie, the following procedures are used. These exist to handle backwards compatibility with RFC 2543 compliant implementations.",
      "ja": "最初のViaヘッダーフィールドにおける分岐パラメータが存在しない、またはマジッククッキーが含まれていない場合は、以下の手順が使用されています。これらは、RFC 2543準拠の実装との下位互換性を処理するために存在します。"
    },
    {
      "indent": 3,
      "text": "The INVITE request matches a transaction if the Request-URI, To tag, From tag, Call-ID, CSeq, and top Via header field match those of the INVITE request which created the transaction. In this case, the INVITE is a retransmission of the original one that created the transaction. The ACK request matches a transaction if the Request-URI, From tag, Call-ID, CSeq number (not the method), and top Via header field match those of the INVITE request which created the transaction, and the To tag of the ACK matches the To tag of the response sent by the server transaction. Matching is done based on the matching rules defined for each of those header fields. Inclusion of the tag in the To header field in the ACK matching process helps disambiguate ACK for 2xx from ACK for other responses at a proxy, which may have forwarded both responses (This can occur in unusual conditions. Specifically, when a proxy forked a request, and then crashes, the responses may be delivered to another proxy, which might end up forwarding multiple responses upstream). An ACK request that matches an INVITE transaction matched by a previous ACK is considered a retransmission of that previous ACK.",
      "ja": "要求URIあればINVITEリクエストは、トランザクションを作成したINVITEリクエストのものと一致するViaヘッダーフィールド、のCSeq、およびトップ-IDを呼び出し、タグから、タグ付けするには、トランザクションと一致します。この場合、INVITEトランザクションを作成したオリジナルのものの再送信です。 ACK要求は、Request-URI場合ヘッダーフィールドマッチを介してトランザクションを作成したINVITEリクエストのもの、のCSeq番号（ない方法）、及びトップ-IDを呼び出し、タグから、トランザクションに一致し、そしてACKタグにはサーバーのトランザクションによって送信された応答のにタグが一致します。マッチングは、それらのヘッダフィールドのそれぞれに対して定義されたマッチングルールに基づいて行われます。 ACKマッチング処理におけるヘッダのフィールドにタグを含めることは、両方の応答（これは異常な状況で発生する可能性が転送している場合があり、プロキシにおける他の応答のためのACKからの2xxに対するACKを明確に役立つ。具体的には、プロキシはリクエストをフォークしたとき、次いでクラッシュ、応答は、上流複数の応答を転送し終わるかもしれない別のプロキシ）に送達することができます。以前のACKにマッチしたINVITEトランザクションにマッチするACKリクエストはその前のACKの再送信と考えられています。"
    },
    {
      "indent": 12,
      "text": "                      |Request received\n                      |pass to TU\n                      V\n                +-----------+\n                |           |\n                | Trying    |-------------+\n                |           |             |\n                +-----------+             |200-699 from TU\n                      |                   |send response\n                      |1xx from TU        |\n                      |send response      |\n                      |                   |\n   Request            V      1xx from TU  |\n   send response+-----------+send response|\n       +--------|           |--------+    |\n       |        | Proceeding|        |    |\n       +------->|           |<-------+    |\n+<--------------|           |             |\n|Trnsprt Err    +-----------+             |\n|Inform TU            |                   |\n|                     |                   |\n|                     |200-699 from TU    |\n|                     |send response      |\n|  Request            V                   |\n|  send response+-----------+             |\n|      +--------|           |             |\n|      |        | Completed |<------------+\n|      +------->|           |\n+<--------------|           |\n|Trnsprt Err    +-----------+\n|Inform TU            |\n|                     |Timer J fires\n|                     |-\n|                     |\n|                     V\n|               +-----------+\n|               |           |\n+-------------->| Terminated|\n                |           |\n                +-----------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 8: non-INVITE server transaction",
      "ja": "図8：非INVITEサーバートランザクション"
    },
    {
      "indent": 3,
      "text": "For all other request methods, a request is matched to a transaction if the Request-URI, To tag, From tag, Call-ID, CSeq (including the method), and top Via header field match those of the request that created the transaction. Matching is done based on the matching rules defined for each of those header fields. When a non-INVITE request matches an existing transaction, it is a retransmission of the request that created that transaction.",
      "ja": "リクエストURI場合、他のすべてのリクエストメソッドのために、要求はタグから、タグには、トランザクションに整合され、コールID、（メソッドを含む）のCSeq、およびトップヘッダーフィールドマッチを介してトランザクションを作成したリクエストのもの。マッチングは、それらのヘッダフィールドのそれぞれに対して定義されたマッチングルールに基づいて行われます。非INVITEリクエストが既存のトランザクションに一致した場合、そのトランザクションを作成した要求の再送信です。"
    },
    {
      "indent": 3,
      "text": "Because the matching rules include the Request-URI, the server cannot match a response to a transaction. When the TU passes a response to the server transaction, it must pass it to the specific server transaction for which the response is targeted.",
      "ja": "マッチングルールが要求URIが含まれているため、サーバは、トランザクションへの応答を一致させることはできません。 TUがサーバートランザクションに応答を通過するとき、それは応答が目標とされている特定のサーバートランザクションに渡す必要があります。"
    },
    {
      "indent": 0,
      "text": "17.2.4 Handling Transport Errors",
      "section_title": true,
      "ja": "トランスポートエラー処理17.2.4"
    },
    {
      "indent": 3,
      "text": "When the server transaction sends a response to the transport layer to be sent, the following procedures are followed if the transport layer indicates a failure.",
      "ja": "サーバートランザクションは、トランスポート層への応答を送信する送信すると、トランスポート層は失敗を示している場合、以下の手順に従わされています。"
    },
    {
      "indent": 3,
      "text": "First, the procedures in [4] are followed, which attempt to deliver the response to a backup. If those should all fail, based on the definition of failure in [4], the server transaction SHOULD inform the TU that a failure has occurred, and SHOULD transition to the terminated state.",
      "ja": "まず、バックアップへの応答を提供しようとする[4]に従っているの手順、。これらはすべて、[4]に、障害の定義に基づいて、失敗した場合、サーバートランザクションは、障害が発生したことをTUに通知するべきであり、終了状態に移行すべきです。"
    },
    {
      "indent": 0,
      "text": "18 Transport",
      "ja": "18交通"
    },
    {
      "indent": 3,
      "text": "The transport layer is responsible for the actual transmission of requests and responses over network transports. This includes determination of the connection to use for a request or response in the case of connection-oriented transports.",
      "ja": "トランスポート層は、ネットワークトランスポート上でリクエストとレスポンスの実際の送信を担当しています。これは、コネクション指向のトランスポートの場合には、要求または応答に使用する接続の決意を含みます。"
    },
    {
      "indent": 3,
      "text": "The transport layer is responsible for managing persistent connections for transport protocols like TCP and SCTP, or TLS over those, including ones opened to the transport layer. This includes connections opened by the client or server transports, so that connections are shared between client and server transport functions. These connections are indexed by the tuple formed from the address, port, and transport protocol at the far end of the connection. When a connection is opened by the transport layer, this index is set to the destination IP, port and transport. When the connection is accepted by the transport layer, this index is set to the source IP address, port number, and transport. Note that, because the source port is often ephemeral, but it cannot be known whether it is ephemeral or selected through procedures in [4], connections accepted by the transport layer will frequently not be reused. The result is that two proxies in a \"peering\" relationship using a connection-oriented transport frequently will have two connections in use, one for transactions initiated in each direction.",
      "ja": "トランスポート層はTCPとSCTP、またはトランスポート層に開かれたものも含めて、これらの、オーバーTLSのようなトランスポートプロトコルのための永続的な接続を管理する責任があります。これは、接続は、クライアントとサーバーのトランスポート機能の間で共有されるように、クライアントやサーバートランスポートによって開かれた接続が含まれています。これらの接続は、接続の遠端のアドレス、ポート、およびトランスポートプロトコルから形成されたタプルによってインデックス付けされます。接続はトランスポート層で開かれると、このインデックスは、宛先IP、ポート、およびトランスポートに設定されています。接続はトランスポート層によって受け付けられると、このインデックスは、ソースIPアドレス、ポート番号、およびトランスポートに設定されています。ソースポートは、しばしば、短命であるので、なお、それは、それが短命又は[4]、トランスポート層に受け入れた接続が頻繁に再使用されないの手順を介して選択されたか否かを知ることはできません。結果が「ピアリング」関係で2つのプロキシは、接続指向のトランスポートを使用することである、頻繁に使用されている2つの接続、各方向に開始されたトランザクションのための1つを有することになります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that connections be kept open for some implementation-defined duration after the last message was sent or received over that connection. This duration SHOULD at least equal the longest amount of time the element would need in order to bring a transaction from instantiation to the terminated state. This is to make it likely that transactions are completed over the same connection on which they are initiated (for example, request, response, and in the case of INVITE, ACK for non-2xx responses). This usually means at least 64*T1 (see Section 17.1.1.1 for a definition of T1). However, it could be larger in an element that has a TU using a large value for timer C (bullet 11 of Section 16.6), for example.",
      "ja": "最後のメッセージがその接続を介して送信または受信された後の接続は、いくつかの実装定義の期間のために開いたままにすることが推奨されます。この期間は、少なくとも要素がインスタンス化から終了状態にトランザクションをもたらすために必要となる時間の最長の量に等しくなければなりません。これは、おそらくトランザクションがそれらが（2xx以外の応答のための例えば、要求、応答、およびINVITEの場合には、ACK）が開始されている同じ接続で完了していることを確認することです。これは通常、少なくとも64 * T1を（T1の定義については、セクション17.1.1.1を参照）を意味します。しかし、例えば、タイマーC（セクション16.6の弾11）のための大きい値を使用して、TUを有する要素に大きくてもよいです。"
    },
    {
      "indent": 3,
      "text": "All SIP elements MUST implement UDP and TCP. SIP elements MAY implement other protocols.",
      "ja": "すべてのSIPエレメントはUDPとTCPを実装しなければなりません。 SIP要素は、他のプロトコルを実装してもよいです。"
    },
    {
      "indent": 6,
      "text": "Making TCP mandatory for the UA is a substantial change from RFC 2543. It has arisen out of the need to handle larger messages, which MUST use TCP, as discussed below. Thus, even if an element never sends large messages, it may receive one and needs to be able to handle them.",
      "ja": "UAのためのTCPが必須作ることはそれは以下に述べるように、TCPを使用しなければならない大きなメッセージを処理する必要性から生じているRFC 2543からの実質的な変化です。このように、要素が大きなメッセージを送信しない場合でも、それは1を受け取り、それらを処理できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.1 Clients",
      "section_title": true,
      "ja": "18.1クライアント"
    },
    {
      "indent": 0,
      "text": "18.1.1 Sending Requests",
      "section_title": true,
      "ja": "18.1.1要求の送信"
    },
    {
      "indent": 3,
      "text": "The client side of the transport layer is responsible for sending the request and receiving responses. The user of the transport layer passes the client transport the request, an IP address, port, transport, and possibly TTL for multicast destinations.",
      "ja": "トランスポート層のクライアント側が要求を送信し、応答を受信する責任があります。トランスポート層の利用者は、マルチキャスト宛先のクライアント移送依頼、IPアドレス、ポート、輸送、そしておそらくTTLを渡します。"
    },
    {
      "indent": 3,
      "text": "If a request is within 200 bytes of the path MTU, or if it is larger than 1300 bytes and the path MTU is unknown, the request MUST be sent using an RFC 2914 [43] congestion controlled transport protocol, such as TCP. If this causes a change in the transport protocol from the one indicated in the top Via, the value in the top Via MUST be changed. This prevents fragmentation of messages over UDP and provides congestion control for larger messages. However, implementations MUST be able to handle messages up to the maximum datagram packet size. For UDP, this size is 65,535 bytes, including IP and UDP headers.",
      "ja": "要求は、パスMTUの200バイトの範囲内である、または1300バイトのMTUが未知であるパスよりも大きい場合、要求は、TCPなどのRFC 2914 [43]輻輳制御トランスポートプロトコルを使用して送信されなければならない。場合これはトップヴィア示すものからトランスポート・プロトコルを変化させる場合、上部を介して値が変更されなければなりません。これは、UDP上でメッセージの断片化を防ぎ、大きなメッセージのための輻輳制御を提供します。しかし、実装は、最大データグラムパケットサイズにメッセージを扱うことができなければなりません。 UDPの場合、このサイズは、IPおよびUDPヘッダを含む65,535バイト、です。"
    },
    {
      "indent": 6,
      "text": "The 200 byte \"buffer\" between the message size and the MTU accommodates the fact that the response in SIP can be larger than the request. This happens due to the addition of Record-Route header field values to the responses to INVITE, for example. With the extra buffer, the response can be about 170 bytes larger than the request, and still not be fragmented on IPv4 (about 30 bytes is consumed by IP/UDP, assuming no IPSec). 1300 is chosen when path MTU is not known, based on the assumption of a 1500 byte Ethernet MTU.",
      "ja": "メッセージサイズとMTUの間で200バイトの「バッファ」はSIPで応答が要求よりも大きくすることができるという事実を収容します。これは、例えば、INVITEに対する応答へのRecord-Routeヘッダフィールド値の加算に起こります。余分な緩衝液を用いて、応答が要求よりも約170バイトを大きくすることができ、さらにはIPv4に断片化されない（約30バイトないIPSecを想定していない、IP / UDPによって消費されます）。パスMTUが1500バイトのイーサネットのMTUの仮定に基づいて、知られていないとき、1300が選択されています。"
    },
    {
      "indent": 3,
      "text": "If an element sends a request over TCP because of these message size constraints, and that request would have otherwise been sent over UDP, if the attempt to establish the connection generates either an ICMP Protocol Not Supported, or results in a TCP reset, the element SHOULD retry the request, using UDP. This is only to provide backwards compatibility with RFC 2543 compliant implementations that do not support TCP. It is anticipated that this behavior will be deprecated in a future revision of this specification.",
      "ja": "要素があるため、これらのメッセージサイズの制約のTCPオーバー要求を送信し、接続を確立しようとする試みは、ICMPプロトコルサポートされていない、またはTCPリセットで結果、要素のいずれかを生成した場合、その要求は、それ以外の場合は、UDP経由で送信されていたであろうあればUDPを使用して、要求を再試行する必要があります。これは、TCPをサポートしていないRFC 2543準拠の実装との後方互換性を提供するだけです。この動作はこの仕様の今後の改正で廃止されることが予想されます。"
    },
    {
      "indent": 3,
      "text": "A client that sends a request to a multicast address MUST add the \"maddr\" parameter to its Via header field value containing the destination multicast address, and for IPv4, SHOULD add the \"ttl\" parameter with a value of 1. Usage of IPv6 multicast is not defined in this specification, and will be a subject of future standardization when the need arises.",
      "ja": "マルチキャストアドレスにリクエストを送信するクライアントは、宛先マルチキャストアドレスを含むそのViaヘッダーフィールド値に「MADDR」パラメータを追加しなければならない、とIPv4のため、IPv6のマルチキャストの1用法の値と「TTL」パラメータを追加すべきですこの仕様で定義されていない、と必要性が生じたとき、将来の標準化の対象となります。"
    },
    {
      "indent": 3,
      "text": "These rules result in a purposeful limitation of multicast in SIP. Its primary function is to provide a \"single-hop-discovery-like\" service, delivering a request to a group of homogeneous servers, where it is only required to process the response from any one of them. This functionality is most useful for registrations. In fact, based on the transaction processing rules in Section 17.1.3, the client transaction will accept the first response, and view any others as retransmissions because they all contain the same Via branch identifier.",
      "ja": "これらのルールは、SIPにおけるマルチキャストの意図的制限をもたらします。その主な機能は、唯一のそれらのいずれかからの応答を処理するために必要とされる均質なサーバーのグループに要求を提供し、「単一ホップ発見のような」サービスを提供することです。この機能は、登録のために最も有用です。実際には、セクション17.1.3でのトランザクション処理のルールに基づいて、クライアントのトランザクションは、最初の応答を受け入れます、そしてそれらはすべて同じ経由のブランチ識別子が含まれているため、再送として他のものを表示します。"
    },
    {
      "indent": 3,
      "text": "Before a request is sent, the client transport MUST insert a value of the \"sent-by\" field into the Via header field. This field contains an IP address or host name, and port. The usage of an FQDN is RECOMMENDED. This field is used for sending responses under certain conditions, described below. If the port is absent, the default value depends on the transport. It is 5060 for UDP, TCP and SCTP, 5061 for TLS.",
      "ja": "リクエストが送信される前に、クライアント・トランスポートはViaヘッダーフィールドに「送られた - で」フィールドの値を挿入しなければなりません。このフィールドには、IPアドレスまたはホスト名、およびポートが含まれています。 FQDNの使用が推奨されます。このフィールドは、以下に説明、一定の条件の下での応答を送信するために使用されます。ポートが存在しない場合、デフォルト値は、トランスポートに依存します。これは、TLSのためのUDP、TCPおよびSCTPのための5060、5061です。"
    },
    {
      "indent": 3,
      "text": "For reliable transports, the response is normally sent on the connection on which the request was received. Therefore, the client transport MUST be prepared to receive the response on the same connection used to send the request. Under error conditions, the server may attempt to open a new connection to send the response. To handle this case, the transport layer MUST also be prepared to receive an incoming connection on the source IP address from which the request was sent and port number in the \"sent-by\" field. It also",
      "ja": "信頼性の高いトランスポートのために、応答は、通常、要求を受信した接続上で送信されます。そのため、クライアントトランスポートはリクエストを送信するために使用したのと同じ接続で応答を受信するために準備しなければなりません。エラー条件の下では、サーバが応答を送信するために新しい接続を開こうとすることがあります。このような場合を処理するために、トランスポート層は、「送信ごとの」フィールドに要求が送信された送信元IPアドレスとポート番号の着信接続を受信する準備をしなければなりません。また"
    },
    {
      "indent": 3,
      "text": "MUST be prepared to receive incoming connections on any address and port that would be selected by a server based on the procedures described in Section 5 of [4].",
      "ja": "[4]のセクション5に記載された手順に基づいて、サーバによって選択される任意のアドレスとポート上の着信接続を受信する準備をしなければなりません。"
    },
    {
      "indent": 3,
      "text": "For unreliable unicast transports, the client transport MUST be prepared to receive responses on the source IP address from which the request is sent (as responses are sent back to the source address) and the port number in the \"sent-by\" field. Furthermore, as with reliable transports, in certain cases the response will be sent elsewhere. The client MUST be prepared to receive responses on any address and port that would be selected by a server based on the procedures described in Section 5 of [4].",
      "ja": "信頼性のないユニキャストトランスポートの場合は、クライアント・トランスポートは、リクエストの送信元IPアドレス（応答が送信元アドレスに戻る送信されるように）「送られた - で」フィールドにポート番号の応答を受信するために準備しなければなりません。また、信頼性の高いトランスポートと同様に、特定の場合には応答が他の場所に送信されます。クライアントは、[4]のセクション5に記載された手順に基づいて、サーバによって選択される任意のアドレスとポートで応答を受信するように準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For multicast, the client transport MUST be prepared to receive responses on the same multicast group and port to which the request is sent (that is, it needs to be a member of the multicast group it sent the request to.)",
      "ja": "マルチキャストのために、クライアント・トランスポート（すなわち、それはそれが要求を送信したマルチキャストグループのメンバーである必要がある。）は、要求が送信された同一のマルチキャストグループとポート上の応答を受信するように準備しなければなりません"
    },
    {
      "indent": 3,
      "text": "If a request is destined to an IP address, port, and transport to which an existing connection is open, it is RECOMMENDED that this connection be used to send the request, but another connection MAY be opened and used.",
      "ja": "リクエストが既存の接続がオープンされているIPアドレス、ポート、およびトランスポートを宛先としている場合は、この接続要求を送信するために使用することを推奨しますが、別の接続がオープンして使用することができます。"
    },
    {
      "indent": 3,
      "text": "If a request is sent using multicast, it is sent to the group address, port, and TTL provided by the transport user. If a request is sent using unicast unreliable transports, it is sent to the IP address and port provided by the transport user.",
      "ja": "要求がマルチキャストを使用して送信される場合は、トランスポート・ユーザによって提供されるグループアドレス、ポート、およびTTLに送られます。要求は、ユニキャスト信頼性の低いトランスポートを使用して送信された場合、それはトランスポートユーザーによって提供されるIPアドレスとポートに送信されます。"
    },
    {
      "indent": 0,
      "text": "18.1.2 Receiving Responses",
      "section_title": true,
      "ja": "18.1.2受信応答"
    },
    {
      "indent": 3,
      "text": "When a response is received, the client transport examines the top Via header field value. If the value of the \"sent-by\" parameter in that header field value does not correspond to a value that the client transport is configured to insert into requests, the response MUST be silently discarded.",
      "ja": "応答が受信されると、クライアント・トランスポートは、ヘッダフィールド値を介してトップを調べます。そのヘッダーフィールド値に「送信ごとの」パラメータの値は、クライアント輸送を要求に挿入するように構成されている値に対応しない場合、応答が静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "If there are any client transactions in existence, the client transport uses the matching procedures of Section 17.1.3 to attempt to match the response to an existing transaction. If there is a match, the response MUST be passed to that transaction. Otherwise, the response MUST be passed to the core (whether it be stateless proxy, stateful proxy, or UA) for further processing. Handling of these \"stray\" responses is dependent on the core (a proxy will forward them, while a UA will discard, for example).",
      "ja": "現存するすべてのクライアント・トランザクションがある場合は、クライアント・トランスポートは、既存のトランザクションへの応答と一致することを試みるために、セクション17.1.3のマッチング手順を使用しています。一致がある場合、応答はそのトランザクションに通過しなければなりません。そうでなければ、応答は、さらなる処理のためにコア（それはステートレスプロキシ、ステートフルプロキシ又はUAであるかどうか）に渡さなければなりません。これらの「迷」応答の取り扱い（UAが破棄されますしながら、プロキシが、たとえば、それらを転送します）コアに依存しています。"
    },
    {
      "indent": 0,
      "text": "18.2 Servers",
      "section_title": true,
      "ja": "18.2サーバー"
    },
    {
      "indent": 0,
      "text": "18.2.1 Receiving Requests",
      "section_title": true,
      "ja": "18.2.1受信要求"
    },
    {
      "indent": 3,
      "text": "A server SHOULD be prepared to receive requests on any IP address, port and transport combination that can be the result of a DNS lookup on a SIP or SIPS URI [4] that is handed out for the purposes of communicating with that server. In this context, \"handing out\" includes placing a URI in a Contact header field in a REGISTER request or a redirect response, or in a Record-Route header field in a request or response. A URI can also be \"handed out\" by placing it on a web page or business card. It is also RECOMMENDED that a server listen for requests on the default SIP ports (5060 for TCP and UDP, 5061 for TLS over TCP) on all public interfaces. The typical exception would be private networks, or when multiple server instances are running on the same host. For any port and interface that a server listens on for UDP, it MUST listen on that same port and interface for TCP. This is because a message may need to be sent using TCP, rather than UDP, if it is too large. As a result, the converse is not true. A server need not listen for UDP on a particular address and port just because it is listening on that same address and port for TCP. There may, of course, be other reasons why a server needs to listen for UDP on a particular address and port.",
      "ja": "サーバは、SIP上のDNSルックアップの結果であり得る、任意のIPアドレス、ポートおよびトランスポートの組み合わせに要求を受信する準備またはURIをSIPSされるべきである[4]そのサーバーとの通信のために配られます。この文脈において、「配る」をREGISTERリクエストまたはリダイレクト応答で、またはRecord-Routeヘッダフィールドに、要求または応答のContactヘッダフィールドにURIを配置することを含みます。 URIは、Webページや名刺にそれを置くことによって「配っ」することができます。また、サーバーがすべてのパブリックインターフェイス上（TCP上のTLSのためのTCPおよびUDP、5061のため5060）デフォルトのSIPポートで要求を聞くことが推奨されます。典型的な例外は、プライベートネットワークとなり、または複数のサーバーインスタンスが同じホスト上で実行されている場合。サーバはUDPを待機する任意のポートおよびインターフェイスの場合は、TCPの場合と同じポートおよびインターフェイス上でリッスンする必要があります。それが大きすぎるメッセージは、UDPではなく、TCPを使用して送信する必要があるかもしれないからです。その結果、逆は真ではありません。サーバは、TCPの場合と同じアドレスとポートで待機しているという理由だけで、特定のアドレスとポートにUDPをリッスンする必要はありません。もちろん、サーバは特定のアドレスとポートにUDPをリッスンする必要がある他の理由があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "When the server transport receives a request over any transport, it MUST examine the value of the \"sent-by\" parameter in the top Via header field value. If the host portion of the \"sent-by\" parameter contains a domain name, or if it contains an IP address that differs from the packet source address, the server MUST add a \"received\" parameter to that Via header field value. This parameter MUST contain the source address from which the packet was received. This is to assist the server transport layer in sending the response, since it must be sent to the source IP address from which the request came.",
      "ja": "サーバートランスポートは任意のトランスポート上の要求を受信すると、ヘッダフィールド値のViaトップで、「送信されたバイ」パラメータの値を調べる必要があります。もしのホスト部「送らバイ」パラメータは、ドメイン名が含まれているか、それがパケットの送信元アドレスと異なったIPアドレスが含まれている場合、サーバは、ヘッダフィールドの値を経由してそれに「受信」パラメータを追加する必要があります。このパラメータは、パケットが受信された送信元アドレスを含まなければなりません。それは、要求が来たソースIPアドレスに送信されなければならないので、これは、応答を送信して、サーバーのトランスポート層を支援することです。"
    },
    {
      "indent": 3,
      "text": "Consider a request received by the server transport which looks like, in part:",
      "ja": "一部では、のように見えるのサーバーのトランスポートで受信した要求を考慮してください。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@Biloxi.com SIP/2.0 Via: SIP/2.0/UDP bobspc.biloxi.com:5060",
      "ja": "SIPのINVITE：bob@Biloxi.com SIP / 2.0経由：SIP / 2.0 / UDP bobspc.biloxi.com:5060"
    },
    {
      "indent": 3,
      "text": "The request is received with a source IP address of 192.0.2.4. Before passing the request up, the transport adds a \"received\" parameter, so that the request would look like, in part:",
      "ja": "リクエストは、192.0.2.4の送信元IPアドレスで受信されます。要求は、部分的に、次のようになりますようにアップ要求を渡す前に、輸送は、「受信」パラメータを追加します。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@Biloxi.com SIP/2.0 Via: SIP/2.0/UDP bobspc.biloxi.com:5060;received=192.0.2.4",
      "ja": "SIPのINVITE：bob@Biloxi.com SIP / 2.0経由：SIP / 2.0 / UDP bobspc.biloxi.com:5060;received=192.0.2.4"
    },
    {
      "indent": 3,
      "text": "Next, the server transport attempts to match the request to a server transaction. It does so using the matching rules described in Section 17.2.3. If a matching server transaction is found, the request is passed to that transaction for processing. If no match is found, the request is passed to the core, which may decide to construct a new server transaction for that request. Note that when a UAS core sends a 2xx response to INVITE, the server transaction is destroyed. This means that when the ACK arrives, there will be no matching server transaction, and based on this rule, the ACK is passed to the UAS core, where it is processed.",
      "ja": "次に、サーバトランスポートはサーバーのトランザクションへの要求を一致させようとします。それはとても、セクション17.2.3で説明したマッチングルールを使用しません。マッチングサーバトランザクションが見つかった場合は、要求が処理のためにそのトランザクションに渡されます。一致が見つからない場合、要求はその要求に対して新しいサーバのトランザクションを構築することを決定してコアに渡されます。 UASコアがINVITEする2xx応答を送信すると、サーバートランザクションが破壊されることに注意してください。これは、ACKが到着すると、一致するサーバーのトランザクションは存在しませんし、このルールに基づいて、ACKは、それが処理されるUASコアに渡されることを意味します。"
    },
    {
      "indent": 0,
      "text": "18.2.2 Sending Responses",
      "section_title": true,
      "ja": "18.2.2送信応答"
    },
    {
      "indent": 3,
      "text": "The server transport uses the value of the top Via header field in order to determine where to send a response. It MUST follow the following process:",
      "ja": "サーバトランスポートは応答を送信するかを決定するために、ヘッダフィールドを介してトップの値を使用します。これは、次のプロセスに従う必要があります。"
    },
    {
      "indent": 6,
      "text": "o If the \"sent-protocol\" is a reliable transport protocol such as TCP or SCTP, or TLS over those, the response MUST be sent using the existing connection to the source of the original request that created the transaction, if that connection is still open. This requires the server transport to maintain an association between server transactions and transport connections. If that connection is no longer open, the server SHOULD open a connection to the IP address in the \"received\" parameter, if present, using the port in the \"sent-by\" value, or the default port for that transport, if no port is specified. If that connection attempt fails, the server SHOULD use the procedures in [4] for servers in order to determine the IP address and port to open the connection and send the response to.",
      "ja": "「送信プロトコル」は、それらの上のTCP又はSCTP、又はTLSなどの信頼性の高いトランスポートプロトコルである場合、その接続がまだある場合、O、応答は、トランザクションを作成した元の要求元への既存の接続を使用して送信されなければなりません開いた。これは、サーバーのトランザクションと交通機関の接続との間の関連性を維持するために、サーバの輸送を必要とします。その接続がもはや開いている場合はノーならば、サーバは、存在する場合、「送信され-で」値、またはそのトランスポートのデフォルトポートにポートを使用して、パラメータを「受信」のIPアドレスへの接続を開くべきではありませんポートが指定されています。その接続に失敗した場合、サーバは接続をオープンしたことに応答を送信するためにIPアドレスとポートを決定するために、サーバのための[4]の手順を使用すべきです。"
    },
    {
      "indent": 6,
      "text": "o Otherwise, if the Via header field value contains a \"maddr\" parameter, the response MUST be forwarded to the address listed there, using the port indicated in \"sent-by\", or port 5060 if none is present. If the address is a multicast address, the response SHOULD be sent using the TTL indicated in the \"ttl\" parameter, or with a TTL of 1 if that parameter is not present.",
      "ja": "Viaヘッダーフィールド値が「MADDR」パラメータを含む場合、Oそうでない場合、応答は、ポートを使用して、そこに記載されているアドレスに転送する必要がいずれも存在しない場合、「送信ごとの」に示されている、またはポート5060。アドレスがマルチキャストアドレスである場合、応答はTTLを使用して送信されるようにパラメータが存在しない場合、「TTL」パラメータで、又は1のTTLで示されます。"
    },
    {
      "indent": 6,
      "text": "o Otherwise (for unreliable unicast transports), if the top Via has a \"received\" parameter, the response MUST be sent to the address in the \"received\" parameter, using the port indicated in the \"sent-by\" value, or using port 5060 if none is specified explicitly. If this fails, for example, elicits an ICMP \"port unreachable\" response, the procedures of Section 5 of [4] SHOULD be used to determine where to send the response.",
      "ja": "トップビアパラメータを「受信」した場合、Oそうでない場合には（信頼性のないユニキャストトランスポートのため）、応答がポートを使用して、パラメータを「受信」のアドレスに送信されなければならない値「が送信済み」、または使用に示されどれも明示的に指定されていない場合は、ポート5060。これが失敗した場合、例えば、ICMP「ポート到達不能」応答を誘発する、[4]の第5章の手順は、ここで応答を送信するかを決定するために使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "o Otherwise, if it is not receiver-tagged, the response MUST be sent to the address indicated by the \"sent-by\" value, using the procedures in Section 5 of [4].",
      "ja": "それは受信機タグをされていない場合、Oそうでない場合、応答は「送信バイ」値、[4]のセクション5の手順を使用して示されたアドレスに送信されなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.3 Framing",
      "section_title": true,
      "ja": "18.3フレーミング"
    },
    {
      "indent": 3,
      "text": "In the case of message-oriented transports (such as UDP), if the message has a Content-Length header field, the message body is assumed to contain that many bytes. If there are additional bytes in the transport packet beyond the end of the body, they MUST be discarded. If the transport packet ends before the end of the message body, this is considered an error. If the message is a response, it MUST be discarded. If the message is a request, the element SHOULD generate a 400 (Bad Request) response. If the message has no Content-Length header field, the message body is assumed to end at the end of the transport packet.",
      "ja": "メッセージは、Content-Lengthヘッダフィールドを持っている場合（例えば、UDPのような）メッセージ指向のトランスポートの場合には、メッセージ本体はそのバイト数を含むものとします。本体の端を越えてトランスポートパケットにおける追加バイトがある場合、それらは捨てなければなりません。トランスポートパケットは、メッセージ本文の終了前に終了した場合、これは誤りであると考えられます。メッセージが応答であるならば、それは捨てなければなりません。メッセージが要求である場合、要素は400（悪いRequest）応答を生成する必要があります。メッセージがないContent-Lengthヘッダフィールドを持っていない場合、メッセージボディはトランスポートパケットの終わりで終了するものとします。"
    },
    {
      "indent": 3,
      "text": "In the case of stream-oriented transports such as TCP, the Content-Length header field indicates the size of the body. The Content-Length header field MUST be used with stream oriented transports.",
      "ja": "TCPのようなストリーム指向のトランスポートの場合には、Content-Lengthヘッダフィールドは、体の大きさを示しています。 Content-Lengthヘッダフィールドは、ストリーム指向のトランスポートを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.4 Error Handling",
      "section_title": true,
      "ja": "18.4エラー処理"
    },
    {
      "indent": 3,
      "text": "Error handling is independent of whether the message was a request or response.",
      "ja": "エラー処理は、メッセージが要求または応答であったかどうかとは無関係です。"
    },
    {
      "indent": 3,
      "text": "If the transport user asks for a message to be sent over an unreliable transport, and the result is an ICMP error, the behavior depends on the type of ICMP error. Host, network, port or protocol unreachable errors, or parameter problem errors SHOULD cause the transport layer to inform the transport user of a failure in sending. Source quench and TTL exceeded ICMP errors SHOULD be ignored.",
      "ja": "トランスポート・ユーザは、信頼性の低いトランスポートを介して送信されるメッセージを要求し、その結果がICMPエラーである場合、動作は、ICMPエラーの種類に依存します。ホスト、ネットワーク、ポートまたはプロトコル到達不能エラー、またはパラメータ問題エラートランスポート層は、送信に失敗した輸送をユーザーに通知するようになります。ソースクエンチし、TTLはICMPエラーは無視されるべきである超えました。"
    },
    {
      "indent": 3,
      "text": "If the transport user asks for a request to be sent over a reliable transport, and the result is a connection failure, the transport layer SHOULD inform the transport user of a failure in sending.",
      "ja": "トランスポートユーザーが信頼できるトランスポートを介して送信するリクエストを要求し、その結果、接続に失敗している場合は、トランスポート層は、送信に失敗したトランスポートユーザーに通知する必要があります。"
    },
    {
      "indent": 0,
      "text": "19 Common Message Components",
      "ja": "19の共通メッセージのコンポーネント"
    },
    {
      "indent": 3,
      "text": "There are certain components of SIP messages that appear in various places within SIP messages (and sometimes, outside of them) that merit separate discussion.",
      "ja": "別の議論に値する（それらの外側に、時には）SIPメッセージ内の様々な場所に表示されるSIPメッセージの特定の構成要素があります。"
    },
    {
      "indent": 0,
      "text": "19.1 SIP and SIPS Uniform Resource Indicators",
      "section_title": true,
      "ja": "19.1 SIPおよびユニフォームリソースインジケータをSIPS"
    },
    {
      "indent": 3,
      "text": "A SIP or SIPS URI identifies a communications resource. Like all URIs, SIP and SIPS URIs may be placed in web pages, email messages, or printed literature. They contain sufficient information to initiate and maintain a communication session with the resource.",
      "ja": "SIPまたはSIPS URIは、通信リソースを識別する。すべてのURIと同様に、SIPとSIPS URIは、Webページ、電子メールメッセージ、または印刷された文献に配置することができます。彼らは、リソースとの通信セッションを開始し、維持するのに十分な情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Examples of communications resources include the following:",
      "ja": "通信リソースの例としては次のものがあります。"
    },
    {
      "indent": 6,
      "text": "o a user of an online service",
      "ja": "オンラインサービスの利用者O"
    },
    {
      "indent": 6,
      "text": "o an appearance on a multi-line phone",
      "ja": "Oマルチライン電話上の外観"
    },
    {
      "indent": 6,
      "text": "o a mailbox on a messaging system",
      "ja": "Oメッセージングシステム上のメールボックス"
    },
    {
      "indent": 6,
      "text": "o a PSTN number at a gateway service",
      "ja": "OゲートウェイサービスにおけるPSTN番号"
    },
    {
      "indent": 6,
      "text": "o a group (such as \"sales\" or \"helpdesk\") in an organization",
      "ja": "組織内（例えば、「販売」または「ヘルプデスク」という）O群"
    },
    {
      "indent": 3,
      "text": "A SIPS URI specifies that the resource be contacted securely. This means, in particular, that TLS is to be used between the UAC and the domain that owns the URI. From there, secure communications are used to reach the user, where the specific security mechanism depends on the policy of the domain. Any resource described by a SIP URI can be \"upgraded\" to a SIPS URI by just changing the scheme, if it is desired to communicate with that resource securely.",
      "ja": "SIPS URIは、リソースが確実に連絡することを指定します。これは、TLSはUACとURIを所有しているドメインとの間で使用されることを、具体的には、意味します。そこから、安全な通信は、特定のセキュリティメカニズムは、ドメインのポリシーに依存して、ユーザーに到達するために使用されています。 SIP URIによって記載された任意のリソースは、確実にそのリソースと通信することが所望される場合だけ、スキームを変更することにより、SIPS URIに「アップグレード」することができます。"
    },
    {
      "indent": 0,
      "text": "19.1.1 SIP and SIPS URI Components",
      "section_title": true,
      "ja": "19.1.1 SIPとSIPS URIコンポーネント"
    },
    {
      "indent": 3,
      "text": "The \"sip:\" and \"sips:\" schemes follow the guidelines in RFC 2396 [5]. They use a form similar to the mailto URL, allowing the specification of SIP request-header fields and the SIP message-body. This makes it possible to specify the subject, media type, or urgency of sessions initiated by using a URI on a web page or in an email message. The formal syntax for a SIP or SIPS URI is presented in Section 25. Its general form, in the case of a SIP URI, is:",
      "ja": "\"SIP：\" と \"一口：\" スキームはRFC 2396のガイドラインに従ってください[5]。これらは、SIPリクエスト・ヘッダー・フィールドの仕様とSIPメッセージボディを可能MAILTO URLと同様の形式を使用します。これは主題、メディアタイプ、またはWebページや電子メールメッセージ内のURIを使用して開始したセッションの緊急性を指定することが可能となります。 SIPまたは正式な構文は、SIP URIの場合には、セクション25その一般的な形で提示されたURIをSIPS、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "sip:user:password@host:port;uri-parameters?headers",
      "ja": "SIP：ユーザー：パスワード@ホスト：ポート、URIパラメータのヘッダー？"
    },
    {
      "indent": 3,
      "text": "The format for a SIPS URI is the same, except that the scheme is \"sips\" instead of sip. These tokens, and some of the tokens in their expansions, have the following meanings:",
      "ja": "SIPS URIの形式はスキームはなく、SIPの「一口」であることを除いて、同じです。これらのトークン、およびその展開内のトークンのいくつかは、次の意味があります。"
    },
    {
      "indent": 6,
      "text": "user: The identifier of a particular resource at the host being addressed. The term \"host\" in this context frequently refers to a domain. The \"userinfo\" of a URI consists of this user field, the password field, and the @ sign following them. The userinfo part of a URI is optional and MAY be absent when the destination host does not have a notion of users or when the host itself is the resource being identified. If the @ sign is present in a SIP or SIPS URI, the user field MUST NOT be empty.",
      "ja": "ユーザー：ホストの特定のリソースの識別子がアドレス指定されます。この文脈における用語「宿主」とは、頻繁にドメインを指します。 URIの「userinfoを」は、このユーザーフィールド、パスワードフィールド、およびそれらを以下の@記号で構成されています。 URIのユーザー情報の一部はオプションであり、宛先ホストがユーザーの概念を持たないか、またはホスト自体である場合、リソースが識別されたときに存在しなくてもよいです。 @記号は、SIP中に存在するか、またはURIをSIPS場合、ユーザーフィールドは空にすることはできません。"
    },
    {
      "indent": 9,
      "text": "If the host being addressed can process telephone numbers, for instance, an Internet telephony gateway, a telephone-subscriber field defined in RFC 2806 [9] MAY be used to populate the user field. There are special escaping rules for encoding telephone-subscriber fields in SIP and SIPS URIs described in Section 19.1.2.",
      "ja": "アドレス指定されているホストは、電話番号を処理することができる場合、例えば、インターネット電話ゲートウェイ、RFC 2806で定義された電話加入者フィールドは、[9]ユーザーフィールドを埋めるために使用されるかもしれません。セクション19.1.2で説明SIPとSIPS URIの中の電話加入者のフィールドを符号化するための特別なエスケープのルールがあります。"
    },
    {
      "indent": 6,
      "text": "password: A password associated with the user. While the SIP and SIPS URI syntax allows this field to be present, its use is NOT RECOMMENDED, because the passing of authentication information in clear text (such as URIs) has proven to be a security risk in almost every case where it has been used. For instance, transporting a PIN number in this field exposes the PIN.",
      "ja": "パスワード：ユーザーに関連付けられているパスワード。 SIPおよびURIの構文をSIPSは、このフィールドが存在することができますが（URIなど）クリアテキストでの認証情報の受け渡しは、それが使用されているほぼすべてのケースではセキュリティ上のリスクがあることが証明されているので、その使用はお勧めしません。たとえば、このフィールドにPIN番号を輸送してPINを公開します。"
    },
    {
      "indent": 9,
      "text": "Note that the password field is just an extension of the user portion. Implementations not wishing to give special significance to the password portion of the field MAY simply treat \"user:password\" as a single string.",
      "ja": "パスワードフィールドは、ユーザー部分の単なる延長であることに注意してください。 1つの文字列として：「パスワードのユーザーを」実装は、単純に扱うかもしれフィールドのパスワード部分に特別な意味を与えることを望むものではありません。"
    },
    {
      "indent": 6,
      "text": "host: The host providing the SIP resource. The host part contains either a fully-qualified domain name or numeric IPv4 or IPv6 address. Using the fully-qualified domain name form is RECOMMENDED whenever possible.",
      "ja": "ホスト：ホストがSIPリソースを提供します。ホスト部分は、完全修飾ドメイン名または数値のIPv4またはIPv6アドレスのいずれかが含まれています。完全修飾ドメイン名の形式を使用すると、可能な限り推奨されます。"
    },
    {
      "indent": 6,
      "text": "port: The port number where the request is to be sent.",
      "ja": "ポート：要求が送信されるポート番号。"
    },
    {
      "indent": 6,
      "text": "URI parameters: Parameters affecting a request constructed from the URI.",
      "ja": "URIパラメータ：URIから構築要求に影響を与えるパラメータ。"
    },
    {
      "indent": 9,
      "text": "URI parameters are added after the hostport component and are separated by semi-colons.",
      "ja": "URIパラメータは、ホスト側の構成要素の後に添加し、セミコロンによって分離されています。"
    },
    {
      "indent": 9,
      "text": "URI parameters take the form:",
      "ja": "URIパラメータは次の形式をとります。"
    },
    {
      "indent": 12,
      "text": "parameter-name \"=\" parameter-value",
      "ja": "パラメータ名「=」パラメータ値"
    },
    {
      "indent": 9,
      "text": "Even though an arbitrary number of URI parameters may be included in a URI, any given parameter-name MUST NOT appear more than once.",
      "ja": "URIパラメータの任意の数は、URIに含まれることができるにもかかわらず、任意のパラメータ名が複数回出現することはできません。"
    },
    {
      "indent": 9,
      "text": "This extensible mechanism includes the transport, maddr, ttl, user, method and lr parameters.",
      "ja": "この拡張可能なメカニズムは、トランスポート、MADDR、TTL、ユーザ、方法及びLRパラメータを含みます。"
    },
    {
      "indent": 9,
      "text": "The transport parameter determines the transport mechanism to be used for sending SIP messages, as specified in [4]. SIP can use any network transport protocol. Parameter names are defined for UDP (RFC 768 [14]), TCP (RFC 761 [15]), and SCTP (RFC 2960 [16]). For a SIPS URI, the transport parameter MUST indicate a reliable transport.",
      "ja": "トランスポートパラメータは、[4]で指定されるように、SIPメッセージを送信するために使用されるトランスポート機構を決定します。 SIPは、任意のネットワークトランスポートプロトコルを使用することができます。パラメータ名は、UDP（RFC 768 [14]）、TCP（RFC 761 [15]）、およびSCTP（RFC 2960 [16]）で定義されています。 SIPS URIの場合は、トランスポート・パラメータは、信頼性の高いトランスポートを指定する必要があります。"
    },
    {
      "indent": 9,
      "text": "The maddr parameter indicates the server address to be contacted for this user, overriding any address derived from the host field. When an maddr parameter is present, the port and transport components of the URI apply to the address indicated in the maddr parameter value. [4] describes the proper interpretation of the transport, maddr, and hostport in order to obtain the destination address, port, and transport for sending a request.",
      "ja": "MADDRパラメータは、ホストフィールドから派生した任意のアドレスを上書きするとこのユーザーのために連絡するサーバーのアドレスを示しています。 MADDRパラメータが存在する場合、URIのポートおよびトランスポートコンポーネントはMADDRパラメータ値で示されるアドレスに適用されます。 [4]要求を送信するための宛先アドレス、ポート、および輸送を得るために輸送、MADDR、及びホスト側の適切な解釈を記載します。"
    },
    {
      "indent": 9,
      "text": "The maddr field has been used as a simple form of loose source routing. It allows a URI to specify a proxy that must be traversed en-route to the destination. Continuing to use the maddr parameter this way is strongly discouraged (the mechanisms that enable it are deprecated). Implementations should instead use the Route mechanism described in this document, establishing a pre-existing route set if necessary (see Section 8.1.1.1). This provides a full URI to describe the node to be traversed.",
      "ja": "MADDRフィールドは、ルーズソースルーティングの単純な形として使用されています。これは、URIは、EN-ルート先に横断しなければならないプロキシを指定することができます。この方法は、強くお勧めしMADDRパラメータを使用し続ける（これを有効にするメカニズムが推奨されていません）。インプリメンテーションではなく、必要に応じて設定する既存のルートを確立する、本書では説明ルートメカニズムを使用しなければならない（セクション8.1.1.1を参照）。これは、横断するノードを記述するために、完全なURIを提供します。"
    },
    {
      "indent": 9,
      "text": "The ttl parameter determines the time-to-live value of the UDP multicast packet and MUST only be used if maddr is a multicast address and the transport protocol is UDP. For example, to specify a call to alice@atlanta.com using multicast to 239.255.255.1 with a ttl of 15, the following URI would be used:",
      "ja": "TTLパラメータは、UDPマルチキャストパケットの存続時間値を決定し、MADDRがマルチキャストアドレスであり、転送プロトコルがUDPである場合にのみ使用されなければなりません。例えば、15のTTLと239.255.255.1するマルチキャストを使用alice@atlanta.comの呼び出しを指定するには、次のURIを使用することになります。"
    },
    {
      "indent": 12,
      "text": "sip:alice@atlanta.com;maddr=239.255.255.1;ttl=15",
      "ja": "SIP：alice@atlanta.com; MADDR = 239.255.255.1; TTL = 15"
    },
    {
      "indent": 9,
      "text": "The set of valid telephone-subscriber strings is a subset of valid user strings. The user URI parameter exists to distinguish telephone numbers from user names that happen to look like telephone numbers. If the user string contains a telephone number formatted as a telephone-subscriber, the user parameter value \"phone\" SHOULD be present. Even without this parameter, recipients of SIP and SIPS URIs MAY interpret the pre-@ part as a telephone number if local restrictions on the name space for user name allow it.",
      "ja": "有効な電話加入者の文字列のセットには、有効なユーザ文字列のサブセットです。ユーザーURIパラメータは、電話番号のように見えるために起こるユーザ名から電話番号を区別するために存在しています。ユーザ文字列が電話加入者としてフォーマットされた電話番号が含まれている場合、ユーザー・パラメータ値「電話」が存在しなければなりません。ユーザー名のネームスペース上のローカル制約がそれを許可している場合でも、このパラメータなしで、SIPおよびSIPS URIの受信者は、電話番号などの事前の@部分を解釈するかもしれません。"
    },
    {
      "indent": 9,
      "text": "The method of the SIP request constructed from the URI can be specified with the method parameter.",
      "ja": "URIから構築されたSIPリクエストのメソッドは、メソッドのパラメータで指定することができます。"
    },
    {
      "indent": 9,
      "text": "The lr parameter, when present, indicates that the element responsible for this resource implements the routing mechanisms specified in this document. This parameter will be used in the URIs proxies place into Record-Route header field values, and may appear in the URIs in a pre-existing route set.",
      "ja": "LRパラメータは、存在する場合、このリソースを担当する要素はこの文書で指定されたルーティングメカニズムを実装していることを示しています。このパラメータは、Record-Routeヘッダフィールド値へのURIプロキシの代わりに使用され、既存のルートセット内のURIで表示されてもよいです。"
    },
    {
      "indent": 9,
      "text": "This parameter is used to achieve backwards compatibility with systems implementing the strict-routing mechanisms of RFC 2543 and the rfc2543bis drafts up to bis-05. An element preparing to send a request based on a URI not containing this parameter can assume the receiving element implements strict-routing and reformat the message to preserve the information in the Request-URI.",
      "ja": "このパラメータは、RFC 2543の厳密なルーティングメカニズムを実装するシステムとの下位互換性を実現するために使用され、rfc2543bisはビス05まで立案します。このパラメータを含まないURIに基づいて要求を送信する準備要素は、受信要素が厳密ルーティングを実装仮定とRequest-URI内の情報を保存するためのメッセージを再フォーマットすることができます。"
    },
    {
      "indent": 9,
      "text": "Since the uri-parameter mechanism is extensible, SIP elements MUST silently ignore any uri-parameters that they do not understand.",
      "ja": "URIパラメータメカニズムは拡張可能なので、SIPエレメントは、静かに彼らが理解していない任意のURIパラメータを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Headers: Header fields to be included in a request constructed from the URI.",
      "ja": "ヘッダ：URIから構築要求に含まれるヘッダフィールド。"
    },
    {
      "indent": 9,
      "text": "Headers fields in the SIP request can be specified with the \"?\" mechanism within a URI. The header names and values are encoded in ampersand separated hname = hvalue pairs. The special hname \"body\" indicates that the associated hvalue is the message-body of the SIP request.",
      "ja": "SIPリクエストのヘッダーフィールドは、「？」を指定することができますURI内のメカニズム。ヘッダー名と値はアンパサンドでhname = hvalueペアを分離して符号化されます。特別hname「本体」は関連hvalueは、SIPリクエストのメッセージ・ボディであることを示しています。"
    },
    {
      "indent": 3,
      "text": "Table 1 summarizes the use of SIP and SIPS URI components based on the context in which the URI appears. The external column describes URIs appearing anywhere outside of a SIP message, for instance on a web page or business card. Entries marked \"m\" are mandatory, those marked \"o\" are optional, and those marked \"-\" are not allowed. Elements processing URIs SHOULD ignore any disallowed components if they are present. The second column indicates the default value of an optional element if it is not present. \"--\" indicates that the element is either not optional, or has no default value.",
      "ja": "表1は、SIPの使用を要約し、URIが現れるコンテキストに基づいてURIコンポーネントをSIPS。外部列は、URIがWebページや名刺に、たとえば、どこでもSIPメッセージの外に現れて説明します。エントリーは、「m」は、それらの「O」マークされ、必須のオプションであり、そしてそれらがマークマーク「 - 」許可されていません。それらが存在する場合のURIを処理要素は、任意の許可されていないコンポーネントを無視する必要があります。それが存在しない場合には、第2の列は、任意の要素のデフォルト値を示しています。 「 - 」の要素がいずれかのオプションではありません、またはデフォルト値を持たないことを示しています。"
    },
    {
      "indent": 3,
      "text": "URIs in Contact header fields have different restrictions depending on the context in which the header field appears. One set applies to messages that establish and maintain dialogs (INVITE and its 200 (OK) response). The other applies to registration and redirection messages (REGISTER, its 200 (OK) response, and 3xx class responses to any method).",
      "ja": "ContactヘッダーフィールドのURIは、ヘッダーフィールドが表示されるコンテキストに応じて、異なる制限があります。 1つのセットは、ダイアログを（INVITEおよびその200（OK）応答）を確立し、維持メッセージに適用されます。他には、登録とリダイレクトメッセージ（REGISTER、その200（OK）応答、および任意のメソッドへの3xxクラス応答）に適用されます。"
    },
    {
      "indent": 0,
      "text": "19.1.2 Character Escaping Requirements",
      "section_title": true,
      "ja": "19.1.2文字のエスケープ要件"
    },
    {
      "indent": 0,
      "text": " dialog reg./redir. Contact/ default Req.-URI To From Contact R-R/Route external user -- o o o o o o password -- o o o o o o host -- m m m m m m port (1) o - - o o o user-param ip o o o o o o method INVITE - - - - - o maddr-param -- o - - o o o ttl-param 1 o - - o - o transp.-param (2) o - - o o o lr-param -- o - - - o o other-param -- o o o o o o headers -- - - - o - o",
      "ja": "reg./redirダイアログ。 RRお問い合わせ/ルート外部ユーザーからの連絡/デフォルトReq.-URIへ -  OOOOOOパスワード -  OOOOOOホスト -   -  oooのユーザーストップのIP OOOOOO方法がINVITE  -   -   -   -   -   -  MADDRストップ（1）MMMMMMポート -  O  -   -  TTL-PARAM 1 OOO  -  O  -  O-TRANSPストップ（2） - 。 -  OOO LR-PARAM  -  O  -   -   -  OO他-PARAM  -  OOOOOOヘッダー -   -   -   - ○ - "
    },
    {
      "indent": 3,
      "text": "(1): The default port value is transport and scheme dependent. The default is 5060 for sip: using UDP, TCP, or SCTP. The default is 5061 for sip: using TLS over TCP and sips: over TCP.",
      "ja": "（1）：デフォルトのポート値は、トランスポートおよびスキームに依存します。 UDP、TCP、またはSCTPを使用する：デフォルトでは、SIPのための5060です。デフォルトでは、SIPのための5061です：TCPと一口上でTLSを使用して：TCP上。"
    },
    {
      "indent": 3,
      "text": "(2): The default transport is scheme dependent. For sip:, it is UDP. For sips:, it is TCP.",
      "ja": "（2）：デフォルトのトランスポートはスキームに依存しています。 SIPのため:,それはUDPです。 SIPに関して:,それはTCPです。"
    },
    {
      "indent": 3,
      "text": "Table 1: Use and default values of URI components for SIP header field values, Request-URI and references",
      "ja": "表1：使用し、SIPヘッダフィールド値のURIコンポーネントのデフォルト値は、リクエストURIと参照"
    },
    {
      "indent": 3,
      "text": "SIP follows the requirements and guidelines of RFC 2396 [5] when defining the set of characters that must be escaped in a SIP URI, and uses its \"\"%\" HEX HEX\" mechanism for escaping. From RFC 2396 [5]:",
      "ja": "SIPは、SIP URIでエスケープされなければならない文字のセットを定義する場合の要件とRFC 2396のガイドライン[5]以下、及びエスケープために、その「」％「HEX HEX」メカニズムを使用します。 RFC 2396から[5]："
    },
    {
      "indent": 6,
      "text": "The set of characters actually reserved within any given URI component is defined by that component. In general, a character is reserved if the semantics of the URI changes if the character is replaced with its escaped US-ASCII encoding [5]. Excluded US-ASCII characters (RFC 2396 [5]), such as space and control characters and characters used as URI delimiters, also MUST be escaped. URIs MUST NOT contain unescaped space and control characters.",
      "ja": "実際に任意のURIコンポーネント内に予約文字の集合は、その成分によって定義されます。一般的には、文字はURIのセマンティクスが変更された場合、文字がエスケープUS-ASCIIエンコーディングに置き換えている場合に予約[5]。さまた、エスケープしなければならない、そのようなURIの区切り文字として使用するスペースと制御文字や文字などの除外US-ASCII文字（RFC 2396 [5]）、、。 URIはエスケープされていないスペースと制御文字を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "For each component, the set of valid BNF expansions defines exactly which characters may appear unescaped. All other characters MUST be escaped.",
      "ja": "各成分について、有効なBNFの拡張のセットが文字がエスケープ表示されることを正確に定義します。他のすべての文字をエスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, \"@\" is not in the set of characters in the user component, so the user \"j@s0n\" must have at least the @ sign encoded, as in \"j%40s0n\".",
      "ja": "例えば、「@」は、ユーザ・コンポーネント内の文字の集合ではないので、ユーザ「Jする@ S0N」は「Jの％の40s0n」のように、符号化された少なくとも@記号を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "Expanding the hname and hvalue tokens in Section 25 show that all URI reserved characters in header field names and values MUST be escaped.",
      "ja": "セクション25に名前と値のトークンを拡大URIヘッダフィールド名と値の文字を予約し、すべてをエスケープしなければならないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The telephone-subscriber subset of the user component has special escaping considerations. The set of characters not reserved in the RFC 2806 [9] description of telephone-subscriber contains a number of characters in various syntax elements that need to be escaped when used in SIP URIs. Any characters occurring in a telephone-subscriber that do not appear in an expansion of the BNF for the user rule MUST be escaped.",
      "ja": "ユーザコンポーネントの電話加入者のサブセットは特別なエスケープの考慮事項を有します。 RFC 2806に予約されていない文字の組が[9]の電話加入者の説明は、SIP URIの中で使用される場合、エスケープする必要がある様々な構文要素の文字数が含ま。ユーザールールのためのBNFの展開には表示されません。電話加入者に発生した任意の文字をエスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that character escaping is not allowed in the host component of a SIP or SIPS URI (the % character is not valid in its expansion). This is likely to change in the future as requirements for Internationalized Domain Names are finalized. Current implementations MUST NOT attempt to improve robustness by treating received escaped characters in the host component as literally equivalent to their unescaped counterpart. The behavior required to meet the requirements of IDN may be significantly different.",
      "ja": "なお、文字エスケープは、SIPのホストコンポーネントで許可又は（％文字は、その膨張に有効でない）URIをSIPSされていません。これは、国際化ドメイン名の要件が確定しているとして、将来的に変更する可能性があります。現在の実装では、アンエスケープの対応に文字通り同等のものとして、ホストコンポーネントで受信エスケープ文字を処理することにより、堅牢性を向上させるのを試みてはいけません。 IDNの要件を満たすために必要な動作が大幅に異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "19.1.3 Example SIP and SIPS URIs",
      "section_title": true,
      "ja": "19.1.3例SIPとSIPS URIを"
    },
    {
      "indent": 3,
      "text": "sip:alice@atlanta.com sip:alice:secretword@atlanta.com;transport=tcp sips:alice@atlanta.com?subject=project%20x&priority=urgent sip:+1-212-555-1212:1234@gateway.com;user=phone sips:1212@gateway.com sip:alice@192.0.2.4 sip:atlanta.com;method=REGISTER?to=alice%40atlanta.com sip:alice;day=tuesday@atlanta.com",
      "ja": "SIP：SIP alice@atlanta.com：アリス：secretword@atlanta.com;輸送= TCPの一口：？alice@atlanta.com対象=プロジェクト％20X＆優先順位=緊急SIP：+ 1-212-555-1212：1234ゲートウェイ@。 COM;ユーザー=電話一口：1212@gateway.com SIP：alice@192.0.2.4のSIP：atlanta.com;メソッド=レジスタに=アリス％40atlanta.com SIP：？アリス; day=tuesday@atlanta.com"
    },
    {
      "indent": 3,
      "text": "The last sample URI above has a user field value of \"alice;day=tuesday\". The escaping rules defined above allow a semicolon to appear unescaped in this field. For the purposes of this protocol, the field is opaque. The structure of that value is only useful to the SIP element responsible for the resource.",
      "ja": "「;日=火曜日アリス」最後のサンプルURIは、上記のユーザーフィールドの値を持っています。上記で定義されたエスケープ規則は、セミコロンがこのフィールドにエスケープされていない表示されるようにします。このプロトコルの目的のために、フィールドが不透明です。その値の構造は、リソースを担当するSIP要素にのみ有効です。"
    },
    {
      "indent": 0,
      "text": "19.1.4 URI Comparison",
      "section_title": true,
      "ja": "URI 19.1.4比較"
    },
    {
      "indent": 3,
      "text": "Some operations in this specification require determining whether two SIP or SIPS URIs are equivalent. In this specification, registrars need to compare bindings in Contact URIs in REGISTER requests (see Section 10.3.). SIP and SIPS URIs are compared for equality according to the following rules:",
      "ja": "本明細書におけるいくつかの動作は、2つのSIPまたはSIPS URIが等価であるかどうかを決定する必要があります。本明細書では、レジストラがREGISTERリクエストで連絡先のURIでバインディングを比較する必要があります（項10.3を参照してください。）。 SIPとSIPS URIは、次の規則に従って等しいかどうかを比較しています。"
    },
    {
      "indent": 6,
      "text": "o A SIP and SIPS URI are never equivalent.",
      "ja": "O A SIPとSIPS URIは等価では決してありません。"
    },
    {
      "indent": 6,
      "text": "o Comparison of the userinfo of SIP and SIPS URIs is case-sensitive. This includes userinfo containing passwords or formatted as telephone-subscribers. Comparison of all other components of the URI is case-insensitive unless explicitly defined otherwise.",
      "ja": "O SIPとSIPS URIのユーザー情報の比較は大文字と小文字が区別されます。これは、パスワードを含むか、電話加入者としてフォーマットのUserInfo含まれています。明示的に別段の定義がない限り、URIの他のすべてのコンポーネントの比較は大文字と小文字を区別しないです。"
    },
    {
      "indent": 6,
      "text": "o The ordering of parameters and header fields is not significant in comparing SIP and SIPS URIs.",
      "ja": "oをパラメータとヘッダフィールドの順序は、SIPとSIPS URIを比較するに重要ではありません。"
    },
    {
      "indent": 6,
      "text": "o Characters other than those in the \"reserved\" set (see RFC 2396 [5]) are equivalent to their \"\"%\" HEX HEX\" encoding.",
      "ja": "O「予約」セット中のもの以外の文字は、その「」％「HEX HEX」符号化と等価である（RFC 2396 [5]を参照します）。"
    },
    {
      "indent": 6,
      "text": "o An IP address that is the result of a DNS lookup of a host name does not match that host name.",
      "ja": "Oホスト名のDNSルックアップの結果であるIPアドレスは、そのホスト名と一致していません。"
    },
    {
      "indent": 6,
      "text": "o For two URIs to be equal, the user, password, host, and port components must match.",
      "ja": "2つのURIが同じであるためにO、ユーザー、パスワード、ホスト、ポートコンポーネントが一致しなければなりません。"
    },
    {
      "indent": 9,
      "text": "A URI omitting the user component will not match a URI that includes one. A URI omitting the password component will not match a URI that includes one.",
      "ja": "ユーザ・コンポーネントを省略URIはつを含むURIと一致しないであろう。パスワードコンポーネントを省略URIは一つを含むURIと一致しません。"
    },
    {
      "indent": 9,
      "text": "A URI omitting any component with a default value will not match a URI explicitly containing that component with its default value. For instance, a URI omitting the optional port component will not match a URI explicitly declaring port 5060. The same is true for the transport-parameter, ttl-parameter, user-parameter, and method components.",
      "ja": "デフォルト値で任意のコンポーネントを省いURIは、明示的にそのデフォルト値とそのコンポーネントを含むURIと一致しません。例えば、任意のポート構成要素を省略URIがURI明示的に宣言ポート5060に一致しない同じトランスポートパラメータ、TTLパラメータ、ユーザ・パラメータ、および方法の構成要素についても同様です。"
    },
    {
      "indent": 12,
      "text": "Defining sip:user@host to not be equivalent to sip:user@host:5060 is a change from RFC 2543. When deriving addresses from URIs, equivalent addresses are expected from equivalent URIs. The URI sip:user@host:5060 will always resolve to port 5060. The URI sip:user@host may resolve to other ports through the DNS SRV mechanisms detailed in [4].",
      "ja": "一口の定義：ユーザ@ホスト：ユーザー@ホストは、SIPと同等ではないし5060は、RFC 2543のURIからアドレスを導き出すから変更され、同等のアドレスは同等のURIから期待されています。 URI SIP：ユーザー@ホスト：5060は常にポート5060に解決されるURI SIP：ユーザー@ホストがで詳述のDNS SRVメカニズムを介して他のポートに解決することができる[4]。"
    },
    {
      "indent": 6,
      "text": "o URI uri-parameter components are compared as follows:",
      "ja": "次のようにO URI URIパラメータ成分が比較されます。"
    },
    {
      "indent": 9,
      "text": "- Any uri-parameter appearing in both URIs must match.",
      "ja": " - 両方のURIに登場する任意のURIパラメータが一致している必要があります。"
    },
    {
      "indent": 9,
      "text": "- A user, ttl, or method uri-parameter appearing in only one URI never matches, even if it contains the default value.",
      "ja": " - 唯一のURIに登場ユーザー、TTL、またはメソッドのuriパラメータは、デフォルト値が含まれていても、一致することはありません。"
    },
    {
      "indent": 9,
      "text": "- A URI that includes an maddr parameter will not match a URI that contains no maddr parameter.",
      "ja": " - 何MADDRパラメータを含まないURIとは一致しませんMADDRパラメータを含んでいるURI。"
    },
    {
      "indent": 9,
      "text": "- All other uri-parameters appearing in only one URI are ignored when comparing the URIs.",
      "ja": " -  URIを比較するときにだけ1つのURIに登場する他のすべてのURIパラメータは無視されます。"
    },
    {
      "indent": 6,
      "text": "o URI header components are never ignored. Any present header component MUST be present in both URIs and match for the URIs to match. The matching rules are defined for each header field in Section 20.",
      "ja": "O URIヘッダ要素は無視されることはありません。任意本ヘッダ成分は、両方のURIに存在することと一致するURIの一致しなければなりません。マッチングルールはセクション20の各ヘッダフィールドのために定義されています。"
    },
    {
      "indent": 3,
      "text": "The URIs within each of the following sets are equivalent:",
      "ja": "次の組のそれぞれ内のURIは等価です。"
    },
    {
      "indent": 3,
      "text": "sip:%61lice@atlanta.com;transport=TCP sip:alice@AtLanTa.CoM;Transport=tcp",
      "ja": "SIP：%61lice@atlanta.com;輸送= TCPのSIP：alice@AtLanTa.CoM;交通= TCP"
    },
    {
      "indent": 3,
      "text": "sip:carol@chicago.com sip:carol@chicago.com;newparam=5 sip:carol@chicago.com;security=on",
      "ja": "SIP：SIP carol@chicago.com：carol@chicago.com; newparam = 5 SIP：carol@chicago.com;セキュリティ=上"
    },
    {
      "indent": 3,
      "text": "sip:biloxi.com;transport=tcp;method=REGISTER?to=sip:bob%40biloxi.com sip:biloxi.com;method=REGISTER;transport=tcp?to=sip:bob%40biloxi.com",
      "ja": "SIP：biloxi.com;輸送= TCP;方法=レジスタへ= SIP：ボブ％の40biloxi.comのSIP：biloxi.com;方法= REGISTER;輸送= TCP = SIPにボブ％40biloxi.com？"
    },
    {
      "indent": 3,
      "text": "sip:alice@atlanta.com?subject=project%20x&priority=urgent sip:alice@atlanta.com?priority=urgent&subject=project%20x",
      "ja": "SIP：alice@atlanta.com対象=プロジェクト％20X＆優先順位=緊急SIP：？alice@atlanta.com優先順位=緊急＆主題=プロジェクト％20X？"
    },
    {
      "indent": 3,
      "text": "The URIs within each of the following sets are not equivalent:",
      "ja": "次の組のそれぞれ内のURIは等価ではありません。"
    },
    {
      "indent": 3,
      "text": "SIP:ALICE@AtLanTa.CoM;Transport=udp (different usernames) sip:alice@AtLanTa.CoM;Transport=UDP",
      "ja": "SIP：ALICE@AtLanTa.CoM;トランス= UDP（異なるユーザ名）SIP：alice@AtLanTa.CoM;トランス= UDP"
    },
    {
      "indent": 3,
      "text": "sip:bob@biloxi.com (can resolve to different ports) sip:bob@biloxi.com:5060",
      "ja": "SIP：bob@biloxi.com（異なるポートに解決することができます）SIP：bob@biloxi.com：5060"
    },
    {
      "indent": 3,
      "text": "sip:bob@biloxi.com (can resolve to different transports) sip:bob@biloxi.com;transport=udp",
      "ja": "SIP：bob@biloxi.com（異なるトランスポートに解決することができる）SIP：bob@biloxi.com;輸送= UDP"
    },
    {
      "indent": 3,
      "text": "sip:bob@biloxi.com (can resolve to different port and transports) sip:bob@biloxi.com:6000;transport=tcp",
      "ja": "輸送= TCP; 6000：SIP：bob@biloxi.com：bob@biloxi.comは、SIPを（別のポートに解決して輸送することができます）"
    },
    {
      "indent": 3,
      "text": "sip:carol@chicago.com (different header component) sip:carol@chicago.com?Subject=next%20meeting",
      "ja": "SIP：carol@chicago.com（異なるヘッダ成分）SIP：carol@chicago.com件名=次％の20meeting"
    },
    {
      "indent": 3,
      "text": "sip:bob@phone21.boxesbybob.com (even though that's what sip:bob@192.0.2.4 phone21.boxesbybob.com resolves to)",
      "ja": "SIP：bob@phone21.boxesbybob.com（それは一口何にもかかわらず：bob@192.0.2.4 phone21.boxesbybob.comはに解決）"
    },
    {
      "indent": 3,
      "text": "Note that equality is not transitive:",
      "ja": "平等で推移ないことに注意してください："
    },
    {
      "indent": 6,
      "text": "o sip:carol@chicago.com and sip:carol@chicago.com;security=on are equivalent",
      "ja": "OのSIP：carol@chicago.comとSIP：carol@chicago.com;セキュリティ=上等価です"
    },
    {
      "indent": 6,
      "text": "o sip:carol@chicago.com and sip:carol@chicago.com;security=off are equivalent",
      "ja": "OのSIP：carol@chicago.comとSIP：carol@chicago.com;セキュリティ=オフ等価です"
    },
    {
      "indent": 6,
      "text": "o sip:carol@chicago.com;security=on and sip:carol@chicago.com;security=off are not equivalent",
      "ja": "入出力SIP：carol@chicago.com;セキュリティ= ONとSIP：carol@chicago.com;セキュリティ=オフ等価ではありません"
    },
    {
      "indent": 0,
      "text": "19.1.5 Forming Requests from a URI",
      "section_title": true,
      "ja": "19.1.5 URIからのリクエストを形成します"
    },
    {
      "indent": 3,
      "text": "An implementation needs to take care when forming requests directly from a URI. URIs from business cards, web pages, and even from sources inside the protocol such as registered contacts may contain inappropriate header fields or body parts.",
      "ja": "実装はURIから直接リクエストを形成する際に世話をする必要があります。名刺、ウェブページから、さらにはそのような登録連絡先などのプロトコル内部のソースからのURIは不適切なヘッダーフィールドまたは身体の部分を含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST include any provided transport, maddr, ttl, or user parameter in the Request-URI of the formed request. If the URI contains a method parameter, its value MUST be used as the method of the request. The method parameter MUST NOT be placed in the Request-URI. Unknown URI parameters MUST be placed in the message's Request-URI.",
      "ja": "実装は任意に形成されたリクエストのRequest-URIに設けられた輸送、MADDR、TTL、またはユーザパラメータを含まなければなりません。 URIは、メソッドパラメータが含まれている場合、その値は、要求の方法として使用されなければなりません。メソッドのパラメータは、Request-URIには設置しないでください。未知のURIパラメータはメッセージの要求URIに置かなければなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD treat the presence of any headers or body parts in the URI as a desire to include them in the message, and choose to honor the request on a per-component basis.",
      "ja": "実装は、メッセージに含めるための願望としてURI内の任意のヘッダまたは身体部分の存在を治療するため、およびコンポーネントごとのベースで要求を尊重するように選択するべきです。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT honor these obviously dangerous header fields: From, Call-ID, CSeq, Via, and Record-Route.",
      "ja": "実装は、これらの明らかに危険なヘッダフィールドを尊重しないでください。から、コールID、のCSeq、ビア、およびRecord-ルートを。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT honor any requested Route header field values in order to not be used as an unwitting agent in malicious attacks.",
      "ja": "実装は、悪意のある攻撃に無意識剤として使用されないようにするために、任意の要求されたRouteヘッダーフィールド値を尊重すべきではありません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT honor requests to include header fields that may cause it to falsely advertise its location or capabilities. These include: Accept, Accept-Encoding, Accept-Language, Allow, Contact (in its dialog usage), Organization, Supported, and User-Agent.",
      "ja": "実装は、それがその場所や機能を通知偽っする可能性がありヘッダフィールドを含めるように要求を尊重すべきではありません。これらを含める：、受け入れのAccept-エンコーディング、言語を受け入れ、許可、（そのダイアログの使用で）連絡先、組織、サポート、およびユーザエージェント。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD verify the accuracy of any requested descriptive header fields, including: Content-Disposition, Content-Encoding, Content-Language, Content-Length, Content-Type, Date, Mime-Version, and Timestamp.",
      "ja": "コンテンツ処分、コンテンツのエンコード、コンテンツ言語、コンテンツの長さ、Content-Typeの、日付、マイム・バージョン、およびタイムスタンプ：インプリメンテーションは、いずれかの精度を含む記述的ヘッダフィールドを、要求された確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the request formed from constructing a message from a given URI is not a valid SIP request, the URI is invalid. An implementation MUST NOT proceed with transmitting the request. It should instead pursue the course of action due an invalid URI in the context it occurs.",
      "ja": "指定されたURIからのメッセージを構築するから形成された要求が有効SIP要求でない場合、URIは無効です。実装が要求を送信を続行してはなりません。これは、代わりにそれが発生したコンテキストで無効なURIによるアクションのコースを追求すべきです。"
    },
    {
      "indent": 6,
      "text": "The constructed request can be invalid in many ways. These include, but are not limited to, syntax error in header fields, invalid combinations of URI parameters, or an incorrect description of the message body.",
      "ja": "構築の要求は、多くの方法で無効にすることができます。これらには、ヘッダフィールド、URIパラメータ、またはメッセージボディの不正確な説明の無効な組み合わせに構文エラーが、これらに限定されません。"
    },
    {
      "indent": 3,
      "text": "Sending a request formed from a given URI may require capabilities unavailable to the implementation. The URI might indicate use of an unimplemented transport or extension, for example. An implementation SHOULD refuse to send these requests rather than modifying them to match their capabilities. An implementation MUST NOT send a request requiring an extension that it does not support.",
      "ja": "与えられたURIから形成されたリクエストを送信する実装に利用できない機能を必要とするかもしれません。 URIは、例えば実装されていない輸送または拡張子を使用することを、示している可能性があります。実装は、自分の能力に合わせて、それらを修正するのではなく、これらの要求を送信することを拒否すべきです。実装は、それがサポートしていないという拡張子を必要とする要求を送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "For example, such a request can be formed through the presence of a Require header parameter or a method URI parameter with an unknown or explicitly unsupported value.",
      "ja": "例えば、そのような要求は、要求ヘッダーパラメータまたは未知のまたは明示的にサポートされていない値を持つ方法URIパラメータの存在下で形成することができます。"
    },
    {
      "indent": 0,
      "text": "19.1.6 Relating SIP URIs and tel URLs",
      "section_title": true,
      "ja": "19.1.6に関するSIP URIとURLのTEL"
    },
    {
      "indent": 3,
      "text": "When a tel URL (RFC 2806 [9]) is converted to a SIP or SIPS URI, the entire telephone-subscriber portion of the tel URL, including any parameters, is placed into the userinfo part of the SIP or SIPS URI.",
      "ja": "TELのURL（RFC 2806 [9]）SIPに変換するか、URI、任意のパラメータを含むTELのURLの全体の電話加入者の部分を、SIPSされた場合、SIPのユーザ情報部分内に配置されるか、またはURIをSIPSれます。"
    },
    {
      "indent": 3,
      "text": "Thus, tel:+358-555-1234567;postd=pp22 becomes",
      "ja": "したがって、TEL：+ 358-555-1234567; postd = PP22となります"
    },
    {
      "indent": 6,
      "text": "sip:+358-555-1234567;postd=pp22@foo.com;user=phone",
      "ja": "SIP：+ 358-555-1234567; postd=pp22@foo.com;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "or sips:+358-555-1234567;postd=pp22@foo.com;user=phone",
      "ja": "または一口：+ 358-555-1234567; postd=pp22@foo.com;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "not sip:+358-555-1234567@foo.com;postd=pp22;user=phone",
      "ja": "一口ではない：+358-555-1234567@foo.comを、postd = PP22;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 6,
      "text": "sips:+358-555-1234567@foo.com;postd=pp22;user=phone",
      "ja": "一口：+358-555-1234567@foo.com; postd =のPP22;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "In general, equivalent \"tel\" URLs converted to SIP or SIPS URIs in this fashion may not produce equivalent SIP or SIPS URIs. The userinfo of SIP and SIPS URIs are compared as a case-sensitive string. Variance in case-insensitive portions of tel URLs and reordering of tel URL parameters does not affect tel URL equivalence, but does affect the equivalence of SIP URIs formed from them.",
      "ja": "一般に、同等の「TEL」URLは同等SIPまたはSIPS URIを生成しないことがあり、この方法でSIPに変換またはSIPS URIを。 SIPとSIPS URIのユーザー情報は、大文字と小文字を区別した文字列として比較されます。 TEL URLとのtel URLパラメータの並べ替えの大文字と小文字を区別しない部分での分散は、TELのURLの等価性には影響を与えませんが、それらから形成されたSIP URIの等価性に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 6,
      "text": "tel:+358-555-1234567;postd=pp22 tel:+358-555-1234567;POSTD=PP22",
      "ja": "TEL：+ 358-555-1234567;ポツダムPP22 = TEL：+ 358-555-1234567;ポツダム= PP22"
    },
    {
      "indent": 3,
      "text": "are equivalent, while",
      "ja": "しばらく等価です"
    },
    {
      "indent": 6,
      "text": "sip:+358-555-1234567;postd=pp22@foo.com;user=phone sip:+358-555-1234567;POSTD=PP22@foo.com;user=phone",
      "ja": "SIP：+ 358-555-1234567; postd=pp22@foo.com;ユーザー=電話SIP：+ 358-555-1234567; POSTD=PP22@foo.com;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "are not.",
      "ja": "ありません。"
    },
    {
      "indent": 3,
      "text": "Likewise,",
      "ja": "同様に、"
    },
    {
      "indent": 6,
      "text": "tel:+358-555-1234567;postd=pp22;isub=1411 tel:+358-555-1234567;isub=1411;postd=pp22",
      "ja": "TEL：+ 358-555-1234567;ポスト= PP 22; Isubは= 1411 TEL：+ 358-555-1234567; Isubは= 1411;ポスト= PP 22"
    },
    {
      "indent": 3,
      "text": "are equivalent, while",
      "ja": "しばらく等価です"
    },
    {
      "indent": 6,
      "text": "sip:+358-555-1234567;postd=pp22;isub=1411@foo.com;user=phone sip:+358-555-1234567;isub=1411;postd=pp22@foo.com;user=phone",
      "ja": "SIP：+ 358-555-1234567; postd = PP22; isub=1411@foo.com;ユーザー=電話SIP：+ 358-555-1234567; Isubは= 1411; postd=pp22@foo.com;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "are not.",
      "ja": "ありません。"
    },
    {
      "indent": 3,
      "text": "To mitigate this problem, elements constructing telephone-subscriber fields to place in the userinfo part of a SIP or SIPS URI SHOULD fold any case-insensitive portion of telephone-subscriber to lower case, and order the telephone-subscriber parameters lexically by parameter name, excepting isdn-subaddress and post-dial, which occur first and in that order. (All components of a tel URL except for future-extension parameters are defined to be compared case-insensitive.)",
      "ja": "この問題を軽減するために、要素は、SIPのユーザ情報部分に配置する電話加入者フィールドを構築またはURIが小文字に電話加入者の任意の大文字と小文字を区別しない部分を折り、パラメータ名で辞書的に電話加入者パラメータを注文するべきであるSIPS ISDN-サブアドレスとポストダイヤルを除く、第一の順に発生します。 （将来拡張パラメータ以外のTEL URLのすべてのコンポーネントは大文字と小文字を区別しない比較することと定義されます。）"
    },
    {
      "indent": 3,
      "text": "Following this suggestion, both",
      "ja": "両方とも、この提案に続き"
    },
    {
      "indent": 6,
      "text": "tel:+358-555-1234567;postd=pp22 tel:+358-555-1234567;POSTD=PP22",
      "ja": "TEL：+ 358-555-1234567;ポツダムPP22 = TEL：+ 358-555-1234567;ポツダム= PP22"
    },
    {
      "indent": 6,
      "text": "become",
      "ja": "なります"
    },
    {
      "indent": 8,
      "text": "sip:+358-555-1234567;postd=pp22@foo.com;user=phone",
      "ja": "SIP：+ 358-555-1234567; postd=pp22@foo.com;ユーザー=電話"
    },
    {
      "indent": 3,
      "text": "and both",
      "ja": "両方"
    },
    {
      "indent": 8,
      "text": "tel:+358-555-1234567;tsp=a.b;phone-context=5\ntel:+358-555-1234567;phone-context=5;tsp=a.b",
      "raw": true
    },
    {
      "indent": 6,
      "text": "become",
      "ja": "なります"
    },
    {
      "indent": 8,
      "text": "sip:+358-555-1234567;phone-context=5;tsp=a.b@foo.com;user=phone",
      "ja": "SIP：+ 358-555-1234567、電話コンテキスト= 5; tsp=a.b@foo.com;ユーザー=電話"
    },
    {
      "indent": 0,
      "text": "19.2 Option Tags",
      "section_title": true,
      "ja": "19.2オプションタグ"
    },
    {
      "indent": 3,
      "text": "Option tags are unique identifiers used to designate new options (extensions) in SIP. These tags are used in Require (Section 20.32), Proxy-Require (Section 20.29), Supported (Section 20.37) and Unsupported (Section 20.40) header fields. Note that these options appear as parameters in those header fields in an option-tag = token form (see Section 25 for the definition of token).",
      "ja": "オプションタグはSIPの新しいオプション（拡張）を指定するために使用される一意の識別子です。これらのタグは、で使用される（セクション20.32）、プロキシ要求（セクション20.29）、サポートされている（セクション20.37）およびサポートされていない（セクション20.40）ヘッダーフィールドを必要とします。これらのオプションは、（トークンの定義については、セクション25を参照）オプションタグ=トークンの形でそれらのヘッダフィールドのパラメータとして現れることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Option tags are defined in standards track RFCs. This is a change from past practice, and is instituted to ensure continuing multi-vendor interoperability (see discussion in Section 20.32 and Section 20.37). An IANA registry of option tags is used to ensure easy reference.",
      "ja": "オプションタグは、標準化トラックのRFCで定義されています。これは過去の慣行から変更され、そして（セクション20.32とセクション20.37での議論を参照）継続マルチベンダーの相互運用性を確保するために制定されました。オプションタグのIANAレジストリが簡単に参照を確実にするために使用されます。"
    },
    {
      "indent": 0,
      "text": "19.3 Tags",
      "section_title": true,
      "ja": "19.3タグ"
    },
    {
      "indent": 3,
      "text": "The \"tag\" parameter is used in the To and From header fields of SIP messages. It serves as a general mechanism to identify a dialog, which is the combination of the Call-ID along with two tags, one from each participant in the dialog. When a UA sends a request outside of a dialog, it contains a From tag only, providing \"half\" of the dialog ID. The dialog is completed from the response(s), each of which contributes the second half in the To header field. The forking of SIP requests means that multiple dialogs can be established from a single request. This also explains the need for the two-sided dialog identifier; without a contribution from the recipients, the originator could not disambiguate the multiple dialogs established from a single request.",
      "ja": "「タグ」パラメータにし、SIPメッセージのヘッダフィールドから使用されています。これは、2個のタグ、ダイアログの各参加者からの1つと共にコール-IDの組み合わせであるダイアログを識別するための一般的な機構として役立ちます。 UAは、ダイアログの外に要求を送信すると、それは、ダイアログIDの「半分」を提供する、唯一のタグから含まれています。ダイアログは、ヘッダのフィールドに後半に寄与する各々が応答（S）から完了する。 SIPリクエストのフォークは、複数のダイアログが単一の要求から確立することができることを意味します。また、これは両面ダイアログ識別子の必要性を説明します。受信者からの寄与せずに、発信者は、単一の要求から確立された複数のダイアログを明確にできませんでした。"
    },
    {
      "indent": 3,
      "text": "When a tag is generated by a UA for insertion into a request or response, it MUST be globally unique and cryptographically random with at least 32 bits of randomness. A property of this selection requirement is that a UA will place a different tag into the From header of an INVITE than it would place into the To header of the response to the same INVITE. This is needed in order for a UA to invite itself to a session, a common case for \"hairpinning\" of calls in PSTN gateways. Similarly, two INVITEs for different calls will have different From tags, and two responses for different calls will have different To tags.",
      "ja": "タグは、要求または応答の中への挿入のためにUAによって生成されたとき、それはグローバルに一意と乱数の少なくとも32ビットの暗号ランダムでなければなりません。この選択要件のプロパティは、UAは、それがINVITE同じに対する応答のヘッダにに入れるであろうよりも、INVITEのFromヘッダに異なるタグを配置することです。これは、UAは、セッションにPSTNゲートウェイのコールの「ヘアピン」のための一般的なケースを自分自身を招待するために必要とされています。同様に、別の呼び出しのための2つのINVITEは、タグは異なる必要があります、そして異なる呼び出しのための2つの応答は、タグに異なっています。"
    },
    {
      "indent": 3,
      "text": "Besides the requirement for global uniqueness, the algorithm for generating a tag is implementation-specific. Tags are helpful in fault tolerant systems, where a dialog is to be recovered on an alternate server after a failure. A UAS can select the tag in such a way that a backup can recognize a request as part of a dialog on the failed server, and therefore determine that it should attempt to recover the dialog and any other state associated with it.",
      "ja": "グローバル一意性のための要件に加えて、タグを生成するためのアルゴリズムは、実装固有です。タグは、ダイアログが失敗した後、代替サーバー上に回復するフォールトトレラントシステム、に役立ちます。 UASは、バックアップが失敗したサーバー上のダイアログの一部として要求を認識し、そのためには、ダイアログとそれに関連する他の状態を回復しようとすべきであると決定することができるような方法でタグを選択することができます。"
    },
    {
      "indent": 0,
      "text": "20 Header Fields",
      "ja": "20のヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The general syntax for header fields is covered in Section 7.3. This section lists the full set of header fields along with notes on syntax, meaning, and usage. Throughout this section, we use [HX.Y] to refer to Section X.Y of the current HTTP/1.1 specification RFC 2616 [8]. Examples of each header field are given.",
      "ja": "ヘッダフィールドの一般的な構文はセクション7.3でカバーされています。このセクションでは、構文、意味、および用法上の注意事項と一緒にヘッダフィールドのフルセットを示しています。このセクション全体を通して、我々は、現在のHTTP / 1.1仕様RFC 2616のセクションX.Yを参照するために[HX.Y]に[8]。各ヘッダフィールドの例が示されています。"
    },
    {
      "indent": 3,
      "text": "Information about header fields in relation to methods and proxy processing is summarized in Tables 2 and 3.",
      "ja": "方法およびプロキシ処理に関連するヘッダ・フィールドについての情報は、表2および3に要約されています。"
    },
    {
      "indent": 3,
      "text": "The \"where\" column describes the request and response types in which the header field can be used. Values in this column are:",
      "ja": "「ここ」の列は、ヘッダーフィールドが使用可能な要求および応答の種類を記載しています。この列の値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "R: header field may only appear in requests;",
      "ja": "R：ヘッダフィールドは、リクエストのみに現れてもよいです。"
    },
    {
      "indent": 6,
      "text": "r: header field may only appear in responses;",
      "ja": "R：ヘッダフィールドは、応答に現れてもよいです。"
    },
    {
      "indent": 6,
      "text": "2xx, 4xx, etc.: A numerical value or range indicates response codes with which the header field can be used;",
      "ja": "2XX、4XX、等：数値または範囲がヘッダフィールドを使用することができると応答コードを示します。"
    },
    {
      "indent": 6,
      "text": "c: header field is copied from the request to the response.",
      "ja": "C：ヘッダフィールドは、応答をリクエストからコピーされます。"
    },
    {
      "indent": 6,
      "text": "An empty entry in the \"where\" column indicates that the header field may be present in all requests and responses.",
      "ja": "「」内の空きエントリは、列ヘッダフィールドは、すべての要求と応答に存在してもよいことを示しています。"
    },
    {
      "indent": 3,
      "text": "The \"proxy\" column describes the operations a proxy may perform on a header field:",
      "ja": "「プロキシ」の列は、プロキシがヘッダーフィールドに実行できる操作について説明します。"
    },
    {
      "indent": 6,
      "text": "a: A proxy can add or concatenate the header field if not present.",
      "ja": "A：プロキシが存在しない場合ヘッダフィールドを追加したり、連結することができます。"
    },
    {
      "indent": 6,
      "text": "m: A proxy can modify an existing header field value.",
      "ja": "M：プロキシは既存のヘッダフィールド値を変更することができます。"
    },
    {
      "indent": 6,
      "text": "d: A proxy can delete a header field value.",
      "ja": "D：プロキシはヘッダーフィールド値を削除することができます。"
    },
    {
      "indent": 6,
      "text": "r: A proxy must be able to read the header field, and thus this header field cannot be encrypted.",
      "ja": "R：プロキシはヘッダーフィールドを読み取ることができなければならないので、このヘッダーフィールドは、暗号化することができません。"
    },
    {
      "indent": 3,
      "text": "The next six columns relate to the presence of a header field in a method:",
      "ja": "次の6つの列は、メソッドのヘッダフィールドの存在に関係します。"
    },
    {
      "indent": 6,
      "text": "c: Conditional; requirements on the header field depend on the context of the message.",
      "ja": "C：条件付き。ヘッダフィールド上の要件は、メッセージの文脈に依存します。"
    },
    {
      "indent": 6,
      "text": "m: The header field is mandatory.",
      "ja": "M：ヘッダフィールドは必須です。"
    },
    {
      "indent": 6,
      "text": "m*: The header field SHOULD be sent, but clients/servers need to be prepared to receive messages without that header field.",
      "ja": "M *：ヘッダフィールドを送ってくださいますが、クライアント/サーバは、そのヘッダフィールドなしでメッセージを受信する準備する必要があります。"
    },
    {
      "indent": 6,
      "text": "o: The header field is optional.",
      "ja": "O：ヘッダーフィールドはオプションです。"
    },
    {
      "indent": 6,
      "text": "t: The header field SHOULD be sent, but clients/servers need to be prepared to receive messages without that header field.",
      "ja": "T：ヘッダフィールドを送ってくださいますが、クライアント/サーバは、そのヘッダフィールドなしでメッセージを受信するために準備する必要があります。"
    },
    {
      "indent": 11,
      "text": "If a stream-based protocol (such as TCP) is used as a\ntransport, then the header field MUST be sent.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "*: The header field is required if the message body is not empty. See Sections 20.14, 20.15 and 7.4 for details.",
      "ja": "*：メッセージ本体が空でない場合、ヘッダフィールドが必要です。詳細については、セクション20.14、20.15と7.4を参照してください。"
    },
    {
      "indent": 6,
      "text": "-: The header field is not applicable.",
      "ja": " - ：ヘッダーフィールドは適用されません。"
    },
    {
      "indent": 3,
      "text": "\"Optional\" means that an element MAY include the header field in a request or response, and a UA MAY ignore the header field if present in the request or response (The exception to this rule is the Require header field discussed in 20.32). A \"mandatory\" header field MUST be present in a request, and MUST be understood by the UAS receiving the request. A mandatory response header field MUST be present in the response, and the header field MUST be understood by the UAC processing the response. \"Not applicable\" means that the header field MUST NOT be present in a request. If one is placed in a request by mistake, it MUST be ignored by the UAS receiving the request. Similarly, a header field labeled \"not applicable\" for a response means that the UAS MUST NOT place the header field in the response, and the UAC MUST ignore the header field in the response.",
      "ja": "「オプション」は、要素は、要求または応答のヘッダフィールドを含んでもよく、存在する場合、UAは（この規則の例外は20.32で説明したRequireヘッダーフィールドで）要求または応答のヘッダフィールドを無視することを意味します。 「必須」ヘッダフィールドは要求に存在していなければなりません、との要求を受信UASによって理解されなければなりません。必須の応答ヘッダフィールドは、応答中に存在していなければなりません、そしてヘッダフィールドは、応答を処理するUACによって理解されなければなりません。 「該当なし」ヘッダーフィールドがリクエストに存在してはならないことを意味しています。 1が誤って要求に配置されている場合は、その要求を受けUASによって無視されなければなりません。同様に、応答は、「該当しない」とラベル付けされたヘッダフィールドは、UASが応答してヘッダーフィールドを配置してはならず、およびUACが応答でヘッダーフィールドを無視しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "A UA SHOULD ignore extension header parameters that are not understood.",
      "ja": "UAは理解されていない拡張ヘッダパラメータを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "A compact form of some common header field names is also defined for use when overall message size is an issue.",
      "ja": "メッセージ全体のサイズが問題である場合、いくつかの共通ヘッダフィールド名のコンパクト形はまた、使用のために定義されています。"
    },
    {
      "indent": 3,
      "text": "The Contact, From, and To header fields contain a URI. If the URI contains a comma, question mark or semicolon, the URI MUST be enclosed in angle brackets (< and >). Any URI parameters are contained within these brackets. If the URI is not enclosed in angle brackets, any semicolon-delimited parameters are header-parameters, not URI parameters.",
      "ja": "連絡先は、から、およびToヘッダフィールドは、URIが含まれています。 URIがカンマ、疑問符またはセミコロンが含まれている場合は、URIは、山括弧（<と>）で囲む必要があります。任意のURIパラメータは、これらの括弧内に収容されています。 URIは、角括弧で囲まれていない場合、任意のセミコロンで区切られたパラメータは、ヘッダパラメータはなく、URIパラメータです。"
    },
    {
      "indent": 0,
      "text": "20.1 Accept",
      "section_title": true,
      "ja": "20.1受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept header field follows the syntax defined in [H14.1]. The semantics are also identical, with the exception that if no Accept header field is present, the server SHOULD assume a default value of application/sdp.",
      "ja": "Acceptヘッダーフィールドは[H14.1]で定義された構文に従います。セマンティクスにはAcceptヘッダーフィールドが存在しない場合、サーバは、アプリケーション/ SDPのデフォルト値をとるべきであることを除いて、また同じです。"
    },
    {
      "indent": 3,
      "text": "An empty Accept header field means that no formats are acceptable.",
      "ja": "空のAcceptヘッダーフィールドには形式が許容されないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Header field          where   proxy ACK BYE CAN INV OPT REG\n___________________________________________________________\nAccept                  R            -   o   -   o   m*  o\nAccept                 2xx           -   -   -   o   m*  o\nAccept                 415           -   c   -   c   c   c\nAccept-Encoding         R            -   o   -   o   o   o\nAccept-Encoding        2xx           -   -   -   o   m*  o\nAccept-Encoding        415           -   c   -   c   c   c\nAccept-Language         R            -   o   -   o   o   o\nAccept-Language        2xx           -   -   -   o   m*  o\nAccept-Language        415           -   c   -   c   c   c\nAlert-Info              R      ar    -   -   -   o   -   -\nAlert-Info             180     ar    -   -   -   o   -   -\nAllow                   R            -   o   -   o   o   o\nAllow                  2xx           -   o   -   m*  m*  o\nAllow                   r            -   o   -   o   o   o\nAllow                  405           -   m   -   m   m   m\nAuthentication-Info    2xx           -   o   -   o   o   o\nAuthorization           R            o   o   o   o   o   o\nCall-ID                 c       r    m   m   m   m   m   m\nCall-Info                      ar    -   -   -   o   o   o\nContact                 R            o   -   -   m   o   o\nContact                1xx           -   -   -   o   -   -\nContact                2xx           -   -   -   m   o   o\nContact                3xx      d    -   o   -   o   o   o\nContact                485           -   o   -   o   o   o\nContent-Disposition                  o   o   -   o   o   o\nContent-Encoding                     o   o   -   o   o   o\nContent-Language                     o   o   -   o   o   o\nContent-Length                 ar    t   t   t   t   t   t\nContent-Type                         *   *   -   *   *   *\nCSeq                    c       r    m   m   m   m   m   m\nDate                            a    o   o   o   o   o   o\nError-Info           300-699    a    -   o   o   o   o   o\nExpires                              -   -   -   o   -   o\nFrom                    c       r    m   m   m   m   m   m\nIn-Reply-To             R            -   -   -   o   -   -\nMax-Forwards            R      amr   m   m   m   m   m   m\nMin-Expires            423           -   -   -   -   -   m\nMIME-Version                         o   o   -   o   o   o\nOrganization                   ar    -   -   -   o   o   o",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Table 2: Summary of header fields, A--O",
      "ja": "表2：ヘッダフィールドの概要、A  -  O"
    },
    {
      "indent": 3,
      "text": "Header field              where       proxy ACK BYE CAN INV OPT REG\n___________________________________________________________________\nPriority                    R          ar    -   -   -   o   -   -\nProxy-Authenticate         407         ar    -   m   -   m   m   m\nProxy-Authenticate         401         ar    -   o   o   o   o   o\nProxy-Authorization         R          dr    o   o   -   o   o   o\nProxy-Require               R          ar    -   o   -   o   o   o\nRecord-Route                R          ar    o   o   o   o   o   -\nRecord-Route             2xx,18x       mr    -   o   o   o   o   -\nReply-To                                     -   -   -   o   -   -\nRequire                                ar    -   c   -   c   c   c\nRetry-After          404,413,480,486         -   o   o   o   o   o\n                         500,503             -   o   o   o   o   o\n                         600,603             -   o   o   o   o   o\nRoute                       R          adr   c   c   c   c   c   c\nServer                      r                -   o   o   o   o   o\nSubject                     R                -   -   -   o   -   -\nSupported                   R                -   o   o   m*  o   o\nSupported                  2xx               -   o   o   m*  m*  o\nTimestamp                                    o   o   o   o   o   o\nTo                        c(1)          r    m   m   m   m   m   m\nUnsupported                420               -   m   -   m   m   m\nUser-Agent                                   o   o   o   o   o   o\nVia                         R          amr   m   m   m   m   m   m\nVia                        rc          dr    m   m   m   m   m   m\nWarning                     r                -   o   o   o   o   o\nWWW-Authenticate           401         ar    -   m   -   m   m   m\nWWW-Authenticate           407         ar    -   o   -   o   o   o",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 3: Summary of header fields, P--Z; (1): copied with possible addition of tag",
      "ja": "表3：ヘッダフィールドの概要、P  -  Z。 （1）：タグの可能加えてコピー"
    },
    {
      "indent": 6,
      "text": "Accept: application/sdp;level=1, application/x-private, text/html",
      "ja": "受け入れ：アプリケーション/ SDPと、レベル= 1、アプリケーション/ X-プライベート、テキスト/ HTML"
    },
    {
      "indent": 0,
      "text": "20.2 Accept-Encoding",
      "section_title": true,
      "ja": "20.2のAccept-エンコーディング"
    },
    {
      "indent": 3,
      "text": "The Accept-Encoding header field is similar to Accept, but restricts the content-codings [H3.5] that are acceptable in the response. See [H14.3]. The semantics in SIP are identical to those defined in [H14.3].",
      "ja": "Accept-Encodingヘッダフィールドは、そのまま使用することが同様であるが、応答に許容される内容コーディング[H3.5]を制限します。 [H14.3]を参照してください。 SIP内のセマンティクスは[H14.3]で定義されたものと同一です。"
    },
    {
      "indent": 3,
      "text": "An empty Accept-Encoding header field is permissible. It is equivalent to Accept-Encoding: identity, that is, only the identity encoding, meaning no encoding, is permissible.",
      "ja": "空のAccept-Encodingヘッダフィールドは許容されます。それは、受け入れエンコードすることと等価である：アイデンティティを、つまり、唯一のアイデンティティエンコーディング、何のエンコーディングを意味しない、許されます。"
    },
    {
      "indent": 3,
      "text": "If no Accept-Encoding header field is present, the server SHOULD assume a default value of identity.",
      "ja": "何のAccept-Encodingヘッダフィールドが存在しない場合、サーバは身元のデフォルト値を想定すべきです。"
    },
    {
      "indent": 3,
      "text": "This differs slightly from the HTTP definition, which indicates that when not present, any encoding can be used, but the identity encoding is preferred.",
      "ja": "これが存在する場合ではない、任意の符号化を使用することができることを示すHTTP定義からわずかに異なるが、同一のエンコードが好ましいです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Accept-Encoding: gzip",
      "ja": "受け入れエンコード：gzipで"
    },
    {
      "indent": 0,
      "text": "20.3 Accept-Language",
      "section_title": true,
      "ja": "20.3受け入れ言語"
    },
    {
      "indent": 3,
      "text": "The Accept-Language header field is used in requests to indicate the preferred languages for reason phrases, session descriptions, or status responses carried as message bodies in the response. If no Accept-Language header field is present, the server SHOULD assume all languages are acceptable to the client.",
      "ja": "Accept-Languageヘッダーフィールドは、応答メッセージボディとして運ば理由フレーズ、セッション記述、またはステータス応答のための好ましい言語を示すために、要求に使用されます。何のAccept-Languageヘッダーフィールドが存在しない場合、サーバーはすべての言語がクライアントに受け入れられると想定すべきです。"
    },
    {
      "indent": 3,
      "text": "The Accept-Language header field follows the syntax defined in [H14.4]. The rules for ordering the languages based on the \"q\" parameter apply to SIP as well.",
      "ja": "Accept-Languageヘッダーフィールドは[H14.4]で定義された構文に従います。 「Q」パラメータに基づいて言語を注文するためのルールも同様にSIPに適用されます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Accept-Language: da, en-gb;q=0.8, en;q=0.7",
      "ja": "受け入れ-言語：DA、EN-GB; Q = 0.8、EN; Q = 0.7"
    },
    {
      "indent": 0,
      "text": "20.4 Alert-Info",
      "section_title": true,
      "ja": "20.4アラート情報"
    },
    {
      "indent": 3,
      "text": "When present in an INVITE request, the Alert-Info header field specifies an alternative ring tone to the UAS. When present in a 180 (Ringing) response, the Alert-Info header field specifies an alternative ringback tone to the UAC. A typical usage is for a proxy to insert this header field to provide a distinctive ring feature.",
      "ja": "存在する場合、INVITEリクエストで、Alert-InfoヘッダーフィールドはUASの代替着信音を指定します。場合180（リンギング）応答中に存在する、Alert-Infoヘッダーフィールドは、UACに代わるリングバック・トーンを特定します。典型的な使用は、着信音機能を提供するために、このヘッダフィールドを挿入するためのプロキシのためのものです。"
    },
    {
      "indent": 3,
      "text": "The Alert-Info header field can introduce security risks. These risks and the ways to handle them are discussed in Section 20.9, which discusses the Call-Info header field since the risks are identical.",
      "ja": "Alert-Infoヘッダーフィールドはセキュリティリスクを導入することができます。これらのリスクおよびそれらを処理する方法は、リスクが同じであるため、コール-Infoヘッダーフィールドを説明し、セクション20.9で議論されています。"
    },
    {
      "indent": 3,
      "text": "In addition, a user SHOULD be able to disable this feature selectively.",
      "ja": "また、ユーザーが選択、この機能を無効にすることができるべきです。"
    },
    {
      "indent": 6,
      "text": "This helps prevent disruptions that could result from the use of this header field by untrusted elements.",
      "ja": "これは信頼されていない要素によって、このヘッダフィールドの使用から生じる可能性が混乱を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Alert-Info: <http://www.example.com/sounds/moo.wav>",
      "ja": "アラート情報：<http://www.example.com/sounds/moo.wav>"
    },
    {
      "indent": 0,
      "text": "20.5 Allow",
      "section_title": true,
      "ja": "20.5許可"
    },
    {
      "indent": 3,
      "text": "The Allow header field lists the set of methods supported by the UA generating the message.",
      "ja": "許可ヘッダフィールドは、メッセージを生成するUAによってサポートされるメソッドのセットを一覧表示します。"
    },
    {
      "indent": 3,
      "text": "All methods, including ACK and CANCEL, understood by the UA MUST be included in the list of methods in the Allow header field, when present. The absence of an Allow header field MUST NOT be interpreted to mean that the UA sending the message supports no methods. Rather, it implies that the UA is not providing any information on what methods it supports.",
      "ja": "存在する場合UAによって理解ACKおよびCANCEL、を含むすべての方法は、許可ヘッダーフィールド内のメソッドのリストに含まれなければなりません。許可ヘッダフィールドが存在しない場合は、メッセージを送信するUAはない方法をサポートしないことを意味すると解釈されてはいけません。むしろ、それは、UAは、それがサポートする方法上の任意の情報を提供していないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Supplying an Allow header field in responses to methods other than OPTIONS reduces the number of messages needed.",
      "ja": "OPTIONS以外の方法への応答で許可ヘッダーフィールドを供給する必要のメッセージ数を減少させます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Allow: INVITE, ACK, OPTIONS, CANCEL, BYE",
      "ja": "許可：、ACK、OPTIONSをINVITE、CANCEL、BYE"
    },
    {
      "indent": 0,
      "text": "20.6 Authentication-Info",
      "section_title": true,
      "ja": "20.6認証-情報"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header field provides for mutual authentication with HTTP Digest. A UAS MAY include this header field in a 2xx response to a request that was successfully authenticated using digest based on the Authorization header field.",
      "ja": "認証-Infoヘッダフィールドは、HTTPダイジェストとの相互認証を提供します。 UASは、正常Authorizationヘッダフィールドに基づいてダイジェスト用いて認証された要求への2xx応答してこのヘッダーフィールドを含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "Syntax and semantics follow those specified in RFC 2617 [17].",
      "ja": "構文とセマンティクスは、RFC 2617 [17]で指定されたものに従ってください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Authentication-Info: nextnonce=\"47364c23432d2e131a5fb210812c\"",
      "ja": "認証-情報：nextnonce = \"47364c23432d2e131a5fb210812c\""
    },
    {
      "indent": 0,
      "text": "20.7 Authorization",
      "section_title": true,
      "ja": "20.7認証"
    },
    {
      "indent": 3,
      "text": "The Authorization header field contains authentication credentials of a UA. Section 22.2 overviews the use of the Authorization header field, and Section 22.4 describes the syntax and semantics when used with HTTP authentication.",
      "ja": "Authorizationヘッダフィールドは、UAの認証資格情報が含まれています。セクション22.2は、Authorizationヘッダフィールドの使用を概観し、HTTP認証で使用される場合セクション22.4構文と意味論を記載しています。"
    },
    {
      "indent": 3,
      "text": "This header field, along with Proxy-Authorization, breaks the general rules about multiple header field values. Although not a comma-separated list, this header field name may be present multiple times, and MUST NOT be combined into a single header line using the usual rules described in Section 7.3.",
      "ja": "このヘッダーフィールドは、プロキシ認証と共に、複数のヘッダフィールド値に関する一般的な規則を破ります。ないカンマ区切りのリストが、このヘッダーフィールド名が複数回存在してもよく、および7.3節に記載の通常のルールを使用して、単一のヘッダ行に結合されてはいけません。"
    },
    {
      "indent": 3,
      "text": "In the example below, there are no quotes around the Digest parameter:",
      "ja": "以下の例では、ダイジェストパラメータの前後に引用符はありません。"
    },
    {
      "indent": 6,
      "text": "Authorization: Digest username=\"Alice\", realm=\"atlanta.com\", nonce=\"84a4cc6f3082121f32b42a2187831a9e\", response=\"7587245234b3434cc3412213e5f113a5432\"",
      "ja": "認証：ユーザ名= \"アリス\" をダイジェストレルム= \"atlanta.com\"、= \"84a4cc6f3082121f32b42a2187831a9e\" ナンス、レスポンス= \"7587245234b3434cc3412213e5f113a5432\""
    },
    {
      "indent": 0,
      "text": "20.8 Call-ID",
      "section_title": true,
      "ja": "20.8コールID"
    },
    {
      "indent": 3,
      "text": "The Call-ID header field uniquely identifies a particular invitation or all registrations of a particular client. A single multimedia conference can give rise to several calls with different Call-IDs, for example, if a user invites a single individual several times to the same (long-running) conference. Call-IDs are case-sensitive and are simply compared byte-by-byte.",
      "ja": "Call-IDヘッダーフィールドは、一意に特定の招待または特定のクライアントのすべての登録を識別する。ユーザーが同じ（長時間実行）会議に単一の個人、数回を誘う場合は、単一のマルチメディア会議は、例えば、異なるコールIDを持ついくつかのコールを生じさせることができます。コールIDは大文字と小文字が区別され、単純にバイトごとに比較されています。"
    },
    {
      "indent": 3,
      "text": "The compact form of the Call-ID header field is i.",
      "ja": "Call-IDヘッダーフィールドのコンパクト形はIです。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Call-ID: f81d4fae-7dec-11d0-a765-00a0c91e6bf6@biloxi.com i:f81d4fae-7dec-11d0-a765-00a0c91e6bf6@192.0.2.4",
      "ja": "コールIDを：f81d4fae-7dec-11d0-a765-00a0c91e6bf6@biloxi.com I：f81d4fae-7dec-11d0-a765-00a0c91e6bf6@192.0.2.4"
    },
    {
      "indent": 0,
      "text": "20.9 Call-Info",
      "section_title": true,
      "ja": "20.9コール情報"
    },
    {
      "indent": 3,
      "text": "The Call-Info header field provides additional information about the caller or callee, depending on whether it is found in a request or response. The purpose of the URI is described by the \"purpose\" parameter. The \"icon\" parameter designates an image suitable as an iconic representation of the caller or callee. The \"info\" parameter describes the caller or callee in general, for example, through a web page. The \"card\" parameter provides a business card, for example, in vCard [36] or LDIF [37] formats. Additional tokens can be registered using IANA and the procedures in Section 27.",
      "ja": "コール-Infoヘッダフィールド、それが要求または応答に見出されるかどうかに応じて、発呼者又は被呼者に関する追加情報を提供します。 URIの目的は、「目的」パラメータによって記述されています。 「アイコン」パラメータは、発呼者又は被呼者の象徴的な表現として適切な画像を示します。 「情報」パラメータは、Webページを介して、例えば、一般的には、発信者や呼び出し先を記述する。 「カード」パラメータは、例えば、vCardの中[36]またはLDIF [37]の形式を名刺を提供します。追加のトークンはIANAとセクション27の手順を使用して登録することができます。"
    },
    {
      "indent": 3,
      "text": "Use of the Call-Info header field can pose a security risk. If a callee fetches the URIs provided by a malicious caller, the callee may be at risk for displaying inappropriate or offensive content, dangerous or illegal content, and so on. Therefore, it is RECOMMENDED that a UA only render the information in the Call-Info header field if it can verify the authenticity of the element that originated the header field and trusts that element. This need not be the peer UA; a proxy can insert this header field into requests.",
      "ja": "コール-Infoヘッダーフィールドを使用すると、セキュリティ上のリスクをもたらすことができます。被呼者が悪意のある呼び出し元によって提供されるURIを取り出す場合、着呼側はこれに不適切または不快なコンテンツを表示するためのリスク、危険または違法なコンテンツ、およびであってもよいです。したがって、ヘッダフィールドを発信し、その要素を信頼要素の真正性を検証することができる場合UAのみコール-Infoヘッダフィールド内の情報をレンダリングすることが推奨されます。これは、ピアUAである必要はありません。プロキシはリクエストにこのヘッダフィールドを挿入することができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Call-Info: <http://wwww.example.com/alice/photo.jpg> ;purpose=icon, <http://www.example.com/alice/> ;purpose=info",
      "ja": "コール情報：<http://wwww.example.com/alice/photo.jpg>;目的=アイコン、<http://www.example.com/alice/>;目的=情報"
    },
    {
      "indent": 0,
      "text": "20.10 Contact",
      "section_title": true,
      "ja": "20.10問い合わせ"
    },
    {
      "indent": 3,
      "text": "A Contact header field value provides a URI whose meaning depends on the type of request or response it is in.",
      "ja": "Contactヘッダーフィールド値は、その意味は、それが中にある要求または応答のタイプに依存するURIを提供します。"
    },
    {
      "indent": 3,
      "text": "A Contact header field value can contain a display name, a URI with URI parameters, and header parameters.",
      "ja": "Contactヘッダーフィールド値は、表示名、URIパラメータ、およびヘッダーパラメータを使用してURIを含むことができます。"
    },
    {
      "indent": 3,
      "text": "This document defines the Contact parameters \"q\" and \"expires\". These parameters are only used when the Contact is present in a REGISTER request or response, or in a 3xx response. Additional parameters may be defined in other specifications.",
      "ja": "この文書では、連絡先パラメータ「q」を定義し、「期限が切れます」。これらのパラメータは、唯一の連絡先は、REGISTER要求や応答、または3xx応答中に存在する場合に使用されています。追加のパラメータは、他の仕様で定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "When the header field value contains a display name, the URI including all URI parameters is enclosed in \"<\" and \">\". If no \"<\" and \">\" are present, all parameters after the URI are header parameters, not URI parameters. The display name can be tokens, or a quoted string, if a larger character set is desired.",
      "ja": "ヘッダフィールド値が表示名が含まれている場合、すべてのURIパラメータを含むURIは、で囲まれた「<」と「>」です。存在しない場合、「<」と「>」、URIの後に全てのパラメータがパラメータではなく、URIパラメータヘッダれます。大きな文字セットが所望される場合は、表示名は、トークン、または引用符で囲んだ文字列を指定できます。"
    },
    {
      "indent": 3,
      "text": "Even if the \"display-name\" is empty, the \"name-addr\" form MUST be used if the \"addr-spec\" contains a comma, semicolon, or question mark. There may or may not be LWS between the display-name and the \"<\".",
      "ja": "「表示名」は空であっても、「ADDR-specは」カンマ、セミコロン、または疑問符が含まれている場合は、「名前-addrに」フォームを使用しなければなりません。または「<」の表示名との間にLWSがあってもなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "These rules for parsing a display name, URI and URI parameters, and header parameters also apply for the header fields To and From.",
      "ja": "これらの表示名を解析するためのルール、URIとURIパラメータ、およびヘッダーパラメータもおよびからヘッダフィールドに適用します。"
    },
    {
      "indent": 6,
      "text": "The Contact header field has a role similar to the Location header field in HTTP. However, the HTTP header field only allows one address, unquoted. Since URIs can contain commas and semicolons as reserved characters, they can be mistaken for header or parameter delimiters, respectively.",
      "ja": "Contactヘッダーフィールドは、HTTPでのLocationヘッダフィールドと同様の役割を持っています。しかし、HTTPヘッダフィールドは、引用符で囲まれていない、一つのアドレスを可能にします。 URIは予約文字としてカンマとセミコロンを含むことができるので、それらはそれぞれ、ヘッダまたはパラメータ区切り文字と間違われることができます。"
    },
    {
      "indent": 3,
      "text": "The compact form of the Contact header field is m (for \"moved\").",
      "ja": "Contactヘッダフィールドのコンパクト形は、（「移動」の場合）mです。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Contact: \"Mr. Watson\" <sip:watson@worcester.bell-telephone.com> ;q=0.7; expires=3600, \"Mr. Watson\" <mailto:watson@bell-telephone.com> ;q=0.1 m: <sips:bob@192.0.2.4>;expires=60",
      "ja": "連絡先： \"氏ワトソン\" <一口：watson@worcester.bell-telephone.com>; Q = 0.7; = 3600、 \"氏ワトソン\" 満了する<のmailto：watson@bell-telephone.com>; Q = 0.1 M：<一口：bob@192.0.2.4>; = 60満了"
    },
    {
      "indent": 0,
      "text": "20.11 Content-Disposition",
      "section_title": true,
      "ja": "20.11のContent-処分"
    },
    {
      "indent": 3,
      "text": "The Content-Disposition header field describes how the message body or, for multipart messages, a message body part is to be interpreted by the UAC or UAS. This SIP header field extends the MIME Content-Type (RFC 2183 [18]).",
      "ja": "コンテンツの廃棄ヘッダーフィールドは、メッセージボディまたは、マルチパートメッセージについて、メッセージボディ部は、UACまたはUASによって解釈する方法を記載しています。このSIPヘッダーフィールドは、MIMEコンテンツタイプを拡張（RFC 2183 [18]）。"
    },
    {
      "indent": 3,
      "text": "Several new \"disposition-types\" of the Content-Disposition header are defined by SIP. The value \"session\" indicates that the body part describes a session, for either calls or early (pre-call) media. The value \"render\" indicates that the body part should be displayed or otherwise rendered to the user. Note that the value \"render\" is used rather than \"inline\" to avoid the connotation that the MIME body is displayed as a part of the rendering of the entire message (since the MIME bodies of SIP messages oftentimes are not displayed to users). For backward-compatibility, if the Content-Disposition header field is missing, the server SHOULD assume bodies of Content-Type application/sdp are the disposition \"session\", while other content types are \"render\".",
      "ja": "Content-Dispositionヘッダーのいくつかの新しい「処分・タイプは、」SIPによって定義されています。値「セッション」は、身体の一部が発信や早期（プリコール）メディアのいずれかのために、セッションを記述していることを示しています。値「レンダリング」は、身体の一部が表示されるか、またはそうでなければユーザにレンダリングされるべきであることを示します。 「レンダリング」値を（SIPメッセージのMIME体はしばしばユーザに表示されないので）MIME本体は全体メッセージのレンダリングの一部として表示されていることを含蓄を回避するためではなく、「インライン」よりも使用されることに留意されたいです。 Content-Dispositionヘッダーフィールドが欠落している場合、下位互換性のために、サーバは、Content-Typeのアプリケーション/ SDPの遺体を前提とすべきである他のコンテンツタイプは、「レンダリング」している一方で、処分「セッション」です。"
    },
    {
      "indent": 3,
      "text": "The disposition type \"icon\" indicates that the body part contains an image suitable as an iconic representation of the caller or callee that could be rendered informationally by a user agent when a message has been received, or persistently while a dialog takes place. The value \"alert\" indicates that the body part contains information, such as an audio clip, that should be rendered by the user agent in an attempt to alert the user to the receipt of a request, generally a request that initiates a dialog; this alerting body could for example be rendered as a ring tone for a phone call after a 180 Ringing provisional response has been sent.",
      "ja": "気質タイプ「アイコン」は、身体の一部がメッセージを受信した場合、またはダイアログが起こる持続しながら、ユーザエージェントによって情報的にレンダリングすることができ、発呼者又は被呼者の象徴的な表現として適切な画像が含まれていることを示しています。値「警告」とは、身体の一部は、一般的に要求、ダイアログを開始する要求の受信をユーザに警告する試みにおいてユーザエージェントによってレンダリングされるべきオーディオクリップ、等の情報が含まれていることを示しています。 180リンギング暫定応答が送信された後に、この警告体は、例えば、電話用の着信音としてレンダリングすることができます。"
    },
    {
      "indent": 3,
      "text": "Any MIME body with a \"disposition-type\" that renders content to the user should only be processed when a message has been properly authenticated.",
      "ja": "メッセージが正しく認証されたときにユーザーにコンテンツをレンダリングする「気質タイプ」のいずれかのMIMEボディのみが処理されるべきです。"
    },
    {
      "indent": 3,
      "text": "The handling parameter, handling-param, describes how the UAS should react if it receives a message body whose content type or disposition type it does not understand. The parameter has defined values of \"optional\" and \"required\". If the handling parameter is missing, the value \"required\" SHOULD be assumed. The handling parameter is described in RFC 3204 [19].",
      "ja": "-PARAMを扱う処理パラメータは、それがそのコンテンツタイプや気質タイプ、それは理解していないメッセージ本文を受信した場合、UASは反応すべき方法を説明します。パラメータは、「オプション」および「必須」の値を定義しています。取り扱いパラメータが欠落している場合は、「必要」値が想定されるべきです。処理パラメータは、RFC 3204 [19]に記載されています。"
    },
    {
      "indent": 3,
      "text": "If this header field is missing, the MIME type determines the default content disposition. If there is none, \"render\" is assumed.",
      "ja": "このヘッダーフィールドが欠落している場合、MIMEタイプがデフォルトのコンテンツの配置を決定します。何も存在しない場合は、「レンダリング」と想定されます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Content-Disposition: session",
      "ja": "コンテンツディスポジション：セッション"
    },
    {
      "indent": 0,
      "text": "20.12 Content-Encoding",
      "section_title": true,
      "ja": "20.12コンテンツのエンコーディング"
    },
    {
      "indent": 3,
      "text": "The Content-Encoding header field is used as a modifier to the \"media-type\". When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms MUST be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a body to be compressed without losing the identity of its underlying media type.",
      "ja": "コンテンツ-Encodingヘッダーフィールドは、「メディアタイプ」の修飾語として使用されます。存在する場合、その値は、追加のコンテンツコーディングが復号メカニズムはContent-Typeヘッダフィールドによって参照されるメディアタイプを得るために適用されなければならないものこうしてエンティティボディに適用されてきたものを示しています。コンテンツのエンコーディングは、主に体がその根底にあるメディアタイプのアイデンティティを失わずに圧縮することができるようにするために使用されます。"
    },
    {
      "indent": 3,
      "text": "If multiple encodings have been applied to an entity-body, the content codings MUST be listed in the order in which they were applied.",
      "ja": "複数のエンコーディングがエンティティボディに適用されている場合は、コンテンツのコーディングは、それらが適用された順にリストされなければなりません。"
    },
    {
      "indent": 3,
      "text": "All content-coding values are case-insensitive. IANA acts as a registry for content-coding value tokens. See [H3.5] for a definition of the syntax for content-coding.",
      "ja": "すべてのコンテンツコーディング値は、大文字と小文字を区別しません。 IANAは、コンテンツコード値トークンのレジストリとして機能します。コンテンツコードの構文の定義については[H3.5]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Clients MAY apply content encodings to the body in requests. A server MAY apply content encodings to the bodies in responses. The server MUST only use encodings listed in the Accept-Encoding header field in the request.",
      "ja": "クライアントがリクエストで、本体へのコンテンツのエンコーディングを適用することができます。サーバは、応答のボディに、コンテンツのエンコーディングを適用することができます。サーバは、要求内のAccept-Encodingヘッダフィールドにリストされたエンコーディングを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The compact form of the Content-Encoding header field is e. Examples:",
      "ja": "コンテンツエンコードヘッダフィールドのコンパクト形はEです。例："
    },
    {
      "indent": 6,
      "text": "Content-Encoding: gzip e: tar",
      "ja": "コンテンツエンコード：gzipでE：タール"
    },
    {
      "indent": 0,
      "text": "20.13 Content-Language",
      "section_title": true,
      "ja": "20.13コンテンツの言語"
    },
    {
      "indent": 3,
      "text": "See [H14.12]. Example:",
      "ja": "[H14.12]を参照してください。例："
    },
    {
      "indent": 6,
      "text": "Content-Language: fr",
      "ja": "コンテンツ言語：FR"
    },
    {
      "indent": 0,
      "text": "20.14 Content-Length",
      "section_title": true,
      "ja": "20.14コンテンツの長さ"
    },
    {
      "indent": 3,
      "text": "The Content-Length header field indicates the size of the message-body, in decimal number of octets, sent to the recipient. Applications SHOULD use this field to indicate the size of the message-body to be transferred, regardless of the media type of the entity. If a stream-based protocol (such as TCP) is used as transport, the header field MUST be used.",
      "ja": "Content-Lengthヘッダフィールドは、受信者に送信されたオクテットの10進数で、メッセージボディのサイズを示します。アプリケーションは関係なく、エンティティのメディアタイプの、転送されるメッセージボディのサイズを示すために、このフィールドを使用すべきです。 （TCPなど）ストリームベースのプロトコルをトランスポートとして使用される場合、ヘッダーフィールドを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The size of the message-body does not include the CRLF separating header fields and body. Any Content-Length greater than or equal to zero is a valid value. If no body is present in a message, then the Content-Length header field value MUST be set to zero.",
      "ja": "メッセージボディのサイズは、ヘッダフィールドと本体とを分離CRLFを含みません。 0以上の任意のContent-Lengthは有効な値です。全く体がメッセージに存在しない場合には、Content-Lengthヘッダフィールド値をゼロに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The ability to omit Content-Length simplifies the creation of cgi-like scripts that dynamically generate responses.",
      "ja": "コンテンツの長さを省略することができるということは、動的応答を生成CGIのようなスクリプトの作成を簡素化します。"
    },
    {
      "indent": 3,
      "text": "The compact form of the header field is l.",
      "ja": "ヘッダフィールドのコンパクト形はlです。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Content-Length: 349 l: 173",
      "ja": "コンテンツの長さ：349リットル：173"
    },
    {
      "indent": 0,
      "text": "20.15 Content-Type",
      "section_title": true,
      "ja": "20.15のContent-Type"
    },
    {
      "indent": 3,
      "text": "The Content-Type header field indicates the media type of the message-body sent to the recipient. The \"media-type\" element is defined in [H3.7]. The Content-Type header field MUST be present if the body is not empty. If the body is empty, and a Content-Type header field is present, it indicates that the body of the specific type has zero length (for example, an empty audio file).",
      "ja": "Content-Typeヘッダフィールドは、受信者に送信されるメッセージボディのメディアタイプを示しています。 「メディアタイプ」エレメントは[H3.7]で定義されています。本体が空でない場合、Content-Typeヘッダフィールドが存在しなければなりません。本体は空で、Content-Typeヘッダフィールドが存在する場合、それは特定のタイプの本体（例えば、空のオーディオファイル）は、ゼロの長さを有することを示しています。"
    },
    {
      "indent": 3,
      "text": "The compact form of the header field is c.",
      "ja": "ヘッダフィールドのコンパクト形はCです。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Content-Type: application/sdp c: text/html; charset=ISO-8859-4",
      "ja": "コンテンツタイプ：アプリケーション/ SDP C：text / htmlの。文字セット= ISO-8859-4"
    },
    {
      "indent": 0,
      "text": "20.16 CSeq",
      "section_title": true,
      "ja": "20.16のCSeq"
    },
    {
      "indent": 3,
      "text": "A CSeq header field in a request contains a single decimal sequence number and the request method. The sequence number MUST be expressible as a 32-bit unsigned integer. The method part of CSeq is case-sensitive. The CSeq header field serves to order transactions within a dialog, to provide a means to uniquely identify transactions, and to differentiate between new requests and request retransmissions. Two CSeq header fields are considered equal if the sequence number and the request method are identical. Example:",
      "ja": "要求におけるCSeqヘッダーフィールドは、単一の進シーケンス番号と、要求メソッドを含みます。シーケンス番号は32ビットの符号なし整数として表現可能でなければなりません。 CSeqの方法の一部は、大文字と小文字が区別されます。 CSeqヘッダーフィールドは、ダイアログ内のトランザクションを注文する一意の取引を識別するための手段を提供すること、及び新しい要求と要求の再送信を区別するのに役立ちます。シーケンス番号とリクエストメソッドが同一である場合、2つのCSeqヘッダーフィールドは等しいと見なされます。例："
    },
    {
      "indent": 6,
      "text": "CSeq: 4711 INVITE",
      "ja": "CSeq：4711 INVITE"
    },
    {
      "indent": 0,
      "text": "20.17 Date",
      "section_title": true,
      "ja": "20.17日"
    },
    {
      "indent": 3,
      "text": "The Date header field contains the date and time. Unlike HTTP/1.1, SIP only supports the most recent RFC 1123 [20] format for dates. As in [H3.3], SIP restricts the time zone in SIP-date to \"GMT\", while RFC 1123 allows any time zone. An RFC 1123 date is case-sensitive.",
      "ja": "Dateヘッダフィールドには、日付と時刻が含まれています。 HTTP / 1.1とは異なり、SIPは、日付のみのために最新のRFC 1123 [20]の形式をサポートしています。 RFC 1123は、任意の時間帯を可能にしながら、[H3.3]のように、SIPは、SIP-日付に「GMT」で時間帯を制限します。 RFC 1123の日付は、大文字と小文字が区別されます。"
    },
    {
      "indent": 3,
      "text": "The Date header field reflects the time when the request or response is first sent.",
      "ja": "日付ヘッダーフィールドは、要求または応答が最初に送信された時刻を反映しています。"
    },
    {
      "indent": 6,
      "text": "The Date header field can be used by simple end systems without a battery-backed clock to acquire a notion of current time. However, in its GMT form, it requires clients to know their offset from GMT.",
      "ja": "日付ヘッダーフィールドは、現在時刻の概念を取得するバッテリバックアップクロックことなく、簡単なエンドシステムで使用することができます。しかし、そのGMT形式で、それは彼らのGMTからのオフセットを知るためにクライアントが必要です。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Date: Sat, 13 Nov 2010 23:29:00 GMT",
      "ja": "日付：土、2010年11月13日23時29分00秒GMT"
    },
    {
      "indent": 0,
      "text": "20.18 Error-Info",
      "section_title": true,
      "ja": "20.18エラー-情報"
    },
    {
      "indent": 3,
      "text": "The Error-Info header field provides a pointer to additional information about the error status response.",
      "ja": "エラー-Infoヘッダフィールドエラーステータス応答に関する追加情報へのポインタを提供します。"
    },
    {
      "indent": 6,
      "text": "SIP UACs have user interface capabilities ranging from pop-up windows and audio on PC softclients to audio-only on \"black\" phones or endpoints connected via gateways. Rather than forcing a server generating an error to choose between sending an error status code with a detailed reason phrase and playing an audio recording, the Error-Info header field allows both to be sent. The UAC then has the choice of which error indicator to render to the caller.",
      "ja": "SIPの求めるUACは、PCのsoftclients上のポップアップウィンドウと音声から音声のみにゲートウェイを介して接続された「黒」の携帯電話またはエンドポイントに及ぶユーザーインターフェイス機能を持っています。むしろ、詳細な理由フレーズとエラーステータスコードを送信し、オーディオ録音を再生する間で選択するとエラー、エラー-Infoヘッダーフィールドを生成するサーバーを強制よりも、両方を送信することができます。 UACは、呼び出し側にレンダリングするためにどのエラーインジケータの選択肢を持っています。"
    },
    {
      "indent": 3,
      "text": "A UAC MAY treat a SIP or SIPS URI in an Error-Info header field as if it were a Contact in a redirect and generate a new INVITE, resulting in a recorded announcement session being established. A non-SIP URI MAY be rendered to the user.",
      "ja": "UACは、SIPを治療するか、リダイレクトで連絡をしたかのようにエラー-InfoヘッダーフィールドにURIをSIPS、確立された録音アナウンスメントセッションで、その結果、新しいINVITEを生成するかもしれません。非SIP URIは、ユーザーにレンダリングすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "SIP/2.0 404 The number you have dialed is not in service Error-Info: <sip:not-in-service-recording@atlanta.com>",
      "ja": "SIP / 2.0 404あなたがダイヤルしている番号は、サービスエラー・情報ではありません。<SIP：not-in-service-recording@atlanta.com>"
    },
    {
      "indent": 0,
      "text": "20.19 Expires",
      "section_title": true,
      "ja": "20.19有効期限"
    },
    {
      "indent": 3,
      "text": "The Expires header field gives the relative time after which the message (or content) expires.",
      "ja": "ヘッダフィールドは、メッセージ（またはコンテンツ）が満了した後の相対時間を与える有効期限。"
    },
    {
      "indent": 3,
      "text": "The precise meaning of this is method dependent.",
      "ja": "これの正確な意味は依存する方法です。"
    },
    {
      "indent": 3,
      "text": "The expiration time in an INVITE does not affect the duration of the actual session that may result from the invitation. Session description protocols may offer the ability to express time limits on the session duration, however.",
      "ja": "INVITEでの有効期限は招待状から生じる実際のセッションの時間には影響を与えません。セッション記述プロトコルは、しかし、セッション期間に時間制限を発現する能力を提供することができます。"
    },
    {
      "indent": 3,
      "text": "The value of this field is an integral number of seconds (in decimal) between 0 and (2**32)-1, measured from the receipt of the request.",
      "ja": "このフィールドの値は、要求の受信から測定し、0と（2 ** 32）-1の間（10進数）秒の整数です。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Expires: 5",
      "ja": "有効期限：5"
    },
    {
      "indent": 0,
      "text": "20.20 From",
      "section_title": true,
      "ja": "20.20から"
    },
    {
      "indent": 3,
      "text": "The From header field indicates the initiator of the request. This may be different from the initiator of the dialog. Requests sent by the callee to the caller use the callee's address in the From header field.",
      "ja": "ヘッダフィールドからの要求の開始を示しています。これは、ダイアログのイニシエータと異なる場合があります。呼び出し元に呼び出し先によって送られたリクエストは、Fromヘッダーフィールドに呼び出し先のアドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "The optional \"display-name\" is meant to be rendered by a human user interface. A system SHOULD use the display name \"Anonymous\" if the identity of the client is to remain hidden. Even if the \"display-name\" is empty, the \"name-addr\" form MUST be used if the \"addr-spec\" contains a comma, question mark, or semicolon. Syntax issues are discussed in Section 7.3.1.",
      "ja": "オプションの「ディスプレイ名」は、ヒトユーザーインターフェースによってレンダリングされることを意味します。クライアントのアイデンティティが隠されたままにする場合、システムは、表示名「匿名」を使用すべきです。 「表示名」は空であっても、「ADDR-specは」カンマ、疑問符、またはセミコロンが含まれている場合は、「名前-addrに」フォームを使用しなければなりません。構文の問題はセクション7.3.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "Two From header fields are equivalent if their URIs match, and their parameters match. Extension parameters in one header field, not present in the other are ignored for the purposes of comparison. This means that the display name and presence or absence of angle brackets do not affect matching.",
      "ja": "ヘッダフィールドからの二つは、そのURIが一致した場合と同等であり、それらのパラメータが一致します。 1つのヘッダフィールド内の拡張パラメータは、他には存在しないが、比較の目的のために無視されます。これは、角括弧の表示名と有無は一致に影響を与えないことを意味します。"
    },
    {
      "indent": 3,
      "text": "See Section 20.10 for the rules for parsing a display name, URI and URI parameters, and header field parameters.",
      "ja": "表示名、URIとURIパラメータ、ヘッダフィールドパラメータを解析するための規則については、セクション20.10を参照。"
    },
    {
      "indent": 3,
      "text": "The compact form of the From header field is f.",
      "ja": "Fromヘッダフィールドのコンパクト形はFです。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "From: \"A. G. Bell\" <sip:agb@bell-telephone.com> ;tag=a48s From: sip:+12125551212@server.phone2net.com;tag=887s f: Anonymous <sip:c8oqz84zk7z@privacy.org>;tag=hyh8",
      "ja": "From： \"AGベル\" <SIP：agb@bell-telephone.com>;タグ=からa48s：SIP：+12125551212@server.phone2net.com;タグ= 887sのF：匿名<SIP：c8oqz84zk7z@privacy.org>。タグ= hyh8"
    },
    {
      "indent": 0,
      "text": "20.21 In-Reply-To",
      "section_title": true,
      "ja": "20.21では、返信先"
    },
    {
      "indent": 3,
      "text": "The In-Reply-To header field enumerates the Call-IDs that this call references or returns. These Call-IDs may have been cached by the client then included in this header field in a return call.",
      "ja": "イン返信先ヘッダーフィールドは、コールIDがこのコール参照または復帰することを列挙します。これらのコールIDは、その後、リターンコールでは、このヘッダフィールドに含まれるクライアントによってキャッシュされている場合があります。"
    },
    {
      "indent": 6,
      "text": "This allows automatic call distribution systems to route return calls to the originator of the first call. This also allows callees to filter calls, so that only return calls for calls they originated will be accepted. This field is not a substitute for request authentication.",
      "ja": "これは、最初のコールの発信元に経路リターンコールに自動呼分配システムを可能にします。彼らだけが受け入れられます発信されたコールのコールを返すように、これはまた、呼び出し先が呼び出しをフィルタリングすることができます。このフィールドには、要求の認証に代わるものではありません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "In-Reply-To: 70710@saturn.bell-tel.com, 17320@saturn.bell-tel.com",
      "ja": "イン返信先：70710@saturn.bell-tel.com、17320@saturn.bell-tel.com"
    },
    {
      "indent": 0,
      "text": "20.22 Max-Forwards",
      "section_title": true,
      "ja": "20.22マックス・フォワード"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards header field must be used with any SIP method to limit the number of proxies or gateways that can forward the request to the next downstream server. This can also be useful when the client is attempting to trace a request chain that appears to be failing or looping in mid-chain.",
      "ja": "最大転送しヘッダフィールドは、次のダウンストリームサーバに要求を転送することができるプロキシまたはゲートウェイの数を制限するために、任意のSIPメソッドで使用されなければなりません。クライアントは、中鎖に失敗またはループしているように見えるリクエストチェーンをトレースしようとしているときにも役立ちます。"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards value is an integer in the range 0-255 indicating the remaining number of times this request message is allowed to be forwarded. This count is decremented by each server that forwards the request. The recommended initial value is 70.",
      "ja": "最大転送した値は、この要求メッセージを転送することが許可されている残り回数を示す0〜255の範囲の整数です。このカウントは、要求を転送し、各サーバによって減少します。推奨される初期値は70です。"
    },
    {
      "indent": 3,
      "text": "This header field should be inserted by elements that can not otherwise guarantee loop detection. For example, a B2BUA should insert a Max-Forwards header field.",
      "ja": "このヘッダーフィールドは、そうでなければ、ループ検出を保証することができない要素によって挿入されるべきです。例えば、B2BUAは、Max-Forwardsヘッダーフィールドを挿入しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Max-Forwards: 6",
      "ja": "マックス・フォワード：6"
    },
    {
      "indent": 0,
      "text": "20.23 Min-Expires",
      "section_title": true,
      "ja": "20.23分、有効期限"
    },
    {
      "indent": 3,
      "text": "The Min-Expires header field conveys the minimum refresh interval supported for soft-state elements managed by that server. This includes Contact header fields that are stored by a registrar. The header field contains a decimal integer number of seconds from 0 to (2**32)-1. The use of the header field in a 423 (Interval Too Brief) response is described in Sections 10.2.8, 10.3, and 21.4.17.",
      "ja": "ミン期限切れヘッダフィールドは、そのサーバが管理するソフトステートエレメントのためのサポートされる最小リフレッシュ間隔を伝えます。これは、レジストラによって記憶されているContactヘッダフィールドを含みます。ヘッダーフィールドは0〜秒の進整数（2 ** 32）を含有-1。 423（間隔すぎる概要）応答のヘッダフィールドの使用は、セクション10.2.8に10.3、および21.4.17に記載されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Min-Expires: 60",
      "ja": "ミン有効期限：60"
    },
    {
      "indent": 0,
      "text": "20.24 MIME-Version",
      "section_title": true,
      "ja": "20.24 MIME-バージョン"
    },
    {
      "indent": 3,
      "text": "See [H19.4.1].",
      "ja": "[H19.4.1]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "MIME-Version: 1.0",
      "ja": "MIME-バージョン：1.0"
    },
    {
      "indent": 0,
      "text": "20.25 Organization",
      "section_title": true,
      "ja": "20.25機関"
    },
    {
      "indent": 3,
      "text": "The Organization header field conveys the name of the organization to which the SIP element issuing the request or response belongs.",
      "ja": "組織ヘッダーフィールドは、要求または応答を発行するSIP要素が所属する組織の名前を伝えます。"
    },
    {
      "indent": 6,
      "text": "The field MAY be used by client software to filter calls.",
      "ja": "フィールドには、呼び出しをフィルタリングするために、クライアントソフトウェアによって使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Organization: Boxes by Bob",
      "ja": "組織：ボブによってボックス"
    },
    {
      "indent": 0,
      "text": "20.26 Priority",
      "section_title": true,
      "ja": "20.26優先順位"
    },
    {
      "indent": 3,
      "text": "The Priority header field indicates the urgency of the request as perceived by the client. The Priority header field describes the priority that the SIP request should have to the receiving human or its agent. For example, it may be factored into decisions about call routing and acceptance. For these decisions, a message containing no Priority header field SHOULD be treated as if it specified a Priority of \"normal\". The Priority header field does not influence the use of communications resources such as packet forwarding priority in routers or access to circuits in PSTN gateways. The header field can have the values \"non-urgent\", \"normal\", \"urgent\", and \"emergency\", but additional values can be defined elsewhere. It is RECOMMENDED that the value of \"emergency\" only be used when life, limb, or property are in imminent danger. Otherwise, there are no semantics defined for this header field.",
      "ja": "クライアントによって知覚される優先順位ヘッダーフィールドは、要求の緊急性を示します。優先順位ヘッダフィールドは、SIP要求が受信ヒト又はその代理人に有していなければならない優先順位を記載しています。例えば、それは、コールルーティングと受け入れに関する決定に織り込ますることができます。それは、「正常」の優先度を指定した場合、これらの決定のために、非優先ヘッダーフィールドを含まないメッセージが扱われるべきです。優先ヘッダーフィールドは、ルータまたはPSTNゲートウェイ内の回路へのアクセスにかかるパケット転送の優先度などの通信リソースの使用に影響を与えません。ヘッダフィールドは「非緊急」、「ノーマル」、「緊急」、および「緊急」が、追加の値を他の場所で定義することができる値を有することができます。生命、身体、または財産が差し迫って危険にさらされている時に「緊急」の値のみが使用することをお勧めします。そうでない場合は、このヘッダフィールドのために定義された意味はありません。"
    },
    {
      "indent": 6,
      "text": "These are the values of RFC 2076 [38], with the addition of \"emergency\".",
      "ja": "これらは、「緊急」を加えて、RFC 2076 [38]の値です。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Subject: A tornado is heading our way! Priority: emergency",
      "ja": "件名：竜巻は、私たちの道を向かっています！優先度：緊急"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 6,
      "text": "Subject: Weekend plans Priority: non-urgent",
      "ja": "件名：週末の計画の優先順位：非緊急"
    },
    {
      "indent": 0,
      "text": "20.27 Proxy-Authenticate",
      "section_title": true,
      "ja": "20.27プロキシ認証"
    },
    {
      "indent": 3,
      "text": "A Proxy-Authenticate header field value contains an authentication challenge.",
      "ja": "プロキシ認証ヘッダフィールド値は、認証チャレンジを含んでいます。"
    },
    {
      "indent": 3,
      "text": "The use of this header field is defined in [H14.33]. See Section 22.3 for further details on its usage.",
      "ja": "このヘッダフィールドの使用は[H14.33]で定義されています。その使用方法の詳細については、セクション22.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Proxy-Authenticate: Digest realm=\"atlanta.com\", domain=\"sip:ss1.carrier.com\", qop=\"auth\", nonce=\"f84f1cec41e6cbe5aea9c8e88d359\", opaque=\"\", stale=FALSE, algorithm=MD5",
      "ja": "プロキシ認証：ダイジェスト分野= \"atlanta.com\"、ドメイン= \"SIP：ss1.carrier.com\"、QOP = \"認証\"、ナンス= \"f84f1cec41e6cbe5aea9c8e88d359\"、不透明= \"\"、古い= FALSE、アルゴリズム= MD5"
    },
    {
      "indent": 0,
      "text": "20.28 Proxy-Authorization",
      "section_title": true,
      "ja": "20.28プロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authorization header field allows the client to identify itself (or its user) to a proxy that requires authentication. A Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested.",
      "ja": "Proxy-Authorizationヘッダフィールドは、クライアントが認証を必要とするプロキシにそれ自体（又はそのユーザ）を識別することを可能にします。プロキシ認証フィールド値は、プロキシおよび/または要求されたリソースのレルムのユーザエージェントの認証情報を含む資格情報から成ります。"
    },
    {
      "indent": 3,
      "text": "See Section 22.3 for a definition of the usage of this header field.",
      "ja": "このヘッダフィールドの使用方法の定義については、セクション22.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "This header field, along with Authorization, breaks the general rules about multiple header field names. Although not a comma-separated list, this header field name may be present multiple times, and MUST NOT be combined into a single header line using the usual rules described in Section 7.3.1.",
      "ja": "このヘッダーフィールドは、認可に伴い、複数のヘッダーフィールド名に関する一般ルールを破ります。ないカンマ区切りのリストが、このヘッダーフィールド名が複数回存在してもよく、およびセクション7.3.1に記載の通常の規則を使用して単一のヘッダ行に結合されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Proxy-Authorization: Digest username=\"Alice\", realm=\"atlanta.com\", nonce=\"c60f3082ee1212b402a21831ae\", response=\"245f23415f11432b3434341c022\"",
      "ja": "プロキシ認証：ダイジェストユーザ名= \"アリス\"、領域= \"atlanta.com\"、= \"c60f3082ee1212b402a21831ae\" ナンス、レスポンス= \"245f23415f11432b3434341c022\""
    },
    {
      "indent": 0,
      "text": "20.29 Proxy-Require",
      "section_title": true,
      "ja": "20.29プロキシ要求"
    },
    {
      "indent": 3,
      "text": "The Proxy-Require header field is used to indicate proxy-sensitive features that must be supported by the proxy. See Section 20.32 for more details on the mechanics of this message and a usage example.",
      "ja": "プロキシ要求ヘッダーフィールドは、プロキシによってサポートされなければならないプロキシ感受性の特徴を示すために使用されます。このメッセージの仕組みの詳細については、セクション20.32と使用例を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Proxy-Require: foo",
      "ja": "プロキシが必要：FOOを"
    },
    {
      "indent": 0,
      "text": "20.30 Record-Route",
      "section_title": true,
      "ja": "20.30を記録 - ルート"
    },
    {
      "indent": 3,
      "text": "The Record-Route header field is inserted by proxies in a request to force future requests in the dialog to be routed through the proxy.",
      "ja": "Record-Routeヘッダフィールドは、プロキシを介してルーティングされるダイアログの将来の要求を強制する要求にプロキシによって挿入されます。"
    },
    {
      "indent": 3,
      "text": "Examples of its use with the Route header field are described in Sections 16.12.1.",
      "ja": "Routeヘッダーフィールドとその使用の例は、セクション16.12.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Record-Route: <sip:server10.biloxi.com;lr>, <sip:bigbox3.site3.atlanta.com;lr>",
      "ja": "レコードルート：<SIP：server10.biloxi.com; LR>、<SIP：bigbox3.site3.atlanta.com; LR>"
    },
    {
      "indent": 0,
      "text": "20.31 Reply-To",
      "section_title": true,
      "ja": "20.31返信先"
    },
    {
      "indent": 3,
      "text": "The Reply-To header field contains a logical return URI that may be different from the From header field. For example, the URI MAY be used to return missed calls or unestablished sessions. If the user wished to remain anonymous, the header field SHOULD either be omitted from the request or populated in such a way that does not reveal any private information.",
      "ja": "返信するフィールドをヘッダは、ヘッダフィールドから異なっていてもよい論理戻りURIを含みます。例えば、URIは、不在着信や未確立セッションを返すために使用されるかもしれません。ユーザーが匿名を希望する場合は、ヘッダフィールドは、いずれかの要求から省略または任意の個人情報を明らかにしないように移入されるべきである（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Even if the \"display-name\" is empty, the \"name-addr\" form MUST be used if the \"addr-spec\" contains a comma, question mark, or semicolon. Syntax issues are discussed in Section 7.3.1.",
      "ja": "「表示名」は空であっても、「ADDR-specは」カンマ、疑問符、またはセミコロンが含まれている場合は、「名前-addrに」フォームを使用しなければなりません。構文の問題はセクション7.3.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Reply-To: Bob <sip:bob@biloxi.com>",
      "ja": "返信先：ボブ<SIP：bob@biloxi.com>"
    },
    {
      "indent": 0,
      "text": "20.32 Require",
      "section_title": true,
      "ja": "20.32が必要"
    },
    {
      "indent": 3,
      "text": "The Require header field is used by UACs to tell UASs about options that the UAC expects the UAS to support in order to process the request. Although an optional header field, the Require MUST NOT be ignored if it is present.",
      "ja": "Requireヘッダーフィールドは、UACがUASがリクエストを処理するためにサポートする予定のオプションについてのUASに伝えるために求めるUACによって使用されます。それが存在する場合、オプションヘッダフィールドが、要求を無視してはいけません。"
    },
    {
      "indent": 3,
      "text": "The Require header field contains a list of option tags, described in Section 19.2. Each option tag defines a SIP extension that MUST be understood to process the request. Frequently, this is used to indicate that a specific set of extension header fields need to be understood. A UAC compliant to this specification MUST only include option tags corresponding to standards-track RFCs.",
      "ja": "Requireヘッダーフィールドは、セクション19.2で説明するオプションタグのリストが含まれています。各オプションタグは、要求を処理するように理解されなければならないSIP拡張機能を定義します。しばしば、これは拡張ヘッダフィールドの特定のセットを理解する必要があることを示すために使用されます。この仕様にUAC準拠は、標準トラックのRFCに対応するオプションタグのみを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Require: 100rel",
      "ja": "必要：100relを"
    },
    {
      "indent": 0,
      "text": "20.33 Retry-After",
      "section_title": true,
      "ja": "20.33リトライした後、"
    },
    {
      "indent": 3,
      "text": "The Retry-After header field can be used with a 500 (Server Internal Error) or 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client and with a 404 (Not Found), 413 (Request Entity Too Large), 480 (Temporarily Unavailable), 486 (Busy Here), 600 (Busy), or 603 (Decline) response to indicate when the called party anticipates being available again. The value of this field is a positive integer number of seconds (in decimal) after the time of the response.",
      "ja": "リトライ-Afterヘッダフィールドは500（サーバ内部エラー）またはサービスが要求元のクライアントにして（見つかりません）404と使用できなくなることが期待されてどのくらいの期間を示すために503（サービス使用不可）レスポンス、413（で使用することができます着信側が再び利用可能見込んでいたときに、要求エンティティが大きすぎ）、480（一時的に利用できない）、486（ここで忙しい）、600（ビジー）、または603（辞退）応答が示します。このフィールドの値は、応答の時間後（10進数）秒の正の整数です。"
    },
    {
      "indent": 3,
      "text": "An optional comment can be used to indicate additional information about the time of callback. An optional \"duration\" parameter indicates how long the called party will be reachable starting at the initial time of availability. If no duration parameter is given, the service is assumed to be available indefinitely.",
      "ja": "オプションのコメントは、コールバックの時間に関する追加情報を示すために使用することができます。オプションの「期間」パラメータは、着信側が可用性の初期時点から始まる到達可能になりますどのくらいを示しています。何durationパラメータが指定されていない場合は、サービスが無期限に利用可能であると仮定されます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Retry-After: 18000;duration=3600 Retry-After: 120 (I'm in a meeting)",
      "ja": "リトライ後：18000;期間= 3600リトライ後：120（私は会議中です）"
    },
    {
      "indent": 0,
      "text": "20.34 Route",
      "section_title": true,
      "ja": "20.34ルート"
    },
    {
      "indent": 3,
      "text": "The Route header field is used to force routing for a request through the listed set of proxies. Examples of the use of the Route header field are in Section 16.12.1.",
      "ja": "Routeヘッダーフィールドは、プロキシのリストされたセットを介して要求のルーティングを強制するために使用されます。 Routeヘッダーフィールドの使用例は、セクション16.12.1です。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Route: <sip:bigbox3.site3.atlanta.com;lr>, <sip:server10.biloxi.com;lr>",
      "ja": "ルート：<SIP：bigbox3.site3.atlanta.com; LR>、<SIP：server10.biloxi.com; LR>"
    },
    {
      "indent": 0,
      "text": "20.35 Server",
      "section_title": true,
      "ja": "20.35サーバー"
    },
    {
      "indent": 3,
      "text": "The Server header field contains information about the software used by the UAS to handle the request.",
      "ja": "サーバーヘッダフィールドは、リクエストを処理するためにUASが使用するソフトウェアに関する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Revealing the specific software version of the server might allow the server to become more vulnerable to attacks against software that is known to contain security holes. Implementers SHOULD make the Server header field a configurable option.",
      "ja": "サーバーの特定のソフトウェアバージョンを明らかにすることは、サーバがセキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。実装者は、Serverヘッダフィールド設定可能なオプションにするべきです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Server: HomeServer v2",
      "ja": "サーバー：自宅サーバv2の"
    },
    {
      "indent": 0,
      "text": "20.36 Subject",
      "section_title": true,
      "ja": "20.36件名"
    },
    {
      "indent": 3,
      "text": "The Subject header field provides a summary or indicates the nature of the call, allowing call filtering without having to parse the session description. The session description does not have to use the same subject indication as the invitation.",
      "ja": "件名ヘッダフィールドは、要約を提供するまたはセッション記述を解析することなく、コールフィルタリングを可能にする、コールの性質を示しています。セッション記述は招待と同じサブジェクト表示を使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The compact form of the Subject header field is s.",
      "ja": "件名ヘッダフィールドのコンパクト形はsです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Subject: Need more boxes s: Tech Support",
      "ja": "件名：必要以上のボックスのS：テクニカルサポート"
    },
    {
      "indent": 0,
      "text": "20.37 Supported",
      "section_title": true,
      "ja": "20.37がサポートされています"
    },
    {
      "indent": 3,
      "text": "The Supported header field enumerates all the extensions supported by the UAC or UAS.",
      "ja": "Supportedヘッダーフィールドは、UACまたはUASがサポートしているすべての拡張機能を列挙します。"
    },
    {
      "indent": 3,
      "text": "The Supported header field contains a list of option tags, described in Section 19.2, that are understood by the UAC or UAS. A UA compliant to this specification MUST only include option tags corresponding to standards-track RFCs. If empty, it means that no extensions are supported.",
      "ja": "Supportedヘッダフィールドは、UACまたはUASによって理解されているセクション19.2で説明したオプションタグのリストを含んでいます。この仕様に準拠したUAのは、標準トラックのRFCに対応するオプションタグのみを含まなければなりません。空の場合、それは何の機能拡張がサポートされていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The compact form of the Supported header field is k.",
      "ja": "サポートされているヘッダフィールドのコンパクト形はKです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Supported: 100rel",
      "ja": "サポートされている：100rel"
    },
    {
      "indent": 0,
      "text": "20.38 Timestamp",
      "section_title": true,
      "ja": "20.38のタイムスタンプ"
    },
    {
      "indent": 3,
      "text": "The Timestamp header field describes when the UAC sent the request to the UAS.",
      "ja": "UACがUASにリクエストを送信したときにタイムスタンプヘッダフィールドが記載されています。"
    },
    {
      "indent": 3,
      "text": "See Section 8.2.6 for details on how to generate a response to a request that contains the header field. Although there is no normative behavior defined here that makes use of the header, it allows for extensions or SIP applications to obtain RTT estimates.",
      "ja": "ヘッダフィールドが含まれている要求に対する応答を生成する方法の詳細については、セクション8.2.6を参照してください。ヘッダを利用し、ここで定義された規範的な行動はありませんが、それはRTT推定値を得るために拡張またはSIPアプリケーションが可能になります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Timestamp: 54",
      "ja": "タイムスタンプ：54"
    },
    {
      "indent": 0,
      "text": "20.39 To",
      "section_title": true,
      "ja": "２０。３９ と"
    },
    {
      "indent": 3,
      "text": "The To header field specifies the logical recipient of the request.",
      "ja": "Toヘッダフィールドは要求の論理的な受信者を指定します。"
    },
    {
      "indent": 3,
      "text": "The optional \"display-name\" is meant to be rendered by a human-user interface. The \"tag\" parameter serves as a general mechanism for dialog identification.",
      "ja": "オプションの「ディスプレイ名」は、ヒト・ユーザ・インターフェースによってレンダリングされることを意味します。 「タグ」パラメータは、ダイアログ識別のための一般的な機構として働きます。"
    },
    {
      "indent": 3,
      "text": "See Section 19.3 for details of the \"tag\" parameter.",
      "ja": "「タグ」パラメータの詳細については、セクション19.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Comparison of To header fields for equality is identical to comparison of From header fields. See Section 20.10 for the rules for parsing a display name, URI and URI parameters, and header field parameters.",
      "ja": "平等のためのToヘッダフィールドの比較は、ヘッダフィールドからの比較と同じです。表示名、URIとURIパラメータ、ヘッダフィールドパラメータを解析するための規則については、セクション20.10を参照。"
    },
    {
      "indent": 3,
      "text": "The compact form of the To header field is t.",
      "ja": "Toヘッダフィールドのコンパクト形はTです。"
    },
    {
      "indent": 3,
      "text": "The following are examples of valid To header fields:",
      "ja": "次のフィールドをヘッダーへの有効な例は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "To: The Operator <sip:operator@cs.columbia.edu>;tag=287447 t: sip:+12125551212@server.phone2net.com",
      "ja": "To：演算子<SIP：operator@cs.columbia.edu>;タグ= 287447トン：SIP：+12125551212@server.phone2net.com"
    },
    {
      "indent": 0,
      "text": "20.40 Unsupported",
      "section_title": true,
      "ja": "サポートされていない20.40"
    },
    {
      "indent": 3,
      "text": "The Unsupported header field lists the features not supported by the UAS. See Section 20.32 for motivation.",
      "ja": "サポートされていないヘッダフィールドはUASによってサポートされていない機能を示します。動機については、セクション20.32を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Unsupported: foo",
      "ja": "サポートされていない：FOO"
    },
    {
      "indent": 0,
      "text": "20.41 User-Agent",
      "section_title": true,
      "ja": "20.41のUser-Agent"
    },
    {
      "indent": 3,
      "text": "The User-Agent header field contains information about the UAC originating the request. The semantics of this header field are defined in [H14.43].",
      "ja": "User-Agentヘッダフィールドは、リクエストを元のUACに関する情報が含まれています。このヘッダフィールドのセマンティクスは[H14.43]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Revealing the specific software version of the user agent might allow the user agent to become more vulnerable to attacks against software that is known to contain security holes. Implementers SHOULD make the User-Agent header field a configurable option.",
      "ja": "ユーザーエージェントの特定のソフトウェアバージョンを明らかにすることは、ユーザエージェントがセキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。実装者はUser-Agentヘッダフィールドに設定可能なオプションを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "User-Agent: Softphone Beta1.5",
      "ja": "User-Agent：ソフトフォンBeta1.5"
    },
    {
      "indent": 0,
      "text": "20.42 Via",
      "section_title": true,
      "ja": "20.42経由"
    },
    {
      "indent": 3,
      "text": "The Via header field indicates the path taken by the request so far and indicates the path that should be followed in routing responses. The branch ID parameter in the Via header field values serves as a transaction identifier, and is used by proxies to detect loops.",
      "ja": "Viaヘッダフィールドは、これまで要求によって取られる経路を示し、ルーティング応答に従うべき経路を示します。 Viaヘッダフィールド値に分岐IDパラメータは、トランザクション識別子として機能し、ループを検出するためにプロキシによって使用されています。"
    },
    {
      "indent": 3,
      "text": "A Via header field value contains the transport protocol used to send the message, the client's host name or network address, and possibly the port number at which it wishes to receive responses. A Via header field value can also contain parameters such as \"maddr\", \"ttl\", \"received\", and \"branch\", whose meaning and use are described in other sections. For implementations compliant to this specification, the value of the branch parameter MUST start with the magic cookie \"z9hG4bK\", as discussed in Section 8.1.1.7.",
      "ja": "Viaヘッダーフィールド値は、メッセージ、クライアントのホスト名またはネットワークアドレス、およびそれが応答を受信したいれる可能性のポート番号を送信するために使用されるトランスポートプロトコルが含まれています。 Viaヘッダフィールド値はまた、その意味と使用する他のセクションに記載されているような「MADDR」、「TTL」は、「受信」などのパラメータ、および「ブランチ」を含むことができます。セクション8.1.1.7で述べたようにこの仕様に準拠する実装の場合は、分岐パラメータの値が、マジッククッキー「z9hG4bK」で開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "Transport protocols defined here are \"UDP\", \"TCP\", \"TLS\", and \"SCTP\". \"TLS\" means TLS over TCP. When a request is sent to a SIPS URI, the protocol still indicates \"SIP\", and the transport protocol is TLS.",
      "ja": "ここで定義されたトランスポートプロトコルは、 \"UDP\"、 \"TCP\"、 \"TLS\"、および \"SCTP\" です。 \"TLS\" はTCP上のTLSを意味します。要求がSIPS URIに送信されると、プロトコルは、依然として「SIP」を示し、およびトランスポート・プロトコルは、TLSです。"
    },
    {
      "indent": 0,
      "text": "Via: SIP/2.0/UDP erlang.bell-telephone.com:5060;branch=z9hG4bK87asdks7 Via: SIP/2.0/UDP 192.0.2.1:5060 ;received=192.0.2.207 ;branch=z9hG4bK77asjd",
      "ja": "ビア：SIP / 2.0 / UDP erlang.bell-telephone.com:5060;branch=z9hG4bK87asdks7経由：SIP / 2.0 / UDP 192.0.2.1:5060;受け取ら= 192.0.2.207;ブランチ= z9hG4bK77asjd"
    },
    {
      "indent": 3,
      "text": "The compact form of the Via header field is v.",
      "ja": "Viaヘッダフィールドのコンパクト形はVです。"
    },
    {
      "indent": 3,
      "text": "In this example, the message originated from a multi-homed host with two addresses, 192.0.2.1 and 192.0.2.207. The sender guessed wrong as to which network interface would be used. Erlang.bell-telephone.com noticed the mismatch and added a parameter to the previous hop's Via header field value, containing the address that the packet actually came from.",
      "ja": "この例では、メッセージは2つのアドレス192.0.2.1と192.0.2.207とマルチホームホストから発信しました。送信者は、ネットワークインタフェースが使用されるであろうと推測として間違っています。 Erlang.bell-telephone.comは不一致に気づき、パケットが実際にから来たアドレスを含む、前のホップのViaヘッダーフィールド値にパラメータを追加しました。"
    },
    {
      "indent": 3,
      "text": "The host or network address and port number are not required to follow the SIP URI syntax. Specifically, LWS on either side of the \":\" or \"/\" is allowed, as shown here:",
      "ja": "ホストまたはネットワークアドレスとポート番号は、SIP URIの構文に従うことを要求されません。具体的に、のいずれかの側にLWS「：」または「/」ここに示されているように、許可されています。"
    },
    {
      "indent": 6,
      "text": "Via: SIP / 2.0 / UDP first.example.com: 4000;ttl=16 ;maddr=224.2.0.1 ;branch=z9hG4bKa7c6a8dlze.1",
      "ja": "ビア：SIP / 2.0 / UDP first.example.com：4000; TTL = 16; MADDR = 224.2.0.1;ブランチ= z9hG4bKa7c6a8dlze.1"
    },
    {
      "indent": 3,
      "text": "Even though this specification mandates that the branch parameter be present in all requests, the BNF for the header field indicates that it is optional. This allows interoperation with RFC 2543 elements, which did not have to insert the branch parameter.",
      "ja": "分岐パラメータはすべてのリクエスト中に存在することが、本明細書の義務も、ヘッダフィールドのBNFは、それがオプションであることを示しています。これは、分岐パラメータを挿入する必要はありませんでしたRFC 2543の要素との相互運用を可能にします。"
    },
    {
      "indent": 3,
      "text": "Two Via header fields are equal if their sent-protocol and sent-by fields are equal, both have the same set of parameters, and the values of all parameters are equal.",
      "ja": "その送信されたプロトコルおよびフィールド送信バイが等しい場合、2つのViaヘッダフィールドは、両方のパラメータの同じセットを有する、等しく、全てのパラメータの値が等しいです。"
    },
    {
      "indent": 0,
      "text": "20.43 Warning",
      "section_title": true,
      "ja": "20.43警告"
    },
    {
      "indent": 3,
      "text": "The Warning header field is used to carry additional information about the status of a response. Warning header field values are sent with responses and contain a three-digit warning code, host name, and warning text.",
      "ja": "警告ヘッダフィールドは、応答のステータスに関する追加情報を搬送するために使用されます。警告ヘッダーフィールド値は、3桁の警告コード、ホスト名、および警告文を応答で送信され、含まれています。"
    },
    {
      "indent": 3,
      "text": "The \"warn-text\" should be in a natural language that is most likely to be intelligible to the human user receiving the response. This decision can be based on any available knowledge, such as the location of the user, the Accept-Language field in a request, or the",
      "ja": "「警告テキストは、」応答を受け取る人間のユーザに理解できる可能性が最も高い自然言語である必要があります。この決定は、ユーザの位置として、任意の利用可能な知識に基づくことができ、受け入れ言語の要求のフィールド、または"
    },
    {
      "indent": 3,
      "text": "Content-Language field in a response. The default language is i-default [21].",
      "ja": "レスポンスのContent-Languageフィールド。デフォルトの言語は[21] I-デフォルトです。"
    },
    {
      "indent": 3,
      "text": "The currently-defined \"warn-code\"s are listed below, with a recommended warn-text in English and a description of their meaning. These warnings describe failures induced by the session description. The first digit of warning codes beginning with \"3\" indicates warnings specific to SIP. Warnings 300 through 329 are reserved for indicating problems with keywords in the session description, 330 through 339 are warnings related to basic network services requested in the session description, 370 through 379 are warnings related to quantitative QoS parameters requested in the session description, and 390 through 399 are miscellaneous warnings that do not fall into one of the above categories.",
      "ja": "現在定義されている「警告コード」をsが英語で推奨警告 - テキストとその意味の説明を、以下に記載されています。これらの警告は、セッション記述によって誘発される障害について説明します。 「3」で始まる警告コードの最初の数字は、SIPに固有の警告を示しています。警告300 329を介しては、379を介して、370はセッション記述で要求された定量的なQoSパラメータに関する警告であり、390、339を介して、330はセッション記述で要求された基本的なネットワークサービスに関連する警告され、セッション記述のキーワードの問題を示すために予約されています399を通じて上記のいずれかのカテゴリに分類されないその他の警告です。"
    },
    {
      "indent": 6,
      "text": "300 Incompatible network protocol: One or more network protocols contained in the session description are not available.",
      "ja": "300互換性のないネットワークプロトコル：セッション記述に含まれる1つのまたは複数のネットワークプロトコルが利用できません。"
    },
    {
      "indent": 6,
      "text": "301 Incompatible network address formats: One or more network address formats contained in the session description are not available.",
      "ja": "301の互換性のないネットワークアドレス形式：セッション記述に含まれる1つの以上のネットワークアドレス形式は使用できません。"
    },
    {
      "indent": 6,
      "text": "302 Incompatible transport protocol: One or more transport protocols described in the session description are not available.",
      "ja": "302互換性のないトランスポートプロトコル：セッション記述に記載される1つの以上のトランスポートプロトコルが利用できません。"
    },
    {
      "indent": 6,
      "text": "303 Incompatible bandwidth units: One or more bandwidth measurement units contained in the session description were not understood.",
      "ja": "303非互換帯域単位：セッション記述に含まれる1つの以上の帯域幅測定ユニットが理解されませんでした。"
    },
    {
      "indent": 6,
      "text": "304 Media type not available: One or more media types contained in the session description are not available.",
      "ja": "304枚のメディアが利用できないタイプ：セッション記述に含まれる1つのまたは複数のメディアタイプは使用できません。"
    },
    {
      "indent": 6,
      "text": "305 Incompatible media format: One or more media formats contained in the session description are not available.",
      "ja": "305の互換性のないメディアフォーマット：セッション記述に含まれる1つの以上のメディアフォーマットが使用できません。"
    },
    {
      "indent": 6,
      "text": "306 Attribute not understood: One or more of the media attributes in the session description are not supported.",
      "ja": "306は理解されていない属性：セッション記述におけるメディア属性の1つ以上がサポートされていません。"
    },
    {
      "indent": 6,
      "text": "307 Session description parameter not understood: A parameter other than those listed above was not understood.",
      "ja": "307セッション記述パラメータは理解されていない：上記以外のパラメータは理解されていませんでした。"
    },
    {
      "indent": 6,
      "text": "330 Multicast not available: The site where the user is located does not support multicast.",
      "ja": "利用できる330マルチキャストません：ユーザーが配置されているサイトは、マルチキャストをサポートしていません。"
    },
    {
      "indent": 6,
      "text": "331 Unicast not available: The site where the user is located does not support unicast communication (usually due to the presence of a firewall).",
      "ja": "331ユニキャストできません：（通常によるファイアウォールの存在のために）、ユーザは、ユニキャスト通信をサポートしていない位置しているサイト。"
    },
    {
      "indent": 6,
      "text": "370 Insufficient bandwidth: The bandwidth specified in the session description or defined by the media exceeds that known to be available.",
      "ja": "370不十分な帯域幅：帯域幅がセッション記述で指定された、またはメディアによって定義が利用可能であることが知られていることを超えています。"
    },
    {
      "indent": 6,
      "text": "399 Miscellaneous warning: The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action.",
      "ja": "399その他の警告：警告テキストは人間のユーザに提示またはログインするための任意の情報を含めることができます。この警告を受けたシステムは、任意の自動化された行動をしてはなりません。"
    },
    {
      "indent": 13,
      "text": "1xx and 2xx have been taken by HTTP/1.1.",
      "ja": "1XXおよび2XXは、HTTP / 1.1で撮影されています。"
    },
    {
      "indent": 3,
      "text": "Additional \"warn-code\"s can be defined through IANA, as defined in Section 27.2.",
      "ja": "追加は、「警告コード」のセクション27.2で定義されているのは、IANAによって定義することができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "Warning: 307 isi.edu \"Session parameter 'foo' not understood\" Warning: 301 isi.edu \"Incompatible network address type 'E.164'\"",
      "ja": "警告：301 isi.edu「互換性のないネットワークアドレスタイプ 『E.164』」：307はisi.edu警告「セッションパラメータ 『foo』で理解されていません」"
    },
    {
      "indent": 0,
      "text": "20.44 WWW-Authenticate",
      "section_title": true,
      "ja": "20.44 WWW認証"
    },
    {
      "indent": 3,
      "text": "A WWW-Authenticate header field value contains an authentication challenge. See Section 22.2 for further details on its usage.",
      "ja": "WWW-Authenticateヘッダフィールド値は、認証チャレンジが含まれています。その使用方法の詳細については、セクション22.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "WWW-Authenticate: Digest realm=\"atlanta.com\", domain=\"sip:boxesbybob.com\", qop=\"auth\", nonce=\"f84f1cec41e6cbe5aea9c8e88d359\", opaque=\"\", stale=FALSE, algorithm=MD5",
      "ja": "WWW認証：ダイジェスト分野= \"atlanta.com\"、ドメイン= \"SIP：boxesbybob.com\"、QOP = \"認証\"、ナンス= \"f84f1cec41e6cbe5aea9c8e88d359\"、不透明= \"\"、古い= FALSE、アルゴリズム= MD5"
    },
    {
      "indent": 0,
      "text": "21 Response Codes",
      "ja": "21の応答コード"
    },
    {
      "indent": 3,
      "text": "The response codes are consistent with, and extend, HTTP/1.1 response codes. Not all HTTP/1.1 response codes are appropriate, and only those that are appropriate are given here. Other HTTP/1.1 response codes SHOULD NOT be used. Also, SIP defines a new class, 6xx.",
      "ja": "応答コードは、HTTP / 1.1の応答コードと一致している、と延びています。いないすべてのHTTP / 1.1応答コードは適切であり、唯一の適切なものは、ここに与えられています。その他のHTTP / 1.1応答コードを使用しないでください。また、SIPは新しいクラス、6xxのを定義します。"
    },
    {
      "indent": 0,
      "text": "21.1 Provisional 1xx",
      "section_title": true,
      "ja": "21.1暫定の1xx"
    },
    {
      "indent": 3,
      "text": "Provisional responses, also known as informational responses, indicate that the server contacted is performing some further action and does not yet have a definitive response. A server sends a 1xx response if it expects to take more than 200 ms to obtain a final response. Note that 1xx responses are not transmitted reliably. They never cause the client to send an ACK. Provisional (1xx) responses MAY contain message bodies, including session descriptions.",
      "ja": "また、情報提供の応答として知られている暫定応答は、連絡サーバはさらにいくつかのアクションを実行しているし、まだ決定的な応答を持っていないことを示しています。それが最終的な応答を得るために、200ミリ秒以上を取ることを期待している場合、サーバーはの1xx応答を送信します。 1xx応答は確実に伝達されていないことに注意してください。彼らは、クライアントがACKを送信することはありません。暫定（1xxの）応答は、セッション記述を含め、メッセージ本文を含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "21.1.1 100 Trying",
      "section_title": true,
      "ja": "21.1.1 100しよう"
    },
    {
      "indent": 3,
      "text": "This response indicates that the request has been received by the next-hop server and that some unspecified action is being taken on behalf of this call (for example, a database is being consulted). This response, like all other provisional responses, stops retransmissions of an INVITE by a UAC. The 100 (Trying) response is different from other provisional responses, in that it is never forwarded upstream by a stateful proxy.",
      "ja": "この応答は、要求を次のホップサーバによって受信され、いくつかの不特定のアクションは、このコールの代わりに取られていること（例えば、データベースが参照されている）ことを示しています。この応答は、他のすべての暫定応答と同様に、UACによってINVITEの再送信を停止します。それはステートフルプロキシによってアップストリームに転送されることはないという点で、100（試行）応答は、他の暫定応答と異なっています。"
    },
    {
      "indent": 0,
      "text": "21.1.2 180 Ringing",
      "section_title": true,
      "ja": "21.1.2 180リンギング"
    },
    {
      "indent": 3,
      "text": "The UA receiving the INVITE is trying to alert the user. This response MAY be used to initiate local ringback.",
      "ja": "INVITEを受信UAは、ユーザーに警告しようとしています。この応答は、ローカルリングバックを開始するのに使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "21.1.3 181 Call Is Being Forwarded",
      "section_title": true,
      "ja": "21.1.3 181コールが転送されています"
    },
    {
      "indent": 3,
      "text": "A server MAY use this status code to indicate that the call is being forwarded to a different set of destinations.",
      "ja": "サーバーは、コールが宛先の異なるセットに転送されていることを示すために、このステータスコードを使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "21.1.4 182 Queued",
      "section_title": true,
      "ja": "21.1.4 182キュー"
    },
    {
      "indent": 3,
      "text": "The called party is temporarily unavailable, but the server has decided to queue the call rather than reject it. When the callee becomes available, it will return the appropriate final status response. The reason phrase MAY give further details about the status of the call, for example, \"5 calls queued; expected waiting time is 15 minutes\". The server MAY issue several 182 (Queued) responses to update the caller about the status of the queued call.",
      "ja": "被呼者が一時的に利用できないが、サーバーはコールをキューイングではなく、それを拒否することを決定しました。呼び出し先が利用可能になると、それは適切な最終ステータス応答を返します。フレーズは、コールのステータスについての更なる詳細を与える可能性の理由は、例えば、「5つのコールはキューに入れられ、予想待機時間は15分です」。サーバーは、キューに入れられたコールのステータスについて発信者を更新するには、いくつかの182（キュー）応答を発行することができます。"
    },
    {
      "indent": 0,
      "text": "21.1.5 183 Session Progress",
      "section_title": true,
      "ja": "21.1.5 183のセッションプログレス"
    },
    {
      "indent": 3,
      "text": "The 183 (Session Progress) response is used to convey information about the progress of the call that is not otherwise classified. The Reason-Phrase, header fields, or message body MAY be used to convey more details about the call progress.",
      "ja": "183（セッションの進捗状況）応答はそう分類されていないコールの進行状況についての情報を伝えるために使用されます。理由-フレーズ、ヘッダフィールド、またはメッセージボディは、呼進行の詳細を伝えるために使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "21.2 Successful 2xx",
      "section_title": true,
      "ja": "21.2成功2XX"
    },
    {
      "indent": 3,
      "text": "The request was successful.",
      "ja": "リクエストが成功しました。"
    },
    {
      "indent": 0,
      "text": "21.2.1 200 OK",
      "section_title": true,
      "ja": "21.2.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The request has succeeded. The information returned with the response depends on the method used in the request.",
      "ja": "リクエストが成功しました。応答で返された情報は、要求で使用される方法に依存します。"
    },
    {
      "indent": 0,
      "text": "21.3 Redirection 3xx",
      "section_title": true,
      "ja": "21.3リダイレクション3XX"
    },
    {
      "indent": 3,
      "text": "3xx responses give information about the user's new location, or about alternative services that might be able to satisfy the call.",
      "ja": "3xx応答は、ユーザーの新しい場所について、またはコールを満たすことができるかもしれない代替サービスについての情報を提供します。"
    },
    {
      "indent": 0,
      "text": "21.3.1 300 Multiple Choices",
      "section_title": true,
      "ja": "21.3.1 300複数の選択肢"
    },
    {
      "indent": 3,
      "text": "The address in the request resolved to several choices, each with its own specific location, and the user (or UA) can select a preferred communication end point and redirect its request to that location.",
      "ja": "いくつかの選択肢、それ自身の特定の場所にそれぞれ、ユーザ（またはUA）に解決​​リクエストのアドレスが、好ましい通信エンドポイントを選択し、その場所にその要求をリダイレクトすることができます。"
    },
    {
      "indent": 3,
      "text": "The response MAY include a message body containing a list of resource characteristics and location(s) from which the user or UA can choose the one most appropriate, if allowed by the Accept request header field. However, no MIME types have been defined for this message body.",
      "ja": "応答が受諾リクエストヘッダフィールドで許可されている場合、ユーザーまたはUAが、最も適切なものを選択することができ、そこからリソース特性および位置（単数または複数）のリストを含むメッセージ本体を含むかもしれません。しかし、MIMEタイプは、このメッセージボディのために定義されていません。"
    },
    {
      "indent": 3,
      "text": "The choices SHOULD also be listed as Contact fields (Section 20.10). Unlike HTTP, the SIP response MAY contain several Contact fields or a list of addresses in a Contact field. UAs MAY use the Contact header field value for automatic redirection or MAY ask the user to confirm a choice. However, this specification does not define any standard for such automatic selection.",
      "ja": "選択肢はまた、連絡先フィールド（セクション20.10）として表示されます。 HTTPとは異なり、SIP応答は、いくつかの連絡先フィールドまたはContactフィールド内のアドレスのリストを含むかもしれません。 UAは、自動リダイレクトのためのContactヘッダーフィールド値を使用したり、選択を確認するようにユーザーに求めることができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。"
    },
    {
      "indent": 6,
      "text": "This status response is appropriate if the callee can be reached at several different locations and the server cannot or prefers not to proxy the request.",
      "ja": "呼び出し先が複数の異なる場所で到達することができ、サーバーがプロキシに要求をない好むないか、できる場合は、このステータス応答が適切です。"
    },
    {
      "indent": 0,
      "text": "21.3.2 301 Moved Permanently",
      "section_title": true,
      "ja": "21.3.2 301が永久的に移動"
    },
    {
      "indent": 3,
      "text": "The user can no longer be found at the address in the Request-URI, and the requesting client SHOULD retry at the new address given by the Contact header field (Section 20.10). The requestor SHOULD update any local directories, address books, and user location caches with this new value and redirect future requests to the address(es) listed.",
      "ja": "ユーザーは、もはや要求URI内のアドレスで見つけることができない、と要求しているクライアントは、Contactヘッダーフィールド（セクション20.10）によって与えられた新しいアドレスで再試行する必要があります。要求者はこの新しい値を持つ任意のローカルディレクトリ、アドレス帳、およびユーザの位置キャッシュを更新し、リストされたアドレス（複数可）に今後の要求をリダイレクトする必要があります。"
    },
    {
      "indent": 0,
      "text": "21.3.3 302 Moved Temporarily",
      "section_title": true,
      "ja": "21.3.3 302は、一時的に移動します"
    },
    {
      "indent": 3,
      "text": "The requesting client SHOULD retry the request at the new address(es) given by the Contact header field (Section 20.10). The Request-URI of the new request uses the value of the Contact header field in the response.",
      "ja": "要求しているクライアントは、Contactヘッダーフィールド（セクション20.10）によって与えられた新しいアドレス（複数可）で要求を再試行する必要があります。新しいリクエストのRequest-URIは、応答のContactヘッダーフィールドの値を使用しています。"
    },
    {
      "indent": 3,
      "text": "The duration of the validity of the Contact URI can be indicated through an Expires (Section 20.19) header field or an expires parameter in the Contact header field. Both proxies and UAs MAY cache this URI for the duration of the expiration time. If there is no explicit expiration time, the address is only valid once for recursing, and MUST NOT be cached for future transactions.",
      "ja": "（セクション20.19）ヘッダーフィールドの有効期限が切れるかContactヘッダフィールドにパラメータを満了するを通じて接触URIの有効期間を示すことができます。どちらもプロキシとUAは有効期限の期間中、このURIをキャッシュすることができます。明示的な有効期限がない場合、アドレスは再帰のために一度だけ有効であり、将来の取引のためにキャッシュされてはなりません。"
    },
    {
      "indent": 3,
      "text": "If the URI cached from the Contact header field fails, the Request-URI from the redirected request MAY be tried again a single time.",
      "ja": "ContactヘッダーフィールドからURIのキャッシュされたが失敗した場合、リダイレクトされたリクエストからのRequest-URIは再び単一の時間を試してみましたかもしれません。"
    },
    {
      "indent": 6,
      "text": "The temporary URI may have become out-of-date sooner than the expiration time, and a new temporary URI may be available.",
      "ja": "一時的なURIは有効期限よりも古く早くなっている可能性があり、新しい一時的なURIが利用可能であってもよいです。"
    },
    {
      "indent": 0,
      "text": "21.3.4 305 Use Proxy",
      "section_title": true,
      "ja": "21.3.4 305プロキシを使用"
    },
    {
      "indent": 3,
      "text": "The requested resource MUST be accessed through the proxy given by the Contact field. The Contact field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 (Use Proxy) responses MUST only be generated by UASs.",
      "ja": "要求されたリソースは、Contactフィールドに指定されたプロキシ経由でアクセスする必要があります。 ContactフィールドはプロキシのURIを提供します。受信者は、プロキシを経由してこの単一の要求を繰り返すことが予想されます。 305（プロキシを使用）応答は唯一のUASによって生成されなければなりません。"
    },
    {
      "indent": 0,
      "text": "21.3.5 380 Alternative Service",
      "section_title": true,
      "ja": "21.3.5 380代替サービス"
    },
    {
      "indent": 3,
      "text": "The call was not successful, but alternative services are possible.",
      "ja": "呼び出しが成功しませんでしたが、代替サービスが可能です。"
    },
    {
      "indent": 3,
      "text": "The alternative services are described in the message body of the response. Formats for such bodies are not defined here, and may be the subject of future standardization.",
      "ja": "代替サービスは、応答のメッセージボディに記述されています。そのような体のためのフォーマットは、ここで定義されていない、そして将来の標準化の対象とすることができます。"
    },
    {
      "indent": 0,
      "text": "21.4 Request Failure 4xx",
      "section_title": true,
      "ja": "21.4要求失敗の4xx"
    },
    {
      "indent": 3,
      "text": "4xx responses are definite failure responses from a particular server. The client SHOULD NOT retry the same request without modification (for example, adding appropriate authorization). However, the same request to a different server might be successful.",
      "ja": "4xx応答は、特定のサーバーからの明確な障害応答です。クライアントは、（例えば、適切な権限を追加する）変更することなく、同じ要求を再試行すべきではありません。しかし、別のサーバーに同じ要求が成功したかもしれません。"
    },
    {
      "indent": 0,
      "text": "21.4.1 400 Bad Request",
      "section_title": true,
      "ja": "21.4.1 400不正な要求"
    },
    {
      "indent": 3,
      "text": "The request could not be understood due to malformed syntax. The Reason-Phrase SHOULD identify the syntax problem in more detail, for example, \"Missing Call-ID header field\".",
      "ja": "リクエストの文法が間違っているために理解することができませんでした。理由-フレーズは、「Call-IDヘッダーフィールドがありません」、例えば、より詳細に構文上の問題を特定する必要があります。"
    },
    {
      "indent": 0,
      "text": "21.4.2 401 Unauthorized",
      "section_title": true,
      "ja": "21.4.2 401権限"
    },
    {
      "indent": 3,
      "text": "The request requires user authentication. This response is issued by UASs and registrars, while 407 (Proxy Authentication Required) is used by proxy servers.",
      "ja": "要求は、ユーザの認証が必要です。 407（プロキシ認証が必要）は、プロキシサーバーで使用されている間、この応答は、のUASおよびレジストラが発行されます。"
    },
    {
      "indent": 0,
      "text": "21.4.3 402 Payment Required",
      "section_title": true,
      "ja": "21.4.3 402支払いが必要"
    },
    {
      "indent": 3,
      "text": "Reserved for future use.",
      "ja": "将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "21.4.4 403 Forbidden",
      "section_title": true,
      "ja": "21.4.4 403禁止"
    },
    {
      "indent": 3,
      "text": "The server understood the request, but is refusing to fulfill it. Authorization will not help, and the request SHOULD NOT be repeated.",
      "ja": "サーバーは要求を理解したが、それを実行することを拒否しています。承認は助けにはなりませんし、要求が繰り返されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "21.4.5 404 Not Found",
      "section_title": true,
      "ja": "21.4.5 404が見つかりません"
    },
    {
      "indent": 3,
      "text": "The server has definitive information that the user does not exist at the domain specified in the Request-URI. This status is also returned if the domain in the Request-URI does not match any of the domains handled by the recipient of the request.",
      "ja": "サーバは、ユーザが要求URIで指定されたドメインに存在しないという決定的な情報を持っています。要求URI内のドメインは、要求の受信者が取り扱うドメインのいずれかと一致しない場合、このステータスも返されます。"
    },
    {
      "indent": 0,
      "text": "21.4.6 405 Method Not Allowed",
      "section_title": true,
      "ja": "21.4.6 405メソッドは許可されていません"
    },
    {
      "indent": 3,
      "text": "The method specified in the Request-Line is understood, but not allowed for the address identified by the Request-URI.",
      "ja": "リクエストラインで指定された方法は理解したが、要求URIによって識別されるアドレスは許可されていません。"
    },
    {
      "indent": 3,
      "text": "The response MUST include an Allow header field containing a list of valid methods for the indicated address.",
      "ja": "応答は、示されたアドレスのための有効な方法のリストを含む許可ヘッダーフィールドを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "21.4.7 406 Not Acceptable",
      "section_title": true,
      "ja": "21.4.7 406受け入れられません"
    },
    {
      "indent": 3,
      "text": "The resource identified by the request is only capable of generating response entities that have content characteristics not acceptable according to the Accept header field sent in the request.",
      "ja": "リクエストによって識別されたリソースは、リクエストで送信されたAcceptヘッダーフィールドに従って受け入れられないコンテンツ特性を持つ応答エンティティを生成することができるだけです。"
    },
    {
      "indent": 0,
      "text": "21.4.8 407 Proxy Authentication Required",
      "section_title": true,
      "ja": "21.4.8 407プロキシ認証が必要"
    },
    {
      "indent": 3,
      "text": "This code is similar to 401 (Unauthorized), but indicates that the client MUST first authenticate itself with the proxy. SIP access authentication is explained in Sections 26 and 22.3.",
      "ja": "このコードは401（不正）に類似しているが、クライアントが最初にプロキシで自身を認証しなければならないことを示しています。 SIPアクセス認証はセクション26と22.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "This status code can be used for applications where access to the communication channel (for example, a telephony gateway) rather than the callee requires authentication.",
      "ja": "このステータスコードはむしろ被呼よりも（例えば、電話ゲートウェイ）通信チャネルへのアクセスが認証を必要とする用途に使用することができます。"
    },
    {
      "indent": 0,
      "text": "21.4.9 408 Request Timeout",
      "section_title": true,
      "ja": "21.4.9 408リクエストタイムアウト"
    },
    {
      "indent": 3,
      "text": "The server could not produce a response within a suitable amount of time, for example, if it could not determine the location of the user in time. The client MAY repeat the request without modifications at any later time.",
      "ja": "それは時間にユーザの位置を決定できなかった場合、サーバは、例えば、適切な時間内に応答を作成できませんでした。クライアントは、それ以降の時間に変更することなく、要求を繰り返してもよいです。"
    },
    {
      "indent": 0,
      "text": "21.4.10 410 Gone",
      "section_title": true,
      "ja": "21.4.10 410ゴーン"
    },
    {
      "indent": 3,
      "text": "The requested resource is no longer available at the server and no forwarding address is known. This condition is expected to be considered permanent. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead.",
      "ja": "要求されたリソースは、サーバーとなし、転送先アドレスが知られている時に使用できなくなりました。この状態は永久的と見なされることが予想されます。サーバは状態が永久的であるかどうか、知っている、または決定するための施設を持っていないいない場合は、ステータスコード404（見つかりません）が代わりに使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "21.4.11 413 Request Entity Too Large",
      "section_title": true,
      "ja": "21.4.11 413要求エンティティが大きすぎます"
    },
    {
      "indent": 3,
      "text": "The server is refusing to process a request because the request entity-body is larger than the server is willing or able to process. The server MAY close the connection to prevent the client from continuing the request.",
      "ja": "サーバは、要求エンティティボディは、サーバが喜んまたは処理することができるよりも大きいため、要求を処理するために拒否されます。サーバーは、クライアントがリクエストを継続することを防止するために、接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "If the condition is temporary, the server SHOULD include a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.",
      "ja": "条件が一時的である場合、サーバはそれが一時的なもので、何時間後にクライアントが再試行してください可能性があることを示すために再試行-Afterヘッダフィールドを含むべきです。"
    },
    {
      "indent": 0,
      "text": "21.4.12 414 Request-URI Too Long",
      "section_title": true,
      "ja": "21.4.12 414のRequest-URIが長すぎます"
    },
    {
      "indent": 3,
      "text": "The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret.",
      "ja": "サーバは、サーバが解釈していく所存ですよりも、リクエスト-URIが長くなるため、要求のサービスを拒否しています。"
    },
    {
      "indent": 0,
      "text": "21.4.13 415 Unsupported Media Type",
      "section_title": true,
      "ja": "21.4.13 415サポートされていないメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The server is refusing to service the request because the message body of the request is in a format not supported by the server for the requested method. The server MUST return a list of acceptable formats using the Accept, Accept-Encoding, or Accept-Language header field, depending on the specific problem with the content. UAC processing of this response is described in Section 8.1.3.5.",
      "ja": "サーバは、要求のメッセージ本体は要求されたメソッドのためのサーバでサポートされていない形式であるため、要求のサービスを拒否しています。サーバは、コンテンツを含む特定の問題に応じて、受け入れ承諾をコードする、またはAccept-Languageヘッダーフィールドを使用して、許容される形式のリストを返さなければなりません。この応答のUAC処理は、セクション8.1.3.5に記載されています。"
    },
    {
      "indent": 0,
      "text": "21.4.14 416 Unsupported URI Scheme",
      "section_title": true,
      "ja": "21.4.14 416サポートされていないURIスキーム"
    },
    {
      "indent": 3,
      "text": "The server cannot process the request because the scheme of the URI in the Request-URI is unknown to the server. Client processing of this response is described in Section 8.1.3.5.",
      "ja": "リクエスト-URIでURIのスキームがサーバーに不明であるため、サーバーは要求を処理することはできません。この応答のクライアントの処理は、セクション8.1.3.5に記載されています。"
    },
    {
      "indent": 0,
      "text": "21.4.15 420 Bad Extension",
      "section_title": true,
      "ja": "21.4.15 420バート・拡張"
    },
    {
      "indent": 3,
      "text": "The server did not understand the protocol extension specified in a Proxy-Require (Section 20.29) or Require (Section 20.32) header field. The server MUST include a list of the unsupported extensions in an Unsupported header field in the response. UAC processing of this response is described in Section 8.1.3.5.",
      "ja": "サーバは、プロキシ要求（セクション20.29）で指定されたプロトコル拡張を理解したり（セクション20.32）ヘッダーフィールドを必要としませんでした。サーバが応答してサポートされていないヘッダフィールドでサポートされていない拡張子のリストを含まなければなりません。この応答のUAC処理は、セクション8.1.3.5に記載されています。"
    },
    {
      "indent": 0,
      "text": "21.4.16 421 Extension Required",
      "section_title": true,
      "ja": "21.4.16 421拡張に必要な"
    },
    {
      "indent": 3,
      "text": "The UAS needs a particular extension to process the request, but this extension is not listed in a Supported header field in the request. Responses with this status code MUST contain a Require header field listing the required extensions.",
      "ja": "UASは、要求を処理するために特定の拡張を必要とするが、この拡張は、リクエストにSupportedヘッダフィールドにリストされていません。このステータスコードで応答が必要な拡張子をリストRequireヘッダーフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A UAS SHOULD NOT use this response unless it truly cannot provide any useful service to the client. Instead, if a desirable extension is not listed in the Supported header field, servers SHOULD process the request using baseline SIP capabilities and any extensions supported by the client.",
      "ja": "それは本当にクライアントに任意の有用なサービスを提供できない場合を除きUASは、この応答を使用しないでください。望ましい拡張がSupportedヘッダーフィールドにリストされていない場合は代わりに、サーバーはベースラインSIP能力とクライアントでサポートされている任意の拡張子を使用して要求を処理しなければなりません。"
    },
    {
      "indent": 0,
      "text": "21.4.17 423 Interval Too Brief",
      "section_title": true,
      "ja": "21.4.17 423間隔あまりにも簡単"
    },
    {
      "indent": 3,
      "text": "The server is rejecting the request because the expiration time of the resource refreshed by the request is too short. This response can be used by a registrar to reject a registration whose Contact header field expiration time was too small. The use of this response and the related Min-Expires header field are described in Sections 10.2.8, 10.3, and 20.23.",
      "ja": "リクエストによって更新リソースの有効期限が短すぎるため、サーバーは要求を拒否しています。この応答は、その連絡先ヘッダフィールドの有効期限が小さすぎた登録を拒否するレジストラで使用することができます。この応答と関連ミン期限切れヘッダフィールドの使用は、セクション10.2.8に10.3、および20.23に記載されています。"
    },
    {
      "indent": 0,
      "text": "21.4.18 480 Temporarily Unavailable",
      "section_title": true,
      "ja": "21.4.18 480一時的に利用できません"
    },
    {
      "indent": 3,
      "text": "The callee's end system was contacted successfully but the callee is currently unavailable (for example, is not logged in, logged in but in a state that precludes communication with the callee, or has activated the \"do not disturb\" feature). The response MAY indicate a better time to call in the Retry-After header field. The user could also be available elsewhere (unbeknownst to this server). The reason phrase SHOULD indicate a more precise cause as to why the callee is unavailable. This value SHOULD be settable by the UA. Status 486 (Busy Here) MAY be used to more precisely indicate a particular reason for the call failure.",
      "ja": "呼び出し先のエンドシステムが正常に接触させたが、呼び出し先が現在使用できません（例えば、ログインしていない、ログインが、呼び出し先との通信を排除する、または機能を「邪魔しないで」起動した状態で）。応答は、再試行の後ヘッダフィールドに呼び出す良い時間を示すことができます。また、ユーザーは別の場所（このサーバに知られず）が利用可能である可能性があります。理由句は、呼び出し先が使用できない理由として、より正確な原因を示す必要があります。この値は、UAによって設定可能であるべきです。ステータス486（ここではBusy）がより正確にコール失敗の特定の理由を示すために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "This status is also returned by a redirect or proxy server that recognizes the user identified by the Request-URI, but does not currently have a valid forwarding location for that user.",
      "ja": "このステータスは、要求URIで識別されるユーザーを認識し、リダイレクトまたはプロキシサーバーによって返されたが、現在はそのユーザーの有効な転送場所を持っていません。"
    },
    {
      "indent": 0,
      "text": "21.4.19 481 Call/Transaction Does Not Exist",
      "section_title": true,
      "ja": "21.4.19 481コール/トランザクションが存在しません"
    },
    {
      "indent": 3,
      "text": "This status indicates that the UAS received a request that does not match any existing dialog or transaction.",
      "ja": "このステータスは、UASが任意の既存のダイアログまたはトランザクションと一致しない要求を受信したことを示します。"
    },
    {
      "indent": 0,
      "text": "21.4.20 482 Loop Detected",
      "section_title": true,
      "ja": "21.4.20 482ループ検出"
    },
    {
      "indent": 3,
      "text": "The server has detected a loop (Section 16.3 Item 4).",
      "ja": "サーバは、ループ（セクション16.3項目4）を検出しました。"
    },
    {
      "indent": 0,
      "text": "21.4.21 483 Too Many Hops",
      "section_title": true,
      "ja": "21.4.21 483ホップ数が多すぎ"
    },
    {
      "indent": 3,
      "text": "The server received a request that contains a Max-Forwards (Section 20.22) header field with the value zero.",
      "ja": "サーバは、値ゼロと最大転送し（セクション20.22）ヘッダフィールドを含むリクエストを受信しました。"
    },
    {
      "indent": 0,
      "text": "21.4.22 484 Address Incomplete",
      "section_title": true,
      "ja": "不完全21.4.22 484住所"
    },
    {
      "indent": 3,
      "text": "The server received a request with a Request-URI that was incomplete. Additional information SHOULD be provided in the reason phrase.",
      "ja": "サーバは不完全であったのRequest-URIで要求を受けました。追加情報は、理由句に提供されるべきです。"
    },
    {
      "indent": 6,
      "text": "This status code allows overlapped dialing. With overlapped dialing, the client does not know the length of the dialing string. It sends strings of increasing lengths, prompting the user for more input, until it no longer receives a 484 (Address Incomplete) status response.",
      "ja": "このステータスコードは重複ダイヤリングを可能にします。重複ダイヤルを使用すると、クライアントは、ダイヤル文字列の長さを知りません。それはもはや484（不完全なアドレス）ステータス応答を受信するまでには、より多くのユーザーに入力を促し、増加の長さの文字列を送信しません。"
    },
    {
      "indent": 0,
      "text": "21.4.23 485 Ambiguous",
      "section_title": true,
      "ja": "21.4.23 485あいまい"
    },
    {
      "indent": 3,
      "text": "The Request-URI was ambiguous. The response MAY contain a listing of possible unambiguous addresses in Contact header fields. Revealing alternatives can infringe on privacy of the user or the organization. It MUST be possible to configure a server to respond with status 404 (Not Found) or to suppress the listing of possible choices for ambiguous Request-URIs.",
      "ja": "Request-URIが曖昧でした。応答はContactヘッダーフィールドで可能な明確なアドレスのリストを含むかもしれません。代替案を明らかにすることは、ユーザや組織のプライバシーを侵害することができます。ステータス404（見つかりません）で応答するか、曖昧な要求-URIの可能な選択肢のリストを抑制するためにサーバーを設定することは可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example response to a request with the Request-URI sip:lee@example.com:",
      "ja": "要求URIのSIPとのリクエストに例応答：lee@example.com："
    },
    {
      "indent": 6,
      "text": "SIP/2.0 485 Ambiguous Contact: Carol Lee <sip:carol.lee@example.com> Contact: Ping Lee <sip:p.lee@example.com> Contact: Lee M. Foote <sips:lee.foote@example.com>",
      "ja": "SIP / 2.0 485あいまいな連絡先：キャロル・リー<一口：carol.lee@example.com>連絡先：Pingのリー<一口：p.lee@example.com>お問い合わせ：リーM.フット<一口：lee.foote@example。コム>"
    },
    {
      "indent": 6,
      "text": "Some email and voice mail systems provide this functionality. A status code separate from 3xx is used since the semantics are different: for 300, it is assumed that the same person or service will be reached by the choices provided. While an automated choice or sequential search makes sense for a 3xx response, user intervention is required for a 485 (Ambiguous) response.",
      "ja": "一部の電子メール、ボイスメールシステムは、この機能を提供します。セマンティクスが異なるため3XXから別のステータス・コードが使用される：300のために、同じ人またはサービスが提供される選択肢によって到達されることが想定されます。自動化された選択肢またはシーケンシャル検索が3xx応答のために理にかなっている間、ユーザーの介入は、485（あいまい）応答のために必要です。"
    },
    {
      "indent": 0,
      "text": "21.4.24 486 Busy Here",
      "section_title": true,
      "ja": "ここ21.4.24 486忙しいです"
    },
    {
      "indent": 3,
      "text": "The callee's end system was contacted successfully, but the callee is currently not willing or able to take additional calls at this end system. The response MAY indicate a better time to call in the Retry-After header field. The user could also be available elsewhere, such as through a voice mail service. Status 600 (Busy Everywhere) SHOULD be used if the client knows that no other end system will be able to accept this call.",
      "ja": "呼び出し先のエンドシステムが正常に接触させたが、呼び出し先は現在、喜んまたはこのエンドシステムに追加の電話を取ることができません。応答は、再試行の後ヘッダフィールドに呼び出す良い時間を示すことができます。ユーザーはまた、ボイスメールサービスを介するなど、他の場所で利用可能である可能性があります。クライアントは、他のエンド・システムは、このコールを受け入れることができないことを知っている場合にはステータス600（どこでもBusy）が使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "21.4.25 487 Request Terminated",
      "section_title": true,
      "ja": "21.4.25 487リクエストが終了"
    },
    {
      "indent": 3,
      "text": "The request was terminated by a BYE or CANCEL request. This response is never returned for a CANCEL request itself.",
      "ja": "要求がBYEで終了したり、要求をキャンセルされました。この応答は、CANCELリクエスト自身のために返されることはありません。"
    },
    {
      "indent": 0,
      "text": "21.4.26 488 Not Acceptable Here",
      "section_title": true,
      "ja": "ここ21.4.26 488許容できません"
    },
    {
      "indent": 3,
      "text": "The response has the same meaning as 606 (Not Acceptable), but only applies to the specific resource addressed by the Request-URI and the request may succeed elsewhere.",
      "ja": "レスポンスは606（許容できない）と同じ意味を持っているが、唯一のRequest-URIと要求他の場所で成功するかもしれによって対処特定のリソースに適用されます。"
    },
    {
      "indent": 3,
      "text": "A message body containing a description of media capabilities MAY be present in the response, which is formatted according to the Accept header field in the INVITE (or application/sdp if not present), the same as a message body in a 200 (OK) response to an OPTIONS request.",
      "ja": "メディア機能の記述を含むメッセージ本体（存在しない場合、またはアプリケーション/ SDP）INVITEにおけるAcceptヘッダーフィールド、200（OK）のメッセージボディと同じに従ってフォーマットされた応答中に存在してもよいですOPTIONS要求への応答。"
    },
    {
      "indent": 0,
      "text": "21.4.27 491 Request Pending",
      "section_title": true,
      "ja": "21.4.27 491リクエスト保留中"
    },
    {
      "indent": 3,
      "text": "The request was received by a UAS that had a pending request within the same dialog. Section 14.2 describes how such \"glare\" situations are resolved.",
      "ja": "要求は、同じダイアログ内に保留中の要求を持っていたUASが受信しました。 14.2は、このような「グレア」状況が解決される方法を説明します。"
    },
    {
      "indent": 0,
      "text": "21.4.28 493 Undecipherable",
      "section_title": true,
      "ja": "21.4.28 493解読不能"
    },
    {
      "indent": 3,
      "text": "The request was received by a UAS that contained an encrypted MIME body for which the recipient does not possess or will not provide an appropriate decryption key. This response MAY have a single body containing an appropriate public key that should be used to encrypt MIME bodies sent to this UA. Details of the usage of this response code can be found in Section 23.2.",
      "ja": "要求は、受信者が所有していないか、適切な復号鍵を提供することはありませんそのために暗号化されたMIMEボディを含まUASが受信しました。この応答は、このUAに送られるMIMEボディを暗号化するために使用されるべき適切な公開鍵を含む単一のボディを持っているかもしれません。このレスポンスコードの使用方法の詳細については、セクション23.2で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "21.5 Server Failure 5xx",
      "section_title": true,
      "ja": "21.5サーバ障害の5xx"
    },
    {
      "indent": 3,
      "text": "5xx responses are failure responses given when a server itself has erred.",
      "ja": "5xx応答は、サーバー自体が誤りを犯した時に与えられた失敗応答です。"
    },
    {
      "indent": 0,
      "text": "21.5.1 500 Server Internal Error",
      "section_title": true,
      "ja": "21.5.1 500サーバー内部エラー"
    },
    {
      "indent": 3,
      "text": "The server encountered an unexpected condition that prevented it from fulfilling the request. The client MAY display the specific error condition and MAY retry the request after several seconds.",
      "ja": "サーバーは、要求を満たすことを妨げる予期しない状態に遭遇しました。クライアントは、特定のエラー状態を表示するかもしれなくて、数秒後に要求を再試行してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "If the condition is temporary, the server MAY indicate when the client may retry the request using the Retry-After header field.",
      "ja": "状態が一時的なものである場合、クライアントが再試行-Afterヘッダフィールドを使用して要求を再試行する際に、サーバが示すかもしれ。"
    },
    {
      "indent": 0,
      "text": "21.5.2 501 Not Implemented",
      "section_title": true,
      "ja": "21.5.2 501が実装されていません"
    },
    {
      "indent": 3,
      "text": "The server does not support the functionality required to fulfill the request. This is the appropriate response when a UAS does not recognize the request method and is not capable of supporting it for any user. (Proxies forward all requests regardless of method.)",
      "ja": "サーバは要求を満たすために必要な機能をサポートしていません。これは、UASがリクエストメソッドを認識しない、任意のユーザのためにそれをサポートすることができないん適切な応答です。 （プロキシは関係なく、メソッドのすべての要求を転送します。）"
    },
    {
      "indent": 3,
      "text": "Note that a 405 (Method Not Allowed) is sent when the server recognizes the request method, but that method is not allowed or supported.",
      "ja": "なお、405（方法は許可されていません）サーバがリクエストメソッドを認識しますが、そのメソッドが許可またはサポートされていないときに送信されます。"
    },
    {
      "indent": 0,
      "text": "21.5.3 502 Bad Gateway",
      "section_title": true,
      "ja": "21.5.3 502不正なゲートウェイ"
    },
    {
      "indent": 3,
      "text": "The server, while acting as a gateway or proxy, received an invalid response from the downstream server it accessed in attempting to fulfill the request.",
      "ja": "サーバは、ゲートウェイまたはプロキシとして動作しながら、それが要求を満たすために試みでアクセスダウンストリームサーバから無効な応答を受け取りました。"
    },
    {
      "indent": 0,
      "text": "21.5.4 503 Service Unavailable",
      "section_title": true,
      "ja": "21.5.4 503サービスを使用できません"
    },
    {
      "indent": 3,
      "text": "The server is temporarily unable to process the request due to a temporary overloading or maintenance of the server. The server MAY indicate when the client should retry the request in a Retry-After header field. If no Retry-After is given, the client MUST act as if it had received a 500 (Server Internal Error) response.",
      "ja": "サーバーが一時的にサーバーの一時的な過負荷またはメンテナンスのためにリクエストを処理することができません。クライアントが再試行-Afterヘッダーフィールドで要求を再試行する必要がある場合に、サーバーが示すかもしれ。何のリトライ後が与えられない場合、それは500（Server Internal Error）応答を受け取ったかのように、クライアントは行動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client (proxy or UAC) receiving a 503 (Service Unavailable) SHOULD attempt to forward the request to an alternate server. It SHOULD NOT forward any other requests to that server for the duration specified in the Retry-After header field, if present.",
      "ja": "503（サービス利用不可）を受信するクライアント（プロキシまたはUAC）は、代替サーバに要求を転送しようとすべきです。存在する場合には、再試行-Afterヘッダフィールドで指定された期間のためにそのサーバーに他の要求を転送すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Servers MAY refuse the connection or drop the request instead of responding with 503 (Service Unavailable).",
      "ja": "サーバーは接続を拒否するか、503（サービス利用不可）で応答するのではなく、要求をドロップすることがあります。"
    },
    {
      "indent": 0,
      "text": "21.5.5 504 Server Time-out",
      "section_title": true,
      "ja": "21.5.5 504サーバータイムアウト"
    },
    {
      "indent": 3,
      "text": "The server did not receive a timely response from an external server it accessed in attempting to process the request. 408 (Request Timeout) should be used instead if there was no response within the period specified in the Expires header field from the upstream server.",
      "ja": "サーバはリクエストを処理するためにアクセスし、外部サーバからタイムリーな応答を受信しませんでした。上流のサーバからExpiresヘッダーフィールドに指定された期間内に応答がなかった場合408（要求タイムアウト）が代わりに使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "21.5.6 505 Version Not Supported",
      "section_title": true,
      "ja": "21.5.6 505バージョンがサポートされていません"
    },
    {
      "indent": 3,
      "text": "The server does not support, or refuses to support, the SIP protocol version that was used in the request. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, other than with this error message.",
      "ja": "サーバがサポートする、または、要求で使用されたSIPプロトコルのバージョンをサポートすることを拒否していません。サーバは、このエラーメッセージよりも、他のクライアントと同じメジャーバージョンを使用して要求を完了できないか、不本意であることを示しています。"
    },
    {
      "indent": 0,
      "text": "21.5.7 513 Message Too Large",
      "section_title": true,
      "ja": "21.5.7 513メッセージが大きすぎます"
    },
    {
      "indent": 3,
      "text": "The server was unable to process the request since the message length exceeded its capabilities.",
      "ja": "サーバーは、メッセージの長さがその能力を超えたため、要求を処理できませんでした。"
    },
    {
      "indent": 0,
      "text": "21.6 Global Failures 6xx",
      "section_title": true,
      "ja": "21.6グローバル失敗の6xx"
    },
    {
      "indent": 3,
      "text": "6xx responses indicate that a server has definitive information about a particular user, not just the particular instance indicated in the Request-URI.",
      "ja": "6xx応答はサーバーが要求URIで示されている特定のユーザーに関する決定的な情報だけではなく、特定のインスタンスを持っていることを示しています。"
    },
    {
      "indent": 0,
      "text": "21.6.1 600 Busy Everywhere",
      "section_title": true,
      "ja": "21.6.1どこでも600ビジー"
    },
    {
      "indent": 3,
      "text": "The callee's end system was contacted successfully but the callee is busy and does not wish to take the call at this time. The response MAY indicate a better time to call in the Retry-After header field. If the callee does not wish to reveal the reason for declining the call, the callee uses status code 603 (Decline) instead. This status response is returned only if the client knows that no other end point (such as a voice mail system) will answer the request. Otherwise, 486 (Busy Here) should be returned.",
      "ja": "呼び出し先のエンドシステムが正常に接触させたが、呼び出し先がビジー状態であると、この時点で電話に出たくありません。応答は、再試行の後ヘッダフィールドに呼び出す良い時間を示すことができます。呼び出し先が呼び出しを衰退の理由を明らかにすることを希望しない場合は、呼び出し先は、代わりにステータスコード603（下落）を使用しています。このステータス応答は、クライアントが（例えばボイスメールシステムなど）は、他のエンドポイントがリクエストにお答えしていないことを知っている場合にのみ返されます。それ以外の場合は、486（ここでBusy）が返されるべきです。"
    },
    {
      "indent": 0,
      "text": "21.6.2 603 Decline",
      "section_title": true,
      "ja": "21.6.2 603衰退"
    },
    {
      "indent": 3,
      "text": "The callee's machine was successfully contacted but the user explicitly does not wish to or cannot participate. The response MAY indicate a better time to call in the Retry-After header field. This status response is returned only if the client knows that no other end point will answer the request.",
      "ja": "呼び出し先のマシンが正常に接触させたが、ユーザーが明示的に希望していないか、参加することはできません。応答は、再試行の後ヘッダフィールドに呼び出す良い時間を示すことができます。このステータス応答は、クライアントが他のエンドポイントがリクエストにお答えしていないことを知っている場合にのみ返されます。"
    },
    {
      "indent": 0,
      "text": "21.6.3 604 Does Not Exist Anywhere",
      "section_title": true,
      "ja": "21.6.3 604はどこにも存在しません"
    },
    {
      "indent": 3,
      "text": "The server has authoritative information that the user indicated in the Request-URI does not exist anywhere.",
      "ja": "サーバーは、Request-URIで示されたユーザーがどこにも存在しないという信頼できる情報を持っています。"
    },
    {
      "indent": 0,
      "text": "21.6.4 606 Not Acceptable",
      "section_title": true,
      "ja": "21.6.4 606受け入れられません"
    },
    {
      "indent": 3,
      "text": "The user's agent was contacted successfully but some aspects of the session description such as the requested media, bandwidth, or addressing style were not acceptable.",
      "ja": "ユーザーのエージェントが正常に接触させたが、そのような要求されたメディア、帯域幅、またはアドレッシングスタイルのようにセッション記述のいくつかの側面は、許容できるものではなかったです。"
    },
    {
      "indent": 3,
      "text": "A 606 (Not Acceptable) response means that the user wishes to communicate, but cannot adequately support the session described. The 606 (Not Acceptable) response MAY contain a list of reasons in a Warning header field describing why the session described cannot be supported. Warning reason codes are listed in Section 20.43.",
      "ja": "606（許容できない）応答は、ユーザが通信したいが、十分に説明セッションをサポートすることができないことを意味します。 606（許容できない）応答を説明セッションをサポートすることができない理由を説明する警告ヘッダフィールドの理由のリストを含むことができます。警告の理由コードは、セクション20.43に記載されています。"
    },
    {
      "indent": 3,
      "text": "A message body containing a description of media capabilities MAY be present in the response, which is formatted according to the Accept header field in the INVITE (or application/sdp if not present), the same as a message body in a 200 (OK) response to an OPTIONS request.",
      "ja": "メディア機能の記述を含むメッセージ本体（存在しない場合、またはアプリケーション/ SDP）INVITEにおけるAcceptヘッダーフィールド、200（OK）のメッセージボディと同じに従ってフォーマットされた応答中に存在してもよいですOPTIONS要求への応答。"
    },
    {
      "indent": 3,
      "text": "It is hoped that negotiation will not frequently be needed, and when a new user is being invited to join an already existing conference, negotiation may not be possible. It is up to the invitation initiator to decide whether or not to act on a 606 (Not Acceptable) response.",
      "ja": "その交渉が頻繁に必要とされることはありません期待され、そして新しいユーザーが既存の会議に招待されている場合、交渉はできないことがあります。それは606（許容できない）応答に作用するかどうかを決定するために招待イニシエータ次第です。"
    },
    {
      "indent": 3,
      "text": "This status response is returned only if the client knows that no other end point will answer the request.",
      "ja": "このステータス応答は、クライアントが他のエンドポイントがリクエストにお答えしていないことを知っている場合にのみ返されます。"
    },
    {
      "indent": 0,
      "text": "22 Usage of HTTP Authentication",
      "ja": "HTTP認証の22使い方"
    },
    {
      "indent": 3,
      "text": "SIP provides a stateless, challenge-based mechanism for authentication that is based on authentication in HTTP. Any time that a proxy server or UA receives a request (with the exceptions given in Section 22.1), it MAY challenge the initiator of the request to provide assurance of its identity. Once the originator has been identified, the recipient of the request SHOULD ascertain whether or not this user is authorized to make the request in question. No authorization systems are recommended or discussed in this document.",
      "ja": "SIPは、HTTPでの認証に基づいて認証のためのステートレス、チャレンジベースのメカニズムを提供します。プロキシサーバーまたはUAが（セクション22.1で与えられた例外を除いて）要求を受信したときはいつでも、それは、そのアイデンティティの保証を提供するために、要求のイニシエータを忌避することができます。発信元が特定されたら、リクエストの受信者は、このユーザーが問題の要求を行うことを許可されているかどうかを確認すべきです。いいえ承認システムは推奨しないか、このドキュメントで説明されています。"
    },
    {
      "indent": 3,
      "text": "The \"Digest\" authentication mechanism described in this section provides message authentication and replay protection only, without message integrity or confidentiality. Protective measures above and beyond those provided by Digest need to be taken to prevent active attackers from modifying SIP requests and responses.",
      "ja": "このセクションで説明する「ダイジェスト」認証メカニズムは、メッセージの完全性や機密性なしに、メッセージ認証とリプレイ保護のみを提供します。上記とダイジェストが提供するものを超えた保護対策は、SIPリクエストとレスポンスを変更することから、アクティブな攻撃を防ぐために取られる必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that due to its weak security, the usage of \"Basic\" authentication has been deprecated. Servers MUST NOT accept credentials using the \"Basic\" authorization scheme, and servers also MUST NOT challenge with \"Basic\". This is a change from RFC 2543.",
      "ja": "、その弱いセキュリティに、「基本」認証の使用は推奨されていることに注意してください。サーバーは、「基本」認可スキームを使用して資格情報を受け入れてはいけませんし、サーバーも「基本」に挑戦してはなりません。これは、RFC 2543からの変更点です。"
    },
    {
      "indent": 0,
      "text": "22.1 Framework",
      "section_title": true,
      "ja": "22.1フレームワーク"
    },
    {
      "indent": 3,
      "text": "The framework for SIP authentication closely parallels that of HTTP (RFC 2617 [17]). In particular, the BNF for auth-scheme, auth-param, challenge, realm, realm-value, and credentials is identical (although the usage of \"Basic\" as a scheme is not permitted). In SIP, a UAS uses the 401 (Unauthorized) response to challenge the identity of a UAC. Additionally, registrars and redirect servers MAY make use of 401 (Unauthorized) responses for authentication, but proxies MUST NOT, and instead MAY use the 407 (Proxy Authentication Required) response. The requirements for inclusion of the Proxy-Authenticate, Proxy-Authorization, WWW-Authenticate, and Authorization in the various messages are identical to those described in RFC 2617 [17].",
      "ja": "SIP認証のフレームワークは、密接にHTTP（RFC 2617 [17]）のものに匹敵します。具体的には、AUTH-スキーム、AUTH-PARAM、チャレンジ、レルム、レルム値、および資格情報のBNFは同一である（ただしスキームを許可しないように「基本」の使用）。 SIPにおいて、UASは、UACのアイデンティティに挑戦する401（不正な）応答を使用します。また、407（プロキシ認証が必要）応答を使用するかもしれ代わりに、レジストラとリダイレクトサーバーは、認証のための401（不正な）応答を利用することができるが、プロキシはならず、。様々なメッセージ中のプロキシ認証、プロキシ認証、WWW認証、および認可を含めるための要件は、RFC 2617 [17]に記載のものと同一です。"
    },
    {
      "indent": 3,
      "text": "Since SIP does not have the concept of a canonical root URL, the notion of protection spaces is interpreted differently in SIP. The realm string alone defines the protection domain. This is a change from RFC 2543, in which the Request-URI and the realm together defined the protection domain.",
      "ja": "SIPは正規のルートURLの概念がありませんので、保護空間の概念は、SIPに異なって解釈されます。 realm文字列だけでは保護ドメインを定義します。これは、Request-URIとレルムが一緒に保護ドメインを定義しているRFC 2543から変更されています。"
    },
    {
      "indent": 6,
      "text": "This previous definition of protection domain caused some amount of confusion since the Request-URI sent by the UAC and the Request-URI received by the challenging server might be different, and indeed the final form of the Request-URI might not be known to the UAC. Also, the previous definition depended on the presence of a SIP URI in the Request-URI and seemed to rule out alternative URI schemes (for example, the tel URL).",
      "ja": "UACとRequest-URIにより送信された要求URIが困難なサーバが異なる場合がありますが受信し、そして実際のRequest-URIの最終的な形がに知られていない可能性がありますので、保護ドメインのこの前の定義は混乱のいくつかの量を引き起こしましたUAC。また、以前の定義は、Request-URI内のSIP URIの存在に依存し、（例えば、TEL URLの）代替のURIスキームを除外するように見えました。"
    },
    {
      "indent": 3,
      "text": "Operators of user agents or proxy servers that will authenticate received requests MUST adhere to the following guidelines for creation of a realm string for their server:",
      "ja": "そのサーバーのレルム文字列を作成するため、以下のガイドラインに準拠する必要があり、受信した要求を認証するユーザーエージェントやプロキシサーバーの演算子："
    },
    {
      "indent": 6,
      "text": "o Realm strings MUST be globally unique. It is RECOMMENDED that a realm string contain a hostname or domain name, following the recommendation in Section 3.2.1 of RFC 2617 [17].",
      "ja": "Oレルム文字列はグローバルに一意でなければなりません。レルム文字列がRFC 2617 [17]のセクション3.2.1で推奨に従って、ホスト名またはドメイン名が含まれていることが推奨されます。"
    },
    {
      "indent": 6,
      "text": "o Realm strings SHOULD present a human-readable identifier that can be rendered to a user.",
      "ja": "Oレルム文字列をユーザにレンダリングすることができる人間可読識別子を提示しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Authorization: Digest realm=\"biloxi.com\", <...>",
      "ja": "bob@biloxi.com SIP / 2.0認証：SIPのINVITEレルムをダイジェスト= \"biloxi.com\"、<...>"
    },
    {
      "indent": 3,
      "text": "Generally, SIP authentication is meaningful for a specific realm, a protection domain. Thus, for Digest authentication, each such protection domain has its own set of usernames and passwords. If a server does not require authentication for a particular request, it MAY accept a default username, \"anonymous\", which has no password (password of \"\"). Similarly, UACs representing many users, such as PSTN gateways, MAY have their own device-specific username and password, rather than accounts for particular users, for their realm.",
      "ja": "一般的に、SIP認証は特定のレルム、保護ドメインのための有意義です。このように、ダイジェスト認証のために、各そのような保護ドメインは、ユーザー名とパスワードの独自のセットを持っています。サーバは特定の要求に対する認証を必要としない場合、それは、パスワードなし（「」のパスワード）を持っていない「匿名」を、デフォルトのユーザー名を受け入れることができます。同様に、PSTNゲートウェイとして多くのユーザーを表す求めるUACは、自分のデバイス固有のユーザー名とパスワードを持っているかもしれません、というよりも自分のレルムの、特定のユーザーを占めています。"
    },
    {
      "indent": 3,
      "text": "While a server can legitimately challenge most SIP requests, there are two requests defined by this document that require special handling for authentication: ACK and CANCEL.",
      "ja": "ACKとCANCEL：サーバーは、合法的に、ほとんどのSIPリクエストに挑戦することができますが、認証のための特別な処理を必要とし、この文書で定義された2つの要求があります。"
    },
    {
      "indent": 3,
      "text": "Under an authentication scheme that uses responses to carry values used to compute nonces (such as Digest), some problems come up for any requests that take no response, including ACK. For this reason, any credentials in the INVITE that were accepted by a server MUST be accepted by that server for the ACK. UACs creating an ACK message will duplicate all of the Authorization and Proxy-Authorization header field values that appeared in the INVITE to which the ACK corresponds. Servers MUST NOT attempt to challenge an ACK.",
      "ja": "（例えばダイジェストなど）ナンスを計算するために使用される値を運ぶために応答を使用する認証スキームの下では、いくつかの問題がACKを含む応答を、取らないすべての要求のために出てきます。このため、サーバーによって受け入れられたINVITEのいずれかの資格情報は、ACKのために、そのサーバーで受け入れなければなりません。 ACKメッセージを作成求めるUACは、ACKが対応するINVITEに現れ認可及びProxy-Authorizationヘッダフィールド値のすべてを複製します。サーバはACKに挑戦しようとしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Although the CANCEL method does take a response (a 2xx), servers MUST NOT attempt to challenge CANCEL requests since these requests cannot be resubmitted. Generally, a CANCEL request SHOULD be accepted by a server if it comes from the same hop that sent the request being canceled (provided that some sort of transport or network layer security association, as described in Section 26.2.1, is in place).",
      "ja": "CANCELメソッドは応答（2xxの）を取るしていますが、これらの要求を再送信することができないため、サーバはリクエストをキャンセル挑戦を試みてはいけません。それがキャンセルされ、要求を送信した同じホップから来る場合は、一般に、CANCEL要求がサーバーによって受け入れられるべきである（セクション26.2.1に記載されているように、トランスポートまたはネットワーク層セキュリティアソシエーションのいくつかの並べ替えは、所定の位置にあることを条件とします）。"
    },
    {
      "indent": 3,
      "text": "When a UAC receives a challenge, it SHOULD render to the user the contents of the \"realm\" parameter in the challenge (which appears in either a WWW-Authenticate header field or Proxy-Authenticate header field) if the UAC device does not already know of a credential for the realm in question. A service provider that pre-configures UAs with credentials for its realm should be aware that users will not have the opportunity to present their own credentials for this realm when challenged at a pre-configured device.",
      "ja": "UACがチャレンジを受信すると、ユーザーにレンダリングされるUACデバイスがすでに知っているしていない場合（WWW-AuthenticateヘッダフィールドまたはProxy-Authenticateヘッダフィールドのいずれかに表示されます）挑戦で「王国」パラメータの内容問題のレルムの資格の。そのレルムの資格情報を使用してのUAをあらかじめ設定し、サービスプロバイダは、ユーザーがあらかじめ設定されたデバイスに挑戦したときに、このレルムのために、独自の資格情報を提示する機会を持っていないことに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, note that even if a UAC can locate credentials that are associated with the proper realm, the potential exists that these credentials may no longer be valid or that the challenging server will not accept these credentials for whatever reason (especially when \"anonymous\" with no password is submitted). In this instance a server may repeat its challenge, or it may respond with a 403 Forbidden. A UAC MUST NOT re-attempt requests with the credentials that have just been rejected (though the request may be retried if the nonce was stale).",
      "ja": "最後に、UACは、適切なレルムに関連付けられている資格情報を見つけることができた場合でも、可能性はこれらの資格情報は、もはや有効ではないかもしれないということか挑戦サーバが何らかの理由（と特に「匿名」のためにこれらの資格情報を受け付けないことが存在することに注意してくださいパスワードなし）が提出されていません。この例では、サーバはその挑戦を繰り返すことができ、またはそれは禁断の403で応答することができます。 UACは（nonceが古くなった場合は、要求が再試行されるかもしれないが）だけ拒否された資格情報を使用して要求を再試行してはなりません。"
    },
    {
      "indent": 0,
      "text": "22.2 User-to-User Authentication",
      "section_title": true,
      "ja": "22.2ユーザ・ツー・ユーザ認証"
    },
    {
      "indent": 3,
      "text": "When a UAS receives a request from a UAC, the UAS MAY authenticate the originator before the request is processed. If no credentials (in the Authorization header field) are provided in the request, the UAS can challenge the originator to provide credentials by rejecting the request with a 401 (Unauthorized) status code.",
      "ja": "UASは、UACからの要求を受信すると、要求が処理される前に、UASは、発信元を認証することができます。 （Authorizationヘッダフィールド内の）は資格情報が要求中に提供されていない場合、UASは401（不正な）ステータスコードで要求を拒否することによって認証情報を提供するために、発信者に挑戦することができます。"
    },
    {
      "indent": 3,
      "text": "The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the realm.",
      "ja": "WWW認証応答ヘッダフィールドは401（不正な）応答メッセージに含まれなければなりません。フィールド値は、認証方式（S）及び領域に適用可能なパラメータを表す少なくとも一つの挑戦で構成されています。"
    },
    {
      "indent": 3,
      "text": "An example of the WWW-Authenticate header field in a 401 challenge is:",
      "ja": "401チャレンジにWWW-Authenticateヘッダフィールドの例を示します。"
    },
    {
      "indent": 6,
      "text": "WWW-Authenticate: Digest realm=\"biloxi.com\", qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"",
      "ja": "WWW認証：ダイジェスト分野= \"biloxi.com\"、QOP = \"AUTH、AUTH-INT\"、ナンスは= \"dcd98b7102dd2f0e8b11d0f600bfb0c093\"、不透明= \"5ccc069c403ebaf9f0171e9517f40e41\""
    },
    {
      "indent": 3,
      "text": "When the originating UAC receives the 401 (Unauthorized), it SHOULD, if it is able, re-originate the request with the proper credentials. The UAC may require input from the originating user before proceeding. Once authentication credentials have been supplied (either directly by the user, or discovered in an internal keyring), UAs SHOULD cache the credentials for a given value of the To header field and \"realm\" and attempt to re-use these values on the next request for that destination. UAs MAY cache credentials in any way they would like.",
      "ja": "発信UAC 401（不正）を受信することができる場合、それは、適切な資格情報を使用して要求を再発信すべきです。 UACは、続行する前に、発信ユーザからの入力を必要とするかもしれません。認証証明書は、（ユーザによって直接、または内部キーリングに発見）が供給されたら、UAは、フィールドおよび「レルム」ヘッダの所定の値の資格情報をキャッシュし、次に、これらの値を再使用を試みますその先の要求。 UAは、彼らが望む任意の方法で資格情報をキャッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "If no credentials for a realm can be located, UACs MAY attempt to retry the request with a username of \"anonymous\" and no password (a password of \"\").",
      "ja": "レルムの資格情報が配置できない場合は、求めるUACは「匿名」のユーザー名とパスワードなし（「」のパスワード）でリクエストを再試行してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Once credentials have been located, any UA that wishes to authenticate itself with a UAS or registrar -- usually, but not necessarily, after receiving a 401 (Unauthorized) response -- MAY do so by including an Authorization header field with the request. The Authorization field value consists of credentials containing the authentication information of the UA for the realm of the resource being requested as well as parameters required in support of authentication and replay protection.",
      "ja": "通常、必ずしもそうではないが、401（不正な）応答を受信した後に -   - 資格情報が配置された後、希望する任意のUAは、UASまたはレジストラに自身を認証するための要求にAuthorizationヘッダフィールドを含めることでそれを行うことができます。 Authorizationフィールド値は、認証とリプレイ保護のサポートに必要なパラメータだけでなく、要求されたリソースのレルムのUAの認証情報を含む資格情報で構成されています。"
    },
    {
      "indent": 3,
      "text": "An example of the Authorization header field is:",
      "ja": "Authorizationヘッダフィールドの例を示します。"
    },
    {
      "indent": 6,
      "text": "Authorization: Digest username=\"bob\", realm=\"biloxi.com\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", uri=\"sip:bob@biloxi.com\", qop=auth, nc=00000001, cnonce=\"0a4f113b\", response=\"6629fae49393a05397450978507c4ef1\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"",
      "ja": "認証：ダイジェストユーザ名は= \"ボブ\"、領域= \"biloxi.com\"、ナンス= \"dcd98b7102dd2f0e8b11d0f600bfb0c093\"、URI = \"SIP：bob@biloxi.com\"、QOP = AUTH、NC = 00000001、cnonce = \"0a4f113b\"、応答= \"6629fae49393a05397450978507c4ef1\"、不透明= \"5ccc069c403ebaf9f0171e9517f40e41\""
    },
    {
      "indent": 3,
      "text": "When a UAC resubmits a request with its credentials after receiving a 401 (Unauthorized) or 407 (Proxy Authentication Required) response, it MUST increment the CSeq header field value as it would normally when sending an updated request.",
      "ja": "UAC 401（不正な）または407（プロキシ認証が必要）応答を受信した後に、その資格情報を使用して要求を再送信したときに、それが正常に更新要求を送信する場合と同様に、CSeqヘッダーフィールド値を増加しなければなりません。"
    },
    {
      "indent": 0,
      "text": "22.3 Proxy-to-User Authentication",
      "section_title": true,
      "ja": "22.3プロキシ・ツー・ユーザ認証"
    },
    {
      "indent": 3,
      "text": "Similarly, when a UAC sends a request to a proxy server, the proxy server MAY authenticate the originator before the request is processed. If no credentials (in the Proxy-Authorization header field) are provided in the request, the proxy can challenge the originator to provide credentials by rejecting the request with a 407 (Proxy Authentication Required) status code. The proxy MUST populate the 407 (Proxy Authentication Required) message with a Proxy-Authenticate header field value applicable to the proxy for the requested resource.",
      "ja": "UACは、プロキシサーバに要求を送信する際に、要求が処理される前に、同様に、プロキシサーバは、発信元を認証することができます。 （Proxy-Authorizationヘッダフィールドにおける）は資格情報が要求中に提供されていない場合、プロキシは407（プロキシ認証が必要）ステータスコードで要求を拒否することによって認証情報を提供するために、発信者に挑戦することができます。プロキシは、要求されたリソースのプロキシに適用プロキシ認証ヘッダフィールド値を持つ407（プロキシ認証が必要）メッセージを移入する必要があります。"
    },
    {
      "indent": 3,
      "text": "The use of Proxy-Authenticate and Proxy-Authorization parallel that described in [17], with one difference. Proxies MUST NOT add values to the Proxy-Authorization header field. All 407 (Proxy Authentication Required) responses MUST be forwarded upstream toward the UAC following the procedures for any other response. It is the UAC's responsibility to add the Proxy-Authorization header field value containing credentials for the realm of the proxy that has asked for authentication.",
      "ja": "一つの違いで、[17]に記載のプロキシ認証およびプロキシ認証平行の使用。プロキシは、Proxy-Authorizationヘッダフィールドに値を追加してはなりません。全407（プロキシ認証が必要）応答は、他の応答のための手順に従って、UACに向けてアップストリームに転送されなければなりません。認証のために依頼したプロキシの分野の資格情報を含むProxy-Authorizationヘッダフィールド値を追加するにはUACの責任です。"
    },
    {
      "indent": 6,
      "text": "If a proxy were to resubmit a request adding a Proxy-Authorization header field value, it would need to increment the CSeq in the new request. However, this would cause the UAC that submitted the original request to discard a response from the UAS, as the CSeq value would be different.",
      "ja": "プロキシがProxy-Authorizationヘッダフィールドの値を加算し、要求を再送信した場合、それは新しい要求でのCSeqをインクリメントする必要があります。しかし、これはのCSeq値が異なるだろうとして、UASからの応答を破棄し、元の要求を提出したUACを引き起こします。"
    },
    {
      "indent": 3,
      "text": "When the originating UAC receives the 407 (Proxy Authentication Required) it SHOULD, if it is able, re-originate the request with the proper credentials. It should follow the same procedures for the display of the \"realm\" parameter that are given above for responding to 401.",
      "ja": "元のUACが407（プロキシ認証が必要）を受信すると、それができる場合には、適切な資格情報を使用して、要求を再発信すべきです。これは、401に応答するための、上記に記載されている「レルム」パラメータの表示のために同じ手順に従うべきです。"
    },
    {
      "indent": 3,
      "text": "If no credentials for a realm can be located, UACs MAY attempt to retry the request with a username of \"anonymous\" and no password (a password of \"\").",
      "ja": "レルムの資格情報が配置できない場合は、求めるUACは「匿名」のユーザー名とパスワードなし（「」のパスワード）でリクエストを再試行してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "The UAC SHOULD also cache the credentials used in the re-originated request.",
      "ja": "UACはまた、再発信要求で使用される資格情報をキャッシュします。"
    },
    {
      "indent": 3,
      "text": "The following rule is RECOMMENDED for proxy credential caching:",
      "ja": "以下のルールは、プロキシ資格情報のキャッシュのために推奨されます。"
    },
    {
      "indent": 3,
      "text": "If a UA receives a Proxy-Authenticate header field value in a 401/407 response to a request with a particular Call-ID, it should incorporate credentials for that realm in all subsequent requests that contain the same Call-ID. These credentials MUST NOT be cached across dialogs; however, if a UA is configured with the realm of its local outbound proxy, when one exists, then the UA MAY cache credentials for that realm across dialogs. Note that this does mean a future request in a dialog could contain credentials that are not needed by any proxy along the Route header path.",
      "ja": "UAは、特定のCall-IDを持つリクエストに401/407応答してプロキシ認証ヘッダフィールド値を受信した場合、それは同じCall-IDを含むすべての後続の要求でそのレルムの資格情報を組み込むべきです。これらの資格情報は、ダイアログ全体でキャッシュされてはなりません。 UAは、それが存在するそのローカルアウトバウンドプロキシの領域で構成されている場合しかし、その後、UAは、ダイアログ全体でそのレルムの資格情報をキャッシュすることができます。このダイアログでは、将来のリクエストがRouteヘッダーのパスに沿った任意のプロキシで必要とされていない資格情報が含まれている可能性を意味しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Any UA that wishes to authenticate itself to a proxy server -- usually, but not necessarily, after receiving a 407 (Proxy Authentication Required) response -- MAY do so by including a Proxy-Authorization header field value with the request. The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy that requires authentication. The Proxy-Authorization header field value consists of credentials containing the authentication information of the UA for the proxy and/or realm of the resource being requested.",
      "ja": "通常、必ずしもそうではないが、407（プロキシ認証が必要）応答を受信した後に -   - プロキシサーバに対して自身を認証することを望む任意のUAは、要求にプロキシ認証ヘッダフィールド値を含めることによってそれを行うことができます。プロキシ認証リクエストヘッダフィールドは、クライアントが認証を必要とするプロキシにそれ自体（又はそのユーザ）を識別することを可能にします。 Proxy-Authorizationヘッダフィールドの値は、プロキシおよび/または要求されたリソースのレルムのUAの認証情報を含む資格情報から成ります。"
    },
    {
      "indent": 3,
      "text": "A Proxy-Authorization header field value applies only to the proxy whose realm is identified in the \"realm\" parameter (this proxy may previously have demanded authentication using the Proxy-Authenticate field). When multiple proxies are used in a chain, a Proxy-Authorization header field value MUST NOT be consumed by any proxy whose realm does not match the \"realm\" parameter specified in that value.",
      "ja": "Proxy-Authorizationヘッダフィールド値は、そのレルム「レルム」パラメータ（このプロキシは、以前にプロキシ認証フィールドを使用して認証を要求していることができる）で識別されたプロキシに適用されます。複数のプロキシをチェーンで使用される場合、Proxy-Authorizationヘッダフィールド値は、その領域その値で指定された「レルム」パラメータと一致しない、プロキシによって消費されてはいけません。"
    },
    {
      "indent": 3,
      "text": "Note that if an authentication scheme that does not support realms is used in the Proxy-Authorization header field, a proxy server MUST attempt to parse all Proxy-Authorization header field values to determine whether one of them has what the proxy server considers to be valid credentials. Because this is potentially very time-consuming in large networks, proxy servers SHOULD use an authentication scheme that supports realms in the Proxy-Authorization header field.",
      "ja": "レルムをサポートしていない認証方式は、Proxy-Authorizationヘッダフィールドで使用されている場合、プロキシサーバは、そのうちの一つは、プロキシサーバが有効であると考えるものがあるかどうかを判断するために、すべてのProxy-Authorizationヘッダフィールドの値を解析しようとしなければならないことに注意してください資格情報。これは潜在的に非常に時間のかかる大規模なネットワークであるため、プロキシサーバは、Proxy-Authorizationヘッダフィールドでレルムをサポートしている認証方式を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "If a request is forked (as described in Section 16.7), various proxy servers and/or UAs may wish to challenge the UAC. In this case, the forking proxy server is responsible for aggregating these challenges into a single response. Each WWW-Authenticate and Proxy-Authenticate value received in responses to the forked request MUST be placed into the single response that is sent by the forking proxy to the UA; the ordering of these header field values is not significant.",
      "ja": "（16.7項で説明したように）要求がフォークされた場合、様々なプロキシサーバおよび/またはUAはUACに挑戦することを望むかもしれません。この場合、フォークプロキシサーバは、単一の応答にこれらの課題を集約する責任があります。二股要求に対する応答で受信された各WWW認証およびプロキシ認証値は、UAにフォーキングプロキシによって送信される単一の応答に入れなければなりません。これらのヘッダーフィールド値の順序は重要ではありません。"
    },
    {
      "indent": 6,
      "text": "When a proxy server issues a challenge in response to a request, it will not proxy the request until the UAC has retried the request with valid credentials. A forking proxy may forward a request simultaneously to multiple proxy servers that require authentication, each of which in turn will not forward the request until the originating UAC has authenticated itself in their respective realm. If the UAC does not provide credentials for each challenge, the proxy servers that issued the challenges will not forward requests to the UA where the destination user might be located, and therefore, the virtues of forking are largely lost.",
      "ja": "プロキシサーバが要求に応答してチャレンジを発行するとUACが有効な資格情報を使用して、要求を再試行するまで、それはプロキシ要求をしません。フォークプロキシは今度はUACがそれぞれの分野で自分自身を認証した発信元まで要求を転送しませんそれぞれの認証を必要とする複数のプロキシサーバーに同時に要求を転送することができます。 UACは、挑戦宛先ユーザが存在する可能性があり、したがって、フォークの美徳が大きく失われたUAのではないでしょう前方の要求を発行したプロキシサーバを各チャレンジの資格情報を提供していない場合。"
    },
    {
      "indent": 3,
      "text": "When resubmitting its request in response to a 401 (Unauthorized) or 407 (Proxy Authentication Required) that contains multiple challenges, a UAC MAY include an Authorization value for each WWW-Authenticate value and a Proxy-Authorization value for each Proxy-Authenticate value for which the UAC wishes to supply a credential. As noted above, multiple credentials in a request SHOULD be differentiated by the \"realm\" parameter.",
      "ja": "複数の課題が含まれている401（不正な）または407（プロキシ認証が必要）に応答してその要求を再送信するとき、UACは、各WWW認証値の許可値と各プロキシ認証値のプロキシ認証値を含むかもしれこれはUACが資格情報を提供することを望みます。上述したように、要求内の複数の資格情報は、「レルム」パラメータによって区別されるべきです。"
    },
    {
      "indent": 3,
      "text": "It is possible for multiple challenges associated with the same realm to appear in the same 401 (Unauthorized) or 407 (Proxy Authentication Required). This can occur, for example, when multiple proxies within the same administrative domain, which use a common realm, are reached by a forking request. When it retries a request, a UAC MAY therefore supply multiple credentials in Authorization or Proxy-Authorization header fields with the same \"realm\" parameter value. The same credentials SHOULD be used for the same realm.",
      "ja": "同じレルムに関連付けられた複数の課題は同じ401（Unauthorized）または407（Proxy Authentication Required）に現れることが可能です。これは一般的なレルムを使用して同じ管理ドメイン内の複数のプロキシは、フォーク要求が到達した場合には、例えば、発生する可能性があります。それはリクエストを再試行する場合、UACは、したがって、同じ「レルム」パラメータ値と許可またはプロキシ認証ヘッダフィールド内の複数の資格情報を供給することができます。同じ資格情報が同じレルムには、使用されてください。"
    },
    {
      "indent": 0,
      "text": "22.4 The Digest Authentication Scheme",
      "section_title": true,
      "ja": "22.4ダイジェスト認証スキーム"
    },
    {
      "indent": 3,
      "text": "This section describes the modifications and clarifications required to apply the HTTP Digest authentication scheme to SIP. The SIP scheme usage is almost completely identical to that for HTTP [17].",
      "ja": "このセクションでは、SIPにHTTPダイジェスト認証方式を適用するために必要な修正および明確化を記載しています。 SIPスキームの使用は、HTTP [17]の場合とほぼ完全に同一です。"
    },
    {
      "indent": 3,
      "text": "Since RFC 2543 is based on HTTP Digest as defined in RFC 2069 [39], SIP servers supporting RFC 2617 MUST ensure they are backwards compatible with RFC 2069. Procedures for this backwards compatibility are specified in RFC 2617. Note, however, that SIP servers MUST NOT accept or request Basic authentication.",
      "ja": "RFC 2069で定義されているRFC 2543はHTTPダイジェストに基づいているので[39]、RFC 2617をサポートするSIPサーバーは、それらが、しかし、そのSIPサーバこの下位互換性のために2069の手順は、RFC 2617（注）で指定されているRFCとの下位互換性を保証しなければなりません受け入れるか、または基本認証を要求してはなりません。"
    },
    {
      "indent": 3,
      "text": "The rules for Digest authentication follow those defined in [17], with \"HTTP/1.1\" replaced by \"SIP/2.0\" in addition to the following differences:",
      "ja": "ダイジェスト認証のためのルールは、次の相違点に加えて、「SIP / 2.0」に置き換え、「HTTP / 1.1」と、[17]で定義されたものに従います。"
    },
    {
      "indent": 6,
      "text": "1. The URI included in the challenge has the following BNF:",
      "section_title": true,
      "ja": "1. URIは、チャレンジに含まれ、次のBNFがあります。"
    },
    {
      "indent": 10,
      "text": "URI = SIP-URI / SIPS-URI",
      "ja": "URI = SIP URIは/ URIをSIPS"
    },
    {
      "indent": 6,
      "text": "2. The BNF in RFC 2617 has an error in that the 'uri' parameter of the Authorization header field for HTTP Digest authentication is not enclosed in quotation marks. (The example in Section 3.5 of RFC 2617 is correct.) For SIP, the 'uri' MUST be enclosed in quotation marks.",
      "ja": "HTTPダイジェスト認証のためのAuthorizationヘッダフィールドの「URI」パラメータは引用符で囲まれていないという点で、2 RFC 2617におけるBNFは、エラーを有します。 （RFC 2617のセクション3.5の例が正しい。）SIPについては、「URI」は引用符で囲まれなければなりません。"
    },
    {
      "indent": 6,
      "text": "3. The BNF for digest-uri-value is:",
      "section_title": true,
      "ja": "3.ダイジェスト-uriの値のためのBNFは、次のとおりです。"
    },
    {
      "indent": 10,
      "text": "digest-uri-value = Request-URI ; as defined in Section 25",
      "ja": "ダイジェスト-uriの値=のRequest-URI;第25条で定義されています"
    },
    {
      "indent": 6,
      "text": "4. The example procedure for choosing a nonce based on Etag does not work for SIP.",
      "ja": "4.たEtagに基づいてnonceを選択するための手順例では、SIPのために動作しません。"
    },
    {
      "indent": 6,
      "text": "5. The text in RFC 2617 [17] regarding cache operation does not apply to SIP.",
      "ja": "5.キャッシュ操作に関するRFC 2617 [17]内のテキストは、SIPには適用されません。"
    },
    {
      "indent": 6,
      "text": "6. RFC 2617 [17] requires that a server check that the URI in the request line and the URI included in the Authorization header field point to the same resource. In a SIP context, these two URIs may refer to different users, due to forwarding at some proxy. Therefore, in SIP, a server MAY check that the Request-URI in the Authorization header field value corresponds to a user for whom the server is willing to accept forwarded or direct requests, but it is not necessarily a failure if the two fields are not equivalent.",
      "ja": "6. RFC 2617 [17]そのサーバチェックを必要とするリクエストラインでURIとURIが同じリソースにAuthorizationヘッダフィールドポイントに含まれます。 SIPのコンテキストでは、これら2つのURIは、何らかのプロキシに転送するには、別のユーザを指してもよいです。したがって、SIPで、サーバは、Authorizationヘッダフィールド値のRequest-URIは、サーバが転送または直接要求を受け入れる意志がある人のためにユーザに対応することを確認することができるが、それは2つのフィールドがない場合は、必ずしも不良ではありません同等。"
    },
    {
      "indent": 6,
      "text": "7. As a clarification to the calculation of the A2 value for message integrity assurance in the Digest authentication scheme, implementers should assume, when the entity-body is empty (that is, when SIP messages have no body) that the hash of the entity-body resolves to the MD5 hash of an empty string, or:",
      "ja": "ダイジェスト認証方式におけるメッセージ完全性保証のためのA2値の算出に明確エンティティボディは、（SIPメッセージが全く体を持っていない場合には、である）が空である場合、実装者は、想定すべきである7.エンティティのハッシュ-body空の文字列、またはのMD5ハッシュを解決します。"
    },
    {
      "indent": 10,
      "text": "   H(entity-body) = MD5(\"\") =\n\"d41d8cd98f00b204e9800998ecf8427e\"",
      "raw": true
    },
    {
      "indent": 6,
      "text": "8. RFC 2617 notes that a cnonce value MUST NOT be sent in an Authorization (and by extension Proxy-Authorization) header field if no qop directive has been sent. Therefore, any algorithms that have a dependency on the cnonce (including \"MD5-Sess\") require that the qop directive be sent. Use of the \"qop\" parameter is optional in RFC 2617 for the purposes of backwards compatibility with RFC 2069; since RFC 2543 was based on RFC 2069, the \"qop\" parameter must unfortunately remain optional for clients and servers to receive. However, servers MUST always send a \"qop\" parameter in WWW-Authenticate and Proxy-Authenticate header field values. If a client receives a \"qop\" parameter in a challenge header field, it MUST send the \"qop\" parameter in any resulting authorization header field.",
      "ja": "cnonce値が許可で送信（及び拡張プロキシ認証による）してはならないこと8. RFC 2617ノートヘッダフィールドないQOP指令が送信されていない場合。したがって、（「MD5-セ​​ッション数」を含む）cnonce依存性を有する任意のアルゴリズムはQOP指令が送信されることを必要とします。 「QOP」パラメータを使用すると、RFC 2069との後方互換性のためにRFC 2617でオプションです。 RFC 2543は、RFC 2069に基づいていたことから、「QOP」パラメータは、残念ながら受信するクライアントとサーバのためのオプションのままにしなければなりません。ただし、サーバは常にWWW認証およびProxy-Authenticateヘッダフィールドの値に「QOP」パラメータを送らなければなりません。クライアントがチャレンジヘッダフィールドに「QOP」パラメータを受信した場合、それがどんな結果、認可ヘッダフィールドに「QOP」パラメータを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "RFC 2543 did not allow usage of the Authentication-Info header field (it effectively used RFC 2069). However, we now allow usage of this header field, since it provides integrity checks over the bodies and provides mutual authentication. RFC 2617 [17] defines mechanisms for backwards compatibility using the qop attribute in the request. These mechanisms MUST be used by a server to determine if the client supports the new mechanisms in RFC 2617 that were not specified in RFC 2069.",
      "ja": "RFC 2543は、（それが効果的にRFC 2069を使用）認証-Infoヘッダフィールドの使用を許可しませんでした。それは体の上に整合性チェックを提供し、相互認証を提供するので、しかし、我々は今、このヘッダフィールドの使用を許可します。 RFC 2617 [17]要求にQOP属性を使用して、下位互換性のためのメカニズムを定義します。これらのメカニズムは、クライアントがRFC 2069で指定されていないRFC 2617で新しいメカニズムをサポートしているかどうかを判断するために、サーバによって使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "23 S/MIME",
      "ja": "23のS / MIME"
    },
    {
      "indent": 3,
      "text": "SIP messages carry MIME bodies and the MIME standard includes mechanisms for securing MIME contents to ensure both integrity and confidentiality (including the 'multipart/signed' and 'application/pkcs7-mime' MIME types, see RFC 1847 [22], RFC 2630 [23] and RFC 2633 [24]). Implementers should note, however, that there may be rare network intermediaries (not typical proxy servers) that rely on viewing or modifying the bodies of SIP messages (especially SDP), and that secure MIME may prevent these sorts of intermediaries from functioning.",
      "ja": "SIPメッセージは、MIMEボディを運び、MIME標準は、[RFC 1847 [22]を参照して、「マルチパート/署名された」と「アプリケーション/ PKCS7-MIME」のMIMEタイプを含む（完全性と機密性の両方を確実にするためにMIMEコンテンツを確保するための機構、RFC 2630を含みます23]及びRFC 2633 [24]）。実装者は珍しいネットワーク仲介表示またはSIPメッセージ（特にSDP）の遺体を修正することに依存している（いない典型的なプロキシサーバ）が存在する可能性があること、しかし、注意しなければならない、とその安全なMIMEが機能から仲介のこれらの種類を防ぐことができます。"
    },
    {
      "indent": 6,
      "text": "This applies particularly to certain types of firewalls.",
      "ja": "これは、ファイアウォールの特定の種類に特に当てはまります。"
    },
    {
      "indent": 6,
      "text": "The PGP mechanism for encrypting the header fields and bodies of SIP messages described in RFC 2543 has been deprecated.",
      "ja": "RFC 2543に記載されたSIPメッセージのヘッダフィールドとボディを暗号化するためのPGP機構が廃止されました。"
    },
    {
      "indent": 0,
      "text": "23.1 S/MIME Certificates",
      "section_title": true,
      "ja": "23.1 S / MIME証明書"
    },
    {
      "indent": 3,
      "text": "The certificates that are used to identify an end-user for the purposes of S/MIME differ from those used by servers in one important respect - rather than asserting that the identity of the holder corresponds to a particular hostname, these certificates assert that the holder is identified by an end-user address. This address is composed of the concatenation of the \"userinfo\" \"@\" and \"domainname\" portions of a SIP or SIPS URI (in other words, an email address of the form \"bob@biloxi.com\"), most commonly corresponding to a user's address-of-record.",
      "ja": "むしろホルダの身元が特定のホスト名に対応することを主張するよりも、これらの証明書は、所有者が主張 -  S / MIMEの目的のために、エンドユーザを識別するために使用される証明書は、一つの重要な点でサーバによって使用されるものとは異なりますエンドユーザーのアドレスによって識別されます。このアドレスは「@」と「ドメイン名」SIPの部分又は（換言すれば、フォームのメールアドレスURIをSIPS「bob@biloxi.com」）を「ユーザー情報」の連結で構成されている、最も一般的に対応しますユーザーのアドレスのレコード。"
    },
    {
      "indent": 3,
      "text": "These certificates are also associated with keys that are used to sign or encrypt bodies of SIP messages. Bodies are signed with the private key of the sender (who may include their public key with the message as appropriate), but bodies are encrypted with the public key of the intended recipient. Obviously, senders must have foreknowledge of the public key of recipients in order to encrypt message bodies. Public keys can be stored within a UA on a virtual keyring.",
      "ja": "これらの証明書は、署名またはSIPメッセージの本文を暗号化するために使用されるキーに関連付けられています。ボディは、（適切なメッセージとその公開鍵を含んでいてもよい）、送信者の秘密鍵で署名されているが、体が意図された受信者の公開鍵で暗号化されています。明らかに、送信者は、メッセージ本文を暗号化するために、受信者の公開鍵の予備知識を持っている必要があります。公開鍵は、仮想キーリングにUA内に格納することができます。"
    },
    {
      "indent": 3,
      "text": "Each user agent that supports S/MIME MUST contain a keyring specifically for end-users' certificates. This keyring should map between addresses of record and corresponding certificates. Over time, users SHOULD use the same certificate when they populate the originating URI of signaling (the From header field) with the same address-of-record.",
      "ja": "S / MIMEは、特にエンドユーザーの証明書のキーリングを含まなければならないサポートする各ユーザーエージェント。このキーリングは、レコードのアドレスと対応する証明書の間でマップする必要があります。彼らは同じアドレス・オブ・レコードに（Fromヘッダーフィールド）シグナリングの発信元のURIを移入する場合、時間が経つにつれて、ユーザーが同じ証明書を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Any mechanisms depending on the existence of end-user certificates are seriously limited in that there is virtually no consolidated authority today that provides certificates for end-user applications. However, users SHOULD acquire certificates from known public certificate authorities. As an alternative, users MAY create self-signed certificates. The implications of self-signed certificates are explored further in Section 26.4.2. Implementations may also use pre-configured certificates in deployments in which a previous trust relationship exists between all SIP entities.",
      "ja": "エンドユーザ証明書の有無に応じて、任意のメカニズムは真剣にエンドユーザアプリケーションのための証明書を提供し、今日はほとんどない連結権限があることで制限されています。ただし、ユーザーが知られている公共の証明機関から証明書を取得する必要があります。別の方法として、ユーザは、自己署名証明書を作成することができます。自己署名証明書の意味合いは、セクション26.4.2でさらに探求されています。また、実装は、以前の信頼関係は、すべてのSIPエンティティ間に存在する展開に予め設定された証明書を使用することができます。"
    },
    {
      "indent": 3,
      "text": "Above and beyond the problem of acquiring an end-user certificate, there are few well-known centralized directories that distribute end-user certificates. However, the holder of a certificate SHOULD publish their certificate in any public directories as appropriate. Similarly, UACs SHOULD support a mechanism for importing (manually or automatically) certificates discovered in public directories corresponding to the target URIs of SIP requests.",
      "ja": "上に、エンドユーザ証明書を取得する問題を超えて、エンドユーザーの証明書を配布するいくつかのよく知られた中央集中型のディレクトリがあります。ただし、証明書の所有者は、必要に応じて任意の公開ディレクトリにその証明書を発行すべきです。同様に、求めるUACは（手動または自動で）SIPリクエストのターゲットURIに対応する公開ディレクトリに発見された証明書をインポートするためのメカニズムをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "23.2 S/MIME Key Exchange",
      "section_title": true,
      "ja": "23.2 S / MIME鍵交換"
    },
    {
      "indent": 3,
      "text": "SIP itself can also be used as a means to distribute public keys in the following manner.",
      "ja": "SIP自体は、以下のように公開鍵を配布する手段としても使用することができます。"
    },
    {
      "indent": 3,
      "text": "Whenever the CMS SignedData message is used in S/MIME for SIP, it MUST contain the certificate bearing the public key necessary to verify the signature.",
      "ja": "CMSのSignedDataメッセージがSIPのためのS / MIMEで使用されるときはいつでも、それは署名を検証するために必要な公開鍵を保有する証明書を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a UAC sends a request containing an S/MIME body that initiates a dialog, or sends a non-INVITE request outside the context of a dialog, the UAC SHOULD structure the body as an S/MIME 'multipart/signed' CMS SignedData body. If the desired CMS service is EnvelopedData (and the public key of the target user is known), the UAC SHOULD send the EnvelopedData message encapsulated within a SignedData message.",
      "ja": "UACがダイアログを開始するか、またはダイアログのコンテキスト外で非INVITE要求を送信するS / MIMEボディを含む要求を送信すると、UACは、S / MIME「マルチパート/署名された」CMSのSignedData体としての本体を構成すべきです。所望のCMSサービスがEnvelopedDataの（及び対象ユーザの公開鍵が知られている）である場合、UACはSignedDataのメッセージ内にカプセル化EnvelopedDataのメッセージを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "When a UAS receives a request containing an S/MIME CMS body that includes a certificate, the UAS SHOULD first validate the certificate, if possible, with any available root certificates for certificate authorities. The UAS SHOULD also determine the subject of the certificate (for S/MIME, the SubjectAltName will contain the appropriate identity) and compare this value to the From header field of the request. If the certificate cannot be verified, because it is self-signed, or signed by no known authority, or if it is verifiable but its subject does not correspond to the From header field of request, the UAS MUST notify its user of the status of the certificate (including the subject of the certificate, its signer, and any key fingerprint information) and request explicit permission before proceeding. If the certificate was successfully verified and the subject of the certificate corresponds to the From header field of the SIP request, or if the user (after notification) explicitly authorizes the use of the certificate, the UAS SHOULD add this certificate to a local keyring, indexed by the address-of-record of the holder of the certificate.",
      "ja": "UASは、証明書を含むS / MIME CMSボディを含む要求を受信すると、可能な場合、UASは最初の証明機関のための任意の利用可能なルート証明書と、証明書を検証する必要があります。 UASはまた、証明書のサブジェクトを決定する（S / MIMEのためのSubjectAltNameが適切なアイデンティティを含むであろう）、要求のヘッダフィールドからこの値を比較する必要があります。証明書は自己署名されているため、検証、または全く知られている機関によって署名された、またはそれが検証可能であるが、その対象がリクエストのFromヘッダフィールドに対応しない場合、UASは、ステータスのそのユーザに通知しなければならないことができない場合（証明書のサブジェクトを含め、その署名者、および任意のキー指紋情報）証明書と先に進む前に、明示的な許可を要求します。証明書がうまく検証し、証明書の対象がSIPリクエストのFromヘッダフィールドに対応し、又は（通知後に）ユーザが明示的に証明書の使用を許可する場合、UASは、ローカル鍵リングにこの証明書を追加する必要がある場合、証明書の所有者のアドレス・オブ・レコードによってインデックスさ。"
    },
    {
      "indent": 3,
      "text": "When a UAS sends a response containing an S/MIME body that answers the first request in a dialog, or a response to a non-INVITE request outside the context of a dialog, the UAS SHOULD structure the body as an S/MIME 'multipart/signed' CMS SignedData body. If the desired CMS service is EnvelopedData, the UAS SHOULD send the EnvelopedData message encapsulated within a SignedData message.",
      "ja": "UASは、ダイアログの最初の要求に応答するS / MIMEボディ、またはダイアログのコンテキスト外で非INVITE要求に対する応答を含む応答を送信すると、UASは、S / MIME「マルチパートとして体を構成すべきです/」CMSのSignedDataボディ署名しました。希望CMSサービスがEnvelopedDataのであれば、UASはSignedDataのメッセージの中にカプセル化されたEnvelopedDataメッセージを送るべきです。"
    },
    {
      "indent": 3,
      "text": "When a UAC receives a response containing an S/MIME CMS body that includes a certificate, the UAC SHOULD first validate the certificate, if possible, with any appropriate root certificate. The UAC SHOULD also determine the subject of the certificate and compare this value to the To field of the response; although the two may very well be different, and this is not necessarily indicative of a security breach. If the certificate cannot be verified because it is self-signed, or signed by no known authority, the UAC MUST notify its user of the status of the certificate (including the subject of the certificate, its signator, and any key fingerprint information) and request explicit permission before proceeding. If the certificate was successfully verified, and the subject of the certificate corresponds to the To header field in the response, or if the user (after notification) explicitly authorizes the use of the certificate, the UAC SHOULD add this certificate to a local keyring, indexed by the address-of-record of the holder of the certificate. If the UAC had not transmitted its own certificate to the UAS in any previous transaction, it SHOULD use a CMS SignedData body for its next request or response.",
      "ja": "UACが証明書を含むS / MIME CMSボディを含む応答を受信すると、可能な場合、UACは、まず、任意の適切なルート証明書と、証明書を検証する必要があります。 UACは、証明書のサブジェクトを決定し、応答の分野に、この値を比較する必要があります。二人は非常によく、異なっていてもよく、これは必ずしもセキュリティ違反を示すものではありません。が、それは自己署名、または全く既知の機関によって署名されているため、証明書を検証できない場合、UACは、（証明書のサブジェクト、その署名者、及び任意の鍵の指紋情報を含む）証明書のステータスのそのユーザに通知しなければなりません先に進む前に、明示的な許可を要求します。証明書が正常に検証された、および証明書のサブジェクトが応答のフィールドをToヘッダーに対応する、または（通知後に）ユーザが明示的に証明書の使用を許可した場合、UACがローカル鍵リングにこの証明書を追加する必要がある場合、証明書の所有者のアドレス・オブ・レコードによってインデックスさ。 UACは以前のトランザクションでUASに独自の証明書を送信していなかった場合、それはその次の要求や応答のためのCMSのSignedDataボディを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "On future occasions, when the UA receives requests or responses that contain a From header field corresponding to a value in its keyring, the UA SHOULD compare the certificate offered in these messages with the existing certificate in its keyring. If there is a discrepancy, the UA MUST notify its user of a change of the certificate (preferably in terms that indicate that this is a potential security breach) and acquire the user's permission before continuing to process the signaling. If the user authorizes this certificate, it SHOULD be added to the keyring alongside any previous value(s) for this address-of-record.",
      "ja": "UAは、そのキーリングの値に対応するFromヘッダーフィールドを含む要求や応答を受信した際、将来の機会に、UAは、そのキーリング内の既存の証明書を使用して、これらのメッセージで提供される証明書を比較する必要があります。矛盾がある場合、UAは、（好ましくは、これは潜在的なセキュリティの侵害であることを示す用語で）証明書の変更をそのユーザに通知し、シグナリングを処理するために、続行する前にユーザーの許可を取得する必要があります。ユーザーはこの証明書を承認する場合は、このアドレス・オブ・レコードの任意の以前の値（複数可）と一緒にキーリングに追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note well however, that this key exchange mechanism does not guarantee the secure exchange of keys when self-signed certificates, or certificates signed by an obscure authority, are used - it is vulnerable to well-known attacks. In the opinion of the authors, however, the security it provides is proverbially better than nothing; it is in fact comparable to the widely used SSH application. These limitations are explored in greater detail in Section 26.4.2.",
      "ja": "無名の機関によって署名された自己署名証明書、または証明書が、使用されているときにこのキー交換メカニズムは、鍵の安全な交換を保証するものではないこと、しかし、よく注意してください - それは、よく知られた攻撃に対して脆弱です。著者の意見では、しかし、それが提供するセキュリティが何よりもproverbially優れています。それは実際に広く使われているSSHアプリケーションに匹敵します。これらの制限は、セクション26.4.2でより詳細に調査しています。"
    },
    {
      "indent": 3,
      "text": "If a UA receives an S/MIME body that has been encrypted with a public key unknown to the recipient, it MUST reject the request with a 493 (Undecipherable) response. This response SHOULD contain a valid certificate for the respondent (corresponding, if possible, to any address of record given in the To header field of the rejected request) within a MIME body with a 'certs-only' \"smime-type\" parameter.",
      "ja": "UAが受信者に公開鍵不明で暗号化されたS / MIMEボディを受信した場合、それは493（解読不能）応答で要求を拒絶しなければなりません。この応答は「本命のみ」「SMIME型」パラメータを使用してMIME本体内（拒否要求のフィールドをヘッダーに指定されたレコードの任意のアドレスに、可能な場合、該当）回答者のための有効な証明書が含まれているべきです。"
    },
    {
      "indent": 3,
      "text": "A 493 (Undecipherable) sent without any certificate indicates that the respondent cannot or will not utilize S/MIME encrypted messages, though they may still support S/MIME signatures.",
      "ja": "すべての証明書なしで送信された493（解読不能）は回答ができないか、彼らはまだS / MIME署名をサポートするかもしれませんが、S / MIME暗号化されたメッセージを利用しないことを示しています。"
    },
    {
      "indent": 3,
      "text": "Note that a user agent that receives a request containing an S/MIME body that is not optional (with a Content-Disposition header \"handling\" parameter of \"required\") MUST reject the request with a 415 Unsupported Media Type response if the MIME type is not understood. A user agent that receives such a response when S/MIME is sent SHOULD notify its user that the remote device does not support S/MIME, and it MAY subsequently resend the request without S/MIME, if appropriate; however, this 415 response may constitute a downgrade attack.",
      "ja": "（「必須」のコンテンツの廃棄ヘッダー「ハンドリング」パラメータを使用して）オプションではありませんS / MIMEボディを含むリクエストを受信するユーザエージェントは、MIMEタイプの場合は415サポートされないメディアタイプ応答で要求を拒絶しなければならないことに注意してください理解されていません。 S / MIMEが送信され、このような応答は、リモートデバイスがS / MIMEをサポートしていないことをそのユーザに通知する必要があり、適切な場合には、その後、S / MIMEなしで要求を再送するかもしれ受信ユーザエージェント。しかし、この415応答はダウングレード攻撃を構成することができます。"
    },
    {
      "indent": 3,
      "text": "If a user agent sends an S/MIME body in a request, but receives a response that contains a MIME body that is not secured, the UAC SHOULD notify its user that the session could not be secured. However, if a user agent that supports S/MIME receives a request with an unsecured body, it SHOULD NOT respond with a secured body, but if it expects S/MIME from the sender (for example, because the sender's From header field value corresponds to an identity on its keychain), the UAS SHOULD notify its user that the session could not be secured.",
      "ja": "ユーザエージェントはリクエストにS / MIMEボディを送信しますが、確保されていないMIMEボディを含む応答を受信した場合、UACはセッションを確保することができませんでした、そのユーザーに通知する必要があります。しかし、S / MIMEをサポートしているユーザエージェントが無担保ボディとリクエストを受信した場合、それは安全なボディに応じるべきではありませんが、それは、例えば（送信者からのS / MIMEを期待している場合ので、ヘッダフィールドの値が対応するから、送信者そのキーチェーン上のアイデンティティー）に、UASはセッションを確保することができませんでした、そのユーザーに通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "A number of conditions that arise in the previous text call for the notification of the user when an anomalous certificate-management event occurs. Users might well ask what they should do under these circumstances. First and foremost, an unexpected change in a certificate, or an absence of security when security is expected, are causes for caution but not necessarily indications that an attack is in progress. Users might abort any connection attempt or refuse a connection request they have received; in telephony parlance, they could hang up and call back. Users may wish to find an alternate means to contact the other party and confirm that their key has legitimately changed. Note that users are sometimes compelled to change their certificates, for example when they suspect that the secrecy of their private key has been compromised. When their private key is no longer private, users must legitimately generate a new key and re-establish trust with any users that held their old key.",
      "ja": "異常証明書管理イベントが発生したときに、ユーザの通知のための前のテキストコールで生じる条件の数。ユーザーはよく、彼らがこのような状況の下で何をすべきかを尋ねるかもしれません。まず第一に、証明書の予想外の変更、またはセキュリティが期待されているセキュリティの欠如は、注意の原因必ずしも必要ではないが、攻撃が進行している兆候があります。ユーザーが任意の接続試行を中止するか、彼らが受け取った接続要求を拒否するかもしれません。テレフォニー用語で、彼らがハングアップして戻って呼び出すことができます。ユーザーは、相手に連絡し、その鍵が合法的に変更されたことを確認するための代替手段を見つけることもできます。彼らは自分の秘密鍵の秘密が侵害されたと思われるときに、ユーザーが時々、たとえば、その証明書の変更を余儀なくされていることに注意してください。自分の秘密鍵はもはやプライベートではない場合には、ユーザーが合法的に新しいキーを生成する必要があり、その古い鍵を保持しているすべてのユーザーとの信頼関係を再確立します。"
    },
    {
      "indent": 3,
      "text": "Finally, if during the course of a dialog a UA receives a certificate in a CMS SignedData message that does not correspond with the certificates previously exchanged during a dialog, the UA MUST notify its user of the change, preferably in terms that indicate that this is a potential security breach.",
      "ja": "ダイアログUAの過程で以前に対話中に交換証明書と一致しないCMSのSignedDataメッセージに証明書を受信した場合、最終的に、UAは、好ましくは、これがあることを示している点で、その変化をユーザに通知しなければなりません潜在的なセキュリティ侵害。"
    },
    {
      "indent": 0,
      "text": "23.3 Securing MIME bodies",
      "section_title": true,
      "ja": "MIMEボディを保護する23.3"
    },
    {
      "indent": 3,
      "text": "There are two types of secure MIME bodies that are of interest to SIP: use of these bodies should follow the S/MIME specification [24] with a few variations.",
      "ja": "SIPに関心のある安全なMIMEボディの2種類があります。これらの機関の使用は、S / MIMEの仕様に従うべきである[24]いくつかのバリエーションで。"
    },
    {
      "indent": 6,
      "text": "o \"multipart/signed\" MUST be used only with CMS detached signatures.",
      "ja": "O「マルチパート/署名された」だけCMS分離署名を使用する必要があります。"
    },
    {
      "indent": 12,
      "text": "This allows backwards compatibility with non-S/MIME-\ncompliant recipients.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "o S/MIME bodies SHOULD have a Content-Disposition header field, and the value of the \"handling\" parameter SHOULD be \"required.\"",
      "ja": "O S / MIMEボディは、Content-Dispositionヘッダーフィールドを持つべきであり、「処理」パラメータの値が「必要」されてください"
    },
    {
      "indent": 6,
      "text": "o If a UAC has no certificate on its keyring associated with the address-of-record to which it wants to send a request, it cannot send an encrypted \"application/pkcs7-mime\" MIME message. UACs MAY send an initial request such as an OPTIONS message with a CMS detached signature in order to solicit the certificate of the remote side (the signature SHOULD be over a \"message/sip\" body of the type described in Section 23.4).",
      "ja": "UACは、アドレスのレコード、それはリクエストを送信したいために関連付けられたそのキーリングには何の証明書を持っていない場合は、O、それは暗号化された「アプリケーション/ PKCS7-MIME」MIMEメッセージを送信することはできません。求めるUACは、リモート側の証明書を要求するために、このようなCMS分離署名を持つOPTIONSメッセージとして初期要求を送信することができる（署名はセクション23.4に記載されているタイプの「メッセージ/ SIP」身体上べきです）。"
    },
    {
      "indent": 12,
      "text": "Note that future standardization work on S/MIME may define\nnon-certificate based keys.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "o Senders of S/MIME bodies SHOULD use the \"SMIMECapabilities\" (see Section 2.5.2 of [24]) attribute to express their capabilities and preferences for further communications. Note especially that senders MAY use the \"preferSignedData\" capability to encourage receivers to respond with CMS SignedData messages (for example, when sending an OPTIONS request as described above).",
      "ja": "O S / MIMEボディの送信者が「SMIMEケーパビリティ」を使用すべきさらなる通信のためにその能力及び好みを表現するために属性（[24]のセクション2.5.2を参照）。送信者は、CMSのSignedDataメッセージで応答する受信機を奨励するために、「preferSignedData」機能を使用することができることに特に注意してください（例えば、前述したようにOPTIONSリクエストを送信する場合）。"
    },
    {
      "indent": 6,
      "text": "o S/MIME implementations MUST at a minimum support SHA1 as a digital signature algorithm, and 3DES as an encryption algorithm. All other signature and encryption algorithms MAY be supported. Implementations can negotiate support for these algorithms with the \"SMIMECapabilities\" attribute.",
      "ja": "O S / MIME実装は、デジタル署名アルゴリズムなどの最小支持SHA1でなければならず、暗号化アルゴリズムとして3DES。他のすべての署名と暗号化アルゴリズムをサポートすることができます。実装は「SMIMEケーパビリティ」属性でこれらのアルゴリズムのサポートを交渉することができます。"
    },
    {
      "indent": 6,
      "text": "o Each S/MIME body in a SIP message SHOULD be signed with only one certificate. If a UA receives a message with multiple signatures, the outermost signature should be treated as the single certificate for this body. Parallel signatures SHOULD NOT be used.",
      "ja": "O SIPメッセージの各S / MIME本体は、ただ1つの証明書で署名されるべきです。 UAは、複数の署名付きメッセージを受信した場合、最も外側の署名は、この本体のための単一の証明書として扱われるべきです。パラレル署名を使用してはいけません。"
    },
    {
      "indent": 9,
      "text": "The following is an example of an encrypted S/MIME SDP body within a SIP message:",
      "ja": "以下は、SIPメッセージ内の暗号化されたS / MIME SDPボディの一例です。"
    },
    {
      "indent": 8,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Max-Forwards: 70 Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/pkcs7-mime; smime-type=enveloped-data; name=smime.p7m Content-Disposition: attachment; filename=smime.p7m handling=required",
      "ja": "ボブ<SIP：bob@biloxi.com>から：アリス<SIP：alice@atlanta.com;：bob@biloxi.com SIP / 2.0経由：ブランチ= z9hG4bKnashds8にSIP / 2.0 / UDP pc33.atlanta.com SIPのINVITE >; = 1928301774のCall-IDタグ：のCSeq a84b4c76e66710：314159は、マックス・フォワードをINVITE：70お問い合わせ：<SIP：alice@pc33.atlanta.com>のContent-Type：アプリケーション/ PKCS7-MIMEを。 SMIME型=エンベロープデータ。名前= smime.p7mというコンテンツディスポジション：添付ファイル;ファイル名= smime.p7mという扱い=必要"
    },
    {
      "indent": 6,
      "text": "******************************************************* * Content-Type: application/sdp * * * * v=0 * * o=alice 53655765 2353687637 IN IP4 pc33.atlanta.com * * s=- * * t=0 0 * * c=IN IP4 pc33.atlanta.com * * m=audio 3456 RTP/AVP 0 1 3 99 * * a=rtpmap:0 PCMU/8000 * *******************************************************",
      "ja": "************************************************** ***** *のContent-Type：アプリケーション/ SDP * * * * V = 0 * * 0 =アリス53655765 2353687637、IN IP4 pc33.atlanta.com * * S =  -  * * T = 0 0 * * C IN = IP4 pc33.atlanta.com * M =オーディオ3456 RTP / AVP 0 1 3 99 * A = rtpmap：0 PCMU / 8000 * ******************** ***********************************"
    },
    {
      "indent": 0,
      "text": "23.4 SIP Header Privacy and Integrity using S/MIME: Tunneling SIP",
      "section_title": true,
      "ja": "トンネリングSIP：S / MIMEを使用して23.4 SIPヘッダープライバシーと整合性"
    },
    {
      "indent": 3,
      "text": "As a means of providing some degree of end-to-end authentication, integrity or confidentiality for SIP header fields, S/MIME can encapsulate entire SIP messages within MIME bodies of type \"message/sip\" and then apply MIME security to these bodies in the same manner as typical SIP bodies. These encapsulated SIP requests and responses do not constitute a separate dialog or transaction, they are a copy of the \"outer\" message that is used to verify integrity or to supply additional information.",
      "ja": "SIPヘッダフィールドのエンドツーエンド認証、完全性や機密性のある程度を提供する手段として、S / MIMEは「メッセージ/ SIP」タイプのMIMEボディ内全体のSIPメッセージをカプセル化することができ、次いで、これらのボディにMIMEセキュリティを適用します典型的なSIP体と同様。これらのカプセル化されたSIP要求と応答が別のダイアログまたはトランザクションを構成するものではありません、彼らは、整合性を確認したり、追加情報を提供するために使用され、「外」のメッセージのコピーです。"
    },
    {
      "indent": 3,
      "text": "If a UAS receives a request that contains a tunneled \"message/sip\" S/MIME body, it SHOULD include a tunneled \"message/sip\" body in the response with the same smime-type.",
      "ja": "UASは、トンネリング「メッセージ/ SIP」S / MIMEボディを含む要求を受信した場合、それは同じSMIME型と反応してトンネリング「メッセージ/ SIP」本体を含むべきです。"
    },
    {
      "indent": 3,
      "text": "Any traditional MIME bodies (such as SDP) SHOULD be attached to the \"inner\" message so that they can also benefit from S/MIME security. Note that \"message/sip\" bodies can be sent as a part of a MIME \"multipart/mixed\" body if any unsecured MIME types should also be transmitted in a request.",
      "ja": "彼らはまた、S / MIMEセキュリティの恩恵を受けることができるように（例えば、SDPのような）任意の従来のMIME本体は「内部」メッセージに添付しなければなりません。任意の保護されていないMIMEタイプは、リクエストで送信されるべきである場合、「メッセージ/ SIP」体がMIME「マルチパート/混合」体の一部として送信することができることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "23.4.1 Integrity and Confidentiality Properties of SIP Headers",
      "section_title": true,
      "ja": "SIPヘッダの23.4.1完全性と機密性のプロパティ"
    },
    {
      "indent": 3,
      "text": "When the S/MIME integrity or confidentiality mechanisms are used, there may be discrepancies between the values in the \"inner\" message and values in the \"outer\" message. The rules for handling any such differences for all of the header fields described in this document are given in this section.",
      "ja": "S / MIMEの完全性や機密性のメカニズムが使用される場合、「外部」メッセージの「内部」メッセージと値の値の間の不一致があってもよいです。この文書に記載されたヘッダフィールドのすべてのためのこのような違いを処理するためのルールは、このセクションに記載されています。"
    },
    {
      "indent": 3,
      "text": "Note that for the purposes of loose timestamping, all SIP messages that tunnel \"message/sip\" SHOULD contain a Date header in both the \"inner\" and \"outer\" headers.",
      "ja": "トンネル「メッセージ/ SIP」が「内側」及び「外側」ヘッダの両方の日付ヘッダを含むべきであるルースタイムスタンプの目的のために、すべてのSIPメッセージのためのことに注意してください。"
    },
    {
      "indent": 0,
      "text": "23.4.1.1 Integrity",
      "section_title": true,
      "ja": "23.4.1.1整合性"
    },
    {
      "indent": 3,
      "text": "Whenever integrity checks are performed, the integrity of a header field should be determined by matching the value of the header field in the signed body with that in the \"outer\" messages using the comparison rules of SIP as described in 20.",
      "ja": "整合性チェックが実行されるたびに、ヘッダフィールドのインテグリティ20に記載のようにSIPの比較ルールを使用して「外側」メッセージでそれに署名された本体のヘッダフィールドの値を照合することによって決定されるべきです。"
    },
    {
      "indent": 3,
      "text": "Header fields that can be legitimately modified by proxy servers are: Request-URI, Via, Record-Route, Route, Max-Forwards, and Proxy-Authorization. If these header fields are not intact end-to-end, implementations SHOULD NOT consider this a breach of security. Changes to any other header fields defined in this document constitute an integrity violation; users MUST be notified of a discrepancy.",
      "ja": "合法的にプロキシサーバによって変更できるヘッダーフィールドは、次のとおりです。要求URI、経由、録音・ルート、ルート、マックス・フォワード、およびプロキシ認証。これらのヘッダーフィールドはそのままエンド・ツー・エンドでない場合、実装は、このセキュリティの違反を検討すべきではありません。この文書で定義された任意の他のヘッダフィールドの変更は、整合性違反を構成しています。ユーザーが不一致を通知しなければなりません。"
    },
    {
      "indent": 0,
      "text": "23.4.1.2 Confidentiality",
      "section_title": true,
      "ja": "23.4.1.2機密性"
    },
    {
      "indent": 3,
      "text": "When messages are encrypted, header fields may be included in the encrypted body that are not present in the \"outer\" message.",
      "ja": "メッセージが暗号化されている場合、ヘッダフィールドは、「外部」メッセージに存在しない暗号化されたボディに含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "Some header fields must always have a plaintext version because they are required header fields in requests and responses - these include:",
      "ja": "彼らは要求と応答で必要なヘッダフィールドであるため、いくつかのヘッダフィールドは、常に平文のバージョンを持っている必要があります - これらは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "To, From, Call-ID, CSeq, Contact. While it is probably not useful to provide an encrypted alternative for the Call-ID, CSeq, or Contact, providing an alternative to the information in the \"outer\" To or From is permitted. Note that the values in an encrypted body are not used for the purposes of identifying transactions or dialogs - they are merely informational. If the From header field in an encrypted body differs from the value in the \"outer\" message, the value within the encrypted body SHOULD be displayed to the user, but MUST NOT be used in the \"outer\" header fields of any future messages.",
      "ja": "へ、コールID、のCSeq、連絡先を。それがToまたはから、「外側」に情報への代替を提供し、コールID、のCSeq、または連絡先のために暗号化された選択肢を提供するために、おそらく有用ではないですが許可されています。暗号化された身体の値は、トランザクションやダイアログを識別する目的のために使用されていないことに注意してください - 彼らは単に情報提供しています。暗号化された体内のFromヘッダフィールドが「外部」メッセージの値と異なる場合に、暗号化された本体内の値がユーザに表示されるべきであるが、任意の将来のメッセージの「外部」ヘッダフィールドに使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Primarily, a user agent will want to encrypt header fields that have an end-to-end semantic, including: Subject, Reply-To, Organization, Accept, Accept-Encoding, Accept-Language, Alert-Info, Error-Info, Authentication-Info, Expires, In-Reply-To, Require, Supported, Unsupported, Retry-After, User-Agent, Server, and Warning. If any of these header fields are present in an encrypted body, they should be used instead of any \"outer\" header fields, whether this entails displaying the header field values to users or setting internal states in the UA. They SHOULD NOT however be used in the \"outer\" headers of any future messages.",
      "ja": "受け入れる言語、アラート情報、エラー、情報、認証、、組織への返信受け入れる、受け入れ-エンコーディングを、件名：主に、ユーザエージェントは、以下を含むエンドツーエンドのセマンティックを持つヘッダフィールドを、暗号化したいと思うでしょう-info、イン返信先、有効期限、必要、サポート、サポートされていない、リトライした後、ユーザーエージェント、サーバー、および警告。これらのヘッダーフィールドのいずれかが暗号化された体内に存在している場合、彼らは、これはユーザにヘッダーフィールド値を表示またはUAに内部状態を設定することを伴うかどうか、任意の「外側」のヘッダフィールドの代わりに使用されるべきです。しかし彼らは将来のメッセージの「外側」のヘッダーで使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If present, the Date header field MUST always be the same in the \"inner\" and \"outer\" headers.",
      "ja": "存在する場合、日付ヘッダフィールドは常に「内側」と「外側」のヘッダーで同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since MIME bodies are attached to the \"inner\" message, implementations will usually encrypt MIME-specific header fields, including: MIME-Version, Content-Type, Content-Length, Content-Language, Content-Encoding and Content-Disposition. The \"outer\" message will have the proper MIME header fields for S/MIME bodies. These header fields (and any MIME bodies they preface) should be treated as normal MIME header fields and bodies received in a SIP message.",
      "ja": "MIME-バージョン、コンテンツタイプ、コンテンツ長、コンテンツ言語、コンテンツエンコーディングとコンテンツの廃棄：MIME体は「内部」メッセージに添付されているので、実装は通常含むMIME固有のヘッダフィールドを、暗号化します。 「外側」メッセージはS / MIMEボディのための適切なMIMEヘッダフィールドを有することになります。これらのヘッダーフィールド（それらは序文任意のMIME本体は）SIPメッセージで受信通常のMIMEヘッダフィールドと体として扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "It is not particularly useful to encrypt the following header fields: Min-Expires, Timestamp, Authorization, Priority, and WWW-Authenticate. This category also includes those header fields that can be changed by proxy servers (described in the preceding section). UAs SHOULD never include these in an \"inner\" message if they are not included in the \"outer\" message. UAs that receive any of these header fields in an encrypted body SHOULD ignore the encrypted values.",
      "ja": "ミン有効期限、タイムスタンプ、認可、優先度、およびWWW認証：以下のヘッダフィールドを暗号化するために特に有用ではありません。このカテゴリは、（前のセクションで説明）プロキシサーバーによって変更することができ、それらのヘッダフィールドを含んでいます。彼らは、「外」のメッセージに含まれていない場合はUAは「内側」のメッセージでこれらを含めるべきではありません。暗号化されたボディに、これらのヘッダフィールドのいずれかを受信するUAは、暗号化された値を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that extensions to SIP may define additional header fields; the authors of these extensions should describe the integrity and confidentiality properties of such header fields. If a SIP UA encounters an unknown header field with an integrity violation, it MUST ignore the header field.",
      "ja": "SIPへの拡張は、追加のヘッダーフィールドを定義してもよいことに留意されたいです。これらの拡張機能の作者は、このようなヘッダフィールドの完全性と機密性の性質を記述する必要があります。 SIP UAは、整合性違反と未知のヘッダフィールドに遭遇した場合、それはヘッダフィールドを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "23.4.2 Tunneling Integrity and Authentication",
      "section_title": true,
      "ja": "23.4.2トンネリング整合性と認証"
    },
    {
      "indent": 3,
      "text": "Tunneling SIP messages within S/MIME bodies can provide integrity for SIP header fields if the header fields that the sender wishes to secure are replicated in a \"message/sip\" MIME body signed with a CMS detached signature.",
      "ja": "送信者が確保したいヘッダフィールドは、CMS分離署名で署名された「メッセージ/ SIP」MIME本体に複製された場合、S / MIMEボディ内のトンネルSIPメッセージは、SIPヘッダフィールドのインテグリティを提供することができます。"
    },
    {
      "indent": 3,
      "text": "Provided that the \"message/sip\" body contains at least the fundamental dialog identifiers (To, From, Call-ID, CSeq), then a signed MIME body can provide limited authentication. At the very least, if the certificate used to sign the body is unknown to the recipient and cannot be verified, the signature can be used to ascertain that a later request in a dialog was transmitted by the same certificate-holder that initiated the dialog. If the recipient of the signed MIME body has some stronger incentive to trust the certificate (they were able to validate it, they acquired it from a trusted repository, or they have used it frequently) then the signature can be taken as a stronger assertion of the identity of the subject of the certificate.",
      "ja": "「メッセージ/ SIP」本体（、コールID、のCSeqから、TO）少なくとも基本的なダイアログ識別子を含むことを提供し、署名されたMIME本体は、限られた認証を提供することができます。本体に署名するために使用される証明書が受信者に知られていないと確認できない場合は最低で、署名ダイアログの後の要求は、ダイアログを開始し、同じ証明書保持者によって送信されたことを確認するために使用することができます。署名付きMIMEボディの受信者が証明書を信頼するためにいくつかの強力なインセンティブを持っている場合（それらが信頼できるリポジトリからそれを取得し、またはそれらは頻繁にそれを使用している、それを検証することができた）、署名は強く主張とすることができます証明書のサブジェクトの識別情報。"
    },
    {
      "indent": 3,
      "text": "In order to eliminate possible confusions about the addition or subtraction of entire header fields, senders SHOULD replicate all header fields from the request within the signed body. Any message bodies that require integrity protection MUST be attached to the \"inner\" message.",
      "ja": "全体ヘッダーフィールドの加算または減算約可能混乱を除去するために、送信者は、署名された体内の要求からすべてのヘッダーフィールドを複製するべきです。完全性保護を必要とするすべてのメッセージ本文には、「内部」メッセージに添付しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a Date header is present in a message with a signed body, the recipient SHOULD compare the header field value with its own internal clock, if applicable. If a significant time discrepancy is detected (on the order of an hour or more), the user agent SHOULD alert the user to the anomaly, and note that it is a potential security breach.",
      "ja": "Dateヘッダが署名本体とメッセージ中に存在する場合に該当する場合、受信者は、自身の内部クロックとヘッダフィールド値を比較する必要があります。かなりの時間の不一致が（時間以上のオーダー）が検出された場合、ユーザーエージェントは、異常をユーザに警告し、それが潜在的なセキュリティ違反であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If an integrity violation in a message is detected by its recipient, the message MAY be rejected with a 403 (Forbidden) response if it is a request, or any existing dialog MAY be terminated. UAs SHOULD notify users of this circumstance and request explicit guidance on how to proceed.",
      "ja": "メッセージに整合性違反は、その受信者によって検出された場合、それが要求され、または既存のダイアログが終了する可能性がある場合、メッセージは403（禁止）応答で拒否されることがあります。 UAはこの状況をユーザに通知し、続行する方法についての明確な指針を要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following is an example of the use of a tunneled \"message/sip\" body:",
      "ja": "以下は、トンネル「メッセージ/ SIP」体の使用例です。"
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0\nVia: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8\nTo: Bob <sip:bob@biloxi.com>\nFrom: Alice <sip:alice@atlanta.com>;tag=1928301774\nCall-ID: a84b4c76e66710\nCSeq: 314159 INVITE\nMax-Forwards: 70\nDate: Thu, 21 Feb 2002 13:02:03 GMT\nContact: <sip:alice@pc33.atlanta.com>\nContent-Type: multipart/signed;\n  protocol=\"application/pkcs7-signature\";\n  micalg=sha1; boundary=boundary42\nContent-Length: 568",
      "raw": true
    },
    {
      "indent": 6,
      "text": "--boundary42 Content-Type: message/sip",
      "ja": "--boundary42のContent-Type：メッセージ/一口"
    },
    {
      "indent": 6,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 To: Bob <bob@biloxi.com> From: Alice <alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Max-Forwards: 70 Date: Thu, 21 Feb 2002 13:02:03 GMT Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/sdp Content-Length: 147",
      "ja": "SIP INVITE：bob@biloxi.comをSIP / 2.0経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8へ：ボブ<bob@biloxi.com>から：アリス<alice@atlanta.com>;タグ= 1928301774コールID：a84b4c76e66710のCSeq：314159 INVITEマックス・フォワード：70日：木、2002年2月21日13時02分03秒GMT連絡先：<SIP：alice@pc33.atlanta.com>のContent-Type：アプリケーション/ SDPのContent長さ：147"
    },
    {
      "indent": 6,
      "text": "v=0 o=UserA 2890844526 2890844526 IN IP4 here.com s=Session SDP c=IN IP4 pc33.atlanta.com t=0 0 m=audio 49172 RTP/AVP 0 a=rtpmap:0 PCMU/8000",
      "ja": "V = 0 0 =ユーザーA 2890844526 2890844526 IN IP4 here.com S =セッションのSDP C = IN IP4 pc33.atlanta.com T = 0、M =オーディオ49172 RTP / AVP 0 A = rtpmap：0 PCMU / 8000"
    },
    {
      "indent": 6,
      "text": "--boundary42 Content-Type: application/pkcs7-signature; name=smime.p7s Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename=smime.p7s; handling=required",
      "ja": "--boundary42のContent-Type：アプリケーション/ PKCS7署名。名前= smime.p7sコンテンツ転送 - エンコード：base64でコンテンツディスポジション：添付ファイル;ファイル名= smime.p7s。ハンドリング=必要"
    },
    {
      "indent": 6,
      "text": "ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6 4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4 7GhIGfHfYT64VQbnj756",
      "ja": "ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6 4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4 7GhIGfHfYT64VQbnj756"
    },
    {
      "indent": 6,
      "text": "--boundary42-",
      "ja": "--boundary42-"
    },
    {
      "indent": 0,
      "text": "23.4.3 Tunneling Encryption",
      "section_title": true,
      "ja": "23.4.3トンネルの暗号化"
    },
    {
      "indent": 3,
      "text": "It may also be desirable to use this mechanism to encrypt a \"message/sip\" MIME body within a CMS EnvelopedData message S/MIME body, but in practice, most header fields are of at least some use to the network; the general use of encryption with S/MIME is to secure message bodies like SDP rather than message headers. Some informational header fields, such as the Subject or Organization could perhaps warrant end-to-end security. Headers defined by future SIP applications might also require obfuscation.",
      "ja": "また、CMS EnvelopedDataのメッセージのS / MIME本体内に「メッセージ/ SIP」MIMEボディを暗号化するためにこのメカニズムを使用することが望ましいが、実際には、ほとんどのヘッダフィールドは、ネットワークに、少なくともいくつかの使用です。 S / MIMEによる暗号化の一般的な使用は、SDPのようなメッセージ本体ではなく、メッセージヘッダーを確保するためです。そのような被験者または組織のようないくつかの情報ヘッダフィールドは、おそらくエンドツーエンドのセキュリティを保証することができました。将来のSIPアプリケーションによって定義されたヘッダも難読化が必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "Another possible application of encrypting header fields is selective anonymity. A request could be constructed with a From header field that contains no personal information (for example, sip:anonymous@anonymizer.invalid). However, a second From header field containing the genuine address-of-record of the originator could be encrypted within a \"message/sip\" MIME body where it will only be visible to the endpoints of a dialog.",
      "ja": "暗号化ヘッダフィールドの別の可能な用途は、選択的な匿名性です。要求には、個人情報（：anonymous@anonymizer.invalid例えば、SIP）を含まないからヘッダフィールドで構成することができます。しかし、本物のアドレス・オブ・レコード発信のを含むヘッダフィールドからの第二は、それだけで、ダイアログのエンドポイントに表示されます「のメッセージ/ SIP」MIME本体内に暗号化することができます。"
    },
    {
      "indent": 6,
      "text": "Note that if this mechanism is used for anonymity, the From header field will no longer be usable by the recipient of a message as an index to their certificate keychain for retrieving the proper S/MIME key to associated with the sender. The message must first be decrypted, and the \"inner\" From header field MUST be used as an index.",
      "ja": "このメカニズムは、匿名性のために使用される場合、ヘッダフィールドからもはや送信者に関連付けられているに適切なS / MIMEキーを取得するため、それらの証明書のチェーンへのインデックスとして、メッセージの受信者によって使用できないことに注意してください。メッセージは、最初の復号化されなければならず、ヘッダフィールドから「内側」とは、指標として使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to provide end-to-end integrity, encrypted \"message/sip\" MIME bodies SHOULD be signed by the sender. This creates a \"multipart/signed\" MIME body that contains an encrypted body and a signature, both of type \"application/pkcs7-mime\".",
      "ja": "エンドツーエンドの整合性を提供するために、暗号化された「メッセージ/一口」MIMEボディは、送信者によって署名されなければなりません。これは、暗号化された本体と署名、種類「アプリケーション/ PKCS7-MIME」の両方を含む「マルチパート/署名された」MIME本体を作成します。"
    },
    {
      "indent": 3,
      "text": "In the following example, of an encrypted and signed message, the text boxed in asterisks (\"*\") is encrypted:",
      "ja": "次の例では、暗号化および署名されたメッセージを、アスタリスクで箱入りのテキスト（「*」）が暗号化されています。"
    },
    {
      "indent": 8,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0\nVia: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8\nTo: Bob <sip:bob@biloxi.com>\nFrom: Anonymous <sip:anonymous@atlanta.com>;tag=1928301774\nCall-ID: a84b4c76e66710\nCSeq: 314159 INVITE\nMax-Forwards: 70\nDate: Thu, 21 Feb 2002 13:02:03 GMT\nContact: <sip:pc33.atlanta.com>\nContent-Type: multipart/signed;\n  protocol=\"application/pkcs7-signature\";\n  micalg=sha1; boundary=boundary42\nContent-Length: 568",
      "raw": true
    },
    {
      "indent": 8,
      "text": "--boundary42 Content-Type: application/pkcs7-mime; smime-type=enveloped-data; name=smime.p7m Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename=smime.p7m handling=required Content-Length: 231",
      "ja": "--boundary42のContent-Type：アプリケーション/ PKCS7-MIME; SMIME型=エンベロープデータ。名前= smime.p7mというコンテンツ転送 - エンコード：base64でコンテンツディスポジション：添付ファイル;ファイル名= smime.p7mという扱い=必要なContent-Length：231"
    },
    {
      "indent": 6,
      "text": "*********************************************************** * Content-Type: message/sip * * * * INVITE sip:bob@biloxi.com SIP/2.0 * * Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 * * To: Bob <bob@biloxi.com> * * From: Alice <alice@atlanta.com>;tag=1928301774 * * Call-ID: a84b4c76e66710 * * CSeq: 314159 INVITE * * Max-Forwards: 70 * * Date: Thu, 21 Feb 2002 13:02:03 GMT * * Contact: <sip:alice@pc33.atlanta.com> * * * * Content-Type: application/sdp * * * * v=0 * * o=alice 53655765 2353687637 IN IP4 pc33.atlanta.com * * s=Session SDP * * t=0 0 * * c=IN IP4 pc33.atlanta.com * * m=audio 3456 RTP/AVP 0 1 3 99 * * a=rtpmap:0 PCMU/8000 * ***********************************************************",
      "ja": "************************************************** ********* *のContent-Type：メッセージ/一口* * * * SIPのINVITE：bob@biloxi.com SIP / 2.0 * *経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8 * *宛先：ボブ<bob@biloxi.com> * *投稿者：アリス<alice@atlanta.com>;タグ= 1928301774 * *コールID：a84b4c76e66710 * *のCSeq：314159は、INVITE * *マックス・フォワード：70 * *日付：木、2002年2月21日午後01時02分03秒GMT * *お問い合わせ：<SIP：alice@pc33.atlanta.com> * * * *のContent-Type：アプリケーション/ SDP * * * * V = 0 * * 0 =アリス53655765 2353687637 IN IP4 pc33.atlanta.com * S =セッションSDP * T = 0 0 * * C = IN IP4 pc33.atlanta.com * M =オーディオ3456 RTP / AVP 0 1 3 99 * * = rtpmap：0 PCMU / 8000 * ******************************************* ****************"
    },
    {
      "indent": 8,
      "text": "--boundary42 Content-Type: application/pkcs7-signature; name=smime.p7s Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename=smime.p7s; handling=required",
      "ja": "--boundary42のContent-Type：アプリケーション/ PKCS7署名。名前= smime.p7sコンテンツ転送 - エンコード：base64でコンテンツディスポジション：添付ファイル;ファイル名= smime.p7s。ハンドリング=必要"
    },
    {
      "indent": 8,
      "text": "ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6 4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4 7GhIGfHfYT64VQbnj756",
      "ja": "ghyHhHUujhJhjH77n8HHGTrfvbnj756tbB9HG4VQpfyF467GhIGfHfYT6 4VQpfyF467GhIGfHfYT6jH77n8HHGghyHhHUujhJh756tbB9HGTrfvbnj n8HHGTrfvhJhjH776tbB9HG4VQbnj7567GhIGfHfYT6ghyHhHUujpfyF4 7GhIGfHfYT64VQbnj756"
    },
    {
      "indent": 8,
      "text": "--boundary42-",
      "ja": "--boundary42-"
    },
    {
      "indent": 0,
      "text": "24 Examples",
      "ja": "24例"
    },
    {
      "indent": 3,
      "text": "In the following examples, we often omit the message body and the corresponding Content-Length and Content-Type header fields for brevity.",
      "ja": "以下の実施例において、我々は、多くの場合、メッセージボディと対応するコンテンツ長と簡潔さのためにContent-Typeヘッダフィールドを省略します。"
    },
    {
      "indent": 0,
      "text": "24.1 Registration",
      "section_title": true,
      "ja": "24.1登録"
    },
    {
      "indent": 3,
      "text": "Bob registers on start-up. The message flow is shown in Figure 9. Note that the authentication usually required for registration is not shown for simplicity.",
      "ja": "ボブは、起動時に登録されます。メッセージフローは、通常、登録に必要な認証は簡単のため図示していないことが図9注に示されています。"
    },
    {
      "indent": 18,
      "text": "biloxi.com         Bob's\n registrar       softphone\n    |                |\n    |   REGISTER F1  |\n    |<---------------|\n    |    200 OK F2   |\n    |--------------->|",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 9: SIP Registration Example",
      "ja": "図9：SIP登録例"
    },
    {
      "indent": 3,
      "text": "F1 REGISTER Bob -> Registrar",
      "ja": "F1 REGISTERボブ - >レジストラ"
    },
    {
      "indent": 7,
      "text": "REGISTER sip:registrar.biloxi.com SIP/2.0\nVia: SIP/2.0/UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7\nMax-Forwards: 70\nTo: Bob <sip:bob@biloxi.com>\nFrom: Bob <sip:bob@biloxi.com>;tag=456248\nCall-ID: 843817637684230@998sdasdh09\nCSeq: 1826 REGISTER\nContact: <sip:bob@192.0.2.4>\nExpires: 7200\nContent-Length: 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The registration expires after two hours. The registrar responds with a 200 OK:",
      "ja": "登録は2時間後に期限が切れます。レジストラは、200 OKで応答します。"
    },
    {
      "indent": 3,
      "text": "F2 200 OK Registrar -> Bob",
      "ja": "F2 200 OKレジストラ - >ボブ"
    },
    {
      "indent": 8,
      "text": "SIP/2.0 200 OK\nVia: SIP/2.0/UDP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7\n ;received=192.0.2.4\nTo: Bob <sip:bob@biloxi.com>;tag=2493k59kd\nFrom: Bob <sip:bob@biloxi.com>;tag=456248\nCall-ID: 843817637684230@998sdasdh09\nCSeq: 1826 REGISTER\nContact: <sip:bob@192.0.2.4>\nExpires: 7200\nContent-Length: 0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "24.2 Session Setup",
      "section_title": true,
      "ja": "24.2セッション設定"
    },
    {
      "indent": 3,
      "text": "This example contains the full details of the example session setup in Section 4. The message flow is shown in Figure 1. Note that these flows show the minimum required set of header fields - some other header fields such as Allow and Supported would normally be present.",
      "ja": "そのような許可のようないくつかの他のヘッダフィールドを、通常存在するであろうサポート - この例では、メッセージ・フローは、これらのフローが必要なヘッダフィールドのセット最小を示すことが、図1に注意が示されている第4の例示的なセッション設定の詳細が含まれてい。"
    },
    {
      "indent": 0,
      "text": "F1 INVITE Alice -> atlanta.com proxy",
      "ja": "F1 INVITEアリス - > atlanta.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 Max-Forwards: 70 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/sdp Content-Length: 142",
      "ja": "bob@biloxi.com SIP / 2.0経由：SIPのINVITE SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8マックス・フォワード：70：から：アリス<SIP：ボブ<bob@biloxi.com一口>： alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：<SIP：alice@pc33.atlanta.com>のContent-Type：アプリケーション/ SDPのContent-Length：142 314159連絡先を招待"
    },
    {
      "indent": 0,
      "text": "(Alice's SDP not shown)",
      "ja": "（AliceのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F2 100 Trying atlanta.com proxy -> Alice",
      "ja": "atlanta.comのプロキシをしようとF2 100  - >アリス"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 100 Trying Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Content-Length: 0",
      "ja": "SIP / 2.0を介してをしよう100：から：<bob@biloxi.com一口>：アリス<SIP：alice@atlanta.comボブ：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8はに= 192.0.2.1を受け>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：314159は、コンテンツの長さをINVITE：0"
    },
    {
      "indent": 0,
      "text": "F3 INVITE atlanta.com proxy -> biloxi.com proxy",
      "ja": "F3 INVITE atlanta.comのプロキシ - > biloxi.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 Max-Forwards: 69 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/sdp Content-Length: 142",
      "ja": "SIP INVITE：bob@biloxi.comをSIP / 2.0経由：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;分岐= z9hG4bK77ef4c2312983.1のVia：SIP / 2.0 / UDP pc33.atlanta.com;分岐= z9hG4bKnashds8、受信= 192.0.2.1マックス・フォワード：69：ボブ<SIP：bob@biloxi.com>から：アリス<SIP：alice@atlanta.com>; = 1928301774のCall-IDタグ：のCSeq a84b4c76e66710：314159は、連絡先をINVITE：<一口： alice@pc33.atlanta.com>のContent-Type：アプリケーション/ SDPコンテンツの長さ：142"
    },
    {
      "indent": 0,
      "text": "(Alice's SDP not shown)",
      "ja": "（AliceのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F4 100 Trying biloxi.com proxy -> atlanta.com proxy",
      "ja": "> atlanta.comのプロキシ - プロキシをbiloxi.comしようとF4 100"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 100 Trying Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Content-Length: 0",
      "ja": "SIP / 2.0経由を試し100：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;分岐= z9hG4bK77ef4c2312983.1; = 192.0.2.2を介して受信した：SIP / 2.0 / UDP pc33.atlanta.comと、分岐= z9hG4bKnashds8、受信= 192.0.2.1へ：から：<bob@biloxi.com一口>：アリス<SIP：alice@atlanta.com>ボブ; = 1928301774のCall-IDタグ：a84b4c76e66710のCSeq：314159は、コンテンツの長さをINVITE：0"
    },
    {
      "indent": 0,
      "text": "F5 INVITE biloxi.com proxy -> Bob",
      "ja": "F5プロキシをbiloxi.com INVITE  - >ボブ"
    },
    {
      "indent": 0,
      "text": "INVITE sip:bob@192.0.2.4 SIP/2.0 Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 Max-Forwards: 68 To: Bob <sip:bob@biloxi.com> From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:alice@pc33.atlanta.com> Content-Type: application/sdp Content-Length: 142",
      "ja": "INVITE SIP：bob@192.0.2.4のSIP / 2.0経由：SIP / 2.0 / UDP server10.biloxi.com;ブランチ= z9hG4bK4b43c2ff8.1経由：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;ブランチ= z9hG4bK77ef4c2312983.1。 = 192.0.2.2を介して受信：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8; = 192.0.2.1マックス・フォワードを受け取っ：68：から：アリス<SIP：<bob@biloxi.com一口>ボブ： alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：<SIP：alice@pc33.atlanta.com>のContent-Type：アプリケーション/ SDPのContent-Length：142 314159連絡先を招待"
    },
    {
      "indent": 0,
      "text": "(Alice's SDP not shown)",
      "ja": "（AliceのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F6 180 Ringing Bob -> biloxi.com proxy",
      "ja": "F6 180リンギングボブ - > biloxi.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 180 Ringing Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1 ;received=192.0.2.3 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 Contact: <sip:bob@192.0.2.4> CSeq: 314159 INVITE Content-Length: 0",
      "ja": "SIP / 2.0 180リンギングのVia：SIP / 2.0 / UDP server10.biloxi.com;分岐= z9hG4bK4b43c2ff8.1; = 192.0.2.3を介して受信した：SIP / 2.0 / UDP bigbox3.site3.atlanta.comと、分岐= z9hG4bK77ef4c2312983.1。するために、受信した= 192.0.2.1;ブランチ= z9hG4bKnashds8; SIP / 2.0 / UDP pc33.atlanta.com：ボブ= 192.0.2.2を介して受信された<SIP：bob@biloxi.com>;タグ= a6c85cfから：アリス<SIP：アリス@ atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710連絡先：<SIP：bob@192.0.2.4>のCSeq：314159のContent-LengthをINVITE：0"
    },
    {
      "indent": 0,
      "text": "F7 180 Ringing biloxi.com proxy -> atlanta.com proxy",
      "ja": "F7 180リンギングbiloxi.comのプロキシ - > atlanta.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 180 Ringing Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 Contact: <sip:bob@192.0.2.4> CSeq: 314159 INVITE Content-Length: 0",
      "ja": "SIP / 2.0 180リンギングのVia：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;分岐= z9hG4bK77ef4c2312983.1は、受信= 192.0.2.2のVia：SIP / 2.0 / UDP pc33.atlanta.com;分岐= z9hG4bKnashds8、受信= 192.0.2.1へ：ボブ<SIP：bob@biloxi.com>;からタグ= a6c85cf：アリス<SIP：alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710連絡先：<SIP：bob@192.0.2.4 >のCSeq：314159のContent-LengthをINVITE：0"
    },
    {
      "indent": 0,
      "text": "F8 180 Ringing atlanta.com proxy -> Alice",
      "ja": "F8 180リンギングatlanta.comのプロキシ - >アリス"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 180 Ringing Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 Contact: <sip:bob@192.0.2.4> CSeq: 314159 INVITE Content-Length: 0",
      "ja": "SIP / 2.0 180リンギング経由：ボブ：SIP / 2.0 / UDP pc33.atlanta.com;分岐= z9hG4bKnashds8はへ= 192.0.2.1を受け;：アリス<SIP：<SIP bob@biloxi.com>からタグ= a6c85cfアリス@ atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710連絡先：<SIP：bob@192.0.2.4>のCSeq：314159のContent-LengthをINVITE：0"
    },
    {
      "indent": 0,
      "text": "F9 200 OK Bob -> biloxi.com proxy",
      "ja": "F9 200 OKボブ - > biloxi.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP server10.biloxi.com;branch=z9hG4bK4b43c2ff8.1 ;received=192.0.2.3 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:bob@192.0.2.4> Content-Type: application/sdp Content-Length: 131",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / UDP server10.biloxi.com;ブランチ= z9hG4bK4b43c2ff8.1は、受信= 192.0.2.3経由：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;ブランチ= z9hG4bK77ef4c2312983.1。するために、受信した= 192.0.2.1;ブランチ= z9hG4bKnashds8; SIP / 2.0 / UDP pc33.atlanta.com：ボブ= 192.0.2.2を介して受信された<SIP：bob@biloxi.com>;タグ= a6c85cfから：アリス<SIP：アリス@ atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：314159 INVITE連絡先：<SIP：bob@192.0.2.4>のContent-Type：アプリケーション/ SDPコンテンツの長さ：131"
    },
    {
      "indent": 0,
      "text": "(Bob's SDP not shown)",
      "ja": "（BobのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F10 200 OK biloxi.com proxy -> atlanta.com proxy",
      "ja": "F10 200 OK biloxi.comのプロキシ - > atlanta.comのプロキシ"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP bigbox3.site3.atlanta.com;branch=z9hG4bK77ef4c2312983.1 ;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:bob@192.0.2.4> Content-Type: application/sdp Content-Length: 131",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / UDP bigbox3.site3.atlanta.com;ブランチ= z9hG4bK77ef4c2312983.1は、受信= 192.0.2.2経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8;受け取ら= 192.0.2.1へ：ボブ<SIP：bob@biloxi.com>;からタグ= a6c85cf：アリス<SIP：alice@atlanta.com>; = 1928301774のCall-IDタグ：a84b4c76e66710のCSeq：314159は、連絡先をINVITE：<SIP：ボブ@ 192.0.2.4>のContent-Type：アプリケーション/ SDPコンテンツの長さ：131"
    },
    {
      "indent": 0,
      "text": "(Bob's SDP not shown)",
      "ja": "（BobのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F11 200 OK atlanta.com proxy -> Alice",
      "ja": "F11 200 OK atlanta.comのプロキシ - >アリス"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds8 ;received=192.0.2.1 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 INVITE Contact: <sip:bob@192.0.2.4> Content-Type: application/sdp Content-Length: 131",
      "ja": "SIP / 2.0 200 OK経由：ボブ：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds8はに= 192.0.2.1を受けた<SIP：bob@biloxi.com>;タグ= a6c85cfをから：アリス<SIP：アリス@ atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：314159 INVITE連絡先：<SIP：bob@192.0.2.4>のContent-Type：アプリケーション/ SDPコンテンツの長さ：131"
    },
    {
      "indent": 0,
      "text": "(Bob's SDP not shown)",
      "ja": "（BobのSDPは示されていません）"
    },
    {
      "indent": 0,
      "text": "F12 ACK Alice -> Bob",
      "ja": "F12 ACKアリス - >ボブ"
    },
    {
      "indent": 0,
      "text": "ACK sip:bob@192.0.2.4 SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bKnashds9 Max-Forwards: 70 To: Bob <sip:bob@biloxi.com>;tag=a6c85cf From: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 314159 ACK Content-Length: 0",
      "ja": "ACK SIP：bob@192.0.2.4のSIP / 2.0経由：SIP / 2.0 / UDP pc33.atlanta.com;ブランチ= z9hG4bKnashds9マックス・フォワード：70：ボブ<SIP：bob@biloxi.com>;タグ= a6c85cfから：アリス<SIP：alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：314159 ACKのコンテンツの長さ：0"
    },
    {
      "indent": 3,
      "text": "The media session between Alice and Bob is now established.",
      "ja": "アリスとボブの間でメディアセッションは現在確立されています。"
    },
    {
      "indent": 3,
      "text": "Bob hangs up first. Note that Bob's SIP phone maintains its own CSeq numbering space, which, in this example, begins with 231. Since Bob is making the request, the To and From URIs and tags have been swapped.",
      "ja": "ボブは最初にハングアップします。ボブのSIPフォンは、ボブは、要求を行っているし、URIとタグから入れ替わっているされているので、この例では、231で始まる、独自のCSeq番号スペースを維持していることに注意してください。"
    },
    {
      "indent": 0,
      "text": "F13 BYE Bob -> Alice",
      "ja": "F13 BYEボブ - >アリス"
    },
    {
      "indent": 0,
      "text": "BYE sip:alice@pc33.atlanta.com SIP/2.0 Via: SIP/2.0/UDP 192.0.2.4;branch=z9hG4bKnashds10 Max-Forwards: 70 From: Bob <sip:bob@biloxi.com>;tag=a6c85cf To: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 231 BYE Content-Length: 0",
      "ja": "BYEのSIP：alice@pc33.atlanta.com SIP / 2.0経由：SIP / 2.0 / UDP 192.0.2.4;ブランチ= z9hG4bKnashds10マックス・フォワード：70から：ボブ<SIP：bob@biloxi.com>;タグ= a6c85cfへ：アリス<SIP：alice@atlanta.com>;タグ= 1928301774のCall-ID：a84b4c76e66710のCSeq：231 BYEのコンテンツの長さ：0"
    },
    {
      "indent": 0,
      "text": "F14 200 OK Alice -> Bob",
      "ja": "F14 200 OKアリス - >ボブ"
    },
    {
      "indent": 0,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/UDP 192.0.2.4;branch=z9hG4bKnashds10 From: Bob <sip:bob@biloxi.com>;tag=a6c85cf To: Alice <sip:alice@atlanta.com>;tag=1928301774 Call-ID: a84b4c76e66710 CSeq: 231 BYE Content-Length: 0",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / UDP 192.0.2.4;ブランチ= z9hG4bKnashds10から：ボブ<SIP：bob@biloxi.com>;タグ= a6c85cfへ：アリス<SIP：alice@atlanta.com>;タグ= 1928301774コールID：a84b4c76e66710のCSeq：231 BYEのコンテンツの長さ：0"
    },
    {
      "indent": 3,
      "text": "The SIP Call Flows document [40] contains further examples of SIP messages.",
      "ja": "SIPコールは、文書[40]はSIPメッセージの更なる例が含まれて流れています。"
    },
    {
      "indent": 0,
      "text": "25 Augmented BNF for the SIP Protocol",
      "ja": "SIPプロトコルのための25増補BNF"
    },
    {
      "indent": 3,
      "text": "All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) defined in RFC 2234 [10]. Section 6.1 of RFC 2234 defines a set of core rules that are used by this specification, and not repeated here. Implementers need to be familiar with the notation and content of RFC 2234 in order to understand this specification. Certain basic rules are in uppercase, such as SP, LWS, HTAB, CRLF, DIGIT, ALPHA, etc. Angle brackets are used within definitions to clarify the use of rule names.",
      "ja": "この文書で指定された機構の全ては、散文とRFC 2234 [10]で定義された拡張バッカスナウア記法（BNF）の両方に記載されています。 RFC 2234のセクション6.1は、本明細書で使用されるコア・ルールのセットを定義し、ここでは繰り返しません。実装は、本明細書を理解するためにRFC 2234の表記と内容に精通している必要があります。特定の基本的なルールは、等角度ブラケットがルール名の使用を明確にするための定義内で使用されているSP、LWS、HTAB、CRLF、DIGIT、ALPHA、として、大文字です。"
    },
    {
      "indent": 3,
      "text": "The use of square brackets is redundant syntactically. It is used as a semantic hint that the specific parameter is optional to use.",
      "ja": "角カッコの使用は、冗長な構文的です。特定のパラメータを使用するオプションであることを意味上のヒントとして使用されます。"
    },
    {
      "indent": 0,
      "text": "25.1 Basic Rules",
      "section_title": true,
      "ja": "25.1基本ルール"
    },
    {
      "indent": 3,
      "text": "The following rules are used throughout this specification to describe basic parsing constructs. The US-ASCII coded character set is defined by ANSI X3.4-1986.",
      "ja": "次のルールは、基本的な構文解析構造を記述するために本明細書を通して使用されています。 US-ASCIIコード化文字セットはANSI X3.4-1986で定義されています。"
    },
    {
      "indent": 6,
      "text": "alphanum = ALPHA / DIGIT",
      "ja": "alphanum = ALPHA / DIGIT"
    },
    {
      "indent": 3,
      "text": "Several rules are incorporated from RFC 2396 [5] but are updated to make them compliant with RFC 2234 [10]. These include:",
      "ja": "いくつかのルールは、RFC 2396 [5]から組み込まれているが、RFC 2234 [10]とそれらを適合させるために更新されます。これらは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "reserved = \";\" / \"/\" / \"?\" / \":\" / \"@\" / \"&\" / \"=\" / \"+\" / \"$\" / \",\" unreserved = alphanum / mark mark = \"-\" / \"_\" / \".\" / \"!\" / \"~\" / \"*\" / \"'\" / \"(\" / \")\" escaped = \"%\" HEXDIG HEXDIG",
      "ja": "=予約 \";\" / \"/\" / \"？\" / \"：\" / \"@\" / \"＆\" / \"=\" / \"+\" / \"$\" / \"\" 予約されていない= alphanum /マークマーク= \" - \" / \"_\" / \"\" / \"！\" / \"〜\" / \"*\" / \"'\" / \"（\" / \"）\" = \"％\" HEXDIG HEXDIGエスケープ"
    },
    {
      "indent": 3,
      "text": "SIP header field values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab. All linear white space, including folding, has the same semantics as SP. A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream. This is intended to behave exactly as HTTP/1.1 as described in RFC 2616 [8]. The SWS construct is used when linear white space is optional, generally between tokens and separators.",
      "ja": "継続行はスペースまたは水平タブで始まる場合、SIPヘッダフィールド値が複数行に折り畳むことができます。折りたたみを含むすべてのリニアホワイトスペースは、SPと同じ意味を持っています。受信者は、フィールドの値を解釈するか、下流のメッセージを転送する前に、単一のSPを持つ任意の線形空白を置き換えることができます。これは、RFC 2616に記載されているように[8]、正確にHTTP / 1.1のように動作することが意図されています。リニアホワイトスペースは、一般にトークンとセパレータとの間に、任意のときSWS構築物が使用されます。"
    },
    {
      "indent": 6,
      "text": "LWS = [*WSP CRLF] 1*WSP ; linear whitespace SWS = [LWS] ; sep whitespace",
      "ja": "LWS = [WSP CRLF *] 1 * WSP。線形空白SWS = [LWS]。 9月の空白"
    },
    {
      "indent": 3,
      "text": "To separate the header name from the rest of value, a colon is used, which, by the above rule, allows whitespace before, but no line break, and whitespace after, including a linebreak. The HCOLON defines this construct.",
      "ja": "値の残りの部分からヘッダ名を分離するために、結腸は改行を含む、上記のルールにより、前に空白を可能にする、使用、ない改行、および空白の後です。 HCOLONは、この構造を定義します。"
    },
    {
      "indent": 6,
      "text": "HCOLON = *( SP / HTAB ) \":\" SWS",
      "ja": "HCOLON = *（SP / HTAB） \"：\" SWS"
    },
    {
      "indent": 3,
      "text": "The TEXT-UTF8 rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser. Words of *TEXT-UTF8 contain characters from the UTF-8 charset (RFC 2279 [7]). The TEXT-UTF8-TRIM rule is used for descriptive field contents that are n t quoted strings, where leading and trailing LWS is not meaningful. In this regard, SIP differs from HTTP, which uses the ISO 8859-1 character set.",
      "ja": "TEXT-UTF8規則は、メッセージパーサによって解釈されることを意図するものではない記述フィールドの内容と値のために使用されます。 * TEXT-UTF8の言葉は（[7] RFC 2279）UTF8文字セットからの文字を含みます。 TEXT-UTF8-TRIMルールはN先頭とLWSを後続する意味のない引用符で囲まれた文字列を、tはれる記述フィールドの内容のために使用されます。この点において、SIPは、ISO 8859-1文字セットを使用してHTTPとは異なります。"
    },
    {
      "indent": 6,
      "text": "TEXT-UTF8-TRIM = 1*TEXT-UTF8char *(*LWS TEXT-UTF8char) TEXT-UTF8char = %x21-7E / UTF8-NONASCII UTF8-NONASCII = %xC0-DF 1UTF8-CONT / %xE0-EF 2UTF8-CONT / %xF0-F7 3UTF8-CONT / %xF8-Fb 4UTF8-CONT / %xFC-FD 5UTF8-CONT UTF8-CONT = %x80-BF",
      "ja": "TEXT-UTF8-TRIM = 1 * TEXT-UTF8char *（* LWS TEXT-UTF8char）TEXT-UTF8char =％x21-7E / UTF8-NONASCII UTF8-NONASCII =％XC0-DF 1UTF8-CONT /％xE0-EF 2UTF8-CONT /％XF0-F7 3UTF8-CONT /％XF8-FB 4UTF8-CONT /％XFC-FD 5UTF8-CONT UTF8-CONT =％X80-BF"
    },
    {
      "indent": 3,
      "text": "A CRLF is allowed in the definition of TEXT-UTF8-TRIM only as part of a header field continuation. It is expected that the folding LWS will be replaced with a single SP before interpretation of the TEXT-UTF8-TRIM value.",
      "ja": "CRLFだけヘッダーフィールド継続の一部としてTEXT-UTF8-TRIMの定義で許容されます。折りたたみLWSはTEXT-UTF8-TRIM値の解釈前に、単一のSPに置き換えされることが期待されます。"
    },
    {
      "indent": 3,
      "text": "Hexadecimal numeric characters are used in several protocol elements. Some elements (authentication) force hex alphas to be lower case.",
      "ja": "進数字は、いくつかのプロトコル要素で使用されています。いくつかの要素（認証）は小文字であることがヘクスアルファを強制します。"
    },
    {
      "indent": 6,
      "text": "LHEX = DIGIT / %x61-66 ;lowercase a-f",
      "ja": "Lhex = DIGIT /％x61-66は、-Fを小文字"
    },
    {
      "indent": 3,
      "text": "Many SIP header field values consist of words separated by LWS or special characters. Unless otherwise stated, tokens are case-insensitive. These special characters MUST be in a quoted string to be used within a parameter value. The word construct is used in Call-ID to allow most separators to be used.",
      "ja": "多くのSIPヘッダフィールド値はLWSまたは特殊文字で区切られた単語から成ります。特に明記しない限り、トークンは大文字と小文字を区別しません。これらの特殊文字は、パラメータ値内で使用されるように引用符で囲まれた文字列でなければなりません。単語構築物は、ほとんどのセパレータを使用できるようにするには、Call-IDに使用されています。"
    },
    {
      "indent": 6,
      "text": "token = 1*(alphanum / \"-\" / \".\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\" ) separators = \"(\" / \")\" / \"<\" / \">\" / \"@\" / \",\" / \";\" / \":\" / \"\\\" / DQUOTE / \"/\" / \"[\" / \"]\" / \"?\" / \"=\" / \"{\" / \"}\" / SP / HTAB word = 1*(alphanum / \"-\" / \".\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\" / \"(\" / \")\" / \"<\" / \">\" / \":\" / \"\\\" / DQUOTE / \"/\" / \"[\" / \"]\" / \"?\" / \"{\" / \"}\" )",
      "ja": "トークン= 1 *（alphanum / \" - \" / / / \"％\" / \"*\" / \"_\" / \"+\" / \"`\"/ \"'\"/ \"〜\" \"\" \"！\"）区切り=\" （ \"/ \"）\"/ \"<\"/ \">\"/ \"@\"/\"、」/ \";\" / \"：\" / \"\\\" / DQUOTE / \"/\" / \"[\" / \"]\" / \"？\" / \"=\" / \"{\" / \"}\" / SP / HTABワード= 1 *（alphanum / \" - \" \"\" \"！\" / / / \"％\" / \"*\" / \"_\" / \"+\" / \"`\"/ \"'\"/ \"〜\"/ \"（\"/ \"）\"/ \"<\"/ \">\"/ \"：\"/ \"\\\"/ DQUOTE / \"/\"/ \"[\"/ \"]\" / \"？\" / \"{\" / \"}\"）"
    },
    {
      "indent": 3,
      "text": "When tokens are used or separators are used between elements, whitespace is often allowed before or after these characters:",
      "ja": "トークンが使用されているか、セパレータをエレメント間に使用されている場合は、空白文字は、多くの場合、これらの文字の前または後に許可されています。"
    },
    {
      "indent": 6,
      "text": "STAR = SWS \"*\" SWS ; asterisk SLASH = SWS \"/\" SWS ; slash EQUAL = SWS \"=\" SWS ; equal LPAREN = SWS \"(\" SWS ; left parenthesis RPAREN = SWS \")\" SWS ; right parenthesis RAQUOT = \">\" SWS ; right angle quote LAQUOT = SWS \"<\"; left angle quote COMMA = SWS \",\" SWS ; comma SEMI = SWS \";\" SWS ; semicolon COLON = SWS \":\" SWS ; colon LDQUOT = SWS DQUOTE; open double quotation mark RDQUOT = DQUOTE SWS ; close double quotation mark",
      "ja": "STAR = SWS \"*\" SWS。アスタリスクSLASH = SWS \"/\" SWS; EQUAL = SWS \"=\" SWSを大幅に削減。等しいLPAREN = SWS \"（\" SWS;左括弧RPAREN = SWS \"）\" SWS。右括弧のRAQUOT = \">\" SWS;直角の引用LAQUOT = SWS \"<\";左の角度の引用COMMA = SWS \"\" SWS;コンマSEMI = SWS \";\" SWS;セミコロンコロン= SWS \"：\" SWS;大腸LDQUOT = SWS DQUOTE。二重引用符のRDQUOT = DQUOTE SWSを開きます。二重引用符を閉じます"
    },
    {
      "indent": 3,
      "text": "Comments can be included in some SIP header fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing \"comment\" as part of their field value definition. In all other fields, parentheses are considered part of the field value.",
      "ja": "コメントは括弧付きコメントテキストを囲むことにより、いくつかのSIPヘッダフィールドに含めることができます。コメントは自分のフィールド値定義の一部として「コメント」を含むフィールドで許可されています。他のすべてのフィールドでは、括弧はフィールド値の一部とみなされます。"
    },
    {
      "indent": 6,
      "text": "comment = LPAREN *(ctext / quoted-pair / comment) RPAREN ctext = %x21-27 / %x2A-5B / %x5D-7E / UTF8-NONASCII / LWS",
      "ja": "コメント= LPAREN *（CTEXT /引用対/コメント）RPAREN CTEXT =％x21-27 /％X2A-5B /％x5D-7E / UTF8-NONASCII / LWS"
    },
    {
      "indent": 3,
      "text": "ctext includes all chars except left and right parens and backslash. A string of text is parsed as a single word if it is quoted using double-quote marks. In quoted strings, quotation marks (\") and backslashes (\\) need to be escaped.",
      "ja": "CTEXTは左右の括弧とバックスラッシュを除くすべての文字が含まれています。それは、二重引用符を使用して引用されている場合は、テキストの文字列は、単一の単語として解析されます。引用符で囲まれた文字列では、引用符（ \"）とバックスラッシュ（\\）はエスケープする必要があります。"
    },
    {
      "indent": 6,
      "text": "quoted-string = SWS DQUOTE *(qdtext / quoted-pair ) DQUOTE qdtext = LWS / %x21 / %x23-5B / %x5D-7E / UTF8-NONASCII",
      "ja": "引用符で囲まれた文字列= SWS DQUOTE *（qdtext /引用対）DQUOTE qdtext = LWS /％X21 /％x23-5B /％x5D-7E / UTF8-NONASCII"
    },
    {
      "indent": 3,
      "text": "The backslash character (\"\\\") MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs. Unlike HTTP/1.1, the characters CR and LF cannot be escaped by this mechanism to avoid conflict with line folding and header separation.",
      "ja": "バックスラッシュ文字（「\\」）は唯一の引用された文字列とコメント構文内の単一文字引用メカニズムとして使用することができます。 HTTP / 1.1とは異なり、文字CRやLFは、ラインフォールディングおよびヘッダ分離との競合を避けるために、この機構によってエスケープすることができません。"
    },
    {
      "indent": 0,
      "text": "quoted-pair = \"\\\" (%x00-09 / %x0B-0C / %x0E-7F)",
      "ja": "引用されたペア= \"\\\"（％x00-09 /％X0B-0C /％x0E-7F）"
    },
    {
      "indent": 0,
      "text": "SIP-URI = \"sip:\" [ userinfo ] hostport uri-parameters [ headers ] SIPS-URI = \"sips:\" [ userinfo ] hostport uri-parameters [ headers ] userinfo = ( user / telephone-subscriber ) [ \":\" password ] \"@\" user = 1*( unreserved / escaped / user-unreserved ) user-unreserved = \"&\" / \"=\" / \"+\" / \"$\" / \",\" / \";\" / \"?\" / \"/\" password = *( unreserved / escaped / \"&\" / \"=\" / \"+\" / \"$\" / \",\" ) hostport = host [ \":\" port ] host = hostname / IPv4address / IPv6reference hostname = *( domainlabel \".\" ) toplabel [ \".\" ] domainlabel = alphanum / alphanum *( alphanum / \"-\" ) alphanum toplabel = ALPHA / ALPHA *( alphanum / \"-\" ) alphanum",
      "ja": "SIP-URI = \"SIP：\" [ユーザー情報]のHostPort URIパラメータ[ヘッダー] SIPS-URI = \"一口：\" [ユーザー情報]のHostPort URIパラメータ[ヘッダー]ユーザー情報=（ユーザ/電話加入者）[ \"：\" パスワード] \"@\" ユーザー= 1 *ユーザー-予約されていない= \"＆​​\" / \"=\" / \"+\" / \"$\"（予約されていない/ /ユーザー-予約されていないエスケープ）/ \"\" / \";\" / \"？\" / \"/\" パスワード= *（予約されていない/エスケープ/ \"＆\" / \"=\" / \"+\" / \"$\" / \"\"）のHostPort =ホスト[ \"：\" ポート]ホスト=ホスト名/ IPv4Addressを/ IPv6referenceホスト名= *（domainlabel \"\"）toplabelの[ \"\" ] domainlabel = alphanum / alphanum *（alphanum / \" - \"）alphanum toplabel = ALPHA / ALPHA *（alphanum / \" - \"）alphanum"
    },
    {
      "indent": 0,
      "text": "IPv4address = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT IPv6reference = \"[\" IPv6address \"]\" IPv6address = hexpart [ \":\" IPv4address ] hexpart = hexseq / hexseq \"::\" [ hexseq ] / \"::\" [ hexseq ] hexseq = hex4 *( \":\" hex4) hex4 = 1*4HEXDIG port = 1*DIGIT",
      "ja": "= 1 * 3DIGIT IPv4Addressを \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT IPv6reference = \"[\" IPv6address \"]\" IPv6address = hexpart [ \"：\" IPv4Addressを】hexpart = hexseq / hexseq \"::\" [hexseq] / \"::\" [hexseq] hexseq = hex4 *（ \"：\" hex4 ）hex4 = 1 * 4HEXDIGポート= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "The BNF for telephone-subscriber can be found in RFC 2806 [9]. Note, however, that any characters allowed there that are not allowed in the user part of the SIP URI MUST be escaped.",
      "ja": "電話加入者のためのBNFは、RFC 2806に見出すことができる[9]。 SIP URIのユーザー部分で許可されていないが許さ任意の文字をエスケープしなければならないこと、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "uri-parameters = *( \";\" uri-parameter) uri-parameter = transport-param / user-param / method-param / ttl-param / maddr-param / lr-param / other-param transport-param = \"transport=\" ( \"udp\" / \"tcp\" / \"sctp\" / \"tls\" / other-transport) other-transport = token user-param = \"user=\" ( \"phone\" / \"ip\" / other-user) other-user = token method-param = \"method=\" Method ttl-param = \"ttl=\" ttl maddr-param = \"maddr=\" host lr-param = \"lr\" other-param = pname [ \"=\" pvalue ] pname = 1*paramchar pvalue = 1*paramchar paramchar = param-unreserved / unreserved / escaped param-unreserved = \"[\" / \"]\" / \"/\" / \":\" / \"&\" / \"+\" / \"$\"",
      "ja": "URIパラメータ= *（ \";\" URIパラメータ）URIパラメータ=輸送-PARAM /ユーザPARAM /方法-PARAM / TTL-PARAM / MADDR-PARAM / LR-PARAM /他-PARAM輸送PARAM =「輸送=」（ \"UDP\" / \"TCP\" / \"SCTP\" / \"TLS\" /他の輸送）他の輸送=トークンユーザPARAM = \"ユーザ=\"（ \"電話\" / \"IP\" /他のユーザ）他-user =トークン方法-PARAM = \"METHOD =\" メソッドTTL-PARAM = \"TTL =\" TTLのMADDR-PARAM = \"MADDR =\" ホストLR-PARAM = \"LR\" 他-PARAM = PNAME [ \"=\" p値] PNAME = 1 * paramchar p値= 1 *予約されていない/ paramchar paramchar =のparam-予約されていない/エスケープのparam-予約されていません= \"[\" / \"]\" / \"/\" / \"：\" / \"＆\" / \"+\" / \"$\""
    },
    {
      "indent": 0,
      "text": "headers = \"?\" header *( \"&\" header ) header = hname \"=\" hvalue hname = 1*( hnv-unreserved / unreserved / escaped ) hvalue = *( hnv-unreserved / unreserved / escaped ) hnv-unreserved = \"[\" / \"]\" / \"/\" / \"?\" / \":\" / \"+\" / \"$\"",
      "ja": "ヘッダ= \"？\"ヘッダ*（ \"＆\" ヘッダ）ヘッダ= hname \"=\" hvalue hname = 1 *（HNV-未予約/予約されていない/エスケープ）hvalue = *（HNV-未予約/予約されていない/エスケープ）HNV-未予約= \"[\" /「] \"/ \"/\"/ \"？\" / \"：\" / \"+\" / \"$\""
    },
    {
      "indent": 0,
      "text": "SIP-message = Request / Response Request = Request-Line *( message-header ) CRLF [ message-body ] Request-Line = Method SP Request-URI SP SIP-Version CRLF Request-URI = SIP-URI / SIPS-URI / absoluteURI absoluteURI = scheme \":\" ( hier-part / opaque-part ) hier-part = ( net-path / abs-path ) [ \"?\" query ] net-path = \"//\" authority [ abs-path ] abs-path = \"/\" path-segments opaque-part = uric-no-slash *uric uric = reserved / unreserved / escaped uric-no-slash = unreserved / escaped / \";\" / \"?\" / \":\" / \"@\" / \"&\" / \"=\" / \"+\" / \"$\" / \",\" path-segments = segment *( \"/\" segment ) segment = *pchar *( \";\" param ) param = *pchar pchar = unreserved / escaped / \":\" / \"@\" / \"&\" / \"=\" / \"+\" / \"$\" / \",\" scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" ) authority = srvr / reg-name srvr = [ [ userinfo \"@\" ] hostport ] reg-name = 1*( unreserved / escaped / \"$\" / \",\" / \";\" / \":\" / \"@\" / \"&\" / \"=\" / \"+\" ) query = *uric SIP-Version = \"SIP\" \"/\" 1*DIGIT \".\" 1*DIGIT",
      "ja": "SIPメッセージ=リクエスト/応答要求=要求ライン*（メッセージヘッダー）CRLF [メッセージ本体]リクエストライン=メソッドSPのRequest-URI SP SIP-版CRLFのRequest-URI = SIP-URI / SIPS-URI / absoluteURIでabsoluteURIで=方式 \"：\" \"？\"（HIER部分/不透明部分）HIER部分=（ネットパス/ ABSパス）[クエリ]ネットパス= \"//\" 権威[ABS-パス] ABS-パス= \"/\" パスセグメント不透明部分=尿-NO-スラッシュ*尿尿=予約されていない/予約/ =尿-NO-スラッシュエスケープません予約されていない/ /エスケープ \";\" / \"？\" / \"：\" / \"@\" / \"＆\" / \"=\" / \"+\" / \"$\" / \"\" パスセグメント=セグメント*（ \"/\" セグメント）セグメント= * PChar型*（ \";\" PARAM ）PARAM = * PChar型PChar型=予約されていない/エスケープ/ \"：\" / \"@\" / \"＆\" / \"=\" / \"+\" / \"$\" / \"\" スキーム= ALPHAの*（ALPHA / DIGIT / \"+\" / \" - \" /）権限= SRVR / REG名SRVR = [[userinfoを \"@\"]ホスト側] REG-名= 1 *（予約されていない/エスケープ/ \"$\" / \"\" / \";\" / \"\" \"：\" / \"@\" / \"＆\" / \"=\" / \"+\"）クエリ= *尿SIP-バージョン= \"SIP\" \"/\" 1 * DIGIT \"\"。 1 * DIGIT"
    },
    {
      "indent": 0,
      "text": "message-header = (Accept / Accept-Encoding / Accept-Language / Alert-Info / Allow / Authentication-Info / Authorization / Call-ID / Call-Info / Contact / Content-Disposition / Content-Encoding / Content-Language / Content-Length / Content-Type / CSeq / Date / Error-Info / Expires / From / In-Reply-To / Max-Forwards / MIME-Version / Min-Expires / Organization / Priority / Proxy-Authenticate / Proxy-Authorization / Proxy-Require / Record-Route / Reply-To",
      "ja": "メッセージ・ヘッダー=（受け入れる/受け入れエンコード/のAccept-Language /言語アラート情報/許可/認証-情報/認証/コールID /コール情報/連絡先/コンテンツ処分/コンテンツエンコーディング/コンテンツ言語/コンテンツ-length /コンテンツタイプ/のCSeq /日/エラー-情報/有効期限/イン返信先/マックス・フォワード/ MIME-バージョン/分、有効期限/組織/優先順位/プロキシ認証/プロキシ認証/プロキシ/から-Require /レコード・ルート/返信先"
    },
    {
      "indent": 16,
      "text": "/  Require\n/  Retry-After\n/  Route\n/  Server\n/  Subject\n/  Supported\n/  Timestamp\n/  To\n/  Unsupported\n/  User-Agent\n/  Via\n/  Warning\n/  WWW-Authenticate\n/  extension-header) CRLF",
      "raw": true
    },
    {
      "indent": 0,
      "text": "INVITEm = %x49.4E.56.49.54.45 ; INVITE in caps ACKm = %x41.43.4B ; ACK in caps OPTIONSm = %x4F.50.54.49.4F.4E.53 ; OPTIONS in caps BYEm = %x42.59.45 ; BYE in caps CANCELm = %x43.41.4E.43.45.4C ; CANCEL in caps REGISTERm = %x52.45.47.49.53.54.45.52 ; REGISTER in caps Method = INVITEm / ACKm / OPTIONSm / BYEm / CANCELm / REGISTERm / extension-method extension-method = token Response = Status-Line *( message-header ) CRLF [ message-body ]",
      "ja": "INVITEm =％x49.4E.56.49.54.45。キャップにINVITE ACKM =％x41.43.4B。キャップでACK OPTIONSm =％x4F.50.54.49.4F.4E.53。キャップでOPTIONS BYEm =％x42.59.45。キャップにBYE CANCELm =％x43.41.4E.43.45.4C。キャップのキャンセルREGISTERm =％x52.45.47.49.53.54.45.52。 REGISTERキャップのメソッド= INVITEm / ACKM / OPTIONSm / BYEm / CANCELm / REGISTERm /拡張メソッド拡張メソッド=トークン応答=ステータスライン*（メッセージヘッダー）CRLF [メッセージ本体]"
    },
    {
      "indent": 0,
      "text": "Status-Line = SIP-Version SP Status-Code SP Reason-Phrase CRLF Status-Code = Informational / Redirection / Success / Client-Error / Server-Error / Global-Failure / extension-code extension-code = 3DIGIT Reason-Phrase = *(reserved / unreserved / escaped / UTF8-NONASCII / UTF8-CONT / SP / HTAB)",
      "ja": "ステータスライン= SIP-バージョンSPステータスコードSP理由-フレーズCRLFのステータスコード=情報/リダイレクト/成功/クライアントエラー/サーバーエラー/グローバル・失敗/延長コード延長コード= 3DIGIT理由-フレーズ= *（/ /予約されていない予約エスケープ/ UTF8-NONASCII / UTF8-CONT / SP / HTAB）"
    },
    {
      "indent": 0,
      "text": "Informational = \"100\" ; Trying / \"180\" ; Ringing / \"181\" ; Call Is Being Forwarded / \"182\" ; Queued / \"183\" ; Session Progress",
      "ja": "情報= \"100\"; /「180」しよう。リンギング/「181」。着信/「182」転送されています。 /「183」キューに入れられました。セッションの進捗状況"
    },
    {
      "indent": 0,
      "text": "Success = \"200\" ; OK",
      "ja": "成功= \"200\"; OK"
    },
    {
      "indent": 0,
      "text": "Redirection = \"300\" ; Multiple Choices / \"301\" ; Moved Permanently / \"302\" ; Moved Temporarily / \"305\" ; Use Proxy / \"380\" ; Alternative Service",
      "ja": "リダイレクト= \"300\";複数の選択肢/「301」。 /「302」永久に移動。 /「305」一時的に移動。プロキシ/「380」を使用します。代替サービス"
    },
    {
      "indent": 0,
      "text": "Client-Error = \"400\" ; Bad Request / \"401\" ; Unauthorized / \"402\" ; Payment Required / \"403\" ; Forbidden / \"404\" ; Not Found / \"405\" ; Method Not Allowed / \"406\" ; Not Acceptable / \"407\" ; Proxy Authentication Required / \"408\" ; Request Timeout / \"410\" ; Gone / \"413\" ; Request Entity Too Large / \"414\" ; Request-URI Too Large / \"415\" ; Unsupported Media Type / \"416\" ; Unsupported URI Scheme / \"420\" ; Bad Extension / \"421\" ; Extension Required / \"423\" ; Interval Too Brief / \"480\" ; Temporarily not available / \"481\" ; Call Leg/Transaction Does Not Exist / \"482\" ; Loop Detected / \"483\" ; Too Many Hops / \"484\" ; Address Incomplete / \"485\" ; Ambiguous / \"486\" ; Busy Here / \"487\" ; Request Terminated / \"488\" ; Not Acceptable Here / \"491\" ; Request Pending / \"493\" ; Undecipherable",
      "ja": "クライアントエラー=「400」;不正な要求/「401」。無断/「402」。お支払い/「403」は必須。 / \"404\" 禁断; /「405」が見つかりませんでした。メソッド/「406」許可されていません。受け入れられない/「407」。プロキシ認証が必要/「408」。要求タイムアウト/「410」。 /「413」ゴーン。リクエストエンティティが大きすぎます/「414」。リクエストURIが大きすぎます/「415」。サポートされていないメディアタイプ/「416」。サポートされていないURIスキーム/「420」。悪い拡張/「421」。拡張必須/「423」。 「480」/あまりにも短い間隔。 「481」/一時的に利用できません。脚/トランザクションは、/「482」が存在しない呼び出します。ループ/「483」が検出。あまりにも多くのホップ/「484」。不完全な/「485」に取り組みます。あいまいな/「486」。ビジーここで/「487」。要求/「488」終端。許容できないここで/「491」。保留/「493」を要求します。解読不能"
    },
    {
      "indent": 0,
      "text": "Server-Error = \"500\" ; Internal Server Error / \"501\" ; Not Implemented / \"502\" ; Bad Gateway / \"503\" ; Service Unavailable / \"504\" ; Server Time-out / \"505\" ; SIP Version not supported / \"513\" ; Message Too Large",
      "ja": "サーバーエラー=「500」;内部サーバーエラー/「501」。 /「502」実装されていません。不正なゲートウェイ/「503」。サービスは利用できません/「504」。サーバーのタイムアウト/「505」。 SIPバージョン/「513」をサポートしていません。大きすぎメッセージ"
    },
    {
      "indent": 0,
      "text": "Global-Failure = \"600\" ; Busy Everywhere / \"603\" ; Decline / \"604\" ; Does not exist anywhere / \"606\" ; Not Acceptable",
      "ja": "グローバル・失敗=「600」;ビジーどこでも/「603」。衰退/「604」。 /どこでも「606」は存在しません。受け付けできません"
    },
    {
      "indent": 0,
      "text": "Accept         =  \"Accept\" HCOLON\n                   [ accept-range *(COMMA accept-range) ]\naccept-range   =  media-range *(SEMI accept-param)\nmedia-range    =  ( \"*/*\"\n                  / ( m-type SLASH \"*\" )\n                  / ( m-type SLASH m-subtype )\n                  ) *( SEMI m-parameter )\naccept-param   =  (\"q\" EQUAL qvalue) / generic-param\nqvalue         =  ( \"0\" [ \".\" 0*3DIGIT ] )\n                  / ( \"1\" [ \".\" 0*3(\"0\") ] )\ngeneric-param  =  token [ EQUAL gen-value ]\ngen-value      =  token / host / quoted-string",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Accept-Encoding = \"Accept-Encoding\" HCOLON [ encoding *(COMMA encoding) ] encoding = codings *(SEMI accept-param) codings = content-coding / \"*\" content-coding = token",
      "ja": "受け入れエンコード= \"受け入れるエンコードを\" HCOLON [エンコーディング*（COMMAエンコーディング）]エンコード=コーディングは、*（SEMI受け入れる-PARAM）コーディングは=コンテンツ符号化/ \"*\" =トークンコンテンツコーディング"
    },
    {
      "indent": 0,
      "text": "Accept-Language = \"Accept-Language\" HCOLON [ language *(COMMA language) ] language = language-range *(SEMI accept-param) language-range = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) / \"*\" )",
      "ja": "受け入れる言語= \"受け入れる言語\" HCOLON [言語*（COMMA言語）]言語=言語レンジ*（SEMI受け入れる-PARAM）言語範囲=（（1 * 8ALPHA×（ \" - \" 1 * 8ALPHA））/ \"*\"）"
    },
    {
      "indent": 0,
      "text": "Alert-Info = \"Alert-Info\" HCOLON alert-param *(COMMA alert-param) alert-param = LAQUOT absoluteURI RAQUOT *( SEMI generic-param )",
      "ja": "アラート情報= \"アラート情報\" HCOLONアラートのparam *（COMMA-のparamのアラート）アラートのparam = LAQUOT absoluteURIでRAQUOT *（SEMIジェネリック-PARAM）"
    },
    {
      "indent": 0,
      "text": "Allow = \"Allow\" HCOLON [Method *(COMMA Method)]",
      "ja": "許可= \"許可\" HCOLON [方法*（COMMA方法）]"
    },
    {
      "indent": 0,
      "text": "Authorization = \"Authorization\" HCOLON credentials credentials = (\"Digest\" LWS digest-response) / other-response digest-response = dig-resp *(COMMA dig-resp) dig-resp = username / realm / nonce / digest-uri / dresponse / algorithm / cnonce / opaque / message-qop / nonce-count / auth-param username = \"username\" EQUAL username-value username-value = quoted-string digest-uri = \"uri\" EQUAL LDQUOT digest-uri-value RDQUOT digest-uri-value = rquest-uri ; Equal to request-uri as specified by HTTP/1.1 message-qop = \"qop\" EQUAL qop-value cnonce = \"cnonce\" EQUAL cnonce-value cnonce-value = nonce-value nonce-count = \"nc\" EQUAL nc-value nc-value = 8LHEX dresponse = \"response\" EQUAL request-digest request-digest = LDQUOT 32LHEX RDQUOT auth-param = auth-param-name EQUAL ( token / quoted-string ) auth-param-name = token other-response = auth-scheme LWS auth-param *(COMMA auth-param) auth-scheme = token",
      "ja": "認証= \"認可\" HCOLON資格資格=（ \"ダイジェスト\" LWSダイジェスト応答）/他の応答ダイジェスト・レスポンス=掘る-RESPの*（COMMA掘る-RESP）掘るを-RESP =ユーザ名/領域/ナンス/ダイジェスト-URI / dresponse /アルゴリズム/ cnonce /不透明/メッセージQOP /ナンスカウント/ AUTH-のparamユーザ名= \"ユーザ名\" EQUALのユーザー名と値のユーザ名、値=引用符で囲まれた文字列のダイジェスト-URI = \"URI\" EQUAL LDQUOTダイジェスト-uriの値RDQUOTダイジェスト-URI値= rquest-URI;リクエストURIにHTTP / 1.1メッセージQOP = \"QOP\" EQUAL QOP値cnonce = \"cnonce\" EQUAL cnonce値cnonce値=ノンス値ナンスカウント= \"NC\" EQUAL NC-値NCによって指定されるように等しいです-value = 8LHEX dresponse = \"応答\" EQUAL要求ダイジェスト要求ダイジェスト= LDQUOT 32LHEX RDQUOT AUTH-PARAM = AUTH-PARAM名EQUAL（トークン/引用符で囲まれた文字列）AUTH-PARAM-NAME =トークン他の応答= auth-スキームLWSのAUTH-PARAM *（COMMA AUTH-PARAM）AUTH-スキーム=トークン"
    },
    {
      "indent": 0,
      "text": "Authentication-Info = \"Authentication-Info\" HCOLON ainfo *(COMMA ainfo) ainfo = nextnonce / message-qop / response-auth / cnonce / nonce-count nextnonce = \"nextnonce\" EQUAL nonce-value response-auth = \"rspauth\" EQUAL response-digest response-digest = LDQUOT *LHEX RDQUOT",
      "ja": "認証情報は= \"認証情報\" HCOLON *（COMMA AINFO）AINFO = nextnonce /メッセージQOP /応答-AUTH / cnonce /ナンスカウントnextnonce = \"nextnonce\" EQUALノンス値応答-AUTH = \"rspauth\" EQUAL AINFO応答ダイジェスト応答ダイジェスト= LDQUOT * LHEX RDQUOT"
    },
    {
      "indent": 0,
      "text": "Call-ID = ( \"Call-ID\" / \"i\" ) HCOLON callid callid = word [ \"@\" word ]",
      "ja": "コールID =（ \"コールID\" / \"I\"）HCOLON callid callid =ワード[ \"@\" の単語]"
    },
    {
      "indent": 0,
      "text": "Call-Info = \"Call-Info\" HCOLON info *(COMMA info) info = LAQUOT absoluteURI RAQUOT *( SEMI info-param) info-param = ( \"purpose\" EQUAL ( \"icon\" / \"info\" / \"card\" / token ) ) / generic-param",
      "ja": "コール情報= \"コール情報\" をHCOLON情報*（COMMA情報）情報= LAQUOT absoluteURIでRAQUOT *（SEMI情報-のparam）情報-paramは=（ \"目的\" EQUAL（ \"アイコン\" / \"情報\" / \"カード\" /トークン））/ジェネリック-PARAM"
    },
    {
      "indent": 0,
      "text": "Contact = (\"Contact\" / \"m\" ) HCOLON ( STAR / (contact-param *(COMMA contact-param))) contact-param = (name-addr / addr-spec) *(SEMI contact-params) name-addr = [ display-name ] LAQUOT addr-spec RAQUOT addr-spec = SIP-URI / SIPS-URI / absoluteURI display-name = *(token LWS)/ quoted-string",
      "ja": "連絡先=（ \"連絡先\" / \"M\"）HCOLON（STAR /（接触のparam *（COMMA接触-のparam）））接触のparam =（名前、アドレス/ ADDR-SPEC）*（SEMI接触-のparams）名 - ADDR = [表示名] LAQUOTのADDRスペックRAQUOTのADDRスペック= SIP-URI / SIPS-URI / absoluteURIで表示名= *（トークンLWS）/引用符で囲まれた文字列"
    },
    {
      "indent": 0,
      "text": "contact-params = c-p-q / c-p-expires / contact-extension c-p-q = \"q\" EQUAL qvalue c-p-expires = \"expires\" EQUAL delta-seconds contact-extension = generic-param delta-seconds = 1*DIGIT",
      "ja": "非接触型のparams = C-P-Q / C-P-期限が切れる/コンタクト拡張C-P-Q = \"Q\" EQUALのqvalueの= EQUALデルタ秒の接触延長=ジェネリック-のparamデルタ秒の \"期限が切れる\" = 1 * DIGITのc-pは、有効期限が切れます"
    },
    {
      "indent": 0,
      "text": "Content-Disposition = \"Content-Disposition\" HCOLON disp-type *( SEMI disp-param ) disp-type = \"render\" / \"session\" / \"icon\" / \"alert\" / disp-extension-token",
      "ja": "コンテンツ処分=の \"Content-処分\" HCOLONのDISP型*（SEMI DISP-のparam）DISP型= \"レンダリング\" / \"セッション\" / \"アイコン\" / \"警告\" / DISP-拡張トークン"
    },
    {
      "indent": 0,
      "text": "disp-param = handling-param / generic-param handling-param = \"handling\" EQUAL ( \"optional\" / \"required\" / other-handling ) other-handling = token disp-extension-token = token",
      "ja": "DISP-PARAM =ハンドリング-PARAM /ジェネリック-PARAMハンドリング-PARAM = \"処理\" EQUAL（ \"オプション\" / \"必須\" /他のハンドリング）他のハンドリング=トークンDISP-拡張トークン=トークン"
    },
    {
      "indent": 0,
      "text": "Content-Encoding = ( \"Content-Encoding\" / \"e\" ) HCOLON content-coding *(COMMA content-coding)",
      "ja": "コンテンツエンコーディング=（「コンテンツエンコーディング」/「E」）HCOLON内容コーディング*（COMMAコンテンツコーディング）"
    },
    {
      "indent": 0,
      "text": "Content-Language = \"Content-Language\" HCOLON language-tag *(COMMA language-tag) language-tag = primary-tag *( \"-\" subtag ) primary-tag = 1*8ALPHA subtag = 1*8ALPHA",
      "ja": "コンテンツ言語=の \"Content-言語\" HCOLON言語タグ*（COMMA言語タグ）言語タグ=プライマリータグ*（ \" - \" サブタグ）主要-タグ= 1 * 8ALPHAサブタグ= 1 * 8ALPHA"
    },
    {
      "indent": 0,
      "text": "Content-Length = ( \"Content-Length\" / \"l\" ) HCOLON 1*DIGIT Content-Type = ( \"Content-Type\" / \"c\" ) HCOLON media-type media-type = m-type SLASH m-subtype *(SEMI m-parameter) m-type = discrete-type / composite-type discrete-type = \"text\" / \"image\" / \"audio\" / \"video\" / \"application\" / extension-token composite-type = \"message\" / \"multipart\" / extension-token extension-token = ietf-token / x-token ietf-token = token x-token = \"x-\" token m-subtype = extension-token / iana-token iana-token = token m-parameter = m-attribute EQUAL m-value m-attribute = token m-value = token / quoted-string",
      "ja": "コンテンツ長=（ \"コンテンツ長\" / \"L\"）HCOLON 1 * DIGIT用のContent-Type =（ \"コンテンツタイプ\" / \"C\"）HCOLONメディア型メディアタイプ= M型スラッシュMサブタイプ* （SEMI Mパラメータ）M型=ディスクリート型/複合型は、離散型=「テキスト」/「画像」/「オーディオ」/「ビデオ」/「アプリケーション」/拡張トークン複合型=「メッセージ\"/ \"マルチパート\"/拡張トークン拡張トークン= IETFトークン/ X-トークントークン= IETFトークンXトークン= \"X-\" トークンMサブタイプ=拡張トークン/ IANAトークンIANAトークントークン= M-パラメータ= M-属性EQUALのm値m-属性=トークンm値=トークン/引用符で囲まれた文字列"
    },
    {
      "indent": 0,
      "text": "CSeq = \"CSeq\" HCOLON 1*DIGIT LWS Method",
      "ja": "CSeq = \"のCSeq\" HCOLON 1 * DIGIT LWS方法"
    },
    {
      "indent": 0,
      "text": "Date = \"Date\" HCOLON SIP-date SIP-date = rfc1123-date rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\" date1 = 2DIGIT SP month SP 4DIGIT ; day month year (e.g., 02 Jun 1982) time = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT ; 00:00:00 - 23:59:59 wkday = \"Mon\" / \"Tue\" / \"Wed\" / \"Thu\" / \"Fri\" / \"Sat\" / \"Sun\" month = \"Jan\" / \"Feb\" / \"Mar\" / \"Apr\" / \"May\" / \"Jun\" / \"Jul\" / \"Aug\" / \"Sep\" / \"Oct\" / \"Nov\" / \"Dec\"",
      "ja": "日付= \"日付\" HCOLON SIP-日付SIP-日= RFC1123-日RFC1123-日=平日 \"\" SP日付1のSP時間SP \"GMT\" 日付1 = 2DIGIT SP月SP 4桁。日月年（例えば、1982年6月2日）時間= 2DIGIT \"：\" 2DIGIT \"：\" 2DIGIT。午前〇時00分00秒 -  23時59分59秒平日=「月」/「火」/「水」/「木」/「金」/「土」/「日」月=「月」/「2月」/ 「月」/「4月」/「月」/「6月」/「7月」/「8月」/「9月」/「10月」/「11月」/「12月」"
    },
    {
      "indent": 0,
      "text": "Error-Info = \"Error-Info\" HCOLON error-uri *(COMMA error-uri) error-uri = LAQUOT absoluteURI RAQUOT *( SEMI generic-param )",
      "ja": "エラー情報= \"エラー情報\" HCOLONエラー-URI *（COMMAエラー-URI）エラー-URI = LAQUOT absoluteURIでRAQUOT *（SEMIジェネリック-PARAM）"
    },
    {
      "indent": 0,
      "text": "Expires = \"Expires\" HCOLON delta-seconds From = ( \"From\" / \"f\" ) HCOLON from-spec from-spec = ( name-addr / addr-spec ) *( SEMI from-param ) from-param = tag-param / generic-param tag-param = \"tag\" EQUAL token",
      "ja": "=から-PARAM =タグ - からスペックからスペック=（ \"から\" / \"F\"）HCOLON =（名前、アドレス/ ADDR-SPEC）*（から-PARAM SEMI）からHCOLONデルタ秒 \"有効期限\" 有効期限PARAM /ジェネリック-paramタグ-のparam = \"タグ\" EQUALトークン"
    },
    {
      "indent": 0,
      "text": "In-Reply-To = \"In-Reply-To\" HCOLON callid *(COMMA callid)",
      "ja": "イン返信先=「イン返信先」HCOLONのcallid *（COMMA callid）"
    },
    {
      "indent": 0,
      "text": "Max-Forwards = \"Max-Forwards\" HCOLON 1*DIGIT",
      "ja": "マックス・フォワード=「マックス・フォワード」HCOLON 1 * DIGIT"
    },
    {
      "indent": 0,
      "text": "MIME-Version = \"MIME-Version\" HCOLON 1*DIGIT \".\" 1*DIGIT",
      "ja": "MIME-バージョン= \"MIME-バージョン\" HCOLON 1 * DIGIT \"\" 1 * DIGIT"
    },
    {
      "indent": 0,
      "text": "Min-Expires = \"Min-Expires\" HCOLON delta-seconds",
      "ja": "ミンは、有効期限= HCOLONデルタ秒「Minは、有効期限」"
    },
    {
      "indent": 0,
      "text": "Organization = \"Organization\" HCOLON [TEXT-UTF8-TRIM]",
      "ja": "組織= \"組織\" HCOLON [TEXT-UTF8-TRIM]"
    },
    {
      "indent": 0,
      "text": "Priority = \"Priority\" HCOLON priority-value priority-value = \"emergency\" / \"urgent\" / \"normal\" / \"non-urgent\" / other-priority other-priority = token",
      "ja": "優先=「優先順位」HCOLON優先値の優先順位値=「緊急」/「緊急」/「ノーマル」/「非緊急」/他の優先順位の他の優先度=トークン"
    },
    {
      "indent": 0,
      "text": "Proxy-Authenticate = \"Proxy-Authenticate\" HCOLON challenge challenge = (\"Digest\" LWS digest-cln *(COMMA digest-cln)) / other-challenge other-challenge = auth-scheme LWS auth-param *(COMMA auth-param) digest-cln = realm / domain / nonce / opaque / stale / algorithm / qop-options / auth-param realm = \"realm\" EQUAL realm-value realm-value = quoted-string domain = \"domain\" EQUAL LDQUOT URI *( 1*SP URI ) RDQUOT URI = absoluteURI / abs-path nonce = \"nonce\" EQUAL nonce-value nonce-value = quoted-string opaque = \"opaque\" EQUAL quoted-string stale = \"stale\" EQUAL ( \"true\" / \"false\" ) algorithm = \"algorithm\" EQUAL ( \"MD5\" / \"MD5-sess\" / token ) qop-options = \"qop\" EQUAL LDQUOT qop-value *(\",\" qop-value) RDQUOT qop-value = \"auth\" / \"auth-int\" / token",
      "ja": "プロキシ認証= \"プロキシ認証\" HCOLONチャレンジチャレンジ= /その他のチャレンジ他-挑戦=のauth-スキームLWSのauth-のparam *（COMMA払い-PARAM（ \"ダイジェスト\" LWSは、*（COMMAダイジェスト-CLN） -  CLNダイジェスト） ）ダイジェスト-CLN =、レルム/ドメイン/ナンス/不透明/古い/アルゴリズム/ qopの-オプション/ AUTH-PARAMレルム= \"王国\" EQUALレルム値レルム値=引用符で囲まれた文字列のドメイン= \"ドメイン\" EQUAL LDQUOT URI *（ 1 * SP URI）RDQUOT URI = absoluteURIで/ ABS経路ナンス=「ナンス」EQUALナンス値ノンス値=引用符で囲まれた文字列不透明=「不透明」EQUALが引用文字列失効=「陳腐」EQUAL（「真」/ \"偽 \"）アルゴリズム= \"アルゴリズム\" EQUAL（ \"MD5\"/ \"MD5-のSES\"/トークン）QOP-オプション= \"QOP\" EQUAL LDQUOTのQOP値*（\"、 \"QOP値）RDQUOTのQOP値=\" 認証「/ \"のauth-int型\" /トークン"
    },
    {
      "indent": 0,
      "text": "Proxy-Authorization = \"Proxy-Authorization\" HCOLON credentials",
      "ja": "プロキシ認証=「プロキシ認証」HCOLON資格"
    },
    {
      "indent": 0,
      "text": "Proxy-Require = \"Proxy-Require\" HCOLON option-tag *(COMMA option-tag) option-tag = token",
      "ja": "=「プロキシ要求する」HCOLONオプションタグ*（COMMAオプションタグ）トークンオプションタグ=プロキシは、要求します"
    },
    {
      "indent": 0,
      "text": "Record-Route = \"Record-Route\" HCOLON rec-route *(COMMA rec-route) rec-route = name-addr *( SEMI rr-param ) rr-param = generic-param",
      "ja": "レコードルート= \"レコード・ルート\" HCOLONのREC-ルート*（COMMA REC-ルート）REC-ルート=名前-addrには*（SEMI-RRのparam）RR-PARAM =ジェネリック-PARAM"
    },
    {
      "indent": 0,
      "text": "Reply-To = \"Reply-To\" HCOLON rplyto-spec rplyto-spec = ( name-addr / addr-spec ) *( SEMI rplyto-param ) rplyto-param = generic-param Require = \"Require\" HCOLON option-tag *(COMMA option-tag)",
      "ja": "返信先= \"返信先\" HCOLON rplytoスペックrplytoスペック=（名前、アドレス/ ADDR-SPEC）*（SEMI rplyto-のparam）rplyto-PARAM =ジェネリック-paramは必要= HCOLONオプションタグを \"必要\" * （COMMAオプションタグ）"
    },
    {
      "indent": 0,
      "text": "Retry-After = \"Retry-After\" HCOLON delta-seconds [ comment ] *( SEMI retry-param )",
      "ja": "リトライ後= \"再試行-後\" HCOLONデルタ秒[コメント] *（SEMIリトライのparam）"
    },
    {
      "indent": 0,
      "text": "retry-param = (\"duration\" EQUAL delta-seconds) / generic-param",
      "ja": "リトライ-PARAM =（ \"期間\" EQUALデルタ秒）/ジェネリック-PARAM"
    },
    {
      "indent": 0,
      "text": "Route = \"Route\" HCOLON route-param *(COMMA route-param) route-param = name-addr *( SEMI rr-param )",
      "ja": "ルート= \"ルート\" HCOLONルート-のparam *（COMMAルート-PARAM）ルートのparam =名前-addrには*（SEMI RR-PARAM）"
    },
    {
      "indent": 0,
      "text": "Server = \"Server\" HCOLON server-val *(LWS server-val) server-val = product / comment product = token [SLASH product-version] product-version = token",
      "ja": "サーバー= \"サーバー\" HCOLONサーバ-VAL *（LWSサーバー-val）で、サーバーのval =製品/コメント積=トークン[SLASH製品バージョン]製品バージョン=トークン"
    },
    {
      "indent": 0,
      "text": "Subject = ( \"Subject\" / \"s\" ) HCOLON [TEXT-UTF8-TRIM]",
      "ja": "被験者=（ \"件名\" / \"S\"）HCOLON [TEXT-UTF8-TRIM]"
    },
    {
      "indent": 0,
      "text": "Supported = ( \"Supported\" / \"k\" ) HCOLON [option-tag *(COMMA option-tag)]",
      "ja": "サポート=（ \"サポート\" / \"K\"）HCOLON [オプションタグ*（COMMAオプションタグ）]"
    },
    {
      "indent": 0,
      "text": "Timestamp = \"Timestamp\" HCOLON 1*(DIGIT) [ \".\" *(DIGIT) ] [ LWS delay ] delay = *(DIGIT) [ \".\" *(DIGIT) ]",
      "ja": "タイムスタンプ= \"タイムスタンプ\" HCOLON 1 *（DIGIT） \"\" *（DIGIT）] [LWS遅延】遅延= *（DIGIT） \"\" *（DIGIT）]"
    },
    {
      "indent": 0,
      "text": "To = ( \"To\" / \"t\" ) HCOLON ( name-addr / addr-spec ) *( SEMI to-param ) to-param = tag-param / generic-param",
      "ja": "=（ \"へ\" / \"T\"）HCOLON（名前-addrに/ ADDR-SPEC）*（SEMIに-PARAM）に-PARAM =タグのparam /ジェネリック-PARAMへ"
    },
    {
      "indent": 0,
      "text": "Unsupported = \"Unsupported\" HCOLON option-tag *(COMMA option-tag) User-Agent = \"User-Agent\" HCOLON server-val *(LWS server-val)",
      "ja": "サポートされていない= \"サポートされていない\" HCOLONオプションタグ*（COMMAオプションタグ）のUser-Agent = \"のUser-Agent\" HCOLONサーバ-VAL *（LWSサーバー-VAL）"
    },
    {
      "indent": 0,
      "text": "Via = ( \"Via\" / \"v\" ) HCOLON via-parm *(COMMA via-parm) via-parm = sent-protocol LWS sent-by *( SEMI via-params ) via-params = via-ttl / via-maddr / via-received / via-branch / via-extension via-ttl = \"ttl\" EQUAL ttl via-maddr = \"maddr\" EQUAL host via-received = \"received\" EQUAL (IPv4address / IPv6address) via-branch = \"branch\" EQUAL token via-extension = generic-param sent-protocol = protocol-name SLASH protocol-version SLASH transport protocol-name = \"SIP\" / token protocol-version = token transport = \"UDP\" / \"TCP\" / \"TLS\" / \"SCTP\" / other-transport sent-by = host [ COLON port ] ttl = 1*3DIGIT ; 0 to 255",
      "ja": "送信されたバイ*（VIA-paramsはSEMI）を介し-paramsは=介し-TTL / via- =（ \"を介して\" / \"V\"）HCOLONビアPARM *（ビアPARM COMMA）を介してビアPARM =送信プロトコルLWS = =「ブランチを介して分岐EQUAL（IPv4Addressを/ IPv6address）を \"受信\" を介して、受信MADDR /ビア・ブランチ/ビア拡張/受信ビア-TTL = \"TTL\" EQUAL TTLビアMADDR = \"MADDR\" EQUALホスト「EQUALトークンを経由して、拡張子=ジェネリック-PARAM送られたプロトコル=プロトコル名SLASHプロトコルバージョンSLASHトランスポートプロトコル名= \"SIP\" /トークン・プロトコル・バージョン=トークン輸送= \"UDP\" / \"TCP\" / \"TLS\" / \"SCTP\" /他の輸送送信バイ=ホスト[大腸ポート] TTL = 1 * 3DIGIT。 0から255"
    },
    {
      "indent": 0,
      "text": "Warning = \"Warning\" HCOLON warning-value *(COMMA warning-value) warning-value = warn-code SP warn-agent SP warn-text warn-code = 3DIGIT warn-agent = hostport / pseudonym ; the name or pseudonym of the server adding ; the Warning header, for use in debugging warn-text = quoted-string pseudonym = token",
      "ja": "警告=「警告」HCOLON警告値*（COMMA警告値）警告値= SP警告エージェントSP警告テキスト警告コードコード警告=警告エージェント3DIGIT =のHostPort /仮名と、追加するサーバーの名前または仮名。トークン警告テキスト=引用符で囲まれた文字列の仮名を=デバッグで使用するための警告ヘッダ、"
    },
    {
      "indent": 0,
      "text": "WWW-Authenticate = \"WWW-Authenticate\" HCOLON challenge",
      "ja": "WWW認証=「WWW認証」HCOLONチャレンジ"
    },
    {
      "indent": 0,
      "text": "extension-header = header-name HCOLON header-value header-name = token header-value = *(TEXT-UTF8char / UTF8-CONT / LWS) message-body = *OCTET",
      "ja": "拡張ヘッダー=ヘッダ名HCOLONヘッダ値ヘッダ名=トークンヘッダ値= *（TEXT-UTF8char / UTF8-CONT / LWS）メッセージ本体= * OCTET"
    },
    {
      "indent": 0,
      "text": "26 Security Considerations: Threat Model and Security Usage Recommendations",
      "ja": "26のセキュリティの考慮：脅威モデルとセキュリティの使用に関する推奨事項"
    },
    {
      "indent": 3,
      "text": "SIP is not an easy protocol to secure. Its use of intermediaries, its multi-faceted trust relationships, its expected usage between elements with no trust at all, and its user-to-user operation make security far from trivial. Security solutions are needed that are deployable today, without extensive coordination, in a wide variety of environments and usages. In order to meet these diverse needs, several distinct mechanisms applicable to different aspects and usages of SIP will be required.",
      "ja": "SIPは、確保するための簡単なプロトコルではありません。仲介のその使用、その多面的な信頼関係は、まったく信頼と要素間の予想される使用、およびそのユーザ・ユーザの​​操作は簡単にはほど遠いセキュリティを作ります。セキュリティソリューションは、環境や用途に幅広く、大規模な調整なし、今日の展開可能であることが必要とされます。これらの多様なニーズを満たすために、SIPの異なる態様及び用途に適用可能ないくつかの別個のメカニズムが必要となります。"
    },
    {
      "indent": 3,
      "text": "Note that the security of SIP signaling itself has no bearing on the security of protocols used in concert with SIP such as RTP, or with the security implications of any specific bodies SIP might carry (although MIME security plays a substantial role in securing SIP). Any media associated with a session can be encrypted end-to-end independently of any associated SIP signaling. Media encryption is outside the scope of this document.",
      "ja": "自身をSIPシグナリングのセキュリティは、RTPとして、又は（MIMEセキュリティがSIPを確保する上で重要な役割を果たしているが）SIPが運ぶ可能性のある特定の体のセキュリティ含意を有するSIPと協調して使用されるプロトコルのセキュリティにはベアリングを有していないことに留意されたいです。セッションに関連付けられた任意のメディアは、独立して、任意の関連したSIPシグナリングのエンドツーエンド暗号化することができます。メディア暗号化は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "The considerations that follow first examine a set of classic threat models that broadly identify the security needs of SIP. The set of security services required to address these threats is then detailed, followed by an explanation of several security mechanisms that can be used to provide these services. Next, the requirements for implementers of SIP are enumerated, along with exemplary deployments in which these security mechanisms could be used to improve the security of SIP. Some notes on privacy conclude this section.",
      "ja": "最初に従うの考慮事項が広くSIPのセキュリティニーズを特定し、古典的な脅威モデルのセットを調べます。これらの脅威に対処するために必要なセキュリティサービスのセットは、これらのサービスを提供するために使用できるいくつかのセキュリティメカニズムの説明に続いて、その後、詳細です。次に、SIPを実装するための要件は、これらのセキュリティメカニズムは、SIPのセキュリティを改善するために使用され得る例示的な展開と共に、列挙されています。プライバシーに関する注意は、このセクションを終えます。"
    },
    {
      "indent": 0,
      "text": "26.1 Attacks and Threat Models",
      "section_title": true,
      "ja": "26.1攻撃と脅威モデル"
    },
    {
      "indent": 3,
      "text": "This section details some threats that should be common to most deployments of SIP. These threats have been chosen specifically to illustrate each of the security services that SIP requires.",
      "ja": "このセクションでは、SIPのほとんどの展開に共通である必要があり、いくつかの脅威を詳しく説明します。これらの脅威は、SIPに必要なセキュリティサービスのそれぞれを説明するために、具体的に選択されています。"
    },
    {
      "indent": 3,
      "text": "The following examples by no means provide an exhaustive list of the threats against SIP; rather, these are \"classic\" threats that demonstrate the need for particular security services that can potentially prevent whole categories of threats.",
      "ja": "決して次の例では、SIPに対する脅威の完全なリストを提供すること。むしろ、これらは潜在的な脅威の全体のカテゴリを防ぐことができ、特定のセキュリティサービスの必要性を実証し、「古典的」な脅威です。"
    },
    {
      "indent": 3,
      "text": "These attacks assume an environment in which attackers can potentially read any packet on the network - it is anticipated that SIP will frequently be used on the public Internet. Attackers on the network may be able to modify packets (perhaps at some compromised intermediary). Attackers may wish to steal services, eavesdrop on communications, or disrupt sessions.",
      "ja": "これらの攻撃は、攻撃者が潜在的にネットワーク上のすべてのパケットを読み取ることができるような環境を想定し -  SIPが頻繁に公共のインターネット上で使用されることが予想されます。ネットワーク上の攻撃者は、（おそらく、いくつかの妥協の中間で）パケットを変更することができるかもしれません。攻撃者は、サービスを盗むしたい通信を盗聴、あるいはセッションを中断される場合があります。"
    },
    {
      "indent": 0,
      "text": "26.1.1 Registration Hijacking",
      "section_title": true,
      "ja": "26.1.1登録ハイジャック"
    },
    {
      "indent": 3,
      "text": "The SIP registration mechanism allows a user agent to identify itself to a registrar as a device at which a user (designated by an address of record) is located. A registrar assesses the identity asserted in the From header field of a REGISTER message to determine whether this request can modify the contact addresses associated with the address-of-record in the To header field. While these two fields are frequently the same, there are many valid deployments in which a third-party may register contacts on a user's behalf.",
      "ja": "SIP登録機構は、ユーザエージェントは（レコードのアドレスで指定される）、ユーザが位置するデバイスとしてレジストラに対して自身を識別することができます。レジストラは、この要求は、アドレス・オブ・レコードヘッダのフィールドに関連付けられた連絡先を変更することができるかどうかを決定するためにREGISTERメッセージのFromヘッダフィールドにアサートされたアイデンティティを評価します。これら2つのフィールドが頻繁に同じですが、サードパーティがユーザーに代わって連絡先を登録している多くの有効な展開があります。"
    },
    {
      "indent": 3,
      "text": "The From header field of a SIP request, however, can be modified arbitrarily by the owner of a UA, and this opens the door to malicious registrations. An attacker that successfully impersonates a party authorized to change contacts associated with an address-of-record could, for example, de-register all existing contacts for a URI and then register their own device as the appropriate contact address, thereby directing all requests for the affected user to the attacker's device.",
      "ja": "SIPリクエストのヘッダフィールドから、しかし、UAの所有者によって任意に変更することができ、これは、悪意のある登録への扉を開きます。成功したパーティを偽装攻撃者は、それによってのためにすべての要求を向ける、アドレス・オブ・レコードに関連付けられている連絡先は、例えば、URIのためのすべての既存の連絡先を登録解除し、適切な連絡先として、自分のデバイスを登録することができ変更する権限攻撃者のデバイスへの影響を受けるユーザー。"
    },
    {
      "indent": 3,
      "text": "This threat belongs to a family of threats that rely on the absence of cryptographic assurance of a request's originator. Any SIP UAS that represents a valuable service (a gateway that interworks SIP requests with traditional telephone calls, for example) might want to control access to its resources by authenticating requests that it receives. Even end-user UAs, for example SIP phones, have an interest in ascertaining the identities of originators of requests.",
      "ja": "この脅威は、要求の発信元の暗号保証の有無に依存している脅威のファミリーに属します。貴重なサービス（例えば、従来の電話通話でSIPリクエストを連係動作ゲートウェイ）を表す任意のSIP UASは受け取った要求を認証することによって、そのリソースへのアクセスを制御することができます。例のSIP電話機用であっても、エンドユーザーのUAは、リクエストの発信元の身元を確認することに関心を持っています。"
    },
    {
      "indent": 3,
      "text": "This threat demonstrates the need for security services that enable SIP entities to authenticate the originators of requests.",
      "ja": "この脅威は、要求の発信元を認証するためにSIPエンティティを可能にするセキュリティサービスの必要性を示しています。"
    },
    {
      "indent": 0,
      "text": "26.1.2 Impersonating a Server",
      "section_title": true,
      "ja": "26.1.2サーバーになりすまします"
    },
    {
      "indent": 3,
      "text": "The domain to which a request is destined is generally specified in the Request-URI. UAs commonly contact a server in this domain directly in order to deliver a request. However, there is always a possibility that an attacker could impersonate the remote server, and that the UA's request could be intercepted by some other party.",
      "ja": "要求が宛先とされたドメインは、一般のRequest-URIで指定されています。 UAは、一般的に直接リクエストをお届けするために、このドメイン内のサーバーにお問い合わせください。しかし、攻撃者がリモートサーバになりすまして、UAの要求が他の当事者によって傍受される可能性があり、そのことができる可能性は常にあります。"
    },
    {
      "indent": 3,
      "text": "For example, consider a case in which a redirect server at one domain, chicago.com, impersonates a redirect server at another domain, biloxi.com. A user agent sends a request to biloxi.com, but the redirect server at chicago.com answers with a forged response that has appropriate SIP header fields for a response from biloxi.com. The forged contact addresses in the redirection response could direct the originating UA to inappropriate or insecure resources, or simply prevent requests for biloxi.com from succeeding.",
      "ja": "例えば、リダイレクトサーバは、1つのドメイン、chicago.comで、別のドメイン、biloxi.comにリダイレクトサーバーを偽装した場合を考えます。ユーザエージェントはbiloxi.comにリクエストを送信するが、biloxi.comからの応答を適切なSIPヘッダフィールドを持つ偽造応答とchicago.com回答にリダイレクトサーバ。リダイレクト応答の偽造のコンタクトアドレスが不適切または安全でないリソースに発信さUAを直接、または単に続くからbiloxi.comの要求を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "This family of threats has a vast membership, many of which are critical. As a converse to the registration hijacking threat, consider the case in which a registration sent to biloxi.com is intercepted by chicago.com, which replies to the intercepted registration with a forged 301 (Moved Permanently) response. This response might seem to come from biloxi.com yet designate chicago.com as the appropriate registrar. All future REGISTER requests from the originating UA would then go to chicago.com.",
      "ja": "脅威のこのファミリーは、その多くが極めて重要である、広大なメンバーシップを持っています。登録ハイジャックの脅威に逆として、偽造301（恒久的に移動）応答で傍受登録に応答biloxi.comに送信登録がchicago.comによって遮断された場合を考えます。この応答はbiloxi.comから来るまだ適切なレジストラとしてchicago.comを指定するように見えるかもしれません。元のUAからの将来のすべてのREGISTER要求は、その後chicago.comに行くだろう。"
    },
    {
      "indent": 3,
      "text": "Prevention of this threat requires a means by which UAs can authenticate the servers to whom they send requests.",
      "ja": "この脅威の防止は、UAが、彼らが要求を送信する先のサーバを認証することができる手段が必要です。"
    },
    {
      "indent": 0,
      "text": "26.1.3 Tampering with Message Bodies",
      "section_title": true,
      "ja": "26.1.3メッセージ本文が改ざん"
    },
    {
      "indent": 3,
      "text": "As a matter of course, SIP UAs route requests through trusted proxy servers. Regardless of how that trust is established (authentication of proxies is discussed elsewhere in this section), a UA may trust a proxy server to route a request, but not to inspect or possibly modify the bodies contained in that request.",
      "ja": "当然のこととして、信頼されたプロキシサーバー経由でSIP UAはルート要求。かかわらず、その信頼が確立された方法の（プロキシの認証が他の場所で、このセクションで説明されている）、UAは、ルートへの要求をプロキシサーバを信頼することができるが、検査又はおそらくその要求に含まれるボディを変更しません。"
    },
    {
      "indent": 3,
      "text": "Consider a UA that is using SIP message bodies to communicate session encryption keys for a media session. Although it trusts the proxy server of the domain it is contacting to deliver signaling properly, it may not want the administrators of that domain to be capable of decrypting any subsequent media session. Worse yet, if the proxy server were actively malicious, it could modify the session key, either acting as a man-in-the-middle, or perhaps changing the security characteristics requested by the originating UA.",
      "ja": "メディアセッションのためのセッションの暗号化キーを通信するSIPメッセージボディを使用しているUAを考えてみましょう。適切にシグナリングを提供するために接触しているドメインのプロキシサーバーを信頼しますが、それは、そのドメインの管理者は、後続のメディアセッションを復号化することができるようにしたくない場合があります。プロキシサーバーを積極的に悪意のあるた場合はさらに悪いことには、セッションキーを変更する可能性のどちらかとして働くのman-in-the-middle、またはおそらく元のUAによって要求されたセキュリティ特性を変更します。"
    },
    {
      "indent": 3,
      "text": "This family of threats applies not only to session keys, but to most conceivable forms of content carried end-to-end in SIP. These might include MIME bodies that should be rendered to the user, SDP, or encapsulated telephony signals, among others. Attackers might attempt to modify SDP bodies, for example, in order to point RTP media streams to a wiretapping device in order to eavesdrop on subsequent voice communications.",
      "ja": "脅威のこのファミリは、セッション鍵に、しかし、SIPにエンドツーエンドを実施し、コンテンツの中で最も考えられるの形にするだけでなく適用されます。これらは、とりわけ、MIMEユーザにレンダリングされるべき体、SDP、またはカプセル化された電話信号を含み得ます。攻撃者は、その後の音声通信を傍受するために盗聴装置にRTPメディアストリームを指し示すために、例えば、SDPボディを変更しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Also note that some header fields in SIP are meaningful end-to-end, for example, Subject. UAs might be protective of these header fields as well as bodies (a malicious intermediary changing the Subject header field might make an important request appear to be spam, for example). However, since many header fields are legitimately inspected or altered by proxy servers as a request is routed, not all header fields should be secured end-to-end.",
      "ja": "また、被験体、例えば、SIPにおけるいくつかのヘッダーフィールドは、意味のあるエンド・ツー・エンドであることに注意。 UAはこれらのヘッダフィールドだけでなく、体の防御であるかもしれない（重要な要求を行う可能性がある件名ヘッダフィールドを変更する悪質な仲介は、たとえば、スパムのように見えます）。多くのヘッダフィールドが合法的検査又は要求がルーティングされるプロキシサーバによって変更されているので、全てのヘッダフィールドは、エンドツーエンドを確保しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For these reasons, the UA might want to secure SIP message bodies, and in some limited cases header fields, end-to-end. The security services required for bodies include confidentiality, integrity, and authentication. These end-to-end services should be independent of the means used to secure interactions with intermediaries such as proxy servers.",
      "ja": "これらの理由から、UAは、SIPメッセージボディを確保したい場合があります、そして、いくつかの限られた場合には、エンド・ツー・エンドのフィールドをヘッダー。体に必要なセキュリティサービスは、機密性、完全性、および認証が含まれます。これらのエンド・ツー・エンドのサービスは、プロキシサーバなどの仲介者との相互作用を確保するために使用される手段の独立していなければなりません。"
    },
    {
      "indent": 0,
      "text": "26.1.4 Tearing Down Sessions",
      "section_title": true,
      "ja": "26.1.4セッションを切断"
    },
    {
      "indent": 3,
      "text": "Once a dialog has been established by initial messaging, subsequent requests can be sent that modify the state of the dialog and/or session. It is critical that principals in a session can be certain that such requests are not forged by attackers.",
      "ja": "ダイアログが最初のメッセージングによって確立された後、後続の要求は、ダイアログおよび/またはセッションの状態を変更すること送信することができます。セッションのプリンシパルは、そのような要求は、攻撃者によって偽造されていないことを確信できることが重要です。"
    },
    {
      "indent": 3,
      "text": "Consider a case in which a third-party attacker captures some initial messages in a dialog shared by two parties in order to learn the parameters of the session (To tag, From tag, and so forth) and then inserts a BYE request into the session. The attacker could opt to forge the request such that it seemed to come from either participant. Once the BYE is received by its target, the session will be torn down prematurely.",
      "ja": "サードパーティの攻撃者が（タグから、タグに、など）セッションのパラメータを学ぶために両当事者が共有するダイアログでいくつかの初期のメッセージをキャプチャした場合を考えてみた後、セッションにBYE要求を挿入。攻撃者は、いずれかの参加者から来るように見えたというような要求を偽造することを選ぶことができます。 BYEは、そのターゲットによって受信されると、セッションが途中で解体されます。"
    },
    {
      "indent": 3,
      "text": "Similar mid-session threats include the transmission of forged re-INVITEs that alter the session (possibly to reduce session security or redirect media streams as part of a wiretapping attack).",
      "ja": "同様の中間セッションの脅威は、（おそらくセッションセキュリティを低下させるか、盗聴攻撃の一部として、メディアストリームをリダイレクトするために）セッションを変更鍛造再度のINVITEの送信を含みます。"
    },
    {
      "indent": 3,
      "text": "The most effective countermeasure to this threat is the authentication of the sender of the BYE. In this instance, the recipient needs only know that the BYE came from the same party with whom the corresponding dialog was established (as opposed to ascertaining the absolute identity of the sender). Also, if the attacker is unable to learn the parameters of the session due to confidentiality, it would not be possible to forge the BYE. However, some intermediaries (like proxy servers) will need to inspect those parameters as the session is established.",
      "ja": "この脅威に最も効果的な対策がBYEの送信者の認証です。この例では、受信者のみがBYEが対応するダイアログが（送信者の絶対的なアイデンティティを確かめると対照的に）が設立された人と同じ党から来たことを知っている必要があります。攻撃者が機密保持のためにセッションのパラメータを知ることができない場合にも、BYEを偽造することはできません。ただし、（プロキシサーバのような）いくつかの仲介は、セッションが確立されると、これらのパラメータを検査する必要があります。"
    },
    {
      "indent": 0,
      "text": "26.1.5 Denial of Service and Amplification",
      "section_title": true,
      "ja": "サービスおよび増幅の26.1.5拒否"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks focus on rendering a particular network element unavailable, usually by directing an excessive amount of network traffic at its interfaces. A distributed denial-of-service attack allows one network user to cause multiple network hosts to flood a target host with a large amount of network traffic.",
      "ja": "DoS攻撃は、通常、その界面でのネットワークトラフィックの過剰な量を向けることにより、利用できない特定のネットワーク要素のレンダリングに焦点を当てます。分散型サービス拒否攻撃は、一つのネットワークユーザーが複数のネットワークホストがネットワークトラフィック量の多いターゲットホストをあふれさせることができます。"
    },
    {
      "indent": 3,
      "text": "In many architectures, SIP proxy servers face the public Internet in order to accept requests from worldwide IP endpoints. SIP creates a number of potential opportunities for distributed denial-of-service attacks that must be recognized and addressed by the implementers and operators of SIP systems.",
      "ja": "多くのアーキテクチャでは、SIPプロキシサーバは、世界中のIPエンドポイントからの要求を受け入れるために公共のインターネットに直面しています。 SIPは、SIPシステムの実装およびオペレータによって認識され、対処されなければならない分散型サービス妨害（DoS）攻撃の潜在的な機会の数を作成します。"
    },
    {
      "indent": 3,
      "text": "Attackers can create bogus requests that contain a falsified source IP address and a corresponding Via header field that identify a targeted host as the originator of the request and then send this request to a large number of SIP network elements, thereby using hapless SIP UAs or proxies to generate denial-of-service traffic aimed at the target.",
      "ja": "攻撃者は、偽造送​​信元IPアドレスを含む偽の要求を作成し、要求の発信元として、ターゲットホストを識別するヘッダフィールドを介して対応すると、それによって不運のSIPのUAまたはプロキシを使用して、SIPネットワーク要素の多数にこの要求を送信することができます目標に向けたサービス拒否トラフィックを生成します。"
    },
    {
      "indent": 3,
      "text": "Similarly, attackers might use falsified Route header field values in a request that identify the target host and then send such messages to forking proxies that will amplify messaging sent to the target.",
      "ja": "同様に、攻撃者はターゲットホストを特定し、ターゲットに送信されたメッセージを増幅するプロキシをフォークにそのようなメッセージを送信要求に改ざんRouteヘッダーフィールド値を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Record-Route could be used to similar effect when the attacker is certain that the SIP dialog initiated by the request will result in numerous transactions originating in the backwards direction.",
      "ja": "攻撃者は、要求によって開始SIPダイアログが後方方向に由来する多数の取引をもたらすことが確実である場合レコードルートは、同様の効果を使用することができます。"
    },
    {
      "indent": 3,
      "text": "A number of denial-of-service attacks open up if REGISTER requests are not properly authenticated and authorized by registrars. Attackers could de-register some or all users in an administrative domain, thereby preventing these users from being invited to new sessions. An attacker could also register a large number of contacts designating the same host for a given address-of-record in order to use the registrar and any associated proxy servers as amplifiers in a denial-of-service attack. Attackers might also attempt to deplete available memory and disk resources of a registrar by registering huge numbers of bindings.",
      "ja": "REGISTERリクエストが適切に認証され、レジストラが許可されていない場合は、サービス拒否攻撃の数が開きます。攻撃者はこれにより、新しいセッションに招待されることから、これらのユーザーを防止、管理ドメイン内の一部またはすべてのユーザーを登録解除できます。攻撃者はまた、サービス拒否攻撃に増幅器などのレジストラおよび関連するプロキシサーバを使用するために与えられたアドレス・オブ・レコードの同じホストを指定する多数のコンタクトを登録することができます。攻撃者はまた、バインディングの膨大な数を登録することにより、レジストラの使用可能なメモリとディスクリソースを枯渇しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "The use of multicast to transmit SIP requests can greatly increase the potential for denial-of-service attacks.",
      "ja": "SIPリクエストを送信するために、マルチキャストの使用が大幅にサービス拒否攻撃の可能性を高めることができます。"
    },
    {
      "indent": 3,
      "text": "These problems demonstrate a general need to define architectures that minimize the risks of denial-of-service, and the need to be mindful in recommendations for security mechanisms of this class of attacks.",
      "ja": "これらの問題は、サービス拒否のリスクを最小化アーキテクチャを定義する一般的な必要性、および攻撃のこのクラスのセキュリティメカニズムのための勧告に留意する必要があることを示しています。"
    },
    {
      "indent": 0,
      "text": "26.2 Security Mechanisms",
      "section_title": true,
      "ja": "26.2セキュリティメカニズム"
    },
    {
      "indent": 3,
      "text": "From the threats described above, we gather that the fundamental security services required for the SIP protocol are: preserving the confidentiality and integrity of messaging, preventing replay attacks or message spoofing, providing for the authentication and privacy of the participants in a session, and preventing denial-of-service attacks. Bodies within SIP messages separately require the security services of confidentiality, integrity, and authentication.",
      "ja": "、メッセージングの機密性と完全性を維持し、リプレイ攻撃やメッセージのなりすましを防止すること、セッションの参加者の認証とプライバシーのために提供し、防止：上記の脅威から、我々は、SIPプロトコルのために必要な基本的なセキュリティサービスであることを集めますサービス拒否攻撃。 SIPメッセージ内の本体は別途機密性、完全性、および認証のセキュリティサービスを必要とします。"
    },
    {
      "indent": 3,
      "text": "Rather than defining new security mechanisms specific to SIP, SIP reuses wherever possible existing security models derived from the HTTP and SMTP space.",
      "ja": "むしろSIPに固有の新しいセキュリティメカニズムを定義するよりも、SIPはHTTPとSMTP空間から派生し、可能な限り既存のセキュリティモデルを再利用します。"
    },
    {
      "indent": 3,
      "text": "Full encryption of messages provides the best means to preserve the confidentiality of signaling - it can also guarantee that messages are not modified by any malicious intermediaries. However, SIP requests and responses cannot be naively encrypted end-to-end in their entirety because message fields such as the Request-URI, Route, and Via need to be visible to proxies in most network architectures so that SIP requests are routed correctly. Note that proxy servers need to modify some features of messages as well (such as adding Via header field values) in order for SIP to function. Proxy servers must therefore be trusted, to some degree, by SIP UAs. To this purpose, low-layer security mechanisms for SIP are recommended, which encrypt the entire SIP requests or responses on the wire on a hop-by-hop basis, and that allow endpoints to verify the identity of proxy servers to whom they send requests.",
      "ja": "メッセージの完全な暗号化は、シグナリングの機密性を保持するために最良の手段を提供します - それはまた、メッセージが任意の悪意のある仲介によって変更されないことを保証することができます。こうした要求URI、ルート、およびVIAなどのメッセージフィールドは、SIP要求が正しく配線されているように、ほとんどのネットワークアーキテクチャでプロキシに見えるようにする必要があるためしかし、SIPの要求と応答は、単純にその全体をエンドツーエンドで暗号化することはできません。そのプロキシサーバは、SIPが機能するためには（例えばヘッダーフィールド値を経由して追加など）だけでなく、メッセージのいくつかの機能を変更する必要があります。プロキシサーバーは、したがって、SIPのUAによって、ある程度、信頼されている必要があります。この目的のために、SIPのための低レイヤのセキュリティメカニズムが推奨され、ホップバイホップベースでワイヤ上の全体のSIP要求または応答を暗号化している、そしてそれは、エンドポイントは、彼らが要求を送信者にプロキシサーバの身元を確認することができます。"
    },
    {
      "indent": 3,
      "text": "SIP entities also have a need to identify one another in a secure fashion. When a SIP endpoint asserts the identity of its user to a peer UA or to a proxy server, that identity should in some way be verifiable. A cryptographic authentication mechanism is provided in SIP to address this requirement.",
      "ja": "SIPエンティティはまた、安全な方法で互いを特定する必要があります。 SIPエンドポイントが相手UAまたはプロキシサーバーにそのユーザーのアイデンティティを主張する場合は、そのIDは、何らかの方法で検証する必要があります。暗号認証機構はこの要求に対処するために、SIPに設けられています。"
    },
    {
      "indent": 3,
      "text": "An independent security mechanism for SIP message bodies supplies an alternative means of end-to-end mutual authentication, as well as providing a limit on the degree to which user agents must trust intermediaries.",
      "ja": "SIPメッセージボディのための独立したセキュリティ機構は、代替エンドツーエンドの相互認証の手段、ならびにユーザエージェントが仲介を信頼しなければならない程度に制限を設けることを供給する。"
    },
    {
      "indent": 0,
      "text": "26.2.1 Transport and Network Layer Security",
      "section_title": true,
      "ja": "26.2.1トランスポートおよびネットワーク層セキュリティ"
    },
    {
      "indent": 3,
      "text": "Transport or network layer security encrypts signaling traffic, guaranteeing message confidentiality and integrity.",
      "ja": "トランスポートまたはネットワーク層のセキュリティは、メッセージの機密性と完全性を保証する、シグナリングトラフィックを暗号化します。"
    },
    {
      "indent": 3,
      "text": "Oftentimes, certificates are used in the establishment of lower-layer security, and these certificates can also be used to provide a means of authentication in many architectures.",
      "ja": "多くの場合、証明書は、下位層のセキュリティの確立に使用されており、これらの証明書はまた、多くのアーキテクチャでは、認証の手段を提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Two popular alternatives for providing security at the transport and network layer are, respectively, TLS [25] and IPSec [26].",
      "ja": "トランスポートおよびネットワーク層でのセキュリティを提供するための2つの人気の選択肢は、それぞれ、TLS [25]およびIPSec [26]です。"
    },
    {
      "indent": 3,
      "text": "IPSec is a set of network-layer protocol tools that collectively can be used as a secure replacement for traditional IP (Internet Protocol). IPSec is most commonly used in architectures in which a set of hosts or administrative domains have an existing trust relationship with one another. IPSec is usually implemented at the operating system level in a host, or on a security gateway that provides confidentiality and integrity for all traffic it receives from a particular interface (as in a VPN architecture). IPSec can also be used on a hop-by-hop basis.",
      "ja": "IPSecは、集合的に、伝統的なIP（インターネットプロトコル）の安全な代替として使用することができるネットワーク層プロトコルツールのセットです。 IPSecは、最も一般的にホストまたは管理ドメインのセットは互いに既存の信頼関係を持っているアーキテクチャで使用されています。 IPSecのは、通常、宿主に、またはそれが（VPNアーキテクチャのような）特定のインターフェイスから受信したすべてのトラフィックの機密性と完全性を提供するセキュリティゲートウェイ上のオペレーティング・システム・レベルで実装されています。 IPSecはまた、ホップバイホップベースで使用することができます。"
    },
    {
      "indent": 3,
      "text": "In many architectures IPSec does not require integration with SIP applications; IPSec is perhaps best suited to deployments in which adding security directly to SIP hosts would be arduous. UAs that have a pre-shared keying relationship with their first-hop proxy server are also good candidates to use IPSec. Any deployment of IPSec for SIP would require an IPSec profile describing the protocol tools that would be required to secure SIP. No such profile is given in this document.",
      "ja": "多くのアーキテクチャではIPSecはSIPアプリケーションとの統合を必要としません。 IPSecはSIPホストに直接セキュリティを追加することが困難になりした展開に、おそらく最適です。彼らの最初のホップのプロキシサーバとの事前共有キーの関係を持つUAはまた、IPSecを使用するように良好な候補です。 SIPのためのIPSecの任意の展開は、SIPを確保するために必要とされるであろうプロトコルツールを記述するIPSecプロファイルを必要とします。そのようなプロファイルは、この文書に与えられていません。"
    },
    {
      "indent": 3,
      "text": "TLS provides transport-layer security over connection-oriented protocols (for the purposes of this document, TCP); \"tls\" (signifying TLS over TCP) can be specified as the desired transport protocol within a Via header field value or a SIP-URI. TLS is most suited to architectures in which hop-by-hop security is required between hosts with no pre-existing trust association. For example, Alice trusts her local proxy server, which after a certificate exchange decides to trust Bob's local proxy server, which Bob trusts, hence Bob and Alice can communicate securely.",
      "ja": "TLSは、（本明細書の目的のために、TCP）接続指向プロトコル経由でトランスポート・レイヤ・セキュリティを提供します。 （TCP上TLSを意味する）「TLS」は、Viaヘッダフィールド値またはSIP-URI内の所望のトランスポートプロトコルとして指定することができます。 TLSは、ホップバイホップセキュリティは無既存のトラスト・アソシエーションとホスト間に必要とされるアーキテクチャに最適です。例えば、アリスは、証明書の交換後、ボブ信託、したがって、ボブとアリスが安全に通信することができボブのローカルプロキシサーバーを、信頼することにした彼女のローカルプロキシサーバーを、信頼します。"
    },
    {
      "indent": 3,
      "text": "TLS must be tightly coupled with a SIP application. Note that transport mechanisms are specified on a hop-by-hop basis in SIP, thus a UA that sends requests over TLS to a proxy server has no assurance that TLS will be used end-to-end.",
      "ja": "TLSは、しっかりとSIPアプリケーションと結合されなければなりません。 TLSは、エンドツーエンドで使用されるという保証を持っていないプロキシサーバーにTLSオーバー要求を送信するメカニズムはSIPにおけるホップバイホップベースで指定される輸送、したがってUAに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite [6] MUST be supported at a minimum by implementers when TLS is used in a SIP application. For purposes of backwards compatibility, proxy servers, redirect servers, and registrars SHOULD support TLS_RSA_WITH_3DES_EDE_CBC_SHA. Implementers MAY also support any other ciphersuite.",
      "ja": "TLSは、SIPアプリケーションで使用される場合TLS_RSA_WITH_AES_128_CBC_SHAの暗号スイート[6]は実装によって最小でサポートしなければなりません。後方互換性の目的のために、プロキシサーバ、サーバにリダイレクト、およびレジストラがTLS_RSA_WITH_3DES_EDE_CBC_SHAをサポートする必要があります。実装者はまた、他の暗号スイートをサポートするかもしれません。"
    },
    {
      "indent": 0,
      "text": "26.2.2 SIPS URI Scheme",
      "section_title": true,
      "ja": "26.2.2は、URIスキームをSIPS"
    },
    {
      "indent": 3,
      "text": "The SIPS URI scheme adheres to the syntax of the SIP URI (described in 19), although the scheme string is \"sips\" rather than \"sip\". The semantics of SIPS are very different from the SIP URI, however. SIPS allows resources to specify that they should be reached securely.",
      "ja": "スキーム文字列が「SIPS」よりもむしろ「SIP」であるが、SIPS URIスキームは、（19に記載）のSIP URIの構文に準拠します。 SIPSの意味論は、しかし、SIP URIとは非常に異なっています。 SIPSは資源が、彼らが安全に到達するように指定することができます。"
    },
    {
      "indent": 3,
      "text": "A SIPS URI can be used as an address-of-record for a particular user - the URI by which the user is canonically known (on their business cards, in the From header field of their requests, in the To header field of REGISTER requests). When used as the Request-URI of a request, the SIPS scheme signifies that each hop over which the request is forwarded, until the request reaches the SIP entity responsible for the domain portion of the Request-URI, must be secured with TLS; once it reaches the domain in question it is handled in accordance with local security and routing policy, quite possibly using TLS for any last hop to a UAS. When used by the originator of a request (as would be the case if they employed a SIPS URI as the address-of-record of the target), SIPS dictates that the entire request path to the target domain be so secured.",
      "ja": "REGISTER要求のフィールドをヘッダーに、そのリクエストのFromヘッダフィールドに、ユーザが正準その名刺に（認識されるURI  -  SIPS URIは、アドレス・オブ・レコードの特定のユーザのためにとして使用することができます）。リクエストURI要求として使用する場合、SIPSスキームは、要求がRequest-URIのドメイン部分を担当するSIPエンティティに達するまで要求が、転送された上に、各ホップは、TLSで保護されなければならないことを意味します。それは恐らくUASへの最後のホップにTLSを使用して、ローカルセキュリティとルーティングポリシーに従って処理された問題のドメインに達します。要求（これらはアドレス・オブ・レコードターゲットとしてSIPS URIを用いる場合のように）の創始者によって使用される場合、SIPSは、ターゲット・ドメインに要求全体パスがそれほど確保することを指示します。"
    },
    {
      "indent": 3,
      "text": "The SIPS scheme is applicable to many of the other ways in which SIP URIs are used in SIP today in addition to the Request-URI, including in addresses-of-record, contact addresses (the contents of Contact headers, including those of REGISTER methods), and Route headers. In each instance, the SIPS URI scheme allows these existing fields to designate secure resources. The manner in which a SIPS URI is dereferenced in any of these contexts has its own security properties which are detailed in [4].",
      "ja": "SIPSスキームはアドレス-のレコード、REGISTER方法を含め連絡先（コンタクトヘッダの内容に含め、SIPのURIは要求URIに加えて、今日SIPで使用されている他の方法の多くに適用されます）、およびRouteヘッダ。各場合において、SIPS URIスキームは、これらの既存のフィールドは、セキュアリソースを指定することを可能にします。 SIPS URIは、これらのコンテキストのいずれかに逆参照される方法[4]に詳述されている独自のセキュリティ特性を有します。"
    },
    {
      "indent": 3,
      "text": "The use of SIPS in particular entails that mutual TLS authentication SHOULD be employed, as SHOULD the ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA. Certificates received in the authentication process SHOULD be validated with root certificates held by the client; failure to validate a certificate SHOULD result in the failure of the request.",
      "ja": "特にSIPSの使用は、相互TLS認証がSHOULD暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAとして、使用されるべきであることを必要とします。認証処理で受信した証明書は、クライアントが保持しているルート証明書を検証する必要があります。証明書を検証するために失敗は、要求の失敗を生じるはずです。"
    },
    {
      "indent": 6,
      "text": "Note that in the SIPS URI scheme, transport is independent of TLS, and thus \"sips:alice@atlanta.com;transport=tcp\" and \"sips:alice@atlanta.com;transport=sctp\" are both valid (although note that UDP is not a valid transport for SIPS). The use of \"transport=tls\" has consequently been deprecated, partly because it was specific to a single hop of the request. This is a change since RFC 2543.",
      "ja": "SIPS URIスキームでなお、トランスポートは、TLSとは無関係であり、したがって「すする：alice@atlanta.com;輸送= TCP」および「一口：alice@atlanta.com;輸送= SCTP」（両方とも有効である。なお、もののUDP）はSIPSのための有効なトランスポートではありません。 「輸送= TLS」の使用は、結果としてそれが要求のシングルホップに特異的であった一因で、廃止されました。これは、RFC 2543からの変更です。"
    },
    {
      "indent": 3,
      "text": "Users that distribute a SIPS URI as an address-of-record may elect to operate devices that refuse requests over insecure transports.",
      "ja": "アドレス・オブ・レコードとしてSIPS URIを配布するユーザーは、安全でないトランスポート上で要求を拒否するデバイスを動作させるために選ぶことができます。"
    },
    {
      "indent": 0,
      "text": "26.2.3 HTTP Authentication",
      "section_title": true,
      "ja": "26.2.3 HTTP認証"
    },
    {
      "indent": 3,
      "text": "SIP provides a challenge capability, based on HTTP authentication, that relies on the 401 and 407 response codes as well as header fields for carrying challenges and credentials. Without significant modification, the reuse of the HTTP Digest authentication scheme in SIP allows for replay protection and one-way authentication.",
      "ja": "SIPは、課題と資格情報を搬送するための401と407応答コードならびにヘッダフィールドに依存してHTTP認証に基づいて、チャレンジ能力を提供します。大幅な変更を加えることなく、SIPにおけるHTTPダイジェスト認証スキームの再利用は、再生保護と一方向認証が可能になります。"
    },
    {
      "indent": 3,
      "text": "The usage of Digest authentication in SIP is detailed in Section 22.",
      "ja": "SIPにおけるダイジェスト認証の使用量はセクション22に詳述されています。"
    },
    {
      "indent": 0,
      "text": "26.2.4 S/MIME",
      "section_title": true,
      "ja": "26.2.4 S / MIME"
    },
    {
      "indent": 3,
      "text": "As is discussed above, encrypting entire SIP messages end-to-end for the purpose of confidentiality is not appropriate because network intermediaries (like proxy servers) need to view certain header fields in order to route messages correctly, and if these intermediaries are excluded from security associations, then SIP messages will essentially be non-routable.",
      "ja": "上述されたように、機密保持の目的のために全体のSIPメッセージのエンド・ツー・エンドの暗号化（プロキシサーバのような）ネットワーク仲介が正しくルーティングメッセージために、特定のヘッダフィールドを表示する必要があるため適切ではない、これらの媒体は、対象から除外された場合セキュリティアソシエーションは、その後、SIPメッセージは、本質的に非ルーティング可能になります。"
    },
    {
      "indent": 3,
      "text": "However, S/MIME allows SIP UAs to encrypt MIME bodies within SIP, securing these bodies end-to-end without affecting message headers. S/MIME can provide end-to-end confidentiality and integrity for message bodies, as well as mutual authentication. It is also possible to use S/MIME to provide a form of integrity and confidentiality for SIP header fields through SIP message tunneling.",
      "ja": "しかし、S / MIMEは、これらの機関は、エンドツーエンドメッセージヘッダーに影響を与えることなく確保、SIP UAがSIP内のMIMEボディを暗号化することを可能にします。 S / MIMEは、メッセージ本文だけでなく、相互認証のためのエンドツーエンドの機密性と完全性を提供することができます。 SIPメッセージをトンネルを介してSIPヘッダーフィールドの完全性と機密性の形態を提供するS / MIMEを使用することも可能です。"
    },
    {
      "indent": 3,
      "text": "The usage of S/MIME in SIP is detailed in Section 23.",
      "ja": "SIPでのS / MIMEの使用はセクション23に詳述されています。"
    },
    {
      "indent": 0,
      "text": "26.3 Implementing Security Mechanisms",
      "section_title": true,
      "ja": "26.3セキュリティの実装メカニズム"
    },
    {
      "indent": 0,
      "text": "26.3.1 Requirements for Implementers of SIP",
      "section_title": true,
      "ja": "SIPの実装者のための26.3.1の要件"
    },
    {
      "indent": 3,
      "text": "Proxy servers, redirect servers, and registrars MUST implement TLS, and MUST support both mutual and one-way authentication. It is strongly RECOMMENDED that UAs be capable initiating TLS; UAs MAY also be capable of acting as a TLS server. Proxy servers, redirect servers, and registrars SHOULD possess a site certificate whose subject corresponds to their canonical hostname. UAs MAY have certificates of their own for mutual authentication with TLS, but no provisions are set forth in this document for their use. All SIP elements that support TLS MUST have a mechanism for validating certificates received during TLS negotiation; this entails possession of one or more root certificates issued by certificate authorities (preferably well-known distributors of site certificates comparable to those that issue root certificates for web browsers).",
      "ja": "プロキシサーバー、サーバーのリダイレクト、およびレジストラがTLSを実装しなければならない、との相互および一方向認証の両方をサポートしなければなりません。強くUAができる開始TLSすることをお勧めします。 UAはまた、TLSサーバーとして動作することが可能であってもよいです。プロキシサーバー、サーバーのリダイレクト、およびレジストラがその対象と自分の正規のホスト名に対応して、サイトの証明書を有していなければなりません。 UAはTLSとの相互認証のために自分自身の証明書を持っているかもしれませんが、何の規定は、その使用については、このドキュメントに記載されていません。 TLSをサポートするすべてのSIPエレメントは、TLSネゴシエーション中に受信した証明書を検証するためのメカニズムを持っている必要があります。これは、認証局（ウェブブラウザのルート証明書を発行するものに匹敵するサイト証明書の好ましくはよく知られているディストリビュータ）によって発行された一つ以上のルート証明書の所持を伴います。"
    },
    {
      "indent": 3,
      "text": "All SIP elements that support TLS MUST also support the SIPS URI scheme.",
      "ja": "TLSをサポートするすべてのSIP要素もSIPS URIスキームをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Proxy servers, redirect servers, registrars, and UAs MAY also implement IPSec or other lower-layer security protocols.",
      "ja": "プロキシサーバー、サーバーにリダイレクトし、登録機関、およびUAはまた、IPSecまたは他の下位層のセキュリティプロトコルを実装してもよいです。"
    },
    {
      "indent": 3,
      "text": "When a UA attempts to contact a proxy server, redirect server, or registrar, the UAC SHOULD initiate a TLS connection over which it will send SIP messages. In some architectures, UASs MAY receive requests over such TLS connections as well.",
      "ja": "UAは、プロキシサーバーを問い合わせサーバ、またはレジストラをリダイレクトしようとすると、UACは、SIPメッセージを送信するその上のTLS接続を開始すべきです。いくつかのアーキテクチャでは、のUASは、同様なTLS接続を介して要求を受信することができます。"
    },
    {
      "indent": 3,
      "text": "Proxy servers, redirect servers, registrars, and UAs MUST implement Digest Authorization, encompassing all of the aspects required in 22. Proxy servers, redirect servers, and registrars SHOULD be configured with at least one Digest realm, and at least one \"realm\" string supported by a given server SHOULD correspond to the server's hostname or domainname.",
      "ja": "少なくとも1つの「領域」の文字列プロキシサーバーは、サーバー、レジストラーをリダイレクトし、UAはダイジェスト認証を実装しなければならない、22プロキシサーバで必要と側面の全てを網羅する、サーバーのリダイレクト、およびレジストラが少なくとも一つのダイジェストレルムを設定する必要があり、かつサーバのホスト名またはドメイン名に対応する必要があります指定されたサーバーでサポートされています。"
    },
    {
      "indent": 3,
      "text": "UAs MAY support the signing and encrypting of MIME bodies, and transference of credentials with S/MIME as described in Section 23. If a UA holds one or more root certificates of certificate authorities in order to validate certificates for TLS or IPSec, it SHOULD be capable of reusing these to verify S/MIME certificates, as appropriate. A UA MAY hold root certificates specifically for validating S/MIME certificates.",
      "ja": "UAがTLSまたはIPSecの証明書を検証するために、認証機関の一つ以上のルート証明書を保持している場合は、セクション23で説明したようにUAはS / MIMEでの資格情報の署名およびMIMEボディの暗号化、および転移をサポートするかもしれ、それはする必要があります必要に応じて、S / MIME証明書を確認するために、これらを再利用できます。 UAは、具体的には、S / MIME証明書を検証するためのルート証明書を保持することができます。"
    },
    {
      "indent": 6,
      "text": "Note that is it anticipated that future security extensions may upgrade the normative strength associated with S/MIME as S/MIME implementations appear and the problem space becomes better understood.",
      "ja": "それはそれは、S / MIMEの実装が表示され、問題空間をよりよく理解になると、将来のセキュリティ拡張機能は、S / MIMEに関連した規範的強度をアップグレードすることが予想されるに注意してください。"
    },
    {
      "indent": 0,
      "text": "26.3.2 Security Solutions",
      "section_title": true,
      "ja": "26.3.2セキュリティソリューション"
    },
    {
      "indent": 3,
      "text": "The operation of these security mechanisms in concert can follow the existing web and email security models to some degree. At a high level, UAs authenticate themselves to servers (proxy servers, redirect servers, and registrars) with a Digest username and password; servers authenticate themselves to UAs one hop away, or to another server one hop away (and vice versa), with a site certificate delivered by TLS.",
      "ja": "コンサートではこれらのセキュリティメカニズムの動作がある程度既存のWebと電子メールのセキュリティモデルに従うことができます。ハイレベルでは、UAはダイジェストのユーザー名とパスワードを使用してサーバ（プロキシサーバ、サーバにリダイレクトし、レジストラ）に自分自身を認証します。サーバーは、1つのホップのUAに自分自身を認証し、または別の離れたサーバー1ホップ（およびその逆）に、TLSによって配信サイト証明書を持ちます。"
    },
    {
      "indent": 3,
      "text": "On a peer-to-peer level, UAs trust the network to authenticate one another ordinarily; however, S/MIME can also be used to provide direct authentication when the network does not, or if the network itself is not trusted.",
      "ja": "ピア・ツー・ピア・レベルでは、UAは1、通常相互に認証するためにネットワークを信頼します。ただし、S / MIMEは、ネットワークがないとき、またはネットワーク自体が信頼されていない場合は直接認証を提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The following is an illustrative example in which these security mechanisms are used by various UAs and servers to prevent the sorts of threats described in Section 26.1. While implementers and network administrators MAY follow the normative guidelines given in the remainder of this section, these are provided only as example implementations.",
      "ja": "以下は、これらのセキュリティメカニズムは、セクション26.1に記載された脅威の種類を防止するために、様々なUAとサーバーによって使用される例示的な例です。実装者とネットワーク管理者は、このセクションの残りの部分に所定の規範ガイドラインに従うことができるが、これらは一例の実装として提供されます。"
    },
    {
      "indent": 0,
      "text": "26.3.2.1 Registration",
      "section_title": true,
      "ja": "26.3.2.1登録"
    },
    {
      "indent": 3,
      "text": "When a UA comes online and registers with its local administrative domain, it SHOULD establish a TLS connection with its registrar (Section 10 describes how the UA reaches its registrar). The registrar SHOULD offer a certificate to the UA, and the site identified by the certificate MUST correspond with the domain in which the UA intends to register; for example, if the UA intends to register the address-of-record 'alice@atlanta.com', the site certificate must identify a host within the atlanta.com domain (such as sip.atlanta.com). When it receives the TLS Certificate message, the UA SHOULD verify the certificate and inspect the site identified by the certificate. If the certificate is invalid, revoked, or if it does not identify the appropriate party, the UA MUST NOT send the REGISTER message and otherwise proceed with the registration.",
      "ja": "UAがオンラインになると、ローカル管理ドメインに登録すると、それはそのレジストラとのTLS接続を確立すべきである（セクション10は、UAがレジストラに達する方法を説明します）。レジストラは、UAに証明書、およびUAは登録するつもりでいるドメインに対応しなければならない証明書によって識別されるサイトを提供する必要があります。 UAは、アドレスのレコード「alice@atlanta.com」を登録しようとする場合、たとえば、サイトの証明書は、（sip.atlanta.comなど）atlanta.comドメイン内のホストを識別する必要があります。それがTLS証明書メッセージを受信した場合、UAは、証明書を検証し、証明書によって識別されるサイトを検査する必要があります。証明書が無効である場合は、取り消され、またはそれが適切なパーティーを特定していない場合、UAは、REGISTERメッセージを送信し、そうでない場合は登録を進めてはなりません。"
    },
    {
      "indent": 6,
      "text": "When a valid certificate has been provided by the registrar, the UA knows that the registrar is not an attacker who might redirect the UA, steal passwords, or attempt any similar attacks.",
      "ja": "有効な証明書は、レジストラによって提供されている場合は、UAがレジストラは、UAをリダイレクトパスワードを盗む、または任意の同様の攻撃をしようとするかもしれない攻撃者ではないことを知っています。"
    },
    {
      "indent": 3,
      "text": "The UA then creates a REGISTER request that SHOULD be addressed to a Request-URI corresponding to the site certificate received from the registrar. When the UA sends the REGISTER request over the existing TLS connection, the registrar SHOULD challenge the request with a 401 (Proxy Authentication Required) response. The \"realm\" parameter within the Proxy-Authenticate header field of the response SHOULD correspond to the domain previously given by the site certificate. When the UAC receives the challenge, it SHOULD either prompt the user for credentials or take an appropriate credential from a keyring corresponding to the \"realm\" parameter in the challenge. The username of this credential SHOULD correspond with the \"userinfo\" portion of the URI in the To header field of the REGISTER request. Once the Digest credentials have been inserted into an appropriate Proxy-Authorization header field, the REGISTER should be resubmitted to the registrar.",
      "ja": "UAは、その後のRequest-URIレジストラから受け取ったサイト証明書に対応する取り組むべきREGISTER要求を作成します。 UAが既存のTLS接続を介してREGISTERリクエストを送信すると、レジストラは401（プロキシ認証が必要）応答でリクエストにチャレンジすべきです。応答のプロキシ認証ヘッダフィールド内の「レルム」パラメータは、以前にサイト証明書によって指定されたドメインに対応しなければなりません。 UACがチャレンジを受信すると、資格情報の入力をユーザーに求めるか、挑戦で「王国」パラメータに対応する鍵束から適切な資格を取る必要がありますどちらか。この資格のユーザ名は、REGISTERリクエストのフィールドをヘッダにURIの「ユーザー情報」部分と対応すべきです。ダイジェスト認証情報が適切なProxy-Authorizationヘッダフィールドに挿入された後、レジスタはレジストラに再送信されるべきです。"
    },
    {
      "indent": 6,
      "text": "Since the registrar requires the user agent to authenticate itself, it would be difficult for an attacker to forge REGISTER requests for the user's address-of-record. Also note that since the REGISTER is sent over a confidential TLS connection, attackers will not be able to intercept the REGISTER to record credentials for any possible replay attack.",
      "ja": "レジストラは自身を認証するためのユーザーエージェントを必要とするので、攻撃者はユーザーのアドレス・オブ・レコードのREGISTERリクエストを偽造することは困難であろう。また、REGISTERは機密TLS接続を介して送信されるため、攻撃者が任意の可能リプレイ攻撃のための資格情報を記録するためにREGISTERを傍受することはできませんのでご注意。"
    },
    {
      "indent": 3,
      "text": "Once the registration has been accepted by the registrar, the UA SHOULD leave this TLS connection open provided that the registrar also acts as the proxy server to which requests are sent for users in this administrative domain. The existing TLS connection will be reused to deliver incoming requests to the UA that has just completed registration.",
      "ja": "登録はレジストラによって受理された後、UAは、レジストラはまた、要求が、この管理ドメインのユーザーに対して送信されると、プロキシサーバとして動作することを提供し、このTLS接続を開いておくべきです。既存のTLS接続だけで登録が完了したUAへの着信要求を実現するために再利用されます。"
    },
    {
      "indent": 6,
      "text": "Because the UA has already authenticated the server on the other side of the TLS connection, all requests that come over this connection are known to have passed through the proxy server - attackers cannot create spoofed requests that appear to have been sent through that proxy server.",
      "ja": "UAはすでにTLS接続の反対側にサーバーを認証しているので、この接続を介して来るすべての要求は、プロキシサーバーを通過したことが知られている - 攻撃者は、そのプロキシサーバーを経由して送信されているように見える偽装されたリクエストを作成することはできません。"
    },
    {
      "indent": 0,
      "text": "26.3.2.2 Interdomain Requests",
      "section_title": true,
      "ja": "26.3.2.2ドメイン間要求"
    },
    {
      "indent": 3,
      "text": "Now let's say that Alice's UA would like to initiate a session with a user in a remote administrative domain, namely \"bob@biloxi.com\". We will also say that the local administrative domain (atlanta.com) has a local outbound proxy.",
      "ja": "今度は、アリスのUAは、すなわち「bob@biloxi.com」、リモート管理ドメイン内のユーザーとのセッションを開始したいとしましょう。また、ローカル管理ドメイン（atlanta.com）はローカルアウトバウンドプロキシを持っていることを言うだろう。"
    },
    {
      "indent": 3,
      "text": "The proxy server that handles inbound requests for an administrative domain MAY also act as a local outbound proxy; for simplicity's sake we'll assume this to be the case for atlanta.com (otherwise the user agent would initiate a new TLS connection to a separate server at this point). Assuming that the client has completed the registration process described in the preceding section, it SHOULD reuse the TLS connection to the local proxy server when it sends an INVITE request to another user. The UA SHOULD reuse cached credentials in the INVITE to avoid prompting the user unnecessarily.",
      "ja": "管理ドメインのインバウンド要求を処理するプロキシサーバは、ローカルアウトバウンドプロキシとして動作することができます。簡単のため、私たちは、これがatlanta.com用ケース（そうでないユーザエージェントは、この時点で別のサーバーへの新しいTLS接続を開始します）であることを仮定します。それは別のユーザーにINVITEリクエストを送信するとき、クライアントは、前のセクションで説明した登録処理を完了したと仮定すると、それは、ローカルプロキシサーバへのTLS接続を再利用すべきです。 UAは、不必要にユーザに促す避けるために、INVITEにキャッシュされた資格情報を再利用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the local outbound proxy server has validated the credentials presented by the UA in the INVITE, it SHOULD inspect the Request-URI to determine how the message should be routed (see [4]). If the \"domainname\" portion of the Request-URI had corresponded to the local domain (atlanta.com) rather than biloxi.com, then the proxy server would have consulted its location service to determine how best to reach the requested user.",
      "ja": "ローカルアウトバウンドプロキシサーバは、INVITEにUAによって提示された信任状を検証した場合には、（[4]参照）メッセージのルーティング方法を決定するためのRequest-URIを検査するべきです。要求URIの「ドメイン名」の部分ではなくbiloxi.comよりも、ローカルドメイン（atlanta.com）に対応していた場合は、プロキシサーバーは、要求されたユーザーに到達するために最善の方法を決定するために、そのロケーションサービスを相談しているだろう。"
    },
    {
      "indent": 6,
      "text": "Had \"alice@atlanta.com\" been attempting to contact, say, \"alex@atlanta.com\", the local proxy would have proxied to the request to the TLS connection Alex had established with the registrar when he registered. Since Alex would receive this request over his authenticated channel, he would be assured that Alice's request had been authorized by the proxy server of the local administrative domain.",
      "ja": "「alice@atlanta.comは」「alex@atlanta.com」、たとえば、連絡しようとしていた、ローカルプロキシは、彼が登録されたときにアレックスがレジストラに確立したTLS接続を要求にプロキシただろう。アレックスは彼の認証されたチャネルを介してこの要求を受け取ることになるので、彼はアリスの要求がローカル管理ドメインのプロキシサーバーによって許可されていたことが保証されます。"
    },
    {
      "indent": 3,
      "text": "However, in this instance the Request-URI designates a remote domain. The local outbound proxy server at atlanta.com SHOULD therefore establish a TLS connection with the remote proxy server at biloxi.com. Since both of the participants in this TLS connection are servers that possess site certificates, mutual TLS authentication SHOULD occur. Each side of the connection SHOULD verify and inspect the certificate of the other, noting the domain name that appears in the certificate for comparison with the header fields of SIP messages. The atlanta.com proxy server, for example, SHOULD verify at this stage that the certificate received from the remote side corresponds with the biloxi.com domain. Once it has done so, and TLS negotiation has completed, resulting in a secure channel between the two proxies, the atlanta.com proxy can forward the INVITE request to biloxi.com.",
      "ja": "ただし、この場合のRequest-URIは、リモートドメインを指定します。 atlanta.comのローカルアウトバウンドプロキシサーバーは、したがって、biloxi.comのリモートプロキシサーバーとのTLS接続を確立する必要があります。このTLS接続の参加者の両方が、サイトの証明書を持っているサーバがあるので、相互TLS認証が起こるべきです。接続の各側は、SIPメッセージのヘッダフィールドとの比較のために証明書に表示されるドメイン名を指摘、他の証明書を検証し、検査するべきです。 atlanta.comプロキシサーバは、例えば、証明書は、リモート側がbiloxi.comドメインに対応するから受信したこの段階で確認する必要があります。それはそうした、とTLSネゴシエーションは2つのプロキシ間のセキュアなチャネルで、その結果、完了すると、atlanta.comのプロキシはbiloxi.comにINVITE要求を転送することができます。"
    },
    {
      "indent": 3,
      "text": "The proxy server at biloxi.com SHOULD inspect the certificate of the proxy server at atlanta.com in turn and compare the domain asserted by the certificate with the \"domainname\" portion of the From header field in the INVITE request. The biloxi proxy MAY have a strict security policy that requires it to reject requests that do not match the administrative domain from which they have been proxied.",
      "ja": "biloxi.comでプロキシサーバは、順番にatlanta.comでプロキシサーバの証明書を検査し、INVITE要求のヘッダフィールドからの「ドメイン名」部分と証明書によってアサートドメインを比較する必要があります。ビロクシープロキシは、彼らがプロキシされているから、管理ドメインと一致しない要求を拒否することを要求する厳格なセキュリティポリシーを持っているかもしれません。"
    },
    {
      "indent": 6,
      "text": "Such security policies could be instituted to prevent the SIP equivalent of SMTP 'open relays' that are frequently exploited to generate spam.",
      "ja": "このようなセキュリティポリシーは、頻繁にスパムを生成するために利用されているSMTP「オープンリレー」のSIP相当を防ぐために制定することができます。"
    },
    {
      "indent": 3,
      "text": "This policy, however, only guarantees that the request came from the domain it ascribes to itself; it does not allow biloxi.com to ascertain how atlanta.com authenticated Alice. Only if biloxi.com has some other way of knowing atlanta.com's authentication policies could it possibly ascertain how Alice proved her identity. biloxi.com might then institute an even stricter policy that forbids requests that come from domains that are not known administratively to share a common authentication policy with biloxi.com.",
      "ja": "このポリシーは、しかし、唯一の要求は、それ自体に帰しドメインから来たことを保証します。それはbiloxi.comがatlanta.comがアリスを認証されたかを確認することはできません。 biloxi.comがatlanta.comの認証ポリシーを知る他の方法を持っている場合にのみ、それはおそらくアリスが彼女の身元を証明したか確かめることができました。 biloxi.comは、biloxi.comと共通の認証ポリシーを共有するために、管理が知られていないドメインからのリクエストが禁止されていても厳しい政策を制定することがあります。"
    },
    {
      "indent": 3,
      "text": "Once the INVITE has been approved by the biloxi proxy, the proxy server SHOULD identify the existing TLS channel, if any, associated with the user targeted by this request (in this case \"bob@biloxi.com\"). The INVITE should be proxied through this channel to Bob. Since the request is received over a TLS connection that had previously been authenticated as the biloxi proxy, Bob knows that the From header field was not tampered with and that atlanta.com has validated Alice, although not necessarily whether or not to trust Alice's identity.",
      "ja": "INVITEはビロクシプロキシによって承認されると、（この場合は「bob@biloxi.com」で）このリクエストの対象となるユーザーに関連付けられた任意の場合は、プロキシサーバーは、既存のTLSチャネルを識別する必要があります。 INVITEはボブに、このチャネルを介してプロキシされる必要があります。要求が以前ビロクシープロキシとして認証されたTLS接続を介して受信されているので、ボブは、Fromヘッダーフィールドで改ざんされていないとアリスのアイデンティティを信頼する必要はないかどうかが、そのatlanta.comは、アリスを検証したことを知っています。"
    },
    {
      "indent": 3,
      "text": "Before they forward the request, both proxy servers SHOULD add a Record-Route header field to the request so that all future requests in this dialog will pass through the proxy servers. The proxy servers can thereby continue to provide security services for the lifetime of this dialog. If the proxy servers do not add themselves to the Record-Route, future messages will pass directly end-to-end between Alice and Bob without any security services (unless the two parties agree on some independent end-to-end security such as S/MIME). In this respect the SIP trapezoid model can provide a nice structure where conventions of agreement between the site proxies can provide a reasonably secure channel between Alice and Bob.",
      "ja": "彼らは要求を転送する前に、このダイアログでは、将来のすべての要求がプロキシサーバを通過するように、両方のプロキシサーバは、リクエストにRecord-Routeヘッダーフィールドを追加する必要があります。プロキシサーバは、それによって、このダイアログの存続のためのセキュリティサービスを提供し続けることができます。プロキシサーバは、レコード・ルートに自分自身を追加しない場合、将来のメッセージが直接渡されますエンドツーエンドアリスとボブの間で任意のセキュリティサービスなし（2つの当事者は、このようなSのようないくつかの独立したエンドツーエンドのセキュリティに合意しない限り、 / MIME）。この点において、SIP台形モデルは、サイトプロキシ間の協定の規則がアリスとボブの間で合理的に安全なチャネルを提供することができます素敵な構造を提供することができます。"
    },
    {
      "indent": 6,
      "text": "An attacker preying on this architecture would, for example, be unable to forge a BYE request and insert it into the signaling stream between Bob and Alice because the attacker has no way of ascertaining the parameters of the session and also because the integrity mechanism transitively protects the traffic between Alice and Bob.",
      "ja": "完全性機構は、過渡保護するので、攻撃者は、セッションのパラメータを確認する方法がないとするので、このアーキテクチャに捕食攻撃者は、例えば、BYE要求を偽造し、ボブとアリスとの間のシグナリングストリームに挿入することができませんアリスとボブの間のトラフィック。"
    },
    {
      "indent": 0,
      "text": "26.3.2.3 Peer-to-Peer Requests",
      "section_title": true,
      "ja": "26.3.2.3ピアツーピアのリクエスト"
    },
    {
      "indent": 3,
      "text": "Alternatively, consider a UA asserting the identity \"carol@chicago.com\" that has no local outbound proxy. When Carol wishes to send an INVITE to \"bob@biloxi.com\", her UA SHOULD initiate a TLS connection with the biloxi proxy directly (using the mechanism described in [4] to determine how to best to reach the given Request-URI). When her UA receives a certificate from the biloxi proxy, it SHOULD be verified normally before she passes her INVITE across the TLS connection. However, Carol has no means of proving her identity to the biloxi proxy, but she does have a CMS-detached signature over a \"message/sip\" body in the INVITE. It is unlikely in this instance that Carol would have any credentials in the biloxi.com realm, since she has no formal association with biloxi.com. The biloxi proxy MAY also have a strict policy that precludes it from even bothering to challenge requests that do not have biloxi.com in the \"domainname\" portion of the From header field - it treats these users as unauthenticated.",
      "ja": "また、ローカルアウトバウンドプロキシを持っていないアイデンティティ「carol@chicago.com」を主張するUAを考えてみましょう。キャロルが「bob@biloxi.com」にINVITEを送信したい場合、彼女のUAは、直接ビロクシプロキシとのTLS接続を開始すべきである（で説明されたメカニズムを使用して、[4]所与のRequest-URIに到達する方法に最善を決定するために） 。彼女のUAはビロクシープロキシから証明書を受け取ると、彼女は彼女がTLS接続でINVITEを渡す前に、それが正常に検証する必要があります。しかし、キャロルはビロクシープロキシに彼女の身元を証明する手段を持たないが、彼女はINVITEの「メッセージ/一口」身体オーバーCMS-分離署名を持っています。彼女がbiloxi.comと正式な関連を持っていないので、キャロルは、biloxi.comレルムのいずれかの資格情報を持っているであろうと、このインスタンスではほとんどありません。それが認証されていないとして、これらのユーザーを扱う - ビロクシープロキシもさえFromヘッダーフィールドの「ドメイン名」部分にbiloxi.comを持たない要求に挑戦するために悩まからそれを排除する厳格なポリシーを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "The biloxi proxy has a policy for Bob that all non-authenticated requests should be redirected to the appropriate contact address registered against 'bob@biloxi.com', namely <sip:bob@192.0.2.4>. Carol receives the redirection response over the TLS connection she established with the biloxi proxy, so she trusts the veracity of the contact address.",
      "ja": "ビロクシープロキシは、すべての非認証の要求が「bob@biloxi.com」、すなわち<：bob@192.0.2.4 SIP>に対して登録適切な連絡先アドレスにリダイレクトされるべきであるとボブのポリシーを持っています。キャロルは、彼女がビロクシープロキシを確立したTLS接続を介してリダイレクト応答を受信したので、彼女は、コンタクトアドレスの真実性を信頼します。"
    },
    {
      "indent": 3,
      "text": "Carol SHOULD then establish a TCP connection with the designated address and send a new INVITE with a Request-URI containing the received contact address (recomputing the signature in the body as the request is readied). Bob receives this INVITE on an insecure interface, but his UA inspects and, in this instance, recognizes the From header field of the request and subsequently matches a locally cached certificate with the one presented in the signature of the body of the INVITE. He replies in similar fashion, authenticating himself to Carol, and a secure dialog begins.",
      "ja": "キャロルは、その後、指定されたアドレスとTCPコネクションを確立し、新しいRequest-URI（要求が準備されているように本体に署名を再計算）を受信連絡先アドレスを含むと共にINVITEを送信すべきです。ボブは、これは安全でないインターフェイス上でINVITEを受信し、彼のUAは検査と、この例では、要求のヘッダフィールドから認識し、続いて、INVITEのボディの署名に提示された1つでローカルにキャッシュされた証明書と一致します。彼はキャロルに身を認証する、同様の方法で返信し、安全なダイアログが開始されます。"
    },
    {
      "indent": 6,
      "text": "Sometimes firewalls or NATs in an administrative domain could preclude the establishment of a direct TCP connection to a UA. In these cases, proxy servers could also potentially relay requests to UAs in a way that has no trust implications (for example, forgoing an existing TLS connection and forwarding the request over cleartext TCP) as local policy dictates.",
      "ja": "時には、管理ドメイン内のファイアウォールやNATはUAへの直接TCP接続の確立を妨げる可能性があります。これらのケースでは、プロキシサーバはまた、潜在的にローカルポリシーのおもむくままとして（例えば、既存のTLS接続をの前述し、平文のTCPを介して要求を転送する）は信頼の意味を持っていない方法でのUAに要求を中継することができます。"
    },
    {
      "indent": 0,
      "text": "26.3.2.4 DoS Protection",
      "section_title": true,
      "ja": "保護26.3.2.4 DoS攻撃"
    },
    {
      "indent": 3,
      "text": "In order to minimize the risk of a denial-of-service attack against architectures using these security solutions, implementers should take note of the following guidelines.",
      "ja": "これらのセキュリティソリューションを使用してアーキテクチャに対するDoS攻撃のリスクを最小限にするためには、実装者は、次のガイドラインに注意を払うべきです。"
    },
    {
      "indent": 3,
      "text": "When the host on which a SIP proxy server is operating is routable from the public Internet, it SHOULD be deployed in an administrative domain with defensive operational policies (blocking source-routed traffic, preferably filtering ping traffic). Both TLS and IPSec can also make use of bastion hosts at the edges of administrative domains that participate in the security associations to aggregate secure tunnels and sockets. These bastion hosts can also take the brunt of denial-of-service attacks, ensuring that SIP hosts within the administrative domain are not encumbered with superfluous messaging.",
      "ja": "SIPプロキシサーバが動作しているホストが公共のインターネットからルーティング可能である場合、それは、（好ましくはpingトラフィックをフィルタリングし、ソースルーティングされたトラフィックをブロックする）守備の運用ポリシーを管理ドメインに配置する必要があります。 TLSとIPSecのどちらにも安全なトンネルとソケットを集約するためにセキュリティアソシエーションに参加管理ドメインのエッジで要塞ホストを利用することができます。これらの要塞ホストは、管理ドメイン内のSIPホストが余分メッセージングで邪魔されていないことを保証し、サービス拒否攻撃の矛先を取ることができます。"
    },
    {
      "indent": 3,
      "text": "No matter what security solutions are deployed, floods of messages directed at proxy servers can lock up proxy server resources and prevent desirable traffic from reaching its destination. There is a computational expense associated with processing a SIP transaction at a proxy server, and that expense is greater for stateful proxy servers than it is for stateless proxy servers. Therefore, stateful proxies are more susceptible to flooding than stateless proxy servers.",
      "ja": "どんなにセキュリティソリューションが展開されているものを、プロキシサーバに向けたメッセージの洪水は、プロキシサーバーのリソースをロックアップしないとその先に到達するのが望ましいトラフィックを防ぐことができます。そこプロキシサーバーでSIPトランザクションを処理に関連する計算費用であり、その費用は、それがステートレスプロキシサーバのためであるよりも、ステートフルプロキシサーバのために大きいです。そのため、ステートフルプロキシはステートレスプロキシ・サーバよりも洪水の影響を受けやすいです。"
    },
    {
      "indent": 3,
      "text": "UAs and proxy servers SHOULD challenge questionable requests with only a single 401 (Unauthorized) or 407 (Proxy Authentication Required), forgoing the normal response retransmission algorithm, and thus behaving statelessly towards unauthenticated requests.",
      "ja": "UAとプロキシサーバは、通常の応答の再送アルゴリズムをの前述ので、未認証の要求に向けてステートレスに動作し、唯一の401（Unauthorized）または407（Proxy Authentication Required）との疑問の要求に挑戦すべきです。"
    },
    {
      "indent": 6,
      "text": "Retransmitting the 401 (Unauthorized) or 407 (Proxy Authentication Required) status response amplifies the problem of an attacker using a falsified header field value (such as Via) to direct traffic to a third party.",
      "ja": "第三者へのトラフィックを誘導する（例えば介して）改竄ヘッダフィールド値を使用して、攻撃者の問題は、401（不正な）または407（プロキシ認証が必要）ステータス応答を増幅して再送信します。"
    },
    {
      "indent": 3,
      "text": "In summary, the mutual authentication of proxy servers through mechanisms such as TLS significantly reduces the potential for rogue intermediaries to introduce falsified requests or responses that can deny service. This commensurately makes it harder for attackers to make innocent SIP nodes into agents of amplification.",
      "ja": "要約すると、TLSなどのメカニズムを通じてプロキシサーバの相互認証が大幅にサービスを拒否することができ偽造要求または応答を紹介する不正な仲介の可能性を低減します。これは、相応の攻撃者は、増幅のエージェントに無実のSIPノードを作ることがより困難になります。"
    },
    {
      "indent": 0,
      "text": "26.4 Limitations",
      "section_title": true,
      "ja": "26.4制限事項"
    },
    {
      "indent": 3,
      "text": "Although these security mechanisms, when applied in a judicious manner, can thwart many threats, there are limitations in the scope of the mechanisms that must be understood by implementers and network operators.",
      "ja": "賢明な方法で適用される場合、これらのセキュリティメカニズムは、多くの脅威を阻止することができるが、実装者とネットワークオペレータによって理解されなければならない機構の範囲には限界があります。"
    },
    {
      "indent": 0,
      "text": "26.4.1 HTTP Digest",
      "section_title": true,
      "ja": "26.4.1 HTTPダイジェスト"
    },
    {
      "indent": 3,
      "text": "One of the primary limitations of using HTTP Digest in SIP is that the integrity mechanisms in Digest do not work very well for SIP. Specifically, they offer protection of the Request-URI and the method of a message, but not for any of the header fields that UAs would most likely wish to secure.",
      "ja": "SIPでHTTPダイジェストを使用しての主な制限の1つはダイジェストで整合性のメカニズムは、SIPのために非常にうまく機能していないということです。具体的には、Request-URIとメッセージの方法ではなく、UAは最も可能性の高いセキュリティで保護したいでしょうヘッダフィールドのいずれかのための保護を提供します。"
    },
    {
      "indent": 3,
      "text": "The existing replay protection mechanisms described in RFC 2617 also have some limitations for SIP. The next-nonce mechanism, for example, does not support pipelined requests. The nonce-count mechanism should be used for replay protection.",
      "ja": "RFC 2617に記述既存のリプレイ保護メカニズムはまた、SIPのためのいくつかの制限があります。次-ナンスのメカニズムは、例えば、パイプライン化された要求をサポートしていません。ナンスカウントメカニズムはリプレイ保護のために使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Another limitation of HTTP Digest is the scope of realms. Digest is valuable when a user wants to authenticate themselves to a resource with which they have a pre-existing association, like a service provider of which the user is a customer (which is quite a common scenario and thus Digest provides an extremely useful function). By way of contrast, the scope of TLS is interdomain or multirealm, since certificates are often globally verifiable, so that the UA can authenticate the server with no pre-existing association.",
      "ja": "HTTPダイジェストの別の制限は、レルムの範囲です。ユーザが顧客である（非常に一般的なシナリオであるため、ダイジェストが非常に便利な機能を提供します）そのサービスプロバイダのように、彼らは既存の関連を持っていると、リソースに自分自身を認証したいときダイジェストは貴重です。 UAはありません、既存の関連でサーバーを認証できるように、証明書は、多くの場合、世界的に検証されているので、対照的に、TLSの適用範囲は、ドメイン間またはmultirealmです。"
    },
    {
      "indent": 0,
      "text": "26.4.2 S/MIME",
      "section_title": true,
      "ja": "26.4.2 S / MIME"
    },
    {
      "indent": 3,
      "text": "The largest outstanding defect with the S/MIME mechanism is the lack of a prevalent public key infrastructure for end users. If self-signed certificates (or certificates that cannot be verified by one of the participants in a dialog) are used, the SIP-based key exchange mechanism described in Section 23.2 is susceptible to a man-in-the-middle attack with which an attacker can potentially inspect and modify S/MIME bodies. The attacker needs to intercept the first exchange of keys between the two parties in a dialog, remove the existing CMS-detached signatures from the request and response, and insert a different CMS-detached signature containing a certificate supplied by the attacker (but which seems to be a certificate for the proper address-of-record). Each party will think they have exchanged keys with the other, when in fact each has the public key of the attacker.",
      "ja": "S / MIME機構を備えた最大の優秀な欠陥は、エンドユーザーのために普及している公開鍵インフラの欠如です。自己署名証明書（またはダイアログの参加者のいずれかによって確認することができない証明書）が使用される場合、セクション23.2に記載されたSIPベースの鍵交換機構は、man-in-the-middle攻撃を受けやすいしています攻撃者は、潜在的に点検し、S / MIMEボディを変更することができます。攻撃者は、ダイアログ内の2つの当事者間のキーの最初の交換を傍受し、要求と応答から既存のCMS-デタッチシグネチャを削除し、攻撃者によって供給された証明書を（含む異なるCMS-分離署名を挿入する必要がなく思われます適切なアドレスのレコード）の証明書であることを。各当事者は、実際には、それぞれが攻撃者の公開鍵を持っているとき、彼らは、他との鍵を交換したと思います。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the attacker can only leverage this vulnerability on the first exchange of keys between two parties - on subsequent occasions, the alteration of the key would be noticeable to the UAs. It would also be difficult for the attacker to remain in the path of all future dialogs between the two parties over time (as potentially days, weeks, or years pass).",
      "ja": "その後の機会に、キーの変更はUAのに目立つだろう - 攻撃者は2つのだけ当事者間のキーの最初の交換にこの脆弱性を活用できることに注意することが重要です。攻撃者は（潜在的に日、週、または年が通過する）時間をかけて二者間のすべての将来のダイアログのパスに残るすることも困難であろう。"
    },
    {
      "indent": 3,
      "text": "SSH is susceptible to the same man-in-the-middle attack on the first exchange of keys; however, it is widely acknowledged that while SSH is not perfect, it does improve the security of connections. The use of key fingerprints could provide some assistance to SIP, just as it does for SSH. For example, if two parties use SIP to establish a voice communications session, each could read off the fingerprint of the key they received from the other, which could be compared against the original. It would certainly be more difficult for the man-in-the-middle to emulate the voices of the participants than their signaling (a practice that was used with the Clipper chip-based secure telephone).",
      "ja": "SSHは、キーの最初のやり取りで同じman-in-the-middle攻撃を受けやすいです。しかし、広くSSHは完璧ではないが、それは接続のセキュリティを向上したことを認めています。キーの指紋の使用は、SSHの場合と同じように、SIPにいくつかの援助を提供することができます。両当事者は、音声通信セッションを確立するためにSIPを使用する場合、例えば、それぞれがオリジナルと比較することができ、それらは、他から受信した鍵の指紋を読み取ることができました。それは確かなman-in-the-middleそのシグナリング（クリッパーチップベースのセキュアな電話が使用された練習）よりも、参加者の声をエミュレートするために、より困難であろう。"
    },
    {
      "indent": 3,
      "text": "The S/MIME mechanism allows UAs to send encrypted requests without preamble if they possess a certificate for the destination address-of-record on their keyring. However, it is possible that any particular device registered for an address-of-record will not hold the certificate that has been previously employed by the device's current user, and that it will therefore be unable to process an encrypted request properly, which could lead to some avoidable error signaling. This is especially likely when an encrypted request is forked.",
      "ja": "S / MIMEメカニズムは、彼らが自分のキーリング上の宛先アドレス・オブ・レコードの証明書を持っている場合はUAがプリアンブルなしで暗号化されたリクエストを送信することができます。しかし、アドレス・オブ・レコードに登録された特定のデバイスは、以前に、デバイスの現在のユーザによって使用されてきた、そしてしたがって、適切に暗号化されたリクエストを処理することができなくなること、つながる可能性がある証明書を保持しない可能性がありますいくつかの回避エラー通知へ。暗号化されたリクエストがフォークされたときに、これは特にそうです。"
    },
    {
      "indent": 3,
      "text": "The keys associated with S/MIME are most useful when associated with a particular user (an address-of-record) rather than a device (a UA). When users move between devices, it may be difficult to transport private keys securely between UAs; how such keys might be acquired by a device is outside the scope of this document.",
      "ja": "特定のユーザ（アドレス・オブ・レコード）よりもむしろデバイス（UA）に関連付けられている場合、S / MIMEに関連したキーは、最も有用です。ユーザーがデバイス間で移動すると、しっかりとUAの間で秘密鍵を輸送することは困難です。デバイスによって取得される可能性がありますどのような鍵、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Another, more prosaic difficulty with the S/MIME mechanism is that it can result in very large messages, especially when the SIP tunneling mechanism described in Section 23.4 is used. For that reason, it is RECOMMENDED that TCP should be used as a transport protocol when S/MIME tunneling is employed.",
      "ja": "S / MIME機構を備えた別の、より多くの平凡な難しさは、23.4項で説明したSIPトンネリングメカニズムを使用する場合、それは特に、非常に大きなメッセージになることができるということです。そのためには、TCPは、S / MIMEトンネリングが使用されるトランスポートプロトコルとして使用することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "26.4.3 TLS",
      "section_title": true,
      "ja": "26.4.3 TLS"
    },
    {
      "indent": 3,
      "text": "The most commonly voiced concern about TLS is that it cannot run over UDP; TLS requires a connection-oriented underlying transport protocol, which for the purposes of this document means TCP.",
      "ja": "TLSについての最も一般的な声の懸念は、それがUDP上で実行することができないということです。 TLSは、このドキュメントの目的のためにTCPを意味コネクション指向の基本的なトランスポートプロトコルが必要です。"
    },
    {
      "indent": 3,
      "text": "It may also be arduous for a local outbound proxy server and/or registrar to maintain many simultaneous long-lived TLS connections with numerous UAs. This introduces some valid scalability concerns, especially for intensive ciphersuites. Maintaining redundancy of long-lived TLS connections, especially when a UA is solely responsible for their establishment, could also be cumbersome.",
      "ja": "また、多数のUAと同時に多数の長寿命TLS接続を維持するために、ローカルアウトバウンドプロキシサーバーおよび/またはレジストラのために骨の折れることがあります。これは特に集中的な暗号スイートのために、いくつかの有効なスケーラビリティの問題を紹介します。 UAは、その設立のための責任を負う場合は特に、長寿命のTLS接続の冗長性を維持し、また厄介である可能性があります。"
    },
    {
      "indent": 3,
      "text": "TLS only allows SIP entities to authenticate servers to which they are adjacent; TLS offers strictly hop-by-hop security. Neither TLS, nor any other mechanism specified in this document, allows clients to authenticate proxy servers to whom they cannot form a direct TCP connection.",
      "ja": "TLSはSIPエンティティは、それらが隣接している先のサーバを認証することができます。 TLSは厳密にホップバイホップのセキュリティを提供しています。どちらもTLS、また、この文書で指定された任意の他のメカニズムは、クライアントが直接TCPコネクションを形成することができない人にプロキシサーバを認証することができます。"
    },
    {
      "indent": 0,
      "text": "26.4.4 SIPS URIs",
      "section_title": true,
      "ja": "26.4.4 SIPS URIを"
    },
    {
      "indent": 3,
      "text": "Actually using TLS on every segment of a request path entails that the terminating UAS must be reachable over TLS (perhaps registering with a SIPS URI as a contact address). This is the preferred use of SIPS. Many valid architectures, however, use TLS to secure part of the request path, but rely on some other mechanism for the final hop to a UAS, for example. Thus SIPS cannot guarantee that TLS usage will be truly end-to-end. Note that since many UAs will not accept incoming TLS connections, even those UAs that do support TLS may be required to maintain persistent TLS connections as described in the TLS limitations section above in order to receive requests over TLS as a UAS.",
      "ja": "実際にリクエストパスのすべてのセグメントにTLSを使用する終端UASは、TLS（おそらくコンタクトアドレスとしてSIPS URIに登録）上に到達可能でなければならないことを必然的に伴います。これは、SIPSの好ましい使用です。多くの有効なアーキテクチャは、しかし、例えば、リクエストパスの一部を確保しますが、UASへの最後のホップのためのいくつかの他のメカニズムに依存するTLSを使用しています。したがってSIPSは、TLSの使用量が真にエンド・ツー・エンドであることを保証することはできません。多くのUAが着信TLS接続を受け入れないため、TLSをサポートしても、それらのUAがUASとしてTLSを超える要求を受信するために、上記のTLS制限の項で説明したように持続的なTLS接続を維持するために必要とされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Location services are not required to provide a SIPS binding for a SIPS Request-URI. Although location services are commonly populated by user registrations (as described in Section 10.2.1), various other protocols and interfaces could conceivably supply contact addresses for an AOR, and these tools are free to map SIPS URIs to SIP URIs as appropriate. When queried for bindings, a location service returns its contact addresses without regard for whether it received a request with a SIPS Request-URI. If a redirect server is accessing the location service, it is up to the entity that processes the Contact header field of a redirection to determine the propriety of the contact addresses.",
      "ja": "位置情報サービスは、SIPSのRequest-URIのための結合SIPSを提供する必要はありません。位置情報サービスは、一般ユーザの登録（セクション10.2.1に記載されているように）によって取り込まれるが、様々な他のプロトコルとインタフェースは考えAORの連絡先アドレスを供給することができ、そしてこれらのツールは、必要に応じてSIP URIにSIPS URIをマッピングして自由です。バインディングのために照会すると、ロケーションサービスは、SIPSのRequest-URIを持つリクエストを受信したか否かに関わらず、そのコンタクトアドレスを返します。リダイレクトサーバーは場所サービスにアクセスしている場合は、連絡先の可否を決定するために、リダイレクトのContactヘッダフィールドを処理するエンティティまでです。"
    },
    {
      "indent": 3,
      "text": "Ensuring that TLS will be used for all of the request segments up to the target domain is somewhat complex. It is possible that cryptographically authenticated proxy servers along the way that are non-compliant or compromised may choose to disregard the forwarding rules associated with SIPS (and the general forwarding rules in Section 16.6). Such malicious intermediaries could, for example, retarget a request from a SIPS URI to a SIP URI in an attempt to downgrade security.",
      "ja": "TLSは、ターゲットドメインまでのリクエストセグメントのすべてに使用されることを保証することは幾分複雑です。非準拠または損なわれる途中暗号認証プロキシサーバーは、SIPS（およびセクション16.6の一般的な転送ルール）に関連付けられている転送ルールを無視することを選択することが可能です。このような悪質な仲介業者は、例えば、セキュリティをダウングレードしようとする試みにはSIP URIにSIPS URIからの要求を再ターゲット可能性があります。"
    },
    {
      "indent": 3,
      "text": "Alternatively, an intermediary might legitimately retarget a request from a SIP to a SIPS URI. Recipients of a request whose Request-URI uses the SIPS URI scheme thus cannot assume on the basis of the Request-URI alone that SIPS was used for the entire request path (from the client onwards).",
      "ja": "あるいは、中間者は合法的にSIPS URIをSIPから要求をリターゲットかもしれません。リクエストURIは、このようSIPS URIスキームを使用してリクエストの受信者は、Request-URIのみSIPS全体リクエストパス（クライアントからの以降）のために使用されたことに基づいて想定することができません。"
    },
    {
      "indent": 3,
      "text": "To address these concerns, it is RECOMMENDED that recipients of a request whose Request-URI contains a SIP or SIPS URI inspect the To header field value to see if it contains a SIPS URI (though note that it does not constitute a breach of security if this URI has the same scheme but is not equivalent to the URI in the To header field). Although clients may choose to populate the Request-URI and To header field of a request differently, when SIPS is used this disparity could be interpreted as a possible security violation, and the request could consequently be rejected by its recipient. Recipients MAY also inspect the Via header chain in order to double-check whether or not TLS was used for the entire request path until the local administrative domain was reached. S/MIME may also be used by the originating UAC to help ensure that the original form of the To header field is carried end-to-end.",
      "ja": "これらの懸念に対処するためには、要求URIは、SIPが含まれているか、URIが、それがあれば、それはセキュリティの違反を構成しないことをSIPS URI（ただし、ノートが含まれているかどうかを確認するために、フィールドの値をToヘッダー検査SIPS要求の受信者ことが推奨されますこのURIは、同じスキームを有するが）フィールドをヘッダにURIと等価ではありません。クライアントが要求URIを移入すると、異なる要求のToヘッダーフィールドに選択することもできますがSIPSが使用されている場合、この格差は、可能なセキュリティ違反と解釈される可能性があり、その要求は、結果的にその受信者によって拒否される可能性があります。受信者はまた、ダブルチェックするために、ローカル管理ドメインに達するまでTLS全体リクエストパスに使用されたか否かを順にViaヘッダーチェーンを検査することができます。 S / MIMEはまた、Toヘッダーフィールドの元の形は、エンドツーエンドを担持していることを保証するために発信UACによって使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "If the UAS has reason to believe that the scheme of the Request-URI has been improperly modified in transit, the UA SHOULD notify its user of a potential security breach.",
      "ja": "UASが要求URIのスキームが不正に中に変更されたことを信じるに足る理由がある場合、UAは、潜在的なセキュリティ侵害のそのユーザに通知すべきです。"
    },
    {
      "indent": 3,
      "text": "As a further measure to prevent downgrade attacks, entities that accept only SIPS requests MAY also refuse connections on insecure ports.",
      "ja": "ダウングレード攻撃を防ぐためのさらなる対策として、受け入れるエンティティは、要求だけでも、安全でないポートでの接続を拒否することができSIPS。"
    },
    {
      "indent": 3,
      "text": "End users will undoubtedly discern the difference between SIPS and SIP URIs, and they may manually edit them in response to stimuli. This can either benefit or degrade security. For example, if an attacker corrupts a DNS cache, inserting a fake record set that effectively removes all SIPS records for a proxy server, then any SIPS requests that traverse this proxy server may fail. When a user, however, sees that repeated calls to a SIPS AOR are failing, they could on some devices manually convert the scheme from SIPS to SIP and retry. Of course, there are some safeguards against this (if the destination UA is truly paranoid it could refuse all non-SIPS requests), but it is a limitation worth noting. On the bright side, users might also divine that 'SIPS' would be valid even when they are presented only with a SIP URI.",
      "ja": "エンドユーザーは間違いなくSIPSとSIP URIの違いを識別し、それらを手動で刺激に応答して、それらを編集することができます。これは、利益やセキュリティを低下させることができます。攻撃者が効果的にすべてのプロキシサーバーのレコードを削除するSIPS偽のレコードセットを挿入し、DNSキャッシュが破損した場合、その後、このプロキシサーバーを通過するすべてのSIPS要求が失敗することがあります。ユーザーは、しかし、SIPS AORを繰り返し呼び出しが失敗していることを確認すると、彼らはいくつかのデバイス上で手動でSIPおよび再試行するSIPSからスキームを変換することができます。もちろん、そこにこのに対するいくつかのセーフガードは、（先UAが真に偏執的であれば、それはすべての非SIPS要求を拒否することができ）ですが、それは注目に値する制限です。明るい側では、ユーザーが「SIPS」ということも、神の彼らは唯一のSIP URIを提示されている場合でも有効になりかもしれません。"
    },
    {
      "indent": 0,
      "text": "26.5 Privacy",
      "section_title": true,
      "ja": "26.5プライバシー"
    },
    {
      "indent": 3,
      "text": "SIP messages frequently contain sensitive information about their senders - not just what they have to say, but with whom they communicate, when they communicate and for how long, and from where they participate in sessions. Many applications and their users require that this sort of private information be hidden from any parties that do not need to know it.",
      "ja": "SIPメッセージが頻繁に送信者に関する機密情報が含まれている - だけではなく、彼らが言っているか、彼らが通信するとき、彼らは通信誰と、どのように長い間、彼らは、セッションに参加し、そこから。多くのアプリケーションとそのユーザーは、個人情報のこの種のは、それを知っている必要はありませんどの政党から隠されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that there are also less direct ways in which private information can be divulged. If a user or service chooses to be reachable at an address that is guessable from the person's name and organizational affiliation (which describes most addresses-of-record), the traditional method of ensuring privacy by having an unlisted \"phone number\" is compromised. A user location service can infringe on the privacy of the recipient of a session invitation by divulging their specific whereabouts to the caller; an implementation consequently SHOULD be able to restrict, on a per-user basis, what kind of location and availability information is given out to certain classes of callers. This is a whole class of problem that is expected to be studied further in ongoing SIP work.",
      "ja": "また、個人情報を公表することができるあまり直接的な方法があることに注意してください。ユーザやサービスが、人の名前と（ほとんどのアドレス・オブ・レコードを記述する）所属組織から推測可能であるアドレスに到達可能であることを選択した場合、非上場の「電話番号」を有することで、プライバシーを確​​保する伝統的な方法が危険にさらされています。ユーザーロケーションサービスは、発信者への具体的な所在を明かすことにより、セッション招待の受信者のプライバシーを侵害することができます。実装は、結果として発信者の特定のクラスに配られる位置および可用性情報の種類、ユーザごとに、制限することができるべきです。これは、現在進行中のSIPの仕事にさらに研究することが期待されている問題のクラス全体です。"
    },
    {
      "indent": 3,
      "text": "In some cases, users may want to conceal personal information in header fields that convey identity. This can apply not only to the From and related headers representing the originator of the request, but also the To - it may not be appropriate to convey to the final destination a speed-dialing nickname, or an unexpanded identifier for a group of targets, either of which would be removed from the Request-URI as the request is routed, but not changed in the To header field if the two were initially identical. Thus it MAY be desirable for privacy reasons to create a To header field that differs from the Request-URI.",
      "ja": "いくつかのケースでは、ユーザーが身元を伝えるヘッダフィールドに個人情報を隠すためにしたいことがあります。これは、要求の発信元を示すFromおよび関連するヘッダに限らず適用することができるだけでなく、ために - 最終的な宛先スピードダイヤルニックネーム、またはターゲットのグループのために拡張されていない識別子に伝えることが適切ではないかもしれません、要求がルーティングされるが、両者が最初に同一であった場合、そのフィールドをヘッダーに変更されないようにそのいずれかは、Request-URIから除去されます。プライバシーの理由がRequest-URIと異なるToヘッダーフィールドを作成するためしたがって、望ましいかもしれません。"
    },
    {
      "indent": 0,
      "text": "27 IANA Considerations",
      "ja": "27のIANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "All method names, header field names, status codes, and option tags used in SIP applications are registered with IANA through instructions in an IANA Considerations section in an RFC.",
      "ja": "SIPアプリケーションで使用されるすべてのメソッド名、ヘッダフィールド名、ステータスコード、およびオプションタグは、RFCでIANA Considerations部の指示を通じてIANAに登録されています。"
    },
    {
      "indent": 3,
      "text": "The specification instructs the IANA to create four new sub-registries under http://www.iana.org/assignments/sip-parameters: Option Tags, Warning Codes (warn-codes), Methods and Response Codes, added to the sub-registry of Header Fields that is already present there.",
      "ja": "仕様はhttp://www.iana.org/assignments/sip-parameters下4新しいサブレジストリを作成するために、IANAに指示します。オプションタグを、コードの警告（警告-コード）、メソッドと応答コード、サブに追加そこに既に存在しているヘッダフィールドのレジストリ。"
    },
    {
      "indent": 0,
      "text": "27.1 Option Tags",
      "section_title": true,
      "ja": "27.1オプションタグ"
    },
    {
      "indent": 3,
      "text": "This specification establishes the Option Tags sub-registry under http://www.iana.org/assignments/sip-parameters.",
      "ja": "この仕様はhttp://www.iana.org/assignments/sip-parameters下のオプションタグのサブレジストリを確立します。"
    },
    {
      "indent": 3,
      "text": "Option tags are used in header fields such as Require, Supported, Proxy-Require, and Unsupported in support of SIP compatibility mechanisms for extensions (Section 19.2). The option tag itself is a string that is associated with a particular SIP option (that is, an extension). It identifies the option to SIP endpoints.",
      "ja": "オプションタグがサポートされている、プロキシ必要とし、拡張のためのSIP互換性メカニズムのサポート（セクション19.2）でサポートされていない、そのような必要とするヘッダフィールドに使用されます。オプションタグ自体は、特定のSIPオプション（すなわち、拡張）に関連付けられた文字列です。これは、SIPエンドポイントにするオプションを識別します。"
    },
    {
      "indent": 3,
      "text": "Option tags are registered by the IANA when they are published in standards track RFCs. The IANA Considerations section of the RFC must include the following information, which appears in the IANA registry along with the RFC number of the publication.",
      "ja": "それらは標準トラックRFCで公開されているとき、オプションタグはIANAによって登録されています。 RFCのIANA条項のセクションでは、出版物のRFC番号とともに、IANAレジストリに表示される次の情報を含める必要があります。"
    },
    {
      "indent": 6,
      "text": "o Name of the option tag. The name MAY be of any length, but SHOULD be no more than twenty characters long. The name MUST consist of alphanum (Section 25) characters only.",
      "ja": "オプションタグのO名前。名前は、任意の長さであり得るが、これ以上20文字以下に長くなければなりません。名前はalphanum（第25条）文字のみで構成する必要があります。"
    },
    {
      "indent": 6,
      "text": "o Descriptive text that describes the extension.",
      "ja": "拡張機能を説明する説明テキストを、O。"
    },
    {
      "indent": 0,
      "text": "27.2 Warn-Codes",
      "section_title": true,
      "ja": "27.2警告する - コード"
    },
    {
      "indent": 3,
      "text": "This specification establishes the Warn-codes sub-registry under http://www.iana.org/assignments/sip-parameters and initiates its population with the warn-codes listed in Section 20.43. Additional warn-codes are registered by RFC publication.",
      "ja": "この仕様はhttp://www.iana.org/assignments/sip-parametersの下で警告し、コードのサブレジストリを確立し、セクション20.43に記載されている警告-コードと人口を開始します。追加の警告-コードはRFC刊行物によって登録されています。"
    },
    {
      "indent": 3,
      "text": "The descriptive text for the table of warn-codes is:",
      "ja": "警告 - コード表の説明テキストは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Warning codes provide information supplemental to the status code in SIP response messages when the failure of the transaction results from a Session Description Protocol (SDP) (RFC 2327 [1]) problem.",
      "ja": "トランザクションの失敗はセッション記述プロトコル（SDP）（RFC 2327 [1]）の問題に起因する場合、警告コードは、SIP応答メッセージのステータスコードへの情報の補足を提供します。"
    },
    {
      "indent": 3,
      "text": "The \"warn-code\" consists of three digits. A first digit of \"3\" indicates warnings specific to SIP. Until a future specification describes uses of warn-codes other than 3xx, only 3xx warn-codes may be registered.",
      "ja": "「警告コード」は、3桁の数字で構成されています。 「3」の最初の桁は、SIPに固有の警告を示しています。将来の仕様が3XX以外の警告、コードの使用を説明するまで、唯一3XX-コードを警告登録されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Warnings 300 through 329 are reserved for indicating problems with keywords in the session description, 330 through 339 are warnings related to basic network services requested in the session description, 370 through 379 are warnings related to quantitative QoS parameters requested in the session description, and 390 through 399 are miscellaneous warnings that do not fall into one of the above categories.",
      "ja": "警告300 329を介しては、379を介して、370はセッション記述で要求された定量的なQoSパラメータに関する警告であり、390、339を介して、330はセッション記述で要求された基本的なネットワークサービスに関連する警告され、セッション記述のキーワードの問題を示すために予約されています399を通じて上記のいずれかのカテゴリに分類されないその他の警告です。"
    },
    {
      "indent": 0,
      "text": "27.3 Header Field Names",
      "section_title": true,
      "ja": "27.3ヘッダーフィールド名"
    },
    {
      "indent": 3,
      "text": "This obsoletes the IANA instructions about the header sub-registry under http://www.iana.org/assignments/sip-parameters.",
      "ja": "これはhttp://www.iana.org/assignments/sip-parameters下のヘッダーサブレジストリに関するIANAの指示を廃止します。"
    },
    {
      "indent": 3,
      "text": "The following information needs to be provided in an RFC publication in order to register a new header field name:",
      "ja": "以下の情報は、新たなヘッダフィールド名を登録するためにRFCの刊行物に提供される必要があります。"
    },
    {
      "indent": 6,
      "text": "o The RFC number in which the header is registered;",
      "ja": "ヘッダが登録されているRFC番号がOであり;"
    },
    {
      "indent": 6,
      "text": "o the name of the header field being registered;",
      "ja": "Oヘッダフィールドの名前が登録されています。"
    },
    {
      "indent": 6,
      "text": "o a compact form version for that header field, if one is defined;",
      "ja": "そのヘッダフィールドのコンパクト形バージョンO、が定義されている場合、"
    },
    {
      "indent": 3,
      "text": "Some common and widely used header fields MAY be assigned one-letter compact forms (Section 7.3.3). Compact forms can only be assigned after SIP working group review, followed by RFC publication.",
      "ja": "いくつかの一般的な、広く使用されるヘッダフィールドを割り当てることができる一文字コンパクトな形態（セクション7.3.3）。コンパクトなフォームは唯一のRFCの公表に続いてSIPワーキンググループの検討、後に割り当てることができます。"
    },
    {
      "indent": 0,
      "text": "27.4 Method and Response Codes",
      "section_title": true,
      "ja": "27.4メソッドと応答コード"
    },
    {
      "indent": 3,
      "text": "This specification establishes the Method and Response-Code sub-registries under http://www.iana.org/assignments/sip-parameters and initiates their population as follows. The initial Methods table is:",
      "ja": "この仕様はhttp://www.iana.org/assignments/sip-parameters下法と応答コードのサブレジストリを確立し、以下のように彼らの人口を開始します。最初のメソッドテーブルは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "INVITE                   [RFC3261]\nACK                      [RFC3261]\nBYE                      [RFC3261]\nCANCEL                   [RFC3261]\nREGISTER                 [RFC3261]\nOPTIONS                  [RFC3261]\nINFO                     [RFC2976]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The response code table is initially populated from Section 21, the portions labeled Informational, Success, Redirection, Client-Error, Server-Error, and Global-Failure. The table has the following format:",
      "ja": "応答コードの表は当初、第21からの情報、成功、リダイレクト、クライアントエラー、サーバーエラー、およびグローバル失敗ラベルされた部分を埋めています。表の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Type (e.g., Informational) Number Default Reason Phrase [RFC3261]",
      "ja": "タイプ（例えば、情報）番号デフォルト理由句[RFC3261]"
    },
    {
      "indent": 3,
      "text": "The following information needs to be provided in an RFC publication in order to register a new response code or method:",
      "ja": "以下の情報は、新しい応答コードまたはメソッドを登録するためにRFCの刊行物に提供される必要があります。"
    },
    {
      "indent": 6,
      "text": "o The RFC number in which the method or response code is registered;",
      "ja": "メソッド又は応答コードが登録されているRFC番号O;"
    },
    {
      "indent": 6,
      "text": "o the number of the response code or name of the method being registered;",
      "ja": "登録されている方法のレスポンスコードまたは名前の数O;"
    },
    {
      "indent": 6,
      "text": "o the default reason phrase for that response code, if applicable;",
      "ja": "その応答コードのデフォルトの理由フレーズO、該当する場合。"
    },
    {
      "indent": 0,
      "text": "27.5 The \"message/sip\" MIME type.",
      "section_title": true,
      "ja": "27.5「メッセージ/一口」MIMEタイプ。"
    },
    {
      "indent": 3,
      "text": "This document registers the \"message/sip\" MIME media type in order to allow SIP messages to be tunneled as bodies within SIP, primarily for end-to-end security purposes. This media type is defined by the following information:",
      "ja": "この文書では、主にエンドツーエンドのセキュリティ上の目的のために、SIPメッセージがSIP内のボディとしてトンネルされることを可能にするために「メッセージ/一口」MIMEメディアタイプを登録します。このメディアタイプは、以下の情報によって定義されます。"
    },
    {
      "indent": 6,
      "text": "Media type name: message Media subtype name: sip Required parameters: none",
      "ja": "メディアの種類名：メッセージメディアサブタイプ名：SIP必須パラメータ：なし"
    },
    {
      "indent": 6,
      "text": "Optional parameters: version version: The SIP-Version number of the enclosed message (e.g., \"2.0\"). If not present, the version defaults to \"2.0\". Encoding scheme: SIP messages consist of an 8-bit header optionally followed by a binary MIME data object. As such, SIP messages must be treated as binary. Under normal circumstances SIP messages are transported over binary-capable transports, no special encodings are needed.",
      "ja": "オプションパラメータ：バージョンバージョン：同封のメッセージのSIP-バージョン番号（例えば、「2.0」）。存在しない場合は、「2.0」にバージョンをデフォルトとします。符号化方式：SIPメッセージは、任意のバイナリMIMEデータオブジェクトに続く8ビットのヘッダから成ります。このように、SIPメッセージはバイナリとして扱われなければなりません。通常の状況下では、SIPメッセージはバイナリ対応のトランスポート上で搬送され、特別なエンコードは必要ありません。"
    },
    {
      "indent": 6,
      "text": "Security considerations: see below Motivation and examples of this usage as a security mechanism in concert with S/MIME are given in 23.4.",
      "ja": "セキュリティの考慮事項：S / MIMEと協調して、セキュリティ・メカニズムとして動機とこの使用例下記参照は23.4に記載されています。"
    },
    {
      "indent": 0,
      "text": "27.6 New Content-Disposition Parameter Registrations",
      "section_title": true,
      "ja": "27.6新規コンテンツ・処分のパラメータ登録"
    },
    {
      "indent": 3,
      "text": "This document also registers four new Content-Disposition header \"disposition-types\": alert, icon, session and render. The authors request that these values be recorded in the IANA registry for Content-Dispositions.",
      "ja": "警告、アイコン、セッションおよびレンダリング：この文書は、4つの新しいコンテンツ-Dispositionヘッダー「処分・タイプ」を登録します。著者らは、これらの値は、Content-処分のためのIANAレジストリに記録されることを要求します。"
    },
    {
      "indent": 3,
      "text": "Descriptions of these \"disposition-types\", including motivation and examples, are given in Section 20.11.",
      "ja": "モチベーションと例を含め、これらの「処分・タイプ」の説明は、セクション20.11に記載されています。"
    },
    {
      "indent": 3,
      "text": "Short descriptions suitable for the IANA registry are:",
      "ja": "IANAレジストリに適した短い説明は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "alert the body is a custom ring tone to alert the user icon the body is displayed as an icon to the user render the body should be displayed to the user session the body describes a communications session, for example, as RFC 2327 SDP body",
      "ja": "体が身体をレンダリングする本体は、ユーザにアイコンとして表示されているユーザーのアイコンを警告するためのカスタム着信音で警告の体はRFC 2327 SDP体として、例えば、通信セッションを記述するユーザーセッションに表示されるべきです"
    },
    {
      "indent": 1,
      "text": "28 Changes From",
      "ja": "28の変更から"
    },
    {
      "indent": 3,
      "text": "This RFC revises RFC 2543. It is mostly backwards compatible with RFC 2543. The changes described here fix many errors discovered in RFC 2543 and provide information on scenarios not detailed in RFC 2543. The protocol has been presented in a more cleanly layered model here.",
      "ja": "このRFCは、それはここで説明する変更は、RFC 2543で発見された多くのエラーを修正したプロトコルは、ここでよりきれいに階層モデルで提示されたRFC 2543に詳述されていないシナリオについての情報を提供し、主に後方互換性RFC 2543であるRFC 2543を改訂します。"
    },
    {
      "indent": 3,
      "text": "We break the differences into functional behavior that is a substantial change from RFC 2543, which has impact on interoperability or correct operation in some cases, and functional behavior that is different from RFC 2543 but not a potential source of interoperability problems. There have been countless clarifications as well, which are not documented here.",
      "ja": "私たちは、RFC 2543と異なるいくつかのケースでは、相互運用性や正しい動作に影響を与えているRFC 2543からの実質的な変化であり、機能的行動、および機能の動作に違いはなく、相互運用性の問題の潜在的な供給源を破ります。ここに記載されていない無数の明確化だけでなく、ありました。"
    },
    {
      "indent": 0,
      "text": "28.1 Major Functional Changes",
      "section_title": true,
      "ja": "28.1主な機能の変更"
    },
    {
      "indent": 3,
      "text": "o When a UAC wishes to terminate a call before it has been answered, it sends CANCEL. If the original INVITE still returns a 2xx, the UAC then sends BYE. BYE can only be sent on an existing call leg (now called a dialog in this RFC), whereas it could be sent at any time in RFC 2543.",
      "ja": "UACは、それが回答されている前に、通話を終了したい場合は、O、それはCANCELを送信します。元がINVITEまだの2xxを返す場合、UACは、BYEを送信します。それはRFC 2543でいつでも送ることができたBYEは、（今、このRFCでダイアログと呼ばれる）は、既存のコールレッグに送信することができます。"
    },
    {
      "indent": 3,
      "text": "o The SIP BNF was converted to be RFC 2234 compliant.",
      "ja": "oをSIP BNFは、RFC 2234に準拠するように変換しました。"
    },
    {
      "indent": 3,
      "text": "o SIP URL BNF was made more general, allowing a greater set of characters in the user part. Furthermore, comparison rules were simplified to be primarily case-insensitive, and detailed handling of comparison in the presence of parameters was described. The most substantial change is that a URI with a parameter with the default value does not match a URI without that parameter.",
      "ja": "O SIP URL BNFは、ユーザ部分における文字の大きなセットを可能にする、より一般的な製造しました。また、比較ルールは、主に大文字と小文字を区別しないことに簡略化し、パラメータの存在下での比較の詳細な処理について説明しました。最も実質的な変化は、デフォルト値を持つパラメータを持つURIは、そのパラメータなしでURIと一致していないということです。"
    },
    {
      "indent": 3,
      "text": "o Removed Via hiding. It had serious trust issues, since it relied on the next hop to perform the obfuscation process. Instead, Via hiding can be done as a local implementation choice in stateful proxies, and thus is no longer documented.",
      "ja": "O隠れ介して除去。それは難読化プロセスを実行するために、次のホップに頼っていたので、それは、深刻な信用問題がありました。代わりに、隠れ経由ステートフルプロキシでローカルの導入選択肢として行わないことができるので、もはや文書化されています。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, CANCEL and INVITE transactions were intermingled. They are separated now. When a user sends an INVITE and then a CANCEL, the INVITE transaction still terminates normally. A UAS needs to respond to the original INVITE request with a 487 response.",
      "ja": "O RFC 2543では、CANCELと取引が混在されたINVITE。彼らは今、分離されています。ユーザーはINVITE、その後キャンセル送信すると、INVITEトランザクションは正常に終了します。 UASは487応答で、元のINVITE要求に応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Similarly, CANCEL and BYE transactions were intermingled; RFC 2543 allowed the UAS not to send a response to INVITE when a BYE was received. That is disallowed here. The original INVITE needs a response.",
      "ja": "O同様に、CANCELとBYEトランザクションが混在しました。 RFC 2543は、BYEを受信したとき、INVITEへの応答を送信しないUASを可能にしました。それはここで許可されていません。オリジナルのINVITEは応答を必要とします。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, UAs needed to support only UDP. In this RFC, UAs need to support both UDP and TCP.",
      "ja": "RFC 2543でoが、UAはUDPのみをサポートするために必要。このRFCでは、UAはUDPとTCPの両方をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, a forking proxy only passed up one challenge from downstream elements in the event of multiple challenges. In this RFC, proxies are supposed to collect all challenges and place them into the forwarded response.",
      "ja": "O RFC 2543では、フォークプロキシは、複数の課題が発生した場合に下流の要素から1つの挑戦して合格します。このRFCでは、プロキシはすべての課題を収集し、転送応答にそれらを置くことになっています。"
    },
    {
      "indent": 3,
      "text": "o In Digest credentials, the URI needs to be quoted; this is unclear from RFC 2617 and RFC 2069 which are both inconsistent on it.",
      "ja": "ダイジェスト資格情報中のO、URIは引用符で囲む必要があります。これはRFC 2617とRFCの両方それに矛盾している2069年からは不明です。"
    },
    {
      "indent": 3,
      "text": "o SDP processing has been split off into a separate specification [13], and more fully specified as a formal offer/answer exchange process that is effectively tunneled through SIP. SDP is allowed in INVITE/200 or 200/ACK for baseline SIP implementations; RFC 2543 alluded to the ability to use it in INVITE, 200, and ACK in a single transaction, but this was not well specified. More complex SDP usages are allowed in extensions.",
      "ja": "O SDP処理は、別個の仕様[13]に離脱、およびより完全に有効SIPを介してトンネリングされ、正式なオファー/アンサー交換処理として指定されています。 SDPは、ベースラインSIP実装のためのINVITE / 200または200 / ACKで許可されています。 RFC 2543は、INVITEでそれを使用できることをほのめかし200、およびACK単一のトランザクションで、これはうまく指定されていませんでした。より複雑なSDPの用法が拡張で許可されています。"
    },
    {
      "indent": 3,
      "text": "o Added full support for IPv6 in URIs and in the Via header field. Support for IPv6 in Via has required that its header field parameters allow the square bracket and colon characters. These characters were previously not permitted. In theory, this could cause interop problems with older implementations. However, we have observed that most implementations accept any non-control ASCII character in these parameters.",
      "ja": "OのURIにとViaヘッダーフィールドにIPv6のフルサポートを追加しました。経由でのIPv6のサポートは、そのヘッダフィールドのパラメータは、角括弧とコロン文字を許可することを必要としていました。これらの文字は、以前に許可されませんでした。理論的には、これは古い実装との相互運用上の問題を引き起こす可能性があります。しかし、私たちは、ほとんどの実装は、これらのパラメータのいずれかの非制御ASCII文字を受け入れることを観察しました。"
    },
    {
      "indent": 3,
      "text": "o DNS SRV procedure is now documented in a separate specification [4]. This procedure uses both SRV and NAPTR resource records and no longer combines data from across SRV records as described in RFC 2543.",
      "ja": "OのDNS SRV手順が今別明細書に記載されている[4]。この手順は、SRVとNAPTRリソースレコードの両方を使用していないし、RFC 2543で説明したように、もはやSRVレコード全体からのデータを組み合わせています。"
    },
    {
      "indent": 3,
      "text": "o Loop detection has been made optional, supplanted by a mandatory usage of Max-Forwards. The loop detection procedure in RFC 2543 had a serious bug which would report \"spirals\" as an error condition when it was not. The optional loop detection procedure is more fully and correctly specified here.",
      "ja": "Oループ検出は、Max-フォワードの必須の使用に取って代わられ、任意なされたものです。 RFC 2543でのループ検出手順は、それがなかったときにエラー条件として「スパイラル」を報告する重大なバグがありました。オプションのループ検出手順より完全かつ正確にここで指定しています。"
    },
    {
      "indent": 3,
      "text": "o Usage of tags is now mandatory (they were optional in RFC 2543), as they are now the fundamental building blocks of dialog identification.",
      "ja": "Oタグの使用方法は、彼らが今ダイアログ識別の基本的なビルディングブロックですとして、（彼らはRFC 2543でオプションだった）今は必須です。"
    },
    {
      "indent": 3,
      "text": "o Added the Supported header field, allowing for clients to indicate what extensions are supported to a server, which can apply those extensions to the response, and indicate their usage with a Require in the response.",
      "ja": "Oの拡張機能は、応答にこれらの拡張子を適用することができ、サーバにサポートされているものを示すために、クライアントのためにできるように、サポートされているヘッダフィールドを追加し、それに応答して必要とそれらの使用法を示しています。"
    },
    {
      "indent": 3,
      "text": "o Extension parameters were missing from the BNF for several header fields, and they have been added.",
      "ja": "O拡張パラメータは、いくつかのヘッダフィールドのBNFから欠落し、そしてそれらが追加されています。"
    },
    {
      "indent": 3,
      "text": "o Handling of Route and Record-Route construction was very underspecified in RFC 2543, and also not the right approach. It has been substantially reworked in this specification (and made vastly simpler), and this is arguably the largest change. Backwards compatibility is still provided for deployments that do not use \"pre-loaded routes\", where the initial request has a set of Route header field values obtained in some way outside of Record-Route. In those situations, the new mechanism is not interoperable.",
      "ja": "ルートおよびRecord-ルート建設のO処理は非常に正しいアプローチをRFC 2543でunderspecifiedさ、ともされませんでした。これは、実質的にこの仕様で再加工（と大幅に簡素化）、これは間違いなく最大の変化ですされています。後方互換性は依然として初期要求がレコードルートの外側のいくつかの方法で得られたRouteヘッダーフィールド値のセットを有する場合、「プリロードされたルートを」使用しない展開のために提供されます。そのような状況では、新しいメカニズムは相互運用性がありません。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, lines in a message could be terminated with CR, LF, or CRLF. This specification only allows CRLF.",
      "ja": "O RFC 2543で、メッセージの行はCR、LF、またはCRLFで終了することができます。この仕様は、CRLFを可能にします。"
    },
    {
      "indent": 3,
      "text": "o Usage of Route in CANCEL and ACK was not well defined in RFC 2543. It is now well specified; if a request had a Route header field, its CANCEL or ACK for a non-2xx response to the request need to carry the same Route header field values. ACKs for 2xx responses use the Route values learned from the Record-Route of the 2xx responses.",
      "ja": "ルートのOの使用中にCANCELとACKがうまくそれが今も指定されているRFC 2543で定義されていませんでした。リクエストがRouteヘッダーフィールドを有する場合、そのCANCELまたは要求に非の2xx応答に対するACKは同じRouteヘッダーフィールド値を伝送する必要があります。 2XX応答のためのACKは2xx応答の録音-ルートから学んだルート値を使用します。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 allowed multiple requests in a single UDP packet. This usage has been removed.",
      "ja": "O RFC 2543は、単一のUDPパケットで複数の要求を可能にしました。この用法は削除されました。"
    },
    {
      "indent": 3,
      "text": "o Usage of absolute time in the Expires header field and parameter has been removed. It caused interoperability problems in elements that were not time synchronized, a common occurrence. Relative times are used instead.",
      "ja": "ヘッダーフィールドとパラメータを有効期限内の絶対時間のOの使用は、除去されています。これは、一般的な発生を時間同期されていなかった要素における相互運用性の問題を引き起こしました。相対時間が代わりに使用されています。"
    },
    {
      "indent": 3,
      "text": "o The branch parameter of the Via header field value is now mandatory for all elements to use. It now plays the role of a unique transaction identifier. This avoids the complex and bug-laden transaction identification rules from RFC 2543. A magic cookie is used in the parameter value to determine if the previous hop has made the parameter globally unique, and comparison falls back to the old rules when it is not present. Thus, interoperability is assured.",
      "ja": "Viaヘッダーフィールド値の分岐パラメータoを今、すべての要素が使用するために必須です。今では独自のトランザクション識別子の役割を果たしています。これはマジッククッキーが前のホップは、パラメータはグローバルに一意てきた、それが存在しない場合に比較が戻って古いルールに該当するかどうかを判断するためのパラメータ値に使用されているRFC 2543から、複雑でバグを含んだトランザクション識別ルールを回避します。このように、相互運用性が保証されています。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, closure of a TCP connection was made equivalent to a CANCEL. This was nearly impossible to implement (and wrong) for TCP connections between proxies. This has been eliminated, so that there is no coupling between TCP connection state and SIP processing.",
      "ja": "O RFC 2543では、TCPコネクションの閉鎖はCANCELに相当しました。これは、プロキシ間のTCP接続のためのほとんどを実装することは不可能（間違った）でした。これは、TCP接続状態とSIP処理の間に結合が存在しないように、除去されています。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 was silent on whether a UA could initiate a new transaction to a peer while another was in progress. That is now specified here. It is allowed for non-INVITE requests, disallowed for INVITE.",
      "ja": "OのRFC 2543は、他の進行中にUAがピアに新しいトランザクションを開始することができるかどうかについては言及しました。それは今ここに指定されています。それは、INVITEのために許可されていない非INVITE要求、許可されます。"
    },
    {
      "indent": 3,
      "text": "o PGP was removed. It was not sufficiently specified, and not compatible with the more complete PGP MIME. It was replaced with S/MIME.",
      "ja": "O PGPを除去しました。それは十分に指定されていない、そしてより完全なPGPのMIMEに対応していませんでした。これは、S / MIMEと交換しました。"
    },
    {
      "indent": 3,
      "text": "o Added the \"sips\" URI scheme for end-to-end TLS. This scheme is not backwards compatible with RFC 2543. Existing elements that receive a request with a SIPS URI scheme in the Request-URI will likely reject the request. This is actually a feature; it ensures that a call to a SIPS URI is only delivered if all path hops can be secured.",
      "ja": "OエンドツーエンドのTLSのための「一口」URIスキームを追加しました。このスキームは、Request-URIにSIPS URIスキームでリクエストを受け取る2543既存の要素がありそうな要求を拒否しますRFCとの下位互換性がありません。これは、実際の機能です。それは、すべてのパスのホップが確保できればSIPS URIへのコールがのみ配信されることを保証します。"
    },
    {
      "indent": 3,
      "text": "o Additional security features were added with TLS, and these are described in a much larger and complete security considerations section.",
      "ja": "O追加のセキュリティ機能は、TLSを添加し、これらは非常に大きく、完全なセキュリティの考慮事項セクションに記載されています。"
    },
    {
      "indent": 3,
      "text": "o In RFC 2543, a proxy was not required to forward provisional responses from 101 to 199 upstream. This was changed to MUST. This is important, since many subsequent features depend on delivery of all provisional responses from 101 to 199.",
      "ja": "O RFC 2543で、プロキシは101から199の上流に暫定応答を転送するために必要ではなかったです。これはMUSTに変更されました。その後の多くの機能が101から199までのすべての暫定応答の配信に依存するため、これは重要です。"
    },
    {
      "indent": 3,
      "text": "o Little was said about the 503 response code in RFC 2543. It has since found substantial use in indicating failure or overload conditions in proxies. This requires somewhat special treatment. Specifically, receipt of a 503 should trigger an attempt to contact the next element in the result of a DNS SRV lookup. Also, 503 response is only forwarded upstream by a proxy under certain conditions.",
      "ja": "Oほとんどは、それが以来、プロキシの故障や過負荷条件を示すの実質的使用が見出されているRFC 2543に503応答コードについて語りました。これは、やや特殊な処理を必要とします。具体的には、503の受信は、DNS SRVルックアップの結果で次の要素に連絡しようとする試みをトリガーする必要があります。また、503応答は、特定の条件下でのみプロキシによってアップストリームに転送されます。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 defined, but did no sufficiently specify, a mechanism for UA authentication of a server. That has been removed. Instead, the mutual authentication procedures of RFC 2617 are allowed.",
      "ja": "O RFC 2543が定義されていますが、何十分、サーバーのUA認証のためのメカニズムを指定しませんでした。それは削除されました。その代わり、RFC 2617の相互認証手続きが許可されています。"
    },
    {
      "indent": 3,
      "text": "o A UA cannot send a BYE for a call until it has received an ACK for the initial INVITE. This was allowed in RFC 2543 but leads to a potential race condition.",
      "ja": "それは初期のINVITEに対するACKを受信するまで、O UAは、コールのためにBYEを送信することはできません。これは、RFC 2543で許可されるが、潜在的な競合状態につながるました。"
    },
    {
      "indent": 3,
      "text": "o A UA or proxy cannot send CANCEL for a transaction until it gets a provisional response for the request. This was allowed in RFC 2543 but leads to potential race conditions.",
      "ja": "O UAまたはプロキシは、リクエストのための暫定応答を取得するまでのトランザクションのために送信キャンセルすることはできません。これは、RFC 2543で許可されるが、潜在的な競合状態につながるました。"
    },
    {
      "indent": 3,
      "text": "o The action parameter in registrations has been deprecated. It was insufficient for any useful services, and caused conflicts when application processing was applied in proxies.",
      "ja": "O登録におけるactionパラメータは廃止されました。これは、任意の有用なサービスには不十分だった、とアプリケーション処理がプロキシに適用されたとき、競合を引き起こしました。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 had a number of special cases for multicast. For example, certain responses were suppressed, timers were adjusted, and so on. Multicast now plays a more limited role, and the protocol operation is unaffected by usage of multicast as opposed to unicast. The limitations as a result of that are documented.",
      "ja": "OのRFC 2543は、マルチキャスト用の特殊なケースの数を持っていました。例えば、特定の応答がようにタイマーを調整し、抑制し、そしてました。マルチキャストについて、より限定された役割を果たし、ユニキャストとは対照的に、プロトコルの動作は、マルチキャストの使用によって影響されません。その結果として、制限が文書化されています。"
    },
    {
      "indent": 3,
      "text": "o Basic authentication has been removed entirely and its usage forbidden.",
      "ja": "O基本認証が完全に除去され、その使用が禁止されました。"
    },
    {
      "indent": 3,
      "text": "o Proxies no longer forward a 6xx immediately on receiving it. Instead, they CANCEL pending branches immediately. This avoids a potential race condition that would result in a UAC getting a 6xx followed by a 2xx. In all cases except this race condition, the result will be the same - the 6xx is forwarded upstream.",
      "ja": "Oプロキシもはや前方の6xxすぐにそれを受信します。代わりに、彼らはすぐに保留中の枝をキャンセル。これは、UACは2xxの続いた6xxを得ることにつながる可能性のある競合状態を避けることができます。この競合状態を除くすべての場合において、結果は同じになります - の6xxをアップストリームに転送されます。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 did not address the problem of request merging. This occurs when a request forks at a proxy and later rejoins at an element. Handling of merging is done only at a UA, and procedures are defined for rejecting all but the first request.",
      "ja": "O RFC 2543は、要求のマージの問題に対応していませんでした。リクエストフォークプロキシで、後は、要素に再加入する場合に発生します。マージの取扱いは、UAでのみ行われ、手続きは、最初の要求以外のすべてを拒否するために定義されています。"
    },
    {
      "indent": 0,
      "text": "28.2 Minor Functional Changes",
      "section_title": true,
      "ja": "28.2マイナー機能の変更"
    },
    {
      "indent": 3,
      "text": "o Added the Alert-Info, Error-Info, and Call-Info header fields for optional content presentation to users.",
      "ja": "oは、ユーザーにオプションのコンテンツ提示のためのアラート情報、エラー-情報、およびCall-Infoヘッダーフィールドを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added the Content-Language, Content-Disposition and MIME-Version header fields.",
      "ja": "O含有量言語、コンテンツディスポジションとMIME-バージョンヘッダフィールドを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added a \"glare handling\" mechanism to deal with the case where both parties send each other a re-INVITE simultaneously. It uses the new 491 (Request Pending) error code.",
      "ja": "O両当事者が同時に再INVITEお互いを送信する場合に対処するための「グレア取扱い」のメカニズムを追加しました。これは新しい491（要求保留中）のエラーコードを使用しています。"
    },
    {
      "indent": 3,
      "text": "o Added the In-Reply-To and Reply-To header fields for supporting the return of missed calls or messages at a later time.",
      "ja": "O中-返信するようにして添加し、返信する後で不在着信又はメッセージのリターンを支持するためのフィールドをヘッダー。"
    },
    {
      "indent": 3,
      "text": "o Added TLS and SCTP as valid SIP transports.",
      "ja": "有効なSIPトランスポートとしてOを追加しましたTLSおよびSCTP。"
    },
    {
      "indent": 3,
      "text": "o There were a variety of mechanisms described for handling failures at any time during a call; those are now generally unified. BYE is sent to terminate.",
      "ja": "O通話中に任意の時点での失敗を処理するための説明のさまざまなメカニズムがありました。これらは現在、一般的に統一されています。 BYEが終了するために送信されます。"
    },
    {
      "indent": 3,
      "text": "o RFC 2543 mandated retransmission of INVITE responses over TCP, but noted it was really only needed for 2xx. That was an artifact of insufficient protocol layering. With a more coherent transaction layer defined here, that is no longer needed. Only 2xx responses to INVITEs are retransmitted over TCP.",
      "ja": "O RFC 2543は、TCP上のINVITE応答の再送信を義務付けられたが、それは本当に唯一の2xxのために必要だった指摘しました。すなわち、不十分なプロトコルの階層化のアーチファクトでした。ここで定義された多くのコヒーレントトランザクション層では、それはもはや必要ではありません。 INVITEへの唯一の2xx応答は、TCP上で再送されます。"
    },
    {
      "indent": 3,
      "text": "o Client and server transaction machines are now driven based on timeouts rather than retransmit counts. This allows the state machines to be properly specified for TCP and UDP.",
      "ja": "Oクライアントとサーバーのトランザクション・マシンは、現在のタイムアウトではなく、再送信回数に基づいて駆動されます。これは、ステートマシンが正しくTCPとUDPのために指定することができます。"
    },
    {
      "indent": 3,
      "text": "o The Date header field is used in REGISTER responses to provide a simple means for auto-configuration of dates in user agents.",
      "ja": "O日付ヘッダフィールドは、ユーザーエージェントの日付の自動設定のための簡単な手段を提供するために、REGISTER応答に使用されます。"
    },
    {
      "indent": 3,
      "text": "o Allowed a registrar to reject registrations with expirations that are too short in duration. Defined the 423 response code and the Min-Expires for this purpose.",
      "ja": "Oレジストラは、持続時間が短すぎると有効期限の登録を拒否することができました。 423応答コードを定義し、この目的のためにミンは、有効期限。"
    },
    {
      "indent": 0,
      "text": "29 Normative References",
      "ja": "29の引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Handley, M. and V. Jacobson, \"SDP: Session Description Protocol\", RFC 2327, April 1998.",
      "ja": "[1]ハンドレー、M.およびV. Jacobsonの \"SDP：セッション記述プロトコル\"、RFC 2327、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[2]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[3] Resnick, P., \"Internet Message Format\", RFC 2822, April 2001.",
      "ja": "[3]レズニック、P.、 \"インターネットメッセージ形式\"、RFC 2822、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[4] Rosenberg, J. and H. Schulzrinne, \"SIP: Locating SIP Servers\", RFC 3263, June 2002.",
      "ja": "[4]ローゼンバーグ、J.、およびH. Schulzrinneと、 \"SIP：SIPサーバの検索\"、RFC 3263、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[5] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[5]バーナーズ=リー、T.、フィールディング、R.、およびL. Masinter、 \"統一資源識別子（URI）：一般的な構文\"、RFC 2396、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[6] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "[6]、RFC 3268、2002年6月のchown、P.、 \"トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせを\"。"
    },
    {
      "indent": 3,
      "text": "[7] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[7] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、RFC 2279、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[8] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[8]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\"、 RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[9] Vaha-Sipila, A., \"URLs for Telephone Calls\", RFC 2806, April 2000.",
      "ja": "[9] Vaha-Sipilaは、A.、RFC 2806、2000年4月、 \"電話のURLコール\"。"
    },
    {
      "indent": 3,
      "text": "[10] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[10]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、RFC 2234、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[11] Freed, F. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, November 1996.",
      "ja": "[11]解放され、F.およびN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）パート2：メディアタイプ\"、RFC 2046、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[12] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[12]イーストレイク、D.、クロッカー、S.とJ.シラー、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[13] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with SDP\", RFC 3264, June 2002.",
      "ja": "[13]ローゼンバーグ、J.、およびH. Schulzrinneと、 \"SDPとオファー/アンサーモデル\"、RFC 3264、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[14] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[14]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[15] Postel, J., \"DoD Standard Transmission Control Protocol\", RFC 761, January 1980.",
      "ja": "[15]ポステル、J.、 \"国防総省標準伝送制御プロトコル\"、RFC 761、1980年1月。"
    },
    {
      "indent": 3,
      "text": "[16] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L. and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[16]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.およびV.パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[17] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. and L. Stewart, \"HTTP authentication: Basic and Digest Access Authentication\", RFC 2617, June 1999.",
      "ja": "[17]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.およびL.スチュワート、 \"HTTP認証：基本とダイジェストアクセス認証\"、 RFC 2617、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[18] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field\", RFC 2183, August 1997.",
      "ja": "[18] Troost、R.、ドルナー、S.とK.ムーア、 \"インターネット・メッセージでプレゼンテーション情報を伝える：コンテンツ-Dispositionヘッダーフィールド\"、RFC 2183、1997年8月。"
    },
    {
      "indent": 3,
      "text": "[19] Zimmerer, E., Peterson, J., Vemuri, A., Ong, L., Audet, F., Watson, M. and M. Zonoun, \"MIME media types for ISUP and QSIG Objects\", RFC 3204, December 2001.",
      "ja": "[19] Zimmerer、E.、ピーターソン、J.、Vemuri、A.、オング、L.、Audet、F.、ワトソン、M.およびM. Zonoun、 \"ISUPとQSIGオブジェクトのMIMEメディアタイプ\"、RFC 3204 、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[20] Braden, R., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, October 1989.",
      "ja": "[20]ブレーデン、R.、 \"インターネットホストのための要件 - 、アプリケーションとサポート\"、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[21] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[21] Alvestrand、H.、 \"文字セットと言語のIETF方針\"、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[22] Galvin, J., Murphy, S., Crocker, S. and N. Freed, \"Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\", RFC 1847, October 1995.",
      "ja": "[22]ガルビン、J.、マーフィー、S.、クロッカー、S.およびN.フリード、 \"MIMEマルチパートのセキュリティ：マルチパート/署名およびマルチパート/暗号化\"、RFC 1847、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[23] Housley, R., \"Cryptographic Message Syntax\", RFC 2630, June 1999.",
      "ja": "[23] Housley氏、R.、 \"暗号メッセージ構文\"、RFC 2630、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[24] Ramsdell B., \"S/MIME Version 3 Message Specification\", RFC 2633, June 1999.",
      "ja": "[24] Ramsdell B.、 \"S / MIMEバージョン3メッセージ仕様\"、RFC 2633、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[25] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[25]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[26] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[26]ケント、S.とR.アトキンソン、 \"インターネットプロトコルのためのセキュリティー体系\"、RFC 2401、1998年11月。"
    },
    {
      "indent": 0,
      "text": "30 Informative References",
      "ja": "30件の参考文献"
    },
    {
      "indent": 3,
      "text": "[27] R. Pandya, \"Emerging mobile and personal communication systems,\" IEEE Communications Magazine, Vol. 33, pp. 44--52, June 1995.",
      "ja": "[27] R. Pandya、 \"モバイルおよびパーソナル通信システムの新興、\" IEEEコミュニケーションズマガジン、巻。 33頁。44--52、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[28] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", RFC 1889, January 1996.",
      "ja": "[28] Schulzrinneと、H.、Casner、S.、フレデリック、R.とV. Jacobson氏、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、RFC 1889、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[29] Schulzrinne, H., Rao, R. and R. Lanphier, \"Real Time Streaming Protocol (RTSP)\", RFC 2326, April 1998.",
      "ja": "[29] SchulzrinneとH.とラオとR.とR. Lanphier、 \"リアルタイムストリーミングプロトコル（RTSP）\"、RFC 2326、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[30] Cuervo, F., Greene, N., Rayhan, A., Huitema, C., Rosen, B. and J. Segers, \"Megaco Protocol Version 1.0\", RFC 3015, November 2000.",
      "ja": "[30]クエルボ、F.、グリーン、N.、Rayhan、A.、のHuitema、C.、ローゼン、B.及びJ. Segers、 \"Megacoのプロトコルバージョン1.0\"、RFC 3015、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[31] Handley, M., Schulzrinne, H., Schooler, E. and J. Rosenberg, \"SIP: Session Initiation Protocol\", RFC 2543, March 1999.",
      "ja": "[31]ハンドレー、M.、Schulzrinneと、H.、学生はE.およびJ.ローゼンバーグ、 \"SIP：セッション開始プロトコル\"、RFC 2543、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[32] Hoffman, P., Masinter, L. and J. Zawinski, \"The mailto URL scheme\", RFC 2368, July 1998.",
      "ja": "[32]ホフマン、P.、Masinter、L.及びJ. Zawinski、 \"mailtoのURLスキーム\"、RFC 2368、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[33] E. M. Schooler, \"A multicast user directory service for synchronous rendezvous,\" Master's Thesis CS-TR-96-18, Department of Computer Science, California Institute of Technology, Pasadena, California, Aug. 1996.",
      "ja": "[33] E. M.学生は、「同期ランデブーのためのマルチキャストユーザディレクトリサービス、」修士論文CS-TR-96から18、コンピュータサイエンス、カリフォルニア工科大学、パサデナ、カリフォルニア州、1996年8月の教室。"
    },
    {
      "indent": 3,
      "text": "[34] Donovan, S., \"The SIP INFO Method\", RFC 2976, October 2000.",
      "ja": "[34]ドノヴァン、S.、 \"SIP INFO方法\"、RFC 2976、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[35] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[35]リベスト、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[36] Dawson, F. and T. Howes, \"vCard MIME Directory Profile\", RFC 2426, September 1998.",
      "ja": "[36]ドーソン、F.とT.ハウズ、 \"vCardのMIMEディレクトリプロフィール\"、RFC 2426、1998年9月。"
    },
    {
      "indent": 3,
      "text": "[37] Good, G., \"The LDAP Data Interchange Format (LDIF) - Technical Specification\", RFC 2849, June 2000.",
      "ja": "[37]グッド、G.、 \"LDAPデータ交換フォーマット（LDIF） - 技術仕様\"、RFC 2849、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[38] Palme, J., \"Common Internet Message Headers\", RFC 2076, February 1997.",
      "ja": "[38]パルメ、J.、 \"一般的なインターネットメッセージヘッダ\"、RFC 2076、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[39] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP: Digest Access Authentication\", RFC 2069, January 1997.",
      "ja": "[39]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、リーチ、P.、Luotonen、A.、シンク、E.およびL.スチュワート、 \"HTTPへの拡張：ダイジェストアクセス認証\"、 RFC 2069、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[40] Johnston, A., Donovan, S., Sparks, R., Cunningham, C., Willis, D., Rosenberg, J., Summers, K. and H. Schulzrinne, \"SIP Call Flow Examples\", Work in Progress.",
      "ja": "[40]ジョンストン、A.、ドノバン、S.、スパークス、R.、カニンガム、C.、ウィリス、D.、ローゼンバーグ、J.、サマーズ、K.およびH. Schulzrinneと、 \"SIPコールフローの例\"、ワーキング進行中。"
    },
    {
      "indent": 3,
      "text": "[41] E. M. Schooler, \"Case study: multimedia conference control in a packet-switched teleconferencing system,\" Journal of Internetworking: Research and Experience, Vol. 4, pp. 99--120, June 1993. ISI reprint series ISI/RS-93-359.",
      "ja": "[41] E. M.学生は、「ケーススタディ：パケット交換会議システムにおけるマルチメディア会議制御、」インターネットワーキングのジャーナル：研究と経験、巻。 4頁。99--120、1993年6月ISI転載シリーズISI / RS-93から359まで。"
    },
    {
      "indent": 3,
      "text": "[42] H. Schulzrinne, \"Personal mobility for multimedia services in the Internet,\" in European Workshop on Interactive Distributed Multimedia Systems and Services (IDMS), (Berlin, Germany), Mar. 1996.",
      "ja": "対話に関する欧州ワークショップでは、[42] H. Schulzrinneと、「インターネットにおけるマルチメディアサービスのためのパーソナルモビリティは、」マルチメディアシステム・サービス（IDMS）、（ベルリン、ドイツ）、1996年3月に配布されています。"
    },
    {
      "indent": 3,
      "text": "[43] Floyd, S., \"Congestion Control Principles\", RFC 2914, September 2000.",
      "ja": "[43]フロイド、S.、 \"輻輳制御の原理\"、RFC 2914、2000年9月。"
    },
    {
      "indent": 0,
      "text": "A Table of Timer Values",
      "ja": "タイマー値の表"
    },
    {
      "indent": 3,
      "text": "Table 4 summarizes the meaning and defaults of the various timers used by this specification.",
      "ja": "表4は、この仕様書で使用される各種タイマの意味とデフォルト値をまとめたもの。"
    },
    {
      "indent": 0,
      "text": "Timer    Value            Section               Meaning\n----------------------------------------------------------------------\nT1       500ms default    Section 17.1.1.1     RTT Estimate\nT2       4s               Section 17.1.2.2     The maximum retransmit\n                                               interval for non-INVITE\n                                               requests and INVITE\n                                               responses\nT4       5s               Section 17.1.2.2     Maximum duration a\n                                               message will\n                                               remain in the network\nTimer A  initially T1     Section 17.1.1.2     INVITE request retransmit\n                                               interval, for UDP only\nTimer B  64*T1            Section 17.1.1.2     INVITE transaction\n                                               timeout timer\nTimer C  > 3min           Section 16.6         proxy INVITE transaction\n                           bullet 11            timeout\nTimer D  > 32s for UDP    Section 17.1.1.2     Wait time for response\n         0s for TCP/SCTP                       retransmits\nTimer E  initially T1     Section 17.1.2.2     non-INVITE request\n                                               retransmit interval,\n                                               UDP only\nTimer F  64*T1            Section 17.1.2.2     non-INVITE transaction\n                                               timeout timer\nTimer G  initially T1     Section 17.2.1       INVITE response\n                                               retransmit interval\nTimer H  64*T1            Section 17.2.1       Wait time for\n                                               ACK receipt\nTimer I  T4 for UDP       Section 17.2.1       Wait time for\n         0s for TCP/SCTP                       ACK retransmits\nTimer J  64*T1 for UDP    Section 17.2.2       Wait time for\n         0s for TCP/SCTP                       non-INVITE request\n                                               retransmits\nTimer K  T4 for UDP       Section 17.1.2.2     Wait time for\n         0s for TCP/SCTP                       response retransmits",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 4: Summary of timers",
      "ja": "表4：タイマーの概要"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We wish to thank the members of the IETF MMUSIC and SIP WGs for their comments and suggestions. Detailed comments were provided by Ofir Arkin, Brian Bidulock, Jim Buller, Neil Deason, Dave Devanathan, Keith Drage, Bill Fenner, Cedric Fluckiger, Yaron Goland, John Hearty, Bernie Hoeneisen, Jo Hornsby, Phil Hoffer, Christian Huitema, Hisham Khartabil, Jean Jervis, Gadi Karmi, Peter Kjellerstedt, Anders Kristensen, Jonathan Lennox, Gethin Liddell, Allison Mankin, William Marshall, Rohan Mahy, Keith Moore, Vern Paxson, Bob Penfield, Moshe J. Sambol, Chip Sharp, Igor Slepchin, Eric Tremblay, and Rick Workman.",
      "ja": "我々は彼らのコメントや提案をIETF MMUSICとSIPのWGのメンバーに感謝したいです。詳細なコメントは、オファイア・アーキン、ブライアンBidulock、ジム・ブラー、ニールDeason、デイブDevanathan、キース糖剤、ビルフェナー、セドリックFluckiger、ヤロンGoland、ジョン・ハーティ、バーニーHoeneisen、ジョー・ホーンズビー、フィル・ホッファー、クリスチャンのHuitema、ヒシャムKhartabilによって提供されましたジャン・ジャービス、Gadi氏Karmi、ピーターKjellerstedt、アンダース・クリステンセン、ジョナサン・レノックス、ゲシンリデル、アリソンマンキン、ウィリアム・マーシャル、ロハンマーイ、キースムーア、バーン・パクソン、ボブペンフィールド、モシェJ. Sambol、チップシャープ、イゴールSlepchin、エリック・トレンブレイ、そしてリック・ワークマン。"
    },
    {
      "indent": 3,
      "text": "Brian Rosen provided the compiled BNF.",
      "ja": "ブライアン・ローゼンは、コンパイル済みのBNFを提供します。"
    },
    {
      "indent": 3,
      "text": "Jean Mahoney provided technical writing assistance.",
      "ja": "ジャン・マホーニーは、テクニカルライティングの支援を提供します。"
    },
    {
      "indent": 3,
      "text": "This work is based, inter alia, on [41,42].",
      "ja": "この作品は、[41,42]に、とりわけ、ベースにしています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Authors addresses are listed alphabetically for the editors, the writers, and then the original authors of RFC 2543. All listed authors actively contributed large amounts of text to this document.",
      "ja": "著者のアドレスがすべて記載されている著者は積極的にこの文書への大量のテキストを寄付し、その後編集者、ライター、およびRFC 2543の原作者のためにアルファベット順にリストされています。"
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg dynamicsoft 72 Eagle Rock Ave East Hanover, NJ 07936 USA",
      "ja": "ジョナサン・ローゼンバーグdynamicsoft 72イーグルロックアベニューイーストハノーバー、NJ 07936 USA"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@dynamicsoft.com",
      "ja": "メールアドレス：jdrosen@dynamicsoft.com"
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Dept. of Computer Science Columbia University 1214 Amsterdam Avenue New York, NY 10027 USA",
      "ja": "コンピュータサイエンスコロンビア大学1214アムステルダムAvenueニューヨークのヘニングSchulzrinneと部長、NY 10027 USA"
    },
    {
      "indent": 3,
      "text": "EMail: schulzrinne@cs.columbia.edu",
      "ja": "メールアドレス：schulzrinne@cs.columbia.edu"
    },
    {
      "indent": 3,
      "text": "Gonzalo Camarillo Ericsson Advanced Signalling Research Lab. FIN-02420 Jorvas Finland",
      "ja": "ゴンサロ・カマリロエリクソン高度なシグナリング研究所。 FIN-02420 Jorvasフィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: Gonzalo.Camarillo@ericsson.com",
      "ja": "メールアドレス：Gonzalo.Camarillo@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Alan Johnston WorldCom 100 South 4th Street St. Louis, MO 63102 USA",
      "ja": "アラン・ジョンストンワールドコム100南第四ストリートセントルイス、MO 63102 USA"
    },
    {
      "indent": 3,
      "text": "EMail: alan.johnston@wcom.com",
      "ja": "メールアドレス：alan.johnston@wcom.com"
    },
    {
      "indent": 3,
      "text": "Jon Peterson NeuStar, Inc 1800 Sutter Street, Suite 570 Concord, CA 94520 USA",
      "ja": "ジョンピーターソンNeuStar株式会社1800サターストリート、スイート570コンコード、CA 94520 USA"
    },
    {
      "indent": 3,
      "text": "EMail: jon.peterson@neustar.com",
      "ja": "メールアドレス：jon.peterson@neustar.com"
    },
    {
      "indent": 3,
      "text": "Robert Sparks dynamicsoft, Inc. 5100 Tennyson Parkway Suite 1200 Plano, Texas 75024 USA",
      "ja": "ロバート・スパークスdynamicsoft株式会社5100テニソンパークウェイスイート1200プラノ、テキサス75024 USA"
    },
    {
      "indent": 3,
      "text": "EMail: rsparks@dynamicsoft.com",
      "ja": "メールアドレス：rsparks@dynamicsoft.com"
    },
    {
      "indent": 3,
      "text": "Mark Handley International Computer Science Institute 1947 Center St, Suite 600 Berkeley, CA 94704 USA",
      "ja": "マーク・ハンドリー国際コンピュータサイエンス研究所1947センターセント、スイート600バークレー、CA 94704 USA"
    },
    {
      "indent": 3,
      "text": "EMail: mjh@icir.org",
      "ja": "メールアドレス：mjh@icir.org"
    },
    {
      "indent": 3,
      "text": "Eve Schooler AT&T Labs-Research 75 Willow Road Menlo Park, CA 94025 USA",
      "ja": "イヴ学生はAT＆T Labsの研究-75ウィローロードメンロパーク、CA 94025 USA"
    },
    {
      "indent": 3,
      "text": "EMail: schooler@research.att.com",
      "ja": "メールアドレス：schooler@research.att.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}