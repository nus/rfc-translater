{
  "title": {
    "text": "RFC 3542 - Advanced Sockets Application Program Interface (API) for IPv6",
    "ja": "RFC 3542 - IPv6用の拡張ソケットアプリケーション・プログラム・インターフェース（API）"
  },
  "number": 3542,
  "created_at": "2019-10-19 10:39:52.626741+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         W. Stevens\nRequest for Comments: 3542                                     M. Thomas\nObsoletes: 2292                                               Consultant\nCategory: Informational                                      E. Nordmark\n                                                                     Sun\n                                                               T. Jinmei\n                                                                 Toshiba\n                                                                May 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Advanced Sockets Application Program Interface (API) for IPv6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document provides sockets Application Program Interface (API) to support \"advanced\" IPv6 applications, as a supplement to a separate specification, RFC 3493. The expected applications include Ping, Traceroute, routing daemons and the like, which typically use raw sockets to access IPv6 or ICMPv6 header fields. This document proposes some portable interfaces for applications that use raw sockets under IPv6. There are other features of IPv6 that some applications will need to access: interface identification (specifying the outgoing interface and determining the incoming interface), IPv6 extension headers, and path Maximum Transmission Unit (MTU) information. This document provides API access to these features too. Additionally, some extended interfaces to libraries for the \"r\" commands are defined. The extension will provide better backward compatibility to existing implementations that are not IPv6-capable.",
      "ja": "この文書は、RFC 3493.期待アプリケーションは通常、アクセスにrawソケットを使用してpingを実行し、トレースルート、ルーティングデーモンなどを含むアプリケーション・プログラム・インターフェース（API）は、別仕様の補足として、「先進」のIPv6アプリケーションをサポートするためのソケットを提供しますIPv6のまたはICMPv6のヘッダフィールド。この文書は、IPv6の下でrawソケットを使用するアプリケーションのためのいくつかのポータブルインタフェースを提案しています。インタフェース識別（発信インターフェイスを指定して、着信インターフェイスを決定する）、IPv6拡張ヘッダ、及びパス最大伝送単位（MTU）情報：いくつかのアプリケーションがアクセスする必要があることのIPv6の他の特徴があります。この文書では、あまりにも、これらの機能へのAPIアクセスを提供します。また、「R」コマンドのライブラリにいくつかの拡張インタフェースが定義されています。拡張子は、IPv6に対応していない既存の実装に優れた後方互換性を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.   Introduction ..............................................  3\n2.   Common Structures and Definitions .........................  5\n     2.1  The ip6_hdr Structure ................................  6\n          2.1.1  IPv6 Next Header Values .......................  6\n          2.1.2  IPv6 Extension Headers ........................  7\n          2.1.3  IPv6 Options ..................................  8\n     2.2  The icmp6_hdr Structure .............................. 10\n          2.2.1  ICMPv6 Type and Code Values ................... 10\n          2.2.2  ICMPv6 Neighbor Discovery Definitions ......... 11\n          2.2.3  Multicast Listener Discovery Definitions ...... 14\n          2.2.4  ICMPv6 Router Renumbering Definitions ......... 14\n     2.3  Address Testing Macros ............................... 16\n     2.4  Protocols File ....................................... 16\n3.   IPv6 Raw Sockets .......................................... 17\n     3.1  Checksums ............................................ 18\n     3.2  ICMPv6 Type Filtering ................................ 19\n     3.3  ICMPv6 Verification of Received Packets .............. 22\n4.   Access to IPv6 and Extension Headers ...................... 22\n     4.1  TCP Implications ..................................... 24\n     4.2  UDP and Raw Socket Implications ...................... 25\n5.   Extensions to Socket Ancillary Data ....................... 26\n     5.1  CMSG_NXTHDR .......................................... 26\n     5.2  CMSG_SPACE ........................................... 26\n     5.3  CMSG_LEN ............................................. 27\n6.   Packet Information ........................................ 27\n     6.1  Specifying/Receiving the Interface ................... 28\n     6.2  Specifying/Receiving Source/Destination Address ...... 29\n     6.3  Specifying/Receiving the Hop Limit ................... 29\n     6.4  Specifying the Next Hop Address ...................... 30\n     6.5  Specifying/Receiving the Traffic Class value ......... 31\n     6.6  Additional Errors with sendmsg() and setsockopt() .... 32\n     6.7  Summary of Outgoing Interface Selection .............. 32\n7.   Routing Header Option ..................................... 33\n     7.1  inet6_rth_space ...................................... 35\n     7.2  inet6_rth_init ....................................... 35\n     7.3  inet6_rth_add ........................................ 36\n     7.4  inet6_rth_reverse .................................... 36\n     7.5  inet6_rth_segments ................................... 36\n     7.6  inet6_rth_getaddr .................................... 36\n8.   Hop-By-Hop Options ........................................ 37\n     8.1  Receiving Hop-by-Hop Options ......................... 38\n     8.2  Sending Hop-by-Hop Options ........................... 38\n9.   Destination Options ....................................... 39\n     9.1  Receiving Destination Options ........................ 39\n     9.2  Sending Destination Options .......................... 39\n10.  Hop-by-Hop and Destination Options Processing ............. 40",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "     10.1  inet6_opt_init ...................................... 41\n     10.2  inet6_opt_append .................................... 41\n     10.3  inet6_opt_finish .................................... 42\n     10.4  inet6_opt_set_val ................................... 42\n     10.5  inet6_opt_next ...................................... 42\n     10.6  inet6_opt_find ...................................... 43\n     10.7  inet6_opt_get_val ................................... 43\n11.  Additional Advanced API Functions ......................... 44\n     11.1  Sending with the Minimum MTU ........................ 44\n     11.2  Sending without Fragmentation ....................... 45\n     11.3  Path MTU Discovery and UDP .......................... 46\n     11.4  Determining the Current Path MTU .................... 47\n12.  Ordering of Ancillary Data and IPv6 Extension Headers ..... 48\n13.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses ..... 50\n14.  Extended interfaces for rresvport, rcmd and rexec ......... 51\n     14.1  rresvport_af ........................................ 51\n     14.2  rcmd_af ............................................. 51\n     14.3  rexec_af ............................................ 52\n15.  Summary of New Definitions ................................ 52\n16.  Security Considerations ................................... 56\n17.  Changes from RFC 2292 ..................................... 57\n18.  References ................................................ 59\n19.  Acknowledgments ........................................... 59\n20.  Appendix A: Ancillary Data Overview ....................... 60\n     20.1  The msghdr Structure ................................ 60\n     20.2  The cmsghdr Structure ............................... 61\n     20.3  Ancillary Data Object Macros ........................ 62\n           20.3.1  CMSG_FIRSTHDR ............................... 63\n           20.3.2  CMSG_NXTHDR ................................. 64\n           20.3.3  CMSG_DATA ................................... 65\n           20.3.4  CMSG_SPACE .................................. 65\n           20.3.5  CMSG_LEN .................................... 65\n21.  Appendix B: Examples Using the inet6_rth_XXX() Functions .. 65\n     21.1  Sending a Routing Header ............................ 65\n     21.2  Receiving Routing Headers ........................... 70\n22.  Appendix C: Examples Using the inet6_opt_XXX() Functions .. 72\n     22.1  Building Options .................................... 72\n     22.2  Parsing Received Options ............................ 74\n23.  Authors' Addresses ........................................ 76\n24.  Full Copyright Statement .................................. 77",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "A separate specification [RFC-3493] contains changes to the sockets API to support IP version 6. Those changes are for TCP and UDP-based applications. This document defines some of the \"advanced\" features of the sockets API that are required for applications to take advantage of additional features of IPv6.",
      "ja": "個別の仕様[RFC-3493]はこれらの変更は、TCPおよびUDPベースのアプリケーションのためのものであるIPバージョン6をサポートするためのソケットAPIへの変更が含まれています。この文書は、IPv6の追加機能を利用するアプリケーションのために必要とされるソケットAPIの「先進的な」機能のいくつかを定義します。"
    },
    {
      "indent": 3,
      "text": "Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley header files. This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API. With IPv6, however, there is no common source code base that implementors are starting from, and the possibility for divergence at this level between different implementations is high. To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.",
      "ja": "今日、IPv4の生のソケットを使用するアプリケーションの移植性は非常に高いが、ほとんどのIPv4実装が共通のベース（バークレーソースコード）から起動または少なくともバークレーヘッダファイルで開始するので、これは主にあります。これは、pingやtracerouteのようなプログラムは、例えば、ソケットAPIをサポートする多くのホスト上で最小限の労力でコンパイルすることができます。 IPv6では、しかし、そこに実装から始めて共通ソースコードベースはなく、異なる実装の間でこのレベルの発散の可能性が高いです。生のIPv6ソケットを使用するアプリケーション間での移植性の完全な欠如を避けるために、いくつかの標準化が必要です。"
    },
    {
      "indent": 3,
      "text": "There are also features from the basic IPv6 specification that are not addressed in [RFC-3493]: sending and receiving Routing headers, Hop-by-Hop options, and Destination options, specifying the outgoing interface, being told of the receiving interface, and control of path MTU information.",
      "ja": "あります[RFC-3493]で扱われていない基本的なIPv6の仕様から機能：送信側と受信側のルーティングヘッダ、ホップバイホップオプション、および宛先オプションを、発信インターフェイスを指定して、受信インタフェースの言われて、そしてパスMTU情報のコントロール。"
    },
    {
      "indent": 3,
      "text": "This document updates and replaces RFC 2292. This revision is based on implementation experience of RFC 2292, as well as some additional extensions that have been found to be useful through the IPv6 deployment. Note, however, that further work on this document may still be needed. Once the API specification becomes mature and is deployed among implementations, it may be formally standardized by a more appropriate body, such as has been done with the Basic API [RFC-3493].",
      "ja": "このドキュメントの更新およびRFC 2292.に代わるものは、この改訂版は、実装RFC 2292の経験だけでなく、IPv6の展開を通じて有用であることがわかっているいくつかの追加の拡張機能に基づいています。この文書にさらなる作業がまだ必要かもしれないこと、しかし、注意してください。 API仕様が成熟になり、実装の中に配備されると、それは正式にそのような基本的なAPI [RFC-3493]で行われているように、より適切な身体によって標準化されてもよいです。"
    },
    {
      "indent": 3,
      "text": "This document can be divided into the following main sections.",
      "ja": "このドキュメントは、次の主要なセクションに分けることができます。"
    },
    {
      "indent": 3,
      "text": "1. Definitions of the basic constants and structures required for applications to use raw IPv6 sockets. This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).",
      "ja": "生のIPv6ソケットを使用するアプリケーションに必要な基本的な定数と構造体の1.定義。これは、IPv6とICMPv6のヘッダと関連するすべての定数（例えば、次ヘッダフィールドの値）のための構造定義を含みます。"
    },
    {
      "indent": 3,
      "text": "2. Some basic semantic definitions for IPv6 raw sockets. For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum. But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation. It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.",
      "ja": "2. IPv6のrawソケットのためのいくつかの基本的なセマンティック定義が。例えば、生ICMPv4のソケットはICMPv4のヘッダチェックサムを計算して格納するアプリケーションを必要とします。しかし、IPv6でこれは、送信元アドレスは、ICMPv6のは今そのチェックサムの計算に使用する擬似ヘッダの一部であるため、送信元IPv6アドレスを選択するためのアプリケーションが必要になります。生のICMPv6ソケットにカーネルは常にICMPv6のヘッダチェックサムを計算し、記憶することが定義されるべきです。"
    },
    {
      "indent": 3,
      "text": "3. Packet information: how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per-packet basis. There are a class of applications that need this capability and the technique should be portable.",
      "ja": "前記パケット情報：アプリケーションは、受信インタフェース、宛先アドレス、およびパケット単位でこれらの値を指定するとともに、ホップ制限を受けを得ることができる方法。ポータブルである必要があり、この機能と技術を必要とするアプリケーションのクラスがあります。"
    },
    {
      "indent": 3,
      "text": "4. Access to the optional Routing header, Hop-by-Hop options, and Destination options extension headers.",
      "ja": "4.オプションのルーティングヘッダへのアクセス、ホップバイホップオプション、および宛先オプション拡張ヘッダ。"
    },
    {
      "indent": 3,
      "text": "5. Additional features required for improved IPv6 application portability.",
      "ja": "改良されたIPv6アプリケーションの移植に必要な5.その他の機能。"
    },
    {
      "indent": 3,
      "text": "The packet information along with access to the extension headers (Routing header, Hop-by-Hop options, and Destination options) are specified using the \"ancillary data\" fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix standard [POSIX] and should therefore be adopted by most vendors.",
      "ja": "拡張ヘッダー（ルーティングヘッダ、ホップバイホップオプション、および宛先オプション）へのアクセスと共にパケット情報が理由である1990年に4.3BSDレノソケットAPIに追加された「補助データ」フィールドを使用して指定されていますこれらの補助データフィールドは、POSIX標準[POSIX]の一部であるため、ほとんどのベンダーによって採用されるべきであること。"
    },
    {
      "indent": 3,
      "text": "This document does not address application access to either the authentication header or the encapsulating security payload header.",
      "ja": "この文書では、認証ヘッダやカプセル化セキュリティペイロードヘッダのいずれかへのアクセスをアプリケーションに対応していません。"
    },
    {
      "indent": 3,
      "text": "Many examples in this document omit error checking in favor of brevity and clarity.",
      "ja": "このドキュメントの多くの例が簡潔かつ明瞭に賛成してエラーチェックを省略します。"
    },
    {
      "indent": 3,
      "text": "We note that some of the functions and socket options defined in this document may have error returns that are not defined in this document. Some of these possible error returns will be recognized only as implementations proceed.",
      "ja": "私たちは、この文書で定義された関数とソケットのオプションのいくつかは、この文書で定義されていないエラーリターンを持っているかもしれないことに注意します。これらの可能性のあるエラーを返すの一部は実装が進むだけとして認識されます。"
    },
    {
      "indent": 3,
      "text": "Datatypes in this document follow the Posix format: intN_t means a signed integer of exactly N bits (e.g., int16_t) and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).",
      "ja": "この文書に記載されているデータ型は、POSIX形式は、次のとおりintN_tは正確にNビットの符号付き整数（例えば、int16_t）を意味し、uintN_tは正確にNビットの符号なし整数（例えば、のuint32_t）を意味します。"
    },
    {
      "indent": 3,
      "text": "Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.",
      "ja": "我々は新しいICMPv6のプロトコルとの混同を避けるために（非公式）用語ICMPv4の、IGMPv4、およびARPv4を使用することに注意してください。"
    },
    {
      "indent": 0,
      "text": "2. Common Structures and Definitions",
      "section_title": true,
      "ja": "2.一般的な構造と定義"
    },
    {
      "indent": 3,
      "text": "Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers. Common structure definitions for these protocol headers are required, along with common constant definitions for the structure members.",
      "ja": "多くの高度なアプリケーションは、IPv6ヘッダーのフィールドを調べて、各種のICMPv6ヘッダー内のフィールドを設定して調べ。これらのプロトコルヘッダーのための共通構造体の定義は、構造体のメンバーのための共通の定数の定義とともに、必要とされます。"
    },
    {
      "indent": 3,
      "text": "This API assumes that the fields in the protocol headers are left in the network byte order, which is big-endian for the Internet protocols. If not, then either these constants or the fields being tested must be converted at run-time, using something like htons() or htonl().",
      "ja": "このAPIは、プロトコルヘッダ内のフィールドは、インターネットプロトコルのためのビッグエンディアンであるネットワークバイト順、に残されていることを前提としています。そうでない場合には、これらの定数またはテストされているいずれかのフィールドはhtons（）やhtonl（）のようなものを使用して、実行時に変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Two new header files are defined: <netinet/ip6.h> and <netinet/icmp6.h>.",
      "ja": "二つの新しいヘッダファイルが定義されています。<netinetの/ ip6.h>と<netinetの/ icmp6.h>。"
    },
    {
      "indent": 3,
      "text": "When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.",
      "ja": "インクルードファイルを指定すると、そのファイルが含まれるが、実際の宣言または定義を行う他のファイルを含めることが許可されています。"
    },
    {
      "indent": 0,
      "text": "2.1. The ip6_hdr Structure",
      "section_title": true,
      "ja": "2.1。 ip6_hdr構造"
    },
    {
      "indent": 3,
      "text": "The following structure is defined as a result of including <netinet/ip6.h>. Note that this is a new header.",
      "ja": "以下の構造は、<netinetの/ ip6.h>などの結果として定義されます。これは新しいヘッダであることに注意してください。"
    },
    {
      "indent": 6,
      "text": "struct ip6_hdr {\n  union {\n    struct ip6_hdrctl {\n      uint32_t ip6_un1_flow; /* 4 bits version, 8 bits TC, 20 bits\n                                flow-ID */\n      uint16_t ip6_un1_plen; /* payload length */\n      uint8_t  ip6_un1_nxt;  /* next header */\n      uint8_t  ip6_un1_hlim; /* hop limit */\n    } ip6_un1;\n    uint8_t ip6_un2_vfc;     /* 4 bits version, top 4 bits\n                                tclass */\n  } ip6_ctlun;\n  struct in6_addr ip6_src;   /* source address */\n  struct in6_addr ip6_dst;   /* destination address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ip6_vfc ip6_ctlun.ip6_un2_vfc #define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow #define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen #define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt #define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim #define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim",
      "ja": "#define ip6_vfc ip6_ctlun.ip6_un2_vfcの#define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flowの#define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plenの#define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxtの#define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlimの#define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim"
    },
    {
      "indent": 0,
      "text": "2.1.1. IPv6 Next Header Values",
      "section_title": true,
      "ja": "2.1.1。 IPv6の次のヘッダ値"
    },
    {
      "indent": 3,
      "text": "IPv6 defines many new values for the Next Header field. The following constants are defined as a result of including <netinet/in.h>.",
      "ja": "IPv6は、次ヘッダフィールドのための多くの新しい値を定義します。以下の定数は、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define IPPROTO_HOPOPTS   0   /* IPv6 Hop-by-Hop options */\n#define IPPROTO_IPV6     41   /* IPv6 header */\n#define IPPROTO_ROUTING  43   /* IPv6 Routing header */\n#define IPPROTO_FRAGMENT 44   /* IPv6 fragment header */\n#define IPPROTO_ESP      50   /* encapsulating security payload */\n#define IPPROTO_AH       51   /* authentication header */\n#define IPPROTO_ICMPV6   58   /* ICMPv6 */\n#define IPPROTO_NONE     59   /* IPv6 no next header */\n#define IPPROTO_DSTOPTS  60   /* IPv6 Destination options */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0. This should not be a problem since IPPROTO_IP is used only with IPv4 sockets and IPPROTO_HOPOPTS only with IPv6 sockets.",
      "ja": "バークレー由来のIPv4実装もIPPROTO_IPのみIPv6ソケットとIPv4のみのソケットとIPPROTO_HOPOPTSと共に使用されるので、これは問題にはならない0にIPPROTO_IPを定義します。"
    },
    {
      "indent": 0,
      "text": "2.1.2. IPv6 Extension Headers",
      "section_title": true,
      "ja": "2.1.2。 IPv6拡張ヘッダー"
    },
    {
      "indent": 3,
      "text": "Six extension headers are defined for IPv6. We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document. The following structures are defined as a result of including <netinet/ip6.h>.",
      "ja": "シックス・拡張ヘッダは、IPv6のために定義されています。私たちは、このドキュメントの範囲を超えて、どちらも認証ヘッダーとカプセル化セキュリティペイロードヘッダ、以外のすべてのための構造を定義します。以下の構造は、<netinetの/ ip6.h>を含めた結果として定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Hop-by-Hop options header */\nstruct ip6_hbh {\n  uint8_t  ip6h_nxt;        /* next header */\n  uint8_t  ip6h_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Destination options header */\nstruct ip6_dest {\n  uint8_t  ip6d_nxt;        /* next header */\n  uint8_t  ip6d_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Routing header */\nstruct ip6_rthdr {\n  uint8_t  ip6r_nxt;        /* next header */\n  uint8_t  ip6r_len;        /* length in units of 8 octets */\n  uint8_t  ip6r_type;       /* routing type */\n  uint8_t  ip6r_segleft;    /* segments left */\n    /* followed by routing type specific data */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Type 0 Routing header */\nstruct ip6_rthdr0 {\n  uint8_t  ip6r0_nxt;       /* next header */\n  uint8_t  ip6r0_len;       /* length in units of 8 octets */\n  uint8_t  ip6r0_type;      /* always zero */\n  uint8_t  ip6r0_segleft;   /* segments left */\n  uint32_t ip6r0_reserved;  /* reserved field */\n    /* followed by up to 127 struct in6_addr */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Fragment header */\nstruct ip6_frag {\n  uint8_t   ip6f_nxt;       /* next header */\n  uint8_t   ip6f_reserved;  /* reserved field */\n  uint16_t  ip6f_offlg;     /* offset, reserved, and flag */\n  uint32_t  ip6f_ident;     /* identification */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if     BYTE_ORDER == BIG_ENDIAN\n#define IP6F_OFF_MASK       0xfff8  /* mask out offset from\n                                       ip6f_offlg */\n#define IP6F_RESERVED_MASK  0x0006  /* reserved bits in\n                                       ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define IP6F_OFF_MASK       0xf8ff  /* mask out offset from\n                                       ip6f_offlg */\n#define IP6F_RESERVED_MASK  0x0600  /* reserved bits in\n                                       ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.3. IPv6 Options",
      "section_title": true,
      "ja": "2.1.3。 IPv6のオプション"
    },
    {
      "indent": 3,
      "text": "Several options are defined for IPv6, and we define structures and macro definitions for some of them below. The following structures are defined as a result of including <netinet/ip6.h>.",
      "ja": "いくつかのオプションは、IPv6のために定義されている、と我々は以下のうちのいくつかのための構造とマクロ定義を定義します。以下の構造は、<netinetの/ ip6.h>を含めた結果として定義されています。"
    },
    {
      "indent": 6,
      "text": "/* IPv6 options */\nstruct ip6_opt {\n  uint8_t  ip6o_type;\n  uint8_t  ip6o_len;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/*\n * The high-order 3 bits of the option type define the behavior\n * when processing an unknown option and whether or not the option\n * content changes in flight.\n */\n#define IP6OPT_TYPE(o)        ((o) & 0xc0)\n#define IP6OPT_TYPE_SKIP      0x00\n#define IP6OPT_TYPE_DISCARD   0x40\n#define IP6OPT_TYPE_FORCEICMP 0x80\n#define IP6OPT_TYPE_ICMP      0xc0\n#define IP6OPT_MUTABLE        0x20",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define IP6OPT_PAD1           0x00  /* 00 0 00000 */\n#define IP6OPT_PADN           0x01  /* 00 0 00001 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define IP6OPT_JUMBO          0xc2  /* 11 0 00010 */\n#define IP6OPT_NSAP_ADDR      0xc3  /* 11 0 00011 */\n#define IP6OPT_TUNNEL_LIMIT   0x04  /* 00 0 00100 */\n#define IP6OPT_ROUTER_ALERT   0x05  /* 00 0 00101 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Jumbo Payload Option */\nstruct ip6_opt_jumbo {\n  uint8_t  ip6oj_type;\n  uint8_t  ip6oj_len;\n  uint8_t  ip6oj_jumbo_len[4];\n};\n#define IP6OPT_JUMBO_LEN   6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* NSAP Address Option */\nstruct ip6_opt_nsap {\n  uint8_t  ip6on_type;\n  uint8_t  ip6on_len;\n  uint8_t  ip6on_src_nsap_len;\n  uint8_t  ip6on_dst_nsap_len;\n    /* followed by source NSAP */\n    /* followed by destination NSAP */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Tunnel Limit Option */\nstruct ip6_opt_tunnel {\n  uint8_t  ip6ot_type;\n  uint8_t  ip6ot_len;\n  uint8_t  ip6ot_encap_limit;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router Alert Option */\nstruct ip6_opt_router {\n  uint8_t  ip6or_type;\n  uint8_t  ip6or_len;\n  uint8_t  ip6or_value[2];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router alert values (in network byte order) */\n#ifdef _BIG_ENDIAN\n#define IP6_ALERT_MLD      0x0000\n#define IP6_ALERT_RSVP     0x0001\n#define  IP6_ALERT_AN      0x0002\n#else\n#define IP6_ALERT_MLD      0x0000\n#define IP6_ALERT_RSVP     0x0100\n#define IP6_ALERT_AN       0x0200\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2. The icmp6_hdr Structure",
      "section_title": true,
      "ja": "2.2。 icmp6_hdr構造"
    },
    {
      "indent": 3,
      "text": "The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons. The following structure is defined as a result of including <netinet/icmp6.h>. Note that this is a new header.",
      "ja": "ICMPv6のヘッダはPingの、トレースルート、ルータディスカバリデーモン、近傍検索デーモンを含む多数のIPv6アプリケーションで必要とされます。以下の構造は、<netinetの/ icmp6.h>などの結果として定義されます。これは新しいヘッダであることに注意してください。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_hdr {\n  uint8_t     icmp6_type;   /* type field */\n  uint8_t     icmp6_code;   /* code field */\n  uint16_t    icmp6_cksum;  /* checksum field */\n  union {\n    uint32_t  icmp6_un_data32[1]; /* type-specific field */\n    uint16_t  icmp6_un_data16[2]; /* type-specific field */\n    uint8_t   icmp6_un_data8[4];  /* type-specific field */\n  } icmp6_dataun;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define icmp6_data32    icmp6_dataun.icmp6_un_data32\n#define icmp6_data16    icmp6_dataun.icmp6_un_data16\n#define icmp6_data8     icmp6_dataun.icmp6_un_data8\n#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */\n#define icmp6_mtu       icmp6_data32[0]  /* packet too big */\n#define icmp6_id        icmp6_data16[0]  /* echo request/reply */\n#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */\n#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group\n                                            membership */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2.1. ICMPv6 Type and Code Values",
      "section_title": true,
      "ja": "2.2.1。 ICMPv6のタイプとコード値"
    },
    {
      "indent": 3,
      "text": "In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields. The following constants are also defined as a result of including <netinet/icmp6.h>.",
      "ja": "ICMPv6のヘッダの共通の構造に加えて、一般的な定義は、ICMPv6のタイプとコードフィールドに必要とされます。以下の定数はまた、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH 1 #define ICMP6_PACKET_TOO_BIG 2 #define ICMP6_TIME_EXCEEDED 3 #define ICMP6_PARAM_PROB 4",
      "ja": "#define ICMP6_DST_UNREACH 1の#define ICMP6_PACKET_TOO_BIG 2の#define ICMP6_TIME_EXCEEDED 3の#define ICMP6_PARAM_PROB 4"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_INFOMSG_MASK  0x80    /* all informational\n                                       messages */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_ECHO_REQUEST 128 #define ICMP6_ECHO_REPLY 129",
      "ja": "#define ICMP6_ECHO_REQUEST 128の#define ICMP6_ECHO_REPLY 129"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to\n                                           destination */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with\n                                           destination */\n                                        /* admin. prohibited */\n#define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source\n                                           address */\n#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */\n#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in\n                                           transit */\n#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header\n                                           field */\n#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized\n                                           Next Header */\n#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized\n                                           IPv6 option */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The five ICMP message types defined by IPv6 neighbor discovery (133- 137) are defined in the next section.",
      "ja": "IPv6近隣探索（133- 137）によって定義された5つのICMPメッセージタイプは、次のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2.2. ICMPv6 Neighbor Discovery Definitions",
      "section_title": true,
      "ja": "2.2.2。 ICMPv6の近隣探索の定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造および定義は、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ND_ROUTER_SOLICIT 133 #define ND_ROUTER_ADVERT 134 #define ND_NEIGHBOR_SOLICIT 135 #define ND_NEIGHBOR_ADVERT 136 #define ND_REDIRECT 137",
      "ja": "#define ND_ROUTER_SOLICIT 133の#define ND_ROUTER_ADVERT 134の#define ND_NEIGHBOR_SOLICIT 135の#define ND_NEIGHBOR_ADVERT 136の#define ND_REDIRECT 137"
    },
    {
      "indent": 6,
      "text": "struct nd_router_solicit {     /* router solicitation */\n  struct icmp6_hdr  nd_rs_hdr;\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_rs_type               nd_rs_hdr.icmp6_type\n#define nd_rs_code               nd_rs_hdr.icmp6_code\n#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum\n#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0] struct nd_router_advert {      /* router advertisement */\n  struct icmp6_hdr  nd_ra_hdr;\n  uint32_t   nd_ra_reachable;   /* reachable time */\n  uint32_t   nd_ra_retransmit;  /* retransmit timer */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_ra_type nd_ra_hdr.icmp6_type #define nd_ra_code nd_ra_hdr.icmp6_code #define nd_ra_cksum nd_ra_hdr.icmp6_cksum #define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8[0] #define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8[1] #define ND_RA_FLAG_MANAGED 0x80 #define ND_RA_FLAG_OTHER 0x40 #define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16[1]",
      "ja": "#define nd_ra_type nd_ra_hdr.icmp6_typeの#define nd_ra_code nd_ra_hdr.icmp6_codeの#define nd_ra_cksum nd_ra_hdr.icmp6_cksumの#define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8 [0]の#define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8 [1]の#define ND_RA_FLAG_MANAGEDは0x80の#define ND_RA_FLAG_OTHER 0x40のに#define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16 [1]"
    },
    {
      "indent": 6,
      "text": "struct nd_neighbor_solicit {   /* neighbor solicitation */\n  struct icmp6_hdr  nd_ns_hdr;\n  struct in6_addr   nd_ns_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_ns_type nd_ns_hdr.icmp6_type #define nd_ns_code nd_ns_hdr.icmp6_code #define nd_ns_cksum nd_ns_hdr.icmp6_cksum #define nd_ns_reserved nd_ns_hdr.icmp6_data32[0]",
      "ja": "#define nd_ns_type nd_ns_hdr.icmp6_typeの#define nd_ns_code nd_ns_hdr.icmp6_codeの#define nd_ns_cksum nd_ns_hdr.icmp6_cksumの#define nd_ns_reserved nd_ns_hdr.icmp6_data32 [0]"
    },
    {
      "indent": 6,
      "text": "struct nd_neighbor_advert {    /* neighbor advertisement */\n  struct icmp6_hdr  nd_na_hdr;\n  struct in6_addr   nd_na_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_na_type               nd_na_hdr.icmp6_type\n#define nd_na_code               nd_na_hdr.icmp6_code\n#define nd_na_cksum              nd_na_hdr.icmp6_cksum\n#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]\n#if     BYTE_ORDER == BIG_ENDIAN\n#define ND_NA_FLAG_ROUTER        0x80000000\n#define ND_NA_FLAG_SOLICITED     0x40000000\n#define ND_NA_FLAG_OVERRIDE      0x20000000\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define ND_NA_FLAG_ROUTER        0x00000080\n#define ND_NA_FLAG_SOLICITED     0x00000040\n#define ND_NA_FLAG_OVERRIDE      0x00000020\n#endif struct nd_redirect {           /* redirect */\n  struct icmp6_hdr  nd_rd_hdr;\n  struct in6_addr   nd_rd_target; /* target address */\n  struct in6_addr   nd_rd_dst;    /* destination address */\n    /* could be followed by options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define nd_rd_type nd_rd_hdr.icmp6_type #define nd_rd_code nd_rd_hdr.icmp6_code #define nd_rd_cksum nd_rd_hdr.icmp6_cksum #define nd_rd_reserved nd_rd_hdr.icmp6_data32[0]",
      "ja": "#define nd_rd_type nd_rd_hdr.icmp6_typeの#define nd_rd_code nd_rd_hdr.icmp6_codeの#define nd_rd_cksum nd_rd_hdr.icmp6_cksumの#define nd_rd_reserved nd_rd_hdr.icmp6_data32 [0]"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_hdr {         /* Neighbor discovery option header */\n  uint8_t  nd_opt_type;\n  uint8_t  nd_opt_len;      /* in units of 8 octets */\n    /* followed by option specific data */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ND_OPT_SOURCE_LINKADDR 1 #define ND_OPT_TARGET_LINKADDR 2 #define ND_OPT_PREFIX_INFORMATION 3 #define ND_OPT_REDIRECTED_HEADER 4 #define ND_OPT_MTU 5",
      "ja": "#define ND_OPT_SOURCE_LINKADDR 1の#define ND_OPT_TARGET_LINKADDR 2の#define ND_OPT_PREFIX_INFORMATION 3の#define ND_OPT_REDIRECTED_HEADER 4の#define ND_OPT_MTU 5"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_prefix_info {    /* prefix information */\n  uint8_t   nd_opt_pi_type;\n  uint8_t   nd_opt_pi_len;\n  uint8_t   nd_opt_pi_prefix_len;\n  uint8_t   nd_opt_pi_flags_reserved;\n  uint32_t  nd_opt_pi_valid_time;\n  uint32_t  nd_opt_pi_preferred_time;\n  uint32_t  nd_opt_pi_reserved2;\n  struct in6_addr  nd_opt_pi_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ND_OPT_PI_FLAG_ONLINK 0x80 #define ND_OPT_PI_FLAG_AUTO 0x40",
      "ja": "#define ND_OPT_PI_FLAG_ONLINKは0x80に#define ND_OPT_PI_FLAG_AUTOは0x40"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_rd_hdr {         /* redirected header */\n  uint8_t   nd_opt_rh_type;\n  uint8_t   nd_opt_rh_len;\n  uint16_t  nd_opt_rh_reserved1;\n  uint32_t  nd_opt_rh_reserved2;\n    /* followed by IP header and data */\n}; struct nd_opt_mtu {            /* MTU option */\n  uint8_t   nd_opt_mtu_type;\n  uint8_t   nd_opt_mtu_len;\n  uint16_t  nd_opt_mtu_reserved;\n  uint32_t  nd_opt_mtu_mtu;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We note that the nd_na_flags_reserved flags have the same byte ordering problems as we showed with ip6f_offlg.",
      "ja": "我々はip6f_offlgで示したようnd_na_flags_reservedフラグは同じバイト順序の問題を抱えていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Multicast Listener Discovery Definitions",
      "section_title": true,
      "ja": "2.2.3。マルチキャストリスナ発見の定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造および定義は、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define MLD_LISTENER_QUERY 130 #define MLD_LISTENER_REPORT 131 #define MLD_LISTENER_REDUCTION 132",
      "ja": "#define MLD_LISTENER_QUERY 130の#define MLD_LISTENER_REPORT 131の#define MLD_LISTENER_REDUCTION 132"
    },
    {
      "indent": 6,
      "text": "struct mld_hdr {\n  struct icmp6_hdr  mld_icmp6_hdr;\n  struct in6_addr   mld_addr; /* multicast address */\n};\n#define mld_type                 mld_icmp6_hdr.icmp6_type\n#define mld_code                 mld_icmp6_hdr.icmp6_code\n#define mld_cksum                mld_icmp6_hdr.icmp6_cksum\n#define mld_maxdelay             mld_icmp6_hdr.icmp6_data16[0]\n#define mld_reserved             mld_icmp6_hdr.icmp6_data16[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2.4. ICMPv6 Router Renumbering Definitions",
      "section_title": true,
      "ja": "2.2.4。 ICMPv6のルータリナンバリングの定義"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造および定義は、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define ICMP6_ROUTER_RENUMBERING    138   /* router renumbering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct icmp6_router_renum {  /* router renumbering header */\n  struct icmp6_hdr  rr_hdr;\n  uint8_t           rr_segnum;\n  uint8_t           rr_flags;\n  uint16_t          rr_maxdelay;\n  uint32_t          rr_reserved;\n};\n#define rr_type                  rr_hdr.icmp6_type\n#define rr_code                  rr_hdr.icmp6_code\n#define rr_cksum                 rr_hdr.icmp6_cksum\n#define rr_seqnum                rr_hdr.icmp6_data32[0]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Router renumbering flags */\n#define ICMP6_RR_FLAGS_TEST        0x80\n#define ICMP6_RR_FLAGS_REQRESULT   0x40\n#define ICMP6_RR_FLAGS_FORCEAPPLY  0x20\n#define ICMP6_RR_FLAGS_SPECSITE    0x10\n#define ICMP6_RR_FLAGS_PREVDONE    0x08",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct rr_pco_match {    /* match prefix part */\n  uint8_t          rpm_code;\n  uint8_t          rpm_len;\n  uint8_t          rpm_ordinal;\n  uint8_t          rpm_matchlen;\n  uint8_t          rpm_minlen;\n  uint8_t          rpm_maxlen;\n  uint16_t         rpm_reserved;\n  struct in6_addr  rpm_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* PCO code values */\n#define RPM_PCO_ADD              1\n#define RPM_PCO_CHANGE           2\n#define RPM_PCO_SETGLOBAL        3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct rr_pco_use {    /* use prefix part */\n  uint8_t          rpu_uselen;\n  uint8_t          rpu_keeplen;\n  uint8_t          rpu_ramask;\n  uint8_t          rpu_raflags;\n  uint32_t         rpu_vltime;\n  uint32_t         rpu_pltime;\n  uint32_t         rpu_flags;\n  struct in6_addr  rpu_prefix;\n};\n#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK   0x20\n#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO     0x10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if BYTE_ORDER == BIG_ENDIAN\n#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000\n#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000\n#elif BYTE_ORDER == LITTLE_ENDIAN\n#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80\n#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40\n#endif struct rr_result {    /* router renumbering result message */\n  uint16_t         rrr_flags;\n  uint8_t          rrr_ordinal;\n  uint8_t          rrr_matchedlen;\n  uint32_t         rrr_ifid;\n  struct in6_addr  rrr_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#if BYTE_ORDER == BIG_ENDIAN #define ICMP6_RR_RESULT_FLAGS_OOB 0x0002 #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001 #elif BYTE_ORDER == LITTLE_ENDIAN #define ICMP6_RR_RESULT_FLAGS_OOB 0x0200 #define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0100 #endif",
      "ja": "BYTE_ORDERの#if == BIG_ENDIANの#define ICMP6_RR_RESULT_FLAGS_OOB 0×0002の#define ICMP6_RR_RESULT_FLAGS_FORBIDDENは0x0001 #elifのBYTE_ORDER == LITTLE_ENDIANの#define ICMP6_RR_RESULT_FLAGS_OOB 0x0200の#define ICMP6_RR_RESULT_FLAGS_FORBIDDENは0x0100 #endifの"
    },
    {
      "indent": 0,
      "text": "2.3. Address Testing Macros",
      "section_title": true,
      "ja": "2.3。テストマクロアドレス"
    },
    {
      "indent": 3,
      "text": "The basic API ([RFC-3493]) defines some macros for testing an IPv6 address for certain properties. This API extends those definitions with additional address testing macros, defined as a result of including <netinet/in.h>.",
      "ja": "基本的なAPI（[RFC-3493]）は、特定のプロパティのIPv6アドレスをテストするためのいくつかのマクロを定義します。このAPIは、<netinetの/ in.h>を含めた結果として定義され、追加のアドレステストマクロとそれらの定義を拡張します。"
    },
    {
      "indent": 6,
      "text": "int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);",
      "ja": "int型IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。"
    },
    {
      "indent": 3,
      "text": "This macro returns non-zero if the addresses are equal; otherwise it returns zero.",
      "ja": "アドレスが等しい場合、このマクロは、非ゼロ返します。それ以外の場合は0を返します。"
    },
    {
      "indent": 0,
      "text": "2.4. Protocols File",
      "section_title": true,
      "ja": "2.4。プロトコルファイル"
    },
    {
      "indent": 3,
      "text": "Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP). Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function. For example, the Ping program contains code of the form",
      "ja": "多くのホストは、様々なIPプロトコルの名前とそのプロトコル番号を含む、ファイル/ etc /プロトコルを提供する（例えば、そのプロトコルのIPv4ヘッダのプロトコルフィールドの値は、ICMPのような1）。いくつかのプログラムは、次いで、ソケット（）関数の3番目の引数として指定されたプロトコル値を得るために、関数getprotobyname（）を呼び出します。たとえば、pingプログラムは、フォームのコードが含まれています"
    },
    {
      "indent": 6,
      "text": "struct protoent *proto;",
      "ja": "構造体protoent *プロト。"
    },
    {
      "indent": 6,
      "text": "proto = getprotobyname(\"icmp\");",
      "ja": "プロト= getprotobyname（ \"ICMP\"）。"
    },
    {
      "indent": 6,
      "text": "s = socket(AF_INET, SOCK_RAW, proto->p_proto);",
      "ja": "S =ソケット（aphaiset、sockra、プロト> pproto）。"
    },
    {
      "indent": 3,
      "text": "Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.",
      "ja": "一般的な名前はgetprotoXXX（）関数を呼び出すアプリケーションの移植性を提供するために、このファイルに新しいIPv6プロトコルのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "We define the following protocol names with the values shown. These are taken under http://www.iana.org/numbers.html.",
      "ja": "私たちは、示された値と、次のプロトコル名を定義します。これらはhttp://www.iana.org/numbers.html下で撮影されています。"
    },
    {
      "indent": 6,
      "text": "hopopt 0 # hop-by-hop options for ipv6 ipv6 41 # ipv6 ipv6-route 43 # routing header for ipv6 ipv6-frag 44 # fragment header for ipv6 esp 50 # encapsulating security payload for ipv6 ah 51 # authentication header for ipv6 ipv6-icmp 58 # icmp for ipv6 ipv6-nonxt 59 # no next header for ipv6 ipv6-opts 60 # destination options for ipv6",
      "ja": "hopopt 0 ESP 50＃IPv6用のIPv6ああ51＃認証ヘッダのセキュリティペイロードをカプセル化IPv6のためのIPv6のIPv6-FRAG 44＃フラグメントヘッダのIPv6のIPv6 41＃のIPv6 IPv6のルート43＃ルーティングヘッダの＃ホップバイホップオプションipv6- ICMPのIPv6のIPv6-nonxt 59＃58＃のICMPには次のヘッダは、IPv6のIPv6 60の＃宛先オプションをIPv6にオプトありません"
    },
    {
      "indent": 0,
      "text": "3. IPv6 Raw Sockets",
      "section_title": true,
      "ja": "3. IPv6のrawソケット"
    },
    {
      "indent": 3,
      "text": "Raw sockets bypass the transport layer (TCP or UDP). With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process. An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89. With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process. Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).",
      "ja": "rawソケットは、トランスポート層（TCPまたはUDP）をバイパスします。 IPv4では、rawソケットがICMPv4の、IGMPv4にアクセスするには、カーネルが処理しないことをプロトコルフィールドを含むIPv4のデータグラムを読み書きするために使用されています。それはICMPv6のために使用され、カーネルが処理をしないことを次のヘッダーフィールドを含むIPv6データグラムを読み書きするIPv6の生のソケットをIPv4プロトコルフィールド89を使用するので、後者の例は、OSPFのルーティングデーモンです。後者の例は、IPv6とRSVP（プロトコルフィールド46）のためのOSPFのルーティングデーモンです。"
    },
    {
      "indent": 3,
      "text": "All data sent via raw sockets must be in network byte order and all data received via raw sockets will be in network byte order. This differs from the IPv4 raw sockets, which did not specify a byte ordering and used the host's byte order for certain IP header fields.",
      "ja": "rawソケット経由で送信されたすべてのデータはネットワークバイト順でなければならず、生のソケットを介して受信されたすべてのデータはネットワークバイト順になります。これは、バイト順序を指定し、特定のIPヘッダフィールドのためのホストのバイト順序を使用していなかったのIPv4生ソケットとは異なります。"
    },
    {
      "indent": 3,
      "text": "Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be sent or received using the IPv6 raw sockets API. Instead, ancillary data objects are used to transfer the extension headers and hoplimit information, as described in Section 6. Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.",
      "ja": "IPv4の生のソケットから別の違いは、完全なパケット（つまり、拡張ヘッダを持つIPv6パケット）のIPv6生ソケットAPIを使用して送信または受信することができないことです。代わりに、補助的なデータオブジェクトは、セクション6で説明したようにアプリケーションが完全なIPv6パケットにアクセスする必要がある場合、拡張ヘッダとhoplimit情報を転送するために使用される、そのようなデータリンクインターフェイスBPFやDLPIのようないくつかの他の技術が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "All fields except the flow label in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output. All fields except the flow label in a received IPv6 header (other than the version number and Next Header fields) and all extension headers that an application might want to know are also made available to the application as ancillary data on input. Hence there is no need for a socket option similar to the IPv4 IP_HDRINCL socket option and on receipt the application will only receive the payload i.e., the data after the IPv6 header and all the extension headers.",
      "ja": "IPv6におけるフローラベルを除くすべてのフィールドは、アプリケーションが変更する可能性があることをヘッダ（すなわち、バージョン番号以外のすべて）を出力するためのアプリケーションで補助的なデータ及び/又はソケットオプションを使用して修正することができます。アプリケーションが知りたいかもしれません（バージョン番号と次ヘッダフィールドを除く）を受信したIPv6ヘッダ内のフローラベルを除くすべてのフィールドと全ての拡張ヘッダは、入力上の補助データとしてアプリケーションに利用可能にされます。従ってのみすなわちペイロード、IPv6ヘッダの後のデータとすべての拡張ヘッダを受信するアプリケーションのIPv4 IP_HDRINCLソケットオプションおよび領収書に似たソケットオプションは不要です。"
    },
    {
      "indent": 3,
      "text": "This API does not define access to the flow label field, because today there is no standard usage of the field.",
      "ja": "今日分野の標準的な使用法がないので、このAPIは、フローラベルフィールドへのアクセスを定義しません。"
    },
    {
      "indent": 3,
      "text": "When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragment headers. On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.",
      "ja": "生のソケットに書き込むときに、そのサイズがパスMTUを超えた場合、カーネルは自動的に必要な断片ヘッダを挿入し、パケットを断片化します。入力時にカーネルは受け取った断片を再構成するので、生のソケットの読者は、任意のフラグメントヘッダを見たことがありません。"
    },
    {
      "indent": 3,
      "text": "When we say \"an ICMPv6 raw socket\" we mean a socket created by calling the socket function with the three arguments AF_INET6, SOCK_RAW, and IPPROTO_ICMPV6.",
      "ja": "私たちは「ICMPv6の生のソケット」と言うとき、私たちは三つの引数AF_INET6、SOCK_RAW、およびIPPROTO_ICMPV6とソケット関数を呼び出すことによって作成されたソケットを意味します。"
    },
    {
      "indent": 3,
      "text": "Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO_RAW, whose value is normally 255, to have it mean that the application will send down complete packets including the IPv4 header. (Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP_HDRINCL socket option was added.) We note that IPPROTO_RAW has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next-header field).",
      "ja": "ほとんどのIPv4実装では値は通常255で、それはアプリケーションがIPv4ヘッダを含む完全なパケットをダウン送信することを意味する持っているIPPROTO_RAWのソケットに第三引数（）で作成した生のソケットに特別な治療を与えます。 （注：この機能は、tracerouteをサポートするために、バン・ジェイコブソンによって1988年にはIPv4に加えて、IP_HDRINCLソケットオプションが追加される前の完全なIPヘッダは、アプリケーションによって渡されることを可能にする。）我々はIPPROTO_RAWがIPv6に特別な意味を持っていないことに注意してください生のソケット（およびIANAは現在、次のヘッダフィールドとして使用される255の値を予約します）。"
    },
    {
      "indent": 0,
      "text": "3.1. Checksums",
      "section_title": true,
      "ja": "3.1。チェックサム"
    },
    {
      "indent": 3,
      "text": "The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.",
      "ja": "このチェックサムは必須であるため、カーネルは、ICMPv6の生のソケット用のICMPv6チェックサムを計算して挿入します。"
    },
    {
      "indent": 3,
      "text": "For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO_ICMPV6), the application must set the new IPV6_CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error. This option prevents applications from having to perform source address selection on the packets they send. The checksum will incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-2460]. This new socket option also specifies an integer offset into the user data of where the checksum is located.",
      "ja": "他の生のIPv6ソケット（すなわちIPPROTO_ICMPV6以外の第三引数で作成された生のIPv6ソケットのために）、カーネルを持つ新しいIPV6_CHECKSUMソケットオプションを設定する必要があり、アプリケーション（1）を計算して出力するためのチェックサムを格納し、（2 ）チェックサムがエラーである場合、パケットを廃棄する、入力に受信したチェックサムを検証します。このオプションは、彼らが送信するパケットに送信元アドレス選択を実行することからアプリケーションを防ぎます。チェックサムは、[RFC-2460]のセクション8.1で定義されたIPv6疑似ヘッダを組み込みます。この新しいソケットオプションもチェックサムが配置されている場所のユーザデータへのオフセットの整数を指定します。"
    },
    {
      "indent": 6,
      "text": "int  offset = 2;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset,\n           sizeof(offset));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the offset to -1 also disables the option. By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.",
      "ja": "デフォルトでは、このソケットオプションが無効になっています。オフセットに-1を設定すると、オプションを無効にします。無効にすることで、我々は、（1）カーネルが計算し、発信パケットのチェックサムを格納し、（2）カーネルは、受信したパケットのチェックサムを検証しませんしませんを意味します。"
    },
    {
      "indent": 3,
      "text": "This option assumes the use of the 16-bit one's complement of the one's complement sum as the checksum algorithm and that the checksum field is aligned on a 16-bit boundary. Thus, specifying a positive odd value as offset is invalid, and setsockopt() will fail for such offset values.",
      "ja": "このオプションは、チェックサムアルゴリズムなどとチェックサムフィールドは、16ビット境界で整列されている1の補数の和の16ビットの1の補数の使用を前提としています。このように、オフセットとして正の奇数の値を指定することは無効であり、のsetsockopt（）は、オフセット値で失敗します。"
    },
    {
      "indent": 3,
      "text": "An attempt to set IPV6_CHECKSUM for an ICMPv6 socket will fail. Also, an attempt to set or get IPV6_CHECKSUM for a non-raw IPv6 socket will fail.",
      "ja": "ICMPv6のソケット用IPV6_CHECKSUMを設定する試みは失敗します。また、非生IPv6ソケット用IPV6_CHECKSUMを設定または取得しようとする試みは失敗します。"
    },
    {
      "indent": 3,
      "text": "(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.)",
      "ja": "（注：チェックサムは常にのICMPv6ソケットのカーネルによって計算されるので、アプリケーションはこのAPIを使用して、おそらくテスト目的のために間違ったチェックサム（）とのICMPv6パケットを生成することができません。）"
    },
    {
      "indent": 0,
      "text": "3.2. ICMPv6 Type Filtering",
      "section_title": true,
      "ja": "3.2。 ICMPv6のタイプのフィルタリング"
    },
    {
      "indent": 3,
      "text": "ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel. (We say \"most\" and not \"all\" because Berkeley-derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket. Instead these three messages are processed entirely by the kernel.) But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4. This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three multicast listener discovery messages.",
      "ja": "ICMPv4の生のソケットは、カーネルが受信したほとんどのICMPv4のメッセージを受信します。 （バークレー由来カーネルがrawソケットにエコー要求、タイムスタンプ要求、またはアドレスマスク要求を渡すことはありませんので、我々は。代わりに、これらの3件のメッセージがカーネルによって完全に処理されます。「すべて」「ほとんど」とされていないと言う）しかし、ICMPv6がスーパーセットでICMPv4のの、またIGMPv4とARPv4の機能を含みます。近隣要請、近隣広告、および3つのマルチキャストリスナーディスカバリメッセージとともに、ICMPv4のに似たICMPメッセージ：これはICMPv6の生のソケットが潜在的に多くのより多くのICMPv4生ソケットで受信されるよりもメッセージを受信できることを意味します。"
    },
    {
      "indent": 3,
      "text": "Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types. To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead. Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.",
      "ja": "ICMPv6メッセージの種類の小さなサブセットのみについてのICMPv6 rawソケットのケアを使用してほとんどのアプリケーション。大きなオーバーヘッドが発生することができ、ユーザにカーネルから余分なICMPv6メッセージを転送します。したがって、このAPIはICMPv6のタイプフィールドでICMPv6メッセージをフィルタリングする方法を含みます。"
    },
    {
      "indent": 3,
      "text": "Each ICMPv6 raw socket has an associated filter whose datatype is defined as",
      "ja": "各ICMPv6の生のソケットは、そのデータ型として定義されている関連するフィルタを有します"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter;",
      "ja": "構造体icmp6_filter。"
    },
    {
      "indent": 3,
      "text": "This structure, along with the macros and constants defined later in this section, are defined as a result of including the <netinet/icmp6.h>.",
      "ja": "この構造は、この節の後半で定義されたマクロおよび定数とともに、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO_ICMPV6 and an option name of ICMP6_FILTER.",
      "ja": "現在のフィルタは、フェッチとIPPROTO_ICMPV6のレベルとICMP6_FILTERのオプション名とのgetsockopt（）とのsetsockopt（）を使用して格納されます。"
    },
    {
      "indent": 3,
      "text": "Six macros operate on an icmp6_filter structure:",
      "ja": "シックス・マクロはicmp6_filter構造に動作します。"
    },
    {
      "indent": 6,
      "text": "void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int  ICMP6_FILTER_WILLPASS (int,\n                            const struct icmp6_filter *);\nint  ICMP6_FILTER_WILLBLOCK(int,\n                            const struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The first argument to the last four macros (an integer) is an ICMPv6 message type, between 0 and 255. The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros and is examined by the last two macros.",
      "ja": "最後の4つのマクロ（整数）の最初の引数は、ICMPv6メッセージのタイプであり、0と255の間にすべての6つのマクロへのポインタ引数は、最初の4つのマクロによって変更され、最終によって検査されるフィルタへのポインタであります二つのマクロ。"
    },
    {
      "indent": 3,
      "text": "The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.",
      "ja": "最初の二つのマクロ、SETPASSALLとSETBLOCKALL、私たちはすべてのICMPv6メッセージがアプリケーションに渡されるか、すべてのICMPv6メッセージがアプリケーションに渡されてからブロックされていることをされていることを指定できます。"
    },
    {
      "indent": 3,
      "text": "The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).",
      "ja": "次の二つのマクロ、SETPASSとSETBLOCK、私たちは与えられたのICMPv6タイプのメッセージがアプリケーションに渡される、またはアプリケーション（ブロック）に渡されないべきであることを指定しましょう。"
    },
    {
      "indent": 3,
      "text": "The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.",
      "ja": "最後の二つのマクロ、WILLPASSとWILLBLOCKは、指定されたメッセージタイプがアプリケーションに渡されるか、フィルタによってアプリケーションに渡されるから遮断されているかどうかをtrueまたはfalseを返すによって第二引数によって指さ。"
    },
    {
      "indent": 3,
      "text": "When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.",
      "ja": "ICMPv6の生のソケットが作成されると、それはデフォルトでは、アプリケーションにすべてのICMPv6メッセージタイプを渡します。"
    },
    {
      "indent": 3,
      "text": "As an example, a program that wants to receive only router advertisements could execute the following:",
      "ja": "例として、唯一のルータ広告を受信したい番組は、次のコマンドを実行できます。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter myfilt;",
      "ja": "構造体icmp6_filterのmyfilt。"
    },
    {
      "indent": 6,
      "text": "fd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);",
      "ja": "FD =ソケット（AF_INET6、SOCK_RAW、IPPROTO_ICMPV6）"
    },
    {
      "indent": 6,
      "text": "ICMP6_FILTER_SETBLOCKALL(&myfilt);\nICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt);\nsetsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "sizeof(myfilt));",
      "ja": "sizeof（myfilt））。"
    },
    {
      "indent": 3,
      "text": "The filter structure is declared and then initialized to block all messages types. The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().",
      "ja": "フィルタ構造が宣言され、すべてのメッセージの種類をブロックするために初期化されます。フィルタ構造は、ルータ広告メッセージをアプリケーションに渡すことができるように変更され、フィルタは、（）のsetsockoptを使用してインストールされています。"
    },
    {
      "indent": 3,
      "text": "In order to clear an installed filter the application can issue a setsockopt for ICMP6_FILTER with a zero length. When no such filter has been installed, getsockopt() will return the kernel default filter.",
      "ja": "インストールフィルタをクリアするために、アプリケーションは、ゼロ長のICMP6_FILTERためのsetsockoptを発行することができます。そのようなフィルタがインストールされていない場合には、のgetsockopt（）カーネルのデフォルトのフィルタを返します。"
    },
    {
      "indent": 3,
      "text": "The icmp6_filter structure is similar to the fd_set datatype used with the select() function in the sockets API. The icmp6_filter structure is an opaque datatype and the application should not care how it is implemented. All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.",
      "ja": "icmp6_filter構造は、ソケットAPIの選択（）関数で使用FD_SETデータ型と類似しています。 icmp6_filter構造は不透明なデータ型であり、アプリケーションは、それがどのように実装されるか気にしてはいけません。すべてのアプリケーションは、このデータ型で行い、この型の変数を割り当てる（GETSOCKOPTするために、この型の変数へのポインタを渡す）とのsetsockopt（）、と私たちは定義された6つのマクロを使用して、この型の変数を操作しています。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.",
      "ja": "それにもかかわらず、このデータ型の単純な実装と6つのマクロを示す価値があります。"
    },
    {
      "indent": 6,
      "text": "struct icmp6_filter {\n  uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define ICMP6_FILTER_WILLPASS(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) & \\ (1 << ((type) & 31))) != 0) #define ICMP6_FILTER_WILLBLOCK(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) & \\ (1 << ((type) & 31))) == 0) #define ICMP6_FILTER_SETPASS(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) |= \\ (1 << ((type) & 31)))) #define ICMP6_FILTER_SETBLOCK(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) &= \\ ~(1 << ((type) & 31)))) #define ICMP6_FILTER_SETPASSALL(filterp) \\ memset((filterp), 0xFF, sizeof(struct icmp6_filter)) #define ICMP6_FILTER_SETBLOCKALL(filterp) \\ memset((filterp), 0, sizeof(struct icmp6_filter))",
      "ja": "#define ICMP6_FILTER_WILLPASS（タイプ、filterpは）\\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）＆\\（1 <<（（タイプ）＆31）））！= 0）の#define ICMP6_FILTER_WILLBLOCK（タイプ、filterpは）\\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）＆\\（1 <<（（タイプ）＆31）））== 0）の#define ICMP6_FILTER_SETPASS（タイプ、filterpは） \\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）| = \\（1 <<（（タイプ）＆31））））の#define ICMP6_FILTER_SETBLOCK（タイプ、filterpは）\\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）＆= \\〜（1 <<（（タイプ）＆31））））の#define ICMP6_FILTER_SETPASSALL（filterpは）\\のmemset（（filterpは）、0xFFで、はsizeof（構造体icmp6_filter ））の#define ICMP6_FILTER_SETBLOCKALL（filterpは）\\のmemset（（filterpは）、0、はsizeof（構造体icmp6_filter））"
    },
    {
      "indent": 3,
      "text": "(Note: These sample definitions have two limitations that an implementation may want to change. The first four macros evaluate their first argument two times. The second two macros require the inclusion of the <string.h> header for the memset() function.)",
      "ja": "（注：これらのサンプルの定義は、実装は、最初の4つのマクロは、その最初の引数を2回評価変更することを第2のマクロは<string.hの>ヘッダのmemset（）関数を含めることを必要とする2つの制限を有します。 ）"
    },
    {
      "indent": 0,
      "text": "3.3. ICMPv6 Verification of Received Packets",
      "section_title": true,
      "ja": "3.3。受信したパケットのICMPv6の検証"
    },
    {
      "indent": 3,
      "text": "The protocol stack will verify the ICMPv6 checksum and discard any packets with invalid checksums.",
      "ja": "プロトコルスタックは、ICMPv6のチェックサムを検証し、不正なチェックサムを持つパケットを廃棄します。"
    },
    {
      "indent": 3,
      "text": "An implementation might perform additional validity checks on the ICMPv6 message content and discard malformed packets. However, a portable application must not assume that such validity checks have been performed.",
      "ja": "実装は、ICMPv6メッセージの内容に追加の妥当性チェックを実行し、不正なパケットを捨てるかもしれません。しかし、ポータブルアプリケーションでは、このような妥当性チェックが行われていると仮定してはいけません。"
    },
    {
      "indent": 3,
      "text": "The protocol stack should not automatically discard packets if the ICMP type is unknown to the stack. For extensibility reasons received ICMP packets with any type (informational or error) must be passed to the applications (subject to ICMP6_FILTER filtering on the type value and the checksum verification).",
      "ja": "ICMPタイプがスタックに知られていない場合は、プロトコル・スタックは、自動的にパケットを捨てるべきではありません。拡張性の理由は、任意のタイプのICMPパケットを受信するための（情報またはエラー）がアプリケーション（タイプ値にICMP6_FILTERフィルタリングとチェックサム検証の対象）に渡されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Access to IPv6 and Extension Headers",
      "section_title": true,
      "ja": "IPv6と拡張ヘッダーへ4.アクセス"
    },
    {
      "indent": 3,
      "text": "Applications need to be able to control IPv6 header and extension header content when sending as well as being able to receive the content of these headers. This is done by defining socket option types which can be used both with setsockopt and with ancillary data. Ancillary data is discussed in Appendix A. The following optional information can be exchanged between the application and the kernel:",
      "ja": "アプリケーションは、これらのヘッダのコンテンツを受信することができるだけでなく送信時にIPv6ヘッダと拡張ヘッダの内容を制御できるようにする必要があります。これは、のsetsockoptとし、補助データの両方で使用することができますソケットオプションの種類を定義することによって行われます。補助データは、付録Aに記載されている次のオプションの情報は、アプリケーションとカーネルとの間で交換することができます。"
    },
    {
      "indent": 3,
      "text": "1. The send/receive interface and source/destination address, 2. The hop limit, 3. Next hop address, 4. The traffic class, 5. Routing header, 6. Hop-by-Hop options header, and 7. Destination options header.",
      "ja": "1.送信/受信インターフェース及びソース/宛先アドレス、2ホップリミット、3次ホップアドレス、4トラフィッククラス、5ルーティングヘッダ、6ホップバイホップオプションヘッダ、および7宛先オプションヘッダー。"
    },
    {
      "indent": 3,
      "text": "First, to receive any of this optional information (other than the next hop address, which can only be set) on a UDP or raw socket, the application must call setsockopt() to turn on the corresponding flag:",
      "ja": "まず、UDPまたは生ソケットに（のみ設定することができる次ホップアドレス以外の）この任意の情報のいずれかを受信するために、アプリケーションは、対応するフラグをオンにするのsetsockopt（）を呼び出す必要があります。"
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "= 1の整数;"
    },
    {
      "indent": 6,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR,    &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS,   &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects.",
      "ja": "これらのオプションのいずれかが有効な場合、対応するデータは、一つ以上の補助的なデータオブジェクトとして）のrecvmsg（の制御情報として返されます。"
    },
    {
      "indent": 3,
      "text": "This document does not define how to receive the optional information on a TCP socket. See Section 4.1 for more details.",
      "ja": "このドキュメントでは、TCPソケットのオプションの情報を受信する方法を定義していません。詳細は、4.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Two different mechanisms exist for sending this optional information:",
      "ja": "二つの異なるメカニズムは、このオプションの情報を送信するために存在します。"
    },
    {
      "indent": 3,
      "text": "1. Using setsockopt to specify the option content for a socket. These are known \"sticky\" options since they affect all transmitted packets on the socket until either a new setsockopt is done or the options are overridden using ancillary data.",
      "ja": "1.ソケットのオプションの内容を指定するにsetsockoptを使用しました。新しいのsetsockoptのいずれかが行われているかのオプションが補助的なデータを使用して上書きされるまで、彼らはソケット上のすべての送信パケットに影響を与えるため、これらは「スティッキー」オプションを知られています。"
    },
    {
      "indent": 3,
      "text": "2. Using ancillary data to specify the option content for a single datagram. This only applies to datagram and raw sockets; not to TCP sockets.",
      "ja": "2.単一のデータグラムのためのオプションの内容を指定する補助データを使用しました。これは、データグラムとrawソケットに適用されます。ないTCPソケットへ。"
    },
    {
      "indent": 3,
      "text": "The three socket option parameters and the three cmsghdr fields that describe the options/ancillary data objects are summarized as:",
      "ja": "3つのソケットオプションパラメータおよびオプションについて説明し3つのcmsghdrフィールドは/補助的なデータオブジェクトは、次のように要約されます。"
    },
    {
      "indent": 6,
      "text": "opt level/    optname/          optval/\ncmsg_level    cmsg_type         cmsg_data[]\n------------  ------------      ------------------------\nIPPROTO_IPV6  IPV6_PKTINFO      in6_pktinfo structure\nIPPROTO_IPV6  IPV6_HOPLIMIT     int\nIPPROTO_IPV6  IPV6_NEXTHOP      socket address structure\nIPPROTO_IPV6  IPV6_RTHDR        ip6_rthdr structure\nIPPROTO_IPV6  IPV6_HOPOPTS      ip6_hbh structure\nIPPROTO_IPV6  IPV6_DSTOPTS      ip6_dest structure\nIPPROTO_IPV6  IPV6_RTHDRDSTOPTS ip6_dest structure\nIPPROTO_IPV6  IPV6_TCLASS       int",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "(Note: IPV6_HOPLIMIT can be used as ancillary data items only)",
      "ja": "（注：IPV6_HOPLIMITは、補助的なデータ項目として使用することができます）"
    },
    {
      "indent": 3,
      "text": "All these options are described in detail in Section 6, 7, 8 and 9. All the constants beginning with IPV6_ are defined as a result of including <netinet/in.h>.",
      "ja": "すべてのこれらのオプションは、セクション6、図7、図8に詳細に記載されているとIPV6_始まる9すべての定数は<netinetの/ in.h>を含めた結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "Note: We intentionally use the same constant for the cmsg_level member as is used as the second argument to getsockopt() and setsockopt() (what is called the \"level\"), and the same constant for the cmsg_type member as is used as the third argument to getsockopt() and setsockopt() (what is called the \"option name\").",
      "ja": "使用される（「レベル」と呼ばれるもの）、およびcmsg_type部材に対して同じ定数）（GETSOCKOPTするために第2の引数として使用されるように（我々が意図的cmsg_levelメンバ部材に同じ定数を使用）とのsetsockopt：注意第三GETSOCKOPTの引数（）とのsetsockopt（）（「オプション名」と呼ばれるもの）。"
    },
    {
      "indent": 3,
      "text": "Issuing getsockopt() for the above options will return the sticky option value i.e., the value set with setsockopt(). If no sticky option value has been set getsockopt() will return the following values:",
      "ja": "上記のオプションのためのgetsockopt（）を発行すると、スティッキーオプション値、すなわち、のsetsockoptで設定された値を（）戻ります。べたつきオプション値はgetsockoptの設定されていない場合（）は次の値を返します。"
    },
    {
      "indent": 3,
      "text": "- For the IPV6_PKTINFO option, it will return an in6_pktinfo structure with ipi6_addr being in6addr_any and ipi6_ifindex being zero.",
      "ja": " -  IPV6_PKTINFOオプションの場合、それはipi6_addrがIN6ADDR_ANYであるとipi6_ifindexゼロであるとin6_pktinfo構造を返します。"
    },
    {
      "indent": 3,
      "text": "- For the IPV6_TCLASS option, it will return the kernel default value.",
      "ja": " -  IPV6_TCLASSオプションの場合は、カーネルのデフォルト値を返します。"
    },
    {
      "indent": 3,
      "text": "- For other options, it will indicate the lack of the option value with optlen being zero.",
      "ja": " - その他のオプションについては、optlenがゼロであることでオプション値がないことを示します。"
    },
    {
      "indent": 3,
      "text": "The application does not explicitly need to access the data structures for the Routing header, Hop-by-Hop options header, and Destination options header, since the API to these features is through a set of inet6_rth_XXX() and inet6_opt_XXX() functions that we define in Section 7 and Section 10. Those functions simplify the interface to these features instead of requiring the application to know the intimate details of the extension header formats.",
      "ja": "我々のアプリケーションこれらの機能のAPIはinet6_rth_XXX（のセットを介しているので、明示的に、ルーティングヘッダ、ホップバイホップオプションヘッダー、および宛先オプションヘッダーのためのデータ構造にアクセスする必要はありません）とinet6_opt_XXX（）関数これらの機能は、代わりに、拡張ヘッダフォーマットの親密な詳細を知っているアプリケーションを必要とするこれらの機能へのインターフェースを簡素化する第7及び第10章に定義します。"
    },
    {
      "indent": 3,
      "text": "When specifying extension headers, this API assumes the header ordering and the number of occurrences of each header as described in [RFC-2460]. More details about the ordering issue will be discussed in Section 12.",
      "ja": "拡張ヘッダを指定する場合、[RFC-2460]に記載されているように、このAPIは、ヘッダの順序と各ヘッダの発生数を想定しています。発注の問題についての詳細は、12章で説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. TCP Implications",
      "section_title": true,
      "ja": "4.1。 TCPへの影響"
    },
    {
      "indent": 3,
      "text": "It is not possible to use ancillary data to transmit the above options for TCP since there is not a one-to-one mapping between send operations and the TCP segments being transmitted. Instead an application can use setsockopt to specify them as sticky options. When the application uses setsockopt to specify the above options it is expected that TCP will start using the new information when sending segments. However, TCP may or may not use the new information when retransmitting segments that were originally sent when the old sticky options were in effect.",
      "ja": "送信操作と送信されるTCPセグメントの間に1対1のマッピングが存在しないので、TCPのために上記のオプションを送信するために補助データを使用することは不可能です。代わりに、アプリケーションは、粘着性のオプションとして指定してsetsockoptを使用することができます。アプリケーションは、上記のオプションを指定するにsetsockoptを使用する場合には、セグメントを送信するときにTCPは、新しい情報を使用して起動することが期待されます。古いスティッキーオプションが有効であったとき、最初に送信されたセグメントを再送信するときしかし、TCPは、または新しい情報を使用しない場合があります。"
    },
    {
      "indent": 3,
      "text": "It is unclear how a TCP application can use received information (such as extension headers) due to the lack of mapping between received TCP segments and receive operations. In particular, the received information could not be used for access control purposes like on UDP and raw sockets.",
      "ja": "TCPアプリケーションが原因受信したTCPセグメントと受信動作との間のマッピングがないために（例えば、拡張ヘッダとして）受信した情報をどのように使用できるかは不明です。具体的には、受信した情報は、UDPと生ソケットのようなアクセス制御の目的で使用することができませんでした。"
    },
    {
      "indent": 3,
      "text": "This specification therefore does not define how to get the received information on TCP sockets. The result of the IPV6_RECVxxx options on a TCP socket is undefined as well.",
      "ja": "この仕様は、したがって、TCPソケットで受信した情報を取得する方法を定義していません。 TCPソケットのIPV6_RECVxxxオプションの結果も同様に定義されていません。"
    },
    {
      "indent": 0,
      "text": "4.2. UDP and Raw Socket Implications",
      "section_title": true,
      "ja": "4.2。 UDPと生ソケットの示唆"
    },
    {
      "indent": 3,
      "text": "The receive behavior for UDP and raw sockets is quite straightforward. After the application has enabled an IPV6_RECVxxx socket option it will receive ancillary data items for every recvmsg() call containing the requested information. However, if the information is not present in the packet the ancillary data item will not be included. For example, if the application enables IPV6_RECVRTHDR and a received datagram does not contain a Routing header there will not be an IPV6_RTHDR ancillary data item. Note that due to buffering in the socket implementation there might be some packets queued when an IPV6_RECVxxx option is enabled and they might not have the ancillary data information.",
      "ja": "UDPと生ソケットの受信動作は非常に簡単です。アプリケーションはIPV6_RECVxxxソケットオプションを有効にした後、それは要求された情報を含む、すべてのrecvmsg（）呼び出しのための補助的なデータ項目を受信します。しかし、情報が存在しない場合、パケット内の補助データ項目が含まれません。アプリケーションがIPV6_RECVRTHDRを可能にし、受信したデータグラムルーティングヘッダが含まれていない場合、例えば、IPV6_RTHDR補助的なデータ項目が存在しないであろう。原因ソケット実装におけるバッファリングにいくつかのパケットがあるかもしれないことに注意してくださいIPV6_RECVxxxオプションが有効になっていると、彼らは補助的なデータ情報を持っていない可能性がある場合キューに入れられました。"
    },
    {
      "indent": 3,
      "text": "For sending the application has the choice between using sticky options and ancillary data. The application can also use both having the sticky options specify the \"default\" and using ancillary data to override the default options.",
      "ja": "アプリケーションを送信するための粘着性のオプションと補助データを使用しての選択があります。また、アプリケーションは、両方の粘着性のオプションは、「デフォルト」を指定した、デフォルトのオプションを上書きするために補助的なデータを使用して使用することができます。"
    },
    {
      "indent": 3,
      "text": "When an ancillary data item is specified in a call to sendmsg(), the item will override an existing sticky option of the same name (if previously specified). For example, if the application has set IPV6_RTHDR using a sticky option and later passes IPV6_RTHDR as ancillary data this will override the IPV6_RTHDR sticky option and the routing header of the outgoing packet will be from the ancillary data item, not from the sticky option. Note, however, that other sticky options than IPV6_RTHDR will not be affected by the IPV6_RTHDR ancillary data item; the overriding mechanism only works for the same type of sticky options and ancillary data items.",
      "ja": "補助的なデータ項目が（）SENDMSGの呼び出しで指定された場合（以前に指定されている場合）、アイテムは、同じ名前の既存のstickyオプションを上書きします。アプリケーションがスティッキーオプションを使用してIPV6_RTHDRを設定し、それ以降の補助データとしてIPV6_RTHDRを通過した場合、例えば、これはIPV6_RTHDRスティッキーオプションを無効にし、発信パケットのルーティングヘッダは、補助的なデータ項目からではなく、粘着性の選択肢であろう。 IPV6_RTHDR以外スティッキーオプションがIPV6_RTHDR補助的データ項目によって影響されないこと、しかし、注意してください。オーバーライドメカニズムはスティッキーオプションと補助的なデータ項目の同じタイプのために働きます。"
    },
    {
      "indent": 3,
      "text": "(Note: the overriding rule is different from the one in RFC 2292. In RFC 2292, an ancillary data item overrode all sticky options previously defined. This was reasonable, because sticky options could only be specified as a set by a single socket option. However, in this API, each option is separated so that it can be specified as a single sticky option. Additionally, there are much more ancillary data items and sticky options than in RFC 2292, including ancillary-only one. Thus, it should be natural for application programmers to separate the overriding rule as well.)",
      "ja": "（注：スティッキーオプションは単一のソケットオプションによって設定されるように指定することができるので、最優先ルールは、RFC 2292でRFC 2292.内の1つ、オーバーライド全てスティッキーオプションが以前に定義された補助的なデータ項目と異なっている。これは、合理的でした。単一のstickyオプションとして指定することができるようになっている。また、補助的な専用のものを含むRFC 2292でよりもはるかに多くの補助的なデータ項目と粘着性の選択肢が存在する。このように、それがあるべきしかし、このAPIには、各オプションが分離され、自然なアプリケーションプログラマが同様に上書きルールを分離するため。）"
    },
    {
      "indent": 3,
      "text": "An application can also temporarily disable a particular sticky option by specifying a corresponding ancillary data item that could disable the sticky option when being used as an argument for a socket option. For example, if the application has set IPV6_HOPOPTS as a sticky option and later passes IPV6_HOPOPTS with a zero length as an ancillary data item, the packet will not have a Hop-by-Hop options header.",
      "ja": "アプリケーションはまた、一時的にソケットオプションの引数として使用されている粘着性のオプションを無効にすることができ、対応する補助データ項目を指定することにより、特定の粘着性のオプションを無効にすることができます。アプリケーションがスティッキーオプションとしてIPV6_HOPOPTSを設定し、それ以降の補助的なデータ項目として長さゼロでIPV6_HOPOPTSを通過した場合、例えば、パケットは、ホップバイホップオプションヘッダを持っていないであろう。"
    },
    {
      "indent": 0,
      "text": "5. Extensions to Socket Ancillary Data",
      "section_title": true,
      "ja": "ソケット補助データ5.拡張"
    },
    {
      "indent": 3,
      "text": "This specification uses ancillary data as defined in Posix with some compatible extensions, which are described in the following subsections. Section 20 will provide a detailed overview of ancillary data and related structures and macros, including the extensions.",
      "ja": "以下のサブセクションに記載されているいくつかの互換性の拡張とPOSIXに定義されるように、本明細書では補助データを使用します。第20節は、拡張を含む補助データと関連する構造とマクロの詳細な概要を提供します。"
    },
    {
      "indent": 0,
      "text": "5.1. CMSG_NXTHDR",
      "section_title": true,
      "ja": "5.1。 CMSG_NXTHDR"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n                            const struct cmsghdr *cmsg);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CMSG_NXTHDR() returns a pointer to the cmsghdr structure describing the next ancillary data object. Mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure. If there is not another ancillary data object, the return value is NULL.",
      "ja": "CMSG_NXTHDR（）は、次の補助データオブジェクトを記述したcmsghdr構造体へのポインタを返します。 MHDRはmsghdr構造体へのポインタであり、CMSGはcmsghdr構造体へのポインタです。別の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。"
    },
    {
      "indent": 3,
      "text": "The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned. That is, CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr). If there are no ancillary data objects, the return value is NULL.",
      "ja": "このマクロの次の動作は、このAPIの新しいですCMSGポインタの値がNULLの場合、最初の補助データオブジェクトを記述したcmsghdr構造体へのポインタが返されます。つまり、CMSG_NXTHDR（MHDR、NULL）がCMSG_FIRSTHDR（MHDR）に相当します。何の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。"
    },
    {
      "indent": 0,
      "text": "5.2. CMSG_SPACE",
      "section_title": true,
      "ja": "5.2。 CMSG_SPACE"
    },
    {
      "indent": 3,
      "text": "socklen_t CMSG_SPACE(socklen_t length);",
      "ja": "socklen_t CMSG_SPACE（のsocklen_t長さ）"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_SPACE() returns an upper bound on the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements. This macro can be used, for example, when allocating space dynamically for the ancillary data. This macro should not be used to initialize the cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN() macro.",
      "ja": "このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_SPACE（）は、アライメント要件を満たすために必要なパディングを含む、オブジェクトとそのcmsghdr構造体に必要なスペースの上限を返します。補助データのための動的空間を割り当てるとき、このマクロは、例えば、使用することができます。このマクロは、cmsghdr構造体のCMSG_LENメンバを初期化するために使用すべきではありません。代わりCMSG_LEN（）マクロを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3. CMSG_LEN",
      "section_title": true,
      "ja": "3.5 CMSG_LEN"
    },
    {
      "indent": 3,
      "text": "socklen_t CMSG_LEN(socklen_t length);",
      "ja": "socklen_t CMSG_LEN（のsocklen_t長さ）"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_LEN() returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.",
      "ja": "このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_LEN（）は考慮アラインメント要件を満たすために必要なパディングを取って、cmsghdr構造体のCMSG_LENメンバに格納する値を返します。"
    },
    {
      "indent": 3,
      "text": "Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also in the figure in Section 20.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg_len member of the ancillary data object.",
      "ja": "補助データオブジェクトの末尾に必要なパディングのために元のアカウントを、後者はCMSG_LENメンバーに格納する実際の長さ：セクション20.2の図にも示さCMSG_SPACE（）とCMSG_LEN（）との差を、注意してください補助的なデータオブジェクト。"
    },
    {
      "indent": 0,
      "text": "6. Packet Information",
      "section_title": true,
      "ja": "6.パケット情報"
    },
    {
      "indent": 3,
      "text": "There are five pieces of information that an application can specify for an outgoing packet using ancillary data:",
      "ja": "アプリケーションは、補助的なデータを使用して発信パケットに指定できる5件の情報があります。"
    },
    {
      "indent": 6,
      "text": "1. the source IPv6 address, 2. the outgoing interface index, 3. the outgoing hop limit, 4. the next hop address, and 5. the outgoing traffic class value.",
      "ja": "1.送信元IPv6アドレス、2発信インタフェースインデックス、3発信ホップリミット、4次ホップアドレス、および5発信トラフィッククラス値。"
    },
    {
      "indent": 3,
      "text": "Four similar pieces of information can be returned for a received packet as ancillary data:",
      "ja": "情報の四つの同様の片が補助データとして受信されたパケットのために戻すことができます。"
    },
    {
      "indent": 6,
      "text": "1. the destination IPv6 address, 2. the arriving interface index, 3. the arriving hop limit, and 4. the arriving traffic class value.",
      "ja": "1.宛先IPv6アドレス、2到着インタフェースインデックス、3到着ホップリミット、および4到着トラフィッククラス値。"
    },
    {
      "indent": 3,
      "text": "The first two pieces of information are contained in an in6_pktinfo structure that is set with setsockopt() or sent as ancillary data with sendmsg() and received as ancillary data with recvmsg(). This structure is defined as a result of including <netinet/in.h>.",
      "ja": "情報の最初の二つの片のsetsockoptで設定（）またはsendmsgのと補助データとして送信（）および（）のrecvmsgと補助データとして受信されるin6_pktinfo構造に含まれています。この構造体は、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "struct in6_pktinfo {\n  struct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n  unsigned int    ipi6_ifindex; /* send/recv interface index */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the socket option and cmsghdr level will be IPPROTO_IPV6, the type will be IPV6_PKTINFO, and the first byte of the option value and cmsg_data[] will be the first byte of the in6_pktinfo structure. An application can clear any sticky IPV6_PKTINFO option by doing a",
      "ja": "ソケットオプションとのcmsghdrレベルにIPPROTO_IPV6になり、タイプがIPV6_PKTINFOなり、オプション値とCMSG_DATAの最初のバイトは[] in6_pktinfo構造の最初のバイトであろう。アプリケーションが実行して任意の粘着性IPV6_PKTINFOオプションをクリアすることができます"
    },
    {
      "indent": 3,
      "text": "\"regular\" setsockopt with ipi6_addr being in6addr_any and ipi6_ifindex being zero.",
      "ja": "ipi6_addrがゼロであることIN6ADDR_ANYとipi6_ifindexていると、「定期的に」のsetsockopt。"
    },
    {
      "indent": 3,
      "text": "This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVPKTINFO socket option:",
      "ja": "この情報は、アプリケーションがIPV6_RECVPKTINFOソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Note: The hop limit is not contained in the in6_pktinfo structure for the following reason. Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this the application can enable just the IPV6_RECVPKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg(). The application need not examine or modify the in6_pktinfo structure at all. But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)",
      "ja": "（注：ホップ限界は次の理由in6_pktinfo構造に含まれていないいくつかのUDPサーバは要求を受信したのと同じインターフェイスから、応答の送信元IPv6アドレスとその回答を送信することによって、クライアントの要求に応答します。リクエストの宛先IPv6アドレスに等しい。このアプリケーションだけIPV6_RECVPKTINFOソケットオプションを有効にしてからは、sendmsg（の発信制御情報としてのrecvmsg（）から受信した制御情報を使用することができます行うには）。アプリケーションは、検査または変更する必要はありませんホップ限界がこの構造に含まれた場合in6_pktinfo構造は全く。しかし、アプリケーションは、受信したホップ限界は、発信パケットのための所望の値ではないので、受信した制御情報を解析し、ホップリミット部材を変更しなければなりません。）"
    },
    {
      "indent": 0,
      "text": "6.1. Specifying/Receiving the Interface",
      "section_title": true,
      "ja": "6.1。インターフェイスの受信/指定"
    },
    {
      "indent": 3,
      "text": "Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC-3493]. That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes. Notice from this document that no interface is ever assigned an index of 0.",
      "ja": "[RFC-3493]のセクション4で説明したようにIPv6ノード上のインタフェースは、小さな正の整数によって識別されます。その文書はまた、インタフェースインデックス、そのインタフェース名にインタフェースインデックスをマッピングする機能、およびすべてのインターフェイス名とインデックスを返す関数へのインターフェイス名をマッピングするための機能について説明します。何のインターフェースがこれまで0のインデックスが割り当てられていない、この文書から注意してください。"
    },
    {
      "indent": 3,
      "text": "When specifying the outgoing interface, if the ipi6_ifindex value is 0, the kernel will choose the outgoing interface.",
      "ja": "発信インターフェイスを指定する場合ipi6_ifindex値が0であれば、カーネルが発信インターフェイスを選択します。"
    },
    {
      "indent": 3,
      "text": "The ordering among various options that can specify the outgoing interface, including IPV6_PKTINFO, is defined in Section 6.7.",
      "ja": "IPV6_PKTINFO含む発信インターフェイスを、指定することができ、様々な選択肢の中の順序は、セクション6.7で定義されています。"
    },
    {
      "indent": 3,
      "text": "When the IPV6_RECVPKTINFO socket option is enabled, the received interface index is always returned as the ipi6_ifindex member of the in6_pktinfo structure.",
      "ja": "IPV6_RECVPKTINFOソケットオプションが有効になっている場合、受信インタフェースインデックスは常にin6_pktinfo構造のipi6_ifindexメンバーとして返されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Specifying/Receiving Source/Destination Address",
      "section_title": true,
      "ja": "6.2。指定受信/送信元/宛先アドレス"
    },
    {
      "indent": 3,
      "text": "The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.",
      "ja": "送信元IPv6アドレスが各出力動作の前にバインド（）を呼び出すが、データと共にソースアドレスを供給することによって特定することができるが少ないオーバーヘッド（すなわち、より少ないシステムコール）を必要とし、記憶し、マルチスレッドのアプリケーションで保護されるべきより少ない状態を必要とします。"
    },
    {
      "indent": 3,
      "text": "When specifying the source IPv6 address as ancillary data, if the ipi6_addr member of the in6_pktinfo structure is the unspecified address (IN6ADDR_ANY_INIT or in6addr_any), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address. If the ipi6_addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6_addr value overrides the already-bound source address for this output operation only.",
      "ja": "補助データとして送信元IPv6アドレスを指定する場合in6_pktinfo構造のipi6_addr部材は未指定アドレス（IN6ADDR_ANY_INIT又はIN6ADDR_ANY）であれば、アドレスが現在ソケットにバインドされている場合、次いで（A）には、送信元アドレスとして使用され何のアドレスが現在のソケットにバインドされていない場合、又は（b）、カーネルは、送信元アドレスを選択します。 ipi6_addrメンバーが未指定のアドレスではなく、ソケットがすでに元アドレスをバインドしている場合は、ipi6_addr値にのみ、この出力動作のためにすでに結合元アドレスを上書きします。"
    },
    {
      "indent": 3,
      "text": "The kernel must verify that the requested source address is indeed a unicast address assigned to the node. When the address is a scoped one, there may be ambiguity about its scope zone. This is particularly the case for link-local addresses. In such a case, the kernel must first determine the appropriate scope zone based on the zone of the destination address or the outgoing interface (if known), then qualify the address. This also means that it is not feasible to specify the source address for a non-binding socket by the IPV6_PKTINFO sticky option, unless the outgoing interface is also specified. The application should simply use bind() for such purposes.",
      "ja": "カーネルは、要求された送信元アドレスが実際にノードに割り当てられたユニキャストアドレスであることを確認する必要があります。アドレスは、スコープ1である場合には、その範囲ゾーンに関するあいまいさがあるかもしれません。これは特に、リンクローカルアドレスの場合です。このような場合には、カーネルは、まず、宛先アドレスのゾーンまたは発信インターフェイス（既知の場合）に基づいて、適切なスコープゾーンを決定するアドレスを修飾しなければなりません。また、発信インターフェイスも指定されていない限り、IPV6_PKTINFO stickyオプションにより非結合ソケットの送信元アドレスを指定することは不可能であることを意味します。アプリケーションは、単にそのような目的のためにバインド（）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPV6_PKTINFO can also be used as a sticky option for specifying the socket's default source address. However, the ipi6_addr member must be the unspecified address for TCP sockets, because it is not possible to dynamically change the source address of a TCP connection. When the IPV6_PKTINFO option is specified for a TCP socket with a non-unspecified address, the call will fail. This restriction should be applied even before the socket binds a specific address.",
      "ja": "IPV6_PKTINFOもソケットのデフォルトの送信元アドレスを指定するためのstickyオプションとして使用することができます。動的にTCP接続の送信元アドレスを変更することはできませんので、しかし、ipi6_addrメンバーは、TCPソケットのために指定されていないアドレスでなければなりません。 IPV6_PKTINFOオプションは非未指定アドレスとTCPソケット用に指定されている場合、コールは失敗します。ソケットは、特定のアドレスをバインドする前であっても、この制限が適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "When the in6_pktinfo structure is returned as ancillary data by recvmsg(), the ipi6_addr member contains the destination IPv6 address from the received packet.",
      "ja": "in6_pktinfo構造が）のrecvmsg（によって補助データとして返されるとき、ipi6_addr部材は、受信したパケットから宛先IPv6アドレスを含んでいます。"
    },
    {
      "indent": 0,
      "text": "6.3. Specifying/Receiving the Hop Limit",
      "section_title": true,
      "ja": "6.3。ホップ制限を受ける/指定"
    },
    {
      "indent": 3,
      "text": "The outgoing hop limit is normally specified with either the IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS socket option, both of which are described in [RFC-3493]. Specifying the",
      "ja": "[RFC-3493]に記載されている両方とも発信ホップ制限は、通常、IPV6_UNICAST_HOPSソケットオプションまたはIPV6_MULTICAST_HOPSソケットオプションのいずれかで指定されています。指定"
    },
    {
      "indent": 3,
      "text": "hop limit as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).",
      "ja": "補助データとしてホップ制限は、アプリケーションが単一の出力動作のために、ユニキャスト宛先またはマルチキャストの宛先のいずれかのために、カーネルのデフォルトまたは以前に指定された値のいずれかをオーバーライドすることができます。受信ホップ限界を返すと、受信ホップ限界は255（例えば、パケットが転送されていないこと）であることを確認する必要があるIPv6アプリケーションに有用です。"
    },
    {
      "indent": 3,
      "text": "The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVHOPLIMIT socket option:",
      "ja": "受信ホップ限界は、アプリケーションがIPV6_RECVHOPLIMITソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first byte of the integer hop limit.",
      "ja": "この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_HOPLIMITなり、CMSG_DATAの最初のバイト[]は整数ホップ限界の最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg(). As specified in [RFC-3493], the interpretation of the integer hop limit value is",
      "ja": "何も特別な必要性が出ホップ制限を指定するために行われる。ただsendmsgのための補助的なデータとして制御情報を指定します（）。 [RFC-3493]で指定されるように、整数ホップ限界値の解釈であります"
    },
    {
      "indent": 6,
      "text": "x < -1: return an error of EINVAL x == -1: use kernel default 0 <= x <= 255: use x x >= 256: return an error of EINVAL",
      "ja": "X <-1：使用のカーネルのデフォルト0 <= xの<= 255：使用X X> = 256：EINVALのx == -1のエラーを返すEINVALのエラーを返します"
    },
    {
      "indent": 3,
      "text": "This API defines IPV6_HOPLIMIT as an ancillary-only option, that is, the option name cannot be used as a socket option. This is because [RFC-3493] has more fine-grained socket options; IPV6_UNICAST_HOPS and IPV6_MULTICAST_HOPS.",
      "ja": "このAPIは、は、オプション名は、ソケットオプションとして使用することはできませんされ、補助的な専用オプションとしてIPV6_HOPLIMITを定義します。 [RFC-3493]は、よりきめ細かなソケットオプションを持っているためです。 IPV6_UNICAST_HOPSとIPV6_MULTICAST_HOPS。"
    },
    {
      "indent": 0,
      "text": "6.4. Specifying the Next Hop Address",
      "section_title": true,
      "ja": "6.4。ネクストホップアドレスを指定します"
    },
    {
      "indent": 3,
      "text": "The IPV6_NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP, and the first byte of cmsg_data[] will be the first byte of the socket address structure.",
      "ja": "IPV6_NEXTHOP補助データオブジェクトは、ソケットアドレス構造体としてデータグラムのための次のホップを指定します。この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_NEXTHOPなり、CMSG_DATAの最初のバイト[]はソケットアドレス構造の最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "This is a privileged option. (Note: It is implementation defined and beyond the scope of this document to define what \"privileged\" means. Unix systems use this term to mean the process must have an effective user ID of 0.)",
      "ja": "これは特権オプションです。 （注：どのような「特権」の手段を定義するために、実装定義されており、このドキュメントの範囲を超えているUnixシステムは、プロセスを意味するためにこの用語を使用し、0の実効ユーザーIDを持っている必要があります。）"
    },
    {
      "indent": 3,
      "text": "This API only defines the case where the socket address contains an IPv6 address (i.e., the sa_family member is AF_INET6). And, in this case, the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO_DONTROUTE socket option.",
      "ja": "このAPIは、ソケットアドレスは、IPv6アドレスを含む場合（即ち、sa_familyに部材がAF_INET6である）を定義します。そして、この場合には、そのアドレスによって識別されるノードは、送信ホストの近隣でなければなりません。そのアドレスがデータグラムの宛先IPv6アドレスに等しい場合、これは、既存のSO_DONTROUTEソケットオプションに相当します。"
    },
    {
      "indent": 3,
      "text": "This option does not have any meaning for multicast destinations. In such a case, the specified next hop will be ignored.",
      "ja": "このオプションは、マルチキャストの宛先のいずれかの意味を持っていません。そのような場合には、指定されたネクストホップは無視されます。"
    },
    {
      "indent": 3,
      "text": "When the outgoing interface is specified by IPV6_PKTINFO as well, the next hop specified by this option must be reachable via the specified interface.",
      "ja": "発信インターフェイスも同様にIPV6_PKTINFOによって指定されている場合、このオプションで指定されたネクストホップは、指定されたインターフェイス経由で到達可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to clear a sticky IPV6_NEXTHOP option the application must issue a setsockopt for IPV6_NEXTHOP with a zero length.",
      "ja": "スティッキーIPV6_NEXTHOPオプションをクリアするために、アプリケーションは、長さがゼロとIPV6_NEXTHOPのためのsetsockoptを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. Specifying/Receiving the Traffic Class value",
      "section_title": true,
      "ja": "6.5。指定/トラフィッククラス値を受け取ります"
    },
    {
      "indent": 3,
      "text": "The outgoing traffic class is normally set to 0. Specifying the traffic class as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received traffic class is useful for programs such as a diffserv debugging tool and for user level ECN (explicit congestion notification) implementation.",
      "ja": "発信トラフィッククラスは、通常、補助データは、ユニキャスト宛先またはマルチキャストの宛先のいずれかのために、アプリケーションのオーバーライドのいずれかのカーネルのデフォルトまたは以前に指定した値をすることができますように、単一出力操作のために、トラフィッククラスを指定する0に設定されています。受信されたトラフィッククラスを返送することは、DiffServのデバッグツールとして、ユーザレベルECN（明示的輻輳通知）の実装のためにプログラムするのに有用です。"
    },
    {
      "indent": 3,
      "text": "The received traffic class is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_RECVTCLASS socket option:",
      "ja": "受信トラフィッククラスは、アプリケーションがIPV6_RECVTCLASSソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_TCLASS, and the first byte of cmsg_data[] will be the first byte of the integer traffic class.",
      "ja": "この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_TCLASSなり、CMSG_DATAの最初のバイト[]は整数トラフィッククラスの最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "To specify the outgoing traffic class value, just specify the control information as ancillary data for sendmsg() or using setsockopt(). Just like the hop limit value, the interpretation of the integer traffic class value is",
      "ja": "発信トラフィッククラス値を指定するだけで補助sendmsgのためのデータ（）またはのsetsockoptを使用するなどの制御情報を指定（）。ただ、ホップ限界値のように、整数トラフィッククラス値の解釈はあります"
    },
    {
      "indent": 6,
      "text": "x < -1: return an error of EINVAL x == -1: use kernel default 0 <= x <= 255: use x x >= 256: return an error of EINVAL",
      "ja": "X <-1：使用のカーネルのデフォルト0 <= xの<= 255：使用X X> = 256：EINVALのx == -1のエラーを返すEINVALのエラーを返します"
    },
    {
      "indent": 3,
      "text": "In order to clear a sticky IPV6_TCLASS option the application can specify -1 as the value.",
      "ja": "スティッキーIPV6_TCLASSオプションをクリアするためにはアプリケーションが指定することができます-1値として。"
    },
    {
      "indent": 3,
      "text": "There are cases where the kernel needs to control the traffic class value and conflicts with the user-specified value on the outgoing traffic. An example is an implementation of ECN in the kernel, setting 2 bits of the traffic class value. In such cases, the kernel should override the user-specified value. On the incoming traffic, the kernel may mask some of the bits in the traffic class field.",
      "ja": "カーネルが発信トラフィックにユーザーが指定した値を持つトラフィッククラス値と競合を制御する必要がある場合があります。例では、トラフィッククラス値の2ビットを設定する、カーネル内のECNの実装です。このような場合には、カーネルは、ユーザーが指定した値をオーバーライドする必要があります。着信トラフィックに、カーネルは、トラフィッククラスフィールド内のビットの一部をマスクすることができます。"
    },
    {
      "indent": 0,
      "text": "6.6. Additional Errors with sendmsg() and setsockopt()",
      "section_title": true,
      "ja": "6.6。 sendmsg（）とのsetsockoptで追加のエラー（）"
    },
    {
      "indent": 3,
      "text": "With the IPV6_PKTINFO socket option there are no additional errors possible with the call to recvmsg(). But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg() or setsockopt(). Note that some implementations might only be able to return this type of errors for setsockopt(). The following are examples, but some of these may not be provided by some implementations, and some implementations may define additional errors:",
      "ja": "IPV6_PKTINFOソケットオプションで追加のエラーがrecvmsgの呼び出しで可能はありません（）。発信インターフェイスまたは送信元アドレスを指定する場合には、追加のエラーが（）にsendmsg（）またはのsetsockoptから可能です。いくつかの実装が唯一のsetsockoptのため、エラーのこのタイプを返すことができるかもしれないことに注意してください（）。以下は一例であり、これらのいくつかは、いくつかの実装によって提供されない場合があり、そしていくつかの実装形態は、追加のエラーを定義してもよいです。"
    },
    {
      "indent": 3,
      "text": "ENXIO The interface specified by ipi6_ifindex does not exist.",
      "ja": "ENXIO ipi6_ifindexで指定されたインターフェイスは存在しません。"
    },
    {
      "indent": 3,
      "text": "ENETDOWN The interface specified by ipi6_ifindex is not enabled for IPv6 use.",
      "ja": "ENETDOWN ipi6_ifindexで指定されたインターフェイスは、IPv6の使用が有効になっていません。"
    },
    {
      "indent": 3,
      "text": "EADDRNOTAVAIL ipi6_ifindex specifies an interface but the address ipi6_addr is not available for use on that interface.",
      "ja": "EADDRNOTAVAIL ipi6_ifindexインターフェイスを指定するが、アドレスipi6_addrは、そのインターフェイス上で使用することはできません。"
    },
    {
      "indent": 3,
      "text": "EHOSTUNREACH No route to the destination exists over the interface specified by ipi6_ifindex.",
      "ja": "EHOSTUNREACH宛先へのルートがipi6_ifindexによって指定されたインターフェイス上存在しません。"
    },
    {
      "indent": 0,
      "text": "6.7. Summary of Outgoing Interface Selection",
      "section_title": true,
      "ja": "6.7。発信インターフェイスの選択の概要"
    },
    {
      "indent": 3,
      "text": "This document and [RFC-3493] specify various methods that affect the selection of the packet's outgoing interface. This subsection summarizes the ordering among those in order to ensure deterministic behavior.",
      "ja": "このドキュメントと[RFC-3493]は、パケットの発信インターフェイスの選択に影響を与える様々な方法を指定します。ここでは、確定的な動作を確保するために、それらの間の順序をまとめたもの。"
    },
    {
      "indent": 3,
      "text": "For a given outgoing packet on a given socket, the outgoing interface is determined in the following order:",
      "ja": "与えられたソケット上の所与の発信パケットについて、発信インターフェイスは、次の順序で決定されます。"
    },
    {
      "indent": 3,
      "text": "1. if an interface is specified in an IPV6_PKTINFO ancillary data item, the interface is used.",
      "ja": "インタフェースはIPV6_PKTINFO補助的なデータ項目で指定されている場合1、インタフェースが使用されます。"
    },
    {
      "indent": 3,
      "text": "2. otherwise, if an interface is specified in an IPV6_PKTINFO sticky option, the interface is used.",
      "ja": "インタフェースはIPV6_PKTINFOスティッキーオプションで指定されている場合2.そうでなければ、インタフェースが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. otherwise, if the destination address is a multicast address and the IPV6_MULTICAST_IF socket option is specified for the socket, the interface is used.",
      "ja": "宛先アドレスがマルチキャストアドレスであるとIPV6_MULTICAST_IFソケットオプションをソケットに指定されている場合3.そうでなければ、インタフェースが使用されます。"
    },
    {
      "indent": 3,
      "text": "4. otherwise, if an IPV6_NEXTHOP ancillary data item is specified, the interface to the next hop is used.",
      "ja": "IPV6_NEXTHOP補助データ項目が指定されている場合4.そうでなければ、次のホップへのインタフェースが使用されます。"
    },
    {
      "indent": 3,
      "text": "5. otherwise, if an IPV6_NEXTHOP sticky option is specified, the interface to the next hop is used.",
      "ja": "IPV6_NEXTHOPスティッキーオプションが指定されている場合5.そうでなければ、次のホップへのインタフェースが使用されます。"
    },
    {
      "indent": 3,
      "text": "6. otherwise, the outgoing interface should be determined in an implementation dependent manner.",
      "ja": "6.そうでなければ、発信インタフェースは実装依存の方法で決定されるべきです。"
    },
    {
      "indent": 3,
      "text": "The ordering above particularly means if the application specifies an interface by the IPV6_MULTICAST_IF socket option (described in [RFC-3493]) as well as specifying a different interface by the IPV6_PKTINFO sticky option, the latter will override the former for every multicast packet on the corresponding socket. The reason for the ordering comes from expectation that the source address is specified as well and that the pair of the address and the outgoing interface should be preferred.",
      "ja": "アプリケーションがIPV6_MULTICAST_IFソケットオプションによってインタフェースを指定している場合、特に上記の順序が（[RFC-3493]に記載されている）、ならびにIPV6_PKTINFO stickyオプションによって異なるインタフェースを指定する手段と、後者は、上のすべてのマルチキャストパケットに対して前者を上書きします対応するソケット。発注した理由は、送信元アドレスが同様に指定されている期待からとアドレスと発信インターフェイスのペアが優先されるべきであるとしています。"
    },
    {
      "indent": 3,
      "text": "In any case, the kernel must also verify that the source and destination addresses do not break their scope zones with regard to the outgoing interface.",
      "ja": "いずれの場合も、カーネルはまた、送信元と送信先のアドレスは発信インターフェイスに関連して、その範囲ゾーンを壊さないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Routing Header Option",
      "section_title": true,
      "ja": "7.ルーティングヘッダオプション"
    },
    {
      "indent": 3,
      "text": "Source routing in IPv6 is accomplished by specifying a Routing header as an extension header. There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC-2460]. This type supports up to 127 intermediate nodes (limited by the length field in the extension header). With this maximum number of intermediate nodes, a source, and a destination, there are 128 hops.",
      "ja": "IPv6におけるソースルーティングは、拡張ヘッダなどのルーティングヘッダを指定することによって達成されます。そこにルーティングヘッダの異なるタイプであるが、IPv6は現在、タイプ0ルーティングヘッダ[RFC-2460]を定義することができます。このタイプは、（拡張ヘッダの長さフィールドによって制限される）127の中間ノードをサポートします。中間ノードのこの最大数、送信元、宛先と、128回のホップがあります。"
    },
    {
      "indent": 3,
      "text": "Source routing with the IPv4 sockets API (the IP_OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format. This IPv6 API, however, defines six functions that the application calls to build and examine a Routing header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel using the IPV6_RTHDR option.",
      "ja": "IPv4では、ソースルーティングは、API（IP_OPTIONSソケットオプション）IPv4オプションフォーマットの詳細な知識を必要とし、IPv4ヘッダーオプションとして表示される形式でソースルートを構築するためのアプリケーションを必要とするソケット。このIPv6のAPIは、しかし、6つのアプリケーションを構築し、ルーティングヘッダを調べるために呼び出す機能、およびアプリケーションとIPV6_RTHDRオプションを使用してカーネルの間でこの情報を通信するためにスティッキーオプションまたは補助データを使用する能力を定義します。"
    },
    {
      "indent": 3,
      "text": "Three functions build a Routing header:",
      "ja": "3つの関数がルーティングヘッダを構築します："
    },
    {
      "indent": 6,
      "text": "inet6_rth_space() - return #bytes required for Routing header inet6_rth_init() - initialize buffer data for Routing header inet6_rth_add() - add one IPv6 address to the Routing header",
      "ja": "inet6_rth_space（） - ヘッダinet6_rth_initをルーティングするために必要な戻り#bytes（） - ）（ヘッダinet6_rth_addをルーティングするためのバッファ・データを初期化する - ルーティングヘッダに1つのIPv6アドレスを追加"
    },
    {
      "indent": 3,
      "text": "Three functions deal with a returned Routing header:",
      "ja": "3つの関数が返されたルーティングヘッダを扱います："
    },
    {
      "indent": 6,
      "text": "inet6_rth_reverse() - reverse a Routing header inet6_rth_segments() - return #segments in a Routing header inet6_rth_getaddr() - fetch one address from a Routing header",
      "ja": "inet6_rth_reverse（） - ルーティングヘッダinet6_rth_getaddrに戻り#segments（） -   - ルーティングヘッダinet6_rth_segments（）を逆ルーティングヘッダからのアドレスをフェッチ"
    },
    {
      "indent": 3,
      "text": "The function prototypes for these functions are defined as a result of including <netinet/in.h>.",
      "ja": "これらの関数の関数プロトタイプは、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "To receive a Routing header the application must enable the IPV6_RECVRTHDR socket option:",
      "ja": "ルーティングヘッダを受信するにはアプリケーションがIPV6_RECVRTHDRソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each received Routing header is returned as one ancillary data object described by a cmsghdr structure with cmsg_type set to IPV6_RTHDR. When multiple Routing headers are received, multiple ancillary data objects (with cmsg_type set to IPV6_RTHDR) will be returned to the application.",
      "ja": "各受信したルーティングヘッダはIPV6_RTHDRに設定cmsg_typeとcmsghdr構造体によって説明したもの補助データオブジェクトとして返されます。複数のルーティング・ヘッダを受信したとき、（IPV6_RTHDRに設定cmsg_typeを有する）複数の補助的なデータオブジェクトがアプリケーションに戻されます。"
    },
    {
      "indent": 3,
      "text": "To send a Routing header the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt(). For the sending side, this API assumes the number of occurrences of the Routing header as described in [RFC-2460]. That is, applications can only specify at most one outgoing Routing header.",
      "ja": "（SENDMSG呼び出し、アプリケーションが補助データのいずれかを指定するルーティングヘッダを送信する）、またはのsetsockoptを使用します（）。 [RFC-2460]に記載されているように送信側では、このAPIは、ルーティングヘッダの発生数を想定しています。これは、アプリケーションがだけ多くても1つの発信ルーティングヘッダで指定することができ、あります。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Routing header by calling setsockopt() for IPV6_RTHDR with a zero option length.",
      "ja": "アプリケーションは、ゼロオプション長でIPV6_RTHDRためのsetsockopt（）を呼び出すことにより、任意の粘着性のルーティングヘッダを除去することができます。"
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Routing header is passed between the application and the kernel as follows: The cmsg_level member has a value of IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR. The contents of the cmsg_data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the six functions that we are about to describe.",
      "ja": "次のようにルーティングヘッダは、アプリケーションとカーネルとの間で渡される補助データを使用する場合：cmsg_levelメンバ部材はIPPROTO_IPV6の値を有し、cmsg_type部材がIPV6_RTHDRの値を有します。 CMSG_DATA []メンバーの内容は実装依存であり、アプリケーションによって直接アクセスされるべきではなく、我々が説明しようとしている6つの機能を使用してアクセスされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following constant is defined as a result of including the <netinet/in.h>:",
      "ja": "以下の定数は、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 6,
      "text": "#define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram. The Routing header then contains the addresses of all the intermediate nodes.",
      "ja": "ルーティングヘッダが指定されている場合、送信先の接続のための指定されたアドレス（）のsendto（）、またはsendmsgの（）は、データグラムの最終的な宛先アドレスです。ルーティングヘッダは、すべての中間ノードのアドレスを含みます。"
    },
    {
      "indent": 0,
      "text": "7.1. inet6_rth_space",
      "section_title": true,
      "ja": "7.1。 inet6_rth_space"
    },
    {
      "indent": 6,
      "text": "socklen_t inet6_rth_space(int type, int segments);",
      "ja": "socklen_t inet6_rth_space（int型、INTセグメント）。"
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses). For an IPv6 Type 0 Routing header, the number of segments must be between 0 and 127, inclusive. The return value is just the space for the Routing header. When the application uses ancillary data it must pass the returned length to CMSG_SPACE() to determine how much memory is needed for the ancillary data object (including the cmsghdr structure).",
      "ja": "この関数は、セグメント（アドレス）の指定された数を含む指定されたタイプのルーティングヘッダを保持するために必要なバイト数を返します。 IPv6のタイプ0ルーティングヘッダは、セグメントの数は、0から127までの範囲でなければなりません。戻り値は、ルーティングヘッダのためだけのスペースです。アプリケーションは、補助データを使用する場合には（cmsghdr構造体を含む）補助データオブジェクトのために必要とされるどのくらいのメモリを決定する（）CMSG_SPACEに戻し長さを通過しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.",
      "ja": "戻り値が0である場合には、ルーティングヘッダのタイプは、この実装でサポートされていないか、またはセグメントの数は、ヘッダルーティングこのタイプの無効のいずれか。"
    },
    {
      "indent": 3,
      "text": "(Note: This function returns the size but does not allocate the space required for the ancillary data. This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg_control buffer.)",
      "ja": "（注：この関数はサイズを返すが、補助データに必要なスペースを割り当てない他の補助的なデータオブジェクトが所望される場合、すべての補助データオブジェクトがSENDMSGするために指定されなければならないので、これは、アプリケーションが大きなバッファを割り当てることができます（。 ）単一msg_controlバッファとして）。"
    },
    {
      "indent": 0,
      "text": "7.2. inet6_rth_init",
      "section_title": true,
      "ja": "7.2。 inet6_rth_init"
    },
    {
      "indent": 6,
      "text": "void *inet6_rth_init(void *bp, socklen_t bp_len, int type,\n                     int segments);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function initializes the buffer pointed to by bp to contain a Routing header of the specified type and sets ip6r_len based on the segments parameter. bp_len is only used to verify that the buffer is large enough. The ip6r_segleft field is set to zero; inet6_rth_add() will increment it.",
      "ja": "この関数は、バッファが指定されたタイプのルーティングヘッダを含むようにBPによって指さ初期化セットは、セグメントパラメータに基づいてip6r_len。 bp_lenは唯一のバッファが十分な大きさであることを確認するために使用されます。 ip6r_segleftフィールドはゼロに設定されています。 inet6_rth_add（）はそれを増加させます。"
    },
    {
      "indent": 3,
      "text": "When the application uses ancillary data the application must initialize any cmsghdr fields.",
      "ja": "アプリケーションは、補助的なデータを使用すると、アプリケーションは、任意ののcmsghdrフィールドを初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "The caller must allocate the buffer and its size can be determined by calling inet6_rth_space().",
      "ja": "呼び出し側は、バッファを割り当てる必要があり、そのサイズはinet6_rth_space（）を呼び出すことによって決定することができます。"
    },
    {
      "indent": 3,
      "text": "Upon success the return value is the pointer to the buffer (bp), and this is then used as the first argument to the inet6_rth_add() function. Upon an error the return value is NULL.",
      "ja": "成功した場合、戻り値は、バッファ（BP）へのポインタであり、これは、次いでinet6_rth_add（）関数の最初の引数として使用されます。エラー時には、戻り値はNULLです。"
    },
    {
      "indent": 0,
      "text": "7.3. inet6_rth_add",
      "section_title": true,
      "ja": "7.3。 inet6_rth_add"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_add(void *bp, const struct in6_addr *addr);",
      "ja": "int型inet6_rth_add（ボイド* bpを、constの構造体のin6_addr * addrに）;"
    },
    {
      "indent": 3,
      "text": "This function adds the IPv6 address pointed to by addr to the end of the Routing header being constructed.",
      "ja": "この機能は、IPv6アドレスが構成されているルーティングヘッダの終わりにADDRによって指さ加算します。"
    },
    {
      "indent": 3,
      "text": "If successful, the segleft member of the Routing Header is updated to account for the new address in the Routing header and the return value of the function is 0. Upon an error the return value of the function is -1.",
      "ja": "成功した場合、ルーティングヘッダのsegleft部材がルーティングヘッダに新しいアドレスを考慮するために更新され、関数の戻り値はエラー時に0である関数の戻り値は-1。"
    },
    {
      "indent": 0,
      "text": "7.4. inet6_rth_reverse",
      "section_title": true,
      "ja": "7.4。 inet6_rth_reverse"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_reverse(const void *in, void *out);",
      "ja": "int型inet6_rth_reverse（のconst void *型で、無効*アウト）。"
    },
    {
      "indent": 3,
      "text": "This function takes a Routing header extension header (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route. The function reverses the order of the addresses and sets the segleft member in the new Routing header to the number of segments. Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).",
      "ja": "この関数は、（最初​​の引数によって指される）ルーティングヘッダ拡張ヘッダを取得し、そのルートの逆に沿ってデータグラムを送信する新しいルーティングヘッダを書き込みます。関数は、アドレスの順序を逆にし、セグメントの数に新しいルーティングヘッダでsegleft部材を設定します。両方の引数は、同じ緩衝液（すなわち、反転が場所で起こり得る）を指すように許可されています。"
    },
    {
      "indent": 3,
      "text": "The return value of the function is 0 on success, or -1 upon an error.",
      "ja": "関数の戻り値は成功時に0、あるいはエラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "7.5. inet6_rth_segments",
      "section_title": true,
      "ja": "7.5。 inet6_rth_segments"
    },
    {
      "indent": 6,
      "text": "int inet6_rth_segments(const void *bp);",
      "ja": "int型inet6_rth_segments（のconst void *型塩基対）。"
    },
    {
      "indent": 3,
      "text": "This function returns the number of segments (addresses) contained in the Routing header described by bp. On success the return value is zero or greater. The return value of the function is -1 upon an error.",
      "ja": "この関数は、BPによって記述ルーティングヘッダに含まれるセグメント（アドレス）の数を返します。成功した場合、戻り値はゼロ以上です。関数の戻り値は、エラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "7.6. inet6_rth_getaddr",
      "section_title": true,
      "ja": "7.6。 inet6_rth_getaddr"
    },
    {
      "indent": 6,
      "text": "struct in6_addr *inet6_rth_getaddr(const void *bp, int index);",
      "ja": "構造体のin6_addr * inet6_rth_getaddr（定数ボイド* bpの、int型のインデックス）;"
    },
    {
      "indent": 3,
      "text": "This function returns a pointer to the IPv6 address specified by index (which must have a value between 0 and one less than the value returned by inet6_rth_segments()) in the Routing header described by bp. An application should first call inet6_rth_segments() to obtain the number of segments in the Routing header.",
      "ja": "この関数は、BPによって記述ルーティングヘッダに（0とinet6_rth_segments（によって返される値未満のもの）の間の値を有していなければならない）インデックスで指定されたIPv6アドレスへのポインタを返します。アプリケーションは、最初のルーティングヘッダ内のセグメントの数を得るために）（inet6_rth_segmentsを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon an error the return value of the function is NULL.",
      "ja": "エラー時には、関数の戻り値はNULLです。"
    },
    {
      "indent": 0,
      "text": "8. Hop-By-Hop Options",
      "section_title": true,
      "ja": "8.ホップバイホップオプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Hop-by-Hop options can appear in a single Hop-by-Hop options header. Each option in the header is TLV-encoded with a type, length, and value. This IPv6 API defines seven functions that the application calls to build and examine a Hop-by_Hop options header, and the ability to use sticky options or ancillary data to communicate this information between the application and the kernel. This uses the IPV6_HOPOPTS for a Hop-by-Hop options header.",
      "ja": "ホップバイホップオプションの可変数は、単一のホップバイホップオプションヘッダに現れることができます。ヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。このIPv6のAPIには、7つのアプリケーションを構築し、ホップby_Hopオプションヘッダを調べるために呼び出す機能、およびアプリケーションとカーネルの間でこの情報を通信するためにスティッキーオプションまたは補助データを使用する能力を定義します。これは、ホップバイホップオプションヘッダのIPV6_HOPOPTSを使用します。"
    },
    {
      "indent": 3,
      "text": "Today several Hop-by-Hop options are defined for IPv6. Two pad options, Pad1 and PadN, are for alignment purposes and are automatically inserted by the inet6_opt_XXX() routines and ignored by the inet6_opt_XXX() routines on the receive side. This section of the API is therefore defined for other (and future) Hop-by-Hop options that an application may need to specify and receive.",
      "ja": "今日、いくつかのホップバイホップオプションは、IPv6のために定義されています。二つパッドオプション、パッド1およびパッドNは、位置合わせの目的のためであり、自動的にinet6_opt_XXX（）ルーチンによって挿入され、受信側inet6_opt_XXX（）ルーチンによって無視されます。 APIのこのセクションでは、したがって、アプリケーションが指定して受信する必要があるかもしれない他の（および将来の）ホップバイホップオプションに定義されています。"
    },
    {
      "indent": 3,
      "text": "Four functions build an options header:",
      "ja": "4つの機能は、オプションのヘッダを構築します："
    },
    {
      "indent": 6,
      "text": "inet6_opt_init() - initialize buffer data for options header inet6_opt_append() - add one TLV option to the options header inet6_opt_finish() - finish adding TLV options to the options header inet6_opt_set_val() - add one component of the option content to the option",
      "ja": "inet6_opt_init（） - オプションの初期化バッファデータ（inet6_opt_appendヘッダ） - オプション1つのTLVオプションを追加（inet6_opt_finishヘッダ） - 仕上げオプションにTLVオプションを追加する（inet6_opt_set_valヘッダ） - オプションにオプションのコンテンツの一つの構成要素を追加"
    },
    {
      "indent": 6,
      "text": "Three functions deal with a returned options header:",
      "ja": "3つの関数が返されたオプションヘッダを扱います："
    },
    {
      "indent": 6,
      "text": "inet6_opt_next() - extract the next option from the options header inet6_opt_find() - extract an option of a specified type from the header inet6_opt_get_val() - retrieve one component of the option content",
      "ja": "inet6_opt_next（） - ）（inet6_opt_findヘッダオプションから次のオプションを抽出 - ）（ヘッダinet6_opt_get_valから指定されたタイプのオプションを抽出する - オプションのコンテンツの一つの成分を取り出します"
    },
    {
      "indent": 3,
      "text": "Individual Hop-by-Hop options (and Destination options, which are described in Section 9 and are very similar to the Hop-by-Hop options) may have specific alignment requirements. For example, the 4-byte Jumbo Payload length should appear on a 4-byte boundary, and IPv6 addresses are normally aligned on an 8-byte boundary. These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix B of [RFC-2460]. The alignment of first byte of each option is specified by two values, called x and y, written as \"xn + y\". This states that the option must appear at an integer multiple of x bytes from the beginning of the options header (x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive). The Pad1 and PadN options are inserted as needed to maintain the required alignment. The functions below need to know the alignment of the end of the option (which is always in the form \"xn,\" where x can have the values 1, 2, 4, or 8) and the total size of the data portion of the option. These are passed as the \"align\" and \"len\" arguments to inet6_opt_append().",
      "ja": "（セクション9に記載され、ホップバイホップオプションに非常に類似しているれ、宛先オプション）個々のホップバイホップオプションは、特定の位置合わせ要件を有することができます。例えば、4バイトのジャンボペイロード長は、4バイト境界上に表示され、そしてIPv6アドレスは、通常、8バイト境界で整列されています。これらの要件は、これらのオプションで使用される用語は、[RFC-2460]のセクション4.2および付録Bに記載されています。各オプションの最初のバイトの位置合わせを「XN + Y」と書かれたxとyと呼ばれる2つの値によって指定されます。このオプションは、オプションヘッダの先頭からxバイトの整数倍で現れなければならないと述べて、プラスYバイト（xは値1、2、4、または8を有することができる）（yは0と7の間の値を持つことができ、包括的）。必要な整列を維持するために必要に応じてパッド1およびパッドNオプションが挿入されています。とのデータ部分の合計サイズ（xは値1、2、4、または8を有することができる形で常に「XN」）オプションの端部の位置合わせを知る必要が以下の機能オプション。これらはinet6_opt_appendする「合わせ」と「LEN」、引数として渡されます（）。"
    },
    {
      "indent": 3,
      "text": "Multiple Hop-by-Hop options must be specified by the application by placing them in a single extension header.",
      "ja": "複数のホップバイホップオプションは、単一の拡張ヘッダにそれらを置くことによって、アプリケーションで指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Finally, we note that use of some Hop-by-Hop options or some Destination options, might require special privilege. That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.",
      "ja": "最後に、我々はいくつかのホップバイホップオプションまたはいくつかの宛先オプションの使用は、特別な権限を必要とするかもしれないことに注意してください。それは、（特別な権限なし）通常のアプリケーションでは、発信パケットで特定のオプションを設定することが禁止される可能性がありますされ、受信したパケットで特定のオプションを見ることはないかもしれません。"
    },
    {
      "indent": 0,
      "text": "8.1. Receiving Hop-by-Hop Options",
      "section_title": true,
      "ja": "8.1。ホップバイホップオプションを受け取ります"
    },
    {
      "indent": 3,
      "text": "To receive a Hop-by-Hop options header the application must enable the IPV6_RECVHOPOPTS socket option:",
      "ja": "受信するにはホップバイホップオプションは、アプリケーションがIPV6_RECVHOPOPTSソケットオプションを有効にする必要がありますヘッダー："
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Hop-by-hop options header is passed between the application and the kernel as follows: The cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_val() functions, described in Section 10.",
      "ja": "次のようにホップバイホップオプションヘッダは、アプリケーションとカーネルとの間で渡される補助データを使用する場合：cmsg_levelメンバ部材はIPPROTO_IPV6なり、cmsg_type部材はIPV6_HOPOPTSあろう。これらのオプションは、次いで、セクション10に記載inet6_opt_next（）、inet6_opt_find（）、及びinet6_opt_get_val（）関数を呼び出すことによって処理されます。"
    },
    {
      "indent": 0,
      "text": "8.2. Sending Hop-by-Hop Options",
      "section_title": true,
      "ja": "8.2。ホップバイホップオプションを送信"
    },
    {
      "indent": 3,
      "text": "To send a Hop-by-Hop options header, the application specifies the header either as ancillary data in a call to sendmsg() or using setsockopt().",
      "ja": "ホップバイホップオプションヘッダを送信するために、アプリケーションは、（SENDMSGの呼び出しで補助データとしてヘッダを指定）またはのsetsockoptを使用して（）。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Hop-by-Hop options header by calling setsockopt() for IPV6_HOPOPTS with a zero option length.",
      "ja": "アプリケーションは、ゼロオプション長でIPV6_HOPOPTSためのsetsockopt（）を呼び出すことにより、任意の粘着性のホップバイホップオプションヘッダを除去することができます。"
    },
    {
      "indent": 3,
      "text": "All the Hop-by-Hop options must be specified by a single ancillary data object. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_HOPOPTS. The option is normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.",
      "ja": "すべてのホップバイホップオプションは、単一の補助データオブジェクトで指定する必要があります。 cmsg_levelメンバメンバーはIPPROTO_IPV6に設定され、cmsg_typeメンバーはIPV6_HOPOPTSに設定されています。オプションは、通常のセクション10に記載inet6_opt_init（）、inet6_opt_append（）、inet6_opt_finish（）、及びinet6_opt_set_val（）関数を使用して構築されています。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.",
      "ja": "追加のエラーがsendmsgの（）とのsetsockopt（）指定されたオプションにエラーがある場合の可能性があります。"
    },
    {
      "indent": 0,
      "text": "9. Destination Options",
      "section_title": true,
      "ja": "9.宛先オプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Destination options can appear in one or more Destination options headers. As defined in [RFC-2460], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header that is not followed by a Routing header is processed only by the final destination. As with the Hop-by-Hop options, each option in a Destination options header is TLV-encoded with a type, length, and value.",
      "ja": "宛先オプションの可変数は、一つ以上の宛先オプションヘッダーに表示されます。 [RFC-2460]で定義されるように、宛先オプションは、ルーティングヘッダに続いていない宛先オプションヘッダのみ処理される間ルーティングヘッダは、最初の目的地に加えてルーティングヘッダで指定された任意の後続の宛先によって処理される前に現れるヘッダ最終目的地によります。ホップバイホップオプションと同様に、宛先オプションヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。"
    },
    {
      "indent": 0,
      "text": "9.1. Receiving Destination Options",
      "section_title": true,
      "ja": "9.1。宛先オプションを受け取ります"
    },
    {
      "indent": 3,
      "text": "To receive Destination options header the application must enable the IPV6_RECVDSTOPTS socket option:",
      "ja": "宛先オプションは、アプリケーションがIPV6_RECVDSTOPTSソケットオプションを有効にする必要がありますヘッダー受信するには："
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Destination options header is returned as one ancillary data object described by a cmsghdr structure with cmsg_level set to IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.",
      "ja": "各宛先オプションヘッダはIPV6_DSTOPTSに設定IPPROTO_IPV6に設定cmsg_levelメンバとcmsg_typeとcmsghdr構造体によって説明したもの補助データオブジェクトとして返されます。"
    },
    {
      "indent": 3,
      "text": "These options are then processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_value() functions.",
      "ja": "これらのオプションは、その後inet6_opt_next（）、inet6_opt_find（）、およびinet6_opt_get_value（）関数を呼び出すことによって処理されます。"
    },
    {
      "indent": 0,
      "text": "9.2. Sending Destination Options",
      "section_title": true,
      "ja": "9.2。宛先オプションを送信"
    },
    {
      "indent": 3,
      "text": "To send a Destination options header, the application specifies it either as ancillary data in a call to sendmsg() or using setsockopt().",
      "ja": "宛先オプションヘッダを送信するには、アプリケーションが）コールで補助データは、（SENDMSGするよう）または（のsetsockoptのいずれかを使用して、それを指定します。"
    },
    {
      "indent": 3,
      "text": "The application can remove any sticky Destination options header by calling setsockopt() for IPV6_RTHDRDSTOPTS/IPV6_DSTOPTS with a zero option length.",
      "ja": "アプリケーションは、ゼロオプション長でIPV6_RTHDRDSTOPTS / IPV6_DSTOPTSためのsetsockopt（）を呼び出すことにより、任意の粘着性の宛先オプションヘッダを除去することができます。"
    },
    {
      "indent": 3,
      "text": "This API assumes the ordering about extension headers as described in [RFC-2460]. Thus, one set of Destination options can only appear before a Routing header, and one set can only appear after a Routing header (or in a packet with no Routing header). Each set can consist of one or more options but each set is a single extension header.",
      "ja": "このAPIは、[RFC-2460]で説明したように拡張ヘッダについての順序を前提としています。したがって、宛先オプションの一組は、ルーティングヘッダの前に表示することができ、そして1セットのみ（又は全くルーティングヘッダを持つパケットで）ルーティングヘッダの後に現れることができます。各セットは、1つの以上のオプションで構成することができるが、各セットは、単一の拡張ヘッダです。"
    },
    {
      "indent": 3,
      "text": "Today all destination options that an application may want to specify can be put after (or without) a Routing header. Thus, applications should usually need IPV6_DSTOPTS only and should avoid using IPV6_RTHDRDSTOPTS whenever possible.",
      "ja": "今日、アプリケーションが指定することをお勧めしますすべての宛先オプションは、後に（またはなし）ルーティングヘッダに置くことができます。したがって、アプリケーションは、通常はIPV6_DSTOPTSを必要とすべきであり、可能な限りIPV6_RTHDRDSTOPTSを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "When using ancillary data a Destination options header is passed between the application and the kernel as follows: The set preceding a Routing header are specified with the cmsg_level member set to IPPROTO_IPV6 and the cmsg_type member set to IPV6_RTHDRDSTOPTS. Any setsockopt or ancillary data for IPV6_RTHDRDSTOPTS is silently ignored when sending packets unless a Routing header is also specified. Note that the \"Routing header\" here means the one specified by this API. Even when the kernel inserts a routing header in its internal routine (e.g., in a mobile IPv6 stack), the Destination options header specified by IPV6_RTHDRDSTOPTS will still be ignored unless the application explicitly specifies its own Routing header.",
      "ja": "ルーティングヘッダに先行するセットがIPPROTO_IPV6に設定cmsg_levelメンバ部材とIPV6_RTHDRDSTOPTSに設定cmsg_typeメンバーで指定されている：補助データを使用する場合、以下のように宛先オプションヘッダは、アプリケーションとカーネルとの間に通されます。ルーティングヘッダも指定されない限り、パケットを送信するときIPV6_RTHDRDSTOPTSための任意のsetsockoptまたは補助データは無視されます。 「ルーティングヘッダ」はここで、このAPIによって指定されたものを意味することに注意してください。カーネルは、（例えば、モバイルIPv6スタックにおける）内部ルーチンにルーティング・ヘッダを挿入した場合でも、アプリケーションが明示的に独自のルーティングヘッダを指定しない限り、オプションはIPV6_RTHDRDSTOPTSによって指定されたヘッダの宛先は依然として無視されます。"
    },
    {
      "indent": 3,
      "text": "The set of Destination options after a Routing header, which are also used when no Routing header is present, are specified with the cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_DSTOPTS.",
      "ja": "いかなるルーティングヘッダが存在しない場合にも使用されるルーティングヘッダ、後の宛先オプションのセットは、cmsg_levelメンバ部材はIPPROTO_IPV6に設定され、cmsg_type部材がIPV6_DSTOPTSに設定されていると指定されています。"
    },
    {
      "indent": 3,
      "text": "The Destination options are normally constructed using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10.",
      "ja": "宛先オプションは、通常のセクション10に記載inet6_opt_init（）、inet6_opt_append（）、inet6_opt_finish（）、及びinet6_opt_set_val（）関数を使用して構築されています。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() and setsockopt() if the specified option is in error.",
      "ja": "追加のエラーがsendmsgの（）とのsetsockopt（）指定されたオプションにエラーがある場合の可能性があります。"
    },
    {
      "indent": 0,
      "text": "10. Hop-by-Hop and Destination Options Processing",
      "section_title": true,
      "ja": "10.ホップバイホップと宛先オプション処理"
    },
    {
      "indent": 3,
      "text": "Building and parsing the Hop-by-Hop and Destination options is complicated for the reasons given earlier. We therefore define a set of functions to help the application. These functions assume the formatting rules specified in Appendix B in [RFC-2460] i.e., that the largest field is placed last in the option.",
      "ja": "ビルやバイホップホップと宛先オプションを解析するには、先に与えられた理由のために複雑です。したがって、我々は、アプリケーションを支援するための関数のセットを定義します。これらの機能は、最大フィールドはオプションで最後に配置されていることを、[RFC-2460]すなわち付録Bに指定されたフォーマットルールを仮定する。"
    },
    {
      "indent": 3,
      "text": "The function prototypes for these functions are defined as a result of including <netinet/in.h>.",
      "ja": "これらの関数の関数プロトタイプは、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "The first 3 functions (init, append, and finish) are used both to calculate the needed buffer size for the options, and to actually encode the options once the application has allocated a buffer for the header. In order to only calculate the size the application must pass a NULL extbuf and a zero extlen to those functions.",
      "ja": "最初の3つの機能（初期化、追加、および仕上げ）はオプションに必要なバッファサイズを計算するために、アプリケーションは、ヘッダ用のバッファを割り当てた後、実際にオプションを符号化するための両方に使用されます。唯一のサイズを計算するために、アプリケーションは、NULLのEXTBUF及びそれらの機能にゼロextlenを通過しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.1. inet6_opt_init",
      "section_title": true,
      "ja": "10.1。 inet6_opt_init"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_init(void *extbuf, socklen_t extlen);",
      "ja": "int型inet6_opt_init（void *型EXTBUF、socklen_tをextlen）。"
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes needed for the empty extension header i.e., without any options. If extbuf is not NULL it also initializes the extension header to have the correct length field. In that case if the extlen value is not a positive (i.e., non-zero) multiple of 8 the function fails and returns -1.",
      "ja": "この関数は、オプションなしで、空の拡張ヘッダ即ちために必要なバイト数を返します。 EXTBUFがNULLでない場合には、正しい長さフィールドを有するように拡張ヘッダを初期化します。 extlen値が8の正の（すなわち、非ゼロの）倍数でない場合、その場合にはこの関数は失敗し、-1を返します。"
    },
    {
      "indent": 3,
      "text": "(Note: since the return value on success is based on a \"constant\" parameter, i.e., the empty extension header, an implementation may return a constant value. However, this specification does not require the value be constant, and leaves it as implementation dependent. The application should not assume a particular constant value as a successful return value of this function.)",
      "ja": "しかしながら、この仕様は、値が一定である必要はない成功した戻り値が「定数」パラメータ、すなわち、空の拡張ヘッダに基づいているので、実装が一定の値を返すことがあり、実装として残す：。（注依存する。アプリケーションは、この関数の成功戻り値として特定の定数値を取るべきではありません。）"
    },
    {
      "indent": 0,
      "text": "10.2. inet6_opt_append",
      "section_title": true,
      "ja": "10.2。 inet6_opt_append"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,\n                     uint8_t type, socklen_t len, uint_t align,\n                     void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Offset should be the length returned by inet6_opt_init() or a previous inet6_opt_append(). This function returns the updated total length taking into account adding an option with length 'len' and alignment 'align'. If extbuf is not NULL then, in addition to returning the length, the function inserts any needed pad option, initializes the option (setting the type and length fields) and returns a pointer to the location for the option content in databufp. If the option does not fit in the extension header buffer the function returns -1.",
      "ja": "オフセット）inet6_opt_init（によって返された長さ）又は前inet6_opt_append（あるべきです。この機能は、更新された全長が長さ「整列」「LEN」とアライメントとオプションを追加することを考慮に入れて返します。 EXTBUFがNULLでない場合、長さを返すことに加えて、機能は、任意の必要なパッドオプションを挿入するオプション（タイプと長さフィールドを設定）を初期化し、databufpでオプションコンテンツの場所へのポインタを返します。オプションは拡張ヘッダに収まらない場合は、機能をバッファリング-1を返します。"
    },
    {
      "indent": 3,
      "text": "Type is the 8-bit option type. Len is the length of the option data (i.e., excluding the option type and option length fields).",
      "ja": "タイプは、8ビットのオプションタイプです。 LEN（すなわち、オプションタイプとオプション長フィールドを除く）オプションデータの長さです。"
    },
    {
      "indent": 3,
      "text": "Once inet6_opt_append() has been called the application can use the databuf directly, or use inet6_opt_set_val() to specify the content of the option.",
      "ja": "inet6_opt_appendたら（）を直接databufを使用、またはオプションの内容を指定するには、（）inet6_opt_set_val使用できるアプリケーションと呼ばれてきました。"
    },
    {
      "indent": 3,
      "text": "The option type must have a value from 2 to 255, inclusive. (0 and 1 are reserved for the Pad1 and PadN options, respectively.)",
      "ja": "オプションタイプは、包括的、2から255までの値を持つ必要があります。 （0と1は、それぞれ、パッド1およびパッドNオプションのために予約されています。）"
    },
    {
      "indent": 3,
      "text": "The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.",
      "ja": "オプションのデータ長は、0〜255の値を持つ包括的、かつ以下のオプションデータの長さである必要があります。"
    },
    {
      "indent": 3,
      "text": "The align parameter must have a value of 1, 2, 4, or 8. The align value can not exceed the value of len.",
      "ja": "ALIGNパラメータは、LENの値を超えることができない1、2、4、または8 ALIGN値の値を有していなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.3. inet6_opt_finish",
      "section_title": true,
      "ja": "10.3。 inet6_opt_finish"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);",
      "ja": "（void *型EXTBUF、socklen_tをextlen、int型オフセット）int型inet6_opt_finish。"
    },
    {
      "indent": 3,
      "text": "Offset should be the length returned by inet6_opt_init() or inet6_opt_append(). This function returns the updated total length taking into account the final padding of the extension header to make it a multiple of 8 bytes. If extbuf is not NULL the function also initializes the option by inserting a Pad1 or PadN option of the proper length.",
      "ja": "inet6_opt_initによって返される長さであるべきであるオフセット（）またはinet6_opt_append（）。この関数は、8バイトの倍数にするためにアカウントに拡張ヘッダの最後のパディングをとる更新全長を返します。 EXTBUF機能をNULLでない場合にも、適切な長さのパッド1又はパッドNオプションを挿入することによって、オプションを初期化します。"
    },
    {
      "indent": 3,
      "text": "If the necessary pad does not fit in the extension header buffer the function returns -1.",
      "ja": "必要なパッドが拡張ヘッダに収まらない場合、関数バッファ-1を返します。"
    },
    {
      "indent": 0,
      "text": "10.4. inet6_opt_set_val",
      "section_title": true,
      "ja": "10.4。 inet6_opt_set_val"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_set_val(void *databuf, int offset, void *val,\n                      socklen_t vallen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Databuf should be a pointer returned by inet6_opt_append(). This function inserts data items of various sizes in the data portion of the option. Val should point to the data to be inserted. Offset specifies where in the data portion of the option the value should be inserted; the first byte after the option type and length is accessed by specifying an offset of zero.",
      "ja": "Databufはinet6_opt_appendによって返されたポインタ（）でなければなりません。この機能は、オプションのデータ部分における様々なサイズのデータ​​項目を挿入します。ヴァルは、挿入されるデータを指すべきです。オプションのデータ部分に値が挿入されるべきで指定したオフセット。オプションのタイプと長さの後の最初のバイトはゼロのオフセットを指定することによってアクセスされます。"
    },
    {
      "indent": 3,
      "text": "The caller should ensure that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the caller's behavior. Even when the alignment requirement is not satisfied, inet6_opt_set_val should just copy the data as required.",
      "ja": "呼び出し側は、[RFC-2460]の付録Bで説明したように、各フィールドは、その自然の境界に整列されていることを確認する必要がありますが、機能は、発信者の動作に依存してはいけません。アライメント要件が満たされていない場合でも、必要に応じ、inet6_opt_set_valは単にデータをコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "The function returns the offset for the next field (i.e., offset + vallen) which can be used when composing option content with multiple fields.",
      "ja": "関数は、複数のフィールドを持つオプションのコンテンツを構成する際に使用することができる次のフィールド（すなわち、+ vallenオフセット）のオフセットを返します。"
    },
    {
      "indent": 0,
      "text": "10.5. inet6_opt_next",
      "section_title": true,
      "ja": "10.5。 inet6_opt_next"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,\n                   uint8_t *typep, socklen_t *lenp,\n                   void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function parses received option extension headers returning the next option. Extbuf and extlen specifies the extension header. Offset should either be zero (for the first option) or the length returned by a previous call to inet6_opt_next() or inet6_opt_find(). It specifies the position where to continue scanning the extension buffer. The next option is returned by updating typep, lenp, and databufp. Typep stores the option type, lenp stores the length of the option data (i.e., excluding the option type and option length fields), and databufp points the data field of the option. This function returns the updated \"previous\" length computed by advancing past the option that was returned. This returned \"previous\" length can then be passed to subsequent calls to inet6_opt_next(). This function does not return any PAD1 or PADN options. When there are no more options or if the option extension header is malformed the return value is -1.",
      "ja": "この関数は、次のオプションを返す受信オプションの拡張ヘッダを解析します。 EXTBUFとextlenは、拡張ヘッダを指定します。ゼロ（最初のオプションの場合）でなければならないのいずれかでオフセットまたは以前の呼び出しによって返された長さがinet6_opt_find inet6_opt_next（）又は（）の。これは、拡張バッファをスキャン継続する位置を指定します。次のオプションがtypep、lenp、およびdatabufpを更新することによって返されます。 Typepオプション（即ち、オプションタイプとオプション長フィールドを除く）オプションデータの長さを格納lenpタイプ、およびdatabufp点オプションのデータフィールドを格納します。この関数は、返されたオプションを過ぎて前進させることによって、計算された更新「前」の長さを返します。これは、返された「前」の長さは、その後inet6_opt_nextする後続の呼び出しに渡すことができます（）。この関数は、任意のPAD1やPADNオプションを返しません。そこにはより多くの選択肢ではない場合やオプションの拡張ヘッダが不正されている場合、戻り値は-1です。"
    },
    {
      "indent": 0,
      "text": "10.6. inet6_opt_find",
      "section_title": true,
      "ja": "10.6。 inet6_opt_find"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_find(void *extbuf, socklen_t extlen, int offset,\n                   uint8_t type, socklen_t *lenp,\n                   void **databufp);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This function is similar to the previously described inet6_opt_next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the extension header.",
      "ja": "この機能は、発信者がオプションタイプを検索するように指定でき除き、この関数は常に拡張ヘッダの次のオプションを返すのではなく、前述のinet6_opt_next（）関数に似ています。"
    },
    {
      "indent": 3,
      "text": "If an option of the specified type is located, the function returns the updated \"previous\" total length computed by advancing past the option that was returned and past any options that didn't match the type. This returned \"previous\" length can then be passed to subsequent calls to inet6_opt_find() for finding the next occurrence of the same option type.",
      "ja": "指定されたタイプのオプションが配置されている場合は、関数が返されたオプションを過ぎやタイプと一致しませんでした任意のオプションを過ぎて前進させることによって、計算された更新「前」の合計の長さを返します。これは返さ「前」の長さは、同じオプションタイプの次の出現を見つけるため（）をinet6_opt_findする後続の呼び出しに渡すことができます。"
    },
    {
      "indent": 3,
      "text": "If an option of the specified type is not located, the return value is -1. If the option extension header is malformed, the return value is -1.",
      "ja": "指定されたタイプのオプションが配置されていない場合、戻り値は-1です。オプションの拡張ヘッダが不正である場合、戻り値は-1です。"
    },
    {
      "indent": 0,
      "text": "10.7. inet6_opt_get_val",
      "section_title": true,
      "ja": "10.7。 inet6_opt_get_val"
    },
    {
      "indent": 6,
      "text": "int inet6_opt_get_val(void *databuf, int offset, void *val,\n                      socklen_t vallen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Databuf should be a pointer returned by inet6_opt_next() or inet6_opt_find(). This function extracts data items of various sizes in the data portion of the option. Val should point to the destination for the extracted data. Offset specifies from where in the data portion of the option the value should be extracted; the first byte after the option type and length is accessed by specifying an offset of zero.",
      "ja": "Databufはinet6_opt_next（）またはinet6_opt_find（）によって返されたポインタであるべきです。この関数は、オプションのデータ部分に様々なサイズのデータ​​項目を抽出します。ヴァルは、抽出されたデータの宛先を指しているべきです。オプションのデータ部分の値が抽出されるべき場所から指定オフセット。オプションのタイプと長さの後の最初のバイトはゼロのオフセットを指定することによってアクセスされます。"
    },
    {
      "indent": 3,
      "text": "It is expected that each field is aligned on its natural boundaries as described in Appendix B of [RFC-2460], but the function must not rely on the alignment.",
      "ja": "[RFC-2460]の付録Bに記載されているように、各フィールドは、その自然境界上に整列されているが、機能は、アラインメントに依存してはならないことが予想されます。"
    },
    {
      "indent": 3,
      "text": "The function returns the offset for the next field (i.e., offset + vallen) which can be used when extracting option content with multiple fields.",
      "ja": "関数は、複数のフィールドを持つオプションの内容を抽出する際に使用することができる次のフィールド（すなわち、+ vallenオフセット）のオフセットを返します。"
    },
    {
      "indent": 0,
      "text": "11. Additional Advanced API Functions",
      "section_title": true,
      "ja": "11.追加の高度なAPI関数"
    },
    {
      "indent": 0,
      "text": "11.1. Sending with the Minimum MTU",
      "section_title": true,
      "ja": "11.1。最小MTUで送信"
    },
    {
      "indent": 3,
      "text": "Unicast applications should usually let the kernel perform path MTU discovery [RFC-1981], as long as the kernel supports it, and should not care about the path MTU. Some applications, however, might not want to incur the overhead of path MTU discovery, especially if the applications only send a single datagram to a destination. A potential example is a DNS server.",
      "ja": "ユニキャストアプリケーションは通常、カーネルがいる限り、カーネルがそれをサポートしているとして、パスMTUディスカバリ[RFC-1981]を実行し、パスMTUを気にはならないようにする必要があります。一部のアプリケーションでは、しかし、アプリケーションが唯一の宛先に単一のデータグラムを送信する場合は特に、パスMTUディスカバリのオーバーヘッドが発生したくない場合があります。潜在的な例では、DNSサーバです。"
    },
    {
      "indent": 3,
      "text": "[RFC-1981] describes how path MTU discovery works for multicast destinations. From practice in using IPv4 multicast, however, many careless applications that send large multicast packets on the wire have caused implosion of ICMPv4 error messages. The situation can be worse when there is a filtering node that blocks the ICMPv4 messages. Though the filtering issue applies to unicast as well, the impact is much larger in the multicast cases.",
      "ja": "[RFC-1981]は、パスMTUディスカバリは、マルチキャスト宛先に対してどのように動作するかを説明します。練習からのIPv4マルチキャストを使用して、しかし、ワイヤーに大きなマルチキャストパケットを送信する多くの不注意なアプリケーションでは、ICMPv4のエラーメッセージの爆縮を引き起こしました。そのブロックのICMPv4メッセージをフィルタリングノードがある場合、状況はさらに悪化することができます。フィルタリングの問題が同様にユニキャストに適用されますが、インパクトは、マルチキャストの場合、はるかに大きいです。"
    },
    {
      "indent": 3,
      "text": "Thus, applications sending multicast traffic should explicitly enable path MTU discovery only when they understand that the benefit of possibly larger MTU usage outweighs the possible impact of MTU discovery for active sources across the delivery tree(s). This default behavior is based on the today's practice with IPv4 multicast and path MTU discovery. The behavior may change in the future once it is found that path MTU discovery effectively works with actual multicast applications and network configurations.",
      "ja": "このように、マルチキャストトラフィックを送信するアプリケーションは、明示的に配信木（複数可）を横切るアクティブソースのMTU発見の可能衝撃を上回る可能性が大きいMTUの使用の利点ことを理解する場合にのみ、パスMTU探索を可能にするべきです。このデフォルトの動作は、IPv4のマルチキャストおよびパスMTUディスカバリと今日のプラクティスに基づいています。パスMTUディスカバリが効果的に実際のマルチキャストアプリケーションおよびネットワーク構成で動作することが判明した後の行動は、将来的に変更されることがあります。"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism to avoid path MTU discovery by sending at the minimum IPv6 MTU [RFC-2460]. If the packet is larger than the minimum MTU and this feature has been enabled the IP layer will fragment to the minimum MTU. To control the policy about path MTU discovery, applications can use the IPV6_USE_MIN_MTU socket option.",
      "ja": "この仕様は、最小のIPv6 MTU [RFC-2460]に送信することによって、パスMTU探索を回避するためのメカニズムを定義します。パケットが最小MTUよりも大きくなると、この機能が有効になっている場合はIP層は最小MTUにフラグメント化します。パスMTUディスカバリに関するポリシーを制御するために、アプリケーションはIPV6_USE_MIN_MTUソケットオプションを使用することができます。"
    },
    {
      "indent": 3,
      "text": "As described above, the default policy should depend on whether the destination is unicast or multicast. For unicast destinations path MTU discovery should be performed by default. For multicast destinations path MTU discovery should be disabled by default. This option thus takes the following three types of integer arguments:",
      "ja": "上述したように、デフォルトのポリシーは、宛先がユニキャストまたはマルチキャストであるかどうかに依存しなければなりません。ユニキャストの宛先パスのMTUの発見は、デフォルトで実行する必要があります。マルチキャストの宛先のパスMTUディスカバリはデフォルトで無効にされなければなりません。このオプションは、このように、整数の引数には、次の3種類を取ります。"
    },
    {
      "indent": 3,
      "text": "-1: perform path MTU discovery for unicast destinations but do not perform it for multicast destinations. Packets to multicast destinations are therefore sent with the minimum MTU.",
      "ja": "-1：ユニキャスト宛先のパスMTUディスカバリを実行しますが、マルチキャストの目的地のためにそれを実行しないでください。マルチキャストの宛先へのパケットは、したがって、最小MTUで送信されます。"
    },
    {
      "indent": 3,
      "text": "0: always perform path MTU discovery.",
      "ja": "0：常にパスMTU探索を行います。"
    },
    {
      "indent": 3,
      "text": "1: always disable path MTU discovery and send packets at the minimum MTU.",
      "ja": "1：常にパスMTUディスカバリを無効にして、最小MTUでパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "The default value of this option is -1. Values other than -1, 0, and 1 are invalid, and an error EINVAL will be returned for those values.",
      "ja": "このオプションのデフォルト値は-1です。 -1、0、1以外の値は無効であり、エラーEINVALはそれらの値のために返されます。"
    },
    {
      "indent": 3,
      "text": "As an example, if a unicast application intentionally wants to disable path MTU discovery, it will add the following lines:",
      "ja": "ユニキャストアプリケーションが意図的にパスMTUディスカバリを無効にしたい場合の例としては、それは次の行を追加します。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this API intentionally excludes the case where the application wants to perform path MTU discovery for multicast but to disable it for unicast. This is because such usage is not feasible considering a scale of performance issues around whether to do path MTU discovery or not. When path MTU discovery makes sense to a destination but not to a different destination, regardless of whether the destination is unicast or multicast, applications either need to toggle the option between sending such packets on the same socket, or use different sockets for the two classes of destinations.",
      "ja": "このAPIは、意図的にアプリケーションがマルチキャスト用のパスMTUディスカバリを実行するのではなく、ユニキャストのためにそれを無効にしたい場合を除外することに注意してください。このような使用は、パスMTU探索を行うべきか否かの周りのパフォーマンスの問題の規模を考えると現実的ではないためです。パスMTU探索が先にではなく、異なる宛先に理にかなっている場合に関係なく、宛先がユニキャストまたはマルチキャストであるかどうか、アプリケーションが同じソケットにそのようなパケットを送信する間のオプションを切り替える必要があるか、または二つのクラスに対して異なるソケットを使用しますか目的地の。"
    },
    {
      "indent": 3,
      "text": "This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_USE_MIN_MTU, and the first byte of cmsg_data[] will be the first byte of the integer.",
      "ja": "このオプションは、補助的なデータとして送信することができます。この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_USE_MIN_MTUなり、CMSG_DATAの最初のバイト[]は整数の最初のバイトであろう。"
    },
    {
      "indent": 0,
      "text": "11.2. Sending without Fragmentation",
      "section_title": true,
      "ja": "11.2。断片化せずに送信します"
    },
    {
      "indent": 3,
      "text": "In order to provide for easy porting of existing UDP and raw socket applications IPv6 implementations will, when originating packets, automatically insert a fragment header in the packet if the packet is too big for the path MTU.",
      "ja": "パケットを発信するとき、パケットはパスMTUのために大きすぎる場合、既存のUDPと生ソケットアプリケーションIPv6実装の容易な移植を提供するために、自動的にパケットにフラグメントヘッダを挿入します。"
    },
    {
      "indent": 3,
      "text": "Some applications might not want this behavior. An example is traceroute which might want to discover the actual path MTU.",
      "ja": "一部のアプリケーションでは、この動作を望まない場合があります。例では、実際のパスMTUを発見することができますトレースルートです。"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism to turn off the automatic inserting of a fragment header for UDP and raw sockets. This can be enabled using the IPV6_DONTFRAG socket option.",
      "ja": "この仕様はUDPと生ソケットのフラグメントヘッダの自動挿入をオフにするメカニズムを定義します。これはIPV6_DONTFRAGソケットオプションを使用して有効にすることができます。"
    },
    {
      "indent": 6,
      "text": "int on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the value to 0 also disables the option i.e., reverts to the default behavior of automatic inserting. This option can also be sent as ancillary data. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_DONTFRAG, and the first byte of cmsg_data[] will be the first byte of the integer. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.",
      "ja": "デフォルトでは、このソケットオプションが無効になっています。値を0に設定することもオプションを無効にし、すなわち、自動挿入の既定の動作に戻ります。このオプションは、補助的なデータとして送信することができます。この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_DONTFRAGなり、CMSG_DATAの最初のバイト[]は整数の最初のバイトであろう。このAPIは、UDPと生ソケットにこのオプションの使用を指定し、TCPソケットの使用を定義していません。"
    },
    {
      "indent": 3,
      "text": "When the data size is larger than the MTU of the outgoing interface, the packet will be discarded. Applications can know the result by enabling the IPV6_RECVPATHMTU option described below and receiving the corresponding ancillary data items. An additional error EMSGSIZE may also be returned in some implementations. Note, however, that some other implementations might not be able to return this additional error when sending a message.",
      "ja": "データサイズが発信インターフェースのMTUよりも大きい場合、パケットは破棄されます。アプリケーションは、以下で説明するIPV6_RECVPATHMTUオプションを有効にすると、対応する補助的なデータ項目を受信することで、結果を知ることができます。追加のエラーEMSGSIZEも、いくつかの実装で返されることがあります。いくつかの他の実装がメッセージを送信するときに、この追加のエラーを返すことができない可能性があること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "11.3. Path MTU Discovery and UDP",
      "section_title": true,
      "ja": "11.3。パスMTUディスカバリーとUDP"
    },
    {
      "indent": 3,
      "text": "UDP and raw socket applications need to be able to determine the \"maximum send transport-message size\" (Section 5.1 of [RFC-1981]) to a given destination so that those applications can participate in path MTU discovery. This lets those applications send smaller datagrams to the destination, avoiding fragmentation.",
      "ja": "UDPと生ソケット・アプリケーションは、これらのアプリケーションは、パスMTU探索に参加できるように、所定の宛先に「最大送信トランスポート・メッセージサイズ」（[RFC-1981のセクション5.1）を決定できるようにする必要があります。これは、これらのアプリケーションは、断片化を避け、先に小さなデータグラムを送信することができます。"
    },
    {
      "indent": 3,
      "text": "This is accomplished using a new ancillary data item (IPV6_PATHMTU) which is delivered to recvmsg() without any actual data. The application can enable the receipt of IPV6_PATHMTU ancillary data items by setting the IPV6_RECVPATHMTU socket option.",
      "ja": "これは、実際のデータなしで（）のrecvmsgに配信される新しい補助データ項目（IPV6_PATHMTU）を使用して達成されます。アプリケーションはIPV6_RECVPATHMTUソケットオプションを設定することにより、IPV6_PATHMTU補助的なデータ項目の受信を可能にすることができます。"
    },
    {
      "indent": 6,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVPATHMTU, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the value to 0 also disables the option. This API only specifies the use of this option for UDP and raw sockets, and does not define the usage for TCP sockets.",
      "ja": "デフォルトでは、このソケットオプションが無効になっています。値を0に設定しても、オプションを無効にします。このAPIは、UDPと生ソケットにこのオプションの使用を指定し、TCPソケットの使用を定義していません。"
    },
    {
      "indent": 3,
      "text": "When the application is sending packets too big for the path MTU recvmsg() will return zero (indicating no data) but there will be a cmsghdr with cmsg_type set to IPV6_PATHMTU, and cmsg_len will indicate that cmsg_data is sizeof(struct ip6_mtuinfo) bytes long. This can happen when the sending node receives a corresponding ICMPv6 packet too big error, or when the packet is sent from a socket with the IPV6_DONTFRAG option being on and the packet size is larger than the MTU of the outgoing interface. This indication is considered as an ancillary data item for a separate (empty) message. Thus, when there are buffered messages (i.e., messages that the application has not received yet) on the socket the application will first receive the buffered messages and then receive the indication.",
      "ja": "アプリケーションは、（データがないことを示す）ゼロを返すであろうが、そこIPV6_PATHMTUに設定cmsg_typeとのcmsghdrなり、CMSG_LENそのCMSG_DATAにはsizeof（構造体ip6_mtuinfo）であることを示すであろう）（経路MTUのrecvmsgに対して大きすぎるパケットを送信しているときに長いバイト。送信ノードが対応するのICMPv6パケットが大きすぎるエラー、または時にパケットがIPV6_DONTFRAGオプションがオンであることをソケットから送信され、パケットサイズが発信インターフェイスのMTUよりも大きいさを受信したときに発生することがあります。この指示は、別個の（空の）メッセージのための補助的なデータ項目として考えられます。したがって、ソケットにバッファされたメッセージ（アプリケーションがまだ受信していない、すなわち、メッセージ）があるときに、アプリケーションは最初にバッファメッセージを受信し、指示を受けます。"
    },
    {
      "indent": 3,
      "text": "The first byte of cmsg_data[] will point to a struct ip6_mtuinfo carrying the path MTU to use together with the IPv6 destination address.",
      "ja": "CMSG_DATAの最初のバイト[]はIPv6宛先アドレスと一緒に使用するパスMTUを運ぶip6_mtuinfo構造体を指します。"
    },
    {
      "indent": 6,
      "text": "struct ip6_mtuinfo {\n  struct sockaddr_in6 ip6m_addr; /* dst address including\n                                    zone ID */\n  uint32_t            ip6m_mtu;  /* path MTU in host byte order */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This cmsghdr will be passed to every socket that sets the IPV6_RECVPATHMTU socket option, even if the socket is non-connected. Note that this also means an application that sets the option may receive an IPV6_MTU ancillary data item for each ICMP too big error the node receives, including such ICMP errors caused by other applications on the node. Thus, an application that wants to perform the path MTU discovery by itself needs to keep history of destinations that it has actually sent to and to compare the address returned in the ip6_mtuinfo structure to the history. An implementation may choose not to delivery data to a connected socket that has a foreign address that is different than the address specified in the ip6m_addr structure.",
      "ja": "これのcmsghdrはソケットが未接続の場合でも、IPV6_RECVPATHMTUソケットオプションを設定し、すべてのソケットに渡されます。これは、ノード上の他のアプリケーションによって引き起こされるようなICMPエラーを含むノードが受信する各ICMP大きすぎるエラーのためIPV6_MTU補助データ項目を受信することができるオプションを設定するアプリケーションを意味します。このように、それ自体で、パスMTUディスカバリを実行したいアプリケーションは、それが実際に送信されたアドレスを比較するために、歴史にip6_mtuinfo構造に戻ってきた目的地の履歴を保持する必要があります。実装はないip6m_addr構造で指定されたアドレスとは異なる外部アドレスを有する接続されたソケットに配信データを選択することができます。"
    },
    {
      "indent": 3,
      "text": "When an application sends a packet with a routing header, the final destination stored in the ip6m_addr member does not necessarily contain complete information of the entire path.",
      "ja": "アプリケーションは、ルーティングヘッダを有するパケットを送信すると、ip6m_addr部材に格納された最終的な宛先は、必ずしもパス全体の完全な情報を含んでいません。"
    },
    {
      "indent": 0,
      "text": "11.4. Determining the Current Path MTU",
      "section_title": true,
      "ja": "11.4。現在のパスMTUの決定"
    },
    {
      "indent": 3,
      "text": "Some applications might need to determine the current path MTU e.g., applications using IPV6_RECVPATHMTU might want to pick a good starting value.",
      "ja": "一部のアプリケーションでは、MTUは、例えば、IPV6_RECVPATHMTUを使用するアプリケーションは、良い出発値を選択することがあります、現在のパスを決定する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "This specification defines a get-only socket option to retrieve the current path MTU value for the destination of a given connected socket. If the IP layer does not have a cached path MTU value it will return the interface MTU for the interface that will be used when sending to the destination address.",
      "ja": "この仕様は、与えられた接続されたソケットの宛先の現在のパスMTU値を取得するには、Get-のみソケットオプションを定義します。 IP層は、キャッシュされたパスMTU値を持っていない場合には、宛先アドレスに送信するときに使用されるインターフェイスのインターフェイスMTUを返します。"
    },
    {
      "indent": 3,
      "text": "This information is retrieved using the IPV6_PATHMTU socket option. This option takes a pointer to the ip6_mtuinfo structure as the fourth argument, and the size of the structure should be passed as a value-result parameter in the fifth argument.",
      "ja": "この情報はIPV6_PATHMTUソケットオプションを使用して取得されます。このオプションでは、第四の引数としてip6_mtuinfo構造体へのポインタをとり、構造体のサイズは、5番目の引数の値、結果パラメータとして渡されるべきです。"
    },
    {
      "indent": 6,
      "text": "struct ip6_mtuinfo mtuinfo;\nsocklen_t infolen = sizeof(mtuinfo);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "getsockopt(fd, IPPROTO_IPV6, IPV6_PATHMTU, &mtuinfo, &infolen);",
      "ja": "getsockoptの（FD、IPPROTO_IPV6、IPV6_PATHMTU、＆mtuinfo、＆infolen）"
    },
    {
      "indent": 3,
      "text": "When the call succeeds, the path MTU value is stored in the ip6m_mtu member of the ip6_mtuinfo structure. Since the socket is connected, the ip6m_addr member is meaningless and should not be referred to by the application.",
      "ja": "呼び出しが成功した場合、パスMTU値がip6_mtuinfo構造のip6m_mtu部材に格納されます。ソケットが接続されているので、ip6m_addr部材は無意味であり、アプリケーションによって参照されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "This option can only be used for a connected socket, because a non-connected socket does not have the information of the destination and there is no way to pass the destination via getsockopt(). When getsockopt() for this option is issued on a non-connected socket, the call will fail. Despite this limitation, this option is still useful from a practical point of view, because applications that care about the path MTU tend to send a lot of packets to a single destination and to connect the socket to the destination for performance reasons. If the application needs to get the MTU value in a more generic way, it should use a more generic interface, such as routing sockets [TCPIPILLUST].",
      "ja": "非接続ソケットは宛先の情報を持っていないと（）はgetsockoptを介して宛先を通過する方法がないため、このオプションは、接続されたソケットのために使用することができます。このオプションのはgetsockopt（）は非接続されたソケット上で発行されると、コールは失敗します。パスMTUを気にするアプリケーションは、単一の宛先にパケットを大量に送信すると、パフォーマンス上の理由から先にソケットを接続する傾向があるため、この制限にもかかわらず、このオプションは、まだ実用的な観点から有用です。アプリケーションは、より一般的な方法でMTU値を取得する必要がある場合、そのようなソケット[TCPIPILLUST]をルーティングするように、より一般的なインタフェースを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Ordering of Ancillary Data and IPv6 Extension Headers",
      "section_title": true,
      "ja": "補助データとIPv6拡張ヘッダーの12注文"
    },
    {
      "indent": 3,
      "text": "Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): the Routing header, Hop-by-Hop options header, and Destination options header. When multiple ancillary data objects are transferred via recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram. For example, when the application has enabled the IPV6_RECVRTHDR and IPV6_RECVDSTOPTS options and later receives an IPv6 packet with extension headers in the following order:",
      "ja": "三のIPv6拡張ヘッダは、アプリケーションによって指定され、sendmsgのと補助データを使用するアプリケーション（）とのrecvmsg（）に戻すことができる：ルーティングヘッダ、ホップバイホップオプションヘッダと宛先オプションヘッダ。複数の補助データオブジェクトは（のrecvmsgを介して転送）と、これらのオブジェクトは、これらの3つの拡張ヘッダのいずれかを表している場合、制御バッファにおけるそれらの配置は、直接対応するIPv6データグラム内のそれらの位置に接続されています。例えば、アプリケーションはIPV6_RECVRTHDRとIPV6_RECVDSTOPTSオプションを有効にし、後で次の順序で拡張ヘッダを持つIPv6パケットを受信した場合："
    },
    {
      "indent": 6,
      "text": "The IPv6 header A Hop-by-Hop options header A Destination options header (1) A Routing header An Authentication header A Destination options header (2) A UDP header and UDP data",
      "ja": "IPv6のヘッダAホップバイホップオプションは宛先オプションヘッダをヘッダ（1）ルーティングヘッダアン認証（2）UDPヘッダとUDPデータ宛先オプションヘッダをヘッダ"
    },
    {
      "indent": 3,
      "text": "then the application will receive three ancillary data objects in the following order:",
      "ja": "アプリケーションは、次の順序で3つの補助的なデータオブジェクトを受け取ります。"
    },
    {
      "indent": 6,
      "text": "an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (1) an object with cmsg_type set to IPV6_RTHDR, which represents the Routing header an object with cmsg_type set to IPV6_DSTOPTS, which represents the destination options header (2)",
      "ja": "ルーティングを表す宛先オプションヘッダを表すIPV6_DSTOPTSに設定cmsg_type持つオブジェクト、（1）IPV6_RTHDRに設定cmsg_typeを持つオブジェクトは、宛先オプション・ヘッダを表すIPV6_DSTOPTSに設定cmsg_typeを持つオブジェクトを、ヘッダ（2）"
    },
    {
      "indent": 3,
      "text": "This example follows the header ordering described in [RFC-2460], but the receiving side of this specification does not assume the ordering. Applications may receive any numbers of objects in any order according to the ordering of the received IPv6 datagram.",
      "ja": "この例では、[RFC-2460]に記載のヘッダの順序に従うが、本明細書の受信側は、順序を想定していません。アプリケーションは、受信したIPv6データグラムの順序に応じて任意の順序でのオブジェクトの任意の番号を受け取ることができます。"
    },
    {
      "indent": 3,
      "text": "For the sending side, however, this API imposes some ordering constraints according to [RFC-2460]. Applications using this API cannot make a packet with extension headers that do not follow the ordering. Note, however, that this does not mean applications must always follow the restriction. This is just a limitation in this API in order to give application programmers a guideline to construct headers in a practical manner. Should an application need to make an outgoing packet in an arbitrary order about the extension headers, some other technique, such as the datalink interfaces BPF or DLPI, must be used.",
      "ja": "送信側では、しかし、このAPIは、[RFC-2460]によると、いくつかの順序の制約を課します。このAPIを使用するアプリケーションは、順序に従わない拡張ヘッダを持つパケットをすることはできません。これは、アプリケーションが常に制限に従わなければならないという意味ではありませんので、しかし、注意してください。これは、アプリケーションプログラマに実用的な方法で、ヘッダを構築するための指針を与えるために、このAPIでただ制限です。アプリケーションは、拡張ヘッダ約任意の順序で送信パケットを作成する必要がある場合、そのようなデータリンクインターフェイスBPFやDLPIのようないくつかの他の技術が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The followings are more details about the constraints:",
      "ja": "以下は、制約の詳細は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "- Each IPV6_xxx ancillary data object for a particular type of extension header can be specified at most once in a single control buffer.",
      "ja": " - 拡張ヘッダの特定の型の各IPV6_xxx補助データオブジェクトは、単一の制御バッファに最も一度に指定することができます。"
    },
    {
      "indent": 3,
      "text": "- IPV6_xxx ancillary data objects can appear in any order in a control buffer, because there is no ambiguity of the ordering.",
      "ja": " - 秩序のないあいまいさがないのでIPV6_xxx補助的なデータオブジェクトは、制御バッファ内の任意の順序で表示されます。"
    },
    {
      "indent": 3,
      "text": "- Each set of IPV6_xxx ancillary data objects and sticky options will be put in the outgoing packet along with the header ordering described in [RFC-2460].",
      "ja": " -  IPV6_xxx補助データオブジェクトとスティッキーオプションの各セットは、[RFC-2460]に記載のヘッダの順序と一緒に発信パケットに置かれます。"
    },
    {
      "indent": 3,
      "text": "- An ancillary data object or a sticky option of IPV6_RTHDRDSTOPTS will affect the outgoing packet only when a Routing header is specified as an ancillary data object or a sticky option. Otherwise, the specified value for IPV6_RTHDRDSTOPTS will be ignored.",
      "ja": " - 補助データ・オブジェクトまたはIPV6_RTHDRDSTOPTSのstickyオプションは、ルーティングヘッダが補助的なデータオブジェクト又はスティッキーオプションとして指定されている唯一の発信パケットに影響を与えます。それ以外の場合は、IPV6_RTHDRDSTOPTSに指定された値は無視されます。"
    },
    {
      "indent": 3,
      "text": "For example, when an application sends a UDP datagram with a control data buffer containing ancillary data objects in the following order:",
      "ja": "例えば、アプリケーションは、次の順序で補助データオブジェクトを含む制御データバッファとUDPデータグラムを送信する場合："
    },
    {
      "indent": 6,
      "text": "an object with cmsg_type set to IPV6_DSTOPTS an object with cmsg_type set to IPV6_RTHDRDSTOPTS an object with cmsg_type set to IPV6_HOPOPTS",
      "ja": "IPV6_HOPOPTSに設定cmsg_typeでオブジェクトをIPV6_RTHDRDSTOPTSに設定cmsg_type持つオブジェクトをIPV6_DSTOPTSに設定cmsg_type持つオブジェクト"
    },
    {
      "indent": 3,
      "text": "and the sending socket does not have any sticky options, then the outgoing packet would be constructed as follows:",
      "ja": "そして、送信ソケットは、送信パケットは以下のように構築されるだろう、任意の粘着性のオプションがありません。"
    },
    {
      "indent": 6,
      "text": "The IPv6 header A Hop-by-Hop options header A Destination options header A UDP header and UDP data",
      "ja": "IPv6はオプションは宛先オプションヘッダホップバイホップUDPヘッダとUDPデータをヘッダヘッダ"
    },
    {
      "indent": 3,
      "text": "where the destination options header corresponds to the ancillary data object with the type IPV6_DSTOPTS.",
      "ja": "宛先オプションヘッダは、タイプIPV6_DSTOPTSと補助データオブジェクトに対応します。"
    },
    {
      "indent": 3,
      "text": "Note that the constraints above do not necessarily mean that the outgoing packet sent on the wire always follows the header ordering specified in this API document. The kernel may insert additional headers that break the ordering as a result. For example, if the kernel supports Mobile IPv6, an additional destination options header may be inserted before an authentication header, even without a routing header.",
      "ja": "上記の制約は、必ずしもワイヤーに送られた発信パケットは、常にこのAPI文書で指定されたヘッダの順序に従っていることを意味するものではありませんので注意してください。カーネルは、結果として、発注を破る追加ヘッダを挿入することができます。カーネルはモバイルIPv6をサポートしている場合、例えば、追加の宛先オプションヘッダは、さらにルーティングヘッダなしで、認証ヘッダの前に挿入されてもよいです。"
    },
    {
      "indent": 3,
      "text": "This API does not provide access to any other extension headers than the supported three types of headers. In particular, no information is provided about the IP security headers on an incoming packet, nor can be specified for an outgoing packet. This API is for applications that do not care about the existence of IP security headers.",
      "ja": "このAPIは、ヘッダのサポート3種類以外の拡張ヘッダへのアクセスを提供していません。具体的には、何の情報は、着信パケットのIPセキュリティヘッダについては提供されていない、また発信パケットのために指定することができます。このAPIは、IPセキュリティヘッダの存在を気にしないアプリケーションのためです。"
    },
    {
      "indent": 0,
      "text": "13. IPv6-Specific Options with IPv4-Mapped IPv6 Addresses",
      "section_title": true,
      "ja": "IPv4マップIPv6アドレスを持つ13 IPv6固有オプション"
    },
    {
      "indent": 3,
      "text": "The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.",
      "ja": "様々なソケットオプションと、この文書で定義された補助的なデータ仕様は真のIPv6ソケットにのみ適用されます。実際に送信し、IPv4射影IPv6アドレスを使用して、IPv4パケットを受信したIPv6ソケットを作成することは可能ですが、IPv4のデータグラムには、この文書で定義されたオプションのマッピングは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "In general, attempting to specify an IPv6-only option, such as the Hop-by-Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4-mapped IPv6 addresses, will probably result in an error. Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4-mapped IPv6 addresses.",
      "ja": "一般に、このようなIPv4マップIPv6アドレスを使用しているIPv6ソケット上のホップバイホップオプション、宛先オプション、またはルーティングヘッダとして、IPv6のみのオプションを指定しようとすると、おそらくエラーになります。いくつかの実装では、しかし、IPv4マップIPv6アドレスを使用しているIPv6ソケットに（ソース/宛先アドレス、インターフェース、およびホップリミットを受信/送信）パケット情報へのアクセスを提供することができます。"
    },
    {
      "indent": 0,
      "text": "14. Extended interfaces for rresvport, rcmd and rexec",
      "section_title": true,
      "ja": "rresvport、RCMDとREXEC 14.拡張インターフェース"
    },
    {
      "indent": 3,
      "text": "Library functions that support the \"r\" commands hide the creation of a socket and the name resolution procedure from an application. When the libraries return an AF_INET6 socket to an application that do not support the address family, the application may encounter an unexpected result when, e.g., calling getpeername() for the socket. In order to support AF_INET6 sockets for the \"r\" commands while keeping backward compatibility, this section defines some extensions to the libraries.",
      "ja": "「R」コマンドをサポートライブラリ関数は、アプリケーションからのソケットと名前解決手順の作成を非表示にします。ライブラリは、アドレスファミリをサポートしていないアプリケーションにAF_INET6ソケットを返す場合は、例えば、ソケットのgetpeername（）を呼び出すときに、アプリケーションが予期しない結果が発生する場合があります。下位互換性を維持しながら、「R」のコマンドのAF_INET6ソケットをサポートするために、このセクションでは、ライブラリにいくつかの拡張機能を定義します。"
    },
    {
      "indent": 0,
      "text": "14.1. rresvport_af",
      "section_title": true,
      "ja": "14.1。 rresvport_af"
    },
    {
      "indent": 3,
      "text": "The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the \"r\" commands such as rlogin. While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.",
      "ja": "rresvport（）関数は、RCMD（）関数によって使用され、この機能は、今度は、そのようなrloginのような「R」コマンドの多くによって呼び出されます。新しいアプリケーションは、RCMD（）関数を使用するように書かれていないが、そのようなrloginなどのレガシーアプリケーションはそれを使用し続けると、これらは、IPv6に移植されます。"
    },
    {
      "indent": 3,
      "text": "rresvport() creates an IPv4/TCP socket and binds a \"reserved port\" to the socket. Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.",
      "ja": "rresvport（）はIPv4の/ TCPソケットを作成し、ソケットに「予約ポート」をバインドします。代わりに、この機能のIPv6のバージョンを定義するので、私たちはその引数としてアドレスファミリを取る新しい関数を定義します。"
    },
    {
      "indent": 6,
      "text": "#include <unistd.h>",
      "ja": "書式#include <unistd.h>"
    },
    {
      "indent": 6,
      "text": "int rresvport_af(int *port, int family);",
      "ja": "あなたrresvport_af（あなた*ポート、あなたの家族）。"
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rresvport() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is either AF_INET or AF_INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.",
      "ja": "この機能は、既存のrresvport（）関数と同じように動作しますが、代わりにAF_INETのTCPソケットを作成するのではなく、それはまた、AF_INET6 TCPソケットを作成することができます。家族の引数は、どちらかAF_INETまたはAF_INET6で、アドレスファミリがサポートされていない場合、新しいエラーリターンはEAFNOSUPPORTです。"
    },
    {
      "indent": 3,
      "text": "(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes. 4.4BSD defines it in <unistd.h>, others in <netdb.h>, and others don't define the function prototypes at all.)",
      "ja": "（注：少しヘッダがrresvportを定義したコンセンサス（）およびRCMD（）関数のプロトタイプがあり4.4BSDは<netdb.h>で他、<unistd.h>にそれを定義し、他のものは関数プロトタイプを定義していません。全然。）"
    },
    {
      "indent": 0,
      "text": "14.2. rcmd_af",
      "section_title": true,
      "ja": "14.2。 rcmd_af"
    },
    {
      "indent": 3,
      "text": "The existing rcmd() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rcmd(). Thus a new function is needed.",
      "ja": "アプリケーションは、例えばによって返さAF_INET6アドレスを、RCMDによって作成されたファイルディスクリプタのgetpeername（）（）を処理するために準備されないので、既存のRCMD（）関数は、透過的にAF_INET6ソケットを使用することはできません。このように、新たな機能が必要とされています。"
    },
    {
      "indent": 6,
      "text": "int rcmd_af(char **ahost, unsigned short rport, const char *locuser, const char *remuser, const char *cmd, int *fd2p, int af)",
      "ja": "int型rcmd_af（文字** ahost、符号なしの短いRPORT、constのchar型* locuser、constのchar型* remuser、constのchar型* cmdを、int型* fd2p、INT AF）"
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rcmd() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.",
      "ja": "この機能は、既存のRCMD（）関数と同じように動作しますが、代わりにAF_INETのTCPソケットを作成するのではなく、それはまた、AF_INET6 TCPソケットを作成することができます。家族の引数がAF_INET、AF_INET6、またはAF_UNSPECです。 AF_INETまたはAF_INET6のどちらかが指定されている場合、この関数は、指定されたアドレスファミリのソケットを作成します。 AF_UNSPECが指定されている場合は、接続が確立できるまで、すべての可能なアドレスファミリをしようとすると、接続の関連するソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーEAFNOSUPPORTが返されます。"
    },
    {
      "indent": 0,
      "text": "14.3. rexec_af",
      "section_title": true,
      "ja": "14.3。 rexec_af"
    },
    {
      "indent": 3,
      "text": "The existing rexec() function can not transparently use AF_INET6 sockets since an application would not be prepared to handle AF_INET6 addresses returned by e.g., getpeername() on the file descriptor created by rexec(). Thus a new function is needed.",
      "ja": "アプリケーションは、例えばによって返さAF_INET6アドレスを、REXECによって作成されたファイルディスクリプタのgetpeername（）（）を処理するために準備されないので、既存のrexec（）関数は、透過的にAF_INET6ソケットを使用することはできません。このように、新たな機能が必要とされています。"
    },
    {
      "indent": 6,
      "text": "int rexec_af(char **ahost, unsigned short rport, const char *name, const char *pass, const char *cmd, int *fd2p, int af)",
      "ja": "int型rexec_af（文字** ahost、符号なしの短いRPORT、CONST文字*名、のconstのchar *のパス、CONSTするchar * cmdと、int型* fd2p、INT AF）"
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rexec() function, but instead of creating an AF_INET TCP socket, it can also create an AF_INET6 TCP socket. The family argument is AF_INET, AF_INET6, or AF_UNSPEC. When either AF_INET or AF_INET6 is specified, this function will create a socket of the specified address family. When AF_UNSPEC is specified, it will try all possible address families until a connection can be established, and will return the associated socket of the connection. A new error EAFNOSUPPORT will be returned if the address family is not supported.",
      "ja": "この機能は、既存のREXEC（）関数と同じように動作しますが、代わりにAF_INETのTCPソケットを作成するのではなく、それはまた、AF_INET6 TCPソケットを作成することができます。家族の引数がAF_INET、AF_INET6、またはAF_UNSPECです。 AF_INETまたはAF_INET6のどちらかが指定されている場合、この関数は、指定されたアドレスファミリのソケットを作成します。 AF_UNSPECが指定されている場合は、接続が確立できるまで、すべての可能なアドレスファミリをしようとすると、接続の関連するソケットを返します。アドレスファミリがサポートされていない場合、新しいエラーEAFNOSUPPORTが返されます。"
    },
    {
      "indent": 0,
      "text": "15. Summary of New Definitions",
      "section_title": true,
      "ja": "新しい定義の概要15"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.",
      "ja": "以下のリストは、ヘッダによってソート定数と構造、このメモで議論定義をまとめたものです。"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> ICMP6_DST_UNREACH <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN <netinet/icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE <netinet/icmp6.h> ICMP6_ECHO_REPLY <netinet/icmp6.h> ICMP6_ECHO_REQUEST <netinet/icmp6.h> ICMP6_INFOMSG_MASK",
      "ja": "<netinetの/ icmp6.h> ICMP6_DST_UNREACH <netinetの/ icmp6.h> ICMP6_DST_UNREACH_ADDR <netinetの/ icmp6.h> ICMP6_DST_UNREACH_ADMIN <netinetの/ icmp6.h> ICMP6_DST_UNREACH_BEYONDSCOPE <netinetの/ icmp6.h> ICMP6_DST_UNREACH_NOPORT <netinetの/ icmp6.h> ICMP6_DST_UNREACH_NOROUTE <netinetの/icmp6.h> ICMP6_ECHO_REPLY <netinetの/ icmp6.h> ICMP6_ECHO_REQUEST <netinetの/ icmp6.h> ICMP6_INFOMSG_MASK"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> ICMP6_PACKET_TOO_BIG <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION <netinet/icmp6.h> ICMP6_PARAM_PROB <netinet/icmp6.h> ICMP6_ROUTER_RENUMBERING <netinet/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY <netinet/icmp6.h> ICMP6_RR_FLAGS_PREVDONE <netinet/icmp6.h> ICMP6_RR_FLAGS_REQRESULT <netinet/icmp6.h> ICMP6_RR_FLAGS_SPECSITE <netinet/icmp6.h> ICMP6_RR_FLAGS_TEST <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME <netinet/icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO <netinet/icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN <netinet/icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB <netinet/icmp6.h> ICMP6_TIME_EXCEEDED <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT <netinet/icmp6.h> MLD_LISTENER_QUERY <netinet/icmp6.h> MLD_LISTENER_REDUCTION <netinet/icmp6.h> MLD_LISTENER_REPORT <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE <netinet/icmp6.h> ND_NA_FLAG_ROUTER <netinet/icmp6.h> ND_NA_FLAG_SOLICITED <netinet/icmp6.h> ND_NEIGHBOR_ADVERT <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT <netinet/icmp6.h> ND_OPT_MTU <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR <netinet/icmp6.h> ND_RA_FLAG_MANAGED <netinet/icmp6.h> ND_RA_FLAG_OTHER <netinet/icmp6.h> ND_REDIRECT <netinet/icmp6.h> ND_ROUTER_ADVERT <netinet/icmp6.h> ND_ROUTER_SOLICIT",
      "ja": "<netinetの/ icmp6.h> ICMP6_PACKET_TOO_BIG <netinetの/ icmp6.h> ICMP6_PARAMPROB_HEADER <netinetの/ icmp6.h> ICMP6_PARAMPROB_NEXTHEADER <netinetの/ icmp6.h> ICMP6_PARAMPROB_OPTION <netinetの/ icmp6.h> ICMP6_PARAM_PROB <netinetの/ icmp6.h> ICMP6_ROUTER_RENUMBERING <netinetの/icmp6.h> ICMP6_RR_FLAGS_FORCEAPPLY <netinetの/ icmp6.h> ICMP6_RR_FLAGS_PREVDONE <netinetの/ icmp6.h> ICMP6_RR_FLAGS_REQRESULT <netinetの/ icmp6.h> ICMP6_RR_FLAGS_SPECSITE <netinetの/ icmp6.h> ICMP6_RR_FLAGS_TEST <netinetの/ icmp6.h> ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME <netinetの/ ICMP6 .H> ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME <netinetの/ icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_AUTO <netinetの/ icmp6.h> ICMP6_RR_PCOUSE_RAFLAGS_ONLINK <netinetの/ icmp6.h> ICMP6_RR_RESULT_FLAGS_FORBIDDEN <netinetの/ icmp6.h> ICMP6_RR_RESULT_FLAGS_OOB <netinetの/ icmp6.h> ICMP6_TIME_EXCEEDED <netinetの/ icmp6.h > ICMP6_TIME_EXCEED_REASSEMBLY <netinetの/ icmp6.h> ICMP6_TIME_EXCEED_TRANSIT <netinetの/ icmp6.h> MLD_LISTENER_QUERY <netinetの/ icmp6.h> MLD_LISTENER_REDUCTION <netinetの/ icmp6.h> MLD_LISTENER_REPORT <netinetの/ cmp6.h> ND_NA_FLAG_OVERRIDE <netinetの/ icmp6.h> ND_NA_FLAG_ROUTER <netinetの/ icmp6.h> ND_NA_FLAG_SOLICITED <netinetの/ icmp6.h> ND_NEIGHBOR_ADVERT <netinetの/ icmp6.h> ND_NEIGHBOR_SOLICIT <netinetの/ icmp6.h> ND_OPT_MTU <netinetの/ ICMP6。 H> ND_OPT_PI_FLAG_AUTO <netinetの/ icmp6.h> ND_OPT_PI_FLAG_ONLINK <netinetの/ icmp6.h> ND_OPT_PREFIX_INFORMATION <netinetの/ icmp6.h> ND_OPT_REDIRECTED_HEADER <netinetの/ icmp6.h> ND_OPT_SOURCE_LINKADDR <netinetの/ icmp6.h> ND_OPT_TARGET_LINKADDR <netinetの/ icmp6.h> ND_RA_FLAG_MANAGED <netinetの/ icmp6.h> ND_RA_FLAG_OTHER <netinetの/ icmp6.h> ND_REDIRECT <netinetの/ icmp6.h> ND_ROUTER_ADVERT <netinetの/ icmp6.h> ND_ROUTER_SOLICIT"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> struct icmp6_filter{};\n<netinet/icmp6.h> struct icmp6_hdr{};\n<netinet/icmp6.h> struct icmp6_router_renum{};\n<netinet/icmp6.h> struct mld_hdr{};\n<netinet/icmp6.h> struct nd_neighbor_advert{};\n<netinet/icmp6.h> struct nd_neighbor_solicit{};\n<netinet/icmp6.h> struct nd_opt_hdr{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> struct nd_opt_mtu{};\n<netinet/icmp6.h> struct nd_opt_prefix_info{};\n<netinet/icmp6.h> struct nd_opt_rd_hdr{};\n<netinet/icmp6.h> struct nd_redirect{};\n<netinet/icmp6.h> struct nd_router_advert{};\n<netinet/icmp6.h> struct nd_router_solicit{};\n<netinet/icmp6.h> struct rr_pco_match{};\n<netinet/icmp6.h> struct rr_pco_use{};\n<netinet/icmp6.h> struct rr_result{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h> IPPROTO_AH <netinet/in.h> IPPROTO_DSTOPTS <netinet/in.h> IPPROTO_ESP <netinet/in.h> IPPROTO_FRAGMENT <netinet/in.h> IPPROTO_HOPOPTS <netinet/in.h> IPPROTO_ICMPV6 <netinet/in.h> IPPROTO_IPV6 <netinet/in.h> IPPROTO_NONE <netinet/in.h> IPPROTO_ROUTING <netinet/in.h> IPV6_CHECKSUM <netinet/in.h> IPV6_DONTFRAG <netinet/in.h> IPV6_DSTOPTS <netinet/in.h> IPV6_HOPLIMIT <netinet/in.h> IPV6_HOPOPTS",
      "ja": "<netinetの/ in.h> IPPROTO_AH <netinetの/ in.h> IPPROTO_DSTOPTS <netinetの/ in.h> IPPROTO_ESP <netinetの/ in.h> IPPROTO_FRAGMENT <netinetの/ in.h> IPPROTO_HOPOPTS <netinetの/ in.h> IPPROTO_ICMPV6 <netinetの/in.h> IPPROTO_IPV6 <netinetの/ in.h> IPPROTO_NONE <netinetの/ in.h> IPPROTO_ROUTING <netinetの/ in.h> IPV6_CHECKSUM <netinetの/ in.h> IPV6_DONTFRAG <netinetの/ in.h> IPV6_DSTOPTS <netinetの/に.H> IPV6_HOPLIMIT <netinetの/ in.h> IPV6_HOPOPTS"
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    IPV6_NEXTHOP\n<netinet/in.h>    IPV6_PATHMTU\n<netinet/in.h>    IPV6_PKTINFO\n<netinet/in.h>    IPV6_RECVDSTOPTS\n<netinet/in.h>    IPV6_RECVHOPLIMIT\n<netinet/in.h>    IPV6_RECVHOPOPTS\n<netinet/in.h>    IPV6_RECVPKTINFO\n<netinet/in.h>    IPV6_RECVRTHDR\n<netinet/in.h>    IPV6_RECVTCLASS\n<netinet/in.h>    IPV6_RTHDR\n<netinet/in.h>    IPV6_RTHDRDSTOPTS\n<netinet/in.h>    IPV6_RTHDR_TYPE_0\n<netinet/in.h>    IPV6_RECVPATHMTU\n<netinet/in.h>    IPV6_TCLASS\n<netinet/in.h>    IPV6_USE_MIN_MTU\n<netinet/in.h>    struct in6_pktinfo{};\n<netinet/in.h>    struct ip6_mtuinfo{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h> IP6F_MORE_FRAG <netinet/ip6.h> IP6F_OFF_MASK <netinet/ip6.h> IP6F_RESERVED_MASK <netinet/ip6.h> IP6OPT_JUMBO <netinet/ip6.h> IP6OPT_JUMBO_LEN",
      "ja": "<netinetの/ ip6.h> IP6F_MORE_FRAG <netinetの/ ip6.h> IP6F_OFF_MASK <netinetの/ ip6.h> IP6F_RESERVED_MASK <netinetの/ ip6.h> IP6OPT_JUMBO <netinetの/ ip6.h> IP6OPT_JUMBO_LEN"
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>   IP6OPT_MUTABLE\n<netinet/ip6.h>   IP6OPT_NSAP_ADDR\n<netinet/ip6.h>   IP6OPT_PAD1\n<netinet/ip6.h>   IP6OPT_PADN\n<netinet/ip6.h>   IP6OPT_ROUTER_ALERT\n<netinet/ip6.h>   IP6OPT_TUNNEL_LIMIT\n<netinet/ip6.h>   IP6OPT_TYPE_DISCARD\n<netinet/ip6.h>   IP6OPT_TYPE_FORCEICMP\n<netinet/ip6.h>   IP6OPT_TYPE_ICMP\n<netinet/ip6.h>   IP6OPT_TYPE_SKIP\n<netinet/ip6.h>   IP6_ALERT_AN\n<netinet/ip6.h>   IP6_ALERT_MLD\n<netinet/ip6.h>   IP6_ALERT_RSVP\n<netinet/ip6.h>   struct ip6_dest{};\n<netinet/ip6.h>   struct ip6_frag{};\n<netinet/ip6.h>   struct ip6_hbh{};\n<netinet/ip6.h>   struct ip6_hdr{};\n<netinet/ip6.h>   struct ip6_opt{};\n<netinet/ip6.h>   struct ip6_opt_jumbo{};\n<netinet/ip6.h>   struct ip6_opt_nsap{};\n<netinet/ip6.h>   struct ip6_opt_router{};\n<netinet/ip6.h>   struct ip6_opt_tunnel{};\n<netinet/ip6.h>   struct ip6_rthdr{};\n<netinet/ip6.h>   struct ip6_rthdr0{};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "ja": "以下のリストは、ヘッダによってソートこのメモで議論機能とマクロプロトタイプをまとめたものです。"
    },
    {
      "indent": 6,
      "text": "<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int, struct\n                                         icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETPASS(int,\n                                       struct icmp6_filter *);\n<netinet/icmp6.h> void\n                  ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,\n                                     const struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,\n                                     const struct icmp6_filter *);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h> int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);",
      "ja": "<netinetの/ in.h> INT IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。"
    },
    {
      "indent": 6,
      "text": "<netinet/in.h> int inet6_opt_append(void *, socklen_t, int, uint8_t, socklen_t, uint_t, void **);",
      "ja": "<netinetの/ in.h> int型inet6_opt_append（ボイド*、socklen_tを、int型、uint8_t、socklen_tを、uint_t、無効**）。"
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int inet6_opt_get_val(void *, int, void *,\n                                        socklen_t);\n<netinet/in.h>    int inet6_opt_find(void *, socklen_t,\n                                     int, uint8_t ,\n                                     socklen_t *, void **);\n<netinet/in.h>    int inet6_opt_finish(void *, socklen_t, int);\n<netinet/in.h>    int inet6_opt_init(void *, socklen_t);\n<netinet/in.h>    int inet6_opt_next(void *, socklen_t,\n                                     int, uint8_t *,\n                                     socklen_t *, void **);\n<netinet/in.h>    int inet6_opt_set_val(void *, int,\n                                        void *, socklen_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>    int inet6_rth_add(void *,\n                                    const struct in6_addr *);\n<netinet/in.h>    struct in6_addr inet6_rth_getaddr(const void *,\n                                                    int);\n<netinet/in.h>    void *inet6_rth_init(void *, socklen_t,\n                                       int, int);\n<netinet/in.h>    int inet6_rth_reverse(const void *, void *);\n<netinet/in.h>    int inet6_rth_segments(const void *);\n<netinet/in.h>    soccklen_t inet6_rth_space(int, int);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h> int IP6OPT_TYPE(uint8_t);",
      "ja": "<netinetの/ ip6.h> INT IP6OPT_TYPE（uint8_t）。"
    },
    {
      "indent": 6,
      "text": "<sys/socket.h>    socklen_t CMSG_LEN(socklen_t);\n<sys/socket.h>    socklen_t CMSG_SPACE(socklen_t);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<unistd.h>        int rresvport_af(int *, int);\n<unistd.h>        int rcmd_af(char **, unsigned short,\n                              const char *, const char *,\n                              const char *, int *, int);\n<unistd.h>        int rexec_af(char **, unsigned short,\n                               const char *, const char *,\n                               const char *, int *, int);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The setting of certain Hop-by-Hop options and Destination options may be restricted to privileged processes. Similarly some Hop-by-Hop options and Destination options may not be returned to non-privileged applications.",
      "ja": "一定のホップバイホップオプションと宛先オプションの設定は特権プロセスに制限することができます。同様に、いくつかのホップバイホップオプションと宛先オプションは、非特権アプリケーションに返されないことがあります。"
    },
    {
      "indent": 3,
      "text": "The ability to specify an arbitrary source address using IPV6_PKTINFO must be prevented; at least for non-privileged processes.",
      "ja": "IPV6_PKTINFOを使用して、任意のソースアドレスを指定する機能は、防止しなければなりません。少なくとも非特権プロセスのために。"
    },
    {
      "indent": 0,
      "text": "17. Changes from ",
      "section_title": true,
      "ja": "17.変更から"
    },
    {
      "indent": 3,
      "text": "Significant changes that affect the compatibility to RFC 2292:",
      "ja": "RFC 2292との互換性に影響を与える重要な変更："
    },
    {
      "indent": 3,
      "text": "- Removed the IPV6_PKTOPTIONS socket option by allowing sticky options to be set with individual setsockopt() calls.",
      "ja": " - スティッキーオプションは、個々のsetsockopt（）の呼び出しで設定できるようにすることによってIPV6_PKTOPTIONSソケットオプションを削除しました。"
    },
    {
      "indent": 3,
      "text": "- Removed the ability to be able to specify Hop-by-Hop and Destination options using multiple ancillary data items. The application, using the inet6_opt_xxx() routines (see below), is responsible for formatting the whole extension header.",
      "ja": " - ホップバイホップと複数の補助的なデータ項目を使用して宛先オプションを指定することができるようにする機能を削除しました。 inet6_opt_xxx（）ルーチン（下記参照）を使用するアプリケーションは、全体拡張ヘッダをフォーマットする責任があります。"
    },
    {
      "indent": 3,
      "text": "- Removed the support for the loose/strict Routing header since that has been removed from the IPv6 specification.",
      "ja": " - それは、IPv6仕様から削除されているので、緩い/厳密ルーティングヘッダのサポートを削除。"
    },
    {
      "indent": 3,
      "text": "- Loosened the constraints for jumbo payload option that this option was always hidden from applications.",
      "ja": " - このオプションは、常にアプリケーションから隠されていたことをジャンボペイロードオプションの制約が緩み。"
    },
    {
      "indent": 3,
      "text": "- Disabled the use of the IPV6_HOPLIMIT sticky option.",
      "ja": " - 無効IPV6_HOPLIMIT stickyオプションを使用します。"
    },
    {
      "indent": 3,
      "text": "- Removed ip6r0_addr field from the ip6_rthdr structure.",
      "ja": " -  ip6_rthdr構造からip6r0_addrフィールドを削除しました。"
    },
    {
      "indent": 3,
      "text": "- Intentionally unspecified how to get received packet's information on TCP sockets.",
      "ja": " -  TCPソケット上でパケットの受信情報を取得する方法を意図的に指定されていません。"
    },
    {
      "indent": 3,
      "text": "New features:",
      "ja": "新機能："
    },
    {
      "indent": 3,
      "text": "- Added IPV6_RTHDRDSTOPTS to specify a Destination Options header before the Routing header.",
      "ja": " - 追加IPV6_RTHDRDSTOPTSは、ルーティングヘッダの前に宛先オプションヘッダーを指定します。"
    },
    {
      "indent": 3,
      "text": "- Added separate IPV6_RECVxxx options to enable the receipt of the corresponding ancillary data items.",
      "ja": " - 対応する補助的なデータ項目の受信を可能にするために別々のIPV6_RECVxxxオプションを追加しました。"
    },
    {
      "indent": 3,
      "text": "- Added inet6_rth_xxx() and inet6_opt_xxx() functions to deal with routing or IPv6 options headers.",
      "ja": " - 追加されたinet6_rth_xxx（）とinet6_opt_xxx（）関数は、ルーティングまたはIPv6オプションヘッダに対処します。"
    },
    {
      "indent": 3,
      "text": "- Added extensions of libraries for the \"r\" commands.",
      "ja": " - 「R」コマンドのためのライブラリの拡張を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Introduced additional IPv6 option definitions such as IP6OPT_PAD1.",
      "ja": " - そのようIP6OPT_PAD1などの追加のIPv6オプション定義を導入しました。"
    },
    {
      "indent": 3,
      "text": "- Added MLD and router renumbering definitions.",
      "ja": " -  MLDルータリナンバリングの定義を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Added MTU-related socket options and ancillary data items.",
      "ja": " - 追加されたMTU関連のソケットオプションと補助的なデータ項目。"
    },
    {
      "indent": 3,
      "text": "- Added options and ancillary data items to manipulate the traffic class field.",
      "ja": " - トラフィッククラスフィールドを操作するためのオプションと補助的なデータ項目を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Changed the name of ICMPv6 unreachable code 2 to be \"beyond scope of source address.\" ICMP6_DST_UNREACH_NOTNEIGHBOR was removed with this change.",
      "ja": " - であることがICMPv6の到達不能コード2の名前を変更し、「送信元アドレスの範囲を超えて。」 ICMP6_DST_UNREACH_NOTNEIGHBORは、この変更で除去しました。"
    },
    {
      "indent": 3,
      "text": "Clarifications:",
      "ja": "明確化："
    },
    {
      "indent": 3,
      "text": "- Added clarifications on extension headers ordering; for the sending side, assume the recommended ordering described in RFC 2460. For the receiving side, do not assume any ordering and pass all headers to the application in the received order.",
      "ja": " - 注文の拡張ヘッダーに追加されまし明確化。送信側では、受信側についてはRFC 2460に記載推奨順序を仮定し、任意の順序を想定し、受信したために、アプリケーションにすべてのヘッダを通過しません。"
    },
    {
      "indent": 3,
      "text": "- Added a summary about the interface selection rule.",
      "ja": " - インタフェースの選択ルールについての概要を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Clarified the ordering between IPV6_MULTICAST_IF and the IPV6_PKTINFO sticky option for multicast packets.",
      "ja": " -  IPV6_MULTICAST_IFおよびマルチキャストパケットのIPV6_PKTINFO stickyオプション間の順序を明らかにしました。"
    },
    {
      "indent": 3,
      "text": "- Clarified how sticky options and the ICMPv6 filter are turned off and that getsockopt() of a sticky option returns what was set with setsockopt().",
      "ja": " - オフになっているか、粘着性のオプションとのICMPv6フィルタ明確化とstickyオプションのgetsockoptのは、（）はsetsockoptで設定されたものを返します（）。"
    },
    {
      "indent": 3,
      "text": "- Clarified that IPV6_NEXTHOP should be ignored for a multicast destination, that it should not contradict with the specified outgoing interface, and that the next hop should be a sockaddr_in6 structure.",
      "ja": " -  IPV6_NEXTHOPは、指定発信インターフェイスと矛盾してはならないこと、及び次ホップがsockaddr_in6構造体であることを、マルチキャストの宛先では無視されるべきであることを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "- Clarified corner cases of IPV6_CHECKSUM.",
      "ja": " -  IPV6_CHECKSUMのコーナーケースを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "- Aligned with the POSIX standard.",
      "ja": " -  POSIX標準に整列されます。"
    },
    {
      "indent": 3,
      "text": "Editorial changes:",
      "ja": "編集上の変更："
    },
    {
      "indent": 3,
      "text": "- Replaced MUST with must (since this is an informational document).",
      "ja": " - 必須に置き換え必要があります（これは、情報提供文書であるため）。"
    },
    {
      "indent": 3,
      "text": "- Revised abstract to be more clear and concise, particularly concentrating on differences from RFC 2292.",
      "ja": " - 特にRFC 2292との相違点に集中し、より明確かつ簡潔であることが抽象改​​訂。"
    },
    {
      "indent": 3,
      "text": "- Made the URL of assigned numbers less specific so that it would be more robust for future changes.",
      "ja": " - それは将来の変更のために、より堅牢になるように割り当てられた番号のURLは以下の特定のメイド。"
    },
    {
      "indent": 3,
      "text": "- Updated the reference to the basic API.",
      "ja": " - 基本的なAPIへの参照を更新しました。"
    },
    {
      "indent": 3,
      "text": "- Added a reference to the latest POSIX standard.",
      "ja": " - 最新のPOSIX標準への参照を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Moved general specifications of ancillary data and CMSG macros to the appendix.",
      "ja": " - 付録を補助データとCMSGマクロの一般的な仕様を移動しました。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC-1981] McCann, J., Deering, S. and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC-1981]マッキャン、J.、デアリング、S.とJ.ムガール人、 \"パスMTUディスカバリIPバージョン6のために\"、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC-2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC-3493] Gilligan, R., Thomson, S., Bound, J., McCann, J. and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, March 2003.",
      "ja": "[RFC-3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.とW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 3493、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[POSIX] IEEE Std. 1003.1-2001 Standard for Information Technology -- Portable Operating System Interface (POSIX). Open group Technical Standard: Base Specifications, Issue 6, December 2001. ISO/IEC 9945:2002. http://www.opengroup.org/austin",
      "ja": "[POSIX] IEEE STD。 1003.1-2001規格情報技術 - ポータブルオペレーティングシステムインタフェース（POSIX）。オープングループ技術標準：基本仕様、6号、2001年12月ISO / IEC 9945：2002。 http://www.opengroup.org/austin"
    },
    {
      "indent": 3,
      "text": "[TCPIPILLUST] Wright, G., Stevens, W., \"TCP/IP Illustrated, Volume 2: The Implementation\", Addison Wesley, 1994.",
      "ja": "[TCPIPILLUST]ライト、G.、スティーブンス、W.、 \"TCP / IPイラスト、2巻：インプリメンテーション\"、アディソンウェズリー、1994。"
    },
    {
      "indent": 0,
      "text": "19. Acknowledgments",
      "section_title": true,
      "ja": "19.謝辞"
    },
    {
      "indent": 3,
      "text": "Matt Thomas and Jim Bound have been working on the technical details in this document for over a year. Keith Sklower is the original implementor of ancillary data in the BSD networking code. Craig Metz provided lots of feedback, suggestions, and comments based on his implementing many of these features as the document was being written. Mark Andrews first proposed the idea of the IPV6_USE_MIN_MTU option. Jun-ichiro Hagino contributed text for the traffic class API from a document of his own.",
      "ja": "バウンドマット・トーマスとジムは年以上のために、この文書で技術的な詳細に取り組んできました。キースSklowerはBSDのネットワークコードにおける補助データの元の実装です。クレイグ・メッツは、文書が書かれていたとして、彼はこれらの機能の多くを実装するに基づいて、フィードバック、提案、コメントの多くを提供します。マーク・アンドリュースは、最初IPV6_USE_MIN_MTUオプションのアイデアを提案しました。 6月-イチロー萩野は彼自身の文書からのトラフィッククラスのAPIのテキストを拠出しました。"
    },
    {
      "indent": 3,
      "text": "The following provided comments on earlier drafts: Pascal Anelli, Hamid Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Don Coolidge, Matt Crawford, Sam T. Denton, Richard Draves, Francis Dupont, Toerless Eckert, Lilian Fernandes, Bob Gilligan, Gerri Harter, Tim Hartrick, Bob Halley, Masaki Hirabaru, Michael Hunter, Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov, Sam Manthorpe, Pedro Marques, Jack McCann, der Mouse, John Moy, Lori Napoli, Thomas Narten, Atsushi Onoe, Steve Parker, Charles Perkins, Ken Powell, Tom Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P. Spackman, Jinmei Tatuya, Karen Tracey, Sowmini Varadhan, Quaizar Vohra, Carl Williams, Steve Wise, Eric Wong, Farrell Woods, Kazu Yamamoto, Vladislav Yasevich, and Yoshifuji Hideaki.",
      "ja": "以前のドラフトで次の提供のコメント：パスカルAnelli、ハミドAsayeshは、アトキンソン、カール・アウエルバッハ、ハミドAsayesh、ドン・クーリッジ、マット・クロフォード、サム・T.デントン、リチャードDraves、フランシスデュポン、Toerlessエッカート、リリアン・フェルナンデス、ボブギリガン、Gerri蘭ハーター、ティムHartrick、ボブハレー、正樹平原、マイケル・ハンター、慶喜井上、ムケシュKacker、ANクズネツォフ、サムManthorpe、ペドロ・マルケス、ジャック・マッキャン、デア・マウス、ジョン・モイ、ロリナポリ、トーマスNarten氏、敦尾上、スティーブ・パーカー、チャールズ・パーキンス、ケン・パウエル、トムPusateri、ペドロ・ローク、サミール・シャー、ピーターSjodin、スティーブンP. Spackman、神明達也、カレン・トレイシー、Sowmini Varadhan、Quaizar Vohra著、カール・ウィリアムズ、スティーブ・ワイズ、エリック・ウォン、ファレル・ウッズ、カズ山本、ウラジスラフYasevich、およびYoshifuji英明。"
    },
    {
      "indent": 0,
      "text": "20. : Ancillary Data Overview",
      "section_title": true,
      "ja": "20.：補助データの概要"
    },
    {
      "indent": 3,
      "text": "4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions. Two members of the msghdr structure, msg_accrights and msg_accrightslen, were used to send and receive the descriptors. When the OSI protocols were added to 4.3BSD Reno in 1990 the names of these two fields in the msghdr structure were changed to msg_control and msg_controllen, because they were used by the OSI protocols for \"control information\", although the comments in the source code call this \"ancillary data\".",
      "ja": "4.2BSDは、ファイル記述子がにsendmsg（）とのrecvmsg（）関数を使用して、UNIXドメインソケットを横切って別のプロセスとの間で転送することができました。 msghdr構造体の2人のメンバー、msg_accrightsとmsg_accrightslenは、ディスクリプタを送受信するために使用されました。 OSIプロトコルは、1990年に4.3BSDレノに添加したときに、ソースコード内のコメントが、それらは、「制御情報」のOSIプロトコルによって使用されたので、msghdr構造体におけるこれら二つのフィールドの名前は、msg_controlおよびmsg_controllenに変更しましたこの「補助データ」と呼びます。"
    },
    {
      "indent": 3,
      "text": "Other than the OSI protocols, the use of ancillary data has been rare. In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP_RECVDSTADDR socket option is set. With Unix domain sockets ancillary data is still used to send and receive descriptors.",
      "ja": "OSIプロトコル以外に、補助的なデータの使用は稀となっています。 4.4BSDでは、例えば、IPv4のと補助データの使用のみがIP_RECVDSTADDRソケットオプションが設定されている場合、受信したUDPデータグラムの宛先アドレスを返すことです。 Unixドメインソケットで補助データはまだ記述子を送受信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written. The inclusion of the msg_control and msg_controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg_control member is required by the Posix sockets API standard.",
      "ja": "それでもmsghdr構造体の補助的なデータフィールドは、読み取りまたは書き込みが行われているデータの他に情報を渡すためにクリーンな方法を提供します。 msg_control部材はPosixのソケットAPI規格によって必要とされることによって指されるcmsghdr構造体と共にmsg_controlとmsghdr構造体のmsg_controllenメンバーを含めます。"
    },
    {
      "indent": 0,
      "text": "20.1. The msghdr Structure",
      "section_title": true,
      "ja": "20.1。 msghdr構造体"
    },
    {
      "indent": 3,
      "text": "The msghdr structure is used by the recvmsg() and sendmsg() functions. Its Posix definition is:",
      "ja": "msghdr構造体は、のrecvmsg（）とsendmsgの（）関数によって使用されます。そのPosixの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct msghdr {\n  void      *msg_name;        /* ptr to socket address\n                                 structure */\n  socklen_t  msg_namelen;     /* size of socket address\n                                 structure */\n  struct iovec  *msg_iov;     /* scatter/gather array */\n  int        msg_iovlen;      /* # elements in msg_iov */\n  void      *msg_control;     /* ancillary data */\n  socklen_t  msg_controllen;  /* ancillary data buffer length */\n  int        msg_flags;       /* flags on received message */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The structure is declared as a result of including <sys/socket.h>.",
      "ja": "構造体は<sysの/ socket.h>に含めた結果として宣言されています。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix the two \"void *\" pointers were typically \"char *\", and the two socklen_t members were typically integers. Earlier drafts of Posix had the two socklen_t members as size_t, but it then changed these to socklen_t to simplify binary portability for 64-bit implementations and to align Posix with X/Open's Networking Services, Issue 5. The change in msg_control to a \"void *\" pointer affects any code that increments this pointer.)",
      "ja": "（注意：POSIXの前に二つの「void *型」のポインタは、典型的には、「char型*」だった、と2人のsocklen_tメンバーは通常、整数だったのPosixの以前のドラフトは、size_tのように2人のsocklen_tメンバーを持っていたが、それはバイナリ簡素化するためのsocklen_tするには、これらを変更しました。 X / OpenのネットワークサービスとのPosixを位置合わせする64ビット実装のポータビリティと、「ボイド*」ポインタにmsg_controlの変化5.発行し、このポインタをインクリメントするコードに影響を与えます。）"
    },
    {
      "indent": 3,
      "text": "Most Berkeley-derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf). This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO_SNDBUF socket option). (Note: This magic number 10240 was picked as a value that should always be large enough. 108 bytes is clearly too small as the maximum size of a Routing header is 2048 bytes.)",
      "ja": "最もバークレー由来の実装では、これ以上108バイト以内（MBUF）まで）（SENDMSG呼び出しにおける補助データの量を制限します。このAPIは、補助データの10240バイトの最小値を必要とするが、量が（SO_SNDBUFソケットオプションによって変更することができる）ソケットによって予約バッファ空間によってのみ制限されることが推奨されます。 （注：このマジックナンバー10240は、常に十分に大きくなければならない値として選ばれた108のバイトは、ルーティングヘッダの最大サイズは2048バイトであるとして明らかに小さすぎます。）。"
    },
    {
      "indent": 0,
      "text": "20.2. The cmsghdr Structure",
      "section_title": true,
      "ja": "20.2。 cmsghdr構造体"
    },
    {
      "indent": 3,
      "text": "The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg(). Its Posix definition is:",
      "ja": "cmsghdr構造体は、補助データのrecvmsgによって転送オブジェクト（）とsendmsgのを記述する（）。そのPosixの定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr {\n  socklen_t  cmsg_len;   /* #bytes, including this header */\n  int        cmsg_level; /* originating protocol */\n  int        cmsg_type;  /* protocol-specific type */\n             /* followed by unsigned char cmsg_data[]; */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This structure is declared as a result of including <sys/socket.h>.",
      "ja": "この構造体は、<sysの/ socket.h>に含めた結果として宣言されています。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix the cmsg_len member was an integer, and not a socklen_t. See the Note in the previous section for why socklen_t is used here.)",
      "ja": "（注意：POSIXはCMSG_LENメンバーは、整数、およびないのsocklen_tた前のsocklen_tがここで使用されている理由については、前のセクションでノートを参照してください。）"
    },
    {
      "indent": 3,
      "text": "As shown in this definition, normally there is no member with the name cmsg_data[]. Instead, the data portion is accessed using the CMSG_xxx() macros, as described in Section 20.3. Nevertheless, it is common to refer to the cmsg_data[] member.",
      "ja": "この定義に示されているように、通常は[] CMSG_DATA名前のメンバが存在しません。セクション20.3で説明したように代わり、データ部は、CMSG_xxx（）マクロを使用してアクセスされます。それにもかかわらず、CMSG_DATA []メンバーを参照するのが一般的です。"
    },
    {
      "indent": 3,
      "text": "When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg_control and msg_controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object's length (the cmsg_len member). Historically Berkeley-derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg(). The following example shows two ancillary data objects in a control buffer.",
      "ja": "補助データが送信または受信されたときに、各オブジェクトは、オブジェクトの長さを画定するcmsghdr構造体（CMSG_LEN部材​​）が先行しているため、補助データオブジェクトの任意の数は、msg_controlとmsghdr構造体のmsg_controllenメンバーで指定することができます。歴史的にはバークレー由来の実装は、一度に1つのオブジェクトに合格したが、このAPIは、複数のオブジェクトが（SENDMSGする単一の呼び出しに渡されることを可能にする）またはのrecvmsg（）。次の例では、制御バッファ内の2つの補助的なデータオブジェクトを示しています。"
    },
    {
      "indent": 0,
      "text": "|<--------------------------- msg_controllen ------------------------->|\n|                                 OR                                   |\n|<--------------------------- msg_controllen ---------------------->|\n|                                                                      |\n|<----- ancillary data object ----->|<---- ancillary data object ----->|\n|<------ min CMSG_SPACE() --------->|<----- min CMSG_SPACE() --------->|\n|                                   |                                  |\n|<---------- cmsg_len ---------->|  |<-------- cmsg_len ----------->|  |\n|<--------- CMSG_LEN() --------->|  |<------- CMSG_LEN() ---------->|  |\n|                                |  |                               |  |\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+\n|cmsg_|cmsg_|cmsg_|XX|   cmsg_   |XX|cmsg_|cmsg_|cmsg_|XX|  cmsg_   |XX|\n|len  |level|type |XX|   data[]  |XX|len  |level|type |XX|  data[]  |XX|\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+----------+--+\n^\n|\nmsg_control\npoints here",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields shown as \"XX\" are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation. While sending an application may or may not include padding at the end of last ancillary data in msg_controllen and implementations must accept both as valid. On receiving a portable application must provide space for padding at the end of the last ancillary data as implementations may copy out the padding at the end of the control message buffer and include it in the received msg_controllen. When recvmsg() is called if msg_controllen is too small for all the ancillary data items including any trailing padding after the last item an implementation may set MSG_CTRUNC.",
      "ja": "実装によって必要とされる場合は、「XX」として表示されるフィールドは、cmsghdr構造体との間でデータ、及びデータと次のcmsghdr構造体との間に、可能パディングです。アプリケーションを送信している間は、またはmsg_controllenの最後の補助データの終わりにパディングを含んでも含まなくてもよいと実装が有効であるとの両方を受け入れなければなりません。実装は、制御メッセージバッファの終わりにパディングをコピーして、受信したmsg_controllenに含めることができるようにポータブルアプリケーションを受信すると、最後の補助データの終わりにパディングのための空間を提供しなければなりません。 recvmsg（）が呼び出されたときmsg_controllenは最後の項目後の任意の後続パディングを含むすべての補助的なデータ項目の小さすぎる実装はMSG_CTRUNCを設定してもよいです。"
    },
    {
      "indent": 0,
      "text": "20.3. Ancillary Data Object Macros",
      "section_title": true,
      "ja": "20.3。補助データオブジェクトのマクロ"
    },
    {
      "indent": 3,
      "text": "To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix: CMSG_DATA(), CMSG_NXTHDR(), and CMSG_FIRSTHDR(). Before describing these macros, we show the following example of how they might be used with a call to recvmsg().",
      "ja": "補助的なデータオブジェクトの操作を助けるために、4.4BSDからの3つのマクロは、POSIXで定義されています。CMSG_DATA（）、CMSG_NXTHDR（）、およびCMSG_FIRSTHDR（）。これらのマクロを説明する前に、我々は、彼らが（）をrecvmsgのための呼び出しで使用されるかもしれない方法の以下の例を示しています。"
    },
    {
      "indent": 6,
      "text": "struct msghdr   msg;\nstruct cmsghdr  *cmsgptr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill in msg */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* call recvmsg() */ for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n    if (cmsgptr->cmsg_len == 0) {\n        /* Error handling */\n     break;\n    }\n    if (cmsgptr->cmsg_level == ... &&\n        cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We now describe the three Posix macros, followed by two more that are new with this API: CMSG_SPACE() and CMSG_LEN(). All these macros are defined as a result of including <sys/socket.h>.",
      "ja": "CMSG_SPACE（）とCMSG_LEN（）：私たちは、今、このAPIで新しく追加された2以上続く3つのPosixのマクロを記述する。すべてのこれらのマクロは、<SYS / socket.h>に含めた結果として定義されています。"
    },
    {
      "indent": 0,
      "text": "20.3.1. CMSG_FIRSTHDR",
      "section_title": true,
      "ja": "20.3.1。 CMSG_FIRSTHDR"
    },
    {
      "indent": 6,
      "text": "struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *mhdr);",
      "ja": "構造体のcmsghdr * CMSG_FIRSTHDR（constの構造体のmsghdr * MHDR）。"
    },
    {
      "indent": 3,
      "text": "CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr. The macro returns NULL if there is no ancillary data pointed to by the msghdr structure (that is, if either msg_control is NULL or if msg_controllen is less than the size of a cmsghdr structure).",
      "ja": "CMSG_FIRSTHDR（）は、msghdr構造体の最初のcmsghdr構造体へのポインタは、MHDRによって指さ戻ります。 NULLマクロ戻るには補助データが存在しない場合msghdr構造体（いずれかmsg_controlがNULLであるかmsg_controllen場合はcmsghdr構造体のサイズよりも小さい場合には、である）によって指さ。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be",
      "ja": "1つの可能な実装は、可能性があり"
    },
    {
      "indent": 6,
      "text": "#define CMSG_FIRSTHDR(mhdr) \\ ( (mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \\ (struct cmsghdr *)(mhdr)->msg_control : \\ (struct cmsghdr *)NULL )",
      "ja": "#define CMSG_FIRSTHDR（MHDR）\\（（MHDR） - > msg_controllen> =はsizeof（構造体のcmsghdr）\\（構造体のcmsghdr *）（MHDR） - > msg_control：？\\（構造体のcmsghdr *）NULL）"
    },
    {
      "indent": 3,
      "text": "(Note: Most existing implementations do not test the value of msg_controllen, and just return the value of msg_control. The value of msg_controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg_control to point to the application's buffer and setting msg_controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg_controllen to 0 on return. It is also easier to put this test into this macro, than making the application perform the test.)",
      "ja": "（注：ほとんどの既存の実装がmsg_controllenの値をテストし、ちょうどmsg_controlの値を返しませんmsg_controllenの値をテストする必要があり、アプリケーションが指すようにmsg_controlを設定することにより、補助データを返すために（）のrecvmsgを要求した場合ので。アプリケーションのバッファと、このバッファの長さにmsg_controllenを設定するには、カーネルには補助データは、リターン時に0にmsg_controllenを設定することにより、利用できないことを示している。アプリケーションがテストを実行することよりも、このマクロにこのテストを置くことも簡単です。）"
    },
    {
      "indent": 0,
      "text": "20.3.2. CMSG_NXTHDR",
      "section_title": true,
      "ja": "20.3.2。 CMSG_NXTHDR"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.1, CMSG_NXTHDR has been extended to handle a NULL 2nd argument to mean \"get the first header\". This provides an alternative way of coding the processing loop shown earlier:",
      "ja": "5.1節で述べたように、CMSG_NXTHDRは、「最初のヘッダを取得する」を意味するNULL第2引数を処理するために拡張されました。これは、先に示した処理ループを符号化する別の方法を提供します。"
    },
    {
      "indent": 6,
      "text": "struct msghdr  msg;\nstruct cmsghdr  *cmsgptr = NULL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill in msg */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* call recvmsg() */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) != NULL) {\n    if (cmsgptr->cmsg_len == 0) {\n        /* Error handling */\n     break;\n    }\n    if (cmsgptr->cmsg_level == ... &&\n        cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_NXTHDR(mhdr, cmsg) \\ (((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \\ (((u_char *)(cmsg) + ALIGN_H((cmsg)->cmsg_len) \\ + ALIGN_D(sizeof(struct cmsghdr)) > \\ (u_char *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \\ (struct cmsghdr *)NULL : \\ (struct cmsghdr *)((u_char *)(cmsg) + \\ ALIGN_H((cmsg)->cmsg_len))))",
      "ja": "#define CMSG_NXTHDR（MHDR、CMSG）\\（（（CMSG）== NULL）CMSG_FIRSTHDR（MHDR）：？\\（（（u_char型*）（CMSG）+ ALIGN_H（（CMSG） - > CMSG_LEN）\\ + ALIGN_D（はsizeof（構造体のcmsghdr））> \\（u_char型*）（（MHDR） - > msg_control）+（MHDR） - > msg_controllen）\\（構造体のcmsghdr *）NULL：？\\（構造体のcmsghdr *）（（u_char型*）（CMSG）+ \\ ALIGN_H（（CMSG） - > CMSG_LEN））））"
    },
    {
      "indent": 3,
      "text": "The macros ALIGN_H() and ALIGN_D(), which are implementation dependent, round their arguments up to the next even multiple of whatever alignment is required for the start of the cmsghdr structure and the data, respectively. (This is probably a multiple of 4 or 8 bytes.) They are often the same macro in implementations platforms where alignment requirement for header and data is chosen to be identical.",
      "ja": "マクロALIGN_H（）とアライメントがそれぞれcmsghdr構造体とデータの開始のために必要とされているものの次の偶数倍までその引数の周りに、インプリメンテーション依存であるALIGN_D（）。 （これはおそらく4または8バイトの倍数である。）彼らはしばしば、ヘッダとデータの位置合わせ要件が同じになるように選択された実装プラットフォームに同じマクロです。"
    },
    {
      "indent": 0,
      "text": "20.3.3. CMSG_DATA",
      "section_title": true,
      "ja": "20.3.3。 CMSG_DATA"
    },
    {
      "indent": 6,
      "text": "unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);",
      "ja": "unsigned char型* CMSG_DATA（constの構造体のcmsghdr *のCMSG）。"
    },
    {
      "indent": 3,
      "text": "CMSG_DATA() returns a pointer to the data (what is called the cmsg_data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.",
      "ja": "CMSG_DATA（）は、cmsghdr構造体以下（例えば、部材が構造体で定義されていない場合でも、CMSG_DATA []メンバーと呼ばれるもの）データへのポインタを返します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \\ ALIGN_D(sizeof(struct cmsghdr)) )",
      "ja": "#define CMSG_DATA（CMSG）（（u_char型*）（CMSG）+ \\ ALIGN_D（はsizeof（構造体のcmsghdr）））"
    },
    {
      "indent": 0,
      "text": "20.3.4. CMSG_SPACE",
      "section_title": true,
      "ja": "20.3.4。 CMSG_SPACE"
    },
    {
      "indent": 3,
      "text": "CMSG_SPACE is new with this API (see Section 5.2). It is used to determine how much space needs to be allocated for an ancillary data item.",
      "ja": "CMSG_SPACEは、このAPIで新しく追加されました（5.2節を参照してください）。補助的なデータ項目に割り当てる必要がどのくらいのスペースを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_SPACE(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \\ ALIGN_H(length) )",
      "ja": "#define CMSG_SPACE（長さ）（ALIGN_D（のsizeof（構造体のcmsghdr））+ \\ ALIGN_H（長さ））"
    },
    {
      "indent": 0,
      "text": "20.3.5. CMSG_LEN",
      "section_title": true,
      "ja": "20.3.5。 CMSG_LEN"
    },
    {
      "indent": 3,
      "text": "CMSG_LEN is new with this API (see Section 5.3). It returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.",
      "ja": "CMSG_LENは、このAPIで新しく追加されました（5.3節を参照してください）。それは考慮に整列要件を満たすために必要な任意の詰め物を取って、cmsghdr構造体のCMSG_LENメンバーに格納する値を返します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 6,
      "text": "#define CMSG_LEN(length) ( ALIGN_D(sizeof(struct cmsghdr)) + \\ length )",
      "ja": "#define CMSG_LEN（長さ）（ALIGN_D（のsizeof（構造体のcmsghdr））+ \\長さ）"
    },
    {
      "indent": 0,
      "text": "21. : Examples Using the inet6_rth_XXX() Functions",
      "section_title": true,
      "ja": "21.：inet6_rth_XXX（）関数の使用例"
    },
    {
      "indent": 3,
      "text": "Here we show an example for both sending Routing headers and processing and reversing a received Routing header.",
      "ja": "ここでは、ルーティングヘッダと送信処理と、受信したルーティングヘッダを反転の両方のための例を示します。"
    },
    {
      "indent": 0,
      "text": "21.1. Sending a Routing Header",
      "section_title": true,
      "ja": "21.1。ルーティングヘッダを送信します"
    },
    {
      "indent": 3,
      "text": "As an example of these Routing header functions defined in this document, we go through the function calls for the example on p. 17 of [RFC-2460]. The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3.",
      "ja": "この文書で定義されたこれらのルーティングヘッダ機能の例として、我々は、p上の例えば、関数呼び出しを通過します。 [RFC-2460]の17。ソースがSであり、宛先がDであり、そして3つの中間ノードは、I1、I2、およびI3です。"
    },
    {
      "indent": 14,
      "text": "S -----> I1 -----> I2 -----> I3 -----> D",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "src: * S S S S S dst: D I1 I2 I3 D D A[1]: I1 I2 I1 I1 I1 I1 A[2]: I2 I3 I3 I2 I2 I2 A[3]: I3 D D D I3 I3 #seg: 3 3 2 1 0 3",
      "ja": "SRC：* S S S S S DST：D I1 I2 I3 D D A [1]：I1 I2 I1 I1 I1 I1 A [2]：I2 I3 I3 I2 I2 I2 A [3]：I3 D D D I3 I3の#seg：3 ​​3 2 1 0 3"
    },
    {
      "indent": 3,
      "text": "src and dst are the source and destination IPv6 addresses in the IPv6 header. A[1], A[2], and A[3] are the three addresses in the Routing header. #seg is the Segments Left field in the Routing header.",
      "ja": "SRCとDSTは、IPv6は、IPv6ヘッダのアドレス、送信元および宛先です。 [1]、A [2]、A [3]ルーティングヘッダ内に3つのアドレスです。 #segルーティングヘッダフィールドを左セグメントです。"
    },
    {
      "indent": 3,
      "text": "The six values in the column beneath node S are the values in the Routing header specified by the sending application using sendmsg() of setsockopt(). The function calls by the sender would look like:",
      "ja": "ノードSの下の列の6つの値は、（）をのsetsockoptのにsendmsg（）を使用して送信側アプリケーションによって指定されたルーティングヘッダ内の値です。機能は次のようになります。送信者によって呼び出されます："
    },
    {
      "indent": 6,
      "text": "void  *extptr;\nsocklen_t   extlen;\nstruct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nint   cmsglen;\nstruct sockaddr_in6  I1, I2, I3, D;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, 3);\ncmsglen = CMSG_SPACE(extlen);\ncmsgptr = malloc(cmsglen);\ncmsgptr->cmsg_len = CMSG_LEN(extlen);\ncmsgptr->cmsg_level = IPPROTO_IPV6;\ncmsgptr->cmsg_type = IPV6_RTHDR;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extptr = CMSG_DATA(cmsgptr);\nextptr = inet6_rth_init(extptr, extlen, IPV6_RTHDR_TYPE_0, 3);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "inet6_rth_add(extptr, &I1.sin6_addr);\ninet6_rth_add(extptr, &I2.sin6_addr);\ninet6_rth_add(extptr, &I3.sin6_addr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "msg.msg_control = cmsgptr;\nmsg.msg_controllen = cmsglen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* finish filling in msg{}, msg_name = D */\n/* call sendmsg() */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).",
      "ja": "我々はまた、ソケットの送信元アドレスが指定されていないことを前提とし（すなわち、図のアスタリスク）。"
    },
    {
      "indent": 3,
      "text": "The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes. Notice that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are \"shifted up\", and D is moved to A[3].",
      "ja": "パケットが2つのノード間の通過している間に、次に5つのノードの間に示されている6つの値の4つの列は、パケットのフィールドの値です。パケットがソースノードSによって送信される前に、送信元アドレスは、（アスタリスクを置換する）選択されていることを確認し、I1は、データグラムの宛先アドレスとなり、二つのアドレス[2]、A [3]が「シフトアップ」 、およびDは、[3]に移動されます。"
    },
    {
      "indent": 3,
      "text": "The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6_RECVPKTINFO and IPV6_RECVRTHDR socket options. The source address is S (contained in the sockaddr_in6 structure pointed to by the msg_name member), the destination address is D (returned as an ancillary data object in an in6_pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3). The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).",
      "ja": "宛先ノードの下に示されている値の列は、アプリケーションがIPV6_RECVPKTINFOとIPV6_RECVRTHDRソケットオプションの両方を有効にしていると仮定のrecvmsg（）によって返される値です。 S（sockaddr_in6構造体に含まれているが、はmsg_name部材によって指される）ソース・アドレスは、宛先アドレスがD（in6_pktinfo構造における補助データオブジェクトとして返される）である、ルーティングヘッダを指定する補助データオブジェクトは、3つのアドレスを含むことになります（I1、I2、及びI3）。ルーティングヘッダ内のセグメントの数は（3つのアドレスを示し、6の値）ルーティングヘッダにHDR拡張LENフィールドから知られています。"
    },
    {
      "indent": 3,
      "text": "The return value from inet6_rth_segments() will be 3 and inet6_rth_getaddr(0) will return I1, inet6_rth_getaddr(1) will return I2, and inet6_rth_getaddr(2) will return I3,",
      "ja": "inet6_rth_segmentsからの戻り値が（3）3及びinet6_rth_getaddr（0）、I1、inet6_rth_getaddr（1）I2を返し、inet6_rth_getaddr（2）I3が返される戻りますであろう"
    },
    {
      "indent": 3,
      "text": "If the receiving application then calls inet6_rth_reverse(), the order of the three addresses will become I3, I2, and I1.",
      "ja": "受信側アプリケーションは、その後、（）inet6_rth_reverseを呼び出した場合、3つのアドレスの順序はI3、I2、I1となります。"
    },
    {
      "indent": 3,
      "text": "We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process. If we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries, then the call to inet6_rth_space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8 + 3*16).",
      "ja": "また、ルーティングヘッダが送信プロセスによって構築されているような実装は、補助的なデータオブジェクトに格納かもしれないものを表示することができます。我々ははsizeof（構造体のcmsghdr）が4バイト境界の所望の配向を有する、12に等しい32ビットのアーキテクチャを想定した場合、コールはinet6_rth_space（3）68戻り：ルーティングのためのcmsghdr構造体のための12バイト、56のバイトヘッダ（8 + 3 * 16）。"
    },
    {
      "indent": 3,
      "text": "The call to inet6_rth_init() initializes the ancillary data object to contain a Type 0 Routing header:",
      "ja": "inet6_rth_init（）の呼び出しはタイプ0ルーティングヘッダを含むように補助データオブジェクトを初期化します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_len = 20 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_level = IPPROTO_IPV6 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_type = IPV6_RTHDR | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Next Header | Hdr Ext Len=6 | Routing Type=0| Seg Left=0 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | CMSG_LEN = 20 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_levelメンバ= IPPROTO_IPV6 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_type = IPV6_RTHDR | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |次のヘッダー| HDRのExtレン= 6 |ルーティングタイプ= 0 |ワンセグ左= 0 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |予約| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "The first call to inet6_rth_add() adds I1 to the list.",
      "ja": "inet6_rth_addする最初の呼び出しは（）リストにI1を追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_len = 36 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_level = IPPROTO_IPV6 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_type = IPV6_RTHDR | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Next Header | Hdr Ext Len=6 | Routing Type=0| Seg Left=1 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[1] = I1 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | CMSG_LEN = 36 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_levelメンバ= IPPROTO_IPV6 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_type = IPV6_RTHDR | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |次のヘッダー| HDRのExtレン= 6 |ルーティングタイプ= 0 |ワンセグ左= 1 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |予約| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[1] = I1 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENを16だけインクリメントされ、フィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "The next call to inet6_rth_add() adds I2 to the list.",
      "ja": "inet6_rth_addする次の呼び出しは（）リストにI2を追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_len = 52 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_level = IPPROTO_IPV6 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_type = IPV6_RTHDR | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Next Header | Hdr Ext Len=6 | Routing Type=0| Seg Left=2 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[1] = I1 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[2] = I2 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | CMSG_LEN = 52 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_levelメンバ= IPPROTO_IPV6 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_type = IPV6_RTHDR | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |次のヘッダー| HDRのExtレン= 6 |ルーティングタイプ= 0 |ワンセグ左= 2 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |予約| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[1] = I1 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[2] = I2 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENを16だけインクリメントされ、フィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "The last call to inet6_rth_add() adds I3 to the list.",
      "ja": "（inet6_rth_addへの最後の呼び出し）リストにI3を追加します。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_len = 68 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_level = IPPROTO_IPV6 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | cmsg_type = IPV6_RTHDR | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Next Header | Hdr Ext Len=6 | Routing Type=0| Seg Left=3 | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reserved | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[1] = I1 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[2] = I2 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | + + | | + Address[3] = I3 + | | + + | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "ja": "+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | CMSG_LEN = 68 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_levelメンバ= IPPROTO_IPV6 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | cmsg_type = IPV6_RTHDR | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |次のヘッダー| HDRのExtレン= 6 |ルーティングタイプ= 0 |ワンセグ左= 3 | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + |予約| +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[1] = I1 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[2] = I2 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  + | | + + | | +アドレス[3] = I3 + | | + + | | +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +"
    },
    {
      "indent": 3,
      "text": "cmsg_len is incremented by 16, and the Segments Left field is incremented by 1.",
      "ja": "CMSG_LENを16だけインクリメントされ、フィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 0,
      "text": "21.2. Receiving Routing Headers",
      "section_title": true,
      "ja": "21.2。ルーティングヘッダを受け取ります"
    },
    {
      "indent": 3,
      "text": "This example assumes that the application has enabled IPV6_RECVRTHDR socket option. The application prints and reverses a source route and uses that to echo the received data.",
      "ja": "この例では、アプリケーションがIPV6_RECVRTHDRソケットオプションを有効にしていることを前提としています。アプリケーション印刷とソースルートを反転し、受信したデータをエコーするためにそれを使用します。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_in6     addr;\nstruct msghdr           msg;\nstruct iovec            iov;\nstruct cmsghdr          *cmsgptr;\nsocklen_t               cmsgspace;\nvoid                    *extptr;\nint                     extlen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int                     segments;\nint                     i;\nchar                    databuf[8192];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "segments = 100;        /* Enough */\nextlen = inet6_rth_space(IPV6_RTHDR_TYPE_0, segments);\ncmsgspace = CMSG_SPACE(extlen);\ncmsgptr = malloc(cmsgspace);\nif (cmsgptr == NULL) {\n        perror(\"malloc\");\n        exit(1);\n}\nextptr = CMSG_DATA(cmsgptr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "msg.msg_control = cmsgptr;\nmsg.msg_controllen = cmsgspace;\nmsg.msg_name = (struct sockaddr *)&addr;\nmsg.msg_namelen = sizeof (addr);\nmsg.msg_iov = &iov;\nmsg.msg_iovlen = 1;\niov.iov_base = databuf;\niov.iov_len = sizeof (databuf);\nmsg.msg_flags = 0;\nif (recvmsg(s, &msg, 0) == -1) {\n        perror(\"recvmsg\");\n        return;\n}\nif (msg.msg_controllen != 0 &&\n    cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n    cmsgptr->cmsg_type == IPV6_RTHDR) {\n        struct in6_addr *in6;\n        char asciiname[INET6_ADDRSTRLEN];\n        struct ip6_rthdr *rthdr;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        rthdr = (struct ip6_rthdr *)extptr;\n        segments = inet6_rth_segments(extptr);\n        printf(\"route (%d segments, %d left): \",\n            segments, rthdr->ip6r_segleft);\n        for (i = 0; i < segments; i++) {\n                in6 = inet6_rth_getaddr(extptr, i); if (in6 == NULL)\n                        printf(\"<NULL> \");\n                else\n                        printf(\"%s \", inet_ntop(AF_INET6,\n                            (void *)in6->s6_addr,\n                            asciiname, INET6_ADDRSTRLEN));\n        }\n        if (inet6_rth_reverse(extptr, extptr) == -1) {\n                printf(\"reverse failed\");\n                return;\n        }\n}\niov.iov_base = databuf;\niov.iov_len = strlen(databuf);\nif (sendmsg(s, &msg, 0) == -1)\n        perror(\"sendmsg\");\nif (cmsgptr != NULL)\n        free(cmsgptr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: The above example is a simple illustration. It skips some error checks, including those involving the MSG_TRUNC and MSG_CTRUNC flags. It also leaves some type mismatches in favor of brevity.",
      "ja": "注：上記の例は単純な図です。それはMSG_TRUNCとMSG_CTRUNCフラグに関連したものを含む、いくつかのエラーチェックをスキップします。また、簡潔に有利ないくつかの型の不一致を残します。"
    },
    {
      "indent": 0,
      "text": "22. : Examples Using the inet6_opt_XXX() Functions",
      "section_title": true,
      "ja": "22.：inet6_opt_XXX（）関数の使用例"
    },
    {
      "indent": 3,
      "text": "This shows how Hop-by-Hop and Destination options can be both built as well as parsed using the inet6_opt_XXX() functions. These examples assume that there are defined values for OPT_X and OPT_Y.",
      "ja": "これは、ホップバイホップおよび宛先オプションは、両方の組み込みならびにinet6_opt_XXX（）関数を使用して解析することができる方法を示しています。これらの例は、OPT_XとOPT_Yのための定義された値があることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Note: The example is a simple illustration. It skips some error checks and leaves some type mismatches in favor of brevity.",
      "ja": "注：例は、単純な図です。これは、いくつかのエラーチェックをスキップして簡潔に有利ないくつかの型の不一致を残します。"
    },
    {
      "indent": 0,
      "text": "22.1. Building Options",
      "section_title": true,
      "ja": "22.1。建物のオプション"
    },
    {
      "indent": 3,
      "text": "We now provide an example that builds two Hop-by-Hop options using the example in Appendix B of [RFC-2460].",
      "ja": "現在、[RFC-2460]の付録Bの例を使用して、2つのホップバイホップオプションを構築する例を提供します。"
    },
    {
      "indent": 6,
      "text": "void *extbuf;\nsocklen_t extlen;\nint currentlen;\nvoid *databuf;\nint offset;\nuint8_t value1;\nuint16_t value2;\nuint32_t value4;\nuint64_t value8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Estimate the length */ currentlen = inet6_opt_init(NULL, 0);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_append(NULL, 0, currentlen, OPT_X,\n                              12, 8, NULL);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_append(NULL, 0, currentlen, OPT_Y,\n                              7, 4, NULL);\nif (currentlen == -1)\n        return (-1);\ncurrentlen = inet6_opt_finish(NULL, 0, currentlen);\nif (currentlen == -1)\n        return (-1);\nextlen = currentlen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "extbuf = malloc(extlen);\nif (extbuf == NULL) {\n        perror(\"malloc\");\n        return (-1);\n}\ncurrentlen = inet6_opt_init(extbuf, extlen);\nif (currentlen == -1)\n        return (-1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_append(extbuf, extlen, currentlen,\n    OPT_X, 12, 8, &databuf);\nif (currentlen == -1)\n        return (-1);\n/* Insert value 0x12345678 for 4-octet field */\noffset = 0;\nvalue4 = 0x12345678;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value4, sizeof (value4));\n/* Insert value 0x0102030405060708 for 8-octet field */\nvalue8 = 0x0102030405060708;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value8, sizeof (value8));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_append(extbuf, extlen, currentlen,\n    OPT_Y, 7, 4, &databuf);\nif (currentlen == -1)\n        return (-1);\n/* Insert value 0x01 for 1-octet field */\noffset = 0;\nvalue1 = 0x01;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value1, sizeof (value1));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Insert value 0x1331 for 2-octet field */\nvalue2 = 0x1331;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value2, sizeof (value2));\n/* Insert value 0x01020304 for 4-octet field */\nvalue4 = 0x01020304;\noffset = inet6_opt_set_val(databuf, offset,\n                           &value4, sizeof (value4));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "currentlen = inet6_opt_finish(extbuf, extlen, currentlen);\nif (currentlen == -1)\n        return (-1);\n/* extbuf and extlen are now completely formatted */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "22.2. Parsing Received Options",
      "section_title": true,
      "ja": "22.2。受信オプションの解析"
    },
    {
      "indent": 3,
      "text": "This example parses and prints the content of the two options in the previous example.",
      "ja": "この例では、解析し、前の例の2つのオプションの内容を印刷します。"
    },
    {
      "indent": 6,
      "text": "int\nprint_opt(void *extbuf, socklen_t extlen)\n{\n        struct ip6_dest *ext;\n        int currentlen;\n        uint8_t type;\n        socklen_t len;\n        void *databuf;\n        int offset;\n        uint8_t value1;\n        uint16_t value2;\n        uint32_t value4;\n        uint64_t value8;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "ext = (struct ip6_dest *)extbuf;\nprintf(\"nxt %u, len %u (bytes %d)\\n\", ext->ip6d_nxt,\n    ext->ip6d_len, (ext->ip6d_len + 1) * 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "currentlen = 0;\nwhile (1) {\n        currentlen = inet6_opt_next(extbuf, extlen,\n                                    currentlen, &type,\n                                    &len, &databuf);\n        if (currentlen == -1)\n                break;\n        printf(\"Received opt %u len %u\\n\",\n            type, len);\n        switch (type) {\n        case OPT_X:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "                        offset = 0;\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value4,\n                                              sizeof (value4));\n                        printf(\"X 4-byte field %x\\n\", value4);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value8,\n                                              sizeof (value8));\n                        printf(\"X 8-byte field %llx\\n\", value8);\n                        break;\n                case OPT_Y:\n                        offset = 0;\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value1,\n                                              sizeof (value1));\n                        printf(\"Y 1-byte field %x\\n\", value1);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value2,\n                                              sizeof (value2));\n                        printf(\"Y 2-byte field %x\\n\", value2);\n                        offset =\n                            inet6_opt_get_val(databuf, offset,\n                                              &value4,\n                                              sizeof (value4));\n                        printf(\"Y 4-byte field %x\\n\", value4);\n                        break;\n                default:\n                        printf(\"Unknown option %u\\n\", type);\n                        break;\n                }\n        }\n        return (0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "23. Authors' Addresses",
      "section_title": true,
      "ja": "23.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "W. Richard Stevens (deceased)",
      "ja": "W.リチャードスティーヴンス（故人）"
    },
    {
      "indent": 3,
      "text": "Matt Thomas 3am Software Foundry 8053 Park Villa Circle Cupertino, CA 95014",
      "ja": "マット・トーマス午前3時ソフトウェアファウンドリー8053パークヴィラサークルクパチーノ、CA 95014"
    },
    {
      "indent": 3,
      "text": "EMail: matt@3am-software.com",
      "ja": "メールアドレス：matt@3am-software.com"
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems Laboratories, Europe 180, avenue de l'Europe 38334 SAINT ISMIER Cedex, France",
      "ja": "エリックNordmarkとSun Microsystemsの研究所、ヨーロッパ180、大通りドゥヨーロッパ38334 SAINT ISMIERセデックス、フランス"
    },
    {
      "indent": 3,
      "text": "Phone: +33 (0)4 74 18 88 03 Fax: +33 (0)4 76 18 88 88 EMail: Erik.Nordmark@sun.com",
      "ja": "電話：+33（0）4 74 18 88 03ファックス：+33（0）4 76 18 88 88 Eメール：Erik.Nordmark@sun.com"
    },
    {
      "indent": 3,
      "text": "Tatuya JINMEI Corporate Research & Development Center, Toshiba Corporation 1 Komukai Toshiba-cho, Kawasaki-shi Kanagawa 212-8582, Japan",
      "ja": "たつや じんめい こｒぽらて れせあｒｃｈ ＆ でゔぇぉｐめんｔ せんてｒ、 としば こｒぽらちおん １ こむかい としばーちょ、 かわさきーし かながわ ２１２ー８５８２、 じゃぱん"
    },
    {
      "indent": 3,
      "text": "EMail: jinmei@isl.rdc.toshiba.co.jp",
      "ja": "メールアドレス：jinmei@isl.rdc.toshiba.co.jp"
    },
    {
      "indent": 0,
      "text": "24. Full Copyright Statement",
      "section_title": true,
      "ja": "24.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}