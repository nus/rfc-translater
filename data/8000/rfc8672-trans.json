{
  "title": {
    "text": "RFC 8672 - TLS Server Identity Pinning with Tickets",
    "ja": "RFC 8672 - チケットを使用したTLSサーバーIDの固定"
  },
  "number": 8672,
  "created_at": "2020-03-10 11:33:05.059117+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                        Y. Sheffer\nRequest for Comments: 8672                                        Intuit\nCategory: Experimental                                        D. Migault\nISSN: 2070-1721                                                 Ericsson\n                                                            October 2019",
      "raw": true
    },
    {
      "indent": 16,
      "text": "TLS Server Identity Pinning with Tickets",
      "ja": "チケットを使用したTLSサーバーIDの固定"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Misissued public-key certificates can prevent TLS clients from appropriately authenticating the TLS server. Several alternatives have been proposed to detect this situation and prevent a client from establishing a TLS session with a TLS end point authenticated with an illegitimate public-key certificate. These mechanisms are either not widely deployed or limited to public web browsing.",
      "ja": "公開鍵証明書を誤って発行すると、TLSクライアントがTLSサーバーを適切に認証できなくなる可能性があります。 この状況を検出し、クライアントが不正な公開鍵証明書で認証されたTLSエンドポイントとのTLSセッションを確立するのを防ぐために、いくつかの代替案が提案されています。 これらのメカニズムは、広く展開されていないか、パブリックWebブラウジングに限定されています。"
    },
    {
      "indent": 3,
      "text": "This document proposes experimental extensions to TLS with opaque pinning tickets as a way to pin the server's identity. During an initial TLS session, the server provides an original encrypted pinning ticket. In subsequent TLS session establishment, upon receipt of the pinning ticket, the server proves its ability to decrypt the pinning ticket and thus the ownership of the pinning protection key. The client can now safely conclude that the TLS session is established with the same TLS server as the original TLS session. One of the important properties of this proposal is that no manual management actions are required.",
      "ja": "このドキュメントでは、サーバーのIDを固定する方法として、不透明な固定チケットを使用したTLSの実験的な拡張を提案しています。 最初のTLSセッション中に、サーバーは元の暗号化された固定チケットを提供します。 後続のTLSセッションの確立では、サーバーは、ピニングチケットを受信すると、ピニングチケットを復号化する能力を証明し、したがって、ピニング保護キーの所有権を証明します。 これで、クライアントは、元のTLSセッションと同じTLSサーバーでTLSセッションが確立されたと安全に結論付けることができます。 この提案の重要な特性の1つは、手動の管理アクションが不要であることです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 調査、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義しています。 これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。 RFCエディターは、このドキュメントをその裁量で公開することを選択しており、実装または展開の価値については何も表明していません。 RFC Editorによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補でもありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8672.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8672で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 1.1. Conventions Used in This Document 1.2. Scope of Experimentation 2. Protocol Overview 2.1. Initial Connection 2.2. Subsequent Connections 2.3. Indexing the Pins 3. Message Definitions 4. Cryptographic Operations 4.1. Pinning Secret 4.2. Pinning Ticket 4.3. Pinning Protection Key 4.4. Pinning Proof 5. Operational Considerations 5.1. Protection Key Synchronization 5.2. Ticket Lifetime 5.3. Certificate Renewal 5.4. Certificate Revocation 5.5. Disabling Pinning 5.6. Server Compromise 5.7. Disaster Recovery 6. Security Considerations 6.1. Trust-on-First-Use (TOFU) and MITM Attacks 6.2. Pervasive Monitoring 6.3. Server-Side Error Detection 6.4. Client Policy and SSL Proxies 6.5. Client-Side Error Behavior 6.6. Stolen and Forged Tickets 6.7. Client Privacy 6.8. Ticket Protection Key Management 7. IANA Considerations 8. References 8.1. Normative References 8.2. Informative References Appendix A. Previous Work A.1. Comparison: HPKP A.2. Comparison: TACK Acknowledgments Authors' Addresses",
      "ja": "1. はじめに1.1。このドキュメントで使用される規則1.2。実験の範囲2.プロトコルの概要2.1。初期接続2.2。後続の接続2.3。ピンのインデックス付け3.メッセージ定義4.暗号操作4.1。秘密の固定4.2。チケットの固定4.3。保護キーの固定4.4。証明の固定5.操作上の考慮事項5.1。保護キーの同期5.2。チケットの有効期間5.3。証明書の更新5.4。証明書失効5.5。ピン止めの無効化5.6。サーバー侵害5.7。災害復旧6.セキュリティに関する考慮事項6.1。 Trust-on-First-Use（TOFU）およびMITM攻撃6.2。広範な監視6.3。サーバー側のエラー検出6.4。クライアントポリシーとSSLプロキシ6.5。クライアント側のエラー動作6.6。盗まれたチケットと偽造されたチケット6.7。クライアントのプライバシー6.8。チケット保護キー管理7. IANAの考慮事項8.参照8.1。規範的な参考資料8.2。参考情報付録A.前の作業A.1。比較：HPKP A.2。比較：TACK謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Misissued public-key certificates can prevent TLS [RFC8446] clients from appropriately authenticating the TLS server. This is a significant risk in the context of the global public key infrastructure (PKI), and similarly for large-scale deployments of certificates within enterprises.",
      "ja": "公開鍵証明書を誤って発行すると、TLS [RFC8446]クライアントがTLSサーバーを適切に認証できなくなる可能性があります。 これは、グローバル公開キーインフラストラクチャ（PKI）のコンテキストでは、また企業内での証明書の大規模な展開でも同様の重大なリスクです。"
    },
    {
      "indent": 3,
      "text": "This document proposes experimental extensions to TLS with opaque pinning tickets as a way to pin the server's identity. The approach is intended to be easy to implement and deploy, and reuses some of the ideas behind TLS session resumption [RFC5077].",
      "ja": "このドキュメントでは、サーバーのIDを固定する方法として、不透明な固定チケットを使用したTLSの実験的な拡張を提案しています。 このアプローチは、実装と展開が簡単になることを目的としており、TLSセッション再開[RFC5077]の背後にあるいくつかのアイデアを再利用します。"
    },
    {
      "indent": 3,
      "text": "Ticket pinning is a second-factor server authentication method and is not proposed as a substitute for the authentication method provided in the TLS key exchange. More specifically, the client only uses the pinning identity method after the TLS key exchange is successfully completed. In other words, the pinning identity method is only performed over an authenticated TLS session. Note that ticket pinning does not pin certificate information and therefore is truly an independent second-factor authentication.",
      "ja": "チケットのピン留めは二要素認証方式であり、TLSキー交換で提供される認証方法の代替として提案されていません。 より具体的には、クライアントは、TLSキー交換が正常に完了した後にのみ、固定ID方式を使用します。 言い換えると、固定ID方式は認証されたTLSセッションでのみ実行されます。 チケットのピン留めは証明書情報をピン留めしないため、真に独立した第2要素認証であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Ticket pinning is a trust-on-first-use (TOFU) mechanism, in that the first server authentication is only based on PKI certificate validation, but for any follow-on sessions, the client is further ensuring the server's identity based on the server's ability to decrypt the ticket, in addition to normal PKI certificate authentication.",
      "ja": "チケットのピン留めは、最初のサーバー認証がPKI証明書の検証のみに基づいているという点で、初回使用時の信頼（TOFU）メカニズムですが、後続のセッションでは、クライアントはサーバーのIDに基づいてサーバーのIDをさらに確認します 通常のPKI証明書認証に加えて、チケットを復号化する機能。"
    },
    {
      "indent": 3,
      "text": "During initial TLS session establishment, the client requests a pinning ticket from the server. Upon receiving the request the server generates a pinning secret that is expected to be unpredictable for peers other than the client or the server. In our case, the pinning secret is generated from parameters exchanged during the TLS key exchange, so client and server can generate it locally and independently. The server constructs the pinning ticket with the necessary information to retrieve the pinning secret. The server then encrypts the ticket and returns the pinning ticket to the client with an associated pinning lifetime.",
      "ja": "最初のTLSセッションの確立中に、クライアントはサーバーに固定チケットを要求します。 要求を受信すると、サーバーは、クライアントまたはサーバー以外のピアでは予測できないと予想されるピニングシークレットを生成します。 この場合、ピニングシークレットはTLSキー交換中に交換されたパラメーターから生成されるため、クライアントとサーバーはローカルで独立して生成できます。 サーバーは、ピニングシークレットを取得するために必要な情報を使用して、ピニングチケットを作成します。 次に、サーバーはチケットを暗号化し、関連付けられた固定ライフタイムとともに固定チケットをクライアントに返します。"
    },
    {
      "indent": 3,
      "text": "The pinning lifetime value indicates for how long the server promises to retain the server-side ticket-encryption key, which allows it to complete the protocol exchange correctly and prove its identity. The server commitment (and ticket lifetime) is typically on the order of weeks.",
      "ja": "固定ライフタイム値は、サーバーがサーバー側のチケット暗号化キーを保持することを約束する期間を示します。これにより、プロトコル交換を正しく完了し、その身元を証明できます。 サーバーのコミットメント（およびチケットの有効期間）は通常、数週間のオーダーです。"
    },
    {
      "indent": 3,
      "text": "Once the key exchange is completed, and the server is deemed authenticated, the client generates locally the pinning secret and caches the server's identifiers to index the pinning secret as well as the pinning ticket and its associated lifetime.",
      "ja": "キー交換が完了し、サーバーが認証されたと見なされると、クライアントはローカルでピンニングシークレットを生成し、サーバーの識別子をキャッシュして、ピンニングシークレットとピンニングチケットおよびその関連するライフタイムをインデックス化します。"
    },
    {
      "indent": 3,
      "text": "When the client reestablishes a new TLS session with the server, it sends the pinning ticket to the server. Upon receiving it, the server returns a proof of knowledge of the pinning secret. Once the key exchange is completed, and the server has been authenticated, the client checks the pinning proof returned by the server using the client's stored pinning secret. If the proof matches, the client can conclude that the server to which it is currently connecting is, in fact, the correct server.",
      "ja": "クライアントは、サーバーとの新しいTLSセッションを再確立すると、固定チケットをサーバーに送信します。 サーバーは、それを受け取ると、固定秘密の知識の証明を返します。 鍵交換が完了し、サーバーが認証されると、クライアントは、クライアントの保存されたピニングシークレットを使用して、サーバーから返されたピニング証明をチェックします。 証明が一致する場合、クライアントは、現在接続しているサーバーが実際には正しいサーバーであると結論付けることができます。"
    },
    {
      "indent": 3,
      "text": "This document only applies to TLS 1.3. We believe that the idea can also be retrofitted into earlier versions of the protocol, but this would require significant changes. One example is that TLS 1.2 [RFC5246] and earlier versions do not provide a generic facility of encrypted handshake extensions, such as is used here to transport the ticket.",
      "ja": "このドキュメントは、TLS 1.3にのみ適用されます。 このアイデアはプロトコルの以前のバージョンに後付けすることもできますが、これには大きな変更が必要です。 1つの例は、TLS 1.2 [RFC5246]以前のバージョンでは、ここでチケットの転送に使用されるような、暗号化されたハンドシェイク拡張機能の一般的な機能を提供しないことです。"
    },
    {
      "indent": 3,
      "text": "The main advantages of this protocol over earlier pinning solutions are the following:",
      "ja": "以前の固定ソリューションに対するこのプロトコルの主な利点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* The protocol is at the TLS level, and as a result is not restricted to HTTP at the application level.",
      "ja": "* プロトコルはTLSレベルであり、その結果、アプリケーションレベルでHTTPに制限されません。"
    },
    {
      "indent": 3,
      "text": "* The protocol is robust to changes in server IP address, certification authority (CA), and public key. The server is characterized by the ownership of the pinning protection key, which is never provided to the client. Server configuration parameters such as the CA and the public key may change without affecting the pinning ticket protocol.",
      "ja": "* このプロトコルは、サーバーのIPアドレス、証明機関（CA）、および公開キーの変更に対して堅牢です。 サーバーは、クライアントに提供されない固定保護キーの所有権によって特徴付けられます。 CAや公開キーなどのサーバー構成パラメーターは、固定チケットプロトコルに影響を与えることなく変更できます。"
    },
    {
      "indent": 3,
      "text": "* Once a single parameter is configured (the ticket's lifetime), operation is fully automated. The server administrator need not bother with the management of backup certificates or explicit pins.",
      "ja": "* 単一のパラメーターが設定されると（チケットの有効期間）、操作は完全に自動化されます。 サーバー管理者は、バックアップ証明書または明示的なピンの管理に煩わされる必要はありません。"
    },
    {
      "indent": 3,
      "text": "* For server clusters, we reuse the existing infrastructure [RFC5077] where it exists.",
      "ja": "* サーバークラスタの場合、既存のインフラストラクチャ[RFC5077]が存在する場所で再利用します。"
    },
    {
      "indent": 3,
      "text": "* Pinning errors, presumably resulting from man-in-the-middle (MITM) attacks, can be detected both by the client and the server. This allows for server-side detection of MITM attacks using large-scale analytics, and with no need to rely on clients to explicitly report the error.",
      "ja": "* おそらく中間者（MITM）攻撃に起因する固定エラーは、クライアントとサーバーの両方で検出できます。 これにより、大規模な分析を使用したMITM攻撃のサーバー側の検出が可能になり、クライアントに明示的にエラーを報告する必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "A note on terminology: unlike other solutions in this space, we do not do \"certificate pinning\" (or \"public key pinning\"), since the protocol is oblivious to the server's certificate. We prefer the term \"server identity pinning\" for this new solution. In our solution, the server proves its identity by generating a proof that it can read and decrypt an encrypted ticket. As a result, the identity proof relies on proof of ownership of the pinning protection key. However, this key is never exchanged with the client or known by it, and so cannot itself be pinned.",
      "ja": "用語に関する注意：このスペースの他のソリューションとは異なり、プロトコルはサーバーの証明書を無視するため、「証明書のピン留め」（または「公開キーのピン留め」）は行いません。 この新しいソリューションでは、「サーバーID固定」という用語を使用します。 このソリューションでは、サーバーは、暗号化されたチケットを読み取って解読できることを証明する証明書を生成することにより、その身元を証明します。 その結果、ID証明は、ピニング保護キーの所有権の証明に依存しています。 ただし、このキーはクライアントと交換または認識されることはないため、それ自体を固定することはできません。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Scope of Experimentation",
      "section_title": true,
      "ja": "1.2. 実験の範囲"
    },
    {
      "indent": 3,
      "text": "This document describes an experimental extension to the TLS protocol. This section defines constraints on this experiment and how it can yield useful information, potentially resulting in a standard.",
      "ja": "このドキュメントでは、TLSプロトコルの実験的な拡張について説明します。 このセクションでは、この実験の制約と、有用な情報を生成する方法を定義し、潜在的に標準をもたらします。"
    },
    {
      "indent": 3,
      "text": "The protocol is designed so that if the server does not support it, the client and server fall back to a normal TLS exchange, with the exception of a single PinningTicket extension being initially sent by the client. In addition, the protocol is designed only to strengthen the validation of the server's identity (\"second factor\"). As a result, implementation or even protocol errors should not result in weakened security compared to the normal TLS exchange. Given these two points, experimentation can be run on the open Internet between consenting client and server implementations.",
      "ja": "このプロトコルは、サーバーがサポートしていない場合、クライアントとサーバーが通常のTLS交換にフォールバックするように設計されています。ただし、クライアントによって最初に送信される単一のPinningTicket拡張機能は例外です。 さらに、プロトコルは、サーバーのID（「第2の要因」）の検証を強化するためにのみ設計されています。 その結果、実装またはプロトコルエラーでさえ、通常のTLS交換と比較してセキュリティが低下することはありません。 これらの2つのポイントを考えると、同意したクライアントとサーバーの実装の間で、オープンなインターネット上で実験を実行できます。"
    },
    {
      "indent": 3,
      "text": "The goal of the experiment is to prove that:",
      "ja": "実験の目的は、次のことを証明することです。"
    },
    {
      "indent": 3,
      "text": "* Non-supporting clients and servers are unaffected.",
      "ja": "* サポートしていないクライアントとサーバーは影響を受けません。"
    },
    {
      "indent": 3,
      "text": "* Connectivity between supporting clients and servers is retained under normal circumstances, whether the client connects to the server frequently (relative to the ticket's lifetime) or very rarely.",
      "ja": "* サポートするクライアントとサーバー間の接続は、クライアントがサーバーに頻繁に接続する（チケットの存続期間に関係する）場合も非常にまれな場合でも、通常の状況では保持されます。"
    },
    {
      "indent": 3,
      "text": "* Enterprise middleboxes do not interrupt such connectivity.",
      "ja": "* エンタープライズミドルボックスは、このような接続を中断しません。"
    },
    {
      "indent": 3,
      "text": "* Misissued certificates and rogue TLS-aware middleboxes do result in broken connectivity, and these cases are detected on the client and/or server side. Clients and servers can be recovered even after such events and the normal connectivity restored.",
      "ja": "* 誤って発行された証明書と不正なTLS対応ミドルボックスは、接続が切断される原因となり、これらのケースはクライアント側またはサーバー側、あるいはその両方で検出されます。 このようなイベントや通常の接続が復元された後でも、クライアントとサーバーを回復できます。"
    },
    {
      "indent": 3,
      "text": "Following two years of successful deployment, the authors will publish a document that summarizes the experiment's findings and will resubmit the protocol for consideration as a Proposed Standard.",
      "ja": "2年間の展開に成功した後、著者は実験の結果を要約したドキュメントを公開し、提案された標準として検討するためにプロトコルを再送信します。"
    },
    {
      "indent": 0,
      "text": "2. Protocol Overview",
      "section_title": true,
      "ja": "2. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The protocol consists of two phases: the first time a particular client connects to a server, and subsequent connections.",
      "ja": "プロトコルは2つのフェーズで構成されます。特定のクライアントが初めてサーバーに接続するときと、その後の接続です。"
    },
    {
      "indent": 3,
      "text": "This protocol supports full TLS handshakes, as well as 0-RTT handshakes. Below we present it in the context of a full handshake, but behavior in 0-RTT handshakes should be identical.",
      "ja": "このプロトコルは、完全なTLSハンドシェイクと0-RTTハンドシェイクをサポートします。 以下では、完全なハンドシェイクのコンテキストでそれを示しますが、0-RTTハンドシェイクの動作は同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "The document presents some similarities with the ticket resumption mechanism described in [RFC5077]. However the scope of this document differs from session resumption mechanisms implemented with [RFC5077] or with other mechanisms. Specifically, the pinning ticket does not carry any state associated with a TLS session and thus cannot be used for session resumption or client authentication. Instead, the pinning ticket only contains the encrypted pinning secret. The pinning ticket is used by the server to prove its ability to decrypt it, which implies ownership of the pinning protection key.",
      "ja": "このドキュメントは、[RFC5077]で説明されているチケット再開メカニズムといくつかの類似点を示しています。 ただし、このドキュメントの範囲は、[RFC5077]または他のメカニズムで実装されたセッション再開メカニズムとは異なります。 具体的には、ピニングチケットはTLSセッションに関連付けられた状態を保持しないため、セッション再開またはクライアント認証に使用できません。 代わりに、固定チケットには暗号化された固定シークレットのみが含まれます。 サーバーは、固定チケットを使用して、暗号化を解除する機能を証明します。これは、固定保護キーの所有権を意味します。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] has been obsoleted by [RFC8446], and ticket resumption is now defined by Section 2.2 of [RFC8446]. This document references [RFC5077] as an informational document since it contains a more thorough discussion of stateless ticket resumption, and because ticket resumption benefits from significant operational experience with TLS 1.2 that is still widely deployed at the time of writing. This experience, as well as deployment experience, can easily be re-used for identity pinning.",
      "ja": "[RFC5077]は[RFC8446]で廃止され、チケットの再開は[RFC8446]のセクション2.2で定義されています。 このドキュメントでは、[RFC5077]を情報ドキュメントとして参照します。ステートレスチケットの再開に関するより徹底的な説明が含まれているためです。 このエクスペリエンスは、展開エクスペリエンスと同様に、アイデンティティの固定に簡単に再利用できます。"
    },
    {
      "indent": 3,
      "text": "With TLS 1.3, session resumption is based on a Pre-Shared Key (PSK). This is orthogonal to this protocol. With TLS 1.3, a TLS session can be established using PKI and a pinning ticket, and later resumed with PSK.",
      "ja": "TLS 1.3では、セッションの再開は事前共有キー（PSK）に基づいています。 これは、このプロトコルに直交しています。 TLS 1.3では、PKIとピニングチケットを使用してTLSセッションを確立し、後でPSKで再開できます。"
    },
    {
      "indent": 3,
      "text": "However, the protocol described in this document addresses the problem of misissued certificates. Thus, it is not expected to be used outside a certificate-based TLS key exchange, such as in PSK. As a result, PSK handshakes MUST NOT include the extension defined here.",
      "ja": "ただし、このドキュメントで説明するプロトコルは、証明書の誤発行の問題に対処しています。 したがって、PSKなどの証明書ベースのTLSキー交換の外部で使用することは想定されていません。 その結果、PSKハンドシェイクには、ここで定義されている拡張子を含めることはできません。"
    },
    {
      "indent": 0,
      "text": "2.1. Initial Connection",
      "section_title": true,
      "ja": "2.1. 初期接続"
    },
    {
      "indent": 3,
      "text": "When a client first connects to a server, it requests a pinning ticket by sending an empty PinningTicket extension, and receives it as part of the server's first response, in the returned PinningTicket extension.",
      "ja": "クライアントが最初にサーバーに接続するとき、空のPinningTicket拡張機能を送信することで固定チケットを要求し、返されたPinningTicket拡張機能でサーバーの最初の応答の一部としてそれを受信します。"
    },
    {
      "indent": 4,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 4,
      "text": "ClientHello\n  + key_share\n  + signature_algorithms\n  + PinningTicket         -------->\n                                                ServerHello\n                                                + key_share\n                                      {EncryptedExtensions\n                                           + PinningTicket}\n                                      {CertificateRequest*}\n                                             {Certificate*}\n                                       {CertificateVerify*}\n                          <--------              {Finished}\n{Certificate*}\n{CertificateVerify*}\n{Finished}                -------->\n[Application Data]        <------->      [Application Data]",
      "raw": true
    },
    {
      "indent": 11,
      "text": "* Indicates optional or situation-dependent messages that are not always sent.",
      "ja": "* 常に送信されるとは限らない、オプションまたは状況依存のメッセージを示します。"
    },
    {
      "indent": 11,
      "text": "{} Indicates messages protected using keys derived from the ephemeral secret.",
      "ja": "{}ははかない秘密から派生したキーを使用して保護されたメッセージを示します。"
    },
    {
      "indent": 11,
      "text": "[] Indicates messages protected using keys derived from the master secret.",
      "ja": "[]マスターシークレットから派生したキーを使用して保護されたメッセージを示します。"
    },
    {
      "indent": 3,
      "text": "If a client supports the PinningTicket extension and does not have any pinning ticket associated with the server, the exchange is considered as an initial connection. Other reasons the client may not have a pinning ticket include the client having flushed its pinning ticket store, or the committed lifetime of the pinning ticket having expired.",
      "ja": "クライアントがPinningTicket拡張機能をサポートし、サーバーに関連付けられたピニングチケットがない場合、交換は初期接続と見なされます。 クライアントがピニングチケットを持っていないその他の理由には、ピニングチケットストアをフラッシュしたクライアント、またはピニングチケットのコミットされた有効期限が切れたことが含まれます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the PinningTicket extension, the server computes a pinning secret (Section 4.1) and sends the pinning ticket (Section 4.2) encrypted with the pinning protection key (Section 4.3). The pinning ticket is associated with a lifetime value by which the server assumes the responsibility of retaining the pinning protection key and being able to decrypt incoming pinning tickets during the period indicated by the committed lifetime.",
      "ja": "PinningTicket拡張機能を受信すると、サーバーはピニングシークレット（セクション4.1）を計算し、ピニング保護キー（セクション4.3）で暗号化されたピニングチケット（セクション4.2）を送信します。 ピニングチケットはライフタイム値に関連付けられます。このライフタイム値により、サーバーは、ピニング保護キーを保持し、コミットされたライフタイムで示される期間中に着信ピニングチケットを解読できるようになります。"
    },
    {
      "indent": 3,
      "text": "Once the pinning ticket has been generated, the server returns the pinning ticket and the committed lifetime in a PinningTicket extension embedded in the EncryptedExtensions message. We note that a PinningTicket extension MUST NOT be sent as part of a HelloRetryRequest.",
      "ja": "ピニングチケットが生成されると、サーバーはEncryptedExtensionsメッセージに埋め込まれたPinningTicket拡張でピニングチケットとコミットされたライフタイムを返します。 HelloRetryRequestの一部としてPinningTicket拡張を送信してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the pinning ticket, the client MUST NOT accept it until the key exchange is completed and the server authenticated. If the key exchange is not completed successfully, the client MUST ignore the received pinning ticket. Otherwise, the client computes the pinning secret and SHOULD cache the pinning secret and the pinning ticket for the duration indicated by the pinning ticket lifetime. The client SHOULD clean up the cached values at the end of the indicated lifetime.",
      "ja": "ピニングチケットを受信すると、クライアントはキー交換が完了してサーバーが認証されるまでそれを受け入れてはなりません。 鍵交換が正常に完了しない場合、クライアントは受信したピニングチケットを無視する必要があります。 それ以外の場合、クライアントはピニングシークレットを計算し、ピニングチケットの有効期間で示される期間、ピニングシークレットとピニングチケットをキャッシュする必要があります。 クライアントは、指定された有効期間の終了時にキャッシュされた値をクリーンアップする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Subsequent Connections",
      "section_title": true,
      "ja": "2.2. 後続の接続"
    },
    {
      "indent": 3,
      "text": "When the client initiates a connection to a server it has previously seen (see Section 2.3 on identifying servers), it SHOULD send the pinning ticket for that server. The pinning ticket, pinning secret, and pinning ticket lifetime computed during the establishment of the previous TLS session are designated in this document as the \"original\" ones, to distinguish them from a new ticket that may be generated during the current session.",
      "ja": "クライアントは、以前に見たサーバーへの接続を開始するとき（サーバーの識別に関するセクション2.3を参照）、そのサーバーの固定チケットを送信する必要があります。 前のTLSセッションの確立中に計算された固定チケット、固定シークレット、および固定チケットの有効期間は、現在のセッション中に生成される新しいチケットと区別するために、このドキュメントでは「オリジナル」として指定されます。"
    },
    {
      "indent": 3,
      "text": "The server MUST extract the original pinning_secret value from the ticket and MUST respond with a PinningTicket extension, which includes:",
      "ja": "サーバーはチケットから元のpinning_secret値を抽出する必要があり、PinningTicket拡張で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "* A proof that the server can understand the ticket that was sent by the client; this proof also binds the pinning ticket to the server's (current) public key, as well as the ongoing TLS session. The proof is mandatory and MUST be included if a pinning ticket was sent by the client.",
      "ja": "* サーバーがクライアントによって送信されたチケットを理解できることの証明。 また、この証明は、固定チケットをサーバーの（現在の）公開キーと、進行中のTLSセッションにバインドします。 証明は必須であり、ピニングチケットがクライアントによって送信された場合は含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* A fresh pinning ticket. The main reason for refreshing the ticket on each connection is privacy: to avoid the ticket serving as a fixed client identifier. While a fresh pinning ticket might be of zero length, it is RECOMMENDED to include a fresh ticket with a nonzero length with each response.",
      "ja": "* 新鮮なピニングチケット。 各接続でチケットを更新する主な理由はプライバシーです：固定クライアント識別子として機能するチケットを避けるため。 新しいピニングチケットの長さはゼロである場合がありますが、応答ごとに長さがゼロでないフレッシュチケットを含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "If the server cannot validate the received ticket, that might indicate an earlier MITM attack on this client. The server MUST then abort the connection with a handshake_failure alert and SHOULD log this failure.",
      "ja": "サーバーが受信したチケットを検証できない場合、このクライアントに対する以前のMITM攻撃を示している可能性があります。 サーバーは、handshake_failureアラートで接続を中止し、この失敗をログに記録する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MUST verify the proof, and if it fails to do so, the client MUST issue a handshake_failure alert and abort the connection (see also Section 6.5). It is important that the client does not attempt to \"fall back\" by omitting the PinningTicket extension.",
      "ja": "クライアントは証明を検証しなければならず、検証に失敗した場合、クライアントはhandshake_failureアラートを発行し、接続を中止しなければなりません（セクション6.5も参照）。 クライアントがPinningTicket拡張機能を省略して「フォールバック」しようとしないことが重要です。"
    },
    {
      "indent": 3,
      "text": "When the connection is successfully set up, i.e., after the Finished message is verified, the client SHOULD store the new ticket along with the corresponding pinning_secret, replacing the original ticket.",
      "ja": "接続が正常にセットアップされると、つまり、Finishedメッセージが検証された後、クライアントは、対応するpinning_secretとともに新しいチケットを保存する必要があり（元のチケットを置き換えます）"
    },
    {
      "indent": 3,
      "text": "Although this is an extension, if the client already has a ticket for a server, the client MUST interpret a missing PinningTicket extension in the server's response as an attack, because of the server's prior commitment to respect the ticket. The client MUST abort the connection in this case. See also Section 5.5 on ramping down support for this extension.",
      "ja": "これは拡張機能ですが、クライアントが既にサーバーのチケットを持っている場合、クライアントはサーバーの応答で欠落しているPinningTicket拡張機能を攻撃として解釈する必要があります。 この場合、クライアントは接続を中止する必要があります。 この拡張機能のサポートの段階的削減については、セクション5.5も参照してください。"
    },
    {
      "indent": 0,
      "text": "2.3. Indexing the Pins",
      "section_title": true,
      "ja": "2.3. ピンのインデックス作成"
    },
    {
      "indent": 3,
      "text": "Each pin is associated with a set of identifiers that include, among others, hostname, protocol (TLS or DTLS), and port number. In other words, the pin for port TCP/443 may be different from that for DTLS, or from the pin for port TCP/8443. These identifiers are expected to be relevant to characterize the identity of the server as well as the establishing TLS session. When a hostname is used, it MUST be the value sent inside the Server Name Indication (SNI) extension. This definition is similar to the concept of a Web Origin [RFC6454], but does not assume the existence of a URL.",
      "ja": "各ピンは、ホスト名、プロトコル（TLSまたはDTLS）、ポート番号などを含む識別子のセットに関連付けられています。 つまり、ポートTCP / 443のピンは、DTLSのピンとは異なる場合があります。または、ポートTCP / 8443のピンとは異なる場合があります。 これらの識別子は、サーバーのアイデンティティとTLSセッションの確立を特徴付けるのに関連していると予想されます。 ホスト名を使用する場合、サーバー名表示（SNI）拡張内で送信される値でなければなりません。 この定義はWeb Origin [RFC6454]の概念に似ていますが、URLの存在を想定していません。"
    },
    {
      "indent": 3,
      "text": "The purpose of ticket pinning is to pin the server identity. As a result, any information orthogonal to the server's identity MUST NOT be considered in indexing. More particularly, IP addresses are ephemeral and forbidden in SNI, and therefore pins MUST NOT be associated with IP addresses. Similarly, CA names or public keys associated with server MUST NOT be used for indexing as they may change over time.",
      "ja": "チケットのピン留めの目的は、サーバーIDをピン留めすることです。 その結果、サーバーのIDに直交する情報をインデックス作成で考慮してはなりません。 より詳細には、IPアドレスは一時的であり、SNIでは禁止されているため、ピンをIPアドレスに関連付けてはなりません。 同様に、サーバーに関連付けられているCA名または公開キーは、時間の経過とともに変化する可能性があるため、インデックス作成に使用しないでください。"
    },
    {
      "indent": 0,
      "text": "3. Message Definitions",
      "section_title": true,
      "ja": "3. メッセージ定義"
    },
    {
      "indent": 3,
      "text": "This section defines the format of the PinningTicket extension. We follow the message notation of [RFC8446].",
      "ja": "このセクションでは、PinningTicket拡張の形式を定義します。 [RFC8446]のメッセージ表記に従います。"
    },
    {
      "indent": 4,
      "text": "opaque pinning_ticket<0..2^16-1>;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "opaque pinning_proof<0..2^8-1>;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n  select (Role) {\n    case client:\n      pinning_ticket ticket<0..2^16-1>; //omitted on 1st connection",
      "raw": true
    },
    {
      "indent": 3,
      "text": "     case server:\n       pinning_proof proof<0..2^8-1>; //no proof on 1st connection\n       pinning_ticket ticket<0..2^16-1>; //omitted on ramp down\n       uint32 lifetime;\n   }\n} PinningTicketExtension;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ticket a pinning ticket sent by the client or returned by the server. The ticket is opaque to the client. The extension MUST contain exactly 0 or 1 tickets.",
      "ja": "クライアントから送信された、またはサーバーから返された固定チケットをチケットします。 チケットはクライアントには不透明です。 拡張には、正確に0または1つのチケットを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "proof a demonstration by the server that it understands the received ticket and therefore that it is in possession of the secret that was used to generate it originally. The extension MUST contain exactly 0 or 1 proofs.",
      "ja": "受信したチケットを理解しているため、元々それを生成するために使用されたシークレットを所有していることを、サーバーによるデモを証明します。 拡張には、正確に0または1の証明が含まれていなければなりません。"
    },
    {
      "indent": 3,
      "text": "lifetime the duration (in seconds) that the server commits to accept offered tickets in the future.",
      "ja": "lifetime提供されたチケットを将来受け入れるためにサーバーがコミットする期間（秒単位）。"
    },
    {
      "indent": 0,
      "text": "4. Cryptographic Operations",
      "section_title": true,
      "ja": "4. 暗号化操作"
    },
    {
      "indent": 3,
      "text": "This section provides details on the cryptographic operations performed by the protocol peers.",
      "ja": "このセクションでは、プロトコルピアによって実行される暗号化操作について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Pinning Secret",
      "section_title": true,
      "ja": "4.1. 固定の秘密"
    },
    {
      "indent": 3,
      "text": "The pinning secret is generated locally by the client and the server, which means they must use the same inputs to generate it. This value must be generated before the ServerHello message is sent, as the server includes the corresponding pinning ticket in the same flight as the ServerHello message. In addition, the pinning secret must be unpredictable to any party other than the client and the server.",
      "ja": "ピニングシークレットは、クライアントとサーバーによってローカルで生成されます。つまり、同じ入力を使用して生成する必要があります。 この値は、ServerHelloメッセージが送信される前に生成する必要があります。これは、ServerHelloメッセージと同じフライトに対応する固定チケットがサーバーに含まれるためです。 さらに、ピニングシークレットは、クライアントとサーバー以外の関係者にとって予測不可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The pinning secret is derived using the Derive-Secret function provided by TLS 1.3, described in Section 7.1 of [RFC8446].",
      "ja": "ピニングシークレットは、[RFC8446]のセクション7.1で説明されているTLS 1.3で提供される派生秘密関数を使用して導出されます。"
    },
    {
      "indent": 3,
      "text": "pinning secret = Derive-Secret(Handshake Secret, \"pinning secret\", ClientHello...ServerHello)",
      "ja": "pinning secret = Derive-Secret（ハンドシェイクシークレット、「pinning secret」、ClientHello ... ServerHello）"
    },
    {
      "indent": 0,
      "text": "4.2. Pinning Ticket",
      "section_title": true,
      "ja": "4.2. 固定チケット"
    },
    {
      "indent": 3,
      "text": "The pinning ticket contains the pinning secret. The pinning ticket is provided by the client to the server, which decrypts it in order to extract the pinning secret and responds with a pinning proof. As a result, the characteristics of the pinning ticket are:",
      "ja": "ピニングチケットには、ピニングシークレットが含まれています。 ピニングチケットはクライアントからサーバーに提供され、サーバーはそれを解読してピニングシークレットを抽出し、ピニング証明で応答します。 その結果、固定チケットの特性は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* Pinning tickets MUST be encrypted and integrity-protected using strong cryptographic algorithms.",
      "ja": "* 固定チケットは、強力な暗号化アルゴリズムを使用して暗号化および整合性保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Pinning tickets MUST be protected with a long-term pinning protection key.",
      "ja": "* 固定チケットは、長期の固定保護キーで保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Pinning tickets MUST include a pinning protection key ID or serial number as to enable the pinning protection key to be refreshed.",
      "ja": "* 固定チケットには、固定保護キーを更新できるように、固定保護キーIDまたはシリアル番号を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* The pinning ticket MAY include other information, in addition to the pinning secret. When additional information is included, a careful review needs to be performed to evaluate its impact on privacy.",
      "ja": "* ピニングチケットには、ピニングシークレットに加えて、他の情報を含めることができます。 追加情報が含まれる場合、プライバシーへの影響を評価するために、慎重なレビューを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The pinning ticket's format is not specified by this document, but a format similar to the one proposed by [RFC5077] is RECOMMENDED.",
      "ja": "ピニングチケットの形式はこのドキュメントでは指定されていませんが、[RFC5077]で提案されている形式に類似した形式が推奨されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Pinning Protection Key",
      "section_title": true,
      "ja": "4.3. 保護キーの固定"
    },
    {
      "indent": 3,
      "text": "The pinning protection key is used only by the server and so remains server implementation specific. [RFC5077] recommends the use of two keys, but when using Authenticated Encryption with Associated Data (AEAD) algorithms, only a single key is required.",
      "ja": "固定保護キーはサーバーによってのみ使用されるため、サーバー実装固有のままです。 [RFC5077]は、2つのキーの使用を推奨していますが、認証済み暗号化関連データ（AEAD）アルゴリズムを使用する場合、必要なキーは1つだけです。"
    },
    {
      "indent": 3,
      "text": "When a single server terminates TLS for multiple virtual servers using the SNI mechanism, it is strongly RECOMMENDED that the server use a separate protection key for each one of them, in order to allow migrating virtual servers between different servers while keeping pinning active.",
      "ja": "単一のサーバーがSNIメカニズムを使用して複数の仮想サーバーのTLSを終了する場合、サーバーは、固定をアクティブに保ちながら異なるサーバー間で仮想サーバーを移行できるようにするために、それぞれに個別の保護キーを使用することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 5.1, if the server is actually a cluster of machines, the protection key MUST be synchronized between all the nodes that accept TLS connections to the same server name. When [RFC5077] is deployed, an easy way to do it is to derive the protection key from the session-ticket protection key, which is already synchronized. For example:",
      "ja": "セクション5.1で述べたように、サーバーが実際にマシンのクラスターである場合、同じサーバー名へのTLS接続を受け入れるすべてのノード間で保護キーを同期する必要があります。 [RFC5077]が展開されている場合、それを行う簡単な方法は、既に同期されているセッションチケット保護キーから保護キーを導出することです。 例えば："
    },
    {
      "indent": 3,
      "text": "pinning_protection_key = HKDF-Expand(resumption_protection_key, \"pinning protection\", L)",
      "ja": "pinning_protection_key = HKDF-Expand（resumption_protection_key、 \"ピン止め保護\"、L）"
    },
    {
      "indent": 3,
      "text": "Where resumption_protection_key is the ticket protection key defined in [RFC5077]. Both resumption_protection_key and pinning_protection_key are only used by the server.",
      "ja": "resumption_protection_keyは[RFC5077]で定義されたチケット保護キーです。 resumption_protection_keyとpinning_protection_keyは両方ともサーバーによってのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "The above solution attempts to minimize code changes related to management of the resumption_protection_key. The drawback is that this key would be used both to directly encrypt session tickets and to derive the pinning_protection_key, and such mixed usage of a single key is not in line with cryptographic best practices. Where possible, it is RECOMMENDED that the resumption_protection_key be unrelated to the pinning_protection_key and that they are separately shared among the relevant servers.",
      "ja": "上記のソリューションは、resumption_protection_keyの管理に関連するコードの変更を最小限にしようとします。 欠点は、このキーがセッションチケットの直接暗号化とpinning_protection_keyの導出の両方に使用され、単一のキーのこのような混合使用が暗号化のベストプラクティスに沿っていないことです。 可能な場合、resumption_protection_keyはpinning_protection_keyとは無関係であり、関連するサーバー間で個別に共有することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.4. Pinning Proof",
      "section_title": true,
      "ja": "4.4. 固定証明"
    },
    {
      "indent": 3,
      "text": "The pinning proof is sent by the server to demonstrate that it has been able to decrypt the pinning ticket and to retrieve the pinning secret. The proof must be unpredictable and must not be replayed. Similarly to the pinning ticket, the pinning proof is sent by the server in the ServerHello message. In addition, it must not be possible for a MITM server with a fake certificate to obtain a pinning proof from the original server.",
      "ja": "固定チケットは、固定チケットを解読し、固定シークレットを取得できたことを示すために、サーバーによって送信されます。 証明は予測不可能であり、再生することはできません。 ピン止めチケットと同様に、ピン止め証明はServerHelloメッセージでサーバーによって送信されます。 さらに、偽の証明書を持つMITMサーバーが元のサーバーからピニング証明を取得できないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to address these requirements, the pinning proof is bound to the TLS session as well as the public key of the server:",
      "ja": "これらの要件に対処するために、ピン止めの証明は、TLSセッションとサーバーの公開キーにバインドされます。"
    },
    {
      "indent": 3,
      "text": "pinning_proof_secret=Derive-Secret(Handshake Secret, \"pinning proof 1\", ClientHello...ServerHello)",
      "ja": "pinning_proof_secret = Derive-Secret（ハンドシェイクシークレット、「pinning proof 1」、ClientHello ... ServerHello）"
    },
    {
      "indent": 3,
      "text": "proof = HMAC(original_pinning_secret, \"pinning proof 2\" +\n             pinning_proof_secret + Hash(server_public_key))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where HMAC [RFC2104] uses the Hash algorithm that was negotiated in the handshake, and the same hash is also used over the server's public key. The original_pinning_secret value refers to the secret value extracted from the ticket sent by the client, to distinguish it from a new pinning secret value that is possibly computed in the current exchange. The server_public_key value is the DER representation of the public key, specifically the SubjectPublicKeyInfo structure as-is.",
      "ja": "ここで、HMAC [RFC2104]は、ハンドシェイクでネゴシエートされたハッシュアルゴリズムを使用し、サーバーの公開キーでも同じハッシュが使用されます。 original_pinning_secret値は、クライアントによって送信されたチケットから抽出されたシークレット値を参照して、現在の交換で計算される可能性のある新しいピニングシークレット値と区別します。 server_public_key値は、公開キーのDER表現、具体的には現状のままのSubjectPublicKeyInfo構造です。"
    },
    {
      "indent": 0,
      "text": "5. Operational Considerations",
      "section_title": true,
      "ja": "5. 運用上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The main motivation behind the current protocol is to enable identity pinning without the need for manual operations. Manual operations are susceptible to human error, and in the case of public key pinning, can easily result in \"server bricking\": the server becoming inaccessible to some or all of its users. To achieve this goal, operations described in identity pinning are only performed within the current TLS session, and there is no dependence on any TLS configuration parameters such as CA identity or public keys. As a result, configuration changes are unlikely to lead to desynchronized state between the client and the server.",
      "ja": "現在のプロトコルの背後にある主な動機は、手動操作を必要とせずにIDピンニングを有効にすることです。 手動操作は人為的エラーの影響を受けやすく、公開キーのピン留めの場合、簡単に「サーバーブリック」が発生する可能性があります。つまり、サーバーの一部またはすべてのユーザーがサーバーにアクセスできなくなります。 この目標を達成するために、IDピニングで説明されている操作は現在のTLSセッション内でのみ実行され、CA IDや公開キーなどのTLS構成パラメーターに依存しません。 その結果、構成の変更によって、クライアントとサーバー間の非同期状態が発生する可能性は低くなります。"
    },
    {
      "indent": 0,
      "text": "5.1. Protection Key Synchronization",
      "section_title": true,
      "ja": "5.1. 保護キーの同期"
    },
    {
      "indent": 3,
      "text": "The only operational requirement when deploying this protocol is that, if the server is part of a cluster, protection keys (the keys used to encrypt tickets) MUST be synchronized between all cluster members. The protocol is designed so that if resumption ticket protection keys [RFC5077] are already synchronized between cluster members, nothing more needs to be done.",
      "ja": "このプロトコルを展開するときの唯一の操作要件は、サーバーがクラスターの一部である場合、すべてのクラスターメンバー間で保護キー（チケットの暗号化に使用されるキー）を同期する必要があることです。 プロトコルは、再開チケット保護キー[RFC5077]がクラスタメンバー間で既に同期されている場合、これ以上行う必要がないように設計されています。"
    },
    {
      "indent": 3,
      "text": "Moreover, synchronization does not need to be instantaneous, e.g., protection keys can be distributed a few minutes or hours in advance of their rollover. In such scenarios, each cluster member MUST be able to accept tickets protected with a new version of the protection key, even while it is still using an old version to generate keys. This ensures that, when a client receives a \"new\" ticket, it does not next hit a cluster member that still rejects this ticket.",
      "ja": "さらに、同期は瞬時に行う必要はありません。たとえば、ロールオーバーの数分または数時間前に保護キーを配布できます。 このようなシナリオでは、古いバージョンを使用してキーを生成している場合でも、各クラスターメンバーは新しいバージョンの保護キーで保護されたチケットを受け入れる必要があります。 これにより、クライアントが「新しい」チケットを受信したときに、このチケットをまだ拒否しているクラスターメンバーに次にヒットすることがなくなります。"
    },
    {
      "indent": 3,
      "text": "Misconfiguration can lead to the server's clock being off by a large amount of time. Consider a case where a server's clock is misconfigured, for example, to be 1 year in the future, and the system is allowed to delete expired keys automatically. The server will then delete many outstanding keys because they are now long expired and will end up rejecting valid tickets that are stored by clients. Such a scenario could make the server inaccessible to a large number of clients.",
      "ja": "構成に誤りがあると、サーバーのクロックが大幅に遅れる場合があります。 たとえば、サーバーのクロックが1年先に誤って設定され、システムが期限切れのキーを自動的に削除することを許可されている場合を考えます。 サーバーは多くの未処理のキーを削除します。これは、キーの有効期限が長くなり、クライアントによって保存されている有効なチケットが拒否されるためです。 このようなシナリオでは、多数のクライアントがサーバーにアクセスできなくなる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The decision to delete a key should at least consider the largest value of the ticket lifetime as well as the expected time desynchronization between the servers of the cluster and the time difference for distributing the new key among the different servers in the cluster.",
      "ja": "キーを削除する決定では、少なくともチケットの有効期間の最大値、クラスターのサーバー間の予想される時間の非同期、およびクラスター内の異なるサーバー間で新しいキーを配布するための時間差を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Ticket Lifetime",
      "section_title": true,
      "ja": "5.2. チケットの有効期間"
    },
    {
      "indent": 3,
      "text": "The lifetime of the ticket is a commitment by the server to retain the ticket's corresponding protection key for this duration, so that the server can prove to the client that it knows the secret embedded in the ticket. For production systems, the lifetime SHOULD be between 7 and 31 days.",
      "ja": "チケットのライフタイムは、サーバーがチケットに対応する保護キーをこの期間保持するためのコミットメントであるため、サーバーは、チケットに埋め込まれた秘密を知っていることをクライアントに証明できます。 実稼働システムの場合、有効期間は7〜31日間である必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Certificate Renewal",
      "section_title": true,
      "ja": "5.3. 証明書の更新"
    },
    {
      "indent": 3,
      "text": "The protocol ensures that the client will continue speaking to the correct server even when the server's certificate is renewed. In this sense, pinning is not associated with certificates, which is the reason we designate the protocol described in this document as \"server identity pinning\".",
      "ja": "このプロトコルにより、サーバーの証明書が更新された場合でも、クライアントが正しいサーバーと通信し続けることが保証されます。 この意味で、固定は証明書に関連付けられていないため、このドキュメントで説明するプロトコルを「サーバーID固定」と指定します。"
    },
    {
      "indent": 3,
      "text": "Note that this property is not impacted by the use of the server's public key in the pinning proof because the scope of the public key used is only the current TLS session.",
      "ja": "使用される公開鍵の範囲は現在のTLSセッションのみであるため、このプロパティは、ピン留め証明でのサーバーの公開鍵の使用による影響を受けないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Certificate Revocation",
      "section_title": true,
      "ja": "5.4. 証明書失効"
    },
    {
      "indent": 3,
      "text": "The protocol is orthogonal to certificate validation in the sense that, if the server's certificate has been revoked or is invalid for some other reason, the client MUST refuse to connect to it regardless of any ticket-related behavior.",
      "ja": "プロトコルは、サーバーの証明書が失効したか、他の何らかの理由で無効になった場合、チケット関連の動作に関係なく、クライアントが接続を拒否しなければならないという意味で、証明書の検証と直交しています。"
    },
    {
      "indent": 0,
      "text": "5.5. Disabling Pinning",
      "section_title": true,
      "ja": "5.5. ピン止めを無効にする"
    },
    {
      "indent": 3,
      "text": "A server implementing this protocol MUST have a \"ramp down\" mode of operation where:",
      "ja": "このプロトコルを実装するサーバーには、「ランプダウン」動作モードが必要です。"
    },
    {
      "indent": 3,
      "text": "* The server continues to accept valid pinning tickets and responds correctly with a proof.",
      "ja": "* サーバーは引き続き有効な固定チケットを受け入れ、証明で正しく応答します。"
    },
    {
      "indent": 3,
      "text": "* The server does not send back a new pinning ticket.",
      "ja": "* サーバーは新しい固定チケットを送り返しません。"
    },
    {
      "indent": 3,
      "text": "After a while, no clients will hold valid tickets, and the feature may be disabled. Note that clients that do not receive a new pinning ticket do not necessarily need to remove the original ticket. Instead, the client may keep using the ticket until its lifetime expires. However, as detailed in Section 6.7, re-use of a ticket by the client may result in privacy concerns as the ticket value may be used to correlate TLS sessions.",
      "ja": "しばらくすると、有効なチケットを保持するクライアントはなくなり、機能が無効になる場合があります。 新しいピニングチケットを受け取らないクライアントは、必ずしも元のチケットを削除する必要がないことに注意してください。 代わりに、クライアントはその有効期限が切れるまでチケットを使用し続ける場合があります。 ただし、セクション6.7で詳しく説明しているように、チケット値を使用してTLSセッションを関連付けると、クライアントがチケットを再利用するとプライバシーの問題が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Issuing a new pinning ticket with a shorter lifetime would only delay the ramp down process, as the shorter lifetime can only affect clients that actually initiated a new connection. Other clients would still see the original lifetime for their pinning tickets.",
      "ja": "短いライフタイムは、実際に新しい接続を開始したクライアントにのみ影響するため、ライフタイムが短い新しいピニングチケットを発行すると、ランプダウンプロセスが遅延するだけです。 他のクライアントは、ピニングチケットの元の有効期間を引き続き参照します。"
    },
    {
      "indent": 0,
      "text": "5.6. Server Compromise",
      "section_title": true,
      "ja": "5.6. サーバーの侵害"
    },
    {
      "indent": 3,
      "text": "If a server compromise is detected, the pinning protection key MUST be rotated immediately, but the server MUST still accept valid tickets that use the old, compromised key. Clients that still hold old pinning tickets will remain vulnerable to MITM attacks, but those that connect to the correct server will immediately receive new tickets protected with the newly generated pinning protection key.",
      "ja": "サーバーの侵害が検出された場合、ピン止め保護キーをすぐにローテーションする必要がありますが、サーバーは古い侵害されたキーを使用する有効なチケットを引き続き受け入れなければなりません。 古いピンチケットを保持しているクライアントはMITM攻撃に対して脆弱なままですが、正しいサーバーに接続するクライアントは、新しく生成されたピン保護キーで保護された新しいチケットをすぐに受け取ります。"
    },
    {
      "indent": 3,
      "text": "The same procedure applies if the pinning protection key is compromised directly, e.g., if a backup copy is inadvertently made public.",
      "ja": "ピン留め保護キーが直接侵害された場合、たとえばバックアップコピーが誤って公開された場合など、同じ手順が適用されます。"
    },
    {
      "indent": 0,
      "text": "5.7. Disaster Recovery",
      "section_title": true,
      "ja": "5.7. 災害からの回復"
    },
    {
      "indent": 3,
      "text": "All web servers in production need to be backed up, so that they can be recovered if a disaster (including a malicious activity) ever wipes them out. Backup often includes the certificate and its private key, which must be backed up securely. The pinning secret, including earlier versions that are still being accepted, must be backed up regularly. However since it is only used as an authentication second factor, it does not require the same level of confidentiality as the server's private key.",
      "ja": "運用中のすべてのWebサーバーは、災害（悪意のあるアクティビティを含む）によって完全に消去された場合に復旧できるように、バックアップする必要があります。 バックアップには、多くの場合、証明書とその秘密キーが含まれます。これらは安全にバックアップする必要があります。 まだ受け入れられている以前のバージョンを含む、固定の秘密は定期的にバックアップする必要があります。 ただし、認証の2番目の要素としてのみ使用されるため、サーバーの秘密キーと同じレベルの機密性は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Readers should note that [RFC5077] session resumption keys are more security sensitive and should normally not be backed up, but rather treated as ephemeral keys. Even when servers derive pinning secrets from resumption keys (Section 4.1), they MUST NOT back up resumption keys.",
      "ja": "読者は、[RFC5077]セッション再開キーの方がセキュリティに敏感であり、通常はバックアップしないで、一時キーとして扱う必要があることに注意してください。 サーバーが再開キー（セクション4.1）からピニングシークレットを導出する場合でも、再開キーをバックアップしてはなりません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section reviews several security aspects related to the proposed extension.",
      "ja": "このセクションでは、提案されている拡張機能に関連するいくつかのセキュリティの側面を確認します。"
    },
    {
      "indent": 0,
      "text": "6.1. Trust-on-First-Use (TOFU) and MITM Attacks",
      "section_title": true,
      "ja": "6.1. Trust-on-First-Use（TOFU）およびMITM攻撃"
    },
    {
      "indent": 3,
      "text": "This protocol is a trust-on-first-use protocol. If a client initially connects to the \"right\" server, it will be protected against MITM attackers for the lifetime of each received ticket. If it connects regularly (depending, of course, on the server-selected lifetime), it will stay constantly protected against fake certificates.",
      "ja": "このプロトコルは、初回使用時に信頼されるプロトコルです。 クライアントが最初に「正しい」サーバーに接続する場合、受信した各チケットのライフタイムの間、MITM攻撃者から保護されます。 定期的に接続する場合（もちろん、サーバーが選択したライフタイムに応じて）、偽の証明書から常に保護されます。"
    },
    {
      "indent": 3,
      "text": "However if it initially connects to an attacker, subsequent connections to the \"right\" server will fail. Server operators might want to advise clients on how to remove corrupted pins, once such large-scale attacks are detected and remediated.",
      "ja": "ただし、最初に攻撃者に接続すると、その後の「正しい」サーバーへの接続は失敗します。 サーバーオペレーターは、このような大規模な攻撃が検出され、修正されたら、破損したピンを削除する方法についてクライアントにアドバイスすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The protocol is designed so that it is not vulnerable to an active MITM attacker who has real-time access to the original server. The pinning proof includes a hash of the server's public key to ensure the client that the proof was in fact generated by the server with which it is initiating the connection.",
      "ja": "このプロトコルは、元のサーバーにリアルタイムでアクセスするアクティブなMITM攻撃者に対して脆弱ではないように設計されています。 固定証明には、サーバーの公開キーのハッシュが含まれ、クライアントが、接続を開始するサーバーによって実際に証明が生成されたことを確認します。"
    },
    {
      "indent": 0,
      "text": "6.2. Pervasive Monitoring",
      "section_title": true,
      "ja": "6.2. 広範囲な監視"
    },
    {
      "indent": 3,
      "text": "Some organizations, and even some countries, perform pervasive monitoring on their constituents [RFC7258]. This often takes the form of always-active SSL proxies. Because of the TOFU property, this protocol does not provide any security in such cases.",
      "ja": "一部の組織、さらには一部の国では、その構成要素の広範な監視を実行しています[RFC7258]。 多くの場合、これは常にアクティブなSSLプロキシの形式を取ります。 TOFUプロパティのため、このプロトコルはこのような場合にセキュリティを提供しません。"
    },
    {
      "indent": 3,
      "text": "Pervasive monitoring may also result in privacy concerns detailed in Section 6.7.",
      "ja": "広範囲の監視により、セクション6.7で詳述するプライバシーの懸念が生じる可能性もあります。"
    },
    {
      "indent": 0,
      "text": "6.3. Server-Side Error Detection",
      "section_title": true,
      "ja": "6.3. サーバー側のエラー検出"
    },
    {
      "indent": 3,
      "text": "Uniquely, this protocol allows the server to detect clients that present incorrect tickets and therefore can be assumed to be victims of a MITM attack. Server operators can use such cases as indications of ongoing attacks, similarly to fake certificate attacks that took place in a few countries in the past.",
      "ja": "一意に、このプロトコルにより、サーバーは不正なチケットを提示するクライアントを検出できるため、MITM攻撃の被害者であると想定できます。 サーバーオペレーターは、過去数カ国で発生した偽の証明書攻撃と同様に、進行中の攻撃の兆候としてこのようなケースを使用できます。"
    },
    {
      "indent": 0,
      "text": "6.4. Client Policy and SSL Proxies",
      "section_title": true,
      "ja": "6.4. クライアントポリシーとSSLプロキシ"
    },
    {
      "indent": 3,
      "text": "Like it or not, some clients are normally deployed behind an SSL proxy. Similar to [RFC7469], it is acceptable to allow pinning to be disabled for some hosts according to local policy. For example, a User Agent (UA) MAY disable pinning for hosts whose validated certificate chain terminates at a user-defined trust anchor, rather than a trust anchor built into the UA (or underlying platform). Moreover, a client MAY accept an empty PinningTicket extension from such hosts as a valid response.",
      "ja": "好むと好まざるとにかかわらず、一部のクライアントは通常SSLプロキシの背後に展開されます。 [RFC7469]と同様に、ローカルポリシーに従って、一部のホストの固定を無効にすることは許容されます。 たとえば、ユーザーエージェント（UA）は、UA（または基盤となるプラットフォーム）に組み込まれたトラストアンカーではなく、検証済みの証明書チェーンがユーザー定義のトラストアンカーで終了するホストの固定を無効にすることができます。 さらに、クライアントは、そのようなホストからの空のPinningTicket拡張を有効な応答として受け入れる場合があります。"
    },
    {
      "indent": 0,
      "text": "6.5. Client-Side Error Behavior",
      "section_title": true,
      "ja": "6.5. クライアント側のエラー動作"
    },
    {
      "indent": 3,
      "text": "When a client receives a malformed or empty PinningTicket extension from a pinned server, it MUST abort the handshake. If the client retries the request, it MUST NOT omit the PinningTicket in the retry message. Doing otherwise would expose the client to trivial fallback attacks, similar to those described in [RFC7507].",
      "ja": "クライアントは、固定されたサーバーから不正な形式または空のPinningTicket拡張を受信すると、ハンドシェイクを中止する必要があります。 クライアントが要求を再試行する場合、再試行メッセージでPinningTicketを省略してはなりません。 そうしないと、[RFC7507]で説明されている攻撃と同様に、クライアントが些細なフォールバック攻撃にさらされることになります。"
    },
    {
      "indent": 3,
      "text": "However, this rule can negatively impact clients that move from behind SSL proxies into the open Internet, and vice versa, if the advice in Section 6.4 is not followed. Therefore, it is RECOMMENDED that browser and library vendors provide a documented way to remove stored pins.",
      "ja": "ただし、このルールは、セクション6.4のアドバイスに従わない場合、SSLプロキシの背後からオープンインターネットに移動するクライアントに悪影響を与える可能性があります。 したがって、ブラウザおよびライブラリベンダーが、保存されたピンを削除するための文書化された方法を提供することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6.6. Stolen and Forged Tickets",
      "section_title": true,
      "ja": "6.6. 盗まれたチケットと偽造されたチケット"
    },
    {
      "indent": 3,
      "text": "An attacker gains no benefit from stealing pinning tickets, even in conjunction with other pinning parameters such as the associated pinning secret, since pinning tickets are used to secure the client rather than the server. Similarly, it is useless to forge a ticket for a particular server.",
      "ja": "固定チケットはサーバーではなくクライアントを保護するために使用されるため、関連する固定シークレットなどの他の固定パラメーターと組み合わせても、固定チケットを盗むことによる攻撃者の利益はありません。 同様に、特定のサーバーのチケットを偽造することは無意味です。"
    },
    {
      "indent": 0,
      "text": "6.7. Client Privacy",
      "section_title": true,
      "ja": "6.7. クライアントのプライバシー"
    },
    {
      "indent": 3,
      "text": "This protocol is designed so that an external attacker cannot link different requests to a single client, provided the client requests and receives a fresh ticket upon each connection. This may be of concern particularly during ramp down, if the server does not provide a new ticket, and the client reuses the same ticket. To reduce or avoid such privacy concerns, it is RECOMMENDED for the server to issue a fresh ticket with a reduced lifetime. This would at least reduce the time period in which the TLS sessions of the client can be linked. The server MAY also issue tickets with a zero-second lifetime until it is confident all tickets are expired.",
      "ja": "このプロトコルは、外部の攻撃者がさまざまなリクエストを単一のクライアントにリンクできないように設計されており、クライアントがリクエストを行い、接続ごとに新しいチケットを受信します。 サーバーが新しいチケットを提供せず、クライアントが同じチケットを再利用する場合、これは特にランプダウン中に懸念される可能性があります。 このようなプライバシーの懸念を軽減または回避するには、サーバーが有効期限の短い新しいチケットを発行することをお勧めします。 これにより、少なくともクライアントのTLSセッションをリンクできる期間が短縮されます。 サーバーは、すべてのチケットの有効期限が切れるまで、ゼロ秒の有効期間を持つチケットを発行することもできます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the server to which the client is connecting can easily track the client. This may be an issue when the client expects to connect to the server (e.g., a mail server) with multiple identities. Implementations SHOULD allow the user to opt out of pinning, either in general or for particular servers.",
      "ja": "一方、クライアントが接続しているサーバーは、クライアントを簡単に追跡できます。 これは、クライアントが複数のIDを持つサーバー（メールサーバーなど）に接続することを期待している場合に問題になる可能性があります。 実装は、一般的または特定のサーバーのいずれかで、ユーザーが固定をオプトアウトできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "This document does not define the exact content of tickets. Including client-specific information in tickets would raise privacy concerns and is NOT RECOMMENDED.",
      "ja": "このドキュメントでは、チケットの正確な内容を定義していません。 チケットにクライアント固有の情報を含めると、プライバシーの問題が発生するため、お勧めしません。"
    },
    {
      "indent": 0,
      "text": "6.8. Ticket Protection Key Management",
      "section_title": true,
      "ja": "6.8. チケット保護キー管理"
    },
    {
      "indent": 3,
      "text": "While the ticket format is not mandated by this document, protecting the ticket using authenticated encryption is RECOMMENDED. Some of the algorithms commonly used for authenticated encryption, e.g., Galois/Counter Mode (GCM), are highly vulnerable to nonce reuse, and this problem is magnified in a cluster setting. Therefore, implementations that choose AES-GCM or any AEAD equivalent MUST adopt one of these three alternatives:",
      "ja": "チケットの形式はこのドキュメントでは義務付けられていませんが、認証された暗号化を使用してチケットを保護することをお勧めします。 認証された暗号化に一般的に使用されるアルゴリズムの一部、たとえばガロア/カウンターモード（GCM）は、ナンスの再利用に対して非常に脆弱であり、この問題はクラスター設定で拡大されます。 したがって、AES-GCMまたは同等のAEADを選択する実装では、次の3つの選択肢のいずれかを採用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Partition the nonce namespace between cluster members and use monotonic counters on each member, e.g., by setting the nonce to the concatenation of the cluster member ID and an incremental counter.",
      "ja": "* ノンス名前空間をクラスターメンバー間で分割し、各メンバーで単調カウンターを使用します。たとえば、ノンスをクラスターメンバーIDと増分カウンターの連結に設定します。"
    },
    {
      "indent": 3,
      "text": "* Generate random nonces but avoid the so-called birthday bound, i.e., never generate more than the maximum allowed number of encrypted tickets (2**64 for AES-128-GCM) for the same ticket pinning protection key.",
      "ja": "* ランダムナンスを生成しますが、いわゆる誕生日制限を避けます。つまり、同じチケット固定保護キーに対して、暗号化されたチケットの最大許容数（AES-128-GCMの場合は2 ** 64）を超えないようにします。"
    },
    {
      "indent": 3,
      "text": "* An alternative design that has been attributed to Karthik Bhargavan is as follows. Start with a 128-bit master key K_master and then for each encryption, generate a 256-bit random nonce and compute: K = HKDF(K_master, Nonce || \"key\"), then N = HKDF(K_master, Nonce || \"nonce\"). Use these values to encrypt the ticket, AES-GCM(K, N, data). This nonce should then be stored and transmitted with the ticket.",
      "ja": "* Karthik Bhargavanに起因する代替設計は次のとおりです。 128ビットのマスターキーK_masterから開始し、暗号化ごとに256ビットのランダムノンスを生成して計算します。K= HKDF（K_master、Nonce || \"key\"）、N = HKDF（K_master、Nonce || \" ナンス」）。 これらの値を使用して、チケットAES-GCM（K、N、data）を暗号化します。 その後、このナンスは保存され、チケットとともに送信されます。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IANA has allocated a TicketPinning extension value in the \"TLS ExtensionType Values\" registry.",
      "ja": "IANAは、「TLS ExtensionType値」レジストリにTicketPinning拡張値を割り当てました。"
    },
    {
      "indent": 3,
      "text": "[RFC8447] defines the procedure, requirements, and the necessary information for the IANA to update the \"TLS ExtensionType Values\" registry [TLS-EXT]. The registration procedure is \"Specification Required\" [RFC8126].",
      "ja": "[RFC8447]は、手順、要件、およびITLSが「TLS ExtensionType値」レジストリ[TLS-EXT]を更新するために必要な情報を定義します。 登録手順は「仕様が必要」[RFC8126]です。"
    },
    {
      "indent": 3,
      "text": "The TicketPinning extension is registered as follows. (The extension is not limited to Private Use, and as such has its first byte in the range 0-254.)",
      "ja": "TicketPinning拡張機能は次のように登録されます。 （拡張機能はプライベート使用に限定されず、そのため、最初のバイトの範囲は0〜254です。）"
    },
    {
      "indent": 3,
      "text": "Value: 32",
      "ja": "値：32"
    },
    {
      "indent": 3,
      "text": "Name: ticket_pinning",
      "ja": "名前：ticket_pinning"
    },
    {
      "indent": 3,
      "text": "Recommended: No",
      "ja": "推奨：いいえ"
    },
    {
      "indent": 3,
      "text": "TLS 1.3: CH, EE (to indicate that the extension is present in ClientHello and EncryptedExtensions messages)",
      "ja": "TLS 1.3：CH、EE（拡張機能がClientHelloおよびEncryptedExtensionsメッセージに存在することを示すため）"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8447] Salowey, J. and S. Turner, \"IANA Registry Updates for TLS and DTLS\", RFC 8447, DOI 10.17487/RFC8447, August 2018, <https://www.rfc-editor.org/info/rfc8447>.",
      "ja": "[RFC8447] Salowey、J。およびS. Turner、「TLSおよびDTLSのIANAレジストリ更新」、RFC 8447、DOI 10.17487 / RFC8447、2018年8月、<https://www.rfc-editor.org/info/rfc8447> 。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Netcraft] Mutton, P., \"HTTP Public Key Pinning: You're doing it wrong!\", March 2016, <https://news.netcraft.com/archives/2016/03/30/http-public-key-pinning-youre-doing-it-wrong.html>.",
      "ja": "[Netcraft]マトン、P。、「HTTP公開キーのピン留め：あなたは間違っています！」、2016年3月、<https://news.netcraft.com/archives/2016/03/30/http-public-key -pinning-youre-doing-it-wrong.html>。"
    },
    {
      "indent": 3,
      "text": "[Oreo] Berkman, O., Pinkas, B., and M. Yung, \"Firm Grip Handshakes: A Tool for Bidirectional Vouching\", Cryptology and Network Security pp. 142-157, 2012.",
      "ja": "[オレオ]バークマン、O。、ピンカス、B。、およびM.ユン、「ファームグリップハンドシェイク：双方向バウチングのツール」、暗号およびネットワークセキュリティpp。142-157、2012年。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のキー付きハッシュ」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<https：//www.rfc-editor .org / info / rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <https://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、Zhou、H.、Eronen、P。、およびH. Tschofenig、「サーバー側状態のないトランスポート層セキュリティ（TLS）セッション再開」、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 <https://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <https://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454] Barth、A。、「Web Origin Concept」、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<https://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC6962] Laurie, B., Langley, A., and E. Kasper, \"Certificate Transparency\", RFC 6962, DOI 10.17487/RFC6962, June 2013, <https://www.rfc-editor.org/info/rfc6962>.",
      "ja": "[RFC6962]ローリー、B。、ラングレー、A。、およびE.カスパー、「証明書の透明性」、RFC 6962、DOI 10.17487 / RFC6962、2013年6月、<https://www.rfc-editor.org/info/rfc6962 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014, <https://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[RFC7258] Farrell、S.およびH. Tschofenig、「広範囲にわたる監視は攻撃」、BCP 188、RFC 7258、DOI 10.17487 / RFC7258、2014年5月、<https://www.rfc-editor.org/info/rfc7258 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7469] Evans, C., Palmer, C., and R. Sleevi, \"Public Key Pinning Extension for HTTP\", RFC 7469, DOI 10.17487/RFC7469, April 2015, <https://www.rfc-editor.org/info/rfc7469>.",
      "ja": "[RFC7469] Evans、C.、Palmer、C。、およびR. Sleevi、「HTTPの公開キー固定拡張」、RFC 7469、DOI 10.17487 / RFC7469、2015年4月、<https://www.rfc-editor.org / info / rfc7469>。"
    },
    {
      "indent": 3,
      "text": "[RFC7507] Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks\", RFC 7507, DOI 10.17487/RFC7507, April 2015, <https://www.rfc-editor.org/info/rfc7507>.",
      "ja": "[RFC7507] Moeller、B.、A。Langley、「プロトコルダウングレード攻撃を防ぐためのTLSフォールバックシグナリング暗号スイート値（SCSV）」、RFC 7507、DOI 10.17487 / RFC7507、2015年4月、<https：//www.rfc-editor .org / info / rfc7507>。"
    },
    {
      "indent": 3,
      "text": "[RFC8555] Barnes, R., Hoffman-Andrews, J., McCarney, D., and J. Kasten, \"Automatic Certificate Management Environment (ACME)\", RFC 8555, DOI 10.17487/RFC8555, March 2019, <https://www.rfc-editor.org/info/rfc8555>.",
      "ja": "[RFC8555] Barnes、R.、Hoffman-Andrews、J.、McCarney、D。、およびJ.Kasten、「自動証明書管理環境（ACME）」、RFC 8555、DOI 10.17487 / RFC8555、2019年3月、<https：/ /www.rfc-editor.org/info/rfc8555>。"
    },
    {
      "indent": 3,
      "text": "[TLS-EXT] IANA, \"TLS Extension Type Value\", <https://www.iana.org/assignments/tls-extensiontype-values/>.",
      "ja": "[TLS-EXT] IANA、「TLS拡張タイプ値」、<https://www.iana.org/assignments/tls-extensiontype-values/>。"
    },
    {
      "indent": 3,
      "text": "[TLS-TACK] Marlinspike, M., \"Trust Assertions for Certificate Keys\", Work in Progress, Internet-Draft, draft-perrin-tls-tack-02, 7 January 2013, <https://tools.ietf.org/html/draft-perrin-tls-tack-02>.",
      "ja": "[TLS-TACK] Marlinspike、M.、「証明書キーの信頼アサーション」、Work in Progress、Internet-Draft、draft-perrin-tls-tack-02、2013年1月7日、<https://tools.ietf.org / html / draft-perrin-tls-tack-02>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Previous Work",
      "section_title": true,
      "ja": "付録A.前の作業"
    },
    {
      "indent": 3,
      "text": "The global PKI system relies on the trust of a CA issuing certificates. As a result, a corrupted trusted CA may issue a certificate for any organization without the organization's approval (a misissued or \"fake\" certificate), and use the certificate to impersonate the organization. There are many attempts to resolve these weaknesses, including the Certificate Transparency (CT) protocol [RFC6962], HTTP Public Key Pinning (HPKP) [RFC7469], and Trust Assertions for Certificate Keys (TACK) [TLS-TACK].",
      "ja": "グローバルPKIシステムは、証明書を発行するCAの信頼に依存しています。 その結果、破損した信頼できるCAは、組織の承認なしに組織に証明書を発行し（誤発行または「偽の」証明書）、証明書を使用して組織になりすますことができます。 証明書の透明性（CT）プロトコル[RFC6962]、HTTP公開キーピニング（HPKP）[RFC7469]、および証明書キーの信頼アサーション（TACK）[TLS-TACK]など、これらの弱点を解決する試みは数多くあります。"
    },
    {
      "indent": 3,
      "text": "CT requires cooperation of a large portion of the hundreds of extant certificate authorities (CAs) before it can be used \"for real\", in enforcing mode. It is noted that the relevant industry forum (CA/ Browser Forum) is indeed pushing for such extensive adoption. However the public nature of CT often makes it inappropriate for enterprise use because many organizations are not willing to expose their internal infrastructure publicly.",
      "ja": "CTは、強制モードで「実際に」使用する前に、何百もの現存する認証局（CA）の大部分の協力を必要とします。 関連する業界フォーラム（CA /ブラウザフォーラム）が実際にそのような広範な採用を推進していることに注意してください。 しかし、多くの組織は内部インフラストラクチャを公開することを望んでいないため、CTの公共性により、企業での使用には不適切になることがよくあります。"
    },
    {
      "indent": 3,
      "text": "TACK has some similarities to the current proposal, but work on it seems to have stalled. Appendix A.2 compares our proposal to TACK.",
      "ja": "TACKには現在の提案といくつかの類似点がありますが、その作業は停滞しているようです。 付録A.2では、提案をTACKと比較しています。"
    },
    {
      "indent": 3,
      "text": "HPKP is an IETF standard, but so far has proven hard to deploy. HPKP pins (fixes) a public key, one of the public keys listed in the certificate chain. As a result, HPKP needs to be coordinated with the certificate management process. Certificate management impacts HPKP and thus increases the probability of HPKP failures. This risk is made even higher given the fact that, even though work has been done in the Automated Certificate Management Environment (ACME) working group to automate certificate management, in many or even most cases, certificates are still managed manually. As a result, HPKP cannot be completely automated, resulting in error-prone manual configuration. Such errors could prevent the web server from being accessed by some clients. In addition, HPKP uses an HTTP header, which makes this solution HTTPS specific and not generic to TLS. On the other hand, the current document provides a solution that is independent of the server's certificate management, and that can be entirely and easily automated. Appendix A.1 compares HPKP to the current document in more detail.",
      "ja": "HPKPはIETF標準ですが、これまでのところ展開が難しいことが証明されています。 HPKPは、証明書チェーンにリストされている公開キーの1つである公開キーを固定（修正）します。そのため、HPKPは証明書管理プロセスと調整する必要があります。証明書管理はHPKPに影響を与えるため、HPKPが失敗する可能性が高くなります。自動証明書管理環境（ACME）ワーキンググループで証明書管理を自動化するための作業が行われているにもかかわらず、多くの場合、またはほとんどの場合、証明書は依然として手動で管理されているため、このリスクはさらに高くなります。その結果、HPKPを完全に自動化できず、エラーが発生しやすい手動構成になります。このようなエラーにより、一部のクライアントがWebサーバーにアクセスできなくなる場合があります。さらに、HPKPはHTTPヘッダーを使用するため、このソリューションはHTTPS固有であり、TLSに対して汎用ではありません。一方、現在のドキュメントは、サーバーの証明書管理に依存しないソリューションを提供し、完全かつ簡単に自動化できます。付録A.1では、HPKPと現在のドキュメントをより詳細に比較しています。"
    },
    {
      "indent": 3,
      "text": "The ticket pinning proposal augments these mechanisms with a much easier to implement and deploy solution for server identity pinning, by reusing some of the ideas behind TLS session resumption.",
      "ja": "チケット固定の提案は、TLSセッション再開の背後にあるいくつかのアイデアを再利用することで、サーバーID固定のためのソリューションの実装と展開がはるかに簡単になることで、これらのメカニズムを強化します。"
    },
    {
      "indent": 3,
      "text": "This section compares ticket pinning to two earlier proposals, HPKP and TACK.",
      "ja": "このセクションでは、チケットのピン留めを、HPKPおよびTACKの2つの以前の提案と比較します。"
    },
    {
      "indent": 0,
      "text": "A.1. Comparison: HPKP",
      "section_title": true,
      "ja": "A.1. 比較：HPKP"
    },
    {
      "indent": 3,
      "text": "The current IETF standard for pinning the identity of web servers is HPKP [RFC7469].",
      "ja": "WebサーバーのIDを固定するための現在のIETF標準はHPKP [RFC7469]です。"
    },
    {
      "indent": 3,
      "text": "The main differences between HPKP and the current document are the following:",
      "ja": "HPKPと現在のドキュメントの主な違いは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* HPKP limits its scope to HTTPS, while the current document considers all application above TLS.",
      "ja": "* HPKPはその範囲をHTTPSに制限していますが、現在のドキュメントではすべてのアプリケーションがTLSを超えていると考えています。"
    },
    {
      "indent": 3,
      "text": "* HPKP pins the public key of the server (or another public key along the certificate chain), and as such, is highly dependent on the management of certificates. Such dependency increases the potential error surface, especially as certificate management is not yet largely automated. The current proposal, on the other hand, is independent of certificate management.",
      "ja": "* HPKPはサーバーの公開キー（または証明書チェーンに沿った別の公開キー）を固定するため、証明書の管理に大きく依存しています。 このような依存関係は、特に証明書管理がまだほとんど自動化されていないため、潜在的なエラーサーフェスを増やします。 一方、現在の提案は証明書管理とは無関係です。"
    },
    {
      "indent": 3,
      "text": "* HPKP pins public keys that are public and used for the standard TLS authentication. Identity pinning relies on the ownership of the pinning key, which is not disclosed to the public and not involved in the standard TLS authentication. As a result, identity pinning is a completely independent, second-factor authentication mechanism.",
      "ja": "* HPKPは、公開され、標準TLS認証に使用される公開鍵を固定します。 IDピニングは、ピニングキーの所有権に依存します。これは、公開されておらず、標準のTLS認証に関与していません。 その結果、IDピンニングは完全に独立した第2要素認証メカニズムです。"
    },
    {
      "indent": 3,
      "text": "* HPKP relies on a backup key to recover the misissuance of a key. We believe such backup mechanisms add excessive complexity and cost. Reliability of the current mechanism is primarily based on its being highly automated.",
      "ja": "* HPKPは、キーの誤発行を回復するためにバックアップキーに依存しています。 このようなバックアップメカニズムは、過度の複雑さとコストを追加すると考えています。 現在のメカニズムの信頼性は、主に高度に自動化されていることに基づいています。"
    },
    {
      "indent": 3,
      "text": "* HPKP relies on the client to report errors to the report-uri. The current document does not need any out-of-band mechanism, and the server is informed automatically. This provides an easier and more reliable health monitoring.",
      "ja": "* HPKPはクライアントに依存して、エラーをreport-uriに報告します。 現在のドキュメントには帯域外メカニズムは必要なく、サーバーには自動的に通知されます。 これにより、より簡単で信頼性の高いヘルスモニタリングが提供されます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, HPKP shares the following aspects with identity pinning:",
      "ja": "一方、HPKPは次の側面をIDピンニングと共有しています。"
    },
    {
      "indent": 3,
      "text": "* Both mechanisms provide hard failure. With HPKP, only the client is aware of the failure, while with the current proposal both client and server are informed of the failure. This provides room for further mechanisms to automatically recover from such failures.",
      "ja": "* 両方のメカニズムはハード障害を提供します。 HPKPでは、クライアントのみが障害を認識しますが、現在の提案では、クライアントとサーバーの両方に障害が通知されます。 これにより、このような障害から自動的に回復するためのさらなるメカニズムの余地が提供されます。"
    },
    {
      "indent": 3,
      "text": "* Both mechanisms are subject to a server compromise in which users are provided with an invalid ticket (e.g., a random one) or HTTP header with a very long lifetime. For identity pinning, this lifetime SHOULD NOT be longer than 31 days. In both cases, clients will not be able to reconnect the server during this lifetime. With the current proposal, an attacker needs to compromise the TLS layer, while with HPKP, the attacker needs to compromise the HTTP server. Arguably, the TLS-level compromise is typically more difficult for the attacker.",
      "ja": "* 両方のメカニズムは、ユーザーに無効なチケット（ランダムなチケットなど）または非常に長い有効期間のHTTPヘッダーが提供されるサーバー侵害の影響を受けます。 IDのピン留めの場合、この有効期間は31日を超えてはなりません。 どちらの場合も、クライアントはこの存続期間中にサーバーに再接続できません。 現在の提案では、攻撃者はTLSレイヤーを侵害する必要がありますが、HPKPでは、攻撃者はHTTPサーバーを侵害する必要があります。 おそらく、TLSレベルの侵害は通常、攻撃者にとってより困難です。"
    },
    {
      "indent": 3,
      "text": "Unfortunately HPKP has not seen wide deployment yet. As of March 2016, the number of servers using HPKP was less than 3000 [Netcraft]. This may simply be due to inertia, but we believe the main reason is the interactions between HPKP and manual certificate management that is needed to implement HPKP for enterprise servers. The penalty for making mistakes (e.g., being too early or too late to deploy new pins) is that the server becomes unusable for some of the clients.",
      "ja": "残念ながら、HPKPはまだ広く展開されていません。 2016年3月現在、HPKPを使用しているサーバーの数は3000 [Netcraft]未満でした。 これは単に慣性によるものかもしれませんが、主な理由は、HPKPとエンタープライズサーバーにHPKPを実装するために必要な手動証明書管理との相互作用であると考えています。 ミスを犯した場合のペナルティ（新しいピンを展開するには遅すぎたり遅すぎたりするなど）は、一部のクライアントがサーバーを使用できなくなることです。"
    },
    {
      "indent": 3,
      "text": "To demonstrate this point, we present a list of the steps involved in deploying HPKP on a security-sensitive web server.",
      "ja": "この点を示すために、セキュリティに敏感なWebサーバーにHPKPを展開するために必要な手順のリストを示します。"
    },
    {
      "indent": 3,
      "text": "1. Generate two public/private key pairs on a computer that is not the live server. The second one is the \"backup1\" key pair.",
      "ja": "1. ライブサーバーではないコンピューターで2つの公開キーと秘密キーのペアを生成します。 2番目は「backup1」キーペアです。"
    },
    {
      "indent": 8,
      "text": "openssl genrsa -out \"example.com.key\" 2048;",
      "ja": "openssl genrsa -out \"example.com.key\" 2048;"
    },
    {
      "indent": 8,
      "text": "openssl genrsa -out \"example.com.backup1.key\" 2048;",
      "ja": "openssl genrsa -out \"example.com.backup1.key\" 2048;"
    },
    {
      "indent": 3,
      "text": "2. Generate hashes for both of the public keys. These will be used in the HPKP header:",
      "ja": "2. 両方の公開鍵のハッシュを生成します。 これらはHPKPヘッダーで使用されます。"
    },
    {
      "indent": 8,
      "text": "openssl rsa -in \"example.com.key\" -outform der -pubout | \\\nopenssl dgst -sha256 -binary | openssl enc -base64",
      "raw": true
    },
    {
      "indent": 8,
      "text": "openssl rsa -in \"example.com.backup1.key\" -outform der \\\n-pubout | openssl dgst -sha256 -binary | openssl enc -base64",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Generate a single CSR (Certificate Signing Request) for the first key pair, where you include the domain name in the CN (Common Name) field:",
      "ja": "3. 最初のキーペアに対して単一のCSR（証明書署名要求）を生成します。CN（共通名）フィールドにドメイン名を含めます。"
    },
    {
      "indent": 8,
      "text": "openssl req -new -subj \"/C=GB/ST=Area/L=Town/O=Org/ \\\nCN=example.com\" -key \"example.com.key\" -out \"example.com.csr\";",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. Send this CSR to the CA and go though the dance to prove you own the domain. The CA will give you a single certificate that will typically expire within a year or two.",
      "ja": "4. このCSRをCAに送信し、ダンスを行って、ドメインを所有していることを証明します。 CAは、通常1〜2年以内に期限切れになる単一の証明書を提供します。"
    },
    {
      "indent": 3,
      "text": "5. On the live server, upload and set up the first key pair and its certificate. At this point, you can add the \"Public-Key-Pins\" header, using the two hashes you created in step 2.",
      "ja": "5. ライブサーバーで、最初のキーペアとその証明書をアップロードして設定します。 この時点で、手順2で作成した2つのハッシュを使用して、「Public-Key-Pins」ヘッダーを追加できます。"
    },
    {
      "indent": 8,
      "text": "Note that only the first key pair has been uploaded to the server so far.",
      "ja": "これまでは、最初のキーペアのみがサーバーにアップロードされていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "6. Store the second (backup1) key pair somewhere safe, probably somewhere encrypted like a password manager. It won't expire, as it's just a key pair; it just needs to be ready for when you need to get your next certificate.",
      "ja": "6. 2番目の（backup1）キーペアを安全な場所、おそらくパスワードマネージャーのように暗号化された場所に保存します。 キーペアにすぎないため、有効期限はありません。 次の証明書を取得する必要がある場合に備えて準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "7. Time passes -- probably just under a year (if waiting for a certificate to expire), or maybe sooner if you find that your server has been compromised, and you need to replace the key pair and certificate.",
      "ja": "7. 時間が経ちます-おそらく1年弱（証明書の有効期限が切れるのを待っている場合）、またはサーバーが危険にさらされていることがわかった場合はすぐにキーペアと証明書を交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "8. Create a new CSR using the \"backup1\" key pair, and get a new certificate from your CA.",
      "ja": "8. 「backup1」キーペアを使用して新しいCSRを作成し、CAから新しい証明書を取得します。"
    },
    {
      "indent": 3,
      "text": "9. Generate a new backup key pair (backup2), get its hash, and store it in a safe place (again, not on the live server).",
      "ja": "9. 新しいバックアップキーペア（backup2）を生成し、そのハッシュを取得して、安全な場所に（再び、ライブサーバー上ではなく）保存します。"
    },
    {
      "indent": 3,
      "text": "10. Replace your old certificate and old key pair, update the \"Public-Key-Pins\" header to remove the old hash, and add the new \"backup2\" key pair.",
      "ja": "10. 古い証明書と古いキーペアを置き換え、「Public-Key-Pins」ヘッダーを更新して古いハッシュを削除し、新しい「backup2」キーペアを追加します。"
    },
    {
      "indent": 3,
      "text": "Note that in the above steps, both the certificate issuance as well as the storage of the backup key pair involve manual steps. Even with an automated CA that runs the ACME protocol [RFC8555], key backup would be a challenge to automate.",
      "ja": "上記の手順では、証明書の発行とバックアップキーペアの保存の両方に手動の手順が必要であることに注意してください。 ACMEプロトコル[RFC8555]を実行する自動CAを使用しても、キーのバックアップは自動化の課題になります。"
    },
    {
      "indent": 0,
      "text": "A.2. Comparison: TACK",
      "section_title": true,
      "ja": "A.2. 比較：TACK"
    },
    {
      "indent": 3,
      "text": "Compared with HPKP, TACK [TLS-TACK] is more similar to the current document. It can even be argued that this document is a symmetric-cryptography variant of TACK. That said, there are still a few significant differences:",
      "ja": "HPKPと比較して、TACK [TLS-TACK]は現在のドキュメントにより類似しています。 このドキュメントはTACKの対称暗号化版であると主張することさえできます。 ただし、まだいくつかの重要な違いがあります。"
    },
    {
      "indent": 3,
      "text": "* Probably the most important difference is that with TACK, validation of the server certificate is no longer required, and in fact TACK specifies it as a \"MAY\" requirement ([TLS-TACK], Section 5.3). With ticket pinning, certificate validation by the client remains a MUST requirement, and the ticket acts only as a second factor. If the pinning secret is compromised, the server's security is not immediately at risk.",
      "ja": "* おそらく最も重要な違いは、TACKを使用すると、サーバー証明書の検証が不要になり、実際、TACKがそれを「MAY」要件として指定することです（[TLS-TACK]、セクション5.3）。 チケットの固定では、クライアントによる証明書の検証は必須要件のままであり、チケットは2番目の要素としてのみ機能します。 ピニングシークレットが侵害された場合、サーバーのセキュリティはすぐに危険にさらされることはありません。"
    },
    {
      "indent": 3,
      "text": "* Both TACK and the current document are mostly orthogonal to the server certificate as far as their life cycle, and so both can be deployed with no manual steps.",
      "ja": "* TACKと現在のドキュメントはどちらも、そのライフサイクルに関してはほとんどサーバー証明書と直交しているため、手動の手順なしで両方を展開できます。"
    },
    {
      "indent": 3,
      "text": "* TACK uses Elliptic Curve Digital Signature Algorithm (ECDSA) to sign the server's public key. This allows cooperating clients to share server assertions between themselves. This is an optional TACK feature, and one that cannot be done with pinning tickets.",
      "ja": "* TACKは、楕円曲線デジタル署名アルゴリズム（ECDSA）を使用して、サーバーの公開キーに署名します。 これにより、協力するクライアントはサーバーアサーションを共有できます。 これはオプションのTACK機能であり、チケットの固定では実行できません。"
    },
    {
      "indent": 3,
      "text": "* TACK allows multiple servers to share its public keys. Such sharing is disallowed by the current document.",
      "ja": "* TACKにより、複数のサーバーが公開鍵を共有できます。 このような共有は、現在のドキュメントでは許可されていません。"
    },
    {
      "indent": 3,
      "text": "* TACK does not allow the server to track a particular client, and so has better privacy properties than the current document.",
      "ja": "* TACKは、サーバーが特定のクライアントを追跡することを許可しないため、現在のドキュメントよりも優れたプライバシープロパティを持ちます。"
    },
    {
      "indent": 3,
      "text": "* TACK has an interesting way to determine the pin's lifetime, setting it to the time period since the pin was first observed, with a hard upper bound of 30 days. The current document makes the lifetime explicit, which may be more flexible to deploy. For example, web sites that are only visited rarely by users may opt for a longer period than other sites that expect users to visit on a daily basis.",
      "ja": "* TACKにはピンの寿命を決定する興味深い方法があり、ピンが最初に観測されてからの期間に設定され、30日間という厳しい上限があります。 現在のドキュメントでは、ライフタイムを明示的にしています。これにより、展開の柔軟性が高まります。 たとえば、ユーザーがめったにアクセスしないWebサイトは、ユーザーが毎日アクセスすることを期待する他のサイトよりも長い期間選択する可能性があります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The original idea behind this proposal was published in [Oreo] by Moti Yung, Benny Pinkas, and Omer Berkman. The current protocol is but a distant relative of the original Oreo protocol, and any errors are the responsibility of the authors of this document alone.",
      "ja": "この提案の背後にある元のアイデアは、[Oreo]でMoti Yung、Benny Pinkas、およびOmer Berkmanによって公開されました。 現在のプロトコルは、元のOreoプロトコルとはかなり遠いものであり、エラーはすべてこのドキュメントの著者の責任です。"
    },
    {
      "indent": 3,
      "text": "We would like to thank Adrian Farrel, Dave Garrett, Daniel Kahn Gillmor, Alexey Melnikov, Yoav Nir, Eric Rescorla, Benjamin Kaduk, and Rich Salz for their comments on this document. Special thanks to Craig Francis for contributing the HPKP deployment script, and to Ralph Holz for several fruitful discussions.",
      "ja": "このドキュメントに関するコメントについては、Adrian Farrel、Dave Garrett、Daniel Kahn Gillmor、Alexey Melnikov、Yoav Nir、Eric Rescorla、Benjamin Kaduk、およびRich Salzに感謝します。 HPKP展開スクリプトを提供してくれたCraig Francisと、実りある議論をしてくれたRalph Holzに特に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yaron Sheffer Intuit",
      "ja": "ヤロン・シェファーの直観"
    },
    {
      "indent": 3,
      "text": "Email: yaronf.ietf@gmail.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Daniel Migault Ericsson",
      "ja": "ダニエル・ミゴール・エリクソン"
    },
    {
      "indent": 3,
      "text": "Email: daniel.migault@ericsson.com",
      "raw": true
    }
  ]
}