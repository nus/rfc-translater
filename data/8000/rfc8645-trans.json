{
  "title": {
    "text": "RFC 8645 - Re-keying Mechanisms for Symmetric Keys",
    "ja": "RFC 8645 - 対称キーのキー変更メカニズム"
  },
  "number": 8645,
  "created_at": "2020-03-09 19:09:51.332436+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                   S. Smyshlyaev, Ed.\nRequest for Comments: 8645                                     CryptoPro\nCategory: Informational                                      August 2019\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Re-keying Mechanisms for Symmetric Keys",
      "ja": "対称キーのキー変更メカニズム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "A certain maximum amount of data can be safely encrypted when encryption is performed under a single key. This amount is called the \"key lifetime\". This specification describes a variety of methods for increasing the lifetime of symmetric keys. It provides two types of re-keying mechanisms based on hash functions and block ciphers that can be used with modes of operations such as CTR, GCM, CBC, CFB, and OMAC.",
      "ja": "単一のキーで暗号化を実行すると、特定の最大量のデータを安全に暗号化できます。 この量は「キーの有効期間」と呼ばれます。 この仕様は、対称キーの寿命を延ばすためのさまざまな方法を説明しています。 CTR、GCM、CBC、CFB、OMACなどの操作モードで使用できるハッシュ関数とブロック暗号に基づく2種類のキー再生成メカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "このドキュメントは、IRTFのCrypto Forum Research Group（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Research Task Force（IRTF）の製品です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。 これらの結果は、展開に適さない場合があります。 このRFCは、インターネット研究特別調査委員会（IRTF）の暗号フォーラム研究グループのコンセンサスを表しています。 IRSGによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補でもありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8645.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8645で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Conventions Used in This Document . . . . . . . . . . . . . .   7\n3.  Basic Terms and Definitions . . . . . . . . . . . . . . . . .   7\n4.  Choosing Constructions and Security Parameters  . . . . . . .   9\n5.  External Re-keying Mechanisms . . . . . . . . . . . . . . . .  11\n  5.1.  Methods of Key Lifetime Control . . . . . . . . . . . . .  14\n  5.2.  Parallel Constructions  . . . . . . . . . . . . . . . . .  14\n    5.2.1.  Parallel Construction Based on a KDF on a Block\n            Cipher  . . . . . . . . . . . . . . . . . . . . . . .  15\n    5.2.2.  Parallel Construction Based on a KDF on a Hash\n            Function  . . . . . . . . . . . . . . . . . . . . . .  16\n    5.2.3.  Tree-Based Construction . . . . . . . . . . . . . . .  16\n  5.3.  Serial Constructions  . . . . . . . . . . . . . . . . . .  17\n    5.3.1.  Serial Construction Based on a KDF on a Block Cipher   19\n    5.3.2.  Serial Construction Based on a KDF on a Hash Function  19\n  5.4.  Using Additional Entropy during Re-keying . . . . . . . .  19\n6.  Internal Re-keying Mechanisms . . . . . . . . . . . . . . . .  20\n  6.1.  Methods of Key Lifetime Control . . . . . . . . . . . . .  22\n  6.2.  Constructions that Do Not Require a Master Key  . . . . .  23\n    6.2.1.  ACPKM Re-keying Mechanisms  . . . . . . . . . . . . .  23\n    6.2.2.  CTR-ACPKM Encryption Mode . . . . . . . . . . . . . .  25\n    6.2.3.  GCM-ACPKM Authenticated Encryption Mode . . . . . . .  26\n  6.3.  Constructions that Require a Master Key . . . . . . . . .  29\n    6.3.1.  ACPKM-Master Key Derivation from the Master Key . . .  29\n    6.3.2.  CTR-ACPKM-Master Encryption Mode  . . . . . . . . . .  31\n    6.3.3.  GCM-ACPKM-Master Authenticated Encryption Mode  . . .  33\n    6.3.4.  CBC-ACPKM-Master Encryption Mode  . . . . . . . . . .  37\n    6.3.5.  CFB-ACPKM-Master Encryption Mode  . . . . . . . . . .  39\n    6.3.6.  OMAC-ACPKM-Master Authentication Mode . . . . . . . .  40\n7.  Joint Usage of External and Internal Re-keying  . . . . . . .  42\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  43\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  43\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  44\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  44\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  45\nAppendix A.  Test Examples  . . . . . . . . . . . . . . . . . . .  48\n  A.1.  Test Examples for External Re-keying  . . . . . . . . . .  48\n    A.1.1.  External Re-keying with a Parallel Construction . . .  48\n    A.1.2.  External Re-keying with a Serial Construction . . . .  49\n  A.2.  Test Examples for Internal Re-keying  . . . . . . . . . .  52\n    A.2.1.  Internal Re-keying Mechanisms that Do Not\n            Require a Master Key  . . . . . . . . . . . . . . . .  52\n    A.2.2.  Internal Re-keying Mechanisms with a Master Key . . .  56\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  69\nContributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  69\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  69",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A certain maximum amount of data can be safely encrypted when encryption is performed under a single key. Hereinafter, this amount will be referred to as the \"key lifetime\". The need for such a limitation is dictated by the following methods of cryptanalysis:",
      "ja": "単一のキーで暗号化を実行すると、特定の最大量のデータを安全に暗号化できます。 以下、この量を「キーの有効期間」と呼びます。 このような制限の必要性は、次の暗号解析方法によって決まります。"
    },
    {
      "indent": 3,
      "text": "1. Methods based on the combinatorial properties of the used block cipher mode of operation",
      "ja": "1. 使用されるブロック暗号操作モードの組み合わせ特性に基づく方法"
    },
    {
      "indent": 10,
      "text": "These methods do not depend on the underlying block cipher. Common mode restrictions derived from such methods are of order 2^{n/2}, where n is a block size defined in Section 3. [Sweet32] includes an example of an attack that is based on such methods.",
      "ja": "これらのメソッドは、基礎となるブロック暗号に依存しません。 そのような方法から派生したコモンモードの制限は2 ^ {n / 2}の順序です。nはセクション3で定義されたブロックサイズです。[Sweet32]には、そのような方法に基づく攻撃の例が含まれています。"
    },
    {
      "indent": 3,
      "text": "2. Methods based on side-channel analysis issues",
      "ja": "2. サイドチャネル分析の問題に基づく方法"
    },
    {
      "indent": 10,
      "text": "In most cases, these methods do not depend on the used encryption modes and weakly depend on the used cipher features. Limitations resulting from these considerations are usually the most restrictive ones. [TEMPEST] is an example of an attack that is based on such methods.",
      "ja": "ほとんどの場合、これらの方法は使用される暗号化モードに依存せず、使用される暗号機能に弱く依存します。 これらの考慮事項から生じる制限は、通常、最も制限的なものです。 [TEMPEST]は、そのような方法に基づく攻撃の例です。"
    },
    {
      "indent": 3,
      "text": "3. Methods based on the properties of the used block cipher",
      "ja": "3. 使用されるブロック暗号のプロパティに基づくメソッド"
    },
    {
      "indent": 10,
      "text": "The most common methods of this type are linear and differential cryptanalysis [LDC]. In most cases, these methods do not depend on the used modes of operation. In the case of secure block ciphers, bounds resulting from such methods are roughly the same as the natural bounds of 2^n and are dominated by the other bounds above. Therefore, they can be excluded from the considerations here.",
      "ja": "このタイプの最も一般的な方法は、線形および差分暗号解析[LDC]です。 ほとんどの場合、これらの方法は使用される動作モードに依存しません。 安全なブロック暗号の場合、そのような方法から生じる境界は、2 ^ nの自然な境界とほぼ同じであり、上記の他の境界によって支配されます。 したがって、ここでの考慮事項から除外できます。"
    },
    {
      "indent": 3,
      "text": "As a result, it is important to replace a key when the total size of the processed plaintext under that key approaches the lifetime limitation. A specific value of the key lifetime should be determined in accordance with some safety margin for protocol security and the methods outlined above.",
      "ja": "その結果、キーの下で処理されたプレーンテキストの合計サイズがライフタイムの制限に近づいたときに、キーを置き換えることが重要です。 キーの寿命の特定の値は、プロトコルセキュリティの安全マージンと上記の方法に従って決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose L is a key lifetime limitation in some protocol P. For simplicity, assume that all messages have the same length m. Hence, the number of messages q that can be processed with a single key K should be such that m * q <= L. This can be depicted graphically as a rectangle with sides m and q enclosed by area L (see Figure 1).",
      "ja": "Lが一部のプロトコルPのキーの有効期間の制限であると仮定します。簡単にするために、すべてのメッセージの長さは同じであると仮定しますm したがって、単一のキーKで処理できるメッセージqの数は、m * q <= Lになるようにする必要があります。これは、辺mとqが領域Lで囲まれた長方形としてグラフィカルに描くことができます（図1を参照）。"
    },
    {
      "indent": 22,
      "text": "+------------------------+\n|                      L |\n| +--------m---------+   |\n| |==================|   |\n| |==================|   |\n| q==================|   |       m * q <= L\n| |==================|   |\n| |==================|   |\n| +------------------+   |\n+------------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 1: Graphic Display of the Key Lifetime Limitation",
      "ja": "図1：主要な寿命制限のグラフィック表示"
    },
    {
      "indent": 3,
      "text": "In practice, the amount of data that corresponds to limitation L may not be enough. The simplest and obvious solution in this situation is a regular renegotiation of an initial key after processing this threshold amount of data L. However, this reduces the total performance, since it usually entails termination of application data transmission, additional service messages, the use of a random number generator, and many other additional calculations, including resource-intensive public key cryptography.",
      "ja": "実際には、制限Lに対応するデータの量では十分でない場合があります。 この状況で最も簡単で明白な解決策は、このデータ量のしきい値Lを処理した後の初期キーの定期的な再ネゴシエーションです。ただし、通常、アプリケーションデータ送信の終了、追加のサービスメッセージ、 乱数ジェネレーター、および他の多くの追加計算（リソース集約型の公開キー暗号化を含む）。"
    },
    {
      "indent": 3,
      "text": "For protocols based on block ciphers or stream ciphers, a more efficient way to increase the key lifetime is to use various re-keying mechanisms. This specification considers re-keying mechanisms for block ciphers only; re-keying mechanisms typical for stream ciphers (e.g., [Pietrzak2009], [FPS2012]) are beyond the scope of this document.",
      "ja": "ブロック暗号またはストリーム暗号に基づくプロトコルの場合、キーの有効期間を延長するより効率的な方法は、さまざまなキー変更メカニズムを使用することです。 この仕様では、ブロック暗号のキー再生成メカニズムのみを考慮しています。 ストリーム暗号に典型的なキー再生成メカニズム（[Pietrzak2009]、[FPS2012]など）は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Re-keying mechanisms can be applied at the different protocol levels: the block cipher level (this approach is known as fresh re-keying and is described, for instance, in [FRESHREKEYING]; the block cipher mode of operation level (see Section 6); and the protocol level above the block cipher mode of operation (see Section 5). The usage of the first approach is highly inefficient due to the key changing after each message block is processed. Moreover, fresh re-keying mechanisms can change the block cipher internal structure and, consequently, can require an additional security analysis for each particular block cipher. As a result, this approach depends on particular primitive properties and cannot be applied to any arbitrary block cipher without additional security analysis. Therefore, fresh re-keying mechanisms go beyond the scope of this document.",
      "ja": "キー再生成メカニズムは、さまざまなプロトコルレベルで適用できます。ブロック暗号レベル（このアプローチはフレッシュキー再生成と呼ばれ、たとえば[FRESHREKEYING]で説明されています。ブロック暗号モードの操作レベル（セクション6を参照） ）;およびブロック暗号操作モードより上のプロトコルレベル（セクション5を参照）。各メッセージブロックの処理後にキーが変更されるため、最初のアプローチの使用は非常に非効率的です。 ブロック暗号の内部構造のため、特定のブロック暗号ごとに追加のセキュリティ分析が必要になる可能性があるため、このアプローチは特定のプリミティブプロパティに依存し、追加のセキュリティ分析なしでは任意のブロック暗号に適用できません。 キーイングメカニズムは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "Thus, this document contains the list of recommended re-keying mechanisms that can be used in the symmetric encryption schemes based on the block ciphers. These mechanisms are independent from the particular block cipher specification, and their security properties rely only on the standard block cipher security assumption.",
      "ja": "したがって、このドキュメントには、ブロック暗号に基づく対称暗号化スキームで使用できる推奨されるキー再生成メカニズムのリストが含まれています。 これらのメカニズムは特定のブロック暗号仕様から独立しており、それらのセキュリティプロパティは標準のブロック暗号セキュリティの前提のみに依存しています。"
    },
    {
      "indent": 3,
      "text": "This specification presents two basic approaches to extending the lifetime of a key while avoiding renegotiation, which were introduced in [AAOS2017]:",
      "ja": "この仕様は、[AAOS2017]で導入された、再ネゴシエーションを回避しながらキーの寿命を延長するための2つの基本的なアプローチを示します。"
    },
    {
      "indent": 3,
      "text": "1. External re-keying",
      "ja": "1. 外部キー再生成"
    },
    {
      "indent": 6,
      "text": "External re-keying is performed by a protocol, and it is independent of the underlying block cipher and the mode of operation. External re-keying can use parallel and serial constructions. In the parallel case, data processing keys K^1, K^2, ... are generated directly from the initial key K independently of each other. In the serial case, every data-processing key depends on the state that is updated after the generation of each new data-processing key.",
      "ja": "外部のキー再生成はプロトコルによって実行され、基盤となるブロック暗号や動作モードには依存しません。 外部キー再生成では、パラレルおよびシリアル構成を使用できます。 並列の場合、データ処理キーK ^ 1、K ^ 2、...は、互いに独立して初期キーKから直接生成されます。 シリアルの場合、すべてのデータ処理キーは、各新しいデータ処理キーの生成後に更新される状態に依存します。"
    },
    {
      "indent": 6,
      "text": "As a generalization of external parallel re-keying, an external tree-based mechanism can be considered. It is specified in Section 5.2.3 and can be viewed as the tree generalization in [GGM]. Similar constructions are used in the one-way tree mechanism ([OWT]) and [AESDUKPT] standard.",
      "ja": "外部並列キー再生成の一般化として、外部ツリーベースのメカニズムを検討できます。 セクション5.2.3で指定されており、[GGM]でツリーの一般化として見ることができます。 同様の構造は、一方向ツリーメカニズム（[OWT]）および[AESDUKPT]標準で使用されます。"
    },
    {
      "indent": 3,
      "text": "2. Internal re-keying",
      "ja": "2. 内部キー再生成"
    },
    {
      "indent": 6,
      "text": "Internal re-keying is built into the mode, and it depends heavily on the properties of the mode of operation and the block size.",
      "ja": "内部キー再生成はモードに組み込まれており、動作モードのプロパティとブロックサイズに大きく依存します。"
    },
    {
      "indent": 3,
      "text": "The re-keying approaches extend the key lifetime for a single initial key by allowing the leakages to be limited (via side channels) and by improving the combinatorial properties of the used block cipher mode of operation.",
      "ja": "再キーイングアプローチは、（サイドチャネルを介して）漏洩を制限できるようにし、使用するブロック暗号モードの組み合わせ特性を改善することにより、単一の初期キーのキーの有効期間を延長します。"
    },
    {
      "indent": 3,
      "text": "In practical applications, re-keying can be useful for protocols that need to operate in hostile environments or under restricted resource conditions (e.g., those that require lightweight cryptography, where ciphers have a small block size that imposes strict combinatorial limitations). Moreover, mechanisms that use external or internal re-keying may provide some protection against possible future attacks (by limiting the number of plaintext-ciphertext pairs that an adversary can collect) and some properties of forward or backward security (meaning that past or future data-processing keys remain secure even if the current key is compromised; see [AbBell] for more details). External or internal re-keying can be used in network protocols as well as in the systems for data-at-rest encryption.",
      "ja": "実際のアプリケーションでは、キーの再生成は、敵対的な環境または制限されたリソース条件で動作する必要のあるプロトコル（たとえば、暗号のブロックサイズが小さく、厳密な組み合わせの制限が課される軽量暗号化が必要なプロトコル）に役立ちます。 さらに、外部または内部のキー再生成を使用するメカニズムは、（攻撃者が収集できる平文と暗号文のペアの数を制限することにより）将来起こりうる攻撃に対するいくつかの保護と、フォワードまたはバックワードセキュリティ（過去または未来のデータを意味する） -現在のキーが危険にさらされた場合でも、処理キーは安全なままです。詳細については、[AbBell]を参照してください。 外部または内部のキー再生成は、ネットワークプロトコルおよび保存データの暗号化システムで使用できます。"
    },
    {
      "indent": 3,
      "text": "Depending on the concrete protocol characteristics, there might be situations in which both external and internal re-keying mechanisms (see Section 7) can be applied. For example, a similar approach was used in Taha's tree construction (see [TAHA]).",
      "ja": "具体的なプロトコル特性に応じて、外部および内部の両方のキー再生成メカニズム（セクション7を参照）を適用できる状況があります。 たとえば、Tahaのツリー構造で同様のアプローチが使用されました（[TAHA]を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that there are key-updating (key regression) algorithms (e.g., [FKK2005] and [KMNT2003]) that are called \"re-keying\" as well, but they pursue goals other than increasing the key lifetime. Therefore, key regression algorithms are excluded from the considerations here.",
      "ja": "「再キーイング」と呼ばれるキー更新（キー回帰）アルゴリズム（[FKK2005]および[KMNT2003]など）もありますが、キーの有効期間の延長以外の目標を追求していることに注意してください。 したがって、ここでは重要な回帰アルゴリズムは考慮事項から除外されます。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG).",
      "ja": "このドキュメントは、暗号フォーラム研究グループ（CFRG）のコンセンサスを表しています。"
    },
    {
      "indent": 0,
      "text": "2. Conventions Used in This Document",
      "section_title": true,
      "ja": "2. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Basic Terms and Definitions",
      "section_title": true,
      "ja": "3. 基本的な用語と定義"
    },
    {
      "indent": 3,
      "text": "This document uses the following terms and definitions for the sets and operations on the elements of these sets:",
      "ja": "このドキュメントでは、セットおよびこれらのセットの要素に対する操作について、次の用語と定義を使用します。"
    },
    {
      "indent": 3,
      "text": "V* the set of all bit strings of a finite length (hereinafter referred to as strings), including the empty string;",
      "ja": "V *空の文字列を含む、有限長のすべてのビット文字列（以降、文字列と呼びます）のセット。"
    },
    {
      "indent": 3,
      "text": "V_s the set of all bit strings of length s, where s is a non-negative integer;",
      "ja": "V_s長さsのすべてのビット文字列のセット。ここで、sは非負の整数です。"
    },
    {
      "indent": 3,
      "text": "|X| the bit length of the bit string X;",
      "ja": "| X | ビット文字列Xのビット長。"
    },
    {
      "indent": 3,
      "text": "A | B the concatenation of strings A and B both belonging to V*, i.e., a string in V_{|A|+|B|}, where the left substring in V_|A| is equal to A and the right substring in V_|B| is equal to B;",
      "ja": "A | B両方がV *に属する文字列AとBの連結、つまりV_ {| A | + | B |}の文字列。ここで、V_ | A |の左の部分文字列 はAに等しく、V_ | B |の右部分文字列 Bに等しい;"
    },
    {
      "indent": 3,
      "text": "(xor) the exclusive-or of two bit strings of the same length;",
      "ja": "（xor）同じ長さの2ビット文字列の排他的論理和。"
    },
    {
      "indent": 3,
      "text": "Z_{2^n} the ring of residues modulo 2^n;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Int_s: V_s -> Z_{2^s}\n        the transformation that maps the string a = (a_s, ... , a_1)\n        in V_s into the integer Int_s(a) = 2^{s-1} * a_s + ... + 2 *\n        a_2 + a_1 (the interpretation of the binary string as an\n        integer);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Vec_s: Z_{2^s} -> V_s\n        the transformation inverse to the mapping Int_s (the\n        interpretation of an integer as a binary string);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "MSB_i: V_s -> V_i\n        the transformation that maps the string a = (a_s, ... , a_1)\n        in V_s into the string MSB_i(a) = (a_s, ... , a_{s-i+1}) in\n        V_i (most significant bits);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "LSB_i: V_s -> V_i\n        the transformation that maps the string a = (a_s, ... , a_1)\n        in V_s into the string LSB_i(a) = (a_i, ... , a_1) in V_i\n        (least significant bits);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Inc_c: V_s -> V_s\n        the transformation that maps the string a = (a_s, ... , a_1)\n        in V_s into the string Inc_c(a) = MSB_{|a|-c}(a) |\n        Vec_c(Int_c(LSB_c(a)) + 1(mod 2^c)) in V_s (incrementing the\n        least significant c bits of the bit string, regarded as the\n        binary representation of an integer);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "a^s the string in V_s that consists of s 'a' bits;",
      "ja": "a ^ s s 'a'ビットで構成されるV_sの文字列。"
    },
    {
      "indent": 3,
      "text": "E_{K}: V_n -> V_n\n        the block cipher permutation under the key K in V_k;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ceil(x) the smallest integer that is greater than or equal to x;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "floor(x) the biggest integer that is less than or equal to x;",
      "ja": "floor（x）x以下の最大の整数。"
    },
    {
      "indent": 3,
      "text": "k the bit length of the K; k is assumed to be divisible by 8;",
      "ja": "k Kのビット長。 kは8で割り切れると仮定されます。"
    },
    {
      "indent": 3,
      "text": "n the block size of the block cipher (in bits); n is assumed to be divisible by 8;",
      "ja": "nブロック暗号のブロックサイズ（ビット単位）。 nは8で割り切れると想定されています。"
    },
    {
      "indent": 3,
      "text": "b       the number of data blocks in the plaintext P (b =\n        ceil(|P|/n));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "N the section size (the number of bits that are processed with one section key before this key is transformed).",
      "ja": "Nセクションサイズ（このキーが変換される前に1つのセクションキーで処理されるビット数）。"
    },
    {
      "indent": 3,
      "text": "A plaintext message P and the corresponding ciphertext C are divided into b = ceil(|P|/n) blocks, denoted as P = P_1 | P_2 | ... | P_b and C = C_1 | C_2 | ... | C_b, respectively. The first b-1 blocks P_i and C_i are in V_n for i = 1, 2, ... , b-1. The b-th blocks P_b and C_b may be incomplete blocks, i.e., in V_r, where r <= n if not otherwise specified.",
      "ja": "平文メッセージPと対応する暗号文Cは、b = ceil（| P | / n）ブロックに分割され、P = P_1 | P_2 | ... | P_bおよびC = C_1 | C_2 | ... | それぞれC_b。 最初のb-1ブロックP_iおよびC_iは、i = 1、2、...、b-1の場合V_nにあります。 b番目のブロックP_bおよびC_bは、不完全なブロック、つまりV_rである場合があります。ここで、特に指定がない限り、r <= nです。"
    },
    {
      "indent": 0,
      "text": "4. Choosing Constructions and Security Parameters",
      "section_title": true,
      "ja": "4. 構造とセキュリティパラメータの選択"
    },
    {
      "indent": 3,
      "text": "External re-keying is an approach assuming that a key is transformed after encrypting a limited number of entire messages. The external re-keying method is chosen at the protocol level, regardless of the underlying block cipher or the encryption mode. External re-keying is recommended for protocols that process relatively short messages or protocols that have a way to divide a long message into manageable pieces. Through external re-keying, the number of messages that can be securely processed with a single initial key K is substantially increased without a loss of message length.",
      "ja": "外部キー再生成は、限られた数のメッセージ全体を暗号化した後にキーが変換されることを想定したアプローチです。 外部のキー再生成方法は、基礎となるブロック暗号または暗号化モードに関係なく、プロトコルレベルで選択されます。 外部のキー再生成は、比較的短いメッセージを処理するプロトコル、または長いメッセージを管理可能な部分に分割する方法があるプロトコルに推奨されます。 外部キー再生成により、単一の初期キーKで安全に処理できるメッセージの数は、メッセージの長さを失うことなく大幅に増加します。"
    },
    {
      "indent": 3,
      "text": "External re-keying has the following advantages",
      "ja": "外部キー再生成には次の利点があります"
    },
    {
      "indent": 3,
      "text": "1. It increases the lifetime of an initial key by increasing the number of messages processed with this key.",
      "ja": "1. このキーで処理されるメッセージの数を増やすことにより、初期キーの寿命を延ばします。"
    },
    {
      "indent": 3,
      "text": "2. It has minimal impact on performance when the number of messages processed under one initial key is sufficiently large.",
      "ja": "2. 1つの初期キーで処理されるメッセージの数が十分に大きい場合、パフォーマンスへの影響は最小限になります。"
    },
    {
      "indent": 3,
      "text": "3. It provides forward and backward security of data-processing keys.",
      "ja": "3. データ処理キーの前方および後方セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "However, the use of external re-keying has the following disadvantage: in cases with restrictive key lifetime limitations, the message sizes can become obstructive due to the impossibility of processing sufficiently large messages, so it may be necessary to perform additional fragmentation at the protocol level. For example, if the key lifetime L is 1 GB and the message length m = 3 GB, then this message cannot be processed as a whole, and it should be divided into three fragments that will be processed separately.",
      "ja": "ただし、外部キー再生成の使用には次の欠点があります：キーの有効期間が制限されている場合、十分に大きなメッセージを処理できないためにメッセージサイズが邪魔になる可能性があるため、プロトコルで追加のフラグメンテーションを実行する必要がある場合があります レベル。 たとえば、キーの有効期間Lが1 GBでメッセージの長さm = 3 GBの場合、このメッセージは全体として処理できず、個別に処理される3つのフラグメントに分割する必要があります。"
    },
    {
      "indent": 3,
      "text": "Internal re-keying is an approach assuming that a key is transformed during each separate message processing. Such procedures are integrated into the base modes of operations, so every internal re-keying mechanism is defined for the particular operation mode and the block size of the used cipher. Internal re-keying is recommended for protocols that process long messages: the size of each single message can be substantially increased without loss in the number of messages that can be securely processed with a single initial key.",
      "ja": "内部キー再生成は、個々のメッセージ処理中にキーが変換されることを想定したアプローチです。 このような手順は、操作の基本モードに統合されているため、すべての内部キー再生成メカニズムは、特定の操作モードと使用される暗号のブロックサイズに対して定義されます。 長いメッセージを処理するプロトコルには、内部キーの再生成が推奨されます。単一の初期キーで安全に処理できるメッセージの数を失うことなく、各メッセージのサイズを大幅に増やすことができます。"
    },
    {
      "indent": 3,
      "text": "Internal re-keying has the following advantages:",
      "ja": "内部キー再生成には次の利点があります。"
    },
    {
      "indent": 3,
      "text": "1. It increases the lifetime of an initial key by increasing the size of the messages processed with one initial key.",
      "ja": "1. 1つの初期キーで処理されるメッセージのサイズを増やすことにより、初期キーの寿命を延ばします。"
    },
    {
      "indent": 3,
      "text": "2. It has minimal impact on performance.",
      "ja": "2. パフォーマンスへの影響は最小限です。"
    },
    {
      "indent": 3,
      "text": "3. Internal re-keying mechanisms without a master key do not affect short-message transformation at all.",
      "ja": "3. マスターキーを使用しない内部キー再生成メカニズムは、ショートメッセージ変換にはまったく影響しません。"
    },
    {
      "indent": 3,
      "text": "4. It is transparent (works like any mode of operation): it does not require changes of initialization vectors (IVs) and a restart of MACing.",
      "ja": "4. 透過的です（他の操作モードと同様に機能します）。初期化ベクトル（IV）の変更とMACingの再起動は不要です。"
    },
    {
      "indent": 3,
      "text": "However, the use of internal re-keying has the following disadvantages:",
      "ja": "ただし、内部キー再生成の使用には次の欠点があります。"
    },
    {
      "indent": 3,
      "text": "1. a specific method must not be chosen independently of a mode of operation.",
      "ja": "1. 動作モードに関係なく特定の方法を選択しないでください。"
    },
    {
      "indent": 3,
      "text": "2. internal re-keying mechanisms without a master key do not provide backward security of data-processing keys.",
      "ja": "2. マスターキーを使用しない内部キー再生成メカニズムは、データ処理キーの後方セキュリティを提供しません。"
    },
    {
      "indent": 3,
      "text": "Any block cipher modes of operations with internal re-keying can be jointly used with any external re-keying mechanisms. Such joint usage increases both the number of messages processed with one initial key and their maximum possible size.",
      "ja": "内部キー再生成を使用するブロック暗号モードの操作は、外部キー再生成メカニズムと併用できます。 このような共同使用により、1つの初期キーで処理されるメッセージの数と、可能な最大サイズの両方が増加します。"
    },
    {
      "indent": 3,
      "text": "If the adversary has access to the data-processing interface, the use of the same cryptographic primitives both for data-processing and re-keying transformation decreases the code size but can lead to some possible vulnerabilities (the possibility of mounting a chosen-plaintext attack may lead to the compromise of the following keys). This vulnerability can be eliminated by using different primitives for data processing and re-keying, e.g., block cipher for data processing and hash for re-keying (see Section 5.2.2 and Section 5.3.2). However, in this case, the security of the whole scheme cannot be reduced to standard notions like a pseudorandom function (PRF) or pseudorandom permutation (PRP), so security estimations become more difficult and unclear.",
      "ja": "攻撃者がデータ処理インターフェイスにアクセスできる場合、データ処理とキー再生成の両方の変換に同じ暗号プリミティブを使用すると、コードサイズは小さくなりますが、いくつかの脆弱性（選択されたプレーンテキスト攻撃を仕掛ける可能性）につながる可能性があります 次のキーの侵害につながる可能性があります）。 この脆弱性は、データ処理とキー再生成に異なるプリミティブを使用することで排除できます。たとえば、データ処理のブロック暗号とキー再生成のハッシュです（セクション5.2.2およびセクション5.3.2を参照）。 ただし、この場合、スキーム全体のセキュリティを疑似ランダム関数（PRF）や疑似ランダム順列（PRP）などの標準的な概念に減らすことはできないため、セキュリティの推定はより困難で不明確になります。"
    },
    {
      "indent": 3,
      "text": "Summing up the abovementioned issues briefly:",
      "ja": "上記の問題を簡単にまとめると："
    },
    {
      "indent": 3,
      "text": "1. If a protocol assumes processing of long records (e.g., [CMS]), internal re-keying should be used. If a protocol assumes processing of a significant number of ordered records, which can be considered as a single data stream (e.g., [TLS], [SSH]), internal re-keying may also be used.",
      "ja": "1. プロトコルが長いレコード（[CMS]など）の処理を想定している場合、内部キー再生成を使用する必要があります。 プロトコルが、単一のデータストリーム（[TLS]、[SSH]など）と見なすことができる大量の順序付けされたレコードの処理を想定している場合、内部のキー再生成も使用できます。"
    },
    {
      "indent": 3,
      "text": "2. For protocols that allow out-of-order delivery and lost records (e.g., [DTLS], [ESP]), external re-keying should be used as, in this case, records cannot be considered as a single data stream. If the records are also long enough, internal re-keying should also be used during each separate message processing.",
      "ja": "2. 順不同の配信と失われたレコード（[DTLS]、[ESP]など）を許可するプロトコルの場合、この場合、レコードを単一のデータストリームと見なすことができないため、外部のキー再生成を使用する必要があります。 レコードも十分に長い場合は、個別のメッセージ処理中に内部キー再生成も使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For external re-keying:",
      "ja": "外部キー再生成の場合："
    },
    {
      "indent": 3,
      "text": "1. If it is desirable to separate transformations used for data processing and key updates, hash function-based re-keying should be used.",
      "ja": "1. データ処理とキーの更新に使用される変換を分離することが望ましい場合は、ハッシュ関数ベースのキー再生成を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If parallel data processing is required, then parallel external re-keying should be used.",
      "ja": "2. 並列データ処理が必要な場合は、並列外部キー再生成を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. If restrictive key lifetime limitations are present, external tree-based re-keying should be used.",
      "ja": "3. キーの有効期間に制限がある場合は、外部ツリーベースのキー再生成を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For internal re-keying:",
      "ja": "内部キー再生成の場合："
    },
    {
      "indent": 3,
      "text": "1. If the property of forward and backward security is desirable for data-processing keys and if additional key material can be easily obtained for the data-processing stage, internal re-keying with a master key should be used.",
      "ja": "1. フォワードおよびバックワードセキュリティの特性がデータ処理キーに望ましい場合、およびデータ処理段階で追加のキーマテリアルを簡単に取得できる場合は、マスターキーを使用した内部キー再生成を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. External Re-keying Mechanisms",
      "section_title": true,
      "ja": "5. 外部キー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "This section presents an approach to increasing the initial key lifetime by using a transformation of a data-processing key (frame key) after processing a limited number of entire messages (frame). The approach provides external parallel and serial re-keying mechanisms (see [AbBell]). These mechanisms use initial key K only for frame key generation and never use it directly for data processing. Such mechanisms operate outside of the base modes of operations and do not change them at all; therefore, they are called \"external re-keying\" mechanisms in this document.",
      "ja": "このセクションでは、限られた数のメッセージ（フレーム）全体を処理した後、データ処理キー（フレームキー）の変換を使用して、初期キーの有効期間を延長する方法を示します。 このアプローチは、外部のパラレルおよびシリアルのキー再生成メカニズムを提供します（[AbBell]を参照）。 これらのメカニズムは、フレームキーの生成にのみ初期キーKを使用し、データ処理に直接使用することはありません。 このようなメカニズムは、操作の基本モードの外側で動作し、それらをまったく変更しません。 したがって、これらはこのドキュメントでは「外部キー再生成」メカニズムと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "External re-keying mechanisms are recommended for usage in protocols that process quite small messages, since the maximum gain in increasing the initial key lifetime is achieved by increasing the number of messages.",
      "ja": "外部キー再生成メカニズムは、非常に小さなメッセージを処理するプロトコルでの使用に推奨されます。これは、メッセージの数を増やすことで初期キーの有効期間を延長する最大の利点が得られるためです。"
    },
    {
      "indent": 3,
      "text": "External re-keying increases the initial key lifetime through the following approach. Suppose there is a protocol P with some mode of operation (base encryption or authentication mode). Let L1 be a key lifetime limitation induced by side-channel analysis methods (side-channel limitation), let L2 be a key lifetime limitation induced by methods based on the combinatorial properties of a used mode of operation (combinatorial limitation), and let q1, q2 be the total numbers of messages of length m that can be safely processed with an initial key K according to these limitations.",
      "ja": "外部キーの再生成は、次のアプローチにより初期キーの寿命を延ばします。 何らかの動作モード（基本暗号化または認証モード）のプロトコルPがあるとします。 L1をサイドチャネル分析方法によって引き起こされる主要な寿命制限（サイドチャネル制限）とし、L2を使用済み動作モードの組み合わせ特性に基づく方法によって引き起こされる主要な寿命制限（組み合わせ制限）とし、q1とします 、q2は、これらの制限に従って初期キーKで安全に処理できる長さmのメッセージの総数です。"
    },
    {
      "indent": 3,
      "text": "Let L = min(L1, L2), q = min(q1, q2), and q * m <= L. As the L1 limitation is usually much stronger than the L2 limitation (L1 < L2), the final key lifetime restriction is equal to the most restrictive limitation L1. Thus, as displayed in Figure 2, without re-keying, only q1 (q1 * m <= L1) messages can be safely processed.",
      "ja": "L = min（L1、L2）、q = min（q1、q2）、q * m <= Lとしましょう。通常、L1の制限はL2の制限（L1 <L2）よりもはるかに強いため、最終的なキーの有効期間の制限は 最も制限の厳しいL1と等しい。 したがって、図2に示すように、キーを再生成することなく、q1（q1 * m <= L1）メッセージのみを安全に処理できます。"
    },
    {
      "indent": 21,
      "text": "    <--------m------->\n    +----------------+ ^ ^\n    |================| | |\n    |================| | |\nK-->|================| q1|\n    |================| | |\n    |==============L1| | |\n    +----------------+ v |\n    |                |   |\n    |                |   |\n    |                |   q2\n    |                |   |\n    |                |   |\n    |                |   |\n    |                |   |\n    |                |   |\n    |                |   |\n    |                |   |\n    |                |   |\n    |              L2|   |\n    +----------------+   v",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 2: Basic Principles of Message Processing without External Re-keying",
      "ja": "図2：外部キー再生成を使用しないメッセージ処理の基本原則"
    },
    {
      "indent": 3,
      "text": "Suppose that the safety margin for the protocol P is fixed and the external re-keying approach is applied to the initial key K to generate the sequence of frame keys. The frame keys are generated in such a way that the leakage of a previous frame key does not have any impact on the following one, so the side-channel limitation L1 is switched off. Thus, the resulting key lifetime limitation of the initial key K can be calculated on the basis of a new combinatorial limitation L2'. It is proven (see [AbBell]) that the security of the mode of operation that uses external re-keying leads to an increase when compared to base mode without re-keying (thus, L2 < L2'). Hence, as displayed in Figure 3, the resulting key lifetime limitation if using external re-keying can be increased up to L2'.",
      "ja": "プロトコルPの安全マージンが固定され、外部キー再生成アプローチが初期キーKに適用されてフレームキーのシーケンスが生成されるとします。 フレームキーは、前のフレームキーの漏洩が次のフレームキーに影響を与えないように生成されるため、サイドチャネル制限L1はオフになります。 したがって、初期鍵Kの結果として生じる鍵寿命制限は、新しい組み合わせ制限L2 'に基づいて計算することができます。 外部キー再生成を使用する操作モードのセキュリティは、キー再生成なしのベースモードと比較して増加することが実証されています（[AbBell]を参照）（したがって、L2 <L2 '）。 したがって、図3に示すように、外部のキー再生成を使用した場合のキーの有効期間の制限は、L2 'まで増加できます。"
    },
    {
      "indent": 18,
      "text": "       <--------m------->\n K     +----------------+\n |     |================|\n v     |================|\nK^1--> |================|\n |     |================|\n |     |==============L1|\n |     +----------------+\n |     |================|\n v     |================|\nK^2--> |================|\n |     |================|\n |     |==============L1|\n |     +----------------+\n |     |================|\n v     |================|\n...    |      . . .     |\n       |                |\n       |                |\n       |              L2|\n       +----------------+\n       |                |\n      ...              ...\n       |             L2'|\n       +----------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 3: Basic Principles of Message Processing with External Re-keying",
      "ja": "図3：外部キー再生成を使用したメッセージ処理の基本原則"
    },
    {
      "indent": 3,
      "text": "Note: The key transformation process is depicted in a simplified form. A specific approach (parallel and serial) is described below.",
      "ja": "注：キー変換プロセスは、簡略化された形式で示されています。 特定のアプローチ（パラレルおよびシリアル）を以下に説明します。"
    },
    {
      "indent": 3,
      "text": "Consider an example. Let the message size in a protocol P be equal to 1 KB. Suppose L1 = 128 MB and L2 = 1 TB. Thus, if an external re-keying mechanism is not used, the initial key K must be renegotiated after processing 128 MB / 1 KB = 131072 messages.",
      "ja": "例を考えてみましょう。 プロトコルPのメッセージサイズを1 KBにします。 L1 = 128 MB、L2 = 1 TBと仮定します。 したがって、外部キー再生成メカニズムを使用しない場合、128 MB / 1 KB = 131072メッセージを処理した後、初期キーKを再ネゴシエートする必要があります。"
    },
    {
      "indent": 3,
      "text": "If an external re-keying mechanism is used, the key lifetime limitation L1 goes off. Hence, the resulting key lifetime limitation L2' can be set to more than 1 TB. Thus, if an external re-keying mechanism is used, more than 1 TB / 1 KB = 2^30 messages can be processed before the initial key K is renegotiated. This is 8192 times greater than the number of messages that can be processed when an external re-keying mechanism is not used.",
      "ja": "外部のキー再生成メカニズムが使用される場合、キーの有効期間の制限L1はオフになります。 したがって、結果として得られるキーの有効期間制限L2 'は、1 TBを超える値に設定できます。 したがって、外部のキー再生成メカニズムを使用すると、初期キーKが再ネゴシエートされる前に、1 TB / 1 KB = 2 ^ 30を超えるメッセージを処理できます。 これは、外部キー再生成メカニズムを使用しない場合に処理できるメッセージの数の8192倍です。"
    },
    {
      "indent": 0,
      "text": "5.1. Methods of Key Lifetime Control",
      "section_title": true,
      "ja": "5.1. キーライフタイムコントロールの方法"
    },
    {
      "indent": 3,
      "text": "Suppose L is an amount of data that can be safely processed with one frame key. For i in {1, 2, ... , t}, the frame key K^i (see Figures 4 and 6) should be transformed after processing q_i messages, where q_i can be calculated in accordance with one of the following approaches:",
      "ja": "Lは、1つのフレームキーで安全に処理できるデータ量であるとします。 {1、2、...、t}のiの場合、q_iメッセージの処理後にフレームキーK ^ i（図4および6を参照）を変換する必要があります。ここで、q_iは次のいずれかのアプローチに従って計算できます。"
    },
    {
      "indent": 3,
      "text": "Explicit approach:",
      "ja": "明示的なアプローチ："
    },
    {
      "indent": 6,
      "text": "q_i is such that |M^{i,1}| + ... + |M^{i,q_i}| <= L, |M^{i,1}| + ... + |M^{i,q_i+1}| > L. This approach allows use of the frame key K^i in an almost optimal way, but it can be applied only when messages cannot be lost or reordered (e.g., TLS records).",
      "ja": "q_iは、| M ^ {i、1} | + ... + | M ^ {i、q_i} | <= L、| M ^ {i、1} | + ... + | M ^ {i、q_i + 1} | > L.このアプローチでは、フレームキーK ^ iをほぼ最適な方法で使用できますが、メッセージの損失や並べ替えができない場合（TLSレコードなど）にのみ適用できます。"
    },
    {
      "indent": 3,
      "text": "Implicit approach:",
      "ja": "暗黙的なアプローチ："
    },
    {
      "indent": 6,
      "text": "q_i = L / m_max, i = 1, ... , t. The amount of data processed with one frame key K^i is calculated under the assumption that every message has the maximum length m_max. Hence, this amount can be considerably less than the key lifetime limitation L. On the other hand, this approach can be applied when messages may be lost or reordered (e.g., DTLS records).",
      "ja": "q_i = L / m_max、i = 1、...、t 1つのフレームキーK ^ iで処理されるデータ量は、すべてのメッセージの最大長がm_maxであるという仮定の下で計算されます。 したがって、この量はキーの有効期間の制限Lよりもかなり少なくなる可能性があります。一方、このアプローチは、メッセージが失われたり並べ替えられたりする場合に適用できます（DTLSレコードなど）。"
    },
    {
      "indent": 3,
      "text": "Dynamic key changes:",
      "ja": "動的なキーの変更："
    },
    {
      "indent": 6,
      "text": "We can organize the key change using the Protected Point to Point ([P3]) solution by building a protected tunnel between the endpoints in which the information about frame key updating can be safely passed across. This can be useful, for example, when we want the adversary to not detect the key change during the protocol evaluation.",
      "ja": "フレームキーの更新に関する情報を安全に渡すことができるエンドポイント間に保護されたトンネルを構築することにより、保護されたポイントツーポイント（[P3]）ソリューションを使用してキーの変更を整理できます。 これは、たとえば、プロトコルの評価中に攻撃者がキーの変更を検出しないようにする場合に役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2. Parallel Constructions",
      "section_title": true,
      "ja": "5.2. 並列構造"
    },
    {
      "indent": 3,
      "text": "External parallel re-keying mechanisms generate frame keys K^1, K^2, ... directly from the initial key K independently of each other.",
      "ja": "外部並列再キーイングメカニズムは、互いに独立して初期キーKから直接フレームキーK ^ 1、K ^ 2、...を生成します。"
    },
    {
      "indent": 3,
      "text": "The main idea behind external re-keying with a parallel construction\nis presented in Figure 4: Maximum message size = m_max.\n_____________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                                m_max\n                          <---------------->\n                M^{1,1}   |===             |\n                M^{1,2}   |=============== |\n      +->K^1-->   ...            ...\n      |         M^{1,q_1} |========        |\n      |\n      |\n      |         M^{2,1}   |================|\n      |         M^{2,2}   |=====           |\nK-----|->K^2-->   ...            ...\n      |         M^{2,q_2} |==========      |\n      |\n     ...\n      |         M^{t,1}   |============    |\n      |         M^{t,2}   |=============   |\n      +->K^t-->   ...            ...\n                M^{t,q_t} |==========      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "_____________________________________________________________",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 4: External Parallel Re-keying Mechanisms",
      "ja": "図4：外部並列キー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "The frame key K^i, i = 1, ... , t - 1 is updated after processing a certain number of messages (see Section 5.1).",
      "ja": "フレームキーK ^ i、i = 1、...、t-1は、特定の数のメッセージを処理した後に更新されます（セクション5.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Parallel Construction Based on a KDF on a Block Cipher",
      "section_title": true,
      "ja": "5.2.1. ブロック暗号上のKDFに基づく並列構築"
    },
    {
      "indent": 3,
      "text": "The ExtParallelC re-keying mechanism is based on the key derivation function on a block cipher and is used to generate t frame keys as follows:",
      "ja": "ExtParallelCのキー変更メカニズムは、ブロック暗号のキー派生関数に基づいており、次のようにtフレームキーを生成するために使用されます。"
    },
    {
      "indent": 6,
      "text": "K^1 | K^2 | ... | K^t = ExtParallelC(K, t * k) = MSB_{t * k}(E_{K}(Vec_n(0)) | E_{K}(Vec_n(1)) | ... | E_{K}(Vec_n(R - 1))),",
      "ja": "K ^ 1 | K ^ 2 | ... | K ^ t = ExtParallelC（K、t * k）= MSB_ {t * k}（E_ {K}（Vec_n（0））| E_ {K}（Vec_n（1））| ... | E_ {K} （Vec_n（R-1）））、"
    },
    {
      "indent": 3,
      "text": "where R = ceil(t * k/n).",
      "ja": "ここで、R = ceil（t * k / n）。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Parallel Construction Based on a KDF on a Hash Function",
      "section_title": true,
      "ja": "5.2.2. ハッシュ関数上のKDFに基づく並列構築"
    },
    {
      "indent": 3,
      "text": "The ExtParallelH re-keying mechanism is based on the key derivation function HKDF-Expand, described in [RFC5869], and is used to generate t frame keys as follows:",
      "ja": "ExtParallelHのキー変更メカニズムは、[RFC5869]で説明されているキー派生関数HKDF-Expandに基づいており、次のようにtフレームキーを生成するために使用されます。"
    },
    {
      "indent": 6,
      "text": "K^1 | K^2 | ... | K^t = ExtParallelH(K, t * k) = HKDF-Expand(K, label, t * k),",
      "ja": "K ^ 1 | K ^ 2 | ... | K ^ t = ExtParallelH（K、t * k）= HKDF-Expand（K、label、t * k）、"
    },
    {
      "indent": 3,
      "text": "where label is a string (may be a zero-length string) that is defined by a specific protocol.",
      "ja": "labelは、特定のプロトコルで定義された文字列（長さゼロの文字列の場合があります）です。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Tree-Based Construction",
      "section_title": true,
      "ja": "5.2.3. ツリーベースの構築"
    },
    {
      "indent": 3,
      "text": "The application of an external tree-based mechanism leads to the construction of the key tree with the initial key K (root key) at the 0 level and the frame keys K^1, K^2, ... at the last level, as described in Figure 5.",
      "ja": "外部ツリーベースのメカニズムを適用すると、0レベルの初期キーK（ルートキー）と最後のレベルのフレームキーK ^ 1、K ^ 2、...を持つキーツリーが構築されます。 図5で説明されているように。"
    },
    {
      "indent": 8,
      "text": "                    K_root = K\n              ___________|___________\n             |          ...          |\n             V                       V\n            K{1,1}                K{1,W1}\n       ______|______           ______|______\n      |     ...     |         |     ...     |\n      V             V         V             V\n   K{2,1}       K{2,W2}  K{2,(W1-1)*W2+1} K{2,W1*W2}\n    __|__         __|__     __|__         __|__\n   | ... |       | ... |   | ... |       | ... |\n   V     V       V     V   V     V       V     V\nK{3,1}  ...     ...   ... ...   ...     ...   K{3,W1*W2*W3}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "      ...                                           ...\n     __|__                   ...                   __|__\n    | ... |                                       | ... |\n    V     V                                       V     V\nK{h,1}   K{h,Wh}         K{h,(W1*...*W{h-1}-1)*Wh+1}  K{h,W1*...*Wh}\n  //       \\\\                                  //       \\\\\nK^1       K^{Wh}        K^{(W1*...*W{h-1}-1)*Wh+1}     K^{W1*...*Wh}\n____________________________________________________________________",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 5: External Tree-Based Mechanism",
      "ja": "図5：外部ツリーベースのメカニズム"
    },
    {
      "indent": 3,
      "text": "The tree height h and the number of keys Wj, j in {1, ... , h}, which can be partitioned from the \"parent\" key, are defined in accordance with a specific protocol and key lifetime limitations for the used derivation functions.",
      "ja": "ツリーの高さhと{1、...、h}のキーの数Wj、jは、「親」キーから分割でき、特定のプロトコルと使用される派生のキーの有効期間の制限に従って定義されます。 関数。"
    },
    {
      "indent": 3,
      "text": "Each j-level key K{j,w}, where j in {1, ... , h}, w in {1, ... , W1 * ... * Wj}, is derived from the (j-1)-level \"parent\" key K{j-1, ceil(w/Wi)} (and other appropriate input data) using the j-th level derivation function. This function can be based on the block cipher function or on the hash function and is defined in accordance with a specific protocol.",
      "ja": "各jレベルキーK {j、w}、ここでjは{1、...、h}、wは{1、...、W1 * ... * Wj}であり、（j- 1）レベル「親」キーK {j-1、ceil（w / Wi）}（および他の適切な入力データ）j番目のレベル派生関数を使用。 この関数は、ブロック暗号関数またはハッシュ関数に基づくことができ、特定のプロトコルに従って定義されます。"
    },
    {
      "indent": 3,
      "text": "The i-th frame K^i, i in {1, 2, ... , W1*...*Wh}, can be calculated as follows:",
      "ja": "i番目のフレームK ^ i、{1、2、...、W1 * ... * Wh}のiは、次のように計算できます。"
    },
    {
      "indent": 6,
      "text": "K^i = ExtKeyTree(K, i) = KDF_h(KDF_{h-1}(... KDF_1(K, ceil(i / (W2 * ... * Wh)) ... , ceil(i / Wh)), i),",
      "ja": "K ^ i = ExtKeyTree（K、i）= KDF_h（KDF_ {h-1}（... KDF_1（K、ceil（i /（W2 * ... * Wh））...、ceil（i / Wh ））、 私）、"
    },
    {
      "indent": 3,
      "text": "where KDF_j is the j-th level derivation function that takes two arguments (the parent key value and the integer in a range from 1 to W1 * ... * Wj) and outputs the j-th level key value.",
      "ja": "ここで、KDF_jは2つの引数（親キー値と1からW1 * ... * Wjの範囲の整数）を取り、jレベルのキー値を出力するjレベルの派生関数です。"
    },
    {
      "indent": 3,
      "text": "The frame key K^i is updated after processing a certain number of messages (see Section 5.1).",
      "ja": "フレームキーK ^ iは、一定数のメッセージを処理した後に更新されます（セクション5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "In order to create an efficient implementation, during frame key K^i generation, the derivation functions KDF_j, j in {1, ... , h-1} should be used only when ceil(i / (W{j+1} * ... * Wh)) != ceil((i - 1) / (W{j+1} * ... * Wh)); otherwise, it is necessary to use a previously generated value. This approach also makes it possible to take countermeasures against side-channel attacks.",
      "ja": "効率的な実装を作成するには、フレームキーK ^ iの生成中に、{1、...、h-1}の派生関数KDF_j、jは、ceil（i /（W {j + 1} * ... * Wh））！= ceil（（i-1）/（W {j + 1} * ... * Wh））; そうでない場合は、以前に生成された値を使用する必要があります。 このアプローチにより、サイドチャネル攻撃に対する対策を講じることも可能になります。"
    },
    {
      "indent": 3,
      "text": "Consider an example. Suppose h = 3, W1 = W2 = W3 = W, and KDF_1, KDF_2, KDF_3 are key derivation functions based on the KDF_GOSTR3411_2012_256 (hereafter simply KDF) function described in [RFC7836]. The resulting ExtKeyTree function can be defined as follows:",
      "ja": "例を考えてみましょう。 h = 3、W1 = W2 = W3 = W、およびKDF_1、KDF_2、KDF_3が、[RFC7836]で説明されているKDF_GOSTR3411_2012_256（以下、単にKDF）関数に基づくキー派生関数であると仮定します。 結果のExtKeyTree関数は、次のように定義できます。"
    },
    {
      "indent": 6,
      "text": "ExtKeyTree(K, i) = KDF(KDF(KDF(K, \"level1\", ceil(i / W^2)), \"level2\", ceil(i / W)), \"level3\", i).",
      "ja": "ExtKeyTree（K、i）= KDF（KDF（KDF（K、 \"level1\"、ceil（i / W ^ 2））、 \"level2\"、ceil（i / W））、 \"level3\"、i）。"
    },
    {
      "indent": 3,
      "text": "where i in {1, 2, ... , W^3}.",
      "ja": "ここで、{1、2、...、W ^ 3}のi。"
    },
    {
      "indent": 3,
      "text": "A structure similar to the external tree-based mechanism can be found in Section 6 of [NISTSP800-108].",
      "ja": "外部ツリーベースのメカニズムに類似した構造は、[NISTSP800-108]のセクション6にあります。"
    },
    {
      "indent": 0,
      "text": "5.3. Serial Constructions",
      "section_title": true,
      "ja": "5.3. シリアル構造"
    },
    {
      "indent": 3,
      "text": "External serial re-keying mechanisms generate frame keys, each of which depends on the secret state (K*_1, K*_2, ...) that is updated after the generation of each new frame key; see Figure 6. Similar approaches are used in the [SIGNAL] protocol and the [TLS] updating",
      "ja": "外部シリアルキー再生成メカニズムはフレームキーを生成します。フレームキーはそれぞれ、新しいフレームキーの生成後に更新される秘密の状態（K * _1、K * _2、...）に依存します。 図6を参照してください。[SIGNAL]プロトコルと[TLS]更新で同様のアプローチが使用されます"
    },
    {
      "indent": 3,
      "text": "traffic key mechanism and were proposed for use in the [U2F] protocol.",
      "ja": "トラフィックキーメカニズムと[U2F]プロトコルでの使用が提案されました。"
    },
    {
      "indent": 3,
      "text": "External serial re-keying mechanisms have the obvious disadvantage of being impossible to implement in parallel, but they may be the preferred option if additional forward secrecy is desirable. If all keys are securely deleted after usage, the compromise of a current secret state at some point does not lead to a compromise of all previous secret states and frame keys. In terms of [TLS], compromise of application_traffic_secret_N does not compromise all previous application_traffic_secret_i, i < N.",
      "ja": "外部シリアルキー再生成メカニズムには、並行して実装することが不可能であるという明らかな欠点がありますが、追加の前方秘匿性が必要な場合は、これらのメカニズムが優先される可能性があります。 使用後にすべてのキーが安全に削除された場合、ある時点で現在のシークレット状態が侵害されても、以前のすべてのシークレット状態とフレームキーが侵害されることはありません。 [TLS]に関しては、application_traffic_secret_Nの侵害は、以前のapplication_traffic_secret_iのすべてを侵害するわけではありません。i<N。"
    },
    {
      "indent": 3,
      "text": "The main idea behind external re-keying with a serial construction is presented in Figure 6:",
      "ja": "シリアル構成による外部キー再生成の背後にある主なアイデアを図6に示します。"
    },
    {
      "indent": 3,
      "text": "Maximum message size = m_max.\n_____________________________________________________________\n                                     m_max\n                               <---------------->\n                     M^{1,1}   |===             |\n                     M^{1,2}   |=============== |\nK*_1 = K --->K^1-->    ...            ...\n  |                  M^{1,q_1} |========        |\n  |\n  |\n  |                  M^{2,1}   |================|\n  v                  M^{2,2}   |=====           |\nK*_2 ------->K^2-->    ...            ...\n  |                  M^{2,q_2} |==========      |\n  |\n ...\n  |                  M^{t,1}   |============    |\n  v                  M^{t,2}   |=============   |\nK*_t ------->K^t-->    ...            ...\n                     M^{t,q_t} |==========      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "_____________________________________________________________",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 6: External Serial Re-keying Mechanisms",
      "ja": "図6：外部シリアルキー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "The frame key K^i, i = 1, ... , t - 1, is updated after processing a certain number of messages (see Section 5.1).",
      "ja": "フレームキーK ^ i、i = 1、...、t-1は、一定数のメッセージを処理した後に更新されます（セクション5.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Serial Construction Based on a KDF on a Block Cipher",
      "section_title": true,
      "ja": "5.3.1. ブロック暗号上のKDFに基づくシリアル構築"
    },
    {
      "indent": 3,
      "text": "The frame key K^i is calculated using the ExtSerialC transformation as follows:",
      "ja": "フレームキーK ^ iは、ExtSerialC変換を使用して次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "K^i = ExtSerialC(K, i) = MSB_k(E_{K*_i}(Vec_n(0)) |E_{K*_i}(Vec_n(1)) | ... | E_{K*_i}(Vec_n(J - 1))),",
      "ja": "K ^ i = ExtSerialC（K、i）= MSB_k（E_ {K * _i}（Vec_n（0））| E_ {K * _i}（Vec_n（1））| ... | E_ {K * _i}（ Vec_n（J-1）））、"
    },
    {
      "indent": 3,
      "text": "where J = ceil(k / n), i = 1, ... , t, K*_i is calculated as follows:",
      "ja": "ここで、J = ceil（k / n）、i = 1、...、t、K * _iは次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "K*_1 = K,",
      "ja": "K * _1 = K、"
    },
    {
      "indent": 6,
      "text": "K*_{j+1} = MSB_k(E_{K*_j}(Vec_n(J)) | E_{K*_j}(Vec_n(J + 1)) | ... | E_{K*_j}(Vec_n(2 * J - 1))),",
      "ja": "K * _ {j + 1} = MSB_k（E_ {K * _j}（Vec_n（J））| E_ {K * _j}（Vec_n（J + 1））| ... | E_ {K * _j}（ Vec_n（2 * J-1）））、"
    },
    {
      "indent": 3,
      "text": "where j = 1, ... , t - 1.",
      "ja": "ここで、j = 1、...、t-1。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Serial Construction Based on a KDF on a Hash Function",
      "section_title": true,
      "ja": "5.3.2. ハッシュ関数上のKDFに基づくシリアル構築"
    },
    {
      "indent": 3,
      "text": "The frame key K^i is calculated using the ExtSerialH transformation as follows:",
      "ja": "フレームキーK ^ iは、ExtSerialH変換を使用して次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "K^i = ExtSerialH(K, i) = HKDF-Expand(K*_i, label1, k),",
      "ja": "K ^ i = ExtSerialH（K、i）= HKDF-Expand（K * _i、label1、k）、"
    },
    {
      "indent": 3,
      "text": "where i = 1, ... , t; HKDF-Expand is the HMAC-based key derivation function, as described in [RFC5869]; and K*_i is calculated as follows:",
      "ja": "ここで、i = 1、...、t; [RFC5869]で説明されているように、HKDF-ExpandはHMACベースのキー派生関数です。 K * _iは次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "K*_1 = K,",
      "ja": "K * _1 = K、"
    },
    {
      "indent": 6,
      "text": "K*_{j+1} = HKDF-Expand(K*_j, label2, k), where j = 1, ... , t - 1,",
      "ja": "K * _ {j + 1} = HKDF-Expand（K * _j、label2、k）、ここでj = 1、...、t-1"
    },
    {
      "indent": 3,
      "text": "where label1 and label2 are different strings from V* that are defined by a specific protocol (see, for example, the algorithm for updating traffic keys in TLS 1.3 [TLS]).",
      "ja": "label1とlabel2は、特定のプロトコルで定義されているV *とは異なる文字列です（たとえば、TLS 1.3 [TLS]でトラフィックキーを更新するアルゴリズムを参照）。"
    },
    {
      "indent": 0,
      "text": "5.4. Using Additional Entropy during Re-keying",
      "section_title": true,
      "ja": "5.4. キー再生成中に追加のエントロピーを使用する"
    },
    {
      "indent": 3,
      "text": "In many cases, using additional entropy during re-keying won't increase security but may give a false sense of that. Therefore, one can rely on additional entropy only after conducting a deep security analysis. For example, good PRF constructions do not require additional entropy for the quality of keys, so, in most cases, there is no need to use additional entropy with external re-keying mechanisms based on secure KDFs. However, in some situations, mixed-in entropy can still increase security in the case of a time-limited but complete breach of the system when an adversary can access the frame-key generation interface but cannot reveal the master keys (e.g., when the master keys are stored in a Hardware Security Module (HSM)).",
      "ja": "多くの場合、キー再生成中に追加のエントロピーを使用してもセキュリティは向上しませんが、誤った感覚を与える可能性があります。 したがって、深いセキュリティ分析を行った後にのみ、追加のエントロピーに依存できます。 たとえば、優れたPRF構造では、キーの品質のために追加のエントロピーを必要としないため、ほとんどの場合、安全なKDFに基づく外部のキー再生成メカニズムで追加のエントロピーを使用する必要はありません。 ただし、状況によっては、敵がフレームキー生成インターフェイスにアクセスできるがマスターキーを公開できない場合（たとえば、システムの時間制限はあるが完全な侵害の場合、混合エントロピーによりセキュリティが向上する可能性があります。 マスターキーはハードウェアセキュリティモジュール（HSM）に保存されます）。"
    },
    {
      "indent": 3,
      "text": "For example, an external parallel construction based on a KDF on a hash function with a mixed-in entropy can be described as follows:",
      "ja": "たとえば、エントロピーが混在するハッシュ関数のKDFに基づく外部並列構造は、次のように記述できます。"
    },
    {
      "indent": 6,
      "text": "K^i = HKDF-Expand(K, label_i, k),",
      "ja": "K ^ i = HKDF-Expand（K、label_i、k）、"
    },
    {
      "indent": 3,
      "text": "where label_i is additional entropy that must be sent to the recipient (e.g., sent jointly with an encrypted message). The entropy label_i and the corresponding key K^i must be generated directly before message processing.",
      "ja": "label_iは、受信者に送信する必要がある追加のエントロピーです（たとえば、暗号化されたメッセージと一緒に送信されます）。 エントロピーlabel_iおよび対応するキーK ^ iは、メッセージ処理の前に直接生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Internal Re-keying Mechanisms",
      "section_title": true,
      "ja": "6. 内部キー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "This section presents an approach to increasing the key lifetime by using a transformation of a data-processing key (section key) during each separate message processing. Each message is processed starting with the same key (the first section key), and each section key is updated after processing N bits of the message (section).",
      "ja": "このセクションでは、各メッセージ処理中にデータ処理キー（セクションキー）の変換を使用することにより、キーの有効期間を延長する方法を示します。 各メッセージは同じキー（最初のセクションキー）から処理され、各セクションキーはメッセージ（セクション）のNビットを処理した後に更新されます。"
    },
    {
      "indent": 3,
      "text": "This section provides internal re-keying mechanisms called ACPKM (Advanced Cryptographic Prolongation of Key Material) and ACPKM-Master that do not use a master key and use a master key, respectively. Such mechanisms are integrated into the base modes of operation and actually form new modes of operation. Therefore, they are called \"internal re-keying\" mechanisms in this document.",
      "ja": "このセクションでは、マスターキーを使用しないACPKM（キーマテリアルの高度な暗号化延長）とマスターキーを使用するACPKMマスターと呼ばれる内部のキー再生成メカニズムを提供します。 このようなメカニズムは、基本操作モードに統合され、実際に新しい操作モードを形成します。 したがって、これらはこのドキュメントでは「内部キー再生成」メカニズムと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Internal re-keying mechanisms are recommended to be used in protocols that process large single messages (e.g., CMS messages), since the maximum gain in increasing the key lifetime is achieved by increasing the length of a message, while it provides almost no increase in the number of messages that can be processed with one initial key.",
      "ja": "キーの寿命を延ばすことで最大の利益が得られるのは、メッセージの長さを長くすることで達成されるため、大きな単一メッセージ（CMSメッセージなど）を処理するプロトコルで使用することをお勧めします。 1つの初期キーで処理できるメッセージの数。"
    },
    {
      "indent": 3,
      "text": "Internal re-keying increases the key lifetime through the following approach. Suppose protocol P uses some base mode of operation. Let L1 and L2 be a side channel and combinatorial limitations, respectively, and for some fixed number of messages q, let m1, m2 be the lengths of messages that can be safely processed with a single initial key K according to these limitations.",
      "ja": "内部キー再生成は、次のアプローチによりキーの有効期間を延長します。 プロトコルPがいくつかの基本動作モードを使用するとします。 L1とL2をそれぞれサイドチャネルと組み合わせの制限とし、一定数のメッセージqについて、これらの制限に従って単一の初期キーKで安全に処理できるメッセージの長さをm1、m2とする。"
    },
    {
      "indent": 3,
      "text": "Thus, the approach without re-keying (analogous to Section 5) yields a final key lifetime restriction equal to L1, and only q messages of the length m1 can be safely processed; see Figure 7.",
      "ja": "したがって、キーを再生成しないアプローチ（セクション5に類似）では、L1に等しい最終キーの有効期間制限が得られ、長さm1のqメッセージのみが安全に処理できます。 図7を参照してください。"
    },
    {
      "indent": 6,
      "text": "          K\n          |\n          v\n^ +----------------+------------------------------------+\n| |==============L1|                                  L2|\n| |================|                                    |\nq |================|                                    |\n| |================|                                    |\n| |================|                                    |\nv +----------------+------------------------------------+\n  <-------m1------->\n  <----------------------------m2----------------------->",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 7: Basic Principles of Message Processing without Internal Re-keying",
      "ja": "図7：内部キー再生成を使用しないメッセージ処理の基本原則"
    },
    {
      "indent": 3,
      "text": "Suppose that the safety margin for the protocol P is fixed and the internal re-keying approach is applied to the base mode of operation. Suppose further that every message is processed with a section key, which is transformed after processing N bits of data, where N is a parameter. If q * N does not exceed L1, then the side-channel limitation L1 goes off, and the resulting key lifetime limitation of the initial key K can be calculated on the basis of a new combinatorial limitation L2'. The security of the mode of operation that uses internal re-keying increases when compared to the base mode of operation without re-keying (thus, L2 < L2'). Hence, as displayed in Figure 8, the resulting key lifetime limitation if using internal re-keying can be increased up to L2'.",
      "ja": "プロトコルPの安全マージンが固定され、内部キー再生成アプローチが基本操作モードに適用されると仮定します。 さらに、すべてのメッセージがセクションキーで処理され、セクションキーがNビットのデータの処理後に変換されるとします（Nはパラメーター）。 q * NがL1を超えない場合、サイドチャネル制限L1はオフになり、初期キーKの結果のキーライフタイム制限は、新しい組み合わせ制限L2 'に基づいて計算できます。 キー再生成を使用しない基本操作モード（したがって、L2 <L2 '）と比較すると、内部キー再生成を使用する操作モードのセキュリティが向上します。 したがって、図8に示すように、内部のキー再生成を使用した場合のキーの有効期間の制限は、L2 'まで増やすことができます。"
    },
    {
      "indent": 3,
      "text": "  K-----> K^1-------------> K^2 -----------> . . .\n          |                 |\n          v                 v\n^ +---------------+---------------+------------------+--...--+\n| |=============L1|=============L1|======          L2|    L2'|\n| |===============|===============|======            |       |\nq |===============|===============|====== . . .      |       |\n| |===============|===============|======            |       |\n| |===============|===============|======            |       |\nv +---------------+---------------+------------------+--...--+\n  <-------N------->",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 8: Basic Principles of Message Processing with Internal Re-keying",
      "ja": "図8：内部キー再生成を使用したメッセージ処理の基本原則"
    },
    {
      "indent": 3,
      "text": "Note: The key transformation process is depicted in a simplified form. A specific approach (ACPKM and ACPKM-Master re-keying mechanisms) is described below.",
      "ja": "注：キー変換プロセスは、簡略化された形式で示されています。 特定のアプローチ（ACPKMおよびACPKMマスターキー再生成メカニズム）を以下に説明します。"
    },
    {
      "indent": 3,
      "text": "Since the performance of encryption can slightly decrease for rather small values of N, the maximum possible value should be selected for parameter N for a particular protocol in order to provide the necessary key lifetime for the considered security models.",
      "ja": "暗号化のパフォーマンスは、Nの値がやや小さいとわずかに低下する可能性があるため、考慮されるセキュリティモデルに必要なキーの有効期間を提供するために、特定のプロトコルのパラメーターNに最大値を選択する必要があります"
    },
    {
      "indent": 3,
      "text": "Consider an example. Suppose L1 = 128 MB and L2 = 10 TB. Let the message size in the protocol be large/unlimited (which may exhaust the whole key lifetime L2). The most restrictive resulting key lifetime limitation is equal to 128 MB.",
      "ja": "例を考えてみましょう。 L1 = 128 MB、L2 = 10 TBと仮定します。 プロトコルのメッセージサイズを大きく/無制限にします（これにより、キーの有効期間L2全体が使い果たされる可能性があります）。 結果として最も制限の厳しいキーの有効期間制限は、128 MBに相当します。"
    },
    {
      "indent": 3,
      "text": "Thus, there is a need to put a limit on the maximum message size m_max. For example, if m_max = 32 MB, it may happen that the renegotiation of initial key K would be required after processing only four messages.",
      "ja": "したがって、最大メッセージサイズm_maxに制限を設ける必要があります。 たとえば、m_max = 32 MBの場合、4つのメッセージのみを処理した後に初期キーKの再ネゴシエーションが必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "If an internal re-keying mechanism with section size N = 1 MB is used, more than L1 / N = 128 MB / 1 MB = 128 messages can be processed before the renegotiation of initial key K (instead of four messages when an internal re-keying mechanism is not used). Note that only one section of each message is processed with the section key K^i, and, consequently, the key lifetime limitation L1 goes off. Hence, the resulting key lifetime limitation L2' can be set to more than 10 TB (in cases when a single large message is processed using the initial key K).",
      "ja": "セクションサイズN = 1 MBの内部キー再生成メカニズムが使用される場合、初期キーKの再ネゴシエーションの前にL1 / N = 128 MB / 1 MB = 128を超えるメッセージを処理できます（内部再 -キーイングメカニズムは使用されません）。 各メッセージの1つのセクションのみがセクションキーK ^ iで処理されるため、キーの有効期間制限L1が無効になることに注意してください。 したがって、結果のキーライフタイム制限L2 'は10 TBを超える値に設定できます（初期キーKを使用して単一の大きなメッセージが処理される場合）。"
    },
    {
      "indent": 0,
      "text": "6.1. Methods of Key Lifetime Control",
      "section_title": true,
      "ja": "6.1. キーライフタイムコントロールの方法"
    },
    {
      "indent": 3,
      "text": "Suppose L is an amount of data that can be safely processed with one section key and N is a section size (fixed parameter). Suppose M^{i}_1 is the first section of message M^{i}, i = 1, ... , q (see Figures 9 and 10); the parameter q can then be calculated in accordance with one of the following two approaches:",
      "ja": "Lが1つのセクションキーで安全に処理できるデータ量であり、Nがセクションサイズ（固定パラメーター）であるとします。 M ^ {i} _1がメッセージM ^ {i}の最初のセクションであるとします。i= 1、...、q（図9および10を参照）。 パラメータqは、次の2つのアプローチのいずれかに従って計算できます。"
    },
    {
      "indent": 3,
      "text": "o Explicit approach: q_i is such that |M^{1}_1| + ... + |M^{q}_1| <= L, |M^{1}_1| + ... + |M^{q+1}_1| > L This approach allows use of the section key K^i in an almost optimal way, but it can be applied only when messages cannot be lost or reordered (e.g., TLS records).",
      "ja": "o 明示的なアプローチ：q_iは、| M ^ {1} _1 | + ... + | M ^ {q} _1 | <= L、| M ^ {1} _1 | + ... + | M ^ {q + 1} _1 | > Lこのアプローチでは、セクションキーK ^ iをほぼ最適な方法で使用できますが、メッセージの損失や並べ替えができない場合にのみ適用できます（TLSレコードなど）。"
    },
    {
      "indent": 3,
      "text": "o Implicit approach: q = L / N. The amount of data processed with one section key K^i is calculated under the assumption that the length of every message is equal to or greater than section size N and thus can be considerably less than the key lifetime limitation L. On the other hand, this approach can be applied when messages may be lost or reordered (e.g., DTLS records).",
      "ja": "o 暗黙的アプローチ：q = L /N。1つのセクションキーK ^ iで処理されるデータ量は、すべてのメッセージの長さがセクションサイズN以上であるため、キーよりもかなり小さいと仮定して計算されます。 一方、このアプローチは、メッセージが失われたり並べ替えられたりする可能性がある場合（DTLSレコードなど）に適用できます。"
    },
    {
      "indent": 0,
      "text": "6.2. Constructions that Do Not Require a Master Key",
      "section_title": true,
      "ja": "6.2. マスターキーを必要としない構造"
    },
    {
      "indent": 3,
      "text": "This section describes the block cipher modes that use the ACPKM re-keying mechanism, which does not use a master key; an initial key is used directly for the data encryption.",
      "ja": "このセクションでは、マスターキーを使用しないACPKMキー変更メカニズムを使用するブロック暗号モードについて説明します。 データの暗号化には初期キーが直接使用されます。"
    },
    {
      "indent": 0,
      "text": "6.2.1. ACPKM Re-keying Mechanisms",
      "section_title": true,
      "ja": "6.2.1. ACPKMキー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "This section defines a periodical key transformation without a master key, which is called the ACPKM re-keying mechanism. This mechanism can be applied to one of the base encryption modes (CTR and GCM block cipher modes) to get an extension of this encryption mode that uses periodical key transformation without a master key. This extension can be considered as a new encryption mode.",
      "ja": "このセクションでは、マスターキーなしの定期的なキー変換を定義します。これはACPKMキー再生成メカニズムと呼ばれます。 このメカニズムをベース暗号化モード（CTRおよびGCMブロック暗号モード）のいずれかに適用して、マスターキーなしで定期的なキー変換を使用するこの暗号化モードの拡張機能を取得できます。 この拡張機能は、新しい暗号化モードと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "An additional parameter that defines the functioning of base encryption modes with the ACPKM re-keying mechanism is the section size N. The value of N is measured in bits and is fixed within a specific protocol based on the requirements of the system capacity and the key lifetime. The section size N MUST be divisible by the block size n.",
      "ja": "ACPKMキー再生成メカニズムを使用した基本暗号化モードの機能を定義する追加パラメーターは、セクションサイズNです。Nの値はビット単位で測定され、システム容量とキーの要件に基づいて特定のプロトコル内で固定されます 一生。 セクションサイズNは、ブロックサイズnで割り切れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The main idea behind internal re-keying without a master key is presented in Figure 9:",
      "ja": "マスターキーなしの内部キー再生成の背後にある主な考え方を図9に示します。"
    },
    {
      "indent": 3,
      "text": "Section size = const = N,\nmaximum message size = m_max.\n____________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "              ACPKM       ACPKM              ACPKM\n       K^1 = K ---> K^2 ---...-> K^{l_max-1} ----> K^{l_max}\n           |          |                |           |\n           |          |                |           |\n           v          v                v           v\nM^{1} |==========|==========| ... |==========|=======:  |\nM^{2} |==========|==========| ... |===       |       :  |\n  .        .          .        .       .          .  :\n  :        :          :        :       :          :  :\nM^{q} |==========|==========| ... |==========|=====  :  |\n                   section                           :\n                 <---------->                      m_max\n                    N bit\n___________________________________________________________________\nl_max = ceil(m_max/N).",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 9: Internal Re-keying without a Master Key",
      "ja": "図9：マスターキーを使用しない内部キー再生成"
    },
    {
      "indent": 3,
      "text": "During the processing of the input message M with the length m in some encryption mode that uses the ACPKM key transformation of the initial key K, the message is divided into l = ceil(m / N) sections (denoted as M = M_1 | M_2 | ... | M_l, where M_i is in V_N for i in {1, 2, ... , l - 1} and M_l is in V_r, r <= N). The first section of each message is processed with the section key K^1 = K. To process the (i + 1)-th section of each message, the section key K^{i+1} is calculated using the ACPKM transformation as follows:",
      "ja": "初期キーKのACPKMキー変換を使用する暗号化モードで長さmの入力メッセージMの処理中、メッセージはl = ceil（m / N）セクションに分割されます（M = M_1 | M_2と表記） | ... | M_l、ここでM_iは{1、2、...、l-1}のiのV_Nにあり、M_lはV_rにあり、r <= N）。 各メッセージの最初のセクションはセクションキーK ^ 1 = Kで処理されます。各メッセージの（i + 1）番目のセクションを処理するために、セクションキーK ^ {i + 1}はACPKM変換を使用して計算されます。 次のとおりです。"
    },
    {
      "indent": 6,
      "text": "K^{i+1} = ACPKM(K^i) = MSB_k(E_{K^i}(D_1) | ... | E_{K^i}(D_J)),",
      "ja": "K ^ {i + 1} = ACPKM（K ^ i）= MSB_k（E_ {K ^ i}（D_1）| ... | E_ {K ^ i}（D_J））、"
    },
    {
      "indent": 3,
      "text": "where J = ceil(k/n) and D_1, D_2, ... , D_J are in V_n and are calculated as follows:",
      "ja": "ここで、J = ceil（k / n）およびD_1、D_2、...、D_JはV_nにあり、次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "D_1 | D_2 | ... | D_J = MSB_{J * n}(D),",
      "ja": "D_1 | D_2 | ... | D_J = MSB_ {J * n}（D）、"
    },
    {
      "indent": 3,
      "text": "where D is the following constant in V_{1024}:",
      "ja": "ここで、DはV_ {1024}の次の定数です。"
    },
    {
      "indent": 13,
      "text": "D = ( 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87\n    | 88 | 89 | 8a | 8b | 8c | 8d | 8e | 8f\n    | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97\n    | 98 | 99 | 9a | 9b | 9c | 9d | 9e | 9f\n    | a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7\n    | a8 | a9 | aa | ab | ac | ad | ae | af\n    | b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7\n    | b8 | b9 | ba | bb | bc | bd | be | bf\n    | c0 | c1 | c2 | c3 | c4 | c5 | c6 | c7\n    | c8 | c9 | ca | cb | cc | cd | ce | cf\n    | d0 | d1 | d2 | d3 | d4 | d5 | d6 | d7\n    | d8 | d9 | da | db | dc | dd | de | df\n    | e0 | e1 | e2 | e3 | e4 | e5 | e6 | e7\n    | e8 | e9 | ea | eb | ec | ed | ee | ef\n    | f0 | f1 | f2 | f3 | f4 | f5 | f6 | f7\n    | f8 | f9 | fa | fb | fc | fd | fe | ff)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The constant D is such that D_1, ... , D_J are pairwise different for any allowed n and k values.",
      "ja": "注：定数Dは、許可されたn値とk値に対して、D_1、...、D_Jがペアごとに異なるようなものです。"
    },
    {
      "indent": 3,
      "text": "Note: The highest bit of each octet of the constant D is equal to 1. This condition is important as, in conjunction with a certain mode message length limitation, it allows prevention of collisions of block cipher permutation inputs in cases with key transformation and message processing (for more details, see Section 4.4 of [AAOS2017]).",
      "ja": "注：定数Dの各オクテットの最上位ビットは1に等しい。この条件は、特定のモードメッセージ長の制限と併せて、キー変換およびメッセージの場合のブロック暗号置換入力の衝突の防止を可能にするため重要である 処理（詳細については、[AAOS2017]のセクション4.4を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.2. CTR-ACPKM Encryption Mode",
      "section_title": true,
      "ja": "6.2.2. CTR-ACPKM暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines a CTR-ACPKM encryption mode that uses the ACPKM internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM内部キー再生成メカニズムを使用するCTR-ACPKM暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM mode can be considered as the base encryption mode CTR (see [MODES]) extended by the ACPKM re-keying mechanism.",
      "ja": "CTR-ACPKMモードは、ACPKMキー再生成メカニズムによって拡張されたベース暗号化モードCTR（[MODES]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM encryption mode can be used with the following parameters:",
      "ja": "CTR-ACPKM暗号化モードは、次のパラメータとともに使用できます。"
    },
    {
      "indent": 3,
      "text": "o 64 <= n <= 512.",
      "ja": "o 64 <= n <= 512。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The number c of bits in a specific part of the block to be incremented is such that 32 <= c <= 3 / 4 n, where c is a multiple of 8.",
      "ja": "o インクリメントされるブロックの特定の部分のビット数cは、32 <= c <= 3/4 n（cは8の倍数）です。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = n * 2^{c-1}.",
      "ja": "o 最大メッセージサイズm_max = n * 2 ^ {c-1}。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM mode encryption and decryption procedures are defined as follows:",
      "ja": "CTR-ACPKMモードの暗号化および復号化手順は、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CTR-ACPKM-Encrypt(N, K, ICN, P)                               |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - initial counter nonce ICN in V_{n-c},                       |\n|  - plaintext P = P_1 | ... | P_b, |P| <= m_max.                |\n|  Output:                                                       |\n|  - ciphertext C.                                               |\n|----------------------------------------------------------------|\n|  1. CTR_1 = ICN | 0^c                                          |\n|  2. For j = 2, 3, ... , b do                                   |\n|         CTR_{j} = Inc_c(CTR_{j-1})                             |\n|  3. K^1 = K                                                    |\n|  4. For i = 2, 3, ... , ceil(|P| / N)                          |\n|         K^i = ACPKM(K^{i-1})                                   |\n|  5. For j = 1, 2, ... , b do                                   |\n|         i = ceil(j * n / N),                                   |\n|         G_j = E_{K^i}(CTR_j)                                   |\n|  6. C = P (xor) MSB_{|P|}(G_1 | ... | G_b)                     |\n|  7. Return C                                                   |\n+----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CTR-ACPKM-Decrypt(N, K, ICN, C)                               |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - initial counter nonce ICN in V_{n-c},                       |\n|  - ciphertext C = C_1 | ... | C_b, |C| <= m_max.               |\n|  Output:                                                       |\n|  - plaintext P.                                                |\n|----------------------------------------------------------------|\n|  1. P = CTR-ACPKM-Encrypt(N, K, ICN, C)                        |\n|  2. Return P                                                   |\n+----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The initial counter nonce (ICN) value for each message that is encrypted under the given initial key K must be chosen in a unique manner.",
      "ja": "指定された初期キーKで暗号化される各メッセージの初期カウンターナンス（ICN）値は、一意の方法で選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. GCM-ACPKM Authenticated Encryption Mode",
      "section_title": true,
      "ja": "6.2.3. GCM-ACPKM認証暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines the GCM-ACPKM authenticated encryption mode that uses the ACPKM internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM内部キー再生成メカニズムを使用するGCM-ACPKM認証暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM mode can be considered as the base authenticated encryption mode GCM (see [GCM]) extended by the ACPKM re-keying mechanism.",
      "ja": "GCM-ACPKMモードは、ACPKMキー再生成メカニズムによって拡張された基本認証暗号化モードGCM（[GCM]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM authenticated encryption mode can be used with the following parameters:",
      "ja": "GCM-ACPKM認証暗号化モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o n in {128, 256}.",
      "ja": "o {128、256}のn。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The number c of bits in a specific part of the block to be incremented is such that 1 / 4 n <= c <= 1 / 2 n, c is a multiple of 8.",
      "ja": "o インクリメントされるブロックの特定部分のビット数cは、1/4 n <= c <= 1/2 nであり、cは8の倍数です。"
    },
    {
      "indent": 3,
      "text": "o Authentication tag length t.",
      "ja": "o 認証タグの長さt。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = min{n * (2^{c-1} - 2), 2^{n/2} - 1}.",
      "ja": "o 最大メッセージサイズm_max = min {n *（2 ^ {c-1}-2）、2 ^ {n / 2}-1}。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM mode encryption and decryption procedures are defined as follows:",
      "ja": "GCM-ACPKMモードの暗号化および復号化手順は、次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GHASH(X, H)                                                      |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - bit string X = X_1 | ... | X_m, X_1, ... , X_m in V_n.         |\n|  Output:                                                          |\n|  - block GHASH(X, H) in V_n.                                      |\n|-------------------------------------------------------------------|\n|  1. Y_0 = 0^n                                                     |\n|  2. For i = 1, ... , m do                                         |\n|         Y_i = (Y_{i-1} (xor) X_i) * H                             |\n|  3. Return Y_m                                                    |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCTR(N, K, ICB, X)                                               |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - initial counter block ICB,                                     |\n|  - X = X_1 | ... | X_b.                                           |\n|  Output:                                                          |\n|  - Y in V_{|X|}.                                                  |\n|-------------------------------------------------------------------|\n|  1. If X in V_0, then return Y, where Y in V_0                    |\n|  2. GCTR_1 = ICB                                                  |\n|  3. For i = 2, ... , b do                                         |\n|         GCTR_i = Inc_c(GCTR_{i-1})                                |\n|  4. K^1 = K                                                       |\n|  5. For j = 2, ... , ceil(|X| / N)                                |\n|         K^j = ACPKM(K^{j-1})                                      |\n|  6. For i = 1, ... , b do                                         |\n|         j = ceil(i * n / N),                                      |\n|         G_i = E_{K_j}(GCTR_i)                                     |\n|  7. Y = X (xor) MSB_{|X|}(G_1 | ... | G_b)                        |\n|  8. Return Y                                                      |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCM-ACPKM-Encrypt(N, K, ICN, P, A)                               |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - initial counter nonce ICN in V_{n-c},                          |\n|  - plaintext P = P_1 | ... | P_b, |P| <= m_max,                   |\n|  - additional authenticated data A.                               |\n|  Output:                                                          |\n|  - ciphertext C,                                                  |\n|  - authentication tag T.                                          |\n|-------------------------------------------------------------------|\n|  1. H = E_{K}(0^n)                                                |\n|  2. ICB_0 = ICN | 0^{c-1} | 1                                     |\n|  3. C = GCTR(N, K, Inc_c(ICB_0), P)                               |\n|  4. u = n * ceil(|C| / n) - |C|                                   |\n|     v = n * ceil(|A| / n) - |A|                                   |\n|  5. S = GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n|               | Vec_{n/2}(|C|), H)                                |\n|  6. T = MSB_t(E_{K}(ICB_0) (xor) S)                               |\n|  7. Return C | T                                                  |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCM-ACPKM-Decrypt(N, K, ICN, A, C, T)                            |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - initial counter block ICN,                                     |\n|  - additional authenticated data A,                               |\n|  - ciphertext C = C_1 | ... | C_b, |C| <= m_max,                  |\n|  - authentication tag T.                                          |\n|  Output:                                                          |\n|  - plaintext P or FAIL.                                           |\n|-------------------------------------------------------------------|\n|  1. H = E_{K}(0^n)                                                |\n|  2. ICB_0 = ICN | 0^{c-1} | 1                                     |\n|  3. P = GCTR(N, K, Inc_c(ICB_0), C)                               |\n|  4. u = n * ceil(|C| / n) - |C|                                   |\n|     v = n * ceil(|A| / n) - |A|                                   |\n|  5. S = GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n|               | Vec_{n/2}(|C|), H)                                |\n|  6. T' = MSB_t(E_{K}(ICB_0) (xor) S)                              |\n|  7. If T = T', then return P; else return FAIL                    |\n+-------------------------------------------------------------------+ The * operation on (pairs of) the 2^n possible blocks corresponds to\nthe multiplication operation for the binary Galois (finite) field of\n2^n elements defined by the polynomial f as follows (analogous to\n[GCM]):",
      "raw": true
    },
    {
      "indent": 3,
      "text": "n = 128: f = a^128 + a^7 + a^2 + a^1 + 1,",
      "ja": "n = 128：f = a ^ 128 + a ^ 7 + a ^ 2 + a ^ 1 + 1"
    },
    {
      "indent": 3,
      "text": "n = 256: f = a^256 + a^10 + a^5 + a^2 + 1.",
      "ja": "n = 256：f = a ^ 256 + a ^ 10 + a ^ 5 + a ^ 2 + 1。"
    },
    {
      "indent": 3,
      "text": "The initial counter nonce ICN value for each message that is encrypted under the given initial key K must be chosen in a unique manner.",
      "ja": "指定された初期キーKで暗号化される各メッセージの初期カウンターnonce ICN値は、一意の方法で選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The key for computing values E_{K}(ICB_0) and H is not updated and is equal to the initial key K.",
      "ja": "値E_ {K}（ICB_0）およびHを計算するためのキーは更新されず、初期キーKと等しくなります。"
    },
    {
      "indent": 0,
      "text": "6.3. Constructions that Require a Master Key",
      "section_title": true,
      "ja": "6.3. マスターキーが必要な構造"
    },
    {
      "indent": 3,
      "text": "This section describes the block cipher modes that use the ACPKM-Master re-keying mechanism, which use the initial key K as a master key, so K is never used directly for data processing but is used for key derivation.",
      "ja": "このセクションでは、初期キーKをマスターキーとして使用するACPKM-Masterのキー変更メカニズムを使用するブロック暗号モードについて説明します。したがって、Kはデータ処理に直接使用されることはなく、キー導出に使用されます。"
    },
    {
      "indent": 0,
      "text": "6.3.1. ACPKM-Master Key Derivation from the Master Key",
      "section_title": true,
      "ja": "6.3.1. マスターキーからのACPKMマスターキーの派生"
    },
    {
      "indent": 3,
      "text": "This section defines periodical key transformation with a master key, which is called the ACPKM-Master re-keying mechanism. This mechanism can be applied to one of the base modes of operation (CTR, GCM, CBC, CFB, OMAC modes) for getting an extension that uses periodical key transformation with a master key. This extension can be considered as a new mode of operation.",
      "ja": "このセクションでは、ACPKM-Master re-keying mechanismと呼ばれるマスターキーを使用した定期的なキー変換を定義します。 このメカニズムは、マスターキーによる定期的なキー変換を使用する拡張機能を取得するための基本操作モード（CTR、GCM、CBC、CFB、OMACモード）のいずれかに適用できます。 この拡張機能は、新しい動作モードと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "Additional parameters that define the functioning of modes of operation that use the ACPKM-Master re-keying mechanism are the section size N, the change frequency T* of the master keys K*_1, K*_2, ... (see Figure 10), and the size d of the section key material. The values of N and T* are measured in bits and are fixed within a specific protocol based on the requirements of the system capacity and the key lifetime. The section size N MUST be divisible by the block size n. The master key frequency T* MUST be divisible by d and by n.",
      "ja": "ACPKM-Masterキー再生成メカニズムを使用する動作モードの機能を定義する追加パラメーターは、セクションサイズN、マスターキーK * _1、K * _2、...の変更頻度T *です（図10を参照） ）、およびセクションキーマテリアルのサイズd。 NとT *の値はビット単位で測定され、システム容量とキーの寿命の要件に基づいて特定のプロトコル内で固定されます。 セクションサイズNは、ブロックサイズnで割り切れる必要があります。 マスターキーの頻度T *は、dとnで割り切れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The main idea behind internal re-keying with a master key is presented in Figure 10:",
      "ja": "マスターキーを使用した内部キー再生成の背後にある主な考え方を図10に示します。"
    },
    {
      "indent": 3,
      "text": "Master key frequency T*,\nsection size N,\nmaximum message size = m_max.\n_____________________________________________________________________",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                        ACPKM                 ACPKM\n             K*_1 = K----------> K*_2 ---------...-----> K*_l_max\n            ___|___            ___|___                 ___|___\n           |       |          |       |               |       |\n           v  ...  v          v  ...  v               v  ...  v\n         K[1]     K[t]     K[t+1]  K[2*t]  K[(l_max-1)t+1] K[l_max*t]\n           |       |          |       |               |       |\n           |       |          |       |               |       |\n           v       v          v       v               v       v\nM^{1}||======|...|======||======|...|======||...||======|...|==  : ||\nM^{2}||======|...|======||======|...|======||...||======|...|====: ||\n ... ||      |   |      ||      |   |      ||   ||      |   |    : ||\nM^{q}||======|...|======||====  |...|      ||...||      |...|    : ||\n       section                                                   :\n      <------>                                                   :\n        N bit                                                  m_max\n_____________________________________________________________________\n|K[i]| = d,\nt = T* / d,\nl_max = ceil(m_max / (N * t)).",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 10: Internal Re-keying with a Master Key",
      "ja": "図10：マスターキーを使用した内部キー再生成"
    },
    {
      "indent": 3,
      "text": "During the processing of the input message M with the length m in some mode of operation that uses ACPKM-Master key transformation with the initial key K and the master key frequency T*, the message M is divided into l = ceil(m / N) sections (denoted as M = M_1 | M_2 | ... | M_l, where M_i is in V_N for i in {1, 2, ... , l - 1} and M_l is in V_r, r <= N). The j-th section of each message is processed with the key material K[j], j in {1, ... , l}, |K[j]| = d, which is calculated with the ACPKM-Master algorithm as follows:",
      "ja": "初期キーKおよびマスターキー周波数T *を使用したACPKMマスターキー変換を使用する動作モードで、長さmの入力メッセージMの処理中に、メッセージMはl = ceil（m / N ）セクション（M = M_1 | M_2 | ... | M_lと表記、ここでM_iは{1、2、...、l-1}のiに対してV_Nにあり、M_lはV_rにあり、r <= N）。 各メッセージのj番目のセクションは、鍵素材K [j]で処理されます。jは{1、...、l}にあり、| K [j] | = d。次のようにACPKM-Masterアルゴリズムで計算されます。"
    },
    {
      "indent": 6,
      "text": "K[1] | ... | K[l] = ACPKM-Master(T*, K, d, l) = CTR-ACPKM-Encrypt (T*, K, 1^{n/2}, 0^{d*l}).",
      "ja": "K [1] | ... | K [l] = ACPKM-Master（T *、K、d、l）= CTR-ACPKM-Encrypt（T *、K、1 ^ {n / 2}、0 ^ {d * l}）。"
    },
    {
      "indent": 3,
      "text": "Note: The parameters d and l MUST be such that d * l <= n * 2^{n/2-1}.",
      "ja": "注：パラメーターdおよびlは、d * l <= n * 2 ^ {n / 2-1}である必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.2. CTR-ACPKM-Master Encryption Mode",
      "section_title": true,
      "ja": "6.3.2. CTR-ACPKM-マスター暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines a CTR-ACPKM-Master encryption mode that uses the ACPKM-Master internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM-Master内部キー再生成メカニズムを使用するCTR-ACPKM-Master暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM-Master encryption mode can be considered as the base encryption mode CTR (see [MODES]) extended by the ACPKM-Master re-keying mechanism.",
      "ja": "CTR-ACPKM-Master暗号化モードは、ACPKM-Masterキー再生成メカニズムによって拡張されたベース暗号化モードCTR（[MODES]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM-Master encryption mode can be used with the following parameters:",
      "ja": "CTR-ACPKM-Master暗号化モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o 64 <= n <= 512.",
      "ja": "o 64 <= n <= 512。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The number c of bits in a specific part of the block to be incremented is such that 32 <= c <= 3 / 4 n, c is a multiple of 8.",
      "ja": "o インクリメントするブロックの特定の部分のビット数cは、32 <= c <= 3/4 n、cは8の倍数です。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = min{N * (n * 2^{n/2-1} / k), n * 2^c}.",
      "ja": "o 最大メッセージサイズm_max = min {N *（n * 2 ^ {n / 2-1} / k）、n * 2 ^ c}。"
    },
    {
      "indent": 3,
      "text": "The key material K[j] that is used for one-section processing is equal to K^j, where |K^j| = k bits.",
      "ja": "1セクション処理に使用されるキーマテリアルK [j]はK ^ jに等しく、ここで| K ^ j | = kビット。"
    },
    {
      "indent": 3,
      "text": "The CTR-ACPKM-Master mode encryption and decryption procedures are defined as follows:",
      "ja": "CTR-ACPKM-Masterモードの暗号化および復号化手順は、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CTR-ACPKM-Master-Encrypt(N, K, T*, ICN, P)                    |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - master key frequency T*,                                    |\n|  - initial counter nonce ICN in V_{n-c},                       |\n|  - plaintext P = P_1 | ... | P_b, |P| <= m_max.                |\n|  Output:                                                       |\n|  - ciphertext C.                                               |\n|----------------------------------------------------------------|\n|  1. CTR_1 = ICN | 0^c                                          |\n|  2. For j = 2, 3, ... , b do                                   |\n|         CTR_{j} = Inc_c(CTR_{j-1})                             |\n|  3. l = ceil(|P| / N)                                          |\n|  4. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                |\n|  5. For j = 1, 2, ... , b do                                   |\n|         i = ceil(j * n / N),                                   |\n|         G_j = E_{K^i}(CTR_j)                                   |\n|  6. C = P (xor) MSB_{|P|}(G_1 | ... |G_b)                      |\n|  7. Return C                                                   |\n|----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CTR-ACPKM-Master-Decrypt(N, K, T*, ICN, C)                    |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - master key frequency T*,                                    |\n|  - initial counter nonce ICN in V_{n-c},                       |\n|  - ciphertext C = C_1 | ... | C_b, |C| <= m_max.               |\n|  Output:                                                       |\n|  - plaintext P.                                                |\n|----------------------------------------------------------------|\n|  1. P = CTR-ACPKM-Master-Encrypt(N, K, T*, ICN, C)             |\n|  1. Return P                                                   |\n+----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The initial counter nonce ICN value for each message that is encrypted under the given initial key must be chosen in a unique manner.",
      "ja": "指定された初期キーで暗号化される各メッセージの初期カウンターノンスICN値は、一意の方法で選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.3. GCM-ACPKM-Master Authenticated Encryption Mode",
      "section_title": true,
      "ja": "6.3.3. GCM-ACPKM-Master認証済み暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines a GCM-ACPKM-Master authenticated encryption mode that uses the ACPKM-Master internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM-Master内部キー再生成メカニズムを使用するGCM-ACPKM-Master認証暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM-Master authenticated encryption mode can be considered as the base authenticated encryption mode GCM (see [GCM]) extended by the ACPKM-Master re-keying mechanism.",
      "ja": "GCM-ACPKM-Master認証暗号化モードは、ACPKM-Masterキー再生成メカニズムによって拡張されたベース認証暗号化モードGCM（[GCM]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM-Master authenticated encryption mode can be used with the following parameters:",
      "ja": "GCM-ACPKM-Master認証暗号化モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o n in {128, 256}.",
      "ja": "o {128、256}のn。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The number c of bits in a specific part of the block to be incremented is such that 1 / 4 n <= c <= 1 / 2 n, c is a multiple of 8.",
      "ja": "o インクリメントされるブロックの特定部分のビット数cは、1/4 n <= c <= 1/2 nであり、cは8の倍数です。"
    },
    {
      "indent": 3,
      "text": "o authentication tag length t.",
      "ja": "o 認証タグの長さt。"
    },
    {
      "indent": 3,
      "text": "o the maximum message size m_max = min{N * ( n * 2^{n/2-1} / k), n * (2^c - 2), 2^{n/2} - 1}.",
      "ja": "o 最大メッセージサイズm_max = min {N *（n * 2 ^ {n / 2-1} / k）、n *（2 ^ c-2）、2 ^ {n / 2}-1}。"
    },
    {
      "indent": 3,
      "text": "The key material K[j] that is used for the j-th section processing is equal to K^j, |K^j| = k bits.",
      "ja": "j番目のセクション処理に使用されるキーマテリアルK [j]は、K ^ j、| K ^ j |に等しい = kビット。"
    },
    {
      "indent": 3,
      "text": "The GCM-ACPKM-Master mode encryption and decryption procedures are defined as follows:",
      "ja": "GCM-ACPKM-Masterモードの暗号化および復号化手順は、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GHASH(X, H)                                                      |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - bit string X = X_1 | ... | X_m, X_i in V_n for i in {1, ... ,m}|\n|  Output:                                                          |\n|  - block GHASH(X, H) in V_n                                       |\n|-------------------------------------------------------------------|\n|  1. Y_0 = 0^n                                                     |\n|  2. For i = 1, ... , m do                                         |\n|         Y_i = (Y_{i-1} (xor) X_i) * H                             |\n|  3. Return Y_m                                                    |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCTR(N, K, T*, ICB, X)                                           |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - master key frequency T*,                                       |\n|  - initial counter block ICB,                                     |\n|  - X = X_1 | ... | X_b.                                           |\n|  Output:                                                          |\n|  - Y in V_{|X|}.                                                  |\n|-------------------------------------------------------------------|\n|  1. If X in V_0, then return Y, where Y in V_0                    |\n|  2. GCTR_1 = ICB                                                  |\n|  3. For i = 2, ... , b do                                         |\n|         GCTR_i = Inc_c(GCTR_{i-1})                                |\n|  4. l = ceil(|X| / N)                                             |\n|  5. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                   |\n|  6. For j = 1, ... , b do                                         |\n|         i = ceil(j * n / N),                                      |\n|         G_j = E_{K^i}(GCTR_j)                                     |\n|  7. Y = X (xor) MSB_{|X|}(G_1 | ... | G_b)                        |\n|  8. Return Y                                                      |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCM-ACPKM-Master-Encrypt(N, K, T*, ICN, P, A)                    |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - master key frequency T*,                                       |\n|  - initial counter nonce ICN in V_{n-c},                          |\n|  - plaintext P = P_1 | ... | P_b, |P| <= m_max.                   |\n|  - additional authenticated data A.                               |\n|  Output:                                                          |\n|  - ciphertext C,                                                  |\n|  - authentication tag T.                                          |\n|-------------------------------------------------------------------|\n|  1. K^1 = ACPKM-Master(T*, K, k, 1)                               |\n|  2. H = E_{K^1}(0^n)                                              |\n|  3. ICB_0 = ICN | 0^{c-1} | 1                                     |\n|  4. C = GCTR(N, K, T*, Inc_c(ICB_0), P)                           |\n|  5. u = n * ceil(|C| / n) - |C|                                   |\n|     v = n * ceil(|A| / n) - |A|                                   |\n|  6. S = GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n|               | Vec_{n/2}(|C|), H)                                |\n|  7. T = MSB_t(E_{K^1}(ICB_0) (xor) S)                             |\n|  8. Return C | T                                                  |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|  GCM-ACPKM-Master-Decrypt(N, K, T*, ICN, A, C, T)                 |\n|-------------------------------------------------------------------|\n|  Input:                                                           |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - master key frequency T*,                                       |\n|  - initial counter nonce ICN in V_{n-c},                          |\n|  - additional authenticated data A.                               |\n|  - ciphertext C = C_1 | ... | C_b, |C| <= m_max,                  |\n|  - authentication tag T.                                          |\n|  Output:                                                          |\n|  - plaintext P or FAIL.                                           |\n|-------------------------------------------------------------------|\n|  1. K^1 = ACPKM-Master(T*, K, k, 1)                               |\n|  2. H = E_{K^1}(0^n)                                              |\n|  3. ICB_0 = ICN | 0^{c-1} | 1                                     |\n|  4. P = GCTR(N, K, T*, Inc_c(ICB_0), C)                           |\n|  5. u = n * ceil(|C| / n) - |C|                                   |\n|     v = n * ceil(|A| / n) - |A|                                   |\n|  6. S = GHASH(A | 0^v | C | 0^u | Vec_{n/2}(|A|) |                |\n|               | Vec_{n/2}(|C|), H)                                |\n|  7. T' = MSB_t(E_{K^1}(ICB_0) (xor) S)                            |\n|  8. If T = T', then return P; else return FAIL.                   |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The * operation on (pairs of) the 2^n possible blocks corresponds to the multiplication operation for the binary Galois (finite) field of 2^n elements defined by the polynomial f as follows (by analogy with [GCM]):",
      "ja": "（ペアの）2 ^ n個のブロックの*演算は、次のように多項式[f]によって定義される2 ^ n要素のバイナリガロア（有限）体の乗算演算に対応します（[GCM]との類推により）。"
    },
    {
      "indent": 3,
      "text": "n = 128: f = a^128 + a^7 + a^2 + a^1 + 1,",
      "ja": "n = 128：f = a ^ 128 + a ^ 7 + a ^ 2 + a ^ 1 + 1"
    },
    {
      "indent": 3,
      "text": "n = 256: f = a^256 + a^10 + a^5 + a^2 + 1.",
      "ja": "n = 256：f = a ^ 256 + a ^ 10 + a ^ 5 + a ^ 2 + 1。"
    },
    {
      "indent": 3,
      "text": "The initial counter nonce ICN value for each message that is encrypted under the given initial key must be chosen in a unique manner.",
      "ja": "指定された初期キーで暗号化される各メッセージの初期カウンターノンスICN値は、一意の方法で選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.4. CBC-ACPKM-Master Encryption Mode",
      "section_title": true,
      "ja": "6.3.4. CBC-ACPKM-マスター暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines a CBC-ACPKM-Master encryption mode that uses the ACPKM-Master internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM-Master内部キー再生成メカニズムを使用するCBC-ACPKM-Master暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The CBC-ACPKM-Master encryption mode can be considered as the base encryption mode CBC (see [MODES]) extended by the ACPKM-Master re-keying mechanism.",
      "ja": "CBC-ACPKM-Master暗号化モードは、ACPKM-Masterキー再生成メカニズムによって拡張されたベース暗号化モードCBC（[MODES]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The CBC-ACPKM-Master encryption mode can be used with the following parameters:",
      "ja": "CBC-ACPKM-Master暗号化モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o 64 <= n <= 512.",
      "ja": "o 64 <= n <= 512。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = N * (n * 2^{n/2-1} / k).",
      "ja": "o 最大メッセージサイズm_max = N *（n * 2 ^ {n / 2-1} / k）。"
    },
    {
      "indent": 3,
      "text": "In the specification of the CBC-ACPKM-Master mode, the plaintext and ciphertext must be a sequence of one or more complete data blocks. If the data string to be encrypted does not initially satisfy this property, then it MUST be padded to form complete data blocks. The padding methods are out of the scope of this document. An example of a padding method can be found in Appendix A of [MODES].",
      "ja": "CBC-ACPKM-Masterモードの仕様では、プレーンテキストと暗号文は1つ以上の完全なデータブロックのシーケンスである必要があります。 暗号化されるデータ文字列が最初にこのプロパティを満たさない場合、完全なデータブロックを形成するためにパディングする必要があります。 パディング方法は、このドキュメントの範囲外です。 パディング方法の例は、[モード]の付録Aにあります。"
    },
    {
      "indent": 3,
      "text": "The key material K[j] that is used for the j-th section processing is equal to K^j, |K^j| = k bits.",
      "ja": "j番目のセクション処理に使用されるキーマテリアルK [j]は、K ^ j、| K ^ j |に等しい = kビット。"
    },
    {
      "indent": 3,
      "text": "We use D_{K} to denote the decryption function that is a permutation inverse to E_{K}.",
      "ja": "D_ {K}を使用して、E_ {K}の逆順列である復号化関数を示します。"
    },
    {
      "indent": 3,
      "text": "The CBC-ACPKM-Master mode encryption and decryption procedures are defined as follows:",
      "ja": "CBC-ACPKM-Masterモードの暗号化および復号化手順は、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CBC-ACPKM-Master-Encrypt(N, K, T*, IV, P)                     |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - master key frequency T*,                                    |\n|  - initialization vector IV in V_n,                            |\n|  - plaintext P = P_1 | ... | P_b, |P_b| = n, |P| <= m_max.     |\n|  Output:                                                       |\n|  - ciphertext C.                                               |\n|----------------------------------------------------------------|\n|  1. l = ceil(|P| / N)                                          |\n|  2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                |\n|  3. C_0 = IV                                                   |\n|  4. For j = 1, 2, ... , b do                                   |\n|         i = ceil(j * n / N),                                   |\n|         C_j = E_{K^i}(P_j (xor) C_{j-1})                       |\n|  5. Return C = C_1 | ... | C_b                                 |\n|----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+----------------------------------------------------------------+\n|  CBC-ACPKM-Master-Decrypt(N, K, T*, IV, C)                     |\n|----------------------------------------------------------------|\n|  Input:                                                        |\n|  - section size N,                                             |\n|  - initial key K,                                              |\n|  - master key frequency T*,                                    |\n|  - initialization vector IV in V_n,                            |\n|  - ciphertext C = C_1 | ... | C_b, |C_b| = n, |C| <= m_max.    |\n|  Output:                                                       |\n|  - plaintext P.                                                |\n|----------------------------------------------------------------|\n|  1. l = ceil(|C| / N)                                          |\n|  2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)                |\n|  3. C_0 = IV                                                   |\n|  4. For j = 1, 2, ... , b do                                   |\n|         i = ceil(j * n / N)                                    |\n|         P_j = D_{K^i}(C_j) (xor) C_{j-1}                       |\n|  5. Return P = P_1 | ... | P_b                                 |\n+----------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The initialization vector IV for any particular execution of the encryption process must be unpredictable.",
      "ja": "暗号化プロセスの特定の実行の初期化ベクトルIVは、予測不能でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.5. CFB-ACPKM-Master Encryption Mode",
      "section_title": true,
      "ja": "6.3.5. CFB-ACPKM-マスター暗号化モード"
    },
    {
      "indent": 3,
      "text": "This section defines a CFB-ACPKM-Master encryption mode that uses the ACPKM-Master internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM-Master内部キー再生成メカニズムを使用するCFB-ACPKM-Master暗号化モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The CFB-ACPKM-Master encryption mode can be considered as the base encryption mode CFB (see [MODES]) extended by the ACPKM-Master re-keying mechanism.",
      "ja": "CFB-ACPKM-Master暗号化モードは、ACPKM-Master鍵再生成メカニズムによって拡張された基本暗号化モードCFB（[MODES]を参照）と見なすことができます。"
    },
    {
      "indent": 3,
      "text": "The CFB-ACPKM-Master encryption mode can be used with the following parameters:",
      "ja": "CFB-ACPKM-Master暗号化モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o 64 <= n <= 512.",
      "ja": "o 64 <= n <= 512。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = N * (n * 2^{n/2-1} / k).",
      "ja": "o 最大メッセージサイズm_max = N *（n * 2 ^ {n / 2-1} / k）。"
    },
    {
      "indent": 3,
      "text": "The key material K[j] that is used for the j-th section processing is equal to K^j, |K^j| = k bits.",
      "ja": "j番目のセクション処理に使用されるキーマテリアルK [j]は、K ^ j、| K ^ j |に等しい = kビット。"
    },
    {
      "indent": 3,
      "text": "The CFB-ACPKM-Master mode encryption and decryption procedures are defined as follows:",
      "ja": "CFB-ACPKM-Masterモードの暗号化および復号化手順は、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------+\n|  CFB-ACPKM-Master-Encrypt(N, K, T*, IV, P)                  |\n|-------------------------------------------------------------|\n|  Input:                                                     |\n|  - section size N,                                          |\n|  - initial key K,                                           |\n|  - master key frequency T*,                                 |\n|  - initialization vector IV in V_n,                         |\n|  - plaintext P = P_1 | ... | P_b, |P| <= m_max.             |\n|  Output:                                                    |\n|  - ciphertext C.                                            |\n|-------------------------------------------------------------|\n|  1. l = ceil(|P| / N)                                       |\n|  2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)             |\n|  3. C_0 = IV                                                |\n|  4. For j = 1, 2, ... , b - 1 do                            |\n|         i = ceil(j * n / N),                                |\n|         C_j = E_{K^i}(C_{j-1}) (xor) P_j                    |\n|  5. C_b = MSB_{|P_b|}(E_{K^l}(C_{b-1})) (xor) P_b           |\n|  6. Return C = C_1 | ... | C_b                              |\n|-------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------+\n|  CFB-ACPKM-Master-Decrypt(N, K, T*, IV, C)                  |\n|-------------------------------------------------------------|\n|  Input:                                                     |\n|  - section size N,                                          |\n|  - initial key K,                                           |\n|  - master key frequency T*,                                 |\n|  - initialization vector IV in V_n,                         |\n|  - ciphertext C = C_1 | ... | C_b, |C| <= m_max.            |\n|  Output:                                                    |\n|  - plaintext P.                                             |\n|-------------------------------------------------------------|\n|  1. l = ceil(|C| / N)                                       |\n|  2. K^1 | ... | K^l = ACPKM-Master(T*, K, k, l)             |\n|  3. C_0 = IV                                                |\n|  4. For j = 1, 2, ... , b - 1 do                            |\n|         i = ceil(j * n / N),                                |\n|         P_j = E_{K^i}(C_{j-1}) (xor) C_j                    |\n|  5. P_b = MSB_{|C_b|}(E_{K^l}(C_{b-1})) (xor) C_b           |\n|  6. Return P = P_1 | ... | P_b                              |\n+-------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The initialization vector IV for any particular execution of the encryption process must be unpredictable.",
      "ja": "暗号化プロセスの特定の実行の初期化ベクトルIVは、予測不能でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.6. OMAC-ACPKM-Master Authentication Mode",
      "section_title": true,
      "ja": "6.3.6. OMAC-ACPKM-マスター認証モード"
    },
    {
      "indent": 3,
      "text": "This section defines an OMAC-ACPKM-Master message authentication code calculation mode that uses the ACPKM-Master internal re-keying mechanism for the periodical key transformation.",
      "ja": "このセクションでは、定期的なキー変換にACPKM-Master内部キー再生成メカニズムを使用するOMAC-ACPKM-Masterメッセージ認証コード計算モードを定義します。"
    },
    {
      "indent": 3,
      "text": "The OMAC-ACPKM-Master mode can be considered as the base message authentication code calculation mode OMAC1, which is also known as CMAC (see [RFC4493]), extended by the ACPKM-Master re-keying mechanism.",
      "ja": "OMAC-ACPKM-Masterモードは、ベースメッセージ認証コード計算モードOMAC1と見なすことができます。これは、CMAC（[RFC4493]を参照）としても知られ、ACPKM-Masterキー再生成メカニズムによって拡張されます。"
    },
    {
      "indent": 3,
      "text": "The OMAC-ACPKM-Master message authentication code calculation mode can be used with the following parameters:",
      "ja": "OMAC-ACPKM-Masterメッセージ認証コード計算モードは、次のパラメーターで使用できます。"
    },
    {
      "indent": 3,
      "text": "o n in {64, 128, 256}.",
      "ja": "o {64、128、256}のn。"
    },
    {
      "indent": 3,
      "text": "o 128 <= k <= 512.",
      "ja": "o 128 <= k <= 512。"
    },
    {
      "indent": 3,
      "text": "o The maximum message size m_max = N * (n * 2^{n/2-1} / (k + n)).",
      "ja": "o 最大メッセージサイズm_max = N *（n * 2 ^ {n / 2-1} /（k + n））。"
    },
    {
      "indent": 3,
      "text": "The key material K[j] that is used for one-section processing is equal to K^j | K^j_1, where |K^j| = k bits and |K^j_1| = n bits.",
      "ja": "1セクション処理に使用されるキーマテリアルK [j]は、K ^ j | K ^ j_1、ここで| K ^ j | = kビットおよび| K ^ j_1 | = nビット。"
    },
    {
      "indent": 3,
      "text": "The following is a specification of the subkey generation process of OMAC:",
      "ja": "以下は、OMACのサブキー生成プロセスの仕様です。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n| Generate_Subkey(K1, r)                                            |\n|-------------------------------------------------------------------|\n| Input:                                                            |\n|  - key K1.                                                        |\n|  Output:                                                          |\n|  - key SK.                                                        |\n|-------------------------------------------------------------------|\n|   1. If r = n, then return K1                                     |\n|   2. If r < n, then                                               |\n|          if MSB_1(K1) = 0                                         |\n|              return K1 << 1                                       |\n|          else                                                     |\n|              return (K1 << 1) (xor) R_n                           |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, R_n takes the following values:",
      "ja": "ここで、R_nは次の値を取ります。"
    },
    {
      "indent": 3,
      "text": "o n = 64: R_{64} = 0^{59} | 11011.",
      "ja": "o n = 64：R_ {64} = 0 ^ {59} | 11011。"
    },
    {
      "indent": 3,
      "text": "o n = 128: R_{128} = 0^{120} | 10000111.",
      "ja": "o n = 128：R_ {128} = 0 ^ {120} | 10000111。"
    },
    {
      "indent": 3,
      "text": "o n = 256: R_{256} = 0^{145} | 10000100101.",
      "ja": "o n = 256：R_ {256} = 0 ^ {145} | 10000100101。"
    },
    {
      "indent": 3,
      "text": "The OMAC-ACPKM-Master message authentication code calculation mode is defined as follows:",
      "ja": "OMAC-ACPKM-Masterメッセージ認証コード計算モードは、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n| OMAC-ACPKM-Master(K, N, T*, M)                                    |\n|-------------------------------------------------------------------|\n| Input:                                                            |\n|  - section size N,                                                |\n|  - initial key K,                                                 |\n|  - master key frequency T*,                                       |\n|  - plaintext M = M_1 | ... | M_b, |M| <= m_max.                   |\n|  Output:                                                          |\n|  - message authentication code T.                                 |\n|-------------------------------------------------------------------|\n| 1. C_0 = 0^n                                                      |\n| 2. l = ceil(|M| / N)                                              |\n| 3. K^1 | K^1_1 | ... | K^l | K^l_1 =                              |\n                  = ACPKM-Master(T*, K, (k + n), l)                 |\n| 4. For j = 1, 2, ... , b - 1 do                                   |\n|        i = ceil(j * n / N),                                       |\n|        C_j = E_{K^i}(M_j (xor) C_{j-1})                           |\n| 5. SK = Generate_Subkey(K^l_1, |M_b|)                             |\n| 6. If |M_b| = n, then M*_b = M_b                                  |\n|                  else M*_b = M_b | 1 | 0^{n - 1 -|M_b|}           |\n| 7. T = E_{K^l}(M*_b (xor) C_{b-1} (xor) SK)                       |\n| 8. Return T                                                       |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. Joint Usage of External and Internal Re-keying",
      "section_title": true,
      "ja": "7. 外部および内部キー再生成の共同使用"
    },
    {
      "indent": 3,
      "text": "Both external re-keying and internal re-keying have their own advantages and disadvantages, which are discussed in Section 1. For instance, using external re-keying can essentially limit the message length, while in the case of internal re-keying, the section size, which can be chosen as the maximal possible for operational properties, limits the number of separate messages. Therefore, the choice of re-keying mechanism (either external or internal) depends on particular protocol features. However, some protocols may have features that require the advantages of both the external and internal re-keying mechanisms: for example, the protocol mainly transmits short messages, but it must additionally support processing of very long messages. In such situations, it is necessary to use external and internal re-keying jointly, since these techniques negate each other's disadvantages.",
      "ja": "外部キー再生成と内部キー再生成の両方に独自の利点と欠点があります。これらについてはセクション1で説明します。たとえば、外部キー再生成を使用すると、メッセージの長さを本質的に制限できます。 セクションサイズは、運用プロパティの最大値として選択でき、個別のメッセージの数を制限します。 したがって、キー再生成メカニズム（外部または内部）の選択は、特定のプロトコル機能に依存します。 ただし、一部のプロトコルには、外部および内部のキー再生成メカニズムの両方の利点を必要とする機能があります。たとえば、プロトコルは主にショートメッセージを送信しますが、非常に長いメッセージの処理を追加でサポートする必要があります。 このような状況では、外部と内部のキー再生成を一緒に使用する必要があります。これらの技術はお互いの欠点を打ち消すからです。"
    },
    {
      "indent": 3,
      "text": "For composition of external and internal re-keying techniques, any mechanism described in Section 5 can be used with any mechanism described in Section 6.",
      "ja": "外部および内部のキー再生成手法の構成については、セクション5で説明したメカニズムをセクション6で説明したメカニズムと併用できます。"
    },
    {
      "indent": 3,
      "text": "For example, consider the GCM-ACPKM mode with external serial re-keying based on a KDF on a hash function. Denote the number of messages in each frame (in the case of the implicit approach to the key lifetime control) for external re-keying as a frame size.",
      "ja": "たとえば、ハッシュ関数のKDFに基づいた外部シリアルキー再生成を使用したGCM-ACPKMモードを考えます。 外部キー再生成のための各フレーム内のメッセージ数（キーライフタイムコントロールへの暗黙的なアプローチの場合）をフレームサイズとして示します。"
    },
    {
      "indent": 3,
      "text": "Let L be a key lifetime limitation. The section size N for internal re-keying and the frame size q for external re-keying must be chosen in such a way that q * N must not exceed L.",
      "ja": "Lをキーの有効期間の制限とします。 内部キー再生成のセクションサイズNと外部キー再生成のフレームサイズqは、q * NがLを超えないように選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose that t messages (ICN_i, P_i, A_i), with initial counter nonce ICN_i, plaintext P_i, and additional authenticated data A_i will be processed before renegotiation.",
      "ja": "初期カウンターnonce ICN_i、プレーンテキストP_i、および追加の認証データA_iを含むtメッセージ（ICN_i、P_i、A_i）が再ネゴシエーションの前に処理されると仮定します。"
    },
    {
      "indent": 3,
      "text": "For authenticated encryption of each message (ICN_i, P_i, A_i), i = 1, ..., t, the following algorithm can be applied:",
      "ja": "各メッセージ（ICN_i、P_i、A_i）の認証された暗号化、i = 1、...、tには、次のアルゴリズムを適用できます。"
    },
    {
      "indent": 3,
      "text": "1. j = ceil(i / q), 2. K^j = ExtSerialH(K, j), 3. C_i | T_i = GCM-ACPKM-Encrypt(N, K^j, ICN_i, P_i, A_i).",
      "ja": "1. j = ceil（i / q）、2. K ^ j = ExtSerialH（K、j）、3. C_i | T_i = GCM-ACPKM-Encrypt（N、K ^ j、ICN_i、P_i、A_i）"
    },
    {
      "indent": 3,
      "text": "Note that nonces ICN_i that are used under the same frame key must be unique for each message.",
      "ja": "同じフレームキーで使用されるナンスICN_iは、各メッセージで一意である必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Re-keying should be used to increase a priori security properties of ciphers in hostile environments (e.g., with side-channel adversaries). If efficient attacks on a cipher are known, the cipher must not be used. Thus, re-keying cannot be used as a patch for vulnerable ciphers. Base cipher properties must be well analyzed because the security of re-keying mechanisms is based on the security of a block cipher as a pseudorandom function.",
      "ja": "敵対的な環境（サイドチャネルの敵など）で暗号の演prior的なセキュリティプロパティを高めるために、キーの再生成を使用する必要があります。 暗号に対する効率的な攻撃が知られている場合、暗号を使用しないでください。 したがって、キーの再生成は脆弱な暗号のパッチとして使用できません。 鍵再生成メカニズムのセキュリティは、擬似乱数関数としてのブロック暗号のセキュリティに基づいているため、ベース暗号プロパティを十分に分析する必要があります。"
    },
    {
      "indent": 3,
      "text": "Re-keying is not intended to solve any postquantum security issues for symmetric cryptography, since the reduction of security caused by Grover's algorithm is not connected with a size of plaintext transformed by a cipher -- only a negligible (sufficient for key uniqueness) material is needed -- and the aim of re-keying is to limit the size of plaintext transformed under one initial key.",
      "ja": "Groverのアルゴリズムによって引き起こされるセキュリティの低下は、暗号によって変換されるプレーンテキストのサイズとは関係がないため、鍵の再生成は対称暗号の量子後のセキュリティの問題を解決することを意図していません-無視できる（鍵の一意性に十分な）材料のみです 必要-再キーイングの目的は、1つの初期キーの下で変換されるプレーンテキストのサイズを制限することです。"
    },
    {
      "indent": 3,
      "text": "Re-keying can provide backward security only if previous key material is securely deleted after usage by all parties.",
      "ja": "すべての関係者による使用後に以前のキーマテリアルが安全に削除された場合にのみ、キーの再生成によって後方セキュリティが提供されます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[CMS] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, <https://www.rfc-editor.org/info/rfc5652>.",
      "ja": "[CMS] Housley、R。、「Cryptographic Message Syntax（CMS）」、STD 70、RFC 5652、DOI 10.17487 / RFC5652、2009年9月、<https://www.rfc-editor.org/info/rfc5652>。"
    },
    {
      "indent": 3,
      "text": "[DTLS] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[DTLS] Rescorla、E。およびN. Modadugu、「データグラムトランスポートレイヤーセキュリティバージョン1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[ESP] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, DOI 10.17487/RFC4303, December 2005, <https://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[ESP]ケント、S。、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、<https://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[GCM] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\", NIST Special Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November 2007, <http://nvlpubs.nist.gov/nistpubs/Legacy/SP/ nistspecialpublication800-38d.pdf>.",
      "ja": "[GCM] Dworkin、M。、「ブロック暗号操作モードの推奨：ガロア/カウンターモード（GCM）およびGMAC」、NIST特別出版800-38D、DOI 10.6028 / NIST.SP.800-38D、2007年11月、< http://nvlpubs.nist.gov/nistpubs/Legacy/SP/ nistspecialpublication800-38d.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MODES] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation: Methods and Techniques\", NIST Special Publication 800-38A, DOI 10.6028/NIST.SP.800-38A, December 2001.",
      "ja": "[モード] Dworkin、M。、「ブロック暗号操作モードの推奨事項：方法と手法」、NIST特別公開800-38A、DOI 10.6028 / NIST.SP.800-38A、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[NISTSP800-108] National Institute of Standards and Technology, \"Recommendation for Key Derivation Using Pseudorandom Functions\", NIST Special Publication 800-108, October 2009, <http://nvlpubs.nist.gov/nistpubs/Legacy/SP/ nistspecialpublication800-108.pdf>.",
      "ja": "[NISTSP800-108]国立標準技術研究所、「擬似乱数関数を使用した鍵導出の推奨事項」、NIST Special Publication 800-108、2009年10月、<http://nvlpubs.nist.gov/nistpubs/Legacy/SP/ nistspecialpublication800 -108.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4493] Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June 2006, <https://www.rfc-editor.org/info/rfc4493>.",
      "ja": "[RFC4493] Song、JH。、Poovendran、R.、Lee、J。、およびT. Iwata、「AES-CMACアルゴリズム」、RFC 4493、DOI 10.17487 / RFC4493、2006年6月、<https：//www.rfc -editor.org/info/rfc4493>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <https://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H。、およびP. Eronen、「HMACベースの抽出および拡張キー派生関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<https：//www.rfc-editor .org / info / rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC7836] Smyshlyaev, S., Ed., Alekseev, E., Oshkin, I., Popov, V., Leontiev, S., Podobaev, V., and D. Belyavsky, \"Guidelines on the Cryptographic Algorithms to Accompany the Usage of Standards GOST R 34.10-2012 and GOST R 34.11-2012\", RFC 7836, DOI 10.17487/RFC7836, March 2016, <https://www.rfc-editor.org/info/rfc7836>.",
      "ja": "[RFC7836] Smyshlyaev、S.、Ed。、Alekseev、E.、Oshkin、I.、Popov、V.、Leontiev、S.、Podobaev、V.、およびD. Belyavsky、 \"に伴う暗号アルゴリズムのガイドライン 標準GOST R 34.10-2012およびGOST R 34.11-2012の使用」、RFC 7836、DOI 10.17487 / RFC7836、2016年3月、<https://www.rfc-editor.org/info/rfc7836>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[SSH] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Transport Layer Protocol\", RFC 4253, DOI 10.17487/RFC4253, January 2006, <https://www.rfc-editor.org/info/rfc4253>.",
      "ja": "[SSH] Ylonen、T.およびC. Lonvick、Ed。、「セキュアシェル（SSH）トランスポート層プロトコル」、RFC 4253、DOI 10.17487 / RFC4253、2006年1月、<https://www.rfc-editor.org / info / rfc4253>。"
    },
    {
      "indent": 3,
      "text": "[TLS] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[TLS] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AAOS2017] Ahmetzyanova, L., Alekseev, E., Oshkin, I., and S. Smyshlyaev, \"Increasing the Lifetime of Symmetric Keys for the GCM Mode by Internal Re-keying\", Cryptology ePrint Archive, Report 2017/697, 2017, <https://eprint.iacr.org/2017/697.pdf>.",
      "ja": "AAA 2017、<https://eprint.iacr.org/2017/697.pdf>。"
    },
    {
      "indent": 3,
      "text": "[AbBell] Abdalla, M. and M. Bellare, \"Increasing the Lifetime of a Key: A Comparative Analysis of the Security of Re-keying Techniques\", ASIACRYPT 2000, Lecture Notes in Computer Science, Volume 1976, pp. 546-559, DOI 10.1007/3-540-44448-3_42, October 2000.",
      "ja": "[AbBell] Abdalla、M.、M。Bellare、「キーの寿命の延長：キー再生成技術のセキュリティの比較分析」、ASIACRYPT 2000、コンピューターサイエンスの講義ノート、1976年、546-559ページ 、DOI 10.1007 / 3-540-44448-3_42、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[AESDUKPT] American National Standards Institute, \"Retail Financial Services Symmetric Key Management - Part 3: Derived Unique Key Per Transaction\", ANSI X9.24-3-2017, October 2017.",
      "ja": "[AESDUKPT] American National Standards Institute、「小売金融サービスの対称キー管理-パート3：トランザクションごとの派生キー」、ANSI X9.24-3-2017、2017年10月。"
    },
    {
      "indent": 3,
      "text": "[FKK2005] Fu, K., Kamara, S., and T. Kohno, \"Key Regression: Enabling Efficient Key Distribution for Secure Distributed Storage\", November 2005, <https://homes.cs.washington.edu/ ~yoshi/papers/KR/NDSS06.pdf>.",
      "ja": "[FKK2005] Fu、K.、Kamara、S。、およびT. Kohno、「キー回帰：安全な分散ストレージのための効率的なキー配布の有効化」、2005年11月、<https://homes.cs.washington.edu/〜yoshi /papers/KR/NDSS06.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FPS2012] Faust, S., Pietrzak, K., and J. Schipper, \"Practical Leakage-Resilient Symmetric Cryptography\", Cryptographic Hardware and Embedded Systems (CHES), Lecture Notes in Computer Science, Volume 7428, pp. 213-232, DOI 10.1007/978-3-642-33027-8_13, 2012, <https://link.springer.com/content/ pdf/10.1007%2F978-3-642-33027-8_13.pdf>.",
      "ja": "[FPS2012] Faust、S.、Pietrzak、K。、およびJ. Schipper、「実用的な漏れ耐性の対称暗号化」、暗号ハードウェアおよび組み込みシステム（CHES）、コンピューターサイエンスの講義ノート、ボリューム7428、pp。213-232 、DOI 10.1007 / 978-3-642-33027-8_13、2012、<https://link.springer.com/content/ pdf / 10.1007％2F978-3-642-33027-8_13.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FRESHREKEYING] Dziembowski, S., Faust, S., Herold, G., Journault, A., Masny, D., and F. Standaert, \"Towards Sound Fresh Re-Keying with Hard (Physical) Learning Problems\", Cryptology ePrint Archive, Report 2016/573, June 2016, <https://eprint.iacr.org/2016/573>.",
      "ja": "[フレッシュキーイング] Dziembowski、S.、Faust、S.、Herold、G.、Journault、A.、Masny、D.、and F. Standaert、 \"Towards Sound Fresh Re-Keying with Hard（Physical）Learning Problems ''、Cryptology ePrintアーカイブ、レポート2016 / 573、2016年6月、<https://eprint.iacr.org/2016/573>。"
    },
    {
      "indent": 3,
      "text": "[GGM] Goldreich, O., Goldwasser, S., and S. Micali, \"How to Construct Random Functions\", Journal of the Association for Computing Machinery, Volume 33, No. 4, pp. 792-807, DOI 10.1145/6490.6503, October 1986, <https://dl.acm.org/citation.cfm?doid=6490.6503>.",
      "ja": "[GGM] Goldreich、O.、Goldwasser、S。、およびS. Micali、「ランダム関数の構築方法」、Journal of the Association for Computing Machinery、Vol。33、No。4、pp。792-807、DOI 10.1145 / 6490.6503、1986年10月、<https://dl.acm.org/citation.cfm?doid=6490.6503>。"
    },
    {
      "indent": 3,
      "text": "[KMNT2003] Kim, Y., Maino, F., Narasimha, M., and G. Tsudik, \"Secure Group Services for Storage Area Networks\", IEEE Communications Magazine 41, Number 8, pp. 92-99, DOI 10.1109/SISW.2002.1183514, August 2003, <https://ieeexplore.ieee.org/document/1183514>.",
      "ja": "[KMNT2003] Kim、Y.、Maino、F.、Narasimha、M。、およびG. Tsudik、「ストレージエリアネットワークのセキュアグループサービス」、IEEE Communications Magazine 41、Number 8、92-99ページ、DOI 10.1109 / SISW.2002.1183514、2003年8月、<https://ieeexplore.ieee.org/document/1183514>。"
    },
    {
      "indent": 3,
      "text": "[LDC] Heys, H., \"A Tutorial on Linear and Differential Cryptanalysis\", 2001, <https://citeseerx.ist.psu.edu/ viewdoc/citations?doi=10.1.1.2.2759>.",
      "ja": "[LDC] Heys、H.、「線形および微分暗号解読法のチュートリアル」、2001、<https://citeseerx.ist.psu.edu/viewdoc/citations?doi=10.1.1.2.2759>。"
    },
    {
      "indent": 3,
      "text": "[OWT] Joye, M. and S. Yen, \"One-Way Cross-Trees and Their Applications\", Public Key Cryptography (PKC), Lecture Notes in Computer Science, Volume 2274, DOI 10.1007/3-540-45664-3_25, February 2002, <https://link.springer.com/content/ pdf/10.1007%2F3-540-45664-3_25.pdf>.",
      "ja": "[OWT] Joye、M。、およびS. Yen、「一方向クロスツリーとそのアプリケーション」、公開鍵暗号（PKC）、コンピューターサイエンスの講義ノート、第2274巻、DOI 10.1007 / 3-540-45664-3_25 、2002年2月、<https://link.springer.com/content/ pdf / 10.1007％2F3-540-45664-3_25.pdf>。"
    },
    {
      "indent": 3,
      "text": "[P3] Alexander, P., \"Subject: [Cfrg] Dynamic Key Changes on Encrypted Sessions. - Draft I-D Attached\", message to the CFRG mailing list, 4 November 2017, <https://mailarchive.ietf.org/arch/msg/cfrg/ ecTR3Hb-DFfrPCVmY0ghyYOEcxU>.",
      "ja": "[P3] Alexander、P.、「サブジェクト：[Cfrg]暗号化セッションでの動的なキーの変更。-ドラフトID添付」、CFRGメーリングリストへのメッセージ、2017年11月4日、<https://mailarchive.ietf.org/arch / msg / cfrg / ecTR3Hb-DFfrPCVmY0ghyYOEcxU>。"
    },
    {
      "indent": 3,
      "text": "[Pietrzak2009] Pietrzak, K., \"A Leakage-Resilient Mode of Operation\", EUROCRYPT 2009, Lecture Notes in Computer Science, Volume 5479, pp. 462-482, DOI 10.1007/978-3-642-01001-9_27, April 2009, <https://iacr.org/archive/eurocrypt2009/ 54790461/54790461.pdf>.",
      "ja": "[Pietrzak2009] Pietrzak、K.、 \"A Leakage-Resilient Mode of Operation\"、EUROCRYPT 2009、Lecture Notes in Computer Science、Volume 5479、pp。462-482、DOI 10.1007 / 978-3-642-01001-9_27、April 2009、<https://iacr.org/archive/eurocrypt2009/ 54790461 / 54790461.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SIGNAL] Perrin, T., Ed. and M. Marlinspike, \"The Double Ratchet Algorithm\", November 2016, <https://signal.org/docs/ specifications/doubleratchet/doubleratchet.pdf>.",
      "ja": "[シグナル]ペリン、T。、エド。 およびM. Marlinspike、「The Double Ratchet Algorithm」、2016年11月、<https://signal.org/docs/ specification / doubleratchet / doubleratchet.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Sweet32] Bhargavan, K. and G. Leurent, \"On the Practical (In-)Security of 64-bit Block Ciphers: Collision Attacks on HTTP over TLS and OpenVPN\", Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pp. 456-467, DOI 10.1145/2976749.2978423, October 2016, <https://sweet32.info/SWEET32_CCS16.pdf>.",
      "ja": "[Sweet32] Bhargavan、K。、およびG. Leurent、「64ビットブロック暗号の実用的（イン）セキュリティについて：TLSおよびOpenVPNを介したHTTPに対する衝突攻撃」、2016年ACM SIGSAC Conference on Computer and Communications Securityの議事録 、456-467ページ、DOI 10.1145 / 2976749.2978423、2016年10月、<https://sweet32.info/SWEET32_CCS16.pdf>。"
    },
    {
      "indent": 3,
      "text": "[TAHA] Taha, M. and P. Schaumont, \"Key Updating for Leakage Resiliency With Application to AES Modes of Operation\", IEEE Transactions on Information Forensics and Security, DOI 10.1109/TIFS.2014.2383359, December 2014, <http://ieeexplore.ieee.org/document/6987331/>.",
      "ja": "[TAHA] Taha、M.およびP. Schaumont、「AES動作モードへの適用による漏れ耐性のキー更新」、情報フォレンジックおよびセキュリティに関するIEEEトランザクション、DOI 10.1109 / TIFS.2014.2383359、2014年12月、<http：// ieeexplore.ieee.org/document/6987331/>。"
    },
    {
      "indent": 3,
      "text": "[TEMPEST] Ramsay, C. and J. Lohuis, \"TEMPEST attacks against AES. Covertly stealing keys for 200 euro\", June 2017, <https://www.fox-it.com/en/wp-content/uploads/sites/11/ Tempest_attacks_against_AES.pdf>.",
      "ja": "[TEMPEST] Ramsay、C.およびJ. Lohuis、「TEMPESTはAESを攻撃します。200ユーロで鍵をひそかに盗む」、2017年6月、<https://www.fox-it.com/en/wp-content/uploads/ sites / 11 / Tempest_attacks_against_AES.pdf>。"
    },
    {
      "indent": 3,
      "text": "[U2F] Chang, D., Mishra, S., Sanadhya, S., and A. Singh, \"On Making U2F Protocol Leakage-Resilient via Re-keying\", Cryptology ePrint Archive, Report 2017/721, August 2017, <https://eprint.iacr.org/2017/721.pdf>.",
      "ja": "[U2F] Chang、D.、Mishra、S.、Sanadyya、S。、およびA. Singh、「Re-keyingによるU2Fプロトコルの漏洩耐性の作成」、Cryptology ePrint Archive、Report 2017 / 721、2017年8月 https://eprint.iacr.org/2017/721.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Examples",
      "section_title": true,
      "ja": "付録A.テスト例"
    },
    {
      "indent": 0,
      "text": "A.1. Test Examples for External Re-keying",
      "section_title": true,
      "ja": "A.1. 外部キー再生成のテスト例"
    },
    {
      "indent": 0,
      "text": "A.1.1. External Re-keying with a Parallel Construction",
      "section_title": true,
      "ja": "A.1.1. 並列構造による外部キー再生成"
    },
    {
      "indent": 3,
      "text": "External re-keying with a parallel construction based on AES-256\n****************************************************************\nk = 256\nt = 128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00",
      "ja": "初期キー：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00"
    },
    {
      "indent": 3,
      "text": "K^1: 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1",
      "ja": "K ^ 1：51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1"
    },
    {
      "indent": 3,
      "text": "K^2: 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15 B8 02 92 32 D8 D3 8D 73 FE DC DD C6 C8 36 78 BD",
      "ja": "K ^ 2：6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15 B8 02 92 32 D8 D3 8D 73 FE DC DD C6 C8 36 78 BD"
    },
    {
      "indent": 3,
      "text": "K^3: B6 40 24 85 A4 24 BD 35 B4 26 43 13 76 26 70 B6 5B F3 30 3D 3B 20 EB 14 D1 3B B7 91 74 E3 DB EC",
      "ja": "K ^ 3：B6 40 24 85 A4 24 BD 35 B4 26 43 13 76 26 70 B6 5B F3 30 3D 3B 20 EB 14 D1 3B B7 91 74 E3 DB EC"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "K^126: 2F 3F 15 1B 53 88 23 CD 7D 03 FC 3D FD B3 57 5E 23 E4 1C 4E 46 FF 6B 33 34 12 27 84 EF 5D 82 23",
      "ja": "K ^ 126：2F 3F 15 1B 53 88 23 CD 7D 03 FC 3D FD B3 57 5E 23 E4 1C 4E 46 FF 6B 33 34 12 27 84 EF 5D 82 23"
    },
    {
      "indent": 3,
      "text": "K^127: 8E 51 31 FB 0B 64 BB D0 BC D4 C5 7B 1C 66 EF FD 97 43 75 10 6C AF 5D 5E 41 E0 17 F4 05 63 05 ED",
      "ja": "K ^ 127：8E 51 31 FB 0B 64 BB D0 BC D4 C5 7B 1C 66 EF FD 97 43 75 10 6C AF 5D 5E 41 E0 17 F4 05 63 05 ED"
    },
    {
      "indent": 3,
      "text": "K^128: 77 4F BF B3 22 60 C5 3B A3 8E FE B1 96 46 76 41 94 49 AF 84 2D 84 65 A7 F4 F7 2C DC A4 9D 84 F9",
      "ja": "K ^ 128：77 4F BF B3 22 60 C5 3B A3 8E FE B1 96 46 76 41 41 94 49 AF 84 2D 84 65 A7 F4 F7 2C DC A4 9D 84 F9"
    },
    {
      "indent": 3,
      "text": "External re-keying with a parallel construction based on SHA-256\n****************************************************************\nk = 256\nt = 128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "label: SHA2label Initial key: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00",
      "ja": "ラベル：SHA2label初期キー：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00"
    },
    {
      "indent": 3,
      "text": "K^1: C1 A1 4C A0 30 29 BE 43 9F 35 3C 79 1A 51 48 57 26 7A CD 5A E8 7D E7 D1 B2 E2 C7 AF A4 29 BD 35",
      "ja": "K ^ 1：C1 A1 4C A0 30 29 BE 43 9F 35 3C 79 1A 51 48 57 26 7A CD 5A E8 7D E7 D1 B2 E2 C7 AF A4 29 BD 35"
    },
    {
      "indent": 3,
      "text": "K^2: 03 68 BB 74 41 2A 98 ED C4 7B 94 CC DF 9C F4 9E A9 B8 A9 5F 0E DC 3C 1E 3B D2 59 4D D1 75 82 D4",
      "ja": "K ^ 2：03 68 BB 74 41 2A 98 ED C4 7B 94 CC DF 9C F4 9E A9 B8 A9 5F 0E DC 3C 1E 3B D2 59 4D D1 75 82 D4"
    },
    {
      "indent": 3,
      "text": "K^3: 2F D3 68 D3 A7 8F 91 E6 3B 68 DC 2B 41 1D AC 80 0A C3 14 1D 80 26 3E 61 C9 0D 24 45 2A BD B1 AE",
      "ja": "K ^ 3：2F D3 68 D3 A7 8F 91 E6 3B 68 DC 2B 41 1D AC 80 0A C3 14 1D 80 26 3E 61 C9 0D 24 45 2A BD B1 AE"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "K^126: 55 AC 2B 25 00 78 3E D4 34 2B 65 0E 75 E5 8B 76 C8 04 E9 D3 B6 08 7D C0 70 2A 99 A4 B5 85 F1 A1",
      "ja": "K ^ 126：55 AC 2B 25 00 78 3E D4 34 2B 65 0E 75 E5 8B 76 C8 04 E9 D3 B6 08 7D C0 70 2A 99 A4 B5 85 F1 A1"
    },
    {
      "indent": 3,
      "text": "K^127: 77 4D 15 88 B0 40 90 E5 8C 6A D7 5D 0F CF 0A 4A 6C 23 F1 B3 91 B1 EF DF E5 77 64 CD 09 F5 BC AF",
      "ja": "K ^ 127：77 4D 15 88 B0 40 90 E5 8C 6A D7 5D 0F CF 0A 4A 6C 23 F1 B3 91 B1 EF DF E5 77 64 CD 09 F5 BC AF"
    },
    {
      "indent": 3,
      "text": "K^128: E5 81 FF FB 0C 90 88 CD E5 F4 A5 57 B6 AB D2 2E 94 C3 42 06 41 AB C1 72 66 CC 2F 59 74 9C 86 B3",
      "ja": "K ^ 128：E5 81 FF FB 0C 90 88 CD E5 F4 A5 57 B6 AB D2 2E 94 C3 42 06 41 AB C1 72 66 CC 2F 59 74 9C 86 B3"
    },
    {
      "indent": 0,
      "text": "A.1.2. External Re-keying with a Serial Construction",
      "section_title": true,
      "ja": "A.1.2. シリアル構造を使用した外部キー再生成"
    },
    {
      "indent": 3,
      "text": "External re-keying with a serial construction based on AES-256\n**************************************************************\nAES 256 examples:\nk = 256\nt = 128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00",
      "ja": "初期キー：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00"
    },
    {
      "indent": 3,
      "text": "K*_1: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00 K^1: 66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86",
      "ja": "K * _1：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00 K ^ 1：66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86"
    },
    {
      "indent": 3,
      "text": "K*_2: 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15",
      "ja": "K * _2：64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15"
    },
    {
      "indent": 3,
      "text": "K^2: 66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86",
      "ja": "K ^ 2：66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86"
    },
    {
      "indent": 3,
      "text": "K*_3: 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15",
      "ja": "K * _3：64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15"
    },
    {
      "indent": 3,
      "text": "K^3: 66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86",
      "ja": "K ^ 3：66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "K*_126: 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15",
      "ja": "K * _126：64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15"
    },
    {
      "indent": 3,
      "text": "K^126: 66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86",
      "ja": "K ^ 126：66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86"
    },
    {
      "indent": 3,
      "text": "K*_127: 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15",
      "ja": "K * _127：64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15"
    },
    {
      "indent": 3,
      "text": "K^127: 66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86",
      "ja": "K ^ 127：66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0 51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86"
    },
    {
      "indent": 3,
      "text": "K*_128: 64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15",
      "ja": "K * _128：64 7D 5C D5 1C 3D 62 98 BC 09 B1 D8 64 EC D9 B1 6F ED F5 D3 77 57 48 75 35 2B 5F 4D B6 5B E0 15"
    },
    {
      "indent": 3,
      "text": "K^128:\n66 B8 BD E5 90 6C EC DF FA 8A B2 FD 92 84 EB F0\n51 16 8A B6 C8 A8 38 65 54 85 31 A5 D2 BA C3 86 External re-keying with a serial construction based on SHA-256\n**************************************************************\nk = 256\nt = 128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00",
      "ja": "初期キー：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00"
    },
    {
      "indent": 3,
      "text": "label1: SHA2label1",
      "ja": "label1：SHA2label1"
    },
    {
      "indent": 3,
      "text": "label2: SHA2label2",
      "ja": "label2：SHA2label2"
    },
    {
      "indent": 3,
      "text": "K*_1: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00",
      "ja": "K * _1：00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00"
    },
    {
      "indent": 3,
      "text": "K^1: 2D A8 D1 37 6C FD 52 7F F7 36 A4 E2 81 C6 0A 9B F3 8E 66 97 ED 70 4F B5 FB 10 33 CC EC EE D5 EC",
      "ja": "K ^ 1：2D A8 D1 37 6C FD 52 7F F7 36 A4 E2 81 C6 0A 9B F3 8E 66 97 ED 70 4F B5 FB 10 33 CC EC EE D5 EC"
    },
    {
      "indent": 3,
      "text": "K*_2: 14 65 5A D1 7C 19 86 24 9B D3 56 DF CC BE 73 6F 52 62 4A 9D E3 CC 40 6D A9 48 DA 5C D0 68 8A 04",
      "ja": "K * _2：14 65 5A D1 7C 19 86 24 9B D3 56 DF CC BE 73 6F 52 62 4A 9D E3 CC 40 6D A9 48 DA 5C D0 68 8A 04"
    },
    {
      "indent": 3,
      "text": "K^2: 2F EA 8D 57 2B EF B8 89 42 54 1B 8C 1B 3F 8D B1 84 F9 56 C7 FE 01 11 99 1D FB 98 15 FE 65 85 CF",
      "ja": "K ^ 2：2F EA 8D 57 2B EF B8 89 42 54 1B 8C 1B 3F 8D B1 84 F9 56 C7 FE 01 11 99 1D FB 98 15 FE 65 85 CF"
    },
    {
      "indent": 3,
      "text": "K*_3: 18 F0 B5 2A D2 45 E1 93 69 53 40 55 43 70 95 8D 70 F0 20 8C DF B0 5D 67 CD 1B BF 96 37 D3 E3 EB",
      "ja": "K * _3：18 F0 B5 2A D2 45 E1 93 69 53 40 55 43 70 95 8D 70 F0 20 8C DF B0 5D 67 CD 1B BF 96 37 D3 E3 EB"
    },
    {
      "indent": 3,
      "text": "K^3: 53 C7 4E 79 AE BC D1 C8 24 04 BF F6 D7 B1 AC BF F9 C0 0E FB A8 B9 48 29 87 37 E1 BA E7 8F F7 92",
      "ja": "K ^ 3：53 C7 4E 79 AE BC D1 C8 24 04 BF F6 D7 B1 AC BF F9 C0 0E FB A8 B9 48 29 87 37 E1 BA E7 8F F7 92"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "K*_126: A3 6D BF 02 AA 0B 42 4A F2 C0 46 52 68 8B C7 E6 5E F1 62 C3 B3 2F DD EF E4 92 79 5D BB 45 0B CA",
      "ja": "K * _126：A3 6D BF 02 AA 0B 42 4A F2 C0 46 52 68 8B C7 E6 5E F1 62 C3 B3 2F DD EF E4 92 79 5D BB 45 0B CA"
    },
    {
      "indent": 3,
      "text": "K^126: 6C 4B D6 22 DC 40 48 0F 29 C3 90 B8 E5 D7 A7 34 23 4D 34 65 2C CE 4A 76 2C FE 2A 42 C8 5B FE 9A K*_127: 84 5F 49 3D B8 13 1D 39 36 2B BE D3 74 8F 80 A1 05 A7 07 37 BA 15 72 E0 73 49 C2 67 5D 0A 28 A1",
      "ja": "K ^ 126：6C 4B D6 22 DC 40 48 0F 29 C3 90 B8 E5 D7 A7 34 23 4D 34 65 2C CE 4A 76 2C FE 2A 42 C8 5B FE 9A K * _127：84 5F 49 3D B8 13 1D 39 36 2B BE D3 74 8F 80 A1 05 A7 07 37 BA 15 72 E0 73 49 C2 67 5D 0A 28 A1"
    },
    {
      "indent": 3,
      "text": "K^127: 57 F0 BD 5A B8 2A F3 6B 87 33 CF F7 22 62 B4 D0 F0 EE EF E1 50 74 E5 BA 13 C1 23 68 87 36 29 A2",
      "ja": "K ^ 127：57 F0 BD 5A B8 2A F3 6B 87 33 CF F7 22 62 B4 D0 F0 EE EF E1 50 74 E5 BA 13 C1 23 68 87 36 29 A2"
    },
    {
      "indent": 3,
      "text": "K*_128: 52 F2 0F 56 5C 9C 56 84 AF 69 AD 45 EE B8 DA 4E 7A A6 04 86 35 16 BA 98 E4 CB 46 D2 E8 9A C1 09",
      "ja": "K * _128：52 F2 0F 56 5C 9C 56 84 AF 69 AD 45 EE B8 DA 4E 7A A6 04 86 35 16 BA 98 E4 CB 46 D2 E8 9A C1 09"
    },
    {
      "indent": 3,
      "text": "K^128: 9B DD 24 7D F3 25 4A 75 E0 22 68 25 68 DA 9D D5 C1 6D 2D 2B 4F 3F 1F 2B 5E 99 82 7F 15 A1 4F A4",
      "ja": "K ^ 128：9B DD 24 7D F3 25 4A 75 E0 22 68 25 68 DA 9D D5 C1 6D 2D 2B 4F 3F 1F 2B 5E 99 82 7F 15 A1 4F A4"
    },
    {
      "indent": 0,
      "text": "A.2. Test Examples for Internal Re-keying",
      "section_title": true,
      "ja": "A.2. 内部キー再生成のテスト例"
    },
    {
      "indent": 0,
      "text": "A.2.1. Internal Re-keying Mechanisms that Do Not Require a Master Key",
      "section_title": true,
      "ja": "A.2.1. マスターキーを必要としない内部キー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "CTR-ACPKM mode with AES-256\n***************************\nk = 256\nn = 128\nc = 64\nN = 256",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "初期キーK：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Plaintext P: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050: 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060: 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44",
      "ja": "平文P：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050：44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060：55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44"
    },
    {
      "indent": 3,
      "text": "ICN: 12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12 23 34 45 56 67 78 89 90 12 13 14 15 16 17 18 19",
      "ja": "ICN：12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12 23 34 45 56 67 78 89 90 12 13 14 15 16 17 18 19"
    },
    {
      "indent": 3,
      "text": "D_1: 00000: 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F D_2: 00000: 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F",
      "ja": "D_1：00000：80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F D_2：00000：90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F"
    },
    {
      "indent": 3,
      "text": "Section_1",
      "ja": "セクション_1"
    },
    {
      "indent": 3,
      "text": "Section key K^1: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "セクションキーK ^ 1：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Input block CTR_1: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 00",
      "ja": "入力ブロックCTR_1：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Output block G_1: 00000: FD 7E F8 9A D9 7E A4 B8 8D B8 B5 1C 1C 9D 6D D0",
      "ja": "出力ブロックG_1：00000：FD 7E F8 9A D9 7E A4 B8 8D B8 B5 1C 1C 9D 6D D0"
    },
    {
      "indent": 3,
      "text": "Input block CTR_2: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 01",
      "ja": "入力ブロックCTR_2：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 01"
    },
    {
      "indent": 3,
      "text": "Output block G_2: 00000: 19 98 C5 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2",
      "ja": "出力ブロックG_2：00000：19 98 C5 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2"
    },
    {
      "indent": 3,
      "text": "Section_2",
      "ja": "第2節"
    },
    {
      "indent": 3,
      "text": "Section key K^2: 00000: F6 80 D1 21 2F A4 3D F4 EC 3A 91 DE 2A B1 6F 1B 00010: 36 B0 48 8A 4F C1 2E 09 98 D2 E4 A8 88 E8 4F 3D",
      "ja": "セクションキーK ^ 2：00000：F6 80 D1 21 2F A4 3D F4 EC 3A 91 DE 2A B1 6F 1B 00010：36 B0 48 8A 4F C1 2E 09 98 D2 E4 A8 88 E8 4F 3D"
    },
    {
      "indent": 3,
      "text": "Input block CTR_3: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02",
      "ja": "入力ブロックCTR_3：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02"
    },
    {
      "indent": 3,
      "text": "Output block G_3: 00000: E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA",
      "ja": "出力ブロックG_3：00000：E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA"
    },
    {
      "indent": 3,
      "text": "Input block CTR_4: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03",
      "ja": "入力ブロックCTR_4：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03"
    },
    {
      "indent": 3,
      "text": "Output block G_4: 00000: BC 4F 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4",
      "ja": "出力ブロックG_4：00000：BC 4F 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4"
    },
    {
      "indent": 3,
      "text": "Section_3",
      "ja": "セクション_3"
    },
    {
      "indent": 3,
      "text": "Section key K^3: 00000: 8E B9 7E 43 27 1A 42 F1 CA 8E E2 5F 5C C7 C8 3B 00010: 1A CE 9E 5E D0 6A A5 3B 57 B9 6A CF 36 5D 24 B8",
      "ja": "セクションキーK ^ 3：00000：8E B9 7E 43 27 1A 42 F1 CA 8E E2 5F 5C C7 C8 3B 00010：1A CE 9E 5E D0 6A A5 3B 57 B9 6A CF 36 5D 24 B8"
    },
    {
      "indent": 3,
      "text": "Input block CTR_5: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04 Output block G_5: 00000: 68 6F 22 7D 8F B2 9C BD 05 C8 C3 7D 22 FE 3B B7",
      "ja": "入力ブロックCTR_5：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04出力ブロックG_5：00000：68 6F 22 7D 8F B2 9C BD 05 C8 C3 7D 22 FE 3B B7"
    },
    {
      "indent": 3,
      "text": "Input block CTR_6: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 05",
      "ja": "入力ブロックCTR_6：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 05"
    },
    {
      "indent": 3,
      "text": "Output block G_6: 00000: C0 1B F9 7F 75 6E 12 2F 80 59 55 BD DE 2D 45 87",
      "ja": "出力ブロックG_6：00000：C0 1B F9 7F 75 6E 12 2F 80 59 55 BD DE 2D 45 87"
    },
    {
      "indent": 3,
      "text": "Section_4",
      "ja": "セクション_4"
    },
    {
      "indent": 3,
      "text": "Section key K^4: 00000: C5 71 6C C9 67 98 BC 2D 4A 17 87 B7 8A DF 94 AC 00010: E8 16 F8 0B DB BC AD 7D 60 78 12 9C 0C B4 02 F5",
      "ja": "セクションキーK ^ 4：00000：C5 71 6C C9 67 98 BC 2D 4A 17 87 B7 8A DF 94 AC 00010：E8 16 F8 0B DB BC AD 7D 60 78 12 9C 0C B4 02 F5"
    },
    {
      "indent": 3,
      "text": "Block number 7:",
      "ja": "ブロック番号7："
    },
    {
      "indent": 3,
      "text": "Input block CTR_7: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 06",
      "ja": "入力ブロックCTR_7：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 06"
    },
    {
      "indent": 3,
      "text": "Output block G_7: 00000: 03 DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D",
      "ja": "出力ブロックG_7：00000：03 DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D"
    },
    {
      "indent": 3,
      "text": "The result G = G_1 | G_2 | G_3 | G_4 | G_5 | G_6 | G_7: 00000: FD 7E F8 9A D9 7E A4 B8 8D B8 B5 1C 1C 9D 6D D0 00010: 19 98 C5 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2 00020: E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA 00030: BC 4F 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4 00040: 68 6F 22 7D 8F B2 9C BD 05 C8 C3 7D 22 FE 3B B7 00050: C0 1B F9 7F 75 6E 12 2F 80 59 55 BD DE 2D 45 87 00060: 03 DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D",
      "ja": "結果G = G_1 | G_2 | G_3 | G_4 | G_5 | G_6 | G_7：00000：FD 7E F8 9A D9 7E A4 B8 8D B8 B5 1C 1C 9D 6D D0 00010：19 98 C5 71 76 37 FB 17 11 E4 48 F0 0C 0D 60 B2 00020：E4 88 89 4F B6 02 87 DB 77 5A 07 D9 2C 89 46 EA 00030：BC 4F 87 23 DB F0 91 50 DD B4 06 C3 1D A9 7C A4 00040：68 6F 22 7D 8F B2 9C BD 05 C8 C3 7D 22 FE 3B B7 00050：C0 1B F9 7F 75 6E 12 2F 80 59 55 BD DE 2D 45 87 00060：03 DE 34 74 AB 9B 65 8A 3B 54 1E F8 BD 2B F4 7D"
    },
    {
      "indent": 3,
      "text": "The result ciphertext C = P (xor) MSB_{|P|}(G):\n00000:   EC 5C CB DE 8C 18 D3 B8 72 56 68 D0 A7 37 F4 58\n00010:   19 89 E7 42 32 62 9D 60 99 7D E2 4B C0 E3 9F B8\n00020:   F5 AA BA 0B E3 64 F0 53 EE F0 BC 15 C2 76 4C EA\n00030:   9E 7C C3 76 BD 87 19 C9 77 0F CA 2D E2 A3 7C B5\n00040:   5B 2B 77 1B F8 3A 05 17 BE 04 2D 82 28 FE 2A 95\n00050:   84 4E 9F 08 FD F7 B8 94 4C B7 AA B7 DE 3C 67 B4\n00060:   56 B8 43 FC 32 31 DE 46 D5 AB 14 F8 AC 09 C7 39 GCM-ACPKM mode with AES-128\n***************************\nk = 128\nn = 128\nc = 32\nN = 256",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "初期キーK：00000：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Additional data A: 00000: 11 22 33",
      "ja": "追加データA：00000：11 22 33"
    },
    {
      "indent": 3,
      "text": "Plaintext: 00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "平文：00000：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000010：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "ICN: 00000: 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "ICN：00000：00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Number of sections: 2",
      "ja": "セクションの数：2"
    },
    {
      "indent": 3,
      "text": "Section key K^1: 00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "セクションキーK ^ 1：00000：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Section key K^2: 00000: 15 1A 9F B0 B6 AC C5 97 6A FB 50 31 D1 DE C8 41",
      "ja": "セクションキーK ^ 2：00000：15 1A 9F B0 B6 AC C5 97 6A FB 50 31 D1 DE C8 41"
    },
    {
      "indent": 3,
      "text": "Encrypted GCTR_1 | GCTR_2 | GCTR_3: 00000: 03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010: F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020: D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD",
      "ja": "暗号化されたGCTR_1 | GCTR_2 | GCTR_3：00000：03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010：F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020：D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD"
    },
    {
      "indent": 3,
      "text": "Ciphertext C: 00000: 03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010: F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020: D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD",
      "ja": "暗号文C：00000：03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010：F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020：D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD"
    },
    {
      "indent": 3,
      "text": "GHASH input: 00000: 11 22 33 00 00 00 00 00 00 00 00 00 00 00 00 00 00010: 03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00020: F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00030: D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD 00040: 00 00 00 00 00 00 00 18 00 00 00 00 00 00 01 80",
      "ja": "GHASH入力：00000：11 22 33 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000010：03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00020：F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00030：D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD 00040：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 80"
    },
    {
      "indent": 3,
      "text": "GHASH output S: 00000: E8 ED E9 94 9A DD 55 30 B0 F4 4E F5 00 FC 3E 3C Authentication tag T: 00000: B0 0F 15 5A 60 A3 65 51 86 8B 53 A2 A4 1B 7B 66",
      "ja": "GHASH出力S：00000：E8 ED E9 94 9A DD 55 30 B0 F4 4E F5 00 FC 3E 3C認証タグT：00000：B0 0F 15 5A 60 A3 65 51 86 8B 53 A2 A4 1B 7B 66"
    },
    {
      "indent": 3,
      "text": "The result C | T: 00000: 03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010: F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020: D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD 00030: B0 0F 15 5A 60 A3 65 51 86 8B 53 A2 A4 1B 7B 66",
      "ja": "結果C | T：00000：03 88 DA CE 60 B6 A3 92 F3 28 C2 B9 71 B2 FE 78 00010：F7 95 AA AB 49 4B 59 23 F7 FD 89 FF 94 8B C1 E0 00020：D6 B3 12 46 E9 CE 9F F1 3A B3 42 7E E8 91 96 AD 00030：B0 0F 15 5A 60 A3 65 51 86 8B 53 A2 A4 1B 7B 66"
    },
    {
      "indent": 0,
      "text": "A.2.2. Internal Re-keying Mechanisms with a Master Key",
      "section_title": true,
      "ja": "A.2.2. マスターキーを使用した内部キー再生成メカニズム"
    },
    {
      "indent": 3,
      "text": "CTR-ACPKM-Master mode with AES-256\n**********************************\nk = 256\nn = 128\nc for CTR-ACPKM mode = 64\nc for CTR-ACPKM-Master mode = 64\nN = 256\nT* = 512",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "初期キーK：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Initial vector ICN: 00000: 12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12",
      "ja": "初期ベクトルICN：00000：12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12"
    },
    {
      "indent": 3,
      "text": "Plaintext P: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050: 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060: 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44",
      "ja": "平文P：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050：44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060：55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44"
    },
    {
      "indent": 3,
      "text": "K^1 | K^2 | K^3 | K^4:\n00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n00020:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n00040:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n00050:   60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n00060:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12 Section_1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "K^1: 00000: 9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010: 39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60",
      "ja": "K ^ 1：00000：9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010：39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60"
    },
    {
      "indent": 3,
      "text": "Input block CTR_1: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 00",
      "ja": "入力ブロックCTR_1：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Output block G_1: 00000: 8C A2 B6 82 A7 50 65 3F 8E BF 08 E7 9F 99 4D 5C",
      "ja": "出力ブロックG_1：00000：8C A2 B6 82 A7 50 65 3F 8E BF 08 E7 9F 99 4D 5C"
    },
    {
      "indent": 3,
      "text": "Input block CTR_2: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 01",
      "ja": "入力ブロックCTR_2：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 01"
    },
    {
      "indent": 3,
      "text": "Output block G_2: 00000: F6 A6 A5 BA 58 14 1E ED 23 DC 31 68 D2 35 89 A1",
      "ja": "出力ブロックG_2：00000：F6 A6 A5 BA 58 14 1E ED 23 DC 31 68 D2 35 89 A1"
    },
    {
      "indent": 3,
      "text": "Section_2",
      "ja": "第2節"
    },
    {
      "indent": 3,
      "text": "K^2: 00000: 77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010: AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3",
      "ja": "K ^ 2：00000：77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010：AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3"
    },
    {
      "indent": 3,
      "text": "Input block CTR_3: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02",
      "ja": "入力ブロックCTR_3：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 02"
    },
    {
      "indent": 3,
      "text": "Output block G_3: 00000: 4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71",
      "ja": "出力ブロックG_3：00000：4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71"
    },
    {
      "indent": 3,
      "text": "Input block CTR_4: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03",
      "ja": "入力ブロックCTR_4：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 03"
    },
    {
      "indent": 3,
      "text": "Output block G_4: 00000: 23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7",
      "ja": "出力ブロックG_4：00000：23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7"
    },
    {
      "indent": 3,
      "text": "Section_3",
      "ja": "セクション_3"
    },
    {
      "indent": 3,
      "text": "K^3: 00000: E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010: 60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94",
      "ja": "K ^ 3：00000：E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010：60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94"
    },
    {
      "indent": 3,
      "text": "Input block CTR_5: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04 Output block G_5: 00000: A8 09 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8",
      "ja": "入力ブロックCTR_5：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 04出力ブロックG_5：00000：A8 09 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8"
    },
    {
      "indent": 3,
      "text": "Input block CTR_6: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 05",
      "ja": "入力ブロックCTR_6：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 05"
    },
    {
      "indent": 3,
      "text": "Output block G_6: 00000: C6 E3 6E 8E 5B 82 AA C4 A6 6C 14 8D B1 F6 9B EF",
      "ja": "出力ブロックG_6：00000：C6 E3 6E 8E 5B 82 AA C4 A6 6C 14 8D B1 F6 9B EF"
    },
    {
      "indent": 3,
      "text": "Section_4",
      "ja": "セクション_4"
    },
    {
      "indent": 3,
      "text": "K^4: 00000: F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010: 2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12",
      "ja": "K ^ 4：00000：F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010：2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12"
    },
    {
      "indent": 3,
      "text": "Input block CTR_7: 00000: 12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 06",
      "ja": "入力ブロックCTR_7：00000：12 34 56 78 90 AB CE F0 00 00 00 00 00 00 00 06"
    },
    {
      "indent": 3,
      "text": "Output block G_7: 00000: 82 2B E9 07 96 37 44 95 75 36 3F A7 07 F8 40 22",
      "ja": "出力ブロックG_7：00000：82 2B E9 07 96 37 44 95 75 36 3F A7 07 F8 40 22"
    },
    {
      "indent": 3,
      "text": "The result G = G_1 | G_2 | G_3 | G_4 | G_5 | G_6 | G_7: 00000: 8C A2 B6 82 A7 50 65 3F 8E BF 08 E7 9F 99 4D 5C 00010: F6 A6 A5 BA 58 14 1E ED 23 DC 31 68 D2 35 89 A1 00020: 4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71 00030: 23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7 00040: A8 09 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8 00050: C6 E3 6E 8E 5B 82 AA C4 A6 6C 14 8D B1 F6 9B EF 00060: 82 2B E9 07 96 37 44 95 75 36 3F A7 07 F8 40 22",
      "ja": "結果G = G_1 | G_2 | G_3 | G_4 | G_5 | G_6 | G_7：00000：8C A2 B6 82 A7 50 65 3F 8E BF 08 E7 9F 99 4D 5C 00010：F6 A6 A5 BA 58 14 1E ED 23 DC 31 68 D2 35 89 A1 00020：4A 07 5F 86 05 87 72 94 1D 8E 7D F8 32 F4 23 71 00030：23 35 66 AF 61 DD FE A7 B1 68 3F BA B0 52 4A D7 00040：A8 09 6D BC E8 BB 52 FC DE 6E 03 70 C1 66 95 E8 00050：C6 E3 6E 8E 5B 82 AA C4 A6 6C 14 8D B1 F6 9B EF 00060：82 2B E9 07 96 37 44 95 75 36 3F A7 07 F8 40 22"
    },
    {
      "indent": 3,
      "text": "The result ciphertext C = P (xor) MSB_{|P|}(G):\n00000:   9D 80 85 C6 F2 36 12 3F 71 51 D5 2B 24 33 D4 D4\n00010:   F6 B7 87 89 1C 41 78 9A AB 45 9B D3 1E DB 76 AB\n00020:   5B 25 6C C2 50 E1 05 1C 84 24 C6 34 DC 0B 29 71\n00030:   01 06 22 FA 07 AA 76 3E 1B D3 F3 54 4F 58 4A C6\n00040:   9B 4D 38 DA 9F 33 CB 56 65 A2 ED 8F CB 66 84 CA\n00050:   82 B6 08 F9 D3 1B 00 7F 6A 82 EB 87 B1 E7 B9 DC\n00060:   D7 4D 9E 8F 0F 9D FF 59 9B C9 35 A7 16 DA 73 66 GCM-ACPKM-Master mode with AES-256\n**********************************\nk = 192\nn = 128\nc for the CTR-ACPKM mode = 64\nc for the GCM-ACPKM-Master mode = 32\nT* = 384\nN = 256",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00010: 00 00 00 00 00 00 00 00",
      "ja": "初期キーK：00000：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000010：00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Additional data A: 00000: 11 22 33",
      "ja": "追加データA：00000：11 22 33"
    },
    {
      "indent": 3,
      "text": "Plaintext: 00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "平文：00000：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000010：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000030：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000040：00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "ICN: 00000: 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "ICN：00000：00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Number of sections: 3",
      "ja": "セクションの数：3"
    },
    {
      "indent": 3,
      "text": "K^1 | K^2 | K^3:\n00000:   93 BA AF FB 35 FB E7 39 C1 7C 6A C2 2E EC F1 8F\n00010:   7B 89 F0 BF 8B 18 07 05 96 48 68 9F 36 A7 65 CC\n00020:   CD 5D AC E2 0D 47 D9 18 D7 86 D0 41 A8 3B AB 99\n00030:   F5 F8 B1 06 D2 71 78 B1 B0 08 C9 99 0B 72 E2 87\n00040:   5A 2D 3C BE F1 6E 67 3C",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Encrypted GCTR_1 | ... | GCTR_5 00000: 43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010: 69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020: 11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030: 4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040: 40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08",
      "ja": "暗号化されたGCTR_1 | ... | GCTR_5 00000：43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010：69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020：11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030：4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040：40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08"
    },
    {
      "indent": 3,
      "text": "Ciphertext C: 00000: 43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010: 69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020: 11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030: 4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040: 40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 GHASH input: 00000: 11 22 33 00 00 00 00 00 00 00 00 00 00 00 00 00 00010: 43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00020: 69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00030: 11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00040: 4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00050: 40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 00060: 00 00 00 00 00 00 00 18 00 00 00 00 00 00 02 80",
      "ja": "暗号文C：00000：43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010：69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020：11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030：4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040：40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 GHASH入力：00000：11 22 33 00 00 00 00 00 00 00 00 00 00 00 00 00 000010：43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00020：69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00030：11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00040：4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00050：40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 00060：00 00 00 00 00 00 00 18 00 00 00 00 00 00 00 02 80"
    },
    {
      "indent": 3,
      "text": "GHASH output S: 00000: 6E A3 4B D5 6A C5 40 B7 3E 55 D5 86 D1 CC 09 7D",
      "ja": "GHASH出力S：00000：6E A3 4B D5 6A C5 40 B7 3E 55 D5 86 D1 CC 09 7D"
    },
    {
      "indent": 3,
      "text": "Authentication tag T: 00050: CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8",
      "ja": "認証タグT：00050：CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8"
    },
    {
      "indent": 3,
      "text": "The result C | T: 00000: 43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010: 69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020: 11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030: 4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040: 40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 00050: CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8",
      "ja": "結果C | T：00000：43 FA 71 81 64 B1 E3 D7 1E 7B 65 39 A7 02 1D 52 00010：69 9B 9E 1B 43 24 B7 52 95 74 E7 90 F2 BE 60 E8 00020：11 62 C9 90 2A 2B 77 7F D9 6A D6 1A 99 E0 C6 DE 00030：4B 91 D4 29 E3 1A 8C 11 AF F0 BC 47 F6 80 AF 14 00040：40 1C C1 18 14 63 8E 76 24 83 37 75 16 34 70 08 00050：CC 3A BA 11 8C E7 85 FD 77 78 94 D4 B5 20 69 F8"
    },
    {
      "indent": 3,
      "text": "CBC-ACPKM-Master mode with AES-256\n**********************************\nk = 256\nn = 128\nc for the CTR-ACPKM mode = 64\nN = 256\nT* = 512",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "初期キーK：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Initial vector IV: 00000: 12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12",
      "ja": "初期ベクトルIV：00000：12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12"
    },
    {
      "indent": 3,
      "text": "Plaintext P:\n00000:   11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88\n00010:   00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A\n00020:   11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00\n00030:   22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11\n00040:   33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22\n00050:   44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33\n00060:   55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44 K^1 | K^2 | K^3 | K^4:\n00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n00020:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n00040:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n00050:   60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n00060:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section_1",
      "ja": "セクション_1"
    },
    {
      "indent": 3,
      "text": "K^1: 00000: 9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010: 39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60",
      "ja": "K ^ 1：00000：9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010：39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_1: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88",
      "ja": "平文ブロックP_1：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"
    },
    {
      "indent": 3,
      "text": "Input block P_1 (xor) C_0: 00000: 03 16 65 3C C5 CD B9 F0 5E 5C 1E 18 5E 5A 98 9A",
      "ja": "入力ブロックP_1（xor）C_0：00000：03 16 65 3C C5 CD B9 F0 5E 5C 1E 18 5E 5A 98 9A"
    },
    {
      "indent": 3,
      "text": "Output block C_1: 00000: 59 CB 5B CA C2 69 2C 60 0D 46 03 A0 C7 40 C9 7C",
      "ja": "出力ブロックC_1：00000：59 CB 5B CA C2 69 2C 60 0D 46 03 A0 C7 40 C9 7C"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_2: 00000: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A",
      "ja": "平文ブロックP_2：00000：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A"
    },
    {
      "indent": 3,
      "text": "Input block P_2 (xor) C_1: 00000: 59 DA 79 F9 86 3C 4A 17 85 DF A9 1B 0B AE 36 76",
      "ja": "入力ブロックP_2（xor）C_1：00000：59 DA 79 F9 86 3C 4A 17 85 DF A9 1B 0B AE 36 76"
    },
    {
      "indent": 3,
      "text": "Output block C_2: 00000: 80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6 8B 42",
      "ja": "出力ブロックC_2：00000：80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6 8B 42"
    },
    {
      "indent": 3,
      "text": "Section_2",
      "ja": "第2節"
    },
    {
      "indent": 3,
      "text": "K^2: 00000: 77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010: AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3",
      "ja": "K ^ 2：00000：77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010：AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_3: 00000: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00",
      "ja": "平文ブロックP_3：00000：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00"
    },
    {
      "indent": 3,
      "text": "Input block P_3 (xor) C_2: 00000: 91 94 31 30 01 ED 80 41 E1 B5 1A C9 65 09 81 42",
      "ja": "入力ブロックP_3（xor）C_2：00000：91 94 31 30 01 ED 80 41 E1 B5 1A C9 65 09 81 42"
    },
    {
      "indent": 3,
      "text": "Output block C_3: 00000: 8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97 59 Plaintext block P_4: 00000: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11",
      "ja": "出力ブロックC_3：00000：8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97 59平文ブロックP_4：00000：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11"
    },
    {
      "indent": 3,
      "text": "Input block P_4 (xor) C_3: 00000: AE 17 BF 9A 0E 62 39 36 CF 45 8B 9B 6A BE 97 48",
      "ja": "入力ブロックP_4（xor）C_3：00000：AE 17 BF 9A 0E 62 39 36 CF 45 8B 9B 6A BE 97 48"
    },
    {
      "indent": 3,
      "text": "Output block C_4: 00000: 19 65 A5 00 58 0D 50 23 72 1B E9 90 E1 83 30 E9",
      "ja": "出力ブロックC_4：00000：19 65 A5 00 58 0D 50 23 72 1B E9 90 E1 83 30 E9"
    },
    {
      "indent": 3,
      "text": "Section_3",
      "ja": "セクション_3"
    },
    {
      "indent": 3,
      "text": "K^3: 00000: E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010: 60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94",
      "ja": "K ^ 3：00000：E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010：60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_5: 00000: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22",
      "ja": "平文ブロックP_5：00000：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22"
    },
    {
      "indent": 3,
      "text": "Input block P_5 (xor) C_4: 00000: 2A 21 F0 66 2F 85 C9 89 C9 D7 07 6F EB 83 21 CB",
      "ja": "入力ブロックP_5（xor）C_4：00000：2A 21 F0 66 2F 85 C9 89 C9 D7 07 6F EB 83 21 CB"
    },
    {
      "indent": 3,
      "text": "Output block C_5: 00000: 56 D8 34 F4 6F 0F 4D E6 20 53 A9 5C B5 F6 3C 14",
      "ja": "出力ブロックC_5：00000：56 D8 34 F4 6F 0F 4D E6 20 53 A9 5C B5 F6 3C 14"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_6: 00000: 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33",
      "ja": "平文ブロックP_6：00000：44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33"
    },
    {
      "indent": 3,
      "text": "Input block P_6 (xor) C_5: 00000: 12 8D 52 83 E7 96 E7 5D EC BD 56 56 B5 E7 1E 27",
      "ja": "入力ブロックP_6（xor）C_5：00000：12 8D 52 83 E7 96 E7 5D EC BD 56 56 B5 E7 1E 27"
    },
    {
      "indent": 3,
      "text": "Output block C_6: 00000: 66 68 2B 8B DD 6E B2 7E DE C7 51 D6 2F 45 A5 45",
      "ja": "出力ブロックC_6：00000：66 68 2B 8B DD 6E B2 7E DE C7 51 D6 2F 45 A5 45"
    },
    {
      "indent": 3,
      "text": "Section_4",
      "ja": "セクション_4"
    },
    {
      "indent": 3,
      "text": "K^4: 00000: F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010: 2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12",
      "ja": "K ^ 4：00000：F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010：2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_7: 00000: 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44",
      "ja": "平文ブロックP_7：00000：55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 44"
    },
    {
      "indent": 3,
      "text": "Input block P_7 (xor) C_6: 00000: 33 0E 5C 03 44 C4 09 B2 30 38 5B D6 3E 67 96 01",
      "ja": "入力ブロックP_7（xor）C_6：00000：33 0E 5C 03 44 C4 09 B2 30 38 5B D6 3E 67 96 01"
    },
    {
      "indent": 3,
      "text": "Output block C_7: 00000: 7F 4D 87 F9 CA E9 56 09 79 C4 FA FE 34 0B 45 34 Ciphertext C: 00000: 59 CB 5B CA C2 69 2C 60 0D 46 03 A0 C7 40 C9 7C 00010: 80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6 8B 42 00020: 8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97 59 00030: 19 65 A5 00 58 0D 50 23 72 1B E9 90 E1 83 30 E9 00040: 56 D8 34 F4 6F 0F 4D E6 20 53 A9 5C B5 F6 3C 14 00050: 66 68 2B 8B DD 6E B2 7E DE C7 51 D6 2F 45 A5 45 00060: 7F 4D 87 F9 CA E9 56 09 79 C4 FA FE 34 0B 45 34",
      "ja": "出力ブロックC_7：00000：7F 4D 87 F9 CA E9 56 09 79 C4 FA FE 34 0B 45 34暗号文C：00000：59 CB 5B CA C2 69 2C 60 0D 46 03 A0 C7 40 C9 7C 00010：80 B6 02 74 54 8B F7 C9 78 1F A1 05 8B F6 8B 42 00020：8C 24 FB CF 68 15 B1 AF 65 FE 47 75 95 B4 97 59 00030：19 65 A5 00 58 0D 50 23 72 1B E9 90 E1 83 30 E9 00040：56 D8 34 F4 6F 0F 4D E6 20 53 A9 5C B5 F6 3C 14 00050：66 68 2B 8B DD 6E B2 7E DE C7 51 D6 2F 45 A5 45 00060：7F 4D 87 F9 CA E9 56 09 79 C4 FA FE 34 0B 45 34"
    },
    {
      "indent": 3,
      "text": "CFB-ACPKM-Master mode with AES-256\n**********************************\nk = 256\nn = 128\nc for the CTR-ACPKM mode = 64\nN = 256\nT* = 512",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "初期キーK：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Initial vector IV: 00000: 12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12",
      "ja": "初期ベクトルIV：00000：12 34 56 78 90 AB CE F0 A1 B2 C3 D4 E5 F0 01 12"
    },
    {
      "indent": 3,
      "text": "Plaintext P: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050: 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060: 55 66 77 88 99 AA BB CC",
      "ja": "平文P：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 00050：44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33 00060：55 66 77 88 99 AA BB CC"
    },
    {
      "indent": 3,
      "text": "K^1 | K^2 | K^3 | K^4\n00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n00020:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n00040:   E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4\n00050:   60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94\n00060:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12 Section_1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "K^1: 00000: 9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010: 39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60",
      "ja": "K ^ 1：00000：9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010：39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_1: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88",
      "ja": "平文ブロックP_1：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^1}(C_0):\n00000:   1C 39 9D 59 F8 5D 91 91 A9 D2 12 9F 63 15 90 03",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_1 = E_{K^1}(C_0) (xor) P_1:\n00000:   0D 1B AE 1D AD 3B E6 91 56 3C CF 53 D8 BF 09 8B",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Plaintext block P_2: 00000: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A",
      "ja": "平文ブロックP_2：00000：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^1}(C_1):\n00000:   6B A2 C5 42 52 69 C6 0B 15 14 06 87 90 46 F6 2E",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_2 = E_{K^1}(C_1) (xor) P_2:\n00000:   6B B3 E7 71 16 3C A0 7C 9D 8D AC 3C 5C A8 09 24",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section_2",
      "ja": "第2節"
    },
    {
      "indent": 3,
      "text": "K^2: 00000: 77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010: AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3",
      "ja": "K ^ 2：00000：77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0 00010：AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_3: 00000: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00",
      "ja": "平文ブロックP_3：00000：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^2}(C_2):\n00000:   95 45 5F DB C3 9E 0A 13 9F CB 10 F5 BD 79 A3 88",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_3 = E_{K^2}(C_2) (xor) P_3:\n00000:   84 67 6C 9F 96 F8 7D 9B 06 61 AB 39 53 86 A9 88",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Plaintext block P_4: 00000: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11",
      "ja": "平文ブロックP_4：00000：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^2}(C_3):\n00000:   E0 AA 32 5D 80 A4 47 95 BA 42 BF 63 F8 4A C8 B2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_4 = E_{K^2}(C_3) (xor) P_4:\n00000:   C2 99 76 08 E6 D3 CF 0C 10 F9 73 8D 07 40 C8 A3 Section_3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "K^3: 00000: E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010: 60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94",
      "ja": "K ^ 3：00000：E8 76 2B 30 8B 08 EB CE 3E 93 9A C2 C0 3E 76 D4 00010：60 9A AB D9 15 33 13 D3 CF D3 94 E7 75 DF 3A 94"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_5: 00000: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22",
      "ja": "平文ブロックP_5：00000：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^3}(C_4):\n00000:   FE 42 8C 70 C2 51 CE 13 36 C1 BF 44 F8 49 66 89",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_5 = E_{K^3}(C_4) (xor) P_5:\n00000:   CD 06 D9 16 B5 D9 57 B9 8D 0D 51 BB F2 49 77 AB",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Plaintext block P_6: 00000: 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33",
      "ja": "平文ブロックP_6：00000：44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22 33"
    },
    {
      "indent": 3,
      "text": "Encrypted block E_{K^3}(C_5):\n00000:   01 24 80 87 86 18 A5 43 11 0A CC B5 0A E5 02 A3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_6 = E_{K^3}(C_5) (xor) P_6:\n00000:   45 71 E6 F0 0E 81 0F F8 DD E4 33 BF 0A F4 20 90",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section_4",
      "ja": "セクション_4"
    },
    {
      "indent": 3,
      "text": "K^4: 00000: F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010: 2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12",
      "ja": "K ^ 4：00000：F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010：2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12"
    },
    {
      "indent": 3,
      "text": "Plaintext block P_7: 00000: 55 66 77 88 99 AA BB CC",
      "ja": "平文ブロックP_7：00000：55 66 77 88 99 AA BB CC"
    },
    {
      "indent": 3,
      "text": "Encrypted block MSB_{|P_7|}(E_{K^4}(C_6)):\n00000:   97 5C 96 37 55 1E 8C 7F",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Output block C_7 = MSB_{|P_7|}(E_{K^4}(C_6)) (xor) P_7\n00000:   C2 3A E1 BF CC B4 37 B3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Ciphertext C:\n00000:   0D 1B AE 1D AD 3B E6 91 56 3C CF 53 D8 BF 09 8B\n00010:   6B B3 E7 71 16 3C A0 7C 9D 8D AC 3C 5C A8 09 24\n00020:   84 67 6C 9F 96 F8 7D 9B 06 61 AB 39 53 86 A9 88\n00030:   C2 99 76 08 E6 D3 CF 0C 10 F9 73 8D 07 40 C8 A3\n00040:   CD 06 D9 16 B5 D9 57 B9 8D 0D 51 BB F2 49 77 AB\n00050:   45 71 E6 F0 0E 81 0F F8 DD E4 33 BF 0A F4 20 90\n00060:   C2 3A E1 BF CC B4 37 B3 OMAC-ACPKM-Master mode with AES-256\n***********************************\nk = 256\nn = 128\nc for the CTR-ACPKM mode = 64\nN = 256\nT* = 768",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initial key K: 00000: 88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010: FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF",
      "ja": "初期キーK：00000：88 99 AA BB CC DD EE FF 00 11 22 33 44 55 66 77 00010：FE DC BA 98 76 54 32 10 01 23 45 67 89 AB CD EF"
    },
    {
      "indent": 3,
      "text": "Plaintext M: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22",
      "ja": "平文M：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88 00010：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00020：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 00030：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 00040：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22"
    },
    {
      "indent": 3,
      "text": "K^1 | K^1_1 | K^2 | K^2_1 | K^3 | K^3_1:\n00000:   9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64\n00010:   39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60\n00020:   77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0\n00030:   AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3\n00040:   9D CC 66 42 0D FF 45 5B 21 F3 93 F0 D4 D6 6E 67\n00050:   BB 1B 06 0B 87 66 6D 08 7A 9D A7 49 55 C3 5B 48\n00060:   F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9\n00070:   2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12\n00080:   78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section_1",
      "ja": "セクション_1"
    },
    {
      "indent": 3,
      "text": "K^1: 00000: 9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010: 39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60",
      "ja": "K ^ 1：00000：9F 10 BB F1 3A 79 FB BD 4A 4C A8 64 C4 90 74 64 00010：39 FE 50 6D 4B 86 9B 21 03 A3 B6 A4 79 28 3C 60"
    },
    {
      "indent": 3,
      "text": "K^1_1: 00000: 77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0",
      "ja": "K ^ 1_1：00000：77 91 17 50 E0 D1 77 E5 9A 13 78 2B F1 89 08 D0"
    },
    {
      "indent": 3,
      "text": "Plaintext block M_1: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88",
      "ja": "平文ブロックM_1：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"
    },
    {
      "indent": 3,
      "text": "Input block M_1 (xor) C_0: 00000: 11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88",
      "ja": "入力ブロックM_1（xor）C_0：00000：11 22 33 44 55 66 77 00 FF EE DD CC BB AA 99 88"
    },
    {
      "indent": 3,
      "text": "Output block C_1: 00000: 0B A5 89 BF 55 C1 15 42 53 08 89 76 A0 FE 24 3E Plaintext block M_2: 00000: 00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A",
      "ja": "出力ブロックC_1：00000：0B A5 89 BF 55 C1 15 42 53 08 89 76 A0 FE 24 3E平文ブロックM_2：00000：00 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A"
    },
    {
      "indent": 3,
      "text": "Input block M_2 (xor) C_1: 00000: 0B B4 AB 8C 11 94 73 35 DB 91 23 CD 6C 10 DB 34",
      "ja": "入力ブロックM_2（xor）C_1：00000：0B B4 AB 8C 11 94 73 35 DB 91 23 CD 6C 10 DB 34"
    },
    {
      "indent": 3,
      "text": "Output block C_2: 00000: 1C 53 DD A3 6D DC E1 17 ED 1F 14 09 D8 6A F3 2C",
      "ja": "出力ブロックC_2：00000：1C 53 DD A3 6D DC E1 17 ED 1F 14 09 D8 6A F3 2C"
    },
    {
      "indent": 3,
      "text": "Section_2",
      "ja": "第2節"
    },
    {
      "indent": 3,
      "text": "K^2: 00000: AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3 00010: 9D CC 66 42 0D FF 45 5B 21 F3 93 F0 D4 D6 6E 67",
      "ja": "K ^ 2：00000：AB 6B 59 EE 92 49 05 B3 AB C7 A4 E3 69 65 76 C3 00010：9D CC 66 42 0D FF 45 5B 21 F3 93 F0 D4 D6 6E 67"
    },
    {
      "indent": 3,
      "text": "K^2_1: 00000: BB 1B 06 0B 87 66 6D 08 7A 9D A7 49 55 C3 5B 48",
      "ja": "K ^ 2_1：00000：BB 1B 06 0B 87 66 6D 08 7A 9D A7 49 55 C3 5B 48"
    },
    {
      "indent": 3,
      "text": "Plaintext block M_3: 00000: 11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00",
      "ja": "平文ブロックM_3：00000：11 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00"
    },
    {
      "indent": 3,
      "text": "Input block M_3 (xor) C_2: 00000: 0D 71 EE E7 38 BA 96 9F 74 B5 AF C5 36 95 F9 2C",
      "ja": "入力ブロックM_3（xor）C_2：00000：0D 71 EE E7 38 BA 96 9F 74 B5 AF C5 36 95 F9 2C"
    },
    {
      "indent": 3,
      "text": "Output block C_3: 00000: 4E D4 BC A6 CE 6D 6D 16 F8 63 85 13 E0 48 59 75",
      "ja": "出力ブロックC_3：00000：4E D4 BC A6 CE 6D 6D 16 F8 63 85 13 E0 48 59 75"
    },
    {
      "indent": 3,
      "text": "Plaintext block M_4: 00000: 22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11",
      "ja": "平文ブロックM_4：00000：22 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11"
    },
    {
      "indent": 3,
      "text": "Input block M_4 (xor) C_3: 00000: 6C E7 F8 F3 A8 1A E5 8F 52 D8 49 FD 1F 42 59 64",
      "ja": "入力ブロックM_4（xor）C_3：00000：6C E7 F8 F3 A8 1A E5 8F 52 D8 49 FD 1F 42 59 64"
    },
    {
      "indent": 3,
      "text": "Output block C_4: 00000: B6 83 E3 96 FD 30 CD 46 79 C1 8B 24 03 82 1D 81",
      "ja": "出力ブロックC_4：00000：B6 83 E3 96 FD 30 CD 46 79 C1 8B 24 03 82 1D 81"
    },
    {
      "indent": 3,
      "text": "Section_3",
      "ja": "セクション_3"
    },
    {
      "indent": 3,
      "text": "K^3: 00000: F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010: 2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12",
      "ja": "K ^ 3：00000：F2 EE 91 45 6B DC 3D E4 91 2C 87 C3 29 CF 31 A9 00010：2F 20 2E 5A C4 9A 2A 65 31 33 D6 74 8C 4F F9 12"
    },
    {
      "indent": 3,
      "text": "K^3_1: 00000: 78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07",
      "ja": "K ^ 3_1：00000：78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07"
    },
    {
      "indent": 3,
      "text": "MSB1(K1) == 0 -> K2 = K1 << 1 K1:\n00000:   78 21 C7 C7 6C BD 79 63 56 AC F8 8E 69 6A 00 07",
      "raw": true
    },
    {
      "indent": 3,
      "text": "K2: 00000: F0 43 8F 8E D9 7A F2 C6 AD 59 F1 1C D2 D4 00 0E",
      "ja": "K2：00000：F0 43 8F 8E D9 7A F2 C6 AD 59 F1 1C D2 D4 00 0E"
    },
    {
      "indent": 3,
      "text": "Plaintext M_5: 00000: 33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22",
      "ja": "平文M_5：00000：33 44 55 66 77 88 99 AA BB CC EE FF 0A 00 11 22"
    },
    {
      "indent": 3,
      "text": "Using K1, padding is not required",
      "ja": "K1を使用すると、パディングは不要です"
    },
    {
      "indent": 3,
      "text": "Input block M_5 (xor) C_4: 00000: FD E6 71 37 E6 05 2D 8F 94 A1 9D 55 60 E8 0C A4",
      "ja": "入力ブロックM_5（xor）C_4：00000：FD E6 71 37 E6 05 2D 8F 94 A1 9D 55 60 E8 0C A4"
    },
    {
      "indent": 3,
      "text": "Output block C_5: 00000: B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8",
      "ja": "出力ブロックC_5：00000：B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8"
    },
    {
      "indent": 3,
      "text": "Message authentication code T: 00000: B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8",
      "ja": "メッセージ認証コードT：00000：B3 AD B8 92 18 32 05 4C 09 21 E7 B8 08 CF A0 B8"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We thank Mihir Bellare, Scott Fluhrer, Dorothy Cooley, Yoav Nir, Jim Schaad, Paul Hoffman, Dmitry Belyavsky, Yaron Sheffer, Alexey Melnikov, and Spencer Dawkins for their useful comments.",
      "ja": "Mihir Bellare、Scott Fluhrer、Dorothy Cooley、Yoav Nir、Jim Schaad、Paul Hoffman、Dmitry Belyavsky、Yaron Sheffer、Alexey Melnikov、およびSpencer Dawkinsに感謝します。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "Russ Housley Vigil Security, LLC housley@vigilsec.com",
      "ja": "Russ Housley Vigil Security、LLC housley@vigilsec.com"
    },
    {
      "indent": 3,
      "text": "Evgeny Alekseev CryptoPro alekseev@cryptopro.ru",
      "ja": "Evgeny Alekseev CryptoPro alekseev@cryptopro.ru"
    },
    {
      "indent": 3,
      "text": "Ekaterina Smyshlyaeva CryptoPro ess@cryptopro.ru",
      "ja": "Ekaterina Smyshlyaeva CryptoPro ess@cryptopro.ru"
    },
    {
      "indent": 3,
      "text": "Shay Gueron University of Haifa, Israel Intel Corporation, Israel Development Center, Israel shay.gueron@gmail.com",
      "ja": "シェイゲロンハイファ大学、イスラエルインテルコーポレーション、イスラエル開発センター、イスラエルshay.gueron@gmail.com"
    },
    {
      "indent": 3,
      "text": "Daniel Fox Franke Akamai Technologies dfoxfranke@gmail.com",
      "ja": "ダニエルフォックスフランケアカマイテクノロジーズdfoxfranke@gmail.com"
    },
    {
      "indent": 3,
      "text": "Lilia Ahmetzyanova CryptoPro lah@cryptopro.ru",
      "ja": "Lilia Ahmetzyanova CryptoPro lah@cryptopro.ru"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Stanislav Smyshlyaev (editor) CryptoPro 18, Suschevskiy val Moscow 127018 Russian Federation",
      "ja": "スタニスラフ・スミシュリャエフ（編集者）CryptoPro 18、Suschevskiy val Moscow 127018 Russian Federation"
    },
    {
      "indent": 3,
      "text": "Phone: +7 (495) 995-48-20\nEmail: svs@cryptopro.ru",
      "raw": true
    }
  ]
}