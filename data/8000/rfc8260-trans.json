{
  "title": {
    "text": "RFC 8260 - Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol",
    "ja": "RFC 8260 - ストリーム制御伝送プロトコルのためのストリームスケジューラとユーザーのメッセージインターリーブ"
  },
  "number": 8260,
  "created_at": "2019-10-27 13:44:19.351408+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        R. Stewart\nRequest for Comments: 8260                                 Netflix, Inc.\nCategory: Standards Track                                      M. Tuexen\nISSN: 2070-1721                         Muenster Univ. of Appl. Sciences\n                                                               S. Loreto\n                                                                Ericsson\n                                                           R. Seggelmann\n                                     Metafinanz Informationssysteme GmbH\n                                                           November 2017",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Stream Schedulers and User Message Interleaving\n  for the Stream Control Transmission Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Stream Control Transmission Protocol (SCTP) is a message-oriented transport protocol supporting arbitrarily large user messages. This document adds a new chunk to SCTP for carrying payload data. This allows a sender to interleave different user messages that would otherwise result in head-of-line blocking at the sender. The interleaving of user messages is required for WebRTC data channels.",
      "ja": "ストリーム制御伝送プロトコル（SCTP）は、任意の大きなユーザメッセージをサポートするメッセージ指向トランスポート・プロトコルです。この文書では、ペイロードデータを運ぶためのSCTPする新しいチャンクを追加します。これは、そうでない場合は、送信者にヘッドオブラインブロッキングにつながる別のユーザーのメッセージをインターリーブする送信者を可能にします。ユーザメッセージのインターリーブはのWebRTCデータチャネルのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "Whenever an SCTP sender is allowed to send user data, it may choose from multiple outgoing SCTP streams. Multiple ways for performing this selection, called stream schedulers, are defined in this document. A stream scheduler can choose to either implement, or not implement, user message interleaving.",
      "ja": "SCTP送信者は、ユーザデータを送信することが許可されたときはいつでも、それは複数の発信SCTPストリームから選択することができます。ストリームスケジューラと呼ばれるこの選択を行うための複数の方法は、この文書で定義されています。ストリームスケジューラは、実装するユーザーメッセージインターリーブを実装し、そうでないかのどちらかに選択することができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8260.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8260で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.2.  Conventions . . . . . . . . . . . . . . . . . . . . . . .   6\n2.  User Message Interleaving . . . . . . . . . . . . . . . . . .   6\n  2.1.  The I-DATA Chunk Supporting User Message Interleaving . .   7\n  2.2.  Procedures  . . . . . . . . . . . . . . . . . . . . . . .   9\n    2.2.1.  Negotiation . . . . . . . . . . . . . . . . . . . . .  10\n    2.2.2.  Sender-Side Considerations  . . . . . . . . . . . . .  10\n    2.2.3.  Receiver-Side Considerations  . . . . . . . . . . . .  11\n  2.3.  Interaction with Other SCTP Extensions  . . . . . . . . .  11\n    2.3.1.  SCTP Partial Reliability Extension  . . . . . . . . .  11\n    2.3.2.  SCTP Stream Reconfiguration Extension . . . . . . . .  13\n3.  Stream Schedulers . . . . . . . . . . . . . . . . . . . . . .  14\n  3.1.  First-Come, First-Served Scheduler (SCTP_SS_FCFS) . . . .  14\n  3.2.  Round-Robin Scheduler (SCTP_SS_RR)  . . . . . . . . . . .  14\n  3.3.  Round-Robin Scheduler per Packet (SCTP_SS_RR_PKT) . . . .  14\n  3.4.  Priority-Based Scheduler (SCTP_SS_PRIO) . . . . . . . . .  14\n  3.5.  Fair Capacity Scheduler (SCTP_SS_FC)  . . . . . . . . . .  15\n  3.6.  Weighted Fair Queueing Scheduler (SCTP_SS_WFQ)  . . . . .  15\n4.  Socket API Considerations . . . . . . . . . . . . . . . . . .  15\n  4.1.  Exposure of the Stream Sequence Number (SSN)  . . . . . .  15\n  4.2.  SCTP_ASSOC_CHANGE Notification  . . . . . . . . . . . . .  16\n  4.3.  Socket Options  . . . . . . . . . . . . . . . . . . . . .  16\n    4.3.1.  Enable or Disable the Support of User Message\n            Interleaving (SCTP_INTERLEAVING_SUPPORTED)  . . . . .  16\n    4.3.2.  Get or Set the Stream Scheduler\n            (SCTP_STREAM_SCHEDULER) . . . . . . . . . . . . . . .  17\n    4.3.3.  Get or Set the Stream Scheduler Parameter\n            (SCTP_STREAM_SCHEDULER_VALUE) . . . . . . . . . . . .  18\n  4.4.  Explicit EOR Marking  . . . . . . . . . . . . . . . . . .  19\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  19\n  5.1.  I-DATA Chunk  . . . . . . . . . . . . . . . . . . . . . .  19\n  5.2.  I-FORWARD-TSN Chunk . . . . . . . . . . . . . . . . . . .  20\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  20\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  21\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  22\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  22\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  23",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Overview",
      "section_title": true,
      "ja": "1.1. 概要"
    },
    {
      "indent": 3,
      "text": "When SCTP [RFC4960] was initially designed, it was mainly envisioned for the transport of small signaling messages. Late in the design stage, it was decided to add support for fragmentation and reassembly of larger messages with the thought that someday signaling messages in the style of Session Initiation Protocol (SIP) [RFC3261] may also need to use SCTP, and a message that is a single Maximum Transmission Unit (MTU) would be too small. Unfortunately this design decision, though valid at the time, did not account for other applications that might send large messages over SCTP. The sending of such large messages over SCTP, as specified in [RFC4960], can result in a form of sender-side head-of-line blocking (e.g., when the transmission of a message is blocked from transmission because the sender has started the transmission of another, possibly large, message). This head-of-line blocking is caused by the use of the Transmission Sequence Number (TSN) for three different purposes:",
      "ja": "SCTP [RFC4960]が最初に設計された場合には、主に小シグナリングメッセージの輸送のために想定されました。後期設計段階において、それがいつか、セッション開始プロトコル（SIP）のスタイルでシグナリングメッセージ思想と大きなメッセージのフラグメンテーション及び再組み立てのためのサポートを追加することを決定した[RFC3261]もSCTPを使用する必要があるかもしれません、とメッセージ単一の最大伝送ユニット（MTU）が小さすぎるです。残念ながら、この設計上の決定は、一度に有効なものの、SCTP上で大きなメッセージを送信することがあります、他のアプリケーションを考慮していませんでした。送信者が開始したので、SCTP上、このような大きなメッセージの送信、[RFC4960]で指定されるように、送信側のヘッド・オブ・ラインメッセージの送信は、送信が阻止される場合、例えば、（ブロックの形をもたらすことができます別の送信、おそらくは大、メッセージ）。このヘッドオブラインブロッキングは、3つの異なる目的のための送信シーケンス番号（TSN）の使用によって引き起こされます。"
    },
    {
      "indent": 3,
      "text": "1. As an identifier for DATA chunks to provide a reliable transfer.",
      "section_title": true,
      "ja": "DATAチャンクが信頼できる転送を提供するための識別子として1。"
    },
    {
      "indent": 3,
      "text": "2. As an identifier for the sequence of fragments to allow reassembly.",
      "ja": "2.再構築を可能にするためにフラグメントのシーケンスの識別子として。"
    },
    {
      "indent": 3,
      "text": "3. As a sequence number allowing up to 2**16 - 1 Stream Sequence Numbers (SSNs) outstanding.",
      "ja": "卓越した1ストリーム・シーケンス番号（SSNの） -  2 ** 16まで許可シーケンス番号として3。"
    },
    {
      "indent": 3,
      "text": "The protocol requires all fragments of a user message to have consecutive TSNs. This document allows an SCTP sender to interleave different user messages.",
      "ja": "プロトコルは、連続したTSNを持っているユーザメッセージのすべての断片が必要です。この文書では、SCTP送信者が別のユーザーのメッセージをインターリーブすることができます。"
    },
    {
      "indent": 3,
      "text": "This document also defines several stream schedulers for general SCTP associations allowing different relative stream treatments. The stream schedulers may behave differently depending on whether or not user message interleaving has been negotiated for the association.",
      "ja": "この文書はまた、異なる相対ストリームトリートメントを可能一般的なSCTPアソシエーションのいくつかのストリームスケジューラを定義します。ストリームスケジューラは、ユーザ・メッセージ・インターリービングは、アソシエーションのために交渉されたか否かに応じて異なる動作をすることができます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates the behavior of a round-robin stream scheduler using DATA chunks when three streams with the Stream Identifiers (SIDs) 0, 1, and 2 are used. Each queue for SID 0 and SID 2 contains a single user message requiring three chunks. The queue for SID 1 contains three user messages each requiring a single chunk. It is shown how these user messages are encapsulated in chunks using TSN 0 to TSN 8. Please note that the use of such a scheduler implies late",
      "ja": "図1は、ストリーム識別子（SID）、0,1、および2を有する3つのストリームが使用される場合のデータチャンクを使用して、ラウンドロビン・ストリーム・スケジューラの挙動を示します。 SID 0およびSID 2に対する各キューは、三のチャンクを必要とする単一のユーザメッセージを含みます。 SID 1のキューは、単一のチャンクを必要とする3つのユーザーのメッセージ、それぞれが含まれています。このようなスケジューラの使用が遅く暗示ことに注意してくださいTSN 8にTSN 0を使用して、これらのユーザーのメッセージがチャンクにカプセル化する方法を示しています"
    },
    {
      "indent": 3,
      "text": "TSN assignment, but it can be used with an implementation that is compliant with [RFC4960] and that does not support user message interleaving. Late TSN assignment means that the sender generates chunks from user messages and assigns the TSN as late as possible in the process of sending the user messages.",
      "ja": "TSN割り当て、それは、[RFC4960]に準拠しており、それはユーザ・メッセージ・インターリービングをサポートしていない実装で使用することができます。後期TSNの割り当ては、送信者がユーザーのメッセージからチャンクを生成し、ユーザのメッセージを送信するプロセスでできるだけ遅くTSNを割り当てることを意味します。"
    },
    {
      "indent": 3,
      "text": "+---+---+---+\n|    0/0    |-+\n+---+---+---+ |\n              |  +---+---+---+---+---+---+---+---+---+\n+---+---+---+ +->|1/2|1/1|2/0|2/0|2/0|1/0|0/0|0/0|0/0|\n|1/2|1/1|1/0|--->|---|---|---|---|---|---|---|---|---|\n+---+---+---+ +->| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n              |  +---+---+---+---+---+---+---+---+---+\n+---+---+---+ |\n|    2/0    |-+\n+---+---+---+\n                               +-------+\n  +-------+                    |SID/SSN|\n  |SID/SSN|                    |-------|\n  +-------+                    |  TSN  |\n                               +-------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: Round-Robin Scheduler without User Message Interleaving",
      "ja": "図1：ユーザー・メッセージインターリーブなしのラウンドロビンスケジューラ"
    },
    {
      "indent": 3,
      "text": "This document describes a new chunk carrying payload data called I-DATA. This chunk incorporates the properties of the current SCTP DATA chunk, all the flags and fields except the Stream Sequence Number (SSN), and also adds two new fields in its chunk header -- the Fragment Sequence Number (FSN) and the Message Identifier (MID). The FSN is only used for reassembling all fragments that have the same MID and the same ordering property. The TSN is only used for the reliable transfer in combination with Selective Acknowledgment (SACK) chunks.",
      "ja": "この文書では、I-DATAと呼ばれるペイロードデータを運ぶ新しいチャンクを記述する。このチャンクは、ストリームシーケンス番号（SSN）を除く現在のSCTPデータチャンクの特性、すべてのフラグ及びフィールドを内蔵し、また、そのチャンクヘッダーの2つの新しいフィールド追加 - （フラグメントシーケンス番号（FSN）およびメッセージ識別子をMID）。 FSNは、同じMIDと同じ順序付けプロパティを持つすべての断片を組み立て直すために使用されています。 TSNのみ選択的確認応答（SACK）チャンクと組み合わせて信頼性の高い転送のために使用されます。"
    },
    {
      "indent": 3,
      "text": "In addition, the MID is also used for ensuring ordered delivery instead of using the stream sequence number (the I-DATA chunk omits an SSN).",
      "ja": "また、MIDはまた、順序付けられた配信を確保する代わりに、ストリーム・シーケンス番号（I-DATAチャンクがSSNを省略）を使用するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Figure 2 illustrates the behavior of an interleaving round-robin stream scheduler using I-DATA chunks.",
      "ja": "図2は、I-DATAチャンクを使用してインターリーブラウンドロビンストリームスケジューラの挙動を示します。"
    },
    {
      "indent": 0,
      "text": "+---+---+---+\n|    0/0    |-+\n+---+---+---+ |\n              |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+\n+---+---+---+ +->|2/0/2|1/2/0|0/0/2|2/0/1|1/1/0|0/0/1|2/0/0|1/0/0|0/0/0|\n|1/2|1/1|1/0|--->|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n+---+---+---+ +->|  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |\n              |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+\n+---+---+---+ |\n|    2/0    |-+\n+---+---+---+\n                                     +-----------+\n  +-------+                          |SID/MID/FSN|\n  |SID/MID|                          |-----------|\n  +-------+                          |    TSN    |\n                                     +-----------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 2: Round-Robin Scheduler with User Message Interleaving",
      "ja": "図2：ユーザー・メッセージインターリーブとラウンドロビンスケジューラ"
    },
    {
      "indent": 3,
      "text": "The support of the I-DATA chunk is negotiated during the association setup using the Supported Extensions Parameter, as defined in [RFC5061]. If I-DATA support has been negotiated for an association, I-DATA chunks are used for all user messages. DATA chunks are not permitted when I-DATA support has been negotiated. It should be noted that an SCTP implementation supporting I-DATA chunks needs to allow the coexistence of associations using DATA chunks and associations using I-DATA chunks.",
      "ja": "[RFC5061]で定義されているI-DATAチャンクのサポートは、サポートされている拡張機能のパラメータを使用して、関連のセットアップ中にネゴシエートされます。 I-DATAのサポートは、協会のために交渉されている場合は、I-DATAチャンクは、すべてのユーザーのメッセージに使用されています。 I-DATAのサポートが交渉されたときに、データチャンクは許可されていません。 I-DATAチャンクをサポートするSCTPの実装は、I-DATAチャンクを使用して、DATAチャンクとの関連付けを使用して団体の共存を可能にするために必要であることに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "In Section 2, this document specifies the user message interleaving by defining the I-DATA chunk, the procedures to use it, and its interactions with other SCTP extensions. Section 3 defines multiple stream schedulers, and Section 4 describes an extension to the socket API for using the mechanism specified in this document.",
      "ja": "第2節では、この文書は、I-DATAチャンクを定義することによってインターリーブユーザメッセージ、それを使用する手順、および他のSCTP拡張機能との相互作用を特定します。セクション3は、複数のストリームスケジューラを定義し、セクション4は、この文書で指定されたメカニズムを使用するためのソケットAPIの拡張を記述しています。"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions",
      "section_title": true,
      "ja": "1.2. 表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. User Message Interleaving",
      "section_title": true,
      "ja": "2.ユーザーのメッセージインターリーブ"
    },
    {
      "indent": 3,
      "text": "The protocol mechanisms described in this document allow the interleaving of user messages sent on different streams. They do not support the interleaving of multiple messages (ordered or unordered) sent on the same stream.",
      "ja": "本書で説明されたプロトコルメカニズムは異なるストリームに対して送信されたユーザメッセージのインターリーブを可能にします。彼らは、同じストリームで送信された複数のメッセージ（注文または順不同）のインターリーブをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "The interleaving of user messages is required for WebRTC data channels, as specified in [DATA-CHAN].",
      "ja": "[DATA-CHAN]で指定されたユーザメッセージのインターリービングは、のWebRTCデータチャネルのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation supporting user message interleaving is REQUIRED to support the coexistence of associations using DATA chunks and associations using I-DATA chunks. If an SCTP implementation supports user message interleaving and the Partial Reliability extension described in [RFC3758] or the Stream Reconfiguration Extension described in [RFC6525], it is REQUIRED to implement the corresponding changes specified in Section 2.3.",
      "ja": "ユーザ・メッセージ・インターリービングをサポートSCTP実装は、I-DATAチャンクを使用して、データチャンクとの関連付けを使用して関連の共存をサポートするために必要とされます。 SCTP実装がインターリーブユーザメッセージおよびストリーム再拡張は、[RFC6525]に記載の部分信頼性[RFC3758]に記載の拡張またはをサポートしている場合、セクション2.3で指定された対応する変更を実装するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "2.1. The I-DATA Chunk Supporting User Message Interleaving",
      "section_title": true,
      "ja": "2.1. ユーザー・メッセージインターリーブをサポートするI-DATAチャンク"
    },
    {
      "indent": 3,
      "text": "The following Figure 3 shows the new I-DATA chunk allowing user message interleaving.",
      "ja": "以下、図3は、ユーザメッセージのインターリーブを可能にする新たなI-DATAチャンクを示しています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 64   |  Res  |I|U|B|E|       Length = Variable       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Stream Identifier      |           Reserved            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Message Identifier                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Payload Protocol Identifier / Fragment Sequence Number     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                           User Data                           /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 3: I-DATA Chunk Format",
      "ja": "図3：I-DATAチャンクフォーマット"
    },
    {
      "indent": 3,
      "text": "The only differences between the I-DATA chunk in Figure 3 and the DATA chunk defined in [RFC4960] and [RFC7053] are the addition of the new Message Identifier (MID) and the new Fragment Sequence Number (FSN) and the removal of the Stream Sequence Number (SSN). The Payload Protocol Identifier (PPID), which is already defined for DATA chunks in [RFC4960], and the new FSN are stored at the same location of the packet using the B bit to determine which value is stored at the location. The length of the I-DATA chunk header is 20 bytes, which is 4 bytes more than the length of the DATA chunk header defined in [RFC4960] and [RFC7053].",
      "ja": "図3のI-DATAチャンクとDATA [RFC4960]で定義されたチャンクと[RFC7053]の間の唯一の違いは、新しいメッセージ識別子（MID）と新しいフラグメントシーケンス番号（FSN）との除去の添加でありますストリームシーケンス番号（SSN）。すでに[RFC4960]のデータチャンクのために定義されているペイロードプロトコル識別子（PPID）、及び新たなFSNは、場所に格納された値を決定するためにBビットを使用してパケットの同じ場所に格納されています。 I-DATAチャンクヘッダの長さは、[RFC4960]及び[RFC7053]で定義されたデータチャンクヘッダの長さよりも4バイト以上である20バイトです。"
    },
    {
      "indent": 3,
      "text": "The old fields are:",
      "ja": "古いフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Res: 4 bits These bits are reserved. They MUST be set to 0 by the sender and MUST be ignored by the receiver.",
      "ja": "RES：これらのビットは予約されて4ビット。彼らは、送信者によって0に設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "I bit: 1 bit The (I)mmediate Bit, if set, indicates that the receiver SHOULD NOT delay the sending of the corresponding SACK chunk. Same as the I bit for DATA chunks, as specified in [RFC7053].",
      "ja": "Iビット：1ビット（I）mmediateビットをセットは、受信機は対応するSACKチャンクの送信を遅らせないことを示す場合。 [RFC7053]で指定されるように、DATAチャンクのためのIビットと同じ。"
    },
    {
      "indent": 3,
      "text": "U bit: 1 bit The (U)nordered bit, if set, indicates the user message is unordered. Same as the U bit for DATA chunks, as specified in [RFC4960].",
      "ja": "Uビット：1ビット（U）norderedビット、設定されている場合、ユーザ・メッセージが順不同であることを示します。 [RFC4960]で指定されるように、データチャンクのためのUビットと同じ。"
    },
    {
      "indent": 3,
      "text": "B bit: 1 bit The (B)eginning fragment bit, if set, indicates the first fragment of a user message. Same as the B bit for DATA chunks, as specified in [RFC4960].",
      "ja": "Bビット：1ビット（B）eginningフラグメントビット、設定されている場合、ユーザ・メッセージの最初のフラグメントを示します。 [RFC4960]で指定されるように、データチャンクのためのBビットと同じ。"
    },
    {
      "indent": 3,
      "text": "E bit: 1 bit The (E)nding fragment bit, if set, indicates the last fragment of a user message. Same as the E bit for DATA chunks, as specified in [RFC4960].",
      "ja": "Eビット：断片ビットをnding 1ビット（E）は、設定されている場合、ユーザメッセージの最後の断片を示します。 [RFC4960]で指定されるように、データチャンクのためのEビットと同じ。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) This field indicates the length in bytes of the DATA chunk from the beginning of the Type field to the end of the User Data field, excluding any padding. Similar to the Length for DATA chunks, as specified in [RFC4960].",
      "ja": "長さ：16ビット（符号なし整数）このフィールドは、任意のパディングを除いて、ユーザデータフィールドの端にタイプフィールドの先頭からのデータ・チャンクのバイト長を示します。 [RFC4960]で指定されるように、データチャンクのための長さに類似しています。"
    },
    {
      "indent": 3,
      "text": "TSN: 32 bits (unsigned integer) This value represents the TSN for this I-DATA chunk. Same as the TSN for DATA chunks, as specified in [RFC4960].",
      "ja": "TSN：32ビット（符号なし整数）この値は、このI-DATAのチャンクのTSNを表します。 [RFC4960]で指定されるように、DATAチャンクのためのTSNと同じ。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier: 16 bits (unsigned integer) Identifies the stream to which the user data belongs. Same as the Stream Identifier for DATA chunks, as specified in [RFC4960].",
      "ja": "ストリーム識別子：16ビット（符号なし整数）は、ユーザデータが属するストリームを識別する。 [RFC4960]で指定されたように、データチャンクのためのストリーム識別子と同じ。"
    },
    {
      "indent": 3,
      "text": "The new fields are:",
      "ja": "新しいフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 bits (unsigned integer) This field is reserved. It MUST be set to 0 by the sender and MUST be ignored by the receiver.",
      "ja": "予約：16ビット（符号なし整数）このフィールドは予約されています。これは、送信者によって0に設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Identifier (MID): 32 bits (unsigned integer) The MID is the same for all fragments of a user message; it is used to determine which fragments (enumerated by the FSN) belong to the same user message. For ordered user messages, the MID is also used by the SCTP receiver to deliver the user messages in the correct order to the upper layer (similar to the SSN of the DATA chunk defined in [RFC4960]). The sender uses two counters for each outgoing stream: one for ordered messages and one for unordered messages. All of these counters are independent and initially 0. They are incremented by 1 for each user message. Please note that the serial number arithmetic defined in [RFC1982] using SERIAL_BITS = 32 applies. Therefore, the sender MUST NOT have more than 2**31 - 1 ordered messages for each outgoing stream in flight and MUST NOT have more than 2**31 - 1 unordered messages for each outgoing stream in flight. A message is considered in flight if at least one of its I-DATA chunks is not acknowledged in a way that cannot be reneged (i.e., not acknowledged by the cumulative TSN Ack). Please note that the MID is in \"network byte order\", a.k.a. Big Endian.",
      "ja": "メッセージ識別子（MID）：32ビット（符号なし整数）MIDは、ユーザ・メッセージの全ての断片についても同様です。同一のユーザメッセージに属するフラグメント（FSNによって列挙）を決定するために使用されます。順序付けられたユーザメッセージの場合、MIDはまた、上位層に正しい順序でユーザ・メッセージを配信するためにSCTP受信機によって使用される（[RFC4960]で定義されたデータチャンクのSSNと同様）。注文したメッセージ用と順序なしのメッセージのための1：送信者は、各発信ストリームのための2つのカウンタを使用しています。これらのカウンタのすべてが独立しており、当初は0彼らは、各ユーザーのメッセージのために1ずつ増加しています。 [RFC1982]を使用SERIAL_BITSで定義されたシリアル番号算術= 32が適用されることに注意してください。 1飛行中の各発信ストリームのメッセージを注文し、以上の2つの** 31件のあってはならない -   - 飛行中の各発信ストリームの1順不同のメッセージをそのため、送信者は、以上の2 ** 31は、あってはなりません。そのI-DATAチャンクの少なくとも一つが（即ち、累積TSN肯定応答によって肯定応答されない）破っすることができないように確認されない場合、メッセージは、飛行中であると考えられます。 MIDは、「ネットワークバイト順序」、別名、ビッグエンディアンであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Payload Protocol Identifier (PPID) / Fragment Sequence Number (FSN): 32 bits (unsigned integer) If the B bit is set, this field contains the PPID of the user message. Note that in this case, this field is not touched by an SCTP implementation; therefore, its byte order is not necessarily in network byte order. The upper layer is responsible for any byte order conversions to this field, similar to the PPID of DATA chunks. In this case, the FSN is implicitly considered to be 0. If the B bit is not set, this field contains the FSN. The FSN is used to enumerate all fragments of a single user message, starting from 0 and incremented by 1. The last fragment of a message MUST have the E bit set. Note that the FSN MAY wrap completely multiple times, thus allowing arbitrarily large user messages. For the FSN, the serial number arithmetic defined in [RFC1982] applies with SERIAL_BITS = 32. Therefore, a sender MUST NOT have more than 2**31 - 1 fragments of a single user message in flight. A fragment is considered in flight if it is not acknowledged in a way that cannot be reneged. Please note that the FSN is in \"network byte order\", a.k.a. Big Endian.",
      "ja": "ペイロードプロトコル識別子（PPID）/フラグメントシーケンス番号（FSN）：32ビット（符号なし整数）Bビットがセットされている場合、このフィールドは、ユーザメッセージのPPIDを含んでいます。この場合には、このフィールドはSCTP実装によって触れられていないことに注意してください。そのため、そのバイト順はネットワークバイトオーダーに限りません。上位層は、DATAチャンクのPPIDに似て、このフィールドに任意のバイトオーダー変換する責任があります。この場合、FSNは暗黙的Bビットが設定されていない場合、このフィールドは、FSNが含ま0であると考えられます。 FSNは、0から開始し、単一のユーザメッセージのすべてのフラグメントを列挙するために使用され、メッセージの最後のフラグメントは、Eビットを設定する必要があります1だけインクリメントされます。 FSNは、このように任意の大きさのユーザーのメッセージを許可する、完全に複数回折り返すことに注意してください。 FSNは、[RFC1982]で定義されたシリアル番号算術= 32 SERIAL_BITSで適用したがって、送信者は、より** 2より31てはならない - 飛行中の単一のユーザメッセージの1フラグメント。それは破ったことができない方法で確認されない場合はフラグメントは、飛行中に考慮されています。 FSNは、「ネットワークバイト順序」、別名、ビッグエンディアンであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Procedures",
      "section_title": true,
      "ja": "2.2. 手順"
    },
    {
      "indent": 3,
      "text": "This subsection describes how the support of the I-DATA chunk is negotiated and how the I-DATA chunk is used by the sender and receiver.",
      "ja": "ここでは、I-DATAチャンクのサポートが交渉されている方法およびI-DATAチャンクは、送信者と受信者によって使用されている方法を説明します。"
    },
    {
      "indent": 3,
      "text": "The handling of the I bit for the I-DATA chunk corresponds to the handling of the I bit for the DATA chunk described in [RFC7053].",
      "ja": "I-DATAのチャンクのIビットの処理は[RFC7053]で説明したデータチャンクのIビットの処理に相当します。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Negotiation",
      "section_title": true,
      "ja": "2.2.1. ネゴシエーション"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint indicates user message interleaving support by listing the I-DATA chunk within the Supported Extensions Parameter, as defined in [RFC5061]. User message interleaving has been negotiated for an association if both endpoints have indicated I-DATA support.",
      "ja": "SCTPエンドポイントは、[RFC5061]で定義されるように、サポートされている拡張パラメータ内I-DATAチャンクをリストすることによって、ユーザメッセージインターリーブサポートを示しています。両方のエンドポイントがI-DATAのサポートを示している場合、ユーザメッセージインターリーブはアソシエーションのために交渉されています。"
    },
    {
      "indent": 3,
      "text": "If user message interleaving support has been negotiated for an association, I-DATA chunks MUST be used for all user messages and DATA chunks MUST NOT be used. If user message interleaving support has not been negotiated for an association, DATA chunks MUST be used for all user messages and I-DATA chunks MUST NOT be used.",
      "ja": "ユーザメッセージインターリーブサポートは、協会のために交渉されている場合は、I-DATAチャンクを使用してはいけません、すべてのユーザーのメッセージとDATAチャンクを使用しなければなりません。ユーザメッセージインターリーブサポートは、協会のために交渉されていない場合は、DATAチャンクは、すべてのユーザーのメッセージとI-DATAチャンクを使用しなければなりません使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "An endpoint implementing the socket API specified in [RFC6458] MUST NOT indicate user message interleaving support unless the user has requested its use (e.g., via the socket API; see Section 4.3). This constraint is made since the usage of this chunk requires that the application is capable of handling interleaved messages upon reception within an association. This is not the default choice within the socket API (see the SCTP_FRAGMENT_INTERLEAVE socket option in Section 8.1.20 of [RFC6458]); thus, the user MUST indicate to the SCTP implementation its support for receiving completely interleaved messages.",
      "ja": "ユーザは、その使用要求していない限り、[RFC6458]で指定されたソケットAPIを実装するエンドポイントがサポートインターリーブユーザメッセージを示してはいけません（ソケットAPIを介して、例えばと、セクション4.3を参照します）。このチャンクの使用は、アプリケーションが関連付け内の受信時にインターリーブメッセージを処理することが可能であることを必要とするので、この制約がなされます。これは、ソケットAPI内のデフォルトの選択（[RFC6458]のセクション8.1.20でSCTP_FRAGMENT_INTERLEAVEソケットオプションを参照）ではありません。従って、ユーザは、SCTP実装に完全にインターリーブされたメッセージを受信するためのサポートを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that stacks that do not implement [RFC6458] may use other methods to indicate interleaved message support and thus indicate the support of user message interleaving. The crucial point is that the SCTP stack MUST know that the application can handle interleaved messages before indicating the I-DATA support.",
      "ja": "実装していないスタック[RFC6458]はインターリーブメッセージのサポートを示すために他の方法を使用し、したがって、ユーザ・メッセージ・インターリービングのサポートを示すことができることに留意されたいです。重要なポイントは、SCTPスタックは、アプリケーションがI-DATAのサポートを示す前に、インターリーブされたメッセージを処理できることを知らなければならないということです。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Sender-Side Considerations",
      "section_title": true,
      "ja": "2.2.2. 送信側の考慮事項"
    },
    {
      "indent": 3,
      "text": "The sender-side usage of the I-DATA chunk is quite simple. Instead of using the TSN for fragmentation purposes, the sender uses the new FSN field to indicate which fragment number is being sent. The first fragment MUST have the B bit set. The last fragment MUST have the E bit set. All other fragments MUST NOT have the B or E bit set. All other properties of the existing SCTP DATA chunk also apply to the I-DATA chunk, i.e., congestion control as well as receiver window conditions MUST be observed, as defined in [RFC4960].",
      "ja": "I-DATAチャンクの送信者側の使用は非常に簡単です。代わりに、断片化の目的のためにTSNを使用するのではなく、送信者は、送信されているフラグメント数を示すために、新しいFSNフィールドを使用します。最初のフラグメントは、Bビットを設定する必要があります。最後のフラグメントは、Eビットを設定する必要があります。他のすべてのフラグメントは、BまたはEビットがセットされていてはなりません。 [RFC4960]で定義されるように、既存のSCTPデータチャンクのすべての他の特性も、I-DATAチャンク、すなわち、輻輳制御、ならびにレシーバウィンドウ条件を守らなければならないにも適用されます。"
    },
    {
      "indent": 3,
      "text": "Note that the usage of this chunk implies the late assignment of the actual TSN to any chunk being sent. Each I-DATA chunk uses a single TSN. This way messages from other streams may be interleaved with the fragmented message. Please note that this is the only form of interleaving support. For example, it is not possible to interleave multiple ordered or unordered user messages from the same stream.",
      "ja": "このチャンクの使用量が送信されている任意のチャンクに実際のTSNの後期割り当てを意味することに注意してください。各I-DATAチャンクは、単一のTSNを使用しています。このように他のストリームからのメッセージは断片化されたメッセージとインターリーブされてもよいです。これは、インターリーブ対応の唯一の形式であることに注意してください。例えば、同じストリームから複数の注文や順不同ユーザメッセージをインターリーブすることはできません。"
    },
    {
      "indent": 3,
      "text": "The sender MUST NOT process (move user data into I-DATA chunks and assign a TSN to it) more than one user message in any given stream at any time. At any time, a sender MAY process multiple user messages, each of them on different streams.",
      "ja": "送信者は、NOTプロセスは、いつでも任意のストリーム内の複数のユーザのメッセージを（I-DATAのチャンクにユーザデータを移動し、それにTSNを割り当てる）しなければなりません。任意の時点で、送信者が異なるストリーム上で、それらのそれぞれを複数のユーザーのメッセージを処理することができます。"
    },
    {
      "indent": 3,
      "text": "The sender MUST assign TSNs to I-DATA chunks in a way that the receiver can make progress. One way to achieve this is to assign a higher TSN to the later fragments of a user message and send out the I-DATA chunks such that the TSNs are in sequence.",
      "ja": "送信者は、受信機が進歩を遂げることができますように、I-DATAチャンクへのTSNを割り当てる必要があります。これを達成する1つの方法は、ユーザーのメッセージの後の断片に高いTSNを割り当てるとのTSNが順番にあるようなI-DATAチャンクを送信することです。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Receiver-Side Considerations",
      "section_title": true,
      "ja": "2.2.3. 受信側の考慮事項"
    },
    {
      "indent": 3,
      "text": "Upon reception of an SCTP packet containing an I-DATA chunk whose user message needs to be reassembled, the receiver MUST first use the SID to identify the stream, consider the U bit to determine if it is part of an ordered or unordered message, find the user message identified by the MID, and use the FSN for reassembly of the message and not the TSN. The receiver MUST NOT make any assumption about the TSN assignments of the sender. Note that a non-fragmented message is indicated by the fact that both the E and B bits are set. A message (either ordered or unordered) whose E and B bits are not both set may be identified as being fragmented.",
      "ja": "ユーザメッセージの再組み立てする必要がI-DATAチャンクを含むSCTPパケットを受信すると、受信機は最初に、ストリームを識別するためにSIDを使用することが命じ又は順不同メッセージの一部であるかどうかを決定するためにUビットを考慮し、見つけなければなりませんユーザMIDによって識別されるメッセージ、およびメッセージとしないTSNの再構成のためFSNを使用します。受信機は、送信者のTSNの割り当てについての仮定をしてはなりません。非断片化メッセージをEとBビットの両方が設定されているという事実によって示されることに留意されたいです。そのEとBビットの両方設定されていないメッセージ（順序付け又は順不同のいずれか）が断片化されたものとして識別することができます。"
    },
    {
      "indent": 3,
      "text": "If I-DATA support has been negotiated for an association, the reception of a DATA chunk is a violation of the above rules and therefore the receiver of the DATA chunk MUST abort the association by sending an ABORT chunk. The ABORT chunk MAY include the 'Protocol Violation' error cause. The same applies if I-DATA support has not been negotiated for an association and an I-DATA chunk is received.",
      "ja": "I-DATAサポートはアソシエーションのために交渉されている場合、データチャンクの受信は、上記の規則に違反しているため、データチャンクの受信機は、ABORTチャンクを送信することにより、関連付けを中止しなければなりません。 ABORTチャンクは「プロトコル違反」というエラー原因を含むかもしれません。 I-DATAのサポートは、協会のために交渉されておらず、I-DATAチャンクを受信した場合も同様です。"
    },
    {
      "indent": 0,
      "text": "2.3. Interaction with Other SCTP Extensions",
      "section_title": true,
      "ja": "2.3. その他のSCTP拡張機能との相互作用"
    },
    {
      "indent": 3,
      "text": "The usage of the I-DATA chunk might interfere with other SCTP extensions. Future SCTP extensions MUST describe if and how they interfere with the usage of I-DATA chunks. For the SCTP extensions already defined when this document was published, the details are given in the following subsections.",
      "ja": "I-DATAチャンクの使用は他のSCTP拡張を妨げる可能性があります。彼らはI-DATAチャンクの利用を妨げる場合には、どのように将来SCTP拡張が説明しなければなりません。この文書が公開されたときにすでに定義されているSCTPの拡張について、詳細は以下のサブセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "2.3.1. SCTP Partial Reliability Extension",
      "section_title": true,
      "ja": "2.3.1.  SCTP部分的な信頼性の拡張"
    },
    {
      "indent": 3,
      "text": "When the SCTP extension defined in [RFC3758] is used in combination with the user message interleaving extension, the new I-FORWARD-TSN chunk MUST be used instead of the FORWARD-TSN chunk. The difference between the FORWARD-TSN and the I-FORWARD-TSN chunk is that the 16-bit Stream Sequence Number (SSN) has been replaced by the 32-bit Message Identifier (MID), and the largest skipped MID can also be provided for unordered messages. Therefore, the principle applied to ordered messages when using FORWARD-TSN chunks is applied to ordered and unordered messages when using I-FORWARD-TSN chunks.",
      "ja": "[RFC3758]で定義されたSCTP拡張がユーザメッセージインターリーブ拡張と組み合わせて使用​​される場合、新たなI-FORWARD-TSNチャンク代わりFORWARD-TSNチャンクの使用されなければなりません。 FORWARD-TSNおよびI-FORWARD-TSNチャンクとの間の差は、16ビットストリームシーケンス番号（SSN）は、32ビットのメッセージ識別子（MID）により置換されており、最大スキップMIDも提供することができることです順不同のメッセージのため。 I-FORWARD-TSNチャンクを使用するときため、FORWARD-TSNチャンクを使用するときに注文したメッセージに適用される原則を注文し、順不同のメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 194  | Flags = 0x00  |      Length = Variable        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       New Cumulative TSN                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Stream Identifier       |          Reserved           |U|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Stream Identifier       |          Reserved           |U|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Message Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 4: I-FORWARD-TSN Chunk Format",
      "ja": "図4：I-FORWARD-TSNチャンクのフォーマット"
    },
    {
      "indent": 3,
      "text": "The old fields are:",
      "ja": "古いフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Flags: 8 bits (unsigned integer) These bits are reserved. They MUST be set to 0 by the sender and MUST be ignored by the receiver. Same as the Flags for FORWARD TSN chunks, as specified in [RFC3758].",
      "ja": "フラグ：8ビット（符号なし整数）これらのビットは予約されています。彼らは、送信者によって0に設定しなければならなくて、受信機で無視しなければなりません。 [RFC3758]で指定されているようFORWARD TSNチャンクのフラグと同じ。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer) This field holds the length of the chunk. Similar to the Length for FORWARD TSN chunks, as specified in [RFC3758].",
      "ja": "長さ：16ビット（符号なし整数）このフィールドは、チャンクの長さを保持します。 [RFC3758]で指定されるように、FORWARD TSNチャンクのための長さに類似しています。"
    },
    {
      "indent": 3,
      "text": "New Cumulative TSN: 32 bits (unsigned integer) This indicates the New Cumulative TSN to the data receiver. Same as the New Cumulative TSN for FORWARD TSN chunks, as specified in [RFC3758].",
      "ja": "新しい累積TSN：32ビット（符号なし整数）これは、データ受信機に新たな累積TSNを示しています。 [RFC3758]で指定されるように、FORWARD TSNチャンクのための新たな累積TSNと同じ。"
    },
    {
      "indent": 3,
      "text": "The new fields are:",
      "ja": "新しいフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier (SID): 16 bits (unsigned integer) This field holds the stream number this entry refers to.",
      "ja": "ストリーム識別子（SID）：16ビット（符号なし整数）このフィールドは、このエントリが参照するストリーム番号を保持します。"
    },
    {
      "indent": 3,
      "text": "Reserved: 15 bits This field is reserved. It MUST be set to 0 by the sender and MUST be ignored by the receiver.",
      "ja": "予約：このフィールドは予約されている15ビット。これは、送信者によって0に設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "U bit: 1 bit The U bit specifies if the Message Identifier of this entry refers to unordered messages (U bit is set) or ordered messages (U bit is not set).",
      "ja": "Uビット：このエントリのメッセージ識別子が順不同メッセージを指す（Uビットが設定されている）、又は（Uビットが設定されていない）メッセージを注文した場合Uビットが指定する1ビット。"
    },
    {
      "indent": 3,
      "text": "Message Identifier (MID): 32 bits (unsigned integer) This field holds the largest Message Identifier for ordered or unordered messages indicated by the U bit that was skipped for the stream specified by the Stream Identifier. For ordered messages, this is similar to the FORWARD-TSN chunk, just replacing the 16-bit SSN by the 32-bit MID.",
      "ja": "メッセージ識別子（MID）：32ビット（符号なし整数）このフィールドは、ストリーム識別子により特定されるストリームのスキップされたUビットによって示される順序付きまたは順序なしのメッセージの最大メッセージ識別子を保持しています。順序付けられたメッセージの場合、これは単に、32ビットMIDによって16ビットのSSNを置き換える、FORWARD-TSNチャンクと類似しています。"
    },
    {
      "indent": 3,
      "text": "Support for the I-FORWARD-TSN chunk is negotiated during the SCTP association setup via the Supported Extensions Parameter, as defined in [RFC5061]. The partial reliability extension is negotiated and can be used in combination with user message interleaving only if both endpoints indicated their support of user message interleaving and the I-FORWARD-TSN chunk.",
      "ja": "[RFC5061]で定義されているI-FORWARD-TSNチャンクのサポートは、サポートされている拡張機能パラメータを経由してSCTPアソシエーションのセットアップ中にネゴシエートされます。部分的な信頼性拡張がネゴシエートされ、両方のエンドポイントがユーザメッセージインターリーブ及びI-FORWARD-TSNチャンクの彼らのサポートを示す場合にのみ、インタリーブユーザメッセージと組み合わせて使用​​することができます。"
    },
    {
      "indent": 3,
      "text": "The FORWARD-TSN chunk MUST be used in combination with the DATA chunk and MUST NOT be used in combination with the I-DATA chunk. The I-FORWARD-TSN chunk MUST be used in combination with the I-DATA chunk and MUST NOT be used in combination with the DATA chunk.",
      "ja": "FORWARD-TSNチャンクは、データチャンクと組み合わせて使用​​する必要があり、I-DATAチャンクと組み合わせて使用​​してはいけません。 I-FORWARD-TSNチャンクは、I-DATAチャンクと組み合わせて使用​​して、データチャンクと組み合わせて使用​​してはいけません。"
    },
    {
      "indent": 3,
      "text": "If I-FORWARD-TSN support has been negotiated for an association, the reception of a FORWARD-TSN chunk is a violation of the above rules and therefore the receiver of the FORWARD-TSN chunk MUST abort the association by sending an ABORT chunk. The ABORT chunk MAY include the 'Protocol Violation' error cause. The same applies if I-FORWARD-TSN support has not been negotiated for an association and a FORWARD-TSN chunk is received.",
      "ja": "I-FORWARD-TSNサポートはアソシエーションのために交渉されている場合は、FORWARD-TSNチャンクの受信は、上記の規則の違反であり、したがって、FORWARD-TSNチャンクの受信機は、ABORTチャンクを送信することにより、関連付けを中止しなければなりません。 ABORTチャンクは「プロトコル違反」というエラー原因を含むかもしれません。 I-FORWARD-TSNサポートは協会のために交渉されていないとFORWARD-TSNチャンクを受信した場合も同様です。"
    },
    {
      "indent": 0,
      "text": "2.3.2. SCTP Stream Reconfiguration Extension",
      "section_title": true,
      "ja": "2.3.2.  SCTPストリームの再拡張"
    },
    {
      "indent": 3,
      "text": "When an association resets the SSN using the SCTP extension defined in [RFC6525], the two counters (one for the ordered messages, one for the unordered messages) used for the MIDs MUST be reset to 0.",
      "ja": "関連付けが[RFC6525]で定義されたSCTP拡張を使用して、SSNをリセットすると、MIDのために使用される2つのカウンタ（順序付けられたメッセージのための1つの、順序付けられていないメッセージのための1つ）が0にリセットされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since most schedulers, especially all schedulers supporting user message interleaving, require late TSN assignment, it should be noted that the implementation of [RFC6525] needs to handle this.",
      "ja": "ほとんどのスケジューラは、特にユーザメッセージのインターリーブをサポートしているすべてのスケジューラが、後半TSNの割り当てを必要とするので、[RFC6525]の実装がこれを処理する必要があることに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "3. Stream Schedulers",
      "section_title": true,
      "ja": "3.ストリームスケジューラ"
    },
    {
      "indent": 3,
      "text": "This section defines several stream schedulers. The stream schedulers may behave differently depending on whether or not user message interleaving has been negotiated for the association. An implementation MAY implement any subset of them. If the implementation is used for WebRTC data channels, as specified in [DATA-CHAN], it MUST implement the Weighted Fair Queueing Scheduler defined in Section 3.6.",
      "ja": "このセクションでは、いくつかのストリームスケジューラを定義します。ストリームスケジューラは、ユーザ・メッセージ・インターリービングは、アソシエーションのために交渉されたか否かに応じて異なる動作をすることができます。実装はそれらの任意のサブセットを実装してもよいです。実装はのWebRTCデータチャネルに使用される場合、[DATA-CHAN]で指定されるように、それはセクション3.6で定義された均等化キューイング・スケジューラを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The selection of the stream scheduler is done at the sender side. There is no mechanism provided for signaling the stream scheduler being used to the receiver side or even for letting the receiver side influence the selection of the stream scheduler used at the sender side.",
      "ja": "ストリームスケジューラの選択は、送信側で行われます。受信側に、あるいは受信側が送信側で使用されるストリーム・スケジューラの選択に影響させるために使用されるストリームスケジューラをシグナリングするために設けられメカニズムはありません。"
    },
    {
      "indent": 0,
      "text": "3.1. First-Come, First-Served Scheduler (SCTP_SS_FCFS)",
      "section_title": true,
      "ja": "3.1. 先着順スケジューラ（SCTP_SS_FCFS）"
    },
    {
      "indent": 3,
      "text": "The simple first-come, first-served scheduler of user messages is used. It just passes through the messages in the order in which they have been delivered by the application. No modification of the order is done at all. The usage of user message interleaving does not affect the sending of the chunks, except that I-DATA chunks are used instead of DATA chunks.",
      "ja": "ユーザメッセージの簡単な先着順スケジューラが使用されています。それはちょうど彼らがアプリケーションによって提供された順序でメッセージを通過します。オーダーの修正は一切行われません。ユーザメッセージのインターリーブの使用量はI-DATAチャンクではなくDATAチャンクの使用されていることを除いて、チャンクの送信には影響を与えません。"
    },
    {
      "indent": 0,
      "text": "3.2. Round-Robin Scheduler (SCTP_SS_RR)",
      "section_title": true,
      "ja": "3.2. ラウンドロビンスケジューラ（SCTP_SS_RR）"
    },
    {
      "indent": 3,
      "text": "When not interleaving user messages, this scheduler provides a fair scheduling based on the number of user messages by cycling around non-empty stream queues. When interleaving user messages, this scheduler provides a fair scheduling based on the number of I-DATA chunks by cycling around non-empty stream queues.",
      "ja": "ユーザメッセージをインターリーブしない場合、このスケジューラは空でないストリームキューの周りに循環することによって、ユーザメッセージの数に基づいて公平なスケジューリングを提供します。ユーザメッセージをインタリーブすると、このスケジューラは空でないストリームキューの周りに循環させることによってI-DATAチャンクの数に基づいて、公平なスケジューリングを提供します。"
    },
    {
      "indent": 0,
      "text": "3.3. Round-Robin Scheduler per Packet (SCTP_SS_RR_PKT)",
      "section_title": true,
      "ja": "3.3. パケットごとのラウンドロビンスケジューラ（SCTP_SS_RR_PKT）"
    },
    {
      "indent": 3,
      "text": "This is a round-robin scheduler, which only switches streams when starting to fill a new packet. It bundles only DATA or I-DATA chunks referring to the same stream in a packet. This scheduler minimizes head-of-line blocking when a packet is lost because only a single stream is affected.",
      "ja": "これは、新しいパケットを埋めるために始めたときにのみ、ストリームを切り替えラウンドロビンスケジューラ、です。これは、パケット内の同じストリームを参照するデータのみまたはI-DATAチャンクをバンドルしています。唯一の単一ストリームが影響を受けるため、パケットが失われたときに、このスケジューラは、ヘッドオブラインブロッキングを最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Priority-Based Scheduler (SCTP_SS_PRIO)",
      "section_title": true,
      "ja": "3.4. 優先度ベースのスケジューラ（SCTP_SS_PRIO）"
    },
    {
      "indent": 3,
      "text": "Scheduling of user messages with strict priorities is used. The priority is configurable per outgoing SCTP stream. Streams having a higher priority will be scheduled first and when multiple streams have the same priority, the scheduling between them is implementation dependent. When the scheduler interleaves user messages, the sending of large, lower-priority user messages will not delay the sending of higher-priority user messages.",
      "ja": "厳格な優先順位を持つユーザメッセージのスケジューリングが使用されています。優先順位は、発信SCTPストリームごとに設定可能です。優先順位の高いストリームが最初にスケジュールし、複数のストリームが同じ優先順位を持つ場合、それらの間のスケジューリングは実装に依存します。スケジューラは、ユーザーのメッセージをインタリーブすると、大規模な、優先順位の低いユーザメッセージの送信は、優先度の高いユーザーのメッセージの送信を遅らせることはありません。"
    },
    {
      "indent": 0,
      "text": "3.5. Fair Capacity Scheduler (SCTP_SS_FC)",
      "section_title": true,
      "ja": "3.5. フェアキャパシティスケジューラ（SCTP_SS_FC）"
    },
    {
      "indent": 3,
      "text": "A fair capacity distribution between the streams is used. This scheduler considers the lengths of the messages of each stream and schedules them in a specific way to maintain an equal capacity for all streams. The details are implementation dependent. interleaving user messages allows for a better realization of the fair capacity usage.",
      "ja": "ストリーム間の公正な容量の分布が使用されます。このスケジューラは、すべてのストリームに対して等しい容量を維持するために特定の方法で各ストリームおよびスケジュールそれらのメッセージの長さを考慮する。詳細は実装に依存しています。ユーザメッセージをインターリーブすることは、公正使用容量をより良く実現することができます。"
    },
    {
      "indent": 0,
      "text": "3.6. Weighted Fair Queueing Scheduler (SCTP_SS_WFQ)",
      "section_title": true,
      "ja": "3.6. 均等化キューイングスケジューラ（SCTP_SS_WFQ）"
    },
    {
      "indent": 3,
      "text": "A Weighted Fair Queueing scheduler between the streams is used. The weight is configurable per outgoing SCTP stream. This scheduler considers the lengths of the messages of each stream and schedules them in a specific way to use the capacity according to the given weights. If the weight of stream S1 is n times the weight of stream S2, the scheduler should assign to stream S1 n times the capacity it assigns to stream S2. The details are implementation dependent. Interleaving user messages allows for a better realization of the capacity usage according to the given weights.",
      "ja": "ストリーム間の均等化キューイングスケジューラが使用されています。重量は、発信SCTPストリームごとに設定可能です。このスケジューラは、所定の重みに応じて容量を使用するための特定の方法で各ストリームおよびスケジュールそれらのメッセージの長さを考慮する。ストリームS1の重量はストリームS2のn倍重量である場合、スケジューラは、S1 n回にそれがS2をストリームに割り当てる能力をストリーミングするために割り当てる必要があります。詳細は実装に依存しています。ユーザメッセージをインタリーブすることは、所与の重みに応じて容量の使用をより良く実現することが可能になります。"
    },
    {
      "indent": 3,
      "text": "This scheduler, in combination with user message interleaving, is used for WebRTC data channels, as specified in [DATA-CHAN].",
      "ja": "[DATA-CHAN]で指定され、このスケジューラは、ユーザ・メッセージ・インターリーブと組み合わせて、のWebRTCデータチャネルのために使用されます。"
    },
    {
      "indent": 0,
      "text": "4. Socket API Considerations",
      "section_title": true,
      "ja": "4.ソケットAPIの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes how the socket API defined in [RFC6458] is extended to allow applications to use the extension described in this document.",
      "ja": "このセクションでは、[RFC6458]で定義されたソケットAPIは、アプリケーションが、この文書で説明する拡張機能を使用することができるように拡張される方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Please note that this section is informational only.",
      "ja": "このセクションは情報提供のみであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.1. Exposure of the Stream Sequence Number (SSN)",
      "section_title": true,
      "ja": "4.1. ストリームシーケンス番号（SSN）の暴露"
    },
    {
      "indent": 3,
      "text": "The socket API defined in [RFC6458] defines several structures in which the SSN of a received user message is exposed to the application. The list of these structures includes:",
      "ja": "[RFC6458]で定義されたソケットAPIは、受信したユーザメッセージのSSNは、アプリケーションに露出されたいくつかの構造を定義します。これらの構造のリストが含まれています："
    },
    {
      "indent": 3,
      "text": "struct sctp_sndrcvinfo Specified in Section 5.3.2 of [RFC6458] and marked as deprecated.",
      "ja": "構造体にsctp_sndrcvinfo [RFC6458]のセクション5.3.2に指定され、非推奨としてマーク。"
    },
    {
      "indent": 3,
      "text": "struct sctp_extrcvinfo Specified in Section 5.3.3 of [RFC6458] and marked as deprecated.",
      "ja": "構造体sctp_extrcvinfo [RFC6458]のセクション5.3.3に指定され、非推奨としてマーク。"
    },
    {
      "indent": 3,
      "text": "struct sctp_rcvinfo Specified in Section 5.3.5 of [RFC6458].",
      "ja": "[RFC6458]のセクション5.3.5で指定された構造体sctp_rcvinfo。"
    },
    {
      "indent": 3,
      "text": "If user message interleaving is used, the lower-order 16 bits of the MID are used as the SSN when filling out these structures.",
      "ja": "ユーザ・メッセージ・インターリービングが使用される場合、これらの構造を充填する際、MIDの下位16ビットはSSNとして使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2. SCTP_ASSOC_CHANGE Notification",
      "section_title": true,
      "ja": "4.2.  SCTP_ASSOC_CHANGE通知"
    },
    {
      "indent": 3,
      "text": "When an SCTP_ASSOC_CHANGE notification (specified in Section 6.1.1 of [RFC6458]) is delivered indicating a sac_state of SCTP_COMM_UP or SCTP_RESTART for an SCTP association where both peers support the I-DATA chunk, SCTP_ASSOC_SUPPORTS_INTERLEAVING should be listed in the sac_info field.",
      "ja": "場合（[RFC6458]のセクション6.1.1で指定された）SCTP_ASSOC_CHANGE通知は、両方のピアがI-DATAチャンクをサポートし、SCTP_ASSOC_SUPPORTS_INTERLEAVINGはsac_infoフィールドにリストされるべきSCTPアソシエーションのためSCTP_COMM_UP又はSCTP_RESTARTのsac_stateを示す送達されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Socket Options",
      "section_title": true,
      "ja": "4.3. ソケットオプション"
    },
    {
      "indent": 3,
      "text": "+-----------------------------+-------------------------+-----+-----+\n| Option Name                 | Data Type               | Get | Set |\n+-----------------------------+-------------------------+-----+-----+\n| SCTP_INTERLEAVING_SUPPORTED | struct sctp_assoc_value |  X  |  X  |\n| SCTP_STREAM_SCHEDULER       | struct sctp_assoc_value |  X  |  X  |\n| SCTP_STREAM_SCHEDULER_VALUE | struct                  |  X  |  X  |\n|                             | sctp_stream_value       |     |     |\n+-----------------------------+-------------------------+-----+-----+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.1. Enable or Disable the Support of User Message Interleaving (SCTP_INTERLEAVING_SUPPORTED)",
      "ja": "4.3.1. ユーザー・メッセージインターリーブ（SCTP_INTERLEAVING_SUPPORTED）のサポートを有効または無効にします"
    },
    {
      "indent": 3,
      "text": "This socket option allows the enabling or disabling of the negotiation of user message interleaving support for future associations. For existing associations, it allows for querying whether or not user message interleaving support was negotiated on a particular association.",
      "ja": "このソケットオプションを有効または将来の団体のサポートをインターリーブユーザメッセージの交渉の無効化ができます。既存の関連付けのためには、ユーザメッセージインターリーブサポートは、特定のアソシエーションにネゴシエートされたか否かを問い合わせることを可能にします。"
    },
    {
      "indent": 3,
      "text": "This socket option uses IPPROTO_SCTP as its level and SCTP_INTERLEAVING_SUPPORTED as its name. It can be used with getsockopt() and setsockopt(). The socket option value uses the following structure defined in [RFC6458]:",
      "ja": "このソケットオプションは、その名のようにそのレベルとSCTP_INTERLEAVING_SUPPORTEDとしてIPPROTO_SCTPを使用しています。それはgetsockoptの（）とのsetsockopt（）で使用することができます。ソケットオプションの値は、[RFC6458]で定義され、以下の構造を使用します。"
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. The special sctp_assoc_t SCTP_FUTURE_ASSOC can also be used; it is an error to use SCTP_{CURRENT|ALL}_ASSOC in assoc_id.",
      "ja": "assoc_id：このパラメータは、1対1スタイルソケットでは無視されます。 1対多スタイルソケットの場合、このパラメータは、ユーザーがアクションを実行している際にアソシエーション示します。特別sctp_assoc_tのSCTP_FUTURE_ASSOCも使用することができます。 assoc_idで_ASSOC | SCTP_ {ALL CURRENT}を使用するとエラーになります。"
    },
    {
      "indent": 3,
      "text": "assoc_value: A non-zero value encodes the enabling of user message interleaving, whereas a value of zero encodes the disabling of user message interleaving.",
      "ja": "assoc_value：非ゼロ値は、ゼロの値は、ユーザ・メッセージ・インターリービングの禁止をコードに対し、インターリーブユーザメッセージの有効化コード。"
    },
    {
      "indent": 3,
      "text": "sctp_opt_info() needs to be extended to support SCTP_INTERLEAVING_SUPPORTED.",
      "ja": "sctp_opt_infoは（）SCTP_INTERLEAVING_SUPPORTEDをサポートするように拡張する必要があります。"
    },
    {
      "indent": 3,
      "text": "An application using user message interleaving should also set the fragment interleave level to 2 by using the SCTP_FRAGMENT_INTERLEAVE socket option specified in Section 8.1.20 of [RFC6458]. This allows the interleaving of user messages from different streams. Please note that it does not allow the interleaving of user messages (ordered or unordered) on the same stream. Failure to set this option can possibly lead to application deadlock. Some implementations might therefore put some restrictions on setting combinations of these values. Setting the interleaving level to at least 2 before enabling the negotiation of user message interleaving should work on all platforms. Since the default fragment interleave level is not 2, user message interleaving is disabled per default.",
      "ja": "インターリーブアプリケーション使用してユーザメッセージは、[RFC6458]のセクション8.1.20に指定SCTP_FRAGMENT_INTERLEAVEソケットオプションを使用して2フラグメントインターリーブレベルを設定しなければなりません。これは、異なるストリームからのユーザメッセージのインターリーブすることができます。それは同じストリーム上のユーザ・メッセージ（注文または順不同）のインターリーブすることはできませんのでご注意ください。このオプションを設定しないと、おそらくアプリケーションのデッドロックにつながることができます。一部の実装では、したがって、これらの値の組み合わせを設定するにはいくつかの制限を置くかもしれません。ユーザメッセージのインターリーブの交渉を有効にする前に少なくとも2にインターリーブレベルを設定すると、すべてのプラットフォーム上で動作するはずです。デフォルトフラグメントインターリーブレベルが2ではないので、ユーザ・メッセージ・インターリービングはデフォルトごとに無効にされます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Get or Set the Stream Scheduler (SCTP_STREAM_SCHEDULER)",
      "section_title": true,
      "ja": "4.3.2. ストリームスケジューラ（SCTP_STREAM_SCHEDULER）を取得または設定します"
    },
    {
      "indent": 3,
      "text": "A stream scheduler can be selected with the SCTP_STREAM_SCHEDULER option for setsockopt(). The struct sctp_assoc_value is used to specify the association for which the scheduler should be changed and the value of the desired algorithm.",
      "ja": "ストリームスケジューラは）（のsetsockopt用SCTP_STREAM_SCHEDULERオプションで選択することができます。構造体sctp_assoc_valueはスケジューラを変更すべき協会、所望アルゴリズムの値を指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The definition of struct sctp_assoc_value is the same as in [RFC6458]:",
      "ja": "構造体sctp_assoc_valueの定義は[RFC6458]と同じです。"
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assoc_id: Holds the identifier of the association for which the scheduler should be changed. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used. This parameter is ignored for one-to-one style sockets.",
      "ja": "assoc_idは：スケジューラを変更する必要のある関連の識別子を保持します。特別SCTP_ {FUTURE | CURRENT | ALL} _ASSOCも使用することができます。このパラメータは、1対1のスタイルのソケットでは無視されます。"
    },
    {
      "indent": 3,
      "text": "assoc_value: This specifies which scheduler is used. The following constants can be used:",
      "ja": "assoc_value：これは、使用されているスケジューラを指定します。次の定数を使用することができます。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_DEFAULT: The default scheduler used by the SCTP implementation. Typical values are SCTP_SS_FCFS or SCTP_SS_RR.",
      "ja": "SCTP_SS_DEFAULT：SCTPの実装で使用されるデフォルトのスケジューラ。典型的な値はSCTP_SS_FCFSまたはSCTP_SS_RRです。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_FCFS: Use the scheduler specified in Section 3.1.",
      "ja": "SCTP_SS_FCFS：3.1節で指定されたスケジューラを使用してください。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_RR: Use the scheduler specified in Section 3.2.",
      "ja": "SCTP_SS_RR：3.2節で指定されたスケジューラを使用してください。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_RR_PKT: Use the scheduler specified in Section 3.3.",
      "ja": "SCTP_SS_RR_PKT：3.3節で指定されたスケジューラを使用してください。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_PRIO: Use the scheduler specified in Section 3.4. The priority can be assigned with the sctp_stream_value struct. The higher the assigned value, the lower the priority. That is, the default value 0 is the highest priority, and therefore the default scheduling will be used if no priorities have been assigned.",
      "ja": "SCTP_SS_PRIO：3.4節で指定されたスケジューラを使用してください。優先順位はsctp_stream_value構造体を割り当てることができます。優先順位が低いほど、割り当てられた値より高いです。つまり、デフォルト値0が最優先であり、何の優先順位が割り当てられていない場合ので、デフォルトのスケジュールが使用されます。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_FB: Use the scheduler specified in Section 3.5.",
      "ja": "SCTP_SS_FB：3.5節で指定されたスケジューラを使用してください。"
    },
    {
      "indent": 6,
      "text": "SCTP_SS_WFQ: Use the scheduler specified in Section 3.6. The weight can be assigned with the sctp_stream_value struct.",
      "ja": "SCTP_SS_WFQ：セクション3.6で指定されたスケジューラを使用してください。重量はsctp_stream_value構造体を割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "sctp_opt_info() needs to be extended to support SCTP_STREAM_SCHEDULER.",
      "ja": "sctp_opt_infoは（）SCTP_STREAM_SCHEDULERをサポートするように拡張する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Get or Set the Stream Scheduler Parameter (SCTP_STREAM_SCHEDULER_VALUE)",
      "ja": "4.3.3. ストリームスケジューラパラメータ（SCTP_STREAM_SCHEDULER_VALUE）を取得または設定します"
    },
    {
      "indent": 3,
      "text": "Some schedulers require additional information to be set for individual streams as shown in the following table:",
      "ja": "いくつかのスケジューラは、次の表に示すように、個々のストリームに設定する追加の情報を必要とします。"
    },
    {
      "indent": 19,
      "text": "+-----------------+-----------------+\n| Name            | Per-Stream Info |\n+-----------------+-----------------+\n| SCTP_SS_DEFAULT |       n/a       |\n| SCTP_SS_FCFS    |        no       |\n| SCTP_SS_RR      |        no       |\n| SCTP_SS_RR_PKT  |        no       |\n| SCTP_SS_PRIO    |       yes       |\n| SCTP_SS_FB      |        no       |\n| SCTP_SS_WFQ     |       yes       |\n+-----------------+-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This is achieved with the SCTP_STREAM_SCHEDULER_VALUE option and the corresponding struct sctp_stream_value. The definition of struct sctp_stream_value is as follows:",
      "ja": "これはSCTP_STREAM_SCHEDULER_VALUEオプションと対応する構造体sctp_stream_valueで達成されます。次のように構造体sctp_stream_valueの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "struct sctp_stream_value {\n  sctp_assoc_t assoc_id;\n  uint16_t stream_id;\n  uint16_t stream_value;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assoc_id: Holds the identifier of the association for which the scheduler should be changed. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used. This parameter is ignored for one-to-one style sockets.",
      "ja": "assoc_idは：スケジューラを変更する必要のある関連の識別子を保持します。特別SCTP_ {FUTURE | CURRENT | ALL} _ASSOCも使用することができます。このパラメータは、1対1のスタイルのソケットでは無視されます。"
    },
    {
      "indent": 3,
      "text": "stream_id: Holds the identifier of the stream for which additional information has to be provided.",
      "ja": "stream_idは：追加の情報が提供されなければならないため、ストリームの識別子を保持します。"
    },
    {
      "indent": 3,
      "text": "stream_value: The meaning of this field depends on the scheduler specified. It is ignored when the scheduler does not need additional information.",
      "ja": "stream_value：このフィールドの意味は、指定したスケジュールに依存します。スケジューラは、追加情報を必要としない場合には無視されます。"
    },
    {
      "indent": 3,
      "text": "sctp_opt_info() needs to be extended to support SCTP_STREAM_SCHEDULER_VALUE.",
      "ja": "sctp_opt_infoは（）SCTP_STREAM_SCHEDULER_VALUEをサポートするように拡張する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Explicit EOR Marking",
      "section_title": true,
      "ja": "4.4. 明示的なEORマーキング"
    },
    {
      "indent": 3,
      "text": "Using explicit End of Record (EOR) marking for an SCTP association supporting user message interleaving allows the user to interleave the sending of user messages on different streams.",
      "ja": "ユーザ・メッセージ・インターリービングをサポートするSCTPアソシエーションマーキングレコード（EOR）の明示的なエンドを使用することにより、ユーザは異なるストリームにユーザメッセージの送信をインタリーブすることを可能にします。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Two new chunk types have been assigned by IANA.",
      "ja": "二つの新しいチャンクタイプは、IANAによって割り当てられています。"
    },
    {
      "indent": 0,
      "text": "5.1. I-DATA Chunk",
      "section_title": true,
      "ja": "5.1.  I-DATAチャンク"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the chunk type for this chunk from the pool of chunks with the upper two bits set to '01'. This appears in the \"Chunk Types\" registry for SCTP as follows:",
      "ja": "IANAは「01」に設定上位2ビットとチャンクのプールからこのチャンクのチャンクタイプを割り当てました。これは次のようにSCTPのための「チャンクタイプ」レジストリに表示されます。"
    },
    {
      "indent": 3,
      "text": "+----------+--------------------------------------------+-----------+\n| ID Value | Chunk Type                                 | Reference |\n+----------+--------------------------------------------+-----------+\n| 64       | Payload Data supporting Interleaving       | RFC 8260  |\n|          | (I-DATA)                                   |           |\n+----------+--------------------------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The registration table (as defined in [RFC6096]) for the chunk flags of this chunk type is initially as follows:",
      "ja": "次のように、このチャンクタイプのチャンクフラグの登録テーブルは（[RFC6096]で定義されるように）、最初です。"
    },
    {
      "indent": 12,
      "text": "+------------------+-----------------+-----------+\n| Chunk Flag Value | Chunk Flag Name | Reference |\n+------------------+-----------------+-----------+\n| 0x01             | E bit           | RFC 8260  |\n| 0x02             | B bit           | RFC 8260  |\n| 0x04             | U bit           | RFC 8260  |\n| 0x08             | I bit           | RFC 8260  |\n| 0x10             | Unassigned      |           |\n| 0x20             | Unassigned      |           |\n| 0x40             | Unassigned      |           |\n| 0x80             | Unassigned      |           |\n+------------------+-----------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.2. I-FORWARD-TSN Chunk",
      "section_title": true,
      "ja": "5.2.  I-FORWARD-TSNチャンク"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the chunk type for this chunk from the pool of chunks with the upper two bits set to '11'. This appears in the \"Chunk Types\" registry for SCTP as follows:",
      "ja": "IANAは「11」に設定上位2ビットとチャンクのプールからこのチャンクのチャンクタイプを割り当てました。これは次のようにSCTPのための「チャンクタイプ」レジストリに表示されます。"
    },
    {
      "indent": 17,
      "text": "+----------+---------------+-----------+\n| ID Value | Chunk Type    | Reference |\n+----------+---------------+-----------+\n| 194      | I-FORWARD-TSN | RFC 8260  |\n+----------+---------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The registration table (as defined in [RFC6096]) for the chunk flags of this chunk type is initially empty.",
      "ja": "このチャンクタイプのチャンクフラグの登録テーブルは（[RFC6096]で定義されるように）最初は空です。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not add any additional security considerations in addition to the ones given in [RFC4960] and [RFC6458].",
      "ja": "この文書では、[RFC4960]と[RFC6458]で与えられたものに加えて、追加のセキュリティ上の考慮事項を追加しません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the application has to consent that it is willing to do the more complex reassembly support required for user message interleaving. When doing so, an application has to provide a reassembly buffer for each incoming stream. It has to protect itself against these buffers taking too many resources. If user message interleaving is not used, only a single reassembly buffer needs to be provided for each association. But the application has to protect itself for excessive resource usages there too.",
      "ja": "アプリケーションがユーザメッセージのインターリーブのために必要な、より複雑な再構築のサポートをしても構わないと思っていることを承知していることに留意すべきです。その際、アプリケーションは、各入力ストリームのためのリアセンブリ・バッファを提供しなければなりません。それはあまりにも多くのリソースを取って、これらのバッファに対して自身を保護しなければなりません。ユーザ・メッセージ・インターリービングを使用しない場合、単一の再構成バッファは、各アソシエーションのために提供される必要があります。しかし、アプリケーションがあまりにも過度のリソース使用状況のために自分自身を保護しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, DOI 10.17487/RFC1982, August 1996, <https://www.rfc-editor.org/info/rfc1982>.",
      "ja": "[RFC1982]エルツ、R.とR.ブッシュ大統領、 \"シリアル番号演算\"、RFC 1982、DOI 10.17487 / RFC1982、1996年8月、<https://www.rfc-editor.org/info/rfc1982>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, \"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension\", RFC 3758, DOI 10.17487/RFC3758, May 2004, <https://www.rfc-editor.org/info/rfc3758>.",
      "ja": "[RFC3758]スチュワート、R.、Ramalho、M.、謝、Q.、Tuexen、M.、およびP.コンラッド、 \"ストリーム制御伝送プロトコル（SCTP）部分信頼拡張子\"、RFC 3758、DOI 10.17487 / RFC3758、月2004年、<https://www.rfc-editor.org/info/rfc3758>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <https://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960]スチュワート、R.、エド。、 \"ストリーム制御伝送プロトコル\"、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<https://www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC5061] Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M. Kozuka, \"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration\", RFC 5061, DOI 10.17487/RFC5061, September 2007, <https://www.rfc-editor.org/info/rfc5061>.",
      "ja": "[RFC5061]スチュワート、R.、謝、Q.、Tuexen、M.、丸山、S.、およびM.小塚、 \"ストリーム制御伝送プロトコル（SCTP）動的アドレス再構成\"、RFC 5061、DOI 10.17487 / RFC5061、9月2007年、<https://www.rfc-editor.org/info/rfc5061>。"
    },
    {
      "indent": 3,
      "text": "[RFC6096] Tuexen, M. and R. Stewart, \"Stream Control Transmission Protocol (SCTP) Chunk Flags Registration\", RFC 6096, DOI 10.17487/RFC6096, January 2011, <https://www.rfc-editor.org/info/rfc6096>.",
      "ja": "[RFC6096] Tuexen、M.およびR.スチュワート、 \"ストリーム制御伝送プロトコル（SCTP）チャンクフラグ登録\"、RFC 6096、DOI 10.17487 / RFC6096、2011年1月、<https://www.rfc-editor.org/info / rfc6096>。"
    },
    {
      "indent": 3,
      "text": "[RFC6525] Stewart, R., Tuexen, M., and P. Lei, \"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration\", RFC 6525, DOI 10.17487/RFC6525, February 2012, <https://www.rfc-editor.org/info/rfc6525>.",
      "ja": "[RFC6525]スチュワート、R.、Tuexen、M.、およびP.レイ、 \"ストリーム制御伝送プロトコル（SCTP）ストリーム再構成\"、RFC 6525、DOI 10.17487 / RFC6525、2012年2月、<HTTPS：//www.rfc- editor.org/info/rfc6525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7053] Tuexen, M., Ruengeler, I., and R. Stewart, \"SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol\", RFC 7053, DOI 10.17487/RFC7053, November 2013, <https://www.rfc-editor.org/info/rfc7053>.",
      "ja": "[RFC7053] Tuexen、M.、Ruengeler、I.、およびR.スチュワート、 \"SACK-すぐにストリーム制御伝送プロトコルのための拡張\"、RFC 7053、DOI 10.17487 / RFC7053、2013年11月、<HTTPS：//www.rfc -editor.org/info/rfc7053>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[DATA-CHAN] Jesup, R., Loreto, S., and M. Tuexen, \"WebRTC Data Channels\", Work in Progress, draft-ietf-rtcweb-data-channel-13, January 2015.",
      "ja": "[DATA-CHAN]ジェサップ、R.、ロレート、S.、およびM. Tuexen、 \"のWebRTCデータ・チャンネル\"、進行中で働いて、ドラフトIETF-rtcwebデータチャネル-13、2015年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, \"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)\", RFC 6458, DOI 10.17487/RFC6458, December 2011, <https://www.rfc-editor.org/info/rfc6458>.",
      "ja": "[RFC6458]スチュワート、R.、Tuexen、M.、プーン、K.、レイ、P.、およびV. Yasevich、DOI 10.17487 / RFC6458、RFC 6458、 \"ストリーム制御伝送プロトコル（SCTP）のためのソケットAPIの拡張機能\" 、2011年12月、<https://www.rfc-editor.org/info/rfc6458>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Benoit Claise, Julian Cordes, Spencer Dawkins, Gorry Fairhurst, Lennart Grahl, Christer Holmberg, Mirja Kuehlewind, Marcelo Ricardo Leitner, Karen E. Egede Nielsen, Maksim Proshin, Eric Rescorla, Irene Ruengeler, Felix Weinrank, Michael Welzl, Magnus Westerlund, and Lixia Zhang for their invaluable comments.",
      "ja": "著者はブノワClaise、ジュリアン・コルド、スペンサードーキンスGorry Fairhurst、レナートGrahl、クリステルHolmbergの、Mirja Kuehlewind、マルセロリカルド・ライトナー、カレンE. Egedeニールセン、マクシムProshin、エリックレスコラ、アイリーンRuengeler、フェリックスWeinrank、マイケルWelzl感謝したいです彼らの貴重なコメントについて、マグヌスウェスター、およびLixiaチャン。"
    },
    {
      "indent": 3,
      "text": "This work has received funding from the European Union's Horizon 2020 research and innovation program under grant agreement No. 644334 (NEAT). The views expressed are solely those of the authors.",
      "ja": "この作品は、付与契約番号644334（NEAT）の下で、欧州連合（EU）のホライゾン2020年の研究と技術革新プログラムから資金提供を受けています。見解はもっぱら著者のものです。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Netflix, Inc. Chapin, SC 29036 United States of America",
      "ja": "ランドールR.スチュワートネットフリックス社アメリカのチャピン、SC 29036米国"
    },
    {
      "indent": 3,
      "text": "Email: randall@lakerest.net",
      "ja": "メール：randall@lakerest.net"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany",
      "ja": "応用科学Stegerwaldstrasse 39 48565シュタインフルトドイツのマイケルTuexenミュンスター大学"
    },
    {
      "indent": 3,
      "text": "Email: tuexen@fh-muenster.de",
      "ja": "メール：tuexen@fh-muenster.de"
    },
    {
      "indent": 3,
      "text": "Salvatore Loreto Ericsson Torshamnsgatan 21 164 80 Stockholm Sweden",
      "ja": "サルヴァトーレ・ロレートエリクソンTorshamnsgatan 21 164 80ストックホルムスウェーデン"
    },
    {
      "indent": 3,
      "text": "Email: Salvatore.Loreto@ericsson.com",
      "ja": "メール：Salvatore.Loreto@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Robin Seggelmann Metafinanz Informationssysteme GmbH Leopoldstrasse 146 80804 Muenchen Germany",
      "ja": "ロビンSeggelmann metafinanz INFORMATIONSSYSTEME社Leopoldstrasse 146 80804ミュンヘンドイツ"
    },
    {
      "indent": 3,
      "text": "Email: rfc@robin-seggelmann.com",
      "ja": "メール：rfc@robin-seggelmann.com"
    }
  ]
}