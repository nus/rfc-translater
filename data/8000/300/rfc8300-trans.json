{
  "title": {
    "text": "RFC 8300 - Network Service Header (NSH)",
    "ja": "RFC 8300 - ネットワークサービスヘッダー（NSH）"
  },
  "number": 8300,
  "created_at": "2019-10-29 21:23:58.047462+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     P. Quinn, Ed.\nRequest for Comments: 8300                                         Cisco\nCategory: Standards Track                                  U. Elzur, Ed.\nISSN: 2070-1721                                                    Intel\n                                                       C. Pignataro, Ed.\n                                                                   Cisco\n                                                            January 2018",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Network Service Header (NSH)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a Network Service Header (NSH) imposed on packets or frames to realize Service Function Paths (SFPs). The NSH also provides a mechanism for metadata exchange along the instantiated service paths. The NSH is the Service Function Chaining (SFC) encapsulation required to support the SFC architecture (defined in RFC 7665).",
      "ja": "この文書では、ネットワークサービスヘッダー（NSH）は、サービス機能のパス（SFPを）実現するパケットまたはフレームに課さについて説明します。 NSHはまた、インスタンス化されたサービス経路に沿ってメタデータ交換のためのメカニズムを提供します。 NSHは、（RFC 7665で定義されている）SFCアーキテクチャをサポートするために必要なサービス機能の連鎖（SFC）カプセル化したものです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8300.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8300で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Applicability ..............................................4\n   1.2. Requirements Language ......................................4\n   1.3. Definition of Terms ........................................4\n   1.4. Problem Space ..............................................6\n   1.5. NSH-Based Service Chaining .................................6\n2. Network Service Header ..........................................7\n   2.1. Network Service Header Format ..............................7\n   2.2. NSH Base Header ............................................8\n   2.3. Service Path Header .......................................11\n   2.4. NSH MD Type 1 .............................................12\n   2.5. NSH MD Type 2 .............................................13\n        2.5.1. Optional Variable-Length Metadata ..................13\n3. NSH Actions ....................................................15\n4. NSH Transport Encapsulation ....................................16\n5. Fragmentation Considerations ...................................17\n6. Service Path Forwarding with NSH ...............................18\n   6.1. SFFs and Overlay Selection ................................18\n   6.2. Mapping the NSH to Network Topology .......................21\n   6.3. Service Plane Visibility ..................................21\n   6.4. Service Graphs ............................................22\n7. Policy Enforcement with NSH ....................................22\n   7.1. NSH Metadata and Policy Enforcement .......................22\n   7.2. Updating/Augmenting Metadata ..............................24\n   7.3. Service Path Identifier and Metadata ......................25\n8. Security Considerations ........................................26\n   8.1. NSH Security Considerations from Operators' Environments ..27\n   8.2. NSH Security Considerations from the SFC Architecture .....28\n        8.2.1. Integrity ..........................................29\n        8.2.2. Confidentiality ....................................31\n9. IANA Considerations ............................................32\n   9.1. NSH Parameters ............................................32\n        9.1.1. NSH Base Header Bits ...............................32\n        9.1.2. NSH Version ........................................32\n        9.1.3. NSH MD Types .......................................33\n        9.1.4. NSH MD Class .......................................33\n        9.1.5. NSH IETF-Assigned Optional Variable-Length\n               Metadata Types .....................................34\n        9.1.6. NSH Next Protocol ..................................35\n10. NSH-Related Codepoints ........................................35\n   10.1. NSH Ethertype ............................................35\n11. References ....................................................36\nAcknowledgments ...................................................38\nContributors ......................................................39\nAuthors' Addresses ................................................40",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Service Functions are widely deployed and essential in many networks. These Service Functions provide a range of features such as security, WAN acceleration, and server load balancing. Service Functions may be instantiated at different points in the network infrastructure such as the WAN, data center, and so forth.",
      "ja": "サービス機能は、広く多くのネットワークで展開し、必要不可欠です。これらのサービス機能は、セキュリティ、WANアクセラレーション、およびサーバーの負荷分散などの機能の範囲を提供します。サービス機能など、そのようなWAN、データセンターなどのネットワークインフラストラクチャ内の異なる点でインスタンス化することができます。"
    },
    {
      "indent": 3,
      "text": "Prior to development of the SFC architecture [RFC7665] and the protocol specified in this document, current Service Function deployment models have been relatively static and bound to topology for insertion and policy selection. Furthermore, they do not adapt well to elastic service environments enabled by virtualization.",
      "ja": "[RFC7665]この文書で指定されたプロトコルSFCアーキテクチャの開発に先立ち、現在のサービス機能の導入モデルを挿入し、政策選択のためのトポロジーに比較的静的およびバインドされています。さらに、彼らは、仮想化によって有効弾性サービス環境にうまく適応していません。"
    },
    {
      "indent": 3,
      "text": "New data-center network and cloud architectures require more flexible Service Function deployment models. Additionally, the transition to virtual platforms demands an agile service insertion model that supports dynamic and elastic service delivery. Specifically, the following functions are necessary:",
      "ja": "新データセンターのネットワークとクラウドのアーキテクチャは、より柔軟なサービス機能の導入モデルを必要とします。また、仮想プラットフォームへの移行は、動的弾性サービス配信をサポートアジャイルサービス挿入モデルを要求します。具体的には、以下の機能が必要です。"
    },
    {
      "indent": 3,
      "text": "1. The movement of Service Functions and application workloads in the network.",
      "ja": "ネットワークでのサービス機能とアプリケーション・ワークロードの1動き。"
    },
    {
      "indent": 3,
      "text": "2. The ability to easily bind service policy to granular information, such as per-subscriber state.",
      "ja": "2.容易にそのような単位の加入者状態として、粒状情報にサービスポリシーを結合する能力を。"
    },
    {
      "indent": 3,
      "text": "3. The capability to steer traffic to the requisite Service Function(s).",
      "ja": "3.必要なサービス機能（複数可）へのトラフィックを操縦する機能。"
    },
    {
      "indent": 3,
      "text": "This document, the Network Service Header (NSH) specification, defines a new data-plane protocol, which is an encapsulation for SFCs. The NSH is designed to encapsulate an original packet or frame and, in turn, be encapsulated by an outer transport encapsulation (which is used to deliver the NSH to NSH-aware network elements), as shown in Figure 1:",
      "ja": "この文書、ネットワークサービスヘッダ（NSH）仕様では、SFCのためのカプセル化され、新たなデータプレーンのプロトコルを定義します。 NSHは、元のパケットまたはフレームをカプセル化するために設計されており、図1に示すように順番に、（NSHアウェアネットワーク要素にNSHを送達するために使用される）は、外側輸送カプセル化によってカプセル化されます。"
    },
    {
      "indent": 21,
      "text": "+------------------------------+\n|    Transport Encapsulation   |\n+------------------------------+\n| Network Service Header (NSH) |\n+------------------------------+\n|    Original Packet / Frame   |\n+------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 1: Network Service Header Encapsulation",
      "ja": "図1：ネットワークサービスヘッダーのカプセル化"
    },
    {
      "indent": 3,
      "text": "The NSH is composed of the following elements:",
      "ja": "NSHは、次の要素で構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Service Function Path identification.",
      "section_title": true,
      "ja": "1.サービス機能パスの識別。"
    },
    {
      "indent": 3,
      "text": "2. Indication of location within a Service Function Path.",
      "section_title": true,
      "ja": "サービス機能パス内の位置の2指示。"
    },
    {
      "indent": 3,
      "text": "3. Optional, per-packet metadata (fixed-length or variable).",
      "section_title": true,
      "ja": "3.オプション、パケットごとのメタデータ（固定長または可変長）。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] provides an overview of a service chaining architecture that clearly defines the roles of the various elements and the scope of a SFC encapsulation. Figure 3 of [RFC7665] depicts the SFC architectural components after classification. The NSH is the SFC encapsulation referenced in [RFC7665].",
      "ja": "[RFC7665]は、明らかに、様々な要素の役割とSFCのカプセル化の範囲を定義するサービス連鎖アーキテクチャの概要を提供します。 [RFC7665]の図3は、分類後のSFCアーキテクチャ構成要素を示します。 NSHは[RFC7665]で参照SFCカプセル化です。"
    },
    {
      "indent": 0,
      "text": "1.1. Applicability",
      "section_title": true,
      "ja": "1.1。適用性"
    },
    {
      "indent": 3,
      "text": "The NSH is designed to be easy to implement across a range of devices, both physical and virtual, including hardware platforms.",
      "ja": "NSHは、ハードウェア・プラットフォームを含む、物理および仮想の両方のデバイス、の範囲で実施するのが容易であるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The intended scope of the NSH is for use within a single provider's operational domain. This deployment scope is deliberately constrained, as explained also in [RFC7665], and limited to a single network administrative domain. In this context, a \"domain\" is a set of network entities within a single administration. For example, a network administrative domain can include a single data center, or an overlay domain using virtual connections and tunnels. A corollary is that a network administrative domain has a well-defined perimeter.",
      "ja": "NSHの意図された範囲は、単一のプロバイダの運用ドメイン内で使用するためのものです。この展開範囲は故意[RFC7665]にも説明したように、制約、および単一ネットワーク管理ドメインに限られています。この文脈では、「ドメイン」とは、単一の管理内のネットワークエンティティのセットです。例えば、ネットワーク管理ドメインは、単一のデータセンタ、または仮想接続とトンネルを使用してオーバーレイ・ドメインを含むことができます。当然の結果は、ネットワーク管理ドメインは、明確に定義された境界線を有することです。"
    },
    {
      "indent": 3,
      "text": "An NSH-aware control plane is outside the scope of this document.",
      "ja": "NSH対応制御プレーンは、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Language",
      "section_title": true,
      "ja": "1.2。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "1.3. Definition of Terms",
      "section_title": true,
      "ja": "1.3。用語の定義"
    },
    {
      "indent": 3,
      "text": "Byte: All references to \"bytes\" in this document refer to 8-bit bytes, or octets.",
      "ja": "バイト：このドキュメントの「バイト」へのすべての参照は、8ビットバイト、またはオクテットを参照してください。"
    },
    {
      "indent": 3,
      "text": "Classification: Defined in [RFC7665].",
      "ja": "分類：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Classifier: Defined in [RFC7665].",
      "ja": "分類子：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Metadata (MD): Defined in [RFC7665]. The metadata, or context information shared between Classifiers and SFs, and among SFs, is carried on the NSH's Context Headers. It allows summarizing a classification result in the packet itself, avoiding subsequent re-classifications. Examples of metadata include classification information used for policy enforcement and network context for forwarding after service delivery.",
      "ja": "メタデータ（MD）：[RFC7665]で定義されます。メタデータ、または分類器およびSFSの間で共有コンテキスト情報、およびSFSの間では、NSHのコンテキストヘッダ上に担持されます。これは、その後の再分類を回避し、パケット自体に分類結果を要約することを可能にします。メタデータの例は、サービス提供後の転送のためのポリシー施行とネットワークコンテキストに使用される分類情報を含みます。"
    },
    {
      "indent": 3,
      "text": "Network Locator: Data-plane address, typically IPv4 or IPv6, used to send and receive network traffic.",
      "ja": "ネットワークロケータ：ネットワークトラフィックを送受信するために使用されるデータ・プレーンアドレス、一般的にIPv4またはIPv6、。"
    },
    {
      "indent": 3,
      "text": "Network Node/Element: Device that forwards packets or frames based on an outer header (i.e., transport encapsulation) information.",
      "ja": "ネットワークノード/要素：外部ヘッダ（即ち、トランスポートカプセル化）情報に基づいて、パケットまたはフレームを転送デバイス。"
    },
    {
      "indent": 3,
      "text": "Network Overlay: Logical network built on top of an existing network (the underlay). Packets are encapsulated or tunneled to create the overlay network topology.",
      "ja": "ネットワークオーバーレイ：既存のネットワーク（アンダーレイ）の上に構築された論理的なネットワーク。パケットは、カプセル化またはオーバーレイネットワークトポロジを作成するために、トンネル化されています。"
    },
    {
      "indent": 3,
      "text": "NSH-aware: NSH-aware means SFC-encapsulation-aware, where the NSH provides the SFC encapsulation. This specification uses NSH-aware as a more specific term from the more generic term \"SFC-aware\" [RFC7665].",
      "ja": "NSH-意識：NSH-意識手段のSFC-カプセル化を意識し、NSHはSFCのカプセル化を提供します。この仕様は、より一般的な用語「SFC対応」[RFC7665]から、より具体的な用語としてNSH-意識を使用しています。"
    },
    {
      "indent": 3,
      "text": "Service Classifier: Logical entity providing classification function. Since they are logical, Classifiers may be co-resident with SFC elements such as SFs or SFFs. Service Classifiers perform classification and impose the NSH. The initial Classifier imposes the initial NSH and sends the NSH packet to the first SFF in the path. Non-initial (i.e., subsequent) classification can occur as needed and can alter, or create a new service path.",
      "ja": "サービス分類子：論理エンティティは、分類機能を提供します。それらは論理的であるため、分類器は、サービスフロー又はスキャンフリップフロップとしてSFC要素と共存してもよいです。サービス分類器は、分類を行い、NSHを課します。最初の分類器は、初期NSHを課し、パスの最初のSFFにNSHパケットを送信します。非初期（すなわち、後続）分類は、必要に応じて発生し、変更することができ、又は新たなサービス・パスを作成します。"
    },
    {
      "indent": 3,
      "text": "Service Function (SF): Defined in [RFC7665].",
      "ja": "サービス機能（SF）：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Service Function Chain (SFC): Defined in [RFC7665].",
      "ja": "サービス機能チェーン（SFC）：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Service Function Forwarder (SFF): Defined in [RFC7665].",
      "ja": "サービス機能のフォワーダ（SFF）：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Service Function Path (SFP): Defined in [RFC7665].",
      "ja": "サービス機能パス（SFP）：[RFC7665]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Service Plane: The collection of SFFs and associated SFs creates a service-plane overlay in which all SFs and SFC Proxies reside [RFC7665].",
      "ja": "サービス・プレーン：スキャンフリップフロップのコレクションと関連のSFは、すべてのSFとSFCプロキシは[RFC7665]を常駐するサービスプレーンオーバレイを作成します。"
    },
    {
      "indent": 3,
      "text": "SFC Proxy: Defined in [RFC7665].",
      "ja": "SFCプロキシ：[RFC7665]で定義されます。"
    },
    {
      "indent": 0,
      "text": "1.4. Problem Space",
      "section_title": true,
      "ja": "1.4。問題空間"
    },
    {
      "indent": 3,
      "text": "The NSH addresses several limitations associated with Service Function deployments. [RFC7498] provides a comprehensive review of those issues.",
      "ja": "NSHは、サービス機能の導入に関連したいくつかの制限に対処します。 [RFC7498]は、それらの問題の包括的な見直しを提供します。"
    },
    {
      "indent": 0,
      "text": "1.5. NSH-Based Service Chaining",
      "section_title": true,
      "ja": "1.5。 NSH-ベースのサービスチェーン"
    },
    {
      "indent": 3,
      "text": "The NSH creates a dedicated service plane; more specifically, the NSH enables:",
      "ja": "NSHは、専用のサービス・プレーンを作成します。具体的には、NSHが可能になります。"
    },
    {
      "indent": 3,
      "text": "1. Topological Independence: Service forwarding occurs within the service plane, so the underlying network topology does not require modification. The NSH provides an identifier used to select the network overlay for network forwarding.",
      "ja": "1.トポロジー独立性：サービスの転送は、サービス面内で発生し、その基盤となるネットワークトポロジーは変更する必要はありません。 NSHは、ネットワーク転送のためにネットワークオーバーレイを選択するために使用される識別子を提供します。"
    },
    {
      "indent": 3,
      "text": "2. Service Chaining: The NSH enables service chaining per [RFC7665]. The NSH contains path identification information needed to realize a service path. Furthermore, the NSH provides the ability to monitor and troubleshoot a service chain, end-to-end via service-specific Operations, Administration, and Maintenance (OAM) messages. The NSH fields can be used by administrators (for example, via a traffic analyzer) to verify the path specifics (e.g., accounting, ensuring correct chaining, providing reports, etc.) of packets being forwarded along a service path.",
      "ja": "2.サービスチェーン：NSHは、[RFC7665]あたりの連鎖のサービスを可能にします。 NSHは、サービスパスを実現するために必要なパスの識別情報が含まれています。さらに、NSHは、サービスチェーン、エンドツーエンドのサービス固有の操作を介して、管理、および保守（OAM）メッセージを監視し、トラブルシューティングする能力を提供します。サービス・パスに沿って転送されるパケットのNSHフィールド（例えば、など、会計正しいチェーンを確保する、レポートを提供する）経路の仕様を確認する（トラフィックアナライザを介して、など）管理者が使用することができます。"
    },
    {
      "indent": 3,
      "text": "3. The NSH provides a mechanism to carry shared metadata between participating entities and Service Functions. The semantics of the shared metadata are communicated via a control plane (which is outside the scope of this document) to participating nodes. Section 3.3 of [SFC-CONTROL-PLANE] provides an example of this. Examples of metadata include classification information used for policy enforcement and network context for forwarding post service delivery. Sharing the metadata allows Service Functions to share initial and intermediate classification results with downstream Service Functions saving re-classification, where enough information was enclosed.",
      "ja": "3. NSHは、参加エンティティとサービス関数間の共有メタデータを運ぶためのメカニズムを提供します。共有メタデータの意味論は、参加ノードに（この文書の範囲外である）制御プレーンを介して通信されます。 [SFC-CONTROL-PLANE]のセクション3.3は、この例を提供します。メタデータの例としては、転送後のサービス提供のための政策執行機関やネットワーク状況のために使用される分類情報が含まれています。メタデータを共有するサービスの機能が十分な情報が封入された再分類、保存、下流サービス関数と初期および中間の分類結果を共有することができます。"
    },
    {
      "indent": 3,
      "text": "4. The NSH offers a common and standards-based header for service chaining to all network and service nodes.",
      "ja": "4. NSHは、すべてのネットワークとサービスノードにチェーンサービスのための共通かつ標準ベースのヘッダを提供します。"
    },
    {
      "indent": 3,
      "text": "5. Transport Encapsulation Agnostic: The NSH is transport encapsulation independent: meaning it can be transported by a variety of encapsulation protocols. An appropriate (for a given deployment) encapsulation protocol can be used to carry NSH-encapsulated traffic. This transport encapsulation may form an overlay network; and if an existing overlay topology provides the required service path connectivity, that existing overlay may be used.",
      "ja": "5.交通カプセル化不可知論者：NSHは、独立したトランスポートのカプセル化である：それはカプセル化プロトコルの様々な輸送することができるという意味。適切な（所定の展開のための）カプセル化プロトコルは、NSH、カプセル化されたトラフィックを搬送するために使用することができます。このトランスポートカプセル化は、オーバーレイネットワークを形成してもよいです。既存のオーバーレイ・トポロジは、必要なサービス経路の接続性を提供する場合、その既存のオーバーレイを使用することができます。"
    },
    {
      "indent": 0,
      "text": "2. Network Service Header",
      "section_title": true,
      "ja": "2.ネットワークサービスヘッダ"
    },
    {
      "indent": 3,
      "text": "An NSH is imposed on the original packet/frame. This NSH contains service path information and, optionally, metadata that are added to a packet or frame and used to create a service plane. Subsequently, an outer transport encapsulation is imposed on the NSH, which is used for network forwarding.",
      "ja": "NSHは、元のパケット/フレームに課されます。このNSHは、必要に応じて、サービス経路情報と、パケットまたはフレームに追加され、サービス・プレーンを作成するために使用されるメタデータを含みます。その後、外側の搬送カプセル化は、ネットワークの転送のために使用されるNSH、課されます。"
    },
    {
      "indent": 3,
      "text": "A Service Classifier adds the NSH. The NSH is removed by the last SFF in the service chain or by an SF that consumes the packet.",
      "ja": "サービス分類子はNSHを追加します。 NSHは、サービスチェーンの最後のSFFまたはパケットを消費SFによって除去されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Network Service Header Format",
      "section_title": true,
      "ja": "2.1。ネットワークサービスヘッダー形式"
    },
    {
      "indent": 3,
      "text": "The NSH is composed of a 4-byte Base Header, a 4-byte Service Path Header, and optional Context Headers, as shown in Figure 2.",
      "ja": "図2に示すようにNSHは、4バイトの基本ヘッダ、4バイトのサービスパスヘッダー、およびオプションのコンテキストヘッダで構成されています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Base Header                                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Service Path Header                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                Context Header(s)                              ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 2: Network Service Header",
      "ja": "図2：ネットワークサービスのヘッダー"
    },
    {
      "indent": 3,
      "text": "Base Header: Provides information about the service header and the payload protocol.",
      "ja": "ベースヘッダー：サービスヘッダとペイロードプロトコルに関する情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Service Path Header: Provides path identification and location within a service path.",
      "ja": "サービスパスヘッダー：サービス・パス内のパスの識別と場所を提供します。"
    },
    {
      "indent": 3,
      "text": "Context Header: Carries metadata (i.e., context data) along a service path.",
      "ja": "コンテキストヘッダ：サービス・パスに沿ってメタデータ（即ち、コンテキスト・データ）を運びます。"
    },
    {
      "indent": 0,
      "text": "2.2. NSH Base Header",
      "section_title": true,
      "ja": "2.2。 NSHベースヘッダー"
    },
    {
      "indent": 3,
      "text": "Figure 3 depicts the NSH Base Header:",
      "ja": "図3は、NSH基本ヘッダを示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 3: NSH Base Header",
      "ja": "図3：NSHベースヘッダ"
    },
    {
      "indent": 3,
      "text": "The field descriptions are as follows:",
      "ja": "次のようにフィールドの説明は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Version: The Version field is used to ensure backward compatibility going forward with future NSH specification updates. It MUST be set to 0x0 by the sender, in this first revision of the NSH. If a packet presumed to carry an NSH header is received at an SFF, and the SFF does not understand the version of the protocol as indicated in the base header, the packet MUST be discarded, and the event SHOULD be logged. Given the widespread implementation of existing hardware that uses the first nibble after an MPLS label stack for Equal-Cost Multipath (ECMP) decision processing, this document reserves version 01b. This value MUST NOT be used in future versions of the protocol. Please see [RFC7325] for further discussion of MPLS-related forwarding requirements.",
      "ja": "バージョン：Versionフィールドは、将来のNSH仕様のアップデートと今後の下位互換性を確保するために使用されます。それはNSHのこの最初のリビジョンでは、送信者が0x0に設定しなければなりません。 NSHヘッダを運ぶために推定パケットがSFFで受信され、SFFは、基本ヘッダに示されているように、プロトコルのバージョンを理解していない場合、パケットは廃棄されなければならないし、イベントをログに記録します。等価コストマルチパス（ECMP）判定処理のためのMPLSラベルスタックの後の最初のニブルを使用して、既存のハードウェア、本書の埋蔵バージョン01Bの広範囲の実装を考えます。この値は、プロトコルの将来のバージョンで使用してはいけません。 MPLS関連の転送要件のさらなる議論のための[RFC7325]を参照してください。"
    },
    {
      "indent": 3,
      "text": "O bit: Setting this bit indicates an OAM packet (see [RFC6291]). The actual format and processing of SFC OAM packets is outside the scope of this specification (for example, see [SFC-OAM-FRAMEWORK] for one approach).",
      "ja": "Oビット：このビットを設定する（[RFC6291]を参照）OAMパケットを示しています。 SFC OAMパケットの実際のフォーマットおよび処理（例えば、1つのアプローチは[SFC-OAM-FRAMEWORK]を参照）、本明細書の範囲外です。"
    },
    {
      "indent": 6,
      "text": "The O bit MUST be set for OAM packets and MUST NOT be set for non-OAM packets. The O bit MUST NOT be modified along the SFP.",
      "ja": "Oビットは、OAMパケットのために設定しなければならなくて、非OAMパケットのために設定してはいけません。 Oビットは、SFPに沿って変更してはいけません。"
    },
    {
      "indent": 6,
      "text": "SF/SFF/SFC Proxy/Classifier implementations that do not support SFC OAM procedures SHOULD discard packets with O bit set, but MAY support a configurable parameter to enable forwarding received SFC OAM packets unmodified to the next element in the chain. Forwarding OAM packets unmodified by SFC elements that do not support SFC OAM procedures may be acceptable for a subset of OAM functions, but it can result in unexpected outcomes for others; thus, it is recommended to analyze the impact of forwarding an OAM packet for all OAM functions prior to enabling this behavior. The configurable parameter MUST be disabled by default.",
      "ja": "Oビットが設定されたパケットを廃棄すべきであるSFCのOAM手順をサポートしていないが、転送を可能にするための設定可能なパラメータをサポートするかもしれSF / SFF / SFCプロキシ/分類の実装は、チェーン内の次の要素に修飾されていないSFC OAMパケットを受信しました。 OAM機能のサブセットのために許容できるSFCのOAM手順をサポートしないSFC要素により修飾されていないOAMパケットを転送するが、それは他人のために、予期しない結果をもたらすことができます。従って、この動作を有効にする前に、すべてのOAM機能のためのOAMパケットの転送の影響を分析することが推奨されます。設定可能なパラメータは、デフォルトでは無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "TTL: Indicates the maximum SFF hops for an SFP. This field is used for service-plane loop detection. The initial TTL value SHOULD be configurable via the control plane; the configured initial value can be specific to one or more SFPs. If no initial value is explicitly provided, the default initial TTL value of 63 MUST be used. Each SFF involved in forwarding an NSH packet MUST decrement the TTL value by 1 prior to NSH forwarding lookup. Decrementing by 1 from an incoming value of 0 shall result in a TTL value of 63. The packet MUST NOT be forwarded if TTL is, after decrement, 0.",
      "ja": "TTLは：最大SFFは、SFPのためにホップを示します。このフィールドは、サービス・プレーン・ループ検出のために使用されています。初期TTL値は、制御プレーンを介して設定されるべきです。構成された初期値は、一個の以上のSFPを特定することができます。何の初期値が明示的に提供されていない場合は、63のデフォルトの初期TTL値を使用しなければなりません。 NSHパケットの転送に関係する各SFFは1つの前NSHに転送ルックアップによってTTL値をデクリメントしなければなりません。 0の受信値から1だけデクリメントする63パケットのTTL値をもたらすものとTTLをデクリメント、0の後に、ある場合に転送されてはいけません。"
    },
    {
      "indent": 6,
      "text": "This TTL field is the primary loop-prevention mechanism. This TTL mechanism represents a robust complement to the Service Index (see Section 2.3), as the TTL is decremented by each SFF. The handling of an incoming 0 TTL allows for better, although not perfect, interoperation with pre-standard implementations that do not support this TTL field.",
      "ja": "このTTLフィールドは、一次ループ防止機構です。 TTLは、各SFFだけデクリメントされるように、このTTLメカニズムは、サービスインデックス（セクション2.3を参照）に強い補数を表しています。着信0 TTLの取り扱いは、このTTLフィールドをサポートしていない先行標準の実装とのより良い、完璧ではないものの、相互運用が可能になります。"
    },
    {
      "indent": 3,
      "text": "Length: The total length, in 4-byte words, of the NSH including the Base Header, the Service Path Header, the Fixed-Length Context Header, or Variable-Length Context Header(s). The length MUST be 0x6 for MD Type 0x1, and it MUST be 0x2 or greater for MD Type 0x2. The length of the Network Service Header MUST be an integer multiple of 4 bytes; thus, variable-length metadata is always padded out to a multiple of 4 bytes.",
      "ja": "長さ：全長、4バイトワードで、基本ヘッダ、サービスパスヘッダ、固定長コンテキストヘッダ、または可変長コンテキストヘッダ（単数または複数）を含むNSHの。長さは、MDタイプ0x1のための0x6にでなければならない、そしてそれは、MDタイプ0x2のための0x2の以上でなければなりません。ネットワークサービスヘッダの長さが4バイトの整数倍でなければなりません。従って、可変長メタデータは、常に4バイトの倍数にパディングされます。"
    },
    {
      "indent": 3,
      "text": "Unassigned bits: All other flag fields, marked U, are unassigned and available for future use; see Section 9.1.1. Unassigned bits MUST be set to zero upon origination, and they MUST be ignored and preserved unmodified by other NSH supporting elements. At reception, all elements MUST NOT modify their actions based on these unknown bits.",
      "ja": "未割り当てビット：他のすべてのフラグフィールドは、Uをマークし、将来の使用のために割り当てられていないと利用できます。第9.1.1項を参照してください。割り当てられていないビットは、発信時にゼロに設定しなければなりません、そして、それらは無視され、他のNSH支持要素により修飾されていない保存されなければなりません。レセプションでは、すべての要素は、これらの未知のビットに基づいて自分の行動を変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "Metadata (MD) Type: Indicates the format of the NSH beyond the mandatory NSH Base Header and the Service Path Header. MD Type defines the format of the metadata being carried. Please see the IANA Considerations in Section 9.1.3.",
      "ja": "メタデータ（MD）タイプ：必須NSHベースヘッダーを超えNSHとサービスパスヘッダーの形式を示します。 MDタイプを搭載しているメタデータのフォーマットを定義します。 9.1.3項でIANAの考慮事項を参照してください。"
    },
    {
      "indent": 6,
      "text": "This document specifies the following four MD Type values:",
      "ja": "このドキュメントでは、次の4つのMDタイプの値を指定します。"
    },
    {
      "indent": 6,
      "text": "0x0: This is a reserved value. Implementations SHOULD silently discard packets with MD Type 0x0.",
      "ja": "0x0の：これは予約値です。実装は黙っMDタイプ0x0の持つパケットを破棄すべきです。"
    },
    {
      "indent": 6,
      "text": "0x1: This indicates that the format of the header includes a Fixed-Length Context Header (see Figure 5 below).",
      "ja": "0x1の：これは、ヘッダのフォーマットが固​​定長コンテキストヘッダ（以下の図5を参照）を含むことを示します。"
    },
    {
      "indent": 6,
      "text": "0x2: This does not mandate any headers beyond the Base Header and Service Path Header, but may contain optional Variable-Length Context Header(s). With MD Type 0x2, a length of 0x2 implies there are no Context Headers. The semantics of the Variable-Length Context Header(s) are not defined in this document. The format of the optional Variable-Length Context Headers is provided in Section 2.5.1.",
      "ja": "0x2の：これは、基本ヘッダーとサービスPathヘッダを超えた任意のヘッダを強制しませんが、オプションの可変長コンテキストヘッダー（複数可）を含有していてもよいです。 MDタイプ0x2のでは、0x2というの長さにはコンテキストヘッダが存在しない意味します。可変長コンテキストヘッダー（複数可）のセマンティクスは、この文書で定義されていません。任意可変長コンテキストヘッダのフォーマットはセクション2.5.1に設けられています。"
    },
    {
      "indent": 6,
      "text": "0xF: This value is reserved for experimentation and testing, as per [RFC3692]. Implementations not explicitly configured to be part of an experiment SHOULD silently discard packets with MD Type 0xF.",
      "ja": "0xFの：この値は[RFC3692]に従って、実験および試験のために予約されています。明示的実験の一部であるように構成されていない実装は黙っMDタイプ0xFの持つパケットを破棄すべきです。"
    },
    {
      "indent": 6,
      "text": "The format of the Base Header and the Service Path Header is invariant and not affected by MD Type.",
      "ja": "基本ヘッダーとサービスパスヘッダーのフォーマットは不変とMDの種類によって影響を受けません。"
    },
    {
      "indent": 6,
      "text": "The NSH MD Type 1 and MD Type 2 are described in detail in Sections 2.4 and 2.5, respectively. NSH implementations MUST support MD Types 0x1 and 0x2 (where the length is 0x2). NSH implementations SHOULD support MD Type 0x2 with length greater than 0x2. Devices that do not support MD Type 0x2 with a length greater than 0x2 MUST ignore any optional Context Headers and process the packet without them; the Base Header Length field can be used to determine the original payload offset if access to the original packet/frame is required. This specification does not disallow the MD Type value from changing along an SFP; however, the specification of the necessary mechanism to allow the MD Type to change along an SFP are outside the scope of this document and would need to be defined for that functionality to be available. Packets with MD Type values not supported by an implementation MUST be silently dropped.",
      "ja": "NSH MDタイプ1及びMDタイプ2は、それぞれ、セクション2.4および2.5に詳細に記載されています。 NSHの実装では、（長さを0x2である）MDタイプは0x1と0x2のをサポートしなければなりません。 NSH実装は0x2のより大きい長さとMDタイプ0x2のをサポートする必要があります。 0x2のより大きい長さとMDタイプ0x2のをサポートしないデバイスは、任意のオプションのコンテキストヘッダを無視し、それらなしでパケットを処理しなければなりません。基本ヘッダ長フィールドは、元のパケット/フレームへのアクセスが必要とされる場合、オフセット元のペイロードを決定するために用いることができます。この仕様は、SFPに沿って変化するからMDタイプ値を禁止しません。しかし、MDタイプは、SFPに沿って変化することを可能にするために必要な機構の仕様は、この文書の範囲外であり、その機能を利用できるようにするために定義される必要があるであろう。実装によってサポートされていないMDタイプの値を持つパケットは黙って捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Next Protocol: Indicates the protocol type of the encapsulated data. The NSH does not alter the inner payload, and the semantics on the inner protocol remain unchanged due to NSH SFC. Please see the IANA Considerations in Section 9.1.6.",
      "ja": "次のプロトコル：カプセル化されたデータのプロトコルタイプを示します。 NSHは、内側ペイロードを変更していない、と内部のプロトコル上のセマンティクスが原因NSH SFCに変更されないまま。 9.1.6項でIANAの考慮事項を参照してください。"
    },
    {
      "indent": 6,
      "text": "This document defines the following Next Protocol values:",
      "ja": "このドキュメントでは、次の次のプロトコル値を定義します。"
    },
    {
      "indent": 6,
      "text": "0x1: IPv4 0x2: IPv6 0x3: Ethernet 0x4: NSH 0x5: MPLS 0xFE: Experiment 1 0xFF: Experiment 2",
      "ja": "0x1の：のIPv4を0x2：のIPv6を0x3：イーサネットを0x4：NSHの0x5：MPLS 0xFEの：実験1の0xFF：実験2"
    },
    {
      "indent": 6,
      "text": "The functionality of hierarchical NSH using a Next Protocol value of 0x4 (NSH) is outside the scope of this specification. Packets with Next Protocol values not supported SHOULD be silently dropped by default, although an implementation MAY provide a configuration parameter to forward them. Additionally, an implementation not explicitly configured for a specific experiment [RFC3692] SHOULD silently drop packets with Next Protocol values 0xFE and 0xFF.",
      "ja": "0x4の次のプロトコル値を使用して階層NSH（NSH）の機能は、本明細書の範囲外です。実装はそれらを転送するように設定パラメータを提供してもよい（MAY）がサポートされていない次のプロトコル値を持つパケットは静かに、デフォルトでドロップされるべきである（SHOULD）。また、明示的に特定実験[RFC3692]のために構成されていない実装では、サイレント次のプロトコル値0xFEのと0xFFを持つパケットをドロップすべきです。"
    },
    {
      "indent": 0,
      "text": "2.3. Service Path Header",
      "section_title": true,
      "ja": "2.3。サービスパスヘッダー"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the format of the Service Path Header:",
      "ja": "図4は、サービスパスヘッダーのフォーマットを示しています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier (SPI)        | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Service Path Identifier (SPI): 24 bits Service Index (SI): 8 bits",
      "ja": "サービス・パス識別子（SPI）：24ビットサービスインデックス（SI）：8ビット"
    },
    {
      "indent": 21,
      "text": "Figure 4: NSH Service Path Header",
      "ja": "図4：NSHサービスパスヘッダー"
    },
    {
      "indent": 3,
      "text": "The meaning of these fields is as follows:",
      "ja": "次のようにこれらのフィールドの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Service Path Identifier (SPI): Uniquely identifies a Service Function Path (SFP). Participating nodes MUST use this identifier for SFP selection. The initial Classifier MUST set the appropriate SPI for a given classification result.",
      "ja": "サービスパス識別子（SPI）は、一意サービス機能パス（SFP）を識別します。参加ノードは、SFPを選択するための識別子を使用しなければなりません。最初の分類器は、与えられた分類結果に対する適切なSPIを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Service Index (SI): Provides location within the SFP. The initial Classifier for a given SFP SHOULD set the SI to 255; however, the control plane MAY configure the initial value of the SI as appropriate (i.e., taking into account the length of the SFP). The Service Index MUST be decremented by a value of 1 by Service Functions or by SFC Proxy nodes after performing required services; the new decremented SI value MUST be used in the egress packet's NSH. The initial Classifier MUST send the packet to the first SFF in the identified SFP for forwarding along an SFP. If re-classification occurs, and that re-classification results in a new SPI, the (re-)Classifier is, in effect, the initial Classifier for the resultant SPI.",
      "ja": "サービスインデックス（SI）は：SFP内の場所を提供します。与えられたSFPの初期分類子は255にSIを設定すべきです。しかし、制御プレーン（すなわち、考慮SFPの長さを取る）を適宜SIの初期値を設定してもよいです。サービスインデックスが必要なサービスを実行した後のサービス機能によって、またはSFC Proxyノードによって1の値だけ減少しなければなりません。新しい減らさSI値は、出力パケットのNSHに使用しなければなりません。最初の分類器は、SFPに沿って転送するための識別SFPの最初のSFFにパケットを送らなければなりません。再分類が発生した場合、および新しいSPIでその再分類結果、（再）分類器は、実際には、得られるSPIの初期分類子です。"
    },
    {
      "indent": 3,
      "text": "The SI is used in conjunction with the Service Path Identifier for SFP selection and for determining the next SFF/SF in the path. The SI is also valuable when troubleshooting or reporting service paths. While the TTL provides the primary SFF-based loop prevention for this mechanism, SI decrement by SF serves as a limited loop-prevention mechanism. NSH packets, as described above, are discarded when an SFF decrements the TTL to 0. In addition, an SFF that is not the terminal SFF for an SFP will discard any NSH packet with an SI of 0, as there will be no valid next SF information.",
      "ja": "SIは、SFP選択のためのサービス・パス識別子と関連して、パス内の次のSFF / SFを決定するために使用されます。トラブルシューティングやサービスのパスを報告するときSIにも貴重なものです。 TTLは、この機構のプライマリSFFベースループ防止を提供しながら、SFによってSIの減少は、限られたループ防止メカニズムとして機能します。 SFFはまた0にTTLをデクリメントするときNSHパケットは、上述したように、廃棄される有効な次存在しないであろうように、SFP用の端子SFFないSFFは、0のSIと任意NSHパケットを廃棄しますSF情報。"
    },
    {
      "indent": 0,
      "text": "2.4. NSH MD Type 1",
      "section_title": true,
      "ja": "2.4。 NSH MDタイプ1"
    },
    {
      "indent": 3,
      "text": "When the Base Header specifies MD Type 0x1, a Fixed-Length Context Header (16-bytes) MUST be present immediately following the Service Path Header, as per Figure 5. The value of a Fixed-Length Context Header that carries no metadata MUST be set to zero.",
      "ja": "基本ヘッダは、MDタイプは0x1を指定した場合、固定長コンテキストヘッダ（16バイト）は、図5でなければならないというメタデータを搬送しない固定長コンテキストヘッダの値に従って、直ちにサービスパスヘッダに続く存在していなければなりませんゼロに設定します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier              | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Fixed-Length Context Header                   |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 5: NSH MD Type 0x1",
      "ja": "図5：NSH MDタイプ0x1の"
    },
    {
      "indent": 3,
      "text": "This specification does not make any assumptions about the content of the 16-byte Context Header that must be present when the MD Type field is set to 1, and it does not describe the structure or meaning of the included metadata.",
      "ja": "この仕様は、MDのTypeフィールドが1に設定されているときに存在しなければならない16バイトのコンテキストヘッダの内容についての仮定をしない、それが含まれるメタデータの構造や意味を説明していません。"
    },
    {
      "indent": 3,
      "text": "An SFC-aware SF or SFC Proxy needs to receive the data structure and semantics first in order to process the data placed in the mandatory context field. The data structure and semantics include both the allocation schema and order as well as the meaning of the included data. How an SFC-aware SF or SFC Proxy gets the data structure and semantics is outside the scope of this specification.",
      "ja": "SFC対応のSFやSFCプロキシが最初の必須のコンテキストフィールドに配置されたデータを処理するために、データ構造とセマンティクスを受信する必要があります。データ構造およびセマンティクスは、割当スキーマ及び順序並びに含まれるデータの意味の両方を含みます。 SFC対応のSFやSFCプロキシは、データ構造とセマンティクスを取得する方法この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "An SF or SFC Proxy that does not know the format or semantics of the Context Header for an NSH with MD Type 1 MUST discard any packet with such an NSH (i.e., MUST NOT ignore the metadata that it cannot process), and MUST log the event at least once per the SPI for which the event occurs (subject to thresholding).",
      "ja": "MDタイプ1とNSHのためのコンテキストヘッダーの形式や意味を知らないSFまたはSFCプロキシはNSH（すなわち、それは処理できないメタデータを無視してはいけません）などで任意のパケットを捨てなければなりませんし、ログインする必要がありますイベントが（閾値による）発生するために少なくとも一回SPIあたりイベント。"
    },
    {
      "indent": 3,
      "text": "[NSH-DC-ALLOCATION] and [NSH-BROADBAND-ALLOCATION] provide specific examples of how metadata can be allocated.",
      "ja": "[NSH-DC-ALLOCATION]および[NSH-BROADBAND-ALLOCATION]メタデータを割り当てることができる方法の具体的な例を提供します。"
    },
    {
      "indent": 0,
      "text": "2.5. NSH MD Type 2",
      "section_title": true,
      "ja": "2.5。 NSH MDタイプ2"
    },
    {
      "indent": 3,
      "text": "When the Base Header specifies MD Type 0x2, zero or more Variable-Length Context Headers MAY be added, immediately following the Service Path Header (see Figure 6). Therefore, Length = 0x2, indicates that only the Base Header and Service Path Header are present (and in that order). The optional Variable-Length Context Headers MUST be of an integer number of 4-bytes. The Base Header Length field MUST be used to determine the offset to locate the original packet or frame for SFC nodes that require access to that information.",
      "ja": "ベースヘッダーMDタイプを0x2を指定した場合、ゼロ個以上の可変長コンテキストヘッダは、直ちにサービスパスヘッダ（図6参照）、以下を添加してもよいです。したがって、長さ= 0x2のは、唯一の基本ヘッダおよびサービス・パスヘッダーが存在する（そのために）であることを示しています。任意可変長コンテキストヘッダは4バイトの整数倍でなければなりません。基本ヘッダ長フィールドは、その情報へのアクセスを必要とSFCノードの元のパケットまたはフレームを配置するためにオフセットを決定するために使用されなければなりません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Ver|O|U|    TTL    |   Length  |U|U|U|U|MD Type| Next Protocol |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Service Path Identifier              | Service Index |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~              Variable-Length Context Headers  (opt.)          ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 6: NSH MD Type 0x2",
      "ja": "図6：NSH MDタイプを0x2"
    },
    {
      "indent": 0,
      "text": "2.5.1. Optional Variable-Length Metadata",
      "section_title": true,
      "ja": "2.5.1。オプションの可変長のメタデータ"
    },
    {
      "indent": 3,
      "text": "The format of the optional Variable-Length Context Headers, is as depicted in Figure 7.",
      "ja": "図7に示すように、オプションの可変長コンテキストヘッダのフォーマットは、です。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Metadata Class       |      Type     |U|    Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Variable-Length Metadata                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 7: Variable-Length Context Headers",
      "ja": "図7：可変長コンテキストヘッダ"
    },
    {
      "indent": 3,
      "text": "Metadata Class (MD Class): Defines the scope of the Type field to provide a hierarchical namespace. Section 9.1.4 defines how the MD Class values can be allocated to standards bodies, vendors, and others.",
      "ja": "メタデータクラス（MDクラス）：階層的な名前空間を提供するために、Typeフィールドの範囲を定義します。 9.1.4項ではMDクラスの値は標準化団体、ベンダー、および他の人に割り当てることができる方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Type: Indicates the explicit type of metadata being carried. The definition of the Type is the responsibility of the MD Class owner.",
      "ja": "タイプは：メタデータの明示的な型が搭載されていることを示します。タイプの定義はMDクラスの所有者の責任です。"
    },
    {
      "indent": 3,
      "text": "Unassigned bit: One unassigned bit is available for future use. This bit MUST NOT be set, and it MUST be ignored on receipt.",
      "ja": "未割り当てビット：一つの未割り当てのビットは将来の使用のために利用可能です。このビットがセットされてはならない、そしてそれは領収書で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Length: Indicates the length of the variable-length metadata, in bytes. In case the metadata length is not an integer number of 4-byte words, the sender MUST add pad bytes immediately following the last metadata byte to extend the metadata to an integer number of 4-byte words. The receiver MUST round the Length field up to the nearest 4-byte-word boundary, to locate and process the next field in the packet. The receiver MUST access only those bytes in the metadata indicated by the Length field (i.e., actual number of bytes) and MUST ignore the remaining bytes up to the nearest 4-byte-word boundary. The length may be 0 or greater.",
      "ja": "長：バイトで、可変長のメタデータの長さを示します。メタデータの長さが4バイトワードの整数倍でない場合には、送信者は直ちに4バイトワードの整数にメタデータを拡張する最後のメタデータ・バイト以下パッドバイトを追加しなければなりません。受信機は、パケット内の次のフィールドを検索し、処理するため、最寄りの4バイトワード境界に長さフィールドを切り上げなければなりません。受信機は、長さフィールド（バイトすなわち、実際の数）で示されるメタデータにのみバイトにアクセスする必要があり、最寄りの4バイトワード境界までの残りのバイトを無視しなければなりません。長さが0以上であってもよいです。"
    },
    {
      "indent": 6,
      "text": "A value of 0 denotes a Context Header without a Variable-Length Metadata field.",
      "ja": "0の値は、可変長のメタデータ・フィールドなしコンテキストヘッダを表します。"
    },
    {
      "indent": 3,
      "text": "This specification does not make any assumption about Context Headers that are mandatory to implement or those that are mandatory to process. These considerations are deployment specific. However, the control plane is entitled to instruct SFC-aware SFs with the data structure of the Context Header together with its scoping (see e.g., Section 3.3.3 of [SFC-CONTROL-PLANE]).",
      "ja": "この仕様は、実装が必須または処理するために必須なものであるコンテキストヘッダについての仮定を行いません。これらの考慮事項は、特定の展開です。しかし、制御プレーンは（例えば[SFC-CONTROL-PLANE]のセクション3.3.3を参照）と共に、そのスコープとコンテキスト・ヘッダのデータ構造をSFC対応のサービスフローを指示する権利があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a packet that belongs to a given SFP, if a mandatory-to-process Context Header is missing in that packet, the SFC-aware SF MUST NOT process the packet and MUST log an error at least once per the SPI for which the mandatory metadata is missing.",
      "ja": "必須・ツー・プロセスコンテキストた場合のヘッダは、そのパケットに欠けている、与えられたSFPに属しているパケットを受信すると、SFC対応のSFは、パケットを処理してはならないとのためのSPIごとに少なくとも一度はエラーをログに記録しなければなりません必須メタデータが不足しています。"
    },
    {
      "indent": 3,
      "text": "If multiple mandatory-to-process Context Headers are required for a given SFP, the control plane MAY instruct the SFC-aware SF with the order to consume these Context Headers. If no instructions are provided and the SFC-aware SF will make use of or modify the specific Context Header, then the SFC-aware SF MUST process these Context Headers in the order they appear in an NSH packet.",
      "ja": "複数の必須・ツー・プロセスコンテキストヘッダが与えられたSFPのために必要とされる場合は、コントロールプレーンは、これらのコンテキストヘッダを消費するためにSFC対応のSFを指示することができます。何の説明書が提供されていないとSFC対応のSFはを利用したり、特定のコンテキストヘッダーを変更する場合は、その後、SFC対応のSFは、彼らがNSHパケットに表示される順序でこれらのコンテキストヘッダを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If multiple instances of the same metadata are included in an NSH packet, but the definition of that Context Header does not allow for it, the SFC-aware SF MUST process the first instance and ignore subsequent instances. The SFC-aware SF MAY log or increase a counter for this event.",
      "ja": "同じメタデータの複数のインスタンスがNSHパケットに含まれているが、そのコンテキストの定義はヘッダーがそれを許可しない場合は、SFC対応のSFは、最初のインスタンスを処理し、後続のインスタンスを無視しなければなりません。 SFC対応のSFは、ログインするか、このイベントのためにカウンタを増加させることができます。"
    },
    {
      "indent": 0,
      "text": "3. NSH Actions",
      "section_title": true,
      "ja": "3. NSHアクション"
    },
    {
      "indent": 3,
      "text": "NSH-aware nodes (which include Service Classifiers, SFFs, SFs, and SFC Proxies) may alter the contents of the NSH headers. These nodes have several possible NSH-related actions:",
      "ja": "（サービス分類子、スキャンフリップフロップ、サービスフロー、及びSFCプロキシを含む）NSH対応ノードはNSHヘッダの内容を変更することができます。これらのノードは、いくつかの可能NSH-関連のアクションを持っています。"
    },
    {
      "indent": 3,
      "text": "1. Insert or remove the NSH: These actions can occur respectively at the start and end of a service path. Packets are classified, and if determined to require servicing, an NSH will be imposed. A",
      "ja": "1.またはNSHを削除します。これらのアクションは、サービスパスの開始時と終了時にそれぞれ発生する可能性があります。パケットが分類され、サービスが必要と判定された場合、NSHが課されます。 A"
    },
    {
      "indent": 7,
      "text": "Service Classifier MUST insert an NSH at the start of an SFP.  An\nimposed NSH MUST contain both a valid Base Header and Service\nPath Header.  At the end of an SFP, an SFF MUST remove the NSH\nbefore forwarding or delivering the un-encapsulated packet.\nTherefore, it is the last node operating on the service header.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Multiple logical Classifiers may exist within a given service path. Non-initial Classifiers may re-classify data, and that re-classification MAY result in the selection of a different SFP. When the logical Classifier performs re-classification that results in a change of service path, it MUST replace the existing NSH with a new NSH with the Base Header and Service Path Header reflecting the new service path information and MUST set the initial SI. The O bit, the TTL field, and unassigned flags MUST be copied transparently from the old NSH to a new NSH. Metadata MAY be preserved in the new NSH.",
      "ja": "複数の論理的な分類器は、与えられたサービス・パス内に存在し得ます。非初期分類器は、データを再分類することができる、そしてその再分類が異なるSFPの選択をもたらすことができます。論理的分類は、サービス経路の変化をもたらす再分類を行う場合には、新たなサービス経路情報を反映した新しい基本ヘッダでNSH及びサービス経路ヘッダで既存のNSHを交換する必要があり、初期SIを設定しなければなりません。 Oビット、TTLフィールド、および割り当てられていないフラグが新しいNSHに古いNSHから透過的にコピーされなければなりません。メタデータは、新しいNSHに保存することができます。"
    },
    {
      "indent": 3,
      "text": "2. Select service path: The Service Path Header provides service path information and is used by SFFs to determine correct service path selection. SFFs MUST use the Service Path Header for selecting the next SF or SFF in the service path.",
      "ja": "2.サービスのパスを選択：サービスパスヘッダーは、サービス・パスの情報を提供し、正しいサービス・パスの選択を決定するためにスキャンフリップフロップで使用されています。スキャンフリップフロップは、サービス・パスに次のSFやSFFを選択するためのサービスパスのヘッダーを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. Update the NSH: SFs MUST decrement the service index by one. If an SFF receives a packet with an SPI and SI that do not correspond to a valid next hop in a valid SFP, that packet MUST be dropped by the SFF.",
      "ja": "3.更新NSH：のSFが1でサービスインデックスをデクリメントしなければなりません。 SFFが有効なSFPで有効なネクストホップに対応していないSPIおよびSIでパケットを受信した場合、そのパケットは、SFFによって下げなければなりません。"
    },
    {
      "indent": 7,
      "text": "Classifiers MAY update Context Headers if new/updated context is\navailable.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If an SFC proxy is in use (acting on behalf of an NSH-unaware Service Function for NSH actions), then the proxy MUST update the Service Index and MAY update contexts. When an SFC Proxy receives an NSH-encapsulated packet, it MUST remove the NSH before forwarding it to an NSH-unaware SF. When the SFC Proxy receives a packet back from an NSH-unaware SF, it MUST re-encapsulate it with the correct NSH, and it MUST decrement the Service Index by one.",
      "ja": "SFCプロキシを使用している場合（NSHアクションのためNSH-気づかないサービス機能のために行動する）、その後、プロキシがサービスインデックスを更新しなければならなくて、コンテキストを更新することができます。 SFCプロキシはNSH-カプセル化されたパケットを受信すると、NSH-気づかないSFに転送する前にNSHを削除する必要があります。 SFCプロキシはバックNSH-気づかないSFからのパケットを受信すると、それが正しいNSHでそれを再カプセル化しなければならない、そしてそれは1によってサービスインデックスをデクリメントしなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. Service policy selection: Service Functions derive policy (i.e., service actions such as permit or deny) selection and enforcement from the NSH. Metadata shared in the NSH can provide a range of service-relevant information such as traffic classification.",
      "ja": "4.サービスポリシー選択：サービス関数は、ポリシーを引き出す（すなわち、などの許可または拒否などのサービス・アクション）NSHからの選択と実施。 NSH共有メタデータは、トラフィック分類などのサービス関連情報の範囲を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Figure 8 maps each of the four actions above to the components in the SFC architecture that can perform it.",
      "ja": "図8は、それを行うことができるSFCアーキテクチャのコンポーネントに上記の4つのアクションのそれぞれをマッピングします。"
    },
    {
      "indent": 3,
      "text": "+-----------+-----------------------+-------+---------------+-------+\n|           | Insert, remove, or    |Forward| Update        |Service|\n|           | replace the NSH       |the NSH| the NSH       |policy |\n|           |                       |packets|               |sel.   |\n|Component  +-------+-------+-------+       +-------+-------+       |\n|           |       |       |       |       |Dec.   |Update |       |\n|           |Insert |Remove |Replace|       |Service|Context|       |\n|           |       |       |       |       |Index  |Header |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|           |  +    |       |   +   |       |       |   +   |       |\n|Classifier |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|Service    |       |   +   |       |   +   |       |       |       |\n|Function   |       |       |       |       |       |       |       |\n|Forwarder  |       |       |       |       |       |       |       |\n|(SFF)      |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|Service    |       |       |       |       |   +   |   +   |   +   |\n|Function   |       |       |       |       |       |       |       |\n|(SF)       |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+\n|           |  +    |   +   |       |       |   +   |   +   |       |\n|SFC Proxy  |       |       |       |       |       |       |       |\n+-----------+-------+-------+-------+-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 8: NSH Action and Role Mapping",
      "ja": "図8：NSHアクションとロールマッピング"
    },
    {
      "indent": 0,
      "text": "4. NSH Transport Encapsulation",
      "section_title": true,
      "ja": "4. NSH交通のカプセル化"
    },
    {
      "indent": 3,
      "text": "Once the NSH is added to a packet, an outer transport encapsulation is used to forward the original packet and the associated metadata to the start of a service chain. The encapsulation serves two purposes:",
      "ja": "NSHがパケットに追加されると、外側の搬送カプセル化は、元のパケットとサービスチェーンの開始に関連するメタデータを転送するために使用されます。カプセル化は2つの目的があります："
    },
    {
      "indent": 3,
      "text": "1. Creates a topologically independent services plane. Packets are forwarded to the required services without changing the underlying network topology.",
      "ja": "1.位相幾何学の独立したサービス面を作成します。パケットは、基盤となるネットワークトポロジを変更することなく、必要なサービスに転送されます。"
    },
    {
      "indent": 3,
      "text": "2. Transit network nodes simply forward the encapsulated packets without modification.",
      "ja": "2.トランジットネットワークノードは、単純に変更することなく、カプセル化されたパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "The service header is independent of the transport encapsulation used. Existing transport encapsulations can be used. The presence of an NSH is indicated via a protocol type or another indicator in the outer transport encapsulation.",
      "ja": "サービスヘッダが使用されるトランスポートカプセル化とは無関係です。既存のトランスポートのカプセル化を使用することができます。 NSHの存在は、プロトコルタイプ又は外側の輸送カプセル化における他のインジケータを介して示されています。"
    },
    {
      "indent": 0,
      "text": "5. Fragmentation Considerations",
      "section_title": true,
      "ja": "5.断片化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "The NSH and the associated transport encapsulation header are \"added\" to the encapsulated packet/frame. This additional information increases the size of the packet.",
      "ja": "NSH及び関連するトランスポート・カプセル化ヘッダは、カプセル化されたパケット/フレームに「追加」されています。この追加情報は、パケットのサイズが大きくなります。"
    },
    {
      "indent": 3,
      "text": "Within a managed administrative domain, an operator can ensure that the underlay MTU is sufficient to carry SFC traffic without requiring fragmentation. Given that the intended scope of the NSH is within a single provider's operational domain, that approach is sufficient.",
      "ja": "管理管理ドメイン内では、オペレータが下敷きMTUはフラグメンテーションを必要とせずにSFCのトラフィックを運ぶのに十分であることを確認することができます。 NSHの意図された範囲は、単一のプロバイダの運用ドメイン内にあることを考えると、そのアプローチは十分です。"
    },
    {
      "indent": 3,
      "text": "However, although explicitly outside the scope of this specification, there might be cases where the underlay MTU is not large enough to carry the NSH traffic. Since the NSH does not provide fragmentation support at the service plane, the transport encapsulation protocol ought to provide the requisite fragmentation handling. For instance, Section 9 of [RTG-ENCAP] provides exemplary approaches and guidance for those scenarios.",
      "ja": "しかし、明示的にこの仕様の範囲外であるが、アンダーレイは、MTUはNSHのトラフィックを伝送するのに十分な大きさではない場合があるかもしれません。 NSHは、サービス面で断片化サポートを提供しないので、トランスポート・カプセル化プロトコルは、必要なフラグメンテーション処理を提供するべきです。例えば、[RTG-ENCAP]のセクション9は、例示的なアプローチと、これらのシナリオのためのガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "When the transport encapsulation protocol supports fragmentation, and fragmentation procedures needs to be used, such fragmentation is part of the transport encapsulation logic. If, as it is common, fragmentation is performed by the endpoints of the transport encapsulation, then fragmentation procedures are performed at the sending NSH entity as part of the transport encapsulation, and reassembly procedures are performed at the receiving NSH entity during transport de-encapsulation handling logic. In no case would such fragmentation result in duplication of the NSH header.",
      "ja": "トランスポート・カプセル化プロトコルは、断片化をサポートし、断片化手順を使用する必要がある場合、そのような断片は、トランスポートカプセル化ロジックの一部です。それは一般的であるように、フラグメンテーションは、トランスポートカプセル化のエンドポイントによって実行される場合、断片化手順は、トランスポートカプセル化の一部として送信NSHエンティティにおいて実行され、そして再組み立て手順は、トランスポートデカプセル中に受信NSHエンティティにおいて行われますロジックを扱います。いかなる場合にもNSHヘッダの複製におけるそのような断片化の結果であろう。"
    },
    {
      "indent": 3,
      "text": "For example, when the NSH is encapsulated in IP, IP-level fragmentation coupled with Path MTU Discovery (PMTUD) (e.g., [RFC8201]) is used. Since PMTUD relies on ICMP messages, an operator should ensure ICMP packets are not blocked. When, on the other hand, the underlay does not support fragmentation procedures, an error message SHOULD be logged when dropping a packet too big. Lastly, NSH-specific fragmentation and reassembly methods may be defined as well, but these methods are outside the scope of this document and subject for future work.",
      "ja": "NSHをIPでカプセル化されたとき、例えば、パスMTUディスカバリ（PMTUD）（例えば、[RFC8201]）と結合されたIPレベルの断片化が使用されます。 PMTUDがICMPメッセージに依存しているため、オペレータは、ICMPパケットがブロックされていないことを確認する必要があります。一方、アンダーレイが断片化手順をサポートしていない場合には、あまりにも大きなパケットをドロップする場合、エラーメッセージが記録されるべきです。最後に、NSH特異的断片化と再アセンブリ方法は同様に定義することができるが、これらの方法は、今後の作業のために、この文書と主題の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. Service Path Forwarding with NSH",
      "section_title": true,
      "ja": "NSHで転送6.サービスパス"
    },
    {
      "indent": 0,
      "text": "6.1. SFFs and Overlay Selection",
      "section_title": true,
      "ja": "6.1。スキャンフリップフロップとオーバーレイの選択"
    },
    {
      "indent": 3,
      "text": "As described above, the NSH contains a Service Path Identifier (SPI) and a Service Index (SI). The SPI is, as per its name, an identifier. The SPI alone cannot be used to forward packets along a service path. Rather, the SPI provides a level of indirection between the service path / topology and the network transport encapsulation. Furthermore, there is no requirement for, or expectation of, an SPI being bound to a predetermined or static network path.",
      "ja": "上述したように、NSHは、サービス・パス識別子（SPI）とサービスインデックス（SI）を含みます。 SPIは、その名のとおり、識別子です。単独のSPIは、サービスパスに沿ってパケットを転送するために使用することはできません。むしろ、SPIは、サービス・パス/トポロジーおよびネットワーク・トランスポートカプセル化との間の間接のレベルを提供します。また、何の要求、またはSPI、の期待所定のまたは静的なネットワーク経路に結合しているがありません。"
    },
    {
      "indent": 3,
      "text": "The Service Index provides an indication of location within a service path. The combination of SPI and SI provides the identification of a logical SF and its order within the service plane. This combination is used to select the appropriate network locator(s) for overlay forwarding. The logical SF may be a single SF or a set of eligible SFs that are equivalent. In the latter case, the SFF provides load distribution amongst the collection of SFs as needed.",
      "ja": "サービスインデックスは、サービス経路内の位置の表示を提供します。 SPIとSIとの組み合わせは、論理SFおよびサービス・プレーン内での順序の識別を提供します。この組み合わせは、オーバーレイの転送のための適切なネットワークロケータ（複数可）を選択するために使用されます。論理的なSFは、単一のSF又は同等の資格のSF設定することもできます。必要に応じて、後者の場合には、SFFは、SFのコレクションの間で負荷分散を提供します。"
    },
    {
      "indent": 3,
      "text": "SI serves as a mechanism for detecting invalid SFPs. In particular, an SI value of zero indicates that forwarding is incorrect and the packet must be discarded.",
      "ja": "SIは無効SFPを検出するための機構として働きます。特に、ゼロのSI値は、転送が正しくないと、パケットが廃棄されなければならないことを示しています。"
    },
    {
      "indent": 3,
      "text": "This indirection -- SPI to overlay -- creates a true service plane. That is, the SFF/SF topology is constructed without impacting the network topology, but, more importantly, service-plane-only participants (i.e., most SFs) need not be part of the network overlay topology and its associated infrastructure (e.g., control plane, routing tables, etc.). SFs need to be able to return a packet to an appropriate SFF (i.e., has the requisite NSH information) when service processing is complete. This can be via the overlay or underlay and, in some cases, can require additional configuration on the SF. As mentioned above, an existing overlay topology may be used, provided it offers the requisite connectivity.",
      "ja": "この間接 -  SPIをオーバーレイするには - 真のサービス面を作成します。これは、SFF / SFトポロジは、ネットワークトポロジに影響を与えずに構築されている、しかし、もっと重要なのは、サービス・プレーンのみの参加者は（すなわち、ほとんどのSF）は、ネットワーク・オーバーレイ・トポロジーとその関連インフラ（例えば、制御の一部である必要はありません平面、ルーティングテーブル、等）。サービス処理が完了したときのSFは、適切なSFFにパケットを返すことができる必要がある（すなわち、必要なNSH情報を有しています）。これは、オーバーレイまたはアンダーレイを介して行うことができると、いくつかのケースでは、SFの追加設定が必要になることができます。上述したように、既存のオーバレイ・トポロジーを使用することができる、それが必要な接続性を提供しました。"
    },
    {
      "indent": 3,
      "text": "The mapping of SPI to transport encapsulation occurs on an SFF (as discussed above, the first SFF in the path gets an NSH encapsulated packet from the Classifier). The SFF consults the SPI/ID values to determine the appropriate overlay transport encapsulation protocol (several may be used within a given network) and next hop for the requisite SF. Table 1 depicts an example of a single next-hop SPI/ SI-to-network overlay network locator mapping.",
      "ja": "（上述したようにパスの最初のSFFは、分類からNSHカプセル化されたパケットを取得し、）カプセル化を輸送するSPIのマッピングは、SFFに起こります。 SFFは、必要なSFのための適切なオーバーレイトランスポートカプセル化プロトコル（いくつかは所与のネットワーク内で使用されてもよい）、次のホップを決定するために、SPI / ID値を調べ。表1は、単一の次ホップSPI / SI・ツー・ネットワークオーバレイネットワークロケータマッピングの例を示します。"
    },
    {
      "indent": 6,
      "text": "+------+------+---------------------+-------------------------+\n| SPI  | SI   | Next Hop(s)         | Transport Encapsulation |\n+------+------+---------------------+-------------------------+\n| 10   | 255  | 192.0.2.1           | VXLAN-gpe               |\n|      |      |                     |                         |\n| 10   | 254  | 198.51.100.10       | GRE                     |\n|      |      |                     |                         |\n| 10   | 251  | 198.51.100.15       | GRE                     |\n|      |      |                     |                         |\n| 40   | 251  | 198.51.100.15       | GRE                     |\n|      |      |                     |                         |\n| 50   | 200  | 01:23:45:67:89:ab   | Ethernet                |\n|      |      |                     |                         |\n| 15   | 212  | Null (end of path)  | None                    |\n+------+------+---------------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 1: SFF NSH Mapping Example",
      "ja": "表1：SFF NSHマッピングの例"
    },
    {
      "indent": 3,
      "text": "Additionally, further indirection is possible: the resolution of the required SF network locator may be a localized resolution on an SFF, rather than an SFC control plane responsibility, as per Tables 2 and 3.",
      "ja": "また、さらに間接が可能である：必要なSFネットワークロケータの分解能は表2および表3の通りSFFに局在解像度ではなく、SFC制御プレーンの責任であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Please note: VXLAN-gpe and GRE in the above table refer to [VXLAN-GPE] and [RFC2784] [RFC7676], respectively.",
      "ja": "それぞれ、[VXLAN-GPE]を参照して上記の表にVXLAN-GPEおよびGREと[RFC2784]、[RFC7676]に注意してください。"
    },
    {
      "indent": 22,
      "text": "+------+-----+----------------+\n| SPI  | SI  | Next Hop(s)    |\n+------+-----+----------------+\n| 10   | 3   | SF2            |\n|      |     |                |\n| 245  | 12  | SF34           |\n|      |     |                |\n| 40   | 9   | SF9            |\n+------+-----+----------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 2: NSH-to-SF Mapping Example",
      "ja": "表2：NSH-へ-SFマッピングの例"
    },
    {
      "indent": 10,
      "text": "+------+-------------------+-------------------------+\n| SF   | Next Hop(s)       | Transport Encapsulation |\n+------+-------------------+-------------------------+\n| SF2  | 192.0.2.2         | VXLAN-gpe               |\n|      |                   |                         |\n| SF34 | 198.51.100.34     | UDP                     |\n|      |                   |                         |\n| SF9  | 2001:db8::1       | GRE                     |\n+------+-------------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 3: SF Locator Mapping Example",
      "ja": "表3：SFロケータマッピングの例"
    },
    {
      "indent": 3,
      "text": "Since the SPI is a representation of the service path, the lookup may return more than one possible next hop within a service path for a given SF, essentially a series of weighted (equally or otherwise) paths to be used (for load distribution, redundancy, or policy); see Table 4. The metric depicted in Table 4 is an example to help illustrate weighing SFs. In a real network, the metric will range from a simple preference (similar to routing next-hop) to a true dynamic composite metric based on the state of a Service Function (including load, session state, capacity, etc.).",
      "ja": "SPIは、サービス・パスの表現であるので、ルックアップは負荷分散のために使用される加重（均等またはその他）経路の所定のSF、本質的に直列（冗長性のためのサービス経路内の複数の可能な次のホップを返すことができます、またはポリシー）表4に示したメトリックを参照すると、計量サービスフローを例示するのに役立つ例です。実際のネットワークでは、メトリックは、（負荷、セッションの状態、容量、などを含む）サービス機能の状態に基づいて、真の動的な複合メトリックに（ルーティング次ホップに似ている）単純な嗜好の範囲であろう。"
    },
    {
      "indent": 18,
      "text": "+------+-----+--------------+---------+\n| SPI  | SI  | NH           | Metric  |\n+------+-----+--------------+---------+\n| 10   | 3   | 203.0.113.1  | 1       |\n|      |     |              |         |\n|      |     | 203.0.113.2  | 1       |\n|      |     |              |         |\n| 20   | 12  | 192.0.2.1    | 1       |\n|      |     |              |         |\n|      |     | 203.0.113.4  | 1       |\n|      |     |              |         |\n| 30   | 7   | 192.0.2.10   | 10      |\n|      |     |              |         |\n|      |     | 198.51.100.1 | 5       |\n+------+-----+--------------+---------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "(encapsulation type omitted for formatting)",
      "ja": "（書式設定のために省略カプセル化タイプ）"
    },
    {
      "indent": 20,
      "text": "Table 4: NSH Weighted Service Path",
      "ja": "表4：NSH加重サービスパス"
    },
    {
      "indent": 3,
      "text": "The information contained in Tables 1-4 may be received from the control plane, but the exact mechanism is outside the scope of this document.",
      "ja": "表1~4に含まれる情報は、制御プレーンから受信することができるが、正確なメカニズムはこの文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6.2. Mapping the NSH to Network Topology",
      "section_title": true,
      "ja": "6.2。ネットワークトポロジにNSHのマッピング"
    },
    {
      "indent": 3,
      "text": "As described above, the mapping of the SPI to network topology may result in a single path, or it might result in a more complex topology. Furthermore, the SPI-to-overlay mapping occurs at each SFF independently. Any combination of topology selection is possible. Please note, there is no requirement to create a new overlay topology if a suitable one already exists. NSH packets can use any (new or existing) overlay, provided the requisite connectivity requirements are satisfied.",
      "ja": "上述したように、トポロジをネットワークするSPIのマッピングは、単一のパスをもたらすことができる、またはそれは、より複雑なトポロジーをもたらすかもしれません。また、SPI-にオーバーレイマッピングは、それぞれ独立してSFFで起こります。トポロジの選択の任意の組み合わせが可能です。適切なものがすでに存在する場合、新たなオーバーレイ・トポロジーを作成する必要はありません、ご注意ください。 NSHパケットが任意の（新規または既存）のオーバーレイを使用することができ、必要な接続要件が満たされて。"
    },
    {
      "indent": 3,
      "text": "Examples of mapping for a topology:",
      "ja": "トポロジのマッピングの例："
    },
    {
      "indent": 3,
      "text": "1. Next SF is located at SFFb with locator 2001:db8::1 SFFa mapping: SPI=10 --> VXLAN-gpe, dst-ip: 2001:db8::1",
      "ja": "1.次にSFは、ロケータ2001 SFFbに配置されている：DB8 :: 1 SFFaマッピング：SPI = 10  - > VXLAN-GPE、DST-IP：2001：DB8を:: 1"
    },
    {
      "indent": 3,
      "text": "2. Next SF is located at SFFc with multiple network locators for load-distribution purposes: SFFb mapping: SPI=10 --> VXLAN-gpe, dst_ip:203.0.113.1, 203.0.113.2, 203.0.113.3, equal cost",
      "ja": "2.次にSFは、負荷分散の目的で、複数のネットワークロケータとSFFCに配置されている：SFFbマッピング：SPI = 10  - > VXLAN-GPE、dst_ip：203.0.113.1、203.0.113.2、203.0.113.3、等しいコスト"
    },
    {
      "indent": 3,
      "text": "3. Next SF is located at SFFd with two paths from SFFc, one for redundancy: SFFc mapping: SPI=10 --> VXLAN-gpe, dst_ip:192.0.2.10 cost=10, 203.0.113.10, cost=20",
      "ja": "3.次にSFはSFFC、冗長性のための1つから二つの経路でSFFDに配置されている：SFFCマッピング：SPI = 10  - > VXLAN-GPE、dst_ip：192.0.2.10コスト= 10、203.0.113.10、コスト= 20"
    },
    {
      "indent": 3,
      "text": "In the above example, each SFF makes an independent decision about the network overlay path and policy for that path. In other words, there is no a priori mandate about how to forward packets in the network (only the order of services that must be traversed).",
      "ja": "上記の例では、各SFFは、そのパスに対するネットワーク・オーバーレイ・パスおよびポリシーについて独立決定を行います。言い換えれば、ネットワーク（トラバースしなければならないサービスの唯一の順）にパケットを転送する方法について先験的義務はありません。"
    },
    {
      "indent": 3,
      "text": "The network operator retains the ability to engineer the network paths as required. For example, the overlay path between SFFs may utilize traffic engineering, QoS marking, or ECMP, without requiring complex configuration and network protocol support to be extended to the service path explicitly. In other words, the network operates as expected, and evolves as required, as does the service plane.",
      "ja": "ネットワークオペレータは、必要に応じてネットワークパスを設計する能力を保持しています。例えば、スキャンフリップフロップとの間のオーバレイ経路がQoSが明示的サービス・パスに拡張するための複雑な構成とネットワークプロトコルのサポートを必要とせずに、マーキング、又はECMP、トラフィックエンジニアリングを利用してもよいです。サービス・プレーンと同様に、換言すれば、ネットワークが期待通りに動作し、必要に応じて進化します。"
    },
    {
      "indent": 0,
      "text": "6.3. Service Plane Visibility",
      "section_title": true,
      "ja": "6.3。サービス面の可視性"
    },
    {
      "indent": 3,
      "text": "The SPI and SI serve an important function for visibility into the service topology. An operator can determine what service path a packet is \"on\" and its location within that path simply by viewing NSH information (packet capture, IP Flow Information Export (IPFIX), etc.). The information can be used for service scheduling and placement decisions, troubleshooting, and compliance verification.",
      "ja": "SPIおよびSIは、サービス・トポロジーを可視化するための重要な機能を果たします。オペレータは、パケットは、単にNSH情報（パケットキャプチャ、IPフロー情報のエクスポート（IPFIX）、など）を表示することによって、そのパスの中に「上」と、その場所でどのようなサービスのパスを決定することができます。情報は、サービスのスケジューリングと配置を決定、トラブルシューティング、およびコンプライアンスの検証に使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.4. Service Graphs",
      "section_title": true,
      "ja": "6.4。サービスグラフ"
    },
    {
      "indent": 3,
      "text": "While a given realized SFP is a specific sequence of Service Functions, the service, as seen by a user, can actually be a collection of SFPs, with the interconnection provided by Classifiers (in-service path, non-initial re-classification). These internal re-Classifiers examine the packet at relevant points in the network, and, if needed, SPI and SI are updated (whether this update is a re-write, or the imposition of a new NSH with new values is implementation specific) to reflect the \"result\" of the classification. These Classifiers may, of course, also modify the metadata associated with the packet. Section 2.1 of [RFC7665] describes Service Graphs in detail.",
      "ja": "所与の実現SFPは、サービス関数の特定の配列であるが、このサービスは、ユーザによって見られるように、実際の分類子（インサービス経路、非初期の再分類）により提供される配線と、のSFPの集合とすることができます。これらの内部の再分類器は、ネットワーク内の関連するポイントでパケットを調べ、そして、必要に応じて、SPIおよびSIが更新されると（この更新は、再書き込み、または新しい値を持つ新しいNSHの賦課であるかどうかは実装固有のものです）分類の「結果」を反映しています。これらの分類器は、もちろん、また、パケットに関連付けられたメタデータを変更することがあります。 [RFC7665]の2.1節を詳細にサービスグラフを示しています。"
    },
    {
      "indent": 0,
      "text": "7. Policy Enforcement with NSH",
      "section_title": true,
      "ja": "NSH 7.ポリシー施行"
    },
    {
      "indent": 0,
      "text": "7.1. NSH Metadata and Policy Enforcement",
      "section_title": true,
      "ja": "7.1。 NSHメタデータとポリシー施行"
    },
    {
      "indent": 3,
      "text": "As described in Section 2, NSH provides the ability to carry metadata along a service path. This metadata may be derived from several sources. Common examples include:",
      "ja": "第2節で説明したように、NSH、サービス経路に沿ってメタデータを搬送する能力を提供します。このメタデータは、いくつかの供給源から誘導することができます。一般的な例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Network nodes/devices: Information provided by network nodes can indicate network-centric information (such as VPN Routing and Forwarding (VRF) or tenant) that may be used by Service Functions or conveyed to another network node post service path egress.",
      "ja": "ネットワーク・ノード/装置：ネットワークノードによって提供される情報は、サービスの機能によって使用されるか、または他のネットワークノードポストサービス経路出口へと搬送することができる（例えば、VPNルーティングおよび転送（VRF）またはテナントのような）ネットワーク中心の情報を示すことができます。"
    },
    {
      "indent": 6,
      "text": "External (to the network) systems: External systems, such as orchestration systems, often contain information that is valuable for Service Function policy decisions. In most cases, this information cannot be deduced by network nodes. For example, a cloud orchestration platform placing workloads \"knows\" what application is being instantiated and can communicate this information to all NSH nodes via metadata carried in the Context Header(s).",
      "ja": "外部システム（ネットワークに）：そのようなオーケストレーションシステムなどの外部システム、多くの場合、サービス機能の政策決定のための貴重な情報が含まれています。ほとんどの場合、この情報は、ネットワークノードによって推定することはできません。例えば、ワークロードを配置するクラウドオーケストレーションプラットフォームは、どのアプリケーションがインスタンス化されるとコンテキストヘッダ（単数または複数）で運ばれたメタデータを介してすべてのNSHノードにこの情報を通信することができる「知っています」。"
    },
    {
      "indent": 6,
      "text": "Service Functions: A Classifier co-resident with Service Functions often performs very detailed and valuable classification.",
      "ja": "サービス機能：サービス関数と分類子の共存は、多くの場合、非常に詳細かつ貴重な分類を行います。"
    },
    {
      "indent": 3,
      "text": "Regardless of the source, metadata reflects the \"result\" of classification. The granularity of classification may vary. For example, a network switch, acting as a Classifier, might only be able to classify based on a 2-tuple, or based on a 5-tuple, while a Service Function may be able to inspect application information. Regardless of granularity, the classification information can be represented in the NSH.",
      "ja": "ソースに関係なく、メタデータは、分類の「結果」を反映しています。分類の細かさが異なる場合があります。例えば、ネットワークスイッチは、分類子として作用するのみサービス機能は、アプリケーション情報を検査することができるかもしれないが、2タプルに基づいて、または5タプルに基づいて分類することができるかもしれません。かかわらず、粒度の、分類情報は、NSHで表現することができます。"
    },
    {
      "indent": 3,
      "text": "Once the data is added to the NSH, it is carried along the service path. NSH-aware SFs receive the metadata, and can use that metadata for local decisions and policy enforcement. Figures 9 and 10 highlight the relationship between metadata and policy.",
      "ja": "データはNSHに追加されると、それはサービス経路に沿って搬送されます。 NSH-意識のSFは、メタデータを受信し、地元の意思決定とポリシー適用のためにそのメタデータを使用することができます。図9および10は、メタデータと政策との関係を強調しました。"
    },
    {
      "indent": 16,
      "text": "+-------+        +-------+        +-------+\n|  SFF  )------->(  SFF  |------->|  SFF  |\n+---+---+        +---+---+        +---+---+\n    ^                |                |\n  ,-|-.            ,-|-.            ,-|-.\n /     \\          /     \\          /     \\\n( Class )        (  SF1  )        (  SF2  )\n \\ ify /          \\     /          \\     /\n  `---'            `---'            `---'\n 5-tuple:        Permit             Inspect\n Tenant A        Tenant A           AppY\n AppY",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 9: Metadata and Policy",
      "ja": "図9：メタデータとポリシー"
    },
    {
      "indent": 14,
      "text": " +-----+           +-----+            +-----+\n | SFF |---------> | SFF |----------> | SFF |\n +--+--+           +--+--+            +--+--+\n    ^                 |                  |\n  ,-+-.             ,-+-.              ,-+-.\n /     \\           /     \\            /     \\\n( Class )         (  SF1  )          (  SF2  )\n \\ ify /           \\     /            \\     /\n  `-+-'             `---'              `---'\n    |              Permit            Deny AppZ\n+---+---+          employees\n|       |\n+-------+\nExternal\nsystem:\nEmployee\nAppZ",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 10: External Metadata and Policy",
      "ja": "図10：外部メタデータとポリシー"
    },
    {
      "indent": 3,
      "text": "In both of the examples above, the Service Functions perform policy decisions based on the result of the initial classification: the SFs did not need to perform re-classification; instead, they rely on an antecedent classification for local policy enforcement.",
      "ja": "上記の例の両方で、サービス関数は、最初の分類結果に基づいて政策決定を行う：SFを再分類を実行する必要はありませんでした。代わりに、彼らは、ローカルポリシーの施行のための先行分類に依存しています。"
    },
    {
      "indent": 3,
      "text": "Depending on the information carried in the metadata, data privacy impact needs to be considered. For example, if the metadata conveys tenant information, that information may need to be authenticated and/or encrypted between the originator and the intended recipients (which may include intended SFs only); one approach to an optional capability to do this is explored in [NSH-ENCRYPT]. The NSH itself does not provide privacy functions, rather it relies on the transport encapsulation/overlay. An operator can select the appropriate set of transport encapsulation protocols to ensure confidentiality (and other security) considerations are met. Metadata privacy and security considerations are a matter for the documents that define metadata format.",
      "ja": "メタデータで運ばれた情報に応じて、データのプライバシーへの影響を考慮する必要があります。メタデータは、テナント情報を伝達する場合、その情報は、認証および/または発信元と受信者（のみ意図されたSFを含んでいてもよい）との間で暗号化される必要があるかもしれません。これを行うためのオプションの機能への1つのアプローチは、[NSH-ENCRYPT]で検討されています。 NSH自体は、むしろそれは、トランスポートのカプセル化/オーバーレイに依存して、プライバシー機能を提供していません。オペレータは、考慮事項が満たされている機密性（およびその他のセキュリティ）を確保するために、トランスポートカプセル化プロトコルの適切なセットを選択することができます。メタデータのプライバシーとセキュリティの考慮事項は、メタデータフォーマットを定義する文書のための問題です。"
    },
    {
      "indent": 0,
      "text": "7.2. Updating/Augmenting Metadata",
      "section_title": true,
      "ja": "7.2。更新/増強メタデータ"
    },
    {
      "indent": 3,
      "text": "Post-initial metadata imposition (typically, performed during initial service path determination), the metadata may be augmented or updated:",
      "ja": "後最初のメタデータの賦課（典型的には、初期サービス経路決定時に実行される）、メタデータは、拡張または更新されてもよいです。"
    },
    {
      "indent": 3,
      "text": "1. Metadata Augmentation: Information may be added to the NSH's existing metadata, as depicted in Figure 11. For example, if the initial classification returns the tenant information, a secondary classification (perhaps co-resident with deep packet inspection (DPI) or server load balancing (SLB)) may augment the tenant classification with application information, and impose that new information in NSH metadata. The tenant classification is still valid and present, but additional information has been added to it.",
      "ja": "1.メタデータ増強：図11に示されているような情報は、NSHの既存のメタデータに追加してもよい。例えば、初期の分類は、テナント情報、二次区分（ディープパケットインスペクション（DPI）またはサーバと恐らく共存を返す場合ロードバランシング（SLB））は、アプリケーション情報とテナントの分類を強化し、NSHメタデータでその新しい情報を課すことができます。テナントの分類はまだ有効と存在しているが、追加の情報が追加されました。"
    },
    {
      "indent": 3,
      "text": "2. Metadata Update: Subsequent Classifiers may update the initial classification if it is determined to be incorrect or not descriptive enough. For example, the initial Classifier adds metadata that describes the traffic as \"Internet\", but a security Service Function determines that the traffic is really \"attack\". Figure 12 illustrates an example of updating metadata.",
      "ja": "2.メタデータの更新：正しくないか、十分に説明的でないと判断された場合以降のクラシファイアは、初期分類を更新することができます。たとえば、最初のクラシファイアは、「インターネット」としてトラフィックを記述したメタデータが追加されますが、セキュリティサービス機能は、トラフィックが実際に「攻撃」であると判断します。図12は、メタデータを更新する例を示しています。"
    },
    {
      "indent": 14,
      "text": " +-----+           +-----+            +-----+\n | SFF |---------> | SFF |----------> | SFF |\n +--+--+           +--+--+            +--+--+\n    ^                 |                  |\n  ,---.             ,---.              ,---.\n /     \\           /     \\            /     \\\n( Class )         (  SF1  )          (  SF2  )\n \\     /           \\     /            \\     /\n  `-+-'             `---'              `---'\n    |              Inspect           Deny\n+---+---+          employees         employee+\n|       |          Class=AppZ        appZ\n+-------+\nExternal\nsystem:\nEmployee",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 11: Metadata Augmentation",
      "ja": "図11：メタデータの増強"
    },
    {
      "indent": 14,
      "text": "  +-----+           +-----+            +-----+\n  | SFF |---------> | SFF |----------> | SFF |\n  +--+--+           +--+--+            +--+--+\n     ^                 |                  |\n   ,---.             ,---.              ,---.\n  /     \\           /     \\            /     \\\n ( Class )         (  SF1  )          (  SF2  )\n  \\     /           \\     /            \\     /\n   `---'             `---'              `---'\n5-tuple:            Inspect             Deny\nTenant A            Tenant A            attack\n                     --> attack",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 12: Metadata Update",
      "ja": "図12：メタデータの更新"
    },
    {
      "indent": 0,
      "text": "7.3. Service Path Identifier and Metadata",
      "section_title": true,
      "ja": "7.3。サービスパス識別子とメタデータ"
    },
    {
      "indent": 3,
      "text": "Metadata information may influence the service path selection since the Service Path Identifier values can represent the result of classification. A given SPI can be defined based on classification results (including metadata classification). The imposition of the SPI and SI results in the packet being placed on the newly specified SFP at the position indicated by the imposed SPI and SI.",
      "ja": "サービスパス識別子値が分類の結果を表すことができるので、メタデータ情報は、サービス経路の選択に影響を及ぼし得ます。与えられたSPIは、（メタデータの分類を含む）の分類結果に基づいて定義することができます。 SPIとSIの賦課は課さSPIとSIで示される位置に、新たに指定されたSFP上に配置されているパケットになります。"
    },
    {
      "indent": 3,
      "text": "This relationship provides the ability to create a dynamic service plane based on complex classification, without requiring each node to be capable of such classification or requiring a coupling to the network topology. This yields Service Graph functionality as described in Section 6.4. Figure 13 illustrates an example of this behavior.",
      "ja": "この関係は、このような分類することができるように各ノードを必要とするか、ネットワークトポロジへの結合を必要とせず、複雑な分類に基づいて動的なサービス・プレーンを作成する能力を提供します。 6.4節で述べたように、これはサービスグラフの機能が得られます。図13は、この動作の例を示す図です。"
    },
    {
      "indent": 13,
      "text": "  +-----+           +-----+            +-----+\n  | SFF |---------> | SFF |------+---> | SFF |\n  +--+--+           +--+--+      |     +--+--+\n     |                 |         |        |\n   ,---.             ,---.       |      ,---.\n  /     \\           / SF1 \\      |     /     \\\n (  SCL  )         (   +   )     |    (  SF2  )\n  \\     /           \\SCL2 /      |     \\     /\n   `---'             `---'    +-----+   `---'\n5-tuple:            Inspect   | SFF |    Original\nTenant A            Tenant A  +--+--+    next SF\n                     --> DoS     |\n                                 V\n                               ,-+-.\n                              /     \\\n                             (  SF10 )\n                              \\     /\n                               `---'\n                                DoS\n                             \"Scrubber\"",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Legend: SCL = Service Classifier",
      "ja": "凡例：SCL =サービスクラシ"
    },
    {
      "indent": 22,
      "text": "Figure 13: Path ID and Metadata",
      "ja": "図13：パスIDとメタデータ"
    },
    {
      "indent": 3,
      "text": "Specific algorithms for mapping metadata to an SPI are outside the scope of this document.",
      "ja": "SPIにマッピングするメタデータのための特定のアルゴリズムは、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "NSH security must be considered in the contexts of the SFC architecture and operators' environments. One important characteristic of NSH is that it is not an end-to-end protocol. As opposed to a protocol that \"starts\" on a host and \"ends\" on a server or another host, NSH is typically imposed by a network device on ingress to the SFC domain and removed at the egress of the SFC domain. As such, and as with any other network-centric protocols (e.g., IP Tunneling, Traffic Engineering, MPLS, or Provider-Provisioned Virtual Private Networks), there is an underlying trust in the network devices responsible for imposing, removing, and acting on NSH information.",
      "ja": "NSHセキュリティはSFCアーキテクチャのコンテキストと事業者の環境に考慮しなければなりません。 NSHの一つの重要な特徴は、エンドツーエンドのプロトコルではないということです。プロトコルとは対照的に、ホスト上の「開始」およびサーバまたは別のホスト上の「終了」は、NSHは、典型的には、SFCドメインに入力上のネットワークデバイスによって課さ及びSFCドメインの出口で除去されます。そのため、他のネットワーク中心のプロトコル（例えば、IPトンネリング、トラフィックエンジニアリング、MPLS、またはプロバイダ・プロビジョニングされた仮想プライベートネットワーク）のように、堂々削除、および上の演技を担当するネットワーク機器における基本的な信頼がありますNSH情報。"
    },
    {
      "indent": 3,
      "text": "The following sections detail an analysis and present a set of requirements and recommendations in those two areas.",
      "ja": "以下のセクションの詳細を分析し、それらの二つの領域に要件と推奨事項のセットを提示します。"
    },
    {
      "indent": 0,
      "text": "8.1. NSH Security Considerations from Operators' Environments",
      "section_title": true,
      "ja": "8.1。オペレーターの環境からNSHセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Trusted Devices",
      "ja": "信頼できるデバイス"
    },
    {
      "indent": 6,
      "text": "All Classifiers, SFFs and SFs (hereinafter referred to as \"SFC devices\") within an operator's environment are assumed to have been selected, vetted, and actively maintained; therefore, they are trusted by that operator. This assumption differs from the oft held view that devices are untrusted, often referred to as the \"zero-trust model\". Operators SHOULD regularly monitor (i.e., continuously audit) these devices to help ensure compliant behavior. This trust, therefore, extends into NSH operations: SFC devices are not, themselves, considered to be attack vectors. This assumption, and the resultant conclusion is reasonable since this is the very basis of an operator posture; the operator depends on this reality to function. If these devices are not trusted, and indeed are compromised, almost the entirety of the operator's standard-based IP and MPLS protocol suites are vulnerable; therefore, the operation of the entire network is compromised. Although there are well-documented monitoring-based methods for detecting compromise (such as included continuous monitoring and audit and log review), these may not be sufficient to contain damage by a completely compromised element.",
      "ja": "オペレータの環境内のすべての分類子、スキャンフリップフロップおよびSFS（以下「SFC装置」と呼ぶ）が、選択されたと仮定吟味、積極的に維持されます。そのため、彼らはそのオペレータによって信頼されています。この仮定は、多くの場合、「ゼロ・信頼モデル」と呼ばれるデバイスが信頼されていないことをしばしば開催されたビューとは異なります。オペレータは、定期的に準拠した動作を確保するために、これらのデバイスを（すなわち、継続的に監査）監視する必要があります。この信頼は、それゆえ、NSH操作中に延び：SFCデバイスは攻撃ベクトルであると考えられ、それ自身ではありません。これは、オペレータの姿勢は非常に基礎であるので、これを前提として、得られた結論は妥当です。オペレータが機能するために、この現実に依存します。これらのデバイスが侵害された確かに信頼され、されていない場合は、オペレータの標準ベースのIPおよびMPLSプロトコルスイートのほぼ全体が脆弱です。従って、全体のネットワークの動作が損なわれています。 （そのような付属連続監視および監査レビューをログとして）妥協点を検出するためのモニタリングに基づく方法が十分に立証されているが、これらは完全に損なわ要素による損傷を含むのに十分ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "Methods and best practices to secure devices are also widely documented and outside the scope of this document.",
      "ja": "デバイスを固定するための方法およびベストプラクティスも広く文書化され、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Single Domain Boundary",
      "ja": "単一ドメイン境界"
    },
    {
      "indent": 6,
      "text": "As per [RFC7665], NSH is designed for use within a single administrative domain. This scoping provides two important characteristics:",
      "ja": "[RFC7665]に従って、NSHは、単一の管理ドメイン内で使用するために設計されています。このスコープは、2つの重要な特性を提供します。"
    },
    {
      "indent": 6,
      "text": "i) Clear NSH boundaries",
      "ja": "I）をクリアNSH境界"
    },
    {
      "indent": 6,
      "text": "NSH egress devices MUST strip the NSH headers before they send the users' packets or frames out of the NSH domain.",
      "ja": "彼らはNSHドメインのうち、ユーザのパケットまたはフレームを送信する前にNSH出力デバイスは、NSHヘッダーを削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Means to prevent leaking privacy-related information outside an administrative domain are natively supported by the NSH given that the last SFF of a service path will systematically remove the NSH encapsulation before forwarding a packet exiting the service path.",
      "ja": "ネイティブサービスパスの最後のSFFが体系サービスパスを終了し、パケットを転送する前にNSHのカプセル化を削除することを指定したNSHによってサポートされている管理ドメイン外のプライバシー関連情報の漏洩を防止することを意味します。"
    },
    {
      "indent": 6,
      "text": "The second step in such prevention is to filter the transport encapsulation protocol used by NSH at the domain edge. The transport encapsulation protocol MUST be filtered and MUST NOT leave the domain edge.",
      "ja": "そのような予防の2番目のステップは、ドメインエッジでNSHによって使用されるトランスポート・カプセル化プロトコルをフィルタリングすることです。トランスポート・カプセル化プロトコルがフィルタリングされなければならないし、ドメインエッジを残してはいけません。"
    },
    {
      "indent": 6,
      "text": "Depending upon the transport encapsulation protocol used for NSH, this can be done either by completely blocking the transport encapsulation (e.g., if MPLS is the chosen NSH transport encapsulation protocol, it is therefore never allowed to leave the domain) or by examining the carried protocol with the transport encapsulation (e.g., if VXLAN-gpe is used as the NSH transport encapsulation protocol, all domain edges need to filter based on the carried protocol in the VXLAN-gpe.)",
      "ja": "NSHのために使用されるトランスポートカプセル化プロトコルに応じて、これは完全に輸送カプセル化を遮断することによって（MPLSが選ばれたNSH輸送カプセル化プロトコルである場合、例えば、ので、ドメインを残すことが許されることはありません）、または実施のプロトコルを調べることによってのいずれかで行うことができますトランスポート・カプセル化（VXLAN-GPEはNSH輸送カプセル化プロトコルとして使用される場合、例えば、全てのドメインのエッジはVXLAN-GPEで実施プロトコルに基づいてフィルタリングする必要があります。）"
    },
    {
      "indent": 6,
      "text": "The other consequence of this bounding is that ingress packets MUST also be filtered to prevent attackers from sending in NSH packets with service path identification and metadata of their own selection. The same filters as described above for both the NSH at SFC devices and for the transport encapsulation protocol as general edge protections MUST be applied on ingress.",
      "ja": "この境界の他の結果は、入力パケットは、独自の選択のサービスパスの識別とメタデータとNSHパケット内の送信からの攻撃を防ぐためにフィルタリングされなければならないということです。 SFC装置でNSH及び一般的なエッジの保護などのトランスポート・カプセル化プロトコルの両方について上述したのと同じフィルタが入力に適用されなければなりません。"
    },
    {
      "indent": 6,
      "text": "In summary, packets originating outside the SFC-enabled domain MUST be dropped if they contain an NSH. Similarly, packets exiting the SFC-enabled domain MUST be dropped if they contain an NSH.",
      "ja": "彼らはNSHが含まれている場合要約すると、SFC対応のドメイン外に発信さパケットは廃棄されなければなりません。彼らはNSHが含まれている場合は同様に、SFC対応のドメインを出て行くパケットは廃棄されなければなりません。"
    },
    {
      "indent": 6,
      "text": "ii) Mitigation of external threats",
      "ja": "ⅱ）外部からの脅威の軽減を"
    },
    {
      "indent": 6,
      "text": "As per the trusted SFC device points raised above, given that NSH is scoped within an operator's domain, that operator can ensure that the environment and its transitive properties comply with that operator's required security posture. Continuous audits for assurance are recommended with this reliance on a fully trusted environment. The term \"continuous audits\" describes a method (automated or manual) of checking security-control compliance on a regular basis, at some set period of time.",
      "ja": "NSHは、オペレータのドメイン内でスコープされていることを考えると、上記の引き上げ信頼できるSFCデバイスポイントごとに、そのオペレータは、環境とその推移の特性は、そのオペレータの必要なセキュリティ姿勢に準拠していることを確認することができます。保証のための継続的な監査は、完全に信頼できる環境でこの依存で推奨されています。用語「連続監査は、」時間のいくつかの設定した周期で、定期的にセキュリティ・コントロールのコンプライアンスをチェックする方法（自動または手動）について説明します。"
    },
    {
      "indent": 0,
      "text": "8.2. NSH Security Considerations from the SFC Architecture",
      "section_title": true,
      "ja": "8.2。 SFCのアーキテクチャからNSHセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The SFC architecture defines functional roles (e.g., SFF), as well as protocol elements (e.g., Metadata). This section considers each role and element in the context of threats posed in the areas of integrity and confidentiality. As with routing, the distributed computation model assumes a distributed trust model.",
      "ja": "SFCアーキテクチャは、機能的役割（例えば、SFF）、ならびにプロトコル要素（例えば、メタデータ）を定義します。このセクションでは、完全性と機密性の分野で脅威の文脈におけるそれぞれの役割や要素を考慮しています。ルーティングと同様に、分散型計算モデルは、分散型信頼モデルを仮定する。"
    },
    {
      "indent": 3,
      "text": "An important consideration is that NSH contains mandatory-to-mute fields, and further, the SFC architecture describes cases where other fields in NSH change, all on a possible SFP hop-by-hop basis. This means that any cryptographic solution requires complex key distribution and life-cycle operations.",
      "ja": "考慮すべき重要な点は、NSHは必須ツーミュートのフィールドが含まれていることで、さらに、SFCのアーキテクチャは、可能なSFPのホップバイホップベースでNSHの変更の他のフィールドの場合、すべてを説明しています。これは、任意の暗号化ソリューションは、複雑な鍵の配布やライフサイクル操作を必要とすることを意味します。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Integrity",
      "section_title": true,
      "ja": "8.2.1。整合性"
    },
    {
      "indent": 3,
      "text": "SFC devices",
      "ja": "SFCデバイス"
    },
    {
      "indent": 6,
      "text": "SFC devices MAY perform various forms of verification on received NSH packets such as only accepting NSH packets from expected devices, checking that NSH SPI and SI values received from expected devices conform to expected values and so on. Implementation of these additional checks are a local matter and, thus, out of scope of this document.",
      "ja": "SFC装置はNSH SPIとSIが期待装置から受信した値ことを確認するように期待値に適合し、そのようなだけ期待デバイスからNSHパケットを受け入れ、受信NSHパケットに対して検証の様々な形態を実行することができます。これらの追加チェックの実施は、この文書の範囲の外に、このように、ローカルの問題であり、。"
    },
    {
      "indent": 3,
      "text": "NSH Base and Service Path Headers",
      "ja": "NSH基本とサービスパスのヘッダー"
    },
    {
      "indent": 6,
      "text": "Attackers who can modify packets within the operator's network may be able to modify the SFP, path position, and/or the metadata associated with a packet.",
      "ja": "オペレータのネットワーク内でパケットを変更することができ、攻撃者は、SFP、パスの位置、及び/又はパケットに関連付けられたメタデータを変更することができるかもしれません。"
    },
    {
      "indent": 6,
      "text": "One specific concern is an attack in which a malicious modification of the SPI/SI results in an alteration of the path to avoid security devices. The options discussed in this section help thwart that attack, and so does the use of the optional \"Proof of Transit\" method [PROOF-OF-TRANSIT].",
      "ja": "一つの具体的な懸念は、SPI / SIの悪意のある変更はセキュリティデバイスを避けるために、パスの変更につながるした攻撃です。このセクションで説明するオプションは、その攻撃を阻止助けるなど法[PROOF-OF-TRANSIT]オプション「トランジットの証明」の使用を行います。"
    },
    {
      "indent": 6,
      "text": "As stated above, SFC devices are trusted; in the case where an SFC device is compromised, NSH integrity protection would be subject to forging (in many cases) as well.",
      "ja": "上述したように、SFCデバイスは、信頼されています。 SFC装置が危険にさらされた場合に、NSH完全性保護は、同様に（多くの場合）鍛造を受けるであろう。"
    },
    {
      "indent": 6,
      "text": "NSH itself does not mandate protocol-specific integrity protection. However, if an operator deems protection is required, several options are viable:",
      "ja": "NSH自体は、プロトコル固有の完全性保護を強制しません。オペレータは、保護が必要なと判断した場合には、いくつかのオプションが実行可能です。"
    },
    {
      "indent": 6,
      "text": "1. SFF/SF NSH verification",
      "section_title": true,
      "ja": "1. SFF / SF NSH検証"
    },
    {
      "indent": 10,
      "text": "Although, strictly speaking, not integrity protection, some of\nthe techniques mentioned above, such as checking expected NSH\nvalues are received from expected SFC device(s), can provide a\nform of verification without incurring the burden of a full-\nfledged integrity-protection deployment.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "2. Transport Security",
      "section_title": true,
      "ja": "2.トランスポート・セキュリティ"
    },
    {
      "indent": 10,
      "text": "NSH is always encapsulated by an outer transport encapsulation\nas detailed in Section 4 of this specification, and as\ndepicted in Figure 1.  If an operator deems cryptographic\nintegrity protection necessary due to their risk analysis,\nthen an outer transport encapsulation that provides such\nprotection [RFC6071], such as IPsec, MUST be used.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Although the threat model and recommendations of Section 5 of BCP 72 [RFC3552] would normally require cryptographic data origin authentication for the header, this document does not mandate such mechanisms in order to reflect the operational and technical realities of deployment.",
      "ja": "脅威モデルとBCP 72のセクション5の勧告は、[RFC3552]通常、ヘッダーのための暗号データ​​発信元認証を必要とするが、この文書は、展開の運用と技術的な現実を反映させるために、このようなメカニズムを強制しません。"
    },
    {
      "indent": 10,
      "text": "Given that NSH is transport independent, as mentioned above, a secure transport, such as IPsec can be used for carry NSH. IPsec can be used either alone or in conjunction with other transport encapsulation protocols, in turn, encapsulating NSH.",
      "ja": "上述したようにNSHは、トランスポート独立していることを考えると、IPsecなどの安全な輸送は、キャリーNSHのために使用することができます。 IPsecはNSHをカプセル化し、今度は、単独で、または他のトランスポートカプセル化プロトコルと組み合わせて使用​​することができます。"
    },
    {
      "indent": 10,
      "text": "Operators MUST ensure the selected transport encapsulation protocol can be supported by the transport encapsulation/ underlay of all relevant network segments as well as SFFs, SFs, and SFC Proxies in the service path.",
      "ja": "選択されたトランスポート・カプセル化プロトコルを確保しなければならない事業者は、サービス・パスにおけるトランスポートカプセル化/関連するすべてのネットワークセグメントの下敷きならびにスキャンフリップフロップ、サービスフロー、及びSFCプロキシによってサポートすることができます。"
    },
    {
      "indent": 10,
      "text": "If connectivity between SFC-enabled devices traverses the public Internet, then such connectivity MUST be secured at the transport encapsulation layer. IPsec is an example of such a transport.",
      "ja": "SFC対応デバイス間の接続は、公衆インターネットを横断した場合、そのような接続は、トランスポートカプセル化層に固定されなければなりません。 IPsecは、そのような輸送の一例です。"
    },
    {
      "indent": 6,
      "text": "3. NSH Variable Header-Based Integrity",
      "section_title": true,
      "ja": "3. NSH可変ヘッダー・ベースのIntegrity"
    },
    {
      "indent": 10,
      "text": "Lastly, NSH MD Type 2 provides, via variable-length headers,\nthe ability to append cryptographic integrity protection to\nthe NSH packet.  The implementation of such a scheme is\noutside the scope of this document.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NSH metadata",
      "ja": "NSHメタデータ"
    },
    {
      "indent": 6,
      "text": "As with the Base and Service Path Headers, if an operator deems cryptographic integrity protection needed, then an existing, standard transport protocol MUST be used since the integrity protection applies to entire encapsulated NSH packets. As mentioned above, a risk assessment that deems data-plane traffic subject to tampering will apply not only to NSH but to the transport information; therefore, the use of a secure transport is likely needed already to protect the entire stack.",
      "ja": "オペレータが必要な暗号の完全性保護を認めるときは、完全性保護が全体のカプセル化されたNSHパケットに適用されますので、基本とサービスパスヘッダと同じように、既存の標準的なトランスポートプロトコルを使用しなければなりません。前述したように、改ざんへのデータプレーントラフィックの件名をと考えるリスクアセスメントは、NSHではなく交通情報に限らず適用されます。そのため、安全な輸送の利用は可能性の高いスタック全体を保護するためにすでに必要とされています。"
    },
    {
      "indent": 6,
      "text": "If an MD Type 2 variable header integrity scheme is in place, then the integrity of the metadata can be ensured via that mechanism as well.",
      "ja": "MDタイプ2可変ヘッダ完全性スキームが適所にある場合、メタデータの整合性は、同様にその機構を介して確保することができます。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Confidentiality",
      "section_title": true,
      "ja": "8.2.2。機密性"
    },
    {
      "indent": 3,
      "text": "SFC devices",
      "ja": "SFCデバイス"
    },
    {
      "indent": 6,
      "text": "SFC devices can \"see\" (and need to use) NSH information.",
      "ja": "SFCデバイスは「を参照してください。」（および使用する必要があります）NSH情報をすることができます。"
    },
    {
      "indent": 3,
      "text": "NSH Base and Service Path Headers",
      "ja": "NSH基本とサービスパスのヘッダー"
    },
    {
      "indent": 6,
      "text": "SPI and other base / service path information does not typically require confidentiality; however, if an operator does deem confidentiality to be required, then, as with integrity, an existing transport encapsulation that provides encryption MUST be utilized.",
      "ja": "SPIおよび他のベース/サービスのパス情報は、一般的に機密性を必要としません。しかし、オペレータは、整合性、暗号化を利用しなければならない提供し、既存のトランスポートでカプセル化されたとして、その後、必要とされることが機密性を考えるない場合。"
    },
    {
      "indent": 3,
      "text": "NSH metadata",
      "ja": "NSHメタデータ"
    },
    {
      "indent": 6,
      "text": "An attacker with access to the traffic in an operator's network can potentially observe the metadata NSH carries with packets, potentially discovering privacy-sensitive information.",
      "ja": "オペレータのネットワークにおけるトラフィックへのアクセス権を持つ攻撃者は、潜在的に、プライバシーに敏感な情報を発見し、NSHは、パケットを運ぶメタデータを観察することができます。"
    },
    {
      "indent": 6,
      "text": "Much of the metadata carried by NSH is not sensitive. It often reflects information that can be derived from the underlying packet or frame. Direct protection of such information is not necessary, as the risks are simply those of carrying the underlying packet or frame.",
      "ja": "NSHによって運ばれるメタデータの多くは敏感ではありません。それは多くの場合、基本的なパケットまたはフレームから得ることができる情報を反映しています。リスクは、単に基本的なパケットやフレームを伝送するものであり、そのような情報を直接保護は、必要ありません。"
    },
    {
      "indent": 6,
      "text": "Implementers and operators MUST be aware that metadata can have privacy implications, and those implications are sometimes hard to predict. Therefore, attached metadata should be limited to that necessary for correct operation of the SFP. Further, [RFC8165] defines metadata considerations that operators can take into account when using NSH.",
      "ja": "実装者とオペレータは、メタデータは、プライバシーへの影響を持つことができることに注意する必要があり、それらの意味は、時々予測することは困難です。したがって、添付のメタデータは、SFPの正しい動作のために、その必要に制限されるべきです。さらに、[RFC8165]はNSHを使用した場合、オペレータは、考慮に入れることができ、メタデータの考慮事項を定義します。"
    },
    {
      "indent": 6,
      "text": "Protecting NSH metadata information between SFC components can be done using transport encapsulation protocols with suitable security capabilities, along the lines discussed above. If a security analysis deems these protections necessary, then security features in the transport encapsulation protocol (such as IPsec) MUST be used.",
      "ja": "SFCの構成要素間の保護NSHメタデータ情報は、上述の線に沿って、適切なセキュリティ機能を備えた搬送カプセル化プロトコルを使用して行うことができます。セキュリティ分析は、これらの保護が必要と認める場合には、（IPsecなど）トランスポート・カプセル化プロトコルのセキュリティ機能を使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "One useful element of providing privacy protection for sensitive metadata is described under the \"SFC Encapsulation\" area of the Security Considerations of [RFC7665]. Operators can and should use indirect identification for metadata deemed to be sensitive (such as personally identifying information), significantly mitigating the risk of a privacy violation. In particular, subscriber-identifying information should be handled carefully, and, in general, SHOULD be obfuscated.",
      "ja": "敏感なメタデータのプライバシー保護を提供する一つの有用な元素は、[RFC7665]のセキュリティの考慮事項の「SFCのカプセル化」エリアの下に記載されています。オペレータは著しくプライバシー侵害の危険性を軽減する、（例えば、個人識別情報など）に敏感であると考えメタデータのための間接的な識別を使用すべきことができます。具体的には、加入者識別情報は、一般に、難読化されるべきであり、慎重に処理し、すべきです。"
    },
    {
      "indent": 6,
      "text": "For those situations where obfuscation is either inapplicable or judged to be insufficient, an operator can also encrypt the metadata. An approach to an optional capability to do this was explored in [NSH-ENCRYPT]. For other situations where greater assurance is desired, optional mechanisms such as [PROOF-OF-TRANSIT] can be used.",
      "ja": "難読化は適用できない、または不十分であると判断いずれかであるような状況のために、オペレータは、メタデータを暗号化することができます。これを行うには、オプションの機能へのアプローチは、[NSH-ENCRYPT]で調査しました。より大きな保証が望まれる他の状況では、そのような[PROOF-OF-TRANSIT]のような任意の機構を使用することができます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. NSH Parameters",
      "section_title": true,
      "ja": "9.1。 NSHパラメータ"
    },
    {
      "indent": 3,
      "text": "IANA has created a new \"Network Service Header (NSH) Parameters\" registry. The following subsections detail new registries within the \"Network Service Header (NSH) Parameters\" registry.",
      "ja": "IANAは、新たな「ネットワークサービスヘッダ（NSH）パラメータ」レジストリを作成しました。 「ネットワークサービスヘッダ（NSH）パラメータ」レジストリ内の以下のサブセクションで詳細新しいレジストリ。"
    },
    {
      "indent": 0,
      "text": "9.1.1. NSH Base Header Bits",
      "section_title": true,
      "ja": "9.1.1。 NSHベースヘッダビット"
    },
    {
      "indent": 3,
      "text": "There are five unassigned bits (U bits) in the NSH Base Header, and one assigned bit (O bit). New bits are assigned via Standards Action [RFC8126].",
      "ja": "NSHベースヘッダに割り当てられていない5ビット（Uビット）、および1つの割り当てビット（Oビット）があります。新しいビットが標準アクション[RFC8126]を経由して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Bit 2 - O (OAM) bit Bit 3 - Unassigned Bits 16-19 - Unassigned",
      "ja": "ビット2  -  O（OAM）ビットのビット3  - 未割り当てビット16-19  - 未割り当て"
    },
    {
      "indent": 0,
      "text": "9.1.2. NSH Version",
      "section_title": true,
      "ja": "9.1.2。 NSHバージョン"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH Version\" registry. New values are assigned via Standards Action [RFC8126].",
      "ja": "IANAは「NSHバージョン」のレジストリを設定しています。新しい値は標準アクション[RFC8126]を経由して割り当てられます。"
    },
    {
      "indent": 7,
      "text": "+-------------+---------------------------------+-----------+\n| Version     | Description                     | Reference |\n+-------------+---------------------------------+-----------+\n| Version 00b | Protocol as defined by RFC 8300 | RFC 8300  |\n| Version 01b | Reserved                        | RFC 8300  |\n| Version 10b | Unassigned                      |           |\n| Version 11b | Unassigned                      |           |\n+-------------+---------------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 5: NSH Version",
      "ja": "表5：NSHバージョン"
    },
    {
      "indent": 0,
      "text": "9.1.3. NSH MD Types",
      "section_title": true,
      "ja": "9.1.3。 NSH MDタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH MD Types\" registry, which contains 4-bit values. MD Type values 0x0, 0x1, 0x2, and 0xF are specified in this document; see Table 6. Registry entries are assigned via the \"IETF Review\" policy defined in RFC 8126 [RFC8126].",
      "ja": "IANAは、4ビットの値が含まれている「NSH MDタイプ」レジストリを設定しています。 MDタイプは0x0の、0x1の、0x2の、および0xFのは、この文書で指定された値。参照表6.レジストリエントリは、RFC 8126 [RFC8126]で定義された「IETFレビュー」ポリシーによって割り当てられます。"
    },
    {
      "indent": 16,
      "text": "+-----------+-----------------+-----------+\n| MD Type   | Description     | Reference |\n+-----------+-----------------+-----------+\n| 0x0       | Reserved        | RFC 8300  |\n|           |                 |           |\n| 0x1       | NSH MD Type 1   | RFC 8300  |\n|           |                 |           |\n| 0x2       | NSH MD Type 2   | RFC 8300  |\n|           |                 |           |\n| 0x3 - 0xE | Unassigned      |           |\n|           |                 |           |\n| 0xF       | Experimentation | RFC 8300  |\n+-----------+-----------------+-----------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Table 6: MD Type Values",
      "ja": "表6：MD型の値"
    },
    {
      "indent": 0,
      "text": "9.1.4. NSH MD Class",
      "section_title": true,
      "ja": "9.1.4。 NSH MDクラス"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH MD Class\" registry, which contains 16-bit values. New allocations are to be made according to the following policies:",
      "ja": "IANAは、16ビットの値が含まれている「NSH MDクラスの」レジストリを設定しています。新しい割り当ては、以下の方針に従って行われるべきです。"
    },
    {
      "indent": 3,
      "text": "0x0000 to 0x01ff: IETF Review 0x0200 to 0xfff5: Expert Review",
      "ja": "0x01ffには0x0000：0xfff5にIETFレビュー0x0200：エキスパートレビュー"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the values as follows:",
      "ja": "次のようにIANAは、値が割り当てられています："
    },
    {
      "indent": 8,
      "text": "+------------------+------------------------+------------+\n| Value            | Meaning                | Reference  |\n+------------------+------------------------+------------+\n| 0x0000           | IETF Base NSH MD Class | RFC 8300   |\n|                  |                        |            |\n| 0xfff6 to 0xfffe | Experimental           | RFC 8300   |\n|                  |                        |            |\n| 0xffff           | Reserved               | RFC 8300   |\n+------------------+------------------------+------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 7: NSH MD Class",
      "ja": "表7：NSH MDクラス"
    },
    {
      "indent": 3,
      "text": "A registry for Types for the MD Class of 0x0000 is defined in Section 9.1.5.",
      "ja": "0000のMDクラスのためのタイプのレジストリは、9.1.5項で定義されています。"
    },
    {
      "indent": 3,
      "text": "Designated Experts evaluating new allocation requests from the \"Expert Review\" range should principally consider whether a new MD class is needed compared to adding MD Types to an existing class. The Designated Experts should also encourage the existence of an associated and publicly visible registry of MD Types although this registry need not be maintained by IANA.",
      "ja": "「エキスパートレビュー」の範囲からの新規割り当て要求を評価し、指定専門家は、主に新しいMDクラスは既存のクラスにMDタイプを追加することに比べて必要とされているかどうかを検討すべきです。このレジストリは、IANAによって維持する必要はないが、指定専門家はまた、MDタイプの関連すると一般に公開レジストリが存在することを奨励すべきです。"
    },
    {
      "indent": 3,
      "text": "When evaluating a request for an allocation, the Expert should verify that the allocation plan includes considerations to handle privacy and security issues associated with the anticipated individual MD Types allocated within this class. These plans should consider, when appropriate, alternatives such as indirection, encryption, and limited-deployment scenarios. Information that can't be directly derived from viewing the packet contents should be examined for privacy and security implications.",
      "ja": "割り当て要求を評価する場合、専門家は、割り当て計画は、このクラス内に割り当てられた予想の個々のMDタイプに関連したプライバシーとセキュリティの問題を処理するための考慮事項が含まれていることを確認する必要があります。これらの計画は、こうした間接、暗号化、および限られた展開シナリオとして適切な場合、代替案を検討すべきです。直接パケットの内容を見てから導き出すことができない情報は、プライバシーとセキュリティの影響について検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.1.5. NSH IETF-Assigned Optional Variable-Length Metadata Types",
      "section_title": true,
      "ja": "9.1.5。 NSH-IETF割り当てオプションの可変長のメタデータの種類"
    },
    {
      "indent": 3,
      "text": "The Type values within the IETF Base NSH MD Class, i.e., when the MD Class is set to 0x0000 (see Section 9.1.4), are the Types owned by the IETF. Per this document, IANA has created a registry for the Type values for the IETF Base NSH MD Class called the \"NSH IETF-Assigned Optional Variable-Length Metadata Types\" registry, as specified in Section 2.5.1.",
      "ja": "MDクラスを0x0000に設定されている、すなわちIETFベースNSH MDクラス、中タイプ値は、IETFが所有するタイプであり、（セクション9.1.4を参照します）。このドキュメントごとに、IANAはIETFベースNSH MDクラスの型の値のレジストリを作成しました2.5.1項で指定されるように、「NSH-IETF割り当てオプションの可変長のメタデータ・タイプ」レジストリと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The type values are assigned via Standards Action [RFC8126].",
      "ja": "型の値は、標準アクション[RFC8126]を経由して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "No initial values are assigned at the creation of the registry.",
      "ja": "いいえ初期値は、レジストリの作成時に割り当てられません。"
    },
    {
      "indent": 0,
      "text": "9.1.6. NSH Next Protocol",
      "section_title": true,
      "ja": "9.1.6。 NSH次のプロトコル"
    },
    {
      "indent": 3,
      "text": "IANA has set up the \"NSH Next Protocol\" registry, which contains 8-bit values. Next Protocol values 0, 1, 2, 3, 4, and 5 are defined in this document (see Table 8). New values are assigned via \"Expert Review\" as per [RFC8126].",
      "ja": "IANAは、8ビットの値が含まれている「NSH次議定書」のレジストリを設定しています。次のプロトコル値0、1、2、3、4、及び5は、この文書で定義されている（表8を参照されたいです）。新しい値は、[RFC8126]あたりとして「エキスパートレビュー」を経由して割り当てられます。"
    },
    {
      "indent": 15,
      "text": "+---------------+--------------+-----------+\n| Next Protocol | Description  | Reference |\n+---------------+--------------+-----------+\n| 0x00          | Unassigned   |           |\n|               |              |           |\n| 0x01          | IPv4         | RFC 8300  |\n|               |              |           |\n| 0x02          | IPv6         | RFC 8300  |\n|               |              |           |\n| 0x03          | Ethernet     | RFC 8300  |\n|               |              |           |\n| 0x04          | NSH          | RFC 8300  |\n|               |              |           |\n| 0x05          | MPLS         | RFC 8300  |\n|               |              |           |\n| 0x06 - 0xFD   | Unassigned   |           |\n|               |              |           |\n| 0xFE          | Experiment 1 | RFC 8300  |\n|               |              |           |\n| 0xFF          | Experiment 2 | RFC 8300  |\n+---------------+--------------+-----------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Table 8: NSH Base Header Next Protocol Values",
      "ja": "表8：NSHベースヘッダー次のプロトコル値"
    },
    {
      "indent": 3,
      "text": "Expert Review requests MUST include a single codepoint per request. Designated Experts evaluating new allocation requests from this registry should consider the potential scarcity of codepoints for an 8-bit value, and check both for duplications and availability of documentation. If the actual assignment of the Next Protocol field allocation reaches half of the range (that is, when there are 128 unassigned values), IANA needs to alert the IESG. At that point, a new more strict allocation policy SHOULD be considered.",
      "ja": "専門家レビューのリクエストは、リクエストごとに単一のコードポイントを含まなければなりません。このレジストリから新しい割り当て要求を評価し、指定専門家は、8ビット値のためのコードポイントの潜在的な希少性を考慮し、重複やドキュメントの可用性の両方をチェックする必要があります。次のプロトコル・フィールド割り当ての実際の割り当ては、範囲の半分に達した場合（128の割り当てられていない値がある場合には、である）、IANAはIESGに警告する必要があります。その時点で、新しい、より厳格割り当てポリシーを考慮すべきです。"
    },
    {
      "indent": 0,
      "text": "10. NSH-Related Codepoints",
      "section_title": true,
      "ja": "10. NSH-関連のコードポイント"
    },
    {
      "indent": 0,
      "text": "10.1. NSH Ethertype",
      "section_title": true,
      "ja": "10.1。 NSHイーサタイプ"
    },
    {
      "indent": 3,
      "text": "An IEEE Ethertype, 0x894F, has been allocated for NSH.",
      "ja": "IEEEイーサタイプ、0x894F、NSHのために割り当てられています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function Chaining (SFC) Architecture\", RFC 7665, DOI 10.17487/RFC7665, October 2015, <https://www.rfc-editor.org/info/rfc7665>.",
      "ja": "[RFC7665]アルペルン、J.、エド。そして、C. Pignataro、エド。、 \"サービス機能の連鎖（SFC）アーキテクチャ\"、RFC 7665、DOI 10.17487 / RFC7665、2015年10月、<https://www.rfc-editor.org/info/rfc7665>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[NSH-BROADBAND-ALLOCATION] Napper, J., Kumar, S., Muley, P., Henderickx, W., and M. Boucadair, \"NSH Context Header Allocation -- Broadband\", Work in Progress, draft-napper-sfc-nsh-broadband-allocation-04, November 2017.",
      "ja": "[NSH広帯域割当] Napper、J.、クマー、S.、Muley、P.、Henderickx、W.、およびM. Boucadair、 \"NSHコンテキストヘッダ割り当て - ブロードバンド\"、進行中で働いて、ドラフトnapper- SFC-NSH-ブロードバンド割り当て-04、2017年11月。"
    },
    {
      "indent": 3,
      "text": "[NSH-DC-ALLOCATION] Guichard, J., Smith, M., Kumar, S., Majee, S., Agarwal, P., Glavin, K., Laribi, Y., and T. Mizrahi, \"Network Service Header (NSH) MD Type 1: Context Header Allocation (Data Center)\", Work in Progress, draft-guichard-sfc-nsh-dc-allocation-07, August 2017.",
      "ja": "[NSH-DC-ALLOCATION]ギシャール、J.、スミス、M.、クマー、S.、Majee、S.、Agarwalさん、P.、Glavin、K.、Laribi、Y.、およびT.ミズラヒ、「ネットワークサービスヘッダー（NSH）MDタイプ1：コンテキストヘッダーの割り当て（データセンター）」が進行中で働いて、ドラフト・ギシャール-SFC-NSH-DC-割り当て-07、2017年8月。"
    },
    {
      "indent": 3,
      "text": "[NSH-ENCRYPT] Reddy, T., Patil, P., Fluhrer, S., and P. Quinn, \"Authenticated and encrypted NSH service chains\", Work in Progress, draft-reddy-sfc-nsh-encrypt-00, April 2015.",
      "ja": "[NSH-ENCRYPT]レディ、T.、パティル、P.、Fluhrer、S.、およびP.クイン、 \"認証および暗号化NSHサービスチェーン\" が進行中で働いて、ドラフトレディ-SFC-NSH-暗号化-00、 2015年4月。"
    },
    {
      "indent": 3,
      "text": "[PROOF-OF-TRANSIT] Brockners, F., Bhandari, S., Dara, S., Pignataro, C., Leddy, J., Youell, S., Mozes, D., and T. Mizrahi, \"Proof of Transit\", Work in Progress, draft-brockners-proof-of-transit-04, October 2017.",
      "ja": "[PROOF-OF-TRANSIT] Brockners、F.、バンダリ、S.、ダラ、S.、Pignataro、C.、Leddy、J.、Youell、S.、Mozes、D.、およびT.ミズラヒ、「証明トランジット」が進行中で働いて、ドラフトbrocknersプルーフ・オブ・トランジット-04、2017年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2784] Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, \"Generic Routing Encapsulation (GRE)\", RFC 2784, DOI 10.17487/RFC2784, March 2000, <https://www.rfc-editor.org/info/rfc2784>.",
      "ja": "[RFC2784]ファリナッチ、D.、李、T.、ハンクス、S.、マイヤー、D.、およびP. Trainaの、 \"総称ルーティングカプセル化（GRE）\"、RFC 2784、DOI 10.17487 / RFC2784、2000年3月<HTTPS ：//www.rfc-editor.org/info/rfc2784>。"
    },
    {
      "indent": 3,
      "text": "[RFC3552] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.",
      "ja": "[RFC3552]レスコラ、E.とB.コーバー、 \"セキュリティの考慮事項の書き方RFCテキストのためのガイドライン\"、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/情報/ rfc3552>。"
    },
    {
      "indent": 3,
      "text": "[RFC3692] Narten, T., \"Assigning Experimental and Testing Numbers Considered Useful\", BCP 82, RFC 3692, DOI 10.17487/RFC3692, January 2004, <https://www.rfc-editor.org/info/rfc3692>.",
      "ja": "[RFC3692] Narten氏、T.、 \"役に立つと考えられた実験的でテスト番号の割り当て\"、BCP 82、RFC 3692、DOI 10.17487 / RFC3692、2004年1月、<https://www.rfc-editor.org/info/rfc3692>。"
    },
    {
      "indent": 3,
      "text": "[RFC6071] Frankel, S. and S. Krishnan, \"IP Security (IPsec) and Internet Key Exchange (IKE) Document Roadmap\", RFC 6071, DOI 10.17487/RFC6071, February 2011, <https://www.rfc-editor.org/info/rfc6071>.",
      "ja": "[RFC6071]フランケル、S.とS.クリシュナン、 \"IPセキュリティ（IPsec）やInternet Key Exchange（IKE）ドキュメントロードマップ\"、RFC 6071、DOI 10.17487 / RFC6071、2011年2月、<HTTPS：//www.rfc-editor .ORG /情報/ rfc6071>。"
    },
    {
      "indent": 3,
      "text": "[RFC6291] Andersson, L., van Helvoort, H., Bonica, R., Romascanu, D., and S. Mansfield, \"Guidelines for the Use of the \"OAM\" Acronym in the IETF\", BCP 161, RFC 6291, DOI 10.17487/RFC6291, June 2011, <https://www.rfc-editor.org/info/rfc6291>.",
      "ja": "[RFC6291]アンダーソン、L.、バンHelvoort、H.、Bonica、R.、Romascanu、D.、およびS.マンスフィールド、OAM \"IETFにおける頭字語 \"\" の使用のためのガイドライン\"、BCP 161、RFC 6291 、DOI 10.17487 / RFC6291、2011年6月、<https://www.rfc-editor.org/info/rfc6291>。"
    },
    {
      "indent": 3,
      "text": "[RFC7325] Villamizar, C., Ed., Kompella, K., Amante, S., Malis, A., and C. Pignataro, \"MPLS Forwarding Compliance and Performance Requirements\", RFC 7325, DOI 10.17487/RFC7325, August 2014, <https://www.rfc-editor.org/info/rfc7325>.",
      "ja": "[RFC7325] Villamizar、C.、エド。、Kompella、K.、Amante、S.、Malis、A.、およびC. Pignataro、 \"MPLS転送コンプライアンスおよびパフォーマンス要件\"、RFC 7325、DOI 10.17487 / RFC7325、2014年8月、<https://www.rfc-editor.org/info/rfc7325>。"
    },
    {
      "indent": 3,
      "text": "[RFC7498] Quinn, P., Ed. and T. Nadeau, Ed., \"Problem Statement for Service Function Chaining\", RFC 7498, DOI 10.17487/RFC7498, April 2015, <https://www.rfc-editor.org/info/rfc7498>.",
      "ja": "[RFC7498]クイン、P.、エド。そして、T.ナドー、エド。、 \"サービス機能の連鎖のための問題文\"、RFC 7498、DOI 10.17487 / RFC7498、2015年4月、<https://www.rfc-editor.org/info/rfc7498>。"
    },
    {
      "indent": 3,
      "text": "[RFC7676] Pignataro, C., Bonica, R., and S. Krishnan, \"IPv6 Support for Generic Routing Encapsulation (GRE)\", RFC 7676, DOI 10.17487/RFC7676, October 2015, <https://www.rfc-editor.org/info/rfc7676>.",
      "ja": "[RFC7676] Pignataro、C.、Bonica、R.、およびS.クリシュナン、 \"総称ルーティングカプセル化（GRE）のIPv6サポート\"、RFC 7676、DOI 10.17487 / RFC7676、2015年10月、<HTTPS：//www.rfc- editor.org/info/rfc7676>。"
    },
    {
      "indent": 3,
      "text": "[RFC8165] Hardie, T., \"Design Considerations for Metadata Insertion\", RFC 8165, DOI 10.17487/RFC8165, May 2017, <https://www.rfc-editor.org/info/rfc8165>.",
      "ja": "[RFC8165]ハーディ、T.、 \"メタデータの挿入のための設計上の考慮事項\"、RFC 8165、DOI 10.17487 / RFC8165、2017年5月、<https://www.rfc-editor.org/info/rfc8165>。"
    },
    {
      "indent": 3,
      "text": "[RFC8201] McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., \"Path MTU Discovery for IP version 6\", STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <https://www.rfc-editor.org/info/rfc8201>.",
      "ja": "[RFC8201]マッキャン、J.、デアリング、S.、モーグル、J.、およびR. Hindenと編、 \"IPバージョン6のパスMTUディスカバリ\"、STD 87、RFC 8201、DOI 10.17487 / RFC8201、2017年7月、 <https://www.rfc-editor.org/info/rfc8201>。"
    },
    {
      "indent": 3,
      "text": "[RTG-ENCAP] Nordmark, E., Tian, A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P., and T. Herbert, \"Encapsulation Considerations\", Work in Progress, draft-ietf-rtgwg-dt-encap-02, October 2016.",
      "ja": "[RTG-ENCAP] Nordmarkと、E.、天、A.、グロス、J.、ハドソン、J.、Kreeger、L.、ガーグ、P.、ターラー、P.、およびT.ハーバート、 \"カプセル化の考慮事項\"、ドラフト-IETF-rtgwg-DT-ENCAP-02、2016年10月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[SFC-CONTROL-PLANE] Boucadair, M., \"Service Function Chaining (SFC) Control Plane Components & Requirements\", Work in Progress, draft-ietf-sfc-control-plane-08, October 2016.",
      "ja": "[SFC-CONTROL-PLANE] Boucadair、M.、 \"サービス機能の連鎖（SFC）コントロールプレーンコンポーネント＆要件\" 進行中、仕事、ドラフト-IETF-SFC-コントロールプレーン-08、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[SFC-OAM-FRAMEWORK] Aldrin, S., Pignataro, C., Kumar, N., Akiya, N., Krishnan, R., and A. Ghanwani, \"Service Function Chaining (SFC) Operation, Administration and Maintenance (OAM) Framework\", Work in Progress, draft-ietf-sfc-oam-framework-03, September 2017.",
      "ja": "[SFC-OAM-FRAMEWORK]アルドリン、S.、Pignataro、C.、クマー、N.、秋谷、N.、クリシュナン、R.、およびA. Ghanwani、「サービス機能連鎖（SFC）の操作、管理および保守（ OAM）フレームワーク」が進行中で働いて、ドラフト-IETF-SFC-OAMフレームワーク-03、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[VXLAN-GPE] Maino, F., Kreeger, L., and U. Elzur, \"Generic Protocol Extension for VXLAN\", Work in Progress, draft-ietf-nvo3-vxlan-gpe-05, October 2017.",
      "ja": "[VXLAN-GPE]メイノー、F.、Kreeger、L.、およびU. Elzur、 \"VXLANのための汎用プロトコル拡張\" が進行中で働いて、ドラフト-IETF-nvo3-VXLAN-GPE-05、2017年10月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Sunil Vallamkonda, Nagaraj Bagepalli, Abhijit Patra, Peter Bosch, Darrel Lewis, Pritesh Kothari, Tal Mizrahi, and Ken Gray for their detailed reviews, comments, and contributions.",
      "ja": "著者は、その詳細なレビュー、コメント、貢献のためスニルVallamkonda、Nagaraj Bagepalli、Abhijitパトラ、ピーター・ボッシュ、ダレル・ルイス、Priteshコタリ、タルミズラヒ、とケングレーに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "A special thank you goes to David Ward and Tom Edsall for their guidance and feedback.",
      "ja": "特別なあなたが彼らの指導やフィードバックのためのデビッド・ウォードとトムEdsallに行く感謝します。"
    },
    {
      "indent": 3,
      "text": "Additionally, the authors would like to thank Larry Kreeger for his invaluable ideas and contributions, which are reflected throughout this document.",
      "ja": "さらに、著者は、この文書全体に反映されている彼の貴重なアイデアや貢献のためのラリーKreegerに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Loa Andersson provided a thorough review and valuable comments; we thank him for that.",
      "ja": "ロア・アンダーソンは、徹底的な見直しと貴重なコメントを提供します。我々はそのために彼に感謝します。"
    },
    {
      "indent": 3,
      "text": "Reinaldo Penno deserves a particular thank you for his architecture and implementation work that helped guide the protocol concepts and design.",
      "ja": "レイナルドPennoは、特定のプロトコルの概念と設計を導く助けた彼のアーキテクチャと実装の仕事をありがとう値します。"
    },
    {
      "indent": 3,
      "text": "The editors also acknowledge comprehensive reviews and respective useful suggestions by Med Boucadair, Adrian Farrel, Juergen Schoenwaelder, Acee Lindem, and Kathleen Moriarty.",
      "ja": "編集者はまた、包括的なレビューとメッドBoucadair、エードリアンファレル、ユルゲンSchoenwaelder、ACEE Lindem、とキャスリーン・モリアーティによって、それぞれの有益な提案を認めます。"
    },
    {
      "indent": 3,
      "text": "Lastly, David Dolson has provided significant review, feedback, and suggestions throughout the evolution of this document. His contributions are very much appreciated.",
      "ja": "最後に、デビッドDolsonは、このドキュメントの進化の過程で重要なレビュー、フィードバック、提案を提供してきました。彼の貢献は非常に高く評価されています。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "This WG document originated as draft-quinn-sfc-nsh; the following are its coauthors and contributors along with their respective affiliations at the time of WG adoption. The editors of this document would like to thank and recognize them and their contributions. These coauthors and contributors provided invaluable concepts and content for this document's creation.",
      "ja": "このWG文書はドラフト・クイン-SFC-NSHとして始まり。 WG採用の時に、それぞれの所属とともにその共著者と貢献者は次のとおり。このドキュメントの編集者は、彼らと彼らの貢献に感謝し、理解したいと思います。これらの共著者と貢献者は、この文書の作成のための貴重な概念やコンテンツを提供します。"
    },
    {
      "indent": 3,
      "text": "o Jim Guichard, Cisco Systems, Inc. o Surendra Kumar, Cisco Systems, Inc. o Michael Smith, Cisco Systems, Inc. o Wim Henderickx, Alcatel-Lucent o Tom Nadeau, Brocade o Puneet Agarwal o Rajeev Manur, Broadcom o Abhishek Chauhan, Citrix o Joel Halpern, Ericsson o Sumandra Majee, F5 o David Melman, Marvell o Pankaj Garg, Microsoft o Brad McConnell, Rackspace o Chris Wright, Red Hat, Inc. o Kevin Glavin, Riverbed o Hong (Cathy) Zhang, Huawei US R&D o Louis Fourie, Huawei US R&D o Ron Parker, Affirmed Networks o Myo Zarny, Goldman Sachs o Andrew Dolganow, Alcatel-Lucent o Rex Fernando, Cisco Systems, Inc. o Praveen Muley, Alcatel-Lucent o Navindra Yadav, Cisco Systems, Inc.",
      "ja": "ラジーブManur、アビシェークChauhan O BroadcomのO Puneet AgarwalさんOトム・ナドー、ブロケードOヴィム・ヘンデリックOマイケル・スミス、シスコシステムズ社、アルカテル・ルーセント〇〇ジム・ギシャール、シスコシステムズ、株式会社スレンドラクマールO、シスコシステムズ、株式会社ケビンGlavin、香港（キャシー）張、華為米国OのRiverbed Oジョエル・ハルパーン、クリス・ライトOブラッド・マコーネル、RackspaceのOパンカジガーグ、マイクロソフトOデビッドMelman、マーベルO Sumandra Majee、F5 OエリクソンO、Citrix社はRed Hat、Inc.のNavindra Yadavが、シスコシステムズO PraveenさんMuley Oレックスフェルナンド・OアンドリューDolganow、アルカテル・ルーセントOミオZarny、ゴールドマン・サックスOロン・パーカー、断言ネットワークOルイ・フォーリー、華為米国R＆D O R＆D、シスコシステムズ社、アルカテル・ルーセント、株式会社"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Quinn (editor) Cisco Systems, Inc.",
      "ja": "ポール・クイン（エディタ）は、シスコシステムズ、株式会社"
    },
    {
      "indent": 3,
      "text": "Email: paulq@cisco.com",
      "ja": "メール：paulq@cisco.com"
    },
    {
      "indent": 3,
      "text": "Uri Elzur (editor) Intel",
      "ja": "ウリElzur（編集者）インテル"
    },
    {
      "indent": 3,
      "text": "Email: uri.elzur@intel.com",
      "ja": "メール：uri.elzur@intel.com"
    },
    {
      "indent": 3,
      "text": "Carlos Pignataro (editor) Cisco Systems, Inc.",
      "ja": "カルロスPignataro（エディタ）は、シスコシステムズ、株式会社"
    },
    {
      "indent": 3,
      "text": "Email: cpignata@cisco.com",
      "ja": "メール：cpignata@cisco.com"
    }
  ]
}