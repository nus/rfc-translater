{
  "title": {
    "text": "RFC 8478 - Zstandard Compression and the application/zstd Media Type",
    "ja": "RFC 8478 - Zstandard圧縮とapplication / zstdメディアタイプ"
  },
  "number": 8478,
  "created_at": "2019-10-22 23:17:42.249487+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         Y. Collet\nRequest for Comments: 8478                             M. Kucherawy, Ed.\nCategory: Informational                                         Facebook\nISSN: 2070-1721                                             October 2018",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Zstandard Compression and the application/zstd Media Type",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Zstandard, or \"zstd\" (pronounced \"zee standard\"), is a data compression mechanism. This document describes the mechanism and registers a media type and content encoding to be used when transporting zstd-compressed content via Multipurpose Internet Mail Extensions (MIME).",
      "ja": "Zstandard、または「zstd」（「zee standard」と発音）は、データ圧縮メカニズムです。 このドキュメントでは、メカニズムを説明し、MIME（Multipurpose Internet Mail Extensions）を介してzstdで圧縮されたコンテンツを転送するときに使用されるメディアタイプとコンテンツエンコーディングを登録します。"
    },
    {
      "indent": 3,
      "text": "Despite use of the word \"standard\" as part of its name, readers are advised that this document is not an Internet Standards Track specification; it is being published for informational purposes only.",
      "ja": "名前の一部として「標準」という言葉を使用していますが、読者はこの文書がインターネット標準化過程の仕様ではないことをお勧めします。 情報提供のみを目的として公開されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 情報提供の目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8478.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8478で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Compression Algorithm . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  Frames  . . . . . . . . . . . . . . . . . . . . . . . . .   6\n    3.1.1.  Zstandard Frames  . . . . . . . . . . . . . . . . . .   6\n      3.1.1.1.  Frame Header  . . . . . . . . . . . . . . . . . .   7\n      3.1.1.2.  Blocks  . . . . . . . . . . . . . . . . . . . . .  12\n      3.1.1.3.  Compressed Blocks . . . . . . . . . . . . . . . .  14\n      3.1.1.4.  Sequence Execution  . . . . . . . . . . . . . . .  28\n      3.1.1.5.  Repeat Offsets  . . . . . . . . . . . . . . . . .  29\n    3.1.2.  Skippable Frames  . . . . . . . . . . . . . . . . . .  30\n4.  Entropy Encoding  . . . . . . . . . . . . . . . . . . . . . .  30\n  4.1.  FSE . . . . . . . . . . . . . . . . . . . . . . . . . . .  31\n    4.1.1.  FSE Table Description . . . . . . . . . . . . . . . .  31\n  4.2.  Huffman Coding  . . . . . . . . . . . . . . . . . . . . .  34\n    4.2.1.  Huffman Tree Description  . . . . . . . . . . . . . .  35\n      4.2.1.1.  Huffman Tree Header . . . . . . . . . . . . . . .  36\n      4.2.1.2.  FSE Compression of Huffman Weights  . . . . . . .  37\n      4.2.1.3.  Conversion from Weights to Huffman Prefix Codes .  38\n    4.2.2.  Huffman-Coded Streams . . . . . . . . . . . . . . . .  39\n5.  Dictionary Format . . . . . . . . . . . . . . . . . . . . . .  40\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  42\n  6.1.  The 'application/zstd' Media Type . . . . . . . . . . . .  42\n  6.2.  Content Encoding  . . . . . . . . . . . . . . . . . . . .  43\n  6.3.  Dictionaries  . . . . . . . . . . . . . . . . . . . . . .  43\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  43\n8.  Implementation Status . . . . . . . . . . . . . . . . . . . .  44\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  45\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  45\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  45\nAppendix A.  Decoding Tables for Predefined Codes . . . . . . . .  46\n  A.1.  Literal Length Code Table . . . . . . . . . . . . . . . .  46\n  A.2.  Match Length Code Table . . . . . . . . . . . . . . . . .  49\n  A.3.  Offset Code Table . . . . . . . . . . . . . . . . . . . .  52\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  53\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  54",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Zstandard, or \"zstd\" (pronounced \"zee standard\"), is a data compression mechanism, akin to gzip [RFC1952].",
      "ja": "Zstandard、または「zstd」（「zee standard」と発音）は、gzip [RFC1952]に似たデータ圧縮メカニズムです。"
    },
    {
      "indent": 3,
      "text": "Despite use of the word \"standard\" as part of its name, readers are advised that this document is not an Internet Standards Track specification; it is being published for informational purposes only.",
      "ja": "名前の一部として「標準」という言葉を使用していますが、読者はこの文書がインターネット標準化過程の仕様ではないことをお勧めします。 情報提供のみを目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This document describes the Zstandard format. Also, to enable the transport of a data object compressed with Zstandard, this document registers a media type that can be used to identify such content when it is used in a payload encoded using Multipurpose Internet Mail Extensions (MIME).",
      "ja": "このドキュメントでは、Zstandard形式について説明します。 また、Zstandardで圧縮されたデータオブジェクトの転送を可能にするために、このドキュメントでは、MIME（Multipurpose Internet Mail Extensions）を使用してエンコードされたペイロードで使用されるコンテンツを識別するために使用できるメディアタイプを登録します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "Some terms used elsewhere in this document are defined here for clarity.",
      "ja": "このドキュメントの他の場所で使用されているいくつかの用語は、明確にするためにここで定義されています。"
    },
    {
      "indent": 3,
      "text": "uncompressed: Describes an arbitrary set of bytes in their original form, prior to being subjected to compression.",
      "ja": "非圧縮：圧縮される前の任意のバイトセットを元の形式で記述します。"
    },
    {
      "indent": 3,
      "text": "compress, compression: The act of processing a set of bytes via the compression mechanism described here.",
      "ja": "圧縮、圧縮：ここで説明する圧縮メカニズムを介してバイトのセットを処理する行為。"
    },
    {
      "indent": 3,
      "text": "compressed: Describes the result of passing a set of bytes through this mechanism. The original input has thus been compressed.",
      "ja": "圧縮済み：このメカニズムを介してバイトセットを渡した結果を記述します。 したがって、元の入力は圧縮されています。"
    },
    {
      "indent": 3,
      "text": "decompress, decompression: The act of processing a set of bytes through the inverse of the compression mechanism described here, in an attempt to recover the original set of bytes prior to compression.",
      "ja": "圧縮解除、圧縮解除：圧縮前に元のバイトセットを復元しようとして、ここで説明した圧縮メカニズムの逆を介してバイトセットを処理する動作。"
    },
    {
      "indent": 3,
      "text": "decompressed: Describes the result of passing a set of bytes through the reverse of this mechanism. When this is successful, the decompressed payload and the uncompressed payload are indistinguishable.",
      "ja": "解凍：このメカニズムの逆に一連のバイトを渡した結果について説明します。 これが成功すると、圧縮解除されたペイロードと圧縮解除されたペイロードは区別できなくなります。"
    },
    {
      "indent": 3,
      "text": "encode: The process of translating data from one form to another; this may include compression or it may refer to other translations done as part of this specification.",
      "ja": "エンコード：データをある形式から別の形式に変換するプロセス。 これには圧縮が含まれるか、この仕様の一部として行われる他の翻訳を参照する場合があります。"
    },
    {
      "indent": 3,
      "text": "decode: The reverse of \"encode\"; describes a process of reversing a prior encoding to recover the original content.",
      "ja": "デコード：「エンコード」の逆。 元のコンテンツを復元するために、以前のエンコードを逆にするプロセスについて説明します。"
    },
    {
      "indent": 3,
      "text": "frame: Content compressed by Zstandard is transformed into a Zstandard frame. Multiple frames can be appended into a single file or stream. A frame is completely independent, has a defined beginning and end, and has a set of parameters that tells the decoder how to decompress it.",
      "ja": "フレーム：Zstandardで圧縮されたコンテンツは、Zstandardフレームに変換されます。 複数のフレームを単一のファイルまたはストリームに追加できます。 フレームは完全に独立しており、定義された開始点と終了点を持ち、デコーダーに圧縮解除方法を指示する一連のパラメーターがあります。"
    },
    {
      "indent": 3,
      "text": "block: A frame encapsulates one or multiple blocks. Each block contains arbitrary content, which is described by its header, and has a guaranteed maximum content size that depends upon frame parameters. Unlike frames, each block depends on previous blocks for proper decoding. However, each block can be decompressed without waiting for its successor, allowing streaming operations.",
      "ja": "ブロック：フレームは、1つまたは複数のブロックをカプセル化します。 各ブロックには、ヘッダーで記述される任意のコンテンツが含まれ、フレームパラメーターに依存する最大コンテンツサイズが保証されています。 フレームとは異なり、各ブロックは適切なデコードのために前のブロックに依存します。 ただし、各ブロックは、後続操作を待たずに圧縮解除できるため、ストリーミング操作が可能です。"
    },
    {
      "indent": 3,
      "text": "natural order: A sequence or ordering of objects or values that is typical of that type of object or value. A set of unique integers, for example, is in \"natural order\" if when progressing from one element in the set or sequence to the next, there is never a decrease in value.",
      "ja": "自然順序：そのタイプのオブジェクトまたは値の典型的なオブジェクトまたは値の順序または順序。 たとえば、一意の整数のセットは、セットまたはシーケンスの1つの要素から次の要素に進むときに値が減少しない場合、「自然な順序」になります。"
    },
    {
      "indent": 3,
      "text": "The naming convention for identifiers within the specification is Mixed_Case_With_Underscores. Identifiers inside square brackets indicate that the identifier is optional in the presented context.",
      "ja": "仕様内の識別子の命名規則はMixed_Case_With_Underscoresです。 角括弧内の識別子は、提示されたコンテキストでは識別子がオプションであることを示します。"
    },
    {
      "indent": 0,
      "text": "3. Compression Algorithm",
      "section_title": true,
      "ja": "3.圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section describes the Zstandard algorithm.",
      "ja": "このセクションでは、Zstandardアルゴリズムについて説明します。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to define a lossless compressed data format that is a) independent of the CPU type, operating system, file system, and character set and b) is suitable for file compression and pipe and streaming compression, using the Zstandard algorithm. The text of the specification assumes a basic background in programming at the level of bits and other primitive data representations.",
      "ja": "このドキュメントの目的は、a）CPUタイプ、オペレーティングシステム、ファイルシステム、および文字セットに依存せず、b）Zstandardアルゴリズムを使用して、ファイル圧縮とパイプおよびストリーミング圧縮に適したロスレス圧縮データ形式を定義することです。 。 仕様のテキストは、ビットおよびその他のプリミティブデータ表現のレベルでのプログラミングの基本的な背景を前提としています。"
    },
    {
      "indent": 3,
      "text": "The data can be produced or consumed, even for an arbitrarily long sequentially presented input data stream, using only an a priori bounded amount of intermediate storage, and hence can be used in data communications. The format uses the Zstandard compression method, and an optional xxHash-64 checksum method [XXHASH], for detection of data corruption.",
      "ja": "事前に制限された量の中間ストレージのみを使用して、任意の長さの連続して入力されるデータストリームであっても、データを生成または消費できるため、データ通信に使用できます。 この形式では、データ破損の検出にZstandard圧縮方式とオプションのxxHash-64チェックサム方式[XXHASH]が使用されます。"
    },
    {
      "indent": 3,
      "text": "The data format defined by this specification does not attempt to allow random access to compressed data.",
      "ja": "この仕様で定義されているデータ形式は、圧縮データへのランダムアクセスを許可しません。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise indicated below, a compliant compressor must produce data sets that conform to the specifications presented here. However, it does not need to support all options.",
      "ja": "以下で特に指定されていない限り、準拠するコンプレッサーは、ここに提示された仕様に適合するデータセットを生成する必要があります。 ただし、すべてのオプションをサポートする必要はありません。"
    },
    {
      "indent": 3,
      "text": "A compliant decompressor must be able to decompress at least one working set of parameters that conforms to the specifications presented here. It may also ignore informative fields, such as the checksum. Whenever it does not support a parameter defined in the compressed stream, it must produce a non-ambiguous error code and associated error message explaining which parameter is unsupported.",
      "ja": "準拠した圧縮解除プログラムは、ここに提示された仕様に適合するパラメータの少なくとも1つのワーキングセットを圧縮解除できる必要があります。 また、チェックサムなどの情報フィールドを無視する場合があります。 圧縮ストリームで定義されたパラメーターをサポートしていない場合は常に、サポートされていないパラメーターを説明するあいまいでないエラーコードと関連エラーメッセージを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification is intended for use by implementers of software to compress data into Zstandard format and/or decompress data from Zstandard format. The Zstandard format is supported by an open source reference implementation, written in portable C, and available at [ZSTD].",
      "ja": "この仕様は、ソフトウェアの実装者がデータをZstandard形式に圧縮したり、Zstandard形式からデータを解凍したりするために使用することを目的としています。 Zstandard形式は、ポータブルCで記述されたオープンソースのリファレンス実装でサポートされており、[ZSTD]で入手できます。"
    },
    {
      "indent": 0,
      "text": "3.1. Frames",
      "section_title": true,
      "ja": "3.1。 フレーム"
    },
    {
      "indent": 3,
      "text": "Zstandard compressed data is made up of one or more frames. Each frame is independent and can be decompressed independently of other frames. The decompressed content of multiple concatenated frames is the concatenation of each frame's decompressed content.",
      "ja": "Zstandard圧縮データは、1つ以上のフレームで構成されています。 各フレームは独立しており、他のフレームとは独立して圧縮解除できます。 複数の連結されたフレームの解凍されたコンテンツは、各フレームの解凍されたコンテンツの連結です。"
    },
    {
      "indent": 3,
      "text": "There are two frame formats defined for Zstandard: Zstandard frames and skippable frames. Zstandard frames contain compressed data, while skippable frames contain custom user metadata.",
      "ja": "Zstandardには、Zstandardフレームとスキップ可能フレームの2つのフレーム形式が定義されています。 Zstandardフレームには圧縮データが含まれ、スキップ可能なフレームにはカスタムユーザーメタデータが含まれます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Zstandard Frames",
      "section_title": true,
      "ja": "3.1.1。 Zstandard Frames"
    },
    {
      "indent": 3,
      "text": "The structure of a single Zstandard frame is as follows:",
      "ja": "単一のZstandardフレームの構造は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+--------------------+------------+\n|    Magic_Number    | 4 bytes    |\n+--------------------+------------+\n|    Frame_Header    | 2-14 bytes |\n+--------------------+------------+\n|     Data_Block     | n bytes    |\n+--------------------+------------+\n| [More Data_Blocks] |            |\n+--------------------+------------+\n| [Content_Checksum] | 0-4 bytes  |\n+--------------------+------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Magic_Number: 4 bytes, little-endian format. Value: 0xFD2FB528.",
      "ja": "Magic_Number：4バイト、リトルエンディアン形式。 値：0xFD2FB528。"
    },
    {
      "indent": 3,
      "text": "Frame_Header: 2 to 14 bytes, detailed in Section 3.1.1.1.",
      "ja": "Frame_Header：2〜14バイト、詳細はセクション3.1.1.1で。"
    },
    {
      "indent": 3,
      "text": "Data_Block: Detailed in Section 3.1.1.2. This is where data appears.",
      "ja": "Data_Block：セクション3.1.1.2で詳述。 ここにデータが表示されます。"
    },
    {
      "indent": 3,
      "text": "Content_Checksum: An optional 32-bit checksum, only present if Content_Checksum_Flag is set. The content checksum is the result of the XXH64() hash function [XXHASH] digesting the original (decoded) data as input, and a seed of zero. The low 4 bytes of the checksum are stored in little-endian format.",
      "ja": "Content_Checksum：オプションの32ビットチェックサム。Content_Checksum_Flagが設定されている場合にのみ存在します。 コンテンツチェックサムは、入力として元の（デコードされた）データをダイジェストするXXH64（）ハッシュ関数[XXHASH]の結果とゼロのシードです。 チェックサムの下位4バイトは、リトルエンディアン形式で保存されます。"
    },
    {
      "indent": 3,
      "text": "The magic number was selected to be less probable to find at the beginning of an arbitrary file. It avoids trivial patterns (0x00, 0xFF, repeated bytes, increasing bytes, etc.), contains byte values outside of ASCII range, and doesn't map into UTF-8 space, all of which reduce the likelihood of its appearance at the top of a text file.",
      "ja": "マジックナンバーは、任意のファイルの先頭で見つける可能性が低くなるように選択されました。 些細なパターン（0x00、0xFF、繰り返されるバイト、増加するバイトなど）を避け、ASCII範囲外のバイト値を含み、UTF-8空間にマップしません。これらはすべて、上部に表示される可能性を減らします。 テキストファイルの。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1. Frame Header",
      "section_title": true,
      "ja": "3.1.1.1。 フレームヘッダー"
    },
    {
      "indent": 3,
      "text": "The frame header has a variable size, with a minimum of 2 bytes and up to 14 bytes depending on optional parameters. The structure of Frame_Header is as follows:",
      "ja": "フレームヘッダーのサイズは可変で、オプションのパラメーターに応じて、最小2バイトから最大14バイトです。 Frame_Headerの構造は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+-------------------------+-----------+\n| Frame_Header_Descriptor | 1 byte    |\n+-------------------------+-----------+\n|   [Window_Descriptor]   | 0-1 byte  |\n+-------------------------+-----------+\n|     [Dictionary_ID]     | 0-4 bytes |\n+-------------------------+-----------+\n|  [Frame_Content_Size]   | 0-8 bytes |\n+-------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1. Frame_Header_Descriptor",
      "section_title": true,
      "ja": "3.1.1.1.1。 Frame_Header_Descriptor"
    },
    {
      "indent": 3,
      "text": "The first header's byte is called the Frame_Header_Descriptor. It describes which other fields are present. Decoding this byte is enough to tell the size of Frame_Header.",
      "ja": "最初のヘッダーのバイトは、Frame_Header_Descriptorと呼ばれます。 他のどのフィールドが存在するかを説明します。 このバイトをデコードするだけで、Frame_Headerのサイズを知ることができます。"
    },
    {
      "indent": 5,
      "text": "+------------+-------------------------+\n| Bit Number | Field Name              |\n+------------+-------------------------+\n|    7-6     | Frame_Content_Size_Flag |\n+------------+-------------------------+\n|     5      | Single_Segment_Flag     |\n+------------+-------------------------+\n|     4      | (unused)                |\n+------------+-------------------------+\n|     3      | (reserved)              |\n+------------+-------------------------+\n|     2      | Content_Checksum_Flag   |\n+------------+-------------------------+\n|    1-0     | Dictionary_ID_Flag      |\n+------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this table, bit 7 is the highest bit, while bit 0 is the lowest one.",
      "ja": "この表では、ビット7が最上位ビットであり、ビット0が最下位ビットです。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.1. Frame_Content_Size_Flag",
      "section_title": true,
      "ja": "3.1.1.1.1.1。 Frame_Content_Size_Flag"
    },
    {
      "indent": 3,
      "text": "This is a 2-bit flag (equivalent to Frame_Header_Descriptor right-shifted 6 bits) specifying whether Frame_Content_Size (the decompressed data size) is provided within the header. Flag_Value provides FCS_Field_Size, which is the number of bytes used by Frame_Content_Size according to the following table:",
      "ja": "これは、Frame_Content_Size（非圧縮データサイズ）がヘッダー内で提供されるかどうかを指定する2ビットフラグ（Frame_Header_Descriptorと6ビット右シフト）です。 Flag_ValueはFCS_Field_Sizeを提供します。これは、次の表に従ってFrame_Content_Sizeが使用するバイト数です。"
    },
    {
      "indent": 5,
      "text": "+----------------+--------+---+---+---+\n| Flag_Value     |   0    | 1 | 2 | 3 |\n+----------------+--------+---+---+---+\n| FCS_Field_Size | 0 or 1 | 2 | 4 | 8 |\n+----------------+--------+---+---+---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When Flag_Value is 0, FCS_Field_Size depends on Single_Segment_Flag: If Single_Segment_Flag is set, FCS_Field_Size is 1. Otherwise, FCS_Field_Size is 0; Frame_Content_Size is not provided.",
      "ja": "Flag_Valueが0の場合、FCS_Field_SizeはSingle_Segment_Flagに依存します。Single_Segment_Flagが設定されている場合、FCS_Field_Sizeは1です。 Frame_Content_Sizeは提供されません。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.2. Single_Segment_Flag",
      "section_title": true,
      "ja": "3.1.1.1.1.2。 Single_Segment_Flag"
    },
    {
      "indent": 3,
      "text": "If this flag is set, data must be regenerated within a single continuous memory segment.",
      "ja": "このフラグが設定されている場合、単一の連続メモリセグメント内でデータを再生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this case, Window_Descriptor byte is skipped, but Frame_Content_Size is necessarily present. As a consequence, the decoder must allocate a memory segment of size equal or larger than Frame_Content_Size.",
      "ja": "この場合、Window_Descriptorバイトはスキップされますが、Frame_Content_Sizeは必ず存在します。 結果として、デコーダは、Frame_Content_Size以上のサイズのメモリセグメントを割り当てる必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to protect the decoder from unreasonable memory requirements, a decoder is allowed to reject a compressed frame that requests a memory size beyond the decoder's authorized range.",
      "ja": "デコーダを不合理なメモリ要件から保護するために、デコーダは、デコーダの許可範囲を超えるメモリサイズを要求する圧縮フレームを拒否できます。"
    },
    {
      "indent": 3,
      "text": "For broader compatibility, decoders are recommended to support memory sizes of at least 8 MB. This is only a recommendation; each decoder is free to support higher or lower limits, depending on local limitations.",
      "ja": "広範な互換性のために、デコーダは少なくとも8 MBのメモリサイズをサポートすることをお勧めします。 これは単なる推奨事項です。 各デコーダは、ローカルの制限に応じて、上限または下限を自由にサポートできます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.3. Unused Bit",
      "section_title": true,
      "ja": "3.1.1.1.1.3。 未使用ビット"
    },
    {
      "indent": 3,
      "text": "A decoder compliant with this specification version shall not interpret this bit. It might be used in a future version, to signal a property that is not mandatory to properly decode the frame. An encoder compliant with this specification must set this bit to zero.",
      "ja": "この仕様バージョンに準拠したデコーダは、このビットを解釈してはなりません。 将来のバージョンでは、フレームを適切にデコードするために必須ではないプロパティを通知するために使用される可能性があります。 この仕様に準拠するエンコーダは、このビットをゼロに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.4. Reserved Bit",
      "section_title": true,
      "ja": "3.1.1.1.1.4。 予約ビット"
    },
    {
      "indent": 3,
      "text": "This bit is reserved for some future feature. Its value must be zero. A decoder compliant with this specification version must ensure it is not set. This bit may be used in a future revision, to signal a feature that must be interpreted to decode the frame correctly.",
      "ja": "このビットは、将来の機能のために予約されています。 その値はゼロでなければなりません。 この仕様バージョンに準拠するデコーダは、設定されていないことを確認する必要があります。 このビットは、フレームを正しくデコードするために解釈する必要がある機能を示すために、将来のリビジョンで使用される可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.5. Content_Checksum_Flag",
      "section_title": true,
      "ja": "3.1.1.1.1.5。 Content_Checksum_Flag"
    },
    {
      "indent": 3,
      "text": "If this flag is set, a 32-bit Content_Checksum will be present at the frame's end. See the description of Content_Checksum above.",
      "ja": "このフラグが設定されている場合、32ビットのContent_Checksumがフレームの最後に存在します。 上記のContent_Checksumの説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.1.6. Dictionary_ID_Flag",
      "section_title": true,
      "ja": "3.1.1.1.1.6。 Dictionary_ID_Flag"
    },
    {
      "indent": 3,
      "text": "This is a 2-bit flag (= Frame_Header_Descriptor & 0x3) indicating whether a dictionary ID is provided within the header. It also specifies the size of this field as DID_Field_Size:",
      "ja": "これは、辞書IDがヘッダー内で提供されるかどうかを示す2ビットのフラグ（= Frame_Header_Descriptor＆0x3）です。 また、このフィールドのサイズをDID_Field_Sizeとして指定します。"
    },
    {
      "indent": 5,
      "text": "+----------------+---+---+---+---+\n| Flag_Value     | 0 | 1 | 2 | 3 |\n+----------------+---+---+---+---+\n| DID_Field_Size | 0 | 1 | 2 | 4 |\n+----------------+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1.1.2. Window Descriptor",
      "section_title": true,
      "ja": "3.1.1.1.2。 ウィンドウ記述子"
    },
    {
      "indent": 3,
      "text": "This provides guarantees about the minimum memory buffer required to decompress a frame. This information is important for decoders to allocate enough memory.",
      "ja": "これにより、フレームの圧縮解除に必要な最小メモリバッファが保証されます。 この情報は、デコーダが十分なメモリを割り当てるために重要です。"
    },
    {
      "indent": 3,
      "text": "The Window_Descriptor byte is optional. When Single_Segment_Flag is set, Window_Descriptor is not present. In this case, Window_Size is Frame_Content_Size, which can be any value from 0 to 2^64-1 bytes (16 ExaBytes).",
      "ja": "Window_Descriptorバイトはオプションです。 Single_Segment_Flagが設定されている場合、Window_Descriptorは存在しません。 この場合、Window_SizeはFrame_Content_Sizeであり、0〜2 ^ 64-1バイト（16 ExaBytes）の任意の値にできます。"
    },
    {
      "indent": 5,
      "text": "+------------+----------+----------+\n| Bit Number |   7-3    |   2-0    |\n+------------+----------+----------+\n| Field Name | Exponent | Mantissa |\n+------------+----------+----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The minimum memory buffer size is called Window_Size. It is described by the following formulae:",
      "ja": "最小メモリバッファサイズはWindow_Sizeと呼ばれます。 次の式で説明されます。"
    },
    {
      "indent": 5,
      "text": "windowLog = 10 + Exponent;\nwindowBase = 1 << windowLog;\nwindowAdd = (windowBase / 8) * Mantissa;\nWindow_Size = windowBase + windowAdd;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The minimum Window_Size is 1 KB. The maximum Window_Size is (1<<41) + 7*(1<<38) bytes, which is 3.75 TB.",
      "ja": "最小のWindow_Sizeは1 KBです。 最大Window_Sizeは（1 << 41）+ 7 *（1 << 38）バイトで、3.75 TBです。"
    },
    {
      "indent": 3,
      "text": "In general, larger Window_Size values tend to improve the compression ratio, but at the cost of increased memory usage.",
      "ja": "一般に、Window_Sizeの値を大きくすると圧縮率が向上する傾向がありますが、メモリ使用量が増加します。"
    },
    {
      "indent": 3,
      "text": "To properly decode compressed data, a decoder will need to allocate a buffer of at least Window_Size bytes.",
      "ja": "圧縮されたデータを適切にデコードするには、デコーダは少なくともWindow_Sizeバイトのバッファを割り当てる必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to protect decoders from unreasonable memory requirements, a decoder is allowed to reject a compressed frame that requests a memory size beyond decoder's authorized range.",
      "ja": "デコーダを不合理なメモリ要件から保護するために、デコーダは、デコーダの許可範囲を超えるメモリサイズを要求する圧縮フレームを拒否できます。"
    },
    {
      "indent": 3,
      "text": "For improved interoperability, it's recommended for decoders to support values of Window_Size up to 8 MB and for encoders not to generate frames requiring a Window_Size larger than 8 MB. It's merely a recommendation though, and decoders are free to support larger or lower limits, depending on local limitations.",
      "ja": "相互運用性を向上させるには、デコーダが最大8 MBのWindow_Sizeの値をサポートし、エンコーダが8 MBを超えるWindow_Sizeを必要とするフレームを生成しないことをお勧めします。 ただし、これは単なる推奨事項であり、デコーダはローカルの制限に応じて、より大きな制限またはより小さな制限を自由にサポートできます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.3. Dictionary_ID",
      "section_title": true,
      "ja": "3.1.1.1.3。 Dictionary_ID"
    },
    {
      "indent": 3,
      "text": "This is a variable size field, which contains the ID of the dictionary required to properly decode the frame. This field is optional. When it's not present, it's up to the decoder to know which dictionary to use.",
      "ja": "これは可変サイズのフィールドで、フレームを適切にデコードするために必要な辞書のIDが含まれています。 このフィールドはオプションです。 存在しない場合、使用する辞書を知るのはデコーダー次第です。"
    },
    {
      "indent": 3,
      "text": "Dictionary_ID field size is provided by DID_Field_Size. DID_Field_Size is directly derived from the value of Dictionary_ID_Flag. One byte can represent an ID 0-255; 2 bytes can represent an ID 0-65535; 4 bytes can represent an ID 0-4294967295. Format is little-endian.",
      "ja": "Dictionary_IDフィールドサイズは、DID_Field_Sizeによって提供されます。 DID_Field_Sizeは、Dictionary_ID_Flagの値から直接導出されます。 1バイトはID 0-255を表すことができます。 2バイトはID 0-65535を表すことができます。 4バイトはID 0-4294967295を表すことができます。 形式はリトルエンディアンです。"
    },
    {
      "indent": 3,
      "text": "It is permitted to represent a small ID (for example, 13) with a large 4-byte dictionary ID, even if it is less efficient.",
      "ja": "効率が悪くても、小さな4バイトの辞書IDで小さなID（たとえば、13）を表すことは許可されています。"
    },
    {
      "indent": 3,
      "text": "Within private environments, any dictionary ID can be used. However, for frames and dictionaries distributed in public space, Dictionary_ID must be attributed carefully. The following ranges are reserved for use only with dictionaries that have been registered with IANA (see Section 6.3):",
      "ja": "プライベート環境内では、任意の辞書IDを使用できます。 ただし、パブリックスペースで配布されるフレームと辞書の場合、Dictionary_IDは慎重に属性付けする必要があります。 次の範囲は、IANAに登録されている辞書でのみ使用するために予約されています（セクション6.3を参照）。"
    },
    {
      "indent": 3,
      "text": "low range: <= 32767 high range: >= (1 << 31)",
      "ja": "低範囲：<= 32767高範囲：> =（1 << 31）"
    },
    {
      "indent": 3,
      "text": "Any other value for Dictionary_ID can be used by private arrangement between participants.",
      "ja": "Dictionary_IDの他の値は、参加者間のプライベートアレンジメントで使用できます。"
    },
    {
      "indent": 3,
      "text": "Any payload presented for decompression that references an unregistered reserved dictionary ID results in an error.",
      "ja": "未登録の予約済み辞書IDを参照する、解凍用に提示されたペイロードはすべてエラーになります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1.4. Frame Content Size",
      "section_title": true,
      "ja": "3.1.1.1.4。 フレームコンテンツサイズ"
    },
    {
      "indent": 3,
      "text": "This is the original (uncompressed) size. This information is optional. Frame_Content_Size uses a variable number of bytes, provided by FCS_Field_Size. FCS_Field_Size is provided by the value of Frame_Content_Size_Flag. FCS_Field_Size can be equal to 0 (not present), 1, 2, 4, or 8 bytes.",
      "ja": "これは元の（非圧縮）サイズです。 この情報はオプションです。 Frame_Content_Sizeは、FCS_Field_Sizeによって提供される可変バイト数を使用します。 FCS_Field_Sizeは、Frame_Content_Size_Flagの値によって提供されます。 FCS_Field_Sizeは、0（存在しない）、1、2、4、または8バイトに等しくすることができます。"
    },
    {
      "indent": 5,
      "text": "+----------------+--------------+\n| FCS Field Size | Range        |\n+----------------+--------------+\n|        0       | unknown      |\n+----------------+--------------+\n|        1       | 0 - 255      |\n+----------------+--------------+\n|        2       | 256 - 65791  |\n+----------------+--------------+\n|        4       | 0 - 2^32 - 1 |\n+----------------+--------------+\n|        8       | 0 - 2^64 - 1 |\n+----------------+--------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Frame_Content_Size format is little-endian. When FCS_Field_Size is 1, 4, or 8 bytes, the value is read directly. When FCS_Field_Size is 2, the offset of 256 is added. It's allowed to represent a small size (for example 18) using any compatible variant.",
      "ja": "Frame_Content_Size形式はリトルエンディアンです。 FCS_Field_Sizeが1、4、または8バイトの場合、値は直接読み取られます。 FCS_Field_Sizeが2の場合、256のオフセットが追加されます。 互換性のあるバリアントを使用して、小さいサイズ（たとえば18）を表すことができます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2. Blocks",
      "section_title": true,
      "ja": "3.1.1.2。 ブロック"
    },
    {
      "indent": 3,
      "text": "After Magic_Number and Frame_Header, there are some number of blocks. Each frame must have at least 1 block, but there is no upper limit on the number of blocks per frame.",
      "ja": "Magic_NumberとFrame_Headerの後に、いくつかのブロックがあります。 各フレームには少なくとも1つのブロックが必要ですが、フレームあたりのブロック数に上限はありません。"
    },
    {
      "indent": 3,
      "text": "The structure of a block is as follows:",
      "ja": "ブロックの構造は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+--------------+---------------+\n| Block_Header | Block_Content |\n+--------------+---------------+\n|    3 bytes   |    n bytes    |\n+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Block_Header uses 3 bytes, written using little-endian convention. It contains three fields:",
      "ja": "Block_Headerは、リトルエンディアン規則を使用して記述された3バイトを使用します。 次の3つのフィールドが含まれます。"
    },
    {
      "indent": 5,
      "text": "+------------+------------+------------+\n| Last_Block | Block_Type | Block_Size |\n+------------+------------+------------+\n|    bit 0   |   bits 1-2 |  bits 3-23 |\n+------------+------------+------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1.2.1. Last_Block",
      "section_title": true,
      "ja": "3.1.1.2.1。 Last_Block"
    },
    {
      "indent": 3,
      "text": "The lowest bit (Last_Block) signals whether this block is the last one. The frame will end after this last block. It may be followed by an optional Content_Checksum (see Section 3.1.1).",
      "ja": "最下位ビット（Last_Block）は、このブロックが最後のものかどうかを示します。 フレームは、この最後のブロックの後に終了します。 オプションのContent_Checksumが続く場合があります（セクション3.1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2.2. Block_Type",
      "section_title": true,
      "ja": "3.1.1.2.2。 Block_Type"
    },
    {
      "indent": 3,
      "text": "The next 2 bits represent the Block_Type. There are four block types:",
      "ja": "次の2ビットはBlock_Typeを表します。 4つのブロックタイプがあります。"
    },
    {
      "indent": 5,
      "text": "+-----------+------------------+\n|   Value   |    Block_Type    |\n+-----------+------------------+\n|     0     |     Raw_Block    |\n+-----------+------------------+\n|     1     |     RLE_Block    |\n+-----------+------------------+\n|     2     | Compressed_Block |\n+-----------+------------------+\n|     3     |     Reserved     |\n+-----------+------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Raw_Block: This is an uncompressed block. Block_Content contains Block_Size bytes.",
      "ja": "Raw_Block：これは非圧縮ブロックです。 Block_ContentにはBlock_Sizeバイトが含まれます。"
    },
    {
      "indent": 3,
      "text": "RLE_Block: This is a single byte, repeated Block_Size times. Block_Content consists of a single byte. On the decompression side, this byte must be repeated Block_Size times.",
      "ja": "RLE_Block：これは1バイトで、Block_Size回繰り返されます。 Block_Contentは1バイトで構成されます。 解凍側では、このバイトをBlock_Size回繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Compressed_Block: This is a compressed block as described in Section 3.1.1.3. Block_Size is the length of Block_Content, namely the compressed data. The decompressed size is not known, but its maximum possible value is guaranteed (see below).",
      "ja": "Compressed_Block：これは、セクション3.1.1.3で説明されている圧縮ブロックです。 Block_Sizeは、Block_Contentの長さ、つまり圧縮データです。 解凍されたサイズは不明ですが、可能な最大値が保証されています（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "Reserved: This is not a block. This value cannot be used with the current specification. If such a value is present, it is considered to be corrupt data.",
      "ja": "予約済み：これはブロックではありません。 この値は現在の仕様では使用できません。 そのような値が存在する場合、破損したデータと見なされます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2.3. Block_Size",
      "section_title": true,
      "ja": "3.1.1.2.3。 ブロックサイズ"
    },
    {
      "indent": 3,
      "text": "The upper 21 bits of Block_Header represent the Block_Size. Block_Size is the size of the block excluding the header. A block can contain any number of bytes (even zero), up to Block_Maximum_Decompressed_Size, which is the smallest of:",
      "ja": "Block_Headerの上位21ビットは、Block_Sizeを表します。 Block_Sizeは、ヘッダーを除くブロックのサイズです。 ブロックには、Block_Maximum_Decompressed_Sizeまでの任意の数のバイト（ゼロでも可）を含めることができます。"
    },
    {
      "indent": 3,
      "text": "o Window_Size",
      "ja": "o Window_Size"
    },
    {
      "indent": 3,
      "text": "o 128 KB",
      "ja": "o 128 KB"
    },
    {
      "indent": 3,
      "text": "A Compressed_Block has the extra restriction that Block_Size is always strictly less than the decompressed size. If this condition cannot be respected, the block must be sent uncompressed instead (i.e., treated as a Raw_Block).",
      "ja": "Compressed_Blockには、Block_Sizeが常に圧縮解除サイズよりも厳密に小さいという追加の制限があります。 この条件を順守できない場合は、代わりにブロックを圧縮せずに送信する必要があります（つまり、Raw_Blockとして扱われます）。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3. Compressed Blocks",
      "section_title": true,
      "ja": "3.1.1.3。 圧縮ブロック"
    },
    {
      "indent": 3,
      "text": "To decompress a compressed block, the compressed size must be provided from the Block_Size field within Block_Header.",
      "ja": "圧縮ブロックを解凍するには、Block_Header内のBlock_Sizeフィールドから圧縮サイズを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "A compressed block consists of two sections: a Literals Section (Section 3.1.1.3.1) and a Sequences_Section (Section 3.1.1.3.2). The results of the two sections are then combined to produce the decompressed data in Sequence Execution (Section 3.1.1.4).",
      "ja": "圧縮ブロックは、リテラルセクション（セクション3.1.1.3.1）とシーケンスセクション（セクション3.1.1.3.2）の2つのセクションで構成されます。 次に、2つのセクションの結果を組み合わせて、シーケンス実行（セクション3.1.1.4）で圧縮解除されたデータを生成します。"
    },
    {
      "indent": 3,
      "text": "To decode a compressed block, the following elements are necessary:",
      "ja": "圧縮ブロックをデコードするには、次の要素が必要です。"
    },
    {
      "indent": 3,
      "text": "o Previous decoded data, up to a distance of Window_Size, or the beginning of the Frame, whichever is smaller. Single_Segment_Flag will be set in the latter case.",
      "ja": "o Window_Sizeの距離まで、またはフレームの先頭までのいずれか小さい方までの、以前にデコードされたデータ。 Single_Segment_Flagは、後者の場合に設定されます。"
    },
    {
      "indent": 3,
      "text": "o List of \"recent offsets\" from the previous Compressed_Block.",
      "ja": "o前のCompressed_Blockからの「最近のオフセット」のリスト。"
    },
    {
      "indent": 3,
      "text": "o The previous Huffman tree, required by Treeless_Literals_Block type.",
      "ja": "o Treeless_Literals_Blockタイプで必要な以前のハフマンツリー。"
    },
    {
      "indent": 3,
      "text": "o Previous Finite State Entropy (FSE) decoding tables, required by Repeat_Mode, for each symbol type (literals lengths, match lengths, offsets).",
      "ja": "o各シンボルタイプ（リテラル長、一致長、オフセット）のRepeat_Modeで必要な以前の有限状態エントロピー（FSE）デコードテーブル。"
    },
    {
      "indent": 3,
      "text": "Note that decoding tables are not always from the previous Compressed_Block:",
      "ja": "デコードテーブルは、常に以前のCompressed_Blockからのものではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Every decoding table can come from a dictionary.",
      "ja": "oすべてのデコードテーブルは辞書から取得できます。"
    },
    {
      "indent": 3,
      "text": "o The Huffman tree comes from the previous Compressed_Literals_Block.",
      "ja": "oハフマンツリーは、以前のCompressed_Literals_Blockから派生しています。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1. Literals_Section_Header",
      "section_title": true,
      "ja": "3.1.1.3.1。 Literals_Section_Header"
    },
    {
      "indent": 3,
      "text": "All literals are regrouped in the first part of the block. They can be decoded first and then copied during Sequence Execution (see Section 3.1.1.4), or they can be decoded on the flow during Sequence Execution.",
      "ja": "すべてのリテラルは、ブロックの最初の部分で再グループ化されます。 最初にデコードしてからシーケンス実行中にコピーするか（セクション3.1.1.4を参照）、シーケンス実行中にフローでデコードすることができます。"
    },
    {
      "indent": 3,
      "text": "Literals can be stored uncompressed or compressed using Huffman prefix codes. When compressed, an optional tree description can be present, followed by 1 or 4 streams.",
      "ja": "リテラルは、Huffmanプレフィックスコードを使用して非圧縮または圧縮で保存できます。 圧縮されると、オプションのツリー記述が存在し、その後に1つまたは4つのストリームが続きます。"
    },
    {
      "indent": 5,
      "text": "+----------------------------+\n|   Literals_Section_Header  |\n+----------------------------+\n| [Huffman_Tree_Description] |\n+----------------------------+\n|        [Jump_Table]        |\n+----------------------------+\n|          Stream_1          |\n+----------------------------+\n|         [Stream_2]         |\n+----------------------------+\n|         [Stream_3]         |\n+----------------------------+\n|         [Stream_4]         |\n+----------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.1. Literals_Section_Header",
      "section_title": true,
      "ja": "3.1.1.3.1.1。 Literals_Section_Header"
    },
    {
      "indent": 3,
      "text": "This field describes how literals are packed. It's a byte-aligned variable-size bit field, ranging from 1 to 5 bytes, using little-endian convention.",
      "ja": "このフィールドは、リテラルのパック方法を示します。 これは、リトルエンディアンの規則を使用した、1〜5バイトの範囲のバイト調整された可変サイズのビットフィールドです。"
    },
    {
      "indent": 5,
      "text": "+---------------------+-----------+\n| Literals_Block_Type |  2 bits   |\n+---------------------+-----------+\n|     Size_Format     | 1-2 bits  |\n+---------------------+-----------+\n|   Regenerated_Size  | 5-20 bits |\n+---------------------+-----------+\n|  [Compressed_Size]  | 0-18 bits |\n+---------------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this representation, bits at the top are the lowest bits.",
      "ja": "この表現では、最上位のビットが最下位ビットです。"
    },
    {
      "indent": 3,
      "text": "The Literals_Block_Type field uses the two lowest bits of the first byte, describing four different block types:",
      "ja": "Literals_Block_Typeフィールドは、最初のバイトの最下位2ビットを使用して、4つの異なるブロックタイプを記述します。"
    },
    {
      "indent": 5,
      "text": "+---------------------------+-------+\n|    Literals_Block_Type    | Value |\n+---------------------------+-------+\n|     Raw_Literals_Block    |   0   |\n+---------------------------+-------+\n|     RLE_Literals_Block    |   1   |\n+---------------------------+-------+\n| Compressed_Literals_Block |   2   |\n+---------------------------+-------+\n|  Treeless_Literals_Block  |   3   |\n+---------------------------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Raw_Literals_Block: Literals are stored uncompressed. Literals_Section_Content is Regenerated_Size.",
      "ja": "Raw_Literals_Block：リテラルは非圧縮で保存されます。 Literals_Section_ContentはRegenerated_Sizeです。"
    },
    {
      "indent": 3,
      "text": "RLE_Literals_Block: Literals consist of a single-byte value repeated Regenerated_Size times. Literals_Section_Content is 1.",
      "ja": "RLE_Literals_Block：リテラルは、Regenerated_Size回繰り返されるシングルバイト値で構成されます。 Literals_Section_Contentは1です。"
    },
    {
      "indent": 3,
      "text": "Compressed_Literals_Block: This is a standard Huffman-compressed block, starting with a Huffman tree description. See details below. Literals_Section_Content is Compressed_Size.",
      "ja": "Compressed_Literals_Block：これは標準のハフマン圧縮ブロックであり、ハフマンツリーの説明から始まります。 以下の詳細を参照してください。 Literals_Section_ContentはCompressed_Sizeです。"
    },
    {
      "indent": 3,
      "text": "Treeless_Literals_Block: This is a Huffman-compressed block, using the Huffman tree from the previous Compressed_Literals_Block, or a dictionary if there is no previous Huffman-compressed literals block. Huffman_Tree_Description will be skipped. Note that if this mode is triggered without any previous Huffman-table in the frame (or dictionary, per Section 5), it should be treated as data corruption. Literals_Section_Content is Compressed_Size.",
      "ja": "Treeless_Literals_Block：これは、以前のCompressed_Literals_BlockのHuffmanツリーを使用するHuffman圧縮ブロック、または以前のHuffman圧縮リテラルブロックがない場合は辞書です。 Huffman_Tree_Descriptionはスキップされます。 このモードがフレーム内の以前のハフマンテーブル（またはセクション5ごとの辞書）なしでトリガーされた場合、データ破損として扱われることに注意してください。 Literals_Section_ContentはCompressed_Sizeです。"
    },
    {
      "indent": 3,
      "text": "The Size_Format is divided into two families:",
      "ja": "Size_Formatは2つのファミリに分けられます。"
    },
    {
      "indent": 3,
      "text": "o For Raw_Literals_Block and RLE_Literals_Block, it's only necessary to decode Regenerated_Size. There is no Compressed_Size field.",
      "ja": "o Raw_Literals_BlockおよびRLE_Literals_Blockの場合、Regenerated_Sizeをデコードするだけです。 Compressed_Sizeフィールドはありません。"
    },
    {
      "indent": 3,
      "text": "o For Compressed_Block and Treeless_Literals_Block, it's required to decode both Compressed_Size and Regenerated_Size (the decompressed size). It's also necessary to decode the number of streams (1 or 4).",
      "ja": "o Compressed_BlockおよびTreeless_Literals_Blockの場合、Compressed_SizeとRegenerated_Size（解凍されたサイズ）の両方をデコードする必要があります。 また、ストリームの数（1または4）をデコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "For values spanning several bytes, the convention is little endian.",
      "ja": "数バイトにわたる値の場合、規則はリトルエンディアンです。"
    },
    {
      "indent": 3,
      "text": "Size_Format for Raw_Literals_Block and RLE_Literals_Block uses 1 or 2 bits. Its value is (Literals_Section_Header[0]>>2) & 0x3.",
      "ja": "Raw_Literals_BlockおよびRLE_Literals_BlockのSize_Formatは、1または2ビットを使用します。 その値は（Literals_Section_Header [0] >> 2）＆0x3です。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 00 or 10: Size_Format uses 1 bit. Regenerated_Size uses 5 bits (value 0-31). Literals_Section_Header uses 1 byte. Regenerated_Size = Literal_Section_Header[0]>>3.",
      "ja": "Size_Format == 00または10：Size_Formatは1ビットを使用します。 Regenerated_Sizeは5ビット（値0-31）を使用します。 Literals_Section_Headerは1バイトを使用します。 Regenerated_Size = Literal_Section_Header [0] >> 3。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 01: Size_Format uses 2 bits. Regenerated_Size uses 12 bits (values 0-4095). Literals_Section_Header uses 2 bytes. Regenerated_Size = (Literals_Section_Header[0]>>4) + (Literals_Section_Header[1]<<4).",
      "ja": "Size_Format == 01：Size_Formatは2ビットを使用します。 Regenerated_Sizeは12ビット（値0〜4095）を使用します。 Literals_Section_Headerは2バイトを使用します。 Regenerated_Size =（Literals_Section_Header [0] >> 4）+（Literals_Section_Header [1] << 4）。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 11: Size_Format uses 2 bits. Regenerated_Size uses 20 bits (values 0-1048575). Literals_Section_Header uses 3 bytes. Regenerated_Size = (Literals_Section_Header[0]>>4) + (Literals_Section_Header[1]<<4) + (Literals_Section_Header[2]<<12)",
      "ja": "Size_Format == 11：Size_Formatは2ビットを使用します。 Regenerated_Sizeは20ビット（値0-1048575）を使用します。 Literals_Section_Headerは3バイトを使用します。 Regenerated_Size =（Literals_Section_Header [0] >> 4）+（Literals_Section_Header [1] << 4）+（Literals_Section_Header [2] << 12）"
    },
    {
      "indent": 3,
      "text": "Only Stream_1 is present for these cases. Note that it is permitted to represent a short value (for example, 13) using a long format, even if it's less efficient.",
      "ja": "これらの場合、Stream_1のみが存在します。 効率が悪くても、長い形式を使用して短い値（13など）を表すことが許可されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Size_Format for Compressed_Literals_Block and Treeless_Literals_Block always uses 2 bits.",
      "ja": "Compressed_Literals_BlockおよびTreeless_Literals_BlockのSize_Formatは常に2ビットを使用します。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 00: A single stream. Both Regenerated_Size and Compressed_Size use 10 bits (values 0-1023). Literals_Section_Header uses 3 bytes.",
      "ja": "Size_Format == 00：単一のストリーム。 Regenerated_SizeとCompressed_Sizeは両方とも10ビット（値0〜1023）を使用します。 Literals_Section_Headerは3バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 01: 4 streams. Both Regenerated_Size and Compressed_Size use 10 bits (values 0-1023). Literals_Section_Header uses 3 bytes.",
      "ja": "Size_Format == 01：4ストリーム。 Regenerated_SizeとCompressed_Sizeは両方とも10ビット（値0〜1023）を使用します。 Literals_Section_Headerは3バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 10: 4 streams. Both Regenerated_Size and Compressed_Size use 14 bits (values 0-16383). Literals_Section_Header uses 4 bytes.",
      "ja": "Size_Format == 10：4ストリーム。 Regenerated_SizeとCompressed_Sizeは両方とも14ビット（値0-16383）を使用します。 Literals_Section_Headerは4バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "Size_Format == 11: 4 streams. Both Regenerated_Size and Compressed_Size use 18 bits (values 0-262143). Literals_Section_Header uses 5 bytes.",
      "ja": "Size_Format == 11：4ストリーム。 Regenerated_SizeとCompressed_Sizeは両方とも18ビット（値0〜262143）を使用します。 Literals_Section_Headerは5バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "Both the Compressed_Size and Regenerated_Size fields follow little-endian convention. Note that Compressed_Size includes the size of the Huffman_Tree_Description when it is present.",
      "ja": "Compressed_SizeフィールドとRegenerated_Sizeフィールドはどちらもリトルエンディアンの規則に従います。 Compressed_Sizeには、Huffman_Tree_Descriptionが存在する場合、そのサイズが含まれることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.2. Raw_Literals_Block",
      "section_title": true,
      "ja": "3.1.1.3.1.2。 Raw_Literals_Block"
    },
    {
      "indent": 3,
      "text": "The data in Stream_1 is Regenerated_Size bytes long. It contains the raw literals data to be used during Sequence Execution (Section 3.1.1.3.2).",
      "ja": "Stream_1のデータはRegenerated_Sizeバイト長です。 これには、シーケンス実行中に使用される未加工のリテラルデータが含まれます（セクション3.1.1.3.2）。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.3. RLE_Literals_Block",
      "section_title": true,
      "ja": "3.1.1.3.1.3。 RLE_Literals_Block"
    },
    {
      "indent": 3,
      "text": "Stream_1 consists of a single byte that should be repeated Regenerated_Size times to generate the decoded literals.",
      "ja": "Stream_1は、デコードされたリテラルを生成するためにRegenerated_Size回繰り返される単一バイトで構成されます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.4. Compressed_Literals_Block and Treeless_Literals_Block",
      "section_title": true,
      "ja": "3.1.1.3.1.4。 Compressed_Literals_BlockおよびTreeless_Literals_Block"
    },
    {
      "indent": 3,
      "text": "Both of these modes contain Huffman-encoded data. For Treeless_Literals_Block, the Huffman table comes from the previously compressed literals block, or from a dictionary; see Section 5.",
      "ja": "これらのモードには両方とも、ハフマンエンコードデータが含まれています。 Treeless_Literals_Blockの場合、Huffmanテーブルは、以前に圧縮されたリテラルブロックまたは辞書から取得されます。 セクション5を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.5. Huffman_Tree_Description",
      "section_title": true,
      "ja": "3.1.1.3.1.5。 Huffman_Tree_Description"
    },
    {
      "indent": 3,
      "text": "This section is only present when the Literals_Block_Type type is Compressed_Literals_Block (2). The format of Huffman_Tree_Description can be found in Section 4.2.1. The size of Huffman_Tree_Description is determined during the decoding process. It must be used to determine where streams begin.",
      "ja": "このセクションは、Literals_Block_TypeタイプがCompressed_Literals_Block（2）の場合にのみ表示されます。 Huffman_Tree_Descriptionの形式はセクション4.2.1にあります。 Huffman_Tree_Descriptionのサイズは、デコードプロセス中に決定されます。 ストリームの開始位置を決定するために使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "Total_Streams_Size = Compressed_Size - Huffman_Tree_Description_Size",
      "ja": "Total_Streams_Size = Compressed_Size-Huffman_Tree_Description_Size"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.1.6. Jump_Table",
      "section_title": true,
      "ja": "3.1.1.3.1.6。 Jump_Table"
    },
    {
      "indent": 3,
      "text": "The Jump_Table is only present when there are 4 Huffman-coded streams.",
      "ja": "Jump_Tableは、4つのハフマン符号化ストリームがある場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "(Reminder: Huffman-compressed data consists of either 1 or 4 Huffman-coded streams.)",
      "ja": "（注意：ハフマン圧縮データは、1つまたは4つのハフマン符号化ストリームで構成されます。）"
    },
    {
      "indent": 3,
      "text": "If only 1 stream is present, it is a single bitstream occupying the entire remaining portion of the literals block, encoded as described within Section 4.2.2.",
      "ja": "ストリームが1つしかない場合、それはリテラルブロックの残りの部分全体を占める単一のビットストリームであり、セクション4.2.2で説明されているようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "If there are 4 streams, Literals_Section_Header only provides enough information to know the decompressed and compressed sizes of all 4 streams combined. The decompressed size of each stream is equal to (Regenerated_Size+3)/4, except for the last stream, which may be up to 3 bytes smaller, to reach a total decompressed size as specified in Regenerated_Size.",
      "ja": "4つのストリームがある場合、Literals_Section_Headerは、4つすべてのストリームの結合された圧縮解除および圧縮サイズを知るのに十分な情報のみを提供します。 各ストリームの解凍サイズは、（Regenerated_Size + 3）/ 4に等しくなります。ただし、最後のストリームは例外で、Regenerated_Sizeで指定された合計解凍サイズに達するために最大3バイト小さくなります。"
    },
    {
      "indent": 3,
      "text": "The compressed size of each stream is provided explicitly in the Jump_Table. The Jump_Table is 6 bytes long and consists of three 2-byte little-endian fields, describing the compressed sizes of the first 3 streams. Stream4_Size is computed from Total_Streams_Size minus sizes of other streams.",
      "ja": "各ストリームの圧縮サイズは、Jump_Tableで明示的に提供されます。 Jump_Tableは6バイト長で、3つの2バイトのリトルエンディアンフィールドで構成され、最初の3つのストリームの圧縮サイズを記述します。 Stream4_Sizeは、Total_Streams_Sizeから他のストリームのサイズを差し引いて計算されます。"
    },
    {
      "indent": 5,
      "text": "Stream4_Size = Total_Streams_Size - 6 - Stream1_Size - Stream2_Size - Stream3_Size",
      "ja": "Stream4_Size = Total_Streams_Size-6-Stream1_Size-Stream2_Size-Stream3_Size"
    },
    {
      "indent": 3,
      "text": "Note that if Stream1_Size + Stream2_Size + Stream3_Size exceeds Total_Streams_Size, the data are considered corrupted.",
      "ja": "Stream1_Size + Stream2_Size + Stream3_SizeがTotal_Streams_Sizeを超える場合、データは破損していると見なされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Each of these 4 bitstreams is then decoded independently as a Huffman-Coded stream, as described in Section 4.2.2.",
      "ja": "これらの4つのビットストリームのそれぞれは、セクション4.2.2で説明されているように、ハフマン符号化ストリームとして個別にデコードされます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2. Sequences_Section",
      "section_title": true,
      "ja": "3.1.1.3.2。 Sequences_Section"
    },
    {
      "indent": 3,
      "text": "A compressed block is a succession of sequences. A sequence is a literal copy command, followed by a match copy command. A literal copy command specifies a length. It is the number of bytes to be copied (or extracted) from the Literals Section. A match copy command specifies an offset and a length.",
      "ja": "圧縮ブロックは一連のシーケンスです。 シーケンスはリテラルコピーコマンドで、その後に一致コピーコマンドが続きます。 リテラルコピーコマンドは長さを指定します。 これは、リテラルセクションからコピー（または抽出）されるバイト数です。 match copyコマンドは、オフセットと長さを指定します。"
    },
    {
      "indent": 3,
      "text": "When all sequences are decoded, if there are literals left in the literals section, these bytes are added at the end of the block.",
      "ja": "すべてのシーケンスがデコードされ、リテラルセクションにリテラルが残っている場合、これらのバイトはブロックの最後に追加されます。"
    },
    {
      "indent": 3,
      "text": "This is described in more detail in Section 3.1.1.4.",
      "ja": "これについては、3.1.1.4項で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "The Sequences_Section regroups all symbols required to decode commands. There are three symbol types: literals lengths, offsets, and match lengths. They are encoded together, interleaved, in a single \"bitstream\".",
      "ja": "Sequences_Sectionは、コマンドのデコードに必要なすべてのシンボルを再グループ化します。 シンボルには、リテラルの長さ、オフセット、および一致の長さの3つのタイプがあります。 これらは、単一の「ビットストリーム」に一緒にエンコードされ、インターリーブされます。"
    },
    {
      "indent": 3,
      "text": "The Sequences_Section starts by a header, followed by optional probability tables for each symbol type, followed by the bitstream.",
      "ja": "Sequences_Sectionはヘッダーで始まり、その後に各シンボルタイプのオプションの確率テーブルが続き、その後にビットストリームが続きます。"
    },
    {
      "indent": 5,
      "text": "Sequences_Section_Header [Literals_Length_Table] [Offset_Table] [Match_Length_Table] bitStream",
      "ja": "Sequences_Section_Header [Literals_Length_Table] [Offset_Table] [Match_Length_Table] bitStream"
    },
    {
      "indent": 3,
      "text": "To decode the Sequences_Section, it's necessary to know its size. This size is deduced from the size of the Literals_Section: Sequences_Section_Size = Block_Size - Literals_Section_Header - Literals_Section_Content",
      "ja": "Sequences_Sectionをデコードするには、そのサイズを知る必要があります。 このサイズはLiterals_Sectionのサイズから推定されます。Sequences_Section_Size = Block_Size-Literals_Section_Header-Literals_Section_Content"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.1. Sequences_Section_Header",
      "section_title": true,
      "ja": "3.1.1.3.2.1。 Sequences_Section_Header"
    },
    {
      "indent": 3,
      "text": "This header consists of two items:",
      "ja": "このヘッダーは2つのアイテムで構成されています。"
    },
    {
      "indent": 3,
      "text": "o Number_of_Sequences",
      "ja": "o Number_of_Sequences"
    },
    {
      "indent": 3,
      "text": "o Symbol_Compression_Modes",
      "ja": "o Symbol_Compression_Modes"
    },
    {
      "indent": 3,
      "text": "Number_of_Sequences is a variable size field using between 1 and 3 bytes. If the first byte is \"byte0\":",
      "ja": "Number_of_Sequencesは、1〜3バイトを使用する可変サイズのフィールドです。 最初のバイトが「byte0」の場合："
    },
    {
      "indent": 3,
      "text": "o if (byte0 == 0): there are no sequences. The sequence section stops here. Decompressed content is defined entirely as Literals Section content. The FSE tables used in Repeat_Mode are not updated.",
      "ja": "o if（byte0 == 0）：シーケンスはありません。 シーケンスセクションはここで終了します。 解凍されたコンテンツは、リテラルセクションコンテンツとして完全に定義されます。 Repeat_Modeで使用されるFSEテーブルは更新されません。"
    },
    {
      "indent": 3,
      "text": "o if (byte0 < 128): Number_of_Sequences = byte0. Uses 1 byte.",
      "ja": "o if（byte0 <128）：Number_of_Sequences = byte0。 1バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "o if (byte0 < 255): Number_of_Sequences = ((byte0 - 128) << 8) + byte1. Uses 2 bytes.",
      "ja": "o if（byte0 <255）：シーケンス数=（（byte0-128）<< 8）+ byte1。 2バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "o if (byte0 == 255): Number_of_Sequences = byte1 + (byte2 << 8) + 0x7F00. Uses 3 bytes.",
      "ja": "o if（byte0 == 255）：Number_of_Sequences = byte1 +（byte2 << 8）+ 0x7F00 3バイトを使用します。"
    },
    {
      "indent": 3,
      "text": "Symbol_Compression_Modes is a single byte, defining the compression mode of each symbol type.",
      "ja": "Symbol_Compression_Modesはシングルバイトで、各シンボルタイプの圧縮モードを定義します。"
    },
    {
      "indent": 5,
      "text": "+-------------+----------------------+\n| Bit Number  |      Field Name      |\n+-------------+----------------------+\n|     7-6     | Literal_Lengths_Mode |\n+-------------+----------------------+\n|     5-4     |     Offsets_Mode     |\n+-------------+----------------------+\n|     3-2     |  Match_Lengths_Mode  |\n+-------------+----------------------+\n|     1-0     |       Reserved       |\n+-------------+----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The last field, Reserved, must be all zeroes.",
      "ja": "最後の予約済みフィールドは、すべてゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Literals_Lengths_Mode, Offsets_Mode, and Match_Lengths_Mode define the Compression_Mode of literals lengths, offsets, and match lengths symbols, respectively. They follow the same enumeration:",
      "ja": "Literals_Lengths_Mode、Offsets_Mode、およびMatch_Lengths_Modeは、それぞれリテラルの長さ、オフセット、および一致長のシンボルのCompression_Modeを定義します。 それらは同じ列挙に従います："
    },
    {
      "indent": 5,
      "text": "+-------+---------------------+\n| Value |  Compression_Mode   |\n+-------+---------------------+\n|   0   |   Predefined_Mode   |\n+-------+---------------------+\n|   1   |      RLE_Mode       |\n+-------+---------------------+\n|   2   | FSE_Compressed_Mode |\n+-------+---------------------+\n|   3   |     Repeat_Mode     |\n+-------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Predefined_Mode: A predefined FSE (see Section 4.1) distribution table is used, as defined in Section 3.1.1.3.2.2. No distribution table will be present.",
      "ja": "Predefined_Mode：セクション3.1.1.3.2.2で定義されているように、事前定義されたFSE（セクション4.1を参照）配布テーブルが使用されます。 配布テーブルは存在しません。"
    },
    {
      "indent": 3,
      "text": "RLE_Mode: The table description consists of a single byte, which contains the symbol's value. This symbol will be used for all sequences.",
      "ja": "RLE_Mode：テーブルの説明は、シンボルの値を含む1バイトで構成されます。 このシンボルは、すべてのシーケンスに使用されます。"
    },
    {
      "indent": 3,
      "text": "FSE_Compressed_Mode: Standard FSE compression. A distribution table will be present. The format of this distribution table is described in Section 4.1.1. Note that the maximum allowed accuracy log for literals length and match length tables is 9, and the maximum accuracy log for the offsets table is 8. This mode must not be used when only one symbol is present; RLE_Mode should be used instead (although any other mode will work).",
      "ja": "FSE_Compressed_Mode：標準のFSE圧縮。 配布テーブルが存在します。 この配布テーブルの形式については、セクション4.1.1で説明しています。 リテラル長と一致長のテーブルの最大許容精度ログは9であり、オフセットテーブルの最大精度ログは8であることに注意してください。このモードは、シンボルが1つしかない場合は使用しないでください。 代わりにRLE_Modeを使用する必要があります（ただし、他のモードでも機能します）。"
    },
    {
      "indent": 3,
      "text": "Repeat_Mode: The table used in the previous Compressed_Block with Number_Of_Sequences > 0 will be used again, or if this is the first block, the table in the dictionary will be used. Note that this includes RLE_Mode, so if Repeat_Mode follows RLE_Mode, the same symbol will be repeated. It also includes Predefined_Mode, in which case Repeat_Mode will have the same outcome as Predefined_Mode. No distribution table will be present. If this mode is used without any previous sequence table in the frame (or dictionary; see Section 5) to repeat, this should be treated as corruption.",
      "ja": "Repeat_Mode：Number_Of_Sequences> 0で以前のCompressed_Blockで使用されたテーブルが再び使用されます。これが最初のブロックである場合は、辞書のテーブルが使用されます。 これにはRLE_Modeが含まれるため、Repeat_ModeがRLE_Modeの後に続く場合、同じシンボルが繰り返されることに注意してください。 また、Predefined_Modeも含まれます。この場合、Repeat_ModeはPredefined_Modeと同じ結果になります。 配布テーブルは存在しません。 フレーム内の以前のシーケンステーブル（または辞書。セクション5を参照）を使用せずにこのモードを使用して繰り返す場合、これは破損として扱われる必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.1.1. Sequence Codes for Lengths and Offsets",
      "section_title": true,
      "ja": "3.1.1.3.2.1.1。 長さとオフセットのシーケンスコード"
    },
    {
      "indent": 3,
      "text": "Each symbol is a code in its own context, which specifies Baseline and Number_of_Bits to add. Codes are FSE compressed and interleaved with raw additional bits in the same bitstream.",
      "ja": "各シンボルは、追加するベースラインとNumber_of_Bitsを指定する独自のコンテキスト内のコードです。 コードはFSE圧縮され、同じビットストリーム内の生の追加ビットでインターリーブされます。"
    },
    {
      "indent": 3,
      "text": "Literals length codes are values ranging from 0 to 35 inclusive. They define lengths from 0 to 131071 bytes. The literals length is equal to the decoded Baseline plus the result of reading Number_of_Bits bits from the bitstream, as a little-endian value.",
      "ja": "リテラル長コードは、0〜35の範囲の値です。 0〜131071バイトの長さを定義します。 リテラルの長さは、デコードされたベースラインに、ビットストリームからNumber_of_Bitsビットを読み込んだ結果に、リトルエンディアン値として等しくなります。"
    },
    {
      "indent": 5,
      "text": "+----------------------+----------+----------------+\n| Literals_Length_Code | Baseline | Number_of_Bits |\n+----------------------+----------+----------------+\n|         0-15         |  length  |       0        |\n+----------------------+----------+----------------+\n|          16          |    16    |       1        |\n+----------------------+----------+----------------+\n|          17          |    18    |       1        |\n+----------------------+----------+----------------+\n|          18          |    20    |       1        |\n+----------------------+----------+----------------+\n|          19          |    22    |       1        |\n+----------------------+----------+----------------+\n|          20          |    24    |       2        |\n+----------------------+----------+----------------+\n|          21          |    28    |       2        |\n+----------------------+----------+----------------+\n|          22          |    32    |       3        |\n+----------------------+----------+----------------+\n|          23          |    40    |       3        |\n+----------------------+----------+----------------+\n|          24          |    48    |       4        |\n+----------------------+----------+----------------+\n|          25          |    64    |       6        |\n+----------------------+----------+----------------+\n|          26          |    128   |       7        |\n+----------------------+----------+----------------+\n|          27          |    256   |       8        |\n+----------------------+----------+----------------+\n|          28          |    512   |       9        |\n+----------------------+----------+----------------+\n|          29          |   1024   |       10       |\n+----------------------+----------+----------------+\n|          30          |   2048   |       11       |\n+----------------------+----------+----------------+\n|          31          |   4096   |       12       |\n+----------------------+----------+----------------+\n|          32          |   8192   |       13       |\n+----------------------+----------+----------------+\n|          33          |  16384   |       14       |\n+----------------------+----------+----------------+\n|          34          |  32768   |       15       |\n+----------------------+----------+----------------+\n|          35          |  65536   |       16       |\n+----------------------+----------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Match length codes are values ranging from 0 to 52 inclusive. They define lengths from 3 to 131074 bytes. The match length is equal to the decoded Baseline plus the result of reading Number_of_Bits bits from the bitstream, as a little-endian value.",
      "ja": "一致長コードは、0〜52の範囲の値です。 これらは、3〜131074バイトの長さを定義します。 一致の長さは、デコードされたベースラインと、ビットストリームからNumber_of_Bitsビットを読み込んだ結果に、リトルエンディアン値として等しくなります。"
    },
    {
      "indent": 5,
      "text": "+-------------------+-----------------------+----------------+\n| Match_Length_Code |       Baseline        | Number_of_Bits |\n+-------------------+-----------------------+----------------+\n|        0-31       | Match_Length_Code + 3 |       0        |\n+-------------------+-----------------------+----------------+\n|         32        |          35           |       1        |\n+-------------------+-----------------------+----------------+\n|         33        |          37           |       1        |\n+-------------------+-----------------------+----------------+\n|         34        |          39           |       1        |\n+-------------------+-----------------------+----------------+\n|         35        |          41           |       1        |\n+-------------------+-----------------------+----------------+\n|         36        |          43           |       2        |\n+-------------------+-----------------------+----------------+\n|         37        |          47           |       2        |\n+-------------------+-----------------------+----------------+\n|         38        |          51           |       3        |\n+-------------------+-----------------------+----------------+\n|         39        |          59           |       3        |\n+-------------------+-----------------------+----------------+\n|         40        |          67           |       4        |\n+-------------------+-----------------------+----------------+\n|         41        |          83           |       4        |\n+-------------------+-----------------------+----------------+\n|         42        |          99           |       5        |\n+-------------------+-----------------------+----------------+\n|         43        |         131           |       7        |\n+-------------------+-----------------------+----------------+\n|         44        |         259           |       8        |\n+-------------------+-----------------------+----------------+\n|         45        |         515           |       9        |\n+-------------------+-----------------------+----------------+\n|         46        |         1027          |       10       |\n+-------------------+-----------------------+----------------+\n|         47        |         2051          |       11       |\n+-------------------+-----------------------+----------------+\n|         48        |         4099          |       12       |\n+-------------------+-----------------------+----------------+\n|         49        |         8195          |       13       |\n+-------------------+-----------------------+----------------+\n|         50        |         16387         |       14       |\n+-------------------+-----------------------+----------------+\n|         51        |         32771         |       15       |\n+-------------------+-----------------------+----------------+\n|         52        |         65539         |       16       |\n+-------------------+-----------------------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Offset codes are values ranging from 0 to N.",
      "ja": "オフセットコードは、0〜Nの範囲の値です。"
    },
    {
      "indent": 3,
      "text": "A decoder is free to limit its maximum supported value for N. Support for values of at least 22 is recommended. At the time of this writing, the reference decoder supports a maximum N value of 31.",
      "ja": "デコーダーは、Nのサポートされる最大値を自由に制限できます。少なくとも22の値のサポートが推奨されます。 この記事の執筆時点では、参照デコーダーは最大31のN値をサポートしています。"
    },
    {
      "indent": 3,
      "text": "An offset code is also the number of additional bits to read in little-endian fashion and can be translated into an Offset_Value using the following formulas:",
      "ja": "オフセットコードは、リトルエンディアン形式で読み取る追加ビットの数でもあり、次の式を使用してOffset_Valueに変換できます。"
    },
    {
      "indent": 5,
      "text": "Offset_Value = (1 << offsetCode) + readNBits(offsetCode);\nif (Offset_Value > 3) Offset = Offset_Value - 3;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This means that maximum Offset_Value is (2^(N+1))-1, supporting back-reference distance up to (2^(N+1))-4, but it is limited by the maximum back-reference distance (see Section 3.1.1.1.2).",
      "ja": "これは、最大Offset_Valueが（2 ^（N + 1））-1であり、（2 ^（N + 1））-4までの後方参照距離をサポートすることを意味しますが、最大後方参照距離によって制限されます（参照 セクション3.1.1.1.2）。"
    },
    {
      "indent": 3,
      "text": "Offset_Value from 1 to 3 are special: they define \"repeat codes\". This is described in more detail in Section 3.1.1.5.",
      "ja": "1から3までのOffset_Valueは特別です。「繰り返しコード」を定義します。 これについては、セクション3.1.1.5で詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.1.2. Decoding Sequences",
      "section_title": true,
      "ja": "3.1.1.3.2.1.2。 シーケンスのデコード"
    },
    {
      "indent": 3,
      "text": "FSE bitstreams are read in reverse of the direction they are written. In zstd, the compressor writes bits forward into a block, and the decompressor must read the bitstream backwards.",
      "ja": "FSEビットストリームは、書き込まれた方向と逆に読み取られます。 zstdでは、コンプレッサーはビットを順方向にブロックに書き込み、デコンプレッサーはビットストリームを逆方向に読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "To find the start of the bitstream, it is therefore necessary to know the offset of the last byte of the block, which can be found by counting Block_Size bytes after the block header.",
      "ja": "したがって、ビットストリームの先頭を見つけるには、ブロックの最後のバイトのオフセットを知る必要があります。これは、ブロックヘッダーの後のBlock_Sizeバイトをカウントすることで見つけることができます。"
    },
    {
      "indent": 3,
      "text": "After writing the last bit containing information, the compressor writes a single 1 bit and then fills the byte with 0-7 zero bits of padding. The last byte of the compressed bitstream cannot be zero for that reason.",
      "ja": "情報を含む最後のビットを書き込んだ後、コンプレッサーは単一の1ビットを書き込み、0〜7の0ビットのパディングでバイトを埋めます。 そのため、圧縮ビットストリームの最後のバイトをゼロにすることはできません。"
    },
    {
      "indent": 3,
      "text": "When decompressing, the last byte containing the padding is the first byte to read. The decompressor needs to skip 0-7 initial zero bits until the first 1 bit occurs. Afterwards, the useful part of the bitstream begins.",
      "ja": "圧縮解除するとき、パディングを含む最後のバイトは、読み取る最初のバイトです。 デコンプレッサは、最初の1ビットが発生するまで、0〜7の初期ゼロビットをスキップする必要があります。 その後、ビットストリームの有用な部分が始まります。"
    },
    {
      "indent": 3,
      "text": "FSE decoding requires a 'state' to be carried from symbol to symbol. For more explanation on FSE decoding, see Section 4.1.",
      "ja": "FSEデコードでは、シンボルからシンボルへと「状態」を伝達する必要があります。 FSEデコードの詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "For sequence decoding, a separate state keeps track of each literal lengths, offsets, and match lengths symbols. Some FSE primitives are also used. For more details on the operation of these primitives, see Section 4.1.",
      "ja": "シーケンスのデコードでは、個別の状態が各リテラルの長さ、オフセット、および一致長のシンボルを追跡します。 一部のFSEプリミティブも使用されます。 これらのプリミティブの操作の詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The bitstream starts with initial FSE state values, each using the required number of bits in their respective accuracy, decoded previously from their normalized distribution. It starts with Literals_Length_State, followed by Offset_State, and finally Match_Length_State.",
      "ja": "ビットストリームは、初期FSE状態値で始まります。各FSE状態値は、それぞれの精度で必要なビット数を使用し、正規化された分布から事前にデコードされます。 Literals_Length_Stateで始まり、その後にOffset_State、最後にMatch_Length_Stateが続きます。"
    },
    {
      "indent": 3,
      "text": "Note that all values are read backward, so the 'start' of the bitstream is at the highest position in memory, immediately before the last 1 bit for padding.",
      "ja": "すべての値が逆方向に読み取られるため、ビットストリームの「開始」はメモリ内の最上位、つまりパディングの最後の1ビットの直前にあることに注意してください。"
    },
    {
      "indent": 3,
      "text": "After decoding the starting states, a single sequence is decoded Number_Of_Sequences times. These sequences are decoded in order from first to last. Since the compressor writes the bitstream in the forward direction, this means the compressor must encode the sequences starting with the last one and ending with the first.",
      "ja": "開始状態をデコードした後、単一のシーケンスがNumber_Of_Sequences回デコードされます。 これらのシーケンスは、最初から最後まで順番にデコードされます。 コンプレッサーはビットストリームを順方向に書き込むため、これはコンプレッサーが最後のシーケンスから始めて最初のシーケンスで終わるシーケンスをエンコードする必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "For each of the symbol types, the FSE state can be used to determine the appropriate code. The code then defines the Baseline and Number_of_Bits to read for each type. The description of the codes for how to determine these values can be found in Section 3.1.1.3.2.1.",
      "ja": "シンボルタイプごとに、FSE状態を使用して適切なコードを決定できます。 次に、コードは、各タイプを読み取るためのBaselineとNumber_of_Bitsを定義します。 これらの値を決定する方法のコードの説明は、セクション3.1.1.3.2.1にあります。"
    },
    {
      "indent": 3,
      "text": "Decoding starts by reading the Number_of_Bits required to decode offset. It does the same for Match_Length and then for Literals_Length. This sequence is then used for Sequence Execution (see Section 3.1.1.4).",
      "ja": "デコードは、オフセットのデコードに必要なNumber_of_Bitsを読み取ることから始まります。 Match_Lengthに対してもLiterals_Lengthに対しても同じことを行います。 その後、このシーケンスはシーケンスの実行に使用されます（セクション3.1.1.4を参照）。"
    },
    {
      "indent": 3,
      "text": "If it is not the last sequence in the block, the next operation is to update states. Using the rules pre-calculated in the decoding tables, Literals_Length_State is updated, followed by Match_Length_State, and then Offset_State. See Section 4.1 for details on how to update states from the bitstream.",
      "ja": "ブロック内の最後のシーケンスでない場合、次の操作は状態の更新です。 デコードテーブルで事前に計算されたルールを使用して、Literals_Length_Stateが更新され、Match_Length_State、Offset_Stateの順に更新されます。 ビットストリームから状態を更新する方法の詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "This operation will be repeated Number_of_Sequences times. At the end, the bitstream shall be entirely consumed; otherwise, the bitstream is considered corrupted.",
      "ja": "この操作はNumber_of_Sequences回繰り返されます。 最後に、ビットストリームは完全に消費されます。 そうでない場合、ビットストリームは破損していると見なされます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.2. Default Distributions",
      "section_title": true,
      "ja": "3.1.1.3.2.2。 デフォルトの分布"
    },
    {
      "indent": 3,
      "text": "If Predefined_Mode is selected for a symbol type, its FSE decoding table is generated from a predefined distribution table defined here. For details on how to convert this distribution into a decoding table, see Section 4.1.",
      "ja": "Predefined_Modeがシンボルタイプに選択されている場合、そのFSEデコードテーブルは、ここで定義された事前定義された配布テーブルから生成されます。 この分布をデコードテーブルに変換する方法の詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.2.1. Literals Length",
      "section_title": true,
      "ja": "3.1.1.3.2.2.1。 リテラルの長さ"
    },
    {
      "indent": 3,
      "text": "The decoding table uses an accuracy log of 6 bits (64 states).",
      "ja": "デコードテーブルは、6ビット（64状態）の精度ログを使用します。"
    },
    {
      "indent": 5,
      "text": "short literalsLength_defaultDistribution[36] = { 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1, -1,-1,-1,-1 };",
      "ja": "short literalsLength_defaultDistribution [36] = {4、3、2、2、2、2、2、2、2、2、2、2、2、2、1、1、1、2、2、2、2、2、2、2 、2、2、2、3、2、1、1、1、1、1、-1、-1、-1、-1};"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.2.2. Match Length",
      "section_title": true,
      "ja": "3.1.1.3.2.2.2。 マッチの長さ"
    },
    {
      "indent": 3,
      "text": "The decoding table uses an accuracy log of 6 bits (64 states).",
      "ja": "デコードテーブルは、6ビット（64状態）の精度ログを使用します。"
    },
    {
      "indent": 5,
      "text": "short matchLengths_defaultDistribution[53] = { 1, 4, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1, -1,-1,-1,-1,-1 };",
      "ja": "short matchLengths_defaultDistribution [53] = {1、4、3、2、2、2、2、2、2、2、1、1、1、1、1、1、1、1、1、1、1、1、1、1 、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、1、- 1、-1、-1、-1、-1、-1、-1、-1};"
    },
    {
      "indent": 0,
      "text": "3.1.1.3.2.2.3. Offset Codes",
      "section_title": true,
      "ja": "3.1.1.3.2.2.3。 オフセットコード"
    },
    {
      "indent": 3,
      "text": "The decoding table uses an accuracy log of 5 bits (32 states), and supports a maximum N value of 28, allowing offset values up to 536,870,908.",
      "ja": "デコードテーブルは5ビット（32状態）の精度ログを使用し、最大N値28をサポートし、最大536,870,908のオフセット値を許可します。"
    },
    {
      "indent": 3,
      "text": "If any sequence in the compressed block requires a larger offset than this, it's not possible to use the default distribution to represent it.",
      "ja": "圧縮ブロック内のいずれかのシーケンスがこれより大きなオフセットを必要とする場合、デフォルトの分布を使用してそれを表すことはできません。"
    },
    {
      "indent": 5,
      "text": "short offsetCodes_defaultDistribution[29] = { 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1 };",
      "ja": "short offsetCodes_defaultDistribution [29] = {1、1、1、1、1、1、1、2、2、2、1、1、1、1、1、1、1、1、1、1、1、1、1、1 、1、1、-1、-1、-1、-1、-1、-1};"
    },
    {
      "indent": 0,
      "text": "3.1.1.4. Sequence Execution",
      "section_title": true,
      "ja": "3.1.1.4。 シーケンス実行"
    },
    {
      "indent": 3,
      "text": "Once literals and sequences have been decoded, they are combined to produce the decoded content of a block.",
      "ja": "リテラルとシーケンスがデコードされると、それらが組み合わされてブロックのデコードされたコンテンツが生成されます。"
    },
    {
      "indent": 3,
      "text": "Each sequence consists of a tuple of (literals_length, offset_value, match_length), decoded as described in the Sequences_Section (Section 3.1.1.3.2). To execute a sequence, first copy literals_length bytes from the decoded literals to the output.",
      "ja": "各シーケンスは、（literals_length、offset_value、match_length）のタプルで構成され、Sequences_Section（セクション3.1.1.3.2）で説明されているようにデコードされます。 シーケンスを実行するには、最初にliterals_lengthバイトをデコードされたリテラルから出力にコピーします。"
    },
    {
      "indent": 3,
      "text": "Then, match_length bytes are copied from previous decoded data. The offset to copy from is determined by offset_value:",
      "ja": "次に、match_lengthバイトが以前のデコードされたデータからコピーされます。 コピー元のオフセットは、offset_valueによって決定されます。"
    },
    {
      "indent": 3,
      "text": "o if Offset_Value > 3, then the offset is Offset_Value - 3;",
      "ja": "o Offset_Value> 3の場合、オフセットはOffset_Value-3です。"
    },
    {
      "indent": 3,
      "text": "o if Offset_Value is from 1-3, the offset is a special repeat offset value. See Section 3.1.1.5 for how the offset is determined in this case.",
      "ja": "o Offset_Valueが1〜3の場合、オフセットは特別な繰り返しオフセット値です。 この場合のオフセットの決定方法については、セクション3.1.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The offset is defined as from the current position (after copying the literals), so an offset of 6 and a match length of 3 means that 3 bytes should be copied from 6 bytes back. Note that all offsets leading to previously decoded data must be smaller than Window_Size defined in Frame_Header_Descriptor (Section 3.1.1.1.1).",
      "ja": "オフセットは現在の位置から（リテラルをコピーした後）として定義されるため、オフセット6と一致長3は、6バイトから3バイトをコピーして戻すことを意味します。 以前にデコードされたデータにつながるすべてのオフセットは、Frame_Header_Descriptor（セクション3.1.1.1.1）で定義されたWindow_Sizeよりも小さくなければならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1.5. Repeat Offsets",
      "section_title": true,
      "ja": "3.1.1.5。 オフセットを繰り返す"
    },
    {
      "indent": 3,
      "text": "As seen above, the first three values define a repeated offset; we will call them Repeated_Offset1, Repeated_Offset2, and Repeated_Offset3. They are sorted in recency order, with Repeated_Offset1 meaning \"most recent one\".",
      "ja": "上記のように、最初の3つの値は繰り返しオフセットを定義します。 Repeated_Offset1、Repeated_Offset2、Repeated_Offset3と呼びます。 これらは最新の順序でソートされ、Repeated_Offset1は「最新のもの」を意味します。"
    },
    {
      "indent": 3,
      "text": "If offset_value is 1, then the offset used is Repeated_Offset1, etc.",
      "ja": "offset_valueが1の場合、使用されるオフセットはRepeated_Offset1などです。"
    },
    {
      "indent": 3,
      "text": "There is one exception: When the current sequence's literals_length is 0, repeated offsets are shifted by 1, so an offset_value of 1 means Repeated_Offset2, an offset_value of 2 means Repeated_Offset3, and an offset_value of 3 means Repeated_Offset1 - 1_byte.",
      "ja": "例外が1つあります。現在のシーケンスのliterals_lengthが0の場合、繰り返されるオフセットは1だけシフトされます。したがって、offset_value 1はRepeated_Offset2を意味し、offset_value 2はRepeated_Offset3を意味し、offset_value 3はRepeated_Offset1-1_byteを意味します。"
    },
    {
      "indent": 3,
      "text": "For the first block, the starting offset history is populated with the following values: Repeated_Offset1 (1), Repeated_Offset2 (4), and Repeated_Offset3 (8), unless a dictionary is used, in which case they come from the dictionary.",
      "ja": "最初のブロックでは、辞書が使用されている場合を除き、開始オフセット履歴にRepeated_Offset1（1）、Repeated_Offset2（4）、およびRepeated_Offset3（8）の値が入力されます。"
    },
    {
      "indent": 3,
      "text": "Then each block gets its starting offset history from the ending values of the most recent Compressed_Block. Note that blocks that are not Compressed_Block are skipped; they do not contribute to offset history.",
      "ja": "次に、各ブロックは、最新のCompressed_Blockの終了値から開始オフセット履歴を取得します。 Compressed_Blockではないブロックはスキップされることに注意してください。 オフセット履歴には寄与しません。"
    },
    {
      "indent": 3,
      "text": "The newest offset takes the lead in offset history, shifting others back (up to its previous place if it was already present). This means that when Repeated_Offset1 (most recent) is used, history is unmodified. When Repeated_Offset2 is used, it is swapped with Repeated_Offset1. If any other offset is used, it becomes Repeated_Offset1, and the rest are shifted back by 1.",
      "ja": "最新のオフセットがオフセット履歴の先頭になり、他のオフセットを戻します（既に存在する場合は前の場所まで）。 つまり、Repeated_Offset1（最新）が使用されると、履歴は変更されません。 Repeated_Offset2を使用すると、Repeated_Offset1と交換されます。 他のオフセットを使用すると、Repeated_Offset1になり、残りは1だけシフトバックされます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Skippable Frames",
      "section_title": true,
      "ja": "3.1.2。 スキップ可能なフレーム"
    },
    {
      "indent": 5,
      "text": "+--------------+------------+-----------+\n| Magic_Number | Frame_Size | User_Data |\n+--------------+------------+-----------+\n|    4 bytes   |   4 bytes  |  n bytes  |\n+--------------+------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Skippable frames allow the insertion of user-defined metadata into a flow of concatenated frames.",
      "ja": "スキップ可能なフレームを使用すると、連結フレームのフローにユーザー定義のメタデータを挿入できます。"
    },
    {
      "indent": 3,
      "text": "Skippable frames defined in this specification are compatible with skippable frames in [LZ4].",
      "ja": "この仕様で定義されたスキップ可能なフレームは、[LZ4]のスキップ可能なフレームと互換性があります。"
    },
    {
      "indent": 3,
      "text": "From a compliant decoder perspective, skippable frames simply need to be skipped, and their content ignored, resuming decoding after the skippable frame.",
      "ja": "準拠したデコーダーの観点からは、スキップ可能なフレームをスキップする必要があり、そのコンテンツは無視され、スキップ可能なフレームの後にデコードを再開します。"
    },
    {
      "indent": 3,
      "text": "It should be noted that a skippable frame can be used to watermark a stream of concatenated frames embedding any kind of tracking information (even just a Universally Unique Identifier (UUID)). Users wary of such possibility should scan the stream of concatenated frames in an attempt to detect such frames for analysis or removal.",
      "ja": "スキップ可能なフレームを使用して、任意の種類の追跡情報（Universally Unique Identifier（UUID）だけでも）を埋め込む連結フレームのストリームに透かしを入れることができることに注意してください。 このような可能性に注意するユーザーは、分析または削除のためにフレームを検出するために、連結されたフレームのストリームをスキャンする必要があります。"
    },
    {
      "indent": 3,
      "text": "The fields are:",
      "ja": "フィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Magic_Number: 4 bytes, little-endian format. Value: 0x184D2A5?, which means any value from 0x184D2A50 to 0x184D2A5F. All 16 values are valid to identify a skippable frame. This specification does not detail any specific tagging methods for skippable frames.",
      "ja": "Magic_Number：4バイト、リトルエンディアン形式。 値：0x184D2A5 ?、これは0x184D2A50から0x184D2A5Fまでの任意の値を意味します。 16個の値はすべて、スキップ可能なフレームを識別するために有効です。 この仕様では、スキップ可能なフレームの特定のタグ付け方法について詳しく説明していません。"
    },
    {
      "indent": 3,
      "text": "Frame_Size: This is the size, in bytes, of the following User_Data (without including the magic number nor the size field itself). This field is represented using 4 bytes, little-endian format, unsigned 32 bits. This means User_Data can't be bigger than (2^32-1) bytes.",
      "ja": "Frame_Size：これは、次のUser_Dataのサイズ（バイト単位）です（マジックナンバーもサイズフィールド自体も含まれません）。 このフィールドは、4バイト、リトルエンディアン形式、符号なし32ビットを使用して表されます。 これは、User_Dataが（2 ^ 32-1）バイトを超えることはできないことを意味します。"
    },
    {
      "indent": 3,
      "text": "User_Data: This field can be anything. Data will just be skipped by the decoder.",
      "ja": "User_Data：このフィールドは何でもかまいません。 データはデコーダーによってスキップされます。"
    },
    {
      "indent": 0,
      "text": "4. Entropy Encoding",
      "section_title": true,
      "ja": "4.エントロピーエンコーディング"
    },
    {
      "indent": 3,
      "text": "Two types of entropy encoding are used by the Zstandard format: FSE and Huffman coding. Huffman is used to compress literals, while FSE is used for all other symbols (Literals_Length_Code, Match_Length_Code, and offset codes) and to compress Huffman headers.",
      "ja": "Zstandard形式では、FSEとハフマンコーディングの2種類のエントロピーエンコーディングが使用されます。 Huffmanはリテラルの圧縮に使用され、FSEは他のすべてのシンボル（Literals_Length_Code、Match_Length_Code、およびオフセットコード）に使用され、Huffmanヘッダーを圧縮します。"
    },
    {
      "indent": 0,
      "text": "4.1. FSE",
      "section_title": true,
      "ja": "4.1。 FSE"
    },
    {
      "indent": 3,
      "text": "FSE, short for Finite State Entropy, is an entropy codec based on [ANS]. FSE encoding/decoding involves a state that is carried over between symbols, so decoding must be done in the opposite direction as encoding. Therefore, all FSE bitstreams are read from end to beginning. Note that the order of the bits in the stream is not reversed; they are simply read in the reverse order from which they were written.",
      "ja": "FSEは、有限状態エントロピーの略で、[ANS]に基づくエントロピーコーデックです。 FSEエンコード/デコードには、シンボル間で引き継がれる状態が含まれるため、デコードはエンコードとは逆の方向で実行する必要があります。 したがって、すべてのFSEビットストリームは最初から最後まで読み取られます。 ストリーム内のビットの順序は逆にならないことに注意してください。 それらは、書き込まれた順序とは逆の順序で単に読み取られます。"
    },
    {
      "indent": 3,
      "text": "For additional details on FSE, see Finite State Entropy [FSE].",
      "ja": "FSEの詳細については、有限状態エントロピー[FSE]を参照してください。"
    },
    {
      "indent": 3,
      "text": "FSE decoding involves a decoding table that has a power of 2 size and contains three elements: Symbol, Num_Bits, and Baseline. The base 2 logarithm of the table size is its Accuracy_Log. An FSE state value represents an index in this table.",
      "ja": "FSEデコードには、サイズが2のべき乗で、Symbol、Num_Bits、Baselineの3つの要素を含むデコードテーブルが含まれます。 テーブルサイズの2を底とする対数は、Accuracy_Logです。 FSE状態値は、このテーブルのインデックスを表します。"
    },
    {
      "indent": 3,
      "text": "To obtain the initial state value, consume Accuracy_Log bits from the stream as a little-endian value. The next symbol in the stream is the Symbol indicated in the table for that state. To obtain the next state value, the decoder should consume Num_Bits bits from the stream as a little-endian value and add it to Baseline.",
      "ja": "初期状態値を取得するには、リトルエンディアン値としてストリームからAccuracy_Logビットを消費します。 ストリーム内の次のシンボルは、その状態の表に示されているシンボルです。 次の状態値を取得するには、デコーダーはストリームからのNum_Bitsビットをリトルエンディアン値として消費し、ベースラインに追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. FSE Table Description",
      "section_title": true,
      "ja": "4.1.1。 FSEテーブルの説明"
    },
    {
      "indent": 3,
      "text": "To decode FSE streams, it is necessary to construct the decoding table. The Zstandard format encodes FSE table descriptions as described here.",
      "ja": "FSEストリームをデコードするには、デコードテーブルを作成する必要があります。 Zstandard形式は、ここで説明するようにFSEテーブルの説明をエンコードします。"
    },
    {
      "indent": 3,
      "text": "An FSE distribution table describes the probabilities of all symbols from 0 to the last present one (included) on a normalized scale of (1 << Accuracy_Log). Note that there must be two or more symbols with non-zero probability.",
      "ja": "FSE分布表は、0から最後の現在のシンボル（含まれる）までのすべてのシンボルの確率を、（1 << Accuracy_Log）の正規化されたスケールで記述します。 ゼロ以外の確率のシンボルが2つ以上必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A bitstream is read forward, in little-endian fashion. It is not necessary to know its exact size, since the size will be discovered and reported by the decoding process. The bitstream starts by reporting on which scale it operates. If low4bits designates the lowest 4 bits of the first byte, then Accuracy_Log = low4bits + 5.",
      "ja": "ビットストリームは、リトルエンディアン形式で前方に読み込まれます。 サイズはデコードプロセスで検出および報告されるため、正確なサイズを知る必要はありません。 ビットストリームは、動作するスケールをレポートすることから始まります。 low4bitsが最初のバイトの最下位4ビットを指定する場合、Accuracy_Log = low4bits + 5。"
    },
    {
      "indent": 3,
      "text": "This is followed by each symbol value, from 0 to the last present one. The number of bits used by each field is variable and depends on:",
      "ja": "これには、0から最後に存在する各シンボル値が続きます。 各フィールドで使用されるビット数は可変であり、以下に依存します。"
    },
    {
      "indent": 3,
      "text": "Remaining probabilities + 1: For example, presuming an Accuracy_Log of 8, and presuming 100 probabilities points have already been distributed, the decoder may read any value from 0 to (256 - 100 + 1) == 157, inclusive. Therefore, it must read log2sup(157) == 8 bits.",
      "ja": "残りの確率+ 1：たとえば、Accuracy_Logが8で、100個の確率ポイントが既に分布していると仮定すると、デコーダーは0から（256-100 + 1）== 157までの値を読み取ります。 したがって、log2sup（157）== 8ビットを読み取る必要があります。"
    },
    {
      "indent": 3,
      "text": "Value decoded: Small values use 1 fewer bit. For example, presuming values from 0 to 157 (inclusive) are possible, 255 - 157 = 98 values are remaining in an 8-bit field. The first 98 values (hence from 0 to 97) use only 7 bits, and values from 98 to 157 use 8 bits. This is achieved through this scheme:",
      "ja": "デコードされた値：値が小さいほど、使用するビットが1つ少なくなります。 たとえば、0〜157（両端を含む）の値が想定され、255-157 = 98の値が8ビットフィールドに残ります。 最初の98個の値（0〜97）は7ビットのみを使用し、98〜157の値は8ビットを使用します。 これは、次のスキームにより実現されます。"
    },
    {
      "indent": 5,
      "text": "+------------+---------------+-----------+\n| Value Read | Value Decoded | Bits Used |\n+------------+---------------+-----------+\n|   0 - 97   |     0 - 97    |     7     |\n+------------+---------------+-----------+\n|  98 - 127  |    98 - 127   |     8     |\n+------------+---------------+-----------+\n| 128 - 225  |     0 - 97    |     7     |\n+------------+---------------+-----------+\n| 226 - 255  |   128 - 157   |     8     |\n+------------+---------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Symbol probabilities are read one by one, in order. The probability is obtained from Value decoded using the formula P = Value - 1. This means the value 0 becomes the negative probability -1. This is a special probability that means \"less than 1\". Its effect on the distribution table is described below. For the purpose of calculating total allocated probability points, it counts as 1.",
      "ja": "シンボル確率は順番に1つずつ読み取られます。 確率は、式P =値-1を使用してデコードされた値から取得されます。これは、値0が負の確率-1になることを意味します。 これは、「1未満」を意味する特別な確率です。 分布表への影響を以下に説明します。 割り当てられた確率ポイントの合計を計算するために、1としてカウントされます。"
    },
    {
      "indent": 3,
      "text": "When a symbol has a probability of zero, it is followed by a 2-bit repeat flag. This repeat flag tells how many probabilities of zeroes follow the current one. It provides a number ranging from 0 to 3. If it is a 3, another 2-bit repeat flag follows, and so on.",
      "ja": "シンボルの確率がゼロの場合、2ビットの繰り返しフラグが続きます。 この繰り返しフラグは、現在のゼロに続くゼロの確率を示します。 0〜3の範囲の数値を提供します。3の場合、2ビットの繰り返しフラグが続きます。"
    },
    {
      "indent": 3,
      "text": "When the last symbol reaches a cumulated total of (1 << Accuracy_Log), decoding is complete. If the last symbol makes the cumulated total go above (1 << Accuracy_Log), distribution is considered corrupted.",
      "ja": "最後のシンボルが累積合計（1 << Accuracy_Log）に達すると、デコードが完了します。 最後のシンボルが累積合計を上回った場合（1 << Accuracy_Log）、分布は破損していると見なされます。"
    },
    {
      "indent": 3,
      "text": "Finally, the decoder can tell how many bytes were used in this process and how many symbols are present. The bitstream consumes a round number of bytes. Any remaining bit within the last byte is simply unused.",
      "ja": "最後に、デコーダーはこのプロセスで使用されたバイト数と存在するシンボルの数を知ることができます。 ビットストリームは、ラウンドバイト数を消費します。 最後のバイト内の残りのビットは、単に使用されません。"
    },
    {
      "indent": 3,
      "text": "The distribution of normalized probabilities is enough to create a unique decoding table. The table has a size of (1 << Accuracy_Log). Each cell describes the symbol decoded and instructions to get the next state.",
      "ja": "正規化された確率の分布は、一意のデコードテーブルを作成するのに十分です。 テーブルのサイズは（1 << Accuracy_Log）です。 各セルは、デコードされたシンボルと次の状態を取得するための命令を記述します。"
    },
    {
      "indent": 3,
      "text": "Symbols are scanned in their natural order for \"less than 1\" probabilities as described above. Symbols with this probability are being attributed a single cell, starting from the end of the table and retreating. These symbols define a full state reset, reading Accuracy_Log bits.",
      "ja": "前述のように、シンボルは「1未満」の確率で自然な順序でスキャンされます。 この確率のシンボルは、テーブルの終わりから始まり、後退する単一のセルに起因しています。 これらのシンボルは完全な状態のリセットを定義し、Accuracy_Logビットを読み取ります。"
    },
    {
      "indent": 3,
      "text": "All remaining symbols are allocated in their natural order. Starting from symbol 0 and table position 0, each symbol gets allocated as many cells as its probability. Cell allocation is spread, not linear; each successor position follows this rule:",
      "ja": "残りのすべてのシンボルは、自然な順序で割り当てられます。 シンボル0とテーブル位置0から開始して、各シンボルにはその確率と同じ数のセルが割り当てられます。 セルの割り当ては線形ではなく広がります。 各後続職はこのルールに従います。"
    },
    {
      "indent": 5,
      "text": "position += (tableSize >> 1) + (tableSize >> 3) + 3;\nposition &= tableSize - 1;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A position is skipped if it is already occupied by a \"less than 1\" probability symbol. Position does not reset between symbols; it simply iterates through each position in the table, switching to the next symbol when enough states have been allocated to the current one.",
      "ja": "ポジションがすでに「1未満」の確率シンボルで占められている場合、そのポジションはスキップされます。 シンボル間の位置はリセットされません。 テーブル内の各位置を単純に反復し、現在の状態に十分な状態が割り当てられたら次のシンボルに切り替えます。"
    },
    {
      "indent": 3,
      "text": "The result is a list of state values. Each state will decode the current symbol.",
      "ja": "結果は、状態値のリストです。 各状態は現在のシンボルをデコードします。"
    },
    {
      "indent": 3,
      "text": "To get the Number_of_Bits and Baseline required for the next state, it is first necessary to sort all states in their natural order. The lower states will need 1 more bit than higher ones. The process is repeated for each symbol.",
      "ja": "次の状態に必要なNumber_of_BitsとBaselineを取得するには、最初にすべての状態を自然な順序で並べ替える必要があります。 低い状態には、高い状態よりも1ビット多く必要です。 このプロセスは、シンボルごとに繰り返されます。"
    },
    {
      "indent": 3,
      "text": "For example, presuming a symbol has a probability of 5, it receives five state values. States are sorted in natural order. The next power of 2 is 8. The space of probabilities is divided into 8 equal parts. Presuming the Accuracy_Log is 7, this defines 128 states, and each share (divided by 8) is 16 in size. In order to reach 8, 8 - 5 = 3 lowest states will count \"double\", doubling the number of shares (32 in width), requiring 1 more bit in the process.",
      "ja": "たとえば、シンボルの確率が5であると仮定すると、シンボルは5つの状態値を受け取ります。 状態は自然な順序でソートされます。 次の2のべき乗は8です。確率の空間は8つの等しい部分に分割されます。 Accuracy_Logが7であると仮定すると、これは128の状態を定義し、各共有（8で割られる）のサイズは16です。 8、8-5 = 3の最低状態に到達するには、「double」をカウントし、共有数（幅32）を2倍にします。プロセスでさらに1ビット必要です。"
    },
    {
      "indent": 3,
      "text": "Baseline is assigned starting from the higher states using fewer bits, and proceeding naturally, then resuming at the first state, each taking its allocated width from Baseline.",
      "ja": "ベースラインは、より少ないビットを使用して上位の状態から割り当てられ、自然に進んでから最初の状態で再開され、それぞれが割り当てられた幅をベースラインから取得します。"
    },
    {
      "indent": 5,
      "text": "+----------------+-------+-------+--------+------+-------+\n|   state order  |   0   |   1   |   2    |  3   |  4    |\n+----------------+-------+-------+--------+------+-------+\n|     width      |   32  |   32  |   32   |  16  |  16   |\n+----------------+-------+-------+--------+------+-------+\n| Number_of_Bits |   5   |   5   |   5    |  4   |  4    |\n+----------------+-------+-------+--------+------+-------+\n|  range number  |   2   |   4   |   6    |  0   |  1    |\n+----------------+-------+-------+--------+------+-------+\n|    Baseline    |   32  |   64  |   96   |  0   |  16   |\n+----------------+-------+-------+--------+------+-------+\n|     range      | 32-63 | 64-95 | 96-127 | 0-15 | 16-31 |\n+----------------+-------+-------+--------+------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The next state is determined from the current state by reading the required Number_of_Bits and adding the specified Baseline.",
      "ja": "次の状態は、必要なNumber_of_Bitsを読み取り、指定されたベースラインを追加することにより、現在の状態から決定されます。"
    },
    {
      "indent": 3,
      "text": "See Appendix A for the results of this process that are applied to the default distributions.",
      "ja": "デフォルトの配布に適用されるこのプロセスの結果については、付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Huffman Coding",
      "section_title": true,
      "ja": "4.2。 ハフマンコーディング"
    },
    {
      "indent": 3,
      "text": "Zstandard Huffman-coded streams are read backwards, similar to the FSE bitstreams. Therefore, to find the start of the bitstream, it is necessary to know the offset of the last byte of the Huffman-coded stream.",
      "ja": "Zstandard Huffman符号化ストリームは、FSEビットストリームと同様に逆方向に読み取られます。 したがって、ビットストリームの先頭を見つけるには、ハフマン符号化ストリームの最後のバイトのオフセットを知る必要があります。"
    },
    {
      "indent": 3,
      "text": "After writing the last bit containing information, the compressor writes a single 1 bit and then fills the byte with 0-7 0 bits of padding. The last byte of the compressed bitstream cannot be 0 for that reason.",
      "ja": "情報を含む最後のビットを書き込んだ後、コンプレッサーは単一の1ビットを書き込み、0〜7 0ビットのパディングでバイトを埋めます。 そのため、圧縮ビットストリームの最後のバイトを0にすることはできません。"
    },
    {
      "indent": 3,
      "text": "When decompressing, the last byte containing the padding is the first byte to read. The decompressor needs to skip 0-7 initial 0 bits and the first 1 bit that occurs. Afterwards, the useful part of the bitstream begins.",
      "ja": "圧縮解除するとき、パディングを含む最後のバイトは、読み取る最初のバイトです。 デコンプレッサは、0〜7の初期0ビットと最初の1ビットをスキップする必要があります。 その後、ビットストリームの有用な部分が始まります。"
    },
    {
      "indent": 3,
      "text": "The bitstream contains Huffman-coded symbols in little-endian order, with the codes defined by the method below.",
      "ja": "ビットストリームには、ハフマン符号化されたシンボルがリトルエンディアン順に含まれており、コードは以下の方法で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Huffman Tree Description",
      "section_title": true,
      "ja": "4.2.1。 ハフマンツリーの説明"
    },
    {
      "indent": 3,
      "text": "Prefix coding represents symbols from an a priori known alphabet by bit sequences (codewords), one codeword for each symbol, in a manner such that different symbols may be represented by bit sequences of different lengths, but a parser can always parse an encoded string unambiguously symbol by symbol.",
      "ja": "プレフィックスコーディングは、さまざまなシンボルがさまざまな長さのビットシーケンスで表されるように、ビットシーケンス（コードワード）によってアプリオリに既知のアルファベットからのシンボルを表します。ただし、パーサーは常にエンコードされた文字列を明確に解析できます。 シンボルごとに。"
    },
    {
      "indent": 3,
      "text": "Given an alphabet with known symbol frequencies, the Huffman algorithm allows the construction of an optimal prefix code using the fewest bits of any possible prefix codes for that alphabet.",
      "ja": "既知のシンボル周波数を持つアルファベットを考えると、ハフマンアルゴリズムは、そのアルファベットの可能なプレフィックスコードの最小ビットを使用して、最適なプレフィックスコードの構築を可能にします。"
    },
    {
      "indent": 3,
      "text": "The prefix code must not exceed a maximum code length. More bits improve accuracy but yield a larger header size and require more memory or more complex decoding operations. This specification limits the maximum code length to 11 bits.",
      "ja": "プレフィックスコードは、最大コード長を超えてはなりません。 ビット数を増やすと精度が向上しますが、ヘッダーサイズが大きくなり、より多くのメモリまたはより複雑なデコード操作が必要になります。 この仕様では、最大コード長を11ビットに制限しています。"
    },
    {
      "indent": 3,
      "text": "All literal values from zero (included) to the last present one (excluded) are represented by Weight with values from 0 to Max_Number_of_Bits. Transformation from Weight to Number_of_Bits follows this pseudocode:",
      "ja": "ゼロ（含まれる）から最後に存在する（除外される）までのすべてのリテラル値は、0からMax_Number_of_Bitsの値を持つWeightで表されます。 WeightからNumber_of_Bitsへの変換は、この擬似コードに従います。"
    },
    {
      "indent": 5,
      "text": "if Weight == 0 Number_of_Bits = 0 else Number_of_Bits = Max_Number_of_Bits + 1 - Weight",
      "ja": "if Weight == 0 Number_of_Bits = 0 else Number_of_Bits = Max_Number_of_Bits + 1-重み"
    },
    {
      "indent": 3,
      "text": "The last symbol's Weight is deduced from previously decoded ones, by completing to the nearest power of 2. This power of 2 gives Max_Number_of_Bits the depth of the current tree.",
      "ja": "最後のシンボルの重みは、最も近い2の累乗まで完了することにより、以前にデコードされたものから推定されます。この2の累乗は、Max_Number_of_Bitsに現在のツリーの深さを与えます。"
    },
    {
      "indent": 3,
      "text": "For example, presume the following Huffman tree must be described:",
      "ja": "たとえば、次のハフマンツリーを記述する必要があると仮定します。"
    },
    {
      "indent": 5,
      "text": "+---------------+----------------+\n| Literal Value | Number_of_Bits |\n+---------------+----------------+\n|       0       |        1       |\n+---------------+----------------+\n|       1       |        2       |\n+---------------+----------------+\n|       2       |        3       |\n+---------------+----------------+\n|       3       |        0       |\n+---------------+----------------+\n|       4       |        4       |\n+---------------+----------------+\n|       5       |        4       |\n+---------------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The tree depth is 4, since its longest element uses 4 bits. (The longest elements are those with the smallest frequencies.) Value 5 will not be listed as it can be determined from the values for 0-4, nor will values above 5 as they are all 0. Values from 0 to 4 will be listed using Weight instead of Number_of_Bits. The pseudocode to determine Weight is:",
      "ja": "最も長い要素が4ビットを使用するため、ツリーの深さは4です。 （最も長い要素は、頻度が最も小さい要素です。）値5は、0〜4の値から決定できるためリストされません。また、5を超える値はすべて0であるため、リストされません。 Number_of_Bitsの代わりにWeightを使用します。 重みを決定するための擬似コードは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "if Number_of_Bits == 0 Weight = 0 else Weight = Max_Number_of_Bits + 1 - Number_of_Bits",
      "ja": "if Number_of_Bits == 0 Weight = 0 else Weight = Max_Number_of_Bits + 1-Number_of_Bits"
    },
    {
      "indent": 3,
      "text": "It gives the following series of weights:",
      "ja": "次の一連の重みを提供します。"
    },
    {
      "indent": 5,
      "text": "+---------------+--------+\n| Literal Value | Weight |\n+---------------+--------+\n|       0       |   4    |\n+---------------+--------+\n|       1       |   3    |\n+---------------+--------+\n|       2       |   2    |\n+---------------+--------+\n|       3       |   0    |\n+---------------+--------+\n|       4       |   1    |\n+---------------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The decoder will do the inverse operation: having collected weights of literals from 0 to 4, it knows the last literal, 5, is present with a non-zero Weight. The Weight of 5 can be determined by advancing to the next power of 2. The sum of 2^(Weight-1) (excluding 0's) is 15. The nearest power of 2 is 16. Therefore, Max_Number_of_Bits = 4 and Weight[5] = 16 - 15 = 1.",
      "ja": "デコーダーは逆の操作を行います。0から4までのリテラルの重みを収集すると、最後のリテラル5がゼロ以外の重みで存在することを認識します。 5の重みは、次の2の累乗に進むことで決定できます。2^（Weight-1）（0を除く）の合計は15です。2の最も近い累乗は16です。したがって、Max_Number_of_Bits = 4およびWeight [5 ] = 16-15 = 1。"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Huffman Tree Header",
      "section_title": true,
      "ja": "4.2.1.1。 ハフマンツリーヘッダー"
    },
    {
      "indent": 3,
      "text": "This is a single byte value (0-255), which describes how the series of weights is encoded.",
      "ja": "これは単一バイト値（0〜255）であり、一連の重みのエンコード方法を示します。"
    },
    {
      "indent": 3,
      "text": "headerByte < 128: The series of weights is compressed using FSE (see below). The length of the FSE-compressed series is equal to headerByte (0-127).",
      "ja": "headerByte <128：一連の重みはFSEを使用して圧縮されます（以下を参照）。 FSEで圧縮されたシリーズの長さは、headerByte（0-127）に等しくなります。"
    },
    {
      "indent": 3,
      "text": "headerByte >= 128: This is a direct representation, where each Weight is written directly as a 4-bit field (0-15). They are encoded forward, 2 weights to a byte with the first weight taking the top 4 bits and the second taking the bottom 4; for example, the following operations could be used to read the weights:",
      "ja": "headerByte> = 128：これは直接の表現で、各Weightは4ビットフィールド（0〜15）として直接書き込まれます。 これらは前方にエンコードされ、2つの重みが1バイトになり、最初の重みが上位4ビットを、2番目の重みが下位4ビットを使用します。 たとえば、次の操作を使用して重みを読み取ることができます。"
    },
    {
      "indent": 5,
      "text": "Weight[0] = (Byte[0] >> 4) Weight[1] = (Byte[0] & 0xf), etc.",
      "ja": "Weight [0] =（Byte [0] >> 4）Weight [1] =（Byte [0]＆0xf）など"
    },
    {
      "indent": 6,
      "text": "The full representation occupies ceiling(Number_of_Symbols/2) bytes, meaning it uses only full bytes even if Number_of_Symbols is odd. Number_of_Symbols = headerByte - 127. Note that maximum Number_of_Symbols is 255 - 127 = 128. If any literal has a value over 128, raw header mode is not possible, and it is necessary to use FSE compression.",
      "ja": "完全な表現はceiling（Number_of_Symbols / 2）バイトを占有します。つまり、Number_of_Symbolsが奇数であっても完全なバイトのみを使用します。 Number_of_Symbols = headerByte-127。Number_of_Symbolsの最大値は255-127 = 128であることに注意してください。リテラルの値が128を超える場合、生のヘッダーモードは使用できず、FSE圧縮を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1.2. FSE Compression of Huffman Weights",
      "section_title": true,
      "ja": "4.2.1.2。 ハフマン重みのFSE圧縮"
    },
    {
      "indent": 3,
      "text": "In this case, the series of Huffman weights is compressed using FSE compression. It is a single bitstream with two interleaved states, sharing a single distribution table.",
      "ja": "この場合、一連のハフマン重みはFSE圧縮を使用して圧縮されます。 これは、2つのインターリーブされた状態を持つ単一のビットストリームであり、単一の配布テーブルを共有します。"
    },
    {
      "indent": 3,
      "text": "To decode an FSE bitstream, it is necessary to know its compressed size. Compressed size is provided by headerByte. It's also necessary to know its maximum possible decompressed size, which is 255, since literal values span from 0 to 255, and the last symbol's Weight is not represented.",
      "ja": "FSEビットストリームをデコードするには、その圧縮サイズを知る必要があります。 圧縮サイズはheaderByteによって提供されます。 また、リテラル値の範囲は0〜255であり、最後のシンボルのWeightは表されないため、可能な最大の解凍サイズ255を知る必要があります。"
    },
    {
      "indent": 3,
      "text": "An FSE bitstream starts by a header, describing probabilities distribution. It will create a decoding table. For a list of Huffman weights, the maximum accuracy log is 6 bits. For more details, see Section 4.1.1.",
      "ja": "FSEビットストリームは、確率分布を記述するヘッダーから始まります。 デコードテーブルを作成します。 ハフマンの重みのリストの場合、最大精度ログは6ビットです。 詳細については、セクション4.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Huffman header compression uses two states, which share the same FSE distribution table. The first state (State1) encodes the even-numbered index symbols, and the second (State2) encodes the odd-numbered index symbols. State1 is initialized first, and then State2, and they take turns decoding a single symbol and updating their state. For more details on these FSE operations, see Section 4.1.",
      "ja": "ハフマンヘッダー圧縮では、同じFSE配布テーブルを共有する2つの状態を使用します。 最初の状態（State1）は偶数のインデックスシンボルをエンコードし、2番目（State2）は奇数のインデックスシンボルをエンコードします。 State1が最初に初期化され、次にState2が初期化され、単一のシンボルをデコードして状態を更新します。 これらのFSE操作の詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The number of symbols to be decoded is determined by tracking the bitStream overflow condition: If updating state after decoding a symbol would require more bits than remain in the stream, it is assumed that extra bits are zero. Then, symbols for each of the final states are decoded and the process is complete.",
      "ja": "デコードされるシンボルの数は、bitStreamオーバーフロー条件を追跡することで決定されます。シンボルのデコード後に状態を更新する場合、ストリームに残っているよりも多くのビットが必要な場合、余分なビットはゼロと見なされます。 次に、各最終状態のシンボルがデコードされ、プロセスが完了します。"
    },
    {
      "indent": 0,
      "text": "4.2.1.3. Conversion from Weights to Huffman Prefix Codes",
      "section_title": true,
      "ja": "4.2.1.3。 重みからハフマンプレフィックスコードへの変換"
    },
    {
      "indent": 3,
      "text": "All present symbols will now have a Weight value. It is possible to transform weights into Number_of_Bits, using this formula:",
      "ja": "現在のすべてのシンボルにWeight値があります。 次の式を使用して、重みをNumber_of_Bitsに変換することができます。"
    },
    {
      "indent": 5,
      "text": "if Weight > 0 Number_of_Bits = Max_Number_of_Bits + 1 - Weight else Number_of_Bits = 0",
      "ja": "重み> 0の場合Number_of_Bits = Max_Number_of_Bits + 1-重みelse Number_of_Bits = 0"
    },
    {
      "indent": 3,
      "text": "Symbols are sorted by Weight. Within the same Weight, symbols keep natural sequential order. Symbols with a Weight of zero are removed. Then, starting from the lowest Weight, prefix codes are distributed in sequential order.",
      "ja": "シンボルは重みでソートされます。 同じウェイト内で、シンボルは自然な順番を維持します。 重みがゼロのシンボルは削除されます。 次に、最小の重みから始めて、プレフィックスコードが順番に配信されます。"
    },
    {
      "indent": 3,
      "text": "For example, assume the following list of weights has been decoded:",
      "ja": "たとえば、次の重みのリストがデコードされたと仮定します。"
    },
    {
      "indent": 5,
      "text": "+---------+--------+\n| Literal | Weight |\n+---------+--------+\n|    0    |   4    |\n+---------+--------+\n|    1    |   3    |\n+---------+--------+\n|    2    |   2    |\n+---------+--------+\n|    3    |   0    |\n+---------+--------+\n|    4    |   1    |\n+---------+--------+\n|    5    |   1    |\n+---------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Sorting by weight and then the natural sequential order yields the following distribution:",
      "ja": "重みでソートしてから自然な順序でソートすると、次の分布が得られます。"
    },
    {
      "indent": 5,
      "text": "+---------+--------+----------------+--------------+\n| Literal | Weight | Number_Of_Bits | Prefix Codes |\n+---------+--------+----------------|--------------+\n|    3    |   0    |        0       |      N/A     |\n+---------+--------+----------------|--------------+\n|    4    |   1    |        4       |     0000     |\n+---------+--------+----------------|--------------+\n|    5    |   1    |        4       |     0001     |\n+---------+--------+----------------|--------------+\n|    2    |   2    |        3       |      001     |\n+---------+--------+----------------|--------------+\n|    1    |   3    |        2       |       01     |\n+---------+--------+----------------|--------------+\n|    0    |   4    |        1       |        1     |\n+---------+--------+----------------|--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.2. Huffman-Coded Streams",
      "section_title": true,
      "ja": "4.2.2。 ハフマン符号化ストリーム"
    },
    {
      "indent": 3,
      "text": "Given a Huffman decoding table, it is possible to decode a Huffman-coded stream.",
      "ja": "ハフマンデコードテーブルがあれば、ハフマンコーディングされたストリームをデコードできます。"
    },
    {
      "indent": 3,
      "text": "Each bitstream must be read backward, which starts from the end and goes up to the beginning. Therefore, it is necessary to know the size of each bitstream.",
      "ja": "各ビットストリームは逆方向に読み取る必要があり、最後から始まり、最初まで続きます。 したがって、各ビットストリームのサイズを知る必要があります。"
    },
    {
      "indent": 3,
      "text": "It is also necessary to know exactly which bit is the last. This is detected by a final bit flag: the highest bit of the last byte is a final-bit-flag. Consequently, a last byte of 0 is not possible. And the final-bit-flag itself is not part of the useful bitstream. Hence, the last byte contains between 0 and 7 useful bits.",
      "ja": "どのビットが最後であるかを正確に知ることも必要です。 これは、最終ビットフラグによって検出されます。最終バイトの最上位ビットは、最終ビットフラグです。 したがって、最後のバイトを0にすることはできません。 そして、final-bit-flag自体は有用なビットストリームの一部ではありません。 したがって、最後のバイトには0〜7の有用なビットが含まれます。"
    },
    {
      "indent": 3,
      "text": "Starting from the end, it is possible to read the bitstream in a little-endian fashion, keeping track of already used bits. Since the bitstream is encoded in reverse order, starting from the end, read symbols in forward order.",
      "ja": "最後から始めて、ビットストリームをリトルエンディアン形式で読み取り、既に使用されているビットを追跡することができます。 ビットストリームは最後から逆順でエンコードされるため、シンボルを順方向に読み取ります。"
    },
    {
      "indent": 3,
      "text": "For example, if the literal sequence \"0145\" was encoded using the above prefix code, it would be encoded (in reverse order) as:",
      "ja": "たとえば、リテラルシーケンス \"0145\"が上記のプレフィックスコードを使用してエンコードされた場合、次のように（逆順で）エンコードされます。"
    },
    {
      "indent": 5,
      "text": "+---------+----------+\n| Symbol  | Encoding |\n+---------+----------+\n|    5    |   0000   |\n+---------+----------+\n|    4    |   0001   |\n+---------+----------+\n|    1    |    01    |\n+---------+----------+\n|    0    |    1     |\n+---------+----------+\n| Padding |   00001  |\n+---------+----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This results in the following 2-byte bitstream:",
      "ja": "これにより、次の2バイトビットストリームが生成されます。"
    },
    {
      "indent": 5,
      "text": "00010000 00001101",
      "ja": "00010000 00001101"
    },
    {
      "indent": 3,
      "text": "Here is an alternative representation with the symbol codes separated by underscores:",
      "ja": "以下に、アンダースコアで区切られたシンボルコードを使用した代替表現を示します。"
    },
    {
      "indent": 5,
      "text": "0001_0000 00001_1_01",
      "ja": "0001_0000 00001_1_01"
    },
    {
      "indent": 3,
      "text": "Reading the highest Max_Number_of_Bits bits, it's possible to compare the extracted value to the decoding table, determining the symbol to decode and number of bits to discard.",
      "ja": "最上位のMax_Number_of_Bitsビットを読み取ると、抽出された値をデコードテーブルと比較し、デコードするシンボルと破棄するビット数を決定できます。"
    },
    {
      "indent": 3,
      "text": "The process continues reading up to the required number of symbols per stream. If a bitstream is not entirely and exactly consumed, hence reaching exactly its beginning position with all bits consumed, the decoding process is considered faulty.",
      "ja": "プロセスは、ストリームごとに必要な数のシンボルまで読み取りを続けます。 ビットストリームが完全に正確に消費されていないため、すべてのビットが消費されて正確に開始位置に達した場合、復号化プロセスに障害があると見なされます。"
    },
    {
      "indent": 0,
      "text": "5. Dictionary Format",
      "section_title": true,
      "ja": "5.辞書形式"
    },
    {
      "indent": 3,
      "text": "Zstandard is compatible with \"raw content\" dictionaries, free of any format restriction, except that they must be at least 8 bytes. These dictionaries function as if they were just the content part of a formatted dictionary.",
      "ja": "Zstandardは、「生のコンテンツ」辞書と互換性があり、フォーマットの制限はありませんが、少なくとも8バイトでなければなりません。 これらの辞書は、フォーマットされた辞書の単なるコンテンツ部分であるかのように機能します。"
    },
    {
      "indent": 3,
      "text": "However, dictionaries created by \"zstd --train\" in the reference implementation follow a specific format, described here.",
      "ja": "ただし、リファレンス実装で「zstd --train」によって作成された辞書は、ここで説明する特定の形式に従います。"
    },
    {
      "indent": 3,
      "text": "Dictionaries are not included in the compressed content but rather are provided out of band. That is, the Dictionary_ID identifies which should be used, but this specification does not describe the mechanism by which the dictionary is obtained prior to use during compression or decompression.",
      "ja": "辞書は圧縮されたコンテンツには含まれませんが、帯域外で提供されます。 つまり、Dictionary_IDはどちらを使用するかを識別しますが、この仕様では、圧縮または解凍中に使用する前に辞書を取得するメカニズムについては説明していません。"
    },
    {
      "indent": 3,
      "text": "A dictionary has a size, defined either by a buffer limit or a file size. The general format is:",
      "ja": "辞書にはサイズがあり、バッファ制限またはファイルサイズのいずれかで定義されます。 一般的な形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+--------------+---------------+----------------+---------+\n| Magic_Number | Dictionary_ID | Entropy_Tables | Content |\n+--------------+---------------+----------------+---------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Magic_Number: 4 bytes ID, value 0xEC30A437, little-endian format.",
      "ja": "Magic_Number：4バイトのID、値0xEC30A437、リトルエンディアン形式。"
    },
    {
      "indent": 3,
      "text": "Dictionary_ID: 4 bytes, stored in little-endian format. Dictionary_ID can be any value, except 0 (which means no Dictionary_ID). It is used by decoders to check if they use the correct dictionary. If the frame is going to be distributed in a private environment, any Dictionary_ID can be used. However, for public distribution of compressed frames, the following ranges are reserved and shall not be used:",
      "ja": "Dictionary_ID：4バイト。リトルエンディアン形式で保存されます。 Dictionary_IDには、0（Dictionary_IDがないことを意味する）を除く任意の値を指定できます。 デコーダーが正しい辞書を使用しているかどうかを確認するために使用されます。 フレームがプライベート環境で配布される場合、Dictionary_IDを使用できます。 ただし、圧縮フレームのパブリック配信では、次の範囲が予約されており、使用されません。"
    },
    {
      "indent": 9,
      "text": "low range: <= 32767\nhigh range: >= (2^31)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Entropy_Tables: Follow the same format as the tables in compressed blocks. See the relevant FSE and Huffman sections for how to decode these tables. They are stored in the following order: Huffman table for literals, FSE table for offsets, FSE table for match lengths, and FSE table for literals lengths. These tables populate the Repeat Stats literals mode and Repeat distribution mode for sequence decoding. It is finally followed by 3 offset values, populating repeat offsets (instead of using {1,4,8}), stored in order, 4-bytes little-endian each, for a total of 12 bytes. Each repeat offset must have a value less than the dictionary size.",
      "ja": "Entropy_Tables：圧縮ブロック内のテーブルと同じ形式に従います。 これらのテーブルをデコードする方法については、関連するFSEおよびハフマンのセクションを参照してください。 これらは、リテラルのハフマンテーブル、オフセットのFSEテーブル、一致の長さのFSEテーブル、およびリテラルの長さのFSEテーブルの順序で格納されます。 これらの表は、シーケンスデコード用の統計の繰り返しリテラルモードと分散モードの繰り返しを設定します。 最後に、3つのオフセット値が続き、（{1,4,8}を使用する代わりに）繰り返しオフセットを設定し、それぞれ4バイトのリトルエンディアンで、合計12バイトの順序で格納されます。 各繰り返しオフセットには、辞書サイズよりも小さい値が必要です。"
    },
    {
      "indent": 3,
      "text": "Content: The rest of the dictionary is its content. The content acts as a \"past\" in front of data to be compressed or decompressed, so it can be referenced in sequence commands. As long as the amount of data decoded from this frame is less than or equal to Window_Size, sequence commands may specify offsets longer than the total length of decoded output so far to reference back to the dictionary, even parts of the dictionary with offsets larger than Window_Size. After the total output has surpassed Window_Size, however, this is no longer allowed, and the dictionary is no longer accessible.",
      "ja": "内容：辞書の残りはその内容です。 コンテンツは、圧縮または圧縮解除されるデータの前の「過去」として機能するため、シーケンスコマンドで参照できます。 このフレームからデコードされたデータの量がWindow_Size以下である限り、シーケンスコマンドは、これまでにデコードされた出力の合計長より長いオフセットを指定して、辞書に戻って参照します。 Window_Size。 ただし、合計出力がWindow_Sizeを超えると、これは許可されなくなり、辞書にアクセスできなくなります。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made two registrations, as described below.",
      "ja": "以下に説明するように、IANAは2つの登録を行いました。"
    },
    {
      "indent": 0,
      "text": "6.1. The 'application/zstd' Media Type",
      "section_title": true,
      "ja": "6.1。 「application / zstd」メディアタイプ"
    },
    {
      "indent": 3,
      "text": "The 'application/zstd' media type identifies a block of data that is compressed using zstd compression. The data is a stream of bytes as described in this document. IANA has added the following to the \"Media Types\" registry:",
      "ja": "「application / zstd」メディアタイプは、zstd圧縮を使用して圧縮されたデータのブロックを識別します。 このドキュメントで説明されているように、データはバイトのストリームです。 IANAは、「メディアタイプ」レジストリに次を追加しました。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: zstd",
      "ja": "サブタイプ名：zstd"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必須パラメーター：なし"
    },
    {
      "indent": 3,
      "text": "Optional parameters: N/A",
      "ja": "オプションのパラメーター：N / A"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: binary",
      "ja": "エンコードに関する考慮事項：バイナリ"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 7 of RFC 8478",
      "ja": "セキュリティに関する考慮事項：RFC 8478のセクション7を参照"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する考慮事項：N / A"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 8478",
      "ja": "公開された仕様：RFC 8478"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: anywhere data size is an issue",
      "ja": "このメディアタイプを使用するアプリケーション：どこでもデータサイズが問題"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Magic number(s): 4 bytes, little-endian format. Value: 0xFD2FB528",
      "ja": "マジックナンバー：4バイト、リトルエンディアン形式。 値：0xFD2FB528"
    },
    {
      "indent": 6,
      "text": "File extension(s): zst",
      "ja": "ファイル拡張子：zst"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshファイルタイプコード：N / A"
    },
    {
      "indent": 3,
      "text": "For further information: See [ZSTD]",
      "ja": "詳細については、[ZSTD]を参照してください"
    },
    {
      "indent": 3,
      "text": "Intended usage: common",
      "ja": "使用目的：一般的な"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: Murray S. Kucherawy",
      "ja": "著者：マレー・S・クシェラヴィ"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "コントローラーの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Provisional registration: no",
      "ja": "仮登録：いいえ"
    },
    {
      "indent": 0,
      "text": "6.2. Content Encoding",
      "section_title": true,
      "ja": "6.2。 コンテンツエンコーディング"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entry to the \"HTTP Content Coding Registry\" within the \"Hypertext Transfer Protocol (HTTP) Parameters\" registry:",
      "ja": "IANAは、「Hypertext Transfer Protocol（HTTP）Parameters」レジストリ内の「HTTP Content Coding Registry」に次のエントリを追加しました。"
    },
    {
      "indent": 3,
      "text": "Name: zstd",
      "ja": "名前：zstd"
    },
    {
      "indent": 3,
      "text": "Description: A stream of bytes compressed using the Zstandard protocol",
      "ja": "説明：Zstandardプロトコルを使用して圧縮されたバイトのストリーム"
    },
    {
      "indent": 3,
      "text": "Pointer to specification text: RFC 8478",
      "ja": "仕様テキストへのポインター：RFC 8478"
    },
    {
      "indent": 0,
      "text": "6.3. Dictionaries",
      "section_title": true,
      "ja": "6.3。 辞書"
    },
    {
      "indent": 3,
      "text": "Work in progress includes development of dictionaries that will optimize compression and decompression of particular types of data. Specification of such dictionaries for public use will necessitate registration of a code point from the reserved range described in Section 3.1.1.1.3 and its association with a specific dictionary.",
      "ja": "進行中の作業には、特定の種類のデータの圧縮と解凍を最適化する辞書の開発が含まれます。 そのような辞書を公的に使用するために指定するには、セクション3.1.1.1.3で説明されている予約範囲からのコードポイントの登録と、特定の辞書との関連付けが必要になります。"
    },
    {
      "indent": 3,
      "text": "However, there are at present no such dictionaries published for public use, so this document makes no immediate request of IANA to create such a registry.",
      "ja": "ただし、現在のところ、公共で使用するために公開されているそのような辞書はないため、このドキュメントでは、IANAにそのようなレジストリを作成するよう直ちに要請することはありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Any data compression method involves the reduction of redundancy in the data. Zstandard is no exception, and the usual precautions apply.",
      "ja": "すべてのデータ圧縮方法には、データの冗長性の削減が含まれます。 Zstandardも例外ではなく、通常の予防措置が適用されます。"
    },
    {
      "indent": 3,
      "text": "One should never compress a message whose content must remain secret with a message generated by a third party. Such a compression can be used to guess the content of the secret message through analysis of entropy reduction. This was demonstrated in the Compression Ratio Info-leak Made Easy (CRIME) attack [CRIME], for example.",
      "ja": "第三者が生成したメッセージでコンテンツを秘密にしておく必要のあるメッセージを圧縮しないでください。 このような圧縮は、エントロピー削減の分析を通じて秘密メッセージの内容を推測するために使用できます。 これは、たとえば、圧縮率情報リークが発生しやすい（CRIME）攻撃[CRIME]で実証されました。"
    },
    {
      "indent": 3,
      "text": "A decoder has to demonstrate capabilities to detect and prevent any kind of data tampering in the compressed frame from triggering system faults, such as reading or writing beyond allowed memory ranges. This can be guaranteed by either the implementation language or careful bound checkings. Of particular note is the encoding of Number_of_Sequences values that cause the decoder to read into the block header (and beyond), as well as the indication of a Frame_Content_Size that is smaller than the actual decompressed data, in an attempt to trigger a buffer overflow. It is highly recommended to fuzz-test (i.e., provide invalid, unexpected, or random input and verify safe operation of) decoder implementations to test and harden their capability to detect bad frames and deal with them without any adverse system side effect.",
      "ja": "デコーダーは、圧縮されたフレーム内のあらゆる種類のデータの改ざんを検出し、許可されたメモリ範囲を超える読み取りや書き込みなどのシステム障害をトリガーする機能を実証する必要があります。 これは、実装言語または慎重な境界チェックによって保証されます。 特に注目すべきは、バッファーオーバーフローをトリガーするために、デコーダーがブロックヘッダー（以降）に読み込むNumber_of_Sequences値のエンコードと、実際の圧縮解除データよりも小さいFrame_Content_Sizeの表示です。 デコーダーの実装をファズテスト（つまり、無効、予期しない、またはランダムな入力を提供し、安全な動作を検証する）することを強くお勧めします。これにより、悪いフレームを検出し、システムに悪影響を与えることなく対処する機能をテストおよび強化します。"
    },
    {
      "indent": 3,
      "text": "An attacker may provide correctly formed compressed frames with unreasonable memory requirements. A decoder must always control memory requirements and enforce some (system-specific) limits in order to protect memory usage from such scenarios.",
      "ja": "攻撃者は、不当なメモリ要件で正しく形成された圧縮フレームを提供する場合があります。 このようなシナリオからメモリの使用を保護するために、デコーダは常にメモリ要件を制御し、いくつかの（システム固有の）制限を実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "Compression can be optimized by training a dictionary on a variety of related content payloads. This dictionary must then be available at the decoder for decompression of the payload to be possible. While this document does not specify how to acquire a dictionary for a given compressed payload, it is worth noting that third-party dictionaries may interact unexpectedly with a decoder, leading to possible memory or other resource exhaustion attacks. We expect such topics to be discussed in further detail in the Security Considerations section of a forthcoming RFC for dictionary acquisition and transmission, but highlight this issue now out of an abundance of caution.",
      "ja": "圧縮は、関連するさまざまなコンテンツペイロードで辞書をトレーニングすることで最適化できます。 このディクショナリは、ペイロードの圧縮解除を可能にするために、デコーダで利用できる必要があります。 このドキュメントでは、特定の圧縮ペイロードの辞書を取得する方法を指定していませんが、サードパーティの辞書がデコーダと予期せず相互作用し、メモリまたは他のリソース枯渇攻撃を引き起こす可能性があることに注意してください。 このようなトピックについては、辞書の取得と送信に関するRFCのセキュリティに関する考慮事項のセクションでさらに詳しく説明する予定ですが、十分な注意を払ってこの問題を強調しています。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.1.2, it is possible to store arbitrary user metadata in skippable frames. While such frames are ignored during decompression of the data, they can be used as a watermark to track the path of the compressed payload.",
      "ja": "セクション3.1.2で説明したように、スキップ可能なフレームに任意のユーザーメタデータを保存することができます。 このようなフレームはデータの解凍中は無視されますが、圧縮されたペイロードのパスを追跡するための透かしとして使用できます。"
    },
    {
      "indent": 0,
      "text": "8. Implementation Status",
      "section_title": true,
      "ja": "8.実装ステータス"
    },
    {
      "indent": 3,
      "text": "Source code for a C language implementation of a Zstandard-compliant library is available at [ZSTD-GITHUB]. This implementation is considered to be the reference implementation and is production ready; it implements the full range of the specification. It is routinely tested against security hazards and widely deployed within Facebook infrastructure.",
      "ja": "Zstandard準拠ライブラリのC言語実装のソースコードは、[ZSTD-GITHUB]で入手できます。 この実装は参照実装と見なされ、本番環境に対応しています。 仕様の全範囲を実装します。 セキュリティハザードに対して定期的にテストされ、Facebookインフラストラクチャ内で広く展開されています。"
    },
    {
      "indent": 3,
      "text": "The reference version is optimized for speed and is highly portable. It has been proven to run safely on multiple architectures (e.g., x86, x64, ARM, MIPS, PowerPC, IA64) featuring 32- or 64-bit addressing schemes, a little- or big-endian storage scheme, a number of different operating systems (e.g., UNIX (including Linux, BSD, OS-X, and Solaris) and Windows), and a number of compilers (e.g., gcc, clang, visual, and icc).",
      "ja": "参照バージョンは速度が最適化されており、移植性に優れています。 32ビットまたは64ビットのアドレススキーム、リトルエンディアンまたはビッグエンディアンのストレージスキーム、多数の異なる動作を特徴とする複数のアーキテクチャ（x86、x64、ARM、MIPS、PowerPC、IA64など）で安全に動作することが実証されています システム（たとえば、UNIX（Linux、BSD、OS-X、およびSolarisを含む）およびWindows）、および多数のコンパイラ（たとえば、gcc、clang、visual、icc）。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参照"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[ZSTD] \"Zstandard\", <http://www.zstd.net>.",
      "ja": "[ZSTD]「Zstandard」、<http://www.zstd.net>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。 参考資料"
    },
    {
      "indent": 3,
      "text": "[ANS] Duda, J., \"Asymmetric numeral systems: entropy coding combining speed of Huffman coding with compression rate of arithmetic coding\", January 2014, <https://arxiv.org/pdf/1311.2540>.",
      "ja": "[ANS] Duda、J.、「非対称数字システム：ハフマン符号化の速度と算術符号化の圧縮率を組み合わせたエントロピー符号化」、2014年1月、<https://arxiv.org/pdf/1311.2540>。"
    },
    {
      "indent": 3,
      "text": "[CRIME] \"CRIME\", June 2018, <https://en.wikipedia.org/w/ index.php?title=CRIME&oldid=844538656>.",
      "ja": "[CRIME]「CRIME」、2018年6月、<https://en.wikipedia.org/w/ index.php？title = CRIME＆oldid = 844538656>。"
    },
    {
      "indent": 3,
      "text": "[FSE] \"FiniteStateEntropy\", commit 6efa78a, June 2018, <https://github.com/Cyan4973/FiniteStateEntropy/>.",
      "ja": "[FSE]「FiniteStateEntropy」、コミット6efa78a、2018年6月、<https://github.com/Cyan4973/FiniteStateEntropy/>。"
    },
    {
      "indent": 3,
      "text": "[LZ4] \"LZ4 Frame Format Description\", commit d03224b, January 2018, <https://github.com/lz4/lz4/blob/master/doc/ lz4_Frame_format.md>.",
      "ja": "[LZ4] \"LZ4フレーム形式の説明\"、コミットd03224b、2018年1月、<https://github.com/lz4/lz4/blob/master/doc/ lz4_Frame_format.md>。"
    },
    {
      "indent": 3,
      "text": "[RFC1952] Deutsch, P., \"GZIP file format specification version 4.3\", RFC 1952, DOI 10.17487/RFC1952, May 1996, <https://www.rfc-editor.org/info/rfc1952>.",
      "ja": "[RFC1952] Deutsch、P。、「GZIPファイル形式仕様バージョン4.3」、RFC 1952、DOI 10.17487 / RFC1952、1996年5月、<https://www.rfc-editor.org/info/rfc1952>。"
    },
    {
      "indent": 3,
      "text": "[XXHASH] \"XXHASH Algorithm\", <http://www.xxhash.org>.",
      "ja": "[XXHASH]「XXHASHアルゴリズム」、<http://www.xxhash.org>。"
    },
    {
      "indent": 3,
      "text": "[ZSTD-GITHUB] \"zstd\", commit 8514bd8, August 2018, <https://github.com/facebook/zstd>.",
      "ja": "[ZSTD-GITHUB] \"zstd\"、コミット8514bd8、2018年8月、<https://github.com/facebook/zstd>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Decoding Tables for Predefined Codes",
      "ja": "付録A.定義済みコードのデコードテーブル"
    },
    {
      "indent": 3,
      "text": "This appendix contains FSE decoding tables for the predefined literal length, match length, and offset codes. The tables have been constructed using the algorithm as given above in Section 4.1.1. The tables here can be used as examples to crosscheck that an implementation has built its decoding tables correctly.",
      "ja": "この付録には、定義済みのリテラル長、一致長、およびオフセットコードのFSEデコードテーブルが含まれています。 テーブルは、上記のセクション4.1.1で示したアルゴリズムを使用して構築されています。 ここの表は、実装がデコード表を正しく構築したことをクロスチェックするための例として使用できます。"
    },
    {
      "indent": 0,
      "text": "A.1. Literal Length Code Table",
      "ja": "A.1。 リテラル長コード表"
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n| State | Symbol | Number_Of_Bits | Base |\n+-------+--------+----------------+------+\n|    0  |    0   |        0       |   0  |\n+-------+--------+----------------+------+\n|    0  |    0   |        4       |   0  |\n+-------+--------+----------------+------+\n|    1  |    0   |        4       |  16  |\n+-------+--------+----------------+------+\n|    2  |    1   |        5       |  32  |\n+-------+--------+----------------+------+\n|    3  |    3   |        5       |   0  |\n+-------+--------+----------------+------+\n|    4  |    4   |        5       |   0  |\n+-------+--------+----------------+------+\n|    5  |    6   |        5       |   0  |\n+-------+--------+----------------+------+\n|    6  |    7   |        5       |   0  |\n+-------+--------+----------------+------+\n|    7  |    9   |        5       |   0  |\n+-------+--------+----------------+------+\n|    8  |   10   |        5       |   0  |\n+-------+--------+----------------+------+\n|    9  |   12   |        5       |   0  |\n+-------+--------+----------------+------+\n|   10  |   14   |        6       |   0  |\n+-------+--------+----------------+------+\n|   11  |   16   |        5       |   0  |\n+-------+--------+----------------+------+\n|   12  |   18   |        5       |   0  |\n+-------+--------+----------------+------+\n|   13  |   19   |        5       |   0  |\n+-------+--------+----------------+------+\n|   14  |   21   |        5       |   0  |\n+-------+--------+----------------+------+\n|   15  |   22   |        5       |   0  |\n+-------+--------+----------------+------+\n|   16  |   24   |        5       |   0  |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n|   17  |   25   |        5       |  32  |\n+-------+--------+----------------+------+\n|   18  |   26   |        5       |   0  |\n+-------+--------+----------------+------+\n|   19  |   27   |        6       |   0  |\n+-------+--------+----------------+------+\n|   20  |   29   |        6       |   0  |\n+-------+--------+----------------+------+\n|   21  |   31   |        6       |   0  |\n+-------+--------+----------------+------+\n|   22  |    0   |        4       |  32  |\n+-------+--------+----------------+------+\n|   23  |    1   |        4       |   0  |\n+-------+--------+----------------+------+\n|   24  |    2   |        5       |   0  |\n+-------+--------+----------------+------+\n|   25  |    4   |        5       |  32  |\n+-------+--------+----------------+------+\n|   26  |    5   |        5       |   0  |\n+-------+--------+----------------+------+\n|   27  |    7   |        5       |  32  |\n+-------+--------+----------------+------+\n|   28  |    8   |        5       |   0  |\n+-------+--------+----------------+------+\n|   29  |   10   |        5       |  32  |\n+-------+--------+----------------+------+\n|   30  |   11   |        5       |   0  |\n+-------+--------+----------------+------+\n|   31  |   13   |        6       |   0  |\n+-------+--------+----------------+------+\n|   32  |   16   |        5       |  32  |\n+-------+--------+----------------+------+\n|   33  |   17   |        5       |   0  |\n+-------+--------+----------------+------+\n|   34  |   19   |        5       |  32  |\n+-------+--------+----------------+------+\n|   35  |   20   |        5       |   0  |\n+-------+--------+----------------+------+\n|   36  |   22   |        5       |  32  |\n+-------+--------+----------------+------+\n|   37  |   23   |        5       |   0  |\n+-------+--------+----------------+------+\n|   38  |   25   |        4       |   0  |\n+-------+--------+----------------+------+\n|   39  |   25   |        4       |  16  |\n+-------+--------+----------------+------+\n|   40  |   26   |        5       |  32  |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n|   41  |   28   |        6       |   0  |\n+-------+--------+----------------+------+\n|   42  |   30   |        6       |   0  |\n+-------+--------+----------------+------+\n|   43  |    0   |        4       |  48  |\n+-------+--------+----------------+------+\n|   44  |    1   |        4       |  16  |\n+-------+--------+----------------+------+\n|   45  |    2   |        5       |  32  |\n+-------+--------+----------------+------+\n|   46  |    3   |        5       |  32  |\n+-------+--------+----------------+------+\n|   47  |    5   |        5       |  32  |\n+-------+--------+----------------+------+\n|   48  |    6   |        5       |  32  |\n+-------+--------+----------------+------+\n|   49  |    8   |        5       |  32  |\n+-------+--------+----------------+------+\n|   50  |    9   |        5       |  32  |\n+-------+--------+----------------+------+\n|   51  |   11   |        5       |  32  |\n+-------+--------+----------------+------+\n|   52  |   12   |        5       |  32  |\n+-------+--------+----------------+------+\n|   53  |   15   |        6       |   0  |\n+-------+--------+----------------+------+\n|   54  |   17   |        5       |  32  |\n+-------+--------+----------------+------+\n|   55  |   18   |        5       |  32  |\n+-------+--------+----------------+------+\n|   56  |   20   |        5       |  32  |\n+-------+--------+----------------+------+\n|   57  |   21   |        5       |  32  |\n+-------+--------+----------------+------+\n|   58  |   23   |        5       |  32  |\n+-------+--------+----------------+------+\n|   59  |   24   |        5       |  32  |\n+-------+--------+----------------+------+\n|   60  |   35   |        6       |   0  |\n+-------+--------+----------------+------+\n|   61  |   34   |        6       |   0  |\n+-------+--------+----------------+------+\n|   62  |   33   |        6       |   0  |\n+-------+--------+----------------+------+\n|   63  |   32   |        6       |   0  |\n+-------+--------+----------------+------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2. Match Length Code Table",
      "ja": "A.2。 一致長コード表"
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n| State | Symbol | Number_Of_Bits | Base |\n+-------+--------+----------------+------+\n|    0  |    0   |        0       |   0  |\n+-------+--------+----------------+------+\n|    0  |    0   |        6       |   0  |\n+-------+--------+----------------+------+\n|    1  |    1   |        4       |   0  |\n+-------+--------+----------------+------+\n|    2  |    2   |        5       |  32  |\n+-------+--------+----------------+------+\n|    3  |    3   |        5       |   0  |\n+-------+--------+----------------+------+\n|    4  |    5   |        5       |   0  |\n+-------+--------+----------------+------+\n|    5  |    6   |        5       |   0  |\n+-------+--------+----------------+------+\n|    6  |    8   |        5       |   0  |\n+-------+--------+----------------+------+\n|    7  |   10   |        6       |   0  |\n+-------+--------+----------------+------+\n|    8  |   13   |        6       |   0  |\n+-------+--------+----------------+------+\n|    9  |   16   |        6       |   0  |\n+-------+--------+----------------+------+\n|   10  |   19   |        6       |   0  |\n+-------+--------+----------------+------+\n|   11  |   22   |        6       |   0  |\n+-------+--------+----------------+------+\n|   12  |   25   |        6       |   0  |\n+-------+--------+----------------+------+\n|   13  |   28   |        6       |   0  |\n+-------+--------+----------------+------+\n|   14  |   31   |        6       |   0  |\n+-------+--------+----------------+------+\n|   15  |   33   |        6       |   0  |\n+-------+--------+----------------+------+\n|   16  |   35   |        6       |   0  |\n+-------+--------+----------------+------+\n|   17  |   37   |        6       |   0  |\n+-------+--------+----------------+------+\n|   18  |   39   |        6       |   0  |\n+-------+--------+----------------+------+\n|   19  |   41   |        6       |   0  |\n+-------+--------+----------------+------+\n|   20  |   43   |        6       |   0  |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n|   21  |   45   |        6       |   0  |\n+-------+--------+----------------+------+\n|   22  |    1   |        4       |  16  |\n+-------+--------+----------------+------+\n|   23  |    2   |        4       |   0  |\n+-------+--------+----------------+------+\n|   24  |    3   |        5       |  32  |\n+-------+--------+----------------+------+\n|   25  |    4   |        5       |   0  |\n+-------+--------+----------------+------+\n|   26  |    6   |        5       |  32  |\n+-------+--------+----------------+------+\n|   27  |    7   |        5       |   0  |\n+-------+--------+----------------+------+\n|   28  |    9   |        6       |   0  |\n+-------+--------+----------------+------+\n|   29  |   12   |        6       |   0  |\n+-------+--------+----------------+------+\n|   30  |   15   |        6       |   0  |\n+-------+--------+----------------+------+\n|   31  |   18   |        6       |   0  |\n+-------+--------+----------------+------+\n|   32  |   21   |        6       |   0  |\n+-------+--------+----------------+------+\n|   33  |   24   |        6       |   0  |\n+-------+--------+----------------+------+\n|   34  |   27   |        6       |   0  |\n+-------+--------+----------------+------+\n|   35  |   30   |        6       |   0  |\n+-------+--------+----------------+------+\n|   36  |   32   |        6       |   0  |\n+-------+--------+----------------+------+\n|   37  |   34   |        6       |   0  |\n+-------+--------+----------------+------+\n|   38  |   36   |        6       |   0  |\n+-------+--------+----------------+------+\n|   39  |   38   |        6       |   0  |\n+-------+--------+----------------+------+\n|   40  |   40   |        6       |   0  |\n+-------+--------+----------------+------+\n|   41  |   42   |        6       |   0  |\n+-------+--------+----------------+------+\n|   42  |   44   |        6       |   0  |\n+-------+--------+----------------+------+\n|   43  |    1   |        4       |  32  |\n+-------+--------+----------------+------+\n|   44  |    1   |        4       |  48  |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n|   45  |    2   |        4       |  16  |\n+-------+--------+----------------+------+\n|   46  |    4   |        5       |  32  |\n+-------+--------+----------------+------+\n|   47  |    5   |        5       |  32  |\n+-------+--------+----------------+------+\n|   48  |    7   |        5       |  32  |\n+-------+--------+----------------+------+\n|   49  |    8   |        5       |  32  |\n+-------+--------+----------------+------+\n|   50  |   11   |        6       |   0  |\n+-------+--------+----------------+------+\n|   51  |   14   |        6       |   0  |\n+-------+--------+----------------+------+\n|   52  |   17   |        6       |   0  |\n+-------+--------+----------------+------+\n|   53  |   20   |        6       |   0  |\n+-------+--------+----------------+------+\n|   54  |   23   |        6       |   0  |\n+-------+--------+----------------+------+\n|   55  |   26   |        6       |   0  |\n+-------+--------+----------------+------+\n|   56  |   29   |        6       |   0  |\n+-------+--------+----------------+------+\n|   57  |   52   |        6       |   0  |\n+-------+--------+----------------+------+\n|   58  |   51   |        6       |   0  |\n+-------+--------+----------------+------+\n|   59  |   50   |        6       |   0  |\n+-------+--------+----------------+------+\n|   60  |   49   |        6       |   0  |\n+-------+--------+----------------+------+\n|   61  |   48   |        6       |   0  |\n+-------+--------+----------------+------+\n|   62  |   47   |        6       |   0  |\n+-------+--------+----------------+------+\n|   63  |   46   |        6       |   0  |\n+-------+--------+----------------+------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.3. Offset Code Table",
      "ja": "A.3。 オフセットコード表"
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n| State | Symbol | Number_Of_Bits | Base |\n+-------+--------+----------------+------+\n|    0  |    0   |        0       |   0  |\n+-------+--------+----------------+------+\n|    0  |    0   |        5       |   0  |\n+-------+--------+----------------+------+\n|    1  |    6   |        4       |   0  |\n+-------+--------+----------------+------+\n|    2  |    9   |        5       |   0  |\n+-------+--------+----------------+------+\n|    3  |   15   |        5       |   0  |\n+-------+--------+----------------+------+\n|    4  |   21   |        5       |   0  |\n+-------+--------+----------------+------+\n|    5  |    3   |        5       |   0  |\n+-------+--------+----------------+------+\n|    6  |    7   |        4       |   0  |\n+-------+--------+----------------+------+\n|    7  |   12   |        5       |   0  |\n+-------+--------+----------------+------+\n|    8  |   18   |        5       |   0  |\n+-------+--------+----------------+------+\n|    9  |   23   |        5       |   0  |\n+-------+--------+----------------+------+\n|   10  |    5   |        5       |   0  |\n+-------+--------+----------------+------+\n|   11  |    8   |        4       |   0  |\n+-------+--------+----------------+------+\n|   12  |   14   |        5       |   0  |\n+-------+--------+----------------+------+\n|   13  |   20   |        5       |   0  |\n+-------+--------+----------------+------+\n|   14  |    2   |        5       |   0  |\n+-------+--------+----------------+------+\n|   15  |    7   |        4       |  16  |\n+-------+--------+----------------+------+\n|   16  |   11   |        5       |   0  |\n+-------+--------+----------------+------+\n|   17  |   17   |        5       |   0  |\n+-------+--------+----------------+------+\n|   18  |   22   |        5       |   0  |\n+-------+--------+----------------+------+\n|   19  |    4   |        5       |   0  |\n+-------+--------+----------------+------+\n|   20  |    8   |        4       |  16  |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "+-------+--------+----------------+------+\n|   21  |   13   |        5       |   0  |\n+-------+--------+----------------+------+\n|   22  |   19   |        5       |   0  |\n+-------+--------+----------------+------+\n|   23  |    1   |        5       |   0  |\n+-------+--------+----------------+------+\n|   24  |    6   |        4       |  16  |\n+-------+--------+----------------+------+\n|   25  |   10   |        5       |   0  |\n+-------+--------+----------------+------+\n|   26  |   16   |        5       |   0  |\n+-------+--------+----------------+------+\n|   27  |   28   |        5       |   0  |\n+-------+--------+----------------+------+\n|   28  |   27   |        5       |   0  |\n+-------+--------+----------------+------+\n|   29  |   26   |        5       |   0  |\n+-------+--------+----------------+------+\n|   30  |   25   |        5       |   0  |\n+-------+--------+----------------+------+\n|   31  |   24   |        5       |   0  |\n+-------+--------+----------------+------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "zstd was developed by Yann Collet.",
      "ja": "zstdはYann Colletによって開発されました。"
    },
    {
      "indent": 3,
      "text": "Bobo Bose-Kolanu, Felix Handte, Kyle Nekritz, Nick Terrell, and David Schleimer provided helpful feedback during the development of this document.",
      "ja": "Bobo Bose-Kolanu、Felix Handte、Kyle Nekritz、Nick Terrell、David Schleimerは、このドキュメントの開発中に役立つフィードバックを提供しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yann Collet Facebook 1 Hacker Way Menlo Park, CA 94025 United States of America",
      "ja": "Yann Collet Facebook 1 Hacker Way Menlo Park、CA 94025アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: cyan@fb.com",
      "ja": "メール：cyan@fb.com"
    },
    {
      "indent": 3,
      "text": "Murray S. Kucherawy (editor) Facebook 1 Hacker Way Menlo Park, CA 94025 United States of America",
      "ja": "Murray S. Kucherawy（編集者）Facebook 1 Hacker Way Menlo Park、CA 94025アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: msk@fb.com",
      "ja": "メール：msk@fb.com"
    }
  ]
}