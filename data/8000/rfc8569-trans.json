{
  "title": {
    "text": "RFC 8569 - Content-Centric Networking (CCNx) Semantics",
    "ja": "RFC 8569 - コンテンツ中心ネットワーク（CCNx）セマンティクス"
  },
  "number": 8569,
  "created_at": "2019-10-30 07:13:10.219601+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                             M. Mosko\nRequest for Comments: 8569                                    PARC, Inc.\nCategory: Experimental                                          I. Solis\nISSN: 2070-1721                                                 LinkedIn\n                                                                 C. Wood\n                                         University of California Irvine\n                                                               July 2019",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Content-Centric Networking (CCNx) Semantics",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the core concepts of the Content-Centric Networking (CCNx) architecture and presents a network protocol based on two messages: Interests and Content Objects. It specifies the set of mandatory and optional fields within those messages and describes their behavior and interpretation. This architecture and protocol specification is independent of a specific wire encoding.",
      "ja": "この文書では、コンテンツ中心ネットワーク（CCNx）アーキテクチャの中核となる概念を説明し、二つのメッセージに基づいてネットワークプロトコル提示：興味やコンテンツオブジェクトを。これは、それらのメッセージ内の必須およびオプションのフィールドのセットを指定し、その行動と解釈を説明します。このアーキテクチャおよびプロトコル仕様は、特定のワイヤエンコーディングとは無関係です。"
    },
    {
      "indent": 3,
      "text": "The protocol also uses a control message called an Interest Return, whereby one system can return an Interest message to the previous hop due to an error condition. This indicates to the previous hop that the current system will not respond to the Interest.",
      "ja": "プロトコルは、一つのシステムがエラー状態のために以前のホップにインタレストメッセージを返すことができるインタレストリターンと呼ばれる制御メッセージを使用します。これは、現在のシステムは、インタレストに応答しません前のホップに示します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Information-Centric Networking Research Group (ICNRG). The document received wide review among ICNRG participants. Two full implementations are in active use and have informed the technical maturity of the protocol specification.",
      "ja": "この文書は、情報中心ネットワーキング研究グループ（ICNRG）の製品です。文書はICNRGの参加者の間で幅広い評価を受けました。 2つの完全な実装では、積極的に活用しているし、プロトコル仕様の技術的な成熟度を知らせてきました。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Information-Centric Networking Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットリサーチタスクフォースの情報中心ネットワーキング研究グループ（IRTF）のコンセンサスを表しています。 IRSGによって公表のために承認された文書はインターネットStandardのどんなレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8569.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8569で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2019 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n  1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .   5\n  1.3.  Protocol Overview . . . . . . . . . . . . . . . . . . . .   6\n2.  Protocol  . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n  2.1.  Message Grammar . . . . . . . . . . . . . . . . . . . . .  10\n  2.2.  Consumer Behavior . . . . . . . . . . . . . . . . . . . .  14\n  2.3.  Publisher Behavior  . . . . . . . . . . . . . . . . . . .  15\n  2.4.  Forwarder Behavior  . . . . . . . . . . . . . . . . . . .  16\n    2.4.1.  Interest HopLimit . . . . . . . . . . . . . . . . . .  16\n    2.4.2.  Interest Aggregation  . . . . . . . . . . . . . . . .  17\n    2.4.3.  Content Store Behavior  . . . . . . . . . . . . . . .  19\n    2.4.4.  Interest Pipeline . . . . . . . . . . . . . . . . . .  19\n    2.4.5.  Content Object Pipeline . . . . . . . . . . . . . . .  20\n3.  Names . . . . . . . . . . . . . . . . . . . . . . . . . . . .  21\n  3.1.  Name Examples . . . . . . . . . . . . . . . . . . . . . .  23\n  3.2.  Interest Payload ID . . . . . . . . . . . . . . . . . . .  23\n4.  Cache Control . . . . . . . . . . . . . . . . . . . . . . . .  23\n5.  Content Object Hash . . . . . . . . . . . . . . . . . . . . .  24\n6.  Link  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24\n7.  Hashes  . . . . . . . . . . . . . . . . . . . . . . . . . . .  25\n8.  Validation  . . . . . . . . . . . . . . . . . . . . . . . . .  25\n  8.1.  Validation Algorithm  . . . . . . . . . . . . . . . . . .  25\n  8.2.  Message Integrity Codes . . . . . . . . . . . . . . . . .  26\n  8.3.  Message Authentication Codes  . . . . . . . . . . . . . .  26\n  8.4.  Signature . . . . . . . . . . . . . . . . . . . . . . . .  26\n9.  Interest to Content Object Matching . . . . . . . . . . . . .  28\n10. Interest Return . . . . . . . . . . . . . . . . . . . . . . .  29\n  10.1.  Message Format . . . . . . . . . . . . . . . . . . . . .  30\n  10.2.  ReturnCode Types . . . . . . . . . . . . . . . . . . . .  31\n  10.3.  Interest Return Protocol . . . . . . . . . . . . . . . .  32\n    10.3.1.  No Route . . . . . . . . . . . . . . . . . . . . . .  32\n    10.3.2.  HopLimit Exceeded  . . . . . . . . . . . . . . . . .  33\n    10.3.3.  Interest MTU Too Large . . . . . . . . . . . . . . .  33\n    10.3.4.  No Resources . . . . . . . . . . . . . . . . . . . .  33\n    10.3.5.  Path Error . . . . . . . . . . . . . . . . . . . . .  33\n    10.3.6.  Prohibited . . . . . . . . . . . . . . . . . . . . .  33\n    10.3.7.  Congestion . . . . . . . . . . . . . . . . . . . . .  34\n    10.3.8.  Unsupported Content Object Hash Algorithm  . . . . .  34\n    10.3.9.  Malformed Interest . . . . . . . . . . . . . . . . .  34\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  34\n12. Security Considerations . . . . . . . . . . . . . . . . . . .  34\n13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  37\n  13.1.  Normative References . . . . . . . . . . . . . . . . . .  37\n  13.2.  Informative References . . . . . . . . . . . . . . . . .  37\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  40",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the principles of the CCNx architecture. It describes a network protocol that uses a hierarchical name to forward requests and to match responses to requests. It does not use endpoint addresses, such as Internet Protocol. Restrictions in a request can limit the response by the public key of the response's signer or the cryptographic hash of the response. Every CCNx forwarder along the path does the name matching and restriction checking. The CCNx protocol fits within the broader framework of Information-Centric Networking (ICN) protocols [RFC7927]. This document concerns the semantics of the protocol and is not dependent on a specific wire encoding. The CCNx Messages [RFC8609] document describes a type-length-value (TLV) wire-protocol encoding. This section introduces the main concepts of CCNx, which are further elaborated in the remainder of the document.",
      "ja": "この文書はCCNxアーキテクチャの原則を説明しています。これは、要求を転送し、要求に対する応答に一致するように階層名を使用するネットワークプロトコルを記述します。このようなインターネット・プロトコルとしてエンドポイントのアドレスを、使用していません。リクエスト内の制限事項は、応答の署名者の公開鍵または応答の暗号学的ハッシュにより応答を制限することができます。パスに沿ってすべてのCCNxフォワーダは、名前の一致および制限チェックを行います。 CCNxプロトコルは、情報中心のネットワークのより広範な枠組み（ICN）プロトコル[RFC7927]に収まります。この文書では、プロトコルの意味論に関する、特定のワイヤのエンコーディングに依存しません。 CCNxメッセージ[RFC8609]文書は、タイプ長さ値（TLV）ワイヤプロトコル符号化を記述する。このセクションでは、さらに、文書の残りの部分で詳述されているCCNxの主な概念を紹介します。"
    },
    {
      "indent": 3,
      "text": "The CCNx protocol derives from the early ICN work by Jacobson, et al. [nnc]. Jacobson's version of CCNx is known as the 0.x version (\"CCNx 0.x\"), and the present work is known as the 1.0 version (\"CCNx 1.0\"). There are two active implementations of CCNx 1.0. The most complete implementation is Community ICN (CICN) [cicn], a Linux Foundation project hosted at fd.io. Another active implementation is CCN-lite [ccn-lite], with support for Internet of Things (IoT) systems and the RIOT operating system. CCNx 0.x formed the basis of the Named Data Networking (NDN) [ndn] university project.",
      "ja": "CCNxプロトコルら、ヤコブソンによって初期ICN作業に由来します。 【NNC]。 CCNxのヤコブソンのバージョンは0.xのバージョン（「CCNxの0.xの」）として知られており、本研究は、1.0バージョン（「CCNx 1.0」）として知られています。 CCNx 1.0の二つの活性実装があります。最も完全な実装では、コミュニティICN（CICN）[cicn]、fd.io.でホストされているLinux Foundationのプロジェクトです別の有効な実装は、モノのインターネット（IOT）システムと暴動のオペレーティングシステムをサポートし、CCN-LITE [CCN-LITE]です。 CCNx 0.xでは、名前付きデータネットワーク（NDN）[NDN]大学のプロジェクトの基礎を形成しました。"
    },
    {
      "indent": 3,
      "text": "The current CCNx 1.0 specification diverges from CCNx 0.x in a few significant areas. The most pronounced behavioral difference between CCNx 0.x and CCNx 1.0 is that CCNx 1.0 has a simpler response processing behavior. In both versions, a forwarder uses a hierarchical longest prefix match of a request name against the forwarding information base (FIB) to send the request through the network to a system that can issue a response. A forwarder must then match a response's name to a request's name to determine the reverse path and deliver the response to the requester. In CCNx 0.x, the Interest name may be a hierarchical prefix of the response name, which allows a form of Layer 3 (L3) content discovery. In CCNx 1.0, a response's name must exactly equal a request's name. Content discovery is performed by a higher-layer protocol.",
      "ja": "現在CCNx 1.0仕様では、いくつかの重要な分野でCCNxの0.xであるから発散します。 CCNxの0.xであるとCCNx 1.0の間で最も顕著な行動の違いはCCNx 1.0は、シンプルな応答処理の動作を持っていることです。両方のバージョンでは、フォワーダは、応答を発行することができるシステムにネットワークを介して要求を送信する転送情報ベース（FIB）に対する要求名の階層的な最長プレフィックスマッチを使用します。フォワーダは、逆の経路を決定し、要求者への応答を提供するために、要求の名前に応答者の名前と一致する必要があります。 CCNxの0.xであるにおいて、対象名は、レイヤ3（L3）コンテンツ発見の形態を可能にする応答名の階層プレフィックスであってもよいです。 CCNx 1.0では、応答者の名前が正確に依頼者の名前を同じにする必要があります。コンテンツの発見は、上位層プロトコルによって行われます。"
    },
    {
      "indent": 3,
      "text": "The selector protocol \"CCNx Selectors\" [selectors] is an example of using a higher-layer protocol on top of the CCNx 1.0 L3 to perform content discovery. The selector protocol uses a method similar to the original CCNx 0.x techniques without requiring partial name matching of a response to a request in the forwarder.",
      "ja": "セレクタプロトコル「CCNxセレクタ」[セレクタ]コンテンツ発見を実行するCCNx 1.0 L3の上に上位層プロトコルを使用した例です。セレクタプロトコルはフォワーダに要求に対する応答の部分的な名前の一致を必要とせずに、元のCCNxの0.xの技術と同様の方法を使用します。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Information-Centric Networking Research Group (ICNRG). It is the first ICN protocol from the RG, created from the early CCNx protocol [nnc] with significant revision and input from the ICN community and RG members. This document has received critical reading by several members of the ICN community and the RG. The authors and RG chairs approve of the contents. This document is sponsored under the IRTF, is not issued by the IETF, and is not an IETF standard. This is an experimental protocol and may not be suitable for any specific application. The specification may change in the future.",
      "ja": "この文書は、情報中心ネットワーキング研究グループ（ICNRG）のコンセンサスを表しています。これは、ICNのコミュニティとRGのメンバーから大幅に改訂し、入力と早期CCNxプロトコル[NNC]から作成されたRGからの最初のICNプロトコルです。この文書では、ICNのコミュニティとRGのいくつかのメンバーによる重要な読書を受けています。著者とRGの椅子は、内容を承認します。この文書は、IETFによって発行されていないIRTFの下で後援、およびIETF標準ではありません。これは、実験プロトコルであり、任意の特定の用途には適していません。仕様は、将来的に変更されることがあります。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Architecture",
      "section_title": true,
      "ja": "1.2. 建築"
    },
    {
      "indent": 3,
      "text": "We describe the architecture of the network in which CCNx operates and introduce certain terminology from [terminology]. The detailed behavior of each component and message grammar is in Section 2.",
      "ja": "我々はCCNxが動作するネットワークのアーキテクチャを説明し、[用語]から特定の用語を紹介します。各成分およびメッセージ文法の詳細な動作は、セクション2です。"
    },
    {
      "indent": 3,
      "text": "A producer (also called a \"publisher\") is an endpoint that encapsulates content in Content Objects for transport in the CCNx network. A producer has a public/private keypair and signs (directly or indirectly) the Content Objects. Usually, the producer's KeyId (hash of the public key) is well known or may be derived from the producer's namespace via standard means.",
      "ja": "（また、「発行者」と呼ばれる）プロデューサーはCCNxネットワーク内の輸送のためのコンテンツオブジェクトのコンテンツをカプセル化するエンドポイントです。プロデューサーには、公開鍵/秘密鍵ペアおよび徴候（直接的または間接的に）コンテンツオブジェクトを持っています。通常、生産者KEYID（公開鍵のハッシュ）がよく知られているか、標準的な手段を経由して、プロデューサの名前空間に由来することができます。"
    },
    {
      "indent": 3,
      "text": "A producer operates within one or more namespaces. A namespace is a name prefix that is represented in the forwarding information base (FIB). This allows a request to reach the producer and fetch a response (if one exists).",
      "ja": "プロデューサーは、一の以上の名前空間内で動作します。名前空間は、転送情報ベース（FIB）で表される名前の接頭辞です。これは、（存在する場合）の生産に到達し、応答を取得するための要求を可能にします。"
    },
    {
      "indent": 3,
      "text": "The FIB is a table that tells a forwarder where to send a request. It may point to a local application, a local cache or Content Store, or to a remote system. If there is no matching entry in the FIB, a forwarder cannot process a request. The detailed rules on name matching to the FIB are given in Section 2.4.4. An endpoint has a FIB, though it may be a simple default route. An intermediate system (i.e., a router) typically has a much larger FIB. A core CCNx forwarder, for example, would know all the global routes.",
      "ja": "FIBはどこリクエストを送信するフォワーダを伝えた表です。これは、ローカルアプリケーション、ローカルキャッシュまたはContent Storeへの、またはリモートシステムを指すことがあります。 FIBに一致するエントリがない場合、フォワーダは要求を処理できません。 FIBに一致する名前に関する詳細なルールは、セクション2.4.4に記載されています。それは単純なデフォルトルートかもしれませんがエンドポイントは、FIBを持っています。中間システム（すなわち、ルータ）は、典型的にはるかに大きいFIBを有します。コアCCNxフォワーダは、例えば、すべてのグローバルルートを知っているだろう。"
    },
    {
      "indent": 3,
      "text": "A consumer is an endpoint that requests a name. It is beyond the scope of this document to describe how a consumer learns of a name or publisher KeyId; higher-layer protocols built on top of CCNx handle those tasks, such as search engines or lookup services or well-known names. The consumer constructs a request, called an Interest, and forwards it via the endpoint's FIB. The consumer should get back either a response (called a Content Object) that matches the Interest or a control message (called an Interest Return) that indicates the network cannot handle the request.",
      "ja": "消費者は名前を要求したエンドポイントです。これは、消費者が名前や出版社KEYIDの学習方法を説明するために、この文書の範囲外です。 CCNxの上に構築された上位層プロトコルは、このような検索エンジンや検索サービスや、よく知られた名前など、これらのタスクを扱います。消費者が関心を呼ばれ、要求を構築し、エンドポイントのFIBを経由して転送します。消費者は、バック利息またはネットワークが要求を処理できないことを示し（利息リターンと呼ばれる）制御メッセージに一致する（コンテンツオブジェクトと呼ばれる）応答のいずれかを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "There are three ways to detect errors in Interest handling. An Interest Return is a network control message that indicates a low-level error like \"no route\" or \"out of resources\". If an Interest arrives at a producer, but the producer does not have the requested content, the producer should send an application-specific error message (e.g., a \"not found\" message). Finally, a consumer may not receive anything; in which case, it should timeout and, depending on the application, retry the request or return an error to the application.",
      "ja": "インタレスト取り扱いにおけるエラーを検出するための3つの方法があります。利息リターンは「NOルート」や「資源のうち」のような低レベルのエラーを示したネットワーク制御メッセージです。利息はプロデューサーに到着したが、プロデューサーが要求されたコンテンツを持っていない場合は、プロデューサーは、アプリケーション固有のエラー・メッセージ（例えば、「見つかりません」というメッセージ）を送信する必要があります。最後に、消費者は何も受信しない場合があり、その場合には、タイムアウトと、用途に応じて、要求を再試行するか、アプリケーションにエラーを返すべきです。"
    },
    {
      "indent": 0,
      "text": "1.3. Protocol Overview",
      "section_title": true,
      "ja": "1.3. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The goal of CCNx is to name content and retrieve the content from the network without binding it to a specific network endpoint. A routing system (specified separately) populates the FIB tables at each CCNx router with hierarchical name prefixes that point towards the content producers under that prefix. A request finds matching content along those paths, in which case a response carries the data, or, if no match is found, a control message indicates the failure. A request may further refine acceptable responses with a restriction on the response's signer and the cryptographic hash of the response. The details of these restrictions are described below.",
      "ja": "CCNxの目標は、内容に名前を付け、特定のネットワークエンドポイントにそれを結合することなくネットワークからコンテンツを取得することです。 （別途指定）ルーティングシステムは、そのプレフィックスの下でコンテンツ制作に向けてポイント階層名プレフィックスを有する各CCNxルータにFIBテーブルを移入します。要求は、これらのパスに沿って一致するコンテンツを検索し、応答データを運ぶ、または、一致が見つからない場合、制御メッセージが失敗を示している場合。要求は、さらに、応答の署名者の制限と応答の暗号ハッシュと許容される応答を改善することができます。これらの制限の詳細については、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "The CCNx name is a hierarchical series of name segments. Each name segment has a type and zero or more bytes. Matching two names is done as a binary comparison of the type and value, and is done segment by segment. The human-readable form is defined under a URI scheme \"ccnx:\" [ccnx-uri], though the canonical encoding of a name is a series of pairs (type, octet string). There is no requirement that any name segment be human readable or UTF-8. The first few segments in a name will be matched against the FIB, and a routing protocol may put its own restrictions on the routable name components (e.g., a maximum length or character-encoding rules). In principle, name segments and names have unbounded length, though in practice they are limited by the wire encoding and practical considerations imposed by a routing protocol. Note that in CCNx, name segments use binary comparison, whereas in a URI, the authority uses a case-insensitive hostname (due to DNS).",
      "ja": "CCNx名は名セグメントの階層的なシリーズです。各名前セグメントは、タイプおよびゼロ以上のバイトを有しています。二つの名前に一致する型と値のバイナリ比較として行われ、セグメントごとに行われます。名前の正規符号化対（タイプ、オクテットストリング）のシリーズであるが、[ccnx-URI]：人間が読める形式は、URIスキーム「ccnx」で定義されています。任意の名前セグメントは、人間が読める形式またはUTF-8である必要はありません。名前の最初のいくつかのセグメントは、FIBと照合され、ルーティングプロトコルは、ルーティング可能な名前の構成要素（例えば、最大長または文字符号化規則）に独自の制限を置いてもよいです。実際に、彼らは、ワイヤ符号化およびルーティングプロトコルによって課せられる実用的な考慮事項によって制限されているものの、原理的には、名前セグメントと名前は、無限の長さを有します。 URIで、権限が（原因DNS）は、大文字と小文字を区別しないホスト名を使用するのに対しCCNxに、名前セグメントは、バイナリ比較を使用することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The CCNx name, as used by the forwarder, is purposefully left as a general octet-encoded type and value without any requirements on human readability and character encoding. The reason for this is that we are concerned with how a forwarder processes names. We expect that applications, routing protocols, or other higher layers will apply their own conventions and restrictions on the allowed name segment types and name segment values.",
      "ja": "CCNx名は、フォワーダによって使用されるように、意図的に人間の可読性と文字エンコーディング上の任意の要件なし一般的なオクテットエンコードタイプおよび値として残されます。この理由は、我々はフォワーダが名を処理する方法に関するものであるということです。私たちは、アプリケーション、ルーティングプロトコル、または他の上位層は許さ名セグメントタイプと名前のセグメント値に、独自の規則および制限を適用することを期待しています。"
    },
    {
      "indent": 3,
      "text": "CCNx is a request and response protocol that fetches chunks of data using a name. The integrity of each chunk may be directly asserted through a digital signature or Message Authentication Code (MAC), or, alternatively, indirectly via hash chains. Chunks may also carry weaker Message Integrity Codes (MICs) or no integrity protection mechanism at all. Because provenance information is carried with each chunk (or larger indirectly protected block), we no longer need to rely on host identities, such as those derived from TLS certificates, to ascertain the chunk legitimacy. Therefore, data integrity is a core feature of CCNx; it does not rely on the data transmission channel. There are several options for data confidentiality, discussed later.",
      "ja": "CCNxは、名前を使用して、データのチャンクをフェッチ要求および応答プロトコルです。各チャンクの完全性は、直接的、間接的に、ハッシュチェーンを介して、あるいは、デジタル署名又はメッセージ認証コード（MAC）を介してアサートされる、またはされてもよいです。チャンクはまた全然弱いメッセージ整合性コード（MIC）があるかまたは全く整合性の保護メカニズムを運ぶことができます。来歴情報は、各チャンク（以上、間接的に保護されたブロック）で行われているので、我々はもはやチャンク正当性を確認するために、そのようなTLS証明書に由来するものとして、ホストアイデンティティに頼る必要はありません。このため、データの整合性がCCNxのコア機能です。それは、データ伝送チャネルに依存しません。後述するデータの機密性のためのいくつかのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "This document only defines the general properties of CCNx names. In some isolated environments, CCNx users may be able to use any name they choose and either inject that name (or prefix) into a routing protocol or use other information foraging techniques. In the Internet environment, there will be policies around the formats of names and assignments of names to publishers, though those are not specified here.",
      "ja": "この文書では、唯一のCCNx名の一般的なプロパティを定義します。いくつかの単離された環境では、CCNxユーザーは、彼らが選択した任意の名前を使用して、ルーティングプロトコルにその名前（または接頭辞）を注入または他の情報採餌技術を使用するかすることができるかもしれません。それらはここで指定されていないものの、インターネット環境では、発行者に名前と名前の割り当ての形式の周りの方針があるでしょう。"
    },
    {
      "indent": 3,
      "text": "The key concept of CCNx is that a subjective name is cryptographically bound to a fixed payload. These publisher-generated bindings can therefore be cryptographically verified. A named payload is thus the tuple {{Name, ExtraFields, Payload, ValidationAlgorithm}, ValidationPayload}, where all fields in the inner tuple are covered by the validation payload (e.g., signature). Consumers of this data can check the binding integrity by recomputing the same cryptographic hash and verifying the digital signature in ValidationPayload.",
      "ja": "CCNxの重要な概念は、主観的な名前は、暗号一定のペイロードにバインドされていることです。これらの出版社、生成されたバインディングは、したがって、暗号的に検証することができます。名前のペイロードは、このように内側のタプルのすべてのフィールドが検証ペイロード（例えば、署名）によって覆われているタプル{{名前、ExtraFields、ペイロード、ValidationAlgorithm}、ValidationPayload}、です。このデータの消費者は、同じ暗号ハッシュを再計算し、ValidationPayloadにデジタル署名を検証することによって、結合の完全性を確認することができます。"
    },
    {
      "indent": 3,
      "text": "In addition to digital signatures (e.g., RSA), CCNx also supports message authentication codes (e.g., Hashed Message Authentication Code (HMAC)) and message integrity codes (e.g., Cyclic Redundancy Checks (CRC)). To maintain the cryptographic binding, there should be at least one object with a signature or authentication code, but not all objects require it. For example, a first object with a signature could refer to other objects via a hash chain, a Merkle tree, or a signed manifest. The later objects may not have any validation and rely purely on the references. The use of an integrity code (e.g., CRC) is intended for detecting accidental corruption in an Interest.",
      "ja": "デジタル署名（例えば、RSA）に加えて、CCNxはまた、メッセージ認証コード（例えば、ハッシュメッセージ認証コード（HMAC））をサポートし、メッセージ完全性コード（例えば、巡回冗長検査（CRC））。暗号化結合を維持するために、そこに署名又は認証コードを有する少なくとも一つのオブジェクトではなく、すべてのオブジェクトは、それを必要とするべきです。例えば、署名付き第一の目的は、ハッシュチェーン、マークル木、または署名されたマニフェストを介して他のオブジェクトを参照することができます。後でオブジェクトが検証を一切持っており、参照に純粋に依存しない場合があります。完全性コード（例えば、CRC）の使用は、対象における偶発的破損を検出するために意図されています。"
    },
    {
      "indent": 3,
      "text": "CCNx specifies a network protocol around Interests (request messages) and Content Objects (response messages) to move named payloads. An Interest includes the Name field, which identifies the desired response, and optional matching restrictions. Restrictions limit the possible matching Content Objects. Two restrictions exist: the Key ID restriction (KeyIdRestr) and Content Object Hash restriction (ContentObjectHashRestr). The first restriction on the KeyId limits responses to those signed with a ValidationAlgorithm KeyId field equal to the restriction. The second is the Content Object Hash restriction, which limits the response to one where the cryptographic hash of the entire named payload is equal to the restriction. Section 9 fully explains how these restrictions limit matching of a Content Object to an Interest.",
      "ja": "CCNxは、名前のペイロードを移動するために興味（リクエスト・メッセージ）とコンテンツオブジェクト（応答メッセージ）を中心にネットワーク・プロトコルを指定します。関心が所望の応答を識別する名前フィールド、およびオプションのマッチング制約を含みます。制限事項は、可能なマッチングコンテンツオブジェクトを制限します。 2つの制約が存在します。Key IDの制限（KeyIdRestr）とコンテンツオブジェクトのハッシュ制限（ContentObjectHashRestrを）。鍵IDの最初の制限は、制限に等しいValidationAlgorithm鍵IDフィールドを使用して署名されたものと応答が制限されます。第二は、全体命名ペイロードの暗号ハッシュは、制限に等しいものと応答を制限するコンテンツオブジェクトのハッシュ制限、です。第9節は完全にこれらの制限は、インタレストにコンテンツオブジェクトのマッチングを制限する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The hierarchy of a CCNx name is used for routing via the longest matching prefix in a forwarder. The longest matching prefix is computed name segment by name segment in the hierarchical name, where each name segment must be exactly equal to match. There is no requirement that the prefix be globally routable. Within a deployment, any local routing may be used, even one that only uses a single flat (nonhierarchical) name segment.",
      "ja": "CCNx名の階層は、フォワーダで最長一致プレフィクスを介してルーティングするために使用されます。最長一致接頭部は、それぞれの名前のセグメントが一致する正確に等しくなければならない階層名で名前セグメントによって名セグメントを計算します。接頭辞がグローバルにルーティング可能である必要はありません。配備内の、任意のローカルルーティングは、単一のフラット（非階層）名セグメントを使用してもいずれかを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Another concept of CCNx is that there should be flow balance between Interest messages and Content Object messages. At the network level, an Interest traveling along a single path should elicit no more than one Content Object response. If some node sends the Interest along more than one path, that node should consolidate the responses such that only one Content Object flows back towards the requester. If an Interest is sent broadcast or multicast on a multiple-access media, the sender should be prepared for multiple responses unless some other media-dependent mechanism like gossip suppression or leader election is used.",
      "ja": "CCNxのもう一つの概念は、インタレストメッセージやコンテンツオブジェクトのメッセージ間のフローのバランスがなければならないということです。ネットワークレベルでは、単一のパスに沿って移動する利息は、1つのコンテンツオブジェクトの応答よりも多くを誘発してはなりません。いくつかのノードが複数のパスに沿って金利を送信した場合、そのノードは、唯一のコンテンツオブジェクトは、要求者への流れるような応答を統合する必要があります。利息は、複数のアクセスメディア上でブロードキャストやマルチキャストを送信した場合ゴシップ抑制やリーダー選挙のようないくつかの他のメディア依存のメカニズムが使用されていない限り、送信者は複数の応答のために準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "As an Interest travels the forward path following the FIB, it establishes state at each forwarder such that a Content Object response can trace its way back to the original requester(s) without the requester needing to include a routable return address. We use the notional Pending Interest Table (PIT) as a method to store state that facilitates the return of a Content Object.",
      "ja": "インタレストFIB次の往路を移動するように、コンテンツオブジェクト応答がルーティング可能なリターン・アドレスを含むことを必要とすることなく、リクエスタ元の要求者（複数可）への道をたどることができるように、各フォワーダの状態を確立します。私たちは、コンテンツオブジェクトの復帰を容易に状態を保存するための方法として、名目保留関心表（PIT）を使用します。"
    },
    {
      "indent": 3,
      "text": "The notional PIT stores the last hop of an Interest plus its Name field and optional restrictions. This is the data required to match a Content Object to an Interest (see Section 9). When a Content",
      "ja": "想定元本PITは、利息を加えたその名前フィールドとオプションの制限の最後のホップを格納します。これは、金利へのコンテンツオブジェクトを一致させるために必要なデータである（セクション9を参照）。ときコンテンツ"
    },
    {
      "indent": 3,
      "text": "Object arrives, it must be matched against the PIT to determine which entries it satisfies. For each such entry, at most one copy of the Content Object is sent to each listed last hop in the PIT entries.",
      "ja": "オブジェクトは、満たすエントリを決定するためにPITと照合しなければならない、到着しました。各そのようなエントリのために、コンテンツオブジェクトの最大で1つのコピーがPITエントリ内の各リストされた最後のホップに送信されます。"
    },
    {
      "indent": 3,
      "text": "An actual PIT is not mandated by this specification. An implementation may use any technique that gives the same external behavior. There are, for example, research papers that use techniques like label switching in some parts of the network to reduce the per-node state incurred by the PIT [dart]. Some implementations store the PIT state in the FIB, so there is not a second table.",
      "ja": "実際のPITは、この仕様で規定されていません。実装では、同じ外部動作を与える任意の技術を使用することができます。 PIT [ダーツ]が負担ごとのノード状態を低減するために、ネットワークの一部でラベルスイッチングのような技術を使用し、例えば、研究論文があります。いくつかの実装は、FIBでPITの状態を保存するので、第二のテーブルが存在しません。"
    },
    {
      "indent": 3,
      "text": "If multiple Interests with the same {Name, [KeyIdRestr], [ContentObjectHashRestr]} tuple arrive at a node before a Content Object matching the first Interest comes back, they are grouped in the same PIT entry and their last hops are aggregated (see Section 2.4.2). Thus, one Content Object might satisfy multiple pending Interests in a PIT.",
      "ja": "同一の{名前、[KeyIdRestr]、[ContentObjectHashRestr]}タプルを持つ複数の趣味章を参照（最初の関心に一致するコンテンツオブジェクトが戻ってくる前に、それらが同じPITエントリにグループ化され、彼らの最後のホップが集約されるノードに到着した場合2.4.2）。したがって、一つのコンテンツオブジェクトは、PITで保留中の複数の興味を満たすことがあります。"
    },
    {
      "indent": 3,
      "text": "In CCNx, higher-layer protocols are often called \"name-based protocols\" because they operate on the CCNx name. For example, a versioning protocol might append additional name segments to convey state about the version of payload. A content discovery protocol might append certain protocol-specific name segments to a prefix to discover content under that prefix. Many such protocols may exist and apply their own rules to names. They may be layered with each protocol encapsulating (to the left) a higher layer's name prefix.",
      "ja": "彼らはCCNx名に動作するためCCNxでは、上位層プロトコルは、多くの場合、「名前ベースのプロトコル」と呼ばれています。例えば、バージョン管理プロトコルは、ペイロードのバージョンについての状態を伝えるために、追加の名前セグメントを追加するかもしれません。コンテンツの発見プロトコルは、そのプレフィックスの下でコンテンツを発見するために、プレフィックスに特定のプロトコル固有名セグメントを追加することがあります。そのような多くのプロトコルが存在し、名前に独自のルールを適用することができます。彼らは、各プロトコルカプセル化（左）、より高いレイヤの名前の接頭辞で積層してもよいです。"
    },
    {
      "indent": 3,
      "text": "This document also describes a control message called an Interest Return. A network element may return an Interest message to a previous hop if there is an error processing the Interest. The returned Interest may be further processed at the previous hop or returned towards the Interest origin. When a node returns an Interest, it indicates that the previous hop should not expect a response from that node for the Interest, i.e., there is no PIT entry left at the returning node for a Content Object to follow.",
      "ja": "また、このドキュメントでは、インタレストリターンと呼ばれる制御メッセージについて説明します。関心の処理にエラーが発生した場合、ネットワーク要素は、前のホップにインタレストメッセージを返すことができます。返された利息は、さらに前のホップで処理されるか、インタレスト原点に向けて返されることがあります。ノードが興味を返す場合、それは前のホップが関心をそのノードからの応答を期待すべきではないことを示し、すなわち、コンテンツオブジェクトを追従するための戻りノードに残されたPITエントリが存在しません。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways to describe larger objects in CCNx. Aggregating L3 Content Objects into larger objects is beyond the scope of this document. One proposed method, File-Like ICN Collection (FLIC) [flic], uses a manifest to enumerate the pieces of a larger object. Manifests are, themselves, Content Objects. Another option is to use a convention in the Content Object name, as in the CCNx Chunking [chunking] protocol where a large object is broken into small chunks and each chunk receives a special name component indicating its serial order.",
      "ja": "CCNxに大きなオブジェクトを記述するために複数の方法があります。より大きなオブジェクトにL3コンテンツオブジェクトを集約することは、この文書の範囲外です。一つの提案された方法、ファイルのようなICNコレクション（FLIC）[フリック]は、より大きな物体の一部を列挙するためにマニフェストを使用します。マニフェストは、コンテンツオブジェクトそのものです。別のオプションは、ラージ・オブジェクトを小さなチャンクに分割し、各チャンクは、そのシリアル順序を示す特別な名前コンポーネントを受けるCCNxチャンキング[チャンキング]プロトコルと同様に、コンテンツオブジェクト名に規則を使用することです。"
    },
    {
      "indent": 3,
      "text": "At the semantic level, described in this document, we do not address fragmentation. One experimental fragmentation protocol, BeginEnd Fragments [befrags], uses a multipoint PPP-style technique for use over L2 interfaces with the specification for CCNx Messages [RFC8609] in TLV wire encoding.",
      "ja": "この文書で説明セマンティックレベルでは、我々は断片化に対処するものではありません。 1つの実験断片化プロトコルは、BeginEndフラグメントは[befrags]、TLVワイヤエンコーディングでCCNxメッセージ[RFC8609]のための仕様のL2インタフェース上に使用するための多PPPスタイルの技術を使用します。"
    },
    {
      "indent": 3,
      "text": "With these concepts, the remainder of the document specifies the behavior of a forwarder in processing Interest, Content Object, and Interest Return messages.",
      "ja": "これらの概念を使用すると、ドキュメントの残りの部分は、処理インタレスト、コンテンツオブジェクト、および利息リターンメッセージでフォワーダの動作を指定します。"
    },
    {
      "indent": 0,
      "text": "2. Protocol",
      "section_title": true,
      "ja": "2.プロトコル"
    },
    {
      "indent": 3,
      "text": "This section defines the grammar of a CCNx Message (Interest, Content Object, or Interest Return). It then presents typical behaviors for a consumer, a publisher, and a forwarder. In the forwarder section, there are detailed descriptions about how to handle the forwarder-specific topics, such as HopLimit and Content Store, along with detailed processing pipelines for Interest and Content Object messages.",
      "ja": "このセクションでは、CCNxメッセージ（利息、コンテンツオブジェクト、または関心リターン）の文法を定義します。その後、消費者、出版社、およびフォワーダのための典型的な行動を提示します。フォワーダのセクションでは、利息およびコンテンツオブジェクトのメッセージの詳細な処理パイプラインと一緒に、このようHopLimitやコンテンツストアなどフォワーダ - 特定のトピックを扱う方法についての詳細な説明があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Message Grammar",
      "section_title": true,
      "ja": "2.1. メッセージ文法"
    },
    {
      "indent": 3,
      "text": "The CCNx Message ABNF [RFC5234] grammar is shown in Figure 1. The grammar does not include any encoding delimiters, such as TLVs. Specific wire encodings are given in a separate document. If a Validation section exists, the Validation Algorithm covers from the Body (BodyName or BodyOptName) through the end of the ValidationAlg section. The InterestLifetime, CacheTime, and Return Code fields exist outside of the validation envelope and may be modified.",
      "ja": "CCNxメッセージABNF [RFC5234]文法は、文法は、TLVのような任意の符号化区切り文字を含まない図1に示されています。特定ワイヤエンコーディングは、別の文書に記載されています。検証部が存在する場合、検証アルゴリズムValidationAlg部の端部を介してボディ（のBodyName又はBodyOptName）から覆っています。 InterestLifetime、CacheTime、および戻りコードフィールドは、検証エンベロープの外側に存在し、変更されてもよいです。"
    },
    {
      "indent": 3,
      "text": "HashType, PayloadType, and Private Enterprise Number (PEN) need to correspond to IANA values registered in the \"CCNx Hash Function Types\" and \"CCNx Payload Types\" registries [ccnx-registry], as well as the \"Private Enterprise Numbers\" registry [eprise-numbers], respectively.",
      "ja": "HashType、PayloadType、および民間企業数（PEN）は、[「CCNxハッシュ関数の種類」と「CCNxペイロードタイプ」レジストリ[ccnx-レジストリ]だけでなく、「民間企業番号」レジストリに登録IANA値に対応する必要がありますeprise-番号]、それぞれ。"
    },
    {
      "indent": 3,
      "text": "The various fields, in alphabetical order, are defined as:",
      "ja": "様々なフィールドは、アルファベット順に、次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "AbsTime: Absolute times are conveyed as the 64-bit UTC time in milliseconds since the epoch (standard POSIX time).",
      "ja": "ABSTIME：絶対時間はエポック（標準POSIX時間）からのミリ秒での64ビットUTC時間として搬送されます。"
    },
    {
      "indent": 3,
      "text": "CacheTime: The absolute time after which the publisher believes there is low value in caching the Content Object. This is a recommendation to caches (see Section 4).",
      "ja": "CacheTime：出版社がコンテンツオブジェクトをキャッシュでの低値があると考えていた後に絶対時間。これは、キャッシュへの勧告（第4節を参照）です。"
    },
    {
      "indent": 3,
      "text": "Cert: Some applications may wish to embed an X.509 certificate to both validate the signature and provide a trust anchor. The Cert is a DER-encoded X.509 certificate.",
      "ja": "証明書：一部のアプリケーションでは、署名を検証し、トラストアンカーを提供するために、両方のX.509証明書を埋め込むこともできます。証明書は、DER符号化されたX.509証明書です。"
    },
    {
      "indent": 3,
      "text": "ConObjField: These are optional fields that may appear in a Content Object.",
      "ja": "ConObjField：これらは、コンテンツオブジェクトに表示される場合がありますオプションのフィールドです。"
    },
    {
      "indent": 3,
      "text": "ConObjHash: The value of the Content Object Hash, which is the SHA256-32 over the message from the beginning of the body to the end of the message. Note that this coverage area is different from the ValidationAlg. This value SHOULD NOT be trusted across domains (see Section 5).",
      "ja": "ConObjHash：メッセージの最後に本文の先頭からのメッセージを超えるSHA256-32あるコンテンツオブジェクトのハッシュの値。このカバレッジエリアがValidationAlg異なることに注意してください。この値は、ドメイン間で信頼されるべきではない（第5節参照）。"
    },
    {
      "indent": 3,
      "text": "ContentObjectHashRestr: The Content Object Hash restriction. A Content Object must hash to the same value as the restriction using the same HashType. The ContentObjectHashRestr MUST use SHA256-32.",
      "ja": "ContentObjectHashRestr：コンテンツオブジェクトのハッシュ制限。コンテンツオブジェクトは、同じHashTypeを使用して制限と同じ値にハッシュしなければなりません。 ContentObjectHashRestrはSHA256-32を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ExpiryTime: An absolute time after which the Content Object should be considered expired (see Section 4).",
      "ja": "ExpiryTime：コンテンツオブジェクトが期限切れになったと見なされるべき後の絶対時間（4章を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Hash: Hash values carried in a Message carry a HashType to identify the algorithm used to generate the hash followed by the hash value. This form is to allow hash agility. Some fields may mandate a specific HashType.",
      "ja": "ハッシュ：メッセージで運ばれたハッシュ値は、ハッシュ値が続くハッシュを生成するために使用されるアルゴリズムを識別するためにHashTypeを運びます。この形式は、ハッシュ俊敏性を可能にすることです。一部のフィールドは、特定のHashTypeを義務付けることがあります。"
    },
    {
      "indent": 3,
      "text": "HashType: The algorithm used to calculate a hash, which must correspond to one of the IANA \"CCNx Hash Function Types\" [ccnx-registry].",
      "ja": "HashType：IANA「CCNxハッシュ関数タイプ」[ccnx-レジストリ]のいずれかに対応しなければならないハッシュを計算するために使用されるアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "HopLimit: Interest messages may loop if there are loops in the forwarding plane. To eventually terminate loops, each Interest carries a HopLimit that is decremented after each hop and no longer forwarded when it reaches zero. See Section 2.4.",
      "ja": "HopLimit：インタレストメッセージは、フォワーディングプレーンのループがあるかもしれループ場合。最終的にループを終了するために、各関心が各ホップの後にデクリメントされ、もはやそれがゼロに到達したときに転送されるHopLimitを運びます。 2.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "InterestField: These are optional fields that may appear in an Interest message.",
      "ja": "InterestField：これらは、インタレストメッセージに表示されることがあり、オプションのフィールドです。"
    },
    {
      "indent": 3,
      "text": "KeyId: An identifier for the key used in the ValidationAlg. See Validation (Section 8) for a description of how it is used for MACs and signatures.",
      "ja": "KEYID：ValidationAlgで使用する鍵の識別子。それはMACおよび署名のために使用される方法についての検証（8章）を参照してください。"
    },
    {
      "indent": 3,
      "text": "KeyIdRestr: The KeyId Restriction. A Content Object must have a KeyId with the same value as the restriction.",
      "ja": "KeyIdRestr：KEYID制限。コンテンツオブジェクトは、制限と同じ値を持つキーIDを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "KeyLink: A Link (see Section 6) that names how to retrieve the key used to verify the ValidationPayload (see Section 8).",
      "ja": "KeyLink：名前がどのように検証ペイロードを検証するために使用するキーを取得するためのリンク（第6節参照）（セクション8を参照）。"
    },
    {
      "indent": 3,
      "text": "Lifetime: The approximate time during which a requester is willing to wait for a response, usually measured in seconds. It is not strongly related to the network round-trip time, though it must necessarily be larger.",
      "ja": "生涯：リクエスタが応答を待つために喜んでいる間のおおよその時間は、通常、秒単位で測定します。それは必然的に大きくなければなりませんけれどもそれは強く、ネットワークラウンドトリップ時間とは関係ありません。"
    },
    {
      "indent": 3,
      "text": "Name: A name is made up of a nonempty first segment followed by zero or more additional segments, which may be of 0 length. Name segments are opaque octet strings and are thus case sensitive if encoding UTF-8. An Interest MUST have a Name. A Content Object MAY have a Name (see Section 9). The segments of a name are said to be complete if its segments uniquely identify a single Content Object. A name is exact if its segments are complete. An Interest carrying a full name is one that specifies an exact name and the Content Object Hash restriction of the corresponding Content Object.",
      "ja": "名前：名前は0長さであってもよいゼロ以上の追加のセグメントに続く空でない最初のセグメントから構成されています。 UTF-8をコードする場合、名前のセグメントは、不透明なオクテットストリングであり、したがって、大文字と小文字が区別されています。利息は名前を持つ必要があります。コンテンツオブジェクト（セクション9を参照）の名前を持っているかもしれません。名前のセグメントは、そのセグメントが一意に単一のコンテンツオブジェクトを識別する場合に完全であると言われています。そのセグメントが完了している場合、名前は正確です。フルネームを運ぶ関心が正確な名前と対応するコンテンツオブジェクトのコンテンツオブジェクトのハッシュ制限を指定するものです。"
    },
    {
      "indent": 3,
      "text": "Payload: The message's data, as defined by PayloadType.",
      "ja": "ペイロード：メッセージのデータ、PayloadTypeで定義されています。"
    },
    {
      "indent": 3,
      "text": "PayloadType: The format of the Payload field. If missing, assume Data type (T_PAYLOADTYPE_DATA) [ccnx-registry]. Data type means the payload is opaque application bytes. Key type (T_PAYLOADTYPE_KEY [ccnx-registry]) means the payload is a DER-encoded public key or X.509 certificate. Link type (T_PAYLOADTYPE_LINK [ccnx-registry]) means it is one or more Links (see Section 6).",
      "ja": "PayloadType：ペイロードフィールドのフォーマット。不足している場合は、データ型（T_PAYLOADTYPE_DATA）[ccnx-レジストリ]を想定しています。データタイプは、ペイロードが不透明なアプリケーションのバイトであることを意味します。キータイプ（T_PAYLOADTYPE_KEY [ccnx-レジストリ]）は、ペイロードがDER符号化された公開鍵またはX.509証明書であることを意味します。リンクタイプ（T_PAYLOADTYPE_LINK [ccnx-レジストリ]）は、1つまたは複数のリンク（セクション6を参照）であることを意味します。"
    },
    {
      "indent": 3,
      "text": "PublicKey: Some applications may wish to embed the public key used to verify the signature within the message itself. The PublickKey is DER encoded.",
      "ja": "PublicKey：一部のアプリケーションでは、メッセージ自体内の署名を検証するために使用される公開鍵を埋め込むこともできます。 PublickKeyは、DERエンコードされています。"
    },
    {
      "indent": 3,
      "text": "RelTime: A relative time, measured in milliseconds.",
      "ja": "reltimeに：相対時間は、ミリ秒単位で測定します。"
    },
    {
      "indent": 3,
      "text": "ReturnCode: States the reason an Interest message is being returned to the previous hop (see Section 10.2).",
      "ja": "RETURNCODE：米国金利のメッセージは前のホップに戻されている理由（10.2節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "SigTime: The absolute time (UTC milliseconds) when the signature was generated. The signature time only applies to the validation algorithm; it does not necessarily represent when the validated message was created.",
      "ja": "SigTime：署名が生成された絶対時間（UTCミリ秒）。署名時間はわずか検証アルゴリズムに適用されます。検証済みのメッセージが作成されたとき、それは必ずしも表すものではありません。"
    },
    {
      "indent": 3,
      "text": "Vendor: Vendor-specific opaque data. The Vendor data includes the IANA Private Enterprise Numbers [eprise-numbers], followed by vendor-specific information. CCNx allows vendor-specific data in most locations of the grammar.",
      "ja": "ベンダー：ベンダー固有の不透明なデータ。ベンダーデータは、ベンダー固有情報続いIANA民間企業番号[eprise-番号]を含みます。 CCNxは、文法のほとんどの場所では、ベンダー固有のデータを可能にします。"
    },
    {
      "indent": 3,
      "text": "Message = Interest / ContentObject / InterestReturn Interest = IntHdr BodyName [Validation] IntHdr = HopLimit [Lifetime] *Vendor ContentObject = ConObjHdr BodyOptName [Validation] ConObjHdr = [CacheTime / ConObjHash] *Vendor InterestReturn= ReturnCode Interest BodyName = Name Common BodyOptName = [Name] Common",
      "ja": "メッセージ=金利/ ContentObject / InterestReturnインタレスト= IntHdrのBodyName [検証] IntHdr = HopLimit [寿命] *ベンダーContentObject = ConObjHdr BodyOptName [検証] ConObjHdr = [CacheTime / ConObjHash] *ベンダーInterestReturn = RETURNCODE金利のBodyName =名共通BodyOptName = [名] 一般"
    },
    {
      "indent": 3,
      "text": "Common = *Field [Payload] Validation = ValidationAlg ValidationPayload",
      "ja": "コモン= *フィールド[ペイロード]検証= ValidationAlg ValidationPayload"
    },
    {
      "indent": 3,
      "text": "Name = FirstSegment *Segment FirstSegment = 1*OCTET / Vendor Segment = *OCTET / Vendor",
      "ja": "= FirstSegment *セグメントFirstSegment = 1 * OCTET /ベンダーセグメント= * OCTET /ベンダーの名前"
    },
    {
      "indent": 3,
      "text": "ValidationAlg = (RSA-SHA256 / EC-SECP-256K1 / EC-SECP-384R1 / HMAC-SHA256 / CRC32C) *Vendor ValidationPayload = 1*OCTET PublicAlg = KeyId [SigTime] [KeyLink] [PublicKey] [Cert] RSA-SHA256 = PublicAlg EC-SECP-256K1 = PublicAlg EC-SECP-384R1 = PublicAlg HMAC-SHA256 = KeyId [SigTime] [KeyLink] CRC32C = [SigTime]",
      "ja": "ValidationAlg =（RSA-SHA256 / EC-SECP-256K1 / EC-SECP-384R1 / HMAC-SHA256 / CRC32C）*ベンダーValidationPayload = 1 * OCTET PublicAlg = KEYID [SigTime] [KeyLink] [のPublicKey] [証明書] RSA-SHA256 = PublicAlg EC-SECP-256K1 = PublicAlg EC-SECP-384R1 = PublicAlg HMAC-SHA256 = KEYID [SigTime] [KeyLink] CRC32C = [SigTime]"
    },
    {
      "indent": 3,
      "text": "AbsTime = 8OCTET ; 64-bit UTC msec since epoch CacheTime = AbsTime ConObjField = ExpiryTime / PayloadType ConObjHash = Hash ExpiryTime = AbsTime Field = InterestField / ConObjField / Vendor Hash = HashType 1*OCTET HashType = 2OCTET ; IANA \"CCNx Hash Function Types\" HopLimit = OCTET InterestField = KeyIdRestr / ContentObjectHashRestr KeyId = Hash KeyIdRestr = Hash KeyLink = Link Lifetime = RelTime Link = Name [KeyIdRestr] [ContentObjectHashRestr] ContentObjectHashRestr = Hash Payload = *OCTET PayloadType = OCTET ; IANA \"CCNx Payload Types\" PublicKey = *OCTET ; DER-encoded public key Cert = *OCTET ; DER-encoded X.509 Certificate RelTime = 1*OCTET ; msec ReturnCode = OCTET ; see Section 10.2 SigTime = AbsTime Vendor = PEN *OCTET PEN = 1*OCTET ; IANA \"Private Enterprise Number\"",
      "ja": "ABSTIME = 8OCTET。エポックCacheTime = ABSTIME Con​​ObjField = ExpiryTime / PayloadType ConObjHash =ハッシュExpiryTime = ABSTIMEフィールド= InterestField / ConObjField /ベンダーハッシュ= HashType 1 * OCTET HashType = 2OCTETミリ秒の64ビットUTC。 IANA \"CCNxハッシュ関数の種類\" HopLimit = OCTET InterestField = KeyIdRestr / ContentObjectHashRestr KEYID =ハッシュKeyIdRestr =ハッシュKeyLink =リンク寿命= reltimeにリンク=名[KeyIdRestr] [ContentObjectHashRestr] ContentObjectHashRestr =ハッシュペイロード= * OCTET PayloadType = OCTET。 IANA \"CCNxペイロードタイプ\" のPublicKey = * OCTET。 DERでエンコードされた公開鍵証明書= * OCTET。 DERでエンコードされたX.509証明書reltimeに= 1 * OCTET。ミリ秒RETURNCODE = OCTET。 10.2節SigTime = ABSTIMEベンダー= PEN * OCTET PEN = 1 *のOCTETを参照してください。 IANA「民間企業数」"
    },
    {
      "indent": 20,
      "text": "Figure 1: CCNx Message ABNF Grammar",
      "ja": "図1：CCNxメッセージABNF文法"
    },
    {
      "indent": 0,
      "text": "2.2. Consumer Behavior",
      "section_title": true,
      "ja": "2.2. 消費者行動"
    },
    {
      "indent": 3,
      "text": "To request a piece of content for a given {Name, [KeyIdRest], [ContentObjectHashRestr]} tuple, a consumer creates an Interest message with those values. It MAY add a validation section, typically only a CRC32C. A consumer MAY put a Payload field in an Interest to send additional data to the producer beyond what is in the name. The name is used for routing and may be remembered at each hop in the notional PIT to facilitate returning a Content Object; storing large amounts of state in the name could lead to high memory requirements. Because the payload is not considered when forwarding an Interest or matching a Content Object to an Interest, a consumer SHOULD put an Interest Payload ID (see Section 3.2) as part of the name to allow a forwarder to match Interests to Content Objects and avoid aggregating Interests with different payloads. Similarly, if a consumer uses a MAC or a signature, it SHOULD also include a unique segment as part of the name to prevent the Interest from being aggregated with other Interests or satisfied by a Content Object that has no relation to the validation.",
      "ja": "所与の{名前、[KeyIdRest]、[ContentObjectHashRestr]}タプルのためのコンテンツのピースを要求するために、消費者は、これらの値を持つインタレストメッセージを作成します。それは、典型的には、検証区間のみCRC32Cを追加するかもしれません。消費者は名前であるものを超えてプロデューサに追加データを送信するために利益のためにペイロードフィールドを置いてもよいです。名前は、ルーティングに使用され、コンテンツオブジェクトを返す容易にするために、名目PIT内の各ホップで覚えてもよいです。名での状態を大量に保存することは、高いメモリ要件につながる可能性があります。関心を転送するか、関心にコンテンツオブジェクトを照合する際にペイロードが考慮されていないので、消費者が関心のペイロードIDを置くべきフォワーダがコンテンツオブジェクトへの興味と一致して集計を回避できるようにするために、名前の一部として（3.2節を参照してください）異なるペイロードと興味。消費者は、MACまたは署名を使用する場合同様に、それはまた、他の興味を持つ凝集または検証とは関係を持たないコンテンツオブジェクトによって満たされているから関心を防止するために、名前の一部として一意のセグメントを含むべきです。"
    },
    {
      "indent": 3,
      "text": "The consumer SHOULD specify an InterestLifetime, which is the length of time the consumer is willing to wait for a response. The InterestLifetime is an application-scale time, not a network round-trip time (see Section 2.4.2). If not present, the InterestLifetime will use a default value (2 seconds).",
      "ja": "消費者は、消費者が応答を待つても構わないと思っている時間の長さであるInterestLifetimeを、特定すべきです。 InterestLifetimeは、アプリケーション規模な時間ではなく、ネットワークラウンドトリップ時間（2.4.2項を参照）です。存在しない場合は、InterestLifetimeは、デフォルト値（2秒）を使用します。"
    },
    {
      "indent": 3,
      "text": "The consumer SHOULD set the Interest HopLimit to a reasonable value or use the default 255. If the consumer knows the distances to the producer via routing, it SHOULD use that value.",
      "ja": "消費者は、合理的な値に関心HopLimitを設定したり、消費者がルーティング経由プロデューサーまでの距離を知っている場合、それはその値を使用する必要があり、デフォルト255を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "A consumer hands off the Interest to its first forwarder, which will then forward the Interest over the network to a publisher (or replica) that may satisfy it based on the name (see Section 2.4).",
      "ja": "その後、名前に基づいて、それを満たすことが、パブリッシャ（またはレプリカ）をネットワーク経由で利息を転送しますその最初のフォワーダへの関心、オフ消費者の手が（セクション2.4を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Interest messages are unreliable. A consumer SHOULD run a transport protocol that will retry the Interest if it goes unanswered, up to the InterestLifetime. No transport protocol is specified in this document.",
      "ja": "インタレストメッセージは信頼できません。消費者は、それがInterestLifetimeまで、未回答行けば利息を再試行しますトランスポートプロトコルを実行する必要があります。いいえ、トランスポートプロトコルは、この文書で指定されていません。"
    },
    {
      "indent": 3,
      "text": "The network MAY send to the consumer an Interest Return message that indicates the network cannot fulfill the Interest. The ReturnCode specifies the reason for the failure, such as no route or congestion. Depending on the ReturnCode, the consumer MAY retry the Interest or MAY return an error to the requesting application.",
      "ja": "ネットワークは、消費者の関心を満たすことができないネットワークを示しインタレスト戻りメッセージを送信することができます。 RETURNCODEは、NOルートや渋滞など、失敗の理由を指定します。 RETURNCODEによっては、消費者が関心を再試行したり、要求元のアプリケーションにエラーを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "If the content was found and returned by the first forwarder, the consumer will receive a Content Object. The consumer uses the following set of checks to validate a received Content Object:",
      "ja": "コンテンツが見つかり、最初のフォワーダによって返された場合、消費者は、コンテンツオブジェクトを受け取ります。消費者は、受け取ったコンテンツオブジェクトを検証するためにチェックし、次のセットを使用しています："
    },
    {
      "indent": 3,
      "text": "o The consumer MUST ensure the Content Object is properly formatted.",
      "ja": "消費者がコンテンツオブジェクトが正しくフォーマットされていることを確認しなければならない（MUST）O。"
    },
    {
      "indent": 3,
      "text": "o The consumer MUST verify that the returned Content Object matches one or more pending Interests as per Section 9.",
      "ja": "O消費者は返さコンテンツオブジェクトは、第9章ごとに、1つ以上の保留中の興味と一致していることを確かめなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the Content Object is signed, the consumer SHOULD cryptographically verify the signature as per Section 8. If it does not have the corresponding key, it SHOULD fetch the key, such as from a key resolution service or via the KeyLink.",
      "ja": "コンテンツオブジェクトが署名されている場合、それは対応するキーを持っていない場合は、O、消費者が暗号セクション8通りの署名を検証すべきである、そのようなキー解決サービスからとして、あるいはKeyLinkを介してキーをフェッチすべきです。"
    },
    {
      "indent": 3,
      "text": "o If the signature has a SigTime, the consumer MAY use that in considering if the signature is valid. For example, if the consumer is asking for dynamically generated content, it should expect the SigTime not to be before the time the Interest was generated.",
      "ja": "署名がSigTimeを持っている場合は、O、消費者は、署名が有効である場合を考慮してそれを使用するかもしれません。消費者が動的に生成されたコンテンツを求めている場合、それはSigTimeは利息が生成された時刻の前ではないと期待してください。"
    },
    {
      "indent": 3,
      "text": "o If the Content Object is signed, the consumer SHOULD assert the trustworthiness of the signing key to the namespace. Such an assertion is beyond the scope of this document, though one may use traditional PKI methods, a trusted key resolution service, or methods like [trust].",
      "ja": "コンテンツオブジェクトが署名されている場合は、O、消費者は、名前空間への署名鍵の信頼性を主張すべきです。 1は、従来のPKI方式は、信頼できるキー解決サービス、または[信頼]のようなメソッドを使用するかもしれませんが、このような主張は、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "o The consumer MAY cache the Content Object for future use, up to the ExpiryTime if present.",
      "ja": "O消費者はExpiryTime存在する場合まで、将来の使用のためにコンテンツオブジェクトをキャッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "o The consumer MAY accept a Content Object off the wire that is expired. A packet Content Object may expire while in flight; there is no requirement that forwarders drop expired packets in flight. The only requirement is that Content Stores, caches, or producers MUST NOT respond with an expired Content Object.",
      "ja": "O消費者は有効期限が切れているワイヤーオフコンテンツオブジェクトを受け入れることができます。パケットコンテンツオブジェクトは、飛行中に期限切れこと。フォワーダーは、飛行中に期限切れのパケットをドロップする必要はありません。唯一の要件は、コンテンツを格納し、キャッシュ、または生産者が期限切れのコンテンツオブジェクトで応答してはならないということです。"
    },
    {
      "indent": 0,
      "text": "2.3. Publisher Behavior",
      "section_title": true,
      "ja": "2.3. 出版社の行動"
    },
    {
      "indent": 3,
      "text": "This document does not specify the method by which names populate a FIB table at forwarders (see Section 2.4). A publisher is either configured with one or more name prefixes under which it may create content or it chooses its name prefixes and informs the routing layer to advertise those prefixes.",
      "ja": "この文書では、名前がフォワーダーでのFIBテーブルを移入する方法を指定していない（2.4節を参照してください）。出版社は、それがコンテンツを作成することができるか、その名前プレフィックスを選択し、それらのプレフィックスを広告するルーティング層を通知する下一つ以上の名プレフィックスを使用して構成されますか。"
    },
    {
      "indent": 3,
      "text": "When a publisher receives an Interest, it SHOULD:",
      "ja": "発行者が利息を受け取ると、それは必要があります。"
    },
    {
      "indent": 3,
      "text": "o Verify that the Interest is part of the publisher's namespace(s).",
      "ja": "O利息は出版社の名前空間（S）の一部であることを確認します。"
    },
    {
      "indent": 3,
      "text": "o If the Interest has a Validation section, verify it as per Section 8. Usually an Interest will only have a CRC32C, unless the publisher application specifically accommodates other validations. The publisher MAY choose to drop Interests that carry a Validation section if the publisher application does not expect those signatures, as this could be a form of computational denial of service. If the signature requires a key that the publisher does not have, it is NOT RECOMMENDED that the publisher fetch the key over the network unless it is part of the application's expected behavior.",
      "ja": "利息は、検証部を有している場合、O、出版社のアプリケーションは、特に他のバリデーションを収容しない限り、通常は利息のみ、CRC32Cを持っています8節ごとに、それを検証します。これはサービスの計算拒否の形かもしれないと出版社は、出版社のアプリケーションは、これらの署名を期待していない場合は検証セクションを運ぶ興味をドロップするように選ぶかもしれません。署名は、出版社が持っていないというキーを必要とする場合、アプリケーションの予期される動作の一部である場合を除き、発行者がネットワーク経由でキーを取得することはお勧めできません。"
    },
    {
      "indent": 3,
      "text": "o Retrieve or generate the requested Content Object and return it to the Interest's previous hop. If the requested content cannot be returned, the publisher SHOULD reply with an Interest Return or a Content Object with application payload that says the content is not available; this Content Object should have a short ExpiryTime in the future or not be cacheable (i.e., an expiry time of 0).",
      "ja": "O取得または要求されたコンテンツオブジェクトを生成して、興味の前のホップに戻します。要求されたコンテンツを返すことができない場合は、発行者は、インタレスト・リターンやコンテンツが利用できないと言うアプリケーションペイロードを持つコンテンツオブジェクトで応答すべきです。このコンテンツオブジェクトは、将来の短いExpiryTimeを有するか、またはキャッシュ可能であるべきではない（すなわち、0の有効期限）。"
    },
    {
      "indent": 0,
      "text": "2.4. Forwarder Behavior",
      "section_title": true,
      "ja": "2.4. フォワーダ挙動"
    },
    {
      "indent": 3,
      "text": "A forwarder routes Interest messages based on a Forwarding Information Base (FIB), returns Content Objects that match Interests to the Interest's previous hop, and processes Interest Return control messages. It may also keep a cache of Content Objects in the notional Content Store table. This document does not specify the internal behavior of a forwarder, only these and other external behaviors.",
      "ja": "転送情報ベース（FIB）に基づいて、フォワーダルートインタレストメッセージは、金利の前のホップに興味と一致するコンテンツオブジェクトを返し、金利リターン制御メッセージを処理します。また、概念的なコンテンツストアテーブルにコンテンツオブジェクトのキャッシュを保持してもよいです。この文書では、これらおよび他の外部の行動のみをフォワーダの内部動作を指定しません。"
    },
    {
      "indent": 3,
      "text": "In this document, we will use two processing pipelines: one for Interests and one for Content Objects. Interest processing is made up of checking for duplicate Interests in the PIT (see Section 2.4.2), checking for a cached Content Object in the Content Store (see Section 2.4.3), and forwarding an Interest via the FIB. Content Store processing is made up of checking for matching Interests in the PIT and forwarding to those previous hops.",
      "ja": "興味のための1つのコンテンツオブジェクトに対して1：この文書では、我々は2つの処理パイプラインを使用します。利息処理は、（2.4.2項を参照）PIT内の重複興味をチェックする（2.4.3を参照）コンテンツストアにキャッシュされたコンテンツオブジェクトをチェックし、FIBを経由して関心を転送で構成されています。コンテンツストア処理はPITに興味を照合し、それらの前のホップに転送するためのチェックで構成されています。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Interest HopLimit",
      "section_title": true,
      "ja": "2.4.1. インタレストHopLimit"
    },
    {
      "indent": 3,
      "text": "Interest looping is not prevented in CCNx. An Interest traversing loops is eventually discarded using the hop-limit field of the Interest, which is decremented at each hop traversed by the Interest.",
      "ja": "利息のループはCCNxに防止されていません。ループを横切る利息は、最終的に関心が横断する各ホップでデクリメントされるスポットのホップ制限フィールドを用いて廃棄されます。"
    },
    {
      "indent": 3,
      "text": "A loop may also terminate because the Interest is aggregated with its previous PIT entry along the loop. In this case, the Content Object will be sent back along the loop and eventually return to a node that already forwarded the content, so it will likely not have a PIT entry anymore. When the content reaches a node without a PIT entry, it will be discarded. It may be that a new Interest or another looped Interest will return to that same node, in which case the node will return a cached response to make a new PIT entry, as below.",
      "ja": "インタレストがループに沿ってその前のPITエントリに集約されるので、ループも終了することができます。この場合、コンテンツオブジェクトがすでにコンテンツを転送したノードに戻るバックループに沿って、最終的に送信されますので、それはおそらくもうPITエントリを持っていません。コンテンツはPITエントリせずにノードに到達すると、それは破棄されます。これは、新しい興味や別の関心は、ノードが以下のように、新しいPITエントリを作るために、キャッシュされた応答を返します。その場合には、同じノードに戻りますループいる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The HopLimit is the last resort method to stop Interest loops where a Content Object chases an Interest around a loop and where the intermediate nodes, for whatever reason, no longer have a PIT entry and do not cache the Content Object.",
      "ja": "HopLimitは、コンテンツオブジェクトは、何らかの理由で、ループの周りの関心とどこ中間ノードを追うインタレスト・ループを停止する最後の方法で、もはやPITエントリを持っていないし、コンテンツオブジェクトをキャッシュしません。"
    },
    {
      "indent": 3,
      "text": "Every Interest MUST carry a HopLimit. An Interest received from a local application MAY have a 0 HopLimit, which restricts the Interest to other local sources.",
      "ja": "すべての関心がHopLimitを運ばなければなりません。ローカルアプリケーションから受け取った利息は、他のローカルソースへの関心を制限0 HopLimitを有していてもよいです。"
    },
    {
      "indent": 3,
      "text": "When an Interest is received from another forwarder, the HopLimit MUST be positive, otherwise the forwarder will discard the Interest. A forwarder MUST decrement the HopLimit of an Interest by at least 1 before it is forwarded.",
      "ja": "スポットが別のフォワーダから受信した場合、HopLimitさもなければフォワーダが興味を破棄し、正でなければなりません。それが転送される前に、フォワーダは、少なくとも1関心のHopLimitをデクリメントしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the decremented HopLimit equals 0, the Interest MUST NOT be forwarded to another forwarder; it MAY be sent to a local publisher application or serviced from a local Content Store.",
      "ja": "減算HopLimitが0の場合、利息は別のフォワーダに転送してはなりません。それは、地元の出版社のアプリケーションに送信されるか、ローカルコンテンツストアからサービスされます。"
    },
    {
      "indent": 3,
      "text": "A RECOMMENDED HopLimit-processing pipeline is below:",
      "ja": "推奨HopLimit処理パイプラインは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If Interest received from a remote system:",
      "ja": "利息は、リモート・システムから受信した場合○："
    },
    {
      "indent": 6,
      "text": "* If received HopLimit is 0, optionally send Interest Return (HopLimit Exceeded), and discard Interest.",
      "ja": "受信した場合* HopLimitは、必要に応じて金利リターン（HopLimitが超過）を送信し、利息を破棄し、0です。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, decrement the HopLimit by 1.",
      "ja": "*それ以外の場合は、1でHopLimitをデクリメント。"
    },
    {
      "indent": 3,
      "text": "o Process as per Content Store and Aggregation rules.",
      "ja": "コンテンツストアおよび集約ルールどおりOプロセス。"
    },
    {
      "indent": 3,
      "text": "o If the Interest will be forwarded:",
      "ja": "O関心が転送されます。"
    },
    {
      "indent": 6,
      "text": "* If the (potentially decremented) HopLimit is 0, restrict forwarding to the local system.",
      "ja": "（潜在的にデクリメント）HopLimitが0の場合*、ローカルシステムへの転送制限します。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, forward as desired to local or remote systems.",
      "ja": "*そうでない場合には、前方にローカルまたはリモートシステムに所望のように。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Interest Aggregation",
      "section_title": true,
      "ja": "2.4.2. インタレスト集約"
    },
    {
      "indent": 3,
      "text": "Interest aggregation is when a forwarder receives an Interest message that could be satisfied by the response to another Interest message already forwarded by the node, so the forwarder suppresses forwarding the new Interest; it only records the additional previous hop so a Content Object sent in response to the first Interest will satisfy both Interests.",
      "ja": "フォワーダが既にノードによって転送別の金利メッセージに応答することによって満足することができ、関心のメッセージを受信するので、フォワーダは、新しい関心を転送抑制する場合関心の集約です。最初の関心に応じて送信されるコンテンツオブジェクトは、両方の興味を満足させるので、それが唯一の追加前のホップを記録します。"
    },
    {
      "indent": 3,
      "text": "CCNx uses an Interest aggregation rule that assumes the InterestLifetime is akin to a subscription time and is not a network round-trip time. Some previous aggregation rules assumed the lifetime was a round-trip time, but this leads to problems of expiring an Interest before a response comes if the RTT is estimated too short or interfering with an Automatic Repeat reQuest (ARQ) scheme that wants to retransmit an Interest but a prior Interest overestimated the RTT.",
      "ja": "CCNxはInterestLifetimeは、加入時に似ていると仮定し、ネットワークラウンドトリップ時間ではありませんインタレスト・アグリゲーション・ルールを使用しています。いくつかの以前の集計ルールは寿命が往復時間だったと仮定が、RTTが短すぎると推定や自動再送要求再送信したい（ARQ）方式に干渉している場合は、応答が来る前に、これは関心の期限切れの問題につながりますインタレストしかし前利息は、RTTを過大評価しました。"
    },
    {
      "indent": 3,
      "text": "A forwarder MAY implement an Interest aggregation scheme. If it does not, then it will forward all Interest messages. This does not imply that multiple, possibly identical, Content Objects will come back. A forwarder MUST still satisfy all pending Interests, so one Content Object could satisfy multiple similar Interests, even if the forwarder did not suppress duplicate Interest messages.",
      "ja": "フォワーダは、金利の集計方式を実施することができます。そうでない場合は、それはすべてのインタレストメッセージを転送します。これは、複数の、おそらく同じ、コンテンツオブジェクトが戻ってくることを意味するものではありません。フォワーダはまだ保留中のすべての興味を満足させなければならないので、フォワーダが重複インタレストメッセージを抑制しなかった場合でも、1つのコンテンツオブジェクトは、複数の同じような興味を満たすことができます。"
    },
    {
      "indent": 3,
      "text": "A RECOMMENDED Interest aggregation scheme is:",
      "ja": "推奨インタレスト集計方式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Two Interests are considered \"similar\" if they have the same Name, KeyIdRestr, and ContentObjectHashRestr, where a missing optional field in one must be missing in the other.",
      "ja": "彼らは同じ名前、KeyIdRestr、および1で不足しているオプションのフィールドは、他にはないしなければならないContentObjectHashRestrを、持っている場合は、O二つの興味は「類似」と考えられています。"
    },
    {
      "indent": 3,
      "text": "o Let the notional value InterestExpiry (a local value at the forwarder) be equal to the receive time plus the InterestLifetime (or a platform-dependent default value if not present).",
      "ja": "O名目値InterestExpiry（フォワーダでローカル値）受信時間+ InterestLifetime（またはプラットフォーム依存のデフォルト値が存在しない場合）に等しいとします。"
    },
    {
      "indent": 3,
      "text": "o An Interest record (PIT entry) is considered invalid if its InterestExpiry time is in the past.",
      "ja": "そのInterestExpiry時間が過去にある場合、Oインタレスト・レコード（PITエントリ）が無効とみなされます。"
    },
    {
      "indent": 3,
      "text": "o The first reception of an Interest MUST be forwarded.",
      "ja": "Oスポットの最初の受信が転送されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A second or later reception of an Interest similar to a valid pending Interest from the same previous hop MUST be forwarded. We consider these a retransmission request.",
      "ja": "O同一の前のホップからの有効な保留関心と同様関心の二回目以降の受信が転送されなければなりません。我々は、これらの再送要求を検討してください。"
    },
    {
      "indent": 3,
      "text": "o A second or later reception of an Interest similar to a valid pending Interest from a new previous hop MAY be aggregated (not forwarded). If this Interest has a larger HopLimit than the pending Interest, it MUST be forwarded.",
      "ja": "O新しい前のホップからの有効な保留関心と同様関心の二回目以降の受信が集計されるかもしれない（転送されません）。この利息は、保留中の利息よりも大きなHopLimitを持っている場合、それは転送されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Aggregating an Interest MUST extend the InterestExpiry time of the Interest record. An implementation MAY keep a single InterestExpiry time for all previous hops or MAY keep the InterestExpiry time per previous hop. In the first case, the forwarder might send a Content Object down a path that is no longer waiting for it, in which case the previous hop (next hop of the Content Object) would drop it.",
      "ja": "利息を集約oを利息レコードのInterestExpiry時間を延長しなければなりません。実装は、以前のすべてのホップのための単一のInterestExpiry時間を維持したり、前のホップあたりInterestExpiry時間を保持してもよいです。最初のケースでは、フォワーダは、前のホップ（コンテンツオブジェクトの次のホップが）それをドロップします。その場合には、もはやそれを待っている道をオブジェクトのコンテンツを送信することがあります。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Content Store Behavior",
      "section_title": true,
      "ja": "2.4.3. コンテンツストアの動作"
    },
    {
      "indent": 3,
      "text": "The Content Store is a special cache that is an integral part of a CCNx forwarder. It is an optional component. It serves to repair lost packets and handle flash requests for popular content. It could be prepopulated or use opportunistic caching. Because the Content Store could serve to amplify an attack via cache poisoning, there are special rules about how a Content Store behaves.",
      "ja": "コンテンツストアはCCNxフォワーダの不可欠な部分である特殊なキャッシュです。これはオプションのコンポーネントです。これは、失われたパケットを修復し、人気の高いコンテンツのためのフラッシュ要求を処理するのに役立ちます。これは、あらかじめ入力または日和見キャッシュを使用することができます。コンテンツストアは、キャッシュポイズニングを経由して攻撃を増幅するのに役立つ可能性があるため、コンテンツストアがどのように動作するかについての特別な規則があります。"
    },
    {
      "indent": 3,
      "text": "1. A forwarder MAY implement a Content Store. If it does, the Content Store matches a Content Object to an Interest via the normal matching rules (see Section 9).",
      "ja": "1.フォワーダは、コンテンツストアを実施することができます。それがない場合、Content Storeは、通常のマッチングルールを介したインタレストにコンテンツオブジェクトに一致する（セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "2. If an Interest has a KeyId restriction, then the Content Store MUST NOT reply unless it knows the signature on the matching Content Object is correct. It may do this by external knowledge (i.e., in a managed network or system with prepopulated caches) or by having the public key and cryptographically verifying the signature. A Content Store is NOT REQUIRED to verify signatures; if it does not, then it treats these cases like a cache miss.",
      "ja": "2.金利が鍵IDの制限がある場合、それは、一致するコンテンツオブジェクトの署名が正しいことを知っている場合を除き、その後、コンテンツストアは、返信してはなりません。それは（すなわち、あらかじめ設定キャッシュと管理されたネットワークまたはシステム内の）外部の知識によって、または公開鍵を有する暗号署名を検証することによってこれを行うことができます。コンテンツストアは、署名を検証する必要はありません。そうでない場合、それは、キャッシュミスのようなこれらのケースを扱います。"
    },
    {
      "indent": 3,
      "text": "3. If a Content Store chooses to verify signatures, then it MAY do so as follows. If the public key is provided in the Content Object itself (i.e., in the PublicKey field) or in the Interest, the Content Store MUST verify that the public key's hash is equal to the KeyId and that it verifies the signature (see Section 8.4). A Content Store MAY verify the digital signature of a Content Object before it is cached, but it is not required to do so. A Content Store SHOULD NOT fetch keys over the network. If it cannot or has not yet verified the signature, it should treat the Interest as a cache miss.",
      "ja": "3.コンテンツストアは、署名を検証することを選択した場合、次のように、それはそうかもしれません。公開鍵は、コンテンツオブジェクト自体に提供されている場合（すなわち、公開鍵フィールド内）または利息で、コンテンツストアは、公開鍵のハッシュはKEYIDに等しいことを確かめなければなりませんし、それが署名を検証することを（8.4節を参照してください） 。コンテンツストアは、それがキャッシュされる前に、コンテンツオブジェクトのデジタル署名を確認することができるが、そうする必要はありません。コンテンツストアは、ネットワーク上のキーを取得すべきではありません。それはまだ署名を検証していないか、できない場合は、キャッシュミスなどの対象を扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "4. If an Interest has a Content Object Hash restriction, then the Content Store MUST NOT reply unless it knows the matching Content Object has the correct hash. If it cannot verify the hash, then it should treat the Interest as a cache miss.",
      "ja": "4.関心がコンテンツオブジェクトのハッシュ制限がある場合、それは、一致するコンテンツオブジェクトが正しいハッシュを持って知っている場合を除き、その後、コンテンツストアは、返信してはなりません。それはハッシュを確認できない場合、それはキャッシュミスなどの対象を扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "5. It must obey the cache control directives (see Section 4).",
      "section_title": true,
      "ja": "5.これは、キャッシュ制御ディレクティブを（セクション4を参照）に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4.4. Interest Pipeline",
      "section_title": true,
      "ja": "2.4.4. インタレストパイプライン"
    },
    {
      "indent": 3,
      "text": "1. Perform the HopLimit check (see Section 2.4.1).",
      "section_title": true,
      "ja": "1. HopLimitチェック（2.4.1項を参照）を実行します。"
    },
    {
      "indent": 3,
      "text": "2. If the Interest carries a validation, such as a MIC or a signature with an embedded public key or certificate, a forwarder MAY validate the Interest as per Section 8. A forwarder SHOULD NOT fetch keys via a KeyLink. If the forwarder drops an Interest due to failed validation, it MAY send an Interest Return (Section 10.3.9).",
      "ja": "2.関心はフォワーダがフォワーダがKeyLinkを介してキーをフェッチすべきではないセクション8に従ってインタレストを検証することができる、そのような埋め込まれた公開鍵または証明書付きMICまたはシグネチャとして、検証を運ぶ場合。フォワーダが失敗した検証のために金利をドロップした場合、それは金利リターン（セクション10.3.9）を送信することができます。"
    },
    {
      "indent": 3,
      "text": "3. Determine if the Interest can be aggregated as per Section 2.4.2. If it can be, aggregate and do not forward the Interest.",
      "ja": "利息は2.4.2項に従って集約することができるかどう3.決定します。それは、集約することができ、興味を転送しない場合。"
    },
    {
      "indent": 3,
      "text": "4. If forwarding the Interest, check for a hit in the Content Store as per Section 2.4.3. If a matching Content Object is found, return it to the Interest's previous hop. This injects the Content Store as per Section 2.4.5.",
      "ja": "4.金利を転送する場合は、セクション2.4.3に従ってコンテンツストアでのヒットを確認してください。マッチングコンテンツオブジェクトが見つかった場合、金利の前のホップに戻します。これは、2.4.5に従ってコンテンツストアを注入します。"
    },
    {
      "indent": 3,
      "text": "5. Look up the Interest in the FIB. Longest Prefix Match (LPM) is performed name segment by name segment (not byte or bit). It SHOULD exclude the Interest's previous hop. If a match is found, forward the Interest. If no match is found or the forwarder chooses not to forward due to a local condition (e.g., congestion), it SHOULD send an Interest Return message as per Section 10.",
      "ja": "5. FIBへの関心を検索します。最長プレフィックスマッチ（LPM）名前セグメント（不バイト又はビット）により名称セグメントを行います。それは興味の前のホップを除外する必要があります。一致が見つかった場合、利息を転送します。一致が見つからないか、またはフォワーダが局部状態（例えば、輻輳）に転送しないことを選択している場合、それは第10通りインタレスト返信メッセージを送ります。"
    },
    {
      "indent": 0,
      "text": "2.4.5. Content Object Pipeline",
      "section_title": true,
      "ja": "2.4.5. コンテンツオブジェクトパイプライン"
    },
    {
      "indent": 3,
      "text": "1. It is RECOMMENDED that a forwarder that receives a Content Object check that the Content Object came from an expected previous hop. An expected previous hop is one pointed to by the FIB or one recorded in the PIT as having had a matching Interest sent that way.",
      "ja": "1.これは、コンテンツオブジェクトが期待される前のホップから来たことをコンテンツオブジェクトのチェックを受けるフォワーダことが推奨されます。予想される前のホップは、一FIB又はマッチングインタレストがそのように送信されていたものとしてPITに記録された1つによって指されます。"
    },
    {
      "indent": 3,
      "text": "2. A Content Object MUST be matched to all pending Interests that satisfy the matching rules (see Section 9). Each satisfied pending Interest MUST then be removed from the set of pending Interests.",
      "ja": "2. Aコンテンツオブジェクト（セクション9を参照）のマッチングルールを満たすすべての保留中の興味に一致しなければなりません。それぞれの満足保留中の利息はその後、保留中の興味のセットから削除されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. A forwarder SHOULD NOT send more than one copy of the received Content Object to the same Interest previous hop. It may happen, for example, that two Interests ask for the same Content Object in different ways (e.g., by name and by name and KeyId), and that they both come from the same previous hop. It is normal to send the same Content Object multiple times on the same interface, such as Ethernet, if it is going to different previous hops.",
      "ja": "3.フォワーダは、同じ興味前のホップに受け取ったコンテンツオブジェクトの複数のコピーを送るべきではありません。 2人の興味は異なる方法（例えば、名前、名前と鍵IDによる）で同じコンテンツオブジェクトを要求していること、例えば、発生する可能性があり、そして彼らの両方が同じ前のホップから来ていること。別の前のホップに起こっている場合は、イーサネットなど、同じインターフェイス上で同じコンテンツオブジェクトを複数回送るようにするのが普通です。"
    },
    {
      "indent": 3,
      "text": "4. A Content Object SHOULD only be put in the Content Store if it satisfied an Interest (and passed rule #1 above). This is to reduce the chances of cache poisoning.",
      "ja": "それは興味を満たし（上記のルール＃1を通過した）場合4. Aコンテンツオブジェクトにのみコンテンツストアに配置する必要があります。これは、キャッシュ汚染の可能性を減らすことです。"
    },
    {
      "indent": 0,
      "text": "3. Names",
      "section_title": true,
      "ja": "3.名前"
    },
    {
      "indent": 3,
      "text": "A CCNx name is a composition of name segments. Each name segment carries a label identifying the purpose of the name segment, and a value. For example, some name segments are general names and some serve specific purposes such as carrying version information or the sequencing of many chunks of a large object into smaller, signed Content Objects.",
      "ja": "CCNx名は、名前セグメントの組成物です。各名前セグメントは、名セグメント、および価値の目的を識別するラベルを運びます。例えば、いくつかの名前セグメントは、一般的な名称であり、いくつかは、バージョン情報を以下にラージ・オブジェクトの多くのチャンクの順序を運ぶ、コンテンツオブジェクトに署名したような特定の目的を果たします。"
    },
    {
      "indent": 3,
      "text": "There are three different types of names in CCNx: prefix, exact, and full names. A prefix name is simply a name that does not uniquely identify a single Content Object, but rather a namespace or prefix of an existing Content Object name. An exact name is one that uniquely identifies the name of a Content Object. A full name is one that is exact and is accompanied by an explicit or implicit ConObjHash. The ConObjHash is explicit in an Interest and implicit in a Content Object.",
      "ja": "正確な接頭辞、およびフルネーム：CCNxの名前の3種類があります。プレフィックス名は、単純に一意に単一のコンテンツオブジェクトではなく、既存のコンテンツオブジェクト名の名前空間接頭辞かを識別しない名前です。正確な名前は一意にコンテンツオブジェクトの名前を特定するものです。フルネームは正確であると明示的または暗黙的なConObjHashを伴うものです。 ConObjHashは、コンテンツオブジェクトの関心が明示的および暗黙的です。"
    },
    {
      "indent": 3,
      "text": "Note that a forwarder does not need to know any semantics about a name. It only needs to be able to match a prefix to forward Interests and match an exact or full name to forward Content Objects. It is not sensitive to the name segment types.",
      "ja": "フォワーダは、名前についての意味を知っている必要がないことに注意してください。それだけで興味を転送し、コンテンツオブジェクトを転送するために、正確なまたは完全な名前と一致するプレフィックスと一致できるようにする必要があります。これは、名前のセグメントタイプに敏感ではありません。"
    },
    {
      "indent": 3,
      "text": "The name segment labels specified in this document are given in Table 1. Name Segment is a general name segment, typically occurring in the routable prefix and user-specified content name. Interest Payload ID is a name segment to identify the Interest's payload. Application Components are a set of name segment types reserved for application use.",
      "ja": "本書で指定された名前セグメントラベルを表1名セグメントに与えられている一般的にルーティング可能な接頭辞と、ユーザによって指定されたコンテンツ名に発生する、一般的な名前セグメントです。インタレストペイロードIDは、金利のペイロードを識別するための名前セグメントです。アプリケーションコンポーネントは、アプリケーションの使用のために予約名セグメントタイプのセットです。"
    },
    {
      "indent": 3,
      "text": "+-------------+-----------------------------------------------------+\n|     Type    | Description                                         |\n+-------------+-----------------------------------------------------+\n|     Name    | A generic name segment that includes arbitrary      |\n|   Segment   | octets.                                             |\n|             |                                                     |\n|   Interest  | An octet string that identifies the payload carried |\n|  Payload ID | in an Interest.  As an example, the Payload ID      |\n|             | might be a hash of the Interest Payload.  This      |\n|             | provides a way to differentiate between Interests   |\n|             | based on the payload solely through a name segment  |\n|             | without having to include all the extra bytes of    |\n|             | the payload itself.                                 |\n|             |                                                     |\n| Application | An application-specific payload in a name segment.  |\n|  Components | An application may apply its own semantics to these |\n|             | components.  A good practice is to identify the     |\n|             | application in a name segment prior to the          |\n|             | application component segments.                     |\n+-------------+-----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 1: CCNx Name Segment Types",
      "ja": "表1：CCNx名セグメントタイプ"
    },
    {
      "indent": 3,
      "text": "At the lowest level, a forwarder does not need to understand the semantics of name segments; it need only identify name segment boundaries and be able to compare two name segments (both label and value) for equality. The forwarder matches names segment by segment against its forwarding table to determine a next hop.",
      "ja": "最低レベルでは、フォワーダは、名前セグメントの意味を理解する必要はありません。それだけ名前セグメント境界を識別し、平等のための2つの名前セグメント（ラベルと値の両方）を比較することができる必要があります。フォワーダは次のホップを決定するために、その転送テーブルに対するセグメントによって名セグメントと一致します。"
    },
    {
      "indent": 0,
      "text": "3.1. Name Examples",
      "section_title": true,
      "ja": "3.1. 名前の例"
    },
    {
      "indent": 3,
      "text": "This section uses the CCNx URI [ccnx-uri] representation of CCNx names. Note that as per the message grammar, an Interest must have a Name with at least one name segment that must have at least 1 octet of value. A Content Object must have a similar name or no name at all. The FIB, on the other hand, could have 0-length names (a default route), or a first name segment with no value, or a regular name.",
      "ja": "このセクションでは、CCNx名のCCNx URI [ccnx-URI]の表現を使用しています。メッセージの文法に従って、関心値の少なくとも1つのオクテットを有していなければならない少なくとも一つの名前セグメントに名前を持たなければならないことに留意されたいです。コンテンツオブジェクトは、類似した名前またはまったく名前を持つ必要があります。 FIBは、一方で、長さ0名（デフォルトルート）、または値なし、または通常の名前の最初の名前セグメントを有することができます。"
    },
    {
      "indent": 3,
      "text": "+--------------------------+----------------------------------------+\n|           Name           | Description                            |\n+--------------------------+----------------------------------------+\n|          ccnx:/          | A 0-length name, corresponds to a      |\n|                          | default route.                         |\n|                          |                                        |\n|       ccnx:/NAME=        | A name with 1 segment of 0 length,     |\n|                          | distinct from ccnx:/.                  |\n|                          |                                        |\n| ccnx:/NAME=foo/APP:0=bar | A 2-segment name, where the first      |\n|                          | segment is of type NAME and the second |\n|                          | segment is of type APP:0.              |\n+--------------------------+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 2: CCNx Name Examples",
      "ja": "表2：CCNx名の例"
    },
    {
      "indent": 0,
      "text": "3.2. Interest Payload ID",
      "section_title": true,
      "ja": "3.2. インタレストペイロードID"
    },
    {
      "indent": 3,
      "text": "An Interest may also have a Payload field that carries state about the Interest but is not used to match a Content Object. If an Interest contains a payload, the Interest name should contain an Interest Payload ID (IPID). The IPID allows a PIT entry to correctly multiplex Content Objects in response to a specific Interest with a specific payload ID. The IPID could be derived from a hash of the payload or could be a Globally Unique Identifier (GUID) or a nonce. An optional Metadata field defines the IPID field so other systems can verify the IPID, such as when it is derived from a hash of the payload. No system is required to verify the IPID.",
      "ja": "利息はまた、金利についての状態を運ぶが、コンテンツオブジェクトを一致させるために使用されていないペイロードフィールドを有することができます。利息は、ペイロードが含まれている場合は、利息名インタレスト・ペイロードID（IPID）が含まれている必要があります。 IPIDは、特定のペイロードIDを持つ特定の関心に応じて正しく多重コンテンツオブジェクトへのPITエントリを可能にします。 IPIDは、ペイロードのハッシュから導出することができ、またはグローバル一意識別子（GUID）またはノンスとすることができます。オプションのメタデータ・フィールドは、それがペイロードのハッシュから導出されたときにように他のシステムがIPIDを、検証することができるIPIDフィールドを定義します。いいえシステムは、IPIDを検証するために必要とされません。"
    },
    {
      "indent": 0,
      "text": "4. Cache Control",
      "section_title": true,
      "ja": "4.キャッシュ制御"
    },
    {
      "indent": 3,
      "text": "CCNx supports two fields that affect cache control. These determine how a cache or Content Store handles a Content Object. They are not used in the fast path; they are only used to determine if a Content Object can be injected onto the fast path in response to an Interest.",
      "ja": "CCNxは、キャッシュ制御に影響を与える二つのフィールドをサポートしています。これらは、キャッシュまたはコンテンツストアは、コンテンツオブジェクトを処理する方法を決定します。彼らは、高速パスで使用されていません。彼らは唯一のコンテンツオブジェクトが関心に応じて、ファストパスに注入することができるかどうかを判断するために使用されています。"
    },
    {
      "indent": 3,
      "text": "The ExpiryTime is a field that exists within the signature envelope of a Validation Algorithm. It is the UTC time in milliseconds after which the Content Object is considered expired and MUST no longer be used to respond to an Interest from a cache. Stale content MAY be flushed from the cache.",
      "ja": "ExpiryTimeは、検証アルゴリズムの署名エンベロープ内に存在するフィールドです。これは、コンテンツオブジェクトが期限切れになったとみなされ、もはやキャッシュからの関心に応えるために使用しないことが必要になるまでのミリ秒単位のUTC時刻です。古いコンテンツがキャッシュからフラッシュされます。"
    },
    {
      "indent": 3,
      "text": "The Recommended Cache Time (RCT) is a field that exists outside the signature envelope. It is the UTC time in milliseconds after which the publisher considers the Content Object to be of low value to cache. A cache SHOULD discard it after the RCT, though it MAY keep it and still respond with it. A cache MAY also discard the Content Object before the RCT time; there is no contractual obligation to remember anything.",
      "ja": "推奨キャッシュ時間（RCT）が署名エンベロープの外部に存在するフィールドです。それは出版社がコンテンツオブジェクトがキャッシュに低い値であるとみなした後にミリ秒単位のUTC時刻です。それはそれを維持し、まだそれに応じるかもしれませんが、キャッシュは、RCT後にそれを捨てます。キャッシュはまた、RCT時間前にコンテンツオブジェクトを捨てるかもしれ。何かを覚えて何も契約上の義務はありません。"
    },
    {
      "indent": 3,
      "text": "This formulation allows a producer to create a Content Object with a long ExpiryTime but short RCT and keep republishing the same signed Content Object over and over again by extending the RCT. This allows a form of \"phone home\" where the publisher wants to periodically see that the content is being used.",
      "ja": "この製剤は、プロデューサが長いExpiryTimeしかし短いRCTを持つコンテンツオブジェクトを作成し、RCTを拡張することによって何度も同じ署名されたコンテンツオブジェクトを再発行維持することを可能にします。これは、出版社が定期的にコンテンツが使用されていることを見たい「携帯電話の家」の形を可能にします。"
    },
    {
      "indent": 0,
      "text": "5. Content Object Hash",
      "section_title": true,
      "ja": "5.コンテンツオブジェクトのハッシュ"
    },
    {
      "indent": 3,
      "text": "CCNx allows an Interest to restrict a response to a specific hash. The hash covers the Content Object message body and the validation sections, if present. Thus, if a Content Object is signed, its hash includes that signature value. The hash does not include the fixed or hop-by-hop headers of a Content Object. Because it is part of the matching rules (see Section 9), the hash is used at every hop.",
      "ja": "CCNxは、特定のハッシュへの応答を制限する利息を可能にします。存在する場合、ハッシュは、コンテンツオブジェクトのメッセージ本体と検証のセクションをカバーしています。コンテンツオブジェクトが署名されている場合したがって、そのハッシュは、その署名値を含みます。ハッシュは、コンテンツオブジェクトの固定またはホップバイホップヘッダを含みません。それは、マッチングルール（セクション9を参照）の一部であるため、ハッシュは、すべてのホップで使用されます。"
    },
    {
      "indent": 3,
      "text": "There are two options for matching the Content Object Hash restriction in an Interest. First, a forwarder could compute for itself the hash value and compare it to the restriction. This is an expensive operation. The second option is for a border device to compute the hash once and place the value in a header (ConObjHash) that is carried through the network. The second option, of course, removes any security properties from matching the hash, so it SHOULD only be used within a trusted domain. The header SHOULD be removed when crossing a trust boundary.",
      "ja": "利息にコンテンツオブジェクトのハッシュ制限をマッチングするための2つのオプションがあります。まず、フォワーダは自身のハッシュ値を計算し、それが制限と比較することができます。これは高価な操作です。第2のオプションは、一度ハッシュを計算し、ネットワークを介して実施されるヘッダ（ConObjHash）の値を配置する境界デバイスのためのものです。 2番目のオプションは、もちろん、ハッシュに一致するから任意のセキュリティプロパティを削除し、それが唯一の信頼できるドメイン内で使用されるべきである（SHOULD）。信頼境界を横断するときにヘッダが除去されるべきです。"
    },
    {
      "indent": 0,
      "text": "6. Link",
      "section_title": true,
      "ja": "6.リンク"
    },
    {
      "indent": 3,
      "text": "A Link is the tuple {Name, [KeyIdRestr], [ContentObjectHashRestr]}. The information in a Link comprises the fields of an Interest that would retrieve the Link target. A Content Object with PayloadType of \"Link\" is an object whose payload is one or more Links. This tuple may be used as a KeyLink to identify a specific object with the certificate-wrapped key. It is RECOMMENDED to include at least one of either KeyId restriction or Content Object Hash restriction. If neither restriction is present, then any Content Object with a matching name from any publisher could be returned.",
      "ja": "リンクは、タプル{名前、[KeyIdRestr]、[ContentObjectHashRestr]}です。リンク内の情報は、リンクのターゲットを取得します興味のある分野を含みます。 「リンク」のPayloadTypeを持つコンテンツオブジェクトは、そのペイロードの1つまたは複数のリンクであるオブジェクトです。このタプルは、証明書ラップキーで特定のオブジェクトを識別するためにKeyLinkとして使用することができます。 KEYID制限またはコンテンツオブジェクトのハッシュ制限のいずれかのうちの少なくとも1つを含むことをお勧めします。どちらの制限が存在する場合、いずれかの出版社から名前が一致するすべてのコンテンツオブジェクトが返されることがあります。"
    },
    {
      "indent": 0,
      "text": "7. Hashes",
      "section_title": true,
      "ja": "7.ハッシュ"
    },
    {
      "indent": 3,
      "text": "Several protocol fields use cryptographic hash functions, which must be secure against attack and collisions. Because these hash functions change over time, with better ones appearing and old ones falling victim to attacks, it is important that a CCNx protocol implementation supports hash agility.",
      "ja": "いくつかのプロトコルフィールドには、攻撃や衝突に対して安全でなければならない暗号学的ハッシュ関数を使用します。これらのハッシュ関数は、時間の経過とともに変化するので、より良いものが登場すると、古いものは、攻撃の犠牲に落ちると、CCNxプロトコルの実装は、ハッシュ俊敏性をサポートしていることが重要です。"
    },
    {
      "indent": 3,
      "text": "In this document, we suggest certain hashes (e.g., SHA-256), but a specific implementation may use what it deems best. The normative CCNx Messages [RFC8609] specification should be taken as the definition of acceptable hash functions and uses.",
      "ja": "この文書では、我々は特定のハッシュ（例えば、SHA-256）をお勧めしますが、具体的な実装は、それが最善と判断したものを使用することができます。規範CCNxメッセージ[RFC8609]仕様は、許容可能なハッシュ関数および使用の定義として解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. Validation",
      "section_title": true,
      "ja": "8.検証"
    },
    {
      "indent": 0,
      "text": "8.1. Validation Algorithm",
      "section_title": true,
      "ja": "8.1. 検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The Validator consists of a ValidationAlgorithm that specifies how to verify the message and a ValidationPayload containing the validation output, e.g., the digital signature or MAC. The ValidationAlgorithm section defines the type of algorithm to use and includes any necessary additional information. The validation is calculated from the beginning of the CCNx Message through the end of the ValidationAlgorithm section (i.e., up to but not including the validation payload). We refer to this as the validation region. The ValidationPayload is the integrity value bytes, such as a MAC or signature.",
      "ja": "バリデータは、検証出力、例えば、デジタル署名またはMACを含むメッセージとValidationPayloadを確認する方法を指定ValidationAlgorithmから成ります。 ValidationAlgorithm部が使用するアルゴリズムのタイプを定義し、任意の必要な追加情報を含みます。検証はValidationAlgorithm部（すなわち、検証ペイロードを含むまでではない）の端部を通ってCCNxメッセージの先頭から計算されます。私たちは、検証領域としてこれを参照してください。 ValidationPayloadは、MACや署名などのインテグリティ値のバイトです。"
    },
    {
      "indent": 3,
      "text": "The CCNx Message Grammar (Section 2.1) shows the allowed validation algorithms and their structure. In the case of a Vendor algorithm, the vendor may use any desired structure. A Validator can only be applied to an Interest or a Content Object, not an Interest Return. An Interest inside an Interest Return would still have the original validator, if any.",
      "ja": "CCNxメッセージ文法（セクション2.1）が許容検証アルゴリズム及びその構造を示します。ベンダアルゴリズムの場合には、ベンダーは、任意の所望の構造を使用することができます。 Validatorは唯一の関心やコンテンツオブジェクトではなく、金利リターンに適用することができます。もしあれば利息戻る内部の関心はまだ、オリジナルのバリデータを持っているでしょう。"
    },
    {
      "indent": 3,
      "text": "The grammar allows multiple Vendor extensions to the validation algorithm. It is up to the vendor to describe the validation region for each extension. A vendor may, for example, use a regular signature in the validation algorithm, then append a proprietary MIC to allow for in-network error checking without using expensive signature verification. As part of this specification, we do not allow for multiple Validation Algorithm blocks apart from these vendor methods.",
      "ja": "文法は、検証アルゴリズムに複数のベンダー拡張を可能にします。これは、各拡張機能の検証範囲を記述するために、ベンダー次第です。ベンダーは、例えば、その後、高価な署名検証を使用せずにネットワークエラーチェックを可能にする独自のMICを追加し、検証アルゴリズムで正規署名を使用することができます。本明細書の一部として、私たちは離れてこれらのベンダーのメソッドから複数の検証アルゴリズムのブロックのために許可されていません。"
    },
    {
      "indent": 0,
      "text": "8.2. Message Integrity Codes",
      "section_title": true,
      "ja": "8.2. メッセージ整合性コード"
    },
    {
      "indent": 3,
      "text": "If the validation algorithm is CRC32C, then the validation payload is the output of the CRC over the validation region. This validation algorithm allows for an optional signature time (SigTime) to timestamp when the message was validated (calling it a \"signature\" time is a slight misnomer, but we reuse the same field for this purpose between MICs, MACs, and signatures).",
      "ja": "検証アルゴリズムがCRC32Cある場合、検証ペイロードは、検証領域にわたってCRCの出力です。この検証アルゴリズムは、メッセージが検証された場合（「署名」時間はわずか誤った名称であるが、我々はMICを、のMAC、および署名の間の、この目的のために同じフィールドを再利用することを呼び出す）タイムスタンプに任意の署名時間（SigTime）を可能にします。"
    },
    {
      "indent": 3,
      "text": "MICs are usually used with an Interest to avoid accidental in-network corruption. They are usually not used on Content Objects because the objects are either signed or linked to by hash chains, so the CRC32C is redundant.",
      "ja": "MICは通常、偶発ネットワーク内の破損を避けるために興味を持って使用されています。オブジェクトがいずれかの署名またはハッシュチェーンによってリンクされているので、彼らは通常、コンテンツオブジェクトに使用されていないので、CRC32Cは冗長です。"
    },
    {
      "indent": 0,
      "text": "8.3. Message Authentication Codes",
      "section_title": true,
      "ja": "8.3. メッセージ認証コード"
    },
    {
      "indent": 3,
      "text": "If the validation algorithm is HMAC-SHA256, then the validation payload is the output of the HMAC over the validation region. The validation algorithm requires a KeyId and allows for a signature time (SigTime) and KeyLink.",
      "ja": "検証アルゴリズムはHMAC-SHA256である場合、検証ペイロードは、検証領域上HMACの出力です。検証アルゴリズムは、鍵IDを必要とし、署名時間（SigTime）とKeyLinkを可能にします。"
    },
    {
      "indent": 3,
      "text": "The KeyId field identifies the shared secret used between two parties to authenticate messages. These secrets SHOULD be derived from a key exchange protocol such as [ccnx-ke]. The KeyId, for a shared secret, SHOULD be an opaque identifier not derived from the actual key; an integer counter, for example, is a good choice.",
      "ja": "鍵IDフィールドは、メッセージを認証するために2つの当事者間で共有されるシークレットを識別します。これらの秘密は、[ccnx-KE]として鍵交換プロトコルから誘導されるべきです。鍵IDは、共有された秘密のため、実際のキーに由来しない不透明な識別子でなければなりません。整数カウンタは、例えば、良い選択です。"
    },
    {
      "indent": 3,
      "text": "The signature time is the timestamp when the authentication code was computed and added to the messages.",
      "ja": "認証コードが計算され、メッセージに追加された場合、署名時間は、タイムスタンプです。"
    },
    {
      "indent": 3,
      "text": "The KeyLink field in a MAC indicates how to negotiate keys and should point towards the key exchange endpoint. The use of a key negotiation algorithm is beyond the scope of this specification, and a key negotiation algorithm is not required to use this field.",
      "ja": "MACでKeyLinkフィールドは、キーを交渉するために鍵交換のエンドポイントを指摘するべきかを示しています。鍵交換アルゴリズムを使用することは、この仕様の範囲を超えている、と鍵交換アルゴリズムは、このフィールドを使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "8.4. Signature",
      "section_title": true,
      "ja": "8.4. 署名"
    },
    {
      "indent": 3,
      "text": "Signature-validation algorithms use public key cryptographic algorithms such as RSA and the Elliptic Curve Digital Signature Algorithm (ECDSA). This specification and the corresponding wire encoding [RFC8609] only support three specific signature algorithms: RSA-SHA256, EC-SECP-256K1, and EC-SECP-384R1. Other algorithms may be added in through other documents or by using experimental or vendor-validation algorithm types.",
      "ja": "署名検証アルゴリズムは、RSAや楕円曲線デジタル署名アルゴリズム（ECDSA）などの公開鍵暗号化アルゴリズムを使用します。 RSA-SHA256、EC-SECP-256K1、およびEC-SECP-384R1：本明細書及び対応するワイヤエンコーディング[RFC8609]は3つのだけ、特定の署名アルゴリズムをサポートします。他のアルゴリズムは、他のドキュメントを介して、または実験的またはベンダー検証アルゴリズムのタイプを使用して添加してもよいです。"
    },
    {
      "indent": 3,
      "text": "A signature that is public key based requires a KeyId field and may optionally carry a signature time, an embedded public key, an embedded certificate, and a KeyLink. The signature time behaves as normal to timestamp when the signature was created. We describe the use and relationship of the other fields here.",
      "ja": "公開鍵が計算された署名は、鍵IDフィールドを必要とし、必要に応じて、署名時、埋め込み公開鍵、埋め込まれた証明書、及びKeyLinkを搬送することができます。署名が作成されたとき、署名時間は、タイムスタンプに、正常に動作します。ここでは、他のフィールドの使用との関係を説明します。"
    },
    {
      "indent": 3,
      "text": "It is not common to use embedded certificates, as they can be very large and may have validity periods different than the validated data. The preferred method is to use a KeyLink to the validating certificate.",
      "ja": "彼らは非常に大きくなる可能性が、検証データとは異なる有効期間を有することができるように、埋め込まれた証明書を使用するのが一般的ではありません。好ましい方法は、検証証明書にKeyLinkを使用することです。"
    },
    {
      "indent": 3,
      "text": "The KeyId field in the ValidationAlgorithm identifies the public key used to verify the signature. It is similar to a Subject Key Identifier from X.509 (Section 4.2.1.2 of [RFC5280]). We define the KeyId to be a cryptographic hash of the public key in DER form. All implementations MUST support the SHA-256 digest as the KeyId hash.",
      "ja": "ValidationAlgorithmにおける鍵IDフィールドは、署名を検証するために使用される公開鍵を識別する。これはX.509からサブジェクト鍵識別子（[RFC5280]のセクション4.2.1.2）と同様です。私たちは、鍵IDは、DER形式で公開鍵の暗号化ハッシュであることを定義します。すべての実装は鍵IDのハッシュとしてSHA-256ダイジェストをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The use of other algorithms for the KeyId is allowed, and it will not cause problems at a forwarder because the forwarder only matches the digest algorithm and digest output and does not compute the digest (see Section 9). It may cause issues with a Content Store, which needs to verify the KeyId and PublicKey match (see Section 2.4.3); though in this case, it only causes a cache miss and the Interest would still be forwarded to the publisher. As long as the publisher and consumers support the hash, data will validate.",
      "ja": "keyidに他のアルゴリズムを使用することは許可され、フォワーダだけダイジェストアルゴリズムと一致し、出力を消化し、ダイジェストを（セクション9を参照）を計算しないので、それがフォワーダで問題が発生することはありません。これは、鍵IDとのPublicKeyの一致を確認する必要があるコンテンツストア、（セクション2.4.3を参照）で問題が発生することがあります。この場合も、それだけでキャッシュミスが発生し、利息はまだ出版社に転送されます。限り発行者と消費者がハッシュをサポートするよう、データが検証されます。"
    },
    {
      "indent": 3,
      "text": "As per Section 9, a forwarder only matches the KeyId to a KeyId restriction. It does not need to look at the other fields such as the public key, certificate, or KeyLink.",
      "ja": "第9章ごととして、フォワーダは鍵IDの制限に鍵IDと一致しました。それは、このような公開鍵、証明書、またはKeyLinkなどの他の分野を見てする必要はありません。"
    },
    {
      "indent": 3,
      "text": "If a message carries multiples of the KeyId, public key, certificate, or KeyLink, an endpoint (consumer, cache, or Content Store) MUST ensure that any fields it uses are consistent. The KeyId MUST be the corresponding hash of the embedded public key or certificate public key. The hash function to use is the KeyId's HashType. If there is both an embedded public key and a certificate, the public keys MUST be the same.",
      "ja": "メッセージが鍵ID、公開鍵、証明書、またはKeyLink、エンドポイント（消費者、キャッシュ、またはコンテンツストア）の倍数を運ぶ場合は、使用するすべてのフィールドが一致していることを保証しなければなりません。鍵IDが埋め込まれた公開鍵または証明書の公開鍵の対応するハッシュでなければなりません。使用するハッシュ関数は、鍵IDのHashTypeです。埋め込まれた公開鍵と証明書の両方がある場合は、公開鍵は同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A message SHOULD NOT have both a PublicKey and a KeyLink to a public key, as that is redundant. It MAY have a PublicKey and a KeyLink to a certificate.",
      "ja": "それは冗長であるように、メッセージは、公開鍵へのPublicKeyとKeyLinkの両方を持つべきではありません。それはのPublicKeyおよび証明書へのKeyLinkを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "A KeyLink in a first Content Object may point to a second Content Object with a DER-encoded public key in the PublicKey field and an optional DER-encoded X.509 certificate in the payload. The second Content Object's KeyId MUST equal the first object's KeyId. The second object's PublicKey field MUST be the public key corresponding to the KeyId. That key must validate both the first and second object's signature. A DER-encoded X.509 certificate may be included in the second object's payload and its embedded public key MUST match the PublicKey. It must be issued by a trusted authority, preferably specifying the valid namespace of the key in the distinguished name. The second object MUST NOT have a KeyLink; we do not allow for recursive key lookup.",
      "ja": "最初のコンテンツオブジェクトにKeyLinkは、公開鍵フィールドにDER符号化された公開鍵とペイロードにおける任意のDER符号化されたX.509証明書を使用して第2コンテンツオブジェクトを指すことができます。第2のコンテンツオブジェクトのKEYIDは、最初のオブジェクトの鍵IDと等しくなければなりません。第二の目的の公開鍵フィールドは、鍵IDに対応する公開鍵でなければなりません。そのキーは、第1と第2の両方のオブジェクトの署名を検証する必要があります。 DER符号化されたX.509証明書は、第二の物体のペイロードに含まれてもよく、その埋め込まれた公開鍵のPublicKeyと一致しなければなりません。それは、好ましくは、識別名でのキーの有効な名前空間を指定して、信頼された機関によって発行されなければなりません。第二の目的は、KeyLinkを持ってはいけません。私たちは、再帰キーの検索を可能にするものではありません。"
    },
    {
      "indent": 0,
      "text": "9. Interest to Content Object Matching",
      "section_title": true,
      "ja": "コンテンツオブジェクトのマッチングに9インタレスト"
    },
    {
      "indent": 3,
      "text": "A Content Object satisfies an Interest if and only if (a) the Content Object name, if present, exactly matches the Interest name, (b) the ValidationAlgorithm KeyId of the Content Object exactly equals the Interest KeyId restriction, if present, and (c) the computed Content Object Hash exactly equals the Interest Content Object Hash restriction, if present.",
      "ja": "（a）は、コンテンツオブジェクトの名前が、存在する場合、正確インタレスト名と一致する場合にのみ及び、（b）は、コンテンツオブジェクトのValidationAlgorithm鍵IDが正確インタレスト鍵IDの制限は、存在する場合、および（cに等しい場合、コンテンツオブジェクトは、インタレストを満たします存在する場合）、計算されたコンテンツオブジェクトのハッシュは、正確に、利息のコンテンツオブジェクトのハッシュ制限に等しいです。"
    },
    {
      "indent": 3,
      "text": "The KeyId and KeyIdRestr use the Hash format (see Section 2.1). The Hash format has an embedded HashType followed by the hash value. When comparing a KeyId and KeyIdRestr, one compares both the HashType and the value.",
      "ja": "KEYIDとKeyIdRestrは、ハッシュ形式を使用します（セクション2.1を参照してください）。ハッシュフォーマットは、ハッシュ値が続く埋め込みHashTypeを有しています。鍵IDとKeyIdRestrを比較すると、一方がHashTypeと値の両方を比較します。"
    },
    {
      "indent": 3,
      "text": "The matching rules are given by this predicate, which, if it evaluates true, means the Content Object matches the Interest. Ni = Name in the Interest (may not be empty), Ki = KeyIdRestr in the Interest (may be empty), and Hi = ContentObjectHashRestr in the Interest (may be empty). Likewise, No, Ko, and Ho are those properties in the Content Object, where No and Ko may be empty; Ho always exists (it is an intrinsic property of the Content Object). For binary relations, we use \"&\" for AND and \"|\" for OR. We use \"E\" for the EXISTS (not empty) operator and \"!\" for the NOT EXISTS operator.",
      "ja": "マッチングルールは、それが真の評価された場合、コンテンツオブジェクトは興味と一致する意味、この述語で与えられます。スポットにおけるNi =名（空ではないかもしれない）、のKi =利益にKeyIdRestr（空であってもよい）、及び関心のHI = ContentObjectHashRestr（空であってもよいです）。同様に、いや、コ、及びホーはありませんし、コが空になることがあり、コンテンツオブジェクト、中にこれらのプロパティです。ホーは、常に（それがコンテンツオブジェクトの固有の特性である）が存在します。 「|」バイナリ関係のために、私たちは「＆」ANDおよび使用しますORため。私たちは、EXISTS（空でない）のために「E」演算子と「！」を使用しますNOTのためにオペレータが存在します。"
    },
    {
      "indent": 3,
      "text": "As a special case, if the Content Object Hash restriction in the Interest specifies an unsupported hash algorithm, then no Content Object can match the Interest, so the system should drop the Interest and MAY send an Interest Return to the previous hop. In this case, the predicate below will never get executed because the Interest is never forwarded. If the system is using the optional behavior of having a different system calculate the hash for it, then the system may assume all hash functions are supported and leave it to the other system to accept or reject the Interest.",
      "ja": "利益のためにコンテンツオブジェクトのハッシュ制限がサポートされていないハッシュアルゴリズムを指定した場合、システムが関心をドロップする必要がありますし、前のホップへの関心の戻りを送るかもしれので、特別な場合として、その後、何のコンテンツオブジェクトは、インタレストに一致することはできません。利息が転送されることはありませんので、この場合には、以下の述語が実行されることはありません飽きないだろう。システムが別のシステムを有するのオプションの動作を使用している場合、それのハッシュを計算し、その後、システムは、すべてのハッシュ関数がサポートされていると仮定し、関心を受け入れるか拒否する他のシステムに任せることができます。"
    },
    {
      "indent": 3,
      "text": "(!No | (Ni=No)) & (!Ki | (Ki=Ko)) & (!Hi | (Hi=Ho)) & (E No | E Hi)",
      "ja": "（！の ｜ （に＝の）） ＆ （！き ｜ （き＝こ）） ＆ （！ひ ｜ （ひ＝ほ）） ＆ （え の ｜ え ひ）"
    },
    {
      "indent": 3,
      "text": "As one can see, there are two types of attributes one can match. The first term depends on the existence of the attribute in the Content Object while the next two terms depend on the existence of the attribute in the Interest. The last term is the \"Nameless Object\" restriction that states that if a Content Object does not have a Name, then it must match the Interest on at least the Hash restriction.",
      "ja": "1が見ることができるように、1を一致させることができる2種類の属性があります。次の二つの用語が関心内の属性の存在に依存しつつ、第1項は、コンテンツオブジェクト内の属性の存在に依存しています。最後の項は、コンテンツオブジェクトの名前を持っていない場合、それは、少なくともハッシュ制限利息に一致しなければならないと述べ、「名も無きオブジェクト」制限です。"
    },
    {
      "indent": 3,
      "text": "If a Content Object does not carry the Content Object Hash as an expressed field, it must be calculated in network to match against. It is sufficient within an autonomous system to calculate a Content Object Hash at a border router and carry it via trusted means within the autonomous system. If a Content Object ValidationAlgorithm does not have a KeyId, then the Content Object cannot match an Interest with a KeyId restriction.",
      "ja": "コンテンツオブジェクトが発現フィールドとしてコンテンツオブジェクトのハッシュを運ぶしない場合は、照合するネットワークで計算しなければなりません。これは、境界ルータでコンテンツオブジェクトのハッシュを計算し、自律システム内の信頼できる手段を介して、それを運ぶために自律システム内で十分です。コンテンツオブジェクトValidationAlgorithmがKEYIDを持っていない場合は、コンテンツオブジェクトは、鍵IDの制限と利益を一致させることはできません。"
    },
    {
      "indent": 0,
      "text": "10. Interest Return",
      "section_title": true,
      "ja": "10.金利戻ります"
    },
    {
      "indent": 3,
      "text": "This section describes the process whereby a network element may return an Interest message to a previous hop if there is an error processing the Interest. The returned Interest may be further processed at the previous hop or returned towards the Interest origin. When a node returns an Interest, it indicates that the previous hop should not expect a response from that node for the Interest, i.e., there is no PIT entry left at the returning node.",
      "ja": "このセクションでは、関心の処理にエラーが発生した場合、ネットワーク要素は、前のホップへのインタレストメッセージを返すことができることにより、プロセスを記載しています。返された利息は、さらに前のホップで処理されるか、インタレスト原点に向けて返されることがあります。ノードが興味を返す場合、それは前のホップが関心をそのノードからの応答を期待すべきではないことを示し、すなわち、復帰ノードに残されたPITエントリが存在しません。"
    },
    {
      "indent": 3,
      "text": "The returned message maintains compatibility with the existing TLV packet format (a fixed header, optional hop-by-hop headers, and the CCNx Message body). The returned Interest packet is modified in only two ways:",
      "ja": "返されたメッセージは、既存のTLVパケットフォーマット（固定ヘッダ、オプションのホップバイホップヘッダ、及びCCNxメッセージ本体）との互換性を維持します。返された利息パケットは2つだけの方法で変更されています。"
    },
    {
      "indent": 3,
      "text": "o The PacketType is set to Interest Return to indicate a Feedback message.",
      "ja": "O PacketTypeは、フィードバックメッセージを示すために、金利返すように設定されています。"
    },
    {
      "indent": 3,
      "text": "o The ReturnCode is set to the appropriate value to signal the reason for the return.",
      "ja": "O RETURNCODEは、返品理由を知らせるために適切な値に設定されています。"
    },
    {
      "indent": 3,
      "text": "The specific encodings of the Interest Return are specified in [RFC8609].",
      "ja": "インタレストリターンの特定のエンコーディングは、[RFC8609]で指定されています。"
    },
    {
      "indent": 3,
      "text": "A forwarder is not required to send any Interest Return messages.",
      "ja": "フォワーダは、任意の利息リターンメッセージを送信するために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "A forwarder is not required to process any received Interest Return message. If a forwarder does not process Interest Return messages, it SHOULD silently drop them.",
      "ja": "フォワーダは、任意の受取利息のリターンメッセージを処理するために必要とされていません。フォワーダがインタレストリターンメッセージを処理していない場合、それは静かにそれらを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Interest Return message does not apply to a Content Object or any other message type.",
      "ja": "インタレストリターンメッセージは、コンテンツオブジェクトまたはその他のメッセージタイプには適用されません。"
    },
    {
      "indent": 3,
      "text": "An Interest Return message is a 1-hop message between peers. It is not propagated multiple hops via the FIB. An intermediate node that receives an Interest Return may take corrective actions or may propagate its own Interest Return to previous hops as indicated in the reverse path of a PIT entry.",
      "ja": "インタレストリターンメッセージは、ピア間の1ホップメッセージです。これは、FIBを介して複数のホップを伝播されません。インタレストリターンを受ける中間ノードは、是正措置をとることができるか、PITエントリの逆の経路で示されるように、前のホップに独自の関心の戻りを伝搬することができます。"
    },
    {
      "indent": 0,
      "text": "10.1. Message Format",
      "section_title": true,
      "ja": "10.1. メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The Interest Return message looks exactly like the original Interest message with the exception of the two modifications mentioned above. The PacketType is set to indicate the message is an Interest Return, and the reserved byte in the Interest header is used as a Return Code. The numeric values for the PacketType and ReturnCodes are in [RFC8609].",
      "ja": "インタレストリターンメッセージは正確に上記の2つの変更を除いて、元のインタレストメッセージのように見えます。 PacketTypeは、関心リターンであり、関心のヘッダ内の予約バイトがリターンコードとして使用されるメッセージを示すために設定されています。 PacketTypeとReturnCodesのための数値は[RFC8609]です。"
    },
    {
      "indent": 0,
      "text": "10.2. ReturnCode Types",
      "section_title": true,
      "ja": "10.2.  RETURNCODEタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines the Interest Return ReturnCode introduced in this RFC. The numeric values used in the packet are defined in [RFC8609].",
      "ja": "このセクションでは、利息リターンRETURNCODEはこのRFCで導入定義します。パケットに使用される数値は、[RFC8609]で定義されています。"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n| Name                 | Description                                |\n+----------------------+--------------------------------------------+\n| No Route (Section    | The returning forwarder has no route to    |\n| 10.3.1)              | the Interest name.                         |\n|                      |                                            |\n| HopLimit Exceeded    | The HopLimit has decremented to 0 and      |\n| (Section 10.3.2)     | needs to forward the packet.               |\n|                      |                                            |\n| Interest MTU too     | The Interest's MTU does not conform to the |\n| large (Section       | required minimum and would require         |\n| 10.3.3)              | fragmentation.                             |\n|                      |                                            |\n| No Resources         | The node does not have the resources to    |\n| (Section 10.3.4)     | process the Interest.                      |\n|                      |                                            |\n| Path error (Section  | There was a transmission error when        |\n| 10.3.5)              | forwarding the Interest along a route (a   |\n|                      | transient error).                          |\n|                      |                                            |\n| Prohibited (Section  | An administrative setting prohibits        |\n| 10.3.6)              | processing this Interest.                  |\n|                      |                                            |\n| Congestion (Section  | The Interest was dropped due to congestion |\n| 10.3.7)              | (a transient error).                       |\n|                      |                                            |\n| Unsupported Content  | The Interest was dropped because it        |\n| Object Hash          | requested a Content Object Hash            |\n| Algorithm (Section   | restriction using a hash algorithm that    |\n| 10.3.8)              | cannot be computed.                        |\n|                      |                                            |\n| Malformed Interest   | The Interest was dropped because it did    |\n| (Section 10.3.9)     | not correctly parse.                       |\n+----------------------+--------------------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 3: Interest Return Reason Codes",
      "ja": "表3：利息返品理由コード"
    },
    {
      "indent": 0,
      "text": "10.3. Interest Return Protocol",
      "section_title": true,
      "ja": "10.3. インタレストリターンプロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the forwarder behavior for the various Reason codes for Interest Return. A forwarder is not required to generate any of the codes, but if it does, it MUST conform to this specification.",
      "ja": "このセクションでは、インタレストリターンのための様々な理由コードのためのフォワーダの動作を説明します。フォワーダは、コードのいずれかを生成するために必要とされていないが、それがない場合は、この仕様に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a forwarder receives an Interest Return, it SHOULD take these standard corrective actions. A forwarder is allowed to ignore Interest Return messages, in which case its PIT entry would go through normal timeout processes.",
      "ja": "フォワーダが関心リターンを受信した場合、これらの標準的な是正措置をとるべきです。フォワーダは、そのPITエントリが通常のタイムアウトプロセスを経ることになる場合には金利のリターンメッセージを、無視することが許されます。"
    },
    {
      "indent": 3,
      "text": "o Verify that the Interest Return came from a next hop to which it actually sent the Interest.",
      "ja": "O利息リターンは、それが実際に興味を送った先の次のホップから来ていることを確認します。"
    },
    {
      "indent": 3,
      "text": "o If a PIT entry for the corresponding Interest does not exist, the forwarder should ignore the Interest Return.",
      "ja": "対応する利息のためのPITエントリが存在しない場合は、O、フォワーダは、インタレスト・リターンを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "o If a PIT entry for the corresponding Interest does exist, the forwarder MAY do one of the following:",
      "ja": "対応する利息のためのPITエントリが存在しない場合は、O、フォワーダは、次のいずれかを行うことができます："
    },
    {
      "indent": 6,
      "text": "* Try a different forwarding path, if one exists, and discard the Interest Return, or",
      "ja": "* 1が存在する場合は、別の転送パスを試してみて、そして金利リターンを破棄、または"
    },
    {
      "indent": 6,
      "text": "* Clear the PIT state and send an Interest Return along the reverse path.",
      "ja": "*クリアPIT状態と逆の経路に沿って金利のリターンを送信します。"
    },
    {
      "indent": 3,
      "text": "If a forwarder tries alternate routes, it MUST ensure that it does not use the same path multiple times. For example, it could keep track of which next hops it has tried and not reuse them.",
      "ja": "フォワーダが代替ルートを試みる場合、それは、同じ経路を複数回使用していないことを確認しなければなりません。例えば、それは次のことはしようとしたホップいるのを追跡し、それらを再利用することができませんでした。"
    },
    {
      "indent": 3,
      "text": "If a forwarder tries an alternate route, it may receive a second Interest Return, possibly of a different type than the first Interest Return. For example, node A sends an Interest to node B, which sends a No Route return. Node A then tries node C, which sends a Prohibited Interest Return. Node A should choose what it thinks is the appropriate code to send back to its previous hop.",
      "ja": "フォワーダが代替ルートをしようとした場合、それは、おそらく最初のインタレスト戻りとは異なるタイプの第二インタレスト戻りを受信することができます。例えば、ノードAは、NOルートリターンを送信Bを、ノードにインタレストを送信します。ノードAは、禁止利息リターンを送信したノードCを、しようとします。ノードAは、その前のホップに送り返すための適切なコードであると考えるものを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a forwarder tries an alternate route, it should decrement the Interest Lifetime to account for the time spent thus far processing the Interest.",
      "ja": "フォワーダが代替ルートをしようとすると、それは金利を処理し、これまでに費やした時間のための口座に利息の寿命をデクリメントする必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.1. No Route",
      "section_title": true,
      "ja": "10.3.1. ルートがありません"
    },
    {
      "indent": 3,
      "text": "If a forwarder receives an Interest for which it has no route, or for which the only route is back towards the system that sent the Interest, the forwarder SHOULD generate a \"No Route\" Interest Return message.",
      "ja": "フォワーダは、それが何のルートを持たないために利息を受け取る、またはそのための唯一のルートが興味を送信されるシステムに向けてバックで、フォワーダが「NOルート」インタレスト戻りメッセージを生成する必要があります。場合"
    },
    {
      "indent": 3,
      "text": "How a forwarder manages the FIB table when it receives a No Route message is implementation dependent. In general, receiving a No Route Interest Return should not cause a forwarder to remove a route. The dynamic routing protocol that installed the route should correct the route, or the administrator who created a static route should correct the configuration. A forwarder could suppress using that next hop for some period of time.",
      "ja": "フォワーダが、それはNOルートメッセージを受信したFIBテーブルをどのように管理するかは実装依存です。一般的には、NOルート金利リターンを受信すると、ルートを削除するには、フォワーダが発生することはありません。ルートをインストールし、動的ルーティングプロトコルは、経路を修正する必要があり、または静的ルートを作成した管理者が設定を修正すべきです。フォワーダは、しばらくの間その次のホップを使用して抑制することができます。"
    },
    {
      "indent": 0,
      "text": "10.3.2. HopLimit Exceeded",
      "section_title": true,
      "ja": "10.3.2.  HopLimit超過"
    },
    {
      "indent": 3,
      "text": "A forwarder MAY choose to send HopLimit Exceeded messages when it receives an Interest that must be forwarded off system and the HopLimit is 0.",
      "ja": "フォワーダは、システムをオフに転送されなければならない利息を受け取り、HopLimitが0のときHopLimitがメッセージを超過送信するために選ぶかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.3.3. Interest MTU Too Large",
      "section_title": true,
      "ja": "10.3.3. インタレストMTUが大きすぎます"
    },
    {
      "indent": 3,
      "text": "If a forwarder receives an Interest whose MTU exceeds the prescribed minimum, it MAY send an \"Interest MTU Too Large\" message, or it may silently discard the Interest.",
      "ja": "フォワーダは、そのMTU所定の最小値を超えた関心を受信した場合、それは「目的MTUが大きすぎます」というメッセージを送ることができる、またはそれは静かに関心を破棄してもよいです。"
    },
    {
      "indent": 3,
      "text": "If a forwarder receives an \"Interest MTU Too Large\" response, it SHOULD NOT try alternate paths. It SHOULD propagate the Interest Return to its previous hops.",
      "ja": "フォワーダが「インタレストMTUが大きすぎます」応答を受信した場合、それは代替パスを試みるべきではありません。それは、その前のホップに興味リターンを伝播すべきです。"
    },
    {
      "indent": 0,
      "text": "10.3.4. No Resources",
      "section_title": true,
      "ja": "10.3.4. リソースなしません"
    },
    {
      "indent": 3,
      "text": "If a forwarder receives an Interest and it cannot process the Interest due to lack of resources, it MAY send an Interest Return. A lack of resources could mean the PIT is too large or that there is some other capacity limit.",
      "ja": "フォワーダが利息を受け取り、それはリソース不足に興味を処理できない場合には、金利のリターンを送信することができます。資源の不足は、PITが大きすぎるか、他のいくつかの容量制限があることを意味するかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.3.5. Path Error",
      "section_title": true,
      "ja": "10.3.5. パスのエラー"
    },
    {
      "indent": 3,
      "text": "If a forwarder detects an error forwarding an Interest, such as over a reliable link, it MAY send a Path-Error Interest Return indicating that it was not able to send or repair a forwarding error.",
      "ja": "フォワーダは、そのような信頼性の高いリンク上などの対象を、転送エラーを検出した場合、送信または転送エラーを修復することができなかったことを示すパス・エラー・インタレスト・リターンを送信することができます。"
    },
    {
      "indent": 0,
      "text": "10.3.6. Prohibited",
      "section_title": true,
      "ja": "10.3.6. 禁止されています"
    },
    {
      "indent": 3,
      "text": "A forwarder may have administrative policies, such as access control lists (ACLs), that prohibit receiving or forwarding an Interest. If a forwarder discards an Interest due to a policy, it MAY send a Prohibited Interest Return to the previous hop. For example, if there is an ACL that says \"/example/private\" can only come from interface e0, but the forwarder receives one from e1, the forwarder must have a way to return the Interest with an explanation.",
      "ja": "フォワーダは、このような受信や関心を転送禁止のアクセス制御リスト（ACL）、などの管理方針を有していてもよいです。フォワーダは政策による金利を破棄した場合、それは前のホップに禁止利息リターンを送信することができます。そこに「/例/プライベート」のみのインターフェイスE0から来ることができると言うACLですが、フォワーダは、E1からいずれかを受信した場合、フォワーダは、説明と利息を返す方法を持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.7. Congestion",
      "section_title": true,
      "ja": "10.3.7. 混雑"
    },
    {
      "indent": 3,
      "text": "If a forwarder discards an Interest due to congestion, it MAY send a Congestion Interest Return to the previous hop.",
      "ja": "フォワーダが輻輳による利息を破棄した場合、それは前のホップに混雑インタレスト・リターンを送信することができます。"
    },
    {
      "indent": 0,
      "text": "10.3.8. Unsupported Content Object Hash Algorithm",
      "section_title": true,
      "ja": "10.3.8. サポートされていないコンテンツオブジェクトハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "If a Content Object Hash restriction specifies a hash algorithm the forwarder cannot verify, the Interest should not be accepted and the forwarder MAY send an Interest Return to the previous hop.",
      "ja": "コンテンツオブジェクトのハッシュ制限がフォワーダが確認できないハッシュアルゴリズムを指定した場合、利息は受理すべきではないとフォワーダは、前のホップに興味リターンを送信することができます。"
    },
    {
      "indent": 0,
      "text": "10.3.9. Malformed Interest",
      "section_title": true,
      "ja": "10.3.9. 不正な形式の利息"
    },
    {
      "indent": 3,
      "text": "If a forwarder detects a structural or syntactical error in an Interest, it SHOULD drop the Interest and MAY send an Interest Return to the previous hop. This does not imply that any router must validate the entire structure of an Interest.",
      "ja": "フォワーダが関心の構造や構文エラーを検出した場合には、利息をドロップする必要があり、前のホップに興味リターンを送信することができます。これは、任意のルータが関心の全体構造を検証しなければならないことを意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントには、IANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The CCNx protocol is an L3 network protocol, which may also operate as an overlay using other transports such as UDP or other tunnels. It includes intrinsic support for message authentication via a signature (e.g., RSA or elliptic curve) or message authentication code (e.g., HMAC). In lieu of an authenticator, it may instead use a message integrity check (e.g., SHA or CRC). CCNx does not specify an encryption envelope; that function is left to a high-layer protocol (e.g., [esic]).",
      "ja": "CCNxプロトコルはまた、UDPまたは他のトンネルのような他のトランスポートを使用してオーバーレイとして動作することができるL3ネットワークプロトコル、です。これは、署名（例えば、RSAや楕円曲線）またはメッセージ認証コード（例えば、HMAC）を介してメッセージ認証のための固有のサポートを含みます。オーセンティケータの代わりに、それは代わりに、メッセージ完全性チェック（例えば、SHA又はCRC）を使用することができます。 CCNxは、暗号化エンベロープを指定していません。その機能は、高い層のプロトコル（例えば、[ESIC]）に任されています。"
    },
    {
      "indent": 3,
      "text": "The CCNx message format includes the ability to attach MICs (e.g., CRC32C), MACs (e.g., HMAC), and signatures (e.g., RSA or ECDSA) to all packet types. This does not mean that it is a good idea to use an arbitrary ValidationAlgorithm, nor to include computationally expensive algorithms in Interest packets, as that could lead to computational DoS attacks. Applications should use an explicit protocol to guide their use of packet signatures. As a general guideline, an application might use a MIC on an Interest to detect unintentionally corrupted packets. If one wishes to secure an Interest, one should consider using an encrypted wrapper and a protocol that prevents replay attacks, especially if the Interest is being used as an actuator. Simply using an authentication code or signature does not make an Interest secure. There are several examples in the literature on how to secure ICN-style messaging [mobile] [ace].",
      "ja": "CCNxメッセージフォーマットは、すべてのパケットタイプへのMIC（例えば、CRC32C）のMAC（例えば、HMAC）と署名（例えば、RSA又はECDSA）を添付する能力を含みます。それが計算DoS攻撃につながる可能性があるとして、任意のValidationAlgorithmを使用するように、またインタレストパケットにおける計算コストが高いアルゴリズムを含めることは良い考えであることを意味するものではありません。アプリケーションでは、パケット署名の使用を導くために、明示的なプロトコルを使用する必要があります。一般的なガイドラインとして、アプリケーションが意図せずに破損したパケットを検出するために、金利にMICを使用する場合があります。 1が興味を確保したい場合は、一つは金利がアクチュエータとして使用されている場合は特に、リプレイ攻撃を防ぐ暗号化されたラッパーとプロトコルを使用することを検討すべきです。単に認証コードを使用するか、署名は関心が安全なことはありません。 ICNスタイルのメッセージング[モバイル] [エース]を保護する方法に関する文献にはいくつかの例があります。"
    },
    {
      "indent": 3,
      "text": "As an L3 protocol, this document does not describe how one arrives at keys or how one trusts keys. The CCNx Content Object may include a public key or certificate embedded in the object or may use the KeyLink field to point to a public key or certificate that authenticates the message. One key-exchange specification is CCNxKE [ccnx-ke] [mobile], which is similar to the TLS 1.3 key exchange except it is over the CCNx L3 messages. Trust is beyond the scope of an L3 protocol and left to applications or application frameworks.",
      "ja": "L3プロトコルとして、この文書は、1つのキーで、またはどのように1つの信託キー到着する方法については説明しません。 CCNxコンテンツオブジェクトは、オブジェクトに埋め込まれた公開鍵または証明書を含んでもよく、またはメッセージを認証する公開鍵または証明書を指すようにKeyLinkフィールドを使用してもよいです。一鍵交換仕様はCCNxKE [ccnx-KE] [移動]、それはCCNx L3メッセージ上にある以外はTLS 1.3鍵交換と同様です。信頼は、L3プロトコルの範囲を超えてアプリケーションまたはアプリケーションフレームワークに任さ。"
    },
    {
      "indent": 3,
      "text": "The combination of an ephemeral key exchange (e.g., CCNxKE [ccnx-ke]) and an encapsulating encryption (e.g., [esic]) provides the equivalent of a TLS tunnel. Intermediate nodes may forward the Interests and Content Objects but have no visibility inside. It also completely hides the internal names in those used by the encryption layer. This type of tunneling encryption is useful for content that has little or no cacheability, as it can only be used by someone with the ephemeral key. Short-term caching may help with lossy links or mobility, but long-term caching is usually not of interest.",
      "ja": "短期キー交換（例えば、CCNxKE [ccnx-KE]）の組合せとカプセル化暗号化（例えば、[ESIC]）は、TLSトンネルの等価物を提供します。中間ノードは、興味やコンテンツオブジェクトを転送するが、内部には、視認性を有していなくてもよいです。また、完全に暗号化層で使用されるものでは内部名を隠します。トンネルの暗号化のこのタイプは、それが唯一の短期キーを持つ人で使用することができますように、ほとんど、あるいはまったくキャッシュ可能性を持っているコンテンツのために有用です。短期キャッシングは、非可逆リンクやモビリティを助けるかもしれないが、長期的なキャッシングは、関心のある通常ではありません。"
    },
    {
      "indent": 3,
      "text": "Broadcast encryption or proxy re-encryption may be useful for content with multiple uses over time or many consumers. There is currently no recommendation for this form of encryption.",
      "ja": "ブロードキャスト暗号化またはプロキシ再暗号化は、時間や多くの消費者の上に複数の用途を持つ内容のために有用である可能性があります。暗号化は、このフォームには勧告は現在ありません。"
    },
    {
      "indent": 3,
      "text": "The specific encoding of messages will have security implications. [RFC8609] uses a type-length-value (TLV) encoding. We chose to compromise between extensibility and unambiguous encodings of types and lengths. Some TLV encodings use variable-length \"T\" and variable-length \"L\" fields to accommodate a wide gamut of values while trying to be byte efficient. Our TLV encoding uses a fixed-length 2-byte \"T\" and 2-byte \"L\". Using a fixed-length \"T\" and \"L\" field solves two problems. The first is aliases. If one is able to encode the same value, such as %x02 and %x0002, in different byte lengths, then one must decide if they mean the same thing, if they are different, or if one is illegal. If they are different, then one must always compare on the buffers, not the integer equivalents. If one is illegal, then one must validate the TLV encoding, every field of every packet at every hop. If they are the same, then one has the second problem: how to specify packet filters. For example, if a name has 6 name components, then there are 7 T's and 7 L's, each of which might have up to 4 representations of the same value. That would be 14 fields with 4 encodings each, or 1001 combinations. It also means that one cannot compare, for example, a name via a memory function as one needs to consider that any embedded \"T\" or \"L\" might have a different format.",
      "ja": "メッセージの特定のエンコーディングはセキュリティに影響を持つことになります。 [RFC8609]はタイプレングス値（TLV）エンコーディングを使用します。私たちは、拡張性と種類と長さの明確なエンコーディングの間で妥協することにしました。バイト効率的になろうとしながら、いくつかTLVエンコーディングは、値の広い色域に対応するために、可変長「T」と可変長の「L」のフィールドを使用します。我々のTLVエンコーディングは固定長の2バイトの「T」と2バイトの「L」を使用します。固定長の「T」と「L」フィールドを使用すると、2つの問題を解決します。最初は別名です。 1が別のバイトの長さでは、このような％のX02と％x0002と、同じ値をエンコードすることができた場合、彼らは同じことを意味場合、彼らは異なっている場合は、1つは、決定しなければなりません、または1つが不正な場合。それらが異なる場合には、一つは、常にバッファ、ない整数当量を比較する必要があります。 1が違法である場合には、一つは、すべてのホップですべてのパケットのすべてのフィールドをTLVエンコーディングを検証する必要があります。それらが同じであれば、一つは第二の問題があります。パケットフィルタを指定する方法。名前は、6名の構成要素を有する場合、例えば、同じ値の最大4つの表現を有する可能性があるそれぞれが7 Tの7 L'sが存在します。すなわち、4つのエンコーディングそれぞれ、または1001の組み合わせで14のフィールドであろう。また、1は任意の埋め込まれた「T」または「L」は、異なるフォーマットを持っている可能性があることを考慮する必要があるように、1つのメモリ機能を経由して、例えば、名前を比較できないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The Interest Return message has no authenticator from the previous hop. Therefore, the payload of the Interest Return should only be used locally to match an Interest. A node should never forward that",
      "ja": "インタレストリターンメッセージは、前のホップからのオーセンティケータを持っていません。したがって、金利リターンのペイロードにのみ関心を一致させるためにローカルに使用する必要があります。ノードはそれを転送することはありません"
    },
    {
      "indent": 3,
      "text": "Interest Payload as an Interest. It should also verify that it sent the Interest in the Interest Return to that node and not allow anyone to negate Interest messages.",
      "ja": "利息として利息ペイロード。また、それは、そのノードへの関心の戻りに興味を送信し、誰もが興味メッセージを否定することはできませいることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Caching nodes must take caution when processing Content Objects. It is essential that the Content Store obey the rules outlined in Section 2.4.3 to avoid certain types of attacks. CCNx 1.0 has no mechanism to work around an undesired result from the network (there are no \"excludes\"), so if a cache becomes poisoned with bad content, it might cause problems retrieving content. There are three types of access to content from a Content Store: unrestricted, signature restricted, and hash restricted. If an Interest has no restrictions, then the requester is not particular about what they get back, so any matching cached object is OK. In the hash-restricted case, the requester is very specific about what they want and the Content Store (and every forward hop) can easily verify that the content matches the request. In the signature-restricted case (often used for initial manifest discovery), the requester only knows the KeyId that signed the content. It is this case that requires the closest attention in the Content Store to avoid amplifying bad data. The Content Store must only respond with a Content Object if it can verify the signature; this means either the Content Object carries the public key inside it or the Interest carries the public key in addition to the KeyId. If that is not the case, then the Content Store should treat the Interest as a cache miss and let an endpoint respond.",
      "ja": "コンテンツオブジェクトを処理するときにキャッシングノードは注意を取る必要があります。コンテンツストアがあるタイプの攻撃を避けるために、セクション2.4.3に概説されたルールに従うことが不可欠です。 CCNx 1.0は（ない「除外」は存在しない）ネットワークからの望ましくない結果を回避するための機構がないので、キャッシュが悪い内容で毒になった場合、それがコンテンツを取得する問題が発生する可能性があります。制限無制限、制限された署名、ハッシュ：コンテンツストアからコンテンツへのアクセスの3つのタイプがあります。利息は制限はありません場合は、依頼者は、彼らが戻って得るかについて特にありませんので、任意のマッチング、キャッシュされたオブジェクトはOKです。ハッシュ制限の場合、要求者は、彼らが望むものについて非常に特異的であり、かつコンテンツストア（およびすべての前方ホップ）を容易にコンテンツが要求と一致することを確認することができます。 （しばしば初期マニフェスト発見のために使用される）署名拘束場合、要求者は、コンテンツに署名した鍵IDを知っています。これは、不良データを増幅避けるために、コンテンツストアに細心の注意が必要です。このケースです。それは署名を検証することができた場合、コンテンツストアにのみコンテンツオブジェクトで応答しなければなりません。これは意味のいずれかのコンテンツオブジェクトは、内部の公開鍵を運ぶか、関心が鍵IDに加えて、公開鍵を運びます。それがない場合は、コンテンツストアは、キャッシュミスなどの対象を治療し、エンドポイントの応答をさせてください。"
    },
    {
      "indent": 3,
      "text": "A user-level cache could perform full signature verification by fetching a public key or certificate according to the KeyLink. That is not, however, a burden we wish to impose on the forwarder. A user-level cache could also rely on out-of-band attestation, such as the cache operator only inserting content that it knows has the correct signature.",
      "ja": "ユーザーレベルのキャッシュはKeyLinkに係る公開鍵または証明書を取得することによって、完全な署名検証を実行することができます。それは、しかし、我々はフォワーダに課すしたい重荷ではありません。ユーザーレベルのキャッシュはまた、キャッシュ・オペレータのみが正しい署名を有する知っているコンテンツを挿入するように、アウトオブバンド認証に頼ることができます。"
    },
    {
      "indent": 3,
      "text": "The CCNx grammar allows for hash-algorithm agility via the HashType. It specifies a short list of acceptable hash algorithms that should be implemented at each forwarder. Some hash values only apply to end systems, so updating the hash algorithm does not affect forwarders; they would simply match the buffer that includes the type-length-hash buffer. Some fields, such as the ConObjHash, must be verified at each hop, so a forwarder (or related system) must know the hash algorithm; it could cause backward compatibility problems if the hash type is updated. [RFC8609] is the authoritative source for per-field-allowed hash types in that encoding.",
      "ja": "CCNx文法はHashTypeを経由して、ハッシュ・アルゴリズムの機敏性を可能にします。これは、各フォワーダに実装されるべき許容されるハッシュアルゴリズムの短いリストを指定します。いくつかのハッシュ値のみがシステムを終了するには適用され、そのハッシュアルゴリズムを更新するフォワーダには影響を与えません。彼らは単にタイプ長ハッシュバッファを含むバッファにマッチします。例えばConObjHashのようないくつかのフィールドは、各ホップで検証されなければならないので、フォワーダ（又は関連するシステム）がハッシュアルゴリズムを知っていなければなりません。ハッシュタイプが更新される場合には、下位互換性の問題を引き起こす可能性があります。 [RFC8609]は、その符号化でごとフィールド許容ハッシュタイプの信頼できるソースです。"
    },
    {
      "indent": 3,
      "text": "A CCNx name uses binary matching whereas a URI uses a case-insensitive hostname. Some systems may also use case-insensitive matching of the URI path to a resource. An implication of this is that human-entered CCNx names will likely have case or non-ASCII symbol mismatches unless one uses a consistent URI normalization to the CCNx name. It also means that an entity that registers a CCNx routable prefix, say \"ccnx:/example.com\", would need separate registrations for simple variations like \"ccnx:/Example.com\". Unless this is addressed in URI normalization and routing protocol conventions, there could be phishing attacks.",
      "ja": "URIは、大文字と小文字を区別しないホスト名を使用するのに対し、CCNx名はバイナリマッチングを使用します。いくつかのシステムは、リソースへのURIパスの大文字と小文字を区別しないマッチングを使用することができます。これの意味するところは、1がCCNx名に一貫性のあるURIの正規化を使用しない限り、人間が入力したCCNx名の可能性が高い場合や非ASCII記号ミスマッチを有するということです。また、CCNxルーティング可能な接頭辞を登録するエンティティは、「ccnx：/example.com」と言うことを意味し、「：/Example.com ccnx」のような単純なバリエーションのための個別の登録が必要になります。これは、URI正規化およびルーティングプロトコルの規則で対処されていない限り、フィッシング攻撃がある可能性があります。"
    },
    {
      "indent": 3,
      "text": "For a more general introduction to ICN-related security concerns and approaches, see [RFC7927] and [RFC7945].",
      "ja": "ICN関連のセキュリティ問題とアプローチに、より一般的な概要については、[RFC7927]及び[RFC7945]を参照。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ace] Shang, W., Yu, Y., Liang, T., Zhang, B., and L. Zhang, \"NDN-ACE: Access Control for Constrained Environments over Named Data Networking\", NDN Technical Report NDN-0036, December 2015, <http://new.named-data.net/ wp-content/uploads/2015/12/ndn-0036-1-ndn-ace.pdf>.",
      "ja": "[ACE]シャン、W.、ゆう、Y.、梁、T.、張、B.、およびL.チャン、 \"NDN-ACE：名前付きデータネットワーキング以上の制約のある環境のためのアクセス制御\"、NDNテクニカルレポートNDN-0036 、2015年12月、<http://new.named-data.net/のwp-コンテンツ/アップロード/ 12分の2015 / NDN-0036から1-NDN-ace.pdf>。"
    },
    {
      "indent": 3,
      "text": "[befrags] Mosko, M. and C. Tschudin, \"ICN \"Begin-End\" Hop by Hop Fragmentation\", Work in Progress, draft-mosko-icnrg-beginendfragment-02, December 2016.",
      "ja": "[befrags] Mosko、M.とC. Tschudinは、 \"ICNは、 \"開始・終了\" ホップフラグメンテーションによってホップ\"、作業を進行中、ドラフトmosko-icnrg-beginendfragment-02、2016年12月。"
    },
    {
      "indent": 3,
      "text": "[ccn-lite] Tschudin, C., et al., \"CCN-lite\", University of Basel, 2011-2019, <http://ccn-lite.net>.",
      "ja": "[CCN-LITE] Tschudin、C.、ら、 \"CCN-LITE\"、バーゼル、2011-2019大学、<http://ccn-lite.net>。"
    },
    {
      "indent": 3,
      "text": "[ccnx-ke] Mosko, M., Uzun, E., and C. Wood, \"CCNx Key Exchange Protocol Version 1.0\", Work in Progress, draft-wood-icnrg-ccnxkeyexchange-02, March 2017.",
      "ja": "[ccnx-KE] Mosko、M.、ウズン、E.、およびC.ウッド、 \"CCNx鍵交換プロトコルバージョン1.0\"、進捗状況、ドラフト・木材icnrg-ccnxkeyexchange-02、2017年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[ccnx-registry] IANA, \"Content-Centric Networking (CCNx)\", <https://www.iana.org/assignments/ccnx>.",
      "ja": "[ccnx-レジストリ] IANA、 \"コンテンツ中心ネットワーク（CCNx）\"、<https://www.iana.org/assignments/ccnx>。"
    },
    {
      "indent": 3,
      "text": "[ccnx-uri] Mosko, M. and C. Wood, \"The CCNx URI Scheme\", Work in Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016.",
      "ja": "[ccnx-URI] Mosko、M.とC.ウッド、 \"CCNx URIスキーム\" 進行中、仕事、ドラフトmosko-icnrg-ccnxurischeme-01、2016年4月。"
    },
    {
      "indent": 3,
      "text": "[chunking] Mosko, M., \"CCNx Content Object Chunking\", Work in Progress, draft-mosko-icnrg-ccnxchunking-02, June 2016.",
      "ja": "Mosko、M.、 \"CCNxコンテンツオブジェクトチャンキング\"、進捗状況、ドラフトmosko-icnrg-ccnxchunking-02、2016年6月で仕事を[チャンキング]。"
    },
    {
      "indent": 3,
      "text": "[cicn] FD.io, \"Community ICN (CICN)\", February 2017, <https://wiki.fd.io/index.php?title=Cicn&oldid=7191>.",
      "ja": "【cicn] FD.io、 \"コミュニティICN（CICN）\"、2017年2月、<https://wiki.fd.io/index.php?title=Cicn&oldid=7191>。"
    },
    {
      "indent": 3,
      "text": "[dart] Garcia-Luna-Aceves, J. and M. Mirzazad-Barijough, \"A Light-Weight Forwarding Plane for Content-Centric Networks\", International Conference on Computing, Networking, and Communications (ICNC), DOI 10.1109/ICCNC.2016.7440637, February 2016, <https://arxiv.org/pdf/1603.06044.pdf>.",
      "ja": "【ダーツ】ガルシア - ルナ -  ACEVES、J.とM. Mirzazad-Barijough、 \"コンテンツ中心ネットワークのための軽量フォワーディングプレーン\"、コンピューティング、ネットワーキング、および通信に関する国際会議（ICNC）、DOI 10.1109 / ICCNC。 2016.7440637、2016年2月、<https://arxiv.org/pdf/1603.06044.pdf>。"
    },
    {
      "indent": 3,
      "text": "[eprise-numbers] IANA, \"IANA Private Enterprise Numbers\", <https://www.iana.org/assignments/enterprise-numbers>.",
      "ja": "[eprise-番号] IANA、 \"IANA民間企業番号\"、<https://www.iana.org/assignments/enterprise-numbers>。"
    },
    {
      "indent": 3,
      "text": "[esic] Mosko, M. and C. Wood, \"Encrypted Sessions In CCNx (ESIC)\", Work in Progress, draft-wood-icnrg-esic-01, September 2017.",
      "ja": "【ESIC] Mosko、M.とC.ウッド、 \"CCNxで暗号化セッション（ESIC）\"、進行中で働いて、ドラフト木材icnrg-ESIC-01、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[flic] Tschudin, C. and C. Wood, \"File-Like ICN Collection (FLIC)\", Work in Progress, draft-tschudin-icnrg-flic-03, March 2017.",
      "ja": "[フリック] Tschudin、C.およびC.ウッド、 \"ファイルのようなICNコレクション（FLIC）\"、進捗状況、ドラフトtschudin-icnrg-フリック-03、2017年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[mobile] Mosko, M., Uzun, E., and C. Wood, \"Mobile Sessions in Content-Centric Networks\", IFIP Networking Conference (IFIP Networking) and Workshops, DOI 10.23919/IFIPNetworking.2017.8264861, June 2017, <https://dl.ifip.org/db/conf/networking/ networking2017/1570334964.pdf>.",
      "ja": "【モバイル】Mosko、M.、ウズン、E.、およびC.ウッド、 \"コンテンツ中心ネットワークにおけるモバイルセッション\"、IFIPネットワーク会議（IFIPネットワーク）とワークショップ、DOI 10.23919 / IFIPNetworking.2017.8264861、2017年6月、<HTTPS ：//dl.ifip.org/db/conf/networking/ networking2017 / 1570334964.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ndn] UCLA, \"Named Data Networking\", 2019, <https://www.named-data.net>.",
      "ja": "[NDN] UCLAは、2019年、<https://www.named-data.net> \"データネットワーキング名前\"。"
    },
    {
      "indent": 3,
      "text": "[nnc] Jacobson, V., Smetters, D., Thornton, J., Plass, M., Briggs, N., and R. Braynard, \"Networking Named Content\", Proceedings of the 5th International Conference on Emerging Networking Experiments and Technologies, DOI 10.1145/1658939.1658941, December 2009, <https://dx.doi.org/10.1145/1658939.1658941>.",
      "ja": "[NNC]ジェーコブソン、V.、Smetters、D.、ソーントン、J.、Plass、M.、ブリッグス、N.、およびR. Braynard、 \"名前付きコンテンツをネットワーク\"、新興ネットワーク実験の第5回国際会議の議事録と・テクノロジーズ、DOI 10.1145 / 1658939.1658941、2009年12月、<https://dx.doi.org/10.1145/1658939.1658941>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<https://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC7927] Kutscher, D., Ed., Eum, S., Pentikousis, K., Psaras, I., Corujo, D., Saucez, D., Schmidt, T., and M. Waehlisch, \"Information-Centric Networking (ICN) Research Challenges\", RFC 7927, DOI 10.17487/RFC7927, July 2016, <https://www.rfc-editor.org/info/rfc7927>.",
      "ja": "[RFC7927] Kutscher、D.、編、EUM、S.、Pentikousis、K.、Psaras、I.、Corujo、D.、Saucez、D.、シュミット、T。、およびM.Wählisch、「情報中心ネットワーク（ICN）研究課題」、RFC 7927、DOI 10.17487 / RFC7927、2016年7月、<https://www.rfc-editor.org/info/rfc7927>。"
    },
    {
      "indent": 3,
      "text": "[RFC7945] Pentikousis, K., Ed., Ohlman, B., Davies, E., Spirou, S., and G. Boggia, \"Information-Centric Networking: Evaluation and Security Considerations\", RFC 7945, DOI 10.17487/RFC7945, September 2016, <https://www.rfc-editor.org/info/rfc7945>.",
      "ja": "[RFC7945] Pentikousis、K.、エド、Ohlman、B.、デイビス、E.、Spirou、S.、およびG. Boggia、 \"情報セントリックネットワーク：評価およびセキュリティの考慮事項\"、RFC 7945、DOI 10.17487 / RFC7945 、2016年9月、<https://www.rfc-editor.org/info/rfc7945>。"
    },
    {
      "indent": 3,
      "text": "[RFC8609] Mosko, M., Solis, I., and C. Wood, \"Content-Centric Networking (CCNx) Messages in TLV Format\", RFC 8609, DOI 10.17487/RFC8609, July 2019, <https://www.rfc-editor.org/info/rfc8609>.",
      "ja": "[RFC8609] Mosko、M.、ソリス、I.、およびC.ウッド、 \"コンテンツ中心ネットワーク（CCNx）TLV形式のメッセージ\"、RFC 8609、DOI 10.17487 / RFC8609、2019年7月、<https：//でWWW。 rfc-editor.org/info/rfc8609>。"
    },
    {
      "indent": 3,
      "text": "[selectors] Mosko, M., \"CCNx Selector Based Discovery\", Work in Progress, draft-mosko-icnrg-selectors-01, May 2019.",
      "ja": "[セレクタ] Mosko、M.、 \"CCNxセレクタベースの検出\" が進行中で働いて、ドラフトmosko-icnrg-セレクタ-01、2019月。"
    },
    {
      "indent": 3,
      "text": "[terminology] Wissingh, B., Wood, C., Afanasyev, A., Zhang, L., Oran, D., and C. Tschudin, \"Information-Centric Networking (ICN): CCN and NDN Terminology\", Work in Progress, draft-irtf-icnrg-terminology-04, June 2019.",
      "ja": "[用語] Wissingh、B.、木材、C.、Afanasyev、A.、チャン、L.、オラン、D.、およびC. Tschudin、 \"情報セントリックネットワーク（ICN）：CCNとNDN用語\"、仕事に進捗状況、ドラフトIRTF-icnrg-用語-04、2019年6月。"
    },
    {
      "indent": 3,
      "text": "[trust] Tschudin, C., Uzun, E., and C. Wood, \"Trust in Information-Centric Networking: From Theory to Practice\", 25th International Conference on Computer Communication and Networks (ICCCN), DOI 10.1109/ICCCN.2016.7568589, August 2016, <https://doi.org/10.1109/ICCCN.2016.7568589>.",
      "ja": "[信頼] Tschudin、C.、ウズン、E.、およびC.ウッド、「情報中心のネットワークで信頼：理論から実践へ」、コンピュータ通信およびネットワーク（ICCCN）の第25回国際会議、DOI 10.1109 / ICCCN.2016.7568589 、2016年8月、<https://doi.org/10.1109/ICCCN.2016.7568589>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Marc Mosko PARC, Inc. Palo Alto, California 94304 United States of America",
      "ja": "マルク・Mosko PARC社、カリフォルニア州パロアルトアメリカの94304米国"
    },
    {
      "indent": 3,
      "text": "Phone: +01 650-812-4405 Email: marc.mosko@parc.com",
      "ja": "電話：+01 650-812-4405 Eメール：marc.mosko@parc.com"
    },
    {
      "indent": 3,
      "text": "Ignacio Solis LinkedIn Mountain View, California 94043 United States of America",
      "ja": "イグナシオ・ソリスLinkedInのアメリカのマウンテンビュー、カリフォルニア94043米国"
    },
    {
      "indent": 3,
      "text": "Email: nsolis@linkedin.com",
      "ja": "メール：nsolis@linkedin.com"
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood University of California Irvine Irvine, California 92697 United States of America",
      "ja": "クリストファー・A.ウッドカリフォルニア州アーヴァイン、カリフォルニアの大学アメリカの92697米国"
    },
    {
      "indent": 3,
      "text": "Phone: +01 315-806-5939 Email: woodc1@uci.edu",
      "ja": "電話：+01 315-806-5939 Eメール：woodc1@uci.edu"
    }
  ]
}