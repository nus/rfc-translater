{
  "title": {
    "text": "RFC 8229 - TCP Encapsulation of IKE and IPsec Packets",
    "ja": "RFC 8229 - IKEおよびIPSecパケットのTCPカプセル化"
  },
  "number": 8229,
  "created_at": "2019-10-27 04:52:38.717945+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          T. Pauly\nRequest for Comments: 8229                                    Apple Inc.\nCategory: Standards Track                                      S. Touati\nISSN: 2070-1721                                                 Ericsson\n                                                               R. Mantha\n                                                           Cisco Systems\n                                                             August 2017",
      "raw": true
    },
    {
      "indent": 15,
      "text": "TCP Encapsulation of IKE and IPsec Packets",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a method to transport Internet Key Exchange Protocol (IKE) and IPsec packets over a TCP connection for traversing network middleboxes that may block IKE negotiation over UDP. This method, referred to as \"TCP encapsulation\", involves sending both IKE packets for Security Association establishment and Encapsulating Security Payload (ESP) packets over a TCP connection. This method is intended to be used as a fallback option when IKE cannot be negotiated over UDP.",
      "ja": "この文書では、UDP上でIKEネゴシエーションをブロックすることができるネットワークミドルボックスを横断するためのTCP接続を介してインターネット鍵交換プロトコル（IKE）とIPsecパケットを転送する方法を説明しています。この方法は、「TCPカプセル化」と呼ばれ、TCP接続を介してセキュリティアソシエーションの確立のためのIKEパケットとカプセル化セキュリティペイロード（ESP）パケットの両方を送信することが含まれます。このメソッドは、IKEは、UDP上で交渉することはできませんフォールバックオプションとして使用されることを意図しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8229.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8229で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Prior Work and Motivation ..................................4\n   1.2. Terminology and Notation ...................................5\n2. Configuration ...................................................5\n3. TCP-Encapsulated Header Formats .................................6\n   3.1. TCP-Encapsulated IKE Header Format .........................6\n   3.2. TCP-Encapsulated ESP Header Format .........................7\n4. TCP-Encapsulated Stream Prefix ..................................7\n5. Applicability ...................................................8\n   5.1. Recommended Fallback from UDP ..............................8\n6. Connection Establishment and Teardown ...........................9\n7. Interaction with NAT Detection Payloads ........................11\n8. Using MOBIKE with TCP Encapsulation ............................11\n9. Using IKE Message Fragmentation with TCP Encapsulation .........12\n10. Considerations for Keep-Alives and Dead Peer Detection ........12\n11. Middlebox Considerations ......................................12\n12. Performance Considerations ....................................13\n   12.1. TCP-in-TCP ...............................................13\n   12.2. Added Reliability for Unreliable Protocols ...............14\n   12.3. Quality-of-Service Markings ..............................14\n   12.4. Maximum Segment Size .....................................14\n   12.5. Tunneling ECN in TCP .....................................14\n13. Security Considerations .......................................15\n14. IANA Considerations ...........................................16\n15. References ....................................................16\n   15.1. Normative References .....................................16\n   15.2. Informative References ...................................17",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix A. Using TCP Encapsulation with TLS ......................18\nAppendix B. Example Exchanges of TCP Encapsulation with TLS .......19\n  B.1. Establishing an IKE Session ................................19\n  B.2. Deleting an IKE Session ....................................21\n  B.3. Re-establishing an IKE Session .............................22\n  B.4. Using MOBIKE between UDP and TCP Encapsulation .............23\nAcknowledgments ...................................................25\nAuthors' Addresses ................................................25",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Internet Key Exchange Protocol version 2 (IKEv2) [RFC7296] is a protocol for establishing IPsec Security Associations (SAs), using IKE messages over UDP for control traffic, and using Encapsulating Security Payload (ESP) [RFC4303] messages for encrypted data traffic. Many network middleboxes that filter traffic on public hotspots block all UDP traffic, including IKE and IPsec, but allow TCP connections through because they appear to be web traffic. Devices on these networks that need to use IPsec (to access private enterprise networks, to route Voice over IP calls to carrier networks, or because of security policies) are unable to establish IPsec SAs. This document defines a method for encapsulating IKE control messages as well as IPsec data messages within a TCP connection.",
      "ja": "インターネット鍵交換プロトコルバージョン2（IKEv2の）[RFC7296]、IPsecセキュリティアソシエーション（SA）を確立する制御トラフィック用のUDP上でIKEメッセージを使用して、暗号化データトラフィックのためにカプセル化セキュリティペイロード（ESP）[RFC4303]メッセージを使用するためのプロトコルであります。公共のホットスポットでのフィルタトラフィック多くのネットワークミドルボックスは、IKEおよびIPsecを含め、すべてのUDPトラフィックをブロックするが、彼らはWebトラフィックのように見えるのでを通じてTCP接続を許可します。 IPsecを使用する必要がこれらのネットワーク上のデバイス（IP経由のルートの音声にプライベート企業ネットワークにアクセスするためには、キャリアネットワークの呼び出し、またはためのセキュリティポリシーの）はIPsecのSAを確立することはできません。この文書では、TCP接続内IKE制御メッセージと同様のIPsecデータメッセージをカプセル化するための方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Using TCP as a transport for IPsec packets adds a third option to the list of traditional IPsec transports:",
      "ja": "IPsecパケットのトランスポートとしてTCPを使用することで、従来のIPsecのトランスポートのリストに第三の選択肢を追加します。"
    },
    {
      "indent": 3,
      "text": "1. Direct. Currently, IKE negotiations begin over UDP port 500. If no Network Address Translation (NAT) device is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 500, and IPsec data packets are sent using ESP.",
      "ja": "1.直接。何のネットワークアドレス変換（NAT）デバイスは、イニシエータとレスポンダの間で検出されない場合は、現在、IKEネゴシエーションはUDPポート500上で開始し、その後のIKEパケットは、UDPポート500を介して送信され、およびIPsecデータパケットはESPを使用して送信されます。"
    },
    {
      "indent": 3,
      "text": "2. UDP Encapsulation [RFC3948]. If a NAT is detected between the Initiator and the Responder, then subsequent IKE packets are sent over UDP port 4500 with four bytes of zero at the start of the UDP payload, and ESP packets are sent out over UDP port 4500. Some peers default to using UDP encapsulation even when no NAT is detected on the path, as some middleboxes do not support IP protocols other than TCP and UDP.",
      "ja": "2. UDPカプセル化[RFC3948]。 NATは、イニシエータとレスポンダの間で検出された場合、その後のIKEパケットはUDPペイロードの開始時にゼロの4バイトでUDPポート4500を介して送信され、ESPパケットはUDPポート4500上にいくつかのピアのデフォルトを送出しますいくつかのミドルボックスは、TCPおよびUDP以外のIPプロトコルをサポートしていないとして、何のNATがパスで検出されない場合でも、UDPカプセル化を使用しました。"
    },
    {
      "indent": 3,
      "text": "3. TCP Encapsulation. If the other two methods are not available or appropriate, IKE negotiation packets as well as ESP packets can be sent over a single TCP connection to the peer.",
      "ja": "3. TCPカプセル化。他の2つの方法が利用できるか、適切でない場合は、IKEネゴシエーションパケットだけでなく、ESPパケットは、ピアへの単一のTCP接続を介して送信することができます。"
    },
    {
      "indent": 3,
      "text": "Direct use of ESP or UDP encapsulation should be preferred by IKE implementations due to performance concerns when using TCP encapsulation (Section 12). Most implementations should use TCP encapsulation only on networks where negotiation over UDP has been attempted without receiving responses from the peer or if a network is known to not support UDP.",
      "ja": "ESPまたはUDPカプセル化の直接の使用はTCPカプセル化（第12節）を使用して、パフォーマンス上の問題のためにIKEの実装によって好まれるべきです。ほとんどの実装はUDP上の交渉がピアからの応答を受信することなく、またはネットワークがUDPをサポートしていないことが知られている場合が試みられているネットワーク上のTCPカプセル化を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Prior Work and Motivation",
      "section_title": true,
      "ja": "1.1。先行研究とモチベーション"
    },
    {
      "indent": 3,
      "text": "Encapsulating IKE connections within TCP streams is a common approach to solve the problem of UDP packets being blocked by network middleboxes. The specific goals of this document are as follows:",
      "ja": "TCP内IKE接続をカプセル化すると、ネットワークのミドルボックスによってブロックされるUDPパケットの問題を解決するための一般的なアプローチであるストリーム。次のように、この文書の具体的な目標は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o To promote interoperability by defining a standard method of framing IKE and ESP messages within TCP streams.",
      "ja": "TCPストリーム内のIKEとESPメッセージをフレーミングする標準的な方法を定義することで、相互運用性を促進するために、O。"
    },
    {
      "indent": 3,
      "text": "o To be compatible with the current IKEv2 standard without requiring modifications or extensions.",
      "ja": "修正または拡張を必要とせずに現在のIKEv2規格と互換性があるように、O。"
    },
    {
      "indent": 3,
      "text": "o To use IKE over UDP by default to avoid the overhead of other alternatives that always rely on TCP or Transport Layer Security (TLS) [RFC5246].",
      "ja": "oは常にTCPまたはトランスポート層セキュリティ（TLS）[RFC5246]に依存する他の選択肢のオーバーヘッドを回避するために、デフォルトではUDP上でIKEを使用します。"
    },
    {
      "indent": 3,
      "text": "Some previous alternatives include:",
      "ja": "いくつかの以前の選択肢が含まれます："
    },
    {
      "indent": 3,
      "text": "Cellular Network Access Interworking Wireless LAN (IWLAN) uses IKEv2 to create secure connections to cellular carrier networks for making voice calls and accessing other network services over Wi-Fi networks. 3GPP has recommended that IKEv2 and ESP packets be sent within a TLS connection to be able to establish connections on restrictive networks.",
      "ja": "セルラーネットワークアクセスインターワーキング無線LAN（IWLAN）は、音声通話を行うとWi-Fiネットワークを介して他のネットワークサービスにアクセスするための携帯キャリアネットワークへの安全な接続を作成するためのIKEv2を使用しています。 3GPPは、IKEv2のとESPパケットが制限ネットワーク上で接続を確立できるようにするTLS接続内で送信することを推奨しています。"
    },
    {
      "indent": 3,
      "text": "ISAKMP over TCP Various non-standard extensions to the Internet Security Association and Key Management Protocol (ISAKMP) have been deployed that send IPsec traffic over TCP or TCP-like packets.",
      "ja": "インターネットSecurity AssociationとKey Managementプロトコル（ISAKMP）へのTCP上のISAKMP様々な非標準の拡張機能は、TCPまたはTCPのようなパケット上のIPsecトラフィックを送信すること配備されています。"
    },
    {
      "indent": 3,
      "text": "Secure Sockets Layer (SSL) VPNs Many proprietary VPN solutions use a combination of TLS and IPsec in order to provide reliability. These often run on TCP port 443.",
      "ja": "セキュア・ソケット・レイヤーは、（SSL）VPNの多くは独自のVPNソリューションは、信頼性を提供するために、TLSとIPsecを組み合わせて使用​​します。これらは、多くの場合、TCPポート443上で実行します。"
    },
    {
      "indent": 3,
      "text": "IKEv2 over TCP IKEv2 over TCP as described in [IKE-over-TCP] is used to avoid UDP fragmentation.",
      "ja": "[IKEオーバーTCP]に記載されているようにTCP上のTCPのIKEv2上のIKEv2は、UDPの断片化を回避するために使用されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology and Notation",
      "section_title": true,
      "ja": "1.2。用語と表記"
    },
    {
      "indent": 3,
      "text": "This document distinguishes between the IKE peer that initiates TCP connections to be used for TCP encapsulation and the roles of Initiator and Responder for particular IKE messages. During the course of IKE exchanges, the role of IKE Initiator and Responder may swap for a given SA (as with IKE SA rekeys), while the Initiator of the TCP connection is still responsible for tearing down the TCP connection and re-establishing it if necessary. For this reason, this document will use the term \"TCP Originator\" to indicate the IKE peer that initiates TCP connections. The peer that receives TCP connections will be referred to as the \"TCP Responder\". If an IKE SA is rekeyed one or more times, the TCP Originator MUST remain the peer that originally initiated the first IKE SA.",
      "ja": "このドキュメントでは、TCPのカプセル化および特定のIKEメッセージのイニシエータとレスポンダの役割に使用するTCP接続を開始IKEピアが区別されます。 TCPコネクションのイニシエータは、まだTCPコネクションを切断している場合、それを再確立する責任がありながら、IKE交換の過程で、IKEイニシエータとレスポンダの役割は、（IKE SAのキー更新と同じように）与えられたSAのために交換可能必要。このため、このドキュメントは、TCP接続を開始IKEピアを示すために、用語「TCPの発信」を使用します。 TCPコネクションを受け取るピアは、「TCPレスポンダ」と呼ぶことにします。 IKE SAを1回以上再 - 合わせされている場合は、TCPの発信者は、もともと最初のIKE SAを開始したピアでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2. Configuration",
      "section_title": true,
      "ja": "2.構成"
    },
    {
      "indent": 3,
      "text": "One of the main reasons to use TCP encapsulation is that UDP traffic may be entirely blocked on a network. Because of this, support for TCP encapsulation is not specifically negotiated in the IKE exchange. Instead, support for TCP encapsulation must be pre-configured on both the TCP Originator and the TCP Responder.",
      "ja": "TCPカプセル化を使用する主な理由の一つは、UDPトラフィックを完全にネットワーク上でブロックすることができるということです。このため、TCPのカプセル化のためのサポートは、具体的IKE交換で交渉されていません。代わりに、TCPのカプセル化のためのサポートは、TCP発信し、TCPレスポンダの両方で事前に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support TCP encapsulation on TCP port 4500, which is reserved for IPsec NAT traversal.",
      "ja": "実装は、IPsec NATトラバーサルのために予約されているTCPポート4500上でTCPカプセル化をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Beyond a flag indicating support for TCP encapsulation, the configuration for each peer can include the following optional parameters:",
      "ja": "TCPカプセル化のためのサポートを示すフラグを超え、各ピアのコンフィギュレーションは、以下のオプションのパラメータを含むことができます。"
    },
    {
      "indent": 3,
      "text": "o Alternate TCP ports on which the specific TCP Responder listens for incoming connections. Note that the TCP Originator may initiate TCP connections to the TCP Responder from any local port.",
      "ja": "特定のTCP Responderが着信接続をリッスンする代替TCPポートO。 TCP発信者が任意のローカルポートからTCPレスポンダへのTCP接続を開始することができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o An extra framing protocol to use on top of TCP to further encapsulate the stream of IKE and IPsec packets. See Appendix A for a detailed discussion.",
      "ja": "さらにIKEとIPsecパケットのストリームをカプセル化するために、TCPの上で使用するために余分なフレーミングプロトコルO。詳細な議論については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Since TCP encapsulation of IKE and IPsec packets adds overhead and has potential performance trade-offs compared to direct or UDP-encapsulated SAs (as described in Section 12), implementations SHOULD prefer ESP direct or UDP-encapsulated SAs over TCP-encapsulated SAs when possible.",
      "ja": "IKEとIPsecパケットのTCPカプセル化がオーバーヘッド追加し、（項12に記載のように）SAを直接的またはUDPカプセル化と比較して潜在的なパフォーマンスのトレードオフを有しているので、可能な場合、実装は、TCPカプセル化のSA上ESP直接またはUDPカプセル化SAを好むべきです。"
    },
    {
      "indent": 0,
      "text": "3. TCP-Encapsulated Header Formats",
      "section_title": true,
      "ja": "3. TCPカプセル化ヘッダー形式"
    },
    {
      "indent": 3,
      "text": "Like UDP encapsulation, TCP encapsulation uses the first four bytes of a message to differentiate IKE and ESP messages. TCP encapsulation also adds a Length field to define the boundaries of messages within a stream. The message length is sent in a 16-bit field that precedes every message. If the first 32 bits of the message are zeros (a non-ESP marker), then the contents comprise an IKE message. Otherwise, the contents comprise an ESP message. Authentication Header (AH) messages are not supported for TCP encapsulation.",
      "ja": "UDPカプセル化と同様に、TCPのカプセル化は、IKEとESPメッセージを区別するために、メッセージの最初の4つのバイトを使用しています。 TCPカプセル化は、ストリーム内でメッセージの境界を定義するために長さフィールドを追加します。メッセージ長は、すべてのメッセージに先行する16ビットのフィールドで送信されます。メッセージの最初の32ビットがゼロ（非ESPマーカー）である場合、コンテンツは、IKEメッセージを含みます。そうでなければ、内容はESPメッセージを含んでいます。認証ヘッダー（AH）のメッセージは、TCPカプセル化のためにサポートされていません。"
    },
    {
      "indent": 3,
      "text": "Although a TCP stream may be able to send very long messages, implementations SHOULD limit message lengths to typical UDP datagram ESP payload lengths. The maximum message length is used as the effective MTU for connections that are being encrypted using ESP, so the maximum message length will influence characteristics of inner connections, such as the TCP Maximum Segment Size (MSS).",
      "ja": "TCPストリームは非常に長いメッセージを送信することができるかもしれないが、実装は、メッセージは、典型的なUDPデータグラムESPペイロードの長さに長制限する必要があります。メッセージの最大長は、ESPを使用して暗号化されている接続のための有効なMTUとして使用されるので、メッセージの最大長は、TCP最大セグメントサイズ（MSS）のような内部接続の特性に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Note that this method of encapsulation will also work for placing IKE and ESP messages within any protocol that presents a stream abstraction, beyond TCP.",
      "ja": "カプセル化のこの方法はまた、TCPを超えて、ストリームの抽象化を提供する任意のプロトコル内でIKEとESPメッセージを配置するために働くことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.1. TCP-Encapsulated IKE Header Format",
      "section_title": true,
      "ja": "3.1。 TCPカプセル化IKEヘッダー形式"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Non-ESP Marker                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                      IKE header [RFC7296]                     ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The IKE header is preceded by a 16-bit Length field in network byte order that specifies the length of the IKE message (including the non-ESP marker) within the TCP stream. As with IKE over UDP port 4500, a zeroed 32-bit non-ESP marker is inserted before the start of the IKE header in order to differentiate the traffic from ESP traffic between the same addresses and ports.",
      "ja": "IKEヘッダは、TCPストリーム内（非ESPマーカーを含む）IKEメッセージの長さを指定するネットワークバイト順に16ビット長のフィールドが先行します。 UDPポート4500上IKEと同様に、ゼロの32ビット非ESPマーカーが同じアドレスとポート間のESPトラフィックからのトラフィックを区別するためにIKEヘッダの開始前に挿入されます。"
    },
    {
      "indent": 3,
      "text": "o Length (2 octets, unsigned integer) - Length of the IKE packet, including the Length field and non-ESP marker.",
      "ja": "O長（2つのオクテットの符号なし整数） -  IKEパケットの長さ、長さフィールドおよび非ESPマーカーを含みます。"
    },
    {
      "indent": 0,
      "text": "3.2. TCP-Encapsulated ESP Header Format",
      "section_title": true,
      "ja": "3.2。 TCPカプセル化ESPヘッダー形式"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                     ESP header [RFC4303]                      ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "The ESP header is preceded by a 16-bit Length field in network byte order that specifies the length of the ESP packet within the TCP stream.",
      "ja": "ESPヘッダは、TCPストリーム内のESPパケットの長さを指定するネットワークバイト順に16ビット長のフィールドが先行します。"
    },
    {
      "indent": 3,
      "text": "The Security Parameter Index (SPI) field [RFC7296] in the ESP header MUST NOT be a zero value.",
      "ja": "ESPヘッダ内のセキュリティパラメータインデックス（SPI）フィールド[RFC7296]はゼロ値であるはずがありません。"
    },
    {
      "indent": 3,
      "text": "o Length (2 octets, unsigned integer) - Length of the ESP packet, including the Length field.",
      "ja": "O長（2つのオクテットの符号なし整数） -  ESPパケットの長さ、長さフィールドを含みます。"
    },
    {
      "indent": 0,
      "text": "4. TCP-Encapsulated Stream Prefix",
      "section_title": true,
      "ja": "4. TCPカプセル化ストリームのプレフィックス"
    },
    {
      "indent": 3,
      "text": "Each stream of bytes used for IKE and IPsec encapsulation MUST begin with a fixed sequence of six bytes as a magic value, containing the characters \"IKETCP\" as ASCII values. This value is intended to identify and validate that the TCP connection is being used for TCP encapsulation as defined in this document, to avoid conflicts with the prevalence of previous non-standard protocols that used TCP port 4500. This value is only sent once, by the TCP Originator only, at the beginning of any stream of IKE and ESP messages.",
      "ja": "マジック値として6バイトの固定シーケンスで始まる必要がありIKEおよびIPsecカプセル化のために使用されるバイトの各ストリーム、ASCII値として文字「IKETCP」を含みます。この値はにより、識別し、この値は一度だけ送信されるTCPポート4500を使用し、以前の非標準プロトコルの有病率との競合を避けるために、このドキュメントで定義されているTCP接続はTCPカプセル化のために使用されていることを検証するために意図されましたTCPの発信のみ、IKEおよびESPのいずれかのメッセージストリームの先頭に。"
    },
    {
      "indent": 3,
      "text": "If other framing protocols are used within TCP to further encapsulate or encrypt the stream of IKE and ESP messages, the stream prefix must be at the start of the TCP Originator's IKE and ESP message stream within the added protocol layer (Appendix A). Although some framing protocols do support negotiating inner protocols, the stream prefix should always be used in order for implementations to be as generic as possible and not rely on other framing protocols on top of TCP.",
      "ja": "他のフレーミングプロトコルがさらにカプセル化またはIKEとESPメッセージのストリームを暗号化するためにTCP内で使用している場合は、ストリームの接頭辞が追加プロトコル層（付録A）内のTCP発信者のIKEとESPメッセージ・ストリームの先頭にある必要があります。いくつかのフレーミングプロトコルが交渉内部のプロトコルをサポートしていますが、ストリームのプレフィックスは常に実装は、できるだけ汎用的なものとTCPの上に他のフレーミングプロトコルに依存しないようにするために使用すべきです。"
    },
    {
      "indent": 15,
      "text": " 0      1      2      3      4      5\n+------+------+------+------+------+------+\n| 0x49 | 0x4b | 0x45 | 0x54 | 0x43 | 0x50 |\n+------+------+------+------+------+------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 0,
      "text": "5. Applicability",
      "section_title": true,
      "ja": "5.適用性"
    },
    {
      "indent": 3,
      "text": "TCP encapsulation is applicable only when it has been configured to be used with specific IKE peers. If a Responder is configured to use TCP encapsulation, it MUST listen on the configured port(s) in case any peers will initiate new IKE sessions. Initiators MAY use TCP encapsulation for any IKE session to a peer that is configured to support TCP encapsulation, although it is recommended that Initiators should only use TCP encapsulation when traffic over UDP is blocked.",
      "ja": "TCPカプセル化は、特定のIKEピアで使用されるように構成されている場合にのみ適用されます。レスポンダは、TCPカプセル化を使用するように設定されている場合は、それがどのピアが新しいIKEセッションを開始します場合に設定されたポート（複数可）に耳を傾けなければなりません。 UDP上のトラフィックがブロックされたときにイニシエータのみTCPカプセル化を使用することが推奨されるが、イニシエータは、TCPカプセル化をサポートするように設定されたピアへのIKEセッションのためのTCPカプセル化を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Since the support of TCP encapsulation is a configured property, not a negotiated one, it is recommended that if there are multiple IKE endpoints representing a single peer (such as multiple machines with different IP addresses when connecting by Fully Qualified Domain Name, or endpoints used with IKE redirection), all of the endpoints equally support TCP encapsulation.",
      "ja": "TCPカプセル化のサポートが構成性ではなく、ネゴシエートされたものであるので、複数のIKE完全修飾ドメイン名によって接続する際に、異なるIPアドレスを持つ複数のマシンのような単一のピアを（代表エンドポイント、またはエンドポイントがある場合に使用することが推奨されIKEのリダイレクト）と、すべてのエンドポイントは、均等にTCPカプセル化をサポートしています。"
    },
    {
      "indent": 3,
      "text": "If TCP encapsulation is being used for a specific IKE SA, all messages for that IKE SA and its Child SAs MUST be sent over a TCP connection until the SA is deleted or IKEv2 Mobility and Multihoming (MOBIKE) is used to change the SA endpoints and/or the encapsulation protocol. See Section 8 for more details on using MOBIKE to transition between encapsulation modes.",
      "ja": "TCPカプセル化が特定のIKE SAのために使用されている場合、SAが削除されるまで、そのIKE SAとその子SAのすべてのメッセージは、TCP接続を介して送らなければなりませんまたはIKEv2のモビリティとマルチホーミング（MOBIKE）はSAのエンドポイントを変更するために使用され、 /またはカプセル化プロトコル。カプセル化モード間の移行をMOBIKEを使用しての詳細については、セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1. Recommended Fallback from UDP",
      "section_title": true,
      "ja": "5.1。 UDPからのフォールバックを推奨"
    },
    {
      "indent": 3,
      "text": "Since UDP is the preferred method of transport for IKE messages, implementations that use TCP encapsulation should have an algorithm for deciding when to use TCP after determining that UDP is unusable. If an Initiator implementation has no prior knowledge about the network it is on and the status of UDP on that network, it SHOULD always attempt to negotiate IKE over UDP first. IKEv2 defines how to use retransmission timers with IKE messages and, specifically, IKE_SA_INIT messages [RFC7296]. Generally, this means that the implementation will define a frequency of retransmission and the maximum number of retransmissions allowed before marking the IKE SA as failed. An implementation can attempt negotiation over TCP once it has hit the maximum retransmissions over UDP, or slightly before to reduce connection setup delays. It is recommended that the initial message over UDP be retransmitted at least once before falling back to TCP, unless the Initiator knows beforehand that the network is likely to block UDP.",
      "ja": "UDPは、IKEメッセージのための輸送の好ましい方法であるので、TCPカプセル化を使用する実装は、UDPが使用不可能であると判断した後にTCPを使用する際に決定するためのアルゴリズムを持っている必要があります。イニシエータの実装は、それがオンになっているネットワークおよびそのネットワーク上のUDPの状態についての予備知識を持っていない場合、それは常に最初にUDP上でIKEを交渉しようとすべきです。 IKEv2は、IKEメッセージと、具体的には、IKE_SA_INITメッセージ[RFC7296]と再送タイマーを使用する方法を定義します。一般的に、これは実装は、再送信の周波数と失敗したとして、IKE SAをマーキングする前に許可される再送信の最大数を定義することを意味します。それは接続設定遅延を低減するためにUDP経由、または少し前に最大再送を打った後の実装は、TCP上で交渉を試みることができます。イニシエータは、ネットワークがUDPをブロックする可能性があることを事前に知っていない限り、UDPを超える最初のメッセージは、TCPに戻って落ちる前に少なくとも一回再送信することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6. Connection Establishment and Teardown",
      "section_title": true,
      "ja": "6.接続の確立とティアダウン"
    },
    {
      "indent": 3,
      "text": "When the IKE Initiator uses TCP encapsulation, it will initiate a TCP connection to the Responder using the configured TCP port. The first bytes sent on the stream MUST be the stream prefix value (Section 4). After this prefix, encapsulated IKE messages will negotiate the IKE SA and initial Child SA [RFC7296]. After this point, both encapsulated IKE (Figure 1) and ESP (Figure 2) messages will be sent over the TCP connection. The TCP Responder MUST wait for the entire stream prefix to be received on the stream before trying to parse out any IKE or ESP messages. The stream prefix is sent only once, and only by the TCP Originator.",
      "ja": "IKEイニシエータは、TCPカプセル化を使用する場合は、設定されたTCPポートを使用してレスポンダへのTCP接続を開始します。ストリーム上で送信された最初のバイトは、ストリームプレフィックス値（セクション4）でなければなりません。この接頭辞の後、カプセル化されたIKEメッセージは、IKE SAと初期チャイルドSA [RFC7296]を交渉します。この時点の後、両方のカプセル化されたIKE（図1）及びESP（図2）メッセージは、TCP接続を介して送信されます。 TCP Responderは任意のIKEまたはESPメッセージを解析しようとする前に、ストリーム上で受信されるストリーム全体のプレフィックスのために待たなければなりません。ストリーム接頭辞は一度だけ、とのみTCP発信者によって送信されます。"
    },
    {
      "indent": 3,
      "text": "In order to close an IKE session, either the Initiator or Responder SHOULD gracefully tear down IKE SAs with DELETE payloads. Once the SA has been deleted, the TCP Originator SHOULD close the TCP connection if it does not intend to use the connection for another IKE session to the TCP Responder. If the connection is left idle and the TCP Responder needs to clean up resources, the TCP Responder MAY close the TCP connection.",
      "ja": "IKEセッションを閉じるためには、イニシエータまたはレスポンダのいずれかが正常DELETEペイロードでIKE SAを取り壊すべきです。 SAが削除されたら、それはTCPのレスポンダに別のIKEセッションの接続を使用することを意図していない場合は、TCP発信者は、TCP接続を閉じる必要があります。接続がアイドル状態のままにし、TCP Responderがリソースをクリーンアップする必要がある場合は、TCP ResponderはTCP接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "An unexpected FIN or a TCP Reset on the TCP connection may indicate a loss of connectivity, an attack, or some other error. If a DELETE payload has not been sent, both sides SHOULD maintain the state for their SAs for the standard lifetime or timeout period. The TCP Originator is responsible for re-establishing the TCP connection if it is torn down for any unexpected reason. Since new TCP connections may use different ports due to NAT mappings or local port allocations changing, the TCP Responder MUST allow packets for existing SAs to be received from new source ports.",
      "ja": "予想外のFINまたはTCP接続上でTCPリセットは、接続の喪失、攻撃、または他のいくつかのエラーを示すことがあります。 DELETEペイロードが送信されていない場合は、両側には、標準的な寿命か、タイムアウト期間のための彼らのSAの状態を維持する必要があります。 TCPの発信は、それが何らかの予期しない理由で切断された場合、TCP接続を再確立するための責任があります。新しいTCP接続が変化によるNATマッピングまたはローカルポートの割り当てとは異なるポートを使用することができるので、TCPレスポンダは、SAを既存のパケットが新しい送信元ポートから受信されることを可能にしなければなりません。"
    },
    {
      "indent": 3,
      "text": "A peer MUST discard a partially received message due to a broken connection.",
      "ja": "ピアが原因壊れた接続に部分的に受信されたメッセージを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Whenever the TCP Originator opens a new TCP connection to be used for an existing IKE SA, it MUST send the stream prefix first, before any IKE or ESP messages. This follows the same behavior as the initial TCP connection.",
      "ja": "TCPの発信者は、既存のIKE SAのために使用される新しいTCP接続を開くたびに、それがどのIKEまたはESPのメッセージの前に、最初のストリーム接頭辞を送らなければなりません。これは、初期のTCP接続と同じ動作に従います。"
    },
    {
      "indent": 3,
      "text": "If a TCP connection is being used to resume a previous IKE session, the TCP Responder can recognize the session using either the IKE SPI from an encapsulated IKE message or the ESP SPI from an encapsulated ESP message. If the session had been fully established previously, it is suggested that the TCP Originator send an UPDATE_SA_ADDRESSES message if MOBIKE is supported, or an informational message (a keep-alive) otherwise.",
      "ja": "TCP接続は、前のIKEセッションを再開するために使用されている場合、TCPレスポンダは、カプセル化されたESPメッセージからカプセル化されたIKEメッセージからIKE SPIまたはESP SPIのいずれかを使用してセッションを認識することができます。セッションが完全に以前に確立されていたならば、MOBIKEがサポートされている場合、TCP発信者がUPDATE_SA_ADDRESSESメッセージを送ることが示唆された、または情報メッセージ（キープアライブ）がそうでありません。"
    },
    {
      "indent": 3,
      "text": "The TCP Responder MUST NOT accept any messages for the existing IKE session on a new incoming connection, unless that connection begins with the stream prefix. If either the TCP Originator or TCP Responder detects corruption on a connection that was started with a valid stream prefix, it SHOULD close the TCP connection. The connection can be determined to be corrupted if there are too many subsequent messages that cannot be parsed as valid IKE messages or ESP messages with known SPIs, or if the authentication check for an ESP message with a known SPI fails. Implementations SHOULD NOT tear down a connection if only a single ESP message has an unknown SPI, since the SPI databases may be momentarily out of sync. If there is instead a syntax issue within an IKE message, an implementation MUST send the INVALID_SYNTAX notify payload and tear down the IKE SA as usual, rather than tearing down the TCP connection directly.",
      "ja": "その接続は、ストリームの接頭辞で始まりますしない限り、TCP Responderは、新しい着信接続に既存のIKEセッションのために任意のメッセージを受け入れてはいけません。 TCP発信またはTCPレスポンダのいずれかが有効なストリーム接頭辞で開始された接続上の破損を検出した場合、TCP接続を閉じる必要があります。知られているSPIとESPメッセージの認証チェックが失敗した場合、既知のSPIで有効なIKEメッセージやESPメッセージとして解析、またはすることはできませんあまりにも多くの後続のメッセージがある場合、接続が破損している可能性があると判断することができます。ただ一つのESPメッセージが未知のSPIを持っている場合、SPIのデータベースが同期してい一瞬かもしれないので、実装は、接続を切断すべきではありません。代わりに、IKEメッセージ内の構文に問題がある場合、実装はINVALID_SYNTAXではなく、直接TCPコネクションを切断するよりも、いつものようにIKE SAをペイロードを通知し、取り壊す送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A TCP Originator SHOULD only open one TCP connection per IKE SA, over which it sends all of the corresponding IKE and ESP messages. This helps ensure that any firewall or NAT mappings allocated for the TCP connection apply to all of the traffic associated with the IKE SA equally.",
      "ja": "TCP発信は、それが対応するIKEとESPすべてのメッセージを送信する上でIKE SAごとに1つのTCP接続を、開く必要があります。これは、TCP接続のために割り当てられた任意のファイアウォールやNATマッピングが均等にIKE SAに関連付けられたすべてのトラフィックに適用されることを確保することができます。"
    },
    {
      "indent": 3,
      "text": "Similarly, a TCP Responder SHOULD at any given time send packets for an IKE SA and its Child SAs over only one TCP connection. It SHOULD choose the TCP connection on which it last received a valid and decryptable IKE or ESP message. In order to be considered valid for choosing a TCP connection, an IKE message must be successfully decrypted and authenticated, not be a retransmission of a previously received message, and be within the expected window for IKE message IDs. Similarly, an ESP message must pass authentication checks and be decrypted, and must not be a replay of a previous message.",
      "ja": "同様に、TCP Responderは、任意の時点でのみ、1つのTCP接続を介してIKE SAとその子SAのパケットを送信すべきです。それは最後の有効なおよび復号可能IKEまたはESPメッセージを受信したTCPコネクションを選択する必要があります。 TCPコネクションを選択するために有効とみなされるためには、IKEメッセージが正常に復号化され、認証される必要があり、以前に受信したメッセージの再送信すること、およびIKEメッセージIDの予想ウィンドウ内ではありません。同様に、ESPメッセージ認証チェックを通過しなければならないし、復号化され、そして前のメッセージの再生であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Since a connection may be broken and a new connection re-established by the TCP Originator without the TCP Responder being aware, a TCP Responder SHOULD accept receiving IKE and ESP messages on both old and new connections until the old connection is closed by the TCP Originator. A TCP Responder MAY close a TCP connection that it perceives as idle and extraneous (one previously used for IKE and ESP messages that has been replaced by a new connection).",
      "ja": "接続が壊れたとTCP Responderが意識することなく再確立されたTCP発信することにより、新しい接続することができるので、古い接続はTCPの発信によって閉じられるまで、TCP Responderは、新旧両方の接続にIKEとESPメッセージを受信して​​受け入れるべき。 TCP Responderは、それがアイドルとして異質なと感じることをTCP接続（以前に新しい接続に置き換えられているIKEとESPメッセージのために使用されるもの）を閉じます。"
    },
    {
      "indent": 3,
      "text": "Multiple IKE SAs MUST NOT share a single TCP connection, unless one is a rekey of an existing IKE SA, in which case there will temporarily be two IKE SAs on the same TCP connection.",
      "ja": "1が一時的に同じTCP接続上の2つのIKE SAが存在します、その場合には、既存のIKE SAのリキー、でない限り、複数のIKE SAは、単一のTCP接続を共用してはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Interaction with NAT Detection Payloads",
      "section_title": true,
      "ja": "NAT検出ペイロード7.相互作用"
    },
    {
      "indent": 3,
      "text": "When negotiating over UDP port 500, IKE_SA_INIT packets include NAT_DETECTION_SOURCE_IP and NAT_DETECTION_DESTINATION_IP payloads to determine if UDP encapsulation of IPsec packets should be used. These payloads contain SHA-1 digests of the SPIs, IP addresses, and ports as defined in [RFC7296]. IKE_SA_INIT packets sent on a TCP connection SHOULD include these payloads with the same content as when sending over UDP and SHOULD use the applicable TCP ports when creating and checking the SHA-1 digests.",
      "ja": "UDPポート500上にネゴシエートするとき、IKE_SA_INITパケットは、IPsecパケットのUDPカプセル化を使用すべきかどうかを決定するためにNAT_DETECTION_SOURCE_IPとNAT_DETECTION_DESTINATION_IPペイロードを含みます。 [RFC7296]で定義されるように、これらのペイロードのSPI、IPアドレス、およびポートのSHA-1ダイジェストを含みます。 TCP接続で送信されたIKE_SA_INITパケットは、UDP上で送信するときと同じ内容を有するこれらのペイロードを含むべきであり、SHA-1ダイジェストを作成し、チェックするときに適用可能なTCPポートを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "If a NAT is detected due to the SHA-1 digests not matching the expected values, no change should be made for encapsulation of subsequent IKE or ESP packets, since TCP encapsulation inherently supports NAT traversal. Implementations MAY use the information that a NAT is present to influence keep-alive timer values.",
      "ja": "NATは、期待値と一致しないSHA-1ダイジェストのために検出された場合はTCPカプセル化は、本質的にNATトラバーサルをサポートしているので、何ら変化は、その後のIKEまたはESPパケットのカプセル化のために作られるべきではありません。実装は、NATキープアライブタイマー値に影響を与えるために存在する情報を使用することができます。"
    },
    {
      "indent": 3,
      "text": "If a NAT is detected, implementations need to handle transport mode TCP and UDP packet checksum fixup as defined for UDP encapsulation in [RFC3948].",
      "ja": "NATが検出された場合は、[RFC3948]でUDPカプセル化のために定義されているように、実装は、トランスポートモードのTCPおよびUDPパケットのチェックサムフィックスアップを処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Using MOBIKE with TCP Encapsulation",
      "section_title": true,
      "ja": "8. TCPカプセル化とMOBIKEを使用します"
    },
    {
      "indent": 3,
      "text": "When an IKE session that has negotiated MOBIKE [RFC4555] is transitioning between networks, the Initiator of the transition may switch between using TCP encapsulation, UDP encapsulation, or no encapsulation. Implementations that implement both MOBIKE and TCP encapsulation MUST support dynamically enabling and disabling TCP encapsulation as interfaces change.",
      "ja": "MOBIKE [RFC4555]をネゴシエートされたIKEセッションがネットワーク間で移行されたときに、遷移の開始は、TCPカプセル化、UDPカプセル化、または全くカプセル化を使用して切り替えることができます。 MOBIKEとTCPカプセル化の両方を実装する実装では、インターフェースの変化に動的に有効化およびTCPカプセル化を無効にサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a MOBIKE-enabled Initiator changes networks, the UPDATE_SA_ADDRESSES notification SHOULD be sent out first over UDP before attempting over TCP. If there is a response to the UPDATE_SA_ADDRESSES notification sent over UDP, then the ESP packets should be sent directly over IP or over UDP port 4500 (depending on if a NAT was detected), regardless of if a connection on a previous network was using TCP encapsulation. Similarly, if the Responder only responds to the UPDATE_SA_ADDRESSES notification over TCP, then the ESP packets should be sent over the TCP connection, regardless of if a connection on a previous network did not use TCP encapsulation.",
      "ja": "MOBIKE対応のイニシエータは、ネットワークを変更すると、UPDATE_SA_ADDRESSES通知は、TCP上で試みる前に、UDP上で最初に送ってください。 UDP経由で送信されるUPDATE_SA_ADDRESSES通知に対する応答があった場合は、ESPパケットが（NATが検出された場合に応じて）、IP上またはUDPポート4500を介して直接送信されなければならないにかかわらず、前回のネットワーク上の接続はTCPを使用していた場合のカプセル化。 Responderは唯一のTCP経由UPDATE_SA_ADDRESSES通知に応答した場合も、その後、ESPパケットは関係なく、以前のネットワークに接続がTCPカプセル化を使用しなかった場合の、TCP接続を介して送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Using IKE Message Fragmentation with TCP Encapsulation",
      "section_title": true,
      "ja": "9. TCPカプセル化とIKEメッセージの断片化を使用します"
    },
    {
      "indent": 3,
      "text": "IKE message fragmentation [RFC7383] is not required when using TCP encapsulation, since a TCP stream already handles the fragmentation of its contents across packets. Since fragmentation is redundant in this case, implementations might choose to not negotiate IKE fragmentation. Even if fragmentation is negotiated, an implementation SHOULD NOT send fragments when going over a TCP connection, although it MUST support receiving fragments.",
      "ja": "TCPカプセル化を使用するときにTCPストリームが既にパケットを横切ってその内容の断片を処理するためのIKEメッセージの断片化[RFC7383]は、必要とされません。断片化は、この場合に冗長であるため、実装は、IKEの断片化を交渉しないことを選択するかもしれません。フラグメンテーションが交渉されている場合でも、TCP接続を介して行くとき、それは断片を受信をサポートする必要がありますが、実装は、フラグメントを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "If an implementation supports both MOBIKE and IKE fragmentation, it SHOULD negotiate IKE fragmentation over a TCP-encapsulated session in case the session switches to UDP encapsulation on another network.",
      "ja": "実装はMOBIKEとIKEの断片化の両方をサポートしている場合、それは別のネットワーク上の場合にはTCPカプセル化セッションでUDPカプセル化へのセッションのスイッチをIKEの断片化を交渉すべきです。"
    },
    {
      "indent": 0,
      "text": "10. Considerations for Keep-Alives and Dead Peer Detection",
      "section_title": true,
      "ja": "キープアライブとデッドピア検出のための10の注意事項"
    },
    {
      "indent": 3,
      "text": "Encapsulating IKE and IPsec inside of a TCP connection can impact the strategy that implementations use to detect peer liveness and to maintain middlebox port mappings. Peer liveness should be checked using IKE informational packets [RFC7296].",
      "ja": "TCPコネクションの内部IKEおよびIPsecを封入する実装がピアライブネスを検出し、ミドルポートマッピングを維持するために使用する戦略に影響を与えることができます。ピアライブネスは、IKEの情報パケット[RFC7296]を使用してチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "In general, TCP port mappings are maintained by NATs longer than UDP port mappings, so IPsec ESP NAT keep-alives [RFC3948] SHOULD NOT be sent when using TCP encapsulation. Any implementation using TCP encapsulation MUST silently drop incoming NAT keep-alive packets and not treat them as errors. NAT keep-alive packets over a TCP-encapsulated IPsec connection will be sent as an ESP message with a one-octet-long payload with the value 0xFF.",
      "ja": "IPsecのESP NATは、キープアライブので、[RFC3948] TCPカプセル化を使用したときに送信されるべきではないが、一般的には、TCPポートのマッピングは、UDPポートマッピングよりも長いのNATによって維持されています。 TCPカプセル化を使用して任意の実装は静かにエラーとして扱い、着信NATキープアライブパケットをドロップしませんしなければなりません。 TCPカプセル化IPSec接続を介してNATキープアライブパケットは、値は0xFFを持つ1オクテット長のペイロードとESPメッセージとして送信されます。"
    },
    {
      "indent": 3,
      "text": "Note that, depending on the configuration of TCP and TLS on the connection, TCP keep-alives [RFC1122] and TLS keep-alives [RFC6520] may be used. These MUST NOT be used as indications of IKE peer liveness.",
      "ja": "接続上のTCPとTLSの構成に応じて、TCPキープアライブ、ことに注意してください[RFC1122]とTLSキープアライブ[RFC6520]を使用することができます。これらは、IKEピアライブネスの兆候として使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "11. Middlebox Considerations",
      "section_title": true,
      "ja": "11.ミドルの考慮事項"
    },
    {
      "indent": 3,
      "text": "Many security networking devices, such as firewalls or intrusion prevention systems, network optimization/acceleration devices, and NAT devices, keep the state of sessions that traverse through them.",
      "ja": "、ファイアウォールや侵入防止システム、ネットワークの最適化/加速デバイス、およびNATデバイスなどの多くのセキュリティネットワーキングデバイスは、それらを横断セッションの状態を保ちます。"
    },
    {
      "indent": 3,
      "text": "These devices commonly track the transport-layer and/or application-layer data to drop traffic that is anomalous or malicious in nature. While many of these devices will be more likely to pass TCP-encapsulated traffic as opposed to UDP-encapsulated traffic, some may still block or interfere with TCP-encapsulated IKE and IPsec traffic.",
      "ja": "これらのデバイスは、一般的に自然の中で異常または悪意のあるトラフィックをドロップするようにトランスポート層および/またはアプリケーション層のデータを追跡します。 UDPカプセル化されたトラフィックとは対照的に、これらのデバイスの多くはTCPカプセル化トラフィックを通過する可能性が高くなりますが、いくつかは、まだブロックまたはTCPカプセル化IKEおよびIPsecトラフィックを妨げる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A network device that monitors the transport layer will track the state of TCP sessions, such as TCP sequence numbers. TCP encapsulation of IKE should therefore use standard TCP behaviors to avoid being dropped by middleboxes.",
      "ja": "トランスポート層を監視するネットワークデバイスは、TCPシーケンス番号などのTCPセッションの状態を追跡します。 IKEのTCPカプセル化は、したがって、ミドルボックスでドロップされるのを避けるために、標準的なTCPの動作を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "12. Performance Considerations",
      "section_title": true,
      "ja": "12.パフォーマンスの考慮事項"
    },
    {
      "indent": 3,
      "text": "Several aspects of TCP encapsulation for IKE and IPsec packets may negatively impact the performance of connections within a tunnel-mode IPsec SA. Implementations should be aware of these performance impacts and take these into consideration when determining when to use TCP encapsulation. Implementations SHOULD favor using direct ESP or UDP encapsulation over TCP encapsulation whenever possible.",
      "ja": "IKEとIPsecパケットのTCPカプセル化のいくつかの側面は、負のトンネル・モードのIPsec SA内の接続のパフォーマンスに影響を与えることができます。実装は、これらのパフォーマンスへの影響を認識し、TCPカプセル化を使用するかを決定する際に考慮これらを取る必要があります。実装は可能な限りTCPカプセル化を直接ESPまたはUDPカプセル化を使用して優先すべきです。"
    },
    {
      "indent": 0,
      "text": "12.1. TCP-in-TCP",
      "section_title": true,
      "ja": "12.1。 TCP-で-TCP"
    },
    {
      "indent": 3,
      "text": "If the outer connection between IKE peers is over TCP, inner TCP connections may suffer negative effects from using TCP within TCP. Running TCP within TCP is discouraged, since the TCP algorithms generally assume that they are running over an unreliable datagram layer.",
      "ja": "IKEピア間の外部接続がTCP上にある場合、内側TCP接続がTCP内でTCPを使用してから悪影響を受けることができます。 TCPアルゴリズムは、一般的に、彼らは信頼性のないデータグラム層の上に実行していることを前提とするのでTCP内で実行されているTCPは、お勧めしません。"
    },
    {
      "indent": 3,
      "text": "If the outer (tunnel) TCP connection experiences packet loss, this loss will be hidden from any inner TCP connections, since the outer connection will retransmit to account for the losses. Since the outer TCP connection will deliver the inner messages in order, any messages after a lost packet may have to wait until the loss is recovered. This means that loss on the outer connection will be interpreted only as delay by inner connections. The burstiness of inner traffic can increase, since a large number of inner packets may be delivered across the tunnel at once. The inner TCP connection may interpret a long period of delay as a transmission problem, triggering a retransmission timeout, which will cause spurious retransmissions. The sending rate of the inner connection may be unnecessarily reduced if the retransmissions are not detected as spurious in time.",
      "ja": "外側（トンネル）TCP接続はパケットロスが発生した場合、外側の接続が損失を考慮して再送信することから、この損失は、任意の内側のTCP接続から表示されなくなります。外側のTCPコネクションが順番に、内側のメッセージをお届けしますので、失われたパケットの後に任意のメッセージは、損失が回復されるまで待つ必要があります。これは、外部接続上の損失は、内部接続だけ遅延として解釈されることを意味します。インナー多数のパケットを一度にトンネルを横切って送達することができるので、内部トラフィックのバースト性は、増加させることができます。内側のTCP接続は、スプリアス再送を引き起こします再送タイムアウトを、トリガ、伝送問題として、遅延の長い期間を解釈することがあります。再送信が時間的にスプリアスとして検出されない場合に内部接続の送信速度が不必要に減少させることができます。"
    },
    {
      "indent": 3,
      "text": "The inner TCP connection's round-trip-time estimation will be affected by the burstiness of the outer TCP connection if there are long delays when packets are retransmitted by the outer TCP connection. This will make the congestion control loop of the inner TCP traffic less reactive, potentially permanently leading to a lower sending rate than the outer TCP would allow for.",
      "ja": "長い遅延がある場合、パケットは、外側TCP接続によって再送信されたときに、内側TCPコネクションのラウンドトリップ時間推定は、外側のTCPコネクションのバースト性の影響を受けることになります。これは、潜在的に永久を可能にする外TCPより低い送信レートにつながる、内側のTCPトラフィックの輻輳制御ループは反応性が低いようになります。"
    },
    {
      "indent": 3,
      "text": "TCP-in-TCP can also lead to increased buffering, or bufferbloat. This can occur when the window size of the outer TCP connection is reduced and becomes smaller than the window sizes of the inner TCP connections. This can lead to packets backing up in the outer TCP connection's send buffers. In order to limit this effect, the outer TCP connection should have limits on its send buffer size and on the rate at which it reduces its window size.",
      "ja": "TCP-で-TCPも増加し、バッファリング、またはbufferbloatにつながることができます。外側のTCPコネクションのウィンドウサイズが減少し、内側TCP接続のウィンドウサイズより小さくなっている場合に発生する可能性があります。これは、外側のTCPコネクションの送信バッファにバックアップパケットにつながることができます。この影響を制限するために、外側TCP接続は、その送信バッファのサイズと、そのウィンドウサイズを縮小する速度に制限を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that any negative effects will be shared between all flows going through the outer TCP connection. This is of particular concern for any latency-sensitive or real-time applications using the tunnel. If such traffic is using a TCP-encapsulated IPsec connection, it is recommended that the number of inner connections sharing the tunnel be limited as much as possible.",
      "ja": "任意の負の影響は、外側のTCP接続を経由するすべてのフローの間で共有されることに注意してください。これは、任意の遅延に敏感な又はトンネルを使用してリアルタイムアプリケーションのために特に重要です。そのようなトラフィックがTCPカプセル化IPsec接続を使用している場合、トンネルを共有する内側接続の数が可能な限り限定することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "12.2. Added Reliability for Unreliable Protocols",
      "section_title": true,
      "ja": "12.2。信頼できないプロトコルを追加しました信頼性"
    },
    {
      "indent": 3,
      "text": "Since ESP is an unreliable protocol, transmitting ESP packets over a TCP connection will change the fundamental behavior of the packets. Some application-level protocols that prefer packet loss to delay (such as Voice over IP or other real-time protocols) may be negatively impacted if their packets are retransmitted by the TCP connection due to packet loss.",
      "ja": "ESPは信頼できないプロトコルであるので、TCP接続を介してESPパケットを送信することは、パケットの基本的な動作を変更します。そのパケットはパケットロスにTCPコネクションによって再送された場合（たとえば、ボイスオーバーIPまたは他のリアルタイムプロトコルとして）遅らせるために、パケットロスを好むいくつかのアプリケーションレベルのプロトコルが悪影響を受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "12.3. Quality-of-Service Markings",
      "section_title": true,
      "ja": "12.3。サービス品質マーキング"
    },
    {
      "indent": 3,
      "text": "Quality-of-Service (QoS) markings, such as the Differentiated Services Code Point (DSCP) and Traffic Class, should be used with care on TCP connections used for encapsulation. Individual packets SHOULD NOT use different markings than the rest of the connection, since packets with different priorities may be routed differently and cause unnecessary delays in the connection.",
      "ja": "こうした差別化サービスコードポイント（DSCP）およびトラフィッククラスなどのサービス品質（QoS）のマーキング、カプセル化のために使用されるTCP接続に注意して使用してください。個々のパケットは、優先度の異なるパケットは、異なるルーティングすることができるため、接続の残りの部分とは異なるマーキングを使用し、接続における不必要な遅延が発生することはありません。"
    },
    {
      "indent": 0,
      "text": "12.4. Maximum Segment Size",
      "section_title": true,
      "ja": "12.4。最大セグメントサイズ"
    },
    {
      "indent": 3,
      "text": "A TCP connection used for IKE encapsulation SHOULD negotiate its MSS in order to avoid unnecessary fragmentation of packets.",
      "ja": "IKEカプセル化に使用するTCPコネクションは、パケットの不要な断片化を避けるために、そのMSSを交渉すべきです。"
    },
    {
      "indent": 0,
      "text": "12.5. Tunneling ECN in TCP",
      "section_title": true,
      "ja": "12.5。 TCPでのトンネリングECN"
    },
    {
      "indent": 3,
      "text": "Since there is not a one-to-one relationship between outer IP packets and inner ESP/IP messages when using TCP encapsulation, the markings for Explicit Congestion Notification (ECN) [RFC3168] cannot be simply mapped. However, any ECN Congestion Experienced (CE) marking on inner headers should be preserved through the tunnel.",
      "ja": "外側IPパケットと内側ESP / IPメッセージとの間の1対1の関係が存在しないので、TCPカプセル化を使用する場合、明示的輻輳通知（ECN）のためのマーキング[RFC3168]は、単純にマッピングすることができません。しかし、内部ヘッダにマーキング経験任意ECN輻輳（CE）は、トンネルを介して保存されるべきです。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD follow the ECN compatibility mode for tunnel ingress as described in [RFC6040]. In compatibility mode, the outer tunnel TCP connection marks its packet headers as not ECN-capable. If upon egress, the arriving outer header is marked with CE, the implementation will drop the inner packet, since there is not a distinct inner packet header onto which to translate the ECN markings.",
      "ja": "[RFC6040]に記載されるような実装は、トンネル入口用ECN互換モードに従うべきです。互換モードでは、外側のトンネルTCP接続がECN対応しないように、そのパケットヘッダをマークします。出力時に、到着外部ヘッダがCEとマークされている場合ECNマーキングを変換する上異なる内部パケットのヘッダが存在しないので、実装は、内部パケットをドロップします。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "IKE Responders that support TCP encapsulation may become vulnerable to new Denial-of-Service (DoS) attacks that are specific to TCP, such as SYN-flooding attacks. TCP Responders should be aware of this additional attack surface.",
      "ja": "TCPカプセル化をサポートIKEのレスポンダは、SYNフラッディング攻撃のようにTCPに固有の新サービス拒否（DoS）攻撃に対して脆弱になることがあります。 TCPレスポンダは、この追加攻撃面に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "TCP Responders should be careful to ensure that (1) the stream prefix \"IKETCP\" uniquely identifies incoming streams as streams that use the TCP encapsulation protocol and (2) they are not running any other protocols on the same listening port (to avoid potential conflicts).",
      "ja": "TCPのレスポンダは、（潜在的な競合を避けるために、（1）ストリーム接頭辞「IKETCPは」一意TCPカプセル化プロトコルを使用してストリームとして入ってくるストリームを識別し、（2）彼らは同じリスニングポート上の任意の他のプロトコルを実行していないことを保証するために注意する必要があります）。"
    },
    {
      "indent": 3,
      "text": "Attackers may be able to disrupt the TCP connection by sending spurious TCP Reset packets. Therefore, implementations SHOULD make sure that IKE session state persists even if the underlying TCP connection is torn down.",
      "ja": "攻撃者は、偽のTCPリセットパケットを送信してTCP接続を破壊することができるかもしれません。そのため、実装は、基になるTCP接続が切断されても、IKEセッション状態が解消されないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If MOBIKE is being used, all of the security considerations outlined for MOBIKE apply [RFC4555].",
      "ja": "MOBIKEが使用されている場合は、MOBIKEについて概説したセキュリティ上の考慮事項のすべては、[RFC4555]を適用します。"
    },
    {
      "indent": 3,
      "text": "Similarly to MOBIKE, TCP encapsulation requires a TCP Responder to handle changes to source address and port due to network or connection disruption. The successful delivery of valid IKE or ESP messages over a new TCP connection is used by the TCP Responder to determine where to send subsequent responses. If an attacker is able to send packets on a new TCP connection that pass the validation checks of the TCP Responder, it can influence which path future packets will take. For this reason, the validation of messages on the TCP Responder must include decryption, authentication, and replay checks.",
      "ja": "同様にMOBIKEし、TCPのカプセル化は、ネットワークや接続の中断に送信元アドレスとポートへの変更を処理するために、TCPレスポンダが必要です。新しいTCP接続を介して有効なIKEやESPメッセージ配信の成功はどこ以降の応答の送信先を決定するためにTCPレスポンダで使用されています。攻撃者はTCPレスポンダの妥当性チェックに合格し、新たなTCPコネクション上でパケットを送信することが可能である場合、それは将来のパケットがかかりますどのパスに影響することができます。このため、TCPレスポンダ上のメッセージの検証は、復号化、認証、およびリプレイチェックを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Since TCP provides reliable, in-order delivery of ESP messages, the ESP anti-replay window size SHOULD be set to 1. See [RFC4303] for a complete description of the ESP anti-replay window. This increases the protection of implementations against replay attacks.",
      "ja": "TCPは信頼性を提供するので、ESPメッセージの順序どおりの配信は、ESPアンチリプレイウィンドウサイズはESPアンチリプレイウィンドウの詳細については、1を参照してください[RFC4303]に設定する必要があります。これは、リプレイ攻撃に対する実装の保護を強化します。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "TCP port 4500 is already allocated to IPsec for NAT traversal. This port SHOULD be used for TCP-encapsulated IKE and ESP as described in this document.",
      "ja": "TCPポート4500はすでにNATトラバーサルのためにIPsecに割り当てられています。この文書で説明したように、このポートは、TCPカプセル化IKEおよびESPのために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "This document updates the reference for TCP port 4500:",
      "ja": "このドキュメントでは、TCPポート4500のための参照を更新します。"
    },
    {
      "indent": 9,
      "text": "Keyword       Decimal    Description           Reference\n-----------   --------   -------------------   ---------\nipsec-nat-t   4500/tcp   IPsec NAT-Traversal   RFC 8229",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15.参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3948] Huttunen, A., Swander, B., Volpe, V., DiBurro, L., and M. Stenberg, \"UDP Encapsulation of IPsec ESP Packets\", RFC 3948, DOI 10.17487/RFC3948, January 2005, <http://www.rfc-editor.org/info/rfc3948>.",
      "ja": "[RFC3948] Huttunen、A.、Swander、B.、ボルペ、V.、DiBurro、L.、及びM.ステンバーグ、 \"IPsecのESPパケットのUDPカプセル化\"、RFC 3948、DOI 10.17487 / RFC3948、2005年1月<HTTP ：//www.rfc-editor.org/info/rfc3948>。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, DOI 10.17487/RFC4303, December 2005, <http://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、<http://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[RFC6040] Briscoe, B., \"Tunnelling of Explicit Congestion Notification\", RFC 6040, DOI 10.17487/RFC6040, November 2010, <http://www.rfc-editor.org/info/rfc6040>.",
      "ja": "[RFC6040]ブリスコウ、B.、 \"明示的輻輳通知のトンネリング\"、RFC 6040、DOI 10.17487 / RFC6040、2010年11月、<http://www.rfc-editor.org/info/rfc6040>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296]コーフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、<http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFCに小文字VS大文字の曖昧2119個のキーワード\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[IKE-over-TCP] Nir, Y., \"A TCP transport for the Internet Key Exchange\", Work in Progress, draft-ietf-ipsecme-ike-tcp-01, December 2012.",
      "ja": "[IKEオーバー-TCP]ニール、Y.、 \"インターネット鍵交換のためのTCPトランスポート\" が進行中で働いて、ドラフト-IETF-ipsecme-IKE-TCP-01、2012年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <http://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<http://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC2817] Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\", RFC 2817, DOI 10.17487/RFC2817, May 2000, <http://www.rfc-editor.org/info/rfc2817>.",
      "ja": "[RFC2817] Khare、R.およびS.ローレンス、 \"HTTP / 1.1内でTLSへのアップグレード\"、RFC 2817、DOI 10.17487 / RFC2817、2000年5月、<http://www.rfc-editor.org/info/rfc2817> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <http://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC4555] Eronen, P., \"IKEv2 Mobility and Multihoming Protocol (MOBIKE)\", RFC 4555, DOI 10.17487/RFC4555, June 2006, <http://www.rfc-editor.org/info/rfc4555>.",
      "ja": "[RFC4555] Eronen、P.、 \"IKEv2のモビリティとマルチホーミングプロトコル（MOBIKE）\"、RFC 4555、DOI 10.17487 / RFC4555、2006年6月、<http://www.rfc-editor.org/info/rfc4555>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, \"Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension\", RFC 6520, DOI 10.17487/RFC6520, February 2012, <http://www.rfc-editor.org/info/rfc6520>.",
      "ja": "[RFC6520] Seggelmann、R.、Tuexen、M.、およびM.ウィリアムズ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）ハートビート拡張\"、RFC 6520、DOI 10.17487 / RFC6520、2012年2月、<HTTP ：//www.rfc-editor.org/info/rfc6520>。"
    },
    {
      "indent": 3,
      "text": "[RFC7383] Smyslov, V., \"Internet Key Exchange Protocol Version 2 (IKEv2) Message Fragmentation\", RFC 7383, DOI 10.17487/RFC7383, November 2014, <http://www.rfc-editor.org/info/rfc7383>.",
      "ja": "[RFC7383] Smyslov、V.、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）メッセージの断片化\"、RFC 7383、DOI 10.17487 / RFC7383、2014年11月、<http://www.rfc-editor.org/info/rfc7383> 。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Using TCP Encapsulation with TLS",
      "ja": "TLSとTCPカプセル化を使用し付録A."
    },
    {
      "indent": 3,
      "text": "This section provides recommendations on how to use TLS in addition to TCP encapsulation.",
      "ja": "このセクションでは、TCPのカプセル化に加えて、TLSを使用する方法に関する推奨事項を示します。"
    },
    {
      "indent": 3,
      "text": "When using TCP encapsulation, implementations may choose to use TLS [RFC5246] on the TCP connection to be able to traverse middleboxes, which may otherwise block the traffic.",
      "ja": "TCPカプセル化を使用する場合、実装は、他のトラフィックをブロックすることができる、中間装置を通過できるようにTCP接続でTLS [RFC5246]を使用することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "If a web proxy is applied to the ports used for the TCP connection and TLS is being used, the TCP Originator can send an HTTP CONNECT message to establish an SA through the proxy [RFC2817].",
      "ja": "Webプロキシは、TCP接続に使用するポートに適用され、TLSが使用されている場合、TCP発信プロキシ[RFC2817]を介してSAを確立するために、HTTP CONNECTメッセージを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The use of TLS should be configurable on the peers, and may be used as the default when using TCP encapsulation or may be used as a fallback when basic TCP encapsulation fails. The TCP Responder may expect to read encapsulated IKE and ESP packets directly from the TCP connection, or it may expect to read them from a stream of TLS data packets. The TCP Originator should be pre-configured to use TLS or not when communicating with a given port on the TCP Responder.",
      "ja": "TLSを使用すると、ピア上で設定する必要があり、およびTCPカプセル化を使用する場合、デフォルトとして使用してもよいし、基本的なTCPカプセル化が失敗したときにフォールバックとして使用することができます。 TCP ResponderはTCP接続から直接カプセル化されたIKEとESPパケットを読み取るために期待することがあり、またはそれはTLSデータパケットのストリームからそれらを読むことを期待することがあります。 TCP発信者はTCPレスポンダ上の特定のポートと通信するときにTLSを使用したりしないように事前に設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When new TCP connections are re-established due to a broken connection, TLS must be renegotiated. TLS session resumption is recommended to improve efficiency in this case.",
      "ja": "新しいTCP接続が原因切断された接続に再確立されている場合は、TLSを再交渉する必要があります。 TLSセッション再開は、このときの効率を改善することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The security of the IKE session is entirely derived from the IKE negotiation and key establishment and not from the TLS session (which in this context is only used for encapsulation purposes); therefore, when TLS is used on the TCP connection, both the TCP Originator and the TCP Responder SHOULD allow the NULL cipher to be selected for performance reasons.",
      "ja": "IKEセッションのセキュリティを完全に（このコンテキストでのみカプセル化の目的のために使用される）、TLSセッションからIKEネゴシエーションと鍵確立としないから誘導されます。 TLSは、TCP接続で使用される場合、したがって、TCP発信元及びTCPレスポンダの両方がNULL暗号は、パフォーマンス上の理由のために選択されることを可能にするべきです。"
    },
    {
      "indent": 3,
      "text": "Implementations should be aware that the use of TLS introduces another layer of overhead requiring more bytes to transmit a given IKE and IPsec packet. For this reason, direct ESP, UDP encapsulation, or TCP encapsulation without TLS should be preferred in situations in which TLS is not required in order to traverse middleboxes.",
      "ja": "実装は、TLSの使用は、所与のIKEおよびIPsecパケットを送信するために複数バイトを必要とするオーバーヘッドの別の層を導入することに注意すべきです。このため、TLSなしで直接ESP、UDPカプセル化、またはTCPカプセル化はTLSがミドルボックスを通過するために必要とされていない状況で好まれるべきです。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example Exchanges of TCP Encapsulation with TLS",
      "ja": "TLSとTCPカプセル化の付録B.例の交流"
    },
    {
      "indent": 0,
      "text": "B.1. Establishing an IKE Session",
      "ja": "B.1。 IKEセッションの確立"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  --------------------  TCP Connection  -------------------\n    (IP_I:Port_I  -> IP_R:Port_R)\n    TcpSyn                    ---------->\n                              <----------          TcpSyn,Ack\n    TcpAck                    ---------->",
      "raw": true
    },
    {
      "indent": 5,
      "text": "2)  ---------------------  TLS Session  ---------------------\n    ClientHello               ---------->\n                                                  ServerHello\n                                                 Certificate*\n                                           ServerKeyExchange*\n                              <----------     ServerHelloDone\n    ClientKeyExchange\n    CertificateVerify*\n    [ChangeCipherSpec]\n    Finished                  ---------->\n                                           [ChangeCipherSpec]\n                              <----------            Finished",
      "raw": true
    },
    {
      "indent": 5,
      "text": "3)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->\n4)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker   ---------->\n    IKE_SA_INIT\n    HDR, SAi1, KEi, Ni,\n    [N(NAT_DETECTION_*_IP)]\n                              <------ Length + Non-ESP Marker\n                                                  IKE_SA_INIT\n                                          HDR, SAr1, KEr, Nr,\n                                      [N(NAT_DETECTION_*_IP)]\n    Length + Non-ESP Marker   ---------->\n    first IKE_AUTH\n    HDR, SK {IDi, [CERTREQ]\n    CP(CFG_REQUEST), IDr,\n    SAi2, TSi, TSr, ...}\n                              <------ Length + Non-ESP Marker\n                                               first IKE_AUTH\n                                  HDR, SK {IDr, [CERT], AUTH,\n                                         EAP, SAr2, TSi, TSr}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Length + Non-ESP Marker   ---------->\nIKE_AUTH + EAP\nrepeat 1..N times\n                          <------ Length + Non-ESP Marker\n                                           IKE_AUTH + EAP\nLength + Non-ESP Marker   ---------->\nfinal IKE_AUTH\nHDR, SK {AUTH}\n                          <------ Length + Non-ESP Marker\n                                           final IKE_AUTH\n                            HDR, SK {AUTH, CP(CFG_REPLY),\n                                       SA, TSi, TSr, ...}\n-------------- IKE and IPsec SAs Established ------------\nLength + ESP Frame        ---------->",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "1. The client establishes a TCP connection with the server on port 4500 or on an alternate pre-configured port that the server is listening on.",
      "ja": "1.クライアントは、ポート4500上またはサーバーがリッスンしている代替あらかじめ設定されたポート上のサーバとのTCP接続を確立します。"
    },
    {
      "indent": 3,
      "text": "2. If configured to use TLS, the client initiates a TLS handshake. During the TLS handshake, the server SHOULD NOT request the client's certificate, since authentication is handled as part of IKE negotiation.",
      "ja": "2. TLSを使用するように設定している場合、クライアントはTLSハンドシェイクを開始します。認証は、IKEネゴシエーションの一部として扱われるため、TLSハンドシェイク中に、サーバーは、クライアントの証明書を要求すべきでありません。"
    },
    {
      "indent": 3,
      "text": "3. The client sends the stream prefix for TCP-encapsulated IKE (Section 4) traffic to signal the beginning of IKE negotiation.",
      "ja": "3.クライアントは、IKEネゴシエーションの開始を通知するためにTCPカプセル化IKE（第4節）トラフィックのストリーム接頭辞を送信します。"
    },
    {
      "indent": 3,
      "text": "4. The client and server establish an IKE connection. This example shows EAP-based authentication, although any authentication type may be used.",
      "ja": "4.クライアントとサーバは、IKE接続を確立します。任意の認証タイプが使用されてもよいが、この例では、EAPベースの認証を示しています。"
    },
    {
      "indent": 0,
      "text": "B.2. Deleting an IKE Session",
      "ja": "B.2。 IKEセッションを削除します"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker   ---------->\n    INFORMATIONAL\n    HDR, SK {[N,] [D,]\n           [CP,] ...}\n                              <------ Length + Non-ESP Marker\n                                                INFORMATIONAL\n                                           HDR, SK {[N,] [D,]\n                                                   [CP], ...}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "2)  ---------------------  TLS Session  ---------------------\n    close_notify              ---------->\n                              <----------        close_notify\n3)  --------------------  TCP Connection  -------------------\n    TcpFin                    ---------->\n                              <----------                 Ack\n                              <----------              TcpFin\n    Ack                       ---------->\n    --------------------  IKE SA Deleted  -------------------",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 3,
      "text": "1. The client and server exchange informational messages to notify IKE SA deletion.",
      "ja": "1.クライアントとサーバーの交換情報メッセージは、IKE SAの削除を通知します。"
    },
    {
      "indent": 3,
      "text": "2. The client and server negotiate TLS session deletion using TLS CLOSE_NOTIFY.",
      "ja": "2.クライアントとサーバがTLSは、close_notifyを使用して、TLSセッションの削除を交渉します。"
    },
    {
      "indent": 3,
      "text": "3. The TCP connection is torn down.",
      "section_title": true,
      "ja": "3. TCP接続が切断され。"
    },
    {
      "indent": 3,
      "text": "The deletion of the IKE SA should lead to the disposal of the underlying TLS and TCP state.",
      "ja": "IKE SAの削除は、基礎となるTLSおよびTCP状態の処分につながるはず。"
    },
    {
      "indent": 0,
      "text": "B.3. Re-establishing an IKE Session",
      "ja": "B.3。 IKEセッションを再確立します"
    },
    {
      "indent": 5,
      "text": "              Client                              Server\n            ----------                          ----------\n1)  --------------------  TCP Connection  -------------------\n    (IP_I:Port_I  -> IP_R:Port_R)\n    TcpSyn                    ---------->\n                              <----------          TcpSyn,Ack\n    TcpAck                    ---------->\n2)  ---------------------  TLS Session  ---------------------\n    ClientHello               ---------->\n                              <----------         ServerHello\n                                           [ChangeCipherSpec]\n                                                     Finished\n    [ChangeCipherSpec]        ---------->\n    Finished\n3)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->\n4)  <---------------------> IKE/ESP Flow <------------------>\n    Length + ESP Frame        ---------->",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 7",
      "ja": "図7"
    },
    {
      "indent": 3,
      "text": "1. If a previous TCP connection was broken (for example, due to a TCP Reset), the client is responsible for re-initiating the TCP connection. The TCP Originator's address and port (IP_I and Port_I) may be different from the previous connection's address and port.",
      "ja": "1.以前のTCP接続は（TCPリセットに例えば、原因）壊れていた場合、クライアントは、TCP接続を再起動する責任があります。 TCP発信者のアドレスとポート（IP_IとPort_I）は、以前の接続のアドレスとポートとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "2. In the ClientHello TLS message, the client SHOULD send the session ID it received in the previous TLS handshake if available. It is up to the server to perform either an abbreviated handshake or a full handshake based on the session ID match.",
      "ja": "ClientHello TLSメッセージで、[クライアントが利用できるならば、それは以前のTLSハンドシェイクで受信したセッションIDを送るべきです。これは、簡略ハンドシェイクまたはセッションIDの一致に基づいて完全なハンドシェイクのいずれかを実行するサーバー次第です。"
    },
    {
      "indent": 3,
      "text": "3. After TCP and TLS are complete, the client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).",
      "ja": "TCPとTLSが完了した後3.クライアントはTCPカプセル化IKEトラフィック（第4節）のためのストリーム接頭辞を送信します。"
    },
    {
      "indent": 3,
      "text": "4. The IKE and ESP packet flow can resume. If MOBIKE is being used, the Initiator SHOULD send an UPDATE_SA_ADDRESSES message.",
      "ja": "4. IKEとESPパケットフローを再開することができます。 MOBIKEが使用されている場合、イニシエータはUPDATE_SA_ADDRESSESメッセージを送るべきです。"
    },
    {
      "indent": 0,
      "text": "B.4. Using MOBIKE between UDP and TCP Encapsulation",
      "ja": "B.4。 UDPとTCPカプセル化の間MOBIKEを使用して"
    },
    {
      "indent": 5,
      "text": "                Client                              Server\n              ----------                          ----------\n    (IP_I1:UDP500 -> IP_R:UDP500)\n1)  ----------------- IKE_SA_INIT Exchange -----------------\n    (IP_I1:UDP4500 -> IP_R:UDP4500)\n    Non-ESP Marker           ----------->\n    Initial IKE_AUTH\n    HDR, SK { IDi, CERT, AUTH,\n    CP(CFG_REQUEST),\n    SAi2, TSi, TSr,\n    N(MOBIKE_SUPPORTED) }\n                             <-----------      Non-ESP Marker\n                                             Initial IKE_AUTH\n                                   HDR, SK { IDr, CERT, AUTH,\n                                         EAP, SAr2, TSi, TSr,\n                                        N(MOBIKE_SUPPORTED) }\n    <------------------ IKE SA Establishment --------------->",
      "raw": true
    },
    {
      "indent": 5,
      "text": "2)  ------------ MOBIKE Attempt on New Network --------------\n    (IP_I2:UDP4500 -> IP_R:UDP4500)\n    Non-ESP Marker           ----------->\n    INFORMATIONAL\n    HDR, SK { N(UPDATE_SA_ADDRESSES),\n    N(NAT_DETECTION_SOURCE_IP),\n    N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true
    },
    {
      "indent": 5,
      "text": "3)  --------------------  TCP Connection  -------------------\n    (IP_I2:Port_I -> IP_R:Port_R)\n    TcpSyn                   ----------->\n                             <-----------          TcpSyn,Ack\n    TcpAck                   ----------->",
      "raw": true
    },
    {
      "indent": 5,
      "text": "4)  ---------------------  TLS Session  ---------------------\n    ClientHello              ----------->\n                                                  ServerHello\n                                                 Certificate*\n                                           ServerKeyExchange*\n                             <-----------     ServerHelloDone\n    ClientKeyExchange\n    CertificateVerify*\n    [ChangeCipherSpec]\n    Finished                 ----------->\n                                           [ChangeCipherSpec]\n                             <-----------            Finished",
      "raw": true
    },
    {
      "indent": 5,
      "text": "5)  ---------------------- Stream Prefix --------------------\n    \"IKETCP\"                  ---------->",
      "raw": true
    },
    {
      "indent": 5,
      "text": "6)  ----------------------- IKE Session ---------------------\n    Length + Non-ESP Marker  ----------->\n    INFORMATIONAL (Same as step 2)\n    HDR, SK { N(UPDATE_SA_ADDRESSES),\n    N(NAT_DETECTION_SOURCE_IP),\n    N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true
    },
    {
      "indent": 5,
      "text": "                             <------- Length + Non-ESP Marker\n                        HDR, SK { N(NAT_DETECTION_SOURCE_IP),\n                            N(NAT_DETECTION_DESTINATION_IP) }\n7)  <----------------- IKE/ESP Data Flow ------------------->",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 8",
      "ja": "図8"
    },
    {
      "indent": 3,
      "text": "1. During the IKE_SA_INIT exchange, the client and server exchange MOBIKE_SUPPORTED notify payloads to indicate support for MOBIKE.",
      "ja": "1. IKE_SA_INIT交換中に、クライアントとサーバーの交換は、MOBIKEのサポートを示すためにペイロードを通知しMOBIKE_SUPPORTED。"
    },
    {
      "indent": 3,
      "text": "2. The client changes its point of attachment to the network and receives a new IP address. The client attempts to re-establish the IKE session using the UPDATE_SA_ADDRESSES notify payload, but the server does not respond because the network blocks UDP traffic.",
      "ja": "2.クライアントは、ネットワークへの接続点を変更し、新しいIPアドレスを受信します。クライアントはUPDATE_SA_ADDRESSESがペイロードを通知し使用してIKEセッションを再確立しようとしたが、サーバーはネットワークブロックため、UDPトラフィックを応答しません。"
    },
    {
      "indent": 3,
      "text": "3. The client brings up a TCP connection to the server in order to use TCP encapsulation.",
      "ja": "3.クライアントは、TCPカプセル化を使用するために、サーバーへのTCP接続が表示されます。"
    },
    {
      "indent": 3,
      "text": "4. The client initiates a TLS handshake with the server.",
      "section_title": true,
      "ja": "4.クライアントは、サーバとのTLSハンドシェイクを開始します。"
    },
    {
      "indent": 3,
      "text": "5. The client sends the stream prefix for TCP-encapsulated IKE traffic (Section 4).",
      "ja": "5.クライアントは、TCPカプセル化IKEトラフィック（第4節）のストリーム接頭辞を送信します。"
    },
    {
      "indent": 3,
      "text": "6. The client sends the UPDATE_SA_ADDRESSES notify payload on the TCP-encapsulated connection. Note that this IKE message is the same as the one sent over UDP in step 2; it should have the same message ID and contents.",
      "ja": "6.クライアントはUPDATE_SA_ADDRESSESはTCPカプセル化接続上でペイロードを通知し送信します。このIKEメッセージは、ステップ2でUDPを介して送信されたものと同じであることに留意されたいです。それは、同じメッセージIDと内容を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "7. The IKE and ESP packet flow can resume.",
      "section_title": true,
      "ja": "7. IKEとESPパケットフローを再開することができます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge the input and advice of Stuart Cheshire, Delziel Fernandes, Yoav Nir, Christoph Paasch, Yaron Sheffer, David Schinazi, Graham Bartlett, Byju Pularikkal, March Wu, Kingwel Xie, Valery Smyslov, Jun Hu, and Tero Kivinen. Special thanks to Eric Kinnear for his implementation work.",
      "ja": "著者はスチュアートチェシャー、Delzielフェルナンデス、ヨアフニール、クリストフPaasch、ヤロンシェファー、デビッドSchinazi、グラハム・バートレット、Byju Pularikkal、月呉、Kingwel謝、ヴァレリーSmyslov、6月胡、およびTERO Kivinenの入力やアドバイスを承認したいと思います。彼の実装作業のためのエリック・キニアに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tommy Pauly Apple Inc. 1 Infinite Loop Cupertino, California 95014 United States of America",
      "ja": "トミーポーリーされたApple Inc. 1無限ループクパチーノ、カリフォルニアアメリカの95014米国"
    },
    {
      "indent": 3,
      "text": "Email: tpauly@apple.com",
      "ja": "メール：tpauly@apple.com"
    },
    {
      "indent": 3,
      "text": "Samy Touati Ericsson 2755 Augustine Santa Clara, California 95054 United States of America",
      "ja": "サミーTouatiエリクソン2755オーガスティンサンタクララ、カリフォルニア州アメリカの95054米国"
    },
    {
      "indent": 3,
      "text": "Email: samy.touati@ericsson.com",
      "ja": "メール：samy.touati@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Ravi Mantha Cisco Systems SEZ, Embassy Tech Village Panathur, Bangalore 560 037 India",
      "ja": "ラヴィManthaシスコシステムズSEZ、大使館テック村Panathur、バンガロール560 037インド"
    },
    {
      "indent": 3,
      "text": "Email: ramantha@cisco.com",
      "ja": "メール：ramantha@cisco.com"
    }
  ]
}