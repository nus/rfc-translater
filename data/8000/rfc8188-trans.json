{
  "title": {
    "text": "RFC 8188 - Encrypted Content-Encoding for HTTP",
    "ja": "RFC 8188 - HTTPのための暗号化されたコンテンツのエンコーディング"
  },
  "number": 8188,
  "created_at": "2019-10-24 13:49:26.599407+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        M. Thomson\nRequest for Comments: 8188                                       Mozilla\nCategory: Standards Track                                      June 2017\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Encrypted Content-Encoding for HTTP",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo introduces a content coding for HTTP that allows message payloads to be encrypted.",
      "ja": "このメモは、メッセージペイロードを暗号化することを可能にするHTTPをコードするコンテンツを紹介します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8188.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8188で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3\n2.  The \"aes128gcm\" HTTP Content Coding . . . . . . . . . . . . .   3\n  2.1.  Encryption Content-Coding Header  . . . . . . . . . . . .   5\n  2.2.  Content-Encryption Key Derivation . . . . . . . . . . . .   6\n  2.3.  Nonce Derivation  . . . . . . . . . . . . . . . . . . . .   6\n3.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.1.  Encryption of a Response  . . . . . . . . . . . . . . . .   7\n  3.2.  Encryption with Multiple Records  . . . . . . . . . . . .   8\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .   8\n  4.1.  Automatic Decryption  . . . . . . . . . . . . . . . . . .   9\n  4.2.  Message Truncation  . . . . . . . . . . . . . . . . . . .   9\n  4.3.  Key and Nonce Reuse . . . . . . . . . . . . . . . . . . .   9\n  4.4.  Data Encryption Limits  . . . . . . . . . . . . . . . . .  10\n  4.5.  Content Integrity . . . . . . . . . . . . . . . . . . . .  10\n  4.6.  Leaking Information in Header Fields  . . . . . . . . . .  10\n  4.7.  Poisoning Storage . . . . . . . . . . . . . . . . . . . .  11\n  4.8.  Sizing and Timing Attacks . . . . . . . . . . . . . . . .  11\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12\n  5.1.  The \"aes128gcm\" HTTP Content Coding . . . . . . . . . . .  12\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  12\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  13\nAppendix A.  JWE Mapping  . . . . . . . . . . . . . . . . . . . .  15\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  16\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "It is sometimes desirable to encrypt the contents of an HTTP message (request or response) so that when the payload is stored (e.g., with an HTTP PUT), only someone with the appropriate key can read it.",
      "ja": "ペイロード（例えば、HTTPのPUTで）格納されている場合、適切なキーを持つ唯一の誰かがそれを読むことができるように、HTTPメッセージ（要求または応答）の内容を暗号化することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, it might be necessary to store a file on a server without exposing its contents to that server. Furthermore, that same file could be replicated to other servers (to make it more resistant to server or network failure), downloaded by clients (to make it available offline), etc., without exposing its contents.",
      "ja": "例えば、そのサーバーにその内容を公開することなく、サーバー上のファイルを格納する必要があるかもしれません。さらに、同じファイルがその内容を公開することなく、など、（オフラインでそれが利用できるようにする）他のサーバ（サーバやネットワーク障害に対してより抵抗性にする）、クライアントによってダウンロードに複製することができました。"
    },
    {
      "indent": 3,
      "text": "These uses are not met by the use of Transport Layer Security (TLS) [RFC5246], since it only encrypts the channel between the client and server.",
      "ja": "これらの用途はそれだけで、クライアントとサーバとの間のチャネルを暗号化するので、トランスポート層セキュリティ（TLS）[RFC5246]を使用することによって満たされていません。"
    },
    {
      "indent": 3,
      "text": "This document specifies a content coding (see Section 3.1.2 of [RFC7231]) for HTTP to serve these and other use cases.",
      "ja": "このドキュメントでは、HTTPは、これらおよび他の使用例を提供するためのコンテンツコーディングを（[RFC7231]のセクション3.1.2を参照）を指定します。"
    },
    {
      "indent": 3,
      "text": "This content coding is not a direct adaptation of message-based encryption formats -- such as those that are described by [RFC4880], [RFC5652], [RFC7516], and [XMLENC]. Those formats are not suited to stream processing, which is necessary for HTTP. The format described here follows more closely to the lower-level constructs described in [RFC5116].",
      "ja": "【XMLENCような[RFC4880]に記載されているものとして、[RFC5652]、[RFC7516]、および - このコンテンツの符号化は、メッセージベースの暗号化フォーマットの直接適応ではありません。これらの形式は、HTTPに必要な処理をストリーミングするために適していません。ここで説明するフォーマットは、[RFC5116]に記載下位構築物より密接に従います。"
    },
    {
      "indent": 3,
      "text": "To the extent that message-based encryption formats use the same primitives, the format can be considered to be a sequence of encrypted messages with a particular profile. For instance, Appendix A explains how the format is congruent with a sequence of JSON Web Encryption [RFC7516] values with a fixed header.",
      "ja": "メッセージベースの暗号化フォーマットは同じプリミティブを使用する限り、フォーマットは、特定のプロファイルを使用して暗号化されたメッセージのシーケンスであると考えることができます。例えば、付録Aは、フォーマットが固​​定ヘッダとJSONウェブ暗号化[RFC7516]の値の順序と一致する例を説明します。"
    },
    {
      "indent": 3,
      "text": "This mechanism is likely only a small part of a larger design that uses content encryption. How clients and servers acquire and identify keys will depend on the use case. In particular, a key management system is not described.",
      "ja": "このメカニズムは、可能性の高いコンテンツの暗号化を使用して、より大きな設計のほんの一部です。どのようにクライアントとサーバが取得し、ユースケースに依存したキーを識別します。具体的には、鍵管理システムが記載されていません。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The \"aes128gcm\" HTTP Content Coding",
      "section_title": true,
      "ja": "2.「aes128gcm」HTTPコンテンツコーディング"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" HTTP content coding indicates that a payload has been encrypted using Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM) as identified as AEAD_AES_128_GCM in [RFC5116], Section 5.1. The AEAD_AES_128_GCM algorithm uses a 128-bit content-encryption key.",
      "ja": "「aes128gcm」HTTPコンテンツの符号化は、[RFC5116]にAEAD_AES_128_GCMとして識別されるペイロードは、ガロア/カウンタ・モード（GCM）でのAdvanced Encryption Standard（AES）を使用して、セクション5.1を暗号化されていることを示しています。 AEAD_AES_128_GCMアルゴリズムは、128ビットのコンテンツ暗号化キーを使用しています。"
    },
    {
      "indent": 3,
      "text": "Using this content coding requires knowledge of a key. How this key is acquired is not defined in this document.",
      "ja": "このコンテンツコーディングを使用すると、キーの知識が必要です。どのように取得され、このキーは、このドキュメントで定義されていません。"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding uses a single fixed set of encryption primitives. Cipher agility is achieved by defining a new content-coding scheme. This ensures that only the HTTP Accept-Encoding header field is necessary to negotiate the use of encryption.",
      "ja": "「aes128gcm」コンテンツの符号化は、暗号化プリミティブの単一の固定セットを使用しています。暗号敏捷性は、新しいコンテンツ符号化方式を定義することによって達成されます。これは、HTTPのAccept-エンコーディングをヘッダフィールドは、暗号化の使用を交渉する必要があることを保証します。"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding uses a fixed record size. The final encoding consists of a header (see Section 2.1) and zero or more fixed-size encrypted records; the final record can be smaller than the record size.",
      "ja": "「aes128gcm」コンテンツコーディングは、固定されたレコードサイズを使用しています。最終的な符号化は、ヘッダ（セクション2.1を参照）、ゼロまたは複数の固定サイズの暗号化されたレコードから成ります。最後のレコードがレコードサイズよりも小さくすることができます。"
    },
    {
      "indent": 3,
      "text": "The record size determines the length of each portion of plaintext that is enciphered. The record size (\"rs\") is included in the content-coding header (see Section 2.1).",
      "ja": "レコードサイズが暗号化される平文の各部分の長さを決定します。レコードサイズ（「RS」）が、コンテンツ符号化ヘッダに含まれる（セクション2.1参照）。"
    },
    {
      "indent": 3,
      "text": "+-----------+             content\n|   data    |             any length up to rs-17 octets\n+-----------+\n     |\n     v\n+-----------+-----+       add a delimiter octet (0x01 or 0x02)\n|   data    | pad |       then 0x00-valued octets to rs-16\n+-----------+-----+       (or less on the last record)\n         |\n         v\n+--------------------+    encrypt with AEAD_AES_128_GCM;\n|    ciphertext      |    final size is rs;\n+--------------------+    the last record can be smaller",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AEAD_AES_128_GCM produces ciphertext 16 octets longer than its input plaintext. Therefore, the unencrypted content of each record is shorter than the record size by 16 octets. Valid records always contain at least a padding delimiter octet and a 16-octet authentication tag.",
      "ja": "AEAD_AES_128_GCMは、その入力平文よりも16オクテット長い暗号文を生成します。したがって、各レコードの暗号化されていないコンテンツは、16個のオクテットによってレコードサイズよりも短くなっています。有効なレコードは常に、少なくともパディング区切りオクテットと16オクテットの認証タグが含まれています。"
    },
    {
      "indent": 3,
      "text": "Each record contains a single padding delimiter octet followed by any number of zero octets. The last record uses a padding delimiter octet set to the value 2, all other records have a padding delimiter octet value of 1.",
      "ja": "各レコードは、ゼロオクテットの任意の数字が続く単一のパディング区切りオクテットが含まれています。最後のレコードの値が2に設定されパディング区切りオクテットを使用して、他のすべてのレコードが1のパディング区切りオクテット値を持っています。"
    },
    {
      "indent": 3,
      "text": "On decryption, the padding delimiter is the last non-zero-valued octet of the record. A decrypter MUST fail if the record contains no non-zero octet. A decrypter MUST fail if the last record contains a padding delimiter with a value other than 2 or if any record other than the last contains a padding delimiter with a value other than 1.",
      "ja": "復号化では、パディング区切り文字は、レコードの最後の非ゼロ値のオクテットです。レコードは何の非ゼロのオクテットが含まれていない場合解読が失敗しなければなりません。最後のレコードが2未満又は最後以外のすべてのレコードが1以外の値でパディング区切り文字が含まれている場合は他の値でパディング区切り文字が含まれている場合、解読は失敗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The nonce for each record is a 96-bit value constructed from the record sequence number and the input-keying material. Nonce derivation is covered in Section 2.3.",
      "ja": "各レコードのノンスは、レコードシーケンス番号と入力キーイング材料から構成される96ビットの値です。ノンス導出は、第2.3節で覆われています。"
    },
    {
      "indent": 3,
      "text": "The additional data passed to each invocation of AEAD_AES_128_GCM is a zero-length octet sequence.",
      "ja": "AEAD_AES_128_GCMの各呼び出しに渡される追加データは、長さゼロのオクテット配列です。"
    },
    {
      "indent": 3,
      "text": "A consequence of this record structure is that range requests [RFC7233] and random access to encrypted payload bodies are possible at the granularity of the record size. Partial records at the ends of a range cannot be decrypted. Thus, it is best if range requests start and end on record boundaries. However, note that random access to specific parts of encrypted data could be confounded by the presence of padding.",
      "ja": "このレコード構造の結果は、その範囲要求[RFC7233]と暗号化されたペイロード体へのランダムアクセスは、レコードサイズの単位で可能ですです。範囲の両端の部分レコードを解読することはできません。範囲要求を開始し、レコード境界に終了した場合このように、それがベストです。ただし、暗号化されたデータの特定の部分へのランダムアクセスは、パディングの存在によって混乱することができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Selecting the record size most appropriate for a given situation requires a trade-off. A smaller record size allows decrypted octets to be released more rapidly, which can be appropriate for applications that depend on responsiveness. Smaller records also reduce the additional data required if random access into the ciphertext is needed.",
      "ja": "与えられた状況に最も適したレコードサイズを選択すると、トレードオフが必要です。小さなレコードサイズは、応答性に依存するアプリケーションに適していることができ、復号化されたオクテットがより迅速に解放することができます。小さいレコードも暗号文へのランダムアクセスが必要な場合に必要な追加データを削減します。"
    },
    {
      "indent": 3,
      "text": "Applications that don't depend on streaming, random access, or arbitrary padding can use larger records, or even a single record. A larger record size reduces processing and data overheads.",
      "ja": "ストリーミング、ランダムアクセス、または任意のパディングに依存しないアプリケーションは、より大きな記録、あるいは単一のレコードを使用することができます。より大きなレコード・サイズは、処理及びデータオーバーヘッドを減少させます。"
    },
    {
      "indent": 0,
      "text": "2.1. Encryption Content-Coding Header",
      "section_title": true,
      "ja": "2.1. 暗号化コンテンツのコーディングヘッダー"
    },
    {
      "indent": 3,
      "text": "The content coding uses a header block that includes all parameters needed to decrypt the content (other than the key). The header block is placed in the body of a message ahead of the sequence of records.",
      "ja": "コンテンツ符号化は、（キー以外の）コンテンツを解読するために必要なすべてのパラメータを含むヘッダブロックを使用します。ヘッダブロックが先行レコードのシーケンスのメッセージの本体内に配置されます。"
    },
    {
      "indent": 3,
      "text": "+-----------+--------+-----------+---------------+\n| salt (16) | rs (4) | idlen (1) | keyid (idlen) |\n+-----------+--------+-----------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "salt: The \"salt\" parameter comprises the first 16 octets of the \"aes128gcm\" content-coding header. The same \"salt\" parameter value MUST NOT be reused for two different payload bodies that have the same input-keying material; generating a random salt for every application of the content coding ensures that content-encryption key reuse is highly unlikely.",
      "ja": "塩：「塩」パラメータが「aes128gcm」コンテンツ符号化ヘッダの最初の16個のオクテットを含みます。同じ「塩」パラメータの値が同じ入力鍵材料を有する2人の異なるペイロード体に再利用してはいけません。コンテンツ符号化のすべてのアプリケーションのためのランダムな塩を生成するコンテンツ暗号鍵の再利用が非常に低いであることを保証します。"
    },
    {
      "indent": 3,
      "text": "rs: The \"rs\" or record size parameter contains an unsigned 32-bit integer in network byte order that describes the record size in octets. Note that it is, therefore, impossible to exceed the 2^36-31 limit on plaintext input to AEAD_AES_128_GCM. Values smaller than 18 are invalid.",
      "ja": "RS：「RS」またはレコードサイズパラメータはオクテットでレコードサイズを記述したネットワークバイトオーダーで32ビットの符号なし整数が含まれています。従って、AEAD_AES_128_GCMに平文入力に2 ^ 36から31の限界を超えることは不可能であることに留意されたいです。 18より小さい値は無効です。"
    },
    {
      "indent": 3,
      "text": "idlen: The \"idlen\" parameter is an unsigned 8-bit integer that defines the length of the \"keyid\" parameter.",
      "ja": "idlen：「idlen」パラメータが「鍵ID」パラメータの長さを定義する、符号なし8ビット整数です。"
    },
    {
      "indent": 3,
      "text": "keyid: The \"keyid\" parameter can be used to identify the keying material that is used. This field is the length determined by the \"idlen\" parameter. Recipients that receive a message are expected to know how to retrieve keys; the \"keyid\" parameter might be input to that process. A \"keyid\" parameter SHOULD be a UTF-8-encoded [RFC3629] string, particularly where the identifier might need to be rendered in a textual form.",
      "ja": "キーID：「鍵ID」パラメータが使用されている鍵素材を識別するために使用することができます。このフィールドは、「idlen」パラメータによって決定される長さです。メッセージを受け取る受信者は、キーを取得する方法を知っていると予想されます。 「キーID」パラメータは、そのプロセスに入力することがあります。 「鍵ID」パラメータは、識別子はテキスト形式でレンダリングする必要がある場合があり、特にUTF-8でエンコードされた[RFC3629]の文字列でなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Content-Encryption Key Derivation",
      "section_title": true,
      "ja": "2.2. コンテンツの暗号化鍵の導出"
    },
    {
      "indent": 3,
      "text": "In order to allow the reuse of keying material for multiple different HTTP messages, a content-encryption key is derived for each message. The content-encryption key is derived from the \"salt\" parameter using the HMAC-based key derivation function (HKDF) described in [RFC5869] using the SHA-256 hash algorithm [FIPS180-4].",
      "ja": "複数の異なるHTTPメッセージのための鍵材料の再利用を可能にするために、コンテンツ暗号化キーは、各メッセージのために導出されます。コンテンツ暗号化キーは、SHA-256ハッシュアルゴリズム[FIPS180-4]を使用して、[RFC5869]に記載HMACベースの鍵導出関数（HKDF）を使用して、「塩」パラメータから導出されます。"
    },
    {
      "indent": 3,
      "text": "The value of the \"salt\" parameter is the salt input to the HKDF. The keying material identified by the \"keyid\" parameter is the input-keying material (IKM) to HKDF. Input-keying material is expected to be provided to recipients separately. The extract phase of HKDF, therefore, produces a pseudorandom key (PRK) as follows:",
      "ja": "「塩」パラメータの値は、HKDFへの塩の入力です。 「鍵ID」パラメータによって識別される鍵材料はHKDFへ入力キーイングマテリアル（IKM）です。入力キーイングマテリアルは、別途受信者に提供されることが期待されます。次のようにHKDFの抽出相は、従って、疑似ランダムキー（PRK）を生成します。"
    },
    {
      "indent": 6,
      "text": "PRK = HMAC-SHA-256 (salt, IKM)",
      "ja": "PRK = HMAC-SHA-256（塩、IKM）"
    },
    {
      "indent": 3,
      "text": "The info parameter to HKDF is set to the ASCII-encoded string \"Content-Encoding: aes128gcm\" and a single zero octet:",
      "ja": "「：aes128gcmコンテンツエンコーディング」と、単一のゼロオクテットHKDFにinfoパラメータは、ASCIIでエンコードされた文字列に設定されています："
    },
    {
      "indent": 6,
      "text": "cek_info = \"Content-Encoding: aes128gcm\" || 0x00",
      "ja": "cek_info = \"コンテンツエンコード：aes128gcm\" || $ 00"
    },
    {
      "indent": 3,
      "text": "Note(1): Concatenation of octet sequences is represented by the \"||\" operator.",
      "ja": "注（1）：オクテット配列の連結は「||」で表されます。オペレーター。"
    },
    {
      "indent": 3,
      "text": "Note(2): The strings used here and in Section 2.3 do not include a terminating 0x00 octet, as is used in some programming languages.",
      "ja": "注（2）：ここでは、セクション2.3で使用される文字列は、いくつかのプログラミング言語で使用されているように、終端0x00のオクテットは含まれていません。"
    },
    {
      "indent": 3,
      "text": "AEAD_AES_128_GCM requires a 16-octet (128-bit) content-encryption key (CEK), so the length (L) parameter to HKDF is 16. The second step of HKDF can, therefore, be simplified to the first 16 octets of a single HMAC:",
      "ja": "AEAD_AES_128_GCMは、16オクテット（128ビット）のコンテンツ暗号鍵（CEK）を必要とするので、HKDFの長さ（L）パラメータはHKDFの第2のステップは、従って、単一の最初の16個のオクテットに簡略化することができる16です。 HMAC："
    },
    {
      "indent": 6,
      "text": "CEK = HMAC-SHA-256(PRK, cek_info || 0x01)",
      "ja": "CEK = HMAC-SHA-256（PRK、||は0x01 cek_info）"
    },
    {
      "indent": 0,
      "text": "2.3. Nonce Derivation",
      "section_title": true,
      "ja": "2.3. 使節導出"
    },
    {
      "indent": 3,
      "text": "The nonce input to AEAD_AES_128_GCM is constructed for each record. The nonce for each record is a 12-octet (96-bit) value that is derived from the record sequence number, input-keying material, and \"salt\" parameter.",
      "ja": "AEAD_AES_128_GCMへのナンス入力は、各レコードのために構成されています。各レコードのノンスは、レコードシーケンス番号、入力キーイング材料、及び「塩」パラメータから導出された12オクテット（96ビット）の値です。"
    },
    {
      "indent": 3,
      "text": "The input-keying material and \"salt\" parameter are input to HKDF with different info and length (L) parameters.",
      "ja": "入力キーイングマテリアル及び「塩」パラメータは異なる情報と長さ（L）パラメータでHKDFに入力されます。"
    },
    {
      "indent": 3,
      "text": "The length (L) parameter is 12 octets. The info parameter for the nonce is the ASCII-encoded string \"Content-Encoding: nonce\", terminated by a single zero octet:",
      "ja": "長さ（L）パラメータは12オクテットです。単一のゼロオクテットによって終了：「ナンスコンテンツエンコーディング」、ナンスのためのinfoパラメータは、ASCIIエンコードされた文字列です。"
    },
    {
      "indent": 6,
      "text": "nonce_info = \"Content-Encoding: nonce\" || 0x00",
      "ja": "nonce_info =「コンテンツエンコード：ナンス」|| $ 00"
    },
    {
      "indent": 3,
      "text": "The result is combined with the record sequence number -- using exclusive or -- to produce the nonce. The record sequence number (SEQ) is a 96-bit unsigned integer in network byte order that starts at zero.",
      "ja": "nonceを生成する - 排他的論理和を用いた - 結果は、レコードシーケンス番号と組み合わされます。レコード・シーケンス番号（SEQ）がゼロから始まり、ネットワークバイト順で96ビットの符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "Thus, the final nonce for each record is a 12-octet value:",
      "ja": "したがって、各レコードの最終的なノンスは、12オクテットの値です。"
    },
    {
      "indent": 6,
      "text": "NONCE = HMAC-SHA-256(PRK, nonce_info || 0x01) XOR SEQ",
      "ja": "NONCE = HMAC-SHA-256（PRK、0x01の|| nonce_info）のXOR SEQ"
    },
    {
      "indent": 3,
      "text": "This nonce construction prevents removal or reordering of records.",
      "ja": "このナンス構造は、レコードの削除や並べ替えを防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "3. Examples",
      "section_title": true,
      "ja": "3.例"
    },
    {
      "indent": 3,
      "text": "This section shows a few examples of the encrypted-content coding.",
      "ja": "このセクションでは、暗号化されたコンテンツ符号化のいくつかの例を示します。"
    },
    {
      "indent": 3,
      "text": "Note: All binary values in the examples in this section use base64 encoding with URL and filename safe alphabet [RFC4648]. This includes the bodies of requests. Whitespace and line wrapping is added to fit formatting constraints.",
      "ja": "注意：URLやファイル名安全なアルファベット[RFC4648]でこのセクションを使用するbase64エンコードの例のすべてのバイナリ値を。これは、リクエストの遺体が含まれています。空白や行の折り返しは、フォーマット制約に合わせて追加されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Encryption of a Response",
      "section_title": true,
      "ja": "3.1. レスポンスの暗号化"
    },
    {
      "indent": 3,
      "text": "Here, a successful HTTP GET response has been encrypted. This uses a record size of 4096 octets and no padding (just the single-octet padding delimiter), so only a partial record is present. The input-keying material is identified by an empty string (that is, the \"keyid\" field in the header is zero octets in length).",
      "ja": "ここでは、成功したHTTPのGET応答は暗号化されています。これは、4096オクテットのレコードサイズとなしパディング（ちょうど単一オクテットパディングデリミタ）を使用するため、部分的にのみレコードが存在しています。入力鍵材料（つまり、ヘッダ内の「鍵ID」フィールドは、長さがゼロのオクテットである）空の文字列によって識別されます。"
    },
    {
      "indent": 3,
      "text": "The encrypted data in this example is the UTF-8-encoded string \"I am the walrus\". The input-keying material is the value \"yqdlZ-tYemfogSmv7Ws5PQ\" (in base64url). The 54-octet content body contains a single record and is shown here using 71 base64url characters for presentation reasons.",
      "ja": "この例では暗号化されたデータは、「私はセイウチだ」UTF-8でエンコードされた文字列です。入力キーイングマテリアルは、（base64urlで）「yqdlZ-tYemfogSmv7Ws5PQ」の値です。 54オクテットのコンテンツ本体は、単一のレコードが含まれており、プレゼンテーションの理由で71個のbase64url文字を使用して、ここに示されています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Content-Type: application/octet-stream Content-Length: 54 Content-Encoding: aes128gcm",
      "ja": "HTTP / 1.1 200 OKのContent-Type：アプリケーション/オクテットストリームのContent-Length：54コンテンツエンコード：aes128gcm"
    },
    {
      "indent": 3,
      "text": "I1BsxtFttlv3u_Oo94xnmwAAEAAA-NAVub2qFgBEuQKRapoZu-IxkIva3MEB1PD-ly8Thjg",
      "ja": "I1BsxtFttlv3u_Oo94xnmwAAEAAA-NAVub2qFgBEuQKRapoZu-IxkIva3MEB1PD-ly8Thjg"
    },
    {
      "indent": 3,
      "text": "Note that the media type has been changed to \"application/octet-stream\" to avoid exposing information about the content. Alternatively (and equivalently), the Content-Type header field can be omitted.",
      "ja": "メディアタイプがコンテンツについての情報を公開しないようするために、「アプリケーション/オクテットストリーム」に変更されていることに注意してください。代替的に（と同等）、Content-Typeヘッダフィールドを省略することができます。"
    },
    {
      "indent": 3,
      "text": "Intermediate values for this example (all shown using base64url):",
      "ja": "この例の中間値（全てbase64urlを使用して示されています）。"
    },
    {
      "indent": 3,
      "text": "salt (from header) = I1BsxtFttlv3u_Oo94xnmw PRK = zyeH5phsIsgUyd4oiSEIy35x-gIi4aM7y0hCF8mwn9g CEK = _wniytB-ofscZDh4tbSjHw NONCE = Bcs8gkIRKLI8GeI8 unencrypted data = SSBhbSB0aGUgd2FscnVzAg",
      "ja": "（ヘッダから）塩= I1BsxtFttlv3u_Oo94xnmw PRK = zyeH5phsIsgUyd4oiSEIy35x-gIi4aM7y0hCF8mwn9g CEK = _wniytB-ofscZDh4tbSjHw NONCE = Bcs8gkIRKLI8GeI8暗号化されていないデータ= SSBhbSB0aGUgd2FscnVzAg"
    },
    {
      "indent": 0,
      "text": "3.2. Encryption with Multiple Records",
      "section_title": true,
      "ja": "3.2. 複数のレコードでの暗号化"
    },
    {
      "indent": 3,
      "text": "This example shows the same message with input-keying material of \"BO3ZVPxUlnLORbVGMpbT1Q\". In this example, the plaintext is split into records of 25 octets each (that is, the \"rs\" field in the header is 25). The first record includes one 0x00 padding octet. This means that there are 7 octets of message in the first record and 8 in the second. A key identifier of the UTF-8-encoded string \"a1\" is also included in the header.",
      "ja": "この例では、「BO3ZVPxUlnLORbVGMpbT1Q」の入力キーイングマテリアルと同じメッセージを示します。この例では、平文（つまり、ヘッダ内の「RS」フィールドは25である）25オクテットそれぞれのレコードに分割されます。最初のレコードは1つの0x00でパディングオクテットを含んでいます。これにより、第2の最初のレコード及び8におけるメッセージの7つのオクテットが存在することを意味します。 UTF-8でエンコードされた文字列「A1」のキー識別子は、ヘッダに含まれています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Content-Length: 73 Content-Encoding: aes128gcm",
      "ja": "HTTP / 1.1 200 OKのContent-Length：73コンテンツエンコード：aes128gcm"
    },
    {
      "indent": 3,
      "text": "uNCkWiNYzKTnBN9ji3-qWAAAABkCYTHOG8chz_gnvgOqdGYovxyjuqRyJFjEDyoF 1Fvkj6hQPdPHI51OEUKEpgz3SsLWIqS_uA",
      "ja": "uNCkWiNYzKTnBN9ji3-qWAAAABkCYTHOG8chz_gnvgOqdGYovxyjuqRyJFjEDyoF 1Fvkj6hQPdPHI51OEUKEpgz3SsLWIqS_uA"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This mechanism assumes the presence of a key management framework that is used to manage the distribution of keys between valid senders and receivers. Defining key management is part of composing this mechanism into a larger application, protocol, or framework.",
      "ja": "このメカニズムは、有効な送信者と受信者の間で鍵の配布を管理するために使用された鍵管理フレームワークの存在を前提としています。鍵管理を定義する大規模なアプリケーション、プロトコル、またはフレームワークにこの機構を構成の一部です。"
    },
    {
      "indent": 3,
      "text": "Implementation of cryptography -- and key management in particular -- can be difficult. For instance, implementations need to account for the potential for exposing keying material on side channels, such as might be exposed by the time it takes to perform a given operation. The requirements for a good implementation of cryptographic algorithms can change over time.",
      "ja": "特にキー管理 -   - 暗号の実装が困難な場合があります。例えば、実装は、それが特定の操作を実行するのに要する時間によって露出されるかもしれないようなサイドチャネル上でキーイング材料を露出させるための可能性を考慮する必要があります。暗号アルゴリズムの良い実装のための要件は、時間の経過とともに変化することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. Automatic Decryption",
      "section_title": true,
      "ja": "4.1. 自動解読"
    },
    {
      "indent": 3,
      "text": "As a content coding, a \"aes128gcm\" content coding might be automatically removed by a receiver in a way that is not obvious to the ultimate consumer of a message. Recipients that depend on content-origin authentication using this mechanism MUST reject messages that don't include the \"aes128gcm\" content coding.",
      "ja": "コンテンツ符号化として、「aes128gcm」コンテンツコードが自動的にメッセージの最終的な消費者には自明ではない方法で、受信機によって除去される可能性があります。このメカニズムを使用したコンテンツ起点認証に依存して受信者が「aes128gcm」コンテンツコーディングを含まないメッセージを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Truncation",
      "section_title": true,
      "ja": "4.2. メッセージ切り捨て"
    },
    {
      "indent": 3,
      "text": "This content encoding is designed to permit the incremental processing of large messages. It also permits random access to plaintext in a limited fashion. The content encoding permits a receiver to detect when a message is truncated.",
      "ja": "このコンテンツのエンコーディングは、大きなメッセージの増分処理を可能にするように設計されています。また、限られた方法で平文へのランダムアクセスが可能になります。コンテンツのエンコーディングは、メッセージが切り捨てられたときに検出するために受信機を許容します。"
    },
    {
      "indent": 3,
      "text": "A partially delivered message MUST NOT be processed as though the entire message was successfully delivered. For instance, a partially delivered message cannot be cached as though it were complete.",
      "ja": "全体のメッセージが正常に配信されたかのように部分的に配信されたメッセージが処理されてはなりません。それが完了したかのように例えば、部分的に配信されたメッセージをキャッシュすることはできません。"
    },
    {
      "indent": 3,
      "text": "An attacker might exploit willingness to process partial messages to cause a receiver to remain in a specific intermediate state. Implementations performing processing on partial messages need to ensure that any intermediate processing states don't advantage an attacker.",
      "ja": "攻撃者は、特定の中間状態のままにするために受信機を引き起こすために、部分的メッセージを処理する意欲を悪用する可能性があります。部分的なメッセージの処理を実行する実装は、任意の中間処理状態は、攻撃者が有利していないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Key and Nonce Reuse",
      "section_title": true,
      "ja": "4.3. キーとナンスの再利用"
    },
    {
      "indent": 3,
      "text": "Encrypting different plaintext with the same content-encryption key and nonce in AES-GCM is not safe [RFC5116]. The scheme defined here uses a fixed progression of nonce values. Thus, a new content-encryption key is needed for every application of the content coding. Since input-keying material can be reused, a unique \"salt\" parameter is needed to ensure that a content-encryption key is not reused.",
      "ja": "AES-GCMで同じコンテンツ暗号化キーとナンスと異なる平文を暗号化する安全な[RFC5116]ではありません。ここで定義されたスキームは、一回だけの値の一定の進行を使用しています。このように、新しいコンテンツ暗号化キーは、コンテンツ・コーディングのすべてのアプリケーションのために必要とされます。入力-鍵材料を再利用することができますので、独特の「塩」パラメータは、コンテンツ暗号化キーが再利用されていないことを保証するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "If a content-encryption key is reused -- that is, if input-keying material and \"salt\" parameter are reused -- this could expose the plaintext and the authentication key, nullifying the protection offered by encryption. Thus, if the same input-keying material is reused, then the \"salt\" parameter MUST be unique each time. This ensures that the content-encryption key is not reused. An implementation SHOULD generate a random \"salt\" parameter for every message.",
      "ja": "コンテンツ暗号化キーが再利用された場合 - 入力キーイングマテリアルと「塩」パラメータが再利用されている場合には、ある - これは、暗号化によって提供される保護を無効化し、平文と認証キーを公開することができます。同じ入力鍵材料が再利用された場合したがって、次に「塩」パラメータは、各時間一意でなければなりません。これは、コンテンツ暗号化キーが再利用されていないことを保証します。実装は、メッセージごとにランダムな「塩」パラメータを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Data Encryption Limits",
      "section_title": true,
      "ja": "4.4. データ暗号化の制限"
    },
    {
      "indent": 3,
      "text": "There are limits to the data that AEAD_AES_128_GCM can encipher. The maximum value for the record size is limited by the size of the \"rs\" field in the header (see Section 2.1), which ensures that the 2^36-31 limit for a single application of AEAD_AES_128_GCM is not reached [RFC5116]. In order to preserve a 2^-40 probability of indistinguishability under chosen plaintext attack (IND-CPA), the total amount of plaintext that can be enciphered with the key derived from the same input-keying material and salt MUST be less than 2^44.5 blocks of 16 octets [AEBounds].",
      "ja": "AEAD_AES_128_GCMを暗号化することができるデータには制限があります。レコードサイズの最大値は、ヘッダ内の「RS」フィールドのサイズによって制限されるAEAD_AES_128_GCMの単一のアプリケーションのための2 ^ 36から31制限は[RFC5116]を達していないことを保証する、（セクション2.1を参照）。選択平文攻撃（IND-CPA）の下で識別不能の2 ^ -40確率を維持するために、同一の入力キーイングマテリアル及び塩に由来する鍵で暗号化することができる平文の総量は^ 2未満でなければなりません16オクテット[AEBounds]の44.5ブロック。"
    },
    {
      "indent": 3,
      "text": "If the record size is a multiple of 16 octets, this means that 398 terabytes can be encrypted safely, including padding and overhead. However, if the record size is not a multiple of 16 octets, the total amount of data that can be safely encrypted is reduced because partial AES blocks are encrypted. The worst case is a record size of 18 octets, for which at most 74 terabytes of plaintext can be encrypted, of which at least half is padding.",
      "ja": "レコードサイズは、16オクテットの倍数である場合、これは398テラバイトのパディングとオーバーヘッドを含め、安全に暗号化することができることを意味します。しかし、レコード・サイズが16オクテットの倍数でない場合は、部分的なAESブロックが暗号化されるので、安全に暗号化できるデータの総量が減少します。最悪の場合には、平文の最大で74件のテラバイトの少なくとも半分がパディングとなっている、暗号化することができたために18オクテットのレコードサイズです。"
    },
    {
      "indent": 0,
      "text": "4.5. Content Integrity",
      "section_title": true,
      "ja": "4.5. コンテンツの整合性"
    },
    {
      "indent": 3,
      "text": "This mechanism only provides content-origin authentication. The authentication tag only ensures that an entity with access to the content-encryption key produced the encrypted data.",
      "ja": "このメカニズムは、コンテンツのみ起点認証を提供します。認証タグは、コンテンツ暗号化キーへのアクセス権を持つエンティティが暗号化されたデータを生成することを保証します。"
    },
    {
      "indent": 3,
      "text": "Any entity with the content-encryption key can, therefore, produce content that will be accepted as valid. This includes all recipients of the same HTTP message.",
      "ja": "コンテンツ暗号化キーを持つ任意のエンティティは、それゆえ、有効なものとして受け入れられるコンテンツを生成することができます。これは、同じHTTPメッセージのすべての受信者が含まれています。"
    },
    {
      "indent": 3,
      "text": "Furthermore, any entity that is able to modify both the Content-Encoding header field and the HTTP message body can replace the contents. Without the content-encryption key or the input-keying material, modifications to, or replacement of, parts of a payload body are not possible.",
      "ja": "また、コンテンツ符号化ヘッダ・フィールドとHTTPメッセージボディの両方を変更することができる任意のエンティティは、コンテンツを置き換えることができます。コンテンツ暗号化キーまたは入力キーイングマテリアル、に変更、または交換することなく、ペイロード本体の部分は不可能です。"
    },
    {
      "indent": 0,
      "text": "4.6. Leaking Information in Header Fields",
      "section_title": true,
      "ja": "4.6. ヘッダーフィールドに情報をリークします"
    },
    {
      "indent": 3,
      "text": "Because only the payload body is encrypted, information exposed in header fields is visible to anyone who can read the HTTP message. This could expose side-channel information.",
      "ja": "ペイロードのみ本体が暗号化されているため、ヘッダ・フィールドに露出情報は、HTTPメッセージを読むことができる人に見えます。これは、サイドチャネル情報を公開することができます。"
    },
    {
      "indent": 3,
      "text": "For example, the Content-Type header field can leak information about the payload body.",
      "ja": "例えば、Content-Typeヘッダフィールドは、ペイロード本体に関する情報を漏洩することができます。"
    },
    {
      "indent": 3,
      "text": "There are a number of strategies available to mitigate this threat, depending upon the application's threat model and the users' tolerance for leaked information:",
      "ja": "アプリケーションの脅威モデルによっては、この脅威を軽減するために利用できる多くの戦略や漏洩した情報に対するユーザーの公差があります。"
    },
    {
      "indent": 3,
      "text": "1. Determine that it is not an issue. For example, if it is expected that all content stored will be \"application/json\", or another very common media type, exposing the Content-Type header field could be an acceptable risk.",
      "ja": "1.それは問題ではないことを決定します。例えば、それはすべてのコンテンツが格納されていることが予想される場合、「アプリケーション/ JSON」である、または別の非常に一般的なメディアタイプ、Content-Typeヘッダフィールドを露光することは許容されるリスクがあり得るであろう。"
    },
    {
      "indent": 3,
      "text": "2. If it is considered sensitive information and it is possible to determine it through other means (e.g., out of band, using hints in other representations, etc.), omit the relevant headers, and/ or normalize them. In the case of Content-Type, this could be accomplished by always sending Content-Type: application/octet-stream (the most generic media type), or no Content-Type at all.",
      "ja": "2.それは（等、他の表現でヒントを使用して、帯域外例えば、）機密情報と考えられ、他の手段によってそれを決定することが可能である場合、関連するヘッダーを省略し、及び/又はそれらを正規化します。アプリケーション/ octet-streamの（最も一般的なメディアタイプ）、またはまったくのContent-Type：のContent-Typeの場合、これは常にのContent-Typeを送信することにより達成することができます。"
    },
    {
      "indent": 3,
      "text": "3. If it is considered sensitive information and it is not possible to convey it elsewhere, encapsulate the HTTP message using the application/http media type (see Section 8.3.2 of [RFC7230]), encrypting that as the payload of the \"outer\" message.",
      "ja": "3.これは「外側のペイロードとしてそれを暗号化し、（[RFC7230]のセクション8.3.2を参照）機密情報と考えられ、別の場所に搬送することができない、アプリケーション/ HTTPメディアタイプを使用してHTTPメッセージをカプセル化している場合\"メッセージ。"
    },
    {
      "indent": 0,
      "text": "4.7. Poisoning Storage",
      "section_title": true,
      "ja": "4.7. 中毒ストレージ"
    },
    {
      "indent": 3,
      "text": "This mechanism only offers data-origin authentication; it does not perform authentication or authorization of the message creator, which could still need to be performed (e.g., by HTTP authentication [RFC7235]).",
      "ja": "このメカニズムは、データ起点認証を提供しています。それはまだ（例えば、HTTP認証[RFC7235]で）実行する必要がある可能性があり、メッセージの作成者の認証または許可を実行しません。"
    },
    {
      "indent": 3,
      "text": "This is especially relevant when an HTTP PUT request is accepted by a server without decrypting the payload; if the request is unauthenticated, it becomes possible for a third party to deny service and/or poison the store.",
      "ja": "HTTPのPUTリクエストがペイロードを復号化することなく、サーバーによって受け入れられる場合に特に適切です。要求が認証されていないの場合は、第三者がサービスを拒否および/またはストアを毒殺することが可能となります。"
    },
    {
      "indent": 0,
      "text": "4.8. Sizing and Timing Attacks",
      "section_title": true,
      "ja": "4.8. サイジングとタイミング攻撃"
    },
    {
      "indent": 3,
      "text": "Applications using this mechanism need to be aware that the size of encrypted messages, as well as their timing, HTTP methods, URIs and so on, may leak sensitive information. See, for example, [NETFLIX] or [CLINIC].",
      "ja": "このメカニズムを使用するアプリケーションは、その上の暗号化されたメッセージのサイズ、並びにそのタイミング、HTTPメソッド、URIとは、機密情報を漏洩する可能性があることに注意する必要があります。 [NETFLIX]または[クリニック]、例えば、参照してください。"
    },
    {
      "indent": 3,
      "text": "This risk can be mitigated through the use of the padding that this mechanism provides. Alternatively, splitting up content into segments and storing them separately might reduce exposure. HTTP/2 [RFC7540] combined with TLS [RFC5246] might be used to hide the size of individual messages.",
      "ja": "このリスクは、このメカニズムが提供パディングを使用して緩和することができます。また、セグメントにコンテンツを分割し、それらを別々に保存することはリスクを減らす可能性があります。 TLS [RFC5246]と組み合わせるHTTP / 2 [RFC7540]は、個々のメッセージのサイズを隠すために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Developing a padding strategy is difficult. A good padding strategy can depend on context. Common strategies include padding to a small set of fixed lengths, padding to multiples of a value, or padding to powers of 2. Even a good strategy can still cause size information to leak if processing activity of a recipient can be observed. This is especially true if the trailing records of a message contain only padding. Distributing non-padding data across records is recommended to avoid leaking size information.",
      "ja": "パディング戦略を開発することは困難です。良いパディング戦略は、文脈に依存することができます。一般的な戦略は、優れた戦略は依然として受信者の処理活性を観察することができる場合サイズ情報が漏洩する可能性があっても2の累乗に固定された長さの小さなセットにパディング値の倍数にパディング、またはパディングを含みます。メッセージの末尾のレコードが唯一のパディングが含まれている場合、これは特にそうです。レコードの間で非パディングデータを配布することは漏れサイズ情報を避けることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. The \"aes128gcm\" HTTP Content Coding",
      "section_title": true,
      "ja": "5.1.  「aes128gcm」HTTPコンテンツのコーディング"
    },
    {
      "indent": 3,
      "text": "This memo registers the \"aes128gcm\" HTTP content coding in the \"HTTP Content Coding Registry\", as detailed in Section 2.",
      "ja": "このメモは、第2節で説明するように、「レジストリをコーディングHTTPコンテンツ」の「aes128gcm」HTTPコンテンツのコーディングを登録します。"
    },
    {
      "indent": 3,
      "text": "o Name: aes128gcm",
      "ja": "O名：aes128gcm"
    },
    {
      "indent": 3,
      "text": "o Description: AES-GCM encryption with a 128-bit content-encryption key",
      "ja": "O説明：128ビットのコンテンツ暗号鍵でAES-GCM暗号化"
    },
    {
      "indent": 3,
      "text": "o Reference: this specification",
      "ja": "Oリファレンス：この仕様"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS180-4] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS180-4, August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[FIPS180-4]米国国立標準技術研究所、 \"セキュアハッシュ規格（SHS）\"、FIPS PUB 180-4の、DOI 10.6028 / NIST.FIPS180-4、2015年8月、<http://nvlpubs.nist.gov/ nistpubs / FIPS / NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <http://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116]マグリュー、D.、 \"認証暗号化のためのインタフェースとアルゴリズム\"、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<http://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <http://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H.、およびP. Eronen、 \"HMACベースの抽出物と、拡大鍵導出関数（HKDF）\"、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<のhttp：//www.rfc-editor .ORG /情報/ rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[AEBounds] Luykx, A. and K. Paterson, \"Limits on Authenticated Encryption Use in TLS\", March 2016, <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.",
      "ja": "[AEBounds] Luykx、A.およびK.パターソン、 \"TLSで暗号化認証の使用上の制限\"、2016年3月、<http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>。"
    },
    {
      "indent": 3,
      "text": "[CLINIC] Miller, B., Huang, L., Joseph, A., and J. Tygar, \"I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis\", DOI 10.1007/978-3-319-08506-7_8, March 2014, <https://arxiv.org/abs/1403.0297>.",
      "ja": "[クリニック]・ミラー、B.、黄、L.、ジョセフ、A.、およびJ. Tygar、 \"あなたがクリニックに行ってきましたなぜ私が知っている：リスクおよびHTTPSトラフィック分析の実現\"、DOI 10.1007 / 978-3-319 -08506-7_8、2014年3月、<https://arxiv.org/abs/1403.0297>。"
    },
    {
      "indent": 3,
      "text": "[NETFLIX] Reed, A. and M. Kranch, \"Identifying HTTPS-Protected Netflix Videos in Real-Time\", Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy CODASPY '17, DOI 10.1145/3029806.3029821, 2017.",
      "ja": "[NETFLIX]リード、A.とM. Kranch、「リアルタイムにHTTPSで保護されたNetflixの動画の識別」、データとアプリケーションのセキュリティとプライバシーCODASPY '17、DOI 10.1145 / 3029806.3029821、2017会議第7回ACMの議事。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, DOI 10.17487/RFC4880, November 2007, <http://www.rfc-editor.org/info/rfc4880>.",
      "ja": "[RFC4880]カラス、J.、Donnerhacke、L.、フィニー、H.、ショー、D.、およびR.セイヤー、 \"OpenPGPのメッセージフォーマット\"、RFC 4880、DOI 10.17487 / RFC4880、2007年11月、<のhttp：// www.rfc-editor.org/info/rfc4880>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, <http://www.rfc-editor.org/info/rfc5652>.",
      "ja": "[RFC5652] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、DOI 10.17487 / RFC5652、2009年9月、<http://www.rfc-editor.org/info/rfc5652>。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、DOI 10.17487 / RFC7233 6月2014年、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M.及びJ.ヒルデブランド、 \"JSONウェブ暗号化（JWE）\"、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<http://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7540] Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext Transfer Protocol Version 2 (HTTP/2)\", RFC 7540, DOI 10.17487/RFC7540, May 2015, <http://www.rfc-editor.org/info/rfc7540>.",
      "ja": "[RFC7540] Belshe、M.、ペオン、R.、およびM.トムソン、エド、 \"ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）\"、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、<のhttp：// www.rfc-editor.org/info/rfc7540>。"
    },
    {
      "indent": 3,
      "text": "[XMLENC] Eastlake, D., Reagle, J., Hirsch, F., and T. Roessler, \"XML Encryption Syntax and Processing Version 1.1\", World Wide Web Consortium Recommendation REC-xmlenc-core1-20130411, April 2013, <http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411>.",
      "ja": "[XMLENC]イーストレイク、D.、Reagle、J.、ハーシュ、F.、およびT.レスラー、 \"XML暗号化構文と処理バージョン1.1\"、World Wide Web Consortium（W3C）の勧告REC-xmlenc-core1-20130411、2013年4月、< http://www.w3.org/TR/2013/REC-xmlenc-core1-20130411>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. JWE Mapping",
      "ja": "付録A. JWEマッピング"
    },
    {
      "indent": 3,
      "text": "The \"aes128gcm\" content coding can be considered as a sequence of JSON Web Encryption (JWE) [RFC7516] objects, each corresponding to a single fixed-size record that includes trailing padding. The following transformations are applied to a JWE object that might be expressed using the JWE Compact Serialization:",
      "ja": "「aes128gcm」コンテンツコードは、それぞれパディング末尾含む単一の固定サイズのレコードに対応する、JSONのWeb暗号化（JWE）[RFC7516]のオブジェクトのシーケンスとして考えることができます。次の変換はJWEコンパクトシリアル化を使用して表現されるかもしれないJWEオブジェクトに適用されます。"
    },
    {
      "indent": 3,
      "text": "o  The JWE Protected Header is fixed to the value { \"alg\": \"dir\",\n   \"enc\": \"A128GCM\" }, describing direct encryption using AES-GCM\n   with a 128-bit content-encryption key.  This header is not\n   transmitted, it is instead implied by the value of the Content-\n   Encoding header field.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The JWE Encrypted Key is empty, as stipulated by the direct encryption algorithm.",
      "ja": "直接暗号化アルゴリズムによって規定されるO JWE暗号化されたキーは、空です。"
    },
    {
      "indent": 3,
      "text": "o The JWE Initialization Vector (\"iv\") for each record is set to the exclusive-or of the 96-bit record sequence number, starting at zero, and a value derived from the input-keying material (see Section 2.3). This value is also not transmitted.",
      "ja": "各レコードのJWE初期化ベクトル（「IV」）O 0から始まる、排他的論理和の96ビットレコードのシーケンス番号に設定され、入力キーイング材料から導出される値（セクション2.3を参照）。この値は、送信されていません。"
    },
    {
      "indent": 3,
      "text": "o The final value is the concatenated header, JWE Ciphertext, and JWE Authentication Tag, all expressed without base64url encoding. The \".\" separator is omitted, since the length of these fields is known.",
      "ja": "Oの最終的な値は、連結ヘッダ、JWE暗号文、及びJWE認証タグ、全てbase64url符号化なしで発現されます。 「」これらのフィールドの長さが知られているので、セパレータは、省略されています。"
    },
    {
      "indent": 3,
      "text": "Thus, the example in Section 3.1 can be rendered using the JWE Compact Serialization as:",
      "ja": "したがって、セクション3.1の例はとしてJWEコンパクトシリアル化を使用してレンダリングすることができます。"
    },
    {
      "indent": 3,
      "text": "eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..Bcs8gkIRKLI8GeI8. -NAVub2qFgBEuQKRapoZuw.4jGQi9rcwQHU8P6XLxOGOA",
      "ja": "eyAiYWxnIjogImRpciIsICJlbmMiOiAiQTEyOEdDTSIgfQ..Bcs8gkIRKLI8GeI8。 -NAVub2qFgBEuQKRapoZuw.4jGQi9rcwQHU8P6XLxOGOA"
    },
    {
      "indent": 3,
      "text": "Where the first line represents the fixed JWE Protected Header, an empty JWE Encrypted Key, and the algorithmically determined JWE Initialization Vector. The second line contains the encoded body, split into JWE Ciphertext and JWE Authentication Tag.",
      "ja": "最初の行は、固定JWE保護ヘッダ、空JWE暗号化された鍵、およびアルゴリズム決定JWE初期化ベクトルを表します。 2行目はJWE暗号文とJWE認証タグに分け、符号化された本体を含んでいます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Mark Nottingham was an original author of this document.",
      "ja": "マーク・ノッティンガムは、このドキュメントの原作者でした。"
    },
    {
      "indent": 3,
      "text": "The following people provided valuable input: Richard Barnes, David Benjamin, Peter Beverloo, JR Conlin, Mike Jones, Stephen Farrell, Adam Langley, James Manger, John Mattsson, Julian Reschke, Eric Rescorla, Jim Schaad, and Magnus Westerlund.",
      "ja": "リチャード・バーンズ、デヴィッド・ベンジャミン、ピーターBeverloo、JR Conlin、マイク・ジョーンズ、スティーブン・ファレル、アダム・ラングレー、ジェームス・マンジェ、ジョン・マットソン、ジュリアンReschke、エリックレスコラ、ジムSchaad、およびマグヌスウェスター：次の人は貴重な入力を提供します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Thomson Mozilla",
      "ja": "マーティン・トムソンのMozilla"
    },
    {
      "indent": 3,
      "text": "Email: martin.thomson@gmail.com",
      "ja": "メール：martin.thomson@gmail.com"
    }
  ]
}