{
  "title": {
    "text": "RFC 8620 - The JSON Meta Application Protocol (JMAP)",
    "ja": "RFC 8620 - JSONメタアプリケーションプロトコル（JMAP）"
  },
  "number": 8620,
  "created_at": "2019-11-05 20:54:42.703540+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        N. Jenkins\nRequest for Comments: 8620                                      Fastmail\nCategory: Standards Track                                      C. Newman\nISSN: 2070-1721                                                   Oracle\n                                                               July 2019",
      "raw": true
    },
    {
      "indent": 15,
      "text": "The JSON Meta Application Protocol (JMAP)",
      "ja": "JSONメタアプリケーションプロトコル（JMAP）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a protocol for clients to efficiently query, fetch, and modify JSON-based data objects, with support for push notification of changes and fast resynchronisation and for out-of-band binary data upload/download.",
      "ja": "このドキュメントは、クライアントがJSONベースのデータオブジェクトを効率的にクエリ、フェッチ、および変更するためのプロトコルを指定します。変更のプッシュ通知と高速再同期、および帯域外バイナリデータのアップロード/ダウンロードをサポートします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8620.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8620で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Notational Conventions  . . . . . . . . . . . . . . . . .   4\n  1.2.  The Id Data Type  . . . . . . . . . . . . . . . . . . . .   6\n  1.3.  The Int and UnsignedInt Data Types  . . . . . . . . . . .   6\n  1.4.  The Date and UTCDate Data Types . . . . . . . . . . . . .   7\n  1.5.  JSON as the Data Encoding Format  . . . . . . . . . . . .   7\n  1.6.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   7\n    1.6.1.  User  . . . . . . . . . . . . . . . . . . . . . . . .   7\n    1.6.2.  Accounts  . . . . . . . . . . . . . . . . . . . . . .   7\n    1.6.3.  Data Types and Records  . . . . . . . . . . . . . . .   8\n  1.7.  The JMAP API Model  . . . . . . . . . . . . . . . . . . .   8\n  1.8.  Vendor-Specific Extensions  . . . . . . . . . . . . . . .   9\n2.  The JMAP Session Resource . . . . . . . . . . . . . . . . . .   9\n  2.1.  Example . . . . . . . . . . . . . . . . . . . . . . . . .  14\n  2.2.  Service Autodiscovery . . . . . . . . . . . . . . . . . .  15\n3.  Structured Data Exchange  . . . . . . . . . . . . . . . . . .  16\n  3.1.  Making an API Request . . . . . . . . . . . . . . . . . .  16\n  3.2.  The Invocation Data Type  . . . . . . . . . . . . . . . .  16\n  3.3.  The Request Object  . . . . . . . . . . . . . . . . . . .  16\n    3.3.1.  Example Request . . . . . . . . . . . . . . . . . . .  18\n  3.4.  The Response Object . . . . . . . . . . . . . . . . . . .  18\n    3.4.1.  Example Response  . . . . . . . . . . . . . . . . . .  19\n  3.5.  Omitting Arguments  . . . . . . . . . . . . . . . . . . .  19\n  3.6.  Errors  . . . . . . . . . . . . . . . . . . . . . . . . .  19\n    3.6.1.  Request-Level Errors  . . . . . . . . . . . . . . . .  20\n    3.6.2.  Method-Level Errors . . . . . . . . . . . . . . . . .  21\n  3.7.  References to Previous Method Results . . . . . . . . . .  22\n  3.8.  Localisation of User-Visible Strings  . . . . . . . . . .  27\n  3.9.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  28\n  3.10. Concurrency . . . . . . . . . . . . . . . . . . . . . . .  28\n4.  The Core/echo Method  . . . . . . . . . . . . . . . . . . . .  28\n  4.1.  Example . . . . . . . . . . . . . . . . . . . . . . . . .  28\n5.  Standard Methods and Naming Convention  . . . . . . . . . . .  29\n  5.1.  /get  . . . . . . . . . . . . . . . . . . . . . . . . . .  29\n  5.2.  /changes  . . . . . . . . . . . . . . . . . . . . . . . .  30\n  5.3.  /set  . . . . . . . . . . . . . . . . . . . . . . . . . .  34\n  5.4.  /copy . . . . . . . . . . . . . . . . . . . . . . . . . .  40\n  5.5.  /query  . . . . . . . . . . . . . . . . . . . . . . . . .  42\n  5.6.  /queryChanges . . . . . . . . . . . . . . . . . . . . . .  48\n  5.7.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .  51\n  5.8.  Proxy Considerations  . . . . . . . . . . . . . . . . . .  58\n6.  Binary Data . . . . . . . . . . . . . . . . . . . . . . . . .  58\n  6.1.  Uploading Binary Data . . . . . . . . . . . . . . . . . .  59\n  6.2.  Downloading Binary Data . . . . . . . . . . . . . . . . .  60\n  6.3.  Blob/copy . . . . . . . . . . . . . . . . . . . . . . . .  61",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.  Push  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  62\n  7.1.  The StateChange Object  . . . . . . . . . . . . . . . . .  63\n    7.1.1.  Example . . . . . . . . . . . . . . . . . . . . . . .  64\n  7.2.  PushSubscription  . . . . . . . . . . . . . . . . . . . .  64\n    7.2.1.  PushSubscription/get  . . . . . . . . . . . . . . . .  67\n    7.2.2.  PushSubscription/set  . . . . . . . . . . . . . . . .  68\n    7.2.3.  Example . . . . . . . . . . . . . . . . . . . . . . .  69\n  7.3.  Event Source  . . . . . . . . . . . . . . . . . . . . . .  71\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  73\n  8.1.  Transport Confidentiality . . . . . . . . . . . . . . . .  73\n  8.2.  Authentication Scheme . . . . . . . . . . . . . . . . . .  73\n  8.3.  Service Autodiscovery . . . . . . . . . . . . . . . . . .  73\n  8.4.  JSON Parsing  . . . . . . . . . . . . . . . . . . . . . .  74\n  8.5.  Denial of Service . . . . . . . . . . . . . . . . . . . .  74\n  8.6.  Connection to Unknown Push Server . . . . . . . . . . . .  74\n  8.7.  Push Encryption . . . . . . . . . . . . . . . . . . . . .  75\n  8.8.  Traffic Analysis  . . . . . . . . . . . . . . . . . . . .  76\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  76\n  9.1.  Assignment of jmap Service Name . . . . . . . . . . . . .  76\n  9.2.  Registration of Well-Known URI Suffix for JMAP  . . . . .  76\n  9.3.  Registration of the jmap URN Sub-namespace  . . . . . . .  77\n  9.4.  Creation of \"JMAP Capabilities\" Registry  . . . . . . . .  77\n    9.4.1.  Preliminary Community Review  . . . . . . . . . . . .  77\n    9.4.2.  Submit Request to IANA  . . . . . . . . . . . . . . .  78\n    9.4.3.  Designated Expert Review  . . . . . . . . . . . . . .  78\n    9.4.4.  Change Procedures . . . . . . . . . . . . . . . . . .  78\n    9.4.5.  JMAP Capabilities Registry Template . . . . . . . . .  79\n    9.4.6.  Initial Registration for JMAP Core  . . . . . . . . .  79\n    9.4.7.  Registration for JMAP Error Placeholder in JMAP\n            Capabilities Registry . . . . . . . . . . . . . . . .  80\n  9.5.  Creation of \"JMAP Error Codes\" Registry . . . . . . . . .  80\n    9.5.1.  Expert Review . . . . . . . . . . . . . . . . . . . .  80\n    9.5.2.  JMAP Error Codes Registry Template  . . . . . . . . .  81\n    9.5.3.  Initial Contents for the JMAP Error Codes Registry  .  81\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  86\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  86\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  89\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  90",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The JSON Meta Application Protocol (JMAP) is used for synchronising data, such as mail, calendars, or contacts, between a client and a server. It is optimised for mobile and web environments and aims to provide a consistent interface to different data types.",
      "ja": "JSONメタアプリケーションプロトコル（JMAP）は、クライアント、サーバー間でメール、カレンダー、連絡先などのデータを同期するために使用されます。 モバイルおよびWeb環境向けに最適化されており、さまざまなデータ型への一貫したインターフェイスを提供することを目的としています。"
    },
    {
      "indent": 3,
      "text": "This specification is for the generic mechanism of data synchronisation. Further specifications define the data models for different data types that may be synchronised via JMAP.",
      "ja": "この仕様は、データ同期の一般的なメカニズム用です。 さらに詳細な仕様では、JMAPを介して同期できるさまざまなデータタイプのデータモデルを定義しています。"
    },
    {
      "indent": 3,
      "text": "JMAP is designed to make efficient use of limited network resources. Multiple API calls may be batched in a single request to the server, reducing round trips and improving battery life on mobile devices. Push connections remove the need for polling, and an efficient delta update mechanism ensures a minimum amount of data is transferred.",
      "ja": "JMAPは、限られたネットワークリソースを効率的に使用するように設計されています。 サーバーへの1回のリクエストで複数のAPI呼び出しをバッチ処理することで、ラウンドトリップを減らし、モバイルデバイスのバッテリー寿命を改善できます。 プッシュ接続により、ポーリングの必要がなくなり、効率的なデルタ更新メカニズムにより、最小量のデータが転送されます。"
    },
    {
      "indent": 3,
      "text": "JMAP is designed to be horizontally scalable to a very large number of users. This is facilitated by separate endpoints for users after login, the separation of binary and structured data, and a data model for sharing that does not allow data dependencies between accounts.",
      "ja": "JMAPは、非常に多くのユーザーに対して水平方向に拡張できるように設計されています。 これは、ログイン後のユーザーの個別のエンドポイント、バイナリデータと構造化データの分離、およびアカウント間のデータ依存関係を許可しない共有のデータモデルによって促進されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Notational Conventions",
      "section_title": true,
      "ja": "1.1. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "The underlying format used for this specification is JSON. Consequently, the terms \"object\" and \"array\" as well as the four primitive types (strings, numbers, booleans, and null) are to be interpreted as described in Section 1 of [RFC8259]. Unless otherwise noted, all the property names and values are case sensitive.",
      "ja": "この仕様に使用される基本的な形式はJSONです。 したがって、「オブジェクト」および「配列」という用語と4つのプリミティブ型（文字列、数値、ブール値、およびヌル）は、[RFC8259]のセクション1で説明されているように解釈されます。 特に明記されていない限り、すべてのプロパティ名と値は大文字と小文字が区別されます。"
    },
    {
      "indent": 3,
      "text": "Some examples in this document contain \"partial\" JSON documents used for illustrative purposes. In these examples, three periods \"...\" are used to indicate a portion of the document that has been removed for compactness.",
      "ja": "このドキュメントの一部の例には、説明のために使用される「部分的な」JSONドキュメントが含まれています。 これらの例では、3つのピリオド「...」を使用して、コンパクト化のために削除されたドキュメントの一部を示しています。"
    },
    {
      "indent": 3,
      "text": "For compatibility with publishing requirements, line breaks have been inserted inside long JSON strings, with the following continuation lines indented. To form the valid JSON example, any line breaks inside a string must be replaced with a space and any other white space after the line break removed.",
      "ja": "発行要件との互換性のために、次の継続行がインデントされた長いJSON文字列内に改行が挿入されています。 有効なJSONの例を作成するには、文字列内の改行をスペースと、改行を削除した後のその他の空白で置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified, examples of API exchanges only show the methodCalls array of the Request object or the methodResponses array of the Response object. For compactness, the rest of the Request/ Response object is omitted.",
      "ja": "特に指定がない限り、API交換の例には、RequestオブジェクトのmethodCalls配列またはResponseオブジェクトのmethodResponses配列のみが表示されます。 コンパクトにするために、残りのRequest / Responseオブジェクトは省略されています。"
    },
    {
      "indent": 3,
      "text": "Type signatures are given for all JSON values in this document. The following conventions are used:",
      "ja": "このドキュメントのすべてのJSON値に型シグネチャが与えられています。 次の規則が使用されます。"
    },
    {
      "indent": 3,
      "text": "o \"*\" - The type is undefined (the value could be any type, although permitted values may be constrained by the context of this value).",
      "ja": "o \"*\"-タイプは未定義です（値はどのタイプでもかまいませんが、許可される値はこの値のコンテキストによって制約される場合があります）。"
    },
    {
      "indent": 3,
      "text": "o \"String\" - The JSON string type.",
      "ja": "o 「文字列」-JSON文字列タイプ。"
    },
    {
      "indent": 3,
      "text": "o \"Number\" - The JSON number type.",
      "ja": "o 「番号」-JSON番号タイプ。"
    },
    {
      "indent": 3,
      "text": "o \"Boolean\" - The JSON boolean type.",
      "ja": "o 「ブール」-JSONブール型。"
    },
    {
      "indent": 3,
      "text": "o \"A[B]\" - A JSON object where the keys are all of type \"A\", and the values are all of type \"B\".",
      "ja": "o 「A [B]」-キーがすべて「A」タイプで、値がすべて「B」タイプのJSONオブジェクト。"
    },
    {
      "indent": 3,
      "text": "o \"A[]\" - An array of values of type \"A\".",
      "ja": "o 「A []」-「A」タイプの値の配列。"
    },
    {
      "indent": 3,
      "text": "o \"A|B\" - The value is either of type \"A\" or of type \"B\".",
      "ja": "o 「A | B」-値は、タイプ「A」またはタイプ「B」のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Other types may also be given, with their representation defined elsewhere in this document.",
      "ja": "このドキュメントの他の場所で定義されている表現を使用して、他のタイプも指定できます。"
    },
    {
      "indent": 3,
      "text": "Object properties may also have a set of attributes defined along with the type signature. These have the following meanings:",
      "ja": "オブジェクトプロパティには、タイプシグネチャとともに定義された属性のセットも含まれる場合があります。 これらの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o \"server-set\" -- Only the server can set the value for this property. The client MUST NOT send this property when creating a new object of this type.",
      "ja": "o \"server-set\"-サーバーのみがこのプロパティの値を設定できます。 このタイプの新しいオブジェクトを作成するとき、クライアントはこのプロパティを送信してはいけません。"
    },
    {
      "indent": 3,
      "text": "o \"immutable\" -- The value MUST NOT change after the object is created.",
      "ja": "o 「不変」-値は、オブジェクトの作成後に変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "o \"default\" -- (This is followed by a JSON value). The value that will be used for this property if it is omitted in an argument or when creating a new object of this type.",
      "ja": "o 「デフォルト」-（これにJSON値が続きます）。 引数で省略された場合、またはこのタイプの新しいオブジェクトを作成するときにこのプロパティに使用される値。"
    },
    {
      "indent": 0,
      "text": "1.2. The Id Data Type",
      "section_title": true,
      "ja": "1.2. Idデータ型"
    },
    {
      "indent": 3,
      "text": "All record ids are assigned by the server and are immutable.",
      "ja": "すべてのレコードIDはサーバーによって割り当てられ、不変です。"
    },
    {
      "indent": 3,
      "text": "Where \"Id\" is given as a data type, it means a \"String\" of at least 1 and a maximum of 255 octets in size, and it MUST only contain characters from the \"URL and Filename Safe\" base64 alphabet, as defined in Section 5 of [RFC4648], excluding the pad character (\"=\"). This means the allowed characters are the ASCII alphanumeric characters (\"A-Za-z0-9\"), hyphen (\"-\"), and underscore (\"_\").",
      "ja": "「Id」がデータ型として指定されている場合、少なくとも1〜255オクテットのサイズの「文字列」を意味し、「URL and Filename Safe」base64アルファベットの文字のみを含む必要があります。 [RFC4648]のセクション5、埋め込み文字（ \"=\"）を除く。 これは、許可される文字がASCII英数字（ \"A-Za-z0-9\"）、ハイフン（ \"-\"）、および下線（ \"_\"）であることを意味します。"
    },
    {
      "indent": 3,
      "text": "These characters are safe to use in almost any context (e.g., filesystems, URIs, and IMAP atoms). For maximum safety, servers SHOULD also follow defensive allocation strategies to avoid creating risks where glob completion or data type detection may be present (e.g., on filesystems or in spreadsheets). In particular, it is wise to avoid:",
      "ja": "これらの文字は、ほぼすべてのコンテキスト（ファイルシステム、URI、IMAPアトムなど）で使用しても安全です。 最大限の安全性を確保するために、サーバーは防御的な割り当て戦略にも従う必要があります（ファイルシステム上またはスプレッドシート内など）。 特に、避けることは賢明です："
    },
    {
      "indent": 3,
      "text": "o Ids starting with a dash",
      "ja": "o ダッシュで始まるID"
    },
    {
      "indent": 3,
      "text": "o Ids starting with digits",
      "ja": "o 数字で始まるID"
    },
    {
      "indent": 3,
      "text": "o Ids that contain only digits",
      "ja": "o 数字のみを含むID"
    },
    {
      "indent": 3,
      "text": "o Ids that differ only by ASCII case (for example, A vs. a)",
      "ja": "o ASCIIケースのみが異なるID（たとえば、Aとa）"
    },
    {
      "indent": 3,
      "text": "o the specific sequence of three characters \"NIL\" (because this sequence can be confused with the IMAP protocol expression of the null value)",
      "ja": "o 3文字の特定のシーケンス「NIL」（このシーケンスは、ヌル値のIMAPプロトコル表現と混同される可能性があるため）"
    },
    {
      "indent": 3,
      "text": "A good solution to these issues is to prefix every id with a single alphabetical character.",
      "ja": "これらの問題に対する適切な解決策は、すべてのIDに単一のアルファベット文字をプレフィックスとして付けることです。"
    },
    {
      "indent": 0,
      "text": "1.3. The Int and UnsignedInt Data Types",
      "section_title": true,
      "ja": "1.3. IntおよびUnsignedIntデータ型"
    },
    {
      "indent": 3,
      "text": "Where \"Int\" is given as a data type, it means an integer in the range -2^53+1 <= value <= 2^53-1, the safe range for integers stored in a floating-point double, represented as a JSON \"Number\".",
      "ja": "データ型として「Int」が指定されている場合、浮動小数点doubleに格納された整数の安全範囲である-2 ^ 53 + 1 <= value <= 2 ^ 53-1の範囲の整数を意味します。 JSON「番号」。"
    },
    {
      "indent": 3,
      "text": "Where \"UnsignedInt\" is given as a data type, it means an \"Int\" where the value MUST be in the range 0 <= value <= 2^53-1.",
      "ja": "データ型として「UnsignedInt」が指定されている場合、値が0 <= value <= 2 ^ 53-1の範囲にある必要がある「Int」を意味します。"
    },
    {
      "indent": 0,
      "text": "1.4. The Date and UTCDate Data Types",
      "section_title": true,
      "ja": "1.4. 日付およびUTCDateデータ型"
    },
    {
      "indent": 3,
      "text": "Where \"Date\" is given as a type, it means a string in \"date-time\" format [RFC3339]. To ensure a normalised form, the \"time-secfrac\" MUST always be omitted if zero, and any letters in the string (e.g., \"T\" and \"Z\") MUST be uppercase. For example, \"2014-10-30T14:12:00+08:00\".",
      "ja": "「日付」がタイプとして指定されている場合、「日付/時刻」形式の文字列を意味します[RFC3339]。 正規化された形式を確保するために、ゼロの場合は常に「time-secfrac」を省略しなければならず、文字列内の文字（例：「T」および「Z」）は大文字でなければなりません。 たとえば、「2014-10-30T14：12：00 + 08：00」。"
    },
    {
      "indent": 3,
      "text": "Where \"UTCDate\" is given as a type, it means a \"Date\" where the \"time-offset\" component MUST be \"Z\" (i.e., it must be in UTC time). For example, \"2014-10-30T06:12:00Z\".",
      "ja": "「UTCDate」がタイプとして指定されている場合、「time-offset」コンポーネントが「Z」でなければならない「日付」を意味します（つまり、UTC時間でなければなりません）。 たとえば、「2014-10-30T06：12：00Z」。"
    },
    {
      "indent": 0,
      "text": "1.5. JSON as the Data Encoding Format",
      "section_title": true,
      "ja": "1.5. データエンコード形式としてのJSON"
    },
    {
      "indent": 3,
      "text": "JSON is a text-based data interchange format as specified in [RFC8259]. The Internet JSON (I-JSON) format defined in [RFC7493] is a strict subset of this, adding restrictions to avoid potentially confusing scenarios (for example, it mandates that an object MUST NOT have two members with the same name).",
      "ja": "JSONは、[RFC8259]で指定されているテキストベースのデータ交換形式です。 [RFC7493]で定義されているインターネットJSON（I-JSON）形式はこれの厳密なサブセットであり、混乱を招く可能性のあるシナリオを回避するための制限を追加します（たとえば、オブジェクトに同じ名前の2つのメンバーを含めることはできません）。"
    },
    {
      "indent": 3,
      "text": "All data sent from the client to the server or from the server to the client (except binary file upload/download) MUST be valid I-JSON according to the RFC and is therefore case sensitive and encoded in UTF-8 [RFC3629].",
      "ja": "クライアントからサーバーまたはサーバーからクライアントに送信されるすべてのデータ（バイナリファイルのアップロード/ダウンロードを除く）は、RFCに従って有効なI-JSONでなければならず、したがって大文字と小文字が区別され、UTF-8 [RFC3629]でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "1.6. Terminology",
      "section_title": true,
      "ja": "1.6. 用語"
    },
    {
      "indent": 0,
      "text": "1.6.1. User",
      "section_title": true,
      "ja": "1.6.1. ユーザー"
    },
    {
      "indent": 3,
      "text": "A user is a person accessing data via JMAP. A user has a set of permissions determining the data that they can see.",
      "ja": "ユーザーは、JMAPを介してデータにアクセスする人です。 ユーザーには、表示できるデータを決定する一連の権限があります。"
    },
    {
      "indent": 0,
      "text": "1.6.2. Accounts",
      "section_title": true,
      "ja": "1.6.2. アカウント"
    },
    {
      "indent": 3,
      "text": "An account is a collection of data. A single account may contain an arbitrary set of data types, for example, a collection of mail, contacts, and calendars. Most JMAP methods take a mandatory \"accountId\" argument that specifies on which account the operations are to take place.",
      "ja": "アカウントはデータのコレクションです。 単一のアカウントには、メール、連絡先、カレンダーのコレクションなど、データタイプの任意のセットを含めることができます。 ほとんどのJMAPメソッドは、操作が実行されるアカウントを指定する必須の「accountId」引数を取ります。"
    },
    {
      "indent": 3,
      "text": "An account is not the same as a user, although it is common for a primary account to directly belong to the user. For example, you may have an account that contains data for a group or business, to which multiple users have access.",
      "ja": "アカウントはユーザーと同じではありませんが、プライマリアカウントがユーザーに直接属することは一般的です。 たとえば、複数のユーザーがアクセスできるグループまたはビジネスのデータを含むアカウントがある場合があります。"
    },
    {
      "indent": 3,
      "text": "A single set of credentials may provide access to multiple accounts, for example, if another user is sharing their work calendar with the authenticated user or if there is a group mailbox for a support-desk inbox.",
      "ja": "たとえば、別のユーザーが認証済みユーザーと仕事の予定表を共有している場合や、サポートデスクの受信トレイ用のグループメールボックスがある場合、1組の資格情報で複数のアカウントにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "In the event of a severe internal error, a server may have to reallocate ids or do something else that violates standard JMAP data constraints for an account. In this situation, the data on the server is no longer compatible with cached data the client may have from before. The server MUST treat this as though the account has been deleted and then recreated with a new account id. Clients will then be forced to throw away any data with the old account id and refetch all data from scratch.",
      "ja": "重大な内部エラーが発生した場合、サーバーはIDを再割り当てするか、アカウントの標準JMAPデータの制約に違反する他の操作を行う必要があります。 この状況では、サーバー上のデータは、クライアントが以前から保持していたキャッシュデータと互換性がなくなります。 サーバーは、アカウントが削除され、新しいアカウントIDで再作成されたかのようにこれを処理する必要があります。 クライアントは、古いアカウントIDのデータを破棄し、すべてのデータを最初から再取得することを余儀なくされます。"
    },
    {
      "indent": 0,
      "text": "1.6.3. Data Types and Records",
      "section_title": true,
      "ja": "1.6.3. データ型とレコード"
    },
    {
      "indent": 3,
      "text": "JMAP provides a uniform interface for creating, retrieving, updating, and deleting various types of objects. A \"data type\" is a collection of named, typed properties, just like the schema for a database table. Each instance of a data type is called a \"record\".",
      "ja": "JMAPは、さまざまなタイプのオブジェクトを作成、取得、更新、および削除するための統一されたインターフェースを提供します。 「データ型」とは、データベーステーブルのスキーマと同様に、名前付きの型付きプロパティのコレクションです。 データ型の各インスタンスは「レコード」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The id of a record is immutable and assigned by the server. The id MUST be unique among all records of the *same type* within the *same account*. Ids may clash across accounts or for two records of different types within the same account.",
      "ja": "レコードのIDは不変であり、サーバーによって割り当てられます。 idは、*同じアカウント*内の*同じタイプ*のすべてのレコード間で一意でなければなりません。 IDはアカウント間で衝突したり、同じアカウント内の異なるタイプの2つのレコードで衝突したりする場合があります。"
    },
    {
      "indent": 0,
      "text": "1.7. The JMAP API Model",
      "section_title": true,
      "ja": "1.7. JMAP APIモデル"
    },
    {
      "indent": 3,
      "text": "JMAP uses HTTP [RFC7230] to expose API, push, upload, and download resources. All HTTP requests MUST use the \"https://\" scheme (HTTP over TLS [RFC2818]). All HTTP requests MUST be authenticated.",
      "ja": "JMAPはHTTP [RFC7230]を使用して、API、プッシュ、アップロード、およびダウンロードのリソースを公開します。 すべてのHTTP要求は、「https：//」スキーム（HTTP over TLS [RFC2818]）を使用する必要があります。 すべてのHTTP要求を認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "An authenticated client can fetch the user's Session object with details about the data and capabilities the server can provide as shown in Section 2. The client may then exchange data with the server in the following ways:",
      "ja": "認証されたクライアントは、セクション2に示すように、サーバーが提供できるデータと機能の詳細を使用してユーザーのSessionオブジェクトを取得できます。クライアントは、次の方法でサーバーとデータを交換できます。"
    },
    {
      "indent": 3,
      "text": "1. The client may make an API request to the server to get or set structured data. This request consists of an ordered series of method calls. These are processed by the server, which then returns an ordered series of responses. This is described in Sections 3, 4, and 5.",
      "ja": "1. クライアントは、構造化データを取得または設定するためにサーバーにAPIリクエストを行う場合があります。 このリクエストは、順序付けられた一連のメソッド呼び出しで構成されます。 これらはサーバーによって処理され、サーバーは順序付けられた一連の応答を返します。 これについては、セクション3、4、および5で説明します。"
    },
    {
      "indent": 3,
      "text": "2. The client may download or upload binary files from/to the server. This is detailed in Section 6.",
      "ja": "2. クライアントは、サーバーから/にバイナリファイルをダウンロードまたはアップロードできます。 これについては、セクション6で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "3. The client may connect to a push channel on the server, to be notified when data has changed. This is explained in Section 7.",
      "ja": "3. クライアントは、サーバーのプッシュチャネルに接続して、データが変更されたときに通知を受けることができます。 これについては、セクション7で説明します。"
    },
    {
      "indent": 0,
      "text": "1.8. Vendor-Specific Extensions",
      "section_title": true,
      "ja": "1.8. ベンダー固有の拡張"
    },
    {
      "indent": 3,
      "text": "Individual services will have custom features they wish to expose over JMAP. This may take the form of extra data types and/or methods not in the spec, extra arguments to JMAP methods, or extra properties on existing data types (which may also appear in arguments to methods that take property names).",
      "ja": "個々のサービスには、JMAPで公開したいカスタム機能があります。 これは、仕様にない追加のデータ型やメソッド、JMAPメソッドの追加の引数、または既存のデータ型の追加のプロパティ（プロパティ名を取得するメソッドの引数にも表示される）の形式をとることがあります。"
    },
    {
      "indent": 3,
      "text": "The server can advertise custom extensions it supports by including the identifiers in the capabilities object. Identifiers for vendor extensions MUST be a URL belonging to a domain owned by the vendor, to avoid conflict. The URL SHOULD resolve to documentation for the changes the extension makes.",
      "ja": "サーバーは、機能オブジェクトに識別子を含めることで、サポートするカスタム拡張をアドバタイズできます。 競合を避けるため、ベンダー拡張の識別子は、ベンダーが所有するドメインに属するURLでなければなりません。 URLは、拡張機能が行う変更に関するドキュメントに解決する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MUST opt in to use an extension by passing the appropriate capability identifier in the \"using\" array of the Request object, as described in Section 3.3. The server MUST only follow the specifications that are opted into and behave as though it does not implement anything else when processing a request. This is to ensure compatibility with clients that don't know about a specific custom extension and for compatibility with future versions of JMAP.",
      "ja": "クライアントは、セクション3.3で説明されているように、Requestオブジェクトの「using」配列に適切な機能識別子を渡すことにより、拡張機能の使用を選択する必要があります。 サーバーは、要求を処理するときに他に何も実装していないかのように選択され、動作する仕様のみに従う必要があります。 これは、特定のカスタム拡張機能を知らないクライアントとの互換性を確保し、JMAPの将来のバージョンとの互換性を確保するためです。"
    },
    {
      "indent": 0,
      "text": "2. The JMAP Session Resource",
      "section_title": true,
      "ja": "2. JMAPセッションリソース"
    },
    {
      "indent": 3,
      "text": "You need two things to connect to a JMAP server:",
      "ja": "JMAPサーバーに接続するには、次の2つが必要です。"
    },
    {
      "indent": 3,
      "text": "1. The URL for the JMAP Session resource. This may be requested directly from the user or discovered automatically based on a username domain (see Section 2.2 below).",
      "ja": "1. JMAPセッションリソースのURL。 これは、ユーザーから直接要求されるか、ユーザー名ドメインに基づいて自動的に検出されます（セクション2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "2. Credentials to authenticate with. How to obtain credentials is out of scope for this document.",
      "ja": "2. 認証に使用する資格情報。 資格情報を取得する方法は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "A successful authenticated GET request to the JMAP Session resource MUST return a JSON-encoded *Session* object, giving details about the data and capabilities the server can provide to the client given those credentials. It has the following properties:",
      "ja": "JMAP Sessionリソースへの認証されたGETリクエストが成功すると、JSONエンコードされた* Session *オブジェクトを返さなければならず、それらの資格情報を与えられたサーバーがクライアントに提供できるデータと機能の詳細を提供します。 次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o capabilities: \"String[Object]\"",
      "ja": "o 機能：「文字列[オブジェクト]」"
    },
    {
      "indent": 6,
      "text": "An object specifying the capabilities of this server. Each key is a URI for a capability supported by the server. The value for each of these keys is an object with further information about the server's capabilities in relation to that capability.",
      "ja": "このサーバーの機能を指定するオブジェクト。 各キーは、サーバーがサポートする機能のURIです。 これらの各キーの値は、その機能に関連するサーバーの機能に関する詳細情報を持つオブジェクトです。"
    },
    {
      "indent": 6,
      "text": "The client MUST ignore any properties it does not understand.",
      "ja": "クライアントは、理解できないプロパティを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The capabilities object MUST include a property called \"urn:ietf:params:jmap:core\". The value of this property is an object that MUST contain the following information on server capabilities (suggested minimum values for limits are supplied that allow clients to make efficient use of the network):",
      "ja": "機能オブジェクトには、「urn：ietf：params：jmap：core」というプロパティを含める必要があります。 このプロパティの値は、サーバー機能に関する次の情報を含む必要があるオブジェクトです（クライアントがネットワークを効率的に使用できるようにするために、制限の推奨最小値が提供されます）。"
    },
    {
      "indent": 6,
      "text": "* maxSizeUpload: \"UnsignedInt\"",
      "ja": "* maxSizeUpload： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum file size, in octets, that the server will accept for a single file upload (for any purpose). Suggested minimum: 50,000,000.",
      "ja": "サーバーが1回のファイルアップロードで（任意の目的で）受け入れる最大ファイルサイズ（オクテット単位）。 推奨最小値：50,000,000。"
    },
    {
      "indent": 6,
      "text": "* maxConcurrentUpload: \"UnsignedInt\"",
      "ja": "* maxConcurrentUpload： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum number of concurrent requests the server will accept to the upload endpoint. Suggested minimum: 4.",
      "ja": "サーバーがアップロードエンドポイントに対して受け入れる同時リクエストの最大数。 推奨最小値：4。"
    },
    {
      "indent": 6,
      "text": "* maxSizeRequest: \"UnsignedInt\"",
      "ja": "* maxSizeRequest： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum size, in octets, that the server will accept for a single request to the API endpoint. Suggested minimum: 10,000,000.",
      "ja": "サーバーがAPIエンドポイントへの単一の要求に対して受け入れる最大サイズ（オクテット単位）。 推奨最小値：10,000,000。"
    },
    {
      "indent": 6,
      "text": "* maxConcurrentRequests: \"UnsignedInt\"",
      "ja": "* maxConcurrentRequests： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum number of concurrent requests the server will accept to the API endpoint. Suggested minimum: 4.",
      "ja": "サーバーがAPIエンドポイントに対して受け入れる同時リクエストの最大数。 推奨最小値：4。"
    },
    {
      "indent": 6,
      "text": "* maxCallsInRequest: \"UnsignedInt\"",
      "ja": "* maxCallsInRequest： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum number of method calls the server will accept in a single request to the API endpoint. Suggested minimum: 16.",
      "ja": "サーバーがAPIエンドポイントへの1回のリクエストで受け入れるメソッド呼び出しの最大数。 推奨最小値：16。"
    },
    {
      "indent": 6,
      "text": "* maxObjectsInGet: \"UnsignedInt\"",
      "ja": "* maxObjectsInGet： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum number of objects that the client may request in a single /get type method call. Suggested minimum: 500.",
      "ja": "クライアントが1回の/ getタイプのメソッド呼び出しで要求できるオブジェクトの最大数。 推奨最小値：500。"
    },
    {
      "indent": 6,
      "text": "* maxObjectsInSet: \"UnsignedInt\"",
      "ja": "* maxObjectsInSet： \"UnsignedInt\""
    },
    {
      "indent": 9,
      "text": "The maximum number of objects the client may send to create, update, or destroy in a single /set type method call. This is the combined total, e.g., if the maximum is 10, you could not create 7 objects and destroy 6, as this would be 13 actions, which exceeds the limit. Suggested minimum: 500.",
      "ja": "単一の/ setタイプのメソッド呼び出しでクライアントが作成、更新、または破棄するために送信できるオブジェクトの最大数。 これは、合計が合計です。たとえば、最大が10の場合、7個のオブジェクトを作成し、6個を破壊できませんでした。これは、13個のアクションであり、制限を超えています。 推奨最小値：500。"
    },
    {
      "indent": 6,
      "text": "* collationAlgorithms: \"String[]\"",
      "ja": "* collationAlgorithms： \"String []\""
    },
    {
      "indent": 9,
      "text": "A list of identifiers for algorithms registered in the collation registry, as defined in [RFC4790], that the server supports for sorting when querying records.",
      "ja": "[RFC4790]で定義されている照合レジストリに登録されているアルゴリズムの識別子のリスト。サーバーはレコードを照会する際のソートをサポートします。"
    },
    {
      "indent": 6,
      "text": "Specifications for future capabilities will define their own properties on the capabilities object.",
      "ja": "将来の機能の仕様では、機能オブジェクトで独自のプロパティを定義します。"
    },
    {
      "indent": 6,
      "text": "Servers MAY advertise vendor-specific JMAP extensions, as described in Section 1.8. To avoid conflict, an identifier for a vendor-specific extension MUST be a URL with a domain owned by the vendor. Clients MUST opt in to any capability it wishes to use (see Section 3.3).",
      "ja": "サーバーは、セクション1.8で説明されているように、ベンダー固有のJMAP拡張をアドバタイズすることができます。 競合を避けるために、ベンダー固有の拡張機能の識別子は、ベンダーが所有するドメインを持つURLでなければなりません。 クライアントは、使用したい機能を選択する必要があります（セクション3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o accounts: \"Id[Account]\"",
      "ja": "o アカウント：「Id [アカウント]」"
    },
    {
      "indent": 6,
      "text": "A map of an account id to an Account object for each account (see Section 1.6.2) the user has access to. An *Account* object has the following properties:",
      "ja": "ユーザーがアクセスできる各アカウント（セクション1.6.2を参照）のアカウントオブジェクトへのアカウントIDのマップ。 * Account *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "* name: \"String\"",
      "ja": "* 名前：「ストリング」"
    },
    {
      "indent": 9,
      "text": "A user-friendly string to show when presenting content from this account, e.g., the email address representing the owner of the account.",
      "ja": "このアカウントのコンテンツを表示するときに表示するユーザーフレンドリーな文字列。たとえば、アカウントの所有者を表すメールアドレス。"
    },
    {
      "indent": 6,
      "text": "* isPersonal: \"Boolean\"",
      "ja": "* isPersonal： \"ブール値\""
    },
    {
      "indent": 9,
      "text": "This is true if the account belongs to the authenticated user rather than a group account or a personal account of another user that has been shared with them.",
      "ja": "これは、アカウントがグループアカウントまたは共有されている別のユーザーの個人アカウントではなく、認証されたユーザーに属している場合に当てはまります。"
    },
    {
      "indent": 6,
      "text": "* isReadOnly: \"Boolean\"",
      "ja": "* isReadOnly： \"ブール値\""
    },
    {
      "indent": 9,
      "text": "This is true if the entire account is read-only.",
      "ja": "これは、アカウント全体が読み取り専用の場合に当てはまります。"
    },
    {
      "indent": 6,
      "text": "* accountCapabilities: \"String[Object]\"",
      "ja": "* accountCapabilities： \"String [Object]\""
    },
    {
      "indent": 9,
      "text": "The set of capability URIs for the methods supported in this account. Each key is a URI for a capability that has methods you can use with this account. The value for each of these keys is an object with further information about the account's permissions and restrictions with respect to this capability, as defined in the capability's specification.",
      "ja": "このアカウントでサポートされているメソッドの機能URIのセット。 各キーは、このアカウントで使用できるメソッドを持つ機能のURIです。 これらの各キーの値は、機能の仕様で定義されているように、この機能に関するアカウントの権限と制限に関する詳細情報を持つオブジェクトです。"
    },
    {
      "indent": 9,
      "text": "The client MUST ignore any properties it does not understand.",
      "ja": "クライアントは、理解できないプロパティを無視しなければなりません。"
    },
    {
      "indent": 9,
      "text": "The server advertises the full list of capabilities it supports in the capabilities object, as defined above. If the capability defines new methods, the server MUST include it in the accountCapabilities object if the user may use those methods with this account. It MUST NOT include it in the accountCapabilities object if the user cannot use those methods with this account.",
      "ja": "サーバーは、上記で定義されているように、機能オブジェクトでサポートする機能の完全なリストをアドバタイズします。 機能が新しいメソッドを定義する場合、ユーザーがこのアカウントでこれらのメソッドを使用できる場合、サーバーはaccountCapabilitiesオブジェクトにそれを含める必要があります。 ユーザーがこのアカウントでこれらのメソッドを使用できない場合、accountCapabilitiesオブジェクトに含めることはできません。"
    },
    {
      "indent": 9,
      "text": "For example, you may have access to your own account with mail, calendars, and contacts data and also a shared account that only has contacts data (a business address book, for example). In this case, the accountCapabilities property on the first account would include something like \"urn:ietf:params:jmap:mail\", \"urn:ietf:params:jmap:calendars\", and \"urn:ietf:params:jmap:contacts\", while the second account would just have the last of these.",
      "ja": "たとえば、メール、カレンダー、連絡先データを持つ独自のアカウント、および連絡先データのみを持つ共有アカウント（ビジネスアドレス帳など）にアクセスできる場合があります。 この場合、最初のアカウントのaccountCapabilitiesプロパティには、「urn：ietf：params：jmap：mail」、「urn：ietf：params：jmap：calendars」、および「urn：ietf：params：jmap：contacts」のようなものが含まれます。 「一方、2番目のアカウントにはこれらの最後のアカウントがあります。"
    },
    {
      "indent": 9,
      "text": "Attempts to use the methods defined in a capability with one of the accounts that does not support that capability are rejected with an \"accountNotSupportedByMethod\" error (see \"Method-Level Errors\", Section 3.6.2).",
      "ja": "その機能をサポートしていないアカウントの1つで機能で定義されたメソッドを使用しようとすると、「accountNotSupportedByMethod」エラーで拒否されます（「メソッドレベルのエラー」、セクション3.6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o primaryAccounts: \"String[Id]\"",
      "ja": "o primaryAccounts： \"String [Id]\""
    },
    {
      "indent": 6,
      "text": "A map of capability URIs (as found in accountCapabilities) to the account id that is considered to be the user's main or default account for data pertaining to that capability. If no account being returned belongs to the user, or in any other way there is no appropriate way to determine a default account, there MAY be no entry for a particular URI, even though that capability is supported by the server (and in the capabilities object). \"urn:ietf:params:jmap:core\" SHOULD NOT be present.",
      "ja": "その機能に関連するデータのユーザーのメインまたはデフォルトアカウントと見なされるアカウントIDへの機能URI（accountCapabilitiesにある）のマップ。 返されるアカウントがユーザーに属していない場合、または他の方法でデフォルトアカウントを決定する適切な方法がない場合、その機能がサーバー（および機能でサポートされている場合でも） オブジェクト）。 「urn：ietf：params：jmap：core」は存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "o username: \"String\"",
      "ja": "o ユーザー名： \"String\""
    },
    {
      "indent": 6,
      "text": "The username associated with the given credentials, or the empty string if none.",
      "ja": "指定された資格情報に関連付けられたユーザー名、または存在しない場合は空の文字列。"
    },
    {
      "indent": 3,
      "text": "o apiUrl: \"String\"",
      "ja": "o apiUrl： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The URL to use for JMAP API requests.",
      "ja": "JMAP APIリクエストに使用するURL。"
    },
    {
      "indent": 3,
      "text": "o downloadUrl: \"String\"",
      "ja": "o downloadUrl： \"String\""
    },
    {
      "indent": 6,
      "text": "The URL endpoint to use when downloading files, in URI Template (level 1) format [RFC6570]. The URL MUST contain variables called \"accountId\", \"blobId\", \"type\", and \"name\". The use of these variables is described in Section 6.2. Due to potential encoding issues with slashes in content types, it is RECOMMENDED to put the \"type\" variable in the query section of the URL.",
      "ja": "ファイルをダウンロードするときに使用するURLエンドポイント、URIテンプレート（レベル1）形式[RFC6570]。 URLには、「accountId」、「blobId」、「type」、および「name」と呼ばれる変数を含める必要があります。 これらの変数の使用については、セクション6.2で説明しています。 コンテンツタイプのスラッシュでエンコードの問題が発生する可能性があるため、URLのクエリセクションに「type」変数を配置することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o uploadUrl: \"String\"",
      "ja": "o uploadUrl： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The URL endpoint to use when uploading files, in URI Template (level 1) format [RFC6570]. The URL MUST contain a variable called \"accountId\". The use of this variable is described in Section 6.1.",
      "ja": "URIテンプレート（レベル1）形式のファイルをアップロードするときに使用するURLエンドポイント[RFC6570]。 URLには、「accountId」という変数を含める必要があります。 この変数の使用については、セクション6.1で説明しています。"
    },
    {
      "indent": 3,
      "text": "o eventSourceUrl: \"String\"",
      "ja": "o eventSourceUrl： \"String\""
    },
    {
      "indent": 6,
      "text": "The URL to connect to for push events, as described in Section 7.3, in URI Template (level 1) format [RFC6570]. The URL MUST contain variables called \"types\", \"closeafter\", and \"ping\". The use of these variables is described in Section 7.3.",
      "ja": "セクション7.3で説明されているように、URIテンプレート（レベル1）形式のプッシュイベントのために接続するURL [RFC6570]。URLは、「種類」、「closeafter」、および「ピング」と呼ばれる変数を含まなければなりません。 これらの変数の使用については、セクション7.3で説明しています。"
    },
    {
      "indent": 3,
      "text": "o state: \"String\"",
      "ja": "o 状態：「文字列」"
    },
    {
      "indent": 6,
      "text": "A (preferably short) string representing the state of this object on the server. If the value of any other property on the Session object changes, this string will change. The current value is also returned on the API Response object (see Section 3.4), allowing clients to quickly determine if the session information has changed (e.g., an account has been added or removed), so they need to refetch the object.",
      "ja": "サーバー上のこのオブジェクトの状態を表す（できれば短い）文字列。 Sessionオブジェクトの他のプロパティの値が変更されると、この文字列も変更されます。 現在の値はAPI Responseオブジェクトにも返されます（セクション3.4を参照）。これにより、クライアントはセッション情報が変更されたか（アカウントが追加または削除されたかなど）をすばやく判断できるため、オブジェクトを再取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "To ensure future compatibility, other properties MAY be included on the Session object. Clients MUST ignore any properties they are not expecting.",
      "ja": "将来の互換性を確保するために、他のプロパティをSessionオブジェクトに含めることができます。 クライアントは、予期しないプロパティを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementors must take care to avoid inappropriate caching of the Session object at the HTTP layer. Since the client should only refetch when it detects there is a change (via the sessionState property of an API response), it is RECOMMENDED to disable HTTP caching altogether, for example, by setting \"Cache-Control: no-cache, no-store, must-revalidate\" on the response.",
      "ja": "実装者は、HTTP層でSessionオブジェクトの不適切なキャッシュを避けるように注意する必要があります。 クライアントは（API応答のsessionStateプロパティを介して）変更が検出された場合にのみ再フェッチする必要があるため、たとえば、「Cache-Control：no-cache、no-store 、再検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Example",
      "section_title": true,
      "ja": "2.1. 例"
    },
    {
      "indent": 3,
      "text": "In the following example Session object, the user has access to their own mail and contacts via JMAP, as well as read-only access to shared mail from another user. The server is advertising a custom \"https://example.com/apis/foobar\" capability.",
      "ja": "次のSessionオブジェクトの例では、ユーザーはJMAPを介して自分のメールと連絡先にアクセスできるほか、別のユーザーからの共有メールに読み取り専用でアクセスできます。 サーバーは、カスタムの「https://example.com/apis/foobar」機能をアドバタイズしています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"capabilities\": {\n    \"urn:ietf:params:jmap:core\": {\n      \"maxSizeUpload\": 50000000,\n      \"maxConcurrentUpload\": 8,\n      \"maxSizeRequest\": 10000000,\n      \"maxConcurrentRequest\": 8,\n      \"maxCallsInRequest\": 32,\n      \"maxObjectsInGet\": 256,\n      \"maxObjectsInSet\": 128,\n      \"collationAlgorithms\": [\n        \"i;ascii-numeric\",\n        \"i;ascii-casemap\",\n        \"i;unicode-casemap\"\n      ]\n    },\n    \"urn:ietf:params:jmap:mail\": {}\n    \"urn:ietf:params:jmap:contacts\": {},\n    \"https://example.com/apis/foobar\": {\n      \"maxFoosFinangled\": 42\n    }\n  },\n  \"accounts\": {\n    \"A13824\": {\n      \"name\": \"john@example.com\",\n      \"isPersonal\": true,\n      \"isReadOnly\": false,\n      \"accountCapabilities\": {\n        \"urn:ietf:params:jmap:mail\": {\n          \"maxMailboxesPerEmail\": null,\n          \"maxMailboxDepth\": 10,\n          ...\n        },\n        \"urn:ietf:params:jmap:contacts\": {\n          ...\n        }\n      }\n    },",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    \"A97813\": {\n      \"name\": \"jane@example.com\",\n      \"isPersonal\": false,\n      \"isReadOnly\": true,\n      \"accountCapabilities\": {\n        \"urn:ietf:params:jmap:mail\": {\n          \"maxMailboxesPerEmail\": 1,\n          \"maxMailboxDepth\": 10,\n          ...\n        }\n      }\n    }\n  },\n  \"primaryAccounts\": {\n    \"urn:ietf:params:jmap:mail\": \"A13824\",\n    \"urn:ietf:params:jmap:contacts\": \"A13824\"\n  },\n  \"username\": \"john@example.com\",\n  \"apiUrl\": \"https://jmap.example.com/api/\",\n  \"downloadUrl\": \"https://jmap.example.com\n    /download/{accountId}/{blobId}/{name}?accept={type}\",\n  \"uploadUrl\": \"https://jmap.example.com/upload/{accountId}/\",\n  \"eventSourceUrl\": \"https://jmap.example.com\n    /eventsource/?types={types}&closeafter={closeafter}&ping={ping}\",\n  \"state\": \"75128aab4b1b\"\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2. Service Autodiscovery",
      "section_title": true,
      "ja": "2.2. サービスの自動検出"
    },
    {
      "indent": 3,
      "text": "There are two standardised autodiscovery methods in use for Internet protocols:",
      "ja": "インターネットプロトコルに使用されている2つの標準化された自動検出方法があります。"
    },
    {
      "indent": 3,
      "text": "o DNS SRV (see [RFC2782], [RFC6186], and [RFC6764])",
      "ja": "o DNS SRV（[RFC2782]、[RFC6186]、および[RFC6764]を参照）"
    },
    {
      "indent": 3,
      "text": "o .well-known/servicename (see [RFC8615])",
      "ja": "o .well-known / servicename（[RFC8615]を参照）"
    },
    {
      "indent": 3,
      "text": "A JMAP-supporting host for the domain \"example.com\" SHOULD publish a SRV record \"_jmap._tcp.example.com\" that gives a hostname and port (usually port \"443\"). The JMAP Session resource is then \"https://${hostname}[:${port}]/.well-known/jmap\" (following any redirects).",
      "ja": "ドメイン「example.com」のJMAPをサポートするホストは、ホスト名とポート（通常はポート「443」）を提供するSRVレコード「_jmap._tcp.example.com」を発行する必要があります。 JMAPセッションリソースは、「https：// $ {hostname} [：$ {port}] /.well-known/jmap」になります（リダイレクトの後に続きます）。"
    },
    {
      "indent": 3,
      "text": "If the client has a username in the form of an email address, it MAY use the domain portion of this to attempt autodiscovery of the JMAP server.",
      "ja": "クライアントが電子メールアドレスの形式のユーザー名を持っている場合、このドメイン部分を使用してJMAPサーバーの自動検出を試みることができます。"
    },
    {
      "indent": 0,
      "text": "3. Structured Data Exchange",
      "section_title": true,
      "ja": "3. 構造化データ交換"
    },
    {
      "indent": 3,
      "text": "The client may make an API request to the server to get or set structured data. This request consists of an ordered series of method calls. These are processed by the server, which then returns an ordered series of responses.",
      "ja": "クライアントは、構造化データを取得または設定するためにサーバーにAPIリクエストを行う場合があります。 このリクエストは、順序付けられた一連のメソッド呼び出しで構成されます。 これらはサーバーによって処理され、サーバーは順序付けられた一連の応答を返します。"
    },
    {
      "indent": 0,
      "text": "3.1. Making an API Request",
      "section_title": true,
      "ja": "3.1. APIリクエストを行う"
    },
    {
      "indent": 3,
      "text": "To make an API request, the client makes an authenticated POST request to the API resource, which is defined by the \"apiUrl\" property in the Session object (see Section 2).",
      "ja": "APIリクエストを行うために、クライアントはAPIリソースに対して認証済みのPOSTリクエストを行います。これは、Sessionオブジェクトの「apiUrl」プロパティで定義されます（セクション2を参照）。"
    },
    {
      "indent": 3,
      "text": "The request MUST be of type \"application/json\" and consist of a single JSON-encoded \"Request\" object, as defined in Section 3.3. If successful, the response MUST also be of type \"application/json\" and consist of a single \"Response\" object, as defined in Section 3.4.",
      "ja": "リクエストは、タイプ「application / json」でなければならず、セクション3.3で定義されているように、JSONでエンコードされた単一の「リクエスト」オブジェクトで構成されている必要があります。 成功した場合、応答は「application / json」タイプであり、セクション3.4で定義されているように、単一の「応答」オブジェクトで構成されている必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. The Invocation Data Type",
      "section_title": true,
      "ja": "3.2. 呼び出しデータ型"
    },
    {
      "indent": 3,
      "text": "Method calls and responses are represented by the *Invocation* data type. This is a tuple, represented as a JSON array containing three elements:",
      "ja": "メソッドの呼び出しと応答は、* Invocation *データ型で表されます。 これは、3つの要素を含むJSON配列として表されるタプルです。"
    },
    {
      "indent": 3,
      "text": "1. A \"String\" *name* of the method to call or of the response.",
      "ja": "1. 呼び出すメソッドまたは応答の「文字列」*名前*。"
    },
    {
      "indent": 3,
      "text": "2. A \"String[*]\" object containing named *arguments* for that method or response.",
      "ja": "2. そのメソッドまたは応答の名前付き*引数*を含む「String [*]」オブジェクト。"
    },
    {
      "indent": 3,
      "text": "3. A \"String\" *method call id*: an arbitrary string from the client to be echoed back with the responses emitted by that method call (a method may return 1 or more responses, as it may make implicit calls to other methods; all responses initiated by this method call get the same method call id in the response).",
      "ja": "3. 「String」* method call id *：そのメソッド呼び出しによって発行された応答でエコーバックされるクライアントからの任意の文字列（メソッドは、他のメソッドを暗黙的に呼び出す可能性があるため、1つ以上の応答を返す場合があります。すべての応答 このメソッド呼び出しによって開始された応答で同じメソッド呼び出しIDを取得します）。"
    },
    {
      "indent": 0,
      "text": "3.3. The Request Object",
      "section_title": true,
      "ja": "3.3. リクエストオブジェクト"
    },
    {
      "indent": 3,
      "text": "A *Request* object has the following properties:",
      "ja": "* Request *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o using: \"String[]\"",
      "ja": "o 使用： \"String []\""
    },
    {
      "indent": 6,
      "text": "The set of capabilities the client wishes to use. The client MAY include capability identifiers even if the method calls it makes do not utilise those capabilities. The server advertises the set of specifications it supports in the Session object (see Section 2), as keys on the \"capabilities\" property.",
      "ja": "クライアントが使用したい機能のセット。 クライアントは、メソッド呼び出しがそれらの機能を利用しない場合でも、機能識別子を含めることができます。 サーバーは、 \"capabilities\"プロパティのキーとして、Sessionオブジェクト（セクション2を参照）でサポートする一連の仕様をアドバタイズします。"
    },
    {
      "indent": 3,
      "text": "o methodCalls: \"Invocation[]\"",
      "ja": "o methodCalls： \"Invocation []\""
    },
    {
      "indent": 6,
      "text": "An array of method calls to process on the server. The method calls MUST be processed sequentially, in order.",
      "ja": "サーバーで処理するメソッド呼び出しの配列。 メソッド呼び出しは順番に順番に処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "o createdIds: \"Id[Id]\" (optional)",
      "ja": "o createdIds： \"Id [Id]\"（オプション）"
    },
    {
      "indent": 6,
      "text": "A map of a (client-specified) creation id to the id the server assigned when a record was successfully created.",
      "ja": "レコードが正常に作成されたときにサーバーが割り当てたIDへの（クライアント指定の）作成IDのマップ。"
    },
    {
      "indent": 6,
      "text": "As described later in this specification, some records may have a property that contains the id of another record. To allow more efficient network usage, you can set this property to reference a record created earlier in the same API request. Since the real id is unknown when the request is created, the client can instead specify the creation id it assigned, prefixed with a \"#\" (see Section 5.3 for more details).",
      "ja": "この仕様で後述するように、一部のレコードには、別のレコードのIDを含むプロパティがある場合があります。 ネットワークをより効率的に使用できるようにするために、同じAPIリクエストで以前に作成されたレコードを参照するようにこのプロパティを設定できます。 リクエストの作成時には実際のIDは不明であるため、クライアントは代わりに「＃」を接頭辞として割り当てた作成IDを指定できます（詳細はセクション5.3を参照）。"
    },
    {
      "indent": 6,
      "text": "As the server processes API requests, any time it successfully creates a new record, it adds the creation id to this map (see the \"create\" argument to /set in Section 5.3), with the server-assigned real id as the value. If it comes across a reference to a creation id in a create/update, it looks it up in the map and replaces the reference with the real id, if found.",
      "ja": "サーバーがAPIリクエストを処理するとき、新しいレコードを正常に作成するたびに、サーバーに割り当てられた実際のIDを値として、作成マップをこのマップに追加します（セクション5.3の「/ set」引数を参照）。 作成/更新で作成IDへの参照に出くわすと、マップでそれを検索し、参照が見つかった場合は実際のIDに置き換えます。"
    },
    {
      "indent": 6,
      "text": "The client can pass an initial value for this map as the \"createdIds\" property of the Request object. This may be an empty object. If given in the request, the response will also include a createdIds property. This allows proxy servers to easily split a JMAP request into multiple JMAP requests to send to different servers. For example, it could send the first two method calls to server A, then the third to server B, before sending the fourth to server A again. By passing the createdIds of the previous response to the next request, it can ensure all of these still resolve. See Section 5.8 for further discussion of proxy considerations.",
      "ja": "クライアントは、このマップの初期値をRequestオブジェクトの「createdIds」プロパティとして渡すことができます。 これは空のオブジェクトである可能性があります。 リクエストで指定された場合、レスポンスにはcreatedIdsプロパティも含まれます。 これにより、プロキシサーバーはJMAP要求を複数のJMAP要求に簡単に分割して、異なるサーバーに送信できます。 たとえば、最初の2つのメソッド呼び出しをサーバーAに送信し、3番目をサーバーBに送信してから、4番目をサーバーAに再度送信します。 前の応答のcreatedIdsを次の要求に渡すことで、これらすべてが解決されることを保証できます。 プロキシの考慮事項の詳細については、セクション5.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Future specifications MAY add further properties to the Request object to extend the semantics. To ensure forwards compatibility, a server MUST ignore any other properties it does not understand on the JMAP Request object.",
      "ja": "将来の仕様では、セマンティクスを拡張するために、Requestオブジェクトにさらにプロパティを追加できます。 前方互換性を確保するために、サーバーは、JMAP Requestオブジェクトで理解できない他のプロパティを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Example Request",
      "section_title": true,
      "ja": "3.3.1. リクエスト例"
    },
    {
      "indent": 0,
      "text": "{\n  \"using\": [ \"urn:ietf:params:jmap:core\", \"urn:ietf:params:jmap:mail\" ],\n  \"methodCalls\": [\n    [ \"method1\", {\n      \"arg1\": \"arg1data\",\n      \"arg2\": \"arg2data\"\n    }, \"c1\" ],\n    [ \"method2\", {\n      \"arg1\": \"arg1data\"\n    }, \"c2\" ],\n    [ \"method3\", {}, \"c3\" ]\n  ]\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.4. The Response Object",
      "section_title": true,
      "ja": "3.4. 応答オブジェクト"
    },
    {
      "indent": 3,
      "text": "A *Response* object has the following properties:",
      "ja": "* Response *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o methodResponses: \"Invocation[]\"",
      "ja": "o methodResponses： \"Invocation []\""
    },
    {
      "indent": 6,
      "text": "An array of responses, in the same format as the \"methodCalls\" on the Request object. The output of the methods MUST be added to the \"methodResponses\" array in the same order that the methods are processed.",
      "ja": "要求オブジェクトの「methodCalls」と同じ形式の応答の配列。 メソッドの出力は、メソッドが処理されるのと同じ順序で「methodResponses」配列に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "o createdIds: \"Id[Id]\" (optional; only returned if given in the request)",
      "ja": "o createdIds： \"Id [Id]\"（オプション。リクエストで指定された場合にのみ返されます）"
    },
    {
      "indent": 6,
      "text": "A map of a (client-specified) creation id to the id the server assigned when a record was successfully created. This MUST include all creation ids passed in the original createdIds parameter of the Request object, as well as any additional ones added for newly created records.",
      "ja": "レコードが正常に作成されたときにサーバーが割り当てたIDへの（クライアント指定の）作成IDのマップ。 これには、リクエストオブジェクトの元のcreatedIdsパラメータで渡されたすべての作成IDと、新しく作成されたレコードに追加された追加IDを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o sessionState: \"String\"",
      "ja": "o sessionState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The current value of the \"state\" string on the Session object, as described in Section 2. Clients may use this to detect if this object has changed and needs to be refetched.",
      "ja": "セッションオブジェクトの「状態」文字列の現在の値。セクション2で説明します。クライアントはこれを使用して、このオブジェクトが変更され、再取得する必要があるかどうかを検出できます。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified, if the method call completed successfully, its response name is the same as the method name in the request.",
      "ja": "特に指定しない限り、メソッド呼び出しが正常に完了した場合、その応答名はリクエスト内のメソッド名と同じです。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Example Response",
      "section_title": true,
      "ja": "3.4.1. 応答例"
    },
    {
      "indent": 19,
      "text": "{\n  \"methodResponses\": [\n    [ \"method1\", {\n      \"arg1\": 3,\n      \"arg2\": \"foo\"\n    }, \"c1\" ],\n    [ \"method2\", {\n      \"isBlah\": true\n    }, \"c2\" ],\n    [ \"anotherResponseFromMethod2\", {\n      \"data\": 10,\n      \"yetmoredata\": \"Hello\"\n    }, \"c2\"],\n    [ \"error\", {\n      \"type\":\"unknownMethod\"\n    }, \"c3\" ]\n  ],\n  \"sessionState\": \"75128aab4b1b\"\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5. Omitting Arguments",
      "section_title": true,
      "ja": "3.5. 引数を省略する"
    },
    {
      "indent": 3,
      "text": "An argument to a method may be specified to have a default value. If omitted by the client, the server MUST treat the method call the same as if the default value had been specified. Similarly, the server MAY omit any argument in a response that has the default value.",
      "ja": "メソッドへの引数は、デフォルト値を持つように指定できます。 クライアントが省略した場合、サーバーはメソッド呼び出しをデフォルト値が指定された場合と同じように扱わなければなりません。 同様に、サーバーは、デフォルト値を持つ応答の引数を省略してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified in a method description, null is the default value for any argument in a request or response where this is allowed by the type signature. Other arguments may only be omitted if an explicit default value is defined in the method description.",
      "ja": "メソッドの説明で特に指定されていない限り、nullは、タイプシグネチャで許可されている要求または応答の引数のデフォルト値です。 他の引数は、メソッドの説明で明示的なデフォルト値が定義されている場合にのみ省略できます。"
    },
    {
      "indent": 0,
      "text": "3.6. Errors",
      "section_title": true,
      "ja": "3.6. エラー"
    },
    {
      "indent": 3,
      "text": "There are three different levels of granularity at which an error may be returned in JMAP.",
      "ja": "JMAPでエラーが返される粒度には3つの異なるレベルがあります。"
    },
    {
      "indent": 3,
      "text": "When an API request is made, the request as a whole may be rejected due to rate limiting, malformed JSON, request for an unknown capability, etc. In this case, the entire request is rejected with an appropriate HTTP error response code and an additional JSON body with more detail for the client.",
      "ja": "APIリクエストが行われると、レート制限、不正なJSON、未知の機能のリクエストなどにより、リクエスト全体が拒否される場合があります。この場合、リクエスト全体が適切なHTTPエラーレスポンスコードと追加で拒否されます クライアントの詳細を含むJSON本体。"
    },
    {
      "indent": 3,
      "text": "Provided the request itself is syntactically valid (the JSON is valid and when decoded, it matches the type signature of a Request object), the methods within it are executed sequentially by the server. Each method may individually fail, for example, if invalid arguments are given or an unknown method name is called.",
      "ja": "リクエスト自体が構文的に有効である（JSONが有効であり、デコードされると、リクエストオブジェクトのタイプシグネチャと一致する）場合、その中のメソッドはサーバーによって順次実行されます。 たとえば、無効な引数が指定されたり、不明なメソッド名が呼び出されたりすると、各メソッドは個別に失敗する場合があります。"
    },
    {
      "indent": 3,
      "text": "Finally, methods that make changes to the server state often act upon a number of different records within a single call. Each record change may be separately rejected with a SetError, as described in Section 5.3.",
      "ja": "最後に、サーバーの状態を変更するメソッドは、多くの場合、1回の呼び出しで多くの異なるレコードに作用します。 セクション5.3で説明されているように、各レコードの変更はSetErrorで個別に拒否される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Request-Level Errors",
      "section_title": true,
      "ja": "3.6.1. 要求レベルのエラー"
    },
    {
      "indent": 3,
      "text": "When an HTTP error response is returned to the client, the server SHOULD return a JSON \"problem details\" object as the response body, as per [RFC7807].",
      "ja": "HTTPエラー応答がクライアントに返されると、サーバーは[RFC7807]に従って、JSONの「問題の詳細」オブジェクトを応答本文として返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The following problem types are defined:",
      "ja": "次の問題タイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "o \"urn:ietf:params:jmap:error:unknownCapability\" The client included a capability in the \"using\" property of the request that the server does not support.",
      "ja": "o 「urn：ietf：params：jmap：error：unknownCapability」クライアントは、サーバーがサポートしていないリクエストの「using」プロパティに機能を含めました。"
    },
    {
      "indent": 3,
      "text": "o \"urn:ietf:params:jmap:error:notJSON\" The content type of the request was not \"application/json\" or the request did not parse as I-JSON.",
      "ja": "o 「urn：ietf：params：jmap：error：notJSON」リクエストのコンテンツタイプが「application / json」ではなかったか、リクエストがI-JSONとして解析されませんでした。"
    },
    {
      "indent": 3,
      "text": "o \"urn:ietf:params:jmap:error:notRequest\" The request parsed as JSON but did not match the type signature of the Request object.",
      "ja": "o \"urn：ietf：params：jmap：error：notRequest\"リクエストはJSONとして解析されましたが、リクエストオブジェクトのタイプシグネチャと一致しませんでした。"
    },
    {
      "indent": 3,
      "text": "o \"urn:ietf:params:jmap:error:limit\" The request was not processed as it would have exceeded one of the request limits defined on the capability object, such as maxSizeRequest, maxCallsInRequest, or maxConcurrentRequests. A \"limit\" property MUST also be present on the \"problem details\" object, containing the name of the limit being applied.",
      "ja": "o 「urn：ietf：params：jmap：error：limit」maxSizeRequest、maxCallsInRequest、maxConcurrentRequestsなど、機能オブジェクトで定義された要求制限のいずれかを超えたため、要求は処理されませんでした。 「制限」プロパティは、適用される制限の名前を含む「問題の詳細」オブジェクトにも存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.1.1. Example",
      "section_title": true,
      "ja": "3.6.1.1. 例"
    },
    {
      "indent": 7,
      "text": "{\n  \"type\": \"urn:ietf:params:jmap:error:unknownCapability\",\n  \"status\": 400,\n  \"detail\": \"The Request object used capability\n    'https://example.com/apis/foobar', which is not supported\n    by this server.\"\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Another example:",
      "ja": "もう一つの例："
    },
    {
      "indent": 5,
      "text": "{\n  \"type\": \"urn:ietf:params:jmap:error:limit\",\n  \"limit\": \"maxSizeRequest\",\n  \"status\": 400,\n  \"detail\": \"The request is larger than the server is willing to\n             process.\"\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.6.2. Method-Level Errors",
      "section_title": true,
      "ja": "3.6.2. メソッドレベルのエラー"
    },
    {
      "indent": 3,
      "text": "If a method encounters an error, the appropriate \"error\" response MUST be inserted at the current point in the \"methodResponses\" array and, unless otherwise specified, further processing MUST NOT happen within that method call.",
      "ja": "メソッドでエラーが発生した場合、適切な「エラー」応答を「methodResponses」配列の現在のポイントに挿入する必要があり、特に指定しない限り、そのメソッド呼び出し内でさらに処理を行ってはなりません。"
    },
    {
      "indent": 3,
      "text": "Any further method calls in the request MUST then be processed as normal. Errors at the method level MUST NOT generate an HTTP-level error.",
      "ja": "リクエスト内のそれ以降のメソッド呼び出しは、通常どおり処理する必要があります。 メソッドレベルのエラーは、HTTPレベルのエラーを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "An \"error\" response looks like this:",
      "ja": "「エラー」応答は次のようになります。"
    },
    {
      "indent": 25,
      "text": "[ \"error\", {\n  \"type\": \"unknownMethod\"\n}, \"call-id\" ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The response name is \"error\", and it MUST have a type property. Other properties may be present with further information; these are detailed in the error type descriptions where appropriate.",
      "ja": "応答名は「エラー」であり、typeプロパティを持たなければなりません。 その他のプロパティには、詳細情報が含まれている場合があります。 これらは、必要に応じてエラータイプの説明で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "With the exception of when the \"serverPartialFail\" error is returned, the externally visible state of the server MUST NOT have changed if an error is returned at the method level.",
      "ja": "「serverPartialFail」エラーが返される場合を除き、エラーがメソッドレベルで返される場合、サーバーの外部から見える状態は変更されてはなりません。"
    },
    {
      "indent": 3,
      "text": "The following error types are defined, which may be returned for any method call where appropriate:",
      "ja": "以下のエラータイプが定義されており、必要に応じてメソッド呼び出しに対して返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"serverUnavailable\": Some internal server resource was temporarily unavailable. Attempting the same operation later (perhaps after a backoff with a random factor) may succeed.",
      "ja": "\"serverUnavailable\"：一部の内部サーバーリソースが一時的に利用できませんでした。 後で同じ操作を試行する（おそらく、ランダムな要因によるバックオフの後）ことがあります。"
    },
    {
      "indent": 3,
      "text": "\"serverFail\": An unexpected or unknown error occurred during the processing of the call. A \"description\" property should provide more details about the error. The method call made no changes to the server's state. Attempting the same operation again is expected to fail again. Contacting the service administrator is likely necessary to resolve this problem if it is persistent.",
      "ja": "「serverFail」：コールの処理中に予期しないエラーまたは不明なエラーが発生しました。 「説明」プロパティは、エラーに関する詳細を提供する必要があります。 メソッド呼び出しは、サーバーの状態を変更しませんでした。 同じ操作を再試行すると、再び失敗することが予想されます。 この問題が解決しない場合は、おそらくサービス管理者に連絡する必要があります。"
    },
    {
      "indent": 3,
      "text": "\"serverPartialFail\": Some, but not all, expected changes described by the method occurred. The client MUST resynchronise impacted data to determine server state. Use of this error is strongly discouraged.",
      "ja": "「serverPartialFail」：メソッドによって記述された予期される変更がすべてではありませんが、発生しました。 クライアントは、サーバーの状態を判断するために、影響を受けるデータを再同期する必要があります。 このエラーの使用は強く推奨されていません。"
    },
    {
      "indent": 3,
      "text": "\"unknownMethod\": The server does not recognise this method name.",
      "ja": "\"unknownMethod\"：サーバーはこのメソッド名を認識しません。"
    },
    {
      "indent": 3,
      "text": "\"invalidArguments\": One of the arguments is of the wrong type or is otherwise invalid, or a required argument is missing. A \"description\" property MAY be present to help debug with an explanation of what the problem was. This is a non-localised string, and it is not intended to be shown directly to end users.",
      "ja": "「invalidArguments」：引数の1つが間違ったタイプであるか、無効であるか、必要な引数がありません。 問題が何であったかを説明するデバッグを支援するために、「説明」プロパティが存在する場合があります。 これはローカライズされていない文字列であり、エンドユーザーに直接表示されることを意図していません。"
    },
    {
      "indent": 3,
      "text": "\"invalidResultReference\": The method used a result reference for one of its arguments (see Section 3.7), but this failed to resolve.",
      "ja": "「invalidResultReference」：メソッドは引数の1つに結果参照を使用しました（セクション3.7を参照）が、これは解決できませんでした。"
    },
    {
      "indent": 3,
      "text": "\"forbidden\": The method and arguments are valid, but executing the method would violate an Access Control List (ACL) or other permissions policy.",
      "ja": "「禁止」：メソッドと引数は有効ですが、メソッドの実行はアクセス制御リスト（ACL）またはその他のアクセス許可ポリシーに違反します。"
    },
    {
      "indent": 3,
      "text": "\"accountNotFound\": The accountId does not correspond to a valid account.",
      "ja": "\"accountNotFound\"：accountIdは有効なアカウントに対応していません。"
    },
    {
      "indent": 3,
      "text": "\"accountNotSupportedByMethod\": The accountId given corresponds to a valid account, but the account does not support this method or data type.",
      "ja": "\"accountNotSupportedByMethod\"：指定されたaccountIdは有効なアカウントに対応していますが、アカウントはこのメソッドまたはデータ型をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "\"accountReadOnly\": This method modifies state, but the account is read-only (as returned on the corresponding Account object in the JMAP Session resource).",
      "ja": "\"accountReadOnly\"：このメソッドは状態を変更しますが、アカウントは読み取り専用です（JMAP Sessionリソースの対応するAccountオブジェクトで返されます）。"
    },
    {
      "indent": 3,
      "text": "Further possible errors for a particular method are specified in the method descriptions.",
      "ja": "特定のメソッドでさらに発生する可能性のあるエラーは、メソッドの説明で指定されています。"
    },
    {
      "indent": 3,
      "text": "Further general errors MAY be defined in future RFCs. Should a client receive an error type it does not understand, it MUST treat it the same as the \"serverFail\" type.",
      "ja": "さらに一般的なエラーは、将来のRFCで定義される場合があります。 クライアントが理解できないエラータイプを受け取った場合、「serverFail」タイプと同じように扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.7. References to Previous Method Results",
      "section_title": true,
      "ja": "3.7. 以前のメソッド結果への参照"
    },
    {
      "indent": 3,
      "text": "To allow clients to make more efficient use of the network and avoid round trips, an argument to one method can be taken from the result of a previous method call in the same request.",
      "ja": "クライアントがネットワークをより効率的に使用し、往復を回避できるようにするために、1つのメソッドへの引数は、同じリクエスト内の以前のメソッド呼び出しの結果から取得できます。"
    },
    {
      "indent": 3,
      "text": "To do this, the client prefixes the argument name with \"#\" (an octothorpe). The value is a ResultReference object as described below. When processing a method call, the server MUST first check the arguments object for any names beginning with \"#\". If found, the result reference should be resolved and the value used as the \"real\" argument. The method is then processed as normal. If any result reference fails to resolve, the whole method MUST be rejected with an \"invalidResultReference\" error. If an arguments object contains the same argument name in normal and referenced form (e.g., \"foo\" and \"#foo\"), the method MUST return an \"invalidArguments\" error.",
      "ja": "これを行うために、クライアントは引数名の前に「＃」（オクトソープ）を付けます。 この値は、以下で説明するResultReferenceオブジェクトです。 メソッド呼び出しを処理するとき、サーバーは最初に「＃」で始まる名前の引数オブジェクトをチェックする必要があります。 見つかった場合、結果参照が解決され、値が「実際の」引数として使用されます。 その後、メソッドは通常どおり処理されます。 結果の参照が解決に失敗した場合、「invalidResultReference」エラーでメソッド全体が拒否されなければなりません。 引数オブジェクトに通常の参照された形式で同じ引数名（たとえば、「foo」と「#foo」）が含まれている場合、メソッドは「invalidArguments」エラーを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "A *ResultReference* object has the following properties:",
      "ja": "* ResultReference *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o resultOf: \"String\"",
      "ja": "o resultOf： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The method call id (see Section 3.2) of a previous method call in the current request.",
      "ja": "現在のリクエストの前のメソッド呼び出しのメソッド呼び出しID（セクション3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o name: \"String\"",
      "ja": "o 名前：「ストリング」"
    },
    {
      "indent": 6,
      "text": "The required name of a response to that method call.",
      "ja": "そのメソッド呼び出しへの応答に必要な名前。"
    },
    {
      "indent": 3,
      "text": "o path: \"String\"",
      "ja": "o パス：「文字列」"
    },
    {
      "indent": 6,
      "text": "A pointer into the arguments of the response selected via the name and resultOf properties. This is a JSON Pointer [RFC6901], except it also allows the use of \"*\" to map through an array (see the description below).",
      "ja": "nameおよびresultOfプロパティを介して選択された応答の引数へのポインター。 これはJSONポインター[RFC6901]です。ただし、「*」を使用して配列をマッピングすることもできます（以下の説明を参照）。"
    },
    {
      "indent": 3,
      "text": "To resolve:",
      "ja": "解決する："
    },
    {
      "indent": 3,
      "text": "1. Find the first response with a method call id identical to the \"resultOf\" property of the ResultReference in the \"methodResponses\" array from previously processed method calls in the same request. If none, evaluation fails.",
      "ja": "1. 同じリクエストで以前に処理されたメソッド呼び出しから、「methodResponses」配列内のResultReferenceの「resultOf」プロパティと同一のメソッド呼び出しIDを持つ最初の応答を見つけます。 存在しない場合、評価は失敗します。"
    },
    {
      "indent": 3,
      "text": "2. If the response name is not identical to the \"name\" property of the ResultReference, evaluation fails.",
      "ja": "2. 応答名がResultReferenceの「name」プロパティと同一でない場合、評価は失敗します。"
    },
    {
      "indent": 3,
      "text": "3. Apply the \"path\" to the arguments object of the response (the second item in the response array) following the JSON Pointer algorithm [RFC6901], except with the following addition in \"Evaluation\" (see Section 4):",
      "ja": "3. JSONポインターアルゴリズム[RFC6901]に従って、応答の引数オブジェクト（応答配列の2番目の項目）に「パス」を適用します。ただし、「評価」に以下を追加します（セクション4を参照）。"
    },
    {
      "indent": 7,
      "text": "If the currently referenced value is a JSON array, the reference token may be exactly the single character \"*\", making the new referenced value the result of applying the rest of the JSON Pointer tokens to every item in the array and returning the results in the same order in a new array. If the result of applying the rest of the pointer tokens to each item was itself an array, the contents of this array are added to the output rather than the array itself (i.e., the result is flattened from an array of arrays to a single array). If the result of applying the rest of the pointer tokens to a value was itself an array, its items should be included individually in the output rather than including the array itself (i.e., the result is flattened from an array of arrays to a single array).",
      "ja": "現在参照されている値がJSON配列である場合、参照トークンは正確に単一文字「*」である場合があり、新しい参照値はJSONポインタートークンの残りを配列内のすべてのアイテムに適用し、結果を返します 新しい配列の同じ順序。 各項目に残りのポインタートークンを適用した結果がそれ自体配列である場合、この配列の内容は配列自体ではなく出力に追加されます（つまり、結果は配列の配列から単一の配列にフラット化されます） ）。 残りのポインタートークンを値に適用した結果自体が配列である場合、その項目は配列自体を含めるのではなく、出力に個別に含める必要があります（つまり、結果は配列の配列から単一の配列にフラット化されます） ）。"
    },
    {
      "indent": 3,
      "text": "As a simple example, suppose we have the following API request \"methodCalls\":",
      "ja": "簡単な例として、次のAPIリクエスト「methodCalls」があるとします。"
    },
    {
      "indent": 22,
      "text": "[[ \"Foo/changes\", {\n    \"accountId\": \"A1\",\n    \"sinceState\": \"abcdef\"\n}, \"t0\" ],\n[ \"Foo/get\", {\n    \"accountId\": \"A1\",\n    \"#ids\": {\n        \"resultOf\": \"t0\",\n        \"name\": \"Foo/changes\",\n        \"path\": \"/created\"\n    }\n}, \"t1\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "After executing the first method call, the \"methodResponses\" array is:",
      "ja": "最初のメソッド呼び出しを実行した後、「methodResponses」配列は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "[[ \"Foo/changes\", {\n    \"accountId\": \"A1\",\n    \"oldState\": \"abcdef\",\n    \"newState\": \"123456\",\n    \"hasMoreChanges\": false,\n    \"created\": [ \"f1\", \"f4\" ],\n    \"updated\": [],\n    \"destroyed\": []\n}, \"t0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To execute the \"Foo/get\" call, we look through the arguments and find there is one with a \"#\" prefix. To resolve this, we apply the algorithm above:",
      "ja": "「Foo / get」呼び出しを実行するには、引数を調べて、「＃」プレフィックスが付いている引数があることを見つけます。 これを解決するには、上記のアルゴリズムを適用します。"
    },
    {
      "indent": 3,
      "text": "1. Find the first response with method call id \"t0\". The \"Foo/ changes\" response fulfils this criterion.",
      "ja": "1. メソッド呼び出しID「t0」を持つ最初の応答を見つけます。 「Foo / changes」応答はこの基準を満たしています。"
    },
    {
      "indent": 3,
      "text": "2. Check that the response name is the same as in the result reference. It is, so this is fine.",
      "ja": "2. 応答名が結果参照と同じであることを確認してください。 それで、これは大丈夫です。"
    },
    {
      "indent": 3,
      "text": "3. Apply the \"path\" as a JSON Pointer to the arguments object. This simply selects the \"created\" property, so the result of evaluating is: [ \"f1\", \"f4\" ].",
      "ja": "3. 引数オブジェクトへのJSONポインターとして「パス」を適用します。 これは単に「作成された」プロパティを選択するため、評価の結果は次のようになります：[\"f1\"、 \"f4\"]。"
    },
    {
      "indent": 3,
      "text": "The JMAP server now continues to process the \"Foo/get\" call as though the arguments were:",
      "ja": "JMAPサーバーは、引数が次のように「Foo / get」呼び出しを処理し続けるようになりました。"
    },
    {
      "indent": 25,
      "text": "{\n    \"accountId\": \"A1\",\n    \"ids\": [ \"f1\", \"f4\" ]\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, a more complicated example using the JMAP Mail data model: fetch the \"from\"/\"date\"/\"subject\" for every Email in the first 10 Threads in the inbox (sorted newest first):",
      "ja": "ここで、JMAPメールデータモデルを使用したより複雑な例：受信ボックスの最初の10スレッド（最新のものから順に）のすべての電子メールの「from」/「date」/「subject」を取得します。"
    },
    {
      "indent": 6,
      "text": "[[ \"Email/query\", {\n  \"accountId\": \"A1\",\n  \"filter\": { \"inMailbox\": \"id_of_inbox\" },\n  \"sort\": [{ \"property\": \"receivedAt\", \"isAscending\": false }],\n  \"collapseThreads\": true,\n  \"position\": 0,\n  \"limit\": 10,\n  \"calculateTotal\": true\n}, \"t0\" ],\n[ \"Email/get\", {\n  \"accountId\": \"A1\",\n  \"#ids\": {\n    \"resultOf\": \"t0\",\n    \"name\": \"Email/query\",\n    \"path\": \"/ids\"\n  },\n  \"properties\": [ \"threadId\" ]\n}, \"t1\" ],\n[ \"Thread/get\", {\n  \"accountId\": \"A1\",\n  \"#ids\": {\n    \"resultOf\": \"t1\",\n    \"name\": \"Email/get\",\n    \"path\": \"/list/*/threadId\"\n  }\n}, \"t2\" ],\n[ \"Email/get\", {\n  \"accountId\": \"A1\",\n  \"#ids\": {\n    \"resultOf\": \"t2\",\n    \"name\": \"Thread/get\",\n    \"path\": \"/list/*/emailIds\"\n  },\n  \"properties\": [ \"from\", \"receivedAt\", \"subject\" ]\n}, \"t3\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "After executing the first 3 method calls, the \"methodResponses\" array might be:",
      "ja": "最初の3つのメソッド呼び出しを実行した後、「methodResponses」配列は次のようになります。"
    },
    {
      "indent": 7,
      "text": "[[ \"Email/query\", {\n    \"accountId\": \"A1\",\n    \"queryState\": \"abcdefg\",\n    \"canCalculateChanges\": true,\n    \"position\": 0,\n    \"total\": 101,\n    \"ids\": [ \"msg1023\", \"msg223\", \"msg110\", \"msg93\", \"msg91\",\n        \"msg38\", \"msg36\", \"msg33\", \"msg11\", \"msg1\" ]\n}, \"t0\" ],\n[ \"Email/get\", {\n    \"accountId\": \"A1\",\n    \"state\": \"123456\",\n    \"list\": [{\n        \"id\": \"msg1023\",\n        \"threadId\": \"trd194\"\n    }, {\n        \"id\": \"msg223\",\n        \"threadId\": \"trd114\"\n    },\n    ...\n    ],\n    \"notFound\": []\n}, \"t1\" ],\n[ \"Thread/get\", {\n    \"accountId\": \"A1\",\n    \"state\": \"123456\",\n    \"list\": [{\n        \"id\": \"trd194\",\n        \"emailIds\": [ \"msg1020\", \"msg1021\", \"msg1023\" ]\n    }, {\n        \"id\": \"trd114\",\n        \"emailIds\": [ \"msg201\", \"msg223\" ]\n    },\n    ...\n    ],\n    \"notFound\": []\n}, \"t2\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To execute the final \"Email/get\" call, we look through the arguments and find there is one with a \"#\" prefix. To resolve this, we apply the algorithm:",
      "ja": "最後の「Email / get」呼び出しを実行するために、引数を調べて、「＃」プレフィックスを持つものがあることを見つけます。 これを解決するために、アルゴリズムを適用します："
    },
    {
      "indent": 3,
      "text": "1. Find the first response with method call id \"t2\". The \"Thread/ get\" response fulfils this criterion.",
      "ja": "1. メソッド呼び出しID「t2」を持つ最初の応答を見つけます。 「Thread / get」応答は、この基準を満たしています。"
    },
    {
      "indent": 3,
      "text": "2. \"Thread/get\" is the name specified in the result reference, so this is fine.",
      "ja": "2. 「Thread / get」は結果参照で指定された名前なので、これで問題ありません。"
    },
    {
      "indent": 3,
      "text": "3. Apply the \"path\" as a JSON Pointer to the arguments object. Token by token:",
      "ja": "3. 引数オブジェクトへのJSONポインターとして「パス」を適用します。 トークンごとのトークン："
    },
    {
      "indent": 7,
      "text": "1. \"list\": get the array of thread objects",
      "ja": "1. 「リスト」：スレッドオブジェクトの配列を取得"
    },
    {
      "indent": 7,
      "text": "2. \"*\": for each of the items in the array:",
      "ja": "2. 「*」：配列内の各アイテム："
    },
    {
      "indent": 11,
      "text": "a. \"emailIds\": get the array of Email ids",
      "ja": "a。 「emailIds」：電子メールIDの配列を取得します"
    },
    {
      "indent": 11,
      "text": "b. Concatenate these into a single array of all the ids in the result.",
      "ja": "b。 これらを結果のすべてのIDの単一の配列に連結します。"
    },
    {
      "indent": 3,
      "text": "The JMAP server now continues to process the \"Email/get\" call as though the arguments were:",
      "ja": "JMAPサーバーは、引数が次のように「Email / get」呼び出しを処理し続けるようになりました。"
    },
    {
      "indent": 0,
      "text": "{\n    \"accountId\": \"A1\",\n    \"ids\": [ \"msg1020\", \"msg1021\", \"msg1023\", \"msg201\", \"msg223\", ... ],\n    \"properties\": [ \"from\", \"receivedAt\", \"subject\" ]\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The ResultReference performs a similar role to that of the creation id, in that it allows a chained method call to refer to information not available when the request is generated. However, they are different things and not interchangeable; the only commonality is the octothorpe used to indicate them.",
      "ja": "ResultReferenceは、要求が生成されたときに利用できない情報をチェーンメソッド呼び出しが参照できるようにするという点で、作成IDと同様の役割を実行します。 ただし、それらは異なるものであり、互換性はありません。 唯一の共通点は、それらを示すために使用されるオクトソープです。"
    },
    {
      "indent": 0,
      "text": "3.8. Localisation of User-Visible Strings",
      "section_title": true,
      "ja": "3.8. ユーザーに見える文字列のローカライズ"
    },
    {
      "indent": 3,
      "text": "If returning a custom string to be displayed to the user, for example, an error message, the server SHOULD use information from the Accept-Language header of the request (as defined in Section 5.3.5 of [RFC7231]) to choose the best available localisation. The Content-Language header of the response (see Section 3.1.3.2 of [RFC7231]) SHOULD indicate the language being used for user-visible strings.",
      "ja": "エラーメッセージなど、ユーザーに表示するカスタム文字列を返す場合、サーバーはリクエストのAccept-Languageヘッダー（[RFC7231]のセクション5.3.5で定義）からの情報を使用して最適なものを選択する必要があります（SHOULD） 利用可能なローカリゼーション。 応答のContent-Languageヘッダー（[RFC7231]のセクション3.1.3.2を参照）は、ユーザーに表示される文字列に使用されている言語を示す必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a request was made with the following header:",
      "ja": "たとえば、次のヘッダーを使用してリクエストが行われたとします。"
    },
    {
      "indent": 7,
      "text": "Accept-Language: fr-CH, fr;q=0.9, de;q=0.8, en;q=0.7, *;q=0.5",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and a method generated an error to display to the user. The server has translations of the error message in English and German. Looking at the Accept-Language header, the user's preferred language is French. Since we don't have a translation for this, we look at the next most preferred, which is German. We have a German translation, so the server returns this and indicates the language chosen in a Content-Language header like so:",
      "ja": "また、メソッドはユーザーに表示するエラーを生成しました。 サーバーには、英語とドイツ語のエラーメッセージの翻訳があります。 Accept-Languageヘッダーを見ると、ユーザーの優先言語はフランス語です。 これに関する翻訳がないため、次に優先されるドイツ語を見てみましょう。 ドイツ語の翻訳があるので、サーバーはこれを返し、Content-Languageヘッダーで選択された言語を次のように示します。"
    },
    {
      "indent": 27,
      "text": "Content-Language: de",
      "ja": "コンテンツ言語：de"
    },
    {
      "indent": 0,
      "text": "3.9. Security",
      "section_title": true,
      "ja": "3.9. セキュリティ"
    },
    {
      "indent": 3,
      "text": "As always, the server must be strict about data received from the client. Arguments need to be checked for validity; a malicious user could attempt to find an exploit through the API. In case of invalid arguments (unknown/insufficient/wrong type for data, etc.), the method MUST return an \"invalidArguments\" error and terminate.",
      "ja": "いつものように、サーバーはクライアントから受信したデータについて厳格でなければなりません。 引数の有効性を確認する必要があります。 悪意のあるユーザーがAPIを介してエクスプロイトを見つけようとする可能性があります。 無効な引数（データの不明/不十分/間違ったタイプなど）の場合、メソッドは「invalidArguments」エラーを返して終了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.10. Concurrency",
      "section_title": true,
      "ja": "3.10. 並行性"
    },
    {
      "indent": 3,
      "text": "Method calls within a single request MUST be executed in order. However, method calls from different concurrent API requests may be interleaved. This means that the data on the server may change between two method calls within a single API request.",
      "ja": "単一のリクエスト内のメソッド呼び出しは順番に実行する必要があります。 ただし、異なる同時API要求からのメソッド呼び出しはインターリーブされる場合があります。 つまり、サーバー上のデータは、単一のAPIリクエスト内の2つのメソッド呼び出し間で変更される可能性があります。"
    },
    {
      "indent": 0,
      "text": "4. The Core/echo Method",
      "section_title": true,
      "ja": "4. コア/エコー方式"
    },
    {
      "indent": 3,
      "text": "The \"Core/echo\" method returns exactly the same arguments as it is given. It is useful for testing if you have a valid authenticated connection to a JMAP API endpoint.",
      "ja": "「Core / echo」メソッドは、指定されたものとまったく同じ引数を返します。 JMAP APIエンドポイントへの有効な認証済み接続があるかどうかをテストするのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.1. Example",
      "section_title": true,
      "ja": "4.1. 例"
    },
    {
      "indent": 3,
      "text": "Request:",
      "ja": "要求："
    },
    {
      "indent": 29,
      "text": "[[ \"Core/echo\", {\n  \"hello\": true,\n  \"high\": 5\n}, \"b3ff\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Response:",
      "ja": "応答："
    },
    {
      "indent": 29,
      "text": "[[ \"Core/echo\", {\n  \"hello\": true,\n  \"high\": 5\n}, \"b3ff\" ]]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Standard Methods and Naming Convention",
      "section_title": true,
      "ja": "5. 標準メソッドと命名規則"
    },
    {
      "indent": 3,
      "text": "JMAP provides a uniform interface for creating, retrieving, updating, and deleting objects of a particular type. For a \"Foo\" data type, records of that type would be fetched via a \"Foo/get\" call and modified via a \"Foo/set\" call. Delta updates may be fetched via a \"Foo/changes\" call. These methods all follow a standard format as described below.",
      "ja": "JMAPは、特定のタイプのオブジェクトを作成、取得、更新、削除するための統一されたインターフェースを提供します。 「Foo」データタイプの場合、そのタイプのレコードは「Foo / get」コールを介してフェッチされ、「Foo / set」コールを介して変更されます。 デルタの更新は、「Foo / changes」呼び出しを介して取得できます。 これらのメソッドはすべて、以下で説明する標準形式に従います。"
    },
    {
      "indent": 3,
      "text": "Some types may not have all these methods. Specifications defining types MUST specify which methods are available for the type.",
      "ja": "一部のタイプには、これらのすべてのメソッドがない場合があります。 タイプを定義する仕様では、そのタイプで使用可能なメソッドを指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. /get",
      "section_title": true,
      "ja": "5.1. /取得する"
    },
    {
      "indent": 3,
      "text": "Objects of type Foo are fetched via a call to \"Foo/get\".",
      "ja": "タイプFooのオブジェクトは、「Foo / get」の呼び出しを介してフェッチされます。"
    },
    {
      "indent": 3,
      "text": "It takes the following arguments:",
      "ja": "以下の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to use.",
      "ja": "使用するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o ids: \"Id[]|null\"",
      "ja": "o ids： \"Id [] | null\""
    },
    {
      "indent": 6,
      "text": "The ids of the Foo objects to return. If null, then *all* records of the data type are returned, if this is supported for that data type and the number of records does not exceed the \"maxObjectsInGet\" limit.",
      "ja": "返すFooオブジェクトのID。 nullの場合、データ型の* all *レコードが返されます。これがそのデータ型でサポートされ、レコード数が「maxObjectsInGet」の制限を超えていない場合です。"
    },
    {
      "indent": 3,
      "text": "o properties: \"String[]|null\"",
      "ja": "o プロパティ： \"String [] | null\""
    },
    {
      "indent": 6,
      "text": "If supplied, only the properties listed in the array are returned for each Foo object. If null, all properties of the object are returned. The id property of the object is *always* returned, even if not explicitly requested. If an invalid property is requested, the call MUST be rejected with an \"invalidArguments\" error.",
      "ja": "指定した場合、配列にリストされているプロパティのみが各Fooオブジェクトに対して返されます。 nullの場合、オブジェクトのすべてのプロパティが返されます。 オブジェクトのidプロパティは、明示的に要求されていなくても、常に返されます。 無効なプロパティが要求された場合、呼び出しは「invalidArguments」エラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o state: \"String\"",
      "ja": "o 状態：「文字列」"
    },
    {
      "indent": 6,
      "text": "A (preferably short) string representing the state on the server for *all* the data of this type in the account (not just the objects returned in this call). If the data changes, this string MUST change. If the Foo data is unchanged, servers SHOULD return the same state string on subsequent requests for this data type. When a client receives a response with a different state string to a previous call, it MUST either throw away all currently cached objects for the type or call \"Foo/changes\" to get the exact changes.",
      "ja": "アカウントのこのタイプのデータ（この呼び出しで返されるオブジェクトだけでなく）のサーバーの状態を表す（できれば短い）文字列。 データが変更される場合、この文字列は変更する必要があります。 Fooデータが変更されていない場合、サーバーは、このデータ型に対する後続のリクエストで同じ状態文字列を返す必要があります。 クライアントは、以前の呼び出しとは異なる状態文字列を含む応答を受信すると、そのタイプの現在キャッシュされているオブジェクトをすべて破棄するか、「Foo / changes」を呼び出して正確な変更を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "o list: \"Foo[]\"",
      "ja": "o リスト：「Foo []」"
    },
    {
      "indent": 6,
      "text": "An array of the Foo objects requested. This is the *empty array* if no objects were found or if the \"ids\" argument passed in was also an empty array. The results MAY be in a different order to the \"ids\" in the request arguments. If an identical id is included more than once in the request, the server MUST only include it once in either the \"list\" or the \"notFound\" argument of the response.",
      "ja": "要求されたFooオブジェクトの配列。 オブジェクトが見つからなかった場合、または渡された \"ids\"引数も空の配列であった場合、これは*空の配列*です。 結果は、リクエスト引数の「id」とは異なる順序になる場合があります。 同一のidがリクエストに複数回含まれている場合、サーバーはレスポンスの「リスト」または「notFound」引数のいずれかに1回だけ含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o notFound: \"Id[]\"",
      "ja": "o notFound： \"Id []\""
    },
    {
      "indent": 6,
      "text": "This array contains the ids passed to the method for records that do not exist. The array is empty if all requested ids were found or if the \"ids\" argument passed in was either null or an empty array.",
      "ja": "この配列には、存在しないレコードのメソッドに渡されたIDが含まれます。 要求されたすべてのIDが見つかった場合、または渡された「ids」引数がnullまたは空の配列の場合、配列は空です。"
    },
    {
      "indent": 3,
      "text": "The following additional error may be returned instead of the \"Foo/ get\" response:",
      "ja": "「Foo / get」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"requestTooLarge\": The number of ids requested by the client exceeds the maximum number the server is willing to process in a single method call.",
      "ja": "「requestTooLarge」：クライアントによって要求されたIDの数が、サーバーが1回のメソッド呼び出しで処理できる最大数を超えています。"
    },
    {
      "indent": 0,
      "text": "5.2. /changes",
      "section_title": true,
      "ja": "5.2. / changes"
    },
    {
      "indent": 3,
      "text": "When the state of the set of Foo records in an account changes on the server (whether due to creation, updates, or deletion), the \"state\" property of the \"Foo/get\" response will change. The \"Foo/changes\" method allows a client to efficiently update the state of its Foo cache to match the new state on the server. It takes the following arguments:",
      "ja": "アカウントのFooレコードのセットの状態がサーバー上で変更されると（作成、更新、または削除のため）、「Foo / get」応答の「state」プロパティが変更されます。 「Foo / changes」メソッドを使用すると、クライアントはFooキャッシュの状態を効率的に更新して、サーバー上の新しい状態に一致させることができます。 以下の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to use.",
      "ja": "使用するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o sinceState: \"String\"",
      "ja": "o sinceState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The current state of the client. This is the string that was returned as the \"state\" argument in the \"Foo/get\" response. The server will return the changes that have occurred since this state.",
      "ja": "クライアントの現在の状態。 これは、「Foo / get」応答の「state」引数として返された文字列です。 サーバーは、この状態以降に発生した変更を返します。"
    },
    {
      "indent": 3,
      "text": "o maxChanges: \"UnsignedInt|null\"",
      "ja": "o maxChanges： \"UnsignedInt | null\""
    },
    {
      "indent": 6,
      "text": "The maximum number of ids to return in the response. The server MAY choose to return fewer than this value but MUST NOT return more. If not given by the client, the server may choose how many to return. If supplied by the client, the value MUST be a positive integer greater than 0. If a value outside of this range is given, the server MUST reject the call with an \"invalidArguments\" error.",
      "ja": "応答で返すIDの最大数。 サーバーはこの値よりも少ない値を返すことを選択してもよいが、それ以上を返してはならない。 クライアントから指定されていない場合、サーバーは返す数を選択できます。 クライアントから提供される場合、値は0より大きい正の整数でなければなりません。この範囲外の値が指定された場合、サーバーは「invalidArguments」エラーで呼び出しを拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o oldState: \"String\"",
      "ja": "o oldState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This is the \"sinceState\" argument echoed back; it's the state from which the server is returning changes.",
      "ja": "これは、エコーバックされる「sinceState」引数です。 サーバーが変更を返す元の状態です。"
    },
    {
      "indent": 3,
      "text": "o newState: \"String\"",
      "ja": "o newState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This is the state the client will be in after applying the set of changes to the old state.",
      "ja": "これは、古い状態に一連の変更を適用した後のクライアントの状態です。"
    },
    {
      "indent": 3,
      "text": "o hasMoreChanges: \"Boolean\"",
      "ja": "o hasMoreChanges： \"ブール値\""
    },
    {
      "indent": 6,
      "text": "If true, the client may call \"Foo/changes\" again with the \"newState\" returned to get further updates. If false, \"newState\" is the current server state.",
      "ja": "trueの場合、クライアントは、「newState」を返して「Foo / changes」を再度呼び出して、さらなる更新を取得できます。 falseの場合、「newState」は現在のサーバーの状態です。"
    },
    {
      "indent": 3,
      "text": "o created: \"Id[]\"",
      "ja": "o 作成済み：「Id []」"
    },
    {
      "indent": 6,
      "text": "An array of ids for records that have been created since the old state.",
      "ja": "古い状態以降に作成されたレコードのIDの配列。"
    },
    {
      "indent": 3,
      "text": "o updated: \"Id[]\"",
      "ja": "o 更新：「Id []」"
    },
    {
      "indent": 6,
      "text": "An array of ids for records that have been updated since the old state.",
      "ja": "古い状態以降に更新されたレコードのIDの配列。"
    },
    {
      "indent": 3,
      "text": "o destroyed: \"Id[]\"",
      "ja": "o 破壊されました： \"Id []\""
    },
    {
      "indent": 6,
      "text": "An array of ids for records that have been destroyed since the old state.",
      "ja": "古い状態以降に破棄されたレコードのIDの配列。"
    },
    {
      "indent": 3,
      "text": "If a record has been created AND updated since the old state, the server SHOULD just return the id in the \"created\" list but MAY return it in the \"updated\" list as well.",
      "ja": "レコードが作成され、古い状態以降に更新された場合、サーバーは「作成済み」リストにIDを返すだけである必要がありますが、「更新済み」リストにもIDを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "If a record has been updated AND destroyed since the old state, the server SHOULD just return the id in the \"destroyed\" list but MAY return it in the \"updated\" list as well.",
      "ja": "レコードが更新され、古い状態以降に破棄された場合、サーバーは単に「破棄された」リストにIDを返すだけである必要がありますが、「更新された」リストにもIDを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "If a record has been created AND destroyed since the old state, the server SHOULD remove the id from the response entirely. However, it MAY include it in just the \"destroyed\" list or in both the \"destroyed\" and \"created\" lists.",
      "ja": "レコードが作成され、古い状態以降に破棄された場合、サーバーは応答からIDを完全に削除する必要があります。 ただし、「破棄」リストのみ、または「破棄」リストと「作成」リストの両方に含めることができます。"
    },
    {
      "indent": 3,
      "text": "If a \"maxChanges\" is supplied, or set automatically by the server, the server MUST ensure the number of ids returned across \"created\", \"updated\", and \"destroyed\" does not exceed this limit. If there are more changes than this between the client's state and the current server state, the server SHOULD generate an update to take the client to an intermediate state, from which the client can continue to call \"Foo/changes\" until it is fully up to date. If it is unable to calculate an intermediate state, it MUST return a \"cannotCalculateChanges\" error response instead.",
      "ja": "「maxChanges」が提供されるか、サーバーによって自動的に設定される場合、サーバーは「created」、「updated」、および「destroyed」で返されるIDの数がこの制限を超えないようにしなければなりません。 クライアントの状態と現在のサーバーの状態の間にこれよりも多くの変更がある場合、サーバーはクライアントを中間状態にするための更新を生成する必要があります。中間状態から、クライアントは完全に起動するまで「Foo / changes」を呼び出し続けます 現在まで。 中間状態を計算できない場合、代わりに「cannotCalculateChanges」エラー応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "When generating intermediate states, the server may choose how to divide up the changes. For many types, it will provide a better user experience to return the more recent changes first, as this is more likely to be what the user is most interested in. The client can then continue to page in the older changes while the user is viewing the newer data. For example, suppose a server went through the following states:",
      "ja": "中間状態を生成するとき、サーバーは変更を分割する方法を選択できます。 多くのタイプでは、ユーザーが最も関心を持っているものである可能性が高いため、最新の変更を最初に返す方がユーザーエクスペリエンスが向上します。クライアントは、ユーザーが表示している間、古い変更をページングし続けることができます 新しいデータ。 たとえば、サーバーが次の状態を経たとします。"
    },
    {
      "indent": 27,
      "text": "A -> B -> C -> D -> E",
      "raw": true
    },
    {
      "indent": 3,
      "text": "And a client asks for changes from state \"B\". The server might first get the ids of records created, updated, or destroyed between states D and E, returning them with:",
      "ja": "そして、クライアントは状態「B」からの変更を要求します。 サーバーは、状態DとEの間で作成、更新、または破棄されたレコードのIDを最初に取得し、次のようにそれらを返します。"
    },
    {
      "indent": 27,
      "text": "state: \"B-D-E\" hasMoreChanges: true",
      "ja": "状態：「B-D-E」hasMoreChanges：true"
    },
    {
      "indent": 3,
      "text": "The client will then ask for the change from state \"B-D-E\", and the server can return the changes between states C and D, returning:",
      "ja": "次に、クライアントは状態「B-D-E」からの変更を要求し、サーバーは状態CとDの間の変更を返すことができます。"
    },
    {
      "indent": 27,
      "text": "state: \"B-C-E\" hasMoreChanges: true",
      "ja": "状態：「B-C-E」hasMoreChanges：true"
    },
    {
      "indent": 3,
      "text": "Finally, the client will request the changes from \"B-C-E\", and the server can return the changes between states B and C, returning:",
      "ja": "最後に、クライアントは「B-C-E」からの変更を要求し、サーバーは状態BとCの間の変更を返すことができます。"
    },
    {
      "indent": 27,
      "text": "state: \"E\" hasMoreChanges: false",
      "ja": "状態：「E」hasMoreChanges：false"
    },
    {
      "indent": 3,
      "text": "Should the state on the server be modified in the middle of all this (to \"F\"), the server still does the same, but now when the update to state \"E\" is returned, it would indicate that it still has more changes for the client to fetch.",
      "ja": "このすべての途中でサーバーの状態が（ \"F\"に）変更された場合、サーバーは同じことを行いますが、状態 \"E\"への更新が返されると、さらに変更があることを示します。 クライアントが取得します。"
    },
    {
      "indent": 3,
      "text": "Where multiple changes to a record are split across different intermediate states, the server MUST NOT return a record as created after a response that deems it as updated or destroyed, and it MUST NOT return a record as destroyed before a response that deems it as created or updated. The server may have to coalesce multiple changes to a record to satisfy this requirement.",
      "ja": "レコードへの複数の変更が異なる中間状態に分割される場合、サーバーは、更新または破棄されたとみなす応答の後に作成されたレコードを返してはならず、作成されたとみなされる応答の前に破棄されたレコードを返してはなりません または更新されました。 サーバーは、この要件を満たすためにレコードへの複数の変更を結合する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "The following additional errors may be returned instead of the \"Foo/ changes\" response:",
      "ja": "「Foo / changes」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"cannotCalculateChanges\": The server cannot calculate the changes from the state string given by the client. Usually, this is due to the client's state being too old or the server being unable to produce an update to an intermediate state when there are too many updates. The client MUST invalidate its Foo cache.",
      "ja": "\"cannotCalculateChanges\"：サーバーは、クライアントが指定した状態文字列から変更を計算できません。 通常、これは、クライアントの状態が古すぎるか、更新が多すぎるとサーバーが中間状態への更新を生成できないことが原因です。 クライアントはFooキャッシュを無効にしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Maintaining state to allow calculation of \"Foo/changes\" can be expensive for the server, but always returning \"cannotCalculateChanges\" severely increases network traffic and resource usage for the client. To allow efficient sync, servers SHOULD be able to calculate changes from any state string that was given to a client within the last 30 days (but of course may support calculating updates from states older than this).",
      "ja": "「Foo / changes」の計算を許可する状態を維持すると、サーバーにとってコストがかかりますが、常に「cannotCalculateChanges」を返すと、クライアントのネットワークトラフィックとリソース使用量が大幅に増加します。 効率的な同期を可能にするために、サーバーは、過去30日以内にクライアントに与えられた状態文字列からの変更を計算できる必要があります（もちろん、これより古い状態からの更新の計算をサポートする場合があります）。"
    },
    {
      "indent": 0,
      "text": "5.3. /set",
      "section_title": true,
      "ja": "5.3. /セットする"
    },
    {
      "indent": 3,
      "text": "Modifying the state of Foo objects on the server is done via the \"Foo/set\" method. This encompasses creating, updating, and destroying Foo records. This allows the server to sort out ordering and dependencies that may exist if doing multiple operations at once (for example, to ensure there is always a minimum number of a certain record type).",
      "ja": "サーバー上のFooオブジェクトの状態を変更するには、「Foo / set」メソッドを使用します。 これには、Fooレコードの作成、更新、および破棄が含まれます。 これにより、サーバーは、複数の操作を一度に実行する場合に存在する可能性のある順序と依存関係を整理できます（たとえば、特定のレコードタイプの最小数を常に確保するため）。"
    },
    {
      "indent": 3,
      "text": "The \"Foo/set\" method takes the following arguments:",
      "ja": "「Foo / set」メソッドは、次の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to use.",
      "ja": "使用するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o ifInState: \"String|null\"",
      "ja": "o ifInState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "This is a state string as returned by the \"Foo/get\" method (representing the state of all objects of this type in the account). If supplied, the string must match the current state; otherwise, the method will be aborted and a \"stateMismatch\" error returned. If null, any changes will be applied to the current state.",
      "ja": "これは、「Foo / get」メソッドによって返される状態文字列です（アカウント内のこのタイプのすべてのオブジェクトの状態を表します）。 指定する場合、文字列は現在の状態と一致する必要があります。 そうでない場合、メソッドは中止され、「stateMismatch」エラーが返されます。 nullの場合、変更は現在の状態に適用されます。"
    },
    {
      "indent": 3,
      "text": "o create: \"Id[Foo]|null\"",
      "ja": "o create： \"Id [Foo] | null\""
    },
    {
      "indent": 6,
      "text": "A map of a *creation id* (a temporary id set by the client) to Foo objects, or null if no objects are to be created.",
      "ja": "*作成ID *（クライアントによって設定された一時ID）のFooオブジェクトへのマップ、またはオブジェクトが作成されない場合はnull。"
    },
    {
      "indent": 6,
      "text": "The Foo object type definition may define default values for properties. Any such property may be omitted by the client.",
      "ja": "Fooオブジェクトタイプの定義では、プロパティのデフォルト値を定義できます。 このようなプロパティは、クライアントによって省略される場合があります。"
    },
    {
      "indent": 6,
      "text": "The client MUST omit any properties that may only be set by the server (for example, the \"id\" property on most object types).",
      "ja": "クライアントは、サーバーのみが設定できるプロパティ（たとえば、ほとんどのオブジェクトタイプの「id」プロパティ）を省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o update: \"Id[PatchObject]|null\"",
      "ja": "o 更新：「Id [PatchObject] | null」"
    },
    {
      "indent": 6,
      "text": "A map of an id to a Patch object to apply to the current Foo object with that id, or null if no objects are to be updated.",
      "ja": "IDをPatchオブジェクトにマップして、そのIDを持つ現在のFooオブジェクトに適用します。更新するオブジェクトがない場合はnullです。"
    },
    {
      "indent": 6,
      "text": "A *PatchObject* is of type \"String[*]\" and represents an unordered set of patches. The keys are a path in JSON Pointer format [RFC6901], with an implicit leading \"/\" (i.e., prefix each key with \"/\" before applying the JSON Pointer evaluation algorithm).",
      "ja": "* PatchObject *はタイプ \"String [*]\"であり、パッチの順序付けられていないセットを表します。 キーは、JSONポインター形式[RFC6901]のパスであり、暗黙の先頭に「/」が付いています（つまり、JSONポインター評価アルゴリズムを適用する前に各キーの前に「/」を付けます）。"
    },
    {
      "indent": 6,
      "text": "All paths MUST also conform to the following restrictions; if there is any violation, the update MUST be rejected with an \"invalidPatch\" error:",
      "ja": "すべてのパスは、次の制限にも準拠する必要があります。 違反がある場合、「invalidPatch」エラーで更新を拒否する必要があります。"
    },
    {
      "indent": 6,
      "text": "* The pointer MUST NOT reference inside an array (i.e., you MUST NOT insert/delete from an array; the array MUST be replaced in its entirety instead).",
      "ja": "* ポインターは配列内を参照してはなりません（つまり、配列に挿入/削除してはなりません;代わりに配列全体を置き換えなければなりません）。"
    },
    {
      "indent": 6,
      "text": "* All parts prior to the last (i.e., the value after the final slash) MUST already exist on the object being patched.",
      "ja": "* 最後の前のすべての部分（つまり、最後のスラッシュの後の値）は、パッチされるオブジェクト上にすでに存在していなければなりません。"
    },
    {
      "indent": 6,
      "text": "* There MUST NOT be two patches in the PatchObject where the pointer of one is the prefix of the pointer of the other, e.g., \"alerts/1/offset\" and \"alerts\".",
      "ja": "* PatchObjectには、一方のポインターが他方のポインターのプレフィックスである2つのパッチ（たとえば、「アラート/ 1 /オフセット」と「アラート」）があってはなりません。"
    },
    {
      "indent": 6,
      "text": "The value associated with each pointer determines how to apply that patch:",
      "ja": "各ポインターに関連付けられた値によって、そのパッチの適用方法が決まります。"
    },
    {
      "indent": 6,
      "text": "* If null, set to the default value if specified for this property; otherwise, remove the property from the patched object. If the key is not present in the parent, this a no-op.",
      "ja": "* nullの場合、このプロパティに指定されている場合はデフォルト値に設定されます。 それ以外の場合は、パッチを適用したオブジェクトからプロパティを削除します。 キーが親に存在しない場合、これはノーオペレーションです。"
    },
    {
      "indent": 6,
      "text": "* Anything else: The value to set for this property (this may be a replacement or addition to the object being patched).",
      "ja": "* その他：このプロパティに設定する値（これは、パッチを適用するオブジェクトの置換または追加の場合があります）。"
    },
    {
      "indent": 6,
      "text": "Any server-set properties MAY be included in the patch if their value is identical to the current server value (before applying the patches to the object). Otherwise, the update MUST be rejected with an \"invalidProperties\" SetError.",
      "ja": "値が現在のサーバー値と同じ場合（オブジェクトにパッチを適用する前に）、サーバーセットのプロパティをパッチに含めることができます。 それ以外の場合、「invalidProperties」SetErrorで更新を拒否する必要があります。"
    },
    {
      "indent": 6,
      "text": "This patch definition is designed such that an entire Foo object is also a valid PatchObject. The client may choose to optimise network usage by just sending the diff or may send the whole object; the server processes it the same either way.",
      "ja": "このパッチ定義は、Fooオブジェクト全体が有効なPatchObjectでもあるように設計されています。 クライアントは、差分を送信するだけでネットワークの使用を最適化することも、オブジェクト全体を送信することもできます。 サーバーはどちらの方法でも同じように処理します。"
    },
    {
      "indent": 3,
      "text": "o destroy: \"Id[]|null\"",
      "ja": "o destroy： \"Id [] | null\""
    },
    {
      "indent": 6,
      "text": "A list of ids for Foo objects to permanently delete, or null if no objects are to be destroyed.",
      "ja": "永久に削除するFooオブジェクトのIDのリスト、またはオブジェクトを破棄しない場合はnull。"
    },
    {
      "indent": 3,
      "text": "Each creation, modification, or destruction of an object is considered an atomic unit. It is permissible for the server to commit changes to some objects but not others; however, it MUST NOT only commit part of an update to a single record (e.g., update a \"name\" property but not a \"count\" property, if both are supplied in the update object).",
      "ja": "オブジェクトの作成、変更、または破棄はそれぞれ、アトミックユニットと見なされます。 サーバーは、一部のオブジェクトに変更をコミットできますが、他のオブジェクトにはコミットできません。 ただし、更新の一部を単一のレコードにコミットするだけではいけません（たとえば、「count」プロパティではなく「name」プロパティを更新します（両方が更新オブジェクトで提供される場合）。"
    },
    {
      "indent": 3,
      "text": "The final state MUST be valid after the \"Foo/set\" is finished; however, the server may have to transition through invalid intermediate states (not exposed to the client) while processing the individual create/update/destroy requests. For example, suppose there is a \"name\" property that must be unique. A single method call could rename an object A => B and simultaneously rename another object B => A. If the final state is valid, this is allowed. Otherwise, each creation, modification, or destruction of an object should be processed sequentially and accepted/rejected based on the current server state.",
      "ja": "「Foo / set」が終了した後、最終状態は有効でなければなりません。 ただし、個々の作成/更新/破棄リクエストの処理中に、サーバーは無効な中間状態（クライアントに公開されていない）を移行する必要がある場合があります。 たとえば、一意である必要がある「名前」プロパティがあるとします。 単一のメソッド呼び出しで、オブジェクトA => Bの名前を変更し、同時に別のオブジェクトB => Aの名前を変更できます。最終状態が有効な場合、これは許可されます。 それ以外の場合、オブジェクトの作成、変更、または破棄はそれぞれ順番に処理され、現在のサーバーの状態に基づいて受け入れ/拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "If a create, update, or destroy is rejected, the appropriate error MUST be added to the notCreated/notUpdated/notDestroyed property of the response, and the server MUST continue to the next create/update/ destroy. It does not terminate the method.",
      "ja": "作成、更新、または破棄が拒否された場合、応答のnotCreated / notUpdated / notDestroyedプロパティに適切なエラーを追加する必要があり、サーバーは次の作成/更新/破棄を続行する必要があります。 メソッドは終了しません。"
    },
    {
      "indent": 3,
      "text": "If an id given cannot be found, the update or destroy MUST be rejected with a \"notFound\" set error.",
      "ja": "指定されたIDが見つからない場合、更新または破棄は「notFound」セットエラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MAY skip an update (rejecting it with a \"willDestroy\" SetError) if that object is destroyed in the same /set request.",
      "ja": "サーバーは、同じ/ set要求でそのオブジェクトが破棄された場合、更新をスキップすることができます（「willDestroy」SetErrorで拒否）。"
    },
    {
      "indent": 3,
      "text": "Some records may hold references to other records (foreign keys). That reference may be set (via create or update) in the same request as the referenced record is created. To do this, the client refers to the new record using its creation id prefixed with a \"#\". The order of the method calls in the request by the client MUST be such that the record being referenced is created in the same or an earlier call. Thus, the server never has to look ahead. Instead, while processing a request, the server MUST keep a simple map for the duration of the request of creation id to record id for each newly created record, so it can substitute in the correct value if necessary in later method calls. In the case of records with references to the same type, the server MUST order the creates and updates within a single method call so that creates happen before their creation ids are referenced by another create/update/destroy in the same call.",
      "ja": "一部のレコードには、他のレコード（外部キー）への参照が含まれる場合があります。 その参照は、参照されたレコードが作成されるのと同じ要求で（作成または更新を介して）設定されます。 これを行うために、クライアントは、「＃」が前に付いた作成IDを使用して新しいレコードを参照します。 クライアントによるリクエスト内のメソッド呼び出しの順序は、参照されているレコードが同じ呼び出しまたは以前の呼び出しで作成されるようなものでなければなりません。 したがって、サーバーが先を見る必要はありません。 代わりに、リクエストを処理している間、サーバーは、作成された各レコードのIDを記録するために、作成IDのリクエストの期間中に単純なマップを保持する必要があります。 同じ型への参照を持つレコードの場合、サーバーは、同じ呼び出しで別のcreate / update / destroyによって作成IDが参照される前に作成が行われるように、単一のメソッド呼び出し内で作成と更新を順序付けなければなりません。"
    },
    {
      "indent": 3,
      "text": "Creation ids are not scoped by type but are a single map for all types. A client SHOULD NOT reuse a creation id anywhere in the same API request. If a creation id is reused, the server MUST map the creation id to the most recently created item with that id. To allow easy proxying of API requests, an initial set of creation id to real id values may be passed with a request (see \"The Request Object\", Section 3.3) and the final state of the map passed out with the response (see \"The Response Object\", Section 3.4).",
      "ja": "作成IDのスコープはタイプごとではなく、すべてのタイプの単一のマップです。 クライアントは、同じAPIリクエストのどこでも作成IDを再利用するべきではありません。 作成IDが再利用される場合、サーバーは、作成IDをそのIDで最後に作成されたアイテムにマップする必要があります。 APIリクエストを簡単にプロキシできるように、作成IDから実際のID値への初期セットをリクエストで渡し（「リクエストオブジェクト」、セクション3.3を参照）、マップの最終状態をレスポンスで渡します（「 応答オブジェクト」、セクション3.4）。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o oldState: \"String|null\"",
      "ja": "o oldState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "The state string that would have been returned by \"Foo/get\" before making the requested changes, or null if the server doesn't know what the previous state string was.",
      "ja": "要求された変更を行う前に「Foo / get」によって返された状態文字列、またはサーバーが前の状態文字列が何であるかを知らない場合はnull。"
    },
    {
      "indent": 3,
      "text": "o newState: \"String\"",
      "ja": "o newState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The state string that will now be returned by \"Foo/get\".",
      "ja": "「Foo / get」によって返される状態文字列。"
    },
    {
      "indent": 3,
      "text": "o created: \"Id[Foo]|null\"",
      "ja": "o 作成：「Id [Foo] | null」"
    },
    {
      "indent": 6,
      "text": "A map of the creation id to an object containing any properties of the created Foo object that were not sent by the client. This includes all server-set properties (such as the \"id\" in most object types) and any properties that were omitted by the client and thus set to a default by the server.",
      "ja": "クライアントによって送信されなかった、作成されたFooオブジェクトのプロパティを含むオブジェクトへの作成IDのマップ。 これには、すべてのサーバー設定プロパティ（ほとんどのオブジェクトタイプの「id」など）と、クライアントによって省略されたためサーバーによってデフォルトに設定されたプロパティが含まれます。"
    },
    {
      "indent": 6,
      "text": "This argument is null if no Foo objects were successfully created.",
      "ja": "Fooオブジェクトが正常に作成されなかった場合、この引数はnullです。"
    },
    {
      "indent": 3,
      "text": "o updated: \"Id[Foo|null]|null\"",
      "ja": "o 更新：「Id [Foo | null] | null」"
    },
    {
      "indent": 6,
      "text": "The keys in this map are the ids of all Foos that were successfully updated.",
      "ja": "このマップのキーは、正常に更新されたすべてのFoodのIDです。"
    },
    {
      "indent": 6,
      "text": "The value for each id is a Foo object containing any property that changed in a way *not* explicitly requested by the PatchObject sent to the server, or null if none. This lets the client know of any changes to server-set or computed properties.",
      "ja": "各IDの値は、サーバーに送信されたPatchObjectによって明示的に要求されない方法で変更されたプロパティを含むFooオブジェクトです。ない場合はnullです。 これにより、クライアントはサーバーセットまたは計算されたプロパティの変更を認識できます。"
    },
    {
      "indent": 6,
      "text": "This argument is null if no Foo objects were successfully updated.",
      "ja": "Fooオブジェクトが正常に更新されなかった場合、この引数はnullです。"
    },
    {
      "indent": 3,
      "text": "o destroyed: \"Id[]|null\"",
      "ja": "o 破壊されました： \"Id [] | null\""
    },
    {
      "indent": 6,
      "text": "A list of Foo ids for records that were successfully destroyed, or null if none.",
      "ja": "正常に破棄されたレコードのFoo IDのリスト。ない場合はnull。"
    },
    {
      "indent": 3,
      "text": "o notCreated: \"Id[SetError]|null\"",
      "ja": "o notCreated： \"Id [SetError] | null\""
    },
    {
      "indent": 6,
      "text": "A map of the creation id to a SetError object for each record that failed to be created, or null if all successful.",
      "ja": "作成に失敗した各レコードのSetErrorオブジェクトへの作成IDのマップ。すべて成功した場合はnull。"
    },
    {
      "indent": 3,
      "text": "o notUpdated: \"Id[SetError]|null\"",
      "ja": "o notUpdated： \"Id [SetError] | null\""
    },
    {
      "indent": 6,
      "text": "A map of the Foo id to a SetError object for each record that failed to be updated, or null if all successful.",
      "ja": "更新に失敗した各レコードのFoo idのSetErrorオブジェクトへのマップ。すべて成功した場合はnull。"
    },
    {
      "indent": 3,
      "text": "o notDestroyed: \"Id[SetError]|null\"",
      "ja": "o notDestroyed： \"Id [SetError] | null\""
    },
    {
      "indent": 6,
      "text": "A map of the Foo id to a SetError object for each record that failed to be destroyed, or null if all successful.",
      "ja": "破棄に失敗した各レコードのSetErrorオブジェクトへのFoo idのマップ、またはすべて成功した場合はnull。"
    },
    {
      "indent": 3,
      "text": "A *SetError* object has the following properties:",
      "ja": "* SetError *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o type: \"String\"",
      "ja": "o タイプ：「ストリング」"
    },
    {
      "indent": 6,
      "text": "The type of error.",
      "ja": "エラーのタイプ。"
    },
    {
      "indent": 3,
      "text": "o description: \"String|null\"",
      "ja": "o 説明：「ストリング|ヌル」"
    },
    {
      "indent": 6,
      "text": "A description of the error to help with debugging that includes an explanation of what the problem was. This is a non-localised string and is not intended to be shown directly to end users.",
      "ja": "問題の説明を含む、デバッグに役立つエラーの説明。 これはローカライズされていない文字列であり、エンドユーザーに直接表示されることを意図していません。"
    },
    {
      "indent": 3,
      "text": "The following SetError types are defined and may be returned for set operations on any record type where appropriate:",
      "ja": "以下のSetErrorタイプが定義されており、必要に応じて任意のレコードタイプのセット操作に対して返される場合があります。"
    },
    {
      "indent": 3,
      "text": "o \"forbidden\": (create; update; destroy). The create/update/destroy would violate an ACL or other permissions policy.",
      "ja": "o 「禁止」：（作成、更新、破棄）。 create / update / destroyは、ACLまたはその他の許可ポリシーに違反します。"
    },
    {
      "indent": 3,
      "text": "o \"overQuota\": (create; update). The create would exceed a server-defined limit on the number or total size of objects of this type.",
      "ja": "o 「overQuota」：（作成、更新）。 作成は、このタイプのオブジェクトの数または合計サイズのサーバー定義制限を超えます。"
    },
    {
      "indent": 3,
      "text": "o \"tooLarge\": (create; update). The create/update would result in an object that exceeds a server-defined limit for the maximum size of a single object of this type.",
      "ja": "o 「tooLarge」：（作成、更新）。 作成/更新により、このタイプの単一オブジェクトの最大サイズのサーバー定義の制限を超えるオブジェクトが作成されます。"
    },
    {
      "indent": 3,
      "text": "o \"rateLimit\": (create). Too many objects of this type have been created recently, and a server-defined rate limit has been reached. It may work if tried again later.",
      "ja": "o 「rateLimit」：（作成）。 最近作成されたこのタイプのオブジェクトが多すぎて、サーバー定義のレート制限に達しました。 後で再試行すると機能する場合があります。"
    },
    {
      "indent": 3,
      "text": "o \"notFound\": (update; destroy). The id given to update/destroy cannot be found.",
      "ja": "o 「notFound」：（更新、破棄）。 update / destroyに指定されたIDが見つかりません。"
    },
    {
      "indent": 3,
      "text": "o \"invalidPatch\": (update). The PatchObject given to update the record was not a valid patch (see the patch description).",
      "ja": "o 「invalidPatch」：（更新）。 レコードを更新するために指定されたPatchObjectは有効なパッチではありませんでした（パッチの説明を参照）。"
    },
    {
      "indent": 3,
      "text": "o \"willDestroy\": (update). The client requested that an object be both updated and destroyed in the same /set request, and the server has decided to therefore ignore the update.",
      "ja": "o 「willDestroy」：（更新）。 クライアントは、同じ/ set要求でオブジェクトの更新と破棄の両方を要求したため、サーバーは更新を無視することを決定しました。"
    },
    {
      "indent": 3,
      "text": "o \"invalidProperties\": (create; update). The record given is invalid in some way. For example:",
      "ja": "o 「invalidProperties」：（作成;更新）。 指定されたレコードは何らかの方法で無効です。 例えば："
    },
    {
      "indent": 6,
      "text": "* It contains properties that are invalid according to the type specification of this record type.",
      "ja": "* このレコードタイプのタイプ指定に従って無効なプロパティが含まれています。"
    },
    {
      "indent": 6,
      "text": "* It contains a property that may only be set by the server (e.g., \"id\") and is different to the current value. Note, to allow clients to pass whole objects back, it is not an error to include a server-set property in an update as long as the value is identical to the current value on the server.",
      "ja": "* これには、サーバーによってのみ設定できるプロパティ（「id」など）が含まれ、現在の値とは異なります。 クライアントがオブジェクト全体を戻すことができるようにするために、値がサーバー上の現在の値と同一である限り、更新にサーバー設定プロパティを含めることはエラーではありません。"
    },
    {
      "indent": 6,
      "text": "* There is a reference to another record (foreign key), and the given id does not correspond to a valid record.",
      "ja": "* 別のレコード（外部キー）への参照があり、指定されたIDは有効なレコードに対応していません。"
    },
    {
      "indent": 6,
      "text": "The SetError object SHOULD also have a property called \"properties\" of type \"String[]\" that lists *all* the properties that were invalid.",
      "ja": "SetErrorオブジェクトには、無効なプロパティすべてをリストする「String []」タイプの「properties」というプロパティも含める必要があります。"
    },
    {
      "indent": 6,
      "text": "Individual methods MAY specify more specific errors for certain conditions that would otherwise result in an invalidProperties error. If the condition of one of these is met, it MUST be returned instead of the invalidProperties error.",
      "ja": "個々のメソッドは、それ以外の場合はinvalidPropertiesエラーになる特定の条件に対して、より具体的なエラーを指定する場合があります。 これらのいずれかの条件が満たされた場合、invalidPropertiesエラーの代わりに返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o \"singleton\": (create; destroy). This is a singleton type, so you cannot create another one or destroy the existing one.",
      "ja": "o 「シングルトン」：（作成、破棄）。 これはシングルトンタイプであるため、別のものを作成したり、既存のものを破壊したりすることはできません。"
    },
    {
      "indent": 3,
      "text": "Other possible SetError types MAY be given in specific method descriptions. Other properties MAY also be present on the SetError object, as described in the relevant methods.",
      "ja": "他の可能性のあるSetErrorタイプは、特定のメソッドの説明で提供される場合があります。 関連するメソッドで説明されているように、他のプロパティもSetErrorオブジェクトに存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "The following additional errors may be returned instead of the \"Foo/ set\" response:",
      "ja": "「Foo / set」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"requestTooLarge\": The total number of objects to create, update, or destroy exceeds the maximum number the server is willing to process in a single method call.",
      "ja": "「requestTooLarge」：作成、更新、または破棄するオブジェクトの総数が、サーバーが1回のメソッド呼び出しで処理できる最大数を超えています。"
    },
    {
      "indent": 3,
      "text": "\"stateMismatch\": An \"ifInState\" argument was supplied, and it does not match the current state.",
      "ja": "「stateMismatch」：「ifInState」引数が指定されましたが、現在の状態と一致しません。"
    },
    {
      "indent": 0,
      "text": "5.4. /copy",
      "section_title": true,
      "ja": "5.4. / copy"
    },
    {
      "indent": 3,
      "text": "The only way to move Foo records *between* two different accounts is to copy them using the \"Foo/copy\" method; once the copy has succeeded, delete the original. The \"onSuccessDestroyOriginal\" argument allows you to try to do this in one method call; however, note that the two different actions are not atomic, so it is possible for the copy to succeed but the original not to be destroyed for some reason.",
      "ja": "2つの異なるアカウント間でFooレコードを移動する唯一の方法は、「Foo / copy」メソッドを使用してそれらをコピーすることです。 コピーが成功したら、オリジナルを削除します。 「onSuccessDestroyOriginal」引数を使用すると、1回のメソッド呼び出しでこれを実行できます。 ただし、2つの異なるアクションはアトミックではないため、コピーは成功する可能性がありますが、元のアクションは何らかの理由で破棄されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "The copy is conceptually in three phases:",
      "ja": "コピーは概念的に3つのフェーズにあります。"
    },
    {
      "indent": 3,
      "text": "1. Reading the current values from the \"from\" account.",
      "ja": "1. 「from」アカウントから現在の値を読み取ります。"
    },
    {
      "indent": 3,
      "text": "2. Writing the new copies to the other account.",
      "ja": "2. 新しいコピーを他のアカウントに書き込みます。"
    },
    {
      "indent": 3,
      "text": "3. Destroying the originals in the \"from\" account, if requested.",
      "ja": "3. 要求された場合、「差出人」アカウントのオリジナルを破棄します。"
    },
    {
      "indent": 3,
      "text": "Data may change in between phases due to concurrent requests.",
      "ja": "同時要求により、フェーズ間でデータが変更される場合があります。"
    },
    {
      "indent": 3,
      "text": "The \"Foo/copy\" method takes the following arguments:",
      "ja": "「Foo / copy」メソッドは、次の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o fromAccountId: \"Id\"",
      "ja": "o fromAccountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to copy records from.",
      "ja": "レコードのコピー元のアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o ifFromInState: \"String|null\"",
      "ja": "o ifFromInState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "This is a state string as returned by the \"Foo/get\" method. If supplied, the string must match the current state of the account referenced by the fromAccountId when reading the data to be copied; otherwise, the method will be aborted and a \"stateMismatch\" error returned. If null, the data will be read from the current state.",
      "ja": "これは、「Foo / get」メソッドによって返される状態文字列です。 指定する場合、文字列は、コピーするデータを読み取るときにfromAccountIdによって参照されるアカウントの現在の状態と一致する必要があります。 そうでない場合、メソッドは中止され、「stateMismatch」エラーが返されます。 nullの場合、データは現在の状態から読み取られます。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to copy records to. This MUST be different to the \"fromAccountId\".",
      "ja": "レコードをコピーするアカウントのID。 これは「fromAccountId」と異なる必要があります。"
    },
    {
      "indent": 3,
      "text": "o ifInState: \"String|null\"",
      "ja": "o ifInState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "This is a state string as returned by the \"Foo/get\" method. If supplied, the string must match the current state of the account referenced by the accountId; otherwise, the method will be aborted and a \"stateMismatch\" error returned. If null, any changes will be applied to the current state.",
      "ja": "これは、「Foo / get」メソッドによって返される状態文字列です。 指定する場合、文字列はaccountIdによって参照されるアカウントの現在の状態と一致する必要があります。 そうでない場合、メソッドは中止され、「stateMismatch」エラーが返されます。 nullの場合、変更は現在の状態に適用されます。"
    },
    {
      "indent": 3,
      "text": "o create: \"Id[Foo]\"",
      "ja": "o create：「Id [Foo]」"
    },
    {
      "indent": 6,
      "text": "A map of the *creation id* to a Foo object. The Foo object MUST contain an \"id\" property, which is the id (in the fromAccount) of the record to be copied. When creating the copy, any other properties included are used instead of the current value for that property on the original.",
      "ja": "*作成ID *のFooオブジェクトへのマップ。 Fooオブジェクトには、コピーするレコードの（fromAccount内の）idである「id」プロパティを含める必要があります。 コピーを作成するときに、元のプロパティの現在の値の代わりに、含まれている他のプロパティが使用されます。"
    },
    {
      "indent": 3,
      "text": "o onSuccessDestroyOriginal: \"Boolean\" (default: false)",
      "ja": "o onSuccessDestroyOriginal： \"ブール値\"（デフォルト：false）"
    },
    {
      "indent": 6,
      "text": "If true, an attempt will be made to destroy the original records that were successfully copied: after emitting the \"Foo/copy\" response, but before processing the next method, the server MUST make a single call to \"Foo/set\" to destroy the original of each successfully copied record; the output of this is added to the responses as normal, to be returned to the client.",
      "ja": "trueの場合、正常にコピーされた元のレコードを破棄しようとします。「Foo / copy」応答を送信した後、次のメソッドを処理する前に、サーバーは「Foo / set」を1回呼び出して破棄する必要があります 正常にコピーされた各レコードのオリジナル。 この出力は通常どおり応答に追加され、クライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "o destroyFromIfInState: \"String|null\"",
      "ja": "o destroyFromIfInState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "This argument is passed on as the \"ifInState\" argument to the implicit \"Foo/set\" call, if made at the end of this request to destroy the originals that were successfully copied.",
      "ja": "この引数は、正常にコピーされたオリジナルを破棄するためにこのリクエストの最後に行われた場合、暗黙的な「Foo / set」呼び出しに「ifInState」引数として渡されます。"
    },
    {
      "indent": 3,
      "text": "Each record copy is considered an atomic unit that may succeed or fail individually.",
      "ja": "各レコードコピーは、個別に成功または失敗する可能性があるアトミックユニットと見なされます。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o fromAccountId: \"Id\"",
      "ja": "o fromAccountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account records were copied from.",
      "ja": "アカウントレコードのIDのコピー元。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account records were copied to.",
      "ja": "アカウントレコードのIDがコピーされました。"
    },
    {
      "indent": 3,
      "text": "o oldState: \"String|null\"",
      "ja": "o oldState： \"String | null\""
    },
    {
      "indent": 6,
      "text": "The state string that would have been returned by \"Foo/get\" on the account records that were copied to before making the requested changes, or null if the server doesn't know what the previous state string was.",
      "ja": "要求された変更を行う前にコピーされたアカウントレコードの「Foo / get」によって返された状態文字列、またはサーバーが前の状態文字列が何であるかを知らない場合はnull。"
    },
    {
      "indent": 3,
      "text": "o newState: \"String\"",
      "ja": "o newState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The state string that will now be returned by \"Foo/get\" on the account records were copied to.",
      "ja": "アカウントレコードの「Foo / get」によって返される状態文字列がコピーされました。"
    },
    {
      "indent": 3,
      "text": "o created: \"Id[Foo]|null\"",
      "ja": "o 作成：「Id [Foo] | null」"
    },
    {
      "indent": 6,
      "text": "A map of the creation id to an object containing any properties of the copied Foo object that are set by the server (such as the \"id\" in most object types; note, the id is likely to be different to the id of the object in the account it was copied from).",
      "ja": "サーバーによって設定される、コピーされたFooオブジェクトのプロパティを含むオブジェクトへの作成IDのマップ（ほとんどのオブジェクトタイプの「id」など。注意、idはオブジェクトのidとは異なる可能性が高い コピー元のアカウントで）。"
    },
    {
      "indent": 6,
      "text": "This argument is null if no Foo objects were successfully copied.",
      "ja": "Fooオブジェクトが正常にコピーされなかった場合、この引数はnullです。"
    },
    {
      "indent": 3,
      "text": "o notCreated: \"Id[SetError]|null\"",
      "ja": "o notCreated： \"Id [SetError] | null\""
    },
    {
      "indent": 6,
      "text": "A map of the creation id to a SetError object for each record that failed to be copied, or null if none.",
      "ja": "コピーに失敗した各レコードのSetErrorオブジェクトへの作成IDのマップ。ない場合はnull。"
    },
    {
      "indent": 3,
      "text": "The SetError may be any of the standard set errors returned for a create or update. In addition, the following SetError is defined:",
      "ja": "SetErrorは、作成または更新のために返される標準セットエラーのいずれかです。 さらに、次のSetErrorが定義されています。"
    },
    {
      "indent": 3,
      "text": "\"alreadyExists\": The server forbids duplicates, and the record already exists in the target account. An \"existingId\" property of type \"Id\" MUST be included on the SetError object with the id of the existing record.",
      "ja": "\"alreadyExists\"：サーバーは重複を禁止し、レコードはターゲットアカウントに既に存在します。 タイプ「Id」の「existingId」プロパティは、既存のレコードのIDを使用してSetErrorオブジェクトに含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The following additional errors may be returned instead of the \"Foo/ copy\" response:",
      "ja": "「Foo / copy」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"fromAccountNotFound\": The \"fromAccountId\" does not correspond to a valid account.",
      "ja": "「fromAccountNotFound」：「fromAccountId」は有効なアカウントに対応していません。"
    },
    {
      "indent": 3,
      "text": "\"fromAccountNotSupportedByMethod\": The \"fromAccountId\" given corresponds to a valid account, but the account does not support this data type.",
      "ja": "「fromAccountNotSupportedByMethod」：指定された「fromAccountId」は有効なアカウントに対応していますが、アカウントはこのデータ型をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "\"stateMismatch\": An \"ifInState\" argument was supplied and it does not match the current state, or an \"ifFromInState\" argument was supplied and it does not match the current state in the from account.",
      "ja": "「stateMismatch」：「ifInState」引数が指定され、現在の状態と一致しないか、「ifFromInState」引数が指定され、fromアカウントの現在の状態と一致しません。"
    },
    {
      "indent": 0,
      "text": "5.5. /query",
      "section_title": true,
      "ja": "5.5. / query"
    },
    {
      "indent": 3,
      "text": "For data sets where the total amount of data is expected to be very small, clients can just fetch the complete set of data and then do any sorting/filtering locally. However, for large data sets (e.g., multi-gigabyte mailboxes), the client needs to be able to search/sort/window the data type on the server.",
      "ja": "データの総量が非常に少ないと予想されるデータセットの場合、クライアントはデータの完全なセットを取得し、ローカルで並べ替え/フィルタリングを行うことができます。 ただし、大きなデータセット（マルチギガバイトのメールボックスなど）の場合、クライアントはサーバー上のデータタイプを検索/ソート/ウィンドウ化できる必要があります。"
    },
    {
      "indent": 3,
      "text": "A query on the set of Foos in an account is made by calling \"Foo/ query\". This takes a number of arguments to determine which records to include, how they should be sorted, and which part of the result should be returned (the full list may be *very* long). The result is returned as a list of Foo ids.",
      "ja": "アカウント内の一連のFoosに対するクエリは、「Foo / query」を呼び出すことで作成されます。 これはいくつかの引数を取り、どのレコードを含めるか、どのようにソートするか、結果のどの部分を返すかを決定します（完全なリストは*非常に*長い場合があります）。 結果はFoo IDのリストとして返されます。"
    },
    {
      "indent": 3,
      "text": "A call to \"Foo/query\" takes the following arguments:",
      "ja": "「Foo / query」の呼び出しは、次の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to use.",
      "ja": "使用するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o filter: \"FilterOperator|FilterCondition|null\"",
      "ja": "o フィルター：「FilterOperator | FilterCondition | null」"
    },
    {
      "indent": 6,
      "text": "Determines the set of Foos returned in the results. If null, all objects in the account of this type are included in the results. A *FilterOperator* object has the following properties:",
      "ja": "結果で返されるFoodのセットを決定します。 nullの場合、このタイプのアカウント内のすべてのオブジェクトが結果に含まれます。 * FilterOperator *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "* operator: \"String\"",
      "ja": "* 演算子：「文字列」"
    },
    {
      "indent": 9,
      "text": "This MUST be one of the following strings:",
      "ja": "これは、次の文字列のいずれかである必要があります。"
    },
    {
      "indent": 9,
      "text": "+ \"AND\": All of the conditions must match for the filter to match.",
      "ja": "+ 「AND」：フィルタが一致するためには、すべての条件が一致する必要があります。"
    },
    {
      "indent": 9,
      "text": "+ \"OR\": At least one of the conditions must match for the filter to match.",
      "ja": "+ 「OR」：フィルターが一致するには、少なくとも1つの条件が一致する必要があります。"
    },
    {
      "indent": 9,
      "text": "+ \"NOT\": None of the conditions must match for the filter to match.",
      "ja": "+ 「NOT」：フィルターが一致するためには、どの条件も一致する必要はありません。"
    },
    {
      "indent": 6,
      "text": "* conditions: \"(FilterOperator|FilterCondition)[]\"",
      "ja": "* 条件：「（FilterOperator | FilterCondition）[]」"
    },
    {
      "indent": 9,
      "text": "The conditions to evaluate against each record.",
      "ja": "各レコードに対して評価する条件。"
    },
    {
      "indent": 6,
      "text": "A *FilterCondition* is an \"object\" whose allowed properties and semantics depend on the data type and is defined in the /query method specification for that type. It MUST NOT have an \"operator\" property.",
      "ja": "* FilterCondition *は、許可されるプロパティとセマンティクスがデータ型に依存する「オブジェクト」であり、その型の/ queryメソッド仕様で定義されます。 「演算子」プロパティを持つことはできません。"
    },
    {
      "indent": 3,
      "text": "o sort: \"Comparator[]|null\"",
      "ja": "o ソート： \"Comparator [] | null\""
    },
    {
      "indent": 6,
      "text": "Lists the names of properties to compare between two Foo records, and how to compare them, to determine which comes first in the sort. If two Foo records have an identical value for the first comparator, the next comparator will be considered, and so on. If all comparators are the same (this includes the case where an empty array or null is given as the \"sort\" argument), the sort order is server dependent, but it MUST be stable between calls to \"Foo/query\". A *Comparator* has the following properties:",
      "ja": "2つのFooレコード間で比較するプロパティの名前と、それらの比較方法を一覧表示して、どちらが最初に来るかを判断します。 2つのFooレコードの最初のコンパレーターの値が同じ場合、次のコンパレーターが考慮されます。 すべてのコンパレーターが同じ場合（空の配列またはnullが \"sort\"引数として指定される場合を含む）、ソート順はサーバーに依存しますが、 \"Foo / query\"の呼び出し間で安定している必要があります。 * Comparator *には次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "* property: \"String\"",
      "ja": "* プロパティ：「文字列」"
    },
    {
      "indent": 9,
      "text": "The name of the property on the Foo objects to compare.",
      "ja": "比較するFooオブジェクトのプロパティの名前。"
    },
    {
      "indent": 6,
      "text": "* isAscending: \"Boolean\" (optional; default: true)",
      "ja": "* isAscending： \"ブール値\"（オプション;デフォルト：true）"
    },
    {
      "indent": 9,
      "text": "If true, sort in ascending order. If false, reverse the comparator's results to sort in descending order.",
      "ja": "trueの場合、昇順でソートします。 falseの場合、コンパレータの結果を逆にして降順に並べ替えます。"
    },
    {
      "indent": 6,
      "text": "* collation: \"String\" (optional; default is server-dependent)",
      "ja": "* collation： \"String\"（オプション。デフォルトはサーバー依存）"
    },
    {
      "indent": 9,
      "text": "The identifier, as registered in the collation registry defined in [RFC4790], for the algorithm to use when comparing the order of strings. The algorithms the server supports are advertised in the capabilities object returned with the Session object (see Section 2).",
      "ja": "[RFC4790]で定義されている照合レジストリに登録されている、文字列の順序を比較するときに使用するアルゴリズムの識別子。 サーバーがサポートするアルゴリズムは、Sessionオブジェクトで返される機能オブジェクトで通知されます（セクション2を参照）。"
    },
    {
      "indent": 9,
      "text": "If omitted, the default algorithm is server dependent, but:",
      "ja": "省略した場合、デフォルトのアルゴリズムはサーバーに依存しますが、次のとおりです。"
    },
    {
      "indent": 9,
      "text": "1. It MUST be unicode-aware.",
      "ja": "1. Unicodeに対応している必要があります。"
    },
    {
      "indent": 9,
      "text": "2. It MAY be selected based on an Accept-Language header in the request (as defined in [RFC7231], Section 5.3.5) or out-of-band information about the user's language/locale.",
      "ja": "2. 要求のAccept-Languageヘッダー（[RFC7231]、セクション5.3.5で定義）またはユーザーの言語/ロケールに関する帯域外情報に基づいて選択できます（MAY）。"
    },
    {
      "indent": 9,
      "text": "3. It SHOULD be case insensitive where such a concept makes sense for a language/locale. Where the user's language is unknown, it is RECOMMENDED to follow the advice in Section 5.2.3 of [RFC8264].",
      "ja": "3. そのような概念が言語/ロケールにとって意味がある場合、大文字と小文字を区別しない必要があります。 ユーザーの言語が不明な場合、[RFC8264]のセクション5.2.3のアドバイスに従うことをお勧めします。"
    },
    {
      "indent": 9,
      "text": "The \"i;unicode-casemap\" collation [RFC5051] and the Unicode Collation Algorithm (<http://www.unicode.org/reports/tr10/>) are two examples that fulfil these criterion and provide reasonable behaviour for a large number of languages.",
      "ja": "「i; unicode-casemap」照合[RFC5051]およびUnicode Collation Algorithm（<http://www.unicode.org/reports/tr10/>）は、これらの基準を満たす2つの例であり、多数に対して妥当な動作を提供します。 言語の。"
    },
    {
      "indent": 9,
      "text": "When the property being compared is not a string, the \"collation\" property is ignored, and the following comparison rules apply based on the type. In ascending order:",
      "ja": "比較されるプロパティが文字列ではない場合、「照合」プロパティは無視され、タイプに基づいて次の比較ルールが適用されます。 昇順："
    },
    {
      "indent": 9,
      "text": "+ \"Boolean\": false comes before true.",
      "ja": "+ 「ブール」：trueの前にfalseが来る。"
    },
    {
      "indent": 9,
      "text": "+ \"Number\": A lower number comes before a higher number.",
      "ja": "+ 「数字」：小さい数字が大きい数字の前に来ます。"
    },
    {
      "indent": 9,
      "text": "+ \"Date\"/\"UTCDate\": The earlier date comes first.",
      "ja": "+ 「日付」/「UTCDate」：早い日付が最初に来ます。"
    },
    {
      "indent": 6,
      "text": "The Comparator object may also have additional properties as required for specific sort operations defined in a type's /query method.",
      "ja": "Comparatorオブジェクトには、型の/ queryメソッドで定義された特定の並べ替え操作に必要な追加のプロパティもあります。"
    },
    {
      "indent": 3,
      "text": "o position: \"Int\" (default: 0)",
      "ja": "o 位置： \"Int\"（デフォルト：0）"
    },
    {
      "indent": 6,
      "text": "The zero-based index of the first id in the full list of results to return.",
      "ja": "返される結果の完全なリストの最初のIDのゼロから始まるインデックス。"
    },
    {
      "indent": 6,
      "text": "If a negative value is given, it is an offset from the end of the list. Specifically, the negative value MUST be added to the total number of results given the filter, and if still negative, it's clamped to \"0\". This is now the zero-based index of the first id to return.",
      "ja": "負の値が指定されている場合、それはリストの末尾からのオフセットです。 具体的には、フィルターに与えられた結果の総数に負の値を追加する必要があり、それでも負の場合は「0」に固定されます。 これは、返される最初のIDのゼロベースのインデックスになりました。"
    },
    {
      "indent": 6,
      "text": "If the index is greater than or equal to the total number of objects in the results list, then the \"ids\" array in the response will be empty, but this is not an error.",
      "ja": "インデックスが結果リストのオブジェクトの総数以上である場合、応答の「ids」配列は空になりますが、これはエラーではありません。"
    },
    {
      "indent": 3,
      "text": "o anchor: \"Id|null\"",
      "ja": "o アンカー：「Id | null」"
    },
    {
      "indent": 6,
      "text": "A Foo id. If supplied, the \"position\" argument is ignored. The index of this id in the results will be used in combination with the \"anchorOffset\" argument to determine the index of the first result to return (see below for more details).",
      "ja": "Foo id。 指定した場合、「position」引数は無視されます。 結果のこのidのインデックスは、 \"anchorOffset\"引数と組み合わせて使用して、最初に返される結果のインデックスを決定します（詳細については以下を参照）。"
    },
    {
      "indent": 3,
      "text": "o anchorOffset: \"Int\" (default: 0)",
      "ja": "o anchorOffset： \"Int\"（デフォルト：0）"
    },
    {
      "indent": 6,
      "text": "The index of the first result to return relative to the index of the anchor, if an anchor is given. This MAY be negative. For example, \"-1\" means the Foo immediately preceding the anchor is the first result in the list returned (see below for more details).",
      "ja": "アンカーが指定されている場合、アンカーのインデックスに関連して返される最初の結果のインデックス。 これは否定的な場合があります。 たとえば、「-1」は、アンカーの直前のFooが返されるリストの最初の結果であることを意味します（詳細については以下を参照）。"
    },
    {
      "indent": 3,
      "text": "o limit: \"UnsignedInt|null\"",
      "ja": "o 制限：「UnsignedInt | null」"
    },
    {
      "indent": 6,
      "text": "The maximum number of results to return. If null, no limit presumed. The server MAY choose to enforce a maximum \"limit\" argument. In this case, if a greater value is given (or if it is null), the limit is clamped to the maximum; the new limit is returned with the response so the client is aware. If a negative value is given, the call MUST be rejected with an \"invalidArguments\" error.",
      "ja": "返される結果の最大数。 nullの場合、制限は推定されません。 サーバーは、最大の「制限」引数を強制することを選択できます。 この場合、より大きな値が指定された場合（またはnullの場合）、制限は最大値に固定されます。 クライアントが認識できるように、新しい制限が応答とともに返されます。 負の値が指定された場合、呼び出しは「invalidArguments」エラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o calculateTotal: \"Boolean\" (default: false)",
      "ja": "o CalculateTotal： \"Boolean\"（デフォルト：false）"
    },
    {
      "indent": 6,
      "text": "Does the client wish to know the total number of results in the query? This may be slow and expensive for servers to calculate, particularly with complex filters, so clients should take care to only request the total when needed.",
      "ja": "クライアントはクエリの結果の総数を知りたいですか？ これは、特に複雑なフィルターの場合、サーバーの計算に時間がかかり、コストがかかる可能性があるため、クライアントは必要な場合にのみ合計を要求するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an \"anchor\" argument is given, the anchor is looked for in the results after filtering and sorting. If found, the \"anchorOffset\" is then added to its index. If the resulting index is now negative, it is clamped to 0. This index is now used exactly as though it were supplied as the \"position\" argument. If the anchor is not found, the call is rejected with an \"anchorNotFound\" error.",
      "ja": "「アンカー」引数が指定されている場合、フィルタリングおよびソート後の結果でアンカーが検索されます。 見つかった場合、「anchorOffset」がそのインデックスに追加されます。 結果のインデックスが負の場合、0に固定されます。このインデックスは、「位置」引数として指定された場合とまったく同じように使用されます。 アンカーが見つからない場合、呼び出しは「anchorNotFound」エラーで拒否されます。"
    },
    {
      "indent": 3,
      "text": "If an \"anchor\" is specified, any position argument supplied by the client MUST be ignored. If no \"anchor\" is supplied, any \"anchorOffset\" argument MUST be ignored.",
      "ja": "「アンカー」が指定されている場合、クライアントが提供する位置引数は無視しなければなりません。 「anchor」が指定されていない場合、「anchorOffset」引数は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client can use \"anchor\" instead of \"position\" to find the index of an id within a large set of results.",
      "ja": "クライアントは、「position」の代わりに「anchor」を使用して、多数の結果セット内でidのインデックスを見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o queryState: \"String\"",
      "ja": "o queryState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "A string encoding the current state of the query on the server. This string MUST change if the results of the query (i.e., the matching ids and their sort order) have changed. The queryState string MAY change if something has changed on the server, which means the results may have changed but the server doesn't know for sure.",
      "ja": "サーバー上のクエリの現在の状態をエンコードする文字列。 クエリの結果（つまり、一致するIDとそれらの並べ替え順序）が変更された場合、この文字列を変更する必要があります。 サーバー上で何かが変更された場合、queryState文字列が変更される場合があります。つまり、結果は変更された可能性がありますが、サーバーは確実にはわかりません。"
    },
    {
      "indent": 6,
      "text": "The queryState string only represents the ordered list of ids that match the particular query (including its sort/filter). There is no requirement for it to change if a property on an object matching the query changes but the query results are unaffected (indeed, it is more efficient if the queryState string does not change in this case). The queryState string only has meaning when compared to future responses to a query with the same type/sort/ filter or when used with /queryChanges to fetch changes.",
      "ja": "queryState文字列は、特定のクエリ（ソート/フィルターを含む）に一致するIDの順序付きリストのみを表します。 クエリに一致するオブジェクトのプロパティが変更されても変更する必要はありませんが、クエリ結果は影響を受けません（実際、この場合、queryState文字列が変更されない方が効率的です）。 queryState文字列は、同じタイプ/ソート/フィルターを使用したクエリに対する今後の応答と比較した場合、または/ queryChangesで変更をフェッチする場合にのみ意味を持ちます。"
    },
    {
      "indent": 6,
      "text": "Should a client receive back a response with a different queryState string to a previous call, it MUST either throw away the currently cached query and fetch it again (note, this does not require fetching the records again, just the list of ids) or call \"Foo/queryChanges\" to get the difference.",
      "ja": "クライアントが以前の呼び出しとは異なるqueryState文字列を含む応答を受信した場合、現在キャッシュされているクエリを破棄して再度フェッチする必要があります（これは、レコードの再フェッチは必要なく、IDのリストのみを取得する必要があります） 「Foo / queryChanges」で違いを取得します。"
    },
    {
      "indent": 3,
      "text": "o canCalculateChanges: \"Boolean\"",
      "ja": "o canCalculateChanges： \"ブール値\""
    },
    {
      "indent": 6,
      "text": "This is true if the server supports calling \"Foo/queryChanges\" with these \"filter\"/\"sort\" parameters. Note, this does not guarantee that the \"Foo/queryChanges\" call will succeed, as it may only be possible for a limited time afterwards due to server internal implementation details.",
      "ja": "これは、サーバーがこれらの「filter」/「sort」パラメーターで「Foo / queryChanges」の呼び出しをサポートしている場合に当てはまります。 これは、サーバー内部の実装の詳細のために、その後の限られた時間のみ可能になるため、「Foo / queryChanges」呼び出しが成功することを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "o position: \"UnsignedInt\"",
      "ja": "o 位置：「UnsignedInt」"
    },
    {
      "indent": 6,
      "text": "The zero-based index of the first result in the \"ids\" array within the complete list of query results.",
      "ja": "クエリ結果の完全なリスト内の「ids」配列の最初の結果のゼロから始まるインデックス。"
    },
    {
      "indent": 3,
      "text": "o ids: \"Id[]\"",
      "ja": "o ids： \"Id []\""
    },
    {
      "indent": 6,
      "text": "The list of ids for each Foo in the query results, starting at the index given by the \"position\" argument of this response and continuing until it hits the end of the results or reaches the \"limit\" number of ids. If \"position\" is >= \"total\", this MUST be the empty list.",
      "ja": "クエリ結果の各FooのIDのリスト。この応答の「位置」引数で指定されたインデックスから始まり、結果の終わりに達するか、IDの「制限」数に達するまで続きます。 「位置」が> =「合計」の場合、これは空のリストでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o total: \"UnsignedInt\" (only if requested)",
      "ja": "o 合計： \"UnsignedInt\"（要求された場合のみ）"
    },
    {
      "indent": 6,
      "text": "The total number of Foos in the results (given the \"filter\"). This argument MUST be omitted if the \"calculateTotal\" request argument is not true.",
      "ja": "結果に含まれる食品の総数（「フィルター」を指定）。 「計算された合計」リクエスト引数が真でない場合、この引数は省略されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o limit: \"UnsignedInt\" (if set by the server)",
      "ja": "o 制限：「UnsignedInt」（サーバーによって設定されている場合）"
    },
    {
      "indent": 6,
      "text": "The limit enforced by the server on the maximum number of results to return. This is only returned if the server set a limit or used a different limit than that given in the request.",
      "ja": "返される結果の最大数にサーバーが適用する制限。 これは、サーバーが制限を設定した場合、または要求で指定された制限とは異なる制限を使用した場合にのみ返されます。"
    },
    {
      "indent": 3,
      "text": "The following additional errors may be returned instead of the \"Foo/ query\" response:",
      "ja": "「Foo / query」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"anchorNotFound\": An anchor argument was supplied, but it cannot be found in the results of the query.",
      "ja": "\"anchorNotFound\"：アンカー引数が指定されましたが、クエリの結果に見つかりません。"
    },
    {
      "indent": 3,
      "text": "\"unsupportedSort\": The \"sort\" is syntactically valid, but it includes a property the server does not support sorting on or a collation method it does not recognise.",
      "ja": "「unsupportedSort」：「sort」は構文的には有効ですが、サーバーがソートをサポートしていないプロパティや、認識できない照合メソッドが含まれています。"
    },
    {
      "indent": 3,
      "text": "\"unsupportedFilter\": The \"filter\" is syntactically valid, but the server cannot process it. If the filter was the result of a user's search input, the client SHOULD suggest that the user simplify their search.",
      "ja": "「unsupportedFilter」：「filter」は構文的に有効ですが、サーバーはそれを処理できません。 フィルタがユーザーの検索入力の結果である場合、クライアントは、ユーザーが検索を簡素化することを提案する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. /queryChanges",
      "section_title": true,
      "ja": "5.6. / queryChanges"
    },
    {
      "indent": 3,
      "text": "The \"Foo/queryChanges\" method allows a client to efficiently update the state of a cached query to match the new state on the server. It takes the following arguments:",
      "ja": "「Foo / queryChanges」メソッドを使用すると、クライアントはキャッシュされたクエリの状態を効率的に更新して、サーバー上の新しい状態に一致させることができます。 以下の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to use.",
      "ja": "使用するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o filter: \"FilterOperator|FilterCondition|null\"",
      "ja": "o フィルター：「FilterOperator | FilterCondition | null」"
    },
    {
      "indent": 6,
      "text": "The filter argument that was used with \"Foo/query\".",
      "ja": "「Foo / query」で使用されたフィルター引数。"
    },
    {
      "indent": 3,
      "text": "o sort: \"Comparator[]|null\"",
      "ja": "o ソート： \"Comparator [] | null\""
    },
    {
      "indent": 6,
      "text": "The sort argument that was used with \"Foo/query\".",
      "ja": "「Foo / query」で使用されたソート引数。"
    },
    {
      "indent": 3,
      "text": "o sinceQueryState: \"String\"",
      "ja": "o sinceQueryState： \"String\""
    },
    {
      "indent": 6,
      "text": "The current state of the query in the client. This is the string that was returned as the \"queryState\" argument in the \"Foo/query\" response with the same sort/filter. The server will return the changes made to the query since this state.",
      "ja": "クライアントでのクエリの現在の状態。 これは、同じソート/フィルターを使用した「Foo / query」応答の「queryState」引数として返された文字列です。 サーバーは、この状態以降にクエリに加えられた変更を返します。"
    },
    {
      "indent": 3,
      "text": "o maxChanges: \"UnsignedInt|null\"",
      "ja": "o maxChanges： \"UnsignedInt | null\""
    },
    {
      "indent": 6,
      "text": "The maximum number of changes to return in the response. See error descriptions below for more details.",
      "ja": "応答で返す変更の最大数。 詳細については、以下のエラーの説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "o upToId: \"Id|null\"",
      "ja": "o upToId： \"Id | null\""
    },
    {
      "indent": 6,
      "text": "The last (highest-index) id the client currently has cached from the query results. When there are a large number of results, in a common case, the client may have only downloaded and cached a small subset from the beginning of the results. If the sort and filter are both only on immutable properties, this allows the server to omit changes after this point in the results, which can significantly increase efficiency. If they are not immutable, this argument is ignored.",
      "ja": "クライアントがクエリ結果から現在キャッシュしている最後の（最高のインデックス）ID。 多数の結果がある場合、一般的な場合、クライアントは結果の先頭から小さなサブセットのみをダウンロードしてキャッシュした可能性があります。 並べ替えとフィルターの両方が不変のプロパティのみである場合、これにより、サーバーは結果のこのポイント以降の変更を省略することができ、効率が大幅に向上します。 それらが不変でない場合、この引数は無視されます。"
    },
    {
      "indent": 3,
      "text": "o calculateTotal: \"Boolean\" (default: false)",
      "ja": "o CalculateTotal： \"Boolean\"（デフォルト：false）"
    },
    {
      "indent": 6,
      "text": "Does the client wish to know the total number of results now in the query? This may be slow and expensive for servers to calculate, particularly with complex filters, so clients should take care to only request the total when needed.",
      "ja": "クライアントは、クエリの結果の総数を知りたいですか？ これは、特に複雑なフィルターの場合、サーバーの計算に時間がかかり、コストがかかる可能性があるため、クライアントは必要な場合にのみ合計を要求するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o oldQueryState: \"String\"",
      "ja": "o oldQueryState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This is the \"sinceQueryState\" argument echoed back; that is, the state from which the server is returning changes.",
      "ja": "これはエコーバックされる「sinceQueryState」引数です。 つまり、サーバーが変更を返す元の状態です。"
    },
    {
      "indent": 3,
      "text": "o newQueryState: \"String\"",
      "ja": "o newQueryState： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This is the state the query will be in after applying the set of changes to the old state.",
      "ja": "これは、一連の変更を古い状態に適用した後のクエリの状態です。"
    },
    {
      "indent": 3,
      "text": "o total: \"UnsignedInt\" (only if requested)",
      "ja": "o 合計： \"UnsignedInt\"（要求された場合のみ）"
    },
    {
      "indent": 6,
      "text": "The total number of Foos in the results (given the \"filter\"). This argument MUST be omitted if the \"calculateTotal\" request argument is not true.",
      "ja": "結果に含まれる食品の総数（「フィルター」を指定）。 「計算された合計」リクエスト引数が真でない場合、この引数は省略されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o removed: \"Id[]\"",
      "ja": "o 削除：「Id []」"
    },
    {
      "indent": 6,
      "text": "The \"id\" for every Foo that was in the query results in the old state and that is not in the results in the new state.",
      "ja": "クエリに含まれていたすべてのFooの「id」の結果は古い状態になり、新しい状態の結果には含まれません。"
    },
    {
      "indent": 6,
      "text": "If the server cannot calculate this exactly, the server MAY return the ids of extra Foos in addition that may have been in the old results but are not in the new results.",
      "ja": "サーバーがこれを正確に計算できない場合、サーバーは、古い結果にはあったかもしれないが新しい結果にはない追加のFoosのIDを返す場合があります。"
    },
    {
      "indent": 6,
      "text": "If the sort and filter are both only on immutable properties and an \"upToId\" is supplied and exists in the results, any ids that were removed but have a higher index than \"upToId\" SHOULD be omitted.",
      "ja": "並べ替えとフィルターの両方が不変のプロパティのみであり、「upToId」が指定されて結果に存在する場合、削除されたが「upToId」よりも高いインデックスを持つIDは省略される必要があります。"
    },
    {
      "indent": 6,
      "text": "If the \"filter\" or \"sort\" includes a mutable property, the server MUST include all Foos in the current results for which this property may have changed. The position of these may have moved in the results, so they must be reinserted by the client to ensure its query cache is correct.",
      "ja": "「フィルター」または「ソート」に可変プロパティが含まれる場合、サーバーは、このプロパティが変更された可能性のある現在の結果にすべてのFoosを含める必要があります。 これらの位置は結果内で移動した可能性があるため、クエリキャッシュが正しいことを確認するには、クライアントがそれらを再挿入する必要があります。"
    },
    {
      "indent": 3,
      "text": "o added: \"AddedItem[]\"",
      "ja": "o 追加：「AddedItem []」"
    },
    {
      "indent": 6,
      "text": "The id and index in the query results (in the new state) for every Foo that has been added to the results since the old state AND every Foo in the current results that was included in the \"removed\" array (due to a filter or sort based upon a mutable property).",
      "ja": "古い状態以降に結果に追加されたすべてのFooのクエリ結果（新しい状態）のIDとインデックス、および「削除」配列に含まれていた現在の結果のすべてのFoo（フィルターまたは 可変プロパティに基づいて並べ替えます）。"
    },
    {
      "indent": 6,
      "text": "If the sort and filter are both only on immutable properties and an \"upToId\" is supplied and exists in the results, any ids that were added but have a higher index than \"upToId\" SHOULD be omitted.",
      "ja": "並べ替えとフィルターの両方が不変のプロパティのみであり、結果に「upToId」が指定されて存在する場合、追加されたが「upToId」よりも高いインデックスを持つIDは省略される必要があります。"
    },
    {
      "indent": 6,
      "text": "The array MUST be sorted in order of index, with the lowest index first.",
      "ja": "配列は、インデックスの順にソートされなければならず、最も低いインデックスが最初になります。"
    },
    {
      "indent": 6,
      "text": "An *AddedItem* object has the following properties:",
      "ja": "* AddedItem *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "* id: \"Id\"",
      "ja": "* やった\""
    },
    {
      "indent": 6,
      "text": "* index: \"UnsignedInt\"",
      "ja": "* インデックス：「UnsignedInt」"
    },
    {
      "indent": 3,
      "text": "The result of this is that if the client has a cached sparse array of Foo ids corresponding to the results in the old state, then:",
      "ja": "この結果、クライアントが古い状態の結果に対応するFoo IDのキャッシュされたスパース配列を持っている場合、次のようになります。"
    },
    {
      "indent": 3,
      "text": "fooIds = [ \"id1\", \"id2\", null, null, \"id3\", \"id4\", null, null, null ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If it *splices out* all ids in the removed array that it has in its cached results, then:",
      "ja": "キャッシュされた結果にある削除された配列内のすべてのIDを*スプライスアウト*する場合、次のようになります。"
    },
    {
      "indent": 6,
      "text": "removed = [ \"id2\", \"id31\", ... ];\nfooIds => [ \"id1\", null, null, \"id3\", \"id4\", null, null, null ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and *splices in* (one by one in order, starting with the lowest index) all of the ids in the added array:",
      "ja": "そして、* splices in *（最小のインデックスから順番に1つずつ）追加された配列のすべてのID："
    },
    {
      "indent": 2,
      "text": "added = [{ id: \"id5\", index: 0, ... }];\nfooIds => [ \"id5\", \"id1\", null, null, \"id3\", \"id4\", null, null, null ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and *truncates* or *extends* to the new total length, then the results will now be in the new state.",
      "ja": "そして* truncates *または* extends *を新しい合計の長さにすると、結果は新しい状態になります。"
    },
    {
      "indent": 3,
      "text": "Note: splicing in adds the item at the given index, incrementing the index of all items previously at that or a higher index. Splicing out is the inverse, removing the item and decrementing the index of every item after it in the array.",
      "ja": "注：スプライシングは、指定されたインデックスにアイテムを追加し、以前にそのインデックス以上のすべてのアイテムのインデックスをインクリメントします。 スプライスアウトは逆で、アイテムを削除し、配列内のすべてのアイテムのインデックスをデクリメントします。"
    },
    {
      "indent": 3,
      "text": "The following additional errors may be returned instead of the \"Foo/ queryChanges\" response:",
      "ja": "「Foo / queryChanges」応答の代わりに、次の追加エラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"tooManyChanges\": There are more changes than the client's \"maxChanges\" argument. Each item in the removed or added array is considered to be one change. The client may retry with higher max changes or invalidate its cache of the query results.",
      "ja": "「tooManyChanges」：クライアントの「maxChanges」引数よりも多くの変更があります。 削除または追加された配列の各アイテムは、1つの変更と見なされます。 クライアントは、最大変更数を増やして再試行するか、クエリ結果のキャッシュを無効にします。"
    },
    {
      "indent": 3,
      "text": "\"cannotCalculateChanges\": The server cannot calculate the changes from the queryState string given by the client, usually due to the client's state being too old. The client MUST invalidate its cache of the query results.",
      "ja": "\"cannotCalculateChanges\"：通常、クライアントの状態が古すぎるため、サーバーはクライアントが指定したqueryState文字列から変更を計算できません。 クライアントはクエリ結果のキャッシュを無効にしなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.7. Examples",
      "section_title": true,
      "ja": "5.7. 例"
    },
    {
      "indent": 3,
      "text": "Suppose we have a type *Todo* with the following properties:",
      "ja": "次のプロパティを持つ* Todo *型があるとします："
    },
    {
      "indent": 3,
      "text": "o id: \"Id\" (immutable; server-set)",
      "ja": "o id： \"Id\"（不変;サーバーセット）"
    },
    {
      "indent": 6,
      "text": "The id of the object.",
      "ja": "オブジェクトのID。"
    },
    {
      "indent": 3,
      "text": "o title: \"String\"",
      "ja": "o title： \"文字列\""
    },
    {
      "indent": 6,
      "text": "A brief summary of what is to be done.",
      "ja": "何をすべきかの簡単な要約。"
    },
    {
      "indent": 3,
      "text": "o keywords: \"String[Boolean]\" (default: {})",
      "ja": "o キーワード： \"String [Boolean]\"（デフォルト：{}）"
    },
    {
      "indent": 6,
      "text": "A set of keywords that apply to the Todo. The set is represented as an object, with the keys being the \"keywords\". The value for each key in the object MUST be true. (This format allows you to update an individual key using patch syntax rather than having to update the whole set of keywords as one, which a \"String[]\" representation would require.)",
      "ja": "Todoに適用される一連のキーワード。 セットはオブジェクトとして表され、キーは「キーワード」です。 オブジェクトの各キーの値は真でなければなりません。 （この形式では、「String []」表現が必要とするキーワードのセット全体を1つとして更新するのではなく、パッチ構文を使用して個々のキーを更新できます。）"
    },
    {
      "indent": 3,
      "text": "o neuralNetworkTimeEstimation: \"Number\" (server-set)",
      "ja": "o neuroNetworkTimeEstimation： \"Number\"（サーバーセット）"
    },
    {
      "indent": 6,
      "text": "The title and keywords are fed into the server's state-of-the-art neural network to get an estimation of how long this Todo will take, in seconds.",
      "ja": "タイトルとキーワードは、サーバーの最新のニューラルネットワークに送られ、このTodoにかかる時間を数秒で推定します。"
    },
    {
      "indent": 3,
      "text": "o subTodoIds: \"Id[]|null\"",
      "ja": "o subTodoIds： \"Id [] | null\""
    },
    {
      "indent": 6,
      "text": "The ids of a list of other Todos to complete as part of this Todo.",
      "ja": "このTodoの一部として完了する他のTodoのリストのID。"
    },
    {
      "indent": 3,
      "text": "Suppose also that all the standard methods are defined for this type and the FilterCondition object supports a \"hasKeyword\" property to match Todos with the given keyword.",
      "ja": "また、すべての標準メソッドがこのタイプに対して定義されており、FilterConditionオブジェクトが「hasKeyword」プロパティをサポートして、与えられたキーワードとTodoを一致させると仮定します。"
    },
    {
      "indent": 3,
      "text": "A client might want to display the list of Todos with either a \"music\" keyword or a \"video\" keyword, so it makes the following method call:",
      "ja": "クライアントは、「音楽」キーワードまたは「ビデオ」キーワードのいずれかでTodoのリストを表示したい場合があるため、次のメソッド呼び出しを行います。"
    },
    {
      "indent": 19,
      "text": "[[ \"Todo/query\", {\n  \"accountId\": \"x\",\n  \"filter\": {\n    \"operator\": \"OR\",\n    \"conditions\": [\n      { \"hasKeyword\": \"music\" },\n      { \"hasKeyword\": \"video\" }\n    ]\n  },\n  \"sort\": [{ \"property\": \"title\" }],\n  \"position\": 0,\n  \"limit\": 10\n}, \"0\" ],\n[ \"Todo/get\", {\n  \"accountId\": \"x\",\n  \"#ids\": {\n    \"resultOf\": \"0\",\n    \"name\": \"Todo/query\",\n    \"path\": \"/ids\"\n  }\n}, \"1\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This would query the server for the set of Todos with a keyword of either \"music\" or \"video\", sorted by title, and limited to the first 10 results. It fetches the full object for each of these Todos using back-references to reference the result of the query. The response might look something like:",
      "ja": "これは、タイトルでソートされ、最初の10件の結果に制限された「音楽」または「ビデオ」のいずれかのキーワードを使用して、サーバーに一連のTodoを照会します。 クエリの結果を参照するための後方参照を使用して、これらの各Todoの完全なオブジェクトをフェッチします。 応答は次のようになります。"
    },
    {
      "indent": 7,
      "text": "[[ \"Todo/query\", {\n  \"accountId\": \"x\",\n  \"queryState\": \"y13213\",\n  \"canCalculateChanges\": true,\n  \"position\": 0,\n  \"ids\": [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\" ]\n}, \"0\" ],\n[ \"Todo/get\", {\n  \"accountId\": \"x\",\n  \"state\": \"10324\",\n  \"list\": [{\n    \"id\": \"a\",\n    \"title\": \"Practise Piano\",\n    \"keywords\": {\n      \"music\": true,\n      \"beethoven\": true,\n      \"mozart\": true,\n      \"liszt\": true,\n      \"rachmaninov\": true\n    },\n    \"neuralNetworkTimeEstimation\": 3600\n  }, {\n    \"id\": \"b\",\n    \"title\": \"Watch Daft Punk music video\",\n    \"keywords\": {\n      \"music\": true,\n      \"video\": true,\n      \"trance\": true\n    },\n    \"neuralNetworkTimeEstimation\": 18000\n  },\n  ...\n  ]\n}, \"1\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, suppose the user adds a keyword \"chopin\" and removes the keyword \"mozart\" from the \"Practise Piano\" task. The client may send the whole object to the server, as this is a valid PatchObject:",
      "ja": "ここで、ユーザーが「ショパン」というキーワードを追加し、「ピアノの練習」タスクから「モーツァルト」というキーワードを削除するとします。 これは有効なPatchObjectであるため、クライアントはオブジェクト全体をサーバーに送信できます。"
    },
    {
      "indent": 17,
      "text": "[[ \"Todo/set\", {\n  \"accountId\": \"x\",\n  \"ifInState\": \"10324\",\n  \"update\": {\n    \"a\": {\n      \"id\": \"a\",\n      \"title\": \"Practise Piano\",\n      \"keywords\": {\n        \"music\": true,\n        \"beethoven\": true,\n        \"chopin\": true,\n        \"liszt\": true,\n        \"rachmaninov\": true\n      },\n      \"neuralNetworkTimeEstimation\": 360\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "or it may send a minimal patch:",
      "ja": "または、最小限のパッチを送信する場合があります。"
    },
    {
      "indent": 22,
      "text": "[[ \"Todo/set\", {\n  \"accountId\": \"x\",\n  \"ifInState\": \"10324\",\n  \"update\": {\n    \"a\": {\n      \"keywords/chopin\": true,\n      \"keywords/mozart\": null\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The effect is exactly the same on the server in either case, and presuming the server is still in state \"10324\", it will probably return success:",
      "ja": "どちらの場合でも、サーバー上での効果はまったく同じであり、サーバーがまだ「10324」状態にあると仮定すると、おそらく成功を返します。"
    },
    {
      "indent": 17,
      "text": "[[ \"Todo/set\", {\n  \"accountId\": \"x\",\n  \"oldState\": \"10324\",\n  \"newState\": \"10329\",\n  \"updated\": {\n    \"a\": {\n      \"neuralNetworkTimeEstimation\": 5400\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server changed the \"neuralNetworkTimeEstimation\" property on the object as part of this change; as this changed in a way *not* explicitly requested by the PatchObject sent to the server, it is returned with the \"updated\" confirmation.",
      "ja": "サーバーは、この変更の一部としてオブジェクトの「neuralNetworkTimeEstimation」プロパティを変更しました。 これは、サーバーに送信されるPatchObjectによって明示的に要求されない方法で変更されたため、「更新済み」確認とともに返されます。"
    },
    {
      "indent": 3,
      "text": "Let us now add a sub-Todo to our new \"Practise Piano\" Todo. In this example, we can see the use of a reference to a creation id to allow us to set a foreign key reference to a record created in the same request:",
      "ja": "ここで、新しい「Practise Piano」TodoにサブTodoを追加しましょう。 この例では、作成IDへの参照を使用して、同じリクエストで作成されたレコードへの外部キー参照を設定できます。"
    },
    {
      "indent": 19,
      "text": "[[ \"Todo/set\", {\n  \"accountId\": \"x\",\n  \"create\": {\n    \"k15\": {\n      \"title\": \"Warm up with scales\"\n    }\n  },\n  \"update\": {\n    \"a\": {\n      \"subTodoIds\": [ \"#k15\" ]\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, suppose another user deleted the \"Listen to Daft Punk\" Todo. The first user will receive a push notification (see Section 7) with the changed state string for the \"Todo\" type. Since the new string does not match its current state, it knows it needs to check for updates. It may make a request like:",
      "ja": "次に、別のユーザーが「Listen to Daft Punk」Todoを削除したとします。 最初のユーザーは、 \"Todo\"タイプの状態文字列が変更されたプッシュ通知（セクション7を参照）を受け取ります。 新しい文字列は現在の状態と一致しないため、更新を確認する必要があることがわかります。 次のようなリクエストを行う場合があります。"
    },
    {
      "indent": 19,
      "text": "[[ \"Todo/changes\", {\n  \"accountId\": \"x\",\n  \"sinceState\": \"10324\",\n  \"maxChanges\": 50\n}, \"0\" ],\n[ \"Todo/queryChanges\", {\n  \"accountId\": \"x\",\n  \"filter\": {\n    \"operator\": \"OR\",\n    \"conditions\": [\n      { \"hasKeyword\": \"music\" },\n      { \"hasKeyword\": \"video\" }\n    ]\n  },\n  \"sort\": [{ \"property\": \"title\" }],\n  \"sinceQueryState\": \"y13213\",\n  \"maxChanges\": 50\n}, \"1\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and receive in response:",
      "ja": "応答で受信します。"
    },
    {
      "indent": 23,
      "text": "[[ \"Todo/changes\", {\n  \"accountId\": \"x\",\n  \"oldState\": \"10324\",\n  \"newState\": \"871903\",\n  \"hasMoreChanges\": false,\n  \"created\": [],\n  \"updated\": [],\n  \"destroyed\": [\"b\"]\n}, \"0\" ],\n[ \"Todo/queryChanges\", {\n  \"accountId\": \"x\",\n  \"oldQueryState\": \"y13213\",\n  \"newQueryState\": \"y13218\",\n  \"removed\": [\"b\"],\n  \"added\": null\n}, \"1\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suppose the user has access to another account \"y\", for example, a team account shared between multiple users. To move an existing Todo from account \"x\", the client would call:",
      "ja": "ユーザーが別のアカウント「y」、たとえば、複数のユーザー間で共有されるチームアカウントにアクセスできるとします。 アカウント「x」から既存のTodoを移動するには、クライアントは以下を呼び出します。"
    },
    {
      "indent": 20,
      "text": "[[ \"Todo/copy\", {\n  \"fromAccountId\": \"x\",\n  \"accountId\": \"y\",\n  \"create\": {\n    \"k5122\": {\n      \"id\": \"a\"\n    }\n  },\n  \"onSuccessDestroyOriginal\": true\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server successfully copies the Todo to a new account (where it receives a new id) and deletes the original. Due to the implicit call to \"Todo/set\", there are two responses to the single method call, both with the same method call id:",
      "ja": "サーバーは、Todoを（新しいIDを受け取る）新しいアカウントに正常にコピーし、元のアカウントを削除します。 「Todo / set」への暗黙的な呼び出しにより、単一のメソッド呼び出しに対する応答が2つあり、両方とも同じメソッド呼び出しIDを使用します。"
    },
    {
      "indent": 23,
      "text": "[[ \"Todo/copy\", {\n  \"fromAccountId\": \"x\",\n  \"accountId\": \"y\",\n  \"created\": {\n    \"k5122\": {\n      \"id\": \"DAf97\"\n    }\n  },\n  \"oldState\": \"c1d64ecb038c\",\n  \"newState\": \"33844835152b\"\n}, \"0\" ],\n[ \"Todo/set\", {\n  \"accountId\": \"x\",\n  \"oldState\": \"871903\",\n  \"newState\": \"871909\",\n  \"destroyed\": [ \"a\" ],\n  ...\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.8. Proxy Considerations",
      "section_title": true,
      "ja": "5.8. プロキシの考慮事項"
    },
    {
      "indent": 3,
      "text": "JMAP has been designed to allow an API endpoint to easily proxy through to one or more JMAP servers. This may be useful for load balancing, augmenting capabilities, or presenting a single endpoint to accounts hosted on different JMAP servers (splitting the request based on each method's \"accountId\" argument). The proxy need only understand the general structure of a JMAP Request object; it does not need to know anything specifically about the methods and arguments it will pass through to other servers.",
      "ja": "JMAPは、APIエンドポイントが1つ以上のJMAPサーバーに簡単にプロキシスルーできるように設計されています。 これは、負荷分散、機能の強化、または異なるJMAPサーバーでホストされているアカウントへの単一のエンドポイントの提示（各メソッドの「accountId」引数に基づいて要求を分割する）に役立つ場合があります。 プロキシは、JMAP Requestオブジェクトの一般的な構造のみを理解する必要があります。 他のサーバーに渡すメソッドと引数について特に知る必要はありません。"
    },
    {
      "indent": 3,
      "text": "If splitting up the methods in a request to call them on different backend servers, the proxy must do two things to ensure back-references and creation-id references resolve the same as if the entire request were processed on a single server:",
      "ja": "リクエスト内のメソッドを分割して異なるバックエンドサーバーで呼び出す場合、プロキシは、後方参照とcreation-id参照が単一のサーバーでリクエスト全体が処理された場合と同じように解決されるように2つのことを行う必要があります："
    },
    {
      "indent": 3,
      "text": "1. It must pass a \"createdIds\" property with each subrequest. If this is not given by the client, an empty object should be used for the first subrequest. The \"createdIds\" property of each subresponse should be passed on in the next subrequest.",
      "ja": "1. 各サブリクエストで「createdIds」プロパティを渡す必要があります。 これがクライアントによって与えられない場合、空のオブジェクトが最初のサブリクエストに使用されるべきです。 各サブレスポンスの「createdIds」プロパティは、次のサブリクエストで渡される必要があります。"
    },
    {
      "indent": 3,
      "text": "2. It must resolve back-references to previous method results that were processed on a different server. This is a relatively simple syntactic substitution, described in Section 3.7.",
      "ja": "2. 別のサーバーで処理された以前のメソッド結果への後方参照を解決する必要があります。 これは比較的簡単な構文置換であり、セクション3.7で説明されています。"
    },
    {
      "indent": 3,
      "text": "When splitting a request based on accountId, proxy implementors do need to be aware of \"/copy\" methods that copy between accounts. If the accounts are on different servers, the proxy will have to implement this functionality directly.",
      "ja": "accountIdに基づいてリクエストを分割する場合、プロキシ実装者は、アカウント間でコピーする「/ copy」メソッドを認識する必要があります。 アカウントが異なるサーバー上にある場合、プロキシはこの機能を直接実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Binary Data",
      "section_title": true,
      "ja": "6. バイナリデータ"
    },
    {
      "indent": 3,
      "text": "Binary data is referenced by a *blobId* in JMAP and uploaded/ downloaded separately to the core API. The blobId solely represents the raw bytes of data, not any associated metadata such as a file name or content type. Such metadata is stored alongside the blobId in the object referencing it. The data represented by a blobId is immutable.",
      "ja": "バイナリデータはJMAPの* blobId *によって参照され、コアAPIに個別にアップロード/ダウンロードされます。 blobIdはデータの生のバイトのみを表し、ファイル名やコンテンツタイプなどの関連するメタデータは表しません。 このようなメタデータは、それを参照するオブジェクトのblobIdと共に保存されます。 blobIdで表されるデータは不変です。"
    },
    {
      "indent": 3,
      "text": "Any blobId that exists within an account may be used when creating/ updating another object in that account. For example, an Email type may have a blobId that represents the object in Internet Message Format [RFC5322]. A client could create a new Email object with an attachment and use this blobId, in effect attaching the old message to the new one. Similarly, it could attach any existing attachment of an old message without having to download and upload it again.",
      "ja": "アカウント内に存在するblobIdは、そのアカウント内の別のオブジェクトを作成/更新するときに使用できます。 たとえば、電子メールタイプには、インターネットメッセージ形式[RFC5322]のオブジェクトを表すblobIdが含まれる場合があります。 クライアントは、添付ファイル付きの新しいEmailオブジェクトを作成し、このblobIdを使用して、事実上古いメッセージを新しいメッセージに添付できます。 同様に、ダウンロードしてアップロードし直すことなく、古いメッセージの既存の添付ファイルを添付できます。"
    },
    {
      "indent": 3,
      "text": "When the client uses a blobId in a create/update, the server MAY assign a new blobId to refer to the same binary data within the new/ updated object. If it does so, it MUST return any properties that contain a changed blobId in the created/updated response, so the client gets the new ids.",
      "ja": "クライアントが作成/更新でblobIdを使用する場合、サーバーは新しいblobIdを割り当てて、新しい/更新されたオブジェクト内の同じバイナリデータを参照する場合があります。 そうする場合、作成/更新された応答で変更されたblobIdを含むプロパティを返さなければならないため、クライアントは新しいIDを取得します。"
    },
    {
      "indent": 3,
      "text": "A blob that is not referenced by a JMAP object (e.g., as a message attachment) MAY be deleted by the server to free up resources. Uploads (see below) are initially unreferenced blobs. To ensure interoperability:",
      "ja": "JMAPオブジェクトによって参照されないblob（たとえば、メッセージの添付ファイルとして）は、リソースを解放するためにサーバーによって削除される場合があります。 アップロード（以下を参照）は、最初は参照されていないBLOBです。 相互運用性を確保するには："
    },
    {
      "indent": 3,
      "text": "o The server SHOULD use a separate quota for unreferenced blobs to the account's usual quota. In the case of shared accounts, this quota SHOULD be separate per user.",
      "ja": "o サーバーは、参照されていないblobに対して、アカウントの通常のクォータに対する個別のクォータを使用する必要があります。 共有アカウントの場合、このクォータはユーザーごとに分離する必要があります。"
    },
    {
      "indent": 3,
      "text": "o This quota SHOULD be at least the maximum total size that a single object can reference on this server. For example, if supporting JMAP Mail, this should be at least the maximum total attachments size for a message.",
      "ja": "o このクォータは、少なくとも、このサーバーで単一オブジェクトが参照できる最大合計サイズである必要があります。 たとえば、JMAPメールをサポートする場合、これは少なくともメッセージの最大合計添付ファイルサイズである必要があります。"
    },
    {
      "indent": 3,
      "text": "o When an upload would take the user over quota, the server MUST delete unreferenced blobs in date order, oldest first, until there is room for the new blob.",
      "ja": "o アップロードでユーザーが割り当てを超えた場合、サーバーは、新しいblobのスペースができるまで、参照されていないblobを日付順に古いものから削除しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Except where quota restrictions force early deletion, an unreferenced blob MUST NOT be deleted for at least 1 hour from the time of upload; if reuploaded, the same blobId MAY be returned, but this SHOULD reset the expiry time.",
      "ja": "o クォータ制限により早期削除が強制される場合を除き、参照されていないblobはアップロード時から少なくとも1時間は削除しないでください。 再アップロードされた場合、同じblobIdが返される場合がありますが、これは有効期限をリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "o A blob MUST NOT be deleted during the method call that removed the last reference, so that a client can issue a create and a destroy that both reference the blob within the same method call.",
      "ja": "o クライアントが同じメソッド呼び出し内でblobを参照するcreateとdestroyを発行できるように、最後の参照を削除したメソッド呼び出し中にblobを削除しないでください。"
    },
    {
      "indent": 0,
      "text": "6.1. Uploading Binary Data",
      "section_title": true,
      "ja": "6.1. バイナリデータのアップロード"
    },
    {
      "indent": 3,
      "text": "There is a single endpoint that handles all file uploads for an account, regardless of what they are to be used for. The Session object (see Section 2) has an \"uploadUrl\" property in URI Template (level 1) format [RFC6570], which MUST contain a variable called \"accountId\". The client may use this template in combination with an \"accountId\" to get the URL of the file upload resource.",
      "ja": "使用目的に関係なく、アカウントのすべてのファイルアップロードを処理する単一のエンドポイントがあります。 Sessionオブジェクト（セクション2を参照）には、URIテンプレート（レベル1）形式の[uploadUrl]プロパティ[RFC6570]があり、「accountId」という変数を含まなければなりません。 クライアントは、このテンプレートを「accountId」と組み合わせて使用して、ファイルアップロードリソースのURLを取得できます。"
    },
    {
      "indent": 3,
      "text": "To upload a file, the client submits an authenticated POST request to the file upload resource.",
      "ja": "ファイルをアップロードするには、クライアントは認証されたPOSTリクエストをファイルアップロードリソースに送信します。"
    },
    {
      "indent": 3,
      "text": "A successful request MUST return a single JSON object with the following properties as the response:",
      "ja": "成功したリクエストは、応答として次のプロパティを持つ単一のJSONオブジェクトを返さなければなりません："
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account used for the call.",
      "ja": "呼び出しに使用されるアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o blobId: \"Id\"",
      "ja": "o blobId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id representing the binary data uploaded. The data for this id is immutable. The id *only* refers to the binary data, not any metadata.",
      "ja": "アップロードされたバイナリデータを表すID。 このIDのデータは不変です。 id * only *は、メタデータではなくバイナリデータを指します。"
    },
    {
      "indent": 3,
      "text": "o type: \"String\"",
      "ja": "o タイプ：「ストリング」"
    },
    {
      "indent": 6,
      "text": "The media type of the file (as specified in [RFC6838], Section 4.2) as set in the Content-Type header of the upload HTTP request.",
      "ja": "アップロードHTTPリクエストのContent-Typeヘッダーに設定されているファイルのメディアタイプ（[RFC6838]、セクション4.2で指定）。"
    },
    {
      "indent": 3,
      "text": "o size: \"UnsignedInt\"",
      "ja": "o サイズ：「UnsignedInt」"
    },
    {
      "indent": 6,
      "text": "The size of the file in octets.",
      "ja": "オクテット単位のファイルのサイズ。"
    },
    {
      "indent": 3,
      "text": "If identical binary content to an existing blob in the account is uploaded, the existing blobId MAY be returned.",
      "ja": "アカウント内の既存のblobと同じバイナリコンテンツがアップロードされた場合、既存のblobIdが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "Clients should use the blobId returned in a timely manner. Under rare circumstances, the server may have deleted the blob before the client uses it; the client should keep a reference to the local file so it can upload it again in such a situation.",
      "ja": "クライアントは、タイムリーに返されたblobIdを使用する必要があります。 まれに、クライアントが使用する前にサーバーがblobを削除した可能性があります。 クライアントはローカルファイルへの参照を保持して、そのような状況で再びアップロードできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "When an HTTP error response is returned to the client, the server SHOULD return a JSON \"problem details\" object as the response body, as per [RFC7807].",
      "ja": "HTTPエラー応答がクライアントに返されると、サーバーは[RFC7807]に従って、JSONの「問題の詳細」オブジェクトを応答本文として返す必要があります。"
    },
    {
      "indent": 3,
      "text": "As access controls are often determined by the object holding the reference to a blob, unreferenced blobs MUST only be accessible to the uploader, even in shared accounts.",
      "ja": "アクセス制御は多くの場合blobへの参照を保持するオブジェクトによって決定されるため、共有アカウントであっても、参照されていないblobにはアップローダーのみがアクセスできる必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Downloading Binary Data",
      "section_title": true,
      "ja": "6.2. バイナリデータのダウンロード"
    },
    {
      "indent": 3,
      "text": "The Session object (see Section 2) has a \"downloadUrl\" property, which is in URI Template (level 1) format [RFC6570]. The URL MUST contain variables called \"accountId\", \"blobId\", \"type\", and \"name\".",
      "ja": "Sessionオブジェクト（セクション2を参照）には、「downloadUrl」プロパティがあります。これは、URIテンプレート（レベル1）形式[RFC6570]です。 URLには、「accountId」、「blobId」、「type」、および「name」と呼ばれる変数を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "To download a file, the client makes an authenticated GET request to the download URL with the appropriate variables substituted in:",
      "ja": "ファイルをダウンロードするために、クライアントは、適切な変数を次のように置き換えて、ダウンロードURLに対して認証されたGETリクエストを作成します。"
    },
    {
      "indent": 3,
      "text": "o \"accountId\": The id of the account to which the record with the blobId belongs.",
      "ja": "o 「accountId」：blobIdを持つレコードが属するアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o \"blobId\": The blobId representing the data of the file to download.",
      "ja": "o 「blobId」：ダウンロードするファイルのデータを表すblobId。"
    },
    {
      "indent": 3,
      "text": "o \"type\": The type for the server to set in the \"Content-Type\" header of the response; the blobId only represents the binary data and does not have a content-type innately associated with it.",
      "ja": "o 「type」：応答の「Content-Type」ヘッダーに設定するサーバーのタイプ。 blobIdはバイナリデータのみを表し、コンテンツタイプが元々関連付けられていません。"
    },
    {
      "indent": 3,
      "text": "o \"name\": The name for the file; the server MUST return this as the filename if it sets a \"Content-Disposition\" header.",
      "ja": "o 「名前」：ファイルの名前。 サーバーは、「Content-Disposition」ヘッダーを設定する場合、これをファイル名として返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "As the data for a particular blobId is immutable, and thus the response in the generated download URL is too, implementors are recommended to set long cache times and use the \"immutable\" Cache-Control extension [RFC8246] for successful responses, for example, \"Cache-Control: private, immutable, max-age=31536000\".",
      "ja": "特定のblobIdのデータは不変であり、したがって生成されたダウンロードURLの応答も不変であるため、実装者は長いキャッシュ時間を設定し、成功した応答に対して「不変」のCache-Control拡張[RFC8246]を使用することをお勧めします、 「キャッシュ制御：プライベート、不変、max-age = 31536000」。"
    },
    {
      "indent": 3,
      "text": "When an HTTP error response is returned to the client, the server SHOULD return a JSON \"problem details\" object as the response body, as per [RFC7807].",
      "ja": "HTTPエラー応答がクライアントに返されると、サーバーは[RFC7807]に従って、JSONの「問題の詳細」オブジェクトを応答本文として返す必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Blob/copy",
      "section_title": true,
      "ja": "6.3. ブロブ/コピー"
    },
    {
      "indent": 3,
      "text": "Binary data may be copied *between* two different accounts using the \"Blob/copy\" method rather than having to download and then reupload on the client.",
      "ja": "バイナリデータは、クライアントでダウンロードしてから再アップロードするのではなく、「Blob / copy」メソッドを使用して2つの異なるアカウント間でコピーできます。"
    },
    {
      "indent": 3,
      "text": "The \"Blob/copy\" method takes the following arguments:",
      "ja": "「Blob / copy」メソッドは、次の引数を取ります。"
    },
    {
      "indent": 3,
      "text": "o fromAccountId: \"Id\"",
      "ja": "o fromAccountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to copy blobs from.",
      "ja": "BLOBのコピー元のアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account to copy blobs to.",
      "ja": "BLOBをコピーするアカウントのID。"
    },
    {
      "indent": 3,
      "text": "o blobIds: \"Id[]\"",
      "ja": "o blobIds： \"Id []\""
    },
    {
      "indent": 6,
      "text": "A list of ids of blobs to copy to the other account.",
      "ja": "他のアカウントにコピーするblobのIDのリスト。"
    },
    {
      "indent": 3,
      "text": "The response has the following arguments:",
      "ja": "応答には次の引数があります。"
    },
    {
      "indent": 3,
      "text": "o fromAccountId: \"Id\"",
      "ja": "o fromAccountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account blobs were copied from.",
      "ja": "アカウントBLOBのIDのコピー元。"
    },
    {
      "indent": 3,
      "text": "o accountId: \"Id\"",
      "ja": "o accountId： \"Id\""
    },
    {
      "indent": 6,
      "text": "The id of the account blobs were copied to.",
      "ja": "アカウントBLOBのIDがコピーされました。"
    },
    {
      "indent": 3,
      "text": "o copied: \"Id[Id]|null\"",
      "ja": "o コピー： \"Id [Id] | null\""
    },
    {
      "indent": 6,
      "text": "A map of the blobId in the fromAccount to the id for the blob in the account it was copied to, or null if none were successfully copied.",
      "ja": "fromAccount内のblobIdの、コピー先のアカウント内のblobのIDへのマップ。正常にコピーされなかった場合はnull。"
    },
    {
      "indent": 3,
      "text": "o notCopied: \"Id[SetError]|null\"",
      "ja": "o notCopied： \"Id [SetError] | null\""
    },
    {
      "indent": 6,
      "text": "A map of blobId to a SetError object for each blob that failed to be copied, or null if none.",
      "ja": "コピーに失敗した各blobのSetErrorオブジェクトへのblobIdのマップ。ない場合はnull。"
    },
    {
      "indent": 3,
      "text": "The SetError may be any of the standard set errors that may be returned for a create, as defined in Section 5.3. In addition, the \"notFound\" SetError error may be returned if the blobId to be copied cannot be found.",
      "ja": "SetErrorは、セクション5.3で定義されているように、作成のために返される可能性のある標準セットエラーのいずれかです。 さらに、コピーするblobIdが見つからない場合、「notFound」SetErrorエラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "The following additional method-level error may be returned instead of the \"Blob/copy\" response:",
      "ja": "「Blob / copy」応答の代わりに、以下の追加のメソッドレベルエラーが返される場合があります。"
    },
    {
      "indent": 3,
      "text": "\"fromAccountNotFound\": The \"fromAccountId\" included with the request does not correspond to a valid account.",
      "ja": "「fromAccountNotFound」：リクエストに含まれる「fromAccountId」が有効なアカウントに対応していません。"
    },
    {
      "indent": 0,
      "text": "7. Push",
      "section_title": true,
      "ja": "7. 押す"
    },
    {
      "indent": 3,
      "text": "Push notifications allow clients to efficiently update (almost) instantly to stay in sync with data changes on the server. The general model for push is simple and sends minimal data over the push channel: just enough for the client to know whether it needs to resync. The format allows multiple changes to be coalesced into a single push update and the frequency of pushes to be rate limited by the server. It doesn't matter if some push events are dropped before they reach the client; the next time it gets/sets any records of a changed type, it will discover the data has changed and still sync all changes.",
      "ja": "プッシュ通知を使用すると、クライアントは（ほぼ）即座に効率的に更新して、サーバー上のデータの変更と同期を保つことができます。 プッシュの一般的なモデルはシンプルで、最小限のデータをプッシュチャネル経由で送信します。クライアントが再同期する必要があるかどうかを知るのに十分です。 この形式では、複数の変更を1つのプッシュ更新に結合し、プッシュの頻度をサーバーによって制限することができます。 プッシュイベントがクライアントに到達する前にドロップされるかどうかは関係ありません。 次回、変更されたタイプのレコードを取得/設定すると、データが変更されたことを検出し、すべての変更を同期します。"
    },
    {
      "indent": 3,
      "text": "There are two different mechanisms by which a client can receive push notifications, to allow for the different environments in which a client may exist. An event source resource (see Section 7.3) allows clients that can hold transport connections open to receive push notifications directly from the JMAP server. This is simple and avoids third parties, but it is often not feasible on constrained platforms such as mobile devices. Alternatively, clients can make use of any push service supported by their environment. A URL for the push service is registered with the JMAP server (see Section 7.2); the server then POSTs each notification to that URL. The push service is then responsible for routing these to the client.",
      "ja": "クライアントがプッシュ通知を受信できる2つの異なるメカニズムがあり、クライアントが存在するさまざまな環境に対応できます。 イベントソースリソース（セクション7.3を参照）を使用すると、トランスポート接続を開いたままにできるクライアントが、JMAPサーバーから直接プッシュ通知を受信できます。 これは単純であり、サードパーティを回避しますが、モバイルデバイスなどの制約のあるプラットフォームでは実行できない場合がよくあります。 または、クライアントは、環境でサポートされているプッシュサービスを利用できます。 プッシュサービスのURLがJMAPサーバーに登録されます（セクション7.2を参照）。 サーバーは各通知をそのURLにPOSTします。 その後、プッシュサービスはこれらをクライアントにルーティングします。"
    },
    {
      "indent": 0,
      "text": "7.1. The StateChange Object",
      "section_title": true,
      "ja": "7.1. StateChangeオブジェクト"
    },
    {
      "indent": 3,
      "text": "When something changes on the server, the server pushes a StateChange object to the client. A *StateChange* object has the following properties:",
      "ja": "サーバー上で何かが変更されると、サーバーはStateChangeオブジェクトをクライアントにプッシュします。 * StateChange *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o @type: \"String\"",
      "ja": "o @type： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This MUST be the string \"StateChange\".",
      "ja": "これは文字列「StateChange」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o changed: \"Id[TypeState]\"",
      "ja": "o 変更：「Id [TypeState]」"
    },
    {
      "indent": 6,
      "text": "A map of an \"account id\" to an object encoding the state of data types that have changed for that account since the last StateChange object was pushed, for each of the accounts to which the user has access and for which something has changed.",
      "ja": "ユーザーがアクセス権を持ち、何かが変更されたアカウントごとに、最後のStateChangeオブジェクトがプッシュされてからそのアカウントに対して変更されたデータ型の状態をエンコードするオブジェクトへの「アカウントID」のマップ。"
    },
    {
      "indent": 6,
      "text": "A *TypeState* object is a map. The keys are the type name \"Foo\" (e.g., \"Mailbox\" or \"Email\"), and the value is the \"state\" property that would currently be returned by a call to \"Foo/get\".",
      "ja": "* TypeState *オブジェクトはマップです。 キーはタイプ名「Foo」（例：「Mailbox」または「Email」）で、値は「Foo / get」への呼び出しによって現在返される「state」プロパティです。"
    },
    {
      "indent": 6,
      "text": "The client can compare the new state strings with its current values to see whether it has the current data for these types. If not, the changes can then be efficiently fetched in a single standard API request (using the /changes type methods).",
      "ja": "クライアントは、新しい状態文字列を現在の値と比較して、これらのタイプの現在のデータがあるかどうかを確認できます。 そうでない場合、変更は単一の標準APIリクエストで効率的に取得できます（/ changesタイプメソッドを使用）。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Example",
      "section_title": true,
      "ja": "7.1.1. 例"
    },
    {
      "indent": 3,
      "text": "In this example, the server has amalgamated a few changes together across two different accounts the user has access to, before pushing the following StateChange object to the client:",
      "ja": "この例では、サーバーは、次のStateChangeオブジェクトをクライアントにプッシュする前に、ユーザーがアクセスできる2つの異なるアカウント間でいくつかの変更をまとめたものです。"
    },
    {
      "indent": 18,
      "text": "{\n  \"@type\": \"StateChange\",\n  \"changed\": {\n    \"a3123\": {\n      \"Email\": \"d35ecb040aab\",\n      \"EmailDelivery\": \"428d565f2440\",\n      \"CalendarEvent\": \"87accfac587a\"\n    },\n    \"a43461d\": {\n      \"Mailbox\": \"0af7a512ce70\",\n      \"CalendarEvent\": \"7a4297cecd76\"\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client can compare the state strings with its current state for the Email, CalendarEvent, etc., object types in the appropriate accounts to see if it needs to fetch changes.",
      "ja": "クライアントは、状態文字列を、Email、CalendarEventなど、適切なアカウントのオブジェクトタイプの現在の状態と比較して、変更を取得する必要があるかどうかを確認できます。"
    },
    {
      "indent": 3,
      "text": "If the client is itself making changes, it may receive a StateChange object while the /set API call is in flight. It can wait until the call completes and then compare if the new state string after the /set is the same as was pushed in the StateChange object; if so, and the old state of the /set response matches the client's previous state, it does not need to waste a request asking for changes it already knows.",
      "ja": "クライアント自体が変更を行っている場合、/ set API呼び出しの実行中にStateChangeオブジェクトを受け取る場合があります。 呼び出しが完了するまで待機してから、/ setの後の新しい状態文字列がStateChangeオブジェクトにプッシュされたものと同じかどうかを比較できます。 その場合、/ set応答の古い状態がクライアントの前の状態と一致する場合、既に知っている変更を要求する要求を無駄にする必要はありません。"
    },
    {
      "indent": 0,
      "text": "7.2. PushSubscription",
      "section_title": true,
      "ja": "7.2. PushSubscription"
    },
    {
      "indent": 3,
      "text": "Clients may create a PushSubscription to register a URL with the JMAP server. The JMAP server will then make an HTTP POST request to this URL for each push notification it wishes to send to the client.",
      "ja": "クライアントは、PushSubscriptionを作成してURLをJMAPサーバーに登録できます。 JMAPサーバーは、クライアントに送信するプッシュ通知ごとに、このURLにHTTP POSTリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "As a push subscription causes the JMAP server to make a number of requests to a previously unknown endpoint, it can be used as a vector for launching a denial-of-service attack. To prevent this, when a subscription is created, the JMAP server immediately sends a PushVerification object to that URL (see Section 7.2.2). The JMAP server MUST NOT make any further requests to the URL until the client receives the push and updates the subscription with the correct verification code.",
      "ja": "プッシュサブスクリプションにより、JMAPサーバーは以前に不明なエンドポイントに対して多数のリクエストを行うため、サービス拒否攻撃を仕掛けるためのベクトルとして使用できます。 これを防ぐために、サブスクリプションが作成されると、JMAPサーバーはすぐにPushVerificationオブジェクトをそのURLに送信します（セクション7.2.2を参照）。 JMAPサーバーは、クライアントがプッシュを受信し、正しい検証コードでサブスクリプションを更新するまで、URLにそれ以上リクエストをしてはなりません。"
    },
    {
      "indent": 3,
      "text": "A *PushSubscription* object has the following properties:",
      "ja": "* PushSubscription *オブジェクトには次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o id: \"Id\" (immutable; server-set)",
      "ja": "o id： \"Id\"（不変;サーバーセット）"
    },
    {
      "indent": 6,
      "text": "The id of the push subscription.",
      "ja": "プッシュサブスクリプションのID。"
    },
    {
      "indent": 3,
      "text": "o deviceClientId: \"String\" (immutable)",
      "ja": "o deviceClientId： \"String\"（不変）"
    },
    {
      "indent": 6,
      "text": "An id that uniquely identifies the client + device it is running on. The purpose of this is to allow clients to identify which PushSubscription objects they created even if they lose their local state, so they can revoke or update them. This string MUST be different on different devices and be different from apps from other vendors. It SHOULD be easy to regenerate and not depend on persisted state. It is RECOMMENDED to use a secure hash of a string that contains:",
      "ja": "実行中のクライアント+デバイスを一意に識別するID。 これの目的は、ローカル状態が失われた場合でも、クライアントが作成したPushSubscriptionオブジェクトを識別できるようにすることです。これにより、クライアントはそれらを取り消したり更新したりできます。 この文字列は、デバイスごとに異なり、他のベンダーのアプリとは異なる必要があります。 再生成が簡単で、永続化された状態に依存しないようにする必要があります。 以下を含む文字列の安全なハッシュを使用することを推奨します。"
    },
    {
      "indent": 6,
      "text": "1. A unique identifier associated with the device where the JMAP client is running, normally supplied by the device's operating system.",
      "ja": "1. JMAPクライアントが実行されているデバイスに関連付けられた一意の識別子。通常、デバイスのオペレーティングシステムによって提供されます。"
    },
    {
      "indent": 6,
      "text": "2. A custom vendor/app id, including a domain controlled by the vendor of the JMAP client.",
      "ja": "2. JMAPクライアントのベンダーが制御するドメインを含む、カスタムベンダー/アプリID。"
    },
    {
      "indent": 6,
      "text": "To protect the privacy of the user, the deviceClientId id MUST NOT contain an unobfuscated device id.",
      "ja": "ユーザーのプライバシーを保護するために、deviceClientId idには難読化されていないデバイスIDを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "o url: \"String\" (immutable)",
      "ja": "o url： \"String\"（不変）"
    },
    {
      "indent": 6,
      "text": "An absolute URL where the JMAP server will POST the data for the push message. This MUST begin with \"https://\".",
      "ja": "JMAPサーバーがプッシュメッセージのデータをPOSTする絶対URL。 これは「https：//」で始まる必要があります。"
    },
    {
      "indent": 3,
      "text": "o keys: \"Object|null\" (immutable)",
      "ja": "o キー： \"Object | null\"（不変）"
    },
    {
      "indent": 6,
      "text": "Client-generated encryption keys. If supplied, the server MUST use them as specified in [RFC8291] to encrypt all data sent to the push subscription. The object MUST have the following properties:",
      "ja": "クライアント生成の暗号化キー。 提供される場合、サーバーは[RFC8291]で指定されているようにそれらを使用して、プッシュサブスクリプションに送信されるすべてのデータを暗号化する必要があります。 オブジェクトには次のプロパティが必要です。"
    },
    {
      "indent": 6,
      "text": "* p256dh: \"String\"",
      "ja": "* p256dh：「ストリング」"
    },
    {
      "indent": 9,
      "text": "The P-256 Elliptic Curve Diffie-Hellman (ECDH) public key as described in [RFC8291], encoded in URL-safe base64 representation as defined in [RFC4648].",
      "ja": "[RFC4648]で定義されたURLセーフbase64表現でエンコードされた[RFC8291]で説明されているP-256楕円曲線ディフィーヘルマン（ECDH）公開鍵。"
    },
    {
      "indent": 6,
      "text": "* auth: \"String\"",
      "ja": "* auth： \"文字列\""
    },
    {
      "indent": 9,
      "text": "The authentication secret as described in [RFC8291], encoded in URL-safe base64 representation as defined in [RFC4648].",
      "ja": "[RFC4648]で定義されているURLセーフbase64表現でエンコードされた[RFC8291]で説明されている認証シークレット。"
    },
    {
      "indent": 3,
      "text": "o verificationCode: \"String|null\"",
      "ja": "o verifyCode： \"String | null\""
    },
    {
      "indent": 6,
      "text": "This MUST be null (or omitted) when the subscription is created. The JMAP server then generates a verification code and sends it in a push message, and the client updates the PushSubscription object with the code; see Section 7.2.2 for details.",
      "ja": "サブスクリプションが作成されるとき、これはnull（または省略）でなければなりません。 次に、JMAPサーバーは検証コードを生成してプッシュメッセージで送信し、クライアントはコードでPushSubscriptionオブジェクトを更新します。 詳細については、セクション7.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "o expires: \"UTCDate|null\"",
      "ja": "o 有効期限： \"UTCDate | null\""
    },
    {
      "indent": 6,
      "text": "The time this push subscription expires. If specified, the JMAP server MUST NOT make further requests to this resource after this time. It MAY automatically destroy the push subscription at or after this time.",
      "ja": "このプッシュサブスクリプションの有効期限。 指定されている場合、JMAPサーバーは、この時間後にこのリソースにさらにリクエストをしてはいけません。 この時点以降にプッシュサブスクリプションを自動的に破棄する場合があります。"
    },
    {
      "indent": 6,
      "text": "The server MAY choose to set an expiry if none is given by the client or modify the expiry time given by the client to a shorter duration.",
      "ja": "サーバーは、クライアントから何も指定されていない場合に有効期限を設定するか、クライアントから指定された有効期限をより短い期間に変更することを選択できます。"
    },
    {
      "indent": 3,
      "text": "o types: \"String[]|null\"",
      "ja": "o タイプ： \"String [] | null\""
    },
    {
      "indent": 6,
      "text": "A list of types the client is interested in (using the same names as the keys in the TypeState object defined in the previous section). A StateChange notification will only be sent if the data for one of these types changes. Other types are omitted from the TypeState object. If null, changes will be pushed for all types.",
      "ja": "クライアントが関心を持っている型のリスト（前のセクションで定義されたTypeStateオブジェクトのキーと同じ名前を使用）。 StateChange通知は、これらのタイプのいずれかのデータが変更された場合にのみ送信されます。 TypeStateオブジェクトから他のタイプは省略されます。 nullの場合、すべてのタイプに対して変更がプッシュされます。"
    },
    {
      "indent": 3,
      "text": "The POST request MUST have a content type of \"application/json\" and contain the UTF-8 JSON-encoded object as the body. The request MUST have a \"TTL\" header and MAY have \"Urgency\" and/or \"Topic\" headers, as specified in Section 5 of [RFC8030]. The JMAP server is expected to understand and handle HTTP status responses in a reasonable manner. A \"429\" (Too Many Requests) response MUST cause the JMAP server to reduce the frequency of pushes; the JMAP push structure allows multiple changes to be coalesced into a single minimal StateChange object. See the security considerations in Section 8.6 for a discussion of the risks in connecting to unknown servers.",
      "ja": "POSTリクエストのコンテンツタイプは「application / json」であり、本文としてUTF-8 JSONエンコードオブジェクトが含まれている必要があります。 [RFC8030]のSection 5で指定されているように、リクエストには「TTL」ヘッダーがなければならず、「緊急」および/または「トピック」ヘッダーが含まれている場合があります。 JMAPサーバーは、HTTPステータス応答を合理的な方法で理解して処理することが期待されています。 「429」（リクエストが多すぎる）応答により、JMAPサーバーはプッシュの頻度を減らす必要があります。 JMAPプッシュ構造により、複数の変更を1つの最小のStateChangeオブジェクトに結合できます。 不明なサーバーに接続する際のリスクについては、セクション8.6のセキュリティに関する考慮事項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The JMAP server acts as an application server as defined in [RFC8030]. A client MAY use the rest of [RFC8030] in combination with its own push service to form a complete end-to-end solution, or it MAY rely on alternative mechanisms to ensure the delivery of the pushed data after it leaves the JMAP server.",
      "ja": "JMAPサーバーは、[RFC8030]で定義されているアプリケーションサーバーとして機能します。 クライアントは、独自のプッシュサービスと組み合わせて[RFC8030]の残りを使用して完全なエンドツーエンドソリューションを形成できます。または、JMAPサーバーを離れた後のプッシュデータの配信を保証する代替メカニズムに依存する場合があります。"
    },
    {
      "indent": 3,
      "text": "The push subscription is tied to the credentials used to authenticate the API request that created it. Should these credentials expire or be revoked, the push subscription MUST be destroyed by the JMAP server. Only subscriptions created by these credentials are returned when the client fetches existing subscriptions.",
      "ja": "プッシュサブスクリプションは、それを作成したAPI要求の認証に使用される資格情報に関連付けられています。 これらの資格情報が期限切れになるか取り消された場合、プッシュサブスクリプションはJMAPサーバーによって破棄されなければなりません。 クライアントが既存のサブスクリプションを取得すると、これらの資格情報によって作成されたサブスクリプションのみが返されます。"
    },
    {
      "indent": 3,
      "text": "When these credentials have their own expiry (i.e., it is a session with a timeout), the server SHOULD NOT set or bound the expiry time for the push subscription given by the client but MUST expire it when the session expires.",
      "ja": "これらの資格情報に独自の有効期限がある場合（つまり、タイムアウトのあるセッション）、サーバーは、クライアントによって指定されたプッシュサブスクリプションの有効期限を設定またはバインドするべきではありませんが、セッションの有効期限が切れたときに期限を切れる必要があります。"
    },
    {
      "indent": 3,
      "text": "When these credentials are not time bounded (e.g., Basic authentication [RFC7617]), the server SHOULD set an expiry time for the push subscription if none is given and limit the expiry time if set too far in the future. This maximum expiry time MUST be at least 48 hours in the future and SHOULD be at least 7 days in the future. An app running on a mobile device may only be able to refresh the push subscription lifetime when it is in the foreground, so this gives a reasonable time frame to allow this to happen.",
      "ja": "これらの資格情報が時間制限されていない場合（たとえば、基本認証[RFC7617]）、サーバーは、プッシュサブスクリプションの有効期限を設定する必要があります（何も指定しない場合）。 この最大有効期限は、少なくとも48時間後でなければならず、少なくとも7日後でなければなりません。 モバイルデバイスで実行されているアプリは、フォアグラウンドにある場合にのみプッシュサブスクリプションの有効期間を更新できるため、これを実現するための妥当な時間枠が与えられます。"
    },
    {
      "indent": 3,
      "text": "In the case of separate access and refresh credentials, as in Oauth 2.0 [RFC6749], the server SHOULD tie the push subscription to the validity of the refresh token rather than the access token and behave according to whether this is time-limited or not.",
      "ja": "Oauth 2.0 [RFC6749]のように、アクセスとリフレッシュのクレデンシャルが別々の場合、サーバーはプッシュサブスクリプションをアクセストークンではなくリフレッシュトークンの有効性に結び付けて、これが時間制限があるかどうかに従って動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a push subscription is destroyed, the server MUST securely erase the URL and encryption keys from memory and storage as soon as possible.",
      "ja": "プッシュサブスクリプションが破棄されると、サーバーはできるだけ早くメモリとストレージからURLと暗号化キーを安全に消去する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.1. PushSubscription/get",
      "section_title": true,
      "ja": "7.2.1. PushSubscription / get"
    },
    {
      "indent": 3,
      "text": "Standard /get method as described in Section 5.1, except it does *not* take or return an \"accountId\" argument, as push subscriptions are not tied to specific accounts. It also does *not* return a \"state\" argument. The \"ids\" argument may be null to fetch all at once.",
      "ja": "プッシュサブスクリプションは特定のアカウントに関連付けられていないため、「accountId」引数を取得または返さないことを除いて、セクション5.1で説明されている標準の/ getメソッド。 また、「状態」引数を*返しません*。 「ids」引数は、一度にすべてを取得するためにnullにできます。"
    },
    {
      "indent": 3,
      "text": "The server MUST only return push subscriptions that were created using the same authentication credentials as for this \"PushSubscription/get\" request.",
      "ja": "サーバーは、この「PushSubscription / get」リクエストと同じ認証資格情報を使用して作成されたプッシュサブスクリプションのみを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "As the \"url\" and \"keys\" properties may contain data that is private to a particular device, the values for these properties MUST NOT be returned. If the \"properties\" argument is null or omitted, the server MUST default to all properties excluding these two. If one of them is explicitly requested, the method call MUST be rejected with a \"forbidden\" error.",
      "ja": "「url」および「keys」プロパティには特定のデバイス専用のデータが含まれている可能性があるため、これらのプロパティの値を返してはいけません。 「プロパティ」引数がnullまたは省略されている場合、サーバーはこれら2つを除くすべてのプロパティにデフォルト設定する必要があります。 それらのいずれかが明示的に要求された場合、メソッド呼び出しは「禁止」エラーで拒否されなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. PushSubscription/set",
      "section_title": true,
      "ja": "7.2.2. PushSubscription / set"
    },
    {
      "indent": 3,
      "text": "Standard /set method as described in Section 5.3, except it does *not* take or return an \"accountId\" argument, as push subscriptions are not tied to specific accounts. It also does *not* take an \"ifInState\" argument or return \"oldState\" or \"newState\" arguments.",
      "ja": "プッシュサブスクリプションは特定のアカウントに関連付けられていないため、「accountId」引数を取得または返さないことを除いて、セクション5.3で説明されている標準の/ setメソッド。 また、「ifInState」引数を取ることも「oldState」引数または「newState」引数を返すことも*しません*。"
    },
    {
      "indent": 3,
      "text": "The \"url\" and \"keys\" properties are immutable; if the client wishes to change these, it must destroy the current push subscription and create a new one.",
      "ja": "「url」および「keys」プロパティは不変です。 クライアントがこれらを変更したい場合、現在のプッシュサブスクリプションを破棄し、新しいサブスクリプションを作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a PushSubscription is created, the server MUST immediately push a *PushVerification* object to the URL. It has the following properties:",
      "ja": "PushSubscriptionが作成されると、サーバーはすぐに* PushVerification *オブジェクトをURLにプッシュする必要があります。 次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o @type: \"String\"",
      "ja": "o @type： \"文字列\""
    },
    {
      "indent": 6,
      "text": "This MUST be the string \"PushVerification\".",
      "ja": "これは文字列「PushVerification」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o pushSubscriptionId: \"String\"",
      "ja": "o pushSubscriptionId： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The id of the push subscription that was created.",
      "ja": "作成されたプッシュサブスクリプションのID。"
    },
    {
      "indent": 3,
      "text": "o verificationCode: \"String\"",
      "ja": "o validationCode： \"文字列\""
    },
    {
      "indent": 6,
      "text": "The verification code to add to the push subscription. This MUST contain sufficient entropy to avoid the client being able to guess the code via brute force.",
      "ja": "プッシュサブスクリプションに追加する確認コード。 これには、クライアントがブルートフォースを介してコードを推測できるのを回避するのに十分なエントロピーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MUST update the push subscription with the correct verification code before the server makes any further requests to the subscription's URL. Attempts to update the subscription with an invalid verification code MUST be rejected by the server with an \"invalidProperties\" SetError.",
      "ja": "クライアントは、サーバーがサブスクリプションのURLに対してさらに要求を行う前に、正しい検証コードでプッシュサブスクリプションを更新する必要があります。 無効な検証コードでサブスクリプションを更新しようとする試みは、「invalidProperties」SetErrorでサーバーによって拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client may update the \"expires\" property to extend (or, less commonly, shorten) the lifetime of a push subscription. The server MAY modify the proposed new expiry time to enforce server-defined limits. Extending the lifetime does not require the subscription to be verified again.",
      "ja": "クライアントは、「サブスクリプション」プロパティを更新して、プッシュサブスクリプションの有効期間を延長（または、あまり一般的ではないが短縮）することができます。 サーバーは、提案された新しい有効期限を変更して、サーバー定義の制限を実施することができます。 ライフタイムを延長しても、サブスクリプションを再度確認する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT update or destroy a push subscription that they did not create (i.e., has a \"deviceClientId\" that they do not recognise).",
      "ja": "クライアントは、作成しなかったプッシュサブスクリプションを更新または破棄しないでください（つまり、認識しない「deviceClientId」があります）。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Example",
      "section_title": true,
      "ja": "7.2.3. 例"
    },
    {
      "indent": 3,
      "text": "At \"2018-07-06T02:14:29Z\", a client with deviceClientId \"a889-ffea-910\" fetches the set of push subscriptions currently on the server, making an API request with:",
      "ja": "「2018-07-06T02：14：29Z」で、deviceClientIdが「a889-ffea-910」のクライアントは、現在サーバー上にあるプッシュサブスクリプションのセットをフェッチし、次のAPIリクエストを作成します。"
    },
    {
      "indent": 23,
      "text": "[[ \"PushSubscription/get\", { \"ids\": null }, \"0\" ]]",
      "ja": "[[\"PushSubscription / get\"、{\"ids\"：null}、 \"0\"]]"
    },
    {
      "indent": 3,
      "text": "Which returns:",
      "ja": "返されるもの："
    },
    {
      "indent": 7,
      "text": "[[ \"PushSubscription/get\", {\n  \"list\": [{\n      \"id\": \"e50b2c1d-9553-41a3-b0a7-a7d26b599ee1\",\n      \"deviceClientId\": \"b37ff8001ca0\",\n      \"verificationCode\": \"b210ef734fe5f439c1ca386421359f7b\",\n      \"expires\": \"2018-07-31T00:13:21Z\",\n      \"types\": [ \"Todo\" ]\n  }, {\n      \"id\": \"f2d0aab5-e976-4e8b-ad4b-b380a5b987e4\",\n      \"deviceClientId\": \"X8980fc\",\n      \"verificationCode\": \"f3d4618a9ae15c8b7f5582533786d531\",\n      \"expires\": \"2018-07-12T05:55:00Z\",\n      \"types\": [ \"Mailbox\", \"Email\", \"EmailDelivery\" ]\n  }],\n  \"notFound\": []\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Since neither of the returned push subscription objects have the client's deviceClientId, it knows it does not have a current push subscription active on the server. So it creates one, sending this request:",
      "ja": "返されたプッシュサブスクリプションオブジェクトはいずれもクライアントのdeviceClientIdを持たないため、サーバーでアクティブな現在のプッシュサブスクリプションがないことを認識しています。 そのため、このリクエストを送信して作成します："
    },
    {
      "indent": 0,
      "text": "[[ \"PushSubscription/set\", {\n  \"create\": {\n    \"4f29\": {\n      \"deviceClientId\": \"a889-ffea-910\",\n      \"url\": \"https://example.com/push/?device=X8980fc&client=12c6d086\",\n      \"types\": null\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server creates the push subscription but limits the expiry time to 7 days in the future, returning this response:",
      "ja": "サーバーはプッシュサブスクリプションを作成しますが、有効期限を将来の7日間に制限し、次の応答を返します。"
    },
    {
      "indent": 12,
      "text": "[[ \"PushSubscription/set\", {\n  \"created\": {\n    \"4f29\": {\n      \"id\": \"P43dcfa4-1dd4-41ef-9156-2c89b3b19c60\",\n      \"keys\": null,\n      \"expires\": \"2018-07-13T02:14:29Z\"\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server also immediately makes a POST request to \"https://example.com/push/?device=X8980fc&client=12c6d086\" with the data:",
      "ja": "サーバーは、データとともに「https://example.com/push/?device=X8980fc&client=12c6d086」に対してすぐにPOST要求を行います。"
    },
    {
      "indent": 6,
      "text": "{\n  \"@type\": \"PushVerification\",\n  \"pushSubscriptionId\": \"P43dcfa4-1dd4-41ef-9156-2c89b3b19c60\",\n  \"verificationCode\": \"da1f097b11ca17f06424e30bf02bfa67\"\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client receives this and updates the subscription with the verification code (note there is a potential race condition here; the client MUST be able to handle receiving the push while the request creating the subscription is still in progress):",
      "ja": "クライアントはこれを受信し、検証コードでサブスクリプションを更新します（潜在的な競合状態があることに注意してください。クライアントは、サブスクリプションを作成するリクエストが進行中にプッシュの受信を処理できる必要があります）。"
    },
    {
      "indent": 7,
      "text": "[[ \"PushSubscription/set\", {\n  \"update\": {\n    \"P43dcfa4-1dd4-41ef-9156-2c89b3b19c60\": {\n      \"verificationCode\": \"da1f097b11ca17f06424e30bf02bfa67\"\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server confirms the update was successful and will now make requests to the registered URL when the state changes.",
      "ja": "サーバーは更新が成功したことを確認し、状態が変化すると登録されたURLにリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "Two days later, the client updates the subscription to extend its lifetime, sending this request:",
      "ja": "2日後、クライアントはサブスクリプションを更新して有効期間を延長し、次のリクエストを送信します。"
    },
    {
      "indent": 15,
      "text": "[[ \"PushSubscription/set\", {\n  \"update\": {\n    \"P43dcfa4-1dd4-41ef-9156-2c89b3b19c60\": {\n      \"expires\": \"2018-08-13T00:00:00Z\"\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server extends the expiry time, but only again to its maximum limit of 7 days in the future, returning this response:",
      "ja": "サーバーは有効期限を延長しますが、今後も最大で7日間に制限し、次の応答を返します。"
    },
    {
      "indent": 15,
      "text": "[[ \"PushSubscription/set\", {\n  \"updated\": {\n    \"P43dcfa4-1dd4-41ef-9156-2c89b3b19c60\": {\n      \"expires\": \"2018-07-15T02:22:50Z\"\n    }\n  }\n}, \"0\" ]]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. Event Source",
      "section_title": true,
      "ja": "7.3. イベントソース"
    },
    {
      "indent": 3,
      "text": "Clients that can hold transport connections open can connect directly to the JMAP server to receive push notifications via a \"text/event-stream\" resource, as described in [EventSource]. This is a long running HTTP request, where the server can push data to the client by appending data without ending the response.",
      "ja": "[EventSource]で説明されているように、トランスポート接続を開いたままにできるクライアントは、JMAPサーバーに直接接続して、「text / event-stream」リソース経由でプッシュ通知を受信できます。 これは長時間実行されるHTTP要求であり、サーバーは応答を終了せずにデータを追加することにより、クライアントにデータをプッシュできます。"
    },
    {
      "indent": 3,
      "text": "When a change occurs in the data on the server, it pushes an event called \"state\" to any connected clients, with the StateChange object as the data.",
      "ja": "サーバー上のデータに変更が発生すると、StateChangeオブジェクトをデータとして、「state」というイベントを接続されたクライアントにプッシュします。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD also send a new event id that encodes the entire server state visible to the user immediately after sending a \"state\" event. When a new connection is made to the event-source endpoint, a client following the server-sent events specification will send a Last-Event-ID HTTP header field with the last id it saw, which the server can use to work out whether the client has missed some changes. If so, it SHOULD send these changes immediately on connection.",
      "ja": "サーバーは、「状態」イベントを送信した直後にユーザーに見えるサーバー状態全体をエンコードする新しいイベントIDも送信する必要があります。 イベントソースエンドポイントへの新しい接続が作成されると、サーバー送信イベント仕様に従うクライアントは、最後のIDを持つLast-Event-ID HTTPヘッダーフィールドを送信します。サーバーはこれを使用して、 クライアントはいくつかの変更を見逃しました。 その場合、これらの変更を接続時にすぐに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Session object (see Section 2) has an \"eventSourceUrl\" property, which is in URI Template (level 1) format [RFC6570]. The URL MUST contain variables called \"types\", \"closeafter\", and \"ping\".",
      "ja": "Sessionオブジェクト（セクション2を参照）には、「eventSourceUrl」プロパティがあります。これは、URIテンプレート（レベル1）形式[RFC6570]です。URLは、「種類」、「closeafter」、および「ピング」と呼ばれる変数を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "To connect to the resource, the client makes an authenticated GET request to the event-source URL with the appropriate variables substituted in:",
      "ja": "リソースに接続するために、クライアントは、適切な変数を次のように置き換えて、イベントソースURLに対して認証されたGET要求を作成します。"
    },
    {
      "indent": 3,
      "text": "o \"types\": This MUST be either:",
      "ja": "o 「タイプ」：これは次のいずれかでなければなりません："
    },
    {
      "indent": 6,
      "text": "* A comma-separated list of type names, e.g., \"Email,CalendarEvent\". The server MUST only push changes for the types in this list.",
      "ja": "* 型名のコンマ区切りリスト、たとえば「Email、CalendarEvent」。 サーバーは、このリスト内のタイプの変更のみをプッシュする必要があります。"
    },
    {
      "indent": 6,
      "text": "* The single character: \"*\". Changes to all types are pushed.",
      "ja": "* 単一の文字：「*」。 すべてのタイプへの変更がプッシュされます。"
    },
    {
      "indent": 3,
      "text": "o \"closeafter\": This MUST be one of the following values:",
      "ja": "o \"closeafter\"：これは次の値のいずれかでなければなりません："
    },
    {
      "indent": 6,
      "text": "* \"state\": The server MUST end the HTTP response after pushing a state event. This can be used by clients in environments where buffering proxies prevent the pushed data from arriving immediately, or indeed at all, when operating in the usual mode.",
      "ja": "* 「状態」：サーバーは、状態イベントをプッシュした後、HTTP応答を終了する必要があります。 これは、通常モードで動作しているときに、バッファリングプロキシがプッシュされたデータをすぐに、または実際にはまったく到着させない環境のクライアントで使用できます。"
    },
    {
      "indent": 6,
      "text": "* \"no\": The connection is persisted by the server as a standard event-source resource.",
      "ja": "* 「no」：接続は、標準のイベントソースリソースとしてサーバーによって永続化されます。"
    },
    {
      "indent": 3,
      "text": "o \"ping\": A positive integer value representing a length of time in seconds, e.g., \"300\". If non-zero, the server MUST send an event called \"ping\" whenever this time elapses since the previous event was sent. This MUST NOT set a new event id. If the value is \"0\", the server MUST NOT send ping events.",
      "ja": "o 「ping」：秒単位の時間の長さを表す正の整数値（「300」など）。 ゼロ以外の場合、サーバーは、前のイベントが送信されてからこの時間が経過するたびに「ping」というイベントを送信する必要があります。 これは、新しいイベントIDを設定してはなりません。 値が「0」の場合、サーバーはpingイベントを送信してはなりません。"
    },
    {
      "indent": 6,
      "text": "The server MAY modify a requested ping interval to be subject to a minimum and/or maximum value. For interoperability, servers MUST NOT have a minimum allowed value higher than 30 or a maximum allowed value less than 300.",
      "ja": "サーバーは、要求されたping間隔を変更して、最小値または最大値、あるいはその両方を適用できます。 相互運用性のために、サーバーは30を超える最小許容値または300未満の最大許容値を持つことはできません。"
    },
    {
      "indent": 6,
      "text": "The data for the ping event MUST be a JSON object containing an \"interval\" property, the value (type \"UnsignedInt\") being the interval in seconds the server is using to send pings (this may be different to the requested value if the server clamped it to be within a min/max value).",
      "ja": "pingイベントのデータは、「interval」プロパティを含むJSONオブジェクトである必要があります。値（タイプ「UnsignedInt」）は、サーバーがpingを送信するために使用する秒単位の間隔です（サーバーが要求する値と異なる場合があります） 最小/最大値内に収まるようにクランプしました）。"
    },
    {
      "indent": 6,
      "text": "Clients can monitor for the ping event to help determine when the closeafter mode may be required.",
      "ja": "クライアントは、pingイベントを監視して、closeafterモードがいつ必要になるかを判断できます。"
    },
    {
      "indent": 3,
      "text": "A client MAY hold open multiple connections to the event-source resource, although it SHOULD try to use a single connection for efficiency.",
      "ja": "クライアントは、イベントソースリソースへの複数の接続を開いたままにすることができますが、効率のために単一の接続の使用を試みる必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Transport Confidentiality",
      "section_title": true,
      "ja": "8.1. 輸送の機密性"
    },
    {
      "indent": 3,
      "text": "To ensure the confidentiality and integrity of data sent and received via JMAP, all requests MUST use TLS 1.2 [RFC5246] [RFC8446] or later, following the recommendations in [RFC7525]. Servers SHOULD support TLS 1.3 [RFC8446] or later.",
      "ja": "JMAPを介して送受信されるデータの機密性と整合性を確保するために、すべての要求は[RFC7525]の推奨事項に従って、TLS 1.2 [RFC5246] [RFC8446]以降を使用する必要があります。 サーバーはTLS 1.3 [RFC8446]以降をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients MUST validate TLS certificate chains to protect against man-in-the-middle attacks [RFC5280].",
      "ja": "クライアントは、中間者攻撃[RFC5280]から保護するために、TLS証明書チェーンを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Authentication Scheme",
      "section_title": true,
      "ja": "8.2. 認証スキーム"
    },
    {
      "indent": 3,
      "text": "A number of HTTP authentication schemes have been standardised (see <https://www.iana.org/assignments/http-authschemes/>). Servers should take care to assess the security characteristics of different schemes in relation to their needs when deciding what to implement.",
      "ja": "多くのHTTP認証スキームが標準化されました（<https://www.iana.org/assignments/http-authschemes/>を参照）。 サーバーは、何を実装するかを決定するときに、ニーズに関連してさまざまなスキームのセキュリティ特性を評価するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of the Basic authentication scheme is NOT RECOMMENDED. Services that choose to use it are strongly recommended to require generation of a unique \"app password\" via some external mechanism for each client they wish to connect. This allows connections from different devices to be differentiated by the server and access to be individually revoked.",
      "ja": "基本認証スキームの使用は推奨されません。 それを使用することを選択するサービスは、接続したいクライアントごとに何らかの外部メカニズムを介して一意の「アプリパスワード」の生成を要求することを強くお勧めします。 これにより、さまざまなデバイスからの接続をサーバーで区別し、アクセスを個別に取り消すことができます。"
    },
    {
      "indent": 0,
      "text": "8.3. Service Autodiscovery",
      "section_title": true,
      "ja": "8.3. サービスの自動検出"
    },
    {
      "indent": 3,
      "text": "Unless secured by something like DNSSEC, autodiscovery of server details using SRV DNS records is vulnerable to a DNS poisoning attack, which can lead to the client talking to an attacker's server instead of the real JMAP server. The attacker may then intercept requests to execute man-in-the-middle attacks and, depending on the authentication scheme, steal credentials to generate its own requests.",
      "ja": "DNSSECのようなもので保護されていない限り、SRV DNSレコードを使用したサーバーの詳細の自動検出はDNSポイズニング攻撃に対して脆弱です。 その後、攻撃者はリクエストをインターセプトして中間者攻撃を実行し、認証スキームに応じて資格情報を盗み、独自のリクエストを生成します。"
    },
    {
      "indent": 3,
      "text": "Clients that do not support SRV lookups are likely to try just using the \"/.well-known/jmap\" path directly against the domain of the username over HTTPS. Servers SHOULD ensure this path resolves or redirects to the correct JMAP Session resource to allow this to work. If this is not feasible, servers MUST ensure this path cannot be controlled by an attacker, as again it may be used to steal credentials.",
      "ja": "SRVルックアップをサポートしないクライアントは、HTTPS経由でユーザー名のドメインに対して「/.well-known/jmap」パスを直接使用することを試みる可能性があります。 サーバーは、これが機能するように、このパスが正しいJMAPセッションリソースを解決またはリダイレクトすることを確認する必要があります。 これが実行可能でない場合、サーバーは資格情報を盗むために再び使用される可能性があるため、攻撃者がこのパスを制御できないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4. JSON Parsing",
      "section_title": true,
      "ja": "8.4. JSON解析"
    },
    {
      "indent": 3,
      "text": "The Security Considerations of [RFC8259] apply to the use of JSON as the data interchange format.",
      "ja": "[RFC8259]のセキュリティに関する考慮事項は、データ交換形式としてのJSONの使用に適用されます。"
    },
    {
      "indent": 3,
      "text": "As for any serialization format, parsers need to thoroughly check the syntax of the supplied data. JSON uses opening and closing tags for several types and structures, and it is possible that the end of the supplied data will be reached when scanning for a matching closing tag; this is an error condition, and implementations need to stop scanning at the end of the supplied data.",
      "ja": "シリアル化形式については、パーサーは提供されたデータの構文を徹底的にチェックする必要があります。 JSONはいくつかのタイプと構造に開始タグと終了タグを使用します。一致する終了タグをスキャンすると、提供されたデータの最後に到達する可能性があります。 これはエラー状態であり、実装は提供されたデータの終わりでスキャンを停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "JSON also uses a string encoding with some escape sequences to encode special characters within a string. Care is needed when processing these escape sequences to ensure that they are fully formed before the special processing is triggered, with special care taken when the escape sequences appear adjacent to other (non-escaped) special characters or adjacent to the end of data (as in the previous paragraph).",
      "ja": "JSONは、文字列内の特殊文字をエンコードするために、いくつかのエスケープシーケンスを含む文字列エンコードも使用します。 これらのエスケープシーケンスを処理するときは、特別な処理がトリガーされる前に完全に形成されるように注意する必要があります。エスケープシーケンスが他の（エスケープされていない）特殊文字またはデータの終わりに隣接する場合（ 前の段落で）。"
    },
    {
      "indent": 3,
      "text": "If parsing JSON into a non-textual structured data format, implementations may need to allocate storage to hold JSON string elements. Since JSON does not use explicit string lengths, the risk of denial of service due to resource exhaustion is small, but implementations may still wish to place limits on the size of allocations they are willing to make in any given context, to avoid untrusted data causing excessive memory allocation.",
      "ja": "JSONを非テキスト構造化データ形式に解析する場合、実装はJSON文字列要素を保持するためにストレージを割り当てる必要がある場合があります。 JSONは文字列の長さを明示的に使用しないため、リソースの枯渇によるサービス拒否のリスクは小さいですが、実装は、信頼されていないデータの原因となることを避けるために、特定のコンテキストで行う割り当てのサイズに制限を置くことを依然として望む場合があります 過剰なメモリ割り当て。"
    },
    {
      "indent": 0,
      "text": "8.5. Denial of Service",
      "section_title": true,
      "ja": "8.5. サービス拒否"
    },
    {
      "indent": 3,
      "text": "A small request may result in a very large response and require considerable work on the server if resource limits are not enforced. JMAP provides mechanisms for advertising and enforcing a wide variety of limits for mitigating this threat, including limits on the number of objects fetched in a single method call, number of methods in a single request, number of concurrent requests, etc.",
      "ja": "リクエストが小さいと、レスポンスが非常に大きくなり、リソースの制限が適用されない場合、サーバーでかなりの作業が必要になる場合があります。 JMAPは、この脅威を緩和するために、1つのメソッド呼び出しでフェッチされるオブジェクトの数、1つのリクエストのメソッドの数、同時リクエストの数などのさまざまな制限を広告および実施するメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "JMAP servers MUST implement sensible limits to mitigate against resource exhaustion attacks.",
      "ja": "JMAPサーバーは、リソース枯渇攻撃を緩和するために、適切な制限を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.6. Connection to Unknown Push Server",
      "section_title": true,
      "ja": "8.6. 不明なプッシュサーバーへの接続"
    },
    {
      "indent": 3,
      "text": "When a push subscription is registered, the application server will make POST requests to the given URL. There are a number of security considerations that MUST be considered when implementing this.",
      "ja": "プッシュサブスクリプションが登録されると、アプリケーションサーバーは指定されたURLに対してPOST要求を行います。 これを実装するときに考慮しなければならないセキュリティの考慮事項がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "The server MUST ensure the URL is externally resolvable to avoid server-side request forgery, where the server makes a request to a resource on its internal network.",
      "ja": "サーバーは、サーバーが内部ネットワーク上のリソースへのリクエストを行うサーバー側のリクエスト偽造を回避するために、URLが外部的に解決可能であることを保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A malicious client may use the push subscription to attempt to flood a third party server with requests, creating a denial-of-service attack and masking the attacker's true identity. There is no guarantee that the URL given to the JMAP server is actually a valid push server. Upon creation of a push subscription, the JMAP server sends a PushVerification object to the URL and MUST NOT send any further requests until the client verifies it has received the initial push. The verification code MUST contain sufficient entropy to prevent the client from being able to verify the subscription via brute force.",
      "ja": "悪意のあるクライアントは、プッシュサブスクリプションを使用して、サードパーティのサーバーにリクエストを殺到させ、サービス拒否攻撃を仕掛け、攻撃者の本当の身元を隠す可能性があります。 JMAPサーバーに指定されたURLが実際に有効なプッシュサーバーであるという保証はありません。 プッシュサブスクリプションの作成時に、JMAPサーバーはPushVerificationオブジェクトをURLに送信し、クライアントが最初のプッシュを受信したことを確認するまで、それ以上の要求を送信してはなりません。 検証コードには、クライアントがブルートフォースを介してサブスクリプションを検証できないようにするのに十分なエントロピーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The verification code does not guarantee the URL is a valid push server, only that the client is able to access the data submitted to it. While the verification step significantly reduces the set of potential targets, there is still a risk that the server is unrelated to the client and being targeted for a denial-of-service attack.",
      "ja": "検証コードは、URLが有効なプッシュサーバーであることを保証するものではなく、クライアントが送信されたデータにアクセスできることのみを保証します。 検証手順によって潜在的なターゲットのセットが大幅に削減されますが、サーバーがクライアントと無関係であり、サービス拒否攻撃の標的にされるリスクが依然としてあります。"
    },
    {
      "indent": 3,
      "text": "The server MUST limit the number of push subscriptions any one user may have to ensure the user cannot cause the server to send a large number of push notifications at once, which could again be used as part of a denial-of-service attack. The rate of creation MUST also be limited to minimise the ability to abuse the verification request as an attack vector.",
      "ja": "サーバーは、サービス拒否攻撃の一部として再び使用される可能性がある、ユーザーが一度に大量のプッシュ通知をサーバーに送信させないようにするために、1人のユーザーが持つことができるプッシュサブスクリプションの数を制限する必要があります。 検証のリクエストを攻撃ベクトルとして悪用する可能性を最小限に抑えるために、作成率も制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.7. Push Encryption",
      "section_title": true,
      "ja": "8.7. プッシュ暗号化"
    },
    {
      "indent": 3,
      "text": "When data changes, a small object is pushed with the new state strings for the types that have changed. While the data here is minimal, a passive man-in-the-middle attacker may be able to gain useful information. To ensure confidentiality and integrity, if the push is sent via a third party outside of the control of the client and JMAP server, the client MUST specify encryption keys when establishing the PushSubscription and ignore any push notification received that is not encrypted with those keys.",
      "ja": "データが変更されると、変更された型の新しい状態文字列で小さなオブジェクトがプッシュされます。 ここでのデータは最小限ですが、受動的な中間者攻撃者は有用な情報を取得できる可能性があります。 機密性と整合性を確保するために、プッシュがクライアントとJMAPサーバーの制御外にあるサードパーティを介して送信される場合、クライアントはPushSubscriptionを確立するときに暗号化キーを指定し、それらのキーで暗号化されていないプッシュ通知を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The privacy and security considerations of [RFC8030] and [RFC8291] also apply to the use of the PushSubscription mechanism.",
      "ja": "[RFC8030]と[RFC8291]のプライバシーとセキュリティの考慮事項は、PushSubscriptionメカニズムの使用にも適用されます。"
    },
    {
      "indent": 3,
      "text": "As there is no crypto algorithm agility in Web Push Encryption [RFC8291], a new specification will be needed to provide this if new algorithms are required in the future.",
      "ja": "Webプッシュ暗号化[RFC8291]には暗号アルゴリズムの俊敏性がないため、将来新しいアルゴリズムが必要になった場合、これを提供するには新しい仕様が必要になります。"
    },
    {
      "indent": 0,
      "text": "8.8. Traffic Analysis",
      "section_title": true,
      "ja": "8.8. トラフィック分析"
    },
    {
      "indent": 3,
      "text": "While the data is encrypted, a passive observer with the ability to monitor network traffic may be able to glean information from the timing of API requests and push notifications. For example, suppose an email or calendar invitation is sent from User A (hosted on Server X) to User B (hosted on Server Y). If Server X hosts data for many users, a passive observer can see that the two servers connected but does not know who the data was for. However, if a push notification is immediately sent to User B and the attacker can observe this as well, they may reasonably conclude that someone on Server X is connecting to User B.",
      "ja": "データが暗号化されている間、ネットワークトラフィックを監視する機能を持つ受動的なオブザーバーは、APIリクエストとプッシュ通知のタイミングから情報を収集できる場合があります。 たとえば、電子メールまたはカレンダーの招待状がユーザーA（サーバーXでホスト）からユーザーB（サーバーYでホスト）に送信されたとします。 サーバーXが多くのユーザーのデータをホストしている場合、パッシブオブザーバーは、2つのサーバーが接続されていることを確認できますが、データの送信元はわかりません。 ただし、プッシュ通知がすぐにユーザーBに送信され、攻撃者もこれを観察できる場合、サーバーXの誰かがユーザーBに接続していると合理的に結論付けることができます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. Assignment of jmap Service Name",
      "section_title": true,
      "ja": "9.1. jmapサービス名の割り当て"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the 'jmap' service name in the \"Service Name and Transport Protocol Port Number Registry\" [RFC6335].",
      "ja": "IANAは、「サービス名とトランスポートプロトコルポート番号レジストリ」[RFC6335]で「jmap」サービス名を割り当てています。"
    },
    {
      "indent": 3,
      "text": "Service Name: jmap",
      "ja": "サービス名：jmap"
    },
    {
      "indent": 3,
      "text": "Transport Protocol(s): tcp",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Assignee: IESG",
      "ja": "担当者：IESG"
    },
    {
      "indent": 3,
      "text": "Contact: IETF Chair",
      "ja": "連絡先：IETF Chair"
    },
    {
      "indent": 3,
      "text": "Description: JSON Meta Application Protocol",
      "ja": "説明：JSONメタアプリケーションプロトコル"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 8620",
      "ja": "参照：RFC 8620"
    },
    {
      "indent": 3,
      "text": "Assignment Notes: This service name was previously assigned under the name \"JSON Mail Access Protocol\". This has been de-assigned and re-assigned with the approval of the previous assignee.",
      "ja": "割り当てに関する注意：このサービス名は、以前は「JSON Mail Access Protocol」という名前で割り当てられていました。 これは、以前の譲受人の承認を得て、割り当て解除および再割り当てされました。"
    },
    {
      "indent": 0,
      "text": "9.2. Registration of Well-Known URI Suffix for JMAP",
      "section_title": true,
      "ja": "9.2. JMAPの既知のURIサフィックスの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following suffix in the \"Well-Known URIs\" registry for JMAP, as described in [RFC8615]:",
      "ja": "[RFC8615]で説明されているように、IANAはJMAPの「Well-Known URIs」レジストリに次のサフィックスを登録しました。"
    },
    {
      "indent": 3,
      "text": "URI Suffix: jmap",
      "ja": "URIサフィックス：jmap"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "コントローラーの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Specification Document: RFC 8620, Section 2.2.",
      "ja": "仕様書：RFC 8620、セクション2.2。"
    },
    {
      "indent": 0,
      "text": "9.3. Registration of the jmap URN Sub-namespace",
      "section_title": true,
      "ja": "9.3. jmap URNサブ名前空間の登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following URN sub-namespace in the \"IETF URN Sub-namespace for Registered Protocol Parameter Identifiers\" registry within the \"Uniform Resource Name (URN) Namespace for IETF Use\" registry as described in [RFC3553].",
      "ja": "[RFC3553]で説明されているように、IANAは「IETF使用のための均一リソース名（URN）名前空間」レジストリ内の「登録済みプロトコルパラメータ識別子のIETF URNサブ名前空間」レジストリに次のURNサブ名前空間を登録しました。"
    },
    {
      "indent": 3,
      "text": "Registered Parameter Identifier: jmap",
      "ja": "登録済みパラメーター識別子：jmap"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 8620, Section 9.4",
      "ja": "参照：RFC 8620、セクション9.4"
    },
    {
      "indent": 3,
      "text": "IANA Registry Reference: http://www.iana.org/assignments/jmap",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.4. Creation of \"JMAP Capabilities\" Registry",
      "section_title": true,
      "ja": "9.4. 「JMAP Capabilities」レジストリの作成"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"JMAP Capabilities\" registry as described in Section 2. JMAP capabilities are advertised in the \"capabilities\" property of the JMAP Session resource. They are used to extend the functionality of a JMAP server. A capability is referenced by a URI. The JMAP capability URI can be a URN starting with \"urn:ietf:params:jmap:\" plus a unique suffix that is the index value in the jmap URN sub-namespace. Registration of a JMAP capability with another form of URI has no impact on the jmap URN sub-namespace.",
      "ja": "IANAは、セクション2で説明されている「JMAP Capabilities」レジストリを作成しました。JMAP機能は、JMAP Sessionリソースの「capabilities」プロパティでアドバタイズされます。 これらは、JMAPサーバーの機能を拡張するために使用されます。 機能はURIによって参照されます。 JMAP機能URIは、「urn：ietf：params：jmap：」で始まるURNに加えて、jmap URNサブ名前空間のインデックス値である一意のサフィックスを使用できます。 別の形式のURIでJMAP機能を登録しても、jmap URNサブ名前空間には影響しません。"
    },
    {
      "indent": 3,
      "text": "This registry follows the expert review process unless the \"intended use\" field is \"common\" or \"placeholder\", in which case registration follows the specification required process.",
      "ja": "このレジストリは、「使用目的」フィールドが「共通」または「プレースホルダー」である場合を除き、専門家のレビュープロセスに従います。この場合、登録は仕様に必要なプロセスに従います。"
    },
    {
      "indent": 3,
      "text": "A JMAP capability registration can have an intended use of \"common\", \"placeholder\", \"limited\", or \"obsolete\". IANA will list common-use registrations prominently and separately from those with other intended use values.",
      "ja": "JMAP機能の登録には、「共通」、「プレースホルダー」、「制限」、または「廃止」の使用目的があります。 IANAは、他の使用目的の値を持つものとは別に、よく使用される登録を一覧表示します。"
    },
    {
      "indent": 3,
      "text": "The JMAP capability registration procedure is not a formal standards process but rather an administrative procedure intended to allow community comment and sanity checking without excessive time delay.",
      "ja": "JMAP機能の登録手順は、正式な標準プロセスではなく、過度の時間遅延なしにコミュニティのコメントと健全性チェックを許可することを目的とした管理手順です。"
    },
    {
      "indent": 3,
      "text": "A \"placeholder\" registration reserves part of the jmap URN namespace for another purpose but is typically not included in the \"capabilities\" property of the JMAP Session resource.",
      "ja": "「プレースホルダ」登録は、別の目的のためにjmap URN名前空間の一部を予約しますが、通常、JMAPセッションリソースの「機能」プロパティには含まれません。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Preliminary Community Review",
      "section_title": true,
      "ja": "9.4.1. 予備的なコミュニティレビュー"
    },
    {
      "indent": 3,
      "text": "Notice of a potential JMAP common-use registration SHOULD be sent to the JMAP mailing list <jmap@ietf.org> for review. This mailing list is appropriate to solicit community feedback on a proposed JMAP capability. Registrations that are not intended for common use MAY be sent to the list for review as well; doing so is entirely OPTIONAL, but is encouraged.",
      "ja": "潜在的なJMAP共通登録の通知は、レビューのためにJMAPメーリングリスト<jmap@ietf.org>に送信する必要があります。 このメーリングリストは、提案されているJMAP機能に関するコミュニティのフィードバックを求めるのに適しています。 一般的な使用を意図していない登録も、レビューのためにリストに送信できます。 そうすることは完全に任意ですが、推奨されます。"
    },
    {
      "indent": 3,
      "text": "The intent of the public posting to this list is to solicit comments and feedback on the choice of the capability name, the unambiguity of the specification document, and a review of any interoperability or security considerations. The submitter may submit a revised registration proposal or abandon the registration completely at any time.",
      "ja": "このリストへの公開投稿の目的は、機能名の選択、仕様文書の曖昧さ、および相互運用性またはセキュリティに関する考慮事項のレビューに関するコメントとフィードバックを募ることです。 提出者は、いつでも修正された登録提案書を提出するか、登録を完全に放棄することができます。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Submit Request to IANA",
      "section_title": true,
      "ja": "9.4.2. IANAにリクエストを送信"
    },
    {
      "indent": 3,
      "text": "Registration requests can be sent to <iana@iana.org>.",
      "ja": "登録リクエストは<iana@iana.org>に送信できます。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Designated Expert Review",
      "section_title": true,
      "ja": "9.4.3. 指定エキスパートレビュー"
    },
    {
      "indent": 3,
      "text": "For a limited-use registration, the primary concern of the designated expert (DE) is preventing name collisions and encouraging the submitter to document security and privacy considerations; a published specification is not required. For a common-use registration, the DE is expected to confirm that suitable documentation, as described in Section 4.6 of [RFC8126], is available. The DE should also verify that the capability does not conflict with work that is active or already published within the IETF.",
      "ja": "使用制限付き登録の場合、指定された専門家（DE）の主な関心事は、名前の衝突を防止し、提出者にセキュリティとプライバシーの考慮事項を文書化するよう促すことです。 公開された仕様は必要ありません。 共同利用登録については、[RFC8126]のセクション4.6に記載されている適切な文書が利用可能であることをDEが確認することが期待されます。 また、DEは、機能がIETF内でアクティブまたは既に公開されている作業と競合しないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Before a period of 30 days has passed, the DE will either approve or deny the registration request and publish a notice of the decision to the JMAP WG mailing list or its successor, as well as inform IANA. A denial notice must be justified by an explanation, and, in the cases where it is possible, concrete suggestions on how the request can be modified so as to become acceptable should be provided.",
      "ja": "30日が経過する前に、DEは登録要求を承認または拒否し、決定の通知をJMAP WGメーリングリストまたはその後継者に公開するとともに、IANAに通知します。 拒否通知は説明によって正当化される必要があり、可能な場合は、要求を受け入れ可能になるように変更する方法に関する具体的な提案を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the DE does not respond within 30 days, the registrant may request the IESG take action to process the request in a timely manner.",
      "ja": "DEが30日以内に応答しない場合、登録者はIESGに要求をタイムリーに処理するためのアクションを実行するように要求できます。"
    },
    {
      "indent": 0,
      "text": "9.4.4. Change Procedures",
      "section_title": true,
      "ja": "9.4.4. 変更手順"
    },
    {
      "indent": 3,
      "text": "Once a JMAP capability has been published by the IANA, the change controller may request a change to its definition. The same procedure that would be appropriate for the original registration request is used to process a change request.",
      "ja": "JMAP機能がIANAによって公開されると、変更コントローラーはその定義の変更を要求できます。 元の登録要求に適しているのと同じ手順を使用して、変更要求を処理します。"
    },
    {
      "indent": 3,
      "text": "JMAP capability registrations may not be deleted; capabilities that are no longer believed appropriate for use can be declared obsolete by a change to their \"intended use\" field; such capabilities will be clearly marked in the lists published by the IANA.",
      "ja": "JMAP機能の登録は削除できません。 使用に適さないと思われる機能は、「意図された使用」フィールドを変更することで廃止と宣言できます。 そのような機能は、IANAが公開するリストで明確にマークされます。"
    },
    {
      "indent": 3,
      "text": "Significant changes to a capability's definition should be requested only when there are serious omissions or errors in the published specification. When review is required, a change request may be denied if it renders entities that were valid under the previous definition invalid under the new definition.",
      "ja": "公開された仕様に重大な欠落や誤りがある場合にのみ、機能の定義の大幅な変更を要求する必要があります。 レビューが必要な場合、以前の定義で有効だったエンティティを新しい定義で無効にすると、変更要求が拒否される場合があります。"
    },
    {
      "indent": 3,
      "text": "The owner of a JMAP capability may pass responsibility to another person or agency by informing the IANA; this can be done without discussion or review.",
      "ja": "JMAP機能の所有者は、IANAに通知することにより、責任を別の個人または代理店に渡すことができます。 これは、ディスカッションやレビューなしで実行できます。"
    },
    {
      "indent": 3,
      "text": "The IESG may reassign responsibility for a JMAP capability. The most common case of this will be to enable changes to be made to capabilities where the author of the registration has died, moved out of contact, or is otherwise unable to make changes that are important to the community.",
      "ja": "IESGは、JMAP機能の責任を再割り当てする場合があります。 これの最も一般的なケースは、登録の作成者が死亡したか、連絡が取れなくなった、またはコミュニティにとって重要な変更を加えることができない機能に変更を加えることです。"
    },
    {
      "indent": 0,
      "text": "9.4.5. JMAP Capabilities Registry Template",
      "section_title": true,
      "ja": "9.4.5. JMAP機能レジストリテンプレート"
    },
    {
      "indent": 3,
      "text": "Capability name: (see capability property in Section 2)",
      "ja": "機能名：（セクション2の機能プロパティを参照）"
    },
    {
      "indent": 3,
      "text": "Specification document:",
      "ja": "仕様書："
    },
    {
      "indent": 3,
      "text": "Intended use: (one of common, limited, placeholder, or obsolete)",
      "ja": "使用目的：（共通、限定、プレースホルダー、または廃止のいずれか）"
    },
    {
      "indent": 3,
      "text": "Change controller: (\"IETF\" for Standards Track / BCP RFCs)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Security and privacy considerations:",
      "ja": "セキュリティとプライバシーに関する考慮事項："
    },
    {
      "indent": 0,
      "text": "9.4.6. Initial Registration for JMAP Core",
      "section_title": true,
      "ja": "9.4.6. JMAP Coreの初期登録"
    },
    {
      "indent": 3,
      "text": "Capability Name: \"urn:ietf:params:jmap:core\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Specification document: RFC 8620, Section 2",
      "ja": "仕様書：RFC 8620、セクション2"
    },
    {
      "indent": 3,
      "text": "Intended use: common",
      "ja": "使用目的：一般的な"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "コントローラーの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Security and privacy considerations: RFC 8620, Section 8.",
      "ja": "セキュリティとプライバシーの考慮事項：RFC 8620、セクション8。"
    },
    {
      "indent": 0,
      "text": "9.4.7. Registration for JMAP Error Placeholder in JMAP Capabilities Registry",
      "ja": "9.4.7. JMAP機能レジストリへのJMAPエラープレースホルダーの登録"
    },
    {
      "indent": 3,
      "text": "Capability Name: \"urn:ietf:params:jmap:error:\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Specification document: RFC 8620, Section 9.5",
      "ja": "仕様書：RFC 8620、セクション9.5"
    },
    {
      "indent": 3,
      "text": "Intended use: placeholder",
      "ja": "使用目的：プレースホルダー"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "コントローラーの変更：IETF"
    },
    {
      "indent": 3,
      "text": "Security and privacy considerations: RFC 8620, Section 8.",
      "ja": "セキュリティとプライバシーの考慮事項：RFC 8620、セクション8。"
    },
    {
      "indent": 0,
      "text": "9.5. Creation of \"JMAP Error Codes\" Registry",
      "section_title": true,
      "ja": "9.5. 「JMAPエラーコード」レジストリの作成"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"JMAP Error Codes\" registry. JMAP error codes appear in the \"type\" member of a JSON problem details object (as described in Section 3.6.1), the \"type\" member in a JMAP error object (as described in Section 3.6.2), or the \"type\" member of a JMAP method-specific error object (such as SetError in Section 5.3). When used in a problem details object, the prefix \"urn:ietf:params:jmap:error:\" is always included; when used in JMAP objects, the prefix is always omitted.",
      "ja": "IANAは「JMAPエラーコード」レジストリを作成しました。 JMAPエラーコードは、JSON問題詳細オブジェクトの「type」メンバー（セクション3.6.1で説明）、JMAPエラーオブジェクトの「type」メンバー（セクション3.6.2で説明）、または「type JMAPメソッド固有のエラーオブジェクトのメンバー（セクション5.3のSetErrorなど）。 問題詳細オブジェクトで使用する場合、接頭辞「urn：ietf：params：jmap：error：」が常に含まれます。 JMAPオブジェクトで使用する場合、プレフィックスは常に省略されます。"
    },
    {
      "indent": 3,
      "text": "This registry follows the expert review process. Preliminary community review for this registry follows the same procedures as the \"JMAP Capabilities\" registry, but it is optional. The change procedures for this registry are the same as the change procedures for the \"JMAP Capabilities\" registry.",
      "ja": "このレジストリは、エキスパートレビュープロセスに従います。 このレジストリの予備的なコミュニティレビューは、「JMAP Capabilities」レジストリと同じ手順に従いますが、オプションです。 このレジストリの変更手順は、「JMAP Capabilities」レジストリの変更手順と同じです。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Expert Review",
      "section_title": true,
      "ja": "9.5.1. エキスパートレビュー"
    },
    {
      "indent": 3,
      "text": "The designated expert should review the following aspects of the registration:",
      "ja": "指定された専門家は、登録の次の側面を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Verify the error code does not conflict with existing names.",
      "ja": "1. エラーコードが既存の名前と競合しないことを確認します。"
    },
    {
      "indent": 3,
      "text": "2. Verify the error code follows the syntax limitations (does not require URI encoding).",
      "ja": "2. エラーコードが構文の制限に従っていることを確認します（URIエンコードは不要です）。"
    },
    {
      "indent": 3,
      "text": "3. Encourage the submitter to follow the naming convention of previously registered errors.",
      "ja": "3. 提出者が以前に登録されたエラーの命名規則に従うことを奨励します。"
    },
    {
      "indent": 3,
      "text": "4. Encourage the submitter to describe client behaviours that are recommended in response to the error code. These may distinguish the error code from other error codes.",
      "ja": "4. エラーコードへの応答として推奨されるクライアントの動作を説明するよう送信者に促します。 これらは、エラーコードを他のエラーコードと区別する場合があります。"
    },
    {
      "indent": 3,
      "text": "5. Encourage the submitter to describe when the server should issue the error as opposed to some other error code.",
      "ja": "5. 他のエラーコードではなく、サーバーがエラーを発行するタイミングを説明するよう送信者に促します。"
    },
    {
      "indent": 3,
      "text": "6. Encourage the submitter to note any security considerations associated with the error, if any (e.g., an error code that might disclose existence of data the authenticated user does not have permission to know about).",
      "ja": "6. エラーに関連するセキュリティ上の考慮事項がある場合は、送信者に注意するように奨励します（たとえば、認証されたユーザーが知る権限のないデータの存在を開示する可能性のあるエラーコード）。"
    },
    {
      "indent": 3,
      "text": "Steps 3-6 are meant to promote a higher-quality registry. However, the expert is encouraged to approve any registration that would not actively harm JMAP interoperability to make this a relatively lightweight process.",
      "ja": "ステップ3〜6は、高品質のレジストリを促進することを目的としています。 ただし、専門家は、JMAPの相互運用性を積極的に損なわない登録を承認して、これを比較的軽量なプロセスにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9.5.2. JMAP Error Codes Registry Template",
      "section_title": true,
      "ja": "9.5.2. JMAPエラーコードレジストリテンプレート"
    },
    {
      "indent": 3,
      "text": "JMAP Error Code:",
      "ja": "JMAPエラーコード："
    },
    {
      "indent": 3,
      "text": "Intended use: (one of \"common\", \"limited\", \"obsolete\")",
      "ja": "使用目的：（「共通」、「限定」、「廃止」のいずれか）"
    },
    {
      "indent": 3,
      "text": "Change Controller: (\"IETF\" for Standards Track / BCP RFCs)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reference: (Optional. Only required if defined in an RFC.)",
      "ja": "参照：（オプション。RFCで定義されている場合のみ必要です。）"
    },
    {
      "indent": 3,
      "text": "Description:",
      "ja": "説明："
    },
    {
      "indent": 0,
      "text": "9.5.3. Initial Contents for the JMAP Error Codes Registry",
      "section_title": true,
      "ja": "9.5.3. JMAPエラーコードレジストリの初期内容"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: accountNotFound Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: The accountId does not correspond to a valid account.",
      "ja": "o JMAPエラーコード：accountNotFound使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：accountIdは有効なアカウントに対応していません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: accountNotSupportedByMethod Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: The accountId given corresponds to a valid account, but the account does not support this method or data type.",
      "ja": "o JMAPエラーコード：accountNotSupportedByMethod使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：指定されたaccountIdは有効なアカウントに対応していますが、アカウントはこのメソッドまたはデータタイプをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: accountReadOnly Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: This method modifies state, but the account is read-only (as returned on the corresponding Account object in the JMAP Session resource).",
      "ja": "o JMAPエラーコード：accountReadOnly使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：このメソッドは状態を変更しますが、アカウントは読み取り専用です（JMAPセッションリソースの対応するAccountオブジェクトで返されます） 。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: anchorNotFound Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.5 Description: An anchor argument was supplied, but it cannot be found in the results of the query.",
      "ja": "o JMAPエラーコード：anchorNotFound使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.5説明：アンカー引数が指定されましたが、クエリの結果に見つかりません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: alreadyExists Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.4 Description: The server forbids duplicates, and the record already exists in the target account. An existingId property of type Id MUST be included on the SetError object with the id of the existing record.",
      "ja": "o JMAPエラーコード：alreadyExists使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.4説明：サーバーは重複を禁止しており、レコードは既にターゲットアカウントに存在します。 タイプIdのexistingIdプロパティは、既存のレコードのIDとともにSetErrorオブジェクトに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: cannotCalculateChanges Intended Use: Common Change Controller: IETF Reference: RFC 8620, Sections 5.2 and 5.6 Description: The server cannot calculate the changes from the state string given by the client.",
      "ja": "o JMAPエラーコード：cannotCalculateChanges使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.2および5.6説明：サーバーは、クライアントが指定した状態文字列から変更を計算できません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: forbidden Intended Use: Common Change Controller: IETF Reference: RFC 8620, Sections 3.6.2, 5.3, and 7.2.1 Description: The action would violate an ACL or other permissions policy.",
      "ja": "o JMAPエラーコード：使用禁止：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2、5.3、および7.2.1説明：アクションはACLまたは他のアクセス許可ポリシーに違反します。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: fromAccountNotFound Intended Use: Common Change Controller: IETF Reference: RFC 8620, Sections 5.4 and 6.3 Description: The fromAccountId does not correspond to a valid account.",
      "ja": "o JMAPエラーコード：fromAccountNotFound使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.4および6.3説明：fromAccountIdは有効なアカウントに対応していません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: fromAccountNotSupportedByMethod Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.4 Description: The fromAccountId given corresponds to a valid account, but the account does not support this data type.",
      "ja": "o JMAPエラーコード：fromAccountNotSupportedByMethod使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.4説明：指定されたfromAccountIdは有効なアカウントに対応していますが、アカウントはこのデータタイプをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: invalidArguments Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: One of the arguments is of the wrong type or otherwise invalid, or a required argument is missing.",
      "ja": "o JMAPエラーコード：invalidArguments使用目的：共通の変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：引数の1つが間違ったタイプであるか、無効であるか、必要な引数がありません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: invalidPatch Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The PatchObject given to update the record was not a valid patch.",
      "ja": "o JMAPエラーコード：invalidPatch使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：レコードを更新するために指定されたPatchObjectは有効なパッチではありませんでした。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: invalidProperties Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The record given is invalid.",
      "ja": "o JMAPエラーコード：invalidProperties使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：指定されたレコードは無効です。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: notFound Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The id given cannot be found.",
      "ja": "o JMAPエラーコード：notFound使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：指定されたIDが見つかりません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: notJSON Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.1 Description: The content type of the request was not application/ json, or the request did not parse as I-JSON.",
      "ja": "o JMAPエラーコード：notJSON使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.1説明：要求のコンテンツタイプがapplication / jsonでないか、要求がI-JSONとして解析されませんでした。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: notRequest Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.1 Description: The request parsed as JSON but did not match the type signature of the Request object.",
      "ja": "o JMAPエラーコード：notRequest使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.1説明：要求はJSONとして解析されましたが、要求オブジェクトのタイプシグネチャと一致しませんでした。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: overQuota Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The create would exceed a server-defined limit on the number or total size of objects of this type.",
      "ja": "o JMAPエラーコード：overQuota使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：作成は、このタイプのオブジェクトの数または合計サイズのサーバー定義の制限を超えます。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: rateLimit Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: Too many objects of this type have been created recently, and a server-defined rate limit has been reached. It may work if tried again later.",
      "ja": "o JMAPエラーコード：rateLimit使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：このタイプのオブジェクトが最近作成されすぎており、サーバー定義のレート制限に達しました。 後で再試行すると機能する場合があります。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: requestTooLarge Intended Use: Common Change Controller: IETF Reference: RFC 8620, Sections 5.1 and 5.3 Description: The total number of actions exceeds the maximum number the server is willing to process in a single method call.",
      "ja": "o JMAPエラーコード：requestTooLarge使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.1および5.3説明：アクションの総数が、サーバーが1つのメソッド呼び出しで処理できる最大数を超えています。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: invalidResultReference Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: The method used a result reference for one of its arguments, but this failed to resolve.",
      "ja": "o JMAPエラーコード：invalidResultReference使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：メソッドは引数の1つに対して結果リファレンスを使用しましたが、これは解決に失敗しました。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: serverFail Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: An unexpected or unknown error occurred during the processing of the call. The method call made no changes to the server's state.",
      "ja": "o JMAPエラーコード：serverFail使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：呼び出しの処理中に予期しないエラーまたは不明なエラーが発生しました。 メソッド呼び出しは、サーバーの状態を変更しませんでした。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: serverPartialFail Intended Use: Limited Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: Some, but not all, expected changes described by the method occurred. The client MUST resynchronise impacted data to determine the server state. Use of this error is strongly discouraged.",
      "ja": "o JMAPエラーコード：serverPartialFail使用目的：制限付き変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：メソッドによって説明されている、すべてではないが一部の変更が発生しました。 クライアントは、影響を受けたデータを再同期して、サーバーの状態を判断する必要があります。 このエラーの使用は強く推奨されていません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: serverUnavailable Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: Some internal server resource was temporarily unavailable. Attempting the same operation later (perhaps after a backoff with a random factor) may succeed.",
      "ja": "o JMAPエラーコード：serverUnavailable使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：一部の内部サーバーリソースは一時的に利用できませんでした。 後で同じ操作を試行する（おそらく、ランダムな要因によるバックオフの後）ことがあります。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: singleton Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: This is a singleton type, so you cannot create another one or destroy the existing one.",
      "ja": "o JMAPエラーコード：シングルトン使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：これはシングルトンタイプであるため、別のタイプを作成したり、既存のタイプを破壊したりすることはできません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: stateMismatch Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: An ifInState argument was supplied, and it does not match the current state.",
      "ja": "o JMAPエラーコード：stateMismatch使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：ifInState引数が指定されましたが、現在の状態と一致しません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: tooLarge Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The action would result in an object that exceeds a server-defined limit for the maximum size of a single object of this type.",
      "ja": "o JMAPエラーコード：tooLarge使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：アクションは、このタイプの単一オブジェクトの最大サイズのサーバー定義の制限を超えるオブジェクトになります。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: tooManyChanges Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.6 Description: There are more changes than the client's maxChanges argument.",
      "ja": "o JMAPエラーコード：tooManyChanges使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.6説明：クライアントのmaxChanges引数よりも多くの変更があります。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: unknownCapability Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.1 Description: The client included a capability in the \"using\" property of the request that the server does not support.",
      "ja": "o JMAPエラーコード：unknownCapability使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.1説明：クライアントは、サーバーがサポートしていない要求の \"using\"プロパティに機能を含めました。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: unknownMethod Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 3.6.2 Description: The server does not recognise this method name.",
      "ja": "o JMAPエラーコード：unknownMethod使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション3.6.2説明：サーバーはこのメソッド名を認識しません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: unsupportedFilter Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.5 Description: The filter is syntactically valid, but the server cannot process it.",
      "ja": "o JMAPエラーコード：unsupportedFilter使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.5説明：フィルターは構文的に有効ですが、サーバーは処理できません。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: unsupportedSort Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.5 Description: The sort is syntactically valid but includes a property the server does not support sorting on or a collation method it does not recognise.",
      "ja": "o JMAPエラーコード：unsupportedSort使用目的：一般的な変更コントローラー：IETFリファレンス：RFC 8620、セクション5.5説明：並べ替えは構文的には有効ですが、サーバーが並べ替えをサポートしていないプロパティ、または認識できない照合方法が含まれています。"
    },
    {
      "indent": 3,
      "text": "o JMAP Error Code: willDestroy Intended Use: Common Change Controller: IETF Reference: RFC 8620, Section 5.3 Description: The client requested an object be both updated and destroyed in the same /set request, and the server has decided to therefore ignore the update.",
      "ja": "o JMAPエラーコード：willDestroy使用目的：共通変更コントローラー：IETFリファレンス：RFC 8620、セクション5.3説明：クライアントは、同じ/ set要求でオブジェクトの更新と破棄の両方を要求したため、サーバーは更新を無視することを決定しました。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[EventSource] Hickson, I., \"Server-Sent Events\", World Wide Web Consortium Recommendation REC-eventsource-20150203, February 2015, <https://www.w3.org/TR/eventsource/>.",
      "ja": "[EventSource] Hickson、I.、「サーバー送信イベント」、World Wide Web Consortium Recommendation REC-eventsource-20150203、2015年2月、<https://www.w3.org/TR/eventsource/>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, DOI 10.17487/RFC2782, February 2000, <https://www.rfc-editor.org/info/rfc2782>.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<https：// www.rfc-editor.org/info/rfc2782>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <https://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818] Rescorla、E。、「HTTP Over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<https://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, DOI 10.17487/RFC3339, July 2002, <https://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339] Klyne、G. and C. Newman、 \"Date and Time on the Internet：Timestamps\"、RFC 3339、DOI 10.17487 / RFC3339、July 2002、<https://www.rfc-editor.org/info/rfc3339 >。"
    },
    {
      "indent": 3,
      "text": "[RFC3553] Mealling, M., Masinter, L., Hardie, T., and G. Klyne, \"An IETF URN Sub-namespace for Registered Protocol Parameters\", BCP 73, RFC 3553, DOI 10.17487/RFC3553, June 2003, <https://www.rfc-editor.org/info/rfc3553>.",
      "ja": "[RFC3553] Mealling、M.、Masinter、L.、Hardie、T。、およびG. Klyne、「登録済みプロトコルパラメータのIETF URNサブ名前空間」、BCP 73、RFC 3553、DOI 10.17487 / RFC3553、2003年6月、 <https://www.rfc-editor.org/info/rfc3553>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC4790] Newman, C., Duerst, M., and A. Gulbrandsen, \"Internet Application Protocol Collation Registry\", RFC 4790, DOI 10.17487/RFC4790, March 2007, <https://www.rfc-editor.org/info/rfc4790>.",
      "ja": "[RFC4790]ニューマン、C。、デュエルスト、M。、およびA.グルブランセン、「インターネットアプリケーションプロトコル照合レジストリ」、RFC 4790、DOI 10.17487 / RFC4790、2007年3月、<https://www.rfc-editor.org/ info / rfc4790>。"
    },
    {
      "indent": 3,
      "text": "[RFC5051] Crispin, M., \"i;unicode-casemap - Simple Unicode Collation Algorithm\", RFC 5051, DOI 10.17487/RFC5051, October 2007, <https://www.rfc-editor.org/info/rfc5051>.",
      "ja": "[RFC5051]クリスピン、M。、「i; unicode-casemap-Simple Unicode Collation Algorithm」、RFC 5051、DOI 10.17487 / RFC5051、2007年10月、<https://www.rfc-editor.org/info/rfc5051>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、およびW. Polk、 \"インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, DOI 10.17487/RFC5322, October 2008, <https://www.rfc-editor.org/info/rfc5322>.",
      "ja": "[RFC5322] Resnick、P.、Ed。、「インターネットメッセージフォーマット」、RFC 5322、DOI 10.17487 / RFC5322、2008年10月、<https://www.rfc-editor.org/info/rfc5322>。"
    },
    {
      "indent": 3,
      "text": "[RFC6186] Daboo, C., \"Use of SRV Records for Locating Email Submission/Access Services\", RFC 6186, DOI 10.17487/RFC6186, March 2011, <https://www.rfc-editor.org/info/rfc6186>.",
      "ja": "[RFC6186] Daboo、C.、「電子メール送信/アクセスサービスを見つけるためのSRVレコードの使用」、RFC 6186、DOI 10.17487 / RFC6186、2011年3月、<https://www.rfc-editor.org/info/rfc6186> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, <https://www.rfc-editor.org/info/rfc6335>.",
      "ja": "[RFC6335] Cotton、M.、Eggert、L.、Touch、J.、Westerlund、M。、およびS. Cheshire、「サービス名およびトランスポートプロトコルポート番号レジストリの管理のためのインターネット指定番号機関（IANA）手順 \"、BCP 165、RFC 6335、DOI 10.17487 / RFC6335、2011年8月、<https://www.rfc-editor.org/info/rfc6335>。"
    },
    {
      "indent": 3,
      "text": "[RFC6570] Gregorio, J., Fielding, R., Hadley, M., Nottingham, M., and D. Orchard, \"URI Template\", RFC 6570, DOI 10.17487/RFC6570, March 2012, <https://www.rfc-editor.org/info/rfc6570>.",
      "ja": "[RFC6570]グレゴリオ、J。、フィールディング、R。、ハドリー、M。、ノッティンガム、M。、およびD.オーチャード、「URIテンプレート」、RFC 6570、DOI 10.17487 / RFC6570、2012年3月、<https：// www .rfc-editor.org / info / rfc6570>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D.、Ed。、「OAuth 2.0認可フレームワーク」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC6764] Daboo, C., \"Locating Services for Calendaring Extensions to WebDAV (CalDAV) and vCard Extensions to WebDAV (CardDAV)\", RFC 6764, DOI 10.17487/RFC6764, February 2013, <https://www.rfc-editor.org/info/rfc6764>.",
      "ja": "[RFC6764] Daboo、C。、「WebDAV（CalDAV）のカレンダー拡張機能およびWebDAV（CardDAV）のvCard拡張機能の検索サービス」、RFC 6764、DOI 10.17487 / RFC6764、2013年2月、<https：//www.rfc-editor .org / info / rfc6764>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「Media Type Specifications and Registration Procedures」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<https：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC6901] Bryan, P., Ed., Zyp, K., and M. Nottingham, Ed., \"JavaScript Object Notation (JSON) Pointer\", RFC 6901, DOI 10.17487/RFC6901, April 2013, <https://www.rfc-editor.org/info/rfc6901>.",
      "ja": "[RFC6901] Bryan、P.、Ed。、Zyp、K。、およびM. Nottingham、Ed。、「JavaScript Object Notation（JSON）ポインター」、RFC 6901、DOI 10.17487 / RFC6901、2013年4月、<https：// www.rfc-editor.org/info/rfc6901>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <https://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R。、エド。 およびJ. rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <https://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R。、エド。 およびJ. Reschke、Ed。、「ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスとコンテンツ」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <https://www.rfc-editor.org/info/rfc7493>.",
      "ja": "[RFC7493]ブレイ、T。、エド、「I-JSONメッセージ形式」、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、<https://www.rfc-editor.org/info/rfc7493>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <https://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<https://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, DOI 10.17487/RFC7617, September 2015, <https://www.rfc-editor.org/info/rfc7617>.",
      "ja": "[RFC7617] Reschke、J。、「The 'Basic' HTTP Authentication Scheme」、RFC 7617、DOI 10.17487 / RFC7617、2015年9月、<https://www.rfc-editor.org/info/rfc7617>。"
    },
    {
      "indent": 3,
      "text": "[RFC7807] Nottingham, M. and E. Wilde, \"Problem Details for HTTP APIs\", RFC 7807, DOI 10.17487/RFC7807, March 2016, <https://www.rfc-editor.org/info/rfc7807>.",
      "ja": "[RFC7807]ノッティンガム、M。、およびE.ワイルド、「HTTP APIの問題の詳細」、RFC 7807、DOI 10.17487 / RFC7807、2016年3月、<https://www.rfc-editor.org/info/rfc7807>。"
    },
    {
      "indent": 3,
      "text": "[RFC8030] Thomson, M., Damaggio, E., and B. Raymor, Ed., \"Generic Event Delivery Using HTTP Push\", RFC 8030, DOI 10.17487/RFC8030, December 2016, <https://www.rfc-editor.org/info/rfc8030>.",
      "ja": "[RFC8030] Thomson、M.、Damaggio、E。、およびB. Raymor、Ed。、「HTTPプッシュを使用した汎用イベント配信」、RFC 8030、DOI 10.17487 / RFC8030、2016年12月、<https：//www.rfc- editor.org/info/rfc8030>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、Ed。、「JavaScriptオブジェクト表記（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、<https://www.rfc-editor.org / info / rfc8259>。"
    },
    {
      "indent": 3,
      "text": "[RFC8264] Saint-Andre, P. and M. Blanchet, \"PRECIS Framework: Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols\", RFC 8264, DOI 10.17487/RFC8264, October 2017, <https://www.rfc-editor.org/info/rfc8264>.",
      "ja": "[RFC8264] Saint-Andre、P。およびM. Blanchet、「PRECISフレームワーク：アプリケーションプロトコルでの国際化文字列の準備、施行、および比較」、RFC 8264、DOI 10.17487 / RFC8264、2017年10月、<https：// www。 rfc-editor.org/info/rfc8264>。"
    },
    {
      "indent": 3,
      "text": "[RFC8291] Thomson, M., \"Message Encryption for Web Push\", RFC 8291, DOI 10.17487/RFC8291, November 2017, <https://www.rfc-editor.org/info/rfc8291>.",
      "ja": "[RFC8291]トムソン、M.、\"ウェブプッシュのためのメッセージの暗号化\"、RFC8291、DOI10.17487/ RFC8291、2017年11月、<https://www.rfc-editor.org/info/rfc8291>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8615] Nottingham, M., \"Well-Known Uniform Resource Identifiers (URIs)\", RFC 8615, DOI 10.17487/RFC8615, May 2019, <https://www.rfc-editor.org/info/rfc8615>.",
      "ja": "[RFC8615]ノッティンガム、M。、「Well-Known Uniform Resource Identifiers（URIs）」、RFC 8615、DOI 10.17487 / RFC8615、2019年5月、<https://www.rfc-editor.org/info/rfc8615>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC8246] McManus, P., \"HTTP Immutable Responses\", RFC 8246, DOI 10.17487/RFC8246, September 2017, <https://www.rfc-editor.org/info/rfc8246>.",
      "ja": "[RFC8246] McManus、P。、「HTTP Immutable Responses」、RFC 8246、DOI 10.17487 / RFC8246、2017年9月、<https://www.rfc-editor.org/info/rfc8246>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Neil Jenkins Fastmail PO Box 234, Collins St. West Melbourne, VIC 8007 Australia",
      "ja": "Neil Jenkins Fastmail PO Box 234、Collins St.West Melbourne、VIC 8007 Australia"
    },
    {
      "indent": 3,
      "text": "Email: neilj@fastmailteam.com\nURI:   https://www.fastmail.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chris Newman Oracle 440 E. Huntington Dr., Suite 400 Arcadia, CA 91006 United States of America",
      "ja": "Chris Newman Oracle 440 E. Huntington Dr. Suite 400 Arcadia、CA 91006アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: chris.newman@oracle.com",
      "raw": true
    }
  ]
}