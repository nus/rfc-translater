{
  "title": {
    "text": "RFC 8699 - Coupled Congestion Control for RTP Media",
    "ja": "RFC 8699 - RTPメディアの結合輻輳制御"
  },
  "number": 8699,
  "created_at": "2020-03-11 12:10:01.066308+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          S. Islam\nRequest for Comments: 8699                                      M. Welzl\nCategory: Experimental                                       S. Gjessing\nISSN: 2070-1721                                       University of Oslo\n                                                            January 2020",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Coupled Congestion Control for RTP Media",
      "ja": "RTPメディアの結合輻輳制御"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "When multiple congestion-controlled Real-time Transport Protocol (RTP) sessions traverse the same network bottleneck, combining their controls can improve the total on-the-wire behavior in terms of delay, loss, and fairness. This document describes such a method for flows that have the same sender, in a way that is as flexible and simple as possible while minimizing the number of changes needed to existing RTP applications. This document also specifies how to apply the method for the Network-Assisted Dynamic Adaptation (NADA) congestion control algorithm and provides suggestions on how to apply it to other congestion control algorithms.",
      "ja": "複数の輻輳制御Real-time Transport Protocol（RTP）セッションが同じネットワークボトルネックを通過する場合、それらの制御を組み合わせることにより、遅延、損失、および公平性の観点から、全体のワイヤ上の動作を改善できます。 このドキュメントでは、既存のRTPアプリケーションに必要な変更の数を最小限に抑えながら、できるだけ柔軟でシンプルな方法で、同じ送信者を持つフローのこのような方法について説明します。 また、このドキュメントでは、Network-Assisted Dynamic Adaptation（NADA）輻輳制御アルゴリズムにメソッドを適用する方法を指定し、他の輻輳制御アルゴリズムに適用する方法について提案します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 調査、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義しています。 このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8699.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8699で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 2. Definitions 3. Limitations 4. Architectural Overview 5. Roles 5.1. SBD 5.2. FSE 5.3. Flows 5.3.1. Example Algorithm 1 - Active FSE 5.3.2. Example Algorithm 2 - Conservative Active FSE 6. Application 6.1. NADA 6.2. General Recommendations 7. Expected Feedback from Experiments 8. IANA Considerations 9. Security Considerations 10. References 10.1. Normative References 10.2. Informative References Appendix A. Application to GCC Appendix B. Scheduling Appendix C. Example Algorithm - Passive FSE C.1. Example Operation (Passive) Acknowledgements Authors' Addresses",
      "ja": "1. はじめに2.定義3.制限4.アーキテクチャの概要5.役割5.1。 SBD 5.2。 FSE 5.3。 フロー5.3.1。 アルゴリズム例1-アクティブFSE 5.3.2。 アルゴリズム例2-保守的アクティブFSE 6.アプリケーション6.1。 ADA 6.2。 一般的な推奨事項7.実験から期待されるフィードバック8. IANAに関する考慮事項9.セキュリティに関する考慮事項10.参考文献10.1 規範的参考文献10.2。 参考情報付録A. GCCへの適用付録B.スケジューリング付録C.アルゴリズムの例-パッシブFSE C.1。 操作例（パッシブ）謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "When there is enough data to send, a congestion controller attempts to increase its sending rate until the path's capacity has been reached. Some controllers detect path capacity by increasing the sending rate further, until packets are ECN-marked [RFC8087] or dropped, and then decreasing the sending rate until that stops happening. This process inevitably creates undesirable queuing delay when multiple congestion-controlled connections traverse the same network bottleneck, and each connection overshoots the path capacity as it determines its sending rate.",
      "ja": "送信するのに十分なデータがある場合、輻輳コントローラは、パスの容量に達するまで送信レートを増加させようとします。 一部のコントローラーは、パケットがECNマーク[RFC8087]またはドロップされるまで送信レートをさらに上げ、それが停止するまで送信レートを下げることにより、パス容量を検出します。 このプロセスは、複数の輻輳制御接続が同じネットワークボトルネックを通過し、送信レートを決定するときに各接続がパスキャパシティをオーバーシュートする場合、必然的に望ましくないキュー遅延を作成します。"
    },
    {
      "indent": 3,
      "text": "The Congestion Manager (CM) [RFC3124] couples flows by providing a single congestion controller. It is hard to implement because it requires an additional congestion controller and removes all per-connection congestion control functionality, which is quite a significant change to existing RTP-based applications. This document presents a method to combine the behavior of congestion control mechanisms that is easier to implement than the Congestion Manager [RFC3124] and also requires fewer significant changes to existing RTP-based applications. It attempts to roughly approximate the CM behavior by sharing information between existing congestion controllers. It is able to honor user-specified priorities, which is required by WebRTC [RTCWEB-OVERVIEW] [RFC7478].",
      "ja": "Congestion Manager（CM）[RFC3124]は、単一の輻輳コントローラを提供することによりフローを結合します。 追加の輻輳コントローラが必要であり、接続ごとの輻輳制御機能がすべて削除されるため、実装が困難です。これは、既存のRTPベースのアプリケーションに対する大幅な変更です。 このドキュメントでは、輻輳マネージャ[RFC3124]よりも実装が簡単で、既存のRTPベースのアプリケーションへの大幅な変更が少ない輻輳制御メカニズムの動作を組み合わせる方法を紹介します。 既存の輻輳コントローラ間で情報を共有することにより、CMの動作をほぼ近似しようとします。 WebRTC [RTCWEB-OVERVIEW] [RFC7478]で必要とされるユーザー指定の優先順位を尊重することができます。"
    },
    {
      "indent": 3,
      "text": "The described mechanisms are believed safe to use, but they are experimental and are presented for wider review and operational evaluation.",
      "ja": "説明したメカニズムは安全に使用できると考えられていますが、実験的なものであり、より広範なレビューと運用評価のために提示されています。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "Available Bandwidth: The available bandwidth is the nominal link capacity minus the amount of traffic that traversed the link during a certain time interval, divided by that time interval.",
      "ja": "使用可能な帯域幅：使用可能な帯域幅は、名目リンク容量から特定の時間間隔中にリンクを通過したトラフィックの量をその時間間隔で割った値です。"
    },
    {
      "indent": 3,
      "text": "Bottleneck: The first link with the smallest available bandwidth along the path between a sender and receiver.",
      "ja": "ボトルネック：送信者と受信者の間のパスに沿って利用可能な最小の帯域幅を持つ最初のリンク。"
    },
    {
      "indent": 3,
      "text": "Flow: A flow is the entity that congestion control is operating on. It could, for example, be a transport-layer connection or an RTP stream [RFC7656], regardless of whether or not this RTP stream is multiplexed onto an RTP session with other RTP streams.",
      "ja": "フロー：フローは、輻輳制御が機能しているエンティティです。 たとえば、このRTPストリームが他のRTPストリームとのRTPセッションに多重化されているかどうかに関係なく、トランスポート層接続またはRTPストリーム[RFC7656]になります。"
    },
    {
      "indent": 3,
      "text": "Flow Group Identifier (FGI): A unique identifier for each subset of flows that is limited by a common bottleneck.",
      "ja": "フローグループ識別子（FGI）：フローの各サブセットの一意の識別子で、共通のボトルネックによって制限されています。"
    },
    {
      "indent": 3,
      "text": "Flow State Exchange (FSE): The entity that maintains information that is exchanged between flows.",
      "ja": "フロー状態交換（FSE）：フロー間で交換される情報を維持するエンティティ。"
    },
    {
      "indent": 3,
      "text": "Flow Group (FG): A group of flows having the same FGI.",
      "ja": "フローグループ（FG）：同じFGIを持つフローのグループ。"
    },
    {
      "indent": 3,
      "text": "Shared Bottleneck Detection (SBD): The entity that determines which flows traverse the same bottleneck in the network or the process of doing so.",
      "ja": "共有ボトルネック検出（SBD）：ネットワーク内の同じボトルネックまたはそのプロセスを通過するフローを決定するエンティティ。"
    },
    {
      "indent": 0,
      "text": "3. Limitations",
      "section_title": true,
      "ja": "3. 制限事項"
    },
    {
      "indent": 3,
      "text": "Sender-side only: Shared bottlenecks can exist when multiple flows originate from the same sender or when flows from different senders reach the same receiver (see Section 3 of [RFC8382]). Coupled congestion control, as described here, only supports the former case, not the latter, as it operates inside a single host on the sender side.",
      "ja": "送信側のみ：複数のフローが同じ送信者から発信される場合、または異なる送信者からのフローが同じ受信者に到達する場合、共有ボトルネックが存在する可能性があります（[RFC8382]のセクション3を参照）。 ここで説明するように、結合輻輳制御は、送信者側の単一ホスト内で動作するため、前者の場合のみをサポートし、後者はサポートしません。"
    },
    {
      "indent": 3,
      "text": "Shared bottlenecks do not change quickly: As per the definition above, a bottleneck depends on cross traffic, and since such traffic can heavily fluctuate, bottlenecks can change at a high frequency (e.g., there can be oscillation between two or more links). This means that, when flows are partially routed along different paths, they may quickly change between sharing and not sharing a bottleneck. For simplicity, here it is assumed that a shared bottleneck is valid for a time interval that is significantly longer than the interval at which congestion controllers operate. Note that, for the only SBD mechanism defined in this document (multiplexing on the same five-tuple), the notion of a shared bottleneck stays correct even in the presence of fast traffic fluctuations; since all flows that are assumed to share a bottleneck are routed in the same way, if the bottleneck changes, it will still be shared.",
      "ja": "共有ボトルネックはすぐに変更されません：上記の定義によると、ボトルネックはクロストラフィックに依存し、そのようなトラフィックは大きく変動する可能性があるため、ボトルネックは高頻度で変更される可能性があります（たとえば、2つ以上のリンク間で振動が発生する可能性があります）。 つまり、フローが異なるパスに沿って部分的にルーティングされると、ボトルネックの共有と非共有の間で急速に変化する可能性があります。 簡単にするために、ここでは、輻輳コントローラが動作する間隔よりもかなり長い時間間隔で共有ボトルネックが有効であると想定しています。 このドキュメントで定義されている唯一のSBDメカニズム（同じ5タプルでの多重化）の場合、高速なトラフィック変動がある場合でも、共有ボトルネックの概念は正しいままであることに注意してください。 ボトルネックを共有すると想定されるすべてのフローは同じ方法でルーティングされるため、ボトルネックが変更されても、共有されます。"
    },
    {
      "indent": 0,
      "text": "4. Architectural Overview",
      "section_title": true,
      "ja": "4. アーキテクチャの概要"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the elements of the architecture for coupled congestion control: the Flow State Exchange (FSE), Shared Bottleneck Detection (SBD), and Flows. The FSE is a storage element that can be implemented in two ways: active and passive. In the active version, it initiates communication with flows and SBD. However, in the passive version, it does not actively initiate communication with flows and SBD; its only active role is internal state maintenance (e.g., an implementation could use soft state to remove a flow's data after long periods of inactivity). Every time a flow's congestion control mechanism would normally update its sending rate, the flow instead updates information in the FSE and performs a query on the FSE, leading to a sending rate that can be different from what the congestion controller originally determined. Using information about/from the currently active flows, SBD updates the FSE with the correct Flow Group Identifiers (FGIs).",
      "ja": "図1は、結合された輻輳制御のアーキテクチャの要素、フロー状態交換（FSE）、共有ボトルネック検出（SBD）、およびフローを示しています。 FSEは、アクティブとパッシブの2つの方法で実装できるストレージ要素です。 アクティブバージョンでは、フローおよびSBDとの通信を開始します。 ただし、パッシブバージョンでは、フローおよびSBDとの通信をアクティブに開始しません。 その唯一のアクティブな役割は内部状態のメンテナンスです（たとえば、実装はソフト状態を使用して、長期間非アクティブになった後にフローのデータを削除できます）。 通常、フローの輻輳制御メカニズムが送信レートを更新するたびに、フローは代わりにFSEの情報を更新し、FSEでクエリを実行し、輻輳コントローラーが最初に決定したものとは異なる送信レートを導きます。 現在アクティブなフローに関する情報を使用して、SBDはFSEを正しいフローグループ識別子（FGI）で更新します。"
    },
    {
      "indent": 3,
      "text": "This document describes both active and passive versions. While the passive algorithm works better for congestion controls with RTT-independent convergence, it can still produce oscillations on short time scales. The passive algorithm, described in Appendix C, is therefore considered highly experimental and not safe to deploy outside of testbed environments. Figure 2 shows the interaction between flows and the FSE using the variable names defined in Section 5.2.",
      "ja": "このドキュメントでは、アクティブバージョンとパッシブバージョンの両方について説明します。 パッシブアルゴリズムは、RTTに依存しないコンバージェンスを使用した輻輳制御に適していますが、それでも短い時間スケールで振動を生成できます。 したがって、付録Cで説明されているパッシブアルゴリズムは、非常に実験的であると見なされており、テストベッド環境外に展開するのは安全ではありません。 図2は、セクション5.2で定義された変数名を使用したフローとFSE間の相互作用を示しています。"
    },
    {
      "indent": 25,
      "text": "-------  <---  Flow 1\n| FSE |  <---  Flow 2 ..\n-------  <---  .. Flow N\n   ^\n   |             |\n-------          |\n| SBD |  <-------|\n-------",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 1: Coupled congestion control architecture",
      "ja": "図1：結合された輻輳制御アーキテクチャ"
    },
    {
      "indent": 5,
      "text": "Flow#1(cc)                     FSE                    Flow#2(cc)\n----------                     ---                    ----------\n#1 JOIN     ----register--> REGISTER",
      "raw": true
    },
    {
      "indent": 33,
      "text": "REGISTER <--register-- JOIN #1",
      "ja": "レジスタ<-register-- JOIN＃1"
    },
    {
      "indent": 5,
      "text": "#2 CC_R(1)  ----UPDATE----> UPDATE (in)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "#3 NEW RATE <---FSE_R(1)-- UPDATE (out) --FSE_R(2)-> #3 NEW RATE",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2: Flow-FSE interactions",
      "ja": "図2：Flow-FSEの相互作用"
    },
    {
      "indent": 3,
      "text": "Since everything shown in Figure 1 is assumed to operate on a single host (the sender) only, this document only describes aspects that have an influence on the resulting on-the-wire behavior. It does not, for instance, define how many bits must be used to represent FGIs or in which way the entities communicate.",
      "ja": "図1に示されているものはすべて、単一のホスト（送信者）でのみ動作することを前提としているため、このドキュメントでは、結果のワイヤ上の動作に影響を与える側面のみを説明します。 たとえば、FGIを表すために使用する必要があるビット数や、エンティティが通信する方法を定義しません。"
    },
    {
      "indent": 3,
      "text": "Implementations can take various forms; for instance, all the elements in the figure could be implemented within a single application, thereby operating on flows generated by that application only. Another alternative could be to implement both the FSE and SBD together in a separate process that different applications communicate with via some form of Inter-Process Communication (IPC). Such an implementation would extend the scope to flows generated by multiple applications. The FSE and SBD could also be included in the Operating System kernel. However, only one type of coupling algorithm should be used for all flows. Combinations of multiple algorithms at different aggregation levels (e.g., the Operating System coupling application aggregates with one algorithm, and applications coupling their flows with another) have not been tested and are therefore not recommended.",
      "ja": "実装にはさまざまな形式があります。 たとえば、図のすべての要素を単一のアプリケーション内に実装し、そのアプリケーションによって生成されたフローのみを操作できます。 別の方法として、FSEとSBDの両方を、さまざまなアプリケーションが何らかのプロセス間通信（IPC）を介して通信する別個のプロセスで一緒に実装することもできます。 そのような実装は、複数のアプリケーションによって生成されるフローに範囲を拡張します。 FSEとSBDは、オペレーティングシステムカーネルに含めることもできます。 ただし、すべてのフローに使用する結合アルゴリズムは1種類のみです。 異なる集約レベルでの複数のアルゴリズムの組み合わせ（たとえば、アプリケーション集約を1つのアルゴリズムに結合するオペレーティングシステム、およびアプリケーションフローを別のアルゴリズムに結合するアプリケーション）はテストされていないため、推奨されません。"
    },
    {
      "indent": 0,
      "text": "5. Roles",
      "section_title": true,
      "ja": "5. 役割"
    },
    {
      "indent": 3,
      "text": "This section gives an overview of the roles of the elements of coupled congestion control and provides an example of how coupled congestion control can operate.",
      "ja": "このセクションでは、結合された輻輳制御の要素の役割の概要を示し、結合された輻輳制御の動作方法の例を示します。"
    },
    {
      "indent": 0,
      "text": "5.1. SBD",
      "section_title": true,
      "ja": "5.1. SBD"
    },
    {
      "indent": 3,
      "text": "SBD uses knowledge about the flows to determine which flows belong in the same Flow Group (FG) and assigns FGIs accordingly. This knowledge can be derived in three basic ways:",
      "ja": "SBDは、フローに関する知識を使用して、同じフローグループ（FG）に属するフローを判断し、それに応じてFGIを割り当てます。 この知識は、3つの基本的な方法で導き出すことができます。"
    },
    {
      "indent": 3,
      "text": "1. From multiplexing: It can be based on the simple assumption that packets sharing the same five-tuple (IP source and destination address, protocol, and transport-layer port number pair) and having the same values for the Differentiated Services Code Point (DSCP) and the ECN field in the IP header are typically treated in the same way along the path. This method is the only one specified in this document; SBD MAY consider all flows that use the same five-tuple, DSCP, and ECN field value to belong to the same FG. This classification applies to certain tunnels or RTP flows that are multiplexed over one transport (cf. [TRANSPORT-MULTIPLEX]). Such multiplexing is also a recommended usage of RTP in WebRTC [RTCWEB-RTP-USAGE].",
      "ja": "1. 多重化から：パケットは同じ5タプル（IP送信元と宛先アドレス、プロトコル、およびトランスポート層ポート番号のペア）を共有し、Differentiated Services Code Point（DSCP）の値が同じであるという単純な仮定に基づくことができます IPヘッダーのECNフィールドは通常、パスに沿って同じ方法で処理されます。 このメソッドは、このドキュメントで指定されている唯一のメソッドです。 SBDは、同じ5タプル、DSCP、およびECNフィールド値を使用するすべてのフローが同じFGに属すると見なしてもよい（MAY）。 この分類は、1つのトランスポートで多重化される特定のトンネルまたはRTPフローに適用されます（[TRANSPORT-MULTIPLEX]を参照）。 このような多重化は、WebRTC [RTCWEB-RTP-USAGE]でのRTPの推奨される使用法でもあります。"
    },
    {
      "indent": 3,
      "text": "2. Via configuration: e.g., by assuming that a common wireless uplink is also a shared bottleneck.",
      "ja": "2. 構成を介して：たとえば、共通のワイヤレスアップリンクも共有ボトルネックであると想定します。"
    },
    {
      "indent": 3,
      "text": "3. From measurements: e.g., by considering correlations among measured delay and loss as an indication of a shared bottleneck.",
      "ja": "3. 測定から：たとえば、測定された遅延と損失の間の相関を共有ボトルネックの指標として考慮することによる。"
    },
    {
      "indent": 3,
      "text": "The methods above have some essential trade-offs. For example, multiplexing is a completely reliable measure, but it is limited in scope to two endpoints (i.e., it cannot be applied to couple congestion controllers of one sender talking to multiple receivers). A measurement-based SBD mechanism is described in [RFC8382]. Measurements can never be 100% reliable, in particular because they are based on the past, but applying coupled congestion control involves making an assumption about the future; it is therefore recommended to implement cautionary measures, e.g., by disabling coupled congestion control if enabling it causes a significant increase in delay and/or packet loss. Measurements also take time, which entails a certain delay for turning on coupling (refer to [RFC8382] for details). When this is possible, it can be more efficient to statically configure shared bottlenecks (e.g., via a system configuration or user input) based on assumptions about the network environment.",
      "ja": "上記の方法には、いくつかの重要なトレードオフがあります。 たとえば、多重化は完全に信頼できる手段ですが、スコープは2つのエンドポイントに制限されます（つまり、1つの送信者の輻輳コントローラーを複数の受信者と通信するために適用することはできません）。 測定ベースのSBDメカニズムは[RFC8382]で説明されています。 特に過去に基づいているため、測定値が100％信頼できることはありませんが、結合された輻輳制御を適用するには、将来についての仮定が必要です。 したがって、たとえば、遅延および/またはパケット損失の大幅な増加を引き起こす場合、結合された輻輳制御を無効にすることにより、注意措置を実装することをお勧めします。 また、測定にも時間がかかります。これには、カップリングをオンにするための一定の遅延が伴います（詳細については[RFC8382]を参照）。 これが可能な場合、ネットワーク環境に関する仮定に基づいて、共有ボトルネックを静的に構成する方が効率的です（たとえば、システム構成またはユーザー入力を介して）。"
    },
    {
      "indent": 0,
      "text": "5.2. FSE",
      "section_title": true,
      "ja": "5.2. FSE"
    },
    {
      "indent": 3,
      "text": "The FSE contains a list of all flows that have registered with it. For each flow, the FSE stores the following:",
      "ja": "FSEには、登録されているすべてのフローのリストが含まれています。 各フローについて、FSEは次を保存します。"
    },
    {
      "indent": 3,
      "text": "* a unique flow number f to identify the flow.",
      "ja": "* フローを識別する一意のフロー番号f。"
    },
    {
      "indent": 3,
      "text": "* the FGI of the FG that it belongs to (based on the definitions in this document, a flow has only one bottleneck and can therefore be in only one FG).",
      "ja": "* 所属するFGのFGI（このドキュメントの定義に基づくと、フローにはボトルネックが1つしかないため、1つのFGにしか存在できません）。"
    },
    {
      "indent": 3,
      "text": "* a priority P(f), which is a number greater than zero.",
      "ja": "* 優先度P（f）。これはゼロより大きい数値です。"
    },
    {
      "indent": 3,
      "text": "* The rate used by the flow in bits per second, FSE_R(f).",
      "ja": "* フローで使用されるレート（ビット/秒、FSE_R（f））。"
    },
    {
      "indent": 3,
      "text": "* The desired rate DR(f) of flow f. This can be smaller than FSE_R(f) if the application feeding into the flow has less data to send than FSE_R(f) would allow or if a maximum value is imposed on the rate. In the absence of such limits, DR(f) must be set to the sending rate provided by the congestion control module of flow f.",
      "ja": "* フローfの望ましいレートDR（f）。 これは、FSE_R（f）が許可するよりもフローにフィードするアプリケーションの送信データが少ない場合、またはレートに最大値が課されている場合、FSE_R（f）より小さくなります。 このような制限がない場合、DR（f）は、フローfの輻輳制御モジュールによって提供される送信レートに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the absolute range of priorities does not matter; the algorithm works with a flow's priority portion of the sum of all priority values. For example, if there are two flows, flow 1 with priority 1 and flow 2 with priority 2, the sum of the priorities is 3. Then, flow 1 will be assigned 1/3 of the aggregate sending rate, and flow 2 will be assigned 2/3 of the aggregate sending rate. Priorities can be mapped to the \"very-low\", \"low\", \"medium\", or \"high\" priority levels described in [WEBRTC-TRANS] by simply using the values 1, 2, 4, and 8, respectively.",
      "ja": "優先順位の絶対範囲は重要ではないことに注意してください。 このアルゴリズムは、すべての優先度値の合計のフローの優先度部分で機能します。 たとえば、優先度1のフロー1と優先度2のフロー2の2つのフローがある場合、優先度の合計は3です。その後、フロー1には集約送信レートの1/3が割り当てられ、フロー2には 集約送信レートの2/3が割り当てられました。 優先度は、それぞれ1、2、4、および8の値を使用するだけで、[WEBRTC-TRANS]で説明されている「非常に低い」、「低」、「中」、または「高」の優先レベルにマッピングできます。"
    },
    {
      "indent": 3,
      "text": "In the FSE, each FG contains one static variable, S_CR, which is the sum of the calculated rates of all flows in the same FG. This value is used to calculate the sending rate.",
      "ja": "FSEでは、各FGに1つの静的変数S_CRが含まれています。これは、同じFG内のすべてのフローの計算されたレートの合計です。 この値は、送信レートの計算に使用されます。"
    },
    {
      "indent": 3,
      "text": "The information listed here is enough to implement the sample flow algorithm given below. FSE implementations could easily be extended to store, e.g., a flow's current sending rate for statistics gathering or future potential optimizations.",
      "ja": "ここにリストされている情報は、以下に示すサンプルフローアルゴリズムを実装するのに十分です。 FSEの実装は、たとえば、統計の収集または将来の潜在的な最適化のためのフローの現在の送信レートを格納するように簡単に拡張できます。"
    },
    {
      "indent": 0,
      "text": "5.3. Flows",
      "section_title": true,
      "ja": "5.3. 流れ"
    },
    {
      "indent": 3,
      "text": "Flows register themselves with SBD and FSE when they start, deregister from the FSE when they stop, and carry out an UPDATE function call every time their congestion controller calculates a new sending rate. Via UPDATE, they provide the newly calculated rate and, optionally (if the algorithm supports it), the desired rate. The desired rate is less than the calculated rate in case of application-limited flows; otherwise, it is the same as the calculated rate.",
      "ja": "フローは、開始時にSBDおよびFSEに自身を登録し、停止時にFSEから登録解除し、輻輳コントローラーが新しい送信レートを計算するたびにUPDATE関数呼び出しを実行します。 UPDATEを介して、新しく計算されたレートと、オプションで（アルゴリズムがサポートしている場合）必要なレートを提供します。 アプリケーション制限フローの場合、望ましいレートは計算されたレートよりも低くなります。 それ以外の場合は、計算されたレートと同じです。"
    },
    {
      "indent": 3,
      "text": "Below, two example algorithms are described. While other algorithms could be used instead, the same algorithm must be applied to all flows. Names of variables used in the algorithms are explained below.",
      "ja": "以下に、2つのアルゴリズム例について説明します。 代わりに他のアルゴリズムを使用できますが、すべてのフローに同じアルゴリズムを適用する必要があります。 アルゴリズムで使用される変数の名前を以下に説明します。"
    },
    {
      "indent": 3,
      "text": "CC_R(f) The rate received from the congestion controller of flow f when it calls UPDATE.",
      "ja": "CC_R（f）フローfの輻輳コントローラーがUPDATEを呼び出したときに受信したレート。"
    },
    {
      "indent": 3,
      "text": "FSE_R(f) The rate calculated by the FSE for flow f.",
      "ja": "FSE_R（f）フローfに対してFSEによって計算されたレート。"
    },
    {
      "indent": 3,
      "text": "DR(f) The desired rate of flow f.",
      "ja": "DR（f）所望の流量f。"
    },
    {
      "indent": 3,
      "text": "S_CR The sum of the calculated rates of all flows in the same FG; this value is used to calculate the sending rate.",
      "ja": "S_CR同じFG内のすべてのフローの計算されたレートの合計。 この値は、送信レートの計算に使用されます。"
    },
    {
      "indent": 3,
      "text": "FG A group of flows having the same FGI and hence, sharing the same bottleneck.",
      "ja": "FG同じFGIを持ち、したがって同じボトルネックを共有するフローのグループ。"
    },
    {
      "indent": 3,
      "text": "P(f) The priority of flow f, which is received from the flow's congestion controller; the FSE uses this variable for calculating FSE_R(f).",
      "ja": "P（f）フローの輻輳コントローラから受信したフローfの優先度。 FSEはこの変数を使用してFSE_R（f）を計算します。"
    },
    {
      "indent": 3,
      "text": "S_P The sum of all the priorities.",
      "ja": "S_Pすべての優先順位の合計。"
    },
    {
      "indent": 3,
      "text": "TLO The total leftover rate; the sum of rates that could not be assigned to flows that were limited by their desired rate.",
      "ja": "TLO総残り率。 目的のレートによって制限されたフローに割り当てられなかったレートの合計。"
    },
    {
      "indent": 3,
      "text": "AR The aggregate rate that is assigned to flows that are not limited by their desired rate.",
      "ja": "AR目的のレートによって制限されないフローに割り当てられる集約レート。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Example Algorithm 1 - Active FSE",
      "section_title": true,
      "ja": "5.3.1. アルゴリズム例1-アクティブFSE"
    },
    {
      "indent": 3,
      "text": "This algorithm was designed to be the simplest possible method to assign rates according to the priorities of flows. Simulation results in [FSE] indicate that it does not, however, significantly reduce queuing delay and packet loss.",
      "ja": "このアルゴリズムは、フローの優先度に従ってレートを割り当てるための最も簡単な方法になるように設計されました。 [FSE]のシミュレーション結果は、キューイング遅延とパケット損失を大幅に削減しないことを示しています。"
    },
    {
      "indent": 3,
      "text": "(1) When a flow f starts, it registers itself with SBD and the FSE. FSE_R(f) is initialized with the congestion controller's initial rate. SBD will assign the correct FGI. When a flow is assigned an FGI, it adds its FSE_R(f) to S_CR.",
      "ja": "（1）フローfが開始されると、SBDおよびFSEに登録されます。 FSE_R（f）は、輻輳コントローラーの初期速度で初期化されます。 SBDは正しいFGIを割り当てます。 フローにFGIが割り当てられると、そのFSE_R（f）がS_CRに追加されます。"
    },
    {
      "indent": 3,
      "text": "(2) When a flow f stops or pauses, its entry is removed from the list.",
      "ja": "（2）フローfが停止または一時停止すると、そのエントリはリストから削除されます。"
    },
    {
      "indent": 3,
      "text": "(3) Every time the congestion controller of the flow f determines a new sending rate CC_R(f), the flow calls UPDATE, which carries out the tasks listed below to derive the new sending rates for all the flows in the FG. A flow's UPDATE function uses three local (i.e., per-flow) temporary variables: S_P, TLO, and AR.",
      "ja": "（3）フローfの輻輳コントローラが新しい送信レートCC_R（f）を決定するたびに、フローはUPDATEを呼び出します。UPDATEは、以下のタスクを実行して、FG内のすべてのフローの新しい送信レートを導き出します。 フローのUPDATE関数は、S_P、TLO、およびARの3つのローカル（つまり、フローごとの）一時変数を使用します。"
    },
    {
      "indent": 8,
      "text": "(a) It updates S_CR.",
      "ja": "（a）S_CRを更新します。"
    },
    {
      "indent": 23,
      "text": "S_CR = S_CR + CC_R(f) - FSE_R(f)",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(b) It calculates the sum of all the priorities, S_P, and initializes FSE_R.",
      "ja": "（b）すべての優先順位の合計S_Pを計算し、FSE_Rを初期化します。"
    },
    {
      "indent": 23,
      "text": "S_P = 0\nfor all flows i in FG do\n    S_P = S_P + P(i)\n    FSE_R(i) = 0\nend for",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(c) It distributes S_CR among all flows, ensuring that each flow's desired rate is not exceeded.",
      "ja": "（c）S_CRをすべてのフローに分配し、各フローの目的のレートを超えないようにします。"
    },
    {
      "indent": 23,
      "text": "TLO = S_CR\nwhile(TLO-AR>0 and S_P>0)\n    AR = 0\n    for all flows i in FG do\n        if FSE_R[i] < DR[i] then\n            if TLO * P[i] / S_P >= DR[i] then\n                TLO = TLO - DR[i]\n                FSE_R[i] = DR[i]\n                S_P = S_P - P[i]\n            else\n                FSE_R[i] = TLO * P[i] / S_P\n                AR = AR + TLO * P[i] / S_P\n            end if\n        end if\n    end for\nend while",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(d) It distributes FSE_R to all the flows.",
      "ja": "（d）FSE_Rをすべてのフローに配布します。"
    },
    {
      "indent": 23,
      "text": "for all flows i in FG do send FSE_R(i) to the flow i end for",
      "ja": "FGのすべてのフローiについて、フローi endにFSE_R（i）を送信します"
    },
    {
      "indent": 0,
      "text": "5.3.2. Example Algorithm 2 - Conservative Active FSE",
      "section_title": true,
      "ja": "5.3.2. アルゴリズム例2-保守的アクティブFSE"
    },
    {
      "indent": 3,
      "text": "This algorithm changes algorithm 1 to conservatively emulate the behavior of a single flow by proportionally reducing the aggregate rate on congestion. Simulation results in [FSE] indicate that it can significantly reduce queuing delay and packet loss.",
      "ja": "このアルゴリズムは、アルゴリズム1を変更して、輻輳時の集約レートを比例的に減らすことにより、単一フローの動作を控えめにエミュレートします。 [FSE]のシミュレーション結果は、キューイング遅延とパケット損失を大幅に削減できることを示しています。"
    },
    {
      "indent": 3,
      "text": "Step (a) of the UPDATE function is changed as described below. This also introduces a local variable DELTA, which is used to calculate the difference between CC_R(f) and the previously stored FSE_R(f). To prevent flows from either ignoring congestion or overreacting, a timer keeps them from changing their rates immediately after the common rate reduction that follows a congestion event. This timer is set to two RTTs of the flow that experienced congestion because it is assumed that a congestion event can persist for up to one RTT of that flow, with another RTT added to compensate for fluctuations in the measured RTT value.",
      "ja": "UPDATE関数のステップ（a）は、次のように変更されます。 これにより、ローカル変数DELTAも導入されます。これは、CC_R（f）と以前に保存されたFSE_R（f）の差を計算するために使用されます。 フローが輻輳を無視したり過剰に反応したりするのを防ぐために、タイマーは、輻輳イベントに続く一般的なレート削減の直後にフローがレートを変更しないようにします。 このタイマーは、輻輳が発生したフローの2つのRTTに設定されます。これは、輻輳イベントがそのフローの最大1つのRTTまで持続し、測定されたRTT値の変動を補正するために別のRTTが追加されることが想定されているためです。"
    },
    {
      "indent": 3,
      "text": "(a) It updates S_CR based on DELTA.",
      "ja": "（a）DELTAに基づいてS_CRを更新します。"
    },
    {
      "indent": 18,
      "text": "if Timer has expired or was not set then\n  DELTA = CC_R(f) - FSE_R(f)\n  if DELTA < 0 then  // Reduce S_CR proportionally\n    S_CR = S_CR * CC_R(f) / FSE_R(f)\n    Set Timer for 2 RTTs\n  else\n    S_CR = S_CR + DELTA\n  end if\n end if",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6. Application",
      "section_title": true,
      "ja": "6. 応用"
    },
    {
      "indent": 3,
      "text": "This section specifies how the FSE can be applied to specific congestion control mechanisms and makes general recommendations that facilitate applying the FSE to future congestion controls.",
      "ja": "このセクションでは、特定の輻輳制御メカニズムにFSEを適用する方法を指定し、将来の輻輳制御へのFSEの適用を促進する一般的な推奨事項を作成します。"
    },
    {
      "indent": 0,
      "text": "6.1. NADA",
      "section_title": true,
      "ja": "6.1. ADA"
    },
    {
      "indent": 3,
      "text": "Network-Assisted Dynamic Adaptation (NADA) [RFC8698] is a congestion control scheme for WebRTC. It calculates a reference rate r_ref upon receiving an acknowledgment and then, based on the reference rate, calculates a video target rate r_vin and a sending rate for the flows, r_send.",
      "ja": "Network-Assisted Dynamic Adaptation（NADA）[RFC8698]は、WebRTCの輻輳制御スキームです。 確認応答を受信すると、参照レートr_refを計算し、その参照レートに基づいて、ビデオターゲットレートr_vinとフローの送信レートr_sendを計算します。"
    },
    {
      "indent": 3,
      "text": "When applying the FSE to NADA, the UPDATE function call described in Section 5.3 gives the FSE NADA's reference rate r_ref. The recommended algorithm for NADA is the Active FSE in Section 5.3.1. In step 3 (d), when the FSE_R(i) is \"sent\" to the flow i, r_ref (r_vin and r_send) of flow i is updated with the value of FSE_R(i).",
      "ja": "FSEをNADAに適用する場合、5.3項で説明するUPDATE関数呼び出しは、FSE NADAの参照レートr_refを提供します。 NADAの推奨アルゴリズムは、セクション5.3.1のアクティブFSEです。 ステップ3（d）で、FSE_R（i）がフローiに「送信」されると、フローiのr_ref（r_vinおよびr_send）がFSE_R（i）の値で更新されます。"
    },
    {
      "indent": 0,
      "text": "6.2. General Recommendations",
      "section_title": true,
      "ja": "6.2. 一般的な推奨事項"
    },
    {
      "indent": 3,
      "text": "This section provides general advice for applying the FSE to congestion control mechanisms.",
      "ja": "このセクションでは、輻輳制御メカニズムにFSEを適用するための一般的なアドバイスを提供します。"
    },
    {
      "indent": 3,
      "text": "Receiver-side calculations: When receiver-side calculations make assumptions about the rate of the sender, the calculations need to be synchronized, or the receiver needs to be updated accordingly. This applies to TCP Friendly Rate Control (TFRC) [RFC5348], for example, where simulations showed somewhat less favorable results when using the FSE without a receiver-side change [FSE].",
      "ja": "受信側の計算：受信側の計算が送信者のレートについて仮定する場合、計算を同期する必要があるか、受信者をそれに応じて更新する必要があります。 これは、例えば、TCPフレンドリーレートコントロール（TFRC）[RFC5348]に適用されます。この場合、レシーバー側の変更[FSE]なしでFSEを使用する場合、シミュレーションはやや好ましくない結果を示しました。"
    },
    {
      "indent": 3,
      "text": "Stateful algorithms: When a congestion control algorithm is stateful (e.g., during the TCP slow start, congestion avoidance, or fast recovery phase), these states should be carefully considered such that the overall state of the aggregate flow is correct. This may require sharing more information in the UPDATE call.",
      "ja": "ステートフルアルゴリズム：輻輳制御アルゴリズムがステートフルの場合（たとえば、TCPスロースタート、輻輳回避、または高速回復フェーズ中）、これらの状態は、集約フローの全体的な状態が正しいように慎重に検討する必要があります。 これには、UPDATE呼び出しでより多くの情報を共有する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Rate jumps: The FSE-based coupling algorithms can let a flow quickly increase its rate to its fair share, e.g., when a new flow joins or after a quiescent period. In case of window-based congestion controls, this may produce a burst that should be mitigated in some way. An example of how this could be done without using a timer is presented in [ANRW2016], using TCP as an example.",
      "ja": "レートのジャンプ：FSEベースのカップリングアルゴリズムにより、フローは、たとえば新しいフローが参加したとき、または休止期間の後に、公平な割合までフローをすばやく増加させることができます。 ウィンドウベースの輻輳制御の場合、これは何らかの方法で軽減する必要があるバーストを生成する可能性があります。 例としてTCPを使用して、タイマーを使用せずにこれを実行する方法の例を[ANRW2016]に示します。"
    },
    {
      "indent": 0,
      "text": "7. Expected Feedback from Experiments",
      "section_title": true,
      "ja": "7. 実験から期待されるフィードバック"
    },
    {
      "indent": 3,
      "text": "The algorithm described in this memo has so far been evaluated using simulations covering all the tests for more than one flow from [RMCAT-PROPOSALS] (see [IETF-93] and [IETF-94]). Experiments should confirm these results using at least the NADA congestion control algorithm with real-life code (e.g., browsers communicating over an emulated network covering the conditions in [RMCAT-PROPOSALS]). The tests with real-life code should be repeated afterwards in real network environments and monitored. Experiments should investigate cases where the media coder's output rate is below the rate that is calculated by the coupling algorithm (FSE_R(i) in algorithms 1 (Section 5.3.1) and 2 (Section 5.3.2)). Implementers and testers are invited to document their findings in an Internet-Draft.",
      "ja": "このメモで説明されているアルゴリズムは、これまでに[RMCAT-PROPOSALS]からの複数のフローのすべてのテストをカバーするシミュレーションを使用して評価されました（[IETF-93]および[IETF-94]を参照）。 実験では、少なくともNADA輻輳制御アルゴリズムと実際のコードを使用してこれらの結果を確認する必要があります（たとえば、[RMCAT-PROPOSALS]の条件をカバーするエミュレートネットワークで通信するブラウザ）。 その後、実際のコードを使用したテストを実際のネットワーク環境で繰り返し、監視する必要があります。 実験では、メディアコーダーの出力レートがカップリングアルゴリズム（アルゴリズム1（セクション5.3.1）および2（セクション5.3.2）のFSE_R（i））によって計算されるレートを下回る場合を調査する必要があります。 実装者とテスターは、インターネットドラフトで結果を文書化するように招待されています。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In scenarios where the architecture described in this document is applied across applications, various cheating possibilities arise, e.g., supporting wrong values for the calculated rate, desired rate, or priority of a flow. In the worst case, such cheating could either prevent other flows from sending or make them send at a rate that is unreasonably large. The end result would be unfair behavior at the network bottleneck, akin to what could be achieved with any UDP-based application. Hence, since this is no worse than UDP in general, there seems to be no significant harm in using this in the absence of UDP rate limiters.",
      "ja": "このドキュメントで説明されているアーキテクチャがアプリケーション全体に適用されるシナリオでは、さまざまな不正行為の可能性が生じます。たとえば、計算されたレート、望ましいレート、またはフローの優先度の誤った値をサポートします。 最悪の場合、そのような不正行為は、他のフローの送信を妨げるか、不当に大きいレートで送信する可能性があります。 最終的な結果は、ネットワークのボトルネックでの不公平な振る舞いになり、UDPベースのアプリケーションで達成できることと似ています。 したがって、これは一般にUDPよりも悪くないため、UDPレートリミッターがなくてもこれを使用しても大きな害はないようです。"
    },
    {
      "indent": 3,
      "text": "In the case of a single-user system, it should also be in the interest of any application programmer to give the user the best possible experience by using reasonable flow priorities or even letting the user choose them. In a multi-user system, this interest may not be given, and one could imagine the worst case of an \"arms race\" situation where applications end up setting their priorities to the maximum value. If all applications do this, the end result is a fair allocation in which the priority mechanism is implicitly eliminated and no major harm is done.",
      "ja": "シングルユーザーシステムの場合、合理的なフロー優先順位を使用するか、ユーザーにそれらを選択させることによって、ユーザーに可能な限り最高のエクスペリエンスを提供することは、アプリケーションプログラマーの利益にもなります。 マルチユーザーシステムでは、この関心は与えられない可能性があり、アプリケーションが最終的に優先順位を最大値に設定する「軍拡競争」状況の最悪のケースを想像できます。 すべてのアプリケーションがこれを行う場合、最終結果は公平な割り当てになり、優先度メカニズムが暗黙的に削除され、大きな損害は発生しません。"
    },
    {
      "indent": 3,
      "text": "Implementers should also be aware of the Security Considerations sections of [RFC3124], [RFC5348], and [RFC7478].",
      "ja": "実装者は、[RFC3124]、[RFC5348]、および[RFC7478]のセキュリティに関する考慮事項セクションにも注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion Manager\", RFC 3124, DOI 10.17487/RFC3124, June 2001, <https://www.rfc-editor.org/info/rfc3124>.",
      "ja": "[RFC3124]バラクリシュナン、H。およびS.セシャン、「輻輳マネージャー」、RFC 3124、DOI 10.17487 / RFC3124、2001年6月、<https://www.rfc-editor.org/info/rfc3124>。"
    },
    {
      "indent": 3,
      "text": "[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, \"TCP Friendly Rate Control (TFRC): Protocol Specification\", RFC 5348, DOI 10.17487/RFC5348, September 2008, <https://www.rfc-editor.org/info/rfc5348>.",
      "ja": "[RFC5348]フロイド、S。、ハンドリー、M。、パディ、J。、およびJ.ウィドマー、「TCPフレンドリーレートコントロール（TFRC）：プロトコル仕様」、RFC 5348、DOI 10.17487 / RFC5348、2008年9月、<https： //www.rfc-editor.org/info/rfc5348>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8698] Zhu, X., Pan, R., Ramalho, M., and S. Mena, \"Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control Scheme for Real-Time Media\", RFC 8698, DOI 10.17487/RFC8698, January 2020, <https://www.rfc-editor.org/info/rfc8698>.",
      "ja": "[RFC8698] Zhu、X.、Pan、R.、Ramalho、M。、およびS. Mena、「ネットワーク支援動的適応（NADA）：リアルタイムメディア用の統合輻輳制御方式」、RFC 8698、DOI 10.17487 / RFC8698、2020年1月、<https://www.rfc-editor.org/info/rfc8698>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ANRW2016] Islam, S. and M. Welzl, \"Start Me Up: Determining and Sharing TCP's Initial Congestion Window\", ACM, IRTF, ISOC Applied Networking Research Workshop 2016 (ANRW 2016), DOI 10.1145/2959424.2959440, Proceedings of the 2016 Applied Networking Research Workshop Pages 52-54, July 2016, <https://doi.org/10.1145/2959424.2959440>.",
      "ja": "[ANRW2016] Islam、S.およびM. Welzl、「Start Me Up：TCPの初期輻輳ウィンドウの決定と共有」、ACM、IRTF、ISOC Applied Networking Research Workshop 2016（ANRW 2016）、DOI 10.1145 / 2959424.2959440、Proceedings of the 2016 Applied Networking Research Workshop Pages 52-54、July 2016、<https://doi.org/10.1145/2959424.2959440>。"
    },
    {
      "indent": 3,
      "text": "[FSE] Islam, S., Welzl, M., Gjessing, S., and N. Khademi, \"Coupled Congestion Control for RTP Media\", ACM SIGCOMM Capacity Sharing Workshop (CSWS 2014) and ACM SIGCOMM CCR 44(4) 2014, March 2014, <http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf>.",
      "ja": "[FSE] Islam、S.、Welzl、M.、Gjessing、S.、and N. Khademi、 \"Coupled Congestion Control for RTP Media\"、ACM SIGCOMM Capacity Sharing Workshop（CSWS 2014）and ACM SIGCOMM CCR 44（4）2014 、2014年3月、<http://safiquli.at.ifi.uio.no/paper/fse-tech-report.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FSE-NOMS] Islam, S., Welzl, M., Hayes, D., and S. Gjessing, \"Managing real-time media flows through a flow state exchange\", IEEE NOMS 2016, DOI 10.1109/NOMS.2016.7502803, <https://doi.org/10.1109/NOMS.2016.7502803>.",
      "ja": "[FSE-NOMS] Islam、S.、Welzl、M.、Hayes、D.、and S.Gjessing、 \"Managing real-time media flow through flow state exchange\"、IEEE NOMS 2016、DOI 10.1109 / NOMS.2016.7502803、 <https://doi.org/10.1109/NOMS.2016.7502803>。"
    },
    {
      "indent": 3,
      "text": "[GCC-RTCWEB] Holmer, S., Lundin, H., Carlucci, G., Cicco, L., and S. Mascolo, \"A Google Congestion Control Algorithm for Real-Time Communication\", Work in Progress, Internet-Draft, draft-ietf-rmcat-gcc-02, 8 July 2016, <https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>.",
      "ja": "[GCC-RTCWEB] Holmer、S.、Lundin、H.、Carlucci、G.、Cicco、L。、およびS. Mascolo、「リアルタイム通信のためのGoogle輻輳制御アルゴリズム」、Work in Progress、インターネットドラフト 、draft-ietf-rmcat-gcc-02、2016年7月8日、<https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02>。"
    },
    {
      "indent": 3,
      "text": "[IETF-93] Islam, S., Welzl, M., and S. Gjessing, \"Updates on 'Coupled Congestion Control for RTP Media'\", RTP Media Congestion Avoidance Techniques (rmcat) Working Group, IETF 93, July 2015, <https://www.ietf.org/proceedings/93/rmcat.html>.",
      "ja": "[IETF-93] Islam、S.、Welzl、M。、およびS. Gjessing、「「RTPメディアの結合輻輳制御」の更新」、RTPメディア輻輳回避手法（rmcat）ワーキンググループ、IETF 93、2015年7月、 <https://www.ietf.org/proceedings/93/rmcat.html>。"
    },
    {
      "indent": 3,
      "text": "[IETF-94] Islam, S., Welzl, M., and S. Gjessing, \"Updates on 'Coupled Congestion Control for RTP Media'\", RTP Media Congestion Avoidance Techniques (rmcat) Working Group, IETF 94, November 2015, <https://www.ietf.org/proceedings/94/rmcat.html>.",
      "ja": "[IETF-94] Islam、S.、Welzl、M。、およびS. Gjessing、「「TPPメディアの輻輳制御の結合」に関する更新」、RTPメディア輻輳回避手法（rmcat）ワーキンググループ、IETF 94、2015年11月、 <https://www.ietf.org/proceedings/94/rmcat.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC7478] Holmberg, C., Hakansson, S., and G. Eriksson, \"Web Real-Time Communication Use Cases and Requirements\", RFC 7478, DOI 10.17487/RFC7478, March 2015, <https://www.rfc-editor.org/info/rfc7478>.",
      "ja": "[RFC7478] Holmberg、C.、Hakansson、S。、およびG. Eriksson、「Webリアルタイム通信の使用例と要件」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、<https：//www.rfc- editor.org/info/rfc7478>。"
    },
    {
      "indent": 3,
      "text": "[RFC7656] Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and B. Burman, Ed., \"A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources\", RFC 7656, DOI 10.17487/RFC7656, November 2015, <https://www.rfc-editor.org/info/rfc7656>.",
      "ja": "[RFC7656] Lennox、J.、Gross、K.、Nandakumar、S.、Salgueiro、G。、およびB. Burman、Ed。、「リアルタイムトランスポートプロトコル（RTP）ソースのセマンティクスおよびメカニズムの分類」、 RFC 7656、DOI 10.17487 / RFC7656、2015年11月、<https://www.rfc-editor.org/info/rfc7656>。"
    },
    {
      "indent": 3,
      "text": "[RFC8087] Fairhurst, G. and M. Welzl, \"The Benefits of Using Explicit Congestion Notification (ECN)\", RFC 8087, DOI 10.17487/RFC8087, March 2017, <https://www.rfc-editor.org/info/rfc8087>.",
      "ja": "[RFC8087] Fairhurst、G.およびM. Welzl、「明示的輻輳通知（ECN）を使用する利点」、RFC 8087、DOI 10.17487 / RFC8087、2017年3月、<https://www.rfc-editor.org/info / rfc8087>。"
    },
    {
      "indent": 3,
      "text": "[RFC8382] Hayes, D., Ed., Ferlin, S., Welzl, M., and K. Hiorth, \"Shared Bottleneck Detection for Coupled Congestion Control for RTP Media\", RFC 8382, DOI 10.17487/RFC8382, June 2018, <https://www.rfc-editor.org/info/rfc8382>.",
      "ja": "[RFC8382] Hayes、D.、Ed。、Ferlin、S.、Welzl、M.、およびK. Hiorth、 \"RTP Mediaの結合輻輳制御のための共有ボトルネック検出\"、RFC 8382、DOI 10.17487 / RFC8382、June 2018、 <https://www.rfc-editor.org/info/rfc8382>。"
    },
    {
      "indent": 3,
      "text": "[RMCAT-PROPOSALS] Sarker, Z., Singh, V., Zhu, X., and M. Ramalho, \"Test Cases for Evaluating RMCAT Proposals\", Work in Progress, Internet-Draft, draft-ietf-rmcat-eval-test-10, 23 May 2019, <https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10>.",
      "ja": "[RMCAT-PROPOSALS] Sarker、Z.、Singh、V.、Zhu、X。、およびM. Ramalho、「RMCAT提案を評価するためのテストケース」、Work in Progress、Internet-Draft、draft-ietf-rmcat-eval- test-10、2019年5月23日、<https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-10>"
    },
    {
      "indent": 3,
      "text": "[RTCWEB-OVERVIEW] Alvestrand, H., \"Overview: Real Time Protocols for Browser-based Applications\", Work in Progress, Internet-Draft, draft-ietf-rtcweb-overview-19, 11 November 2017, <https://tools.ietf.org/html/draft-ietf-rtcweb-overview-19>.",
      "ja": "[RTCWEB-OVERVIEW] Alvestrand、H.、「概要：ブラウザーベースのアプリケーションのリアルタイムプロトコル」、Work in Progress、Internet-Draft、draft-ietf-rtcweb-overview-19、2017年11月11日、<https：// tools.ietf.org/html/draft-ietf-rtcweb-overview-19>。"
    },
    {
      "indent": 3,
      "text": "[RTCWEB-RTP-USAGE] Perkins, C., Westerlund, M., and J. Ott, \"Web Real-Time Communication (WebRTC): Media Transport and Use of RTP\", Work in Progress, Internet-Draft, draft-ietf-rtcweb-rtp-usage-26, 17 March 2016, <https://tools.ietf.org/html/ draft-ietf-rtcweb-rtp-usage-26>.",
      "ja": "[RTCWEB-RTP-USAGE] Perkins、C.、Westerlund、M。、およびJ. Ott、「Web Real-Time Communication（WebRTC）：メディア転送とRTPの使用」、Work in Progress、Internet-Draft、draft- ietf-rtcweb-rtp-usage-26、2016年3月17日、<https://tools.ietf.org/html/ draft-ietf-rtcweb-rtp-usage-26>。"
    },
    {
      "indent": 3,
      "text": "[TRANSPORT-MULTIPLEX] Westerlund, M. and C. Perkins, \"Multiple RTP Sessions on a Single Lower-Layer Transport\", Work in Progress, Internet-Draft, draft-westerlund-avtcore-transport-multiplexing-07, October 2013, <https://tools.ietf.org/html/draft-westerlund-avtcore-transport-multiplexing-07>.",
      "ja": "[TRANSPORT-MULTIPLEX] Westerlund、M。、およびC. Perkins、「単一の下位層トランスポートでの複数のRTPセッション」、Work in Progress、Internet-Draft、draft-westerlund-avtcore-transport-multiplexing-07、2013年10月、 <https://tools.ietf.org/html/draft-westerlund-avtcore-transport-multiplexing-07>。"
    },
    {
      "indent": 3,
      "text": "[WEBRTC-TRANS] Alvestrand, H., \"Transports for WebRTC\", Work in Progress, Internet-Draft, draft-ietf-rtcweb-transports-17, 26 October 2016, <https://tools.ietf.org/html/draft-ietf-rtcweb-transports-17>.",
      "ja": "[WEBRTC-TRANS] Alvestrand、H。、「Transports for WebRTC」、Work in Progress、インターネットドラフト、draft-ietf-rtcweb-transports-17、2016年10月26日、<https://tools.ietf.org/html / draft-ietf-rtcweb-transports-17>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Application to GCC",
      "section_title": true,
      "ja": "付録A. GCCへの適用"
    },
    {
      "indent": 3,
      "text": "Google Congestion Control (GCC) [GCC-RTCWEB] is another congestion control scheme for RTP flows that is under development. GCC is not yet finalized, but at the time of this writing, the rate control of GCC employs two parts: controlling the bandwidth estimate based on delay and controlling the bandwidth estimate based on loss. Both are designed to estimate the available bandwidth, A_hat.",
      "ja": "Google輻輳制御（GCC）[GCC-RTCWEB]は、開発中のRTPフロー用の別の輻輳制御スキームです。 GCCはまだ確定していませんが、この記事の執筆時点では、GCCのレート制御は2つの部分を使用しています。遅延に基づく帯域幅推定の制御と損失に基づく帯域幅推定の制御です。 両方とも、利用可能な帯域幅A_hatを推定するように設計されています。"
    },
    {
      "indent": 3,
      "text": "When applying the FSE to GCC, the UPDATE function call described in Section 5.3 gives the FSE GCC's estimate of available bandwidth A_hat. The recommended algorithm for GCC is the Active FSE in Section 5.3.1. In step 3 (d) of this algorithm, when the FSE_R(i) is \"sent\" to the flow i, A_hat of flow i is updated with the value of FSE_R(i).",
      "ja": "FSEをGCCに適用する場合、セクション5.3で説明されているUPDATE関数呼び出しは、FSE GCCの利用可能な帯域幅A_hatの推定値を提供します。 GCCの推奨アルゴリズムは、セクション5.3.1のアクティブFSEです。 このアルゴリズムのステップ3（d）では、FSE_R（i）がフローiに「送信」されると、フローiのA_hatがFSE_R（i）の値で更新されます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Scheduling",
      "section_title": true,
      "ja": "付録B.スケジューリング"
    },
    {
      "indent": 3,
      "text": "When flows originate from the same host, it would be possible to use only one sender-side congestion controller that determines the overall allowed sending rate and then use a local scheduler to assign a proportion of this rate to each RTP session. This way, priorities could also be implemented as a function of the scheduler. The Congestion Manager (CM) [RFC3124] also uses such a scheduling function.",
      "ja": "フローが同じホストから発信される場合、全体の許可された送信レートを決定する送信側の輻輳コントローラーを1つだけ使用し、ローカルスケジューラを使用してこのレートの割合を各RTPセッションに割り当てることができます。 このように、優先度はスケジューラの機能として実装することもできます。 Congestion Manager（CM）[RFC3124]もそのようなスケジューリング機能を使用します。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Algorithm - Passive FSE",
      "section_title": true,
      "ja": "付録C.アルゴリズムの例-パッシブFSE"
    },
    {
      "indent": 3,
      "text": "Active algorithms calculate the rates for all the flows in the FG and actively distribute them. In a passive algorithm, UPDATE returns a rate that should be used instead of the rate that the congestion controller has determined. This can make a passive algorithm easier to implement; however, when round-trip times of flows are unequal, flows with shorter RTTs may (depending on the congestion control algorithm) update and react to the overall FSE state more often than flows with longer RTTs, which can produce unwanted side effects. This problem is more significant when the congestion control convergence depends on the RTT. While the passive algorithm works better for congestion controls with RTT-independent convergence, it can still produce oscillations on short time scales. The algorithm described below is therefore considered highly experimental and not safe to deploy outside of testbed environments. Results of a simplified passive FSE algorithm with both NADA and GCC can be found in [FSE-NOMS].",
      "ja": "アクティブアルゴリズムは、FG内のすべてのフローのレートを計算し、それらをアクティブに配布します。パッシブアルゴリズムでは、UPDATEは、輻輳コントローラが決定したレートの代わりに使用するレートを返します。これにより、パッシブアルゴリズムの実装が容易になります。ただし、フローの往復時間が等しくない場合、RTTの短いフローは（輻輳制御アルゴリズムに応じて）更新され、RTTの長いフローよりもFSEの状態全体に頻繁に反応し、望ましくない副作用を引き起こす可能性があります。この問題は、輻輳制御の収束がRTTに依存している場合により重大になります。パッシブアルゴリズムは、RTTに依存しないコンバージェンスを使用した輻輳制御に適していますが、それでも短い時間スケールで振動を生成する可能性があります。したがって、以下で説明するアルゴリズムは非常に実験的であると見なされており、テストベッド環境外に展開するのは安全ではありません。 NADAとGCCの両方を使用した単純化されたパッシブFSEアルゴリズムの結果は、[FSE-NOMS]にあります。"
    },
    {
      "indent": 3,
      "text": "In the passive version of the FSE, TLO (Total Leftover Rate) is a static variable per FG that is initialized to 0. Additionally, S_CR is limited to increase or decrease as conservatively as a flow's congestion controller decides in order to prohibit sudden rate jumps.",
      "ja": "FSEのパッシブバージョンでは、TLO（Total Leftover Rate）は0に初期化されるFGごとの静的変数です。さらに、S_CRは、突然のレートジャンプを禁止するためにフローの輻輳コントローラーが決定するのと同じくらい控えめに増減するように制限されています 。"
    },
    {
      "indent": 3,
      "text": "(1) When a flow f starts, it registers itself with SBD and the FSE. FSE_R(f) and DR(f) are initialized with the congestion controller's initial rate. SBD will assign the correct FGI. When a flow is assigned an FGI, it adds its FSE_R(f) to S_CR.",
      "ja": "（1）フローfが開始されると、SBDおよびFSEに登録されます。 FSE_R（f）およびDR（f）は、輻輳コントローラーの初期速度で初期化されます。 SBDは正しいFGIを割り当てます。 フローにFGIが割り当てられると、そのFSE_R（f）がS_CRに追加されます。"
    },
    {
      "indent": 3,
      "text": "(2) When a flow f stops or pauses, it sets its DR(f) to 0 and sets P(f) to -1.",
      "ja": "（2）フローfが停止または一時停止すると、そのDR（f）を0に設定し、P（f）を-1に設定します。"
    },
    {
      "indent": 3,
      "text": "(3) Every time the congestion controller of the flow f determines a new sending rate CC_R(f), assuming the flow's new desired rate new_DR(f) to be \"infinity\" in case of a bulk data transfer with an unknown maximum rate, the flow calls UPDATE, which carries out the tasks listed below to derive the flow's new sending rate, Rate(f). A flow's UPDATE function uses a few local (i.e., per-flow) temporary variables, which are all initialized to 0: DELTA, new_S_CR, and S_P.",
      "ja": "（3）フローfの輻輳コントローラーが新しい送信レートCC_R（f）を決定するたびに、未知の最大レートでのバルクデータ転送の場合、フローの新しい望ましいレートnew_DR（f）が「無限」であると仮定し、 フローはUPDATEを呼び出します。UPDATEは、以下にリストされているタスクを実行して、フローの新しい送信レートRate（f）を導き出します。 フローのUPDATE関数は、いくつかのローカル（つまり、フローごと）の一時変数を使用します。これらはすべて0に初期化されます：DELTA、new_S_CR、およびS_P。"
    },
    {
      "indent": 8,
      "text": "(a) For all the flows in its FG (including itself), it calculates the sum of all the calculated rates, new_S_CR. Then, it calculates DELTA: the difference between FSE_R(f) and CC_R(f).",
      "ja": "（a）FG内のすべてのフロー（それ自体を含む）について、計算されたすべてのレートの合計new_S_CRを計算します。 次に、DELTA：FSE_R（f）とCC_R（f）の差を計算します。"
    },
    {
      "indent": 21,
      "text": "for all flows i in FG do\n    new_S_CR = new_S_CR + FSE_R(i)\nend for\nDELTA =  CC_R(f) - FSE_R(f)",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(b) It updates S_CR, FSE_R(f), and DR(f).",
      "ja": "（b）S_CR、FSE_R（f）、およびDR（f）を更新します。"
    },
    {
      "indent": 21,
      "text": "FSE_R(f) = CC_R(f)\nif DELTA > 0 then  // the flow's rate has increased\n    S_CR = S_CR + DELTA\nelse if DELTA < 0 then\n    S_CR = new_S_CR + DELTA\nend if\nDR(f) = min(new_DR(f),FSE_R(f))",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(c) It calculates the leftover rate TLO, removes the terminated flows from the FSE, and calculates the sum of all the priorities, S_P.",
      "ja": "（c）残りレートTLOを計算し、FSEから終了したフローを削除し、すべての優先順位の合計S_Pを計算します。"
    },
    {
      "indent": 23,
      "text": "for all flows i in FG do\n   if P(i)<0 then\n      delete flow\n   else\n      S_P = S_P + P(i)\n   end if\nend for\nif DR(f) < FSE_R(f) then\n   TLO = TLO + (P(f)/S_P) * S_CR - DR(f))\nend if",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(d) It calculates the sending rate, Rate(f).",
      "ja": "（d）送信レートRate（f）を計算します。"
    },
    {
      "indent": 23,
      "text": "Rate(f) = min(new_DR(f), (P(f)*S_CR)/S_P + TLO)",
      "raw": true
    },
    {
      "indent": 23,
      "text": "if Rate(f) != new_DR(f) and TLO > 0 then\n    TLO = 0  // f has 'taken' TLO\nend if",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(e) It updates DR(f) and FSE_R(f) with Rate(f).",
      "ja": "（e）DR（f）およびFSE_R（f）をRate（f）で更新します。"
    },
    {
      "indent": 23,
      "text": "if Rate(f) > DR(f) then\n    DR(f) = Rate(f)\nend if\nFSE_R(f)  = Rate(f)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The goals of the flow algorithm are to achieve prioritization, improve network utilization in the face of application-limited flows, and impose limits on the increase behavior such that the negative impact of multiple flows trying to increase their rate together is minimized. It does that by assigning a flow a sending rate that may not be what the flow's congestion controller expected. It therefore builds on the assumption that no significant inefficiencies arise from temporary application-limited behavior or from quickly jumping to a rate that is higher than the congestion controller intended. How problematic these issues really are depends on the controllers in use and requires careful per-controller experimentation. The coupled congestion control mechanism described here also does not require all controllers to be equal; effects of heterogeneous controllers, or homogeneous controllers being in different states, are also subject to experimentation.",
      "ja": "フローアルゴリズムの目標は、優先順位付けを達成し、アプリケーションが制限されたフローに直面してネットワークの使用率を改善し、複数のフローが一緒に速度を上げようとする悪影響が最小限になるように、増加動作に制限を課すことです。 それは、フローの輻輳コントローラーが予期したものではないかもしれない送信レートをフローに割り当てることによってそれを行います。 したがって、一時的なアプリケーション制限の動作や、輻輳コントローラーが意図したよりも高いレートにすばやくジャンプしても、重大な非効率性は発生しないという前提に基づいています。 これらの問題の実際の問題点は、使用中のコントローラーによって異なり、コントローラーごとの慎重な実験が必要です。 ここで説明する結合された輻輳制御メカニズムでは、すべてのコントローラーが同じである必要はありません。 異種コントローラ、または異なる状態にある同種コントローラの効果も実験の対象となります。"
    },
    {
      "indent": 3,
      "text": "This algorithm gives the leftover rate of application-limited flows to the first flow that updates its sending rate, provided that this flow needs it all (otherwise, its own leftover rate can be taken by the next flow that updates its rate). Other policies could be applied, e.g., to divide the leftover rate of a flow equally among all other flows in the FGI.",
      "ja": "このアルゴリズムは、アプリケーション制限フローの残り率を、送信率を更新する最初のフローに与えます（このフローがすべてを必要とする場合）（そうでない場合、独自の残り率は、その率を更新する次のフローで取得できます）。 例えば、フローの残り率をFGI内の他のすべてのフローに均等に分割するために、他のポリシーを適用できます。"
    },
    {
      "indent": 0,
      "text": "C.1. Example Operation (Passive)",
      "section_title": true,
      "ja": "C.1. 操作例（パッシブ）"
    },
    {
      "indent": 3,
      "text": "In order to illustrate the operation of the passive coupled congestion control algorithm, this section presents a toy example of two flows that use it. Let us assume that both flows traverse a common 10 Mbit/s bottleneck and use a simplistic congestion controller that starts out with 1 Mbit/s, increases its rate by 1 Mbit/s in the absence of congestion, and decreases it by 2 Mbit/s in the presence of congestion. For simplicity, flows are assumed to always operate in a round-robin fashion. Rate numbers below without units are assumed to be in Mbit/s. For illustration purposes, the actual sending rate is also shown for every flow in FSE diagrams even though it is not really stored in the FSE.",
      "ja": "受動的結合輻輳制御アルゴリズムの動作を説明するために、このセクションでは、それを使用する2つのフローのおもちゃの例を示します。 両方のフローが共通の10 Mbit / sボトルネックを通過し、1 Mbit / sで開始し、輻輳がない場合に1 Mbit / sでレートを上げ、2 Mbit / sでレートを下げる単純な輻輳コントローラを使用すると仮定します。 輻輳がある場合。 簡単にするために、フローは常にラウンドロビン方式で動作すると想定されています。 以下の単位なしのレート番号は、Mbit / sであると想定されます。 実例として、実際の送信レートは、実際にはFSEに保存されていなくても、FSEダイアグラムのすべてのフローに対して表示されます。"
    },
    {
      "indent": 3,
      "text": "Flow #1 begins. It is a bulk data transfer and considers itself to have top priority. This is the FSE after the flow algorithm's step 1:",
      "ja": "フロー＃1が始まります。 バルクデータ転送であり、それ自体が最優先事項であると見なされます。 これは、フローアルゴリズムのステップ1の後のFSEです。"
    },
    {
      "indent": 3,
      "text": "----------------------------------------\n| # | FGI |  P  | FSE_R  |  DR  | Rate |\n|   |     |     |        |      |      |\n| 1 |  1  |  1  |   1    |   1  |   1  |\n----------------------------------------\nS_CR = 1, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Its congestion controller gradually increases its rate. Eventually, at some point, the FSE should look like this:",
      "ja": "輻輳コントローラは、そのレートを徐々に増やします。 最終的に、ある時点で、FSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-----------------------------------------\n| # | FGI |  P  |  FSE_R  |  DR  | Rate |\n|   |     |     |         |      |      |\n| 1 |  1  |  1  |   10    |  10  |  10  |\n-----------------------------------------\nS_CR = 10, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, another flow joins. It is also a bulk data transfer and has a lower priority (0.5):",
      "ja": "ここで、別のフローが参加します。 また、バルクデータ転送であり、優先度は低くなります（0.5）："
    },
    {
      "indent": 3,
      "text": "------------------------------------------\n| # | FGI |   P   | FSE_R  |  DR  | Rate |\n|   |     |       |        |      |      |\n| 1 |  1  |   1   |   10   |  10  |  10  |\n| 2 |  1  |  0.5  |    1   |   1  |   1  |\n------------------------------------------\nS_CR = 11, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, assume that the first flow updates its rate to 8, because the total sending rate of 11 exceeds the total capacity. Let us take a closer look at what happens in step 3 of the flow algorithm.",
      "ja": "ここで、11の合計送信レートが合計容量を超えているため、最初のフローがレートを8に更新すると仮定します。 フローアルゴリズムのステップ3で何が起こるかを詳しく見てみましょう。"
    },
    {
      "indent": 3,
      "text": "CC_R(1) = 8. new_DR(1) = infinity.",
      "ja": "CC_R（1）=8。new_DR（1）=無限。"
    },
    {
      "indent": 3,
      "text": "(3a) new_S_CR = 11; DELTA = 8 - 10 = -2.",
      "ja": "（3a）new_S_CR = 11; デルタ= 8-10 = -2。"
    },
    {
      "indent": 3,
      "text": "(3b)  FSE_R(1) = 8.  DELTA is negative, hence S_CR = 9; DR(1) = 8",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(3c) S_P = 1.5.",
      "ja": "（3c）S_P = 1.5。"
    },
    {
      "indent": 3,
      "text": "(3d) new sending rate Rate(1) = min(infinity, 1/1.5 * 9 + 0) = 6.",
      "ja": "（3d）新しい送信レートRate（1）= min（infinity、1 / 1.5 * 9 + 0）= 6。"
    },
    {
      "indent": 3,
      "text": "(3e) FSE_R(1) = 6.",
      "ja": "（3e）FSE_R（1）= 6。"
    },
    {
      "indent": 3,
      "text": "The resulting FSE looks as follows:",
      "ja": "結果のFSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------\n| # | FGI |   P   |  FSE_R  |  DR  | Rate |\n|   |     |       |         |      |      |\n| 1 |  1  |   1   |    6    |   8  |   6  |\n| 2 |  1  |  0.5  |    1    |   1  |   1  |\n-------------------------------------------\nS_CR = 9, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The effect is that flow #1 is sending with 6 Mbit/s instead of the 8 Mbit/s that the congestion controller derived. Let us now assume that flow #2 updates its rate. Its congestion controller detects that the network is not fully saturated (the actual total sending rate is 6+1=7) and increases its rate.",
      "ja": "その結果、フロー＃1は、輻輳コントローラーが導出した8 Mbit / sではなく6 Mbit / sで送信します。 フロー＃2がそのレートを更新すると仮定しましょう。 輻輳コントローラは、ネットワークが完全に飽和していないことを検出し（実際の合計送信レートは6 + 1 = 7です）、そのレートを上げます。"
    },
    {
      "indent": 3,
      "text": "CC_R(2) = 2. new_DR(2) = infinity.",
      "ja": "CC_R（2）=2。new_DR（2）=無限。"
    },
    {
      "indent": 3,
      "text": "(3a) new_S_CR = 7; DELTA = 2 - 1 = 1.",
      "ja": "（3a）new_S_CR = 7; DELTA = 2-1 = 1。"
    },
    {
      "indent": 3,
      "text": "(3b) FSE_R(2) = 2. DELTA is positive, hence S_CR = 9 + 1 = 10; DR(2) = 2.",
      "ja": "（3b）FSE_R（2）=2。デルタは正であるため、S_CR = 9 + 1 = 10。 DR（2）= 2。"
    },
    {
      "indent": 3,
      "text": "(3c) S_P = 1.5.",
      "ja": "（3c）S_P = 1.5。"
    },
    {
      "indent": 3,
      "text": "(3d) Rate(2) = min(infinity, 0.5/1.5 * 10 + 0) = 3.33.",
      "ja": "（3d）Rate（2）= min（infinity、0.5 / 1.5 * 10 + 0）= 3.33。"
    },
    {
      "indent": 3,
      "text": "(3e) DR(2) = FSE_R(2) = 3.33.",
      "ja": "（3e）DR（2）= FSE_R（2）= 3.33。"
    },
    {
      "indent": 3,
      "text": "The resulting FSE looks as follows:",
      "ja": "結果のFSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------\n| # | FGI |   P   |  FSE_R  |  DR  | Rate |\n|   |     |       |         |      |      |\n| 1 |  1  |   1   |    6    |   8  |   6  |\n| 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |\n-------------------------------------------\nS_CR = 10, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The effect is that flow #2 is now sending with 3.33 Mbit/s, which is close to half of the rate of flow #1 and leads to a total utilization of 6(#1) + 3.33(#2) = 9.33 Mbit/s. Flow #2's congestion controller has increased its rate faster than the controller actually expected. Now, flow #1 updates its rate. Its congestion controller detects that the network is not fully saturated and increases its rate. Additionally, the application feeding into flow #1 limits the flow's sending rate to at most 2 Mbit/s.",
      "ja": "効果は、フロー＃2が3.33 Mbit / sで送信されるようになり、フロー＃1のレートの半分に近く、合計使用率が6（＃1）+ 3.33（＃2）= 9.33 Mbit / s。 Flow＃2の輻輳コントローラーは、コントローラーが実際に予想したよりも速くそのレートを増加させました。 これで、フロー＃1がレートを更新します。 輻輳コントローラは、ネットワークが完全に飽和していないことを検出し、そのレートを上げます。 さらに、アプリケーションがフロー＃1にフィードすることにより、フローの送信レートが最大2メガビット/秒に制限されます。"
    },
    {
      "indent": 3,
      "text": "CC_R(1) = 7. new_DR(1) = 2.",
      "ja": "CC_R（1）= 7. new_DR（1）= 2。"
    },
    {
      "indent": 3,
      "text": "(3a) new_S_CR = 9.33; DELTA = 1.",
      "ja": "（3a）new_S_CR = 9.33; デルタ= 1。"
    },
    {
      "indent": 3,
      "text": "(3b) FSE_R(1) = 7, DELTA is positive, hence S_CR = 10 + 1 = 11; DR(1) = min(2, 7) = 2.",
      "ja": "（3b）FSE_R（1）= 7、DELTAは正であるため、S_CR = 10 + 1 = 11。 DR（1）= min（2、7）= 2。"
    },
    {
      "indent": 3,
      "text": "(3c) S_P = 1.5; DR(1) < FSE_R(1), hence TLO = 1/1.5 * 11 - 2 = 5.33.",
      "ja": "（3c）S_P = 1.5; DR（1）<FSE_R（1）、したがってTLO = 1 / 1.5 * 11-2 = 5.33。"
    },
    {
      "indent": 3,
      "text": "(3d) Rate(1) = min(2, 1/1.5 * 11 + 5.33) = 2.",
      "ja": "（3d）Rate（1）= min（2、1 / 1.5 * 11 + 5.33）= 2。"
    },
    {
      "indent": 3,
      "text": "(3e) FSE_R(1) = 2.",
      "ja": "（3e）FSE_R（1）= 2。"
    },
    {
      "indent": 3,
      "text": "The resulting FSE looks as follows:",
      "ja": "結果のFSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------\n| # | FGI |   P   |  FSE_R  |  DR  | Rate |\n|   |     |       |         |      |      |\n| 1 |  1  |   1   |    2    |   2  |   2  |\n| 2 |  1  |  0.5  |   3.33  | 3.33 | 3.33 |\n-------------------------------------------\nS_CR = 11, TLO = 5.33",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, the total rate of the two flows is 2 + 3.33 = 5.33 Mbit/s, i.e., the network is significantly underutilized due to the limitation of flow #1. Flow #2 updates its rate. Its congestion controller detects that the network is not fully saturated and increases its rate.",
      "ja": "これで、2つのフローの合計レートは2 + 3.33 = 5.33 Mbit / sになります。つまり、フロー＃1の制限により、ネットワークの使用率が大幅に低下します。 フロー＃2はそのレートを更新します。 輻輳コントローラは、ネットワークが完全に飽和していないことを検出し、そのレートを上げます。"
    },
    {
      "indent": 3,
      "text": "CC_R(2) = 4.33. new_DR(2) = infinity.",
      "ja": "CC_R（2）= 4.33。 new_DR（2）=無限大。"
    },
    {
      "indent": 3,
      "text": "(3a) new_S_CR = 5.33; DELTA = 1.",
      "ja": "（3a）new_S_CR = 5.33; デルタ= 1。"
    },
    {
      "indent": 3,
      "text": "(3b) FSE_R(2) = 4.33. DELTA is positive, hence S_CR = 12; DR(2) = 4.33.",
      "ja": "（3b）FSE_R（2）= 4.33。 DELTAは正であるため、S_CR = 12。 DR（2）= 4.33。"
    },
    {
      "indent": 3,
      "text": "(3c) S_P = 1.5.",
      "ja": "（3c）S_P = 1.5。"
    },
    {
      "indent": 3,
      "text": "(3d) Rate(2) = min(infinity, 0.5/1.5 * 12 + 5.33 ) = 9.33.",
      "ja": "（3d）Rate（2）= min（infinity、0.5 / 1.5 * 12 + 5.33）= 9.33。"
    },
    {
      "indent": 3,
      "text": "(3e) FSE_R(2) = 9.33, DR(2) = 9.33.",
      "ja": "（3e）FSE_R（2）= 9.33、DR（2）= 9.33。"
    },
    {
      "indent": 3,
      "text": "The resulting FSE looks as follows:",
      "ja": "結果のFSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------\n| # | FGI |   P   |  FSE_R  |  DR  | Rate |\n|   |     |       |         |      |      |\n| 1 |  1  |   1   |    2    |   2  |   2  |\n| 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |\n-------------------------------------------\nS_CR = 12, TLO = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now, the total rate of the two flows is 2 + 9.33 = 11.33 Mbit/s. Finally, flow #1 terminates. It sets P(1) to -1 and DR(1) to 0. Let us assume that it terminated late enough for flow #2 to still experience the network in a congested state, i.e., flow #2 decreases its rate in the next iteration.",
      "ja": "現在、2つのフローの合計レートは2 + 9.33 = 11.33 Mbit / sです。 最後に、フロー＃1が終了します。 P（1）を-1に設定し、DR（1）を0に設定します。フロー＃2がネットワークを輻輳状態のままにするのに十分遅れて終了したと仮定します。 繰り返し。"
    },
    {
      "indent": 3,
      "text": "CC_R(2) = 7.33. new_DR(2) = infinity.",
      "ja": "CC_R（2）= 7.33。 new_DR（2）=無限大。"
    },
    {
      "indent": 3,
      "text": "(3a) new_S_CR = 11.33; DELTA = -2.",
      "ja": "（3a）new_S_CR = 11.33; デルタ= -2。"
    },
    {
      "indent": 3,
      "text": "(3b) FSE_R(2) = 7.33. DELTA is negative, hence S_CR = 9.33; DR(2) = 7.33.",
      "ja": "（3b）FSE_R（2）= 7.33。 DELTAは負であるため、S_CR = 9.33。 DR（2）= 7.33。"
    },
    {
      "indent": 3,
      "text": "(3c) Flow 1 has P(1) = -1, hence it is deleted from the FSE. S_P = 0.5.",
      "ja": "（3c）フロー1はP（1）= -1であるため、FSEから削除されます。 S_P = 0.5。"
    },
    {
      "indent": 3,
      "text": "(3d) Rate(2) = min(infinity, 0.5/0.5*9.33 + 0) = 9.33.",
      "ja": "（3d）Rate（2）= min（infinity、0.5 / 0.5 * 9.33 + 0）= 9.33。"
    },
    {
      "indent": 3,
      "text": "(3e) FSE_R(2) = DR(2) = 9.33.",
      "ja": "（3e）FSE_R（2）= DR（2）= 9.33。"
    },
    {
      "indent": 3,
      "text": "The resulting FSE looks as follows:",
      "ja": "結果のFSEは次のようになります。"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------\n| # | FGI |   P   |  FSE_R  |  DR  | Rate |\n|   |     |       |         |      |      |\n| 2 |  1  |  0.5  |   9.33  | 9.33 | 9.33 |\n-------------------------------------------\nS_CR = 9.33, TLO = 0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document benefited from discussions with and feedback from Andreas Petlund, Anna Brunstrom, Colin Perkins, David Hayes, David Ros (who also gave the FSE its name), Ingemar Johansson, Karen Nielsen, Kristian Hiorth, Martin Stiemerling, Mirja Kühlewind, Spencer Dawkins, Varun Singh, Xiaoqing Zhu, and Zaheduzzaman Sarker. The authors would like to especially thank Xiaoqing Zhu and Stefan Holmer for helping with NADA and GCC, and Anna Brunstrom as well as Julius Flohr for helping us correct the active algorithm for the case of application-limited flows.",
      "ja": "この文書は、Andreas Petlund、Anna Brunstrom、Colin Perkins、David Hayes、David Ros（FSEの名前も付けた）、Ingemar Johansson、Karen Nielsen、Kristian Hiorth、Martin Stiemerling、MirjaKühlewind、Spencer Dawkinsとの議論とフィードバックから恩恵を受けました 、Varun Singh、Xiaoqing Zhu、およびZaheduzzaman Sarker。 著者は、特にNADAとGCCを支援してくれたXiaoqing ZhuとStefan Holmer、およびアプリケーションが制限されたフローの場合にアクティブアルゴリズムを修正するのを支援したJulius Flohrに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "This work was partially funded by the European Community under its Seventh Framework Program through the Reducing Internet Transport Latency (RITE) project (ICT-317700).",
      "ja": "この作業の一部は、インターネットトランスポートレイテンシの削減（RITE）プロジェクト（ICT-317700）を介した第7フレームワークプログラムの下で、欧州共同体によって資金提供されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Safiqul Islam University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway",
      "ja": "Safiqul Islam University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway"
    },
    {
      "indent": 3,
      "text": "Phone: +47 22 84 08 37\nEmail: safiquli@ifi.uio.no",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Michael Welzl University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway",
      "ja": "Michael Welzl University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway"
    },
    {
      "indent": 3,
      "text": "Phone: +47 22 85 24 20\nEmail: michawe@ifi.uio.no",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Stein Gjessing University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway",
      "ja": "Stein Gjessing University of Oslo PO Box 1080 Blindern N-0316 Oslo Norway"
    },
    {
      "indent": 3,
      "text": "Phone: +47 22 85 24 44\nEmail: steing@ifi.uio.no",
      "raw": true
    }
  ]
}