{
  "title": {
    "text": "RFC 8492 - Secure Password Ciphersuites for Transport Layer Security (TLS)",
    "ja": "RFC 8492 - トランスポート層セキュリティ（TLS）用の安全なパスワード暗号スイート"
  },
  "number": 8492,
  "created_at": "2019-10-23 16:50:45.597462+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                   D. Harkins, Ed.\nRequest for Comments: 8492                                 HP Enterprise\nCategory: Informational                                    February 2019\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Secure Password Ciphersuites for Transport Layer Security (TLS)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo defines several new ciphersuites for the Transport Layer Security (TLS) protocol to support certificateless, secure authentication using only a simple, low-entropy password. The exchange is called \"TLS-PWD\". The ciphersuites are all based on an authentication and key exchange protocol, named \"dragonfly\", that is resistant to offline dictionary attacks.",
      "ja": "このメモでは、Transport Layer Security（TLS）プロトコルのいくつかの新しい暗号スイートを定義して、単純な低エントロピーパスワードのみを使用した、証明書のない安全な認証をサポートします。 交換は「TLS-PWD」と呼ばれます。 暗号スイートはすべて、「dragonfly」という名前の認証およびキー交換プロトコルに基づいており、オフライン辞書攻撃に耐性があります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書は、インターネット標準化過程の仕様ではありません。 情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。 RFCエディターは、このドキュメントをその裁量で公開することを選択しており、実装または展開の価値については何も表明していません。 RFC Editorによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補でもありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8492.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8492で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の発行日に有効なBCP 78およびIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction and Motivation .....................................3\n   1.1. The Case for Certificateless Authentication ................3\n   1.2. Resistance to Dictionary Attacks ...........................3\n2. Key Words .......................................................4\n3. Notation and Background .........................................4\n   3.1. Notation ...................................................4\n   3.2. Discrete Logarithm Cryptography ............................5\n        3.2.1. Elliptic Curve Cryptography .........................5\n        3.2.2. Finite Field Cryptography ...........................7\n   3.3. Instantiating the Random Function ..........................8\n   3.4. Passwords ..................................................8\n   3.5. Assumptions ................................................9\n4. Specification of the TLS-PWD Handshake .........................10\n   4.1. TLS-PWD Pre-TLS 1.3 .......................................10\n   4.2. TLS-PWD in TLS 1.3 ........................................11\n   4.3. Protecting the Username ...................................11\n        4.3.1. Construction of a Protected Username ...............12\n        4.3.2. Recovery of a Protected Username ...................13\n   4.4. Fixing the Password Element ...............................14\n        4.4.1. Computing an ECC Password Element ..................16\n        4.4.2. Computing an FFC Password Element ..................18\n        4.4.3. Password Naming ....................................19\n        4.4.4. Generating TLS-PWD Commit ..........................20\n   4.5. Changes to Handshake Message Contents .....................20\n        4.5.1. Pre-1.3 TLS ........................................20\n               4.5.1.1. ClientHello Changes .......................20\n               4.5.1.2. ServerKeyExchange Changes .................21\n               4.5.1.3. ClientKeyExchange Changes .................23\n        4.5.2. TLS 1.3 ............................................24\n               4.5.2.1. TLS 1.3 KeyShare ..........................24\n               4.5.2.2. ClientHello Changes .......................24\n               4.5.2.3. ServerHello Changes .......................25\n               4.5.2.4. HelloRetryRequest Changes .................25\n   4.6. Computing the Shared Secret ...............................26\n5. Ciphersuite Definition .........................................26\n6. IANA Considerations ............................................27\n7. Security Considerations ........................................27\n8. Human Rights Considerations ....................................30\n9. Implementation Considerations ..................................31\n10. References ....................................................32\n   10.1. Normative References .....................................32\n   10.2. Informative References ...................................33\nAppendix A. Example Exchange ......................................35\nAcknowledgements ..................................................40\nAuthor's Address ..................................................40",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction and Motivation",
      "section_title": true,
      "ja": "1.紹介と動機"
    },
    {
      "indent": 0,
      "text": "1.1. The Case for Certificateless Authentication",
      "section_title": true,
      "ja": "1.1.  証明書なしの認証の場合"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) usually uses public key certificates for authentication [RFC5246] [RFC8446]. This is problematic in some cases:",
      "ja": "Transport Layer Security（TLS）は通常、認証に公開鍵証明書を使用します[RFC5246] [RFC8446]。 これはいくつかの場合に問題があります："
    },
    {
      "indent": 3,
      "text": "o Frequently, TLS [RFC5246] is used in devices owned, operated, and provisioned by people who lack competency to properly use certificates and merely want to establish a secure connection using a more natural credential like a simple password. The proliferation of deployments that use a self-signed server certificate in TLS [RFC5246] followed by a basic password exchange over the unauthenticated channel underscores this case.",
      "ja": "o多くの場合、TLS [RFC5246]は、証明書を適切に使用する能力がなく、単純なパスワードなどのより自然な資格情報を使用して安全な接続を確立したい人が所有、操作、プロビジョニングするデバイスで使用されます。 TLSで自己署名サーバー証明書を使用する展開の急増[RFC5246]に続いて、認証されていないチャネルでの基本的なパスワード交換がこのケースを強調しています。"
    },
    {
      "indent": 3,
      "text": "o The alternatives to TLS-PWD for employing certificateless TLS authentication -- using pre-shared keys in an exchange that is susceptible to dictionary attacks or using a Secure Remote Password (SRP) exchange that requires users to, a priori, be fixed to a specific Finite Field Cryptography (FFC) group for all subsequent connections -- are not acceptable for modern applications that require both security and cryptographic agility.",
      "ja": "o証明書のないTLS認証を使用するためのTLS-PWDの代替-辞書攻撃の影響を受けやすい交換で事前共有キーを使用するか、ユーザーに事前に固定する必要があるセキュアリモートパスワード（SRP）交換を使用する 後続のすべての接続用の特定の有限フィールド暗号化（FFC）グループは、セキュリティと暗号化の敏ility性の両方を必要とする最新のアプリケーションには受け入れられません。"
    },
    {
      "indent": 3,
      "text": "o A password is a more natural credential than a certificate (from early childhood, people learn the semantics of a shared secret), so a password-based TLS ciphersuite can be used to protect an HTTP-based certificate enrollment scheme like Enrollment over Secure Transport (EST) [RFC7030] to parlay a simple password into a certificate for subsequent use with any certificate-based authentication protocol. This addresses a significant \"chicken-and-egg\" dilemma found with certificate-only use of [RFC5246].",
      "ja": "oパスワードは証明書よりも自然な資格情報です（幼児期から、人々は共有シークレットのセマンティクスを学習します）。そのため、パスワードベースのTLS暗号スイートを使用して、Secure Transport over Enrollment over Secure TransportのようなHTTPベースの証明書登録スキームを保護できます （EST）[RFC7030]証明書ベースの認証プロトコルで使用するために、簡単なパスワードを証明書に組み込む。 これは、[RFC5246]の証明書のみの使用で見つかった重要な「鶏と卵」のジレンマに対処します。"
    },
    {
      "indent": 3,
      "text": "o Some PIN-code readers will transfer the entered PIN to a smart card in cleartext. Assuming a hostile environment, this is a bad practice. A password-based TLS ciphersuite can enable the establishment of an authenticated connection between reader and card based on the PIN.",
      "ja": "o一部のPINコードリーダーは、入力されたPINをクリアテキストでスマートカードに転送します。 敵対的な環境を想定すると、これは悪い習慣です。 パスワードベースのTLS暗号スイートを使用すると、PINに基づいてリーダーとカード間の認証済み接続を確立できます。"
    },
    {
      "indent": 0,
      "text": "1.2. Resistance to Dictionary Attacks",
      "section_title": true,
      "ja": "1.2.  辞書攻撃に対する抵抗"
    },
    {
      "indent": 3,
      "text": "It is a common misconception that a protocol that authenticates with a shared and secret credential is resistant to dictionary attacks if the credential is assumed to be an N-bit uniformly random secret, where N is sufficiently large. The concept of resistance to dictionary attacks really has nothing to do with whether that secret can be found in a standard collection of a language's defined words (i.e., a dictionary). It has to do with how an adversary gains an advantage in attacking the protocol.",
      "ja": "共有された秘密のクレデンシャルで認証するプロトコルは、クレデンシャルがNビットの一様にランダムなシークレット（Nは十分に大きい）であると想定される場合、辞書攻撃に耐性があるという一般的な誤解です。 辞書攻撃に対する抵抗の概念は、その秘密が言語の定義された単語の標準コレクション（つまり、辞書）で見つかるかどうかとはまったく関係ありません。 攻撃者がプロトコルを攻撃する際にどのように利点を得るかに関係しています。"
    },
    {
      "indent": 3,
      "text": "For a protocol to be resistant to dictionary attacks, any advantage an adversary can gain must be a function of the amount of interactions she makes with an honest protocol participant and not a function of the amount of computation she uses. This means that the adversary will not be able to obtain any information about the password except whether a single guess from a single protocol run that she took part in is correct or incorrect.",
      "ja": "プロトコルが辞書攻撃に耐えるには、攻撃者が得られる利点は、使用する計算量の関数ではなく、正直なプロトコル参加者とのやり取りの関数でなければなりません。 これは、攻撃者は、参加した単一のプロトコル実行からの単一の推測が正しいか間違っているかを除いて、パスワードに関する情報を取得できないことを意味します。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the attacker has access to a pool of data from which the secret was drawn -- it could be all numbers between 1 and 2^N; it could be all defined words in a dictionary. The key is that the attacker cannot do an attack and then go offline and enumerate through the pool trying potential secrets (computation) to see if one is correct. She must do an active attack for each secret she wishes to try (interaction), and the only information she can glean from that attack is whether the secret used with that particular attack is correct or not.",
      "ja": "攻撃者は、秘密が引き出されたデータのプールにアクセスできると想定されます。これは、1から2 ^ Nまでのすべての数字である可能性があります。 辞書に定義されているすべての単語である可能性があります。 重要なのは、攻撃者は攻撃を実行できず、オフラインになり、潜在的な秘密（計算）を試してプールを列挙し、正しいかどうかを確認することです。 彼女は、試行（対話）する各秘密に対して積極的な攻撃を行う必要があり、その攻撃から収集できる唯一の情報は、その特定の攻撃で使用された秘密が正しいかどうかです。"
    },
    {
      "indent": 0,
      "text": "2. Key Words",
      "section_title": true,
      "ja": "2.キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Notation and Background",
      "section_title": true,
      "ja": "3.表記と背景"
    },
    {
      "indent": 0,
      "text": "3.1. Notation",
      "section_title": true,
      "ja": "3.1.  表記法"
    },
    {
      "indent": 3,
      "text": "The following notation is used in this memo:",
      "ja": "このメモでは次の表記法が使用されます。"
    },
    {
      "indent": 3,
      "text": "password a secret -- and potentially low-entropy -- word, phrase, code, or key used as a credential for authentication. The password is shared between the TLS client and TLS server.",
      "ja": "パスワード秘密-潜在的に低エントロピー-認証の資格情報として使用される単語、フレーズ、コード、またはキー。 パスワードは、TLSクライアントとTLSサーバー間で共有されます。"
    },
    {
      "indent": 3,
      "text": "y = H(x) a binary string of arbitrary length, x, is given to a function H, which produces a fixed-length output, y.",
      "ja": "y = H（x）任意の長さxのバイナリ文字列が、固定長の出力yを生成する関数Hに与えられます。"
    },
    {
      "indent": 3,
      "text": "a | b denotes concatenation of string \"a\" with string \"b\".",
      "ja": "| bは、ストリング「a」とストリング「b」の連結を示します。"
    },
    {
      "indent": 3,
      "text": "[a]b indicates a string consisting of the single bit \"a\" repeated \"b\" times.",
      "ja": "[a] bは、単一のビット「a」が「b」回繰り返される文字列を示します。"
    },
    {
      "indent": 3,
      "text": "x mod y indicates the remainder of division of x by y. The result will be between 0 and y.",
      "ja": "x mod yは、xをyで割った余りを示します。 結果は0〜yになります。"
    },
    {
      "indent": 3,
      "text": "len(x) indicates the length in bits of the string \"x\".",
      "ja": "len（x）は、文字列「x」のビット単位の長さを示します。"
    },
    {
      "indent": 3,
      "text": "lgr(a, b) takes \"a\" and a prime, b, and returns the Legendre symbol (a/b).",
      "ja": "lgr（a、b）は「a」と素数bを取り、ルジャンドル記号（a / b）を返します。"
    },
    {
      "indent": 3,
      "text": "LSB(x) returns the least-significant bit of the bitstring \"x\".",
      "ja": "LSB（x）は、ビット文字列「x」の最下位ビットを返します。"
    },
    {
      "indent": 3,
      "text": "G.x indicates the x-coordinate of a point, G, on an elliptic curve.",
      "ja": "G.xは、楕円曲線上の点Gのx座標を示します。"
    },
    {
      "indent": 0,
      "text": "3.2. Discrete Logarithm Cryptography",
      "section_title": true,
      "ja": "3.2.  離散対数暗号"
    },
    {
      "indent": 3,
      "text": "The ciphersuites defined in this memo use discrete logarithm cryptography (see [SP800-56A]) to produce an authenticated and shared secret value that is an Element in a group defined by a set of domain parameters. The domain parameters can be based on either FFC or Elliptic Curve Cryptography (ECC).",
      "ja": "このメモで定義された暗号スイートは、離散対数暗号化（[SP800-56A]を参照）を使用して、ドメインパラメータのセットで定義されたグループ内の要素である認証済みの共有シークレット値を生成します。 ドメインパラメータは、FFCまたはElliptic Curve Cryptography（ECC）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "Elements in a group -- either an FFC or ECC group -- are indicated using uppercase, while scalar values are indicated using lowercase.",
      "ja": "グループ内の要素（FFCまたはECCグループ）は大文字を使用して示され、スカラー値は小文字を使用して示されます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Elliptic Curve Cryptography",
      "section_title": true,
      "ja": "3.2.1.  楕円曲線暗号"
    },
    {
      "indent": 3,
      "text": "The authenticated key exchange defined in this memo uses fundamental algorithms of elliptic curves defined over GF(p) as described in [RFC6090]. Ciphersuites defined in this memo SHALL only use ECC curves based on the Weierstrass equation y^2 = x^3 + a*x + b.",
      "ja": "このメモで定義された認証されたキー交換は、[RFC6090]で説明されているように、GF（p）で定義された楕円曲線の基本アルゴリズムを使用します。 このメモで定義されている暗号スイートは、ワイエルシュトラス方程式y ^ 2 = x ^ 3 + a * x + bに基づくECC曲線のみを使用するものとします（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the ECC groups used by this memo are:",
      "ja": "このメモで使用されるECCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p). The cryptographic group will be a subgroup of the full elliptic curve group, which consists of points on an elliptic curve -- Elements from GF(p) that satisfy the curve's equation -- together with the \"point at infinity\" that serves as the identity Element.",
      "ja": "o素数体GF（p）を決定する素数p。 暗号グループは完全な楕円曲線グループのサブグループになります。これは、楕円曲線上の点（曲線の方程式を満たすGF（p）の要素）と、アイデンティティとして機能する「無限遠点」で構成されます。 素子。"
    },
    {
      "indent": 3,
      "text": "o Elements a and b from GF(p) that define the curve's equation. The point (x, y) in GF(p) x GF(p) is on the elliptic curve if and only if (y^2 - x^3 - a*x - b) mod p equals zero (0).",
      "ja": "o曲線の方程式を定義するGF（p）の要素aおよびb。 （y ^ 2-x ^ 3-a * x-b）mod pがゼロ（0）の場合にのみ、GF（p）x GF（p）の点（x、y）は楕円曲線上にあります。"
    },
    {
      "indent": 3,
      "text": "o A point, G, on the elliptic curve, which serves as a generator for the ECC group. G is chosen such that its order, with respect to elliptic curve addition, is a sufficiently large prime.",
      "ja": "o ECCグループのジェネレーターとして機能する楕円曲線上のポイントG。 Gは、楕円曲線の加算に関してその次数が十分に大きい素数になるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the order of G and thus is also the size of the cryptographic subgroup that is generated by G.",
      "ja": "o素数q。Gの次数であり、Gによって生成される暗号化サブグループのサイズでもあります。"
    },
    {
      "indent": 3,
      "text": "o A co-factor, f, defined by the requirement that the size of the full elliptic curve group (including the \"point at infinity\") be the product of f and q.",
      "ja": "o完全な楕円曲線グループ（「無限遠点」を含む）のサイズがfとqの積であるという要件によって定義される補因子f。"
    },
    {
      "indent": 3,
      "text": "This memo uses the following ECC functions:",
      "ja": "このメモは、次のECC機能を使用します。"
    },
    {
      "indent": 3,
      "text": "o Z = elem-op(X, Y) = X + Y: two points on the curve, X and Y, are summed to produce another point on the curve, Z. This is the group operation for ECC groups.",
      "ja": "o Z = elem-op（X、Y）= X + Y：曲線上の2つのポイントXとYを合計して、曲線Z上の別のポイントを生成します。これはECCグループのグループ操作です。"
    },
    {
      "indent": 3,
      "text": "o Z = scalar-op(x, Y) = x * Y: an integer scalar, x, acts on a point on the curve, Y, via repetitive addition (Y is added to itself x times), to produce another ECC Element, Z.",
      "ja": "o Z = scalar-op（x、Y）= x * Y：整数スカラーxは、繰り返し加算（Yがx回追加される）によって曲線上の点Yに作用し、別のECC要素を生成します 、Z"
    },
    {
      "indent": 3,
      "text": "o Y = inverse(X): a point on the curve, X, has an inverse, Y, which is also a point on the curve, when their sum is the \"point at infinity\" (the identity for elliptic curve addition). In other words, R + inverse(R) = \"0\".",
      "ja": "o Y =逆数（X）：曲線上の点Xには逆のYがあります。これは、それらの合計が「無限遠点」（楕円曲線追加の恒等式）である場合、曲線上の点でもあります。 つまり、R + inverse（R）= \"0\"です。"
    },
    {
      "indent": 3,
      "text": "o z = F(X): the x-coordinate of a point (x, y) on the curve is returned. This is a mapping function to convert a group Element into an integer.",
      "ja": "o z = F（X）：曲線上の点（x、y）のx座標が返されます。 これは、グループ要素を整数に変換するマッピング関数です。"
    },
    {
      "indent": 3,
      "text": "Only ECC groups over GF(p) can be used with TLS-PWD. Characteristic-2 curves SHALL NOT be used by TLS-PWD. ECC groups over GF(2^m) SHALL NOT be used by TLS-PWD. In addition, ECC groups with a co-factor greater than one (1) SHALL NOT be used by TLS-PWD.",
      "ja": "TLS-PWDで使用できるのは、GF（p）上のECCグループのみです。 特性2曲線は、TLS-PWDで使用しないでください。 GF（2 ^ m）上のECCグループは、TLS-PWDで使用しないでください。 さらに、補助係数が1より大きいECCグループは、TLS-PWDで使用しないでください。"
    },
    {
      "indent": 3,
      "text": "A composite (x, y) pair can be validated as a point on the elliptic curve by checking that 1) both coordinates x and y are greater than zero (0) and less than the prime defining the underlying field, 2) coordinates x and y satisfy the equation of the curve, and 3) they do not represent the \"point at infinity\". If any of those conditions are not true, the (x, y) pair is not a valid point on the curve.",
      "ja": "複合（x、y）ペアは、1）座標xとyの両方がゼロ（0）より大きく、基になるフィールドを定義する素数よりも小さいこと、2）座標xと yは曲線の方程式を満たし、3）それらは「無限遠点」を表しません。 これらの条件のいずれかが真でない場合、（x、y）ペアは曲線上の有効なポイントではありません。"
    },
    {
      "indent": 3,
      "text": "A compliant implementation of TLS-PWD SHALL support group twenty-three (23) and SHOULD support group twenty-four (24) from the \"TLS Supported Groups\" registry; see [TLS_REG].",
      "ja": "TLS-PWDの準拠実装は、グループ23をサポートし、「TLSサポートグループ」レジストリからグループ24をサポートする必要があります。 [TLS_REG]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Finite Field Cryptography",
      "section_title": true,
      "ja": "3.2.2.  有限フィールド暗号化"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the FFC groups used by this memo are:",
      "ja": "このメモで使用されるFFCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p) (i.e., the integers modulo p). The FFC group will be a subgroup of GF(p)* (i.e., the multiplicative group of non-zero Elements in GF(p)).",
      "ja": "o素数体GF（p）（つまり、pを法とする整数）を決定する素数p。 FFCグループはGF（p）*のサブグループ（つまり、GF（p）の非ゼロ要素の乗法グループ）になります。"
    },
    {
      "indent": 3,
      "text": "o An Element, G, in GF(p)*, which serves as a generator for the FFC group. G is chosen such that its multiplicative order is a sufficiently large prime divisor of ((p - 1)/2).",
      "ja": "o GF（p）*のG要素。FFCグループのジェネレーターとして機能します。 Gは、乗法次数が（（p-1）/ 2）の十分に大きい素数であるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the multiplicative order of G and thus is also the size of the cryptographic subgroup of GF(p)* that is generated by G.",
      "ja": "o素数q。Gの乗法次数であり、Gによって生成されるGF（p）*の暗号サブグループのサイズでもあります。"
    },
    {
      "indent": 3,
      "text": "This memo uses the following FFC functions:",
      "ja": "このメモでは、次のFFC関数を使用します。"
    },
    {
      "indent": 3,
      "text": "o Z = elem-op(X, Y) = (X * Y) mod p: two FFC Elements, X and Y, are multiplied modulo the prime, p, to produce another FFC Element, Z. This is the group operation for FFC groups.",
      "ja": "o Z = elem-op（X、Y）=（X * Y）mod p：2つのFFC要素XとYは素数pを法として乗算され、別のFFC要素Zを生成します。これは、 FFCグループ。"
    },
    {
      "indent": 3,
      "text": "o Z = scalar-op(x, Y) = Y^x mod p: an integer scalar, x, acts on an FFC group Element, Y, via exponentiation modulo the prime, p, to produce another FFC Element, Z.",
      "ja": "o Z = scalar-op（x、Y）= Y ^ x mod p：整数スカラーxは、素数pを法とする累乗を介してFFCグループ要素Yに作用し、別のFFC要素Zを生成します。"
    },
    {
      "indent": 3,
      "text": "o Y = inverse(X): a group Element, X, has an inverse, Y, when the product of the Element and its inverse modulo the prime equals one (1). In other words, (X * inverse(X)) mod p = 1.",
      "ja": "o Y = inverse（X）：要素とその素のモジュロの積が1（1）に等しい場合、グループ要素Xには逆Yがあります。 つまり、（X * inverse（X））mod p = 1です。"
    },
    {
      "indent": 3,
      "text": "o z = F(X): is the identity function, since an Element in an FFC group is already an integer. It is included here for consistency in the specification.",
      "ja": "o z = F（X）：FFCグループの要素は既に整数であるため、恒等関数です。 仕様の一貫性のためにここに含まれています。"
    },
    {
      "indent": 3,
      "text": "Many FFC groups used in IETF protocols are based on safe primes and do not define an order (q). For these groups, the order (q) used in this memo shall be the prime of the group minus one divided by two -- (p - 1)/2.",
      "ja": "IETFプロトコルで使用される多くのFFCグループは、安全な素数に基づいており、順序（q）を定義しません。 これらのグループの場合、このメモで使用されている順序（q）は、グループの素数から1を2で割ったもの（-p-1）/ 2です。"
    },
    {
      "indent": 3,
      "text": "An integer can be validated as being an Element in an FFC group by checking that 1) it is between one (1) and the prime, p, exclusive and 2) modular exponentiation of the integer by the group order, q, equals one (1). If either of these conditions is not true, the integer is not an Element in the group.",
      "ja": "整数は、1）それが1（1）とプライム、p、排他的、2）グループ順序qによる整数のモジュラー累乗の1に等しいことをチェックすることにより、FFCグループの要素として検証できます。 1）。 これらの条件のいずれかが真でない場合、整数はグループ内の要素ではありません。"
    },
    {
      "indent": 3,
      "text": "A compliant implementation of TLS-PWD SHOULD support group two hundred fifty-six (256) and group two hundred fifty-eight (258) from the \"TLS Supported Groups\" registry on [TLS_REG].",
      "ja": "TLS-PWDの準拠した実装は、[TLS_REG]の「TLSサポートグループ」レジストリからのグループ256（256）およびグループ258（258）をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Instantiating the Random Function",
      "section_title": true,
      "ja": "3.3.  ランダム関数のインスタンス化"
    },
    {
      "indent": 3,
      "text": "The protocol described in this memo uses a random function, H, which is modeled as a \"random oracle\". At first glance, one may view this as a hash function. As noted in [RANDOR], though, hash functions are too structured to be used directly as a random oracle. But they can be used to instantiate the random oracle.",
      "ja": "このメモで説明されているプロトコルは、「ランダムオラクル」としてモデル化されたランダム関数Hを使用します。 一見すると、これをハッシュ関数と見なすことができます。 ただし、[RANDOR]で述べたように、ハッシュ関数は構造化されすぎて、ランダムオラクルとして直接使用できません。 ただし、これらを使用してランダムオラクルをインスタンス化できます。"
    },
    {
      "indent": 3,
      "text": "The random function, H, in this memo is instantiated by using the hash algorithm defined by the particular TLS-PWD ciphersuite in Hashed Message Authentication Code (HMAC) mode with a key whose length is equal to the block size of the hash algorithm and whose value is zero. For example, if the ciphersuite is TLS_ECCPWD_WITH_AES_128_GCM_SHA256, then H will be instantiated with SHA256 as:",
      "ja": "このメモのランダム関数Hは、ハッシュアルゴリズムのブロックサイズと同じ長さのキーを持つHashed Message Authentication Code（HMAC）モードの特定のTLS-PWD暗号スイートで定義されたハッシュアルゴリズムを使用してインスタンス化されます。 値はゼロです。 たとえば、暗号スイートがTLS_ECCPWD_WITH_AES_128_GCM_SHA256の場合、Hは次のようにSHA256でインスタンス化されます。"
    },
    {
      "indent": 6,
      "text": "H(x) = HMAC-SHA256([0]32, x)",
      "ja": "H（x）= HMAC-SHA256（[0] 32、x）"
    },
    {
      "indent": 0,
      "text": "3.4. Passwords",
      "section_title": true,
      "ja": "3.4.  パスワード"
    },
    {
      "indent": 3,
      "text": "The authenticated key exchange used in TLS-PWD requires each side to have a common view of a shared credential. To protect the server's database of stored passwords, a password MAY be salted. When [RFC5246] or earlier is used, the password SHALL be salted. When [RFC8446] is used, a password MAY be stored with a salt or without. The password, username, and, optionally, the salt can create an irreversible digest called the \"base\", which is used in the authenticated key exchange.",
      "ja": "TLS-PWDで使用される認証済みのキー交換では、各側が共有資格情報の共通ビューを持つ必要があります。 保存されたパスワードのサーバーのデータベースを保護するために、パスワードをソルトすることができます。 [RFC5246]以前を使用する場合、パスワードはソルト化する必要があります。 [RFC8446]が使用される場合、パスワードはソルトありまたはソルトなしで保存できます。 パスワード、ユーザー名、およびオプションでソルトは、認証されたキー交換で使用される「ベース」と呼ばれる不可逆的なダイジェストを作成できます。"
    },
    {
      "indent": 3,
      "text": "The salting function is defined as:",
      "ja": "ソルティング関数は次のように定義されます："
    },
    {
      "indent": 6,
      "text": "base = HMAC-SHA256(salt, username | password)",
      "ja": "base = HMAC-SHA256（salt、username | password）"
    },
    {
      "indent": 3,
      "text": "The unsalted function is defined as:",
      "ja": "無塩機能は次のように定義されます："
    },
    {
      "indent": 6,
      "text": "base = SHA256(username | password)",
      "ja": "base = SHA256（ユーザー名|パスワード）"
    },
    {
      "indent": 3,
      "text": "The password used for generation of the base SHALL be represented as a UTF-8 encoded character string processed according to the rules of the OpaqueString profile of [RFC8265], and the salt SHALL be a 32-octet random number. The server SHALL store a tuple of the form:",
      "ja": "ベースの生成に使用されるパスワードは、[RFC8265]のOpaqueStringプロファイルのルールに従って処理されるUTF-8エンコード文字列として表され、ソルトは32オクテットの乱数でなければなりません。 サーバーは、次の形式のタプルを保存する必要があります。"
    },
    {
      "indent": 6,
      "text": "{ username, base, salt }",
      "ja": "{ユーザー名、ベース、ソルト}"
    },
    {
      "indent": 3,
      "text": "if the password is salted and:",
      "ja": "パスワードがソルトされ、次の場合："
    },
    {
      "indent": 6,
      "text": "{ username, base }",
      "ja": "{ユーザー名、ベース}"
    },
    {
      "indent": 3,
      "text": "if it is not. When password salting is being used, the client generates the base upon receiving the salt from the server; otherwise, it may store the base at the time the username and password are provisioned.",
      "ja": "そうでない場合。 パスワードソルティングが使用されている場合、クライアントはサーバーからソルトを受信するとベースを生成します。 そうでない場合は、ユーザー名とパスワードがプロビジョニングされたときにベースを保存できます。"
    },
    {
      "indent": 0,
      "text": "3.5. Assumptions",
      "section_title": true,
      "ja": "3.5.  仮定"
    },
    {
      "indent": 3,
      "text": "The security properties of the authenticated key exchange defined in this memo are based on a number of assumptions:",
      "ja": "このメモで定義された認証されたキー交換のセキュリティ特性は、多くの仮定に基づいています："
    },
    {
      "indent": 3,
      "text": "1. The random function, H, is a \"random oracle\" as defined in [RANDOR].",
      "ja": "1.ランダム関数Hは、[RANDOR]で定義されている「ランダムオラクル」です。"
    },
    {
      "indent": 3,
      "text": "2. The discrete logarithm problem for the chosen group is hard. That is, given g, p, and y = g^x mod p, it is computationally infeasible to determine x. Similarly, for an ECC group given the curve definition, a generator G, and Y = x * G, it is computationally infeasible to determine x.",
      "ja": "2.選択したグループの離散対数問題は困難です。 つまり、g、p、およびy = g ^ x mod pが与えられた場合、xを決定することは計算上実行不可能です。 同様に、曲線定義、ジェネレーターG、およびY = x * Gが与えられたECCグループの場合、xを決定することは計算上実行不可能です。"
    },
    {
      "indent": 3,
      "text": "3. Quality random numbers with sufficient entropy can be created. This may entail the use of specialized hardware. If such hardware is unavailable, a cryptographic mixing function (like a strong hash function) to distill entropy from multiple, uncorrelated sources of information and events may be needed. A very good discussion of this can be found in [RFC4086].",
      "ja": "3.十分なエントロピーを持つ高品質の乱数を作成できます。 これには、専用ハードウェアの使用が必要になる場合があります。 そのようなハードウェアが利用できない場合、情報およびイベントの複数の無相関のソースからエントロピーを抽出する暗号ミキシング機能（強力なハッシュ関数など）が必要になる場合があります。 これに関する非常に良い議論は[RFC4086]にあります。"
    },
    {
      "indent": 3,
      "text": "If the server supports username protection (see Section 4.3), it is assumed that the server has chosen a domain parameter set and generated a username-protection keypair. The chosen domain parameter set and public key are assumed to be conveyed to the client at the time the client's username and password were provisioned.",
      "ja": "サーバーがユーザー名保護をサポートしている場合（セクション4.3を参照）、サーバーがドメインパラメーターセットを選択し、ユーザー名保護キーペアを生成したと想定されます。 選択されたドメインパラメータセットと公開キーは、クライアントのユーザー名とパスワードがプロビジョニングされたときにクライアントに伝達されると想定されます。"
    },
    {
      "indent": 0,
      "text": "4. Specification of the TLS-PWD Handshake",
      "section_title": true,
      "ja": "4. TLS-PWDハンドシェイクの仕様"
    },
    {
      "indent": 3,
      "text": "The key exchange underlying TLS-PWD is the \"dragonfly\" password-authenticated key exchange (PAKE) as defined in [RFC7664].",
      "ja": "TLS-PWDの基礎となる鍵交換は、[RFC7664]で定義されている「トンボ」パスワード認証鍵交換（PAKE）です。"
    },
    {
      "indent": 3,
      "text": "The authenticated key exchange is accomplished by each side deriving a Password Element (PE) [RFC7664] in the chosen group, making a \"commitment\" to a single guess of the password using the PE, and generating a shared secret. The ability of each side to produce a valid finished message using a key derived from the shared secret allows each side to authenticates itself to the other side.",
      "ja": "認証された鍵交換は、選択されたグループでパスワード要素（PE）[RFC7664]を導出し、PEを使用してパスワードの単一推測に「コミット」を行い、共有シークレットを生成することで行われます。 共有シークレットから派生したキーを使用して有効な終了メッセージを生成する各側の機能により、各側は相手側に対して自身を認証できます。"
    },
    {
      "indent": 3,
      "text": "The authenticated key exchange is dropped into the standard TLS message handshake by defining extensions to some of the messages.",
      "ja": "認証されたキー交換は、一部のメッセージの拡張子を定義することにより、標準のTLSメッセージハンドシェイクにドロップされます。"
    },
    {
      "indent": 0,
      "text": "4.1. TLS-PWD Pre-TLS 1.3",
      "section_title": true,
      "ja": "4.1.  TLS-PWD Pre-TLS 1.3"
    },
    {
      "indent": 9,
      "text": " Client                                            Server\n--------                                          --------",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ClientHello (name)      -------->",
      "raw": true
    },
    {
      "indent": 34,
      "text": "                      ServerHello\n       ServerKeyExchange (commit)\n<--------        ServerHello Done",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ClientKeyExchange (commit)\nChangeCipherSpec\nFinished                -------->",
      "raw": true
    },
    {
      "indent": 34,
      "text": "                 ChangeCipherSpec\n<--------                Finished",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Application Data        <------->        Application Data",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: Pre-TLS 1.3 TLS-PWD Handshake",
      "ja": "図1：Pre-TLS 1.3 TLS-PWDハンドシェイク"
    },
    {
      "indent": 0,
      "text": "4.2. TLS-PWD in TLS 1.3",
      "section_title": true,
      "ja": "4.2.  TLS 1.3のTLS-PWD"
    },
    {
      "indent": 8,
      "text": " Client                                            Server\n--------                                          --------\n ClientHello (name)\n + key_share (commit)       -------->\n                                                ServerHello\n                                       + key_share (commit)\n                                      {EncryptedExtensions}\n                                                 {Finished}\n                            <--------   [Application Data*]\n {Finished}                 -------->\n [Application Data]         <------->    [Application Data]",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2: TLS 1.3 TLS-PWD Handshake",
      "ja": "図2：TLS 1.3 TLS-PWDハンドシェイク"
    },
    {
      "indent": 0,
      "text": "4.3. Protecting the Username",
      "section_title": true,
      "ja": "4.3.  ユーザー名の保護"
    },
    {
      "indent": 3,
      "text": "The client is required to identify herself to the server before the server can look up the appropriate client credential with which to perform the authenticated key exchange. This has negative privacy implications and opens up the client to tracking and increased monitoring. It is therefore useful for the client to be able to protect her username from passive monitors of the exchange and against active attack by a malicious server. TLS-PWD provides such a mechanism. Support for protected usernames is RECOMMENDED.",
      "ja": "クライアントは、サーバーが認証されたキー交換を実行するための適切なクライアント資格情報を検索する前に、サーバーに対して自分自身を識別する必要があります。 これは、プライバシーに悪影響を及ぼし、クライアントが追跡と監視の強化を行えるようにします。 したがって、クライアントがユーザー名を交換のパッシブモニターから保護し、悪意のあるサーバーによるアクティブな攻撃から保護できると便利です。 TLS-PWDはそのようなメカニズムを提供します。 保護されたユーザー名のサポートが推奨されます。"
    },
    {
      "indent": 3,
      "text": "To enable username protection, a server chooses a domain parameter set and generates an ephemeral public/private keypair. This keypair SHALL only be used for username protection. For efficiency, the domain parameter set used for username protection MUST be based on ECC. Any ECC group that is appropriate for TLS-PWD (see Section 3.2.1) is suitable for this purpose, but for interoperability, prime256v1 (aka NIST's p256 curve) MUST be supported. The domain parameter set chosen for username protection is independent of the domain parameter set chosen for the underlying key exchange -- i.e., they need not be the same.",
      "ja": "ユーザー名保護を有効にするために、サーバーはドメインパラメーターセットを選択し、一時的な公開/秘密キーペアを生成します。 このキーペアは、ユーザー名の保護にのみ使用する必要があります。 効率のために、ユーザー名保護に使用されるドメインパラメータセットはECCに基づいている必要があります。 TLS-PWDに適したECCグループ（セクション3.2.1を参照）はこの目的に適していますが、相互運用性のために、prime256v1（別名NISTのp256カーブ）をサポートする必要があります。 ユーザー名保護のために選択されたドメインパラメータセットは、基礎となるキー交換のために選択されたドメインパラメータセットとは無関係です。つまり、同じである必要はありません。"
    },
    {
      "indent": 3,
      "text": "When the client's username and password are provisioned on the server, the chosen group and its public key are provisioned on the client. This is stored on the client along with the server-specific state (e.g., the hostname) it uses to initiate a TLS-PWD exchange. The server uses the same group and public key with all clients.",
      "ja": "クライアントのユーザー名とパスワードがサーバーでプロビジョニングされると、選択したグループとその公開鍵がクライアントでプロビジョニングされます。 これは、TLS-PWD交換を開始するために使用するサーバー固有の状態（ホスト名など）とともにクライアントに保存されます。 サーバーは、すべてのクライアントで同じグループと公開鍵を使用します。"
    },
    {
      "indent": 3,
      "text": "To protect a username, the client and server perform a static-ephemeral Diffie-Hellman exchange. Since the y-coordinate is not necessary and eliminating it will reduce message size, compact representation (and therefore compact output; see [RFC6090]) is used",
      "ja": "ユーザー名を保護するために、クライアントとサーバーは静的一時的なDiffie-Hellman交換を実行します。 y座標は不要であり、これを削除するとメッセージサイズが小さくなるため、コンパクトな表現（したがって、コンパクトな出力。[RFC6090]を参照）が使用されます。"
    },
    {
      "indent": 3,
      "text": "in the static-ephemeral Diffie-Hellman exchange. The result of the Diffie-Hellman exchange is passed to the HMAC-based Key Derivation Function (HKDF) [RFC5869] to create a key-encrypting key suitable for AES-SIV [RFC5297] (where \"AES\" stands for \"Advanced Encryption Standard\" and \"SIV\" stands for \"Synthetic Initialization Vector\") in its deterministic authenticated encryption mode. The length of the key-encrypting key (1) and the hash function to use with the HKDF depend on the length of the prime, p, of the group used to provide username protection:",
      "ja": "静的一時的なDiffie-Hellman交換で。 Diffie-Hellman交換の結果はHMACベースのキー派生関数（HKDF）[RFC5869]に渡され、AES-SIV [RFC5297]に適したキー暗号化キーが作成されます（「AES」は「Advanced Encryption Standard 「および」「SIV」は、確定的認証暗号化モードの「合成初期化ベクトル」を表します。 キー暗号化キー（1）の長さとHKDFで使用するハッシュ関数は、ユーザー名保護を提供するために使用されるグループの素数pの長さに依存します。"
    },
    {
      "indent": 3,
      "text": "o SHA-256, SIV-128, l=256 bits: when len(p) <= 256",
      "ja": "o SHA-256、SIV-128、l = 256ビット：len（p）<= 256の場合"
    },
    {
      "indent": 3,
      "text": "o SHA-384, SIV-192, l=384 bits: when 256 < len(p) <= 384",
      "ja": "o SHA-384、SIV-192、l = 384ビット：256 <len（p）<= 384の場合"
    },
    {
      "indent": 3,
      "text": "o SHA-512, SIV-256, l=512 bits: when len(p) > 384",
      "ja": "o SHA-512、SIV-256、l = 512ビット：len（p）> 384の場合"
    },
    {
      "indent": 0,
      "text": "4.3.1. Construction of a Protected Username",
      "section_title": true,
      "ja": "4.3.1.  保護されたユーザー名の構築"
    },
    {
      "indent": 3,
      "text": "Prior to initiating a TLS-PWD exchange, the client chooses a random secret, c, such that 1 < c < (q - 1), where q is the order of the group from which the server's public key was generated, and it uses scalar-op() with the group's generator to create a public key, C. It uses scalar-op() with the server's public key and c to create a shared secret, and it derives a key-encrypting key, k, using the \"saltless\" mode of the HKDF [RFC5869]:",
      "ja": "TLS-PWD交換を開始する前に、クライアントは1 <c <（q-1）のようなランダムなシークレットcを選択します。ここで、qはサーバーの公開キーが生成されたグループの順序であり、 グループのジェネレーターでスカラー-op（）を使用して公開キーCを作成します。サーバーのパブリックキーでスカラー-op（）とcを使用して共有シークレットを作成し、キー暗号化キーkを使用して、 HKDFの「無塩」モード[RFC5869]："
    },
    {
      "indent": 6,
      "text": "C = scalar-op(c, G)",
      "ja": "C = scalar-op（c、G）"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(c, S)",
      "ja": "Z =スカラー-op（c、S）"
    },
    {
      "indent": 6,
      "text": "k = HKDF-expand(HKDF-extract(NULL, Z.x), \"\", l)",
      "ja": "k = HKDF-expand（HKDF-extract（NULL、Z.x）、 \"\"、l）"
    },
    {
      "indent": 3,
      "text": "where NULL indicates the salt-free invocation and \"\" indicates an empty string (i.e., there is no \"context\" passed to the HKDF).",
      "ja": "NULLはソルトフリーの呼び出しを示し、「」は空の文字列を示します（つまり、HKDFに渡される「コンテキスト」はありません）。"
    },
    {
      "indent": 3,
      "text": "The client's username SHALL be represented as a UTF-8 encoded character string processed according to the rules of the OpaqueString profile of [RFC8265]. The output of OpaqueString is then passed with the key, k, to SIV-encrypt with no Additional Authenticated Data (AAD) and no nonce, to produce an encrypted username, u:",
      "ja": "クライアントのユーザー名は、[RFC8265]のOpaqueStringプロファイルのルールに従って処理されたUTF-8エンコード文字列として表される必要があります。 OpaqueStringの出力は、キーkとともに、追加認証データ（AAD）およびノンスなしでSIV-encryptに渡され、暗号化されたユーザー名uが生成されます。"
    },
    {
      "indent": 6,
      "text": "u = SIV-encrypt(k, username)",
      "ja": "u = SIV-encrypt（k、ユーザー名）"
    },
    {
      "indent": 3,
      "text": "Note: The format of the ciphertext output includes the authenticating SIV.",
      "ja": "注：暗号文出力の形式には、認証SIVが含まれます。"
    },
    {
      "indent": 3,
      "text": "The protected username SHALL be the concatenation of the x-coordinate of the client's public key, C, and the encrypted username, u. The length of the x-coordinate of C MUST be equal to the length of the group's prime, p, prepended with zeros, if necessary. The protected username is inserted into the extension_data field of the pwd_protect extension (see Section 4.4.3).",
      "ja": "保護されたユーザー名は、クライアントの公開キーのx座標Cと暗号化されたユーザー名uの連結でなければなりません。 Cのx座標の長さは、必要に応じて、ゼロを前に付けたグループの素数pの長さに等しくなければなりません。 保護されたユーザー名は、pwd_protect拡張のextension_dataフィールドに挿入されます（セクション4.4.3を参照）。"
    },
    {
      "indent": 3,
      "text": "To ensure that the username remains confidential, the random secret, c, MUST be generated from a source of random entropy; see Section 3.5.",
      "ja": "ユーザー名の機密性を保つために、ランダムな秘密cをランダムなエントロピーのソースから生成する必要があります。 セクション3.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The length of the ciphertext output from SIV, minus the synthetic initialization vector, will be equal to the length of the input plaintext -- in this case, the username. To further foil traffic analysis, it is RECOMMENDED that clients append a series of NULL bytes to their usernames prior to passing them to SIV-encrypt() such that the resulting padded length of the username is at least 128 octets.",
      "ja": "SIVからの暗号化テキスト出力の長さから合成初期化ベクトルを引いた長さは、入力プレーンテキストの長さ（この場合はユーザー名）と等しくなります。 トラフィック分析をさらにフォイルするには、クライアントがSIV-encrypt（）に渡す前に一連のNULLバイトをユーザー名に追加して、結果のユーザー名のパディング長が少なくとも128オクテットになるようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Recovery of a Protected Username",
      "section_title": true,
      "ja": "4.3.2.  保護されたユーザー名の回復"
    },
    {
      "indent": 3,
      "text": "A server that receives a protected username needs to recover the client's username prior to performing the key exchange. To do so, the server computes the client's public key; completes the static-ephemeral Diffie-Hellman exchange; derives the key-encrypting key, k; and decrypts the username.",
      "ja": "保護されたユーザー名を受信するサーバーは、キー交換を実行する前にクライアントのユーザー名を回復する必要があります。 そのために、サーバーはクライアントの公開キーを計算します。 静的一時的なDiffie-Hellman交換を完了します。 キー暗号化キーkを導出します。 ユーザー名を解読します。"
    },
    {
      "indent": 3,
      "text": "The length of the x-coordinate of the client's public key is known (it is the length of the prime from the domain parameter set used to protect usernames) and can easily be separated from the ciphertext in the pwd_name extension in the ClientHello -- the first len(p) bits are the x-coordinate of the client's public key, and the remaining bits are the ciphertext.",
      "ja": "クライアントの公開鍵のx座標の長さ（ユーザー名を保護するために使用されるドメインパラメーターセットの素数の長さ）がわかっており、ClientHelloのpwd_name拡張で暗号文から簡単に分離できます。 最初のlen（p）ビットはクライアントの公開鍵のx座標であり、残りのビットは暗号文です。"
    },
    {
      "indent": 3,
      "text": "Since compressed representation is used by the client, the server MUST compute the y-coordinate of the client's public key by using the equation of the curve:",
      "ja": "クライアントは圧縮表現を使用するため、サーバーは曲線の方程式を使用してクライアントの公開キーのy座標を計算する必要があります。"
    },
    {
      "indent": 6,
      "text": "y^2 = x^3 + ax + b",
      "ja": "y ^ 2 = x ^ 3 + ax + b"
    },
    {
      "indent": 3,
      "text": "and solving for y. There are two solutions for y, but since compressed output is also being used, the selection is irrelevant. The server reconstructs the client's public value, C, from (x, y). If there is no solution for y or if (x, y) is not a valid point on the elliptic curve (see Section 3.2.1), the server MUST treat the ClientHello as if it did not have a password for a given username (see Section 4.5.1.1).",
      "ja": "yを解きます。 yには2つの解決策がありますが、圧縮出力も使用されているため、選択は無関係です。 サーバーは、（x、y）からクライアントのパブリック値Cを再構築します。 yに解決策がない場合、または（x、y）が楕円曲線上の有効なポイントでない場合（セクション3.2.1を参照）、サーバーはClientHelloを特定のユーザー名のパスワードを持っていないかのように扱わなければなりません（MUST） セクション4.5.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The server then uses scalar-op() with the reconstructed point C and the private key it uses for protected passwords, s, to generate a shared secret, and it derives a key-encrypting key, k, in the same manner as that described in Section 4.3.1.",
      "ja": "サーバーは、再構築されたポイントCと保護されたパスワードsに使用する秘密キーでscalar-op（）を使用して共有シークレットを生成し、説明と同じ方法でキー暗号化キーkを取得します セクション4.3.1で。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(s, C)",
      "ja": "Z =スカラーop（s、C）"
    },
    {
      "indent": 6,
      "text": "k = HKDF-expand(HKDF-extract(NULL, Z.x), \"\", l)",
      "ja": "k = HKDF-expand（HKDF-extract（NULL、Z.x）、 \"\"、l）"
    },
    {
      "indent": 3,
      "text": "The key, k, and the ciphertext portion of the pwd_name extension, u, are passed to SIV-decrypt with no AAD and no nonce, to produce the username:",
      "ja": "キー、k、およびpwd_name拡張の暗号文部分、uは、AADおよびノンスなしでSIV-decryptに渡され、ユーザー名が生成されます。"
    },
    {
      "indent": 6,
      "text": "username = SIV-decrypt(k, u)",
      "ja": "ユーザー名= SIV-decrypt（k、u）"
    },
    {
      "indent": 3,
      "text": "If SIV-decrypt returns the symbol FAIL indicating unsuccessful decryption and verification, the server MUST treat the ClientHello as if it did not have a password for a given username (see Section 4.5.1.1). If successful, the server has obtained the client's username and can process it as needed. Any NULL octets added by the client prior to encryption can be easily stripped off of the string that represents the username.",
      "ja": "SIV-decryptが復号化と検証の失敗を示すシンボルFAILを返す場合、サーバーはClientHelloを指定されたユーザー名のパスワードを持っていないかのように扱わなければなりません（セクション4.5.1.1を参照）。 成功した場合、サーバーはクライアントのユーザー名を取得し、必要に応じて処理できます。 暗号化の前にクライアントによって追加されたNULLオクテットは、ユーザー名を表す文字列から簡単に削除できます。"
    },
    {
      "indent": 0,
      "text": "4.4. Fixing the Password Element",
      "section_title": true,
      "ja": "4.4.  パスワード要素の修正"
    },
    {
      "indent": 3,
      "text": "Prior to making a \"commitment\", both sides must generate a secret Element (PE) in the chosen group, using the common password-derived base. The server generates the PE after it receives the ClientHello and chooses the particular group to use, and the client generates the PE prior to sending the ClientHello in TLS 1.3 and upon receipt of the ServerKeyExchange in TLS pre-1.3.",
      "ja": "「コミットメント」を行う前に、両側は、共通のパスワード派生ベースを使用して、選択したグループに秘密要素（PE）を生成する必要があります。 サーバーは、ClientHelloを受信して使用する特定のグループを選択した後にPEを生成し、クライアントは、TLS 1.3でClientHelloを送信する前、およびTLS 1.3より前のServerKeyExchangeを受信するとPEを生成します。"
    },
    {
      "indent": 3,
      "text": "Fixing the PE involves an iterative \"hunting-and-pecking\" technique using the prime from the negotiated group's domain parameter set and an ECC-specific or FFC-specific operation, depending on the negotiated group.",
      "ja": "PEの修正には、ネゴシエートされたグループのドメインパラメータセットからの素数と、ネゴシエートされたグループに応じたECC固有またはFFC固有の操作を使用する反復「ハンティングアンドペッキング」技術が含まれます。"
    },
    {
      "indent": 3,
      "text": "To thwart side-channel attacks that attempt to determine the number of iterations of the hunting-and-pecking loop that are used to find the PE for a given password, a security parameter, m, is used to ensure that at least m iterations are always performed.",
      "ja": "与えられたパスワードのPEを見つけるために使用されるハンティングアンドペッキングループの反復回数を決定しようとするサイドチャネル攻撃を阻止するには、セキュリティパラメータmを使用して、少なくともm回の反復が行われるようにします。 常に実行されます。"
    },
    {
      "indent": 3,
      "text": "First, an 8-bit counter is set to the value one (1). Then, H is used to generate a password seed from the counter, the prime of the selected group, and the base (which is derived from the username, password, and, optionally, the salt; see Section 3.4):",
      "ja": "最初に、8ビットカウンタが値1に設定されます。 次に、Hを使用して、カウンター、選択したグループの素数、およびベース（ユーザー名、パスワード、およびオプションでソルトから派生。セクション3.4を参照）からパスワードシードを生成します。"
    },
    {
      "indent": 3,
      "text": "pwd-seed = H(base | counter | p)",
      "ja": "pwd-seed = H（ベース|カウンター| p）"
    },
    {
      "indent": 3,
      "text": "Next, a context is generated consisting of random information. For versions of TLS less than 1.3, the context is a concatenation of the ClientHello random and the ServerHello random. For TLS 1.3, the context is the ClientHello random:",
      "ja": "次に、ランダムな情報で構成されるコンテキストが生成されます。 TLSのバージョンが1.3未満の場合、コンテキストはClientHelloランダムとServerHelloランダムの連結です。 TLS 1.3の場合、コンテキストはClientHelloランダムです："
    },
    {
      "indent": 3,
      "text": "if (version < 1.3) { context = ClientHello.random | ServerHello.random } else { context = ClientHello.random }",
      "ja": "if（バージョン<1.3）{context = ClientHello.random | ServerHello.random} else {context = ClientHello.random}"
    },
    {
      "indent": 3,
      "text": "Then, using the technique from Appendix B.5.1 of [FIPS186-4], the pwd-seed is expanded, using the Pseudorandom Function (PRF), to the length of the prime from the negotiated group's domain parameter set plus a constant, sixty-four (64), to produce an intermediate pwd-tmp, which is modularly reduced to create the pwd-value:",
      "ja": "次に、[FIPS186-4]の付録B.5.1の手法を使用して、疑似ランダム関数（PRF）を使用して、ネゴシエートされたグループのドメインパラメーターセットからの素数の長さ、定数60 -four（64）、中間のpwd-tmpを生成します。これは、pwd-valueを作成するためにモジュール的に削減されます。"
    },
    {
      "indent": 3,
      "text": "n = len(p) + 64 pwd-tmp = PRF(pwd-seed, \"TLS-PWD Hunting And Pecking\", context) [0..n]; pwd-value = (pwd-tmp mod (p - 1)) + 1",
      "ja": "n = len（p）+ 64 pwd-tmp = PRF（pwd-seed、 \"TLS-PWD Hunting And Pecking\"、context）[0..n]; pwd-value =（pwd-tmp mod（p-1））+ 1"
    },
    {
      "indent": 3,
      "text": "The pwd-value is then passed to the group-specific operation, which either returns the selected PE or fails. If the group-specific operation fails, the counter is incremented, a new pwd-seed is generated, and the hunting-and-pecking process continues; this procedure continues until the group-specific operation returns the PE. After the PE has been chosen, the base is changed to a random number, the counter is incremented, and the hunting-and-pecking process continues until the counter is greater than the security parameter, m.",
      "ja": "次に、pwd-valueがグループ固有の操作に渡され、選択されたPEが返されるか、失敗します。 グループ固有の操作が失敗すると、カウンターが増分され、新しいpwd-seedが生成され、ハンティングとペッキングのプロセスが続行されます。 この手順は、グループ固有の操作がPEを返すまで続きます。 PEが選択された後、ベースが乱数に変更され、カウンターが増分され、カウンターがセキュリティパラメーターmを超えるまでハンティングとペッキングのプロセスが続行されます。"
    },
    {
      "indent": 3,
      "text": "The probability that one requires more than n iterations of the hunting-and-pecking loop to find an ECC PE is roughly (q/2p)^n and to find an FFC PE is roughly (q/p)^n, both of which rapidly approach zero (0) as n increases. The security parameter, m, SHOULD be set sufficiently large such that the probability that finding the PE would take more than m iterations is sufficiently small (see Section 7).",
      "ja": "ECC PEを見つけるためにハンティングアンドペッキングループをn回以上繰り返す必要がある確率は、おおよそ（q / 2p）^ nであり、FFC PEを見つけるにはおおよそ（q / p）^ nです。 nが増加すると、急速にゼロ（0）に近づきます。 セキュリティパラメータmは、PEを見つけるのにm回以上の反復が必要となる確率が十分に小さくなるように、十分に大きく設定する必要があります（セクション7を参照）。"
    },
    {
      "indent": 3,
      "text": "When the PE has been discovered, pwd-seed, pwd-tmp, and pwd-value SHALL be irretrievably destroyed.",
      "ja": "PEが検出されると、pwd-seed、pwd-tmp、およびpwd-valueは回復不能に破壊されるものとします。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Computing an ECC Password Element",
      "section_title": true,
      "ja": "4.4.1.  ECCパスワード要素の計算"
    },
    {
      "indent": 3,
      "text": "The group-specific operation for ECC groups uses pwd-value, pwd-seed, and the equation for the curve to produce the PE. First, pwd-value is used directly as the x-coordinate, x, with the equation for the elliptic curve, with parameters a and b from the domain parameter set of the curve, to solve for a y-coordinate, y. If there is no solution to the quadratic equation, this operation fails and the hunting-and-pecking process continues. If a solution is found, then an ambiguity exists, as there are technically two solutions to the equation, and pwd-seed is used to unambiguously select one of them. If the low-order bit of pwd-seed is equal to the low-order bit of y, then a candidate PE is defined as the point (x, y); if the low-order bit of pwd-seed differs from the low-order bit of y, then a candidate PE is defined as the point (x, p - y), where p is the prime over which the curve is defined. The candidate PE becomes the PE, a random number is used instead of the base, and the hunting-and-pecking process continues until it has looped through m iterations, where m is a suitably large number to prevent side-channel attacks (see [RFC7664]).",
      "ja": "ECCグループのグループ固有の操作では、pwd-value、pwd-seed、および曲線の方程式を使用してPEを生成します。最初に、pwd-valueをx座標xとして直接使用し、楕円曲線の方程式と、曲線のドメインパラメーターセットのパラメーターaおよびbを使用して、y座標yを解きます。二次方程式の解が存在しない場合、この操作は失敗し、狩りとつつきのプロセスが続行されます。解決策が見つかった場合、方程式には技術的に2つの解決策があるため、あいまいさが存在し、pwd-seedを使用してそれらの1つを明確に選択します。 pwd-seedの下位ビットがyの下位ビットと等しい場合、候補PEはポイント（x、y）として定義されます。 pwd-seedの下位ビットがyの下位ビットと異なる場合、候補PEはポイント（x、p-y）として定義されます。ここで、pは曲線が定義される素数です。候補PEがPEになり、ベースの代わりに乱数が使用され、ハンティングとペッキングのプロセスがm回の反復を繰り返すまで続きます。mはサイドチャネル攻撃を防ぐために適切な大きな数です（[ RFC7664]）。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 5,
      "text": "found = 0 counter = 0 n = len(p) + 64 if (version < 1.3) context = ClientHello.random | ServerHello.random } else { context = ClientHello.random } do { counter = counter + 1 seed = H(base | counter | p) tmp = PRF(seed, \"TLS-PWD Hunting And Pecking\", context) [0..n] val = (tmp mod (p - 1)) + 1 if ( (val^3 + a*val + b) mod p is a quadratic residue) then if (found == 0) then x = val save = seed found = 1 base = random() fi fi } while ((found == 0) || (counter <= m)) y = sqrt(x^3 + a*x + b) mod p if ( lsb(y) == lsb(save)) then PE = (x, y) else PE = (x, p - y) fi",
      "ja": "found = 0 counter = 0 n = len（p）+ 64 if（version <1.3）context = ClientHello.random | ServerHello.random} else {context = ClientHello.random} do {counter = counter + 1 seed = H（base | counter | p）tmp = PRF（seed、 \"TLS-PWD Hunting And Pecking\"、context）[0 .. n] val =（tmp mod（p-1））+ 1 if（（val ^ 3 + a * val + b）mod pが2次剰余））if（found == 0）then x = val save = seed found = 1 base = random（）fi fi} while（（found == 0）||（counter <= m））y = sqrt（x ^ 3 + a * x + b）mod p if（lsb（y） == lsb（save））then PE =（x、y）else PE =（x、p-y）fi"
    },
    {
      "indent": 20,
      "text": "Figure 3: Fixing PE for ECC Groups",
      "ja": "図3：ECCグループのPEの修正"
    },
    {
      "indent": 3,
      "text": "Checking whether a value is a quadratic residue modulo a prime can leak information about that value in a side-channel attack. Therefore, it is RECOMMENDED that the technique used to determine if the value is a quadratic residue modulo p first blind the value with a random number so that the blinded value can take on all numbers between 1 and (p - 1) with equal probability. Determining the quadratic residue in a fashion that resists leakage of information is handled by flipping a coin and multiplying the blinded value by either a random quadratic residue or a random quadratic nonresidue and checking whether the multiplied value is a quadratic residue or a quadratic nonresidue modulo p, respectively. The random residue and nonresidue can be calculated prior to hunting and pecking by calculating the Legendre symbol on random values until they are found:",
      "ja": "値が素数を法とする二次剰余であるかどうかをチェックすると、サイドチャネル攻撃でその値に関する情報が漏洩する可能性があります。 したがって、値がpを法とする2次剰余であるかどうかを判断するために使用される手法は、ブラインド値が1から（p-1）までのすべての数値を等しい確率で引き継ぐことができるように、まず乱数で値をブラインドすることをお勧めします。 情報の漏洩に抵抗する方法で二次剰余を決定するには、コインを反転し、ブラインド値にランダム二次剰余またはランダム二次非剰余を乗算し、乗算値が二次剰余または二次非剰余p 、それぞれ。 ランダムな残基と非残基は、ランダム値でルジャンドル記号を計算することにより、それらが見つかるまでハンティングとペッキングの前に計算できます。"
    },
    {
      "indent": 3,
      "text": "do { qr = random() } while ( lgr(qr, p) != 1)",
      "ja": "do {qr = random（）} while（lgr（qr、p）！= 1）"
    },
    {
      "indent": 3,
      "text": "do { qnr = random() } while ( lgr(qnr, p) != -1)",
      "ja": "do {qnr = random（）} while（lgr（qnr、p）！= -1）"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the masking technique to find out whether a value is a quadratic residue modulo a prime or not looks like this:",
      "ja": "アルゴリズム的に、値が素数を法とする2次剰余であるかどうかを調べるマスキング手法は、次のようになります。"
    },
    {
      "indent": 3,
      "text": "is_quadratic_residue (val, p) { r = (random() mod (p - 1)) + 1 num = (val * r * r) mod p if ( lsb(r) == 1 ) num = (num * qr) mod p if ( lgr(num, p) == 1) then return TRUE fi else num = (num * qnr) mod p if ( lgr(num, p) == -1) then return TRUE fi fi return FALSE }",
      "ja": "is_quadratic_residue（val、p）{r =（random（）mod（p-1））+ 1 num =（val * r * r）mod p if（lsb（r）== 1）num =（num * qr） mod p if（lgr（num、p）== 1）then TRUE fi else num =（num * qnr）mod p if（lgr（num、p）== -1）then TRUE TRUE fi fi return FALSE}"
    },
    {
      "indent": 3,
      "text": "The random quadratic residue and quadratic nonresidue (qr and qnr above) can be used for all the hunting-and-pecking loops, but the blinding value, r, MUST be chosen randomly for each loop.",
      "ja": "ランダムな2次剰余および2次非剰余（上記のqrおよびqnr）は、すべての狩りとつつきループに使用できますが、ブラインド値rは各ループに対してランダムに選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Computing an FFC Password Element",
      "section_title": true,
      "ja": "4.4.2.  FFCパスワード要素の計算"
    },
    {
      "indent": 3,
      "text": "The group-specific operation for FFC groups takes the prime (p) and the order (q) from the group's domain parameter set and the variable pwd-value to directly produce a candidate PE, by exponentiating the pwd-value to the value ((p - 1)/q) modulo p. See Section 3.2.2 when the order is not part of the defined domain parameter set. If the result is greater than one (1), the candidate PE becomes the PE, and the hunting-and-pecking process continues until it has looped through m iterations, where m is a suitably large number to prevent side-channel attacks (see [RFC7664]).",
      "ja": "FFCグループのグループ固有の操作は、pwd-valueを値（（ p-1）/ q）pを法とする 順序が定義済みドメインパラメータセットの一部ではない場合は、セクション3.2.2を参照してください。 結果が1より大きい場合、候補PEはPEになり、ハンティングとペッキングのプロセスは、m回の繰り返しをループするまで続行されます。mは、サイドチャネル攻撃を防ぐために適切な数です（参照 [RFC7664]）。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 5,
      "text": "found = 0 counter = 0 n = len(p) + 64 if (version < 1.3) context = ClientHello.random | ServerHello.random } else { context = ClientHello.random } do { counter = counter + 1 pwd-seed = H(base | counter | p) pwd-tmp = PRF(pwd-seed, \"TLS-PWD Hunting And Pecking\", context) [0..n] pwd-value = (pwd-tmp mod (p - 1)) + 1 PE = pwd-value^((p - 1)/q) mod p if (PE > 1) then found = 1 base = random() fi } while ((found == 0) || (counter <= m))",
      "ja": "found = 0 counter = 0 n = len（p）+ 64 if（version <1.3）context = ClientHello.random | ServerHello.random} else {context = ClientHello.random} do {counter = counter + 1 pwd-seed = H（base | counter | p）pwd-tmp = PRF（pwd-seed、 \"TLS-PWD Hunting And Pecking\"、 コンテキスト）[0..n] pwd-value =（pwd-tmp mod（p-1））+ 1 PE = pwd-value ^（（p-1）/ q）mod p if（PE> 1）then found = 1 base = random（）fi} while（（found == 0）||（counter <= m））"
    },
    {
      "indent": 20,
      "text": "Figure 4: Fixing PE for FFC Groups",
      "ja": "図4：FFCグループのPEの修正"
    },
    {
      "indent": 0,
      "text": "4.4.3. Password Naming",
      "section_title": true,
      "ja": "4.4.3.  パスワードの命名"
    },
    {
      "indent": 3,
      "text": "The client is required to identify herself to the server by adding either a pwd_protect or pwd_clear extension to her ClientHello message, depending on whether the client wishes to protect her username (see Section 4.3) or not, respectively. The pwd_protect and pwd_clear extensions use the standard mechanism defined in [RFC5246]. The \"extension data\" field of the extension SHALL contain a pwd_name, which is used to identify the password shared between the client and server. If username protection is performed and the ExtensionType is pwd_protect, the contents of the pwd_name SHALL be constructed according to Section 4.3.1.",
      "ja": "クライアントは、クライアントがユーザー名（セクション4.3を参照）を保護するかどうかに応じて、ClientHelloメッセージにpwd_protectまたはpwd_clear拡張を追加することにより、サーバーに対して自身を識別する必要があります。 pwd_protectおよびpwd_clear拡張は、[RFC5246]で定義された標準メカニズムを使用します。 拡張の「拡張データ」フィールドには、クライアントとサーバー間で共有されるパスワードを識別するために使用されるpwd_nameが含まれる必要があります。 ユーザー名保護が実行され、ExtensionTypeがpwd_protectである場合、pwd_nameの内容はセクション4.3.1に従って構築される必要があります。"
    },
    {
      "indent": 6,
      "text": "enum { pwd_protect(29), pwd_clear(30) } ExtensionType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque pwd_name<1..2^8-1>;",
      "ja": "opaque pwd_name <1..2 ^ 8-1>;"
    },
    {
      "indent": 3,
      "text": "An unprotected pwd_name SHALL be a UTF-8 encoded character string processed according to the rules of the OpaqueString profile of [RFC8265], and a protected pwd_name SHALL be a string of bits.",
      "ja": "保護されていないpwd_nameは、[RFC8265]のOpaqueStringプロファイルの規則に従って処理されたUTF-8エンコード文字列でなければならず、保護されたpwd_nameはビット列でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Generating TLS-PWD Commit",
      "section_title": true,
      "ja": "4.4.4.  TLS-PWDコミットの生成"
    },
    {
      "indent": 3,
      "text": "The scalar and Element that comprise each peer's \"commitment\" are generated as follows.",
      "ja": "各ピアの「コミットメント」を構成するスカラーと要素は、次のように生成されます。"
    },
    {
      "indent": 3,
      "text": "First, two random numbers, called \"private\" and \"mask\", between zero and the order of the group (exclusive) are generated. If their sum modulo the order of the group, q, equals zero (0) or one (1), the numbers must be thrown away and new random numbers generated. If their sum modulo the order of the group, q, is greater than one, the sum becomes the scalar.",
      "ja": "最初に、「プライベート」と「マスク」と呼ばれる、ゼロとグループの順序（排他的）の間の2つの乱数が生成されます。 グループの次数qを法とする合計がゼロ（0）または1（1）に等しい場合、数値を破棄して新しい乱数を生成する必要があります。 グループの次数を法とする合計qが1より大きい場合、合計はスカラーになります。"
    },
    {
      "indent": 6,
      "text": "scalar = (private + mask) mod q",
      "ja": "スカラー=（プライベート+マスク）mod q"
    },
    {
      "indent": 3,
      "text": "The Element is then calculated as the inverse of the group's scalar operation (see the group-specific operations discussed in Section 3.2) with the mask and PE.",
      "ja": "Elementは、マスクとPEを使用して、グループのスカラー演算の逆数として計算されます（セクション3.2で説明したグループ固有の演算を参照）。"
    },
    {
      "indent": 6,
      "text": "Element = inverse(scalar-op(mask, PE))",
      "ja": "要素= inverse（scalar-op（mask、PE））"
    },
    {
      "indent": 3,
      "text": "After calculation of the scalar and Element, the mask SHALL be irretrievably destroyed.",
      "ja": "スカラーと要素の計算後、マスクは回復不能なほど破壊されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5. Changes to Handshake Message Contents",
      "section_title": true,
      "ja": "4.5.  ハンドシェイクメッセージの内容の変更"
    },
    {
      "indent": 0,
      "text": "4.5.1. Pre-1.3 TLS",
      "section_title": true,
      "ja": "4.5.1.  1.3より前のTLS"
    },
    {
      "indent": 0,
      "text": "4.5.1.1. ClientHello Changes",
      "section_title": true,
      "ja": "4.5.1.1。 ClientHelloの変更"
    },
    {
      "indent": 3,
      "text": "A client offering a PWD ciphersuite MUST include one of the pwd_name extensions from Section 4.4.3 in her ClientHello.",
      "ja": "PWD暗号スイートを提供するクライアントは、ClientHelloにセクション4.4.3のpwd_name拡張の1つを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server does not have a password for a client identified by the username either extracted from the pwd_name (if unprotected) or recovered using the technique provided in Section 4.3.2 (if protected), or if recovery of a protected username fails, the server SHOULD hide that fact by simulating the protocol -- putting random data in the PWD-specific components of the ServerKeyExchange -- and then rejecting the client's finished message with a \"bad_record_mac\" alert [RFC8446]. To properly effect a simulated TLS-PWD exchange, an appropriate delay SHOULD be inserted between receipt of the ClientHello and response of the ServerHello. Alternately, a server",
      "ja": "サーバーに、pwd_nameから抽出された（保護されていない場合）またはセクション4.3.2で提供されている手法を使用して回復された（保護されている場合）ユーザー名で識別されるクライアントのパスワードがない場合、または保護されたユーザー名の回復が失敗した場合、 サーバーはプロトコルをシミュレートしてその事実を隠すべきであり（ServerKeyExchangeのPWD固有のコンポーネントにランダムデータを入れて）、次に \"bad_record_mac\"アラート[RFC8446]でクライアントの終了メッセージを拒否します。 シミュレートされたTLS-PWD交換を適切に実行するには、ClientHelloの受信とServerHelloの応答の間に適切な遅延を挿入する必要があります。 代わりに、サーバー"
    },
    {
      "indent": 3,
      "text": "MAY choose to terminate the exchange if a password is not found. The security implication of terminating the exchange is to expose to an attacker whether a username is valid or not.",
      "ja": "パスワードが見つからない場合、交換を終了することを選択できます。 交換を終了することのセキュリティ上の意味は、ユーザー名が有効かどうかを攻撃者にさらすことです。"
    },
    {
      "indent": 3,
      "text": "The server decides on a group to use with the named user (see Section 9) and generates the PE according to Section 4.4.2.",
      "ja": "サーバーは、指定されたユーザーで使用するグループを決定し（セクション9を参照）、セクション4.4.2に従ってPEを生成します。"
    },
    {
      "indent": 0,
      "text": "4.5.1.2. ServerKeyExchange Changes",
      "section_title": true,
      "ja": "4.5.1.2。 ServerKeyExchangeの変更"
    },
    {
      "indent": 3,
      "text": "The domain parameter set for the selected group MUST be explicitly specified by name in the ServerKeyExchange. ECC groups are specified using the NamedCurve enumeration of [RFC8422], and FFC groups are specified using the NamedGroup extensions added by [RFC7919] to the \"TLS Supported Groups\" registry in [TLS_REG]. In addition to the group specification, the ServerKeyExchange also contains the server's \"commitment\" in the form of a scalar and Element, and the salt that was used to store the user's password.",
      "ja": "選択したグループのドメインパラメータセットは、ServerKeyExchangeで名前で明示的に指定する必要があります。 ECCグループは[RFC8422]のNamedCurve列挙を使用して指定され、FFCグループは[TLS_REG]の「TLS Supported Groups」レジストリに[RFC7919]によって追加されたNamedGroup拡張を使用して指定されます。 グループの指定に加えて、ServerKeyExchangeには、サーバーの「コミットメント」もスカラーと要素の形式で含まれ、ユーザーのパスワードを保存するために使用されたソルトも含まれます。"
    },
    {
      "indent": 3,
      "text": "Two new values have been added to the enumerated KeyExchangeAlgorithm to indicate TLS-PWD using FFC and TLS-PWD using ECC: ff_pwd and ec_pwd, respectively.",
      "ja": "2つの新しい値が列挙されたKeyExchangeAlgorithmに追加され、FFCを使用するTLS-PWDとECCを使用するTLS-PWDを示します。それぞれff_pwdとec_pwdです。"
    },
    {
      "indent": 16,
      "text": "enum { ff_pwd, ec_pwd } KeyExchangeAlgorithm;",
      "raw": true
    },
    {
      "indent": 16,
      "text": "struct {\n  opaque salt<1..2^8-1>;\n  NamedGroup ff_group;\n  opaque ff_selement<1..2^16-1>;\n  opaque ff_sscalar<1..2^16-1>;\n} ServerFFPWDParams;",
      "raw": true
    },
    {
      "indent": 16,
      "text": "struct {\n  opaque salt<1..2^8-1>;\n  ECParameters curve_params;\n  ECPoint ec_selement;\n  opaque ec_sscalar<1..2^8-1>;\n} ServerECPWDParams;",
      "raw": true
    },
    {
      "indent": 16,
      "text": "struct {\n  select (KeyExchangeAlgorithm) {\n    case ec_pwd:\n      ServerECPWDParams params;\n    case ff_pwd:\n      ServerFFPWDParams params;\n  };\n} ServerKeyExchange;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.1.2.1. Generation of ServerKeyExchange",
      "section_title": true,
      "ja": "4.5.1.2.1。 ServerKeyExchangeの生成"
    },
    {
      "indent": 3,
      "text": "The scalar and Element referenced in this section are derived according to Section 4.4.4.",
      "ja": "このセクションで参照されるスカラーと要素は、セクション4.4.4に従って導出されます。"
    },
    {
      "indent": 0,
      "text": "4.5.1.2.1.1. ECC ServerKeyExchange",
      "section_title": true,
      "ja": "4.5.1.2.1.1。 ECC ServerKeyExchange"
    },
    {
      "indent": 3,
      "text": "ECC domain parameters are specified in the ECParameters component of the ECC-specific ServerKeyExchange as defined in [RFC8422]. The scalar SHALL become the ec_sscalar component, and the Element SHALL become the ec_selement of the ServerKeyExchange. If the client requested a specific point format (compressed or uncompressed) with the Supported Point Formats Extension (see [RFC8422]) in its ClientHello, the Element MUST be formatted in the ec_selement to conform to that request. If the client offered (an) elliptic curve(s) in its ClientHello using the Supported Elliptic Curves Extension, the server MUST include (one of the) named curve(s) in the ECParameters field in the ServerKeyExchange and the key exchange operations specified in Section 4.5.1.2.1 MUST use that group.",
      "ja": "ECCドメインパラメータは、[RFC8422]で定義されているように、ECC固有のServerKeyExchangeのECParametersコンポーネントで指定されます。 スカラーはec_sscalarコンポーネントになり、要素はServerKeyExchangeのec_selementになります。 クライアントがClientHelloでサポートされているポイント形式拡張（[RFC8422]を参照）で特定のポイント形式（圧縮または非圧縮）を要求した場合、その要求に適合するようにec_selementで要素をフォーマットしなければなりません。 クライアントが、Supported Elliptic Curves Extensionを使用してClientHelloで楕円曲線を提供した場合、サーバーは、ServerKeyExchangeのECParametersフィールドに指定された曲線の1つと、 セクション4.5.1.2.1はそのグループを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 3.2.1, characteristic-2 curves and curves with a co-factor greater than one (1) SHALL NOT be used by TLS-PWD.",
      "ja": "セクション3.2.1で述べたように、特性2曲線および1より大きい補因子を持つ曲線は、TLS-PWDで使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.1.2.1.2. FFC ServerKeyExchange",
      "section_title": true,
      "ja": "4.5.1.2.1.2。 FFC ServerKeyExchange"
    },
    {
      "indent": 3,
      "text": "FFC domain parameters use the NamedGroup extension specified in [RFC7919]. The scalar SHALL become the ff_sscalar component, and the Element SHALL become the ff_selement in the FFC-specific ServerKeyExchange.",
      "ja": "FFCドメインパラメータは、[RFC7919]で指定されたNamedGroup拡張を使用します。 スカラーはff_sscalarコンポーネントになり、要素はFFC固有のServerKeyExchangeのff_selementになります。"
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 3.2.2, if the prime is a safe prime and no order is included in the domain parameter set, the order added to the ServerKeyExchange SHALL be the prime minus one divided by two -- (p - 1)/2.",
      "ja": "セクション3.2.2で述べたように、プライムが安全なプライムであり、ドメインパラメータセットに順序が含まれていない場合、ServerKeyExchangeに追加される順序は、プライムから1を2で割った値-（p-1）/ 2 。"
    },
    {
      "indent": 0,
      "text": "4.5.1.2.2. Processing of ServerKeyExchange",
      "section_title": true,
      "ja": "4.5.1.2.2。 ServerKeyExchangeの処理"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ServerKeyExchange, the client decides whether to support the indicated group or not. If the client decides to support the indicated group, the server's \"commitment\" MUST be validated by ensuring that 1) the server's scalar value is greater than one (1) and less than the order of the group, q and 2) the Element is valid for the chosen group (see Sections 3.2.1 and 3.2.2 for how to determine whether an Element is valid for the particular group. Note that if the Element is a compressed point on an elliptic curve, it MUST be uncompressed before checking its validity).",
      "ja": "ServerKeyExchangeを受信すると、クライアントは指定されたグループをサポートするかどうかを決定します。 クライアントが示されたグループをサポートすることを決定した場合、サーバーの「コミットメント」は、1）サーバーのスカラー値が1より大きく、グループの順序より小さいこと、qおよび2）要素が 選択されたグループに対して有効です（特定のグループに対して要素が有効かどうかを判断する方法については、セクション3.2.1および3.2.2を参照してください。要素が楕円曲線上の圧縮点である場合、チェックする前に圧縮解除する必要があります。 有効）。"
    },
    {
      "indent": 3,
      "text": "If the group is acceptable and the server's \"commitment\" has been successfully validated, the client extracts the salt from the ServerKeyExchange and generates the PE according to Sections 3.4 and 4.4.2. If the group is not acceptable or the server's \"commitment\" failed validation, the exchange MUST be aborted.",
      "ja": "グループが受け入れ可能で、サーバーの「コミットメント」が正常に検証された場合、クライアントはServerKeyExchangeからソルトを抽出し、セクション3.4および4.4.2に従ってPEを生成します。 グループが受け入れられない場合、またはサーバーの「コミットメント」が検証に失敗した場合、交換は中止されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.1.3. ClientKeyExchange Changes",
      "section_title": true,
      "ja": "4.5.1.3。 ClientKeyExchangeの変更"
    },
    {
      "indent": 3,
      "text": "When the value of KeyExchangeAlgorithm is either ff_pwd or ec_pwd, the ClientKeyExchange is used to convey the client's \"commitment\" to the server. It therefore contains a scalar and an Element.",
      "ja": "KeyExchangeAlgorithmの値がff_pwdまたはec_pwdの場合、ClientKeyExchangeを使用して、クライアントの「コミットメント」をサーバーに伝えます。 したがって、スカラーと要素が含まれます。"
    },
    {
      "indent": 21,
      "text": "struct {\n  opaque ff_celement<1..2^16-1>;\n  opaque ff_cscalar<1..2^16-1>;\n} ClientFFPWDParams;",
      "raw": true
    },
    {
      "indent": 21,
      "text": "struct {\n  ECPoint ec_celement;\n  opaque ec_cscalar<1..2^8-1>;\n} ClientECPWDParams;",
      "raw": true
    },
    {
      "indent": 21,
      "text": "struct {\n  select (KeyExchangeAlgorithm) {\n    case ff_pwd: ClientFFPWDParams;\n    case ec_pwd: ClientECPWDParams;\n  } exchange_keys;\n} ClientKeyExchange;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.1.3.1. Generation of ClientKeyExchange",
      "section_title": true,
      "ja": "4.5.1.3.1。 ClientKeyExchangeの生成"
    },
    {
      "indent": 3,
      "text": "The client's scalar and Element are generated in the manner described in Section 4.5.1.2.1.",
      "ja": "クライアントのスカラーと要素は、セクション4.5.1.2.1で説明されている方法で生成されます。"
    },
    {
      "indent": 3,
      "text": "For an FFC group, the scalar SHALL become the ff_cscalar component and the Element SHALL become the ff_celement in the FFC-specific ClientKeyExchange.",
      "ja": "FFCグループの場合、スカラーはFF_cscalarコンポーネントになり、要素はFFC固有のClientKeyExchangeのff_celementになります。"
    },
    {
      "indent": 3,
      "text": "For an ECC group, the scalar SHALL become the ec_cscalar component and the Element SHALL become the ec_celement in the ECC-specific ClientKeyExchange. If the client requested a specific point format (compressed or uncompressed) with the Supported Point Formats Extension in its ClientHello, then the Element MUST be formatted in the ec_celement to conform to its initial request.",
      "ja": "ECCグループの場合、スカラーはec_cscalarコンポーネントになり、要素はECC固有のClientKeyExchangeのec_celementになります。 クライアントがClientHelloでサポートされているPoint Formats Extensionを使用して特定のポイント形式（圧縮または非圧縮）を要求した場合、Elementは初期要求に適合するようにec_celementでフォーマットする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.1.3.2. Processing of ClientKeyExchange",
      "section_title": true,
      "ja": "4.5.1.3.2。 ClientKeyExchangeの処理"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ClientKeyExchange, the server must validate the client's \"commitment\" by ensuring that 1) the client's scalar and Element differ from the server's scalar and Element, 2) the client's scalar value is greater than one (1) and less than the order of the group, q, and 3) the Element is valid for the chosen group (see Sections 3.2.1 and 3.2.2 for how to determine whether an Element is valid for a particular group. Note that if the Element is a compressed point on an elliptic curve, it MUST be uncompressed before checking its validity). If any of these three conditions are not met, the server MUST abort the exchange.",
      "ja": "ClientKeyExchangeを受信すると、サーバーは、1）クライアントのスカラーとElementがサーバーのスカラーとElementと異なること、2）クライアントのスカラー値が1より大きく、1より小さいことを確認することにより、クライアントの「コミットメント」を検証する必要があります グループ、q、および3の順序）要素は、選択したグループに対して有効です（特定のグループに対して要素が有効かどうかを判断する方法については、セクション3.2.1および3.2.2を参照してください。要素が圧縮されている場合 楕円曲線上の点、有効性をチェックする前に圧縮解除する必要があります）。 これら3つの条件のいずれかが満たされない場合、サーバーは交換を中止しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.2. TLS 1.3",
      "section_title": true,
      "ja": "4.5.2.  TLS 1.3"
    },
    {
      "indent": 0,
      "text": "4.5.2.1. TLS 1.3 KeyShare",
      "section_title": true,
      "ja": "4.5.2.1。 TLS 1.3 KeyShare"
    },
    {
      "indent": 3,
      "text": "TLS 1.3 clients and servers convey their commit values in a \"key_share\" extension. The structure of this extension SHALL be:",
      "ja": "TLS 1.3クライアントとサーバーは、コミット値を「key_share」拡張機能で伝達します。 この拡張機能の構造は次のとおりです。"
    },
    {
      "indent": 13,
      "text": "enum { ff_pwd, ec_pwd } KeyExchangeAlgorithm;",
      "raw": true
    },
    {
      "indent": 13,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case ec_pwd:\n            opaque elemX[coordinate_length];\n            opaque elemY[coordinate_length];\n        case ff_pwd:\n            opaque elem[coordinate_length];\n     };\n     opaque scalar<1..2^8-1>\n} PWDKeyShareEntry;",
      "raw": true
    },
    {
      "indent": 13,
      "text": "struct {\n     NamedGroup group;\n     PWDKeyShareEntry pwd_key_exchange<1..2^16-1>;\n} KeyShareEntry;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.2.2. ClientHello Changes",
      "section_title": true,
      "ja": "4.5.2.2。 ClientHelloの変更"
    },
    {
      "indent": 3,
      "text": "The ClientHello message MUST include a pwd_name extension from Section 4.4.3 and it MUST include a key_share extension from Section 4.5.2.1.",
      "ja": "ClientHelloメッセージには、セクション4.4.3のpwd_name拡張を含める必要があり、セクション4.5.2.1のkey_share拡張を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a ClientHello, the server MUST validate the key_share extension_data [RFC8446] to ensure that the scalar value is greater than one (1) and less than the order of the group q, and that the Element is valid for the chosen group (see Sections 3.2.1 and 3.2.2).",
      "ja": "ClientHelloを受信すると、サーバーはkey_share extension_data [RFC8446]を検証して、スカラー値が1より大きく、グループqの順序よりも小さく、エレメントが選択されたグループに対して有効であることを確認する必要があります（ セクション3.2.1および3.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "If a server does not have a password for a client identified by the username either extracted from the pwd_name (if unprotected) or recovered using the technique in Section 4.3.2 (if protected), or if recovery of a protected username fails, the server SHOULD hide that fact by simulating the protocol -- putting random data in the PWD-specific components of its KeyShareEntry -- and then rejecting the client's finished message with a \"bad_record_mac\" alert. To properly effect a simulated TLS-PWD exchange, an appropriate delay SHOULD be inserted between receipt of the ClientHello and response of the ServerHello. Alternately, a server MAY choose to terminate the exchange if a password is not found. The security implication of terminating the exchange is to expose to an attacker whether a username is valid or not.",
      "ja": "pwd_nameから抽出された（保護されていない場合）、またはセクション4.3.2の手法を使用して回復された（保護されている場合）ユーザー名で識別されるクライアントのパスワードがサーバーにない場合、または保護されたユーザー名の回復が失敗した場合、サーバーは プロトコルをシミュレートして（KeyShareEntryのPWD固有のコンポーネントにランダムデータを入れて）、「bad_record_mac」アラートでクライアントの終了メッセージを拒否することにより、その事実を隠すべきです。 シミュレートされたTLS-PWD交換を適切に実行するには、ClientHelloの受信とServerHelloの応答の間に適切な遅延を挿入する必要があります。 または、パスワードが見つからない場合、サーバーは交換を終了することを選択する場合があります。 交換を終了することのセキュリティ上の意味は、ユーザー名が有効かどうかを攻撃者にさらすことです。"
    },
    {
      "indent": 0,
      "text": "4.5.2.3. ServerHello Changes",
      "section_title": true,
      "ja": "4.5.2.3。 ServerHelloの変更"
    },
    {
      "indent": 3,
      "text": "If the server supports TLS-PWD, agrees with the group chosen by the client, and finds an unsalted password indicated by the pwd_name extension of the received ClientHello, its ServerHello MUST contain a key_share extension from Section 4.5.2.1 in the same group as that chosen by the client.",
      "ja": "サーバーがTLS-PWDをサポートし、クライアントが選択したグループに同意し、受信したClientHelloのpwd_name拡張子で示される無塩パスワードを見つけた場合、ServerHelloは同じグループにセクション4.5.2.1のkey_share拡張を含まなければなりません クライアントが選択します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a ServerHello, the client MUST validate the key_share extension_data to ensure that the scalar value is greater than one (1) and less than the order of the group q, and that the Element is valid for the chosen group (see Sections 3.2.1 and 3.2.2).",
      "ja": "ServerHelloを受信すると、クライアントはkey_share extension_dataを検証して、スカラー値が1より大きく、グループqの順序よりも小さく、エレメントが選択されたグループに対して有効であることを確認する必要があります（セクション3.2を参照） .1および3.2.2）。"
    },
    {
      "indent": 0,
      "text": "4.5.2.4. HelloRetryRequest Changes",
      "section_title": true,
      "ja": "4.5.2.4。 HelloRetryRequestの変更"
    },
    {
      "indent": 3,
      "text": "The server sends this message in response to a ClientHello if it desires a different group or if the password identified by the client's password identified by pwd_name is salted.",
      "ja": "別のグループが必要な場合、またはpwd_nameで識別されるクライアントのパスワードで識別されるパスワードがソルトされている場合、サーバーはClientHelloに応答してこのメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "A different group is indicated by adding the KeyShareHelloRetryRequest extension to the HelloRetryRequest. The indication of a salted password, and the salt used, is done by adding the following structure:",
      "ja": "別のグループは、KeyShareHelloRetryRequest拡張をHelloRetryRequestに追加することで示されます。 ソルトされたパスワードと使用されたソルトの表示は、次の構造を追加することにより行われます。"
    },
    {
      "indent": 17,
      "text": "enum { password_salt(31) } ExtensionType;",
      "raw": true
    },
    {
      "indent": 17,
      "text": "struct {\n    opaque pwd_salt<2^16-1>;\n} password_salt;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A client that receives a HelloRetryRequest indicating the password salt SHALL delete its computed PE and derive another version using the salt prior to sending another ClientHello.",
      "ja": "パスワードsalt SHALLを示すHelloRetryRequestを受信したクライアントは、計算されたPEを削除し、別のClientHelloを送信する前にそのsaltを使用して別のバージョンを導出します。"
    },
    {
      "indent": 0,
      "text": "4.6. Computing the Shared Secret",
      "section_title": true,
      "ja": "4.6.  共有秘密の計算"
    },
    {
      "indent": 3,
      "text": "The client and server use their private value as calculated in Section 4.4.4 with the other party's Element and scalar for the ServerHello or ClientHello, respectively (here denoted \"Peer_Element\" and \"peer_scalar\") to generate the shared secret z.",
      "ja": "クライアントとサーバーは、セクション4.4.4で計算したプライベート値を、それぞれServerHelloまたはClientHelloの相手側の要素とスカラー（ここでは「Peer_Element」と「peer_scalar」と表示）とともに使用して、共有シークレットzを生成します。"
    },
    {
      "indent": 11,
      "text": "z = F(scalar-op(private,\n                elem-op(Peer_Element,\n                        scalar-op(peer_scalar, PE))))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For TLS versions prior to 1.3, the intermediate value, z, is then used as the premaster secret after any leading bytes of z that contain all zero bits have been stripped off. For TLS version 1.3, leading zero bytes are retained, and the intermediate value z is used as the (EC)DHE input in the key schedule.",
      "ja": "1.3より前のTLSバージョンの場合、ゼロ値をすべて含むzの先頭バイトが取り除かれた後、中間値zがプリマスターシークレットとして使用されます。 TLSバージョン1.3の場合、先行ゼロバイトが保持され、中間値zがキースケジュールの（EC）DHE入力として使用されます。"
    },
    {
      "indent": 0,
      "text": "5. Ciphersuite Definition",
      "section_title": true,
      "ja": "5.暗号スイートの定義"
    },
    {
      "indent": 3,
      "text": "This memo adds the following ciphersuites:",
      "ja": "このメモは、次の暗号スイートを追加します。"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = (0xC0,0xB0);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 =（0xC0,0xB0）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 =（0xC0,0xB1）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = (0xC0,0xB2);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 =（0xC0,0xB2）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 =（0xC0,0xB3）;"
    },
    {
      "indent": 3,
      "text": "Implementations conforming to this specification MUST support the TLS_ECCPWD_WITH_AES_128_GCM_SHA256 ciphersuite; they SHOULD support the remaining ciphersuites.",
      "ja": "この仕様に準拠する実装は、TLS_ECCPWD_WITH_AES_128_GCM_SHA256暗号スイートをサポートしなければなりません。 残りの暗号スイートをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When negotiated with a version of TLS prior to 1.2, the PRF from that earlier version is used; when the negotiated version of TLS is TLS 1.2, the PRF is the TLS 1.2 PRF [RFC5246], using the hash function indicated by the ciphersuite; when the negotiated version of TLS is TLS 1.3, the PRF is the Derive-Secret function from Section 7.1 of [RFC8446]. Regardless of the TLS version, the TLS-PWD random function, H, is always instantiated with the hash algorithm indicated by the ciphersuite.",
      "ja": "1.2より前のバージョンのTLSとネゴシエートされる場合、その以前のバージョンのPRFが使用されます。 TLSのネゴシエートされたバージョンがTLS 1.2である場合、PRFはTLS 1.2 PRF [RFC5246]であり、暗号スイートによって示されるハッシュ関数を使用します。 TLSのネゴシエートされたバージョンがTLS 1.3である場合、PRFは[RFC8446]のセクション7.1の派生秘密関数です。 TLSバージョンに関係なく、TLS-PWDランダム関数Hは、暗号スイートによって示されるハッシュアルゴリズムで常にインスタンス化されます。"
    },
    {
      "indent": 3,
      "text": "For those ciphersuites that use Cipher Block Chaining (CBC) [SP800-38A] mode, the MAC is HMAC [RFC2104] with the hash function indicated by the ciphersuite.",
      "ja": "Cipher Block Chaining（CBC）[SP800-38A]モードを使用する暗号スイートの場合、MACはHMAC [RFC2104]であり、暗号スイートによって示されるハッシュ関数を持ちます。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned three values for new TLS extension types from the \"TLS ExtensionType Values\" registry defined in [RFC8446] and [RFC8447]. They are pwd_protect (29), pwd_clear (30), and password_salt (31). See Sections 4.5.1.1 and 4.5.2.2 for more information.",
      "ja": "IANAは、[RFC8446]および[RFC8447]で定義されている「TLS ExtensionType Values」レジストリから、新しいTLS拡張タイプに3つの値を割り当てました。 それらは、pwd_protect（29）、pwd_clear（30）、およびpassword_salt（31）です。 詳細については、セクション4.5.1.1および4.5.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "In summary, the following rows have been added to the \"TLS ExtensionType Values\" registry:",
      "ja": "要約すると、「TLS ExtensionType Values」レジストリに次の行が追加されました。"
    },
    {
      "indent": 11,
      "text": "+-------+----------------+-------------+-----------+\n| Value | Extension Name |   TLS 1.3   | Reference |\n+-------+----------------+-------------+-----------+\n|   29  |  pwd_protect   |      CH     |  RFC 8492 |\n|   30  |   pwd_clear    |      CH     |  RFC 8492 |\n|   31  | password_salt  | CH, SH, HRR |  RFC 8492 |\n+-------+----------------+-------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IANA has assigned the following ciphersuites from the \"TLS Cipher Suites\" registry defined in [RFC8446] and [RFC8447]:",
      "ja": "IANAは、[RFC8446]および[RFC8447]で定義されている「TLS Cipher Suites」レジストリから次の暗号スイートを割り当てています。"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = (0xC0,0xB0);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 =（0xC0,0xB0）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 =（0xC0,0xB1）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = (0xC0,0xB2);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 =（0xC0,0xB2）;"
    },
    {
      "indent": 6,
      "text": "CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);",
      "ja": "CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 =（0xC0,0xB3）;"
    },
    {
      "indent": 3,
      "text": "The \"DTLS-OK\" column in the registry has been set to \"Y\", and the \"Recommended\" column has been set to \"N\" for all ciphersuites defined in this memo.",
      "ja": "レジストリの「DTLS-OK」列は「Y」に設定されており、「推奨」列はこのメモで定義されているすべての暗号スイートに対して「N」に設定されています。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A security proof of this key exchange in the random oracle model is found in [lanskro].",
      "ja": "ランダムオラクルモデルにおけるこの鍵交換のセキュリティ証明は、[lanskro]にあります。"
    },
    {
      "indent": 3,
      "text": "A passive attacker against this protocol will see the ServerKeyExchange and the ClientKeyExchange (in TLS pre-1.3), or the KeyShare (from TLS 1.3), containing the scalar and Element of the server and the client, respectively. The client and server effectively hide their secret private value by masking it modulo the order of the selected group. If the order is \"q\", then there are approximately \"q\" distinct pairs of numbers that will sum to the scalar values observed. It is possible for an attacker to iterate through all such values, but for a large value of \"q\", this exhaustive search technique is computationally infeasible. The attacker would have a better chance in solving the discrete logarithm problem, which we have already assumed (see Section 3.5) to be an intractable problem.",
      "ja": "このプロトコルに対する受動的な攻撃者は、ServerKeyExchangeとClientKeyExchange（TLS 1.3より前）、またはKeyShare（TLS 1.3から）を見て、それぞれサーバーとクライアントのスカラーと要素を含んでいます。 クライアントとサーバーは、選択したグループの順序を法としてそれをマスクすることにより、秘密のプライベート値を効果的に隠します。 順序が「q」の場合、観測されるスカラー値に合計される数値のおよそ「q」個の別個のペアがあります。 攻撃者はそのようなすべての値を反復処理することができますが、「q」の値が大きい場合、この徹底的な検索手法は計算上実行不可能です。 攻撃者は、離散対数問題を解決する可能性が高くなります。これは、手に負えない問題であると既に想定しています（セクション3.5を参照）。"
    },
    {
      "indent": 3,
      "text": "A passive attacker can take the Element from the ServerKeyExchange or the ClientKeyExchange (in TLS pre-1.3), or from the KeyShare (from TLS 1.3), and try to determine the random \"mask\" value used in its construction and then recover the other party's \"private\" value from the scalar in the same message. But this requires the attacker to solve the discrete logarithm problem, which we assumed was intractable.",
      "ja": "受動的な攻撃者は、ServerKeyExchangeまたはClientKeyExchange（TLS pre-1.3内）、またはKeyShare（TLS 1.3から）からElementを取得し、その構築で使用されたランダムな「マスク」値を決定してから、他の 同じメッセージ内のスカラーからのパーティの「プライベート」値。 しかし、これには、攻撃者が離散対数問題を解決する必要があります。"
    },
    {
      "indent": 3,
      "text": "Both the client and the server obtain a shared secret based on a secret group Element and the private information they contributed to the exchange. The secret group Element is based on the password. If they do not share the same password, they will be unable to derive the same secret group Element, and if they don't generate the same secret group Element, they will be unable to generate the same shared secret. Seeing a finished message will not provide any additional advantage of attack, since it is generated with the unknowable secret.",
      "ja": "クライアントとサーバーの両方が、シークレットグループ要素と、交換に貢献したプライベート情報に基づいて共有シークレットを取得します。 秘密グループ要素はパスワードに基づいています。 同じパスワードを共有しない場合、同じシークレットグループエレメントを導出できず、同じシークレットグループエレメントを生成しない場合、同じ共有シークレットを生成できません。 完成したメッセージを見ると、未知の秘密で生成されるため、攻撃の追加の利点は提供されません。"
    },
    {
      "indent": 3,
      "text": "In TLS pre-1.3, an active attacker impersonating the client can induce a server to send a ServerKeyExchange containing the server's scalar and Element. The attacker can attempt to generate a ClientKeyExchange and send it to the server, but she is required to send a finished message first; therefore, the only information she can obtain in this attack is less than the information she can obtain from a passive attack, so this particular active attack is not very fruitful.",
      "ja": "TLS 1.3以前では、アクティブな攻撃者がクライアントになりすまして、サーバーにサーバーのスカラーと要素を含むServerKeyExchangeを送信させることができます。 攻撃者はClientKeyExchangeを生成してサーバーに送信しようとすることができますが、最初に終了メッセージを送信する必要があります。 したがって、この攻撃で取得できる情報は、受動的攻撃から取得できる情報よりも少ないため、この特定の能動的攻撃はあまり有益ではありません。"
    },
    {
      "indent": 3,
      "text": "In TLS pre-1.3, an active attacker can impersonate the server and send a forged ServerKeyExchange after receiving the ClientHello. The attacker then waits until it receives the ClientKeyExchange and finished message from the client. Now the attacker can attempt to run through all possible values of the password, computing the PE (see Section 4.4), computing candidate premaster secrets (see Section 4.6), and attempting to recreate the client's finished message.",
      "ja": "TLS 1.3より前では、アクティブな攻撃者は、ClientHelloを受信した後にサーバーになりすまし、偽造されたServerKeyExchangeを送信できます。 その後、攻撃者はClientKeyExchangeを受信し、クライアントからメッセージを終了するまで待機します。 これで、攻撃者はパスワードのすべての可能な値を実行し、PEを計算し（セクション4.4を参照）、候補プリマスターシークレットを計算し（セクション4.6を参照）、クライアントの完成したメッセージの再作成を試みることができます。"
    },
    {
      "indent": 3,
      "text": "But the attacker committed to a single guess of the password with her forged ServerKeyExchange. That value was used by the client in her computation of the premaster secret, which was used to produce the finished message. Any guess of the password that differs from the password used in the forged ServerKeyExchange would result in each side using a different PE in the computation of the premaster secret; therefore, the finished message cannot be verified as correct, even if a subsequent guess, while running through all possible values, was correct. The attacker gets one guess, and one guess only, per active attack.",
      "ja": "しかし、攻撃者は偽造されたServerKeyExchangeでパスワードを1回推測することを約束しました。 その値は、完成したメッセージを生成するために使用されたプリマスターシークレットの計算でクライアントによって使用されました。 偽造されたServerKeyExchangeで使用されるパスワードと異なるパスワードの推測は、プリマスターシークレットの計算でそれぞれの側が異なるPEを使用することになります。 したがって、可能性のあるすべての値を実行中に後続の推測が正しかったとしても、完成したメッセージを正しいものとして検証することはできません。 攻撃者は、アクティブな攻撃ごとに1つの推測、および1つの推測のみを取得します。"
    },
    {
      "indent": 3,
      "text": "Instead of attempting to guess at the password, an attacker can attempt to determine the PE and then launch an attack. But the PE is determined by the output of the random function, H, which is indistinguishable from a random source, since H is assumed to be a \"random oracle\" (Section 3.5). Therefore, each Element of the finite cyclic group will have an equal probability of being the PE. The probability of guessing the PE will be 1/q, where q is the order of the group. For a large value of \"q\", this will be computationally infeasible.",
      "ja": "パスワードを推測する代わりに、攻撃者はPEを特定してから攻撃を開始できます。 ただし、PEはランダム関数の出力によって決定されます。Hはランダムソースと区別できないため、Hは「ランダムオラクル」と見なされるためです（セクション3.5）。 したがって、有限巡回グループの各要素は、PEになる確率が等しくなります。 PEを推測する確率は1 / qになります。ここで、qはグループの次数です。 「q」の値が大きい場合、これは計算上実行不可能です。"
    },
    {
      "indent": 3,
      "text": "The implications of resistance to dictionary attacks are significant. An implementation can provision a password in a practical and realistic manner -- i.e., it MAY be a character string, and it MAY be relatively short -- and still maintain security. The nature of the pool of potential passwords determines the size of the pool, D, and countermeasures can prevent an attacker from determining the password in the only possible way: repeated, active, guessing attacks. For example, a simple four-character string using lowercase English characters, and assuming random selection of those characters, will result in D of over four hundred thousand. An attacker would need to mount over one hundred thousand active, guessing attacks (which will easily be detected) before gaining any significant advantage in determining the pre-shared key.",
      "ja": "辞書攻撃に対する抵抗の意味は重要です。 実装は、実用的で現実的な方法でパスワードをプロビジョニングできます-つまり、文字列である場合があり、比較的短い場合があります-そして、セキュリティを維持します。 潜在的なパスワードのプールの性質により、プールのサイズDが決まり、対策により、攻撃者が唯一の可能な方法（繰り返し、アクティブ、推測攻撃）でパスワードを決定できなくなります。 たとえば、小文字の英語文字を使用し、それらの文字をランダムに選択すると仮定した単純な4文字の文字列では、Dは40万を超えます。 攻撃者は、事前共有キーを決定する際に大きな利点を得る前に、10万を超える推測攻撃（簡単に検出されます）を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures to deal with successive active, guessing attacks are only possible by noticing that a certain username is failing repeatedly over a certain period of time. Attacks that attempt to find a password for a random user are more difficult to detect. For instance, if a device uses a serial number as a username and the pool of potential passwords is sufficiently small, a more effective attack would be to select a password and try all potential \"users\" to disperse the attack and confound countermeasures. It is therefore RECOMMENDED that implementations of TLS-PWD keep track of the total number of failed authentications, regardless of username, in an effort to detect and thwart this type of attack.",
      "ja": "連続したアクティブな推測攻撃に対処するための対策は、特定のユーザー名が特定の期間にわたって繰り返し失敗していることに注意することによってのみ可能です。 ランダムなユーザーのパスワードを見つけようとする攻撃は、検出がより困難です。 たとえば、デバイスがユーザー名としてシリアル番号を使用し、潜在的なパスワードのプールが十分に小さい場合、より効果的な攻撃はパスワードを選択し、すべての潜在的な「ユーザー」を試して攻撃を分散させ、対策を混乱させることです。 したがって、TLS-PWDの実装は、このタイプの攻撃を検出して阻止するために、ユーザー名に関係なく、失敗した認証の総数を追跡することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The benefits of resistance to dictionary attacks can be lessened by a client using the same passwords with multiple servers. An attacker could redirect a session from one server to the other if the attacker knew that the intended server stored the same password for the client as another server.",
      "ja": "辞書攻撃に対する抵抗の利点は、クライアントが複数のサーバーで同じパスワードを使用することにより軽減される可能性があります。 攻撃者は、目的のサーバーが別のサーバーと同じクライアントのパスワードを保存していることを知っている場合、あるサーバーから別のサーバーにセッションをリダイレクトできます。"
    },
    {
      "indent": 3,
      "text": "An adversary that has access to, and a considerable amount of control over, a client or server could attempt to mount a side-channel attack to determine the number of times it took for a certain password (plus client random and server random) to select a PE. Each such attack could result in a successive \"paring down\" of the size of the pool of potential passwords, resulting in a manageably small set from which to launch a series of active attacks to determine the password. A security parameter, m, is used to normalize the amount of work necessary to determine the PE (see Section 4.4). The probability that a password will require more than m iterations is roughly (q/2p)^m for ECC groups and (q/p)^m for FFC groups, so it is possible to mitigate side-channel attacks at the expense of a constant cost per connection attempt. But if a particular password requires more than k iterations, it will leak k bits of information to the side-channel attacker; for some dictionaries, this will uniquely identify the password. Therefore, the security parameter, m, needs to be set with great care. It is RECOMMENDED that an implementation set the security parameter, m, to a value of at least forty (40), which will put the probability that more than forty iterations are needed in the order of one in one trillion (1:1,000,000,000,000).",
      "ja": "クライアントまたはサーバーにアクセスし、それをかなり制御できる攻撃者は、サイドチャネル攻撃を仕掛けて、特定のパスワード（およびクライアントランダムとサーバーランダム）が選択するのにかかった回数を判断しようとする可能性があります。 PE。そのような攻撃はそれぞれ、潜在的なパスワードのプールのサイズを連続して「削減」し、一連のアクティブな攻撃を開始してパスワードを決定する管理可能な小さなセットをもたらす可能性があります。セキュリティパラメータmは、PEの決定に必要な作業量を正規化するために使用されます（セクション4.4を参照）。パスワードがm回を超える反復を必要とする確率は、ECCグループではおおよそ（q / 2p）^ m、FFCグループでは（q / p）^ mであるため、サイドチャネル攻撃を軽減することは可能ですが、接続試行ごとの一定のコスト。ただし、特定のパスワードがk回を超える反復を必要とする場合、サイドビット攻撃者にkビットの情報が漏洩します。一部の辞書では、これによりパスワードが一意に識別されます。そのため、セキュリティパラメータmは細心の注意を払って設定する必要があります。実装では、セキュリティパラメータmを少なくとも40の値に設定することをお勧めします。これにより、40を超える反復が1兆分の1（1：1,000,000,000,000）のオーダーで必要になる確率が高くなります。"
    },
    {
      "indent": 3,
      "text": "A database of salted passwords prevents an adversary who gains access to the database from learning the client's password; it does not prevent such an adversary from impersonating the client back to the server. Each side uses the salted password, called the base, as the authentication credential, so the database of salted passwords MUST be afforded the security of a database of plaintext passwords.",
      "ja": "ソルトパスワードのデータベースは、データベースにアクセスする攻撃者がクライアントのパスワードを学習するのを防ぎます。 そのような敵がクライアントになりすましてサーバーに戻るのを防ぐことはできません。 各サイドは、認証資格情報としてベースと呼ばれるソルトパスワードを使用するため、ソルトパスワードのデータベースには、プレーンテキストパスワードのデータベースのセキュリティを確保する必要があります。"
    },
    {
      "indent": 3,
      "text": "Authentication is performed by proving knowledge of the password. Any third party that knows the password shared by the client and server can impersonate one to the other.",
      "ja": "認証は、パスワードの知識を証明することにより実行されます。 クライアントとサーバーが共有するパスワードを知っている第三者は、一方を他方になりすますことができます。"
    },
    {
      "indent": 3,
      "text": "The static-ephemeral Diffie-Hellman exchange used to protect usernames requires the server to reuse its Diffie-Hellman public key. To prevent an \"invalid curve\" attack, an entity that reuses its Diffie-Hellman public key needs to check whether the received ephemeral public key is actually a point on the curve. This is done explicitly as part of the server's reconstruction of the client's public key out of only its x-coordinate (\"compact representation\").",
      "ja": "ユーザー名を保護するために使用される静的一時的なDiffie-Hellman交換では、サーバーがDiffie-Hellman公開キーを再利用する必要があります。 「無効な曲線」攻撃を防ぐには、Diffie-Hellman公開鍵を再利用するエンティティは、受信した一時公開鍵が実際に曲線上の点であるかどうかを確認する必要があります。 これは、x座標（「コンパクトな表現」）のみからサーバーがクライアントの公開キーを再構築する一環として明示的に行われます。"
    },
    {
      "indent": 0,
      "text": "8. Human Rights Considerations",
      "section_title": true,
      "ja": "8.人権に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "At the time of publication of this document, there was a growing interest in considering the impacts that IETF (and IRTF) work can have on human rights; some related research is discussed in [RFC8280]. As such, the human rights considerations of TLS-PWD are presented here.",
      "ja": "このドキュメントの発行時点で、IETF（およびIRTF）の作業が人権に与える影響を考慮することに関心が高まっていました。 いくつかの関連する研究は[RFC8280]で議論されています。 そのため、TLS-PWDの人権に関する考慮事項をここに示します。"
    },
    {
      "indent": 3,
      "text": "The key exchange underlying TLS-PWD uses public key cryptography to perform authentication and authenticated key exchange. The keys it produces can be used to establish secure connections between two people to protect their communication. Implementations of TLS-PWD, like implementations of other TLS ciphersuites that perform authentication and authenticated key establishment, are considered \"armaments\" or \"munitions\" by many governments around the world.",
      "ja": "TLS-PWDの基礎となる鍵交換は、公開鍵暗号化を使用して認証および認証された鍵交換を実行します。 生成されたキーを使用して、2人のユーザー間の安全な接続を確立し、通信を保護できます。 TLS-PWDの実装は、認証および認証されたキーの確立を実行する他のTLS暗号スイートの実装と同様に、世界中の多くの政府によって「兵器」または「弾薬」と見なされています。"
    },
    {
      "indent": 3,
      "text": "The most fundamental of human rights is the right to protect oneself. The right to keep and bear arms is an example of this right. Implementations of TLS-PWD can be used as arms, kept and borne, to defend oneself against all manner of attackers -- criminals, governments, lawyers, etc. TLS-PWD is a powerful tool in the promotion and defense of universal human rights.",
      "ja": "人権の最も基本的なものは、自分自身を守る権利です。 武器を保持および保有する権利は、この権利の一例です。 TLS-PWDの実装は、犯罪者、政府、弁護士など、あらゆる種類の攻撃者から身を守るための武器として使用できます。TLS-PWDは、普遍的な人権の促進と防衛における強力なツールです。"
    },
    {
      "indent": 0,
      "text": "9. Implementation Considerations",
      "section_title": true,
      "ja": "9.実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The selection of the ciphersuite and selection of the particular finite cyclic group to use with the ciphersuite are divorced in this memo, but they remain intimately close.",
      "ja": "暗号スイートの選択と、暗号スイートで使用する特定の有限サイクリックグループの選択は、このメモでは離婚されていますが、密接に近いままです。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that implementations take note of the strength estimates of particular groups and select a ciphersuite providing commensurate security with its hash and encryption algorithms. A ciphersuite whose encryption algorithm has a keylength less than the strength estimate or whose hash algorithm has a block size that is less than twice the strength estimate SHOULD NOT be used.",
      "ja": "実装では、特定のグループの強度推定値に注意し、そのハッシュと暗号化アルゴリズムで適切なセキュリティを提供する暗号スイートを選択することをお勧めします。 暗号化アルゴリズムのキー長が強度推定値よりも小さいか、ハッシュアルゴリズムのブロックサイズが強度推定値の2倍よりも小さい暗号スイートは使用しないでください。"
    },
    {
      "indent": 3,
      "text": "For example, the elliptic curve named \"brainpoolP256r1\" (whose IANA-assigned number is 26) [RFC7027] provides an estimated 128 bits of strength and would be compatible with 1) an encryption algorithm supporting a key of that length and 2) a hash algorithm that has at least a 256-bit block size. Therefore, a suitable ciphersuite to use with brainpoolP256r1 could be TLS_ECCPWD_WITH_AES_128_GCM_SHA256 (see Appendix A for an example of such an exchange).",
      "ja": "たとえば、「brainpoolP256r1」という名前の楕円曲線（IANAが割り当てた番号は26）[RFC7027]は、推定128ビットの強度を提供し、1）その長さのキーをサポートする暗号化アルゴリズム、2）ハッシュ 少なくとも256ビットのブロックサイズを持つアルゴリズム。 したがって、brainpoolP256r1で使用する適切な暗号スイートは、TLS_ECCPWD_WITH_AES_128_GCM_SHA256である可能性があります（このような交換の例については、付録Aを参照してください）。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attacks means that the attacker must launch an active attack to make a single guess at the password. If the size of the pool from which the password was extracted was D and each password in the pool has an equal probability of being chosen, then the probability of success after a single guess is 1/D. After X guesses and the removal of failed guesses from the pool of possible passwords, the probability becomes 1/(D-X). As X grows, so does the probability of success. Therefore, it is possible for an attacker to determine the password through repeated brute-force, active, guessing attacks. Implementations SHOULD take note of this fact and choose an appropriate pool of potential passwords -- i.e., make D big. Implementations SHOULD also take countermeasures -- for instance, refusing authentication attempts by a particular username for a certain amount of time, after the number of failed authentication attempts reaches a certain threshold. No such threshold or amount of time is recommended in this memo.",
      "ja": "辞書攻撃に対する抵抗とは、攻撃者がアクティブな攻撃を開始してパスワードを推測する必要があることを意味します。パスワードが抽出されたプールのサイズがDで、プール内の各パスワードが選択される確率が等しい場合、1回の推測後の成功の確率は1 / Dです。 Xが推測し、失敗した推測を可能なパスワードのプールから削除すると、確率は1 /（D-X）になります。 Xが大きくなると、成功の確率も大きくなります。したがって、攻撃者は、ブルートフォースのアクティブな推測攻撃を繰り返してパスワードを決定することができます。実装はこの事実に留意し、潜在的なパスワードの適切なプールを選択する必要があります（つまり、Dを大きくします）。実装は、たとえば、失敗した認証試行の回数が特定のしきい値に達した後、特定のユーザー名による認証試行を一定時間拒否するなどの対策も講じる必要があります。このメモでは、このようなしきい値や時間は推奨されていません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参照"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1.  規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のキー付きハッシュ」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<https：//www.rfc-editor .org / info / rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5297] Harkins, D., \"Synthetic Initialization Vector (SIV) Authenticated Encryption Using the Advanced Encryption Standard (AES)\", RFC 5297, DOI 10.17487/RFC5297, October 2008, <https://www.rfc-editor.org/info/rfc5297>.",
      "ja": "[RFC5297] Harkins、D。、「Advanced Encryption Standard（AES）を使用した合成初期化ベクトル（SIV）認証暗号化」、RFC 5297、DOI 10.17487 / RFC5297、2008年10月、<https://www.rfc-editor.org / info / rfc5297>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <https://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー派生関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<https：//www.rfc-editor .org / info / rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC7919] Gillmor, D., \"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)\", RFC 7919, DOI 10.17487/RFC7919, August 2016, <https://www.rfc-editor.org/info/rfc7919>.",
      "ja": "[RFC7919] Gillmor、D。、「トランスポート層セキュリティ（TLS）のネゴシエートされた有限フィールドDiffie-Hellman一時パラメータ」、RFC 7919、DOI 10.17487 / RFC7919、2016年8月、<https://www.rfc-editor.org/ info / rfc7919>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8265] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 8265, DOI 10.17487/RFC8265, October 2017, <https://www.rfc-editor.org/info/rfc8265>.",
      "ja": "[RFC8265] Saint-Andre、P。およびA. Melnikov、「ユーザー名とパスワードを表す国際化された文字列の準備、施行、比較」、RFC 8265、DOI 10.17487 / RFC8265、2017年10月、<https：//www.rfc- editor.org/info/rfc8265>。"
    },
    {
      "indent": 3,
      "text": "[RFC8422] Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier\", RFC 8422, DOI 10.17487/RFC8422, August 2018, <https://www.rfc-editor.org/info/rfc8422>.",
      "ja": "[RFC8422] Nir、Y.、Josefsson、S。、およびM. Pegourie-Gonnard、「トランスポート層セキュリティ（TLS）バージョン1.2以前の楕円曲線暗号（ECC）暗号スイート」、RFC 8422、DOI 10.17487 / RFC8422 2018年8月、<https://www.rfc-editor.org/info/rfc8422>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8447] Salowey, J. and S. Turner, \"IANA Registry Updates for TLS and DTLS\", RFC 8447, DOI 10.17487/RFC8447, August 2018, <https://www.rfc-editor.org/info/rfc8447>.",
      "ja": "[RFC8447] Salowey、J。およびS. Turner、「TLSおよびDTLSのIANAレジストリ更新」、RFC 8447、DOI 10.17487 / RFC8447、2018年8月、<https://www.rfc-editor.org/info/rfc8447> 。"
    },
    {
      "indent": 3,
      "text": "[TLS_REG] IANA, \"Transport Layer Security (TLS) Parameters\", <https://www.iana.org/assignments/tls-parameters/>.",
      "ja": "[TLS_REG] IANA、「トランスポート層セキュリティ（TLS）パラメーター」、<https://www.iana.org/assignments/tls-parameters/>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2.  有益な参考文献"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", Federal Information Processing Standards Publication 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <https://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[FIPS186-4]国立標準技術研究所、「デジタル署名標準（DSS）」、連邦情報処理標準出版物186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月、<https：// nvlpubs .nist.gov / nistpubs / FIPS / NIST.FIPS.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[lanskro] Lancrenon, J. and M. Skrobot, \"On the Provable Security of the Dragonfly Protocol\", ISC 2015 Proceedings of the 18th International Conference on Information Security - Volume 9290, pp. 244-261, DOI 10.1007/978-3-319-23318-5_14, September 2015.",
      "ja": "[lanskro] Lancrenon、J。およびM. Skrobot、「トンボプロトコルの証明可能なセキュリティについて」、ISC 2015情報セキュリティに関する第18回国際会議の議事録-第9290巻、244-261、DOI 10.1007 / 978-3 -319-23318-5_14、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[RANDOR] Bellare, M. and P. Rogaway, \"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols\", Proceedings of the 1st ACM Conference on Computer and Communications Security, pp. 62-73, ACM Press, DOI 10.1145/168588.168596, November 1993.",
      "ja": "[RANDOR] Bellare、M.、P。Rogaway、「Random Oracles are Practical：A Paradigm for Designing Efficient Protocols」、Proceedings of the 1st ACM Conference on Computer and Communications Security、pp.62-73、ACM Press、DOI 10.1145 / 168588.168596、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<https：//www.rfc-editor .org / info / rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <https://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「Fundamental Elliptic Curve Cryptography Algorithms」、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<https://www.rfc-editor.org/ info / rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC7027] Merkle, J. and M. Lochter, \"Elliptic Curve Cryptography (ECC) Brainpool Curves for Transport Layer Security (TLS)\", RFC 7027, DOI 10.17487/RFC7027, October 2013, <https://www.rfc-editor.org/info/rfc7027>.",
      "ja": "[RFC7027] Merkle、J。およびM. Lochter、「トランスポート層セキュリティ（TLS）の楕円曲線暗号（ECC）脳プール曲線」、RFC 7027、DOI 10.17487 / RFC7027、2013年10月、<https：//www.rfc- editor.org/info/rfc7027>。"
    },
    {
      "indent": 3,
      "text": "[RFC7030] Pritikin, M., Ed., Yee, P., Ed., and D. Harkins, Ed., \"Enrollment over Secure Transport\", RFC 7030, DOI 10.17487/RFC7030, October 2013, <https://www.rfc-editor.org/info/rfc7030>.",
      "ja": "[RFC7030] Pritikin、M.、Ed。、Yee、P.、Ed。、and D. Harkins、Ed。、 \"Enrollment over Secure Transport\"、RFC 7030、DOI 10.17487 / RFC7030、October 2013、<https：// www.rfc-editor.org/info/rfc7030>。"
    },
    {
      "indent": 3,
      "text": "[RFC7664] Harkins, D., Ed., \"Dragonfly Key Exchange\", RFC 7664, DOI 10.17487/RFC7664, November 2015, <https://www.rfc-editor.org/info/rfc7664>.",
      "ja": "[RFC7664] Harkins、D.、Ed。、 \"Dragonfly Key Exchange\"、RFC 7664、DOI 10.17487 / RFC7664、November 2015、<https://www.rfc-editor.org/info/rfc7664>。"
    },
    {
      "indent": 3,
      "text": "[RFC8280] ten Oever, N. and C. Cath, \"Research into Human Rights Protocol Considerations\", RFC 8280, DOI 10.17487/RFC8280, October 2017, <https://www.rfc-editor.org/info/rfc8280>.",
      "ja": "[RFC8280] ten Oever、N。およびC. Cath、「Research into Human Rights Protocol Considerations」、RFC 8280、DOI 10.17487 / RFC8280、2017年10月、<https://www.rfc-editor.org/info/rfc8280> 。"
    },
    {
      "indent": 3,
      "text": "[SP800-38A] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation - Methods and Techniques\", NIST Special Publication 800-38A, DOI 10.6028/NIST.SP.800-38A, December 2001, <https://nvlpubs.nist.gov/nistpubs/ Legacy/SP/nistspecialpublication800-38a.pdf>.",
      "ja": "[SP800-38A] Dworkin、M。、「ブロック暗号操作モードの推奨-方法と手法」、NIST特別公開800-38A、DOI 10.6028 / NIST.SP.800-38A、2001年12月、<https：// nvlpubs.nist.gov/nistpubs/ Legacy / SP / nistspecialpublication800-38a.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R. Davis, \"Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography\", NIST Special Publication 800-56A, Revision 3, DOI 10.6028/NIST.SP.800-56Ar3, April 2018, <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/ NIST.SP.800-56Ar3.pdf>.",
      "ja": "[SP800-56A] Barker、E.、Chen、L.、Roginsky、A.、Vassilev、A。、およびR. Davis、「離散対数暗号を使用したペアワイズキー確立スキームの推奨事項」、NIST Special Publication 800 -56A、リビジョン3、DOI 10.6028 / NIST.SP.800-56Ar3、2018年4月、<https://nvlpubs.nist.gov/nistpubs/SpecialPublications/ NIST.SP.800-56Ar3.pdf>"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Exchange",
      "ja": "付録A.サンプル交換"
    },
    {
      "indent": 3,
      "text": "username: fred password: barney",
      "ja": "ユーザー名：fredパスワード：barney"
    },
    {
      "indent": 3,
      "text": "---- prior to running TLS-PWD ----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "server generates salt:",
      "ja": "サーバーはソルトを生成します："
    },
    {
      "indent": 3,
      "text": "96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3",
      "ja": "96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3"
    },
    {
      "indent": 3,
      "text": "and a base:",
      "ja": "およびベース："
    },
    {
      "indent": 3,
      "text": "6e 7c 79 82 1b 9f 8e 80 21 e9 e7 e8 26 e9 ed 28 c4 a1 8a ef c8 75 0c 72 6f 74 c7 09 61 d7 00 75",
      "ja": "6e 7c 79 82 1b 9f 8e 80 21 e9 e7 e8 26 e9 ed 28 c4 a1 8a ef c8 75 0c 72 6f 74 c7 09 61 d7 00 75"
    },
    {
      "indent": 3,
      "text": "---- state derived during the TLS-PWD exchange ----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "client and server agree to use brainpoolP256r1",
      "ja": "クライアントとサーバーはBrainpoolP256r1の使用に同意します"
    },
    {
      "indent": 3,
      "text": "client and server generate the PE:",
      "ja": "クライアントとサーバーはPEを生成します。"
    },
    {
      "indent": 3,
      "text": "PE.x: 29 b2 38 55 81 9f 9c 3f c3 71 ba e2 84 f0 93 a3 a4 fd 34 72 d4 bd 2e 9d f7 15 2d 22 ab 37 aa e6",
      "ja": "PE.x：29 b2 38 55 81 9f 9c 3f c3 71 ba e2 84 f0 93 a3 a4 fd 34 72 d4 bd 2e 9d f7 15 2d 22 ab 37 aa e6"
    },
    {
      "indent": 3,
      "text": "server private and mask:",
      "ja": "サーバープライベートとマスク："
    },
    {
      "indent": 3,
      "text": "private: 21 d9 9d 34 1c 97 97 b3 ae 72 df d2 89 97 1f 1b 74 ce 9d e6 8a d4 b9 ab f5 48 88 d8 f6 c5 04 3c mask: 0d 96 ab 62 4d 08 2c 71 25 5b e3 64 8d cd 30 3f 6a b0 ca 61 a9 50 34 a5 53 e3 30 8d 1d 37 44 e5",
      "ja": "private：21 d9 9d 34 1c 97 97 b3 ae 72 df d2 89 97 1f 1b 74 ce 9d e6 8a d4 b9 ab f5 48 88 d8 f6 c5 04 3c mask：0d 96 ab 62 4d 08 2c 71 25 5b e3 64 8d cd 30 3f 6a b0 ca 61 a9 50 34 a5 53 e3 30 8d 1d 37 44 e5"
    },
    {
      "indent": 3,
      "text": "client private and mask:",
      "ja": "クライアントプライベートとマスク："
    },
    {
      "indent": 3,
      "text": "private: 17 1d e8 ca a5 35 2d 36 ee 96 a3 99 79 b5 b7 2f a1 89 ae 7a 6a 09 c7 7f 7b 43 8a f1 6d f4 a8 8b mask: 4f 74 5b df c2 95 d3 b3 84 29 f7 eb 30 25 a4 88 83 72 8b 07 d8 86 05 c0 ee 20 23 16 a0 72 d1 bd both parties generate premaster secret and master secret",
      "ja": "private：17 1d e8 ca a5 35 2d 36 ee 96 a3 99 79 b5 b7 2f a1 89 ae 7a 6a 09 c7 7f 7b 43 8a f1 6d f4 a8 8b mask：4f 74 5b df c2 95 d3 b3 84 29 f7 eb 30 25 a4 88 83 72 8b 07 d8 86 05 c0 ee 20 23 16 a0 72 d1 bd両当事者がプリマスターシークレットとマスターシークレットを生成"
    },
    {
      "indent": 3,
      "text": "premaster secret: 01 f7 a7 bd 37 9d 71 61 79 eb 80 c5 49 83 45 11 af 58 cb b6 dc 87 e0 18 1c 83 e7 01 e9 26 92 a4 master secret: 65 ce 15 50 ee ff 3d aa 2b f4 78 cb 84 29 88 a1 60 26 a4 be f2 2b 3f ab 23 96 e9 8a 7e 05 a1 0f 3d 8c ac 51 4d da 42 8d 94 be a9 23 89 18 4c ad",
      "ja": "プリマスターシークレット：01 f7 a7 bd 37 9d 71 61 79 eb 80 c5 49 83 45 11 af 58 cb b6 dc 87 e0 18 1c 83 e7 01 e9 26 92 a4マスターシークレット：65 ce 15 50 ee ff 3d aa 2b f4 78 cb 84 29 88 a1 60 26 a4 be f2 2b 3f ab 23 96 e9 8a 7e 05 a1 0f 3d 8c ac 51 4d da 42 8d 94 be a9 23 89 18 4c ad"
    },
    {
      "indent": 3,
      "text": "---- ssldump output of exchange ----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "New TCP connection #1: Charlene Client <-> Sammy Server 1 1 0.0018 (0.0018) C>SV3.3(173) Handshake ClientHello Version 3.3 random[32]= 52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d ciphersuites TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV TLS_ECCPWD_WITH_AES_256_GCM_SHA384_PRIV Unknown value 0xff compression methods NULL extensions TLS-PWD unprotected name[5]= 04 66 72 65 64 elliptic curve point format[4]= 03 00 01 02 elliptic curve list[58]= 00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00 06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f 00 10 00 11 Packet data[178]= 16 03 03 00 ad 01 00 00 a9 03 03 52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d 00 00 06 ff b3 ff b4 00 ff 01 00 00 7a b8 aa 00 05 04 66 72 65 64 00 0b 00 04 03 00 01 02 00 0a 00 3a 00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00 06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f 00 10 00 11 00 0d 00 22 00 20 06 01 06 02 06 03 05 01 05 02 05 03 04 01 04 02 04 03 03 01 03 02 03 03 02 01 02 02 02 03 01 01 00 0f 00 01 01",
      "ja": "新しいTCP接続＃1：Charlene Client <-> Sammy Server 1 1 0.0018（0.0018）C> SV3.3（173）Handshake ClientHelloバージョン3.3 random [32] = 52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d暗号スイートTLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV TLS_ECCPWD_WITH_AES_256_GCM_SHA384_PRIV] 03 00 01 02楕円曲線リスト[58] = 00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00 06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f 00 10 00 11パケットデータ[178] = 16 03 03 00 ad 01 00 00 a9 03 03 52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d 00 00 06 ff b3 ff b4 00 ff 01 00 00 7a b8 aa 00 05 04 66 72 65 64 00 0b 00 04 03 00 01 02 00 0a 00 3a 00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00 09 00 0a 00 1a 00 16 00 17 0 0 08 00 06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f 00 10 00 11 00 0d 00 22 00 20 06 01 06 02 06 03 05 01 05 02 05 03 04 01 04 02 04 03 03 01 03 02 03 03 02 01 02 02 02 03 01 01 00 0f 00 01 01"
    },
    {
      "indent": 3,
      "text": "1 2 0.0043 (0.0024) S>CV3.3(94) Handshake ServerHello Version 3.3 random[32]= 52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3 ce eb 3c fc d8 5c bf cd d5 8e aa session_id[32]= ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6 00 6d 18 0e 09 f0 73 d5 21 20 cf 9f bf 62 88 cipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV compressionMethod NULL extensions renegotiate[1]= 00 elliptic curve point format[4]= 03 00 01 02 heartbeat[1]= 01 Packet data[99]= 16 03 03 00 5e 02 00 00 5a 03 03 52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3 ce eb 3c fc d8 5c bf cd d5 8e aa 20 ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6 00 6d 18 0e 09 f0 73 d5 21 20 cf 9f bf 62 88 ff b3 00 00 12 ff 01 00 01 00 00 0b 00 04 03 00 01 02 00 0f 00 01 01",
      "ja": "1 2 0.0043（0.0024）S> CV3.3（94）Handshake ServerHelloバージョン3.3 random [32] = 52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3 ce eb 3c fc d8 5c bf cd d5 8e aa session_id [32] = ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6 00 6d 18 0e 09 f0 73 d5 21 20 cf 9f bf 62 88 cipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV compression方法 ] = 00楕円曲線ポイント形式[4] = 03 00 01 02 heartbeat [1] = 01パケットデータ[99] = 16 03 03 00 5e 02 00 00 5a 03 03 52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3 ce eb 3c fc d8 5c bf cd d5 8e aa 20 ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6 00 6d 18 0e 09 f0 73 d5 21 20 cf 9f bf 62 88 ff b3 00 00 12 ff 01 00 01 00 00 0b 00 04 03 00 01 02 00 0f 00 01 01"
    },
    {
      "indent": 3,
      "text": "1 3 0.0043 (0.0000) S>CV3.3(141) Handshake ServerKeyExchange params salt[32]= 96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3 EC parameters = 3 curve id = 26 element[65]= 04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee f3 7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43 be 34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1 scalar[32]= 2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21 Packet data[146]= 16 03 03 00 8d 0c 00 00 89 00 20 96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3 03 00 1a 41 04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee f3 7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43 be 34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1 00 20 2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21",
      "ja": "1 3 0.0043（0.0000）S> CV3.3（141）Handshake ServerKeyExchange params salt [32] = 96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3 ECパラメーター= 3曲線id = 26 element [65] = 04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee f3 7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43 be 34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1 scalar [32] = 2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21パケットデータ[146] = 16 03 03 00 8d 0c 00 00 89 00 20 96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44 99 29 84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3 03 00 1a 41 04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee f3 7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d 43 be 34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1 00 20 2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a df 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21"
    },
    {
      "indent": 3,
      "text": "1 4 0.0043 (0.0000) S>CV3.3(4) Handshake ServerHelloDone Packet data[9]= 16 03 03 00 04 0e 00 00 00",
      "ja": "1 4 0.0043（0.0000）S> CV3.3（4）Handshake ServerHelloDone Packet data [9] = 16 03 03 00 04 0e 00 00 00"
    },
    {
      "indent": 3,
      "text": "1 5 0.0086 (0.0043) C>SV3.3(104) Handshake ClientKeyExchange element[65]= 04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e 64 d3 c1 08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd a0 scalar[32]= 66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24 fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48 Packet data[109]= 16 03 03 00 68 10 00 00 64 41 04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e 64 d3 c1 08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd a0 00 20 66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24 fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48",
      "ja": "1 5 0.0086（0.0043）C> SV3.3（104）Handshake ClientKeyExchange element [65] = 04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e 64 d3 c1 08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd a0スカラー[32] = 66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24 fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48パケットデータ[109] = 16 03 03 00 68 10 00 00 64 41 04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e 64 d3 c1 08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd a0 00 20 66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24 fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48"
    },
    {
      "indent": 3,
      "text": "1 6 0.0086 (0.0000) C>SV3.3(1) ChangeCipherSpec Packet data[6]= 14 03 03 00 01 01",
      "ja": "1 6 0.0086（0.0000）C> SV3.3（1）ChangeCipherSpecパケットデータ[6] = 14 03 03 00 01 01"
    },
    {
      "indent": 3,
      "text": "1 7 0.0086 (0.0000) C>SV3.3(40) Handshake Packet data[45]= 16 03 03 00 28 44 cd 3f 26 ed 64 9a 1b bb 07 c7 0c 6d 3e 28 af e6 32 b1 17 29 49 a1 14 8e cb 7a 0b 4b 70 f5 1f 39 c2 9c 7b 6c cc 57 20",
      "ja": "1 7 0.0086（0.0000）C> SV3.3（40）ハンドシェイクパケットデータ[45] = 16 03 03 00 28 44 cd 3f 26 ed 64 9a 1b bb 07 c7 0c 6d 3e 28 af e6 32 b1 17 29 49 a1 14 8e cb 7a 0b 4b 70 f5 1f 39 c2 9c 7b 6c cc 57 20"
    },
    {
      "indent": 3,
      "text": "1 8 0.0105 (0.0018) S>CV3.3(1) ChangeCipherSpec Packet data[6]= 14 03 03 00 01 01",
      "ja": "1 8 0.0105（0.0018）S> CV3.3（1）ChangeCipherSpecパケットデータ[6] = 14 03 03 00 01 01"
    },
    {
      "indent": 3,
      "text": "1 9 0.0105 (0.0000) S>CV3.3(40) Handshake Packet data[45]= 16 03 03 00 28 fd da 3c 9e 48 0a e7 99 ba 41 8c 9f fd 47 c8 41 2c fd 22 10 77 3f 0f 78 54 5e 41 a2 21 94 90 12 72 23 18 24 21 c3 60 a4",
      "ja": "1 9 0.0105（0.0000）S> CV3.3（40）ハンドシェイクパケットデータ[45] = 16 03 03 00 28 fd da 3c 9e 48 0a e7 99 ba 41 8c 9f fd 47 c8 41 2c fd 22 10 77 3f 0f 78 54 5e 41 a2 21 94 90 12 72 23 18 24 21 c3 60 a4"
    },
    {
      "indent": 3,
      "text": "1 10 0.0107 (0.0002) C>SV3.3(100) application_data Packet data....",
      "ja": "1 10 0.0107（0.0002）C> SV3.3（100）application_dataパケットデータ..."
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authenticated key exchange defined here has also been defined for use in 802.11 networks, as an Extensible Authentication Protocol (EAP) method, and as an authentication method for the Internet Key Exchange Protocol (IKE). Each of these specifications has elicited very helpful comments from a wide collection of people that have allowed the definition of the authenticated key exchange to be refined and improved.",
      "ja": "ここで定義された認証キー交換は、802.11ネットワークでの使用、拡張認証プロトコル（EAP）メソッド、およびインターネットキー交換プロトコル（IKE）の認証メソッドとしても定義されています。 これらの仕様のそれぞれは、認証されたキー交換の定義を洗練および改善することを可能にした幅広い人々から非常に役立つコメントを引き出しました。"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Scott Fluhrer for discovering the \"password as exponent\" attack that was possible in an early version of this key exchange and for his very helpful suggestions on the techniques for fixing the PE to prevent it. The author would also like to thank Hideyuki Suzuki for his insight in discovering an attack against a previous version of the underlying key exchange protocol. Special thanks to Lily Chen for helpful discussions on hashing into an elliptic curve. Rich Davis suggested the defensive checks that are part of the processing of the ServerKeyExchange and ClientKeyExchange messages, and his various comments have greatly improved the quality of this memo and the underlying key exchange on which it is based.",
      "ja": "著者は、この鍵交換の初期バージョンで可能だった「指数としてのパスワード」攻撃を発見し、それを防ぐためにPEを修正する技術に関する非常に役立つ提案をしてくれたScott Fluhrerに感謝します。 また、著者は、基礎となる鍵交換プロトコルの以前のバージョンに対する攻撃を発見した洞察について鈴木英之に感謝したいと思います。 楕円曲線へのハッシュに関する有益な議論について、リリー・チェンに感謝します。 リッチデイビスは、ServerKeyExchangeおよびClientKeyExchangeメッセージの処理の一部である防御チェックを提案し、彼のさまざまなコメントにより、このメモの品質とそれが基にしている基になるキー交換が大幅に改善されました。"
    },
    {
      "indent": 3,
      "text": "Martin Rex, Peter Gutmann, Marsh Ray, and Rene Struik discussed on the TLS mailing list the possibility of a side-channel attack against the hunting-and-pecking loop. That discussion prompted the addition of the security parameter, m, to the hunting-and-pecking loop. Scott Fluhrer suggested the blinding technique to test whether a value is a quadratic residue modulo a prime in a manner that does not leak information about the value being tested.",
      "ja": "Martin Rex、Peter Gutmann、Marsh Ray、およびRene Struikは、TLSメーリングリストで、ハンティングアンドペッキングループに対するサイドチャネル攻撃の可能性について議論しました。 その議論により、セキュリティパラメータmがハンティングアンドペッキングループに追加されました。 Scott Fluhrerは、値がテスト対象の値に関する情報を漏らさない方法で、値が素数を法とする2次剰余であるかどうかをテストする盲目的な手法を提案しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Dan Harkins (editor) HP Enterprise 3333 Scott Blvd. Santa Clara, CA 95054 United States of America",
      "ja": "ダンハーキンス（編集者）HP Enterprise 3333 Scott Blvd. カリフォルニア州サンタクララ95054アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dharkins@lounge.org",
      "ja": "メール：dharkins@lounge.org"
    }
  ]
}