{
  "title": {
    "text": "RFC 8120 - Mutual Authentication Protocol for HTTP",
    "ja": "RFC 8120 - HTTPのための相互認証プロトコル"
  },
  "number": 8120,
  "created_at": "2019-10-23 14:47:25.544995+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           Y. Oiwa\nRequest for Comments: 8120                                   H. Watanabe\nCategory: Experimental                                         H. Takagi\nISSN: 2070-1721                                               ITRI, AIST\n                                                                K. Maeda\n                                                  Individual Contributor\n                                                              T. Hayashi\n                                                                 Lepidum\n                                                                 Y. Ioku\n                                                  Individual Contributor\n                                                              April 2017",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Mutual Authentication Protocol for HTTP",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies an authentication scheme for the Hypertext Transfer Protocol (HTTP) that is referred to as either the Mutual authentication scheme or the Mutual authentication protocol. This scheme provides true mutual authentication between an HTTP client and an HTTP server using password-based authentication. Unlike the Basic and Digest authentication schemes, the Mutual authentication scheme specified in this document assures the user that the server truly knows the user's encrypted password.",
      "ja": "この文書では、相互認証方式や相互認証プロトコルのどちらかと呼ばれるハイパーテキスト転送プロトコル（HTTP）のための認証方式を指定します。この方式は、HTTPクライアントとパスワードベースの認証を使用してHTTPサーバ間の真の相互認証を提供します。基本とダイジェスト認証方式とは異なり、この文書で指定された相互認証方式は、サーバーが本当にユーザーの暗号化されたパスワードを知っているユーザーを保証します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8120.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8120で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Terminology ................................................5\n   1.2. Document Structure and Related Documents ...................6\n2. Protocol Overview ...............................................6\n   2.1. Messages ...................................................7\n   2.2. Typical Flows of the Protocol ..............................8\n   2.3. Alternative Flows .........................................10\n3. Message Syntax .................................................12\n   3.1. Non-ASCII Extended Header Parameters ......................12\n   3.2. Values ....................................................13\n        3.2.1. Tokens .............................................13\n        3.2.2. Strings ............................................14\n        3.2.3. Numbers ............................................14\n4. Messages .......................................................15\n   4.1. 401-INIT and 401-STALE ....................................16\n   4.2. req-KEX-C1 ................................................19\n   4.3. 401-KEX-S1 ................................................19\n   4.4. req-VFY-C .................................................20\n   4.5. 200-VFY-S .................................................21\n5. Authentication Realms ..........................................21\n   5.1. Resolving Ambiguities .....................................23\n6. Session Management .............................................24\n7. Host Validation Methods ........................................26\n   7.1. Applicability Notes .......................................27\n   7.2. Notes on \"tls-unique\" .....................................28\n8. Authentication Extensions ......................................28\n9. String Preparation .............................................29\n10. Decision Procedure for Clients ................................29\n   10.1. General Principles and Requirements ......................29\n   10.2. State Machine for the Client (Informative) ...............31",
      "raw": true
    },
    {
      "indent": 3,
      "text": "11. Decision Procedure for Servers ................................36\n12. Authentication Algorithms .....................................39\n   12.1. Support Functions and Notations ..........................39\n   12.2. Default Functions for Algorithms .........................41\n13. Application Channel Binding ...................................42\n14. Application for Proxy Authentication ..........................42\n15. Methods to Extend This Protocol ...............................43\n16. IANA Considerations ...........................................44\n   16.1. Addition to HTTP Authentication Schemes Registry .........44\n   16.2. Registry for Authentication Algorithms ...................44\n   16.3. Registry for Validation Methods ..........................45\n17. Security Considerations .......................................46\n   17.1. Security Properties ......................................46\n   17.2. Secrecy of Credentials ...................................46\n   17.3. Denial-of-Service Attacks on Servers .....................47\n        17.3.1. Online Active Password Attacks ....................47\n   17.4. Communicating the Status of Mutual Authentication\n         with Users ...............................................48\n   17.5. Implementation Considerations ............................48\n   17.6. Usage Considerations .....................................49\n18. References ....................................................49\n   18.1. Normative References .....................................49\n   18.2. Informative References ...................................51\nAuthors' Addresses ................................................53",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies an authentication scheme for the Hypertext Transfer Protocol (HTTP) that is referred to as either the Mutual authentication scheme or the Mutual authentication protocol. This scheme provides true mutual authentication between an HTTP client and an HTTP server using just a simple password as a credential.",
      "ja": "この文書では、相互認証方式や相互認証プロトコルのどちらかと呼ばれるハイパーテキスト転送プロトコル（HTTP）のための認証方式を指定します。この方式は、HTTPクライアントや資格などの単純なパスワードを使用してHTTPサーバ間の真の相互認証を提供します。"
    },
    {
      "indent": 3,
      "text": "Password-stealing attacks are one of the most critical threats for Web systems. Plain-text password authentication techniques (Basic authentication and Web-form-based authentication) have been widely used for a long time. When these techniques are used with plain HTTP protocols, it is trivially easy for attackers to sniff the password credentials on the wire.",
      "ja": "パスワードを盗む攻撃はWebシステムのための最も重要な脅威の一つです。プレーンテキストのパスワード認証技術（基本認証とWebフォームベースの認証）が広く長い間使用されてきました。これらの技術は、プレーンHTTPプロトコルを使用している場合、攻撃者は、ワイヤ上のパスワードの資格情報を盗聴することは自明簡単です。"
    },
    {
      "indent": 3,
      "text": "The Digest authentication scheme [RFC7616] uses SHA-256 and SHA-512/256 (formerly SHA-1 and MD5) hash algorithms to hide the raw user password from network sniffers. However, if the number of possible candidate users' passwords is not enough, newer and more powerful computers can compute possible hash values for billions of password candidates and compare these with the sniffed values to find out the correct password. This kind of attack is called an offline password dictionary attack; the search capacity of these newer computers reduces the effectiveness of users' memorable passwords, thereby threatening the effectiveness of such hash-based password protections.",
      "ja": "ダイジェスト認証方式は、[RFC7616]ネットワークスニファからの生のユーザ・パスワードを非表示にSHA-256およびSHA-256分の512（以前はSHA-1およびMD5）ハッシュアルゴリズムを使用します。可能性のある候補ユーザのパスワードの数が十分でない場合は、より新しく、より強力なコンピュータは、パスワードの候補数十億のための可能なハッシュ値を計算し、正しいパスワードを見つけるために嗅い値でこれらを比較することができます。この種の攻撃は、オフラインパスワード辞書攻撃と呼ばれています。これらの新しいコンピュータの検索能力は、それによって、このようなハッシュベースのパスワード保護の有効性を脅かし、ユーザーの記憶に残るパスワードの有効性を低減します。"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) [RFC5246] provides strong cryptographic protection against the network-based sniffing of passwords and other communication contents. If TLS is correctly used by both server operators and client users, passwords and other credentials will not be available to any outside attackers. However, there is a pitfall related to TLS deployment on Web systems: if the users are fraudulently routed to a \"wrong Website\" via some kind of social engineering attack (e.g., phishing) and tricked into performing authentication on that site, the credentials will be sent to the attacker's server and trivially leaked. Attacks such as phishing have become a serious threat. In current Web system deployments, TLS certificates will be issued to almost any users of the Internet (including malicious attackers). Although those certificates include several levels of the \"validation results\" (such as corporate names) of the issued entities, the task of \"checking\" those validation results is left to the users of Web browsers, still leaving open the possibility of such social engineering attacks.",
      "ja": "トランスポート層セキュリティ（TLS）[RFC5246]は、パスワードやその他の通信内容のネットワークベースのスニッフィングに対する強力な暗号化保護を提供します。 TLSが正しく両方のサーバーオペレータとクライアントのユーザーによって使用されている場合は、パスワードなどの資格情報は、いかなる外部の攻撃者に利用できません。しかし、Webシステム上でTLSの展開に関連する落とし穴があります：ユーザーが不正にソーシャルエンジニアリング攻撃のいくつかの種類（例えば、フィッシング）を経由して、「間違ったウェブサイト」にルーティングし、そのサイト上で認証を実行するようにだまされている場合、資格情報がします攻撃者のサーバーに送信され、自明漏洩します。フィッシングなどの攻撃は深刻な脅威となっています。現在のWebシステムの展開では、TLS証明書は、（悪意のある攻撃者を含む）は、インターネットのほぼすべてのユーザーに発行されます。それらの証明書が発行されたエンティティの（企業名など）、「検証結果」のいくつかのレベルが含まれますが、これらの検証結果を「チェック」のタスクは、まだ、このようなソーシャルエンジニアリングの可能性を開いたまま、Webブラウザのユーザーに任されています攻撃。"
    },
    {
      "indent": 3,
      "text": "Another way to avoid such threats is to avoid password-based authentication and use some kinds of pre-deployed strong secret keys (on either the client side or the server side) for authentications. Several federated authentication frameworks, as well as HTTP Origin-Bound Authentication (HOBA) [RFC7486], are proposed and deployed on real Web systems to satisfy those needs. However, a type of authentication based on \"human-memorable secrets\" (i.e., passwords) is still required in several scenarios, such as initialization, key deployment to new clients, or recovery of secret accounts with lost cryptographic keys.",
      "ja": "このような脅威を回避するための別の方法は、パスワードベースの認証を回避し、認証のために（クライアント側またはサーバ側のいずれかに）事前に配備強力な秘密キーの一部の種類を使用することです。いくつかのフェデレーション認証フレームワーク、ならびにHTTP原点結合した認証（HOBA）[RFC7486]は、提案され、それらのニーズを満たすために実際のWebシステムにデプロイされています。しかし、「人間の記憶に残るの秘密」（すなわち、パスワード）に基づく認証の種類は、まだ、このような初期化、新規顧客への鍵展開、または失われた暗号鍵と秘密口座の回復などいくつかのシナリオで必要とされます。"
    },
    {
      "indent": 3,
      "text": "The Mutual authentication protocol, as proposed in this document, is a strong cryptographic solution for password authentications. It mainly provides the following two key features:",
      "ja": "相互認証プロトコルは、この文書で提案されているように、パスワード認証のための強力な暗号ソリューションです。これは、主に次の二つの主要な機能を提供しています。"
    },
    {
      "indent": 3,
      "text": "o No password information at all is exchanged in the communications. When the server and the user fail to authenticate with each other, the protocol will not reveal even the tiniest bit of information about the user's password. This prevents any kind of offline password dictionary attacks, even with the existence of phishing attacks.",
      "ja": "O全くパスワード情報は、通信で交換されていません。サーバーとユーザーが相互に認証に失敗した場合、プロトコルは、さらに、ユーザのパスワードに関する情報の最も小さいビットを明らかにしません。これはさえフィッシング攻撃の存在で、オフラインパスワードの辞書攻撃のあらゆる種類のを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "o To successfully authenticate, the server, as well as client users, must own the valid registered credentials (authentication secret). This means that a phishing attacker cannot trick users into thinking that it is an \"authentic\" server. (It should be pointed out that this is not true for Basic and Digest authentication; for example, servers using Basic authentication can answer \"YES\" to any clients without actually checking authentication at all.) Client users can ascertain whether or not the communicating peer is truly \"the server\" that registered their account beforehand. In other words, it provides \"true\" mutual authentication between servers and clients.",
      "ja": "正常に認証するには、O、サーバーだけでなく、クライアントのユーザーは、有効な登録証明（認証秘密）を所有している必要があります。これはフィッシング攻撃者は、それが「本物」サーバであることを考えることにユーザーをだましていないことを意味します。 （基本とダイジェスト認証のための真実ではないことを指摘しなければならない。例えば、基本認証を使用するサーバーは、実際にすべての認証をチェックせずに任意のクライアントに「YES」と答えることができます。）クライアントのユーザーは、通信相手がいるか否かを確認することができます事前に自分のアカウントを登録し、真に「サーバー」です。換言すれば、サーバーとクライアント間の「真」の相互認証を提供します。"
    },
    {
      "indent": 3,
      "text": "Given the information above, the proposed protocol can serve as a strong alternative to the Basic, Digest, and Web-form-based authentication schemes and also as a strong companion to the non-password-based authentication frameworks.",
      "ja": "上記の情報を考えると、提案されたプロトコルは、非パスワードベースの認証フレームワークに強いコンパニオンとしても基本、ダイジェスト、およびWebフォームベースの認証スキームへの強い代替として機能することができます。"
    },
    {
      "indent": 3,
      "text": "The proposed protocol will serve in the same way as does existing Basic or Digest authentication: it meets the requirements for new authentication schemes for HTTP, as described in Section 5.1.2 of [RFC7235]. Additionally, to communicate authentication results more reliably between the server and the client user, it suggests that Web browsers have some \"secure\" way of displaying the authentication results. Having such a user interface in future browsers will greatly reduce the risk of impersonation by various kinds of social engineering attacks, in a manner similar to that of the \"green padlock\" for Extended Validation TLS certificates.",
      "ja": "Basicまたはダイジェスト認証を既存の場合と同様に提案されたプロトコルは同じように機能します：[RFC7235]のセクション5.1.2で説明したように、それは、HTTPのための新しい認証方式のための要件を満たしています。また、より確実にサーバとクライアントのユーザとの間の認証結果を伝達するために、それは、Webブラウザは、認証結果を表示するいくつかの「安全な」方法を持っていることを示唆しています。将来のブラウザで、このようなユーザーインターフェースを持つことは非常に拡張検証TLS証明書の「緑の南京錠」と同様に、ソーシャルエンジニアリング攻撃の様々な種類によって、なりすましのリスクを軽減します。"
    },
    {
      "indent": 3,
      "text": "Technically, the authentication scheme proposed in this document is a general framework for using password-based authenticated key exchange (PAKE) and similar stronger cryptographic primitives with HTTP. The two key features shown above correspond to the nature of PAKE.",
      "ja": "技術的に、この文書で提案されている認証方式は、パスワードベースの認証鍵交換（PAKE）とHTTPと同様の強力な暗号プリミティブを使用するための一般的なフレームワークです。上に示した二つの重要な特徴は、PAKEの性質に対応しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "This document distinguishes the terms \"client\" and \"user\" in the following way: a \"client\" is an entity that understands and implements HTTP and the specified authentication protocol -- usually computer software; a \"user\" is typically a human being who wants to access data resources using a \"client\".",
      "ja": "このドキュメントは、次のように用語「クライアント」と「ユーザー」に区別：「クライアント」はHTTPと指定された認証プロトコルを理解し、実装したエンティティである - 通常はコンピュータソフトウェアを、 「ユーザー」は、典型的には、「クライアント」を使用してデータリソースにアクセスすることを望んでいる人間です。"
    },
    {
      "indent": 3,
      "text": "The term \"natural numbers\" refers to the non-negative integers (including zero) throughout this document.",
      "ja": "用語「自然数」とは、本明細書を通して（ゼロを含む）非負整数を指します。"
    },
    {
      "indent": 3,
      "text": "This document treats both the input (domain) and the output (codomain) of hash functions as octet strings. When a natural number output for a hash function is required, it will be written as INT(H(s)).",
      "ja": "この文書では、オクテット文字列として入力（ドメイン）及びハッシュ関数の出力（終域）の両方を扱います。ハッシュ関数の自然数出力が必要な場合、それは、INT（H（S））のように記述されるであろう。"
    },
    {
      "indent": 0,
      "text": "1.2. Document Structure and Related Documents",
      "section_title": true,
      "ja": "1.2。文書構造と関連文書"
    },
    {
      "indent": 3,
      "text": "The entire document is organized as follows:",
      "ja": "次のように文書全体が構成されています。"
    },
    {
      "indent": 3,
      "text": "o Section 2 presents an overview of the protocol design.",
      "ja": "O部2は、プロトコル設計の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "o Sections 3 through 11 define a general framework of the Mutual authentication protocol. This framework is independent of specific cryptographic primitives.",
      "ja": "Oセクション3〜11は、相互認証プロトコルの一般的な枠組みを規定します。このフレームワークは、特定の暗号プリミティブとは無関係です。"
    },
    {
      "indent": 3,
      "text": "o Section 12 describes properties needed for cryptographic algorithms used with this protocol framework and defines a few functions that will be shared among such cryptographic algorithms.",
      "ja": "O部12は、このプロトコルのフレームワークで使用される暗号化アルゴリズムのために必要な特性を説明し、そのような暗号アルゴリズムの間で共有されるいくつかの関数を定義します。"
    },
    {
      "indent": 3,
      "text": "o Sections 13 through 15 contain general normative and informative information about the protocol.",
      "ja": "Oセクション15を介して、図13は、プロトコルに関する一般的な規範的で有益な情報を含みます。"
    },
    {
      "indent": 3,
      "text": "o Sections 16 and 17 describe IANA considerations and security considerations, respectively.",
      "ja": "Oセクション16および17は、それぞれ、IANAの考慮事項とセキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 3,
      "text": "In addition, we will refer to the following two companion documents, as they are related to this specification:",
      "ja": "彼らはこの仕様に関連しているよう加えて、我々は、以下の二つのコンパニオンのドキュメントを参照します。"
    },
    {
      "indent": 3,
      "text": "o [RFC8121] defines cryptographic primitives that can be used with this protocol framework.",
      "ja": "O [RFC8121]は、このプロトコルのフレームワークで使用することができる暗号プリミティブを定義します。"
    },
    {
      "indent": 3,
      "text": "o [RFC8053] defines small but useful extensions to the current HTTP authentication framework so that it can support application-level semantics of existing Web systems.",
      "ja": "それは既存のWebシステムのアプリケーション・レベルのセマンティクスをサポートすることができるように、O [RFC8053]は、現在のHTTP認証フレームワークに小さいが有用な拡張を定義します。"
    },
    {
      "indent": 0,
      "text": "2. Protocol Overview",
      "section_title": true,
      "ja": "2.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The protocol, as a whole, is designed as a natural extension to HTTP [RFC7230] and uses the framework defined in [RFC7235]. Internally, the server and the client will first perform a cryptographic key exchange, using the secret password as a \"tweak\" to the exchange. The key exchange will only succeed when the secrets used by both peers are correctly related (i.e., generated from the same password). Then, both peers will verify the authentication results by confirming the sharing of the exchanged key. This section provides a brief outline of the protocol and the exchanged messages.",
      "ja": "プロトコルは、全体として、HTTPに自然に拡張[RFC7230]として設計され、[RFC7235]で定義されたフレームワークを使用します。内部的には、サーバとクライアントは、最初に交換する「微調整」として秘密のパスワードを使用して、暗号鍵交換を実行します。両方のピアで使用される秘密は正しく関連しているとき、鍵交換にのみ成功します（つまり、同じパスワードから生成されました）。その後、両方のピアは交換した鍵の共有を確認することで、認証結果を検証します。このセクションでは、プロトコルと交換されたメッセージの簡単な概要を提供します。"
    },
    {
      "indent": 0,
      "text": "2.1. Messages",
      "section_title": true,
      "ja": "2.1。メッセージ"
    },
    {
      "indent": 3,
      "text": "The authentication protocol uses six kinds of messages to perform mutual authentication. These messages have specific names within this specification.",
      "ja": "認証プロトコルは、相互認証を実行するために、メッセージの6種類を使用しています。これらのメッセージは、この仕様書内の特定の名前を持ちます。"
    },
    {
      "indent": 3,
      "text": "o Authentication request messages: used by the servers to request that clients start mutual authentication.",
      "ja": "O認証要求メッセージ：クライアントが相互認証を開始することを要求するためにサーバによって使用されます。"
    },
    {
      "indent": 6,
      "text": "* 401-INIT message: a general message to start the authentication protocol. It is also used as a message indicating an authentication failure.",
      "ja": "* 401-INITメッセージ：認証プロトコルを開始するための一般的なメッセージ。また、認証失敗を示すメッセージとして使用されます。"
    },
    {
      "indent": 6,
      "text": "* 401-STALE message: a message indicating that the client has to start a new key exchange.",
      "ja": "* 401-STALEメッセージ：クライアントは新しい鍵交換を開始したことを示すメッセージ。"
    },
    {
      "indent": 3,
      "text": "o Authenticated key exchange messages: used by both peers to perform authentication and the sharing of a cryptographic secret.",
      "ja": "O鍵交換メッセージを認証：認証と暗号秘密の共有を行うために、両方のピアで使用。"
    },
    {
      "indent": 6,
      "text": "* req-KEX-C1 message: a message sent from the client.",
      "ja": "* REQ-KEX-C1のメッセージ：クライアントから送信されたメッセージ。"
    },
    {
      "indent": 6,
      "text": "* 401-KEX-S1 message: an intermediate response to a req-KEX-C1 message from the server.",
      "ja": "* 401-KEX-S1メッセージ：サーバーからREQ-KEX-C1メッセージの中間応答。"
    },
    {
      "indent": 3,
      "text": "o Authentication verification messages: used by both peers to verify the authentication results.",
      "ja": "O認証検証メッセージ：認証結果を検証するために、両方のピアで使用。"
    },
    {
      "indent": 6,
      "text": "* req-VFY-C message: a message used by the client to request that the server authenticate and authorize the client.",
      "ja": "* REQ-VFY-Cメッセージ：そのサーバーの認証を要求し、クライアントを認証するためにクライアントによって使用されるメッセージ。"
    },
    {
      "indent": 6,
      "text": "* 200-VFY-S message: a response used by the server to indicate that client authentication succeeded. It also contains information necessary for the client to check the authenticity of the server.",
      "ja": "* 200-VFY-Sメッセージ：クライアント認証が成功したことを示すために、サーバによって使用される応答。クライアントがサーバの正当性をチェックすることも必要な情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "In addition to the above six kinds of messages, a request or response without any HTTP headers related to this specification will be hereafter called a \"normal request\" or \"normal response\", respectively.",
      "ja": "メッセージの上記6種類に加えて、本明細書に関連するHTTPヘッダーなしの要求または応答を、以下、それぞれ、「正常要求」又は「正常な応答」と呼ぶことにします。"
    },
    {
      "indent": 0,
      "text": "2.2. Typical Flows of the Protocol",
      "section_title": true,
      "ja": "2.2。議定書の一般的な流れ"
    },
    {
      "indent": 3,
      "text": "In typical cases, client access to a resource protected by the Mutual authentication scheme will use the following protocol sequence:",
      "ja": "典型的な例では、相互認証方式で保護されたリソースへのクライアントアクセスは、以下のプロトコルシーケンスを使用します。"
    },
    {
      "indent": 3,
      "text": "       Client                                 Server\n         |                                      |\n         |  ---- (1) normal request --------->  |\n     GET / HTTP/1.1                             |\n         |                                      |\n         |  <---------------- (2) 401-INIT ---  |\n         |            401 Unauthorized          |\n         |            WWW-Authenticate: Mutual realm=\"a realm\"\n         |                                      |\n[user,   |                                      |\n pass]-->|                                      |\n         |  ---- (3) req-KEX-C1 ------------->  |\n     GET / HTTP/1.1                             |\n     Authorization: Mutual user=\"john\",         |--> [user DB]\n                    kc1=\"...\", ...              |<-- [user info]\n         |                                      |\n         |  <-------------- (4) 401-KEX-S1 ---  |\n         |           401 Unauthorized           |\n         |           WWW-Authenticate: Mutual sid=..., ks1=\"...\", ...\n         |                                      |\n     [compute] (5) compute session secret   [compute]\n         |                                      |\n         |                                      |\n         |  ---- (6) req-VFY-C -------------->  |\n     GET / HTTP/1.1                             |--> [verify (6)]\n     Authorization: Mutual sid=...,             |<-- OK\n                    vkc=\"...\", ...              |\n         |                                      |\n         |  <--------------- (7) 200-VFY-S ---  |\n[verify  |           200 OK                     |\n  (7)]<--|           Authentication-Info: Mutual vks=\"...\"\n         |                                      |\n         v                                      v",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: Typical Communication Flow for First Access to Resource",
      "ja": "図1：リソースへの最初のアクセスのための代表的な通信フロー"
    },
    {
      "indent": 3,
      "text": "o As is typical in general HTTP protocol designs, a client will at first request a resource without any authentication attempt (1). If the requested resource is protected by the Mutual authentication protocol, the server will respond with a message requesting authentication (401-INIT) (2).",
      "ja": "一般的なHTTPプロトコルの設計において典型的であるように、クライアントは、任意の認証の試み（1）なしの最初の要求リソースであろうO。要求されたリソースは、相互認証プロトコルによって保護されている場合、サーバは、メッセージ認証要求（401-INIT）（2）で応答します。"
    },
    {
      "indent": 3,
      "text": "o The client processes the body of the message and waits for the user to input the username and password. If the username and password are available, the client will send a message with the authenticated key exchange (req-KEX-C1) to start the authentication (3).",
      "ja": "Oクライアントは、メッセージの本文を処理し、入力するユーザー名とパスワードを待ちます。ユーザー名とパスワードが利用可能な場合、クライアントが認証を開始するために、認証鍵交換（REQ-KEX-C1）でメッセージを送信します（3）。"
    },
    {
      "indent": 3,
      "text": "o If the server has received a req-KEX-C1 message, the server looks up the user's authentication information within its user database. Then, the server creates a new session identifier (sid) that will be used to identify sets of the messages that follow it and responds with a message containing a server-side authenticated key exchange value (401-KEX-S1) (4).",
      "ja": "サーバはREQ-KEX-C1メッセージを受信した場合には、O、サーバは、そのユーザデータベース内のユーザの認証情報を検索します。次いで、サーバはそれに従うメッセージのセットを識別するために使用され、サーバー側の認証鍵交換値（401-KEX-S1）を含むメッセージで応答する新たなセッション識別子（SID）を作成する（4）。"
    },
    {
      "indent": 3,
      "text": "o At this point (5), both peers calculate a shared \"session secret\" using the exchanged values in the key exchange messages. Only when both the server and the client have used secret credentials generated from the same password will the session secret values match. This session secret will be used for access authentication of every individual request/response pair after this point.",
      "ja": "この時点で、O（5）、両方のピアは、鍵交換メッセージで交換した値を使用して共有「セッションの秘密」を計算します。サーバーとクライアントの両方が同じパスワードから生成された秘密の資格情報を使用している場合にのみ、セッション秘密の値が一致します。このセッションの秘密は、これ以降のすべての個々の要求/応答のペアのアクセス認証に使用されます。"
    },
    {
      "indent": 3,
      "text": "o The client will send a request with a client-side authentication verification value (req-VFY-C) (6), calculated from the client-generated session secret. The server will check the validity of the verification value using its own version of the session secret.",
      "ja": "Oクライアントは、クライアント側認証検証値（REQ-VFY-C）（6）、クライアントが生成したセッション秘密から計算で要求を送信します。サーバーは、セッション秘密の独自のバージョンを使用して検証値の妥当性をチェックします。"
    },
    {
      "indent": 3,
      "text": "o If the authentication verification value from the client was correct, then the client definitely owns the credential based on the expected password (i.e., the client authentication succeeded). The server will respond with a successful message (200-VFY-S) (7). Unlike the usual one-way authentication (e.g., HTTP Basic authentication or POP APOP authentication [RFC1939]), this message also contains a server-side authentication verification value.",
      "ja": "クライアントからの認証検証値が正しかった場合は、O、その後、クライアントは間違いなく期待されるパスワードに基づいて資格を所有している（つまり、クライアント認証が成功しました）。サーバは成功のメッセージ（200-VFY-S）（7）で応答します。通常一方向認証（例えば、HTTP基本認証またはAPOP認証[RFC1939]をPOP）とは異なり、このメッセージは、サーバー側の認証検証値を含みます。"
    },
    {
      "indent": 6,
      "text": "When the client's verification value is incorrect (e.g., because the user-supplied password was incorrect), the server will respond with a 401-INIT message (the same message as the message used in (2)) instead.",
      "ja": "（ユーザーが入力したパスワードが間違っていたので、例えば）クライアントの検証値が正しくない場合、サーバは代わりに401-INITメッセージ（（2）で使用したメッセージと同じメッセージ）で応答します。"
    },
    {
      "indent": 3,
      "text": "o The client MUST first check the validity of the server-side authentication verification value contained in the message (7). If the value was equal to the expected value, server authentication succeeded.",
      "ja": "Oクライアントは、最初のメッセージ（7）に含まれるサーバ側認証検証値の妥当性をチェックしなければなりません。値が期待値に等しかった場合は、サーバー認証が成功しました。"
    },
    {
      "indent": 6,
      "text": "If it is not the expected value or the message does not contain the authentication verification value, then the mutual authentication has been broken for some unexpected reason. The client MUST NOT process any body or header values contained in the HTTP response in this case. (Note: This case should not happen between a correctly implemented server and client without any active attacks; such a scenario could be caused by either a man-in-the-middle attack or incorrect implementation.)",
      "ja": "それは期待値ではありませんか、メッセージが認証検証値が含まれていない場合は、相互認証が何らかの予期しない理由で破損しています。クライアントは、この場合のHTTPレスポンスに含まれる任意の身体またはヘッダ値を処理してはいけません。 （注：この場合は、任意のアクティブな攻撃せずに正しく実装され、サーバとクライアントの間で起こるべきではありません。このようなシナリオは、man-in-the-middle攻撃や不正な実装のいずれかによって発生する可能性があります。）"
    },
    {
      "indent": 0,
      "text": "2.3. Alternative Flows",
      "section_title": true,
      "ja": "2.3。代替フロー"
    },
    {
      "indent": 3,
      "text": "As shown above, the typical flow for a first authentication request requires three request-response pairs. To reduce protocol overhead, the protocol enables several shortcut flows that require fewer messages.",
      "ja": "上記のように、最初の認証要求のための典型的な流れは、三要求 - 応答ペアを必要とします。プロトコルのオーバーヘッドを削減するために、プロトコルは、より少ないメッセージを必要とするいくつかのショートカットの流れを可能にします。"
    },
    {
      "indent": 3,
      "text": "o Case A: If the client knows that the resource is likely to require authentication, the client MAY omit the first unauthenticated request (1) and immediately send a key exchange (req-KEX-C1) message. This will reduce the number of round trips by one.",
      "ja": "oケースA：クライアントはリソースが認証を必要とする可能性があることを知っている場合は、クライアントが最初に認証されていない要求（1）を省略し、すぐに鍵交換（REQ-KEX-C1）メッセージを送信することができます。これは、1つのことで、ラウンドトリップの数を削減します。"
    },
    {
      "indent": 3,
      "text": "o Case B: If both the client and the server previously shared a session secret associated with a valid sid, the client MAY directly send a req-VFY-C message using the existing sid and corresponding session secret. This will further reduce the number of round trips by one.",
      "ja": "oケースB：クライアントとサーバーの両方が以前に有効なSIDに関連するセッション秘密を共有した場合、クライアントは直接既存のSIDおよび対応するセッションの秘密を使用してREQ-VFY-Cメッセージを送信することができます。これはさらに、1つでラウンドトリップの数を削減します。"
    },
    {
      "indent": 6,
      "text": "The server MAY have thrown out the corresponding session from the session table. If so, the server will respond with a 401-STALE message, indicating that a new key exchange is required. The client SHOULD try again to construct a req-KEX-C1 message in this case.",
      "ja": "サーバーは、セッションテーブルから対応するセッションを投げている可能性があります。その場合、サーバは新しいキーの交換が必要であることを示す、401-STALEメッセージで応答します。クライアントは、この場合にはREQ-KEX-C1メッセージを構築するために、再度試してみてください。"
    },
    {
      "indent": 3,
      "text": "Figure 2 depicts the shortcut flows described above. When using appropriate settings and implementations, most of the requests to resources are expected to meet both criteria; thus, only one round trip of request/response will be required.",
      "ja": "図2は、上述のショートカット・フローを示します。適切な設定と実装を使用する場合は、リソースへの要求のほとんどは、両方の基準を満たすことが期待されています。このように、要求/応答の唯一の1往復が必要になります。"
    },
    {
      "indent": 5,
      "text": "Case A: Omit first request (2 round trips)",
      "ja": "ケースA：最初のリクエストを省略します（2往復）"
    },
    {
      "indent": 8,
      "text": "Client            Server\n|                      |\n| --- req-KEX-C1 ----> |\n|                      |\n| <---- 401-KEX-S1 --- |\n|                      |\n| ---- req-VFY-C ----> |\n|                      |\n| <----- 200-VFY-S --- |\n|                      |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Case B: Reuse session secret (re-authentication)",
      "ja": "ケースB：再利用セッションの秘密（再認証）"
    },
    {
      "indent": 9,
      "text": "(B-1) key available        (B-2) key expired\n      (1 round trip)             (3 round trips)",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Client            Server   Client              Server\n|                      |   |                        |\n| ---- req-VFY-C ----> |   | --- req-VFY-C -------> |\n|                      |   |                        |\n| <----- 200-VFY-S --- |   | <------- 401-STALE --- |\n|                      |   |                        |\n                           | --- req-KEX-C1 ------> |\n                           |                        |\n                           | <------ 401-KEX-S1 --- |\n                           |                        |\n                           | --- req-VFY-C -------> |\n                           |                        |\n                           | <------- 200-VFY-S --- |\n                           |                        |",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 2: Several Alternative Protocol Flows",
      "ja": "図2：いくつかの代替プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "For more details, see Sections 10 and 11.",
      "ja": "詳細については、セクション10および11を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Message Syntax",
      "section_title": true,
      "ja": "3.メッセージの構文"
    },
    {
      "indent": 3,
      "text": "Throughout this specification, the syntax is denoted in the extended augmented BNF syntax as defined in [RFC7230] and [RFC5234]. The following elements are used in this document per [RFC5234], [RFC7230], and [RFC7235]: DIGIT, ALPHA, SP, auth-scheme, quoted-string, auth-param, header-field, token, challenge, and credentials.",
      "ja": "[RFC7230]及び[RFC5234]で定義されるように本明細書を通して、構文は拡張拡張BNF構文で示されています。 DIGIT、ALPHA、SP、AUTH-スキーム、引用符で囲まれた文字列、AUTH-PARAM、ヘッダフィールド、トークン、チャレンジ、および資格：次の要素が[RFC5234]、[RFC7230]及び[RFC7235]あたり本書で使用されています。"
    },
    {
      "indent": 3,
      "text": "The Mutual authentication protocol uses three headers: WWW-Authenticate (usually in responses with a 401 status code), Authorization (in requests), and Authentication-Info (in responses other than a 401 status code). These headers follow the frameworks described in [RFC7235] and [RFC7615]. See Section 4 for more details regarding these headers.",
      "ja": "（リクエストで）許可、（通常は401のステータスコードで応答で）WWW認証、および認証-INFO（401のステータスコード以外の応答で）：相互認証プロトコルは、三のヘッダを使用します。これらのヘッダーは、[RFC7235]及び[RFC7615]に記載のフレームワークに従います。これらのヘッダーについての詳細は、第4章を参照してください。"
    },
    {
      "indent": 3,
      "text": "The framework in [RFC7235] defines the syntax for the headers WWW-Authenticate and Authorization as the syntax elements \"challenge\" and \"credentials\", respectively. The auth-scheme element contained in those headers MUST be set to \"Mutual\" when using the protocol specified in this document. The syntax for \"challenge\" and \"credentials\" to be used with the \"Mutual\" auth-scheme SHALL be name-value pairs (#auth-param), not the \"token68\" parameter defined in [RFC7235].",
      "ja": "[RFC7235]でのフレームワークは、それぞれ、シンタックス要素「チャレンジ」および「資格情報」としてヘッダWWW認証及び認可するための構文を定義します。本書で指定されたプロトコルを使用する場合、それらのヘッダに含まAUTH-scheme要素は、「相互」に設定しなければなりません。 「チャレンジ」および「資格証明書」の構文は、名前と値のペア（＃1 AUTH-PARAM）、ない[RFC7235]で定義された「token68」パラメータでなければならない「相互」AUTH-スキームで使用します。"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header used in this protocol SHALL follow the syntax defined in [RFC7615].",
      "ja": "このプロトコルで使用される認証-Infoヘッダは、[RFC7615]で定義された構文に従います。"
    },
    {
      "indent": 3,
      "text": "In HTTP, the WWW-Authenticate header may contain two or more challenges. Client implementations SHOULD be aware of, and be capable of correctly handling, those cases.",
      "ja": "HTTPでは、WWW-Authenticateヘッダは、二つ以上の課題を含んでいてもよいです。クライアントの実装はを認識して、かつ正確に、これらのケースを扱うことができるべきです。"
    },
    {
      "indent": 0,
      "text": "3.1. Non-ASCII Extended Header Parameters",
      "section_title": true,
      "ja": "3.1。非ASCII拡張ヘッダのパラメータ"
    },
    {
      "indent": 3,
      "text": "All of the parameters contained in the above three headers, except for the \"realm\" field, MAY be extended to ISO 10646-1 values using the framework described in [RFC5987]. All servers and clients MUST be capable of receiving and sending values encoded per the syntax specified in [RFC5987].",
      "ja": "上記の3つのヘッダに含まれるパラメータの全ては、「レルム」フィールドを除いて、[RFC5987]に記載のフレームワークを使用して、ISO 10646-1値に拡張することができます。すべてのサーバーとクライアントは[RFC5987]で指定された構文ごとにエンコードされた値を受信し、送信することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a value to be sent contains only ASCII characters, the field MUST be sent using plain syntax as defined in RFC 7235. The syntax as extended by RFC 5987 MUST NOT be used in this case.",
      "ja": "送信される値は、ASCII文字のみが含まれている場合は、この場合に使用してはいけませんRFC 5987で延長としてRFC 7235.構文で定義されるように、フィールドは、プレーンな構文を使用して送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a value (except for the \"realm\" header) contains one or more non-ASCII characters, the parameter SHOULD be sent using the syntax defined in Section 3.2 of [RFC5987] as \"ext-parameter\". Such a parameter MUST have a charset value of \"UTF-8\", and the language value MUST always be omitted (have an empty value). The same parameter MUST NOT be sent more than once, regardless of the syntax used.",
      "ja": "（「レルム」ヘッダを除く）値が1以上の非ASCII文字が含まれている場合、パラメータが「EXTパラメータ」と[RFC5987]のセクション3.2で定義された構文を使用して送信されるべきです。このようなパラメータは、「UTF-8」のcharset値を持たなければならない、と言語の値は常に（空の値を持つ）省略しなければなりません。同じパラメータが使用されている構文に関係なく、複数回送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "For example, a parameter \"user\" with the value \"Renee of France\" SHOULD be sent as < user=\"Renee of France\" >. If the value is \"Ren<e acute>e of France\", it SHOULD be sent as < user*=UTF-8''Ren%C3%89e%20of%20France > instead.",
      "ja": "例えば、値「ルネ・ド・フランス」とパラメータ「ユーザ」は、<ユーザ=「ルネ・ド・フランス」>として送信されるべきです。値が \"フランスの蓮<E急性> E\" である場合、それは代わりに<ユーザー* = UTF-8''Ren％C3％89E％20of％20France>として送られるべきです。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] requires that the \"realm\" parameter be in its plain form (not as an extended \"realm*\" parameter), so the syntax specified in RFC 5987 MUST NOT be used for this parameter.",
      "ja": "[RFC7235]は、「レルム」パラメータは、その普通の形態であることを必要とするので、RFC 5987で指定された構文（拡張「レルム*」パラメータとしてではない）、このパラメータのために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "3.2. Values",
      "section_title": true,
      "ja": "3.2。値"
    },
    {
      "indent": 3,
      "text": "The parameter values contained in challenges or credentials MUST be parsed in strict conformance with HTTP semantics (especially the unquoting of string parameter values). In this protocol, those values are further categorized into the following value types: tokens (bare-token and extensive-token), string, integer, hex-fixed-number, and base64-fixed-number.",
      "ja": "課題または資格情報に含まれるパラメータ値は、HTTPセマンティクス（文字列パラメータ値の特にunquoting）に厳密に準拠して解析されなければなりません。トークン（トークン裸及び広範囲トークン）、文字列、整数、ヘキサ固定数、およびbase64で固定数：このプロトコルでは、これらの値は、さらに、以下の値のタイプに分類されます。"
    },
    {
      "indent": 3,
      "text": "For clarity, it is RECOMMENDED that implementations use the canonical representations specified in the following subsections for sending values. However, recipients MUST accept both quoted and unquoted representations interchangeably, as specified in HTTP.",
      "ja": "明確にするためには、実装が値を送信するために、以下のサブセクションで指定された正規表現を使用することをお勧めします。ただし、受信者はHTTPに指定されている、同義的に両方の引用されたと引用符で囲まれていない表現を受け入れなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Tokens",
      "section_title": true,
      "ja": "3.2.1。トークン"
    },
    {
      "indent": 3,
      "text": "For sustaining both security and extensibility at the same time, this protocol defines a stricter sub-syntax for the \"token\" to be used. Extensive-token values SHOULD use the following syntax (after the parsing of HTTP values):",
      "ja": "同時に、セキュリティと拡張性の両方を維持するために、このプロトコルを使用する「トークン」の厳格なサブ構文を定義します。豊富なトークン値は、（HTTP値の解析後の）次の構文を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "bare-token = bare-token-lead-char *bare-token-char bare-token-lead-char = %x30-39 / %x41-5A / %x61-7A bare-token-char = %x30-39 / %x41-5A / %x61-7A / \"-\" / \"_\" extension-token = \"-\" bare-token 1*(\".\" bare-token) extensive-token = bare-token / extension-token",
      "ja": "裸トークン=ベアトークン鉛チャー*ベアトークンチャーベアトークン鉛チャー=％x30-39 /％x41-5A /％x61-7Aベアトークンチャー=％x30-39 / ％x41-5A /％x61-7A /「 - 」/「_」拡張トークン=「 - 」裸トークン1 *（ベアトークン「」）広範トークン=裸トークン/拡張トークン"
    },
    {
      "indent": 19,
      "text": "Figure 3: BNF Syntax for Token Values",
      "ja": "図3：BNF構文トークンの値に対して"
    },
    {
      "indent": 3,
      "text": "The tokens (bare-token and extension-token) are case insensitive. Senders SHOULD send these in lower case, and receivers MUST accept both upper and lower cases. When tokens are used as (partial) inputs to any hash functions or other mathematical functions, they MUST always be used in lower case.",
      "ja": "トークン（ベアトークンと拡張トークン）は、大文字と小文字を区別しています。送信者は、小文字でこれらを送信する必要があり、受信機は、上下両方のケースを受け入れなければなりません。トークンは、任意のハッシュ関数または他の数学関数に（部分的な）入力として使用される場合、それらは常に小文字で使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extensive-tokens are used in this protocol where the set of acceptable tokens may include non-standard extensions. Any extension of this protocol MAY use either the bare-tokens allocated by IANA (see the procedure described in Section 16) or extension-tokens with the format \"-<bare-token>.<domain-name>\", where <domain-name> is a valid (sub)domain name on the Internet owned by the party who defines the extension.",
      "ja": "広範なトークンは、許容可能なトークンのセットは非標準の拡張を含んでいてもよい、このプロトコルで使用されています。このプロトコルの任意の拡張子は、IANAによって割り当てられた裸トークン（項16に記載の手順を参照）、またはフォーマットの拡張トークンも使用することができる「 -  <ベアトークン> <ドメイン名>」、ここで<ドメイン - 名前>は、拡張子を定義するパーティが所有し、インターネット上で有効な（サブ）ドメイン名です。"
    },
    {
      "indent": 3,
      "text": "Bare-tokens and extensive-tokens are also used for parameter names, in the unquoted form. Requirements for using the extension-token for the parameter names are the same as those described in the previous paragraph.",
      "ja": "ベアトークンと広範囲-トークンは引用符で囲まれていない形態で、パラメータ名にも使用されます。パラメータ名に拡張子トークンを使用するための要件は、前の段落で説明したものと同じです。"
    },
    {
      "indent": 3,
      "text": "The canonical format for bare-tokens and extensive-tokens is the unquoted representation.",
      "ja": "ベアトークンと広範囲-トークンの標準フォーマットは引用符で囲まれていない表現です。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Strings",
      "section_title": true,
      "ja": "3.2.2。ストリング"
    },
    {
      "indent": 3,
      "text": "All character strings MUST be encoded to octet strings using UTF-8 encoding [RFC3629] for the Unicode character set [Unicode]. Such strings MUST NOT contain any leading Byte Order Marks (BOMs) (also known as ZERO WIDTH NO-BREAK SPACE, U+FEFF, or EF BB BF). It is RECOMMENDED that both peers reject any invalid UTF-8 sequences that might cause decoding ambiguities (e.g., containing <\"> in the second or subsequent bytes of the UTF-8 encoded characters).",
      "ja": "すべての文字列はUnicode文字セット[ユニコード]のためのUTF-8エンコーディング[RFC3629]を使用してオクテット文字列に符号化されなければなりません。そのような文字列は、（またZERO WIDTH NO-BREAKスペース、U + FEFF、又はEF BBのBFとしても知られる）の任意の先頭のバイト順序マーク（部品表）を含んでいてはなりません。 （例えば、UTF-8でエンコードされた文字の目以降のバイト数< \">を含む）復号曖昧さを引き起こすかもしれない両方のピアが無効なUTF-8シーケンスを拒否することを推奨されています。"
    },
    {
      "indent": 3,
      "text": "If strings represent a domain name or URI that contains non-ASCII characters, the host parts SHOULD be encoded as they (the parts) are used in the HTTP protocol layer (e.g., in a Host: header); per current standards, the A-label as defined in [RFC5890] will be used. Lowercase ASCII characters SHOULD be used.",
      "ja": "文字列は非ASCII文字が含まれているドメイン名またはURIを表す場合、それら（の部分）がHTTPプロトコル層で使用されるように、ホスト部は、（例えば、宿主における、：ヘッダ）符号化されるべきです。現在の規格ごとに、[RFC5890]で定義されるようにA-ラベルが使用されます。小文字のASCII文字を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The canonical format for strings is quoted-string (as it may contain equals signs (\"=\"), plus signs (\"+\"), and slashes (\"/\")), unless the parameter containing the string value will use extended syntax as defined in [RFC5987]. (Per [RFC5987], an extended parameter will have an unquoted encoded value.)",
      "ja": "文字列値を含むパラメータは、拡張構文が使用されない限り、文字列の正規の形式は、（それが含まれていてもよいように記号（「=」）、プラス記号（「+」​​）、およびスラッシュ（「/」）に等しい）引用符で囲まれた文字列であります[RFC5987]で定義されます。 （PER [RFC5987]は、拡張されたパラメータは、引用符で囲まれていない符号化された値を有します。）"
    },
    {
      "indent": 0,
      "text": "3.2.3. Numbers",
      "section_title": true,
      "ja": "3.2.3。数字"
    },
    {
      "indent": 3,
      "text": "The following syntax definitions provide a syntax for numeric values:",
      "ja": "次の構文定義は、数値の構文を提供します。"
    },
    {
      "indent": 4,
      "text": "integer = \"0\" / (%x31-39 *DIGIT) ; no leading zeros hex-fixed-number = 1*(2(DIGIT / %x41-46 / %x61-66)) base64-fixed-number = 1*( ALPHA / DIGIT / \"+\" / \"/\" ) 0*2\"=\"",
      "ja": "整数= \"0\" /（％x31-39 * DIGIT）。ない先行ゼロヘキサ固定数= 1 *（2（DIGIT /％x41-46 /％x61-66））base64で固定数= 1 *（ALPHA / DIGIT / \"+\" / \"/\"）0 * 2 \"=\""
    },
    {
      "indent": 21,
      "text": "Figure 4: BNF Syntax for Numbers",
      "ja": "図4：BNF構文数値について"
    },
    {
      "indent": 3,
      "text": "The syntax definition of the integers only allows representations that do not contain leading zeros.",
      "ja": "整数の構文定義は先行ゼロを含まない表現を可能にします。"
    },
    {
      "indent": 3,
      "text": "A number represented as a hex-fixed-number MUST include an even number of hexadecimal digits (i.e., multiples of eight bits). Those values are case insensitive and SHOULD be sent in lower case. When these values are generated from any cryptographic values, they MUST have their \"natural length\"; if they are generated from a hash function, their lengths correspond to the hash size; if they represent elements of a mathematical set (or group), their lengths SHALL be the shortest lengths that represent all the elements in the set. For example, the results of the SHA-256 hash function will be represented by 64 digits, and any elements in a 2048-bit prime field (modulo a 2048-bit integer) will be represented by 512 digits, regardless of how many zeros appear in front of such representations. Session identifiers and other non-cryptographically generated values are represented in any (even) length determined by the side that generates it first, and the same length MUST be used in all communications by both peers.",
      "ja": "ヘキサ固定数として表される数は、16進数の偶数（8ビットの、すなわち、倍数）を含まなければなりません。これらの値は、大文字と小文字が区別され、小文字で送信されるべきです。これらの値は任意の暗号値から生成されたとき、彼らは「自然長」を持っている必要があります。これらはハッシュ関数から生成される場合、その長さは、ハッシュ・サイズに対応します。これらは数学的集合（またはグループ）の要素を表す場合は、それらの長さは、セット内のすべての要素を表す最短の長さでなければなりません。例えば、SHA-256ハッシュ関数の結果は、64桁で表される、2048ビットの素数フィールド（2048ビットの整数を法）における任意の要素に関係なくゼロが表示されるどのように多くの、512桁で表現されますそのような表現の正面です。セッション識別子及び他の非暗号生成された値は、最初に生成側によって決定された任意の（偶数）の長さで表され、そして同じ長さは、両方のピアがすべての通信で使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The numbers represented as base64-fixed-number SHALL be generated as follows: first, the number is converted to a big-endian radix-256 binary representation as an octet string. The length of the representation is determined in the same way as the technique mentioned above. Then, the string is encoded using base64 encoding (described in Section 4 of [RFC4648]) without any spaces and newlines. Implementations decoding base64-fixed-number SHOULD reject any input data with invalid characters, excess or insufficient padding, or non-canonical pad bits (see Sections 3.1 through 3.5 of [RFC4648]).",
      "ja": "まず、数がオクテットストリングとしてビッグエンディアン基数256のバイナリ表現に変換され、次のようにbase64で固定数として表される数値が生成されなければなりません。表現の長さは、上述した手法と同様にして決定されます。次に、文字列がスペースや改行せずに（[RFC4648]のセクション4で説明）base64エンコーディングを使用して符号化されます。 base64で固定番号を復号化の実装は、無効な文字、過剰または不十分なパディング、または非標準パッドビットを有する任意の入力データを拒否すべきである（[RFC4648]の3.5を介してセクション3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The canonical format for integer and hex-fixed-number is unquoted tokens, and the canonical format for base64-fixed-number is quoted-string.",
      "ja": "整数及びヘキサ固定数の標準フォーマットは、引用符で囲まれていないトークンであり、base64で固定数の標準フォーマットは引用文字列です。"
    },
    {
      "indent": 0,
      "text": "4. Messages",
      "section_title": true,
      "ja": "4.メッセージ"
    },
    {
      "indent": 3,
      "text": "In this section, we define the six kinds of messages in the authentication protocol, along with the formats and requirements of the headers for each type of message.",
      "ja": "このセクションでは、我々は、メッセージの種類ごとにヘッダーのフォーマットおよび要件とともに、認証プロトコルのメッセージの6種類を定義します。"
    },
    {
      "indent": 3,
      "text": "To determine under what circumstances each message is expected to be sent, see Sections 10 and 11.",
      "ja": "各メッセージが送信されると予想されるどのような状況下で決定するために、セクション10及び11を参照。"
    },
    {
      "indent": 3,
      "text": "In the descriptions below, the types of allowable values for each header parameter are shown in parentheses after each parameter name. The \"algorithm-determined\" type means that the acceptable value for the parameter is one of the types defined in Section 3 and is",
      "ja": "以下の説明では、各ヘッダパラメータの許容値の種類は、各パラメータ名の後の括弧内に示されています。 「アルゴリズム決定」タイプは、パラメータの許容値は、セクション3で定義されたタイプの一つであり、であることを意味します"
    },
    {
      "indent": 3,
      "text": "determined by the value of the \"algorithm\" parameter. The parameters marked \"mandatory\" SHALL be contained in the message. The parameters marked \"non-mandatory\" MAY be either contained in the message or omitted from it. Each parameter SHALL appear in each header exactly once at most.",
      "ja": "「アルゴリズム」パラメータの値によって決まります。 「必須」とマークされたパラメータは、メッセージに含まれるものとする（SHALL）。パラメータがマークされ、「非必須」のいずれかのメッセージに含まれる、またはそれから省略されるかもしれません。各パラメータには、最大でも正確に一度、各ヘッダーに表示されないものとします。"
    },
    {
      "indent": 3,
      "text": "All credentials and challenges MAY contain any parameters not explicitly specified in the following sections. Recipients that do not understand such parameters MUST silently ignore them. However, all credentials and challenges MUST meet the following criteria:",
      "ja": "すべての資格情報や課題を明示的に次のセクションで指定されていない任意のパラメータを含むかもしれません。このようなパラメータを理解していない受信者は静かにそれらを無視しなければなりません。しかし、すべてのクレデンシャルと課題は以下の基準を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "o For responses, the parameters \"reason\", any \"ks#\" (where \"#\" stands for any decimal integer), and \"vks\" are mutually exclusive; any challenges MUST NOT contain two or more parameters among them. They MUST NOT contain any \"kc#\" or \"vkc\" parameters.",
      "ja": "O応答については、パラメータ「理由」は、任意の「KS＃が」（ここで、「＃」は、任意の10進整数を表す）、及び「VKS」は相互に排他的です。すべての課題は、それらのうちの2以上のパラメータを含めることはできません。彼らは、任意の「KC番号」または「VKC」パラメータを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "o For requests, the parameters \"kc#\" (where \"#\" stands for any decimal integer) and \"vkc\" are mutually exclusive; any challenges MUST NOT contain two or more parameters among them. They MUST NOT contain any \"ks#\" or \"vks\" parameters.",
      "ja": "O要求の場合、パラメータは「KC＃」は、（ここで、「＃」は、任意の10進整数を表す）と「VKC」は相互に排他的です。すべての課題は、それらのうちの2以上のパラメータを含めることはできません。彼らは、任意の「KS番号」または「VKS」パラメータを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "Every message defined in this section contains a \"version\" field to detect any future revisions of the protocol that are incompatible. Implementations of the protocol described in this specification MUST always send a token \"1\" to represent the version number. Recipients MUST reject messages that contain any other value for the version, unless another specification defines specific behavior for that version.",
      "ja": "このセクションで定義されたすべてのメッセージは、互換性のないプロトコルの将来の改訂を検出するために、「バージョン」フィールドが含まれています。本明細書に記載したプロトコルの実装は常にバージョン番号を表すトークン「1」を送信しなければなりません。受信者は、別の指定がそのバージョンの特定の動作を定義しない限り、バージョンのために他の値を含むメッセージを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. 401-INIT and 401-STALE",
      "section_title": true,
      "ja": "4.1。 401-INITおよび401-STALE"
    },
    {
      "indent": 3,
      "text": "Every 401-INIT or 401-STALE message SHALL be a valid HTTP 401 (Unauthorized) status message (or some other 4xx status message, if appropriate) containing one and only one (hereafter not explicitly noted) WWW-Authenticate header containing a \"reason\" parameter in the challenge. The challenge SHALL contain all of the parameters marked \"mandatory\" below and MAY contain those marked \"non-mandatory\".",
      "ja": "すべての401-INITまたは401-STALEメッセージは、唯一つの「理由を含む（以下、明示的に述べていない）WWW-Authenticateヘッダを含む有効なHTTP 401（不正な）ステータスメッセージ（またはいくつかの他の4XXステータスメッセージ、適切な場合）でなければなりません挑戦で \"パラメータ。課題は、以下の「必須」マークと「非必須」とマークされたものを含むかもしれパラメータのすべてを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "version: (mandatory extensive-token) should be the token \"1\".",
      "ja": "バージョン：（必須広範なトークン）は、トークン「1」にする必要があります。"
    },
    {
      "indent": 3,
      "text": "algorithm: (mandatory extensive-token) specifies the authentication algorithm to be used. The value MUST be one of the tokens specified in [RFC8121] or another supplemental specification.",
      "ja": "アルゴリズム：（必須広範なトークン）が使用される認証アルゴリズムを指定します。値は[RFC8121]で指定されたトークンまたは他の補足仕様のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "validation: (mandatory extensive-token) specifies the method of host validation. The value MUST be one of the tokens described in Section 7 or the tokens specified in another supplemental specification.",
      "ja": "検証：（必須広範なトークン）は、ホストの検証方法を指定します。値はセクション7に記載のトークンまたは他の補足仕様で指定されたトークンのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "auth-scope: (non-mandatory string) specifies the authentication scope, i.e., the set of hosts for which the authentication credentials are valid. It MUST be one of the strings described in Section 5. If the value is omitted, it is assumed to be the \"single-server type\" domain as described in Section 5.",
      "ja": "AUTH-スコープ（非必須の列）認証範囲、認証証明書が有効であるためにホストの、すなわち、集合を指定します。値が省略された場合には、第5節に記載したように「単一サーバ型」ドメインであると仮定され、セクション5に記載された文字列のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "realm: (mandatory string) is a string representing the name of the authentication realm inside the authentication scope. As specified in [RFC7235], this value MUST always be sent in the quoted-string form, and an encoding as specified in [RFC5987] MUST NOT be used.",
      "ja": "レルムは：（必須の列）認証範囲内の認証領域の名前を表す文字列です。 [RFC7235]で指定されるように[RFC5987]で指定されるように、この値は常に引用符で囲まれた文字列形式、及び符号化で送信されなければならない使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "The realm value sent from the server SHOULD be an ASCII string. Clients MAY treat any non-ASCII value received in this field as a binary blob, an NFC-normalized UTF-8 string (\"NFC\" stands for \"Normalization Form C\"), or an error.",
      "ja": "サーバーから送信されたレルム値は、ASCII文字列でなければなりません。クライアントは、バイナリブロブ、NFC正規化UTF-8文字列としてこのフィールドに受信したすべての非ASCII値（「NFC」「正規化形式C」を表す）、またはエラーを扱うかもしれ。"
    },
    {
      "indent": 3,
      "text": "reason: (mandatory extensive-token) SHALL be an extensive-token that describes the possible reason for the failed authentication or authorization. Both servers and clients SHALL understand and support the following three tokens:",
      "ja": "理由：（必須広範なトークン）が失敗した認証または認可のための可能な理由を説明する広範なトークンされなければなりません。サーバーとクライアントの両方が、次の3つのトークンを理解し、サポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "* initial: Authentication was not attempted because there was no Authorization header in the corresponding request.",
      "ja": "*初期：対応する要求にはAuthorizationヘッダが存在しないため、認証が試みませんでした。"
    },
    {
      "indent": 6,
      "text": "* stale-session: The provided sid in the request was either unknown to the server or expired in the server.",
      "ja": "*古いセッション：要求で提供さsidは、サーバーに知られていないか、サーバーで期限切れのいずれかでした。"
    },
    {
      "indent": 6,
      "text": "* auth-failed: The authentication trial failed for some reason, possibly because of a bad authentication credential.",
      "ja": "*のauth-失敗：認証試験はおそらく悪い認証資格の、何らかの理由で失敗しました。"
    },
    {
      "indent": 6,
      "text": "Implementations MAY support the following tokens or any extensive-tokens defined outside of this specification. If clients receive any unknown tokens, they SHOULD treat them as if they were \"auth-failed\" or \"initial\".",
      "ja": "実装は、本明細書の外に定義された次のトークンまたは任意の広範囲トークンをサポートするかもしれません。クライアントは未知のトークンを受信した場合、彼らは「認証に失敗した」または「初期」であるかのように、彼らはそれらを扱うべきです。"
    },
    {
      "indent": 6,
      "text": "* reauth-needed: The server-side application requires a new authentication trial, regardless of the current status.",
      "ja": "* REAUTH-必要：サーバー側のアプリケーションは関係なく、現在の状態の、新しい認証の試行が必要です。"
    },
    {
      "indent": 6,
      "text": "* invalid-parameters: The server did not attempt authentication because some parameters were not acceptable.",
      "ja": "*無効なパラメータ：いくつかのパラメータが許容なかったため、サーバーが認証をしようとしませんでした。"
    },
    {
      "indent": 6,
      "text": "* internal-error: The server did not attempt authentication because there are some problems on the server side.",
      "ja": "*内部エラー：サーバー側でいくつかの問題があるため、サーバーが認証をしようとしませんでした。"
    },
    {
      "indent": 6,
      "text": "* user-unknown: This is a special case of auth-failed; it suggests that the provided username is invalid. Due to security implications, the use of this parameter is NOT RECOMMENDED, except for special-purpose applications where it would make sense to do so.",
      "ja": "*ユーザー不明：これは失敗したのauth-の特殊なケースです。それは提供されたユーザ名が無効であることを示唆しています。セキュリティへの影響のため、このパラメータの使用は、それがそうするように理にかなって特殊目的の用途を除いて、推奨されません。"
    },
    {
      "indent": 6,
      "text": "* invalid-credential: This is another special case of auth-failed; it suggests that the provided username was valid but authentication still failed. For security reasons, the use of this parameter is NOT RECOMMENDED.",
      "ja": "*無効-資格：これは失敗したのauth-の別の特殊なケースです。それは提供されたユーザ名が有効であったことを示唆しているが、認証はまだ失敗しました。セキュリティ上の理由から、このパラメータの使用は推奨されません。"
    },
    {
      "indent": 6,
      "text": "* authz-failed: Authentication was successful, but access to the specified resource is not authorized to the specific authenticated user. (It might be used along with either a 401 (Unauthorized) or 403 (Forbidden) status code to indicate that the authentication result is one of the existing reasons for the failed authorization.)",
      "ja": "*のauthz-失敗：認証が成功しましたが、指定されたリソースへのアクセスを特定の認証済みのユーザーに許可されていません。 （認証結果が失敗した許可のための既存の理由の一つであることを示すために401（不正な）または403（禁止）状態コードのいずれかと一緒に使用されてもよいです。）"
    },
    {
      "indent": 6,
      "text": "It is RECOMMENDED that the reason for failure be recorded to some type of diagnostic log, shown to the client user immediately, or both. It will be helpful to find out later whether the reason for the failure is technical or caused by user error.",
      "ja": "失敗の理由はいくつかすぐにクライアントユーザに示す診断ログの種類、またはその両方に記録することが推奨されます。失敗の理由は、技術やユーザー・エラーによって引き起こされているかどうかを後で調べるために参考になります。"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in this header will determine the types (among those defined in Section 3) and the values for K_c1, K_s1, VK_c, and VK_s.",
      "ja": "このヘッダーで指定されたアルゴリズムは、タイプ（セクション3で定義されたものの中で）とK_c1、K_s1、VK_c、及びVK_sの値を決定します。"
    },
    {
      "indent": 3,
      "text": "Among these messages, any messages with the \"reason\" parameter value \"stale-session\" will be called \"401-STALE\" messages hereafter, because these messages have a special meaning in the protocol flow. Messages with any other \"reason\" parameters will be called \"401-INIT\" messages.",
      "ja": "これらのメッセージは、プロトコルフローに特別な意味を持っているので、これらのメッセージの中で、「理由」パラメータの値を持つすべてのメッセージは、「古くなったセッションは」、以下「401-STALE」メッセージと呼ばれます。その他の「理由」パラメータを持つメッセージは、「401-INIT」のメッセージと呼ばれます。"
    },
    {
      "indent": 0,
      "text": "4.2. req-KEX-C1",
      "section_title": true,
      "ja": "4.2。 REQ-KEX-C1"
    },
    {
      "indent": 3,
      "text": "Every req-KEX-C1 message SHALL be a valid HTTP request message containing an Authorization header with a credential containing a \"kc1\" parameter.",
      "ja": "すべてREQ-KEX-C1メッセージは「KC1」パラメータを含む信任状でAuthorizationヘッダを含む有効なHTTPリクエストメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The credential SHALL contain the parameters with the following names:",
      "ja": "資格は次の名前のパラメータが含まれていなければなりません。"
    },
    {
      "indent": 3,
      "text": "version: (mandatory, extensive-token) should be the token \"1\".",
      "ja": "バージョン：（必須の、広範なトークン）はトークン「1」であるべきです。"
    },
    {
      "indent": 3,
      "text": "algorithm, validation, auth-scope, realm: MUST be the same values as those received from the server.",
      "ja": "アルゴリズム、検証、認証スコープ、レルム：サーバーから受信したものと同じ値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "user: (mandatory, string) is the UTF-8 encoded name of the user. The string SHOULD be prepared according to the method presented in Section 9.",
      "ja": "ユーザー：（必須、ストリング）は、ユーザのUTF-8でエンコードされた名前です。文字列は、セクション9に示された方法に従って調製されるべきです。"
    },
    {
      "indent": 3,
      "text": "kc1: (mandatory, algorithm-determined) is the client-side key exchange value K_c1, which is specified by the algorithm that is used.",
      "ja": "KC1：（必須、アルゴリズム決定）が使用されるアルゴリズムで指定されたクライアント側の鍵交換価値K_c1、です。"
    },
    {
      "indent": 0,
      "text": "4.3. 401-KEX-S1",
      "section_title": true,
      "ja": "4.3。 KEX-401-S1"
    },
    {
      "indent": 3,
      "text": "Every 401-KEX-S1 message SHALL be a valid HTTP 401 (Unauthorized) status response message containing a WWW-Authenticate header with a challenge containing a \"ks1\" parameter.",
      "ja": "すべての401-KEX-S1メッセージは、「KS1」パラメータを含むチャレンジとWWW-Authenticateヘッダを含む有効なHTTP 401（不正な）ステータス応答メッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The challenge SHALL contain the parameters with the following names:",
      "ja": "課題は、次の名前のパラメータが含まれていなければなりません。"
    },
    {
      "indent": 3,
      "text": "version: (mandatory, extensive-token) should be the token \"1\".",
      "ja": "バージョン：（必須の、広範なトークン）はトークン「1」であるべきです。"
    },
    {
      "indent": 3,
      "text": "algorithm, validation, auth-scope, realm: MUST be the same values as those received from the client.",
      "ja": "アルゴリズム、検証、認証スコープ、レルム：クライアントから受信したものと同じ値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "sid: (mandatory, hex-fixed-number) MUST be a session identifier, which is a random integer. The sid SHOULD have uniqueness of at least 80 bits or the square of the maximum estimated transactions concurrently available in the session table, whichever is larger. See Section 6 for more details.",
      "ja": "SID：（必須、ヘキサ固定数）ランダム整数であるセッション識別子でなければなりません。 SIDは、少なくとも80ビット以上である方セッションテーブルで同時に使用可能な最大推定トランザクションの正方形の一意性を有するべきです。詳細は、6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "ks1: (mandatory, algorithm-determined) is the server-side key exchange value K_s1, which is specified by the algorithm.",
      "ja": "KS1：（必須、アルゴリズム決定）は、アルゴリズムによって指定されたサーバ側の鍵交換価値K_s1、です。"
    },
    {
      "indent": 3,
      "text": "nc-max: (mandatory, integer) is the maximum value of nonce numbers that the server accepts.",
      "ja": "NC-MAX：（必須、整数）は、サーバが受け入れるノンス数の最大値です。"
    },
    {
      "indent": 3,
      "text": "nc-window: (mandatory, integer) is the number of available nonce number slots that the server will accept. It is RECOMMENDED that the value of the \"nc-window\" parameter be 128 or more.",
      "ja": "NC-ウィンドウ：（必須、整数）サーバが受け入れる利用可能なノンス数スロットの数です。 「NC-ウィンドウ」パラメータの値が128以上であることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "time: (mandatory, integer) represents the suggested time (in seconds) that the client can reuse the session represented by the sid. It is RECOMMENDED that the time be set to at least 60 (seconds). However, the server is not required to guarantee that the session represented by the sid will be available (e.g., alive, usable) for the time specified in this parameter.",
      "ja": "時間：（必須、整数）は、クライアントがSIDで表さセッションを再利用することができます（秒単位）を示唆した時間を表しています。時間が少なくとも60（秒）に設定することをお勧めします。しかし、サーバがSIDで表されるセッションは、このパラメータで指定された時間（例えば、生きている、使用可能な）利用可能になることを保証するために必要とされません。"
    },
    {
      "indent": 3,
      "text": "path: (non-mandatory, string) specifies to which path in the URI space the same authentication is expected to be applied. The value is a space-separated list of URIs, in the same format as that specified in the \"domain\" parameter [RFC7616] for Digest authentications. All path elements contained in the \"path\" parameter MUST be inside the specified auth-scope; if not, clients SHOULD ignore such elements. For better performance, it is important that clients recognize and use this parameter.",
      "ja": "パス：（非必須、ストリング）が同じ認証が適用されることが予想されるURI空間内のどのパスを指定します。値は、ダイジェスト認証のための「ドメイン」パラメータ[RFC7616]で指定されたものと同じ形式で、URIのスペースで区切られたリストです。 「パス」パラメータに含まれるすべてのパス要素は、指定されたAUTH-スコープ内でなければなりません。いない場合、クライアントは、そのような要素を無視すべきです。パフォーマンスを向上させるためには、クライアントは、このパラメータを認識して使用することが重要です。"
    },
    {
      "indent": 0,
      "text": "4.4. req-VFY-C",
      "section_title": true,
      "ja": "4.4。 REQ-VFY-C"
    },
    {
      "indent": 3,
      "text": "Every req-VFY-C message SHALL be a valid HTTP request message containing an Authorization header with a credential containing a \"vkc\" parameter.",
      "ja": "すべてREQ-VFY-Cメッセージは「VKC」パラメータを含む信任状でAuthorizationヘッダを含む有効なHTTPリクエストメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameters contained in the header are as follows:",
      "ja": "次のようにヘッダに含まれるパラメータは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "version: (mandatory, extensive-token) should be the token \"1\".",
      "ja": "バージョン：（必須の、広範なトークン）はトークン「1」であるべきです。"
    },
    {
      "indent": 3,
      "text": "algorithm, validation, auth-scope, realm: MUST be the same values as those received from the server for the session.",
      "ja": "アルゴリズム、検証、認証スコープ、レルムは：セッションのサーバから受信したものと同じ値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "sid: (mandatory, hex-fixed-number) MUST be one of the sid values that was received from the server for the same authentication realm.",
      "ja": "SID：（必須、ヘキサ固定数）が同じ認証領域にサーバから受信されたSID値のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "nc: (mandatory, integer) is a nonce request number that is unique among the requests sharing the same sid. The values of the nonce numbers SHOULD satisfy the properties outlined in Section 6.",
      "ja": "NC：（必須、整数）は、同じSIDを共有する要求の中で一意であるノンスリクエスト数です。ノンス数の値は、セクション6で概説特性を満足させなければなりません。"
    },
    {
      "indent": 3,
      "text": "vkc: (mandatory, algorithm-determined) is the client-side authentication verification value VK_c, which is specified by the algorithm.",
      "ja": "VKC：（必須、アルゴリズム決定）は、アルゴリズムで指定されたクライアント側の認証検証値VK_c、です。"
    },
    {
      "indent": 0,
      "text": "4.5. 200-VFY-S",
      "section_title": true,
      "ja": "4.5。 200-VFY-S"
    },
    {
      "indent": 3,
      "text": "Every 200-VFY-S message SHALL be a valid HTTP message that does not have a 401 (Unauthorized) status code and SHALL contain an Authentication-Info header with a \"vks\" parameter.",
      "ja": "すべての200-VFY-Sメッセージ401（不正な）ステータスコードを持っていないと「VKS」パラメータを持つヘッダ認証-情報を含まなければならない有効なHTTPメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameters contained in the header are as follows:",
      "ja": "次のようにヘッダに含まれるパラメータは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "version: (mandatory, extensive-token) should be the token \"1\".",
      "ja": "バージョン：（必須の、広範なトークン）はトークン「1」であるべきです。"
    },
    {
      "indent": 3,
      "text": "sid: (mandatory, hex-fixed-number) MUST be the value received from the client.",
      "ja": "SID：（必須、ヘキサ固定数）は、クライアントから受信した値である必要があります。"
    },
    {
      "indent": 3,
      "text": "vks: (mandatory, algorithm-determined) is the server-side authentication verification value VK_s, which is specified by the algorithm.",
      "ja": "VKS：（必須、アルゴリズム決定）は、アルゴリズムによって指定されたサーバ側の認証検証値VK_s、です。"
    },
    {
      "indent": 3,
      "text": "The header MUST be sent before the content body; it MUST NOT be sent in the trailer of a chunked-encoded response. If a \"100 (Continue)\" [RFC7231] response is sent from the server, the Authentication-Info header SHOULD be included in that response instead of the final response.",
      "ja": "ヘッダは、コンテンツ本体の前に送信されなければなりません。それはチャンクエンコードされた応答のトレーラーに送ってはいけません。 「100（続行）」[RFC7231]応答がサーバから送信された場合、認証-INFOヘッダではなく、最終的な応答の応答に含まれるべきです。"
    },
    {
      "indent": 0,
      "text": "5. Authentication Realms",
      "section_title": true,
      "ja": "5.認証レルム"
    },
    {
      "indent": 3,
      "text": "In this protocol, an authentication realm is defined as a set of resources (URIs) for which the same set of usernames and passwords is valid. If the server requests authentication for an authentication realm for which the client is already authenticated, the client will automatically perform the authentication using the already-known credentials. However, for different authentication realms, clients MUST NOT automatically reuse usernames and passwords for another realm.",
      "ja": "このプロトコルでは、認証領域は、ユーザ名とパスワードの同じセットが有効であるリソース（のURI）の集合として定義されます。サーバは、クライアントがすでに認証されている認証レルムの認証を要求した場合、クライアントは自動的に、既に知られている資格情報を使用して認証を実行します。しかし、異なる認証レルムのために、クライアントは自動的に別のレルムのユーザー名とパスワードを再利用してはいけません。"
    },
    {
      "indent": 3,
      "text": "As is the case for the Basic and Digest access authentication protocols, the Mutual authentication protocol supports multiple, separate protection spaces to be set up inside each host. Furthermore, the protocol allows a single authentication realm to span several hosts within the same Internet domain.",
      "ja": "Basicおよびダイジェストアクセス認証プロトコルの場合のように、相互認証プロトコルは、各ホスト内に設定される複数の、独立した保護空間をサポートしています。さらに、プロトコルは、単一の認証領域は、同じインターネットドメイン内の複数のホストにまたがることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Each authentication realm is defined and distinguished by the triple of an authentication algorithm, an authentication scope, and a \"realm\" parameter. However, it is NOT RECOMMENDED that server operators use the same pair of an authentication scope and a realm with different authentication algorithms.",
      "ja": "各認証領域は、認証アルゴリズム、認証範囲、および「レルム」パラメータのトリプルによって定義され、区別されます。しかし、サーバーオペレータは、認証範囲と異なる認証アルゴリズムを持つ分野の同じペアを使用することをお勧めしません。"
    },
    {
      "indent": 3,
      "text": "The \"realm\" parameter is a string as defined in Section 4. Authentication scopes are described in the remainder of this section.",
      "ja": "「レルム」パラメータは、このセクションの残りの部分に記載されている第4章認証スコープで定義された文字列です。"
    },
    {
      "indent": 3,
      "text": "An authentication scope specifies the range of hosts spanned by the authentication realm. In this protocol, it MUST be one of the following kinds of strings:",
      "ja": "認証範囲は、認証レルムが張るホストの範囲を指定します。このプロトコルでは、文字列の次の種類のいずれかである必要があります"
    },
    {
      "indent": 3,
      "text": "o Single-server type: A string in the format \"<scheme>://<host>\" or \"<scheme>://<host>:<port>\", where <scheme>, <host>, and <port> are the corresponding URI parts of the request URI. If the default port (i.e., 80 for HTTP and 443 for HTTPS) is used for the underlying HTTP communications, the port part MUST be omitted, regardless of whether it was present in the request URI. In all other cases, the port part MUST be present, and it MUST NOT contain leading zeros. Use this format when authentication is only valid for a specific protocol (such as HTTPS). This format is equivalent to the ASCII serialization of a Web origin, as presented in Section 6.2 of [RFC6454].",
      "ja": "Oシングル・サーバ型：形式の文字列 \"<スキーム>：// <ホスト>\" または \"<スキーム>：// <ホスト>：<ポート>\"、<スキーム>、<ホスト>、および<ポート>リクエストURIの対応するURIの部分です。デフォルトポートは（すなわち、HTTP 80およびHTTPS 443）基礎となるHTTP通信に使用されている場合は、ポート部にかかわらず、それがリクエストURIに存在したかどうか、省略されなければなりません。他のすべての例では、ポート部分が存在している必要があり、それは先行ゼロを含めることはできません。認証（HTTPSなど）特定のプロトコルのためにのみ有効である場合、このフォーマットを使用します。 [RFC6454]の6.2節で提示したこのフォーマットは、ウェブ起源のASCII直列化と等価です。"
    },
    {
      "indent": 3,
      "text": "o Single-host type: The \"host\" part of the requested URI. This is the default value. Authentication realms within this kind of authentication scope will span several protocols (e.g., HTTP and HTTPS) and ports but will not span different hosts.",
      "ja": "Oシングルホストタイプ：要求されたURIの「ホスト」の部分。これがデフォルト値です。認証スコープこの種の内の認証領域は、いくつかのプロトコル（例えば、HTTPおよびHTTPS）およびポートに及ぶであろうが、異なるホストにまたがるないであろう。"
    },
    {
      "indent": 3,
      "text": "o Wildcard-domain type: A string in the format \"*.<domain-postfix>\", where <domain-postfix> is either the host part of the requested URI or any domain in which the requested host is included (this means that the specification \"*.example.com\" is valid for all of hosts \"www.example.com\", \"web.example.com\", \"www.sales.example.com\", and \"example.com\"). The domain-postfix sent by the servers MUST be equal to or included in a valid Internet domain assigned to a specific organization; if clients know, via some means such as a blacklist for HTTP cookies [RFC6265], that the specified domain is not to be assigned to any specific organization (e.g., \"*.com\" or \"*.jp\"), it is RECOMMENDED that clients reject the authentication request.",
      "ja": "Oワイルドカードドメインタイプ：形式の文字列「* <ドメイン接尾辞>」、ここで、<ドメイン接尾辞>要求されたURIのホスト部分、または要求されたホストが含まれている任意のドメインのいずれかである（これがあることを意味仕様 \"* .example.comとは、\" すべてのホスト \"www.example.com\"、 \"web.example.com\"、 \"www.sales.example.com\"、および \"example.com\"）のために有効です。サーバーが送信ドメイン接尾辞は、特定の組織に割り当てられた有効なインターネットドメイン内に等しいか、または含まれている必要があります。クライアントが指定したドメインは、任意の特定の組織に割り当てることはしないようにHTTPクッキー[RFC6265]のためのブラックリストとして、経由して、いくつかの手段を、知っていれば（例えば、「* .COM」または「* .JP」）、それが推奨されますクライアントは、認証要求を拒否していること。"
    },
    {
      "indent": 3,
      "text": "In the above specifications, every \"scheme\", \"host\", and \"domain\" MUST be in lower case, and any internationalized domain names beyond the ASCII character set SHALL be represented in the way they are sent in the underlying HTTP protocol, represented in lowercase characters, i.e., these domain names SHALL be in the form of LDH (\"letters, digits, hyphen\") labels as defined in the Internationalized Domain Names for Applications (IDNA) specification [RFC5890]. A \"port\" MUST be given in shortest unsigned decimal number notation. Not obeying these requirements will cause valid authentication attempts to fail.",
      "ja": "上記の仕様では、すべての「スキーム」、「ホスト」、および「ドメイン」は小文字でなければならない（MUST）、およびASCII文字セットを越えた国際化ドメイン名は、彼らは基本的なHTTPプロトコルで送信された方法で表現代表されるものと小文字で、すなわち、これらのドメイン名は、（「文字、数字、ハイフン」）アプリケーション（IDNA）仕様[RFC5890]のための国際化ドメイン名で定義されたラベルLDHの形でされなければなりません。 「ポート」は、最短符号なしの10進数表記で与えられなければなりません。これらの要件に従うないと失敗する有効な認証の試行が発生します。"
    },
    {
      "indent": 0,
      "text": "5.1. Resolving Ambiguities",
      "section_title": true,
      "ja": "5.1。解決あいまい"
    },
    {
      "indent": 3,
      "text": "In the above definitions of authentication scopes, several scopes may overlap each other. If a client has already been authenticated to several realms applicable to the same server, the client may have multiple lists of the \"path\" parameters received with the \"401-KEX-S1\" message (see Section 4). If these path lists have any overlap, a single URI may belong to multiple possible candidate realms to which the client can be authenticated. In such cases, clients face an ambiguous choice regarding which credentials to send for a new request (see Steps 3 and 4 of the decision procedure presented in Section 10).",
      "ja": "認証スコープの上記の定義において、いくつかのスコープは、互いに重複してもよいです。クライアントがすでに同じサーバに適用いくつかのレルムに認証されている場合、クライアントは「401-KEX-S1」メッセージで受信した「パス」パラメータの複数のリストを有していてもよい（セクション4を参照）。これらのパスリストは任意の重複がある場合は、単一のURIは、クライアントが認証可能な複数の可能な候補レルムに属していてもよいです。このような場合には、クライアントが（第10節で提示決定手順のステップ3および4を参照）新規リクエストを送信するためにどの資格情報に関する曖昧な選択肢に直面しています。"
    },
    {
      "indent": 3,
      "text": "In such cases, a client MAY freely send requests that belong to any of these candidate realms, or it MAY simply send an unauthenticated request and see for which realm the server requests an authentication. It is RECOMMENDED that server operators provide properly configured \"path\" parameters (more precisely, disjoint path sets for each realm) for clients so that such ambiguities will not occur.",
      "ja": "このような場合には、クライアントは自由にこれらの候補レルムのいずれかに属しているリクエストを送信することができ、またはそれは単に認証されていない要求を送信し、サーバが認証を要求するレルムに表示されることがあります。そのような曖昧さが生じないように、サーバーオペレータが適切にクライアントのために（より正確には、独立経路は、各レルムのセット）、「パス」のパラメータを設定して提供することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following procedure is one possible tactic for resolving ambiguities in such cases:",
      "ja": "次の手順では、このような場合に曖昧さを解決するための一つの可能​​な戦術です。"
    },
    {
      "indent": 3,
      "text": "o If the client has previously sent a request to the same URI and it remembers the authentication realm requested by the 401-INIT message at that time, use that realm.",
      "ja": "O場合、クライアントは、以前に同じURIにリクエストを送信しており、それはそのレルムを使用し、その時点で401-INITメッセージによって要求された認証レルムを記憶しています。"
    },
    {
      "indent": 3,
      "text": "o In other cases, use one of the authentication realms representing the most-specific authentication scopes. The list of possible domain specifications shown above is given from most specific to least specific.",
      "ja": "O他の場合には、最も固有の認証範囲を表す認証領域のいずれかを使用します。上に示した可能ドメイン指定のリストは、最も特定的なものからに与えられています。"
    },
    {
      "indent": 6,
      "text": "If there are several choices with different wildcard-domain specifications, the one that has the longest domain-postfix has priority over those with shorter domain-postfixes.",
      "ja": "別のワイルドカードドメイン仕様にいくつかの選択肢がある場合、最長のドメイン接尾辞を持つものは、短いドメイン接尾辞を持つものより優先されます。"
    },
    {
      "indent": 3,
      "text": "o If there are realms with the same authentication scope, there is no defined priority; the client MAY choose any one of the possible choices.",
      "ja": "同じ認証範囲とのレルムが存在する場合、O、全く定義優先順位はありません。クライアントは、可能な選択肢のいずれかを選択することができます。"
    },
    {
      "indent": 0,
      "text": "6. Session Management",
      "section_title": true,
      "ja": "6.セッション管理"
    },
    {
      "indent": 3,
      "text": "In the Mutual authentication protocol, a session represented by an sid is set up using four messages (first request, 401-INIT, req-KEX-C1, and 401-KEX-S1), after which a session secret (z) associated with the session is established. After mutually establishing a session secret, this session, along with the secret, can be used for one or more requests for resources protected by the same realm on the same server. Note that session management is only an inside detail of the protocol and usually not visible to normal users. If a session expires, the client and server SHOULD automatically re-establish another session without informing the user.",
      "ja": "相互認証プロトコルでは、SIDで表されるセッションに関連付けられたセッション・シークレット（Z）の後に、（最初の要求、401-INIT、REQ-KEX-C1および401-KEX-S1）は、4つのメッセージを使用して設定されていますセッションが確立されています。相互セッション秘密を確立した後、このセッションでは、秘密と一緒に、同じサーバー上の同じレルムで保護されたリソースのための1つまたは複数の要求のために使用することができます。そのセッション管理プロトコルの内側のみ詳細と通常ユーザーに通常は見えないことに注意してください。セッションの有効期限が切れた場合は、クライアントとサーバが自動的にユーザーに通知することなく、別のセッションを再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Sessions and session identifiers are local to each server (defined by scheme, host, and port), even if an authentication scope covers multiple servers; clients MUST establish separate sessions for each port of a host to be accessed. Furthermore, sessions and identifiers are also local to each authentication realm, even if they are provided by the same server. The same session identifiers provided either from different servers or for different realms MUST be treated as being independent of each other.",
      "ja": "セッションとセッション識別子は、認証範囲は、複数のサーバーをカバーする場合であっても、（スキーム、ホスト、およびポートによって定義された）各サーバに対してローカルです。クライアントがアクセスするホストのポートごとに、別々のセッションを確立する必要があります。さらに、セッションと識別子は、それらが同一のサーバによって提供されていても、また、各認証レルムに対してローカルです。異なるサーバから、または異なるレルムのいずれかのために設けられ、同一セッション識別子は、互いに独立しているとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD accept at least one req-VFY-C request for each session if the request reaches the server in a time window specified by the \"timeout\" parameter in the 401-KEX-S1 message and if there are no emergent reasons (such as flooding attacks) to forget the session. After that, the server MAY discard any session at any time and MAY send 401-STALE messages for any further req-VFY-C requests received for that session.",
      "ja": "いかなる緊急の理由が存在しない場合、サーバは、（リクエスト401-KEX-S1メッセージに「タイムアウト」パラメータで指定された時間ウィンドウ内でサーバに到達した場合は、各セッションのための少なくとも一つのREQ-VFY-Cの要求を受け入れて、SHOULDフラッディング攻撃など）セッションを忘れること。その後、サーバーは、いつでもセッションを捨てるかもしれ、それ以上のreq-VFY-C要求がそのセッションのために受信するために401-STALEメッセージを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The client MAY send two or more requests using a single session specified by the sid. However, for all such requests, each value of the nonce number (in the \"nc\" parameter) MUST satisfy the following conditions:",
      "ja": "クライアントは、SIDで指定された単一のセッションを使用して、2つ以上の要求を送信することができます。しかし、すべてのそのような要求に対して、（「NC」パラメータで）ナンス番号の各値は、以下の条件を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "o It is a natural number.",
      "ja": "Oそれは自然数です。"
    },
    {
      "indent": 3,
      "text": "o The same nonce number was not sent within the same session.",
      "ja": "O同じナンス番号が同じセッション内で送信されませんでした。"
    },
    {
      "indent": 3,
      "text": "o It is not larger than the nc-max value that was sent from the server in the session represented by the sid.",
      "ja": "Oこれは、SIDによって表されるセッション内のサーバーから送信されたNC-maxの値よりも大きくありません。"
    },
    {
      "indent": 3,
      "text": "o It is larger than (largest-nc - nc-window), where largest-nc is the largest value of nc that was previously sent in the session and nc-window is the value of the \"nc-window\" parameter that was received from the server for the session.",
      "ja": "最大-NCは、以前のセッションで送信されたNCの最大値であり、NC-ウィンドウが受信された「NC-ウィンドウ」パラメータの値であり、 -  Oそれは（NC-ウィンドウ最大-NC）よりも大きいですセッションのサーバーから。"
    },
    {
      "indent": 3,
      "text": "The last condition allows servers to reject any nonce numbers that are \"significantly\" smaller than the \"current\" value (defined by the value of nc-window) of the nonce number used in the session involved. In other words, servers MAY treat such nonce numbers as \"already received\". This restriction enables servers to implement duplicate-nonce detection in a constant amount of memory for each session.",
      "ja": "最後の条件は、サーバが「有意に」関与するセッションで使用されるノンス数の（NC-ウィンドウの値によって定義される）、「現在の」値よりも小さい任意のナンス番号を拒否することを可能にします。言い換えれば、サーバは、「受信済み」などナンス数字を扱うかもしれ。この制限は、各セッションのメモリの一定量に重複ナンスの検出を実装するためのサーバーを可能にします。"
    },
    {
      "indent": 3,
      "text": "Servers MUST check for duplication of the received nonce numbers, and if any duplication is detected, the server MUST discard the session and respond with a 401-STALE message, as outlined in Section 11. The server MAY also reject other invalid nonce numbers (such as those above the nc-max limit) by sending a 401-STALE message.",
      "ja": "セクション11にサーバを概説したように、このような（他の無効なナンス番号を拒絶MAY、サーバは、受信したノンス番号の重複を確認する必要があり、任意の重複が検出された場合、サーバは、セッションを破棄し、401-STALEメッセージで応答しなければなりません401-STALEメッセージを送信することによって、NC-maxの限界を超えるもの）として。"
    },
    {
      "indent": 3,
      "text": "For example, assume that the nc-window value of the current session is 128 and nc-max is 400, and that the client has already used the following nonce numbers: {1-120, 122, 124, 130-238, 255-360, 363-372}. The nonce number that can then be used for the next request is a number from the following set: {245-254, 361, 362, 373-400}. The values {0, 121, 123, 125-129, 239-244} MAY be rejected by the server because they are not above the current \"window limit\" (244 = 372 - 128).",
      "ja": "{1-120、122、124、130から238、255-たとえば、現在のセッションのNC-ウィンドウ値は128であり、NC-maxは400であり、クライアントは、既に次のノンス番号を使用したことを仮定する360、363から372}。 {245-254、361、362、373から400}：次に、次のリクエストのために使用することができるノンス数は、次の組の数です。それらは現在 \"ウィンドウ限界\"（ -  128 244 = 372）上にないため、値{0、121、123、125-129、239-244}がサーバによって拒否されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Typically, clients can ensure the above property by using a monotonically increasing integer counter that counts from zero up to the value of nc-max.",
      "ja": "典型的には、クライアントは、NC-MAXの値までゼロからカウント単調に増加する整数のカウンタを使用して、上記の特性を確保することができます。"
    },
    {
      "indent": 3,
      "text": "The values of the nonce numbers and any nonce-related values MUST always be treated as natural numbers within an infinite range. Implementations that use fixed-width integer representations, fixed-precision floating-point numbers, or similar representations SHOULD NOT reject any larger values that overflow such representative limits and MUST NOT silently truncate them using any modulus-like rounding operation (e.g., by mod 2^32). Instead, the whole protocol is carefully designed so that recipients MAY replace any such overflowing values (e.g., 2^80) with some reasonably large maximum representative integer (e.g., 2^31 - 1 or others).",
      "ja": "ナンス番号と任意のナンス関連値の値は常に無限の範囲内の自然数として扱われなければなりません。固定幅の整数表現、固定精度浮動小数点数、または同様の表現を使用する実装は、そのような代表的な制限をオーバーフロー任意の大きな値を拒絶すべきではなく、静かにMOD 2によって、例えば、（任意の係数のような丸め操作を使用してそれらを切り捨ててはいけません^ 32）。受信者がいくつかの合理的に大きな最大代表整数（ -  1等、例えば、2 ^ 31）と、そのようなあふれた値（例えば、2 ^ 80）を交換できるように、その代わりに、全体のプロトコルを慎重に設計されています。"
    },
    {
      "indent": 0,
      "text": "7. Host Validation Methods",
      "section_title": true,
      "ja": "7.ホストの検証方法"
    },
    {
      "indent": 3,
      "text": "The \"validation method\" specifies a method to \"relate\" (or \"bind\") the mutual authentication processed by this protocol with other authentications already performed in the underlying layers and to prevent man-in-the-middle attacks. It determines the value vh that is an input to the authentication protocols.",
      "ja": "「検証方法」が「関連」（または「バインド」）、他の認証済み下層で行い、man-in-the-middle攻撃を防止するとともに、このプロトコルによって処理された相互認証する方法を指定します。これは、認証プロトコルに入力された値VHを決定します。"
    },
    {
      "indent": 3,
      "text": "When HTTPS or another possible secure transport is used, this corresponds to the idea of \"channel binding\" as described in [RFC5929]. Even when HTTP is used, similar, but somewhat limited, \"binding\" is performed to prevent a malicious server from trying to authenticate itself to another server as a valid user by forwarding the received credentials.",
      "ja": "HTTPSまたは別の可能なセキュアトランスポートが使用される場合、これは[RFC5929]に記載されているように、「結合チャネル」の概念に相当します。 HTTPを使用した場合でも、同様の、やや限定された、「結合」を受け取った資格情報を転送することで、有効なユーザーとして別のサーバーに自身を認証しようとする悪意のあるサーバーを防ぐために行われます。"
    },
    {
      "indent": 3,
      "text": "The valid tokens for the \"validation\" parameter and corresponding values of vh are as follows:",
      "ja": "次のようにVHの「検証」パラメータと対応する値のための有効なトークンは、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "host: hostname validation. The value vh will be the ASCII string in the following format: \"<scheme>://<host>:<port>\", where <scheme>, <host>, and <port> are the URI components corresponding to the server-side resource currently being accessed. The scheme and host are in lower case, and the port is listed in shortest decimal notation. Even if the request URI does not have a port part, vh will include the default port number.",
      "ja": "ホスト：ホスト名の検証。値VHは、次の形式のASCII文字列になります：「<スキーム>：// <ホスト>：<ポート>」、<スキーム>、<ホスト>、および<ポート> URIコンポーネントは、サーバーに対応しています側のリソースは、現在アクセスされています。スキームとホストは小文字であり、及びポートが最短進表記で記載されています。リクエストURIがポート部分を持っていない場合でも、VHは、デフォルトのポート番号が含まれます。"
    },
    {
      "indent": 3,
      "text": "tls-server-end-point: TLS endpoint (certificate) validation. The value vh will be the octet string of the hash value of the server's public key certificate used in the underlying TLS [RFC5246] connection, processed as specified in Section 4.1 of [RFC5929].",
      "ja": "TLS-サーバー・エンドポイント：TLSエンドポイント（証明書）の検証。 [RFC5929]のセクション4.1で指定された値のVHが処理された基本的なTLS [RFC5246]の関連で使用されるサーバの公開鍵証明書のハッシュ値のオクテット文字列になります。"
    },
    {
      "indent": 3,
      "text": "tls-unique: TLS shared-key validation. The value vh will be the channel-binding material derived from the Finished messages, as defined in Section 3.1 of [RFC5929]. (Note: See Section 7.2 for some security-related notes regarding this validation method.)",
      "ja": "TLS-ユニーク：TLS共有キーの検証。 [RFC5929]のセクション3.1で定義されている値VHが、Finishedメッセージに由来するチャンネル結合物質であろう。 （注意：この検証方法に関するいくつかのセキュリティ関連の注意事項については、セクション7.2を参照してください。）"
    },
    {
      "indent": 3,
      "text": "If HTTP is used on a non-encrypted channel (TCP and the Stream Control Transmission Protocol (SCTP), for example), the validation type MUST be \"host\". If HTTP/TLS [RFC2818] (HTTPS) is used with a server certificate, the validation type MUST be \"tls-server-end-point\". If HTTP/TLS is used with an anonymous Diffie-Hellman key exchange, the validation type MUST be \"tls-unique\" (see the note below).",
      "ja": "HTTPは、非暗号化チャネル（例えばTCPおよびストリーム制御伝送プロトコル（SCTP））上で使用される場合、検証タイプは、「ホスト」でなければなりません。 HTTP / TLS [RFC2818]（HTTPS）がサーバ証明書で使用される場合、検証タイプは、「TLSサーバエンドポイント」でなければなりません。 HTTP / TLSは、匿名のDiffie-Hellman鍵交換を一緒に使用されている場合は、検証タイプは、「TLS-ユニーク」（下記の注を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the validation type \"tls-server-end-point\" is used, the server certificate provided in the TLS connection MUST be verified at least to make sure that the server actually owns the corresponding private key. (Note: This verification is automatic in some RSA-based key exchanges but is NOT automatic in Diffie-Hellman-based key exchanges with separate exchanges for server verification.)",
      "ja": "検証タイプ「TLS-サーバー・エンドポイント」を使用する場合は、TLS接続で提供されるサーバー証明書は、少なくとも、サーバーが実際に対応する秘密鍵を所有していることを確認するために検証されなければなりません。 （注：この検証は、いくつかのRSAベースの鍵交換に自動であるが、サーバの検証のための別々の交換とディフィー・ヘルマンベースの鍵交換に自動ではありません。）"
    },
    {
      "indent": 3,
      "text": "Clients MUST validate this parameter upon receipt of 401-INIT messages.",
      "ja": "クライアントは、401-INITメッセージの受信時に、このパラメータを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The protocol defines two variants of validation on the TLS connections. The \"tls-unique\" method is technically more secure. However, there are some situations where \"tls-server-end-point\" is preferable:",
      "ja": "注意：プロトコルは、TLS接続の検証の二つの変種を定義します。 「TLS-ユニークな」方法は技術的にはより安全です。しかし、「TLS-サーバー・エンドポイントは」望ましいいくつかの状況があります。"
    },
    {
      "indent": 3,
      "text": "o When TLS accelerating proxies are used. In this case, it is difficult for the authenticating server to acquire the TLS key information that is used between the client and the proxy. This is not the case for client-side \"tunneling\" proxies using the HTTP CONNECT method.",
      "ja": "Oプロキシを加速TLSを使用する場合。認証サーバは、クライアントとプロキシ間で使用されるTLSキー情報を取得するため、この場合には、それが困難です。これは、HTTP CONNECTメソッドを使用してクライアント側の「トンネリング」プロキシの場合はそうではありません。"
    },
    {
      "indent": 3,
      "text": "o When a black-box implementation of the TLS protocol is used on either peer.",
      "ja": "O TLSプロトコルのブラックボックス実装は、いずれかのピアで使用する場合。"
    },
    {
      "indent": 0,
      "text": "7.1. Applicability Notes",
      "section_title": true,
      "ja": "7.1。適用性の注意事項"
    },
    {
      "indent": 3,
      "text": "When the client is a Web browser with any scripting capabilities (support of dynamic contents), the underlying TLS channel used with HTTP/TLS MUST provide server identity verification. This means that (1) anonymous Diffie-Hellman key exchange cipher suites MUST NOT be used and (2) verification of the server certificate provided by the server MUST be performed. This is to prevent loading identity-unauthenticated scripts or dynamic contents, which are referenced from the authenticated page.",
      "ja": "クライアントは、任意のスクリプト機能を備えたWebブラウザ（ダイナミックコンテンツのサポート）、HTTPで使用される基本的なTLSチャネルがある場合は/ TLSは、サーバーの身元確認を提供しなければなりません。これは、（1）匿名のDiffie-Hellmanキー交換暗号スイートを使用してはいけません（2）サーバが提供するサーバ証明書の検証が行わなければならないことを意味します。これは、認証されたページから参照されているロードアイデンティティ認証されていないスクリプトや動的なコンテンツを、防ぐためです。"
    },
    {
      "indent": 3,
      "text": "For other systems, when the underlying TLS channel used with HTTP/TLS does not perform server identity verification, the client SHOULD ensure that all responses are validated using the Mutual authentication protocol, regardless of the existence of 401-INIT responses.",
      "ja": "HTTP / TLSで使用する基本的なTLSチャネルは、サーバ本人確認を行っていないときに、他のシステムでは、クライアントはすべての応答に関係なく401-INIT応答の存在の、相互認証プロトコルを使用して検証していることを確認してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Notes on \"tls-unique\"",
      "section_title": true,
      "ja": "7.2。 「TLS-ユニークな」についてのご注意"
    },
    {
      "indent": 3,
      "text": "As described in the interoperability note in Section 3.1 of [RFC5929], the \"tls-unique\" verification value will be changed by possible TLS renegotiation, causing an interoperability problem. TLS renegotiations are used in several HTTPS server implementations for enforcing some security properties (such as cryptographic strength) for some specific responses.",
      "ja": "[RFC5929]のセクション3.1での相互運用性ノートに記載されているように、「TLS固有の」検証値は、相互運用性の問題を引き起こす可能TLS再ネゴシエーションにより変更されるであろう。 TLS再ネゴシエーションは、いくつかの特定の反応のために（例えば、暗号の強さのような）いくつかのセキュリティ特性を強化するためのいくつかHTTPSサーバの実装に使用されています。"
    },
    {
      "indent": 3,
      "text": "If an implementation supports the \"tls-unique\" verification method, the following precautions SHOULD be taken:",
      "ja": "実装は、「TLS-ユニークな」検証方法をサポートしている場合は、以下の予防措置が取られるべきです："
    },
    {
      "indent": 3,
      "text": "o Both peers must be aware that the vh values used for vkc (in req-VFY-C messages) and vks (in 200-VFY-S messages) may be different. These values MUST be retrieved from underlying TLS libraries each time they are used.",
      "ja": "O両方のピアは、（200-VFY-Sメッセージ内）のVH（REQ-VFY-Cメッセージで）VKCのために使用される値とVKSは異なっていてもよいことに注意しなければなりません。これらの値は、基礎となるTLSライブラリから、彼らが使用されるたびに取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "o After calculating the values vh and vkc to send a req-VFY-C request, clients SHOULD NOT initiate TLS renegotiation until the end of the corresponding response header is received. An exception is that clients can and SHOULD perform TLS renegotiation as a response to the server's request for TLS renegotiation, before receipt of the beginning of the response header.",
      "ja": "対応する応答ヘッダの終了を受信するまでO REQ-VFY-C要求を送信する値VHとVKCを計算した後、クライアントは、TLS再ネゴシエーションを開始すべきではありません。例外は、クライアントが、応答ヘッダーの始まりを受け取る前に、TLS再ネゴシエーションのためのサーバの要求に対する応答として、TLSの再交渉を行うべきであるということです。"
    },
    {
      "indent": 3,
      "text": "Also, implementers MUST take care of session resumption attacks regarding \"tls-unique\" channel-binding mechanisms and master secrets. As a mitigation, the TLS extension defined in [RFC7627] SHOULD be used when \"tls-unique\" host verification is to be used.",
      "ja": "また、実装者は、「TLS-ユニークな」チャネル結合機構やマスター秘密に関するセッション再開攻撃の世話をしなければなりません。緩和されるように、[RFC7627]で定義されたTLS拡張子は「TLS-ユニーク」は、宿主検証が使用されるときに使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. Authentication Extensions",
      "section_title": true,
      "ja": "8.認証の拡張"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that interactive clients (e.g., Web browsers) supporting this protocol support non-mandatory authentication and the Authentication-Control header defined in [RFC8053], except for the \"auth-style\" parameter. This specification also proposes (but does not mandate) that the default \"auth-style\" be \"non-modal\". Web applications SHOULD, however, consider the security impacts of the behavior of clients that do not support these headers.",
      "ja": "インタラクティブクライアント（例えば、Webブラウザ）は、「AUTHスタイル」パラメータを除いて、このプロトコルをサポート非必須の認証と[RFC8053]で定義された認証-Controlヘッダーをサポートすることが推奨されます。また、この仕様は、デフォルト「のauth-スタイル」は「非モーダル」することが提案されている（ただし、必須ではありません）。 Webアプリケーションは、しかし、これらのヘッダをサポートしていないクライアントの動作のセキュリティへの影響を考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Authentication-initializing messages with the Optional-WWW-Authenticate header are used only where the 401-INIT response is valid. It will not replace other 401-type messages such as 401-STALE and 401-KEX-S1. That is, the \"reason\" field of such a message MUST be \"initial\" (or any extensive-tokens NOT defined in Section 4.1).",
      "ja": "401-INIT応答が有効である場合にのみオプション-WWW-Authenticateヘッダの認証初期化メッセージが使用されます。このような401-STALEおよび401-KEX-S1などの他の401型メッセージを置き換えることはありません。すなわち、このようなメッセージの「理由」フィールドが「初期」でなければなりません（または任意の広範囲のトークンは、セクション4.1で定義されていません）。"
    },
    {
      "indent": 0,
      "text": "9. String Preparation",
      "section_title": true,
      "ja": "9.文字列の準備"
    },
    {
      "indent": 3,
      "text": "For interoperability reasons, it is important that usernames and passwords used in this protocol be binary-comparable, regardless of the user's input methods and/or environments. To ensure this, the following preparation SHOULD be performed:",
      "ja": "相互運用性の理由から、このプロトコルで使用されるユーザー名とパスワードに関係なく、ユーザの入力方法および/または環境の、バイナリ同等であることが重要です。これを確実にするために、次の準備を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Usernames received from users SHOULD be prepared using the \"UsernameCasePreserved\" profile defined in Section 3.3 of [RFC7613].",
      "ja": "[RFC7613]のセクション3.3で定義された「UsernameCasePreserved」プロファイルを使用して準備する必要がありOユーザ名は、ユーザから受信しました。"
    },
    {
      "indent": 3,
      "text": "o Passwords received from users SHOULD be prepared using the \"OpaqueString\" profile defined in Section 4.2 of [RFC7613].",
      "ja": "Oパスワードは[RFC7613]のセクション4.2で定義された「OpaqueString」プロファイルを使用して準備する必要があり、ユーザーから受け取りました。"
    },
    {
      "indent": 3,
      "text": "In both cases, it is the sender's duty to correctly prepare the character strings. If any non-prepared character string is received from the other peer of the communication, the behavior of its recipient is not defined; the recipient MAY either accept or reject such input.",
      "ja": "どちらの場合も、正しく文字列を準備するために、送信者の義務です。任意の非調製文字列を通信の他のピアから受信された場合、その受信者の振る舞いが定義されていません。受信者は、このような入力を受け入れるか拒否するかもしれないどちらか。"
    },
    {
      "indent": 3,
      "text": "Server applications SHOULD also prepare usernames and passwords accordingly upon registration of user credentials.",
      "ja": "サーバ・アプリケーションは、ユーザーの資格情報の登録時に応じてユーザー名とパスワードを準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition, binary-based \"interfaces\" of implementations MAY require and assume that the string is already prepared accordingly; when a string is already stored as a binary Unicode string form, implementations MAY omit preparation and Unicode normalization (performing UTF-8 encoding only) before using it. When a string is already stored as an octet blob, implementations MAY send it as is.",
      "ja": "また、実装のバイナリベースの「インターフェース」が必要と文字列が既に応じて調製されることを仮定してもよいです。文字列が既にバイナリUnicode文字列形式として保存されている場合、実装は、製造およびそれを使用する前に、（UTF-8符号化のみを行う）Unicode正規化を省略することができます。文字列がすでにオクテットブロブとして格納されている場合であるとして、実装はそれを送信することができます。"
    },
    {
      "indent": 0,
      "text": "10. Decision Procedure for Clients",
      "section_title": true,
      "ja": "クライアントの10.決定手続き"
    },
    {
      "indent": 0,
      "text": "10.1. General Principles and Requirements",
      "section_title": true,
      "ja": "10.1。一般原則と要件"
    },
    {
      "indent": 3,
      "text": "To securely implement the protocol, the client must be careful about accepting the authenticated responses from the server. This also holds true for the reception of a \"normal response\" (a response that does not contain mutual-authentication-related headers) from HTTP servers.",
      "ja": "安全プロトコルを実装するには、クライアントがサーバーから認証された応答を受け入れるに注意する必要があります。また、これはHTTPサーバからの「正常な応答」（相互認証関連のヘッダーが含まれていない応答）の受信にも当てはまります。"
    },
    {
      "indent": 3,
      "text": "Per typical HTTP authentication, a single user-level request may result in the exchange of two or more HTTP requests and responses in sequence. The following normative rules MUST be followed by the clients implementing this protocol:",
      "ja": "典型的なHTTP認証ごとに、単一のユーザレベル要求は、シーケンス内の2つの以上のHTTP要求と応答の交換をもたらすことができます。以下の規範的なルールは、このプロトコルを実装するクライアントが続かなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Any kind of \"normal response\" MUST only be accepted for the very first request in the sequence. Any \"normal response\" returned for the second or subsequent requests in the sequence SHALL be considered invalid.",
      "ja": "O「正常な応答」の任意の種類の配列のみで非常に最初の要求のために受理されなければなりません。シーケンスにおける第二またはその後の要求のために返された「正常な応答が」無効考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o By the same principle, if any response is related to an authentication realm that is different from that of the client's request (for example, a 401-INIT message requesting authentication on another realm), it MUST only be accepted for the very first request in the sequence. Such a response returned for a second or subsequent request in the sequence SHALL be considered invalid.",
      "ja": "任意の応答がクライアントの要求とは異なる認証領域に関連している場合、同じ原理で、Oは、（例えば、別の領域で認証を要求する401-INITメッセージ）は、それが非常に最初の要求を受け入れなければなりませんシーケンスインチシーケンス内の第二の又は後続の要求は無効とみなされるため、このような応答が返されます。"
    },
    {
      "indent": 3,
      "text": "o A req-KEX-C1 message MAY be sent as either an initial request or a response to a 401-INIT or 401-STALE message. However, to avoid infinite loops of messages, the req-KEX-C1 message SHOULD NOT be sent more than once in the sequence for a single authentication realm. A 401-KEX-S1 response MUST be accepted only when the corresponding request is req-KEX-C1.",
      "ja": "O REQ-KEX-C1のメッセージは、最初の要求または401-INITまたは401-STALEメッセージへの応答のいずれかとして送信されるかもしれません。ただし、メッセージの無限ループを回避するために、REQ-KEX-C1のメッセージは、単一の認証領域に順番に複数回送るべきではありません。 401-KEX-S1の応答は、対応する要求REQ-KEX-C1である場合にのみ受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A req-VFY-C message MAY be sent if there is a valid session secret shared between the client and the server, as established by req-KEX-C1 and 401-KEX-S1 messages. If any response with a 401 status code is returned for such a message, the corresponding session secret SHOULD be discarded as unusable.",
      "ja": "クライアントとサーバの間で共有される有効なセッション秘密がある場合REQ-KEX-C1および401-KEX-S1メッセージによって確立されるO-REQ VFY-Cメッセージは、送信されるかもしれません。 401のステータスコードを有する任意の応答は、このようなメッセージのために戻された場合、対応するセッション秘密は使用不能として廃棄されるべきです。"
    },
    {
      "indent": 6,
      "text": "In particular, upon the reception of a 401-STALE response, the client SHOULD try to establish a new session by sending a req-KEX-C1 message, but only once within the request/response sequence.",
      "ja": "具体的には、401-STALE応答を受信すると、クライアントはREQ-KEX-C1のメッセージを送信することによって、新しいセッションを確立しようとしたが、一度だけの要求/応答シーケンス内にすべきです。"
    },
    {
      "indent": 3,
      "text": "o A 200-VFY-S message MUST be accepted only as a response to a req-VFY-C message and nothing else. The VK_s values of such response messages MUST always be checked against the correct value, and if it is incorrect, the whole response SHOULD be considered invalid.",
      "ja": "O 200-VFY-Sメッセージは、REQ-VFY-Cメッセージと何も応答として受け入れなければなりません。このような応答メッセージのVK_s値は常に正しい値と照合しなければならない、それが間違っている場合は、全体の応答が無効とみなされるべきです。"
    },
    {
      "indent": 3,
      "text": "The final status of the client request following the message exchange sequence shall be determined as follows:",
      "ja": "次のようにメッセージ交換シーケンスを次のクライアント要求の最終ステータスを決定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o AUTH-SUCCEED: A 200-VFY-S message with the correct VK_s value was returned in response to the req-VFY-C request in the sequence.",
      "ja": "AUTH-SUCCEED O：200 VFY-Sメッセージ正しいVK_s値は、配列におけるREQ-VFY-C要求に応答して返されたと。"
    },
    {
      "indent": 3,
      "text": "o AUTH-REQUIRED: Two cases exist:",
      "ja": "O-AUTH REQUIRED：2つのケースが存在します。"
    },
    {
      "indent": 6,
      "text": "* A 401-INIT message was returned from the server, and the client does not know how to authenticate to the given authentication realm.",
      "ja": "* 401-INITメッセージは、サーバから返された、およびクライアントは、与えられた認証レルムの認証を受ける方法を知りません。"
    },
    {
      "indent": 6,
      "text": "* A 401-INIT response was returned for a req-VFY-C (or req-KEX-C1) message, which means that the user-supplied authentication credentials were not accepted.",
      "ja": "* 401-INIT応答は、ユーザ供給認証資格情報が受け入れられなかったことを意味REQ-VFY-C（又はREQ-KEX-C1）メッセージのために戻されました。"
    },
    {
      "indent": 3,
      "text": "o UNAUTHENTICATED: A \"normal response\" is returned for an initial request of any kind in the sequence.",
      "ja": "O UNAUTHENTICATED：「正常な応答」は、配列内の任意の種類の最初のリクエストに対して返されます。"
    },
    {
      "indent": 3,
      "text": "Any kind of response (including a \"normal response\") other than those explicitly allowed in the above rules SHOULD be interpreted as a fatal communication error. In such cases, the clients MUST NOT process any data (the response body and other content-related headers) sent from the server. However, to handle exceptional error cases, clients MAY accept a message without an Authentication-Info header if it has a Server Error (5xx) status code. In such cases, they SHOULD be careful about processing the body of the content (ignoring it is still RECOMMENDED, as it may possibly be forged by intermediate attackers), and the client will then have a status of \"UNAUTHENTICATED\".",
      "ja": "明示的に上記の規則で許容されるもの以外の（「正常応答」を含む）応答の任意の種類は、致命的な通信エラーとして解釈されるべきです。このような場合、クライアントは、サーバから送信されたデータ（レスポンスボディと他のコンテンツに関連するヘッダ）を処理してはいけません。それはサーバーエラー（5xxの）ステータスコードを持っている場合は、例外的なエラーケースを処理するために、クライアントが認証-Infoヘッダーのないメッセージを受け入れることができます。このような場合には、彼らはコンテンツの本体を処理について注意しなければならない（それを無視することは、おそらく、中間攻撃者によって偽造することができるよう、まだ、推奨される）、およびクライアントは、その後、「UNAUTHENTICATED」の状態になります。"
    },
    {
      "indent": 3,
      "text": "If a request is a sub-request for a resource included in another resource (e.g., embedded images, style sheets, frames), clients MAY treat an AUTH-REQUESTED status the same way they would treat an UNAUTHENTICATED status. In other words, the client MAY ignore the server's request to start authentication with new credentials via sub-requests.",
      "ja": "リクエストはリソースのサブリクエストが別のリソース（例えば、埋め込み画像、スタイルシート、フレーム）に含まれている場合、クライアントはAUTH-REQUESTED状態に彼らがUNAUTHENTICATED状態を治療するのと同じ方法で扱うかもしれ。言い換えれば、クライアントは、サブリクエストを介した新しい資格情報を使用して認証を開始するには、サーバーの要求を無視してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "10.2. State Machine for the Client (Informative)",
      "section_title": true,
      "ja": "10.2。クライアントのステートマシン（参考情報）"
    },
    {
      "indent": 3,
      "text": "The following state machine describes the possible request-response sequences derived from the above normative rules. If implementers are not quite sure of the security consequences of the above rules, we strongly advise that the decision procedure below be followed. In particular, clients SHOULD NOT accept \"normal responses\" unless explicitly allowed in the rules. The labels in the steps below are for informational purposes only. Action entries within each step are checked in top-to-bottom order, and the first clause satisfied is to be followed.",
      "ja": "次のステートマシンは、上記規定のルールに由来する可能な要求 - 応答シーケンスを記述する。実装者は、上記の規則のセキュリティへの影響のかなり確実でない場合は、私たちは強く、以下の決定手順に従うことをお勧めします。明示的ルールで許可されない限り、具体的には、クライアントが「正常な応答を」受け入れるべきではありません。以下の手順でラベルは、情報提供のみを目的としています。各ステップ内のアクションエントリは上から下への順序でチェックされ、そして満足第一句が続くべきです。"
    },
    {
      "indent": 3,
      "text": "Step 1 (step_new_request): If the client software needs to access a new Web resource, check to see whether the resource is expected to be inside some authentication realm for which the user has already been authenticated via the Mutual authentication scheme. If yes, go to Step 2. Otherwise, go to Step 5.",
      "ja": "ステップ1（step_new_request）：クライアント・ソフトウェアは、新しいWebリソースにアクセスする必要がある場合、リソースはユーザーがすでに相互認証方式で認証されたいくつかの認証レルム内であることが予想されているかどうかを確認します。はい、そうでない場合はステップ2に行く場合は、手順5に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 2: Check to see whether there is an available sid for the expected authentication realm. If there is one, go to Step 3. Otherwise, go to Step 4.",
      "ja": "ステップ2：期待される認証レルムのために利用可能SIDがあるかどうかを確認します。 1があれば、そうでない場合はステップ3に進む、ステップ4に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 3 (step_send_vfy_1): Send a req-VFY-C request.",
      "ja": "ステップ3（step_send_vfy_1）：REQ-VFY-C要求を送信します。"
    },
    {
      "indent": 7,
      "text": "*  If a 401-INIT message is received with a different\n   authentication realm than expected, go to Step 6.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* If a 401-STALE message is received, go to Step 9.",
      "ja": "* 401-STALEメッセージを受信した場合は、手順9に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received, go to Step 13.",
      "ja": "* 401-INITメッセージが受信された場合、ステップ13に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 200-VFY-S message is received, go to Step 14.",
      "ja": "200-VFY-Sメッセージを受信した場合*、14に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a \"normal response\" is received, go to Step 11.",
      "ja": "「通常の応答」を受信した場合*、11に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 4 (step_send_kex1_1): Send a req-KEX-C1 request.",
      "ja": "ステップ4（step_send_kex1_1）：REQ-KEX-C1要求を送ります。"
    },
    {
      "indent": 7,
      "text": "*  If a 401-INIT message is received with a different\n   authentication realm than expected, go to Step 6.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* If a 401-KEX-S1 message is received, go to Step 10.",
      "ja": "401-KEX-S1メッセージを受信した場合*、ステップ10に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received with the same authentication realm, go to Step 13 (see Note 1).",
      "ja": "401-INITメッセージが同一の認証領域で受信された場合*、ステップ13に進み（注1を参照）。"
    },
    {
      "indent": 7,
      "text": "* If a \"normal response\" is received, go to Step 11.",
      "ja": "「通常の応答」を受信した場合*、11に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 5 (step_send_normal_1): Send a request without any mutual-authentication headers.",
      "ja": "ステップ5（step_send_normal_1）：任意の相互認証ヘッダーなしで要求を送信します。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received, go to Step 6.",
      "ja": "* 401-INITメッセージが受信された場合は、ステップ6に進んでください。"
    },
    {
      "indent": 7,
      "text": "* If a \"normal response\" is received, go to Step 11.",
      "ja": "「通常の応答」を受信した場合*、11に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 6 (step_rcvd_init): Check to see whether the user's password for the requested authentication realm is known. If yes, go to Step 7. Otherwise, go to Step 12.",
      "ja": "ステップ6（step_rcvd_init）：要求された認証レルムのユーザーのパスワードが知られているかどうかを確認します。はい、そうでない場合はステップ7に行く場合は、ステップ12に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 7: Check to see whether there is an available sid for the expected authentication realm. If there is one, go to Step 8. Otherwise, go to Step 9.",
      "ja": "ステップ7：期待される認証レルムのために利用可能SIDがあるかどうかを確認します。 1があれば、そうでない場合はステップ8に進みます、9に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 8 (step_send_vfy): Send a req-VFY-C request.",
      "ja": "ステップ8（step_send_vfy）：REQ-VFY-C要求を送信します。"
    },
    {
      "indent": 7,
      "text": "* If a 401-STALE message is received, go to Step 9.",
      "ja": "* 401-STALEメッセージを受信した場合は、手順9に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received, go to Step 13.",
      "ja": "* 401-INITメッセージが受信された場合、ステップ13に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 200-VFY-S message is received, go to Step 14.",
      "ja": "200-VFY-Sメッセージを受信した場合*、14に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 9 (step_send_kex1): Send a req-KEX-C1 request.",
      "ja": "ステップ9（step_send_kex1）：REQ-KEX-C1要求を送ります。"
    },
    {
      "indent": 7,
      "text": "* If a 401-KEX-S1 message is received, go to Step 10.",
      "ja": "401-KEX-S1メッセージを受信した場合*、ステップ10に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received, go to Step 13 (see Note 1).",
      "ja": "* 401-INITメッセージが受信された場合、ステップ13に進み（注1を参照）。"
    },
    {
      "indent": 3,
      "text": "Step 10 (step_rcvd_kex1): Send a req-VFY-C request.",
      "ja": "ステップ10（step_rcvd_kex1）：REQ-VFY-C要求を送信します。"
    },
    {
      "indent": 7,
      "text": "* If a 401-INIT message is received, go to Step 13.",
      "ja": "* 401-INITメッセージが受信された場合、ステップ13に進みます。"
    },
    {
      "indent": 7,
      "text": "* If a 200-VFY-S message is received, go to Step 14.",
      "ja": "200-VFY-Sメッセージを受信した場合*、14に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 11 (step_rcvd_normal): The requested resource is out of the authenticated area. The client will be in the \"UNAUTHENTICATED\" status. If the response contains a request for authentication other than Mutual authentication, it MAY be handled normally.",
      "ja": "ステップ11（step_rcvd_normal）：要求されたリソースは、認証済みの領域の外にあります。クライアントは、「UNAUTHENTICATED」の状態になります。応答が相互認証以外の認証のための要求が含まれている場合、それは正常に処理されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Step 12 (step_rcvd_init_unknown): The requested resource requires Mutual authentication, and the user is not yet authenticated. The client will be in the \"AUTH-REQUESTED\" status; it is RECOMMENDED that the client process the content sent from the server and ask the user for a username and password. When those are supplied by the user, go to Step 9.",
      "ja": "ステップ12（step_rcvd_init_unknown）：要求されたリソースは、相互認証を必要とし、ユーザーがまだ認証されていません。クライアントは、「AUTHが要求した」状態になります。クライアント・プロセスコンテンツは、サーバから送信され、ユーザのユーザ名とパスワードを尋ねることが推奨されます。それらがユーザーによって供給されている場合は、手順9に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 13 (step_rcvd_init_failed): The authentication failed for some reason, possibly because the password or username is invalid for the authenticated resource. Forget the user-provided credentials for the authentication realm, and go to Step 12.",
      "ja": "ステップ13（step_rcvd_init_failed）：認証は、パスワードやユーザー名が認証されたリソースのために無効である可能性があるため、何らかの理由で失敗しました。認証レルムのユーザー提供の資格情報を忘れて、ステップ12に進みます。"
    },
    {
      "indent": 3,
      "text": "Step 14 (step_rcvd_vfy): The received message is the 200-VFY-S message, which always contains a \"vks\" field. Check the validity of the received VK_s value. If it is equal to the expected value, then the mutual authentication succeeded. The client will be in the \"AUTH-SUCCEED\" status.",
      "ja": "ステップ14（step_rcvd_vfy）：受信したメッセージが常に「VKS」フィールドを含む200-VFY-Sメッセージです。受信VK_s値の妥当性を確認してください。それは期待値に等しい場合には、相互認証が成功しました。クライアントは、「AUTH-SUCCEED」の状態になります。"
    },
    {
      "indent": 7,
      "text": "An unexpected value is interpreted as a fatal communication\nerror.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If a user explicitly asks to log out (via the user interface), the client MUST forget the user's password, go to Step 5, and reload the current resource without an authentication header.",
      "ja": "ユーザーが明示的に（ユーザインタフェースを介して）ログアウトするように要求した場合、クライアントは、ユーザーのパスワードを忘れてしまった5ステップ、および認証ヘッダなしで現在のリソースを再ロードするために行かなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note 1: These transitions MAY be accepted by clients, but it is NOT RECOMMENDED that servers initiate them.",
      "ja": "注1：これらの遷移は、クライアントによって受け入れられるかもしれないが、サーバがそれらを開始することをお勧めしません。"
    },
    {
      "indent": 3,
      "text": "Figure 5 shows an informative diagram of the client state.",
      "ja": "図5は、クライアントの状態の有益な図を示しています。"
    },
    {
      "indent": 3,
      "text": "      ===========                                  -(11)------------\n      NEW REQUEST                                 ( UNAUTHENTICATED )\n      ===========                                  -----------------\n           |                                              ^ normal\n           v                                              | response\n+(1)-------------------+ NO                         +(5)----------+\n| The requested URI    |--------------------------->| send normal |\n| known to be auth'ed? |                            |   request   |\n+----------------------+                            +-------------+\n       YES |   401-INIT                            401-INIT|\n           |   with a different realm                      |\n           |          -----------------------------------. |\n           |         /                                   v v\n           |        |       -(12)------------    NO  +(6)--------+\n           |        |      ( AUTH-REQUESTED  )<------| user/pass |\n           |        |       -----------------        |   known?  |\n           |        |                                +-----------+\n           |        |                                      |YES\n           v        |                                      v\n     +(2)--------+  |                                +(7)--------+\n     | session   |  |                                | session   | NO\n NO /| available?|  |                                | available?|\\\n   / +-----------+  |                                +-----------+ |\n  /        |YES     |                                      |YES    |\n |         |       /|                                      |       |\n |         v      / |  401-                   401-         v       |\n |   +(3)--------+  |  INIT --(13)----------  INIT   +(8)--------+ |\n |   |   send    |--+----->/ AUTH-REQUESTED \\<-------|   send    | |\n |  /| req-VFY-C |  |      \\forget password /        | req-VFY-C | |\n  \\/ +-----------+ /        ----------------        /+-----------+ |\n  /\\           \\ \\/                 ^ 401-INIT     |     |401-     |\n |  ------      \\/\\  401-STALE      |              |     | STALE  /\n |        \\     /\\ -----------------+--------------+---. |       /\n |         |   /  \\                 |              |   | |      /\n |         v  /    | 401-           |       401-   |   v v     v\n |   +(4)--------+ | KEX-S1   +(10)-------+ KEX-S1 | +(9)--------+\n |   |   send    |-|--------->|   send    |<-------+-|   send    |\n | --| req-KEX-C1| |          | req-VFY-C |        | | req-KEX-C1|\n |/  +-----------+ |          +-----------+        | +-----------+\n |                 |200-VFY-S      |      200-VFY-S|       ^\n |normal           |               |200-VFY-S     /        |\n |response         |               v             / ==================\n v                  \\         -(14)---------    /  USER/PASS INPUTTED\n -(11)------------   ------->( AUTH-SUCCEED )<--   ==================\n( UNAUTHENTICATED )           --------------\n -----------------",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 5: State Diagram for Clients",
      "ja": "図5：状態図のクライアントのために"
    },
    {
      "indent": 0,
      "text": "11. Decision Procedure for Servers",
      "section_title": true,
      "ja": "サーバ11.決定手続き"
    },
    {
      "indent": 3,
      "text": "Each server SHOULD have a table of session states. This table need not be persistent over the long term; it MAY be cleared upon server restart, reboot, or for other reasons. Each entry in the table SHOULD contain at least the following information:",
      "ja": "各サーバーは、セッション状態のテーブルを持っているべきです。このテーブルには、長期的に持続的である必要はありません。これは、サーバの再起動、再起動、またはその他の理由によりクリアされます。テーブルの各エントリには、少なくとも以下の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The session identifier, which is the value of the \"sid\" parameter.",
      "ja": "「SID」パラメータの値であるセッション識別子、O。"
    },
    {
      "indent": 3,
      "text": "o The algorithm used.",
      "ja": "Oアルゴリズムが使用されます。"
    },
    {
      "indent": 3,
      "text": "o The authentication realm.",
      "ja": "認証レルムO。"
    },
    {
      "indent": 3,
      "text": "o The state of the protocol: one of \"key exchanging\", \"authenticated\", \"rejected\", or \"inactive\".",
      "ja": "プロトコルの状態○：「鍵交換」、「認証」の一つ、「拒否」、または「非アクティブ」。"
    },
    {
      "indent": 3,
      "text": "o The username received from the client.",
      "ja": "Oユーザ名は、クライアントから受け取りました。"
    },
    {
      "indent": 3,
      "text": "o A boolean flag indicating whether or not the session is fake.",
      "ja": "セッションが偽物であるか否かを示すブールフラグO。"
    },
    {
      "indent": 3,
      "text": "o When the state is \"key exchanging\", the values of K_c1 and S_s1.",
      "ja": "O状態「は交換鍵」、K_c1とS_s1の値である場合。"
    },
    {
      "indent": 3,
      "text": "o When the state is \"authenticated\", the following information:",
      "ja": "Oの状態は、以下の情報を「認証済み」されている場合："
    },
    {
      "indent": 6,
      "text": "* The value of the session secret (z).",
      "ja": "*セッションの秘密（z）の値。"
    },
    {
      "indent": 6,
      "text": "* The largest nc received from the client (largest-nc).",
      "ja": "*最大のNCは、クライアント（最大-NC）から受け取りました。"
    },
    {
      "indent": 6,
      "text": "* For each possible nc value between (largest-nc - nc-window + 1) and max_nc, a boolean flag indicating whether or not a request with the corresponding nc has been received.",
      "ja": "*（最大-NC  -  NC-ウィンドウ+ 1）との間のそれぞれの可能なNC値およびmax_nc、ブール・フラグは、対応するNCとの要求を受信したか否かを示します。"
    },
    {
      "indent": 3,
      "text": "The table MAY contain other information.",
      "ja": "テーブルには、他の情報を含んでもよいです。"
    },
    {
      "indent": 3,
      "text": "Servers SHOULD respond to the client requests according to the following procedure (see Note 1 below regarding 401-INIT messages with a plus sign):",
      "ja": "サーバーは、以下の手順（プラス記号付き401-INITメッセージについて、下の注1を参照）に応じて、クライアントの要求に応える必要があります。"
    },
    {
      "indent": 3,
      "text": "o When the server receives a \"normal request\":",
      "ja": "Oサーバは、「通常の要求」を受信した場合："
    },
    {
      "indent": 6,
      "text": "* If the requested resource is not protected by the Mutual authentication, send a \"normal response\".",
      "ja": "*要求されたリソースは、相互認証で保護されていない場合は、「正常な応答」を送信。"
    },
    {
      "indent": 6,
      "text": "* If the resource is protected by the Mutual authentication, send a 401-INIT response.",
      "ja": "リソースが相互認証により保護されている場合は*、401-INIT応答を送信します。"
    },
    {
      "indent": 3,
      "text": "o When the server receives a req-KEX-C1 request:",
      "ja": "Oサーバは、REQ-KEX-C1要求を受信します。"
    },
    {
      "indent": 6,
      "text": "* If the requested resource is not protected by the Mutual authentication, send a \"normal response\".",
      "ja": "*要求されたリソースは、相互認証で保護されていない場合は、「正常な応答」を送信。"
    },
    {
      "indent": 6,
      "text": "* If the authentication realm specified in the req-KEX-C1 request is not the expected realm, send a 401-INIT response.",
      "ja": "* REQ-KEX-C1要求で指定された認証領域401-INIT応答を送信し、期待される領域ではない場合。"
    },
    {
      "indent": 6,
      "text": "* If the server cannot validate the parameter \"kc1\", send a 401-INIT (+) response.",
      "ja": "*サーバは、パラメータ「KC1」を検証できない場合は、401-INIT（+）応答を送信します。"
    },
    {
      "indent": 6,
      "text": "* If the received username is either invalid, unknown, or unacceptable, create a new session, mark it as a \"fake\" session, compute a random value as K_s1, and send a fake 401-KEX-S1 response (see Note 2).",
      "ja": "*受信したユーザ名は、無効不明、または許容できないのいずれかである場合は、新しいセッションを作成し、「偽」のセッションとしてそれをマークし、K_s1としてランダムな値を計算し、偽の401-KEX-S1の応答を送信する（注2参照） 。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, create a new session, compute K_s1, and send a 401-KEX-S1 response. The created session is marked as not fake, and its largest-nc value is initialized to zero.",
      "ja": "*それ以外の場合は、K_s1を計算し、新しいセッションを作成し、401-KEX-S1の応答を送信します。作成されたセッションは偽物ではないとしてマークされ、その最大の-NC値はゼロに初期化されます。"
    },
    {
      "indent": 6,
      "text": "The created session is in the \"key exchanging\" state.",
      "ja": "作成されたセッションは、「キー交換」状態になっています。"
    },
    {
      "indent": 3,
      "text": "o When the server receives a req-VFY-C request:",
      "ja": "Oサーバは、REQ-VFY-C要求を受信します。"
    },
    {
      "indent": 6,
      "text": "* If the requested resource is not protected by the Mutual authentication, send a \"normal response\".",
      "ja": "*要求されたリソースは、相互認証で保護されていない場合は、「正常な応答」を送信。"
    },
    {
      "indent": 6,
      "text": "* If the authentication realm specified in the req-VFY-C request is not the expected realm, send a 401-INIT response.",
      "ja": "* REQ-VFY-C要求で指定された認証領域401-INIT応答を送信し、期待される領域ではない場合。"
    },
    {
      "indent": 6,
      "text": "If none of the above holds true, the server will look up the session corresponding to the received sid and the authentication realm.",
      "ja": "上記のいずれも成立しない場合は、サーバが受信したSIDと認証レルムに対応するセッションを検索します。"
    },
    {
      "indent": 6,
      "text": "* If the session corresponding to the received sid could not be found or it is in the \"inactive\" state, send a 401-STALE response.",
      "ja": "*受信したSIDに対応するセッションが見つかりませんでしたか、それは「非アクティブ」状態にある場合は、401-STALE応答を送信します。"
    },
    {
      "indent": 6,
      "text": "* If the session is in the \"rejected\" state, send either a 401-INIT (+) response or a 401-STALE message.",
      "ja": "*セッションが「拒否」状態にある場合、401-INIT（+）応答または401-STALEメッセージのいずれかを送信します。"
    },
    {
      "indent": 6,
      "text": "* If the nc value in the request is larger than the \"nc-max\" parameter sent from the server or it is not larger than (largest-nc - nc-window) (when in the \"authenticated\" state), the server MAY (but is not REQUIRED to; see Note 3) send a 401-STALE message. The session is changed to the \"inactive\" state if the 401-STALE message was sent.",
      "ja": "*リクエストでNC値は、サーバから送信された「NC-MAX」パラメータよりも大きくなっているか、それは（最大-NC  -  NC-ウィンドウ）より大きくない場合（「認証済み」の状態で）、サーバはMAY 401-STALEメッセージを送信する。（注3参照が、する必要はありません）。 401-STALEメッセージが送信された場合のセッションは、「非アクティブ」状態に変更されます。"
    },
    {
      "indent": 6,
      "text": "* If the session is in the \"authenticated\" state and the request has an nc value that was previously received from the client, send a 401-STALE message. The session is changed to the \"inactive\" state.",
      "ja": "*セッションが「認証済み」状態にあり、要求が以前にクライアントから受信されたNC値を有する場合、401-STALEメッセージを送信します。セッションでは、「非アクティブ」状態に変更されます。"
    },
    {
      "indent": 6,
      "text": "* If the session is a \"fake\" session or the received vkc is incorrect, then send a 401-INIT (+) response. If the session is in the \"key exchanging\" state, it MUST be changed to the \"rejected\" state; otherwise, it MAY be either changed to the \"rejected\" state or kept in the previous state.",
      "ja": "*セッションは「偽物」のセッションであるか、受信VKCが正しくない場合は、401-INIT（+）応答を送信します。セッションは、「キー交換」状態にある場合、それは「拒否」状態に変更する必要があります。それ以外の場合は、いずれかの「拒否」状態に変化したり、以前の状態に保つことができます。"
    },
    {
      "indent": 6,
      "text": "* Otherwise, send a 200-VFY-S response. If the session was in the \"key exchanging\" state, the session SHOULD be changed to the \"authenticated\" state. The maximum nc and nc flags of the state MUST be updated appropriately.",
      "ja": "*それ以外の場合は、200-VFY-S応答を送信します。セッションは、「キー交換」状態にあった場合、セッションは、「認証済み」の状態に変更する必要があります。状態の最大NCとNCフラグが適切に更新されなければなりません。"
    },
    {
      "indent": 3,
      "text": "At any time, the server MAY change any state entries with both the \"rejected\" and \"authenticated\" states to the \"inactive\" state and MAY discard any \"inactive\" states from the table. Entries with the \"key exchanging\" state SHOULD be kept unless there is an emergency situation such as a server reboot or a table capacity overflow.",
      "ja": "任意の時点で、サーバは「拒否」と「非アクティブ」状態に状態を「認証済み」と表から任意の「非アクティブ」の状態を捨てるかもしれ両方を持つ任意の状態エントリを変更することがあります。サーバーの再起動やテーブル容量のオーバーフローなどの緊急事態がない限り、「キー交換」状態とのエントリは保たれるべきです。"
    },
    {
      "indent": 3,
      "text": "Note 1: In relation to, and following the specification of, the optional authentication defined in [RFC8053], the 401-INIT messages marked with plus signs cannot be replaced with a successful response with an Optional-WWW-Authenticate header. Every other 401-INIT can be a response with an Optional-WWW-Authenticate header.",
      "ja": "関連して、[RFC8053]で定義されたオプションの認証の仕様以下、401-INITメッセージが付いたプラス記号は任意-WWW-Authenticateヘッダを持つ正常な応答に置き換えることができない。注1。すべての他の401-INITは任意-WWW-Authenticateヘッダを有する応答することができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The server SHOULD NOT send a 401-INIT response in this case, because it will leak the information to the client that the specified username will not be accepted. Instead, postpone it until the response to the next req-VFY-C request.",
      "ja": "注2：それは指定されたユーザー名が受け入れられないであろうことをクライアントに情報をリークしますので、サーバーは、この場合は401-INIT応答を送るべきではありません。代わりに、次REQ-VFY-C要求への応答まで延期。"
    },
    {
      "indent": 3,
      "text": "Note 3: If the request is not rejected in this clause, the server will be required, in the next step, to determine whether the same nc value was previously received from the client. If that is impossible, the server MUST send a 401-STALE response in this step. If the server does not remember the whole history of the nc values received from the client, the server MUST send a 401-STALE message in this clause.",
      "ja": "注3：要求がこの句に拒否されていない場合、サーバーは同じNC値が以前にクライアントから受信されたかどうかを判断するために、次のステップでは、必要となります。それが不可能な場合、サーバーは、このステップでは401-STALE応答を送らなければなりません。サーバがクライアントから受信したNC値の全体の歴史を覚えていない場合は、サーバーがこの句に401-STALEメッセージを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Authentication Algorithms",
      "section_title": true,
      "ja": "12.認証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Cryptographic authentication algorithms that are used with this protocol will be defined separately. The algorithm definition MUST at least provide definitions for the following functions:",
      "ja": "このプロトコルで使用されている暗号化認証アルゴリズムを別々に定義します。アルゴリズムの定義には、少なくとも以下の機能の定義を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The server-side authentication credential J, derived from the client-side authentication credential pi.",
      "ja": "サーバー側の認証資格J O、クライアント側の認証資格のパイ由来。"
    },
    {
      "indent": 3,
      "text": "o Key exchange values K_c1, K_s1 (exchanged on the wire) and S_c1, S_s1 (kept secret in each peer).",
      "ja": "O鍵交換K_c1、K_s1（ワイヤ上で交換）とS_c1、S_s1（各ピアにおける秘密）の値。"
    },
    {
      "indent": 3,
      "text": "o Shared session secret (z), to be computed by both server and client.",
      "ja": "O共有セッション秘密（z）は、サーバーとクライアントの両方によって計算されます。"
    },
    {
      "indent": 3,
      "text": "o A hash function H to be used with the protocol, along with its output size hSize.",
      "ja": "その出力サイズHSIZEと共に、プロトコルで使用されるハッシュ関数H O。"
    },
    {
      "indent": 3,
      "text": "o The value nIterPi, the number of iterations for the key derivation operation.",
      "ja": "値nIterPi O、キー導出演算の反復回数。"
    },
    {
      "indent": 3,
      "text": "Specifications for cryptographic algorithms used with this framework MUST specify whether those algorithms will (1) use the default functions defined below for values pi, VK_c, and VK_s or (2) define their own comparable functions.",
      "ja": "このフレームワークで使用される暗号アルゴリズムの仕様は、これらのアルゴリズムは、（1）値PI、VK_c、及びVK_sについて以下に定義されたデフォルトの機能を使用するか、（2）独自の同等の機能を定義するかどうかを指定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "All algorithms used with this protocol SHOULD provide secure mutual authentication between clients and servers and generate a cryptographically strong shared secret value (z) that is equally strong or stronger than the hash function H. If any passwords (or passphrases or any equivalents, i.e., weak secrets) are involved, these SHOULD NOT be guessable from any data transmitted in the protocol, even if an attacker (either an eavesdropper or an active server) knows the possible thoroughly searchable candidate list of passwords. Furthermore, it is RECOMMENDED that the function J for deriving the server-side authentication credential J(pi) be one-way, if possible, so that pi cannot be easily computed from J(pi).",
      "ja": "このプロトコルで使用されるすべてのアルゴリズムは、つまり、クライアントとサーバ間の安全な相互認証を提供し、任意のパスワード（またはパスフレーズまたは任意の等価物であれば同じように強いまたはハッシュ関数Hよりも強い暗号的に強力な共有秘密値（z）を生成するべきです弱い秘密）が関与している、これらは攻撃者（盗聴者またはアクティブなサーバーのいずれか）は、パスワードの可能徹底的に検索可能な候補リストを知っている場合でも、プロトコルに送信されたデータから推測するべきではありません。また、可能な場合、PIは容易J（PI）から計算することができないように、サーバ側の認証証明書J（PI）を導出する関数Jは、一方向であることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "12.1. Support Functions and Notations",
      "section_title": true,
      "ja": "12.1。サポート関数と表記"
    },
    {
      "indent": 3,
      "text": "In this section, we define several support functions and notations to be shared by several algorithm definitions.",
      "ja": "このセクションでは、我々はいくつかのアルゴリズムの定義で共有するために、いくつかのサポート機能と表記法を定義します。"
    },
    {
      "indent": 3,
      "text": "The integers in the specification are in decimal, or in hexadecimal when prefixed with \"0x\".",
      "ja": "明細書中の整数は小数であり、または16進数で「0X」が付いたとき。"
    },
    {
      "indent": 3,
      "text": "The function octet(i) generates an octet string containing a single octet of value i. The operator \"|\", when applied to octet strings, denotes the concatenation of two operands.",
      "ja": "関数オクテット（i）は、値Iの単一のオクテットを含むオクテット列を生成します。演算子「|」オクテット文字列に適用され、二つのオペランドの連結を示しています。"
    },
    {
      "indent": 3,
      "text": "The function VI encodes natural numbers into octet strings in the following manner: numbers are represented as big-endian radix-128 strings, where each digit is represented by an octet within the range 0x80-0xff, except for the last digit, which is represented by an octet within the range 0x00-0x7f. The first octet MUST NOT be 0x80. For example, VI(i) = octet(i) for i < 128, and VI(i) = octet(0x80 + (i >> 7)) | octet(i & 127) for 128 <= i < 16384. This encoding is the same as the encoding used for the subcomponents of object identifiers in ASN.1 encoding [ITU.X690.2015] and is available as a \"w\" conversion in the \"pack\" function of several scripting languages.",
      "ja": "機能VIは、以下のようにオクテットストリングに自然数をコード：数字は、各数字が示されている最後の桁を除いて、範囲0x80-0xff内のオクテットによって表されるビッグエンディアン基数128文字列として表され範囲0x00-0x7f内のオクテットによります。最初のオクテットは0x80をしているはずがありません。例えば、VI（I）=オクテット（I）I <128、およびVI（I）=オクテット（0x80からの+（I >> 7））のために| 128のためのオクテット（I＆127）<= iは、この符号化は、[ITU.X690.2015] ASN.1符号化でオブジェクト識別子のサブコンポーネントのために使用される符号化と同じであり、「W」変換として利用可能である16384を<いくつかのスクリプト言語の「パック」機能インチ"
    },
    {
      "indent": 3,
      "text": "The function VS encodes a variable-length octet string into a uniquely decoded, self-delimited octet string in the following manner:",
      "ja": "機能VSは、以下のように一意に復号された、自己区切りオクテットストリングに可変長オクテット列をコード"
    },
    {
      "indent": 3,
      "text": "VS(s) = VI(length(s)) | s",
      "ja": "VS（S）= VI（長さ（S））| S"
    },
    {
      "indent": 3,
      "text": "where length(s) is a number of octets (not characters) in s.",
      "ja": "ここで、長さ（S）はSのオクテットの数（文字ではない）です。"
    },
    {
      "indent": 3,
      "text": "Some examples:",
      "ja": "いくつかの例："
    },
    {
      "indent": 6,
      "text": "VI(0) = \"\\000\" (in C string notation)",
      "ja": "VI（0）= \"\\ 000\"（Cストリング表記）"
    },
    {
      "indent": 6,
      "text": "VI(100) = \"d\"",
      "ja": "VI（100）= \"D\""
    },
    {
      "indent": 6,
      "text": "VI(10000) = \"\\316\\020\"",
      "ja": "VI 020 \\（10000）=「\\ 316 \""
    },
    {
      "indent": 6,
      "text": "VI(1000000) = \"\\275\\204@\"",
      "ja": "VI（1000000）=「\\ 275 204 \\ @ \""
    },
    {
      "indent": 6,
      "text": "VS(\"\") = \"\\000\"",
      "ja": "VS（ \"\"）= \"\\ 000\""
    },
    {
      "indent": 6,
      "text": "VS(\"Tea\") = \"\\003Tea\"",
      "ja": "VS（ \"茶\"）= \"\\ 003Tea\""
    },
    {
      "indent": 6,
      "text": "VS(\"Caf<e acute>\" [in UTF-8]) = \"\\005Caf\\303\\251\"",
      "ja": "VS（ \"カフェ<急性E>\" [UTF-8]）= \"\\ 005Caf 251 \\ 303 \\\""
    },
    {
      "indent": 6,
      "text": "VS([10000 \"a\"s]) = \"\\316\\020aaaaa...\" (10002 octets)",
      "ja": "VS（[10000 \"\" S]）= \"\\ 316 \\ 020aaaaa ...\"（10002オクテット）"
    },
    {
      "indent": 3,
      "text": "(Note: Unlike the colon-separated format used in the Basic and Digest HTTP authentication schemes, the string generated by a concatenation of the VS-encoded strings will be unique, regardless of the characters included in the strings to be encoded.)",
      "ja": "（注：BasicおよびダイジェストHTTP認証スキームで使用されるコロン区切り形式とは異なり、VS-エンコードされた文字列を連結することによって生成された文字列が一意になり、関係なく、文字の符号化対象文字列に含まれます。）"
    },
    {
      "indent": 3,
      "text": "The function OCTETS converts an integer into the corresponding radix-256 big-endian octet string having its natural length. See Section 3.2.3 for the definition of \"natural length\".",
      "ja": "機能オクテットは、その自然長を有する対応基数256ビッグエンディアンオクテット文字列に整数に変換します。 「自然長」の定義については、3.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The function INT converts an octet string into a natural number, where the input string is treated as being in radix-256 big-endian notation. The identity INT(OCTETS(n)) = n always holds for any natural number n.",
      "ja": "関数INTは、入力された文字列が基数256ビッグエンディアン表記であるものとして扱われる自然数にオクテットストリングを変換します。アイデンティティ・INT（オクテット（N））= N常に任意の自然数nについて成り立ちます。"
    },
    {
      "indent": 0,
      "text": "12.2. Default Functions for Algorithms",
      "section_title": true,
      "ja": "12.2。アルゴリズムのデフォルトの機能"
    },
    {
      "indent": 3,
      "text": "The functions defined in this section are common default functions among authentication algorithms.",
      "ja": "このセクションで定義された関数は、認証アルゴリズムに共通するデフォルトの機能です。"
    },
    {
      "indent": 3,
      "text": "The client-side password-based (credential) pi used by this authentication is a natural number derived in the following manner:",
      "ja": "この認証によって使用されるクライアント側のパスワードベース（クレデンシャル）PIは、以下のように誘導される自然数です。"
    },
    {
      "indent": 6,
      "text": "pi = INT(PBKDF2(HMAC_H, password, VS(algorithm) | VS(auth-scope) | VS(realm) | VS(username), nIterPi, hSize / 8))",
      "ja": "PI = INT（PBKDF2（HMAC_H、パスワード、VS（アルゴリズム）| VS（AUTH-スコープ）| VS（領域）| VS（ユーザー名）、nIterPi、HSIZE / 8））"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 3,
      "text": "o PBKDF2 is the password-based key derivation function defined in [RFC8018],",
      "ja": "O PBKDF2は[RFC8018]で定義されたパスワードベースの鍵導出関数であり、"
    },
    {
      "indent": 3,
      "text": "o HMAC_H is the Hashed Message Authentication Code (HMAC) function, defined in [RFC2104], composed from the hash function H, and",
      "ja": "O HMAC_Hは、ハッシュ関数Hからなるハッシュメッセージ認証コード（HMAC）関数、[RFC2104]で定義は、であり、そして"
    },
    {
      "indent": 3,
      "text": "o hSize is the output size of hash H in bits.",
      "ja": "O HSIZEは、ビット単位でハッシュHの出力サイズです。"
    },
    {
      "indent": 3,
      "text": "The values of algorithm, realm, and auth-scope are taken from the values contained in the 401-INIT message. If the password comes from user input, it SHOULD first be prepared according to the method presented in Section 9. Then, the password SHALL be encoded as a UTF-8 string.",
      "ja": "アルゴリズム、レルム、およびAUTH-範囲の値は、401-INITメッセージに含まれる値から取られます。パスワードは、ユーザーの入力から来る場合、それは最初に続いて第9節で提示した方法に従って調製されるべきで、パスワードはUTF-8文字列として符号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The values VK_c and VK_s are derived via the following equations:",
      "ja": "値VK_cとVK_sは、以下の式を介して導出されます。"
    },
    {
      "indent": 6,
      "text": "VK_c = INT(H(octet(4) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) | VI(nc) | VS(vh)))",
      "ja": "VK_c = INT（H（オクテット（4）|オクテット（K_c1）|オクテット（K_s1）|オクテット（Z）| 6（NC）| VS（VH）））"
    },
    {
      "indent": 6,
      "text": "VK_s = INT(H(octet(3) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) | VI(nc) | VS(vh)))",
      "ja": "VK_s = INT（H（オクテット（3）|オクテット（K_c1）|オクテット（K_s1）|オクテット（Z）| 6（NC）| VS（VH）））"
    },
    {
      "indent": 0,
      "text": "13. Application Channel Binding",
      "section_title": true,
      "ja": "13.アプリケーションチャネルバインディング"
    },
    {
      "indent": 3,
      "text": "Applications and upper-layer communication protocols may need authentication binding to the HTTP-layer authenticated user. Such applications MAY use the following values as a standard shared secret.",
      "ja": "アプリケーションおよび上位層通信プロトコルは、HTTP層認証されたユーザへの結合認証を必要とするかもしれません。このようなアプリケーションは、標準の共有秘密として、以下の値を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "These values are parameterized with an optional octet string (t), which may be arbitrarily chosen by each application or protocol. If there is no appropriate value to be specified, use an empty string for t.",
      "ja": "これらの値は、任意に、各アプリケーションまたはプロトコルによって選択することができる任意のオクテットストリング（T）でパラメータ化されます。指定すべき適切な値が存在しない場合は、トンに空の文字列を使用します。"
    },
    {
      "indent": 3,
      "text": "For applications requiring binding to either an authenticated user or a shared-key session (to ensure that the requesting client is authenticated), the following value b_1 MAY be used:",
      "ja": "認証されたユーザーまたは共有セッション鍵（要求元のクライアントが認証されることを保証する）のいずれかに結合することが必要な用途のために、以下の値B_1が使用され得ます。"
    },
    {
      "indent": 6,
      "text": "b_1 = H(H(octet(6) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) | VI(0) | VS(vh)) | VS(t))",
      "ja": "B_1 = H（H（オクテット（6）|オクテット（K_c1）|オクテット（K_s1）|オクテット（Z）| VI（0）| VS（VH））| VS（t））を"
    },
    {
      "indent": 3,
      "text": "For applications requiring binding to a specific request (to ensure that the payload data is generated for the exact HTTP request), the following value b_2 MAY be used:",
      "ja": "特定の要求への結合が必要な用途のために、以下の値B_2を使用することができる（ペイロードデータは、正確なHTTPリクエストのために生成されることを確実にします）："
    },
    {
      "indent": 6,
      "text": "b_2 = H(H(octet(7) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) | VI(nc) | VS(vh)) | VS(t))",
      "ja": "B_2 = H（H（オクテット（7）|オクテット（K_c1）|オクテット（K_s1）|オクテット（Z）| 6（NC）| VS（VH））| VS（t））を"
    },
    {
      "indent": 3,
      "text": "Note: Channel bindings to lower-layer transports (TCP and TLS) are defined in Section 7.",
      "ja": "注：下層トランスポート（TCPおよびTLS）へのチャネル・バインディングはセクション7で定義されています。"
    },
    {
      "indent": 0,
      "text": "14. Application for Proxy Authentication",
      "section_title": true,
      "ja": "プロキシ認証のための14アプリケーション"
    },
    {
      "indent": 3,
      "text": "The authentication scheme defined in the previous sections can be applied (with modifications) to proxy authentication. In such cases, the following alterations MUST be applied:",
      "ja": "前のセクションで定義されている認証方式は、プロキシ認証に（変更を加えて）適用することができます。このような場合には、以下の変更が適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The 407 (Proxy Authentication Required) status code is to be sent and recognized in places where the 401 status code is used,",
      "ja": "407（プロキシ認証が必要）ステータスコード401個のステータスコードが使用される場所に送信され、認識されるべきであるO、"
    },
    {
      "indent": 3,
      "text": "o The Proxy-Authenticate header is to be used in places where the WWW-Authenticate header is used,",
      "ja": "Oプロキシ認証ヘッダは、WWW-Authenticateヘッダが使用される場所で使用されます、"
    },
    {
      "indent": 3,
      "text": "o The Proxy-Authorization header is to be used in places where the Authorization header is used,",
      "ja": "プロキシ認証ヘッダは、Authorizationヘッダが使用される場所で使用されるO、"
    },
    {
      "indent": 3,
      "text": "o The Proxy-Authentication-Info header is to be used in places where the Authentication-Info header is used,",
      "ja": "Oプロキシ認証-Infoヘッダは、認証-Infoヘッダが使用される場所で使用されます"
    },
    {
      "indent": 3,
      "text": "o The \"auth-scope\" parameter is fixed to the hostname of the proxy, which means that it covers all requests processed by the specific proxy,",
      "ja": "O「のauth-スコープ」パラメータは、それが特定のプロキシによって処理されたすべての要求をカバーすることを意味し、プロキシのホスト名、に固定されており、"
    },
    {
      "indent": 3,
      "text": "o The limitation for the paths contained in the \"path\" parameter of 401-KEX-S1 messages is disregarded,",
      "ja": "O 401-KEX-S1メッセージの「パス」パラメータに含まれるパスの制限は無視され、"
    },
    {
      "indent": 3,
      "text": "o The omission of the \"path\" parameter of 401-KEX-S1 messages means that the authentication realm will potentially cover all requests processed by the proxy,",
      "ja": "O 401-KEX-S1メッセージの「パス」パラメータの省略は、認証レルムは、潜在的に、プロキシによって処理されたすべての要求をカバーすることを意味します"
    },
    {
      "indent": 3,
      "text": "o The scheme, hostname, and port of the proxy are used for host validation tokens, and",
      "ja": "Oスキーム、ホスト名、およびプロキシのポートは、ホストの検証トークンのために使用され、"
    },
    {
      "indent": 3,
      "text": "o Authentication extensions defined in [RFC8053] are not applicable.",
      "ja": "O [RFC8053]で定義された認証拡張は適用されません。"
    },
    {
      "indent": 0,
      "text": "15. Methods to Extend This Protocol",
      "section_title": true,
      "ja": "このプロトコルを拡張するために15のメソッド"
    },
    {
      "indent": 3,
      "text": "If a private extension to this protocol is implemented, it MUST use the extension-tokens defined in Section 3 to avoid conflicts with this protocol and other extensions. (Standardized extensions, as well as extensions that are in the process of being standardized, MAY use either bare-tokens or extension-tokens.)",
      "ja": "このプロトコルにプライベート拡張が実装されている場合、それはこのプロトコルおよび他の拡張機能との競合を避けるために、第3節で定義された拡張トークンを使用しなければなりません。 （標準の拡張、ならびに標準化の過程にある拡張は、ベアトークンまたは拡張トークンも使用することができます。）"
    },
    {
      "indent": 3,
      "text": "Specifications defining authentication algorithms MAY use other representations for the parameters \"kc1\", \"ks1\", \"vkc\", and \"vks\"; replace those parameter names; and/or add parameters to the messages containing those parameters in supplemental specifications, provided that syntactic and semantic requirements in Section 3 of this document, [RFC7230], and [RFC7235] are satisfied. Any parameters starting with \"kc\", \"ks\", \"vkc\", or \"vks\" and followed by decimal natural numbers (e.g., kc2, ks0, vkc1, vks3) are reserved for this purpose. If those specifications use names other than those mentioned above, it is RECOMMENDED that extension-tokens be used to avoid any parameter-name conflicts with future extensions to this protocol.",
      "ja": "認証アルゴリズムを定義する仕様のパラメータ「KC1」、「KS1」、「VKC」、および「VKS」の他の表現を使用することができます。これらのパラメータ名に置き換えます。および/または補足仕様でそれらのパラメータを含むメッセージにパラメータを追加し、このドキュメントのセクション3、[RFC7230]及び[RFC7235]での構文と意味の要件が満たされることを条件とします。 \"KC\"、 \"KS\"、 \"VKC\"、または \"VKS\" と小数自然数、続いて始まる任意のパラメータは、（例えば、KC2、KS0、vkc1は、vks3）は、この目的のために予約されています。これらの仕様は上記以外の名前を使用する場合は、拡張トークンは、このプロトコルへの将来の拡張子を持つ任意のパラメータ名の競合を避けるために使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Extension-tokens MAY be freely used for any non-standard, private, and/or experimental uses for those parameters provided that the domain part in the token is used in the manner defined in Section 3.",
      "ja": "拡張トークンを自由トークンのドメイン部分は、セクション3で定義された方法で使用されることが提供されるパラメータの任意の非標準的、民間、及び/又は実験的用途に使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "ja": "16. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "16.1. Addition to HTTP Authentication Schemes Registry",
      "section_title": true,
      "ja": "16.1。 HTTP認証スキームのレジストリに加え"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entry to the \"HTTP Authentication Schemes\" registry:",
      "ja": "IANAは、「HTTP認証スキーム」レジストリに次のエントリを追加しました："
    },
    {
      "indent": 3,
      "text": "o Authentication Scheme Name: Mutual",
      "ja": "O認証スキーム名：相互"
    },
    {
      "indent": 3,
      "text": "o Reference: RFC 8120",
      "ja": "Oリファレンス：RFC 8120"
    },
    {
      "indent": 0,
      "text": "16.2. Registry for Authentication Algorithms",
      "section_title": true,
      "ja": "16.2。認証アルゴリズムのレジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes the \"HTTP Mutual Authentication Algorithms\" registry. The registry manages case-insensitive ASCII strings. The strings MUST follow the extensive-token syntax defined in Section 3.",
      "ja": "この文書は、「HTTP相互認証アルゴリズム」レジストリを確立します。レジストリは、大文字と小文字を区別しないASCII文字列を管理します。文字列は、第3節で定義された大規模なトークンの構文に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "When bare-tokens are used for the authentication-algorithm parameter, they MUST be allocated by IANA. To acquire registered tokens, the usage of such tokens MUST be reviewed by a Designated Expert, as outlined in [RFC5226].",
      "ja": "ベアトークンが認証アルゴリズムパラメータのために使用される場合、それらはIANAによって割り当てなければなりません。 [RFC5226]に概説されるように登録されたトークンを取得するために、そのようなトークンの使用は、指定された専門家によって検討されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Registrations for an authentication algorithm are required to include descriptions of the authentication algorithms. Reviewers assigned by the IESG are advised to examine minimum security requirements and consistency of the key exchange algorithm descriptions.",
      "ja": "認証アルゴリズムのための登録は、認証アルゴリズムの記述を含める必要があります。 IESGによって割り当てられたレビュアーは、最低限のセキュリティ要件と鍵交換アルゴリズム記述の一貫性を検討することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It is advised that new registrations provide the following information:",
      "ja": "新たな登録は、以下の情報を提供することをお勧めします："
    },
    {
      "indent": 3,
      "text": "o Token: A token used in HTTP headers for identifying the algorithm.",
      "ja": "Oトークン：アルゴリズムを識別するためのHTTPヘッダーで使用されるトークン。"
    },
    {
      "indent": 3,
      "text": "o Description: A brief description of the algorithm.",
      "ja": "O説明：アルゴリズムの簡単な説明。"
    },
    {
      "indent": 3,
      "text": "o Specification: A reference for a specification defining the algorithm.",
      "ja": "O仕様：アルゴリズムを定義する仕様の参照。"
    },
    {
      "indent": 3,
      "text": "[RFC8121] defines the initial contents of this registry.",
      "ja": "[RFC8121]は、このレジストリの初期内容を定義します。"
    },
    {
      "indent": 0,
      "text": "16.3. Registry for Validation Methods",
      "section_title": true,
      "ja": "16.3。検証方法のレジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes the \"HTTP Mutual Authentication Host Validation Methods\" registry. The registry manages case-insensitive ASCII strings. The strings MUST follow the extensive-token syntax defined in Section 3.",
      "ja": "この文書は、「HTTP相互認証ホストの検証方法」レジストリを確立します。レジストリは、大文字と小文字を区別しないASCII文字列を管理します。文字列は、第3節で定義された大規模なトークンの構文に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "When bare-tokens are used for the validation parameter, they MUST be allocated by IANA. To acquire registered tokens, the usage of such tokens MUST be reviewed by a Designated Expert, as outlined in [RFC5226].",
      "ja": "ベアトークンが検証パラメータに使用される場合、それらは、IANAによって割り当てられなければなりません。 [RFC5226]に概説されるように登録されたトークンを取得するために、そのようなトークンの使用は、指定された専門家によって検討されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Registrations for a validation method are required to include a description of the validation method. Reviewers assigned by the IESG are advised to examine its use-case requirements and any security consequences related to its introduction.",
      "ja": "検証方法のための登録は、検証方法の説明を含むことが必要です。 IESGによって割り当てられたレビューアがそのユースケースの要件とその導入に関連するセキュリティ上の影響を検討することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It is advised that new registrations provide the following information:",
      "ja": "新たな登録は、以下の情報を提供することをお勧めします："
    },
    {
      "indent": 3,
      "text": "o Token: A token used in HTTP headers for identifying the method.",
      "ja": "Oトークン：メソッドを識別するためのHTTPヘッダーで使用されるトークン。"
    },
    {
      "indent": 3,
      "text": "o Description: A brief description of the method.",
      "ja": "O説明：メソッドの簡単な説明。"
    },
    {
      "indent": 3,
      "text": "o Specification: A reference for a specification defining the method.",
      "ja": "O仕様：メソッドを定義する仕様の参照。"
    },
    {
      "indent": 3,
      "text": "The initial contents of this registry are as follows:",
      "ja": "次のようにこのレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "+----------------------+------------------------+----------------+\n| Token                | Description            | Reference      |\n+----------------------+------------------------+----------------+\n| host                 | Hostname verification  | RFC 8120,      |\n|                      | only                   | Section 7      |\n|                      |                        |                |\n| tls-server-end-point | TLS certificate-based  | RFC 8120,      |\n|                      |                        | Section 7      |\n|                      |                        |                |\n| tls-unique           | TLS unique key-based   | RFC 8120,      |\n|                      |                        | Section 7      |\n+----------------------+------------------------+----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "ja": "17.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "17.1. Security Properties",
      "section_title": true,
      "ja": "17.1。セキュリティのプロパティ"
    },
    {
      "indent": 3,
      "text": "o The protocol is secure against passive eavesdropping and replay attacks. However, the protocol relies on transport security (including DNS integrity) for data secrecy and integrity. HTTP/TLS SHOULD be used where transport security is not assured and/or data confidentiality is important.",
      "ja": "Oプロトコルは、受動的な盗聴やリプレイ攻撃に対して安全です。しかし、このプロトコルは、データの機密性と完全性のために（DNSの整合性を含む）トランスポート・セキュリティに依存しています。トランスポート・セキュリティが保証されていないおよび/またはデータの機密性が重要であるHTTP / TLSを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When used with HTTP/TLS, if TLS server certificates are reliably verified, the protocol provides true protection against active man-in-the-middle attacks.",
      "ja": "HTTP / TLSで使用する場合、TLSサーバー証明書が確実に検証された場合、O、プロトコルがアクティブman-in-the-middle攻撃に対する真の保護を提供します。"
    },
    {
      "indent": 3,
      "text": "o Even if the server certificate is not used or is unreliable, the protocol provides protection against active man-in-the-middle attacks for each HTTP request/response pair. However, in such cases, JavaScript or similar scripts that are not authenticated by this authentication mechanism can affect mutually authenticated contents to circumvent the protection. This is why this protocol stipulates that valid TLS server certificates MUST be shown from the server to the client (Section 7).",
      "ja": "サーバ証明書が使用されるか、または信頼できないれていない場合でも、O、プロトコルは、各HTTP要求/応答ペアのアクティブman-in-the-middle攻撃に対する保護を提供します。しかし、このような場合には、JavaScriptやこの認証メカニズムによって認証されていない同様のスクリプトは、保護を回避するために、相互に認証された内容に影響を与えることができます。このプロトコルは、有効なTLSサーバ証明書は、サーバからクライアント（第7節）に示されなければならないと規定している理由はここにあります。"
    },
    {
      "indent": 0,
      "text": "17.2. Secrecy of Credentials",
      "section_title": true,
      "ja": "17.2。資格情報の秘密"
    },
    {
      "indent": 3,
      "text": "The client-side password credential MUST always be kept secret and SHOULD NOT be used for any other (possibly insecure) authentication purposes. Loss of control of the credential will directly affect the control of the corresponding server-side account.",
      "ja": "クライアント側のパスワード資格情報は常に秘密にしなければならないと、他の（おそらく安全でない）認証の目的には使用しないでください。資格の制御の損失は、直接対応するサーバ側のアカウントの制御に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "The use of a client-side credential with THIS authentication scheme is always safe, even if the connected server peer is not trustworthy (e.g., a phishing scenario). However, if it is used with other authentication schemes (such as Web forms) and the recipient is rogue, the result will be obvious.",
      "ja": "この認証スキームを使用してクライアント側のクレデンシャルを使用することは、接続されたサーバピアが信頼できない場合でも、常に安全である（例えば、フィッシングシナリオ）。それは（例えば、Webフォームなど）他の認証方式を使用し、受信者が不正であるされている場合しかし、結果は明らかであろう。"
    },
    {
      "indent": 3,
      "text": "It is also important that the server-side password credential (J) be kept secret. If it is stolen and the client's choice of password is not strong, anyone who is aware of the server-side password credential can employ an offline dictionary attack to search for the client's password. However, if the client has chosen a strong password so that an attacker cannot guess the client's password from dictionary candidates, the client is still well protected from any attacks.",
      "ja": "また、サーバー側のパスワード資格（J）は秘密にすることが重要です。それが盗まれたとパスワードのクライアントの選択は強くないされている場合は、サーバー側のパスワードの資格情報を知っている誰もがクライアントのパスワードを検索するためにオフライン辞書攻撃を用いることができます。攻撃者は、辞書候補の中から、クライアントのパスワードを推測できないように、クライアントは強力なパスワードを選択した場合は、クライアントはまだよくあらゆる攻撃から保護されています。"
    },
    {
      "indent": 3,
      "text": "The shared session secret (z) MUST be kept secret inside the server/client software; if it is lost and the session is still active, session hijacking will result. After the session expires, the key is of no value to attackers.",
      "ja": "共有セッションの秘密（z）は、サーバ/クライアントソフトウェアの内部で秘密にしなければなりません。それが失われ、セッションがまだアクティブである場合、セッションハイジャックが発生します。セッションの有効期限が切れた後、鍵が攻撃者に無価値です。"
    },
    {
      "indent": 0,
      "text": "17.3. Denial-of-Service Attacks on Servers",
      "section_title": true,
      "ja": "17.3。サーバー上のサービス拒否攻撃"
    },
    {
      "indent": 3,
      "text": "The protocol requires a server-side table of active sessions, which may become a critical point for server resource consumption. For proper operation, the protocol requires that at least one key verification request be processed for each session identifier. After that, servers MAY discard sessions internally at any time without causing any operational problems for clients. Clients will then silently re-establish a new session.",
      "ja": "プロトコルは、サーバリソース消費のための重要なポイントになる可能性がある、アクティブなセッションのサーバ側テーブルを必要とします。適切な動作のために、プロトコルは、少なくとも1つのキー確認要求は、各セッション識別子のために処理されることを必要とします。その後、サーバーは、クライアントのための任意の操作上の問題を引き起こすことなく、内部でいつでもセッションを捨てるかもしれ。クライアントはその後、静かに新しいセッションを再確立します。"
    },
    {
      "indent": 3,
      "text": "However, if a malicious client sends too many requests for key exchanges (req-KEX-C1 messages) only, resource starvation might occur. In such critical situations, servers MAY discard any kind of existing sessions, regardless of their statuses. One way to mitigate such attacks is that servers MAY set number and time limits for unverified, pending key exchange requests (in the \"key exchanging\" state).",
      "ja": "悪意のあるクライアントが鍵交換のためにあまりにも多くの要求（REQ-KEX-C1メッセージ）のみを送信した場合ただし、リソース不足が発生することがあります。こうした危機的な状況では、サーバは関係なく、そのステータスの、既存のセッションのいずれかの種類を捨てるかもしれ。このような攻撃を緩和する一つの方法は、サーバが（「キー交換」状態の）鍵交換要求を保留し、未検証のための数や時間制限を設定することです。"
    },
    {
      "indent": 3,
      "text": "This is a common weakness of authentication protocols with almost any kind of negotiations or states, including the Digest authentication scheme and most cookie-based authentication implementations. However, regarding resource consumption, the situation for the Mutual authentication scheme is slightly better than that for Digest, because HTTP requests without any kind of authentication requests will not generate any kind of sessions. Session identifiers are only generated after a client starts a key negotiation, so that simple clients such as Web crawlers will not accidentally consume server-side resources for session management.",
      "ja": "これは、ダイジェスト認証スキームと最もクッキーベースの認証の実装を含む交渉や状態のほとんどすべての種類、との認証プロトコルの一般的な弱点です。認証要求のいずれかの種類せずにHTTPリクエストがセッションのいずれかの種類を生成しませんので、しかし、リソース消費量については、相互認証スキームの状況は、ダイジェストのそれよりも若干良好です。クライアントは、キーのネゴシエーションを開始した後、このようなウェブクローラなどの簡単なクライアントが誤ってセッション管理用サーバ側のリソースを消費しないように、セッション識別子は、生成されます。"
    },
    {
      "indent": 0,
      "text": "17.3.1. Online Active Password Attacks",
      "section_title": true,
      "ja": "17.3.1。オンラインアクティブなパスワード攻撃"
    },
    {
      "indent": 3,
      "text": "Although the protocol provides very strong protection against offline dictionary attacks from eavesdropped traffic, the protocol, by its nature, cannot prevent active password attacks in which an attacker sends so many authentication trial requests for every possible password.",
      "ja": "プロトコルは盗聴トラフィックからオフライン辞書攻撃に対して非常に強力な保護を提供しますが、プロトコルは、その性質により、攻撃者は、すべての可能なパスワードのために非常に多くの認証試験の要求を送信するアクティブなパスワード攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "Possible countermeasures for preventing such attacks may be the rate-limiting of password authentication trials, statistics-based intrusion-detection measures, or similar protection schemes. If the server operators assume that the passwords of users are not strong enough, it may be desirable to introduce such ad hoc countermeasures.",
      "ja": "このような攻撃を防ぐための可能性のある対策が律速パスワード認証試験、統計ベースの侵入検知対策、または類似の保護スキームのかもしれません。サーバーオペレータは、ユーザーのパスワードが十分に強くないと仮定した場合、そのようなアドホックな対策を導入することが望ましい場合があります。"
    },
    {
      "indent": 0,
      "text": "17.4. Communicating the Status of Mutual Authentication with Users",
      "section_title": true,
      "ja": "17.4。ユーザーとの相互認証の状況を伝えます"
    },
    {
      "indent": 3,
      "text": "This protocol is designed with two goals in mind. The first goal is simply to provide a secure alternative to existing Basic and Digest authentication schemes. The second goal is to provide users with a way to detect forged rogue servers imitating (e.g., via a phishing attack) a user's registered account on a server.",
      "ja": "このプロトコルは、心の中で2つのゴールで設計されています。最初の目標は、既存の基本とダイジェスト認証スキームへの安全な代替手段を提供することです。第二の目標は、サーバー上で（フィッシング攻撃を経由して、例えば）偽造、不正なサーバの模倣を検出する方法でユーザーの登録アカウントをユーザーに提供することです。"
    },
    {
      "indent": 3,
      "text": "For this protocol to effectively work as a countermeasure against such attacks, it is very important that end users of clients be notified of the result of mutual authentication performed by this protocol, especially the three states \"AUTH-SUCCEED\", \"AUTH-REQUIRED\", and \"UNAUTHENTICATED\" as defined in Section 10. The design of secure user interfaces for HTTP interactive clients is out of scope for this document, but if possible, having some kind of UI indication for the three states above will be desirable from the standpoint of providing user security.",
      "ja": "効果的な攻撃に対する対策として機能するには、このプロトコルの場合、クライアントのエンドユーザーが「AUTH-REQUIRED」、特に三つの状態「AUTH-SUCCEED」、このプロトコルによって行われる相互認証の結果が通知されることが非常に重要です節10に定義されるようにHTTP対話クライアントのセキュアなユーザインターフェイスの設計は、この文書の範囲外であるが、可能な場合、上記3つの状態のためのUI表示のいくつかの種類を有する観点からは望ましいであろう、そして「UNAUTHENTICATED」ユーザーのセキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "Of course, in such cases, the user interfaces for requesting passwords for this authentication shall be protected against imitation (for example, by other insecure password input fields, such as forms). If the passwords are known to malicious attackers outside of the protocol, the protocol cannot work as an effective security measure.",
      "ja": "もちろん、そのような場合には、この認証のためのパスワードを要求するためのユーザインタフェースを模倣から保護されなければならない（例えば、このような形態のような他の安全でないパスワード入力フィールドによって）。パスワードは、プロトコルの外悪意のある攻撃者に知られている場合は、プロトコルは、効果的なセキュリティ対策として動作することはできません。"
    },
    {
      "indent": 0,
      "text": "17.5. Implementation Considerations",
      "section_title": true,
      "ja": "17.5。実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "o To securely implement the protocol, the Authentication-Info headers in the 200-VFY-S messages MUST always be validated by the client. If the validation fails, the client MUST NOT process any content sent with the message, including other headers and the body part. Non-compliance with this requirement will allow phishing attacks.",
      "ja": "安全プロトコルを実装するためにoは、200-VFY-Sメッセージでの認証、情報のヘッダは常にクライアントによって検証されなければなりません。検証が失敗した場合、クライアントは、他のヘッダとボディ部を含むメッセージで送信されたコンテンツを、処理してはいけません。この要件の不遵守は、フィッシング攻撃できるようになります。"
    },
    {
      "indent": 3,
      "text": "o For HTTP/TLS communications, when a Web form is submitted from mutually authenticated pages via the \"tls-server-end-point\" validation method to a URI that is protected by the same realm (so indicated by the \"path\" parameter), if the server certificate has been changed since the pages were received, it is RECOMMENDED that the peer be revalidated using a req-KEX-C1 message with an \"Expect: 100-continue\" header. The same applies when the page is received via the \"tls-unique\" validation method and when the TLS session has expired.",
      "ja": "OについてHTTP / TLS通信、ウェブフォームが（いわゆる「パス」パラメータによって示される）と同じレルムで保護されているURIに「TLSサーバエンドポイント」検証方法を介して相互に認証ページから送信されたとき「100-続ける期待」ヘッダページが受信されたため、サーバ証明書が変更された場合、ピアが有するREQ-KEX-C1のメッセージを使用して再検証されることが推奨されます。同じページが、「TLS-ユニークな」検証メソッドを介して受信されると、TLSセッションの有効期限が切れているときときに適用されます。"
    },
    {
      "indent": 3,
      "text": "o For better protection against possible password database stealing, server-side storage of user passwords should contain the values encrypted by the one-way function J(pi) instead of the real passwords or those hashed by pi.",
      "ja": "Oの可能なパスワードデータベースの盗用に対するより良い保護のために、ユーザパスワードのサーバ側のストレージは、一方向関数J（PI）によって暗号化された値の代わりに、実際のパスワードやパイでハッシュ化されたものが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o If TLS 1.2 [RFC5246] is used for underlying HTTP/TLS communications, follow the best practices specified in [RFC7525].",
      "ja": "TLS 1.2 [RFC5246]はHTTP / TLS通信の基礎をなすために使用されている場合は、O、[RFC7525]で指定されたベストプラクティスに従ってください。"
    },
    {
      "indent": 0,
      "text": "17.6. Usage Considerations",
      "section_title": true,
      "ja": "17.6。使用に関する注意事項"
    },
    {
      "indent": 3,
      "text": "o The usernames inputted by a user may be sent automatically to any servers sharing the same auth-scope. This means that when a host-type auth-scope is used for authentication on an HTTPS site and an HTTP server on the same host requests the Mutual authentication scheme within the same realm, the client will send the username in clear text. If usernames have to be kept secret (protected from eavesdroppers), the server must use the full-scheme-type \"auth-scope\" parameter and HTTPS. Passwords, on the other hand, are not exposed to eavesdroppers, even in HTTP requests.",
      "ja": "Oユーザにより入力されたユーザ名は、同一のAUTHスコープを共有する任意のサーバに自動的に送信することができます。これは、ホスト型のauth-範囲は、HTTPSサイトでの認証に使用され、同じホスト上のHTTPサーバは、同じ領域内の相互認証方式を要求されている場合、クライアントはクリアテキストでのユーザ名を送信することを意味します。ユーザ名は、（盗聴から保護）秘密にする必要がある場合は、サーバーは、フルスキーム型「のauth-スコープ」パラメータおよびHTTPSを使用する必要があります。パスワードは、他の一方で、でも、HTTPリクエストで、盗聴者には公開されません。"
    },
    {
      "indent": 3,
      "text": "o If the server provides several ways to store server-side password secrets in the password database, it is desirable, for purposes of better security, to store the values encrypted by using the one-way function J(pi) instead of the real passwords or those hashed by pi.",
      "ja": "サーバがパスワードデータベース内のサーバー側のパスワードの秘密を格納するためのいくつかの方法を提供している場合は、O、それは代わりに、実際のパスワードの一方向関数J（PI）を使用して暗号化された値を保存するために、セキュリティを強化する目的で、望ましいですパイでハッシュ化されたものか。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "ja": "18.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<HTTP：//www.rfc-editor .ORG /情報/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed., and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "\"構文仕様のための増大しているBNF：ABNF\" [RFC5234]クロッカー、D.、エド、およびP. Overell、。、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<のhttp：//www.rfc-editor .ORG /情報/ RFC5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5987] Reschke, J., \"Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters\", RFC 5987, DOI 10.17487/RFC5987, August 2010, <http://www.rfc-editor.org/info/rfc5987>.",
      "ja": "[RFC5987] Reschke、J.、 \"文字セットおよび言語エンコーディング転送プロトコル（HTTP）ヘッダフィールドパラメータハイパーテキストのための\"、RFC 5987、DOI 10.17487 / RFC5987、2010年8月、<http://www.rfc-editor.org/情報/ rfc5987>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"。。、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<HTTP：/ /www.rfc-editor.org/info/rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"。。、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<HTTP：// WWW。 rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7613] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 7613, DOI 10.17487/RFC7613, August 2015, <http://www.rfc-editor.org/info/rfc7613>.",
      "ja": "[RFC7613]サンアンドレ、P.およびA.メルニコフ、 \"準備、施行、およびユーザ名とパスワードを表現する国際化された文字列の比較\"、RFC 7613、DOI 10.17487 / RFC7613、2015年8月、<のhttp：//www.rfc- editor.org/info/rfc7613>。"
    },
    {
      "indent": 3,
      "text": "[RFC7615] Reschke, J., \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\", RFC 7615, DOI 10.17487/RFC7615, September 2015, <http://www.rfc-editor.org/info/rfc7615>.",
      "ja": "[RFC7615] Reschke、J.、 \"HTTP認証-INFOとプロキシ認証-INFO応答ヘッダフィールド\"、RFC 7615、DOI 10.17487 / RFC7615、2015年9月、<http://www.rfc-editor.org/info/ rfc7615>。"
    },
    {
      "indent": 3,
      "text": "[RFC8018] Moriarty, K., Ed., Kaliski, B., and A. Rusch, \"PKCS #5: Password-Based Cryptography Specification Version 2.1\", RFC 8018, DOI 10.17487/RFC8018, January 2017, <http://www.rfc-editor.org/info/rfc8018>.",
      "ja": "[RFC8018]モリアーティ、K.、エド、Kaliski、B.、およびA.ラッシュ、 \"PKCS＃5：パスワードベースの暗号化仕様バージョン2.1\"、RFC 8018、DOI 10.17487 / RFC8018、2017年1月、<のhttp：/ /www.rfc-editor.org/info/rfc8018>。"
    },
    {
      "indent": 3,
      "text": "[RFC8053] Oiwa, Y., Watanabe, H., Takagi, H., Maeda, K., Hayashi, T., and Y. Ioku, \"HTTP Authentication Extensions for Interactive Clients\", RFC 8053, DOI 10.17487/RFC8053, January 2017, <http://www.rfc-editor.org/info/rfc8053>.",
      "ja": "[RFC8053]大岩、Y.、渡辺、H.、高木、H.、前田、K.、林、T.、およびY. Ioku、 \"HTTP対話クライアントの認証拡張\"、RFC 8053、DOI 10.17487 / RFC8053、 2017年1月、<http://www.rfc-editor.org/info/rfc8053>。"
    },
    {
      "indent": 3,
      "text": "[Unicode] The Unicode Consortium, \"The Unicode Standard\", <http://www.unicode.org/versions/latest/>.",
      "ja": "[UNICODE]ユニコードコンソーシアム、 \"Unicode規格\"、<http://www.unicode.org/versions/latest/>。"
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "ja": "18.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ITU.X690.2015] International Telecommunication Union, \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, ISO/IEC 8825-1, August 2015, <https://www.itu.int/rec/T-REC-X.690/>.",
      "ja": "[ITU.X690.2015]国際電気通信連合、 \"情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）の仕様\"、ITU-T勧告X 0.690、ISO / IEC 8825から1、2015年8月、<https://www.itu.int/rec/T-REC-X.690/>。"
    },
    {
      "indent": 3,
      "text": "[RFC1939] Myers, J. and M. Rose, \"Post Office Protocol - Version 3\", STD 53, RFC 1939, DOI 10.17487/RFC1939, May 1996, <http://www.rfc-editor.org/info/rfc1939>.",
      "ja": "[RFC1939]マイヤーズ、J.とM.ローズ、 \"ポストオフィスプロトコル - バージョン3\"、STD 53、RFC 1939、DOI 10.17487 / RFC1939、1996年5月、<http://www.rfc-editor.org/info/ RFC1939>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <http://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, DOI 10.17487/RFC5890, August 2010, <http://www.rfc-editor.org/info/rfc5890>.",
      "ja": "[RFC5890] Klensin、J.、 \"アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク\"、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、<http://www.rfc-editor.org/info/ rfc5890>。"
    },
    {
      "indent": 3,
      "text": "[RFC5929] Altman, J., Williams, N., and L. Zhu, \"Channel Bindings for TLS\", RFC 5929, DOI 10.17487/RFC5929, July 2010, <http://www.rfc-editor.org/info/rfc5929>.",
      "ja": "[RFC5929]アルトマン、J.、ウィリアムズ、N.、およびL.朱、 \"TLSのチャネルバインディング\"、RFC 5929、DOI 10.17487 / RFC5929、2010年7月、<http://www.rfc-editor.org/info / rfc5929>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、DOI 10.17487 / RFC6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド、およびJ. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"。。、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<のhttp：// www.rfc-editor.org/info/rfc7231>。"
    },
    {
      "indent": 3,
      "text": "[RFC7486] Farrell, S., Hoffman, P., and M. Thomas, \"HTTP Origin-Bound Authentication (HOBA)\", RFC 7486, DOI 10.17487/RFC7486, March 2015, <http://www.rfc-editor.org/info/rfc7486>.",
      "ja": "[RFC7486]ファレル、S.、ホフマン、P.、およびM.トーマス、 \"HTTP原点結合した認証（HOBA）\"、RFC 7486、DOI 10.17487 / RFC7486、2015年3月、<HTTP：//www.rfc-editor .ORG /情報/ rfc7486>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <http://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\"、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<http://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7616] Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, \"HTTP Digest Access Authentication\", RFC 7616, DOI 10.17487/RFC7616, September 2015, <http://www.rfc-editor.org/info/rfc7616>.",
      "ja": "[RFC7616] Shekh・ユセフ、R.、エド、アーレンス、D.、およびS.ブレマー、 \"HTTPダイジェストアクセス認証\"、RFC 7616、DOI 10.17487 / RFC7616、2015年9月、<のhttp：。//www.rfc- editor.org/info/rfc7616>。"
    },
    {
      "indent": 3,
      "text": "[RFC7627] Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A., Langley, A., and M. Ray, \"Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension\", RFC 7627, DOI 10.17487/RFC7627, September 2015, <http://www.rfc-editor.org/info/rfc7627>.",
      "ja": "[RFC7627] Bhargavan、K.、エド。、Delignat-Lavaud、A.、Pironti、A.、ラングレー、A.、およびM.レイ、 \"トランスポート層セキュリティ（TLS）セッションハッシュおよび拡張マスターシークレット拡張\"、RFC 7627、DOI 10.17487 / RFC7627、2015年9月、<http://www.rfc-editor.org/info/rfc7627>。"
    },
    {
      "indent": 3,
      "text": "[RFC8121] Oiwa, Y., Watanabe, H., Takagi, H., Maeda, K., Hayashi, T., and Y. Ioku, \"Mutual Authentication Protocol for HTTP: Cryptographic Algorithms Based on the Key Agreement Mechanism 3 (KAM3)\", RFC 8121, DOI 10.17487/RFC8121, April 2017, <http://www.rfc-editor.org/info/rfc8121>.",
      "ja": "HTTPのために[RFC8121]大岩、Y.、渡辺、H.、高木、H.、前田、K.、林、T.、およびY. Ioku、「相互認証プロトコル：鍵共有機構3に基づいて、暗号化アルゴリズム（ KAM3）」、RFC 8121、DOI 10.17487 / RFC8121、2017年4月、<http://www.rfc-editor.org/info/rfc8121>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yutaka Oiwa National Institute of Advanced Industrial Science and Technology Information Technology Research Institute Tsukuba Central 1 1-1-1 Umezono Tsukuba-shi, Ibaraki Japan Email: y.oiwa@aist.go.jp",
      "ja": "産業技術総合研究所情報技術の豊大岩国立研究所つくば中央1 1-1-1梅園つくば市、茨城県、日本のEメール：y.oiwa@aist.go.jp"
    },
    {
      "indent": 3,
      "text": "Hajime Watanabe National Institute of Advanced Industrial Science and Technology Information Technology Research Institute Tsukuba Central 1 1-1-1 Umezono Tsukuba-shi, Ibaraki Japan Email: h-watanabe@aist.go.jp",
      "ja": "産業技術総合研究所情報技術つくば中央1 1-1-1梅園つくば市、茨城県、日本の渡辺創研究所Eメール：h-watanabe@aist.go.jp"
    },
    {
      "indent": 3,
      "text": "Hiromitsu Takagi National Institute of Advanced Industrial Science and Technology Information Technology Research Institute Tsukuba Central 1 1-1-1 Umezono Tsukuba-shi, Ibaraki Japan Email: takagi.hiromitsu@aist.go.jp",
      "ja": "takagi.hiromitsu@aist.go.jp：産業技術総合研究所情報技術つくば中央1 1-1-1梅園つくば市、茨城県、日本の電子メールの高木浩光国立研究所"
    },
    {
      "indent": 3,
      "text": "Kaoru Maeda Individual Contributor Email: kaorumaeda.ml@gmail.com",
      "ja": "薫前田投稿者メールアドレス：kaorumaeda.ml@gmail.com"
    },
    {
      "indent": 3,
      "text": "Tatsuya Hayashi Lepidum Co. Ltd. Village Sasazuka 3, Suite #602 1-30-3 Sasazuka Shibuya-ku, Tokyo Japan Email: hayashi@lepidum.co.jp",
      "ja": "たつや はやし ぇぴづｍ こ。 Ｌｔｄ。 ゔぃっぁげ ささずか ３、 すいて ＃６０２ １ー３０ー３ ささずか しぶやーく、 ときょ じゃぱん えまいｌ： はやし＠ぇぴづｍ。こ。ｊｐ"
    },
    {
      "indent": 3,
      "text": "Yuichi Ioku Individual Contributor Email: mutual-work@ioku.org",
      "ja": "雄一乗客投稿者のメール：mutual-work@ioku.org"
    }
  ]
}