{
  "title": {
    "text": "RFC 8166 - Remote Direct Memory Access Transport for Remote Procedure Call Version 1",
    "ja": "RFC 8166 - リモートプロシージャコールバージョン1用のリモートダイレクトメモリアクセス交通"
  },
  "number": 8166,
  "created_at": "2019-10-24 06:21:28.589501+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     C. Lever, Ed.\nRequest for Comments: 8166                                        Oracle\nObsoletes: 5666                                               W. Simpson\nCategory: Standards Track                                        Red Hat\nISSN: 2070-1721                                                T. Talpey\n                                                               Microsoft\n                                                               June 2017",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Remote Direct Memory Access Transport for\n     Remote Procedure Call Version 1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a protocol for conveying Remote Procedure Call (RPC) messages on physical transports capable of Remote Direct Memory Access (RDMA). This protocol is referred to as the RPC-over-RDMA version 1 protocol in this document. It requires no revision to application RPC protocols or the RPC protocol itself. This document obsoletes RFC 5666.",
      "ja": "この文書では、リモートプロシージャコール（RPC）リモートダイレクトメモリアクセス（RDMA）できる物理トランスポートにメッセージを伝達するためのプロトコルを指定します。このプロトコルは、この文書に記載されているRPCオーバーRDMAバージョン1つのプロトコルと呼ばれています。これは、アプリケーションのRPCプロトコルまたはRPCプロトコル自体への改正を必要としません。この文書はRFC 5666を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8166.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8166で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  RPCs on RDMA Transports . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n  2.2.  RPCs  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  2.3.  RDMA  . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n3.  RPC-over-RDMA Protocol Framework  . . . . . . . . . . . . . .  10\n  3.1.  Transfer Models . . . . . . . . . . . . . . . . . . . . .  10\n  3.2.  Message Framing . . . . . . . . . . . . . . . . . . . . .  11\n  3.3.  Managing Receiver Resources . . . . . . . . . . . . . . .  11\n  3.4.  XDR Encoding with Chunks  . . . . . . . . . . . . . . . .  14\n  3.5.  Message Size  . . . . . . . . . . . . . . . . . . . . . .  19\n4.  RPC-over-RDMA in Operation  . . . . . . . . . . . . . . . . .  23\n  4.1.  XDR Protocol Definition . . . . . . . . . . . . . . . . .  23\n  4.2.  Fixed Header Fields . . . . . . . . . . . . . . . . . . .  28\n  4.3.  Chunk Lists . . . . . . . . . . . . . . . . . . . . . . .  30\n  4.4.  Memory Registration . . . . . . . . . . . . . . . . . . .  33\n  4.5.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  34\n  4.6.  Protocol Elements No Longer Supported . . . . . . . . . .  37\n  4.7.  XDR Examples  . . . . . . . . . . . . . . . . . . . . . .  38\n5.  RPC Bind Parameters . . . . . . . . . . . . . . . . . . . . .  39\n6.  ULB Specifications  . . . . . . . . . . . . . . . . . . . . .  41\n  6.1.  DDP-Eligibility . . . . . . . . . . . . . . . . . . . . .  41\n  6.2.  Maximum Reply Size  . . . . . . . . . . . . . . . . . . .  43\n  6.3.  Additional Considerations . . . . . . . . . . . . . . . .  43\n  6.4.  ULP Extensions  . . . . . . . . . . . . . . . . . . . . .  43\n7.  Protocol Extensibility  . . . . . . . . . . . . . . . . . . .  44\n  7.1.  Conventional Extensions . . . . . . . . . . . . . . . . .  44\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  44\n  8.1.  Memory Protection . . . . . . . . . . . . . . . . . . . .  44\n  8.2.  RPC Message Security  . . . . . . . . . . . . . . . . . .  46\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  49\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  50\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  50\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  51\nAppendix A.  Changes from RFC 5666  . . . . . . . . . . . . . . .  53\n  A.1.  Changes to the Specification  . . . . . . . . . . . . . .  53\n  A.2.  Changes to the Protocol . . . . . . . . . . . . . . . . .  53\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  54\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  55",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies the RPC-over-RDMA version 1 protocol, based on existing implementations of RFC 5666 and experience gained through deployment. This document obsoletes RFC 5666.",
      "ja": "この文書は、展開を通じて得たRFC 5666や経験の既存の実装に基づいて、RPCオーバーRDMAバージョン1プロトコルを指定します。この文書はRFC 5666を廃止します。"
    },
    {
      "indent": 3,
      "text": "This specification clarifies text that was subject to multiple interpretations and removes support for unimplemented RPC-over-RDMA version 1 protocol elements. It clarifies the role of Upper-Layer Bindings (ULBs) and describes what they are to contain.",
      "ja": "この仕様は、複数の解釈の対象であり、実装されていないRPCオーバーRDMAバージョン1プロトコル要素のためのサポートを削除したテキストを明確。これは、上位層のバインディング（ULBs）の役割を明確にし、それらが含まれているものを説明します。"
    },
    {
      "indent": 3,
      "text": "In addition, this document describes current practice using RPCSEC_GSS [RFC7861] on RDMA transports.",
      "ja": "また、この文書は、RDMAトランスポートにRPCSEC_GSS [RFC7861]を使用して、現在の練習を説明しています。"
    },
    {
      "indent": 3,
      "text": "The protocol version number has not been changed because the protocol specified in this document fully interoperates with implementations of the RPC-over-RDMA version 1 protocol specified in [RFC5666].",
      "ja": "本書で指定されたプロトコルが完全に[RFC5666]で指定されたRPCオーバーRDMAバージョン1プロトコルの実装と相互運用するためのプロトコルバージョン番号が変更されていません。"
    },
    {
      "indent": 0,
      "text": "1.1. RPCs on RDMA Transports",
      "section_title": true,
      "ja": "1.1。 RDMAトランスポート上のRPC"
    },
    {
      "indent": 3,
      "text": "RDMA [RFC5040] [RFC5041] [IBARCH] is a technique for moving data efficiently between end nodes. By directing data into destination buffers as it is sent on a network, and placing it via direct memory access by hardware, the benefits of faster transfers and reduced host overhead are obtained.",
      "ja": "RDMA [RFC5040]、[RFC5041]は[IBARCH】エンドノード間でデータを効率的に移動させるための技術です。それはネットワーク上で送信される宛先バッファにデータを向けると、ハードウェアによって直接メモリアクセスを介して、それを配置することにより、高速転送と減少ホストのオーバーヘッドの利点が得られます。"
    },
    {
      "indent": 3,
      "text": "Open Network Computing Remote Procedure Call (ONC RPC, often shortened in NFSv4 documents to RPC) [RFC5531] is a remote procedure call protocol that runs over a variety of transports. Most RPC implementations today use UDP [RFC768] or TCP [RFC793]. On UDP, RPC messages are encapsulated inside datagrams, while on a TCP byte stream, RPC messages are delineated by a record marking protocol. An RDMA transport also conveys RPC messages in a specific fashion that must be fully described if RPC implementations are to interoperate.",
      "ja": "オープンネットワークコンピューティングリモートプロシージャコール（RPCしばしばへのNFSv4文書に短縮ONC RPC）[RFC5531]はトランスポートのさまざま上で実行するリモート・プロシージャ・コール・プロトコルです。ほとんどのRPCの実装今日はUDP [RFC768]やTCP [RFC793]を使用します。 TCPのバイトストリーム上で、RPCメッセージが記録マーキングプロトコルによって描写されている間、UDPで、RPCメッセージは、データグラムの中にカプセル化します。 RDMA輸送も、RPCの実装が相互運用するためであれば十分に説明しなければならない特定の方法でRPCメッセージを伝えます。"
    },
    {
      "indent": 3,
      "text": "RDMA transports present semantics that differ from either UDP or TCP. They retain message delineations like UDP but provide reliable and sequenced data transfer like TCP. They also provide an offloaded bulk transfer service not provided by UDP or TCP. RDMA transports are therefore appropriately viewed as a new transport type by RPC.",
      "ja": "RDMAは、UDPまたはTCP異なる存在の意味を運びます。彼らは、UDPのようなメッセージの描写を保持するが、TCPのような信頼性の高い、配列決定データ転送を提供します。彼らはまた、UDPまたはTCPによって提供されていないオフロードバルク転送サービスを提供しています。 RDMAトランスポートは、したがって、適切にRPCで新しいトランスポートタイプとして表示されます。"
    },
    {
      "indent": 3,
      "text": "In this context, the Network File System (NFS) protocols, as described in [RFC1094], [RFC1813], [RFC7530], [RFC5661], and future NFSv4 minor versions, are all obvious beneficiaries of RDMA transports. A complete problem statement is presented in [RFC5532]. Many other RPC-based protocols can also benefit.",
      "ja": "[RFC1094]、[RFC1813]、[RFC7530]、[RFC5661]、および将来のNFSv4マイナーバージョンに記載されているように、この文脈では、ネットワークファイルシステム（NFS）プロトコル、RDMAの全て明らか受益者が搬送されます。完全問題文は、[RFC5532]に提示されています。他の多くのRPCベースのプロトコルも恩恵を受けることができます。"
    },
    {
      "indent": 3,
      "text": "Although the RDMA transport described herein can provide relatively transparent support for any RPC application, this document also describes mechanisms that can optimize data transfer even further, when RPC applications are willing to exploit awareness of RDMA as the transport.",
      "ja": "本明細書に記載のRDMA転送は、任意のRPCアプリケーションに対して比較的透明な支持体を提供することができるが、この文書はまた、RPCアプリケーションがトランスポートとしてRDMAの意識を利用して喜んでである場合、さらにデータ転送を最適化することができる機構を記載しています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2.2. RPCs",
      "section_title": true,
      "ja": "2.2。 RPC"
    },
    {
      "indent": 3,
      "text": "This section highlights key elements of the RPC [RFC5531] and External Data Representation (XDR) [RFC4506] protocols, upon which RPC-over-RDMA version 1 is constructed. Strong grounding with these protocols is recommended before reading this document.",
      "ja": "このセクションでは、キーRPC [RFC5531]の要素とRPCオーバーRDMAバージョン1が構築される際に、外部データ表現（XDR）[RFC4506]プロトコルを、強調しています。これらのプロトコルとの強力な接地は、このドキュメントを読む前にお勧めします。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Upper-Layer Protocols",
      "section_title": true,
      "ja": "2.2.1。上位層プロトコル"
    },
    {
      "indent": 3,
      "text": "RPCs are an abstraction used to implement the operations of an Upper-Layer Protocol (ULP). \"ULP\" refers to an RPC Program and Version tuple, which is a versioned set of procedure calls that comprise a single well-defined API. One example of a ULP is the Network File System Version 4.0 [RFC7530].",
      "ja": "RPCは上位層プロトコル（ULP）の動作を実現するために使用される抽象化です。 「ULP」は、単一の明確に定義されたAPIを含むプロシージャ・コールのバージョンセットであるRPCプログラムとバージョンタプルを指します。 ULPの一例は、ネットワークファイルシステムバージョン4.0 [RFC7530]です。"
    },
    {
      "indent": 3,
      "text": "In this document, the term \"RPC consumer\" refers to an implementation of a ULP running on an RPC client endpoint.",
      "ja": "この文書では、用語「RPCの消費者は、」RPCクライアントエンドポイント上で実行されているULPの実装を指します。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Requesters and Responders",
      "section_title": true,
      "ja": "2.2.2。リクエスタとレスポンダ"
    },
    {
      "indent": 3,
      "text": "Like a local procedure call, every RPC procedure has a set of \"arguments\" and a set of \"results\". A calling context invokes a procedure, passing arguments to it, and the procedure subsequently returns a set of results. Unlike a local procedure call, the called procedure is executed remotely rather than in the local application's execution context.",
      "ja": "ローカルプロシージャコールと同じように、すべてのRPCの手順は、「引数」のセットと「結果」のセットを持っています。呼び出しコンテキストがそれに引数を渡す、プロシージャを起動し、手順がその後に結果セットを返します。ローカルプロシージャコールとは異なり、呼び出されたプロシージャは、むしろローカルアプリケーションの実行コンテキストよりもリモートで実行されます。"
    },
    {
      "indent": 3,
      "text": "The RPC protocol as described in [RFC5531] is fundamentally a message-passing protocol between one or more clients (where RPC consumers are running) and a server (where a remote execution context is available to process RPC transactions on behalf of those consumers).",
      "ja": "[RFC5531]に記載されているようにRPCプロトコルは、基本的に（RPC消費者が実行している）1つまたは複数のクライアント間のメッセージパッシングプロトコルと（リモート実行コンテキストは、これらの消費者に代わってRPCトランザクションを処理するのに利用可能である）サーバです。"
    },
    {
      "indent": 3,
      "text": "ONC RPC transactions are made up of two types of messages:",
      "ja": "ONC RPCのトランザクションは、メッセージの2種類で構成されています。"
    },
    {
      "indent": 3,
      "text": "CALL An \"RPC Call message\" requests that work be done. This type of message is designated by the value zero (0) in the message's msg_type field. An arbitrary unique value is placed in the message's XID field in order to match this RPC Call message to a corresponding RPC Reply message.",
      "ja": "作業が行われ、「RPCコールメッセージ」要求を呼び出します。このタイプのメッセージは、メッセージのMSG_TYPEフィールドに値ゼロ（0）によって指定されます。任意のユニークな値は、対応するRPC応答メッセージにこのRPCコールメッセージを一致させるために、メッセージのXIDフィールドに配置されます。"
    },
    {
      "indent": 3,
      "text": "REPLY An \"RPC Reply message\" reports the results of work requested by an RPC Call message. An RPC Reply message is designated by the value one (1) in the message's msg_type field. The value contained in an RPC Reply message's XID field is copied from the RPC Call message whose results are being reported.",
      "ja": "返信「RPC応答メッセージは、」RPCコールメッセージによって要求された作業の結果を報告します。 RPC応答メッセージは、メッセージのMSG_TYPEフィールドの値1（1）で示されています。 RPC応答メッセージのXIDフィールドに含まれる値は、その結果が報告されているRPCコールメッセージからコピーされます。"
    },
    {
      "indent": 3,
      "text": "The RPC client endpoint acts as a \"Requester\". It serializes the procedure's arguments and conveys them to a server endpoint via an RPC Call message. This message contains an RPC protocol header, a header describing the requested upper-layer operation, and all arguments.",
      "ja": "RPCクライアントエンドポイントは、「依頼者」として機能します。これは、プロシージャの引数をシリアライズし、RPCコールメッセージを介してサーバーのエンドポイントにそれらを伝えます。このメッセージは、RPCプロトコルヘッダ、要求された上層の動作を説明するヘッダ、およびすべての引数を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The RPC server endpoint acts as a \"Responder\". It deserializes the arguments and processes the requested operation. It then serializes the operation's results into another byte stream. This byte stream is conveyed back to the Requester via an RPC Reply message. This message contains an RPC protocol header, a header describing the upper-layer reply, and all results.",
      "ja": "RPCサーバーのエンドポイントは、「レスポンダ」として機能します。これは、引数をデシリアライズし、要求された操作を処理します。その後、別のバイトストリームに操作の結果をシリアル化します。このバイトストリームは、RPC応答メッセージを介して依頼者に戻って搬送されます。このメッセージは、RPCプロトコルヘッダ、上位レイヤ応答を記述するヘッダ、およびすべての結果を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The Requester deserializes the results and allows the original caller to proceed. At this point, the RPC transaction designated by the XID in the RPC Call message is complete, and the XID is retired.",
      "ja": "リクエスタは、結果をデシリアライズし、元の発信者が進行することを可能にします。この時点で、RPCコールメッセージにXIDで指定されたRPCのトランザクションが完了し、XIDが引退しています。"
    },
    {
      "indent": 3,
      "text": "In summary, RPC Call messages are sent by Requesters to Responders to initiate RPC transactions. RPC Reply messages are sent by Responders to Requesters to complete the processing on an RPC transaction.",
      "ja": "要約すると、RPCコールメッセージは、RPCトランザクションを開始するために応答するリクエスタで送信されます。 RPC応答メッセージは、RPCトランザクションの処理を完了するために、リクエスタにレスポンダによって送信されます。"
    },
    {
      "indent": 0,
      "text": "2.2.3. RPC Transports",
      "section_title": true,
      "ja": "2.2.3。 RPCトランスポート"
    },
    {
      "indent": 3,
      "text": "The role of an \"RPC transport\" is to mediate the exchange of RPC messages between Requesters and Responders. An RPC transport bridges the gap between the RPC message abstraction and the native operations of a particular network transport.",
      "ja": "「RPCトランスポート」の役割は、リクエスタとレスポンダ間のRPCメッセージの交換を仲介することです。 RPCトランスポートは、RPCメッセージ抽象化と特定のネットワーク・トランスポートのネイティブ動作との間のギャップを埋めます。"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA is a connection-oriented RPC transport. When a connection-oriented transport is used, clients initiate transport connections, while servers wait passively for incoming connection requests.",
      "ja": "RPC-オーバーRDMAは、接続指向RPCの輸送です。接続指向のトランスポートを使用する場合のサーバーが着信接続要求を受動的に待っている間、クライアントは、交通機関の接続を開始します。"
    },
    {
      "indent": 0,
      "text": "2.2.4. External Data Representation",
      "section_title": true,
      "ja": "2.2.4。外部データ表現"
    },
    {
      "indent": 3,
      "text": "One cannot assume that all Requesters and Responders represent data objects the same way internally. RPC uses External Data Representation (XDR) to translate native data types and serialize arguments and results [RFC4506].",
      "ja": "一つは、すべてのリクエスタとレスポンダは、データが内部的に同じ方法でオブジェクトを表すと仮定することはできません。 RPCは、ネイティブのデータ型を変換し、引数と結果[RFC4506]をシリアル化するために外部データ表現（XDR）を使用しています。"
    },
    {
      "indent": 3,
      "text": "The XDR protocol encodes data independently of the endianness or size of host-native data types, allowing unambiguous decoding of data on the receiving end. RPC Programs are specified by writing an XDR definition of their procedures, argument data types, and result data types.",
      "ja": "XDRプロトコルは、受信側のデータの明確な復号化を可能にし、独立してエンディアンまたはホストのネイティブのデータ型のサイズのデータ​​を符号化します。 RPCプログラムは、その手続き、引数のデータ型、および結果データ・タイプのXDR定義を記述することによって指定されています。"
    },
    {
      "indent": 3,
      "text": "XDR assumes that the number of bits in a byte (octet) and their order are the same on both endpoints and on the physical network. The smallest indivisible unit of XDR encoding is a group of four octets. XDR also flattens lists, arrays, and other complex data types so they can be conveyed as a stream of bytes.",
      "ja": "XDRは、バイト（オクテット）のビット数とその順序は、両方のエンドポイントと物理ネットワーク上で同じであると仮定しています。 XDR符号化の最小不可分単位は4つのオクテットのグループです。それらはバイトストリームとして搬送することができるので、XDRはまた、リスト、アレイ、及び他の複合データ型を平ら。"
    },
    {
      "indent": 3,
      "text": "A serialized stream of bytes that is the result of XDR encoding is referred to as an \"XDR stream\". A sending endpoint encodes native data into an XDR stream and then transmits that stream to a receiver. A receiving endpoint decodes incoming XDR byte streams into its native data representation format.",
      "ja": "XDR符号化の結果であるバイトのシリアル化されたストリームは、「XDRストリーム」と呼ばれます。送信エンドポイントは、XDRストリームにネイティブデータを符号化し、受信機にそのストリームを送信します。受信エンドポイントは、その天然のデータ表現形式に着信XDRバイトストリームをデコードします。"
    },
    {
      "indent": 0,
      "text": "2.2.4.1. XDR Opaque Data",
      "section_title": true,
      "ja": "2.2.4.1。 XDR隠されたデータ"
    },
    {
      "indent": 3,
      "text": "Sometimes, a data item must be transferred as is: without encoding or decoding. The contents of such a data item are referred to as \"opaque data\". XDR encoding places the content of opaque data items directly into an XDR stream without altering it in any way. ULPs or applications perform any needed data translation in this case. Examples of opaque data items include the content of files or generic byte strings.",
      "ja": "符号化または復号化なし：時々、データ項目があるとして転送されなければなりません。このようなデータ項目の内容は「不透明なデータ」と呼ばれます。 XDR符号化は、任意の方法でそれを変更することなく、直接、XDRストリームに不透明なデータ項目の内容を配置します。 ULPやアプリケーションは、この場合には、必要なデータ変換を行います。不透明なデータ項目の例としては、ファイルや、一般的なバイト文字列の内容が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.2.4.2. XDR Roundup",
      "section_title": true,
      "ja": "2.2.4.2。 XDRラウンドアップ"
    },
    {
      "indent": 3,
      "text": "The number of octets in a variable-length data item precedes that item in an XDR stream. If the size of an encoded data item is not a multiple of four octets, octets containing zero are added after the end of the item; this is the case so that the next encoded data item in the XDR stream starts on a four-octet boundary. The encoded size of the item is not changed by the addition of the extra octets. These extra octets are never exposed to ULPs.",
      "ja": "可変長データ項目のオクテットの数は、XDRストリーム内のそのアイテムに先行します。符号化されたデータ項目のサイズが4つのオクテットの倍数でない場合、ゼロが含まれているオクテットは、アイテムの終了後に添加されます。 XDRストリーム内の次の符号化データ項目が4オクテット境界で開始するように、これはそうです。アイテムのエンコードされたサイズは、余分なオクテットの添加によって変更されません。これらの余分なオクテットはのULPにさらされることはありません。"
    },
    {
      "indent": 3,
      "text": "This technique is referred to as \"XDR roundup\", and the extra octets are referred to as \"XDR roundup padding\".",
      "ja": "この技術は、「XDRのラウンドアップ」と呼ばれ、余分なオクテットは「XDRの切り上げパディング」と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "2.3. RDMA",
      "section_title": true,
      "ja": "2.3。 RDMA"
    },
    {
      "indent": 3,
      "text": "RPC Requesters and Responders can be made more efficient if large RPC messages are transferred by a third party, such as intelligent network-interface hardware (data movement offload), and placed in the receiver's memory so that no additional adjustment of data alignment has to be made (direct data placement or \"DDP\"). RDMA transports enable both optimizations.",
      "ja": "RPCリクエスタとレスポンダは、大きなRPCメッセージは、インテリジェント・ネットワーク・インターフェース・ハードウェア（データ移動オフロード）など、第三者によって転送された場合に、より効率的に、データ整列の追加の調整がなければならないように、受信機のメモリ内に配置することができます（直接データ配置または「DDP」）しました。 RDMAは、両方の最適化を有効に運びます。"
    },
    {
      "indent": 0,
      "text": "2.3.1. DDP",
      "section_title": true,
      "ja": "2.3.1。 DDP"
    },
    {
      "indent": 3,
      "text": "Typically, RPC implementations copy the contents of RPC messages into a buffer before being sent. An efficient RPC implementation sends bulk data without copying it into a separate send buffer first.",
      "ja": "典型的には、RPC実装は、送信される前にバッファにRPCメッセージの内容をコピーします。効率的なRPCの実装では、第1分割送信バッファにコピーすることなく、大量のデータを送信します。"
    },
    {
      "indent": 3,
      "text": "However, socket-based RPC implementations are often unable to receive data directly into its final place in memory. Receivers often need to copy incoming data to finish an RPC operation: sometimes, only to adjust data alignment.",
      "ja": "しかし、ソケットベースのRPCの実装は、多くの場合、メモリ内の最終的な場所にデータを直接受信することはできません。レシーバは、多くの場合、RPC操作を完了するために、着信データをコピーする必要があります。時々、データのみのアライメントを調整します。"
    },
    {
      "indent": 3,
      "text": "In this document, \"RDMA\" refers to the physical mechanism an RDMA transport utilizes when moving data. Although this may not be efficient, before an RDMA transfer, a sender may copy data into an intermediate buffer. After an RDMA transfer, a receiver may copy that data again to its final destination.",
      "ja": "この文書では、「RDMA」は、データを移動する際RDMA転送を利用する物理的メカニズムを指します。これは効率的でないかもしれないが、RDMA転送の前に、送信者は、中間バッファにデータをコピーすることができます。 RDMA転送後、受信機は、その最終的な宛先に再びそのデータをコピーしてもよいです。"
    },
    {
      "indent": 3,
      "text": "In this document, the term \"DDP\" refers to any optimized data transfer where it is unnecessary for a receiving host's CPU to copy transferred data to another location after it has been received.",
      "ja": "この文書では、用語「DDP」は、それが受信された後に受信したホストのCPUは、別の場所に転送されたデータをコピーすることは不要である任意の最適化されたデータの転送を指します。"
    },
    {
      "indent": 3,
      "text": "Just as [RFC5666] did, this document focuses on the use of RDMA Read and Write operations to achieve both data movement offload and DDP. However, not all RDMA-based data transfer qualifies as DDP, and DDP can be achieved using non-RDMA mechanisms.",
      "ja": "[RFC5666]はやったのと同じように、このドキュメントは、RDMA読むの使用に焦点を当て、データ移動オフロードとDDPの両方を達成するための操作を書きます。しかし、すべてのRDMAベースのデータ転送は、DDPとしての資格、およびDDPは、非RDMA機構を使用して達成することができません。"
    },
    {
      "indent": 0,
      "text": "2.3.2. RDMA Transport Requirements",
      "section_title": true,
      "ja": "2.3.2。 RDMAトランスポートの要件"
    },
    {
      "indent": 3,
      "text": "To achieve good performance during receive operations, RDMA transports require that RDMA consumers provision resources in advance to receive incoming messages.",
      "ja": "受信時に良好な性能を達成するために、RDMAは、着信メッセージを受信するために、事前にそのRDMA消費者提供のリソースを必要と運びます。"
    },
    {
      "indent": 3,
      "text": "An RDMA consumer might provide Receive buffers in advance by posting an RDMA Receive Work Request for every expected RDMA Send from a remote peer. These buffers are provided before the remote peer posts RDMA Send Work Requests; thus, this is often referred to as \"pre-posting\" buffers.",
      "ja": "RDMAの消費者は、すべての予想されるRDMAは、リモートピアからの送信のための作業要求を受信RDMAを掲載することにより、事前に受信バッファ提供することがあります。リモートピアポストRDMAは、作業要求を送信する前にこれらのバッファが提供されています。したがって、これはしばしば、「前の投稿」バッファと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "An RDMA Receive Work Request remains outstanding until hardware matches it to an inbound Send operation. The resources associated with that Receive must be retained in host memory, or \"pinned\", until the Receive completes.",
      "ja": "RDMAは、ハードウェアが受信用の送信操作に一致するまでの作業の要求が未処理のまま受信します。その受信に関連したリソースは受信が完了するまで、ホストメモリに保持、または「固定」する必要があります。"
    },
    {
      "indent": 3,
      "text": "Given these basic tenets of RDMA transport operation, the RPC-over-RDMA version 1 protocol assumes each transport provides the following abstract operations. A more complete discussion of these operations is found in [RFC5040].",
      "ja": "RDMAの搬送動作のこれらの基本的な教義を与え、RPCオーバーRDMAバージョン1プロトコルは、各トランスポートは、以下の抽象操作を提供前提。これらの操作のより完全な議論は[RFC5040]で発見されました。"
    },
    {
      "indent": 3,
      "text": "Registered Memory Registered memory is a region of memory that is assigned a steering tag that temporarily permits access by the RDMA provider to perform data-transfer operations. The RPC-over-RDMA version 1 protocol assumes that each region of registered memory MUST be identified with a steering tag of no more than 32 bits and memory addresses of up to 64 bits in length.",
      "ja": "登録メモリに登録メモリは、一時的にデータ転送操作を実行するRDMAプロバイダによってアクセスを許可するステアリングタグが割り当てられているメモリの領域です。 RPCオーバーRDMAバージョン1プロトコルは、登録されたメモリの各領域がこれ以上32ビット以下、長さは最大64ビットのメモリアドレスのステアリングタグで識別されなければならないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "RDMA Send The RDMA provider supports an RDMA Send operation, with completion signaled on the receiving peer after data has been placed in a pre-posted buffer. Sends complete at the receiver in the order they were issued at the sender. The amount of data transferred by a single RDMA Send operation is limited by the size of the remote peer's pre-posted buffers.",
      "ja": "データが事前通知バッファ内に置かれた後に完了が受信ピア上でシグナリングとRDMAは、RDMAプロバイダがRDMA送信動作をサポート送ります。それらは、送信者に発行されたために、受信機側で完全に送信します。単一のRDMA送信操作によって転送されるデータの量がリモートピアの事前掲載バッファのサイズによって制限されています。"
    },
    {
      "indent": 3,
      "text": "RDMA Receive The RDMA provider supports an RDMA Receive operation to receive data conveyed by incoming RDMA Send operations. To reduce the amount of memory that must remain pinned awaiting incoming Sends, the amount of pre-posted memory is limited. Flow control to prevent overrunning receiver resources is provided by the RDMA consumer (in this case, the RPC-over-RDMA version 1 protocol).",
      "ja": "RDMAは、RDMAプロバイダはRDMAが着信RDMAにより搬送されたデータの操作を送信を受信するための受信動作をサポート受信します。入ってくるの待っていることは送りピン止めたままにしなければならないメモリの量を減らすために、事前に掲示メモリの量は限られています。オーバーラン受信機資源を防止するためにフロー制御（この場合、RPCオーバーRDMAバージョン1つのプロトコル）RDMA消費者によって提供されます。"
    },
    {
      "indent": 3,
      "text": "RDMA Write The RDMA provider supports an RDMA Write operation to place data directly into a remote memory region. The local host initiates an RDMA Write, and completion is signaled there. No completion is signaled on the remote peer. The local host provides a steering tag, memory address, and length of the remote peer's memory region.",
      "ja": "RDMA RDMAプロバイダを書くには、リモートのメモリ領域にデータを直接配置するRDMA書き込み操作をサポートしています。ローカルホストは、RDMA書き込みを開始し、完了が通知されます。何の完了は、リモートピアにシグナリングされていません。ローカルホストは、ステアリングタグ、メモリアドレス、およびリモートピアのメモリ領域の長さを提供します。"
    },
    {
      "indent": 6,
      "text": "RDMA Writes are not ordered with respect to one another, but are ordered with respect to RDMA Sends. A subsequent RDMA Send completion obtained at the write initiator guarantees that prior RDMA Write data has been successfully placed in the remote peer's memory.",
      "ja": "RDMAの書き込みは、互いに対して順序付けされていませんが、RDMA送信に関して順序付けされます。書き込みイニシエータで得られ、その後のRDMA送信完了前RDMA書き込みデータが正常にリモートピアのメモリ内に配置されていることを保証します。"
    },
    {
      "indent": 3,
      "text": "RDMA Read The RDMA provider supports an RDMA Read operation to place peer source data directly into the read initiator's memory. The local host initiates an RDMA Read, and completion is signaled there. No completion is signaled on the remote peer. The local host provides steering tags, memory addresses, and a length for the remote source and local destination memory region.",
      "ja": "RDMA写真ザRDMAプロバイダは、直接読み取りイニシエータのメモリにピア・ソース・データを配置するRDMA読み取り操作をサポートしています。ローカルホストは、RDMA読み取りを開始し、完了が通知されます。何の完了は、リモートピアにシグナリングされていません。ローカルホストは、ステアリングタグ、メモリアドレス、およびリモートソースとローカル宛先メモリ領域用の長さを提供します。"
    },
    {
      "indent": 6,
      "text": "The local host signals Read completion to the remote peer as part of a subsequent RDMA Send message. The remote peer can then release steering tags and subsequently free associated source memory regions.",
      "ja": "ローカルホスト信号は、後続のRDMA送信メッセージの一部としてリモートピアに完了を読みます。リモートピアは、その後、ステアリングタグ、続いて遊離関連するソースメモリ領域を解放することができます。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA version 1 protocol is designed to be carried over RDMA transports that support the above abstract operations. This protocol conveys information sufficient for an RPC peer to direct an RDMA provider to perform transfers containing RPC data and to communicate their result(s).",
      "ja": "RPCオーバーRDMAバージョン1プロトコルは、上記の抽象操作をサポートするRDMAトランスポートを介して搬送されるように設計されています。このプロトコルは、RPCデータを含む転送を実行するRDMAプロバイダを指示し、その結果（複数可）を通信するRPCピアのために十分な情報を伝達します。"
    },
    {
      "indent": 0,
      "text": "3. RPC-over-RDMA Protocol Framework",
      "section_title": true,
      "ja": "3. RPCオーバーRDMAプロトコルのフレームワーク"
    },
    {
      "indent": 0,
      "text": "3.1. Transfer Models",
      "section_title": true,
      "ja": "3.1。転送モデル"
    },
    {
      "indent": 3,
      "text": "A \"transfer model\" designates which endpoint exposes its memory and which is responsible for initiating the transfer of data. To enable RDMA Read and Write operations, for example, an endpoint first exposes regions of its memory to a remote endpoint, which initiates these operations against the exposed memory.",
      "ja": "「伝達モデルは、」そのメモリを公開し、データの転送を開始するための責任があるどのエンドポイントを指定します。 RDMA読み取り可能および書き込み操作には、例えば、エンドポイントは、最初の露出メモリに対してこれらの操作を開始するリモートエンドポイントにそのメモリの領域を露出させます。"
    },
    {
      "indent": 3,
      "text": "Read-Read Requesters expose their memory to the Responder, and the Responder exposes its memory to Requesters. The Responder reads, or pulls, RPC arguments or whole RPC calls from each Requester. Requesters pull RPC results or whole RPC relies from the Responder.",
      "ja": "読み込み読むリクエスタがレスポンダにそのメモリを公開し、Responderはリクエスタにそのメモリを公開しています。 Responderは、RPCの引数または各リクエスタからの全体のRPCコールを読み込み、または引きます。リクエスタは、RPCの結果を引っ張ったり、全体のRPCがレスポンダから依存しています。"
    },
    {
      "indent": 3,
      "text": "Write-Write Requesters expose their memory to the Responder, and the Responder exposes its memory to Requesters. Requesters write, or push, RPC arguments or whole RPC calls to the Responder. The Responder pushes RPC results or whole RPC relies to each Requester.",
      "ja": "リクエスタがレスポンダにそのメモリを公開する書き込み書き込み、およびレスポンダは、リクエスタにそのメモリを公開しています。リクエスタは、書き込み、またはプッシュ、RPCの引数または全部RPCは、レスポンダに呼び出します。 ResponderはRPCの結果をプッシュするか、全体のRPCは、各リクエスタに依存しています。"
    },
    {
      "indent": 3,
      "text": "Read-Write Requesters expose their memory to the Responder, but the Responder does not expose its memory. The Responder pulls RPC arguments or whole RPC calls from each Requester. The Responder pushes RPC results or whole RPC relies to each Requester.",
      "ja": "読み書きリクエスタがレスポンダにそのメモリを公開しますが、Responderはそのメモリを公開していません。レスポンダは、RPCの引数または各リクエスタからの全体のRPC呼び出しを引っ張ります。 ResponderはRPCの結果をプッシュするか、全体のRPCは、各リクエスタに依存しています。"
    },
    {
      "indent": 3,
      "text": "Write-Read The Responder exposes its memory to Requesters, but Requesters do not expose their memory. Requesters push RPC arguments or whole RPC calls to the Responder. Requesters pull RPC results or whole RPC relies from the Responder.",
      "ja": "ライト・写真ザResponderはリクエスタにそのメモリを公開しますが、リクエスタは、そのメモリを公開しません。リクエスタは、RPCの引数またはレスポンダに全RPCコールを押してください。リクエスタは、RPCの結果を引っ張ったり、全体のRPCがレスポンダから依存しています。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Framing",
      "section_title": true,
      "ja": "3.2。メッセージフレーミング"
    },
    {
      "indent": 3,
      "text": "On an RPC-over-RDMA transport, each RPC message is encapsulated by an RPC-over-RDMA message. An RPC-over-RDMA message consists of two XDR streams.",
      "ja": "RPCオーバーRDMA輸送に、各RPCメッセージは、RPCオーバーRDMAメッセージにカプセル化されます。 RPCオーバーRDMAメッセージは、次の2つのXDRストリームから成ります。"
    },
    {
      "indent": 3,
      "text": "RPC Payload Stream The \"Payload stream\" contains the encapsulated RPC message being transferred by this RPC-over-RDMA message. This stream always begins with the Transaction ID (XID) field of the encapsulated RPC message.",
      "ja": "RPCペイロードストリーム「ペイロード・ストリーム」は、このRPCオーバーRDMAメッセージによって転送されるカプセル化されたRPCメッセージを含みます。このストリームは、常にカプセル化されたRPCメッセージのトランザクションID（XID）フィールドで始まります。"
    },
    {
      "indent": 3,
      "text": "Transport Stream The \"Transport stream\" contains a header that describes and controls the transfer of the Payload stream in this RPC-over-RDMA message. This header is analogous to the record marking used for RPC on TCP sockets but is more extensive, since RDMA transports support several modes of data transfer.",
      "ja": "トランスポートストリーム「トランスポートストリームは、」説明およびこのRPCオーバーRDMAメッセージ内のペイロード・ストリームの転送を制御ヘッダを含んでいます。このヘッダは、TCPソケットにRPCに使用マーキングレコードに類似しているが、RDMAデータ転送のいくつかのモードをサポートして搬送するため、より広範です。"
    },
    {
      "indent": 3,
      "text": "In its simplest form, an RPC-over-RDMA message consists of a Transport stream followed immediately by a Payload stream conveyed together in a single RDMA Send. To transmit large RPC messages, a combination of one RDMA Send operation and one or more other RDMA operations is employed.",
      "ja": "その最も単純な形態では、RPCオーバーRDMAメッセージは、トランスポートストリームから成るストリームは、単一のRDMA送信中で一緒に運ばペイロード直後。大RPCメッセージを送信するために、1つのRDMAの組み合わせは、操作を送信し、一の以上の他のRDMA操作が採用されています。"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA framing replaces all other RPC framing (such as TCP record marking) when used atop an RPC-over-RDMA association, even when the underlying RDMA protocol may itself be layered atop a transport with a defined RPC framing (such as TCP).",
      "ja": "RPCオーバーRDMAフレーミングのような根本的なRDMAプロトコル自体が定義RPCフレーミングと輸送の上に積層することができる場合であっても、RPCオーバーRDMAアソシエーションの上に使用された場合（マーキング例えばTCPレコードのような）他のすべてのRPCフレーミング（置き換えTCP）。"
    },
    {
      "indent": 3,
      "text": "However, it is possible for RPC-over-RDMA to be dynamically enabled in the course of negotiating the use of RDMA via a ULP exchange. Because RPC framing delimits an entire RPC request or reply, the resulting shift in framing must occur between distinct RPC messages, and in concert with the underlying transport.",
      "ja": "しかし、それは、RPCオーバーRDMA動的ULP交換を通じてRDMAの使用を交渉の過程で有効にすることが可能です。 RPCフレーミング全体RPC要求または応答を画定するので、フレーミングで得られたシフトは、異なるRPCメッセージ間、基礎となるトランスポートと協調して行われなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Managing Receiver Resources",
      "section_title": true,
      "ja": "3.3。レシーバリソースの管理"
    },
    {
      "indent": 3,
      "text": "It is critical to provide RDMA Send flow control for an RDMA connection. If any pre-posted Receive buffer on the connection is not large enough to accept an incoming RDMA Send, or if a pre-posted Receive buffer is not available to accept an incoming RDMA Send, the",
      "ja": "RDMA接続のためのRDMA送信フロー制御を提供することが重要です。接続上の任意の投稿を事前に受信バッファが受け入れるのに十分な大きされていない場合、着信RDMAは、送信、または事前に掲載受信バッファを受け入れるように利用できない場合、着信RDMAは、送信します"
    },
    {
      "indent": 3,
      "text": "RDMA connection can be terminated. This is different than conventional TCP/IP networking, in which buffers are allocated dynamically as messages are received.",
      "ja": "RDMA接続が終了することができます。これは、メッセージが受信されるとバッファが動的に割り当てられた従来のTCP / IPネットワークとは異なります。"
    },
    {
      "indent": 3,
      "text": "The longevity of an RDMA connection mandates that sending endpoints respect the resource limits of peer receivers. To ensure messages can be sent and received reliably, there are two operational parameters for each connection.",
      "ja": "RDMA接続の寿命は、送信側エンドポイントがピア受信機のリソース制限を尊重することを義務付け。メッセージが送信され、確実に受信できることを確認するには、各接続用の2つの動作パラメータがあります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. RPC-over-RDMA Credits",
      "section_title": true,
      "ja": "3.3.1。 RPCオーバーRDMAクレジット"
    },
    {
      "indent": 3,
      "text": "Flow control for RDMA Send operations directed to the Responder is implemented as a simple request/grant protocol in the RPC-over-RDMA header associated with each RPC message.",
      "ja": "RDMAは、各RPCメッセージに関連付けられたRPCオーバーRDMAヘッダ内の単純な要求/許可プロトコルとして実装されているレスポンダに向け操作を送信するための制御フロー。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA version 1 credit is the capability to handle one RPC-over-RDMA transaction. Each RPC-over-RDMA message sent from Requester to Responder requests a number of credits from the Responder. Each RPC-over-RDMA message sent from Responder to Requester informs the Requester how many credits the Responder has granted. The requested and granted values are carried in each RPC-over-RDMA message's rdma_credit field (see Section 4.2.3).",
      "ja": "RPCオーバーRDMAバージョン1クレジットは1 RPCオーバーRDMAトランザクションを処理するための機能です。レスポンダに依頼者から送信される各RPCオーバーRDMAメッセージは、レスポンダからのクレジットの数を要求します。リクエスタにレスポンダから送信される各RPCオーバーRDMAメッセージは、Responderが付与されているどのように多くのクレジットリクエスタに通知します。要求されたと付与された値は、各RPCオーバーRDMAメッセージのrdma_creditフィールドで運ばれる（4.2.3項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Practically speaking, the critical value is the granted value. A Requester MUST NOT send unacknowledged requests in excess of the Responder's granted credit limit. If the granted value is exceeded, the RDMA layer may signal an error, possibly terminating the connection. The granted value MUST NOT be zero, since such a value would result in deadlock.",
      "ja": "事実上、重要な値が付与された値です。リクエスタがレスポンダの付与された与信限度を超える未確認のリクエストを送ってはいけません。付与された値を超えた場合、RDMA層は、おそらく接続を終了、エラーを通知してもよいです。そのような値がデッドロックにつながるので、許可された値は、ゼロであってはなりません。"
    },
    {
      "indent": 3,
      "text": "RPC calls complete in any order, but the current granted credit limit at the Responder is known to the Requester from RDMA Send ordering properties. The number of allowed new requests the Requester may send is then the lower of the current requested and granted credit values, minus the number of requests in flight. Advertised credit values are not altered when individual RPCs are started or completed.",
      "ja": "RPCは、任意の順序で完全呼び出しますが、レスポンダで現在付与された与信限度は、プロパティを発注送るRDMAから依頼者にはよく知られています。リクエスタが送信することが許可され、新しいリクエストの数は、現在の要求と付与されたクレジット値の下、マイナス飛行中の要求の数です。個々のRPCが開始または完了したときに広告を出してクレジット値は変更されません。"
    },
    {
      "indent": 3,
      "text": "The requested and granted credit values MAY be adjusted to match the needs or policies in effect on either peer. For instance, a Responder may reduce the granted credit value to accommodate the available resources in a Shared Receive Queue. The Responder MUST ensure that an increase in receive resources is effected before the next RPC Reply message is sent.",
      "ja": "要求されたと付与されたクレジット値は、ピアのいずれかに有効なニーズやポリシーに合致するように調整することができます。例えば、Responderは共有で利用可能なリソース受信キューに対応するために付与されたクレジット値を減少させることができます。 Responderは次のRPC応答メッセージが送信される前にリソースを受け取るの増加がもたらされることを保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A Requester MUST maintain enough receive resources to accommodate expected replies. Responders have to be prepared for there to be no receive resources available on Requesters with no pending RPC transactions.",
      "ja": "リクエスタが予想される回答に対応するためにリソースを受け取る十分に維持しなければなりません。レスポンダには保留中のRPC取引にリクエスタで使用可能なリソースを受信するためにそこにのために準備されないことがあります。"
    },
    {
      "indent": 3,
      "text": "Certain RDMA implementations may impose additional flow-control restrictions, such as limits on RDMA Read operations in progress at the Responder. Accommodation of such restrictions is considered the responsibility of each RPC-over-RDMA version 1 implementation.",
      "ja": "特定のRDMA実装は、レスポンダで進行中のRDMA読み取り操作の制限のような追加のフロー制御の制約を課すことができます。そのような制限の宿泊は、各RPCオーバーRDMAバージョン1つの実装の責任と考えられています。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Inline Threshold",
      "section_title": true,
      "ja": "3.3.2。インラインしきい値"
    },
    {
      "indent": 3,
      "text": "An \"inline threshold\" value is the largest message size (in octets) that can be conveyed in one direction between peer implementations using RDMA Send and Receive. The inline threshold value is the smaller of the largest number of bytes the sender can post via a single RDMA Send operation and the largest number of bytes the receiver can accept via a single RDMA Receive operation. Each connection has two inline threshold values: one for messages flowing from Requester-to-Responder (referred to as the \"call inline threshold\") and one for messages flowing from Responder-to-Requester (referred to as the \"reply inline threshold\").",
      "ja": "「インライン閾値」の値は、送受信RDMAを使用して、ピア・インプリメンテーションとの間を一方向に搬送することができる（オクテットで）最大メッセージサイズです。インライン閾値は、動作および受信動作を受信する単一のRDMAを介して受け入れることができるバイトの最大数を送信し、送信者が、単一のRDMAを介して投稿できるバイトの最大数の小さい方です。各接続は、2つのインライン閾値を有する：からリクエスタツーレスポンダ流れるメッセージのための1つ（「コールインライン閾値」と呼ぶ）とレスポンダ・ツー・リクエスタから流れるメッセージの一つが（「返信インライン閾値」と称します）。"
    },
    {
      "indent": 3,
      "text": "Unlike credit limits, inline threshold values are not advertised to peers via the RPC-over-RDMA version 1 protocol, and there is no provision for inline threshold values to change during the lifetime of an RPC-over-RDMA version 1 connection.",
      "ja": "与信限度額とは異なり、インラインしきい値は、RPCオーバーRDMAバージョン1プロトコルを介してピアにアドバタイズし、RPCオーバーRDMAバージョン1接続の存続期間中に変更するインラインしきい値のための規定はないれていません。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Initial Connection State",
      "section_title": true,
      "ja": "3.3.3。初期接続状態"
    },
    {
      "indent": 3,
      "text": "When a connection is first established, peers might not know how many receive resources the other has, nor how large the other peer's inline thresholds are.",
      "ja": "接続が最初に確立されると、ピアは他が持っているリソースを受け取るどのように多くの知らないかもしれない、また他のピアのインラインしきい値はどのように大規模な。"
    },
    {
      "indent": 3,
      "text": "As a basis for an initial exchange of RPC requests, each RPC-over-RDMA version 1 connection provides the ability to exchange at least one RPC message at a time, whose RPC Call and Reply messages are no more than 1024 bytes in size. A Responder MAY exceed this basic level of configuration, but a Requester MUST NOT assume more than one credit is available and MUST receive a valid reply from the Responder carrying the actual number of available credits, prior to sending its next request.",
      "ja": "RPCリクエストの最初の交換のための基礎として、各RPCオーバーRDMAバージョン1つの接続は、そのRPCコール及びメッセージを返信サイズはせいぜい1024バイトではない時、に少なくとも一つのRPCメッセージを交換する能力を提供します。レスポンダは、この構成の基本的なレベルを超えることがありますが、依頼者は、複数のクレジットが利用可能であり、従来その次の要求を送信することに利用できるクレジットの実際の数を運ぶレスポンダから有効な回答を受けなければならないと仮定してはいけません。"
    },
    {
      "indent": 3,
      "text": "Receiver implementations MUST support inline thresholds of 1024 bytes but MAY support larger inline thresholds values. An independent mechanism for discovering a peer's inline thresholds before a connection is established may be used to optimize the use of RDMA Send and Receive operations. In the absence of such a mechanism, senders and receives MUST assume the inline thresholds are 1024 bytes.",
      "ja": "受信機の実装は、1024バイトのインライン閾値をサポートしなければならないが、より大きなインラインしきい値の値をサポートするかもしれません。接続が確立される前に、ピアのインライン閾値を発見するための独立したメカニズムがオペレーションを送信および受信RDMAの使用を最適化するために使用することができます。そのような機構の非存在下で、送信者と受信インラインしきい値が1024バイトであると仮定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. XDR Encoding with Chunks",
      "section_title": true,
      "ja": "3.4。チャンクとXDRエンコーディング"
    },
    {
      "indent": 3,
      "text": "When a DDP capability is available, the transport places the contents of one or more XDR data items directly into the receiver's memory, separately from the transfer of other parts of the containing XDR stream.",
      "ja": "DDP能力が利用可能である場合、トランスポートは、別々に含むXDRストリームの他の部分の転送から、直接受信機のメモリに一つ以上のXDRデータ項目の内容を配置します。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Reducing an XDR Stream",
      "section_title": true,
      "ja": "3.4.1。 XDRストリームを削減"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA version 1 provides a mechanism for moving part of an RPC message via a data transfer distinct from an RDMA Send/Receive pair. The sender removes one or more XDR data items from the Payload stream. They are conveyed via other mechanisms, such as one or more RDMA Read or Write operations. As the receiver decodes an incoming message, it skips over directly placed data items.",
      "ja": "RPCオーバーRDMAバージョン1対を受信/送信RDMAとは異なるデータ転送を介してRPCメッセージの一部を移動させるための機構を提供します。送信者は、ペイロード・ストリームから1つのまたは複数のXDRデータ項目を削除します。これらは、1つ以上のRDMA読み取りまたは書き込み操作などの他の機構を介して搬送されます。受信機は、受信メッセージを復号したように、それは直接配置データ項目をスキップします。"
    },
    {
      "indent": 3,
      "text": "The portion of an XDR stream that is split out and moved separately is referred to as a \"chunk\". In some contexts, data in an RPC-over-RDMA header that describes these split out regions of memory may also be referred to as a \"chunk\".",
      "ja": "別々に分割して移動されるXDRストリームの部分は、「チャンク」と呼ばれます。いくつかの状況では、メモリのこれらのうち分割領域を説明RPCオーバーRDMAヘッダ内のデータは、「チャンク」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "A Payload stream after chunks have been removed is referred to as a \"reduced\" Payload stream. Likewise, a data item that has been removed from a Payload stream to be transferred separately is referred to as a \"reduced\" data item.",
      "ja": "チャンクが除去された後にペイロードストリームは、「縮小」ペイロードストリームと呼ばれます。同様に、別々に転送されるペイロード・ストリームから除去されたデータ項目は、「縮小」データ項目と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.4.2. DDP-Eligibility",
      "section_title": true,
      "ja": "3.4.2。 DDP資格"
    },
    {
      "indent": 3,
      "text": "Not all XDR data items benefit from DDP. For example, small data items or data items that require XDR unmarshaling by the receiver do not benefit from DDP. In addition, it is impractical for receivers to prepare for every possible XDR data item in a protocol to be transferred in a chunk.",
      "ja": "いないすべてのXDRデータ項目は、DDPの恩恵を受ける。例えば、受信機によってXDRのアンマーシャリングを必要とする小さなデータ項目またはデータ項目は、DDPの恩恵を受けません。また、受信機はチャンクで転送されるプロトコルにあらゆる可能なXDRデータ項目を準備するために実用的ではありません。"
    },
    {
      "indent": 3,
      "text": "To maintain interoperability on an RPC-over-RDMA transport, a determination must be made of which few XDR data items in each ULP are allowed to use DDP.",
      "ja": "RPCオーバーRDMA輸送上の相互運用性を維持するために、決意は、各ULPのいくつかのXDRデータ項目がDDPを使用することを許可されるから作られなければなりません。"
    },
    {
      "indent": 3,
      "text": "This is done by additional specifications that describe how ULPs employ DDP. A \"ULB specification\" identifies which specific individual XDR data items in a ULP MAY be transferred via DDP. Such data items are referred to as \"DDP-eligible\". All other XDR data items MUST NOT be reduced.",
      "ja": "これは、のULPはDDPを利用する方法について説明し、追加の仕様によって行われます。 DDPを介して転送されてもよいULPの特定の個々のXDRデータ項目「ULB仕様」を識別する。このようなデータ項目は、「DDP-適格」と呼ばれています。他のすべてのXDRのデータ項目が減少してはなりません。"
    },
    {
      "indent": 3,
      "text": "Detailed requirements for ULBs are provided in Section 6.",
      "ja": "ULBsのための詳細な要件は、第6節で提供されています。"
    },
    {
      "indent": 0,
      "text": "3.4.3. RDMA Segments",
      "section_title": true,
      "ja": "3.4.3。 RDMAセグメント"
    },
    {
      "indent": 3,
      "text": "When encoding a Payload stream that contains a DDP-eligible data item, a sender may choose to reduce that data item. When it chooses to do so, the sender does not place the item into the Payload stream. Instead, the sender records in the RPC-over-RDMA header the location and size of the memory region containing that data item.",
      "ja": "DDP-適格データ項目が含まれているペイロード・ストリームを符号化するとき、送信者は、そのデータ項目を削減することもできます。それがそうすることを選択した場合、送信者はペイロードストリームにアイテムを配置しません。代わりに、RPCオーバーRDMAにおける送信者レコードは、そのデータ項目を含むメモリ領域の位置とサイズをヘッダ。"
    },
    {
      "indent": 3,
      "text": "The Requester provides location information for DDP-eligible data items in both RPC Call and Reply messages. The Responder uses this information to retrieve arguments contained in the specified region of the Requester's memory or place results in that memory region.",
      "ja": "依頼者は、両方のRPCコールでDDP-適格なデータ項目の位置情報を提供し、メッセージを返信します。 Responderはそのメモリ領域におけるリクエスタのメモリや場所の結果の指定された領域に含まれる引数を取得するために、この情報を使用しています。"
    },
    {
      "indent": 3,
      "text": "An \"RDMA segment\", or \"plain segment\", is an RPC-over-RDMA Transport header data object that contains the precise coordinates of a contiguous memory region that is to be conveyed separately from the Payload stream. Plain segments contain the following information:",
      "ja": "「RDMAセグメント」、又は「普通セグメント」、ペイロードストリームから別々に搬送される連続したメモリ領域の正確な座標を含むRPCオーバーRDMAトランスポート・ヘッダ・データ・オブジェクトです。平野セグメントは、次の情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "Handle Steering tag (STag) or R_key generated by registering this memory with the RDMA provider.",
      "ja": "RDMAプロバイダにこのメモリを登録することによって生成されたタグ（婚前）またはR_keyステアリングハンドル。"
    },
    {
      "indent": 3,
      "text": "Length The length of the RDMA segment's memory region, in octets. An \"empty segment\" is an RDMA segment with the value zero (0) in its length field.",
      "ja": "長さオクテットでRDMAセグメントのメモリ領域の長さ、。 「空のセグメント」は、その長さフィールドの値がゼロ（0）とRDMAセグメントです。"
    },
    {
      "indent": 3,
      "text": "Offset The offset or beginning memory address of the RDMA segment's memory region.",
      "ja": "RDMAセグメントのメモリ領域のオフセットまたは開始メモリアドレスをオフセット。"
    },
    {
      "indent": 3,
      "text": "See [RFC5040] for further discussion.",
      "ja": "さらなる議論のための[RFC5040]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.4. Chunks",
      "section_title": true,
      "ja": "3.4.4。チャンク"
    },
    {
      "indent": 3,
      "text": "In RPC-over-RDMA version 1, a \"chunk\" refers to a portion of the Payload stream that is moved independently of the RPC-over-RDMA Transport header and Payload stream. Chunk data is removed from the sender's Payload stream, transferred via separate operations, and then reinserted into the receiver's Payload stream to form a complete RPC message.",
      "ja": "RPCオーバーRDMAバージョン1において、「チャンク」は、独立してRPCオーバーRDMA転送ヘッダおよびペイロードストリームの移動されるペイロード・ストリームの部分を指します。チャンクデータは、別々の操作を介して転送され、送信元のペイロード流から除去し、次いで、完全RPCメッセージを形成するために、受信機のペイロードストリームに再挿入されます。"
    },
    {
      "indent": 3,
      "text": "Each chunk is comprised of RDMA segments. Each RDMA segment represents a single contiguous piece of that chunk. A Requester MAY divide a chunk into RDMA segments using any boundaries that are convenient. The length of a chunk is the sum of the lengths of the RDMA segments that comprise it.",
      "ja": "各チャンクは、RDMAセグメントから構成されています。各RDMAセグメントは、そのチャンクの単一の連続部分を表します。リクエスタは、便利な任意の境界を用いてRDMAセグメントにチャンクを分割することができます。チャンクの長さは、それを含むRDMAセグメントの長さの和です。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA version 1 transport protocol does not place a limit on chunk size. However, each ULP may cap the amount of data that can be transferred by a single RPC (for example, NFS has \"rsize\" and \"wsize\", which restrict the payload size of NFS READ and WRITE operations). The Responder can use such limits to sanity check chunk sizes before using them in RDMA operations.",
      "ja": "RPCオーバーRDMAバージョン1つのトランスポートプロトコルはチャンクサイズに制限を課しません。しかし、各ULPは、（例えば、NFSはNFS READおよびWRITE動作のペイロードサイズを制限している、「RSIZE」と「wsizeの値」を有する）は、単一のRPCによって転送できるデータの量をキャップすることができます。 ResponderはRDMA操作でそれらを使用する前に、健全性チェックのチャンクサイズに、このような制限を使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.4.4.1. Counted Arrays",
      "section_title": true,
      "ja": "3.4.4.1。カウント配列"
    },
    {
      "indent": 3,
      "text": "If a chunk contains a counted array data type, the count of array elements MUST remain in the Payload stream, while the array elements MUST be moved to the chunk. For example, when encoding an opaque byte array as a chunk, the count of bytes stays in the Payload stream, while the bytes in the array are removed from the Payload stream and transferred within the chunk.",
      "ja": "チャンクカウント配列データ・タイプが含まれている場合は配列要素がチャンクに移動する必要がありますが、配列要素の数は、ペイロード・ストリーム内のままでなければなりません。チャンクとして不透明なバイト配列をコードする場合、アレイ内のバイトがペイロードストリームから除去され、チャンク内に転送されている間、例えば、バイトのカウントは、ペイロードストリームに留まります。"
    },
    {
      "indent": 3,
      "text": "Individual array elements appear in a chunk in their entirety. For example, when encoding an array of arrays as a chunk, the count of items in the enclosing array stays in the Payload stream, but each enclosed array, including its item count, is transferred as part of the chunk.",
      "ja": "個々の配列要素は、それらの全体が塊に表示されます。チャンクとして配列の配列をコードする場合、例えば、囲いアレイ内の項目の数は、ペイロードストリームに留まるが、そのアイテム数を含む各囲まれたアレイは、チャンクの一部として転送されます。"
    },
    {
      "indent": 0,
      "text": "3.4.4.2. Optional-Data",
      "section_title": true,
      "ja": "3.4.4.2。オプション - データ"
    },
    {
      "indent": 3,
      "text": "If a chunk contains an optional-data data type, the \"is present\" field MUST remain in the Payload stream, while the data, if present, MUST be moved to the chunk.",
      "ja": "チャンクは、オプションデータのデータ型が含まれている場合は、「存在」フィールドは、ペイロードストリームに残す必要が存在する場合、データが、チャンクに移動させなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.4.3. XDR Unions",
      "section_title": true,
      "ja": "3.4.4.3。 XDR組合"
    },
    {
      "indent": 3,
      "text": "A union data type MUST NOT be made DDP-eligible, but one or more of its arms MAY be DDP-eligible, subject to the other requirements in this section.",
      "ja": "組合のデータ型は、DDP-適格作られてはならないが、その腕の一つ以上は、DDP-適格、このセクションの他の要件を受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.4.4.4. Chunk Roundup",
      "section_title": true,
      "ja": "3.4.4.4。チャンクラウンドアップ"
    },
    {
      "indent": 3,
      "text": "Except in special cases (covered in Section 3.5.3), a chunk MUST contain exactly one XDR data item. This makes it straightforward to reduce variable-length data items without affecting the XDR alignment of data items in the Payload stream.",
      "ja": "（セクション3.5.3で説明）特別な場合を除いて、チャンクは、1つのXDRデータ項目を含まなければなりません。これは、単純なペイロードストリーム内のデータ項目のXDRアライメントに影響を与えることなく、可変長のデータ項目を低減することができます。"
    },
    {
      "indent": 3,
      "text": "When a variable-length XDR data item is reduced, the sender MUST remove XDR roundup padding for that data item from the Payload stream so that data items remaining in the Payload stream begin on four-byte alignment.",
      "ja": "可変長XDRデータ項目が減少するとペイロードストリームに残っているデータ項目は4バイト整列に開始するように、送信側は、ペイロードストリームからそのデータ項目のXDRのまとめパディングを削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.5. Read Chunks",
      "section_title": true,
      "ja": "3.4.5。チャンクを読みます"
    },
    {
      "indent": 3,
      "text": "A \"Read chunk\" represents an XDR data item that is to be pulled from the Requester to the Responder.",
      "ja": "「読み取りチャンクは」レスポンダにリクエスタから引き出されるべきXDRデータ項目を表します。"
    },
    {
      "indent": 3,
      "text": "A Read chunk is a list of one or more RDMA read segments. An RDMA read segment consists of a Position field followed by a plain segment. See Section 4.1.2 for details.",
      "ja": "読むのチャンクは、一つ以上のRDMAリードセグメントのリストです。 RDMA読み取りセグメントは普通セグメントに続くPositionフィールドから成ります。詳細については、4.1.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Position The byte offset in the unreduced Payload stream where the receiver reinserts the data item conveyed in a chunk. The Position value MUST be computed from the beginning of the unreduced Payload stream, which begins at Position zero. All RDMA read segments belonging to the same Read chunk have the same value in their Position field.",
      "ja": "受信機はチャンクに搬送データ項目を再挿入非還元ペイロードストリーム内のバイトオフセットを置き。位置値は、位置ゼロで始まり非還元ペイロードストリームの先頭から計算されなければなりません。すべてのRDMAは、同じ読み取りチャンクに属するセグメントは、その位置フィールドに同じ値を持って読んでください。"
    },
    {
      "indent": 3,
      "text": "While constructing an RPC Call message, a Requester registers memory regions that contain data to be transferred via RDMA Read operations. It advertises the coordinates of these regions in the RPC-over-RDMA Transport header of the RPC Call message.",
      "ja": "RPCコールメッセージを構築しながら、リクエスタはデータを含むメモリ領域をRDMA読み取り操作を介して転送されるように登録します。これは、RPCコールメッセージのRPCオーバーRDMAトランスポートヘッダ内のこれらの領域の座標をアドバタイズ。"
    },
    {
      "indent": 3,
      "text": "After receiving an RPC Call message sent via an RDMA Send operation, a Responder transfers the chunk data from the Requester using RDMA Read operations. The Responder reconstructs the transferred chunk data by concatenating the contents of each RDMA segment, in list order, into the received Payload stream at the Position value recorded in that RDMA segment.",
      "ja": "操作を送るRDMAを介して送信されたRPC呼び出しメッセージを受信した後、レスポンダは、RDMA読み取り操作を使用して、リクエスタからのチャンクのデータを転送します。レスポンダは、RDMAセグメントに記録された位置値で受信したペイロードストリームに、リスト順に、各RDMAセグメントの内容を連結することによって転送チャンクデータを再構成します。"
    },
    {
      "indent": 3,
      "text": "Put another way, the Responder inserts the first RDMA segment in a Read chunk into the Payload stream at the byte offset indicated by its Position field. RDMA segments whose Position field value match this offset are concatenated afterwards, until there are no more RDMA segments at that Position value.",
      "ja": "別の言い方をすれば、レスポンダは、その位置フィールドによって示されるバイトオフセットでペイロードストリームに読み取りチャンクの最初のRDMAセグメントを挿入します。その位置フィールド値が一致、このオフセットは、その位置の値にもはやRDMAセグメントが存在しなくなるまで、その後連結さRDMAセグメント。"
    },
    {
      "indent": 3,
      "text": "The Position field in a read segment indicates where the containing Read chunk starts in the Payload stream. The value in this field MUST be a multiple of four. All segments in the same Read chunk share the same Position value, even if one or more of the RDMA segments have a non-four-byte-aligned length.",
      "ja": "含有読み取りチャンクペイロードストリームで始まる読み出しセグメントにおける位置フィールドが示します。このフィールドの値は4の倍数でなければなりません。 RDMAセグメントの1つまたは複数の非4バイト整列の長さを持っている場合でも、同じ読むチャンクシェアのすべてのセグメントに同じ位置値、。"
    },
    {
      "indent": 0,
      "text": "3.4.5.1. Decoding Read Chunks",
      "section_title": true,
      "ja": "3.4.5.1。デコード読むチャンク"
    },
    {
      "indent": 3,
      "text": "While decoding a received Payload stream, whenever the XDR offset in the Payload stream matches that of a Read chunk, the Responder initiates an RDMA Read to pull the chunk's data content into registered local memory.",
      "ja": "受信したペイロードストリームをデコードしながらペイロードストリームにオフセットXDRは、読み出しチャンクのものと一致するたびに、レスポンダは、登録され、ローカルメモリへのチャンクのデータコンテンツをプルするRDMA読み取りを開始します。"
    },
    {
      "indent": 3,
      "text": "The Responder acknowledges its completion of use of Read chunk source buffers when it sends an RPC Reply message to the Requester. The Requester may then release Read chunks advertised in the request.",
      "ja": "それはリクエスタにRPC応答メッセージを送信するときResponderは読むチャンクソース・バッファの使用のその完了を認めています。依頼者はその要求でアドバタイズ読むチャンクを解放することができます。"
    },
    {
      "indent": 0,
      "text": "3.4.5.2. Read Chunk Roundup",
      "section_title": true,
      "ja": "3.4.5.2。チャンクラウンドアップを読みます"
    },
    {
      "indent": 3,
      "text": "When reducing a variable-length argument data item, the Requester SHOULD NOT include the data item's XDR roundup padding in the chunk. The length of a Read chunk is determined as follows:",
      "ja": "可変長引数のデータ項目を削減すると、リクエスタは、チャンク内のデータ項目のXDR総まとめパディングを含めるべきではありません。次のように読むのチャンクの長さが決定されます。"
    },
    {
      "indent": 3,
      "text": "o If the Requester chooses to include roundup padding in a Read chunk, the chunk's total length MUST be the sum of the encoded length of the data item and the length of the roundup padding. The length of the data item that was encoded into the Payload stream remains unchanged.",
      "ja": "リクエスタは、読み出しチャンクにまとめパディングを含めることを選択した場合、O、チャンクの総長さは、データ項目の符号化された長さの和とまとめパディングの長さでなければなりません。ペイロードストリームに符号化されたデータ項目の長さは変わりません。"
    },
    {
      "indent": 6,
      "text": "The sender can increase the length of the chunk by adding another RDMA segment containing only the roundup padding, or it can do so by extending the final RDMA segment in the chunk.",
      "ja": "送信者は、まとめパディングを含む別のRDMAセグメントを追加することにより、チャンクの長さを増やすことができ、またはそれはチャンクの最後のRDMAセグメントを拡張することによってこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "o If the sender chooses not to include roundup padding in the chunk, the chunk's total length MUST be the same as the encoded length of the data item.",
      "ja": "送信者がチャンクにまとめパディングを含まないことを選択した場合、O、チャンクの総長さは、データ項目の符号化された長さと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Write Chunks",
      "section_title": true,
      "ja": "3.4.6。チャンクを書きます"
    },
    {
      "indent": 3,
      "text": "While constructing an RPC Call message, a Requester prepares memory regions in which to receive DDP-eligible result data items. A \"Write chunk\" represents an XDR data item that is to be pushed from a Responder to a Requester. It is made up of an array of zero or more plain segments.",
      "ja": "RPCコールメッセージを構築しながら、リクエスタはDDP-適格結果データ項目を受信するメモリ領域を用意します。 「書き込みチャンクは」リクエスタにレスポンダからプッシュされるXDRデータ項目を表します。これはゼロまたはそれ以上の普通のセグメントのアレイで構成されています。"
    },
    {
      "indent": 3,
      "text": "Write chunks are provisioned by a Requester long before the Responder has prepared the reply Payload stream. A Requester often does not know the actual length of the result data items to be returned, since the result does not yet exist. Thus, it MUST register Write chunks long enough to accommodate the maximum possible size of each returned data item.",
      "ja": "書き込みチャンクはResponderが応答ペイロードのストリームを作成したずっと前にリクエスタによってプロビジョニングされています。結果がまだ存在していないので、リクエスタは、多くの場合、返される結果データ項目の実際の長さを知りません。したがって、各返されたデータ項目の最大サイズを収容するのに十分に長いチャンクを書く登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition, the XDR position of DDP-eligible data items in the reply's Payload stream is not predictable when a Requester constructs an RPC Call message. Therefore, RDMA segments in a Write chunk do not have a Position field.",
      "ja": "リクエスタは、RPCコールメッセージを構築する際に加えて、回答者のペイロードストリームでDDP-適格データ項目のXDR位置は予測可能ではありません。そのため、書き込みチャンクでRDMAセグメントは、Positionフィールドを持っていません。"
    },
    {
      "indent": 3,
      "text": "For each Write chunk provided by a Requester, the Responder pushes one data item to the Requester, filling the chunk contiguously and in segment array order until that data item has been completely written to the Requester. The Responder MUST copy the segment count and all segments from the Requester-provided Write chunk into the RPC Reply message's Transport header. As it does so, the Responder updates each segment length field to reflect the actual amount of data that is being returned in that segment. The Responder then sends the RPC Reply message via an RDMA Send operation.",
      "ja": "リクエスタによって提供される各書き込みチャンクのために、レスポンダは、そのデータ項目が完全にリクエスタに書き込まれるまで連続セグメントアレイためにチャンクを充填し、リクエスタ1つのデータ項目を押します。レスポンダは、RPC応答メッセージの転送ヘッダにセグメント数とリクエスタ提供書き込みチャンクからのすべてのセグメントをコピーする必要があります。それはそうするように、レスポンダは、そのセグメントに返されるデータの実際の量を反映するように、各セグメントの長さフィールドを更新します。 Responderは、その後のRDMA送信操作を経由してRPC応答メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "An \"empty Write chunk\" is a Write chunk with a zero segment count. By definition, the length of an empty Write chunk is zero. An \"unused Write chunk\" has a non-zero segment count, but all of its segments are empty segments.",
      "ja": "「空の書き込みチャンクは」ゼロセグメント数と書き込みチャンクです。定義によると、空の書き込みチャンクの長さはゼロです。 「未使用の書き込みチャンクは」非ゼロのセグメント数を有するが、そのすべてのセグメントは、空セグメントです。"
    },
    {
      "indent": 0,
      "text": "3.4.6.1. Decoding Write Chunks",
      "section_title": true,
      "ja": "3.4.6.1。デコード書き込みチャンク"
    },
    {
      "indent": 3,
      "text": "After receiving the RPC Reply message, the Requester reconstructs the transferred data by concatenating the contents of each segment, in array order, into the RPC Reply message's XDR stream at the known XDR position of the associated DDP-eligible result data item.",
      "ja": "RPC応答メッセージを受信した後、リクエスタは、関連DDP-適格結果データ項目の既知のXDR位置RPC応答メッセージのXDRストリームに、アレイのために、各セグメントの内容を連結して転送されたデータを再構成します。"
    },
    {
      "indent": 0,
      "text": "3.4.6.2. Write Chunk Roundup",
      "section_title": true,
      "ja": "3.4.6.2。チャンクラウンドアップを書きます"
    },
    {
      "indent": 3,
      "text": "When provisioning a Write chunk for a variable-length result data item, the Requester SHOULD NOT include additional space for XDR roundup padding. A Responder MUST NOT write XDR roundup padding into a Write chunk, even if the Requester made space available for it. Therefore, when returning a single variable-length result data item, a returned Write chunk's total length MUST be the same as the encoded length of the result data item.",
      "ja": "可変長結果データ項目の書き込みチャンクをプロビジョニングする場合、リクエスタはXDR切り上げパディングのための追加のスペースを含めないでください。応答者は、要求がそれのために利用可能なスペースを作っていても、書き込みチャンクにXDRの検挙パディングを書くなりません。単一の可変長結果データ項目を返すときしたがって、返された書き込みチャンクの全長は結果データ項目の符号化された長さと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. Message Size",
      "section_title": true,
      "ja": "3.5。メッセージサイズ"
    },
    {
      "indent": 3,
      "text": "A receiver of RDMA Send operations is required by RDMA to have previously posted one or more adequately sized buffers. Memory savings are achieved on both Requesters and Responders by posting small Receive buffers. However, not all RPC messages are small. RPC-over-RDMA version 1 provides several mechanisms that allow messages of any size to be conveyed efficiently.",
      "ja": "RDMAの受信機は、以前一つ以上の適切なサイズのバッファを掲載しているためにRDMAによって要求された操作を送信します。メモリの節約は小さな受信バッファを掲載することにより、両方のリクエスタとレスポンダに達成されます。ただし、すべてのRPCメッセージが小さいです。 RPCオーバーRDMAバージョン1は、任意のサイズのメッセージを効率的に搬送することを可能にするいくつかのメカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Short Messages",
      "section_title": true,
      "ja": "3.5.1。短いメッセージ"
    },
    {
      "indent": 3,
      "text": "RPC messages are frequently smaller than typical inline thresholds. For example, the NFS version 3 GETATTR operation is only 56 bytes: 20 bytes of RPC header, a 32-byte file handle argument, and 4 bytes for its length. The reply to this common request is about 100 bytes.",
      "ja": "RPCメッセージは、典型的なインラインのしきい値よりも頻繁に小さくなっています。 RPCヘッダの20バイト、32バイトのファイルハンドル引数、その長さは4バイト：例えば、NFSバージョン3 GETATTR操作は、わずか56バイトです。この共通の要求に対する応答は、約100バイトです。"
    },
    {
      "indent": 3,
      "text": "Since all RPC messages conveyed via RPC-over-RDMA require an RDMA Send operation, the most efficient way to send an RPC message that is smaller than the inline threshold is to append the Payload stream directly to the Transport stream. An RPC-over-RDMA header with a small RPC Call or Reply message immediately following is transferred using a single RDMA Send operation. No other operations are needed.",
      "ja": "RPCオーバーRDMAを介して伝達すべてのRPCメッセージは、RDMA動作を送るを必要とするので、インライン閾値より小さいRPCメッセージを送信するための最も効率的な方法は、トランスポートストリームに直接ペイロードストリームを追加することです。小さなRPCコールとRPCオーバーRDMAヘッダ又は直ちに単一のRDMAオペレーションを送るを使用して転送され、次のメッセージを返信します。他の操作は必要ありません。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using Short Messages:",
      "ja": "ショートメッセージを使用してRPC-オーバーRDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5.2. Chunked Messages",
      "section_title": true,
      "ja": "3.5.2。チャンクのメッセージ"
    },
    {
      "indent": 3,
      "text": "If DDP-eligible data items are present in a Payload stream, a sender MAY reduce some or all of these items by removing them from the Payload stream. The sender uses a separate mechanism to transfer the reduced data items. The Transport stream with the reduced Payload stream immediately following is then transferred using a single RDMA Send operation.",
      "ja": "DDP-適格なデータ項目は、ペイロード・ストリーム中に存在する場合、送信者は、ペイロード・ストリームからそれらを除去することにより、これらの項目の一部または全部を減らすことができます。送信者は、縮小されたデータ項目を転送する別のメカニズムを使用します。直後の減少ペイロードストリームとトランスポートストリームは、その後の操作を送るシングルRDMAを使用して転送されます。"
    },
    {
      "indent": 3,
      "text": "After receiving the Transport and Payload streams of an RPC Call message accompanied by Read chunks, the Responder uses RDMA Read operations to move reduced data items in Read chunks. Before sending the Transport and Payload streams of an RPC Reply message containing Write chunks, the Responder uses RDMA Write operations to move reduced data items in Write and Reply chunks.",
      "ja": "交通読むチャンクを伴うRPC呼び出しメッセージのペイロード・ストリームを受信した後、Responderは読むのチャンクで減少したデータ項目を移動するRDMA読み取り操作を使用しています。書き込みチャンクを含むRPC応答メッセージのトランスポートおよびペイロードのストリームを送信する前に、レスポンダは、書込みに低減されたデータ項目を移動し、チャンクを返信するRDMA書き込み操作を使用しています。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction with a Read chunk:",
      "ja": "読むのチャンクとRPCオーバーRDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |        RDMA Read                    |\n     |   <------------------------------   |\n     |        RDMA Response (arg data)     |\n     |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction with a Write chunk:",
      "ja": "書き込みチャンクとRPCオーバーRDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Write (result data)     |\n     |   <------------------------------   |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5.3. Long Messages",
      "section_title": true,
      "ja": "3.5.3。長いメッセージ"
    },
    {
      "indent": 3,
      "text": "When a Payload stream is larger than the receiver's inline threshold, the Payload stream is reduced by removing DDP-eligible data items and placing them in chunks to be moved separately. If there are no DDP-eligible data items in the Payload stream, or the Payload stream is still too large after it has been reduced, the RDMA transport MUST use RDMA Read or Write operations to convey the Payload stream itself. This mechanism is referred to as a \"Long Message\".",
      "ja": "ペイロードのストリームが受信機のインライン閾値よりも大きい場合、ペイロードストリームは、DDP-対象データ項目を除去し、別々に移動するチャンクにそれらを置くことによって低減されます。そこにはDDP-適格なデータ項目は、ペイロード・ストリームにない、またはペイロードストリームはまだそれが削減された後に大きすぎる場合、RDMA輸送は、ペイロード・ストリーム自体を伝えるためにRDMA読み取りを使用するか、または操作を記述する必要があります。このメカニズムは、「長いメッセージ」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "To transmit a Long Message, the sender conveys only the Transport stream with an RDMA Send operation. The Payload stream is not included in the Send buffer in this instance. Instead, the Requester provides chunks that the Responder uses to move the Payload stream.",
      "ja": "長いメッセージを送信するために、送信者は、RDMA送信操作でのみトランスポートストリームを伝えます。ペイロードストリームは、このインスタンス内の送信バッファに含まれていません。代わりに、リクエスタは、Responderがペイロードストリームを移動するために使用するチャンクを提供します。"
    },
    {
      "indent": 3,
      "text": "Long Call To send a Long Call message, the Requester provides a special Read chunk that contains the RPC Call message's Payload stream. Every RDMA read segment in this chunk MUST contain zero in its Position field. Thus, this chunk is known as a \"Position Zero Read chunk\".",
      "ja": "ロングコールメッセージを送信するために長いコール、リクエスタは、RPCコールメッセージのペイロード・ストリームが含まれている特殊な読み取りチャンクを提供します。すべてのRDMAは、そのPositionフィールドにゼロを含まなければならない。このチャンクにセグメントをお読みください。したがって、このチャンクは「ポジションゼロ読むチャンク」として知られています。"
    },
    {
      "indent": 3,
      "text": "Long Reply To send a Long Reply, the Requester provides a single special Write chunk in advance, known as the \"Reply chunk\", that will contain the RPC Reply message's Payload stream. The Requester sizes the Reply chunk to accommodate the maximum expected reply size for that upper-layer operation.",
      "ja": "ロング返信を送るために長い返信は、リクエスタは、RPC応答メッセージのペイロード・ストリームが含まれています「返信チャンク」として知られている、事前に単一の特別な書き込みチャンクを、提供します。リクエスタは、上位層動作のための予想される最大応答サイズに対応する返信チャンクのサイズ。"
    },
    {
      "indent": 3,
      "text": "Though the purpose of a Long Message is to handle large RPC messages, Requesters MAY use a Long Message at any time to convey an RPC Call message.",
      "ja": "長いメッセージの目的は、大規模なRPCメッセージを処理することですが、リクエスタは、RPCコールメッセージを伝えるために、いつでも長いメッセージを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A Responder chooses which form of reply to use based on the chunks provided by the Requester. If Write chunks were provided and the Responder has a DDP-eligible result, it first reduces the reply Payload stream. If a Reply chunk was provided and the reduced Payload stream is larger than the reply inline threshold, the Responder MUST use the Requester-provided Reply chunk for the reply.",
      "ja": "レスポンダは、リクエスタによって提供されるチャンクに基づいて使用する返信のどの形式を選択します。書き込みチャンクが提供され、ResponderはDDP-適格な結果を持っていた場合、それは最初の応答ペイロードの流れを低減します。返信チャンクが設けられており、減少ペイロードストリームは応答インライン閾値よりも大きいされた場合、レスポンダは、応答をリクエスタ提供返信チャンクを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "XDR data items may appear in these special chunks without regard to their DDP-eligibility. As these chunks contain a Payload stream, such chunks MUST include appropriate XDR roundup padding to maintain proper XDR alignment of their contents.",
      "ja": "XDRデータ項目は、そのDDP-適格性を考慮せずに、これらの特別なチャンクで表示されることがあります。これらのチャンクは、ペイロードのストリームを含むように、そのようなチャンクは、その内容の適正XDR整列を維持するために適切なXDRのまとめパディングを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using a Long Call:",
      "ja": "ロングコールを使用してRPC-オーバーRDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_NOMSG)       |\nCall |   ------------------------------>   |\n     |        RDMA Read                    |\n     |   <------------------------------   |\n     |        RDMA Response (RPC call)     |\n     |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Send (RDMA_MSG)         |\n     |   <------------------------------   | Reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transaction using a Long Reply:",
      "ja": "ロング返信を使用してRPC-オーバーRDMAトランザクション："
    },
    {
      "indent": 10,
      "text": " Requester                             Responder\n     |        RDMA Send (RDMA_MSG)         |\nCall |   ------------------------------>   |\n     |                                     |\n     |                                     | Processing\n     |                                     |\n     |        RDMA Write (RPC reply)       |\n     |   <------------------------------   |\n     |        RDMA Send (RDMA_NOMSG)       |\n     |   <------------------------------   | Reply",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. RPC-over-RDMA in Operation",
      "section_title": true,
      "ja": "4. RPCオーバーRDMA操作で"
    },
    {
      "indent": 3,
      "text": "Every RPC-over-RDMA version 1 message has a header that includes a copy of the message's transaction ID, data for managing RDMA flow-control credits, and lists of RDMA segments describing chunks. All RPC-over-RDMA header content is contained in the Transport stream; thus, it MUST be XDR encoded.",
      "ja": "すべてのRPCオーバーRDMAバージョン1のメッセージは、メッセージのトランザクションIDのコピーを含むヘッダを有するRDMAフロー制御クレジットを管理するためのデータ、及びRDMAセグメントのリストは、チャンクを記述する。すべてのRPCオーバーRDMAヘッダのコンテンツは、トランスポートストリームに含まれます。したがって、それはXDRエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "RPC message layout is unchanged from that described in [RFC5531] except for the possible reduction of data items that are moved by separate operations.",
      "ja": "RPCメッセージのレイアウトは、別々の操作によって移動されたデータ項目の可能な減少を除いて、[RFC5531]に記載されたものと変わりません。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA protocol passes RPC messages without regard to their type (CALL or REPLY). Apart from restrictions imposed by ULBs, each endpoint of a connection MAY send RDMA_MSG or RDMA_NOMSG message header types at any time (subject to credit limits).",
      "ja": "RPCオーバーRDMAプロトコルは、それらのタイプ（CALLまたはREPLY）に関係なく、RPCメッセージを渡します。離れULBsによって課される制約から、接続の各エンドポイントは、任意の時間（信用限度の対象）でRDMA_MSG又はRDMA_NOMSGメッセージヘッダータイプを送信することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. XDR Protocol Definition",
      "section_title": true,
      "ja": "4.1。 XDRプロトコル定義"
    },
    {
      "indent": 3,
      "text": "This section contains a description of the core features of the RPC-over-RDMA version 1 protocol, expressed in the XDR language [RFC4506].",
      "ja": "このセクションでは、RPCオーバーRDMAバージョン1プロトコルのコア機能の記述を含む、XDR言語[RFC4506]で表さ。"
    },
    {
      "indent": 3,
      "text": "This description is provided in a way that makes it simple to extract into ready-to-compile form. The reader can apply the following shell script to this document to produce a machine-readable XDR description of the RPC-over-RDMA version 1 protocol.",
      "ja": "この説明は、すぐにコンパイル形式に抽出することが簡単になります方法で提供されています。読者は、RPCオーバーRDMAバージョン1つのプロトコルの機械可読XDR記述を生成するために、この文書に次のシェルスクリプトを適用することができます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh grep '^ *///' | sed 's?^ /// ??' | sed 's?^ *///$??'",
      "ja": "ます。＃！/ bin / shのはgrep '^ * ///' | SEDの？^ /// ?? ' | SEDの？^ * /// $ ?? '"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "That is, if the above script is stored in a file called \"extract.sh\" and this document is in a file called \"spec.txt\", then the reader can do the following to extract an XDR description file:",
      "ja": "これは、上記のスクリプトは、「extract.sh」と呼ばれるファイルに格納されており、この文書は「spec.txt」と呼ばれるファイルである、そして読者がXDR記述ファイルを抽出するために、次の操作を行うことができれば、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "sh extract.sh < spec.txt > rpcrdma_corev1.x",
      "ja": "SH extract.sh <spec.txt> rpcrdma_corev1.x"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "4.1.1. Code Component License",
      "section_title": true,
      "ja": "4.1.1。コードコンポーネントのライセンス"
    },
    {
      "indent": 3,
      "text": "Code components extracted from this document must include the following license text. When the extracted XDR code is combined with other complementary XDR code, which itself has an identical license, only a single copy of the license text need be preserved.",
      "ja": "この文書から抽出されたコードコンポーネントは、次のライセンステキストを含める必要があります。抽出されたXDRコード自体が同一のライセンスを有する他の相補的なXDRコードと組み合わせた場合、ライセンス・テキストの単一のコピーのみを保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Copyright (c) 2010-2017 IETF Trust and the persons\n///  * identified as authors of the code.  All rights reserved.\n///  *\n///  * The authors of the code are:\n///  * B. Callaghan, T. Talpey, and C. Lever\n///  *\n///  * Redistribution and use in source and binary forms, with\n///  * or without modification, are permitted provided that the\n///  * following conditions are met:\n///  *\n///  * - Redistributions of source code must retain the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer.\n///  *\n///  * - Redistributions in binary form must reproduce the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer in the documentation and/or other\n///  *   materials provided with the distribution.\n///  *\n///  * - Neither the name of Internet Society, IETF or IETF\n///  *   Trust, nor the names of specific contributors, may be\n///  *   used to endorse or promote products derived from this\n///  *   software without specific prior written permission.\n///  *\n///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///  *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///  */\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "4.1.2. RPC-over-RDMA Version 1 XDR",
      "section_title": true,
      "ja": "4.1.2。 RPCオーバーRDMAバージョン1つのXDR"
    },
    {
      "indent": 3,
      "text": "XDR data items defined in this section encodes the Transport Header Stream in each RPC-over-RDMA version 1 message. Comments identify items that cannot be changed in subsequent versions.",
      "ja": "このセクションで定義されたXDRデータ項目は、各RPCオーバーRDMAバージョン1つのメッセージで転送ヘッダストリームを符号化します。コメントは、その後のバージョンでは変更できない項目を識別します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Plain RDMA segment (Section 3.4.3)\n///  */\n/// struct xdr_rdma_segment {\n///    uint32 handle;           /* Registered memory handle */\n///    uint32 length;           /* Length of the chunk in bytes */\n///    uint64 offset;           /* Chunk virtual address or offset */\n/// };\n///\n/// /*\n///  * RDMA read segment (Section 3.4.5)\n///  */\n/// struct xdr_read_chunk {\n///    uint32 position;        /* Position in XDR stream */\n///    struct xdr_rdma_segment target;\n/// };\n///\n/// /*\n///  * Read list (Section 4.3.1)\n///  */\n/// struct xdr_read_list {\n///         struct xdr_read_chunk entry;\n///         struct xdr_read_list  *next;\n/// };\n///\n/// /*\n///  * Write chunk (Section 3.4.6)\n///  */\n/// struct xdr_write_chunk {\n///         struct xdr_rdma_segment target<>;\n/// };\n///\n/// /*\n///  * Write list (Section 4.3.2)\n///  */\n/// struct xdr_write_list {\n///         struct xdr_write_chunk entry;\n///         struct xdr_write_list  *next;\n/// };\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * Chunk lists (Section 4.3)\n///  */\n/// struct rpc_rdma_header {\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n///    /* rpc body follows */\n/// };\n///\n/// struct rpc_rdma_header_nomsg {\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n/// };\n///\n/// /* Not to be used */\n/// struct rpc_rdma_header_padded {\n///    uint32                 rdma_align;\n///    uint32                 rdma_thresh;\n///    struct xdr_read_list   *rdma_reads;\n///    struct xdr_write_list  *rdma_writes;\n///    struct xdr_write_chunk *rdma_reply;\n///    /* rpc body follows */\n/// };\n///\n/// /*\n///  * Error handling (Section 4.5)\n///  */\n/// enum rpc_rdma_errcode {\n///    ERR_VERS = 1,       /* Value fixed for all versions */\n///    ERR_CHUNK = 2\n/// };\n///\n/// /* Structure fixed for all versions */\n/// struct rpc_rdma_errvers {\n///    uint32 rdma_vers_low;\n///    uint32 rdma_vers_high;\n/// };\n///\n/// union rpc_rdma_error switch (rpc_rdma_errcode err) {\n///    case ERR_VERS:\n///      rpc_rdma_errvers range;\n///    case ERR_CHUNK:\n///      void;\n/// };\n///\n/// /*",
      "raw": true
    },
    {
      "indent": 3,
      "text": "///  * Procedures (Section 4.2.4)\n///  */\n/// enum rdma_proc {\n///    RDMA_MSG = 0,     /* Value fixed for all versions */\n///    RDMA_NOMSG = 1,   /* Value fixed for all versions */\n///    RDMA_MSGP = 2,    /* Not to be used */\n///    RDMA_DONE = 3,    /* Not to be used */\n///    RDMA_ERROR = 4    /* Value fixed for all versions */\n/// };\n///\n/// /* The position of the proc discriminator field is\n///  * fixed for all versions */\n/// union rdma_body switch (rdma_proc proc) {\n///    case RDMA_MSG:\n///      rpc_rdma_header rdma_msg;\n///    case RDMA_NOMSG:\n///      rpc_rdma_header_nomsg rdma_nomsg;\n///    case RDMA_MSGP:   /* Not to be used */\n///      rpc_rdma_header_padded rdma_msgp;\n///    case RDMA_DONE:   /* Not to be used */\n///      void;\n///    case RDMA_ERROR:\n///      rpc_rdma_error rdma_error;\n/// };\n///\n/// /*\n///  * Fixed header fields (Section 4.2)\n///  */\n/// struct rdma_msg {\n///    uint32    rdma_xid;      /* Position fixed for all versions */\n///    uint32    rdma_vers;     /* Position fixed for all versions */\n///    uint32    rdma_credit;   /* Position fixed for all versions */\n///    rdma_body rdma_body;\n/// };",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "4.2. Fixed Header Fields",
      "section_title": true,
      "ja": "4.2。固定ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA header begins with four fixed 32-bit fields that control the RDMA interaction.",
      "ja": "RPCオーバーRDMAヘッダは、RDMAの相互作用を制御する4つの固定された32ビットのフィールドで始まります。"
    },
    {
      "indent": 3,
      "text": "The first three words are individual fields in the rdma_msg structure. The fourth word is the first word of the rdma_body union, which acts as the discriminator for the switched union. The contents of this field are described in Section 4.2.4.",
      "ja": "最初の三つの言葉はrdma_msg構造内の個々のフィールドです。第4ワードは、スイッチ組合のための弁別器として作用rdma_body組合の最初の単語です。このフィールドの内容は、4.2.4項で説明されています。"
    },
    {
      "indent": 3,
      "text": "These four fields must remain with the same meanings and in the same positions in all subsequent versions of the RPC-over-RDMA protocol.",
      "ja": "これら四つのフィールドは、同じ意味を有するとRPCオーバーRDMAプロトコルの後続のすべてのバージョンで同じ位置に維持しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Transaction ID (XID)",
      "section_title": true,
      "ja": "4.2.1。トランザクションID（XID）"
    },
    {
      "indent": 3,
      "text": "The XID generated for the RPC Call and Reply messages. Having the XID at a fixed location in the header makes it easy for the receiver to establish context as soon as each RPC-over-RDMA message arrives. This XID MUST be the same as the XID in the RPC message. The receiver MAY perform its processing based solely on the XID in the RPC-over-RDMA header, and thereby ignore the XID in the RPC message, if it so chooses.",
      "ja": "XIDは、RPCコールのために生成されたメッセージを返信します。受信機は、すぐ各RPCオーバーRDMAメッセージが到着するコンテキストを確立するためのヘッダ内の固定位置にXIDを有することが容易になります。このXIDは、RPCメッセージでXIDと同じでなければなりません。受信機は、RPCオーバーRDMAヘッダにXIDのみに基づいてその処理を実行し、それによってそれがそう選択した場合、RPCメッセージにXIDを無視してもよいです。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Version Number",
      "section_title": true,
      "ja": "4.2.2。バージョンナンバー"
    },
    {
      "indent": 3,
      "text": "For RPC-over-RDMA version 1, this field MUST contain the value one (1). Rules regarding changes to this transport protocol version number can be found in Section 7.",
      "ja": "RPCオーバーRDMAバージョン1の場合、このフィールドは値1を含まなければなりません（1）。このトランスポートプロトコルバージョン番号の変更に関するルールは、第7節で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Credit Value",
      "section_title": true,
      "ja": "4.2.3。クレジット値"
    },
    {
      "indent": 3,
      "text": "When sent with an RPC Call message, the requested credit value is provided. When sent with an RPC Reply message, the granted credit value is returned. Further discussion of how the credit value is determined can be found in Section 3.3.",
      "ja": "RPC呼び出しメッセージで送信された場合、要求されたクレジット値が提供されています。 RPC応答メッセージを送信した場合、付与されたクレジット値が返されます。クレジット値が決定される方法のさらなる議論は3.3節に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Procedure Number",
      "section_title": true,
      "ja": "4.2.4。プロシージャ番号"
    },
    {
      "indent": 3,
      "text": "RDMA_MSG = 0 indicates that chunk lists and a Payload stream follow. The format of the chunk lists is discussed below.",
      "ja": "RDMA_MSG = 0は、そのチャンクのリストとペイロードストリームのフォローを示します。チャンクリストの形式については後述します。"
    },
    {
      "indent": 3,
      "text": "RDMA_NOMSG = 1 indicates that after the chunk lists there is no Payload stream. In this case, the chunk lists provide information to allow the Responder to transfer the Payload stream using explicit RDMA operations.",
      "ja": "RDMA_NOMSG = 1は、チャンクが一覧表示されます後に何のペイロードのストリームが存在しないことを示しています。この場合、チャンクリストは、レスポンダは、明示的なRDMA操作を使用してペイロード・ストリームを転送できるようにする情報を提供します。"
    },
    {
      "indent": 3,
      "text": "RDMA_MSGP = 2 is reserved.",
      "ja": "RDMA_MSGP = 2が予約されています。"
    },
    {
      "indent": 3,
      "text": "RDMA_DONE = 3 is reserved.",
      "ja": "RDMA_DONE = 3が予約されています。"
    },
    {
      "indent": 3,
      "text": "RDMA_ERROR = 4 is used to signal an encoding error in the RPC-over-RDMA header.",
      "ja": "RDMA_ERROR = 4は、RPCオーバーRDMAヘッダに符号化エラーを通知するために使用されます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_MSG procedure conveys the Transport stream and the Payload stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by the Read and Write lists and the Reply chunk, though any or all three MAY be marked as not present. The Payload stream then follows, beginning with its XID field. If a Read or Write chunk list is present, a portion of the Payload stream has been reduced and is conveyed via separate operations.",
      "ja": "RDMA_MSG手順は、操作を送信RDMA経由してトランスポートストリームとペイロードストリームを伝えます。いずれかまたはすべての3つが存在しないとしてマークされてもよいがトランスポートストリームは、読むに続く4つの固定フィールドが含まれていますし、リストや返信チャンクを書きます。ペイロードストリームは、そのXIDフィールドで始まり、次の。読み取りまたは書き込みのチャンクリストが存在する場合、ペイロードストリームの一部が還元されており、別々の操作を介して搬送されます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_NOMSG procedure conveys the Transport stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by the Read and Write chunk lists and the Reply chunk. Though any of these MAY be marked as not present, one MUST be present and MUST hold the Payload stream for this RPC-over-RDMA message. If a Read or Write chunk list is present, a portion of the Payload stream has been excised and is conveyed via separate operations.",
      "ja": "RDMA_NOMSG手順は、RDMA送信操作を介したトランスポートストリームを伝えます。トランスポートストリームは、読むに続く4つの固定フィールドが含まれており、チャンクリストと返信チャンクを書きます。これらのいずれかが存在しないとしてマークされることがありますが、1が存在しなければならないと、このRPCオーバーRDMAメッセージのペイロード・ストリームを保持しなければなりません。読み取りまたは書き込みのチャンクリストが存在する場合、ペイロードストリームの一部が切除されており、別々の操作を介して搬送されます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_ERROR procedure conveys the Transport stream via an RDMA Send operation. The Transport stream contains the four fixed fields followed by formatted error information. No Payload stream is conveyed in this type of RPC-over-RDMA message.",
      "ja": "RDMA_ERROR手順は、RDMA送信操作を介したトランスポートストリームを伝えます。トランスポートストリームは、フォーマットされたエラー情報に続いて4つの固定フィールドが含まれています。いいえペイロードストリームは、RPCオーバーRDMAメッセージのこのタイプに搬送されていません。"
    },
    {
      "indent": 3,
      "text": "A Requester MUST NOT send an RPC-over-RDMA header with the RDMA_ERROR procedure. A Responder MUST silently discard RDMA_ERROR procedures.",
      "ja": "リクエスタはRDMA_ERROR手順をRPCオーバーRDMAヘッダを送ってはいけません。 Responderは黙っRDMA_ERROR手順を捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Transport stream and Payload stream can be constructed in separate buffers. However, the total length of the gathered buffers cannot exceed the inline threshold.",
      "ja": "トランスポートストリームとペイロードストリームは、別のバッファに構築することができます。しかし、収集されたバッファの合計長さは、インラインしきい値を超えることができません。"
    },
    {
      "indent": 0,
      "text": "4.3. Chunk Lists",
      "section_title": true,
      "ja": "4.3。チャンクリスト"
    },
    {
      "indent": 3,
      "text": "The chunk lists in an RPC-over-RDMA version 1 header are three XDR optional-data fields that follow the fixed header fields in RDMA_MSG and RDMA_NOMSG procedures. Read Section 4.19 of [RFC4506] carefully to understand how optional-data fields work. Examples of XDR-encoded chunk lists are provided in Section 4.7 as an aid to understanding.",
      "ja": "RPCオーバーRDMAバージョン1ヘッダー内のチャンクリストはRDMA_MSGとRDMA_NOMSG手順における固定ヘッダフィールドに従う3 XDRオプションのデータフィールドです。オプションのデータフィールドがどのように機能するかを理解するために、[RFC4506]のセクション4.19をよくお読みください。 XDR-エンコードされたチャンクリストの例は、理解の助けとして、セクション4.7で提供されています。"
    },
    {
      "indent": 3,
      "text": "Often, an RPC-over-RDMA message has no associated chunks. In this case, the Read list, Write list, and Reply chunk are all marked \"not present\".",
      "ja": "多くの場合、RPCオーバーRDMAメッセージには、関連するチャンクを持っていません。この場合、読むリストは、すべての「存在しない」とマークされているリストを作成し、チャンクを返信します。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Read List",
      "section_title": true,
      "ja": "4.3.1。リストを読みます"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Read list\". The Read list is a list of zero or more RDMA read segments, provided by the Requester, that are grouped by their Position fields into Read chunks. Each Read chunk advertises the location of argument data the Responder is to pull from the Requester. The Requester has reduced the data items in these chunks from the call's Payload stream.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSG手順は、1つの「リストを読んで」持っています。リードリストは、Readチャンクにそれらの位置フィールドによってグループ化されているリクエスタによって提供されるゼロ個以上のRDMA読み取りセグメントのリストです。各読むチャンクは、Responderがリクエスタから引っ張っている引数のデータの場所をアドバタイズします。リクエスタは、コールのペイロードストリームからこれらのチャンク内のデータ項目を削減しました。"
    },
    {
      "indent": 3,
      "text": "A Requester may transmit the Payload stream of an RPC Call message using a Position Zero Read chunk. If the RPC Call message has no argument data that is DDP-eligible and the Position Zero Read chunk is not being used, the Requester leaves the Read list empty.",
      "ja": "リクエスタは、ポジションゼロ読むチャンクを使用してRPC呼び出しメッセージのペイロード・ストリームを送信してもよいです。 RPCコールメッセージは、DDP-適格とポジションゼロ読むチャンクが使用されていないで引数データを持っていない場合は、リクエスタは、空の読み取りリストを残します。"
    },
    {
      "indent": 3,
      "text": "Responders MUST leave the Read list empty in all replies.",
      "ja": "レスポンダは、すべての返信に空読むリストを残しておく必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. Matching Read Chunks to Arguments",
      "section_title": true,
      "ja": "4.3.1.1。引数に読むチャンクをマッチング"
    },
    {
      "indent": 3,
      "text": "When reducing a DDP-eligible argument data item, a Requester records the XDR stream offset of that data item in the Read chunk's Position field. The Responder can then tell unambiguously where that chunk is to be reinserted into the received Payload stream to form a complete RPC Call message.",
      "ja": "DDP-適格引数のデータ項目を削減すると、リクエスタは読むのチャンクの位置フィールドにそのデータ項目のオフセットXDRストリームを記録します。そのチャンクが完全RPCコールメッセージを形成するために、受信したペイロードストリームに再挿入する場所レスポンダは、明確に伝えることができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Write List",
      "section_title": true,
      "ja": "4.3.2。リストを書きます"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Write list\". The Write list is a list of zero or more Write chunks, provided by the Requester. Each Write chunk is an array of plain segments; thus, the Write list is a list of counted arrays.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSG手順では、一つの「書き込みリスト」を持っています。書き込みリストは、リクエスタが提供するゼロ個以上の書き込みチャンクのリスト、です。各書き込みチャンクプレーンセグメントのアレイです。このように、書き込みリストはカウント配列のリストです。"
    },
    {
      "indent": 3,
      "text": "If an RPC Reply message has no possible DDP-eligible result data items, the Requester leaves the Write list empty. When a Requester provides a Write list, the Responder MUST push data corresponding to DDP-eligible result data items to Requester memory referenced in the Write list. The Responder removes these data items from the reply's Payload stream.",
      "ja": "RPC応答メッセージがまったく可能DDP-適格結果データ項目を持っていない場合は、リクエスタは、空のライトリストを残します。リクエスタは、書き込みリストを提供する場合、Responderは書き込みリストで参照メモリを要求者にDDP-適格結果データ項目に対応するデータをプッシュしなければなりません。 Responderは、返信のペイロードストリームからこれらのデータ項目を削除します。"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Matching Write Chunks to Results",
      "section_title": true,
      "ja": "4.3.2.1。結果への書き込みチャンクをマッチング"
    },
    {
      "indent": 3,
      "text": "A Requester constructs the Write list for an RPC transaction before the Responder has formulated its reply. When there is only one DDP-eligible result data item, the Requester inserts only a single Write chunk in the Write list. If the returned Write chunk is not an unused Write chunk, the Requester knows with certainty which result data item is contained in it.",
      "ja": "Responderはその応答を策定する前にリクエスタは、RPCのトランザクションの書き込みリストを作成します。一つだけDDP-適格結果データ項目がある場合、リクエスタは、書き込みリスト内の唯一の単一の書き込みチャンクを挿入します。返された書き込みチャンクが未使用の書き込みチャンクでない場合、リクエスタは、データ項目は、それに含まれている結果と確信を持って知っています。"
    },
    {
      "indent": 3,
      "text": "When a Requester has provided multiple Write chunks, the Responder fills in each Write chunk with one DDP-eligible result until there are either no more DDP-eligible results or no more Write chunks.",
      "ja": "リクエスタが複数の書き込みチャンクを提供している場合は、それ以上DDP-適格な結果またはこれ以上の書き込みチャンクのいずれかがなくなるまで、Responderは1 DDP-適格な結果と各書き込みチャンクで埋めます。"
    },
    {
      "indent": 3,
      "text": "The Requester might not be able to predict in advance which DDP-eligible data item goes in which chunk. Thus, the Requester is responsible for allocating and registering Write chunks large enough to accommodate the largest result data item that might be associated with each chunk in the Write list.",
      "ja": "リクエスタは、DDP-適格データ項目がどのチャンクになった、事前に予測することができない場合があります。したがって、リクエスタは、書き込みリスト内の各チャンクに関連付けされるかもしれない最大の結果データ項目を収容するのに十分な大き書き込みチャンクを割り当てて登録する責任があります。"
    },
    {
      "indent": 3,
      "text": "As a Requester decodes a reply Payload stream, it is clear from the contents of the RPC Reply message which Write chunk contains which result data item.",
      "ja": "リクエスタが応答ペイロードストリームをデコードするように、チャンクはデータ項目をもたらした含有書くRPC応答メッセージの内容から明らかです。"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Unused Write Chunks",
      "section_title": true,
      "ja": "4.3.2.2。未使用の書き込みチャンク"
    },
    {
      "indent": 3,
      "text": "There are occasions when a Requester provides a non-empty Write chunk but the Responder is not able to use it. For example, a ULP may define a union result where some arms of the union contain a DDP-eligible data item while other arms do not. The Responder is required to use Requester-provided Write chunks in this case, but if the Responder returns a result that uses an arm of the union that has no DDP-eligible data item, that Write chunk remains unconsumed.",
      "ja": "リクエスタが空でない書き込みチャンクを提供しますが、Responderはそれを使用することができないときに機会があります。例えば、ULPは、他のアームがいない間労働組合の一部の腕がDDP-適格データ項目が含まれている労働組合の結果を定義することもできます。レスポンダは、この場合には依頼者が提供する書き込みチャンクを使用する必要はなく、Responderは何のDDP-適格なデータ項目を持たない労働組合のアームを使用して結果を返す場合、その書き込みチャンクは消費されないままにされます。"
    },
    {
      "indent": 3,
      "text": "If there is a subsequent DDP-eligible result data item in the RPC Reply message, it MUST be placed in that unconsumed Write chunk. Therefore, the Requester MUST provision each Write chunk so it can be filled with the largest DDP-eligible data item that can be placed in it.",
      "ja": "RPC応答メッセージのその後DDP-適格結果データ項目がある場合は、その未消費の書き込みチャンクに置かなければなりません。それはそれで置くことができる最大DDP-適格データ項目を充填することができるので、そのため、依頼者のMUSTの提供は、各チャンクを書きます。"
    },
    {
      "indent": 3,
      "text": "If this is the last or only Write chunk available and it remains unconsumed, the Responder MUST return this Write chunk as an unused Write chunk (see Section 3.4.6). The Responder sets the segment count to a value matching the Requester-provided Write chunk, but returns only empty segments in that Write chunk.",
      "ja": "これが可能なチャンクを書き、それが消費されないまま最後または唯一の場合は、Responderは（セクション3.4.6を参照）、未使用の書き込みチャンクとして、この書き込みチャンクを返さなければなりません。レスポンダは、リクエスタが提供書き込みチャンクと一致する値にセグメント数を設定し、それ書き込みチャンクにのみ空のセグメントを返します。"
    },
    {
      "indent": 3,
      "text": "Unused Write chunks, or unused bytes in Write chunk segments, are returned to the RPC consumer as part of RPC completion. Even if a Responder indicates that a Write chunk is not consumed, the Responder may have written data into one or more segments before choosing not to return that data item. The Requester MUST NOT assume that the memory regions backing a Write chunk have not been modified.",
      "ja": "書き込みチャンクセグメント内の未使用の書き込みチャンク、または未使用のバイトは、RPC完了の一部としてRPC消費者に戻されます。 Responderが書き込みチャンクが消費されていないことを示している場合でも、Responderは、そのデータ項目を返さないように選択する前に、1つまたは複数のセグメントにデータを書いたことがあります。リクエスタは、書き込みチャンクをバックアップメモリ​​領域が変更されていないと仮定してはいけません。"
    },
    {
      "indent": 0,
      "text": "4.3.2.3. Empty Write Chunks",
      "section_title": true,
      "ja": "4.3.2.3。空の書き込みチャンク"
    },
    {
      "indent": 3,
      "text": "To force a Responder to return a DDP-eligible result inline, a Requester employs the following mechanism:",
      "ja": "DDP-適格な結果をインライン返すようにレスポンダを強制するには、リクエスタは、次のようなメカニズムを採用しています。"
    },
    {
      "indent": 3,
      "text": "o When there is only one DDP-eligible result item in an RPC Reply message, the Requester provides an empty Write list.",
      "ja": "RPC応答メッセージで唯一のDDP-適格結果の項目がある場合には、O、リクエスタは、空のライトリストを提供します。"
    },
    {
      "indent": 3,
      "text": "o When there are multiple DDP-eligible result data items and a Requester prefers that a data item is returned inline, the Requester provides an empty Write chunk for that item (see Section 3.4.6). The Responder MUST return the corresponding result data item inline and MUST return an empty Write chunk in that Write list position in the RPC Reply message.",
      "ja": "そこに複数のDDP-適格結果データ項目であり、リクエスタはデータ項目がインラインで返されることを好む場合、O、要求者がその項目の空の書き込みチャンクを提供する（セクション3.4.6を参照）。レスポンダは、対応する結果データ項目をインラインで返す必要があり、RPC応答メッセージにその書き込みリスト位置に空の書き込みチャンクを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "As always, a Requester and Responder must prepare for a Long Reply to be used if the resulting RPC Reply might be too large to be conveyed in an RDMA Send.",
      "ja": "いつものように、リクエスタとレスポンダは、得られたRPC返信がRDMAの送信に搬送するには大きすぎるかもしれない場合に使用されるロング返信のために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Reply Chunk",
      "section_title": true,
      "ja": "4.3.3。チャンク返信"
    },
    {
      "indent": 3,
      "text": "Each RDMA_MSG or RDMA_NOMSG procedure has one \"Reply chunk\" slot. A Requester MUST provide a Reply chunk whenever the maximum possible size of the RPC Reply message's Transport and Payload streams is larger than the inline threshold for messages from Responder to Requester. Otherwise, the Requester marks the Reply chunk as not present.",
      "ja": "各RDMA_MSGまたはRDMA_NOMSG手順では、一つの「チャンクを返信」スロットを持っています。 RPC応答メッセージのトランスポートとペイロードストリームの最大可能サイズがレスポンダからリクエスタへのメッセージのためのインライン閾値よりも大きいときはいつでもリクエスタ返信チャンクを提供しなければなりません。そうでなければ、リクエスタは存在しないと返信チャンクをマーク。"
    },
    {
      "indent": 3,
      "text": "If the Transport stream and Payload stream together are smaller than the reply inline threshold, the Responder MAY return the RPC Reply message as a Short message rather than using the Requester-provided Reply chunk.",
      "ja": "トランスポートストリームペイロードストリームは一緒に応答インライン閾値より小さい場合、レスポンダはなくリクエスタ提供返信チャンクを使用するよりも短いメッセージとしてRPC応答メッセージを返すことができます。"
    },
    {
      "indent": 3,
      "text": "When a Requester provides a Reply chunk in an RPC Call message, the Responder MUST copy that chunk into the Transport header of the RPC Reply message. As with Write chunks, the Responder modifies the copied Reply chunk in the RPC Reply message to reflect the actual amount of data that is being returned in the Reply chunk.",
      "ja": "リクエスタは、RPCコールメッセージに返信チャンクを提供する場合、レスポンダは、RPC応答メッセージの転送ヘッダにそのチャンクをコピーする必要があります。書き込みチャンクと同様に、レスポンダは、応答チャンクに返されるデータの実際の量を反映するようにRPC応答メッセージにコピーされた返信チャンクを変更します。"
    },
    {
      "indent": 0,
      "text": "4.4. Memory Registration",
      "section_title": true,
      "ja": "4.4。メモリー登録"
    },
    {
      "indent": 3,
      "text": "The cost of registering and invalidating memory can be a significant proportion of the cost of an RPC-over-RDMA transaction. Thus, an important implementation consideration is how to minimize registration activity without exposing system memory needlessly.",
      "ja": "メモリを登録し、無効のコストは、RPCオーバーRDMAトランザクションのコストのかなりの割合ことができます。したがって、重要な実装の考慮事項は、不システムメモリを露出させることなく、登録活動を最小化する方法です。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Registration Longevity",
      "section_title": true,
      "ja": "4.4.1。登録長寿"
    },
    {
      "indent": 3,
      "text": "Data transferred via RDMA Read and Write can reside in a memory allocation not in the control of the RPC-over-RDMA transport. These memory allocations can persist outside the bounds of an RPC transaction. They are registered and invalidated as needed, as part of each RPC transaction.",
      "ja": "RDMA読み取りと書き込みを経由して転送されたデータはないRPCオーバーRDMA輸送の制御にメモリ割り当てに常駐することができます。これらのメモリ割り当ては、RPCトランザクションの境界の外側に存続することができます。彼らは、登録され、必要に応じて各RPCのトランザクションの一部として、無効とされています。"
    },
    {
      "indent": 3,
      "text": "The Requester endpoint must ensure that memory regions associated with each RPC transaction are protected from Responder access before allowing upper-layer access to the data contained in them. Moreover, the Requester must not access these memory regions while the Responder has access to them.",
      "ja": "リクエスタエンドポイントは、それらに含まれるデータの上位レイヤへのアクセスを許可する前に、アクセスレスポンダから保護される各RPCトランザクションに関連するメモリ領域を確保しなければなりません。 Responderがそれらへのアクセスを有している。また、依頼者は、これらのメモリ領域にアクセスしてはいけません。"
    },
    {
      "indent": 3,
      "text": "This includes memory regions that are associated with canceled RPCs. A Responder cannot know that the Requester is no longer waiting for a reply, and it might proceed to read or even update memory that the Requester might have released for other use.",
      "ja": "これはキャンセルのRPCに関連付けられたメモリ領域を含みます。応答者は、要求がもはや返事を待っていることを知ることはできません、それは読んで、あるいは要求者が他の使用のためにリリースしたかもしれないというメモリを更新するために進むかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Communicating DDP-Eligibility",
      "section_title": true,
      "ja": "4.4.2。 DDP-資格を伝えます"
    },
    {
      "indent": 3,
      "text": "The interface by which a ULP implementation communicates the eligibility of a data item locally to its local RPC-over-RDMA endpoint is not described by this specification.",
      "ja": "ULP実装は、ローカルRPCオーバーRDMA終点に局所的データ項目の適格性を通信することにより、インターフェースは、本明細書によって記載されていません。"
    },
    {
      "indent": 3,
      "text": "Depending on the implementation and constraints imposed by ULBs, it is possible to implement reduction transparently to upper layers. Such implementations may lead to inefficiencies, either because they require the RPC layer to perform expensive registration and invalidation of memory \"on the fly\", or they may require using RDMA chunks in RPC Reply messages, along with the resulting additional handshaking with the RPC-over-RDMA peer.",
      "ja": "ULBsによって課さ実装や制約に応じて、上位層に透過的に削減を実現することができます。彼らは「オンザフライ」メモリの高価な登録および無効化を実行するためにRPC層を必要とするので、そのような実装はどちらか、非効率につながる可能性があり、またはそれらはRPC-を有する得られた付加的なハンドシェイクと共に、RPC応答メッセージにRDMAチャンクを使用して必要とするかもしれません過RDMAピア。"
    },
    {
      "indent": 3,
      "text": "However, these issues are internal and generally confined to the local interface between RPC and its upper layers, one in which implementations are free to innovate. The only requirement, beyond constraints imposed by the ULB, is that the resulting RPC-over-RDMA protocol sent to the peer be valid for the upper layer.",
      "ja": "しかしながら、これらの問題は内部であり、一般にRPCとその上位層との間のローカルインタフェース、実装が革新して自由にされたものに限られました。唯一の要件は、ULBによって課される制約を超えて、ピアに送信され、得られたRPCオーバーRDMAプロトコルは、上位層のために有効であるということです。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Registration Strategies",
      "section_title": true,
      "ja": "4.4.3。登録戦略"
    },
    {
      "indent": 3,
      "text": "The choice of which memory registration strategies to employ is left to Requester and Responder implementers. To support the widest array of RDMA implementations, as well as the most general steering tag scheme, an Offset field is included in each RDMA segment.",
      "ja": "メモリ登録戦略を採用するかの選択は、リクエスタとレスポンダの実装に任されています。 RDMA実装の広い配列、ならびに最も一般的なステアリング・タグ・スキームをサポートするために、オフセット・フィールドは、各RDMAセグメントに含まれています。"
    },
    {
      "indent": 3,
      "text": "While zero-based offset schemes are available in many RDMA implementations, their use by RPC requires individual registration of each memory region. For such implementations, this can be a significant overhead. By providing an offset in each chunk, many pre-registration or region-based registrations can be readily supported.",
      "ja": "ゼロベースのオフセットスキームは多くのRDMA実装において利用可能であるが、RPCによってそれらの使用は、各メモリ領域の個々の登録を必要とします。そのような実装のために、これはかなりのオーバーヘッドであることができます。各チャンクのオフセットを提供することによって、多くの事前登録または領域ベースの登録を容易に支持することができます。"
    },
    {
      "indent": 0,
      "text": "4.5. Error Handling",
      "section_title": true,
      "ja": "4.5。エラー処理"
    },
    {
      "indent": 3,
      "text": "A receiver performs basic validity checks on the RPC-over-RDMA header and chunk contents before it passes the RPC message to the RPC layer. If an incoming RPC-over-RDMA message is not as long as a minimal size RPC-over-RDMA header (28 bytes), the receiver cannot trust the value of the XID field; therefore, it MUST silently discard the message before performing any parsing. If other errors are detected in the RPC-over-RDMA header of an RPC Call message, a Responder MUST send an",
      "ja": "それはRPC層にRPCメッセージを渡す前に、受信機は、RPCオーバーRDMAヘッダ及びチャンク内容の基本的な妥当性チェックを行います。着信RPCオーバーRDMAメッセージが最小サイズRPCオーバーRDMAヘッダ（28バイト）限りではない場合、受信機は、XIDフィールドの値を信頼することはできません。したがって、それは静かにどんな解析を実行する前に、メッセージを捨てなければなりません。他のエラーがRPCコールメッセージのRPCオーバーRDMAヘッダに検出された場合、レスポンダは、送信しなければなりません"
    },
    {
      "indent": 3,
      "text": "RDMA_ERROR message back to the Requester. If errors are detected in the RPC-over-RDMA header of an RPC Reply message, a Requester MUST silently discard the message.",
      "ja": "バックリクエスタにRDMA_ERRORメッセージ。エラーがRPC応答メッセージのRPCオーバーRDMAヘッダに検出された場合、リクエスタは静かにメッセージを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "To form an RDMA_ERROR procedure:",
      "ja": "RDMA_ERROR手順を形成するには："
    },
    {
      "indent": 3,
      "text": "o The rdma_xid field MUST contain the same XID that was in the rdma_xid field in the failing request;",
      "ja": "O rdma_xidフィールドは失敗し、要求にrdma_xidフィールドにあった同じXIDを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The rdma_vers field MUST contain the same version that was in the rdma_vers field in the failing request;",
      "ja": "O rdma_versフィールドは失敗し、要求にrdma_versフィールドにあった同じバージョンを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The rdma_proc field MUST contain the value RDMA_ERROR; and",
      "ja": "O rdma_procフィールドは値RDMA_ERRORを含まなければなりません。そして"
    },
    {
      "indent": 3,
      "text": "o The rdma_err field contains a value that reflects the type of error that occurred, as described below.",
      "ja": "O rdma_errフィールドは、以下に説明するように、発生したエラーの種類を反映する値を含みます。"
    },
    {
      "indent": 3,
      "text": "An RDMA_ERROR procedure indicates a permanent error. Receipt of this procedure completes the RPC transaction associated with XID in the rdma_xid field. A receiver MUST silently discard an RDMA_ERROR procedure that it cannot decode.",
      "ja": "RDMA_ERROR手順は永続的なエラーを示します。この手順の領収書はrdma_xidフィールドにXIDに関連付けられているRPCトランザクションを完了します。受信機は静かにそれがデコードできないRDMA_ERROR手順を捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Header Version Mismatch",
      "section_title": true,
      "ja": "4.5.1。ヘッダーのバージョンの不一致"
    },
    {
      "indent": 3,
      "text": "When a Responder detects an RPC-over-RDMA header version that it does not support (currently this document defines only version 1), it MUST reply with an RDMA_ERROR procedure and set the rdma_err value to ERR_VERS, also providing the low and high inclusive version numbers it does, in fact, support.",
      "ja": "レスポンダは、（現在、このドキュメントは、唯一のバージョン1を定義）がサポートされていないRPCオーバーRDMAヘッダのバージョンを検出すると、RDMA_ERROR手順で応答し、ERR_VERSにrdma_err値を設定し、また、低及び高包括的なバージョンを提供しなければなりません数字は、実際には、サポートしています。"
    },
    {
      "indent": 0,
      "text": "4.5.2. XDR Errors",
      "section_title": true,
      "ja": "4.5.2。 XDRエラー"
    },
    {
      "indent": 3,
      "text": "A receiver might encounter an XDR parsing error that prevents it from processing the incoming Transport stream. Examples of such errors include an invalid value in the rdma_proc field; an RDMA_NOMSG message where the Read list, Write list, and Reply chunk are marked not present; or the value of the rdma_xid field does not match the value of the XID field in the accompanying RPC message. If the rdma_vers field contains a recognized value, but an XDR parsing error occurs, the Responder MUST reply with an RDMA_ERROR procedure and set the rdma_err value to ERR_CHUNK.",
      "ja": "受信機は、受信トランスポートストリームを処理するのを防ぐXDR解析エラーが発生する可能性があります。このようなエラーの例としては、rdma_procフィールドに無効な値が含まれます。読むリストは、リストを書くと、チャンクを返信RDMA_NOMSGメッセージは存在しないとマークされています。またはrdma_xidフィールドの値は、添付のRPCメッセージでXIDフィールドの値と一致していません。 rdma_versフィールドが認識された価値が含まれていますが、XDR解析エラーが発生した場合、ResponderはRDMA_ERROR手順で応答し、ERR_CHUNKにrdma_err値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a Responder receives a valid RPC-over-RDMA header but the Responder's ULP implementation cannot parse the RPC arguments in the RPC Call message, the Responder SHOULD return an RPC Reply message with status GARBAGE_ARGS, using an RDMA_MSG procedure. This type of parsing failure might be due to mismatches between chunk sizes or offsets and the contents of the Payload stream, for example.",
      "ja": "Responderは有効なRPCオーバーRDMAヘッダを受信するが、レスポンダのULPの実装は、RPCコールメッセージにRPCの引数を解析することができない場合は、ResponderはRDMA_MSGプロシージャを使用して、ステータスGARBAGE_ARGSでRPC応答メッセージを返すべきです。パースの障害のこのタイプは、たとえば、原因チャンクサイズまたはオフセットとペイロードストリームの内容間のミスマッチである可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Responder RDMA Operational Errors",
      "section_title": true,
      "ja": "4.5.3。レスポンダRDMA操作ミス"
    },
    {
      "indent": 3,
      "text": "In RPC-over-RDMA version 1, the Responder initiates RDMA Read and Write operations that target the Requester's memory. Problems might arise as the Responder attempts to use Requester-provided resources for RDMA operations. For example:",
      "ja": "RPCオーバーRDMAバージョン1では、レスポンダは、RDMA読み取りを開始し、リクエスタのメモリをターゲットとする操作を記述します。 ResponderがRDMA操作にリクエスタが提供するリソースを使用しようとすると問題が発生する可能性があります。例えば："
    },
    {
      "indent": 3,
      "text": "o Usually, chunks can be validated only by using their contents to perform data transfers. If chunk contents are invalid (e.g., a memory region is no longer registered or a chunk length exceeds the end of the registered memory region), a Remote Access Error occurs.",
      "ja": "O通常、チャンクはデータのみ転送を実行するためにその内容を使用して検証することができます。チャンクの内容が無効である場合（例えば、メモリ領域がもはや登録されているか、チャンクの長さが登録されているメモリ領域の端を超えて）、リモートアクセスエラーが発生しません。"
    },
    {
      "indent": 3,
      "text": "o If a Requester's Receive buffer is too small, the Responder's Send operation completes with a Local Length Error.",
      "ja": "リクエスタの受信バッファが小さすぎる場合には、O、レスポンダの送信操作は、ローカル長エラーで完了します。"
    },
    {
      "indent": 3,
      "text": "o If the Requester-provided Reply chunk is too small to accommodate a large RPC Reply message, a Remote Access Error occurs. A Responder might detect this problem before attempting to write past the end of the Reply chunk.",
      "ja": "依頼者が提供する返信チャンクが大きいRPC応答メッセージに対応するためには小さすぎる場合には、O、リモートアクセスエラーが発生します。 Responderは返信チャンクの終わりを過ぎて書き込もうとする前に、この問題を検出することがあります。"
    },
    {
      "indent": 3,
      "text": "RDMA operational errors are typically fatal to the connection. To avoid a retransmission loop and repeated connection loss that deadlocks the connection, once the Requester has re-established a connection, the Responder should send an RDMA_ERROR reply with an rdma_err value of ERR_CHUNK to indicate that no RPC-level reply is possible for that XID.",
      "ja": "RDMA操作ミスは、通常の接続に致命的です。再送ループとリクエスタが接続を再確立した後、接続がデッドロック繰り返し接続損失を回避するために、レスポンダはないRPCレベルの応答がそのXIDために可能ではないことを示すためにERR_CHUNKのrdma_err値とRDMA_ERROR応答を送信します。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Other Operational Errors",
      "section_title": true,
      "ja": "4.5.4。その他の操作ミス"
    },
    {
      "indent": 3,
      "text": "While a Requester is constructing an RPC Call message, an unrecoverable problem might occur that prevents the Requester from posting further RDMA Work Requests on behalf of that message. As with other transports, if a Requester is unable to construct and transmit an RPC Call message, the associated RPC transaction fails immediately.",
      "ja": "リクエスタは、RPCコールメッセージを構築している間、回復不能の問題は、それがそのメッセージの代わりに、さらにRDMA作業要求を掲示からリクエスタを防ぎ発生する可能性があります。リクエスタは、RPCコールメッセージを構築し、送信することができない場合は、他のトランスポートと同様に、関連したRPCのトランザクションはすぐに失敗します。"
    },
    {
      "indent": 3,
      "text": "After a Requester has received a reply, if it is unable to invalidate a memory region due to an unrecoverable problem, the Requester MUST close the connection to protect that memory from Responder access before the associated RPC transaction is complete.",
      "ja": "リクエスタが応答を受信した後、それが回復不能な問題に起因するメモリ領域を無効にすることができない場合、リクエスタは、関連するRPCトランザクションが完了する前に、レスポンダのアクセスからそのメモリを保護するために、接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "While a Responder is constructing an RPC Reply message or error message, an unrecoverable problem might occur that prevents the Responder from posting further RDMA Work Requests on behalf of that message. If a Responder is unable to construct and transmit an RPC Reply or RPC-over-RDMA error message, the Responder MUST close the connection to signal to the Requester that a reply was lost.",
      "ja": "ResponderがRPC応答メッセージまたはエラーメッセージを構築している間、回復不能の問題は、それがそのメッセージの代わりに、さらにRDMA作業要求を掲示からレスポンダを防ぎ発生する可能性があります。レスポンダは、RPC返信またはRPCオーバーRDMAエラーメッセージを作成および送信することができない場合、レスポンダは、応答が失われた要求者に知らせるために接続を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.5. RDMA Transport Errors",
      "section_title": true,
      "ja": "4.5.5。 RDMA転送エラー"
    },
    {
      "indent": 3,
      "text": "The RDMA connection and physical link provide some degree of error detection and retransmission. iWARP's Marker PDU Aligned (MPA) layer (when used over TCP), the Stream Control Transmission Protocol (SCTP), as well as the InfiniBand [IBARCH] link layer all provide Cyclic Redundancy Check (CRC) protection of the RDMA payload, and CRC-class protection is a general attribute of such transports.",
      "ja": "RDMA接続と物理リンクがエラー検出と再送信のいくつかの学位を提供しています。 iWARPののマーカーPDU同盟（TCP上で使用）（MPA）層は、ストリーム制御伝送プロトコル（SCTP）のほか、インフィニバンド[IBARCH]リンク層の全ては、RDMAペイロードの巡回冗長検査（CRC）保護を提供し、CRC -class保護は、そのようなトランスポートの一般的な属性です。"
    },
    {
      "indent": 3,
      "text": "Additionally, the RPC layer itself can accept errors from the transport and recover via retransmission. RPC recovery can handle complete loss and re-establishment of a transport connection.",
      "ja": "また、RPC層自体は、トランスポートからのエラーを受け入れ、再送信を経由して回復することができます。 RPCの回復は完全に消失し、トランスポート接続の再確立を処理することができます。"
    },
    {
      "indent": 3,
      "text": "The details of reporting and recovery from RDMA link-layer errors are described in specific link-layer APIs and operational specifications and are outside the scope of this protocol specification. See Section 8 for further discussion of the use of RPC-level integrity schemes to detect errors.",
      "ja": "RDMAリンク層エラーからの報告および回復の詳細は、特定のリンク層APIと動作仕様に記載されており、このプロトコル仕様の範囲外でれます。エラーを検出するためにRPCレベルの整合性スキームの使用のさらなる議論については、セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.6. Protocol Elements No Longer Supported",
      "section_title": true,
      "ja": "4.6。プロトコル要素がサポートされなくなりました"
    },
    {
      "indent": 3,
      "text": "The following protocol elements are no longer supported in RPC-over-RDMA version 1. Related enum values and structure definitions remain in the RPC-over-RDMA version 1 protocol for backwards compatibility.",
      "ja": "以下のプロトコル・エレメントは、もはや1関連する列挙値及び構造の定義は、下位互換性のためにRPCオーバーRDMAバージョン1プロトコルに残っRPCオーバーRDMAのバージョンでサポートされていません。"
    },
    {
      "indent": 0,
      "text": "4.6.1. RDMA_MSGP",
      "section_title": true,
      "ja": "4.6.1。 RDMA_MSGP"
    },
    {
      "indent": 3,
      "text": "The specification of RDMA_MSGP in Section 3.9 of [RFC5666] is incomplete. To fully specify RDMA_MSGP would require:",
      "ja": "[RFC5666]のセクション3.9でRDMA_MSGPの仕様は不完全です。完全RDMA_MSGPが必要となる指定するには："
    },
    {
      "indent": 3,
      "text": "o Updating the definition of DDP-eligibility to include data items that may be transferred, with padding, via RDMA_MSGP procedures",
      "ja": "RDMA_MSGP手順を介して、パディングと、転送されるデータ項目を含むことをDDP-適格の定義を更新するO"
    },
    {
      "indent": 3,
      "text": "o Adding full operational descriptions of the alignment and threshold fields",
      "ja": "Oアライメント閾値フィールドの完全な動作記述を追加します"
    },
    {
      "indent": 3,
      "text": "o Discussing how alignment preferences are communicated between two peers without using CCP",
      "ja": "CCPを使用せずに2つのピア間で通信される方法アライメント優先議論O"
    },
    {
      "indent": 3,
      "text": "o Describing the treatment of RDMA_MSGP procedures that convey Read or Write chunks",
      "ja": "読み取りを伝えるRDMA_MSGP手続きの治療を記述するOまたはチャンクを書きます"
    },
    {
      "indent": 3,
      "text": "The RDMA_MSGP message type is beneficial only when the padded data payload is at the end of an RPC message's argument or result list. This is not typical for NFSv4 COMPOUND RPCs, which often include a GETATTR operation as the final element of the compound operation array.",
      "ja": "パディングされたデータペイロードは、RPCメッセージの引数または結果リストの末尾にある場合にのみRDMA_MSGPメッセージタイプは有益です。これは、しばしば複合操作型配列の最後の要素としてGETATTR操作を含むNFSv4の化合物のRPC、のための典型的ではありません。"
    },
    {
      "indent": 3,
      "text": "Without a full specification of RDMA_MSGP, there has been no fully implemented prototype of it. Without a complete prototype of RDMA_MSGP support, it is difficult to assess whether this protocol element has benefit or can even be made to work interoperably.",
      "ja": "RDMA_MSGPの完全な仕様がなければ、それのない完全に実装プロトタイプは存在しませんでした。 RDMA_MSGPサポートの完全なプロトタイプがなければ、このプロトコル要素が利益を持っているかさえも相互運用動作させることができるかどうかを評価することは困難です。"
    },
    {
      "indent": 3,
      "text": "Therefore, senders MUST NOT send RDMA_MSGP procedures. When receiving an RDMA_MSGP procedure, Responders SHOULD reply with an RDMA_ERROR procedure, setting the rdma_err field to ERR_CHUNK; Requesters MUST silently discard the message.",
      "ja": "したがって、送信者はRDMA_MSGP手続きを送ってはいけません。 RDMA_MSGP手順を受信した場合、レスポンダはERR_CHUNKにrdma_errフィールドを設定、RDMA_ERROR手順で応答すべきです。リクエスタは静かにメッセージを捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.2. RDMA_DONE",
      "section_title": true,
      "ja": "4.6.2。 RDMA_DONE"
    },
    {
      "indent": 3,
      "text": "Because no implementation of RPC-over-RDMA version 1 uses the Read-Read transfer model, there is never a need to send an RDMA_DONE procedure.",
      "ja": "RPCオーバーRDMAバージョン1のない実装がリード - リード転送モデルを使用しないため、RDMA_DONE手順を送信する必要は決してありません。"
    },
    {
      "indent": 3,
      "text": "Therefore, senders MUST NOT send RDMA_DONE messages. Receivers MUST silently discard RDMA_DONE messages.",
      "ja": "したがって、送信者はRDMA_DONEメッセージを送ってはいけません。受信機は、静かRDMA_DONEメッセージを捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.7. XDR Examples",
      "section_title": true,
      "ja": "4.7。 XDR例"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA chunk lists are complex data types. In this section, illustrations are provided to help readers grasp how chunk lists are represented inside an RPC-over-RDMA header.",
      "ja": "RPCオーバーRDMAチャンクリストは、複雑なデータ型です。このセクションでは、図示を読者がチャンクリストはRPCオーバーRDMAヘッダの内部表現方法を把握するために提供されます。"
    },
    {
      "indent": 3,
      "text": "A plain segment is the simplest component, being made up of a 32-bit handle (H), a 32-bit length (L), and 64 bits of offset (OO). Once flattened into an XDR stream, plain segments appear as",
      "ja": "普通セグメントは32ビットハンドル（H）で構成されている、最も単純な構成要素であり、32ビットの長さ（L）、およびオフセット（OO）の64ビット。一度XDRストリームに平坦化し、プレーンなセグメントは次のように表示され"
    },
    {
      "indent": 6,
      "text": "HLOO",
      "ja": "冬眠します"
    },
    {
      "indent": 3,
      "text": "An RDMA read segment has an additional 32-bit position field (P). RDMA read segments appear as",
      "ja": "RDMA読み取りセグメントは、追加の32ビット位置フィールド（P）を有します。 RDMAは、セグメントとして表示されます読んで"
    },
    {
      "indent": 6,
      "text": "PHLOO",
      "ja": "PHLOO"
    },
    {
      "indent": 3,
      "text": "A Read chunk is a list of RDMA read segments. Each RDMA read segment is preceded by a 32-bit word containing a one if a segment follows or a zero if there are no more segments in the list. In XDR form, this would look like",
      "ja": "読むのチャンクは、RDMAリードセグメントのリストです。各RDMA読み取りセグメントは、一つのセグメントが続く場合、またはリスト内に複数のセグメントが存在しない場合は、ゼロを含む32ビットワードによって先行されます。 XDR形式では、これは次のようになります。"
    },
    {
      "indent": 6,
      "text": "1 PHLOO 1 PHLOO 1 PHLOO 0",
      "ja": "1 PHLOO 1 PHLOO 1 PHLOO 0"
    },
    {
      "indent": 3,
      "text": "where P would hold the same value for each RDMA read segment belonging to the same Read chunk.",
      "ja": "Pは、各RDMAのために同じ値を保持する場所同じ読み取りチャンクに属するセグメントを読み出します。"
    },
    {
      "indent": 3,
      "text": "The Read list is also a list of RDMA read segments. In XDR form, this would look like a Read chunk, except that the P values could vary across the list. An empty Read list is encoded as a single 32-bit zero.",
      "ja": "読むのリストには、RDMAリードセグメントのリストです。 XDR形式では、これは、P値は、リストごとに異なる可能性があることを除いて、読むの塊のようになります。空読むリストは、単一の32ビットゼロとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "One Write chunk is a counted array of plain segments. In XDR form, the count would appear as the first 32-bit word, followed by an HLOO for each element of the array. For instance, a Write chunk with three elements would look like",
      "ja": "1つの書き込みチャンクプレーンセグメントのカウント配列です。 XDR形態において、カウントは、配列の各要素に対してHLOO続く最初の32ビットワードとして現れます。例えば、三つの要素との書き込みチャンクは次のようになります。"
    },
    {
      "indent": 6,
      "text": "3 HLOO HLOO HLOO",
      "ja": "3休止休止状態休止状態"
    },
    {
      "indent": 3,
      "text": "The Write list is a list of counted arrays. In XDR form, this is a combination of optional-data and counted arrays. To represent a Write list containing a Write chunk with three segments and a Write chunk with two segments, XDR would encode",
      "ja": "書き込みリストはカウント配列のリストです。 XDRの形態では、これはオプションデータ、計数アレイの組み合わせです。三つのセグメントと二つのセグメントを有する書き込みチャンクと書き込みチャンクを含む書き込みリストを表すために、XDRはエンコードなります"
    },
    {
      "indent": 6,
      "text": "1 3 HLOO HLOO HLOO 1 2 HLOO HLOO 0",
      "ja": "1 3 1つの2部屋の部屋0冬眠冬眠を休止"
    },
    {
      "indent": 3,
      "text": "An empty Write list is encoded as a single 32-bit zero.",
      "ja": "空の書き込みリストは、単一の32ビットゼロとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "The Reply chunk is a Write chunk. However, since it is an optional-data field, there is a 32-bit field in front of it that contains a one if the Reply chunk is present or a zero if it is not. After encoding, a Reply chunk with two segments would look like",
      "ja": "返信チャンクは、書き込みチャンクです。それは、オプションのデータフィールドであるので、それがない場合に返信チャンクが存在するか、またはゼロである場合は、1つを含有することの前に32ビットのフィールドです。符号化の後、二つのセグメントで返信チャンクは次のようになります。"
    },
    {
      "indent": 6,
      "text": "1 2 HLOO HLOO",
      "ja": "1つの2休止ハイバネーション"
    },
    {
      "indent": 3,
      "text": "Frequently, a Requester does not provide any chunks. In that case, after the four fixed fields in the RPC-over-RDMA header, there are simply three 32-bit fields that contain zero.",
      "ja": "多くの場合、リクエスタは、どのチャンクを提供していません。その場合には、RPCオーバーRDMAヘッダの4つの固定フィールドの後に、ゼロを含む3つの32ビットフィールドは単にあります。"
    },
    {
      "indent": 0,
      "text": "5. RPC Bind Parameters",
      "section_title": true,
      "ja": "5. RPCバインド・パラメータ"
    },
    {
      "indent": 3,
      "text": "In setting up a new RDMA connection, the first action by a Requester is to obtain a transport address for the Responder. The means used to obtain this address, and to open an RDMA connection, is dependent on the type of RDMA transport and is the responsibility of each RPC protocol binding and its local implementation.",
      "ja": "新しいRDMA接続をセットアップするには、依頼者による最初のアクションは、レスポンダのトランスポート・アドレスを取得することです。このアドレスを取得するために、及びRDMA接続を開くために使用される手段は、RDMA転送のタイプに依存し、各RPCプロトコルバインディングとそのローカル実装の責任です。"
    },
    {
      "indent": 3,
      "text": "RPC services normally register with a portmap or rpcbind service [RFC1833], which associates an RPC Program number with a service address. This policy is no different with RDMA transports. However, a different and distinct service address (port number) might sometimes be required for ULP operation with RPC-over-RDMA.",
      "ja": "RPCサービスは、通常はサービスアドレスでRPCプログラム番号を関連付けるのportmapまたはrpcbindのサービス[RFC1833]、に登録します。このポリシーは、RDMAトランスポートとの違いはありません。しかし、異なる別個のサービス・アドレス（ポート番号）が時々RPCオーバーRDMAとULP動作に必要かもしれません。"
    },
    {
      "indent": 3,
      "text": "When mapped atop the iWARP transport [RFC5040] [RFC5041], which uses IP port addressing due to its layering on TCP and/or SCTP, port mapping is trivial and consists merely of issuing the port in the connection process. The NFS/RDMA protocol service address has been assigned port 20049 by IANA, for both iWARP/TCP and iWARP/SCTP [RFC5667].",
      "ja": "TCP及び/又はSCTP上の積層によるアドレッシングのIPポートを使用するiWARPの輸送[RFC5040]、[RFC5041]の上にマッピングされた場合、ポートマッピングは自明であり、接続プロセスのポート発行の単なる構成されています。 NFS / RDMAプロトコル・サービス・アドレスは、iWARPの/ TCPおよびiWARPの/ SCTP [RFC5667]の両方のために、IANAによってポート20049が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "When mapped atop InfiniBand [IBARCH], which uses a service endpoint naming scheme based on a Group Identifier (GID), a translation MUST be employed. One such translation is described in Annexes A3 (Application Specific Identifiers), A4 (Sockets Direct Protocol (SDP)), and A11 (RDMA IP CM Service) of [IBARCH], which is appropriate for translating IP port addressing to the InfiniBand network. Therefore, in this case, IP port addressing may be readily employed by the upper layer.",
      "ja": "グループID（GID）に基づいて、サービス・エンドポイントの名前付けスキームを使用したInfiniBand [IBARCH]、の上にマッピングされた場合、翻訳を使用しなければなりません。そのような変換は、インフィニバンド・ネットワークにIPアドレス指定ポートを変換に適している[IBARCH]の附属書A3（アプリケーション固有識別子）、A4（ソケット直接プロトコル（SDP））、およびA11（RDMA IP CMサービス）に記載されています。したがって、この場合には、IPアドレス指定ポートが容易に上位層によって使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "When a mapping standard or convention exists for IP ports on an RDMA interconnect, there are several possibilities for each upper layer to consider:",
      "ja": "マッピング規格または規約がRDMA相互接続上のIPポートに存在する場合、考慮すべき各上位層にはいくつかの可能性があります。"
    },
    {
      "indent": 3,
      "text": "o One possibility is to have the Responder register its mapped IP port with the rpcbind service under the netid (or netids) defined here. An RPC-over-RDMA-aware Requester can then resolve its desired service to a mappable port and proceed to connect. This is the most flexible and compatible approach, for those upper layers that are defined to use the rpcbind service.",
      "ja": "O一つの可能​​性は、Responderが、ここで定義されたNETID（またはnetids）下のrpcbindサービスとのマッピングされたIPポートを登録することです。 RPCオーバーRDMA対応のリクエスタは、マッピング可能なポートにその所望のサービスを解決して接続するために進むことができます。これは、rpcbindサービスを使用するように定義されるそれらの上位層に対して、最も柔軟で適合性のアプローチです。"
    },
    {
      "indent": 3,
      "text": "o A second possibility is to have the Responder's portmapper register itself on the RDMA interconnect at a \"well-known\" service address (on UDP or TCP, this corresponds to port 111). A Requester could connect to this service address and use the portmap protocol to obtain a service address in response to a program number, e.g., an iWARP port number or an InfiniBand GID.",
      "ja": "O第2の可能性は、レスポンダのマッパーは、「既知の」サービスアドレス（UDPまたはTCP上で、これはポート111に相当する）でRDMA相互接続上で自身を登録させることです。リクエスタは、このサービスのアドレスに接続し、プログラム番号、例えば、iWARPのポート番号またはインフィニバンドGIDに応答してサービスアドレスを取得するためにポートマッププロトコルを使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Alternately, the Requester could simply connect to the mapped well-known port for the service itself, if it is appropriately defined. By convention, the NFS/RDMA service, when operating atop such an InfiniBand fabric, uses the same 20049 assignment as for iWARP.",
      "ja": "それが適切に定義されている場合、Oあるいは、リクエスタは、単に、サービス自体のマッピングされた既知のポートに接続することができます。慣例により、このようなInfiniBandファブリックの上に動作するNFS / RDMAサービスは、iWARPのと同じ20049割り当てを使用します。"
    },
    {
      "indent": 3,
      "text": "Historically, different RPC protocols have taken different approaches to their port assignment. Therefore, the specific method is left to each RPC-over-RDMA-enabled ULB and is not addressed in this document.",
      "ja": "歴史的に、異なるRPCプロトコルは、そのポートの割り当てに異なるアプローチをとっています。したがって、具体的な方法は、各RPCオーバーRDMA対応ULBに任され、この文書で扱われていません。"
    },
    {
      "indent": 3,
      "text": "In Section 9, this specification defines two new netid values, to be used for registration of upper layers atop iWARP [RFC5040] [RFC5041] and (when a suitable port translation service is available) InfiniBand [IBARCH]. Additional RDMA-capable networks MAY define their own netids, or if they provide a port translation, they MAY share the one defined in this document.",
      "ja": "第9章では、本明細書はiWARPの[RFC5040]、[RFC5041]の上に上層の登録とのために使用される2つの新しいNETID値を定義する（適切なポート翻訳サービスが利用可能な場合）のInfiniBand [IBARCH]。追加のRDMA対応ネットワークは独自のnetidsを定義したり、彼らはポート変換を提供する場合、彼らは、この文書で定義されたものを共有することがあります。"
    },
    {
      "indent": 0,
      "text": "6. ULB Specifications",
      "section_title": true,
      "ja": "6. ULB仕様"
    },
    {
      "indent": 3,
      "text": "An ULP is typically defined independently of any particular RPC transport. An ULB (ULB) specification provides guidance that helps the ULP interoperate correctly and efficiently over a particular transport. For RPC-over-RDMA version 1, a ULB may provide:",
      "ja": "ULPは、典型的には、任意の特定のRPCトランスポートの独立して定義されます。 ULB（ULB）仕様では、ULPは、特定のトランスポート上で正しく効率的に相互運用できますガイダンスを提供します。 RPCオーバーRDMAバージョン1の場合、ULBは、提供することができます。"
    },
    {
      "indent": 3,
      "text": "o A taxonomy of XDR data items that are eligible for DDP",
      "ja": "O DDPの対象となるXDRデータ項目の分類"
    },
    {
      "indent": 3,
      "text": "o Constraints on which upper-layer procedures may be reduced and on how many chunks may appear in a single RPC request",
      "ja": "上層手順が減少し、単一のRPC要求に表示されることがどのように多くのチャンクにすることができる、O制約"
    },
    {
      "indent": 3,
      "text": "o A method for determining the maximum size of the reply Payload stream for all procedures in the ULP",
      "ja": "O ULP内のすべてのプロシージャのための応答ペイロードストリームの最大サイズを決定するための方法"
    },
    {
      "indent": 3,
      "text": "o An rpcbind port assignment for operation of the RPC Program and Version on an RPC-over-RDMA transport",
      "ja": "RPCオーバーRDMA輸送上のRPCプログラムとバージョンの操作のためのrpcbindポート割り当てO"
    },
    {
      "indent": 3,
      "text": "Each RPC Program and Version tuple that utilizes RPC-over-RDMA version 1 needs to have a ULB specification.",
      "ja": "RPCオーバーRDMAバージョン1ニーズを利用し、各RPCプログラムとバージョンのタプルはULB仕様を持っています。"
    },
    {
      "indent": 0,
      "text": "6.1. DDP-Eligibility",
      "section_title": true,
      "ja": "6.1。 DDP資格"
    },
    {
      "indent": 3,
      "text": "An ULB designates some XDR data items as eligible for DDP. As an RPC-over-RDMA message is formed, DDP-eligible data items can be removed from the Payload stream and placed directly in the receiver's memory.",
      "ja": "ULBはDDPの対象として、いくつかのXDRデータ項目を指定します。 RPCオーバーRDMAメッセージが形成されるように、DDP-対象のデータ項目は、ペイロードストリームから除去され、受信機のメモリ内に直接配置することができます。"
    },
    {
      "indent": 3,
      "text": "An XDR data item should be considered for DDP-eligibility if there is a clear benefit to moving the contents of the item directly from the sender's memory to the receiver's memory. Criteria for DDP-eligibility include:",
      "ja": "受信機のメモリに送信者のメモリから直接項目の内容を移動するには明らかな利点がある場合、XDRデータ項目は、DDP-適格性を考慮すべきです。 DDP-適格性の基準は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The XDR data item is frequently sent or received, and its size is often much larger than typical inline thresholds.",
      "ja": "O XDRデータアイテムは頻繁に送信または受信し、その大きさは、多くの場合、典型的なインラインしきい値よりもはるかに大きくなっています。"
    },
    {
      "indent": 3,
      "text": "o If the XDR data item is a result, its maximum size must be predictable in advance by the Requester.",
      "ja": "XDRデータ項目が結果である場合、O、最大サイズは、要求者によって事前に予測可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Transport-level processing of the XDR data item is not needed. For example, the data item is an opaque byte array, which requires no XDR encoding and decoding of its content.",
      "ja": "O XDRデータ項目のトランスポートレベルの処理は不要です。例えば、データ・アイテムは、そのコンテンツのいかなるXDR符号化および復号化を必要としない不透明なバイト配列、です。"
    },
    {
      "indent": 3,
      "text": "o The content of the XDR data item is sensitive to address alignment. For example, a data copy operation would be required on the receiver to enable the message to be parsed correctly, or to enable the data item to be accessed.",
      "ja": "XDRデータ項目のコンテンツoをアラインメントに対処するために敏感です。例えば、データコピー操作が正しく解析されるべきメッセージを有効にする、またはアクセスするデータ項目を有効にするために受信機に必要とされるであろう。"
    },
    {
      "indent": 3,
      "text": "o The XDR data item does not contain DDP-eligible data items.",
      "ja": "O XDRデータ項目は、DDP-適格なデータ項目が含まれていません。"
    },
    {
      "indent": 3,
      "text": "In addition to defining the set of data items that are DDP-eligible, a ULB may also limit the use of chunks to particular upper-layer procedures. If more than one data item in a procedure is DDP-eligible, the ULB may also limit the number of chunks that a Requester can provide for a particular upper-layer procedure.",
      "ja": "DDP-対象であるデータアイテムのセットを定義することに加えて、ULBはまた、特定の上層手順とチャンクの使用を制限することができます。手順における複数のデータ項目がDDP-適格である場合、ULBはまた、リクエスタが特定の上層手順を提供することができるチャンクの数を制限することができます。"
    },
    {
      "indent": 3,
      "text": "Senders MUST NOT reduce data items that are not DDP-eligible. Such data items MAY, however, be moved as part of a Position Zero Read chunk or a Reply chunk.",
      "ja": "送信者は、DDP-資格がありませんデータ項目を減らしてはなりません。このようなデータ項目は、しかし、ポジションゼロ読むチャンクまたは返信チャンクの一部として動かすことができます。"
    },
    {
      "indent": 3,
      "text": "The programming interface by which an upper-layer implementation indicates the DDP-eligibility of a data item to the RPC transport is not described by this specification. The only requirements are that the receiver can re-assemble the transmitted RPC-over-RDMA message into a valid XDR stream, and that DDP-eligibility rules specified by the ULB are respected.",
      "ja": "上層実装はRPC輸送へのデータ項目のDDP-適格性を指示することにより、プログラミング・インターフェースは、本明細書によって記載されていません。唯一の要件は、受信機が有効なXDRストリームに送信されるRPCオーバーRDMAメッセージを再アセンブル、およびULBによって指定されたDDP-適格性ルールが尊重されることができることです。"
    },
    {
      "indent": 3,
      "text": "There is no provision to express DDP-eligibility within the XDR language. The only definitive specification of DDP-eligibility is a ULB.",
      "ja": "XDR言語内のDDP-適格性を表現するための規定はありません。 DDP-資格の唯一の決定的な仕様はULBです。"
    },
    {
      "indent": 3,
      "text": "In general, a DDP-eligibility violation occurs when:",
      "ja": "一般的に、DDP-資格違反が発生したときに："
    },
    {
      "indent": 3,
      "text": "o A Requester reduces a non-DDP-eligible argument data item. The Responder MUST NOT process this RPC Call message and MUST report the violation as described in Section 4.5.2.",
      "ja": "Oリクエスタは、非DDP-適格引数のデータ項目を削減します。 Responderは、このRPCコールメッセージを処理してはならないと4.5.2項で説明したように、違反を報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A Responder reduces a non-DDP-eligible result data item. The Requester MUST terminate the pending RPC transaction and report an appropriate permanent error to the RPC consumer.",
      "ja": "O Responderは非DDP-適格結果データ項目を削減します。リクエスタは、保留中のRPCトランザクションを終了し、RPCの消費者に適切な永続的なエラーを報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A Responder does not reduce a DDP-eligible result data item into an available Write chunk. The Requester MUST terminate the pending RPC transaction and report an appropriate permanent error to the RPC consumer.",
      "ja": "Oレスポンダは、利用可能な書き込みチャンクにDDP-適格結果データ項目を減らすことはありません。リクエスタは、保留中のRPCトランザクションを終了し、RPCの消費者に適切な永続的なエラーを報告しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Maximum Reply Size",
      "section_title": true,
      "ja": "6.2。最大返信サイズ"
    },
    {
      "indent": 3,
      "text": "A Requester provides resources for both an RPC Call message and its matching RPC Reply message. A Requester forms the RPC Call message itself; thus, the Requester can compute the exact resources needed.",
      "ja": "リクエスタは、RPCコールメッセージと一致するRPC応答メッセージの両方のための資源を提供します。リクエスタは、RPCコールメッセージ自体を形成し、したがって、リクエスタが必要な正確なリソースを計算することができます。"
    },
    {
      "indent": 3,
      "text": "A Requester must allocate resources for the RPC Reply message (an RPC-over-RDMA credit, a Receive buffer, and possibly a Write list and Reply chunk) before the Responder has formed the actual reply. To accommodate all possible replies for the procedure in the RPC Call message, a Requester must allocate reply resources based on the maximum possible size of the expected RPC Reply message.",
      "ja": "Responderが実際の応答を形成している前に、リクエスタは、RPC応答メッセージ（RPC-オーバーRDMAクレジット、受信バッファ、およびおそらく書き込みリストと返信チャンク）のためのリソースを割り当てる必要があります。 RPCコールメッセージに手続きのためのすべての可能な応答に対応するために、リクエスタが期待されるRPC応答メッセージの最大サイズに基づいて、応答リソースを割り当てる必要があります。"
    },
    {
      "indent": 3,
      "text": "If there are procedures in the ULP for which there is no clear reply size maximum, the ULB needs to specify a dependable means for determining the maximum.",
      "ja": "明確な返答サイズの上限はありませんそのためULPの手順がある場合は、ULBは、最大値を決定するための信頼できる手段を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Additional Considerations",
      "section_title": true,
      "ja": "6.3。その他の考慮事項"
    },
    {
      "indent": 3,
      "text": "There may be other details provided in a ULB.",
      "ja": "ULBで提供その他の詳細があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "o An ULB may recommend inline threshold values or other transport-related parameters for RPC-over-RDMA version 1 connections bearing that ULP.",
      "ja": "O ULBはULPこと軸受RPCオーバーRDMAバージョン1つの接続のためのインライン閾値または他の輸送関連パラメータを勧告することができます。"
    },
    {
      "indent": 3,
      "text": "o An ULP may provide a means to communicate these transport-related parameters between peers. Note that RPC-over-RDMA version 1 does not specify any mechanism for changing any transport-related parameter after a connection has been established.",
      "ja": "O ULPは、ピア間のこれらの輸送関連パラメータを通信するための手段を提供することができます。接続が確立された後に任意のトランスポート関連パラメータを変更するための任意のメカニズムを指定しないRPCオーバーRDMAバージョン注1。"
    },
    {
      "indent": 3,
      "text": "o Multiple ULPs may share a single RPC-over-RDMA version 1 connection when their ULBs allow the use of RPC-over-RDMA version 1 and the rpcbind port assignments for the Protocols allow connection sharing. In this case, the same transport parameters (such as inline threshold) apply to all Protocols using that connection.",
      "ja": "そのULBsはRPCオーバーRDMAバージョン1の使用を可能にし、プロトコルのrpcbindのポート割り当ては、接続共有を許可するとき、O、複数のULPは、単一のRPCオーバーRDMAバージョン1つの接続を共有することができます。この場合、（例えばインラインしきい値など）同一の転送パラメータは、その接続を使用して、すべてのプロトコルに適用されます。"
    },
    {
      "indent": 3,
      "text": "Each ULB needs to be designed to allow correct interoperation without regard to the transport parameters actually in use. Furthermore, implementations of ULPs must be designed to interoperate correctly regardless of the connection parameters in effect on a connection.",
      "ja": "各ULBは、実際に使用中のトランスポートパラメータに関係なく、正しい相互運用を許可するように設計する必要があります。さらに、のULPの実装は、接続上で正常にかかわらず、有効な接続パラメータの相互運用するように設計しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.4. ULP Extensions",
      "section_title": true,
      "ja": "6.4。 ULP拡張機能"
    },
    {
      "indent": 3,
      "text": "An RPC Program and Version tuple may be extensible. For instance, there may be a minor versioning scheme that is not reflected in the RPC version number, or the ULP may allow additional features to be specified after the original RPC Program specification was ratified.",
      "ja": "RPCプログラムとバージョンのタプルは、延伸性であってもよいです。例えば、そこRPCバージョン番号に反映されていないマイナーバージョン管理方式であってもよいし、ULPは、元のRPCプログラム仕様が批准された後に追加の特徴を指定することを可能にすることができます。"
    },
    {
      "indent": 3,
      "text": "ULBs are provided for interoperable RPC Programs and Versions by extending existing ULBs to reflect the changes made necessary by each addition to the existing XDR.",
      "ja": "ULBs既存XDRにそれぞれ添加することによって、必要な変更を反映するために、既存のULBsを拡張することによって、相互運用可能なRPCプログラムとバージョンのために提供されます。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Extensibility",
      "section_title": true,
      "ja": "7.プロトコルの拡張性"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA header format is specified using XDR, unlike the message header used with RPC-over-TCP. To maintain a high degree of interoperability among implementations of RPC-over-RDMA, any change to this XDR requires a protocol version number change. New versions of RPC-over-RDMA may be published as separate protocol specifications without updating this document.",
      "ja": "RPCオーバーRDMAヘッダフォーマットはRPCオーバー-TCPで使用されるメッセージヘッダとは異なり、XDRを使用して指定されます。 RPCオーバーRDMAの実装間の相互運用性の高い程度を維持するために、このXDRへの変更は、プロトコルのバージョン番号の変更を必要とします。 RPCオーバーRDMAの新バージョンでは、この文書を更新せずに別のプロトコル仕様として公開することができます。"
    },
    {
      "indent": 3,
      "text": "The first four fields in every RPC-over-RDMA header must remain aligned at the same fixed offsets for all versions of the RPC-over-RDMA protocol. The version number must be in a fixed place to enable implementations to detect protocol version mismatches.",
      "ja": "すべてのRPCオーバーRDMAヘッダの最初の4つのフィールドは、RPCオーバーRDMAプロトコルのすべてのバージョンの同じ固定オフセットで整列したままでなければなりません。バージョン番号は、プロトコルのバージョンの不一致を検出するための実装を可能にするために、一定の場所になければなりません。"
    },
    {
      "indent": 3,
      "text": "For version mismatches to be reported in a fashion that all future version implementations can reliably decode, the rdma_proc field must remain in a fixed place, the value of ERR_VERS must always remain the same, and the field placement in struct rpc_rdma_errvers must always remain the same.",
      "ja": "すべての将来のバージョンの実装が確実にデコードできるという形で報告されるバージョンの不一致のために、rdma_procフィールドが一定の場所に残っている必要があり、ERR_VERSの値は常に同じでなければならない、と構造体rpc_rdma_errvers内のフィールドの配置は、常に同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1. Conventional Extensions",
      "section_title": true,
      "ja": "7.1。従来の拡張機能"
    },
    {
      "indent": 3,
      "text": "Introducing new capabilities to RPC-over-RDMA version 1 is limited to the adoption of conventions that make use of existing XDR (defined in this document) and allowed abstract RDMA operations. Because no mechanism for detecting optional features exists in RPC-over-RDMA version 1, implementations must rely on ULPs to communicate the existence of such extensions.",
      "ja": "RPCオーバーRDMAバージョン1に新しい機能を導入すること（このドキュメントで定義された）既存のXDRと許さ抽象RDMA操作を利用する規則の採用に制限されています。オプション機能を検出するための機構はRPCオーバーRDMAバージョン1に存在しないため、実装は、そのような拡張機能の存在を通信するためのULPに頼らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Such extensions must be specified in a Standards Track RFC with appropriate review by the NFSv4 Working Group and the IESG. An example of a conventional extension to RPC-over-RDMA version 1 is the specification of backward direction message support to enable NFSv4.1 callback operations, described in [RFC8167].",
      "ja": "このような拡張は、NFSv4のワーキンググループとIESGによる適切なレビューに標準化過程RFCで指定する必要があります。 RPCオーバーRDMAバージョン1の従来拡張の例は、[RFC8167]に記載NFSv4.1コールバックオペレーションを有効にする逆方向メッセージのサポートの仕様です。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Memory Protection",
      "section_title": true,
      "ja": "8.1。メモリ保護"
    },
    {
      "indent": 3,
      "text": "A primary consideration is the protection of the integrity and confidentiality of local memory by an RPC-over-RDMA transport. The use of an RPC-over-RDMA transport protocol MUST NOT introduce vulnerabilities to system memory contents nor to memory owned by user processes.",
      "ja": "主な考慮事項は、RPCオーバーRDMA交通機関でのローカルメモリの完全性と機密性の保護です。 RPCオーバーRDMAトランスポートプロトコルを使用すると、システムメモリの内容にも、ユーザのプロセスが所有しているメモリへの脆弱性を導入してはなりません。"
    },
    {
      "indent": 3,
      "text": "It is REQUIRED that any RDMA provider used for RPC transport be conformant to the requirements of [RFC5042] in order to satisfy these protections. These protections are provided by the RDMA layer specifications, and in particular, their security models.",
      "ja": "RPCの輸送のために使用される任意のRDMAプロバイダがこれらの保護を満たすために[RFC5042]の要件に適合することが要求されます。これらの保護は、RDMA層の仕様によって提供され、特に、彼らのセキュリティモデルされています。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Protection Domains",
      "section_title": true,
      "ja": "8.1.1。保護ドメイン"
    },
    {
      "indent": 3,
      "text": "The use of Protection Domains to limit the exposure of memory regions to a single connection is critical. Any attempt by an endpoint not participating in that connection to reuse memory handles needs to result in immediate failure of that connection. Because ULP security mechanisms rely on this aspect of Reliable Connection behavior, strong authentication of remote endpoints is recommended.",
      "ja": "単一の接続にメモリ領域の露出を制限する保護ドメインの使用が重要です。メモリハンドルを再利用するために、その接続に参加していないエンドポイントによるいかなる試みは、その接続の即時失敗をもたらすことが必要です。 ULPのセキュリティメカニズムは、信頼性の高い接続の挙動のこの局面に依存しているため、リモートエンドポイントの強力な認証が推奨されます。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Handle Predictability",
      "section_title": true,
      "ja": "8.1.2。予測可能性を扱います"
    },
    {
      "indent": 3,
      "text": "Unpredictable memory handles should be used for any operation requiring advertised memory regions. Advertising a continuously registered memory region allows a remote host to read or write to that region even when an RPC involving that memory is not under way. Therefore, implementations should avoid advertising persistently registered memory.",
      "ja": "予測不可能なメモリハンドルをアドバタイズメモリ領域を必要とする任意の操作のために使用されるべきです。継続的に登録されたメモリ領域を公示すると、そのメモリを含むRPCが進んでいない場合でも、リモートホストがその領域に読み書きすることができます。そのため、実装は広告永続的に登録されたメモリを避ける必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Memory Protection",
      "section_title": true,
      "ja": "8.1.3。メモリ保護"
    },
    {
      "indent": 3,
      "text": "Requesters should register memory regions for remote access only when they are about to be the target of an RPC operation that involves an RDMA Read or Write.",
      "ja": "リクエスタは、彼らがRDMA読み取りや書き込みを必要とするRPC操作の対象としようとしている場合にのみ、リモートアクセスのためのメモリ領域を登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "Registered memory regions should be invalidated as soon as related RPC operations are complete. Invalidation and DMA unmapping of memory regions should be complete before message integrity checking is done and before the RPC consumer is allowed to continue execution and use or alter the contents of a memory region.",
      "ja": "登録されたメモリ領域は、すぐに関連するRPC操作が完了すると無効にする必要があります。メッセージの整合性チェックが行われる前とRPCの消費者は、実行を継続して使用するか、またはメモリ領域の内容を変更することが許可される前に無効化し、メモリ領域のDMAのマッピング解除が完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "An RPC transaction on a Requester might be terminated before a reply arrives if the RPC consumer exits unexpectedly (for example, it is signaled or a segmentation fault occurs). When an RPC terminates abnormally, memory regions associated with that RPC should be invalidated appropriately before the regions are released to be reused for other purposes on the Requester.",
      "ja": "RPCの消費者が予期せず終了した場合の応答が到着する前に、リクエスタ上のRPCトランザクションは、（例えば、それが合図やセグメンテーションフォールトが発生している）終了することがあります。 RPCが異常終了したときに領域をリクエスタ上の他の目的のために再利用されるように解放される前に、そのRPCに関連するメモリ領域を適切に無効化されるべきです。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Denial of Service",
      "section_title": true,
      "ja": "8.1.4。サービス拒否"
    },
    {
      "indent": 3,
      "text": "A detailed discussion of denial-of-service exposures that can result from the use of an RDMA transport is found in Section 6.4 of [RFC5042].",
      "ja": "RDMA輸送の使用に起因することができ、サービス拒否のエクスポージャーの詳細な議論は[RFC5042]のセクション6.4で発見されました。"
    },
    {
      "indent": 3,
      "text": "A Responder is not obliged to pull Read chunks that are unreasonably large. The Responder can use an RDMA_ERROR response to terminate RPCs with unreadable Read chunks. If a Responder transmits more data than a Requester is prepared to receive in a Write or Reply chunk, the RDMA Network Interface Cards (RNICs) typically terminate the connection. For further discussion, see Section 4.5. Such repeated chunk errors can deny service to other users sharing the connection from the errant Requester.",
      "ja": "Responderは不当に大きい読むチャンクをプルする義務はありません。 Responderは読めない読むチャンクでRPCを終了するためにRDMA_ERROR応答を使用することができます。リクエスタが書き込みで受信またはチャンクを返信する準備がよりResponderがより多くのデータを送信する場合は、RDMAネットワークインタフェースカード（RNICs）は、典型的には、接続を終了します。さらなる議論については、4.5節を参照してください。このような繰り返しチャンクエラーが誤っリクエスタからの接続を共有する他のユーザーへのサービスを拒否することができます。"
    },
    {
      "indent": 3,
      "text": "An RPC-over-RDMA transport implementation is not responsible for throttling the RPC request rate, other than to keep the number of concurrent RPC transactions at or under the number of credits granted per connection. This is explained in Section 3.3.1. A sender can trigger a self denial of service by exceeding the credit grant repeatedly.",
      "ja": "RPCオーバーRDMAトランスポート実装は、接続ごとに付与されたクレジットの数で、または下の同時RPCトランザクションの数を維持するよりも、他のRPC要求率を、絞るための責任を負いません。これは、セクション3.3.1で説明されています。送信者は、繰り返し信用助成金を超えることにより、サービスの自己否定をトリガすることができます。"
    },
    {
      "indent": 3,
      "text": "When an RPC has been canceled due to a signal or premature exit of an application process, a Requester may invalidate the RPC's Write and Reply chunks. Invalidation prevents the subsequent arrival of the Responder's reply from altering the memory regions associated with those chunks after the memory has been reused.",
      "ja": "RPCは、信号やアプリケーションプロセスの早期終了のためにキャンセルされた場合には、リクエスタは、RPCの書き込みを無効にし、チャンクを応答することができます。無効化は、メモリが再利用された後、それらのチャンクに関連付けられたメモリ領域を変更することから、レスポンダの応答の後続の到達を阻止します。"
    },
    {
      "indent": 3,
      "text": "On the Requester, a malfunctioning application or a malicious user can create a situation where RPCs are continuously initiated and then aborted, resulting in Responder replies that terminate the underlying RPC-over-RDMA connection repeatedly. Such situations can deny service to other users sharing the connection from that Requester.",
      "ja": "リクエスタに、誤動作アプリケーションまたは悪意のあるユーザーがRPCが連続的に開始し、その後中止されている状況を作り出すことができ、レスポンダをもたらすと、その繰り返し下にあるRPCオーバーRDMA接続を終了返信。このような状況では、リクエスタからの接続を共有する他のユーザーへのサービスを拒否することができます。"
    },
    {
      "indent": 0,
      "text": "8.2. RPC Message Security",
      "section_title": true,
      "ja": "8.2。 RPCメッセージセキュリティ"
    },
    {
      "indent": 3,
      "text": "ONC RPC provides cryptographic security via the RPCSEC_GSS framework [RFC7861]. RPCSEC_GSS implements message authentication (rpc_gss_svc_none), per-message integrity checking (rpc_gss_svc_integrity), and per-message confidentiality (rpc_gss_svc_privacy) in the layer above RPC-over-RDMA. The latter two services require significant computation and movement of data on each endpoint host. Some performance benefits enabled by RDMA transports can be lost.",
      "ja": "ONC RPCはRPCSEC_GSSフレームワーク[RFC7861]を介して、暗号のセキュリティを提供します。 RPCSEC_GSSは、RPCオーバーRDMA上層にメッセージ認証（rpc_gss_svc_none）、検査ごとのメッセージ完全性（rpc_gss_svc_integrity）、およびメッセージごとの機密性（rpc_gss_svc_privacy）を実装します。後者の2つのサービスは、各エンドポイント・ホスト上で重要計算とデータの移動を必要とします。 RDMAトランスポートで有効になっていくつかのパフォーマンス上の利点が失われることがあります。"
    },
    {
      "indent": 0,
      "text": "8.2.1. RPC-over-RDMA Protection at Lower Layers",
      "section_title": true,
      "ja": "8.2.1。 RPCオーバーRDMA保護下位層で"
    },
    {
      "indent": 3,
      "text": "For any RPC transport, utilizing RPCSEC_GSS integrity or privacy services has performance implications. Protection below the RPC transport is often more appropriate in performance-sensitive deployments, especially if it, too, can be offloaded. Certain configurations of IPsec can be co-located in RDMA hardware, for example, without change to RDMA consumers and little loss of data movement efficiency. Such arrangements can also provide a higher degree of privacy by hiding endpoint identity or altering the frequency at which messages are exchanged, at a performance cost.",
      "ja": "すべてのRPCの輸送については、RPCSEC_GSS整合性やプライバシーのサービスを利用すると、パフォーマンスに影響します。 RPCトランスポート下の保護は、それは、あまりにも、オフロードできる場合は特に、多くの場合、パフォーマンスに敏感な展開でより適切です。 IPsecの特定の構成は、RDMAの消費者に変更し、データ移動効率をほとんど損失することなく、例えば、RDMAハードウェアに同じ場所に配置することができます。このような構成は、パフォーマンスのコストで、エンドポイントの身元を隠したり、メッセージを交換する頻度を変更することによって、プライバシーの高い学位を提供することができます。"
    },
    {
      "indent": 3,
      "text": "The use of protection in a lower layer MAY be negotiated through the use of an RPCSEC_GSS security flavor defined in [RFC7861] in conjunction with the Channel Binding mechanism [RFC5056] and IPsec Channel Connection Latching [RFC5660]. Use of such mechanisms is REQUIRED where integrity or confidentiality is desired and where efficiency is required.",
      "ja": "下層の保護の使用は、チャネルバインディング機構[RFC5056]及び[RFC5660]をラッチのIPsecチャネル接続に関連して、[RFC7861]で定義されたRPCSEC_GSSセキュリティ風味の使用を介して交渉されるかもしれません。完全性や機密性が所望される場合と効率が要求されるような機構の使用が必要です。"
    },
    {
      "indent": 0,
      "text": "8.2.2. RPCSEC_GSS on RPC-over-RDMA Transports",
      "section_title": true,
      "ja": "8.2.2。 RPCオーバーRDMAトランスポート上のRPCSEC_GSS"
    },
    {
      "indent": 3,
      "text": "Not all RDMA devices and fabrics support the above protection mechanisms. Also, per-message authentication is still required on NFS clients where multiple users access NFS files. In these cases, RPCSEC_GSS can protect NFS traffic conveyed on RPC-over-RDMA connections.",
      "ja": "いないすべてのRDMAデバイスと生地は上記の保護メカニズムをサポートしています。また、メッセージごとの認証は、まだ複数のユーザーがNFSファイルにアクセスするNFSクライアントで必要とされます。これらのケースでは、RPCSEC_GSSは、NFSのトラフィックを保護することができRPCオーバーRDMA接続上を搬送。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS extends the ONC RPC protocol [RFC5531] without changing the format of RPC messages. By observing the conventions described in this section, an RPC-over-RDMA transport can convey RPCSEC_GSS-protected RPC messages interoperably.",
      "ja": "RPCSEC_GSSは、RPCメッセージのフォーマットを変更することなく、ONC RPCプロトコル[RFC5531]を延びています。このセクションで説明する規則を観察することで、RPCオーバーRDMAトランスポートは、相互運用可能RPCSEC_GSSで保護されたRPCメッセージを伝えることができます。"
    },
    {
      "indent": 3,
      "text": "As part of the ONC RPC protocol, protocol elements of RPCSEC_GSS that appear in the Payload stream of an RPC-over-RDMA message (such as control messages exchanged as part of establishing or destroying a security context or data items that are part of RPCSEC_GSS authentication material) MUST NOT be reduced.",
      "ja": "制御メッセージは、セキュリティコンテキストを確立するか、破壊の一部またはRPCSEC_GSS認証の一部であるデータ項目として交換（例えば、RPCオーバーRDMAメッセージのペイロード・ストリームに現れるONC RPCプロトコル、RPCSEC_GSSのプロトコル要素の一部として材料）が減少してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.2.1. RPCSEC_GSS Context Negotiation",
      "section_title": true,
      "ja": "8.2.2.1。 RPCSEC_GSSコンテキスト交渉"
    },
    {
      "indent": 3,
      "text": "Some NFS client implementations use a separate connection to establish a Generic Security Service (GSS) context for NFS operation. These clients use TCP and the standard NFS port (2049) for context establishment. To enable the use of RPCSEC_GSS with NFS/RDMA, an NFS server MUST also provide a TCP-based NFS service on port 2049.",
      "ja": "いくつかのNFSクライアントの実装は、NFS操作のための一般的なセキュリティサービス（GSS）コンテキストを確立するために、別の接続を使用します。これらのクライアントは、TCPおよびコンテキスト確立のための標準的なNFSポート（2049）を使用します。 NFS / RDMAとRPCSEC_GSSの使用を有効にするには、NFSサーバは、ポート2049上のTCPベースのNFSサービスを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.2.2. RPC-over-RDMA with RPCSEC_GSS Authentication",
      "section_title": true,
      "ja": "8.2.2.2。 RPCSEC_GSS認証でRPCオーバーRDMA"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS authentication service has no impact on the DDP-eligibility of data items in a ULP.",
      "ja": "RPCSEC_GSS認証サービスは、ULPのデータ項目のDDP-適格性に影響を及ぼしません。"
    },
    {
      "indent": 3,
      "text": "However, RPCSEC_GSS authentication material appearing in an RPC message header can be larger than, say, an AUTH_SYS authenticator. In particular, when an RPCSEC_GSS pseudoflavor is in use, a Requester needs to accommodate a larger RPC credential when marshaling RPC Call messages and needs to provide for a maximum size RPCSEC_GSS verifier when allocating reply buffers and Reply chunks.",
      "ja": "しかし、RPCメッセージヘッダに現れるRPCSEC_GSS認証物質はAUTH_SYS認証、たとえば、より大きくすることができます。 RPCSEC_GSSのpseudoflavorが使用されている場合、特に、リクエスタは、RPCコールメッセージをマーシャリングするとき、より大きなRPC資格を収容する必要があり、応答バッファと応答チャンクを割り当てるときの最大サイズRPCSEC_GSS検証のために提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "RPC messages, and thus Payload streams, are made larger as a result. ULP operations that fit in a Short Message when a simpler form of authentication is in use might need to be reduced, or conveyed via a Long Message, when RPCSEC_GSS authentication is in use. It is more likely that a Requester provides both a Read list and a Reply chunk in the same RPC-over-RDMA header to convey a Long Call and provision a receptacle for a Long Reply. More frequent use of Long Messages can impact transport efficiency.",
      "ja": "RPCメッセージ、従ってペイロードストリームは、結果として大きくされています。認証の単純な形式が使用されているときにショートメッセージに収まるULP操作はRPCSEC_GSS認証が使用されているときに、長いメッセージを経由して減少し、または搬送することが必要になる場合があります。リクエスタがロング返信用ロングコール・提供レセプタクルを伝えるために、同じRPCオーバーRDMAヘッダに読んリストと返信チャンクの両方を提供するという可能性が高いです。長いメッセージのより頻繁な使用は、輸送効率に影響を与えることができます。"
    },
    {
      "indent": 0,
      "text": "8.2.2.3. RPC-over-RDMA with RPCSEC_GSS Integrity or Privacy",
      "section_title": true,
      "ja": "8.2.2.3。 RPCSEC_GSSの整合性やプライバシーとRPCオーバーRDMA"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS integrity service enables endpoints to detect modification of RPC messages in flight. The RPCSEC_GSS privacy service prevents all but the intended recipient from viewing the cleartext content of RPC arguments and results. RPCSEC_GSS integrity and privacy services are end-to-end. They protect RPC arguments and results from application to server endpoint, and back.",
      "ja": "RPCSEC_GSSの整合性サービスは、飛行中にRPCメッセージの変更を検出するためのエンドポイントを可能にします。 RPCSEC_GSSプライバシーサービスは、RPCの引数と結果の平文コンテンツを表示から目的の受信者が、すべてを防ぐことができます。 RPCSEC_GSS整合性とプライバシーサービスは、エンド・ツー・エンドです。彼らは、アプリケーションからサーバーのエンドポイント、および背面にRPCの引数と結果を保護します。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS integrity and encryption services operate on whole RPC messages after they have been XDR encoded for transmit, and before they have been XDR decoded after receipt. Both sender and receiver endpoints use intermediate buffers to prevent exposure of encrypted data or unverified cleartext data to RPC consumers. After verification, encryption, and message wrapping has been performed, the transport layer MAY use RDMA data transfer between these intermediate buffers.",
      "ja": "彼らは、送信のためにエンコードされたXDRてきた、と前に彼らは受領後XDRを復号化した後RPCSEC_GSSの整合性および暗号化サービスは、全体のRPCメッセージを操作します。どちらも、送信側と受信側のエンドポイントは、暗号化されたデータやRPCの消費者への未検証平文データの露出を防ぐために、中間バッファを使用します。検証、暗号化、およびメッセージの折り返しが行われた後、トランスポート層は、これらの中間バッファとの間のRDMAデータ転送を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The process of reducing a DDP-eligible data item removes the data item and its XDR padding from the encoded XDR stream. XDR padding of a reduced data item is not transferred in an RPC-over-RDMA message. After reduction, the Payload stream contains fewer octets than the whole XDR stream did beforehand. XDR padding octets are often zero bytes, but they don't have to be. Thus, reducing DDP-eligible items affects the result of message integrity verification or encryption.",
      "ja": "DDP-対象データ項目の削減処理は、符号化されたXDRストリームからデータ項目とそのXDRパディングを除去します。縮小されたデータ項目のXDRパディングは、RPCオーバーRDMAメッセージに転送されません。還元後、ペイロードストリームは、全体のXDRストリームは事前にやったよりも少ないオクテットが含まれています。 XDRパディングオクテットは、多くの場合、ゼロバイトですが、彼らはする必要はありません。このように、DDP-適格項目を減らすことは、メッセージの整合性の検証や暗号化の結果に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Therefore, a sender MUST NOT reduce a Payload stream when RPCSEC_GSS integrity or encryption services are in use. Effectively, no data item is DDP-eligible in this situation, and Chunked Messages cannot be used. In this mode, an RPC-over-RDMA transport operates in the same manner as a transport that does not support DDP.",
      "ja": "RPCSEC_GSSの整合性または暗号化サービスを使用しているときしたがって、送信者は、ペイロード・ストリームを減らしてはなりません。実際には、何のデータ項目は、このような状況ではDDP-資格がない、とチャンク・メッセージを使用することはできません。このモードでは、RPCオーバーRDMA転送はDDPをサポートしていないトランスポートと同様に動作します。"
    },
    {
      "indent": 3,
      "text": "When an RPCSEC_GSS integrity or privacy service is in use, a Requester provides both a Read list and a Reply chunk in the same RPC-over-RDMA header to convey a Long Call and provision a receptacle for a Long Reply.",
      "ja": "RPCSEC_GSSの整合性やプライバシーのサービスが使用されている場合は、リクエスタは同じRPCオーバーRDMAヘッダロングコール・提供ロング返信用の容器を伝えるために読んリストと返信チャンクの両方を提供します。"
    },
    {
      "indent": 0,
      "text": "8.2.2.4. Protecting RPC-over-RDMA Transport Headers",
      "section_title": true,
      "ja": "8.2.2.4。 RPCオーバーRDMA転送ヘッダを保護します"
    },
    {
      "indent": 3,
      "text": "Like the base fields in an ONC RPC message (XID, call direction, and so on), the contents of an RPC-over-RDMA message's Transport stream are not protected by RPCSEC_GSS. This exposes XIDs, connection credit limits, and chunk lists (but not the content of the data items they refer to) to malicious behavior, which could redirect data that is transferred by the RPC-over-RDMA message, result in spurious retransmits, or trigger connection loss.",
      "ja": "ONC RPCメッセージ（XID、通話方向など）におけるベース・フィールドのような、RPCオーバーRDMAメッセージのトランスポートストリームの内容はRPCSEC_GSSによって保護されていません。これは、RPCオーバーRDMAメッセージによって転送されるデータをリダイレクトすることができ、悪意のある挙動にXIDを、接続信用限度、及びチャンクリスト（ただし、それらが参照するデータ項目の内容）を露出させるスプリアス再送をもたらす、又は接続損失を誘発します。"
    },
    {
      "indent": 3,
      "text": "In particular, if an attacker alters the information contained in the chunk lists of an RPC-over-RDMA header, data contained in those chunks can be redirected to other registered memory regions on Requesters. An attacker might alter the arguments of RDMA Read and RDMA Write operations on the wire to similar effect. If such alterations occur, the use of RPCSEC_GSS integrity or privacy services enable a Requester to detect unexpected material in a received RPC message.",
      "ja": "攻撃者はRPCオーバーRDMAヘッダのチャンクリストに含まれている情報を変更する場合は特に、これらのチャンクに含まれるデータは、リクエスタに他の登録されたメモリ領域にリダイレクトすることができます。攻撃者は、同様の効果にワイヤ上でRDMA ReadとRDMA書き込み操作の引数を変更することがあります。このような変更が発生した場合は、RPCSEC_GSSの整合性やプライバシーサービスの利用は、受け取ったRPCメッセージで予期しない材料を検出するために、リクエスタを可能にします。"
    },
    {
      "indent": 3,
      "text": "Encryption at lower layers, as described in Section 8.2.1, protects the content of the Transport stream. To address attacks on RDMA protocols themselves, RDMA transport implementations should conform to [RFC5042].",
      "ja": "セクション8.2.1に記載のように下位層での暗号化は、トランスポートストリームのコンテンツを保護します。 RDMAプロトコルそのものへの攻撃に対処するために、RDMAトランスポートの実装は、[RFC5042]に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "A set of RPC netids for resolving RPC-over-RDMA services is specified by this document. This is unchanged from [RFC5666].",
      "ja": "RPCオーバーRDMAサービスを解決するためのRPCのnetidsのセットは、この文書で指定されています。これは[RFC5666]から変更されていません。"
    },
    {
      "indent": 3,
      "text": "The RPC-over-RDMA transport has been assigned an RPC netid, which is an rpcbind [RFC1833] string used to describe the underlying protocol in order for RPC to select the appropriate transport framing, as well as the format of the service addresses and ports.",
      "ja": "RPCオーバーRDMA輸送は、適切なトランスポート・フレーミング、ならびにサービス・アドレスとポートの形式を選択するためにRPCために、基礎となるプロトコルを記述するために使用されるのrpcbind [RFC1833]の文字列であるRPCのNETIDを、割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The following netid registry strings are defined for this purpose:",
      "ja": "次NETIDのレジストリ文字列は、この目的のために定義されています。"
    },
    {
      "indent": 6,
      "text": "NC_RDMA \"rdma\" NC_RDMA6 \"rdma6\"",
      "ja": "NC_RDMA \"RDMA\" NC_RDMA6 \"rdma6\""
    },
    {
      "indent": 3,
      "text": "The \"rdma\" netid is to be used when IPv4 addressing is employed by the underlying transport, and \"rdma6\" for IPv6 addressing. The netid assignment policy and registry are defined in [RFC5665].",
      "ja": "「RDMA」NETIDは、IPv4アドレッシングをIPv6アドレスのための基礎となるトランスポートによって使用され、「rdma6」されるときに使用されます。 NETID割り当てポリシーとレジストリは[RFC5665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "These netids MAY be used for any RDMA network that satisfies the requirements of Section 2.3.2 and that is able to identify service endpoints using IP port addressing, possibly through use of a translation service as described in Section 5.",
      "ja": "これらnetidsは、セクション2.3.2の要件を満たす任意のRDMAネットワークのために使用されてもよく、それはセクション5で説明したように、おそらく翻訳サービスを使用することにより、アドレッシングのIPポートを使用して、サービス・エンドポイントを識別することができます。"
    },
    {
      "indent": 3,
      "text": "The use of the RPC-over-RDMA protocol has no effect on RPC Program numbers or existing registered port numbers. However, new port numbers MAY be registered for use by RPC-over-RDMA-enabled services, as appropriate to the new networks over which the services will operate.",
      "ja": "RPCオーバーRDMAプロトコルを使用すると、RPCプログラム番号または既存の登録されているポート番号には影響しません。しかし、新しいポート番号はサービスが動作する上で新しいネットワークに応じて、RPCオーバーRDMA対応のサービスで使用するために登録することも可能です。"
    },
    {
      "indent": 3,
      "text": "For example, the NFS/RDMA service defined in [RFC5667] has been assigned the port 20049 in the \"Service Name and Transport Protocol Port Number Registry\". This is distinct from the port number defined for NFS on TCP, which is assigned the port 2049 in the same registry. NFS clients use the same RPC Program number for NFS (100003) when using either transport [RFC5531] (see the \"Remote Procedure Call (RPC) Program Numbers\" registry).",
      "ja": "例えば、[RFC5667]で定義されたNFS / RDMAサービスは、「サービス名とトランスポートプロトコルポート番号レジストリ」でポート20049が割り当てられています。これは、同じレジストリのポート2049に割り当てられているTCPにNFS用に定義されたポート番号とは区別されます。輸送[RFC5531]のいずれかを使用している場合、NFSクライアントは、NFSのために、同じRPCプログラム番号（100003）を使用します（「リモートプロシージャコール（RPC）プログラム番号」レジストリを参照してください）。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1833] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, DOI 10.17487/RFC1833, August 1995, <http://www.rfc-editor.org/info/rfc1833>.",
      "ja": "[RFC1833]スリニバサン、R.、 \"ONC RPCバージョン2のプロトコルのバインド\"、RFC 1833、DOI 10.17487 / RFC1833、1995年8月、<http://www.rfc-editor.org/info/rfc1833>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <http://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506]アイスラー、M.、エド、 \"XDR：外部データ表現標準\"。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<http://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5042] Pinkerton, J. and E. Deleganes, \"Direct Data Placement Protocol (DDP) / Remote Direct Memory Access Protocol (RDMAP) Security\", RFC 5042, DOI 10.17487/RFC5042, October 2007, <http://www.rfc-editor.org/info/rfc5042>.",
      "ja": "[RFC5042]ピンカートン、J.およびE. Deleganes、 \"直接データ配置プロトコル（DDP）/リモートダイレクトメモリアクセスプロトコル（RDMAP）セキュリティ\"、RFC 5042、DOI 10.17487 / RFC5042、2007年10月、<のhttp：// WWW。 rfc-editor.org/info/rfc5042>。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <http://www.rfc-editor.org/info/rfc5056>.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、DOI 10.17487 / RFC5056、2007年11月、<http://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5531] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <http://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[RFC5531] Thurlow、R.、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、<http://www.rfc-editor.org/info/rfc5531>。"
    },
    {
      "indent": 3,
      "text": "[RFC5660] Williams, N., \"IPsec Channels: Connection Latching\", RFC 5660, DOI 10.17487/RFC5660, October 2009, <http://www.rfc-editor.org/info/rfc5660>.",
      "ja": "[RFC5660]ウィリアムズ、N.、 \"IPsecのチャンネル：接続ラッチ\"、RFC 5660、DOI 10.17487 / RFC5660、2009年10月、<http://www.rfc-editor.org/info/rfc5660>。"
    },
    {
      "indent": 3,
      "text": "[RFC5665] Eisler, M., \"IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats\", RFC 5665, DOI 10.17487/RFC5665, January 2010, <http://www.rfc-editor.org/info/rfc5665>.",
      "ja": "[RFC5665]アイスラー、M.、RFC 5665、DOI 10.17487 / RFC5665、2010年1月、< \"リモートプロシージャコール（RPC）のネットワーク識別子とユニバーサルアドレス形式用IANAの考慮事項\" http://www.rfc-editor.org/情報/ rfc5665>。"
    },
    {
      "indent": 3,
      "text": "[RFC7861] Adamson, A. and N. Williams, \"Remote Procedure Call (RPC) Security Version 3\", RFC 7861, DOI 10.17487/RFC7861, November 2016, <http://www.rfc-editor.org/info/rfc7861>.",
      "ja": "[RFC7861]アダムソン、A.およびN.ウィリアムズ、 \"リモートプロシージャコール（RPC）Securityバージョン3\"、RFC 7861、DOI 10.17487 / RFC7861、2016年11月、<http://www.rfc-editor.org/info/ rfc7861>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <http://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<http://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[IBARCH] InfiniBand Trade Association, \"InfiniBand Architecture Specification Volume 1\", Release 1.3, March 2015, <http://www.infinibandta.org/content/ pages.php?pg=technology_download>.",
      "ja": "[IBARCH]インフィニバンド展覧会、 \"インフィニバンドアーキテクチャ仕様の第1巻\"、2015年3月、1.3をリリース、<http://www.infinibandta.org/content/ pages.php？PG = technology_download>。"
    },
    {
      "indent": 3,
      "text": "[RFC768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <http://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、<http://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC1094] Nowicki, B., \"NFS: Network File System Protocol specification\", RFC 1094, DOI 10.17487/RFC1094, March 1989, <http://www.rfc-editor.org/info/rfc1094>.",
      "ja": "[RFC1094] Nowicki、B.、 \"NFS：ネットワークシステムプロトコル仕様書ファイル\"、RFC 1094、DOI 10.17487 / RFC1094を、1989年3月、<http://www.rfc-editor.org/info/rfc1094>。"
    },
    {
      "indent": 3,
      "text": "[RFC1813] Callaghan, B., Pawlowski, B., and P. Staubach, \"NFS Version 3 Protocol Specification\", RFC 1813, DOI 10.17487/RFC1813, June 1995, <http://www.rfc-editor.org/info/rfc1813>.",
      "ja": "[RFC1813]キャラハン、B.、ポロウスキー、B.、およびP.ストーバック、 \"NFSバージョン3プロトコル仕様\"、RFC 1813、DOI 10.17487 / RFC1813、1995年6月、<http://www.rfc-editor.org/情報/ RFC1813>。"
    },
    {
      "indent": 3,
      "text": "[RFC5040] Recio, R., Metzler, B., Culley, P., Hilland, J., and D. Garcia, \"A Remote Direct Memory Access Protocol Specification\", RFC 5040, DOI 10.17487/RFC5040, October 2007, <http://www.rfc-editor.org/info/rfc5040>.",
      "ja": "[RFC5040] Recio、R.、メッツラー、B.、Culley、P.、Hilland、J.、およびD.ガルシア、 \"リモートダイレクトメモリアクセスプロトコル仕様\"、RFC 5040、DOI 10.17487 / RFC5040、2007年10月、< http://www.rfc-editor.org/info/rfc5040>。"
    },
    {
      "indent": 3,
      "text": "[RFC5041] Shah, H., Pinkerton, J., Recio, R., and P. Culley, \"Direct Data Placement over Reliable Transports\", RFC 5041, DOI 10.17487/RFC5041, October 2007, <http://www.rfc-editor.org/info/rfc5041>.",
      "ja": "\"信頼性の高いトランスポート上で直接データ配置\" [RFC5041]シャー、H.、ピンカートン、J.、Recio、R.、およびP. Culley、RFC 5041、DOI 10.17487 / RFC5041、2007年10月、<のhttp：// WWW。 rfc-editor.org/info/rfc5041>。"
    },
    {
      "indent": 3,
      "text": "[RFC5532] Talpey, T. and C. Juszczak, \"Network File System (NFS) Remote Direct Memory Access (RDMA) Problem Statement\", RFC 5532, DOI 10.17487/RFC5532, May 2009, <http://www.rfc-editor.org/info/rfc5532>.",
      "ja": "[RFC5532] Talpey、T.とC. Juszczak、 \"ネットワークファイルシステム（NFS）リモートダイレクトメモリアクセス（RDMA）問題文\"、RFC 5532、DOI 10.17487 / RFC5532、2009年5月、<のhttp：//www.rfc- editor.org/info/rfc5532>。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <http://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<http://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description\", RFC 5662, DOI 10.17487/RFC5662, January 2010, <http://www.rfc-editor.org/info/rfc5662>.",
      "ja": "[RFC5662] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）の説明\"、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、<http://www.rfc-editor.org/info/rfc5662>。"
    },
    {
      "indent": 3,
      "text": "[RFC5666] Talpey, T. and B. Callaghan, \"Remote Direct Memory Access Transport for Remote Procedure Call\", RFC 5666, DOI 10.17487/RFC5666, January 2010, <http://www.rfc-editor.org/info/rfc5666>.",
      "ja": "[RFC5666] Talpey、T.とB.キャラハン、 \"リモートプロシージャコールのためのリモートダイレクトメモリアクセス交通\"、RFC 5666、DOI 10.17487 / RFC5666、2010年1月、<http://www.rfc-editor.org/info/ rfc5666>。"
    },
    {
      "indent": 3,
      "text": "[RFC5667] Talpey, T. and B. Callaghan, \"Network File System (NFS) Direct Data Placement\", RFC 5667, DOI 10.17487/RFC5667, January 2010, <http://www.rfc-editor.org/info/rfc5667>.",
      "ja": "[RFC5667] Talpey、T.及びB.キャラハン、 \"ネットワークファイルシステム（NFS）直接データ配置\"、RFC 5667、DOI 10.17487 / RFC5667、2010年1月、<http://www.rfc-editor.org/info/ rfc5667>。"
    },
    {
      "indent": 3,
      "text": "[RFC7530] Haynes, T., Ed. and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <http://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[RFC7530]ヘインズ、T.、エド。そして、D. Noveck、エド。、 \"ネットワークファイルシステム（NFS）バージョン4プロトコル\"、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<http://www.rfc-editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[RFC8167] Lever, C., \"Bidirectional Remote Procedure Call on RPC-over-RDMA Transports\", RFC 8167, DOI 10.17487/RFC8167, June 2017, <http://www.rfc-editor.org/info/rfc8167>.",
      "ja": "[RFC8167]レバー、C.、 \"RPCオーバーRDMAトランスポートの双方向リモートプロシージャコール\"、RFC 8167、DOI 10.17487 / RFC8167、2017年6月、<http://www.rfc-editor.org/info/rfc8167> 。"
    },
    {
      "indent": 1,
      "text": "Appendix A. Changes from",
      "ja": "付録A.からの変更点"
    },
    {
      "indent": 0,
      "text": "A.1. Changes to the Specification",
      "ja": "A.1。仕様の変更"
    },
    {
      "indent": 3,
      "text": "The following alterations have been made to the RPC-over-RDMA version 1 specification. The section numbers below refer to [RFC5666].",
      "ja": "以下の変更は、RPCオーバーRDMAバージョン1つの仕様になされています。以下のセクション番号は、[RFC5666]を参照します。"
    },
    {
      "indent": 3,
      "text": "o Section 2 has been expanded to introduce and explain key RPC [RFC5531], XDR [RFC4506], and RDMA [RFC5040] terminology. These terms are now used consistently throughout the specification.",
      "ja": "O部2は、導入して、キーRPC [RFC5531]、XDR [RFC4506]、およびRDMA [RFC5040]の用語を説明するために拡張されました。これらの用語は、今や明細書を通して一貫して使用されています。"
    },
    {
      "indent": 3,
      "text": "o Section 3 has been reorganized and split into subsections to help readers locate specific requirements and definitions.",
      "ja": "O部3は、再編成され、読者が特定の要件と定義を見つけやすくするためのサブセクションに分割されました。"
    },
    {
      "indent": 3,
      "text": "o Sections 4 and 5 have been combined to improve the organization of this information.",
      "ja": "Oセクション4及び5は、この情報の組織化を改善するために結合されています。"
    },
    {
      "indent": 3,
      "text": "o The optional Connection Configuration Protocol has never been implemented. The specification of CCP has been deleted from this specification.",
      "ja": "オプションの接続O構成プロトコルが実装されていません。 CCPの仕様は、この仕様書から削除されました。"
    },
    {
      "indent": 3,
      "text": "o A section consolidating requirements for ULBs has been added.",
      "ja": "O ULBsの要件を統合するセクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "o An XDR extraction mechanism is provided, along with full copyright, matching the approach used in [RFC5662].",
      "ja": "O XDR抽出機構は、[RFC5662]で使用されるアプローチと一致する、完全な著作権と共に、設けられています。"
    },
    {
      "indent": 3,
      "text": "o The \"Security Considerations\" section has been expanded to include a discussion of how RPC-over-RDMA security depends on features of the underlying RDMA transport.",
      "ja": "O「セキュリティの考慮事項」セクションには、RPCオーバーRDMAのセキュリティは基本的なRDMA輸送の機能にどのように依存するかの議論を含むように拡張されました。"
    },
    {
      "indent": 3,
      "text": "o A subsection describing the use of RPCSEC_GSS [RFC7861] with RPC-over-RDMA version 1 has been added.",
      "ja": "O RPCオーバーRDMAバージョン1とRPCSEC_GSS [RFC7861]を使用することを記述項が追加されています。"
    },
    {
      "indent": 0,
      "text": "A.2. Changes to the Protocol",
      "ja": "A.2。議定書への変更"
    },
    {
      "indent": 3,
      "text": "Although the protocol described herein interoperates with existing implementations of [RFC5666], the following changes have been made relative to the protocol described in that document:",
      "ja": "本明細書に記載のプロトコルは[RFC5666]の既存の実装と相互運用しているが、以下の変更は、その文書に記載のプロトコルに対してなされています。"
    },
    {
      "indent": 3,
      "text": "o Support for the Read-Read transfer model has been removed. Read-Read is a slower transfer model than Read-Write. As a result, implementers have chosen not to support it. Removal of Read-Read simplifies explanatory text, and the RDMA_DONE procedure is no longer part of the protocol.",
      "ja": "Oリード・リード転送モデルのサポートが削除されました。読み取り読み取り読み取り書き込みよりも遅い転送モデルです。その結果、実装者はそれをサポートしないことを選択しました。リード - リードの除去は、説明文を簡素化し、RDMA_DONE手順は、プロトコルの一部ではなくなりました。"
    },
    {
      "indent": 3,
      "text": "o The specification of RDMA_MSGP in [RFC5666] is not adequate, although some incomplete implementations exist. Even if an adequate specification were provided and an implementation were produced, benefit for protocols such as NFSv4.0 [RFC7530] is doubtful. Therefore, the RDMA_MSGP message type is no longer supported.",
      "ja": "いくつかの不完全な実装が存在するが[RFC5666]でRDMA_MSGPの仕様O、十分ではありません。適切な仕様を提供し、実装を製造したとしても、そのようなNFSv4.0 [RFC7530]は疑わしいなどのプロトコルのために利益を得ます。したがって、RDMA_MSGPメッセージタイプはサポートされなくなりました。"
    },
    {
      "indent": 3,
      "text": "o Technical issues with regard to handling RPC-over-RDMA header errors have been corrected.",
      "ja": "O RPCオーバーRDMAヘッダエラーを処理に関する技術的な問題が修正されました。"
    },
    {
      "indent": 3,
      "text": "o Specific requirements related to implicit XDR roundup and complex XDR data types have been added.",
      "ja": "O暗黙のXDRの総まとめと複雑なXDRのデータ型に関連する具体的な要件が追加されました。"
    },
    {
      "indent": 3,
      "text": "o Explicit guidance is provided related to sizing Write chunks, managing multiple chunks in the Write list, and handling unused Write chunks.",
      "ja": "O明示的なガイダンスは、書き込みチャンクのサイズを決定する書き込みリスト内の複数のチャンクを管理し、未使用の書き込みチャンクの処理に関連されています。"
    },
    {
      "indent": 3,
      "text": "o Clear guidance about Send and Receive buffer sizes has been introduced. This enables better decisions about when a Reply chunk must be provided.",
      "ja": "Oの明確な指針についてのバッファサイズを送信および受信導入されています。これは、返信チャンクが提供されなければならない場合についてのより良い意思決定を可能にします。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor gratefully acknowledges the work of Brent Callaghan and Tom Talpey on the original RPC-over-RDMA Version 1 specification [RFC5666].",
      "ja": "エディタは感謝して、元のRPCオーバーRDMAバージョン1仕様[RFC5666]のブレントキャラハンとトムTalpeyの仕事を認めています。"
    },
    {
      "indent": 3,
      "text": "Dave Noveck provided excellent review, constructive suggestions, and consistent navigational guidance throughout the process of drafting this document. Dave also contributed much of the organization and content of Section 7 and helped the authors understand the complexities of XDR extensibility.",
      "ja": "デイブNoveckは優れたレビュー、建設的な提案、この文書を起草の過程全体で一貫したナビゲーション案内を提供します。 Daveはまた、組織や第7節の内容の多くを貢献したと著者はXDRの拡張の複雑さを理解して助けました。"
    },
    {
      "indent": 3,
      "text": "The comments and contributions of Karen Deitke, Dai Ngo, Chunli Zhang, Dominique Martinet, and Mahesh Siddheshwar are accepted with great thanks. The editor also wishes to thank Bill Baker, Greg Marsden, and Matt Benjamin for their support of this work.",
      "ja": "カレンDeitke、大Ngoの、春麗張、ドミニク・マルティネ、およびマヘシュシッドゥシュワーのコメントと貢献は偉大なおかげで受け入れられています。エディタは、この作品の彼らのサポートのためにビル・ベイカー、グレッグ・マースデン、そしてマット・ベンジャミンに感謝したいです。"
    },
    {
      "indent": 3,
      "text": "The extract.sh shell script and formatting conventions were first described by the authors of the NFSv4.1 XDR specification [RFC5662].",
      "ja": "extract.shシェルスクリプトとフォーマッティング規則は、第NFSv4.1 XDR仕様[RFC5662]の著者によって記述されました。"
    },
    {
      "indent": 3,
      "text": "Special thanks go to Transport Area Director Spencer Dawkins, NFSV4 Working Group Chair and Document Shepherd Spencer Shepler, and NFSV4 Working Group Secretary Thomas Haynes for their support.",
      "ja": "特別な感謝は彼らのサポートのための交通エリアディレクタースペンサードーキンスのNFSv4ワーキンググループの議長およびドキュメントシェパードスペンサーShepler、とのNFSv4ワーキンググループ長官トマス・ヘインズに行きます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Charles Lever (editor) Oracle Corporation 1015 Granger Avenue Ann Arbor, MI 48104 United States of America",
      "ja": "チャールズ・レバー（エディタ）オラクル・コーポレーション1015グレンジャーアベニューアナーバー、ミシガンアメリカの48104米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 248 816 6463 Email: chuck.lever@oracle.com",
      "ja": "電話：+1 248 816 6463 Eメール：chuck.lever@oracle.com"
    },
    {
      "indent": 3,
      "text": "William Allen Simpson Red Hat 1384 Fontaine Madison Heights, MI 48071 United States of America",
      "ja": "アメリカのウィリアムアレンシンプソンのRed Hat 1384フォンテーヌマディソンハイツ、ミシガン48071米国"
    },
    {
      "indent": 3,
      "text": "Email: william.allen.simpson@gmail.com",
      "ja": "メール：william.allen.simpson@gmail.com"
    },
    {
      "indent": 3,
      "text": "Tom Talpey Microsoft Corp. One Microsoft Way Redmond, WA 98052 United States of America",
      "ja": "トムTalpeyマイクロソフト社1マイクロソフト道、レッドモンド、ワシントンアメリカの98052米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 704-9945 Email: ttalpey@microsoft.com",
      "ja": "電話：+1 425 704-9945 Eメール：ttalpey@microsoft.com"
    }
  ]
}