{
  "title": {
    "text": "RFC 8095 - Services Provided by IETF Transport Protocols and Congestion Control Mechanisms",
    "ja": "RFC 8095 - IETFトランスポートプロトコルと輻輳制御メカニズムによって提供されるサービス"
  },
  "number": 8095,
  "created_at": "2019-10-23 06:54:03.683862+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 G. Fairhurst, Ed.\nRequest for Comments: 8095                        University of Aberdeen\nCategory: Informational                                 B. Trammell, Ed.\nISSN: 2070-1721                                       M. Kuehlewind, Ed.\n                                                              ETH Zurich\n                                                              March 2017",
      "raw": true
    },
    {
      "indent": 7,
      "text": "                   Services Provided by\nIETF Transport Protocols and Congestion Control Mechanisms",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes, surveys, and classifies the protocol mechanisms provided by existing IETF protocols, as background for determining a common set of transport services. It examines the Transmission Control Protocol (TCP), Multipath TCP, the Stream Control Transmission Protocol (SCTP), the User Datagram Protocol (UDP), UDP-Lite, the Datagram Congestion Control Protocol (DCCP), the Internet Control Message Protocol (ICMP), the Real-Time Transport Protocol (RTP), File Delivery over Unidirectional Transport / Asynchronous Layered Coding (FLUTE/ALC) for Reliable Multicast, NACK-Oriented Reliable Multicast (NORM), Transport Layer Security (TLS), Datagram TLS (DTLS), and the Hypertext Transport Protocol (HTTP), when HTTP is used as a pseudotransport. This survey provides background for the definition of transport services within the TAPS working group.",
      "ja": "この文書では、説明の調査、およびトランスポート・サービスの共通セットを決定するための背景として、既存のIETFプロトコルによって提供されるプロトコルメカニズムを分類します。これは、伝送制御プロトコル（TCP）、マルチパスTCP、ストリーム制御伝送プロトコル（SCTP）、ユーザーデータグラムプロトコル（UDP）、UDP-Liteは、データグラム輻輳制御プロトコル（DCCP）、インターネット制御メッセージプロトコル（ICMPを調べ）、リアルタイムトランスポートプロトコル（RTP）、単方向交通/非同期階層にわたるファイル配信信頼できるマルチキャストのために（FLUTE / ALC）をコーディング、NACK指向リライアブルマルチキャスト（NORM）、トランスポート層セキュリティ（TLS）、データグラムTLS（DTLS ）、およびHTTPをpseudotransportとして使用されるハイパーテキスト転送プロトコル（HTTP）。この調査では、TAPSワーキンググループ内の輸送サービスの定義のための背景を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8095.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8095で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Overview of Transport Features .............................4\n2. Terminology .....................................................5\n3. Existing Transport Protocols ....................................6\n   3.1. Transport Control Protocol (TCP) ...........................6\n        3.1.1. Protocol Description ................................6\n        3.1.2. Interface Description ...............................8\n        3.1.3. Transport Features ..................................9\n   3.2. Multipath TCP (MPTCP) .....................................10\n        3.2.1. Protocol Description ...............................10\n        3.2.2. Interface Description ..............................10\n        3.2.3. Transport Features .................................11\n   3.3. User Datagram Protocol (UDP) ..............................11\n        3.3.1. Protocol Description ...............................11\n        3.3.2. Interface Description ..............................12\n        3.3.3. Transport Features .................................13\n   3.4. Lightweight User Datagram Protocol (UDP-Lite) .............13\n        3.4.1. Protocol Description ...............................13\n        3.4.2. Interface Description ..............................14\n        3.4.3. Transport Features .................................14\n   3.5. Stream Control Transmission Protocol (SCTP) ...............14\n        3.5.1. Protocol Description ...............................15\n        3.5.2. Interface Description ..............................17\n        3.5.3. Transport Features .................................19\n   3.6. Datagram Congestion Control Protocol (DCCP) ...............20\n        3.6.1. Protocol Description ...............................21\n        3.6.2. Interface Description ..............................22\n        3.6.3. Transport Features .................................22",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   3.7. Transport Layer Security (TLS) and Datagram TLS\n        (DTLS) as a Pseudotransport ...............................23\n        3.7.1. Protocol Description ...............................23\n        3.7.2. Interface Description ..............................24\n        3.7.3. Transport Features .................................25\n   3.8. Real-Time Transport Protocol (RTP) ........................26\n        3.8.1. Protocol Description ...............................26\n        3.8.2. Interface Description ..............................27\n        3.8.3. Transport Features .................................27\n   3.9. Hypertext Transport Protocol (HTTP) over TCP as a\n        Pseudotransport ...........................................28\n        3.9.1. Protocol Description ...............................28\n        3.9.2. Interface Description ..............................29\n        3.9.3. Transport Features .................................30\n   3.10. File Delivery over Unidirectional Transport /\n         Asynchronous Layered Coding (FLUTE/ALC) for\n         Reliable Multicast .......................................31\n        3.10.1. Protocol Description ..............................31\n        3.10.2. Interface Description .............................33\n        3.10.3. Transport Features ................................33\n   3.11. NACK-Oriented Reliable Multicast (NORM) ..................34\n        3.11.1. Protocol Description ..............................34\n        3.11.2. Interface Description .............................35\n        3.11.3. Transport Features ................................36\n   3.12. Internet Control Message Protocol (ICMP) .................36\n        3.12.1. Protocol Description ..............................37\n        3.12.2. Interface Description .............................37\n        3.12.3. Transport Features ................................38\n4. Congestion Control .............................................38\n5. Transport Features .............................................39\n6. IANA Considerations ............................................42\n7. Security Considerations ........................................42\n8. Informative References .........................................42\nAcknowledgments ...................................................53\nContributors ......................................................53\nAuthors' Addresses ................................................54",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Internet applications make use of the services provided by a transport protocol, such as TCP (a reliable, in-order stream protocol) or UDP (an unreliable datagram protocol). We use the term \"transport service\" to mean the end-to-end service provided to an application by the transport layer. That service can only be provided correctly if information about the intended usage is supplied from the application. The application may determine this information at design time, compile time, or run time, and may include guidance on whether a feature is required, a preference by the application, or something in between. Examples of features of transport services are reliable delivery, ordered delivery, content privacy to in-path devices, and integrity protection.",
      "ja": "インターネットアプリケーションは、TCP（信頼性、インオーダーストリームプロトコル）またはUDP（信頼性のないデータグラムプロトコル）などのトランスポートプロトコルによって提供されるサービスの利用を作ります。私たちは、トランスポート層でアプリケーションに提供するエンドツーエンドのサービスを意味する用語「トランスポートサービス」を使用しています。意図した使用状況に関する情報は、アプリケーションから供給された場合、そのサービスにのみ正確に提供することができます。アプリケーションは、設計時にこの情報を決定する時間をコンパイル、または時間を実行し、機能が必要かどうかについてのガイダンス、アプリケーション、または間に何かによって好みが含まれることがあります。輸送サービスの機能の例としては、信頼性の高い配信、注文配達、パス内のデバイスへのコンテンツ、プライバシー、および完全性保護されています。"
    },
    {
      "indent": 3,
      "text": "The IETF has defined a wide variety of transport protocols beyond TCP and UDP, including SCTP, DCCP, MPTCP, and UDP-Lite. Transport services may be provided directly by these transport protocols or layered on top of them using protocols such as WebSockets (which runs over TCP), RTP (over TCP or UDP) or WebRTC data channels (which run over SCTP over DTLS over UDP or TCP). Services built on top of UDP or UDP-Lite typically also need to specify additional mechanisms, including a congestion control mechanism (such as NewReno [RFC6582], TCP-Friendly Rate Control (TFRC) [RFC5348], or Low Extra Delay Background Transport (LEDBAT) [RFC6817]). This extends the set of available transport services beyond those provided to applications by TCP and UDP.",
      "ja": "IETFは、TCPやUDPなど、SCTP、DCCP、MPTCP、およびUDP-Liteの越えたトランスポートプロトコルを幅広く定義されています。トランスポートサービスは、UDPまたはTCP上DTLS上でSCTP上で実行する（これらのトランスポートプロトコルによって直接提供されるか、または、そのような（TCP上で動作）WebSocketを、RTP（TCPまたはUDP経由）またはのWebRTCデータチャネルなどのプロトコルを使用して、それらの上に積層してもよいです）。 UDPまたはUDP-Liteの上に構築されたサービスは、一般的にも、そのようなNewRenoの[RFC6582]などの輻輳制御機構（含む、追加のメカニズムを指定する必要があり、TCPフレンドリーレート制御（TFRC）[RFC5348]、または低余分な遅延の背景トランスポート（ LEDBAT）[RFC6817]）。これは、TCPとUDPによってアプリケーションに提供されるものを越えて利用できる輸送サービスのセットを拡張します。"
    },
    {
      "indent": 3,
      "text": "The transport protocols described in this document provide a basis for the definition of transport services provided by common protocols, as background for the TAPS working group. The protocols listed here were chosen to help expose as many potential transport services as possible and are not meant to be a comprehensive survey or classification of all transport protocols.",
      "ja": "このドキュメントで説明するトランスポートプロトコルは、TAPSワーキンググループの背景として、共通のプロトコルが提供する輸送サービスの定義のための基礎を提供します。ここに記載されているプロトコルは、できるだけ多くの潜在的な輸送サービスを公開し、すべてのトランスポートプロトコルの包括的な調査または分類するものではない助けるために選ばれました。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview of Transport Features",
      "section_title": true,
      "ja": "1.1。交通機能の概要"
    },
    {
      "indent": 3,
      "text": "Transport protocols can be differentiated by the features of the services they provide.",
      "ja": "トランスポートプロトコルは、彼らが提供するサービスの特徴によって区別することができます。"
    },
    {
      "indent": 3,
      "text": "Some of these provided features are closely related to basic control function that a protocol needs to work over a network path, such as addressing. The number of participants in a given association also determines its applicability: a connection can be between endpoints (unicast), to one of multiple endpoints (anycast), or simultaneously to multiple endpoints (multicast). Unicast protocols usually support bidirectional communication, while multicast is generally unidirectional. Another feature is whether a transport requires a control exchange across the network at setup (e.g., TCP) or whether it is connectionless (e.g., UDP).",
      "ja": "これら提供される機能の一部は密接プロトコルは、アドレッシングとして、ネットワーク経路上で動作する必要がある基本的な制御機能に関連しています。所与の関連の参加者の数は、その適用性を決定する：接続は、複数のエンドポイント（エニーキャスト）のいずれかに、または同時に複数のエンドポイント（マルチキャスト）に、エンドポイント（ユニキャスト）の間とすることができます。マルチキャストは、一般的に一方向である一方、ユニキャストプロトコルは通常、双方向通信をサポートしています。もう一つの特徴は、トランスポートは、セットアップでネットワークを介して制御交換を（例えば、TCP）が必要かどうか、それは（例えば、UDP）コネクションレスであるかどうかです。"
    },
    {
      "indent": 3,
      "text": "For packet delivery itself, reliability and integrity protection, ordering, and framing are basic features. However, these features are implemented with different levels of assurance in different protocols. As an example, a transport service may provide full reliability, with detection of loss and retransmission (e.g., TCP). SCTP offers a message-based service that can provide full or partial reliability and allows the protocol to minimize the head-of-line blocking due to the support of ordered and unordered message delivery within multiple streams. UDP-Lite and DCCP can provide partial integrity protection to enable corruption tolerance.",
      "ja": "パケット配信自体、信頼性、完全性保護、発注、およびフレーミングのための基本的な機能です。しかし、これらの機能は、異なるプロトコルで保証の異なるレベルで実装されています。一例として、トランスポート・サービスは、損失および再送の検出（例えば、TCP）と、完全な信頼性を提供してもよいです。 SCTPは、完全または部分的な信頼性を提供することができ、メッセージベースのサービスを提供し、プロトコルが原因複数のストリーム内の規則的順不同メッセージ配信のサポートにヘッドオブラインブロッキングを最小化することを可能にします。 UDP-LiteのとDCCPは汚職トレランスを有効にするために、部分的完全性保護を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Usually, a protocol has been designed to support one specific type of delivery/framing: either data needs to be divided into transmission units based on network packets (datagram service) or a data stream is segmented and re-combined across multiple packets (stream service). Whole objects such as files are handled accordingly. This decision strongly influences the interface that is provided to the upper layer.",
      "ja": "通常、プロトコルは、送達/フレーミングの一つの特定のタイプをサポートするように設計されている：データは、ネットワークパケット（データグラムサービス）またはデータストリームに基づいて送信単位に分割する必要があるいずれかのセグメントと複数のパケットを横切って再結合される（ストリームサービス）。ファイルなどのオブジェクト全体がそれに応じて処理されます。この決定は強く、上位層に提供されたインタフェースに影響を与えます。"
    },
    {
      "indent": 3,
      "text": "In addition, transport protocols offer a certain support for transmission control. For example, a transport service can provide flow control to allow a receiver to regulate the transmission rate of a sender. Further, a transport service can provide congestion control (see Section 4). As an example, TCP and SCTP provide congestion control for use in the Internet, whereas UDP leaves this function to the upper-layer protocol that uses UDP.",
      "ja": "また、トランスポートプロトコルは、伝送制御のための特定のサポートを提供します。例えば、トランスポート・サービスは、受信者が送信者の送信レートを調整することを可能にするフロー制御を提供することができます。さらに、トランスポート・サービス（セクション4を参照）は、輻輳制御を提供することができます。 UDPは、UDPを使用する上位層プロトコルにこの機能を残す一方、例として、TCPとSCTPは、インターネットで使用するための輻輳制御を提供します。"
    },
    {
      "indent": 3,
      "text": "Security features are often provided independently of the transport protocol, via Transport Layer Security (TLS) (see Section 3.7) or by the application-layer protocol itself. The security properties TLS provides to the application (such as confidentiality, integrity, and authenticity) are also features of the transport layer, even though they are often presently implemented in a separate protocol.",
      "ja": "セキュリティ機能は、多くの場合、トランスポート層セキュリティ（TLS）（3.7節を参照）を介して、またはアプリケーション層のプロトコル自体によって、独立したトランスポートプロトコルの提供しています。 TLSは、（例えば、機密性、完全性、及び真偽などの）アプリケーションに提供するセキュリティ・プロパティは、それらがしばしば現在別のプロトコルで実装されていても、また、トランスポート層の特徴です。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The following terms are used throughout this document and in subsequent documents produced by the TAPS working group that describe the composition and decomposition of transport services.",
      "ja": "以下の用語は、この文書全体と輸送サービスの合成と分解を記述TAPSワーキンググループによって作成、その後のドキュメントで使用されています。"
    },
    {
      "indent": 3,
      "text": "Transport Feature: a specific end-to-end feature that the transport layer provides to an application. Examples include confidentiality, reliable delivery, ordered delivery, message-versus-stream orientation, etc.",
      "ja": "トランスポート機能：トランスポート層は、アプリケーションに提供し、特定のエンドツーエンド機能。例としては、などの機密性、信頼性の高い配信、配信を命じ、メッセージ対流れの向きを含み、"
    },
    {
      "indent": 3,
      "text": "Transport Service: a set of transport features, without an association to any given framing protocol, that provides a complete service to an application.",
      "ja": "輸送サービス：輸送機能のセット、アプリケーションへの完全なサービスを提供し、任意のフレーミングプロトコルへの関連、なし。"
    },
    {
      "indent": 3,
      "text": "Transport Protocol: an implementation that provides one or more different transport services using a specific framing and header format on the wire.",
      "ja": "トランスポートプロトコル：ワイヤ上の特定のフレーミングヘッダフォーマットを使用して1つ以上の異なるトランスポートサービスを提供して実装。"
    },
    {
      "indent": 3,
      "text": "Application: an entity that uses the transport layer for end-to-end delivery data across the network (this may also be an upper-layer protocol or tunnel encapsulation).",
      "ja": "アプリケーション：ネットワーク全体のエンドツーエンド配信データのためのトランスポート層を使用するエンティティ（これはまた、上位層プロトコルまたはトンネルカプセル化することができます）。"
    },
    {
      "indent": 0,
      "text": "3. Existing Transport Protocols",
      "section_title": true,
      "ja": "3.既存のトランスポートプロトコル"
    },
    {
      "indent": 3,
      "text": "This section provides a list of known IETF transport protocols and transport protocol frameworks. It does not make an assessment about whether specific implementations of protocols are fully compliant to current IETF specifications.",
      "ja": "このセクションでは、知られているIETFトランスポートプロトコルおよびトランスポートプロトコルのフレームワークのリストを提供します。これは、プロトコルの特定の実装が、現在IETF仕様に完全に準拠しているかどうかについての評価を行うことはありません。"
    },
    {
      "indent": 0,
      "text": "3.1. Transport Control Protocol (TCP)",
      "section_title": true,
      "ja": "3.1。伝送制御プロトコル（TCP）"
    },
    {
      "indent": 3,
      "text": "TCP is an IETF Standards Track transport protocol. [RFC793] introduces TCP as follows:",
      "ja": "TCPは、IETF標準化過程のトランスポートプロトコルです。次のように[RFC793] TCPが導入されています。"
    },
    {
      "indent": 6,
      "text": "The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and in interconnected systems of such networks.",
      "ja": "伝送制御プロトコル（TCP）は、パケット交換コンピュータ通信ネットワークにおいて、そのようなネットワークの相互接続システムのホストとの間の信頼性の高いホスト間プロトコルとして使用するために意図されています。"
    },
    {
      "indent": 3,
      "text": "Since its introduction, TCP has become the default connection-oriented, stream-based transport protocol in the Internet. It is widely implemented by endpoints and widely used by common applications.",
      "ja": "導入以来、TCPはインターネットでのデフォルトの接続指向、ストリームベースのトランスポートプロトコルとなっています。それは広く、エンドポイントによって実装されており、広く一般的なアプリケーションで使用されます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Protocol Description",
      "section_title": true,
      "ja": "3.1.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "TCP is a connection-oriented protocol that provides a three-way handshake to allow a client and server to set up a connection and negotiate features and provides mechanisms for orderly completion and immediate teardown of a connection [RFC793] [TCP-SPEC]. TCP is defined by a family of RFCs (see [RFC7414]).",
      "ja": "TCPは、クライアントとサーバーが接続を設定し、機能を交渉できるようにするために3ウェイハンドシェイクを提供し、秩序ある完了し、接続[RFC793] [TCP-SPEC]の即時解体するためのメカニズムを提供し、接続指向のプロトコルです。 TCPは、（[RFC7414]を参照）RFCの家族によって定義されます。"
    },
    {
      "indent": 3,
      "text": "TCP provides multiplexing to multiple sockets on each host using port numbers. A similar approach is adopted by other IETF-defined transports. An active TCP session is identified by its four-tuple of local and remote IP addresses and local and remote port numbers. The destination port during connection setup is often used to indicate the requested service.",
      "ja": "TCPポート番号を使用して、各ホスト上の複数のソケットへの多重化を提供します。同様のアプローチは他のIETF定義のトランスポートによって採用されています。アクティブなTCPセッションは、ローカルおよびリモートのIPアドレスとローカルとリモートのポート番号の4つのタプルで識別されます。接続設定中の宛先ポートは、多くの場合、要求されたサービスを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "TCP partitions a continuous stream of bytes into segments, sized to fit in IP packets based on a negotiated maximum segment size and further constrained by the effective Maximum Transmission Unit (MTU) from Path MTU Discovery (PMTUD). ICMP-based PMTUD [RFC1191] [RFC1981] as well as Packetization Layer PMTUD (PLPMTUD) [RFC4821] have been defined by the IETF.",
      "ja": "TCPパーティションセグメントにバイトの連続ストリーム、ネゴシエートされた最大セグメントサイズに基づいて、IPパケットに適合するような大きさ、さらにパスMTUディスカバリ（PMTUD）から有効な最大伝送単位（MTU）によって制約。 ICMPベースPMTUD [RFC1191]、[RFC1981]と同様にパケット化レイヤPMTUD（PLPMTUD）[RFC4821]はIETFによって定義されています。"
    },
    {
      "indent": 3,
      "text": "Each byte in the stream is identified by a sequence number. The sequence number is used to order segments on receipt, to identify segments in acknowledgments, and to detect unacknowledged segments for retransmission. This is the basis of the reliable, ordered delivery of data in a TCP stream. TCP Selective Acknowledgment (SACK) [RFC2018] extends this mechanism by making it possible to provide earlier identification of which segments are missing, allowing faster retransmission. SACK-based methods (e.g., Duplicate Selective ACK) can also result in less spurious retransmission.",
      "ja": "ストリーム内の各バイトは、シーケンス番号によって識別されます。シーケンス番号は、受信時にセグメントを注文する肯定応答内のセグメントを識別するために、再送のための未確認のセグメントを検出するために使用されます。これは信頼できるの基本である、TCPストリーム内のデータの受け渡しを命じました。 TCP選択的確認応答（SACK）[RFC2018]は高速再送を可能にすることが可能セグメントが欠落している以前の識別を提供することによってこのメカニズムを拡張します。 SACKベースの方法（例えば、複製選択的ACK）も少ないスプリアス再送をもたらすことができます。"
    },
    {
      "indent": 3,
      "text": "Receiver flow control is provided by a sliding window, which limits the amount of unacknowledged data that can be outstanding at a given time. The window scale option [RFC7323] allows a receiver to use windows greater than 64 KB.",
      "ja": "受信フロー制御は、所定の時間に未処理であることができる未確認データの量を制限するスライディングウィンドウによって提供されます。ウィンドウスケールオプション[RFC7323]は、受信機が64 KBよりも大きいウィンドウを使用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "All TCP senders provide congestion control, such as that described in [RFC5681]. TCP uses a sequence number with a sliding receiver window for flow control. The TCP congestion control mechanism also utilizes this TCP sequence number to manage a separate congestion window [RFC5681]. The sending window at a given point in time is the minimum of the receiver window and the congestion window. The congestion window is increased in the absence of congestion and decreased if congestion is detected. Often, loss is implicitly handled as a congestion indication, which is detected in TCP (also as input for retransmission handling) based on two mechanisms: a retransmission timer with exponential back-off or the reception of three acknowledgments for the same segment, so called \"duplicated ACKs\" (fast retransmit). In addition, Explicit Congestion Notification (ECN) [RFC3168] can be used in TCP and, if supported by both endpoints, allows a network node to signal congestion without inducing loss. Alternatively, a delay-based congestion control scheme that reacts to changes in delay as an early indication of congestion can be used in TCP. This is further described in Section 4. Examples of different kinds of congestion control schemes are provided in Section 4.",
      "ja": "すべてのTCP送信者は、[RFC5681]に記載されているように、輻輳制御を提供します。 TCPは、フロー制御のためのスライディング受信ウィンドウとシーケンス番号を使用します。 TCP輻輳制御機構はまた、別輻輳ウィンドウ[RFC5681]を管理するには、このTCPシーケンス番号を利用します。特定の時点で送信ウインドウは、受信ウィンドウと輻輳ウィンドウの最小値です。輻輳ウィンドウは、輻輳の不在下で増加し、輻輳が検出された場合に減少します。指数バックオフまたは同じセグメントのための3つの肯定応答の受信と再送タイマー、いわゆる：多くの場合、損失は、暗黙的に（また、再送処理のための入力として）は、2つのメカニズムに基づいて、TCPで検出された輻輳表示、として扱われます「重複のACK」（高速再送信）。両方のエンドポイントでサポートされている場合に加えて、明示的輻輳通知（ECN）[RFC3168]は、TCPで使用することができ、ネットワーク・ノードは、損失を誘導することなく、輻輳をシグナリングすることを可能にします。代替的に、輻輳の早期指標として遅延の変化に反応する遅延ベースの輻輳制御方式がTCPで使用することができます。これはさらに、輻輳制御方式の異なる種類の4例はセクション4に設けられているセクションに記載されています。"
    },
    {
      "indent": 3,
      "text": "TCP protocol instances can be extended (see [RFC7414]). Some protocol features may also be tuned to optimize for a specific deployment scenario. Some features are sender-side only, requiring no negotiation with the receiver; some are receiver-side only; and some are explicitly negotiated during connection setup.",
      "ja": "TCPプロトコルインスタンスは、（[RFC7414]を参照）を拡張することができます。いくつかのプロトコル機能は、特定の展開シナリオを最適化するように調整することができます。一部の機能のみを送信側、受信側で何の交渉を必要としないです。いくつかは受信側のみです。そして、いくつかは明示的に接続のセットアップ中にネゴシエートされています。"
    },
    {
      "indent": 3,
      "text": "TCP may buffer data, e.g., to optimize processing or capacity usage. TCP therefore provides mechanisms to control this, including an optional \"PUSH\" function [RFC793] that explicitly requests the transport service not to delay data. By default, TCP segment partitioning uses Nagle's algorithm [TCP-SPEC] to buffer data at the sender into large segments, potentially incurring sender-side buffering delay; this algorithm can be disabled by the sender to transmit more immediately, e.g., to reduce latency for interactive sessions.",
      "ja": "TCP処理や容量使用率を最適化するために、例えば、データをバッファリングすることができます。 TCPは、したがって、明示的にデータを遅延させない輸送サービスを要求するオプションの「PUSH」関数[RFC793]を含む、これを制御するためのメカニズムを提供します。デフォルトでは、TCPセグメント分割は、潜在的に送信側のバッファリング遅延を招く、大きなセグメントに送信側でデータをバッファリングするNagleアルゴリズム[TCP-SPEC]を使用します。このアルゴリズムは、対話型セッションのための待ち時間を短縮するために、例えば、より即時に送信するために送信者によって無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "TCP provides an \"urgent data\" function for limited out-of-order delivery of the data. This function is deprecated [RFC6093].",
      "ja": "TCPはデータの制限アウトオブオーダー配信のための「緊急データ」機能を提供します。この機能は、[RFC6093]を推奨されていません。"
    },
    {
      "indent": 3,
      "text": "A TCP Reset (RST) control message may be used to force a TCP endpoint to close a session [RFC793], aborting the connection.",
      "ja": "TCPリセット（RST）制御メッセージは、接続を中断、セッション[RFC793]を閉じるために、TCPエンドポイントを強制するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "A mandatory checksum provides a basic integrity check against misdelivery and data corruption over the entire packet. Applications that require end-to-end integrity of data are recommended to include a stronger integrity check of their payload data. The TCP checksum [RFC1071] [RFC2460] does not support partial payload protection (as in DCCP/UDP-Lite).",
      "ja": "必須チェックサムは、パケット全体にわたり誤配やデータ破損に対する基本的な整合性チェックを提供します。データのエンドツーエンドの整合性を必要とするアプリケーションは、そのペイロードデータの強力な整合性チェックを含めることが推奨されています。 TCPチェックサム[RFC1071] [RFC2460]は（DCCP / UDP-Liteのような）部分ペイロード保護をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "TCP supports only unicast connections.",
      "ja": "TCPは、ユニキャスト接続をサポートしています。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Interface Description",
      "section_title": true,
      "ja": "3.1.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "The User/TCP Interface defined in [RFC793] provides six user commands: Open, Send, Receive, Close, Status, and Abort. This interface does not describe configuration of TCP options or parameters aside from the use of the PUSH and URGENT flags.",
      "ja": "オープン、送信、受信、閉じる、ステータス、および中止：で定義されたユーザ/ TCPインタフェースは、[RFC793] 6つのユーザーコマンドを提供します。このインタフェースは、PUSHとURGENT旗の使用は別にTCPオプションやパラメータの設定については説明しません。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] describes extensions of the TCP/application-layer interface for:",
      "ja": "[RFC1122]はのためのTCP /アプリケーション層インタフェースの拡張について説明します。"
    },
    {
      "indent": 3,
      "text": "o reporting soft errors such as reception of ICMP error messages, extensive retransmission, or urgent pointer advance,",
      "ja": "OこのようなICMPエラーメッセージの受信、広範囲の再送、または緊急ポインタ予めとしてソフトエラーを報告し、"
    },
    {
      "indent": 3,
      "text": "o providing a possibility to specify the Differentiated Services Code Point (DSCP) [RFC3260] (formerly, the Type-of-Service (TOS)) for segments,",
      "ja": "差別化サービスコードポイント（DSCP）[RFC3260]を指定する可能性を提供O（以前は、タイプオブサービス（TOS））セグメントについて、"
    },
    {
      "indent": 3,
      "text": "o providing a flush call to empty the TCP send queue, and",
      "ja": "TCPの送信キューを空にするためのフラッシュコールを提供し、そしてO"
    },
    {
      "indent": 3,
      "text": "o multihoming support.",
      "ja": "Oサポートをマルチホーミング。"
    },
    {
      "indent": 3,
      "text": "In API implementations derived from the BSD Sockets API, TCP sockets are created using the \"SOCK_STREAM\" socket type as described in the IEEE Portable Operating System Interface (POSIX) Base Specifications [POSIX]. The features used by a protocol instance may be set and tuned via this API. There are currently no documents in the RFC Series that describe this interface.",
      "ja": "BSDソケットAPIに由来するAPIの実装では、TCPソケットは、IEEEポータブルオペレーティングシステムインタフェース（POSIX）ベース仕様[POSIX]に記載されているように「SOCK_STREAM」ソケット・タイプを使用して作成されます。プロトコルインスタンスによって使用される機能を設定し、このAPIを介して調整することができます。このインタフェースを記述するRFCシリーズに文書はありません。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Transport Features",
      "section_title": true,
      "ja": "3.1.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by TCP are:",
      "ja": "TCPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o connection-oriented transport with feature negotiation and application-to-port mapping (implemented using SYN segments and the TCP Option field to negotiate features),",
      "ja": "O機能ネゴシエーションおよびアプリケーション・ツー・ポートマッピング（機能をネゴシエートするSYNセグメントとTCPオプションフィールドを使用して実装される）との接続指向の輸送、"
    },
    {
      "indent": 3,
      "text": "o unicast transport (though anycast TCP is implemented, at risk of instability due to rerouting),",
      "ja": "、ユニキャストトランスポート（エニーキャストTCPが実装されても、再ルーティングに起因する不安定性のリスクがある）をO"
    },
    {
      "indent": 3,
      "text": "o port multiplexing,",
      "ja": "Oポートの多重化、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication,",
      "ja": "一方向又は双方向通信O、"
    },
    {
      "indent": 3,
      "text": "o stream-oriented delivery in a single stream,",
      "ja": "単一ストリーム中のOストリーム指向の配信、"
    },
    {
      "indent": 3,
      "text": "o fully reliable delivery (implemented using ACKs sent from the receiver to confirm delivery),",
      "ja": "完全に信頼性の高い配信（配信を確認するために、受信機から送信されたACKを使用して実装）O-"
    },
    {
      "indent": 3,
      "text": "o error detection (implemented using a segment checksum to verify delivery to the correct endpoint and integrity of the data and options),",
      "ja": "（データおよびオプションの正しいエンドポイントとの整合性への送達を確認するために、セグメントチェックサムを使用して実装）Oエラー検出、"
    },
    {
      "indent": 3,
      "text": "o segmentation,",
      "ja": "ああ、セグメンテーション、"
    },
    {
      "indent": 3,
      "text": "o data bundling (optional; uses Nagle's algorithm to coalesce data sent within the same RTT into full-sized segments),",
      "ja": "Oデータ（オプション、フルサイズのセグメントに同じRTT内に送信されたデータを合体するNagleアルゴリズムを使用して）束ね、"
    },
    {
      "indent": 3,
      "text": "o flow control (implemented using a window-based mechanism where the receiver advertises the window that it is willing to buffer), and",
      "ja": "Oフロー制御、（受信機は、バッファても構わないと思っているウィンドウを広告ウィンドウベースのメカニズムを使用して実現される）と"
    },
    {
      "indent": 3,
      "text": "o congestion control (usually implemented using a window-based mechanism and four algorithms for different phases of the transmission: slow start, congestion avoidance, fast retransmit, and fast recovery [RFC5681]).",
      "ja": "O輻輳制御（通常送信の異なる位相のためのウィンドウ・ベース機構と4つのアルゴリズムを使用して実装：スロースタート、輻輳回避、高速再送信、および高速リカバリ[RFC5681]）。"
    },
    {
      "indent": 0,
      "text": "3.2. Multipath TCP (MPTCP)",
      "section_title": true,
      "ja": "3.2。マルチTCP（MPTCP）"
    },
    {
      "indent": 3,
      "text": "Multipath TCP [RFC6824] is an extension for TCP to support multihoming for resilience, mobility, and load balancing. It is designed to be as indistinguishable to middleboxes from non-multipath TCP as possible. It does so by establishing regular TCP flows between a pair of source/destination endpoints and multiplexing the application's stream over these flows. Sub-flows can be started over IPv4 or IPv6 for the same session.",
      "ja": "マルチパスTCP [RFC6824]はTCPが回復力、モビリティ、および負荷分散のためのマルチホーミングをサポートするために拡張したものです。可能な限り非マルチパスTCPからミドルボックスのように区別できないように設計されています。それはそう定期的にTCPを確立することにより、送信元/宛先エンドポイントのペアの間を流れ、これらのフロー上でアプリケーションのストリームを多重ありません。サブフローは、同じセッションのためにIPv4またはIPv6上で開始することができます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Protocol Description",
      "section_title": true,
      "ja": "3.2.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "MPTCP uses TCP options for its control plane. They are used to signal multipath capabilities, as well as to negotiate data sequence numbers, advertise other available IP addresses, and establish new sessions between pairs of endpoints.",
      "ja": "MPTCPは、その制御プレーンのためのTCPオプションを使用しています。彼らは、マルチパス機能を知らせるために、だけでなく、データのシーケンス番号を交渉するために使用され、他の利用可能なIPアドレスを宣伝し、エンドポイントのペアの間に新しいセッションを確立します。"
    },
    {
      "indent": 3,
      "text": "By multiplexing one byte stream over separate paths, MPTCP can achieve a higher throughput than TCP in certain situations. However, if coupled congestion control [RFC6356] is used, it might limit this benefit to maintain fairness to other flows at the bottleneck. When aggregating capacity over multiple paths, and depending on the way packets are scheduled on each TCP subflow, additional delay and higher jitter might be observed before in-order delivery of data to the applications.",
      "ja": "別々の経路上の多重化1バイトのストリームによって、MPTCPは、特定の状況でTCPよりも高いスループットを達成することができます。結合された輻輳制御[RFC6356]が使用される場合は、それがボトルネックで他のフローに公平性を維持するために、この利点を制限するかもしれません。複数のパス上に容量を集約し、パケットは各TCPサブフローでスケジュールされる方法に依存するとき、追加の遅延と、より高いジッタはアプリケーションへのデータの順序配信の前に観察されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Interface Description",
      "section_title": true,
      "ja": "3.2.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "By default, MPTCP exposes the same interface as TCP to the application. [RFC6897], however, describes a richer API for MPTCP-aware applications.",
      "ja": "デフォルトでは、MPTCPは、アプリケーションへのTCPと同じインターフェイスを公開します。 [RFC6897]は、しかし、MPTCP対応アプリケーションのための豊かなAPIを説明しています。"
    },
    {
      "indent": 3,
      "text": "This Basic API describes how an application can:",
      "ja": "どのアプリケーションができます。この基本的なAPIを説明します。"
    },
    {
      "indent": 3,
      "text": "o enable or disable MPTCP.",
      "ja": "O MPTCPを有効または無効にします。"
    },
    {
      "indent": 3,
      "text": "o bind a socket to one or more selected local endpoints.",
      "ja": "O一の以上選択されたローカルエンドポイントにソケットをバインドします。"
    },
    {
      "indent": 3,
      "text": "o query local and remote endpoint addresses.",
      "ja": "Oローカルおよびリモートエンドポイントのアドレスを問い合わせます。"
    },
    {
      "indent": 3,
      "text": "o get a unique connection identifier (similar to an address-port pair for TCP).",
      "ja": "O（TCP用のアドレスポートのペアに類似）のユニークな接続識別子を取得します。"
    },
    {
      "indent": 3,
      "text": "The document also recommends the use of extensions defined for SCTP [RFC6458] (see Section 3.5) to support multihoming for resilience and mobility.",
      "ja": "文書はまた、SCTP [RFC6458]のために定義された拡張機能を使用することを推奨しています弾力性とモビリティのためのマルチホーミングをサポートするために、（3.5節を参照してください）。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Transport Features",
      "section_title": true,
      "ja": "3.2.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "As an extension to TCP, MPTCP provides mostly the same features. By establishing multiple sessions between available endpoints, it can additionally provide soft failover solutions in the case that one of the paths becomes unusable.",
      "ja": "TCPの拡張として、MPTCPはほとんど同じ機能を提供します。利用可能なエンドポイントとの間で複数のセッションを確立することによって、それはさらに、パスのいずれかが使用不能になった場合にソフトフェイルオーバー・ソリューションを提供することができます。"
    },
    {
      "indent": 3,
      "text": "Therefore, the transport features provided by MPTCP in addition to TCP are:",
      "ja": "そのため、TCPに加えてMPTCPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o multihoming for load balancing, with endpoint multiplexing of a single byte stream, using either coupled congestion control or throughput maximization,",
      "ja": "O、結合された輻輳制御やスループットの最大化のいずれかを使用して、単一のバイトストリームのエンドポイント多重化して、負荷分散のためにマルチホーミング"
    },
    {
      "indent": 3,
      "text": "o address family multiplexing (using IPv4 and IPv6 for the same session), and",
      "ja": "Oアドレスファミリ多重化（同じセッションのためにIPv4とIPv6を使用して）、および"
    },
    {
      "indent": 3,
      "text": "o resilience to network failure and/or handover.",
      "ja": "ネットワーク障害及び/又はハンドオーバ弾力O。"
    },
    {
      "indent": 0,
      "text": "3.3. User Datagram Protocol (UDP)",
      "section_title": true,
      "ja": "3.3。ユーザーデータグラムプロトコル（UDP）"
    },
    {
      "indent": 3,
      "text": "The User Datagram Protocol (UDP) [RFC768] [RFC2460] is an IETF Standards Track transport protocol. It provides a unidirectional datagram protocol that preserves message boundaries. It provides no error correction, congestion control, or flow control. It can be used to send broadcast datagrams (IPv4) or multicast datagrams (IPv4 and IPv6), in addition to unicast and anycast datagrams. IETF guidance on the use of UDP is provided in [RFC8085]. UDP is widely implemented and widely used by common applications, including DNS.",
      "ja": "ユーザデータグラムプロトコル（UDP）[RFC768] [RFC2460]はIETF標準化過程のトランスポートプロトコルです。これは、メッセージの境界を維持する一方向のデータグラムプロトコルを提供します。これは、エラー訂正、輻輳制御、またはフロー制御を提供していません。ユニキャストとエニーキャストデータグラムに加えて、ブロードキャストデータグラム（IPv4の）またはマルチキャストデータグラム（IPv4およびIPv6）を送信するために使用することができます。 UDPの使用に関するIETFガイダンスは、[RFC8085]で提供されています。 UDPは、広く実装され、広くDNSなどの一般的なアプリケーションで使用されています。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Protocol Description",
      "section_title": true,
      "ja": "3.3.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "UDP is a connectionless protocol that maintains message boundaries, with no connection setup or feature negotiation. The protocol uses independent messages, ordinarily called \"datagrams\". It provides detection of payload errors and misdelivery of packets to an unintended endpoint, both of which result in discard of received datagrams, with no indication to the user of the service.",
      "ja": "UDPは、未接続の設定時または機能の交渉で、メッセージの境界を維持コネクションレスプロトコルです。プロトコルは通常、「データグラム」と呼ばれ、独立したメッセージを使用しています。これは、サービスのユーザに対して表示なしで、受信したデータグラムの破棄をもたらすどちらも、意図しないエンドポイントにペイロードエラーとパケットの誤配の検出を提供します。"
    },
    {
      "indent": 3,
      "text": "It is possible to create IPv4 UDP datagrams with no checksum, and while this is generally discouraged [RFC1122] [RFC8085], certain special cases permit this use. These datagrams rely on the IPv4 header checksum to protect from misdelivery to an unintended endpoint. IPv6 does not permit UDP datagrams with no checksum, although in certain cases [RFC6936], this rule may be relaxed [RFC6935].",
      "ja": "チェックサムなしではIPv4 UDPデータグラムを作成することが可能であり、これは一般的に推奨されている間、[RFC1122] [RFC8085]は、特定の特別な場合には、この使用を許可します。これらのデータグラムは、予期しないエンドポイントに誤配信から保護するために、IPv4ヘッダチェックサムに依存しています。特定の例[RFC6936]で、このルールが緩和[RFC6935]かもしれないがIPv6は、ノーチェックサムとUDPデータグラムを許可していません。"
    },
    {
      "indent": 3,
      "text": "UDP does not provide reliability and does not provide retransmission. Messages may be reordered, lost, or duplicated in transit. Note that due to the relatively weak form of checksum used by UDP, applications that require end-to-end integrity of data are recommended to include a stronger integrity check of their payload data.",
      "ja": "UDPは信頼性を提供しないと、再送信を提供していません。メッセージは、並べ替え紛失、または輸送中に重複することがあります。原因UDP、データのエンドツーエンドの整合性を必要とするアプリケーションで使用されるチェックサムの比較的弱い形に彼らのペイロードデータの強力な整合性チェックを含めることが推奨されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Because UDP provides no flow control, a receiving application that is unable to run sufficiently fast, or frequently, may miss messages. The lack of congestion handling implies UDP traffic may experience loss when using an overloaded path and may cause the loss of messages from other protocols (e.g., TCP) when sharing the same network path.",
      "ja": "UDPは、フロー制御、十分に速い、または頻繁に実行することができません受信側のアプリケーションを提供していないため、メッセージを見逃すことがあります。輻輳処理の欠如は、UDPトラフィックが過負荷のパスを使用した場合の損失が発生する可能性があり、同じネットワークパスを共有する場合、他のプロトコル（例えば、TCP）からのメッセージの損失を引き起こす可能性を示唆しています。"
    },
    {
      "indent": 3,
      "text": "On transmission, UDP encapsulates each datagram into a single IP packet or several IP packet fragments. This allows a datagram to be larger than the effective path MTU. Fragments are reassembled before delivery to the UDP receiver, making this transparent to the user of the transport service. When jumbograms are supported, larger messages may be sent without performing fragmentation.",
      "ja": "トランスミッションには、UDPは、単一のIPパケットまたは複数のIPパケットのフラグメントに各データグラムをカプセル化します。これは、データグラムが有効なパスMTUよりも大きくすることを可能にします。フラグメントは、トランスポート・サービスの利用者に対して、これは透明にすること、UDPの受信機に配信する前に再構成されます。ジャンボグラムがサポートされている場合、より大きなメッセージが断片化を行わずに送信することができます。"
    },
    {
      "indent": 3,
      "text": "UDP on its own does not provide support for segmentation, receiver flow control, congestion control, PMTUD/PLPMTUD, or ECN. Applications that require these features need to provide them on their own or use a protocol over UDP that provides them [RFC8085].",
      "ja": "自分自身でUDPは、セグメンテーション、受信フロー制御、輻輳制御、PMTUD / PLPMTUD、またはECNのサポートを提供していません。これらの機能を必要とするアプリケーションは、自分自身でそれらを提供するか、またはそれらを提供してUDP上のプロトコル[RFC8085]を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Interface Description",
      "section_title": true,
      "ja": "3.3.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "[RFC768] describes basic requirements for an API for UDP. Guidance on the use of common APIs is provided in [RFC8085].",
      "ja": "[RFC768] UDPのためのAPIのための基本的な要件について説明します。一般的なAPIの使用に関するガイダンスは、[RFC8085]に提供されます。"
    },
    {
      "indent": 3,
      "text": "A UDP endpoint consists of a tuple of (IP address, port number). De-multiplexing using multiple abstract endpoints (sockets) on the same IP address is supported. The same socket may be used by a single server to interact with multiple clients. (Note: This behavior differs from TCP, which uses a pair of tuples to identify a connection). Multiple server instances (processes) that bind to the same socket can cooperate to service multiple clients. The socket implementation arranges to not duplicate the same received unicast message to multiple server processes.",
      "ja": "UDPのエンドポイントは、（IPアドレス、ポート番号）の組で構成されています。同じIPアドレスに複数の抽象エンドポイント（ソケット）を使用して逆多重化がサポートされています。同じソケットは、複数のクライアントと対話するために、単一のサーバで使用することができます。 （注：この動作は、接続を識別するために、タプルのペアを使用する、TCPとは異なります）。同じソケットにバインドする複数のサーバインスタンス（プロセス）は、複数のクライアントにサービスを提供するために協働することができます。ソケットの実装では、複数のサーバー・プロセスに同じ受信したユニキャストメッセージを重複しないように配置します。"
    },
    {
      "indent": 3,
      "text": "Many operating systems also allow a UDP socket to be \"connected\", i.e., to bind a UDP socket to a specific (remote) UDP endpoint. Unlike TCP's connect primitive, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports [RFC8085].",
      "ja": "多くのオペレーティングシステムは、特定の（リモート）UDPエンドポイントにUDPソケットを結合すること、すなわち、UDPソケットが「接続」されることを可能にします。 TCPのプリミティブ接続とは異なり、UDPのために、これは、ローカル送信/受信機能と、指定されたアドレスとポートのトラフィックをフィルタリングするために[RFC8085]を簡略化するのに役立つだけローカル操作です。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Transport Features",
      "section_title": true,
      "ja": "3.3.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by UDP are:",
      "ja": "UDPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast, multicast, anycast, or IPv4 broadcast transport,",
      "ja": "Oユニキャスト、マルチキャスト、エニーキャスト、またはIPv4ブロードキャストトランスポート、"
    },
    {
      "indent": 3,
      "text": "o port multiplexing (where a receiving port can be configured to receive datagrams from multiple senders),",
      "ja": "（受信ポートは、複数の送信者からのデータグラムを受信するように構成することができる）Oポート多重化、"
    },
    {
      "indent": 3,
      "text": "o message-oriented delivery,",
      "ja": "Oメッセージ指向の配信、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication where the transmissions in each direction are independent,",
      "ja": "各方向の送信が独立しているO一方向または双方向通信、"
    },
    {
      "indent": 3,
      "text": "o non-reliable delivery,",
      "ja": "O非信頼性の高い配信、"
    },
    {
      "indent": 3,
      "text": "o unordered delivery, and",
      "ja": "O順不同配信、"
    },
    {
      "indent": 3,
      "text": "o error detection (implemented using a segment checksum to verify delivery to the correct endpoint and integrity of the data; optional for IPv4 and optional under specific conditions for IPv6 where all or none of the payload data is protected).",
      "ja": "（データの正しいエンドポイントとの整合性への送達を確認するために、セグメントチェックサムを使用して実装;全て又はペイロードデータのいずれも保護されているIPv6の特定の条件下でIPv4のオプションおよびオプション）Oエラー検出。"
    },
    {
      "indent": 0,
      "text": "3.4. Lightweight User Datagram Protocol (UDP-Lite)",
      "section_title": true,
      "ja": "3.4。軽量ユーザーデータグラムプロトコル（UDP-Liteの）"
    },
    {
      "indent": 3,
      "text": "The Lightweight User Datagram Protocol (UDP-Lite) [RFC3828] is an IETF Standards Track transport protocol. It provides a unidirectional, datagram protocol that preserves message boundaries. IETF guidance on the use of UDP-Lite is provided in [RFC8085]. A UDP-Lite service may support IPv4 broadcast, multicast, anycast, and unicast, as well as IPv6 multicast, anycast, and unicast.",
      "ja": "軽量ユーザーデータグラムプロトコル（UDP-Liteは）[RFC3828]はIETF標準化過程のトランスポートプロトコルです。これは、メッセージの境界を維持し、単方向、データグラム・プロトコルを提供します。 UDP-Liteとの使用に関するIETFガイダンスは、[RFC8085]で提供されています。 UDP-Liteのサービスは、IPv4ブロードキャスト、マルチキャスト、エニーキャスト、およびユニキャストだけでなく、IPv6のマルチキャスト、エニーキャスト、およびユニキャストをサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples of use include a class of applications that can derive benefit from having partially damaged payloads delivered rather than discarded. One use is to provide header integrity checks but allow delivery of corrupted payloads to error-tolerant applications or to applications that use some other mechanism to provide payload integrity (see [RFC6936]).",
      "ja": "用途の例は、配信ではなく、廃棄部分的損傷のペイロードを有することから利益を得ることができるアプリケーションのクラスを含みます。 1つの用途は、ヘッダの完全性チェックを提供するが、破損したペイロードの送達がエラートレラントするアプリケーションまたは（[RFC6936]を参照）、ペイロードの整合性を提供するために、いくつかの他のメカニズムを使用するアプリケーションを可能にすることです。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Protocol Description",
      "section_title": true,
      "ja": "3.4.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "Like UDP, UDP-Lite is a connectionless datagram protocol, with no connection setup or feature negotiation. It changes the semantics of the UDP Payload Length field to that of a Checksum Coverage Length field and is identified by a different IP protocol/next-header value. The Checksum Coverage Length field specifies the intended checksum coverage, with the remaining unprotected part of the payload called the \"error-insensitive part\". Therefore, applications using UDP-Lite cannot make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.",
      "ja": "UDPと同様に、UDP-Liteは、未接続の設定時または機能の交渉とコネクションレスのデータグラムプロトコルです。これは、チェックサム・カバレッジ・LengthフィールドのそれとUDPペイロード長フィールドのセマンティクスを変更し、異なるIPプロトコル/次のヘッダ値によって識別されます。チェックサムカバー範囲長フィールドは、「エラーと小文字を区別しない部分」と呼ばれるペイロードの残りの保護されていない部分と、意図したチェックサム適用範囲を指定します。したがって、UDP-Liteの使用するアプリケーションは、UDP-Liteのペイロードの影響を受けない部分で受信したデータの正当性に関する仮定をすることはできません。"
    },
    {
      "indent": 3,
      "text": "Otherwise, UDP-Lite is semantically identical to UDP. In the same way as for UDP, mechanisms for receiver flow control, congestion control, PMTU or PLPMTU discovery, support for ECN, etc., need to be provided by upper-layer protocols [RFC8085].",
      "ja": "それ以外の場合は、UDP-LiteはUDPと意味的に同じです。 UDPの場合と同様に、受信フロー制御、輻輳制御、PMTU又はPLPMTU発見、ECNのサポートなどのためのメカニズムは、上位層プロトコル[RFC8085]により提供される必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Interface Description",
      "section_title": true,
      "ja": "3.4.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "There is no API currently specified in the RFC Series, but guidance on use of common APIs is provided in [RFC8085].",
      "ja": "そこ現在RFCシリーズで指定されていませんAPIはありませんが、共通のAPIの使用に関するガイダンスは、[RFC8085]で提供されています。"
    },
    {
      "indent": 3,
      "text": "The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates a checksum coverage length value. The checksum coverage may also be made visible to the application via the UDP-Lite MIB module [RFC5097].",
      "ja": "UDP-Liteとのインターフェースは、チェックサム・カバレッジ・長さ値を伝達する単一（ソケット）オプションの添加によりUDPとは異なります。チェックサム・カバレッジはまた、UDP-LiteのMIBモジュール[RFC5097]を介してアプリケーションに可視化することができます。"
    },
    {
      "indent": 0,
      "text": "3.4.3. Transport Features",
      "section_title": true,
      "ja": "3.4.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by UDP-Lite are:",
      "ja": "UDP-Liteのが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast, multicast, anycast, or IPv4 broadcast transport (same as for UDP),",
      "ja": "Oユニキャスト、マルチキャスト、エニーキャスト、またはIPv4は、トランスポート（UDPと同様）をブロードキャスト"
    },
    {
      "indent": 3,
      "text": "o port multiplexing (same as for UDP),",
      "ja": "Oポート多重化（UDPと同様）"
    },
    {
      "indent": 3,
      "text": "o message-oriented delivery (same as for UDP),",
      "ja": "Oメッセージ指向送達（UDPと同様）"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication where the transmissions in each direction are independent (same as for UDP),",
      "ja": "各方向の送信が（UDPと同様）独立している単方向または双方向通信O、"
    },
    {
      "indent": 3,
      "text": "o non-reliable delivery (same as for UDP),",
      "ja": "O非信頼性の高い配信（UDPと同様）"
    },
    {
      "indent": 3,
      "text": "o non-ordered delivery (same as for UDP), and",
      "ja": "O（UDPの場合と同じ）の配信を非命じた、と"
    },
    {
      "indent": 3,
      "text": "o partial or full payload error detection (where the Checksum Coverage field indicates the size of the payload data covered by the checksum).",
      "ja": "（チェックサム・カバレッジ・フィールドはチェックサムによってカバーされるペイロードデータのサイズを示す）O部分的または完全なペイロードエラー検出。"
    },
    {
      "indent": 0,
      "text": "3.5. Stream Control Transmission Protocol (SCTP)",
      "section_title": true,
      "ja": "3.5。ストリーム制御伝送プロトコル（SCTP）"
    },
    {
      "indent": 3,
      "text": "SCTP is a message-oriented IETF Standards Track transport protocol. The base protocol is specified in [RFC4960]. It supports multihoming and path failover to provide resilience to path failures. An SCTP association has multiple streams in each direction, providing in-sequence delivery of user messages within each stream. This allows it to minimize head-of-line blocking. SCTP supports multiple stream- scheduling schemes controlling stream multiplexing, including priority and fair weighting schemes.",
      "ja": "SCTPは、メッセージ指向のIETF標準化過程のトランスポートプロトコルです。ベースプロトコルは、[RFC4960]で指定されています。これは、パスの障害に対する回復力を提供するために、マルチホーミングとパスフェイルオーバーをサポートしています。 SCTPアソシエーションは、各ストリーム内のユーザメッセージのインシーケンス配信を提供し、各方向の複数のストリームを有しています。これは、ヘッドオブラインブロッキングを最小限に抑えることができます。 SCTPは優先かつ公正な重み付けスキームを含むストリームの多重化を制御する複数の合理化スケジューリング方式をサポートしています。"
    },
    {
      "indent": 3,
      "text": "SCTP was originally developed for transporting telephony signaling messages and is deployed in telephony signaling networks, especially in mobile telephony networks. It can also be used for other services, for example, in the WebRTC framework for data channels.",
      "ja": "SCTPはもともと、電話シグナリ​​ングメッセージを輸送するために開発された、特に携帯電話ネットワークでは、テレフォニーシグナル伝達ネットワークに配備されています。また、データチャネル用のWebRTCの枠組みの中で、例えば、他のサービスのために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Protocol Description",
      "section_title": true,
      "ja": "3.5.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "SCTP is a connection-oriented protocol using a four-way handshake to establish an SCTP association and a three-way message exchange to gracefully shut it down. It uses the same port number concept as DCCP, TCP, UDP, and UDP-Lite. SCTP only supports unicast.",
      "ja": "SCTPは、正常にシャットダウンするSCTPアソシエーション及び三方メッセージ交換を確立するために、四方向ハンドシェイクを使用してコネクション型のプロトコルです。それはDCCP、TCP、UDP、およびUDP-Liteのと同じポート番号の概念を使用します。 SCTPは、ユニキャストのみをサポートしています。"
    },
    {
      "indent": 3,
      "text": "SCTP uses the 32-bit CRC32c for protecting SCTP packets against bit errors and misdelivery of packets to an unintended endpoint. This is stronger than the 16-bit checksums used by TCP or UDP. However, partial payload checksum coverage as provided by DCCP or UDP-Lite is not supported.",
      "ja": "SCTPは意図しないエンドポイントにビットエラーやパケットの誤配達に対するSCTPパケットを保護するための32ビットCRC32Cを使用します。これは、TCPやUDPで使用される16ビットのチェックサムよりも強いです。しかし、DCCPまたはUDP-Liteとによって提供される部分ペイロードチェックサムカバレッジはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "SCTP has been designed with extensibility in mind. A common header is followed by a sequence of chunks. [RFC4960] defines how a receiver processes chunks with an unknown chunk type. The support of extensions can be negotiated during the SCTP handshake. Currently defined extensions include mechanisms for dynamic reconfiguration of streams [RFC6525] and IP addresses [RFC5061]. Furthermore, the extension specified in [RFC3758] introduces the concept of partial reliability for user messages.",
      "ja": "SCTPは、拡張性を考慮して設計されています。共通ヘッダは、チャンクのシーケンスが続きます。 [RFC4960]は、受信機は、未知のチャンクタイプのチャンクを処理する方法を定義します。拡張のサポートは、SCTPハンドシェーク中に交渉することができます。現在定義されている拡張機能は、ストリームの動的再構成のためのメカニズム[RFC6525]とIPアドレス[RFC5061]を含みます。さらに、[RFC3758]で指定された拡張は、ユーザ・メッセージのための部分的な信頼性の概念を導入します。"
    },
    {
      "indent": 3,
      "text": "SCTP provides a message-oriented service. Multiple small user messages can be bundled into a single SCTP packet to improve efficiency. For example, this bundling may be done by delaying user messages at the sender, similar to Nagle's algorithm used by TCP. User messages that would result in IP packets larger than the MTU will be fragmented at the sender and reassembled at the receiver. There is no protocol limit on the user message size. For MTU discovery, the same mechanism as for TCP can be used [RFC1981] [RFC4821], as well as utilization of probe packets with padding chunks, as defined in [RFC4820].",
      "ja": "SCTPは、メッセージ指向のサービスを提供しています。複数の小ユーザメッセージは、効率を改善するために、単一のSCTPパケットにバンドルすることができます。たとえば、このバンドルは、TCPが使用するNagleのアルゴリズムと同様、送信者のユーザーメッセージを遅延させることにより行うことができます。 MTUよりも大きなIPパケットにつながるユーザー・メッセージは、送信側で断片化し、受信側で再組み立てされます。ユーザメッセージのサイズには、プロトコルの制限はありません。 [RFC4820]で定義されるようにMTU探索のために、TCPと同じメカニズムが、[RFC1981]、[RFC4821]、並びにパディングチャンクとプローブパケットの使用率を使用することができます。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] specifies TCP-friendly congestion control to protect the network against overload. SCTP also uses sliding window flow control to protect receivers against overflow. Similar to TCP, SCTP also supports delaying acknowledgments. [RFC7053] provides a way for the sender of user messages to request immediate sending of the corresponding acknowledgments.",
      "ja": "[RFC4960]は、過負荷に対してネットワークを保護するためにTCPフレンドリーな輻輳制御を指定します。 SCTPはまた、オーバーフローに対して受信機を保護するためにスライディングウィンドウフロー制御を使用しています。 TCPと同様に、SCTPはまた、確認応答を遅らせるサポートしています。 [RFC7053]は、即時対応する肯定応答の送信を要求するユーザメッセージの送信者のための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Each SCTP association has between 1 and 65536 unidirectional streams in each direction. The number of streams can be different in each direction. Every user message is sent on a particular stream. User messages can be sent unordered or ordered upon request by the upper layer. Unordered messages can be delivered as soon as they are completely received. For user messages not requiring fragmentation, this minimizes head-of-line blocking. On the other hand, ordered messages sent on the same stream are delivered at the receiver in the same order as sent by the sender.",
      "ja": "各SCTPアソシエーションは、各方向に1〜65536の単方向ストリームを有しています。ストリームの数は、各方向で異なっていてもよいです。すべてのユーザーのメッセージは、特定のストリームで送信されます。ユーザメッセージは順不同送信または上位層により要求に応じて注文することができます。順序なしのメッセージは、すぐに彼らが完全に受信されているとして配信することができます。ユーザメッセージは断片化を必要としないため、このことは、ヘッドオブラインブロッキングを最小限に抑えます。一方、同じストリーム上で送信されたメッセージが送信者によって送信されたのと同じ順序で受信機に配信されます命じました。"
    },
    {
      "indent": 3,
      "text": "The base protocol defined in [RFC4960] does not allow interleaving of user messages. Large messages on one stream can therefore block the sending of user messages on other streams. [SCTP-NDATA] describes a method to overcome this limitation. This document also specifies multiple algorithms for the sender-side selection of which streams to send data from, supporting a variety of scheduling algorithms including priority-based methods. The stream reconfiguration extension defined in [RFC6525] allows streams to be reset during the lifetime of an association and to increase the number of streams, if the number of streams negotiated in the SCTP handshake becomes insufficient.",
      "ja": "[RFC4960]で定義された基本プロトコルは、ユーザ・メッセージのインターリーブを可能にしません。一つのストリームに大きなメッセージは、従って、他のストリームにユーザメッセージの送信をブロックすることができます。 [SCTP-NDATAは、この制限を克服するための方法が記載されています。この文書はまた、優先順位ベースの方法を含むスケジューリングアルゴリズムの様々な支援からデータを送信するストリームをその送信側の選択のための複数のアルゴリズムを指定します。 [RFC6525]で定義されたストリームの再構成の拡張は、ストリームが関連の存続期間中にリセットすることを可能にし、SCTPハンドシェーク中にネゴシエートストリームの数が不足した場合に、ストリームの数を増加させます。"
    },
    {
      "indent": 3,
      "text": "Each user message sent is delivered to the receiver or, in case of excessive retransmissions, the association is terminated in a non-graceful way [RFC4960], similar to TCP behavior. In addition to this reliable transfer, the partial reliability extension [RFC3758] allows a sender to abandon user messages. The application can specify the policy for abandoning user messages.",
      "ja": "送信された各ユーザのメッセージは、受信機に配信されるか、または、過度の再送信の場合に、関連付けは、TCPの動作に類似した非正常な方法[RFC4960]で終了します。この信頼性の高い転送に加えて、部分的な信頼性拡張[RFC3758]は、送信者がユーザメッセージを放棄することを可能にします。アプリケーションは、ユーザメッセージを放棄するためのポリシーを指定することができます。"
    },
    {
      "indent": 3,
      "text": "SCTP supports multihoming. Each SCTP endpoint uses a list of IP addresses and a single port number. These addresses can be any mixture of IPv4 and IPv6 addresses. These addresses are negotiated during the handshake, and the address reconfiguration extension specified in [RFC5061] in combination with [RFC4895] can be used to change these addresses in an authenticated way during the lifetime of an SCTP association. This allows for transport-layer mobility. Multiple addresses are used for improved resilience. If a remote address becomes unreachable, the traffic is switched over to a reachable one, if one exists.",
      "ja": "SCTPはマルチホーミングをサポートしています。各SCTPエンドポイントは、IPアドレスおよび単一のポート番号のリストを使用しています。これらのアドレスは、IPv4アドレスとIPv6アドレスのいずれかの混合物であることができます。これらのアドレスは、ハンドシェーク中にネゴシエートされ、そして[RFC4895]との組み合わせで、[RFC5061]で指定されたアドレス再構成の拡張は、SCTPアソシエーションの寿命の間に認証された方法でこれらのアドレスを変更するために使用することができます。これは、トランスポート層の移動が可能になります。複数のアドレスは、改良された弾力性のために使用されています。リモートアドレスが到達不能になった場合は1が存在する場合、トラフィックは、到達可能なものに切り替えています。"
    },
    {
      "indent": 3,
      "text": "For securing user messages, the use of TLS over SCTP has been specified in [RFC3436]. However, this solution does not support all services provided by SCTP, such as unordered delivery or partial reliability. Therefore, the use of DTLS over SCTP has been specified in [RFC6083] to overcome these limitations. When using DTLS over SCTP, the application can use almost all services provided by SCTP.",
      "ja": "ユーザメッセージを確保するために、SCTP上TLSの使用は[RFC3436]で指定されています。しかし、この解決策は、順不同の引渡しまたは部分的信頼性など、SCTPが提供するすべてのサービスをサポートしていません。したがって、SCTP上DTLSの使用は、これらの制限を克服するために、[RFC6083]で指定されています。 SCTP上でDTLSを使用する場合、アプリケーションはSCTPが提供するほとんどすべてのサービスを使用することができます。"
    },
    {
      "indent": 3,
      "text": "[NAT-SUPP] defines methods for endpoints and middleboxes to provide NAT traversal for SCTP over IPv4. For legacy NAT traversal, [RFC6951] defines the UDP encapsulation of SCTP packets. Alternatively, SCTP packets can be encapsulated in DTLS packets as specified in [SCTP-DTLS-ENCAPS]. The latter encapsulation is used within the WebRTC [WEBRTC-TRANS] context.",
      "ja": "[NAT-SUPP]はIPv4の上SCTPのためのNATトラバーサルを提供するために、エンドポイントと中間装置のための方法を定義します。従来のNATトラバーサルの場合は、[RFC6951]はSCTPパケットのUDPカプセル化を定義します。 [SCTP-DTLS-ENCAPS]で指定されるように代替的に、SCTPパケットはDTLSパケットにカプセル化することができます。後者のカプセル化のWebRTC〔のWebRTC-TRANS]コンテキスト内で使用されています。"
    },
    {
      "indent": 3,
      "text": "An SCTP ABORT chunk may be used to force a SCTP endpoint to close a session [RFC4960], aborting the connection.",
      "ja": "SCTPのABORTチャンクは接続を中断、セッション[RFC4960]を閉じるために、SCTPエンドポイントを強制するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "SCTP has a well-defined API, described in the next subsection.",
      "ja": "SCTPは、次のサブセクションで説明し、明確に定義されたAPIを、持っています。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Interface Description",
      "section_title": true,
      "ja": "3.5.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] defines an abstract API for the base protocol. This API describes the following functions callable by the upper layer of SCTP: Initialize, Associate, Send, Receive, Receive Unsent Message, Receive Unacknowledged Message, Shutdown, Abort, SetPrimary, Status, Change Heartbeat, Request Heartbeat, Get SRTT Report, Set Failure Threshold, Set Protocol Parameters, and Destroy. The following notifications are provided by the SCTP stack to the upper layer: COMMUNICATION UP, DATA ARRIVE, SHUTDOWN COMPLETE, COMMUNICATION LOST, COMMUNICATION ERROR, RESTART, SEND FAILURE, and NETWORK STATUS CHANGE.",
      "ja": "[RFC4960]は基本プロトコルの抽象APIを定義します。このAPIは、SCTPの上層から呼び出す以下の機能について説明します、准を初期化し、送信、受信、未送信のメッセージを受信し、未確認のメッセージ、シャットダウン、中断、setprimaryを、ステータスを受信、変更ハートビート、ハートビートを要求し、SRTTレポート、設定の失敗を取得します。しきい値、プロトコル・パラメータを設定し、破壊します。 DATAが到着通信UP、完全にシャットダウン、COMMUNICATION LOST、通信エラー、RESTART、FAILUREを送信し、ネットワークステータス変更：次の通知を上位層にSCTPスタックによって提供されます。"
    },
    {
      "indent": 3,
      "text": "An extension to the BSD Sockets API is defined in [RFC6458] and covers:",
      "ja": "BSDソケットAPIの拡張機能は、[RFC6458]で定義されており、カバーされています。"
    },
    {
      "indent": 3,
      "text": "o the base protocol defined in [RFC4960]. The API allows control over local addresses and port numbers and the primary path. Furthermore, the application has fine control of parameters like retransmission thresholds, the path supervision, the delayed acknowledgment timeout, and the fragmentation point. The API provides a mechanism to allow the SCTP stack to notify the application about events if the application has requested them. These notifications provide information about status changes of the association and each of the peer addresses. In case of send failures, including drop of messages sent unreliably, the application can also be notified, and user messages can be returned to the application. When sending user messages, the application can indicate a stream id, a payload protocol identifier, and an indication of whether ordered delivery is requested. These parameters can also be provided on message reception. Additionally, a context can be provided when sending, which can be used in case of send failures. The sending of arbitrarily large user messages is supported.",
      "ja": "[RFC4960]で定義された基本プロトコルO。 APIは、ローカルアドレスとポート番号とプライマリパスを制御できます。さらに、アプリケーションは、再送閾値、パス監督、遅延確認応答のタイムアウト、およびフラグメンテーションポイントのようなパラメータの微調整を有しています。 APIは、アプリケーションがそれを要求した場合SCTPスタックがイベントについてアプリケーションに通知することを可能にするメカニズムを提供します。これらの通知は、ステータス関連の変更やピア・アドレスのそれぞれについての情報を提供します。不確実に送信されたメッセージのドロップなどの送信失敗の場合は、アプリケーションは、通知することができ、かつユーザメッセージは、アプリケーションに戻すことができます。ユーザメッセージを送信する場合、アプリケーションは、ストリームID、ペイロードプロトコル識別子、およびオーダー配信が要求されているかどうかの指標を示すことができます。これらのパラメータは、メッセージの受信に設けることができます。送信失敗の場合に使用することができ、送信時に加えて、コンテキストを提供することができます。任意の大きなユーザメッセージの送信はサポートされています。"
    },
    {
      "indent": 3,
      "text": "o the SCTP Partial Reliability extension defined in [RFC3758] to specify for a user message the Partially Reliable SCTP (PR-SCTP) policy and the policy-specific parameter. Examples of these policies defined in [RFC3758] and [RFC7496] are:",
      "ja": "O [RFC3758]で定義されたSCTP部分信頼性拡張は、ユーザメッセージ部分信頼できるSCTP（PR-SCTP）ポリシーおよびポリシー固有のパラメータに指定します。 [RFC3758]と[RFC7496]で定義されたこれらのポリシーの例は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "* limiting the time a user message is dealt with by the sender.",
      "ja": "*ユーザメッセージが送信者によって対処される時間を制限します。"
    },
    {
      "indent": 6,
      "text": "* limiting the number of retransmissions for each fragment of a user message. If the number of retransmissions is limited to 0, one gets a service similar to UDP.",
      "ja": "*ユーザメッセージの各フラグメントについて再送回数を制限します。再送回数が0に制限されている場合は、一つはUDPと同様のサービスを取得します。"
    },
    {
      "indent": 6,
      "text": "* abandoning messages of lower priority in case of a send buffer shortage.",
      "ja": "*送信バッファ不足の場合には優先度の低いメッセージを放棄します。"
    },
    {
      "indent": 3,
      "text": "o the SCTP Authentication extension defined in [RFC4895] allowing management of the shared keys and allowing the HMAC to use and set the chunk types (which are only accepted in an authenticated way) and get the list of chunks that are accepted by the local and remote endpoints in an authenticated way.",
      "ja": "[RFC4895]で定義されたSCTP認証拡張oを共有鍵の管理を可能にし、HMACを使用して設定し（唯一認証されたように受け入れられる）チャンクタイプとローカルによって受け入れられるチャンクのリストを取得することを可能と認証された方法で、リモートエンドポイント。"
    },
    {
      "indent": 3,
      "text": "o the SCTP Dynamic Address Reconfiguration extension defined in [RFC5061]. It allows the manual addition and deletion of local addresses for SCTP associations, as well as the enabling of automatic address addition and deletion. Furthermore, the peer can be given a hint for choosing its primary path.",
      "ja": "[RFC5061]で定義されたSCTP動的アドレス再延長O。これは、SCTPアソシエーションのローカルアドレスを手動で追加および削除することができます、だけでなく、自動アドレス追加と削除を可能にします。さらに、ピアは、その第一の経路を選択するためのヒントを与えることができます。"
    },
    {
      "indent": 3,
      "text": "A BSD Sockets API extension has been defined in the documents that specify the following SCTP extensions:",
      "ja": "BSDソケットAPIの拡張機能には、以下のSCTPの拡張子を指定したドキュメントで定義されています。"
    },
    {
      "indent": 3,
      "text": "o the SCTP Stream Reconfiguration extension defined in [RFC6525]. The API allows triggering of the reset operation for incoming and outgoing streams and the whole association. It also provides a way to notify the association about the corresponding events. Furthermore, the application can increase the number of streams.",
      "ja": "[RFC6525]で定義されたSCTPストリーム再構成拡張O。 APIは、着信および発信ストリーム全体会合のためのリセット動作のトリガを可能にします。また、対応するイベントに関する協会に通知する方法を提供します。さらに、アプリケーションは、ストリームの数を増加させることができます。"
    },
    {
      "indent": 3,
      "text": "o the UDP Encapsulation of SCTP packets extension defined in [RFC6951]. The API allows the management of the remote UDP encapsulation port.",
      "ja": "O [RFC6951]で定義されたSCTPパケット拡張のUDPカプセル化。 APIは、リモートのUDPカプセル化ポートの管理を行うことができます。"
    },
    {
      "indent": 3,
      "text": "o the SCTP SACK-IMMEDIATELY extension defined in [RFC7053]. The API allows the sender of a user message to request the receiver to send the corresponding acknowledgment immediately.",
      "ja": "[RFC7053]で定義されたSCTP SACK-直ちに拡張O。 APIは、ユーザ・メッセージの送信者がすぐに対応する肯定応答を送信するために受信機を要求することを可能にします。"
    },
    {
      "indent": 3,
      "text": "o the additional PR-SCTP policies defined in [RFC7496]. The API allows enabling/disabling the PR-SCTP extension, choosing the PR-SCTP policies defined in the document, and providing statistical information about abandoned messages.",
      "ja": "[RFC7496]で定義された追加のPR-SCTP政策O。 APIは、文書で定義されたPR-SCTPポリシーを選択し、PR-SCTP拡張を有効/無効、および放棄されたメッセージに関する統計情報を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Future documents describing SCTP extensions are expected to describe the corresponding BSD Sockets API extension in a \"Socket API Considerations\" section.",
      "ja": "SCTP拡張を記述し、将来の文書は、「ソケットAPIの考慮事項」セクションに対応するBSDソケットAPIの拡張機能を記述することが期待されています。"
    },
    {
      "indent": 3,
      "text": "The SCTP Socket API supports two kinds of sockets:",
      "ja": "SCTPソケットAPIは、ソケットの2種類をサポートしています。"
    },
    {
      "indent": 3,
      "text": "o one-to-one style sockets (by using the socket type \"SOCK_STREAM\").",
      "ja": "（ソケットタイプ「SOCK_STREAM」を用いて）O一対一の様式ソケット。"
    },
    {
      "indent": 3,
      "text": "o one-to-many style socket (by using the socket type \"SOCK_SEQPACKET\").",
      "ja": "1対多のスタイルのソケットO（ソケットタイプ「SOCK_SEQPACKET」を使用して）。"
    },
    {
      "indent": 3,
      "text": "One-to-one style sockets are similar to TCP sockets; there is a 1:1 relationship between the sockets and the SCTP associations (except for listening sockets). One-to-many style SCTP sockets are similar to unconnected UDP sockets, where there is a 1:n relationship between the sockets and the SCTP associations.",
      "ja": "一対一のスタイルのソケットはTCPソケットに似ています。 （ソケットリスニングを除く）ソケットとSCTPアソシエーションとの間の関係1：1です。 n個のソケットとSCTPアソシエーションとの関係：一対多スタイルのSCTPソケットは未接続UDP 1があり、ソケットに似ています。"
    },
    {
      "indent": 3,
      "text": "The SCTP stack can provide information to the applications about state changes of the individual paths and the association whenever they occur. These events are delivered similarly to user messages but are specifically marked as notifications.",
      "ja": "それらが発生するたびにSCTPスタックは、個々のパスと関連の状態の変化についてアプリケーションに情報を提供することができます。これらのイベントは、ユーザーのメッセージと同様に配信されますが、具体的通知としてマークされています。"
    },
    {
      "indent": 3,
      "text": "New functions have been introduced to support the use of multiple local and remote addresses. Additional SCTP-specific send and receive calls have been defined to permit SCTP-specific information to be sent without using ancillary data in the form of additional Control Message (cmsg) calls. These functions provide support for detecting partial delivery of user messages and notifications.",
      "ja": "新機能は、複数のローカルおよびリモートアドレスの使用をサポートするために導入されています。追加のSCTP固有の送信および受信コールはSCTP固有の情報を可能にするために定義されているが、追加の制御メッセージの形で補助的なデータを使用せずに送信する（CMSG）が呼び出されます。これらの機能は、ユーザメッセージと通知の一部の配信を検出するためのサポートを提供します。"
    },
    {
      "indent": 3,
      "text": "The SCTP Socket API allows a fine-grained control of the protocol behavior through an extensive set of socket options.",
      "ja": "SCTPソケットAPIは、ソケットオプションの拡張セットを通じてプロトコルの動作をきめ細かく制御することができます。"
    },
    {
      "indent": 3,
      "text": "The SCTP kernel implementations of FreeBSD, Linux, and Solaris follow mostly the specified extension to the BSD Sockets API for the base protocol and the corresponding supported protocol extensions.",
      "ja": "FreeBSDでは、Linux、およびSolarisのSCTPカーネルの実装は、主に基本プロトコルのためのBSDソケットAPIと対応するサポートされるプロトコルの拡張に指定された拡張子に従ってください。"
    },
    {
      "indent": 0,
      "text": "3.5.3. Transport Features",
      "section_title": true,
      "ja": "3.5.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by SCTP are:",
      "ja": "SCTPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o connection-oriented transport with feature negotiation and application-to-port mapping,",
      "ja": "O機能のネゴシエーションおよびアプリケーションとポートのマッピングとの接続指向の輸送、"
    },
    {
      "indent": 3,
      "text": "o unicast transport,",
      "ja": "Oユニキャスト輸送、"
    },
    {
      "indent": 3,
      "text": "o port multiplexing,",
      "ja": "Oポートの多重化、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication, o message-oriented delivery with durable message framing supporting multiple concurrent streams,",
      "ja": "複数の同時ストリームをサポートする耐久性のあるメッセージフレーミングとの一方向または双方向通信O、Oメッセージ指向の配信、"
    },
    {
      "indent": 3,
      "text": "o fully reliable, partially reliable, or unreliable delivery (based on user-specified policy to handle abandoned user messages) with drop notification,",
      "ja": "O、完全に信頼性が部分的に信頼性の高い、または信頼性のない配信（放棄したユーザーのメッセージを処理するためにユーザーが指定したポリシーに基づいて）ドロップ通知で、"
    },
    {
      "indent": 3,
      "text": "o ordered and unordered delivery within a stream,",
      "ja": "O発注し、ストリーム内の順不同配信、"
    },
    {
      "indent": 3,
      "text": "o support for stream scheduling prioritization,",
      "ja": "Oストリームスケジューリング優先順位付けのためのサポート、"
    },
    {
      "indent": 3,
      "text": "o segmentation,",
      "ja": "ああ、セグメンテーション、"
    },
    {
      "indent": 3,
      "text": "o user message bundling,",
      "ja": "Oユーザ・メッセージ・バンドル、"
    },
    {
      "indent": 3,
      "text": "o flow control using a window-based mechanism,",
      "ja": "O、ウインドウベースのメカニズムを使用してフロー制御"
    },
    {
      "indent": 3,
      "text": "o congestion control using methods similar to TCP,",
      "ja": "TCPと同様の方法を使用してOの輻輳制御、"
    },
    {
      "indent": 3,
      "text": "o strong error detection (CRC32c), and",
      "ja": "O強いエラー検出（CRC32C）、及び"
    },
    {
      "indent": 3,
      "text": "o transport-layer multihoming for resilience and mobility.",
      "ja": "弾力性とモビリティのためのOトランスポート層マルチホーミング。"
    },
    {
      "indent": 0,
      "text": "3.6. Datagram Congestion Control Protocol (DCCP)",
      "section_title": true,
      "ja": "3.6。データグラム輻輳制御プロトコル（DCCP）"
    },
    {
      "indent": 3,
      "text": "The Datagram Congestion Control Protocol (DCCP) [RFC4340] is an IETF Standards Track bidirectional transport protocol that provides unicast connections of congestion-controlled messages without providing reliability.",
      "ja": "データグラム輻輳制御プロトコル（DCCP）[RFC4340]は、信頼性を提供することなく、輻輳制御メッセージのユニキャスト接続を提供するIETF標準化過程の双方向転送プロトコルです。"
    },
    {
      "indent": 3,
      "text": "The DCCP Problem Statement [RFC4336] describes the goals that DCCP sought to address. It is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the trade-off between timeliness and reliability [RFC4336].",
      "ja": "DCCP問題文[RFC4336]はDCCPが対処しようと目標を説明します。これは、データのかなり大きな量を転送し、それが適時性と信頼性とのトレードオフを制御[RFC4336]から利益を得ることができる用途に適しています。"
    },
    {
      "indent": 3,
      "text": "DCCP offers low overhead, and many characteristics common to UDP, but can avoid \"re-inventing the wheel\" each time a new multimedia application emerges. Specifically, it includes core transport functions (feature negotiation, path state management, RTT calculation, PMTUD, etc.): DCCP applications select how they send packets and, where suitable, choose common algorithms to manage their functions. Examples of applications that can benefit from such transport services include interactive applications, streaming media, or on-line games [RFC4336].",
      "ja": "DCCPは低いオーバーヘッド、およびUDPに共通する多くの特性を提供していますが、新しいマルチメディアアプリケーションが出てくるたびに「車輪を再発明する」を避けることができます。具体的には、コアトランスポート機能（特徴交渉、パス状態管理、RTT計算、PMTUD、など）が含まれる：DCCPアプリケーションは、彼らが適し、その機能を管理するための一般的なアルゴリズムを選択したパケットとを、送信方法を選択します。このような輸送サービスの恩恵を受けることができるアプリケーションの例としては、対話型アプリケーション、ストリーミングメディア、またはオンラインゲーム[RFC4336]を含んでいます。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Protocol Description",
      "section_title": true,
      "ja": "3.6.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "DCCP is a connection-oriented datagram protocol that provides a three-way handshake to allow a client and server to set up a connection and provides mechanisms for orderly completion and immediate teardown of a connection.",
      "ja": "DCCPは、クライアントとサーバが接続を設定できるようにするために3ウェイハンドシェイクを提供し、秩序ある完了し、接続の即時解体するためのメカニズムを提供し、接続指向のデータグラムプロトコルです。"
    },
    {
      "indent": 3,
      "text": "A DCCP protocol instance can be extended [RFC4340] and tuned using additional features. Some features are sender-side only, requiring no negotiation with the receiver; some are receiver-side only; and some are explicitly negotiated during connection setup.",
      "ja": "DCCPプロトコルインスタンスは、[RFC4340]を拡張し、追加機能を使用して調整することができます。一部の機能のみを送信側、受信側で何の交渉を必要としないです。いくつかは受信側のみです。そして、いくつかは明示的に接続のセットアップ中にネゴシエートされています。"
    },
    {
      "indent": 3,
      "text": "DCCP uses a Connect packet to initiate a session and permits each endpoint to choose the features it wishes to support. Simultaneous open [RFC5596], as in TCP, can enable interoperability in the presence of middleboxes. The Connect packet includes a Service Code [RFC5595] that identifies the application or protocol using DCCP, providing middleboxes with information about the intended use of a connection.",
      "ja": "DCCPは、セッションを開始するために、接続のパケットを使用し、それをサポートしたい機能を選択するために、各エンドポイントを許可します。同時オープン[RFC5596]、TCPのように、ミドルボックスの存在下での相互運用を可能にすることができます。接続パケットは、接続の使用目的に関する情報を中間装置を提供し、DCCPを使用して、アプリケーションまたはプロトコルを識別するサービスコード[RFC5595]を含みます。"
    },
    {
      "indent": 3,
      "text": "The DCCP service is unicast-only.",
      "ja": "DCCPサービスは、ユニキャストのみです。"
    },
    {
      "indent": 3,
      "text": "It provides multiplexing to multiple sockets at each endpoint using port numbers. An active DCCP session is identified by its four-tuple of local and remote IP addresses and local and remote port numbers.",
      "ja": "これは、ポート番号を使用して、各エンドポイントで複数のソケットへの多重化を提供します。アクティブDCCPセッションは、ローカルおよびリモートのIPアドレスとローカルとリモートのポート番号の4つのタプルで識別されます。"
    },
    {
      "indent": 3,
      "text": "The protocol segments data into messages that are typically sized to fit in IP packets but may be fragmented if they are smaller than the maximum packet size. A DCCP interface allows applications to request fragmentation for packets larger than PMTU, but not larger than the maximum packet size allowed by the current congestion control mechanism (Congestion Control Maximum Packet Size (CCMPS)) [RFC4340].",
      "ja": "典型的には、IPパケットに適合するように寸法決めされているが、それらは、最大パケットサイズよりも小さい場合に断片化することができるメッセージにプロトコルセグメントデータ。 DCCPインタフェースは、アプリケーションがPMTUより大きいパケットのフラグメンテーションを要求することを可能にするが、現在の輻輳制御機構（輻輳制御最大パケットサイズ（CCMPS））[RFC4340]によって許容される最大パケットサイズより大きくありません。"
    },
    {
      "indent": 3,
      "text": "Each message is identified by a sequence number. The sequence number is used to identify segments in acknowledgments, to detect unacknowledged segments, to measure RTT, etc. The protocol may support unordered delivery of data and does not itself provide retransmission. DCCP supports reduced checksum coverage, a partial payload protection mechanism similar to UDP-Lite. There is also a Data Checksum option, which when enabled, contains a strong Cyclic Redundancy Check (CRC), to enable endpoints to detect application data corruption.",
      "ja": "各メッセージは、シーケンス番号によって識別されます。シーケンス番号は、プロトコルは、データの順不同配信をサポートすることができ、それ自体が再送信を提供しないなど、RTTを測定するために、未確認のセグメントを検出するために、肯定応答内のセグメントを識別するために使用されます。 DCCPは減少し、チェックサム・カバレッジ、UDP-Liteのに似た部分ペイロード保護メカニズムをサポートしています。有効にすると、アプリケーションデータの破損を検出するために、エンドポイントを有効にするには、強力な巡回冗長検査（CRC）を、含まれているデータのチェックサムオプションもあります。"
    },
    {
      "indent": 3,
      "text": "Receiver flow control is supported, which limits the amount of unacknowledged data that can be outstanding at a given time.",
      "ja": "受信フロー制御は、所定の時間に未処理であることができる未確認データの量が制限され、支持されています。"
    },
    {
      "indent": 3,
      "text": "A DCCP Reset packet may be used to force a DCCP endpoint to close a session [RFC4340], aborting the connection.",
      "ja": "DCCPリセットパケットは、接続を中断、セッション[RFC4340]を閉じるために、DCCP終点を強制するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "DCCP supports negotiation of the congestion control profile between endpoints, to provide plug-and-play congestion control mechanisms. Examples of specified profiles include \"TCP-like\" [RFC4341], \"TCP-friendly\" [RFC4342], and \"TCP-friendly for small packets\" [RFC5622]. Additional mechanisms are recorded in an IANA registry (see <http://www.iana.org/assignments/dccp-parameters>).",
      "ja": "DCCPは、プラグアンドプレイの輻輳制御機構を提供するために、エンドポイント間の輻輳制御プロファイルのネゴシエーションをサポートしています。指定されたプロファイルの例としては、「TCP様」[RFC4341]、「TCPフレンドリー」[RFC4342]、および「TCPフレンドリーな小さなパケットのための」[RFC5622]を含んでいます。追加のメカニズムがIANAレジストリに記録されている（参照<http://www.iana.org/assignments/dccp-parameters>）。"
    },
    {
      "indent": 3,
      "text": "A lightweight UDP-based encapsulation (DCCP-UDP) has been defined [RFC6773] that permits DCCP to be used over paths where DCCP is not natively supported. Support for DCCP in NAPT/NATs is defined in [RFC4340] and [RFC5595]. Upper-layer protocols specified on top of DCCP include DTLS [RFC5238], RTP [RFC5762], and Interactive Connectivity Establishment / Session Description Protocol (ICE/SDP) [RFC6773].",
      "ja": "軽量UDPベースのカプセル化（DCCP-UDP）が定義されている[RFC6773] DCCPがネイティブサポートされていない経路を介して使用するDCCPを可能にすること。 NAPT / NATのでDCCPのサポートは[RFC4340]と[RFC5595]で定義されています。 DCCPの上に指定された上位層プロトコルは、DTLS [RFC5238]、RTP [RFC5762]、およびインタラクティブ接続確立/セッション記述プロトコル（ICE / SDP）[RFC6773]を含みます。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Interface Description",
      "section_title": true,
      "ja": "3.6.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "Functions expected for a DCCP API include: Open, Close, and Management of the progress a DCCP connection. The Open function provides feature negotiation, selection of an appropriate Congestion Control Identifier (CCID) for congestion control, and other parameters associated with the DCCP connection. A function allows an application to send DCCP datagrams, including setting the required checksum coverage and any required options. (DCCP permits sending datagrams with a zero-length payload.) A function allows reception of data, including indicating if the data was used or dropped. Functions can also make the status of a connection visible to an application, including detection of the maximum packet size and the ability to perform flow control by detecting a slow receiver at the sender.",
      "ja": "DCCP APIの期待される機能は以下のとおりです。進歩のオープン、クローズ、および管理DCCP接続を。 Open関数は、機能ネゴシエーション、輻輳制御のための適切な輻輳制御識別子（CCID）の選択、およびDCCP接続に関連する他のパラメータを提供します。関数は、必要なチェックサム適用範囲と必要なオプションを設定することを含む、DCCPデータグラムを送信するアプリケーションを可能にします。 （DCCP許可は、長さゼロのペイロードを有するデータグラムを送信する。）関数は、データが使用されるか、またはドロップされたかどうかを示す含むデータの受信を可能にします。機能は、最大パケットサイズの検出と送信側に遅い受信を検出することにより、フロー制御を実行する機能を含むアプリケーションに見える接続の状態を作ることができます。"
    },
    {
      "indent": 3,
      "text": "There is no API currently specified in the RFC Series.",
      "ja": "現在、RFCシリーズで指定されたAPIはありません。"
    },
    {
      "indent": 0,
      "text": "3.6.3. Transport Features",
      "section_title": true,
      "ja": "3.6.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by DCCP are:",
      "ja": "DCCPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast transport,",
      "ja": "Oユニキャスト輸送、"
    },
    {
      "indent": 3,
      "text": "o connection-oriented communication with feature negotiation and application-to-port mapping,",
      "ja": "O機能のネゴシエーションおよびアプリケーションとポートのマッピングとのコネクション指向通信、"
    },
    {
      "indent": 3,
      "text": "o signaling of application class for middlebox support (implemented using Service Codes),",
      "ja": "ミドル・サポートのためのアプリケーションクラスのOシグナリング（サービスコードを使用して実装）"
    },
    {
      "indent": 3,
      "text": "o port multiplexing,",
      "ja": "Oポートの多重化、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication, o message-oriented delivery,",
      "ja": "単方向または双方向通信O、Oメッセージ指向の配信、"
    },
    {
      "indent": 3,
      "text": "o unreliable delivery with drop notification,",
      "ja": "Oドロップ通知で信頼性のない配信、"
    },
    {
      "indent": 3,
      "text": "o unordered delivery,",
      "ja": "O順不同配信、"
    },
    {
      "indent": 3,
      "text": "o flow control (implemented using the slow receiver function), and",
      "ja": "O（遅い受信機能を用いて実装）フロー制御、および"
    },
    {
      "indent": 3,
      "text": "o partial and full payload error detection (with optional strong integrity check).",
      "ja": "（オプションの強い整合性チェック付き）O部分とフルペイロードエラー検出。"
    },
    {
      "indent": 0,
      "text": "3.7. Transport Layer Security (TLS) and Datagram TLS (DTLS) as a Pseudotransport",
      "ja": "3.7。 Pseudotransportとしてトランスポート層セキュリティ（TLS）およびデータグラムTLS（DTLS）"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) [RFC5246] and Datagram TLS (DTLS) [RFC6347] are IETF protocols that provide several security-related features to applications. TLS is designed to run on top of a reliable streaming transport protocol (usually TCP), while DTLS is designed to run on top of a best-effort datagram protocol (UDP or DCCP [RFC5238]). At the time of writing, the current version of TLS is 1.2, defined in [RFC5246]; work on TLS version is 1.3 [TLS-1.3] nearing completion. DTLS provides nearly identical functionality to applications; it is defined in [RFC6347] and its current version is also 1.2. The TLS protocol evolved from the Secure Sockets Layer (SSL) [RFC6101] protocols developed in the mid-1990s to support protection of HTTP traffic.",
      "ja": "トランスポート層セキュリティ（TLS）[RFC5246]とデータグラムTLS（DTLS）[RFC6347]のアプリケーションにいくつかのセキュリティ関連機能を提供IETFプロトコルです。 DTLSは、ベストエフォート型のデータグラムプロトコル（UDPまたはDCCP [RFC5238]）の上で実行するように設計されているTLSは、信頼性の高いストリーミングトランスポートプロトコル（通常はTCP）の上で動作するように設計されています。書き込み時に、TLSの現在のバージョンは、[RFC5246]で定義され、1.2です。 TLSバージョンの作業は1.3 [TLS-1.3]完成に近づいています。 DTLSは、アプリケーションとほぼ同じ機能を提供します。これは[RFC6347]で定義され、その現在のバージョンも1.2です。 TLSプロトコルは、Secure Sockets Layer（SSL）HTTPトラフィックの保護をサポートするために、1990年代半ばに開発された[RFC6101]のプロトコルから進化しました。"
    },
    {
      "indent": 3,
      "text": "While older versions of TLS and DTLS are still in use, they provide weaker security guarantees. [RFC7457] outlines important attacks on TLS and DTLS. [RFC7525] is a Best Current Practices (BCP) document that describes secure configurations for TLS and DTLS to counter these attacks. The recommendations are applicable for the vast majority of use cases.",
      "ja": "TLSとDTLSの古いバージョンがまだ使用されているが、それらは弱いセキュリティ保証を提供します。 [RFC7457]はTLSとDTLS上の重要な攻撃の概要を説明します。 [RFC7525]は、これらの攻撃に対抗するためにTLSとDTLSのためのセキュアな構成について説明ベスト現在のプラクティス（BCP）文書です。勧告は、ユースケースの大半に適用されます。"
    },
    {
      "indent": 0,
      "text": "3.7.1. Protocol Description",
      "section_title": true,
      "ja": "3.7.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "Both TLS and DTLS provide the same security features and can thus be discussed together. The features they provide are:",
      "ja": "TLSとDTLSの両方が同一のセキュリティ機能を提供し、こうして一緒に議論することができます。それらが提供する機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Confidentiality",
      "ja": "Oの機密性"
    },
    {
      "indent": 3,
      "text": "o Data integrity",
      "ja": "Oデータの整合性"
    },
    {
      "indent": 3,
      "text": "o Peer authentication (optional)",
      "ja": "Oピア認証（オプション）"
    },
    {
      "indent": 3,
      "text": "o Perfect forward secrecy (optional)",
      "ja": "Oパーフェクト転送秘密（オプション）"
    },
    {
      "indent": 3,
      "text": "The authentication of the peer entity can be omitted; a common web use case is where the server is authenticated and the client is not. TLS also provides a completely anonymous operation mode in which neither peer's identity is authenticated. It is important to note that TLS itself does not specify how a peering entity's identity should be interpreted. For example, in the common use case of authentication by means of an X.509 certificate, it is the application's decision whether the certificate of the peering entity is acceptable for authorization decisions.",
      "ja": "ピアエンティティの認証を省略することができます。サーバーが認証された場合の一般的なWebユースケースがあると、クライアントではありません。 TLSはまた、どちらのピアの識別情報が認証されている完全に匿名の動作モードを提供します。 TLS自体はピアリングエンティティのアイデンティティをどのように解釈するかを指定していないことに注意することが重要です。たとえば、X.509証明書による認証の一般的な使用例では、ピアリングのエンティティの証明書は、認証決定のための許容可能であるかどうか、アプリケーションの決定です。"
    },
    {
      "indent": 3,
      "text": "Perfect forward secrecy, if enabled and supported by the selected algorithms, ensures that traffic encrypted and captured during a session at time t0 cannot be later decrypted at time t1 (t1 > t0), even if the long-term secrets of the communicating peers are later compromised.",
      "ja": "完全転送秘密は、有効かつ選択されたアルゴリズムによってサポートされている場合、通信ピアの長期秘密であっても、時刻t0において、セッション中に暗号化され、キャプチャされたトラフィックは、後の時間T1（T1> T0）で復号化することができないことを保証します後で妥協。"
    },
    {
      "indent": 3,
      "text": "As DTLS is generally used over an unreliable datagram transport such as UDP, applications will need to tolerate lost, reordered, or duplicated datagrams. Like TLS, DTLS conveys application data in a sequence of independent records. However, because records are mapped to unreliable datagrams, there are several features unique to DTLS that are not applicable to TLS:",
      "ja": "DTLSは、一般的にUDPのような信頼性のないデータグラムトランスポート上で使用されているとおり、アプリケーションはデータグラムを、失われた並べ替え、または重複許容する必要があるでしょう。 TLSのように、DTLSは、独立したレコードのシーケンスにアプリケーションデータを伝えます。レコードが信頼性のないデータグラムにマッピングされているのでしかし、TLSには適用されませんDTLSに固有のいくつかの機能があります。"
    },
    {
      "indent": 3,
      "text": "o Record replay detection (optional).",
      "ja": "Oレコードリプレイ検出（オプション）。"
    },
    {
      "indent": 3,
      "text": "o Record size negotiation (estimates of PMTU and record size expansion factor).",
      "ja": "Oレコードサイズのネゴシエーション（PMTUとレコードサイズの拡張係数の推定値）。"
    },
    {
      "indent": 3,
      "text": "o Conveyance of IP don't fragment (DF) bit settings by application.",
      "ja": "O IPの搬送は、アプリケーションによって（DF）ビットの設定を断片化していません。"
    },
    {
      "indent": 3,
      "text": "o An anti-DoS stateless cookie mechanism (optional).",
      "ja": "抗-DOSステートレスクッキー機構（オプション）O。"
    },
    {
      "indent": 3,
      "text": "Generally, DTLS follows the TLS design as closely as possible. To operate over datagrams, DTLS includes a sequence number and limited forms of retransmission and fragmentation for its internal operations. The sequence number may be used for detecting replayed information, according to the windowing procedure described in Section 4.1.2.6 of [RFC6347]. DTLS forbids the use of stream ciphers, which are essentially incompatible when operating on independent encrypted records.",
      "ja": "一般的に、DTLSはできるだけTLSの設計に従っています。データグラムで動作するように、DTLSは、その内部動作のシーケンス番号と再送の限られた形態および断片を含みます。シーケンス番号は、[RFC6347]のセクション4.1.2.6に記載のウィンドウの手順に従って、リプレイ情報を検出するために使用することができます。 DTLSは、独立した暗号化されたレコード上で動作する場合、基本的に互換性のないストリーム暗号の使用を禁止します。"
    },
    {
      "indent": 0,
      "text": "3.7.2. Interface Description",
      "section_title": true,
      "ja": "3.7.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "TLS is commonly invoked using an API provided by packages such as OpenSSL, wolfSSL, or GnuTLS. Using such APIs entails the manipulation of several important abstractions, which fall into the following categories: long-term keys and algorithms, session state, and communications/connections.",
      "ja": "TLSは、一般に、OpenSSLの、wolfSSL、またはGNUTLSなどのパッケージが提供するAPIを使用して呼び出されます。長期鍵とアルゴリズム、セッション状態、および通信/接続：このようなAPIを使用すると、次のカテゴリに分類され、いくつかの重要な抽象化、の操作を伴います。"
    },
    {
      "indent": 3,
      "text": "Considerable care is required in the use of TLS APIs to ensure creation of a secure application. The programmer should have at least a basic understanding of encryption and digital signature algorithms and their strengths, public key infrastructure (including X.509 certificates and certificate revocation), and the Sockets API. See [RFC7525] and [RFC7457], as mentioned above.",
      "ja": "かなりの注意が安全なアプリケーションの作成を確実にするためにTLSのAPIの使用に必要とされます。プログラマは、暗号化とデジタル署名アルゴリズムとその強み、（X.509証明書および証明書の失効を含む）は、公開鍵インフラストラクチャ、およびソケットAPIの少なくとも基本的な理解を持っている必要があります。上述のように、[RFC7525]及び[RFC7457]を参照。"
    },
    {
      "indent": 3,
      "text": "As an example, in the case of OpenSSL, the primary abstractions are the library itself, method (protocol), session, context, cipher, and connection. After initializing the library and setting the method, a cipher suite is chosen and used to configure a context object. Session objects may then be minted according to the parameters present in a context object and associated with individual connections. Depending on how precisely the programmer wishes to select different algorithmic or protocol options, various levels of details may be required.",
      "ja": "一例として、のOpenSSLの場合には、主要な抽象化は、ライブラリ自体、方法（プロトコル）セッション、コンテキスト、暗号化、および接続されています。ライブラリーの初期化及び方法を設定した後、暗号スイートを選択し、コンテキスト・オブジェクトを構成するために使用されます。セッションオブジェクトは、コンテキストオブジェクトに存在し、個々の接続に関連付けられたパラメータに応じて鋳造することができます。プログラマは異なるアルゴリズムまたはプロトコルオプションを選択することを望むどのように正確に依存して、細部の様々なレベルが必要とされ得ます。"
    },
    {
      "indent": 0,
      "text": "3.7.3. Transport Features",
      "section_title": true,
      "ja": "3.7.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "Both TLS and DTLS employ a layered architecture. The lower layer is commonly called the \"record protocol\". It is responsible for:",
      "ja": "TLSとDTLSの両方は、階層化アーキテクチャを採用しています。下の層は、一般に「レコードプロトコル」と呼ばれています。それは責任があります："
    },
    {
      "indent": 3,
      "text": "o message fragmentation,",
      "ja": "Oメッセージの断片化、"
    },
    {
      "indent": 3,
      "text": "o authentication and integrity via message authentication codes (MACs),",
      "ja": "メッセージ認証コード（MAC）を介してO認証と完全性、"
    },
    {
      "indent": 3,
      "text": "o data encryption, and",
      "ja": "Oデータの暗号化、および"
    },
    {
      "indent": 3,
      "text": "o scheduling transmission using the underlying transport protocol.",
      "ja": "基礎となるトランスポートプロトコルを使用して、O、スケジューリング伝送。"
    },
    {
      "indent": 3,
      "text": "DTLS augments the TLS record protocol with:",
      "ja": "DTLSはとTLSレコードプロトコルを強化します："
    },
    {
      "indent": 3,
      "text": "o ordering and replay protection, implemented using sequence numbers.",
      "ja": "O順序および再生保護は、シーケンス番号を使用して実装しました。"
    },
    {
      "indent": 3,
      "text": "Several protocols are layered on top of the record protocol. These include the handshake, alert, and change cipher spec protocols. There is also the data protocol, used to carry application traffic. The handshake protocol is used to establish cryptographic and compression parameters when a connection is first set up. In DTLS, this protocol also has a basic fragmentation and retransmission capability and a cookie-like mechanism to resist DoS attacks. (TLS compression is not recommended at present). The alert protocol is used to inform the peer of various conditions, most of which are terminal for the connection. The change cipher spec protocol is used to synchronize changes in cryptographic parameters for each peer.",
      "ja": "いくつかのプロトコルは、レコードプロトコルの上に階層化されています。これらは、握手、警告、および変更暗号仕様プロトコルが含まれます。アプリケーショントラフィックを運ぶために使用されるデータ・プロトコルは、もあります。ハンドシェイクプロトコルは、接続が最初に設定されている暗号化および圧縮パラメータを確立するために使用されます。 DTLSでは、このプロトコルは、基本的な断片化と再送信機能やDoS攻撃に抵抗するクッキーのような機構を備えています。 （TLS圧縮が現時点で推奨されていません）。アラートプロトコルは、接続用の端子であるほとんどが、様々な条件のピアに通知するために使用されます。変化暗号仕様プロトコルは、各ピアの暗号化パラメータの変更を同期させるために使用されます。"
    },
    {
      "indent": 3,
      "text": "The data protocol, when used with an appropriate cipher, provides:",
      "ja": "適切な暗号で使用されるデータプロトコルは、提供します。"
    },
    {
      "indent": 3,
      "text": "o authentication of one end or both ends of a connection,",
      "ja": "一端または接続の両端のO認証、"
    },
    {
      "indent": 3,
      "text": "o confidentiality, and",
      "ja": "O機密性、および"
    },
    {
      "indent": 3,
      "text": "o cryptographic integrity protection.",
      "ja": "O暗号完全性保護。"
    },
    {
      "indent": 3,
      "text": "Both TLS and DTLS are unicast-only.",
      "ja": "どちらもTLSとDTLSは、ユニキャスト専用です。"
    },
    {
      "indent": 0,
      "text": "3.8. Real-Time Transport Protocol (RTP)",
      "section_title": true,
      "ja": "3.8。リアルタイムトランスポートプロトコル（RTP）"
    },
    {
      "indent": 3,
      "text": "RTP provides an end-to-end network transport service, suitable for applications transmitting real-time data, such as audio, video or data, over multicast or unicast transport services, including TCP, UDP, UDP-Lite, DCCP, TLS, and DTLS.",
      "ja": "RTP、TCPを含むマルチキャストまたはユニキャスト輸送サービス、上、オーディオ、ビデオ、データなどのリアルタイムデータを送信するアプリケーションに適したエンドツーエンドのネットワーク・トランスポート・サービスを、提供UDP、UDP-Liteは、DCCP、TLS、およびDTLS。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Protocol Description",
      "section_title": true,
      "ja": "3.8.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "The RTP standard [RFC3550] defines a pair of protocols: RTP and the RTP Control Protocol (RTCP). The transport does not provide connection setup, instead relying on out-of-band techniques or associated control protocols to setup, negotiate parameters, or tear down a session.",
      "ja": "RTP及びRTP制御プロトコル（RTCP）：RTP標準[RFC3550]はプロトコルの組を定義します。輸送は、代わりにセットアップするアウトオブバンド技術または関連する制御プロトコルに依存して、接続設定を提供するパラメータをネゴシエート、またはセッションを切断しません。"
    },
    {
      "indent": 3,
      "text": "An RTP sender encapsulates audio/video data into RTP packets to transport media streams. The RFC Series specifies RTP payload formats that allow packets to carry a wide range of media and specifies a wide range of multiplexing, error control, and other support mechanisms.",
      "ja": "RTPの送信者は、メディアストリームを転送するためにRTPパケットにオーディオ/ビデオデータをカプセル化します。 RFCシリーズは、パケットがメディアの広い範囲を運ぶことを可能にするRTPペイロードフォーマットを指定し、多重化、誤り制御、および他の支持機構の広い範囲を指定します。"
    },
    {
      "indent": 3,
      "text": "If a frame of media data is large, it will be fragmented into several RTP packets. Likewise, several small frames may be bundled into a single RTP packet.",
      "ja": "メディアデータのフレームが大きい場合、それはいくつかのRTPパケットに断片化されるであろう。同様に、いくつかの小さなフレームは、単一のRTPパケットにバンドルすることができます。"
    },
    {
      "indent": 3,
      "text": "An RTP receiver collects RTP packets from the network, validates them for correctness, and sends them to the media decoder input queue. Missing packet detection is performed by the channel decoder. The playout buffer is ordered by time stamp and is used to reorder packets. Damaged frames may be repaired before the media payloads are decompressed to display or store the data. Some uses of RTP are able to exploit the partial payload protection features offered by DCCP and UDP-Lite.",
      "ja": "RTP受信機は、ネットワークからRTPパケットを収集する正確ためにそれらを検証し、メディアデコーダ入力キューに送ります。欠落パケットの検出は、チャネル復号器によって実行されます。再生バッファは、タイムスタンプによって順序付けされ、パケットの順序を変更するために使用されます。メディアペイロードを表示またはデータを格納するために解凍する前に破損したフレームを修復することができます。 RTPのいくつかの用途は、DCCPおよびUDP-Liteのによって提供される部分的なペイロード保護機能を活用することができます。"
    },
    {
      "indent": 3,
      "text": "RTCP is a control protocol that works alongside an RTP flow. Both the RTP sender and receiver will send RTCP report packets. This is used to periodically send control information and report performance.",
      "ja": "RTCPは、RTPの流れと一緒に働く制御プロトコルです。 RTPの送信者と受信者の両方がRTCPレポートパケットを送信します。これは、定期的に制御情報とレポートのパフォーマンスを送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Based on received RTCP feedback, an RTP sender can adjust the transmission, e.g., perform rate adaptation at the application layer in the case of congestion.",
      "ja": "受信されたRTCPフィードバックに基づいて、RTP送信機は、送信を調整することができ、例えば、輻輳の場合に、アプリケーション層でのレート適応を行います。"
    },
    {
      "indent": 3,
      "text": "An RTCP receiver report (RTCP RR) is returned to the sender periodically to report key parameters (e.g., the fraction of packets lost in the last reporting interval, the cumulative number of packets lost, the highest sequence number received, and the inter-arrival jitter). The RTCP RR packets also contain timing information that allows the sender to estimate the network round-trip time (RTT) to the receivers.",
      "ja": "RTCPレシーバレポート（RTCP RR）は、定期的に重要なパラメータ（例えば、最後のレポート間隔で失われたパケットの割合は、パケットの累積数が失われ、最大のシーケンス番号を受信し、到着を報告するために送信者に返されますジッタ）。 RTCP RRパケットはまた、送信者が受信者にネットワークラウンドトリップ時間（RTT）を推定することを可能にするタイミング情報を含みます。"
    },
    {
      "indent": 3,
      "text": "The interval between reports sent from each receiver tends to be on the order of a few seconds on average, although this varies with the session rate, and sub-second reporting intervals are possible for high rate sessions. The interval is randomized to avoid synchronization of reports from multiple receivers.",
      "ja": "このセッションレートで変化し、サブ秒報告間隔が高速セッションのために可能であるが、各受信機から送信されたレポートの間の間隔は、平均して数秒のオーダーとなる傾向があります。間隔は、複数の受信機からのレポートの同期を避けるために、ランダム化されています。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Interface Description",
      "section_title": true,
      "ja": "3.8.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "There is no standard API defined for RTP or RTCP. Implementations are typically tightly integrated with a particular application and closely follow the principles of application-level framing and integrated layer processing [ClarkArch] in media processing [RFC2736], error recovery and concealment, rate adaptation, and security [RFC7202]. Accordingly, RTP implementations tend to be targeted at particular application domains (e.g., voice-over-IP, IPTV, or video conferencing), with a feature set optimized for that domain, rather than being general purpose implementations of the protocol.",
      "ja": "RTPまたはRTCPのために定義された標準的なAPIはありません。実装は、典型的にはしっかり特定のアプリケーションに統合され、密接にメディア処理におけるアプリケーションレベルのフレーミングおよび統合されたレイヤ処理[ClarkArch] [RFC2736]、エラー回復および隠蔽、レート適応、およびセキュリティ[RFC7202]の原則に従っています。したがって、RTP実装はむしろプロトコルの汎用実装さよりも、そのドメインのために最適化された機能セットと、特定のアプリケーションドメイン（例えば、ボイスオーバーIP、IPTV、またはビデオ会議）を対象とする傾向があります。"
    },
    {
      "indent": 0,
      "text": "3.8.3. Transport Features",
      "section_title": true,
      "ja": "3.8.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by RTP are:",
      "ja": "RTPが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast, multicast, or IPv4 broadcast (provided by lower-layer protocol),",
      "ja": "Oユニキャスト、マルチキャスト、またはIPv4ブロードキャストは、（下位層プロトコルによって提供されます）"
    },
    {
      "indent": 3,
      "text": "o port multiplexing (provided by lower-layer protocol),",
      "ja": "（下位層プロトコルによって提供される）Oポート多重化、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication (provided by lower-layer protocol),",
      "ja": "（下位層プロトコルによって提供される）、単方向または双方向通信O、"
    },
    {
      "indent": 3,
      "text": "o message-oriented delivery with support for media types and other extensions,",
      "ja": "Oメディアタイプや他の拡張機能をサポートするメッセージ指向の配信、"
    },
    {
      "indent": 3,
      "text": "o reliable delivery when using erasure coding or unreliable delivery with drop notification (if supported by lower-layer protocol),",
      "ja": "消去符号化またはドロップ通知に信頼性のない配信を使用して、O、信頼性の高い配信（下位層プロトコルでサポートされている場合）、"
    },
    {
      "indent": 3,
      "text": "o connection setup with feature negotiation (using associated protocols) and application-to-port mapping (provided by lower-layer protocol),",
      "ja": "（関連プロトコルを使用して）機能ネゴシエーションと（下位層プロトコルによって提供される）アプリケーションとポートのマッピングとの接続設定O、"
    },
    {
      "indent": 3,
      "text": "o segmentation, and",
      "ja": "Oセグメンテーション、および"
    },
    {
      "indent": 3,
      "text": "o performance metric reporting (using associated protocols).",
      "ja": "Oパフォーマンスメトリック報告（関連プロトコルを使用して）。"
    },
    {
      "indent": 0,
      "text": "3.9. Hypertext Transport Protocol (HTTP) over TCP as a Pseudotransport",
      "section_title": true,
      "ja": "3.9。 PseudotransportとしてTCP上のハイパーテキスト転送プロトコル（HTTP）"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is an application-level protocol widely used on the Internet. It provides object-oriented delivery of discrete data or files. Version 1.1 of the protocol is specified in [RFC7230] [RFC7231] [RFC7232] [RFC7233] [RFC7234] [RFC7235], and version 2 is specified in [RFC7540]. HTTP is usually transported over TCP using ports 80 and 443, although it can be used with other transports. When used over TCP, it inherits TCP's properties.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、インターネットで広く使用されるアプリケーションレベルのプロトコルです。これは、離散的なデータやファイルのオブジェクト指向の配信を提供します。プロトコルのバージョン1.1は、[RFC7232]、[RFC7233]、[RFC7234]、[RFC7235]、およびバージョン2は、[RFC7540]で指定された[RFC7230]、[RFC7231]で指定されています。それは、他のトランスポートとともに使用することができるがHTTPは、通常、ポート80および443を使用して、TCPを介して転送されます。 TCP上で使用する場合は、TCPのプロパティを継承します。"
    },
    {
      "indent": 3,
      "text": "Application-layer protocols may use HTTP as a substrate with an existing method and data formats, or specify new methods and data formats. There are various reasons for this practice listed in [RFC3205]; these include being a well-known and well-understood protocol, reusability of existing servers and client libraries, easy use of existing security mechanisms such as HTTP digest authentication [RFC7235] and TLS [RFC5246], and the ability of HTTP to traverse firewalls, which allows it to work over many types of infrastructure and in cases where an application server often needs to support HTTP anyway.",
      "ja": "アプリケーション層プロトコルは、既存の方法とデータフォーマットを有する基板としてHTTPを使用するか、または新たな方法及びデータフォーマットを指定することができます。 [RFC3205]に記載されているこの実践のための様々な理由があります。これらは、既存のサーバやクライアントライブラリの再利用周知であり、十分に理解プロトコルである含む、HTTPなどの既存のセキュリティ・メカニズムを簡単に使用することは、認証[RFC7235]とTLS [RFC5246]、およびファイアウォールを通過するHTTPの能力をダイジェストそれはインフラの多くの種類の上に、アプリケーション・サーバは、多くの場合、とにかくHTTPをサポートする必要がある場合に動作することができます。"
    },
    {
      "indent": 3,
      "text": "Depending on application need, the use of HTTP as a substrate protocol may add complexity and overhead in comparison to a special-purpose protocol (e.g., HTTP headers, suitability of the HTTP security model, etc.). [RFC3205] addresses this issue, provides some guidelines, and identifies concerns about the use of HTTP standard ports 80 and 443, the use of the HTTP URL scheme, and interaction with existing firewalls, proxies, and NATs.",
      "ja": "アプリケーションの必要に応じて、基板プロトコルとしてHTTPを使用するが、専用のプロトコルと比較して複雑さとオーバーヘッドを追加することができる（例えば、HTTPヘッダ、HTTPのセキュリティモデルの適合性、等）。 [RFC3205]は、この問題に対処するいくつかのガイドラインを提供し、HTTP標準ポート80と443を使用し、HTTP URLスキームを使用すると、既存のファイアウォール、プロキシ、NATのとの相互作用についての懸念を示しています。"
    },
    {
      "indent": 3,
      "text": "Representational State Transfer (REST) [REST] is another example of how applications can use HTTP as a transport protocol. REST is an architecture style that may be used to build applications using HTTP as a communication protocol.",
      "ja": "Representational State Transfer（REST）[REST]は、アプリケーションがトランスポートプロトコルとしてHTTPを使用する方法の別の例です。 RESTは、通信プロトコルとしてHTTPを使用してアプリケーションを構築するために使用することができるアーキテクチャスタイルです。"
    },
    {
      "indent": 0,
      "text": "3.9.1. Protocol Description",
      "section_title": true,
      "ja": "3.9.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a request/response protocol. A client sends a request containing a request method, URI, and protocol version followed by message whose design is inspired by",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、要求/応答プロトコルです。クライアントは、そのデザインに触発されたメッセージに続くリクエストメソッド、URI、およびプロトコルバージョンを含む要求を送信します"
    },
    {
      "indent": 3,
      "text": "MIME (see [RFC7231] for the differences between an HTTP object and a MIME message), containing information about the client and request modifiers. The message can also contain a message body carrying application data. The server responds with a status or error code followed by a message containing information about the server and information about the data. This may include a message body. It is possible to specify a data format for the message body using MIME media types [RFC2045]. The protocol has additional features; some relevant to pseudotransport are described below.",
      "ja": "MIMEクライアント要求修飾子に関する情報を含む、（HTTPオブジェクトとMIMEメッセージの違いのために[RFC7231]を参照）。メッセージは、アプリケーションデータを運ぶメッセージボディを含めることができます。サーバは、データに関するサーバと情報に関する情報を含むメッセージが続くステータスまたはエラーコードで応答します。これは、メッセージ本体を含むことができます。 MIMEメディアタイプ[RFC2045]を使用して、メッセージ本文のデータ形式を指定することが可能です。プロトコルは、追加の機能を備えています。 pseudotransportにはいくつかの関連を以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "Content negotiation, specified in [RFC7231], is a mechanism provided by HTTP to allow selection of a representation for a requested resource. The client and server negotiate acceptable data formats, character sets, and data encoding (e.g., data can be transferred compressed using gzip). HTTP can accommodate exchange of messages as well as data streaming (using chunked transfer encoding [RFC7230]). It is also possible to request a part of a resource using an object range request [RFC7233]. The protocol provides powerful cache control signaling defined in [RFC7234].",
      "ja": "[RFC7231]で指定されたコンテンツネゴシエーションは、要求されたリソースの表現の選択を可能にするためにHTTPで提供するメカニズムです。クライアントとサーバが許容されるデータ形式、文字セット、及びデータ・エンコードを交渉する（例えば、データ圧縮用いGZIPを転送することができます）。 HTTPは、メッセージの交換、ならびに（チャンク転送符号化を使用して、[RFC7230]）データストリーミングを収容することができます。対象範囲要求[RFC7233]を使用してリソースの一部を要求することも可能です。プロトコルは、[RFC7234]で定義された強力なキャッシュ制御シグナリングを提供します。"
    },
    {
      "indent": 3,
      "text": "The persistent connections of HTTP 1.1 and HTTP 2.0 allow multiple request/response transactions (streams) during the lifetime of a single HTTP connection. This reduces overhead during connection establishment and mitigates transport-layer slow-start that would have otherwise been incurred for each transaction. HTTP 2.0 connections can multiplex many request/response pairs in parallel on a single transport connection. Both are important to reduce latency for HTTP's primary use case.",
      "ja": "HTTP 1.1とHTTP 2.0の永続的な接続は、単一のHTTP接続の存続期間中に複数の要求/応答トランザクション（ストリーム）を可能にします。これは、接続確立時のオーバーヘッドを低減し、そうでない場合は、各トランザクションのために負担されていたであろうトランスポート層スロースタートを軽減します。 HTTP 2.0の接続が単一のトランスポート接続上で平行に多くの要求/応答のペアを多重化することができます。どちらも、HTTPの主なユースケースのための待ち時間を削減するために重要です。"
    },
    {
      "indent": 3,
      "text": "HTTP can be combined with security mechanisms, such as TLS (denoted by HTTPS). This adds protocol properties provided by such a mechanism (e.g., authentication and encryption). The TLS Application-Layer Protocol Negotiation (ALPN) extension [RFC7301] can be used to negotiate the HTTP version within the TLS handshake, eliminating the latency incurred by additional round-trip exchanges. Arbitrary cookie strings, included as part of the request headers, are often used as bearer tokens in HTTP.",
      "ja": "HTTPは、（HTTPSで示す）TLSなどのセキュリティメカニズムと組み合わせることができます。このような機構（例えば、認証および暗号化）によって提供されるプロトコルのプロパティを追加します。 TLSアプリケーション層のプロトコルネゴシエーション（ALPN）拡張[RFC7301]は、追加の往復交換によって発生待ち時間をなくし、TLSハンドシェイク内のHTTPバージョンを交渉するために使用することができます。要求ヘッダーの一部として含まれる任意のクッキーストリングは、しばしばHTTPにおけるベアラトークンとして使用されています。"
    },
    {
      "indent": 0,
      "text": "3.9.2. Interface Description",
      "section_title": true,
      "ja": "3.9.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "There are many HTTP libraries available exposing different APIs. The APIs provide a way to specify a request by providing a URI, a method, request modifiers, and, optionally, a request body. For the response, callbacks can be registered that will be invoked when the response is received. If HTTPS is used, the API exposes a registration of callbacks when a server requests client authentication and when certificate verification is needed.",
      "ja": "異なるAPIをさらす可能な多くのHTTPライブラリがあります。 APIは、URIを提供することによって、要求を指定する方法、方法、要求改質剤、及び、必要に応じて、リクエストボディを提供します。応答の場合、コールバックは、応答を受信したときに呼び出されるように登録することができます。 HTTPSを使用する場合は、APIは、サーバーがクライアント認証とする場合、証明書の検証が必要とされているを要求したコールバックの登録を公開します。"
    },
    {
      "indent": 3,
      "text": "The World Wide Web Consortium (W3C) has standardized the XMLHttpRequest API [XHR]. This API can be used for sending HTTP/ HTTPS requests and receiving server responses. Besides the XML data format, the request and response data format can also be JSON, HTML, and plain text. JavaScript and XMLHttpRequest are ubiquitous programming models for websites and more general applications where native code is less attractive.",
      "ja": "World Wide Webコンソーシアム（W3C）は、XMLHTTPリクエストAPI [XHR]を標準化しています。このAPIは、HTTP / HTTPSリクエストを送信し、サーバの応答を受信するために使用することができます。 XMLデータ形式のほかに、リクエストとレスポンスのデータ・フォーマットもJSON、HTML、プレーンテキストことができます。 JavaScriptとXMLHttpRequestがWebサイトやネイティブコードはあまり魅力的で、より一般的なアプリケーションのためのユビキタスなプログラミングモデルです。"
    },
    {
      "indent": 0,
      "text": "3.9.3. Transport Features",
      "section_title": true,
      "ja": "3.9.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by HTTP, when used as a pseudotransport, are:",
      "ja": "pseudotransportとして使用するHTTP、が提供するトランスポート機能は、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast transport (provided by the lower-layer protocol, usually TCP),",
      "ja": "O（下位層プロトコル、通常はTCPによって提供された）ユニキャストトランスポート、"
    },
    {
      "indent": 3,
      "text": "o unidirectional or bidirectional communication,",
      "ja": "一方向又は双方向通信O、"
    },
    {
      "indent": 3,
      "text": "o transfer of objects in multiple streams with object content type negotiation, supporting partial transmission of object ranges,",
      "ja": "対象範囲の部分的な送信をサポートするオブジェクトのコンテンツタイプのネゴシエーションを持つ複数のストリーム内のオブジェクトのO転送、"
    },
    {
      "indent": 3,
      "text": "o ordered delivery (provided by the lower-layer protocol, usually TCP),",
      "ja": "O、（通常はTCP、下位層プロトコルによって提供される）送達を注文"
    },
    {
      "indent": 3,
      "text": "o fully reliable delivery (provided by the lower-layer protocol, usually TCP),",
      "ja": "O（下位層プロトコル、通常はTCPによって提供される）完全に信頼できる配信、"
    },
    {
      "indent": 3,
      "text": "o flow control (provided by the lower-layer protocol, usually TCP), and",
      "ja": "O（下位層プロトコル、通常はTCPによって提供された）フロー制御、および"
    },
    {
      "indent": 3,
      "text": "o congestion control (provided by the lower-layer protocol, usually TCP).",
      "ja": "（下位層プロトコル、通常はTCPにより提供）O輻輳制御。"
    },
    {
      "indent": 3,
      "text": "HTTPS (HTTP over TLS) additionally provides the following features (as provided by TLS):",
      "ja": "HTTPS（HTTP TLS上）（TLSによって提供される）、さらに次の機能を提供します。"
    },
    {
      "indent": 3,
      "text": "o authentication (of one or both ends of a connection),",
      "ja": "（接続の一端または両端の）O認証、"
    },
    {
      "indent": 3,
      "text": "o confidentiality, and",
      "ja": "O機密性、および"
    },
    {
      "indent": 3,
      "text": "o integrity protection.",
      "ja": "Oの完全性保護。"
    },
    {
      "indent": 0,
      "text": "3.10. File Delivery over Unidirectional Transport / Asynchronous Layered Coding (FLUTE/ALC) for Reliable Multicast",
      "ja": "3.10。リライアブルマルチキャスト用（FLUTE / ALC）をコーディング単方向交通/非同期階層にわたるファイル配信"
    },
    {
      "indent": 3,
      "text": "FLUTE/ALC is an IETF Standards Track protocol specified in [RFC6726] and [RFC5775]. It provides object-oriented delivery of discrete data or files. Asynchronous Layer Coding (ALC) provides an underlying reliable transport service and FLUTE a file-oriented specialization of the ALC service (e.g., to carry associated metadata). [RFC6726] and [RFC5775] are non-backward-compatible updates of [RFC3926] and [RFC3450], which are Experimental protocols; these Experimental protocols are currently largely deployed in the 3GPP Multimedia Broadcast / Multicast Service (MBMS) (see [MBMS], Section 7) and similar contexts (e.g., the Japanese ISDB-Tmm standard).",
      "ja": "FLUTE / ALCは、[RFC6726]及び[RFC5775]で指定されたIETF標準化過程プロトコルです。これは、離散的なデータやファイルのオブジェクト指向の配信を提供します。非同期レイヤ符号化（ALC）ALCサービス（例えば、関連するメタデータを運ぶために）のファイル指向の専門基礎となる信頼性の高い輸送サービスとFLUTEを提供します。 [RFC6726]及び[RFC5775]は実験プロトコルは[RFC3926]及び[RFC3450]の非下位互換性アップデートです。これらの実験プロトコルは、現在、主に3GPPのマルチメディアブロードキャスト/マルチキャストサービス（MBMS）に配備されており、同様の状況（例えば、日本のISDB-TMM標準）（[MBMS]、セクション7を参照）。"
    },
    {
      "indent": 3,
      "text": "The FLUTE/ALC protocol has been designed to support massively scalable reliable bulk data dissemination to receiver groups of arbitrary size using IP Multicast over any type of delivery network, including unidirectional networks (e.g., broadcast wireless channels). However, the FLUTE/ALC protocol also supports point-to-point unicast transmissions.",
      "ja": "FLUTE / ALCプロトコルは、単方向ネットワーク（例えば、ブロードキャスト無線チャネル）を含む配信ネットワークの任意のタイプの、上にIPマルチキャストを使用して、任意のサイズの受信機グループに大規模スケーラブル信頼バルクデータ配布をサポートするように設計されています。しかし、FLUTE / ALCプロトコルは、ポイントツーポイントのユニキャスト送信をサポートしています。"
    },
    {
      "indent": 3,
      "text": "FLUTE/ALC bulk data dissemination has been designed for discrete file or memory-based \"objects\". Although FLUTE/ALC is not well adapted to byte and message streaming, there is an exception: FLUTE/ALC is used to carry 3GPP Dynamic Adaptive Streaming over HTTP (DASH) when scalability is a requirement (see [MBMS], Section 5.6).",
      "ja": "FLUTE / ALCバルクデータ配布は、個別のファイルまたはメモリベースの「オブジェクト」のために設計されています。 FLUTE / ALCはよくバイトストリーミングメッセージに適合していないが、例外がある：FLUTE / ALCは、HTTP上（DASH）を3GPP動的適応ストリーミングを搬送するために使用されるスケーラビリティが要件である場合（[MBMS]、セクション5.6を参照）。"
    },
    {
      "indent": 3,
      "text": "FLUTE/ALC's reliability, delivery mode, congestion control, and flow/ rate control mechanisms can be separately controlled to meet different application needs. Section 4.1 of [RFC8085] describes multicast congestion control requirements for UDP.",
      "ja": "FLUTE / ALCの信頼性、配信モード、輻輳制御、およびフロー/レート制御メカニズムは、別々のアプリケーションのニーズを満たすように制御することができます。 [RFC8085]のセクション4.1は、UDPマルチキャスト輻輳制御要件について説明します。"
    },
    {
      "indent": 0,
      "text": "3.10.1. Protocol Description",
      "section_title": true,
      "ja": "3.10.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "The FLUTE/ALC protocol works on top of UDP (though it could work on top of any datagram delivery transport protocol), without requiring any connectivity from receivers to the sender. Purely unidirectional networks are therefore supported by FLUTE/ALC. This guarantees scalability to an unlimited number of receivers in a session, since the sender behaves exactly the same regardless of the number of receivers.",
      "ja": "送信者に受信機からの任意の接続を必要とせずに、（それがどんなデータグラムデリバリー・トランスポートプロトコルの上で動作する可能性がありますが）FLUTE / ALCプロトコルはUDPの上で動作します。純粋に単方向のネットワークは、したがって、FLUTE / ALCによってサポートされています。送信者は関係なく、受信機の数のまったく同じ動作をしますので、これは、セッション内の受信機の数は無制限に拡張性を保証します。"
    },
    {
      "indent": 3,
      "text": "FLUTE/ALC supports the transfer of bulk objects such as file or in-memory content, using either a push or an on-demand mode. In push mode, content is sent once to the receivers, while in on-demand mode, content is sent continuously during periods of time that can greatly exceed the average time required to download the session objects (see [RFC5651], Section 4.2).",
      "ja": "FLUTE / ALCはプッシュまたはオンデマンドモードのいずれかを使用して、そのようなファイルやメモリ内のコンテンツとしてバルクオブジェクトの転送をサポートしています。オンデマンドモードでは、コンテンツを大幅にセッション・オブジェクトをダウンロードするのに必要な平均時間を超えることができる時間の期間中に連続的に送られている間、プッシュモードでは、コンテンツは、受信機に一度送信される（[RFC5651]セクション4.2を参照）。"
    },
    {
      "indent": 3,
      "text": "This enables receivers to join a session asynchronously, at their own discretion, receive the content, and leave the session. In this case, data content is typically sent continuously, in loops (also known as \"carousels\"). FLUTE/ALC also supports the transfer of an object stream, with loose real-time constraints. This is particularly useful to carry 3GPP DASH when scalability is a requirement and unicast transmissions over HTTP cannot be used ([MBMS], Section 5.6). In this case, packets are sent in sequence using push mode. FLUTE/ALC is not well adapted to byte and message streaming, and other solutions could be preferred (e.g., FECFRAME [RFC6363] with real-time flows).",
      "ja": "これは、自らの裁量で、非同期のセッションに参加したコンテンツを受信し、セッションを残すために受信機を可能にします。この場合、データコンテンツは、典型的には、（また、「カルーセル」として知られている）ループで、連続的に送信されます。 FLUTE / ALCも緩いリアルタイム制約と、オブジェクトストリームの転送をサポートしています。スケーラビリティが必要であり、HTTP上ユニキャスト送信は、（[MBMS]、セクション5.6）を使用することができないとき、これは、3GPPのDASHを運ぶために特に有用です。この場合、パケットは、プッシュモードを使用して順番に送信されます。 FLUTE / ALCはよくバイトとメッセージのストリーミングに適応されず、他の解決策が好ましいことができる（例えば、FECFRAME [RFC6363]リアルタイムと流れます）。"
    },
    {
      "indent": 3,
      "text": "The FLUTE file delivery instantiation of ALC provides a metadata delivery service. Each object of the FLUTE/ALC session is described in a dedicated entry of a File Delivery Table (FDT), using an XML format (see [RFC6726], Section 3.2). This metadata can include, but is not restricted to, a URI attribute (to identify and locate the object), a media type attribute, a size attribute, an encoding attribute, or a message digest attribute. Since the set of objects sent within a session can be dynamic, with new objects being added and old ones removed, several instances of the FDT can be sent, and a mechanism is provided to identify a new FDT instance.",
      "ja": "ALCのFLUTEファイル配信のインスタンスは、メタデータ配信サービスを提供しています。 FLUTE / ALCセッションの各オブジェクトは、XML形式を使用して、ファイル配達テーブル（FDT）の専用エントリに記載されている（[RFC6726]セクション3.2を参照）。このメタデータは含むことができるが、URI属性（オブジェクトを識別し、検索するために）、メディアタイプ属性、サイズ属性、エンコーディング属性、またはメッセージダイジェスト属性に限定されるものではありません。セッション内で送信されたオブジェクトの集合が削除追加される新しいオブジェクトと古いものと、動的とすることができるので、FDTの複数のインスタンスを送信することができ、機構は新しいFDTインスタンスを識別するために設けられています。"
    },
    {
      "indent": 3,
      "text": "Error detection and verification of the protocol control information relies on the underlying transport (e.g., UDP checksum).",
      "ja": "プロトコル制御情報のエラー検出及び検証は、基礎となるトランスポート（例えば、UDPチェックサム）に依存しています。"
    },
    {
      "indent": 3,
      "text": "To provide robustness against packet loss and improve the efficiency of the on-demand mode, FLUTE/ALC relies on packet erasure coding (Application-Layer Forward Error Correction (AL-FEC)). AL-FEC encoding is proactive (since there is no feedback and therefore no (N)ACK-based retransmission), and ALC packets containing repair data are sent along with ALC packets containing source data. Several FEC Schemes have been standardized; FLUTE/ALC does not mandate the use of any particular one. Several strategies concerning the transmission order of ALC source and repair packets are possible, in particular, in on-demand mode where it can deeply impact the service provided (e.g., to favor the recovery of objects in sequence or, at the other extreme, to favor the recovery of all objects in parallel), and FLUTE/ALC does not mandate nor recommend the use of any particular one.",
      "ja": "パケット損失に対するロバスト性を提供し、オンデマンドモードの効率を向上させるために、FLUTE / ALCは、パケット消失符号化（アプリケーションレイヤ前方誤り訂正（AL-FEC））に依存しています。 （無フィードバックしたがってなし（N）ACKベースの再送がないため）、AL-FEC符号化は積極的であり、および修復データを含むALCパケットは、ソース・データを含むALCパケットとともに送信されます。いくつかのFECスキームは、標準化されています。 FLUTE / ALCは、任意の特定の1つの使用を強制しません。 ALCソースや修理パケットの送信順序に関するいくつかの戦略は、それが深くに、シーケンス内のオブジェクトの回復を好むか、他の極端にするために、例えば（提供されるサービスに影響を与えることができ、オンデマンドモードでは、具体的には、可能であり、並行して、すべてのオブジェクト）の回復を優先し、FLUTE / ALCが義務付けたり、特定の1つの使用を推奨していません。"
    },
    {
      "indent": 3,
      "text": "A FLUTE/ALC session is composed of one or more channels, associated to different destination unicast and/or multicast IP addresses. ALC packets are sent in those channels at a certain transmission rate, with a rate that often differs depending on the channel. FLUTE/ALC does not mandate nor recommend any strategy to select which ALC packet to send on which channel. FLUTE/ALC can use a multiple rate congestion control building block (e.g., Wave and Equation Based Rate",
      "ja": "FLUTE / ALCセッションは、異なる宛先ユニキャスト及び/またはマルチキャストIPアドレスに関連付けられた、1つまたは複数のチャネルから構成されています。 ALCパケットはしばしばチャネルに応じて異なる速度で、一定の伝送速度で、これらのチャネルで送信されます。 FLUTE / ALCは、どのチャネル上で送信するためにどのALCパケットを選択するための任意の戦略を義務付けるもお勧めしません。 FLUTE / ALCは、複数のレート混雑制御ビルディングブロック（例えば、波動と式ベースのレートを使用することができます"
    },
    {
      "indent": 3,
      "text": "Control (WEBRC)) to provide congestion control that is feedback free, where receivers adjust their reception rates individually by joining and leaving channels associated with the session. To that purpose, the ALC header provides a specific field to carry congestion-control-specific information. However, FLUTE/ALC does not mandate the use of a particular congestion control mechanism although WEBRC is mandatory to support for the Internet ([RFC6726], Section 1.1.4). FLUTE/ALC is often used over a network path with pre-provisioned capacity [RFC8085] where there are no flows competing for capacity. In this case, a sender-based rate control mechanism and a single channel are sufficient.",
      "ja": "受信機はセッションに関連付けられたチャネルを結合し、放置することによって個々にそれらの受信率を調整するフィードバック自由に輻輳制御を提供するために、コントロール（WEBRC））。そのために、ALCヘッダは、輻輳制御固有の情報を運ぶために特定のフィールドを提供します。 WEBRCインターネット（[RFC6726]、セクション1.1.4）をサポートすることは必須であるものの、FLUTE / ALCは、特定の輻輳制御機構の使用を強制しません。 FLUTE / ALCは、多くの場合、容量を競合なしフローが存在しない事前プロビジョニングされた容量[RFC8085]を使用してネットワークパス上で使用されています。この場合、送信ノードベースのレート制御機構と単一チャネルで十分です。"
    },
    {
      "indent": 3,
      "text": "[RFC6584] provides per-packet authentication, integrity, and anti-replay protection in the context of the ALC and NORM protocols. Several mechanisms are proposed that seamlessly integrate into these protocols using the ALC and NORM header extension mechanisms.",
      "ja": "[RFC6584]はALCとNORMプロトコルのコンテキストでパケットごとの認証、整合性、およびアンチリプレイ保護を提供します。いくつかのメカニズムをシームレスALCおよびNORMヘッダの拡張メカニズムを使用して、これらのプロトコルに統合することが提案されています。"
    },
    {
      "indent": 0,
      "text": "3.10.2. Interface Description",
      "section_title": true,
      "ja": "3.10.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "The FLUTE/ALC specification does not describe a specific API to control protocol operation. Although open source and commercial implementations have specified APIs, there is no IETF-specified API for FLUTE/ALC.",
      "ja": "FLUTE / ALC仕様は、プロトコルの動作を制御するための具体的なAPIを説明していません。オープンソースおよび商用の実装は、APIを指定しているが、FLUTE / ALCのためのIETF指定のAPIはありません。"
    },
    {
      "indent": 0,
      "text": "3.10.3. Transport Features",
      "section_title": true,
      "ja": "3.10.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by FLUTE/ALC are:",
      "ja": "FLUTE / ALCが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast, multicast, anycast, or IPv4 broadcast transmission,",
      "ja": "Oユニキャスト、マルチキャスト、エニーキャスト、またはIPv4ブロードキャスト伝送、"
    },
    {
      "indent": 3,
      "text": "o object-oriented delivery of discrete data or files and associated metadata,",
      "ja": "O離散データやファイルおよび関連するメタデータのオブジェクト指向の配信、"
    },
    {
      "indent": 3,
      "text": "o fully reliable or partially reliable delivery (of file or in-memory objects), using proactive packet erasure coding (AL-FEC) to recover from packet erasures,",
      "ja": "O完全に信頼できるまたは（ファイルまたはメモリ内のオブジェクトの）部分的に信頼できる配信、パケットの消失から回復するために積極的なパケット消失符号（AL-FEC）を使用して、"
    },
    {
      "indent": 3,
      "text": "o ordered or unordered delivery (of file or in-memory objects),",
      "ja": "O順序付けまたは（ファイルまたはメモリ内のオブジェクトの）順不同送達"
    },
    {
      "indent": 3,
      "text": "o error detection (based on the UDP checksum),",
      "ja": "（UDPチェックサムに基づいて）Oエラー検出、"
    },
    {
      "indent": 3,
      "text": "o per-packet authentication,",
      "ja": "Anthentikesanパケット、孫、"
    },
    {
      "indent": 3,
      "text": "o per-packet integrity,",
      "ja": "パケットごとの整合性O、"
    },
    {
      "indent": 3,
      "text": "o per-packet replay protection, and",
      "ja": "パケットごとのリプレイ保護O、および"
    },
    {
      "indent": 3,
      "text": "o congestion control for layered flows (e.g., with WEBRC).",
      "ja": "層状フローのO輻輳制御（例えば、WEBRC有します）。"
    },
    {
      "indent": 0,
      "text": "3.11. NACK-Oriented Reliable Multicast (NORM)",
      "section_title": true,
      "ja": "3.11。 NACK指向リライアブルマルチキャスト（NORM）"
    },
    {
      "indent": 3,
      "text": "NORM is an IETF Standards Track protocol specified in [RFC5740]. It provides object-oriented delivery of discrete data or files.",
      "ja": "NORMは、[RFC5740]で指定されたIETF標準化過程プロトコルです。これは、離散的なデータやファイルのオブジェクト指向の配信を提供します。"
    },
    {
      "indent": 3,
      "text": "The protocol was designed to support reliable bulk data dissemination to receiver groups using IP Multicast but also provides for point-to-point unicast operation. Support for bulk data dissemination includes discrete file or computer memory-based \"objects\" as well as byte and message streaming.",
      "ja": "プロトコルは、IPマルチキャストを用いた受信グループに信頼性の高いバルクデータ配布をサポートするように設計だけでなく、ポイントツーポイントのユニキャスト動作のために提供しました。バルクデータ配布のサポートは、個別のファイルまたはコンピュータのメモリベースの「オブジェクト」だけでなく、バ​​イトおよびメッセージのストリーミングが含まれています。"
    },
    {
      "indent": 3,
      "text": "NORM can incorporate packet erasure coding as a part of its selective Automatic Repeat reQuest (ARQ) in response to negative acknowledgments from the receiver. The packet erasure coding can also be proactively applied for forward protection from packet loss. NORM transmissions are governed by TCP-Friendly Multicast Congestion Control (TFMCC) [RFC4654]. The reliability, congestion control, and flow control mechanisms can be separately controlled to meet different application needs.",
      "ja": "NORMは、受信機からの否定応答に応答して、その選択自動再送要求（ARQ）の一部として、パケット消失符号化を組み込むことができます。パケット消失コーディングも積極的にパケット損失から前方保護のために適用することができます。 NORMの送信は、TCPフレンドリーマルチキャスト輻輳制御（TFMCC）[RFC4654]によって支配されています。信頼性、輻輳制御、フロー制御機構は、別々のアプリケーションのニーズを満たすように制御することができます。"
    },
    {
      "indent": 0,
      "text": "3.11.1. Protocol Description",
      "section_title": true,
      "ja": "3.11.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "The NORM protocol is encapsulated in UDP datagrams and thus provides multiplexing for multiple sockets on hosts using port numbers. For loosely coordinated IP Multicast, NORM is not strictly connection-oriented although per-sender state is maintained by receivers for protocol operation. [RFC5740] does not specify a handshake protocol for connection establishment. Separate session initiation can be used to coordinate port numbers. However, in-band \"client-server\" style connection establishment can be accomplished with the NORM congestion control signaling messages using port binding techniques like those for TCP client-server connections.",
      "ja": "NORMプロトコルは、UDPデータグラムにカプセル化され、したがって、ポート番号を使用して、ホスト上の複数のソケットのための多重化を提供します。毎の送信者の状態がプロトコル動作のための受信機によって維持されているものの、緩やかに調整されたIPマルチキャストの場合は、NORMは厳密に接続指向ではありません。 [RFC5740]は、接続確立のためのハンドシェイクプロトコルを指定していません。別のセッションの開始は、ポート番号を調整するために使用することができます。しかし、インバンド「クライアント - サーバ」スタイルの接続確立は、TCPクライアント・サーバ接続のためのそれらのようなポート結合技術を使用してシグナリングメッセージをNORMの輻輳制御を行うことができます。"
    },
    {
      "indent": 3,
      "text": "NORM supports bulk \"objects\" such as file or in-memory content but also can treat a stream of data as a logical bulk object for purposes of packet erasure coding. In the case of stream transport, NORM can support either byte streams or message streams where application-defined message boundary information is carried in the NORM protocol messages. This allows the receiver(s) to join/rejoin and recover message boundaries mid-stream as needed. Application content is carried and identified by the NORM protocol with encoding symbol identifiers depending upon the Forward Error Correction (FEC) Scheme [RFC5052] configured. NORM uses NACK-based selective ARQ to reliably deliver the application content to the receiver(s). NORM proactively measures round-trip timing information to scale ARQ timers appropriately and to support congestion control. For multicast operation, timer-based feedback suppression is used to achieve group size scaling with low feedback traffic levels. The feedback suppression is not applied for unicast operation.",
      "ja": "NORMは、そのようなファイルやメモリ内のコンテンツとしてバルク「オブジェクト」をサポートしていますが、またパケット消失符号化の目的のための論理的なバルクオブジェクトとしてデータのストリームを扱うことができます。ストリーム転送の場合には、NORMは、いずれかのバイトストリームまたはメッセージをサポートすることができるアプリケーション定義メッセージ境界情報をNORMプロトコルメッセージで搬送されるストリーム。これは、受信機（s）が参加/再参加し、必要に応じてメッセージの境界にミッドストリームを復元することができます。アプリケーションコンテンツは、前方誤り訂正（FEC）スキーム[RFC5052]構成に応じて符号化シンボル識別子を持つNORMプロトコルによって運ばれ、識別されます。 NORMが確実に受信機（複数可）へのアプリケーションコンテンツを配信するためにNACKベースの選択的ARQを使用します。 NORMは積極的に適切ARQタイマーを拡張する往復タイミング情報を計測し、輻輳制御をサポートします。マルチキャスト動作のために、タイマーベースのフィードバック抑制は、低フィードバックトラフィックレベルとグループサイズのスケーリングを達成するために使用されます。フィードバック抑制は、ユニキャスト動作のために適用されません。"
    },
    {
      "indent": 3,
      "text": "NORM uses rate-based congestion control based upon the TCP-Friendly Rate Control (TFRC) [RFC5348] principles that are also used in DCCP [RFC4340]. NORM uses control messages to measure RTT and collect congestion event information (e.g., reflecting a loss event or ECN event) from the receiver(s) to support dynamic adjustment or the rate. TCP-Friendly Multicast Congestion Control (TFMCC) [RFC4654] provides extra features to support multicast but is functionally equivalent to TFRC for unicast.",
      "ja": "NORMはまた、DCCP [RFC4340]で使用されるTCPフレンドリーレート制御（TFRC）[RFC5348]の原理に基づいて、レートベースの輻輳制御を使用します。 NORMは、RTTを測定し、動的調節またはレートをサポートするために、受信機（複数可）から（損失イベントまたはECNイベントを反映例えば、）輻輳イベント情報を収集するために、制御メッセージを使用します。 TCPフレンドリーマルチキャスト輻輳制御（TFMCC）[RFC4654]はマルチキャストをサポートするための追加機能を提供するが、ユニキャスト用TFRCと機能的に同等です。"
    },
    {
      "indent": 3,
      "text": "Error detection and verification of the protocol control information relies on the on the underlying transport (e.g., UDP checksum).",
      "ja": "プロトコル制御情報のエラー検出及び検証は、基礎となるトランスポート上で（例えば、UDPチェックサム）に依存しています。"
    },
    {
      "indent": 3,
      "text": "The reliability mechanism is decoupled from congestion control. This allows invocation of alternative arrangements of transport services, for example, to support, fixed-rate reliable delivery or unreliable delivery (that may optionally be \"better than best effort\" via packet erasure coding) using TFRC. Alternative congestion control techniques may be applied, for example, TFRC with congestion event detection based on ECN.",
      "ja": "信頼メカニズムは、輻輳制御から切り離されます。これは、TFRCを使用して（つまり、必要に応じてパケット消失・コーディングを経て、「最善の努力よりも良い」であってもよい）、固定金利、信頼性の高い配信や信頼性のない配信をサポートするために、例えば、輸送サービスの代替構成の呼び出しを可能にします。代替的な輻輳制御技術は、TFRCは、ECNに基づいて、輻輳イベントの検出を、例えば、適用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "While NORM provides NACK-based reliability, it also supports a positive acknowledgment (ACK) mechanism that can be used for receiver flow control. This mechanism is decoupled from the reliability and congestion control, supporting applications with different needs. One example is use of NORM for quasi-reliable delivery, where timely delivery of newer content may be favored over completely reliable delivery of older content within buffering and RTT constraints.",
      "ja": "NORMがNACKベースの信頼性を提供するが、それはまた、受信フロー制御のために使用することができる肯定応答（ACK）機構をサポートします。この機構は、異なるニーズを持つアプリケーションをサポートする、信頼性および輻輳制御から切り離されます。一つの例は、新しいコンテンツのタイムリーな配信は、バッファリングとRTT制約の中で、古いコンテンツの完全に信頼性の高い配信よりも優先することができる準信頼性の高い配信のためのNORMの使用です。"
    },
    {
      "indent": 0,
      "text": "3.11.2. Interface Description",
      "section_title": true,
      "ja": "3.11.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "The NORM specification does not describe a specific API to control protocol operation. A freely available, open-source reference implementation of NORM is available at <https://www.nrl.navy.mil/itd/ncs/products/norm>, and a documented API is provided for this implementation. While a sockets-like API is not currently documented, the existing API supports the necessary functions for that to be implemented.",
      "ja": "NORM仕様は、プロトコルの動作を制御するための具体的なAPIを説明していません。 NORMの自由に利用できる、オープンソースのリファレンス実装は、<https://www.nrl.navy.mil/itd/ncs/products/norm>で入手可能であり、文書APIが、この実施のために設けられています。ソケットのようなAPIが現在文書化されていないが、既存のAPIはそのために必要な機能を実装するためにサポートしています。"
    },
    {
      "indent": 0,
      "text": "3.11.3. Transport Features",
      "section_title": true,
      "ja": "3.11.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport features provided by NORM are:",
      "ja": "NORMが提供するトランスポート機能は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o unicast or multicast transport,",
      "ja": "Oユニキャストまたはマルチキャスト輸送、"
    },
    {
      "indent": 3,
      "text": "o unidirectional communication,",
      "ja": "一方向のコミュニケーションO、"
    },
    {
      "indent": 3,
      "text": "o stream-oriented delivery in a single stream or object-oriented delivery of in-memory data or file bulk content objects,",
      "ja": "単一のストリームまたはメモリ内のデータまたはファイルバルクコンテンツオブジェクトのオブジェクト指向の配信中のOストリーム指向の配信、"
    },
    {
      "indent": 3,
      "text": "o fully reliable (NACK-based) or partially reliable (using erasure coding both proactively and as part of ARQ) delivery,",
      "ja": "O（両方の積極的及びARQの一部として符号化消去を使用して）十分な信頼性（NACKベース）または部分的に信頼できる配信、"
    },
    {
      "indent": 3,
      "text": "o unordered delivery,",
      "ja": "O順不同配信、"
    },
    {
      "indent": 3,
      "text": "o error detection (relies on UDP checksum),",
      "ja": "Oエラー検出（UDPチェックサムに依存しています）、"
    },
    {
      "indent": 3,
      "text": "o segmentation,",
      "ja": "ああ、セグメンテーション、"
    },
    {
      "indent": 3,
      "text": "o data bundling (using Nagle's algorithm),",
      "ja": "Oデータバンドル（Nagleアルゴリズムを使用して）、"
    },
    {
      "indent": 3,
      "text": "o flow control (timer-based and/or ACK-based), and",
      "ja": "O制御（タイマベース及び/又はACKベースの）フロー、および"
    },
    {
      "indent": 3,
      "text": "o congestion control (also supporting fixed-rate reliable or unreliable delivery).",
      "ja": "（また、固定レートが信頼できる又は信頼性のない配信支持）O輻輳制御。"
    },
    {
      "indent": 0,
      "text": "3.12. Internet Control Message Protocol (ICMP)",
      "section_title": true,
      "ja": "3.12。インターネット制御メッセージプロトコル（ICMP）"
    },
    {
      "indent": 3,
      "text": "The Internet Control Message Protocol (ICMP) [RFC792] for IPv4 and ICMP for IPv6 [RFC4443] are IETF Standards Track protocols. It is a connectionless unidirectional protocol that delivers individual messages, without error correction, congestion control, or flow control. Messages may be sent as unicast, IPv4 broadcast, or multicast datagrams (IPv4 and IPv6), in addition to anycast datagrams.",
      "ja": "IPv6の[RFC4443]のためのIPv4およびICMPのためのインターネット制御メッセージプロトコル（ICMP）[RFC792]は、IETF標準化過程プロトコルです。これは、エラー訂正、輻輳制御、またはフロー制御なしに、個々のメッセージを配信するコネクションレス一方向プロトコルです。メッセージは、エニーキャストデータグラムに加えて、ユニキャスト、IPv4のブロードキャスト、またはマルチキャストデータグラム（IPv4およびIPv6）として送信されても​​よいです。"
    },
    {
      "indent": 3,
      "text": "While ICMP is not typically described as a transport protocol, it does position itself over the network layer, and the operation of other transport protocols can be closely linked to the functions provided by ICMP.",
      "ja": "ICMPは、典型的には、トランスポートプロトコルとして記載されていないが、それは、ネットワーク層の上に位置自体を行い、そして他のトランスポートプロトコルの動作は、密接にICMPによって提供される機能にリンクすることができます。"
    },
    {
      "indent": 3,
      "text": "Transport protocols and upper-layer protocols can use received ICMP messages to help them make appropriate decisions when network or endpoint errors are reported, for example, to implement ICMP-based Path MTU Discovery (PMTUD) [RFC1191] [RFC1981] or assist in Packetization Layer PMTUD (PLPMTUD) [RFC4821]. Such reactions to received messages need to protect from off-path data injection",
      "ja": "トランスポートプロトコルと上位層プロトコルは、それらがネットワークまたはエンドポイントのエラーが報告されている場合、例えば、ICMPベースのパスMTUディスカバリ（PMTUD）[RFC1191] [RFC1981]を実装するか、パケット化に役立つ適切な意思決定を支援するために、受信したICMPメッセージを使用することができますPMTUD（PLPMTUD）[RFC4821]をレイヤ。受信したメッセージにこのような反応は、オフパスデータの注入から保護する必要があります"
    },
    {
      "indent": 3,
      "text": "[RFC8085] to avoid an application receiving packets created by an unauthorized third party. An application therefore needs to ensure that all messages are appropriately validated by checking the payload of the messages to ensure they are received in response to actually transmitted traffic (e.g., a reported error condition that corresponds to a UDP datagram or TCP segment was actually sent by the application). This requires context [RFC6056], such as local state about communication instances to each destination (e.g., in TCP, DCCP, or SCTP). This state is not always maintained by UDP-based applications [RFC8085].",
      "ja": "[RFC8085]は権限のない第三者が作成したパケットを受信するアプリケーションを避けるために。アプリケーションは、それゆえ、彼らは例えば、UDPデータグラムまたはTCPセグメントに対応する報告されたエラー条件が実際により送信された、実際に送信されたトラフィック（に応答して受信されることを保証するために、メッセージのペイロードをチェックすることにより、すべてのメッセージが適切に検証されていることを確認する必要がありますアプリケーション）。これは、（例えば、TCP、DCCP、又はSCTPにおける）各宛先への通信インスタンスに関するローカル状態として、コンテキスト[RFC6056]を必要とします。この状態は、常にUDPベースのアプリケーション[RFC8085]によって維持されていません。"
    },
    {
      "indent": 0,
      "text": "3.12.1. Protocol Description",
      "section_title": true,
      "ja": "3.12.1。プロトコル説明"
    },
    {
      "indent": 3,
      "text": "ICMP is a connectionless unidirectional protocol. It delivers independent messages, called \"datagrams\". Each message is required to carry a checksum as an integrity check and to protect from misdelivery to an unintended endpoint.",
      "ja": "ICMPはコネクションレス型の一方向性のプロトコルです。それは、「データグラム」と呼ばれる独立したメッセージを、提供しています。各メッセージは、整合性チェックなどのチェックサムを運ぶために意図しないエンドポイントに誤配信から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "ICMP messages typically relay diagnostic information from an endpoint [RFC1122] or network device [RFC1812] addressed to the sender of a flow. This usually contains the network protocol header of a packet that encountered a reported issue. Some formats of messages can also carry other payload data. Each message carries an integrity check calculated in the same way as for UDP; this checksum is not optional.",
      "ja": "ICMPメッセージは、典型的には、[RFC1122]またはネットワークデバイス[RFC1812]は、フローの送信者宛エンドポイントからの診断情報を中継します。これは通常、報告された問題が発生したパケットのネットワークプロトコルヘッダが含まれています。メッセージの一部の形式は、他のペイロードデータを運ぶことができます。各メッセージにはUDPと同じ方法で算出した整合性チェックを運びます。このチェックサムはオプションではありません。"
    },
    {
      "indent": 3,
      "text": "The RFC Series defines additional IPv6 message formats to support a range of uses. In the case of IPv6, the protocol incorporates neighbor discovery [RFC4861] [RFC3971] (provided by ARP for IPv4) and Multicast Listener Discovery (MLD) [RFC2710] group management functions (provided by IGMP for IPv4).",
      "ja": "RFCシリーズは、用途の範囲をサポートするために追加のIPv6メッセージフォーマットを定義します。 IPv6の場合では、プロトコルは、およびMulticast Listener Discovery（MLD）（IPv4のARPによって提供される）近隣探索[RFC4861]、[RFC3971]（IPv4のIGMPによって提供される）[RFC2710]グループ管理機能を組み込んでいます。"
    },
    {
      "indent": 3,
      "text": "Reliable transmission cannot be assumed. A receiving application that is unable to run sufficiently fast, or frequently, may miss messages since there is no flow or congestion control. In addition, some network devices rate-limit ICMP messages.",
      "ja": "信頼性の高い伝送を想定することはできません。十分に速く走ることができない、またはまったく流れや輻輳制御がないので、頻繁に、メッセージを見逃す可能性が受信アプリケーション。また、一部のネットワークデバイスのレート制限ICMPメッセージ。"
    },
    {
      "indent": 0,
      "text": "3.12.2. Interface Description",
      "section_title": true,
      "ja": "3.12.2。インターフェイス説明"
    },
    {
      "indent": 3,
      "text": "ICMP processing is integrated in many connection-oriented transports but, like other functions, needs to be provided by an upper-layer protocol when using UDP and UDP-Lite.",
      "ja": "ICMP処理は、多くの接続指向トランスポートに統合しかし、他の機能と同様に、UDPおよびUDP-Liteの使用時上位層プロトコルによって提供される必要があります。"
    },
    {
      "indent": 3,
      "text": "On some stacks, a bound socket also allows a UDP application to be notified when ICMP error messages are received for its transmissions [RFC8085].",
      "ja": "いくつかのスタックでは、バインドされたソケットは、ICMPエラーメッセージがその送信[RFC8085]のために受信されたときにUDPアプリケーションが通知を受けることができます。"
    },
    {
      "indent": 3,
      "text": "Any response to ICMP error messages ought to be robust to temporary routing failures (sometimes called \"soft errors\"), e.g., transient ICMP \"unreachable\" messages ought to not normally cause a communication abort [RFC5461] [RFC8085].",
      "ja": "ICMPエラーメッセージに対する応答は、例えば、過渡ICMP「到達不能」メッセージが正常に通信中断[RFC5461]、[RFC8085]を引き起こさないべきである（時には「ソフトエラー」と呼ばれる）臨時経路障害に対してロバストであるべきです。"
    },
    {
      "indent": 0,
      "text": "3.12.3. Transport Features",
      "section_title": true,
      "ja": "3.12.3。トランスポート機能"
    },
    {
      "indent": 3,
      "text": "ICMP does not provide any transport service directly to applications. Used together with other transport protocols, it provides transmission of control, error, and measurement data between endpoints or from devices along the path to one endpoint.",
      "ja": "ICMPは、アプリケーションに直接任意の輸送サービスを提供していません。他のトランスポートプロトコルと一緒に使用、制御、エラー、およびエンドポイント間または1つのエンドポイントへのパスに沿って装置からの測定データの送信を提供します。"
    },
    {
      "indent": 0,
      "text": "4. Congestion Control",
      "section_title": true,
      "ja": "4.輻輳制御"
    },
    {
      "indent": 3,
      "text": "Congestion control is critical to the stable operation of the Internet. A variety of mechanisms are used to provide the congestion control needed by many Internet transport protocols. Congestion is detected based on sensing of network conditions, whether through explicit or implicit feedback. The congestion control mechanisms that can be applied by different transport protocols are largely orthogonal to the choice of transport protocol. This section provides an overview of the congestion control mechanisms available to the protocols described in Section 3.",
      "ja": "輻輳制御は、インターネットの安定動作に重要です。様々なメカニズムは、多くのインターネット・トランスポート・プロトコルで必要な輻輳制御を提供するために使用されています。輻輳がかどうか明示的または暗示的なフィードバックを介して、ネットワークの状態の検知に基づいて検出されます。異なるトランスポートプロトコルによって適用することができる輻輳制御機構は、トランスポートプロトコルの選択にほぼ直交しています。このセクションは、セクション3に記載されたプロトコルが利用可能な輻輳制御機構の概要を提供します。"
    },
    {
      "indent": 3,
      "text": "Many protocols use a separate window to determine the maximum sending rate that is allowed by the congestion control. The used congestion control mechanism will increase the congestion window if feedback is received that indicates that the currently used network path is not congested and will reduce the window otherwise. Window-based mechanisms often increase their window slowing over multiple RTTs, while decreasing strongly when the first indication of congestion is received. One example is an Additive Increase Multiplicative Decrease (AIMD) scheme, where the window is increased by a certain number of packets/bytes for each data segment that has been successfully transmitted, while the window decreases multiplicatively on the occurrence of a congestion event. This can lead to a rather unstable, oscillating sending rate but will resolve a congestion situation quickly. Examples of window-based AIMD schemes include TCP NewReno [RFC5681], TCP Cubic [CUBIC] (the default mechanism for TCP in Linux), and CCID 2 specified for DCCP [RFC4341].",
      "ja": "多くのプロトコルは、輻輳制御により許容される最大送信レートを決定するために、別のウィンドウを使用します。フィードバックは、現在使用されているネットワーク経路が混雑していないことを示し、それ以外のウィンドウを削減することが受信される場合に使用される輻輳制御機構は、輻輳ウィンドウが増大します。輻輳の最初の指示を受信したとき、強く減少させながらウインドウベースのメカニズムは、多くの場合、複数のRTT上遅く、そのウィンドウを増加させます。一例では、添加剤は、ウィンドウが輻輳イベントの発生に乗算減少するウィンドウは、正常に送信された各データセグメントのためのパケット/バイトの一定数だけ増加する乗算減少（AIMD）スキームを、増加です。これはかなり不安定、振動送信レートにつながることができますが、すぐに混雑状況を解決します。ウィンドウベースのAIMDスキームの例は、TCP NewRenoの[RFC5681]、TCPキュービック[キュービック]（LinuxではTCPのデフォルトのメカニズム）、およびDCCP [RFC4341]に指定されたCCID 2が挙げられます。"
    },
    {
      "indent": 3,
      "text": "Some classes of applications prefer to use a transport service that allows sending at a more stable rate that is slowly varied in response to congestion. Rate-based methods offer this type of congestion control and have been defined based on the loss ratio and observed round-trip time, such as TFRC [RFC5348] and TFRC-SP",
      "ja": "アプリケーションの一部のクラスは、混雑に応じて徐々に変化させ、より安定した速度で送信することができます輸送サービスを使用することを好みます。レートベースの方法は、輻輳制御のこのタイプを提供し、そのようなTFRC [RFC5348]及びTFRC-SPとして、損失率と観察された往復時間に基づいて定義されています"
    },
    {
      "indent": 3,
      "text": "[RFC4828]. These methods utilize a throughput equation to determine the maximum acceptable rate. Such methods are used with DCCP CCID 3 [RFC4342], CCID 4 [RFC5622], WEBRC [RFC3738], and other applications.",
      "ja": "[RFC4828]。これらの方法は、最大許容レートを決定するために、スループット方程式を利用します。そのような方法はDCCP CCID 3 [RFC4342]、CCID 4 [RFC5622]、WEBRC [RFC3738]、および他のアプリケーションで使用されています。"
    },
    {
      "indent": 3,
      "text": "Another class of applications prefers a transport service that yields to other (higher-priority) traffic, such as interactive transmissions. While most traffic in the Internet uses loss-based congestion control and therefore tends to fill the network buffers (to a certain level if Active Queue Management (AQM) is used), low-priority congestion control methods often react to changes in delay as an earlier indication of congestion. This approach tends to induce less loss than a loss-based method but does generally not compete well with loss-based traffic across shared bottleneck links. Therefore, methods such as LEDBAT [RFC6817] are deployed in the Internet for scavenger traffic that aims to only utilize otherwise unused capacity.",
      "ja": "アプリケーションの別のクラスは、このような対話型の送信など、他の（優先度の高い）トラフィックに与える輸送サービスを好みます。インターネットのほとんどのトラフィックは損失ベースの輻輳制御を使用し、したがって、（アクティブキュー管理（AQM）が使用される場合、特定のレベルに）ネットワークバッファを充填する傾向があるが、低優先輻輳制御方法は、しばしば、遅延の変化に反応します混雑の以前の兆候。このアプローチは、損失ベースの方法よりも少ない損失を誘発することが、一般的に共有ボトルネックリンク間で損失ベースのトラフィックとうまく競合しない傾向があります。したがって、そのようなLEDBAT [RFC6817]などの方法のみ、さもなければ未使用容量を利用することを目的スカベンジャートラフィックのためのインターネットに配備されています。"
    },
    {
      "indent": 0,
      "text": "5. Transport Features",
      "section_title": true,
      "ja": "5.トランスポート機能"
    },
    {
      "indent": 3,
      "text": "The transport protocol features described in this document can be used as a basis for defining common transport features. These are listed below with the protocols supporting them:",
      "ja": "この文書に記載され、トランスポートプロトコル機能は、共通のトランスポート機能を定義するための基礎として使用することができます。これらは、それらをサポートするプロトコルで、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Control Functions",
      "ja": "O制御機能"
    },
    {
      "indent": 6,
      "text": "* Addressing",
      "ja": "*アドレッシング"
    },
    {
      "indent": 9,
      "text": "+ unicast (TCP, MPTCP, UDP, UDP-Lite, SCTP, DCCP, TLS, RTP, HTTP, ICMP)",
      "ja": "+ユニキャスト（TCP、MPTCP、UDP、UDP-Liteは、SCTP、DCCP、TLS、RTP、HTTP、ICMP）"
    },
    {
      "indent": 9,
      "text": "+ multicast (UDP, UDP-Lite, RTP, ICMP, FLUTE/ALC, NORM). Note that, as TLS and DTLS are unicast-only, there is no widely deployed mechanism for supporting the features listed under the Security bullet (below) when using multicast addressing.",
      "ja": "+マルチキャスト（UDP、UDP-Liteは、RTP、ICMP、FLUTE / ALC、NORM）。 TLSとDTLSは、ユニキャストのみであるようにアドレッシングマルチキャストを使用する場合、（以下）セキュリティ弾丸の下にリストされた機能をサポートするための広く展開機構が存在しないことに留意されたいです。"
    },
    {
      "indent": 9,
      "text": "+ IPv4 broadcast (UDP, UDP-Lite, ICMP)",
      "ja": "+のIPv4ブロードキャスト（UDP、UDP-Liteは、ICMP）"
    },
    {
      "indent": 9,
      "text": "+ anycast (UDP, UDP-Lite). Connection-oriented protocols such as TCP and DCCP have also been deployed using anycast addressing, with the risk that routing changes may cause connection failure.",
      "ja": "+エニーキャスト（UDP、UDP-Liteは）。 TCPやDCCPなどの接続指向のプロトコルも、ルーティングの変更が接続障害を引き起こす可能性があり危険で、エニーキャストアドレッシングを使用して展開されています。"
    },
    {
      "indent": 6,
      "text": "* Association type",
      "ja": "*協会タイプ"
    },
    {
      "indent": 9,
      "text": "+ connection-oriented (TCP, MPTCP, DCCP, SCTP, TLS, RTP, HTTP, NORM)",
      "ja": "+コネクション型（TCP、MPTCP、DCCP、SCTP、TLS、RTP、HTTP、NORM）"
    },
    {
      "indent": 9,
      "text": "+ connectionless (UDP, UDP-Lite, FLUTE/ALC)",
      "ja": "+コネクションレス（UDP、UDP-Liteは、FLUTE / ALC）"
    },
    {
      "indent": 6,
      "text": "* Multihoming support",
      "ja": "*マルチホーミングサポート"
    },
    {
      "indent": 9,
      "text": "+ resilience and mobility (MPTCP, SCTP)",
      "ja": "+回復力とモビリティ（MPTCP、SCTP）"
    },
    {
      "indent": 9,
      "text": "+ load balancing (MPTCP)",
      "ja": "+負荷分散（MPTCP）"
    },
    {
      "indent": 9,
      "text": "+ address family multiplexing (MPTCP, SCTP)",
      "ja": "+アドレスファミリ多重化（MPTCP、SCTP）"
    },
    {
      "indent": 6,
      "text": "* Middlebox cooperation",
      "ja": "*ミドル協力"
    },
    {
      "indent": 9,
      "text": "+ application-class signaling to middleboxes (DCCP)",
      "ja": "+中間装置へのアプリケーションクラスのシグナリング（DCCP）"
    },
    {
      "indent": 9,
      "text": "+ error condition signaling from middleboxes and routers to endpoints (ICMP)",
      "ja": "エンドポイントに中間装置及びルータからのシグナリング+エラー条件（ICMP）"
    },
    {
      "indent": 6,
      "text": "* Signaling",
      "ja": "*シグナリング"
    },
    {
      "indent": 9,
      "text": "+ control information and error signaling (ICMP)",
      "ja": "+制御情報及びエラー通知（ICMP）"
    },
    {
      "indent": 9,
      "text": "+ application performance reporting (RTP)",
      "ja": "+アプリケーションのパフォーマンス・レポート（RTP）"
    },
    {
      "indent": 3,
      "text": "o Delivery",
      "ja": "O配信"
    },
    {
      "indent": 6,
      "text": "* Reliability",
      "ja": "*信頼性"
    },
    {
      "indent": 9,
      "text": "+ fully reliable delivery (TCP, MPTCP, SCTP, TLS, HTTP, FLUTE/ ALC, NORM)",
      "ja": "+完全に信頼性の高い配信（TCP、MPTCP、SCTP、TLS、HTTP、FLUTE / ALC、NORM）"
    },
    {
      "indent": 9,
      "text": "+ partially reliable delivery (SCTP, NORM)",
      "ja": "+部分的に信頼性の高い配信（SCTP、NORM）"
    },
    {
      "indent": 12,
      "text": "- using packet erasure coding (RTP, FLUTE/ALC, NORM)",
      "ja": " - コーディングパケット消失を使用して（RTP、FLUTE / ALC、NORM）"
    },
    {
      "indent": 12,
      "text": "- with specified policy for dropped messages (SCTP)",
      "ja": " - ドロップされたメッセージ（SCTP）のために指定したポリシーを持ちます"
    },
    {
      "indent": 9,
      "text": "+ unreliable delivery (SCTP, UDP, UDP-Lite, DCCP, RTP)",
      "ja": "+信頼性のない配信（SCTP、UDP、UDP-Liteは、DCCP、RTP）"
    },
    {
      "indent": 12,
      "text": "- with drop notification to sender (SCTP, DCCP, RTP)",
      "ja": " - 送信者にドロップ通知（SCTP、DCCP、RTP）と"
    },
    {
      "indent": 9,
      "text": "+ error detection",
      "ja": "+エラー検出"
    },
    {
      "indent": 12,
      "text": "- checksum for error detection (TCP, MPTCP, UDP, UDP-Lite, SCTP, DCCP, TLS, DTLS, FLUTE/ALC, NORM, ICMP)",
      "ja": " - エラー検出のためのチェックサム（TCP、MPTCP、UDP、UDP-Liteは、SCTP、DCCP、TLS、DTLS、FLUTE / ALC、NORM、ICMP）"
    },
    {
      "indent": 12,
      "text": "- partial payload checksum protection (UDP-Lite, DCCP). Some uses of RTP can exploit partial payload checksum protection feature to provide a corruption-tolerant transport service.",
      "ja": " - 部分的なペイロードのチェックサム保護（UDP-Liteは、DCCP）。 RTPのいくつかの用途は、汚職・トレラントな輸送サービスを提供するために、部分的なペイロードチェックサム保護機能を利用することができます。"
    },
    {
      "indent": 12,
      "text": "- checksum optional (UDP). Possible with IPv4 and, in certain cases, with IPv6.",
      "ja": " - チェックサムオプション（UDP）。 IPv6でIPv4と、特定のケースでは、との可能性。"
    },
    {
      "indent": 6,
      "text": "* Ordering",
      "ja": "*注文"
    },
    {
      "indent": 9,
      "text": "+ ordered delivery (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE)",
      "ja": "+命じ配信（TCP、MPTCP、SCTP、TLS、RTP、HTTP、FLUTE）"
    },
    {
      "indent": 9,
      "text": "+ unordered delivery permitted (UDP, UDP-Lite, SCTP, DCCP, RTP, NORM)",
      "ja": "+順不同配信が許可（UDP、UDP-Liteは、SCTP、DCCP、RTP、NORM）"
    },
    {
      "indent": 6,
      "text": "* Type/framing",
      "ja": "*タイプ/フレーミング"
    },
    {
      "indent": 9,
      "text": "+ stream-oriented delivery (TCP, MPTCP, SCTP, TLS, HTTP)",
      "ja": "+ストリーム指向送達（TCP、MPTCP、SCTP、TLS、HTTP）"
    },
    {
      "indent": 12,
      "text": "- with multiple streams per association (SCTP, HTTP2)",
      "ja": " - 協会（SCTP、HTTP2）ごとに複数のストリームを持ちます"
    },
    {
      "indent": 9,
      "text": "+ message-oriented delivery (UDP, UDP-Lite, SCTP, DCCP, DTLS, RTP)",
      "ja": "+メッセージ指向送達（UDP、UDP-Liteは、SCTP、DCCP、DTLS、RTP）"
    },
    {
      "indent": 9,
      "text": "+ object-oriented delivery of discrete data or files and associated metadata (HTTP, FLUTE/ALC, NORM)",
      "ja": "+離散データまたはファイルと関連するメタデータのオブジェクト指向送達（HTTP、FLUTE / ALC、NORM）"
    },
    {
      "indent": 12,
      "text": "- with partial delivery of object ranges (HTTP)",
      "ja": " - 対象範囲の部分の送達との（HTTP）"
    },
    {
      "indent": 6,
      "text": "* Directionality",
      "ja": "*方向性"
    },
    {
      "indent": 9,
      "text": "+ unidirectional (UDP, UDP-Lite, DCCP, RTP, FLUTE/ALC, NORM)",
      "ja": "+単方向（UDP、UDP-Liteは、DCCP、RTP、FLUTE / ALC、NORM）"
    },
    {
      "indent": 9,
      "text": "+ bidirectional (TCP, MPTCP, SCTP, TLS, HTTP)",
      "ja": "+双方向（TCP、MPTCP、SCTP、TLS、HTTP）"
    },
    {
      "indent": 3,
      "text": "o Transmission control",
      "ja": "O送信制御"
    },
    {
      "indent": 6,
      "text": "* flow control (TCP, MPTCP, SCTP, DCCP, TLS, RTP, HTTP)",
      "ja": "*フロー制御（TCP、MPTCP、SCTP、DCCP、TLS、RTP、HTTP）"
    },
    {
      "indent": 6,
      "text": "* congestion control (TCP, MPTCP, SCTP, DCCP, RTP, FLUTE/ALC, NORM). Congestion control can also provided by the transport supporting an upper-layer transport (e.g., TLS, RTP, HTTP).",
      "ja": "*輻輳制御（TCP、MPTCP、SCTP、DCCP、RTP、FLUTE / ALC、NORM）。輻輳制御は、上位層トランスポート（例えば、TLS、RTP、HTTP）をサポートするトランスポートによって提供することができます。"
    },
    {
      "indent": 6,
      "text": "* segmentation (TCP, MPTCP, SCTP, TLS, RTP, HTTP, FLUTE/ALC, NORM)",
      "ja": "*セグメンテーション（TCP、MPTCP、SCTP、TLS、RTP、HTTP、FLUTE / ALC、NORM）"
    },
    {
      "indent": 6,
      "text": "* data/message bundling (TCP, MPTCP, SCTP, TLS, HTTP)",
      "ja": "*データ/メッセージバンドル（TCP、MPTCP、SCTP、TLS、HTTP）"
    },
    {
      "indent": 6,
      "text": "* stream scheduling prioritization (SCTP, HTTP2)",
      "ja": "*ストリームのスケジューリング優先順位付け（SCTP、HTTP2）"
    },
    {
      "indent": 6,
      "text": "* endpoint multiplexing (MPTCP)",
      "ja": "*エンドポイント多重化（MPTCP）"
    },
    {
      "indent": 3,
      "text": "o Security",
      "ja": "Oのセキュリティ"
    },
    {
      "indent": 6,
      "text": "* authentication of one end of a connection (TLS, DTLS, FLUTE/ ALC)",
      "ja": "*接続の一端の認証（TLS、DTLS、FLUTE / ALC）"
    },
    {
      "indent": 6,
      "text": "* authentication of both ends of a connection (TLS, DTLS)",
      "ja": "*接続の両端の認証（TLS、DTLS）"
    },
    {
      "indent": 6,
      "text": "* confidentiality (TLS, DTLS)",
      "ja": "*機密性（TLS、DTLS）"
    },
    {
      "indent": 6,
      "text": "* cryptographic integrity protection (TLS, DTLS)",
      "ja": "*暗号の完全性保護（TLS、DTLS）"
    },
    {
      "indent": 6,
      "text": "* replay protection (TLS, DTLS, FLUTE/ALC)",
      "ja": "*リプレイ保護（TLS、DTLS、FLUTE / ALC）"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document surveys existing transport protocols and protocols providing transport-like services. Confidentiality, integrity, and authenticity are among the features provided by those services. This document does not specify any new features or mechanisms for providing these features. Each RFC referenced by this document discusses the security considerations of the specification it contains.",
      "ja": "この文書の調査は、トランスポートプロトコルおよびトランスポートのようなサービスを提供するプロトコルを、既存の。機密性、完全性、信憑性は、それらのサービスが提供する機能の一つです。この文書では、これらの機能を提供するための任意の新機能やメカニズムを指定していません。このドキュメントで参照される各RFCは、それが含まれている仕様のセキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "8. Informative References",
      "section_title": true,
      "ja": "8.参考文献"
    },
    {
      "indent": 3,
      "text": "[ClarkArch] Clark, D. and D. Tennenhouse, \"Architectural Considerations for a New Generation of Protocols\", Proceedings of ACM SIGCOMM, DOI 10.1145/99517.99553, 1990.",
      "ja": "[ClarkArch]クラーク、D.とD. Tennenhouse、 \"プロトコルの新世代のための建築に関する注意事項\"、ACM SIGCOMM、DOI 10.1145 / 99517.99553、1990年の議事。"
    },
    {
      "indent": 3,
      "text": "[CUBIC] Rhee, I., Xu, L., Ha, S., Zimmermann, A., Eggert, L., and R. Scheffenegger, \"CUBIC for Fast Long-Distance Networks\", Work in Progress, draft-ietf-tcpm-cubic-04, February 2017.",
      "ja": "[CUBIC]李承晩、I.、徐、L.、ハ、S.、ツィンマーマン、A.、 \"高速長距離ネットワーク向けCUBIC\" エッゲルト、L.、およびR. Scheffenegger、進行中で働いて、ドラフトIETF -tcpm立方-04、2017年2月。"
    },
    {
      "indent": 3,
      "text": "[MBMS] 3GPP, \"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs\", 3GPP TS 26.346, 2015, <http://www.3gpp.org/DynaReport/26346.htm>.",
      "ja": "【MBMS] 3GPP、 \"マルチメディアブロードキャスト/マルチキャストサービス（MBMS）;プロトコルとコーデック\"、3GPP TS 26.346、2015年<http://www.3gpp.org/DynaReport/26346.htm>。"
    },
    {
      "indent": 3,
      "text": "[NAT-SUPP] Stewart, R., Tuexen, M., and I. Ruengeler, \"Stream Control Transmission Protocol (SCTP) Network Address Translation Support\", Work in Progress, draft-ietf-tsvwg-natsupp-09, May 2016.",
      "ja": "[NAT-SUPP]スチュワート、R.、Tuexen、M.、およびI. Ruengeler、 \"ストリーム制御伝送プロトコル（SCTP）ネットワークアドレス変換のサポート\" が進行中で働いて、ドラフト-IETF-TSVWG-natsupp-09、2016月。"
    },
    {
      "indent": 3,
      "text": "[POSIX] IEEE, \"Standard for Information Technology -- Portable Operating System Interface (POSIX(R)) Base Specifications, Issue 7\", IEEE 1003.1, DOI 10.1109/ieeestd.2016.7582338, <http://ieeexplore.ieee.org/document/7582338/>.",
      "ja": "[POSIX] IEEE、 \"情報技術のための標準 - ポータブルオペレーティングシステムインタフェース（POSIX（R））ベース仕様、発行7\"、IEEE 1003.1、DOI 10.1109 / ieeestd.2016.7582338、<http://ieeexplore.ieee.org/文書/ 7582338 />。"
    },
    {
      "indent": 3,
      "text": "[REST] Fielding, R., \"Architectural Styles and the Design of Network-based Software Architectures, Chapter 5: Representational State Transfer\", Ph.D. Dissertation, University of California, Irvine, 2000.",
      "ja": "[REST]フィールディング、R.、「建築スタイルとネットワークベースのソフトウェアアーキテクチャの設計、第5章：のRepresentational State転送」、博士論文、カリフォルニア大学アーバイン校、2000。"
    },
    {
      "indent": 3,
      "text": "[RFC768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <http://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、<http://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <http://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<http://www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC1071] Braden, R., Borman, D., and C. Partridge, \"Computing the Internet checksum\", RFC 1071, DOI 10.17487/RFC1071, September 1988, <http://www.rfc-editor.org/info/rfc1071>.",
      "ja": "[RFC1071]ブレーデン、R.、ボーマン、D.、およびC.ヤマウズラ、 \"インターネットチェックサムの計算\"、RFC 1071、DOI 10.17487 / RFC1071、1988年9月、<http://www.rfc-editor.org/info / rfc1071>。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <http://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<http://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, DOI 10.17487/RFC1191, November 1990, <http://www.rfc-editor.org/info/rfc1191>.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、DOI 10.17487 / RFC1191、1990年11月、<http://www.rfc-editor.org/info/rfc1191>。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., Ed., \"Requirements for IP Version 4 Routers\", RFC 1812, DOI 10.17487/RFC1812, June 1995, <http://www.rfc-editor.org/info/rfc1812>.",
      "ja": "[RFC1812]ベイカー、F.、エド。、 \"IPバージョン4つのルータのための要件\"、RFC 1812、DOI 10.17487 / RFC1812、1995年6月、<http://www.rfc-editor.org/info/rfc1812>。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August 1996, <http://www.rfc-editor.org/info/rfc1981>.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981 \"IPバージョン6のパスMTUディスカバリー\"、DOI 10.17487 / RFC1981、1996年8月、<のhttp：//www.rfc-editor。組織/情報/ rfc1981>。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, DOI 10.17487/RFC2018, October 1996, <http://www.rfc-editor.org/info/rfc2018>.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、<HTTP：//www.rfc- editor.org/info/rfc2018>。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, DOI 10.17487/RFC2045, November 1996, <http://www.rfc-editor.org/info/rfc2045>.",
      "ja": "[RFC2045]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、DOI 10.17487 / RFC2045、1996年11月、<のhttp：//www.rfc- editor.org/info/rfc2045>。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, DOI 10.17487/RFC2460, December 1998, <http://www.rfc-editor.org/info/rfc2460>.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと \"インターネットプロトコル、バージョン6（IPv6）の仕様\"、RFC 2460、DOI 10.17487 / RFC2460、1998年12月、<http://www.rfc-editor.org/info/ RFC2460>。"
    },
    {
      "indent": 3,
      "text": "[RFC2710] Deering, S., Fenner, W., and B. Haberman, \"Multicast Listener Discovery (MLD) for IPv6\", RFC 2710, DOI 10.17487/RFC2710, October 1999, <http://www.rfc-editor.org/info/rfc2710>.",
      "ja": "[RFC2710]の \"IPv6におけるマルチキャストリスナー発見（MLD）\" デアリング、S.、フェナー、W.、およびB.ハーバーマン、RFC 2710、DOI 10.17487 / RFC2710、1999年10月、<HTTP：//www.rfc-editor .ORG /情報/ RFC2710>。"
    },
    {
      "indent": 3,
      "text": "[RFC2736] Handley, M. and C. Perkins, \"Guidelines for Writers of RTP Payload Format Specifications\", BCP 36, RFC 2736, DOI 10.17487/RFC2736, December 1999, <http://www.rfc-editor.org/info/rfc2736>.",
      "ja": "[RFC2736]ハンドレー、M.とC.パーキンス、 \"RTPペイロードフォーマット仕様の作家のためのガイドライン\"、BCP 36、RFC 2736、DOI 10.17487 / RFC2736、1999年12月、<http://www.rfc-editor.org/情報/ rfc2736>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <http://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC3205] Moore, K., \"On the use of HTTP as a Substrate\", BCP 56, RFC 3205, DOI 10.17487/RFC3205, February 2002, <http://www.rfc-editor.org/info/rfc3205>.",
      "ja": "[RFC3205]ムーア、K.、 \"基板としてHTTPの使用に\"、BCP 56、RFC 3205、DOI 10.17487 / RFC3205、2002年2月、<http://www.rfc-editor.org/info/rfc3205> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3260] Grossman, D., \"New Terminology and Clarifications for Diffserv\", RFC 3260, DOI 10.17487/RFC3260, April 2002, <http://www.rfc-editor.org/info/rfc3260>.",
      "ja": "[RFC3260]グロスマン、D.、 \"Diffservのための新しい用語と明確化\"、RFC 3260、DOI 10.17487 / RFC3260、2002年4月、<http://www.rfc-editor.org/info/rfc3260>。"
    },
    {
      "indent": 3,
      "text": "[RFC3436] Jungmaier, A., Rescorla, E., and M. Tuexen, \"Transport Layer Security over Stream Control Transmission Protocol\", RFC 3436, DOI 10.17487/RFC3436, December 2002, <http://www.rfc-editor.org/info/rfc3436>.",
      "ja": "[RFC3436] Jungmaier、A.、レスコラ、E.、およびM. Tuexen、 \"ストリーム制御伝送プロトコルを介してトランスポート層セキュリティ\"、RFC 3436、DOI 10.17487 / RFC3436、2002年12月、<のhttp：//www.rfc-editor .ORG /情報/ rfc3436>。"
    },
    {
      "indent": 3,
      "text": "[RFC3450] Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., and J. Crowcroft, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", RFC 3450, DOI 10.17487/RFC3450, December 2002, <http://www.rfc-editor.org/info/rfc3450>.",
      "ja": "[RFC3450]ルビー、M.、Gemmell、J.、Vicisano、L.、リゾー、L.、およびJ.クロウクロフト、RFC 3450、 \"非同期階層は（ALC）プロトコルインスタンス化コーディング\"、DOI 10.17487 / RFC3450、2002年12月、 <http://www.rfc-editor.org/info/rfc3450>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <http://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <http://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3738] Luby, M. and V. Goyal, \"Wave and Equation Based Rate Control (WEBRC) Building Block\", RFC 3738, DOI 10.17487/RFC3738, April 2004, <http://www.rfc-editor.org/info/rfc3738>.",
      "ja": "[RFC3738]ルビー、M.およびV. Goyal氏、 \"波動と式ベースのレート制御（WEBRC）ビルディングブロック\"、RFC 3738、DOI 10.17487 / RFC3738、2004年4月、<http://www.rfc-editor.org/情報/ rfc3738>。"
    },
    {
      "indent": 3,
      "text": "[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, \"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension\", RFC 3758, DOI 10.17487/RFC3758, May 2004, <http://www.rfc-editor.org/info/rfc3758>.",
      "ja": "[RFC3758]スチュワート、R.、Ramalho、M.、謝、Q.、Tuexen、M.、およびP.コンラッド、 \"ストリーム制御伝送プロトコル（SCTP）部分信頼拡張子\"、RFC 3758、DOI 10.17487 / RFC3758、月2004年、<http://www.rfc-editor.org/info/rfc3758>。"
    },
    {
      "indent": 3,
      "text": "[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed., and G. Fairhurst, Ed., \"The Lightweight User Datagram Protocol (UDP-Lite)\", RFC 3828, DOI 10.17487/RFC3828, July 2004, <http://www.rfc-editor.org/info/rfc3828>.",
      "ja": "[RFC3828] Larzon、LA。、Degermark、M.、ピンク、S.、ジョンソン、LE。、編、及びG. Fairhurst、編、 \"軽量ユーザーデータグラムプロトコル（UDP-Liteの）\"、RFC 3828、 DOI 10.17487 / RFC3828、2004年7月、<http://www.rfc-editor.org/info/rfc3828>。"
    },
    {
      "indent": 3,
      "text": "[RFC3926] Paila, T., Luby, M., Lehtonen, R., Roca, V., and R. Walsh, \"FLUTE - File Delivery over Unidirectional Transport\", RFC 3926, DOI 10.17487/RFC3926, October 2004, <http://www.rfc-editor.org/info/rfc3926>.",
      "ja": "[RFC3926] Paila、T.、ルビー、M.、Lehtonenの、R.、ロカ、V.、およびR.ウォルシュ、 \"FLUTE  - 単方向トランスポート上でファイル配信\"、RFC 3926、DOI 10.17487 / RFC3926、2004年10月、< http://www.rfc-editor.org/info/rfc3926>。"
    },
    {
      "indent": 3,
      "text": "[RFC3971] Arkko, J., Ed., Kempf, J., Zill, B., and P. Nikander, \"SEcure Neighbor Discovery (SEND)\", RFC 3971, DOI 10.17487/RFC3971, March 2005, <http://www.rfc-editor.org/info/rfc3971>.",
      "ja": "[RFC3971] Arkko、J.、編、ケンプ、J.、Zill、B.、およびP. Nikander、 \"セキュア近隣探索（SEND）\"、RFC 3971、DOI 10.17487 / RFC3971、2005年3月<HTTP：/ /www.rfc-editor.org/info/rfc3971>。"
    },
    {
      "indent": 3,
      "text": "[RFC4336] Floyd, S., Handley, M., and E. Kohler, \"Problem Statement for the Datagram Congestion Control Protocol (DCCP)\", RFC 4336, DOI 10.17487/RFC4336, March 2006, <http://www.rfc-editor.org/info/rfc4336>.",
      "ja": "[RFC4336]フロイド、S.、ハンドリー、M.、およびE.コーラー、 \"データグラム輻輳制御プロトコル（DCCP）のための問題文\"、RFC 4336、DOI 10.17487 / RFC4336、2006年3月、<のhttp：// WWW。 rfc-editor.org/info/rfc4336>。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, DOI 10.17487/RFC4340, March 2006, <http://www.rfc-editor.org/info/rfc4340>.",
      "ja": "[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、DOI 10.17487 / RFC4340、2006年3月、<のhttp：//www.rfc-editor。組織/情報/ RFC4340>。"
    },
    {
      "indent": 3,
      "text": "[RFC4341] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control\", RFC 4341, DOI 10.17487/RFC4341, March 2006, <http://www.rfc-editor.org/info/rfc4341>.",
      "ja": "[RFC4341]フロイド、S.、およびE.コーラー、 \"データグラム輻輳制御プロトコルのためのプロファイル（DCCP）輻輳制御ID 2：TCPのような輻輳制御\"、RFC 4341、DOI 10.17487 / RFC4341、2006年3月、<のhttp：// www.rfc-editor.org/info/rfc4341>。"
    },
    {
      "indent": 3,
      "text": "[RFC4342] Floyd, S., Kohler, E., and J. Padhye, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)\", RFC 4342, DOI 10.17487/RFC4342, March 2006, <http://www.rfc-editor.org/info/rfc4342>.",
      "ja": "[RFC4342]フロイド、S.、ケーラー、E.、およびJ. Padhye、 \"データグラム輻輳制御プロトコル（DCCP）輻輳制御ID 3のプロファイル：TCPフレンドリーレート制御（TFRC）\"、RFC 4342、DOI 10.17487 / RFC4342 、2006年3月、<http://www.rfc-editor.org/info/rfc4342>。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 4443, DOI 10.17487/RFC4443, March 2006, <http://www.rfc-editor.org/info/rfc4443>.",
      "ja": "[RFC4443]コンタ、A.、デアリング、S.、およびM.グプタ編、 \"インターネット制御メッセージプロトコル（ICMPv6の）インターネットプロトコルバージョン6（IPv6）の仕様は、\"、RFC 4443、DOI 10.17487 / RFC4443、マーチ2006年、<http://www.rfc-editor.org/info/rfc4443>。"
    },
    {
      "indent": 3,
      "text": "[RFC4654] Widmer, J. and M. Handley, \"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification\", RFC 4654, DOI 10.17487/RFC4654, August 2006, <http://www.rfc-editor.org/info/rfc4654>.",
      "ja": "[RFC4654]ウィドマー、J.とM.ハンドリー、 \"TCPフレンドリーマルチキャスト輻輳制御（TFMCC）：プロトコル仕様\"、RFC 4654、DOI 10.17487 / RFC4654、2006年8月、<http://www.rfc-editor.org /情報/ rfc4654>。"
    },
    {
      "indent": 3,
      "text": "[RFC4820] Tuexen, M., Stewart, R., and P. Lei, \"Padding Chunk and Parameter for the Stream Control Transmission Protocol (SCTP)\", RFC 4820, DOI 10.17487/RFC4820, March 2007, <http://www.rfc-editor.org/info/rfc4820>.",
      "ja": "[RFC4820] Tuexen、M.、スチュワート、R.、およびP.レイ、 \"ストリーム制御伝送プロトコル（SCTP）のためのパディングチャンクとパラメータ\"、RFC 4820、DOI 10.17487 / RFC4820、2007年3月、<のhttp：// www.rfc-editor.org/info/rfc4820>。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <http://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<http://www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC4828] Floyd, S. and E. Kohler, \"TCP Friendly Rate Control (TFRC): The Small-Packet (SP) Variant\", RFC 4828, DOI 10.17487/RFC4828, April 2007, <http://www.rfc-editor.org/info/rfc4828>.",
      "ja": "[RFC4828]フロイド、S.、およびE.コーラー、 \"TCPフレンドリーレート制御（TFRC）：小パケット（SP）バリアント\"、RFC 4828、DOI 10.17487 / RFC4828、2007年4月、<のhttp：//www.rfc -editor.org/info/rfc4828>。"
    },
    {
      "indent": 3,
      "text": "[RFC4861] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, \"Neighbor Discovery for IP version 6 (IPv6)\", RFC 4861, DOI 10.17487/RFC4861, September 2007, <http://www.rfc-editor.org/info/rfc4861>.",
      "ja": "[RFC4861] Narten氏、T.、Nordmarkと、E.、シンプソン、W.、およびH.ソリマン、 \"近隣探索IPバージョン6（IPv6）のために\"、RFC 4861、DOI 10.17487 / RFC4861、2007年9月、<のhttp：/ /www.rfc-editor.org/info/rfc4861>。"
    },
    {
      "indent": 3,
      "text": "[RFC4895] Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, \"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)\", RFC 4895, DOI 10.17487/RFC4895, August 2007, <http://www.rfc-editor.org/info/rfc4895>.",
      "ja": "[RFC4895] Tuexen、M.、スチュワート、R.、レイ、P.、およびE.レスコラ、 \"ストリーム制御伝送プロトコル（SCTP）に対して認証チャンク\"、RFC 4895、DOI 10.17487 / RFC4895、2007年8月、<HTTP ：//www.rfc-editor.org/info/rfc4895>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <http://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960]スチュワート、R.、エド。、 \"ストリーム制御伝送プロトコル\"、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<http://www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, DOI 10.17487/RFC5052, August 2007, <http://www.rfc-editor.org/info/rfc5052>.",
      "ja": "[RFC5052]ワトソン、M.、ルビー、M.、およびL. Vicisano、 \"前方誤り訂正（FEC）ビルディングブロック\"、RFC 5052、DOI 10.17487 / RFC5052、2007年8月、<のhttp：//www.rfc-editor .ORG /情報/ rfc5052>。"
    },
    {
      "indent": 3,
      "text": "[RFC5061] Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M. Kozuka, \"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration\", RFC 5061, DOI 10.17487/RFC5061, September 2007, <http://www.rfc-editor.org/info/rfc5061>.",
      "ja": "[RFC5061]スチュワート、R.、謝、Q.、Tuexen、M.、丸山、S.、およびM.小塚、 \"ストリーム制御伝送プロトコル（SCTP）動的アドレス再構成\"、RFC 5061、DOI 10.17487 / RFC5061、9月2007年、<http://www.rfc-editor.org/info/rfc5061>。"
    },
    {
      "indent": 3,
      "text": "[RFC5097] Renker, G. and G. Fairhurst, \"MIB for the UDP-Lite protocol\", RFC 5097, DOI 10.17487/RFC5097, January 2008, <http://www.rfc-editor.org/info/rfc5097>.",
      "ja": "[RFC5097] Renker、G.とG. Fairhurst、 \"UDP-LiteのプロトコルのMIB\"、RFC 5097、DOI 10.17487 / RFC5097、2008年1月、<http://www.rfc-editor.org/info/rfc5097> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5238] Phelan, T., \"Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)\", RFC 5238, DOI 10.17487/RFC5238, May 2008, <http://www.rfc-editor.org/info/rfc5238>.",
      "ja": "[RFC5238]フェラン、T.、 \"データグラム輻輳制御プロトコル（DCCP）を超えるデータグラムトランスポート層セキュリティ（DTLS）\"、RFC 5238、DOI 10.17487 / RFC5238、2008年5月、<http://www.rfc-editor.org /情報/ rfc5238>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, \"TCP Friendly Rate Control (TFRC): Protocol Specification\", RFC 5348, DOI 10.17487/RFC5348, September 2008, <http://www.rfc-editor.org/info/rfc5348>.",
      "ja": "[RFC5348]フロイド、S.、ハンドリー、M.、Padhye、J.、およびJ.ウィトマー、 \"TCPフレンドリーレート制御（TFRC）：プロトコル仕様\"、RFC 5348、DOI 10.17487 / RFC5348、2008年9月、<のhttp： //www.rfc-editor.org/info/rfc5348>。"
    },
    {
      "indent": 3,
      "text": "[RFC5461] Gont, F., \"TCP's Reaction to Soft Errors\", RFC 5461, DOI 10.17487/RFC5461, February 2009, <http://www.rfc-editor.org/info/rfc5461>.",
      "ja": "[RFC5461] Gont、F.、 \"ソフトエラーへのTCPの反応\"、RFC 5461、DOI 10.17487 / RFC5461、2009年2月、<http://www.rfc-editor.org/info/rfc5461>。"
    },
    {
      "indent": 3,
      "text": "[RFC5595] Fairhurst, G., \"The Datagram Congestion Control Protocol (DCCP) Service Codes\", RFC 5595, DOI 10.17487/RFC5595, September 2009, <http://www.rfc-editor.org/info/rfc5595>.",
      "ja": "[RFC5595] Fairhurst、G.、 \"データグラム輻輳制御プロトコル（DCCP）サービスコード\"、RFC 5595、DOI 10.17487 / RFC5595、2009年9月、<http://www.rfc-editor.org/info/rfc5595>。"
    },
    {
      "indent": 3,
      "text": "[RFC5596] Fairhurst, G., \"Datagram Congestion Control Protocol (DCCP) Simultaneous-Open Technique to Facilitate NAT/ Middlebox Traversal\", RFC 5596, DOI 10.17487/RFC5596, September 2009, <http://www.rfc-editor.org/info/rfc5596>.",
      "ja": "[RFC5596] Fairhurst、G.、 \"データグラム輻輳制御プロトコル（DCCP）NAT /ミドルトラバーサルを容易にするために、同時オープン技術\"、RFC 5596、DOI 10.17487 / RFC5596、2009年9月、<のhttp：//www.rfc-editor。組織/情報/ rfc5596>。"
    },
    {
      "indent": 3,
      "text": "[RFC5622] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)\", RFC 5622, DOI 10.17487/RFC5622, August 2009, <http://www.rfc-editor.org/info/rfc5622>.",
      "ja": "[RFC5622]フロイド、S.、およびE.コーラー、 \"データグラム輻輳制御プロトコル（DCCP）輻輳ID 4のプロファイル：スモールパケットのTCPフレンドリーレート制御（TFRC-SP）\"、RFC 5622、DOI 10.17487 / RFC5622、月2009年、<http://www.rfc-editor.org/info/rfc5622>。"
    },
    {
      "indent": 3,
      "text": "[RFC5651] Luby, M., Watson, M., and L. Vicisano, \"Layered Coding Transport (LCT) Building Block\", RFC 5651, DOI 10.17487/RFC5651, October 2009, <http://www.rfc-editor.org/info/rfc5651>.",
      "ja": "[RFC5651]ルビー、M.、ワトソン、M.、およびL. Vicisano、 \"階層符号化トランスポート（LCT）ビルディングブロック\"、RFC 5651、DOI 10.17487 / RFC5651、2009年10月、<のhttp：//www.rfc-editor .ORG /情報/ rfc5651>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <http://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<http://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC5740] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"NACK-Oriented Reliable Multicast (NORM) Transport Protocol\", RFC 5740, DOI 10.17487/RFC5740, November 2009, <http://www.rfc-editor.org/info/rfc5740>.",
      "ja": "[RFC5740]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 \"NACK指向高信頼マルチキャスト（NORM）トランスポートプロトコル\"、RFC 5740、DOI 10.17487 / RFC5740、2009年11月、<HTTP： //www.rfc-editor.org/info/rfc5740>。"
    },
    {
      "indent": 3,
      "text": "[RFC5762] Perkins, C., \"RTP and the Datagram Congestion Control Protocol (DCCP)\", RFC 5762, DOI 10.17487/RFC5762, April 2010, <http://www.rfc-editor.org/info/rfc5762>.",
      "ja": "[RFC5762]パーキンス、C.、 \"RTPデータグラム輻輳制御プロトコル（DCCP）\"、RFC 5762、DOI 10.17487 / RFC5762、2010年4月<http://www.rfc-editor.org/info/rfc5762>。"
    },
    {
      "indent": 3,
      "text": "[RFC5775] Luby, M., Watson, M., and L. Vicisano, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", RFC 5775, DOI 10.17487/RFC5775, April 2010, <http://www.rfc-editor.org/info/rfc5775>.",
      "ja": "[RFC5775]ルビー、M.、ワトソン、M.、およびL. Vicisano、 \"非同期階層コーディング（ALC）プロトコルのインスタンス化\"、RFC 5775、DOI 10.17487 / RFC5775、2010年4月、<HTTP：//www.rfc-editor .ORG /情報/ rfc5775>。"
    },
    {
      "indent": 3,
      "text": "[RFC6056] Larsen, M. and F. Gont, \"Recommendations for Transport-Protocol Port Randomization\", BCP 156, RFC 6056, DOI 10.17487/RFC6056, January 2011, <http://www.rfc-editor.org/info/rfc6056>.",
      "ja": "[RFC6056]ラーセン、M.とF. Gont、 \"トランスポート・プロトコルポートランダム化のための提言\"、BCP 156、RFC 6056、DOI 10.17487 / RFC6056、2011年1月、<http://www.rfc-editor.org/info / rfc6056>。"
    },
    {
      "indent": 3,
      "text": "[RFC6083] Tuexen, M., Seggelmann, R., and E. Rescorla, \"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)\", RFC 6083, DOI 10.17487/RFC6083, January 2011, <http://www.rfc-editor.org/info/rfc6083>.",
      "ja": "[RFC6083] Tuexen、M.、Seggelmann、R.、およびE.レスコラ、RFC 6083 \"ストリーム制御伝送プロトコル（SCTP）のためのデータグラムトランスポート層セキュリティ（DTLS）\"、DOI 10.17487 / RFC6083、2011年1月、<のhttp： //www.rfc-editor.org/info/rfc6083>。"
    },
    {
      "indent": 3,
      "text": "[RFC6093] Gont, F. and A. Yourtchenko, \"On the Implementation of the TCP Urgent Mechanism\", RFC 6093, DOI 10.17487/RFC6093, January 2011, <http://www.rfc-editor.org/info/rfc6093>.",
      "ja": "[RFC6093] Gont、F.およびA. Yourtchenko、RFC 6093 \"TCP緊急機構の実現について\"、DOI 10.17487 / RFC6093、2011年1月、<http://www.rfc-editor.org/info/rfc6093 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6101] Freier, A., Karlton, P., and P. Kocher, \"The Secure Sockets Layer (SSL) Protocol Version 3.0\", RFC 6101, DOI 10.17487/RFC6101, August 2011, <http://www.rfc-editor.org/info/rfc6101>.",
      "ja": "[RFC6101]フライアー、A.、Karlton、P.、およびP.コッヘル、 \"セキュア・ソケット・レイヤー（SSL）プロトコルバージョン3.0\"、RFC 6101、DOI 10.17487 / RFC6101、2011年8月、<のhttp：//www.rfc -editor.org/info/rfc6101>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6356] Raiciu, C., Handley, M., and D. Wischik, \"Coupled Congestion Control for Multipath Transport Protocols\", RFC 6356, DOI 10.17487/RFC6356, October 2011, <http://www.rfc-editor.org/info/rfc6356>.",
      "ja": "[RFC6356] Raiciu、C.、ハンドリー、M.、およびD. Wischik、DOI 10.17487 / RFC6356、2011年10月、<HTTP、RFC 6356、 \"マルチパストランスポートプロトコルのための結合輻輳制御\"：//www.rfc-editor。組織/情報/ rfc6356>。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, DOI 10.17487/RFC6363, October 2011, <http://www.rfc-editor.org/info/rfc6363>.",
      "ja": "[RFC6363]ワトソン、M.、Begen、A.、およびV.ロカ、 \"前方誤り訂正（FEC）フレームワーク\"、RFC 6363、DOI 10.17487 / RFC6363、2011年10月、<のhttp：//www.rfc-editor。組織/情報/ rfc6363>。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, \"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)\", RFC 6458, DOI 10.17487/RFC6458, December 2011, <http://www.rfc-editor.org/info/rfc6458>.",
      "ja": "[RFC6458]スチュワート、R.、Tuexen、M.、プーン、K.、レイ、P.、およびV. Yasevich、DOI 10.17487 / RFC6458、RFC 6458、 \"ストリーム制御伝送プロトコル（SCTP）のためのソケットAPIの拡張機能\" 、2011年12月、<http://www.rfc-editor.org/info/rfc6458>。"
    },
    {
      "indent": 3,
      "text": "[RFC6525] Stewart, R., Tuexen, M., and P. Lei, \"Stream Control Transmission Protocol (SCTP) Stream Reconfiguration\", RFC 6525, DOI 10.17487/RFC6525, February 2012, <http://www.rfc-editor.org/info/rfc6525>.",
      "ja": "[RFC6525]スチュワート、R.、Tuexen、M.、およびP.レイ、 \"ストリーム制御伝送プロトコル（SCTP）ストリーム再構成\"、RFC 6525、DOI 10.17487 / RFC6525、2012年2月、<HTTP：//www.rfc- editor.org/info/rfc6525>。"
    },
    {
      "indent": 3,
      "text": "[RFC6582] Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 6582, DOI 10.17487/RFC6582, April 2012, <http://www.rfc-editor.org/info/rfc6582>.",
      "ja": "[RFC6582]ヘンダーソン、T.、フロイド、S.、Gurtov、A.、およびY.西田、 \"TCPの速い回復アルゴリズムへのNewRenoの変更\"、RFC 6582、DOI 10.17487 / RFC6582、2012年4月、<のhttp：// www.rfc-editor.org/info/rfc6582>。"
    },
    {
      "indent": 3,
      "text": "[RFC6584] Roca, V., \"Simple Authentication Schemes for the Asynchronous Layered Coding (ALC) and NACK-Oriented Reliable Multicast (NORM) Protocols\", RFC 6584, DOI 10.17487/RFC6584, April 2012, <http://www.rfc-editor.org/info/rfc6584>.",
      "ja": "[RFC6584]ロカ、V.、 \"非同期階層符号化（ALC）とのためのシンプルな認証スキームNACK指向リライアブルマルチキャスト（NORM）プロトコル\"、RFC 6584、DOI 10.17487 / RFC6584、2012年4月、<のhttp：// WWW。 rfc-editor.org/info/rfc6584>。"
    },
    {
      "indent": 3,
      "text": "[RFC6726] Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen, \"FLUTE - File Delivery over Unidirectional Transport\", RFC 6726, DOI 10.17487/RFC6726, November 2012, <http://www.rfc-editor.org/info/rfc6726>.",
      "ja": "[RFC6726] Paila、T.、ウォルシュ、R.、ルビー、M.、ロカ、V.、およびR. Lehtonenの、 \"FLUTE  - 単方向トランスポート上でファイル配信\"、RFC 6726、DOI 10.17487 / RFC6726、2012年11月、< http://www.rfc-editor.org/info/rfc6726>。"
    },
    {
      "indent": 3,
      "text": "[RFC6773] Phelan, T., Fairhurst, G., and C. Perkins, \"DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal\", RFC 6773, DOI 10.17487/RFC6773, November 2012, <http://www.rfc-editor.org/info/rfc6773>.",
      "ja": "[RFC6773]フェラン、T.、Fairhurst、G.、およびC.パーキンス、 \"DCCP-UDP：データグラム混雑NATトラバーサルのための制御プロトコルUDPカプセル化\"、RFC 6773、DOI 10.17487 / RFC6773、2012年11月、<のhttp：/ /www.rfc-editor.org/info/rfc6773>。"
    },
    {
      "indent": 3,
      "text": "[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, \"Low Extra Delay Background Transport (LEDBAT)\", RFC 6817, DOI 10.17487/RFC6817, December 2012, <http://www.rfc-editor.org/info/rfc6817>.",
      "ja": "[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 \"低余分な遅延の背景トランスポート（LEDBAT）\"、RFC 6817、DOI 10.17487 / RFC6817、2012年12月、<HTTP：// www.rfc-editor.org/info/rfc6817>。"
    },
    {
      "indent": 3,
      "text": "[RFC6824] Ford, A., Raiciu, C., Handley, M., and O. Bonaventure, \"TCP Extensions for Multipath Operation with Multiple Addresses\", RFC 6824, DOI 10.17487/RFC6824, January 2013, <http://www.rfc-editor.org/info/rfc6824>.",
      "ja": "[RFC6824]フォード、A.、Raiciu、C.、ハンドリー、M.、およびO.ボナベンチャー、 \"複数のアドレスを持つマルチパス操作のためのTCP拡張機能\"、RFC 6824、DOI 10.17487 / RFC6824、2013年1月、<のhttp：// www.rfc-editor.org/info/rfc6824>。"
    },
    {
      "indent": 3,
      "text": "[RFC6897] Scharf, M. and A. Ford, \"Multipath TCP (MPTCP) Application Interface Considerations\", RFC 6897, DOI 10.17487/RFC6897, March 2013, <http://www.rfc-editor.org/info/rfc6897>.",
      "ja": "[RFC6897]シャーフ、M.及びA.フォード、 \"マルチTCP（MPTCP）アプリケーションインターフェースに関する考慮事項\"、RFC 6897、DOI 10.17487 / RFC6897、2013年3月、<http://www.rfc-editor.org/info/rfc6897 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6935] Eubanks, M., Chimento, P., and M. Westerlund, \"IPv6 and UDP Checksums for Tunneled Packets\", RFC 6935, DOI 10.17487/RFC6935, April 2013, <http://www.rfc-editor.org/info/rfc6935>.",
      "ja": "[RFC6935]ユーバンクス、M.、Chimento、P.、およびM.ウェスター、 \"トンネリングされたパケットのIPv6およびUDPチェックサム\"、RFC 6935、DOI 10.17487 / RFC6935、2013年4月、<のhttp：//www.rfc-editor。組織/情報/ rfc6935>。"
    },
    {
      "indent": 3,
      "text": "[RFC6936] Fairhurst, G. and M. Westerlund, \"Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums\", RFC 6936, DOI 10.17487/RFC6936, April 2013, <http://www.rfc-editor.org/info/rfc6936>.",
      "ja": "[RFC6936] Fairhurst、G.およびM.ウェスター、 \"ゼロチェックサムとIPv6のUDPデータグラムを使用するための適用性に関する声明\"、RFC 6936、DOI 10.17487 / RFC6936、2013年4月、<http://www.rfc-editor.org /情報/ rfc6936>。"
    },
    {
      "indent": 3,
      "text": "[RFC6951] Tuexen, M. and R. Stewart, \"UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication\", RFC 6951, DOI 10.17487/RFC6951, May 2013, <http://www.rfc-editor.org/info/rfc6951>.",
      "ja": "[RFC6951] Tuexen、M.とR.スチュワート、RFC 6951、DOI 10.17487 / RFC6951、2013年5月、<HTTP \"ストリーム制御伝送プロトコル（SCTP）エンドホストへのエンドホスト通信用パケットのUDPカプセル化\"：/ /www.rfc-editor.org/info/rfc6951>。"
    },
    {
      "indent": 3,
      "text": "[RFC7053] Tuexen, M., Ruengeler, I., and R. Stewart, \"SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol\", RFC 7053, DOI 10.17487/RFC7053, November 2013, <http://www.rfc-editor.org/info/rfc7053>.",
      "ja": "[RFC7053] Tuexen、M.、Ruengeler、I.、およびR.スチュワート、 \"SACK-すぐにストリーム制御伝送プロトコルのための拡張\"、RFC 7053、DOI 10.17487 / RFC7053、2013年11月、<HTTP：//www.rfc -editor.org/info/rfc7053>。"
    },
    {
      "indent": 3,
      "text": "[RFC7202] Perkins, C. and M. Westerlund, \"Securing the RTP Framework: Why RTP Does Not Mandate a Single Media Security Solution\", RFC 7202, DOI 10.17487/RFC7202, April 2014, <http://www.rfc-editor.org/info/rfc7202>.",
      "ja": "[RFC7202]パーキンス、C.とM.ウェスター、 \"RTPフレームワークの保護：なぜ、RTPは、単一のメディアセキュリティソリューションを強制しない\"、RFC 7202、DOI 10.17487 / RFC7202、2014年4月、<のhttp：//www.rfc- editor.org/info/rfc7202>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, DOI 10.17487/RFC7232, June 2014, <http://www.rfc-editor.org/info/rfc7232>.",
      "ja": "[RFC7232]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、DOI 10.17487 / RFC7232、2014年6月、<http://www.rfc-editor.org/info/rfc7232> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、DOI 10.17487 / RFC7233 6月2014年、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, DOI 10.17487/RFC7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、DOI 10.17487 / RFC7234、2014年6月、<http://www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7301] Friedl, S., Popov, A., Langley, A., and E. Stephan, \"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension\", RFC 7301, DOI 10.17487/RFC7301, July 2014, <http://www.rfc-editor.org/info/rfc7301>.",
      "ja": "[RFC7301] Friedlの、S.、ポポフ、A.、ラングレー、A.、およびE.ステファン、 \"トランスポート層セキュリティ（TLS）アプリケーション層プロトコルネゴシエーション拡張\"、RFC 7301、DOI 10.17487 / RFC7301、2014年7月、< http://www.rfc-editor.org/info/rfc7301>。"
    },
    {
      "indent": 3,
      "text": "[RFC7323] Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., \"TCP Extensions for High Performance\", RFC 7323, DOI 10.17487/RFC7323, September 2014, <http://www.rfc-editor.org/info/rfc7323>.",
      "ja": "[RFC7323]ボーマン、D.、ブレーデン、B.、ヤコブソン、V.、およびR. Scheffenegger、エド、 \"ハイパフォーマンスのためのTCP拡張\"、RFC 7323、DOI 10.17487 / RFC7323、2014年9月、<のhttp：// www.rfc-editor.org/info/rfc7323>。"
    },
    {
      "indent": 3,
      "text": "[RFC7414] Duke, M., Braden, R., Eddy, W., Blanton, E., and A. Zimmermann, \"A Roadmap for Transmission Control Protocol (TCP) Specification Documents\", RFC 7414, DOI 10.17487/RFC7414, February 2015, <http://www.rfc-editor.org/info/rfc7414>.",
      "ja": "[RFC7414]デューク、M.、ブレーデン、R.、エディ、W.、ブラントン、E.、およびA.ツィンマーマン、RFC 7414、DOI 10.17487 / RFC7414、 \"伝送制御プロトコル（TCP）仕様書のためのロードマップ\" 2015年2月、<http://www.rfc-editor.org/info/rfc7414>。"
    },
    {
      "indent": 3,
      "text": "[RFC7457] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS)\", RFC 7457, DOI 10.17487/RFC7457, February 2015, <http://www.rfc-editor.org/info/rfc7457>.",
      "ja": "[RFC7457]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、RFC 7457、DOI 10.17487 / RFC7457、2015年2月、 \"トランスポート層セキュリティ（TLS）およびデータグラムTLS（DTLS）上の既知の攻撃をまとめます\" <http://www.rfc-editor.org/info/rfc7457>。"
    },
    {
      "indent": 3,
      "text": "[RFC7496] Tuexen, M., Seggelmann, R., Stewart, R., and S. Loreto, \"Additional Policies for the Partially Reliable Stream Control Transmission Protocol Extension\", RFC 7496, DOI 10.17487/RFC7496, April 2015, <http://www.rfc-editor.org/info/rfc7496>.",
      "ja": "[RFC7496] Tuexen、M.、Seggelmann、R.、スチュワート、R.、およびS.ロレート、 \"部分的に信頼性の高いストリーム制御伝送プロトコル拡張のための追加のポリシー\"、RFC 7496、DOI 10.17487 / RFC7496、2015年4月、<HTTP ：//www.rfc-editor.org/info/rfc7496>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <http://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\"、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<http://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7540] Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext Transfer Protocol Version 2 (HTTP/2)\", RFC 7540, DOI 10.17487/RFC7540, May 2015, <http://www.rfc-editor.org/info/rfc7540>.",
      "ja": "[RFC7540] Belshe、M.、ペオン、R.、およびM.トムソン、エド、 \"ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）\"、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、<のhttp：// www.rfc-editor.org/info/rfc7540>。"
    },
    {
      "indent": 3,
      "text": "[RFC8085] Eggert, L., Fairhurst, G., and G. Shepherd, \"UDP Usage Guidelines\", BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017, <http://www.rfc-editor.org/info/rfc8085>.",
      "ja": "[RFC8085]エッゲルト、L.、Fairhurst、G.、およびG.シェパード、 \"UDP使用上の注意事項\"、BCP 145、RFC 8085、DOI 10.17487 / RFC8085、2017年3月、<http://www.rfc-editor.org /情報/ rfc8085>。"
    },
    {
      "indent": 3,
      "text": "[SCTP-DTLS-ENCAPS] Tuexen, M., Stewart, R., Jesup, R., and S. Loreto, \"DTLS Encapsulation of SCTP Packets\", Work in Progress, draft-ietf-tsvwg-sctp-dtls-encaps-09, January 2015.",
      "ja": "[SCTP-DTLS-ENCAPS] Tuexen、M.、スチュワート、R.、ジェサップ、R.、およびS.ロレート、 \"SCTPパケットのDTLSカプセル化\"、進行中で働いて、ドラフトIETF-TSVWG-SCTP-DTLS-ENCAPS -09、2015年1月。"
    },
    {
      "indent": 3,
      "text": "[SCTP-NDATA] Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann, \"Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol\", Work in Progress, draft-ietf-tsvwg-sctp-ndata-08, October 2016.",
      "ja": "[SCTP-NDATA]スチュワート、R.、Tuexen、M.、ロレート、S.、およびR. Seggelmann、 \"ストリームスケジューラおよびストリーム制御伝送プロトコルのインターリービングユーザメッセージ\"、進行中で働いて、ドラフトIETF-tsvwg- SCTP-NDATA-08、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[TCP-SPEC] Eddy, W., Ed., \"Transmission Control Protocol Specification\", Work in Progress, draft-ietf-tcpm-rfc793bis-04, December 2016.",
      "ja": "[TCP-SPEC]エディ、W.、エド。、 \"伝送制御プロトコル仕様\" が進行中で働いて、ドラフト-IETF-tcpm-rfc793bis-04、2016年12月。"
    },
    {
      "indent": 3,
      "text": "[TLS-1.3] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", Work in Progress, draft-ietf-tls-tls13-18, October 2016.",
      "ja": "[TLS-1.3]レスコラ、E.、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.3\" が進行中で働いて、ドラフト-IETF-TLS-tls13-18、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[WEBRTC-TRANS] Alvestrand, H., \"Transports for WebRTC\", Work in Progress, draft-ietf-rtcweb-transports-17, October 2016.",
      "ja": "[のWebRTC-TRANS] Alvestrand、H.、 \"のWebRTCのためにトランスポート\" が進行中で働いて、ドラフト-IETF-rtcweb-トランスポート-17、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[XHR] van Kesteren, A., Aubourg, J., Song, J., and H. Steen, \"XMLHttpRequest Level 1\", World Wide Web Consortium NOTE-XMLHttpRequest-20161006, October 2016, <http://www.w3.org/TR/XMLHttpRequest/>.",
      "ja": "[XHR]バンKesteren氏、A.、Aubourg、J.、歌、J.、およびH.スティーン、 \"XMLHttpRequestのレベル1\"、World Wide Web Consortium（W3C）のNOTE-のXMLHttpRequest-20161006、2016年10月、<のhttp：// WWW。 w3.org/TR/XMLHttpRequest/>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Joe Touch, Michael Welzl, Spencer Dawkins, and the TAPS working group for the comments, feedback, and discussion. This work is supported by the European Commission under grant agreement No. 318627 mPlane and from the Horizon 2020 research and innovation program under grant agreements No. 644334 (NEAT) and No. 688421 (MAMI). This support does not imply endorsement.",
      "ja": "ジョー・タッチ、マイケルWelzl、スペンサードーキンスのおかげで、コメント、フィードバック、議論のためのワーキンググループTAPS。この作品は、補助金協定（NEAT）第644334号と688421（MAMI）の下で助成金契約番号318627 mPlane下とホライゾン2020年の研究と技術革新プログラムから、欧州委員会によってサポートされています。このサポートは、保証を意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "In addition to the editors, this document is the work of Brian Adamson, Dragana Damjanovic, Kevin Fall, Simone Ferlin-Oliviera, Ralph Holz, Olivier Mehani, Karen Nielsen, Colin Perkins, Vincent Roca, and Michael Tuexen.",
      "ja": "編集者に加えて、この文書はブライアン・アダムソン、Dragana Damjanovic、ケビン秋、シモーネFerlin-Olivieraの、ラルフ・ホルツ、オリヴィエMehani、カレン・ニールセン、コリンパーキンス、ヴィンセントロカ、そしてマイケルTuexenの作品です。"
    },
    {
      "indent": 3,
      "text": "o Section 3.2 on MPTCP was contributed by Simone Ferlin-Oliviera (ferlin@simula.no) and Olivier Mehani (olivier.mehani@nicta.com.au).",
      "ja": "O MPTCP上のセクション3.2はシモンFerlin-Olivieraの（ferlin@simula.no）とオリビエMehani（olivier.mehani@nicta.com.au）によって与えました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.3 on UDP was contributed by Kevin Fall (kfall@kfall.com).",
      "ja": "O UDP上のセクション3.3は、ケビン・秋（kfall@kfall.com）によって寄贈されました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.5 on SCTP was contributed by Michael Tuexen (tuexen@fh-muenster.de) and Karen Nielsen (karen.nielsen@tieto.com).",
      "ja": "SCTP上のO部3.5は、マイケル・Tuexen（tuexen@fh-muenster.de）とカレン・ニールセン（karen.nielsen@tieto.com）によって寄贈されました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.7 on TLS and DTLS was contributed by Ralph Holz (ralph.holz@nicta.com.au) and Olivier Mehani (olivier.mehani@nicta.com.au).",
      "ja": "TLSとDTLSのO部3.7は、ラルフ・ホルツ（ralph.holz@nicta.com.au）とオリビエMehani（olivier.mehani@nicta.com.au）によって寄贈されました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.8 on RTP contains contributions from Colin Perkins (csp@csperkins.org).",
      "ja": "O RTP上の3.8節には、コリンパーキンス（csp@csperkins.org）からの貢献が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Section 3.9 on HTTP was contributed by Dragana Damjanovic (ddamjanovic@mozilla.com).",
      "ja": "HTTP上のO部3.9は、Dragana Damjanovic（ddamjanovic@mozilla.com）によって寄贈されました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.10 on FLUTE/ALC was contributed by Vincent Roca (vincent.roca@inria.fr).",
      "ja": "O FLUTEの3.10 / ALCは、ヴィンセントロカ（vincent.roca@inria.fr）によって寄贈されました。"
    },
    {
      "indent": 3,
      "text": "o Section 3.11 on NORM was contributed by Brian Adamson (brian.adamson@nrl.navy.mil).",
      "ja": "NORMのO部3.11は、ブライアン・アダムソン（brian.adamson@nrl.navy.mil）によって寄贈されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Godred Fairhurst (editor) University of Aberdeen School of Engineering, Fraser Noble Building Aberdeen AB24 3UE",
      "ja": "Godred Fairhurst（エディタ）エンジニアリングのアバディーン大学の大学、フレイザーノーブルビルアバディーンAB24 3UE"
    },
    {
      "indent": 3,
      "text": "Email: gorry@erg.abdn.ac.uk",
      "ja": "メール：gorry@erg.abdn.ac.uk"
    },
    {
      "indent": 3,
      "text": "Brian Trammell (editor) ETH Zurich Gloriastrasse 35 8092 Zurich Switzerland",
      "ja": "ブライアン・トラメル（エディタ）ETHチューリッヒGloriastrasse 35 8092チューリッヒスイス"
    },
    {
      "indent": 3,
      "text": "Email: ietf@trammell.ch",
      "ja": "メール：ietf@trammell.ch"
    },
    {
      "indent": 3,
      "text": "Mirja Kuehlewind (editor) ETH Zurich Gloriastrasse 35 8092 Zurich Switzerland",
      "ja": "Mirja Kuehlewind（エディタ）ETHチューリッヒGloriastrasse 35 8092チューリッヒスイス"
    },
    {
      "indent": 3,
      "text": "Email: mirja.kuehlewind@tik.ee.ethz.ch",
      "ja": "メール：mirja.kuehlewind@tik.ee.ethz.ch"
    }
  ]
}