{
  "title": {
    "text": "RFC 8407 - Guidelines for Authors and Reviewers of Documents Containing YANG Data Models",
    "ja": "RFC 8407 - YANGデータモデルを含む文書の作成者や査読のためのガイドライン"
  },
  "number": 8407,
  "created_at": "2019-11-02 13:03:22.947146+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        A. Bierman\nRequest for Comments: 8407                                     YumaWorks\nBCP: 216                                                    October 2018\nObsoletes: 6087\nCategory: Best Current Practice\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Guidelines for Authors and Reviewers of Documents\n           Containing YANG Data Models",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo provides guidelines for authors and reviewers of specifications containing YANG modules. Recommendations and procedures are defined, which are intended to increase interoperability and usability of Network Configuration Protocol (NETCONF) and RESTCONF protocol implementations that utilize YANG modules. This document obsoletes RFC 6087.",
      "ja": "このメモは、著者とYANGモジュールを含む仕様書の審査のためのガイドラインを提供します。ネットワーク構成プロトコル（NETCONF）とYANGモジュールを利用RESTCONFプロトコル実装の相互運用性と利便性を高めることを意図している定義されている推奨事項および手順、。この文書はRFC 6087を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo documents an Internet Best Current Practice.",
      "ja": "このメモはインターネット最も良い現在の練習を説明します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 BCPの詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8407.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8407で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Changes since RFC 6087  . . . . . . . . . . . . . . . . .   5\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  NETCONF Terms . . . . . . . . . . . . . . . . . . . . . .   7\n  2.2.  YANG Terms  . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.3.  NMDA Terms  . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.4.  Requirements Notation . . . . . . . . . . . . . . . . . .   8\n3.  General Documentation Guidelines  . . . . . . . . . . . . . .   8\n  3.1.  Module Copyright  . . . . . . . . . . . . . . . . . . . .   9\n  3.2.  Code Components . . . . . . . . . . . . . . . . . . . . .   9\n    3.2.1.  Example Modules . . . . . . . . . . . . . . . . . . .   9\n  3.3.  Terminology Section . . . . . . . . . . . . . . . . . . .  10\n  3.4.  Tree Diagrams . . . . . . . . . . . . . . . . . . . . . .  10\n  3.5.  Narrative Sections  . . . . . . . . . . . . . . . . . . .  10\n  3.6.  Definitions Section . . . . . . . . . . . . . . . . . . .  11\n  3.7.  Security Considerations Section . . . . . . . . . . . . .  11\n    3.7.1.  Security Considerations Section Template  . . . . . .  12\n  3.8.  IANA Considerations Section . . . . . . . . . . . . . . .  13\n    3.8.1.  Documents That Create a New Namespace . . . . . . . .  14\n    3.8.2.  Documents That Extend an Existing Namespace . . . . .  14\n  3.9.  References Sections . . . . . . . . . . . . . . . . . . .  14\n  3.10. Validation Tools  . . . . . . . . . . . . . . . . . . . .  14\n  3.11. Module Extraction Tools . . . . . . . . . . . . . . . . .  15\n  3.12. Module Usage Examples . . . . . . . . . . . . . . . . . .  15\n4.  YANG Usage Guidelines . . . . . . . . . . . . . . . . . . . .  15\n  4.1.  Module Naming Conventions . . . . . . . . . . . . . . . .  16\n  4.2.  Prefixes  . . . . . . . . . . . . . . . . . . . . . . . .  17\n  4.3.  Identifiers . . . . . . . . . . . . . . . . . . . . . . .  18\n    4.3.1.  Identifier Naming Conventions . . . . . . . . . . . .  18\n  4.4.  Defaults  . . . . . . . . . . . . . . . . . . . . . . . .  19\n  4.5.  Conditional Statements  . . . . . . . . . . . . . . . . .  19\n  4.6.  XPath Usage . . . . . . . . . . . . . . . . . . . . . . .  20\n    4.6.1.  XPath Evaluation Contexts . . . . . . . . . . . . . .  20\n    4.6.2.  Function Library  . . . . . . . . . . . . . . . . . .  21\n    4.6.3.  Axes  . . . . . . . . . . . . . . . . . . . . . . . .  22\n    4.6.4.  Types . . . . . . . . . . . . . . . . . . . . . . . .  23\n    4.6.5.  Wildcards . . . . . . . . . . . . . . . . . . . . . .  24\n    4.6.6.  Boolean Expressions . . . . . . . . . . . . . . . . .  24\n  4.7.  YANG Definition Lifecycle Management  . . . . . . . . . .  25\n  4.8.  Module Header, Meta, and Revision Statements  . . . . . .  26\n  4.9.  Namespace Assignments . . . . . . . . . . . . . . . . . .  28\n  4.10. Top-Level Data Definitions  . . . . . . . . . . . . . . .  29\n  4.11. Data Types  . . . . . . . . . . . . . . . . . . . . . . .  30\n    4.11.1.  Fixed-Value Extensibility  . . . . . . . . . . . . .  30\n    4.11.2.  Patterns and Ranges  . . . . . . . . . . . . . . . .  31\n    4.11.3.  Enumerations and Bits  . . . . . . . . . . . . . . .  32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    4.11.4.  Union Types  . . . . . . . . . . . . . . . . . . . .  33\n    4.11.5.  Empty and Boolean  . . . . . . . . . . . . . . . . .  34\n  4.12. Reusable Type Definitions . . . . . . . . . . . . . . . .  35\n  4.13. Reusable Groupings  . . . . . . . . . . . . . . . . . . .  35\n  4.14. Data Definitions  . . . . . . . . . . . . . . . . . . . .  36\n    4.14.1.  Non-Presence Containers  . . . . . . . . . . . . . .  38\n    4.14.2.  Top-Level Data Nodes . . . . . . . . . . . . . . . .  38\n  4.15. Operation Definitions . . . . . . . . . . . . . . . . . .  39\n  4.16. Notification Definitions  . . . . . . . . . . . . . . . .  39\n  4.17. Feature Definitions . . . . . . . . . . . . . . . . . . .  40\n  4.18. YANG Data Node Constraints  . . . . . . . . . . . . . . .  41\n    4.18.1.  Controlling Quantity . . . . . . . . . . . . . . . .  41\n    4.18.2.  \"must\" versus \"when\" . . . . . . . . . . . . . . . .  41\n  4.19. \"augment\" Statements  . . . . . . . . . . . . . . . . . .  41\n    4.19.1.  Conditional Augment Statements . . . . . . . . . . .  41\n    4.19.2.  Conditionally Mandatory Data Definition Statements .  42\n  4.20. Deviation Statements  . . . . . . . . . . . . . . . . . .  43\n  4.21. Extension Statements  . . . . . . . . . . . . . . . . . .  44\n  4.22. Data Correlation  . . . . . . . . . . . . . . . . . . . .  45\n    4.22.1.  Use of \"leafref\" for Key Correlation . . . . . . . .  46\n  4.23. Operational State . . . . . . . . . . . . . . . . . . . .  47\n    4.23.1.  Combining Operational State and Configuration Data .  47\n    4.23.2.  Representing Operational Values of Configuration\n             Data . . . . . . . . . . . . . . . . . . . . . . . .  47\n    4.23.3.  NMDA Transition Guidelines . . . . . . . . . . . . .  48\n  4.24. Performance Considerations  . . . . . . . . . . . . . . .  52\n  4.25. Open Systems Considerations . . . . . . . . . . . . . . .  52\n  4.26. Guidelines for Constructs Specific to YANG 1.1  . . . . .  53\n    4.26.1.  Importing Multiple Revisions . . . . . . . . . . . .  53\n    4.26.2.  Using Feature Logic  . . . . . . . . . . . . . . . .  53\n    4.26.3.  \"anyxml\" versus \"anydata\"  . . . . . . . . . . . . .  53\n    4.26.4.  \"action\" versus \"rpc\"  . . . . . . . . . . . . . . .  53\n  4.27. Updating YANG Modules (Published versus Unpublished)  . .  54\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  55\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  55\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  56\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  56\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  57\nAppendix A.  Module Review Checklist  . . . . . . . . . . . . . .  59\nAppendix B.  YANG Module Template . . . . . . . . . . . . . . . .  61\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  62\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  63",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The standardization of network configuration interfaces for use with network configuration management protocols, such as the Network Configuration Protocol [RFC6241] and the RESTCONF protocol [RFC8040], requires a modular set of data models that can be reused and extended over time.",
      "ja": "このようなネットワーク構成プロトコル[RFC6241]とRESTCONFプロトコル[RFC8040]などのネットワーク構成管理プロトコルで使用するためのネットワーク構成インターフェイスの標準化は、時間をかけて再利用及び拡張可能なデータモデルのモジュールセットを必要とします。"
    },
    {
      "indent": 3,
      "text": "This document defines a set of usage guidelines for documents containing YANG 1.1 [RFC7950] and YANG 1.0 [RFC6020] data models. YANG is used to define the data structures, protocol operations, and notification content used within a NETCONF and/or RESTCONF server. A NETCONF or RESTCONF server that supports a particular YANG module will support client NETCONF and/or RESTCONF operation requests, as indicated by the specific content defined in the YANG module.",
      "ja": "この文書では、YANG 1.1 [RFC7950]とYANG 1.0 [RFC6020]データモデルを含む文書の使用上のガイドラインのセットを定義します。 YANGはNETCONF及び/又はRESTCONFサーバ内で使用されるデータ構造、プロトコル動作、及び通知内容を定義するために使用されます。 YANGモジュールで定義された特定のコンテンツによって示されるように、特定のYANGモジュールをサポートNETCONFまたはRESTCONFサーバは、クライアントのNETCONF及び/又はRESTCONF動作要求をサポートします。"
    },
    {
      "indent": 3,
      "text": "Many YANG constructs are defined as optional to use, such as the \"description\" statement. However, in order to make YANG modules more useful, it is desirable to define a set of usage guidelines that entails a higher level of compliance than the minimum level defined in the YANG specification [RFC7950].",
      "ja": "多くのYANG構築物は、このような「説明」文として、使用するオプションとして定義されています。しかし、YANGモジュールをより便利にするためには、YANG仕様[RFC7950]で定義された最小レベルよりコンプライアンスの高いレベルを必要と使用のガイドラインのセットを定義することが望ましいです。"
    },
    {
      "indent": 3,
      "text": "In addition, YANG allows constructs such as infinite length identifiers and string values, or top-level mandatory nodes, that a compliant server is not required to support. Only constructs that all servers are required to support can be used in IETF YANG modules.",
      "ja": "また、YANG準拠サーバをサポートするために必要とされないことを、このような無限長識別子と文字列値、または最上位必須ノードとして構築を可能にします。すべてのサーバーがサポートする必要があることを構築するだけではIETF YANGモジュールで使用することができます。"
    },
    {
      "indent": 3,
      "text": "This document defines usage guidelines related to the NETCONF operations layer and NETCONF content layer, as defined in [RFC6241], and the RESTCONF methods and RESTCONF resources, as defined in [RFC8040].",
      "ja": "[RFC8040]で定義されるように、このドキュメントは、[RFC6241]で定義されるように、NETCONFオペレーション層とNETCONFコンテンツレイヤに関連する使用上の注意事項を定義し、RESTCONF方法およびRESTCONFリソース。"
    },
    {
      "indent": 3,
      "text": "These guidelines are intended to be used by authors and reviewers to improve the readability and interoperability of published YANG data models.",
      "ja": "これらのガイドラインは公表されYANGデータモデルの読みやすさと相互運用性を向上させるために、著者と査読が使用することを意図しています。"
    },
    {
      "indent": 3,
      "text": "Note that this document is not a YANG tutorial, and the reader is expected to know the YANG data modeling language before implementing the guidance in this document.",
      "ja": "この文書はYANGのチュートリアルではありません、そして読者はこの文書のガイダンスを実装する前に、YANGデータモデリング言語を知ることが期待されていることに注意してください。"
    },
    {
      "indent": 1,
      "text": "1.1. Changes since",
      "section_title": true,
      "ja": "1.1. 以下からの変更点"
    },
    {
      "indent": 3,
      "text": "The following changes have been made to the guidelines published in [RFC6087]:",
      "ja": "次の変更は、[RFC6087]に掲載されたガイドラインに行われています。"
    },
    {
      "indent": 3,
      "text": "o Updated NETCONF reference from RFC 4741 to RFC 6241",
      "ja": "RFC 6241へのRFC 4741からO更新NETCONFの参照"
    },
    {
      "indent": 3,
      "text": "o Updated NETCONF over the Secure Shell (SSH) citation from RFC 4742 to RFC 6242",
      "ja": "RFC 6242にRFC 4742からのSecure Shell（SSH）引用オーバーO更新NETCONF"
    },
    {
      "indent": 3,
      "text": "o Updated YANG Types reference from RFC 6021 to RFC 6991",
      "ja": "O更新YANGタイプは、RFC 6991にRFC 6021からの参照します"
    },
    {
      "indent": 3,
      "text": "o Updated obsolete URLs for IETF resources",
      "ja": "O IETFリソースのため廃止されたU​​RLを更新しました"
    },
    {
      "indent": 3,
      "text": "o Changed top-level data node guideline",
      "ja": "O変更トップレベルデータノードガイドライン"
    },
    {
      "indent": 3,
      "text": "o Clarified XML Path Language (XPath) usage for a literal value representing a YANG identity",
      "ja": "YANGアイデンティティを表すリテラル値のO明確にXMLパス言語（XPath）使用"
    },
    {
      "indent": 3,
      "text": "o Clarified XPath usage for a when-stmt",
      "ja": "O-ときのstmtのためのXPathの使用状況を明確化"
    },
    {
      "indent": 3,
      "text": "o Clarified XPath usage for \"preceding-sibling\" and \"following-sibling\" axes",
      "ja": "O「先行兄弟」のXPathの使用を明確にし、「次-兄弟」軸"
    },
    {
      "indent": 3,
      "text": "o Added terminology guidelines",
      "ja": "O用語のガイドラインを追加しました"
    },
    {
      "indent": 3,
      "text": "o Added mention of RFC 8174, which updates RFC 2119 by clarifying the use of capitalized key words",
      "ja": "大文字のキーワードの使用を明確にすることによってRFC 2119を更新RFC 8174のOを追加しました言及し、"
    },
    {
      "indent": 3,
      "text": "o Added YANG tree diagram guidelines",
      "ja": "Oを追加しましたYANGツリー図のガイドライン"
    },
    {
      "indent": 3,
      "text": "o Updated XPath guidelines for type conversions and function library usage",
      "ja": "型変換および関数ライブラリを使用するためのO更新のXPathガイドライン"
    },
    {
      "indent": 3,
      "text": "o Updated \"Data Types\" section",
      "ja": "O更新し、「データ型」のセクション"
    },
    {
      "indent": 3,
      "text": "o Updated \"Notification Definitions\" section",
      "ja": "O更新「通知の定義」セクション"
    },
    {
      "indent": 3,
      "text": "o Clarified conditional key leaf nodes",
      "ja": "O条件付きキーリーフノードを明確化"
    },
    {
      "indent": 3,
      "text": "o Clarified usage of \"uint64\" and \"int64\" data types",
      "ja": "O「uint64型」と「Int64型」データ型の使用法を明確化"
    },
    {
      "indent": 3,
      "text": "o Added text on YANG feature usage",
      "ja": "YANG機能の使用状況にOを追加しましたテキスト"
    },
    {
      "indent": 3,
      "text": "o Added \"Identifier Naming Conventions\" section",
      "ja": "O「識別子の命名規則」セクションを追加しました"
    },
    {
      "indent": 3,
      "text": "o Clarified use of mandatory nodes with conditional augmentations o Clarified namespace and domain conventions for example modules",
      "ja": "例えばモジュールの明確化の名前空間とドメイン規則O条件オーグメンテーションとの必須のノードのO明確に使用"
    },
    {
      "indent": 3,
      "text": "o Clarified conventions for identifying code components",
      "ja": "Oコードコンポーネントを識別するための規則を明確化"
    },
    {
      "indent": 3,
      "text": "o Added YANG 1.1 guidelines",
      "ja": "Oを追加しましたピリオド1.1ガイドライン"
    },
    {
      "indent": 3,
      "text": "o Added \"YANG Data Node Constraints\" section",
      "ja": "O「YANGデータノードの制約」セクションを追加しました"
    },
    {
      "indent": 3,
      "text": "o Added mention of the RESTCONF protocol",
      "ja": "RESTCONFプロトコルのOを追加しました言及"
    },
    {
      "indent": 3,
      "text": "o Added guidelines for datastores revised by the Network Management Datastore Architecture (NMDA)",
      "ja": "ネットワーク管理データストア・アーキテクチャにより改訂されたデータストアのOを追加しましたガイドライン（NMDA）"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The following terms are used throughout this document:",
      "ja": "以下の用語は、この文書全体で使用されています。"
    },
    {
      "indent": 3,
      "text": "o published: A stable release of a module or submodule. For example, the \"Request for Comments\" described in Section 2.1 of [RFC2026] is considered a stable publication.",
      "ja": "O公表：モジュールまたはサブモジュールの安定したリリースを。例えば、[RFC2026]のセクション2.1に記載された「コメント要求」安定した出版物であると考えられます。"
    },
    {
      "indent": 3,
      "text": "o unpublished: An unstable release of a module or submodule. For example the \"Internet-Draft\" described in Section 2.2 of [RFC2026] is considered an unstable publication that is a work in progress, subject to change at any time.",
      "ja": "O未発表：モジュールまたはサブモジュールの不安定なリリースを。例えば、[RFC2026]のセクション2.2に記載された「インターネットドラフト」は、任意の時点で変更される進行中の作業であり、不安定な出版物であると考えられます。"
    },
    {
      "indent": 3,
      "text": "o YANG fragment: A set of YANG statements that are not intended to represent a complete YANG module or submodule. These statements are not intended for actual use, except to provide an example of YANG statement usage. The invalid syntax \"...\" is sometimes used to indicate that additional YANG statements would be present in a real YANG module.",
      "ja": "O YANG断片：完全YANGモジュールまたはサブモジュールを表すことを意図されていないYANG文のセット。 YANG文の使用例の目的以外にこれらの記述は、実際の使用のために意図されていません。無効な構文は、「...」時には、追加YANG文は実際のYANGモジュール内に存在するであろうことを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "o YANG tree diagram: A diagram representing the contents of a YANG module, as defined in [RFC8340]. It is also called a \"tree diagram\".",
      "ja": "O YANGツリーダイアグラム：[RFC8340]で定義されるようYANGモジュールの内容を表す図です。また、「樹形図」と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "2.1. NETCONF Terms",
      "section_title": true,
      "ja": "2.1.  NETCONF規約"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241] and are not redefined here:",
      "ja": "以下の用語は、[RFC6241]で定義されており、ここで再定義されていません。"
    },
    {
      "indent": 3,
      "text": "o capabilities",
      "ja": "O機能"
    },
    {
      "indent": 3,
      "text": "o client",
      "ja": "またはクライアント"
    },
    {
      "indent": 3,
      "text": "o operation",
      "ja": "運用O"
    },
    {
      "indent": 3,
      "text": "o server",
      "ja": "Oサーバ"
    },
    {
      "indent": 0,
      "text": "2.2. YANG Terms",
      "section_title": true,
      "ja": "2.2. 利用規約THAT"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC7950] and are not redefined here:",
      "ja": "以下の用語は、[RFC7950]で定義されており、ここで再定義されていません。"
    },
    {
      "indent": 3,
      "text": "o data node",
      "ja": "お だた ので"
    },
    {
      "indent": 3,
      "text": "o module",
      "ja": "Oモジュール"
    },
    {
      "indent": 3,
      "text": "o namespace",
      "ja": "Oの名前空間"
    },
    {
      "indent": 3,
      "text": "o submodule",
      "ja": "Oサブモジュール"
    },
    {
      "indent": 3,
      "text": "o version",
      "ja": "Oバージョン"
    },
    {
      "indent": 3,
      "text": "o YANG",
      "ja": "O"
    },
    {
      "indent": 3,
      "text": "o YIN",
      "ja": "MAKING O"
    },
    {
      "indent": 3,
      "text": "Note that the term 'module' may be used as a generic term for a YANG module or submodule. When describing properties that are specific to submodules, the term 'submodule' is used instead.",
      "ja": "用語「モジュール」はYANGモジュールまたはサブモジュールの総称として使用されてもよいことに留意されたいです。サブモジュールに固有の特性を説明するとき、用語「サブモジュール」は代わりに使用されています。"
    },
    {
      "indent": 0,
      "text": "2.3. NMDA Terms",
      "section_title": true,
      "ja": "2.3.  NMDA規約"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC8342] and are not redefined here:",
      "ja": "以下の用語は、[RFC8342]で定義されており、ここで再定義されていません。"
    },
    {
      "indent": 3,
      "text": "o configuration",
      "ja": "O構成"
    },
    {
      "indent": 3,
      "text": "o conventional configuration datastore",
      "ja": "O従来の構成データストア"
    },
    {
      "indent": 3,
      "text": "o datastore o operational state",
      "ja": "OデータストアO動作状態"
    },
    {
      "indent": 3,
      "text": "o operational state datastore",
      "ja": "O動作状態のデータストア"
    },
    {
      "indent": 0,
      "text": "2.4. Requirements Notation",
      "section_title": true,
      "ja": "2.4. 要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. General Documentation Guidelines",
      "section_title": true,
      "ja": "3.一般的なドキュメントのガイドライン"
    },
    {
      "indent": 3,
      "text": "YANG modules under review are likely to be contained in Internet-Drafts (I-Ds). All guidelines for I-D authors [ID-Guidelines] MUST be followed. The guidelines for RFCs should be followed and are defined in the following: [RFC7322] (and any future RFCs that obsolete it), [RFC-STYLE], and [RFC7841].",
      "ja": "検討中YANGモジュールは、インターネットドラフト（I-DS）に含まれる可能性があります。 IDの作者[ID-ガイドライン]のためのすべてのガイドラインに従わなければなりません。 RFCのガイドラインに従わなければならない、以下に定義される：[RFC7322]（およびそれ廃止将来のRFC）、[RFC-STYLE]、および[RFC7841]。"
    },
    {
      "indent": 3,
      "text": "The following sections MUST be present in an I-D containing a module:",
      "ja": "以下のセクションでは、モジュールを含むI-D中に存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Narrative sections",
      "ja": "O物語のセクション"
    },
    {
      "indent": 3,
      "text": "o Definition sections",
      "ja": "O定義セクション"
    },
    {
      "indent": 3,
      "text": "o Security Considerations section",
      "ja": "O Security Considerations部"
    },
    {
      "indent": 3,
      "text": "o IANA Considerations section",
      "ja": "O IANAの考慮事項のセクション"
    },
    {
      "indent": 3,
      "text": "o References section",
      "ja": "Oリファレンスセクション"
    },
    {
      "indent": 3,
      "text": "There are three usage scenarios for YANG that can appear in an I-D or RFC:",
      "ja": "I-DまたはRFCに表示できるYANGための3つの利用シナリオがあります。"
    },
    {
      "indent": 3,
      "text": "o normative module or submodule",
      "ja": "O規範的なモジュールまたはサブモジュール"
    },
    {
      "indent": 3,
      "text": "o example module or submodule",
      "ja": "Oたとえばモジュールまたはサブモジュール"
    },
    {
      "indent": 3,
      "text": "o example YANG fragment not part of any module or submodule",
      "ja": "OたとえばYANG断片の任意のモジュールまたはサブモジュールの一部ではありません"
    },
    {
      "indent": 3,
      "text": "The guidelines in this document refer mainly to a normative module or submodule but may be applicable to example modules and YANG fragments as well.",
      "ja": "この文書に記載されているガイドラインは、規範的なモジュール又はサブモジュールを主に参照するが、同様に、例えばモジュールとYANG断片に適用することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Module Copyright",
      "section_title": true,
      "ja": "3.1. モジュールの著作権"
    },
    {
      "indent": 3,
      "text": "The module \"description\" statement MUST contain a reference to the latest approved IETF Trust Copyright statement, which is available online at:",
      "ja": "モジュール「説明」の文は、オンラインで利用可能である最新の承認IETFトラスト著作権声明への参照を含まなければなりません："
    },
    {
      "indent": 7,
      "text": "<https://trustee.ietf.org/license-info/>",
      "ja": "＜ｈっｔｐｓ：／／ｔるｓてえ。いえｔｆ。おｒｇ／ぃせんせーいんふぉ／＞"
    },
    {
      "indent": 0,
      "text": "3.2. Code Components",
      "section_title": true,
      "ja": "3.2. コードコンポーネント"
    },
    {
      "indent": 3,
      "text": "Each normative YANG module or submodule contained within an I-D or RFC is considered to be a code component. The strings \"<CODE BEGINS>\" and \"<CODE ENDS>\" MUST be used to identify each code component.",
      "ja": "I-D又はRFC内に含まれる各規範YANGモジュールまたはサブモジュールは、コード成分であると考えられます。文字列は、「<CODEが始まる>」および「<CODEが終了>」は、各コード・コンポーネントを識別するために使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"<CODE BEGINS>\" tag SHOULD be followed by a string identifying the file name specified in Section 5.2 of [RFC7950]. The name string form that includes the revision date SHOULD be used. The revision date MUST match the date used in the most recent revision of the module.",
      "ja": "タグ[RFC7950]のセクション5.2で指定されたファイル名を識別する文字列が続くべきである「<CODEが始まる>が」。改訂日を含む名前の文字列形式を使用する必要があります。改訂日は、モジュールの最新版で使用される日付と一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following example is for the \"2016-03-20\" revision of the \"ietf-foo\" module:",
      "ja": "次の例では、「IETF-FOO」モジュールの「2016年3月20日」改訂するためのものです。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-foo@2016-03-20.yang\"",
      "ja": "ファイル \"ietf-foo@2016-03-20.yang\" <CODEが開始されます>"
    },
    {
      "indent": 7,
      "text": "module ietf-foo {\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-foo\";\n  prefix \"foo\";\n  organization \"...\";\n  contact \"...\";\n  description \"...\";\n  revision 2016-03-20 {\n    description \"Latest revision\";\n    reference \"RFC XXXX: Foo Protocol\";\n  }\n  // ... more statements\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "3.2.1. Example Modules",
      "section_title": true,
      "ja": "3.2.1. 例モジュール"
    },
    {
      "indent": 3,
      "text": "Example modules are not code components. The <CODE BEGINS> convention MUST NOT be used for example modules.",
      "ja": "例えばモジュールは、コード構成要素ではありません。 <CODEが開始されます>大会は、例えば、モジュールのために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "An example module SHOULD be named using the term \"example\", followed by a hyphen, followed by a descriptive name, e.g., \"example-toaster\".",
      "ja": "例えば、モジュールは、例えば、「例えば、トースター」、記述名に続く、ハイフンに続いて、用語「例えば」を用いて命名されるべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 4.9 regarding the namespace guidelines for example modules.",
      "ja": "例えば、モジュールの名前空間のガイドラインについては4.9節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3. Terminology Section",
      "section_title": true,
      "ja": "3.3. 用語の説明"
    },
    {
      "indent": 3,
      "text": "A terminology section MUST be present if any terms are defined in the document or if any terms are imported from other documents.",
      "ja": "任意の用語がドキュメント内で定義されている場合、または任意の用語が他の文書からインポートする場合の用語セクションが存在しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Tree Diagrams",
      "section_title": true,
      "ja": "3.4. ツリーダイアグラム"
    },
    {
      "indent": 3,
      "text": "YANG tree diagrams provide a concise representation of a YANG module and SHOULD be included to help readers understand YANG module structure. Guidelines on tree diagrams can be found in Section 3 of [RFC8340].",
      "ja": "YANGツリー図はYANGモジュールの簡潔な表現を提供し、読者がYANGモジュール構造を理解するために含まれるべきです。ツリー図に関するガイドラインは、[RFC8340]のセクション3に記載されています。"
    },
    {
      "indent": 3,
      "text": "If YANG tree diagrams are used, then an informative reference to the YANG tree diagrams specification MUST be included in the document. Refer to Section 2.2 of [RFC8349] for an example of such a reference.",
      "ja": "YANGツリーダイアグラムが使用される場合、次いで、YANGツリーダイアグラム仕様に有益な参照は、文書に含まれなければなりません。このような基準の例については、[RFC8349]のセクション2.2を参照。"
    },
    {
      "indent": 0,
      "text": "3.5. Narrative Sections",
      "section_title": true,
      "ja": "3.5. 物語のセクション"
    },
    {
      "indent": 3,
      "text": "The narrative part MUST include an overview section that describes the scope and field of application of the module(s) defined by the specification and that specifies the relationship (if any) of these modules to other standards, particularly to standards containing other YANG modules. The narrative part SHOULD include one or more sections to briefly describe the structure of the modules defined in the specification.",
      "ja": "物語の一部は、仕様によって定義されたモジュール（単数または複数）の適用の範囲および分野を説明しているが、他の規格にこれらのモジュールの、特に他のYANGモジュールを含む標準との関係を（もしあれば）を指定概要セクションを含まなければなりません。物語の一部を簡単仕様で定義されたモジュールの構造を説明するために1つ以上のセクションを含むべきです。"
    },
    {
      "indent": 3,
      "text": "If the module or modules defined by the specification imports definitions from other modules (except for those defined in [RFC7950] or [RFC6991]) or are always implemented in conjunction with other modules, then those facts MUST be noted in the overview section; any special interpretations of definitions in other modules MUST be noted as well. Refer to Section 2.3 of [RFC8349] for an example of this overview section.",
      "ja": "モジュールまたはモジュール（[RFC7950]または[RFC6991]で定義されたものを除く）、他のモジュールから指定輸入定義によって定義されるかは、常に他のモジュールと組み合わせて実装されている場合、これらの事実は、概要セクションに注意しなければなりません。他のモジュール内の定義の特別な解釈も同様に留意しなければなりません。この概要セクションの例えば[RFC8349]のセクション2.3を参照。"
    },
    {
      "indent": 3,
      "text": "If the document contains a YANG module(s) that is compliant with NMDA [RFC8342], then the Introduction section should mention this fact.",
      "ja": "文書は、NMDA [RFC8342]に準拠したYANGモジュール（複数可）が含まれている場合は、はじめのセクションでは、この事実を言及する必要があります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "The YANG data model in this document conforms to the Network Management Datastore Architecture defined in RFC 8342.",
      "ja": "このドキュメントのYANGデータモデルは、RFC 8342で定義されたネットワーク管理データストアのアーキテクチャに準拠しています。"
    },
    {
      "indent": 3,
      "text": "Consistent indentation SHOULD be used for all examples, including YANG fragments and protocol message instance data. If line wrapping is done for formatting purposes, then this SHOULD be noted, as shown in the following example:",
      "ja": "一貫したインデントはYANG断片とプロトコルメッセージインスタンスデータを含む全ての実施例に使用されるべきです。行の折り返しをフォーマット化目的のために行われている場合、次の例に示すように、これは、注意すべきです。"
    },
    {
      "indent": 6,
      "text": "[note: '\\' line wrapping for formatting only]",
      "ja": "[注：フォーマットするための「\\」行の折り返しのみ]"
    },
    {
      "indent": 6,
      "text": "<myleaf xmlns=\"tag:example.com,2017:example-two\">\\ this is a long value so the line needs to wrap to stay\\ within 72 characters\\ </myleaf>",
      "ja": "<myleafのxmlns = \"タグ：example.com、2017：例-2\"> \\行が72文字\\ </ myleaf>内\\滞在するラップする必要がありますので、これは長い値であり、"
    },
    {
      "indent": 0,
      "text": "3.6. Definitions Section",
      "section_title": true,
      "ja": "3.6. 定義セクション"
    },
    {
      "indent": 3,
      "text": "This section contains the module(s) defined by the specification. These modules SHOULD be written using the YANG 1.1 [RFC7950] syntax. YANG 1.0 [RFC6020] syntax MAY be used if no YANG 1.1 constructs or semantics are needed in the module. If any of the imported YANG modules are written using YANG 1.1, then the module MUST be written using YANG 1.1.",
      "ja": "このセクションでは、仕様で定義されたモジュール（複数可）を含有します。これらのモジュールは、YANG 1.1 [RFC7950]の構文を使用して記述する必要があります。何YANG 1.1構築物またはセマンティクスがモジュールで必要とされていない場合YANG 1.0 [RFC6020]の構文を使用することができます。インポートYANGモジュールのいずれかがYANG 1.1を使用して書かれている場合、モジュールは、YANG 1.1を使用して書かなければなりません。"
    },
    {
      "indent": 3,
      "text": "A YIN syntax version of the module MAY also be present in the document. There MAY also be other types of modules present in the document, such as Structure of Management Information Version 2 (SMIv2), which are not affected by these guidelines.",
      "ja": "モジュールのYIN構文バージョンは、文書中に存在することができます。また、これらのガイドラインに影響されないように経営情報バージョン2の構造としての文書に存在するモジュールの他のタイプ、（SMIv2の）があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that if the module itself is considered normative and not an example module or example YANG fragment, then all YANG statements within a YANG module are considered normative. The use of keywords defined in [RFC2119] and [RFC8174] apply to YANG \"description\" statements in normative modules exactly as they would in any other normative section.",
      "ja": "モジュール自体は、例えばモジュールまたは例えばYANG断片規範としないと考えられる場合、YANGモジュール内のすべてのYANGステートメントが規範的であると考えられることに留意されたいです。で定義されたキーワードの使用[RFC2119]と[RFC8174]は、正確に、彼らは他の規範的部分と同じように規範的なモジュールでYANG「説明」書類に適用されます。"
    },
    {
      "indent": 3,
      "text": "Example YANG modules and example YANG fragments MUST NOT contain any normative text, including any all-uppercase reserved words from [RFC2119] and [RFC8174].",
      "ja": "例えばYANGモジュールと例YANG断片は[RFC2119]及び[RFC8174]から任意すべて大文字予約語を含む、任意の規範的なテキストを含んではなりません。"
    },
    {
      "indent": 3,
      "text": "Consistent indentation and formatting SHOULD be used in all YANG statements within a module.",
      "ja": "一貫性のインデントとフォーマットは、モジュール内のすべてのYANGステートメントで使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 4 for guidelines on YANG usage.",
      "ja": "YANGの使用に関するガイドラインについては第4章を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.7. Security Considerations Section",
      "section_title": true,
      "ja": "3.7. セキュリティの考慮事項のセクション"
    },
    {
      "indent": 3,
      "text": "Each specification that defines one or more modules MUST contain a section that discusses security considerations relevant to those modules.",
      "ja": "一個の以上のモジュールを定義し、各仕様は、それらのモジュールに関連するセキュリティ上の考慮事項について説明セクションを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "This section MUST be patterned after the latest approved template (available at <https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines>). Section 3.7.1 contains the security considerations template dated 2013-05-08 and last updated on 2018-07-02. Authors MUST check the web page at the URL listed above in case there is a more recent version available.",
      "ja": "このセクションでは、（<https://trac.ietf.org/trac/ops/wiki/yang-security-guidelines>で入手可能）、最新の承認されたテンプレートの後にパターン化されなければなりません。セクション3.7.1は2013年5月8日の日付と最後は2018年7月2日に更新されたセキュリティ上の考慮事項のテンプレートが含まれています。著者は、利用可能な、より新しいバージョンがある場合には、上記のURLでWebページをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "In particular:",
      "ja": "特に："
    },
    {
      "indent": 3,
      "text": "o Writable data nodes that could be especially disruptive if abused MUST be explicitly listed by name, and the associated security risks MUST be explained.",
      "ja": "O虐待されている場合は特に破壊的かもしれない書き込み可能なデータ・ノードは、明示的に名前が記載されている必要があり、および関連するセキュリティリスクを説明しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Readable data nodes that contain especially sensitive information or that raise significant privacy concerns MUST be explicitly listed by name, and the reasons for the sensitivity/privacy concerns MUST be explained.",
      "ja": "O、特に機密性の高い情報が含まれているか、その重要なプライバシーの問題を提起読み取り可能なデータ・ノードは、明示的に名前が記載されている必要があり、かつ感度/プライバシーの問題の理由を説明しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Operations (i.e., YANG \"rpc\" statements) that are potentially harmful to system behavior or that raise significant privacy concerns MUST be explicitly listed by name, and the reasons for the sensitivity/privacy concerns MUST be explained.",
      "ja": "O操作（すなわち、YANG「RPC」文）システムの動作に潜在的に有害であるか、それは重大なプライバシーの問題が明示的に名前が記載されている必要があり上げ、感度/プライバシーの問題の理由を説明しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.7.1. Security Considerations Section Template",
      "section_title": true,
      "ja": "3.7.1. セキュリティの考慮事項セクションのテンプレート"
    },
    {
      "indent": 3,
      "text": "X. Security Considerations",
      "ja": "X.のセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The YANG module specified in this document defines a schema for data that is designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040]. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) [RFC6242]. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS [RFC8446].",
      "ja": "この文書で指定YANGモジュールは、NETCONF [RFC6241]またはRESTCONF [RFC8040]などのネットワーク管理プロトコルを介してアクセスするように設計されているデータのスキーマを定義します。最低NETCONF層は、セキュアトランスポート層であり、強制的に実装安全な輸送は、セキュアシェル（SSH）[RFC6242]です。最低RESTCONF層はHTTPSであり、強制的に実装安全な輸送は、TLS [RFC8446]です。"
    },
    {
      "indent": 3,
      "text": "The NETCONF access control model [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.",
      "ja": "NETCONFアクセス制御モデル[RFC8341]は、すべての利用可能なNETCONF又はRESTCONFプロトコル操作とコンテンツの事前設定されたサブセットに特定のNETCONF又はRESTCONFユーザーのアクセスを制限するための手段を提供します。"
    },
    {
      "indent": 4,
      "text": "-- if you have any writable data nodes (those are all the -- \"config true\" nodes, and remember, that is the default) -- describe their specific sensitivity or vulnerability.",
      "ja": " - あなたが任意の書き込み可能なデータノードがある場合（これらはすべてある - 「コンフィグ真」ノード、および覚えて、それがデフォルトです） - 彼らの特定の感度や脆弱性について説明します。"
    },
    {
      "indent": 3,
      "text": "There are a number of data nodes defined in this YANG module that are writable/creatable/deletable (i.e., \"config true\", which is the default). These data nodes may be considered sensitive or vulnerable in some network environments. Write operations (e.g., edit-config) to these data nodes without proper protection can have a negative effect on network operations. These are the subtrees and data nodes and their sensitivity/vulnerability:",
      "ja": "書き込み可能/作成可能/削除可能（デフォルト、すなわち、「真の設定」）である。このYANGモジュールで定義されたデータノードの数があります。これらのデータノードは、いくつかのネットワーク環境に敏感又は脆弱と考えることができます。適切な保護なしに、これらのデータノードへの書き込み操作（例えば、編集設定）は、ネットワーク操作に悪影響を与えることができます。これらは、サブツリーとデータノードとそれらの感度/脆弱性です："
    },
    {
      "indent": 3,
      "text": "<list subtrees and data nodes and state why they are sensitive>",
      "ja": "<リストのサブツリーとデータノードと状態がなぜ彼らは敏感です>"
    },
    {
      "indent": 4,
      "text": "-- for all YANG modules you must evaluate whether any readable data -- nodes (those are all the \"config false\" nodes, but also all other -- nodes, because they can also be read via operations like get or -- get-config) are sensitive or vulnerable (for instance, if they -- might reveal customer information or violate personal privacy -- laws such as those of the European Union if exposed to -- unauthorized parties)",
      "ja": " -  GET-  - 彼らはまた、取得などの操作を経由して読み取ることができるため、ノード - ノード（それらのすべての「コンフィグ偽」のノードであるが、他のすべて - すべてYANGモジュールのためにあなたは、任意の読み取り可能なデータがあるかどうかを評価しなければなりません）権限のない者 - にさらされた場合、欧州連合（EU）のものと法律を - 顧客情報を明らかにしたり、個人のプライバシーを侵害する可能性がある -  configが）彼らは例えば、場合（感受性または脆弱です"
    },
    {
      "indent": 3,
      "text": "Some of the readable data nodes in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control read access (e.g., via get, get-config, or notification) to these data nodes. These are the subtrees and data nodes and their sensitivity/vulnerability:",
      "ja": "このYANGモジュールで読み取り可能なデータノードのいくつかは、いくつかのネットワーク環境に敏感又は脆弱と考えることができます。これらのデータノードにアクセスすること（例えば、GETを介して、または通知設定を取得する）読み取り制御することが重要です。これらは、サブツリーとデータノードとそれらの感度/脆弱性です："
    },
    {
      "indent": 3,
      "text": "<list subtrees and data nodes and state why they are sensitive>",
      "ja": "<リストのサブツリーとデータノードと状態がなぜ彼らは敏感です>"
    },
    {
      "indent": 4,
      "text": "-- if your YANG module has defined any RPC operations -- describe their specific sensitivity or vulnerability.",
      "ja": "あなたYANGモジュールは任意のRPC操作を定義している場合 -   - 彼らの特定の感度や脆弱性について説明します。"
    },
    {
      "indent": 3,
      "text": "Some of the RPC operations in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control access to these operations. These are the operations and their sensitivity/vulnerability:",
      "ja": "このYANGモジュールにおけるRPC操作のいくつかは、いくつかのネットワーク環境に敏感又は脆弱と考えることができます。これらの操作へのアクセスを制御することが重要です。これらは、操作とそれらの感度/脆弱性です："
    },
    {
      "indent": 3,
      "text": "<list RPC operations and state why they are sensitive>",
      "ja": "<リストのRPC操作や状態がなぜ彼らは敏感です>"
    },
    {
      "indent": 0,
      "text": "3.8. IANA Considerations Section",
      "section_title": true,
      "ja": "3.8.  IANA問題部"
    },
    {
      "indent": 3,
      "text": "In order to comply with IESG policy as set forth in <https://www.ietf.org/id-info/checklist.html>, every I-D that is submitted to the IESG for publication MUST contain an IANA Considerations section. The requirements for this section vary depending on what actions are required of the IANA. If there are no IANA considerations applicable to the document, then the IANA Considerations section will state that \"This document has no IANA actions\". Refer to the guidelines in [RFC8126] for more details.",
      "ja": "<https://www.ietf.org/id-info/checklist.html>に記載のIESGポリシーに準拠するために、出版のためにIESGに提出されたすべてのI-Dは、IANA Considerations部を含まなければなりません。このセクションの要件は、アクションがIANAに要求されるものに応じて異なります。文書に適用されるいかなるIANA問題がない場合、IANAの考慮事項のセクションでは、「この文書は何のIANAのアクションを持っていない」と述べているだろう。詳細は[RFC8126]のガイドラインを参照してください。"
    },
    {
      "indent": 3,
      "text": "Each normative YANG module MUST be registered in both the \"IETF XML Registry\" [RFC3688] [IANA-XML] and the \"YANG Module Names\" registry [RFC6020] [IANA-MOD-NAMES]. This applies to new modules and updated modules. An example of an update registration for the \"ietf-template\" module can be found in Section 5.",
      "ja": "各規範YANGモジュールは、 \"IETF XMLレジストリ\" の両方に登録する必要があります[RFC3688] [IANA-XML]と \"YANGモジュール名\" レジストリ[RFC6020] [IANA-MOD-NAMES]。これは、新しいモジュールや更新されたモジュールに適用されます。 「IETFテンプレート」モジュールの更新登録の例は、第5節に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Documents That Create a New Namespace",
      "section_title": true,
      "ja": "3.8.1. 新しい名前空間を作成ドキュメント"
    },
    {
      "indent": 3,
      "text": "If an I-D defines a new namespace that is to be administered by the IANA, then the document MUST include an IANA Considerations section that specifies how the namespace is to be administered.",
      "ja": "I-Dは、IANAによって投与される新しい名前空間を定義する場合、その文書は、名前空間が投与される方法を指定するIANAの考慮事項のセクションを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Specifically, if any YANG module namespace statement value contained in the document is not already registered with IANA, then a new entry in the \"ns\" subregistry within the \"IETF XML Registry\" MUST be requested from the IANA.",
      "ja": "文書に含まれるいかなるYANGモジュールの名前空間のステートメントの値がすでにIANAに登録されていない場合は具体的に、そして、「IETF XMLレジストリ」内の「NS」副登録に新しいエントリがIANAから要求されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Documents That Extend an Existing Namespace",
      "section_title": true,
      "ja": "3.8.2. 既存の名前空間を拡張する書類"
    },
    {
      "indent": 3,
      "text": "It is possible to extend an existing namespace using a YANG submodule that belongs to an existing module already administered by IANA. In this case, the document containing the main module MUST be updated to use the latest revision of the submodule.",
      "ja": "すでにIANAが管理既存のモジュールに属しYANGサブモジュールを使用して、既存の名前空間を拡張することが可能です。この場合、メインモジュールを含む文書は、サブモジュールの最新版を使用するように更新されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.9. References Sections",
      "section_title": true,
      "ja": "3.9. 参考文献セクション"
    },
    {
      "indent": 3,
      "text": "For every import or include statement that appears in a module contained in the specification that identifies a module in a separate document, a corresponding normative reference to that document MUST appear in the Normative References section. The reference MUST correspond to the specific module version actually used within the specification.",
      "ja": "別のドキュメントにモジュールを識別する仕様に含まれているモジュールに表示されるステートメントを含むすべてのインポートのために、または、その文書に対応する規範的な参照は、引用規格のセクションに表示されなければなりません。参照は、実際には仕様の範囲内で使用される特定のモジュールバージョンに対応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For every normative reference statement that appears in a module contained in the specification that identifies a separate document, a corresponding normative reference to that document SHOULD appear in the Normative References section. The reference SHOULD correspond to the specific document version actually used within the specification. If the reference statement identifies an informative reference that identifies a separate document, a corresponding informative reference to that document MAY appear in the Informative References section.",
      "ja": "別の文書を識別する仕様に含まれているモジュールに表示されるすべての引用規格文に対して、その文書に対応する規範的な参照は、引用規格のセクションに表示されます。参照は、実際には仕様の範囲内で使用される特定の文書のバージョンに対応しなければなりません。参照文が別の文書を特定する有益な参照を識別した場合、その文書に対応する有益な参照は、有益な参考資料セクションに表示されることがあります。"
    },
    {
      "indent": 0,
      "text": "3.10. Validation Tools",
      "section_title": true,
      "ja": "3.10. 検証ツール"
    },
    {
      "indent": 3,
      "text": "All modules need to be validated before submission in an I-D. The 'pyang' YANG compiler is freely available from GitHub:",
      "ja": "すべてのモジュールは、I-Dに提出する前に検証する必要があります。 「pyang」YANGコンパイラは、GitHubのから自由に入手可能です："
    },
    {
      "indent": 5,
      "text": "<https://github.com/mbj4668/pyang>",
      "ja": "＜ｈっｔｐｓ：／／ぎてゅｂ。こｍ／ｍｂｊ４６６８／ぴゃんｇ＞"
    },
    {
      "indent": 3,
      "text": "If the 'pyang' compiler is used to validate a normative module, then the \"--ietf\" command-line option MUST be used to identify any IETF guideline issues.",
      "ja": "「pyang」コンパイラが規範モジュールを検証するために使用されている場合は、「--ietf」コマンドラインオプションは任意のIETFガイドラインの問題を識別するために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the 'pyang' compiler is used to validate an example module, then the \"--ietf\" command-line option MAY be used to identify any IETF guideline issues.",
      "ja": "「pyang」コンパイラは、例えばモジュールを検証するために使用されている場合は、「--ietf」コマンドラインオプションは任意のIETFガイドラインの問題を識別するために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The \"yanglint\" program is also freely available from GitHub.",
      "ja": "「yanglint」プログラムは、GitHubのからも自由に利用可能です。"
    },
    {
      "indent": 6,
      "text": "<https://github.com/CESNET/libyang>",
      "ja": "＜ｈっｔｐｓ：／／ぎてゅｂ。こｍ／せＳねＴ／ぃびゃんｇ＞"
    },
    {
      "indent": 3,
      "text": "This tool can be used to validate XPath statements within YANG modules.",
      "ja": "このツールは、YANGモジュール内のXPath文を検証するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.11. Module Extraction Tools",
      "section_title": true,
      "ja": "3.11. モジュールの抽出ツール"
    },
    {
      "indent": 3,
      "text": "A version of 'rfcstrip' that will extract YANG modules from an I-D or RFC is available. The 'rfcstrip' tool that supports YANG module extraction is freely available at:",
      "ja": "I-D又はRFCからYANGモジュールを抽出する「rfcstrip」のバージョンが利用可能です。 YANGモジュールの抽出をサポートしています「rfcstrip」ツールがで自由に利用可能です。"
    },
    {
      "indent": 5,
      "text": "<https://github.com/mbj4668/rfcstrip>",
      "ja": "＜ｈっｔｐｓ：／／ぎてゅｂ。こｍ／ｍｂｊ４６６８／ｒｆｃｓｔりｐ＞"
    },
    {
      "indent": 3,
      "text": "This tool can be used to verify that the \"<CODE BEGINS>\" and \"<CODE ENDS>\" tags are used correctly and that the normative YANG modules can be extracted correctly.",
      "ja": "このツールは、「<CODE BEGINS>」ことを確認するために使用し、規範YANGモジュールが正しく抽出することができることを、「<CODEはENDS>」タグが正しく使用されているとすることができます。"
    },
    {
      "indent": 3,
      "text": "The \"xym\" tool is freely available on GitHub and can be used to extract YANG modules from a document.",
      "ja": "「XYM」ツールは、GitHubの上で自由に利用可能であり、文書からYANGモジュールを抽出するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "<https://github.com/xym-tool/xym>",
      "ja": "＜ｈっｔｐｓ：／／ぎてゅｂ。こｍ／ｘｙｍーとおｌ／ｘｙｍ＞"
    },
    {
      "indent": 0,
      "text": "3.12. Module Usage Examples",
      "section_title": true,
      "ja": "3.12. モジュールの使用例"
    },
    {
      "indent": 3,
      "text": "Each specification that defines one or more modules SHOULD contain usage examples, either throughout the document or in an appendix. This includes example instance document snippets in an appropriate encoding (e.g., XML and/or JSON) to demonstrate the intended usage of the YANG module(s). Example modules MUST be validated. Refer to Section 3.10 for tools that validate YANG modules. If IP addresses are used, then a mix of either IPv4 and IPv6 addresses or IPv6 addresses exclusively SHOULD be used in the examples.",
      "ja": "一つ以上のモジュールを定義し、各仕様は、文書全体または虫垂のいずれかで、使用例が含まれているべきです。これは、YANGモジュール（単数または複数）の使用目的を示すために適切な符号化の例のインスタンス・ドキュメントの断片（例えば、XML及び/またはJSON）を含みます。例のモジュールは、検証する必要があります。 YANGモジュールを検証するツールについては、セクション3.10を参照してください。 IPアドレスが使用されている場合は、IPv4およびIPv6アドレスまたはIPv6のいずれかのミックスは、もっぱら例で使用されるべきであるアドレス。"
    },
    {
      "indent": 0,
      "text": "4. YANG Usage Guidelines",
      "section_title": true,
      "ja": "4. YANG使用上のガイドライン"
    },
    {
      "indent": 3,
      "text": "Modules in IETF Standards Track specifications MUST comply with all syntactic and semantic requirements of YANG 1.1 [RFC7950]. See the exception for YANG 1.0 in Section 3.6. The guidelines in this section are intended to supplement the YANG specification [RFC7950], which is intended to define a minimum set of conformance requirements.",
      "ja": "IETF標準化過程仕様のモジュールは、YANG 1.1 [RFC7950]のすべての構文とセマンティック要件を遵守しなければなりません。セクション3.6でYANG 1.0の例外を参照してください。このセクションのガイドラインは、適合性要件の最小セットを定義することを意図しているYANG仕様[RFC7950]を、補完することを意図しています。"
    },
    {
      "indent": 3,
      "text": "In order to promote interoperability and establish a set of practices based on previous experience, the following sections establish usage guidelines for specific YANG constructs.",
      "ja": "相互運用性を促進し、これまでの経験に基づいた実践のセットを確立するために、次のセクションでは、YANG構築物の特定の使用ガイドラインを確立します。"
    },
    {
      "indent": 3,
      "text": "Only guidelines that clarify or restrict the minimum conformance requirements are included here.",
      "ja": "最小適合性要件を明確化または制限するだけのガイドラインはここに含まれています。"
    },
    {
      "indent": 0,
      "text": "4.1. Module Naming Conventions",
      "section_title": true,
      "ja": "4.1. モジュールの命名規則"
    },
    {
      "indent": 3,
      "text": "Normative modules contained in Standards Track documents MUST be named according to the guidelines in the IANA Considerations section of [RFC7950].",
      "ja": "標準化過程文書に含まれている規範的なモジュールは、[RFC7950]のIANAの考慮事項セクションのガイドラインに従って名前を付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "A distinctive word or abbreviation (e.g., protocol name or working group abbreviation) SHOULD be used in the module name. If new definitions are being defined to extend one or more existing modules, then the same word or abbreviation should be reused, instead of creating a new one.",
      "ja": "特有の単語または略語（例えば、プロトコル名やワーキンググループ略称）モジュール名で使用されるべきです。新しい定義は、1つまたは複数の既存のモジュールを拡張するために定義されている場合は、同じ単語や略語ではなく、新しいものを作成するのではなく、再利用する必要があります。"
    },
    {
      "indent": 3,
      "text": "All published module names MUST be unique. For a YANG module published in an RFC, this uniqueness is guaranteed by IANA. For unpublished modules, the authors need to check that no other work in progress is using the same module name.",
      "ja": "公開されたすべてのモジュール名は一意でなければなりません。 RFCで公開されYANGモジュールの場合、このユニークさは、IANAによって保証されています。未発表のモジュールの場合、著者は、進行中の他の作業は、同じモジュール名を使用していないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Example modules are non-normative and SHOULD be named with the prefix \"example-\".",
      "ja": "例モジュールは非規範的であり、接頭辞「例 - 」と名前を付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "It is suggested that a stable prefix be selected that represents the entire organization. All normative YANG modules published by the IETF MUST begin with the prefix \"ietf-\". Another standards organization, such as the IEEE, might use the prefix \"ieee-\" for all YANG modules.",
      "ja": "安定したプレフィックスは、組織全体を表す選択することが示唆されます。 IETFによって発行されたすべての規範YANGモジュールは、接頭辞「ietf-」で始まる必要があります。 IEEEなどの別の標準化団体は、すべてのYANGモジュールの「IEEE-」接頭辞を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Once a module name is published, it MUST NOT be reused, even if the RFC containing the module is reclassified to \"Historic\" status. A module name cannot be changed in YANG, and this would be treated as a new module, not a name change.",
      "ja": "モジュール名が公開されたら、モジュールを含むRFCが「歴史」の状態に再分類された場合でも、再利用してはいけません。モジュール名はYANGで変更することはできません、これは新しいモジュールではなく、名前の変更として扱われます。"
    },
    {
      "indent": 0,
      "text": "4.2. Prefixes",
      "section_title": true,
      "ja": "4.2. 接頭辞"
    },
    {
      "indent": 3,
      "text": "All YANG definitions are scoped by the module containing the definition being referenced. This allows definitions from multiple modules to be used, even if the names are not unique. In the example below, the identifier \"foo\" is used in all three modules:",
      "ja": "すべてYANG定義は、参照されている定義を含むモジュールによってスコープされています。これは、名前が固有でない場合でも、複数のモジュールからの定義を使用することができます。以下の例では、識別子「FOO」はすべての3つのモジュールで使用されています。"
    },
    {
      "indent": 7,
      "text": "module example-foo {\n  namespace \"tag:example.com,2017:example-foo\";\n  prefix f;",
      "raw": true
    },
    {
      "indent": 7,
      "text": " container foo; }",
      "ja": "コンテナ食品。 }"
    },
    {
      "indent": 7,
      "text": "module example-bar {\n  namespace \"tag:example.com,2017:example-bar\";\n  prefix b;",
      "raw": true
    },
    {
      "indent": 7,
      "text": " typedef foo { type uint32; } }",
      "ja": "FOO {型UINT32のtypedef。 }}"
    },
    {
      "indent": 7,
      "text": "module example-one {\n  namespace \"tag:example.com,2017:example-one\";\n  prefix one;\n  import example-foo { prefix f; }\n  import example-bar { prefix b; }",
      "raw": true
    },
    {
      "indent": 7,
      "text": " augment \"/f:foo\" { leaf foo { type b:foo; } } }",
      "ja": "{リーフFOO {b型： \"FOO / F\"：増強FOOを、 }}}"
    },
    {
      "indent": 3,
      "text": "YANG defines the following rules for prefix usage:",
      "ja": "YANGは、接頭辞を使用するため、以下のルールを定義します。"
    },
    {
      "indent": 3,
      "text": "o Prefixes are never used for built-in data types and YANG keywords.",
      "ja": "Oプレフィックスは、組み込みデータ型とYANGキーワードに使用されることはありません。"
    },
    {
      "indent": 3,
      "text": "o A prefix MUST be used for any external statement (i.e., a statement defined with the YANG \"extension\" statement).",
      "ja": "Oプレフィックスを外部ステートメントに使用されなければならない（すなわち、YANG「拡張子」ステートメントで定義されたステートメント）。"
    },
    {
      "indent": 3,
      "text": "o The proper module prefix MUST be used for all identifiers imported from other modules.",
      "ja": "Oモジュールの適切な接頭辞は他のモジュールからインポートされたすべての識別子を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The proper module prefix MUST be used for all identifiers included from a submodule.",
      "ja": "Oモジュールの適切な接頭辞がサブモジュールから含まれるすべての識別子を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following guidelines apply to prefix usage of the current (local) module:",
      "ja": "以下のガイドラインは、現在の（ローカル）モジュールの使用を接頭辞に適用されます。"
    },
    {
      "indent": 3,
      "text": "o The local module prefix SHOULD be used instead of no prefix in all path expressions.",
      "ja": "Oローカルモジュールプレフィックスではなく、すべてのパス式でない接頭辞の使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The local module prefix MUST be used instead of no prefix in all \"default\" statements for an \"identityref\" or \"instance-identifier\" data type.",
      "ja": "Oローカルモジュールプレフィックスは「identityref」または「インスタンス識別子」データ型のすべての「デフォルト」の文でない接頭辞の代わりに使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The local module prefix MAY be used for references to typedefs, groupings, extensions, features, and identities defined in the module.",
      "ja": "Oローカルモジュールのプレフィックスは、モジュールで定義されたtypedefで、グループ化、拡張、機能、およびアイデンティティへの参照のために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Prefix values SHOULD be short but are also likely to be unique. Prefix values SHOULD NOT conflict with known modules that have been previously published.",
      "ja": "プレフィックス値は短くなるだけでなく、ユニークである可能性があるべきです。プレフィックス値は、以前に公開されている既知のモジュールと競合することはありません。"
    },
    {
      "indent": 0,
      "text": "4.3. Identifiers",
      "section_title": true,
      "ja": "4.3. 識別子"
    },
    {
      "indent": 3,
      "text": "Identifiers for all YANG identifiers in published modules MUST be between 1 and 64 characters in length. These include any construct specified as an \"identifier-arg-str\" token in the ABNF in Section 14 of [RFC7950].",
      "ja": "公表されたモジュール内のすべてのYANG識別子の識別子の長さは1〜64文字の間でなければなりません。これらは、[RFC7950]のセクション14にABNFの「識別子のarg-STR」トークンとして指定された構築物を含みます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Identifier Naming Conventions",
      "section_title": true,
      "ja": "4.3.1. 識別子の命名規則"
    },
    {
      "indent": 3,
      "text": "Identifiers SHOULD follow a consistent naming pattern throughout the module. Only lowercase letters, numbers, and dashes SHOULD be used in identifier names. Uppercase characters, the period character, and the underscore character MAY be used if the identifier represents a well-known value that uses these characters. YANG does not permit any other characters in YANG identifiers.",
      "ja": "識別子は、モジュール全体で一貫した命名パターンに従ってください。唯一の小文字、数字、およびダッシュは識別名に使用されるべきである（SHOULD）。識別子は、これらの文字を使用して、よく知られた値を表す場合、大文字、ピリオド、およびアンダースコア文字を使用することができます。 YANG YANGは、識別子内の他の文字を許可しません。"
    },
    {
      "indent": 3,
      "text": "Identifiers SHOULD include complete words and/or well-known acronyms or abbreviations. Child nodes within a container or list SHOULD NOT replicate the parent identifier. YANG identifiers are hierarchical and are only meant to be unique within the set of sibling nodes defined in the same module namespace.",
      "ja": "識別子は、完全な単語および/または、よく知られた頭字語や略語を含むべきです。コンテナまたはリスト内の子ノードは、親識別子を複製すべきではありません。 YANG識別子は階層的であり、同じモジュール名前空間で定義されたノードの兄弟のセット内で一意であることを意味します。"
    },
    {
      "indent": 3,
      "text": "It is permissible to use common identifiers such as \"name\" or \"id\" in data definition statements, especially if these data nodes share a common data type.",
      "ja": "これらのデータノードは、共通のデータ型を共有する場合は特に、データ定義文では、このような「名前」または「ID」などの一般的な識別子を使用することが許されます。"
    },
    {
      "indent": 3,
      "text": "Identifiers SHOULD NOT carry any special semantics that identify data modeling properties. Only YANG statements and YANG extension statements are designed to convey machine-readable data modeling properties. For example, naming an object \"config\" or \"state\" does not change whether it is configuration data or state data. Only defined YANG statements or YANG extension statements can be used to assign semantics in a machine-readable format in YANG.",
      "ja": "識別子は、データモデリングのプロパティを識別し、特別な意味を運ぶべきではありません。 YANG文とYANG拡張文のみを機械可読データモデリングの特性を伝えるために設計されています。たとえば、オブジェクト「設定」または「状態」を命名、それはコンフィギュレーションデータや状態データであるかどうかを変更しません。のみ定義YANG文またはYANG拡張文はYANGにおける機械可読形式の意味論を割り当てるために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.4. Defaults",
      "section_title": true,
      "ja": "4.4. デフォルト"
    },
    {
      "indent": 3,
      "text": "In general, it is suggested that substatements containing very common default values SHOULD NOT be present. The following substatements are commonly used with the default value, which would make the module difficult to read if used everywhere they are allowed.",
      "ja": "一般的に、非常に一般的なデフォルト値を含むサブステートメントが存在すべきではないことが示唆されます。次のサブステートメントは、一般的にどこでも使用それらが許可されている場合は読みモジュールが困難になり、デフォルト値、で使用されています。"
    },
    {
      "indent": 21,
      "text": "+--------------+---------------+\n| Statement    | Default Value |\n+--------------+---------------+\n| config       | true          |\n| mandatory    | false         |\n| max-elements | unbounded     |\n| min-elements | 0             |\n| ordered-by   | system        |\n| status       | current       |\n| yin-element  | false         |\n+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Statement Defaults",
      "ja": "ステートメントのデフォルト"
    },
    {
      "indent": 0,
      "text": "4.5. Conditional Statements",
      "section_title": true,
      "ja": "4.5. 条件文"
    },
    {
      "indent": 3,
      "text": "A module may be conceptually partitioned in several ways, using the \"if-feature\" and/or \"when\" statements.",
      "ja": "モジュールは、概念的に、「IF-機能」および/または「」ステートメントを使用して、いくつかの方法で分割することができます。"
    },
    {
      "indent": 3,
      "text": "Data model designers need to carefully consider all modularity aspects, including the use of YANG conditional statements.",
      "ja": "データモデル設計者は慎重YANG条件文の使用を含め、すべてのモジュール性の側面を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a data definition is optional, depending on server support for a NETCONF or RESTCONF protocol capability, then a YANG \"feature\" statement SHOULD be defined. The defined \"feature\" statement SHOULD then be used in the conditional \"if-feature\" statement referencing the optional data definition.",
      "ja": "データ定義は、NETCONFまたはRESTCONFプロトコル機能のためのサーバーのサポートに応じて、オプションである場合には、YANG「機能」文が定義されなければなりません。定義された「機能」の文は、オプションのデータ定義を参照する条件付き「であれば、機能」文で使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If any notification data, or any data definition, for a non-configuration data node is not mandatory, then the server may or may not be required to return an instance of this data node. If any conditional requirements exist for returning the data node in a notification payload or retrieval request, they MUST be documented somewhere. For example, a \"when\" or \"if-feature\" statement could apply to the data node, or the conditional requirements could be explained in a \"description\" statement within the data node or one of its ancestors (if any).",
      "ja": "非コンフィギュレーション・データ・ノードのための任意の通知データ、又は任意のデータ定義は、必須ではない場合、サーバは、又はこのデータノードのインスタンスを戻すために必要とされなくてもよいです。いずれかの条件の要件は、通知ペイロードまたは検索要求のデータノードを返すために存在する場合、それらはどこかに文書化されなければなりません。例えば、「場合」または「IF-機能」ステートメントは、データ・ノードに適用することができ、又は条件付きの要件は、データ・ノードまたはその祖先（もしあれば）の1つに「説明」の文で説明することができます。"
    },
    {
      "indent": 3,
      "text": "If any \"if-feature\" statements apply to a list node, then the same \"if-feature\" statements MUST apply to any key leaf nodes for the list. There MUST NOT be any \"if-feature\" statements applied to any key leafs that do not also apply to the parent list node.",
      "ja": "任意の「IF-機能」の文は、リストのノードに適用する場合は、同じ「IF-機能」の文は、リストのための任意のキーリーフノードに適用する必要があります。また、親リストノードには適用されません任意のキーのリーフに適用される「IF-機能」の文があってはなりません。"
    },
    {
      "indent": 3,
      "text": "There SHOULD NOT be any \"when\" statements applied to a key leaf node. It is possible that a \"when\" statement for an ancestor node of a key leaf will have the exact node-set result as the key leaf. In such a case, the \"when\" statement for the key leaf is redundant and SHOULD be avoided.",
      "ja": "キーリーフノードに適用される任意の「とき」のステートメントがあってはなりません。キーのリーフの祖先ノードのための「とき」の文は、キーの葉のように正確なノードセットの結果を持っている可能性があります。そのような場合には、キーの葉のための「とき」文は冗長であり、避けるべきです。"
    },
    {
      "indent": 0,
      "text": "4.6. XPath Usage",
      "section_title": true,
      "ja": "4.6.  XPathの使い方"
    },
    {
      "indent": 3,
      "text": "This section describes guidelines for using the XML Path Language (XPath) [W3C.REC-xpath] within YANG modules.",
      "ja": "このセクションでは、YANGモジュール内のXMLパス言語（XPath）[W3C.REC-のXPath]を使用するためのガイドラインを記載しています。"
    },
    {
      "indent": 0,
      "text": "4.6.1. XPath Evaluation Contexts",
      "section_title": true,
      "ja": "4.6.1.  XPathの評価コンテキスト"
    },
    {
      "indent": 3,
      "text": "YANG defines five separate contexts for evaluation of XPath statements:",
      "ja": "YANGは、XPathステートメントの評価のための5つの別々のコンテキストを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The \"running\" datastore: collection of all YANG configuration data nodes. The document root is the conceptual container (e.g., \"config\" in the \"edit-config\" operation), which is the parent of all top-level data definition statements with a \"config\" statement value of \"true\".",
      "ja": "1.「実行中」のデータストア：すべてのYANG構成データノードのコレクション。ドキュメントルートは、概念容器（例えば、「編集設定」操作で「設定」）「真」の「設定」の文の値を持つすべてのトップレベルのデータ定義文の親です。"
    },
    {
      "indent": 3,
      "text": "2. State data + the \"running\" datastore: collection of all YANG data nodes. The document root is the conceptual container, parent of all top-level data definition statements.",
      "ja": "2.状態データ+「実行中」のデータストア：すべてのYANGデータノードのコレクション。ドキュメントルートは、概念、コンテナ、すべてのトップレベルのデータ定義文の親です。"
    },
    {
      "indent": 3,
      "text": "3. Notification: an event notification document. The document root is the notification element.",
      "ja": "3.通知：イベント通知文書。ドキュメントルートは、通知要素です。"
    },
    {
      "indent": 3,
      "text": "4. RPC Input: The document root is the conceptual \"input\" node, which is the parent of all RPC input parameter definitions.",
      "ja": "4. RPC入力：ドキュメントのルートは、すべてのRPC入力パラメータ定義の親である概念「入力」ノード、です。"
    },
    {
      "indent": 3,
      "text": "5. RPC Output: The document root is the conceptual \"output\" node, which is the parent of all RPC output parameter definitions.",
      "ja": "5. RPC出力：ドキュメントルートは、すべてのRPC出力パラメータ定義の親である概念的な「出力」ノード、です。"
    },
    {
      "indent": 3,
      "text": "Note that these XPath contexts cannot be mixed. For example, a \"when\" statement in a notification context cannot reference configuration data.",
      "ja": "これらのXPathコンテキストは混在できないことに注意してください。例えば、通知文脈での「とき」の文は、コンフィギュレーション・データを参照することはできません。"
    },
    {
      "indent": 7,
      "text": "notification foo {\n  leaf mtu {\n    // NOT okay because when-stmt context is this notification\n    when \"/if:interfaces/if:interface[name='eth0']\";\n    type leafref {\n      // Okay because path-stmt has a different context\n      path \"/if:interfaces/if:interface/if:mtu\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is especially important to consider the XPath evaluation context for XPath expressions defined in groupings. An XPath expression defined in a grouping may not be portable, meaning it cannot be used in multiple contexts and produce proper results.",
      "ja": "グループで定義されたXPath式のXPath評価コンテキストを考慮することが特に重要です。グループで定義されたXPath式は、それが複数のコンテキストで使用され、適切な結果を生成することができないという意味、ポータブルではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the XPath expressions defined in a grouping are intended for a particular context, then this context SHOULD be identified in the \"description\" statement for the grouping.",
      "ja": "グループで定義されたXPath式は、特定のコンテキストのために意図されている場合は、この文脈では、グループ化のための「説明」文で特定されるべきです。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Function Library",
      "section_title": true,
      "ja": "4.6.2. 関数ライブラリ"
    },
    {
      "indent": 3,
      "text": "The \"position\" and \"last\" functions SHOULD NOT be used. This applies to implicit use of the \"position\" function as well (e.g., '//chapter[42]'). A server is only required to maintain the relative XML document order of all instances of a particular user-ordered list or leaf-list. The \"position\" and \"last\" functions MAY be used if they are evaluated in a context where the context node is a user-ordered \"list\" or \"leaf-list\".",
      "ja": "「位置」と「最後」の機能を使用しないでください。これは、暗黙の「位置」機能の使用も（例えば、「//章[42]」）に適用されます。サーバーは、特定のユーザのみ、順序付けられたリストまたはリーフ・リストのすべてのインスタンスの相対的なXMLドキュメントの順序を維持するために必要とされます。彼らは、コンテキストノードがユーザー順序付け「リスト」や「リーフリスト」であるコンテキストで評価されている場合は、「位置」と「最後」の機能を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"id\" function SHOULD NOT be used. The \"ID\" attribute is not present in YANG documents, so this function has no meaning. The YANG compiler SHOULD return an empty string for this function.",
      "ja": "「ID」機能を使用するべきではありません。 「ID」属性は、YANG文書に存在しないので、この機能は意味を持ちません。 YANGコンパイラは、この機能のために空の文字列を返すべきです。"
    },
    {
      "indent": 3,
      "text": "The \"namespace-uri\" and \"name\" functions SHOULD NOT be used. Expanded names in XPath are different than YANG. A specific canonical representation of a YANG-expanded name does not exist.",
      "ja": "「名前空間-URI」と「名前」の機能を使用しないでください。 XPathの中に拡張名がYANGとは異なります。 YANG-拡張名の特定の標準的な表現は存在しません。"
    },
    {
      "indent": 3,
      "text": "The \"lang\" function SHOULD NOT be used. This function does not apply to YANG because there is no \"lang\" attribute set with the document. The YANG compiler SHOULD return 'false' for this function.",
      "ja": "「LANG」機能は使用されるべきではありません。文書で設定しない「LANG」属性が存在しないため、この機能は、YANGには適用されません。 YANGコンパイラは、この機能のために「false」に返すべきです。"
    },
    {
      "indent": 3,
      "text": "The \"local-name\", \"namespace-uri\", \"name\", \"string\", and \"number\" functions SHOULD NOT be used if the argument is a node-set. If so, the function result will be determined by the document order of the node-set. Since this order can be different on each server, the function results can also be different. Any function call that implicitly converts a node-set to a string will also have this issue.",
      "ja": "引数がノードセットである場合、「ローカル名」、「名前空間-URI」、「名前」、「文字列」、および「数」の機能を使用しないでください。もしそうであれば、関数の結果は、ノード集合の文書の順序によって決定されるであろう。この順序は、各サーバー上で異なる可能性があるので、関数の結果も異なっていてもよいです。暗黙的にノードセットの文字列に変換し、任意の関数呼び出しにも、この問題を持っています。"
    },
    {
      "indent": 3,
      "text": "The \"local-name\" function SHOULD NOT be used to reference local names outside of the YANG module that defines the must or when expression containing the \"local-name\" function. Example of a \"local-name\" function that should not be used:",
      "ja": "「ローカル名」機能がないと、ときを定義YANGモジュールの外部ローカル名を参照するために用いるべきではない「ローカル名」関数を含む式。使用すべきではない「ローカル名」機能の例："
    },
    {
      "indent": 6,
      "text": "/*[local-name()='foo']",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"derived-from-or-self\" function SHOULD be used instead of an equality expression for identityref values. This allows the identities to be conceptually augmented.",
      "ja": "「派生から、または自己」機能代わりidentityref値の等価表現の使用されるべきです。これは、アイデンティティが概念的に増大させることができるようになります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "// do not use when \"md-name-format = 'name-format-null'\";",
      "ja": "//使用していないとき、「MD-名フォーマット= 『名前フォーマットヌル』」。"
    },
    {
      "indent": 6,
      "text": "// this is preferred when \"derived-from-or-self(md-name-format, 'name-format-null')\";",
      "ja": "//これが好ましい場合「由来-または自己から（MD-名フォーマット、 『名前フォーマットヌル』）」。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Axes",
      "section_title": true,
      "ja": "4.6.3. 軸"
    },
    {
      "indent": 3,
      "text": "The \"attribute\" and \"namespace\" axes are not supported in YANG and MAY be empty in a NETCONF or RESTCONF server implementation.",
      "ja": "「属性」と「名前空間」の軸はYANGでサポートされていないため、NETCONFまたはRESTCONFサーバー実装で空になることがあります。"
    },
    {
      "indent": 3,
      "text": "The \"preceding\" and \"following\" axes SHOULD NOT be used. These constructs rely on XML document order within a NETCONF or RESTCONF server configuration database, which may not be supported consistently or produce reliable results across implementations. Predicate expressions based on static node properties (e.g., element name or value, and \"ancestor\" or \"descendant\" axes) SHOULD be used instead. The \"preceding\" and \"following\" axes MAY be used if document order is not relevant to the outcome of the expression (e.g., check for global uniqueness of a parameter value).",
      "ja": "「直前」と「次」の軸を使用しないでください。これらの構築物は、一貫してサポートまたは実装間で信頼性のある結果を生成しなくてもよいNETCONF又はRESTCONFサーバー構成データベース内のXML文書の順序に依存しています。静的ノードの特性（例えば、要素名または値、および「祖先」または「子孫」軸）に基づく述語表現が代わりに使用されるべきです。ドキュメントの順序は、式の結果に関連しない場合、「先行」及び「以下」の軸（例えば、パラメータ値のグローバル一意性をチェックする）を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"preceding-sibling\" and \"following-sibling\" axes SHOULD NOT be used; however, they MAY be used if document order is not relevant to the outcome of the expression.",
      "ja": "「先行兄弟」と「次の-兄弟」軸が使用されるべきではありません。文書の順序は、式の結果に関連していない場合しかし、彼らが使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "A server is only required to maintain the relative XML document order of all instances of a particular user-ordered list or leaf-list. The \"preceding-sibling\" and \"following-sibling\" axes MAY be used if they are evaluated in a context where the context node is a user-ordered \"list\" or \"leaf-list\".",
      "ja": "サーバーは、特定のユーザのみ、順序付けられたリストまたはリーフ・リストのすべてのインスタンスの相対的なXMLドキュメントの順序を維持するために必要とされます。 「先行兄弟」と「次の-兄弟」は、それらがコンテキストノードがユーザ順序付け「リスト」または「リーフ・リスト」であるコンテキストで評価される場合に使用されるかもしれ軸。"
    },
    {
      "indent": 0,
      "text": "4.6.4. Types",
      "section_title": true,
      "ja": "4.6.4. タイプ"
    },
    {
      "indent": 3,
      "text": "Data nodes that use the \"int64\" and \"uint64\" built-in type SHOULD NOT be used within numeric or boolean expressions. There are boundary conditions in which the translation from the YANG 64-bit type to an XPath number can cause incorrect results. Specifically, an XPath \"double\" precision floating-point number cannot represent very large positive or negative 64-bit numbers because it only provides a total precision of 53 bits. The \"int64\" and \"uint64\" data types MAY be used in numeric expressions if the value can be represented with no more than 53 bits of precision.",
      "ja": "ビルトインタイプ「Int64型」と「uint64型」を使用したデータ・ノードは、数値またはブール式の中で使用されるべきではありません。 YANG 64ビット型からXPathの番号への翻訳が間違った結果を引き起こすことが可能な境界条件があります。それが唯一の53ビットの合計精度を提供するため、具体的には、XPathの「二重」精度浮動小数点数は、非常に大きな正または負の64ビット数を表すことができません。値は精度を超えない53ビットで表現できる場合、「Int64型」および「UINT64」データ・タイプは数値式に使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Data modelers need to be careful not to confuse the YANG value space and the XPath value space. The data types are not the same in both, and conversion between YANG and XPath data types SHOULD be considered carefully.",
      "ja": "データモデラーはYANGの値空間とXPath値空間を混同しないように注意する必要があります。データタイプは、両方で同じではない、とYANGおよびXPathのデータ型の間の変換を慎重に考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Explicit XPath data type conversions MAY be used (e.g., \"string\", \"boolean\", or \"number\" functions), instead of implicit XPath data type conversions.",
      "ja": "明示的なXPathデータ型変換を使用することができる（例えば、「文字列」、「ブール」、または「数」機能）、代わりに暗黙のXPathデータ型変換。"
    },
    {
      "indent": 3,
      "text": "XPath expressions that contain a literal value representing a YANG identity SHOULD always include the declared prefix of the module where the identity is defined.",
      "ja": "YANGのアイデンティティを表すリテラル値が含まれているXPath式は常にアイデンティティが定義されているモジュールの宣言接頭辞を含むべきです。"
    },
    {
      "indent": 3,
      "text": "XPath expressions for \"when\" statements SHOULD NOT reference the context node or any descendant nodes of the context node. They MAY reference descendant nodes if the \"when\" statement is contained within an \"augment\" statement, and the referenced nodes are not defined within the \"augment\" statement.",
      "ja": "以下のためのXPath式「と、」文がコンテキストノードまたはコンテキストノードの子孫ノードを参照すべきではありません。 「いつ」ステートメントがステートメント「増強」内に含まれ、そして参照ノードは文を「増強」内に定義されていない場合、それらは子孫ノードを参照することができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "augment \"/rt:active-route/rt:input/rt:destination-address\" { when \"rt:address-family='v4ur:ipv4-unicast'\" { description \"This augment is valid only for IPv4 unicast.\"; } // nodes defined here within the augment-stmt // cannot be referenced in the when-stmt }",
      "ja": "{「RT：アドレスファミリ= 『v4ur：IPv4のユニキャスト』」「：アクティブルート/ RT：入力/ RT宛先アドレス/ RTを」増強{説明は「この増強は、IPv4のみのユニキャストに対して有効です」。 } //ノード}とき-STMTで参照することができない//増強-STMT内ここで定義され"
    },
    {
      "indent": 0,
      "text": "4.6.5. Wildcards",
      "section_title": true,
      "ja": "4.6.5. ワイルドカード"
    },
    {
      "indent": 3,
      "text": "It is possible to construct XPath expressions that will evaluate differently when combined with several modules within a server implementation rather than when evaluated within the single module. This is due to augmenting nodes from other modules.",
      "ja": "むしろ、単一のモジュール内で評価する場合よりも、サーバーの実装内の複数のモジュールと組み合わせると違っ評価するXPath式を構築することが可能です。これは、他のモジュールからノードを増強によるものです。"
    },
    {
      "indent": 3,
      "text": "Wildcard expansion is done within a server against all the nodes from all namespaces, so it is possible for a \"must\" or \"when\" expression that uses the '*' operator to always evaluate to false if processed within a single YANG module. In such cases, the \"description\" statement SHOULD clarify that augmenting objects are expected to match the wildcard expansion.",
      "ja": "ワイルドカードの展開は、すべての名前空間からのすべてのノードに対して、サーバー内で行われるので、単一YANGモジュール内で処理された場合は常にfalseと評価する「*」演算子を使用しています「しなければならない」または「とき」の表現が可能です。このような場合には、「説明」の文は増大オブジェクトは、ワイルドカードの展開と一致することが期待されていることを明確にすべき。"
    },
    {
      "indent": 6,
      "text": "when /foo/services/*/active {\n  description\n    \"No services directly defined in this module.\n     Matches objects that have augmented the services container.\";\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.6. Boolean Expressions",
      "section_title": true,
      "ja": "4.6.6. ブール式"
    },
    {
      "indent": 3,
      "text": "The YANG \"must\" and \"when\" statements use an XPath boolean expression to define the test condition for the statement. It is important to specify these expressions in a way that will not cause inadvertent changes in the result if the objects referenced in the expression are updated in future revisions of the module.",
      "ja": "YANG「必須」と「とき」の文は文のテスト条件を定義するためのXPathブール式を使用します。式の中で参照されるオブジェクトは、モジュールの将来の改訂で更新された場合、結果における不注意による変化を生じさせないような方法でこれらの式を指定することが重要です。"
    },
    {
      "indent": 3,
      "text": "For example, the leaf \"foo2\" must exist if the leaf \"foo1\" is equal to \"one\" or \"three\":",
      "ja": "リーフ「foo1の」は「1」または「3」に等しい場合、例えば、葉「foo2は」が存在しなければなりません。"
    },
    {
      "indent": 8,
      "text": "leaf foo1 {\n  type enumeration {\n     enum one;\n     enum two;\n     enum three;\n  }\n}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "leaf foo2 {\n  // INCORRECT\n  must \"/f:foo1 != 'two'\";\n  type string;\n} leaf foo2 {\n  // CORRECT\n  must \"/f:foo1 = 'one' or /f:foo1 = 'three'\";\n  type string;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the next revision of the module, leaf \"foo1\" is extended with a new enum named \"four\":",
      "ja": "モジュールの次のリビジョンでは、葉「foo1のは、」「4」という名前の新しい列挙型で拡張されています。"
    },
    {
      "indent": 8,
      "text": "leaf foo1 {\n  type enumeration {\n     enum one;\n     enum two;\n     enum three;\n     enum four;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Now the first XPath expression will allow the enum \"four\" to be accepted in addition to the \"one\" and \"three\" enum values.",
      "ja": "今最初のXPath式は、列挙型、「4」は「1」と「3」のenum値に加えて受け入れられるようになります。"
    },
    {
      "indent": 0,
      "text": "4.7. YANG Definition Lifecycle Management",
      "section_title": true,
      "ja": "4.7.  YANG定義ライフサイクル管理"
    },
    {
      "indent": 3,
      "text": "The YANG status statement MUST be present within a definition if its value is \"deprecated\" or \"obsolete\". The status SHOULD NOT be changed from \"current\" directly to \"obsolete\". An object SHOULD be available for at least one year with a \"deprecated\" status before it is changed to \"obsolete\".",
      "ja": "その値が「非推奨」または「時代遅れ」であればYANG状態ステートメントは、定義内に存在しなければなりません。ステータスが「時代遅れ」に「現在」から直接変更すべきではありません。それは「時代遅れ」に変更される前に、オブジェクトは、「非推奨」状態で少なくとも1年間利用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "The module or submodule name MUST NOT be changed, once the document containing the module or submodule is published.",
      "ja": "モジュールまたはサブモジュールを含むドキュメントが公開されると、モジュールまたはサブモジュール名は、変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "The module namespace URI value MUST NOT be changed, once the document containing the module is published.",
      "ja": "モジュールを含むドキュメントが公開されると、モジュールの名前空間URI値は、変更しないでください。"
    },
    {
      "indent": 3,
      "text": "The revision date substatement within the import statement SHOULD be present if any groupings are used from the external module.",
      "ja": "いずれかのグループは、外部モジュールから使用されている場合は、インポート文の中で改訂日付サブステートメントが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The revision date substatement within the include statement SHOULD be present if any groupings are used from the external submodule.",
      "ja": "いずれかのグループは、外部のサブモジュールから使用されている場合は、includeステートメント内のリビジョンの日付サブステートメントが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an import statement is for a module from a stable source (e.g., an RFC for an IETF module), then a reference-stmt SHOULD be present within an import statement.",
      "ja": "インポートステートメントは、安定したソースからのモジュールのためのものである場合（例えば、IETF RFCモジ​​ュール用）は、次いで、基準STMTインポートステートメント内に存在しなければなりません。"
    },
    {
      "indent": 8,
      "text": "import ietf-yang-types {\n   prefix yang;\n   reference \"RFC 6991: Common YANG Data Types\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If submodules are used, then the document containing the main module MUST be updated so that the main module revision date is equal to or more recent than the revision date of any submodule that is (directly or indirectly) included by the main module.",
      "ja": "サブモジュールが使用される場合、メインモジュール改訂日が（直接的または間接的に）メインモジュールに含まれる任意のサブモジュールの改訂日付より最近に等しいかそれ以上になるように、メインモジュールを含む文書を更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "Definitions for future use SHOULD NOT be specified in a module. Do not specify placeholder objects like the \"reserved\" example below:",
      "ja": "将来の使用のための定義は、モジュール内で指定してはいけません。以下の「予約済み」の例のようなプレースホルダオブジェクトを指定しないでください。"
    },
    {
      "indent": 7,
      "text": "leaf reserved {\n  type string;\n  description\n    \"This object has no purpose at this time, but a future\n     revision of this module might define a purpose\n     for this object.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.8. Module Header, Meta, and Revision Statements",
      "section_title": true,
      "ja": "4.8. モジュールのヘッダー、メタ、およびリビジョンステートメント"
    },
    {
      "indent": 3,
      "text": "For published modules, the namespace MUST be a globally unique URI, as defined in [RFC3986]. This value is usually assigned by the IANA.",
      "ja": "公表されたモジュールの場合、名前空間は、[RFC3986]で定義されるように、グローバルにユニークなURIでなければなりません。この値は、通常、IANAによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "The \"organization\" statement MUST be present. If the module is contained in a document intended for IETF Standards Track status, then the organization SHOULD be the IETF working group (WG) chartered to write the document. For other standards organizations, a similar approach is also suggested.",
      "ja": "「組織」の文が存在しなければなりません。モジュールは、IETF標準化過程の状態を対象とした文書に含まれている場合、その組織は、文書を書くためにチャーターIETFワーキンググループ（WG）である必要があります。他の標準化団体の場合は、同様のアプローチも提案されています。"
    },
    {
      "indent": 3,
      "text": "The \"contact\" statement MUST be present. If the module is contained in a document intended for Standards Track status, then the WG web and mailing information SHOULD be present, and the main document author or editor contact information SHOULD be present. If additional authors or editors exist, their contact information MAY be present. There is no need to include the contact information for WG Chairs.",
      "ja": "「連絡先」の文が存在しなければなりません。モジュールは標準化過程の状態を対象とした文書に含まれている場合は、WGのウェブおよびメーリングリストの情報が存在する必要があり、メイン文書の著者や編集者の連絡先情報が存在しなければなりません。追加の作家や編集者が存在する場合、その連絡先情報が存在してもよいです。 WGの議長の連絡先情報を含める必要はありません。"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement MUST be present. For modules published within IETF documents, the appropriate IETF Trust Copyright text MUST be present, as described in Section 3.1.",
      "ja": "「説明」の文が存在しなければなりません。 3.1節で説明したようにIETF文書内で公開モジュールの場合、適切なIETFトラスト著作権テキストは、存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the module relies on information contained in other documents, which are not the same documents implied by the import statements present in the module, then these documents MUST be identified in the reference statement.",
      "ja": "モジュールは、モジュール内に存在import文で暗示同じ書類ではありません他の文書に含まれる情報に依存している場合は、これらの文書は、参考書で識別されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A \"revision\" statement MUST be present for each published version of the module. The \"revision\" statement MUST have a \"reference\" substatement. It MUST identify the published document that contains the module. Modules are often extracted from their original documents, and it is useful for developers and operators to know how to find the original source document in a consistent manner. The \"revision\" statement MAY have a \"description\" substatement.",
      "ja": "「改正」の文は、モジュールの各公開バージョンのために存在しなければなりません。 「改正」文は、「参照」サブステートメントを持たなければなりません。これは、モジュールが含まれて公開されたドキュメントを特定しなければなりません。モジュールは、多くの場合、元の文書から抽出され、開発者や事業者が一貫した方法で、元のソースドキュメントを見つける方法を知っておくことは有用です。 「改正」文は、「説明」サブステートメントを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "The following example shows the revision statement for a published YANG module:",
      "ja": "次の例では、公開YANGモジュールの改訂文を示しています。"
    },
    {
      "indent": 6,
      "text": "revision \"2012-02-22\" {\n  description\n    \"Initial version\";\n  reference\n    \"RFC 8341: Network Configuration\n               Access Control Model\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For an unpublished module, a complete history of each unpublished module revision is not required. That is, within a sequence of draft versions, only the most recent revision need be recorded in the module. Do not remove or reuse a revision statement for a published module. A new revision date is not required unless the module contents have changed. If the module contents have changed, then the revision date of that new module version MUST be updated to a date later than that of the previous version.",
      "ja": "未発表のモジュールについては、各未発表モジュール改訂の完全な履歴が必要とされません。これは、ドラフトバージョンの配列内で、唯一の最新のリビジョンは、モジュール内に記録する必要がされています。公表されたモジュールの改訂文を削除するか、再使用しないでください。モジュールの内容が変更されていない限り、新しいリビジョンの日付が必要とされていません。モジュールの内容が変更されている場合は、その新しいモジュールのバージョンの改訂日は、後に、以前のバージョンよりも日に更新されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following example shows the two revision statements for an unpublished update to a published YANG module:",
      "ja": "次の例は、公開されたYANGモジュールに未公開の更新のための2つのリビジョン文を示しています。"
    },
    {
      "indent": 6,
      "text": "revision \"2017-12-11\" {\n  description\n    \"Added support for YANG 1.1 actions and notifications tied to\n     data nodes.  Clarify how NACM extensions can be used by other\n     data models.\";\n  reference\n    \"RFC 8407: Network Configuration Protocol (NETCONF)\n               Access Control Model\";\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "revision \"2012-02-22\" {\n  description\n    \"Initial version\";\n  reference\n    \"RFC 8341: Network Configuration\n               Access Control Model\";\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.9. Namespace Assignments",
      "section_title": true,
      "ja": "4.9. 名前空間の割り当て"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that only valid YANG modules be included in documents, whether or not the modules are published yet. This allows:",
      "ja": "唯一の有効なYANGモジュールは、モジュールがまだ公開されているかどうかにかかわらず、文書に含まれることが推奨されます。これは、ことができます："
    },
    {
      "indent": 3,
      "text": "o the module to compile correctly instead of generating disruptive fatal errors.",
      "ja": "Oモジュールではなく、破壊的な致命的なエラーを生成するので正しくコンパイルします。"
    },
    {
      "indent": 3,
      "text": "o early implementors to use the modules without picking a random value for the XML namespace.",
      "ja": "O初期の実装者は、XML名前空間のランダムな値を選ぶことなく、モジュールを使用します。"
    },
    {
      "indent": 3,
      "text": "o early interoperability testing since independent implementations will use the same XML namespace value.",
      "ja": "Oの独立した実装以来、早期の相互運用性テストは、同じXML名前空間の値を使用します。"
    },
    {
      "indent": 3,
      "text": "Until a URI is assigned by the IANA, a proposed namespace URI MUST be provided for the namespace statement in a YANG module. A value SHOULD be selected that is not likely to collide with other YANG namespaces. Standard module names, prefixes, and URI strings already listed in the \"YANG Module Names\" registry MUST NOT be used.",
      "ja": "URIは、IANAによって割り当てられるまで、提案された名前空間URIは、YANGモジュール内の名前空間のステートメントのために提供されなければなりません。値は、他のYANG名前空間と衝突する可能性がないように選択されるべきです。標準モジュール名、接頭辞、およびすでに「YANGモジュール名」レジストリに記載されたURI文字列を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "A standard namespace statement value SHOULD have the following form:",
      "ja": "標準名前空間のステートメントの値は次の形式を持っている必要があります。"
    },
    {
      "indent": 7,
      "text": "<URN prefix string>:<module-name>",
      "ja": "<URN接頭辞文字列>：<モジュール名>"
    },
    {
      "indent": 3,
      "text": "The following URN prefix string SHOULD be used for published and unpublished YANG modules:",
      "ja": "以下のURN接頭文字列が公開され、公開されていないYANGモジュールを使用する必要があります。"
    },
    {
      "indent": 7,
      "text": "urn:ietf:params:xml:ns:yang:",
      "ja": "URN：IETF：のparams：XML：NS：陽："
    },
    {
      "indent": 3,
      "text": "The following example URNs would be valid namespace statement values for Standards Track modules:",
      "ja": "次の例壺は、標準化過程モジュールの有効な名前空間のステートメントの値のようになります。"
    },
    {
      "indent": 7,
      "text": "urn:ietf:params:xml:ns:yang:ietf-netconf-partial-lock",
      "ja": "URN：IETF：のparams：XML：NS：ヤン：IETF-NETCONF-パーシャル・ロック"
    },
    {
      "indent": 7,
      "text": "urn:ietf:params:xml:ns:yang:ietf-netconf-state",
      "ja": "URN：IETF：のparams：XML：NS：ヤン：IETF-NETCONF状態"
    },
    {
      "indent": 7,
      "text": "urn:ietf:params:xml:ns:yang:ietf-netconf",
      "ja": "URN：IETF：のparams：XML：NS：ヤン：IETF-NETCONF"
    },
    {
      "indent": 3,
      "text": "Note that a different URN prefix string SHOULD be used for modules that are not Standards Track. The string SHOULD be selected according to the guidelines in [RFC7950].",
      "ja": "別のURN接頭辞文字列が標準化過程ないモジュールを使用する必要があることに注意してください。文字列は、[RFC7950]のガイドラインに従って選択されるべきです。"
    },
    {
      "indent": 3,
      "text": "The following URIs exemplify what might be used by modules that are not Standards Track. Note that the domain \"example.com\" SHOULD be used by example modules in IETF I-Ds. These URIs are not intended to be dereferenced. They are used for module namespace identification only.",
      "ja": "以下のURIは標準化過程ないモジュールによって使用される可能性のあるものを例示しています。ドメインが「example.com」IETF I-DSの例モジュールによって使用されるべきであることに注意してください。これらのURIを逆参照することを意図していません。彼らは唯一のモジュールの名前空間の識別に使用されています。"
    },
    {
      "indent": 3,
      "text": "Example URIs using URLs per [RFC3986]:",
      "ja": "[RFC3986]あたりのURLを使用して、実施例のURI："
    },
    {
      "indent": 7,
      "text": "https://example.com/ns/example-interfaces",
      "ja": "ｈっｔｐｓ：／／えぁｍｐぇ。こｍ／んｓ／えぁｍｐぇーいんてｒふぁせｓ"
    },
    {
      "indent": 7,
      "text": "https://example.com/ns/example-system",
      "ja": "ｈっｔｐｓ：／／えぁｍｐぇ。こｍ／んｓ／えぁｍｐぇーｓｙｓてｍ"
    },
    {
      "indent": 3,
      "text": "Example URIs using tags per [RFC4151]:",
      "ja": "[RFC4151]あたりタグを用いて、実施例のURI："
    },
    {
      "indent": 7,
      "text": "tag:example.com,2017:example-interfaces",
      "ja": "タグ：example.com、2017：例えば、インターフェイス"
    },
    {
      "indent": 7,
      "text": "tag:example.com,2017:example-system",
      "ja": "タグ：example.com、2017：例えばシステム"
    },
    {
      "indent": 0,
      "text": "4.10. Top-Level Data Definitions",
      "section_title": true,
      "ja": "4.10. トップレベルのデータ定義"
    },
    {
      "indent": 3,
      "text": "The top-level data organization SHOULD be considered carefully, in advance. Data model designers need to consider how the functionality for a given protocol or protocol family will grow over time.",
      "ja": "トップレベルのデータ編成は、事前に、慎重に検討すべきです。データモデルの設計者は、与えられたプロトコルまたはプロトコルファミリ用の機能は、時間をかけて成長する方法を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "The separation of configuration data and operational state SHOULD be considered carefully. It is sometimes useful to define separate top-level containers for configuration and non-configuration data. For some existing top-level data nodes, configuration data was not in scope, so only one container representing operational state was created. Refer to NMDA [RFC8342] for details.",
      "ja": "構成データおよび動作状態の分離は、慎重に検討する必要があります。コンフィギュレーションおよび非コンフィギュレーションデータのための別個のトップレベルコンテナを定義すると便利な場合があります。いくつかの既存のトップレベル・データ・ノードに対して、構成データはそう動作状態を表す唯一のコンテナが作成された、スコープ内ではありませんでした。詳細については、NMDA [RFC8342]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The number of top-level data nodes within a module SHOULD be minimized. It is often useful to retrieve related information within a single subtree. If data is too distributed, it becomes difficult to retrieve all at once.",
      "ja": "モジュール内の最上位のデータノードの数が最小化されるべきです。単一のサブツリー内の関連情報を取得することが有用であることが多いです。データがあまりにも分散されている場合、それはすべてを一度に取得することが困難になります。"
    },
    {
      "indent": 3,
      "text": "The names and data organization SHOULD reflect persistent information, such as the name of a protocol. The name of the working group SHOULD NOT be used because this may change over time.",
      "ja": "名前とデータ編成は、そのようなプロトコルの名前として、永続的な情報を反映する必要があります。これは時間の経過とともに変化する可能性があるため、ワーキンググループの名前を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "A mandatory database data definition is defined as a node that a client must provide for the database to be valid. The server is not required to provide a value.",
      "ja": "必須データベースのデータ定義は、データベースが有効であるためには、クライアントが提供しなければならないノードとして定義されます。サーバーは、値を提供する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Top-level database data definitions MUST NOT be mandatory. If a mandatory node appears at the top level, it will immediately cause the database to be invalid. This can occur when the server boots or when a module is loaded dynamically at runtime.",
      "ja": "トップレベルのデータベースのデータ定義が必須にすることはできません。必須ノードがトップレベルに表示された場合は、すぐにデータベースは無効となります。ときに、サーバの起動またはモジュールは、実行時に動的にロードされたときに発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.11. Data Types",
      "section_title": true,
      "ja": "4.11. データの種類"
    },
    {
      "indent": 3,
      "text": "Selection of an appropriate data type (i.e., built-in type, existing derived type, or new derived type) is very subjective; therefore, few requirements can be specified on that subject.",
      "ja": "適切なデータ・タイプの選択（すなわち、内蔵型、派生タイプ、又は新しい派生型を既存の）非常に主観的です。そのため、いくつかの要件は、その被写体に指定することができます。"
    },
    {
      "indent": 3,
      "text": "Data model designers SHOULD use the most appropriate built-in data type for the particular application.",
      "ja": "データモデルの設計者は、特定のアプリケーションのための最も適切なビルトインデータ型を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The signed numeric data types (i.e., \"int8\", \"int16\", \"int32\", and \"int64\") SHOULD NOT be used unless negative values are allowed for the desired semantics.",
      "ja": "署名された数値データ型（すなわち、「INT8」、「INT16」、「INT32」、及び「Int64型」）は負の値を所望のセマンティクスのために許可されていない限り、使用されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "4.11.1. Fixed-Value Extensibility",
      "section_title": true,
      "ja": "4.11.1. 固定値の拡張性"
    },
    {
      "indent": 3,
      "text": "If the set of values is fixed and the data type contents are controlled by a single naming authority, then an enumeration data type SHOULD be used.",
      "ja": "値のセットが固定され、データ型コンテンツは、単一の命名機関によって制御されている場合、列挙データ型を使用すべきです。"
    },
    {
      "indent": 7,
      "text": "leaf foo {\n  type enumeration {\n    enum one;\n    enum two;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If extensibility of enumerated values is required, then the \"identityref\" data type SHOULD be used instead of an enumeration or other built-in type.",
      "ja": "列挙値の拡張が必要な​​場合は、「identityref」データ型ではなく、内蔵型列挙または他の使用されるべきです。"
    },
    {
      "indent": 7,
      "text": "identity foo-type {\n  description \"Base for the extensible type\";\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "identity one {\n  base f:foo-type;\n}\nidentity two {\n  base f:foo-type;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "leaf foo { type identityref { base f:foo-type; } }",
      "ja": "リーフFOO {型identityref {基地F：FOO型。 }}"
    },
    {
      "indent": 3,
      "text": "Note that any module can declare an identity with base \"foo-type\" that is valid for the \"foo\" leaf. Identityref values are considered to be qualified names.",
      "ja": "任意のモジュールは、「foo」という葉のために有効であるベース「FOO型」とアイデンティティを宣言することに注意してください。 Identityref値は修飾名であると考えられています。"
    },
    {
      "indent": 0,
      "text": "4.11.2. Patterns and Ranges",
      "section_title": true,
      "ja": "4.11.2. パターンと範囲"
    },
    {
      "indent": 3,
      "text": "For string data types, if a machine-readable pattern can be defined for the desired semantics, then one or more pattern statements SHOULD be present. A single-quoted string SHOULD be used to specify the pattern, since a double-quoted string can modify the content. If the patterns used in a type definition have known limitations such as false negative or false positive matches, then these limitations SHOULD be documented within the typedef or data definition.",
      "ja": "機械可読パターンが所望のセマンティクスのために定義することができる場合は、文字列データ型のために、1つの以上のパターン文が存在しなければなりません。二重引用符で囲まれた文字列は、内容を変更することができるため、単一引用符で囲まれた文字列は、パターンを指定するために使用されるべきです。型定義に使用されるパターンは、偽陰性または偽陽性マッチとしての限界を知っている場合、これらの制限は、のtypedefまたはデータ定義内に文書化されるべきです。"
    },
    {
      "indent": 3,
      "text": "The following typedef from [RFC6991] demonstrates the proper use of the \"pattern\" statement:",
      "ja": "[RFC6991]から以下のtypedefは、「パターン」の文の適切な使用を示しています。"
    },
    {
      "indent": 7,
      "text": "typedef ipv4-address-no-zone {\n  type inet:ipv4-address {\n    pattern '[0-9\\.]*';\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For string data types, if the length of the string is required to be bounded in all implementations, then a length statement MUST be present.",
      "ja": "文字列の長さがすべての実装に囲まする必要がある場合は文字列データ型の場合は、その後、長さステートメントが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following typedef from [RFC6991] demonstrates the proper use of the \"length\" statement:",
      "ja": "[RFC6991]から以下のtypedefは、「長さ」の文の適切な使用を示しています。"
    },
    {
      "indent": 7,
      "text": "typedef yang-identifier {\n  type string {\n    length \"1..max\";\n    pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';\n    pattern '.|..|[^xX].*|.[^mM].*|..[^lL].*';\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For numeric data types, if the values allowed by the intended semantics are different than those allowed by the unbounded intrinsic data type (e.g., \"int32\"), then a range statement SHOULD be present.",
      "ja": "意図セマンティクスによって許可された値は、無限組み込みデータ型（例えば、「INT32」）によって許可されたものとは異なる場合、数値データ・タイプの場合、その後範囲文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following typedef from [RFC6991] demonstrates the proper use of the \"range\" statement:",
      "ja": "[RFC6991]から以下のtypedefは、「範囲」の文の適切な使用を示しています。"
    },
    {
      "indent": 7,
      "text": "typedef dscp {\n  type uint8 {\n     range \"0..63\";\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.11.3. Enumerations and Bits",
      "section_title": true,
      "ja": "4.11.3. 列挙型とビット"
    },
    {
      "indent": 3,
      "text": "For \"enumeration\" or \"bits\" data types, the semantics for each \"enum\" or \"bit\" SHOULD be documented. A separate \"description\" statement (within each \"enum\" or \"bit\" statement) SHOULD be present.",
      "ja": "「列挙」または「ビット」のデータタイプのために、各「列挙」または「ビット」の意味は、文書化されるべきです。 （各「列挙」または「ビット」ステートメント内の）別個の「説明」の文では存在すべきです。"
    },
    {
      "indent": 7,
      "text": "leaf foo {\n  // INCORRECT\n  type enumeration {\n    enum one;\n    enum two;\n  }\n  description\n    \"The foo enum...\n     one: The first enum\n     two: The second enum\";\n} leaf foo {\n  // CORRECT\n  type enumeration {\n    enum one {\n      description \"The first enum\";\n    }\n    enum two {\n      description \"The second enum\";\n    }\n  }\n  description\n    \"The foo enum...  \";\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.11.4. Union Types",
      "section_title": true,
      "ja": "4.11.4. ユニオンタイプ"
    },
    {
      "indent": 3,
      "text": "The YANG \"union\" type is evaluated by testing a value against each member type in the union. The first type definition that accepts a value as valid is the member type used. In general, member types SHOULD be ordered from most restrictive to least restrictive types.",
      "ja": "YANG「ユニオン」タイプは、組合の各メンバタイプに対する値を試験することによって評価されます。値が有効なものとして受け入れる第一のタイプの定義が使用される部材の種類です。一般的には、メンバーの種類は、最も制限のタイプに最も制限から発注する必要があり。"
    },
    {
      "indent": 3,
      "text": "In the following example, the \"enumeration\" type will never be matched because the preceding \"string\" type will match everything.",
      "ja": "前述の「文字列」タイプはすべてを一致するため、次の例では、「列挙」型が一致することはありません。"
    },
    {
      "indent": 3,
      "text": "Incorrect:",
      "ja": "誤："
    },
    {
      "indent": 6,
      "text": "type union {\n  type string;\n  type enumeration {\n    enum up;\n    enum down;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Correct:",
      "ja": "正しい："
    },
    {
      "indent": 6,
      "text": "type union {\n  type enumeration {\n    enum up;\n    enum down;\n  }\n  type string;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is possible for different member types to match, depending on the input encoding format. In XML, all values are passed as string nodes; but in JSON, there are different value types for numbers, booleans, and strings.",
      "ja": "異なるメンバー型が一致することは、入力された符号化形式に応じて、可能です。 XMLでは、すべての値が文字列ノードとして渡されます。しかし、JSONに、数値、ブール値、および文字列の異なる値のタイプがあります。"
    },
    {
      "indent": 3,
      "text": "In the following example, a JSON numeric value will always be matched by the \"int32\" type, but in XML the string value representing a number will be matched by the \"string\" type. The second version will match the \"int32\" member type no matter how the input is encoded.",
      "ja": "次の例では、JSONの数値は常に「int32型」タイプで照合されますが、XMLで数を表す文字列値は、「文字列」タイプでマッチします。第二のバージョンは関係なく、入力のエンコード方法「INT32」メンバーの種類と一致しません。"
    },
    {
      "indent": 3,
      "text": "Incorrect:",
      "ja": "誤："
    },
    {
      "indent": 6,
      "text": "type union {\n  type string;\n  type int32;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Correct:",
      "ja": "正しい："
    },
    {
      "indent": 6,
      "text": "type union {\n  type int32;\n  type string;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.11.5. Empty and Boolean",
      "section_title": true,
      "ja": "4.11.5. 空のブール"
    },
    {
      "indent": 3,
      "text": "YANG provides an \"empty\" data type, which has one value (i.e., present). The default is \"not present\", which is not actually a value. When used within a list key, only one value can (and must) exist for this key leaf. The type \"empty\" SHOULD NOT be used for a key leaf since it is pointless.",
      "ja": "YANGは、一つの値（すなわち、存在）を有する「空」データタイプを提供します。デフォルトでは、実際に値ではありませんこれは、「存在しない」です。リストキー内で使用される場合には、一つの値だけが（としなければならない）、このキーの葉のために存在することができます。 「空」のタイプは、それは無意味であるため、キーの葉には使用しないでください。"
    },
    {
      "indent": 3,
      "text": "There is really no difference between a leaf of type \"empty\" and a leaf-list of type \"empty\". Both are limited to one instance. The type \"empty\" SHOULD NOT be used for a leaf-list.",
      "ja": "タイプ「空」の葉や種の葉のリスト「空」の間に違いは本当にありません。どちらも1つのインスタンスに制限されています。 「空」のタイプは、リーフ・リストには使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The advantage of using type \"empty\" instead of type \"boolean\" is that the default (not present) does not take up any bytes in a representation. The disadvantage is that the client may not be sure if an empty leaf is missing because it was filtered somehow or not implemented. The client may not have a complete and accurate schema for the data returned by the server and may not be aware of the missing leaf.",
      "ja": "タイプ「空」の代わりにタイプの「ブール」を使用することの利点は、デフォルトでは（存在しない）表現で任意のバイトを取らないということです。欠点は、空の葉が欠落している場合、それはどうやらない実装濾過したため、クライアントはわからないかもしれないということです。クライアントは、サーバから返されたデータのための完全かつ正確なスキーマを持たないかもしれないし、不足している葉を認識しないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The YANG \"boolean\" data type provides two values (\"true\" and \"false\"). When used within a list key, two entries can exist for this key leaf. Default values are ignored for key leafs, but a default statement is often used for plain boolean leafs. The advantage of the \"boolean\" type is that the leaf or leaf-list has a clear representation for both values. The default value is usually not returned unless explicitly requested by the client, so no bytes are used in a typical representation.",
      "ja": "YANG「ブール」データ・タイプは、2つの値を提供する（「真」および「偽」）。リストキー内で使用する場合、2つのエントリは、このキーの葉のために存在することができます。デフォルト値は、キーのリーフでは無視されますが、デフォルトの文は、多くの場合、プレーンブールのリーフに使用されます。 「ブール」タイプの利点は、葉または葉-リストは両方の値のための明確な表現を持っていることです。明示的にクライアントによって要求されない限り、デフォルト値は、通常は返されませんので、何のバイトは、一般的な表現で使用されていません。"
    },
    {
      "indent": 3,
      "text": "In general, the \"boolean\" data type SHOULD be used instead of the \"empty\" data type, as shown in the example below:",
      "ja": "以下の例に示すように、一般的に、「ブール」データ・タイプは、代わりに「空の」データ型で使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Incorrect:",
      "ja": "誤："
    },
    {
      "indent": 6,
      "text": "leaf flag1 { type empty; }",
      "ja": "リーフFLAG1 {タイプ空。 }"
    },
    {
      "indent": 3,
      "text": "Correct:",
      "ja": "正しい："
    },
    {
      "indent": 6,
      "text": "leaf flag2 {\n  type boolean;\n  default false;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.12. Reusable Type Definitions",
      "section_title": true,
      "ja": "4.12. 再利用可能な型定義"
    },
    {
      "indent": 3,
      "text": "If an appropriate derived type exists in any standard module, such as [RFC6991], then it SHOULD be used instead of defining a new derived type.",
      "ja": "適切な派生型は、[RFC6991]などの任意の標準モジュールに存在する場合、それは新しい派生型を定義するのではなく、使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "If an appropriate units identifier can be associated with the desired semantics, then a units statement SHOULD be present.",
      "ja": "適切な単位識別子が所望のセマンティクスと関連付けることができる場合には、単位文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an appropriate default value can be associated with the desired semantics, then a default statement SHOULD be present.",
      "ja": "適切なデフォルト値が所望のセマンティクスと関連付けることができる場合は、デフォルトの文は存在すべきです。"
    },
    {
      "indent": 3,
      "text": "If a significant number of derived types are defined, and it is anticipated that these data types will be reused by multiple modules, then these derived types SHOULD be contained in a separate module or submodule, to allow easier reuse without unnecessary coupling.",
      "ja": "派生型のかなりの数が定義され、これらのデータ・タイプは、複数のモジュールによって再利用されることが予想される場合、これらの派生型が不要に結合することなく、容易再利用を可能にするために、別々のモジュールまたはサブモジュールに含まれるべきです。"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement MUST be present.",
      "ja": "「説明」の文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the type definition semantics are defined in an external document (other than another YANG module indicated by an import statement), then the reference statement MUST be present.",
      "ja": "タイプ定義の意味を（import文により示される別のYANGモジュール以外の）外部の文書で定義されている場合、参照文が存在しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.13. Reusable Groupings",
      "section_title": true,
      "ja": "4.13. 再利用可能なグループ化"
    },
    {
      "indent": 3,
      "text": "A reusable grouping is a YANG grouping that can be imported by another module and is intended for use by other modules. This is not the same as a grouping that is used within the module in which it is defined, but it happens to be exportable to another module because it is defined at the top level of the YANG module.",
      "ja": "再利用可能なグループ化は、他のモジュールによってインポートすることができ、他のモジュールによって使用するために意図されYANGグループ化です。これは、それが定義されているモジュール内で使用されているグループと同じではないが、それがYANGモジュールのトップレベルで定義されているため、別のモジュールにエクスポート可能であることを起こります。"
    },
    {
      "indent": 3,
      "text": "The following guidelines apply to reusable groupings, in order to make them as robust as possible:",
      "ja": "次のガイドラインは、可能な限りそれらをほど堅牢にするために、再利用可能なグループに適用されます。"
    },
    {
      "indent": 3,
      "text": "o Clearly identify the purpose of the grouping in the \"description\" statement.",
      "ja": "O明らかに「説明」文でグループ化の目的を特定します。"
    },
    {
      "indent": 3,
      "text": "o There are five different XPath contexts in YANG (rpc/input, rpc/ output, notification, \"config true\" data nodes, and all data nodes). Clearly identify which XPath contexts are applicable or excluded for the grouping.",
      "ja": "O 5つの異なるYANGでXPathコンテキスト（RPC /入力、RPC /出力、通知、「コンフィグ真」データノード、およびすべてのデータノード）が存在します。明らかに該当するか、グループ化のために除外されたXPathのコンテキスト識別します。"
    },
    {
      "indent": 3,
      "text": "o Do not reference data outside the grouping in any \"path\", \"must\", or \"when\" statements.",
      "ja": "O任意の「パス」、「MUST」、または「」文でグループ外のデータを参照しないでください。"
    },
    {
      "indent": 3,
      "text": "o Do not include a \"default\" substatement on a leaf or choice unless the value applies on all possible contexts.",
      "ja": "値はすべての可能なコンテキストに適用されない限り、O、葉や選択肢の「デフォルト」サブステートメントを含めないでください。"
    },
    {
      "indent": 3,
      "text": "o Do not include a \"config\" substatement on a data node unless the value applies on all possible contexts.",
      "ja": "値はすべての可能なコンテキストに適用されない限り、Oデータノードの「設定」サブステートメントを含めないでください。"
    },
    {
      "indent": 3,
      "text": "o Clearly identify any external dependencies in the grouping \"description\" statement, such as nodes referenced by an absolute path from a \"path\", \"must\", or \"when\" statement.",
      "ja": "O明らかに、そのような「パス」、「必須」、又は「an」ステートメントからの絶対パスで参照ノードとしてグルーピング「説明」ステートメントの任意の外部依存関係を識別する。"
    },
    {
      "indent": 0,
      "text": "4.14. Data Definitions",
      "section_title": true,
      "ja": "4.14. データ定義"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement MUST be present in the following YANG statements:",
      "ja": "「説明」文は次のYANG文で存在している必要があります"
    },
    {
      "indent": 3,
      "text": "o anyxml",
      "ja": "AnyXMLでO"
    },
    {
      "indent": 3,
      "text": "o augment",
      "ja": "または増加"
    },
    {
      "indent": 3,
      "text": "o choice",
      "ja": "Oの選択"
    },
    {
      "indent": 3,
      "text": "o container",
      "ja": "Oコンテナ"
    },
    {
      "indent": 3,
      "text": "o extension",
      "ja": "O拡張"
    },
    {
      "indent": 3,
      "text": "o feature",
      "ja": "お ふぇあつれ"
    },
    {
      "indent": 3,
      "text": "o grouping",
      "ja": "Oのグループ化"
    },
    {
      "indent": 3,
      "text": "o identity",
      "ja": "Oアイデンティティ"
    },
    {
      "indent": 3,
      "text": "o leaf",
      "ja": "葉"
    },
    {
      "indent": 3,
      "text": "o leaf-list o list",
      "ja": "リストの葉リスト"
    },
    {
      "indent": 3,
      "text": "o notification",
      "ja": "O通知"
    },
    {
      "indent": 3,
      "text": "o rpc",
      "ja": "O RPC"
    },
    {
      "indent": 3,
      "text": "o typedef",
      "ja": "Oのtypedef"
    },
    {
      "indent": 3,
      "text": "If the data definition semantics are defined in an external document, (other than another YANG module indicated by an import statement), then a reference statement MUST be present.",
      "ja": "データ定義の意味を（import文により示される別のYANGモジュール以外の）外部の文書で定義されている場合、参照文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" construct may be useful to represent an HTML banner containing markup elements, such as \"<b>\" and \"</b>\", and MAY be used in such cases. However, this construct SHOULD NOT be used if other YANG data node types can be used instead to represent the desired syntax and semantics.",
      "ja": "「AnyXMLで」構築物のようなHTMLバナーを含むマークアップ要素を表すために有用であり得る「<B>」と「</ B>」、およびそのような場合に使用することができます。他のYANGデータノードタイプは、所望の構文およびセマンティクスを表現するために代わりに使用することができる場合は、この構築物を使用しないでください。"
    },
    {
      "indent": 3,
      "text": "It has been found that the \"anyxml\" statement is not implemented consistently across all servers. It is possible that mixed-mode XML will not be supported or that configuration anyxml nodes will not supported.",
      "ja": "「AnyXMLで」文は、すべてのサーバー間で一貫して実装されていないことが判明しました。混合モードのXMLがサポートされないか、またはその構成AnyXMLでノードがサポートされない可能性があります。"
    },
    {
      "indent": 3,
      "text": "If there are referential integrity constraints associated with the desired semantics that can be represented with XPath, then one or more \"must\" statements SHOULD be present.",
      "ja": "XPathので表現することができます希望の意味に関連した参照整合性制約がある場合は、1つ以上の文が存在するべきである「必要があります」。"
    },
    {
      "indent": 3,
      "text": "For list and leaf-list data definitions, if the number of possible instances is required to be bounded for all implementations, then the max-elements statements SHOULD be present.",
      "ja": "可能なインスタンスの数は、すべての実装のために境界される必要がある場合は、リストとリーフリストデータ定義については、次に最大要素文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If any \"must\" or \"when\" statements are used within the data definition, then the data definition \"description\" statement SHOULD describe the purpose of each one.",
      "ja": "文がデータ定義内で使用される「とき」いずれか、または、その後、データ定義「の説明」の文は、それぞれの目的を説明すべきである「必要がある」場合。"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement is allowed to be directly present within a \"case\" statement in YANG 1.1. This needs to be considered carefully. Consider simply including the nested \"choice\" as additional \"case\" statements within the parent \"choice\" statement. Note that the \"mandatory\" and \"default\" statements within a nested \"choice\" statement only apply if the \"case\" containing the nested \"choice\" statement is first selected.",
      "ja": "「選択」文はYANG 1.1における「ケース」ステートメント内に直接存在することが許されます。これは、慎重に検討する必要があります。単に親「の選択」ステートメント内の追加「の場合、」ステートメントとして、ネストされた「選択」など、考えてみましょう。ネストされた「選択」の文を含む「ケース」が最初に選択されている場合は、ネストされた「選択」のステートメント内の「必須」と「デフォルト」の文のみ適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a list defines any key leafs, then these leafs SHOULD be defined in order, as the first child nodes within the list. The key leafs MAY be in a different order in some cases, e.g., they are defined in a grouping, and not inline in the list statement.",
      "ja": "リストは任意のキー葉を定義する場合、最初の子リスト内のノードとして、これらのリーフは、順番に定義されるべきです。キー葉は、いくつかのケースでは異なる順序であってもよく、例えば、それらはグループで定義され、リスト文でインラインではありません。"
    },
    {
      "indent": 0,
      "text": "4.14.1. Non-Presence Containers",
      "section_title": true,
      "ja": "4.14.1. 非プレゼンスコンテナ"
    },
    {
      "indent": 3,
      "text": "A non-presence container is used to organize data into specific subtrees. It is not intended to have semantics within the data model beyond this purpose, although YANG allows it (e.g., a \"must\" statement within the non-presence container).",
      "ja": "非存在容器は、特定のサブツリーにデータを整理するために使用されます。 YANGがそれを可能にするが、それは、この目的を超えたデータモデル内の意味を持つように意図されていない（例えば、非存在コンテナ内の「MUST」文）。"
    },
    {
      "indent": 3,
      "text": "Example using container wrappers:",
      "ja": "コンテナラッパーを使用した例："
    },
    {
      "indent": 7,
      "text": "container top {\n   container foos {\n      list foo { ... }\n   }\n   container bars {\n      list bar { ... }\n   }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example without container wrappers:",
      "ja": "コンテナラッパーなし例："
    },
    {
      "indent": 7,
      "text": "container top {\n   list foo { ... }\n   list bar { ... }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Use of non-presence containers to organize data is a subjective matter similar to use of subdirectories in a file system. Although these containers do not have any semantics, they can impact protocol operations for the descendant data nodes within a non-presence container, so use of these containers SHOULD be considered carefully.",
      "ja": "データを整理するための非存在コンテナを使用すると、ファイルシステム内のサブディレクトリの使用に似て主観的な問題です。これらの容器は、いかなる意味を持っていないが、それらは非存在コンテナ内子孫データノードのプロトコル動作に影響を与えることができるので、これらの容器の使用は慎重に考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "The NETCONF and RESTCONF protocols do not currently support the ability to delete all list (or leaf-list) entries at once. This deficiency is sometimes avoided by use of a parent container (i.e., deleting the container also removes all child entries).",
      "ja": "NETCONFとRESTCONFプロトコルは現在、一度にすべてのリスト（またはリーフ・リスト）のエントリを削除する機能をサポートしていません。この欠点は、時には親コンテナ（すなわち、コンテナを削除すると、すべての子エントリを削除します）を使用することによって回避されます。"
    },
    {
      "indent": 0,
      "text": "4.14.2. Top-Level Data Nodes",
      "section_title": true,
      "ja": "4.14.2. トップレベルのデータノード"
    },
    {
      "indent": 3,
      "text": "Use of top-level objects needs to be considered carefully:",
      "ja": "トップレベルのオブジェクトの使用は慎重に検討する必要があります："
    },
    {
      "indent": 3,
      "text": "o top-level siblings are not ordered",
      "ja": "Oトップレベルの兄弟を注文されていません"
    },
    {
      "indent": 3,
      "text": "o top-level siblings are not static and depend on the modules that are loaded",
      "ja": "Oトップレベルの兄弟は静的ではなく、ロードされるモジュールに依存します"
    },
    {
      "indent": 3,
      "text": "o for subtree filtering, retrieval of a top-level leaf-list will be treated as a content-match node for all top-level-siblings",
      "ja": "サブツリー・フィルタリングのためのO、最上位葉リストの検索は、すべてのトップレベルの兄弟のためのコンテンツ一致ノードとして扱われます"
    },
    {
      "indent": 3,
      "text": "o a top-level list with many instances may impact performance",
      "ja": "O多くのインスタンスを持つトップレベルのリストは、パフォーマンスに影響を与える可能性"
    },
    {
      "indent": 0,
      "text": "4.15. Operation Definitions",
      "section_title": true,
      "ja": "4.15. 操作の定義"
    },
    {
      "indent": 3,
      "text": "If the operation semantics are defined in an external document (other than another YANG module indicated by an import statement), then a reference statement MUST be present.",
      "ja": "オペレーションセマンティクスが（import文により示される別のYANGモジュール以外の）外部の文書で定義されている場合、参照文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the operation impacts system behavior in some way, it SHOULD be mentioned in the \"description\" statement.",
      "ja": "何らかの方法で操作の影響システムの動作する場合は、「説明」文で言及されるべきです。"
    },
    {
      "indent": 3,
      "text": "If the operation is potentially harmful to system behavior in some way, it MUST be mentioned in the Security Considerations section of the document.",
      "ja": "操作は、いくつかの方法でシステムの動作に潜在的に有害である場合には、文書のセキュリティについての考慮事項のセクションに記載しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.16. Notification Definitions",
      "section_title": true,
      "ja": "4.16. 通知の定義"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement MUST be present.",
      "ja": "「説明」の文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the notification semantics are defined in an external document (other than another YANG module indicated by an import statement), then a reference statement MUST be present.",
      "ja": "通知セマンティクスが（import文により示される別のYANGモジュール以外の）外部の文書で定義されている場合、参照文が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the notification refers to a specific resource instance, then this instance SHOULD be identified in the notification data. This is usually done by including \"leafref\" leaf nodes with the key leaf values for the resource instance. For example:",
      "ja": "通知は、特定のリソース・インスタンスを参照する場合、このインスタンスは、通知データで特定されるべきです。これは通常、リソースインスタンスのためのキーリーフ値を持つ「leafref」リーフノードを含むことによって行われます。例えば："
    },
    {
      "indent": 5,
      "text": "notification interface-up {\n  description \"Sent when an interface is activated.\";\n  leaf name {\n    type leafref {\n      path \"/if:interfaces/if:interface/if:name\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that there are no formal YANG statements to identify any data node resources associated with a notification. The \"description\" statement for the notification SHOULD specify if and how the notification identifies any data node resources associated with the specific event.",
      "ja": "通知に関連するすべてのデータノードのリソースを識別するための正式なYANG文が存在しないことに注意してください。通知は、特定のイベントに関連するすべてのデータノードのリソースを識別した場合、どのように通知するための「説明」の文は、指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.17. Feature Definitions",
      "section_title": true,
      "ja": "4.17. 機能の定義"
    },
    {
      "indent": 3,
      "text": "The YANG \"feature\" statement is used to define a label for a set of optional functionality within a module. The \"if-feature\" statement is used in the YANG statements associated with a feature. The description-stmt within a feature-stmt MUST specify any interactions with other features.",
      "ja": "YANG「機能」文は、モジュール内のオプション機能のセットのためのラベルを定義するために使用されます。 「IF-機能」文は機能に関連YANG文で使用されています。特徴STMT以内説明-STMTは、他の特徴との任意の相互作用を指定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The set of YANG features defined in a module should be considered carefully. Very fine granular features increase interoperability complexity and should be avoided. A likely misuse of the feature mechanism is the tagging of individual leafs (e.g., counters) with separate features.",
      "ja": "YANGのセットは、慎重に検討する必要があるモジュールで定義されています。非常に微細な粒状の特徴は、相互運用性の複雑さを増し、避けるべきです。機能機構のありそうな誤用は、別個の機能を有する個々のリーフ（例えば、カウンタ）のタグです。"
    },
    {
      "indent": 3,
      "text": "If there is a large set of objects associated with a YANG feature, then consider moving those objects to a separate module, instead of using a YANG feature. Note that the set of features within a module is easily discovered by the reader, but the set of related modules within the entire YANG library is not as easy to identity. Module names with a common prefix can help readers identity the set of related modules, but this assumes the reader will have discovered and installed all the relevant modules.",
      "ja": "YANG機能に関連するオブジェクトの大きなセットがある場合、別のモジュールにこれらのオブジェクトを移動、代わりのYANG機能の使用を検討してください。モジュール内の一連の機能を簡単に読者によって発見されていることに注意してください、しかし全体YANGライブラリ内の関連モジュールのセットは、アイデンティティのように簡単ではありません。共通のプレフィックスを持つモジュール名は、読者のアイデンティティに関連するモジュールのセットを助けることができるが、これは読者が発見しただろうと仮定し、関連するすべてのモジュールがインストールされています。"
    },
    {
      "indent": 3,
      "text": "Another consideration for deciding whether to create a new module or add a YANG feature is the stability of the module in question. It may be desirable to have a stable base module that is not changed frequently. If new functionality is placed in a separate module, then the base module does not need to be republished. If it is designed as a YANG feature, then the module will need to be republished.",
      "ja": "新しいモジュールを作成したり、YANG機能を追加するかどうかを決定するためのもう1つの考慮事項は、問題のモジュールの安定性です。頻繁に変更されていない安定したベースモジュールを有することが望ましいです。新機能は別のモジュールに配置されている場合は、ベースモジュールを再発行する必要はありません。それはYANG機能として設計されている場合、モジュールは再発行する必要があります。"
    },
    {
      "indent": 3,
      "text": "If one feature requires implementation of another feature, then an \"if-feature\" statement SHOULD be used in the dependent \"feature\" statement.",
      "ja": "一つの特徴は、他の機能の実装が必要な場合は、「IF-機能」文は依存「機能」文で使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, feature2 requires implementation of feature1:",
      "ja": "例えば、特長2は特長1の実装が必要です。"
    },
    {
      "indent": 6,
      "text": "feature feature1 { description \"Some protocol feature\"; }",
      "ja": "機能特長1 {説明「いくつかのプロトコル機能」; }"
    },
    {
      "indent": 6,
      "text": "feature feature2 {\n  if-feature \"feature1\";\n  description \"Another protocol feature\";\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.18. YANG Data Node Constraints",
      "section_title": true,
      "ja": "4時18分。 WHOデータノードの制約"
    },
    {
      "indent": 0,
      "text": "4.18.1. Controlling Quantity",
      "section_title": true,
      "ja": "4.18.1. 制御数量"
    },
    {
      "indent": 3,
      "text": "The \"min-elements\" and \"max-elements\" statements can be used to control how many list or leaf-list instances are required for a particular data node. YANG constraint statements SHOULD be used to identify conditions that apply to all implementations of the data model. If platform-specific limitations (e.g., the \"max-elements\" supported for a particular list) are relevant to operations, then a data model definition statement (e.g., \"max-ports\" leaf) SHOULD be used to identify the limit.",
      "ja": "「MIN-要素」と「MAX-要素」文は、多くのリストまたはリーフリストインスタンスが特定のデータノードのために必要とされる方法を制御するために使用することができます。 YANG制約ステートメントは、データ・モデルのすべての実装に適用される条件を同定するために使用されるべきです。プラットフォーム固有の制限（例えば、特定のリストについては、サポートされている「最大要素」）は、業務に関連する場合、データモデル定義文（例えば、「MAX-ポート」葉）が限界を識別するために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "4.18.2. \"must\" versus \"when\"",
      "section_title": true,
      "ja": "4.18.2.  「しなければならない」対「とき」"
    },
    {
      "indent": 3,
      "text": "\"must\" and \"when\" YANG statements are used to provide cross-object referential tests. They have very different behavior. The \"when\" statement causes data node instances to be silently deleted as soon as the condition becomes false. A false \"when\" expression is not considered to be an error.",
      "ja": "そして「いつ」YANG文は、クロスオブジェクト参照のテストを提供するために使用されている「しなければなりません」。彼らは非常に異なる動作を持っています。 「とき」文は黙って、すぐに条件が偽になると、削除するデータノードのインスタンスが発生します。式がエラーと見なされていない「とき」偽。"
    },
    {
      "indent": 3,
      "text": "The \"when\" statement SHOULD be used together with \"augment\" or \"uses\" statements to achieve conditional model composition. The condition SHOULD be based on static properties of the augmented entry (e.g., list key leafs).",
      "ja": "「とき」の文は、条件付きのモデル構成を実現するために、「オーグメント」や「用途」の文と一緒に使用してください。条件は、拡張エントリ（例えば、リストキー葉）の静的プロパティに基づくべきです。"
    },
    {
      "indent": 3,
      "text": "The \"must\" statement causes a datastore validation error if the condition is false. This statement SHOULD be used for enforcing parameter value restrictions that involve more than one data node (e.g., end-time parameter must be after the start-time parameter).",
      "ja": "条件がfalseの場合、「必要」の文は、データストアの検証エラーが発生します。この文は、複数のデータノードを伴うパラメータ値の制限を強制するために使用されるべきである（例えば、終了時パラメータは、開始時のパラメータの後でなければなりません）。"
    },
    {
      "indent": 0,
      "text": "4.19. \"augment\" Statements",
      "section_title": true,
      "ja": "4.19.  「オーグメント」ステートメント"
    },
    {
      "indent": 3,
      "text": "The YANG \"augment\" statement is used to define a set of data definition statements that will be added as child nodes of a target data node. The module namespace for these data nodes will be the augmenting module, not the augmented module.",
      "ja": "YANG「強化」の文は、ターゲット・データ・ノードの子ノードとして追加されるデータ定義文のセットを定義するために使用されます。これらのデータノードのためのモジュールの名前空間は、増強モジュールではなく、拡張モジュールとなります。"
    },
    {
      "indent": 3,
      "text": "A top-level \"augment\" statement SHOULD NOT be used if the target data node is in the same module or submodule as the evaluated \"augment\" statement. The data definition statements SHOULD be added inline instead.",
      "ja": "ターゲット・データ・ノードが評価「増強」文と同じモジュールまたはサブモジュールである場合、最上位「増強」は文を使用しないでください。データ定義文は、代わりにインラインで追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.19.1. Conditional Augment Statements",
      "section_title": true,
      "ja": "4.19.1. 条件付き増補文"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement is often used together with the \"when\" statement and/or \"if-feature\" statement to make the augmentation conditional on some portion of the data model.",
      "ja": "「増やす」の文は、多くの場合、データモデルのいくつかの部分に補強を条件付きにする「とき」の文および/または「IF-機能」の文と一緒に使用されています。"
    },
    {
      "indent": 3,
      "text": "The following example from [RFC7223] shows how a conditional container called \"ethernet\" is added to the \"interface\" list only for entries of the type \"ethernetCsmacd\".",
      "ja": "[RFC7223]から次の例は、「イーサネット」と呼ばれる条件付き容器が唯一のタイプのエントリ「ethernetCsmacd」は「インターフェース」リストに追加する方法を示しています。"
    },
    {
      "indent": 8,
      "text": "augment \"/if:interfaces/if:interface\" {\n    when \"if:type = 'ianaift:ethernetCsmacd'\";",
      "raw": true
    },
    {
      "indent": 8,
      "text": " container ethernet { leaf duplex { ... } } }",
      "ja": "容器イーサネット{葉両面{...}}}"
    },
    {
      "indent": 0,
      "text": "4.19.2. Conditionally Mandatory Data Definition Statements",
      "section_title": true,
      "ja": "4.19.2. 条件付き必須データ定義ステートメント"
    },
    {
      "indent": 3,
      "text": "YANG has very specific rules about how configuration data can be updated in new releases of a module. These rules allow an \"old client\" to continue interoperating with a \"new server\".",
      "ja": "YANGは、構成データがモジュールの新しいリリースで更新することができるかについて非常に特定のルールを持っています。これらのルールは、「古いクライアントは、」「新しいサーバ」との相互運用を続行することができます。"
    },
    {
      "indent": 3,
      "text": "If data nodes are added to an existing entry, the old client MUST NOT be required to provide any mandatory parameters that were not in the original module definition.",
      "ja": "データノードを既存のエントリに追加されている場合は、古いクライアントは元のモジュールの定義ではありませんでしたすべての必須パラメータを提供するために必須ではありません。"
    },
    {
      "indent": 3,
      "text": "It is possible to add conditional \"augment\" statements such that the old client would not know about the new condition and would not specify the new condition. The conditional \"augment\" statement can contain mandatory objects only if the condition is false, unless explicitly requested by the client.",
      "ja": "古いクライアントが新しい状態について知ることはできませんし、新しい条件を指定しないような条件付きの「オーグメント」ステートメントを追加することが可能です。条件付き「オーグメント」のステートメントは、明示的にクライアントから要求されない限り、条件が偽の場合にのみ必須オブジェクトを含めることができます。"
    },
    {
      "indent": 3,
      "text": "Only a conditional \"augment\" statement that uses the \"when\" statement form of a condition can be used in this manner. The YANG features enabled on the server cannot be controlled by the client in any way, so it is not safe to add mandatory augmenting data nodes based on the \"if-feature\" statement.",
      "ja": "唯一の条件は、条件の文の形式は、この方法で使用することができる「と、」使用するステートメントを「増やします」。 YANGは、「IF-機能」声明に基づく義務増強データノードを追加しても安全ではないので、どのような方法で、クライアントによって制御することができない、サーバー上で有効になっています。"
    },
    {
      "indent": 3,
      "text": "The XPath \"when\" statement condition MUST NOT reference data outside of the target data node because the client does not have any control over this external data.",
      "ja": "XPathのクライアントは、この外部データを制御することはできませんので、文の条件は、ターゲット・データ・ノードの外のデータを参照してはなりません「」。"
    },
    {
      "indent": 3,
      "text": "In the following dummy example, it is okay to augment the \"interface\" entry with \"mandatory-leaf\" because the augmentation depends on support for \"some-new-iftype\". The old client does not know about this type, so it would never select this type; therefore, it would not add a mandatory data node.",
      "ja": "増強「は、いくつかの新しい-のifType」のサポートに依存しているため、次のダミーの例では、「必須葉」と「インターフェース」のエントリを補強しても大丈夫です。古いクライアントは、このタイプについて知らないので、このタイプを選択することはありません。そのため、これは必須のデータノードを追加しないでしょう。"
    },
    {
      "indent": 5,
      "text": "module example-module {",
      "ja": "モジュールたとえば、モジュール{"
    },
    {
      "indent": 7,
      "text": "yang-version 1.1;\nnamespace \"tag:example.com,2017:example-module\";\nprefix mymod;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import iana-if-type { prefix iana; } import ietf-interfaces { prefix if; }",
      "ja": "インポートIANA-IF型{接頭辞IANA。 }インポートIETF-インターフェイス{接頭場合、 }"
    },
    {
      "indent": 7,
      "text": "identity some-new-iftype { base iana:iana-interface-type; }",
      "ja": "アイデンティティ一部新しい-のifType {塩基IANA：IANAインターフェイス型。 }"
    },
    {
      "indent": 7,
      "text": "augment \"/if:interfaces/if:interface\" { when \"if:type = 'mymod:some-new-iftype'\";",
      "ja": "\"IF /：インターフェイス/ IF：インタフェース\" 増強{とき \"IF：TYPE = 'MYMOD：いくつかの新しい-のifType'\";"
    },
    {
      "indent": 5,
      "text": "     leaf mandatory-leaf {\n        type string;\n        mandatory true;\n     }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that this practice is safe only for creating data resources. It is not safe for replacing or modifying resources if the client does not know about the new condition. The YANG data model MUST be packaged in a way that requires the client to be aware of the mandatory data nodes if it is aware of the condition for this data. In the example above, the \"some-new-iftype\" identity is defined in the same module as the \"mandatory-leaf\" data definition statement.",
      "ja": "この練習は、データのみのリソースを作成するための安全であることに注意してください。クライアントが新しい条件について知っていない場合は、リソースを交換または修正するための安全ではありません。 YANGデータモデルは、このデータのための条件を知っている場合は必須データノードを認識するようにクライアントを必要とする方法でパッケージされなければなりません。上記の例では、「いくつかの新しい-ifTypeが」同一性「は必須葉」データ定義文と同じモジュールで定義されています。"
    },
    {
      "indent": 3,
      "text": "This practice is not safe for identities defined in a common module such as \"iana-if-type\" because the client is not required to know about \"my-module\" just because it knows about the \"iana-if-type\" module.",
      "ja": "この練習では、クライアントは、それが「IANA-IF型」モジュールについて知っているという理由だけで、「私のモジュール」について知る必要がないので、このような「IANA-IF型」などの一般的なモジュールで定義されたアイデンティティのために安全ではありません。"
    },
    {
      "indent": 0,
      "text": "4.20. Deviation Statements",
      "section_title": true,
      "ja": "4.20. 偏差文"
    },
    {
      "indent": 3,
      "text": "Per RFC 7950, Section 7.20.3, the YANG \"deviation\" statement is not allowed to appear in IETF YANG modules, but it can be useful for documenting server capabilities. Deviation statements are not reusable and typically not shared across all platforms.",
      "ja": "RFC 7950、セクション7.20.3パー、YANG「ずれ」の文は、IETF YANGモジュールに表示されるように許可されていないが、それはサーバ機能を文書化するのに役立ちます。偏差文は、再利用可能なものではなく、一般的に、すべてのプラットフォーム間で共有されません。"
    },
    {
      "indent": 3,
      "text": "There are several reasons that deviations might be needed in an implementation, e.g., an object cannot be supported on all platforms, or feature delivery is done in multiple development phases. Deviation statements can also be used to add annotations to a module, which does not affect the conformance requirements for the module.",
      "ja": "偏差が実装に必要になることがありますいくつかの理由がありますが、例えば、オブジェクトは、すべてのプラットフォーム上でサポートすることができない、または機能のデリバリーは、複数の開発段階で行われます。偏差ステートメントは、モジュールのための適合性要件に影響を与えない、モジュールに注釈を追加するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "It is suggested that deviation statements be defined in separate modules from regular YANG definitions. This allows the deviations to be platform specific and/or temporary.",
      "ja": "偏差文は、通常のYANGの定義とは別のモジュールで定義されていることが示唆されました。これは、偏差が特異的および/または一時的なプラットフォームにすることができます。"
    },
    {
      "indent": 3,
      "text": "The order that deviation statements are evaluated can affect the result. Therefore, multiple deviation statements in the same module, for the same target object, SHOULD NOT be used.",
      "ja": "偏差文が評価される順序は結果に影響を与えることができます。したがって、同じモジュール内の複数の偏差文は、同一の対象物のために、使用されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" statement is intended to describe an architectural limit to the number of list entries. It is not intended to describe platform limitations. It is better to use a \"deviation\" statement for the platforms that have a hard resource limit.",
      "ja": "「MAX-要素」文は、リストのエントリの数に建築制限を記述することを意図しています。プラットフォームの制限を説明するためのものではありません。ハードリソース制限を持っているプラ​​ットフォーム用の「ずれ」ステートメントを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Example documenting platform resource limits:",
      "ja": "プラットフォームのリソース制限を文書化する例："
    },
    {
      "indent": 5,
      "text": "Wrong: (max-elements in the list itself)",
      "ja": "間違い：（リスト自体のmax-要素）"
    },
    {
      "indent": 8,
      "text": "container backups { list backup { ... max-elements 10; ... } }",
      "ja": "コンテナのバックアップ{リストのバックアップ{...最大要素10; ...}}"
    },
    {
      "indent": 5,
      "text": "Correct: (max-elements in a deviation)",
      "ja": "正しい：（MAX-要素偏差）"
    },
    {
      "indent": 8,
      "text": "deviation /bk:backups/bk:backup { deviate add { max-elements 10; } }",
      "ja": "偏差/ BK：バックアップ/ BK：バックアップ{{MAX-要素10を追加逸脱。 }}"
    },
    {
      "indent": 0,
      "text": "4.21. Extension Statements",
      "section_title": true,
      "ja": "4.21. 拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "The YANG \"extension\" statement is used to specify external definitions. This appears in the YANG syntax as an \"unknown-statement\". Usage of extension statements in a published module needs to be considered carefully.",
      "ja": "YANG「拡張子」文は外部定義を指定するために使用されます。これは、「未知の文」としてYANG構文で表示されます。公表モジュールで拡張文の使用は慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following guidelines apply to the usage of YANG extensions:",
      "ja": "次のガイドラインは、YANG拡張の利用に適用されます。"
    },
    {
      "indent": 3,
      "text": "o The semantics of the extension MUST NOT contradict any YANG statements. Extensions can add semantics not covered by the normal YANG statements.",
      "ja": "O拡張の意味論は、任意のYANG文と矛盾してはなりません。拡張機能は、通常のYANGステートメントでカバーされていないセマンティクスを追加することができます。"
    },
    {
      "indent": 3,
      "text": "o The module containing the extension statement MUST clearly identify the conformance requirements for the extension. It should be clear whether all implementations of the YANG module containing the extension need to also implement the extension. If not, identify what conditions apply that would require implementation of the extension.",
      "ja": "O拡張文を含むモジュールは明らかに拡張のための適合性要件を特定しなければなりません。拡張子を含むYANGモジュールのすべての実装にも拡張を実装する必要があるかどうかを明確にする必要があります。そうでない場合、条件はその拡張の実装を必要とする適用するものを特定します。"
    },
    {
      "indent": 3,
      "text": "o The extension MUST clearly identify where it can be used within other YANG statements.",
      "ja": "それは他のYANGステートメント内で使用することができる場所O拡張が明確に特定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The extension MUST clearly identify if YANG statements or other extensions are allowed or required within the extension as substatements.",
      "ja": "YANG文や他の拡張機能を許可するかのサブステートメントなどの拡張内で必要とされている場合は、O拡張が明確に特定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.22. Data Correlation",
      "section_title": true,
      "ja": "4.22. データの相関"
    },
    {
      "indent": 3,
      "text": "Data can be correlated in various ways, using common data types, common data naming, and common data organization. There are several ways to extend the functionality of a module, based on the degree of coupling between the old and new functionality:",
      "ja": "データは、一般的なデータ型、共通のデータ命名し、共通のデータ編成を使用して、さまざまな方法で相関させることができます。古いものと新しい機能間の結合の度合いに基づいて、モジュールの機能を拡張するには、いくつかの方法があります。"
    },
    {
      "indent": 3,
      "text": "o inline: update the module with new protocol-accessible objects. The naming and data organization of the original objects is used. The new objects are in the original module namespace.",
      "ja": "Oインライン：新しいプロトコル・アクセス可能なオブジェクトでモジュールを更新します。元のオブジェクトの命名およびデータ編成が使用されています。新しいオブジェクトは、元のモジュールの名前空間です。"
    },
    {
      "indent": 3,
      "text": "o augment: create a new module with new protocol-accessible objects that augment the original data structure. The naming and data organization of the original objects is used. The new objects are in the new module namespace.",
      "ja": "O増強：元のデータ構造を補強新しいプロトコルでアクセス可能なオブジェクトに新しいモジュールを作成します。元のオブジェクトの命名およびデータ編成が使用されています。新しいオブジェクトは、新しいモジュールの名前空間です。"
    },
    {
      "indent": 3,
      "text": "o mirror: create new objects in a new module or the original module, except use a new naming scheme and data location. The naming can be coupled in different ways. Tight coupling is achieved with a \"leafref\" data type, with the \"require-instance\" substatement set to \"true\". This method SHOULD be used.",
      "ja": "Oミラー：新しい命名スキームとデータの場所を使用する以外は、新しいモジュールまたは元のモジュールに新しいオブジェクトを作成します。命名は異なる方法で結合することができます。密結合は、「真」に設定された「必要インスタンス」をサプと共に、「leafref」データタイプを用いて達成されます。この方法を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the new data instances are not limited to the values in use in the original data structure, then the \"require-instance\" substatement MUST be set to \"false\". Loose coupling is achieved by using key leafs with the same data type as the original data structure. This has the same semantics as setting the \"require-instance\" substatement to \"false\".",
      "ja": "新しいデータ・インスタンスは、元のデータ構造で使用されている値に限定されるものではない場合は、「必要-インスタンスを」サブステートメントは「偽」に設定しなければなりません。疎結合は、元のデータ構造と同じデータタイプとキー葉を使用することによって達成されます。これは「偽」に「必要-インスタンスを」サブステートメントを設定することと同じ意味を持っています。"
    },
    {
      "indent": 3,
      "text": "The relationship between configuration and operational state has been clarified in NMDA [RFC8342].",
      "ja": "構成と動作状態との関係は、NMDA [RFC8342]で明らかにされています。"
    },
    {
      "indent": 0,
      "text": "4.22.1. Use of \"leafref\" for Key Correlation",
      "section_title": true,
      "ja": "4.22.1. 主な相関のための「leafref」の使用"
    },
    {
      "indent": 3,
      "text": "Sometimes it is not practical to augment a data structure. For example, the correlated data could have different keys or contain mandatory nodes.",
      "ja": "場合によっては、データ構造を補強するために実用的ではありません。例えば、相関データは、異なる鍵を有するか、または必須のノードを含むことができます。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of the \"leafref\" data type for data correlation purposes:",
      "ja": "次の例では、データ相関目的のための「leafref」データタイプの使用を示します。"
    },
    {
      "indent": 3,
      "text": "Not preferred:",
      "ja": "好ましいものではありません："
    },
    {
      "indent": 6,
      "text": "list foo {\n   key name;\n   leaf name {\n     type string;\n   }\n   ...\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "list foo-addon {\n   key name;\n   config false;\n   leaf name {\n     type string;\n   }\n   ...\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Preferred:",
      "ja": "プリファード："
    },
    {
      "indent": 6,
      "text": "list foo {\n   key name;\n   leaf name {\n     type string;\n   }\n   ...\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "list foo-addon {\n   key name;\n   config false;\n   leaf name {\n     type leafref {\n       path \"/foo/name\";\n       require-instance false;\n     }\n   }\n   leaf addon {",
      "raw": true
    },
    {
      "indent": 6,
      "text": "     type string;\n     mandatory true;\n   }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.23. Operational State",
      "section_title": true,
      "ja": "4.23. オペレーショナル・ステート"
    },
    {
      "indent": 3,
      "text": "The modeling of operational state with YANG has been refined over time. At first, only data that has a \"config\" statement value of \"false\" was considered to be operational state. This data was not considered to be part of any datastore, which made the YANG XPath definition much more complicated.",
      "ja": "YANGと動作状態のモデリングは、時間をかけて洗練されています。最初は、「偽」の「設定」の文の値を持つデータのみが動作状態であると考えられました。このデータは、はるかに複雑YANG XPathの定義を行ったすべてのデータストアの一部であると考えられていませんでした。"
    },
    {
      "indent": 3,
      "text": "Operational state is now modeled using YANG according to the new NMDA [RFC8342] and conceptually contained in the operational state datastore, which also includes the operational values of configuration data. There is no longer any need to duplicate data structures to provide separate configuration and operational state sections.",
      "ja": "動作状態は、新しいNMDA [RFC8342]に従うと概念的に、構成データの演算値を含む動作状態データストアに含まれるYANGを使用してモデル化されます。個別の構成と動作状態のセクションを提供するために、データ構造を複製する必要がなくなりました。"
    },
    {
      "indent": 3,
      "text": "This section describes some data modeling issues related to operational state and guidelines for transitioning YANG data model design to be NMDA compatible.",
      "ja": "このセクションでは、互換性のあるNMDAするYANGデータモデルの設計を移行するための動作状態やガイドラインに関連するいくつかのデータモデリングの問題について説明します。"
    },
    {
      "indent": 0,
      "text": "4.23.1. Combining Operational State and Configuration Data",
      "section_title": true,
      "ja": "4.23.1. 運用状態や設定データを組み合わせます"
    },
    {
      "indent": 3,
      "text": "If possible, operational state SHOULD be combined with its associated configuration data. This prevents duplication of key leafs and ancestor nodes. It also prevents race conditions for retrieval of dynamic entries and allows configuration and operational state to be retrieved together with minimal message overhead.",
      "ja": "可能な場合、動作状態は、それに関連するコンフィギュレーションデータと組み合わせる必要があります。これは、キー葉や祖先ノードの重複を防ぐことができます。それはまた、ダイナミックエントリを検索するための競合状態を防止した構成と動作状態が最小メッセージオーバーヘッドと共に検索することを可能にします。"
    },
    {
      "indent": 6,
      "text": "container foo { ... // contains \"config true\" and \"config false\" nodes that have // no corresponding \"config true\" object (e.g., counters) }",
      "ja": "容器fooが{... // //は該当する「コンフィグ真」オブジェクトを持たない「コンフィグ真」および「偽設定」ノードを含む（例えば、カウンタ）}"
    },
    {
      "indent": 0,
      "text": "4.23.2. Representing Operational Values of Configuration Data",
      "section_title": true,
      "ja": "4.23.2. 設定データの運用値を表します"
    },
    {
      "indent": 3,
      "text": "If possible, the same data type SHOULD be used to represent the configured value and the operational value, for a given leaf or leaf-list object.",
      "ja": "可能な場合、同じデータ型が指定された葉または葉リストオブジェクトに対して、設定された値と演算値を表すために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Sometimes the configured value set is different than the operational value set for that object, for example, the \"admin-status\" and \"oper-status\" leafs in [RFC8343]. In this case, a separate object MAY be used to represent the configured and operational values.",
      "ja": "時々設定された値のセットは、そのオブジェクトに設定された演算値、[RFC8343]に例えば、「管理ステータス」および「OPERステータス」葉とは異なります。この場合には、別の目的は、構成および動作値を表すために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Sometimes the list keys are not identical for configuration data and the corresponding operational state. In this case, separate lists MAY be used to represent the configured and operational values.",
      "ja": "時にはリストキーは、構成データとそれに対応する動作状態のために同じではありません。この場合、別個のリストが設定され、動作値を表すために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If it is not possible to combine configuration and operational state, then the keys used to represent list entries SHOULD be the same type. The \"leafref\" data type SHOULD be used in operational state for key leafs that have corresponding configuration instances. The \"require-instance\" statement MAY be set to \"false\" (in YANG 1.1 modules only) to indicate instances are allowed in the operational state that do not exist in the associated configuration data.",
      "ja": "それは構成や動作状態を組み合わせることが可能でない場合は、リストの項目を表すために使用されるキーは、同じタイプである必要があります。 「leafref」データ型は、対応するコンフィギュレーションインスタンスを持ってキー葉の運用状態で使用する必要があります。 「必要-インスタンス」文は「偽」（YANGで1.1モジュールのみ）のインスタンスを示すためには、関連する構成データには存在しない動作状態で許可されるように設定することができます。"
    },
    {
      "indent": 3,
      "text": "The need to replicate objects or define different operational state objects depends on the data model. It is not possible to define one approach that will be optimal for all data models.",
      "ja": "オブジェクトを複製するか、別の動作状態のオブジェクトを定義する必要性は、データモデルによって異なります。すべてのデータモデルに対して最適になる一つのアプローチを定義することはできません。"
    },
    {
      "indent": 3,
      "text": "Designers SHOULD describe and justify any NMDA exceptions in detail, such as the use of separate subtrees and/or separate leafs. The \"description\" statements for both the configuration and the operational state SHOULD be used for this purpose.",
      "ja": "設計者は、別のサブツリー及び/又は別個のリーフを使用するように、詳細に任意のNMDA例外を記述し、正当化すべきです。設定および動作状態の両方のための「説明」の文は、この目的のために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "4.23.3. NMDA Transition Guidelines",
      "section_title": true,
      "ja": "4.23.3.  NMDA移行ガイドライン"
    },
    {
      "indent": 3,
      "text": "YANG modules SHOULD be designed with the assumption that they will be used on servers supporting the operational state datastore. With this in mind, YANG modules SHOULD define \"config false\" nodes wherever they make sense to the data model. \"Config false\" nodes SHOULD NOT be defined to provide the operational value for configuration nodes, except when the value space of a configured and operational value may differ, in which case a distinct \"config false\" node SHOULD be defined to hold the operational value for the configured node.",
      "ja": "YANGモジュールは、彼らが動作状態のデータストアをサポートするサーバ上で使用されることを想定して設計する必要があります。彼らはデータモデルに意味をなすどここのことを念頭に、YANGモジュールは、「コンフィグ偽」のノードを定義する必要があります。 「コンフィグ偽」ノードが異なる「コンフィグ偽」ノードが動作値を保持するように定義されるべき場合には、構成及び動作値の値空間が異なっていてもよい場合を除いて、構成ノードの演算値を提供するために定義されるべきではありません構成されたノードの。"
    },
    {
      "indent": 3,
      "text": "The following guidelines are meant to help modelers develop YANG modules that will maximize the utility of the model with both current and new implementations.",
      "ja": "次のガイドラインは、モデラーが現在と新しい実装の両方でモデルの効用を最大化しますYANGモジュールの開発を支援するためのものです。"
    },
    {
      "indent": 3,
      "text": "New modules and modules that are not concerned with the operational state of configuration information SHOULD immediately be structured to be NMDA compatible, as described in Section 4.23.1. This transition MAY be deferred if the module does not contain any configuration datastore objects.",
      "ja": "セクション4.23.1に記載されるように設定情報の動作状態に関係していない新しいモジュールおよびモジュールは直ちに、NMDA適合するように構成されるべきです。モジュールは、すべての構成データストアオブジェクトが含まれていない場合は、この移行は延期されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The remaining are options that MAY be followed during the time that NMDA mechanisms are being defined.",
      "ja": "残りNMDAメカニズムが定義されている間に行ってもよいオプションです。"
    },
    {
      "indent": 3,
      "text": "(a) Modules that require immediate support for the NMDA features SHOULD be structured for NMDA. A temporary non-NMDA version of this type of module MAY exist, as either an existing model or a model created by hand or with suitable tools that mirror the current modeling strategies. Both the NMDA and the non-NMDA modules SHOULD be published in the same document, with NMDA modules in the document main body and the non-NMDA modules in a non-normative appendix. The use of the non-NMDA module will allow temporary bridging of the time period until NMDA implementations are available.",
      "ja": "（a）はNMDA機能の即時のサポートが必要なモジュールは、NMDAのために構造化されるべきです。このタイプのモジュールの一時的な非NMDAバージョンは、既存のモデルや手または現在のモデリング戦略を反映し、適切なツールを使用して作成したモデルのいずれかのように、存在してもよいです。 NMDAおよび非NMDAモジュールの両方が非規範付録の文書本体と非NMDAモジュールにおけるNMDAモジュールと、同じドキュメントに掲載されるべきです。 NMDA実装が利用可能になるまで非NMDAモジュールの使用は、期間の一時的なブリッジングが可能になります。"
    },
    {
      "indent": 3,
      "text": "(b) For published models, the model should be republished with an NMDA-compatible structure, deprecating non-NMDA constructs. For example, the \"ietf-interfaces\" model in [RFC7223] has been restructured as an NMDA-compatible model in [RFC8343]. The \"/interfaces-state\" hierarchy has been marked \"status deprecated\". Models that mark their \"/foo-state\" hierarchy with \"status deprecated\" will allow NMDA-capable implementations to avoid the cost of duplicating the state nodes, while enabling non-NMDA-capable implementations to utilize them for access to the operational values.",
      "ja": "（b）は、公開されたモデルの場合、モデルは、非NMDAコンストラクト卑下、NMDA互換構造で再版されるべきです。例えば、[RFC7223]に「IETF-インターフェース」モデルは、[RFC8343]におけるNMDA互換モデルとして再構築されています。 「/インタフェース状態」階層は「状況は廃止」とマークされています。動作値にアクセスするためにそれらを利用するために非NMDA対応の実装を可能にしながら、「非推奨状態」との「/ fooの状態」の階層をマークしたモデルは、NMDA対応の実装では、状態ノードを複製するコストを避けることができます。"
    },
    {
      "indent": 3,
      "text": "(c) For models that augment models that have not been structured with the NMDA, the modeler will have to consider the structure of the base model and the guidelines listed above. Where possible, such models should move to new revisions of the base model that are NMDA compatible. When that is not possible, augmenting \"state\" containers SHOULD be avoided, with the expectation that the base model will be re-released with the state containers marked as deprecated. It is RECOMMENDED to augment only the \"/foo\" hierarchy of the base model. Where this recommendation cannot be followed, then any new \"state\" elements SHOULD be included in their own module.",
      "ja": "（C）NMDAで構成されていないモデルを増大モデルでは、モデラーは、ベースモデルの構造および上記のガイドラインを考慮しなければなりません。可能であれば、このようなモデルは、NMDA互換性のあるベースモデルの新しいリビジョンに移動する必要があります。それが不可能な場合は、増補「状態」の容器は、ベースモデルは非推奨としてマークされた状態のコンテナで再リリースされることを期待して、避けるべきです。ベースモデルの唯一の「/ foo」という階層構造を強化することをお勧めします。この勧告に従うことができない場合は、その後、新たな「状態」の要素は、独自のモジュールに含まれるべきです。"
    },
    {
      "indent": 0,
      "text": "4.23.3.1. Temporary Non-NMDA Modules",
      "section_title": true,
      "ja": "4.23.3.1。一時的な非NMDAモジュール"
    },
    {
      "indent": 3,
      "text": "A temporary non-NMDA module allows a non-NMDA-aware client to access operational state from an NMDA-compliant server. It contains the top-level \"config false\" data nodes that would have been defined in a legacy YANG module (before NMDA).",
      "ja": "一時的な非NMDAモジュールは非NMDA対応クライアントは、NMDA準拠のサーバーから動作状態にアクセスすることができます。それは（NMDA前）レガシーYANGモジュールで定義されていた最上位の「コンフィグ偽」データノードが含まれています。"
    },
    {
      "indent": 3,
      "text": "A server that needs to support both NMDA and non-NMDA clients can advertise both the new NMDA module and the temporary non-NMDA module. A non-NMDA client can use separate \"foo\" and \"foo-state\" subtrees, except the \"foo-state\" subtree is located in a different (temporary) module. The NMDA module can be used by a non-NMDA client to access the conventional configuration datastores and the deprecated <get> operation to access nested \"config false\" data nodes.",
      "ja": "両方のNMDAおよび非NMDAクライアントが新しいNMDAモジュールと、一時的な非NMDAモジュールの両方を宣伝することができますサポートする必要があるサーバー。 「FOO状態」サブツリーが異なる（一時的な）モジュールに位置している以外は、非NMDAクライアントは、別々の「foo」と「FOO状態」サブツリーを使用することができます。 NMDAモジュールは、ネストされた「コンフィグ偽」データノードにアクセスするために、従来のコンフィギュレーション・データストアおよび非推奨の<GET>操作にアクセスするための非NMDAクライアントで使用することができます。"
    },
    {
      "indent": 3,
      "text": "To create the temporary non-NMDA model from an NMDA model, the following steps can be taken:",
      "ja": "NMDAモデルから一時的に非NMDAモデルを作成するには、次の手順を取ることができます。"
    },
    {
      "indent": 3,
      "text": "o Change the module name by appending \"-state\" to the original module name",
      "ja": "O元のモジュール名に「 - 状態」を追加することによって、モジュール名を変更します"
    },
    {
      "indent": 3,
      "text": "o Change the namespace by appending \"-state\" to the original namespace value",
      "ja": "O本来の名前空間の値に「-state」を追加することで、名前空間を変更"
    },
    {
      "indent": 3,
      "text": "o Change the prefix by appending \"-s\" to the original prefix value",
      "ja": "O元プレフィックス値に「-s」を追加することによって、プレフィックスを変更"
    },
    {
      "indent": 3,
      "text": "o Add an import to the original module (e.g., for typedef definitions)",
      "ja": "O（typedefの定義については、例えば、）元のモジュールへのインポートを追加"
    },
    {
      "indent": 3,
      "text": "o Retain or create only the top-level nodes that have a \"config\" statement value \"false\". These subtrees represent \"config false\" data nodes that were combined into the configuration subtree; therefore, they are not available to non-NMDA aware clients. Set the \"status\" statement to \"deprecated\" for each new node.",
      "ja": "O「偽」「設定」の文の値を持っている唯一のトップレベルのノードを保持するか、または作成します。これらのサブツリーは、構成サブツリーに結合した「コンフィグ偽」データノードを表します。そのため、彼らは非NMDA対応クライアントが使用することはできません。それぞれの新しいノードのために、「非推奨」に「ステータス」文を設定します。"
    },
    {
      "indent": 3,
      "text": "o The module description SHOULD clearly identify the module as a temporary non-NMDA module",
      "ja": "Oモジュールの記述は明らかに一時的な非NMDAモジュールとしてモジュールを特定すべきです"
    },
    {
      "indent": 0,
      "text": "4.23.3.2. Example: Create a New NMDA Module",
      "section_title": true,
      "ja": "4.23.3.2。例：新規NMDAモジュールを作成します。"
    },
    {
      "indent": 3,
      "text": "Create an NMDA-compliant module, using combined configuration and state subtrees, whenever possible.",
      "ja": "可能な限り、複合構成および状態のサブツリーを使用して、NMDA準拠モジュールを作成します。"
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  namespace \"urn:example.com:params:xml:ns:yang:example-foo\";\n  prefix \"foo\";",
      "raw": true
    },
    {
      "indent": 4,
      "text": " container foo { // configuration data child nodes // operational value in operational state datastore only // may contain \"config false\" nodes as needed } }",
      "ja": "容器FOO {必要に応じ//動作状態データストア内の構成データの子ノード//演算値のみ//が含まれていてもよい「コンフィグ偽」ノード}}"
    },
    {
      "indent": 0,
      "text": "4.23.3.3. Example: Convert an Old Non-NMDA Module",
      "section_title": true,
      "ja": "4.23.3.3。例：古い非NMDAモジュールの変換"
    },
    {
      "indent": 3,
      "text": "Do not remove non-compliant objects from existing modules. Instead, change the status to \"deprecated\". At some point, usually after 1 year, the status MAY be changed to \"obsolete\".",
      "ja": "既存のモジュールからの非準拠のオブジェクトを削除しないでください。代わりに、「非推奨」にステータスを変更。いくつかの点で、通常は1年後、ステータスが「時代遅れ」に変更してもよいです。"
    },
    {
      "indent": 3,
      "text": "Old Module:",
      "ja": "旧モジュール："
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  namespace \"urn:example.com:params:xml:ns:yang:example-foo\";\n  prefix \"foo\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "container foo { // configuration data child nodes }",
      "ja": "容器FOO {//構成データ子ノード}"
    },
    {
      "indent": 4,
      "text": " container foo-state { config false; // operational state child nodes } }",
      "ja": "容器FOO状態{設定偽。 //動作状態の子ノード}}"
    },
    {
      "indent": 3,
      "text": "Converted NMDA Module:",
      "ja": "変換されたNMDAモジュール："
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  namespace \"urn:example.com:params:xml:ns:yang:example-foo\";\n  prefix \"foo\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "container foo { // configuration data child nodes // operational value in operational state datastore only // may contain \"config false\" nodes as needed // will contain any data nodes from old foo-state }",
      "ja": "コンテナのfoo {動作状態のデータストア内の//コンフィグレーションデータの子ノード//動作値、必要に応じてのみ、//は、「コンフィグ偽」のノードが含まれていてもよい//古いfooの状態から任意のデータノードが含まれています}"
    },
    {
      "indent": 4,
      "text": "   // keep original foo-state but change status to deprecated\n   container foo-state {\n     config false;\n     status deprecated;\n     // operational state child nodes\n   }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.23.3.4. Example: Create a Temporary NMDA Module",
      "section_title": true,
      "ja": "4.23.3.4。例：一時的なNMDAモジュールを作成します。"
    },
    {
      "indent": 3,
      "text": "Create a new module that contains the top-level operational state data nodes that would have been available before they were combined with configuration data nodes (to be NMDA compliant).",
      "ja": "これらは、構成データノード（NMDA準拠するように）と一緒にした前に利用可能であったであろう、トップレベルの動作状態のデータノードを含む新しいモジュールを作成します。"
    },
    {
      "indent": 5,
      "text": "module example-foo-state {\n  namespace \"urn:example.com:params:xml:ns:yang:example-foo-state\";\n  prefix \"foo-s\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "// import new or converted module; not used in this example import example-foo { prefix foo; }",
      "ja": "//新規または変換されたモジュールをインポートします。この例のインポート例-FOO {プレフィックスFOOでは使用されません。 }"
    },
    {
      "indent": 4,
      "text": "   container foo-state {\n     config false;\n     status deprecated;\n     // operational state child nodes\n   }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.24. Performance Considerations",
      "section_title": true,
      "ja": "4.24. パフォーマンスの考慮事項"
    },
    {
      "indent": 3,
      "text": "It is generally likely that certain YANG statements require more runtime resources than other statements. Although there are no performance requirements for YANG validation, the following information MAY be considered when designing YANG data models:",
      "ja": "特定のYANG文は他の文よりも、ランタイム・リソースを必要とすることを、一般的にそうです。 YANGの検証のための性能要件はありませんがYANGデータモデルを設計する場合、以下の情報を考慮することができます。"
    },
    {
      "indent": 3,
      "text": "o Lists are generally more expensive than containers",
      "ja": "Oリストは、一般的に、容器よりも高価です"
    },
    {
      "indent": 3,
      "text": "o \"when\" statement evaluation is generally more expensive than \"if-feature\" or \"choice\" statements",
      "ja": "o「のとき」文の評価は、一般的に、「IF-機能」よりも高価であるか、「選択」ステートメント"
    },
    {
      "indent": 3,
      "text": "o \"must\" statements are generally more expensive than \"min-entries\", \"max-entries\", \"mandatory\", or \"unique\" statements",
      "ja": "O文は、「MAX-エントリ」、一般的に「必須」「MIN-エントリー」よりも高価であり、「しなければならない」、または「ユニーク」ステートメント"
    },
    {
      "indent": 3,
      "text": "o \"identityref\" leafs are generally more expensive than \"enumeration\" leafs",
      "ja": "O「identityref」葉は、一般的に「列挙」の葉よりも高価であり、"
    },
    {
      "indent": 3,
      "text": "o \"leafref\" and \"instance-identifier\" types with \"require-instance\" set to true are generally more expensive than if \"require-instance\" is set to false",
      "ja": "trueに設定o「はleafref」と「必要-インスタンス」と「インスタンス識別子」タイプは、一般的に「必要-インスタンスが」falseに設定されている場合よりも高価であり、"
    },
    {
      "indent": 0,
      "text": "4.25. Open Systems Considerations",
      "section_title": true,
      "ja": "4.25. オープンシステムの考慮事項"
    },
    {
      "indent": 3,
      "text": "Only the modules imported by a particular module can be assumed to be present in an implementation. An open system MAY include any combination of YANG modules.",
      "ja": "特定のモジュールによってインポートモジュールのみが実装で存在すると仮定することができます。オープンシステムは、YANGモジュールの任意の組み合わせを含むことができます。"
    },
    {
      "indent": 0,
      "text": "4.26. Guidelines for Constructs Specific to YANG 1.1",
      "section_title": true,
      "ja": "4.26.  YANG 1.1への具体的な構築のためのガイドライン"
    },
    {
      "indent": 3,
      "text": "The set of guidelines for YANG 1.1 will grow as operational experience is gained with the new language features. This section contains an initial set of guidelines for new YANG 1.1 language features.",
      "ja": "運用経験が新しい言語機能を得られるようYANG 1.1のためのガイドラインのセットが成長します。このセクションでは、新しいYANG 1.1言語機能のためのガイドラインの最初のセットが含まれています。"
    },
    {
      "indent": 0,
      "text": "4.26.1. Importing Multiple Revisions",
      "section_title": true,
      "ja": "4.26.1. 複数のリビジョンのインポート"
    },
    {
      "indent": 3,
      "text": "Standard modules SHOULD NOT import multiple revisions of the same module into a module. This MAY be done if independent definitions (e.g., enumeration typedefs) from specific revisions are needed in the importing module.",
      "ja": "標準モジュールは、モジュールに同じモジュールの複数のリビジョンをインポートしないでください。特定のリビジョンから独立して定義（例えば、列挙型定義）をインポートモジュールで必要とされる場合に行うことができます。"
    },
    {
      "indent": 0,
      "text": "4.26.2. Using Feature Logic",
      "section_title": true,
      "ja": "4.26.2. 機能のロジックを使用して"
    },
    {
      "indent": 3,
      "text": "The YANG 1.1 feature logic is much more expressive than YANG 1.0. A \"description\" statement SHOULD describe the \"if-feature\" logic in text, to help readers understand the module.",
      "ja": "YANG 1.1機能のロジックは、はるかに表現力YANG 1.0以上です。 「説明」の文は、読者がモジュールを理解するために、テキストで「IF-機能」のロジックを記述する必要があります。"
    },
    {
      "indent": 3,
      "text": "YANG features SHOULD be used instead of the \"when\" statement, if possible. Features are advertised by the server, and objects conditional by the \"if-feature\" statement are conceptually grouped together. There is no such commonality supported for \"when\" statements.",
      "ja": "可能であればYANG機能は、代わりに「とき」の文を使用するべきです。特長は、サーバによってアドバタイズされており、「IF-機能」文で条件付きオブジェクトは、概念的にグループ化されています。 「いつ」ステートメントではサポートされ、そのような共通性はありません。"
    },
    {
      "indent": 3,
      "text": "Features generally require less server implementation complexity and runtime resources than objects that use \"when\" statements. Features are generally static (i.e., set when a module is loaded and not changed at runtime). However, every client edit might cause a \"when\" statement result to change.",
      "ja": "特長は、一般的に「」ステートメントを使用するオブジェクトよりも少ないサーバー実装の複雑さとランタイムリソースを必要とします。特徴は、一般的に静的である（すなわち、モジュールがロードされ、実行時に変更されていない場合に設定されます）。ただし、すべてのクライアントの編集は「いつ」文の結果を変更することがあります。"
    },
    {
      "indent": 0,
      "text": "4.26.3. \"anyxml\" versus \"anydata\"",
      "section_title": true,
      "ja": "4.26.3.  \"ANYDATA\" 対 \"AnyXMLで\""
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement MUST NOT be used to represent a conceptual subtree of YANG data nodes. The \"anydata\" statement MUST be used for this purpose.",
      "ja": "「AnyXMLで」文は、YANGデータノードの概念サブツリーを表すために使用してはいけません。 「ANYDATA」の文は、この目的のために使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.26.4. \"action\" versus \"rpc\"",
      "section_title": true,
      "ja": "4.26.4.  「RPC」対「アクション」"
    },
    {
      "indent": 3,
      "text": "The use of \"action\" statements or \"rpc\" statements is a subjective design decision. RPC operations are not associated with any particular data node. Actions are associated with a specific data node definition. An \"action\" statement SHOULD be used if the protocol operation is specific to a subset of all data nodes instead of all possible data nodes.",
      "ja": "「アクション」の文または「RPC」の文を使用すると、主観的な設計上の決定です。 RPC操作は、任意の特定のデータ・ノードに関連付けられていません。アクションは、特定のデータノード定義に関連付けされています。プロトコルの動作は、全てのデータノードの代わりに、すべての可能なデータノードのサブセットに特異的である場合、「アクション」ステートメントを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The same action name MAY be used in different definitions within different data node. For example, a \"reset\" action defined with a data node definition for an interface might have different parameters than for a power supply or a VLAN. The same action name SHOULD be used to represent similar semantics.",
      "ja": "同じアクション名が異なるデータノード内の異なる定義で使用されるかもしれません。例えば、インターフェースのためのデータノード定義で定義された「リセット」動作は、電源またはVLANの異なるパラメータを持つかもしれません。同じアクション名は、同じような意味を表すために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "The NETCONF Access Control Model (NACM) [RFC8341] does not support parameter-based access control for RPC operations. The user is given permission (or not) to invoke the RPC operation with any parameters. For example, if each client is only allowed to reset their own interface, then NACM cannot be used.",
      "ja": "NETCONFアクセス制御モデル（NACM）[RFC8341]はRPC操作のためのパラメータ・ベースのアクセス制御をサポートしていません。ユーザは、任意のパラメータを使用してRPC動作を呼び出すための許可（またはしない）を与えられます。各クライアントは唯一、独自のインターフェイスをリセットすることが許可されている場合たとえば、その後、NACMを使用することはできません。"
    },
    {
      "indent": 3,
      "text": "For example, NACM cannot enforce access control based on the value of the \"interface\" parameter, only the \"reset\" operation itself:",
      "ja": "例えば、NACMは、「リセット」、「インターフェース」パラメータの値に基づいて、操作自体をアクセス制御を強制することができません。"
    },
    {
      "indent": 6,
      "text": "rpc reset {\n  input {\n    leaf interface {\n      type if:interface-ref;\n      mandatory true;\n      description \"The interface to reset.\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "However, NACM can enforce access control for individual interface instances, using a \"reset\" action. If the user does not have read access to the specific \"interface\" instance, then it cannot invoke the \"reset\" action for that interface instance:",
      "ja": "しかし、NACMは、「リセット」アクションを使用して、個々のインターフェイスインスタンスに対するアクセス制御を強制することができます。ユーザーが特定の「インターフェイス」のインスタンスへの読み取りアクセス権を持っていない場合、それはそのインターフェイスインスタンスのための「リセット」アクションを呼び出すことはできません。"
    },
    {
      "indent": 6,
      "text": "container interfaces { list interface { ... action reset { } } }",
      "ja": "容器インタフェース{リストインタフェース{...アクションリセット{}}}"
    },
    {
      "indent": 0,
      "text": "4.27. Updating YANG Modules (Published versus Unpublished)",
      "section_title": true,
      "ja": "4.27.  YANGモジュールを更新する（未発表に対する公開）"
    },
    {
      "indent": 3,
      "text": "YANG modules can change over time. Typically, new data model definitions are needed to support new features. YANG update rules defined in Section 11 of [RFC7950] MUST be followed for published modules. They MAY be followed for unpublished modules.",
      "ja": "YANGモジュールは、時間の経過とともに変化することができます。一般的に、新しいデータモデルの定義は、新機能をサポートするために必要とされます。 [RFC7950]のセクション11で定義されたYANG更新ルールは、公開されたモジュールのために従わなければなりません。彼らは、未発表のモジュールに続いてもよいです。"
    },
    {
      "indent": 3,
      "text": "The YANG update rules only apply to published module revisions. Each organization will have their own way to identify published work that is considered to be stable and unpublished work that is considered to be unstable. For example, in the IETF, the RFC document is used for published work, and the I-D is used for unpublished work.",
      "ja": "YANGの更新ルールは、公開モジュールのリビジョンに適用されます。各組織は、不安定であると考えられ、安定した未発表の作品であるとみなされ、公開作業を識別するための独自の方法を持っています。例えば、IETFで、RFC文書が公表された研究のために使用され、およびI-Dは、未発表の作品に使用されます。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The following registration in the \"ns\" subregistry of the \"IETF XML Registry\" [RFC3688] was detailed in [RFC6087] and has been updated by IANA to reference this document.",
      "ja": "「IETF XMLレジストリ」の「NS」副登録[RFC3688]で以下の登録は[RFC6087]に詳細であり、この文書を参照するためにIANAによって更新されました。"
    },
    {
      "indent": 7,
      "text": "URI: urn:ietf:params:xml:ns:yang:ietf-template",
      "ja": "URI：URN：IETF：のparams：XML：NS：ヤン：IETF-テンプレート"
    },
    {
      "indent": 7,
      "text": "Registrant Contact: The IESG.",
      "ja": "登録者連絡先：IESG。"
    },
    {
      "indent": 7,
      "text": "XML: N/A, the requested URI is an XML namespace.",
      "ja": "XML：N / Aは、要求されたURIは、XML名前空間があります。"
    },
    {
      "indent": 3,
      "text": "The following assignment was detailed in [RFC6087] and has been updated by IANA in the \"YANG Module Names\" registry. This document has also been added as a reference for the \"YANG Module Names\" registry itself as it contains the template necessary for registration in Appendix B.",
      "ja": "以下の割り当ては、[RFC6087]で詳述され、「YANGモジュール名」レジストリにIANAによって更新されました。それは付録Bに登録するために必要なテンプレートが含まれているとして、この文書はまた、「YANGモジュール名」レジストリ自体の基準として追加されました"
    },
    {
      "indent": 9,
      "text": "+-----------+-------------------------------------------+\n| Field     | Value                                     |\n+-----------+-------------------------------------------+\n| Name      | ietf-template                             |\n| Namespace | urn:ietf:params:xml:ns:yang:ietf-template |\n| Prefix    | temp                                      |\n| Reference | RFC 8407                                  |\n+-----------+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "YANG Registry Assignment",
      "ja": "WHOレジストリの割り当て"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines documentation guidelines for NETCONF or RESTCONF content defined with the YANG data modeling language; therefore, it does not introduce any new or increased security risks into the management system.",
      "ja": "この文書では、YANGデータモデリング言語で定義されたNETCONFまたはRESTCONFコンテンツのドキュメントのガイドラインを定義します。したがって、それは管理システムに新規または強化されたセキュリティ上のリスクを導入していません。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ID-Guidelines] Housley, R., \"Guidelines to Authors of Internet-Drafts\", December 2010, <https://www.ietf.org/standards/ids/guidelines/>.",
      "ja": "[ID-ガイドライン] Housley氏、R.、 \"インターネットドラフトの著者へのガイドライン\"、2010年12月、<https://www.ietf.org/standards/ids/guidelines/>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, DOI 10.17487/RFC3688, January 2004, <https://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、DOI 10.17487 / RFC3688、2004年1月、<https://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTPS：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC5378] Bradner, S., Ed. and J. Contreras, Ed., \"Rights Contributors Provide to the IETF Trust\", BCP 78, RFC 5378, DOI 10.17487/RFC5378, November 2008, <https://www.rfc-editor.org/info/rfc5378>.",
      "ja": "[RFC5378]ブラドナー、S.、エド。そして、J.コントレラス、エド。、 \"権利の貢献者は、IETFトラストに提供する\"、BCP 78、RFC 5378、DOI 10.17487 / RFC5378、2008年11月、<https://www.rfc-editor.org/info/rfc5378>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <https://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M.、エド、 \"YANG  - ネットワーク構成プロトコルのためのデータモデリング言語（NETCONF）\"、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<HTTPS：。//www.rfc-editor。組織/情報/ rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <https://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 \"ネットワーク構成プロトコル（NETCONF）\"、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<https://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC6242] Wasserman, M., \"Using the NETCONF Protocol over Secure Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011, <https://www.rfc-editor.org/info/rfc6242>.",
      "ja": "[RFC6242]ワッサーマン、M.、RFC 6242、DOI 10.17487 / RFC6242、2011年6月、 \"NETCONFプロトコルを使用してセキュアシェル（SSH）上\" <https://www.rfc-editor.org/info/rfc6242>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <https://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M.編、 \"YANG 1.1データモデリング言語\"、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<https://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 3,
      "text": "[RFC8040] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017, <https://www.rfc-editor.org/info/rfc8040>.",
      "ja": "[RFC8040] Bierman、A. Bjorklund、M.、およびK. Watsen、 \"RESTCONFプロトコル\"、RFC 8040、DOI 10.17487 / RFC8040、2017年1月、<https://www.rfc-editor.org/info/rfc8040 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8342] Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K., and R. Wilton, \"Network Management Datastore Architecture (NMDA)\", RFC 8342, DOI 10.17487/RFC8342, March 2018, <https://www.rfc-editor.org/info/rfc8342>.",
      "ja": "[RFC8342] Bjorklund、M.、Schoenwaelder、J.、シェーファー、P.、Watsen、K.、およびR.ウィルトン、 \"ネットワーク管理データストア・アーキテクチャ（NMDA）\"、RFC 8342、DOI 10.17487 / RFC8342、2018年3月、< https://www.rfc-editor.org/info/rfc8342>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446]レスコラ、E.、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.3\"、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xpath] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", W3C Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "ja": "[W3C.REC-のXPath]クラーク、J.及びS. DeRose、 \"XMLパス言語（XPath）バージョン1.0\"、W3C勧告REC-のXPath-19991116、1999年11月、<http://www.w3.org/TR / 1999 / REC-のxpath-19991116>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[IANA-MOD-NAMES] IANA, \"YANG Module Names\", <https://www.iana.org/assignments/yang-parameters/>.",
      "ja": "[IANA-MOD-NAMES] IANA、 \"THATモジュール名\"、<https://www.iana.org/assignments/yang-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[IANA-XML] IANA, \"IETF XML Registry\", <https://www.iana.org/assignments/xml-registry/>.",
      "ja": "[IANA-XML] IANA、 \"IETF XMLレジストリ\"、<https://www.iana.org/assignments/xml-registry/>。"
    },
    {
      "indent": 3,
      "text": "[RFC-STYLE] RFC Editor, \"Style Guide\", <http://www.rfc-editor.org/styleguide/>.",
      "ja": "[RFC-STYLE] RFCエディタ、 \"スタイルガイド\"、<http://www.rfc-editor.org/styleguide/>。"
    },
    {
      "indent": 3,
      "text": "[RFC2026] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP 9, RFC 2026, DOI 10.17487/RFC2026, October 1996, <https://www.rfc-editor.org/info/rfc2026>.",
      "ja": "[RFC2026]ブラドナー、S.、 \"インターネット標準化過程 - リビジョン3\"、BCP 9、RFC 2026、DOI 10.17487 / RFC2026、1996年10月、<https://www.rfc-editor.org/info/rfc2026> 。"
    },
    {
      "indent": 3,
      "text": "[RFC4151] Kindberg, T. and S. Hawke, \"The 'tag' URI Scheme\", RFC 4151, DOI 10.17487/RFC4151, October 2005, <https://www.rfc-editor.org/info/rfc4151>.",
      "ja": "[RFC4151] Kindberg、T.及びS.ホーク、 \" 'タグ' URIスキーム\"、RFC 4151、DOI 10.17487 / RFC4151、2005年10月、<https://www.rfc-editor.org/info/rfc4151>。"
    },
    {
      "indent": 3,
      "text": "[RFC4181] Heard, C., Ed., \"Guidelines for Authors and Reviewers of MIB Documents\", BCP 111, RFC 4181, DOI 10.17487/RFC4181, September 2005, <https://www.rfc-editor.org/info/rfc4181>.",
      "ja": "[RFC4181]聞いた、C.、エド。、 \"著者と査読MIBのドキュメントのためのガイドライン\"、BCP 111、RFC 4181、DOI 10.17487 / RFC4181、2005年9月、<https://www.rfc-editor.org/info / rfc4181>。"
    },
    {
      "indent": 3,
      "text": "[RFC6087] Bierman, A., \"Guidelines for Authors and Reviewers of YANG Data Model Documents\", RFC 6087, DOI 10.17487/RFC6087, January 2011, <https://www.rfc-editor.org/info/rfc6087>.",
      "ja": "[RFC6087] Bierman、A.、 \"YANGデータモデルドキュメントの著者と査読のためのガイドライン\"、RFC 6087、DOI 10.17487 / RFC6087、2011年1月、<https://www.rfc-editor.org/info/rfc6087>。"
    },
    {
      "indent": 3,
      "text": "[RFC6991] Schoenwaelder, J., Ed., \"Common YANG Data Types\", RFC 6991, DOI 10.17487/RFC6991, July 2013, <https://www.rfc-editor.org/info/rfc6991>.",
      "ja": "[RFC6991] Schoenwaelder、J.、エド。、 \"共通YANGデータ型\"、RFC 6991、DOI 10.17487 / RFC6991、2013年7月、<https://www.rfc-editor.org/info/rfc6991>。"
    },
    {
      "indent": 3,
      "text": "[RFC7223] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 7223, DOI 10.17487/RFC7223, May 2014, <https://www.rfc-editor.org/info/rfc7223>.",
      "ja": "[RFC7223] Bjorklund、M.、 \"インターフェイスの管理のためのYANGデータモデル\"、RFC 7223、DOI 10.17487 / RFC7223、2014年5月、<https://www.rfc-editor.org/info/rfc7223>。"
    },
    {
      "indent": 3,
      "text": "[RFC7322] Flanagan, H. and S. Ginoza, \"RFC Style Guide\", RFC 7322, DOI 10.17487/RFC7322, September 2014, <https://www.rfc-editor.org/info/rfc7322>.",
      "ja": "[RFC7322]フラナガン、H.とS.宜野座、 \"RFCスタイルガイド\"、RFC 7322、DOI 10.17487 / RFC7322、2014年9月、<https://www.rfc-editor.org/info/rfc7322>。"
    },
    {
      "indent": 3,
      "text": "[RFC7841] Halpern, J., Ed., Daigle, L., Ed., and O. Kolkman, Ed., \"RFC Streams, Headers, and Boilerplates\", RFC 7841, DOI 10.17487/RFC7841, May 2016, <https://www.rfc-editor.org/info/rfc7841>.",
      "ja": "[RFC7841]アルペルン、J.、編、Daigle氏、L.、エド。、およびO. Kolkman、エド。、 \"RFCストリームヘッダ、及びボイラープレート\"、RFC 7841、DOI 10.17487 / RFC7841、2016年5月、<HTTPS ：//www.rfc-editor.org/info/rfc7841>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8340] Bjorklund, M. and L. Berger, Ed., \"YANG Tree Diagrams\", BCP 215, RFC 8340, DOI 10.17487/RFC8340, March 2018, <https://www.rfc-editor.org/info/rfc8340>.",
      "ja": "[RFC8340] Bjorklund、M.およびL.バーガー、エド。、 \"YANGツリー図\"、BCP 215、RFC 8340、DOI 10.17487 / RFC8340、2018年3月、<https://www.rfc-editor.org/info/ rfc8340>。"
    },
    {
      "indent": 3,
      "text": "[RFC8341] Bierman, A. and M. Bjorklund, \"Network Configuration Access Control Model\", STD 91, RFC 8341, DOI 10.17487/RFC8341, March 2018, <https://www.rfc-editor.org/info/rfc8341>.",
      "ja": "[RFC8341] Bierman、A.とM. Bjorklund、 \"ネットワーク設定のアクセス制御モデル\"、STD 91、RFC 8341、DOI 10.17487 / RFC8341、2018年3月、<https://www.rfc-editor.org/info/rfc8341 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8343] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 8343, DOI 10.17487/RFC8343, March 2018, <https://www.rfc-editor.org/info/rfc8343>.",
      "ja": "[RFC8343] Bjorklund、M.、 \"インターフェイスの管理のためのYANGデータモデル\"、RFC 8343、DOI 10.17487 / RFC8343、2018年3月、<https://www.rfc-editor.org/info/rfc8343>。"
    },
    {
      "indent": 3,
      "text": "[RFC8349] Lhotka, L., Lindem, A., and Y. Qu, \"A YANG Data Model for Routing Management (NMDA Version)\", RFC 8349, DOI 10.17487/RFC8349, March 2018, <https://www.rfc-editor.org/info/rfc8349>.",
      "ja": "[RFC8349] Lhotka、L.、Lindem、A.、およびY.屈原、 \"ルーティング管理のためのデータモデルYANG（NMDA版）\"、RFC 8349、DOI 10.17487 / RFC8349、2018年3月、<https：//でWWW。 rfc-editor.org/info/rfc8349>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Module Review Checklist",
      "ja": "付録A.モジュールレビューのチェックリスト"
    },
    {
      "indent": 3,
      "text": "This section is adapted from RFC 4181.",
      "ja": "このセクションでは、RFC 4181から構成されています。"
    },
    {
      "indent": 3,
      "text": "The purpose of a YANG module review is to review the YANG module for both technical correctness and adherence to IETF documentation requirements. The following checklist may be helpful when reviewing an I-D:",
      "ja": "YANGモジュールレビューの目的は、IETF文書化要件の両方の技術的な正確さと遵守のためのYANGモジュールを検討することです。 I-Dを検討する際、以下のチェックリストが役立つかもしれません。"
    },
    {
      "indent": 3,
      "text": "o I-D Boilerplate -- verify that the document contains the required I-D boilerplate (see <https://www.ietf.org/id-info/ guidelines.html>), including the appropriate statement to permit publication as an RFC, and that the I-D boilerplate does not contain references or section numbers.",
      "ja": "IDボイラープレートO  - ドキュメントはRFCとして公表を可能にする適切なステートメントを含む必要なIDボイラープレートを（<https://www.ietf.org/id-info/ guidelines.html>参照）、含ま、そのことを確認しIDの定型は、参照またはセクション番号が含まれていません。"
    },
    {
      "indent": 3,
      "text": "o Abstract -- verify that the abstract does not contain references, that it does not have a section number, and that its content follows the guidelines in <https://www.ietf.org/id-info/ guidelines.html>.",
      "ja": "抽象○ - それはセクションの番号を持っていないことを、抽象的には参照が含まれていないことを確認し、その内容は<https://www.ietf.org/id-info/ guidelines.html>のガイドラインに従うこと。"
    },
    {
      "indent": 3,
      "text": "o Copyright Notice -- verify that the document has the appropriate text regarding the rights that document contributors provide to the IETF Trust [RFC5378]. Verify that it contains the full IETF Trust copyright notice at the beginning of the document. The IETF Trust Legal Provisions (TLP) can be found at:",
      "ja": "O著作権 - 文書は、文書の貢献者は、IETFトラスト[RFC5378]に提供権利に関する適切なテキストを持っていることを確認してください。それは、文書の先頭に完全なIETFトラストの著作権情報が含まれていることを確認してください。 IETFトラスト法規定（TLP）はで見つけることができます："
    },
    {
      "indent": 6,
      "text": "<https://trustee.ietf.org/license-info/>",
      "ja": "＜ｈっｔｐｓ：／／ｔるｓてえ。いえｔｆ。おｒｇ／ぃせんせーいんふぉ／＞"
    },
    {
      "indent": 3,
      "text": "o Security Considerations section -- verify that the document uses the latest approved template from the Operations and Management (OPS) area website (see <https://trac.ietf.org/area/ops/trac/wiki/ yang-security-guidelines>) and that the guidelines therein have been followed.",
      "ja": "O Security Considerations部は - 文書は運用と管理（OPS）地区のウェブサイトから最新の承認テンプレートを使用していることを確認します（<https://trac.ietf.org/area/ops/trac/wiki/ヤン・セキュリティに見ますガイドライン>）とガイドラインが、その中に従っていること。"
    },
    {
      "indent": 3,
      "text": "o IANA Considerations section -- this section must always be present. For each module within the document, ensure that the IANA Considerations section contains entries for the following IANA registries:",
      "ja": "O IANAの考慮事項のセクション - このセクションでは、常に存在する必要があります。文書内の各モジュールのために、IANA Considerations部は、次のIANAレジストリのエントリが含まれていることを確認します。"
    },
    {
      "indent": 9,
      "text": "XML Namespace Registry: Register the YANG module namespace.",
      "ja": "XML名前空間レジストリ：YANGモジュールの名前空間を登録します。"
    },
    {
      "indent": 9,
      "text": "YANG Module Registry: Register the YANG module name, prefix, namespace, and RFC number, according to the rules specified in [RFC6020].",
      "ja": "YANGモジュールレジストリ：[RFC6020]で指定されたルールに従って、YANGモジュール名、接頭辞、名前空間、およびRFC番号を登録します。"
    },
    {
      "indent": 3,
      "text": "o References -- verify that the references are properly divided between normative and informative references, that RFCs 2119 and 8174 are included as normative references if the terminology defined therein is used in the document, that all references required by the boilerplate are present, that all YANG modules containing imported items are cited as normative references, and that all citations point to the most current RFCs, unless there is a valid reason to do otherwise (for example, it is okay to include an informative reference to a previous version of a specification to help explain a feature included for backward compatibility). Be sure citations for all imported modules are present somewhere in the document text (outside the YANG module). If a YANG module contains reference or \"description\" statements that refer to an I-D, then the I-D is included as an informative reference.",
      "ja": "O参照は - 定型によって必要とされる全ての参考文献は、そのすべての存在することを、その中に定義された用語が文書内で使用される場合のRFC 2119と8174を引用規格として含まれていることを、参照が正しく規範と有益参考間で分割されていることを確認しますインポートされた項目を含むYANGモジュールは全ての引用は、それ以外の場合は行うには正当な理由がない限り、最新のRFCを指していることを引用規格として引用されており（例えば、仕様の以前のバージョンに有益な言及を含むこと大丈夫です下位互換性のために含まれる特徴を説明するために）。すべてのインポートモジュールの引用は（YANGモジュール外）文書テキストのどこかに存在していることを確認してください。 YANGモジュールは、I-Dを参照する参照または「説明」の文が含まれている場合、I-Dは、有益参照として含まれます。"
    },
    {
      "indent": 3,
      "text": "o License -- verify that the document contains the Simplified BSD License in each YANG module or submodule. Some guidelines related to this requirement are described in Section 3.1. Make sure that the correct year is used in all copyright dates. Use the approved text from the latest TLP document, which can be found at:",
      "ja": "Oライセンス - ドキュメントは、各YANGモジュールまたはサブモジュールで簡体BSDライセンスが含まれていることを確認します。この要求に関連するいくつかのガイドラインは、3.1節で説明されています。正しい年は、すべての著作権の日付に使用されていることを確認してください。見つけることができる最新のTLPの文書から承認されたテキストを使用します。"
    },
    {
      "indent": 6,
      "text": "<https://trustee.ietf.org/license-info/>",
      "ja": "＜ｈっｔｐｓ：／／ｔるｓてえ。いえｔｆ。おｒｇ／ぃせんせーいんふぉ／＞"
    },
    {
      "indent": 3,
      "text": "o Other Issues -- check for any issues mentioned in <https://www.ietf.org/id-info/checklist.html> that are not covered elsewhere.",
      "ja": "その他の問題○ - 他の場所でカバーされていない<https://www.ietf.org/id-info/checklist.html>で述べたすべての問題を確認してください。"
    },
    {
      "indent": 3,
      "text": "o Technical Content -- review the actual technical content for compliance with the guidelines in this document. The use of a YANG module compiler is recommended when checking for syntax errors. A list of freely available tools and other information, including formatting advice, can be found at:",
      "ja": "O技術的な内容は - このドキュメントのガイドラインに準拠して、実際の技術的な内容を確認します。構文エラーをチェックするときYANGモジュールコンパイラの使用が推奨されます。アドバイスをフォーマットするなど、自由に利用できるツールやその他の情報のリストは、で見つけることができます："
    },
    {
      "indent": 6,
      "text": "<https://trac.ietf.org/trac/netconf/wiki> and <https://trac.ietf.org/trac/netmod/wiki>",
      "ja": "<https://trac.ietf.org/trac/netconf/wiki>と<https://trac.ietf.org/trac/netmod/wiki>"
    },
    {
      "indent": 6,
      "text": "Checking for correct syntax, however, is only part of the job. It is just as important to actually read the YANG module document from the point of view of a potential implementor. It is particularly important to check that \"description\" statements are sufficiently clear and unambiguous to allow interoperable implementations to be created.",
      "ja": "正しい構文のチェック、しかし、仕事の一部でしかありません。実際には潜在的な実装の観点からYANGモジュールのドキュメントを読むために同様に重要です。 「説明」の文は、相互運用可能な実装を作成することができるように十分に明確であいまいでないことを確認することが特に重要です。"
    },
    {
      "indent": 0,
      "text": "Appendix B. YANG Module Template",
      "ja": "付録B. YANGモジュールテンプレート"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-template@2016-03-20.yang\"",
      "ja": "ファイル \"ietf-template@2016-03-20.yang\" <CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "module ietf-template { yang-version 1.1;",
      "ja": "モジュールIETFテンプレート{陽バージョン1.1。"
    },
    {
      "indent": 5,
      "text": "// replace this string with a unique namespace URN value",
      "ja": "//一意の名前空間のURN値で、この文字列を置換"
    },
    {
      "indent": 5,
      "text": "namespace \"urn:ietf:params:xml:ns:yang:ietf-template\";",
      "ja": "名前空間 \"URN：IETF：のparams：XML：NS：ヤン：IETF-テンプレート\"。"
    },
    {
      "indent": 5,
      "text": "// replace this string, and try to pick a unique prefix",
      "ja": "//この文字列を置換し、独自の接頭辞を選択してみてください"
    },
    {
      "indent": 5,
      "text": "prefix temp;",
      "ja": "接頭辞温度;"
    },
    {
      "indent": 5,
      "text": "// import statements here: e.g., // import ietf-yang-types { prefix yang; } // import ietf-inet-types { prefix inet; } // identify the IETF working group if applicable",
      "ja": "ここで、//インポートステートメント：例えば、//インポートIETF-ヤン・タイプ{プレフィックス陽。 } //インポートIETF-INET-タイプ{プレフィックスINET。該当する場合} // IETFワーキンググループを識別"
    },
    {
      "indent": 5,
      "text": "organization \"IETF NETMOD (NETCONF Data Modeling Language) Working Group\";",
      "ja": "組織「IETF NETMOD（NETCONFデータモデリング言語）ワーキンググループ」。"
    },
    {
      "indent": 5,
      "text": "// update this contact statement with your info",
      "ja": "//あなたの情報と、この接触ステートメントを更新"
    },
    {
      "indent": 5,
      "text": "contact \"WG Web: <http://datatracker.ietf.org/wg/your-wg-name/> WG List: <mailto:your-wg-name@ietf.org>",
      "ja": "「連絡WGのWeb：<http://datatracker.ietf.org/wg/your-wg-name/> WG一覧：<mailtoの：your-wg-name@ietf.org>"
    },
    {
      "indent": 8,
      "text": "Editor: your-name <mailto:your-email@example.com>\";",
      "ja": "エディタ：あなたの名<のmailto：your-email@example.com> \";"
    },
    {
      "indent": 5,
      "text": "// replace the first sentence in this description statement. // replace the copyright notice with the most recent // version, if it has been updated since the publication // of this document",
      "ja": "//この説明文の最初の文を交換してください。 //それは、本書の出版//以降に更新されている場合は、最新の//バージョンと著作権情報を交換します"
    },
    {
      "indent": 5,
      "text": "description \"This module defines a template for other YANG modules.",
      "ja": "説明は「このモジュールは、他のYANGモジュールのテンプレートを定義します。"
    },
    {
      "indent": 8,
      "text": "Copyright (c) <insert year> IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "ja": "著作権（C）<挿入年> IETF信託コードの作者として特定の人物。全著作権所有。"
    },
    {
      "indent": 8,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFトラストの法律規定のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用"
    },
    {
      "indent": 8,
      "text": "Relating to IETF Documents (http://trustee.ietf.org/license-info).",
      "ja": "IETFドキュメント（http://trustee.ietf.org/license-info）に関連します。"
    },
    {
      "indent": 8,
      "text": "This version of this YANG module is part of RFC XXXX; see the RFC itself for full legal notices.\";",
      "ja": "このYANGモジュールのこのバージョンはRFC XXXXの一部です。完全な適法な通知についてはRFC自体を参照してください。 \";"
    },
    {
      "indent": 5,
      "text": "// RFC Ed.: replace XXXX with actual RFC number and remove // this note",
      "ja": "// RFCエド：実際のRFC番号でXXXXを交換し、//このノートを削除"
    },
    {
      "indent": 5,
      "text": "// replace '2016-03-20' with the module publication date // the format is (year-month-day)",
      "ja": "// //形式は、モジュール発行日に「2016年3月20日」を交換する（年 - 月 - 日）"
    },
    {
      "indent": 5,
      "text": "revision 2016-03-20 {\n  description\n    \"what changed in this revision\";\n  reference \"RFC XXXX: <Replace With Document Title>\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " // extension statements // feature statements // identity statements // typedef statements // grouping statements // data definition statements // augment statements // rpc statements // notification statements // DO NOT put deviation statements in a published module }",
      "ja": "//拡張文//機能ステートメント//アイデンティティ文//のtypedef文//グループ化文//データ定義文//公表モジュールに偏差文を入れないでくださいステートメント// RPC文//通知文を//強化}"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The structure and contents of this document are adapted from \"Guidelines for Authors and Reviewers of MIB Documents\" [RFC4181], by C. M. Heard.",
      "ja": "この文書の構造および内容はC. M.聞いたことにより、「MIBドキュメントの著者と査読のためのガイドライン」[RFC4181]から適合されています。"
    },
    {
      "indent": 3,
      "text": "The working group thanks Martin Bjorklund, Juergen Schoenwaelder, Ladislav Lhotka, Jernej Tuljak, Lou Berger, Robert Wilton, Kent Watsen, and William Lupton for their extensive reviews and contributions to this document.",
      "ja": "彼らの豊富なレビューと、この文書への貢献のためのワーキンググループのおかげでマーティンBjorklund、ユルゲンSchoenwaelder、ラディスラフLhotka、Jernej Tuljak、ルー・バーガー、ロバート・ウィルトン、ケントWatsen、そしてウィリアム・ラプトン。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Andy Bierman YumaWorks",
      "ja": "アンディBierman YumaWorks"
    },
    {
      "indent": 3,
      "text": "Email: andy@yumaworks.com",
      "ja": "メール：andy@yumaworks.com"
    }
  ]
}