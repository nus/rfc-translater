{
  "title": {
    "text": "RFC 8677 - Name-Based Service Function Forwarder (nSFF) Component within a Service Function Chaining (SFC) Framework",
    "ja": "RFC 8677 - サービス機能チェーン（SFC）フレームワーク内の名前ベースのサービス機能フォワーダー（nSFF）コンポーネント"
  },
  "number": 8677,
  "created_at": "2020-03-10 12:21:00.304626+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                        D. Trossen\nRequest for Comments: 8677                      InterDigital Europe, Ltd\nCategory: Informational                                   D. Purkayastha\nISSN: 2070-1721                                                A. Rahman\n                                        InterDigital Communications, LLC\n                                                           November 2019",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Name-Based Service Function Forwarder (nSFF) Component within a Service Function Chaining (SFC) Framework",
      "ja": "サービス機能チェーン（SFC）フレームワーク内の名前ベースのサービス機能フォワーダー（nSFF）コンポーネント"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Adoption of cloud and fog technology allows operators to deploy a single \"Service Function\" (SF) to multiple \"execution locations\". The decision to steer traffic to a specific location may change frequently based on load, proximity, etc. Under the current Service Function Chaining (SFC) framework, steering traffic dynamically to the different execution endpoints requires a specific \"rechaining\", i.e., a change in the service function path reflecting the different IP endpoints to be used for the new execution points. This procedure may be complex and take time. In order to simplify rechaining and reduce the time to complete the procedure, we discuss separating the logical Service Function Path (SFP) from the specific execution endpoints. This can be done by identifying the SFs using a name rather than a routable IP endpoint (or Layer 2 address). This document describes the necessary extensions, additional functions, and protocol details in the Service Function Forwarder (SFF) to handle name-based relationships.",
      "ja": "クラウドおよびフォグテクノロジーの採用により、オペレーターは単一の「サービス機能」（SF）を複数の「実行場所」に展開できます。特定の場所にトラフィックを誘導する決定は、負荷、近接などに基づいて頻繁に変更される場合があります。現在のサービス機能連鎖（SFC）フレームワークでは、異なる実行エンドポイントにトラフィックを動的に誘導するには、特定の「再連鎖」、つまり変更が必要です新しい実行ポイントに使用されるさまざまなIPエンドポイントを反映するサービス機能パス。この手順は複雑で時間がかかる場合があります。再連鎖を簡素化し、手順を完了する時間を短縮するために、特定の実行エンドポイントから論理的なService Function Path（SFP）を分離することについて説明します。これは、ルーティング可能なIPエンドポイント（またはレイヤー2アドレス）ではなく名前を使用してSFを識別することで実行できます。このドキュメントでは、名前ベースの関係を処理するために必要な拡張機能、追加機能、およびService Function Forwarder（SFF）のプロトコルの詳細について説明します。"
    },
    {
      "indent": 3,
      "text": "This document presents InterDigital's approach to name-based SFC. It does not represent IETF consensus and is presented here so that the SFC community may benefit from considering this mechanism and the possibility of its use in the edge data centers.",
      "ja": "このドキュメントは、名前ベースのSFCへのInterDigitalのアプローチを示しています。 これはIETFコンセンサスを表していないため、SFCコミュニティがこのメカニズムとエッジデータセンターでの使用の可能性を検討することで利益を得ることができるように、ここで説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 情報提供を目的として公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。 RFCエディターは、このドキュメントをその裁量で公開することを選択しており、実装または展開の価値については何も表明していません。 RFC Editorによる公開が承認されたドキュメントは、どのレベルのインターネット標準の候補でもありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8677.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8677で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 2. Terminology 3. Example Use Case: 5G Control-Plane Services 4. Background 4.1. Relevant Part of SFC Architecture 4.2. Challenges with Current Framework 5. Name-Based Operation in SFF 5.1. General Idea 5.2. Name-Based Service Function Path (nSFP) 5.3. Name-Based Network Locator Map (nNLM) 5.4. Name-Based Service Function Forwarder (nSFF) 5.5. High-Level Architecture 5.6. Operational Steps 6. nSFF Forwarding Operations 6.1. nSFF Protocol Layers 6.2. nSFF Operations 6.2.1. Forwarding between nSFFs and nSFF-NRs 6.2.2. SF Registration 6.2.3. Local SF Forwarding 6.2.4. Handling of HTTP Responses 6.2.5. Remote SF Forwarding 7. IANA Considerations 8. Security Considerations 9. References 9.1. Normative References 9.2. Informative References Acknowledgements Authors' Addresses",
      "ja": "1. はじめに2.用語3.使用例：5Gコントロールプレーンサービス4.背景4.1。 SFCアーキテクチャの関連部分4.2。 現在のフレームワークの課題5. SFF 5.1での名前ベースの操作。 一般的なアイデア5.2。 名前ベースのサービス機能パス（nSFP）5.3。 名前ベースのネットワークロケーターマップ（nNLM）5.4。 名前ベースのサービス機能フォワーダー（nSFF）5.5。 高レベルのアーキテクチャ5.6。 操作手順6. nSFF転送操作6.1。 nSFFプロトコルレイヤー6.2。 nSFF操作6.2.1。 nSFFとnSFF-NR間の転送6.2.2。 SF登録6.2.3。 ローカルSF転送6.2.4。 HTTP応答の処理6.2.5。 リモートSF転送7. IANAに関する考慮事項8.セキュリティに関する考慮事項9.参考文献9.1。 規範的な参考文献9.2。 参考情報謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The requirements on today's networks are very diverse, enabling multiple use cases such as the Internet of Things (IoT), Content Distribution, Gaming, and Network functions such as Cloud Radio Access Network (RAN) and 5G control planes based on a Service-Based Architecture (SBA). These services are deployed, provisioned, and managed using Cloud-based techniques as seen in the IT world. Virtualization of compute and storage resources is at the heart of providing (often web) services to end users with the ability to quickly provision virtualized service endpoints through, e.g., container-based techniques. This creates the ability to dynamically compose new services from existing services. It also allows an operator to move a service instance in response to user mobility or to change resource availability. When moving from a purely \"distant cloud\" model to one of localized micro data centers with regional, metro, or even street level, often called \"edge\" data centers, such virtualized service instances can be instantiated in topologically different locations with the overall \"distant\" data center now being transformed into a network of distributed ones. The reaction of content providers, like Facebook, Google, NetFlix, and others, is not just to rely on deploying content servers at the ingress of the customer network. Instead, the trend is towards deploying multiple Point of Presences (POPs) within the customer network, those POPs being connected through proprietary mechanisms [Schlinker2017] to push content.",
      "ja": "今日のネットワークの要件は非常に多様であり、モノのインターネット（IoT）、コンテンツ配信、ゲーム、クラウド無線アクセスネットワーク（RAN）などのネットワーク機能や、サービスベースの5Gコントロールプレーンなどの複数のユースケースを可能にしますアーキテクチャ（SBA）。これらのサービスは、ITの世界で見られるクラウドベースの技術を使用して展開、プロビジョニング、管理されます。コンピューティングリソースとストレージリソースの仮想化は、コンテナベースの手法などにより仮想化されたサービスエンドポイントを迅速にプロビジョニングする機能を備えた（多くの場合、Web）サービスをエンドユーザーに提供するための中核ですこれにより、既存のサービスから新しいサービスを動的に構成する機能が作成されます。また、オペレータは、ユーザーのモビリティに応じてサービスインスタンスを移動したり、リソースの可用性を変更したりできます。 「エッジ」データセンターと呼ばれる地域レベル、メトロレベル、さらにはストリートレベルのローカライズされたマイクロデータセンターのいずれかに純粋に「遠いクラウド」モデルから移行する場合、このような仮想化サービスインスタンスは、全体的に「現在、分散型のネットワークに変換されつつあります。 Facebook、Google、NetFlixなどのコンテンツプロバイダーの反応は、顧客ネットワークの入口にコンテンツサーバーを配置するだけではありません。代わりに、顧客ネットワーク内に複数のPoint of Presence（POP）を展開する傾向があり、それらのPOPはコンテンツをプッシュする独自のメカニズム[Schlinker2017]を介して接続されます。"
    },
    {
      "indent": 3,
      "text": "The Service Function Chaining (SFC) framework [RFC7665] allows network operators as well as service providers to compose new services by chaining individual \"service functions\". Such chains are expressed through explicit relationships of functional components (the SFs) realized through their direct Layer 2 (e.g., Media Access Control (MAC) address) or Layer 3 (e.g., IP address) relationship as defined through next-hop information that is being defined by the network operator. See Section 4 for more background on SFC.",
      "ja": "Service Function Chaining（SFC）フレームワーク[RFC7665]により、ネットワークオペレーターとサービスプロバイダーは、個々の「サービス機能」をチェーン化することにより、新しいサービスを構成できます。 このようなチェーンは、ネクストホップ情報で定義される直接的なレイヤー2（メディアアクセス制御（MAC）アドレスなど）またはレイヤー3（IPアドレスなど）の関係を通じて実現される機能コンポーネント（SF）の明示的な関係によって表現されます ネットワークオペレータによって定義されています。 SFCの背景については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "In a dynamic service environment of distributed data centers such as the one outlined above, with the ability to create and recreate service endpoints frequently, the SFC framework requires reconfiguring the existing chain through information based on the new relationships, causing overhead in a number of components, specifically the orchestrator that initiates the initial SFC and any possible reconfiguration.",
      "ja": "上記のような分散データセンターの動的なサービス環境では、サービスエンドポイントを頻繁に作成および再作成できるため、SFCフレームワークでは、新しい関係に基づく情報を使用して既存のチェーンを再構成する必要があり、多くのコンポーネントでオーバーヘッドが発生します 、特に初期SFCおよび可能な再構成を開始するオーケストレーター。"
    },
    {
      "indent": 3,
      "text": "This document describes how such changes can be handled without involving the initiation of new and reconfigured SFCs. This is accomplished by lifting the chaining relationship from Layer 2 and Layer 3 information to that of SF \"names\", which can, for instance, be expressed as URIs. In order to transparently support such named relationships, we propose to embed the necessary functionality directly into the Service Function Forwarder (SFF) as described in [RFC7665]. With that, the SFF described in this document allows for keeping an existing SFC intact, as described by its Service Function Path (SFP), while enabling the selection of appropriate service function endpoint(s) during the traversal of packets through the SFC. This document is an Independent Submission to the RFC Editor. It is not an output of the IETF SFC WG.",
      "ja": "このドキュメントでは、新規および再構成されたSFCの開始を伴うことなく、このような変更を処理する方法について説明します。 これは、連鎖関係をレイヤー2およびレイヤー3の情報から、SFの「名前」の情報に持ち上げることによって実現されます。SFの「名前」は、たとえばURIとして表現できます。 このような名前付きの関係を透過的にサポートするために、[RFC7665]で説明されているように、必要な機能をService Function Forwarder（SFF）に直接埋め込むことを提案します。 そのため、このドキュメントで説明するSFFでは、サービス機能パス（SFP）で説明されているように、SFCを介したパケットのトラバース中に適切なサービス機能エンドポイントを選択できるように、既存のSFCをそのまま保持できます。 このドキュメントは、RFC Editorへの独立した提出です。 IETF SFC WGの出力ではありません。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Example Use Case: 5G Control-Plane Services",
      "section_title": true,
      "ja": "3. 使用例：5Gコントロールプレーンサービス"
    },
    {
      "indent": 3,
      "text": "We exemplify the need for chaining SFs at the level of a service name through a use case stemming from the current 3GPP Release 16 work on Service Based Architecture (SBA) [SDO-3GPP-SBA], [SDO-3GPP-SBA-ENHANCEMENT]. In this work, mobile network control planes are proposed to be realized by replacing the traditional network function interfaces with a fully service-based one. HTTP was chosen as the application-layer protocol for exchanging suitable service requests [SDO-3GPP-SBA]. With this in mind, the exchange between, for example, the 3GPP-defined (Rel. 15) Session Management Function (SMF) and the Access and Mobility Management Function (AMF) in a 5G control plane is being described as a set of web-service-like requests that are, in turn, embedded into HTTP requests. Hence, interactions in a 5G control plane can be modeled based on SFCs where the relationship is between the specific (IP-based) SF endpoints that implement the necessary service endpoints in the SMF and AMF. The SFs are exposed through URIs with work ongoing to define the used naming conventions for such URIs.",
      "ja": "サービスベースアーキテクチャ（SBA）の現在の3GPPリリース16の作業[SDO-3GPP-SBA]、[SDO-3GPP-SBA-ENHANCEMENT]から生じるユースケースを通じて、サービス名のレベルでSFをチェーンする必要性を例示します。 。この作業では、モバイルネットワークコントロールプレーンを、従来のネットワーク機能インターフェイスを完全にサービスベースのインターフェイスに置き換えることで実現することを提案します。 HTTPは、適切なサービスリクエストを交換するためのアプリケーション層プロトコルとして選択されました[SDO-3GPP-SBA]。これを念頭に置いて、たとえば、5Gコントロールプレーンでの3GPP定義（Rel。15）セッション管理機能（SMF）とアクセスおよびモビリティ管理機能（AMF）間の交換は、一連のWebとして説明されています。 -次に、HTTPリクエストに埋め込まれるサービスのようなリクエスト。したがって、SMFとAMFに必要なサービスエンドポイントを実装する特定の（IPベースの）SFエンドポイント間の関係であるSFCに基づいて、5Gコントロールプレーンの相互作用をモデル化できます。 SFはURIを介して公開され、そのようなURIに使用される命名規則を定義する作業が進行中です。"
    },
    {
      "indent": 3,
      "text": "This move from a network function model (in pre-Release 15 systems of 3GPP) to a service-based model is motivated through the proliferation of data-center operations for mobile network control-plane services. In other words, typical IT-based methods to service provisioning, particularly that of virtualization of entire compute resources, are envisioned to being used in future operations of mobile networks. Hence, operators of such future mobile networks desire to virtualize SF endpoints and direct (control-plane) traffic to the most appropriate current service instance in the most appropriate (local) data center. Such a data center is envisioned as being interconnected through a software-defined wide area network (SD-WAN). \"Appropriate\" here can be defined by topological or geographical proximity of the service initiator to the SF endpoint. Alternatively, network or service instance compute load can be used to direct a request to a more appropriate (in this case less loaded) instance to reduce possible latency of the overall request. Such data-center-centric operation is extended with the trend towards regionalization of load through a \"regional office\" approach, where micro data centers provide virtualizable resources that can be used in the service execution, creating a larger degree of freedom when choosing the \"most appropriate\" service endpoint for a particular incoming service request.",
      "ja": "ネットワーク機能モデル（3GPPのリリース15より前のシステム）からサービスベースのモデルへのこの移行は、モバイルネットワークコントロールプレーンサービスのデータセンター運用の急増により動機付けられています。言い換えれば、サービスプロビジョニングの一般的なITベースの方法、特にコンピューティングリソース全体の仮想化は、モバイルネットワークの将来の運用で使用されることが想定されています。したがって、このような将来のモバイルネットワークのオペレーターは、SFエンドポイントを仮想化し、最適な（ローカル）データセンターの最適な現在のサービスインスタンスに（コントロールプレーン）トラフィックを向けることを望んでいます。このようなデータセンターは、ソフトウェア定義のワイドエリアネットワーク（SD-WAN）を介して相互接続されていると想定されています。ここでの「適切な」とは、サービス開始者がSFエンドポイントにトポロジ的または地理的に近いことで定義できます。または、ネットワークまたはサービスインスタンスの計算負荷を使用して、より適切な（この場合は負荷の少ない）インスタンスに要求を送信し、要求全体の潜在的な待機時間を削減できます。このようなデータセンター中心の運用は、「地域オフィス」アプローチによる負荷の地域化の傾向に合わせて拡張されます。マイクロデータセンターは、サービス実行で使用できる仮想化可能なリソースを提供し、「特定の着信サービス要求に最も適切な」サービスエンドポイント。"
    },
    {
      "indent": 3,
      "text": "While the move to a service-based model aligns well with the framework of SFC, choosing the most appropriate service instance at runtime requires so-called \"rechaining\" of the SFC since the relationships in said SFC are defined through Layer 2 or Layer 3 identifiers, which, in turn, are likely to be different if the chosen service instances reside in different parts of the network (e.g., in a regional data center).",
      "ja": "サービスベースのモデルへの移行はSFCのフレームワークとうまく調和していますが、実行時に最適なサービスインスタンスを選択するには、SFCの関係がレイヤー2またはレイヤー3識別子によって定義されるため、SFCのいわゆる「リチェーン」が必要です 、選択されたサービスインスタンスがネットワークの異なる部分（たとえば、地域のデータセンター）に存在する場合、同様に異なる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Hence, when a traffic flow is forwarded over a service chain expressed as an SFC-compliant SFP, packets in the traffic flow are processed by the various SF instances, with each SF instance applying an SF prior to forwarding the packets to the next network node. It is a service-layer concept and can possibly work over any Virtual network layer and corresponding underlay network. The underlay network can be IP or alternatively any Layer 2 technology. At the service layer, SFs are identified using a path identifier and an index. Eventually, this index is translated to an IP address (or MAC address) of the host where the SF is running. Because of this, any change-of-service function instance is likely to require a change of the path information since either the IP address (in the case of changing the execution from one data center to another) or MAC address will change due to the newly selected SF instance.",
      "ja": "したがって、トラフィックフローがSFC準拠のSFPとして表されるサービスチェーンを介して転送されると、トラフィックフローのパケットはさまざまなSFインスタンスによって処理され、各SFインスタンスは次のネットワークノードにパケットを転送する前にSFを適用します 。 これはサービスレイヤーの概念であり、任意の仮想ネットワークレイヤーおよび対応するアンダーレイネットワーク上で動作する可能性があります。 アンダーレイネットワークはIPでも、レイヤー2テクノロジーでもかまいません。 サービス層では、パス識別子とインデックスを使用してSFが識別されます。 最終的に、このインデックスは、SFが実行されているホストのIPアドレス（またはMACアドレス）に変換されます。 このため、IPアドレス（1つのデータセンターから別のデータセンターに実行を変更する場合）またはMACアドレスのいずれかが変更されるため、サービス変更機能インスタンスはパス情報の変更を必要とする可能性があります。 新しく選択されたSFインスタンス。"
    },
    {
      "indent": 3,
      "text": "Returning to our 5G control-plane example, a user's connection request to access an application server in the Internet may start with signaling in the control plane to set up user-plane bearers. The connection request may flow through SFs over a service chain in the control plane, as deployed by a network operator. Typical SFs in a 5G control plane may include \"RAN termination / processing\", \"Slice Selection Function\", \"AMF\", and \"SMF\". A \"Network Slice\" is a complete logical network including Radio Access Network (RAN) and Core Network (CN). Distinct RAN and CN Slices may exist. A device may access multiple Network Slices simultaneously through a single RAN. The device may provide Network Slice Selection Assistance Information (NSSAI) parameters to the network to help it select a RAN and a Core Network part of a slice instance. Part of the control plane, the Common Control Network Function (CCNF), includes the Network Slice Selection Function (NSSF), which is in charge of selecting core Network Slice instances. The classifier, as described in SFC architecture, may reside in the user terminal or at the Evolved Node B (eNB). These SFs can be configured to be part of an SFC. We can also say that some of the configurations of the SFP may change at the execution time. For example, the SMF may be relocated as the user moves and a new SMF may be included in the SFP based on user location. Figure 1 shows the example SFC described here.",
      "ja": "5Gコントロールプレーンの例に戻ると、インターネットのアプリケーションサーバーにアクセスするためのユーザーの接続要求は、コントロールプレーンでのシグナリングから始まり、ユーザープレーンのベアラーをセットアップします。接続要求は、ネットワークオペレータによって展開されるように、コントロールプレーンのサービスチェーンを介してSFを介して流れる場合があります。 5G制御プレーンの一般的なSFには、「RAN終了/処理」、「スライス選択機能」、「AMF」、および「SMF」が含まれます。 「ネットワークスライス」は、無線アクセスネットワーク（RAN）およびコアネットワーク（CN）を含む完全な論理ネットワークです。異なるRANおよびCNスライスが存在する場合があります。デバイスは、単一のRANを介して複数のネットワークスライスに同時にアクセスできます。デバイスは、ネットワークスライス選択支援情報（NSSAI）パラメーターをネットワークに提供して、RANおよびスライスインスタンスのコアネットワーク部分を選択できるようにします。コントロールプレーンの一部である共通制御ネットワーク機能（CCNF）には、コアネットワークスライスインスタンスの選択を担当するネットワークスライス選択機能（NSSF）が含まれています。分類器は、SFCアーキテクチャで説明されているように、ユーザー端末またはEvolved Node B（eNB）に存在します。これらのSFは、SFCの一部として構成できます。また、SFPの構成の一部は実行時に変更される可能性があると言えます。たとえば、ユーザーの移動に応じてSMFを再配置し、ユーザーの場所に基づいて新しいSMFをSFPに含めることができます。図1は、ここで説明するSFCの例を示しています。"
    },
    {
      "indent": 15,
      "text": "+------+   +---------+  +-----+   +-----+\n| User |   | Slice   |  |     |   |     |\n| App  |-->| Control |->| AMF |-->| SMF |-->\n| Fn   |   | Function|  |     |   |     |\n+------+   +---------+  +-----+   +-----+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 1: Mapping SFC onto Service Function Execution Points along a Service Function Path",
      "ja": "図1：サービス機能パスに沿ったサービス機能実行ポイントへのSFCのマッピング"
    },
    {
      "indent": 0,
      "text": "4. Background",
      "section_title": true,
      "ja": "4. バックグラウンド"
    },
    {
      "indent": 3,
      "text": "[RFC7665] describes an architecture for the specification, creation, and ongoing maintenance of SFCs. It includes architectural concepts, principles, and components used in the construction of composite services through deployment of SFCs. In the following, we outline the parts of this SFC architecture relevant for our proposed extension, followed by the challenges with this current framework in the light of our example use case.",
      "ja": "[RFC7665]は、SFCの仕様、作成、および継続的なメンテナンスのアーキテクチャについて説明しています。 SFCの展開による複合サービスの構築に使用されるアーキテクチャの概念、原則、およびコンポーネントが含まれます。 以下では、提案された拡張に関連するこのSFCアーキテクチャの部分の概要を説明し、次に、使用例の観点からこの現在のフレームワークでの課題を示します。"
    },
    {
      "indent": 0,
      "text": "4.1. Relevant Part of SFC Architecture",
      "section_title": true,
      "ja": "4.1. SFCアーキテクチャの関連部分"
    },
    {
      "indent": 3,
      "text": "The SFC architecture, as defined in [RFC7665], describes architectural components such as SF, classifier, and SFF. It describes the SFP as the logical path of an SFC. Forwarding traffic along such an SFP is the responsibility of the SFF. For this, the SFFs in a network maintain the requisite SFP forwarding information. Such SFP forwarding information is associated with a service path identifier (SPI) that is used to uniquely identify an SFP. The service forwarding state is represented by the Service Index (SI) and enables an SFF to identify which SFs of a given SFP should be applied, and in what order. The SFF also has information that allows it to forward packets to the next SFF after applying local SFs.",
      "ja": "[RFC7665]で定義されているSFCアーキテクチャは、SF、分類子、SFFなどのアーキテクチャコンポーネントを説明しています。 SFPをSFCの論理パスとして説明します。 このようなSFPに沿ったトラフィックの転送は、SFFの責任です。 このため、ネットワーク内のSFFは必要なSFP転送情報を保持します。 このようなSFP転送情報は、SFPを一意に識別するために使用されるサービスパス識別子（SPI）に関連付けられています。 サービス転送状態はサービスインデックス（SI）で表され、SFFが特定のSFPのどのSFをどの順序で適用するかを識別できるようにします。 SFFには、ローカルSFを適用した後に次のSFFにパケットを転送できる情報もあります。"
    },
    {
      "indent": 3,
      "text": "The operational steps to forward traffic are then as follows: Traffic arrives at an SFF from the network. The SFF determines the appropriate SF the traffic should be forwarded to via information contained in the SFC encapsulation. After SF processing, the traffic is returned to the SFF and, if needed, is forwarded to another SF associated with that SFF. If there is another non-local hop (i.e., to an SF with a different SFF) in the SFP, the SFF further encapsulates the traffic in the appropriate network transport protocol and delivers it to the network for delivery to the next SFF along the path. Related to this forwarding responsibility, an SFF should be able to interact with metadata.",
      "ja": "トラフィックを転送する操作手順は次のとおりです。トラフィックはネットワークからSFFに到着します。 SFFは、SFCカプセル化に含まれる情報を介してトラフィックを転送する適切なSFを決定します。 SF処理後、トラフィックはSFFに返され、必要に応じて、そのSFFに関連付けられた別のSFに転送されます。 SFPに別の非ローカルホップ（つまり、SFFが異なるSF）がある場合、SFFはさらに適切なネットワークトランスポートプロトコルでトラフィックをカプセル化し、パスに沿って次のSFFに配信するためにネットワークに配信します 。 この転送の責任に関連して、SFFはメタデータと対話できる必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Challenges with Current Framework",
      "section_title": true,
      "ja": "4.2. 現在のフレームワークの課題"
    },
    {
      "indent": 3,
      "text": "As outlined in previous sections, the SFP defines an ordered sequence of specific SF instances being used for the interaction between initiator and SFs along the SFP. These SFs are addressed by IP (or any L2/MAC) addresses and defined as next-hop information in the network locator maps of traversing SFF nodes.",
      "ja": "前のセクションで概説したように、SFPは、SFPに沿ったイニシエーターとSF間の対話に使用される特定のSFインスタンスの順序付けられたシーケンスを定義します。 これらのSFは、IP（またはL2 / MAC）アドレスによってアドレス指定され、通過するSFFノードのネットワークロケーターマップでネクストホップ情報として定義されます。"
    },
    {
      "indent": 3,
      "text": "As outlined in our use case, however, the service provider may want to provision SFC nodes based on dynamically spun-up SF instances so that these (now virtualized) SFs can be reached in the SFC domain using the SFC underlay layer.",
      "ja": "ただし、ユースケースで概説したように、サービスプロバイダーは、SFCアンダーレイレイヤーを使用してSFCドメインでこれらの（現在仮想化された）SFに到達できるように、動的にスピンアップされたSFインスタンスに基づいてSFCノードをプロビジョニングする場合があります。"
    },
    {
      "indent": 3,
      "text": "Following the original model of SFC, any change in a specific execution point for a specific SF along the SFP will require a change of the SFP information (since the new SF execution point likely carries different IP or L2 address information) and possibly even the next-hop information in SFFs along the SFP. In case the availability of new SF instances is rather dynamic (e.g., through the use of container-based virtualization techniques), the current model and realization of SFC could lead to reducing the flexibility of service providers and increasing the management complexity incurred by the frequent changes of (service) forwarding information in the respective SFF nodes. This is because any change of the SFP (and possibly next-hop info) will need to go through suitable management cycles.",
      "ja": "SFCの元のモデルに従って、SFPに沿った特定のSFの特定の実行ポイントを変更するには、SFP情報を変更する必要があります（新しいSF実行ポイントは異なるIPまたはL2アドレス情報を保持する可能性が高いため） -SFPに沿ったSFFのホップ情報。 新しいSFインスタンスの可用性がかなり動的な場合（コンテナベースの仮想化技術の使用など）、SFCの現在のモデルと実現により、サービスプロバイダーの柔軟性が低下し、頻繁に発生する管理の複雑さが増す可能性があります 各SFFノードの（サービス）転送情報の変更。 これは、SFPの変更（および場合によってはネクストホップ情報）が適切な管理サイクルを実行する必要があるためです。"
    },
    {
      "indent": 3,
      "text": "To address these challenges through a suitable solution, we identify the following requirements:",
      "ja": "適切なソリューションを通じてこれらの課題に対処するために、次の要件を特定します。"
    },
    {
      "indent": 3,
      "text": "* Relations between Service Execution Points MUST be abstracted so that, from an SFP point of view, the Logical Path never changes.",
      "ja": "* SFPの観点から論理パスが変更されないように、サービス実行ポイント間の関係を抽象化する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Deriving the Service Execution Points from the abstract SFP SHOULD be fast and incur minimum delay.",
      "ja": "* 抽象SFPからのサービス実行ポイントの取得は高速であり、最小限の遅延が発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Identification of the Service Execution Points SHOULD NOT use a combination of Layer 2 or Layer 3 mechanisms.",
      "ja": "* サービス実行ポイントの識別では、レイヤー2またはレイヤー3メカニズムの組み合わせを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The next section outlines a solution to address the issue, allowing for keeping SFC information (represented in its SFP) intact while addressing the desired flexibility of the service provider.",
      "ja": "次のセクションでは、問題に対処するソリューションの概要を説明し、SFC情報（SFPで表される）をそのまま維持しながら、サービスプロバイダーの望ましい柔軟性に対処します。"
    },
    {
      "indent": 0,
      "text": "5. Name-Based Operation in SFF",
      "section_title": true,
      "ja": "5. SFFでの名前ベースの操作"
    },
    {
      "indent": 0,
      "text": "5.1. General Idea",
      "section_title": true,
      "ja": "5.1. 一般的なアイデア"
    },
    {
      "indent": 3,
      "text": "The general idea is two pronged. Firstly, we elevate the definition of an SFP onto the level of \"name-based interactions\" rather than limiting SFPs to Layer 2 or Layer 3 information only. Secondly, we extend the operations of the SFF to allow for forwarding decisions that take into account such name-based interaction while remaining backward compatible to the current SFC architecture as defined in [RFC7665]. In the following sections, we outline these two components of our solution.",
      "ja": "一般的な考え方は2つあります。 まず、SFPをレイヤー2またはレイヤー3情報のみに制限するのではなく、SFPの定義を「名前ベースの相互作用」のレベルに引き上げます。 次に、SRFの操作を拡張して、[RFC7665]で定義されている現在のSFCアーキテクチャとの下位互換性を維持しながら、このような名前ベースの相互作用を考慮した転送決定を可能にします。 次のセクションでは、ソリューションのこれら2つのコンポーネントの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "If the next-hop information in the Network Locator Map (NLM) is described using an L2/L3 identifier, the name-based SFF (nSFF) may operate as described for (traditional) SFF, as defined in [RFC7665]. On the other hand, if the next-hop information in the NLM is described as a name, then the nSFF operates as described in the following sections.",
      "ja": "ネットワークロケーターマップ（NLM）のネクストホップ情報がL2 / L3識別子を使用して記述されている場合、名前ベースのSFF（nSFF）は、[RFC7665]で定義されている（従来の）SFFで説明されているように動作します。 一方、NLMのネクストホップ情報が名前として記述されている場合、nSFFは次のセクションで説明されているように動作します。"
    },
    {
      "indent": 3,
      "text": "In the following sections, we outline the two components of our solution.",
      "ja": "以下のセクションでは、ソリューションの2つのコンポーネントの概要を説明します。"
    },
    {
      "indent": 0,
      "text": "5.2. Name-Based Service Function Path (nSFP)",
      "section_title": true,
      "ja": "5.2. 名前ベースのサービス機能パス（nSFP）"
    },
    {
      "indent": 3,
      "text": "The existing SFC framework is defined in [RFC7665]. Section 4 outlines that the SFP information is representing path information based on Layer 2 or Layer 3 information, i.e., MAC or IP addresses, causing the aforementioned frequent adaptations in cases of execution-point changes. Instead, we introduce the notion of a \"name-based Service Function Path (nSFP)\".",
      "ja": "既存のSFCフレームワークは[RFC7665]で定義されています。 セクション4では、SFP情報がレイヤー2またはレイヤー3の情報、つまりMACまたはIPアドレスに基づいてパス情報を表し、実行ポイントが変更された場合に前述の頻繁な適応を引き起こすことを概説しています。 代わりに、「名前ベースのサービス機能パス（nSFP）」の概念を紹介します。"
    },
    {
      "indent": 3,
      "text": "In today's networking terms, any identifier can be treated as a name, but we will illustrate the realization of a \"Name-based SFP\" through extended SFF operations (see Section 6) based on URIs as names and HTTP as the protocol of exchanging information. Here, URIs are being used to name for an SF along the nSFP. Note that the nSFP approach is not restricted to HTTP (as the protocol) and URIs (as next-hop identifier within the SFP). Other identifiers such as an IP address itself can also be used and are interpreted as a \"name\" in the nSFP. IP addresses as well as fully qualified domain names forming complex URIs (uniform resource identifiers), such as www.example.com/ service_name1, are all captured by the notion of \"name\" in this document.",
      "ja": "今日のネットワーキング用語では、任意の識別子を名前として扱うことができますが、名前としてのURIと情報交換のプロトコルとしてのHTTPに基づく拡張SFF操作（セクション6を参照）による「名前ベースのSFP」の実現について説明します 。 ここでは、URIを使用して、nSFPに沿ってSFに名前を付けています。 nSFPアプローチは、HTTP（プロトコルとして）およびURI（SFP内のネクストホップ識別子として）に制限されないことに注意してください。 IPアドレス自体などの他の識別子も使用でき、nSFPでは「名前」として解釈されます。 IPアドレスと、www.example.com / service_name1などの複雑なURI（統一リソース識別子）を形成する完全修飾ドメイン名はすべて、このドキュメントの「名前」という概念によってキャプチャされます。"
    },
    {
      "indent": 3,
      "text": "Generally, nSFPs are defined as an ordered sequence of the \"name\" of SFs, and a typical nSFP may look like: 192.0.x.x -> www.example.com -> www.example2.com/service1 -> www.example2.com/service2.",
      "ja": "一般に、nSFPはSFの「名前」の順序付きシーケンスとして定義され、一般的なnSFPは次のようになります。192.0.xx-> www.example.com-> www.example2.com/service1-> www.example2 com / service2。"
    },
    {
      "indent": 3,
      "text": "Our use case in Section 3 can then be represented as an ordered named sequence. An example for a session initiation that involves an authentication procedure, this could look like 192.0.x.x -> smf.example.org/session_initiate -> amf.example.org/auth -> smf.example.org/session_complete -> 192.0.x.x. (Note that this example is only a conceptual one since the exact nature of any future SBA-based exchange of 5G control-plane functions is yet to be defined by standardization bodies such as 3GPP).",
      "ja": "セクション3のユースケースは、順序付けられた名前付きシーケンスとして表すことができます。 認証手順を伴うセッション開始の例は、192.0.xx-> smf.example.org/session_initiate-> amf.example.org/auth-> smf.example.org/session_complete-> 192.0のようになります。 xx （5Gコントロールプレーン機能の将来のSBAベースの交換の正確な性質は、まだ3GPPなどの標準化団体によって定義されていないため、この例は概念的なものにすぎないことに注意してください）。"
    },
    {
      "indent": 3,
      "text": "In accordance with our use case in Section 3, any of these named services can potentially be realized through more than one replicated SF instance. This leads to making dynamic decisions on where to send packets along the SAME SFP information, being provided during the execution of the SFC. Through elevating the SFP onto the notion of name-based interactions, the SFP will remain the same even if those specific execution points change for a specific service interaction.",
      "ja": "セクション3の使用例によれば、これらの名前付きサービスはいずれも、複数の複製されたSFインスタンスを通じて実現される可能性があります。 これにより、SFCの実行中に提供される、同じSFP情報に沿ってパケットを送信する場所を動的に決定できます。 SFPを名前ベースのインタラクションの概念に引き上げることにより、特定のサービスインタラクションで特定の実行ポイントが変更されても、SFPは同じままになります。"
    },
    {
      "indent": 3,
      "text": "The following diagram in Figure 2 describes this nSFP concept and the resulting mapping of those named interactions onto (possibly) replicated instances.",
      "ja": "図2の次の図は、このnSFPの概念と、それらの名前付きインタラクションの（場合によっては）複製されたインスタンスへのマッピングの結果を示しています。"
    },
    {
      "indent": 5,
      "text": "+---------------------------------------------------------------+\n|Service Layer                                                  |\n| 192.0.x.x --> www.example.com --> www.example2.com -->        |\n|                      ||              ||                       |\n+----------------------||--------------||-----------------------+\n                       ||              ||\n                       ||              ||\n+----------------------||--------------||-----------------------+\n|Underlay Network      \\/              \\/                       |\n|               +--+ +--+ +--+    +--+ +--+ +--+                |\n|               |  | |  | |  |    |  | |  | |  |                |\n|               +--+ +--+ +--+    +--+ +--+ +--+                |\n|               Compute and       Compute and                   |\n|               storage nodes     storage nodes                 |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 2: Mapping SFC onto Service Function Execution Points along a Service Function Path Based on Virtualized Service Function Instance",
      "ja": "図2：仮想化されたサービス機能インスタンスに基づいたサービス機能パスに沿ったサービス機能実行ポイントへのSFCのマッピング"
    },
    {
      "indent": 0,
      "text": "5.3. Name-Based Network Locator Map (nNLM)",
      "section_title": true,
      "ja": "5.3. 名前ベースのネットワークロケーターマップ（nNLM）"
    },
    {
      "indent": 3,
      "text": "In order to forward a packet within an nSFP, we need to extend the NLM as defined in [RFC8300] with the ability to consider name relations based on URIs as well as high-level transport protocols such as HTTP for means of SFC packet forwarding. Another example for SFC packet forwarding could be that of Constrained Application Protocol (CoAP).",
      "ja": "nSFP内でパケットを転送するには、[RFC8300]で定義されているようにNLMを拡張し、URIに基づく名前関係と、SFCパケット転送のためのHTTPなどの高レベル転送プロトコルを考慮する必要があります。 SFCパケット転送のもう1つの例は、Constrained Application Protocol（CoAP）の例です。"
    },
    {
      "indent": 3,
      "text": "The extended NLM or name-based Network Locator Map (nNLM) is shown in Table 1 as an example for www.example.com being part of the nSFP. Such extended nNLM is stored at each SFF throughout the SFC domain with suitable information populated to the nNLM during the configuration phase.",
      "ja": "拡張NLMまたは名前ベースのネットワークロケーターマップ（nNLM）は、nSFPの一部であるwww.example.comの例として表1に示されています。 このような拡張nNLMは、SFCドメイン全体の各SFFに格納され、構成フェーズ中にnNLMに適切な情報が入力されます。"
    },
    {
      "indent": 5,
      "text": "+-----+-----+--------------------+------------------------------+\n| SPI | SI  | Next Hop(s)        | Transport Encapsulation (TE) |\n+=====+=====+====================+==============================+\n| 10  | 255 | 192.0.2.1          | VXLAN-gpe                    |\n+-----+-----+--------------------+------------------------------+\n| 10  | 254 | 198.51.100.10      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 10  | 253 | www.example.com    | HTTP                         |\n+-----+-----+--------------------+------------------------------+\n| 40  | 251 | 198.51.100.15      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 50  | 200 | 01:23:45:67:89:ab  | Ethernet                     |\n+-----+-----+--------------------+------------------------------+\n| 15  | 212 | Null (end of path) | None                         |\n+-----+-----+--------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Table 1: Name-Based Network Locator Map",
      "ja": "表1：名前ベースのネットワークロケーターマップ"
    },
    {
      "indent": 3,
      "text": "Alternatively, the extended NLM may be defined with implicit name information rather than explicit URIs as in Table 1. In the example of Table 2, the next hop is represented as a generic HTTP service without a specific URI being identified in the extended NLM. In this scenario, the SFF forwards the packet based on parsing the HTTP request in order to identify the host name or URI. It retrieves the URI and may apply policy information to determine the destination host/service.",
      "ja": "または、表1のように、明示的なURIではなく暗黙的な名前情報で拡張NLMを定義することもできます。表2の例では、拡張NLMで特定のURIが識別されない汎用HTTPサービスとしてネクストホップが表されています。 このシナリオでは、ホスト名またはURIを識別するために、SFFはHTTP要求の解析に基づいてパケットを転送します。 URIを取得し、ポリシー情報を適用して宛先ホスト/サービスを決定する場合があります。"
    },
    {
      "indent": 5,
      "text": "+-----+-----+--------------------+------------------------------+\n| SPI | SI  | Next Hop(s)        | Transport Encapsulation (TE) |\n+=====+=====+====================+==============================+\n| 10  | 255 | 192.0.2.1          | VXLAN-gpe                    |\n+-----+-----+--------------------+------------------------------+\n| 10  | 254 | 198.51.100.10      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 10  | 253 | HTTP Service       | HTTP                         |\n+-----+-----+--------------------+------------------------------+\n| 40  | 251 | 198.51.100.15      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 50  | 200 | 01:23:45:67:89:ab  | Ethernet                     |\n+-----+-----+--------------------+------------------------------+\n| 15  | 212 | Null (end of path) | None                         |\n+-----+-----+--------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Table 2: Name-Based Network Locator Map with Implicit Name Information",
      "ja": "表2：暗黙的な名前情報を含む名前ベースのネットワークロケーターマップ"
    },
    {
      "indent": 0,
      "text": "5.4. Name-Based Service Function Forwarder (nSFF)",
      "section_title": true,
      "ja": "5.4. 名前ベースのサービス機能フォワーダー（nSFF）"
    },
    {
      "indent": 3,
      "text": "It is desirable to extend the SFF of the SFC underlay to handle nSFPs transparently and without the need to insert any SF into the nSFP. Such extended nSFFs would then be responsible for forwarding a packet in the SFC domain as per the definition of the (extended) nSFP.",
      "ja": "SFCアンダーレイのSFFを拡張してnSFPを透過的に処理し、nSFPにSFを挿入する必要がないことが望ましいです。 そのような拡張nSFFは、（拡張）nSFPの定義に従って、SFCドメインでパケットを転送する役割を果たします。"
    },
    {
      "indent": 3,
      "text": "In our example realization for an extended SFF, the solution described in this document uses HTTP as the protocol of forwarding SFC packets to the next (name-based) hop in the nSFP. The URI in the HTTP transaction is the name in our nSFP information, which will be used for name-based forwarding.",
      "ja": "拡張SFFの実現例では、このドキュメントで説明するソリューションは、nSFPの次の（名前ベースの）ホップにSFCパケットを転送するプロトコルとしてHTTPを使用します。 HTTPトランザクションのURIは、nSFP情報の名前であり、名前ベースの転送に使用されます。"
    },
    {
      "indent": 3,
      "text": "Following our reasoning so far, HTTP requests (and more specifically, the plaintext-encoded requests above) are the equivalent of packets that enter the SFC domain. In the existing SFC framework, an IP payload is typically assumed to be a packet entering the SFC domain. This packet is forwarded to destination nodes using the L2 encapsulation. Any layer 2 network can be used as an underlay network. This notion is now extended to packets being possibly part of an entire higher-layer application such as HTTP requests. The handling of any intermediate layers, such as TCP and IP, is left to the realization of the (extended) SFF operations towards the next (named) hop. For this, we will first outline the general lifecycle of an SFC packet in the following subsection, followed by two examples for determining next-hop information in Section 6.2.3, finished up by a layered view on the realization of the nSFF in Section 6.2.4.",
      "ja": "これまでの推論に従って、HTTPリクエスト（より具体的には、上記のプレーンテキストでエンコードされたリクエスト）は、SFCドメインに入るパケットに相当します。 既存のSFCフレームワークでは、IPペイロードは通常、SFCドメインに入るパケットであると想定されています。 このパケットは、L2カプセル化を使用して宛先ノードに転送されます。 任意のレイヤー2ネットワークをアンダーレイネットワークとして使用できます。 この概念は、HTTPリクエストなどの上位層アプリケーション全体の一部である可能性のあるパケットに拡張されています。 TCPやIPなどの中間層の処理は、次の（名前の付いた）ホップに向けた（拡張）SFF操作の実現に委ねられます。 このため、最初に次のサブセクションでSFCパケットの一般的なライフサイクルの概要を説明し、次にセクション6.2.3でネクストホップ情報を決定するための2つの例を説明し、セクション6.2でnSFFの実現に関する階層ビューで仕上げます .4。"
    },
    {
      "indent": 0,
      "text": "5.5. High-Level Architecture",
      "section_title": true,
      "ja": "5.5. 高レベルのアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "+----------+\n| SF1      |                 +--------+                  +------+\n| instance |\\                |   NR   |                  | SF2  |\n+----------+ \\               +--------+                  +------+\n              \\                  ||                         ||\n+------------+ \\ +-------+   +---------+   +---------+   +-------+\n| Classifier |---| nSFF1 |---|Forwarder|---|Forwarder|---| nSFF2 |\n+------------+   +-------+   +---------+   +---------+   +-------+\n                                                            ||\n                                                        +----------+\n                                                        | Boundary |\n                                                        |  node    |\n                                                        +----------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 3: High-Level Architecture",
      "ja": "図3：高レベルアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The high-level architecture for name-based operation shown in Figure 3 is very similar to the SFC architecture as described in [RFC7665]. Two new functions are introduced, as shown in the above diagram: namely, the nSFF and the Name Resolver (NR).",
      "ja": "図3に示されている名前ベースの操作の高レベルアーキテクチャは、[RFC7665]で説明されているSFCアーキテクチャに非常によく似ています。 上の図に示すように、nSFFと名前解決（NR）という2つの新しい関数が導入されています。"
    },
    {
      "indent": 3,
      "text": "The nSFF is an extension of the existing SFF and is capable of processing SFC packets based on nNLM information, determining the next SF where the packet should be forwarded, and the required transport encapsulation (TE). Like standard SFF operation, it adds TE to the SFC packet and forwards it.",
      "ja": "nSFFは既存のSFFの拡張であり、nNLM情報に基づいてSFCパケットを処理し、パケットを転送する次のSF、および必要なトランスポートカプセル化（TE）を決定できます。 標準のSFF操作と同様に、SFCパケットにTEを追加して転送します。"
    },
    {
      "indent": 3,
      "text": "The NR is a new functional component, capable of identifying the execution endpoints, where a \"named SF\" is running, triggered by suitable resolution requests sent by the nSFF. Though this is similar to DNS function, it is not same. It does not use DNS protocols or data records. A new procedure to determine the suitable routing/forwarding information towards the nSFF serving the next hop of the SFP is used. The details are described later.",
      "ja": "NRは、nSFFによって送信された適切な解決要求によってトリガーされる「名前付きSF」が実行されている実行エンドポイントを識別することができる新しい機能コンポーネントです。 これはDNS機能に似ていますが、同じではありません。 DNSプロトコルまたはデータレコードは使用しません。 SFPのネクストホップを処理するnSFFへの適切なルーティング/転送情報を決定する新しい手順が使用されます。 詳細は後述します。"
    },
    {
      "indent": 3,
      "text": "The other functional components, such as classifier and SF, are the same as described in SFC architecture, as defined in [RFC7665], while the Forwarders shown in the above diagram are traditional Layer 2 switches.",
      "ja": "分類子やSFなどの他の機能コンポーネントは、[RFC7665]で定義されているSFCアーキテクチャで説明されているものと同じですが、上の図に示されているフォワーダは従来のレイヤ2スイッチです。"
    },
    {
      "indent": 0,
      "text": "5.6. Operational Steps",
      "section_title": true,
      "ja": "5.6. 操作手順"
    },
    {
      "indent": 3,
      "text": "In the proposed solution, the operations are realized by the name-based SFF, called \"nSFF\". We utilize the high-level architecture in Figure 3 to describe the traversal between two SF instances of an nSFP-based transaction in an example chain of: 192.0.x.x -> SF1 (www.example.com) -> SF2 (www.example2.com) -> SF3 -> ...",
      "ja": "提案されたソリューションでは、操作は「nSFF」と呼ばれる名前ベースのSFFによって実現されます。 図3の高レベルアーキテクチャを使用して、192.0.xx-> SF1（www.example.com）-> SF2（www.example2のサンプルチェーンでnSFPベースのトランザクションの2つのSFインスタンス間のトラバーサルを説明します。 .com）-> SF3-> ..."
    },
    {
      "indent": 3,
      "text": "Service Function 3 (SF3) is assumed to be a classical SF; hence, existing SFC mechanisms can be used to reach it and will not be considered in this example.",
      "ja": "サービス機能3（SF3）は、従来のSFであると想定されています。 したがって、既存のSFCメカニズムを使用してアクセスすることができ、この例では考慮されません。"
    },
    {
      "indent": 3,
      "text": "According to the SFC lifecycle, as defined in [RFC7665], based on our example chain above, the traffic originates from a classifier or another SFF on the left. The traffic is processed by the incoming nSFF1 (on the left side) through the following steps. The traffic exits at nSFF2.",
      "ja": "[RFC7665]で定義されているSFCライフサイクルによれば、上記のチェーン例に基づいて、トラフィックは左側の分類子または別のSFFから発生します。 トラフィックは、次の手順で着信nSFF1（左側）によって処理されます。 トラフィックはnSFF2で終了します。"
    },
    {
      "indent": 3,
      "text": "Step 1: At nSFF1, the following nNLM is assumed:",
      "ja": "ステップ1：nSFF1では、次のnNLMが想定されます。"
    },
    {
      "indent": 5,
      "text": "+-----+-----+--------------------+------------------------------+\n| SPI | SI  | Next Hop(s)        | Transport Encapsulation (TE) |\n+=====+=====+====================+==============================+\n| 10  | 255 | 192.0.2.1          | VXLAN-gpe                    |\n+-----+-----+--------------------+------------------------------+\n| 10  | 254 | 198.51.100.10      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 10  | 253 | www.example.com    | HTTP                         |\n+-----+-----+--------------------+------------------------------+\n| 10  | 252 | www.example2.com   | HTTP                         |\n+-----+-----+--------------------+------------------------------+\n| 40  | 251 | 198.51.100.15      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 50  | 200 | 01:23:45:67:89:ab  | Ethernet                     |\n+-----+-----+--------------------+------------------------------+\n| 15  | 212 | Null (end of path) | None                         |\n+-----+-----+--------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 3: nNLM at nSFF1",
      "ja": "表3：nSFF1でのnNLM"
    },
    {
      "indent": 3,
      "text": "Step 2: nSFF1 removes the previous transport encapsulation (TE) for any traffic originating from another SFF or classifier (traffic from an SF instance does not carry any TE and is therefore directly processed at the nSFF).",
      "ja": "ステップ2：nSFF1は、別のSFFまたは分類子から発信されたトラフィックの以前のトランスポートカプセル化（TE）を削除します（SFインスタンスからのトラフィックはTEを運ばないため、nSFFで直接処理されます）。"
    },
    {
      "indent": 3,
      "text": "Step 3: nSFF1 then processes the Network Service Header (NSH) information, as defined in [RFC8300], to identify the next SF at the nSFP level by mapping the NSH information to the appropriate entry in its nNLM (see Table 3) based on the provided SPI/SI information in the NSH (see Section 4) in order to determine the name-based identifier of the next-hop SF. With such nNLM in mind, the nSFF searches the map for SPI = 10 and SI = 253. It identifies the next hop as = www.example.com and HTTP as the protocol to be used. Given that the next hop resides locally, the SFC packet is forwarded to the SF1 instance of www.example.com. Note that the next hop could also be identified from the provided HTTP request, if the next-hop information was identified as a generic HTTP service, as defined in Section 5.3.",
      "ja": "ステップ3：次に、nSFF1は、[RFC8300]で定義されているようにネットワークサービスヘッダー（NSH）情報を処理し、nSLMレベルの次のSFを識別します。 ネクストホップSFの名前ベースの識別子を決定するために、NSHで提供されたSPI / SI情報（セクション4を参照）。 このようなnNLMを念頭に置いて、nSFFはSPI = 10およびSI = 253のマップを検索します。次のホップを= www.example.comとして、HTTPを使用するプロトコルとして識別します。 次ホップがローカルに存在する場合、SFCパケットはwww.example.comのSF1インスタンスに転送されます。 セクション5.3で定義されているように、ネクストホップ情報が汎用HTTPサービスとして識別された場合、ネクストホップは提供されたHTTP要求からも識別できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Step 4: The SF1 instance then processes the received SFC packet according to its service semantics and modifies the NSH by setting SPI = 10 and SI = 252 for forwarding the packet along the SFP. It then forwards the SFC packet to its local nSFF, i.e., nSFF1.",
      "ja": "ステップ4：SF1インスタンスは、サービスセマンティクスに従って受信したSFCパケットを処理し、SFPに沿ってパケットを転送するためにSPI = 10およびSI = 252を設定することによりNSHを変更します。 次に、SFCパケットをローカルのnSFF、つまりnSFF1に転送します。"
    },
    {
      "indent": 3,
      "text": "Step 5: nSFF1 processes the NSH of the SFC packet again, now with the NSH modified (SPI = 10, SI = 252) by the SF1 instance. It retrieves the next-hop information from its nNLM in Table 3 to be www.example2.com. Due to this SF not being locally available, the nSFF consults any locally available information regarding routing/forwarding towards a suitable nSFF that can serve this next hop.",
      "ja": "ステップ5：nSFF1はSFCパケットのNSHを再度処理し、SF1インスタンスによってNSHが変更されます（SPI = 10、SI = 252）。 表3のnNLMからネクストホップ情報を取得してwww.example2.comにします。 このSFがローカルで利用できないため、nSFFは、このネクストホップに対応できる適切なnSFFへのルーティング/転送に関するローカルで利用可能な情報を調べます。"
    },
    {
      "indent": 3,
      "text": "Step 6: If such information exists, the Packet (plus the NSH information) is marked to be sent towards the nSFF serving the next hop based on such information in Step 8.",
      "ja": "ステップ6：そのような情報が存在する場合、パケット（およびNSH情報）は、ステップ8でそのような情報に基づいて、ネクストホップを処理するnSFFに向けて送信されるようにマークされます。"
    },
    {
      "indent": 3,
      "text": "Step 7: If such information does not exist, nSFF1 consults the NR to determine the suitable routing/forwarding information towards the identified nSFF serving the next hop of the SFP. For future SFC packets towards this next hop, such resolved information may be locally cached, avoiding contacting the NR for every SFC packet forwarding. The packet is now marked to be sent via the network in Step 8.",
      "ja": "ステップ7：そのような情報が存在しない場合、nSFF1はNRを調べて、SFPのネクストホップにサービスを提供する識別されたnSFFへの適切なルーティング/転送情報を決定します。 このネクストホップに向かう将来のSFCパケットの場合、そのような解決された情報はローカルにキャッシュされ、SFCパケット転送ごとにNRに連絡することを回避できます。 パケットは、ステップ8でネットワーク経由で送信されるようにマークされました。"
    },
    {
      "indent": 3,
      "text": "Step 8: Utilizing the forwarding information determined in Steps 6 or 7, nSFF1 adds the suitable TE for the SFC packet before forwarding via the forwarders in the network towards the next nSFF22.",
      "ja": "ステップ8：ステップ6または7で決定された転送情報を利用して、nSFF1はネットワーク内のフォワーダーを介して次のnSFF22に転送する前に、SFCパケットに適切なTEを追加します。"
    },
    {
      "indent": 3,
      "text": "Step 9: When the Packet (+NSH+TE) arrives at the outgoing nSFF2, i.e., the nSFF serving the identified next hop of the SFP, it removes the TE and processes the NSH to identify the next-hop information. At nSFF2 the nNLM in Table 4 is assumed. Based on this nNLM and NSH information where SPI = 10 and SI = 252, nSFF2 identifies the next SF as www.example2.com.",
      "ja": "ステップ9：パケット（+ NSH + TE）が発信nSFF2、つまりSFPの識別されたネクストホップにサービスを提供するnSFFに到着すると、TEを削除し、NSHを処理してネクストホップ情報を識別します。 nSFF2では、表4のnNLMが想定されます。 SPI = 10およびSI = 252であるこのnNLMおよびNSH情報に基づいて、nSFF2は次のSFをwww.example2.comとして識別します。"
    },
    {
      "indent": 5,
      "text": "+-----+-----+--------------------+------------------------------+\n| SPI | SI  | Next Hop(s)        | Transport Encapsulation (TE) |\n+=====+=====+====================+==============================+\n| 10  | 252 | www.example2.com   | HTTP                         |\n+-----+-----+--------------------+------------------------------+\n| 40  | 251 | 198.51.100.15      | GRE                          |\n+-----+-----+--------------------+------------------------------+\n| 50  | 200 | 01:23:45:67:89:ab  | Ethernet                     |\n+-----+-----+--------------------+------------------------------+\n| 15  | 212 | Null (end of path) | None                         |\n+-----+-----+--------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 4: nNLM at SFF2",
      "ja": "表4：SFF2でのnNLM"
    },
    {
      "indent": 3,
      "text": "Step 10: If the next hop is locally registered at the nSFF, it forwards the packet (+NSH) to the SF instance using suitable IP/MAC methods for doing so.",
      "ja": "ステップ10：ネクストホップがnSFFでローカルに登録されている場合、適切なIP / MAC方式を使用して、パケット（+ NSH）をSFインスタンスに転送します。"
    },
    {
      "indent": 3,
      "text": "Step 11: If the next hop is not locally registered at the nSFF, the outgoing nSFF adds new TE information to the packet and forwards the packet (+NSH+TE) to the next SFF or boundary node, as shown in Table 4.",
      "ja": "ステップ11：次のホップがnSFFでローカルに登録されていない場合、発信nSFFは新しいTE情報をパケットに追加し、表4に示すように次のSFFまたは境界ノードにパケット（+ NSH + TE）を転送します。"
    },
    {
      "indent": 0,
      "text": "6. nSFF Forwarding Operations",
      "section_title": true,
      "ja": "6. nSFF転送操作"
    },
    {
      "indent": 3,
      "text": "This section outlines the realization of various nSFF forwarding operations in Section 5.6. Although the operations in Section 5 utilize the notion of name-based transactions in general, we exemplify the operations here in Section 5 specifically for HTTP-based transactions to ground our description into a specific protocol for such name-based transaction. We will refer to the various steps in each of the following subsections.",
      "ja": "このセクションでは、セクション5.6のさまざまなnSFF転送操作の実現について概説します。 セクション5の操作は一般に名前ベースのトランザクションの概念を利用しますが、このような名前ベースのトランザクションの特定のプロトコルに説明を根付かせるために、特にHTTPベースのトランザクションに対するセクション5の操作を例示します。 次の各サブセクションのさまざまな手順を参照します。"
    },
    {
      "indent": 0,
      "text": "6.1. nSFF Protocol Layers",
      "section_title": true,
      "ja": "6.1. nSFFプロトコルレイヤー"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the protocol layers based on the high-level architecture in Figure 3.",
      "ja": "図4は、図3の高レベルアーキテクチャに基づくプロトコル層を示しています。"
    },
    {
      "indent": 3,
      "text": "+-------+  +------+----+                              +----+-----+\n|App    |  |      |    |   +--------+                 |    |     |\n|HTTP   |  |-------->  |   |  NR    |                 |nSFF----->|--\n|TCP    |->| TCP  |nSFF|   +---/\\---+                 |    | TCP | |\n|IP     |  | IP   |    |       ||                     |    | IP  | |\n+-------+  +------+----+  +---------+   +---------+   +----------+ |\n|   L2  |  |      L2   |->|Forwarder|-->|Forwarder|-->|   L2     | |\n+-------+  +------+----+  +---------+   +---------+   +----------+ |\n  SF1           nSFF1                                     nSFF2    |\n                                              +-------+            |\n                                              | App   |/           |\n                                              | HTTP  | -----------+\n                                              | TCP   |\\\n                                              | IP    |\n                                              | L2    |\n                                              +-------+\n                                                SF2",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 4: Protocol Layers",
      "ja": "図4：プロトコル層"
    },
    {
      "indent": 3,
      "text": "The nSFF component here is shown as implementing a full incoming/ outgoing TCP/IP protocol stack towards the local SFs, while implementing the nSFF-NR and nSFF-nSFF protocols based on the descriptions in Section 6.2.3.",
      "ja": "ここでのnSFFコンポーネントは、ローカルSFへの完全な着信/発信TCP / IPプロトコルスタックを実装し、セクション6.2.3の説明に基づいてnSFF-NRおよびnSFF-nSFFプロトコルを実装するものとして示されています。"
    },
    {
      "indent": 3,
      "text": "For the exchange of HTTP-based SF transactions, the nSFF terminates incoming TCP connections as well as outgoing TCP connections to local SFs, e.g., the TCP connection from SF1 terminates at nSFF1, and nSFF1 may store the connection information such as socket information. It also maintains the mapping information for the HTTP request such as originating SF, destination SF, and socket ID. nSFF1 may implement sending keep-alive messages over the socket to maintain the connection to SF1. Upon arrival of an HTTP request from SF1, nSFF1 extracts the HTTP Request and forwards it towards the next node as outlined in Section 6.2. Any returning response is mapped onto the suitable open socket (for the original request) and sent towards SF1.",
      "ja": "HTTPベースのSFトランザクションの交換の場合、nSFFはローカルSFへの発信TCP接続と同様に着信TCP接続を終了します。たとえば、SF1からのTCP接続はnSFF1で終了し、nSFF1はソケット情報などの接続情報を保存します。 また、発信元SF、宛先SF、ソケットIDなどのHTTP要求のマッピング情報も維持します。 nSFF1は、SF1への接続を維持するために、ソケットを介してキープアライブメッセージの送信を実装できます。 SF1からHTTPリクエストが到着すると、nSFF1はHTTPリクエストを抽出し、セクション6.2で概説したように次のノードに転送します。 返される応答は、適切なオープンソケット（元の要求用）にマッピングされ、SF1に向けて送信されます。"
    },
    {
      "indent": 3,
      "text": "At the outgoing nSFF2, the destination SF2/Host is identified from the HTTP request message. If no TCP connection exists to the SF2, a new TCP connection is opened towards the destination SF2 and the HTTP request is sent over said TCP connection. The nSFF2 may also save the TCP connection information (such as socket information) and maintain the mapping of the socket information to the destination SF2. When an HTTP response is received from SF2 over the TCP connection, nSFF2 extracts the HTTP response, which is forwarded to the next node. nSFF2 may maintain the TCP connection through keep-alive messages.",
      "ja": "発信nSFF2では、宛先SF2 / HostがHTTP要求メッセージから識別されます。 SF2へのTCP接続が存在しない場合、宛先SF2に対して新しいTCP接続が開かれ、HTTP要求がそのTCP接続を介して送信されます。 nSFF2は、TCP接続情報（ソケット情報など）を保存し、宛先SF2へのソケット情報のマッピングを維持することもできます。 TCP接続を介してSF2からHTTP応答を受信すると、nSFF2はHTTP応答を抽出し、次のノードに転送します。 nSFF2は、キープアライブメッセージを介してTCP接続を維持できます。"
    },
    {
      "indent": 0,
      "text": "6.2. nSFF Operations",
      "section_title": true,
      "ja": "6.2. nSFF操作"
    },
    {
      "indent": 3,
      "text": "In this section, we present three key aspects of operations for the realization of the steps in Section 5.6, namely, (i) the registration of local SFs (for Step 3 in Section 5.6), (ii) the forwarding of SFC packets to and from local SFs (for Steps 3, 4, and 10 in Section 5.6), (iii) the forwarding to a remote SF (for Steps 5, 6, and 7 in Section 5.6) and to the NR as well as (iv) for the lookup of a suitable remote SF (for Step 7 in Section 5.6). We also cover aspects of maintaining local lookup information for reducing lookup latency and other issues.",
      "ja": "このセクションでは、セクション5.6のステップを実現するための操作の3つの重要な側面、つまり、（i）ローカルSFの登録（セクション5.6のステップ3）、（ii）SFCパケットの転送、および ローカルSFから（セクション5.6のステップ3、4、および10）、（iii）リモートSF（セクション5.6のステップ5、6、および7）およびNRへの転送（iv） 適切なリモートSFの検索（セクション5.6のステップ7の場合）。 また、ルックアップレイテンシーやその他の問題を軽減するために、ローカルルックアップ情報を維持する側面もカバーしています。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Forwarding between nSFFs and nSFF-NRs",
      "section_title": true,
      "ja": "6.2.1. nSFFとnSFF-NR間の転送"
    },
    {
      "indent": 3,
      "text": "Forwarding between the distributed nSFFs as well as between nSFFs and NRs is realized over the operator network via a path-based approach. A path-based approach utilizes path information provided by the source of the packet for forwarding said packet in the network. This is similar to segment routing albeit differing in the type of information provided for such source-based forwarding as described in this section. In this approach, the forwarding information to a remote nSFF or the NR is defined as a \"path identifier\" (pathID) of a defined length where said length field indicates the full pathID length. The payload of the packet is defined by the various operations outlined in the following subsections, resulting in an overall packet being transmitted. With this, the generic forwarding format (GFF) for transport over the operator network is defined in Figure 5 with the length field defining the length of the pathID provided.",
      "ja": "分散型nSFF間およびnSFFとNR間の転送は、パスベースのアプローチを介してオペレータネットワーク上で実現されます。 パスベースのアプローチは、ネットワーク内でパケットを転送するためにパケットのソースによって提供されるパス情報を利用します。 このセクションで説明されているように、このようなソースベースの転送に提供される情報のタイプは異なりますが、これはセグメントルーティングに似ています。 このアプローチでは、リモートnSFFまたはNRへの転送情報は、定義された長さの「パス識別子」（pathID）として定義されます。この長さフィールドは完全なpathIDの長さを示します。 パケットのペイロードは、次のサブセクションで説明するさまざまな操作によって定義され、パケット全体が送信されます。 これにより、図5に、提供されたpathIDの長さを定義する長さフィールドを使用して、オペレーターネットワークを介したトランスポートの汎用転送フォーマット（GFF）が定義されます。"
    },
    {
      "indent": 3,
      "text": "+---------+-----------------+------------------------//------------+\n|         |                 |                       //             |\n| Length  | Path ID         |  Payload             //              |\n|(12 bits)|                 |                     //               |\n+---------+-----------------+--------------------//----------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 5: Generic Forwarding Format (GFF)",
      "ja": "図5：Generic Forwarding Format（GFF）"
    },
    {
      "indent": 3,
      "text": "* Length (12 bits): Defines the length of the pathID, i.e., up to 4096 bits",
      "ja": "* 長さ（12ビット）：パスIDの長さ、つまり最大4096ビットを定義します"
    },
    {
      "indent": 3,
      "text": "* Path ID: Variable-length bit field derived from IPv6 source and destination address",
      "ja": "* パスID：IPv6送信元および宛先アドレスから派生した可変長ビットフィールド"
    },
    {
      "indent": 3,
      "text": "For the pathID information, solutions such as those in [Reed2016] can be used. Here, the IPv6 source and destination addresses are used to realize a so-called path-based forwarding from the incoming to the outgoing nSFF or the NR. The forwarders in Figure 4 are realized via SDN (software-defined networking) switches, implementing an AND/CMP operation based on arbitrary wildcard matching over the IPv6 source and destination addresses as outlined in [Reed2016]. Note that in the case of using IPv6 address information for path-based forwarding, the step of removing the TE at the outgoing nSFF in Figure 4 is realized by utilizing the provided (existing) IP header (which was used for the purpose of the path-based forwarding in [Reed2016]) for the purpose of next-hop forwarding such as that of IP-based routing. As described in Step 8 of the extended nSFF operations, this forwarding information is used as traffic encapsulation. With the forwarding information utilizing existing IPv6 information, IP headers are utilized as TE in this case. The next-hop nSFF (see Figure 4) will restore the IP header of the packet with the relevant IP information used to forward the SFC packet to SF2, or it will create suitable TE information to forward the information to another nSFF or boundary node. Forwarding operations at the intermediary forwarders, i.e., SDN switches, examine the pathID information through a flow-matching rule in which a specific switch-local output port is represented through the specific assigned bit position in the pathID. Upon a positive match in said rule, the packet is forwarded on said output port.",
      "ja": "pathID情報には、[Reed2016]のようなソリューションを使用できます。ここでは、IPv6の送信元アドレスと宛先アドレスを使用して、着信から発信nSFFまたはNRへのいわゆるパスベースの転送を実現しています。図4のフォワーダーはSDN（ソフトウェア定義ネットワーク）スイッチを介して実現され、[Reed2016]で概説されているように、IPv6の送信元アドレスと宛先アドレスでの任意のワイルドカードマッチングに基づくAND / CMP操作を実装します。パスベースの転送にIPv6アドレス情報を使用する場合、図4の発信nSFFでTEを削除するステップは、提供された（既存の）IPヘッダー（パスの目的で使用された） IPベースのルーティングなどのネクストホップ転送を目的とした[Reed2016]でのベース転送。拡張nSFF操作のステップ8で説明したように、この転送情報はトラフィックのカプセル化として使用されます。既存のIPv6情報を利用する転送情報では、この場合、IPヘッダーがTEとして利用されます。ネクストホップnSFF（図4を参照）は、SFCパケットをSF2に転送するために使用される関連IP情報でパケットのIPヘッダーを復元するか、情報を別のnSFFまたは境界ノードに転送する適切なTE情報を作成します。中間フォワーダー、つまりSDNスイッチでの転送操作は、特定のスイッチローカル出力ポートがpathIDの特定の割り当てられたビット位置によって表されるフローマッチングルールを介してpathID情報を調べます。上記のルールが一致すると、パケットは上記の出力ポートに転送されます。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the solution in [BIER-MULTICAST] suggests using a so-called BIER (Binary Indexed Explicit Replication) underlay. Here, the nSFF would be realized at the ingress to the BIER underlay, injecting the SFC packet header (plus the Network Service Header (NSH)) with BIER-based traffic encapsulation into the BIER underlay with each of the forwarders in Figure 4 being realized as a so-called Bit-Forwarding Router (BFR) [RFC8279].",
      "ja": "あるいは、[BIER-MULTICAST]のソリューションは、いわゆるBIER（Binary Indexed Explicit Replication）アンダーレイの使用を提案しています。 ここで、nSFFはBIERアンダーレイへの入口で実現され、BIERベースのトラフィックカプセル化を備えたSFCパケットヘッダー（およびNetwork Service Header（NSH））をBIERアンダーレイに注入し、図4の各フォワーダーを実現します いわゆるビット転送ルーター（BFR）[RFC8279]として。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Transport Protocol Considerations",
      "section_title": true,
      "ja": "6.2.1.1. トランスポートプロトコルの考慮事項"
    },
    {
      "indent": 3,
      "text": "Given that the proposed solution operates at the \"named-transaction\" level, particularly for HTTP transactions, forwarding between nSFFs and/or NRs SHOULD be implemented via a transport protocol between nSFFs and/or NRs in order to provide reliability, segmentation of large GFF packets, and flow control, with the GFF in Figure 5 being the basic forwarding format for this.",
      "ja": "提案されたソリューションが「名前付きトランザクション」レベル、特にHTTPトランザクションで動作することを考えると、nSFFおよび/またはNR間の転送は、信頼性、大きなGFFのセグメンテーションを提供するために、nSFFおよび/またはNR間のトランスポートプロトコルを介して実装する必要があります パケット、フロー制御、図5のGFFがこのための基本的な転送形式です。"
    },
    {
      "indent": 3,
      "text": "Note that the nSFFs act as TCP proxies at ingress and egress, thus terminating incoming and initiating outgoing HTTP sessions to SFs.",
      "ja": "nSFFは入力および出力でTCPプロキシとして機能するため、SFへの着信HTTPセッションと着信HTTPセッションを終了することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Figure 6 shows the packet format being used for the transmission of data, being adapted from the TCP header. Segmentation of large transactions into single transport protocol packets is realized through maintaining a \"Sequence number\". A \"Checksum\" is calculated over a single data packet with the ones-complement TCP checksum calculation being used. The \"Window Size\" field indicates the current maximum number of transport packets that are allowed in-flight by the egress nSFF. A data packet is sent without a \"Data\" field to indicate the end of the (e.g., HTTP) transaction.",
      "ja": "図6は、データの送信に使用され、TCPヘッダーから適応されたパケット形式を示しています。 大きなトランザクションを単一のトランスポートプロトコルパケットに分割することは、「シーケンス番号」を維持することで実現されます。 「チェックサム」は、1の補数のTCPチェックサム計算を使用して、単一のデータパケットに対して計算されます。 「ウィンドウサイズ」フィールドは、出力nSFFによって飛行中に許可されるトランスポートパケットの現在の最大数を示します。 （HTTPなど）トランザクションの終了を示すために、データパケットは「データ」フィールドなしで送信されます。"
    },
    {
      "indent": 3,
      "text": "Note that, in order to support future named transactions based on other application protocols, such as Constrained Application Protocol (CoAP), future versions of the transport protocol MAY introduce a \"Type\" field that indicates the type of application protocol being used between SF and nSFF with \"Type\" 0x01 proposed for HTTP. This is being left for future study.",
      "ja": "Constrained Application Protocol（CoAP）などの他のアプリケーションプロトコルに基づく将来の名前付きトランザクションをサポートするために、トランスポートプロトコルの将来のバージョンは、SFとの間に使用されるアプリケーションプロトコルのタイプを示す「タイプ」フィールドを導入する場合があります HTTP用に提案された「タイプ」0x01のnSFF。 これは将来の研究のために残されています。"
    },
    {
      "indent": 15,
      "text": "+----------------------------------------------+\n|         16 bits       |        16 bits       |\n+----------------------------------------------+\n|              Sequence number                 |\n+----------------------------------------------+\n|       Checksum        |      Window Size     |\n+----------------------------------------------+\n|                      ...                     |\n|                Data (Optional)               |\n+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 6: Transport Protocol Data Packet Format",
      "ja": "図6：トランスポートプロトコルデータパケット形式"
    },
    {
      "indent": 3,
      "text": "Given the path-based forwarding being used between nSFFs, the transport protocol between nSFFs utilizes negative acknowledgements from the egress nSFF towards the ingress nSFF. The transport protocol negative Acknowledgment (NACK) packet carries the number of NACKs as well as the specific sequence numbers being indicated as lost in the \"NACK number\" field(s) as shown in Figure 7.",
      "ja": "nSFF間でパスベースの転送が使用されている場合、nSFF間のトランスポートプロトコルは、出力nSFFから入力nSFFへの否定応答を利用します。 トランスポートプロトコルの否定応答（NACK）パケットは、図7に示すように、NACKの数と、「NACK番号」フィールドで失われたことが示されている特定のシーケンス番号を伝送します。"
    },
    {
      "indent": 15,
      "text": "+-----------------------+----------------------+\n|         16 bits       |        16 bits       |\n+----------------------------------------------+\n|    Number of NACKs    |                      +\n+----------------------------------------------+\n|                   NACK number                |\n+----------------------------------------------+\n+                ... NACK number               +\n+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 7: Transport Protocol NACK Packet Format",
      "ja": "図7：トランスポートプロトコルNACKパケット形式"
    },
    {
      "indent": 3,
      "text": "If the indicated number of NACKs in a received NACK packet is nonzero, the ingress nSFF will retransmit all sequence numbers signaled in the packet while decreasing its congestion window size for future transmissions.",
      "ja": "受信したNACKパケット内の指定されたNACKの数がゼロ以外の場合、入力nSFFはパケットで通知されたすべてのシーケンス番号を再送信し、将来の送信のために輻輳ウィンドウサイズを縮小します。"
    },
    {
      "indent": 3,
      "text": "If the indicated number of NACKs in a received NACK packet is zero, it will indicate the current congestion window as being successfully (and completely) being transmitted, increasing the congestion window size if smaller than the advertised \"Window Size\" in Figure 6.",
      "ja": "受信したNACKパケット内の指定されたNACKの数がゼロの場合、現在の輻輳ウィンドウが正常に（および完全に）送信されていることを示し、図6でアドバタイズされた「ウィンドウサイズ」よりも小さい場合、輻輳ウィンドウサイズを増やします。"
    },
    {
      "indent": 3,
      "text": "The maintenance of the congestion window is subject to realization at the ingress nSFF and left for further study in nSFF realizations.",
      "ja": "輻輳ウィンドウの維持は、入力nSFFでの実現を前提としており、nSFFの実現のさらなる研究のために残されています。"
    },
    {
      "indent": 0,
      "text": "6.2.2. SF Registration",
      "section_title": true,
      "ja": "6.2.2. SF登録"
    },
    {
      "indent": 3,
      "text": "As outlined in Steps 3 and 10 of Section 5.6, the nSFF needs to determine if the SF derived from the Name-Based Network Locator (nNLM) is locally reachable or whether the packet needs to be forwarded to a remote SFF. For this, a registration mechanism is provided for such local SF with the local nSFF. Two mechanisms can be used for this:",
      "ja": "セクション5.6のステップ3および10で概説したように、nSFFは、Name-Based Network Locator（nNLM）から派生したSFがローカルに到達可能かどうか、またはパケットをリモートSFFに転送する必要があるかどうかを判断する必要があります。 このため、ローカルnSFFを使用したこのようなローカルSFの登録メカニズムが提供されます。 これには2つのメカニズムを使用できます。"
    },
    {
      "indent": 3,
      "text": "1. SF-initiated: We assume that the SF registers its Fully Qualified Domain Name (FQDN) to the local nSFF. As local mechanisms, we foresee that either a Representational State Transfer (REST-based) interface over the link-local link or configuration of the nSFF (through configuration files or management consoles) can be utilized. Such local registration events lead to the nSFF registering the given FQDN with the NR in combination with a system-unique nSFF identifier that is being used for path-computation purposes in the NR. For the registration, the packet format in Figure 8 is used (inserted as the payload in the GFF of Figure 5 with the pathID towards the NR).",
      "ja": "1. SF開始：SFが完全修飾ドメイン名（FQDN）をローカルnSFFに登録すると仮定します。 ローカルメカニズムとして、リンクローカルリンク上のRepresentational State Transfer（RESTベース）インターフェイスまたはnSFFの構成（構成ファイルまたは管理コンソールを使用）のいずれかを利用できると予測しています。 このようなローカル登録イベントにより、nSFFは、NRでパス計算の目的で使用されているシステム固有のnSFF識別子と組み合わせて、NRで指定されたFQDNを登録します。 登録には、図8のパケット形式が使用されます（図5のGFFにペイロードとして挿入され、NRに向かってpathIDが付けられます）。"
    },
    {
      "indent": 18,
      "text": "+---------+------------------+----------------+\n|         |                  |                |\n|   R/D   |    hash(FQDN)    |    nSFF_ID     |\n| (1 bit) |    (16 bits)     |    (8 bits)    |\n+---------+------------------+----------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 8: Registration Packet Format",
      "ja": "図8：登録パケットの形式"
    },
    {
      "indent": 12,
      "text": "+ R/D: 1-bit length (0 for Register, 1 for Deregister)",
      "ja": "+ R / D：1ビット長（レジスタの場合は0、登録解除の場合は1）"
    },
    {
      "indent": 12,
      "text": "+ hash(FQDN): 16-bit length for a hash over the FQDN of the SF",
      "ja": "+ hash（FQDN）：SFのFQDN上のハッシュの16ビット長"
    },
    {
      "indent": 12,
      "text": "+ nSFF_ID: 8-bit length for a system-unique identifier for the SFF related to the SF",
      "ja": "+ nSFF_ID：SFに関連するSFFのシステム固有の識別子の8ビット長"
    },
    {
      "indent": 12,
      "text": "We assume that the pathID towards the NR is known to the nSFF through configuration means.",
      "ja": "NRへのpathIDは、構成手段を介してnSFFに認識されていると想定しています。"
    },
    {
      "indent": 12,
      "text": "The NR maintains an internal table that associates the hash(FQDN), the nSFF_id information, as well as the pathID information being used for communication between nSFFs and NRs. The nSFF locally maintains a mapping of registered FQDNs to IP addresses for the latter using link-local private IP addresses.",
      "ja": "NRは、ハッシュ（FQDN）、nSFF_id情報、およびnSFFとNR間の通信に使用されるpathID情報を関連付ける内部テーブルを維持します。 nSFFは、リンクローカルプライベートIPアドレスを使用して、登録されたFQDNのIPアドレスへのマッピングをローカルで維持します。"
    },
    {
      "indent": 3,
      "text": "2. Orchestration-based: In this mechanism, we assume that SFC to be orchestrated and the chain to be provided through an orchestration template with FQDN information associated to a compute/storage resource that is being deployed by the orchestrator. We also assume knowledge at the orchestrator of the resource topology. Based on this, the orchestrator can now use the same REST-based protocol defined in option 1 to instruct the NR to register the given FQDN, as provided in the template, at the nSFF it has identified as being the locally servicing nSFF, provided as the system-unique nSFF identifier.",
      "ja": "2. オーケストレーションベース：このメカニズムでは、SFCをオーケストレーションし、オーケストレーターによって展開されているコンピューティング/ストレージリソースに関連付けられたFQDN情報を持つオーケストレーションテンプレートを介してチェーンを提供することを想定しています。 また、リソーストポロジのオーケストレーターでの知識を前提としています。 これに基づいて、オーケストレーターは、オプション1で定義された同じRESTベースのプロトコルを使用して、テンプレートで提供されている特定のFQDNを、ローカルサービスnSFFとして識別されたnSFFで登録するようNRに指示できるようになりました システム固有のnSFF識別子。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Local SF Forwarding",
      "section_title": true,
      "ja": "6.2.3. ローカルSFフォワーディング"
    },
    {
      "indent": 3,
      "text": "There are two cases of local SF forwarding, namely, the SF sending an SFC packet to the local nSFF (incoming requests) or the nSFF sending a packet to the SF (outgoing requests) as part of Steps 3 and 10 in Section 5.6. In the following, we outline the operation for HTTP as an example-named transaction.",
      "ja": "ローカルSF転送には、SFがローカルnSFFにSFCパケットを送信する（着信要求）か、セクション5.6のステップ3および10の一部としてパケットをSFに送信する（送信要求）という2つのケースがあります。 以下では、HTTPの操作の例を名前付きトランザクションとして概説します。"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 4, incoming HTTP requests from SFs are extracted by terminating the incoming TCP connection at their local nSFFs at the TCP level. The nSFF MUST maintain a mapping of open TCP sockets to HTTP requests (utilizing the URI of the request) for HTTP response association.",
      "ja": "図4に示すように、SFからの着信HTTP要求は、TCPレベルのローカルnSFFで着信TCP接続を終了することにより抽出されます。 nSFFは、HTTP応答の関連付けのために、オープンTCPソケットのHTTP要求へのマッピング（要求のURIを使用）を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "For outgoing HTTP requests, the nSFF utilizes the maintained mapping of locally registered FQDNs to link-local IP addresses (see Section 6.2.2, option 1). Hence, upon receiving an SFC packet from a remote nSFF (in Step 9 of Section 5.6), the nSFF determines the local existence of the SF through the registration mechanisms in Section 6.2.2. If said SF does exist locally, the HTTP (+NSH) packet, after stripping the TE, is sent to the local SF as Step 10 in Section 5.6 via a TCP-level connection. Outgoing nSFFs SHOULD keep TCP connections open to local SFs for improving SFC packet delivery in subsequent transactions.",
      "ja": "発信HTTP要求の場合、nSFFはローカルに登録されたFQDNのリンクローカルIPアドレスへの維持されたマッピングを利用します（セクション6.2.2、オプション1を参照）。 したがって、リモートnSFFからSFCパケットを受信すると（セクション5.6のステップ9）、nSFFはセクション6.2.2の登録メカニズムを介してSFのローカルな存在を判断します。 上記のSFがローカルに存在する場合、HTTP（+ NSH）パケットは、TEを除去した後、セクション5.6のステップ10としてTCPレベル接続を介してローカルSFに送信されます。 発信nSFFは、後続のトランザクションでのSFCパケット配信を改善するために、ローカルSFへのTCP接続を開いたままにする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Handling of HTTP Responses",
      "section_title": true,
      "ja": "6.2.4. HTTP応答の処理"
    },
    {
      "indent": 3,
      "text": "When executing Steps 3 and 10 in Section 5.6, the SFC packet will be delivered to the locally registered next hop. As part of the HTTP protocol, responses to the HTTP request will need to be delivered on the return path to the originating nSFF (i.e., the previous hop). For this, the nSFF maintains a list of link-local connection information, e.g., sockets to the local SF and the pathID on which the request was received. Once receiving the response, nSFF consults the table to determine the pathID of the original request, forming a suitable GFF-based packet to be returned to the previous nSFF.",
      "ja": "セクション5.6のステップ3および10を実行すると、SFCパケットはローカルに登録されたネクストホップに配信されます。 HTTPプロトコルの一部として、HTTP要求への応答は、発信元のnSFF（つまり、前のホップ）へのリターンパスで配信される必要があります。 このために、nSFFはリンクローカル接続情報のリスト、たとえば、ローカルSFへのソケットと、リクエストが受信されたpathIDを保持します。 応答を受信すると、nSFFはテーブルを参照して元の要求のpathIDを決定し、前のnSFFに返される適切なGFFベースのパケットを形成します。"
    },
    {
      "indent": 3,
      "text": "When receiving the HTTP response at the previous nSFF, the nSFF consults the table of (locally) open sockets to determine the suitable local SF connection, mapping the received HTTP response URI to the stored request URI. Utilizing the found socket, the HTTP response is forwarded to the locally registered SF.",
      "ja": "前のnSFFでHTTP応答を受信すると、nSFFは（ローカルに）開いているソケットのテーブルを参照して適切なローカルSF接続を決定し、受信したHTTP応答URIを保存された要求URIにマッピングします。 見つかったソケットを利用して、HTTP応答はローカルに登録されたSFに転送されます。"
    },
    {
      "indent": 0,
      "text": "6.2.5. Remote SF Forwarding",
      "section_title": true,
      "ja": "6.2.5. リモートSF転送"
    },
    {
      "indent": 3,
      "text": "In Steps 5, 6, 7, and 8 of Section 5.6, an SFC packet is forwarded to a remote nSFF based on the nNLM information for the next hop of the nSFP. Section 6.2.5.1 handles the case of suitable forwarding information to the remote nSFF not existing, therefore consulting the NR to obtain suitable information. Section 6.2.5.2 describes the maintenance of forwarding information at the local nSFF. Section 6.2.5.3 describes the update of stale forwarding information. Note that the forwarding described in Section 6.2.1 is used for the actual forwarding to the various nSFF components. Ultimately, Section 6.2.5.4 describes the forwarding to the remote nSFF via the forwarder network.",
      "ja": "セクション5.6のステップ5、6、7、および8では、nSFPのネクストホップのnNLM情報に基づいて、SFCパケットがリモートnSFFに転送されます。 セクション6.2.5.1は、存在しないリモートnSFFへの適切な転送情報のケースを処理するため、NRに相談して適切な情報を取得します。 セクション6.2.5.2では、ローカルnSFFでの転送情報のメンテナンスについて説明しています。 セクション6.2.5.3では、古い転送情報の更新について説明しています。 セクション6.2.1で説明されている転送は、さまざまなnSFFコンポーネントへの実際の転送に使用されることに注意してください。 最終的に、セクション6.2.5.4では、フォワーダーネットワークを介したリモートnSFFへの転送について説明します。"
    },
    {
      "indent": 0,
      "text": "6.2.5.1. Remote SF Discovery",
      "section_title": true,
      "ja": "6.2.5.1. リモートSFディスカバリー"
    },
    {
      "indent": 3,
      "text": "The nSFF communicates with the NR for two purposes: namely, the registration and discovery of FQDNs. The packet format for the former was shown in Figure 8 in Section 6.2.2, while Figure 9 outlines the packet format for the discovery request.",
      "ja": "nSFFは、2つの目的でNRと通信します。つまり、FQDNの登録と検出です。 前者のパケット形式はセクション6.2.2の図8に示されており、図9はディスカバリー要求のパケット形式の概要を示しています。"
    },
    {
      "indent": 3,
      "text": "+--------------+-------------+ +--------+-----------------//--------+\n|              |             | |        |                //         |\n|   hash(FQDN) |  nSFF_ID    | | Length | pathID        //          |\n|   (16 bits)  |  (8 bits)   | |(4 bits)|              //           |\n+--------------+-------------+ +--------+-------------//------------+\n        Path Request                     Path Response",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 9: Discovery Packet Format",
      "ja": "図9：検出パケットの形式"
    },
    {
      "indent": 3,
      "text": "For Path Request:",
      "ja": "パスリクエストの場合："
    },
    {
      "indent": 3,
      "text": "* hash(FQDN): 16-bit length for a hash over the FQDN of the SF",
      "ja": "* hash（FQDN）：SFのFQDN上のハッシュの16ビット長"
    },
    {
      "indent": 3,
      "text": "* nSFF_ID: 8-bit length for a system-unique identifier for the SFF related to the SF",
      "ja": "* nSFF_ID：SFに関連するSFFのシステム固有の識別子の8ビット長"
    },
    {
      "indent": 3,
      "text": "For Path Response:",
      "ja": "パス応答の場合："
    },
    {
      "indent": 3,
      "text": "* Length: 4-bit length that defines the length of the pathID",
      "ja": "* 長さ：pathIDの長さを定義する4ビット長"
    },
    {
      "indent": 3,
      "text": "* Path ID: Variable-length bit field derived from IPv6 source and destination address",
      "ja": "* パスID：IPv6送信元および宛先アドレスから派生した可変長ビットフィールド"
    },
    {
      "indent": 3,
      "text": "A path to a specific FQDN is requested by sending a hash of the FQDN to the NR together with its nSFF_id, receiving as a response a pathID with a length identifier. The NR SHOULD maintain a table of discovery requests that map discovered (hash of) FQDN to the nSFF_id that requested it and the pathID that is being calculated as a result of the discovery request.",
      "ja": "特定のFQDNへのパスは、nSFF_idと共にFQDNにFQDNのハッシュを送信し、長さ識別子を持つpathIDを応答として受信することにより要求されます。 NRは、検出された（ハッシュされた）FQDNを要求したnSFF_idと、検出要求の結果として計算されているpathIDにマッピングする検出要求のテーブルを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The discovery request for an FQDN that has not previously been served at the nSFF (or for an FQDN whose pathID information has been flushed as a result of the update operations in Section 6.2.5.3) results in an initial latency incurred by this discovery through the NR, while any SFC packet sent over the same SFP in a subsequent transaction will utilize the nSFF-local mapping table. Such initial latency can be avoided by prepopulating the FQDN-pathID mapping proactively as part of the overall orchestration procedure, e.g., alongside the distribution of the nNLM information to the nSFF.",
      "ja": "nSFFで以前に提供されていないFQDN（またはセクション6.2.5.3の更新操作の結果としてpathID情報がフラッシュされたFQDN）の検出要求は、 NR、後続のトランザクションで同じSFPを介して送信されるSFCパケットは、nSFFローカルマッピングテーブルを利用します。 このような初期遅延は、全体的なオーケストレーション手順の一部として、たとえば、nSLMへのnNLM情報の配信とともに、FQDN-pathIDマッピングを事前に入力することで回避できます。"
    },
    {
      "indent": 0,
      "text": "6.2.5.2. Maintaining Forwarding Information at Local nSFF",
      "section_title": true,
      "ja": "6.2.5.2. ローカルnSFFでの転送情報の維持"
    },
    {
      "indent": 3,
      "text": "Each nSFF MUST maintain an internal table that maps the (hash of the) FQDN information to a suitable pathID. As outlined in Step 7 of Section 5.6, if a suitable entry does not exist for a given FQDN, the pathID information is requested with the operations in Section 6.2.5.1 and the suitable entry is locally created upon receiving a reply with the forwarding operation being executed as described in Section 6.2.1.",
      "ja": "各nSFFは、FQDN情報（のハッシュ）を適切なpathIDにマップする内部テーブルを維持する必要があります。 セクション5.6のステップ7で概説したように、特定のFQDNに適切なエントリが存在しない場合、セクション6.2.5.1の操作でpathID情報が要求され、転送操作で応答を受信すると適切なエントリがローカルに作成されます セクション6.2.1の説明に従って実行されます。"
    },
    {
      "indent": 3,
      "text": "If such an entry does exist (i.e., Step 6 of Section 5.6), the pathID is locally retrieved and used for the forwarding operation in Section 6.2.1.",
      "ja": "そのようなエントリが存在する場合（つまり、セクション5.6のステップ6）、pathIDはローカルで取得され、セクション6.2.1の転送操作に使用されます。"
    },
    {
      "indent": 0,
      "text": "6.2.5.3. Updating Forwarding Information at nSFF",
      "section_title": true,
      "ja": "6.2.5.3. nSFFでの転送情報の更新"
    },
    {
      "indent": 3,
      "text": "The forwarding information maintained at each nSFF (see Section 6.2.5.2) might need to be updated for three reasons:",
      "ja": "各nSFFで保持される転送情報（セクション6.2.5.2を参照）は、次の3つの理由で更新する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "1. An existing SF is no longer reachable: In this case, the nSFF with which the SF is locally registered deregisters the SF explicitly at the NR by sending the packet in Figure 6 with the hashed FQDN and the R/D bit set to 1 (for deregister).",
      "ja": "1. 既存のSFに到達できなくなりました：この場合、SFがローカルに登録されているnSFFは、ハッシュされたFQDNとR / Dビットが1に設定された図6のパケットを送信することで、NRで明示的にSFの登録を解除します 登録解除）。"
    },
    {
      "indent": 3,
      "text": "2. Another SF instance has become reachable in the network (and, therefore, might provide a better alternative to the existing SF): In this case, the NR has received another packet with a format defined in Figure 7 but a different nSFF_id value.",
      "ja": "2. 別のSFインスタンスがネットワーク内で到達可能になりました（したがって、既存のSFに代わるより良い代替手段を提供する可能性があります）：この場合、NRは、図7で定義された形式で異なるnSFF_id値を持つ別のパケットを受信しました。"
    },
    {
      "indent": 3,
      "text": "3. Links along paths might no longer be reachable: The NR might use a suitable southbound interface to transport networks to detect link failures, which it associates to the appropriate pathID bit position.",
      "ja": "3. パスに沿ったリンクに到達できなくなる可能性があります。NRは適切なサウスバウンドインターフェイスを使用してネットワークを転送し、適切なpathIDビット位置に関連付けられたリンク障害を検出する場合があります。"
    },
    {
      "indent": 3,
      "text": "For this purpose, the packet format in Figure 10 is sent from the NR to all affected nSFFs, using the generic format in Figure 5.",
      "ja": "このため、図10のパケット形式は、図5の汎用形式を使用して、NRから影響を受けるすべてのnSFFに送信されます。"
    },
    {
      "indent": 12,
      "text": "+---------+-----------------+--------------//----+\n|         |                 |             //     |\n|   Type  |     #IDs        |  IDs       //      |\n| (1 bit) |    (8 bits)     |           //       |\n+---------+-----------------+----------//--------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 10: Path Update Format",
      "ja": "図10：パス更新形式"
    },
    {
      "indent": 3,
      "text": "* Type: 1-bit length (0 for Nsff ID, 1 for Link ID)",
      "ja": "* タイプ：1ビット長（Nsff IDの場合は0、リンクIDの場合は1）"
    },
    {
      "indent": 3,
      "text": "*  #IDs: 8-bit length for number of IDs in the list",
      "raw": true
    },
    {
      "indent": 3,
      "text": "* IDs: List of IDs (Nsff ID or Link ID)",
      "ja": "* ID：IDのリスト（Nsff IDまたはリンクID）"
    },
    {
      "indent": 3,
      "text": "The pathID to the affected nSFFs is computed as the binary OR over all pathIDs to those nSFF_ids affected where the pathID information to the affected nSFF_id values is determined from the NR-local table maintained in the registration/deregistration operation of Section 6.2.2.",
      "ja": "影響を受けるnSFFへのパスIDは、影響を受けるnSFF_idへのすべてのパスIDに対するバイナリORとして計算され、影響を受けるnSFF_id値へのパスID情報は、セクション6.2.2の登録/登録解除操作で維持されるNRローカルテーブルから決定されます。"
    },
    {
      "indent": 3,
      "text": "The pathID may include the type of information being updated (e.g., node identifiers of leaf nodes or link identifiers for removed links). The node identifier itself may be a special identifier to signal \"ALL NODES\" as being affected. The node identifier may signal changes to the network that are substantial (e.g., parallel link failures). The node identifier may trigger (e.g., recommend) purging of the entire path table (e.g., rather than the selective removal of a few nodes only).",
      "ja": "パスＩＤは、更新されている情報のタイプ（例えば、リーフノードのノード識別子または削除されたリンクのリンク識別子）を含み得る。 ノード識別子自体は、影響を受けると「ALL NODES」を通知する特別な識別子である場合があります。 ノード識別子は、実質的なネットワークへの変更（たとえば、パラレルリンク障害）を通知する場合があります。 ノード識別子は、パステーブル全体のパージをトリガー（たとえば、推奨）することがあります（たとえば、いくつかのノードのみを選択的に削除するのではなく）。"
    },
    {
      "indent": 3,
      "text": "It will include the information according to the type. The included information may also be related to the type and length information for the number of identifiers being provided.",
      "ja": "タイプに応じた情報が含まれます。 含まれる情報は、提供されている識別子の数のタイプと長さの情報に関連する場合もあります。"
    },
    {
      "indent": 3,
      "text": "In cases 1 and 2, the Type bit is set to 1 (type nSFF_id) and the affected nSFFs are determined by those nSFFs that have previously sent SF discovery requests, utilizing the optional table mapping previously registered FQDNs to nSFF_id values. If no table mapping the (hash of) FQDN to nSFF_id is maintained, the update is sent to all nSFFs. Upon receiving the path update at the affected nSFF, all appropriate nSFF-local mapping entries to pathIDs for the hash(FQDN) identifiers provided will be removed, leading to a new NR discovery request at the next remote nSFF forwarding to the appropriate FQDN.",
      "ja": "ケース1および2では、タイプビットは1（タイプnSFF_id）に設定され、影響を受けるnSFFは、以前に登録されたFQDNをnSFF_id値にマッピングするオプションのテーブルを利用して、以前にSFディスカバリー要求を送信したnSFFによって決定されます。 FQDN（のハッシュ）をnSFF_idにマッピングするテーブルが維持されていない場合、更新はすべてのnSFFに送信されます。 影響を受けるnSFFでパス更新を受信すると、提供されたハッシュ（FQDN）識別子のpathIDへのすべての適切なnSFFローカルマッピングエントリが削除され、適切なFQDNへの次のリモートnSFF転送で新しいNR発見要求が発生します。"
    },
    {
      "indent": 3,
      "text": "In case 3, the Type bit is set to 0 (type linkID) and the affected nSFFs are determined by those nSFFs whose discovery requests have previously resulted in pathIDs that include the affected link, utilizing the optional table mapping previously registered FQDNs to pathID values (see Section 6.2.5.1). Upon receiving the node identifier information in the path update, the affected nSFF will check its internal table that maps FQDNs to pathIDs to determine those pathIDs affected by the link problems and remove path information that includes the received node identifier(s). For this, the pathID entries of said table are checked against the linkID values provided in the ID entry of the path update through a binary AND/CMP operation to check the inclusion of the link in the pathIDs to the FQDNs. If any pathID is affected, the FQDN-pathID entry is removed, leading to a new NR discovery request at the next remote nSFF forwarding to the appropriate FQDN.",
      "ja": "ケース3では、タイプビットが0（タイプlinkID）に設定され、影響を受けるnSFFは、以前に登録されたFQDNをpathID値にマッピングするオプションのテーブルを使用して、ディスカバリリクエストが影響を受けるリンクを含むパスIDを以前に生成したnSFFによって決定されます（ セクション6.2.5.1を参照）。 パス更新でノード識別子情報を受信すると、影響を受けるnSFFは、FQDNをパスIDにマッピングする内部テーブルをチェックして、リンクの問題の影響を受けるパスIDを特定し、受信したノード識別子を含むパス情報を削除します。 このために、上記のテーブルのpathIDエントリは、FQDNへのpathIDにリンクが含まれているかどうかを確認するために、バイナリAND / CMP操作によってパス更新のIDエントリで提供されるlinkID値と照合されます。 pathIDが影響を受ける場合、FQDN-pathIDエントリが削除され、適切なFQDNへの次のリモートnSFF転送で新しいNR検出要求が発生します。"
    },
    {
      "indent": 0,
      "text": "6.2.5.4. Forwarding to Remote nSFF",
      "section_title": true,
      "ja": "6.2.5.4. リモートnSFFへの転送"
    },
    {
      "indent": 3,
      "text": "Once Steps 5, 6, and 7 in Section 5.6 are being executed, Step 8 finally sends the SFC packet to the remote nSFF, utilizing the pathID returned in the discovery request (Section 6.2.5.1) or retrieved from the local pathID mapping table. The SFC packet is placed in the payload of the generic forwarding format in Figure 5 together with the pathID, and the nSFF eventually executes the forwarding operations in Section 6.2.1.",
      "ja": "セクション5.6のステップ5、6、および7が実行されると、ステップ8は、ディスカバリー要求（セクション6.2.5.1）で返されるか、ローカルpathIDマッピングテーブルから取得されたpathIDを使用して、SFCパケットをリモートnSFFに送信します。 SFCパケットは、pathIDとともに図5の汎用転送形式のペイロードに配置され、nSFFは最終的にセクション6.2.1の転送操作を実行します。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Sections 5 and 6 describe the forwarding of SFC packets between named SFs based on URIs exchanged in HTTP messages. Security is needed to protect the communications between originating node and Ssff, between one Nsff and the next Nsff, and between Nsff and destination. TLS is sufficient for this and SHOULD be used. The TLS handshake allows to determine the FQDN, which, in turn, is enough for the service routing decision. Supporting TLS also allows the possibility of HTTPS-based transactions.",
      "ja": "セクション5および6では、HTTPメッセージで交換されるURIに基づいた名前付きSF間のSFCパケットの転送について説明します。 発信元ノードとSsffの間、1つのNsffと次のNsffの間、およびNsffと宛先の間の通信を保護するには、セキュリティが必要です。 これにはTLSで十分であり、使用する必要があります。 TLSハンドシェイクにより、FQDNを決定できます。これは、サービスルーティングの決定に十分です。 TLSをサポートすると、HTTPSベースのトランザクションの可能性も可能になります。"
    },
    {
      "indent": 3,
      "text": "It should be noted (per [RFC3986]) that what a URI resolves to is not necessarily stable. This can allow flexibility in deployment, as described in this document, but may also result in unexpected behavior and could provide an attack vector as the resolution of a URI could be \"hijacked\" resulting in packets being steered to the wrong place. This could be particularly important if the SFC is intended to send packets for processing at security functions. Such hijacking is a new attack surface introduced by using a separate NR.",
      "ja": "（[RFC3986]に従って）URIが解決する対象は必ずしも安定していないことに注意する必要があります。 これにより、このドキュメントで説明されているように展開の柔軟性が得られますが、予期しない動作が発生したり、URIの解決が「ハイジャック」されてパケットが間違った場所に送られる可能性があるため、攻撃ベクトルが提供される可能性があります。 SFCがセキュリティ機能での処理のためにパケットを送信することを意図している場合、これは特に重要です。 このようなハイジャックは、別のNRを使用することにより導入される新しい攻撃対象です。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ・リー、T。、フィールディング、R。、およびL.マスインター、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<https：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function Chaining (SFC) Architecture\", RFC 7665, DOI 10.17487/RFC7665, October 2015, <https://www.rfc-editor.org/info/rfc7665>.",
      "ja": "[RFC7665] Halpern、J.、Ed。 およびC.ピグナタロ編、「Service Function Chaining（SFC）Architecture」、RFC 7665、DOI 10.17487 / RFC7665、2015年10月、<https://www.rfc-editor.org/info/rfc7665>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8279] Wijnands, IJ., Ed., Rosen, E., Ed., Dolganow, A., Przygienda, T., and S. Aldrin, \"Multicast Using Bit Index Explicit Replication (BIER)\", RFC 8279, DOI 10.17487/RFC8279, November 2017, <https://www.rfc-editor.org/info/rfc8279>.",
      "ja": "[RFC8279] Wijnands、IJ。、Ed。、Rosen、E.、Ed。、Dolganow、A.、Przygienda、T。、およびS. Aldrin、「BitIndex Explicit Replication（BIER）を使用したマルチキャスト」、RFC 8279、DOI 10.17487 / RFC8279、2017年11月、<https://www.rfc-editor.org/info/rfc8279>。"
    },
    {
      "indent": 3,
      "text": "[RFC8300] Quinn, P., Ed., Elzur, U., Ed., and C. Pignataro, Ed., \"Network Service Header (NSH)\", RFC 8300, DOI 10.17487/RFC8300, January 2018, <https://www.rfc-editor.org/info/rfc8300>.",
      "ja": "[RFC8300]クイン、P。、エド、エルズール、U。、エド、およびC.ピグナタロ、エド、「ネットワークサービスヘッダー（NSH）」、RFC 8300、DOI 10.17487 / RFC8300、2018年1月、 //www.rfc-editor.org/info/rfc8300>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BIER-MULTICAST] Trossen, D., Rahman, A., Wang, C., and T. Eckert, \"Applicability of BIER Multicast Overlay for Adaptive Streaming Services\", Work in Progress, Internet-Draft, draft-ietf-bier-multicast-http-response-01, 28 June 2019, <https://tools.ietf.org/html/draft-ietf-bier-multicast-http-response-01>.",
      "ja": "[BIER-MULTICAST] Trossen、D.、Rahman、A.、Wang、C.、T。Eckert、「アダプティブストリーミングサービスへのBIERマルチキャストオーバーレイの適用性」、Work in Progress、Internet-Draft、draft-ietf-bier -multicast-http-response-01、2019年6月28日、<https://tools.ietf.org/html/draft-ietf-bier-multicast-http-response-01>"
    },
    {
      "indent": 3,
      "text": "[Reed2016] Reed, M.J., Al-Naday, M., Thomas, N., Trossen, D., Petropoulos, G., and S. Spirou, \"Stateless multicast switching in software defined networks\", IEEE ICC 2016, DOI 10.1109/ICC.2016.7511036, May 2016, <https://ieeexplore.ieee.org/document/7511036>.",
      "ja": "[Reed2016] Reed、MJ、Al-Naday、M.、Thomas、N.、Trossen、D.、Petropoulos、G。、およびS. Spirou、「ソフトウェア定義ネットワークでのステートレスマルチキャストスイッチング」、IEEE ICC 2016、DOI 10.1109 /ICC.2016.7511036、2016年5月、<https://ieeexplore.ieee.org/document/7511036>。"
    },
    {
      "indent": 3,
      "text": "[Schlinker2017] Schlinker, B., Kim, H., Cui, T., Katz-Bassett, E., Madhyastha, H., Cunha, I., Quinn, J., Hassan, S., Lapukhov, P., and H. Zeng, \"Engineering Egress with Edge Fabric, Steering Oceans of Content to the World\", ACM SIGCOMM 2017, August 2017, <https://research.fb.com/wp-content/uploads/2017/08/sigcomm17-final177-2billion.pdf>.",
      "ja": "[Schlinker2017] Schlinker、B.、Kim、H.、Cui、T.、Katz-Bassett、E.、Madhyastha、H.、Cunha、I.、Quinn、J.、Hassan、S.、Lapukhov、P.、 およびH. Zeng、「Edge Fabricを使用したエンジニアリング、コンテンツの世界を世界に導く」、ACM SIGCOMM 2017、2017年8月、<https://research.fb.com/wp-content/uploads/2017/08/sigcomm17 -final177-2billion.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SDO-3GPP-SBA] 3GPP, \"Technical Realization of Service Based Architecture\", 3GPP TS 29.500 V15.5.0, September 2019, <https://www.3gpp.org/ftp/Specs/html-info/29500.htm>.",
      "ja": "[SDO-3GPP-SBA] 3GPP、「サービスベースのアーキテクチャの技術的実現」、3GPP TS 29.500 V15.5.0、2019年9月、<https://www.3gpp.org/ftp/Specs/html-info/29500.htm >。"
    },
    {
      "indent": 3,
      "text": "[SDO-3GPP-SBA-ENHANCEMENT] 3GPP, \"New SID for Enhancements to the Service-Based 5G System Architecture\", 3GPP S2-182904, February 2018, <https://www.3gpp.org/ftp/tsg_sa/WG2_Arch/ TSGS2_126_Montreal/Docs/S2-182904.zip>.",
      "ja": "[SDO-3GPP-SBA-ENHANCEMENT] 3GPP、「サービスベースの5Gシステムアーキテクチャの拡張のための新しいSID」、3GPP S2-182904、2018年2月、<https://www.3gpp.org/ftp/tsg_sa/WG2_Arch / TSGS2_126_Montreal / Docs / S2-182904.zip>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Dirk von Hugo and Andrew Malis for their reviews and valuable comments. We would also like to thank Joel Halpern, the chair of the SFC WG, and Adrian Farrel for guiding us through the Independent Submission Editor (ISE) path.",
      "ja": "著者は、レビューと貴重なコメントについてDirk von HugoとAndrew Malisに感謝します。 また、SFC WGの議長であるJoel Halpernと、Independent Submission Editor（ISE）の道を案内してくれたAdrian Farrelにも感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dirk Trossen InterDigital Europe, Ltd 64 Great Eastern Street, 1st Floor London EC2A 3QR United Kingdom",
      "ja": "Dirk Trossen InterDigital Europe、Ltd 64 Great Eastern Street、1st Floor London EC2A 3QRイギリス"
    },
    {
      "indent": 3,
      "text": "Email: Dirk.Trossen@InterDigital.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Debashish Purkayastha InterDigital Communications, LLC 1001 E Hector St Conshohocken, PA United States of America",
      "ja": "Debashish Purkayastha InterDigital Communications、LLC 1001 E Hector St Conshohocken、PAアメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: Debashish.Purkayastha@InterDigital.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Akbar Rahman InterDigital Communications, LLC 1000 Sherbrooke Street West Montreal Canada",
      "ja": "Akbar Rahman InterDigital Communications、LLC 1000 Sherbrooke Street West West Montreal Canada"
    },
    {
      "indent": 3,
      "text": "Email: Akbar.Rahman@InterDigital.com",
      "raw": true
    }
  ]
}