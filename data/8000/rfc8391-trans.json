{
  "title": {
    "text": "RFC 8391 - XMSS: eXtended Merkle Signature Scheme",
    "ja": "RFC 8391 - XMSS：マークル署名方式を拡張されました"
  },
  "number": 8391,
  "created_at": "2019-11-02 11:00:43.374438+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Huelsing\nRequest for Comments: 8391                                  TU Eindhoven\nCategory: Informational                                         D. Butin\nISSN: 2070-1721                                             TU Darmstadt\n                                                               S. Gazdag\n                                                              genua GmbH\n                                                            J. Rijneveld\n                                                      Radboud University\n                                                             A. Mohaisen\n                                           University of Central Florida\n                                                                May 2018",
      "raw": true
    },
    {
      "indent": 17,
      "text": "XMSS: eXtended Merkle Signature Scheme",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This note describes the eXtended Merkle Signature Scheme (XMSS), a hash-based digital signature system that is based on existing descriptions in scientific literature. This note specifies Winternitz One-Time Signature Plus (WOTS+), a one-time signature scheme; XMSS, a single-tree scheme; and XMSS^MT, a multi-tree variant of XMSS. Both XMSS and XMSS^MT use WOTS+ as a main building block. XMSS provides cryptographic digital signatures without relying on the conjectured hardness of mathematical problems. Instead, it is proven that it only relies on the properties of cryptographic hash functions. XMSS provides strong security guarantees and is even secure when the collision resistance of the underlying hash function is broken. It is suitable for compact implementations, is relatively simple to implement, and naturally resists side-channel attacks. Unlike most other signature systems, hash-based signatures can so far withstand known attacks using quantum computers.",
      "ja": "このノートは、拡張マークル署名方式（XMSS）、科学文献において既存の記述に基づいてハッシュベースのデジタル署名システムを記載しています。このノートはWinternitzワンタイム署名プラス（WOTS +）、ワンタイム署名方式を指定します。 XMSS、単一ツリースキーム。そしてXMSS ^ MT、XMSSの多木の変種。 XMSSとXMSSの両方が^ MTは、メインのビルディングブロックとしてWOTS +を使用します。 XMSSは、数学の問題の推測さ硬さに依存することなく、暗号化、デジタル署名を提供します。代わりに、唯一の暗号学的ハッシュ関数の性質に依存していることが証明されました。 XMSSは、強力なセキュリティ保証を提供し、基礎となるハッシュ関数の衝突困難性が破られた場合であっても安全です。これは、コンパクトな実装に適して実装することが比較的簡単であり、自然にサイドチャネル攻撃に抵抗します。他のほとんどの署名システムとは異なり、ハッシュベースのシグネチャは、これまでの量子コンピュータを使用して既知の攻撃に耐えることができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の暗号化フォーラム研究グループのコンセンサスを表しています。 IRSGによって公表のために承認された文書はインターネットStandardのどんなレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8391.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8391で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. CFRG Note on Post-Quantum Cryptography .....................6\n   1.2. Conventions Used in This Document ..........................7\n2. Notation ........................................................7\n   2.1. Data Types .................................................7\n   2.2. Functions ..................................................7\n   2.3. Operators ..................................................8\n   2.4. Integer-to-Byte Conversion .................................9\n   2.5. Hash Function Address Scheme ...............................9\n   2.6. Strings of Base w Numbers .................................12\n   2.7. Member Functions ..........................................13\n3. Primitives .....................................................14\n   3.1. WOTS+: One-Time Signatures ................................14\n        3.1.1. WOTS+ Parameters ...................................14\n               3.1.1.1. WOTS+ Functions ...........................15\n        3.1.2. WOTS+ Chaining Function ............................15\n        3.1.3. WOTS+ Private Key ..................................16\n        3.1.4. WOTS+ Public Key ...................................17\n        3.1.5. WOTS+ Signature Generation .........................17\n        3.1.6. WOTS+ Signature Verification .......................19\n        3.1.7. Pseudorandom Key Generation ........................20\n4. Schemes ........................................................20\n   4.1. XMSS: eXtended Merkle Signature Scheme ....................20\n        4.1.1. XMSS Parameters ....................................21\n        4.1.2. XMSS Hash Functions ................................22\n        4.1.3. XMSS Private Key ...................................22\n        4.1.4. Randomized Tree Hashing ............................23\n        4.1.5. L-Trees ............................................23\n        4.1.6. TreeHash ...........................................24\n        4.1.7. XMSS Key Generation ................................25\n        4.1.8. XMSS Signature .....................................27\n        4.1.9. XMSS Signature Generation ..........................28\n        4.1.10. XMSS Signature Verification .......................30\n        4.1.11. Pseudorandom Key Generation .......................32\n        4.1.12. Free Index Handling and Partial Private Keys ......33\n   4.2. XMSS^MT: Multi-Tree XMSS ..................................33\n        4.2.1. XMSS^MT Parameters .................................33\n        4.2.2. XMSS^MT Key Generation .............................33\n        4.2.3. XMSS^MT Signature ..................................36\n        4.2.4. XMSS^MT Signature Generation .......................37\n        4.2.5. XMSS^MT Signature Verification .....................39\n        4.2.6. Pseudorandom Key Generation ........................40\n        4.2.7. Free Index Handling and Partial Private Keys .......40",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. Parameter Sets .................................................40\n   5.1. Implementing the Functions ................................41\n   5.2. WOTS+ Parameters ..........................................43\n   5.3. XMSS Parameters ...........................................43\n        5.3.1. Parameter Guide ....................................44\n   5.4. XMSS^MT Parameters ........................................45\n        5.4.1. Parameter Guide ....................................47\n6. Rationale ......................................................49\n7. Reference Code .................................................50\n8. IANA Considerations ............................................50\n9. Security Considerations ........................................54\n   9.1. Security Proofs ...........................................55\n   9.2. Minimal Security Assumptions ..............................56\n   9.3. Post-Quantum Security .....................................56\n10. References ....................................................57\n   10.1. Normative References .....................................57\n   10.2. Informative References ...................................58\nAppendix A.  WOTS+ XDR Formats ....................................60\n  A.1.  WOTS+ Parameter Sets ......................................60\n  A.2.  WOTS+ Signatures ..........................................60\n  A.3.  WOTS+ Public Keys .........................................61\nAppendix B.  XMSS XDR Formats .....................................61\n  B.1.  XMSS Parameter Sets .......................................61\n  B.2.  XMSS Signatures ...........................................62\n  B.3.  XMSS Public Keys ..........................................64\nAppendix C.  XMSS^MT XDR Formats ..................................65\n  C.1.  XMSS^MT Parameter Sets ....................................65\n  C.2.  XMSS^MT Signatures ........................................67\n  C.3.  XMSS^MT Public Keys .......................................71\nAcknowledgements ..................................................73\nAuthors' Addresses ................................................74",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A (cryptographic) digital signature scheme provides asymmetric message authentication. The key generation algorithm produces a key pair consisting of a private and a public key. A message is signed using a private key to produce a signature. A message/signature pair can be verified using a public key. A One-Time Signature (OTS) scheme allows using a key pair to sign exactly one message securely. A Many-Time Signature (MTS) system can be used to sign multiple messages.",
      "ja": "（暗号化）デジタル署名方式は、非対称メッセージ認証を提供します。鍵生成アルゴリズムは、秘密鍵と公開鍵からなる鍵ペアを生成します。メッセージは、署名を生成するための秘密鍵を用いて署名されます。メッセージ/署名ペアは、公開鍵を用いて検証することができます。ワンタイム署名（OTS）方式が確実に正確に一つのメッセージに署名する鍵のペアを使用することを可能にします。多くのタイムシグネチャ（MTS）システムは、複数のメッセージに署名するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "OTS schemes, and MTS schemes composed from them, were proposed by Merkle in 1979 [Merkle83]. They were well-studied in the 1990s and have regained interest from the mid 2000s onwards because of their resistance against quantum-computer-aided attacks. These kinds of signature schemes are called hash-based signature schemes as they are built out of a cryptographic hash function. Hash-based signature schemes generally feature small private and public keys as well as fast signature generation and verification; however, they also feature large signatures and relatively slow key generation. In addition, they are suitable for compact implementations that benefit various applications and are naturally resistant to most kinds of side-channel attacks.",
      "ja": "OTS方式、及びそれらから構成されるMTSスキームは、[Merkle83] 1979年マークルによって提案されました。彼らは1990年代によく研究しているため、量子コンピュータ支援攻撃に対するその抵抗の半ば以降、2000年代からの関心を取り戻していました。それらは暗号ハッシュ関数から構築されているとして、署名方式のこれらの種類は、ハッシュベース署名方式と呼ばれています。ハッシュベース署名方式は、一般的に小さな秘密鍵と公開鍵だけでなく、高速な署名生成と検証を備えています。しかし、彼らはまた、大規模な署名と比較的遅いキー生成を備えています。加えて、それらは様々な用途に有益とサイドチャネル攻撃のほとんどの種類に天然に耐性であるコンパクトな実装に適しています。"
    },
    {
      "indent": 3,
      "text": "Some progress has already been made toward introducing and standardizing hash-based signatures. Buchmann, Dahmen, and Huelsing proposed the eXtended Merkle Signature Scheme (XMSS) [BDH11], which offers better efficiency than Merkle's original scheme and a modern security proof in the standard model. McGrew, Curcio, and Fluhrer authored an Internet-Draft [MCF18] specifying the Leighton-Micali Signature (LMS) scheme, which builds on the seminal works by Lamport, Diffie, Winternitz, and Merkle, taking a different approach than XMSS and relying entirely on security arguments in the random oracle model. Very recently, the stateless hash-based signature scheme SPHINCS was introduced [BHH15], with the intent of being easier to deploy in current applications. A reasonable next step toward introducing hash-based signatures is to complete the specifications of the basic algorithms -- LMS, XMSS, SPHINCS, and/or variants.",
      "ja": "いくつかの進展がすでにハッシュベースの署名を導入し、標準化に向けて行われています。 Buchmann、Dahmen、およびHuelsingは、拡張マークル署名方式マークルのオリジナルのスキームと標準モデルで近代的なセキュリティ証明よりも優れた効率を提供しています（XMSS）[BDH11]を、提案しました。マグリュー、Curcio、及びFluhrerはインターネットドラフトは[MCF18] XMSSは異なるアプローチをとり、完全に頼って、ランポート、ディフィー、Winternitz、及びマークルによって精液作品の上に構築レイトン-Micali署名（LMS）スキームを指定執筆ランダムオラクルモデルにおけるセキュリティの引数に。ごく最近、ステートレスハッシュベース署名方式SPHINCSは、現在のアプリケーションに展開することが容易であることを意図して、[BHH15]導入しました。 LMS、XMSS、SPHINCS、および/または変異体 - ハッシュベースの署名を導入するに向かって合理次のステップは、基本的なアルゴリズムの仕様を完了することです。"
    },
    {
      "indent": 3,
      "text": "The eXtended Merkle Signature Scheme (XMSS) [BDH11] is the latest stateful hash-based signature scheme. It has the smallest signatures out of such schemes and comes with a multi-tree variant that solves the problem of slow key generation. Moreover, it can be shown that XMSS is secure, making only mild assumptions on the underlying hash function. In particular, it is not required that the cryptographic hash function is collision-resistant for the security of XMSS. Improvements upon XMSS, as described in [HRS16], are part of this note.",
      "ja": "拡張マークル署名方式（XMSS）は[BDH11]最新ステートフルハッシュベース署名方式です。このようなスキームのうち最小のシグネチャがあり、ゆっくりと鍵生成の問題を解決し、マルチツリーバリアントが付属しています。また、基礎となるハッシュ関数にのみ軽度の仮定を作る、XMSSが安全であることを示すことができます。特に、暗号ハッシュ関数が衝突耐性XMSSのセキュリティのためのものであることが必要とされません。 XMSS時の改善は、[HRS16]に記載されているように、このノートの一部です。"
    },
    {
      "indent": 3,
      "text": "This document describes a single-tree and a multi-tree variant of XMSS. It also describes WOTS+, a variant of the Winternitz OTS scheme introduced in [Huelsing13] that is used by XMSS. The schemes are described with enough specificity to ensure interoperability between implementations.",
      "ja": "この文書では、単一のツリーとXMSSのマルチツリーバリアントを記述する。またWOTS +、XMSSによって使用される[Huelsing13]で導入Winternitz OTS方式の変異体を記載します。スキームが実装間の相互運用性を確保するために十分な特異性で説明されています。"
    },
    {
      "indent": 3,
      "text": "This document is structured as follows. Notation is introduced in Section 2. Section 3 describes the WOTS+ signature system. MTS schemes are defined in Section 4: the eXtended Merkle Signature Scheme (XMSS) in Section 4.1 and its multi-tree variant (XMSS^MT) in Section 4.2. Parameter sets are described in Section 5. Section 6 describes the rationale behind choices in this note. Section 7 gives information about the reference code. The IANA registry for these signature systems is described in Section 8. Finally, security considerations are presented in Section 9.",
      "ja": "次のようにこの文書では、構成されています。表記は第2セクション3に導入されWOTS +署名システムが記載されています。第4.2節4.1およびそのマルチツリーバリアント（XMSS ^ MT）に延びマークル署名方式（XMSS）：MTSスキームは、セクション4で定義されています。パラメータセットは、第5節第6節で説明されているこのノートの選択肢の理論的根拠を説明しています。第7節は、参照コードについての情報を提供します。これらの署名システムのためのIANAレジストリが最後にセクション8に記載されている、セキュリティ問題はセクション9に示されています。"
    },
    {
      "indent": 0,
      "text": "1.1. CFRG Note on Post-Quantum Cryptography",
      "section_title": true,
      "ja": "1.1. ポスト量子暗号のCFRG注意"
    },
    {
      "indent": 3,
      "text": "All post-quantum algorithms documented by the Crypto Forum Research Group (CFRG) are today considered ready for experimentation and further engineering development (e.g., to establish the impact of performance and sizes on IETF protocols). However, at the time of writing, we do not have significant deployment experience with such algorithms.",
      "ja": "暗号フォーラム研究グループ（CFRG）によって文書のすべてのポスト量子アルゴリズムが今日ある（例えば、IETFプロトコルのパフォーマンスとサイズの影響を確立するために）実験やさらなる技術開発のための準備を検討しました。しかし、執筆の時点で、我々はそのようなアルゴリズムと有意な展開の経験を持っていません。"
    },
    {
      "indent": 3,
      "text": "Many of these algorithms come with specific restrictions, e.g., change of classical interface or less cryptanalysis of proposed parameters than established schemes. CFRG has consensus that all documents describing post-quantum technologies include the above paragraph and a clear additional warning about any specific restrictions, especially as those might affect use or deployment of the specific scheme. That guidance may be changed over time via document updates.",
      "ja": "これらのアルゴリズムの多くは、特定の制限、古典的なインターフェイスまたは確立の方式より提案されたパラメータの少ない暗号解読の、例えば、変化してきます。 CFRGは、ポスト量子技術を記述するすべての文書は、それらが特定のスキームの使用または展開に影響を与える可能性がある、特にとして、上の段落および任意の特定の制限について明確な追加の警告が含まれていることを合意しています。そのガイダンスは、ドキュメントの更新を経て時間をかけて変更することができます。"
    },
    {
      "indent": 3,
      "text": "Additionally, for XMSS:",
      "ja": "また、XMSSについて："
    },
    {
      "indent": 3,
      "text": "CFRG consensus is that we are confident in the cryptographic security of the signature schemes described in this document against quantum computers, given the current state of the research community's knowledge about quantum algorithms. Indeed, we are confident that the security of a significant part of the Internet could be made dependent on the signature schemes defined in this document, if developers take care of the following.",
      "ja": "CFRGコンセンサスは、我々は、量子アルゴリズムに関する研究コミュニティの知識の現在の状態を考えると、量子コンピュータに対してこの文書で説明した署名方式の暗号化セキュリティに自信を持っているということです。確かに、我々は、開発者は、次のの世話をする場合は、インターネットの重要な部分のセキュリティは、この文書で定義された署名方式に依存させることができると確信しています。"
    },
    {
      "indent": 3,
      "text": "In contrast to traditional signature schemes, the signature schemes described in this document are stateful, meaning the secret key changes over time. If a secret key state is used twice, no cryptographic security guarantees remain. In consequence, it becomes feasible to forge a signature on a new message. This is a new property that most developers will not be familiar with and requires careful handling of secret keys. Developers should not use the schemes described here except in systems that prevent the reuse of secret key states.",
      "ja": "伝統的な署名方式とは対照的に、このドキュメントで説明する署名方式は、時間をかけて、秘密鍵の変更を意味し、ステートフルです。秘密キーの状態が2回使用されている場合、暗号化セキュリティの保証が残っていません。その結果、それが新しいメッセージに署名を偽造することが可能となります。これは、ほとんどの開発者が精通していないだろう新しいプロパティであり、秘密鍵の慎重な取り扱いが必要です。開発者は、秘密鍵の状態の再利用を防止するためのシステムを除き、ここで説明するスキームを使用するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note that the fact that the schemes described in this document are stateful also implies that classical APIs for digital signatures cannot be used without modification. The API MUST be able to handle a secret key state; in particular, this means that the API MUST allow to return an updated secret key state.",
      "ja": "この文書に記載さスキームは、ステートフルであるという事実は、デジタル署名のための古典的なAPIをそのまま使用することができないことを意味することに留意されたいです。 APIは、秘密鍵の状態を扱うことができなければなりません。特に、これはAPIが更新された秘密鍵の状態を返すことができるようにしなければならないことを意味します。"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.2. このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Notation",
      "section_title": true,
      "ja": "2.記法"
    },
    {
      "indent": 0,
      "text": "2.1. Data Types",
      "section_title": true,
      "ja": "2.1. データの種類"
    },
    {
      "indent": 3,
      "text": "Bytes and byte strings are the fundamental data types. A byte is a sequence of eight bits. A single byte is denoted as a pair of hexadecimal digits with a leading \"0x\". A byte string is an ordered sequence of zero or more bytes and is denoted as an ordered sequence of hexadecimal characters with a leading \"0x\". For example, 0xe534f0 is a byte string of length 3. An array of byte strings is an ordered, indexed set starting with index 0 in which all byte strings have identical length. We assume big-endian representation for any data types or structures.",
      "ja": "バイト、バイト文字列は、基本的なデータ型です。バイトは8ビットのシーケンスです。単一バイトは先頭の「0x」で16進数の対として示されます。バイト列は、ゼロ以上のバイトの順序付きシーケンスであり、先頭の「0x」で進文字の順序付きシーケンスとして示されます。例えば、0xe534f0は、バイト文字列の配列は、すべてのバイト文字列が同一の長さを有しているインデックス0から始まる順序付け、インデックス付きセットの長さ3のバイト列です。私たちは、任意のデータ型や構造のためのビッグエンディアン表現を前提としています。"
    },
    {
      "indent": 0,
      "text": "2.2. Functions",
      "section_title": true,
      "ja": "2.2. 機能"
    },
    {
      "indent": 3,
      "text": "If x is a non-negative real number, then we define the following functions:",
      "ja": "xが負でない実数であるならば、我々は次の関数を定義します。"
    },
    {
      "indent": 6,
      "text": "ceil(x): returns the smallest integer greater than or equal to x.",
      "ja": "CEIL（X）：x以上の最小の整数を返します。"
    },
    {
      "indent": 6,
      "text": "floor(x): returns the largest integer less than or equal to x.",
      "ja": "床（X）：x以下の最大の整数を返します。"
    },
    {
      "indent": 6,
      "text": "lg(x): returns the logarithm to base 2 of x.",
      "ja": "LG（X）は、Xの2を底とする対数を返します。"
    },
    {
      "indent": 0,
      "text": "2.3. Operators",
      "section_title": true,
      "ja": "2.3. 演算子"
    },
    {
      "indent": 3,
      "text": "When a and b are integers, mathematical operators are defined as follows:",
      "ja": "aとbが整数である場合は、次のように、数学的な演算子が定義されています。"
    },
    {
      "indent": 6,
      "text": "^ : a ^ b denotes the result of a raised to the power of b.",
      "ja": "^：A ^ Bは、B乗の結果を示しています。"
    },
    {
      "indent": 6,
      "text": "* : a * b denotes the product of a and b. This operator is sometimes omitted in the absence of ambiguity, as in usual mathematical notation.",
      "ja": "*：* bは、aとbの積を示しています。この演算子は、時々、通常の数学表記のように、曖昧さが存在しない場合には省略されています。"
    },
    {
      "indent": 6,
      "text": "/ : a / b denotes the quotient of a by non-zero b.",
      "ja": "/ A / Bは、非ゼロbでの商を意味します。"
    },
    {
      "indent": 6,
      "text": "% : a % b denotes the non-negative remainder of the integer division of a by b.",
      "ja": "％：％bはbでの整数除算の非負の余りを表します。"
    },
    {
      "indent": 6,
      "text": "+ : a + b denotes the sum of a and b.",
      "ja": "+：A + Bは、aとbの合計を表しています。"
    },
    {
      "indent": 6,
      "text": "- : a - b denotes the difference of a and b.",
      "ja": " - ： -  bがaとbの違いを示しています。"
    },
    {
      "indent": 6,
      "text": "++ : a++ denotes incrementing a by 1, i.e., a = a + 1.",
      "ja": "++：++ 1、すなわち、A = A + 1ずつ増加です。"
    },
    {
      "indent": 6,
      "text": "<< : a << b denotes a logical left shift with b being non-negative, i.e., a * 2^b.",
      "ja": "<<：<< Bは、Bは、すなわち、* 2 ^ B、非負であるとの論理左シフトを表します。"
    },
    {
      "indent": 6,
      "text": ">> : a >> b denotes a logical right shift with b being non-negative, i.e., floor(a / 2^b).",
      "ja": ">>：A >> Bが非負、すなわち、床（/ 2 ^ b）はBの論理右シフトを示しています。"
    },
    {
      "indent": 3,
      "text": "The standard order of operations is used when evaluating arithmetic expressions.",
      "ja": "算術式を評価する際の動作の標準的な順序が使用されます。"
    },
    {
      "indent": 3,
      "text": "Arrays are used in the common way, where the i^th element of an array A is denoted A[i]. Byte strings are treated as arrays of bytes where necessary: if X is a byte string, then X[i] denotes its i^th byte, where X[0] is the leftmost byte.",
      "ja": "アレイは、アレイAのI ^番目の要素は、[I]で示される一般的な方法で使用されます。バイト列はバイト必要な場合の配列として扱われる：Xは、バイト文字列である場合、X [i]はX [0]左端のバイトであり、そのI ^番目のバイトを表します。"
    },
    {
      "indent": 3,
      "text": "If A and B are byte strings of equal length, then:",
      "ja": "A及びBは、次いで、等しい長さのバイト列である場合。"
    },
    {
      "indent": 3,
      "text": "o A AND B denotes the bitwise logical conjunction operation.",
      "ja": "O AおよびBは、ビット単位の論理積演算を表します。"
    },
    {
      "indent": 3,
      "text": "o A XOR B denotes the bitwise logical exclusive disjunction operation.",
      "ja": "O XOR Bは、ビット単位の排他的論理和演算を表します。"
    },
    {
      "indent": 3,
      "text": "When B is a byte and i is an integer, then B >> i denotes the logical right-shift operation.",
      "ja": "Bはバイトであり、iは整数であるとき、B >>私は論理右シフト演算を表します。"
    },
    {
      "indent": 3,
      "text": "If X is an x-byte string and Y a y-byte string, then X || Y denotes the concatenation of X and Y, with X || Y = X[0] ... X[x-1] Y[0] ... Y[y-1].",
      "ja": "その後、Xは、xバイトの文字列とYである場合、Yバイトの文字列、X || YはXと、XとYの連結を意味|| Y = xで[0] ... X [X-1] Y [0] ... Y [Y-1]。"
    },
    {
      "indent": 0,
      "text": "2.4. Integer-to-Byte Conversion",
      "section_title": true,
      "ja": "2.4. 整数・ツー・バイトの変換"
    },
    {
      "indent": 3,
      "text": "If x and y are non-negative integers, we define Z = toByte(x, y) to be the y-byte string containing the binary representation of x in big-endian byte order.",
      "ja": "xおよびyは非負整数である場合、我々は、Z = toByte（x、y）はビッグエンディアンバイト順にxのバイナリ表現を含むYバイト文字列であると定義します。"
    },
    {
      "indent": 0,
      "text": "2.5. Hash Function Address Scheme",
      "section_title": true,
      "ja": "2.5. ハッシュ関数のアドレススキーマ"
    },
    {
      "indent": 3,
      "text": "The schemes described in this document randomize each hash function call. This means that aside from the initial message digest, a different key and different bitmask is used for each hash function call. These values are pseudorandomly generated using a pseudorandom function that takes a key SEED and a 32-byte address ADRS as input and outputs an n-byte value, where n is the security parameter. Here we explain the structure of address ADRS and propose setter methods to manipulate the address. We explain the generation of the addresses in the following sections where they are used.",
      "ja": "このドキュメントで説明するスキームは、各ハッシュ関数の呼び出しをランダム化します。これは別に、初期メッセージダイジェストから、異なるキーと異なるビットマスクが各ハッシュ関数の呼び出しに使用されることを意味します。これらの値は擬似ランダム入力としてキーSEEDと32バイトのアドレスADRSを取り、nはセキュリティパラメータであるnバイト値を出力する擬似ランダム関数を用いて生成されます。ここでは、アドレスADRSの構造を説明し、アドレスを操作するためのセッターメソッドを提案しています。我々は、彼らが使用されている次のセクションでのアドレスの生成を説明します。"
    },
    {
      "indent": 3,
      "text": "The schemes in the next two sections use two kinds of hash functions parameterized by security parameter n. For the hash tree constructions, a hash function that maps an n-byte key and 2n-byte inputs to n-byte outputs is used. To randomize this function, 3n bytes are needed -- n bytes for the key and 2n bytes for a bitmask. For the OTS scheme constructions, a hash function that maps n-byte keys and n-byte inputs to n-byte outputs is used. To randomize this function, 2n bytes are needed -- n bytes for the key and n bytes for a bitmask. Consequently, three addresses are needed for the first function and two addresses for the second one.",
      "ja": "次の2つのセクション内のスキームは、セキュリティパラメータnによってパラメータ化ハッシュ関数の二種類を使用します。ハッシュツリー構造の場合、nバイトの出力にnバイトのキーと2Nバイトの入力をマップするハッシュ関数が使用されています。この機能をランダム化するために、3Nバイトが必要とされている - のnビットマスクのためのキーと2Nバイトのバイト。 OTSスキーム構造のために、nバイトの出力にnバイトのキーおよびnバイトの入力をマップするハッシュ関数が使用されます。この機能をランダム化するには、2n個のバイトが必要とされている - のnビットマスクのための鍵とnバイトのバイト。従って、3つのアドレスは、第1の機能および第2のいずれかの二つのアドレスのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "There are three different types of addresses for the different use cases. One type is used for the hashes in OTS schemes, one is used for hashes within the main Merkle tree construction, and one is used for hashes in the L-trees. The latter is used to compress one-time public keys. All these types share as much format as possible. In the remainder of this section, we describe these types in detail.",
      "ja": "異なるユースケースのためのアドレスの3種類があります。一つのタイプは、一方は主マークル木構造内のハッシュに使用されるOTSスキームにおけるハッシュに使用され、一方はL-木でハッシュするために使用されます。後者は、ワンタイム公開鍵を圧縮するために使用されます。すべてのこれらのタイプは、できるだけ多くのフォーマットを共有しています。このセクションの残りの部分では、我々は詳細にこれらのタイプについて説明します。"
    },
    {
      "indent": 3,
      "text": "The structure of an address complies with word borders, with a word being 32 bits long in this context. Only the tree address is too long to fit a single word, but it can fit a double word. An address is structured as follows. It always starts with a layer address of one word in the most significant bits, followed by a tree address of two words. Both addresses are needed for the multi-tree variant (see Section 4.2) and describe the position of a tree within a multi-tree. They are therefore set to zero in single-tree applications. For multi-tree hash-based signatures, the layer address describes the height of a tree within the multi-tree, starting from height zero for trees at the bottom layer. The tree address describes the position of a tree within a layer of a multi-tree starting with index zero for the leftmost tree. The next word defines the type of the address. It is set to 0 for an OTS address, to 1 for an L-tree address, and to 2 for a hash tree address. Whenever the type word of an address is changed, all following words should be initialized with 0 to prevent non-zero values in unused padding words.",
      "ja": "アドレスの構造は、この文脈では32ビットの長さの単語と、単語の境界に準拠します。唯一のツリー・アドレスは、単一の単語を収めるには長すぎるが、それはダブルワードを収めることができます。次のようにアドレスが構成されています。それは、常に2つの単語のツリー・アドレスに続く最上位ビットの1語の層アドレスで始まります。両方のアドレスはマルチツリー変異体のために必要とされる（セクション4.2参照）、マルチツリー内のツリーの位置を記述する。従って、それらは、単一のツリーのアプリケーションでゼロに設定されています。マルチツリーハッシュベースの署名のために、層のアドレスは、底部層でツリーの高さはゼロから出発して、マルチツリー内のツリーの高さを記載しています。ツリー・アドレスは、最も左側のツリーのインデックスはゼロから始まるマルチツリーの層内のツリーの位置を記載しています。次の言葉は、アドレスの種類を定義します。これは、L-ツリー・アドレスのための1、およびハッシュツリーアドレス2に、OTSアドレスを0に設定されています。アドレスの種類の単語が変更されるたびに、以下のすべての単語は、未使用のパディングワード内の非ゼロ値を防ぐために、0で初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "We first describe the OTS address case. In this case, the type word is followed by an OTS address word that encodes the index of the OTS key pair within the tree. The next word encodes the chain address followed by a word that encodes the address of the hash function call within the chain. The last word, called keyAndMask, is used to generate two different addresses for one hash function call. The word is set to zero to generate the key. To generate the n-byte bitmask, the word is set to one.",
      "ja": "我々は最初のOTSアドレスケースを説明します。この場合、タイプワードは、ツリー内のOTS鍵ペアのインデックスをコードOTSアドレスワードが続きます。次の単語は、チェーン内のハッシュ関数コールのアドレスをコードワードに続くチェーンアドレスを符号化します。 keyAndMaskと呼ばれる最後の言葉は、1つのハッシュ関数呼び出しのための2つの異なるアドレスを生成するために使用されます。単語は、キーを生成するためにゼロに設定されています。 nバイトのビットマスクを生成するには、ワードが1に設定されています。"
    },
    {
      "indent": 21,
      "text": "+-------------------------+\n| layer address  (32 bits)|\n+-------------------------+\n| tree address   (64 bits)|\n+-------------------------+\n| type = 0       (32 bits)|\n+-------------------------+\n| OTS address    (32 bits)|\n+-------------------------+\n| chain address  (32 bits)|\n+-------------------------+\n| hash address   (32 bits)|\n+-------------------------+\n| keyAndMask     (32 bits)|\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "An OTS Hash Address",
      "ja": "OTSハッシュアドレス"
    },
    {
      "indent": 3,
      "text": "We now discuss the L-tree case, which means that the type word is set to one. In that case, the type word is followed by an L-tree address word that encodes the index of the leaf computed with this L-tree. The next word encodes the height of the node being input for the next computation inside the L-tree. The following word encodes the index of the node at that height, inside the L-tree. This time, the last word, keyAndMask, is used to generate three different addresses for one function call. The word is set to zero to generate the key. To generate the most significant n bytes of the 2n-byte bitmask, the word is set to one. The least significant bytes are generated using the address with the word set to two.",
      "ja": "私たちは今、タイプワードが1に設定されていることを意味し、L-木のケースを議論します。その場合、タイプワードは、このL-ツリーで計算リーフのインデックスをコードLツリーアドレスワードが続きます。次の単語は、L-ツリー内の次の計算のために入力されたノードの高さを符号化します。次の単語は、L-ツリーの内部、その高さでのノードのインデックスを符号化します。この時間は、最後の言葉、keyAndMaskは、一つの関数呼び出しのための3つの異なるアドレスを生成するために使用されます。単語は、キーを生成するためにゼロに設定されています。 2Nバイトのビットマスクの最上位nバイトを生成するには、ワードが1に設定されています。最下位バイトは2に設定単語とアドレスを使用して生成されます。"
    },
    {
      "indent": 21,
      "text": "+-------------------------+\n| layer address  (32 bits)|\n+-------------------------+\n| tree address   (64 bits)|\n+-------------------------+\n| type = 1       (32 bits)|\n+-------------------------+\n| L-tree address (32 bits)|\n+-------------------------+\n| tree height    (32 bits)|\n+-------------------------+\n| tree index     (32 bits)|\n+-------------------------+\n| keyAndMask     (32 bits)|\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 29,
      "text": "An L-tree Address",
      "ja": "L-ツリー住所"
    },
    {
      "indent": 3,
      "text": "We now describe the remaining type for the main tree hash addresses. In this case, the type word is set to two, followed by a zero padding of one word. The next word encodes the height of the tree node being input for the next computation, followed by a word that encodes the index of this node at that height. As for the L-tree addresses, the last word, keyAndMask, is used to generate three different addresses for one function call. The word is set to zero to generate the key. To generate the most significant n bytes of the 2n-byte bitmask, the word is set to one. The least significant bytes are generated using the address with the word set to two.",
      "ja": "私たちは今、メインツリーのハッシュアドレスの残りのタイプを記述する。この場合、タイプワードは一つの単語のゼロパディング、続いて2つに設定されています。次の単語は、その高さで、このノードのインデックスをコードワードに続く次の計算のために入力されたツリーノードの高さを符号化します。 L-木アドレスについては、最後の言葉、keyAndMaskは、一つの関数呼び出しのための3つの異なるアドレスを生成するために使用されます。単語は、キーを生成するためにゼロに設定されています。 2Nバイトのビットマスクの最上位nバイトを生成するには、ワードが1に設定されています。最下位バイトは2に設定単語とアドレスを使用して生成されます。"
    },
    {
      "indent": 21,
      "text": "+-------------------------+\n| layer address  (32 bits)|\n+-------------------------+\n| tree address   (64 bits)|\n+-------------------------+\n| type = 2       (32 bits)|\n+-------------------------+\n| Padding = 0    (32 bits)|\n+-------------------------+\n| tree height    (32 bits)|\n+-------------------------+\n| tree index     (32 bits)|\n+-------------------------+\n| keyAndMask     (32 bits)|\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "A Hash Tree Address",
      "ja": "ハッシュツリー住所"
    },
    {
      "indent": 3,
      "text": "All fields within these addresses encode unsigned integers. When describing the generation of addresses we use setter methods that take positive integers and set the bits of a field to the binary representation of that integer of the length of the field. We furthermore assume that the setType() method sets the four words following the type word to zero.",
      "ja": "これらのアドレス内のすべてのフィールドは、符号なし整数を符号化します。アドレスの生成を説明するとき、我々は正の整数を取り、フィールドの長さの整数のバイナリ表現にフィールドのビットを設定セッターメソッドを使用します。我々は、さらにはsetType（）メソッドがゼロにタイプワードを、次の4つの単語を設定すると仮定する。"
    },
    {
      "indent": 0,
      "text": "2.6. Strings of Base w Numbers",
      "section_title": true,
      "ja": "2.6. 数字でベースの弦"
    },
    {
      "indent": 3,
      "text": "A byte string can be considered as a string of base w numbers, i.e., integers in the set {0, ... , w - 1}. The correspondence is defined by the function base_w(X, w, out_len) (Algorithm 1) as follows. If X is a len_X-byte string, and w is a member of the set {4, 16}, then base_w(X, w, out_len) outputs an array of out_len integers between 0 and w - 1. The length out_len is REQUIRED to be less than or equal to 8 * len_X / lg(w).",
      "ja": "バイト文字列を数値Wベースの文字列とみなすことができる、すなわち、セット内の整数{0、...、W  -  1}。対応は（アルゴリズム1）としては、以下の（out_len、W、X）関数base_wによって定義されます。 Xがlen_Xバイトの文字列であり、Wは（out_len、W、X）を、base_w集合{4,16}のメンバーであり、0とWとのout_len整数のアレイ出力する場合 -  1.長さを必要としているout_len以下8 * len_X / LG（W）に等しくなるように。"
    },
    {
      "indent": 3,
      "text": "Algorithm 1: base_w",
      "ja": "アルゴリズム1：base_w"
    },
    {
      "indent": 5,
      "text": "Input: len_X-byte string X, int w, output length out_len Output: out_len int array basew",
      "ja": "入力：len_Xバイトの文字列X、出力長out_len出力ワットint型：int配列のbasew out_len"
    },
    {
      "indent": 7,
      "text": "int in = 0;\nint out = 0;\nunsigned int total = 0;\nint bits = 0;\nint consumed;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for ( consumed = 0; consumed < out_len; consumed++ ) {\n    if ( bits == 0 ) {\n        total = X[in];\n        in++;\n        bits += 8;\n    }\n    bits -= lg(w);\n    basew[out] = (total >> bits) AND (w - 1);\n    out++;\n}\nreturn basew;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For example, if X is the (big-endian) byte string 0x1234, then base_w(X, 16, 4) returns the array a = {1, 2, 3, 4}.",
      "ja": "Xがbase_w次いで、（ビッグエンディアン）のバイト列が0x1234である場合、例えば、（X、16、4）配列a = {1、2、3、4}を返します。"
    },
    {
      "indent": 9,
      "text": "             X (represented as bits)\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n| 0| 0| 0| 1| 0| 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0|\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n           X[0]         |         X[1]",
      "raw": true
    },
    {
      "indent": 9,
      "text": "        X (represented as base 16 numbers)\n+-----------+-----------+-----------+-----------+\n|     1     |     2     |     3     |     4     |\n+-----------+-----------+-----------+-----------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "                 base_w(X, 16, 4)\n+-----------+-----------+-----------+-----------+\n|     1     |     2     |     3     |     4     |\n+-----------+-----------+-----------+-----------+\n    a[0]        a[1]        a[2]        a[3]",
      "raw": true
    },
    {
      "indent": 9,
      "text": "                 base_w(X, 16, 3)\n+-----------+-----------+-----------+\n|     1     |     2     |     3     |\n+-----------+-----------+-----------+\n    a[0]        a[1]        a[2]",
      "raw": true
    },
    {
      "indent": 9,
      "text": "                 base_w(X, 16, 2)\n+-----------+-----------+\n|     1     |     2     |\n+-----------+-----------+\n    a[0]        a[1]",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Example",
      "ja": "例"
    },
    {
      "indent": 0,
      "text": "2.7. Member Functions",
      "section_title": true,
      "ja": "2.7. メンバー関数"
    },
    {
      "indent": 3,
      "text": "To simplify algorithm descriptions, we assume the existence of member functions. If a complex data structure like a public key PK contains a value X, then getX(PK) returns the value of X for this public key. Accordingly, setX(PK, X, Y) sets value X in PK to the value held by Y. Since camelCase is used for member function names, a value z may be referred to as Z in the function name, e.g., getZ.",
      "ja": "アルゴリズムの説明を簡単にするために、我々は、メンバ関数の存在を前提としています。公開鍵PKのような複雑なデータ構造が値Xが含まれている場合は、のgetX（PK）は、この公開鍵のXの値を返します。従って、SETX（PK、X、Y）のメンバ関数名に使用されるキャメルケースのでY.が保持する値にPKの値Xを設定し、値Zは、例えば、関数名でZ、ゲッツと呼ぶことができます。"
    },
    {
      "indent": 0,
      "text": "3. Primitives",
      "section_title": true,
      "ja": "3.プリミティブ"
    },
    {
      "indent": 0,
      "text": "3.1. WOTS+: One-Time Signatures",
      "section_title": true,
      "ja": "3.1.  WOTS +：ワンタイム署名"
    },
    {
      "indent": 3,
      "text": "This section describes the WOTS+ system in a manner similar to that in [Huelsing13]. WOTS+ is an OTS scheme; while a private key can be used to sign any message, each private key MUST be used only once to sign a single message. In particular, if a private key is used to sign two different messages, the scheme becomes insecure.",
      "ja": "このセクションでは、[Huelsing13]と同様にWOTS +システムが記載されています。 WOTS +は、OTSスキームです。秘密鍵は任意のメッセージに署名するために使用することができながら、それぞれの秘密鍵は、単一のメッセージに署名するために、一度だけ使用しなければなりません。秘密鍵は、2つの異なるメッセージに署名するために使用されている場合は特に、スキームが安全でないとなります。"
    },
    {
      "indent": 3,
      "text": "This section starts with an explanation of parameters. Afterwards, the so-called chaining function, which forms the main building block of the WOTS+ scheme, is explained. A description of the algorithms for key generation, signing, and verification follows. Finally, pseudorandom key generation is discussed.",
      "ja": "このセクションでは、パラメータの説明を開始します。その後、WOTS +スキームの主ビルディングブロックを形成する、いわゆる連鎖関数は、説明されています。鍵生成、署名、および検証のためのアルゴリズムの説明は次の通り。最後に、擬似ランダムキーの生成が議論されています。"
    },
    {
      "indent": 0,
      "text": "3.1.1. WOTS+ Parameters",
      "section_title": true,
      "ja": "3.1.1.  WOTS +パラメータ"
    },
    {
      "indent": 3,
      "text": "WOTS+ uses the parameters n and w; they both take positive integer values. These parameters are summarized as follows:",
      "ja": "WOTS +パラメータnおよびWを使用します。彼らは両方の正の整数値をとります。これらのパラメータは以下のように要約されます。"
    },
    {
      "indent": 6,
      "text": "n: the message length as well as the length of a private key, public key, or signature element in bytes.",
      "ja": "N：メッセージの長さ、ならびに秘密鍵、公開鍵、又はバイト内の署名要素の長さ。"
    },
    {
      "indent": 6,
      "text": "w: the Winternitz parameter; it is a member of the set {4, 16}.",
      "ja": "W：Winternitzパラメータ。それは集合{4,16}のメンバーです。"
    },
    {
      "indent": 3,
      "text": "The parameters are used to compute values len, len_1, and len_2:",
      "ja": "パラメータはlenの値、len_1、およびlen_2を計算するために使用されています。"
    },
    {
      "indent": 6,
      "text": "len: the number of n-byte string elements in a WOTS+ private key, public key, and signature. It is computed as len = len_1 + len_2, with len_1 = ceil(8n / lg(w)) and len_2 = floor(lg(len_1 * (w - 1)) / lg(w)) + 1.",
      "ja": "LEN：WOTS +秘密鍵、公開鍵、および署名のnバイトの文字列要素の数。 + 1  - これは（1））/ LG（W）w LG（len_1の*（）len_1 = CEIL（8N / LG（W））とlen_2 =床と、LEN = len_1 + len_2として計算されます。"
    },
    {
      "indent": 3,
      "text": "The value of n is determined by the cryptographic hash function used for WOTS+. The hash function is chosen to ensure an appropriate level of security. The value of n is the input length that can be processed by the signing algorithm. It is often the length of a message digest. The parameter w can be chosen from the set {4, 16}. A larger value of w results in shorter signatures but slower overall signing operations; it has little effect on security. Choices of w are limited to the values 4 and 16 since these values yield optimal trade-offs and easy implementation.",
      "ja": "Nの値はWOTS +ために使用される暗号ハッシュ関数により決定されます。ハッシュ関数は、セキュリティの適切なレベルを確保するように選択されます。 nの値は、署名アルゴリズムによって処理することができ、入力の長さです。それは多くの場合、メッセージダイジェストの長さです。パラメータwは集合{4,16}から選択することができます。短い署名中のWの結果の値が大きいほどより遅い全体的な署名操作。それは、セキュリティにほとんど影響を与えません。これらの値は、最適なトレードオフと容易な実装をもたらすので、Wの選択は値4および16に限定されます。"
    },
    {
      "indent": 3,
      "text": "WOTS+ parameters are implicitly included in algorithm inputs as needed.",
      "ja": "必要に応じてWOTS +パラメータは、暗黙的アルゴリズムの入力に含まれています。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1. WOTS+ Functions",
      "section_title": true,
      "ja": "3.1.1.1。 WOTS +機能"
    },
    {
      "indent": 3,
      "text": "The WOTS+ algorithm uses a keyed cryptographic hash function F. F accepts and returns byte strings of length n using keys of length n. More detail on specific instantiations can be found in Section 5. Security requirements on F are discussed in Section 9. In addition, WOTS+ uses a pseudorandom function PRF. PRF takes as input an n-byte key and a 32-byte index and generates pseudorandom outputs of length n. More detail on specific instantiations can be found in Section 5. Security requirements on PRF are discussed in Section 9.",
      "ja": "WOTS +アルゴリズムは、鍵付き暗号ハッシュ関数FをFを使用して受け取り、戻って長さnのキーを使用して長さnの文字列をバイト。特定のインスタンスの詳細はWOTS +は、擬似ランダム関数PRFを使用して、F 5.セキュリティ要件を加えて9章で議論されているセクションで見つけることができます。 PRFは、入力としてnバイトの鍵と32バイトのインデックスを取り、長さnの擬似ランダム出力を生成します。特定のインスタンス化の詳細は、PRF 5.セキュリティ要件は、第9章で議論されているセクションで見つけることができます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. WOTS+ Chaining Function",
      "section_title": true,
      "ja": "3.1.2.  WOTS +チェーン機能"
    },
    {
      "indent": 3,
      "text": "The chaining function (Algorithm 2) computes an iteration of F on an n-byte input using outputs of PRF. It takes an OTS hash address as input. This address will have the first six 32-bit words set to encode the address of this chain. In each iteration, PRF is used to generate a key for F and a bitmask that is XORed to the intermediate result before it is processed by F. In the following, ADRS is a 32-byte OTS hash address as specified in Section 2.5 and SEED is an n-byte string. To generate the keys and bitmasks, PRF is called with SEED as key and ADRS as input. The chaining function takes as input an n-byte string X, a start index i, a number of steps s, as well as ADRS and SEED. The chaining function returns as output the value obtained by iterating F for s times on input X, using the outputs of PRF.",
      "ja": "連鎖機能（アルゴリズム2）は、PRFの出力を使用してnバイトの入力にFの反復を計算します。これは、入力として、OTSハッシュアドレスを取得します。このアドレスは、このチェーンのアドレスを符号化するために設定された第1の6本の32ビットワードを有することになります。セクション2.5及びSEEDで指定されるように各反復において、PRFは、F、それは以下においてFで処理される前に中間結果にXORされるビットマスクのためのキーを生成するために使用される、ADRSは32バイトOTSハッシュアドレスでありますnバイトの文字列です。キーとビットマスクを生成するには、PRFを入力として、キーとADRSとしてSEEDと呼ばれています。連鎖関数は、入力としてnバイト列X、開始インデックスi、ステップSの数、ならびにADRSとSEEDを取ります。連鎖関数は、出力としてPRFの出力を用いて、入力X上のS回Fを反復して得られた値を返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 2: chain - Chaining Function",
      "ja": "アルゴリズム2：チェーン - チェーン機能"
    },
    {
      "indent": 5,
      "text": "Input: Input string X, start index i, number of steps s, seed SEED, address ADRS Output: value of F iterated s times on X",
      "ja": "入力：入力文字列X、インデックスi、ステップ数S、シードSEED、アドレスADRS出力を開始：X上のFの値がsの反復回数"
    },
    {
      "indent": 5,
      "text": "if ( s == 0 ) {\n  return X;\n}\nif ( (i + s) > (w - 1) ) {\n  return NULL;\n}\nbyte[n] tmp = chain(X, i, s - 1, SEED, ADRS);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ADRS.setHashAddress(i + s - 1);\nADRS.setKeyAndMask(0);\nKEY = PRF(SEED, ADRS);\nADRS.setKeyAndMask(1);\nBM = PRF(SEED, ADRS);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "tmp = F(KEY, tmp XOR BM);\nreturn tmp;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.3. WOTS+ Private Key",
      "section_title": true,
      "ja": "3.1.3.  WOTS +秘密鍵"
    },
    {
      "indent": 3,
      "text": "The private key in WOTS+, denoted by sk (s for secret), is a length len array of n-byte strings. This private key MUST be only used to sign at most one message. Each n-byte string MUST either be selected randomly from the uniform distribution or be selected using a cryptographically secure pseudorandom procedure. In the latter case, the security of the used procedure MUST at least match that of the WOTS+ parameters used. For a further discussion on pseudorandom key generation, see Section 3.1.7. The following pseudocode (Algorithm 3) describes an algorithm for generating sk.",
      "ja": "SK（秘密のためのS）で表さWOTS +秘密鍵は、nバイトの文字列の長さlenの配列です。この秘密鍵は最大1つのメッセージに署名するために使用されなければなりません。それぞれのnバイトの文字列のいずれか一様分布からランダムに選択されなければならないか、暗号的に安全な擬似ランダム手順を使用して選択します。後者の場合には、使用される手順のセキュリティは、少なくとも使用WOTS +パラメータと一致しなければなりません。擬似ランダムキーの生成に関する更なる議論については、セクション3.1.7を参照してください。次の擬似コード（アルゴリズム3）は、SKを生成するためのアルゴリズムを記載しています。"
    },
    {
      "indent": 3,
      "text": "Algorithm 3: WOTS_genSK - Generating a WOTS+ Private Key",
      "ja": "アルゴリズム3：WOTS_genSK  -  WOTS +秘密鍵の生成"
    },
    {
      "indent": 5,
      "text": "Input: No input Output: WOTS+ private key sk",
      "ja": "入力：なし入力出力：WOTS +プライベート鍵sk"
    },
    {
      "indent": 5,
      "text": "for ( i = 0; i < len; i++ ) {\n  initialize sk[i] with a uniformly random n-byte string;\n}\nreturn sk;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.4. WOTS+ Public Key",
      "section_title": true,
      "ja": "3.1.4.  WOTS +公開鍵"
    },
    {
      "indent": 3,
      "text": "A WOTS+ key pair defines a virtual structure that consists of len hash chains of length w. The len n-byte strings in the private key each define the start node for one hash chain. The public key consists of the end nodes of these hash chains. Therefore, like the private key, the public key is also a length len array of n-byte strings. To compute the hash chain, the chaining function (Algorithm 2) is used. An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm. This address will encode the address of the WOTS+ key pair within a greater structure. Hence, a WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the last three 32-bit words. Please note that the SEED used here is public information also available to a verifier. The following pseudocode (Algorithm 4) describes an algorithm for generating the public key pk, where sk is the private key.",
      "ja": "WOTS +鍵ペアは、長さWのLENハッシュ鎖からなる仮想構造を定義します。それぞれが1つのハッシュ・チェーンの開始ノードを定義する秘密鍵でlenのnバイトの文字列。公開鍵は、これらのハッシュチェーンのエンドノードから構成されています。そのため、秘密鍵のように、公開鍵もnバイトの文字列の長さlenの配列です。ハッシュチェーンを計算するために、連鎖機能（アルゴリズム2）が用いられます。 OTSハッシュアドレスADRSとシードSEEDは、呼び出しアルゴリズムによって提供されなければなりません。このアドレスは、より大きな構造内WOTS +鍵ペアのアドレスをコードします。したがって、WOTS +アルゴリズムは、最後の3つの32ビットワードを除いADRSの任意の部分を操作してはいけません。ここで使用SEEDが検証に公開情報も利用可能であることに注意してください。次の擬似コード（アルゴリズム4）は、SKが秘密鍵である公開鍵PKを生成するためのアルゴリズムを記載しています。"
    },
    {
      "indent": 3,
      "text": "Algorithm 4: WOTS_genPK - Generating a WOTS+ Public Key From a Private Key",
      "ja": "アルゴリズム4：WOTS_genPK  - プライベートキーからWOTS +公開鍵の生成"
    },
    {
      "indent": 5,
      "text": "Input: WOTS+ private key sk, address ADRS, seed SEED Output: WOTS+ public key pk",
      "ja": "入力：WOTS +プライベート鍵sk、アドレスADRS、シードSEED出力：WOTS +公開鍵pk"
    },
    {
      "indent": 5,
      "text": "for ( i = 0; i < len; i++ ) {\n  ADRS.setChainAddress(i);\n  pk[i] = chain(sk[i], 0, w - 1, SEED, ADRS);\n}\nreturn pk;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.5. WOTS+ Signature Generation",
      "section_title": true,
      "ja": "3.1.5.  WOTS +署名生成"
    },
    {
      "indent": 3,
      "text": "A WOTS+ signature is a length len array of n-byte strings. The WOTS+ signature is generated by mapping a message to len integers between 0 and w - 1. To this end, the message is transformed into len_1 base w numbers using the base_w function defined in Section 2.6. Next, a checksum is computed and appended to the transformed message as len_2 base w numbers using the base_w function. Note that the checksum may reach a maximum integer value of len_1 * (w - 1) * 2^8 and therefore depends on the parameters n and w. For the parameter sets given in Section 5, a 32-bit unsigned integer is sufficient to hold the checksum. If other parameter settings are used, the size of the variable holding the integer value of the checksum MUST be sufficiently large. Each of the base w integers is used to select a node from a different hash chain. The signature is formed by concatenating the selected nodes. An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm. This address will encode the address of the WOTS+ key pair within a greater structure. Hence, a WOTS+ algorithm MUST NOT manipulate any parts of",
      "ja": "WOTS +署名は、nバイトの文字列の長さlen配列です。 WOTS +署名が0とWとの間の整数でlenするメッセージマッピングすることによって生成される - この目的のために1を、メッセージはセクション2.6で定義されたbase_w関数を用いて数値W len_1塩基に変換されます。次に、チェックサムが計算され、base_w関数を用いて数値W len_2塩基として変換されたメッセージに付加されています。チェックサムがlen_1の最大整数値に到達することができることに留意されたい*（W  -  1）* 2 ^ 8従ってパラメータNおよびWに依存します。第5節で与えられたパラメータセットのために、32ビットの符号なし整数は、チェックサムを保持するのに十分です。他のパラメータ設定が使用される場合、チェックサムの整数値を保持する変数のサイズが十分に大きくなければなりません。ベースW整数の各々は、異なるハッシュチェーンからノードを選択するために使用されます。署名は、選択されたノードを連結することによって形成されています。 OTSハッシュアドレスADRSとシードSEEDは、呼び出しアルゴリズムによって提供されなければなりません。このアドレスは、より大きな構造内WOTS +鍵ペアのアドレスをコードします。したがって、WOTS +アルゴリズムは、任意の部分を操作してはなりません"
    },
    {
      "indent": 3,
      "text": "ADRS except for the last three 32-bit words. Please note that the SEED used here is public information also available to a verifier. The pseudocode for signature generation is shown below (Algorithm 5), where M is the message and sig is the resulting signature.",
      "ja": "最後の3つの32ビットワードを除き、ADRS。ここで使用SEEDが検証に公開情報も利用可能であることに注意してください。署名生成のための擬似コードは、Mはメッセージであり、sigが得られた署名である（アルゴリズム5）、下に示されています。"
    },
    {
      "indent": 3,
      "text": "Algorithm 5: WOTS_sign - Generating a signature from a private key and a message",
      "ja": "アルゴリズム5：WOTS_sign  - 秘密鍵とメッセージから署名を生成します"
    },
    {
      "indent": 5,
      "text": "Input: Message M, WOTS+ private key sk, address ADRS, seed SEED Output: WOTS+ signature sig",
      "ja": "入力：メッセージM、WOTS +プライベート鍵sk、アドレスADRS、シードSEED出力：WOTS +署名SIG"
    },
    {
      "indent": 5,
      "text": "csum = 0;",
      "ja": "CSUM = 0;"
    },
    {
      "indent": 5,
      "text": "// Convert message to base w msg = base_w(M, w, len_1);",
      "ja": "//（len_1、W、M）MSG = base_w wをベースにメッセージを変換します。"
    },
    {
      "indent": 5,
      "text": "// Compute checksum for ( i = 0; i < len_1; i++ ) { csum = csum + w - 1 - msg[i]; }",
      "ja": "用//計算チェックサム（I = 0; I <len_1; iは++）{CSUM = CSUM + W  -  1  -  MSG [I]。 }"
    },
    {
      "indent": 5,
      "text": "// Convert csum to base w\ncsum = csum << ( 8 - ( ( len_2 * lg(w) ) % 8 ));\nlen_2_bytes = ceil( ( len_2 * lg(w) ) / 8 );\nmsg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);\nfor ( i = 0; i < len; i++ ) {\n     ADRS.setChainAddress(i);\n     sig[i] = chain(sk[i], 0, msg[i], SEED, ADRS);\n}\nreturn sig;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The data format for a signature is given below.",
      "ja": "署名のためのデータフォーマットを以下に示します。"
    },
    {
      "indent": 13,
      "text": "+---------------------------------+\n|                                 |\n|           sig_ots[0]            |    n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n~              ....               ~\n|                                 |\n+---------------------------------+\n|                                 |\n|          sig_ots[len - 1]       |    n bytes\n|                                 |\n+---------------------------------+",
      "raw": true
    },
    {
      "indent": 30,
      "text": "WOTS+ Signature",
      "ja": "WOTS +署名"
    },
    {
      "indent": 0,
      "text": "3.1.6. WOTS+ Signature Verification",
      "section_title": true,
      "ja": "3.1.6.  WOTS +署名検証"
    },
    {
      "indent": 3,
      "text": "In order to verify a signature sig on a message M, the verifier computes a WOTS+ public key value from the signature. This can be done by \"completing\" the chain computations starting from the signature values, using the base w values of the message hash and its checksum. This step, called WOTS_pkFromSig, is described below in Algorithm 6. The result of WOTS_pkFromSig is then compared to the given public key. If the values are equal, the signature is accepted. Otherwise, the signature MUST be rejected. An OTS hash address ADRS and a seed SEED have to be provided by the calling algorithm. This address will encode the address of the WOTS+ key pair within a greater structure. Hence, a WOTS+ algorithm MUST NOT manipulate any parts of ADRS except for the last three 32-bit words. Please note that the SEED used here is public information also available to a verifier.",
      "ja": "メッセージMに署名SIGを検証するために、検証者は署名からWOTS +公開鍵値を計算します。これは、メッセージのハッシュとそのチェックサムの値wの塩基を用いて、署名値から始まるチェーン計算を「完了」することによって行うことができます。 WOTS_pkFromSigと呼ばれるこのステップは、WOTS_pkFromSigの結果は、次に、指定された公開鍵と比較されるアルゴリズム6に説明されています。値が等しい場合、署名が受け入れられます。そうでない場合、署名は拒絶しなければなりません。 OTSハッシュアドレスADRSとシードSEEDは、呼び出しアルゴリズムによって提供されなければなりません。このアドレスは、より大きな構造内WOTS +鍵ペアのアドレスをコードします。したがって、WOTS +アルゴリズムは、最後の3つの32ビットワードを除いADRSの任意の部分を操作してはいけません。ここで使用SEEDが検証に公開情報も利用可能であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Algorithm 6: WOTS_pkFromSig - Computing a WOTS+ public key from a message and its signature",
      "ja": "アルゴリズム6：WOTS_pkFromSig  - メッセージとその署名からWOTS +公開鍵を計算します"
    },
    {
      "indent": 5,
      "text": "Input: Message M, WOTS+ signature sig, address ADRS, seed SEED Output: 'Temporary' WOTS+ public key tmp_pk",
      "ja": "入力：メッセージM、WOTS +署名SIG、アドレスADRS、シードSEED出力： '一時的な' WOTS +公開鍵tmp_pk"
    },
    {
      "indent": 5,
      "text": "csum = 0;",
      "ja": "CSUM = 0;"
    },
    {
      "indent": 5,
      "text": "// Convert message to base w msg = base_w(M, w, len_1);",
      "ja": "//（len_1、W、M）MSG = base_w wをベースにメッセージを変換します。"
    },
    {
      "indent": 5,
      "text": "// Compute checksum for ( i = 0; i < len_1; i++ ) { csum = csum + w - 1 - msg[i]; }",
      "ja": "用//計算チェックサム（I = 0; I <len_1; iは++）{CSUM = CSUM + W  -  1  -  MSG [I]。 }"
    },
    {
      "indent": 5,
      "text": "// Convert csum to base w\ncsum = csum << ( 8 - ( ( len_2 * lg(w) ) % 8 ));\nlen_2_bytes = ceil( ( len_2 * lg(w) ) / 8 );\nmsg = msg || base_w(toByte(csum, len_2_bytes), w, len_2);\nfor ( i = 0; i < len; i++ ) {\n     ADRS.setChainAddress(i);\n     tmp_pk[i] = chain(sig[i], msg[i], w - 1 - msg[i], SEED, ADRS);\n}\nreturn tmp_pk;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: XMSS uses WOTS_pkFromSig to compute a public key value and delays the comparison to a later point.",
      "ja": "注意：XMSSは、公開鍵の値を計算するためにWOTS_pkFromSigを使用し、後でポイントとの比較を遅らせます。"
    },
    {
      "indent": 0,
      "text": "3.1.7. Pseudorandom Key Generation",
      "section_title": true,
      "ja": "3.1.7. 擬似ランダムキーの生成"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use a cryptographically secure pseudorandom method to generate the private key from a single n-byte value. For example, the method suggested in [BDH11] and explained below MAY be used. Other methods MAY be used. The choice of a pseudorandom method does not affect interoperability, but the cryptographic strength MUST match that of the used WOTS+ parameters.",
      "ja": "実装は、単一のnバイトの値から秘密鍵を生成するために、暗号的に安全な擬似ランダム方式を使用するかもしれません。例えば、本方法は、[BDH11]で提案して用いることができる以下に説明します。他の方法を用いてもよいです。擬似ランダム方法の選択は、相互運用性に影響を与えませんが、暗号の強度が使用WOTS +パラメータのものと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The advantage of generating the private key elements from a random n-byte string is that only this n-byte string needs to be stored instead of the full private key. The key can be regenerated when needed. The suggested method from [BDH11] can be described using PRF. During key generation, a uniformly random n-byte string S is sampled from a secure source of randomness. This string S is stored as private key. The private key elements are computed as sk[i] = PRF(S, toByte(i, 32)) whenever needed. Please note that this seed S MUST be different from the seed SEED used to randomize the hash function calls. Also, this seed S MUST be kept secret. The seed S MUST NOT be a low entropy, human-memorable value since private key elements are derived from S deterministically and their confidentiality is security-critical.",
      "ja": "ランダムnバイトの文字列から秘密鍵要素を生成することの利点は、これだけのnバイトの文字列ではなく、完全な秘密鍵を保存する必要があるということです。必要なときにキーを再生することができます。 【BDH11]から提案された方法は、PRFを用いて記述することができます。鍵生成中に、一様にランダムなnバイトストリングSは、乱数の安全なソースからサンプリングされます。この文字列Sは、秘密鍵として格納されます。必要なときはいつでも、秘密鍵の要素は、SK [I] = PRF（S、toByte（I、32））として計算されます。このシードSは、ハッシュ関数の呼び出しをランダム化するために使用するシードSEEDは異なるものにする必要がありますのでご注意ください。また、このシードSは秘密にしなければなりません。秘密鍵の要素が決定的にSから派生しているので、シードSは低エントロピー、人間の記憶に残る値にすることはできませんし、その機密性は、セキュリティが重要です。"
    },
    {
      "indent": 0,
      "text": "4. Schemes",
      "section_title": true,
      "ja": "4.スキーム"
    },
    {
      "indent": 3,
      "text": "In this section, the eXtended Merkle Signature Scheme (XMSS) is described using WOTS+. XMSS comes in two flavors: a single-tree variant (XMSS) and a multi-tree variant (XMSS^MT). Both allow combining a large number of WOTS+ key pairs under a single small public key. The main ingredient added is a binary hash tree construction. XMSS uses a single hash tree while XMSS^MT uses a tree of XMSS key pairs.",
      "ja": "このセクションでは、拡張マークル署名方式（XMSS）はWOTS +を用いて説明します。単一ツリーバリアント（XMSS）およびマルチツリーバリアント（XMSS ^ MT）：XMSSは2種類があります。両方が単一の小さな公開鍵の下WOTS +鍵ペアの多数を組み合わせることを可能にします。加え主成分は、バイナリハッシュツリー構造です。 XMSS ^ MTがXMSS鍵ペアの木を使用しながらXMSSは、単一のハッシュ木を使用しています。"
    },
    {
      "indent": 0,
      "text": "4.1. XMSS: eXtended Merkle Signature Scheme",
      "section_title": true,
      "ja": "4.1.  XMSS：マークル署名方式を拡張されました"
    },
    {
      "indent": 3,
      "text": "XMSS is a method for signing a potentially large but fixed number of messages. It is based on the Merkle signature scheme. XMSS uses four cryptographic components: WOTS+ as OTS method, two additional cryptographic hash functions H and H_msg, and a pseudorandom function PRF. One of the main advantages of XMSS with WOTS+ is that it does not rely on the collision resistance of the used hash functions but on weaker properties. Each XMSS public/private key pair is associated with a perfect binary tree, every node of which contains an n-byte value. Each tree leaf contains a special tree hash of a WOTS+ public key value. Each non-leaf tree node is computed by first concatenating the values of its child nodes, computing the XOR with a bitmask, and applying the keyed hash function H to the result. The bitmasks and the keys for the hash function H are generated from a (public) seed that is part of the public key using the pseudorandom function PRF. The value corresponding to the root of the XMSS tree forms the XMSS public key together with the seed.",
      "ja": "XMSSは、メッセージの潜在的に大きいが、一定数に署名するための方法です。これは、マークル署名方式に基づいています。 OTS方法としてWOTS +、二つの追加の暗号ハッシュ関数HとH_msg、及び擬似乱数関数PRF：XMSSは、4つの暗号化コンポーネントを使用します。 WOTS +とXMSSの主な利点の1つは、それが使用されるハッシュ関数の衝突困難性ではなく、弱い性質に依存していないということです。各XMSS公開鍵/秘密鍵のペアは、完璧なバイナリツリー、nバイトの値が含まれているのすべてのノードに関連付けられています。各ツリーの葉はWOTS +公開鍵値の特別な木のハッシュが含まれています。各非リーフツリーノードは最初、その子ノードの値を連結ビットマスクとXORを計算し、その結果に鍵付きハッシュ関数Hを適用することによって計算されます。ビットマスクとハッシュ関数H用のキーは、擬似乱数関数PRFを用いて、公開鍵の一部である（パブリック）種から生成されます。 XMSSツリーのルートに対応する値は、シードと一緒XMSS公開鍵を形成します。"
    },
    {
      "indent": 3,
      "text": "To generate a key pair that can be used to sign 2^h messages, a tree of height h is used. XMSS is a stateful signature scheme, meaning that the private key changes with every signature generation. To prevent one-time private keys from being used twice, the WOTS+ key pairs are numbered from 0 to (2^h) - 1 according to the related leaf, starting from index 0 for the leftmost leaf. The private key contains an index that is updated with every signature generation, such that it contains the index of the next unused WOTS+ key pair.",
      "ja": "2 ^ Hメッセージに署名するために使用できる鍵のペアを生成するために、高さhの木が使用されます。 XMSSは、すべての署名生成とプライベートキーの変更ということを意味し、ステートフル署名方式です。左端のリーフのインデックス0から開始し、関連するリーフに係る1  -  2回使用されるのワンタイム秘密鍵を防止するために、WOTS +鍵ペアは（2 ^ H）、0から番号が付けられています。秘密鍵は、それが次の未使用WOTS +鍵ペアのインデックスを含むように、すべての署名生成で更新されたインデックスが含まれています。"
    },
    {
      "indent": 3,
      "text": "A signature consists of the index of the used WOTS+ key pair, the WOTS+ signature on the message, and the so-called authentication path. The latter is a vector of tree nodes that allow a verifier to compute a value for the root of the tree starting from a WOTS+ signature. A verifier computes the root value and compares it to the respective value in the XMSS public key. If they match, the signature is declared valid. The XMSS private key consists of all WOTS+ private keys and the current index. To reduce storage, a pseudorandom key generation procedure, as described in [BDH11], MAY be used. The security of the used method MUST at least match the security of the XMSS instance.",
      "ja": "署名が使用WOTS +鍵ペア、メッセージにWOTS +署名、いわゆる認証パスのインデックスで構成されています。後者は、検証者がWOTS +署名からツリー開始のルートのための値を計算することを可能にするツリーノードのベクトルです。検証者は、ルート値を計算し、XMSS公開鍵の各値と比較します。それらが一致した場合、署名が有効と宣言されています。 XMSS秘密鍵は、すべてのWOTS +秘密鍵と現在のインデックスで構成されています。 【BDH11]に記載されているように、ストレージ、擬似ランダム鍵生成手順を低減するために、使用することができます。使用される方法のセキュリティは、少なくともXMSSインスタンスのセキュリティと一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.1. XMSS Parameters",
      "section_title": true,
      "ja": "4.1.1.  XMSSパラメータ"
    },
    {
      "indent": 3,
      "text": "XMSS has the following parameters:",
      "ja": "XMSSには、以下のパラメータがあります。"
    },
    {
      "indent": 6,
      "text": "h: the height (number of levels - 1) of the tree",
      "ja": "H：高さ（レベル数 -  1）木の"
    },
    {
      "indent": 6,
      "text": "n: the length in bytes of the message digest as well as each node",
      "ja": "N：メッセージのバイト単位の長さは、各ノードならびにダイジェスト"
    },
    {
      "indent": 6,
      "text": "w: the Winternitz parameter as defined for WOTS+ in Section 3.1",
      "ja": "W：3.1節でWOTS +用に定義されているようWinternitzパラメータ"
    },
    {
      "indent": 3,
      "text": "There are 2^h leaves in the tree.",
      "ja": "ツリー内の2 ^ Hの葉があります。"
    },
    {
      "indent": 3,
      "text": "For XMSS and XMSS^MT, private and public keys are denoted by SK (S for secret) and PK, respectively. For WOTS+, private and public keys are denoted by sk (s for secret) and pk, respectively. XMSS and XMSS^MT signatures are denoted by Sig. WOTS+ signatures are denoted by sig.",
      "ja": "XMSSとXMSS ^ MTの場合は、秘密鍵と公開鍵は、それぞれ、SK（秘密のためのS）とPKで示されています。 WOTS +の場合は、秘密鍵と公開鍵は、それぞれ、SK（秘密のためのS）とPKで示されています。 XMSSとXMSS ^ MT署名がシグによって示されています。 WOTS +署名はSIGによって示されています。"
    },
    {
      "indent": 3,
      "text": "XMSS and XMSS^MT parameters are implicitly included in algorithm inputs as needed.",
      "ja": "必要に応じてXMSSとXMSS ^ MTのパラメータは、暗黙的アルゴリズムの入力に含まれています。"
    },
    {
      "indent": 0,
      "text": "4.1.2. XMSS Hash Functions",
      "section_title": true,
      "ja": "4.1.2.  XMSSハッシュ関数"
    },
    {
      "indent": 3,
      "text": "Besides the cryptographic hash function F and the pseudorandom function PRF required by WOTS+, XMSS uses two more functions:",
      "ja": "暗号ハッシュ関数FとWOTS +によって必要とされる擬似乱数関数PRFに加え、XMSSは、2つの関数を使用します。"
    },
    {
      "indent": 3,
      "text": "o A cryptographic hash function H. H accepts n-byte keys and byte strings of length 2n and returns an n-byte string.",
      "ja": "O暗号ハッシュ関数H Hは、nバイトの鍵長さ2nのバイト文字列を受け取り、nバイトの文字列を返します。"
    },
    {
      "indent": 3,
      "text": "o A cryptographic hash function H_msg. H_msg accepts 3n-byte keys and byte strings of arbitrary length and returns an n-byte string.",
      "ja": "暗号ハッシュ関数H_msg O。 H_msgは3Nバイトのキーと任意の長さのバイト列を受け取り、nバイトの文字列を返します。"
    },
    {
      "indent": 3,
      "text": "More detail on specific instantiations can be found in Section 5. Security requirements on H and H_msg are discussed in Section 9.",
      "ja": "特定のインスタンスの詳細はHとH_msg 5.セキュリティ要件は、第9章で議論されているセクションで見つけることができます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. XMSS Private Key",
      "section_title": true,
      "ja": "4.1.3.  XMSS秘密鍵"
    },
    {
      "indent": 3,
      "text": "An XMSS private key SK contains 2^h WOTS+ private keys, the leaf index idx of the next WOTS+ private key that has not yet been used, SK_PRF (an n-byte key to generate pseudorandom values for randomized message hashing), the n-byte value root (which is the root node of the tree and SEED), and the n-byte public seed used to pseudorandomly generate bitmasks and hash function keys. Although root and SEED formally would be considered only part of the public key, they are needed (e.g., for signature generation) and hence are also required for functions that do not take the public key as input.",
      "ja": "XMSS秘密鍵SKは、2 ^時間WOTS +秘密鍵、まだ使用されていない次WOTS +秘密鍵のリーフインデックスIDX、SK_PRF（ハッシング無作為メッセージの擬似ランダム値を生成するために、nバイトのキー）、N-を含有しますバイト値ルート（ツリーとSEEDのルートノードである）、及び擬似ランダムビットマスクとハッシュファンクションキーを生成するために使用されるnバイト公共種子。根および種子が正式公開鍵の一部のみと考えられるであろうが、それらは必要とされている（例えば、署名生成のため）、したがって、入力として公開鍵を取らない機能のために必要とされます。"
    },
    {
      "indent": 3,
      "text": "The leaf index idx is initialized to zero when the XMSS private key is created. The key SK_PRF MUST be sampled from a secure source of randomness that follows the uniform distribution. The WOTS+ private keys MUST be generated as described in Section 3.1, or, to reduce the private key size, a cryptographic pseudorandom method MUST be used as discussed in Section 4.1.11. SEED is generated as a uniformly random n-byte string. Although SEED is public, it is critical for security that it is generated using a good entropy source. The root node is generated as described below in the section on key generation (Section 4.1.7). That section also contains an example algorithm for combined private and public key generation.",
      "ja": "XMSS秘密鍵が作成されたときに、リーフインデックスIDXをゼロに初期化されます。キーSK_PRFは一様分布に従う乱数の安全なソースからサンプリングしなければなりません。 WOTS +秘密鍵は、セクション4.1.11で説明したように暗号擬似ランダム方法を使用する必要があり、3.1節で説明したように生成されなければならない、または、秘密鍵のサイズを低減します。 SEEDは一様にランダムなnバイトの文字列として生成されます。 SEEDは公共のですが、それは良いエントロピーソースを使用して生成されたセキュリティのために重要です。鍵生成（セクション4.1.7）の項で以下に説明するように、ルートノードが生成されます。その節はまた、組み合わせた秘密鍵と公開鍵の生成のためのアルゴリズム例が含まれています。"
    },
    {
      "indent": 3,
      "text": "For the following algorithm descriptions, the existence of a method getWOTS_SK(SK, i) is assumed. This method takes as input an XMSS private key SK and an integer i and outputs the i^th WOTS+ private key of SK.",
      "ja": "以下のアルゴリズムの説明については、方法getWOTS_SK（SK、I）の存在が想定されます。この方法は、私は、入力としてXMSS秘密鍵SKと整数を受け取り、SKのI ^ WOTS番目の+秘密鍵を出力します。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Randomized Tree Hashing",
      "section_title": true,
      "ja": "4.1.4. ランダム化ツリーのハッシュ"
    },
    {
      "indent": 3,
      "text": "To improve readability, we introduce a function RAND_HASH(LEFT, RIGHT, SEED, ADRS) (Algorithm 7) that does the randomized hashing in the tree. It takes as input two n-byte values LEFT and RIGHT that represent the left and the right halves of the hash function input, the seed SEED used as key for PRF, and the address ADRS of this hash function call. RAND_HASH first uses PRF with SEED and ADRS to generate a key KEY and n-byte bitmasks BM_0, BM_1. Then, it returns the randomized hash H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1)).",
      "ja": "読みやすさを向上させるために、我々は、ツリー内のランダム化されたハッシュを行う関数RAND_HASH（LEFT、RIGHT、SEED、ADRS）（アルゴリズム7）を導入します。それは、入力として、左及びハッシュ関数入力の右半分、PRFのためのキーとして使用されるシードSEED、このハッシュ関数呼び出しのアドレスADRSを表す2つのnバイト左値とRIGHTをとります。 RAND_HASH最初BM_0、BM_1ビットマスクキーKEYとnバイトを生成するSEEDとADRSとPRFを使用します。そして、ランダム化ハッシュH（KEY、（LEFT XOR BM_0）||（RIGHT XOR BM_1））を返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 7: RAND_HASH",
      "ja": "アルゴリズム7：RAND_HASH"
    },
    {
      "indent": 5,
      "text": "Input: n-byte value LEFT, n-byte value RIGHT, seed SEED, address ADRS Output: n-byte randomized hash",
      "ja": "入力：nバイトの値LEFT、nバイトの値RIGHT、シードSEED、アドレスADRS出力：nバイトのランダム化ハッシュ"
    },
    {
      "indent": 5,
      "text": "ADRS.setKeyAndMask(0);\nKEY = PRF(SEED, ADRS);\nADRS.setKeyAndMask(1);\nBM_0 = PRF(SEED, ADRS);\nADRS.setKeyAndMask(2);\nBM_1 = PRF(SEED, ADRS);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "return H(KEY, (LEFT XOR BM_0) || (RIGHT XOR BM_1));",
      "ja": "H（KEY、（LEFT XOR BM_0）||（RIGHT XOR BM_1））を返します。"
    },
    {
      "indent": 0,
      "text": "4.1.5. L-Trees",
      "section_title": true,
      "ja": "4.1.5.  L-木"
    },
    {
      "indent": 3,
      "text": "To compute the leaves of the binary hash tree, a so-called L-tree is used. An L-tree is an unbalanced binary hash tree, distinct but similar to the main XMSS binary hash tree. The algorithm ltree (Algorithm 8) takes as input a WOTS+ public key pk and compresses it to a single n-byte value pk[0]. It also takes as input an L-tree address ADRS that encodes the address of the L-tree and the seed SEED.",
      "ja": "バイナリハッシュツリーの葉を計算するには、いわゆるL-ツリーが使用されています。 Lツリーは、メインXMSSバイナリハッシュツリーに異なるが同様の不均衡なバイナリハッシュ木です。アルゴリズムltreeは（アルゴリズム8）は、[0] WOTS +公開鍵pkを入力として受け取り、単一のnバイト値PKにそれを圧縮します。それはまた、入力としてLツリーシードSEEDのアドレスをコードLツリーアドレスADRSをとります。"
    },
    {
      "indent": 3,
      "text": "Algorithm 8: ltree",
      "ja": "アルゴリズム8：ltreeは"
    },
    {
      "indent": 5,
      "text": "Input: WOTS+ public key pk, address ADRS, seed SEED Output: n-byte compressed public key value pk[0]",
      "ja": "入力：WOTS +公開鍵pk、アドレスADRS、シードSEED出力：nバイト圧縮された公開鍵値PK [0]"
    },
    {
      "indent": 5,
      "text": "unsigned int len' = len;\nADRS.setTreeHeight(0);\nwhile ( len' > 1 ) {\n  for ( i = 0; i < floor(len' / 2); i++ ) {\n    ADRS.setTreeIndex(i);\n    pk[i] = RAND_HASH(pk[2i], pk[2i + 1], SEED, ADRS);\n  }\n  if ( len' % 2 == 1 ) {\n    pk[floor(len' / 2)] = pk[len' - 1];\n  }\n  len' = ceil(len' / 2);\n  ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n}\nreturn pk[0];",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.6. TreeHash",
      "section_title": true,
      "ja": "4.1.6.  TreeHash"
    },
    {
      "indent": 3,
      "text": "For the computation of the internal n-byte nodes of a Merkle tree, the subroutine treeHash (Algorithm 9) accepts an XMSS private key SK (including seed SEED), an unsigned integer s (the start index), an unsigned integer t (the target node height), and an address ADRS that encodes the address of the containing tree. For the height of a node within a tree, counting starts with the leaves at height zero. The treeHash algorithm returns the root node of a tree of height t with the leftmost leaf being the hash of the WOTS+ pk with index s. It is REQUIRED that s % 2^t = 0, i.e., that the leaf at index s is a leftmost leaf of a sub-tree of height t. Otherwise, the hash-addressing scheme fails. The treeHash algorithm described here uses a stack holding up to (t - 1) nodes, with the usual stack functions push() and pop(). We furthermore assume that the height of a node (an unsigned integer) is stored alongside a node's value (an n-byte string) on the stack.",
      "ja": "マークル木の内部のnバイトのノードの計算のために、サブルーチンtreeHash（アルゴリズム9）は、符号なし整数S（開始インデックス）、符号なし整数t（（シードSEEDを含む）XMSS秘密鍵SKを受け付けターゲットノードの高さ）、および含むツリーのアドレスをコードアドレスADRS。ツリー内のノードの高さのために、計数は、高さゼロで葉から始まります。 treeHashアルゴリズムは、左端のリーフインデックスsのWOTS + PKのハッシュされた状態で高さtのツリーのルートノードを返します。それが必要であることよ％2 ^ T = 0、すなわち、インデックスsのリーフ高さtのサブツリーの左端のリーフであること。それ以外の場合は、ハッシュ・アドレス指定方式は失敗します。 treeHashアルゴリズムは、ここで説明する（T  -  1）まで保持スタック使用し、通常のスタック機能を有するノードは、（プッシュ）及びポップ（）。我々はさらに、ノード（符号なし整数）の高さがスタック上のノードの値（nバイト列）と一緒に格納されていると仮定する。"
    },
    {
      "indent": 3,
      "text": "Algorithm 9: treeHash",
      "ja": "アルゴリズム9：treeHash"
    },
    {
      "indent": 5,
      "text": "Input: XMSS private key SK, start index s, target node height t, address ADRS Output: n-byte root node - top node on Stack",
      "ja": "入力：XMSS秘密鍵SK、ノードの高さt、アドレスADRS出力目標、指標Sを起動します。nバイトのルートノード - スタックの一番上のノードを"
    },
    {
      "indent": 5,
      "text": "if( s % (1 << t) != 0 ) return -1;\nfor ( i = 0; i < 2^t; i++ ) {\n  SEED = getSEED(SK);\n  ADRS.setType(0);   // Type = OTS hash address\n  ADRS.setOTSAddress(s + i);\n  pk = WOTS_genPK (getWOTS_SK(SK, s + i), SEED, ADRS);\n  ADRS.setType(1);   // Type = L-tree address\n  ADRS.setLTreeAddress(s + i);\n  node = ltree(pk, SEED, ADRS);\n  ADRS.setType(2);   // Type = hash tree address\n  ADRS.setTreeHeight(0);\n  ADRS.setTreeIndex(i + s);\n  while ( Top node on Stack has same height t' as node ) {\n     ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);\n     node = RAND_HASH(Stack.pop(), node, SEED, ADRS);\n     ADRS.setTreeHeight(ADRS.getTreeHeight() + 1);\n  }\n  Stack.push(node);\n}\nreturn Stack.pop();",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.7. XMSS Key Generation",
      "section_title": true,
      "ja": "4.1.7.  XMSSキー生成"
    },
    {
      "indent": 3,
      "text": "The XMSS key pair is computed as described in XMSS_keyGen (Algorithm 10). The XMSS public key PK consists of the root of the binary hash tree and the seed SEED, both also stored in SK. The root is computed using treeHash. For XMSS, there is only a single main tree. Hence, the used address is set to the all-zero string in the beginning. Note that we do not define any specific format or handling for the XMSS private key SK by introducing this algorithm. It relates to requirements described earlier and simply shows a basic but very inefficient example to initialize a private key.",
      "ja": "XMSS_keyGen（アルゴリズム10）に記載のようにXMSS鍵ペアが計算されます。 XMSS公開鍵PKは、SKに格納された両方のも、バイナリハッシュツリーのルートとシードSEEDから成ります。ルートはtreeHashを使用して計算されます。 XMSSのために、単一のメインツリーがあります。したがって、使用されるアドレスは、初めにすべてゼロの文字列に設定されています。私たちは、このアルゴリズムを導入することにより、XMSS秘密鍵SKのための任意の特定の形式や取り扱いを定義しないことに注意してください。これは、先に説明した要件に関し、単に秘密鍵を初期化するための基本的なが、非常に非効率的な一例を示しています。"
    },
    {
      "indent": 3,
      "text": "Algorithm 10: XMSS_keyGen - Generate an XMSS key pair",
      "ja": "アルゴリズム10：XMSS_keyGen  -  XMSS鍵ペアを生成"
    },
    {
      "indent": 5,
      "text": "Input: No input Output: XMSS private key SK, XMSS public key PK",
      "ja": "入力：なし入力出力：XMSS秘密鍵SK、XMSS公開鍵PK"
    },
    {
      "indent": 5,
      "text": "// Example initialization for SK-specific contents\nidx = 0;\nfor ( i = 0; i < 2^h; i++ ) {\n  wots_sk[i] = WOTS_genSK();\n}\ninitialize SK_PRF with a uniformly random n-byte string;\nsetSK_PRF(SK, SK_PRF);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "// Initialization for common contents\ninitialize SEED with a uniformly random n-byte string;\nsetSEED(SK, SEED);\nsetWOTS_SK(SK, wots_sk));\nADRS = toByte(0, 32);\nroot = treeHash(SK, 0, h, ADRS);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "SK = idx || wots_sk || SK_PRF || root || SEED;\nPK = OID || root || SEED;\nreturn (SK || PK);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above is just an example algorithm. It is strongly RECOMMENDED to use pseudorandom key generation to reduce the private key size. Public and private key generation MAY be interleaved to save space. Particularly, when a pseudorandom method is used to generate the private key, generation MAY be done when the respective WOTS+ key pair is needed by treeHash.",
      "ja": "上記は一例アルゴリズムです。強く、秘密鍵のサイズを縮小するために、疑似ランダムキー生成を使用することをお勧めします。公開鍵と秘密鍵の生成には、スペースを節約するためにインターリーブされるかもしれません。擬似ランダム方式は、秘密鍵を生成するために使用されている場合、それぞれのWOTS +鍵ペアがtreeHashによって必要とされるとき、特に、世代を行うことができます。"
    },
    {
      "indent": 3,
      "text": "The format of an XMSS public key is given below.",
      "ja": "XMSS公開鍵のフォーマットは以下のとおりです。"
    },
    {
      "indent": 12,
      "text": "+---------------------------------+\n|          algorithm OID          |\n+---------------------------------+\n|                                 |\n|            root node            |     n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|              SEED               |     n bytes\n|                                 |\n+---------------------------------+",
      "raw": true
    },
    {
      "indent": 30,
      "text": "XMSS Public Key",
      "ja": "XMSS公開鍵"
    },
    {
      "indent": 0,
      "text": "4.1.8. XMSS Signature",
      "section_title": true,
      "ja": "4.1.8.  XMSS署名"
    },
    {
      "indent": 3,
      "text": "An XMSS signature is a (4 + n + (len + h) * n)-byte string consisting of:",
      "ja": "XMSS署名は（4 + N +（LEN + H）* N）バイト列からなります："
    },
    {
      "indent": 3,
      "text": "o the index idx_sig of the used WOTS+ key pair (4 bytes),",
      "ja": "使用WOTS +鍵ペア（4バイト）のインデックスidx_sig O、"
    },
    {
      "indent": 3,
      "text": "o a byte string r used for randomized message hashing (n bytes),",
      "ja": "ランダム化されたハッシュメッセージ（Nバイト）のために使用されるバイト文字列R O、"
    },
    {
      "indent": 3,
      "text": "o a WOTS+ signature sig_ots (len * n bytes), and",
      "ja": "WOTS +署名sig_ots（LEN * nバイト）O、及び"
    },
    {
      "indent": 3,
      "text": "o the so-called authentication path 'auth' for the leaf associated with the used WOTS+ key pair (h * n bytes).",
      "ja": "使用WOTS +鍵ペア（時間* Nバイト）に関連付けられたリーフのためのいわゆる認証パス「AUTH」O。"
    },
    {
      "indent": 3,
      "text": "The authentication path is an array of h n-byte strings. It contains the siblings of the nodes on the path from the used leaf to the root. It does not contain the nodes on the path itself. A verifier needs these nodes to compute a root node for the tree from the WOTS+ public key. A node Node is addressed by its position in the tree. Node(x, y) denotes the y^th node on level x with y = 0 being the leftmost node on a level. The leaves are on level 0; the root is on level h. An authentication path contains exactly one node on every layer 0 <= x <= (h - 1). For the i^th WOTS+ key pair, counting from zero, the j^th authentication path node is:",
      "ja": "認証経路は、H nバイトの文字列の配列です。これは、ルートするために使用葉からのパス上のノードの兄弟が含まれています。これは、パス自体上のノードが含まれていません。検証者はWOTS +公開鍵からツリーのルートノードを計算するためにこれらのノードを必要とします。ノードノードは、ツリー内のその位置によって対処されます。ノード（x、y）は、Y = 0のレベルの左端のノードであるとレベルxでy ^番目のノードを表します。葉はレベル0です。ルートは、レベルHです。認証パスは、すべてのレイヤ0 <= xで<=（ -  1時間）に正確に一つのノードを含みます。 I ^第WOTS +鍵ペアのために、ゼロからカウント、J ^番目の認証パスのノードです。"
    },
    {
      "indent": 6,
      "text": "Node(j, floor(i / (2^j)) XOR 1)",
      "ja": "ノード（J、床（I /（2 ^ J））XOR 1）"
    },
    {
      "indent": 3,
      "text": "The computation of the authentication path is discussed in Section 4.1.9.",
      "ja": "認証パスの計算は、セクション4.1.9に記載されています。"
    },
    {
      "indent": 3,
      "text": "The data format for a signature is given below.",
      "ja": "署名のためのデータフォーマットを以下に示します。"
    },
    {
      "indent": 13,
      "text": "+---------------------------------+\n|                                 |\n|          index idx_sig          |    4 bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|          randomness r           |    n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|     WOTS+ signature sig_ots     |    len * n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|             auth[0]             |    n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n~              ....               ~\n|                                 |\n+---------------------------------+\n|                                 |\n|           auth[h - 1]           |    n bytes\n|                                 |\n+---------------------------------+",
      "raw": true
    },
    {
      "indent": 30,
      "text": "XMSS Signature",
      "ja": "XMSS署名"
    },
    {
      "indent": 0,
      "text": "4.1.9. XMSS Signature Generation",
      "section_title": true,
      "ja": "4.1.9.  XMSSの署名生成"
    },
    {
      "indent": 3,
      "text": "To compute the XMSS signature of a message M with an XMSS private key, the signer first computes a randomized message digest using a random value r, idx_sig, the index of the WOTS+ key pair to be used, and the root value from the public key as key. Then, a WOTS+ signature of the message digest is computed using the next unused WOTS+ private key. Next, the authentication path is computed. Finally, the private key is updated, i.e., idx is incremented. An implementation MUST NOT output the signature before the private key is updated.",
      "ja": "XMSS秘密鍵を用いてメッセージMのXMSS署名を計算するために、署名者は、第1のランダム値r、idx_sig、鍵のペアを使用する+ WOTSの指標、及び公開鍵からルート値を使用して、ランダム化メッセージダイジェストを計算しますキーとして。次に、メッセージダイジェストのWOTS +署名は、次の未使用WOTS +秘密鍵を使用して計算されます。次に、認証パスが計算されます。最後に、秘密鍵が更新され、すなわち、idxがインクリメントされます。実装は、秘密鍵が更新される前に、出力署名してはなりません。"
    },
    {
      "indent": 3,
      "text": "The node values of the authentication path MAY be computed in any way. This computation is assumed to be performed by the subroutine buildAuth for the function XMSS_sign (Algorithm 12). The fastest alternative is to store all tree nodes and set the array in the signature by copying the respective nodes. The least storage-intensive alternative is to recompute all nodes for each signature online using the treeHash algorithm (Algorithm 9). Several algorithms exist in between, with different time/storage trade-offs. For an overview, see [BDS09]. A further approach can be found in [KMN14]. Note that the details of this procedure are not relevant to interoperability; it is not necessary to know any of these details in order to perform the signature verification operation. The following version of buildAuth is given for completeness. It is a simple example for understanding, but extremely inefficient. The use of one of the alternative algorithms is strongly RECOMMENDED.",
      "ja": "認証パスのノード値は、任意の方法で計算することができます。この計算は、関数XMSS_signためのサブルーチンbuildAuth（アルゴリズム12）によって行われるものとします。最速の代替案は、すべてのツリーノードを格納し、各ノードをコピーすることによって、署名の配列を設定することです。前記ストレージ集約代替はtreeHashアルゴリズム（アルゴリズム9）を使用してオンライン各署名に対するすべてのノードを再計算することです。いくつかのアルゴリズムは、異なる時間/ストレージのトレードオフと、の間に存在します。概要については、[BDS09]を参照してください。さらなるアプローチは、[KMN14]に見出すことができます。この手順の詳細は、相互運用性に関連していないことに注意してください。署名検証操作を実行するために、これらの詳細のいずれかを知る必要はありません。 buildAuthの次のバージョンは、完全を期すために与えられています。それは理解するための簡単な例ですが、非常に非効率的。代替アルゴリズムの1つの使用を強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "Given an XMSS private key SK, all nodes in a tree are determined. Their values are defined in terms of treeHash (Algorithm 9). Hence, one can compute the authentication path as follows:",
      "ja": "XMSS秘密鍵SKを考えると、ツリー内のすべてのノードが決定されます。これらの値はtreeHash（アルゴリズム9）で定義されています。以下のようしたがって、一つの認証パスを計算することができます。"
    },
    {
      "indent": 3,
      "text": "(Example) buildAuth - Compute the authentication path for the i^th WOTS+ key pair",
      "ja": "（実施例）buildAuth  -  I ^番目WOTS +鍵ペアの認証パスを計算します"
    },
    {
      "indent": 5,
      "text": "Input: XMSS private key SK, WOTS+ key pair index i, ADRS Output: Authentication path auth",
      "ja": "入力：XMSS秘密鍵SK、WOTS +鍵のペアのインデックスi、ADRS出力：認証パス認証"
    },
    {
      "indent": 5,
      "text": "for ( j = 0; j < h; j++ ) {\n  k = floor(i / (2^j)) XOR 1;\n  auth[j] = treeHash(SK, k * 2^j, j, ADRS);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We split the description of the signature generation into two main algorithms. The first one, treeSig (Algorithm 11), generates the main part of an XMSS signature and is also used by the multi-tree variant XMSS^MT. XMSS_sign (Algorithm 12) calls treeSig but handles message compression before and the private key update afterwards.",
      "ja": "我々は、2つの主なアルゴリズムに署名生成の説明を分割しました。最初に、treeSig（アルゴリズム11）、XMSS署名の主要部分を生成し、マルチツリーバリアントXMSS ^ MTによって使用されます。 XMSS_sign（アルゴリズム12）がtreeSigを呼び出しますが、その後のメッセージの前に圧縮および秘密鍵の更新を処理します。"
    },
    {
      "indent": 3,
      "text": "The algorithm treeSig (Algorithm 11) described below calculates the WOTS+ signature on an n-byte message and the corresponding authentication path. treeSig takes as input an n-byte message M', an XMSS private key SK, a signature index idx_sig, and an address ADRS. It returns the concatenation of the WOTS+ signature sig_ots and authentication path auth.",
      "ja": "treeSig（アルゴリズム11）は以下に説明するアルゴリズムは、nバイトのメッセージと対応する認証パス上WOTS +署名を算出します。 treeSigは、入力としてのnバイトのメッセージM」、XMSS秘密鍵SK、署名インデックスidx_sig、およびアドレスADRSを取ります。これはWOTS +署名sig_ots及び認証パス認証の連結を返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 11: treeSig - Generate a WOTS+ signature on a message with corresponding authentication path",
      "ja": "アルゴリズム11：treeSig  - 認証パスを対応するメッセージにWOTS +署名を生成します"
    },
    {
      "indent": 5,
      "text": "Input: n-byte message M', XMSS private key SK, signature index idx_sig, ADRS Output: Concatenation of WOTS+ signature sig_ots and authentication path auth",
      "ja": "入力：nバイトのメッセージM」、XMSS秘密鍵SK、署名インデックスidx_sig、ADRS出力：WOTS +署名sig_otsと認証パス認証の連結"
    },
    {
      "indent": 5,
      "text": "auth = buildAuth(SK, idx_sig, ADRS);\nADRS.setType(0);   // Type = OTS hash address\nADRS.setOTSAddress(idx_sig);\nsig_ots = WOTS_sign(getWOTS_SK(SK, idx_sig),\n                    M', getSEED(SK), ADRS);\nSig = sig_ots || auth;\nreturn Sig;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The algorithm XMSS_sign (Algorithm 12) described below calculates an updated private key SK and a signature on a message M. XMSS_sign takes as input a message M of arbitrary length and an XMSS private key SK. It returns the byte string containing the concatenation of the updated private key SK and the signature Sig.",
      "ja": "XMSS_sign（アルゴリズム12）は以下に説明するアルゴリズムは、更新された秘密鍵SKとM. XMSS_signは、入力として、メッセージの任意の長さのMとXMSS秘密鍵SKをとるメッセージの署名を計算します。これは、更新された秘密鍵SKと署名シグの連結を含むバイト文字列を返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 12: XMSS_sign - Generate an XMSS signature and update the XMSS private key",
      "ja": "アルゴリズム12：XMSS_sign  -  XMSSの署名を生成し、XMSSプライベートキーを更新"
    },
    {
      "indent": 5,
      "text": "Input: Message M, XMSS private key SK Output: Updated SK, XMSS signature Sig",
      "ja": "入力：メッセージM、XMSS秘密鍵SK出力：更新SK、XMSS署名シグ"
    },
    {
      "indent": 5,
      "text": "idx_sig = getIdx(SK);\nsetIdx(SK, idx_sig + 1);\nADRS = toByte(0, 32);\nbyte[n] r = PRF(getSK_PRF(SK), toByte(idx_sig, 32));\nbyte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig, n)), M);\nSig = idx_sig || r || treeSig(M', SK, idx_sig, ADRS);\nreturn (SK || Sig);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.10. XMSS Signature Verification",
      "section_title": true,
      "ja": "4.1.10.  XMSSの署名の確認"
    },
    {
      "indent": 3,
      "text": "An XMSS signature is verified by first computing the message digest using randomness r, index idx_sig, the root from PK and message M. Then the used WOTS+ public key pk_ots is computed from the WOTS+ signature using WOTS_pkFromSig. The WOTS+ public key in turn is used to compute the corresponding leaf using an L-tree. The leaf, together with index idx_sig and authentication path auth is used to compute an alternative root value for the tree. The verification succeeds if and only if the computed root value matches the one in the XMSS public key. In any other case, it MUST return fail.",
      "ja": "XMSS署名は、乱数rを、インデックスidx_sig、そしてPK及びメッセージMから使用WOTS +公開鍵pk_otsがWOTS_pkFromSigを用いWOTS +署名から計算されたルートを使用してメッセージダイジェストを計算することによって最初に確認されます。順番にWOTS +公開鍵は、L-木を使用して対応するリーフを計算するために使用されます。一緒にインデックスidx_sig及び認証パスAUTHリーフは、ツリーのための代替ルート値を計算するために使用されます。計算されたルート値がXMSS公開鍵の1と一致した場合にだけ、検証が成功します。それ以外の場合は、それが失敗し返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "As for signature generation, we split verification into two parts to allow for reuse in the XMSS^MT description. The steps also needed for XMSS^MT are done by the function XMSS_rootFromSig (Algorithm 13). XMSS_verify (Algorithm 14) calls XMSS_rootFromSig as a subroutine and handles the XMSS-specific steps.",
      "ja": "署名生成用として、我々はXMSS ^ MTの説明では、再利用を可能にするために2つの部分に検証を分割します。またXMSS ^ MTのために必要なステップは、関数XMSS_rootFromSig（アルゴリズム13）によって行われます。 XMSS_verify（アルゴリズム14）サブルーチンとしてXMSS_rootFromSigを呼び出し、XMSS固有の手順を扱います。"
    },
    {
      "indent": 3,
      "text": "The main part of XMSS signature verification is done by the function XMSS_rootFromSig (Algorithm 13) described below. XMSS_rootFromSig takes as input an index idx_sig, a WOTS+ signature sig_ots, an authentication path auth, an n-byte message M', seed SEED, and address ADRS. XMSS_rootFromSig returns an n-byte string holding the value of the root of a tree defined by the input data.",
      "ja": "XMSS署名検証の主要部分は、後述する機能XMSS_rootFromSig（アルゴリズム13）によって行われます。 XMSS_rootFromSigは、入力としてインデックスidx_sig、WOTS +署名sig_ots、認証パスAUTH、nバイトのメッセージM」、シードSEED、及びアドレスADRSをとります。 XMSS_rootFromSigは、入力データによって定義されたツリーのルートの値を保持してnバイトの文字列を返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 13: XMSS_rootFromSig - Compute a root node from a tree signature",
      "ja": "アルゴリズム13：XMSS_rootFromSig  - ツリー署名からルートノードを計算します"
    },
    {
      "indent": 5,
      "text": "Input: index idx_sig, WOTS+ signature sig_ots, authentication path auth, n-byte message M', seed SEED, address ADRS Output: n-byte root value node[0]",
      "ja": "入力：インデックスidx_sig、WOTS +署名sig_ots、認証パスAUTH、nバイトメッセージM」、シードSEED、アドレスADRS出力：nバイトルート値ノード[0]"
    },
    {
      "indent": 5,
      "text": "ADRS.setType(0);   // Type = OTS hash address\nADRS.setOTSAddress(idx_sig);\npk_ots = WOTS_pkFromSig(sig_ots, M', SEED, ADRS);\nADRS.setType(1);   // Type = L-tree address\nADRS.setLTreeAddress(idx_sig);\nbyte[n][2] node;\nnode[0] = ltree(pk_ots, SEED, ADRS);\nADRS.setType(2);   // Type = hash tree address\nADRS.setTreeIndex(idx_sig);\nfor ( k = 0; k < h; k++ ) {\n  ADRS.setTreeHeight(k);\n  if ( (floor(idx_sig / (2^k)) % 2) == 0 ) {\n    ADRS.setTreeIndex(ADRS.getTreeIndex() / 2);\n    node[1] = RAND_HASH(node[0], auth[k], SEED, ADRS);\n  } else {\n    ADRS.setTreeIndex((ADRS.getTreeIndex() - 1) / 2);\n    node[1] = RAND_HASH(auth[k], node[0], SEED, ADRS);\n  }\n  node[0] = node[1];\n}\nreturn node[0];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The full XMSS signature verification is depicted below (Algorithm 14). It handles message compression, delegates the root computation to XMSS_rootFromSig, and compares the result to the value in the public key. XMSS_verify takes as input an XMSS signature Sig, a message M, and an XMSS public key PK. XMSS_verify returns true if and only if Sig is a valid signature on M under public key PK. Otherwise, it returns false.",
      "ja": "完全XMSS署名検証は、（アルゴリズム14）の下方に示されています。これは、メッセージ圧縮、代表者XMSS_rootFromSigにルート計算を処理し、公開鍵の値に結果を比較します。 XMSS_verifyを入力として受け取りXMSS署名SIG、メッセージM、およびXMSS公開鍵PK。 Sigは、公開鍵PKの下にM上の有効な署名がある場合にのみXMSS_verifyはtrueを返します。それ以外の場合はfalseを返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 14: XMSS_verify - Verify an XMSS signature using the corresponding XMSS public key and a message",
      "ja": "アルゴリズム14：XMSS_verify  - 対応XMSS公開鍵とメッセージを使用してXMSS署名を確認"
    },
    {
      "indent": 5,
      "text": "Input: XMSS signature Sig, message M, XMSS public key PK Output: Boolean",
      "ja": "入力：XMSS署名SIG、メッセージM、XMSS公開鍵PK出力：ブール"
    },
    {
      "indent": 5,
      "text": "ADRS = toByte(0, 32);\nbyte[n] M' = H_msg(r || getRoot(PK) || (toByte(idx_sig, n)), M);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "byte[n] node = XMSS_rootFromSig(idx_sig, sig_ots, auth, M',\n                                getSEED(PK), ADRS);\nif ( node == getRoot(PK) ) {\n  return true;\n} else {\n  return false;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.11. Pseudorandom Key Generation",
      "section_title": true,
      "ja": "4.1.11. 擬似ランダムキーの生成"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use a cryptographically secure pseudorandom method to generate the XMSS private key from a single n-byte value. For example, the method suggested in [BDH11] and explained below MAY be used. Other methods, such as the one in [HRS16], MAY be used. The choice of a pseudorandom method does not affect interoperability, but the cryptographic strength MUST match that of the used XMSS parameters.",
      "ja": "実装は、単一のnバイトの値からXMSS秘密鍵を生成するために、暗号的に安全な擬似ランダム方式を使用するかもしれません。例えば、本方法は、[BDH11]で提案して用いることができる以下に説明します。このような[HRS16]内の1つのような他の方法を用いてもよいです。擬似ランダム方法の選択は、相互運用性に影響を与えませんが、暗号の強度が使用XMSSパラメータのものと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For XMSS, a method similar to that for WOTS+ can be used. The suggested method from [BDH11] can be described using PRF. During key generation, a uniformly random n-byte string S is sampled from a secure source of randomness. This seed S MUST NOT be confused with the public seed SEED. The seed S MUST be independent of SEED, and because it is the main secret, it MUST be kept secret. This seed S is used to generate an n-byte value S_ots for each WOTS+ key pair. The n-byte value S_ots can then be used to compute the respective WOTS+ private key using the method described in Section 3.1.7. The seeds for the WOTS+ key pairs are computed as S_ots[i] = PRF(S, toByte(i, 32)) where i is the index of the WOTS+ key pair. An advantage of this method is that a WOTS+ key can be computed using only len + 1 evaluations of PRF when S is given.",
      "ja": "XMSSため、WOTS +と同様の方法を用いることができます。 【BDH11]から提案された方法は、PRFを用いて記述することができます。鍵生成中に、一様にランダムなnバイトストリングSは、乱数の安全なソースからサンプリングされます。このシードSは、公共シードSEEDと混同してはなりません。シードSは、SEEDの独立でなければならない、そしてそれがメインの秘密ですので、それは秘密にしなければなりません。このシードSは各WOTS +鍵ペアのためのnバイト値S_otsを生成するために使用されます。 nバイト値S_otsは、その後、セクション3.1.7に記載した方法を用いて、各WOTS +秘密鍵を計算するために使用することができます。 WOTSための種子+は、鍵ペアは、iがWOTS +鍵ペアのインデックスであるS_ots [I] = PRF（S、toByte（I、32））として計算されます。この方法の利点は、Sが与えられたときWOTS +キーのみLEN PRFの+ 1つの評価を使用して計算することができるということです。"
    },
    {
      "indent": 0,
      "text": "4.1.12. Free Index Handling and Partial Private Keys",
      "section_title": true,
      "ja": "4.1.12. 無料インデックス処理および部分的な秘密鍵"
    },
    {
      "indent": 3,
      "text": "Some applications might require working with partial private keys or copies of private keys. Examples include load balancing and delegation of signing rights or proxy signatures. Such applications MAY use their own key format and MAY use a signing algorithm different from the one described above. The index in partial private keys or copies of a private key MAY be manipulated as required by the applications. However, applications MUST establish means that guarantee that each index, and thereby each WOTS+ key pair, is used to sign only a single message.",
      "ja": "一部のアプリケーションは、部分的な秘密鍵や秘密鍵のコピーでの作業が必要な場合があります。例としては、負荷分散と署名権や代理署名の委任が含まれています。そのようなアプリケーションは、独自のキーの形式を使用するかもしれし、上記とは異なる署名アルゴリズムを使用することができます。アプリケーションで必要とされる部分秘密鍵や秘密鍵のコピーではインデックスが操作することができます。しかし、アプリケーションは各インデックス、それによって各WOTS +鍵ペアは、単一のメッセージに署名するために使用されることを保証する手段を確立しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. XMSS^MT: Multi-Tree XMSS",
      "section_title": true,
      "ja": "4.2.  XMSS ^ MT：マルチツリーXMSS"
    },
    {
      "indent": 3,
      "text": "XMSS^MT is a method for signing a large but fixed number of messages. It was first described in [HRB13]. It builds on XMSS. XMSS^MT uses a tree of several layers of XMSS trees, a so-called hypertree. The trees on top and intermediate layers are used to sign the root nodes of the trees on the respective layer below. Trees on the lowest layer are used to sign the actual messages. All XMSS trees have equal height.",
      "ja": "XMSS ^ MTは、メッセージの大きいが一定数に署名するための方法です。これは、最初の[HRB13]で説明しました。それはXMSSに基づいています。 XMSS ^ MTはXMSSの木、いわゆるhypertreeのいくつかの層の木を使用しています。上部中間層上の樹木は、以下のそれぞれの層の上に木のルートノードを署名するために使用されます。最下層の木は、実際のメッセージに署名するために使用されています。すべてのXMSS木は同じ高さを持っています。"
    },
    {
      "indent": 3,
      "text": "Consider an XMSS^MT tree of total height h that has d layers of XMSS trees of height h / d. Then, layer d - 1 contains one XMSS tree, layer d - 2 contains 2^(h / d) XMSS trees, and so on. Finally, layer 0 contains 2^(h - h / d) XMSS trees.",
      "ja": "高さH / DのXMSS木の層を日間た全高さhのXMSS ^ MTツリーを考えます。次いで、層d  -  2 SOに2 ^（H / D）XMSSツリーを含み、 -  1は、1つのXMSSツリー、層dを含んでいます。 XMSS木 - 最後に、レイヤー0は、2 ^（H / D H）を含みます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. XMSS^MT Parameters",
      "section_title": true,
      "ja": "4.2.1.  XMSS ^ MTパラメータ"
    },
    {
      "indent": 3,
      "text": "In addition to all XMSS parameters, an XMSS^MT system requires the number of tree layers d, specified as an integer value that divides h without remainder. The same tree height h / d and the same Winternitz parameter w are used for all tree layers.",
      "ja": "全てXMSSパラメータに加えて、XMSS ^ MTシステムは余りなしHを分割する整数値として指定されたツリーの層dの数を必要とします。同じツリーの高さh / Dと同じWinternitzパラメータwはすべてのツリー層のために使用されます。"
    },
    {
      "indent": 3,
      "text": "All the trees on higher layers sign root nodes of other trees, with the root nodes being n-byte strings. Hence, no message compression is needed, and WOTS+ is used to sign the root nodes themselves instead of their hash values.",
      "ja": "より高い層の上のすべての木は、nバイトの文字列であるルートノードと、他の木のルートノードに署名します。したがって、メッセージの圧縮が必要とされず、WOTS +代わりに、それらのハッシュ値のルートノード自身の署名に使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. XMSS^MT Key Generation",
      "section_title": true,
      "ja": "4.2.2.  XMSS ^ MTキーの生成"
    },
    {
      "indent": 3,
      "text": "An XMSS^MT private key SK_MT (S for secret) consists of one reduced XMSS private key for each XMSS tree. These reduced XMSS private keys just contain the WOTS+ private keys corresponding to that XMSS key pair; they do not contain a pseudorandom function key, index, public seed, or root node. Instead, SK_MT contains a single n-byte pseudorandom function key SK_PRF, a single (ceil(h / 8))-byte index idx_MT, a single n-byte seed SEED, and a single root value root (which is the root of the single tree on the top layer). The index is a global index over all WOTS+ key pairs of all XMSS trees on layer 0. It is initialized with 0. It stores the index of the last used WOTS+ key pair on the bottom layer, i.e., a number between 0 and 2^h - 1.",
      "ja": "XMSS ^ MT秘密鍵SK_MT（秘密のためのS）は、各XMSSツリーの1つのに減少XMSSの秘密鍵で構成されています。これらの減少XMSS秘密鍵は、まさにそれXMSS鍵のペアに対応するWOTS +秘密鍵が含まれています。彼らは、擬似ランダムファンクションキー、インデックス、公共の種子、またはルートノードが含まれていません。その代わりに、SK_MTは単一のnバイトの擬似ランダム関数キーSK_PRFが含まれ、単一の（CEIL（H / 8）） - のルートであるバイトインデックスidx_MT、単一のNバイトのシードSEED、及び単一のルート値ルート（最上層の単一のツリー）。インデックスはそれはすなわち底層、0と2の間の数で最後に使用WOTS +鍵ペアのインデックスを格納するが、0で初期化されるレイヤー0上のすべてXMSS木の全てWOTS +鍵ペア上グローバルインデックスであります^ H  -  1。"
    },
    {
      "indent": 3,
      "text": "The reduced XMSS private keys MUST either be generated as described in Section 4.1.3 or be generated using a cryptographic pseudorandom method as discussed in Section 4.2.6. As for XMSS, the PRF key SK_PRF MUST be sampled from a secure source of randomness that follows the uniform distribution. SEED is generated as a uniformly random n-byte string. Although SEED is public, it is critical for security that it is generated using a good entropy source. The root is the root node of the single XMSS tree on the top layer. Its computation is explained below. As for XMSS, root and SEED are public information and would classically be considered part of the public key. However, as both are needed for signing, which only takes the private key, they are also part of SK_MT.",
      "ja": "セクション4.1.3で説明またはセクション4.2.6で説明したように暗号擬似乱数方法を使用して生成するように減少XMSS秘密鍵のいずれかに生成されなければなりません。 XMSSとして、PRFキーSK_PRFは一様分布に従う乱数の安全なソースからサンプリングしなければなりません。 SEEDは一様にランダムなnバイトの文字列として生成されます。 SEEDは公共のですが、それは良いエントロピーソースを使用して生成されたセキュリティのために重要です。ルートは、最上層の単一XMSSツリーのルートノードです。その計算について説明します。 XMSSについては、根とSEEDは公開情報であり、古典的な公開鍵の一部とみなされるであろう。両者は秘密鍵だけを取る署名、ために必要とされているようしかし、彼らはまた、SK_MTの一部です。"
    },
    {
      "indent": 3,
      "text": "This document does not define any specific format for the XMSS^MT private key SK_MT as it is not required for interoperability. Algorithms 15 and 16 use a function getXMSS_SK(SK, x, y) that outputs the reduced private key of the x^th XMSS tree on the y^th layer.",
      "ja": "それは相互運用性のために必要とされていないとして、この文書はXMSS ^ MT秘密鍵SK_MTのための任意の特定のフォーマットを定義していません。アルゴリズム15及び16は、Y ^番目の層上のx ^番目XMSSツリーの低下秘密鍵を出力する関数getXMSS_SK（SK、x、y）を使用します。"
    },
    {
      "indent": 3,
      "text": "The XMSS^MT public key PK_MT contains the root of the single XMSS tree on layer d - 1 and the seed SEED. These are the same values as in the private key SK_MT. The pseudorandom function PRF keyed with SEED is used to generate the bitmasks and keys for all XMSS trees. XMSSMT_keyGen (Algorithm 15) shows example pseudocode to generate SK_MT and PK_MT. The n-byte root node of the top-layer tree is computed using treeHash. The algorithm XMSSMT_keyGen outputs an XMSS^MT private key SK_MT and an XMSS^MT public key PK_MT. The algorithm below gives an example of how the reduced XMSS private keys can be generated. However, any of the above mentioned ways is acceptable as long as the cryptographic strength of the used method matches or supersedes that of the used XMSS^MT parameter set.",
      "ja": "1とシードSEED  -  XMSS ^ MT公開鍵PK_MTは、層d上の単一XMSSツリーのルートが含まれています。これらは、秘密鍵SK_MTと同じ値です。 SEEDとキーイング擬似乱数関数PRFは全てXMSS木のためのビットマスクと鍵を生成するために使用されます。 XMSSMT_keyGen（アルゴリズム15）SK_MTとPK_MTを生成するための例示的疑似コードを示しています。上層木のnバイトのルートノードがtreeHashを使用して計算されます。 XMSS ^ MT秘密鍵SK_MTとXMSS ^ MT公開鍵PK_MTを出力XMSSMT_keyGenアルゴリズム。以下のアルゴリズムが減少XMSS秘密鍵を生成することができる方法の例を示します。使用される方法の暗号化強度が一致するかその使用XMSS ^ MTパラメータセットの優先さしかしながら、上述の方法のいずれかであれば許容されます。"
    },
    {
      "indent": 3,
      "text": "Algorithm 15: XMSSMT_keyGen - Generate an XMSS^MT key pair",
      "ja": "アルゴリズム15：XMSSMT_keyGen  -  XMSS ^ MT鍵ペアを生成"
    },
    {
      "indent": 5,
      "text": "Input: No input Output: XMSS^MT private key SK_MT, XMSS^MT public key PK_MT",
      "ja": "入力：なし入力出力：XMSS ^ MT秘密鍵SK_MT、XMSS ^ MT公開鍵PK_MT"
    },
    {
      "indent": 5,
      "text": "// Example initialization\nidx_MT = 0;\nsetIdx(SK_MT, idx_MT);\ninitialize SK_PRF with a uniformly random n-byte string;\nsetSK_PRF(SK_MT, SK_PRF);\ninitialize SEED with a uniformly random n-byte string;\nsetSEED(SK_MT, SEED);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "// Generate reduced XMSS private keys\nADRS = toByte(0, 32);\nfor ( layer = 0; layer < d; layer++ ) {\n   ADRS.setLayerAddress(layer);\n   for ( tree = 0; tree <\n         (1 << ((d - 1 - layer) * (h / d)));\n         tree++ ) {\n      ADRS.setTreeAddress(tree);\n      for ( i = 0; i < 2^(h / d); i++ ) {\n        wots_sk[i] = WOTS_genSK();\n      }\n      setXMSS_SK(SK_MT, wots_sk, tree, layer);\n   }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "SK = getXMSS_SK(SK_MT, 0, d - 1);\nsetSEED(SK, SEED);\nroot = treeHash(SK, 0, h / d, ADRS);\nsetRoot(SK_MT, root);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PK_MT = OID || root || SEED;\nreturn (SK_MT || PK_MT);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above is just an example algorithm. It is strongly RECOMMENDED to use pseudorandom key generation to reduce the private key size. Public and private key generation MAY be interleaved to save space. In particular, when a pseudorandom method is used to generate the private key, generation MAY be delayed to the point that the respective WOTS+ key pair is needed by another algorithm.",
      "ja": "上記は一例アルゴリズムです。強く、秘密鍵のサイズを縮小するために、疑似ランダムキー生成を使用することをお勧めします。公開鍵と秘密鍵の生成には、スペースを節約するためにインターリーブされるかもしれません。擬似ランダム法は、秘密鍵を生成するために使用される場合、特に、世代は、それぞれWOTS +鍵ペアが別のアルゴリズムによって必要とされている点に遅延させることができます。"
    },
    {
      "indent": 3,
      "text": "The format of an XMSS^MT public key is given below.",
      "ja": "XMSS ^ MT公開鍵のフォーマットは以下のとおりです。"
    },
    {
      "indent": 12,
      "text": "+---------------------------------+\n|          algorithm OID          |\n+---------------------------------+\n|                                 |\n|            root node            |     n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|              SEED               |     n bytes\n|                                 |\n+---------------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "XMSS^MT Public Key",
      "ja": "XMSS ^ MT公開鍵"
    },
    {
      "indent": 0,
      "text": "4.2.3. XMSS^MT Signature",
      "section_title": true,
      "ja": "4.2.3.  XMSS ^ MT署名"
    },
    {
      "indent": 3,
      "text": "An XMSS^MT signature Sig_MT is a byte string of length (ceil(h / 8) + n + (h + d * len) * n). It consists of:",
      "ja": "XMSS ^ MT署名Sig_MTはバイト長の文字列（CEIL（H / 8）+ N +（H + D * LEN）* N）です。これは、で構成されています。"
    },
    {
      "indent": 3,
      "text": "o the index idx_sig of the used WOTS+ key pair on the bottom layer (ceil(h / 8) bytes),",
      "ja": "、下層のキーペア（CEIL（H / 8）バイト）を使用WOTSのインデックスidx_sig + O"
    },
    {
      "indent": 3,
      "text": "o a byte string r used for randomized message hashing (n bytes), and",
      "ja": "ランダム化されたハッシュメッセージ（Nバイト）のために使用されるバイト文字列R O、及び"
    },
    {
      "indent": 3,
      "text": "o d reduced XMSS signatures ((h / d + len) * n bytes each).",
      "ja": "O D（*（H / D + LEN）nは各バイト）XMSS署名を減少させました。"
    },
    {
      "indent": 3,
      "text": "The reduced XMSS signatures only contain a WOTS+ signature sig_ots and an authentication path auth. They contain no index idx and no byte string r.",
      "ja": "減少XMSS署名のみWOTS +署名sig_ots及び認証パス認証含みます。彼らは何のインデックスIDXなしバイト列rを含みません。"
    },
    {
      "indent": 3,
      "text": "The data format for a signature is given below.",
      "ja": "署名のためのデータフォーマットを以下に示します。"
    },
    {
      "indent": 11,
      "text": "+---------------------------------+\n|                                 |\n|          index idx_sig          |   ceil(h / 8) bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|          randomness r           |   n bytes\n|                                 |\n+---------------------------------+\n|                                 |\n|  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes\n|        (bottom layer 0)         |\n|                                 |\n+---------------------------------+\n|                                 |\n|  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes\n|            (layer 1)            |\n|                                 |\n+---------------------------------+\n|                                 |\n~              ....               ~\n|                                 |\n+---------------------------------+\n|                                 |\n|  (reduced) XMSS signature Sig   |   (h / d + len) * n bytes\n|          (layer d - 1)          |\n|                                 |\n+---------------------------------+",
      "raw": true
    },
    {
      "indent": 29,
      "text": "XMSS^MT Signature",
      "ja": "XMSS ^ MT署名"
    },
    {
      "indent": 0,
      "text": "4.2.4. XMSS^MT Signature Generation",
      "section_title": true,
      "ja": "4.2.4.  XMSS ^ MTの署名生成"
    },
    {
      "indent": 3,
      "text": "To compute the XMSS^MT signature Sig_MT of a message M using an XMSS^MT private key SK_MT, XMSSMT_sign (Algorithm 16) described below uses treeSig as defined in Section 4.1.9. First, the signature index is set to idx_sig. Next, PRF is used to compute a pseudorandom n-byte string r. This n-byte string, idx_sig, and the root node from PK_MT are then used to compute a randomized message digest of length n. The message digest is signed using the WOTS+ key pair on the bottom layer with absolute index idx. The authentication path for the WOTS+ key pair and the root of the containing XMSS tree are computed. The root is signed by the parent XMSS tree. This is repeated until the top tree is reached.",
      "ja": "XMSS ^ MT秘密鍵SK_MTを使用してメッセージMのXMSS ^ MT署名Sig_MTを計算するために、XMSSMT_sign（アルゴリズム16）は、以下に記載のセクション4.1.9で定義されるようtreeSigを使用します。まず、署名インデックスはidx_sigに設定されています。次に、PRFは、擬似乱数nバイト列Rを計算するために使用されます。 PK_MTからこのnバイト列、idx_sig、ルートノードは、次に、長さnのランダム化されたメッセージダイジェストを計算するために使用されます。メッセージダイジェストは、絶対インデックスIDXと底層上にWOTS +鍵のペアを使用して署名されます。 WOTS +鍵のペアとを含むXMSSツリーのルートの認証パスが計算されます。ルートは、親XMSSツリーによって署名されています。トップツリーに到達するまで、これが繰り返されます。"
    },
    {
      "indent": 3,
      "text": "Algorithm 16: XMSSMT_sign - Generate an XMSS^MT signature and update the XMSS^MT private key",
      "ja": "アルゴリズム16：XMSSMT_sign  -  XMSS ^ MTの署名を生成し、XMSS ^ MTプライベートキーを更新"
    },
    {
      "indent": 5,
      "text": "Input: Message M, XMSS^MT private key SK_MT Output: Updated SK_MT, signature Sig_MT",
      "ja": "入力：メッセージM、XMSS ^ MT秘密鍵SK_MT出力：更新SK_MT、署名Sig_MT"
    },
    {
      "indent": 5,
      "text": "// Init\nADRS = toByte(0, 32);\nSEED = getSEED(SK_MT);\nSK_PRF = getSK_PRF(SK_MT);\nidx_sig = getIdx(SK_MT);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "// Update SK_MT setIdx(SK_MT, idx_sig + 1);",
      "ja": "//更新SK_MT setIdx（SK_MT、idx_sig + 1）。"
    },
    {
      "indent": 5,
      "text": "// Message compression\nbyte[n] r = PRF(SK_PRF, toByte(idx_sig, 32));\nbyte[n] M' = H_msg(r || getRoot(SK_MT) || (toByte(idx_sig, n)), M);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "// Sign\nSig_MT = idx_sig;\nunsigned int idx_tree\n              = (h - h / d) most significant bits of idx_sig;\nunsigned int idx_leaf = (h / d) least significant bits of idx_sig;\nSK = idx_leaf || getXMSS_SK(SK_MT, idx_tree, 0) || SK_PRF\n      || toByte(0, n) || SEED;\nADRS.setLayerAddress(0);\nADRS.setTreeAddress(idx_tree);\nSig_tmp = treeSig(M', SK, idx_leaf, ADRS);\nSig_MT = Sig_MT || r || Sig_tmp;\nfor ( j = 1; j < d; j++ ) {\n   root = treeHash(SK, 0, h / d, ADRS);\n   idx_leaf = (h / d) least significant bits of idx_tree;\n   idx_tree = (h - j * (h / d)) most significant bits of idx_tree;\n   SK = idx_leaf || getXMSS_SK(SK_MT, idx_tree, j) || SK_PRF\n          || toByte(0, n) || SEED;\n   ADRS.setLayerAddress(j);\n   ADRS.setTreeAddress(idx_tree);\n   Sig_tmp = treeSig(root, SK, idx_leaf, ADRS);\n   Sig_MT = Sig_MT || Sig_tmp;\n}\nreturn SK_MT || Sig_MT;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Algorithm 16 is only one method to compute XMSS^MT signatures. Time-memory trade-offs exist that allow reduction of the signing time to less than the signing time of an XMSS scheme with tree height h / d. These trade-offs 1) prevent certain values from being recomputed several times by keeping a state and 2) distribute all computations over all signature generations. Details can be found in [Huelsing13a].",
      "ja": "アルゴリズム16はXMSS ^ MTの署名を計算する唯一の方法です。時間メモリトレードオフは、ツリーの高さh / dのXMSS方式の署名時間以下に署名時間の短縮を可能にする存在します。これらのトレードオフは、1）状態を維持して数回再計算されることから特定の値を防ぎ、2）すべての署名世代にわたるすべての計算を配布します。詳細は[Huelsing13a]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "4.2.5. XMSS^MT Signature Verification",
      "section_title": true,
      "ja": "4.2.5.  XMSS ^ MTの署名の確認"
    },
    {
      "indent": 3,
      "text": "XMSS^MT signature verification (Algorithm 17) can be summarized as d XMSS signature verifications with small changes. First, the message is hashed. The XMSS signatures are then all on n-byte values. Second, instead of comparing the computed root node to a given value, a signature on this root node is verified. Only the root node of the top tree is compared to the value in the XMSS^MT public key. XMSSMT_verify uses XMSS_rootFromSig. The function getXMSSSignature(Sig_MT, i) returns the ith reduced XMSS signature from the XMSS^MT signature Sig_MT. XMSSMT_verify takes as input an XMSS^MT signature Sig_MT, a message M, and a public key PK_MT. XMSSMT_verify returns true if and only if Sig_MT is a valid signature on M under public key PK_MT. Otherwise, it returns false.",
      "ja": "XMSS ^ MT署名検証（アルゴリズム17）は、小さな変更でD XMSS署名検証のように要約することができます。まず、メッセージがハッシュされます。 XMSS署名は、nバイトの値にすべてです。第二に、代わりに所定の値に計算されたルートノードを比較し、このルートノード上の署名が検証されます。トップツリーのルートノードのみがXMSS ^ MT公開鍵の値と比較されます。 XMSSMT_verifyはXMSS_rootFromSigを使用しています。関数getXMSSSignature（Sig_MT、i）は、i番目のXMSS ^ MT署名Sig_MTからXMSS署名を低減返します。 XMSSMT_verifyは、入力としてXMSS ^ MT署名Sig_MT、メッセージM、及び公開鍵PK_MTをとります。 Sig_MTは、公開鍵PK_MT下M上で有効な署名がある場合にのみXMSSMT_verifyはtrueを返します。それ以外の場合はfalseを返します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 17: XMSSMT_verify - Verify an XMSS^MT signature Sig_MT on a message M using an XMSS^MT public key PK_MT",
      "ja": "アルゴリズム17：XMSSMT_verify  -  XMSS ^ MT公開鍵PK_MTを使用してメッセージMのXMSS ^ MT署名Sig_MTを確認してください"
    },
    {
      "indent": 5,
      "text": "Input: XMSS^MT signature Sig_MT, message M, XMSS^MT public key PK_MT Output: Boolean",
      "ja": "入力：XMSS ^ MT署名Sig_MT、メッセージM、XMSS ^ MT公開鍵PK_MT出力：ブール"
    },
    {
      "indent": 5,
      "text": "idx_sig = getIdx(Sig_MT);\nSEED = getSEED(PK_MT);\nADRS = toByte(0, 32);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "byte[n] M' = H_msg(getR(Sig_MT) || getRoot(PK_MT) || (toByte(idx_sig, n)), M);",
      "ja": "バイト[n]はM」= H_msg（GETR（Sig_MT）|| getRoot（PK_MT）||（toByte（idx_sig、N））、M）;"
    },
    {
      "indent": 5,
      "text": "unsigned int idx_leaf\n              = (h / d) least significant bits of idx_sig;\nunsigned int idx_tree\n              = (h - h / d) most significant bits of idx_sig;\nSig' = getXMSSSignature(Sig_MT, 0);\nADRS.setLayerAddress(0);\nADRS.setTreeAddress(idx_tree);\nbyte[n] node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),\n                                 getAuth(Sig'), M', SEED, ADRS);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for ( j = 1; j < d; j++ ) {\n   idx_leaf = (h / d) least significant bits of idx_tree;\n   idx_tree = (h - j * h / d) most significant bits of idx_tree;\n   Sig' = getXMSSSignature(Sig_MT, j);\n   ADRS.setLayerAddress(j);\n   ADRS.setTreeAddress(idx_tree);\n   node = XMSS_rootFromSig(idx_leaf, getSig_ots(Sig'),\n                         getAuth(Sig'), node, SEED, ADRS);\n}\nif ( node == getRoot(PK_MT) ) {\n  return true;\n} else {\n  return false;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.6. Pseudorandom Key Generation",
      "section_title": true,
      "ja": "4.2.6. 擬似ランダムキーの生成"
    },
    {
      "indent": 3,
      "text": "Like for XMSS, an implementation MAY use a cryptographically secure pseudorandom method to generate the XMSS^MT private key from a single n-byte value. For example, the method explained below MAY be used. Other methods, such as the one in [HRS16], MAY be used. The choice of a pseudorandom method does not affect interoperability, but the cryptographic strength MUST match that of the used XMSS^MT parameters.",
      "ja": "XMSSのためのように、実装は、単一のnバイトの値からXMSS ^ MT秘密鍵を生成するために、暗号的に安全な擬似ランダム方式を使用するかもしれません。例えば、方法を用いることができる以下に説明します。このような[HRS16]内の1つのような他の方法を用いてもよいです。擬似ランダム方法の選択は、相互運用性に影響を与えませんが、暗号の強度が使用XMSS ^ MTパラメータのものと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For XMSS^MT, a method similar to that for XMSS and WOTS+ can be used. The method uses PRF. During key generation, a uniformly random n-byte string S_MT is sampled from a secure source of randomness. This seed S_MT is used to generate one n-byte value S for each XMSS key pair. This n-byte value can be used to compute the respective XMSS private key using the method described in Section 4.1.11. Let S[x][y] be the seed for the x^th XMSS private key on layer y. The seeds are computed as S[x][y] = PRF(PRF(S, toByte(y, 32)), toByte(x, 32)).",
      "ja": "XMSS ^ MTの場合、XMSSとWOTS +と同様の方法を用いることができます。この方法は、PRFを使用しています。鍵生成中に、一様にランダムなnバイトストリングS_MTは、乱数の安全なソースからサンプリングされます。この種S_MT各XMSS鍵ペアのための1つのnバイト値Sを生成するために使用されます。このnバイトの値は、セクション4.1.11に記載された方法を用いて、各XMSS秘密鍵を計算するために使用することができます。 S [X] [Y]はレイヤY上のx ^番目XMSS秘密鍵のシードとします。種子はSとして計算される[X] [Y] = PRF（PRF（S、toByte（Y、32））、toByte（X、32））。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Free Index Handling and Partial Private Keys",
      "section_title": true,
      "ja": "4.2.7. 無料インデックス処理および部分的な秘密鍵"
    },
    {
      "indent": 3,
      "text": "The content of Section 4.1.12 also applies to XMSS^MT.",
      "ja": "セクション4.1.12の内容もXMSS ^ MTに適用されます。"
    },
    {
      "indent": 0,
      "text": "5. Parameter Sets",
      "section_title": true,
      "ja": "5.パラメータセット"
    },
    {
      "indent": 3,
      "text": "This section provides basic parameter sets that are assumed to cover most relevant applications. Parameter sets for two classical security levels are defined. Parameters with n = 32 provide a classical security level of 256 bits. Parameters with n = 64 provide a classical security level of 512 bits. Considering quantum-computer-aided attacks, these output sizes yield post-quantum security of 128 and 256 bits, respectively.",
      "ja": "このセクションでは、最も関連性の高いアプリケーションをカバーすると想定されている基本的なパラメータセットを提供します。 2つの古典のセキュリティレベルのパラメータセットが定義されています。 N = 32とパラメータが256ビットの古典的なセキュリティレベルを提供します。 N = 64を持つパラメータは512ビットの古典的なセキュリティレベルを提供します。量子コンピュータ支援攻撃を考慮すると、これらの出力サイズは、それぞれ、128および256ビットのポスト量子セキュリティをもたらします。"
    },
    {
      "indent": 3,
      "text": "While this document specifies several parameter sets, an implementation is only REQUIRED to provide support for verification of all REQUIRED parameter sets. The REQUIRED parameter sets all use SHA2-256 to instantiate all functions. The REQUIRED parameter sets are only distinguished by the tree height parameter h (which determines the number of signatures that can be done with a single key pair) and the number of layers d (which defines a trade-off between speed and signature size). An implementation MAY provide support for signature generation using any of the proposed parameter sets. For convenience, this document defines a default option for XMSS (XMSS_SHA2_20_256) and XMSS^MT (XMSSMT-SHA2_60/3_256). These are supposed to match the most generic requirements.",
      "ja": "この文書は、いくつかのパラメータセットを指定しますが、実装は唯一必要なすべてのパラメータセットの検証のためのサポートを提供するために必要とされます。 REQUIREDパラメータはすべて、すべての機能をインスタンス化するSHA2-256を使用して設定します。必須パラメータセットのみと（速度及び署名サイズとのトレードオフを規定する）は、D層の数（単一の鍵ペアを用いて行うことができる署名の数を決定する）樹高パラメータhによって区別されます。実装は、提案パラメータセットのいずれかを使用して署名生成のためのサポートを提供してもよいです。便宜上、このドキュメントはXMSS（XMSS_SHA2_20_256）とXMSS ^ MT（XMSSMT-SHA2_60 / 3_256）のデフォルトのオプションを定義します。これらは、最も一般的な要件に合致するようになっています。"
    },
    {
      "indent": 0,
      "text": "5.1. Implementing the Functions",
      "section_title": true,
      "ja": "5.1. 機能を実現"
    },
    {
      "indent": 3,
      "text": "For the n = 32 setting, we give parameters that use SHA2-256 as defined in [FIPS180] and other parameters that use the SHA3/Keccak-based extendable-output function SHAKE-128 as defined in [FIPS202]. For the n = 64 setting, we give parameters that use SHA2-512 as defined in [FIPS180] and other parameters that use the SHA3/Keccak-based extendable-output functions SHAKE-256 as defined in [FIPS202]. The parameter sets using SHA2-256 are mandatory for deployment and therefore MUST be provided by any implementation. The remaining parameter sets specified in this document are OPTIONAL.",
      "ja": "N = 32に設定するために、我々は[FIPS180]と[FIPS202]で定義されるようSHA3 / Keccakベース伸縮出力機能SHAKE-128を使用する他のパラメータで定義されSHA2-256を使用するパラメータを与えます。 N = 64に設定するために、我々は[FIPS180]及びSHA3 / Keccakベース伸縮出力機能を使用する他のパラメータで定義されSHA2-512を使用する[FIPS202]で定義されるように、256をSHAKEパラメータを与えます。 SHA2-256を使用してパラメータセットは、展開のために必須であり、従って、任意の実装によって提供されなければなりません。この文書で指定された残りのパラメータセットはオプションです。"
    },
    {
      "indent": 3,
      "text": "SHA2 does not provide a keyed-mode itself. To implement the keyed hash functions, the following is used for SHA2 with n = 32:",
      "ja": "SHA2はキーモード自体を提供していません。鍵付きハッシュ関数を実装するために、以下ではN = 32とSHA2のために使用されます。"
    },
    {
      "indent": 6,
      "text": "F: SHA2-256(toByte(0, 32) || KEY || M),",
      "ja": "F：SHA2-256（toByte（0、32）|| KEY || M）、"
    },
    {
      "indent": 6,
      "text": "H: SHA2-256(toByte(1, 32) || KEY || M),",
      "ja": "H：SHA2-256（toByte（1、32）|| KEY || M）、"
    },
    {
      "indent": 6,
      "text": "H_msg: SHA2-256(toByte(2, 32) || KEY || M), and",
      "ja": "H_msg：SHA2-256（toByte（2、32）|| KEY || M）、及び"
    },
    {
      "indent": 6,
      "text": "PRF: SHA2-256(toByte(3, 32) || KEY || M).",
      "ja": "PRF：SHA2-256（toByte（3、32）|| KEY || M）。"
    },
    {
      "indent": 3,
      "text": "Accordingly, for SHA2 with n = 64 we use:",
      "ja": "したがって、我々が使用する64のn = SHA2用："
    },
    {
      "indent": 6,
      "text": "F: SHA2-512(toByte(0, 64) || KEY || M),",
      "ja": "F：SHA2-512（toByte（0、64）|| KEY || M）、"
    },
    {
      "indent": 6,
      "text": "H: SHA2-512(toByte(1, 64) || KEY || M),",
      "ja": "H：SHA2-512（toByte（1、64）|| KEY || M）、"
    },
    {
      "indent": 6,
      "text": "H_msg: SHA2-512(toByte(2, 64) || KEY || M), and",
      "ja": "H_msg：SHA2-512（toByte（2、64）|| KEY || M）、及び"
    },
    {
      "indent": 6,
      "text": "PRF: SHA2-512(toByte(3, 64) || KEY || M).",
      "ja": "PRF：SHA2-512（toByte（3、64）|| KEY || M）。"
    },
    {
      "indent": 3,
      "text": "The n-byte padding is used for two reasons. First, it is necessary that the internal compression function takes 2n-byte blocks, but keys are n and 3n bytes long. Second, the padding is used to achieve independence of the different function families. Finally, for the PRF, no full-fledged Hash-Based Message Authentication Code (HMAC) is needed as the message length is fixed, meaning that standard length extension attacks are not a concern here. For that reason, the simpler construction above suffices.",
      "ja": "nバイトのパディングは、2つの理由のために使用されています。まず、内部の圧縮機能は、2Nバイトのブロックを取ることが必要ですが、キーは、nおよび3Nバイト長です。第二に、パディングは異なる機能ファミリーの独立性を達成するために使用されます。メッセージの長さが固定されている最後に、PRFのために、何の本格的なハッシュベースのメッセージ認証コード（HMAC）は、標準的な長さの延長攻撃がここに懸念はないことを意味し、必要ありません。そのため、簡単な構成は、上記で十分。"
    },
    {
      "indent": 3,
      "text": "Similar constructions are used with SHA3. To implement the keyed hash functions, the following is used for SHA3 with n = 32:",
      "ja": "同様の構造はSHA3で使用されています。鍵付きハッシュ関数を実装するために、以下ではN = 32とSHA3ために使用されます。"
    },
    {
      "indent": 6,
      "text": "F: SHAKE128(toByte(0, 32) || KEY || M, 256),",
      "ja": "F：SHAKE128（toByte（0、32）|| || KEY M、256）、"
    },
    {
      "indent": 6,
      "text": "H: SHAKE128(toByte(1, 32) || KEY || M, 256),",
      "ja": "H：SHAKE128（toByte（1、32）|| || KEY M、256）、"
    },
    {
      "indent": 6,
      "text": "H_msg: SHAKE128(toByte(2, 32) || KEY || M, 256),",
      "ja": "H_msg：SHAKE128（toByte（2、32）|| || KEY M、256）、"
    },
    {
      "indent": 6,
      "text": "PRF: SHAKE128(toByte(3, 32) || KEY || M, 256).",
      "ja": "PRF：SHAKE128（toByte（3、32）|| || KEY M、256）。"
    },
    {
      "indent": 3,
      "text": "Accordingly, for SHA3 with n = 64, we use:",
      "ja": "したがって、N = 64とSHA3のために、我々は、使用します。"
    },
    {
      "indent": 6,
      "text": "F: SHAKE256(toByte(0, 64) || KEY || M, 512),",
      "ja": "F：SHAKE256（toByte（0、64）|| || KEY M、512）、"
    },
    {
      "indent": 6,
      "text": "H: SHAKE256(toByte(1, 64) || KEY || M, 512),",
      "ja": "H：SHAKE256（toByte（1、64）|| || KEY M、512）、"
    },
    {
      "indent": 6,
      "text": "H_msg: SHAKE256(toByte(2, 64) || KEY || M, 512),",
      "ja": "H_msg：SHAKE256（toByte（2、64）|| || KEY M、512）、"
    },
    {
      "indent": 6,
      "text": "PRF: SHAKE256(toByte(3, 64) || KEY || M, 512).",
      "ja": "PRF：SHAKE256（toByte（3、64）|| || KEY M、512）。"
    },
    {
      "indent": 3,
      "text": "As for SHA2, an initial n-byte identifier is used to achieve independence of the different function families. While a shorter identifier could be used in case of SHA3, we use n bytes for consistency with the SHA2 implementations.",
      "ja": "SHA2については、最初のnバイトの識別子は、異なる機能ファミリーの独立性を達成するために使用されます。短い識別子がSHA3の場合に使用することができるが、我々は、SHA2の実装との整合性のためにnバイトを使用します。"
    },
    {
      "indent": 0,
      "text": "5.2. WOTS+ Parameters",
      "section_title": true,
      "ja": "5.2.  WOTS +パラメータ"
    },
    {
      "indent": 3,
      "text": "To fully describe a WOTS+ signature method, the parameters n and w, as well as the functions F and PRF, MUST be specified. The following table defines several WOTS+ signature systems, each of which is identified by a name. Naming follows this convention: WOTSP-[Hashfamily]_[n in bits]. Naming does not include w as all parameter sets in this document use w=16. Values for len are provided for convenience.",
      "ja": "完全WOTS +署名方法を説明するために、パラメータNおよびW、ならびに関数FおよびPRFは、指定しなければなりません。以下の表は、名前で識別されそれぞれがいくつかのWOTS +署名システムを定義します。命名は、この規則に従う：WOTSP- [Hashfamily] _ [Nビットで]。命名は、16 = W、この文書の使用中のすべてのパラメータセットとしてwを含んでいません。 LENの値は便宜のために提供されています。"
    },
    {
      "indent": 14,
      "text": "+-----------------+----------+----+----+-----+\n| Name            | F / PRF  |  n |  w | len |\n+-----------------+----------+----+----+-----+\n| REQUIRED:       |          |    |    |     |\n|                 |          |    |    |     |\n| WOTSP-SHA2_256  | SHA2-256 | 32 | 16 |  67 |\n|                 |          |    |    |     |\n| OPTIONAL:       |          |    |    |     |\n|                 |          |    |    |     |\n| WOTSP-SHA2_512  | SHA2-512 | 64 | 16 | 131 |\n|                 |          |    |    |     |\n| WOTSP-SHAKE_256 | SHAKE128 | 32 | 16 |  67 |\n|                 |          |    |    |     |\n| WOTSP-SHAKE_512 | SHAKE256 | 64 | 16 | 131 |\n+-----------------+----------+----+----+-----+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "The implementation of the single functions is done as described above. External Data Representation (XDR) formats for WOTS+ are listed in Appendix A.",
      "ja": "上記のように単機能の実装が行われます。外部データ表現（XDR）WOTS +のためのフォーマットは、付録Aに記載されています"
    },
    {
      "indent": 0,
      "text": "5.3. XMSS Parameters",
      "section_title": true,
      "ja": "5.3.  XMSSパラメータ"
    },
    {
      "indent": 3,
      "text": "To fully describe an XMSS signature method, the parameters n, w, and h, as well as the functions F, H, H_msg, and PRF, MUST be specified. The following table defines different XMSS signature systems, each of which is identified by a name. Naming follows this convention: XMSS-[Hashfamily]_[h]_[n in bits]. Naming does not include w as all parameter sets in this document use w=16.",
      "ja": "完全XMSS署名方法を説明するために、パラメータn、W、およびH、ならびに機能F、H、H_msg、およびPRFは、指定しなければなりません。以下の表は、名前によって識別されるそれぞれが異なるXMSS署名システムを定義します。命名は、この規則に従う：XMSS- [Hashfamily] _ [H] _ [Nビットで]。命名は、16 = W、この文書の使用中のすべてのパラメータセットとしてwを含んでいません。"
    },
    {
      "indent": 10,
      "text": "+-------------------+-----------+----+----+-----+----+\n| Name              | Functions |  n |  w | len |  h |\n+-------------------+-----------+----+----+-----+----+\n| REQUIRED:         |           |    |    |     |    |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_10_256  | SHA2-256  | 32 | 16 |  67 | 10 |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_16_256  | SHA2-256  | 32 | 16 |  67 | 16 |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_20_256  | SHA2-256  | 32 | 16 |  67 | 20 |\n|                   |           |    |    |     |    |\n| OPTIONAL:         |           |    |    |     |    |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_10_512  | SHA2-512  | 64 | 16 | 131 | 10 |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_16_512  | SHA2-512  | 64 | 16 | 131 | 16 |\n|                   |           |    |    |     |    |\n| XMSS-SHA2_20_512  | SHA2-512  | 64 | 16 | 131 | 20 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_10_256 | SHAKE128  | 32 | 16 |  67 | 10 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_16_256 | SHAKE128  | 32 | 16 |  67 | 16 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_20_256 | SHAKE128  | 32 | 16 |  67 | 20 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_10_512 | SHAKE256  | 64 | 16 | 131 | 10 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_16_512 | SHAKE256  | 64 | 16 | 131 | 16 |\n|                   |           |    |    |     |    |\n| XMSS-SHAKE_20_512 | SHAKE256  | 64 | 16 | 131 | 20 |\n+-------------------+-----------+----+----+-----+----+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 3,
      "text": "The XDR formats for XMSS are listed in Appendix B.",
      "ja": "XMSSのためのXDR形式は付録Bに記載されています"
    },
    {
      "indent": 0,
      "text": "5.3.1. Parameter Guide",
      "section_title": true,
      "ja": "5.3.1. パラメーター・ガイド"
    },
    {
      "indent": 3,
      "text": "In contrast to traditional signature schemes like RSA or Digital Signature Algorithm (DSA), XMSS has a tree height parameter h that determines the number of messages that can be signed with one key pair. Increasing the height allows using a key pair for more signatures, but it also increases the signature size and slows down key generation, signing, and verification. To demonstrate the impact of different values of h, the following table shows signature size and runtimes. Runtimes are given as the number of calls to F and H when the BDS algorithm is used to compute authentication paths for the worst case. The last column shows the number of messages that can be signed with one key pair. The numbers are the same for the XMSS-SHAKE instances with same parameters h and n.",
      "ja": "RSA又はデジタル署名アルゴリズム（DSA）のような伝統的な署名方式とは対照的に、XMSSは、一つの鍵ペアで署名することができるメッセージの数を決定樹高パラメータHを有しています。高さを高くすると、より署名用の鍵ペアを使用することを可能にするが、それはまた、署名のサイズを増加させ、鍵生成、署名、検証を遅く。時間の異なる値の影響を実証するために、次の表は、署名のサイズと実行時間を示しています。ランタイムは、BDSアルゴリズムは最悪の場合の認証パスを計算するために使用されるF及びHへの呼び出しの数として与えられます。最後の列は、一つの鍵ペアで署名することができるメッセージの数を示します。数字は、同じパラメータhおよびnのXMSS振れインスタンスについて同じです。"
    },
    {
      "indent": 4,
      "text": "+------------------+-------+------------+--------+--------+-------+\n| Name             | |Sig| |     KeyGen |   Sign | Verify | #Sigs |\n+------------------+-------+------------+--------+--------+-------+\n| REQUIRED:        |       |            |        |        |       |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_10_256 | 2,500 |  1,238,016 |  5,725 |  1,149 |  2^10 |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_16_256 | 2,692 |    79*10^6 |  9,163 |  1,155 |  2^16 |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_20_256 | 2,820 | 1,268*10^6 | 11,455 |  1,159 |  2^20 |\n|                  |       |            |        |        |       |\n| OPTIONAL:        |       |            |        |        |       |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_10_512 | 9,092 |  2,417,664 | 11,165 |  2,237 |  2^10 |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_16_512 | 9,476 |   155*10^6 | 17,867 |  2,243 |  2^16 |\n|                  |       |            |        |        |       |\n| XMSS-SHA2_20_512 | 9,732 | 2,476*10^6 | 22,335 |  2,247 |  2^20 |\n+------------------+-------+------------+--------+--------+-------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 3,
      "text": "As a default, users without special requirements should use option XMSS-SHA2_20_256, which allows signing of 2^20 messages with one key pair and provides reasonable speed and signature size. Users that require more signatures per key pair or faster key generation should consider XMSS^MT.",
      "ja": "デフォルトとして、特別な要件を持たないユーザは、一つの鍵ペアで2 ^ 20メッセージの署名を可能にし、合理的な速度と署名サイズを提供するオプションXMSS-SHA2_20_256を使用する必要があります。鍵ペアまたはより高速な鍵生成あたりより多くの署名を必要とするユーザーがXMSS ^ MTを検討すべきです。"
    },
    {
      "indent": 0,
      "text": "5.4. XMSS^MT Parameters",
      "section_title": true,
      "ja": "5.4.  XMSS ^ MTパラメータ"
    },
    {
      "indent": 3,
      "text": "To fully describe an XMSS^MT signature method, the parameters n, w, h, and d, as well as the functions F, H, H_msg, and PRF, MUST be specified. The following table defines different XMSS^MT signature systems, each of which is identified by a name. Naming follows this convention: XMSSMT-[Hashfamily]_[h]/[d]_[n in bits]. Naming does not include w as all parameter sets in this document use w=16.",
      "ja": "完全XMSS ^ MT署名方法を説明するために、パラメータn、W、H、およびD、ならびに機能F、H、H_msg、およびPRFは、指定しなければなりません。以下の表は、名前によって識別されるそれぞれが異なるXMSS ^ MT署名システムを定義します。命名は、この規則に従う：XMSSMT- [Hashfamily] _ [H] / [D] _ [Nビットで]。命名は、16 = W、この文書の使用中のすべてのパラメータセットとしてwを含んでいません。"
    },
    {
      "indent": 5,
      "text": "+------------------------+-----------+----+----+-----+----+----+\n| Name                   | Functions |  n |  w | len |  h |  d |\n+------------------------+-----------+----+----+-----+----+----+\n| REQUIRED:              |           |    |    |     |    |    |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_20/2_256   | SHA2-256  | 32 | 16 |  67 | 20 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_20/4_256   | SHA2-256  | 32 | 16 |  67 | 20 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/2_256   | SHA2-256  | 32 | 16 |  67 | 40 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/4_256   | SHA2-256  | 32 | 16 |  67 | 40 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/8_256   | SHA2-256  | 32 | 16 |  67 | 40 |  8 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/3_256   | SHA2-256  | 32 | 16 |  67 | 60 |  3 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/6_256   | SHA2-256  | 32 | 16 |  67 | 60 |  6 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/12_256  | SHA2-256  | 32 | 16 |  67 | 60 | 12 |\n|                        |           |    |    |     |    |    |\n| OPTIONAL:              |           |    |    |     |    |    |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_20/2_512   | SHA2-512  | 64 | 16 | 131 | 20 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_20/4_512   | SHA2-512  | 64 | 16 | 131 | 20 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/2_512   | SHA2-512  | 64 | 16 | 131 | 40 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/4_512   | SHA2-512  | 64 | 16 | 131 | 40 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_40/8_512   | SHA2-512  | 64 | 16 | 131 | 40 |  8 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/3_512   | SHA2-512  | 64 | 16 | 131 | 60 |  3 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/6_512   | SHA2-512  | 64 | 16 | 131 | 60 |  6 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHA2_60/12_512  | SHA2-512  | 64 | 16 | 131 | 60 | 12 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_20/2_256  | SHAKE128  | 32 | 16 |  67 | 20 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_20/4_256  | SHAKE128  | 32 | 16 |  67 | 20 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/2_256  | SHAKE128  | 32 | 16 |  67 | 40 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/4_256  | SHAKE128  | 32 | 16 |  67 | 40 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/8_256  | SHAKE128  | 32 | 16 |  67 | 40 |  8 |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/3_256  | SHAKE128  | 32 | 16 |  67 | 60 |  3 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/6_256  | SHAKE128  | 32 | 16 |  67 | 60 |  6 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/12_256 | SHAKE128  | 32 | 16 |  67 | 60 | 12 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_20/2_512  | SHAKE256  | 64 | 16 | 131 | 20 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_20/4_512  | SHAKE256  | 64 | 16 | 131 | 20 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/2_512  | SHAKE256  | 64 | 16 | 131 | 40 |  2 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/4_512  | SHAKE256  | 64 | 16 | 131 | 40 |  4 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_40/8_512  | SHAKE256  | 64 | 16 | 131 | 40 |  8 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/3_512  | SHAKE256  | 64 | 16 | 131 | 60 |  3 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/6_512  | SHAKE256  | 64 | 16 | 131 | 60 |  6 |\n|                        |           |    |    |     |    |    |\n| XMSSMT-SHAKE_60/12_512 | SHAKE256  | 64 | 16 | 131 | 60 | 12 |\n+------------------------+-----------+----+----+-----+----+----+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 3,
      "text": "XDR formats for XMSS^MT are listed in Appendix C.",
      "ja": "XMSS ^ MTのためのXDR形式は付録Cに記載されています"
    },
    {
      "indent": 0,
      "text": "5.4.1. Parameter Guide",
      "section_title": true,
      "ja": "5.4.1. パラメーター・ガイド"
    },
    {
      "indent": 3,
      "text": "In addition to the tree height parameter already used for XMSS, XMSS^MT has the parameter d that determines the number of tree layers. XMSS can be understood as XMSS^MT with a single layer, i.e., d=1. Hence, the choice of h has the same effect as for XMSS. The number of tree layers provides a trade-off between signature size on the one side and key generation and signing speed on the other side. Increasing the number of layers reduces key generation time exponentially and signing time linearly at the cost of increasing the signature size linearly. Essentially, an XMSS^MT signature contains one WOTSP signature per layer. Speed roughly corresponds to d-times the speed for XMSS with trees of height h/d.",
      "ja": "すでにXMSSのために使用されるツリーの高さのパラメータに加えて、XMSS ^ MTは、ツリー層の数を決定するパラメータdを有します。 XMSSは、単層、すなわち、D = 1でXMSS ^ MTとして理解することができます。したがって、時間の選択はXMSSと同じ効果を有します。ツリー層の数は、他の側に署名片側のサイズと鍵生成および署名速度とのトレードオフを提供します。層の数を増やすと、指数関数鍵生成時間を短縮し、直線的に署名サイズを増加させるコストで直線的に時間に署名します。基本的に、XMSS ^ MTの署名は、層ごとに1人のWOTSP署名が含まれています。速度は、おおよそ高さh / Dの木とXMSSためのd倍の速度に相当します。"
    },
    {
      "indent": 3,
      "text": "To demonstrate the impact of different values of h and d, the following table shows signature size and runtimes. Runtimes are given as the number of calls to F and H when the BDS algorithm and distributed signature generation are used. Timings are worst-case times. The last column shows the number of messages that can be signed with one key pair. The numbers are the same for the XMSS-",
      "ja": "H及びDの異なる値の影響を実証するために、次の表は、署名のサイズと実行時間を示しています。ランタイムは、BDSアルゴリズムおよび分散署名生成を使用するF及びHへの呼び出しの数として与えられます。タイミングは最悪の場合の時間です。最後の列は、一つの鍵ペアで署名することができるメッセージの数を示します。数字はXMSS-も同じです"
    },
    {
      "indent": 3,
      "text": "SHAKE instances with same parameters h and n. Due to formatting limitations, only the parameter part of the parameter set names are given, omitting the name \"XMSSMT\".",
      "ja": "同じパラメータhおよびnのインスタンスを振ります。制限をフォーマットするには、パラメータセット名の唯一のパラメータの一部は、名称「XMSSMT」を省略すること、与えられています。"
    },
    {
      "indent": 4,
      "text": "+----------------+---------+------------+--------+--------+-------+\n| Name           |   |Sig| |     KeyGen |   Sign | Verify | #Sigs |\n+----------------+---------+------------+--------+--------+-------+\n| REQUIRED:      |         |            |        |        |       |\n|                |         |            |        |        |       |\n| SHA2_20/2_256  |   4,963 |  2,476,032 |  7,227 |  2,298 |  2^20 |\n|                |         |            |        |        |       |\n| SHA2_20/4_256  |   9,251 |    154,752 |  4,170 |  4,576 |  2^20 |\n|                |         |            |        |        |       |\n| SHA2_40/2_256  |   5,605 | 2,535*10^6 | 13,417 |  2,318 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_40/4_256  |   9,893 |  4,952,064 |  7,227 |  4,596 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_40/8_256  |  18,469 |    309,504 |  4,170 |  9,152 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_60/3_256  |   8,392 | 3,803*10^6 | 13,417 |  3,477 |  2^60 |\n|                |         |            |        |        |       |\n| SHA2_60/6_256  |  14,824 |  7,428,096 |  7,227 |  6,894 |  2^60 |\n|                |         |            |        |        |       |\n| SHA2_60/12_256 |  27,688 |    464,256 |  4,170 | 13,728 |  2^60 |\n|                |         |            |        |        |       |\n| OPTIONAL:      |         |            |        |        |       |\n|                |         |            |        |        |       |\n| SHA2_20/2_512  |  18,115 |  4,835,328 | 14,075 |  4,474 |  2^20 |\n|                |         |            |        |        |       |\n| SHA2_20/4_512  |  34,883 |    302,208 |  8,138 |  8,928 |  2^20 |\n|                |         |            |        |        |       |\n| SHA2_40/2_512  |  19,397 | 4,951*10^6 | 26,025 |  4,494 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_40/4_512  |  36,165 |  9,670,656 | 14,075 |  8,948 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_40/8_512  |  69,701 |    604,416 |  8,138 | 17,856 |  2^40 |\n|                |         |            |        |        |       |\n| SHA2_60/3_512  |  29,064 | 7,427*10^6 | 26,025 |  6,741 |  2^60 |\n|                |         |            |        |        |       |\n| SHA2_60/6_512  |  54,216 | 14,505,984 | 14,075 | 13,422 |  2^60 |\n|                |         |            |        |        |       |\n| SHA2_60/12_512 | 104,520 |    906,624 |  8,138 | 26,784 |  2^60 |\n+----------------+---------+------------+--------+--------+-------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 5",
      "ja": "表5"
    },
    {
      "indent": 3,
      "text": "As a default, users without special requirements should use option XMSSMT-SHA2_60/3_256, which allows signing of 2^60 messages with one key pair (this is a virtually unbounded number of signatures). At the same time, signature size and speed are well balanced.",
      "ja": "デフォルトでは、特別な要件を持たないユーザが一つのキーのペアと2 ^ 60のメッセージ（これは署名の事実上無制限の数である）の署名を可能にするオプションXMSSMT-SHA2_60 / 3_256を、使用する必要があります。同時に、署名のサイズと速度のバランスです。"
    },
    {
      "indent": 0,
      "text": "6. Rationale",
      "section_title": true,
      "ja": "6.理由"
    },
    {
      "indent": 3,
      "text": "The goal of this note is to describe the WOTS+, XMSS, and XMSS^MT algorithms based on the scientific literature. The description is done in a modular way that allows basing a description of stateless hash-based signature algorithms like SPHINCS [BHH15] on it.",
      "ja": "このノートの目標は、科学文献に基づいてWOTS +、XMSS、およびXMSS ^ MTアルゴリズムを記述することです。説明は、その上にSPHINCS [BHH15]のようなステートレスハッシュベースの署名アルゴリズムの記述を基づか可能モジュラー方法で行われます。"
    },
    {
      "indent": 3,
      "text": "This note slightly deviates from the scientific literature by using a tweak that prevents multi-user and multi-target attacks against H_msg. To this end, the public key as well as the index of the used one-time key pair become part of the hash function key. Thereby, we achieve a domain separation that forces an attacker to decide which hash value to attack.",
      "ja": "このノートはわずかH_msgに対するマルチユーザ、マルチターゲットの攻撃を防ぐ微調整を使用することにより、科学文献から外れます。このためには、公開鍵だけでなく、使用のワンタイムキーのペアのインデックスは、ハッシュ関数のキーの一部となります。これにより、我々は攻撃するためにどのハッシュ値を決定するために、攻撃者が強制的にドメイン分離を実現します。"
    },
    {
      "indent": 3,
      "text": "For the generation of the randomness used for randomized message hashing, we apply a PRF, keyed with a secret value, to the index of the used one-time key pair instead of the message. The reason is that this requires processing the message only once instead of twice. For long messages, this improves speed and simplifies implementations on resource-constrained devices that cannot hold the entire message in storage.",
      "ja": "ランダム化されたメッセージのハッシュに使用する乱数の生成のために、我々は、使用のワンタイムキーのペアの代わりに、メッセージのインデックスに、秘密の値とキーPRFを、適用します。その理由は、これは一度だけの代わりに、二度のメッセージを処理する必要があることです。長いメッセージの場合、これは、速度が向上し、記憶装置にメッセージ全体を保持できないリソースに制約のあるデバイス上での実装を簡素化します。"
    },
    {
      "indent": 3,
      "text": "We give one mandatory set of parameters using SHA2-256. The reasons are twofold. On the one hand, SHA2-256 is part of most cryptographic libraries. On the other hand, a 256-bit hash function leads to parameters that provide 128 bits of security even against quantum-computer-aided attacks. A post-quantum security level of 256 bits seems overly conservative. However, to prepare for possible cryptanalytic breakthroughs, we also provide OPTIONAL parameter sets using the less widely supported SHA2-512, SHAKE-256, and SHAKE-512 functions.",
      "ja": "私たちは、SHA2-256を使用してパラメータの1つの必須のセットを与えます。理由は2つあります。一方で、SHA2-256は、ほとんどの暗号化ライブラリの一部です。一方、256ビットのハッシュ関数であっても、量子コンピュータ支援攻撃に対するセキュリティの128ビットを与えるパラメータにつながります。 256ビットのポスト量子セキュリティレベルは過度に保守的と思われます。しかしながら、可能な暗号解読ブレークスルーのために準備するために、我々はまた、あまり広くサポートSHA2-512、SHAKE-256、およびSHAKE-512関数を使用してオプションのパラメータセットを提供します。"
    },
    {
      "indent": 3,
      "text": "We suggest the value w = 16 for the Winternitz parameter. No bigger values are included since the decrease in signature size then becomes less significant. Furthermore, the value w = 16 considerably simplifies the implementations of some of the algorithms. Please note that we do allow w = 4 but limit the specified parameter sets to w = 16 for efficiency reasons.",
      "ja": "私たちは、WinternitzパラメータのW値= 16を示唆しています。署名の大きさの減少が少ないし、顕著になるので、ノー大きな値が含まれています。また、16 = W値はかなりのアルゴリズムのいくつかの実装を簡素化します。私たちは4 = wを許すが、効率上の理由から16 =ワットに指定されたパラメータセットを限定しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The signature and public key formats are designed so that they are easy to parse. Each format starts with a 32-bit enumeration value that indicates all of the details of the signature algorithm and hence defines all of the information that is needed in order to parse the format.",
      "ja": "彼らが解析しやすいように、署名と公開鍵のフォーマットが設計されています。各フォーマットは、署名アルゴリズムの詳細のすべてを示し、従って、フォーマットを構文解析するために必要な情報の全てを定義する32ビットの列挙値で始まります。"
    },
    {
      "indent": 0,
      "text": "7. Reference Code",
      "section_title": true,
      "ja": "7.参照コード"
    },
    {
      "indent": 3,
      "text": "For testing purposes, a reference implementation in C is available. The code contains a basic implementation that closely follows the pseudocode in this document and an optimized implementation that uses the BDS algorithm [BDS08] to compute authentication paths and distributed signature generation as described in [HRB13] for XMSS^MT.",
      "ja": "テスト目的のために、Cの参照実装が利用可能です。コードは、密接にこのドキュメントとXMSS ^ MTのために[HRB13]に記載されているように、認証パスと分散署名生成を計算する[BDS08] BDSアルゴリズムを使用して最適化された実装の擬似コードを以下の基本的な実装を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The code is permanently available at <https://github.com/joostrijneveld/xmss-reference>.",
      "ja": "コードは<https://github.com/joostrijneveld/xmss-reference>で永続的に利用可能です。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Internet Assigned Numbers Authority (IANA) has created three registries: one for WOTS+ signatures (as defined in Section 3), one for XMSS signatures (as defined in Section 4), and one for XMSS^MT signatures (as defined in Section 4). For the sake of clarity and convenience, the first collection of WOTS+, XMSS, and XMSS^MT parameter sets is defined in Section 5. Additions to these registries require that a specification be documented in an RFC or another permanent and readily available reference in sufficient detail as defined by the \"Specification Required\" policy described in [RFC8126] to make interoperability between independent implementations possible. Each entry in these registries contains the following elements:",
      "ja": "（セクション3で定義されるように）WOTS +署名のための1つ、セクション4で定義されるように（セクション4で定義されるように）XMSS署名のための1つ、およびXMSS ^ MT署名のための1つの（インターネット割り当て番号機関（IANA）は、3つのレジストリを作成しています）。明確化および便宜のために、WOTS +、XMSS、及びXMSS ^ MTパラメータセットの最初のコレクションがセクションで定義され、これらのレジストリに5.追加の仕様がRFCまたは十分に別の永久的で容易に入手可能な文献に文書化されることを必要と[RFC8126]に記載されている「仕様必須」ポリシーによって定義された詳細は、独立した実装の間の相互運用性を可能にします。これらのレジストリの各エントリには、次の要素が含まれます。"
    },
    {
      "indent": 3,
      "text": "o a short name, such as \"XMSS_SHA2_20_256\",",
      "ja": "O短い名前は、そのような「XMSS_SHA2_20_256」として、"
    },
    {
      "indent": 3,
      "text": "o a positive number, and",
      "ja": "O正の数、および"
    },
    {
      "indent": 3,
      "text": "o a reference to a specification that completely defines the signature method test cases or provides a reference implementation that can be used to verify the correctness of an implementation (or a reference to such an implementation).",
      "ja": "O完全署名方式のテストケースを定義または実装の正しさ（又はこのような実装を参照）を確認するために使用することができるリファレンス実装を提供する仕様を参照します。"
    },
    {
      "indent": 3,
      "text": "Requests to add an entry to these registries MUST include the name and the reference. The number is assigned by IANA. These number assignments SHOULD use the smallest available positive number. Submitters MUST have their requests reviewed and approved. Designated Experts for this task as requested by the \"Specification Required\" policy defined by [RFC8126] will be assigned by the",
      "ja": "これらのレジストリにエントリを追加するための要求は、名前や参照を含まなければなりません。番号は、IANAによって割り当てられます。これらの番号の割り当ては、利用可能な最小の正の数を使用すべきです。提出者は、彼らの要求を審査し、承認を受ける必要があります。 [RFC8126]で定義された「仕様が必要である」というポリシーによって要求されるように、このタスクのために指定された専門家がによって割り当てられます"
    },
    {
      "indent": 3,
      "text": "Internet Engineering Steering Group (IESG). The IESG can be contacted at iesg@ietf.org. Interested applicants that are unfamiliar with IANA processes should visit <http://www.iana.org>.",
      "ja": "インターネットエンジニアリング運営グループ（IESG）。 IESGはiesg@ietf.orgで接触させることができます。 IANAプロセスに慣れていない興味応募は<http://www.iana.org>を訪問するべきです。"
    },
    {
      "indent": 3,
      "text": "The number 0x00000000 (decimal 0) is Reserved. The numbers between 0xDDDDDDDD (decimal 3,722,304,989) and 0xFFFFFFFF (decimal 4,294,967,295) inclusive will not be assigned by IANA and are Reserved for Private Use; no attempt will be made to prevent multiple sites from using the same value in different (and incompatible) ways [RFC8126].",
      "ja": "番号0x00000000の（十進数0）が予約されています。 0xDDDDDDDD間の数字（3722304989小数）とは0xFFFFFFFF（小数4294967295）IANAによって割り当てられず、私的使用のために予約されている包括的。試みは、異なる（および互換性のない）方法[RFC8126]に同じ値を使用することから、複数のサイトを防ぐために行われません。"
    },
    {
      "indent": 3,
      "text": "The \"WOTS+ Signatures\" registry is as follows.",
      "ja": "以下のように「WOTS +署名」レジストリがあります。"
    },
    {
      "indent": 10,
      "text": "+--------------------+-----------------+-------------+\n| Numeric Identifier | Name            |  Reference  |\n+--------------------+-----------------+-------------+\n|     0x00000000     | Reserved        |   this RFC  |\n|                    |                 |             |\n|     0x00000001     | WOTSP-SHA2_256  | Section 5.2 |\n|                    |                 |             |\n|     0x00000002     | WOTSP-SHA2_512  | Section 5.2 |\n|                    |                 |             |\n|     0x00000003     | WOTSP-SHAKE_256 | Section 5.2 |\n|                    |                 |             |\n|     0x00000004     | WOTSP-SHAKE_512 | Section 5.2 |\n+--------------------+-----------------+-------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 6",
      "ja": "表6"
    },
    {
      "indent": 3,
      "text": "The \"XMSS Signatures\" registry is as follows.",
      "ja": "以下のように「XMSS署名」レジストリがあります。"
    },
    {
      "indent": 9,
      "text": "+--------------------+-------------------+-------------+\n| Numeric Identifier | Name              |  Reference  |\n+--------------------+-------------------+-------------+\n|     0x00000000     | Reserved          |   this RFC  |\n|                    |                   |             |\n|     0x00000001     | XMSS-SHA2_10_256  | Section 5.3 |\n|                    |                   |             |\n|     0x00000002     | XMSS-SHA2_16_256  | Section 5.3 |\n|                    |                   |             |\n|     0x00000003     | XMSS-SHA2_20_256  | Section 5.3 |\n|                    |                   |             |\n|     0x00000004     | XMSS-SHA2_10_512  | Section 5.3 |\n|                    |                   |             |\n|     0x00000005     | XMSS-SHA2_16_512  | Section 5.3 |\n|                    |                   |             |\n|     0x00000006     | XMSS-SHA2_20_512  | Section 5.3 |\n|                    |                   |             |\n|     0x00000007     | XMSS-SHAKE_10_256 | Section 5.3 |\n|                    |                   |             |\n|     0x00000008     | XMSS-SHAKE_16_256 | Section 5.3 |\n|                    |                   |             |\n|     0x00000009     | XMSS-SHAKE_20_256 | Section 5.3 |\n|                    |                   |             |\n|     0x0000000A     | XMSS-SHAKE_10_512 | Section 5.3 |\n|                    |                   |             |\n|     0x0000000B     | XMSS-SHAKE_16_512 | Section 5.3 |\n|                    |                   |             |\n|     0x0000000C     | XMSS-SHAKE_20_512 | Section 5.3 |\n+--------------------+-------------------+-------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 7",
      "ja": "表7"
    },
    {
      "indent": 3,
      "text": "The \"XMSS^MT Signatures\" registry is as follows.",
      "ja": "以下のように「XMSS ^ MT署名」レジストリがあります。"
    },
    {
      "indent": 7,
      "text": "+--------------------+------------------------+-------------+\n| Numeric Identifier | Name                   |  Reference  |\n+--------------------+------------------------+-------------+\n|     0x00000000     | Reserved               |   this RFC  |\n|                    |                        |             |\n|     0x00000001     | XMSSMT-SHA2_20/2_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000002     | XMSSMT-SHA2_20/4_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000003     | XMSSMT-SHA2_40/2_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000004     | XMSSMT-SHA2_40/4_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000005     | XMSSMT-SHA2_40/8_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000006     | XMSSMT-SHA2_60/3_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000007     | XMSSMT-SHA2_60/6_256   | Section 5.4 |\n|                    |                        |             |\n|     0x00000008     | XMSSMT-SHA2_60/12_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000009     | XMSSMT-SHA2_20/2_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000A     | XMSSMT-SHA2_20/4_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000B     | XMSSMT-SHA2_40/2_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000C     | XMSSMT-SHA2_40/4_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000D     | XMSSMT-SHA2_40/8_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000E     | XMSSMT-SHA2_60/3_512   | Section 5.4 |\n|                    |                        |             |\n|     0x0000000F     | XMSSMT-SHA2_60/6_512   | Section 5.4 |\n|                    |                        |             |\n|     0x00000010     | XMSSMT-SHA2_60/12_512  | Section 5.4 |\n|                    |                        |             |\n|     0x00000011     | XMSSMT-SHAKE_20/2_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000012     | XMSSMT-SHAKE_20/4_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000013     | XMSSMT-SHAKE_40/2_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000014     | XMSSMT-SHAKE_40/4_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000015     | XMSSMT-SHAKE_40/8_256  | Section 5.4 |",
      "raw": true
    },
    {
      "indent": 7,
      "text": "|                    |                        |             |\n|     0x00000016     | XMSSMT-SHAKE_60/3_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000017     | XMSSMT-SHAKE_60/6_256  | Section 5.4 |\n|                    |                        |             |\n|     0x00000018     | XMSSMT-SHAKE_60/12_256 | Section 5.4 |\n|                    |                        |             |\n|     0x00000019     | XMSSMT-SHAKE_20/2_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001A     | XMSSMT-SHAKE_20/4_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001B     | XMSSMT-SHAKE_40/2_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001C     | XMSSMT-SHAKE_40/4_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001D     | XMSSMT-SHAKE_40/8_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001E     | XMSSMT-SHAKE_60/3_512  | Section 5.4 |\n|                    |                        |             |\n|     0x0000001F     | XMSSMT-SHAKE_60/6_512  | Section 5.4 |\n|                    |                        |             |\n|     0x00000020     | XMSSMT-SHAKE_60/12_512 | Section 5.4 |\n+--------------------+------------------------+-------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 8",
      "ja": "表8"
    },
    {
      "indent": 3,
      "text": "An IANA registration of a signature system does not constitute an endorsement of that system or its security.",
      "ja": "署名システムのIANA登録は、そのシステムまたはセキュリティの承認を構成するものではありません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "A signature system is considered secure if it prevents an attacker from forging a valid signature. More specifically, consider a setting in which an attacker gets a public key and can learn signatures on arbitrary messages of its choice. A signature system is secure if, even in this setting, the attacker cannot produce a new message/signature pair of his choosing such that the verification algorithm accepts.",
      "ja": "それは有効な署名を偽造からの攻撃者ができない場合、署名システムは安全であると考えられ。具体的には、攻撃者が公開鍵を取得し、その選択した任意のメッセージに署名を学ぶことが可能な設定を検討してください。でもこの設定では、攻撃者が検証アルゴリズムを受け入れるように彼の選択した新しいメッセージ/署名のペアを生成することができない、場合署名システムは安全です。"
    },
    {
      "indent": 3,
      "text": "Preventing an attacker from mounting an attack means that the attack is computationally too expensive to be carried out. There are various estimates for when a computation is too expensive to be done. For that reason, this note only describes how expensive it is for an attacker to generate a forgery. Parameters are accompanied by a bit security value. The meaning of bit security is as follows. A parameter set grants b bits of security if the best attack takes at least 2^(b - 1) bit operations to achieve a success probability of",
      "ja": "攻撃を仕掛ける攻撃者を防止することは、攻撃が、計算が行われるには余りにも高価であることを意味しています。計算が行われるにはあまりにも高価であるときのためのさまざまな推計があります。そのため、このノートは、攻撃者が偽造を生成するためにそれがどのように高価説明します。パラメータはビットのセキュリティ値を伴っています。次のようにビットのセキュリティの意味があります。パラメータセットは、助成金、セキュリティのビットbを最高の攻撃が少なくとも2 ^（B  -  1）かかる場合の成功確率を達成するためにビット演算を"
    },
    {
      "indent": 3,
      "text": "1/2. Hence, to mount a successful attack, an attacker needs to perform 2^b bit operations on average. The given values for bit security were estimated according to [HRS16].",
      "ja": "1/2。したがって、成功した攻撃をマウントするには、攻撃者は、平均して2 ^ Bビット操作を実行する必要があります。ビットセキュリティの与えられた値は、[HRS16]に従って評価しました。"
    },
    {
      "indent": 0,
      "text": "9.1. Security Proofs",
      "section_title": true,
      "ja": "9.1. セキュリティ証明"
    },
    {
      "indent": 3,
      "text": "A full security proof for all schemes described in this document can be found in [HRS16]. This proof shows that an attacker has to break at least one out of certain security properties of the used hash functions and PRFs to forge a signature in any of the described schemes. The proof in [HRS16] considers an initial message compression different from the randomized hashing used here. We comment on this below. For the original schemes, these proofs show that an attacker has to break certain minimal security properties. In particular, it is not sufficient to break the collision resistance of the hash functions to generate a forgery.",
      "ja": "この文書に記載されているすべてのスキームのための完全なセキュリティ証明は[HRS16]で見つけることができます。この証拠は、攻撃者が説明したスキームのいずれかに署名を偽造するために使用されるハッシュ関数とのPRFの特定のセキュリティ特性のうち少なくとも一つを破壊しなければならないことを示しています。 【HRS16]で証明がここで使用されるランダム化ハッシュは異なる初期メッセージ圧縮を考慮する。私たちは、この以下にコメント。元のスキームのために、これらの証明は、攻撃者が特定の最低限のセキュリティプロパティを破るために持っていることを示しています。特に、偽造を生成するハッシュ関数の衝突困難性を破るのに十分ではありません。"
    },
    {
      "indent": 3,
      "text": "More specifically, the requirements on the used functions are that F and H are post-quantum multi-function multi-target second-preimage resistant keyed functions, F fulfills an additional statistical requirement that roughly says that most images have at least two preimages, PRF is a post-quantum pseudorandom function, and H_msg is a post-quantum multi-target extended target collision-resistant keyed hash function. For detailed definitions of these properties see [HRS16]. To give some intuition: multi-function multi-target second-preimage resistance is an extension of second-preimage resistance to keyed hash functions, covering the case where an adversary succeeds if it finds a second preimage for one out of many values. The same holds for multi-target extended target collision resistance, which just lacks the multi-function identifier as target collision resistance already considers keyed hash functions. The proof in [HRS16] splits PRF into two functions. When PRF is used for pseudorandom key generation or generation of randomness for randomized message hashing, it is still considered a pseudorandom function. Whenever PRF is used to generate bitmasks and hash function keys, it is modeled as a random oracle. This is due to technical reasons in the proof, and an implementation using a pseudorandom function is secure.",
      "ja": "より具体的には、使用する機能に関する要件は、F及びHは、ポスト量子多機能多標的二プリイメージ耐性キー付き関数であることであり、Fは概ねほとんどの画像は、少なくとも2つのpreimagesを持っていることを述べている追加の統計的要件を満たす、PRFポスト量子擬似ランダム関数であり、そしてH_msgポスト量子マルチターゲット拡張ターゲット衝突耐性鍵付きハッシュ関数です。これらのプロパティの詳細な定義については、[HRS16]を参照してください。いくつかの直感与える：多機能多標的二プレイメージ抵抗することは、多くの値のうちの一方のための第二プレイメージが見つかった場合敵が成功した場合をカバーする、鍵付きハッシュ関数への第二プリイメージ耐性の拡張です。同じことが、ちょうど目標衝突耐性が既に鍵付きハッシュ関数を考慮したとして多機能識別子を欠くマルチターゲット拡張ターゲット衝突耐性、当てはまります。 【HRS16]で証明は、2つの機能にPRFを分割します。 PRFは、疑似ランダムキー生成又は無作為のメッセージハッシュのための乱数の生成に使用されるとき、それはまだ擬似ランダム関数であると考えられます。 PRFは、ビットマスクとハッシュ関数のキーを生成するために使用されるたびに、それがランダムオラクルとしてモデル化されます。これが証拠で技術的な理由によるもので、擬似ランダム関数を使用して実装が安全です。"
    },
    {
      "indent": 3,
      "text": "The proof in [HRS16] considers classical randomized hashing for the initial message compression, i.e., H(r, M) instead of H(r || getRoot(PK) || index, M). This classical randomized hashing allows getting a security reduction from extended target collision resistance [HRS16], a property that is conjectured to be strictly weaker than collision resistance. However, it turns out that in this case, an attacker could still launch a multi-target attack even against multiple users at the same time. The reason is that the adversary attacking u users at the same time learns u * 2^h randomized hashes H(r_i_j || M_i_j) with signature index i in [0, 2^h - 1] and user index j in [0, u]. It suffices to find a single pair (r*, M*) such that H(r* || M*) = H(r_i_u || M_i_u) for one out of the u * 2^h learned hashes. Hence, an attacker can do a brute-force search in time 2^n / u * 2^h instead of 2^n.",
      "ja": "【HRS16]で証明代わりにH（R || getRoot（PK）||インデックス、M）の初期メッセージ圧縮のための古典的なランダム化ハッシュ、すなわち、H（R、M）を考慮する。この古典無作為化ハッシュは、拡張されたターゲット衝突困難性からセキュリティの削減[HRS16]、衝突抵抗より厳密に弱いことを推測されるプロパティを取得することができます。しかし、それはこの場合には、攻撃者はまだ、同時に複数のユーザーに対しても、マルチターゲット攻撃を仕掛けることができることが判明しました。そして、0 [におけるユーザインデックスj  - 理由は、同時にUユーザを攻撃する敵は、U iが[1 0、2 ^ H]で署名インデックスに2 ^ Hランダム化ハッシュH（r_i_j || M_i_jを）*学習することですU]。これは、H（rは* || M *）= H Uのうちのいずれかの（r_i_u || M_i_u）* 2 ^ Hはハッシュを学習したように、単一のペア（式中、R *、M *）を検索すればよいです。したがって、攻撃者は、代わりに2 ^ n個の時間2 ^ N / U * 2 ^ Hで力まかせ探索を行うことができます。"
    },
    {
      "indent": 3,
      "text": "The indexed randomized hashing H(r || getRoot(PK) || toByte(idx, n), M) used in this work makes the hash function calls position- and user-dependent. This thwarts the above attack because each hash function evaluation during an attack can only target one of the learned randomized hash values. More specifically, an attacker now has to decide which index idx and which root value to use for each query. If one assumes that the used hash function is a random function, it can be shown that a multi-user existential forgery attack that targets this message compression has a complexity of 2^n hash function calls.",
      "ja": "この研究で使用索引付けランダム化ハッシュH（R || getRoot（PK）|| toByte（IDX、N）、M）は、ハッシュ関数は、位置 - およびユーザ依存の呼び出しを行います。攻撃時の各ハッシュ関数の評価だけ学んだ無作為化、ハッシュ値のいずれかをターゲットにすることができますので、これは上記の攻撃を阻止し。具体的には、攻撃者は現在、各クエリに使用するインデックスIDXとルート値を決定する必要があります。一方が使用されるハッシュ関数はランダム関数であると仮定した場合、このメッセージの圧縮を標的マルチユーザ実存偽造攻撃は、2 ^ n個のハッシュ関数呼び出しの複雑さを有することを示すことができます。"
    },
    {
      "indent": 3,
      "text": "The given bit security values were estimated based on the complexity of the best-known generic attacks against the required security properties of the used hash and pseudorandom functions, assuming conventional and quantum adversaries. At the time of writing, generic attacks are the best-known attacks for the parameters suggested in the classical setting. Also, in the quantum setting, there are no dedicated attacks known that perform better than generic attacks. Nevertheless, the topic of quantum cryptanalysis of hash functions is not as well understood as in the classical setting.",
      "ja": "所与のビットセキュリティ値は、従来の量子敵を想定し、使用するハッシュと擬似ランダム関数の必要なセキュリティ特性に対して最もよく知られている一般的な攻撃の複雑さに基づいて推定しました。執筆時点では、一般的な攻撃は、古典的な設定で提案パラメータのための最もよく知られた攻撃です。また、量子設定では、一般的な攻撃よりも良好に機能知ら専用の攻撃はありません。それにも関わらず、ハッシュ関数の量子暗号解読の話題は、同様に、古典的な設定であると理解されていません。"
    },
    {
      "indent": 0,
      "text": "9.2. Minimal Security Assumptions",
      "section_title": true,
      "ja": "9.2. 最小限のセキュリティの仮定"
    },
    {
      "indent": 3,
      "text": "The assumptions one has to make to prove security of the described schemes are minimal in the following sense. Any signature algorithm that allows arbitrary size messages relies on the security of a cryptographic hash function, either on collision resistance or on extended target collision resistance if randomized hashing is used for message compression. For the schemes described here, this is already sufficient to be secure. In contrast, common signature schemes like RSA, DSA, and Elliptic Curve Digital Signature Algorithm (ECDSA) additionally rely on the conjectured hardness of certain mathematical problems.",
      "ja": "1を説明スキームの安全性を証明するために作るために持っている仮定は、以下の意味で最小限です。任意のサイズのメッセージを可能にする任意の署名アルゴリズムは、衝突耐性またはランダム化ハッシュは、メッセージ圧縮のために使用される場合、拡張ターゲット衝突抵抗のいずれか、暗号ハッシュ関数の安全性に依存しています。ここで説明するスキームについては、これはすでに安全であるのに十分です。対照的に、RSA、DSA、および楕円曲線デジタル署名アルゴリズム（ECDSA）などの一般的な署名方式は、さらに、特定の数学の問題の推測さ硬度に依存しています。"
    },
    {
      "indent": 0,
      "text": "9.3. Post-Quantum Security",
      "section_title": true,
      "ja": "9.3. ポスト量子セキュリティ"
    },
    {
      "indent": 3,
      "text": "A post-quantum cryptosystem is a system that is secure against attackers with access to a reasonably sized quantum computer. At the time of writing this note, whether or not it is feasible to build such a machine is an open conjecture. However, significant progress was made over the last few years in this regard. Hence, we consider it a matter of risk assessment to prepare for this case.",
      "ja": "ポスト量子暗号システムは、適度なサイズの量子コンピュータへのアクセス権を持つ攻撃者に対して安全であるシステムです。このようなマシンを構築することが可能であるかどうかにかかわらず、このノートを書いている時点でオープン推測です。しかし、重要な進歩は、この点では、過去数年にわたって行われました。したがって、我々はそれこの場合の準備のためのリスク評価の問題を検討してください。"
    },
    {
      "indent": 3,
      "text": "In contrast to RSA, DSA, and ECDSA, the described signature systems are post-quantum-secure if they are used with an appropriate cryptographic hash function. In particular, for post-quantum security, the size of n must be twice the size required for classical security. This is in order to protect against quantum square-root attacks due to Grover's algorithm. [HRS16] shows that variants of Grover's algorithm are the optimal generic attacks against the security properties of hash functions required for the described schemes.",
      "ja": "RSA、DSA、およびECDSAは対照的に、説明した署名システムは、ポスト量子セキュアそれらは適切な暗号ハッシュ関数で使用される場合です。特に、ポスト量子セキュリティのために、n個の大きさは、古典的なセキュリティのために必要な2倍のサイズでなければなりません。これは、グローバーのアルゴリズムによる量子平方根の攻撃から保護するためです。 [HRS16]グローバーのアルゴリズムの変種が説明スキームのために必要なハッシュ関数のセキュリティ特性に対して最適な汎用的な攻撃であることを示しています。"
    },
    {
      "indent": 3,
      "text": "As stated above, we only consider generic attacks here, as cryptographic hash functions should be deprecated as soon as dedicated attacks that perform significantly better exist. This also applies to the quantum setting. As soon as dedicated quantum attacks against the used hash function that can perform significantly better than the described generic attacks exist, these hash functions should not be used anymore for the described schemes, or the computation of the security level has to be redone.",
      "ja": "上述したように、暗号ハッシュ関数は、すぐに有意に良好が存在を行う専用の攻撃などの非推奨されるべきであるように、私たちは、ここでは一般的な攻撃を検討してください。また、これは、量子設定に適用されます。すぐに説明した一般的な攻撃が存在するよりも大幅にパフォーマンスが向上することができます使用されるハッシュ関数に対して、専用の量子攻撃など、これらのハッシュ関数を記述スキームのために、もはや使用すべきではない、またはセキュリティレベルの計算をやり直す必要があります。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS180] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, August 2015.",
      "ja": "[FIPS180]アメリカ国立標準技術研究所、 \"セキュアハッシュ規格（SHS）\"、FIPS PUB 180-4の、DOI 10.6028 / NIST.FIPS.180-4、2015年8月。"
    },
    {
      "indent": 3,
      "text": "[FIPS202] National Institute of Standards and Technology, \"SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions\", FIPS PUB 202, DOI 10.6028/NIST.FIPS.202, August 2015.",
      "ja": "[FIPS202]アメリカ国立標準技術研究所、 \"SHA-3標準：順列に基づいたハッシュおよび拡張可能-出力機能\"、FIPS PUBの202、DOI 10.6028 / NIST.FIPS.202、2015年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <https://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506]アイスラー、M.、エド、 \"XDR：外部データ表現標準\"。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<https://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BDH11] Buchmann, J., Dahmen, E., and A. Huelsing, \"XMSS - A Practical Forward Secure Signature Scheme Based on Minimal Security Assumptions\", Lecture Notes in Computer Science, Volume 7071, Post-Quantum Cryptography, DOI 10.1007/978-3-642-25405-5_8, 2011.",
      "ja": "[BDH11] Buchmann、J.、Dahmen、E.、およびA. Huelsing、 \"XMSS  - 最小限のセキュリティの仮定に基づいて実用的なフォワードセキュア署名方式\"、コンピュータサイエンスの講義ノート、ボリューム7071、ポスト量子暗号、DOI 10.1007 / 978-3-642-25405-5_8、2011。"
    },
    {
      "indent": 3,
      "text": "[BDS08] Buchmann, J., Dahmen, E., and M. Schneider, \"Merkle Tree Traversal Revisited\", Lecture Notes in Computer Science, Volume 5299, Post-Quantum Cryptography, DOI 10.1007/978-3-540-88403-3_5, 2008.",
      "ja": "【BDS08] Buchmann、J.、Dahmen、E.、およびM.シュナイダー、 \"マークル木トラバーサル再訪\"、コンピュータサイエンスの講義ノート、ボリューム5299、ポスト量子暗号、DOI 10.1007 / 978-3-540-88403- 3_5、2008。"
    },
    {
      "indent": 3,
      "text": "[BDS09] Buchmann, J., Dahmen, E., and M. Szydlo, \"Hash-based Digital Signature Schemes\", Book chapter, Post-Quantum Cryptography, DOI 10.1007/978-3-540-88702-7_3, 2009.",
      "ja": "【BDS09] Buchmann、J.、Dahmen、E.、およびM. Szydlo、 \"ハッシュベースのデジタル署名方式\"、書籍の章、ポスト量子暗号、DOI 10.1007 / 978-3-540-88702-7_3 2009。"
    },
    {
      "indent": 3,
      "text": "[BHH15] Bernstein, D., Hopwood, D., Huelsing, A., Lange, T., Niederhagen, R., Papachristodoulou, L., Schneider, M., Schwabe, P., and Z. Wilcox-O'Hearn, \"SPHINCS: Practical Stateless Hash-Based Signatures\", Lecture Notes in Computer Science, Volume 9056, Advances in Cryptology - EUROCRYPT, DOI 10.1007/978-3-662-46800-5_15, 2015.",
      "ja": "【BHH15】バーンスタイン、D.、ホップウッド、D.、Huelsing、A.、ランゲ、T.、Niederhagen、R.、Papachristodoulou、L.、シュナイダー、M.、シュワーベ、P.、およびZ.ウィルコックス-O」ハーン、： -  DOI 10.1007 / 978-3-662-46800-5_15、2015、EUROCRYPT \"SPHINCS実用ステートレスハッシュベースの署名\"、コンピュータサイエンス、ボリューム9056での講義ノートは、暗号学の進歩します。"
    },
    {
      "indent": 3,
      "text": "[HRB13] Huelsing, A., Rausch, L., and J. Buchmann, \"Optimal Parameters for XMSS^MT\", Lecture Notes in Computer Science, Volume 8128, CD-ARES, DOI 10.1007/978-3-642-40588-4_14, 2013.",
      "ja": "[HRB13] Huelsing、A.、ラウシュ、L.、およびJ. Buchmann、 \"最適なパラメータXMSS ^ MT用\"、コンピュータサイエンスの講義ノート、ボリューム8128、CD-ARES、DOI 10.1007 / 978-3-642-40588 -4_14、2013。"
    },
    {
      "indent": 3,
      "text": "[HRS16] Huelsing, A., Rijneveld, J., and F. Song, \"Mitigating Multi-Target Attacks in Hash-based Signatures\", Lecture Notes in Computer Science, Volume 9614, Public-Key Cryptography - PKC, DOI 10.1007/978-3-662-49384-7_15, 2016.",
      "ja": "[HRS16] Huelsing、A.、Rijneveld、J.、およびF.ソング、 \"ハッシュベースの署名で問題を緩和する要素マルチターゲット攻撃\"、コンピュータサイエンスの講義ノート、ボリューム9614、公開鍵暗号 -  PKC、DOI 10.1007 / 978-3-662-49384-7_15、2016。"
    },
    {
      "indent": 3,
      "text": "[Huelsing13] Huelsing, A., \"W-OTS+ - Shorter Signatures for Hash-Based Signature Schemes\", Lecture Notes in Computer Science, Volume 7918, Progress in Cryptology - AFRICACRYPT, DOI 10.1007/978-3-642-38553-7_10, 2013.",
      "ja": "【Huelsing13] Huelsing、A.、 \"W-OTS +  - ハッシュベースの署名スキームの短い署名\"、コンピュータサイエンスの講義ノート、ボリューム7918、進行暗号理論における -  AFRICACRYPT、DOI 10.1007 / 978-3-642-38553-7_10 2013年。"
    },
    {
      "indent": 3,
      "text": "[Huelsing13a] Huelsing, A., \"Practical Forward Secure Signatures using Minimal Security Assumptions\", PhD thesis TU Darmstadt, 2013, <http://tuprints.ulb.tu-darmstadt.de/3651/1/Thesis.pdf>.",
      "ja": "[Huelsing13a] Huelsing、A.、博士論文TUダルムシュタット、2013年、<http://tuprints.ulb.tu-darmstadt.de/3651/1/Thesis.pdf> \"最小限のセキュリティ前提条件を使用して実用的なフォワードセキュア署名\"。"
    },
    {
      "indent": 3,
      "text": "[KMN14] Knecht, M., Meier, W., and C. Nicola, \"A space- and time-efficient Implementation of the Merkle Tree Traversal Algorithm\", Computing Research Repository (CoRR), arXiv:1409.4081, 2014.",
      "ja": "【KMN14]クネヒト、M.、マイヤー、W.、及びC.ニコラ、「マークル木トラバーサルアルゴリズムの省スペース及び時間効率的な実装」、コンピューティングリサーチリポジトリ（CORR）、arXivの：1409.4081 2014年。"
    },
    {
      "indent": 3,
      "text": "[MCF18] McGrew, D., Curcio, M., and S. Fluhrer, \"Hash-Based Signatures\", Work in Progress, draft-mcgrew-hash-sigs-11, April 2018.",
      "ja": "【MCF18]マグリュー、D.、Curcio、M.、およびS. Fluhrer、 \"ハッシュベースの署名\"、進行中で働いて、ドラフトマグリューハッシュSIGS-11、2018年4月。"
    },
    {
      "indent": 3,
      "text": "[Merkle83] Merkle, R., \"Secrecy, Authentication, and Public Key Systems\", Computer Science Series, UMI Research Press, ISBN: 9780835713849, 1983.",
      "ja": "[Merkle83]マークル、R.、 \"プライバシー、認証、および公開鍵システム\"、コンピュータサイエンスシリーズ、UMIリサーチプレス、ISBN：9780835713849 1983年。"
    },
    {
      "indent": 0,
      "text": "Appendix A. WOTS+ XDR Formats",
      "ja": "付録A. WOTS + XDRフォーマット"
    },
    {
      "indent": 3,
      "text": "The WOTS+ signature and public key formats are formally defined using XDR [RFC4506] in order to provide an unambiguous, machine readable definition. Though XDR is used, these formats are simple and easy to parse without any special tools. Note that this representation includes all optional parameter sets. The same applies for the XMSS and XMSS^MT formats below.",
      "ja": "WOTS +署名と公開鍵の形式は、形式的に明白な、機械読み取り可能な定義を提供するために、XDR [RFC4506]を使用して定義されています。 XDRを用いているが、これらのフォーマットは、シンプルで特別な道具なしで解析するのは簡単です。この表現は、すべてのオプションのパラメータセットが含まれていることに注意してください。同じことは、以下のXMSSとXMSS ^ MT形式に適用されます。"
    },
    {
      "indent": 0,
      "text": "A.1. WOTS+ Parameter Sets",
      "ja": "A.1。 WOTS +パラメータセット"
    },
    {
      "indent": 3,
      "text": "WOTS+ parameter sets are defined using XDR syntax as follows:",
      "ja": "WOTS +パラメータセットは、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* ots_algorithm_type identifies a particular\n   signature algorithm */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum ots_algorithm_type { wotsp_reserved = 0x00000000, wotsp-sha2_256 = 0x00000001, wotsp-sha2_512 = 0x00000002, wotsp-shake_256 = 0x00000003, wotsp-shake_512 = 0x00000004, };",
      "ja": "列挙ots_algorithm_type {wotsp_reserved = 0x00000000の、wotsp-sha2_256 = 0x00000001に、wotsp-sha2_512 = 0x00000002、wotsp-shake_256 = 0x00000003、wotsp-shake_512 = 0x00000004、}。"
    },
    {
      "indent": 0,
      "text": "A.2. WOTS+ Signatures",
      "ja": "A.2。 WOTS +署名"
    },
    {
      "indent": 3,
      "text": "WOTS+ signatures are defined using XDR syntax as follows:",
      "ja": "WOTS +署名は次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Byte strings */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "typedef opaque bytestring32[32];\ntypedef opaque bytestring64[64];",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union ots_signature switch (ots_algorithm_type type) { case wotsp-sha2_256: case wotsp-shake_256: bytestring32 ots_sig_n32_len67[67];",
      "ja": "組合ots_signatureスイッチ（ots_algorithm_typeタイプ）{ケースwotsp-sha2_256：ケースwotsp-shake_256：bytestring32 ots_sig_n32_len67 [67]。"
    },
    {
      "indent": 8,
      "text": "case wotsp-sha2_512: case wotsp-shake_512: bytestring64 ots_sig_n64_len18[131];",
      "ja": "ケースwotsp-sha2_512：ケースwotsp-shake_512：bytestring64 ots_sig_n64_len18 [131]。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;   /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.3. WOTS+ Public Keys",
      "ja": "A.3。 WOTS +公開鍵"
    },
    {
      "indent": 3,
      "text": "WOTS+ public keys are defined using XDR syntax as follows:",
      "ja": "WOTS +公開鍵は、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "union ots_pubkey switch (ots_algorithm_type type) { case wotsp-sha2_256: case wotsp-shake_256: bytestring32 ots_pubk_n32_len67[67];",
      "ja": "組合ots_pubkeyスイッチ（ots_algorithm_typeタイプ）{ケースwotsp-sha2_256：ケースwotsp-shake_256：bytestring32 ots_pubk_n32_len67 [67]。"
    },
    {
      "indent": 8,
      "text": "case wotsp-sha2_512: case wotsp-shake_512: bytestring64 ots_pubk_n64_len18[131];",
      "ja": "ケースwotsp-sha2_512：ケースwotsp-shake_512：bytestring64 ots_pubk_n64_len18 [131]。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;   /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. XMSS XDR Formats",
      "ja": "付録B. XMSS XDRフォーマット"
    },
    {
      "indent": 0,
      "text": "B.1. XMSS Parameter Sets",
      "ja": "B.1。 XMSSパラメータセット"
    },
    {
      "indent": 3,
      "text": "XMSS parameter sets are defined using XDR syntax as follows:",
      "ja": "XMSSパラメータセットは、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Byte strings */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "typedef opaque bytestring4[4];",
      "ja": "typedefの不透明bytestring4 [4]。"
    },
    {
      "indent": 6,
      "text": "/* Definition of parameter sets */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum xmss_algorithm_type { xmss_reserved = 0x00000000,",
      "ja": "列挙xmss_algorithm_type {xmss_reserved = 0x00000000の、"
    },
    {
      "indent": 8,
      "text": "/* 256 bit classical security, 128 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmss-sha2_10_256 = 0x00000001, xmss-sha2_16_256 = 0x00000002, xmss-sha2_20_256 = 0x00000003,",
      "ja": "xmss-sha2_10_256 = 0猫00000001、xmss-sha2_16_256 = 0猫00000002、xmss-sha2_20_256 = 0猫00000003、"
    },
    {
      "indent": 8,
      "text": "/* 512 bit classical security, 256 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmss-sha2_10_512 = 0x00000004, xmss-sha2_16_512 = 0x00000005, xmss-sha2_20_512 = 0x00000006,",
      "ja": "xmss-sha2_10_512 = 0猫00000004、xmss-sha2_16_512 = 0猫00000005、xmss-sha2_20_512 = 0 00000006猫、"
    },
    {
      "indent": 8,
      "text": "/* 256 bit classical security, 128 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmss-shake_10_256 = 0x00000007, xmss-shake_16_256 = 0x00000008, xmss-shake_20_256 = 0x00000009,",
      "ja": "xmss-shake_10_256 = 0x00000007、xmss-shake_16_256 = 0x00000008、xmss-shake_20_256 = 0x00000009、"
    },
    {
      "indent": 8,
      "text": "/* 512 bit classical security, 256 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 6,
      "text": " xmss-shake_10_512 = 0x0000000A, xmss-shake_16_512 = 0x0000000B, xmss-shake_20_512 = 0x0000000C, };",
      "ja": "xmss-shake_10_512 = 0x0000000Aが、xmss-shake_16_512 = 0x0000000B、xmss-shake_20_512 = 0x0000000C、}。"
    },
    {
      "indent": 0,
      "text": "B.2. XMSS Signatures",
      "ja": "B.2。 XMSS署名"
    },
    {
      "indent": 3,
      "text": "XMSS signatures are defined using XDR syntax as follows:",
      "ja": "XMSS署名は、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Authentication path types */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union xmss_path switch (xmss_algorithm_type type) { case xmss-sha2_10_256: case xmss-shake_10_256: bytestring32 path_n32_t10[10];",
      "ja": "組合xmss_pathスイッチ（xmss_algorithm_type型）{ケースxmss-sha2_10_256：ケースxmss-shake_10_256：bytestring32 path_n32_t10 [10]。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_16_256: case xmss-shake_16_256: bytestring32 path_n32_t16[16];",
      "ja": "ケースxmss-sha2_16_256：ケースxmss-shake_16_256：bytestring32 path_n32_t16 [16]。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_20_256: case xmss-shake_20_256: bytestring32 path_n32_t20[20];",
      "ja": "ケースxmss-sha2_20_256：ケースxmss-shake_20_256：bytestring32 path_n32_t20 [20]。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_10_512: case xmss-shake_10_512: bytestring64 path_n64_t10[10];",
      "ja": "ケースxmss-sha2_10_512：ケースxmss-shake_10_512：bytestring64 path_n64_t10 [10]。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_16_512: case xmss-shake_16_512: bytestring64 path_n64_t16[16];",
      "ja": "ケースxmss-sha2_16_512：ケースxmss-shake_16_512：bytestring64 path_n64_t16 [16]。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_20_512: case xmss-shake_20_512: bytestring64 path_n64_t20[20];",
      "ja": "ケースxmss-sha2_20_512：ケースxmss-shake_20_512：bytestring64 path_n64_t20 [20]。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Types for XMSS random strings */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union random_string_xmss switch (xmss_algorithm_type type) { case xmss-sha2_10_256: case xmss-sha2_16_256: case xmss-sha2_20_256: case xmss-shake_10_256: case xmss-shake_16_256: case xmss-shake_20_256: bytestring32 rand_n32;",
      "ja": "組合random_string_xmssスイッチ（xmss_algorithm_type型）{ケースxmss-sha2_10_256：ケースxmss-sha2_16_256：ケースxmss-sha2_20_256：ケースxmss-shake_10_256：ケースxmss-shake_16_256：ケースxmss-shake_20_256：bytestring32 rand_n32。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_10_512: case xmss-sha2_16_512: case xmss-sha2_20_512: case xmss-shake_10_512: case xmss-shake_16_512: case xmss-shake_20_512: bytestring64 rand_n64;",
      "ja": "ケースxmss-sha2_10_512：ケースxmss-sha2_16_512：ケースxmss-sha2_20_512：ケースxmss-shake_10_512：ケースxmss-shake_16_512：ケースxmss-shake_20_512：bytestring64 rand_n64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Corresponding WOTS+ type for given XMSS type */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union xmss_ots_signature switch (xmss_algorithm_type type) { case xmss-sha2_10_256: case xmss-sha2_16_256: case xmss-sha2_20_256: wotsp-sha2_256;",
      "ja": "組合xmss_ots_signatureスイッチ（xmss_algorithm_type型）{ケースxmss-sha2_10_256：ケースxmss-sha2_16_256：ケースxmss-sha2_20_256：wotsp-sha2_256。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_10_512: case xmss-sha2_16_512: case xmss-sha2_20_512: wotsp-sha2_512;",
      "ja": "ケースxmss-sha2_10_512：ケースxmss-sha2_16_512：ケースxmss-sha2_20_512：wotsp-sha2_512。"
    },
    {
      "indent": 8,
      "text": "case xmss-shake_10_256: case xmss-shake_16_256: case xmss-shake_20_256: wotsp-shake_256;",
      "ja": "ケースxmss-shake_10_256：ケースxmss-shake_16_256：ケースxmss-shake_20_256：wotsp-shake_256。"
    },
    {
      "indent": 8,
      "text": "case xmss-shake_10_512: case xmss-shake_16_512: case xmss-shake_20_512: wotsp-shake_512;",
      "ja": "ケースxmss-shake_10_512：ケースxmss-shake_16_512：ケースxmss-shake_20_512：wotsp-shake_512。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* XMSS signature structure */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct xmss_signature {\n  /* WOTS+ key pair index */\n  bytestring4 idx_sig;\n  /* Random string for randomized hashing */\n  random_string_xmss rand_string;\n  /* WOTS+ signature */\n  xmss_ots_signature sig_ots;\n  /* authentication path */\n  xmss_path nodes;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B.3. XMSS Public Keys",
      "ja": "B.3。 XMSS公開鍵"
    },
    {
      "indent": 3,
      "text": "XMSS public keys are defined using XDR syntax as follows:",
      "ja": "XMSS公開鍵は、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Types for bitmask seed */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union seed switch (xmss_algorithm_type type) { case xmss-sha2_10_256: case xmss-sha2_16_256: case xmss-sha2_20_256: case xmss-shake_10_256: case xmss-shake_16_256: case xmss-shake_20_256: bytestring32 seed_n32;",
      "ja": "組合シードスイッチ（xmss_algorithm_type型）{ケースxmss-sha2_10_256：ケースxmss-sha2_16_256：ケースxmss-sha2_20_256：ケースxmss-shake_10_256：ケースxmss-shake_16_256：ケースxmss-shake_20_256：seed_n32 bytestring32。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_10_512: case xmss-sha2_16_512: case xmss-sha2_20_512: case xmss-shake_10_512: case xmss-shake_16_512: case xmss-shake_20_512: bytestring64 seed_n64;",
      "ja": "ケースxmss-sha2_10_512：ケースxmss-sha2_16_512：ケースxmss-sha2_20_512：ケースxmss-shake_10_512：ケースxmss-shake_16_512：xmss-shake_20_512場合：seed_n64 bytestring64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Types for XMSS root node */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union xmss_root switch (xmss_algorithm_type type) { case xmss-sha2_10_256: case xmss-sha2_16_256: case xmss-sha2_20_256: case xmss-shake_10_256: case xmss-shake_16_256: case xmss-shake_20_256: bytestring32 root_n32;",
      "ja": "組合xmss_rootスイッチ（xmss_algorithm_type型）{ケースxmss-sha2_10_256：ケースxmss-sha2_16_256：ケースxmss-sha2_20_256：ケースxmss-shake_10_256：ケースxmss-shake_16_256：ケースxmss-shake_20_256：root_n32 bytestring32。"
    },
    {
      "indent": 8,
      "text": "case xmss-sha2_10_512: case xmss-sha2_16_512: case xmss-sha2_20_512: case xmss-shake_10_512: case xmss-shake_16_512: case xmss-shake_20_512: bytestring64 root_n64;",
      "ja": "ケースxmss-sha2_10_512：ケースxmss-sha2_16_512：ケースxmss-sha2_20_512：ケースxmss-shake_10_512：ケースxmss-shake_16_512：ケースxmss-shake_20_512：root_n64 bytestring64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* XMSS public key structure */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct xmss_public_key {\n  xmss_root root;  /* Root node */\n  seed SEED;  /* Seed for bitmasks */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C. XMSS^MT XDR Formats",
      "ja": "付録C. XMSS ^ MT XDRフォーマット"
    },
    {
      "indent": 0,
      "text": "C.1. XMSS^MT Parameter Sets",
      "ja": "C.1。 XMSS ^ MTパラメータセット"
    },
    {
      "indent": 3,
      "text": "XMSS^MT parameter sets are defined using XDR syntax as follows:",
      "ja": "XMSS ^ MTパラメータセットは、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Byte strings */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "typedef opaque bytestring3[3];\ntypedef opaque bytestring5[5];\ntypedef opaque bytestring8[8];",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Definition of parameter sets */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum xmssmt_algorithm_type { xmssmt_reserved = 0x00000000,",
      "ja": "列挙xmssmt_algorithm_type {xmssmt_reserved = 0x00000000の、"
    },
    {
      "indent": 8,
      "text": "/* 256 bit classical security, 128 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmssmt-sha2_20/2_256 = 0x00000001, xmssmt-sha2_20/4_256 = 0x00000002, xmssmt-sha2_40/2_256 = 0x00000003, xmssmt-sha2_40/4_256 = 0x00000004, xmssmt-sha2_40/8_256 = 0x00000005, xmssmt-sha2_60/3_256 = 0x00000006, xmssmt-sha2_60/6_256 = 0x00000007, xmssmt-sha2_60/12_256 = 0x00000008,",
      "ja": "xmssmt-sha2_20 / 2_256 = 0x00000001に、xmssmt-sha2_20 / 4_256 = 0x00000002、xmssmt-sha2_40 / 2_256 = 0x00000003、xmssmt-sha2_40 / 4_256 = 0x00000004、xmssmt-sha2_40 / 8_256 = 0x00000005、xmssmt-sha2_60 / 3_256 = 0x00000006、xmssmt- sha2_60 / 6_256 = 0x00000007、xmssmt-sha2_60 / 12_256 = 0x00000008、"
    },
    {
      "indent": 8,
      "text": "/* 512 bit classical security, 256 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmssmt-sha2_20/2_512 = 0x00000009, xmssmt-sha2_20/4_512 = 0x0000000A, xmssmt-sha2_40/2_512 = 0x0000000B, xmssmt-sha2_40/4_512 = 0x0000000C, xmssmt-sha2_40/8_512 = 0x0000000D, xmssmt-sha2_60/3_512 = 0x0000000E, xmssmt-sha2_60/6_512 = 0x0000000F, xmssmt-sha2_60/12_512 = 0x00000010,",
      "ja": "xmssmt-sha2_20 / 2_512 = 0x00000009、xmssmt-sha2_20 / 4_512 = 0x0000000Aが、xmssmt-sha2_40 / 2_512 = 0x0000000B、xmssmt-sha2_40 / 4_512 = 0x0000000C、xmssmt-sha2_40 / 8_512 = 0x0000000D、xmssmt-sha2_60 / 3_512 = 0x0000000E、xmssmt- sha2_60 / 6_512 = 0x0000000F、xmssmt-sha2_60 / 12_512 = 0x00000010、"
    },
    {
      "indent": 8,
      "text": "/* 256 bit classical security, 128 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "xmssmt-shake_20/2_256 = 0x00000011, xmssmt-shake_20/4_256 = 0x00000012, xmssmt-shake_40/2_256 = 0x00000013, xmssmt-shake_40/4_256 = 0x00000014, xmssmt-shake_40/8_256 = 0x00000015, xmssmt-shake_60/3_256 = 0x00000016, xmssmt-shake_60/6_256 = 0x00000017, xmssmt-shake_60/12_256 = 0x00000018,",
      "ja": "xmssmt-shake_20 / 2_256 = 0x00000011、xmssmt-shake_20 / 4_256 = 0x00000012、xmssmt-shake_40 / 2_256 = 0x00000013、xmssmt-shake_40 / 4_256 = 0x00000014、xmssmt-shake_40 / 8_256 = 0x00000015、xmssmt-shake_60 / 3_256 = 0x00000016、xmssmt- shake_60 / 6_256 = 0x00000017、xmssmt-shake_60 / 12_256 = 0x00000018、"
    },
    {
      "indent": 8,
      "text": "/* 512 bit classical security, 256 bit post-quantum security */",
      "raw": true
    },
    {
      "indent": 6,
      "text": " xmssmt-shake_20/2_512 = 0x00000019, xmssmt-shake_20/4_512 = 0x0000001A, xmssmt-shake_40/2_512 = 0x0000001B, xmssmt-shake_40/4_512 = 0x0000001C, xmssmt-shake_40/8_512 = 0x0000001D, xmssmt-shake_60/3_512 = 0x0000001E, xmssmt-shake_60/6_512 = 0x0000001F, xmssmt-shake_60/12_512 = 0x00000020, };",
      "ja": "xmssmt-shake_20 / 2_512 = 0x00000019、xmssmt-shake_20 / 4_512 = 0x0000001A、xmssmt-shake_40 / 2_512 = 0x0000001B、xmssmt-shake_40 / 4_512 = 0x0000001C、xmssmt-shake_40 / 8_512 = 0x0000001D、xmssmt-shake_60 / 3_512 = 0x0000001Eを、xmssmt- shake_60 / 6_512 = 0x0000001F、xmssmt-shake_60 / 12_512 = 0x00000020、}。"
    },
    {
      "indent": 0,
      "text": "C.2. XMSS^MT Signatures",
      "ja": "C.2。 XMSS ^ MT署名"
    },
    {
      "indent": 3,
      "text": "XMSS^MT signatures are defined using XDR syntax as follows:",
      "ja": "XMSS ^ MTの署名は、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Type for XMSS^MT key pair index */\n/* Depends solely on h */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union idx_sig_xmssmt switch (xmss_algorithm_type type) { case xmssmt-sha2_20/2_256: case xmssmt-sha2_20/4_256: case xmssmt-sha2_20/2_512: case xmssmt-sha2_20/4_512: case xmssmt-shake_20/2_256: case xmssmt-shake_20/4_256: case xmssmt-shake_20/2_512: case xmssmt-shake_20/4_512: bytestring3 idx3;",
      "ja": "組合idx_sig_xmssmtスイッチ（xmss_algorithm_type型）{ケースxmssmt-sha2_20 / 2_256：ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_20 / 2_512：ケースxmssmt-sha2_20 / 4_512：ケースxmssmt-shake_20 / 2_256：ケースxmssmt-shake_20 / 4_256。ケースxmssmt-shake_20 / 2_512：ケースxmssmt-shake_20 / 4_512：IDX3 bytestring3。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_40/2_256: case xmssmt-sha2_40/4_256: case xmssmt-sha2_40/8_256: case xmssmt-sha2_40/2_512: case xmssmt-sha2_40/4_512: case xmssmt-sha2_40/8_512: case xmssmt-shake_40/2_256: case xmssmt-shake_40/4_256: case xmssmt-shake_40/8_256: case xmssmt-shake_40/2_512: case xmssmt-shake_40/4_512: case xmssmt-shake_40/8_512: bytestring5 idx5;",
      "ja": "ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_40 / 4_256：ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_40 / 2_512：ケース/ 4_512-sha2_40 xmssmt：ケースxmssmt-sha2_40 / 8_512：ケースxmssmt-shake_40 / 2_256：ケースxmssmt-shake_40 / 4_256：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_40 / 2_512：ケースxmssmt-shake_40 / 4_512：ケースxmssmt-shake_40 / 8_512：idx5 bytestring5。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_60/3_256: case xmssmt-sha2_60/6_256: case xmssmt-sha2_60/12_256: case xmssmt-sha2_60/3_512: case xmssmt-sha2_60/6_512: case xmssmt-sha2_60/12_512: case xmssmt-shake_60/3_256: case xmssmt-shake_60/6_256: case xmssmt-shake_60/12_256: case xmssmt-shake_60/3_512: case xmssmt-shake_60/6_512: case xmssmt-shake_60/12_512: bytestring8 idx8;",
      "ja": "ケースxmssmt-sha2_60 / 3_256：ケース/ 6_256-sha2_60 xmssmt：ケースxmssmt-sha2_60 / 12_256：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-shake_60 / 3_256：ケースxmssmt-shake_60 / 6_256：ケースxmssmt-shake_60 / 12_256：ケースxmssmt-shake_60 / 3_512：ケースxmssmt-shake_60 / 6_512：ケースxmssmt-shake_60 / 12_512：bytestring8 idx8。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union random_string_xmssmt switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_256: case xmssmt-sha2_20/4_256: case xmssmt-sha2_40/2_256: case xmssmt-sha2_40/4_256: case xmssmt-sha2_40/8_256: case xmssmt-sha2_60/3_256: case xmssmt-sha2_60/6_256: case xmssmt-sha2_60/12_256: case xmssmt-shake_20/2_256: case xmssmt-shake_20/4_256: case xmssmt-shake_40/2_256: case xmssmt-shake_40/4_256: case xmssmt-shake_40/8_256: case xmssmt-shake_60/3_256: case xmssmt-shake_60/6_256: case xmssmt-shake_60/12_256: bytestring32 rand_n32;",
      "ja": "組合random_string_xmssmtスイッチ（xmssmt_algorithm_type型）{ケースxmssmt-sha2_20 / 2_256：ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_40 / 4_256：ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_60 / 3_256。ケース/ 6_256-sha2_60 xmssmt：ケースxmssmt-sha2_60 / 12_256：ケースxmssmt-shake_20 / 2_256：ケースxmssmt-shake_20 / 4_256：ケースxmssmt-shake_40 / 2_256：ケースxmssmt-shake_40 / 4_256：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_60 / 3_256：ケースxmssmt-shake_60 / 6_256：xmssmt-shake_60 / 12_256場合：bytestring32 rand_n32。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/2_512: case xmssmt-sha2_20/4_512: case xmssmt-sha2_40/2_512: case xmssmt-sha2_40/4_512: case xmssmt-sha2_40/8_512: case xmssmt-sha2_60/3_512: case xmssmt-sha2_60/6_512: case xmssmt-sha2_60/12_512: case xmssmt-shake_20/2_512: case xmssmt-shake_20/4_512: case xmssmt-shake_40/2_512: case xmssmt-shake_40/4_512: case xmssmt-shake_40/8_512: case xmssmt-shake_60/3_512: case xmssmt-shake_60/6_512: case xmssmt-shake_60/12_512: bytestring64 rand_n64;",
      "ja": "ケースxmssmt-sha2_20 / 2_512：ケースxmssmt-sha2_20 / 4_512：ケースxmssmt-sha2_40 / 2_512：ケースxmssmt-sha2_40 / 4_512：ケース/ 8_512-sha2_40 xmssmt：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-shake_20 / 2_512：ケースxmssmt-shake_20 / 4_512：ケース/ 2_512-shake_40 xmssmt：ケースxmssmt-shake_40 / 4_512：ケースxmssmt-shake_40 / 8_512：ケースxmssmt-shake_60 / 3_512：ケースxmssmt -shake_60 / 6_512：xmssmt-shake_60 / 12_512場合：bytestring64 rand_n64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Type for reduced XMSS signatures */ union xmss_reduced (xmss_algorithm_type type) {\n  case xmssmt-sha2_20/2_256:\n  case xmssmt-sha2_40/4_256:\n  case xmssmt-sha2_60/6_256:\n  case xmssmt-shake_20/2_256:\n  case xmssmt-shake_40/4_256:\n  case xmssmt-shake_60/6_256:\n    bytestring32 xmss_reduced_n32_t77[77];",
      "raw": true
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/4_256: case xmssmt-sha2_40/8_256: case xmssmt-sha2_60/12_256: case xmssmt-shake_20/4_256: case xmssmt-shake_40/8_256: case xmssmt-shake_60/12_256: bytestring32 xmss_reduced_n32_t72[72];",
      "ja": "ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_60 / 12_256：ケースxmssmt-shake_20 / 4_256：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_60 / 12_256：bytestring32 xmss_reduced_n32_t72 [72]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_40/2_256: case xmssmt-sha2_60/3_256: case xmssmt-shake_40/2_256: case xmssmt-shake_60/3_256: bytestring32 xmss_reduced_n32_t87[87];",
      "ja": "ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_60 / 3_256：ケースxmssmt-shake_40 / 2_256：ケースxmssmt-shake_60 / 3_256：bytestring32 xmss_reduced_n32_t87 [87]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/2_512: case xmssmt-sha2_40/4_512: case xmssmt-sha2_60/6_512: case xmssmt-shake_20/2_512: case xmssmt-shake_40/4_512: case xmssmt-shake_60/6_512: bytestring64 xmss_reduced_n32_t141[141];",
      "ja": "ケースxmssmt-sha2_20 / 2_512：ケースxmssmt-sha2_40 / 4_512：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-shake_20 / 2_512：ケースxmssmt-shake_40 / 4_512：ケースxmssmt-shake_60 / 6_512：xmss_reduced_n32_t141 [141] bytestring64。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/4_512: case xmssmt-sha2_40/8_512: case xmssmt-sha2_60/12_512: case xmssmt-shake_20/4_512: case xmssmt-shake_40/8_512: case xmssmt-shake_60/12_512: bytestring64 xmss_reduced_n32_t136[136];",
      "ja": "ケースxmssmt-sha2_20 / 4_512：ケースxmssmt-sha2_40 / 8_512：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-shake_20 / 4_512：ケースxmssmt-shake_40 / 8_512：ケースxmssmt-shake_60 / 12_512：bytestring64 xmss_reduced_n32_t136 [136]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_40/2_512: case xmssmt-sha2_60/3_512: case xmssmt-shake_40/2_512: case xmssmt-shake_60/3_512: bytestring64 xmss_reduced_n32_t151[151];",
      "ja": "ケースxmssmt-sha2_40 / 2_512：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-shake_40 / 2_512：ケースxmssmt-shake_60 / 3_512：bytestring64 xmss_reduced_n32_t151 [151]。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* xmss_reduced_array depends on d */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union xmss_reduced_array (xmss_algorithm_type type) { case xmssmt-sha2_20/2_256: case xmssmt-sha2_20/2_512: case xmssmt-sha2_40/2_256: case xmssmt-sha2_40/2_512: case xmssmt-shake_20/2_256: case xmssmt-shake_20/2_512: case xmssmt-shake_40/2_256: case xmssmt-shake_40/2_512: xmss_reduced xmss_red_arr_d2[2];",
      "ja": "組合xmss_reduced_array（xmss_algorithm_type型）{ケースxmssmt-sha2_20 / 2_256：ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_40 / 2_512：ケースxmssmt-shake_20 / 2_256：ケースxmssmt-shake_20 / 2_512：ケースケース/ 2_512-sha2_20 xmssmt xmssmt-shake_40 / 2_256：ケースxmssmt-shake_40 / 2_512：xmss_reduced xmss_red_arr_d2 [2]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_60/3_256: case xmssmt-sha2_60/3_512: case xmssmt-shake_60/3_256: case xmssmt-shake_60/3_512: xmss_reduced xmss_red_arr_d3[3];",
      "ja": "ケースxmssmt-sha2_60 / 3_256：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-shake_60 / 3_256：ケースxmssmt-shake_60 / 3_512：xmss_reduced xmss_red_arr_d3 [3]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/4_256: case xmssmt-sha2_20/4_512: case xmssmt-sha2_40/4_256: case xmssmt-sha2_40/4_512: case xmssmt-shake_20/4_256: case xmssmt-shake_20/4_512: case xmssmt-shake_40/4_256: case xmssmt-shake_40/4_512: xmss_reduced xmss_red_arr_d4[4];",
      "ja": "ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_20 / 4_512：ケースxmssmt-sha2_40 / 4_256：ケースxmssmt-sha2_40 / 4_512：ケース/ 4_256-shake_20 xmssmt：ケースxmssmt-shake_20 / 4_512：ケースxmssmt-shake_40 / 4_256：ケースxmssmt-shake_40 / 4_512：xmss_reduced xmss_red_arr_d4 [4]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_60/6_256: case xmssmt-sha2_60/6_512: case xmssmt-shake_60/6_256: case xmssmt-shake_60/6_512: xmss_reduced xmss_red_arr_d6[6];",
      "ja": "ケースxmssmt-sha2_60 / 6_256：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-shake_60 / 6_256：ケースxmssmt-shake_60 / 6_512：xmss_reduced xmss_red_arr_d6 [6]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_40/8_256: case xmssmt-sha2_40/8_512: case xmssmt-shake_40/8_256: case xmssmt-shake_40/8_512: xmss_reduced xmss_red_arr_d8[8];",
      "ja": "ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_40 / 8_512：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_40 / 8_512：xmss_reduced xmss_red_arr_d8 [8]。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_60/12_256: case xmssmt-sha2_60/12_512: case xmssmt-shake_60/12_256: case xmssmt-shake_60/12_512: xmss_reduced xmss_red_arr_d12[12];",
      "ja": "ケースxmssmt-sha2_60 / 12_256：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-shake_60 / 12_256：ケースxmssmt-shake_60 / 12_512：xmss_reduced xmss_red_arr_d12 [12]。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* XMSS^MT signature structure */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct xmssmt_signature {\n  /* WOTS+ key pair index */\n  idx_sig_xmssmt idx_sig;\n  /* Random string for randomized hashing */\n  random_string_xmssmt randomness;\n  /* Array of d reduced XMSS signatures */\n  xmss_reduced_array;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.3. XMSS^MT Public Keys",
      "ja": "C.3。 XMSS ^ MT公開鍵"
    },
    {
      "indent": 3,
      "text": "XMSS^MT public keys are defined using XDR syntax as follows:",
      "ja": "XMSS ^ MT公開鍵は、次のようにXDR構文を使用して定義されています。"
    },
    {
      "indent": 6,
      "text": "/* Types for bitmask seed */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union seed switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_256: case xmssmt-sha2_40/4_256: case xmssmt-sha2_60/6_256: case xmssmt-sha2_20/4_256: case xmssmt-sha2_40/8_256: case xmssmt-sha2_60/12_256: case xmssmt-sha2_40/2_256: case xmssmt-sha2_60/3_256: case xmssmt-shake_20/2_256: case xmssmt-shake_40/4_256: case xmssmt-shake_60/6_256: case xmssmt-shake_20/4_256: case xmssmt-shake_40/8_256: case xmssmt-shake_60/12_256: case xmssmt-shake_40/2_256: case xmssmt-shake_60/3_256: bytestring32 seed_n32;",
      "ja": "組合シードスイッチ（xmssmt_algorithm_type型）{ケースxmssmt-sha2_20 / 2_256：ケースxmssmt-sha2_40 / 4_256：ケースxmssmt-sha2_60 / 6_256：ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_60 / 12_256。ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_60 / 3_256：ケースxmssmt-shake_20 / 2_256：ケースxmssmt-shake_40 / 4_256：ケース/ 6_256-shake_60 xmssmt：ケースxmssmt-shake_20 / 4_256：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_60 / 12_256：ケースxmssmt-shake_40 / 2_256：ケースxmssmt-shake_60 / 3_256：seed_n32 bytestring32。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/2_512: case xmssmt-sha2_40/4_512: case xmssmt-sha2_60/6_512: case xmssmt-sha2_20/4_512: case xmssmt-sha2_40/8_512: case xmssmt-sha2_60/12_512: case xmssmt-sha2_40/2_512: case xmssmt-sha2_60/3_512: case xmssmt-shake_20/2_512: case xmssmt-shake_40/4_512: case xmssmt-shake_60/6_512: case xmssmt-shake_20/4_512: case xmssmt-shake_40/8_512: case xmssmt-shake_60/12_512: case xmssmt-shake_40/2_512: case xmssmt-shake_60/3_512: bytestring64 seed_n64;",
      "ja": "ケースxmssmt-sha2_20 / 2_512：ケースxmssmt-sha2_40 / 4_512：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-sha2_20 / 4_512：ケース/ 8_512-sha2_40 xmssmt：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-sha2_40 / 2_512：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-shake_20 / 2_512：ケースxmssmt-shake_40 / 4_512：ケース/ 6_512-shake_60 xmssmt：ケースxmssmt-shake_20 / 4_512：ケースxmssmt-shake_40 / 8_512：ケースxmssmt-shake_60 / 12_512：ケースxmssmt -shake_40 / 2_512：ケースxmssmt-shake_60 / 3_512：seed_n64 bytestring64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* Types for XMSS^MT root node */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "union xmssmt_root switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_256: case xmssmt-sha2_20/4_256: case xmssmt-sha2_40/2_256: case xmssmt-sha2_40/4_256: case xmssmt-sha2_40/8_256: case xmssmt-sha2_60/3_256: case xmssmt-sha2_60/6_256: case xmssmt-sha2_60/12_256: case xmssmt-shake_20/2_256: case xmssmt-shake_20/4_256: case xmssmt-shake_40/2_256: case xmssmt-shake_40/4_256: case xmssmt-shake_40/8_256: case xmssmt-shake_60/3_256: case xmssmt-shake_60/6_256: case xmssmt-shake_60/12_256: bytestring32 root_n32;",
      "ja": "組合xmssmt_rootスイッチ（xmssmt_algorithm_type型）{ケースxmssmt-sha2_20 / 2_256：ケースxmssmt-sha2_20 / 4_256：ケースxmssmt-sha2_40 / 2_256：ケースxmssmt-sha2_40 / 4_256：ケースxmssmt-sha2_40 / 8_256：ケースxmssmt-sha2_60 / 3_256。ケース/ 6_256-sha2_60 xmssmt：ケースxmssmt-sha2_60 / 12_256：ケースxmssmt-shake_20 / 2_256：ケースxmssmt-shake_20 / 4_256：ケースxmssmt-shake_40 / 2_256：ケースxmssmt-shake_40 / 4_256：ケースxmssmt-shake_40 / 8_256：ケースxmssmt-shake_60 / 3_256：ケースxmssmt-shake_60 / 6_256：ケースxmssmt-shake_60 / 12_256：bytestring32 root_n32。"
    },
    {
      "indent": 8,
      "text": "case xmssmt-sha2_20/2_512: case xmssmt-sha2_20/4_512: case xmssmt-sha2_40/2_512: case xmssmt-sha2_40/4_512: case xmssmt-sha2_40/8_512: case xmssmt-sha2_60/3_512: case xmssmt-sha2_60/6_512: case xmssmt-sha2_60/12_512: case xmssmt-shake_20/2_512: case xmssmt-shake_20/4_512: case xmssmt-shake_40/2_512: case xmssmt-shake_40/4_512: case xmssmt-shake_40/8_512: case xmssmt-shake_60/3_512: case xmssmt-shake_60/6_512: case xmssmt-shake_60/12_512: bytestring64 root_n64;",
      "ja": "ケースxmssmt-sha2_20 / 2_512：ケースxmssmt-sha2_20 / 4_512：ケースxmssmt-sha2_40 / 2_512：ケースxmssmt-sha2_40 / 4_512：ケース/ 8_512-sha2_40 xmssmt：ケースxmssmt-sha2_60 / 3_512：ケースxmssmt-sha2_60 / 6_512：ケースxmssmt-sha2_60 / 12_512：ケースxmssmt-shake_20 / 2_512：ケースxmssmt-shake_20 / 4_512：ケース/ 2_512-shake_40 xmssmt：ケースxmssmt-shake_40 / 4_512：ケースxmssmt-shake_40 / 8_512：ケースxmssmt-shake_60 / 3_512：ケースxmssmt -shake_60 / 6_512：ケース/ 12_512-shake_60 xmssmt：root_n64 bytestring64。"
    },
    {
      "indent": 6,
      "text": "  default:\n    void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/* XMSS^MT public key structure */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct xmssmt_public_key {\n  xmssmt_root root;  /* Root node */\n  seed SEED;  /* Seed for bitmasks */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Johannes Braun, Peter Campbell, Florian Caullery, Stephen Farrell, Scott Fluhrer, Burt Kaliski, Adam Langley, Marcos Manzano, David McGrew, Rafael Misoczki, Sean Parkinson, Sebastian Roland, and the Keccak team for their help and comments.",
      "ja": "私たちは、彼らの助けとコメントのためにヨハネス・ブラウン、ピーター・キャンベル、フロリアン・コーレイ、スティーブン・ファレル、スコットFluhrer、バート・カリスキー、アダム・ラングレー、マルコスマンザノ、デビッドマグリュー、ラファエルMisoczki、ショーン・パーキンソン、セバスチャン・ローランド、およびKeccakチームに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Andreas Huelsing TU Eindhoven P.O. Box 513 Eindhoven 5600 MB The Netherlands",
      "ja": "アンドレアスHuelsing TUアイントホーフェンの私書箱513 5600 MBアイントホーフェンオランダ箱"
    },
    {
      "indent": 3,
      "text": "Email: ietf@huelsing.net",
      "ja": "メール：ietf@huelsing.net"
    },
    {
      "indent": 3,
      "text": "Denis Butin TU Darmstadt Hochschulstrasse 10 Darmstadt 64289 Germany",
      "ja": "デニスブチンTUダルムシュタット大学シュトラーセ10 64289ダルムシュタットドイツ"
    },
    {
      "indent": 3,
      "text": "Email: dbutin@cdc.informatik.tu-darmstadt.de",
      "ja": "メール：dbutin@cdc.informatik.tu-darmstadt.de"
    },
    {
      "indent": 3,
      "text": "Stefan-Lukas Gazdag genua GmbH Domagkstrasse 7 Kirchheim bei Muenchen 85551 Germany",
      "ja": "ミュンヘン85551ドイツ近くステファン・ルーカスGazdagジェノバ社Domagkstrasse 7キルヒハイム"
    },
    {
      "indent": 3,
      "text": "Email: ietf@gazdag.de",
      "ja": "メール：ietf@gazdag.de"
    },
    {
      "indent": 3,
      "text": "Joost Rijneveld Radboud University Toernooiveld 212 Nijmegen 6525 EC The Netherlands",
      "ja": "JoostのRijneveldラドバウド大学Toernooiveld 212 6525 ECオランダ"
    },
    {
      "indent": 3,
      "text": "Email: ietf@joostrijneveld.nl",
      "ja": "メール：ietf@joostrijneveld.nl"
    },
    {
      "indent": 3,
      "text": "Aziz Mohaisen University of Central Florida 4000 Central Florida Blvd Orlando, FL 32816 United States of America",
      "ja": "セントラルフロリダのアジズMohaisen大学4000セントラルフロリダブルバードオーランド、FLアメリカの32816米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 407 823-1294 Email: mohaisen@ieee.org",
      "ja": "電話：+1 407 823-1294 Eメール：mohaisen@ieee.org"
    }
  ]
}