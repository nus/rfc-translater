{
  "title": {
    "text": "RFC 8289 - Controlled Delay Active Queue Management",
    "ja": "RFC 8289 - 制御遅延アクティブキュー管理"
  },
  "number": 8289,
  "created_at": "2019-10-29 16:53:35.783142+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        K. Nichols\nRequest for Comments: 8289                                 Pollere, Inc.\nCategory: Experimental                                       V. Jacobson\nISSN: 2070-1721                                         A. McGregor, Ed.\n                                                         J. Iyengar, Ed.\n                                                                  Google\n                                                            January 2018",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Controlled Delay Active Queue Management",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes CoDel (Controlled Delay) -- a general framework that controls bufferbloat-generated excess delay in modern networking environments. CoDel consists of an estimator, a setpoint, and a control loop. It requires no configuration in normal Internet deployments.",
      "ja": "現代のネットワーク環境におけるbufferbloat、生成された過剰遅延を制御し、一般的なフレームワーク - この文書はCODELを（遅延を制御）について説明します。 CODELは推定、設定値、及び制御ループから成ります。これは、通常のインターネット展開での設定は必要ありません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8289.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8289で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Conventions and Terms Used in This Document . . . . . . . . .   4\n3.  Understanding the Building Blocks of Queue Management . . . .   5\n  3.1.  Estimator . . . . . . . . . . . . . . . . . . . . . . . .   6\n  3.2.  Target Setpoint . . . . . . . . . . . . . . . . . . . . .   8\n  3.3.  Control Loop  . . . . . . . . . . . . . . . . . . . . . .  10\n4.  Overview of the CoDel AQM . . . . . . . . . . . . . . . . . .  13\n  4.1.  Non-starvation  . . . . . . . . . . . . . . . . . . . . .  14\n  4.2.  Setting INTERVAL  . . . . . . . . . . . . . . . . . . . .  14\n  4.3.  Setting TARGET  . . . . . . . . . . . . . . . . . . . . .  14\n  4.4.  Use with Multiple Queues  . . . . . . . . . . . . . . . .  15\n  4.5.  Setting Up CoDel  . . . . . . . . . . . . . . . . . . . .  16\n5.  Annotated Pseudocode for CoDel AQM  . . . . . . . . . . . . .  16\n  5.1.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .  17\n  5.2.  Per-Queue State (codel_queue_t Instance Variables)  . . .  17\n  5.3.  Constants . . . . . . . . . . . . . . . . . . . . . . . .  17\n  5.4.  Enqueue Routine . . . . . . . . . . . . . . . . . . . . .  18\n  5.5.  Dequeue Routine . . . . . . . . . . . . . . . . . . . . .  18\n  5.6.  Helper Routines . . . . . . . . . . . . . . . . . . . . .  19\n  5.7.  Implementation Considerations . . . . . . . . . . . . . .  21\n6.  Further Experimentation . . . . . . . . . . . . . . . . . . .  21\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  21\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  22\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  22\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  22\nAppendix A.  Applying CoDel in the Data Center  . . . . . . . . .  24\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  25\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  25",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The \"persistently full buffer\" problem has been discussed in the IETF community since the early 80s [RFC896]. The IRTF's End-to-End Research Group called for the deployment of Active Queue Management (AQM) to solve the problem in 1998 [RFC2309]. Despite this awareness, the problem has only gotten worse as growth in memory density per Moore's Law fueled an exponential increase in buffer pool size. Efforts to deploy AQM have been frustrated by difficult configuration and negative impact on network utilization. This \"bufferbloat\" problem [BLOAT] has become increasingly important throughout the Internet but particularly at the consumer edge. Queue management has become more critical due to increased consumer use of the Internet, mixing large video transactions with time-critical VoIP and gaming.",
      "ja": "「永続的バッファフル」の問題は、80年代前半[RFC896]以来、IETFコミュニティで議論されてきました。 IRTFのエンドツーエンドの研究グループは、1998 [RFC2309]で問題を解決するためのアクティブキュー管理（AQM）の展開のために呼ばれます。ムーアの法則あたりのメモリ密度の増加は、バッファプールのサイズが指数関数的な増加を煽ってこのような認識にもかかわらず、問題は悪化しています。 AQMを展開する努力は難しい設定やネットワーク使用率にマイナスの影響でイライラされています。この「bufferbloat」問題[BLOAT]は、インターネット全体ではなく、特に消費者のエッジでますます重要になってきています。キューの管理は、タイムクリティカルなVoIPやゲームで大規模なビデオ取引を混合、インターネットの増加、消費者の使用により重要になってきています。"
    },
    {
      "indent": 3,
      "text": "An effective AQM remediates bufferbloat at a bottleneck while \"doing no harm\" at hops where buffers are not bloated. However, the development and deployment of AQM are frequently subject to misconceptions about the cause of packet queues in network buffers. Network buffers exist to absorb the packet bursts that occur naturally in statistically multiplexed networks. Buffers helpfully absorb the queues created by reasonable packet network behavior such as short-term mismatches in traffic arrival and departure rates that arise from upstream resource contention, transport conversation startup transients, and/or changes in the number of conversations sharing a link. Unfortunately, other less useful network behaviors can cause queues to fill, and their effects are not nearly as benign. Discussion of these issues and the reason why the solution is not simply \"smaller buffers\" can be found in [RFC2309], [VANQ2006], [REDL1998], and [CODEL2012]. To understand queue management, it is critical to understand the difference between the necessary, useful \"good\" queue and the counterproductive \"bad\" queue.",
      "ja": "バッファが肥大化していないホップで「害をやっていない」しながら、効果的なAQMはボトルネックでbufferbloatを修復し。しかし、AQMの開発と展開は、ネットワークバッファ内のパケットキューの原因についての誤解を頻繁に受けます。ネットワーク・バッファは、統計的に多重化されたネットワークで自然に発生するパケットのバーストを吸収するために存在します。バッファは親切な上流のリソースの競合から発生するトラフィックの到着と出発の料金、交通会話スタートアップトランジェント、および/またはリンクを共有している会話の数の変化の短期的な不整合など、合理的なパケットネットワークの動作によって作成されたキューを吸収します。残念ながら、他のより便利なネットワークの挙動は、キューがいっぱいになる可能性があります、そしてその効果はほぼ同じ良性ではありません。これらの問題の議論と解決策は単純ではない理由は、「小さなバッファは、」[CODEL2012] [REDL1998]、[VANQ2006]、[RFC2309]で見つけて、することができます。キュー管理を理解するには、必要に応じて、便利な「良い」キューと逆に「悪い」キューの違いを理解することが重要です。"
    },
    {
      "indent": 3,
      "text": "Several approaches to AQM have been developed over the past two decades, but none have been widely deployed due to performance problems. When designed with the wrong conceptual model for queues, AQMs have limited operational range, require a lot of configuration tweaking, and frequently impair rather than improve performance. Learning from this past history, the CoDel approach is designed to meet the following goals:",
      "ja": "AQMへのいくつかのアプローチが過去20年間にわたって開発されてきたが、どれも広くによるパフォーマンスの問題に配備されていません。キューの間違った概念モデルで設計すると、AQMSは、コンフィギュレーション微調整の多くを必要とし、頻繁に損なわれるのではなく、パフォーマンスを向上させ、動作範囲が限られています。この過去の歴史から学ぶ、CODELのアプローチは、次の目標を満たすように設計されています。"
    },
    {
      "indent": 3,
      "text": "o Make AQM parameterless for normal operation, with no knobs for operators, users, or implementers to adjust.",
      "ja": "O事業者、ユーザー、または調整するための実装のための無ノブと、通常動作にAQMのパラメーターなしを確認します。"
    },
    {
      "indent": 3,
      "text": "o Be able to distinguish \"good\" queue from \"bad\" queue and treat them differently, that is, keep delay low while permitting necessary bursts of traffic.",
      "ja": "O「悪い」キューから「良い」キューを区別し、別々にそれらを扱う、つまり、トラフィックの必要なバーストを可能にしながら、低遅延を維持することができます。"
    },
    {
      "indent": 3,
      "text": "o Control delay while insensitive (or nearly so) to round-trip delays, link rates, and traffic loads; this goal is to \"do no harm\" to network traffic while controlling delay.",
      "ja": "O制御遅れながら、往復遅延、リンク速度、およびトラフィック負荷の影響を受けない（あるいはそれに近いです）。この目標は、遅延を制御しながら、ネットワークトラフィックに「危害を与えない」ことです。"
    },
    {
      "indent": 3,
      "text": "o Adapt to dynamically changing link rates with no negative impact on utilization.",
      "ja": "O動的利用に悪影響をリンク速度の変化に対応。"
    },
    {
      "indent": 3,
      "text": "o Allow simple and efficient implementation (can easily span the spectrum from low-end access points and home routers up to high-end router hardware).",
      "ja": "O（簡単にハイエンドルータのハードウェアへのローエンドのアクセスポイントとホームルーターからのスペクトルにまたがることができます）簡単かつ効率的な実施を許可します。"
    },
    {
      "indent": 3,
      "text": "CoDel has five major differences from prior AQMs: use of the local queue minimum to track congestion (\"bad\" queue), use of an efficient single state variable representation of that tracked statistic, use of packet sojourn time as the observed datum (rather than packets, bytes, or rates), use of a mathematically determined setpoint derived from maximizing network power [KLEIN81], and a modern state-space controller.",
      "ja": "輻輳（「悪い」キュー）、その追跡統計の効率的な単一の状態変数表現の使用を追跡観測データとしてパケットの滞在時間の使用（よりむしろローカルキュー最小の使用：CODEL前AQMSから5つの主な相違点を有していますパケット、バイト、またはレート）、ネットワークパワー[KLEIN81]、および現代の状態空間コントローラを最大に由来数学的に決定された設定値を使用します。"
    },
    {
      "indent": 3,
      "text": "CoDel configures itself based on a round-trip time metric that can be set to 100 ms for the normal, terrestrial Internet. With no changes to parameters, CoDel is expected to work across a wide range of conditions, with varying links and the full range of terrestrial round-trip times.",
      "ja": "CODELは通常、地上のインターネットのために100ミリ秒に設定することができ、ラウンドトリップ時間のメトリックに基づいて自分自身を設定します。パラメータを変更せずに、CODELは、様々なリンクと地上往復時間のフルレンジで、条件の幅広い動作するように期待されています。"
    },
    {
      "indent": 3,
      "text": "CoDel is easily adapted to multiple queue systems as shown by [RFC8290]. Implementers and users SHOULD use the fq_codel multiple-queue approach as it deals with many problems beyond the reach of an AQM on a single queue.",
      "ja": "[RFC8290]で示すようにCODELを容易に複数のキュー・システムに適合されます。それは単一のキュー上のAQMの届かない多くの問題を扱って実装し、ユーザーがfq_codel複数のキューのアプローチを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "CoDel was first published in [CODEL2012] and has been implemented in the Linux kernel.",
      "ja": "CODELは、最初の[CODEL2012]に掲載されましたし、Linuxカーネルに実装されています。"
    },
    {
      "indent": 3,
      "text": "Note that while this document refers to dropping packets when indicated by CoDel, it may be reasonable to ECN-mark packets instead.",
      "ja": "この文書はCODELによって示されるときに、パケットをドロップすることをいうが、それは代わりに、ECNマークパケットに合理的であってもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Terms Used in This Document",
      "section_title": true,
      "ja": "この文書で使用される2.表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 3,
      "text": "The following terms are used in this document and are defined as follows:",
      "ja": "以下の用語は、このドキュメントで使用され、次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "sojourn time: the amount of time a packet has spent in a particular buffer, i.e., the time a packet departs the buffer minus the time the packet arrived at the buffer. A packet can depart a buffer via transmission or drop.",
      "ja": "滞在時間：パケットは、特定のバッファに費やした時間の量、すなわち、時間はパケットがバッファマイナスパケットがバッファに到着した時刻を出発します。パケットは、送信またはドロップを介してバッファに出発することができます。"
    },
    {
      "indent": 3,
      "text": "standing queue: a queue (in packets, bytes, or time delay) in a buffer that persists for a \"long\" time, where \"long\" is on the order of the longer round-trip times through the buffer, as discussed in Section 4.2. A standing queue occurs when the minimum queue over the \"long\" time is non-zero and is usually tolerable and even desirable as long as it does not exceed some target delay.",
      "ja": "キューを立っ：キュー（パケット、バイト、または時間遅れで）節で説明したように、「長い」はバッファを介して長い往復時間のオーダーである「長い」時間、持続バッファに4.2。 「長い」時間をかけて最小キューが非ゼロであり、通常は許容し、それはいくつかの目標遅延を超えない限り、望ましくさえあるときに立っキューが発生します。"
    },
    {
      "indent": 3,
      "text": "bottleneck bandwidth: the limiting bandwidth along a network path.",
      "ja": "ボトルネック帯域：ネットワーク経路に沿って帯域制限。"
    },
    {
      "indent": 0,
      "text": "3. Understanding the Building Blocks of Queue Management",
      "section_title": true,
      "ja": "3.キュー管理のビルディングブロックを理解します"
    },
    {
      "indent": 3,
      "text": "At the heart of queue management is the notion of \"good\" queue and \"bad\" queue and the search for ways to get rid of the \"bad\" queue (which only adds delay) while preserving the \"good\" queue (which provides for good utilization). This section explains queueing, both good and bad, and covers the CoDel building blocks that can be used to manage packet buffers to keep their queues in the \"good\" range.",
      "ja": "キュー管理の心臓部には「良い」キューおよび「悪い」キューとを提供し、「良い」キューを（維持しながら（のみ遅延を加える）「悪い」キューを取り除くための方法については、検索の概念であります良い利用）。このセクションでは、キューイング良い面と悪い面の両方を説明し、「良い」の範囲で自分のキューを維持するために、パケットバッファを管理するために使用することができCODELビルディングブロックをカバーしています。"
    },
    {
      "indent": 3,
      "text": "Packet queues form in buffers facing bottleneck links, i.e., where the line rate goes from high to low or where many links converge. The well-known bandwidth-delay product (sometimes called \"pipe size\") is the bottleneck's bandwidth multiplied by the sender-receiver-sender round-trip delay; it is the amount of data that has to be in transit between two hosts in order to run the bottleneck link at 100% utilization. To explore how queues can form, consider a long-lived TCP connection with a 25-packet window sending through a connection with a bandwidth-delay product of 20 packets. After an initial burst of packets, the connection will settle into a 5-packet (+/-1) standing queue; this standing queue size is determined by the mismatch between the window size and the pipe size and is unrelated to the connection's sending rate. The connection has 25 packets in flight at all times, but only 20 packets arrive at the destination over a round-trip time. If the TCP connection has a 30-packet window, the queue will be 10 packets with no change in sending rate. Similarly, if the window is 20 packets, there will be no queue, but the sending rate is the same. Nothing can be inferred about the sending rate from the queue size, and any queue other than transient bursts only creates delays in the network. The sender needs to reduce the number of packets in flight rather than the sending rate.",
      "ja": "ラインレートが低い場合や、多くのリンクが収束に高いからどこに行くのパケットキューは、すなわち、ボトルネックリンクが直面しているバッファに形成します。 （時々、「パイプサイズ」と呼ばれる）のよく知られた帯域幅遅延積は、送信者、受信者、送信者の往復遅延時間を乗じたボトルネックの帯域幅です。それは100％の使用率でボトルネックリンクを実行するために、2つのホスト間のトランジットでなければならないデータの量です。キューを形成することができる方法を模索するために、20のパケットの帯域遅延積との接続を介して送信25パケットウィンドウで長寿命のTCP接続を考えてみましょう。パケットの初期バースト後、接続は5パケット（+/- 1）定在キューに落ち着くであろう。この立っキューサイズはウィンドウサイズとパイプのサイズの間の不整合によって決定され、接続の送信速度に無関係です。接続は、すべての回で飛行中の25個のパケットを持っていますが、唯一の20パケットが往復の時間をかけて目的地に到着します。 TCP接続が30パケットウィンドウを持っている場合、キューは率を送信中に変化のない10個のパケットになります。ウィンドウが20のパケットであれば同様に、そこにはキューもありませんが、送信レートが同じであるだろう。何もキューサイズから送信レートについて推論することはできない、と過渡バースト以外のキューは、ネットワークの遅延を作成します。送信者は、飛行中のパケットの数ではなく、送信速度を低下させる必要があります。"
    },
    {
      "indent": 3,
      "text": "In the above example, the 5-packet standing queue can be seen to contribute nothing but delay to the connection and thus is clearly \"bad\" queue. If, in our example, there is a single bottleneck link and it is much slower than the link that feeds it (say, a high-speed Ethernet link into a limited DSL uplink), then a 20-packet buffer at the bottleneck might be necessary to temporarily hold the 20 packets in flight to keep the bottleneck link's utilization high. The burst of packets should drain completely (to 0 or 1 packets) within a round-trip time, and this transient queue is \"good\" queue because it allows the connection to keep the 20 packets in flight and the bottleneck link to be fully utilized. In terms of the delay experienced, the \"good\" queue goes away in about a round-trip time, while \"bad\" queue hangs around for longer, causing delays.",
      "ja": "上記の例では、5-パケット立っキューは、接続に遅延が、何も貢献しないように見えるので、はっきりと「悪い」キューであることができます。 、私たちの例では、そこに一つのボトルネックリンクであり、それはそれをフィードのリンク（たとえば、制限されたDSLアップリンクへの高速イーサネットリンク）がボトルネックで、その後20-パケットバッファは、あるかもしれないよりもはるかに遅い場合必要に応じて一時的にボトルネックリンクの利用率を高く維持するために、飛行中に20個のパケットを保持します。パケットのバーストは、ラウンドトリップ時間内（0または1パケットに）完全に排水する必要があり、それは、接続が十分に活用されるように、飛行中に20のパケットとボトルネックリンクを維持することができますので、この過渡的なキューは、「良い」キューであります。 「悪い」キューは、遅延が発生、長い間の周りにハングアップしながら経験した遅延の面では、「良い」キューは、およそ往復時間で消えます。"
    },
    {
      "indent": 3,
      "text": "Effective queue management detects \"bad\" queue while ignoring \"good\" queue and takes action to get rid of the \"bad\" queue when it is detected. The goal is a queue controller that accomplishes this objective. To control a queue, we need three basic components:",
      "ja": "効果的なキュー管理は、「良い」キューを無視して「悪い」キューを検出し、それが検出されたときに「悪い」キューを取り除くためにアクションを実行します。目標は、この目的を達成するキューコントローラです。キューを制御するために、我々は3つの基本的な構成要素が必要になります。"
    },
    {
      "indent": 3,
      "text": "o Estimator - To figure out what we've got.",
      "ja": "O見積もり - 私たちが持っているものを把握します。"
    },
    {
      "indent": 3,
      "text": "o Target setpoint - To know what we want.",
      "ja": "O目標設定値は - 私たちが望むものを知るために。"
    },
    {
      "indent": 3,
      "text": "o Control loop - If what we've got isn't what we want, we need a way to move it there.",
      "ja": "O制御ループ - 私たちが持っていることは、我々が望むものではない場合、我々はそこにそれを移動するための方法が必要です。"
    },
    {
      "indent": 0,
      "text": "3.1. Estimator",
      "section_title": true,
      "ja": "3.1。見積もり"
    },
    {
      "indent": 3,
      "text": "The estimator both observes the queue and detects when \"good\" queue turns to \"bad\" queue and vice versa. CoDel has two parts to its estimator: what is observed as an indicator of queue and how the observations are used to detect \"good\"/\"bad\" queue.",
      "ja": "推定では、キューを観察し、「良い」キューが「悪い」キューおよびその逆になったときに検出し、両方の。 CODELは、その推定には2つの部分で構成されていますキューの指標とどのように観測が「良い」/「悪い」キューを検出するために使用されているように観察されたもの。"
    },
    {
      "indent": 3,
      "text": "Queue length has been widely used as an observed indicator of congestion and is frequently conflated with sending rate. Use of queue length as a metric is sensitive to how and when the length is observed. A high-speed arrival link to a buffer serviced at a much lower rate can rapidly build up a queue that might disperse completely or down to a single packet before a round-trip time has elapsed. If the queue length is monitored at packet arrival (as in original Random Early Detection (RED)) or departure time, every packet will see a queue with one possible exception. If the queue length itself is time sampled (as recommended in [REDL1998]), a truer picture of the queue's occupancy can be gained at the expense of considerable implementation complexity.",
      "ja": "キュー長が広く輻輳の観測指標として使用されており、頻繁に速度を送信して融合しています。メトリックとしてキューの長さの使用は、いつ、どのように長さが観察されるに敏感です。はるかに低いレートでサービスを提供バッファへの高速到着リンクが急速に往​​復時間が経過する前に、完全に、またはダウン単一のパケットに分散させる可能性があるキューを構築することができます。キューの長さが（元ランダム早期検出（RED）のように）パケット到着や出発時に監視されている場合は、すべてのパケットは、一つの可能​​な例外を除いてキューが表示されます。 （[REDL1998]で推奨されるように）キューの長さ自体は時間サンプリングされた場合、キューの占有率の真実画像がかなりの実装の複雑さを犠牲にして得ることができます。"
    },
    {
      "indent": 3,
      "text": "The use of queue length is further complicated in networks that are subject to both short- and long-term changes in available link rate (as in WiFi). Link rate drops can result in a spike in queue length that should be ignored unless it persists. It is not the queue length that should be controlled but the amount of excess delay packets experience due to a persistent or standing queue, which means that the packet sojourn time in the buffer is exactly what we want to track. Tracking the packet sojourn times in the buffer observes the actual delay experienced by each packet. Sojourn time allows queue management to be independent of link rate, gives superior performance to use of buffer size, and is directly related to user-visible performance. It works regardless of line rate changes or link sharing by multiple queues (which the individual queues may experience as changing rates).",
      "ja": "キュー長の使用は、（無線LANのように）利用可能なリンクレートの短期および長期的な変化の両方の対象となるネットワークにさらに複雑になります。リンク速度低下は、それが解決しない限り、無視されるべきであるキューの長さのスパイクが発生することができます。これは、バッファ内のパケットの滞在時間は、私たちが追跡したい正確に何であることを意味し、制御する必要がありますキューの長さが、原因永続または立っキューへの過剰な遅延パケット経験の量ではありません。バッファ内のパケットの滞在時間を追跡することは、各パケットによって経験される実際の遅延を観察します。滞在時間は、キュー管理は、リンク速度とは無関係であることを可能にするバッファサイズの使用に優れた性能を与え、ユーザーに表示性能に直接関係します。これは、（個々のキューが変化率として経験するかもしれない）複数のキューにより関わらず、ラインレートの変更やリンク共有の作品。"
    },
    {
      "indent": 3,
      "text": "Consider a link shared by two queues with different priorities. Packets that arrive at the high-priority queue are sent as soon as the link is available, while packets in the other queue have to wait until the high-priority queue is empty (i.e., a strict priority scheduler). The number of packets in the high-priority queue might be large, but the queue is emptied quickly, and the amount of time each packet spends enqueued (the sojourn time) is not large. The other queue might have a smaller number of packets, but packet sojourn times will include the waiting time for the high-priority packets to be sent. This makes the sojourn time a good sample of the congestion that each separate queue is experiencing. This example also shows how the metric of sojourn time is independent of the number of queues or the service discipline used and is instead indicative of congestion seen by the individual queues.",
      "ja": "優先度の異なる2つのキューが共有するリンクを考えてみましょう。高優先度のキューが空になるまで、他のキュー内のパケットが待機している間、高優先度キューに到着するパケットは、できるだけ早くリンクが利用可能であるとして送信される（すなわち、厳密な優先スケジューラ）。優先度の高いキューのパケットの数が多いかもしれませんが、キューはすぐに空にされ、各パケットはエンキューに費やす時間の量（滞在時間）が大きくありません。他のキューは、パケット数が少ないかもしれないが、優先度の高いパケットが送信されるため、パケットの滞在時間は、待機時間が含まれます。これは滞在時間、各個別のキューが発生している渋滞の良いサンプルになります。また、この例では、滞在時間のメトリックは、キューの数や使用されるサービス規律とは無関係であり、個々のキューから見混雑の代わりに、指標となる方法を示しています。"
    },
    {
      "indent": 3,
      "text": "How can observed sojourn time be used to separate \"good\" queue from \"bad\" queue? Although averages, especially of queue length, have previously been widely used as an indicator of \"bad\" queue, their efficacy is questionable. Consider the burst that disperses every round-trip time. The average queue will be one-half the burst size, though this might vary depending on when the average is computed and the timing of arrivals. The average queue sojourn time would be one-half the time it takes to clear the burst. The average then would indicate a persistent queue where there is none. Instead of averages, we recommend tracking the minimum sojourn time; then, if there is one packet that has a zero sojourn time, there is no persistent queue.",
      "ja": "どのように滞在時間を観察することができます「悪い」キューから「良い」キューを分離するために使用しますか？平均値は、特にキューの長さの、以前に広く「悪い」キューの指標として用いられてきたが、その有効性は疑問です。すべてのラウンドトリップ時間を分散させるバーストを考えてみましょう。この平均値が計算されるときに依存して変化し、到着のタイミングかもしれないけれども平均キューは、半分のバーストサイズであろう。平均キュー滞在時間は、それがバーストをクリアするのにかかる半分の時間になります。平均は、何もありません永続キューを示すことになります。代わりに、平均の、我々は最小滞在時間を追跡するお勧めします。ゼロ滞在時間を持っている一つのパケットがある場合は、その後、何の永続キューはありません。"
    },
    {
      "indent": 3,
      "text": "A persistent queue can be detected by tracking the (local) minimum queue delay packets experience. To ensure that this minimum value does not become stale, it has to have been experienced recently, i.e., during an appropriate past time interval. This interval is the maximum amount of time a minimum value is considered to be in effect and is related to the amount of time it takes for the largest expected burst to drain. Conservatively, this interval SHOULD be at least a round-trip time to avoid falsely detecting a persistent queue and not a lot more than a round-trip time to avoid delay in detecting the persistent queue. This suggests that the appropriate interval value is the maximum round-trip time of all the connections sharing the buffer.",
      "ja": "永続キューは、（ローカル）最小キュー遅延パケットの経験を追跡することによって検出することができます。この最小値は陳腐化しないことを確実にするために、適切な過去の時間間隔の間、すなわち、最近経験されている必要があります。この間隔は最小値が有効であると考えられ、それが排出する最大予想バーストのにかかる時間の量に関係している時間の最大量です。控えめに、この間隔が誤って永続キューを検出する際の遅延を避けるために、永続キューではなく往復時間よりも多くの検出を回避するために、少なくともラウンドトリップ時間であるべきです。これは、適切な間隔の値は、バッファを共有するすべての接続の最大ラウンドトリップ時間であることを示唆しています。"
    },
    {
      "indent": 3,
      "text": "Note that the following key insight makes computation of the local minimum efficient: it is sufficient to keep a single state variable that indicates how long the minimum has been above or below the target value rather than retaining all the local values to compute the minimum, which leads to both storage and computational savings. We use this insight in the pseudocode for CoDel later in the document.",
      "ja": "次のキーの洞察は、効率的な局所最小値の計算を行うことに注意してください。最小ではなく最小値を計算するために、すべてのローカル値を保持するよりも、目標値の上または下になっている期間を示し、単一の状態変数を維持するために十分ですストレージと計算の節約の両方につながります。私たちは、後に文書でCODELのための擬似コードでこの洞察を使用しています。"
    },
    {
      "indent": 3,
      "text": "These two parts, use of sojourn time as the observed value and the local minimum as the statistic to monitor queue congestion, are key to CoDel's estimator building block. The local minimum sojourn time provides an accurate and robust measure of standing queue and has an efficient implementation. In addition, use of the minimum sojourn time has important advantages in implementation. The minimum packet sojourn can only be decreased when a packet is dequeued, which means that all the work of CoDel can take place when packets are dequeued for transmission and that no locks are needed in the implementation. The minimum is the only statistic with this property.",
      "ja": "これらの二つの部分、キューの輻輳を監視するための統計として、観測値と極小値として滞在時間の使用は、CODELの推定ビルディングブロックへの鍵となります。極小滞在時間は立っキューの正確かつ堅牢な尺度を提供し、効率的な実装を持っています。また、最小滞在時間の使用が実装における重要な利点を有します。パケットがデキューされたときに最小のパケット滞在は、パケットだけを送信するためにと何もロックが実装に必要とされていないことをデキューする際にCODELのすべての作業を行うことができることを意味し、減少させることができます。最小値は、このプロパティを持つ唯一の統計です。"
    },
    {
      "indent": 3,
      "text": "A more detailed explanation with many pictures can be found in [TSV84].",
      "ja": "多くの写真と詳細な説明は、[TSV84]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Target Setpoint",
      "section_title": true,
      "ja": "3.2。目標設定値"
    },
    {
      "indent": 3,
      "text": "Now that we have a robust way of detecting standing queue, we need a target setpoint that tells us when to act. If the controller is set to take action as soon as the estimator has a non-zero value, the average drop rate will be maximized, which minimizes TCP goodput [MACTCP1997]. Also, this policy results in no backlog over time (no persistent queue), which negates much of the value of having a buffer, since it maximizes the bottleneck link bandwidth lost due to normal stochastic variation in packet interarrival time. We want a target that maximizes utilization while minimizing delay. Early in the history of packet networking, Kleinrock developed the analytic machinery to do this using a quantity he called \"power\", which is the ratio of a normalized throughput to a normalized delay [KLEIN81].",
      "ja": "今、私たちが立ってキューを検出する強力な方法を持っていることを、私たちは行動することを教えてくれる目標設定値を必要としています。コントローラは、推定器は、非ゼロ値を有するとすぐに行動を取るように設定されている場合、平均液滴速度は、TCPが[MACTCP1997]グッドプット最小化、最大化されるであろう。また、原因パケット到着時間間隔で通常の確率的変動にそれが失われたボトルネックリンクの帯域幅を最大化するために、バッファを持つことの価値の多くを否定時間をかけていないバックログ（なし永続キュー）、このポリシーの結果。私たちは、遅延を最小限に抑えながら利用率を最大化するターゲットをしたいです。早期パケットネットワークの歴史の中で、Kleinrockは、正規化遅延[KLEIN81]に正規化スループットの比である彼は「パワー」と呼ばれる量を使用してこれを行う分析機械を開発しました。"
    },
    {
      "indent": 3,
      "text": "It is straightforward to derive an analytic expression for the average goodput of a TCP conversation at a given round-trip time r and target f (where f is expressed as a fraction of r). Reno TCP, for example, yields:",
      "ja": "与えられたラウンドトリップ時間Rと、（fはRの割合として表される）標的fでTCP会話の平均グッドプットのための解析式を導出することは簡単です。リノTCP、例えば、利回り："
    },
    {
      "indent": 3,
      "text": "goodput = r (3 + 6f - f^2) / (4 (1+f))",
      "ja": "グッドプット= R（3 + 6F  -  F ^ 2）/（4（1 + F））"
    },
    {
      "indent": 3,
      "text": "Since the peak queue delay is simply the product of f and r, power is solely a function of f since the r's in the numerator and denominator cancel:",
      "ja": "ピークキュー遅延は、単にFとRの積であるので、消費電力は分子と分母キャンセルにRのため、単にfの関数であります："
    },
    {
      "indent": 3,
      "text": "power is proportional to (1 + 2f - 1/3 f^2) / (1 + f)^2",
      "ja": "電源はに比例している（1 + 2F  -  1/3 F ^ 2）/（1 + F）^ 2"
    },
    {
      "indent": 3,
      "text": "As Kleinrock observed, the best operating point (in terms of bandwidth/delay trade-off) is the peak power point, since points off the peak represent a higher cost (in delay) per unit of bandwidth. The power vs. f curve for any Additive Increase Multiplicative Decrease (AIMD) TCP is monotone decreasing. But the curve is very flat for f < 0.1, followed by an increasing curvature with a knee around f = 0.2, then a steep, almost linear fall off [TSV84]. Since the previous equation showed that goodput is monotone increasing with f, the best operating point is near the right edge of the flat top, since that represents the highest goodput achievable for a negligible increase in delay. However, since the r in the model is a conservative upper bound, a target of 0.1r runs the risk of pushing shorter RTT connections over the knee and giving them higher delay for no significant goodput increase. Generally, a more conservative target of 0.05r offers a good utilization vs. delay trade-off while giving enough headroom to work well with a large variation in real RTT.",
      "ja": "Kleinrockが観察されたようにピークオフ点は、帯域幅の単位（遅延）より高いコストを表しているので、（帯域幅/遅延のトレードオフの点で）最良の動作点は、ピーク電力点です。任意の添加のためのF曲線対電力が乗算減少（AIMD）TCPを増やし単調減少です。しかし、曲線は、その後、F = 0.2、[TSV84]オフ急峻な、ほぼ直線落下周り膝と共に増加曲率続い、F <0.1のために非常に平坦です。前式はグッドプットをfと単調増加であることを示したので、それは遅延の無視できる増加の達成可能な最高のグッドプットを表すので、最良の動作点は、フラットトップの右端近くにあります。モデルでrは保守的な上限であるので、0.1Rの目標は、膝の上に短いRTT接続をプッシュし、それらに有意なグッドプットの増加の高い遅延を与えることのリスクを実行します。実際のRTTの大きな変動でうまく動作するのに十分なヘッドルームを与えながら、一般的に、0.05rのより保守的な目標は、遅延のトレードオフ対良い利用を提供しています。"
    },
    {
      "indent": 3,
      "text": "As the above analysis shows, a very small standing queue gives close to 100% utilization of the bottleneck link. While this result was for Reno TCP, the derivation uses only properties that must hold for any \"TCP friendly\" transport. We have verified by both analysis and simulation that this result holds for Reno, Cubic, and Westwood [TSV84]. This results in a particularly simple form for the target: the ideal range for the permitted standing queue, or the target setpoint, is between 5% and 10% of the TCP connection's RTT.",
      "ja": "上記の分析が示すように、非常に小さなスタンディングキューは、ボトルネックリンクの100％の使用率に近い与えます。この結果はリノTCPのためでしたが、導出は任意の「TCPフレンドリー」輸送のために保持しなければならないプロパティのみを使用しています。私たちは、この結果はリノ、キュービック、およびウエストウッド[TSV84]のために保持していることを解析とシミュレーションの両方で確認しました。これは、ターゲットのための特に簡単な形式で結果：許容立ちキューのための理想的な範囲、または目標設定値は、5％とTCPコネクションのRTTの10％の間です。"
    },
    {
      "indent": 3,
      "text": "We used simulation to explore the impact when TCPs are mixed with other traffic and with connections of different RTTs. Accordingly, we experimented extensively with values in the 5-10% of RTT range and, overall, used target values between 1 and 20 milliseconds for RTTs from 30 to 500 ms and link bandwidths of 64 Kbps to 100 Mbps to experimentally explore a value for the target that gives consistently high utilization while controlling delay across a range of bandwidths, RTTs, and traffic loads. Our results were notably consistent with the mathematics above.",
      "ja": "私たちは、TCP間は他のトラフィックと異なるのRTTの接続と混合された場合の影響を調査するためにシミュレーションを使用していました。したがって、我々は、全体的な、実験の値を探索するために30〜500ミリ秒と100 Mbpsに64 Kbpsでのリンク帯域からのRTTのための1と20ミリ秒との間の目標値を用い、RTTの範囲の5〜10％の値で十分に実験と帯域幅、のRTT、及びトラフィック負荷の範囲にわたって遅延を制御しながら、一貫して高い利用率を与える目標。我々の結果は、上記の数学と著しく一致していました。"
    },
    {
      "indent": 3,
      "text": "A congested (but not overloaded) CoDel link with traffic composed solely or primarily of long-lived TCP flows will have a median delay through the link that will tend to the target. For bursty traffic loads and for overloaded conditions (where it is difficult or impossible for all the arriving flows to be accommodated), the median queues will be longer than the target.",
      "ja": "長命TCPフローの単独主に構成されるトラフィックで混雑した（しかし、過負荷にならない）CODELリンクがターゲットになる傾向があるリンクを介して中央値の遅延を持つことになります。 （すべての到着の流れが収容されることが困難または不可能である場合）、バースト的なトラフィックの負荷の場合や過負荷の条件のために、中央のキューが長く、目標よりもなります。"
    },
    {
      "indent": 3,
      "text": "The non-starvation drop inhibit feature dominates where the link rate becomes very small. By inhibiting drops when there is less than an (outbound link) MTU worth of bytes in the buffer, CoDel adapts to very low bandwidth links, as shown in [CODEL2012].",
      "ja": "リンク速度が非常に小さくなるところ非飢餓ドロップ禁止機能が支配します。 【CODEL2012]に示すように、バッファ内のバイト（アウトバウンドリンク）MTU分未満である場合に液滴を阻害することにより、CODELは、非常に低い帯域幅リンクを適応させます。"
    },
    {
      "indent": 0,
      "text": "3.3. Control Loop",
      "section_title": true,
      "ja": "3.3。制御ループ"
    },
    {
      "indent": 3,
      "text": "Section 3.1 describes a simple, reliable way to measure \"bad\" (persistent) queue. Section 3.2 shows that TCP congestion control dynamics gives rise to a target setpoint for this measure that's a provably good balance between enhancing throughput and minimizing delay. Section 3.2 also shows that this target is a constant fraction of the same \"largest average RTT\" interval used to distinguish persistent from transient queue. The only remaining building block needed for a basic AQM is a \"control loop\" algorithm to effectively drive the queueing system from any \"persistent queue above the target\" state to a state where the persistent queue is below the target.",
      "ja": "3.1節では、「悪い」（永続的な）キューを測定するための、シンプルで信頼性の高い方法を説明します。 3.2節は、TCP輻輳制御ダイナミクスは、スループットの向上と遅延の最小化との間に証明可能に良いバランスだこの対策のための目標設定値を生じさせることを示しています。 3.2節にも、この目標が一時キューから永続区別するために使用したのと同じ「最大の平均RTT」間隔の一定の部分であることを示しています。基本的なAQMに必要なだけ、残りのビルディングブロックを効果的に永続的なキューが目標を下回っている状態に、任意の「永続キューターゲット上」状態から待ち行列システムを駆動するための「制御ループ」アルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "Control theory provides a wealth of approaches to the design of control loops. Most of classical control theory deals with the control of linear, time-invariant, Single-Input-Single-Output (SISO) systems. Control loops for these systems generally come from a well-understood class known as Proportional-Integral-Derivative (PID) controllers. Unfortunately, a queue is not a linear system, and an AQM operates at the point of maximum non-linearity (where the output link bandwidth saturates, so increased demand creates delay rather than higher utilization). Output queues are also not time invariant since traffic is generally a mix of connections that start and stop at arbitrary times and that can have radically different behaviors ranging from \"open-loop\" UDP audio/video to \"closed-loop\" congestion-avoiding TCP. Finally, the constantly changing mix of connections (which can't be converted to a single \"lumped parameter\" model because of their transfer function differences) makes the system Multi-Input-Multi-Output (MIMO), not SISO.",
      "ja": "制御理論は、制御ループの設計へのアプローチの富を提供します。線形の制御に古典制御理論のお得な情報のほとんどは、時間不変、単一入力単一出力（SISO）システム。制御は、比例積分微分（PID）コントローラとしても知られているよく理解クラスから来て、これらのシステムのためのループ。残念ながら、待ち行列は、線形システムではなく、AQMは、最大非直線性の点で動作（出力リンクの帯域幅が飽和するので、需要の増加ではなく、高い利用率よりも遅延が作成されます）。トラフィックはUDPのオーディオ/ビデオの「クローズドループ」輻輳回避TCP開始し、任意のタイミングで停止し、それは「オープンループ」に至るまで根本的に異なる振る舞いを持つことができる接続のミックスが一般的であるため、出力キューも不変の時間ではありません。最後に、（ため、その伝達関数の差異のシングル「集中パラメータ」モデルに変換できない）接続の絶えず変化するミックスはシステム多入力多出力（MIMO）、ないSISOます。"
    },
    {
      "indent": 3,
      "text": "Since queueing systems match none of the prerequisites for a classical controller, a better approach is a modern state-space controller with \"no persistent queue\" and \"has persistent queue\" states. Since Internet traffic mixtures change rapidly and unpredictably, a noise- and error-tolerant adaptation algorithm like stochastic gradient is a good choice. Since there's essentially no information in the amount of persistent queue [TSV84], the adaptation should be driven by how long it has persisted.",
      "ja": "キューイング・システムは、古典的なコントローラのための前提条件のどれもが一致しないため、より良いアプローチは、「いいえ永続キュー」と「持っている永続キュー」状態を持つ近代的な状態空間コントローラがあります。インターネットトラフィックの混合物を迅速かつ予測不能に変化するので、確率的勾配のようなnoise-とエラー耐性の適応アルゴリズムは良い選択です。基本的に永続キュー[TSV84]の量には情報がないので、適応は、それが持続している時間の長さによって駆動されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Consider the two extremes of traffic behavior: a single, open-loop UDP video stream and a single, long-lived TCP bulk data transfer. If the average bandwidth of the UDP video stream is greater than the bottleneck link rate, the link's queue will grow, and the controller will eventually enter \"has persistent queue\" state and start dropping packets. Since the video stream is open loop, its arrival rate is unaffected by drops, so the queue will persist until the average drop rate is greater than the output bandwidth deficit (= average arrival rate - average departure rate); the job of the adaptation algorithm is to discover this rate. For this example, the adaptation could consist of simply estimating the arrival and departure rates and then dropping at a rate slightly greater than their difference, but this class of algorithm won't work at all for the bulk data TCP stream. TCP runs in closed-loop flow balance [TSV84], so its arrival rate is almost always exactly equal to the departure rate -- the queue isn't the result of a rate imbalance but rather a mismatch between the TCP sender's window and the source-destination-source round-trip path capacity (i.e., the connection's bandwidth-delay product). The sender's TCP congestion avoidance algorithm will slowly increase the send window (one packet per round-trip time) [RFC5681], which will eventually cause the bottleneck to enter \"has persistent queue\" state. But, since the average input rate is the same as the average output rate, the rate deficit estimation that gave the correct drop rate for the video stream would compute a drop rate of zero for the TCP stream. However, if the output link drops one packet as it enters \"has persistent queue\" state, when the sender discovers this (via TCP's normal packet loss repair mechanisms), it will reduce its window by a factor of two [RFC5681]; so, one round-trip time after the drop, the persistent queue will go away.",
      "ja": "シングル、オープンループUDPのビデオストリームとシングル、長寿命のTCPバルクデータ転送：交通行動の両極端を考えます。 UDPのビデオストリームの平均帯域幅がボトルネックリンク速度よりも大きい場合は、リンクのキューが成長すると、コントローラは最終的に入ります状態「永続キューを持っている」と、パケットをドロップし始めます。ビデオストリームが開ループであるため、その到着速度が低下によって影響を受けないので、平均液滴速度が出力帯域不足（=平均到着率 - 平均出発率）よりも大きくなるまで待ち行列が維持されます。適応アルゴリズムの仕事は、このレートを発見することです。この例では、適応は単に到着と出発率を推定して、その差よりわずかに速い速度で落下から構成できますが、アルゴリズムのこのクラスは、バルクデータのTCPストリームのためにまったく動作しません。 TCPは、クローズド・ループ・フロー・バランス[TSV84]で実行されますので、その到着率はほぼ必ず出発率に正確に等しいです - キューは、レートの不均衡の結果ではなく、TCP送信者のウィンドウとソースの間のミスマッチではありません-destination-ソースの往復路容量（すなわち、接続の帯域幅遅延積）。送信側のTCP輻輳回避アルゴリズムは、ゆっくりと、最終的にボトルネックが「持っている永続キュー」状態に入ることになります送信ウィンドウ（ラウンドトリップ時間あたり1つのパケット）[RFC5681]を、大きくなります。平均入力速度は平均出力レートと同じであるので、しかし、ビデオストリームの正しいドロップ率を与えたレート赤字推定は、TCPストリームのためのゼロのドロップ率を計算します。出力リンクは、それが入るように、1つのパケットをドロップした場合、送信者は、それが2 [RFC5681]の要因によって、そのウィンドウを削減します（TCPの通常のパケット損失修復機構を経由して）これを発見したときただし、状態「永続キューを持っています」。そう、1往復時間ドロップした後、永続キューが消えます。"
    },
    {
      "indent": 3,
      "text": "If there were N TCP conversations sharing the bottleneck, the controller would have to drop O(N) packets (one from each conversation) to make all the conversations reduce their window to get rid of the persistent queue. If the traffic mix consists of short (<= bandwidth-delay product) conversations, the aggregate behavior becomes more like the open-loop video example since each conversation is likely to have already sent all its packets by the time it learns about a drop so each drop has negligible effect on subsequent traffic.",
      "ja": "ボトルネックを共有するN TCPの会話があった場合、コントローラは、O（N）パケットを廃棄するすべての会話は、永続キューを取り除くために自分のウィンドウを減らすようにする（各会話からのもの）を持っているでしょう。トラフィックミックスが短い（<=帯域遅延積）の会話で構成されている場合は、それぞれの会話はすでにそれはそうドロップについて学習の時間ですべてのパケットを送信した可能性があるため、集計行動は、よりオープンループビデオの例のようになり、各ドロップは、後続のトラフィックにはほとんど効果があります。"
    },
    {
      "indent": 3,
      "text": "The controller does not know the number, duration, or kind of conversations creating its queue, so it has to learn the appropriate response. Since single drops can have a large effect if the degree of multiplexing (the number of active conversations) is small, dropping at too high a rate is likely to have a catastrophic effect on throughput. Dropping at a low rate (< 1 packet per round-trip time) and then increasing the drop rate slowly until the persistent queue goes below the target is unlikely to overdrop and is guaranteed to eventually dissipate the persistent queue. This stochastic gradient learning procedure is the core of CoDel's control loop (the gradient exists because a drop always reduces the (instantaneous) queue, so an increasing drop rate always moves the system \"down\" toward no persistent queue, regardless of traffic mix).",
      "ja": "コントローラは、そのキューを作成する会話の数、期間、または種類を知らないので、それは適切な応答を学ばなければなりません。多重度（アクティブな会話の数）が小さい場合、単一の液滴が高すぎる速度で滴下し、大きな効果を持つことができるので、スループットに壊滅的な影響を有する可能性があります。低レート（往復時間あたり<1つのパケット）で削除した後、永続キューは、ターゲットを下回るまで、ゆっくりとドロップ率を増加させるとoverdropすることはほとんどありませんし、最終的に永続キューを放散することが保証されます。この確率的勾配学習手順（ドロップがいつも増加ドロップ率は関係なく、常にトラフィックミックスの、ない永続キューに向けたシステム「ダウン」に移動し、（瞬時）キューが減少するため、勾配が存在する）CODELの制御ループの中核です。"
    },
    {
      "indent": 3,
      "text": "The \"next drop time\" is decreased in inverse proportion to the square root of the number of drops since the drop state was entered, using the well-known non-linear relationship of drop rate to throughput to get a linear change in throughput [REDL1998][MACTCP1997].",
      "ja": "落下状態が入力されたので、「次落下時間」REDL1998 [スループットの線形変化を取得するスループットの低下率のよく知られた非線形な関係を用いて、液滴の数の平方根に反比例して減少します] [MACTCP1997]。"
    },
    {
      "indent": 3,
      "text": "Since the best rate to start dropping is at slightly more than one packet per RTT, the controller's initial drop rate can be directly derived from the estimator's interval. When the minimum sojourn time first crosses the target and CoDel drops a packet, the earliest the controller could see the effect of the drop is the round-trip time (interval) + the local queue wait time (the target). If the next drop happens any earlier than this time (interval + target), CoDel will overdrop. In practice, the local queue waiting time tends to vary, so making the initial drop spacing (i.e., the time to the second drop) be exactly the minimum possible also leads to overdropping. Analysis of simulation and real-world measured data shows that the 75th percentile magnitude of this variation is less than the target, so the initial drop spacing SHOULD be set to the estimator's interval (i.e., initial drop spacing = interval) to ensure that the controller has accounted for acceptable congestion delays.",
      "ja": "滴下を開始するための最良のレートはRTTごとにわずかに1つ以下のパケットであるため、コントローラの最初の降下速度を直接推定の間隔に由来することができます。最小滞在時間が第1目標と交差しCODELはパケットを廃棄するとき、最も早いコントローラは、ドロップの効果がラウンドトリップ時間（間隔）+ローカル・キュー待ち時間（ターゲット）で見ることができます。次のドロップがこの時間（インターバル+ターゲット）よりも以前のような場合、CODELはoverdropます。実際には、待ち時間のローカルキューがので（すなわち、第二の降下時間）を正確に最小可能でもoverdroppingにつながる最初の滴間隔を作り、変化する傾向があります。シミュレーションと実世界の測定データの分析は、この変動の75パーセンタイルの大きさが目標未満であることを示しているので、最初のドロップ間隔は、コントローラことを確認するために、推定量の間隔（すなわち、最初のドロップ間隔=間隔）に設定する必要があります許容混雑遅延を占めています。"
    },
    {
      "indent": 3,
      "text": "Use of the minimum statistic lets the controller be placed in the dequeue routine with the estimator. This means that the control signal (the drop) can be sent at the first sign of \"bad\" queue (as indicated by the sojourn time) and that the controller can stop acting as soon as the sojourn time falls below the target. Dropping at dequeue has both implementation and control advantages.",
      "ja": "最小統計の使用は、コントローラは、推定でデキュールーチンに配置することができます。これは、制御信号（ドロップ）が（滞在時間によって示されるように）「悪い」キューの最初の兆候で送信され、コントローラは、すぐに滞在時間が目標を下回るように作用する停止することができることができることを意味します。デキューで落とすと、実装と管理の両方の利点を有しています。"
    },
    {
      "indent": 0,
      "text": "4. Overview of the CoDel AQM",
      "section_title": true,
      "ja": "CODEL AQMの4概要"
    },
    {
      "indent": 3,
      "text": "CoDel was initially designed as a bufferbloat solution for the consumer network edge. The CoDel building blocks are able to adapt to different or time-varying link rates, be easily used with multiple queues, have excellent utilization with low delay, and have a simple and efficient implementation.",
      "ja": "CODELは、最初に消費者ネットワークエッジ用bufferbloat溶液として設計されました。 CODELのビルディングブロックは、異なるまたは時間的に変化するリンク速度に適応することができます簡単に複数のキューを使用すること、低遅延で優れた利用を持ち、シンプルかつ効率的な実装を持っています。"
    },
    {
      "indent": 3,
      "text": "The CoDel algorithm described in the rest of this document uses two key variables: TARGET, which is the controller's target setpoint described in Section 3.2, and INTERVAL, which is the estimator's interval described in Section 3.3.",
      "ja": "セクション3.2で説明コントローラの目標設定値である目標、およびセクション3.3に記載推定の間隔であるINTERVAL、この文書の残りの部分に記載さCODELアルゴリズムは、2つの重要な変数を使用します。"
    },
    {
      "indent": 3,
      "text": "The only setting CoDel requires is the INTERVAL value, and as 100 ms satisfies that definition for normal Internet usage, CoDel can be parameter-free for consumer use. To ensure that link utilization is not adversely affected, CoDel's estimator sets TARGET to one that optimizes power. CoDel's controller does not drop packets when the drop would leave the queue empty or with fewer than a Maximum Transmission Unit (MTU) worth of bytes in the buffer. Section 3.2 shows that an ideal TARGET is 5-10% of the connection round-trip time (RTT). In the open terrestrial-based Internet, especially at the consumer edge, we expect most unbloated RTTs to have a ceiling of 100 ms [CHARB2007]. Using this RTT gives a minimum TARGET of 5 ms and INTERVAL of 100 ms. In practice, uncongested links will see sojourn times below TARGET more often than once per RTT, so the estimator is not overly sensitive to the value of INTERVAL.",
      "ja": "設定のみCODEL必要ではINTERVALの値であり、100ミリ秒を満たす通常のインターネット利用のためのその定義として、CODELは、パラメータなしの民生用することができます。そのリンクの利用率が悪影響を受けていないことを確認するには、CODELの推定量は、電力を最適化1にターゲットを設定します。ドロップが空またはバッファ内のバイトの最大伝送ユニット（MTU）の価値よりも少ないとキューを離れるときCODELのコントローラーはパケットをドロップしません。セクション3.2は、理想的なターゲットが接続ラウンドトリップ時間（RTT）の5〜10％であることを示しています。オープン地上ベースのインターネットでは、特に消費者のエッジで、我々は最もunbloatedのRTTが100ms [CHARB2007]の天井を持つことを期待します。このRTTを使用すると、5ミリと100ミリ秒の間隔の最小TARGETを与えます。推定器は、INTERVALの値に過度に敏感ではないので、実際には、非輻輳リンクは、より頻繁に一度RTTあたりよりTARGETの下に滞在時間が表示されます。"
    },
    {
      "indent": 3,
      "text": "When the estimator finds a persistent delay above TARGET, the controller enters the drop state where a packet is dropped, and the next drop time is set. As discussed in Section 3.3, the initial next drop spacing is intended to be long enough to give the endpoints time to react to the single drop and therefore SHOULD be set to a value equal to INTERVAL. If the estimator's output falls below TARGET, the controller cancels the next drop and exits the drop state. (The controller is more sensitive than the estimator to an overly short INTERVAL value, since an unnecessary drop would occur and lower link utilization). If the next drop time is reached while the controller is still in drop state, the packet being dequeued is dropped, and the next drop time is recalculated.",
      "ja": "推定は、ターゲット上の永続的遅延を検出すると、コントローラは、パケットがドロップされるドロップ状態に入り、次の落下時間が設定されます。セクション3.3で議論するように、最初の次のドロップ間隔は、単一のドロップに反応するエンドポイントの時間を与えるために十分な長さであることが意図され、従って間隔と等しい値に設定されるべきです。推定量の出力が目標を下回った場合、コントローラは次のドロップをキャンセルし、落下状態を終了します。 （コントローラが不要降下が発生するので、過度に短い間隔値に推定より敏感であり、下側のリンク利用率）。コントローラが落下状態にある間、次の落下時間に達した場合、デキューされたパケットは廃棄され、次の落下時間が再計算されます。"
    },
    {
      "indent": 3,
      "text": "Additional logic prevents re-entering the drop state too soon after exiting it and resumes the drop state at a recent control level, if one exists. This logic is described more precisely in the pseudocode below. Additional work is required to determine the frequency and importance of re-entering the drop state.",
      "ja": "追加のロジックがあまりにも早くそれを出た後に再入力ドロップの状態を防ぎ、1が存在する場合は、最近の制御レベルでの落下状態を再開します。このロジックは、以下の擬似コードでより正確に記述されています。追加の作業が落下状態を再入力の頻度や重要性を決定するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "Note that CoDel AQM only enters its drop state when the local minimum sojourn delay has exceeded TARGET for a time period long enough for normal bursts to dissipate, ensuring that a burst of packets that fits in the pipe will not be dropped.",
      "ja": "CODEL AQMのみパイプに収まるパケットのバーストがドロップされないことを保証する、極小滞在遅延は通常バーストが消散させるために十分に長い時間のための目標を超えたその落下状態に入ることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "4.1. Non-starvation",
      "section_title": true,
      "ja": "4.1。非飢餓"
    },
    {
      "indent": 3,
      "text": "CoDel's goals are to control delay with little or no impact on link utilization and to be deployed on a wide range of link bandwidths, including variable-rate links, without reconfiguration. To keep from making drops when it would starve the output link, CoDel makes another check before dropping to see if at least an MTU worth of bytes remains in the buffer. If not, the packet SHOULD NOT be dropped; therefore, CoDel exits the drop state. The MTU size can be set adaptively to the largest packet seen so far or can be read from the interface driver.",
      "ja": "CODELの目標は、リンク使用率にほとんど、あるいはまったく影響で遅延を制御し、再構成することなく、可変レートリンクを含むリンク帯域幅の広い範囲に展開することになっています。それは出力リンクを餓死だろうというとき滴を行うことから保つために、CODELはバイトの少なくともMTUの価値がバッファに残っているかどうかを確認するために削除する前に別のチェックを行います。そうでない場合、パケットはドロップされるべきではありません。そのため、CODELは落下状態を終了します。 MTUサイズは、これまで見やインタフェースドライバから読み取ることができる最大のパケットに適応的に設定することができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Setting INTERVAL",
      "section_title": true,
      "ja": "4.2。間隔の設定"
    },
    {
      "indent": 3,
      "text": "The INTERVAL value is chosen to give endpoints time to react to a drop without being so long that response times suffer. CoDel's estimator, TARGET, and control loop all use INTERVAL. Understanding their derivation shows that CoDel is the most sensitive to the value of INTERVAL for single long-lived TCPs with a decreased sensitivity for traffic mixes. This is fortunate, as RTTs vary across connections and are not known a priori. The best policy seems to be to use an INTERVAL value slightly larger than the RTT seen by most of the connections using a link, a value that can be determined as the largest RTT seen if the value is not an outlier (use of a 95-99th percentile value should work). In practice, this value is not known or measured (however, see Appendix A for an application where INTERVAL is measured). An INTERVAL setting of 100 ms works well across a range of RTTs from 10 ms to 1 second (excellent performance is achieved in the range from 10 ms to 300 ms). For devices intended for the normal terrestrial Internet, INTERVAL SHOULD have a value of 100 ms. This will only cause overdropping where a long-lived TCP has an RTT longer than 100 ms and there is little or no mixing with other connections through the link.",
      "ja": "INTERVAL値は、エンドポイントに応答時間が被るように長いことなくドロップに反応する時間を与えるように選択されます。 CODELの推定、TARGET、および制御ループのすべては、INTERVALを使用しています。彼らの導出を理解することはCODELがトラフィックミックスのために減少した感度を持つ単一の長命のTCPのインターバルの値に最も敏感であることを示しています。 RTTが接続間で変動し、事前に知られていないので、これは、幸運です。最善の策は、値が外れ値（95-の使用がない場合は接続のほとんどは、リンク、見最大RTTとして求めることができる値を使用して見たRTTよりもわずかに大きいINTERVAL値を使用するように思わ99パーセンタイル値）が動作するはずです。実際には、この値は知られていないか（ただし、間隔が測定されるアプリケーションについては、付録Aを参照）を測定しました。 100ミリ秒の間隔の設定は、（優れた性能は、10ミリ秒から300ミリ秒の範囲で達成される）1秒に10ミリからのRTTの範囲にわたって良好に機能します。通常の地上インターネットのために意図デバイスの場合、間隔は100ミリ秒の値を持つ必要があります。これは、長寿命のTCPが長く、100ミリ秒よりもRTTを持ち、リンクを介して他の接続とほとんど、あるいはまったく混入がある場合overdropping原因になります。"
    },
    {
      "indent": 0,
      "text": "4.3. Setting TARGET",
      "section_title": true,
      "ja": "4.3。目標設定"
    },
    {
      "indent": 3,
      "text": "TARGET is the maximum acceptable persistent queue delay above which CoDel is dropping or preparing to drop and below which CoDel will not drop. TARGET SHOULD be set to 5 ms for normal Internet traffic.",
      "ja": "TARGETはCODELが落下またはドロップし、それ以下CODELが低下しないであろう準備され上方に最大許容永続キュー遅延です。 TARGETは、通常のインターネットトラフィックの5ミリ秒に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The calculations of Section 3.2 show that the best TARGET value is 5-10% of the RTT, with the low end of 5% preferred. Extensive simulations exploring the impact of different TARGET values when used with mixed traffic flows with different RTTs and different bandwidths show that below a TARGET of 5 ms, utilization suffers for some conditions and traffic loads; above 5 ms showed very little or no improvement in utilization.",
      "ja": "3.2節の計算は最高の目標値は、好ましくは、5％のローエンドで、RTTの5〜10％のあることを示しています。混合トラフィックに使用される場合、異なる目標値の影響を探索する広範なシミュレーションは、5ミリ秒のTARGETの下、利用は、いくつかの条件およびトラフィック負荷のために苦しんでいることを示す別のRTTと異なる帯域幅で流れます。 5ミリ秒を超える利用が非常にほとんど、あるいはまったく改善を示しました。"
    },
    {
      "indent": 3,
      "text": "Sojourn times must remain above the TARGET for INTERVAL amount of time in order to enter the drop state. Any packet with a sojourn time less than TARGET will reset the time that the queue was last below TARGET. Since Internet traffic has very dynamic characteristics, the actual sojourn delay experienced by packets varies greatly and is often less than TARGET unless the overload is excessive. When a link is not overloaded, it is not a bottleneck, and packet sojourn times will be small or nonexistent. In the usual case, there are only one or two places along a path where packets will encounter a bottleneck (usually at the edge), so the total amount of queueing delay experienced by a packet should be less than 10 ms even under extremely congested conditions. This net delay is substantially lower than common current queueing delays on the Internet that grow to orders of seconds [NETAL2010] [CHARB2007].",
      "ja": "滞在時間はドロップ状態に入るために時間間隔金額のTARGET以上でなければなりません。以下TARGET以上滞在時間を持つ任意のパケットはキューがTARGET以下の最後にあったことを時間をリセットします。インターネットトラフィックは非常に動的な特性を有しているので、パケットが経験する実際の滞在遅延が大きく変動し、過負荷が過剰でない限りTARGETよりもしばしば小さいです。リンクが過負荷にされていない場合は、それがボトルネックではなく、パケットの滞在時間は、小規模または存在しないだろう。通常の場合、パケットは、（通常はエッジで）ボトルネックに遭遇する経路に沿って1つまたは2つの場所が存在するので、パケットが経験する遅延キューイングの合計量も非常に混雑した条件下で10ミリ秒未満であるべきです。このネットの遅延は、[NETAL2010] [CHARB2007]秒のオーダーまで成長するインターネット上の一般的な現在のキューイング遅延よりも実質的に低いです。"
    },
    {
      "indent": 3,
      "text": "Regarding the roles of TARGET and the minimum-tracking INTERVAL, note that TARGET SHOULD NOT be increased in response to lower layers that have a bursty nature, where packets are transmitted for short periods interspersed with idle periods where the link is waiting for permission to send. CoDel's estimator will \"see\" the effective transmission rate over an INTERVAL amount of time, and increasing TARGET only leads to longer queue delays. On the other hand, where a significant additional delay is added to the intrinsic RTT of most or all packets due to the waiting time for a transmission, it is necessary to increase INTERVAL by that extra delay. TARGET SHOULD NOT be adjusted for such short-term bursts, but INTERVAL MAY need to be adjusted if the path's intrinsic RTT changes.",
      "ja": "そのTARGETに注意し、TARGETと最小追跡INTERVALの役割に関してするパケットは、リンクを送信するための許可を待っているアイドル期間が散在し、短い期間のために送信され、バースト性を持つ下位層に応じて増加されるべきではありません。 CODELの推定量は、時間のINTERVAL量を超える実効伝送速度「を参照してください」、およびTARGETを増やすことだけ長くキューの遅延につながります。大幅な追加の遅延は、伝送のための待ち時間のために、ほとんどまたはすべてのパケットの固有RTTに追加される一方、その余分な遅延によって間隔を長くする必要があります。 TARGETは、このような短期的なバーストのために調整されるべきではなく、パスの固有のRTTが変化した場合に間隔を調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Use with Multiple Queues",
      "section_title": true,
      "ja": "4.4。複数のキューを使用します"
    },
    {
      "indent": 3,
      "text": "CoDel is easily adapted to multiple queue systems. With other approaches, there is always a question of how to account for the fact that each queue receives less than the full link rate over time and usually sees a varying rate over time. This is what CoDel excels at: using a packet's sojourn time in the buffer completely circumvents this problem. In a multiple-queue setting, a separate CoDel algorithm runs on each queue, but each CoDel instance uses the packet sojourn time the same way a single-queue CoDel does. Just as a single-queue CoDel adapts to changing link bandwidths [CODEL2012], so does a multiple-queue CoDel system. As an optimization to avoid queueing more than necessary, when testing for queue occupancy before dropping, the total occupancy of all queues sharing the same output link SHOULD be used. This property of CoDel has been exploited in fq_codel [RFC8290], which hashes on the packet header fields to determine a specific bin, or sub-queue, for the packet and runs CoDel on each bin or sub-queue, thus creating a well-mixed output flow and obviating issues of reverse path flows (including \"ack compression\").",
      "ja": "CODELは、簡単に複数のキューシステムに適合しています。他のアプローチでは、各キューは、時間をかけて完全なリンクレート未満を受け取り、通常は時間の経過とともに変化率を見ているという事実を考慮する方法の質問が常にあります。この問題を完全に回避するバッファ内のパケットの滞在時間を使用して：これはCODELが得意とするものです。複数キューの設定では、別個CODELアルゴリズムは、各キュー上で動作するが、各CODELインスタンスは、パケットの滞在時間を単一キューCODELと同じ方法を使用します。ただ、CODELは[CODEL2012]、ので、複数のキューCODELシステムを行い、リンク帯域幅の変化に適応し、シングルキューとして。削除する前に、キュー占有のためにテストするときに、必要以上にキューイング回避するための最適化として、同じ出力リンクを共有するすべてのキューの合計占有を使用する必要があります。 CODELのこの特性は、このように十分に作成、パケットのために、特定のビン、またはサブキューを決定するために、パケットのヘッダフィールドにハッシュし、各ビンまたはサブキューにCODELを実行fq_codel [RFC8290]で利用されています逆パスの混合出力流となくなる問題は（「ACK圧縮」を含む）が流れます。"
    },
    {
      "indent": 0,
      "text": "4.5. Setting Up CoDel",
      "section_title": true,
      "ja": "4.5。 CODELの設定"
    },
    {
      "indent": 3,
      "text": "CoDel is set for use in devices in the open Internet. An INTERVAL setting of 100 ms is used, TARGET is set to 5% of INTERVAL, and the initial drop spacing is also set to the INTERVAL. These settings have been chosen so that a device, such as a small WiFi router, can be sold without the need for any values to be made adjustable, yielding a parameterless implementation. In addition, CoDel is useful in environments with significantly different characteristics from the normal Internet, for example, in switches used as a cluster interconnect within a data center. Since cluster traffic is entirely internal to the data center, round-trip latencies are low (typically <100 us) but bandwidths are high (1-40 Gbps), so it's relatively easy for the aggregation phase of a distributed computation (e.g., the Reduce part of a Map/Reduce) to persistently fill and then overflow the modest per-port buffering available in most high-speed switches. A CoDel configured for this environment (TARGET and INTERVAL in the microsecond rather than millisecond range) can minimize drops or Explicit Congestion Notification (ECN) marks while keeping throughput high and latency low.",
      "ja": "CODELは、オープンなインターネット内のデバイスで使用するために設定されています。 100ミリ秒の間隔の設定が使用され、ターゲットは、INTERVALの5％に設定され、初期液滴間隔も間隔に設定されています。これらの設定が選択されているように、このような小さなWiFiルーターなどのデバイスは、パラメータなしの実装を得、調整可能とする任意の値を必要とせずに販売することができます。また、CODELは、通常、インターネットから著しく異なる特性を持つ環境において、例えば、データセンター内のクラスタ・インターコネクトとして使用されるスイッチに有用です。クラスタトラフィックがデータセンターに完全に内蔵されているので、（例えば、ラウンドトリップレイテンシが（100たちを、通常<）低いですが、帯域幅は、（1-40 Gbps）の高いので、分散計算の集計段階では比較的簡単です持続的に記入して、最も高速スイッチで利用できるささやかなポート単位のバッファリングをオーバーフローする）削減/地図の一部を削減します。スループット高いレイテンシを低く保ちながら、この環境（TARGETとINTERVALマイクロ秒ではなくミリ秒の範囲）用に構成さCODELは液滴または明示的輻輳通知（ECN）マークを最小化することができます。"
    },
    {
      "indent": 3,
      "text": "Devices destined for these environments MAY use a different value for INTERVAL, where suitable. If appropriate analysis indicates, the TARGET MAY be set to some other value in the 5-10% of INTERVAL, and the initial drop spacing MAY be set to a value of 1.0 to 1.2 times INTERVAL. But these settings will cause problems, such as overdropping and low throughput, if used on the open Internet, so devices that allow CoDel to be configured SHOULD default to the Internet-appropriate values given in this document.",
      "ja": "これらの環境に宛てたデバイスは、適当な間隔ごとに異なる値を使用するかもしれません。適切な分析が示す場合、TARGETは、INTERVALの5〜10％、いくつかの他の値に設定されてもよく、初期液滴間隔は、1.0倍〜1.2 INTERVALの値に設定することができます。オープンなインターネット上で使用されている場合CODELを設定することを可能にするデバイスは、この文書に与えられ、インターネットの適切な値をデフォルトにする必要がありますのでしかし、これらの設定は、このようなoverdroppingや低いスループットなどの問題を引き起こします。"
    },
    {
      "indent": 0,
      "text": "5. Annotated Pseudocode for CoDel AQM",
      "section_title": true,
      "ja": "CODEL AQM 5.注釈付き擬似コード"
    },
    {
      "indent": 3,
      "text": "What follows is the CoDel algorithm in C++-like pseudocode. Since CoDel adds relatively little new code to a basic tail-drop FIFO queue, we have attempted to highlight just these additions by presenting CoDel as a sub-class of a basic FIFO queue base class. The reference code is included to aid implementers who wish to apply CoDel to queue management as described here or to adapt its principles to other applications.",
      "ja": "擬似コードのように - 以下は、C ++でのCODELアルゴリズムです。 CODELは、基本的なテールドロップFIFOキューに比較的少ない新しいコードを追加しているので、私たちは、基本的なFIFOキューベースクラスのサブクラスとしてCODELを提示することによって、単にこれらの追加を強調しようとしてきました。参照コードは、ここで説明するように管理をキューにCODELを適用するか、他のアプリケーションにその原則を適応したい実装を支援するために含まれています。"
    },
    {
      "indent": 3,
      "text": "Implementors are strongly encouraged to also look at the Linux kernel version of CoDel -- a well-written, well-tested, real-world, C-based implementation. As of this writing, it is available at https://github.com/torvalds/linux/blob/master/net/sched/sch_codel.c.",
      "ja": "よく書かれた、十分にテストされ、現実世界、Cベースの実装 - 実装者は強くもCODELのLinuxカーネルのバージョンを見てすることをお勧めします。この記事の執筆時点で、それはhttps://github.com/torvalds/linux/blob/master/net/sched/sch_codel.cで入手可能です。"
    },
    {
      "indent": 0,
      "text": "5.1. Data Types",
      "section_title": true,
      "ja": "5.1。データの種類"
    },
    {
      "indent": 3,
      "text": "time_t is an integer time value in units convenient for the system. The code presented here uses 0 as a flag value to indicate \"no time set.\"",
      "ja": "time_tのシステムのための便利な単位の整数時間値です。ここに提示コードは示していないためにフラグの値として0を使用する「は時間設定」を"
    },
    {
      "indent": 3,
      "text": "packet_t* is a pointer to a packet descriptor. We assume it has a tstamp field capable of holding a time_t and that the field is available for use by CoDel (it will be set by the enqueue routine and used by the dequeue routine).",
      "ja": "packet_t *は、パケット記述子へのポインタです。私たちは、それがのtime_tを保持できるTSTAMPフィールドを持ち、フィールドがCODEL（それがエンキュールーチンによって設定され、デキュールーチンによって使用される）によって使用可能であることを前提としています。"
    },
    {
      "indent": 3,
      "text": "queue_t is a base class for queue objects (the parent class for codel_queue_t objects). We assume it has enqueue() and dequeue() methods that can be implemented in child classes. We assume it has a bytes() method that returns the current queue size in bytes. This can be an approximate value. The method is invoked in the dequeue() method but shouldn't require a lock with the enqueue() method.",
      "ja": "たqueue_tは、キューオブジェクト（codel_queue_tオブジェクトの親クラス）の基本クラスです。私たちは、それがエンキュー（）およびデキュー（）子クラスで実装することができるメソッドを持っていると仮定します。我々は、それがバイト単位で現在のキューのサイズを返しバイト（）メソッドを持っていると仮定します。これは、おおよその値にすることができます。この方法は、デキュー（）メソッドで呼び出されるが、エンキュー（）メソッドを使用してロックを必要とすべきではありません。"
    },
    {
      "indent": 3,
      "text": "flag_t is a Boolean.",
      "ja": "flag_tはブール値です。"
    },
    {
      "indent": 0,
      "text": "5.2. Per-Queue State (codel_queue_t Instance Variables)",
      "section_title": true,
      "ja": "5.2。キューごとの状態（インスタンス変数codel_queue_t）"
    },
    {
      "indent": 3,
      "text": "time_t first_above_time_ = 0; // Time to declare sojourn time above // TARGET time_t drop_next_ = 0; // Time to drop next packet uint32_t count_ = 0; // Packets dropped in drop state uint32_t lastcount_ = 0; // Count from previous iteration flag_t dropping_ = false; // Set to true if in drop state",
      "ja": "time_t first_above_time_ = 0。 //時間は// TARGETのtime_t drop_next_ = 0上記の滞在時間を宣言する。 //時間がドロップする次のパケットのuint32_tのcount_ = 0; //パケットはドロップ状態で落下のuint32_t lastcount_ = 0。 // flag_t dropping_ = falseの前の反復から数えます。 //ドロップ状態にある場合はtrueに設定"
    },
    {
      "indent": 0,
      "text": "5.3. Constants",
      "section_title": true,
      "ja": "5.3。定数"
    },
    {
      "indent": 3,
      "text": "time_t TARGET = MS2TIME(5); // 5 ms TARGET queue delay time_t INTERVAL = MS2TIME(100); // 100 ms sliding-minimum window u_int maxpacket = 512; // Maximum packet size in bytes // (SHOULD use interface MTU)",
      "ja": "time_t TARGET = MS2TIME（5）。 // 5ミリTARGETキュー遅延のtime_t INTERVAL = MS2TIME（100）。 // 100ミリ秒スライディング最小ウィンドウu_int maxpacket = 512。 //バイトの最大パケットサイズ//（インターフェースMTUを使用する必要があります）"
    },
    {
      "indent": 0,
      "text": "5.4. Enqueue Routine",
      "section_title": true,
      "ja": "5.4。エンキュールーチン"
    },
    {
      "indent": 3,
      "text": "All the work of CoDel is done in the dequeue routine. The only CoDel addition to enqueue is putting the current time in the packet's tstamp field so that the dequeue routine can compute the packet's sojourn time. Note that packets arriving at a full buffer will be dropped, but these drops are not counted towards CoDel's computations.",
      "ja": "CODELのすべての作業は、デキュールーチンで行われます。デキュールーチンは、パケットの滞在時間を計算することができるようにエンキューにのみCODELの添加は、パケットのTSTAMPフィールドに現在の時間を入れています。フルバッファに到着するパケットが破棄されることに注意してください、これらの滴がCODELの計算にカウントされていません。"
    },
    {
      "indent": 3,
      "text": "void codel_queue_t::enqueue(packet_t* pkt)\n{\n    pkt->tstamp = clock();\n    queue_t::enqueue(pkt);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5. Dequeue Routine",
      "section_title": true,
      "ja": "5.5。デキュールーチン"
    },
    {
      "indent": 3,
      "text": "This is the heart of CoDel. There are two branches based on whether the controller is in drop state: (i) if the controller is in drop state (that is, the minimum packet sojourn time is greater than TARGET), then the controller checks if it is time to leave drop state or schedules the next drop(s); or (ii) if the controller is not in drop state, it determines if it should enter drop state and do the initial drop.",
      "ja": "これはCODELの心臓部です。コントローラが落下状態にあるか否かに基づいて2つの分岐がある：（i）コントローラが落下状態にある場合（つまり、最小パケットの滞在時間が目標よりも大きい）、ドロップを残す時間コントローラチェックである場合状態またはスケジュール次降下（S）;コントローラが落下状態にない場合、それは状態をドロップ入り、最初のドロップを行うべきかどうか、（II）、それが決定されます。"
    },
    {
      "indent": 3,
      "text": "packet_t* CoDelQueue::dequeue()\n{\n    time_t now = clock();\n    dodequeue_result r = dodequeue(now);\n    uint32_t delta;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (dropping_) {\n    if (! r.ok_to_drop) {\n        // sojourn time below TARGET - leave drop state\n        dropping_ = false;\n    }\n    // Time for the next drop.  Drop current packet and dequeue\n    // next.  If the dequeue doesn't take us out of dropping\n    // state, schedule the next drop.  A large backlog might\n    // result in drop rates so high that the next drop should\n    // happen now, hence the 'while' loop.\n    while (now >= drop_next_ && dropping_) {\n        drop(r.p);\n        ++count_;\n        r = dodequeue(now);\n        if (! r.ok_to_drop) {\n            // leave drop state\n            dropping_ = false;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "        } else {\n            // schedule the next drop.\n            drop_next_ = control_law(drop_next_, count_);\n        }\n    }\n// If we get here, we're not in drop state.  The 'ok_to_drop'\n// return from dodequeue means that the sojourn time has been\n// above 'TARGET' for 'INTERVAL', so enter drop state.\n} else if (r.ok_to_drop) {\n    drop(r.p);\n    r = dodequeue(now);\n    dropping_ = true;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "// If min went above TARGET close to when it last went\n// below, assume that the drop rate that controlled the\n// queue on the last cycle is a good starting point to\n// control it now.  ('drop_next' will be at most 'INTERVAL'\n// later than the time of the last drop, so 'now - drop_next'\n// is a good approximation of the time from the last drop\n// until now.) Implementations vary slightly here; this is\n// the Linux version, which is more widely deployed and\n// tested.\ndelta = count_ - lastcount_;\ncount_ = 1;\nif ((delta > 1) && (now - drop_next_ < 16*INTERVAL))\n    count_ = delta;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        drop_next_ = control_law(now, count_);\n        lastcount_ = count_;\n    }\n    return (r.p);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.6. Helper Routines",
      "section_title": true,
      "ja": "5.6。ヘルパールーチン"
    },
    {
      "indent": 3,
      "text": "Since the degree of multiplexing and nature of the traffic sources is unknown, CoDel acts as a closed-loop servo system that gradually increases the frequency of dropping until the queue is controlled (sojourn time goes below TARGET). This is the control law that governs the servo. It has this form because of the sqrt(p) dependence of TCP throughput on drop probability. Note that for embedded systems or kernel implementation, the inverse sqrt can be computed efficiently using only integer multiplication.",
      "ja": "トラフィックソースの多重化及び性質の程度が不明であるため、CODEL徐々にキューが制御されるまで落下の頻度を増加させる閉ループサーボシステム（滞在時間が目標を下回る）として作用します。これは、サーボを支配する制御則です。これは、理由はドロップ確率のTCPスループットのSQRT（P）依存性のこのフォームを持っています。組み込みシステムまたはカーネルの実装のために、逆SQRTのみ整数乗算を使用して効率的に計算することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "time_t codel_queue_t::control_law(time_t t, uint32_t count) { return t + INTERVAL / sqrt(count); }",
      "ja": "time_t codel_queue_t :: control_law（のtime_t T、のuint32_tカウント）{戻りT + INTERVAL / SQRT（カウント）。 }"
    },
    {
      "indent": 3,
      "text": "Next is a helper routine that does the actual packet dequeue and tracks whether the sojourn time is above or below TARGET and, if above, if it has remained above continuously for at least INTERVAL amount of time. It returns two values: a Boolean indicating if it is OK to drop (sojourn time above TARGET for at least INTERVAL) and the packet dequeued.",
      "ja": "次の実際のパケット・デキュー以上ならば、それは時間の少なくともINTERVAL量を連続的に上記の残っている場合に滞在時間は、ターゲットの上または下であるかどうかのトラックを行うヘルパールーチンです。これは、2つの値を返す：（少なくとも間隔に対するターゲット上記滞在時間）を削除するOKであり、パケットがデキュー場合ブール値を示します。"
    },
    {
      "indent": 3,
      "text": "typedef struct {\n    packet_t* p;\n    flag_t ok_to_drop;\n} dodequeue_result;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "dodequeue_result codel_queue_t::dodequeue(time_t now)\n{\n    dodequeue_result r = { queue_t::dequeue(), false };\n    if (r.p == NULL) {\n        // queue is empty - we can't be above TARGET\n        first_above_time_ = 0;\n        return r;\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    // To span a large range of bandwidths, CoDel runs two\n    // different AQMs in parallel.  One is based on sojourn time\n    // and takes effect when the time to send an MTU-sized\n    // packet is less than TARGET.  The 1st term of the \"if\"\n    // below does this.  The other is based on backlog and takes\n    // effect when the time to send an MTU-sized packet is >=\n    // TARGET.  The goal here is to keep the output link\n    // utilization high by never allowing the queue to get\n    // smaller than the amount that arrives in a typical\n    // interarrival time (MTU-sized packets arriving spaced\n    // by the amount of time it takes to send such a packet on\n    // the bottleneck).  The 2nd term of the \"if\" does this.\n    time_t sojourn_time = now - r.p->tstamp;\n    if (sojourn_time_ < TARGET || bytes() <= maxpacket_) {\n        // went below - stay below for at least INTERVAL\n        first_above_time_ = 0;\n    } else {\n        if (first_above_time_ == 0) {\n            // just went above from below. if still above at\n            // first_above_time, will say it's ok to drop.\n            first_above_time_ = now + INTERVAL;\n        } else if (now >= first_above_time_) {\n            r.ok_to_drop = true;\n        }\n    }\n    return r;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.7. Implementation Considerations",
      "section_title": true,
      "ja": "5.7。実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "time_t is an integer time value in units convenient for the system. Resolution to at least a millisecond is required, and better resolution is useful up to the minimum possible packet time on the output link; 64- or 32-bit widths are acceptable but with 32 bits the resolution should be no finer than 2^{-16} to leave enough dynamic range to represent a wide range of queue waiting times. Narrower widths also have implementation issues due to overflow (wrapping) and underflow (limit cycles because of truncation to zero) that are not addressed in this pseudocode.",
      "ja": "time_tのシステムのための便利な単位の整数時間値です。少なくともミリ秒を必要とし、より良い解像度が出力リンク上可能な最小パケット時間まで有用であると決議。 64ビットまたは32ビット幅が許容可能であるが、32ビットで解像度が2 ^よりも細かいてはならない - キュー待ち時間の広い範囲を表すために十分なダイナミックレンジを残す{16}。狭い幅はまた、この擬似コードで対処されていない実装のオーバーフローに起因する問題（ラッピング）及びアンダーフロー（なぜならゼロに切り捨てのリミットサイクル）を有します。"
    },
    {
      "indent": 3,
      "text": "Since CoDel requires relatively little per-queue state and no direct communication or state sharing between the enqueue and dequeue routines, it is relatively simple to add CoDel to almost any packet processing pipeline, including forwarding engines based on Application-Specific Integrated Circuits (ASICs) or Network Processors (NPUs). One issue to consider is dodequeue()'s use of a 'bytes()' function to determine the current queue size in bytes. This value does not need to be exact. If the enqueue part of the pipeline keeps a running count of the total number of bytes it has put into the queue, and the dequeue routine keeps a running count of the total bytes it has removed from the queue, 'bytes()' is simply the difference between these two counters (32-bit counters should be adequate). Enqueue has to update its counter once per packet queued, but it does not matter when (before, during, or after the packet has been added to the queue). The worst that can happen is a slight, transient underestimate of the queue size, which might cause a drop to be briefly deferred.",
      "ja": "CODELが比較的少ないあたりのキュー状態とエンキューおよびデキュールーチンの間に直接通信又は状態の共有を必要とするので、それは特定用途向け集積回路に基づいて転送エンジンを含む、ほぼすべてのパケット処理パイプラインにCODELを追加することは比較的簡単である特定用途向け集積回路（ASIC）またはネットワークプロセッサ（のNPU）。考慮すべき1つの問題は、バイト単位で、現在のキューサイズを決定するために、バイト（） 『関数dodequeue（） 'のsの使用』です。この値は正確である必要はありません。パイプラインのエンキュー一部は、それがキューに入れた総バイト数のランニングカウントを保持し、そしてデキュールーチンは、それがキューから削除している総バイト数のランニングカウントを続ける場合は、「バイト（）」単純ですこれら二つのカウンタの差（32ビットカウンタが適切でなければなりません）。エンキューは、一度パケットあたりのキューに入れられたそのカウンターを更新する必要がありますが、とき（前、中、またはパケットがキューに追加された後）、それは問題ではありません。起こることができる最悪の事態は、ドロップが簡単に延期されることがありますキューサイズのわずかな一過過小評価です。"
    },
    {
      "indent": 0,
      "text": "6. Further Experimentation",
      "section_title": true,
      "ja": "6.さらなる実験"
    },
    {
      "indent": 3,
      "text": "We encourage experimentation with the recommended values of TARGET and INTERVAL for Internet settings. CoDel provides general, efficient, parameterless building blocks for queue management that can be applied to single or multiple queues in a variety of data networking scenarios. CoDel's settings may be modified for other special-purpose networking applications.",
      "ja": "私たちは、インターネット設定のためのTARGETとINTERVALの推奨値と実験を奨励します。 CODELは、データネットワーキング、さまざまなシナリオで、単一または複数のキューに適用することができ、キュー管理のための一般的、効率的、パラメータなしのビルディングブロックを提供します。 CODELの設定は、他の特殊目的のネットワーキングアプリケーション用に修正することができます。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes an active queue management algorithm for implementation in networked devices. There are no known security exposures associated with CoDel at this time.",
      "ja": "この文書では、ネットワーク接続されたデバイスでの実装のためのアクティブキュー管理アルゴリズムを記述しています。この時点でCODELに関連した既知のセキュリティエクスポージャーはありません。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require actions by IANA.",
      "ja": "この文書は、IANAによってアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BLOAT] Gettys, J. and K. Nichols, \"Bufferbloat: Dark Buffers in the Internet\", Communications of the ACM, Volume 55, Issue 1, DOI 10.1145/2063176.2063196, January 2012.",
      "ja": "【BLOAT]ゲティス、J.及びK.ニコルズ、 \"Bufferbloat：インターネットにおけるダークバッファ\"、ACMのコミュニケーション、55巻、1号、DOI 10.1145 / 2063176.2063196、2012年1月。"
    },
    {
      "indent": 3,
      "text": "[CHARB2007] Dischinger, M., Haeberlen, A., Gummadi, K., and S. Saroiu, \"Characterizing Residential Broadband Networks\", Proceedings of the 7th ACM SIGCOMM Conference on Internet Measurement, DOI 10.1145/1298306.1298313, October 2007.",
      "ja": "[CHARB2007] Dischinger、M.、Haeberlen、A.、Gummadi、K.、およびS. Saroiu、 \"特徴付け家庭用ブロードバンド・ネットワーク\"、インターネット計測、DOI 10.1145 / 1298306.1298313、2007年10月第7回ACM SIGCOMM会議の議事。"
    },
    {
      "indent": 3,
      "text": "[CODEL2012] Nichols, K. and V. Jacobson, \"Controlling Queue Delay\", ACM Queue, Volume 10, Issue 5, DOI 10.1145/2208917.2209336, May 2012.",
      "ja": "[CODEL2012]ニコルズ、K.およびV. Jacobson氏、 \"制御しているキュー遅延\"、ACMキュー、10巻、5号、DOI 10.1145 / 2208917.2209336、2012年5月。"
    },
    {
      "indent": 3,
      "text": "[KLEIN81] Kleinrock, L. and R. Gail, \"An Invariant Property of Computer Network Power\", Proceedings of the International Conference on Communications, June 1981, <http://www.lk.cs.ucla.edu/data/files/Gail/power.pdf>.",
      "ja": "[KLEIN81] Kleinrock、L.およびR.ゲイル、「コンピュータネットワークパワーの不変プロパティ」、通信に関する国際会議の議事録、1981年6月、<http://www.lk.cs.ucla.edu/data/ファイル/ゲイル/ power.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MACTCP1997] Mathis, M., Semke, J., Mahdavi, J., and T. Ott, \"The Macroscopic Behavior of the TCP Congestion Avoidance Algorithm\", ACM SIGCOMM Computer Communications Review, Volume 27, Issue 3, pp. 67-82, DOI 10.1145/263932.264023, July 1997.",
      "ja": "【MACTCP1997]マティス、M.、Semke、J.、Mahdavi、J.、およびT.オット、ACM SIGCOMMコンピュータコミュニケーションレビュー、27巻、3号、PP \"TCP輻輳回避アルゴリズムの巨視的挙動\"。67 -82、DOI 10.1145 / 263932.264023、1997年7月。"
    },
    {
      "indent": 3,
      "text": "[NETAL2010] Kreibich, C., Weaver, N., Paxson, V., and B. Nechaev, \"Netalyzr: Illuminating the Edge Network\", Proceedings of the 10th ACM SIGCOMM Conference on Internet Measurement, DOI 10.1145/1879141.1879173, November 2010.",
      "ja": "[NETAL2010] Kreibich、C.、ウィーバー、N.、パクソン、V.、およびB. Nechaevは、 \"Netalyzr：エッジネットワークを照らす\"、インターネット計測、DOI 10.1145 / 1879141.1879173、2010年11月第10回ACM SIGCOMM会議議事録。"
    },
    {
      "indent": 3,
      "text": "[REDL1998] Nichols, K., Jacobson, V., and K. Poduri, \"RED in a Different Light\", Technical Report, Cisco Systems, September 1999, <http://citeseerx.ist.psu.edu/viewdoc/ summary?doi=10.1.1.22.9406>.",
      "ja": "[REDL1998]ニコルズ、K.、ヤコブソン、V.、およびK. Poduri、 \"異なる光でRED\"、技術報告書、シスコシステムズ、1999年9月、<http://citeseerx.ist.psu.edu/viewdoc/要約？DOI = 10.1.1.22.9406>。"
    },
    {
      "indent": 3,
      "text": "[RFC896] Nagle, J., \"Congestion Control in IP/TCP Internetworks\", RFC 896, DOI 10.17487/RFC0896, January 1984, <https://www.rfc-editor.org/info/rfc896>.",
      "ja": "[RFC896]ネーグル、J.、 \"IP / TCPインターネットワークにおける輻輳制御\"、RFC 896、DOI 10.17487 / RFC0896、1984年1月、<https://www.rfc-editor.org/info/rfc896>。"
    },
    {
      "indent": 3,
      "text": "[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, \"Recommendations on Queue Management and Congestion Avoidance in the Internet\", RFC 2309, DOI 10.17487/RFC2309, April 1998, <https://www.rfc-editor.org/info/rfc2309>.",
      "ja": "[RFC2309]ブレーデン、B.、クラーク、D.、クロウクロフト、J.、デイビー、B.、デアリング、S.、Estrin、D.、フロイド、S.、ヤコブソン、V.、Minshall、G.、ヤマウズラ、 C.、ピーターソン、L.、ラマクリシュナン、K.、Shenker、S.、Wroclawski、J.、およびL.チャン、 \"インターネットの待ち行列管理と輻輳回避に関する提言\"、RFC 2309、DOI 10.17487 / RFC2309、4月1998年、<https://www.rfc-editor.org/info/rfc2309>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<https://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC8290] Hoeiland-Joergensen, T., McKenney, P., Taht, D., Gettys, J., and E. Dumazet, \"The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm\", RFC 8290, DOI 10.17487/RFC8290, January 2018, <https://www.rfc-editor.org/info/rfc8290>.",
      "ja": "[RFC8290] Hoeiland-Joergensen、T.、McKenney、P.、Taht、D.、ゲティス、J.、およびE. Dumazet、 \"フローキューCODELパケットスケジューラ及びアクティブキュー管理アルゴリズム\"、RFC 8290、DOI 10.17487 / RFC8290、2018年1月、<https://www.rfc-editor.org/info/rfc8290>。"
    },
    {
      "indent": 3,
      "text": "[TSV84] Jacobson, V., \"CoDel\", IETF 84, Transport Area Open Meeting, July 2012, <http://www.ietf.org/proceedings/84/slides/ slides-84-tsvarea-4.pdf>.",
      "ja": "[TSV84]ジェーコブソン、V.、 \"CODEL\"、IETF 84、交通エリアのオープンミーティング、2012年7月、<http://www.ietf.org/proceedings/84/slides/スライド-84-tsvarea-4.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[VANQ2006] Jacobson, V., \"A Rant on Queues\", Talk at MIT Lincoln Labs, Lexington, MA, July 2006, <http://www.pollere.net/Pdfdocs/QrantJul06.pdf>.",
      "ja": "[VANQ2006]ジェーコブソン、V.、 \"キューの暴言\"、MITリンカーン研究所、レキシントン、MA、2006年7月のトーク、<http://www.pollere.net/Pdfdocs/QrantJul06.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Applying CoDel in the Data Center",
      "ja": "データセンターでCODELを適用する付録A."
    },
    {
      "indent": 3,
      "text": "Nandita Dukkipati and her group at Google realized that the CoDel building blocks could be applied to bufferbloat problems in data-center servers, not just to Internet routers. The Linux CoDel queueing discipline (qdisc) was adapted in three ways to tackle this bufferbloat problem.",
      "ja": "GoogleのNandita Dukkipatiと彼女のグループはCODELビルディングブロックだけではなく、インターネットルータに、データセンターのサーバで問題をbufferbloatに適用することができることを実現しました。 LinuxのCODELキューイング規律（なqdisc）は、このbufferbloatの問題に取り組むための三つの方法で適応されました。"
    },
    {
      "indent": 3,
      "text": "1. The default CoDel action was modified to be a direct feedback from qdisc to the TCP layer at dequeue. The direct feedback simply reduces TCP's congestion window just as congestion control would do in the event of drop. The scheme falls back to ECN marking or packet drop if the TCP socket lock could not be acquired at dequeue.",
      "ja": "1.デフォルトCODELのアクションがデキューでTCP層へのqdiscから直接フィードバックするように修正されました。直接のフィードバックは、単純に輻輳制御は、ドロップのイベントで行うのと同じようにTCPの輻輳ウィンドウを削減します。スキームは、TCPソケットロックがデキューで取得できなかった場合はECNマーキングまたはパケットドロップにフォールバックします。"
    },
    {
      "indent": 3,
      "text": "2. Being located in the server makes it possible to monitor the actual RTT to use as CoDel's interval rather than making a \"best guess\" of RTT. The CoDel interval is dynamically adjusted by using the maximum TCP round-trip time (RTT) of those connections sharing the same qdisc/bucket. In particular, there is a history entry of the maximum RTT experienced over the last second. As a packet is dequeued, the RTT estimate is accessed from its TCP socket. If the estimate is larger than the current CoDel interval, the CoDel interval is immediately refreshed to the new value. If the CoDel interval is not refreshed for over a second, it is decreased to the history entry, and the process is repeated. The use of the dynamic TCP RTT estimate allows the interval to adapt to the actual maximum value currently seen and thus lets the controller space its drop intervals appropriately.",
      "ja": "サーバーに配置されている2は、むしろRTTの「最良の推測」を作るよりも、CODELの間隔として使用するために、実際のRTTを監視することが可能となります。 CODEL間隔を動的に同一なqdisc /バケットを共有し、それらの接続の最大TCPのラウンドトリップ時間（RTT）を使用して調整されます。特に、RTTは、最後の秒にわたって受ける最大の履歴エントリが存在します。パケットがデキューされると、RTT推定値は、そのTCPソケットからアクセスされます。推定値は、現在のCODEL間隔よりも大きい場合、CODEL間隔はすぐに新しい値に更新されます。 CODEL間隔を秒以上更新されない場合は、履歴エントリに減少され、プロセスが繰り返されます。動的TCP RTT推定値の使用は、間隔が現在見て実際の最大値に適合することができ、したがって、適切コントローラ空間にその液滴間隔ができます。"
    },
    {
      "indent": 3,
      "text": "3. Since the mathematics of computing the setpoint are invariant, a TARGET of 5% of the RTT or CoDel interval was used here.",
      "ja": "設定値を計算する数学は不変であるので3、RTT又はCODEL間隔の5％の目標は、ここで使用しました。"
    },
    {
      "indent": 3,
      "text": "Non-data packets were not dropped, as these are typically small and sometimes critical control packets. Being located on the server, there is no concern with misbehaving users as there would be on the public Internet.",
      "ja": "これらは一般的に小さく、時には重要な制御パケットであるとして非データパケットは、廃棄されていませんでした。公共のインターネット上で存在することになるとして、サーバ上に配置され、ふらちなユーザーとの懸念はありません。"
    },
    {
      "indent": 3,
      "text": "In several data-center workload benchmarks, which are typically bursty, CoDel reduced the queueing latencies at the qdisc and thereby improved the mean and 99th-percentile latencies from several tens of milliseconds to less than one millisecond. The minimum tracking part of the CoDel framework proved useful in disambiguating \"good\" queue versus \"bad\" queue, which is particularly helpful in controlling qdisc buffers that are inherently bursty because of TCP Segmentation Offload (TSO).",
      "ja": "典型的には、バースト性であるいくつかのデータセンターのワークロードのベンチマークにおいて、CODELはなqdiscにキューイング遅延を低減し、それにより、1ミリ秒未満に数十ミリ秒からの平均及び99パーセンタイル遅延を改善しました。 CODELフレームワークの最小追跡部があるため、TCPセグメンテーションオフロード（TSO）で、本質的にバースト性のあるのqdiscバッファを制御する上で特に有用である「悪い」キュー、対「良い」キューを一義化に有用証明しました。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors thank Jim Gettys for the constructive nagging that made us get the work \"out there\" before we thought it was ready. We thank Dave Taht, Eric Dumazet, and the open source community for showing the value of getting it \"out there\" and for making it real. We thank Nandita Dukkipati for contributions to Section 6 and for comments that helped to substantially improve this document. We thank the AQM Working Group and the Transport Area Shepherd, Wes Eddy, for patiently prodding this document all the way to publication as an RFC.",
      "ja": "著者は、我々はそれが準備ができていたと思った前に私達が「そこに」仕事を得る作られた建設的しつこいためにジム・ゲティーズに感謝します。私たちは、「そこ」と、それは本当の作るためにそれを得ることの価値を示すためにデイブTaht、エリックDumazet、およびオープンソースコミュニティに感謝します。私たちは、第6節への貢献のためにと、実質的にこの文書を改善するために役立ったコメントをNandita Dukkipatiに感謝します。私たちは辛抱強くRFCとしてすべての方法パブリケーションにこの文書を催促するために、AQMワーキンググループや交通エリアシェパード、ウェス・エディに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Kathleen Nichols Pollere, Inc. PO Box 370201 Montara, CA 94037 United States of America",
      "ja": "キャスリーン・ニコルズPollere株式会社アメリカの私書箱370201モンタラ、CA 94037米国"
    },
    {
      "indent": 3,
      "text": "Email: nichols@pollere.com",
      "ja": "メール：nichols@pollere.com"
    },
    {
      "indent": 3,
      "text": "Van Jacobson Google",
      "ja": "ヤコブソングーグル"
    },
    {
      "indent": 3,
      "text": "Email: vanj@google.com",
      "ja": "メール：vanj@google.com"
    },
    {
      "indent": 3,
      "text": "Andrew McGregor (editor) Google",
      "ja": "アンドリュー・マクレガー（編集者）グーグル"
    },
    {
      "indent": 3,
      "text": "Email: andrewmcgr@google.com",
      "ja": "メール：andrewmcgr@google.com"
    },
    {
      "indent": 3,
      "text": "Janardhan Iyengar (editor) Google",
      "ja": "Janardhanアイアンガー（編集者）グーグル"
    },
    {
      "indent": 3,
      "text": "Email: jri@google.com",
      "ja": "メール：jri@google.com"
    }
  ]
}