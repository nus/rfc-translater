{
  "title": {
    "text": "RFC 8220 - Protocol Independent Multicast (PIM) over Virtual Private LAN Service (VPLS)",
    "ja": "RFC 8220 - プロトコル独立マルチキャスト仮想プライベートLANサービス（VPLS）を超える（PIM）"
  },
  "number": 8220,
  "created_at": "2019-10-27 01:13:30.068883+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         O. Dornon\nRequest for Comments: 8220                                   J. Kotalwar\nCategory: Informational                                        V. Hemige\nISSN: 2070-1721                                                    Nokia\n                                                                  R. Qiu\n                                                              mistnet.io\n                                                                Z. Zhang\n                                                  Juniper Networks, Inc.\n                                                          September 2017",
      "raw": true
    },
    {
      "indent": 16,
      "text": "  Protocol Independent Multicast (PIM)\nover Virtual Private LAN Service (VPLS)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the procedures and recommendations for Virtual Private LAN Service (VPLS) Provider Edges (PEs) to facilitate replication of multicast traffic to only certain ports (behind which there are interested Protocol Independent Multicast (PIM) routers and/or Internet Group Management Protocol (IGMP) hosts) via PIM snooping and proxying.",
      "ja": "この文書では、興味のあるプロトコル独立マルチキャスト（PIM）、ルータおよび/またはインターネットグループ管理プロトコルが存在するその背後にのみ特定のポート（へのマルチキャストトラフィックの複製を容易にするために、仮想プライベートLANサービス（VPLS）プロバイダーエッジ（PES）のための手順や推奨事項について説明しますPIMスヌーピングとプロキシを介して（IGMP）ホスト）。"
    },
    {
      "indent": 3,
      "text": "With PIM snooping, PEs passively listen to certain PIM control messages to build control and forwarding states while transparently flooding those messages. With PIM proxying, PEs do not flood PIM Join/Prune messages but only generate their own and send them out of certain ports, based on the control states built from downstream Join/Prune messages. PIM proxying is required when PIM Join suppression is enabled on the Customer Edge (CE) devices and is useful for reducing PIM control traffic in a VPLS domain.",
      "ja": "PIMスヌーピングでは、PEは受動的に透過的にそれらのメッセージをフラッディングしながら、制御と転送状態を構築するために、特定のPIM制御メッセージに耳を傾けます。 PIMのプロキシでは、PEは、下流から構築された制御状態に基づいて、PIMは/プルーンのメッセージを参加あふれさせるだけで、自分のを生成し、特定のポートのうち、それらを送信していない/プルーンのメッセージに参加。 PIMは抑制に参加するときのPIMプロキシが必要とされるカスタマーエッジ（CE）デバイス上で有効になっており、VPLSドメインにPIM制御トラフィックを低減するために有用です。"
    },
    {
      "indent": 3,
      "text": "This document also describes PIM relay, which can be viewed as lightweight proxying, where all downstream Join/Prune messages are simply forwarded out of certain ports and are not flooded, thereby avoiding the triggering of PIM Join suppression on CE devices.",
      "ja": "この文書は、単に特定のポートから転送されているすべての下流/プルーンJoinメッセージを軽量プロキシ、と見なすことができ、それによってCEデバイス上の抑制に参加し、PIMのトリガ避け、浸水していないPIMリレーを、説明しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8220.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8220で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Multicast Snooping in VPLS .................................5\n   1.2. Assumptions ................................................6\n   1.3. Definitions ................................................6\n   1.4. Requirements Language ......................................7\n2. PIM Snooping for VPLS ...........................................7\n   2.1. PIM Protocol Background ....................................7\n   2.2. General Rules for PIM Snooping in VPLS .....................8\n        2.2.1. Preserving Assert Triggers ..........................8\n   2.3. Some Considerations for PIM Snooping .......................9\n        2.3.1. Scaling .............................................9\n        2.3.2. IPv4 and IPv6 ......................................10\n        2.3.3. PIM-SM (*,*,RP) ....................................10",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   2.4. PIM Snooping vs. PIM Proxying .............................10\n        2.4.1. Differences between PIM Snooping, Relay,\n               and Proxying .......................................10\n        2.4.2. PIM Control Message Latency ........................11\n        2.4.3. When to Snoop and When to Proxy ....................12\n   2.5. Discovering PIM Routers ...................................13\n   2.6. PIM-SM and PIM-SSM ........................................14\n        2.6.1. Building PIM-SM States .............................15\n        2.6.2. Explanation for Per-(S,G,N) States .................17\n        2.6.3. Receiving (*,G) PIM-SM Join/Prune Messages .........18\n        2.6.4. Receiving (S,G) PIM-SM Join/Prune Messages .........20\n        2.6.5. Receiving (S,G,rpt) Join/Prune Messages ............22\n        2.6.6. Sending Join/Prune Messages Upstream ...............23\n   2.7. Bidirectional PIM (BIDIR-PIM) .............................24\n   2.8. Interaction with IGMP Snooping ............................24\n   2.9. PIM-DM ....................................................25\n        2.9.1. Building PIM-DM States .............................25\n        2.9.2. PIM-DM Downstream Per-Port PIM(S,G,N) State\n               Machine ............................................25\n        2.9.3. Triggering Assert Election in PIM-DM ...............26\n   2.10. PIM Proxy ................................................26\n        2.10.1. Upstream PIM Proxy Behavior .......................26\n   2.11. Directly Connected Multicast Source ......................26\n   2.12. Data-Forwarding Rules ....................................27\n        2.12.1. PIM-SM Data-Forwarding Rules ......................28\n        2.12.2. PIM-DM Data-Forwarding Rules ......................29\n3. IANA Considerations ............................................29\n4. Security Considerations ........................................30\n5. References .....................................................30\n   5.1. Normative References ......................................30\n   5.2. Informative References ....................................31\nAppendix A. BIDIR-PIM Considerations ..............................32\n  A.1. BIDIR-PIM Data-Forwarding Rules ............................32\nAppendix B. Example Network Scenario ..............................33\n  B.1. PIM Snooping Example .......................................33\n  B.2. PIM Proxy Example with (S,G) / (*,G) Interaction ...........36\nAcknowledgements ..................................................42\nContributors ......................................................42\nAuthors' Addresses ................................................43",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In the Virtual Private LAN Service (VPLS), the Provider Edge (PE) devices provide a logical interconnect such that Customer Edge (CE) devices belonging to a specific VPLS instance appear to be connected by a single LAN. The Forwarding Information Base (FIB) for a VPLS instance is populated dynamically by Media Access Control (MAC) address learning. Once a unicast MAC address is learned and associated with a particular Attachment Circuit (AC) or pseudowire (PW), a frame destined to that MAC address only needs to be sent on that AC or PW.",
      "ja": "仮想プライベートLANサービス（VPLS）において、プロバイダエッジ（PE）デバイスは、特定のVPLSインスタンスに属する顧客エッジ（CE）デバイスは、単一のLANで接続されるように見えるように論理的相互接続を提供します。 VPLSインスタンスの転送情報ベース（FIB）は、メディアアクセス制御（MAC）アドレス学習によって動的に移入されます。ユニキャストMACアドレスが学習され、特定のアタッチメント回路（AC）または疑似回線（PW）と関連していると、そのMACアドレス宛のフレームは、そのACまたはPW上で送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "For a frame not addressed to a known unicast MAC address, flooding has to be used. This happens with the following so-called \"BUM\" (Broadcast, Unknown Unicast, and Multicast) traffic:",
      "ja": "既知のユニキャストMACアドレス宛ではないフレームに対して、フラッディングを使用しなければなりません。これは、以下の、いわゆる「BUM」（ブロードキャスト、不明ユニキャスト、およびマルチキャスト）トラフィックで起こります："
    },
    {
      "indent": 3,
      "text": "o B: The destination MAC address is a broadcast address.",
      "ja": "O B：宛先MACアドレスがブロードキャストアドレスです。"
    },
    {
      "indent": 3,
      "text": "o U: The destination MAC address is unknown (has not been learned).",
      "ja": "O U：宛先MACアドレスが（学習されていない）は不明です。"
    },
    {
      "indent": 3,
      "text": "o M: The destination MAC address is a multicast address.",
      "ja": "O M：宛先MACアドレスがマルチキャストアドレスです。"
    },
    {
      "indent": 3,
      "text": "Multicast frames are flooded because a PE cannot know where corresponding multicast group members reside. VPLS solutions (RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) perform replication for multicast traffic at the ingress PE devices. As stated in the VPLS Multicast Requirements document (RFC 5501 [VPLS-MCAST-REQ]), there are two issues with VPLS multicast today:",
      "ja": "マルチキャストフレームは、対応するマルチキャスト・グループ・メンバーが存在する場合にPEを知ることができないためにフラッディングされます。 VPLS溶液（RFC 4762 [VPLS-LDP]およびRFC 4761 [VPLS-BGP]）は入口PEデバイスでマルチキャストトラフィックの複製を実行します。 VPLSマルチキャスト要件文書（RFC 5501 [VPLS-MCAST-REQ]）で述べたように、VPLSマルチキャストには2つの問題は、今日があります。"
    },
    {
      "indent": 3,
      "text": "1. Multicast traffic is replicated to non-member sites.",
      "section_title": true,
      "ja": "1.マルチキャストトラフィックは、非会員のサイトにレプリケートされます。"
    },
    {
      "indent": 3,
      "text": "2. Multicast traffic may be replicated when several PWs share a physical path.",
      "ja": "いくつかのPWSは物理パスを共有する場合2.マルチキャストトラフィックを複製することができます。"
    },
    {
      "indent": 3,
      "text": "Issue 1 can be solved by multicast snooping -- PEs learn sites with multicast group members by snooping multicast protocol control messages on ACs and forward IP multicast traffic only to member sites. This document describes the procedures to achieve this when CE devices are PIM adjacencies of each other. Issue 2 is outside the scope of this document and is discussed in RFC 7117 [VPLS-MCAST].",
      "ja": "問題1は、マルチキャストスヌーピングによって解決することができます -  PEは唯一のメンバーサイトにACSのマルチキャストプロトコルの制御メッセージと前方IPマルチキャストトラフィックをスヌーピングにより、マルチキャストグループのメンバーを持つサイトを学びます。この文書では、CEデバイスが互いのPIMの隣接しているときにこれを達成するための手順を説明します。問題2は、この文書の範囲外であり、[VPLS-MCAST] RFC 7117に記載されています。"
    },
    {
      "indent": 3,
      "text": "While descriptions in this document are in the context of the VPLS, the procedures also apply to regular Layer 2 switches interconnected by physical connections, except that the PW-related concepts and procedures do not apply in that case.",
      "ja": "このドキュメントの説明はVPLSのコンテキストであるが、手順もPW-関連する概念と手順が、その場合には適用されないことを除いて、物理的な接続によって相互接続され、通常のレイヤ2スイッチに適用されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Multicast Snooping in VPLS",
      "section_title": true,
      "ja": "1.1。 VPLSでのマルチキャストスヌーピング"
    },
    {
      "indent": 3,
      "text": "IGMP snooping procedures described in RFC 4541 [IGMP-SNOOP] make sure that IP multicast traffic is only sent on the following:",
      "ja": "RFC 4541で説明IGMPスヌーピング手順[IGMP-SNOOP] IPマルチキャストトラフィックのみ、以下に送られていることを確認します："
    },
    {
      "indent": 3,
      "text": "o ACs connecting to hosts that report related group membership",
      "ja": "ACSは、関連するグループメンバーシップを報告するホストに接続するO"
    },
    {
      "indent": 3,
      "text": "o ACs connecting to routers that join related multicast groups",
      "ja": "O ACSは、関連するマルチキャストグループに参加するルータに接続します"
    },
    {
      "indent": 3,
      "text": "o PWs connecting to remote PEs that have the above-described ACs",
      "ja": "OのPWは、上述したACSを有するリモートPEに接続します"
    },
    {
      "indent": 3,
      "text": "Note that traffic is always sent on ports that have point-to-point connections to routers that are attached to a LAN on which there is at least one other router. Because IGMP snooping alone cannot determine if there are interested receivers beyond those routers, we always need to send traffic to these ports, even if there are no snooped group memberships. To further restrict traffic sent to those routers, PIM snooping can be used. This document describes the procedures for PIM snooping, including rules for when both IGMP and PIM snooping are enabled in a VPLS instance; see Sections 2.8 and 2.11 for details.",
      "ja": "トラフィックは、常に少なくとも一つの他のルータが存在しているLANに接続されているルータへのポイントツーポイント接続を持っているポートで送信されることに注意してください。 IGMPは、これらのルータを越えて興味受信機があるかどうかを決定することができないだけでスヌーピングので、我々は常に何スヌープグループのメンバーシップが存在しない場合でも、これらのポートにトラフィックを送信する必要があります。さらに、これらのルータに送信されるトラフィックを制限するには、PIMスヌーピングを使用することができます。この文書では、IGMPおよびPIMスヌーピングの両方がVPLSインスタンスで有効になっている場合のルールを含むPIMスヌーピング、の手順を説明し、セクションに詳細については、2.8と2.11を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that for both IGMP and PIM, the term \"snooping\" is used loosely, referring to the fact that a Layer 2 device peeks into Layer 3 routing protocol messages to build relevant control and forwarding states. Depending on whether the control messages are transparently flooded, selectively forwarded, or aggregated, the processing may be called \"snooping\" or \"proxying\" in different contexts.",
      "ja": "IGMPとPIMの両方のために、「スヌーピング」という用語は、レイヤ3ルーティングプロトコルメッセージにレイヤ2つのデバイス覗き見は、関連する制御および転送状態を構築するという事実を参照し、緩く使用されることに留意されたいです。制御メッセージを透過的にフラッディングされているかどうかに応じて、選択的転送、または凝集し、処理は、異なるコンテキストで「スヌーピング」または「プロキシ」と呼ばれてもよいです。"
    },
    {
      "indent": 3,
      "text": "We will use the term \"PIM snooping\" in this document; however, unless explicitly noted otherwise, the procedures apply equally to PIM snooping and PIM proxying. The procedures specific to PIM proxying are described in Section 2.6.6. Differences that need to be observed while implementing one or the other and recommendations on which method to employ in different scenarios are noted in Section 2.4.",
      "ja": "私たちは、この文書中の用語「PIMスヌーピング」を使用します。明示的に、特に断りのない限りしかし、手順はPIMスヌーピングおよびPIMのプロキシにも同様に適用されます。 PIMのプロキシへの具体的な手順は、2.6.6項で説明されています。どちらか一方を実装し、異なるシナリオで使用するどの方法にお薦めしながら観察する必要がある違いはセクション2.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "This document also describes PIM relay, which can be viewed as lightweight PIM proxying. Unless explicitly noted otherwise, in the rest of this document proxying implicitly includes relay as well. Please refer to Section 2.4.1 for an overview of the differences between snooping, proxying, and relay.",
      "ja": "この文書はまた、軽量PIMのプロキシとして見ることができるPIMリレーを、説明しています。明示的に特に記載のない限り、このドキュメントのプロキシ処理の残りの部分では、暗黙的にも中継しています。スヌーピング、プロキシ、およびリレー間の違いの概要については、2.4.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.2. Assumptions",
      "section_title": true,
      "ja": "1.2。仮定"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader has a good understanding of the PIM protocols. To help correlate the concepts and make the text easier to follow, this document is written in the same style as the following PIM RFCs:",
      "ja": "この文書では、読者がPIMプロトコルの十分な理解を持っていることを前提としています。概念を相関し、従ってテキストを容易に支援するために、この文書は、次のPIM RFCとして同じスタイルで書かれています："
    },
    {
      "indent": 3,
      "text": "o RFC 3973 [PIM-DM]",
      "ja": "OのRFC 3973 [PIM-DM]"
    },
    {
      "indent": 3,
      "text": "o RFC 4607 [PIM-SSM]",
      "ja": "OのRFC 4607 [PIM-SSM]"
    },
    {
      "indent": 3,
      "text": "o RFC 5015 [BIDIR-PIM]",
      "ja": "O RFC 5015 [BI-D-PIM]"
    },
    {
      "indent": 3,
      "text": "o RFC 5384 [JOIN-ATTR]",
      "ja": "OのRFC 5384 [JOIN-ATTR]を"
    },
    {
      "indent": 3,
      "text": "o RFC 7761 [PIM-SM]",
      "ja": "OのRFC 7761 [PIM-SM]"
    },
    {
      "indent": 3,
      "text": "In order to avoid replicating text related to PIM protocol handling from the PIM RFCs, this document cross-references corresponding definitions and procedures in those RFCs. Deviations in protocol handling specific to PIM snooping are specified in this document.",
      "ja": "PIMのRFCには、これらのRFCの定義と手順を対応この文書の相互参照から処理PIMプロトコルに関連するテキストの複製を回避するためです。 PIMスヌーピングに固有のプロトコル処理における偏差は、この文書で指定されています。"
    },
    {
      "indent": 0,
      "text": "1.3. Definitions",
      "section_title": true,
      "ja": "1.3。定義"
    },
    {
      "indent": 3,
      "text": "There are several definitions referenced in this document that are well described in the following PIM RFCs: RFC 3973 [PIM-DM], RFC 5015 [BIDIR-PIM], and RFC 7761 [PIM-SM]. The following definitions and abbreviations are used throughout this document:",
      "ja": "RFC 3973 [PIM-DM]、RFC 5015 [BIDIR-PIM]、およびRFC 7761 [PIM-SM]：いくつかのよく次のPIM RFCで記述されているこのドキュメントで参照定義があります。以下の定義および略語は、この文書全体で使用されています。"
    },
    {
      "indent": 3,
      "text": "o A port is defined as either an AC or a PW.",
      "ja": "Oポートは、ACまたはPWのいずれかとして定義されています。"
    },
    {
      "indent": 3,
      "text": "o When we say that a PIM message is received on a PE port, it means that the PE is processing the message for snooping/proxying or relaying.",
      "ja": "我々は、PIMメッセージはPEポートで受信されると言う場合、O、それはPEは/プロキシスヌーピングまたは中継するためのメッセージを処理していることを意味します。"
    },
    {
      "indent": 3,
      "text": "Abbreviations used in this document:",
      "ja": "このドキュメントで使用される略語："
    },
    {
      "indent": 3,
      "text": "o S: IP address of the multicast source.",
      "ja": "O S：マルチキャスト送信元のIPアドレス。"
    },
    {
      "indent": 3,
      "text": "o G: IP address of the multicast group.",
      "ja": "O G：マルチキャストグループのIPアドレス。"
    },
    {
      "indent": 3,
      "text": "o N: Upstream Neighbor field in a Join/Prune/Graft message.",
      "ja": "O N：参加/プルーン/グラフトメッセージで上流のNeighborフィールド。"
    },
    {
      "indent": 3,
      "text": "o Port(N): Port on which neighbor N is learned, i.e., the port on which N's Hellos are received.",
      "ja": "Oポート（N）：隣人Nが学習しているポート、すなわち、Nのハローズが受信されているポート。"
    },
    {
      "indent": 3,
      "text": "o rpt: Rendezvous Point Tree.",
      "ja": "OのRPT：ランデブーポイントツリー。"
    },
    {
      "indent": 3,
      "text": "o PIM-DM: Protocol Independent Multicast - Dense Mode.",
      "ja": "O PIM-DM：プロトコル独立マルチキャスト - 稠密モード。"
    },
    {
      "indent": 3,
      "text": "o PIM-SM: Protocol Independent Multicast - Sparse Mode.",
      "ja": "O PIM-SM：プロトコル独立マルチキャスト - スパースモード。"
    },
    {
      "indent": 3,
      "text": "o PIM-SSM: Protocol Independent Multicast - Source-Specific Multicast.",
      "ja": " - ソース固有のマルチキャストプロトコル独立マルチキャスト：PIM-SSM O。"
    },
    {
      "indent": 0,
      "text": "1.4. Requirements Language",
      "section_title": true,
      "ja": "1.4。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2. PIM Snooping for VPLS",
      "section_title": true,
      "ja": "VPLS 2. PIMスヌーピング"
    },
    {
      "indent": 0,
      "text": "2.1. PIM Protocol Background",
      "section_title": true,
      "ja": "2.1。 PIMプロトコルの背景"
    },
    {
      "indent": 3,
      "text": "PIM is a multicast routing protocol running between routers, which are CE devices in a VPLS. It uses the unicast routing table to provide reverse-path information for building multicast trees. There are a few variants of PIM. As described in RFC 3973 [PIM-DM], multicast datagrams are pushed towards downstream neighbors, similar to a broadcast mechanism, but in areas of the network where there are no group members, routers prune back branches of the multicast tree towards the source. Unlike PIM-DM, other PIM flavors (RFC 7761 [PIM-SM], RFC 4607 [PIM-SSM], and RFC 5015 [BIDIR-PIM]) employ a pull methodology via explicit Joins instead of the push-and-prune technique.",
      "ja": "PIMは、VPLS内のCEデバイスであるルータ間で実行されているマルチキャストルーティングプロトコルです。これは、マルチキャストツリーを構築するための逆経路情報を提供するために、ユニキャストルーティングテーブルを使用します。 PIMのいくつかのバリエーションがあります。 [PIM-DM] RFC 3973に記載されているように、マルチキャストデータグラムは、放送機構と同様下流の隣人に向かって押され、ないグループメンバーが存在しないネットワークの領域において、ルータは、ソースに向かってマルチキャストツリーの分岐をバック剪定します。 PIM-DMとは異なり、他のPIMフレーバー（RFC 7761 [PIM-SM]、RFC 4607 [PIM-SSM]、およびRFC 5015 [BIDIR-PIM]）は、明示的介しプル方法ではなく、プッシュ・アンド・プルーン技術の参加採用します。"
    },
    {
      "indent": 3,
      "text": "PIM routers periodically exchange Hello messages to discover and maintain stateful sessions with neighbors. After neighbors are discovered, PIM routers can signal their intentions to join or prune specific multicast groups. This is accomplished by having downstream routers send an explicit Join/Prune message (for the sake of generalization, consider Graft messages for PIM-DM as Join messages) to their corresponding upstream router. The Join/Prune message can be group specific (*,G) or group and source specific (S,G).",
      "ja": "PIMルータは、定期的に発見し、隣人とステートフルセッションを維持するために、Helloメッセージを交換します。隣人が発見された後、PIMルータが特定のマルチキャストグループへの参加や剪定する彼らの意図を知らせることができます。これは、下流のルータを有することによって達成され、それらの対応するアップストリームルータに（メッセージに参加したように一般化のために、PIM-DMのためのグラフトメッセージを考える）明示的な参加/プルーンメッセージを送信します。参加/プルーンメッセージは、グループ特定（*、G）またはグループおよびソース特定の（S、G）とすることができます。"
    },
    {
      "indent": 0,
      "text": "2.2. General Rules for PIM Snooping in VPLS",
      "section_title": true,
      "ja": "2.2。 VPLSでPIMスヌーピングのための一般的な規則"
    },
    {
      "indent": 3,
      "text": "The following rules for the correct operation of PIM snooping MUST be followed.",
      "ja": "PIMスヌーピングが正しく動作するために、以下の規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "o PIM snooping MUST NOT affect the operation of customer Layer 2 protocols or Layer 3 protocols.",
      "ja": "O PIMスヌーピングは、顧客のレイヤ2つのプロトコルをまたはレイヤ3つのプロトコルの動作に影響してはいけません。"
    },
    {
      "indent": 3,
      "text": "o PIM messages and multicast data traffic forwarded by PEs MUST follow the split-horizon rule for mesh PWs, as defined in RFC 4762 [VPLS-LDP].",
      "ja": "[VPLS-LDP] RFC 4762で定義されているOのPEによって転送PIMメッセージ及びマルチキャストデータトラフィックは、メッシュのPW用のスプリットホライズンルールに従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "o PIM states in a PE MUST be per VPLS instance.",
      "ja": "O PEにおけるPIM状態がVPLSインスタンスごとになければなりません。"
    },
    {
      "indent": 3,
      "text": "o PIM Assert triggers MUST be preserved to the extent necessary to avoid sending duplicate traffic to the same PE (see Section 2.2.1).",
      "ja": "O PIMアサートトリガー（セクション2.2.1を参照）と同じPEに重複トラフィックを送信することを避けるために必要な程度に保存されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Preserving Assert Triggers",
      "section_title": true,
      "ja": "2.2.1。アサートトリガを保存"
    },
    {
      "indent": 3,
      "text": "In PIM-SM / PIM-DM, there are scenarios where multiple routers could be forwarding the same multicast traffic on a LAN. When this happens, these routers start the PIM Assert election process by sending PIM Assert messages, to ensure that only the Assert winner forwards multicast traffic on the LAN. The Assert election is a data-driven event and happens only if a router sees traffic on the interface to which it should be forwarding the traffic. In the case of a VPLS with PIM snooping, two routers may forward the same multicast datagrams at the same time, but each copy may reach a different set of PEs; this is acceptable from the point of view of avoiding duplicate traffic. If the two copies may reach the same PE, then the sending routers must be able to see each other's traffic, in order to trigger Assert election and stop duplicate traffic. To achieve that, PEs enabled with PIM-SSM / PIM-SM snooping MUST forward multicast traffic for an (S,G) / (*,G) not only on the ports on which they snooped Join(S,G) / Join(*,G) but also towards the upstream neighbor(s). In other words, the ports on which the upstream neighbors are learned must be added to the outgoing port list, along with the ports on which Joins are snooped. Please refer to Section 2.6.1 for the rules that determine the set of upstream neighbors for a particular (x,G).",
      "ja": "PIM-SM / PIM-DMでは、複数のルータがLAN上で同じマルチキャストトラフィックを転送することができシナリオがあります。これが発生した場合、これらのルータはアサート勝者は、LAN上のマルチキャストトラフィックを転送することを保証するために、PIMアサートメッセージを送信することにより、PIMアサート選出プロセスを開始します。アサート選挙は、データ駆動型のイベントであり、それはトラフィックを転送すべきルータがインターフェイス上のトラフィックを見ている場合にのみ発生します。 PIMスヌーピングとVPLSの場合には、2つのルータが同時に同じマルチキャストデータグラムを転送することができるが、各コピーは、PESの異なるセットに到達することができます。これは、重複したトラフィックを回避する観点から許容されます。 2つのコピーが同じPEに達する可能性があれば、送信ルータはアサート選挙の引き金と重複したトラフィックを停止するために、互いのトラフィックを見ることができなければなりません。それを達成するために、PIM-SSM / PIM-SMスヌーピングを有効にPEは（（S、G）/（*、G）だけでなく、彼らは（S、G）が参加詮索されているポートで/参加のためのマルチキャストトラフィックを転送しなければなりません*、G）だけでなく、上流隣接（S）に向かいます。つまり、上流の隣人が学習されているポートが参加を詮索されているポートと一緒に、発信ポートリストに追加する必要があります。特定の（X、G）のための上流の近隣の組を決定する規則については、セクション2.6.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Similarly, PIM-DM snooping SHOULD make sure that Asserts can be triggered (Section 2.9.3).",
      "ja": "同様に、PIM-DMスヌーピングはそれが（セクション2.9.3）をトリガすることができアサートを確認してください。"
    },
    {
      "indent": 3,
      "text": "The above logic needs to be facilitated without breaking VPLS split-horizon forwarding rules. That is, traffic should not be forwarded on the port on which it was received, and traffic arriving on a PW MUST NOT be forwarded onto other PW(s).",
      "ja": "上記のロジックは、VPLSスプリットホライズンの転送ルールを壊すことなく容易に行うことが必要です。これは、トラフィックがそれを受信したポートに転送すべきではない、とPWに到着トラフィックは、他のPW（S）に転送してはならない、です。"
    },
    {
      "indent": 0,
      "text": "2.3. Some Considerations for PIM Snooping",
      "section_title": true,
      "ja": "2.3。 PIMスヌーピングのためのいくつかの考慮事項"
    },
    {
      "indent": 3,
      "text": "The PIM snooping solution described here requires a PE to examine and operate on only PIM Hello and PIM Join/Prune packets. The PE does not need to examine any other PIM packets.",
      "ja": "ここで説明PIMスヌーピングソリューションを調べて/プルーンパケットの参加のみPIMこんにちは、PIM上で動作するPEが必要です。 PEは、他のPIMパケットを検査する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Most of the PIM snooping procedures for handling Hello/Join/Prune messages are very similar to those executed in a PIM router. However, the PE does not need to have any routing tables like those required in PIM routing. It knows how to forward Join/Prune messages only by looking at the Upstream Neighbor field in the Join/Prune packets, as described in Section 2.12.",
      "ja": "こんにちは/参加/プルーンのメッセージを処理するためのPIMスヌーピング手順のほとんどは、PIMルータで実行されるものと非常によく似ています。しかし、PEは、PIMルーティングに必要なような任意のルーティングテーブルを持っている必要はありません。これは、2.12節で説明したように、唯一の参加/プルーンパケットで上流隣接フィールドを見て、/参加プルーンメッセージを転送する方法を知っています。"
    },
    {
      "indent": 3,
      "text": "The PE does not need to know about Rendezvous Points (RPs) and does not have to maintain any RP Set. All of that is transparent to a PIM snooping PE.",
      "ja": "PEは、ランデブーポイント（RPS）について知っておく必要はなく、任意のRPセットを維持する必要はありません。すべてのことは、PEをスヌーピングPIMに対して透過的です。"
    },
    {
      "indent": 3,
      "text": "In the following subsections, we list some considerations and observations for the implementation of PIM snooping in the VPLS.",
      "ja": "以下のサブセクションでは、我々は、VPLSでPIMスヌーピングを実装するためのいくつかの考慮事項との観測を一覧表示します。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Scaling",
      "section_title": true,
      "ja": "2.3.1。スケーリング"
    },
    {
      "indent": 3,
      "text": "PIM snooping needs to be employed on ACs at the downstream PEs (PEs receiving multicast traffic across the VPLS core) to prevent traffic from being sent out of ACs unnecessarily. PIM snooping techniques can also be employed on PWs at the upstream PEs (PEs receiving traffic from local ACs in a hierarchical VPLS) to prevent traffic from being sent to PEs unnecessarily. This may work well for small-scale or medium-scale deployments. However, if there are a large number of VPLS instances with a large number of PEs per instance, then the amount of snooping required at the upstream PEs can overwhelm the upstream PEs.",
      "ja": "PIMスヌーピングが不必要のACから送信されるトラフィックを防ぐために、下流のPE（PEがVPLSコアを横切ってマルチキャストトラフィックを受信する）でACS上で使用する必要があります。 PIMスヌーピング手法はまた、不必要にPEに送信されるトラフィックを防ぐために、上流のPE（PEが階層VPLSにローカルACSからトラフィックを受信する）でのPWに使用することができます。これは、小規模または中規模の展開のために働くことがあります。 VPLSインスタンスの多数のインスタンスごとに、PEの多数である場合は、アップストリームのPEで必要スヌーピングの量は、上流のPEを圧倒することができます。"
    },
    {
      "indent": 3,
      "text": "There are two methods to reduce the burden on the upstream PEs. One is to use PIM proxying, as described in Section 2.6.6, to reduce the control messages forwarded by a PE. The other is not to snoop on the PWs at all but to have PEs signal the snooped states to other PEs out of band via BGP, as described in RFC 7117 [VPLS-MCAST]. In this document, it is assumed that snooping is performed on PWs.",
      "ja": "上流のPEの負担を軽減するための2つの方法があります。一つは、セクション2.6.6に記載したようにPEによって転送された制御メッセージを減らすために、PIMプロキシを使用することです。他は、RFC 7117 [VPLS-MCAST]で説明されるようにPEは、BGPを介して帯域外で他のPEへのスヌープ状態を知らせる有することが、すべてでのPWをスヌープすることはありません。この文書では、スヌーピングがPWの上で実行されているものとします。"
    },
    {
      "indent": 0,
      "text": "2.3.2. IPv4 and IPv6",
      "section_title": true,
      "ja": "2.3.2。 IPv4とIPv6"
    },
    {
      "indent": 3,
      "text": "In the VPLS, PEs forward Ethernet frames received from CEs and as such are agnostic of the Layer 3 protocol used by the CEs. However, as a PIM snooping PE, the PE would have to look deeper into the IP and PIM packets and build snooping state based on that. The PIM protocol specifications handle both IPv4 and IPv6. The specification for PIM snooping in this document can be applied to both IPv4 and IPv6 payloads.",
      "ja": "VPLSにおいて、PEの前方イーサネットフレームは複数のCEから受信し、そのようなものとしてのCEによって使用されるレイヤ3プロトコルのとらわれています。しかし、PEスヌーピングPIMとして、PEは、IPおよびPIMパケットに深く見て、それに基づいて状態をスヌーピング構築しなければなりません。 PIMプロトコルの仕様は、IPv4とIPv6の両方を扱います。本書でスヌーピングPIMの仕様は、IPv4とIPv6の両方のペイロードに適用することができます。"
    },
    {
      "indent": 0,
      "text": "2.3.3. PIM-SM (*,*,RP)",
      "section_title": true,
      "ja": "2.3.3。 PIM-SM（*、*、RP）"
    },
    {
      "indent": 3,
      "text": "This document does not address (*,*,RP) states in the VPLS network, as they have been removed from the PIM protocol as described in RFC 7761 [PIM-SM].",
      "ja": "RFC 7761に記載されているように、それらがPIMプロトコルから削除されたとして、この文書は、VPLSネットワークに（*、*、RP）状態に対処していない[PIM-SM]。"
    },
    {
      "indent": 0,
      "text": "2.4. PIM Snooping vs. PIM Proxying",
      "section_title": true,
      "ja": "2.4。 PIMスヌーピング対PIMプロキシ"
    },
    {
      "indent": 3,
      "text": "This document has previously alluded to PIM snooping/relay/proxying. Details on the PIM relay/proxying solution are discussed in Section 2.6.6. In this section, a brief description and comparison are given.",
      "ja": "この文書は、以前PIMスヌーピング/リレー/プロキシに言及しています。 PIMリレー/プロキシ・ソリューションの詳細については、2.6.6項で説明されています。このセクションでは、簡単な説明との比較が与えられています。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Differences between PIM Snooping, Relay, and Proxying",
      "section_title": true,
      "ja": "2.4.1。 PIMスヌーピング、リレー、およびプロキシの違い"
    },
    {
      "indent": 3,
      "text": "Differences between PIM snooping and relay/proxying can be summarized as follows:",
      "ja": "次のようにPIMスヌーピングおよびリレー/プロキシの違いを要約することができます。"
    },
    {
      "indent": 4,
      "text": "+--------------------+---------------------+-----------------------+\n|     PIM snooping   |    PIM relay        |    PIM proxying       |\n+====================|=====================|=======================+\n| Join/Prune messages| Join/Prune messages | Join/Prune messages   |\n| snooped and flooded| snooped; forwarded  | consumed.  Regenerated|\n| according to VPLS  | as is out of certain| ones sent out of      |\n| flooding procedures| upstream ports      | certain upstream ports|\n+--------------------+---------------------+-----------------------+\n| Hello messages     | Hello messages      | Hello messages        |\n| snooped and flooded| snooped and flooded | snooped and flooded   |\n| according to VPLS  | according to VPLS   | according to VPLS     |\n| flooding procedures| flooding procedures | flooding procedures   |\n+--------------------+---------------------+-----------------------+\n| No PIM packets     | No PIM packets      | New Join/Prune        |\n| generated          | generated           | messages generated    |\n+--------------------+---------------------+-----------------------+\n| CE Join suppression| CE Join suppression | CE Join suppression   |\n| not allowed        | allowed             | allowed               |\n+--------------------+---------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other than the above differences, most of the procedures are common to PIM snooping and PIM relay/proxying, unless specifically stated otherwise.",
      "ja": "上記の相違点以外は特に断りのない限り、手順のほとんどは、PIMスヌーピングおよびPIMリレー/プロキシに共通しています。"
    },
    {
      "indent": 3,
      "text": "Pure PIM snooping PEs simply snoop on PIM packets as they are being forwarded in the VPLS. As such, they truly provide transparent LAN services, since no customer packets are modified or consumed nor are new packets introduced in the VPLS. It is also simpler to implement than PIM proxying. However, for PIM snooping to work correctly, it is a requirement that CE routers MUST disable Join suppression in the VPLS. Otherwise, most of the CE routers with interest in a given multicast data stream will fail to send Join/Prune messages for that stream, and the PEs will not be able to tell which ACs and/or PWs have listeners for that stream.",
      "ja": "彼らはVPLSに転送されているとして、純粋なPIMスヌーピングPEは単にPIMパケットをスヌーピング。まだカスタマーパケットがVPLSで導入された新しいパケットを変更していないか、消費もされているので、そのように、彼らは本当に、透明LANサービスを提供します。 PIMのプロキシよりも実装することも簡単です。しかし、正しく動作するPIMスヌーピングのために、それはCEルータは、VPLSに抑制を無効にする必要があり参加要件です。それ以外の場合は、指定したマルチキャストデータストリームに関心のあるCEルータのほとんどは、そのストリームのために/プルーンJoinメッセージを送信するために失敗し、PEはACSおよび/またはPWSはそのストリームのリスナーを持っている伝えることができなくなります。"
    },
    {
      "indent": 3,
      "text": "Given that a large number of existing CE deployments do not support the disabling of Join suppression and given the operational complexity for a provider to manage the disabling of Join suppression in the VPLS, it becomes a difficult solution to deploy. Another disadvantage of PIM snooping is that it does not scale as well as PIM proxying. If there are a large number of CEs in a VPLS, then every CE will see every other CE's Join/Prune messages.",
      "ja": "既存のCEの展開多数の抑制に参加して、VPLSに抑制参加の無効化を管理するために、プロバイダの運用の複雑さを与えられたの無効化をサポートしていないことを考えると、それが展開するのが困難なソリューションとなります。 PIMスヌーピングのもう一つの欠点は、PIMのプロキシ処理と同様にスケールしないということです。 CEの大多数は、VPLSに存在する場合、すべてのCEは、他のすべてのCEの/参加プルーンのメッセージが表示されます。"
    },
    {
      "indent": 3,
      "text": "PIM relay/proxying has the advantage that it does not require Join suppression to be disabled in the VPLS. Multicast as part of a VPLS can be very easily provided without requiring any changes on the CE routers. PIM relay/proxying helps scale VPLS multicast, since Join/Prune messages are only sent to certain upstream ports instead of flooded, and in cases of full proxying (vs. relay), the PEs intelligently generate only one Join/Prune message for a given multicast stream.",
      "ja": "PIMリレー/プロキシは、それがVPLSで無効になっているの抑制に参加しましょ必要としないという利点を有します。 VPLSの一部としてマルチキャストが非常に容易にCEルータの変更を必要とせずに提供することができます。 PIM中継/プロキシ以来参加/プルーンメッセージのみ特定のアップストリームポートに送信された代わりの浸水、および（リレー対）、フルプロキシの場合には、PEがインテリジェント所与のための唯一の参加/プルーンメッセージを生成し、スケールVPLSマルチキャストを助けますマルチキャストストリーム。"
    },
    {
      "indent": 3,
      "text": "PIM proxying, however, loses the transparency argument, since Join/Prune packets could get modified or even consumed at a PE. Also, new packets could get introduced in the VPLS. However, this loss of transparency is limited to PIM Join/Prune packets. It is in the interest of optimizing multicast in the VPLS and helping a VPLS network scale much better, for both the provider and the customer. Data traffic will still be completely transparent.",
      "ja": "PIMのプロキシは、しかし、透明引数、以来、参加/プルーンパケットが変更され得ることができ、さらにはPEで消費を失います。また、新しいパケットがVPLSに紹介を受けることができます。しかし、透明性のこの損失は、/プルーンパケットを参加PIMに制限されています。これは、プロバイダと顧客の両方のために、VPLSでマルチキャストを最適化し、VPLSネットワークの規模を助ける利益にはるかに優れています。データトラフィックは、まだ完全に透明になります。"
    },
    {
      "indent": 0,
      "text": "2.4.2. PIM Control Message Latency",
      "section_title": true,
      "ja": "2.4.2。 PIM制御メッセージの待ち時間"
    },
    {
      "indent": 3,
      "text": "A PIM snooping/relay/proxying PE snoops on PIM Hello packets while transparently flooding them in the VPLS. As such, there is no latency introduced by the VPLS in the delivery of PIM Hello packets to remote CEs in the VPLS.",
      "ja": "透過VPLSでそれらをフラッディングしながら、PIMスヌーピング/リレー/プロキシPEは、PIM Helloパケットをスヌーピング。このように、VPLS内のリモートCEにPIM Helloパケットの配信にVPLSによって導入された待ち時間がありません。"
    },
    {
      "indent": 3,
      "text": "A PIM snooping PE snoops on PIM Join/Prune packets while transparently flooding them in the VPLS. There is no latency introduced by the VPLS in the delivery of PIM Join/Prune packets when PIM snooping is employed.",
      "ja": "PEをスヌーピングPIMは、PIMにスヌープ透過VPLSでそれらをフラッディングながら/プルーンパケットに参加。 PIMの配信にVPLSによって導入は待ち時間がPIMスヌーピングが採用されたときに/プルーンパケット参加はありません。"
    },
    {
      "indent": 3,
      "text": "A PIM relay/proxying PE does not simply flood PIM Join/Prune packets. This can result in additional latency for a downstream CE to receive multicast traffic after it has sent a Join. When a downstream CE prunes a multicast stream, the traffic SHOULD stop flowing to the CE with no additional latency introduced by the VPLS.",
      "ja": "PIMリレー/プロキシのPEは単にPIMは/プルーンパケット参加フラッディングされません。これは、参加を送信した後にマルチキャストトラフィックを受信するために下流のCEのための追加の待ち時間が発生することができます。下流のCEは、マルチキャストストリームを剪定すると、トラフィックがVPLSによって導入されていない追加のレイテンシでCEに流れる停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "Performing only proxying of Join/Prune and not Hello messages keeps the PE's behavior very similar to that of a PIM router, without introducing too much additional complexity. It keeps the PIM proxying solution fairly simple. Since Join/Prune messages are forwarded by a PE along the slow path and all other PIM packet types are forwarded along the fast path, it is very likely that packets forwarded along the fast path will arrive \"ahead\" of Join/Prune packets at a CE router (note the stress on the fact that fast-path messages will never arrive after Join/Prune packets). Of particular importance are Hello packets sent along the fast path. We can construct a variety of scenarios resulting in out-of-order delivery of Hellos and Join/Prune messages. However, there should be no deviation from normal expected behavior observed at the CE router receiving these messages out of order.",
      "ja": "こんにちは参加/プルーンの唯一のプロキシを実行していないメッセージは、あまりにも多くの追加的な複雑さを導入することなく、PIMルータのものと非常に類似したPEの動作を保持します。それはかなり単純なPIMのプロキシソリューションを保持します。以来/プルーンのメッセージは、低速パスおよび高速パスに沿って転送されている他のすべてのPIMパケットタイプに沿っPEによって転送されて参加し、高速パスに沿って転送されたパケットは、時/プルーンパケット参加の「先」に到着する可能性が非常に高いですCEルータ（ファストパスメッセージは/プルーンパケットに参加した後に到着したことがないという事実上のストレスに注意してください）。特に重要なのは、ファストパスに沿って送信されたHelloパケットです。私たちはハローズのアウトオブオーダー配信結果として、さまざまなシナリオを構築し、/プルーンのメッセージに参加することができます。しかし、順不同で、これらのメッセージを受信したCEルータで観測された通常期待される行動からの逸脱があってはなりません。"
    },
    {
      "indent": 0,
      "text": "2.4.3. When to Snoop and When to Proxy",
      "section_title": true,
      "ja": "2.4.3。ときスヌープへとすると、プロキシへ"
    },
    {
      "indent": 3,
      "text": "From the above descriptions, factors that affect the choice of snooping/relay/proxying include:",
      "ja": "以上の説明から、スヌーピング/リレー/プロキシの選択に影響を与える要因は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Whether CEs do Join suppression or not",
      "ja": "CEが抑制に参加したりしていないかどうかO"
    },
    {
      "indent": 3,
      "text": "o Whether Join/Prune latency is critical or not",
      "ja": "Oかどうかは、/プルーンレイテンシが重要であるかを参加します"
    },
    {
      "indent": 3,
      "text": "o Whether the scale of PIM protocol messages/states in a VPLS requires the scaling benefit of proxying",
      "ja": "VPLSでのPIMプロトコルメッセージ/状態の規模は、プロキシのスケーリングの利益を必要とするかどうかO"
    },
    {
      "indent": 3,
      "text": "Of the above factors, Join suppression is the hard one -- pure snooping can only be used when Join suppression is disabled on all CEs. The latency associated with relay/proxying is implementation dependent and may not be a concern at all with a particular implementation. The scaling benefit may not be important either, in that on a real LAN with Explicit Tracking (ET) a PIM router will need to receive and process all PIM Join/Prune messages as well.",
      "ja": "抑制がすべてのCE上で無効になって参加したときにのみ使用することができ、純粋スヌーピング - 上記の要因のうち、抑制が難しいものです参加。中継/プロキシに関連する待ち時間は実装依存であり、特定の実装とまったく懸念ではないかもしれません。スケーリングの利点は、明示的なトラッキング（ET）ルータが同様にすべてのPIM参加/プルーンのメッセージを受信して​​処理する必要がありますPIMと実際のLAN上のことで、どちらかは重要ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "A PIM router indicates that Join suppression is disabled if the T-bit is set in the LAN Prune Delay option of its Hello message. If all PIM routers on a LAN set the T-bit, ET is possible, allowing an upstream router to track all the downstream neighbors that have Join states for any (S,G) or (*,G). This has two benefits:",
      "ja": "PIMルータは、Tビットは、そのHelloメッセージのLANプルーンDelayオプションに設定されている場合、その参加抑制が無効になっていることを示します。 LAN上のすべてのPIMルータがTビットを設定した場合、ETは、アップストリームルータは、任意の（S、G）または（*、G）のための状態に参加しているすべてのダウンストリームネイバーを追跡することを可能にする、ことが可能です。これには2つの利点があります。"
    },
    {
      "indent": 3,
      "text": "o No need for the Prune-Pending process -- the upstream router may immediately stop forwarding data when it receives a Prune from the last downstream neighbor and immediately prune to its upstream neighbor.",
      "ja": "プルーン・保留処理の必要はありません○ - それは最後の下流隣人からプルーンを受信したときに、上流ルータは直ちにデータの転送を停止することがあり、すぐにその上流ネイバーにプルーニング。"
    },
    {
      "indent": 3,
      "text": "o For management purposes, the upstream router knows exactly which downstream routers exist for a particular Join state.",
      "ja": "管理目的のためにO、上流のルータがダウンストリームルータが特定の参加状態のために存在するかを正確に知っています。"
    },
    {
      "indent": 3,
      "text": "While full proxying can be used with or without Join suppression on CEs and does not interfere with an upstream CE's bypass of the Prune-Pending process, it does proxy all its downstream CEs as a single one to the upstream neighbors, removing the second benefit mentioned above.",
      "ja": "フルプロキシは、一緒に使用または無しのCE上の抑制に参加し、プルーン・保留プロセスの上流のCEのバイパスを妨害しないことができるが、それが前記第二の利益を除去し、上流の近隣に単一のものとしてプロキシすべての下流のCEを行い上記。"
    },
    {
      "indent": 3,
      "text": "Therefore, the general rule is that if Join suppression is enabled on one or more CEs, then proxying or relay MUST be used, but if Join suppression is known to be disabled on all CEs, then snooping, relay, or proxying MAY be used, while snooping or relay SHOULD be used.",
      "ja": "そのため、一般的なルールがあるの抑制は、一の以上のCE上で有効になって、その後リレーが使用されなければならないプロキシまたは、しかし、すべてのCEに抑制無効にすることが知られている参加した場合、その後、スヌーピング、リレー、またはプロキシを使用することができるされて参加した場合には、スヌーピングまたはリレーしながら、使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY choose to dynamically determine which mode to use, through the tracking of the above-mentioned T-bit in all snooped PIM Hello messages, or MAY simply require static provisioning.",
      "ja": "実装は動的に使用するモードを決定するために選ぶかもしれ、すべてにおける上記Tビットのトラッキングを介してPIM Helloメッセージをスヌープ、又は単に静的プロビジョニングを必要とする場合があります。"
    },
    {
      "indent": 0,
      "text": "2.5. Discovering PIM Routers",
      "section_title": true,
      "ja": "2.5。 PIMルータを発見"
    },
    {
      "indent": 3,
      "text": "A PIM snooping PE MUST snoop on PIM Hellos received on ACs and PWs. That is, the PE transparently floods the PIM Hello while snooping on it. PIM Hellos are used by the snooping PE to discover PIM routers and their characteristics.",
      "ja": "PEは、PIM helloメッセージをスヌープしなければならないスヌーピングPIMは、ACSおよびPW上で受信されました。その上でスヌーピングしながら、つまり、PEは、透過的にPIMハローをフラッディングします。 PIMハローズは、PIMルータとその特性を発見するためにスヌーピングPEによって使用されています。"
    },
    {
      "indent": 3,
      "text": "For each neighbor discovered by a PE, it includes an entry in the PIM Neighbor Database with the following fields:",
      "ja": "PEによって発見された各隣人のために、それは次のフィールドを持つPIMネイバーデータベース内のエントリが含まれています。"
    },
    {
      "indent": 3,
      "text": "o Layer 2 encapsulation for the router sending the PIM Hello.",
      "ja": "PIMハローを送信するルータのOレイヤ2カプセル化。"
    },
    {
      "indent": 3,
      "text": "o IP address and address family of the router sending the PIM Hello.",
      "ja": "O IPアドレスとPIMのHelloを送信するルータのアドレスファミリ。"
    },
    {
      "indent": 3,
      "text": "o Port (AC/PW) on which the PIM Hello was received.",
      "ja": "PIMハローが受信されたOポート（AC / PW）。"
    },
    {
      "indent": 3,
      "text": "o Hello Option fields.",
      "ja": "こんにちはOオプションフィールド。"
    },
    {
      "indent": 3,
      "text": "The PE should be able to interpret and act on Hello Option fields as currently defined in RFC 7761 [PIM-SM]. The Option fields of particular interest in this document are:",
      "ja": "PEは解釈し、現在RFC 7761 [PIM-SM]で定義されたハローのオプションフィールドに作用することができなければなりません。この文書の特定の関心のオプションフィールドは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Hello-Hold-Time",
      "ja": "Oこんにちはホールドタイム"
    },
    {
      "indent": 3,
      "text": "o Tracking Support",
      "ja": "Oトラッキングのサポート"
    },
    {
      "indent": 3,
      "text": "o Designated Router (DR) Priority",
      "ja": "O指定ルータ（DR）プライオリティ"
    },
    {
      "indent": 3,
      "text": "Please refer to RFC 7761 [PIM-SM] for a list of the Hello Option fields. When a PIM Hello is received, the PE MUST reset the neighbor-expiry-timer to Hello-Hold-Time. If a PE does not receive a Hello message from a router within Hello-Hold-Time, the PE MUST remove that neighbor from its PIM Neighbor Database. If a PE receives a Hello message from a router with the Hello-Hold-Time value set to zero, the PE MUST remove that router from the PIM snooping state immediately.",
      "ja": "こんにちはオプションフィールドのリストについては、RFC 7761 [PIM-SM]を参照してください。 PIMハローが受信されると、PEこんにちはホールド時間に近隣有効期限タイマーをリセットしなければなりません。 PEこんにちは、ホールド時間内にルータからHelloメッセージを受信しない場合、PEはそのPIMネイバーデータベースからそのネイバーを削除する必要があります。 PEはゼロに設定こんにちは、ホールドタイム値を持つルータからHelloメッセージを受信した場合、PEは直後の状態をスヌーピングPIMからそのルータを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "From the PIM Neighbor Database, a PE MUST be able to use the procedures defined in RFC 7761 [PIM-SM] to identify the PIM DR in the VPLS instance. It should also be able to determine if tracking support is active in the VPLS instance.",
      "ja": "PIMネイバーデータベースから、PEは、VPLSインスタンスでPIM DRを識別するために、[PIM-SM] RFC 7761で定義された手順を使用することができなければなりません。また、トラッキングサポートがVPLSインスタンスでアクティブであるかどうかを決定することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.6. PIM-SM and PIM-SSM",
      "section_title": true,
      "ja": "2.6。 PIM-SMとPIM-SSM"
    },
    {
      "indent": 3,
      "text": "The key characteristic of PIM-SM and PIM-SSM is explicit Join behavior. In this model, multicast traffic is only forwarded to locations that specifically request it. All the procedures described in this section apply to both PIM-SM and PIM-SSM, except for the fact that there is no (*,G) state in PIM-SSM.",
      "ja": "PIM-SMとPIM-SSMの重要な特徴は、行動に参加し、明示的です。このモデルでは、マルチキャストトラフィックは、具体的にそれを要求した場所に転送されます。このセクションで説明するすべての手順は、PIM-SSMには（*、G）ステートが存在しないという事実を除いて、PIM-SMおよびPIM-SSMの両方に適用されます。"
    },
    {
      "indent": 0,
      "text": "2.6.1. Building PIM-SM States",
      "section_title": true,
      "ja": "2.6.1。ビルPIM-SMの状態"
    },
    {
      "indent": 3,
      "text": "PIM-SM and PIM-SSM states are built by snooping on the PIM-SM Join/Prune messages received on ACs/PWs.",
      "ja": "PIM-SMとPIM-SSM状態は、PIM-SMにスヌーピングによって構築されている/プルーンのメッセージは、ACS / PWを上で受信しましょう。"
    },
    {
      "indent": 3,
      "text": "The downstream state machine of a PIM-SM snooping PE very closely resembles the downstream state machine of PIM-SM routers. The downstream state consists of:",
      "ja": "PIM-SMスヌーピングPEの下流ステートマシンは、非常に密接にPIM-SMルータの下流のステートマシンに似ています。下流の状態はで構成されています。"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,*,G):",
      "ja": "パー下流（ポート、*、G）："
    },
    {
      "indent": 3,
      "text": "o DownstreamJPState: One of {\"NoInfo\" (NI), \"Join\" (J), \"Prune-Pending\" (PP)}",
      "ja": "O DownstreamJPState：の一つ{ \"NoInfo\"（NI）、 \"参加\"（J）、 \"プルーン・保留\"（PP）}"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,*,G,N):",
      "ja": "下流あたり（ポート、*、G、N）："
    },
    {
      "indent": 3,
      "text": "o Prune-Pending Timer (PPT(N))",
      "ja": "Oプルーン・ペンディングタイマ（PPT（N））"
    },
    {
      "indent": 3,
      "text": "o Join Expiry Timer (ET(N))",
      "ja": "O入会有効期限タイマ（ET（N））"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,S,G):",
      "ja": "パー下流（ポート、S、G）："
    },
    {
      "indent": 3,
      "text": "o DownstreamJPState: One of {\"NoInfo\" (NI), \"Join\" (J), \"Prune-Pending\" (PP)}",
      "ja": "O DownstreamJPState：の一つ{ \"NoInfo\"（NI）、 \"参加\"（J）、 \"プルーン・保留\"（PP）}"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,S,G,N):",
      "ja": "下流（ポート、S、G、N）ごとに："
    },
    {
      "indent": 3,
      "text": "o Prune-Pending Timer (PPT(N))",
      "ja": "Oプルーン・ペンディングタイマ（PPT（N））"
    },
    {
      "indent": 3,
      "text": "o Join Expiry Timer (ET(N))",
      "ja": "O入会有効期限タイマ（ET（N））"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,S,G,rpt):",
      "ja": "下流（ポート、S、G、RPT）あたり："
    },
    {
      "indent": 3,
      "text": "o DownstreamJPRptState: One of {\"NoInfo\" (NI), \"Pruned\" (P), \"Prune-Pending\" (PP)}",
      "ja": "O DownstreamJPRptState：の一つ{ \"NoInfo\"（NI）、（P）、 \"プルーン・保留\"（PP） \"剪定\"}"
    },
    {
      "indent": 3,
      "text": "Per downstream (Port,S,G,rpt,N):",
      "ja": "下流あたり（ポート、S、G、RPT、N）："
    },
    {
      "indent": 3,
      "text": "o Prune-Pending Timer (PPT(N))",
      "ja": "Oプルーン・ペンディングタイマ（PPT（N））"
    },
    {
      "indent": 3,
      "text": "o Join Expiry Timer (ET(N))",
      "ja": "O入会有効期限タイマ（ET（N））"
    },
    {
      "indent": 3,
      "text": "where S is the address of the multicast source, G is the group address, and N is the Upstream Neighbor field in the Join/Prune message.",
      "ja": "Sはマルチキャストソースのアドレスであり、Gはグループアドレスであり、Nは参加/プルーンメッセージにおける上流隣接フィールドです。"
    },
    {
      "indent": 3,
      "text": "Note that unlike the case of PIM-SM routers, where the PPT and ET are per (Interface,S,G), PIM snooping PEs have to maintain the PPT and ET per (Port,S,G,N). The reasons for this are explained in Section 2.6.2.",
      "ja": "PPT及びETは（インターフェース、S、G）ごとであるPIM-SMルータの場合とは異なり、PIMスヌーピングPEは（ポート、S、G、N）ごとPPTおよびETを維持しなければならないことに留意されたいです。この理由は、セクション2.6.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "Apart from the above states, we define the following state summarization macros:",
      "ja": "上記以外の状態から、我々は次の状態の要約マクロを定義します。"
    },
    {
      "indent": 3,
      "text": "UpstreamNeighbors(*,G): If there are one or more Join(*,G)s received on any port with upstream neighbor N and ET(N) is active, then N is added to UpstreamNeighbors(*,G). This set is used to determine if a Join(*,G) or a Prune(*,G) with upstream neighbor N needs to be sent upstream.",
      "ja": "UpstreamNeighbors（*、G）は：が一つであるか、またはより上流隣接N及びET（N）との任意のポートで受信されたS（*、G）参加アクティブである場合、NはUpstreamNeighbors（*、G）に添加します。このセットは、参加するかどうかを決定するために使用される（*、G）または上流隣接Nとプルーン（*、G）は、上流送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "UpstreamNeighbors(S,G): If there are one or more Join(S,G)s received on any port with upstream neighbor N and ET(N) is active, then N is added to UpstreamNeighbors(S,G). This set is used to determine if a Join(S,G) or a Prune(S,G) with upstream neighbor N needs to be sent upstream.",
      "ja": "UpstreamNeighbors（S、G）：一つ以上の参加（S、G）が存在する場合は、上流の隣人NとET（N）を有する任意のポートで受信sはアクティブであり、その後、NはUpstreamNeighbors（S、G）に添加します。このセットは、N、上流送信する必要が上流隣接して（S、G）またはプルーン（S、G）に参加するかどうかを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "UpstreamPorts(*,G): This is the set of all Port(N) ports where N is in the set UpstreamNeighbors(*,G). Multicast streams forwarded using a (*,G) match MUST be forwarded to these ports. So, UpstreamPorts(*,G) MUST be added to OutgoingPortList(*,G).",
      "ja": "UpstreamPorts（*、G）：これは、Nが設定UpstreamNeighborsにあるすべてのポート（N）ポート（*、G）のセットです。 （*、G）マッチを使用して転送されたマルチキャストストリームは、これらのポートに転送されなければなりません。だから、UpstreamPorts（*、G）がOutgoingPortList（*、G）に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "UpstreamPorts(S,G): This is the set of all Port(N) ports where N is in the set UpstreamNeighbors(S,G). UpstreamPorts(S,G) MUST be added to OutgoingPortList(S,G).",
      "ja": "UpstreamPorts（S、G）：これは、Nが設定UpstreamNeighbors（S、G）にあるすべてのポート（N）ポートのセットです。 UpstreamPorts（S、G）はOutgoingPortList（S、G）に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "InheritedUpstreamPorts(S,G): This is the union of UpstreamPorts(S,G) and UpstreamPorts(*,G).",
      "ja": "InheritedUpstreamPorts（S、G）：これはUpstreamPorts（S、G）とUpstreamPorts（*、G）の労働組合です。"
    },
    {
      "indent": 3,
      "text": "UpstreamPorts(S,G,rpt): If PruneDesired(S,G,rpt) becomes TRUE, then this set is set to UpstreamPorts(*,G). Otherwise, this set is empty. UpstreamPorts(*,G) (-) UpstreamPorts(S,G,rpt) MUST be added to OutgoingPortList(S,G).",
      "ja": "UpstreamPorts（S、G、RPT）：PruneDesired（S、G、RPT）が真となる場合、このセットはUpstreamPorts（*、G）に設定されています。そうでない場合は、このセットは空です。 UpstreamPorts（*、G）（ - ）UpstreamPorts（S、G、RPT）がOutgoingPortList（S、G）に追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "UpstreamPorts(G): This set is the union of all the UpstreamPorts(S,G) and UpstreamPorts(*,G) for a given G. Proxy (S,G) Join/Prune and (*,G) Join/Prune messages MUST be sent to a subset of UpstreamPorts(G) as specified in Section 2.6.6.1.",
      "ja": "UpstreamPorts（G）：このセットは、指定されたG.プロキシ（S、G）のためのすべてのUpstreamPorts（S、G）とUpstreamPorts（*、G）の労働組合である/プルーンと（*、G）が参加/プルーンのメッセージに参加セクション2.6.6.1で指定されるようにUpstreamPorts（G）のサブセットに送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "PWPorts: This is the set of all PWs.",
      "ja": "PWPorts：これは、すべてのPWセットです。"
    },
    {
      "indent": 3,
      "text": "OutgoingPortList(*,G): This is the set of all ports to which traffic needs to be forwarded on a (*,G) match.",
      "ja": "OutgoingPortList（*、G）：これは、トラフィックが（*、G）一致に転送する必要があるために、すべてのポートのセットです。"
    },
    {
      "indent": 3,
      "text": "OutgoingPortList(S,G): This is the set of all ports to which traffic needs to be forwarded on an (S,G) match.",
      "ja": "OutgoingPortList（S、G）：これは、トラフィックが（S、G）一致に転送する必要があるために、すべてのポートのセットです。"
    },
    {
      "indent": 3,
      "text": "See Section 2.12 (\"Data-Forwarding Rules\") for the specification on how OutgoingPortList is calculated.",
      "ja": "OutgoingPortListを計算する方法の仕様については、セクション2.12（「データフォワーディングルール」）を参照してください。"
    },
    {
      "indent": 3,
      "text": "NumETsActive(Port,*,G): This is the number of (Port,*,G,N) entries that have the Expiry Timer running. This macro keeps track of the number of Join(*,G)s that are received on this Port with different upstream neighbors.",
      "ja": "NumETsActive（ポート、*、G）：これは、有効期限タイマーを実行している（ポート、*、G、N）のエントリーの数です。このマクロは、異なる上流の隣人と、このポートで受信されている参加（*、G）の数を追跡します。"
    },
    {
      "indent": 3,
      "text": "NumETsActive(Port,S,G): This is the number of (Port,S,G,N) entries that have the Expiry Timer running. This macro keeps track of the number of Join(S,G)s that are received on this Port with different upstream neighbors.",
      "ja": "NumETsActive（ポート、S、G）：これは、有効期限タイマーを実行している（ポート、S、G、N）のエントリの数です。このマクロは、異なる上流の隣人と、このポートで受信された参加（S、G）Sの数を追跡します。"
    },
    {
      "indent": 3,
      "text": "JoinAttributeTlvs(*,G): Join Attributes (RFC 5384 [JOIN-ATTR]) are TLVs that may be present in received Join(*,G) messages. An example would be Reverse Path Forwarding (RPF) Vectors (RFC 5496 [RPF-VECTOR]). If present, they must be copied to JoinAttributeTlvs(*,G).",
      "ja": "JoinAttributeTlvs（*、G）：（[JOIN-ATTR]をRFC 5384）属性の参加は、受信した参加（*、G）メッセージ中に存在してもよいのTLVです。例は、リバースパス転送（RPF）ベクター（RFC 5496 [RPF-VECTOR]）であろう。存在する場合、彼らはJoinAttributeTlvs（*、G）にコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "JoinAttributeTlvs(S,G): Join Attributes (RFC 5384 [JOIN-ATTR]) are TLVs that may be present in received Join(S,G) messages. If present, they must be copied to JoinAttributeTlvs(S,G).",
      "ja": "JoinAttributeTlvs（S、G）：（[JOIN-ATTR]をRFC 5384）属性の参加は、受信した参加（S、G）メッセージ中に存在してもよいのTLVです。存在する場合、それらはJoinAttributeTlvs（S、G）にコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "Since there are a few differences between the downstream state machines of PIM-SM routers and PIM-SM snooping PEs, we specify the details of the downstream state machine of PIM-SM snooping PEs, at the risk of repeating most of the text documented in RFC 7761 [PIM-SM].",
      "ja": "PIM-SMルータとPIM-SMスヌーピングPEの下流のステートマシンはいくつかの違いがあるので、我々はで文書のテキストのほとんどを繰り返す危険で、PIM-SMスヌーピングPEの下流のステートマシンの詳細を指定しますRFC 7761 [PIM-SM]。"
    },
    {
      "indent": 0,
      "text": "2.6.2. Explanation for Per-(S,G,N) States",
      "section_title": true,
      "ja": "2.6.2。パー（S、G、N）の状態についての説明"
    },
    {
      "indent": 3,
      "text": "In PIM routing protocols, states are built per (S,G). On a router, an (S,G) has only one RPF-Neighbor. However, a PIM snooping PE does not have the Layer 3 routing information available to the routers in order to determine the RPF-Neighbor for a multicast flow. It merely discovers it by snooping the Join/Prune message. A PE could have snooped on two or more different Join/Prune messages for the same (S,G) that could have carried different Upstream Neighbor fields. This could happen during transient network conditions or due to dual-homed sources. A PE cannot make assumptions on which one to pick but instead must allow the CE routers to decide which upstream neighbor gets elected as the RPF-Neighbor. And for this purpose, the PE will have to track downstream and upstream Joins and Prunes per (S,G,N).",
      "ja": "PIMルーティングプロトコルでは、状態は（S、G）ごとに構築されます。ルータ上で、（S、G）は一つだけRPF-ネイバーを有しています。しかし、PEスヌーピングPIMは、マルチキャストフローのためのRPFネイバーを決定するためにルータに利用可能なレイヤ3ルーティング情報を有していません。これは、単に参加/プルーンのメッセージをスヌーピングすることにより、それを検出します。 PEは、異なる上流隣接フィールドを行っている可能性が同じ（S、G）のための2つ以上の異なる参加/プルーンメッセージにスヌープしている可能性があります。これは一時的なネットワークの状態の間に起こるまたはデュアルホームソースに起因することができます。 PEは、選択する代わりに、CEルータが上流の隣人がRPF-近隣に選出されますかを決定できるようにする必要がありますどちらに仮定することはできません。この目的のために、PEは、下流と上流の参加及び（S、G、N）ごとにプルーンを追跡する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6.3. Receiving (*,G) PIM-SM Join/Prune Messages",
      "section_title": true,
      "ja": "2.6.3。受信（*、G）PIM-SM参加/プルーンのメッセージ"
    },
    {
      "indent": 3,
      "text": "A Join(*,G) or Prune(*,G) is considered \"received\" if one of the following conditions is met:",
      "ja": "A（* G）に参加またはプルーン（*、G）は、以下のいずれかの条件が満たされた場合、「受信した」とみなされます。"
    },
    {
      "indent": 3,
      "text": "o The port on which it arrived is not Port(N) where N is the upstream neighbor N of the Join/Prune(*,G).",
      "ja": "Oそれが到着したポートは、ポートNが参加/プルーン（*、G）の上流隣接Nです（N）ではありません。"
    },
    {
      "indent": 3,
      "text": "o If both Port(N) and the arrival port are PWs, then there exists at least one other (*,G,Nx) or (Sx,G,Nx) state with an AC UpstreamPort.",
      "ja": "両方のポート（N）および到着ポートのPWである場合、O、次いでAC UpstreamPortを有する少なくとも一つの他の（*、G、Nxの）または（SX、G、Nxの）状態が存在します。"
    },
    {
      "indent": 3,
      "text": "For simplicity, the case where both Port(N) and the arrival port are PWs is referred to as \"PW-only Join/Prune\" in this document. The PW-only Join/Prune handling is so that the Port(N) PW can be added to the related forwarding entries' OutgoingPortList to trigger an Assert, but that is only needed for those states with AC UpstreamPorts. Note that in the PW-only case, it is OK for the arrival port and Port(N) to be the same. See Appendix B for examples.",
      "ja": "簡単にするため、ポート（N）および到着ポートの両方がのPWである場合は、この文書の「PW-のみ/プルーンに参加」と呼ばれます。 PW-のみ参加/プルーン処理するようにポート（N）PWはアサートをトリガするために、関連するフォワーディングエントリOutgoingPortListに添加することができるが、それだけAC UpstreamPortsとこれらの状態のために必要とされます。 PW-場合にのみ、同じであることが到着ポートおよびポート（N）のためのOKであることに留意されたいです。例については、付録Bを参照してください。"
    },
    {
      "indent": 3,
      "text": "When a router receives a Join(*,G) or a Prune(*,G) with upstream neighbor N, it must process the message as defined in the state machine below. Note that the macro computations of the various macros resulting from this state machine transition are exactly as specified in RFC 7761 [PIM-SM].",
      "ja": "ルータは、上流の隣人Nと（*、G）Joinまたはプルーニング（*、G）を受信すると以下のステートマシンで定義され、それはメッセージを処理しなければなりません。 RFC 7761 [PIM-SM]で指定され、この状態マシン遷移に起因する様々なマクロのマクロ計算が正確であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "We define the following per-port (*,G,N) macro to help with the state machine below.",
      "ja": "私たちは、以下のステート・マシンを支援するために、次のポートごとに（*、G、N）マクロを定義します。"
    },
    {
      "indent": 3,
      "text": "+---------------++-------------------------------------------------+\n|               ||                 Previous State                  |\n|               ++-------------+--------------+--------------------+\n| Event         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |\n+---------------++-------------+--------------+--------------------+\n| Receive       || -> J state  | -> J state   | -> J state         |\n| Join(*,G)     || Action      | Action       | Action             |\n|               || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |\n+---------------++-------------+--------------+--------------------+\n|Receive        || -           | -> PP state  | -> PP state        |\n|Prune(*,G) and ||             | Start PPT(N) |                    |\n|NumETsActive<=1||             |              |                    |\n+---------------++-------------+--------------+--------------------+\n|Receive        || -           | -> J state   | -                  |\n|Prune(*,G) and ||             | Start PPT(N) |                    |\n|NumETsActive>1 ||             |              |                    |\n+---------------++-------------+--------------+--------------------+\n|PPT(N) expires || -           | -> J state   | -> NI state        |\n|               ||             | Action       | Action             |\n|               ||             | PPTExpiry(N) | PPTExpiry(N)       |\n+---------------++-------------+--------------+--------------------+\n|ET(N) expires  || -           | -> NI state  | -> NI state        |\n|and            ||             | Action       | Action             |\n|NumETsActive<=1||             | ETExpiry(N)  | ETExpiry(N)        |\n+---------------++-------------+--------------+--------------------+\n|ET(N) expires  || -           | -> J state   | -                  |\n|and            ||             | Action       |                    |\n|NumETsActive>1 ||             | ETExpiry(N)  |                    |\n+---------------++-------------+--------------+--------------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: Downstream Per-Port (*,G) State Machine in Tabular Form",
      "ja": "図1：ダウンストリームポート単位の表形式で（*、G）ステートマシン"
    },
    {
      "indent": 3,
      "text": "Action RxJoin(N):",
      "ja": "アクションRxJoin（N）："
    },
    {
      "indent": 6,
      "text": "If ET(N) is not already running, then start ET(N). Otherwise, restart ET(N). If N is not already in UpstreamNeighbors(*,G), then add N to UpstreamNeighbors(*,G) and trigger a Join(*,G) with upstream neighbor N to be forwarded upstream. If there are Join Attribute TLVs in the received (*,G) message and if they are different from the recorded JoinAttributeTlvs(*,G), then copy them into JoinAttributeTlvs(*,G). In the case of conflicting attributes, the PE will need to perform conflict resolution per (N) as described in RFC 5384 [JOIN-ATTR].",
      "ja": "ET（N）がすでに実行されていない場合は、ET（N）を起動します。それ以外の場合は、ET（N）を再起動します。 NはUpstreamNeighbors（*、G）にない場合、UpstreamNeighbors（*、G）にNを追加し、（*、G）上流の隣人Nと、上流転送する参加トリガー。そこに受信（*、G）メッセージ内の属性のTLVに参加していると、彼らが記録さJoinAttributeTlvs（*、G）が異なっている場合、JoinAttributeTlvs（*、G）にコピーした場合。矛盾する属性の場合、PEは、RFC 5384 [JOIN-ATTR]に記載されているように（N）当たりの競合解決を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Action PPTExpiry(N):",
      "ja": "アクションPPTExpiry（N）："
    },
    {
      "indent": 6,
      "text": "Same as Action ETExpiry(N) below, plus send a Prune-Echo(*,G) with upstream neighbor N on the downstream port.",
      "ja": "以下のアクションETExpiry（N）と同じで、プラスダウンストリームポートの上流の隣人Nとプルーン・エコー（*、G）を送ります。"
    },
    {
      "indent": 3,
      "text": "Action ETExpiry(N):",
      "ja": "アクションETExpiry（N）："
    },
    {
      "indent": 6,
      "text": "Disable timers ET(N) and PPT(N). Delete Neighbor state (Port,*,G,N). If there are no other (Port,*,G) states with NumETsActive(Port,*,G) > 0, transition DownstreamJPState (RFC 7761 [PIM-SM]) to NoInfo. If there are no other (Port,*,G,N) states (different ports but for the same N), remove N from UpstreamPorts(*,G) -- this will also trigger the Upstream Finite State Machine (FSM) with \"JoinDesired(*,G,N) to FALSE\".",
      "ja": "無効タイマET（N）とPPT（N）。近隣の状態（ポート、*、G、N）を削除します。他に存在しない場合（ポートは、*、G）NoInfoにNumETsActive（ポート、*、G）> 0、遷移DownstreamJPState（RFC 7761 [PIM-SM]）と述べています。無（ポート、*、G、N）の状態、他の（異なるポートが、同じNのためには）存在しない場合は、UpstreamPorts（*、G）からNを削除する - これはまた、「上流有限状態機械（FSM）をトリガしますJoinDesired FALSEに（*、G、N）」。"
    },
    {
      "indent": 0,
      "text": "2.6.4. Receiving (S,G) PIM-SM Join/Prune Messages",
      "section_title": true,
      "ja": "2.6.4。受信（S、G）PIM-SM参加/プルーンのメッセージ"
    },
    {
      "indent": 3,
      "text": "A Join(S,G) or Prune(S,G) is considered \"received\" if one of the following conditions is met:",
      "ja": "：A参加（S、G）またはプルーン（S、G）は、以下のいずれかの条件が満たされた場合、「受信した」とみなされます"
    },
    {
      "indent": 3,
      "text": "o The port on which it arrived is not Port(N) where N is the upstream neighbor N of the Join/Prune(S,G).",
      "ja": "N参加/プルーン（S、G）の上流隣接Nである場合、それが到着したポートOポート（N）ではありません。"
    },
    {
      "indent": 3,
      "text": "o If both Port(N) and the arrival port are PWs, then there exists at least one other (*,G,Nx) or (S,G,Nx) state with an AC UpstreamPort.",
      "ja": "両方のポート（N）および到着ポートのPWである場合、O、次いでAC UpstreamPortを有する少なくとも一つの他の（*、G、Nxの）または（S、G、Nxの）状態が存在します。"
    },
    {
      "indent": 3,
      "text": "For simplicity, the case where both Port(N) and the arrival port are PWs is referred to as \"PW-only Join/Prune\" in this document. The PW-only Join/Prune handling is so that the Port(N) PW can be added to the related forwarding entries' OutgoingPortList to trigger an Assert, but that is only needed for those states with AC UpstreamPorts. Note that in the PW-only case, it is OK for the arrival port and Port(N) to be the same. See Appendix B for examples.",
      "ja": "簡単にするため、ポート（N）および到着ポートの両方がのPWである場合は、この文書の「PW-のみ/プルーンに参加」と呼ばれます。 PW-のみ参加/プルーン処理するようにポート（N）PWはアサートをトリガするために、関連するフォワーディングエントリOutgoingPortListに添加することができるが、それだけAC UpstreamPortsとこれらの状態のために必要とされます。 PW-場合にのみ、同じであることが到着ポートおよびポート（N）のためのOKであることに留意されたいです。例については、付録Bを参照してください。"
    },
    {
      "indent": 3,
      "text": "When a router receives a Join(S,G) or a Prune(S,G) with upstream neighbor N, it must process the message as defined in the state machine below. Note that the macro computations of the various macros resulting from this state machine transition are exactly as specified in RFC 7761 [PIM-SM].",
      "ja": "ルータは、上流隣接Nと（S、G）またはプルーン（S、G）参加を受信した場合に以下の状態マシンで定義され、それはメッセージを処理しなければなりません。 RFC 7761 [PIM-SM]で指定され、この状態マシン遷移に起因する様々なマクロのマクロ計算が正確であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "+---------------++-------------------------------------------------+\n|               ||                 Previous State                  |\n|               ++-------------+--------------+--------------------+\n| Event         || NoInfo (NI) | Join (J)     | Prune-Pending (PP) |\n+---------------++-------------+--------------+--------------------+\n| Receive       || -> J state  | -> J state   | -> J state         |\n| Join(S,G)     || Action      | Action       | Action             |\n|               || RxJoin(N)   | RxJoin(N)    | RxJoin(N)          |\n+---------------++-------------+--------------+--------------------+\n|Receive        || -           | -> PP state  | -                  |\n|Prune(S,G) and ||             | Start PPT(N) |                    |\n|NumETsActive<=1||             |              |                    |\n+---------------++-------------+--------------+--------------------+\n|Receive        || -           | -> J state   | -                  |\n|Prune(S,G) and ||             | Start PPT(N) |                    |\n|NumETsActive>1 ||             |              |                    |\n+---------------++-------------+--------------+--------------------+\n|PPT(N) expires || -           | -> J state   | -> NI state        |\n|               ||             | Action       | Action             |\n|               ||             | PPTExpiry(N) |PPTExpiry(N)        |\n+---------------++-------------+--------------+--------------------+\n|ET(N) expires  || -           | -> NI state  | -> NI state        |\n|and            ||             | Action       | Action             |\n|NumETsActive<=1||             | ETExpiry(N)  | ETExpiry(N)        |\n+---------------++-------------+--------------+--------------------+\n|ET(N) expires  || -           | -> J state   | -                  |\n|and            ||             | Action       |                    |\n|NumETsActive>1 ||             | ETExpiry(N)  |                    |\n+---------------++-------------+--------------+--------------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 2: Downstream Per-Port (S,G) State Machine in Tabular Form",
      "ja": "図2：表形式でダウンストリームポート単位の（S、G）ステートマシン"
    },
    {
      "indent": 3,
      "text": "Action RxJoin(N):",
      "ja": "アクションRxJoin（N）："
    },
    {
      "indent": 6,
      "text": "If ET(N) is not already running, then start ET(N). Otherwise, restart ET(N).",
      "ja": "ET（N）がすでに実行されていない場合は、ET（N）を起動します。それ以外の場合は、ET（N）を再起動します。"
    },
    {
      "indent": 6,
      "text": "If N is not already in UpstreamNeighbors(S,G), then add N to UpstreamNeighbors(S,G) and trigger a Join(S,G) with upstream neighbor N to be forwarded upstream. If there are Join Attribute TLVs in the received (S,G) message and if they are different from the recorded JoinAttributeTlvs(S,G), then copy them into JoinAttributeTlvs(S,G). In cases of conflicting attributes, the PE will need to perform conflict resolution per (N) as described in RFC 5384 [JOIN-ATTR].",
      "ja": "NはUpstreamNeighbors（S、G）にない場合、UpstreamNeighbors（S、G）にNを追加して、上流側に転送する上流隣接Nとの結合（S、G）をトリガします。ある場合は、受信した（S、G）メッセージ内の属性のTLVに参加し、彼らが記録さJoinAttributeTlvs（S、G）と異なっている場合、JoinAttributeTlvs（S、G）にコピーします。矛盾する属性の場合には、PEは、RFC 5384 [JOIN-ATTR]に記載されているように（N）当たりの競合解決を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Action PPTExpiry(N):",
      "ja": "アクションPPTExpiry（N）："
    },
    {
      "indent": 6,
      "text": "Same as Action ETExpiry(N) below, plus send a Prune-Echo(S,G) with upstream neighbor N on the downstream port.",
      "ja": "以下のアクションETExpiry（N）と同じ、プラスダウンストリームポートに上流隣接Nとプルーンエコー（S、G）を送ります。"
    },
    {
      "indent": 3,
      "text": "Action ETExpiry(N):",
      "ja": "アクションETExpiry（N）："
    },
    {
      "indent": 6,
      "text": "Disable timers ET(N) and PPT(N). Delete Neighbor state (Port,S,G,N). If there are no other (Port,S,G) states with NumETsActive(Port,S,G) > 0, transition DownstreamJPState to NoInfo. If there are no other (Port,S,G,N) states (different ports but for the same N), remove N from UpstreamPorts(S,G) -- this will also trigger the Upstream FSM with \"JoinDesired(S,G,N) to FALSE\".",
      "ja": "無効タイマET（N）とPPT（N）。近隣状態（ポート、S、G、N）を削除します。他（ポート、S、G）が存在しない場合NumETsActive（ポート、S、G）> 0、NoInfoへ遷移DownstreamJPStateと述べています。他（ポート、S、G、N）の状態（異なるポートが、同じNの場合）、UpstreamPorts（S、G）から、Nを削除がない場合 - これはまたJoinDesired（S、G」上流FSMをトリガしますFALSEに、N）」。"
    },
    {
      "indent": 0,
      "text": "2.6.5. Receiving (S,G,rpt) Join/Prune Messages",
      "section_title": true,
      "ja": "2.6.5。 （S、G、RPT）/プルーンのメッセージを受信参加"
    },
    {
      "indent": 3,
      "text": "A Join(S,G,rpt) or Prune(S,G,rpt) is \"received\" when the port on which it was received is not also the port on which the upstream neighbor N of the Join/Prune(S,G,rpt) was learned.",
      "ja": "（S、G、RPT）又はプルーン（S、G、RPT）が受信したポートがポートもない場合、「受信」さに参加した上で参加/プルーン（S、Gの上流隣接N 、RPT）を学びました。"
    },
    {
      "indent": 3,
      "text": "While it is important to ensure that the (S,G) and (*,G) state machines allow for handling per-(S,G,N) states, it is not as important for (S,G,rpt) states. It suffices to say that the downstream (S,G,rpt) state machine is the same as what is defined in Section 4.5.3 of RFC 7761 [PIM-SM].",
      "ja": "それは（S、G）および（*、G）ステート・マシンは（S、G、N）状態をパーハンドリングを可能にすることを確実にするために重要であるが、それは（S、G、RPT）の状態のために重要ではありません。これは、下流の（S、G、RPT）ステートマシンは、RFC 7761 [PIM-SM]のセクション4.5.3で定義されているものと同じであると言うことで十分です。"
    },
    {
      "indent": 0,
      "text": "2.6.6. Sending Join/Prune Messages Upstream",
      "section_title": true,
      "ja": "2.6.6。上流参加/プルーンのメッセージの送信"
    },
    {
      "indent": 3,
      "text": "This section applies only to a PIM relay/proxying PE and not to a PIM snooping PE.",
      "ja": "このセクションでは、唯一のPIMリレー/プロキシのPEにはないPEをスヌーピングPIMに適用されます。"
    },
    {
      "indent": 3,
      "text": "A full PIM proxying (not relay) PE MUST implement the Upstream FSM along the lines of the procedure described in Section 4.5.4 of RFC 7761 [PIM-SM].",
      "ja": "完全なPIMのプロキシ（中継しない）PEは、RFC 7761のセクション4.5.4に記載された手順の線に沿って[PIM-SMを上流FSMを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the purposes of the Upstream FSM, a Join or Prune message with upstream neighbor N is \"seen\" on a PIM relay/proxying PE if the port on which the message was received is also Port(N) and the port is an AC. The AC requirement is needed because a Join received on the Port(N) PW must not suppress this PE's Join on that PW.",
      "ja": "メッセージを受信したポートはまた、ポート（N）であり、ポートがACである場合に上流FSMの目的のために、上流隣接Nと結合またはプルーニングメッセージは、PIM中継/プロキシのPEの「見」されています。このPEのはPWことで参加抑制してはならないポート（N）PW上で受信入会ので、AC要件が必要とされています。"
    },
    {
      "indent": 3,
      "text": "A PIM relay PE does not implement the Upstream FSM. It simply forwards received Join/Prune messages out of the same set of upstream ports as in the PIM proxying case.",
      "ja": "PIMリレーPEは、上流FSMを実装していません。単に転送PIMのプロキシの場合のようにアップストリームポートの同じセットのうち/参加プルーンメッセージを受信しました。"
    },
    {
      "indent": 3,
      "text": "In order to correctly facilitate Asserts among the CE routers, such Join/Prune messages need to send not only towards the upstream neighbor but also on certain PWs, as described below.",
      "ja": "後述のように正しくCEルータ間アサート容易にするために、このような参加/プルーンのメッセージは、上流隣接の方だけでなく、特定のPWの上だけでなく、送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If JoinAttributeTlvs(*,G) is not empty, then it must be encoded in a Join(*,G) message sent upstream.",
      "ja": "JoinAttributeTlvs（*、G）が空でない場合、それは上流の送信参加（*、G）メッセージに符号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If JoinAttributeTlvs(S,G) is not empty, then it must be encoded in a Join(S,G) message sent upstream.",
      "ja": "JoinAttributeTlvs（S、G）が空でない場合、それは上流の送信参加（S、G）メッセージに符号化されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.6.1. Where to Send Join/Prune Messages",
      "section_title": true,
      "ja": "2.6.6.1。どこに参加/プルーンのメッセージを送信すること"
    },
    {
      "indent": 3,
      "text": "The following rules apply to both (1) forwarded (in the case of PIM relay) and (2) refreshed and triggered (in the case of PIM proxying) (S,G) / (*,G) Join/Prune messages.",
      "ja": "/プルーンメッセージを参加（G、*）/（S、G）の規則（1）（PIMリレーの場合）転送され、（2）リフレッシュし（PIMのプロキシの場合）トリガの両方に適用される以下。"
    },
    {
      "indent": 3,
      "text": "o The Upstream Neighbor field in the Join/Prune to be sent is set to the N in the corresponding Upstream FSM.",
      "ja": "O参加/プルーンにおける上流隣接フィールドは、対応するアップストリームFSMにNに設定されて送信されます。"
    },
    {
      "indent": 3,
      "text": "o If Port(N) is an AC, send the message to Port(N).",
      "ja": "Oポート（N）がACである場合には、ポート（N）にメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "o Additionally, if OutgoingPortList(x,G,N) contains at least one AC, then the message MUST be sent to at least all the PWs in UpstreamPorts(G) (for (*,G)) or InheritedUpstreamPorts(S,G) (for (S,G)). Alternatively, the message MAY be sent to all PWs.",
      "ja": "OutgoingPortList（X、G、N）は、少なくとも1つのAC、次いで、メッセージは（）*、G（ため）UpstreamPortsに少なくとも全てのPW（G）に送信しなければならないか、またはInheritedUpstreamPorts（S、G）が含まれている場合、さらに、O （（S、G）のために）。また、メッセージはすべてのPWに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "Sending to a subset of PWs as described above guarantees that if traffic (of the same flow) from two upstream routers were to reach this PE, then the two routers will receive from each other, triggering an Assert.",
      "ja": "保証上記のように2つのアップストリームルータから（同じ流量の）トラフィックが、このPEに到達した場合、2つのルータがアサートをトリガー、互いから受け取ることのPWのサブセットに送信します。"
    },
    {
      "indent": 3,
      "text": "Sending to all PWs guarantees that if two upstream routers both send traffic for the same flow (even if it is to different sets of downstream PEs), then the two routers will receive from each other, triggering an Assert.",
      "ja": "全てのPWへの送信は、2つのアップストリームルータが同じフロー（それは下流のPEの異なるセットにある場合でも）のためにトラフィックを送信し、両方の場合、2つのルータがアサートをトリガー、互いから受け取ることを保証します。"
    },
    {
      "indent": 0,
      "text": "2.7. Bidirectional PIM (BIDIR-PIM)",
      "section_title": true,
      "ja": "2.7。双方向PIM（BIDIR-PIM）"
    },
    {
      "indent": 3,
      "text": "Bidirectional PIM (BIDIR-PIM) is a variation of PIM-SM. The main differences between PIM-SM and BIDIR-PIM are as follows:",
      "ja": "双方向PIM（BIDIR-PIM）は、PIM-SMの変形例です。次のようにPIM-SMとBIDIR-PIMとの主な違いは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o There are no source-based trees, and SSM is not supported (i.e., no (S,G) states) in BIDIR-PIM.",
      "ja": "Oそこにはソースベースのツリーではない、とSSMはBIDIR-PIMに（即ち、なし（S、G）ステートを）サポートされていません。"
    },
    {
      "indent": 3,
      "text": "o Multicast traffic can flow up the shared tree in BIDIR-PIM.",
      "ja": "OマルチキャストトラフィックはBIDIR-PIMで共有ツリーを流すことができます。"
    },
    {
      "indent": 3,
      "text": "o To avoid forwarding loops, one router on each link is elected as the Designated Forwarder (DF) for each RP in BIDIR-PIM.",
      "ja": "転送ループを回避するために、Oは、各リンク上のルータはBIDIR-PIM内の各RP用に指定フォワーダ（DF）として選出されます。"
    },
    {
      "indent": 3,
      "text": "The main advantage of BIDIR-PIM is that it scales well for many-to-many applications. However, the lack of source-based trees means that multicast traffic is forced to remain on the shared tree.",
      "ja": "BIDIR-PIMの主な利点は、多対多のアプリケーションにもスケールするということです。しかし、ソースベースの木の欠如は、マルチキャストトラフィックを共有ツリーの上に残ることを余儀なくされていることを意味します。"
    },
    {
      "indent": 3,
      "text": "As described in RFC 5015 [BIDIR-PIM], parts of a BIDIR-PIM-enabled network may forward traffic without exchanging Join/Prune messages -- for instance, between DFs and the Rendezvous Point Link (RPL).",
      "ja": "例えば、DFSおよびランデブーポイントリンク（RPL）の間 -  RFC 5015 [BIDIR-PIM]に記載されているように、BIDIR-PIM対応ネットワークの部分は/参加プルーンメッセージを交換することなく、トラフィックを転送することができます。"
    },
    {
      "indent": 3,
      "text": "As the described procedures for PIM snooping rely on the presence of Join/Prune messages, enabling PIM snooping on BIDIR-PIM networks could break the BIDIR-PIM functionality. Deploying PIM snooping on BIDIR-PIM-enabled networks will require some further study. Some thoughts on this topic are discussed in Appendix A.",
      "ja": "PIMスヌーピングについて説明した手順のようBIDIR-PIM機能を破ることができBIDIR-PIMネットワーク上でPIMスヌーピングを有効にする、参加/プルーンのメッセージの存在に依存しています。 BIDIR-PIM対応ネットワーク上のPIMスヌーピングを展開すると、いくつかのさらなる研究が必要になります。このトピックに関するいくつかの考えは、付録Aで説明されています"
    },
    {
      "indent": 0,
      "text": "2.8. Interaction with IGMP Snooping",
      "section_title": true,
      "ja": "2.8。 IGMPスヌーピングとの相互作用"
    },
    {
      "indent": 3,
      "text": "Whenever IGMP snooping is enabled in conjunction with PIM snooping in the same VPLS instance, the PE SHOULD follow these rules:",
      "ja": "IGMPスヌーピングが同じVPLSインスタンスにスヌーピングPIMと組み合わせて有効になっているときはいつでも、PEは、これらの規則に従ってください："
    },
    {
      "indent": 3,
      "text": "o To maintain the list of multicast routers and ports on which they are attached, the PE SHOULD NOT use the rules described in RFC 4541 [IGMP-SNOOP] but SHOULD rely on the neighbors discovered by PIM snooping. This list SHOULD then be used to apply the first forwarding rule (rule 1) listed in Section 2.1.1 of RFC 4541 [IGMP-SNOOP].",
      "ja": "oは、それらが結合されているマルチキャストルータおよびポートのリストを維持するために、PEは、RFC 4541 [IGMPスヌープ]に記載のルールを使用するべきではなく、PIMスヌーピングによって検出されたネイバーに依存しているべきです。このリストは、その後、RFC 4541 [IGMPスヌープ]のセクション2.1.1に記載されている最初の転送ルール（ルール1）を適用するために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "o If the PE supports proxy reporting, an IGMP membership learned only on a port to which a PIM neighbor is attached (i.e., not learned elsewhere) SHOULD NOT be included in the summarized upstream report sent to that port.",
      "ja": "PEは、プロキシレポートをサポートしている場合は、O、IGMPメンバーシップ（すなわち、他の場所で学習していない）がPIMネイバーが接続されているポート上でのみ学んだそのポートに送らまとめ上流の報告書に含めるべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.9. PIM-DM",
      "section_title": true,
      "ja": "2.9。 PIM-DM"
    },
    {
      "indent": 3,
      "text": "The key characteristic of PIM-DM is flood-and-prune behavior. Shortest-path trees are built as a multicast source starts transmitting.",
      "ja": "PIM-DMの主要な特徴は、洪水と-プルーンの動作です。マルチキャストソースが送信を開始するように最短パス木が構築されます。"
    },
    {
      "indent": 0,
      "text": "2.9.1. Building PIM-DM States",
      "section_title": true,
      "ja": "2.9.1。ビルPIM-DMの状態"
    },
    {
      "indent": 3,
      "text": "PIM-DM states are built by snooping on the PIM-DM Join, Prune, Graft, and State Refresh messages received on ACs/PWs and State Refresh messages sent on ACs/PWs. By snooping on these PIM-DM messages, a PE builds the following states per (S,G,N) where S is the address of the multicast source, G is the group address, and N is the upstream neighbor to which Prunes/Grafts are sent by downstream CEs:",
      "ja": "PIM-DMの状態が参加PIM-DMにスヌーピングによって構築され、プルーン、グラフト、およびステートリフレッシュメッセージは、ACS / PWの上で送信されるのAC / PWをし、ステートリフレッシュメッセージで受信しました。これらのPIM-DMメッセージスヌーピングによって、PE Sはマルチキャスト送信元のアドレスである（S、G、N）ごとに次の状態を構築し、Gはグループアドレスであり、Nは、プルーン/グラフトの上流隣接あります下流のCEによって送信されます。"
    },
    {
      "indent": 3,
      "text": "Per PIM(S,G,N):",
      "ja": "DRINKあたり（C、H、N）："
    },
    {
      "indent": 6,
      "text": "Port PIM(S,G,N) Prune State:",
      "ja": "ポートPIM（S、G、N）プルーン状態："
    },
    {
      "indent": 6,
      "text": "* DownstreamPState(S,G,N,Port): One of {\"NoInfo\" (NI), \"Pruned\" (P), \"Prune-Pending\" (PP)}",
      "ja": "* DownstreamPState（S、G、N、ポート）の一つ{ \"NoInfo\"（NI）、 \"プルーニング\"（P）、 \"プルーン・保留\"（PP）}"
    },
    {
      "indent": 6,
      "text": "* Prune-Pending Timer (PPT)",
      "ja": "*プルーン-保留タイマー（PPT）"
    },
    {
      "indent": 6,
      "text": "* Prune Timer (PT)",
      "ja": "*プルーンタイマー（PT）"
    },
    {
      "indent": 6,
      "text": "* Upstream Port (valid if the PIM(S,G,N) Prune state is \"Pruned\")",
      "ja": "*アップストリームポート（有効なPIM（S、G、N）プルーン状態は \"剪定\" されている場合）"
    },
    {
      "indent": 0,
      "text": "2.9.2. PIM-DM Downstream Per-Port PIM(S,G,N) State Machine",
      "section_title": true,
      "ja": "2.9.2。 PIM-DMダウンストリームポート単位のPIM（S、G、N）ステートマシン"
    },
    {
      "indent": 3,
      "text": "The downstream per-port PIM(S,G,N) state machine is as defined in Section 4.4.2 of RFC 3973 [PIM-DM], with a few changes relevant to PIM snooping. When reading Section 4.4.2 of RFC 3973 [PIM-DM], please be aware that, for the purposes of PIM snooping, the downstream states are built per (S,G,N,Downstream-Port) in PIM snooping and not per (Downstream-Interface,S,G) as in a PIM-DM router. As noted in Section 2.9.1, the states (DownstreamPState) and timers (PPT and PT) are per (S,G,N,Port).",
      "ja": "PIMスヌーピングに関連するいくつかの変更と、RFC 3973 [PIM-DM]のセクション4.4.2で定義されるように、下流ポートごとのPIM（S、G、N）状態機械です。 RFC 3973 [PIM-DM]の4.4.2項を読んだときは、PIMスヌーピングの目的のために、下流の状態があたりPIMスヌーピングではなく（S、G、N、ダウンストリームポート）ごとに構築されている、ということに注意してください。 PIM-DMルータのように（下流-インタフェース、S、G）。セクション2.9.1で述べたように、状態（DownstreamPState）及びタイマ（PPT及びPT）が（S、G、N、ポート）ごとです。"
    },
    {
      "indent": 0,
      "text": "2.9.3. Triggering Assert Election in PIM-DM",
      "section_title": true,
      "ja": "2.9.3。 PIM-DMでアサート選挙のトリガ"
    },
    {
      "indent": 3,
      "text": "Since PIM-DM is a flood-and-prune protocol, traffic is flooded to all routers unless explicitly pruned. Since PIM-DM routers do not prune on non-RPF interfaces, PEs should typically not receive Prunes on Port(RPF-Neighbor). So, the asserting routers should typically be in pim_oiflist(S,G). In most cases, Assert election should occur naturally without any special handling, since data traffic will be forwarded to the asserting routers.",
      "ja": "PIM-DMは、洪水と-プルーンのプロトコルであるので、明示的に剪定されていない限り、トラフィックはすべてのルータにフラッディングされます。 PIM-DMルータは非RPFインターフェイス上で整理しませんので、PEは通常、ポート（RPF-ネイバー）にプルーンを受けるべきではありません。だから、主張するルータは、一般的に（S、G）pim_oiflistにする必要があります。ほとんどの場合、データトラフィックがアサートルータに転送されるので、任意の特別な処理せずに自然に起こるべき選挙をアサートします。"
    },
    {
      "indent": 3,
      "text": "However, there are some scenarios where a Prune might be received on a port that is also an upstream port. If we prune the port from pim_oiflist(S,G), then it would not be possible for the asserting routers to determine if traffic arrived on their downstream port. This can be fixed by adding pim_iifs(S,G) to pim_oiflist(S,G) so that data traffic flows to the upstream ports.",
      "ja": "しかし、プルーンもアップストリームポートであるポートで受信される可能性がありますいくつかのシナリオがあります。我々はpim_oiflist（S、G）からポートを剪定した場合、トラフィックが自分のダウンストリームポートに到着した場合にアサートルータが決定するために、それは可能ではないでしょう。これは、データトラフィックがアップストリームポートに流れるように（S、G）をpim_oiflistするpim_iifs（S、G）を添加することにより固定することができます。"
    },
    {
      "indent": 0,
      "text": "2.10. PIM Proxy",
      "section_title": true,
      "ja": "2.10。ピム領事"
    },
    {
      "indent": 3,
      "text": "As noted earlier, PIM snooping will work correctly only if Join suppression is disabled in the VPLS. If Join suppression is enabled in the VPLS, then PEs MUST do PIM relay/proxying for VPLS multicast to work correctly. This section applies specifically to full proxying and not to relay.",
      "ja": "先に述べたように、PIMスヌーピングが参加抑制がVPLSで無効になっている場合にのみ正しく動作します。参加抑制がVPLSで有効になっている場合には、PEが正しく機能するVPLSマルチキャスト用のPIMリレー/プロキシを行う必要があります。このセクションでは、フルプロキシに特異的に適用され、中継することはありません。"
    },
    {
      "indent": 0,
      "text": "2.10.1. Upstream PIM Proxy Behavior",
      "section_title": true,
      "ja": "2.10.1。上流PIMプロキシ動作"
    },
    {
      "indent": 3,
      "text": "A PIM proxying PE consumes Join/Prune messages and regenerates PIM Join/Prune messages to be sent upstream by implementing the Upstream FSM as specified in Section 4.5.4 of RFC 7761 [PIM-SM]. This is the only difference from PIM relay.",
      "ja": "PIMのプロキシPEは/プルーンJoinメッセージを消費し、RFC 7761 [PIM-SM]のセクション4.5.4で指定されるようにPIMは/上流FSMを実装することにより、上流送信するプルーンJoinメッセージを再生します。これは、PIMリレーとの唯一の違いです。"
    },
    {
      "indent": 3,
      "text": "The source IP address in PIM packets sent upstream SHOULD be the address of a PIM downstream neighbor in the corresponding Join/Prune state. The chosen address MUST NOT be the Upstream Neighbor field to be encoded in the packet. The Layer 2 encapsulation for the selected source IP address MUST be the encapsulation recorded in the PIM Neighbor Database for that IP address.",
      "ja": "アップストリーム送信されたPIMパケット内のソースIPアドレスは、対応する参加/プルーン状態でPIM下流ネイバーのアドレスでなければなりません。選択したアドレスはパケットに符号化する上流隣接フィールドにすることはできません。選択された送信元IPアドレスのレイヤ2カプセル化は、そのIPアドレスのPIMネイバーデータベースに記録されているカプセル化でなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.11. Directly Connected Multicast Source",
      "section_title": true,
      "ja": "2.11。直接接続されているマルチキャストソース"
    },
    {
      "indent": 3,
      "text": "PIM snooping/relay/proxying could be enabled on a LAN that connects a multicast source and a PIM First-Hop Router (FHR). As the FHR will not send any downstream Join/Prune messages, we will not be able to establish any forwarding states for that source. Therefore, if there is a source in the CE network that connects directly into the VPLS instance, then multicast traffic from that source MUST be sent to all PIM routers on the VPLS instance in addition to the IGMP receivers in the VPLS. If there is already (S,G) or (*,G) snooping state that is formed on any PE, this will not happen per the current forwarding rules and guidelines. So, in order to determine if traffic needs to be flooded to all routers, a PE must be able to determine if the traffic came from a host on that LAN. There are three ways to address this problem:",
      "ja": "PIMスヌーピング/リレー/プロキシは、マルチキャストソースとPIMファーストホップルータ（FHR）を接続しているLAN上で有効にすることができます。 FHRは/プルーンのメッセージを参加任意の下流を送信しないように、私たちはそのソースのいずれかの転送状態を確立することができません。 VPLSインスタンスに直接接続CEネットワーク内のソースがある場合、したがって、そのソースからのマルチキャストトラフィックは、VPLS内のIGMP受信機に加えて、VPLSインスタンス上のすべてのPIMルータに送信されなければなりません。任意のPE上に形成されている（S、G）または（*、G）スヌーピング状態が既に存在する場合、これは現在の転送ルールおよびガイドラインごとに起こることはありません。トラフィックは、そのLAN上のホストから来たのであれば、トラフィックはすべてのルータにフラッディングする必要があるかどうかを決定するために、PEは決定できなければなりません。この問題に対処する3つの方法があります。"
    },
    {
      "indent": 3,
      "text": "o The PE would have to do IPv4 ARP snooping and/or IPv6 Neighbor Discovery snooping to determine if a source is directly connected.",
      "ja": "O PEは、IPv4のARPスヌーピングおよび/またはIPv6近隣探索は、ソースが直接接続されているかどうかを決定するためにスヌーピングしなければならないであろう。"
    },
    {
      "indent": 3,
      "text": "o Another option is to configure all PEs to indicate that there are CE sources that are directly connected to the VPLS instance and disallow snooping for the groups for which the source is going to send traffic. This way, traffic from that source to those groups will always be flooded within the provider network.",
      "ja": "O別のオプションは直接VPLSインスタンスに接続し、ソースがトラフィックを送信しようとしているためにグループのためにスヌーピング禁止されているCEソースがあることを示すために、すべてのPEを構成することです。このように、それらのグループにそのソースからのトラフィックは常に、プロバイダのネットワーク内でフラッディングされます。"
    },
    {
      "indent": 3,
      "text": "o A third option is to require that sources of CE multicast traffic must be behind a router.",
      "ja": "O第三の選択肢は、CEのマルチキャストトラフィックのソースはルータの背後でなければならないことを要求することです。"
    },
    {
      "indent": 3,
      "text": "This document recommends the third option -- sources of traffic must be behind a router.",
      "ja": "この文書では、第三のオプションをお勧めします - トラフィックのソースはルータの背後に配置する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.12. Data-Forwarding Rules",
      "section_title": true,
      "ja": "2.12。データフォワーディングルール"
    },
    {
      "indent": 3,
      "text": "First, we define the rules that are common to PIM-SM and PIM-DM PEs. Forwarding rules for each protocol type are specified in the subsections below.",
      "ja": "まず、我々は、PIM-SMとPIM-DMのPEに共通なルールを定義します。各プロトコルタイプの転送ルールは、以下のサブセクションで指定されています。"
    },
    {
      "indent": 3,
      "text": "If there is no matching forwarding state, then the PE SHOULD discard the packet, i.e., the UserDefinedPortList (Sections 2.12.1 and 2.12.2) SHOULD be empty.",
      "ja": "該当転送状態がない場合、PE、すなわち、UserDefinedPortList（セクション2.12.1および2.12.2）が空になり、パケットを破棄すべきです。"
    },
    {
      "indent": 3,
      "text": "The following general rules MUST be followed when forwarding multicast traffic in a VPLS:",
      "ja": "VPLSにマルチキャストトラフィックを転送するときは、次の一般的な規則に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o Traffic arriving on a port MUST NOT be forwarded back onto the same port.",
      "ja": "Oポートに着信したトラフィックは、同じポート上にバック転送されてはなりません。"
    },
    {
      "indent": 3,
      "text": "o Due to VPLS split-horizon rules, traffic ingressing on a PW MUST NOT be forwarded to any other PW.",
      "ja": "O VPLSスプリットホライズンのルールのため、PW上のトラフィックの着信するには、他のどのPWに転送してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.12.1. PIM-SM Data-Forwarding Rules",
      "section_title": true,
      "ja": "2.12.1。 PIM-SMのデータフォワーディングルール"
    },
    {
      "indent": 3,
      "text": "Per the rules in RFC 7761 [PIM-SM] and per the additional rules specified in this document,",
      "ja": "RFC 7761の規則ごとの[PIM-SM]この文書で指定された追加ルールごとに、"
    },
    {
      "indent": 3,
      "text": "OutgoingPortList(*,G) = immediate_olist(*,G) (+) UpstreamPorts(*,G) (+) Port(PimDR)",
      "ja": "OutgoingPortList（*、G）= immediate_olist（*、G）（+）UpstreamPorts（*、G）（+）ポート（PimDR）"
    },
    {
      "indent": 3,
      "text": "OutgoingPortList(S,G) = inherited_olist(S,G) (+) UpstreamPorts(S,G) (+) (UpstreamPorts(*,G) (-) UpstreamPorts(S,G,rpt)) (+) Port(PimDR)",
      "ja": "OutgoingPortList（S、G）=引き継いでいる_olist（S、G）（+）UpstreamPorts（S、G）（+）（UpstreamPorts（*、G）（ - ）UpstreamPorts（S、G、RPT））（+）ポート（PimDR ）"
    },
    {
      "indent": 3,
      "text": "RFC 7761 [PIM-SM] specifies how immediate_olist(*,G) and inherited_olist(S,G) are built. PimDR is the IP address of the PIM DR in the VPLS.",
      "ja": "RFC 7761 [PIM-SM]はimmediate_olist（*、G）と引き継いでいる_olist（S、G）が構築される方法を指定します。 PimDRは、VPLSにおけるPIM DRのIPアドレスです。"
    },
    {
      "indent": 3,
      "text": "The PIM-SM snooping data-forwarding rules are defined below in pseudocode:",
      "ja": "PIM-SMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。"
    },
    {
      "indent": 3,
      "text": "BEGIN iif is the incoming port of the multicast packet. S is the source IP address of the multicast packet. G is the destination IP address of the multicast packet.",
      "ja": "マルチキャストパケットの着信ポートであるIIF BEGIN。 Sは、マルチキャストパケットの送信元IPアドレスです。 Gは、マルチキャストパケットの宛先IPアドレスです。"
    },
    {
      "indent": 7,
      "text": "If there is (S,G) state on the PE\nThen\n    OutgoingPortList = OutgoingPortList(S,G)\nElse if there is (*,G) state on the PE\nThen\n    OutgoingPortList = OutgoingPortList(*,G)\nElse\n    OutgoingPortList = UserDefinedPortList\nEndif",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif",
      "ja": "IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF"
    },
    {
      "indent": 3,
      "text": " Forward the packet to OutgoingPortList. END",
      "ja": "OutgoingPortListにパケットを転送します。終わり"
    },
    {
      "indent": 3,
      "text": "First, if there is (S,G) state on the PE, then the set of outgoing ports is OutgoingPortList(S,G).",
      "ja": "PE上の（S、G）状態が存在する場合、最初に、次に送信ポートのセットがOutgoingPortList（S、G）です。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if there is (*,G) state on the PE, then the set of outgoing ports is OutgoingPortList(*,G).",
      "ja": "PE上の（*、G）状態がある場合にそうでない場合、次に送信ポートのセットがOutgoingPortList（*、G）です。"
    },
    {
      "indent": 3,
      "text": "The packet is forwarded to the selected set of outgoing ports while observing the general rules above in Section 2.12.",
      "ja": "セクション2.12で上記の一般的なルールを観察しながら、パケットが発信ポートの選択されたセットに転送されます。"
    },
    {
      "indent": 0,
      "text": "2.12.2. PIM-DM Data-Forwarding Rules",
      "section_title": true,
      "ja": "2.12.2。 PIM-DMデータフォワーディングルール"
    },
    {
      "indent": 3,
      "text": "The PIM-DM snooping data-forwarding rules are defined below in pseudocode:",
      "ja": "PIM-DMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。"
    },
    {
      "indent": 3,
      "text": "BEGIN iif is the incoming port of the multicast packet. S is the source IP address of the multicast packet. G is the destination IP address of the multicast packet.",
      "ja": "マルチキャストパケットの着信ポートであるIIF BEGIN。 Sは、マルチキャストパケットの送信元IPアドレスです。 Gは、マルチキャストパケットの宛先IPアドレスです。"
    },
    {
      "indent": 7,
      "text": "If there is (S,G) state on the PE\nThen\n    OutgoingPortList = olist(S,G)\nElse\n    OutgoingPortList = UserDefinedPortList\nEndif",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif",
      "ja": "IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF"
    },
    {
      "indent": 3,
      "text": " Forward the packet to OutgoingPortList. END",
      "ja": "OutgoingPortListにパケットを転送します。終わり"
    },
    {
      "indent": 3,
      "text": "If there is forwarding state for (S,G), then forward the packet to olist(S,G) while observing the general rules above in Section 2.12.",
      "ja": "転送状態が（S、G）のためにそこにある場合、セクション2.12で上記の一般的なルールを観察しながら、次いでOLIST（S、G）にパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "RFC 3973 [PIM-DM] specifies how olist(S,G) is constructed.",
      "ja": "RFC 3973は、[PIM-DM] OLIST（S、G）が構築される方法を指定します。"
    },
    {
      "indent": 0,
      "text": "3. IANA Considerations",
      "section_title": true,
      "ja": "3. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Security considerations provided in the VPLS solution documents (i.e., RFC 4762 [VPLS-LDP] and RFC 4761 [VPLS-BGP]) apply to this document as well.",
      "ja": "VPLS溶液文書で提供されるセキュリティ上の考慮事項（すなわち、RFC 4762 [VPLS-LDP]およびRFC 4761 [VPLS-BGP]）は、同様に、この文書に適用されます。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5.参考文献"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[BIDIR-PIM] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, \"Bidirectional Protocol Independent Multicast (BIDIR-PIM)\", RFC 5015, DOI 10.17487/RFC5015, October 2007, <https://www.rfc-editor.org/info/rfc5015>.",
      "ja": "[BIDIR-PIM]ハンドレー、M.、Kouvelas、I.、スピークマン、T.、およびL. Vicisano、 \"双方向プロトコル独立マルチキャスト（BIDIR-PIM）\"、RFC 5015、DOI 10.17487 / RFC5015、2007年10月<HTTPS ：//www.rfc-editor.org/info/rfc5015>。"
    },
    {
      "indent": 3,
      "text": "[JOIN-ATTR] Boers, A., Wijnands, I., and E. Rosen, \"The Protocol Independent Multicast (PIM) Join Attribute Format\", RFC 5384, DOI 10.17487/RFC5384, November 2008, <https://www.rfc-editor.org/info/rfc5384>.",
      "ja": "[登録しよ-ATTR]ボーア人、A.、Wijnands、I.、およびE.ローゼンし、 \"プロトコル独立マルチキャスト（PIM）属性フォーマットへの参加\"、RFC 5384、DOI 10.17487 / RFC5384、2008年11月、<https：//でWWW .rfc-editor.org /情報/ rfc5384>。"
    },
    {
      "indent": 3,
      "text": "[PIM-DM] Adams, A., Nicholas, J., and W. Siadak, \"Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)\", RFC 3973, DOI 10.17487/RFC3973, January 2005, <https://www.rfc-editor.org/info/rfc3973>.",
      "ja": "[PIM-DM]アダムス、A.、ニコラス、J.、およびW. Siadak、 \"プロトコル独立マルチキャスト - 稠密モード（PIM-DM）：プロトコル仕様（改訂）\"、RFC 3973、DOI 10.17487 / RFC3973、2005年1月、<https://www.rfc-editor.org/info/rfc3973>。"
    },
    {
      "indent": 3,
      "text": "[PIM-SM] Fenner, B., Handley, M., Holbrook, H., Kouvelas, I., Parekh, R., Zhang, Z., and L. Zheng, \"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)\", STD 83, RFC 7761, DOI 10.17487/RFC7761, March 2016, <https://www.rfc-editor.org/info/rfc7761>.",
      "ja": "[PIM-SM]フェナー、B.、ハンドレー、M.、ホルブルック、H.、Kouvelas、I.、Parekhの、R.、張、Z.、およびL.鄭、「プロトコル独立マルチキャスト - スパースモード（PIM- SM）：プロトコル仕様（改訂）」、STD 83、RFC 7761、DOI 10.17487 / RFC7761、2016年3月、<https://www.rfc-editor.org/info/rfc7761>。"
    },
    {
      "indent": 3,
      "text": "[PIM-SSM] Holbrook, H. and B. Cain, \"Source-Specific Multicast for IP\", RFC 4607, DOI 10.17487/RFC4607, August 2006, <https://www.rfc-editor.org/info/rfc4607>.",
      "ja": "[PIM-SSM]ホルブルック、H.、およびB.カイン、 \"IPのためのソース固有のマルチキャスト\"、RFC 4607、DOI 10.17487 / RFC4607、2006年8月、<https://www.rfc-editor.org/info/rfc4607 >。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RPF-VECTOR] Wijnands, IJ., Boers, A., and E. Rosen, \"The Reverse Path Forwarding (RPF) Vector TLV\", RFC 5496, DOI 10.17487/RFC5496, March 2009, <https://www.rfc-editor.org/info/rfc5496>.",
      "ja": "[RPF-VECTOR] Wijnands、IJ、ボーア人、A.、およびE.ローゼン、 \"リバースパス転送（RPF）のベクトルTLV\"、RFC 5496、DOI 10.17487 / RFC5496、2009年3月、<HTTPS：// WWW。 rfc-editor.org/info/rfc5496>。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[IGMP-SNOOP] Christensen, M., Kimball, K., and F. Solensky, \"Considerations for Internet Group Management Protocol (IGMP) and Multicast Listener Discovery (MLD) Snooping Switches\", RFC 4541, DOI 10.17487/RFC4541, May 2006, <https://www.rfc-editor.org/info/rfc4541>.",
      "ja": "[IGMP-SNOOP]クリステンセン、M.、キンボール、K.、およびF. Solensky、RFC 4541、DOI 10.17487 / RFC4541、月、 \"インターネットグループ管理プロトコル（IGMP）およびMulticast Listener Discovery（MLD）スヌーピングスイッチの考慮事項\" 2006年、<https://www.rfc-editor.org/info/rfc4541>。"
    },
    {
      "indent": 3,
      "text": "[VPLS-BGP] Kompella, K., Ed., and Y. Rekhter, Ed., \"Virtual Private LAN Service (VPLS) Using BGP for Auto-Discovery and Signaling\", RFC 4761, DOI 10.17487/RFC4761, January 2007, <https://www.rfc-editor.org/info/rfc4761>.",
      "ja": "[VPLS-BGP] Kompella、K.、エド。、およびY. Rekhter、エド。、 \"仮想プライベートLANサービス（VPLS）自動検出およびシグナリングのためにBGPを使用する\"、RFC 4761、DOI 10.17487 / RFC4761、2007年1月、 <https://www.rfc-editor.org/info/rfc4761>。"
    },
    {
      "indent": 3,
      "text": "[VPLS-LDP] Lasserre, M., Ed., and V. Kompella, Ed., \"Virtual Private LAN Service (VPLS) Using Label Distribution Protocol (LDP) Signaling\", RFC 4762, DOI 10.17487/RFC4762, January 2007, <https://www.rfc-editor.org/info/rfc4762>.",
      "ja": "[VPLS-LDP] Lasserre、M.、エド。、およびV. Kompella、エド。、RFC 4762、DOI 10.17487 / RFC4762、2007年1月、 \"仮想プライベートLANサービス（VPLS）はラベル配布プロトコル（LDP）シグナリングを使用します\" <https://www.rfc-editor.org/info/rfc4762>。"
    },
    {
      "indent": 3,
      "text": "[VPLS-MCAST] Aggarwal, R., Ed., Kamite, Y., Fang, L., Rekhter, Y., and C. Kodeboniya, \"Multicast in Virtual Private LAN Service (VPLS)\", RFC 7117, DOI 10.17487/RFC7117, February 2014, <https://www.rfc-editor.org/info/rfc7117>.",
      "ja": "[VPLS-MCAST]アガルワル、R.、エド。、Kamite、Y.、牙、L.、Rekhter、Y.、およびC. Kodeboniya、 \"仮想プライベートLANサービス（VPLS）でマルチキャスト\"、RFC 7117、DOI 10.17487 / RFC7117、2014年2月、<https://www.rfc-editor.org/info/rfc7117>。"
    },
    {
      "indent": 3,
      "text": "[VPLS-MCAST-REQ] Kamite, Y., Ed., Wada, Y., Serbest, Y., Morin, T., and L. Fang, \"Requirements for Multicast Support in Virtual Private LAN Services\", RFC 5501, DOI 10.17487/RFC5501, March 2009, <https://www.rfc-editor.org/info/rfc5501>.",
      "ja": "[VPLS-MCAST-REQ] Kamite、Y.、エド。、和田、Y.、Serbest、Y.、モリン、T.、およびL.牙、 \"仮想プライベートLANサービスにおけるマルチキャストサポートのための要件\"、RFC 5501、 DOI 10.17487 / RFC5501、2009年3月、<https://www.rfc-editor.org/info/rfc5501>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. BIDIR-PIM Considerations",
      "ja": "付録A. BIDIR-PIMの考慮事項"
    },
    {
      "indent": 3,
      "text": "This appendix describes some guidelines that may be used to preserve BIDIR-PIM functionality in combination with PIM snooping.",
      "ja": "この付録では、PIMスヌーピングとの組み合わせでBIDIR-PIM機能を維持するために使用できるいくつかのガイドラインを説明します。"
    },
    {
      "indent": 3,
      "text": "In order to preserve BIDIR-PIM snooping, routers need to set up forwarding states so that:",
      "ja": "BIDIR-PIMスヌーピングを維持するために、ルータはそのよう転送状態を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o on the RPL, all traffic is forwarded to all Port(N) ports.",
      "ja": "O RPLに、すべてのトラフィックはすべてのポート（N）ポートに転送されます。"
    },
    {
      "indent": 3,
      "text": "o on any other interface, traffic is always forwarded to the DF.",
      "ja": "O他のインターフェイス上で、トラフィックは常にDFに転送されます。"
    },
    {
      "indent": 3,
      "text": "The information needed to set up these states may be obtained by:",
      "ja": "これらの状態を設定するために必要な情報をすることによって得ることができます。"
    },
    {
      "indent": 3,
      "text": "o determining the mapping between the group (range) and the RP.",
      "ja": "グループ（範囲）とRPとの間のマッピングを決定O。"
    },
    {
      "indent": 3,
      "text": "o snooping and storing DF election information.",
      "ja": "OスヌーピングとDFの選挙情報を格納します。"
    },
    {
      "indent": 3,
      "text": "o determining where the RPL is. This could be achieved by static configuration or by combining the information mentioned in the two bullet items above.",
      "ja": "RPLがどこにあるかを決定O。これは、静的な構成によって、または上記の二つの箇条書き項目に記載された情報を組み合わせることによって達成することができます。"
    },
    {
      "indent": 0,
      "text": "A.1. BIDIR-PIM Data-Forwarding Rules",
      "ja": "A.1。 BIDIR-PIMデータフォワーディングルール"
    },
    {
      "indent": 3,
      "text": "The BIDIR-PIM snooping data-forwarding rules are defined below in pseudocode:",
      "ja": "BIDIR-PIMスヌーピングデータ転送ルールは、擬似コードで以下に定義されています。"
    },
    {
      "indent": 3,
      "text": "BEGIN iif is the incoming port of the multicast packet. G is the destination IP address of the multicast packet.",
      "ja": "マルチキャストパケットの着信ポートであるIIF BEGIN。 Gは、マルチキャストパケットの宛先IPアドレスです。"
    },
    {
      "indent": 7,
      "text": "If there is forwarding state for G\nThen\n    OutgoingPortList = olist(G)\nElse\n    OutgoingPortList = UserDefinedPortList\nEndif",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If iif is an AC Then OutgoingPortList = OutgoingPortList (-) iif Else ## iif is a PW OutgoingPortList = OutgoingPortList (-) PWPorts Endif",
      "ja": "IIFはACである場合、OutgoingPortList = OutgoingPortList（ - ）IIFエルス## IIFあるPW OutgoingPortList = OutgoingPortList（ - ）PWPorts ENDIF"
    },
    {
      "indent": 3,
      "text": " Forward the packet to OutgoingPortList. END",
      "ja": "OutgoingPortListにパケットを転送します。終わり"
    },
    {
      "indent": 3,
      "text": "If there is forwarding state for G, then forward the packet to olist(G) while observing the general rules above in Section 2.12.",
      "ja": "転送状態がGのためにそこにある場合、セクション2.12で上記の一般的なルールを観察しながら、次いでOLIST（G）にパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "RFC 5015 [BIDIR-PIM] specifies how olist(G) is constructed.",
      "ja": "RFC 5015 [BIDIR-PIM]はOLIST（G）が構築される方法を指定します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example Network Scenario",
      "ja": "付録B.例ネットワークのシナリオ"
    },
    {
      "indent": 3,
      "text": "Let us consider the scenario in Figure 3.",
      "ja": "私たちは、図3のシナリオを考えてみましょう。"
    },
    {
      "indent": 10,
      "text": "                                  +------+ AC3 +------+\n                                  |  PE2 |-----| CE3  |\n                                 /|      |     +------+\n                                / +------+         |\n                               /     |             |\n                              /      |             |\n                             /PW12   |             |\n                            /        |           /---\\\n                           /         |PW23       | S |\n                          /          |           \\---/\n                         /           |             |\n                        /            |             |\n                       /             |             |\n             +------+ /           +------+         |\n+------+     |  PE1 |/   PW13     |  PE3 |     +------+\n| CE1  |-----|      |-------------|      |-----| CE4  |\n+------+ AC1 +------+             +------+ AC4 +------+\n                 |\n                 |AC2\n             +------+\n             | CE2  |\n             +------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 3: An Example Network for Triggering an Assert",
      "ja": "図3：アサートをトリガするためのネットワークの例"
    },
    {
      "indent": 3,
      "text": "In the examples below, JT(Port,S,G,N) is the downstream Join Expiry Timer on the specified Port for the (S,G) with upstream neighbor N.",
      "ja": "以下の実施例では、JT（ポート、S、G、N）の下流にある上流の隣人Nとのために指定されたポート上の有効期限タイマー（S、G）に参加"
    },
    {
      "indent": 0,
      "text": "B.1. PIM Snooping Example",
      "ja": "B.1。 PIMスヌーピングの例"
    },
    {
      "indent": 3,
      "text": "In the network depicted in Figure 3, S is the source of a multicast stream (S,G). CE1 and CE2 both have two ECMP routes to reach the source.",
      "ja": "図3に示されているネットワークでは、Sはマルチキャストストリーム（S、G）の供給源です。 CE1とCE2の両方がソースに到達するために2つのECMPルートを持っています。"
    },
    {
      "indent": 3,
      "text": "1. CE1 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE3.",
      "section_title": true,
      "ja": "1. CE1はUpstreamNeighbors（S、G）= CE3との結合（S、G）を送信します。"
    },
    {
      "indent": 3,
      "text": "2. PE1 snoops on the Join(S,G) and builds forwarding state, since it is received on an AC. It also floods the Join(S,G) in the VPLS. PE2 snoops on the Join(S,G) and builds forwarding state, since the Join(S,G)is targeting a neighbor residing on an AC. PE3 does not create forwarding state for (S,G) because this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G). Both PE2 and PE3 will also flood the Join(S,G) in the VPLS.",
      "ja": "参加（S、G）にスヌープし、それがAC上で受信されているので、状態を転送構築PE1 2。また、VPLSに（S、G）に参加をフラッディングします。 PE2は、参加する（S、G）にスヌープ及び（S、G）ACに存在するネイバーをターゲットに参加するので、状態を転送構築します。これはPW-のみ参加しているとUpstreamPortsでAC（*、G）との既存の（*、G）状態でも、既存の（S、G）のいずれもがあるのでPE3は（S、G）のための転送状態を作成しませんUpstreamPortsにおけるAC（S、G）を有する状態。 PE2とPE3どちらもVPLSに（S、G）に参加をフラッディングします。"
    },
    {
      "indent": 7,
      "text": "The resulting states at the PEs are as follows:",
      "ja": "次のようにするPEの結果の状態は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC1,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12 }",
      "ja": "PE1の状態：JT（AC1、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= {AC1、PW12}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }",
      "ja": "PE2の状態：JT（PW12、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= {PW12、AC3}"
    },
    {
      "indent": 7,
      "text": "PE3 states: No (S,G) state",
      "ja": "PE3状態：いいえ（S、G）ステートを"
    },
    {
      "indent": 3,
      "text": "3. The multicast stream (S,G) flows along CE3 -> PE2 -> PE1 -> CE1.",
      "section_title": true,
      "ja": "3.マルチキャストストリーム（S、G）は、CE3に沿って流れる - > PE2  - > PE1  - > CE1。"
    },
    {
      "indent": 3,
      "text": "4. Now CE2 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE4.",
      "section_title": true,
      "ja": "4.今CE2はUpstreamNeighbors（S、G）と（S、G）に参加= CE4を送信します。"
    },
    {
      "indent": 3,
      "text": "5. All PEs snoop on the Join(S,G), build forwarding state, and flood the Join(S,G) in the VPLS. Note that for PE2, even though this is a PW-only Join, forwarding state is built on this Join(S,G), since PE2 has an existing (S,G) state with an AC in UpstreamPorts(S,G).",
      "ja": "参加（S、G）5.すべてのPEのスヌープは、フォワーディングステートを構築し、VPLSに（S、G）が参加洪水。 PE2はUpstreamPorts（S、G）におけるACで既存の（S、G）ステートを有しているので状態は、この参加（S、G）に基づいて構築されて転送、これは、PW-のみ参加しても、PE2のためのことに注意してください。"
    },
    {
      "indent": 7,
      "text": "The resulting states at the PEs are as follows:",
      "ja": "次のようにするPEの結果の状態は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC1,S,G,CE3) = active JT(AC2,S,G,CE4) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3, CE4 } UpstreamPorts(S,G) = { PW12, PW13 } OutgoingPortList(S,G) = { AC1, PW12, AC2, PW13 }",
      "ja": "PE1の状態：JT（AC1、S、G、CE3）=アクティブJT（AC2、S、G、CE4）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3、CE4} UpstreamPorts（S、G）= {PW12、PW13を} OutgoingPortList（S、G）= {AC1、PW12、AC2、PW13}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,S,G,CE4) = JP_HoldTime JT(PW12,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3, CE4 } UpstreamPorts(S,G) = { AC3, PW23 } OutgoingPortList(S,G) = { PW12, AC3, PW23 }",
      "ja": "PE2の状態：JT（PW12、S、G、CE4）= JP_HoldTime JT（PW12、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3、CE4} UpstreamPorts（S、G）= {AC3、PW23を} OutgoingPortList（S、G）= {PW12、AC3、PW23}"
    },
    {
      "indent": 7,
      "text": "PE3 states: JT(PW13,S,G,CE4) = JP_HoldTime UpstreamNeighbors(S,G) = { CE4 } UpstreamPorts(S,G) = { AC4 } OutgoingPortList(S,G) = { PW13, AC4 }",
      "ja": "PE3状態：JT（PW13、S、G、CE4）= JP_HoldTime UpstreamNeighbors（S、G）= {CE4} UpstreamPorts（S、G）= {AC4} OutgoingPortList（S、G）= {PW13、AC4}"
    },
    {
      "indent": 3,
      "text": "6. The multicast stream (S,G) flows into the VPLS from two of the CEs -- CE3 and CE4. PE2 forwards the stream received from CE3 to PW23, and PE3 forwards the stream to AC4. This helps the CE routers to trigger Assert election. Let us say that CE3 becomes the Assert winner.",
      "ja": "CE3及びCE4  -  6マルチキャストストリーム（S、G）は、CEの2からVPLSに流入します。 PE2は、PW23にCE3から受信したストリームを転送し、PE3はAC4にストリームを転送します。これは、アサート選挙をトリガするためにCEルータに役立ちます。私たちはCE3がアサート勝者になると言ってみましょう。"
    },
    {
      "indent": 3,
      "text": "7. CE3 sends an Assert message to the VPLS. The PEs flood the Assert message without examining it.",
      "ja": "7. CE3は、VPLSにアサートメッセージを送信します。 PEはそれを調べずにアサートメッセージをあふれさせます。"
    },
    {
      "indent": 3,
      "text": "8. CE4 stops sending the multicast stream to the VPLS.",
      "section_title": true,
      "ja": "8. CE4は、VPLSにマルチキャストストリームの送信を停止します。"
    },
    {
      "indent": 3,
      "text": "9. CE2 notices an RPF change due to the Assert and sends a Prune(S,G) with upstream neighbor = CE4. CE2 also sends a Join(S,G) with upstream neighbor = CE3.",
      "ja": "9. CE2起因アサートするRPF変更を通知し、上流隣接= CE4とプルーン（S、G）を送信します。 CE2はまた、上流隣接= CE3と（S、G）加入を送信します。"
    },
    {
      "indent": 3,
      "text": "10. All the PEs start a Prune-Pending timer on the ports on which they received the Prune(S,G). When the Prune-Pending timer expires, all PEs will remove the downstream (S,G,CE4) states.",
      "ja": "10.すべてのPEは、それらがプルーン（S、G）を受信したポートのプルーン・保留タイマーを起動します。プルーン、保留タイマーが満了すると、すべてのPEは、下流の（S、G、CE4）の状態を削除します。"
    },
    {
      "indent": 7,
      "text": "The resulting states at the PEs are as follows:",
      "ja": "次のようにするPEの結果の状態は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC1,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, AC2, PW12 }",
      "ja": "PE1の状態：JT（AC1、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= {AC1、AC2、PW12}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }",
      "ja": "PE2の状態：JT（PW12、S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= {PW12、AC3}"
    },
    {
      "indent": 7,
      "text": "PE3 states: JT(PW13,S,G,CE3) = JP_HoldTime UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW23 } OutgoingPortList(S,G) = { PW13, PW23 }",
      "ja": "PE3状態：JT（PW13、S、G、CE3）= JP_HoldTime UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW23} OutgoingPortList（S、G）= {PW13、PW23}"
    },
    {
      "indent": 7,
      "text": "Note that at this point at PE3, since there is no AC in OutgoingPortList(S,G) and no (*,G) or (S,G) state with an AC in UpstreamPorts(*,G) or UpstreamPorts(S,G), respectively, the existing (S,G) state at PE3 can also be removed. So, finally:",
      "ja": "OutgoingPortList（S、G）なし（*、G）または（S、G）UpstreamPortsにおけるACた状態（*、G）またはUpstreamPorts（S、GにはACが存在しないため、PE3におけるこの時点でなお）、それぞれ、PE3で既存の（S、G）状態も除去することができます。だから、最終的には："
    },
    {
      "indent": 7,
      "text": "PE3 states: No (S,G) state",
      "ja": "PE3状態：いいえ（S、G）ステートを"
    },
    {
      "indent": 3,
      "text": "Note that at the end of the Assert election, there should be no duplicate traffic forwarded downstream, and traffic should flow only on the desired path. Also note that there are no unnecessary (S,G) states on PE3 after the Assert election.",
      "ja": "アサート選挙の終わりに、下流に転送重複トラフィックがあってはならない、とトラフィックが所望の経路に流れのみ必要があることに注意してください。また、不要な（S、G）がアサート選挙後PE3に述べていないがあることに注意してください。"
    },
    {
      "indent": 0,
      "text": "B.2. PIM Proxy Example with (S,G) / (*,G) Interaction",
      "ja": "B.2。 （S、G）/（*、G）相互作用PIMプロキシ例"
    },
    {
      "indent": 3,
      "text": "In the same network, let us assume that CE4 is the upstream neighbor towards the RP for G.",
      "ja": "同ネットワークでは、私たちはCE4はG.のためのRPに向けた上流の隣人であると仮定しましょう"
    },
    {
      "indent": 3,
      "text": "JPST(S,G,N) is the JP sending timer for the (S,G) with upstream neighbor N.",
      "ja": "JPST（S、G、N）は、上流隣接N.と（S、G）のためのJP送信タイマーであります"
    },
    {
      "indent": 3,
      "text": "1. CE1 sends a Join(S,G) with UpstreamNeighbors(S,G) = CE3.",
      "section_title": true,
      "ja": "1. CE1はUpstreamNeighbors（S、G）= CE3との結合（S、G）を送信します。"
    },
    {
      "indent": 3,
      "text": "2. PE1 consumes the Join(S,G) and builds forwarding state, since the Join(S,G) is received on an AC.",
      "ja": "2. PE1は（S、G）に参加消費し、ACで受信された（S、G）に参加するので、状態を転送構築します。"
    },
    {
      "indent": 7,
      "text": "PE2 consumes the Join(S,G) and builds forwarding state, since the\nJoin(S,G) is targeting a neighbor residing on an AC.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "PE3 consumes the Join(S,G) but does not create forwarding state for (S,G), since this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G).",
      "ja": "PE3は参加（S、G）を消費が、これはPW-のみ参加しているとUpstreamPortsでACで既存の（*、G）状態（どちらも*があるので、（S、G）のための転送状態を作成しません、 G）もUpstreamPortsにおけるAC（S、G）と既存の（S、G）状態。"
    },
    {
      "indent": 7,
      "text": "The resulting states at the PEs are as follows:",
      "ja": "次のようにするPEの結果の状態は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC1,S,G,CE3) = JP_HoldTime JPST(S,G,CE3) = t_periodic UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12 }",
      "ja": "PE1の状態：JT（AC1、S、G、CE3）= JP_HoldTime JPST（S、G、CE3）はt_periodic UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）を= = {PW12} OutgoingPortList（S、G ）= {AC1、PW12}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,S,G,CE3) = JP_HoldTime JPST(S,G,CE3) = t_periodic UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3 }",
      "ja": "PE2の状態：JT（PW12、S、G、CE3）= JP_HoldTime JPST（S、G、CE3）はt_periodic UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）を= = {AC3} OutgoingPortList（S、G ）= {PW12、AC3}"
    },
    {
      "indent": 7,
      "text": "PE3 states: No (S,G) state",
      "ja": "PE3状態：いいえ（S、G）ステートを"
    },
    {
      "indent": 7,
      "text": "Joins are triggered as follows: PE1 triggers a Join(S,G) targeting CE3. Since the Join(S,G) was received on an AC and is targeting a neighbor that is residing across a PW, the triggered Join(S,G) is sent on all PWs.",
      "ja": "次のようにトリガーされるジョイン：PE1はCE3を標的とする（S、G）に参加トリガー。 AC上で受信された（S、G）に参加し、PWを横切って常駐さ隣人、トリガ参加（S、G）を標的としているので、全てのPW上で送信されます。"
    },
    {
      "indent": 7,
      "text": "PE2 triggers a Join(S,G) targeting CE3. Since the Join(S,G) is targeting a neighbor residing on an AC, it only sends the Join on AC3.",
      "ja": "PE2はCE3を標的とする（S、G）に参加をトリガします。参加（S、G）は、AC上にあるネイバーを標的としているので、それだけAC3に参加送ります。"
    },
    {
      "indent": 7,
      "text": "PE3 ignores the Join(S,G), since this is a PW-only Join and there is neither an existing (*,G) state with an AC in UpstreamPorts(*,G) nor an existing (S,G) state with an AC in UpstreamPorts(S,G).",
      "ja": "これは、PW-のみ参加してUpstreamPortsにおけるAC（*、G）と既存の（*、G）ステートも有する既存の（S、G）状態でもないがあるのでPE3は、（S、G）参加無視しますUpstreamPortsにおけるAC（S、G）。"
    },
    {
      "indent": 3,
      "text": "3. The multicast stream (S,G) flows along CE3 -> PE2 -> PE1 -> CE1.",
      "section_title": true,
      "ja": "3.マルチキャストストリーム（S、G）は、CE3に沿って流れる - > PE2  - > PE1  - > CE1。"
    },
    {
      "indent": 3,
      "text": "4. Now let us say that CE2 sends a Join(*,G) with UpstreamNeighbors(*,G) = CE4.",
      "ja": "4.今、私たちはCE2はUpstreamNeighbors（*、G）= CE4に参加（*、G）を送ることにしましょう。"
    },
    {
      "indent": 3,
      "text": "5. PE1 consumes the Join(*,G) and builds forwarding state, since the Join(*,G) is received on an AC.",
      "ja": "5. PE1は（G、*）参加消費し、参加（*、G）は、AC上で受信されているので、状態を転送構築します。"
    },
    {
      "indent": 7,
      "text": "PE2 consumes the Join(*,G); although this is a PW-only Join,\nforwarding state is built on this Join(*,G), since PE2 has an\nexisting (S,G) state with an AC in UpstreamPorts(S,G).  However,\nsince this is a PW-only Join, PE2 only adds the PW towards PE3\n(PW23) into UpstreamPorts(*,G) and hence into\nOutgoingPortList(*,G).  It does not add the PW towards PE1 (PW12)\ninto OutgoingPortList(*,G).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "PE3 consumes the Join(*,G) and builds forwarding state, since the Join(*,G) is targeting a neighbor residing on an AC.",
      "ja": "（*、G）は、AC上にあるネイバーをターゲットに参加するためPE3は、（*、G）参加消費し、状態を転送構築します。"
    },
    {
      "indent": 7,
      "text": "The resulting states at the PEs are as follows:",
      "ja": "次のようにするPEの結果の状態は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC1,*,G,CE4) = JP_HoldTime JPST(*,G,CE4) = t_periodic UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW13 } OutgoingPortList(*,G) = { AC2, PW13 }",
      "ja": "PE1の状態：JT（AC1、*、G、CE4）= JP_HoldTime JPST（*、G、CE4）はt_periodic UpstreamNeighborsを=（*、G）= {CE4} UpstreamPorts（*、G）= {PW13} OutgoingPortList（*は、G ）= {AC2、PW13}"
    },
    {
      "indent": 10,
      "text": "JT(AC1,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12, PW13 }",
      "ja": "JT（AC1、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= { AC1、PW12、PW13}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,*,G,CE4) = JP_HoldTime UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(G) = { PW23 } OutgoingPortList(*,G) = { PW23 }",
      "ja": "PE2の状態：JT（PW12、*、G、CE4）= JP_HoldTime UpstreamNeighbors（*、G）= {CE4} UpstreamPorts（G）= {PW23} OutgoingPortList（*、G）= {} PW23"
    },
    {
      "indent": 10,
      "text": "JT(PW12,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(S,G) = { PW12, AC3, PW23 }",
      "ja": "JT（PW12、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（S、G）= { PW12、AC3、PW23}"
    },
    {
      "indent": 7,
      "text": "PE3 states: JT(PW13,*,G,CE4) = JP_HoldTime JPST(*,G,CE4) = t_periodic UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }",
      "ja": "PE3状態：JT（PW13、*、G、CE4）= JP_HoldTime JPST（*、G、CE4）はt_periodic UpstreamNeighborsを=（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*は、G ）= {PW13、AC4}"
    },
    {
      "indent": 7,
      "text": "Joins are triggered as follows: PE1 triggers a Join(*,G) targeting CE4. Since the Join(*,G) was received on an AC and is targeting a neighbor that is residing across a PW, the triggered Join(S,G) is sent on all PWs.",
      "ja": "次のようにトリガーされるジョイン：PE1参加トリガCE4を標的とする（*、G）。 （*、G）参加はACで受信し、PWを横切って常駐さ隣人をターゲットに、トリガー（S、G）に参加するので、全てのPW上で送信されます。"
    },
    {
      "indent": 7,
      "text": "PE2 does not trigger a Join(*,G) based on this Join, since this is a PW-only Join.",
      "ja": "PE2は参加トリガされません（*、G）は、この参加に基づいて、これがあるので、PW-のみの参加します。"
    },
    {
      "indent": 7,
      "text": "PE3 triggers a Join(*,G) targeting CE4. Since the Join(*,G) is targeting a neighbor residing on an AC, it only sends the Join on AC4.",
      "ja": "PE3はCE4をターゲットに（*、G）が参加トリガ。 （*、G）参加をACに存在するネイバーを標的としているので、それだけAC4に参加送ります。"
    },
    {
      "indent": 3,
      "text": "6. If traffic is not flowing yet (i.e., step 3 is delayed so that it occurs after step 6) and in the interim JPST(S,G,CE3) on PE1 expires, causing it to send a refresh Join(S,G) targeting CE3, since the refresh Join(S,G) is targeting a neighbor that is residing across a PW, the refresh Join(S,G) is sent on all PWs.",
      "ja": "トラフィックがまだ流れていない場合は6（これはステップ6の後に起こるように、すなわち、ステップ3が遅延される）と暫定JPST PE1に（S、G、CE3）において、リフレッシュが（S、Gに参加し送信することを引き起こす満了します）リフレッシュがPWを横切って常駐さ隣人をターゲットにしている（S、G）に参加するので、CE3を標的、リフレッシュは全てのPWに送信する（S、G）に参加します。"
    },
    {
      "indent": 3,
      "text": "7. Note that PE1 refreshes its JT based on reception of refresh Joins from CE1 and CE2.",
      "ja": "PE1は、リフレッシュの受信に基づいて、そのJTを更新7.注CE1とCE2からジョイン。"
    },
    {
      "indent": 7,
      "text": "PE2 consumes the Join(S,G) and refreshes the JT(PW12,S,G,CE3)\ntimer.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "PE3 consumes the Join(S,G). It also builds forwarding state on this Join(S,G), even though this is a PW-only Join, since now PE2 has an existing (*,G) state with an AC in UpstreamPorts(*,G). However, since this is a PW-only Join, PE3 only adds the PW towards PE2 (PW23) into UpstreamPorts(S,G) and hence into OutgoingPortList(S,G). It does not add the PW towards PE1 (PW13) into OutgoingPortList(S,G).",
      "ja": "PE3は参加（S、G）を消費します。また、今PE2はUpstreamPortsにおけるAC（*、G）と既存の（*、G）ステートを有しているので、これはPW-のみ参加しても、この参加（S、G）に状態を転送構築します。しかし、このためであるPW-のみ参加し、PE3のみOutgoingPortListにUpstreamPortsにPE2に向けPW（PW23）（S、G）、従って（S、G）を付加します。それはOutgoingPortList（S、G）にPE1へのPW（PW13）を追加しません。"
    },
    {
      "indent": 7,
      "text": "PE3 states: JT(PW13,*,G,CE4) = active JPST(S,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }",
      "ja": "PE3状態：JT（PW13、*、G、CE4）=アクティブJPST（S、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*、Gを）= {PW13、AC4}"
    },
    {
      "indent": 10,
      "text": "JT(PW13,S,G,CE3) = JP_HoldTime UpstreamNeighbors(*,G) = { CE3 } UpstreamPorts(*,G) = { PW23 } OutgoingPortList(*,G) = { PW13, AC4, PW23 }",
      "ja": "JT（PW13、S、G、CE3）= JP_HoldTime UpstreamNeighbors（*、G）= {CE3} UpstreamPorts（*、G）= {PW23} OutgoingPortList（*、G）= {PW13、AC4、PW23}"
    },
    {
      "indent": 7,
      "text": "Joins are triggered as follows: PE2 already has (S,G) state, so it does not trigger a Join(S,G) based on reception of this refresh Join.",
      "ja": "次のようにトリガーされるジョイン：PE2は既に（S、G）状態を有するので、参加このリフレッシュの受信に基づいて参加（S、G）を誘発しません。"
    },
    {
      "indent": 7,
      "text": "PE3 does not trigger a Join(S,G) based on this Join, since this is a PW-only Join.",
      "ja": "この結合のみPWであるため、PE3は、この参加に基づいて参加（S、G）を誘発しません。"
    },
    {
      "indent": 3,
      "text": "8. The multicast stream (S,G) flows into the VPLS from two of the CEs -- CE3 and CE4. PE2 forwards the stream received from CE3 to PW12 and PW23. At the same time, PE3 forwards the stream received from CE4 to PW13 and PW23.",
      "ja": "CE3及びCE4  -  8マルチキャストストリーム（S、G）は、CEの2からVPLSに流入します。 PE2はPW12及びPW23にCE3から受信したストリームを転送します。同時に、PE3はPW13及びPW23にCE4から受信したストリームを転送します。"
    },
    {
      "indent": 7,
      "text": "The stream received over PW12 and PW13 is forwarded by PE1 to AC1\nand AC2.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "The stream received by PE3 over PW23 is forwarded to AC4. The stream received by PE2 over PW23 is forwarded to AC3. Either of these helps the CE routers to trigger Assert election.",
      "ja": "PW23上PE3によって受信されたストリームは、AC4に転送されます。 PW23上PE2によって受信されたストリームは、AC3に転送されます。これらのいずれかがアサート選挙をトリガするためにCEルータに役立ちます。"
    },
    {
      "indent": 3,
      "text": "9. CE3 and/or CE4 send(s) Assert message(s) to the VPLS. The PEs flood the Assert message(s) without examining it.",
      "ja": "9. CE3及び/又はCE4は、（S）VPLSにメッセージ（単数または複数）をアサート送ります。 PEはそれを調べずにアサートメッセージ（複数可）をあふれさせます。"
    },
    {
      "indent": 3,
      "text": "10. CE3 becomes the (S,G) Assert winner, and CE4 stops sending the multicast stream to the VPLS.",
      "ja": "10. CE3は（S、G）が勝者をアサートなり、CE4は、VPLSにマルチキャストストリームの送信を停止します。"
    },
    {
      "indent": 3,
      "text": "11. CE2 notices an RPF change due to the Assert and sends a Prune(S,G,rpt) with upstream neighbor = CE4.",
      "ja": "11. CE2がアサートによるRPF変更を通知し、上流隣接= CE4とプルーン（S、G、RPT）を送信します。"
    },
    {
      "indent": 3,
      "text": "12. PE1 consumes the Prune(S,G,rpt), and since PruneDesired(S,G,Rpt,CE4) is TRUE, it triggers a Prune(S,G,rpt) to CE4. Since the Prune is targeting a neighbor across a PW, it is sent on all PWs.",
      "ja": "12. PE1はプルーン（S、G、RPT）を消費し、PruneDesired（S、G、RPT、CE4）がTRUEであるので、それはCE4にプルーン（S、G、RPT）をトリガします。プルーンは、PW間で隣人をターゲットにしているので、それがすべてのPWに送信されます。"
    },
    {
      "indent": 7,
      "text": "PE2 consumes the Prune(S,G,rpt) and does not trigger any Prune\nbased on this Prune(S,G,rpt), since this was a PW-only Prune.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "PE3 consumes the Prune(S,G,rpt), and since PruneDesired(S,G,rpt,CE4) is TRUE, it sends the Prune(S,G,rpt) on AC4.",
      "ja": "PE3はプルーン（S、G、RPT）を消費し、PruneDesired（S、G、RPT、CE4）がTRUEであるので、AC4にプルーン（S、G、RPT）を送信します。"
    },
    {
      "indent": 7,
      "text": "PE1 states: JT(AC2,*,G,CE4) = active JPST(*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW13 } OutgoingPortList(*,G) = { AC2, PW13 }",
      "ja": "PE1の状態：JT（AC2、*、G、CE4）=アクティブJPST（*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {PW13} OutgoingPortList（*、G ）= {AC2、PW13}"
    },
    {
      "indent": 10,
      "text": "JT(AC2,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this is sent along with the Join(*,G) to CE4 based on JPST(*,G,CE4) expiry UpstreamPorts(S,G,rpt) = { PW13 } UpstreamNeighbors(S,G,rpt) = { CE4 }",
      "ja": "JTは（AC2、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしとは、このためJPSTに基づいCE4（に参加（*、G）と共に送信されます*、G、CE4）有効期限UpstreamPorts（S、G、RPT）= {PW13} UpstreamNeighbors（S、G、RPT）= {} CE4"
    },
    {
      "indent": 10,
      "text": "JT(AC1,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW12 } OutgoingPortList(S,G) = { AC1, PW12, AC2 }",
      "ja": "JT（AC1、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {PW12} OutgoingPortList（S、G）= { AC1、PW12、AC2}"
    },
    {
      "indent": 7,
      "text": "PE2 states: JT(PW12,*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { PW23 } OutgoingPortList(*,G) = { PW23 }",
      "ja": "PE2が状態：JT（PW12、*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {PW23} OutgoingPortList（*、G）= {} PW23"
    },
    {
      "indent": 10,
      "text": "JT(PW12,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this was created off a PW-only Prune UpstreamPorts(S,G,rpt) = { PW23 } UpstreamNeighbors(S,G,rpt) = { CE4 }",
      "ja": "JT（PW12、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしと、これはPW-のみプルーンUpstreamPorts（S、G、RPT）をオフに作成されたので= {PW23} UpstreamNeighbors（S、G、RPT）= {} CE4"
    },
    {
      "indent": 10,
      "text": "JT(PW12,S,G,CE3) = active JPST(S,G,CE3) = active UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { AC3 } OutgoingPortList(*,G) = { PW12, AC3 }",
      "ja": "JT（PW12、S、G、CE3）=アクティブJPST（S、G、CE3）=アクティブUpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）= {AC3} OutgoingPortList（*、G）= { PW12、AC3}"
    },
    {
      "indent": 7,
      "text": "PE3 states: JT(PW13,*,G,CE4) = active JPST(*,G,CE4) = active UpstreamNeighbors(*,G) = { CE4 } UpstreamPorts(*,G) = { AC4 } OutgoingPortList(*,G) = { PW13, AC4 }",
      "ja": "PE3状態：JT（PW13、*、G、CE4）=アクティブJPST（*、G、CE4）=アクティブUpstreamNeighbors（*、G）= {CE4} UpstreamPorts（*、G）= {AC4} OutgoingPortList（*、G ）= {PW13、AC4}"
    },
    {
      "indent": 10,
      "text": "JT(PW13,S,G,CE4) = JP_HoldTime with S,G,rpt prune flag JPST(S,G,CE4) = none, since this is sent along with the Join(*,G) to CE4 based on JPST(*,G,CE4) expiry UpstreamNeighbors(S,G,rpt) = { CE4 } UpstreamPorts(S,G,rpt) = { AC4 }",
      "ja": "JTは（PW13、S、G、CE4）= JP_HoldTime S、G、RPTプルーンフラグJPST（S、G、CE4）=なしとは、このためJPSTに基づいCE4（に参加（*、G）と共に送信されます*、G、CE4）有効期限UpstreamNeighbors（S、G、RPT）= {CE4} UpstreamPorts（S、G、RPT）= {} AC4"
    },
    {
      "indent": 10,
      "text": "JT(PW13,S,G,CE3) = active JPST(S,G,CE3) = none, since this state is created by a PW-only Join UpstreamNeighbors(S,G) = { CE3 } UpstreamPorts(S,G) = { PW23 } OutgoingPortList(S,G) = { PW23 }",
      "ja": "この状態は、PW-のみ参加UpstreamNeighbors（S、G）= {CE3} UpstreamPorts（S、G）によって作成されているのでJT（PW13、S、G、CE3）=アクティブJPST（S、G、CE3）は、どれも=いません= {PW23} OutgoingPortList（S、G）= {} PW23"
    },
    {
      "indent": 3,
      "text": "Even in this example, at the end of the (S,G) / (*,G) Assert election, there should be no duplicate traffic forwarded downstream, and traffic should flow only to the desired CEs.",
      "ja": "（*、G）選挙をアサートしても、この例では、（S、G）の終わりに/、下流転送重複トラフィックがあってはならない、とのトラフィックは、所望のCEにのみ流れるべきです。"
    },
    {
      "indent": 3,
      "text": "However, we don't have duplicate traffic because one of the CEs stops sending traffic due to the Assert, not because we don't have any forwarding state in the PEs to do this forwarding.",
      "ja": "CEのいずれかが原因アサートへのトラフィックの送信を停止し、私たちはこの転送を行うためのPE内の任意の転送状態を持っていないではないので、しかし、我々は、重複したトラフィックを持っていません。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Many members of the former L2VPN and PIM working groups have contributed to, and provided valuable comments and feedback on, this document, including Vach Kompella, Shane Amante, Sunil Khandekar, Rob Nath, Marc Lasserre, Yuji Kamite, Yiqun Cai, Ali Sajassi, Jozef Raets, Himanshu Shah (Ciena), and Himanshu Shah (Cisco).",
      "ja": "かつてのL2VPNおよびPIMワーキンググループの多くのメンバーはに貢献し、そしてVACH Kompella、シェーンAmante、スニルKhandekar、ロブナス、マーク・Lasserre、雄二Kamite、Yiqunカイ、アリSajassi、を含む、このドキュメント、上の貴重なコメントやフィードバックを提供してきましたヨゼフRaets、ヒマンシュシャー（シエナ）、およびヒマンシュシャー（シスコ）。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "Yetik Serbest and Suresh Boddapati coauthored earlier draft versions of this document.",
      "ja": "Yetik SerbestとスレシュBoddapatiはこのドキュメントの以前のドラフト版を共同執筆しました。"
    },
    {
      "indent": 3,
      "text": "Karl (Xiangrong) Cai and Princy Elizabeth made significant contributions to bring the specification to its current state, especially in the area of Join forwarding rules.",
      "ja": "カール（Xiangrong）カイとPrincyエリザベスは特に参加転送ルールの領域に、現在の状態に仕様をもたらすために重要な貢献をしました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Olivier Dornon Nokia Copernicuslaan 50 B-2018 Antwerp Belgium",
      "ja": "オリヴィエ・ソーンノキアCopernicuslaan 50 B-2018アントワープベルギー"
    },
    {
      "indent": 3,
      "text": "Email: olivier.dornon@nokia.com",
      "ja": "メール：olivier.dornon@nokia.com"
    },
    {
      "indent": 3,
      "text": "Jayant Kotalwar Nokia 701 East Middlefield Rd. Mountain View, CA 94043 United States of America",
      "ja": "ジャヤントKotalwarノキア701東ミドルRdを。マウンテンビュー、カリフォルニア州アメリカの94043米国"
    },
    {
      "indent": 3,
      "text": "Email: jayant.kotalwar@nokia.com",
      "ja": "メール：jayant.kotalwar@nokia.com"
    },
    {
      "indent": 3,
      "text": "Venu Hemige Nokia",
      "ja": "ノキアはHemigeを来ました"
    },
    {
      "indent": 3,
      "text": "Email: vhemige@gmail.com",
      "ja": "メール：vhemige@gmail.com"
    },
    {
      "indent": 3,
      "text": "Ray Qiu mistnet.io",
      "ja": "レイQ IUミストnet.IO"
    },
    {
      "indent": 3,
      "text": "Email: ray@mistnet.io",
      "ja": "メール：ray@mistnet.io"
    },
    {
      "indent": 3,
      "text": "Jeffrey Zhang Juniper Networks, Inc. 10 Technology Park Drive Westford, MA 01886 United States of America",
      "ja": "アメリカのジェフリー・チャンジュニパーネットワークス、株式会社10・テクノロジー・パークドライブウェストフォード、マサチューセッツ州01886米国"
    },
    {
      "indent": 3,
      "text": "Email: zzhang@juniper.net",
      "ja": "メール：zzhang@juniper.net"
    }
  ]
}