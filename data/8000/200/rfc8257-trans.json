{
  "title": {
    "text": "RFC 8257 - Data Center TCP (DCTCP): TCP Congestion Control for Data Centers",
    "ja": "RFC 8257 - データセンターTCP（DCTCP）：データセンターのためのTCPの輻輳制御"
  },
  "number": 8257,
  "created_at": "2019-10-27 13:11:31.361681+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        S. Bensley\nRequest for Comments: 8257                                     D. Thaler\nCategory: Informational                               P. Balasubramanian\nISSN: 2070-1721                                                Microsoft\n                                                               L. Eggert\n                                                                  NetApp\n                                                                 G. Judd\n                                                          Morgan Stanley\n                                                            October 2017",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Data Center TCP (DCTCP): TCP Congestion Control for Data Centers",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This Informational RFC describes Data Center TCP (DCTCP): a TCP congestion control scheme for data-center traffic. DCTCP extends the Explicit Congestion Notification (ECN) processing to estimate the fraction of bytes that encounter congestion rather than simply detecting that some congestion has occurred. DCTCP then scales the TCP congestion window based on this estimate. This method achieves high-burst tolerance, low latency, and high throughput with shallow-buffered switches. This memo also discusses deployment issues related to the coexistence of DCTCP and conventional TCP, discusses the lack of a negotiating mechanism between sender and receiver, and presents some possible mitigations. This memo documents DCTCP as currently implemented by several major operating systems. DCTCP, as described in this specification, is applicable to deployments in controlled environments like data centers, but it must not be deployed over the public Internet without additional measures.",
      "ja": "データセンタートラフィックのTCP輻輳制御方式：この情報RFCは、データセンターTCP（DCTCP）について説明します。 DCTCPは、単にいくつかの輻輳が発生したことを検出するのではなく、輻輳が発生したバイトの割合を推定するために明示的輻輳通知（ECN）処理を拡張します。 DCTCPは、この推定に基づいて、TCPの輻輳ウィンドウをスケーリングします。この方法は、浅い緩衝スイッチと高バースト耐性、低レイテンシ、および高スループットを達成します。また、このメモは、DCTCPと従来のTCPの共存に関連した展開の問題について説明し、送信者と受信者間の交渉メカニズムの欠如について説明し、いくつかの可能な緩和策を提示します。このメモ文書は、現在いくつかの主要なオペレーティング・システムによって実装DCTCP。 DCTCPは、この仕様書で説明するように、データセンタなどの管理された環境での展開にも適用可能であるが、それは追加の対策なしで公共のインターネット上で展開されてはなりません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8257.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8257で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  DCTCP Algorithm . . . . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  Marking Congestion on the L3 Switches and Routers . . . .   5\n  3.2.  Echoing Congestion Information on the Receiver  . . . . .   5\n  3.3.  Processing Echoed Congestion Indications on the Sender  .   7\n  3.4.  Handling of Congestion Window Growth  . . . . . . . . . .   8\n  3.5.  Handling of Packet Loss . . . . . . . . . . . . . . . . .   8\n  3.6.  Handling of SYN, SYN-ACK, and RST Packets . . . . . . . .   9\n4.  Implementation Issues . . . . . . . . . . . . . . . . . . . .   9\n  4.1.  Configuration of DCTCP  . . . . . . . . . . . . . . . . .   9\n  4.2.  Computation of DCTCP.Alpha  . . . . . . . . . . . . . . .  10\n5.  Deployment Issues . . . . . . . . . . . . . . . . . . . . . .  11\n6.  Known Issues  . . . . . . . . . . . . . . . . . . . . . . . .  12\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  12\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  13\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  14\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  16\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Large data centers necessarily need many network switches to interconnect their many servers. Therefore, a data center can greatly reduce its capital expenditure by leveraging low-cost switches. However, such low-cost switches tend to have limited queue capacities; thus, they are more susceptible to packet loss due to congestion.",
      "ja": "大規模なデータセンターは、必ずしも彼らの多くのサーバーを相互接続するために、多くのネットワークスイッチが必要になります。そのため、データセンターを大幅に低コストのスイッチを利用することによって、その設備投資を削減することができます。しかし、このような低コストのスイッチは、限られたキューの容量を持っている傾向があります。このように、彼らは、輻輳によるパケットロスの影響を受けやすいです。"
    },
    {
      "indent": 3,
      "text": "Network traffic in a data center is often a mix of short and long flows, where the short flows require low latencies and the long flows require high throughputs. Data centers also experience incast bursts, where many servers send traffic to a single server at the same time. For example, this traffic pattern is a natural consequence of the MapReduce [MAPREDUCE] workload: the worker nodes complete at approximately the same time, and all reply to the master node concurrently.",
      "ja": "データセンター内のネットワークトラフィックは、多くの場合、短いフローは、低レイテンシを必要とし、長いフローは、高スループットを必要とし、短いと長い流れのミックスです。データセンターでは、多くのサーバが同時に単一のサーバーにトラフィックを送信するincastバーストを、経験します。たとえば、このトラフィックパターンは、MapReduceの【のMapReduce】ワークロードの自然な結果である：作業者がほぼ同時に完了ノード、同時にマスターノードへのすべての返信。"
    },
    {
      "indent": 3,
      "text": "These factors place some conflicting demands on the queue occupancy of a switch:",
      "ja": "これらの要因は、スイッチのキュー占有上のいくつかの相反する要求を配置します。"
    },
    {
      "indent": 3,
      "text": "o The queue must be short enough that it does not impose excessive latency on short flows.",
      "ja": "Oキューは、それが短い流れに過度の遅延を課していないことを十分に短くなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The queue must be long enough to buffer sufficient data for the long flows to saturate the path capacity.",
      "ja": "Oキューは、十分な長さの長いフローがパス容量を飽和させるために十分なデータをバッファになければなりません。"
    },
    {
      "indent": 3,
      "text": "o The queue must be long enough to absorb incast bursts without excessive packet loss.",
      "ja": "キューは、過剰なパケットロスなしincastバーストを吸収するのに十分な長さでなければならないoを。"
    },
    {
      "indent": 3,
      "text": "Standard TCP congestion control [RFC5681] relies on packet loss to detect congestion. This does not meet the demands described above. First, short flows will start to experience unacceptable latencies before packet loss occurs. Second, by the time TCP congestion control kicks in on the senders, most of the incast burst has already been dropped.",
      "ja": "標準のTCPの輻輳制御[RFC5681]は、輻輳を検出するために、パケット損失に依存しています。これは、上記の要求を満たしていません。まず、短いフローは、パケットロスが発生する前に、容認できない待ち時間を経験し始めます。第二に、送信者の中の時間TCPの輻輳制御蹴りによって、incastバーストのほとんどは、すでに削除されています。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] describes a mechanism for using Explicit Congestion Notification (ECN) from the switches for detection of congestion. However, this method only detects the presence of congestion, not its extent. In the presence of mild congestion, the TCP congestion window is reduced too aggressively, and this unnecessarily reduces the throughput of long flows.",
      "ja": "[RFC3168]は、輻輳を検出するためのスイッチからの明示的輻輳通知（ECN）を使用するための機構を記載しています。しかし、この方法は、混雑の存在ではなく、その範囲を検出します。軽度の輻輳の存在下では、TCPの輻輳ウィンドウは、あまりにも積極的に減少し、これは不必要に長いフローのスループットが低下しています。"
    },
    {
      "indent": 3,
      "text": "Data Center TCP (DCTCP) changes traditional ECN processing by estimating the fraction of bytes that encounter congestion rather than simply detecting that some congestion has occurred. DCTCP then scales the TCP congestion window based on this estimate. This method achieves high-burst tolerance, low latency, and high throughput with shallow-buffered switches. DCTCP is a modification to the processing of ECN by a conventional TCP and requires that standard TCP congestion control be used for handling packet loss.",
      "ja": "データセンターTCP（DCTCP）は、輻輳が発生したバイトの割合を推定するのではなく、単にいくつかの輻輳が発生したことを検出することにより、従来のECN処理を変更します。 DCTCPは、この推定に基づいて、TCPの輻輳ウィンドウをスケーリングします。この方法は、浅い緩衝スイッチと高バースト耐性、低レイテンシ、および高スループットを達成します。 DCTCPは、従来のTCPによるECNの処理に変更され、標準のTCP輻輳制御は、パケット損失を処理するために使用されることを要求します。"
    },
    {
      "indent": 3,
      "text": "DCTCP should only be deployed in an intra-data-center environment where both endpoints and the switching fabric are under a single administrative domain. DCTCP MUST NOT be deployed over the public Internet without additional measures, as detailed in Section 5.",
      "ja": "DCTCPは両方のエンドポイントおよびスイッチングファブリックは、単一の管理ドメインの下にある内データセンター環境に配置する必要があります。第5節で詳述するようDCTCPは、追加の対策なしに公共のインターネット上で展開されてはなりません。"
    },
    {
      "indent": 3,
      "text": "The objective of this Informational RFC is to document DCTCP as a new approach (which is known to be widely implemented and deployed) to address TCP congestion control in data centers. The IETF TCPM Working Group reached consensus regarding the fact that a DCTCP standard would require further work. A precise documentation of running code enables follow-up Experimental or Standards Track RFCs through the IETF stream.",
      "ja": "この情報RFCの目的は、データセンターにおけるTCP輻輳制御に対処するために（広く実装と展開されることが知られている）新しいアプローチとしてDCTCPを文書化することです。 IETF TCPM作業部会はDCTCP標準はさらなる作業が必要になるという事実について合意に達しました。コードを実行しているの正確な文書は、フォローアップの実験や標準化過程RFCをIETFストリームを介して可能になります。"
    },
    {
      "indent": 3,
      "text": "This document describes DCTCP as implemented in Microsoft Windows Server 2012 [WINDOWS]. The Linux [LINUX] and FreeBSD [FREEBSD] operating systems have also implemented support for DCTCP in a way that is believed to follow this document. Deployment experiences with DCTCP have been documented in [MORGANSTANLEY].",
      "ja": "マイクロソフトのWindows Server 2012 [WINDOWS]に実装され、この文書では、DCTCPを説明しています。 Linuxの[LINUX]とFreeBSD [FREEBSD]のオペレーティングシステムも、この文書に従うと考えられている方法でDCTCPのサポートを実施しています。 DCTCPと展開の経験が[MORGANSTANLEY]に記載されています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 3,
      "text": "Normative language is used to describe how necessary the various aspects of a DCTCP implementation are for interoperability, but even compliant implementations without the measures in Sections 4-6 would still only be safe to deploy in controlled environments, i.e., not over the public Internet.",
      "ja": "すなわち、ない公共のインターネット上で、規範的言語はDCTCP実装のさまざまな側面が相互運用性のためにどのように必要に応じて記述するために使用されますが、セクション4-6の対策なしでも準拠した実装はまだのみ制御された環境で展開するのが安全だろう。"
    },
    {
      "indent": 0,
      "text": "3. DCTCP Algorithm",
      "section_title": true,
      "ja": "3. DCTCPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "There are three components involved in the DCTCP algorithm:",
      "ja": "DCTCPアルゴリズムに関係する3つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "o The switches (or other intermediate devices in the network) detect congestion and set the Congestion Encountered (CE) codepoint in the IP header.",
      "ja": "Oスイッチ（またはネットワーク内の他の中間装置）が輻輳を検出し、IPヘッダ内の輻輳が発生しました（CE）コードポイントを設定します。"
    },
    {
      "indent": 3,
      "text": "o The receiver echoes the congestion information back to the sender, using the ECN-Echo (ECE) flag in the TCP header.",
      "ja": "O受信機は、TCPヘッダにECN-エコー（ECE）フラグを使用して、送信者に渋滞情報をエコーし​​ます。"
    },
    {
      "indent": 3,
      "text": "o The sender computes a congestion estimate and reacts by reducing the TCP congestion window (cwnd) accordingly.",
      "ja": "O送信側は、輻輳推定値を計算し、それに応じてTCP輻輳ウィンドウ（CWND）を減少させることによって反応します。"
    },
    {
      "indent": 0,
      "text": "3.1. Marking Congestion on the L3 Switches and Routers",
      "section_title": true,
      "ja": "3.1。 L3スイッチおよびルータの輻輳をマーキング"
    },
    {
      "indent": 3,
      "text": "The Layer 3 (L3) switches and routers in a data-center fabric indicate congestion to the end nodes by setting the CE codepoint in the IP header as specified in Section 5 of [RFC3168]. For example, the switches may be configured with a congestion threshold. When a packet arrives at a switch and its queue length is greater than the congestion threshold, the switch sets the CE codepoint in the packet. For example, Section 3.4 of [DCTCP10] suggests threshold marking with a threshold of K > (RTT * C)/7, where C is the link rate in packets per second. In typical deployments, the marking threshold is set to be a small value to maintain a short average queueing delay. However, the actual algorithm for marking congestion is an implementation detail of the switch and will generally not be known to the sender and receiver. Therefore, the sender and receiver should not assume that a particular marking algorithm is implemented by the switching fabric.",
      "ja": "[RFC3168]のセクション5で指定されるように、データセンター・ファブリックのレイヤ3（L3）スイッチおよびルータは、IPヘッダのCEコードポイントを設定することにより、エンドノードに輻輳を示します。例えば、スイッチが輻輳閾値を用いて構成することができます。パケットがスイッチに到着すると、そのキュー長が輻輳しきい値よりも大きい場合、スイッチはパケット内のCEコードポイントを設定します。例えば、[DCTCP10]のセクション3.4は、Cは、秒あたりのパケットでリンクレートであるKの閾値とマーキング閾値>（RTT * C）/ 7を、示唆しています。典型的な展開では、マーキング閾値は、短い平均待ち行列遅延を維持するために小さな値に設定されます。しかし、輻輳をマーキングするための実際のアルゴリズムは、スイッチの実装の詳細であり、一般的に送信側と受信側に知られないであろう。したがって、送信者と受信者は、特定のマーキングアルゴリズムは、スイッチング・ファブリックによって実現されることを前提としてはなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Echoing Congestion Information on the Receiver",
      "section_title": true,
      "ja": "3.2。レシーバ上の渋滞情報をエコー"
    },
    {
      "indent": 3,
      "text": "According to Section 6.1.3 of [RFC3168], the receiver sets the ECE flag if any of the packets being acknowledged had the CE codepoint set. The receiver then continues to set the ECE flag until it receives a packet with the Congestion Window Reduced (CWR) flag set. However, the DCTCP algorithm requires more-detailed congestion information. In particular, the sender must be able to determine the number of bytes sent that encountered congestion. Thus, the scheme described in [RFC3168] does not suffice.",
      "ja": "確認応答されたパケットのいずれかがCEコードポイントのセットを有する場合、[RFC3168]のセクション6.1.3によれば、受信機は、ECEフラグをセットします。受信機は、それが減少輻輳ウィンドウ（CWR）フラグを設定してパケットを受信するまで、ECEフラグを設定し続けます。しかし、DCTCPアルゴリズムは、より詳細な渋滞情報が必要です。具体的には、送信者が渋滞に遭遇送信されたバイトの数を決定することができなければなりません。したがって、[RFC3168]に記載の方式は、十分ではありません。"
    },
    {
      "indent": 3,
      "text": "One possible solution is to ACK every packet and set the ECE flag in the ACK if and only if the CE codepoint was set in the packet being acknowledged. However, this prevents the use of delayed ACKs, which are an important performance optimization in data centers. If the delayed ACK frequency is n, then an ACK is generated every n packets.",
      "ja": "一つの可能​​な解決策は、すべてのパケットをACKとCEコードポイントが認識されているパケットに設定された場合に限り、ACKにECEフラグを設定することです。しかし、これは、データセンターにおける重要なパフォーマンスの最適化されている遅延ACKの使用を防止します。遅延ACK周波数がNである場合、ACKは、すべてのN個のパケットが生成されます。"
    },
    {
      "indent": 3,
      "text": "The typical value of n is 2, but it could be affected by ACK throttling or packet-coalescing techniques designed to improve performance.",
      "ja": "Nの典型的な値は2であるが、性能を改善するために設計されたACKスロットリングまたはパケット凝集技術により影響を受ける可能性があります。"
    },
    {
      "indent": 3,
      "text": "Instead, DCTCP introduces a new Boolean TCP state variable, DCTCP Congestion Encountered (DCTCP.CE), which is initialized to false and stored in the Transmission Control Block (TCB). When sending an ACK, the ECE flag MUST be set if and only if DCTCP.CE is true. When receiving packets, the CE codepoint MUST be processed as follows:",
      "ja": "その代わり、DCTCPはfalseに初期化され、伝送制御ブロック（TCB）に格納された新しいブールTCP状態変数、（DCTCP.CE）が発生しましたDCTCP輻輳を、紹介します。 ACKを送信する場合、ECEフラグがDCTCP.CEが真である場合にのみ設定しなければなりません。パケットを受信すると、次のように、CEコードポイントを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. If the CE codepoint is set and DCTCP.CE is false, set DCTCP.CE to true and send an immediate ACK.",
      "ja": "CEコードポイントが設定されDCTCP.CEがfalse、trueにDCTCP.CEを設定し、すぐにACKを送信した場合1。"
    },
    {
      "indent": 3,
      "text": "2. If the CE codepoint is not set and DCTCP.CE is true, set DCTCP.CE to false and send an immediate ACK.",
      "ja": "2. CEコードポイントが設定されDCTCP.CEが真であるされていない場合は、DCTCP.CEをfalseに設定し、即時ACKを送信します。"
    },
    {
      "indent": 3,
      "text": "3. Otherwise, ignore the CE codepoint.",
      "section_title": true,
      "ja": "3.それ以外の場合は、CEコードポイントを無視します。"
    },
    {
      "indent": 3,
      "text": "Since the immediate ACK reflects the new DCTCP.CE state, it may acknowledge any previously unacknowledged packets in the old state. This can lead to an incorrect rate computation at the sender per Section 3.3. To avoid this, an implementation MAY choose to send two ACKs: one for previously unacknowledged packets and another acknowledging the most recently received packet.",
      "ja": "即時ACKが新しいDCTCP.CE状態を反映しているので、それは古い状態で以前に未確認のパケットを確認してもよいです。これは、3.3節ごとに、送信者の間違ったレートの計算につながることができます。以前未確認パケットのための1つの最も最近受信したパケットを認める別：これを避けるために、実装は、次の2つのACKを送信することを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Receiver handling of the CWR bit is also per [RFC3168] (including [Err3639]). That is, on receipt of a segment with both the CE and CWR bits set, CWR is processed first and then CE is processed.",
      "ja": "CWRビットの受信処理は、（[Err3639]など）[RFC3168]あたりもあります。つまり、設定CEとCWRビットの両方を有するセグメントの受信時に、CWRが最初に処理され、次いでCEが処理されます。"
    },
    {
      "indent": 4,
      "text": "                         Send immediate\n                         ACK with ECE=0\n             .-----.     .--------------.     .-----.\nSend 1 ACK  /      v     v              |     |      \\\n for every |     .------------.    .------------.     | Send 1 ACK\n n packets |     | DCTCP.CE=0 |    | DCTCP.CE=1 |     | for every\nwith ECE=0 |     '------------'    '------------'     | n packets\n            \\      |     |              ^     ^      /  with ECE=1\n             '-----'     '--------------'     '-----'\n                          Send immediate\n                          ACK with ECE=1",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: ACK Generation State Machine",
      "ja": "図1：ACK生成ステートマシン"
    },
    {
      "indent": 0,
      "text": "3.3. Processing Echoed Congestion Indications on the Sender",
      "section_title": true,
      "ja": "3.3。送信者にエコー輻輳適応の処理"
    },
    {
      "indent": 3,
      "text": "The sender estimates the fraction of bytes sent that encountered congestion. The current estimate is stored in a new TCP state variable, DCTCP.Alpha, which is initialized to 1 and SHOULD be updated as follows:",
      "ja": "送信者が発生した渋滞ことを送信されたバイトの割合を推定します。現在の推定値は1に初期化され、次のように更新されるべき新しいTCP状態変数、DCTCP.Alpha、に格納されます。"
    },
    {
      "indent": 6,
      "text": "DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M",
      "ja": "DCTCP.Alpha = DCTCP.Alpha *（1  -  G）+ G * M"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "o g is the estimation gain, a real number between 0 and 1. The selection of g is left to the implementation. See Section 4 for further considerations.",
      "ja": "O gを推定ゲイン、Gの選択は実装に委ねられる0と1の間の実数です。さらに考慮事項については第4章を参照してください。"
    },
    {
      "indent": 3,
      "text": "o M is the fraction of bytes sent that encountered congestion during the previous observation window, where the observation window is chosen to be approximately the Round-Trip Time (RTT). In particular, an observation window ends when all bytes in flight at the beginning of the window have been acknowledged.",
      "ja": "O Mは、観察窓が約ラウンドトリップ時間（RTT）であるように選択された以前の観察窓、中輻輳が発生したことを送信されたバイトの割合です。具体的には、観察窓は、窓の初めに飛行中のすべてのバイトが確認されているときに終了します。"
    },
    {
      "indent": 3,
      "text": "In order to update DCTCP.Alpha, the TCP state variables defined in [RFC0793] are used, and three additional TCP state variables are introduced:",
      "ja": "DCTCP.Alphaを更新するために、[RFC0793]で定義されたTCP状態変数が使用されると、3つの追加のTCP状態変数が導入されます。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.WindowEnd: the TCP sequence number threshold when one observation window ends and another is to begin; initialized to SND.UNA.",
      "ja": "O DCTCP.WindowEnd：TCPシーケンス番号しきい値一個の観察窓が終了し、別の開始します。 SND.UNAに初期化。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.BytesAcked: the number of sent bytes acknowledged during the current observation window; initialized to 0.",
      "ja": "O DCTCP.BytesAcked：現在の観測窓の間に認めて送信されたバイト数。 0に初期化。"
    },
    {
      "indent": 3,
      "text": "o DCTCP.BytesMarked: the number of bytes sent during the current observation window that encountered congestion; initialized to 0.",
      "ja": "O DCTCP.BytesMarked：渋滞に遭遇した現在の観察ウィンドウの間に送信されたバイトの数。 0に初期化。"
    },
    {
      "indent": 3,
      "text": "The congestion estimator on the sender MUST process acceptable ACKs as follows:",
      "ja": "次のように送信側の輻輳推定器が許容できるACKを処理しなければなりません："
    },
    {
      "indent": 3,
      "text": "1. Compute the bytes acknowledged (TCP Selective Acknowledgment (SACK) options [RFC2018] are ignored for this computation):",
      "ja": "1.計算バイトは、（この計算では無視されているTCP選択確認応答（SACK）オプション[RFC2018]）を認めました："
    },
    {
      "indent": 10,
      "text": "BytesAcked = SEG.ACK - SND.UNA",
      "ja": "BytesAcked = SEG.ACK  -  SND.UNA"
    },
    {
      "indent": 3,
      "text": "2. Update the bytes sent:",
      "section_title": true,
      "ja": "2.送信されたバイトを更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesAcked += BytesAcked",
      "ja": "DCTCP.BytesAcked + = BytesAcked"
    },
    {
      "indent": 3,
      "text": "3. If the ECE flag is set, update the bytes marked:",
      "section_title": true,
      "ja": "ECEフラグが設定されている場合は3、マークされたバイトを更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesMarked += BytesAcked",
      "ja": "DCTCP.BytesMarked + = BytesAcked"
    },
    {
      "indent": 3,
      "text": "4. If the acknowledgment number is less than or equal to DCTCP.WindowEnd, stop processing. Otherwise, the end of the observation window has been reached, so proceed to update the congestion estimate as follows:",
      "ja": "前記確認応答番号が以下DCTCP.WindowEndに等しい場合、処理を停止します。それ以外の場合は、観察窓の終わりに達したので、次のように混雑推定値を更新するために進みます。"
    },
    {
      "indent": 3,
      "text": "5. Compute the congestion level for the current observation window:",
      "section_title": true,
      "ja": "5.現在の観察窓のための輻輳レベルを計算します。"
    },
    {
      "indent": 10,
      "text": "M = DCTCP.BytesMarked / DCTCP.BytesAcked",
      "ja": "M = DCTCP.BytesMarked / DCTCP.BytesAcked"
    },
    {
      "indent": 3,
      "text": "6. Update the congestion estimate:",
      "section_title": true,
      "ja": "6.混雑推定値を更新します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.Alpha = DCTCP.Alpha * (1 - g) + g * M",
      "ja": "DCTCP.Alpha = DCTCP.Alpha *（1  -  G）+ G * M"
    },
    {
      "indent": 3,
      "text": "7. Determine the end of the next observation window:",
      "section_title": true,
      "ja": "7.次の観察窓の終わりを決定します。"
    },
    {
      "indent": 10,
      "text": "DCTCP.WindowEnd = SND.NXT",
      "ja": "DCTCP.WindowEnd = SND.NXT"
    },
    {
      "indent": 3,
      "text": "8. Reset the byte counters:",
      "section_title": true,
      "ja": "8.バイトカウンタをリセットします。"
    },
    {
      "indent": 10,
      "text": "DCTCP.BytesAcked = DCTCP.BytesMarked = 0",
      "ja": "DCTCP.BytesAcked = DCTCP.BytesMarked = 0"
    },
    {
      "indent": 3,
      "text": "9. Rather than always halving the congestion window as described in [RFC3168], the sender SHOULD update cwnd as follows:",
      "ja": "9.ではなく、[RFC3168]で説明したように、常に輻輳ウィンドウを半減以下のように、送信側はCWNDを更新する必要があります："
    },
    {
      "indent": 10,
      "text": "cwnd = cwnd * (1 - DCTCP.Alpha / 2)",
      "ja": "CWND = CWND *（1  -  DCTCP.Alpha / 2）"
    },
    {
      "indent": 3,
      "text": "Just as specified in [RFC3168], DCTCP does not react to congestion indications more than once for every window of data. The setting of the CWR bit is also as per [RFC3168]. This is required for interoperation with classic ECN receivers due to potential misconfigurations.",
      "ja": "[RFC3168]で指定したのと同じように、DCTCPは、データのすべてのウィンドウのために複数回の輻輳の指標には反応しません。 CWRビットの設定は、[RFC3168]の通りもあります。これは、潜在的な設定ミスによる古典的なECN受信機との相互運用のために必要とされます。"
    },
    {
      "indent": 0,
      "text": "3.4. Handling of Congestion Window Growth",
      "section_title": true,
      "ja": "3.4。輻輳ウィンドウ成長の取り扱い"
    },
    {
      "indent": 3,
      "text": "A DCTCP sender grows its congestion window in the same way as conventional TCP. Slow start and congestion avoidance algorithms are handled as specified in [RFC5681].",
      "ja": "DCTCPの送信者は、従来のTCPと同じように、その輻輳ウィンドウを拡大します。 [RFC5681]で指定されるようにスロースタートと輻輳回避アルゴリズムが処理されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Handling of Packet Loss",
      "section_title": true,
      "ja": "3.5。パケットロスの取り扱い"
    },
    {
      "indent": 3,
      "text": "A DCTCP sender MUST react to loss episodes in the same way as conventional TCP, including fast retransmit and fast recovery algorithms, as specified in [RFC5681]. For cases where the packet loss is inferred and not explicitly signaled by ECN, the cwnd and other state variables like ssthresh MUST be changed in the same way that a conventional TCP would have changed them. As with ECN, a DCTCP sender will only reduce the cwnd once per window of data across all loss signals. Just as specified in [RFC5681], upon a timeout, the cwnd MUST be set to no more than the loss window (1 full-sized segment), regardless of previous cwnd reductions in a given window of data.",
      "ja": "[RFC5681]で指定されるようDCTCP送信者は、高速再送および高速回復アルゴリズムを含む従来のTCP、と同様に損失エピソードに反応しなければなりません。パケットロスが推測され、明示的にECNによって通知されていない場合のために、SSTHRESHようにcwndと他の状態変数は、従来のTCPがそれらを変更したのと同じ方法で変更されなければなりません。 ECNと同じように、DCTCP送信者は、一度だけ、すべての損失信号間でのデータのウィンドウごとのcwndを削減します。ちょうど[RFC5681]で指定されるように、タイムアウト時に、CWNDは、データの指定されたウィンドウに関係なく、前回のCWND削減の損失窓（1フルサイズのセグメント）を超えないように設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Handling of SYN, SYN-ACK, and RST Packets",
      "section_title": true,
      "ja": "3.6。 SYN、SYN-ACK、およびRSTパケットの処理"
    },
    {
      "indent": 3,
      "text": "If SYN, SYN-ACK, and RST packets for DCTCP connections have the ECN-Capable Transport (ECT) codepoint set in the IP header, they will receive the same treatment as other DCTCP packets when forwarded by a switching fabric under load. Lack of ECT in these packets can result in a higher drop rate, depending on the switching fabric configuration. Hence, for DCTCP connections, the sender SHOULD set ECT for SYN, SYN-ACK, and RST packets. A DCTCP receiver ignores CE codepoints set on any SYN, SYN-ACK, or RST packets.",
      "ja": "DCTCP接続のSYN、SYN-ACK、及びRSTパケットはIPヘッダ内（ECT）コードポイントセットECN-可能なトランスポートを使用している場合、負荷の下でスイッチングファブリックによって転送されたとき、それらは他のDCTCPパケットと同じ処理を受けます。これらのパケットにECTの欠如は、スイッチング・ファブリックの構成に応じて、より高い液滴速度をもたらすことができます。したがって、DCTCP接続のため、送信者は、SYN、SYN-ACK、及びRSTパケットに対するECTを設定する必要があります。 DCTCP受信機は、任意のSYN、SYN-ACK、またはRSTパケットに設定されたCEのコードポイントを無視します。"
    },
    {
      "indent": 0,
      "text": "4. Implementation Issues",
      "section_title": true,
      "ja": "4.実装の問題"
    },
    {
      "indent": 0,
      "text": "4.1. Configuration of DCTCP",
      "section_title": true,
      "ja": "4.1。 DCTCPの設定"
    },
    {
      "indent": 3,
      "text": "An implementation needs to know when to use DCTCP. Data-center servers may need to communicate with endpoints outside the data center, where DCTCP is unsuitable or unsupported. Thus, a global configuration setting to enable DCTCP will generally not suffice. DCTCP provides no mechanism for negotiating its use. Thus, additional management and configuration functionality is needed to ensure that DCTCP is not used with non-DCTCP endpoints.",
      "ja": "実装はDCTCPを使用する際に知っておく必要があります。データセンターサーバーはDCTCPが不適切またはサポートされていないデータセンター、外部エンドポイントと通信する必要があるかもしれません。したがって、DCTCPを有効にする設定をグローバルコンフィギュレーションは、一般的に十分ではありません。 DCTCPは、その使用を交渉するための仕組みを提供していません。このように、追加の管理および設定機能がDCTCPが非DCTCPエンドポイントで使用されていないことを保証するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "Known solutions rely on either configuration or heuristics. Heuristics need to allow endpoints to individually enable DCTCP to ensure a DCTCP sender is always paired with a DCTCP receiver. One approach is to enable DCTCP based on the IP address of the remote endpoint. Another approach is to detect connections that transmit within the bounds of a data center. For example, an implementation could support automatic selection of DCTCP if the estimated RTT is less than a threshold (like 10 msec) and ECN is successfully negotiated under the assumption that if the RTT is low, then the two endpoints are likely in the same data-center network.",
      "ja": "既知の解決策は、設定またはヒューリスティックのいずれかに依存しています。ヒューリスティックは、個別にDCTCPの送信者は、常にDCTCP受信機とペアリングされていることを確認するためにDCTCPを可能にするために、エンドポイントを許可する必要があります。一つのアプローチは、リモートエンドポイントのIPアドレスに基づいてDCTCPを有効にすることです。別のアプローチは、データセンターの範囲内で送信接続を検出することです。推定されたRTTが閾値未満である場合、例えば、実装はDCTCPの自動選択をサポートすることができる（のような10ミリ秒）とECNが正常RTTが低い場合、2つのエンドポイントが同じデータにそうであるという仮定の下で交渉されますネットワーク-center。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] forbids the ECN-marking of pure ACK packets because of the inability of TCP to mitigate ACK-path congestion. RFC 3168 also forbids ECN-marking of retransmissions, window probes, and RSTs. However, dropping all these control packets -- rather than ECN-marking them -- has considerable performance disadvantages. It is RECOMMENDED that an implementation provide a configuration knob that will cause ECT to be set on such control packets, which can be used in environments where such concerns do not apply. See [ECN-EXPERIMENTATION] for details.",
      "ja": "[RFC3168]はECNマーキング純粋なACKパケットのためにACKパスの輻輳を緩和するTCPのできないのを禁止します。 RFC 3168はまた、ECNマーキング再送信、ウィンドウプローブ、とのRSTのを禁じています。しかし、これらすべての制御パケットをドロップする - というよりも、それらをECNは、マーキング - かなりのパフォーマンスの欠点を持っています。実装がECTは、そのような懸念が適用されない環境で使用することができ、このような制御パケット、上に設定されるようになります設定ノブを提供することを推奨しています。詳細については、[ECN-実験]を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is useful to implement DCTCP as an additional action on top of an existing congestion control algorithm like Reno [RFC5681]. The DCTCP implementation MAY also allow configuration of resetting the value of DCTCP.Alpha as part of processing any loss episodes.",
      "ja": "リノ[RFC5681]のような既存の輻輳制御アルゴリズムの上に追加のアクションとしてDCTCPを実装するのに便利です。 DCTCP実装はまた、任意の損失エピソードの処理の一部としてDCTCP.Alphaの値を再設定の構成を可能にすることができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Computation of DCTCP.Alpha",
      "section_title": true,
      "ja": "4.2。 DCTCP.Alphaの計算"
    },
    {
      "indent": 3,
      "text": "As noted in Section 3.3, the implementation will need to choose a suitable estimation gain. [DCTCP10] provides a theoretical basis for selecting the gain. However, it may be more practical to use experimentation to select a suitable gain for a particular network and workload. A fixed estimation gain of 1/16 is used in some implementations. (It should be noted that values of 0 or 1 for g result in problematic behavior; g=0 fixes DCTCP.Alpha to its initial value, and g=1 sets it to M without any smoothing.)",
      "ja": "3.3節で述べたように、実装は、適切な推定ゲインを選択する必要があります。 【DCTCP10】利得を選択するための理論的な基礎を提供します。しかし、特定のネットワークとワークロードに適した利得を選択するための実験を使用することがより実用的であり得ます。 1/16の固定された推定ゲインは、いくつかの実装で使用されています。 （これは、問題行動のG結果のために0または1の値ことに留意すべきである。任意の平滑化せずにMに初期値にG = 0修正DCTCP.Alpha、およびG = 1セットを）"
    },
    {
      "indent": 3,
      "text": "The DCTCP.Alpha computation as per the formula in Section 3.3 involves fractions. An efficient kernel implementation MAY scale the DCTCP.Alpha value for efficient computation using shift operations. For example, if the implementation chooses g as 1/16, multiplications of DCTCP.Alpha by g become right-shifts by 4. A scaling implementation SHOULD ensure that DCTCP.Alpha is able to reach 0 once it falls below the smallest shifted value (16 in the above example). At the other extreme, a scaled update needs to ensure DCTCP.Alpha does not exceed the scaling factor, which would be equivalent to greater than 100% congestion. So, DCTCP.Alpha MUST be clamped after an update.",
      "ja": "セクション3.3における式の通りDCTCP.Alpha計算は、画分を含みます。効率的なカーネルの実装では、シフト演算を使用して効率的な計算のためのDCTCP.Alpha値をスケーリングすることができます。例えば、実装は1/16としてGを選択した場合、GによってDCTCP.Alphaの乗算は（それが最も小さいシフト値を下回ったらスケーリング実装はDCTCP.Alphaが0に到達することが可能であることを確認してください4によって右シフトとなります上記の例では16）。他の極端で、スケーリングされた更新はDCTCP.Alphaが100％以上の混雑に相当するであろう倍率を超えないことを保証する必要があります。だから、DCTCP.Alphaは、更新後にクランプされなければなりません。"
    },
    {
      "indent": 3,
      "text": "This results in the following computations replacing steps 5 and 6 in Section 3.3, where SCF is the chosen scaling factor (65536 in the example), and SHF is the shift factor (4 in the example):",
      "ja": "これは、SCFは、選択されたスケーリングファクタ（この例では65536）であり、SHFはシフトファクター（この例では4）であり、セクション3.3の手順5および6を交換次の計算での結果："
    },
    {
      "indent": 3,
      "text": "1. Compute the congestion level for the current observation window:",
      "section_title": true,
      "ja": "1.現在の観察窓のための輻輳レベルを計算します。"
    },
    {
      "indent": 10,
      "text": "ScaledM = SCF * DCTCP.BytesMarked / DCTCP.BytesAcked",
      "ja": "ScaledM = SCF * DCTCP.BytesMarked / DCTCP.BytesAcked"
    },
    {
      "indent": 3,
      "text": "2. Update the congestion estimate:",
      "section_title": true,
      "ja": "2.混雑推定値を更新します。"
    },
    {
      "indent": 10,
      "text": "if (DCTCP.Alpha >> SHF) == 0, then DCTCP.Alpha = 0",
      "ja": "（DCTCP.Alpha >> SHF）== 0、次いでDCTCP.Alpha = 0の場合"
    },
    {
      "indent": 10,
      "text": "DCTCP.Alpha += (ScaledM >> SHF) - (DCTCP.Alpha >> SHF)",
      "ja": "DCTCP.Alpha + =（ScaledM >> SHF） - （DCTCP.Alpha >> SHF）"
    },
    {
      "indent": 10,
      "text": "if DCTCP.Alpha > SCF, then DCTCP.Alpha = SCF",
      "ja": "DCTCP.Alpha> SCF、その後、DCTCP.Alpha = SCF場合"
    },
    {
      "indent": 0,
      "text": "5. Deployment Issues",
      "section_title": true,
      "ja": "5.展開の問題"
    },
    {
      "indent": 3,
      "text": "DCTCP and conventional TCP congestion control do not coexist well in the same network. In typical DCTCP deployments, the marking threshold in the switching fabric is set to a very low value to reduce queueing delay, and a relatively small amount of congestion will exceed the marking threshold. During such periods of congestion, conventional TCP will suffer packet loss and quickly and drastically reduce cwnd. DCTCP, on the other hand, will use the fraction of marked packets to reduce cwnd more gradually. Thus, the rate reduction in DCTCP will be much slower than that of conventional TCP, and DCTCP traffic will gain a larger share of the capacity compared to conventional TCP traffic traversing the same path. If the traffic in the data center is a mix of conventional TCP and DCTCP, it is RECOMMENDED that DCTCP traffic be segregated from conventional TCP traffic. [MORGANSTANLEY] describes a deployment that uses the IP Differentiated Services Codepoint (DSCP) bits to segregate the network such that Active Queue Management (AQM) [RFC7567] is applied to DCTCP traffic, whereas TCP traffic is managed via drop-tail queueing.",
      "ja": "DCTCPと従来のTCPの輻輳制御は、同じネットワーク内にうまく共存しません。典型的DCTCP展開では、スイッチングファブリックのマーキング閾値は、キューイング遅延を低減するために非常に低い値に設定され、輻輳の比較的少量のマーキングしきい値を超えることになります。混雑のような期間中は、従来のTCPは、パケット損失を被る迅速かつ大幅にcwndを削減します。 DCTCPは、一方では、より緩やかにcwndを減らすためにマークされたパケットの割合を使用します。したがって、DCTCPにおけるレート低減は、従来のTCPよりもはるかに遅くなり、そしてDCTCPトラフィックが同じパスを横断する従来のTCPトラフィックに比べて容量の大きなシェアを獲得します。データセンター内のトラフィックは、従来のTCPとDCTCPのミックスがある場合は、DCTCPトラフィックは、従来のTCPトラフィックから分離することが推奨されます。 [MORGANSTANLEY]ネットワークを分離するためにIP差別化サービスコードポイント（DSCP）ビットを使用して、展開を説明TCPトラフィックがドロップテールキューイングを経由して管理されているのに対し、アクティブキュー管理（AQM）[RFC7567]は、DCTCPトラフィックに適用されるようになっています。"
    },
    {
      "indent": 3,
      "text": "Deployments should take into account segregation of non-TCP traffic as well. Today's commodity switches allow configuration of different marking/drop profiles for non-TCP and non-IP packets. Non-TCP and non-IP packets should be able to pass through such switches, unless they really run out of buffer space.",
      "ja": "配備は、非TCPトラフィックのアカウントの分離を考慮する必要があります。今日のコモディティスイッチは、非TCPおよび非IPパケットに別のマーキング/ドロッププロファイルの設定が可能。非TCPおよび非IPパケットは、彼らが実際にバッファ領域が不足していない限り、このようなスイッチを通過することができるはずです。"
    },
    {
      "indent": 3,
      "text": "Since DCTCP relies on congestion marking by the switches, DCTCP's potential can only be realized in data centers where the entire network infrastructure supports ECN. The switches may also support configuration of the congestion threshold used for marking. The proposed parameterization can be configured with switches that implement Random Early Detection (RED) [RFC2309]. [DCTCP10] provides a theoretical basis for selecting the congestion threshold, but, as with the estimation gain, it may be more practical to rely on experimentation or simply to use the default configuration of the device. DCTCP will revert to loss-based congestion control when packet loss is experienced (e.g., when transiting a congested drop-tail link, or a link with an AQM drop behavior).",
      "ja": "DCTCPは、スイッチによってマーキング混雑に依存しているため、DCTCPの可能性が唯一のネットワークインフラストラクチャ全体がECNをサポートしているデータセンターで実現することができます。スイッチはまた、マーキングのために使用される輻輳閾値の設定をサポートすることができます。提案されたパラメータは、ランダム早期検出（RED）[RFC2309]を実装するスイッチで構成することができます。 【DCTCP10】推定ゲインと同様に、実験に依存するか、単にデバイスのデフォルト設定を使用することがより実用的であり得る、輻輳閾値を選択するための理論的基礎を提供するが、。パケット損失が経験されるときDCTCP、損失ベースの輻輳制御に戻ります（例えば、AQM降下挙動を有する輻輳ドロップテールリンク、またはリンクを通過する場合）。"
    },
    {
      "indent": 3,
      "text": "DCTCP requires changes on both the sender and the receiver, so both endpoints must support DCTCP. Furthermore, DCTCP provides no mechanism for negotiating its use, so both endpoints must be configured through some out-of-band mechanism to use DCTCP. A variant of DCTCP that can be deployed unilaterally and that only requires standard ECN behavior has been described in [ODCTCP] and [BSDCAN], but it requires additional experimental evaluation.",
      "ja": "DCTCPは、送信者と受信者の両方に変更が必要なので、両方のエンドポイントはDCTCPをサポートしている必要があります。さらに、DCTCPは、その使用を交渉するためのメカニズムを提供しないので、両方のエンドポイントはDCTCPを使用するいくつかのアウトオブバンド機構を介して設定する必要があります。一方的に展開され、そのことができるDCTCPの変異体は、標準ECN挙動は[ODCTCP]と[BSDCanは]に記載されている必要があり、それは、追加の実験的評価を必要とします。"
    },
    {
      "indent": 0,
      "text": "6. Known Issues",
      "section_title": true,
      "ja": "6.既知の問題"
    },
    {
      "indent": 3,
      "text": "DCTCP relies on the sender's ability to reconstruct the stream of CE codepoints received by the remote endpoint. To accomplish this, DCTCP avoids using a single ACK packet to acknowledge segments received both with and without the CE codepoint set. However, if one or more ACK packets are dropped, it is possible that a subsequent ACK will cumulatively acknowledge a mix of CE and non-CE segments. This will, of course, result in a less-accurate congestion estimate. There are some potential considerations:",
      "ja": "DCTCPは、リモートエンドポイントが受信したCEコードポイントの流れを再構築するために、送信者の能力に依存しています。これを達成するために、DCTCPはセグメントとし、CEコードポイントを設定せずに、両方の受信確認するために、単一のACKパケットを使用して回避します。一つ以上のACKパケットが廃棄されている場合は、それ以降のACKが累積的にCEおよび非CEセグメントのミックスを確認することが可能です。これは、当然のことながら、あまり正確な混雑推定値になります。いくつかの潜在的な考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "o Even with an inaccurate congestion estimate, DCTCP may still perform better than [RFC3168].",
      "ja": "Oでも不正確な輻輳推定値を用いて、DCTCPは依然として[RFC3168]よりも良好に実行することができます。"
    },
    {
      "indent": 3,
      "text": "o If the estimation gain is small relative to the packet loss rate, the estimate may not be too inaccurate.",
      "ja": "推定ゲインは、パケットロス率に対して小さい場合には、O、推定値があまりにも不正確になることがないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o If ACK packet loss mostly occurs under heavy congestion, most drops will occur during an unbroken string of CE packets, and the estimate will be unaffected.",
      "ja": "ACKパケットロスがほとんど混雑の下で発生した場合は、O、ほとんどの滴がCEパケットの連続した文字列の間に起こるであろう、と推定値は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "However, the effect of packet drops on DCTCP under real-world conditions has not been analyzed.",
      "ja": "しかし、パケットの影響が分析されていない現実世界の条件の下でDCTCPに落ちます。"
    },
    {
      "indent": 3,
      "text": "DCTCP provides no mechanism for negotiating its use. The effect of using DCTCP with a standard ECN endpoint has been analyzed in [ODCTCP] and [BSDCAN]. Furthermore, it is possible that other implementations may also modify behavior in the [RFC3168] style without negotiation, causing further interoperability issues.",
      "ja": "DCTCPは、その使用を交渉するための仕組みを提供していません。標準ECNエンドポイントとDCTCPを使用することの効果は、[BSDCanは] [ODCTCP]で分析されています。さらに、他の実装もさらに相互運用性の問題を引き起こして、交渉せずに[RFC3168]のスタイルで動作を変更することが可能です。"
    },
    {
      "indent": 3,
      "text": "Much like standard TCP, DCTCP is biased against flows with longer RTTs. A method for improving the RTT fairness of DCTCP has been proposed in [ADCTCP], but it requires additional experimental evaluation.",
      "ja": "多くの標準TCPのように、DCTCPは長いのRTTとフローに対して付勢されています。 DCTCPのRTT公平性を改善するための方法は、[ADCTCP]で提案されてきたが、それは追加の実験的評価を必要とします。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "DCTCP enhances ECN; thus, it inherits the general security considerations discussed in [RFC3168], although additional mitigation options exist due to the limited intra-data-center deployment of DCTCP.",
      "ja": "DCTCPは、ECNを強化します。追加の緩和オプションがDCTCPの限定されたイントラデータセンターの展開に起因存在するものの、したがって、それは、[RFC3168]で説明した一般的なセキュリティ問題を継承します。"
    },
    {
      "indent": 3,
      "text": "The processing changes introduced by DCTCP do not exacerbate the considerations in [RFC3168] or introduce new ones. In particular, with either algorithm, the network infrastructure or the remote endpoint can falsely report congestion and, thus, cause the sender to reduce cwnd. However, this is no worse than what can be achieved by simply dropping packets.",
      "ja": "DCTCPによって導入された処理の変更は、[RFC3168]での配慮を悪化させたり、新しいものを導入していません。具体的には、アルゴリズムのいずれかで、ネットワークインフラストラクチャまたはリモートエンドポイントが誤ってこのように、cwndのを減らすために、送信者を引き起こす、輻輳を報告することができます。しかし、これは単にパケットをドロップすることによって達成することができるものよりも悪いことではありません。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] requires that a compliant TCP must not set ECT on SYN or SYN-ACK packets. [RFC5562] proposes setting ECT on SYN-ACK packets but maintains the restriction of no ECT on SYN packets. Both these RFCs prohibit ECT in SYN packets due to security concerns regarding malicious SYN packets with ECT set. However, these RFCs are intended for general Internet use; they do not directly apply to a controlled data-center environment. The security concerns addressed by both of these RFCs might not apply in controlled environments like data centers, and it might not be necessary to account for the presence of non-ECN servers. Beyond the security considerations related to virtual servers, additional security can be imposed in the physical servers to intercept and drop traffic resembling an attack.",
      "ja": "[RFC3168]は準拠したTCPは、SYNまたはSYN-ACKパケットにECTを設定していなければならないことが必要です。 [RFC5562] SYN-ACKパケットにECTを設定する提案が、SYNパケットにはECTの制限を維持します。これらのRFCの両方が原因ECTが設定された悪質なSYNパケットに関するセキュリティ上の懸念にSYNパケットにECTを禁止しています。しかし、これらのRFCは、一般的なインターネットの使用を目的としています。彼らは直接制御、データセンター環境には適用されません。これらのRFCの両方によって対処セキュリティ上の懸念は、データセンタなどの管理された環境では適用されない場合があります、非ECNサーバの存在を説明するために必要ではないかもしれません。仮想サーバーに関連するセキュリティ上の考慮事項以外に、追加のセキュリティは、攻撃に似たトラフィックを傍受し、ドロップする物理サーバに課すことができます。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<https://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, DOI 10.17487/RFC2018, October 1996, <https://www.rfc-editor.org/info/rfc2018>.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、<HTTPS：//www.rfc- editor.org/info/rfc2018>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：//でWWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC5562] Kuzmanovic, A., Mondal, A., Floyd, S., and K. Ramakrishnan, \"Adding Explicit Congestion Notification (ECN) Capability to TCP's SYN/ACK Packets\", RFC 5562, DOI 10.17487/RFC5562, June 2009, <https://www.rfc-editor.org/info/rfc5562>.",
      "ja": "[RFC5562] Kuzmanovic、A.、Mondal、A.、フロイド、S.、およびK.ラマクリシュナン、RFC 5562、DOI 10.17487 / RFC5562、2009年6月 \"TCPのSYN / ACKパケットに明示的輻輳通知（ECN）機能を追加します\" 、<https://www.rfc-editor.org/info/rfc5562>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<https://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ADCTCP] Alizadeh, M., Javanmard, A., and B. Prabhakar, \"Analysis of DCTCP: Stability, Convergence, and Fairness\", DOI 10.1145/1993744.1993753, Proceedings of the ACM SIGMETRICS Joint International Conference on Measurement and Modeling of Computer Systems, June 2011, <https://dl.acm.org/citation.cfm?id=1993753>.",
      "ja": "【ADCTCP] Alizadeh、M.、Javanmard、A.およびB. Prabhakar、 \"DCTCPの解析：安定性、収束、及び公平性\"、DOI 10.1145 / 1993744.1993753、測定に関するACM SIGMETRICS合同国際会議の議事録、コンピュータのモデル化システムズ、2011年6月、<https://dl.acm.org/citation.cfm?id=1993753>。"
    },
    {
      "indent": 3,
      "text": "[BSDCAN] Kato, M., Eggert, L., Zimmermann, A., van Meter, R., and H. Tokuda, \"Extensions to FreeBSD Datacenter TCP for Incremental Deployment Support\", BSDCan 2015, June 2015, <https://www.bsdcan.org/2015/schedule/events/559.en.html>.",
      "ja": "[BSDCanは]加藤、M.、エッゲルト、L.、ツィンマーマン、A.、バンメーター、R.、およびH.徳田、 \"インクリメンタル展開支援のためのFreeBSDのデータセンターTCPへの拡張\"、BSDCanは2015年、2015年6月、<HTTPS： //www.bsdcan.org/2015/schedule/events/559.en.html>。"
    },
    {
      "indent": 3,
      "text": "[DCTCP10] Alizadeh, M., Greenberg, A., Maltz, D., Padhye, J., Patel, P., Prabhakar, B., Sengupta, S., and M. Sridharan, \"Data Center TCP (DCTCP)\", DOI 10.1145/1851182.1851192, Proceedings of the ACM SIGCOMM 2010 Conference, August 2010, <http://dl.acm.org/citation.cfm?doid=1851182.1851192>.",
      "ja": "【DCTCP10] Alizadeh、M.、グリーンバーグ、A.、モルツ、D.、Padhye、J.、パテル、P.、Prabhakar、B.、Sengupta、S.、およびM. Sridharan、「データセンターTCP（DCTCP） 」、DOI 10.1145 / 1851182.1851192、ACMのSIGCOMM 2010の議事録会議、2010年8月、<http://dl.acm.org/citation.cfm?doid=1851182.1851192>。"
    },
    {
      "indent": 3,
      "text": "[ECN-EXPERIMENTATION] Black, D., \"Explicit Congestion Notification (ECN) Experimentation\", Work in Progress, draft-ietf-tsvwg-ecn-experimentation-06, September 2017.",
      "ja": "[ECN-実験]ブラック、D.、 \"明示的輻輳通知（ECN）実験\" が進行中で働いて、ドラフト-IETF-TSVWG-ECN-実験-06、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[Err3639] RFC Errata, Erratum ID 3639, RFC 3168, <https://www.rfc-editor.org/errata/eid3639>.",
      "ja": "【Err3639] RFCエラッタ、エラータID 3639、RFC 3168、<https://www.rfc-editor.org/errata/eid3639>。"
    },
    {
      "indent": 3,
      "text": "[FREEBSD] Kato, M. and H. Panchasara, \"DCTCP (Data Center TCP) implementation\", January 2015, <https://github.com/freebsd/freebsd/ commit/8ad879445281027858a7fa706d13e458095b595f>.",
      "ja": "[FREEBSD]加藤、M.およびH. Panchasara、 \"DCTCP（データセンターTCP）の実装\"、2015年1月、<https://github.com/freebsd/freebsd/コミット/ 8ad879445281027858a7fa706d13e458095b595f>。"
    },
    {
      "indent": 3,
      "text": "[LINUX] Borkmann, D., Westphal, F., and Glenn. Judd, \"net: tcp: add DCTCP congestion control algorithm\", LINUX DCTCP Patch, September 2014, <https://git.kernel.org/cgit/linux/ kernel/git/davem/net-next.git/commit/ ?id=e3118e8359bb7c59555aca60c725106e6d78c5ce>.",
      "ja": "[LINUX] Borkmann、D.、ウェストファル、F.、及びグレン。ジャッド、 \"ネット：TCP：DCTCP輻輳制御アルゴリズムを追加\"、LINUX DCTCPパッチ、2014年9月、<https://git.kernel.org/cgit/linux/カーネル/ gitの/ davem /ネット-next.git /コミット/ ？ID = e3118e8359bb7c59555aca60c725106e6d78c5ce>。"
    },
    {
      "indent": 3,
      "text": "[MAPREDUCE] Dean, J. and S. Ghemawat, \"MapReduce: Simplified Data Processing on Large Clusters\", Proceedings of the 6th ACM/USENIX Symposium on Operating Systems Design and Implementation, October 2004, <https://www.usenix.org/ legacy/publications/library/proceedings/osdi04/tech/ dean.html>.",
      "ja": "[MapReduceの]ディーン、J.とS. Ghemawat、 \"MapReduceの：簡体データ処理大規模なクラスタ上の\"、オペレーティングシステムの設計と実装、第6回ACM / USENIXシンポジウム2004年10月、<HTTPS：//www.usenix。 ORG /レガシー/出版/ライブラリ/手続き/ osdi04 /ハイテク/ dean.html>。"
    },
    {
      "indent": 3,
      "text": "[MORGANSTANLEY] Judd, G., \"Attaining the Promise and Avoiding the Pitfalls of TCP in the Datacenter\", Proceedings of the 12th USENIX Symposium on Networked Systems Design and Implementation, May 2015, <https://www.usenix.org/conference/nsdi15/ technical-sessions/presentation/judd>.",
      "ja": "[MORGANSTANLEY]ジャッド、G.、「約束の達成およびDatacenterにおけるTCPの落とし穴を回避」、ネットワークシステムの設計と実装第12回USENIXシンポジウム、2015年5月、<https://www.usenix.org/の議事録会議/ nsdi15 /テクニカル・セッション/プレゼンテーション/ジャッド>。"
    },
    {
      "indent": 3,
      "text": "[ODCTCP] Kato, M., \"Improving Transmission Performance with One-Sided Datacenter TCP\", M.S. Thesis, Keio University, 2013, <http://eggert.org/students/kato-thesis.pdf>.",
      "ja": "[ODCTCP]加藤、M.、「片面データセンターTCPと改善伝送特性」、M.S。論文、慶應義塾大学、2013年、<http://eggert.org/students/kato-thesis.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, \"Recommendations on Queue Management and Congestion Avoidance in the Internet\", RFC 2309, DOI 10.17487/RFC2309, April 1998, <https://www.rfc-editor.org/info/rfc2309>.",
      "ja": "[RFC2309]ブレーデン、B.、クラーク、D.、クロウクロフト、J.、デイビー、B.、デアリング、S.、Estrin、D.、フロイド、S.、ヤコブソン、V.、Minshall、G.、ヤマウズラ、 C.、ピーターソン、L.、ラマクリシュナン、K.、Shenker、S.、Wroclawski、J.、およびL.チャン、 \"インターネットの待ち行列管理と輻輳回避に関する提言\"、RFC 2309、DOI 10.17487 / RFC2309、4月1998年、<https://www.rfc-editor.org/info/rfc2309>。"
    },
    {
      "indent": 3,
      "text": "[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., \"IETF Recommendations Regarding Active Queue Management\", BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, <https://www.rfc-editor.org/info/rfc7567>.",
      "ja": "[RFC7567]ベーカー、F.、エド。そして、G. Fairhurst、エド。、 \"アクティブキュー管理に関するIETF勧告\"、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、<https://www.rfc-editor.org/info/rfc7567>。"
    },
    {
      "indent": 3,
      "text": "[WINDOWS] Microsoft, \"Data Center Transmission Control Protocol (DCTCP)\", May 2012, <https://technet.microsoft.com/ en-us/library/hh997028(v=ws.11).aspx>.",
      "ja": "[WINDOWS]マイクロソフト、 \"データセンター伝送制御プロトコル（DCTCP）\"、2012年5月、<https://technet.microsoft.com/ EN-US /ライブラリ/ hh997028（V = ws.11）.aspxの>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The DCTCP algorithm was originally proposed and analyzed in [DCTCP10] by Mohammad Alizadeh, Albert Greenberg, Dave Maltz, Jitu Padhye, Parveen Patel, Balaji Prabhakar, Sudipta Sengupta, and Murari Sridharan.",
      "ja": "DCTCPアルゴリズムは本来のMohammad Alizadeh、アルバート・グリーンバーグ、デイブ・モルツ、Jitu Padhye、Parveenパテル、バラジ・プラブハカ、サディップタ・セングプタ、及びMurari Sridharanによって[DCTCP10]で提案されていると分析されました。"
    },
    {
      "indent": 3,
      "text": "We would like to thank Andrew Shewmaker for identifying the problem of clamping DCTCP.Alpha and proposing a solution for it.",
      "ja": "私たちは、クランプDCTCP.Alphaの問題を特定し、そのための解決策を提案するためアンドリューShewmakerに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Lars Eggert has received funding from the European Union's Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644866 (\"SSICLOPS\"). This document reflects only the authors' views and the European Commission is not responsible for any use that may be made of the information it contains.",
      "ja": "ラースEggertのは、付与契約番号644866（「SSICLOPS」）の下で、欧州連合（EU）のホライゾン2020年の研究と技術革新プログラム2014年から2018年から資金提供を受けています。この文書では、唯一の著者の見解を反映しており、欧州委員会は、それが含まれている情報を用いることができる任意の使用については責任を負いません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stephen Bensley Microsoft One Microsoft Way Redmond, WA 98052 United States of America",
      "ja": "スティーブン・Bensleyマイクロソフト1マイクロソフト道、レッドモンド、ワシントンアメリカの98052米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 703 5570 Email: sbens@microsoft.com",
      "ja": "電話：+1 425 703 5570 Eメール：sbens@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Dave Thaler Microsoft",
      "ja": "デーブターラーマイクロソフト"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 703 8835 Email: dthaler@microsoft.com",
      "ja": "電話：+1 425 703 8835 Eメール：dthaler@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Praveen Balasubramanian Microsoft",
      "ja": "Praveenさんbalasubramanianaマイクロソフト"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 538 2782 Email: pravb@microsoft.com",
      "ja": "電話：+1 425 538 2782 Eメール：pravb@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Lars Eggert NetApp Sonnenallee 1 Kirchheim 85551 Germany",
      "ja": "ラースEggertのNetAppのSonnenallee 1キルヒハイム85551ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 151 120 55791 Email: lars@netapp.com URI: http://eggert.org/",
      "ja": "電話：+49 151 120 55791 Eメール：lars@netapp.com URI：http://eggert.org/"
    },
    {
      "indent": 3,
      "text": "Glenn Judd Morgan Stanley",
      "ja": "グレン・ジャッドモルガン・スタンレー"
    },
    {
      "indent": 3,
      "text": "Phone: +1 973 979 6481 Email: glenn.judd@morganstanley.com",
      "ja": "電話：+1 973 979 6481 Eメール：glenn.judd@morganstanley.com"
    }
  ]
}