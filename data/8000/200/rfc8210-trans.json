{
  "title": {
    "text": "RFC 8210 - The Resource Public Key Infrastructure (RPKI) to Router Protocol, Version 1",
    "ja": "RFC 8210 - ルータプロトコル、バージョン1のリソース公開鍵インフラストラクチャ（RPKI）"
  },
  "number": 8210,
  "created_at": "2019-10-26 22:05:39.258823+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Bush\nRequest for Comments: 8210                     Internet Initiative Japan\nUpdates: 6810                                                 R. Austein\nCategory: Standards Track                           Dragon Research Labs\nISSN: 2070-1721                                           September 2017",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Resource Public Key Infrastructure (RPKI) to Router Protocol, Version 1",
      "ja": "ルータプロトコル、バージョン1のリソース公開鍵インフラストラクチャ（RPKI）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems and Autonomous System Paths of BGP announcements, routers need a simple but reliable mechanism to receive Resource Public Key Infrastructure (RFC 6480) prefix origin data and router keys from a trusted cache. This document describes a protocol to deliver them.",
      "ja": "検証可能起源自律システムとのBGPアナウンスメントの自律システムパスを検証するために、ルータは、信頼できるキャッシュからリソース公開鍵インフラストラクチャ（RFC 6480）の接頭辞元データとルータキーを受け取るために単純だが信頼性の高いメカニズムが必要です。この文書では、それらを提供するためのプロトコルを記述します。"
    },
    {
      "indent": 3,
      "text": "This document describes version 1 of the RPKI-Router protocol. RFC 6810 describes version 0. This document updates RFC 6810.",
      "ja": "この文書では、RPKI-Routerプロトコルのバージョン1を説明します。 RFC 6810はバージョン0このドキュメントの更新のRFC 6810について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8210.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8210で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4\n  1.2.  Changes from RFC 6810 . . . . . . . . . . . . . . . . . .   4\n2.  Glossary  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Deployment Structure  . . . . . . . . . . . . . . . . . . . .   5\n4.  Operational Overview  . . . . . . . . . . . . . . . . . . . .   6\n5.  Protocol Data Units (PDUs)  . . . . . . . . . . . . . . . . .   7\n  5.1.  Fields of a PDU . . . . . . . . . . . . . . . . . . . . .   7\n  5.2.  Serial Notify . . . . . . . . . . . . . . . . . . . . . .  10\n  5.3.  Serial Query  . . . . . . . . . . . . . . . . . . . . . .  10\n  5.4.  Reset Query . . . . . . . . . . . . . . . . . . . . . . .  12\n  5.5.  Cache Response  . . . . . . . . . . . . . . . . . . . . .  12\n  5.6.  IPv4 Prefix . . . . . . . . . . . . . . . . . . . . . . .  13\n  5.7.  IPv6 Prefix . . . . . . . . . . . . . . . . . . . . . . .  14\n  5.8.  End of Data . . . . . . . . . . . . . . . . . . . . . . .  15\n  5.9.  Cache Reset . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.10. Router Key  . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.11. Error Report  . . . . . . . . . . . . . . . . . . . . . .  17\n6.  Protocol Timing Parameters  . . . . . . . . . . . . . . . . .  18\n7.  Protocol Version Negotiation  . . . . . . . . . . . . . . . .  20\n8.  Protocol Sequences  . . . . . . . . . . . . . . . . . . . . .  21\n  8.1.  Start or Restart  . . . . . . . . . . . . . . . . . . . .  21\n  8.2.  Typical Exchange  . . . . . . . . . . . . . . . . . . . .  22\n  8.3.  No Incremental Update Available . . . . . . . . . . . . .  23\n  8.4.  Cache Has No Data Available . . . . . . . . . . . . . . .  23\n9.  Transport . . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  9.1.  SSH Transport . . . . . . . . . . . . . . . . . . . . . .  25\n  9.2.  TLS Transport . . . . . . . . . . . . . . . . . . . . . .  26\n  9.3.  TCP MD5 Transport . . . . . . . . . . . . . . . . . . . .  26\n  9.4.  TCP-AO Transport  . . . . . . . . . . . . . . . . . . . .  27\n10. Router-Cache Setup  . . . . . . . . . . . . . . . . . . . . .  27\n11. Deployment Scenarios  . . . . . . . . . . . . . . . . . . . .  28\n12. Error Codes . . . . . . . . . . . . . . . . . . . . . . . . .  29\n13. Security Considerations . . . . . . . . . . . . . . . . . . .  30\n14. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  31\n15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  32\n  15.1.  Normative References . . . . . . . . . . . . . . . . . .  32\n  15.2.  Informative References . . . . . . . . . . . . . . . . .  34\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  35\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In order to verifiably validate the origin Autonomous Systems (ASes) and AS paths of BGP announcements, routers need a simple but reliable mechanism to receive cryptographically validated Resource Public Key Infrastructure (RPKI) [RFC6480] prefix origin data and router keys from a trusted cache. This document describes a protocol to deliver them. The design is intentionally constrained to be usable on much of the current generation of ISP router platforms.",
      "ja": "検証可能起源自律システム（ASの）とを検証するためにBGPアナウンスメントのパスは、ルータは、信頼できるキャッシュから暗号的に検証リソース公開鍵インフラストラクチャ（RPKI）[RFC6480]プレフィックス起点データおよびルータキーを受け取るために単純だが信頼性の高いメカニズムを必要とするAS 。この文書では、それらを提供するためのプロトコルを記述します。デザインは、意図的にISPルータプラットフォームの現在の世代の多くに使用できるように制約されています。"
    },
    {
      "indent": 3,
      "text": "This document updates [RFC6810].",
      "ja": "このドキュメントの更新[RFC6810]。"
    },
    {
      "indent": 3,
      "text": "Section 3 describes the deployment structure, and Section 4 then presents an operational overview. The binary payloads of the protocol are formally described in Section 5, and the expected Protocol Data Unit (PDU) sequences are described in Section 8. The transport protocol options are described in Section 9. Section 10 details how routers and caches are configured to connect and authenticate. Section 11 describes likely deployment scenarios. The traditional security and IANA considerations end the document.",
      "ja": "第3節では、展開の構造について説明し、第4節では、動作概要を示します。プロトコルのバイナリペイロードが正式セクション5に記載されており、予想されるプロトコルデータユニット（PDU）のシーケンスは、第9節にルータおよびキャッシュが接続するように構成されている方法10件の詳細を記載されている第8章トランスポート・プロトコル・オプションに記載されています。および認証します。 11節には、可能性の高い展開シナリオについて説明します。伝統的な安全保障とIANAの考慮事項は、文書を終了します。"
    },
    {
      "indent": 3,
      "text": "The protocol is extensible in order to support new PDUs with new semantics, if deployment experience indicates that they are needed. PDUs are versioned should deployment experience call for change.",
      "ja": "プロトコルは、展開の経験は、彼らが必要としていることを示している場合、新しいセマンティクスを持つ新しいPDUをサポートするために拡張可能です。 PDUは、変更のためにすべき展開の経験コールをバージョン管理されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 1,
      "text": "1.2. Changes from",
      "section_title": true,
      "ja": "1.2。からの変更点"
    },
    {
      "indent": 3,
      "text": "This section summarizes the significant changes between [RFC6810] and the protocol described in this document.",
      "ja": "このセクションでは、[RFC6810]の間で有意な変化と、この文書に記載されているプロトコルを要約します。"
    },
    {
      "indent": 3,
      "text": "o New Router Key PDU type (Section 5.10) added.",
      "ja": "O新しいルータのキーPDUタイプ（5.10節）を加えました。"
    },
    {
      "indent": 3,
      "text": "o Explicit timing parameters (Section 5.8, Section 6) added.",
      "ja": "O明示的なタイミング・パラメータ（第5.8項、第6項）を加えました。"
    },
    {
      "indent": 3,
      "text": "o Protocol version number incremented from 0 (zero) to 1 (one).",
      "ja": "Oプロトコルバージョン番号は1（1）に0（ゼロ）からインクリメント。"
    },
    {
      "indent": 3,
      "text": "o Protocol version number negotiation (Section 7) added.",
      "ja": "Oプロトコルバージョン番号のネゴシエーション（第7節）を加えました。"
    },
    {
      "indent": 0,
      "text": "2. Glossary",
      "section_title": true,
      "ja": "2.用語集"
    },
    {
      "indent": 3,
      "text": "The following terms are used with special meaning.",
      "ja": "以下の用語は、特別な意味で使用されています。"
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers at the IANA, Regional Internet Registries (RIRs), National Internet Registries (NIRs), and ISPs; see [RFC6481].",
      "ja": "グローバルRPKI：RPKIの正式なデータはIANA、地域インターネットレジストリ（RIRが）、国別インターネットレジストリ（NIRが）、やISPのサーバの分散セットで公開されています。 [RFC6481]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Cache: A cache is a coalesced copy of the published Global RPKI data, periodically fetched or refreshed, directly or indirectly, using the rsync protocol [RFC5781] or some successor. Relying Party software is used to gather and validate the distributed data of the RPKI into a cache. Trusting this cache further is a matter between the provider of the cache and a Relying Party.",
      "ja": "キャッシュ：キャッシュはrsyncのプロトコル[RFC5781]または一部の後継者を使用して、直接または間接的に、定期的にフェッチまたは更新、公表グローバルRPKIデータの合体コピーです。依拠当事者のソフトウェアは、キャッシュにRPKIの分散データを収集し、検証するために使用されます。さらにこのキャッシュを信頼するキャッシュのプロバイダと依拠当事者間の問題です。"
    },
    {
      "indent": 3,
      "text": "Serial Number: \"Serial Number\" is a 32-bit strictly increasing unsigned integer which wraps from 2^32-1 to 0. It denotes the logical version of a cache. A cache increments the value when it successfully updates its data from a parent cache or from primary RPKI data. While a cache is receiving updates, new incoming data and implicit deletes are associated with the new serial but MUST NOT be sent until the fetch is complete. A Serial Number is not commensurate between different caches or different protocol versions, nor need it be maintained across resets of the cache server. See [RFC1982] on DNS Serial Number Arithmetic for too much detail on the topic.",
      "ja": "シリアルナンバー：「シリアル番号」は、キャッシュの論理バージョンを表す0に2 ^ 32-1からラップ32ビットの厳密な増加の符号なし整数です。それが成功した親キャッシュからまたはプライマリRPKIデータからそのデータを更新するとキャッシュが値を増加させます。キャッシュが更新を受信して​​いる間、新しい着信データと暗黙の削除は、新しいシリアルに関連付けられているが、フェッチが完了するまで送ってはいけません。シリアル番号は、別のキャッシュまたは異なるプロトコルのバージョン間見合っていない、またそれは、キャッシュサーバのリセットしても維持される必要があります。トピックのあまり詳細のためにDNSのシリアル番号算術に[RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Session ID: When a cache server is started, it generates a Session ID to uniquely identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache.",
      "ja": "セッションID：キャッシュサーバを起動すると、それが一意にキャッシュのインスタンスを識別するために、キャッシュインスタンスが生成されることをシリアル番号のシーケンスにバインドするために、セッションIDを生成します。これは、ルータは、それが使用されるシリアル番号は、キャッシュのそれに見合っていることを知って失敗したセッションを再開することができます。"
    },
    {
      "indent": 3,
      "text": "Payload PDU: A payload PDU is a protocol message which contains data for use by the router, as opposed to a PDU which conveys the control mechanisms of this protocol. Prefixes and Router Keys are examples of payload PDUs.",
      "ja": "ペイロードPDU：ペイロードPDUは、このプロトコルの制御機構を搬送するPDUとは対照的に、ルータが使用するデータを含むプロトコルメッセージです。プレフィックスとルータのキーは、ペイロードPDUの例です。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Structure",
      "section_title": true,
      "ja": "3.展開構造"
    },
    {
      "indent": 3,
      "text": "Deployment of the RPKI to reach routers has a three-level structure as follows:",
      "ja": "次のようにルータに到達するRPKIの展開は3レベルの構造を有します："
    },
    {
      "indent": 3,
      "text": "Global RPKI: The authoritative data of the RPKI are published in a distributed set of servers at the IANA, RIRs, NIRs, and ISPs (see [RFC6481]).",
      "ja": "グローバルRPKI：RPKIの正式なデータはIANA、のRIR、のNIRにおけるサーバの分散セットに掲載されており、ISPが（参照[RFC6481]）。"
    },
    {
      "indent": 3,
      "text": "Local Caches: Local caches are a local set of one or more collected and verified caches of RPKI data. A Relying Party, e.g., router or other client, MUST have a trust relationship with, and a trusted transport channel to, any cache(s) it uses.",
      "ja": "ローカル・キャッシュ：ローカルキャッシュはRPKIデータの1つの以上の収集と検証キャッシュのローカルセットです。依拠当事者、例えば、ルータ、または他のクライアントとの信頼関係を持たなければならない、信頼できるトランスポート・チャネルが使用する任意のキャッシュ（複数可）、へ。"
    },
    {
      "indent": 3,
      "text": "Routers: A router fetches data from a local cache using the protocol described in this document. It is said to be a client of the cache. There MAY be mechanisms for the router to assure itself of the authenticity of the cache and to authenticate itself to the cache (see Section 9).",
      "ja": "ルータ：ルータは、この文書に記載のプロトコルを使用してローカルキャッシュからデータを取り出します。キャッシュのクライアントであると言われています。キャッシュの真正性そのものを保証するために、キャッシュに自分自身を認証するためにルータのためのメカニズムがある可能性があります（第9章を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4. Operational Overview",
      "section_title": true,
      "ja": "4.動作概要"
    },
    {
      "indent": 3,
      "text": "A router establishes and keeps open a connection to one or more caches with which it has client/server relationships. It is configured with a semi-ordered list of caches and establishes a connection to the most preferred cache, or set of caches, which accept the connections.",
      "ja": "ルータが確立され、それがクライアント/サーバー上の関係を有する1つの以上のキャッシュへの接続を開き続けます。これは、キャッシュの半順序リストで構成され、最も好ましくはキャッシュへの接続を確立し、または接続を受け入れるキャッシュの設定されています。"
    },
    {
      "indent": 3,
      "text": "The router MUST choose the most preferred, by configuration, cache or set of caches so that the operator may control load on their caches and the Global RPKI.",
      "ja": "オペレータはそれらのキャッシュおよびグローバル・RPKIの負荷を制御することができるように、ルータは、キャッシュの最も好ましい、コンフィギュレーションによって、キャッシュまたはセットを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Periodically, the router sends to the cache the most recent Serial Number for which it has received data from that cache, i.e., the router's current Serial Number, in the form of a Serial Query. When a router establishes a new session with a cache or wishes to reset a current relationship, it sends a Reset Query.",
      "ja": "定期的に、ルータはキャッシュにシリアルクエリの形で、それはそのキャッシュからデータを受信したために、最新のシリアル番号、すなわち、ルータの現在のシリアル番号を送信します。ルータはキャッシュを使用して新しいセッションを確立したり、現在の関係をリセットしたいときは、リセットクエリーを送信します。"
    },
    {
      "indent": 3,
      "text": "The cache responds to the Serial Query with all data changes which took place since the given Serial Number. This may be the null set, in which case the End of Data PDU (Section 5.8) is still sent. Note that the Serial Number comparison used to determine \"since the given Serial Number\" MUST take wrap-around into account; see [RFC1982].",
      "ja": "キャッシュは、指定されたシリアル番号以降に行われたすべてのデータ変更とシリアルクエリに応答します。これは、データPDU（セクション5.8）の端部がまだ送信される場合にはヌル集合であってもよいです。シリアル番号の比較は、「与えられたシリアル番号があるため、」考慮に入れ、ラップアラウンドを取る必要があります決定するために使用することに注意してください。 [RFC1982]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When the router has received all data records from the cache, it sets its current Serial Number to that of the Serial Number in the received End of Data PDU.",
      "ja": "ルータはキャッシュからすべてのデータレコードを受信したとき、それは、データPDUの受信エンドのシリアル番号のものに現在のシリアル番号を設定します。"
    },
    {
      "indent": 3,
      "text": "When the cache updates its database, it sends a Notify PDU to every currently connected router. This is a hint that now would be a good time for the router to poll for an update, but it is only a hint. The protocol requires the router to poll for updates periodically in any case.",
      "ja": "キャッシュがそのデータベースを更新するとき、それはすべての現在接続しているルータに通知PDUを送信します。これは今、ルータは、更新のためにポーリングするための良い時間になるヒントですが、それは単なるヒントです。プロトコルは、どのような場合には定期的にアップデートをポーリングするルータが必要です。"
    },
    {
      "indent": 3,
      "text": "Strictly speaking, a router could track a cache simply by asking for a complete data set every time it updates, but this would be very inefficient. The Serial-Number-based incremental update mechanism allows an efficient transfer of just the data records which have changed since the last update. As with any update protocol based on incremental transfers, the router must be prepared to fall back to a full transfer if for any reason the cache is unable to provide the necessary incremental data. Unlike some incremental transfer protocols, this protocol requires the router to make an explicit request to start the fallback process; this is deliberate, as the cache has no way of knowing whether the router has also established sessions with other caches that may be able to provide better service.",
      "ja": "厳密に言えば、ルータは単に完全なデータセットのために、それが更新されるたびに尋ねることによってキャッシュを追跡することもできますが、これは非常に非効率になります。シリアルナンバーベースの増分更新のメカニズムは、最後の更新以降に変更されただけのデータレコードを効率的に転送することができます。何らかの理由でキャッシュが必要なインクリメンタルデータを提供することができない場合、増分転送に基づく任意の更新プロトコルと同様に、ルータは、完全転送にフォールバックする準備をしなければなりません。いくつかの増分転送プロトコルとは異なり、このプロトコルは、フォールバックプロセスを開始するための明示的な要求をするためにルータが必要です。キャッシュは、ルータはまた、より良いサービスを提供することができるかもしれ他のキャッシュとのセッションを確立しているかどうかを知る方法がないので、これは、意図的です。"
    },
    {
      "indent": 3,
      "text": "As a cache server must evaluate certificates and ROAs (Route Origin Authorizations; see [RFC6480]), which are time dependent, servers' clocks MUST be correct to a tolerance of approximately an hour.",
      "ja": "キャッシュサーバは、証明書と資産収益率（ルート起源承認; [RFC6480]を参照）を評価しなければならないような時間に依存している、サーバの時計は約1時間の許容範囲に正しくなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Protocol Data Units (PDUs)",
      "section_title": true,
      "ja": "5.プロトコルデータユニット（PDU）"
    },
    {
      "indent": 3,
      "text": "The exchanges between the cache and the router are sequences of exchanges of the following PDUs according to the rules described in Section 8.",
      "ja": "キャッシュとルータとの間の交換は、セクション8に記載されたルールに従って、次のPDUの交流の配列です。"
    },
    {
      "indent": 3,
      "text": "Reserved fields (marked \"zero\" in PDU diagrams) MUST be zero on transmission and MUST be ignored on receipt.",
      "ja": "（PDU図に「ゼロ」と印を付けた）予約フィールドは、送信にゼロでなければならない、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. Fields of a PDU",
      "section_title": true,
      "ja": "5.1。 PDUのフィールド"
    },
    {
      "indent": 3,
      "text": "PDUs contain the following data elements:",
      "ja": "PDUは、次のデータ要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "Protocol Version: An 8-bit unsigned integer, currently 1, denoting the version of this protocol.",
      "ja": "プロトコルバージョン：このプロトコルのバージョンを示す8ビットの符号なし整数で、現在1、。"
    },
    {
      "indent": 3,
      "text": "PDU Type: An 8-bit unsigned integer, denoting the type of the PDU, e.g., IPv4 Prefix.",
      "ja": "PDUタイプ：8ビットの符号なし整数、例えば、IPv4のプレフィックスのPDUのタイプを示します。"
    },
    {
      "indent": 3,
      "text": "Serial Number: The Serial Number of the RPKI cache when this set of PDUs was received from an upstream cache server or gathered from the Global RPKI. A cache increments its Serial Number when completing a rigorously validated update from a parent cache or the Global RPKI.",
      "ja": "シリアル番号：PDUのこのセットは、上流のキャッシュサーバから受信またはグローバルRPKIから集めたRPKIキャッシュのシリアル番号。親キャッシュまたはグローバルRPKIから厳密に検証され、更新を完了すると、キャッシュは、そのシリアル番号をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "Session ID: A 16-bit unsigned integer. When a cache server is started, it generates a Session ID to identify the instance of the cache and to bind it to the sequence of Serial Numbers that cache instance will generate. This allows the router to restart a failed session knowing that the Serial Number it is using is commensurate with that of the cache. If, at any time after the protocol version has been negotiated (Section 7), either the router or the cache finds that the value of the Session ID is not the same as the other's, the party which detects the mismatch MUST immediately terminate the session with an Error Report PDU with code 0 (\"Corrupt Data\"), and the router MUST flush all data learned from that cache.",
      "ja": "セッションID：16ビット符号なし整数。キャッシュサーバが開始されると、それはキャッシュのインスタンスを識別し、キャッシュ・インスタンスが生成されることをシリアル番号のシーケンスにバインドするために、セッションIDを生成します。これは、ルータは、それが使用されるシリアル番号は、キャッシュのそれに見合っていることを知って失敗したセッションを再開することができます。ルータまたはキャッシュのどちらかが、セッションIDの値が他のと同じではないことを発見し、プロトコルのバージョンがネゴシエートされた後の任意の時点（第7節）で、場合、不一致を検出した当事者は、直ちにセッションを終えなければなりませんエラーでレポートコード0とPDU（「破損データ」）、およびルータがそのキャッシュから学んだすべてのデータをフラッシュする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that sessions are specific to a particular protocol version. That is, if a cache server supports multiple versions of this protocol, happens to use the same Session ID value for multiple protocol versions, and further happens to use the same Serial Number values for two or more sessions using the same Session ID but different Protocol Version values, the Serial Numbers are not commensurate. The full test for whether Serial Numbers are commensurate requires comparing Protocol Version, Session ID, and Serial Number. To reduce the risk of confusion, cache servers SHOULD NOT use the same Session ID across multiple protocol versions, but even if they do, routers MUST treat sessions with different Protocol Version fields as separate sessions even if they do happen to have the same Session ID.",
      "ja": "セッションは、特定のプロトコル・バージョンに固有であることに注意してください。キャッシュサーバは、このプロトコルの複数のバージョンをサポートし、複数のプロトコルバージョンで同じセッションIDの値を使用して発生し、さらに同じセッションIDが異なるプロトコルを使用して2つの以上のセッションのために同じシリアル番号の値を使用して発生した場合つまり、バージョン値は、シリアル番号が見合っていません。シリアル番号が見合っているかどうかのための完全なテストは、プロトコルバージョン、セッションID、およびシリアル番号を比較する必要があります。混乱のリスクを減らすために、キャッシュサーバは、複数のプロトコル・バージョン間で同じセッションIDを使用するべきではありませんが、彼らが行う場合でも、彼らは同じセッションIDを持って起こる場合でも、ルータは別々のセッションなど、異なるプロトコルバージョンフィールドとのセッションを扱わなければなりません。"
    },
    {
      "indent": 6,
      "text": "Should a cache erroneously reuse a Session ID so that a router does not realize that the session has changed (old Session ID and new Session ID have the same numeric value), the router may become confused as to the content of the cache. The time it takes the router to discover that it is confused will depend on whether the Serial Numbers are also reused. If the Serial Numbers in the old and new sessions are different enough, the cache will respond to the router's Serial Query with a Cache Reset, which will solve the problem. If, however, the Serial Numbers are close, the cache may respond with a Cache Response, which may not be enough to bring the router into sync. In such cases, it's likely but not certain that the router will detect some discrepancy between the state that the cache expects and its own state. For example, the Cache Response may tell the router to drop a record which the router does not hold or may tell the router to add a record which the router already has. In such cases, a router will detect the error and reset the session. The one case in which the router may stay out of sync is when nothing in the Cache Response contradicts any data currently held by the router.",
      "ja": "ルータは、セッションが変更されたことを認識しないように、キャッシュが誤って（古いセッションIDと新しいセッションIDが同じ数値を持つ）セッションIDを再利用する必要があり、ルータは、キャッシュの内容に関しては混乱してしまうことがあります。時間シリアル番号も再利用されているかどうかに依存します混乱していることを発見するためにルータをとります。古いものと新しいセッションでシリアル番号が十分に異なっている場合は、キャッシュが問題を解決するであろう、キャッシュのリセットとルータのシリアル・クエリに応答します。しかし、シリアル番号が接近している場合は、キャッシュが同期にルータをもたらすのに十分でない可能性がある、キャッシュレスポンスで応答することができます。このような場合には、ルータはキャッシュが期待する状態と、自身の状態の間にいくつかの不一致を検出する可能性が高いが、一定ではありません。例えば、キャッシュ応答は、ルータが保持していないか、ルータがすでに持っているレコードを追加するようにルータを教えてレコードを削除するには、ルータに伝えることがあります。このような場合には、ルータがエラーを検出し、セッションをリセットします。キャッシュ応答で何が現在ルータが保持している任意のデータと矛盾していない場合、ルータが同期して滞在できる、1ケースがあります。"
    },
    {
      "indent": 6,
      "text": "Using persistent storage for the Session ID or a clock-based scheme for generating Session IDs should avoid the risk of Session ID collisions.",
      "ja": "セッションIDやセッションIDを生成するためのクロックベースのスキームのための永続ストレージを使用すると、セッションIDの衝突の危険を避ける必要があります。"
    },
    {
      "indent": 6,
      "text": "The Session ID might be a pseudorandom value, a strictly increasing value if the cache has reliable storage, et cetera. A seconds-since-epoch timestamp value such as the POSIX time() function makes a good Session ID value.",
      "ja": "キャッシュは、信頼性の高いストレージを持っている場合、セッションIDは、エトセトラ、擬似ランダム値、厳密に増加する値であるかもしれません。そのようなPOSIX時間（）関数として秒-以来のエポックタイムスタンプ値が良いセッションIDの値になります。"
    },
    {
      "indent": 3,
      "text": "Length: A 32-bit unsigned integer which has as its value the count of the bytes in the entire PDU, including the 8 bytes of header which includes the length field.",
      "ja": "長さ：長さフィールドを含むヘッダの8つのバイトを含む、その値として全体のPDUのバイトカウントを有する32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Flags: The lowest-order bit of the Flags field is 1 for an announcement and 0 for a withdrawal. For a Prefix PDU (IPv4 or IPv6), the flag indicates whether this PDU announces a new right to announce the prefix or withdraws a previously announced right; a withdraw effectively deletes one previously announced Prefix PDU with the exact same Prefix, Length, Max-Len, and Autonomous System Number (ASN). Similarly, for a Router Key PDU, the flag indicates whether this PDU announces a new Router Key or deletes one previously announced Router Key PDU with the exact same AS Number, subjectKeyIdentifier, and subjectPublicKeyInfo.",
      "ja": "フラグ：Flagsフィールドの最下位ビットは、離脱用アナウンスを0 1です。プレフィックスPDU（IPv4またはIPv6）の場合は、フラグはこのPDUは、接頭辞を発表する新しい権利を発表または以前に発表された権利を撤回するかどうかを示します。 A効果的に引き出す一つは以前に全く同じプレフィックス長、最大レン、および自律システム番号（ASN）とプレフィックスPDUを発表削除します。同様に、ルーターキーPDUのために、フラグはこのPDUは、新しいルーターキーを発表または1つは、以前に番号、subjectKeyIdentifier、およびSubjectPublicKeyInfoでASまったく同じでルーターキーPDUを発表しまし削除するかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "The remaining bits in the Flags field are reserved for future use. In protocol version 1, they MUST be zero on transmission and MUST be ignored on receipt.",
      "ja": "Flagsフィールド内の残りのビットは将来の使用のために予約されています。プロトコルバージョン1では、それらは伝送にゼロでなければならない、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix Length: An 8-bit unsigned integer denoting the shortest prefix allowed by the Prefix element.",
      "ja": "プレフィックスの長さ：接頭辞要素によって許可さ最短プレフィックスを表す8ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Max Length: An 8-bit unsigned integer denoting the longest prefix allowed by the Prefix element. This MUST NOT be less than the Prefix Length element.",
      "ja": "最大長さ：プレフィックス要素で許可さ最長プレフィックスを表す8ビットの符号なし整数。これは、プレフィックス長要素以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix: The IPv4 or IPv6 prefix of the ROA.",
      "ja": "接頭辞：ROAのIPv4またはIPv6プレフィックス。"
    },
    {
      "indent": 3,
      "text": "Autonomous System Number: A 32-bit unsigned integer representing an ASN allowed to announce a prefix or associated with a router key.",
      "ja": "自律システム番号：接頭語を発表することができ、またはルータキーに関連付けられたASNを表す32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "Subject Key Identifier: 20-octet Subject Key Identifier (SKI) value of a router key, as described in [RFC6487].",
      "ja": "サブジェクト鍵識別子：[RFC6487]に記載されているように、ルータのキーの20オクテットサブジェクトキー識別子（SKI）値。"
    },
    {
      "indent": 3,
      "text": "Subject Public Key Info: A router key's subjectPublicKeyInfo value, as described in [RFC8208]. This is the full ASN.1 DER encoding of the subjectPublicKeyInfo, including the ASN.1 tag and length values of the subjectPublicKeyInfo SEQUENCE.",
      "ja": "サブジェクト公開鍵情報：[RFC8208]で説明したように、ルータのキーのSubjectPublicKeyInfoで値。これはSubjectPublicKeyInfoで配列のASN.1タグと長さ値を含むSubjectPublicKeyInfoでの完全なASN.1のDER符号化です。"
    },
    {
      "indent": 3,
      "text": "Refresh Interval: Interval between normal cache polls. See Section 6.",
      "ja": "通常のキャッシュポーリング間隔：インターバルを更新します。第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "Retry Interval: Interval between cache poll retries after a failed cache poll. See Section 6.",
      "ja": "失敗したキャッシュのポーリング後にキャッシュのポーリングの再試行間隔：インターバルを再試行してください。第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "Expire Interval: Interval during which data fetched from a cache remains valid in the absence of a successful subsequent cache poll. See Section 6.",
      "ja": "間隔を期限切れ：キャッシュからフェッチされたデータが成功し、その後のキャッシュの世論調査の不在下で有効なまま間隔その間。第6章を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2. Serial Notify",
      "section_title": true,
      "ja": "5.2。通知シリアル"
    },
    {
      "indent": 3,
      "text": "The cache notifies the router that the cache has new data.",
      "ja": "キャッシュは、キャッシュが新しいデータを持っているルータに通知します。"
    },
    {
      "indent": 3,
      "text": "The Session ID reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、シリアル番号が釣り合っているルータ、すなわち、キャッシュセッションが変更されていないと安心させます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a Serial Notify PDU, the router MAY issue an immediate Serial Query (Section 5.3) or Reset Query (Section 5.4) without waiting for the Refresh Interval timer (see Section 6) to expire.",
      "ja": "期限切れに（セクション6を参照）PDUを通知シリアルを受信すると、ルータはすぐにシリアルクエリ（5.3節）を発行したり、更新間隔タイマーを待たずにクエリ（5.4節）をリセットします。"
    },
    {
      "indent": 3,
      "text": "Serial Notify is the only message that the cache can send that is not in response to a message from the router.",
      "ja": "シリアル通知は、キャッシュがそのルータからのメッセージに応答しないで送信できるメッセージのみです。"
    },
    {
      "indent": 3,
      "text": "If the router receives a Serial Notify PDU during the initial startup period where the router and cache are still negotiating to agree on a protocol version, the router MUST simply ignore the Serial Notify PDU, even if the Serial Notify PDU is for an unexpected protocol version. See Section 7 for details.",
      "ja": "ルータはシリアルルータとキャッシュがまだプロトコルのバージョンに同意する交渉している初期起動期間中にPDUを通知受信した場合、ルータは単に予期しないプロトコルバージョンのためであるシリアルは、PDUを通知した場合でも、シリアルは、PDUを通知無視しなければなりません。詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    0     |                     |\n+-------------------------------------------+\n|                                           |\n|                Length=12                  |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3. Serial Query",
      "section_title": true,
      "ja": "5.3。シリアルクエリ"
    },
    {
      "indent": 3,
      "text": "The router sends a Serial Query to ask the cache for all announcements and withdrawals which have occurred since the Serial Number specified in the Serial Query.",
      "ja": "ルータは、シリアルクエリで指定されたシリアル番号以降に発生したすべてのアナウンスや引き出しのキャッシュを依頼するシリアルクエリを送信します。"
    },
    {
      "indent": 3,
      "text": "The cache replies to this query with a Cache Response PDU (Section 5.5) if the cache has a (possibly null) record of the changes since the Serial Number specified by the router, followed by zero or more payload PDUs and an End Of Data PDU (Section 5.8).",
      "ja": "キャッシュは、ゼロ以上のペイロードPDUおよびデータPDUの最後に続いて、ルータで指定されたシリアル番号からの変更の（nullの可能性）の記録を持っている場合は、キャッシュは、キャッシュレスポンスPDU（5.5節）で、このクエリに返信（セクション5.8）。"
    },
    {
      "indent": 3,
      "text": "When replying to a Serial Query, the cache MUST return the minimum set of changes needed to bring the router into sync with the cache. That is, if a particular prefix or router key underwent multiple changes between the Serial Number specified by the router and the cache's current Serial Number, the cache MUST merge those changes to present the simplest possible view of those changes to the router. In general, this means that, for any particular prefix or router key, the data stream will include at most one withdrawal followed by at most one announcement, and if all of the changes cancel out, the data stream will not mention the prefix or router key at all.",
      "ja": "シリアルクエリに返信すると、キャッシュはキャッシュと同期にルータをもたらすために必要な変更の最小セットを返さなければなりません。これは、特定のプレフィックスまたはルータキーはルータで指定されたシリアル番号とキャッシュの現在のシリアル番号との間に複数の変更を行った場合は、キャッシュがルータにそれらの変更の最も単純なビューを提示するためにそれらの変更をマージする必要があり、です。一般的に、これは、任意の特定のプレフィックスまたはルータのキーのために、データストリームは最大1件の発表が続く最大で1つの撤退が含まれ、すべての変更が相殺場合は、データ・ストリームは、プレフィックスまたはルーターに言及していないだろう、ということを意味しますすべてのキーを押します。"
    },
    {
      "indent": 3,
      "text": "The rationale for this approach is that the entire purpose of the RPKI-Router protocol is to offload work from the router to the cache, and it should therefore be the cache's job to simplify the change set, thus reducing work for the router.",
      "ja": "このアプローチの理論的根拠は、RPKI-Routerプロトコルの全体の目的は、キャッシュへのルータから作業をオフロードすることであるということであり、それゆえので、ルータのための作業を減らし、変更セットを簡素化するためにキャッシュの仕事でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the cache does not have the data needed to update the router, perhaps because its records do not go back to the Serial Number in the Serial Query, then it responds with a Cache Reset PDU (Section 5.9).",
      "ja": "キャッシュは、そのレコードはシリアルクエリでシリアル番号に戻っていないかもしれないので、ルータを更新するために必要なデータを持っていない場合、それはキャッシュPDUをリセットします（5.9節）で応答します。"
    },
    {
      "indent": 3,
      "text": "The Session ID tells the cache what instance the router expects to ensure that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "セッションIDは、ルータは、すなわち、キャッシュセッションが変更されていない、シリアル番号が釣り合っていることを確認するために期待するものインスタンスのキャッシュに指示します。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    1     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=12                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.4. Reset Query",
      "section_title": true,
      "ja": "5.4。検索条件をリセット"
    },
    {
      "indent": 3,
      "text": "The router tells the cache that it wants to receive the total active, current, non-withdrawn database. The cache responds with a Cache Response PDU (Section 5.5), followed by zero or more payload PDUs and an End of Data PDU (Section 5.8).",
      "ja": "ルータは、全活性、現在、非撤回データベースを受信したいキャッシュを伝えます。キャッシュは、ゼロ以上のペイロードPDUおよびデータPDU（第5.8節）の終了に続いてキャッシュ応答PDU（5.5節）、で応答します。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    2     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5. Cache Response",
      "section_title": true,
      "ja": "5.5。キャッシュレスポンス"
    },
    {
      "indent": 3,
      "text": "The cache responds to queries with zero or more payload PDUs. When replying to a Serial Query (Section 5.3), the cache sends the set of announcements and withdrawals that have occurred since the Serial Number sent by the client router. When replying to a Reset Query (Section 5.4), the cache sends the set of all data records it has; in this case, the withdraw/announce field in the payload PDUs MUST have the value 1 (announce).",
      "ja": "キャッシュは、ゼロ個以上のペイロードのPDUとの照会に応答します。シリアル・クエリー（5.3節）に返信すると、キャッシュは、クライアントルータによって送信されたシリアルナンバー以降に発生した発表や引き出しのセットを送信します。リセットクエリ（5.4節）に返信すると、キャッシュは、それが持っているすべてのデータレコードのセットを送信します。この場合には、撤回/ペイロードのPDUのフィールドをアナウンス（告知）値1を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "In response to a Reset Query, the new value of the Session ID tells the router the instance of the cache session for future confirmation. In response to a Serial Query, the Session ID being the same reassures the router that the Serial Numbers are commensurate, i.e., the cache session has not been changed.",
      "ja": "リセットクエリに応答して、セッションIDの新しい値は、ルータに、将来の確認のためのキャッシュセッションのインスタンスに指示します。シリアル・クエリに応答して、同じであるセッションIDは、シリアル番号が釣り合っているルータ、すなわち、キャッシュセッションが変更されていないと安心させます。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    3     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.6. IPv4 Prefix",
      "section_title": true,
      "ja": "5.6。 IPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    4     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=20                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |   0..32  |   0..32  |          |\n+-------------------------------------------+\n|                                           |\n|                IPv4 Prefix                |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The lowest-order bit of the Flags field is 1 for an announcement and 0 for a withdrawal.",
      "ja": "Flagsフィールドの最下位ビットは、離脱用アナウンスを0 1です。"
    },
    {
      "indent": 3,
      "text": "In the RPKI, nothing prevents a signing certificate from issuing two identical ROAs. In this case, there would be no semantic difference between the objects, merely a process redundancy.",
      "ja": "RPKIでは、何もは、2つの同一の資産収益率を発行してから署名証明書を妨げません。この場合、オブジェクト間の意味的な違い、単にプロセスの冗長性はないであろう。"
    },
    {
      "indent": 3,
      "text": "In the RPKI, there is also an actual need for what might appear to a router as identical IPvX PDUs. This can occur when an upstream certificate is being reissued or there is an address ownership transfer up the validation chain. The ROA would be identical in the router sense, i.e., have the same {Prefix, Len, Max-Len, ASN}, but it would have a different validation path in the RPKI. This is important to the RPKI but not to the router.",
      "ja": "RPKIでは、同じIPvXのPDUとしてルータに見えるかもしれないもののための実際の必要性も存在します。上流側の証明書を再発行しているか、検証チェーンアップアドレス所有権の移転がある場合に発生する可能性があります。 ROAがルータ意味で同一である、すなわち、同じ{プレフィックス、レン、最大レン、ASN}を有し、それはRPKIで異なる検証パスを有することになります。これは、RPKIにではなく、ルータに重要です。"
    },
    {
      "indent": 3,
      "text": "The cache server MUST ensure that it has told the router client to have one and only one IPvX PDU for a unique {Prefix, Len, Max-Len, ASN} at any one point in time. Should the router client receive an IPvX PDU with a {Prefix, Len, Max-Len, ASN} identical to one it already has active, it SHOULD raise a Duplicate Announcement Received error.",
      "ja": "キャッシュサーバは、それが時間内にいずれかの時点でユニーク{プレフィックス、レン、マックス・レン、ASN}のための、唯一のIPvX PDUを持っているルータのクライアントを語っていることを確認しなければなりません。ルータのクライアントが既にアクティブ有するものと同一{プレフィックス、レン、最大レン、ASN}とIPvX PDUを受信しなければならない、それは重複アナウンス受信したエラーを上げるべきです。"
    },
    {
      "indent": 0,
      "text": "5.7. IPv6 Prefix",
      "section_title": true,
      "ja": "5.7。 IPv6のプレフィックス"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    6     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=32                 |\n|                                           |\n+-------------------------------------------+\n|          |  Prefix  |   Max    |          |\n|  Flags   |  Length  |  Length  |   zero   |\n|          |  0..128  |  0..128  |          |\n+-------------------------------------------+\n|                                           |\n+---                                     ---+\n|                                           |\n+---            IPv6 Prefix              ---+\n|                                           |\n+---                                     ---+\n|                                           |\n+-------------------------------------------+\n|                                           |\n|         Autonomous System Number          |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Analogous to the IPv4 Prefix PDU, it has 96 more bits and no magic.",
      "ja": "IPv4のプレフィックスPDUに類似し、それは96ビット以上と魔法を有しています。"
    },
    {
      "indent": 0,
      "text": "5.8. End of Data",
      "section_title": true,
      "ja": "5.8。データの終わり"
    },
    {
      "indent": 3,
      "text": "The cache tells the router it has no more data for the request.",
      "ja": "キャッシュは、リクエストのためのデータがなくなるルータに指示します。"
    },
    {
      "indent": 3,
      "text": "The Session ID and Protocol Version MUST be the same as that of the corresponding Cache Response which began the (possibly null) sequence of payload PDUs.",
      "ja": "セッションIDとプロトコルバージョンは、ペイロードPDUの（nullの可能性）のシーケンスを開始し、対応するキャッシュレスポンスと同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Session ID      |\n|    1     |    7     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=24                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Serial Number               |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Refresh Interval             |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|               Retry Interval              |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Expire Interval              |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Refresh Interval, Retry Interval, and Expire Interval are all 32-bit elapsed times measured in seconds. They express the timing parameters which the cache expects the router to use in deciding when to send subsequent Serial Query or Reset Query PDUs to the cache. See Section 6 for an explanation of the use and the range of allowed values for these parameters.",
      "ja": "更新間隔、再試行間隔、および期限切れ間隔を秒単位で測定されたすべての32ビットの経過時間です。彼らは、キャッシュは、ルータが、その後のシリアルクエリを送信したり、キャッシュにクエリPDUをリセットするときを決定する際に使用する予定のタイミング・パラメータを表現します。使用の説明およびこれらのパラメータの許容値の範囲については、セクション6を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.9. Cache Reset",
      "section_title": true,
      "ja": "5.9。キャッシュのリセット"
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query informing the router that the cache cannot provide an incremental update starting from the Serial Number specified by the router. The router must decide whether to issue a Reset Query or switch to a different cache.",
      "ja": "キャッシュは、キャッシュがルータによって指定されたシリアル番号から始まる増分更新を提供できないルータを知らせるシリアルクエリに応答することができます。ルータは異なるキャッシュにリセットクエリまたはスイッチを発行するかどうかを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |         zero        |\n|    1     |    8     |                     |\n+-------------------------------------------+\n|                                           |\n|                 Length=8                  |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.10. Router Key",
      "section_title": true,
      "ja": "5.10。ルーターキー"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |          |          |\n| Version  |   Type   |   Flags  |   zero   |\n|    1     |    9     |          |          |\n+-------------------------------------------+\n|                                           |\n|                  Length                   |\n|                                           |\n+-------------------------------------------+\n|                                           |\n+---                                     ---+\n|          Subject Key Identifier           |\n+---                                     ---+\n|                                           |\n+---                                     ---+\n|                (20 octets)                |\n+---                                     ---+\n|                                           |\n+-------------------------------------------+\n|                                           |\n|                 AS Number                 |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|          Subject Public Key Info          |\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The lowest-order bit of the Flags field is 1 for an announcement and 0 for a withdrawal.",
      "ja": "Flagsフィールドの最下位ビットは、離脱用アナウンスを0 1です。"
    },
    {
      "indent": 3,
      "text": "The cache server MUST ensure that it has told the router client to have one and only one Router Key PDU for a unique {SKI, ASN, Subject Public Key} at any one point in time. Should the router client receive a Router Key PDU with a {SKI, ASN, Subject Public Key} identical to one it already has active, it SHOULD raise a Duplicate Announcement Received error.",
      "ja": "キャッシュサーバは、それが時間内にいずれかの点でユニーク{SKI、ASN、サブジェクト公開鍵}のための、唯一のルーターキーPDUを持っているルータのクライアントを語っていることを確認しなければなりません。ルータのクライアントがすでにアクティブ持っているものと同じ{SKI、ASN、サブジェクト公開鍵}とルーターキーPDUを受信する必要があり、それはエラーを受け取っ重複お知らせを上げるべきです。"
    },
    {
      "indent": 3,
      "text": "Note that a particular ASN may appear in multiple Router Key PDUs with different Subject Public Key values, while a particular Subject Public Key value may appear in multiple Router Key PDUs with different ASNs. In the interest of keeping the announcement and withdrawal semantics as simple as possible for the router, this protocol makes no attempt to compress either of these cases.",
      "ja": "特定のサブジェクト公開鍵値が異なるのASNと複数のルータキーのPDUに表示されるかもしれない特定のASNは、異なるサブジェクト公開鍵値を使用して複数のルーターキーのPDUに表示されることに留意されたいです。ルータのためできるだけ単純発表し、撤退のセマンティクスを維持するの関心では、このプロトコルは、これらの例のいずれかを圧縮を試みません。"
    },
    {
      "indent": 3,
      "text": "Also note that it is possible, albeit very unlikely, for multiple distinct Subject Public Key values to hash to the same SKI. For this reason, implementations MUST compare Subject Public Key values as well as SKIs when detecting duplicate PDUs.",
      "ja": "複数の別個のサブジェクト公開鍵値が同じSKIにハッシュするためにも、非常に低いとはいえ、それが可能であることに注意してください。重複したPDUを検出したときに、このような理由から、実装はサブジェクト公開鍵の値だけでなく、スキーを比較しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.11. Error Report",
      "section_title": true,
      "ja": "5.11。エラーレポート"
    },
    {
      "indent": 3,
      "text": "This PDU is used by either party to report an error to the other.",
      "ja": "このPDUは、他にエラーを報告するために、いずれかの当事者によって使用されます。"
    },
    {
      "indent": 3,
      "text": "Error reports are only sent as responses to other PDUs, not to report errors in Error Report PDUs.",
      "ja": "エラーレポートはのみエラーレポートのPDUにエラーを報告しないように、他のPDUへの応答として送信されます。"
    },
    {
      "indent": 3,
      "text": "Error codes are described in Section 12.",
      "ja": "エラーコードは、セクション12で説明されています。"
    },
    {
      "indent": 3,
      "text": "If the error is generic (e.g., \"Internal Error\") and not associated with the PDU to which it is responding, the Erroneous PDU field MUST be empty and the Length of Encapsulated PDU field MUST be zero.",
      "ja": "エラーが一般的な場合（例えば、「内部エラー」）、それが応答されたPDUに関連付けられていない、誤ったPDUのフィールドが空でなければなりません、そして、カプセル化されたPDUのフィールドの長さはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An Error Report PDU MUST NOT be sent for an Error Report PDU. If an erroneous Error Report PDU is received, the session SHOULD be dropped.",
      "ja": "エラーレポートPDUは、エラーレポートPDUのために送ってはいけません。誤ったエラーレポートPDUを受信した場合、セッションは破棄されるべきです。"
    },
    {
      "indent": 3,
      "text": "If the error is associated with a PDU of excessive length, i.e., too long to be any legal PDU other than another Error Report, or a possibly corrupt length, the Erroneous PDU field MAY be truncated.",
      "ja": "エラーは、過度の長さのPDUに関連付けられている場合、すなわち、別のエラーレポート、または多分壊れ長さ以外の任意の法的なPDUであるには余りにも長い間、誤ったPDUフィールドが切り捨てられる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The diagnostic text is optional; if not present, the Length of Error Text field MUST be zero. If error text is present, it MUST be a string in UTF-8 encoding (see [RFC3629]).",
      "ja": "診断テキストはオプションです。存在しない場合は、エラーテキストフィールドの長さはゼロでなければなりません。エラーテキストが存在する場合、それはUTF-8エンコーディングの文字列でなければなりません（[RFC3629]を参照）。"
    },
    {
      "indent": 3,
      "text": "0          8          16         24        31\n.-------------------------------------------.\n| Protocol |   PDU    |                     |\n| Version  |   Type   |     Error Code      |\n|    1     |    10    |                     |\n+-------------------------------------------+\n|                                           |\n|                  Length                   |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|       Length of Encapsulated PDU          |\n|                                           |\n+-------------------------------------------+\n|                                           |\n~               Erroneous PDU               ~\n|                                           |\n+-------------------------------------------+\n|                                           |\n|           Length of Error Text            |\n|                                           |\n+-------------------------------------------+\n|                                           |\n|              Arbitrary Text               |\n|                    of                     |\n~          Error Diagnostic Message         ~\n|                                           |\n`-------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6. Protocol Timing Parameters",
      "section_title": true,
      "ja": "6.プロトコルのタイミングパラメータ"
    },
    {
      "indent": 3,
      "text": "Since the data the cache distributes via the RPKI-Router protocol are retrieved from the Global RPKI system at intervals which are only known to the cache, only the cache can really know how frequently it makes sense for the router to poll the cache, or how long the data are likely to remain valid (or, at least, unchanged). For this reason, as well as to allow the cache some control over the load placed on it by its client routers, the End Of Data PDU includes three values that allow the cache to communicate timing parameters to the router:",
      "ja": "キャッシュはRPKI-Routerプロトコルを経由して配布したデータのみをキャッシュに知られている間隔でグローバルRPKIシステムから取得されているので、唯一のキャッシュは実際にそれがキャッシュをポーリングするルータのために理にかなっている頻度を知っている、またはどのようにすることができます長いデータは、有効な（あるいは、少なくとも、変わらず）残る可能性が高いです。このような理由からだけでなく、キャッシュにそのクライアント・ルータで、それにかかる負荷をある程度制御できるようにするには、データPDUの最後には、キャッシュがルータにタイミングパラメータを通信することを可能にする3つの値が含まれています。"
    },
    {
      "indent": 3,
      "text": "Refresh Interval: This parameter tells the router how long to wait before next attempting to poll the cache and between subsequent attempts, using a Serial Query or Reset Query PDU. The router SHOULD NOT poll the cache sooner than indicated by this parameter. Note that receipt of a Serial Notify PDU overrides this interval and suggests that the router issue an immediate query without waiting for the Refresh Interval to expire. Countdown for this timer starts upon receipt of the containing End Of Data PDU.",
      "ja": "更新間隔：このパラメータは、次のキャッシュをポーリングし、それ以降の試行の間、シリアルクエリを使用して、またはクエリPDUをリセットしようとする前に待機する時間をルータに指示します。ルータは、このパラメータで指定されたよりも早くキャッ​​シュをポーリングすべきではありません。シリアルの受信がPDUはこの間隔を上書きし、期限切れに更新間隔を待たずに、ルータの問題の即時クエリことを示唆している通知に注意してください。このタイマーのカウントダウンは、データPDUの含有末端の受信時に開始します。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 1 second.",
      "ja": "最小許容値：1秒。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 86400 seconds (1 day).",
      "ja": "最大許容値：86400秒（1日）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 3600 seconds (1 hour).",
      "ja": "推奨デフォルト：3600秒（1時間）。"
    },
    {
      "indent": 3,
      "text": "Retry Interval: This parameter tells the router how long to wait before retrying a failed Serial Query or Reset Query. The router SHOULD NOT retry sooner than indicated by this parameter. Note that a protocol version mismatch overrides this interval: if the router needs to downgrade to a lower protocol version number, it MAY send the first Serial Query or Reset Query immediately. Countdown for this timer starts upon failure of the query and restarts after each subsequent failure until a query succeeds.",
      "ja": "間隔を再試行：このパラメータは、再試行する前に失敗したシリアルクエリを待つか、検索条件をリセットするにはどのくらいのルータに指示します。ルータは、このパラメータで指定されたよりも早く再試行すべきではありません。ルータは、下位プロトコルのバージョン番号にダウングレードする必要がある場合、それは最初のシリアルクエリを送信したり、すぐに検索条件をリセットしてもよい（MAY）：プロトコルのバージョンの不一致がこの間隔を上書きすることに注意してください。このタイマーのカウントダウンは、クエリが失敗したときに開始され、クエリが成功するまで、後続の各障害発生後に再起動します。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 1 second.",
      "ja": "最小許容値：1秒。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 7200 seconds (2 hours).",
      "ja": "最大許容値：7200秒（2時間）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 600 seconds (10 minutes).",
      "ja": "推奨デフォルト：600秒（10分）。"
    },
    {
      "indent": 3,
      "text": "Expire Interval: This parameter tells the router how long it can continue to use the current version of the data while unable to perform a successful subsequent query. The router MUST NOT retain the data past the time indicated by this parameter. Countdown for this timer starts upon receipt of the containing End Of Data PDU.",
      "ja": "間隔を期限切れ：このパラメータはできない成功、その後のクエリを実行する一方で、それはデータの現在のバージョンを使用し続けることができますどのくらいのルータに指示します。ルータは、このパラメータで指定された時間を過ぎたデータを保持してはなりません。このタイマーのカウントダウンは、データPDUの含有末端の受信時に開始します。"
    },
    {
      "indent": 6,
      "text": "Minimum allowed value: 600 seconds (10 minutes).",
      "ja": "最小許容値：600秒（10分）。"
    },
    {
      "indent": 6,
      "text": "Maximum allowed value: 172800 seconds (2 days).",
      "ja": "最大許容値：172800秒（2日）。"
    },
    {
      "indent": 6,
      "text": "Recommended default: 7200 seconds (2 hours).",
      "ja": "推奨デフォルト：7200秒（2時間）。"
    },
    {
      "indent": 3,
      "text": "If the router has never issued a successful query against a particular cache, it SHOULD retry periodically using the default Retry Interval, above.",
      "ja": "ルータが特定のキャッシュに対して成功したクエリを発行したことがない場合、それは上記の、デフォルトの再試行間隔を使用して、定期的に再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Caches MUST set Expire Interval to a value larger than either Refresh Interval or Retry Interval.",
      "ja": "キャッシュは、更新間隔や再試行間隔のいずれよりも大きな値に間隔を期限切れに設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Version Negotiation",
      "section_title": true,
      "ja": "7.プロトコルバージョンネゴシエーション"
    },
    {
      "indent": 3,
      "text": "A router MUST start each transport connection by issuing either a Reset Query or a Serial Query. This query will tell the cache which version of this protocol the router implements.",
      "ja": "ルータがリセットクエリまたはシリアルクエリのいずれかを発行することにより、各トランスポート接続を開始する必要があります。このクエリは、このプロトコルのバージョン、ルータの実装キャッシュを教えてくれます。"
    },
    {
      "indent": 3,
      "text": "If a cache which supports version 1 receives a query from a router which specifies version 0, the cache MUST downgrade to protocol version 0 [RFC6810] or send a version 1 Error Report PDU with Error Code 4 (\"Unsupported Protocol Version\") and terminate the connection.",
      "ja": "バージョン1をサポートしているキャッシュは、バージョン0を指定し、ルータからのクエリを受信した場合、キャッシュはプロトコルバージョン0 [RFC6810]にダウングレードするか、エラーコード4（「サポートされていないプロトコルバージョン」）と、バージョン1つのエラーレポートPDUを送信し終えなければなりません接続。"
    },
    {
      "indent": 3,
      "text": "If a router which supports version 1 sends a query to a cache which only supports version 0, one of two things will happen:",
      "ja": "バージョン1をサポートしているルータは唯一のバージョン0をサポートしてキャッシュにクエリを送信した場合、2つのいずれかの処理が行われます。"
    },
    {
      "indent": 3,
      "text": "1. The cache may terminate the connection, perhaps with a version 0 Error Report PDU. In this case, the router MAY retry the connection using protocol version 0.",
      "ja": "1.キャッシュは、おそらくバージョン0エラーレポートPDUと、接続を終了することができます。この場合、ルータはプロトコルバージョン0を使用して接続を再試行することができます。"
    },
    {
      "indent": 3,
      "text": "2. The cache may reply with a version 0 response. In this case, the router MUST either downgrade to version 0 or terminate the connection.",
      "ja": "2.キャッシュは、バージョン0レスポンスで応答することができます。この場合、ルータは、ダウングレードバージョン0またはいずれかの接続を終了しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In any of the downgraded combinations above, the new features of version 1 will not be available, and all PDUs will have 0 in their version fields.",
      "ja": "上記の格下げの組み合わせのいずれかでは、バージョン1の新機能は使用できなくなり、すべてのPDUは、彼らのバージョンフィールドに0を持つことになります。"
    },
    {
      "indent": 3,
      "text": "If either party receives a PDU containing an unrecognized Protocol Version (neither 0 nor 1) during this negotiation, it MUST either downgrade to a known version or terminate the connection, with an Error Report PDU unless the received PDU is itself an Error Report PDU.",
      "ja": "いずれかの当事者がこのネゴシエーション中（0でも1）認識されていないプロトコルバージョンを含むPDUを受信した場合、それはどちらか知らバージョンへのダウングレードや、受信したPDUがエラーレポートPDUは、それ自体でない限り、エラーレポートPDUとの接続を、終えなければなりません。"
    },
    {
      "indent": 3,
      "text": "The router MUST ignore any Serial Notify PDUs it might receive from the cache during this initial startup period, regardless of the Protocol Version field in the Serial Notify PDU. Since Session ID and Serial Number values are specific to a particular protocol version, the values in the notification are not useful to the router. Even if these values were meaningful, the only effect that processing the notification would have would be to trigger exactly the same Reset Query or Serial Query that the router has already sent as part of the not-yet-complete version negotiation process, so there is nothing to be gained by processing notifications until version negotiation completes.",
      "ja": "ルータは関係なく、プロトコルバージョンフィールドのPDUを通知シリアルで、それはこの最初の起動期間中にキャッシュから受け取ることがありますPDUを通知する任意のシリアルを無視しなければなりません。セッションIDとシリアル番号の値は、特定のプロトコル・バージョンに固有であるので、通知の値はルータに有用ではありません。これらの値は有意義であったとしても、通知を処理する必要がありますのみ効果がトリガすることとまったく同じクエリまたはルーターがまだ未完全なバージョンネゴシエーションプロセスの一部として送信されたことをシリアルクエリので、そこにあるのリセットバージョン交渉が完了するまで、通知を処理することによって得られるものは何もありません。"
    },
    {
      "indent": 3,
      "text": "Caches SHOULD NOT send Serial Notify PDUs before version negotiation completes. Routers, however, MUST handle such notifications (by ignoring them) for backwards compatibility with caches serving protocol version 0.",
      "ja": "キャッシュは、バージョン交渉が完了する前にPDUを知らせシリアル送るべきではありません。ルータは、しかし、プロトコルバージョン0にサービスを提供するキャッシュとの後方互換性のために（それらを無視して）、そのような通知を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the cache and router have agreed upon a Protocol Version via the negotiation process above, that version is stable for the life of the session. See Section 5.1 for a discussion of the interaction between Protocol Version and Session ID.",
      "ja": "キャッシュとルータは上記の交渉プロセスを経てプロトコルバージョンに合意したら、そのバージョンは、セッションの生活のために安定しています。プロトコルバージョンとセッションIDの間の相互作用についての説明は、5.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If either party receives a PDU for a different Protocol Version once the above negotiation completes, that party MUST drop the session; unless the PDU containing the unexpected Protocol Version was itself an Error Report PDU, the party dropping the session SHOULD send an Error Report with an error code of 8 (\"Unexpected Protocol Version\").",
      "ja": "上記のネゴシエーションが完了すると、いずれかの当事者が、異なるプロトコルバージョンのためのPDUを受信した場合、その当事者は、セッションを削除する必要があります。予期しないプロトコルバージョンを含むPDUは、エラーレポートPDU自体でない限り、セッションをドロップする当事者は8のエラーコード（「予期しないプロトコルバージョン」）とのエラー報告を送信すべきです。"
    },
    {
      "indent": 0,
      "text": "8. Protocol Sequences",
      "section_title": true,
      "ja": "8.プロトコルシーケンス"
    },
    {
      "indent": 3,
      "text": "The sequences of PDU transmissions fall into four conversations as follows:",
      "ja": "次のようにPDU送信のシーケンスは4人の会話に分類されます。"
    },
    {
      "indent": 0,
      "text": "8.1. Start or Restart",
      "section_title": true,
      "ja": "8.1。開始または再起動"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <----- Reset Query -------- | R requests data (or Serial Query)\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When a transport connection is first established, the router MUST send either a Reset Query or a Serial Query. A Serial Query would be appropriate if the router has significant unexpired data from a broken session with the same cache and remembers the Session ID of that session, in which case a Serial Query containing the Session ID from the previous session will allow the router to bring itself up to date while ensuring that the Serial Numbers are commensurate and that the router and cache are speaking compatible versions of the protocol. In all other cases, the router lacks the necessary data for fast resynchronization and therefore MUST fall back to a Reset Query.",
      "ja": "トランスポート接続が最初に確立されると、ルータはリセットクエリまたはシリアルクエリのいずれかを送らなければなりません。ルータは同じキャッシュを持つ壊れたセッションからの重要な期限切れ前のデータを持っているし、前のセッションからセッションIDを含むシリアルクエリは、ルータが持参することができます。その場合には、そのセッションのセッションIDを、覚えている場合、シリアルQueryが適切であろうそれ自体は最新のシリアル番号は、相応のルータとキャッシュは、プロトコルの互換性のあるバージョンを話しているということであることを保証しながら。他のすべての例では、ルータは、高速再同期のために必要なデータが欠如しているため、バックリセットクエリに入らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Reset Query sequence is also used when the router receives a Cache Reset, chooses a new cache, or fears that it has otherwise lost its way.",
      "ja": "ルータはキャッシュのリセットを受信したときにリセットクエリー配列も使用され、新しいキャッシュ、またはそれ以外の道を失ってしまったという恐れを選択します。"
    },
    {
      "indent": 3,
      "text": "See Section 7 for details on version negotiation.",
      "ja": "バージョン交渉の詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep the data necessary to generate incremental updates, a router MUST send either a Serial Query or a Reset Query periodically. This also acts as a keep-alive at the application layer. See Section 6 for details on the required polling frequency.",
      "ja": "キャッシュは、増分更新を生成するために必要なデータを保持しなければならない時間の長さを制限するには、ルータはシリアルクエリまたは定期的にリセットクエリのいずれかを送らなければなりません。また、これはキープアライブアプリケーション層での役割を果たします。必要なポーリング頻度の詳細については、第6章を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.2. Typical Exchange",
      "section_title": true,
      "ja": "8.2。典型的な交流"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | -------- Notify ----------> |  (optional)\n  |                             |\n  | <----- Serial Query ------- | R requests data\n  |                             |\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The cache server SHOULD send a Notify PDU with its current Serial Number when the cache's serial changes, with the expectation that the router MAY then issue a Serial Query earlier than it otherwise might. This is analogous to DNS NOTIFY in [RFC1996]. The cache MUST rate-limit Serial Notifies to no more frequently than one per minute.",
      "ja": "期待とキャッシュのシリアルの変更は、ルータはその後、以前のそれはそうかもしれないよりシリアルクエリを発行することができることと、キャッシュサーバは、現在のシリアル番号を通知PDUを送信すべきです。 [RFC1996]でNOTIFYこれはDNSに似ています。キャッシュは、レートを制限しなければならないシリアルに通知を毎分なしよりも頻繁にものに。"
    },
    {
      "indent": 3,
      "text": "When the transport layer is up and either a timer has gone off in the router or the cache has sent a Notify PDU, the router queries for new data by sending a Serial Query, and the cache sends all data newer than the serial in the Serial Query.",
      "ja": "トランスポート層がアップしているとすると、タイマーのいずれかがルータでオフになったか、キャッシュがシリアルクエリを送信することによって、PDU、新しいデータのためのルータのクエリを通知送信した、とキャッシュはシリアルシリアルよりもすべてのデータの新しい送信しますクエリ。"
    },
    {
      "indent": 3,
      "text": "To limit the length of time a cache must keep old withdraws, a router MUST send either a Serial Query or a Reset Query periodically. See Section 6 for details on the required polling frequency.",
      "ja": "キャッシュが古い退避を維持しなければならない時間の長さを制限するには、ルータはシリアルクエリまたは定期的にリセットクエリのいずれかを送らなければなりません。必要なポーリング頻度の詳細については、第6章を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.3. No Incremental Update Available",
      "section_title": true,
      "ja": "8.3。利用可能な増分更新しません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Serial Query ------ | R requests data\n  | ------- Cache Reset ------> | C cannot supply update\n  |                             |   from specified serial\n  | <------ Reset Query ------- | R requests new data\n  | ----- Cache Response -----> | C confirms request\n  | ------- Payload PDU ------> | C sends zero or more\n  | ------- Payload PDU ------> |   IPv4 Prefix, IPv6 Prefix,\n  | ------- Payload PDU ------> |   or Router Key PDUs\n  | ------- End of Data ------> | C sends End of Data\n  |                             |   and sends new serial\n  ~                             ~",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The cache may respond to a Serial Query with a Cache Reset, informing the router that the cache cannot supply an incremental update from the Serial Number specified by the router. This might be because the cache has lost state, or because the router has waited too long between polls and the cache has cleaned up old data that it no longer believes it needs, or because the cache has run out of storage space and had to expire some old data early. Regardless of how this state arose, the cache replies with a Cache Reset to tell the router that it cannot honor the request. When a router receives this, the router SHOULD attempt to connect to any more-preferred caches in its cache list. If there are no more-preferred caches, it MUST issue a Reset Query and get an entire new load from the cache.",
      "ja": "キャッシュは、キャッシュがルータによって指定されたシリアル番号から増分更新を供給することはできませんルータを知らせる、キャッシュのリセット付きシリアルクエリに応答することができます。キャッシュが状態を失った、またはルータがポーリングの間であまりにも長い間待っていたとしているので、キャッシュが、それはもはやそれは必要、またはキャッシュがストレージスペースが不足し、期限切れにしなければならなかったので、信じていないことを古いデータをクリーンアップしているので、これがあるかもしれません初期のいくつかの古いデータ。かかわらず、この状態が生じたかの、キャッシュは、要求を尊重することはできませんルータを伝えるためにキャッシュのリセットで応答します。ルータはこれを受信すると、ルータはそのキャッシュリスト内の任意のより優先キャッシュに接続しようとすべきです。これ以上の優先キャッシュがある場合、それはリセットクエリを発行し、キャッシュから全体の新しいロードを取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4. Cache Has No Data Available",
      "section_title": true,
      "ja": "8.4。キャッシュが利用可能なデータがありません"
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Serial Query ------ | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cache                         Router\n  ~                             ~\n  | <------ Reset Query ------- | R requests data\n  | ---- Error Report PDU ----> | C No Data Available\n  ~                             ~",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The cache may respond to either a Serial Query or a Reset Query informing the router that the cache cannot supply any update at all. The most likely cause is that the cache has lost state, perhaps due to a restart, and has not yet recovered. While it is possible that a cache might go into such a state without dropping any of its active sessions, a router is more likely to see this behavior when it initially connects and issues a Reset Query while the cache is still rebuilding its database.",
      "ja": "キャッシュは、キャッシュがまったく更新を供給することができませんルータを知らせるシリアル照会またはリセットクエリのいずれかに応答することができます。最も可能性の高い原因は、キャッシュがおそらく再起動するには、状態を失った、とまだ回復していないということです。それはキャッシュがアクティブなセッションのいずれかを落とすことなく、そのような状態になるかもしれないことは可能ですが、ルータはそれが最初に接続し、キャッシュがまだそのデータベースを再構築している間にリセットクエリを発行した場合、この動作を参照してくださいする可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "When a router receives this kind of error, the router SHOULD attempt to connect to any other caches in its cache list, in preference order. If no other caches are available, the router MUST issue periodic Reset Queries until it gets a new usable load from the cache.",
      "ja": "ルータは、この種のエラーを受信した場合、ルータは優先順に、そのキャッシュリスト内の他のキャッシュに接続しようとすべきです。他のキャッシュが用意されていない場合は、キャッシュから新しい使用可能な負荷を取得するまで、ルータは定期的にリセットクエリを発行しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Transport",
      "section_title": true,
      "ja": "9.交通"
    },
    {
      "indent": 3,
      "text": "The transport-layer session between a router and a cache carries the binary PDUs in a persistent session.",
      "ja": "ルータとキャッシュとの間のトランスポート層セッションは、永続的セッション内のバイナリPDUを運びます。"
    },
    {
      "indent": 3,
      "text": "To prevent cache spoofing and DoS attacks by illegitimate routers, it is highly desirable that the router and the cache be authenticated to each other. Integrity protection for payloads is also desirable to protect against monkey-in-the-middle (MITM) attacks. Unfortunately, there is no protocol to do so on all currently used platforms. Therefore, as of the writing of this document, there is no mandatory-to-implement transport which provides authentication and integrity protection.",
      "ja": "違法なルータによってキャッシュスプーフィングやDoS攻撃を防ぐためには、ルータとキャッシュが相互に認証することが非常に望ましいです。ペイロードのための完全性保護もサル・イン・ザ・ミドル（MITM）攻撃から保護することが望ましいです。残念ながら、すべての現在使用のプラットフォーム上でそうするプロトコルはありません。したがって、この文書の執筆時点で、認証と完全性保護を提供して何の実装に必須の輸送はありません。"
    },
    {
      "indent": 3,
      "text": "To reduce exposure to dropped but non-terminated sessions, both caches and routers SHOULD enable keep-alives when available in the chosen transport protocol.",
      "ja": "とき選択したトランスポートプロトコルで利用可能なドロップが、非終了したセッションへの露出を減らすために、キャッシュとルータの両方がキープアライブを有効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that, when the TCP Authentication Option (TCP-AO) [RFC5925] is available on all platforms deployed by operators, it will become the mandatory-to-implement transport.",
      "ja": "TCP認証オプション（TCP-AO）[RFC5925]は事業者が配置されているすべてのプラットフォーム上で利用可能になったとき、それは実装に必須の輸送となり、ことが期待されます。"
    },
    {
      "indent": 3,
      "text": "Caches and routers MUST implement unprotected transport over TCP using a port, rpki-rtr (323); see Section 14. Operators SHOULD use procedural means, e.g., access control lists (ACLs), to reduce the exposure to authentication issues.",
      "ja": "キャッシュとルータはポート、RPKI-RTR（323）を使用して、TCP上で保護されていないトランスポートを実装しなければなりません。 14.オペレータは認証の問題への露出を減らすために、例えば、アクセス制御リスト（ACL）の手続き手段を使用すべきであるセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "If unprotected TCP is the transport, the cache and routers MUST be on the same trusted and controlled network.",
      "ja": "保護されていないTCPが輸送された場合は、キャッシュおよびルータは、同じ信頼され、制御ネットワーク上にある必要があります。"
    },
    {
      "indent": 3,
      "text": "If available to the operator, caches and routers MUST use one of the following more protected protocols:",
      "ja": "オペレータが利用可能な場合は、キャッシュおよびルータは、次のより多くの保護されたプロトコルのいずれかを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers SHOULD use TCP-AO transport [RFC5925] over the rpki-rtr port.",
      "ja": "OキャッシュとルータはRPKI-RTRポートを介してTCP-AOの輸送[RFC5925]を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use Secure Shell version 2 (SSHv2) transport [RFC4252] using the normal SSH port. For an example, see Section 9.1.",
      "ja": "Oキャッシュとルータは、通常SSHポートを使用して、セキュアシェルバージョン2（SSHv2の）輸送[RFC4252]を使用するかもしれ。たとえば、9.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use TCP MD5 transport [RFC2385] using the rpki-rtr port. Note that TCP MD5 has been obsoleted by TCP-AO [RFC5925].",
      "ja": "OキャッシュおよびルータはRPKI-RTRポートを使用してTCP MD5の輸送[RFC2385]を使用するかもしれません。 TCP MD5は、TCP-AO [RFC5925]で廃止されたことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use TCP over IPsec transport [RFC4301] using the rpki-rtr port.",
      "ja": "OキャッシュおよびルータはRPKI-RTRポートを使用してIPsecトランスポート[RFC4301]の上にTCPを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Caches and routers MAY use Transport Layer Security (TLS) transport [RFC5246] using port rpki-rtr-tls (324); see Section 14.",
      "ja": "Oキャッシュおよびルータは、ポートRPKI-RTR-TLS（324）を使用して、トランスポート層セキュリティ（TLS）の輸送[RFC5246]を使用することができます。第14章を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. SSH Transport",
      "section_title": true,
      "ja": "9.1。 SSHトランスポート"
    },
    {
      "indent": 3,
      "text": "To run over SSH, the client router first establishes an SSH transport connection using the SSHv2 transport protocol, and the client and server exchange keys for message integrity and encryption. The client then invokes the \"ssh-userauth\" service to authenticate the application, as described in the SSH authentication protocol [RFC4252]. Once the application has been successfully authenticated, the client invokes the \"ssh-connection\" service, also known as the SSH connection protocol.",
      "ja": "SSH上で実行するには、クライアントルータは、最初のSSHv2トランスポートプロトコル、およびメッセージの整合性および暗号化のために、クライアントとサーバーの交換キーを使用してSSHトランスポート接続を確立します。クライアントは、次に、SSH認証プロトコル[RFC4252]に記載されているように、アプリケーションを認証するために、「SSH-USERAUTH」サービスを呼び出します。アプリケーションが正常に認証されると、クライアントはSSH接続プロトコルとして知られている「SSH接続」サービスを、起動します。"
    },
    {
      "indent": 3,
      "text": "After the ssh-connection service is established, the client opens a channel of type \"session\", which results in an SSH session.",
      "ja": "SSH接続サービスが確立された後、クライアントがSSHセッションにつながるタイプ「セッション」のチャネルを開きます。"
    },
    {
      "indent": 3,
      "text": "Once the SSH session has been established, the application invokes the application transport as an SSH subsystem called \"rpki-rtr\". Subsystem support is a feature of SSHv2 and is not included in SSHv1. Running this protocol as an SSH subsystem avoids the need for the application to recognize shell prompts or skip over extraneous information, such as a system message that is sent at shell startup.",
      "ja": "SSHセッションが確立されると、アプリケーションは「RPKI-RTR」と呼ばれるSSHサブシステムとしてアプリケーション・トランスポートを起動します。サブシステムのサポートは、SSHv2のの機能であり、SSHv1の中に含まれていません。 SSHサブシステムとして、このプロトコルを実行すると、シェルプロンプトを認識したり、そのようなシェルの起動時に送信されるシステムメッセージのような無関係な情報をスキップするアプリケーションの必要性を回避します。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the router and cache have exchanged keys out of band by some reasonably secured means.",
      "ja": "ルータおよびキャッシュは、いくつかの合理的に安全な手段によって帯域外の鍵を交換しているものとします。"
    },
    {
      "indent": 3,
      "text": "Cache servers supporting SSH transport MUST accept RSA authentication and SHOULD accept Elliptic Curve Digital Signature Algorithm (ECDSA) authentication. User authentication MUST be supported; host authentication MAY be supported. Implementations MAY support password authentication. Client routers SHOULD verify the public key of the cache to avoid MITM attacks.",
      "ja": "SSHトランスポートをサポートするキャッシュサーバは、RSA認証を受け入れなければならないし、楕円曲線デジタル署名アルゴリズム（ECDSA）の認証を受け入れる必要があります。ユーザー認証をサポートしなければなりません。ホスト認証をサポートすることができます。実装は、パスワード認証をサポートするかもしれません。クライアントルータは、MITM攻撃を避けるために、キャッシュの公開鍵を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.2. TLS Transport",
      "section_title": true,
      "ja": "9.2。 TLSトランスポート"
    },
    {
      "indent": 3,
      "text": "Client routers using TLS transport MUST present client-side certificates to authenticate themselves to the cache in order to allow the cache to manage the load by rejecting connections from unauthorized routers. In principle, any type of certificate and Certification Authority (CA) may be used; however, in general, cache operators will wish to create their own small-scale CA and issue certificates to each authorized router. This simplifies credential rollover; any unrevoked, unexpired certificate from the proper CA may be used.",
      "ja": "TLSトランスポートを使用してクライアントのルータは、キャッシュが不正ルーターからの接続を拒否することで負荷を管理することを可能にするためにキャッシュに自分自身を認証するためにクライアント側の証明書を提示しなければなりません。原理的には、証明書と証明機関（CA）のいずれかのタイプを使用することができます。しかし、一般的には、キャッシュのオペレータは、各許可ルータに、独自の小規模なCAと発行証明書を作成したいでしょう。これは、資格ロールオーバーを簡素化します。適切なCAから任意のUNREVOKED、期限が切れていない証明書を使用することができます。"
    },
    {
      "indent": 3,
      "text": "Certificates used to authenticate client routers in this protocol MUST include a subjectAltName extension [RFC5280] containing one or more iPAddress identities; when authenticating the router's certificate, the cache MUST check the IP address of the TLS connection against these iPAddress identities and SHOULD reject the connection if none of the iPAddress identities match the connection.",
      "ja": "このプロトコルでは、クライアント・ルータを認証するために使用される証明書は、一つ以上のIPアドレスIDを含むsubjectAltName拡張[RFC5280]を含まなければなりません。ルータの証明書を認証するときに、キャッシュは、これらのIPアドレスのアイデンティティに対するTLS接続のIPアドレスをチェックしなければなりませんし、IPアドレスのIDのいずれも接続と一致しない場合は接続を拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "Routers MUST also verify the cache's TLS server certificate, using subjectAltName dNSName identities as described in [RFC6125], to avoid MITM attacks. The rules and guidelines defined in [RFC6125] apply here, with the following considerations:",
      "ja": "ルータはまた、[RFC6125]で説明したようにMITM攻撃を避けるために、のsubjectAltNameのdNSName IDを使用して、キャッシュのTLSサーバー証明書を検証しなければなりません。 [RFC6125]で定義されたルールやガイドラインは、次の点を考慮して、ここで適用されます。"
    },
    {
      "indent": 3,
      "text": "o Support for the DNS-ID identifier type (that is, the dNSName identity in the subjectAltName extension) is REQUIRED in rpki-rtr server and client implementations which use TLS. Certification authorities which issue rpki-rtr server certificates MUST support the DNS-ID identifier type, and the DNS-ID identifier type MUST be present in rpki-rtr server certificates.",
      "ja": "O DNS-ID識別子タイプのサポートは（すなわち、subjectAltName拡張内のdNSName同一である）TLSを使用RPKI-RTRサーバとクライアントの実装に必要とされます。 RPKI-RTRサーバ証明書は、DNS-IDの識別子タイプをサポートしなければならない問題が証明機関、およびDNS-IDの識別子タイプはRPKI-RTRサーバ証明書中に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o DNS names in rpki-rtr server certificates SHOULD NOT contain the wildcard character \"*\".",
      "ja": "RPKI-RTRサーバ証明書中のOのDNS名にワイルドカード文字「*」を含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o rpki-rtr implementations which use TLS MUST NOT use Common Name (CN-ID) identifiers; a CN field may be present in the server certificate's subject name but MUST NOT be used for authentication within the rules described in [RFC6125].",
      "ja": "O TLSを使用RPKI-RTR実装は、共通名（CN-ID）の識別子を使用してはいけません。 CNフィールドは、サーバ証明書のサブジェクト名に存在してもよいが、[RFC6125]に記載されたルール内で認証のために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "o The client router MUST set its \"reference identifier\" to the DNS name of the rpki-rtr cache.",
      "ja": "Oクライアントルータは、RPKI-RTRキャッシュのDNS名にその「参照識別子」に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.3. TCP MD5 Transport",
      "section_title": true,
      "ja": "9.3。 TCP MD5交通"
    },
    {
      "indent": 3,
      "text": "If TCP MD5 is used, implementations MUST support key lengths of at least 80 printable ASCII bytes, per Section 4.5 of [RFC2385]. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits.",
      "ja": "TCP MD5を使用する場合、実装は、[RFC2385]のセクション4.5当たり、少なくとも80回の印刷可能なASCIIバイトの鍵長をサポートしなければなりません。実装は、少なくとも32文字、即ち、128ビットの16進数の配列をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Key rollover with TCP MD5 is problematic. Cache servers SHOULD support [RFC4808].",
      "ja": "TCP MD5でのキーロールオーバーには問題があります。キャッシュサーバは、[RFC4808]をサポートすべきです。"
    },
    {
      "indent": 0,
      "text": "9.4. TCP-AO Transport",
      "section_title": true,
      "ja": "9.4。 TCP-AOの交通"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support key lengths of at least 80 printable ASCII bytes. Implementations MUST also support hexadecimal sequences of at least 32 characters, i.e., 128 bits. Message Authentication Code (MAC) lengths of at least 96 bits MUST be supported, per Section 5.1 of [RFC5925].",
      "ja": "実装は、少なくとも80回の印刷可能なASCIIバイトの鍵長をサポートしなければなりません。実装は、少なくとも32文字、即ち、128ビットの16進数の配列をサポートしなければなりません。メッセージ認証コード（MAC）は、少なくとも96ビットの長さは、[RFC5925]のセクション5.1あたり、サポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The cryptographic algorithms and associated parameters described in [RFC5926] MUST be supported.",
      "ja": "[RFC5926]に記載の暗号化アルゴリズムおよび関連するパラメータをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Router-Cache Setup",
      "section_title": true,
      "ja": "10.ルーター・キャッシュの設定"
    },
    {
      "indent": 3,
      "text": "A cache has the public authentication data for each router it is configured to support.",
      "ja": "キャッシュは、サポートするように設定されている各ルータの公開認証データを持っています。"
    },
    {
      "indent": 3,
      "text": "A router may be configured to peer with a selection of caches, and a cache may be configured to support a selection of routers. Each must have the name of, and authentication data for, each peer. In addition, in a router, this list has a non-unique preference value for each server. This preference merely denotes proximity, not trust, preferred belief, et cetera. The client router attempts to establish a session with each potential serving cache in preference order and then starts to load data from the most preferred cache to which it can connect and authenticate. The router's list of caches has the following elements:",
      "ja": "ルータは、キャッシュの選択とピアに構成されてもよいし、キャッシュがルータの選択をサポートするように構成することができます。それぞれの名前、およびのための認証データ、各ピアを持っている必要があります。また、ルータでは、このリストには、サーバごとに一意でないプリファレンス値を持ちます。この設定は、単にエトセトラ、近接ではなく、信頼、優先信念を示しています。クライアントルータは優先順に各潜在的サービングキャッシュとのセッションを確立しようと、それが接続して認証できるためにどの最も好ましいキャッシュからデータをロードするために開始します。キャッシュのルータのリストには次の要素があります。"
    },
    {
      "indent": 3,
      "text": "Preference: An unsigned integer denoting the router's preference to connect to that cache; the lower the value, the more preferred.",
      "ja": "好み：そのキャッシュに接続するためのルータの優先度を表す符号なし整数。低い値が、より好ましいです。"
    },
    {
      "indent": 3,
      "text": "Name: The IP address or fully qualified domain name of the cache.",
      "ja": "名前：IPアドレスまたはキャッシュの完全修飾ドメイン名。"
    },
    {
      "indent": 3,
      "text": "Cache Credential(s): Any credential (such as a public key) needed to authenticate the cache's identity to the router.",
      "ja": "キャッシュ資格（複数可）：（公開鍵など）の任意の資格は、ルータにキャッシュの身元を認証する必要がありました。"
    },
    {
      "indent": 3,
      "text": "Router Credential(s): Any credential (such as a private key or certificate) needed to authenticate the router's identity to the cache.",
      "ja": "ルータの資格（複数可）：（例えば、秘密鍵や証明書など）の任意の資格をキャッシュにルータの身元を認証する必要がありました。"
    },
    {
      "indent": 3,
      "text": "Due to the distributed nature of the RPKI, caches simply cannot be rigorously synchronous. A client may hold data from multiple caches but MUST keep the data marked as to source, as later updates MUST affect the correct data.",
      "ja": "RPKIの分散性に、キャッシュは単に厳密に同期することはできません。後で更新が正しいデータに影響を与えなければならないため、クライアントは、複数のキャッシュからのデータを保持することができるが、ソースへとマークされたデータを保持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Just as there may be more than one covering ROA from a single cache, there may be multiple covering ROAs from multiple caches. The results are as described in [RFC6811].",
      "ja": "単一のキャッシュからROAをカバーする複数のがあるかもしれないのと同様に、複数のキャッシュから複数のカバー資産収益率があるかもしれません。 [RFC6811]に記載されるような結果です。"
    },
    {
      "indent": 3,
      "text": "If data from multiple caches are held, implementations MUST NOT distinguish between data sources when performing validation of BGP announcements.",
      "ja": "複数のキャッシュからのデータが保持されている場合BGPアナウンスの検証を行う際に、実装はデータ・ソースを区別してはいけません。"
    },
    {
      "indent": 3,
      "text": "When a more-preferred cache becomes available, if resources allow, it would be prudent for the client to start fetching from that cache.",
      "ja": "より優先キャッシュが利用可能になるとリソースが許すならば、クライアントはそのキャッシュからフェッチを開始するために、それが賢明だろう。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD attempt to maintain at least one set of data, regardless of whether it has chosen a different cache or established a new connection to the previous cache.",
      "ja": "クライアントに関係なく、それは別のキャッシュを選択したり、以前のキャッシュへの新しい接続を確立しているかどうかの、データの少なくとも1セットを維持しようとすべきです。"
    },
    {
      "indent": 3,
      "text": "A client MAY drop the data from a particular cache when it is fully in sync with one or more other caches.",
      "ja": "それは、1つまたは複数の他のキャッシュと同期して完全にあるときに、クライアントが特定のデータをキャッシュから低下することがあります。"
    },
    {
      "indent": 3,
      "text": "See Section 6 for details on what to do when the client is not able to refresh from a particular cache.",
      "ja": "クライアントが特定のキャッシュからリフレッシュすることができないときに何をすべきかの詳細については、第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a client loses connectivity to a cache it is using or otherwise decides to switch to a new cache, it SHOULD retain the data from the previous cache until it has a full set of data from one or more other caches. Note that this may already be true at the point of connection loss if the client has connections to more than one cache.",
      "ja": "クライアントは、それが使用しているキャッシュへの接続を失ったか、そうでなければ、新たなキャッシュに切り替えることを決定した場合、それが1つのまたは複数の他のキャッシュからのデータの完全なセットを持ってまで、それは以前のキャッシュからのデータを保持するべきです。クライアントが複数のキャッシュへの接続を持っている場合、これはすでに接続損失の時点で真であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11. Deployment Scenarios",
      "section_title": true,
      "ja": "11.展開シナリオ"
    },
    {
      "indent": 3,
      "text": "For illustration, we present three likely deployment scenarios:",
      "ja": "説明のために、我々は3つの可能性の高い展開シナリオを提示します："
    },
    {
      "indent": 3,
      "text": "Small End Site: The small multihomed end site may wish to outsource the RPKI cache to one or more of their upstream ISPs. They would exchange authentication material with the ISP using some out-of-band mechanism, and their router(s) would connect to the cache(s) of one or more upstream ISPs. The ISPs would likely deploy caches intended for customer use separately from the caches with which their own BGP speakers peer.",
      "ja": "小端サイト：小型マルチホームエンドサイトは、その上流のISPの1つ以上にRPKIキャッシュを外部委託することを望むかもしれません。彼らはいくつかのアウトオブバンドメカニズムを使用してISPに認証材を交換するだろう、と彼らのルータ（複数可）は、1つのまたは複数の上流のISPのキャッシュ（複数可）に接続します。 ISPはおそらく自分のBGPスピーカがピアいるとキャッシュとは別に、顧客の使用を意図したキャッシュを展開します。"
    },
    {
      "indent": 3,
      "text": "Large End Site: A larger multihomed end site might run one or more caches, arranging them in a hierarchy of client caches, each fetching from a serving cache which is closer to the Global RPKI. They might configure fallback peerings to upstream ISP caches.",
      "ja": "大規模なエンドサイト：大きなマルチホームエンドサイトは、それぞれがグローバルRPKIに近いサービス提供キャッシュからフェッチ、クライアントキャッシュの階層でそれらを並べ、一の以上のキャッシュを実行する可能性があります。彼らは、ISPのキャッシュを上流へフォールバックピアリングを設定することがあります。"
    },
    {
      "indent": 3,
      "text": "ISP Backbone: A large ISP would likely have one or more redundant caches in each major point of presence (PoP), and these caches would fetch from each other in an ISP-dependent topology so as not to place undue load on the Global RPKI.",
      "ja": "ISPバックボーン：大ISPはおそらく存在する各主要ポイント（POP）内の1つ以上の冗長なキャッシュを持っているでしょう、そしてグローバルRPKIに過度の負荷をかけないように、これらのキャッシュは、ISP依存トポロジーにおいて互いにフェッチあろう。"
    },
    {
      "indent": 3,
      "text": "Experience with large DNS cache deployments has shown that complex topologies are ill-advised, as it is easy to make errors in the graph, e.g., not maintain a loop-free condition.",
      "ja": "大規模なDNSキャッシュの展開の経験は、例えば、ループのない状態を維持していない、グラフ内のエラーを作るのは簡単であるような複雑なトポロジは、無分別であることが示されています。"
    },
    {
      "indent": 3,
      "text": "Of course, these are illustrations, and there are other possible deployment strategies. It is expected that minimizing load on the Global RPKI servers will be a major consideration.",
      "ja": "もちろん、これらは例示であり、他の可能な展開戦略があります。グローバルRPKIサーバーの負荷を最小限に抑えることの主要な考慮事項であることが期待されます。"
    },
    {
      "indent": 3,
      "text": "To keep load on Global RPKI services from unnecessary peaks, it is recommended that primary caches which load from the distributed Global RPKI not do so all at the same times, e.g., on the hour. Choose a random time, perhaps the ISP's AS number modulo 60, and jitter the inter-fetch timing.",
      "ja": "不要なピークからグローバルRPKIサービスの負荷を維持するために、次キャッシュは、分散グローバルRPKIからのロード時間に、例えば、同じタイミングでそのすべてをしないことをお勧めします。おそらくISPのAS番号は60を法、ランダムな時間を選択し、ジッタタイミングを相互フェッチ。"
    },
    {
      "indent": 0,
      "text": "12. Error Codes",
      "section_title": true,
      "ja": "12.エラーコード"
    },
    {
      "indent": 3,
      "text": "This section contains a preliminary list of error codes. The authors expect additions to the list during development of the initial implementations. There is an IANA registry where valid error codes are listed; see Section 14. Errors which are considered fatal MUST cause the session to be dropped.",
      "ja": "このセクションでは、エラーコードの予備的なリストが含まれています。著者は、初期の実装の開発中リストへの追加を期待しています。有効なエラーコードが表示されているIANAレジストリがあります。セッションがドロップさせなければなら致命的と考えられているセクション14のエラーを参照してください。"
    },
    {
      "indent": 3,
      "text": "0: Corrupt Data (fatal): The receiver believes the received PDU to be corrupt in a manner not specified by another error code.",
      "ja": "0：破損データ（致命的な）受信機は、受信されたPDUは、別のエラー・コードによって指定されていない方法で破損であると考えています。"
    },
    {
      "indent": 3,
      "text": "1: Internal Error (fatal): The party reporting the error experienced some kind of internal error unrelated to protocol operation (ran out of memory, a coding assertion failed, et cetera).",
      "ja": "1：内部エラー（致命的な）は：エラーを報告している当事者がプロトコルの動作に関係のない内部エラーのいくつかの種類を経験した（エトセトラ、コーディングアサーションが失敗し、メモリ不足しました）。"
    },
    {
      "indent": 3,
      "text": "2: No Data Available: The cache believes itself to be in good working order but is unable to answer either a Serial Query or a Reset Query because it has no useful data available at this time. This is likely to be a temporary error and most likely indicates that the cache has not yet completed pulling down an initial current data set from the Global RPKI system after some kind of event that invalidated whatever data it might have previously held (reboot, network partition, et cetera).",
      "ja": "2：データなし：キャッシュは、良好な作業順序であることを自分自身を信じているが、それは、この時点で利用可能な有用なデータを持っていないため、シリアルクエリまたはリセットクエリのいずれかを答えることができません。これは一時的なエラーである可能性が高いと最も可能性が高いことが以前に開催されている場合がありますどんなデータ無効イベントのいくつかの種類（再起動、ネットワークパーティションの後にグローバルRPKIシステムからの初期電流のデータセットを引き下げるキャッシュがまだ完了していないことを示し、エトセトラ）。"
    },
    {
      "indent": 3,
      "text": "3: Invalid Request (fatal): The cache server believes the client's request to be invalid.",
      "ja": "3：無効な要求（致命的）：キャッシュサーバは、クライアントの要求は無効であると考えています。"
    },
    {
      "indent": 3,
      "text": "4: Unsupported Protocol Version (fatal): The Protocol Version is not known by the receiver of the PDU.",
      "ja": "4：サポートされないプロトコルバージョン（致命的）：プロトコルバージョンは、PDUの受信機によって知られていません。"
    },
    {
      "indent": 3,
      "text": "5: Unsupported PDU Type (fatal): The PDU Type is not known by the receiver of the PDU.",
      "ja": "5：サポートされていないPDUタイプ（致命的）：PDUタイプは、PDUの受信機によって知られていません。"
    },
    {
      "indent": 3,
      "text": "6: Withdrawal of Unknown Record (fatal): The received PDU has Flag=0, but a matching record ({Prefix, Len, Max-Len, ASN} tuple for an IPvX PDU or {SKI, ASN, Subject Public Key} tuple for a Router Key PDU) does not exist in the receiver's database.",
      "ja": "6：不明なレコードの離脱（致命的）：受信したPDUフラグ= 0を有するが、IPvX PDUまたは{SKI、ASN、サブジェクト公開鍵}タプルのための一致するレコード（{プレフィックスレン、最大レン、ASN}タプルルーターキーPDUのための）受信者のデータベースに存在しません。"
    },
    {
      "indent": 3,
      "text": "7: Duplicate Announcement Received (fatal): The received PDU has Flag=1, but a matching record ({Prefix, Len, Max-Len, ASN} tuple for an IPvX PDU or {SKI, ASN, Subject Public Key} tuple for a Router Key PDU) is already active in the router.",
      "ja": "7：重複アナウンス（致命的）を受信：受信したPDUフラグ= 1が、一致するレコード（{プレフィックスレン、最大レン、ASN} IPvX PDUまたは{SKI、ASN、サブジェクト公開鍵}タプルのためのためのタプルを有しますルーターキーPDU）すでにルータでアクティブになっています。"
    },
    {
      "indent": 3,
      "text": "8: Unexpected Protocol Version (fatal): The received PDU has a Protocol Version field that differs from the protocol version negotiated in Section 7.",
      "ja": "8：予期しないプロトコルバージョン（致命的）：受信されたPDUは、セクション7で交渉プロトコルバージョンとは異なるプロトコルバージョンフィールドを有しています。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As this document describes a security protocol, many aspects of security interest are described in the relevant sections. This section points out issues which may not be obvious in other sections.",
      "ja": "このドキュメントは、セキュリティプロトコルを記述したように、セキュリティ関心の多くの側面には、関連するセクションで説明されています。このセクションでは、他のセクションでは明らかではないかもしれない問題を指摘しています。"
    },
    {
      "indent": 3,
      "text": "Cache Validation: In order for a collection of caches as described in Section 11 to guarantee a consistent view, they need to be given consistent trust anchors to use in their internal validation process. Distribution of a consistent trust anchor is assumed to be out of band.",
      "ja": "キャッシュの検証：一貫したビューを保証するために、セクション11で説明したようにキャッシュのコレクションのために、彼らは彼らの内部検証プロセスで使用するために、一貫した信頼アンカーを与えられる必要があります。一貫性のトラストアンカーの分布は、帯域外であると仮定されます。"
    },
    {
      "indent": 3,
      "text": "Cache Peer Identification: The router initiates a transport connection to a cache, which it identifies by either IP address or fully qualified domain name. Be aware that a DNS or address spoofing attack could make the correct cache unreachable. No session would be established, as the authorization keys would not match.",
      "ja": "キャッシュピアの識別：ルータはIPアドレスまたは完全修飾ドメイン名のいずれかで識別したキャッシュへのトランスポート接続を開始します。 DNSまたはアドレススプーフィング攻撃が正しいキャッシュが到達不能にする可能性があることに注意してください。認証キーが一致しませんようませセッションは、確立されないであろう。"
    },
    {
      "indent": 3,
      "text": "Transport Security: The RPKI relies on object, not server or transport, trust. That is, the IANA root trust anchor is distributed to all caches through some out-of-band means and can then be used by each cache to validate certificates and ROAs all the way down the tree. The inter-cache relationships are based on this object security model; hence, the inter-cache transport can be lightly protected.",
      "ja": "交通安全：RPKIはオブジェクトではなく、サーバーや輸送、信頼に依存しています。それは、IANAのルートトラストアンカーは、いくつかのアウトオブバンド手段を通じてすべてのキャッシュに配布され、その後、すべての道ツリーの下の証明書と資産収益率を検証するために、各キャッシュで使用することができます。キャッシュ間の関係は、このオブジェクトのセキュリティモデルに基づいています。したがって、キャッシュ間の輸送が軽く保護することができます。"
    },
    {
      "indent": 6,
      "text": "However, this protocol document assumes that the routers cannot do the validation cryptography. Hence, the last link, from cache to router, is secured by server authentication and transport-level security. This is dangerous, as server authentication and transport have very different threat models than object security.",
      "ja": "しかし、このプロトコルドキュメントは、ルータが検証暗号化を行うことができないことを前提としています。したがって、キャッシュからルータへの最後のリンクは、サーバー認証と、トランスポートレベルのセキュリティで保護されています。サーバー認証およびトランスポートはオブジェクトのセキュリティは非常に異なる脅威モデルを持っているので、これは、危険です。"
    },
    {
      "indent": 6,
      "text": "So the strength of the trust relationship and the transport between the router(s) and the cache(s) are critical. You're betting your routing on this.",
      "ja": "だから、信頼関係の強さとルータ（複数可）とキャッシュ（複数可）間の輸送は極めて重要です。あなたは、この上のルーティングを賭けています。"
    },
    {
      "indent": 6,
      "text": "While we cannot say the cache must be on the same LAN, if only due to the issue of an enterprise wanting to offload the cache task to their upstream ISP(s), locality, trust, and control are very critical issues here. The cache(s) really SHOULD be as close, in the sense of controlled and protected (against DDoS, MITM) transport, to the router(s) as possible. It also SHOULD be topologically close so that a minimum of validated routing data are needed to bootstrap a router's access to a cache.",
      "ja": "我々はキャッシュがある場合にのみ、それらの上流ISPにキャッシュタスクの負荷を軽減したい企業の問題に、同じLAN上にある必要がありますと言うことはできませんが（S）、地域、信頼、および制御が非常に重要な問題はここにあります。キャッシュ（複数可）、実際に可能な限りのルータ（複数可）に、制御され、保護された（に対するDDoS攻撃、MITM）輸送の意味で、近づけるべきです。検証済みのルーティングデータの最小値がキャッシュにルータのアクセスをブートストラップするために必要とされるように、また、位相幾何学的に近いはずです。"
    },
    {
      "indent": 6,
      "text": "The identity of the cache server SHOULD be verified and authenticated by the router client, and vice versa, before any data are exchanged.",
      "ja": "すべてのデータが交換される前に、キャッシュサーバのアイデンティティは、検証および認証されたルータクライアントによって、及びその逆れるべきです。"
    },
    {
      "indent": 6,
      "text": "Transports which cannot provide the necessary authentication and integrity (see Section 9) must rely on network design and operational controls to provide protection against spoofing/ corruption attacks. As pointed out in Section 9, TCP-AO is the long-term plan. Protocols which provide integrity and authenticity SHOULD be used, and if they cannot, i.e., TCP is used as the transport, the router and cache MUST be on the same trusted, controlled network.",
      "ja": "必要な認証と完全性を提供することができませんトランスポート（9章を参照してください）なりすまし/汚職攻撃に対する保護を提供するために、ネットワークの設計と運用のコントロールに依存しなければなりません。第9章で指摘したように、TCP-AOは、長期計画です。整合性と信頼性を提供するプロトコルが使用されるべきである、と彼らは、すなわち、TCPをトランスポートとして使用されていることができない場合は、ルータおよびキャッシュが同じ信頼できる、制御されたネットワーク上にある必要があります。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section only discusses updates required in the existing IANA protocol registries to accommodate version 1 of this protocol. See [RFC6810] for IANA considerations from the original (version 0) protocol.",
      "ja": "このセクションでは、このプロトコルのバージョン1を収容するために、既存のIANAプロトコルレジストリに必要な更新プログラムについて説明します。元の（バージョン0）プロトコルからIANAの考慮のために[RFC6810]を参照。"
    },
    {
      "indent": 3,
      "text": "All existing entries in the IANA \"rpki-rtr-pdu\" registry remain valid for protocol version 0. All of the PDU types allowed in protocol version 0 are also allowed in protocol version 1, with the addition of the new Router Key PDU. To reduce the likelihood of confusion, the PDU number used by the Router Key PDU in protocol version 1 is hereby registered as reserved (and unused) in protocol version 0.",
      "ja": "IANA「RPKI-RTR-PDU」レジストリのすべての既存のエントリは、新しいルータキーPDUを追加して、プロトコルバージョン0で許可されるPDUタイプのすべてのも、プロトコルバージョン1で許可されているプロトコルバージョン0のための有効なまま。混同の可能性を低減するために、プロトコルバージョン1のルータキーPDUで使用されるPDUの数は、本明細書プロトコルバージョン0にリザーブ（未使用）として登録されています。"
    },
    {
      "indent": 3,
      "text": "The policy for adding to the registry is RFC Required per [RFC8126]; the document must be either Standards Track or Experimental.",
      "ja": "レジストリに追加するためのポリシーは、RFC [RFC8126]ごとに必要です。文書は、標準化過程や実験のどちらかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"rpki-rtr-pdu\" registry has been updated as follows:",
      "ja": "以下のように「RPKI-RTR-PDU」レジストリが更新されました："
    },
    {
      "indent": 14,
      "text": "Protocol   PDU\nVersion    Type  Description\n--------   ----  ---------------\n   0-1       0   Serial Notify\n   0-1       1   Serial Query\n   0-1       2   Reset Query\n   0-1       3   Cache Response\n   0-1       4   IPv4 Prefix\n   0-1       6   IPv6 Prefix\n   0-1       7   End of Data\n   0-1       8   Cache Reset\n    0        9   Reserved\n    1        9   Router Key\n   0-1      10   Error Report\n   0-1     255   Reserved",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All existing entries in the IANA \"rpki-rtr-error\" registry remain valid for all protocol versions. Protocol version 1 adds one new error code:",
      "ja": "IANA「RPKI-RTR-エラー」レジストリ内のすべての既存のエントリは、すべてのプロトコルバージョンのために有効なまま。プロトコルバージョン1は、1つの新しいエラーコードを追加します。"
    },
    {
      "indent": 14,
      "text": "Error\nCode    Description\n-----   ---------------------------\n    8   Unexpected Protocol Version",
      "raw": true
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15.参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, DOI 10.17487/RFC1982, August 1996, <https://www.rfc-editor.org/info/rfc1982>.",
      "ja": "[RFC1982]エルツ、R.とR.ブッシュ大統領、 \"シリアル番号演算\"、RFC 1982、DOI 10.17487 / RFC1982、1996年8月、<https://www.rfc-editor.org/info/rfc1982>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2385] Heffernan, A., \"Protection of BGP Sessions via the TCP MD5 Signature Option\", RFC 2385, DOI 10.17487/RFC2385, August 1998, <https://www.rfc-editor.org/info/rfc2385>.",
      "ja": "[RFC2385] Heffernanの、A.、 \"TCP MD5署名オプションを使用してBGPセッションの保護\"、RFC 2385、DOI 10.17487 / RFC2385、1998年8月、<https://www.rfc-editor.org/info/rfc2385>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4252] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Authentication Protocol\", RFC 4252, DOI 10.17487/RFC4252, January 2006, <https://www.rfc-editor.org/info/rfc4252>.",
      "ja": "[RFC4252] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）認証プロトコル\"、RFC 4252、DOI 10.17487 / RFC4252、2006年1月、<https://www.rfc-editor.org/情報/ rfc4252>。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, DOI 10.17487/RFC4301, December 2005, <https://www.rfc-editor.org/info/rfc4301>.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、DOI 10.17487 / RFC4301、2005年12月、<https://www.rfc-editor.org/info/rfc4301>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5925] Touch, J., Mankin, A., and R. Bonica, \"The TCP Authentication Option\", RFC 5925, DOI 10.17487/RFC5925, June 2010, <https://www.rfc-editor.org/info/rfc5925>.",
      "ja": "[RFC5925]をタッチし、J.、マンキン、A.、およびR. Bonica、 \"TCP認証オプション\"、RFC 5925、DOI 10.17487 / RFC5925、2010年6月、<https://www.rfc-editor.org/info / rfc5925>。"
    },
    {
      "indent": 3,
      "text": "[RFC5926] Lebovitz, G. and E. Rescorla, \"Cryptographic Algorithms for the TCP Authentication Option (TCP-AO)\", RFC 5926, DOI 10.17487/RFC5926, June 2010, <https://www.rfc-editor.org/info/rfc5926>.",
      "ja": "[RFC5926] Lebovitz、G.、およびE.レスコラ、 \"暗号アルゴリズムTCP認証オプション（TCP-AO）のための\"、RFC 5926、DOI 10.17487 / RFC5926、2010年6月、<https://www.rfc-editor.org /情報/ rfc5926>。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6487] Huston, G., Michaelson, G., and R. Loomans, \"A Profile for X.509 PKIX Resource Certificates\", RFC 6487, DOI 10.17487/RFC6487, February 2012, <https://www.rfc-editor.org/info/rfc6487>.",
      "ja": "[RFC6487]ヒューストン、G.、マイケルソン、G.、およびR. Loomans、 \"X.509 PKIXリソース証明書のプロファイル\"、RFC 6487、DOI 10.17487 / RFC6487、2012年2月、<HTTPS：//www.rfc- editor.org/info/rfc6487>。"
    },
    {
      "indent": 3,
      "text": "[RFC6810] Bush, R. and R. Austein, \"The Resource Public Key Infrastructure (RPKI) to Router Protocol\", RFC 6810, DOI 10.17487/RFC6810, January 2013, <https://www.rfc-editor.org/info/rfc6810>.",
      "ja": "[RFC6810]ブッシュ、R.とR. Austeinと、 \"リソース公開鍵インフラストラクチャルータプロトコルへ（RPKI）\"、RFC 6810、DOI 10.17487 / RFC6810、2013年1月、<https://www.rfc-editor.org/情報/ rfc6810>。"
    },
    {
      "indent": 3,
      "text": "[RFC6811] Mohapatra, P., Scudder, J., Ward, D., Bush, R., and R. Austein, \"BGP Prefix Origin Validation\", RFC 6811, DOI 10.17487/RFC6811, January 2013, <https://www.rfc-editor.org/info/rfc6811>.",
      "ja": "[RFC6811] Mohapatra、P.、スカダー、J.、ウォード、D.、ブッシュ、R.、およびR. Austeinと、 \"BGPプレフィクス起源の検証\"、RFC 6811、DOI 10.17487 / RFC6811、2013年1月、<HTTPS：/ /www.rfc-editor.org/info/rfc6811>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8208] Turner, S. and O. Borchert, \"BGPsec Algorithms, Key Formats, and Signature Formats\", RFC 8208, DOI 10.17487/RFC8208, September 2017, <http://www.rfc-editor.org/info/rfc8208>.",
      "ja": "[RFC8208]ターナー、S.及びO. Borchert、 \"BGPsecアルゴリズム、キーフォーマット、および署名フォーマット\"、RFC 8208、DOI 10.17487 / RFC8208、2017年9月、<http://www.rfc-editor.org/info/ rfc8208>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC1996] Vixie, P., \"A Mechanism for Prompt Notification of Zone Changes (DNS NOTIFY)\", RFC 1996, DOI 10.17487/RFC1996, August 1996, <https://www.rfc-editor.org/info/rfc1996>.",
      "ja": "[RFC1996]いるVixie、P.、RFC 1996、DOI 10.17487 / RFC1996、1996年8月、<https://www.rfc-editor.org/info/rfc1996 \"ゾーンの変更（DNSがNOTIFY）のプロンプト通知のメカニズム\" >。"
    },
    {
      "indent": 3,
      "text": "[RFC4808] Bellovin, S., \"Key Change Strategies for TCP-MD5\", RFC 4808, DOI 10.17487/RFC4808, March 2007, <https://www.rfc-editor.org/info/rfc4808>.",
      "ja": "[RFC4808] Bellovin氏、S.、 \"TCP-MD5の主な変更戦略\"、RFC 4808、DOI 10.17487 / RFC4808、2007年3月、<https://www.rfc-editor.org/info/rfc4808>。"
    },
    {
      "indent": 3,
      "text": "[RFC5781] Weiler, S., Ward, D., and R. Housley, \"The rsync URI Scheme\", RFC 5781, DOI 10.17487/RFC5781, February 2010, <https://www.rfc-editor.org/info/rfc5781>.",
      "ja": "[RFC5781]ワイラー、S.、区、D.、およびR. Housley氏、 \"rsyncのURIスキーム\"、RFC 5781、DOI 10.17487 / RFC5781、2010年2月、<https://www.rfc-editor.org/info / rfc5781>。"
    },
    {
      "indent": 3,
      "text": "[RFC6480] Lepinski, M. and S. Kent, \"An Infrastructure to Support Secure Internet Routing\", RFC 6480, DOI 10.17487/RFC6480, February 2012, <https://www.rfc-editor.org/info/rfc6480>.",
      "ja": "[RFC6480] Lepinski、M.とS.ケント、 \"安全なインターネットルーティングをサポートするインフラストラクチャ\"、RFC 6480、DOI 10.17487 / RFC6480、2012年2月、<https://www.rfc-editor.org/info/rfc6480> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6481] Huston, G., Loomans, R., and G. Michaelson, \"A Profile for Resource Certificate Repository Structure\", RFC 6481, DOI 10.17487/RFC6481, February 2012, <https://www.rfc-editor.org/info/rfc6481>.",
      "ja": "[RFC6481]ヒューストン、G.、Loomans、R.、およびG.マイケルソン、 \"リソース証明書リポジトリの構造用プロフィール\"、RFC 6481、DOI 10.17487 / RFC6481、2012年2月、<HTTPS：//www.rfc-editor。組織/情報/ rfc6481>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Nils Bars, Steve Bellovin, Tim Bruijnzeels, Rex Fernando, Richard Hansen, Paul Hoffman, Fabian Holler, Russ Housley, Pradosh Mohapatra, Keyur Patel, David Mandelberg, Sandy Murphy, Robert Raszuk, Andreas Reuter, Thomas C. Schmidt, John Scudder, Ruediger Volk, Matthias Waehlisch, and David Ward. Particular thanks go to Hannes Gredler for showing us the dangers of unnecessary fields.",
      "ja": "著者は、ニルス・バー、スティーブBellovin氏、ティムBruijnzeels、レックスフェルナンド、リチャード・ハンセン、ポール・ホフマン、ファビアン大声、ラスHousley、Pradosh Mohapatra、Keyurパテル、デビッドMandelberg、サンディマーフィー、ロバートRaszuk、アンドレアス・ロイター、トーマスC.に感謝したいですシュミット、ジョン・スカダー、Ruedigerボルク、マティアスWaehlisch、とDavidウォード。特定のおかげで私たちに不要なフィールドの危険性を示すためにハンネスGredlerに行きます。"
    },
    {
      "indent": 3,
      "text": "No doubt this list is incomplete. We apologize to any contributor whose name we missed.",
      "ja": "このリストは不完全で間違いありません。私たちは、その名前、我々は逃した任意の貢献者に謝罪します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randy Bush Internet Initiative Japan 5147 Crystal Springs Bainbridge Island, Washington 98110 United States of America",
      "ja": "ランディブッシュインターネットイニシアティブ5147クリスタルスプリングスベインブリッジ島、ワシントンアメリカの98110米国"
    },
    {
      "indent": 3,
      "text": "Email: randy@psg.com",
      "ja": "メール：randy@psg.com"
    },
    {
      "indent": 3,
      "text": "Rob Austein Dragon Research Labs",
      "ja": "ロブAusteinとドラゴン研究所"
    },
    {
      "indent": 3,
      "text": "Email: sra@hactrn.net",
      "ja": "メール：sra@hactrn.net"
    }
  ]
}