{
  "title": {
    "text": "RFC 8641 - Subscription to YANG Notifications for Datastore Updates",
    "ja": "RFC 8641 - データストア更新のYANG通知のサブスクリプション"
  },
  "number": 8641,
  "created_at": "2020-03-09 18:41:32.521566+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          A. Clemm\nRequest for Comments: 8641                                     Futurewei\nCategory: Standards Track                                        E. Voit\nISSN: 2070-1721                                            Cisco Systems\n                                                          September 2019",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Subscription to YANG Notifications for Datastore Updates",
      "ja": "データストア更新のYANG通知のサブスクリプション"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism that allows subscriber applications to request a continuous and customized stream of updates from a YANG datastore. Providing such visibility into updates enables new capabilities based on the remote mirroring and monitoring of configuration and operational state.",
      "ja": "このドキュメントでは、サブスクライバアプリケーションがYANGデータストアから更新の継続的かつカスタマイズされたストリームを要求できるようにするメカニズムについて説明します。 このような更新の可視性を提供することで、リモートミラーリングに基づく新しい機能と、構成および運用状態の監視が可能になります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8641.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8641で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれる場合があります。この資料の一部の著作権を管理する人は、IETFトラストにそのような資料の変更を許可する権利を付与していない可能性があります IETF標準プロセスの外部。 そのような資料の著作権を管理する人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセスの外で修正されず、その派生物はIETF標準プロセスの外で作成されます。 RFCとしての公開、または英語以外の言語への翻訳。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Definitions .....................................................4\n3. Solution Overview ...............................................6\n   3.1. Subscription Model .........................................6\n   3.2. Negotiation of Subscription Policies .......................7\n   3.3. On-Change Considerations ...................................8\n   3.4. Reliability Considerations .................................9\n   3.5. Data Encodings ............................................10\n   3.6. Defining the Selection with a Datastore ...................11\n   3.7. Streaming Updates .........................................12\n   3.8. Subscription Management ...................................15\n   3.9. Receiver Authorization ....................................16\n   3.10. On-Change Notifiable Datastore Nodes .....................18\n   3.11. Other Considerations .....................................18\n4. A YANG Data Model for Management of Datastore Push\n   Subscriptions ..................................................20\n   4.1. Overview ..................................................20\n   4.2. Subscription Configuration ................................27\n   4.3. YANG Notifications ........................................28\n   4.4. YANG RPCs .................................................29\n5. YANG Module for YANG-Push ......................................34\n6. IANA Considerations ............................................51\n7. Security Considerations ........................................51\n8. References .....................................................53\n   8.1. Normative References ......................................53\n   8.2. Informative References ....................................55\nAppendix A. Subscription Errors ...................................56\n  A.1. RPC Failures ...............................................56\n  A.2. Failure Notifications ......................................57\nAcknowledgments ...................................................58\nContributors ......................................................58\nAuthors' Addresses ................................................58",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Traditional approaches for providing visibility into managed entities from a remote system have been built on polling. With polling, data is periodically requested and retrieved by a client from a server to stay up to date. However, there are issues associated with polling-based management:",
      "ja": "リモートシステムから管理対象エンティティへの可視性を提供するための従来のアプローチは、ポーリングに基づいています。 ポーリングでは、クライアントがサーバーから定期的にデータを要求および取得して、最新の状態を維持します。 ただし、ポーリングベースの管理に関連する問題があります。"
    },
    {
      "indent": 3,
      "text": "o Polling incurs significant latency. This latency prohibits many types of applications.",
      "ja": "o ポーリングには大きな遅延が発生します。 この遅延により、多くの種類のアプリケーションが禁止されます。"
    },
    {
      "indent": 3,
      "text": "o Polling cycles may be missed, and requests may be delayed or get lost -- often when the network is under stress and the need for the data is the greatest.",
      "ja": "o ポーリングサイクルが失われたり、リクエストが遅延したり失われたりすることがあります。多くの場合、ネットワークに負荷がかかっており、データの必要性が最も高い場合です。"
    },
    {
      "indent": 3,
      "text": "o Polling requests may undergo slight fluctuations, resulting in intervals of different lengths. The resulting data is difficult to calibrate and compare.",
      "ja": "o ポーリング要求にはわずかな変動が生じる可能性があり、その結果、間隔の長さが異なります。 結果のデータは、調整および比較が困難です。"
    },
    {
      "indent": 3,
      "text": "o For applications that monitor for changes, many remote polling cycles place unwanted and ultimately wasteful load on the network, devices, and applications, particularly when changes occur only infrequently.",
      "ja": "o 変更を監視するアプリケーションの場合、多くのリモートポーリングサイクルは、特に変更がまれにしか発生しない場合に、ネットワーク、デバイス、およびアプリケーションに不要で最終的に無駄な負荷をかけます。"
    },
    {
      "indent": 3,
      "text": "A more effective alternative to polling is for an application to receive automatic and continuous updates from a targeted subset of a datastore. Accordingly, there is a need for a service that (1) allows applications to subscribe to updates from a datastore and (2) enables the server (also referred to as the \"publisher\") to push and, in effect, stream those updates. The requirements for such a service have been documented in [RFC7923].",
      "ja": "ポーリングのより効果的な代替方法は、アプリケーションがデータストアの対象サブセットから自動および継続的な更新を受信することです。 したがって、（1）アプリケーションがデータストアからの更新をサブスクライブできるようにし、（2）サーバー（「パブリッシャー」とも呼ばれる）がそれらの更新をプッシュし、実際にストリーミングできるようにするサービスが必要です。 このようなサービスの要件は[RFC7923]に文書化されています。"
    },
    {
      "indent": 3,
      "text": "This document defines a corresponding solution that is built on top of [RFC8639]. Supplementing that work are YANG data model augmentations, extended RPCs, and new datastore-specific update notifications. Transport options provided in [RFC8639] will work seamlessly with this solution.",
      "ja": "このドキュメントは、[RFC8639]の上に構築される対応するソリューションを定義します。 その機能を補完するのが、YANGデータモデルの拡張、拡張RPC、および新しいデータストア固有の更新通知です。 [RFC8639]で提供されるトランスポートオプションは、このソリューションとシームレスに機能します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the terminology defined in [RFC7950], [RFC8341], [RFC8342], and [RFC8639]. In addition, this document defines the following terms:",
      "ja": "このドキュメントでは、[RFC7950]、[RFC8341]、[RFC8342]、および[RFC8639]で定義されている用語を使用します。 さらに、このドキュメントでは次の用語を定義しています。"
    },
    {
      "indent": 3,
      "text": "o Datastore node: A node in the instantiated YANG data tree associated with a datastore. In this document, datastore nodes are often also simply referred to as \"objects\".",
      "ja": "o データストアノード：データストアに関連付けられた、インスタンス化されたYANGデータツリー内のノード。 このドキュメントでは、データストアノードは単に「オブジェクト」とも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o Datastore node update: A data item containing the current value of a datastore node at the time the datastore node update was created, as well as the path to the datastore node.",
      "ja": "o データストアノードの更新：データストアノードの更新が作成された時点でのデータストアノードの現在の値と、データストアノードへのパスを含むデータ項目。"
    },
    {
      "indent": 3,
      "text": "o Datastore subscription: A subscription to a stream of datastore node updates.",
      "ja": "o データストアサブスクリプション：データストアノード更新のストリームへのサブスクリプション。"
    },
    {
      "indent": 3,
      "text": "o Datastore subtree: A datastore node and all its descendant datastore nodes.",
      "ja": "o データストアサブツリー：データストアノードとそのすべての子孫データストアノード。"
    },
    {
      "indent": 3,
      "text": "o On-change subscription: A datastore subscription with updates that are triggered when changes in subscribed datastore nodes are detected.",
      "ja": "o 変更時サブスクリプション：サブスクライブされたデータストアノードの変更が検出されたときにトリガーされる更新を含むデータストアサブスクリプション。"
    },
    {
      "indent": 3,
      "text": "o Periodic subscription: A datastore subscription with updates that are triggered periodically according to some time interval.",
      "ja": "o 定期的なサブスクリプション：一定の時間間隔に従って定期的にトリガーされる更新を含むデータストアサブスクリプション。"
    },
    {
      "indent": 3,
      "text": "o Selection filter: Evaluation and/or selection criteria that may be applied against a targeted set of objects.",
      "ja": "o 選択フィルター：オブジェクトの対象セットに対して適用される評価および/または選択基準。"
    },
    {
      "indent": 3,
      "text": "o Update record: A representation of one or more datastore node updates. In addition, an update record may contain which type of update led to the datastore node update (e.g., whether the datastore node was added, changed, or deleted). Also included in the update record may be other metadata, such as a subscription ID of the subscription for which the update record was generated. In this document, update records are often also simply referred to as \"updates\".",
      "ja": "o 更新レコード：1つ以上のデータストアノードの更新の表現。 さらに、更新レコードには、データストアノードの更新につながった更新の種類（データストアノードが追加、変更、削除されたかどうかなど）が含まれる場合があります。 更新レコードには、更新レコードが生成されたサブスクリプションのサブスクリプションIDなど、他のメタデータも含まれる場合があります。 このドキュメントでは、更新レコードは単に「更新」とも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o Update trigger: A mechanism that determines when an update record needs to be generated.",
      "ja": "o 更新トリガー：更新レコードをいつ生成する必要があるかを決定するメカニズム。"
    },
    {
      "indent": 3,
      "text": "o YANG-Push: The subscription and push mechanism for datastore updates that is specified in this document.",
      "ja": "o YANG-Push：このドキュメントで指定されているデータストア更新のサブスクリプションおよびプッシュメカニズム。"
    },
    {
      "indent": 0,
      "text": "3. Solution Overview",
      "section_title": true,
      "ja": "3. ソリューションの概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a solution that provides a subscription service for updates from a datastore. This solution supports dynamic as well as configured subscriptions to updates of datastore nodes. Subscriptions specify when notification messages (also referred to as \"push updates\") should be sent and what data to include in update records. Datastore node updates are subsequently pushed from the publisher to the receiver per the terms of the subscription.",
      "ja": "このドキュメントでは、データストアからの更新にサブスクリプションサービスを提供するソリューションを指定します。 このソリューションは、データストアノードの更新に対する動的なサブスクリプションと構成されたサブスクリプションをサポートします。 サブスクリプションは、通知メッセージ（「プッシュ更新」とも呼ばれます）を送信するタイミングと、更新レコードに含めるデータを指定します。 その後、サブスクリプションの条件に従って、データストアノードの更新がパブリッシャーからレシーバーにプッシュされます。"
    },
    {
      "indent": 0,
      "text": "3.1. Subscription Model",
      "section_title": true,
      "ja": "3.1. サブスクリプションモデル"
    },
    {
      "indent": 3,
      "text": "YANG-Push subscriptions are defined using a YANG data model. This model enhances the subscription model defined in [RFC8639] with capabilities that allow subscribers to subscribe to datastore node updates -- specifically, to specify the update triggers defining when to generate update records as well as what to include in an update record. Key enhancements include:",
      "ja": "YANG-Pushサブスクリプションは、YANGデータモデルを使用して定義されます。 このモデルは、[RFC8639]で定義されたサブスクリプションモデルを拡張し、サブスクライバーがデータストアノードの更新をサブスクライブできるようにします。具体的には、更新レコードを生成するタイミングと更新レコードに含める対象を定義する更新トリガーを指定します。 主な機能強化は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The specification of selection filters that identify targeted YANG datastore nodes and/or datastore subtrees for which updates are to be pushed.",
      "ja": "o 更新がプッシュされる対象のYANGデータストアノードまたはデータストアサブツリー、あるいはその両方を識別する選択フィルターの仕様。"
    },
    {
      "indent": 3,
      "text": "o The specification of update policies that contain conditions that trigger the generation and pushing of new update records. There are two types of subscriptions, distinguished by how updates are triggered: periodic and on-change.",
      "ja": "o 新しい更新レコードの生成とプッシュをトリガーする条件を含む更新ポリシーの仕様。 サブスクリプションには、更新がトリガーされる方法で区別される2つのタイプがあります。定期的と変更時です。"
    },
    {
      "indent": 6,
      "text": "* For periodic subscriptions, the update trigger is specified by two parameters that define when updates are to be pushed. These parameters are (1) the period interval with which to report updates and (2) an \"anchor-time\", i.e., a reference point in time that can be used to calculate at which points in time periodic updates need to be assembled and sent.",
      "ja": "* 定期的なサブスクリプションの場合、更新トリガーは、更新がいつプッシュされるかを定義する2つのパラメーターによって指定されます。 これらのパラメーターは、（1）更新を報告する期間間隔、および（2）「アンカー時間」、つまり、定期的な更新をどの時点でアセンブルする必要があるかを計算するために使用できる基準時点です。 送った。"
    },
    {
      "indent": 6,
      "text": "* For on-change subscriptions, an update trigger occurs whenever a change in the subscribed information is detected. The following additional parameters are included:",
      "ja": "* 変更時サブスクリプションの場合、サブスクリプション情報の変更が検出されるたびに更新トリガーが発生します。 次の追加パラメーターが含まれています。"
    },
    {
      "indent": 9,
      "text": "+ \"dampening-period\": In an on-change subscription, detected object changes should be sent as quickly as possible. However, it may be undesirable to send a rapid series of object changes. Such behavior has the potential to exhaust resources in the publisher or receiver. In order to protect against this type of scenario, a dampening period MAY be used to specify the interval that has to pass before successive update records for the same subscription are generated for a receiver. The dampening period collectively applies to the set of all datastore nodes selected by a single subscription. This means that when there is a change to one or more subscribed objects, an update record containing those objects is created immediately (when no dampening period is in effect) or at the end of a dampening period (when a dampening period is in fact in effect). If multiple changes to a single object occur during a dampening period, only the value that is in effect at the time when the update record is created is included. The dampening period goes into effect every time the assembly of an update record is completed.",
      "ja": "+ 「ダンプニング期間」：変更時サブスクリプションでは、検出されたオブジェクトの変更をできるだけ早く送信する必要があります。ただし、一連のオブジェクト変更を迅速に送信することは望ましくない場合があります。このような動作は、パブリッシャーまたはレシーバーのリソースを使い果たす可能性があります。このタイプのシナリオから保護するために、ダンプニング期間を使用して、同じサブスクリプションの連続した更新レコードがレシーバーに対して生成されるまでに経過する必要がある間隔を指定することができます。ダンプニング期間は、単一のサブスクリプションによって選択されたすべてのデータストアノードのセットに集合的に適用されます。これは、1つ以上のサブスクライブされたオブジェクトに変更がある場合、それらのオブジェクトを含む更新レコードがすぐに（ダンプニング期間が有効でない場合）またはダンプニング期間の終わりに（ダンプニング期間が実際にある場合）作成されることを意味します効果）。減衰期間中に1つのオブジェクトに複数の変更が発生した場合、更新レコードが作成された時点で有効な値のみが含まれます。ダンプニング期間は、更新レコードのアセンブリが完了するたびに有効になります。"
    },
    {
      "indent": 9,
      "text": "+ \"change-type\": This parameter can be used to reduce the types of datastore changes for which updates are sent (e.g., you might only send an update when an object is created or deleted, but not when an object value changes).",
      "ja": "+ \"change-type\"：このパラメーターは、更新が送信されるデータストアの変更の種類を減らすために使用できます（たとえば、オブジェクトの値が変更されたときではなく、オブジェクトが作成または削除されたときにのみ更新を送信できます）。"
    },
    {
      "indent": 9,
      "text": "+ \"sync-on-start\": This parameter defines whether or not a complete \"push-update\" (Section 3.7) of all subscribed data will be sent at the beginning of a subscription. Such early synchronization establishes the frame of reference for subsequent updates.",
      "ja": "+ 「sync-on-start」：このパラメーターは、サブスクリプションの開始時にすべてのサブスクライブされたデータの完全な「プッシュ更新」（セクション3.7）が送信されるかどうかを定義します。 このような早期同期により、後続の更新の参照フレームが確立されます。"
    },
    {
      "indent": 3,
      "text": "o An encoding (using anydata) for the contents of periodic and on-change push updates.",
      "ja": "o 定期的および変更時のプッシュ更新のコンテンツのエンコード（anydataを使用）。"
    },
    {
      "indent": 0,
      "text": "3.2. Negotiation of Subscription Policies",
      "section_title": true,
      "ja": "3.2. サブスクリプションポリシーの交渉"
    },
    {
      "indent": 3,
      "text": "A dynamic subscription request SHOULD be declined if a publisher determines that it may be unable to provide update records meeting the terms of an \"establish-subscription\" or \"modify-subscription\" RPC request. In this case, a subscriber may quickly follow up with a new RPC request using different parameters.",
      "ja": "パブリッシャーが「establish-subscription」または「modify-subscription」RPCリクエストの条件に合う更新レコードを提供できないと判断した場合、動的なサブスクリプションリクエストは拒否されるべきです。 この場合、サブスクライバーは、異なるパラメーターを使用して新しいRPC要求をすばやくフォローアップできます。"
    },
    {
      "indent": 3,
      "text": "Random guessing of different parameters by a subscriber is to be discouraged. Therefore, in order to minimize the number of subscription iterations between subscriber and publisher, a dynamic subscription supports a simple negotiation between subscribers and publishers for subscription parameters. This negotiation is in the form of supplemental information that should be inserted into error responses to a failed RPC request. This returned error response information, when considered, should increase the likelihood of success for subsequent RPC requests. Such hints include suggested periodic time intervals, acceptable dampening periods, and size estimates for the number of objects that would be returned from a proposed selection filter. However, there are no guarantees that subsequent requests that consider these hints will be accepted.",
      "ja": "加入者によるさまざまなパラメータのランダムな推測は推奨されません。 したがって、サブスクライバーとパブリッシャー間のサブスクリプションの反復回数を最小限にするために、動的サブスクリプションは、サブスクリプションパラメーターについてサブスクライバーとパブリッシャー間の単純なネゴシエーションをサポートしています。 このネゴシエーションは、RPC要求の失敗に対するエラー応答に挿入される補足情報の形式です。 返されたエラー応答情報を考慮すると、後続のRPC要求の成功の可能性が高くなります。 このようなヒントには、推奨される定期的な時間間隔、許容される減衰期間、および提案された選択フィルターから返されるオブジェクトの数のサイズ推定が含まれます。 ただし、これらのヒントを考慮した後続の要求が受け入れられるという保証はありません。"
    },
    {
      "indent": 0,
      "text": "3.3. On-Change Considerations",
      "section_title": true,
      "ja": "3.3. 変更時の考慮事項"
    },
    {
      "indent": 3,
      "text": "On-change subscriptions allow receivers to receive updates whenever changes to targeted objects occur. As such, on-change subscriptions are particularly effective for data that changes infrequently but for which applications need to be quickly notified, with minimal delay, whenever a change does occur.",
      "ja": "変更時サブスクリプションを使用すると、ターゲットオブジェクトが変更されるたびに受信者が更新を受信できます。 そのため、変更時サブスクリプションは、変更頻度が低いが、変更が発生するたびに最小限の遅延でアプリケーションに迅速に通知する必要があるデータに対して特に効果的です。"
    },
    {
      "indent": 3,
      "text": "On-change subscriptions tend to be more difficult to implement than periodic subscriptions. Accordingly, on-change subscriptions may not be supported by all implementations or for every object.",
      "ja": "変更時のサブスクリプションは、定期的なサブスクリプションよりも実装が難しい傾向があります。 したがって、変更時サブスクリプションは、すべての実装またはすべてのオブジェクトでサポートされているとは限りません。"
    },
    {
      "indent": 3,
      "text": "Whether or not to accept or reject on-change subscription requests when the scope of the subscription contains objects for which on-change is not supported is up to the publisher implementation. A publisher MAY accept an on-change subscription even when the scope of the subscription contains objects for which on-change is not supported. In that case, updates are sent only for those objects within the scope of the subscription that do support on-change updates, whereas other objects are excluded from update records, even if their values change. In order for a subscriber to determine whether objects support on-change subscriptions, objects are marked accordingly on a publisher. Accordingly, when subscribing, it is the responsibility of the subscriber to ensure that it is aware of which objects support on-change and which do not. For more on how objects are so marked, see Section 3.10.",
      "ja": "サブスクリプションのスコープに変更時がサポートされていないオブジェクトが含まれる場合、変更時のサブスクリプション要求を受け入れるか拒否するかは、パブリッシャーの実装次第です。 パブリッシャーは、サブスクリプションのスコープに変更時がサポートされていないオブジェクトが含まれている場合でも、変更時サブスクリプションを受け入れることができます。 その場合、更新は、変更時更新をサポートするサブスクリプションのスコープ内のオブジェクトに対してのみ送信されますが、他のオブジェクトは、値が変更されても更新レコードから除外されます。 サブスクライバーがオブジェクトが変更時サブスクリプションをサポートするかどうかを判断するために、オブジェクトはそれに応じてパブリッシャーでマークされます。 したがって、サブスクライブするとき、どのオブジェクトがオンチェンジをサポートし、どのオブジェクトがサポートしていないかを認識していることを確認するのは、サブスクライバーの責任です。 オブジェクトのマーク方法の詳細については、セクション3.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a publisher MAY decide to simply reject an on-change subscription if the scope of the subscription contains objects for which on-change is not supported. In the case of a configured subscription, the publisher MAY suspend the subscription.",
      "ja": "あるいは、パブリッシャーは、サブスクリプションの範囲に変更時がサポートされていないオブジェクトが含まれる場合、変更時のサブスクリプションを単に拒否することを決定する場合があります。 構成されたサブスクリプションの場合、パブリッシャーはサブスクリプションを一時停止する場合があります。"
    },
    {
      "indent": 3,
      "text": "To avoid flooding receivers with repeated updates for subscriptions containing fast-changing objects or objects with oscillating values, an on-change subscription allows for the definition of a dampening period. Once an update record for a given object is generated, no other updates for this particular subscription will be created until the end of the dampening period. Values sent at the end of the dampening period are the values that are current at the end of the dampening period of all changed objects. Changed objects include those objects that were deleted or newly created during that dampening period. If an object has returned to its original value (or even has been created and then deleted) during the dampening period, that value (and not the interim change) will still be sent. This will indicate that churn is occurring on that object.",
      "ja": "急速に変化するオブジェクトまたは変動する値を持つオブジェクトを含むサブスクリプションの繰り返し更新でレシーバーがフラッディングするのを防ぐために、オンチェンジサブスクリプションではダンプニング期間を定義できます。 特定のオブジェクトの更新レコードが生成されると、この特定のサブスクリプションの他の更新は、ダンプニング期間が終了するまで作成されません。 減衰期間の終わりに送信される値は、変更されたすべてのオブジェクトの減衰期間の終わりに現在の値です。 変更されたオブジェクトには、その減衰期間中に削除または新しく作成されたオブジェクトが含まれます。 減衰期間中にオブジェクトが元の値に戻った（または作成されてから削除された）場合でも、その値（中間変更ではなく）が送信されます。 これは、そのオブジェクトでチャーンが発生していることを示します。"
    },
    {
      "indent": 3,
      "text": "On-change subscriptions can be refined to let users subscribe only to certain types of changes. For example, a subscriber might only want object creations and deletions, but not modifications of object values.",
      "ja": "変更時のサブスクリプションを改良して、ユーザーが特定のタイプの変更のみをサブスクライブできるようにすることができます。 たとえば、サブスクライバーはオブジェクトの作成と削除のみを望み、オブジェクト値の変更は望みません。"
    },
    {
      "indent": 3,
      "text": "Putting it all together, the conceptual process for creating an update record as part of an on-change subscription is as follows:",
      "ja": "まとめると、変更時サブスクリプションの一部として更新レコードを作成するための概念的なプロセスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Just before a change, or at the start of a dampening period, evaluate any filtering and any access control rules to ensure that a receiver is authorized to view all subscribed datastore nodes (filtering out any nodes for which this is not the case). The result is a set \"A\" of datastore nodes and subtrees.",
      "ja": "1. 変更の直前、または減衰期間の開始時に、フィルタリングとアクセス制御ルールを評価して、受信者がサブスクライブされたすべてのデータストアノードを表示する権限を持っていることを確認します（そうでないノードは除外します）。 結果は、データストアノードとサブツリーのセット「A」です。"
    },
    {
      "indent": 3,
      "text": "2. Just after a change, or at the end of a dampening period, evaluate any filtering and any (possibly new) access control rules. The result is a set \"B\" of datastore nodes and subtrees.",
      "ja": "2. 変更の直後、または減衰期間の終わりに、フィルタリングと（おそらく新しい）アクセス制御ルールを評価します。 結果は、データストアノードとサブツリーのセット「B」です。"
    },
    {
      "indent": 3,
      "text": "3. Construct an update record, which takes the form of a YANG Patch record [RFC8072] for going from A to B.",
      "ja": "3. 更新レコードを作成します。これは、AからBに移動するためのYANGパッチレコード[RFC8072]の形式を取ります。"
    },
    {
      "indent": 3,
      "text": "4. If there were any changes made between A and B that canceled each other out, insert into the YANG Patch record the last change made, even if the new value is no different from the original value (since changes that were made in the interim were canceled out). If the changes involve creating a new datastore node and then deleting it, the YANG Patch record will indicate the deletion of the datastore node. Similarly, if the changes involve deleting a new datastore node and then recreating it, the YANG Patch record will indicate the creation of the datastore node.",
      "ja": "4. AとBの間に行われた変更が互いにキャンセルされた場合、新しい値が元の値と変わらない場合でも、YANGパッチレコードに最後に行われた変更を挿入します（暫定的に行われた変更はキャンセルされたため） でる）。 変更に新しいデータストアノードの作成と削除が含まれる場合、YANGパッチレコードはデータストアノードの削除を示します。 同様に、変更に新しいデータストアノードの削除と再作成が含まれる場合、YANGパッチレコードはデータストアノードの作成を示します。"
    },
    {
      "indent": 3,
      "text": "5. If the resulting YANG Patch record is non-empty, send it to the receiver.",
      "ja": "5. 結果のYANGパッチレコードが空でない場合は、受信者に送信します。"
    },
    {
      "indent": 3,
      "text": "Note: In cases where a subscriber wants to have separate dampening periods for different objects, the subscriber has the option to create multiple subscriptions with different selection filters.",
      "ja": "注：サブスクライバーがオブジェクトごとに別々のダンプニング期間を設定したい場合、サブスクライバーには、異なる選択フィルターを使用して複数のサブスクリプションを作成するオプションがあります。"
    },
    {
      "indent": 0,
      "text": "3.4. Reliability Considerations",
      "section_title": true,
      "ja": "3.4. 信頼性に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A subscription to updates from a datastore is intended to obviate the need for polling. However, in order to do so, it is critical that subscribers can rely on the subscription and have confidence that they will indeed receive the subscribed updates without having to worry about updates being silently dropped. In other words, a subscription constitutes a promise on the side of the publisher to provide the receivers with updates per the terms of the subscription.",
      "ja": "データストアからの更新のサブスクリプションは、ポーリングの必要性をなくすことを目的としています。 ただし、そうするためには、サブスクライバーがサブスクリプションに依存し、サイレントに更新がドロップされることを心配せずに、サブスクライブされた更新を実際に受信できるという自信を持つことが重要です。 つまり、サブスクリプションは、サブスクリプションの条件ごとに受信者に更新を提供するというパブリッシャー側の約束を構成します。"
    },
    {
      "indent": 3,
      "text": "Now, there are many reasons why a publisher may at some point no longer be able to fulfill the terms of the subscription, even if the subscription had been initiated in good faith. For example, the volume of datastore nodes may be larger than anticipated, the interval may prove too short to send full updates in rapid succession, or an internal problem may prevent objects from being collected. For this reason, the solution defined in this document (1) mandates that a publisher notify receivers immediately and reliably whenever it encounters a situation in which it is unable to keep the terms of the subscription and (2) provides the publisher with the option to suspend the subscription in such a case. This includes indicating the fact that an update is incomplete as part of a \"push-update\" or \"push-change-update\" notification, as well as emitting a \"subscription-suspended\" notification as applicable. This is described further in Section 3.11.1.",
      "ja": "現在、サブスクリプションが誠意を持って開始されたとしても、パブリッシャーがいつかサブスクリプションの条件を満たせなくなる可能性がある多くの理由があります。 たとえば、データストアノードのボリュームが予想よりも大きい場合、間隔が短すぎて完全な更新を連続して送信できない場合、または内部問題によりオブジェクトの収集が妨げられる場合があります。 このため、このドキュメントで定義されているソリューションは、（1）パブリッシャーがサブスクリプションの条件を維持できない状況に遭遇したときは常に、パブリッシャーがレシーバーに直ちに確実に通知することを義務付け、（2）パブリッシャーにオプションを提供します そのような場合はサブスクリプションを一時停止してください。 これには、更新が「push-update」または「push-change-update」通知の一部として不完全であることを示すこと、および「subscription-suspended」通知を適宜送信することが含まれます。 これについては、セクション3.11.1でさらに説明します。"
    },
    {
      "indent": 3,
      "text": "A publisher SHOULD reject a request for a subscription if it is unlikely that the publisher will be able to fulfill the terms of that subscription request. In such cases, it is preferable to have a subscriber request a less resource-intensive subscription than to deal with frequently degraded behavior.",
      "ja": "発行者は、発行者がそのサブスクリプション要求の条件を満たせる可能性が低い場合、サブスクリプションの要求を拒否する必要があります。 このような場合、頻繁に低下する動作を処理するよりも、リソースをあまり消費しないサブスクリプションをサブスクライバーに要求させることが望ましいです。"
    },
    {
      "indent": 3,
      "text": "The solution builds on [RFC8639]. As defined therein, any loss of an underlying transport connection will be detected and result in subscription termination (in the case of dynamic subscriptions) or suspension (in the case of configured subscriptions), ensuring that situations where the loss of update notifications would go unnoticed will not occur.",
      "ja": "ソリューションは[RFC8639]に基づいています。 ここで定義されているように、基になるトランスポート接続の損失が検出され、サブスクリプションの終了（動的サブスクリプションの場合）または一時停止（構成されたサブスクリプションの場合）が発生し、更新通知の損失が気付かれない状況を保証します 発生しません。"
    },
    {
      "indent": 0,
      "text": "3.5. Data Encodings",
      "section_title": true,
      "ja": "3.5. データエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.5.1. Periodic Subscriptions",
      "section_title": true,
      "ja": "3.5.1. 定期購読"
    },
    {
      "indent": 3,
      "text": "In a periodic subscription, the data included as part of an update record corresponds to data that could have been read using a retrieval operation.",
      "ja": "定期的なサブスクリプションでは、更新レコードの一部として含まれるデータは、取得操作を使用して読み取ることができたデータに対応します。"
    },
    {
      "indent": 0,
      "text": "3.5.2. On-Change Subscriptions",
      "section_title": true,
      "ja": "3.5.2. 変更時のサブスクリプション"
    },
    {
      "indent": 3,
      "text": "In an on-change subscription, update records need to indicate not only values of changed datastore nodes but also the types of changes that occurred since the last update. Therefore, encoding rules for data in on-change updates will generally follow YANG Patch operations as specified in [RFC8072]. The YANG Patch operations will describe what needs to be applied to the earlier state reported by the preceding update in order to result in the now-current state. Note that objects referred to in an update are not limited to configuration data but can include any objects (including operational data), whereas [RFC8072] patches apply only to configuration data in configuration datastores.",
      "ja": "変更時サブスクリプションでは、更新レコードは、変更されたデータストアノードの値だけでなく、最後の更新以降に発生した変更の種類も示す必要があります。 したがって、変更時の更新のデータのエンコード規則は、一般に[RFC8072]で指定されているYANGパッチ操作に従います。 YANGパッチ操作では、現在の状態に戻すために、前の更新で報告された以前の状態に適用する必要があるものを説明します。 [RFC8072]パッチは構成データストアの構成データにのみ適用されるのに対し、更新で参照されるオブジェクトは構成データに限定されず、任意のオブジェクト（運用データを含む）を含むことができます。"
    },
    {
      "indent": 3,
      "text": "A publisher indicates the type of change to a datastore node using the different YANG Patch operations: the \"create\" operation is used for newly created objects (except entries in a user-ordered list), the \"delete\" operation is used for deleted objects (including in user-ordered lists), the \"replace\" operation is used when only the object value changes, the \"insert\" operation is used when a new entry is inserted in a list, and the \"move\" operation is used when an existing entry in a user-ordered list is moved.",
      "ja": "パブリッシャーは、異なるYANGパッチ操作を使用して、データストアノードへの変更のタイプを示します。「作成」操作は、新しく作成されたオブジェクト（ユーザー順序リストのエントリを除く）に使用され、「削除」操作は、削除されたオブジェクトに使用されます （ユーザー順序リストを含む）、オブジェクト値のみが変更された場合に「置換」操作が使用され、リストに新しいエントリが挿入された場合に「挿入」操作が使用され、 ユーザーが指定したリストの既存のエントリが移動されます。"
    },
    {
      "indent": 3,
      "text": "However, a patch must be able to do more than just describe the delta from the previous state to the current state. As per Section 3.3, it must also be able to identify whether transient changes have occurred on an object during a dampening period. To support this, it is valid to encode a YANG Patch operation so that its application would result in no change between the previous state and the current state. This indicates that some churn has occurred on the object. An example of this would be a patch that indicates a \"create\" operation for a datastore node where the receiver believes one already exists or a \"replace\" operation that replaces a previous value with the same value. Note that this means that the \"create\" and \"delete\" errors as described in [RFC8072], Section 2.5 are not errors in the case of YANG-Push (i.e., they are considered valid operations for YANG-Push).",
      "ja": "ただし、パッチは、前の状態から現在の状態までの差分を記述するだけでなく、それ以上のことができる必要があります。 セクション3.3のように、減衰期間中にオブジェクトに一時的な変化が発生したかどうかも識別できる必要があります。 これをサポートするには、YANGパッチ操作をエンコードして、そのアプリケーションが前の状態と現在の状態の間で変化を起こさないようにすることが有効です。 これは、オブジェクトに何らかのチャーンが発生したことを示しています。 これの例は、レシーバーがすでに存在すると信じているデータストアノードの「作成」操作、または以前の値を同じ値に置き換える「置換」操作を示すパッチです。 これは、[RFC8072]セクション2.5で説明されている「作成」および「削除」エラーがYANG-Pushの場合のエラーではないことに注意してください（つまり、YANG-Pushの有効な操作と見なされます）。"
    },
    {
      "indent": 0,
      "text": "3.6. Defining the Selection with a Datastore",
      "section_title": true,
      "ja": "3.6. データストアを使用した選択の定義"
    },
    {
      "indent": 3,
      "text": "A subscription must specify both the selection filters and the datastore against which these selection filters will be applied. This information is used to choose and subsequently push data from the publisher's datastore to the receivers.",
      "ja": "サブスクリプションでは、選択フィルターと、これらの選択フィルターが適用されるデータストアの両方を指定する必要があります。 この情報は、パブリッシャーのデータストアからレシーバーにデータを選択してプッシュするために使用されます。"
    },
    {
      "indent": 3,
      "text": "Only a single selection filter can be applied to a subscription at a time. An RPC request proposing a new selection filter replaces any existing filter. The following selection filter types are included in the YANG-Push data model and may be applied against a datastore:",
      "ja": "サブスクリプションに一度に適用できる選択フィルターは1つだけです。 新しい選択フィルターを提案するRPC要求は、既存のフィルターを置き換えます。 次の選択フィルタータイプがYANG-Pushデータモデルに含まれており、データストアに対して適用できます。"
    },
    {
      "indent": 3,
      "text": "o subtree: A subtree selection filter identifies one or more datastore subtrees. When specified, update records will only come from the datastore nodes of selected datastore subtree(s). The syntax and semantics correspond to those specified in [RFC6241], Section 6.",
      "ja": "o サブツリー：サブツリー選択フィルターは、1つ以上のデータストアサブツリーを識別します。 指定すると、更新レコードは選択したデータストアサブツリーのデータストアノードからのみ取得されます。 構文とセマンティクスは、[RFC6241]、セクション6で指定されているものに対応しています。"
    },
    {
      "indent": 3,
      "text": "o xpath: An \"xpath\" selection filter is an XPath expression that returns a node set. (XPath is a query language for selecting nodes in an XML document; see [XPATH] for details.) When specified, updates will only come from the selected datastore nodes.",
      "ja": "o xpath：「xpath」選択フィルターは、ノードセットを返すXPath式です。 （XPathは、XMLドキュメント内のノードを選択するためのクエリ言語です。詳細については、[XPATH]を参照してください。）指定した場合、更新は選択したデータストアノードからのみ行われます。"
    },
    {
      "indent": 3,
      "text": "These filters are intended to be used as selectors that define which objects are within the scope of a subscription. A publisher MUST support at least one type of selection filter.",
      "ja": "これらのフィルターは、サブスクリプションの範囲内にあるオブジェクトを定義するセレクターとして使用することを目的としています。 発行者は、少なくとも1種類の選択フィルターをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "XPath itself provides powerful filtering constructs, and care must be used in filter definition. Consider an XPath filter that only passes a datastore node when an interface is up. It is up to the receiver to understand the implications of the presence or absence of objects in each update.",
      "ja": "XPath自体は強力なフィルタリング構造を提供するため、フィルター定義には注意が必要です。 インターフェイスが起動しているときにのみデータストアノードを渡すXPathフィルターを検討してください。 各更新におけるオブジェクトの有無の意味を理解するのは受信者次第です。"
    },
    {
      "indent": 3,
      "text": "When the set of selection-filtering criteria is applied for a periodic subscription, these criteria are applied whenever a periodic update record is constructed, and only datastore nodes that pass the filter and to which a receiver has access are provided to that receiver. If the same filtering criteria are applied to an on-change subscription, only the subset of those datastore nodes supporting on-change is provided. A datastore node that doesn't support on-change is never sent as part of an on-change subscription's \"push-update\" or \"push-change-update\" (Section 3.7).",
      "ja": "選択フィルタリング基準のセットが定期的なサブスクリプションに適用される場合、これらの基準は定期的な更新レコードが構築されるたびに適用され、フィルターを通過し、受信者がアクセスできるデータストアノードのみがその受信者に提供されます。 同じフィルタリング基準が変更時サブスクリプションに適用される場合、変更時をサポートするデータストアノードのサブセットのみが提供されます。 変更時をサポートしないデータストアノードは、変更時サブスクリプションの「プッシュ更新」または「プッシュ変更更新」の一部として送信されることはありません（セクション3.7）。"
    },
    {
      "indent": 0,
      "text": "3.7. Streaming Updates",
      "section_title": true,
      "ja": "3.7. ストリーミング更新"
    },
    {
      "indent": 3,
      "text": "Contrary to traditional data retrieval requests, datastore subscription enables an unbounded series of update records to be streamed over time. Two generic YANG notifications for update records have been defined for this scenario: \"push-update\" and \"push-change-update\".",
      "ja": "従来のデータ取得リクエストとは異なり、データストアサブスクリプションにより、無制限の一連の更新レコードを時間とともにストリーミングできます。 このシナリオでは、更新レコードの2つの一般的なYANG通知「push-update」と「push-change-update」が定義されています。"
    },
    {
      "indent": 3,
      "text": "A \"push-update\" notification defines a complete, filtered update of the datastore per the terms of a subscription. This type of YANG notification is used for continuous updates of periodic subscriptions. A \"push-update\" notification can also be used for the on-change subscriptions in two cases. First, it MUST be used as the initial \"push-update\" if there is a need to synchronize the receiver at the start of a new subscription. Second, it MAY be sent if the publisher later chooses to resync an on-change subscription. The \"push-update\" update record contains an instantiated datastore subtree with all of the subscribed contents. The content of the update record is equivalent to the contents that would be obtained had the same data been explicitly retrieved using a datastore retrieval operation using the same transport with the same filters applied.",
      "ja": "「プッシュ更新」通知は、サブスクリプションの条件ごとに、データストアの完全なフィルター更新を定義します。 このタイプのYANG通知は、定期的なサブスクリプションの継続的な更新に使用されます。 「プッシュ更新」通知は、2つの場合の変更時サブスクリプションにも使用できます。 最初に、新しいサブスクリプションの開始時に受信者を同期する必要がある場合、最初の「プッシュ更新」として使用する必要があります。 第二に、パブリッシャーが後で変更時サブスクリプションを再同期することを選択した場合に送信される場合があります。 「プッシュ更新」更新レコードには、サブスクライブされたすべてのコンテンツを持つインスタンス化されたデータストアサブツリーが含まれます。 更新レコードのコンテンツは、同じフィルターが適用された同じトランスポートを使用したデータストア取得操作を使用して同じデータが明示的に取得された場合に取得されるコンテンツと同等です。"
    },
    {
      "indent": 3,
      "text": "A \"push-change-update\" notification is the most common type of update for on-change subscriptions. The update record in this case contains the set of changes that datastore nodes have undergone since the last notification message. In other words, this indicates which datastore nodes have been created, have been deleted, or have had changes to their values. In cases where multiple changes have occurred over the course of a dampening period and the object has not been deleted, the object's most current value is reported. (In other words, for each object, only one change is reported, not its entire history. Doing so would defeat the purpose of the dampening period.)",
      "ja": "「プッシュ変更更新」通知は、変更時サブスクリプションの更新の最も一般的なタイプです。 この場合の更新レコードには、最後の通知メッセージ以降にデータストアノードが受けた一連の変更が含まれます。 つまり、これは、どのデータストアノードが作成されたか、削除されたか、値が変更されたかを示します。 減衰期間中に複数の変更が発生し、オブジェクトが削除されていない場合、オブジェクトの最新の値が報告されます。 （つまり、各オブジェクトについて、履歴全体ではなく、1つの変更のみが報告されます。そうすると、減衰期間の目的が損なわれます。）"
    },
    {
      "indent": 3,
      "text": "\"push-update\" and \"push-change-update\" are encoded and placed in notification messages and are ultimately queued for egress over the specified transport.",
      "ja": "「push-update」および「push-change-update」はエンコードされて通知メッセージに入れられ、最終的には指定されたトランスポートを介した出力用にキューに入れられます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 provides an example of a notification message for a subscription tracking the operational status of a single Ethernet interface (per [RFC8343]). This notification message is encoded XML [W3C.REC-xml-20081126] over the Network Configuration Protocol (NETCONF) as per [RFC8640].",
      "ja": "図1は、単一のイーサネットインターフェイスの動作ステータスを追跡するサブスクリプションの通知メッセージの例を示しています（[RFC8343]による）。 この通知メッセージは、[RFC8640]に従ってネットワーク構成プロトコル（NETCONF）でXML [W3C.REC-xml-20081126]でエンコードされています。"
    },
    {
      "indent": 2,
      "text": "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n <eventTime>2017-10-25T08:00:11.22Z</eventTime>\n <push-update xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n   <id>1011</id>\n   <datastore-contents>\n      <interfaces xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\">\n       <interface>\n         <name>eth0</name>\n         <oper-status>up</oper-status>\n       </interface>\n     </interfaces>\n   </datastore-contents>\n </push-update>\n</notification>",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 1: Push Example",
      "ja": "図1：プッシュの例"
    },
    {
      "indent": 3,
      "text": "Figure 2 provides an example of an on-change notification message for the same subscription.",
      "ja": "図2は、同じサブスクリプションの変更時通知メッセージの例を示しています。"
    },
    {
      "indent": 2,
      "text": "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n <eventTime>2017-10-25T08:22:33.44Z</eventTime>\n <push-change-update\n      xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n   <id>89</id>\n   <datastore-changes>\n     <yang-patch>\n       <patch-id>0</patch-id>\n       <edit>\n         <edit-id>edit1</edit-id>\n         <operation>replace</operation>\n         <target>/ietf-interfaces:interfaces</target>\n         <value>\n           <interfaces\n                xmlns=\"urn:ietf:params:xml:ns:yang:ietf-interfaces\">\n             <interface>\n               <name>eth0</name>\n               <oper-status>down</oper-status>\n             </interface>\n           </interfaces>\n         </value>\n       </edit>\n     </yang-patch>\n   </datastore-changes>\n </push-change-update>\n</notification>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 2: Push Example for an On-Change Notification Message",
      "ja": "図2：変更時通知メッセージのプッシュ例"
    },
    {
      "indent": 3,
      "text": "Of note in the above example is the \"patch-id\" with a value of \"0\". Per [RFC8072], the \"patch-id\" is an arbitrary string. With YANG-Push, the publisher SHOULD put into the \"patch-id\" a counter starting at \"0\" that increments with every \"push-change-update\" generated for a subscription. If used as a counter, this counter MUST be reset to \"0\" any time a resynchronization occurs (i.e., with the sending of a \"push-update\"). Also, if used as a counter, the counter MUST be reset to \"0\" after passing a maximum value of \"4294967295\" (i.e., the maximum value that can be represented using the uint32 data type). Such a mechanism allows easy identification of lost or out-of-sequence update records.",
      "ja": "上記の例で注目すべきは、値が「0」の「patch-id」です。 [RFC8072]によれば、「パッチID」は任意の文字列です。 YANG-Pushでは、パブリッシャーは、サブスクリプションに対して生成されるすべての「プッシュ変更更新」で増分する「0」で始まるカウンターを「パッチID」に入れる必要があります。 カウンタとして使用する場合、このカウンタは、再同期が発生するたびに「0」にリセットする必要があります（つまり、「プッシュ更新」の送信）。 また、カウンターとして使用する場合、「4294967295」の最大値（つまり、uint32データ型を使用して表現できる最大値）を渡した後、カウンターを「0」にリセットする必要があります。 このようなメカニズムにより、更新レコードの紛失や順不同を簡単に識別できます。"
    },
    {
      "indent": 0,
      "text": "3.8. Subscription Management",
      "section_title": true,
      "ja": "3.8. サブスクリプション管理"
    },
    {
      "indent": 3,
      "text": "The RPCs defined in [RFC8639] have been enhanced to support datastore subscription negotiation. Also, new error codes have been added that are able to indicate why a datastore subscription attempt has failed, along with new yang-data that MAY be used to include details on input parameters that might result in a successful subsequent RPC invocation.",
      "ja": "[RFC8639]で定義されているRPCは、データストアサブスクリプションネゴシエーションをサポートするように強化されています。 また、データストアサブスクリプションの試行が失敗した理由を示すことができる新しいエラーコードが追加されました。また、後続のRPC呼び出しが成功する可能性のある入力パラメーターの詳細を含めるために使用される新しいyang-dataがあります。"
    },
    {
      "indent": 3,
      "text": "The establishment or modification of a datastore subscription can be rejected for multiple reasons, including a subtree request that is too large or the inability of the publisher to push update records as frequently as requested. In such cases, no subscription is established. Instead, a subscription result that includes the reason for the failure is returned as part of the RPC response. As part of this response, a set of alternative subscription parameters MAY be returned that would likely have resulted in acceptance of the subscription request. The subscriber may consider including such parameters in future subscription attempts.",
      "ja": "データストアサブスクリプションの確立または変更は、大きすぎるサブツリーリクエストや、パブリッシャが要求された頻度で更新レコードをプッシュできないなど、さまざまな理由で拒否される可能性があります。 そのような場合、サブスクリプションは確立されません。 代わりに、失敗の理由を含むサブスクリプションの結果がRPC応答の一部として返されます。 この応答の一部として、サブスクリプション要求の受け入れにつながる可能性が高い代替サブスクリプションパラメーターのセットが返される場合があります。 サブスクライバーは、将来のサブスクリプション試行でそのようなパラメーターを含めることを検討する場合があります。"
    },
    {
      "indent": 3,
      "text": "In the case of a rejected request for establishment of a datastore subscription, if there are hints, the hints SHOULD be transported in a yang-data \"establish-subscription-datastore-error-info\" container inserted into the RPC error response, in lieu of the \"establish-subscription-stream-error-info\" that is inserted in the case of a stream subscription.",
      "ja": "データストアサブスクリプションの確立に対する拒否されたリクエストの場合、ヒントがある場合、ヒントはRPCエラー応答に挿入されたyang-data \"establish-subscription-datastore-error-info\"コンテナで転送する必要があります。 ストリームサブスクリプションの場合に挿入される「establish-subscription-stream-error-info」の。"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows a tree diagram for \"establish-subscription-datastore-error-info\". All tree diagrams used in this document follow the notation defined in [RFC8340].",
      "ja": "図3は、「establish-subscription-datastore-error-info」のツリー図を示しています。 このドキュメントで使用されるすべてのツリー図は、[RFC8340]で定義された表記法に従います。"
    },
    {
      "indent": 10,
      "text": "yang-data establish-subscription-datastore-error-info\n  +--ro establish-subscription-datastore-error-info\n     +--ro reason?                identityref\n     +--ro period-hint?           centiseconds\n     +--ro filter-failure-hint?   string\n     +--ro object-count-estimate? uint32\n     +--ro object-count-limit?    uint32\n     +--ro kilobytes-estimate?    uint32\n     +--ro kilobytes-limit?       uint32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3: \"establish-subscription-datastore-error-info\" Tree Diagram Similarly, in the case of a rejected request for modification of a datastore subscription, if there are hints, the hints SHOULD be transported in a yang-data \"modify-subscription-datastore-error-info\" container inserted into the RPC error response, in lieu of the \"modify-subscription-stream-error-info\" that is inserted in the case of a stream subscription.",
      "ja": "図3：「establish-subscription-datastore-error-info」ツリー図同様に、データストアサブスクリプションの変更要求が拒否された場合、ヒントがあれば、そのヒントはyang-data \"modify- ストリームサブスクリプションの場合に挿入される「modify-subscription-stream-error-info」の代わりに、RPCエラー応答に挿入されるsubscription-datastore-error-info」コンテナ。"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows a tree diagram for \"modify-subscription-datastore-error-info\".",
      "ja": "図4は、「modify-subscription-datastore-error-info」のツリー図を示しています。"
    },
    {
      "indent": 10,
      "text": "yang-data modify-subscription-datastore-error-info\n  +--ro modify-subscription-datastore-error-info\n     +--ro reason?                identityref\n     +--ro period-hint?           centiseconds\n     +--ro filter-failure-hint?   string\n     +--ro object-count-estimate? uint32\n     +--ro object-count-limit?    uint32\n     +--ro kilobytes-estimate?    uint32\n     +--ro kilobytes-limit?       uint32",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 4: \"modify-subscription-datastore-error-info\" Tree Diagram",
      "ja": "図4：「modify-subscription-datastore-error-info」ツリー図"
    },
    {
      "indent": 0,
      "text": "3.9. Receiver Authorization",
      "section_title": true,
      "ja": "3.9. 受信者認証"
    },
    {
      "indent": 3,
      "text": "A receiver of subscription data MUST only be sent updates for which it has proper authorization. A publisher MUST ensure that no unauthorized data is included in push updates. To do so, it needs to apply all corresponding checks applicable at the time of a specific pushed update and, if necessary, silently remove any unauthorized data from datastore subtrees. This enables YANG data that is pushed based on subscriptions to be authorized in a way that is equivalent to a regular data retrieval (\"get\") operation.",
      "ja": "サブスクリプションデータの受信者には、適切な承認がある更新のみを送信する必要があります。 発行者は、不正なデータがプッシュ更新に含まれないようにする必要があります。 これを行うには、特定のプッシュ更新時に適用可能なすべての対応するチェックを適用し、必要に応じて、データストアサブツリーから無許可のデータを静かに削除する必要があります。 これにより、サブスクリプションに基づいてプッシュされるYANGデータを、通常のデータ取得（ \"get\"）操作と同等の方法で承認できます。"
    },
    {
      "indent": 3,
      "text": "Each \"push-update\" and \"push-change-update\" MUST have access control applied, as depicted in Figure 5. This includes validating that read access is permitted for any new objects selected since the last notification message was sent to a particular receiver. A publisher MUST silently omit data nodes from the results that the client is not authorized to see. To accomplish this, implementations SHOULD apply the conceptual authorization model of [RFC8341], specifically Section 3.2.4, extended to apply analogously to data nodes included in notifications, not just <rpc-reply> messages sent in response to <get> and <get-config> requests.",
      "ja": "図5に示すように、各「push-update」および「push-change-update」にはアクセス制御を適用する必要があります。これには、最後の通知メッセージが特定の受信者に送信されてから選択された新しいオブジェクトに対して読み取りアクセスが許可されていることの検証が含まれます 。 出版社は、クライアントが見ることを許可されていない結果からデータノードを静かに省略しなければなりません。 これを実現するために、実装は[RFC8341]の概念承認モデル、特にセクション3.2.4を適用する必要があります。これは、<get>および<に応答して送信される<rpc-reply>メッセージだけでなく、通知に含まれるデータノードにも同様に適用されるように拡張されています get-config>リクエスト。"
    },
    {
      "indent": 4,
      "text": "                     +-----------------+      +--------------------+\n push-update or -->  | datastore node  |  yes | add datastore node |\npush-change-update   | access allowed? | ---> | to update record   |\n                     +-----------------+      +--------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 5: Access Control for Push Updates",
      "ja": "図5：プッシュ更新のアクセス制御"
    },
    {
      "indent": 3,
      "text": "A publisher MUST allow for the possibility that a subscription's selection filter references nonexistent data or data that a receiver is not allowed to access. Such support permits a receiver the ability to monitor the entire lifecycle of some datastore tree without needing to explicitly enumerate every individual datastore node. If, after access control has been applied, there are no objects remaining in an update record, then the effect varies given if the subscription is a periodic or on-change subscription. For a periodic subscription, an empty \"push-update\" notification MUST be sent, so that clients do not get confused into thinking that an update was lost. For an on-change subscription, a \"push-update\" notification MUST NOT be sent, so that clients remain unaware of changes made to nodes they don't have read-access for. By the same token, changes to objects that are filtered MUST NOT affect any dampening intervals.",
      "ja": "発行者は、サブスクリプションの選択フィルターが存在しないデータまたは受信者がアクセスを許可されていないデータを参照する可能性を考慮しなければなりません。 このようなサポートにより、受信者は、個々のデータストアノードを明示的に列挙する必要なく、データストアツリーのライフサイクル全体を監視できます。 アクセス制御が適用された後、更新レコードにオブジェクトが残っていない場合、サブスクリプションが定期的または変更中のサブスクリプションである場合、その効果は異なります。 定期的なサブスクリプションの場合、クライアントが更新が失われたと誤解しないように、空の「プッシュ更新」通知を送信する必要があります。 変更時サブスクリプションの場合、クライアントが読み取りアクセス権を持たないノードに加えられた変更を認識しないように、「プッシュ更新」通知を送信してはなりません。 同様に、フィルタリングされるオブジェクトへの変更は、減衰間隔に影響してはなりません。"
    },
    {
      "indent": 3,
      "text": "A publisher MAY choose to reject an \"establish-subscription\" request that selects nonexistent data or data that a receiver is not allowed to access. The error identity \"unchanging-selection\" SHOULD be returned as the reason for the rejection. In addition, a publisher MAY choose to terminate a dynamic subscription or suspend a configured receiver when the authorization privileges of a receiver change or the access controls for subscribed objects change. In that case, the publisher SHOULD include the error identity \"unchanging-selection\" as the reason when sending the \"subscription-terminated\" or \"subscription-suspended\" notification, respectively. Such a capability enables the publisher to avoid having to support continuous and total filtering of a subscription's content for every update record. It also reduces the possibility of leakage of access-controlled objects.",
      "ja": "発行者は、存在しないデータまたは受信者がアクセスを許可されていないデータを選択する「サブスクリプションの確立」要求を拒否することを選択できます。 エラーID「不変の選択」が拒否の理由として返されるべきである（SHOULD）。 さらに、パブリッシャーは、受信者の許可特権が変更されたとき、またはサブスクライブされたオブジェクトのアクセス制御が変更されたときに、動的サブスクリプションを終了するか、構成済みのレシーバーを一時停止することを選択できます。 その場合、パブリッシャーは、「サブスクリプション終了」または「サブスクリプション中断」通知をそれぞれ送信する際に、エラーID「変更なし選択」を理由として含める必要があります。 このような機能により、パブリッシャーは、更新レコードごとにサブスクリプションのコンテンツの継続的かつ完全なフィルタリングをサポートする必要を回避できます。 また、アクセス制御されたオブジェクトの漏洩の可能性を減らします。"
    },
    {
      "indent": 3,
      "text": "If read access into previously accessible nodes has been lost due to a receiver permissions change, this SHOULD be reported as a patch \"delete\" operation for on-change subscriptions. If not capable of handling such receiver permission changes with such a \"delete\", publisher implementations MUST force dynamic subscription re-establishment or configured subscription reinitialization so that appropriate filtering is installed.",
      "ja": "受信者のアクセス許可の変更により、以前にアクセス可能なノードへの読み取りアクセスが失われた場合、これは変更時サブスクリプションのパッチ「削除」操作として報告される必要があります。 そのような「削除」でそのような受信者許可の変更を処理できない場合、パブリッシャー実装は、適切なフィルタリングがインストールされるように、動的なサブスクリプションの再確立または構成されたサブスクリプションの再初期化を強制しなければなりません"
    },
    {
      "indent": 0,
      "text": "3.10. On-Change Notifiable Datastore Nodes",
      "section_title": true,
      "ja": "3.10. 変更時の通知可能なデータストアノード"
    },
    {
      "indent": 3,
      "text": "In some cases, a publisher supporting on-change notifications may not be able to push on-change updates for some object types. Reasons for this might be that the value of the datastore node changes frequently (e.g., the in-octets counter as defined in [RFC8343]), small object changes are frequent and meaningless (e.g., a temperature gauge changing 0.1 degrees), or the implementation is not capable of on-change notification for a particular object.",
      "ja": "場合によっては、変更時通知をサポートしている発行者が、一部のオブジェクトタイプの変更時更新をプッシュできないことがあります。 これの理由は、データストアノードの値が頻繁に変化する（たとえば、[RFC8343]で定義されているオクテット内カウンター）、小さなオブジェクトの変化が頻繁で無意味である（たとえば、温度ゲージが0.1度変化する）、または 実装では、特定のオブジェクトの変更時通知ができません。"
    },
    {
      "indent": 3,
      "text": "In those cases, it will be important for client applications to have a way to identify for which objects on-change notifications are supported and for which ones they are not supported. Otherwise, client applications will have no way of knowing whether they can indeed rely on their on-change subscription to provide them with the change updates that they are interested in. In other words, if implementations do not provide a solution and do not support comprehensive on-change notifiability, clients of those implementations will have no way of knowing what their on-change subscription actually covers.",
      "ja": "そのような場合、クライアントアプリケーションは、どのオブジェクトの変更通知がサポートされているか、どのオブジェクトがサポートされていないかを識別する方法を持つことが重要になります。 そうしないと、クライアントアプリケーションは、関心のある変更の更新を提供するために、変更時のサブスクリプションに実際に依存できるかどうかを知る方法がありません。 変更時の通知可能性では、これらの実装のクライアントは、変更時サブスクリプションが実際にカバーするものを知る方法がありません。"
    },
    {
      "indent": 3,
      "text": "Implementations are therefore strongly advised to provide a solution to this problem. One solution might involve making discoverable to clients which objects are on-change notifiable, specified using another YANG data model. Such a solution is specified in [Yang-Push-Notif-Cap]. Until this solution is standardized, implementations SHOULD provide their own solution.",
      "ja": "したがって、実装では、この問題の解決策を提供することを強くお勧めします。 1つの解決策は、別のYANGデータモデルを使用して指定される、変更時に通知可能なオブジェクトをクライアントに検出可能にすることです。 このようなソリューションは、[Yang-Push-Notif-Cap]で指定されています。 このソリューションが標準化されるまで、実装は独自のソリューションを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.11. Other Considerations",
      "section_title": true,
      "ja": "3.11. その他の考慮事項"
    },
    {
      "indent": 0,
      "text": "3.11.1. Robustness and Reliability",
      "section_title": true,
      "ja": "3.11.1. 堅牢性と信頼性"
    },
    {
      "indent": 3,
      "text": "It is important that updates as discussed in this document, and on-change updates in particular, do not get lost. If the loss of an update is unavoidable, it is critical that the receiver be notified accordingly.",
      "ja": "このドキュメントで説明されている更新、特に変更時の更新が失われないようにすることが重要です。 更新の損失が避けられない場合、それに応じて受信者に通知することが重要です。"
    },
    {
      "indent": 3,
      "text": "Update records for a single subscription MUST NOT be resequenced prior to transport.",
      "ja": "単一のサブスクリプションの更新レコードは、トランスポートの前に再配列してはなりません。"
    },
    {
      "indent": 3,
      "text": "It is conceivable that, under certain circumstances, a publisher will recognize that it is unable to include in an update record the full set of objects desired per the terms of a subscription. In this case, the publisher MUST act as follows.",
      "ja": "特定の状況では、パブリッシャーは、サブスクリプションの条件ごとに必要なオブジェクトの完全なセットを更新レコードに含めることができないことを認識すると考えられます。 この場合、発行者は次のように行動する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The publisher MUST set the \"incomplete-update\" flag on any update record that is known to be missing information.",
      "ja": "o 発行者は、情報が欠落していることがわかっている更新レコードに「不完全更新」フラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The publisher MAY choose to suspend the subscription as per [RFC8639]. If the publisher does not create an update record at all, it MUST suspend the subscription.",
      "ja": "o 発行者は、[RFC8639]に従ってサブスクリプションを一時停止することを選択できます。 パブリッシャーが更新レコードをまったく作成しない場合、サブスクリプションを中断する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When resuming an on-change subscription, the publisher SHOULD generate a complete patch from the previous update record. If this is not possible and the \"sync-on-start\" option is set to \"true\" for the subscription, then the full datastore contents MAY be sent via a \"push-update\" instead (effectively replacing the previous contents). If neither scenario above is possible, then an \"incomplete-update\" flag MUST be included on the next \"push-change-update\".",
      "ja": "o 変更時のサブスクリプションを再開する場合、パブリッシャーは以前の更新レコードから完全なパッチを生成する必要があります。 これが不可能で、サブスクリプションの「sync-on-start」オプションが「true」に設定されている場合、代わりに「push-update」を介して完全なデータストアのコンテンツを送信できます（以前のコンテンツを効果的に置き換えます）。 上記のどちらのシナリオも可能でない場合、次の「push-change-update」に「incomplete-update」フラグを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: It is perfectly acceptable to have a series of \"push-change-update\" notifications (and even \"push-update\" notifications) serially queued at the transport layer awaiting transmission. It is not required for the publisher to merge pending update records sent at the same time.",
      "ja": "注：一連の「プッシュ変更更新」通知（および「プッシュ更新」通知でさえも）が送信を待機しているトランスポート層で連続してキューに入れられることは完全に受け入れられます。 パブリッシャーが同時に送信された保留中の更新レコードをマージする必要はありません。"
    },
    {
      "indent": 3,
      "text": "On the receiver side, what action to take when a record with an \"incomplete-update\" flag is received depends on the application. It could simply choose to wait and do nothing. It could choose to resync, actively retrieving all subscribed information. It could also choose to tear down the subscription and start a new one, perhaps with a smaller scope that contains fewer objects.",
      "ja": "受信側では、「不完全な更新」フラグを持つレコードを受信したときに実行するアクションは、アプリケーションによって異なります。 待つだけで何もしないことを選択できます。 再同期を選択して、購読しているすべての情報を積極的に取得できます。 また、サブスクリプションを破棄して新しいサブスクリプションを開始することもできます。おそらく、より少ないオブジェクトを含むより小さなスコープで。"
    },
    {
      "indent": 0,
      "text": "3.11.2. Publisher Capacity",
      "section_title": true,
      "ja": "3.11.2. パブリッシャー容量"
    },
    {
      "indent": 3,
      "text": "It is far preferable to decline a subscription request than to accept such a request when it cannot be met.",
      "ja": "サブスクリプションリクエストは、満たせない場合にそのようなリクエストを受け入れるよりも断る方がはるかに望ましいです。"
    },
    {
      "indent": 3,
      "text": "Whether or not a subscription can be supported will be determined by a combination of several factors, such as the subscription update trigger (on-change or periodic), the period in which to report changes (one-second periods will consume more resources than one-hour periods), the amount of data in the datastore subtree that is being subscribed to, and the number and combination of other subscriptions that are concurrently being serviced.",
      "ja": "サブスクリプションをサポートできるかどうかは、サブスクリプション更新トリガー（変更時または定期的）、変更を報告する期間（1秒の期間は1つ以上のリソースを消費するなど）のいくつかの要因の組み合わせによって決定されます -時間）、サブスクライブされているデータストアサブツリーのデータ量、および同時にサービスされている他のサブスクリプションの数と組み合わせ。"
    },
    {
      "indent": 0,
      "text": "4. A YANG Data Model for Management of Datastore Push Subscriptions",
      "section_title": true,
      "ja": "4. データストアプッシュサブスクリプションの管理のためのYANGデータモデル"
    },
    {
      "indent": 0,
      "text": "4.1. Overview",
      "section_title": true,
      "ja": "4.1. 概要"
    },
    {
      "indent": 3,
      "text": "The YANG data model for datastore push subscriptions is depicted in Figures 6 through 9. The tree diagram that is used follows the notation defined in [RFC8340]. New schema objects defined here (i.e., beyond those from [RFC8639]) are identified with \"yp\". For the reader's convenience, in order to compact the tree representation, some nodes that are defined in the ietf-subscribed-notifications YANG module [RFC8639] and therefore are not essential to the understanding of the data model defined here have been removed. This is indicated by \"...\" in the diagram where applicable.",
      "ja": "データストアプッシュサブスクリプションのYANGデータモデルを図6〜9に示します。使用されるツリー図は、[RFC8340]で定義されている表記法に従います。 ここで定義された新しいスキーマオブジェクト（つまり、[RFC8639]のオブジェクトを超える）は、「yp」で識別されます。 読者の便宜のために、ツリー表現をコンパクトにするために、ietf-subscribed-notifications YANGモジュール[RFC8639]で定義されているため、ここで定義されたデータモデルの理解に不可欠ではないノードを削除しました。 これは、該当する場合、図の「...」で示されます。"
    },
    {
      "indent": 3,
      "text": "Because the tree diagram is quite large, its depiction is broken up into four figures. Figure 6 depicts the augmentations that are introduced in YANG module ietf-yang-push to the subscription configuration specified in YANG module ietf-subscribed-notifications.",
      "ja": "ツリー図は非常に大きいため、その図は4つの図に分かれています。 図6は、YANGモジュールietf-yang-pushで、YANGモジュールietf-subscribed-notificationsで指定されたサブスクリプション構成に導入された拡張機能を示しています。"
    },
    {
      "indent": 3,
      "text": "module: ietf-subscribed-notifications\n  ...\n  +--rw filters\n  |  ...\n  |  +--rw yp:selection-filter* [filter-id]\n  |     +--rw yp:filter-id                   string\n  |     +--rw (yp:filter-spec)?\n  |        +--:(yp:datastore-subtree-filter)\n  |        |  +--rw yp:datastore-subtree-filter?   <anydata>\n  |        |          {sn:subtree}?\n  |        +--:(yp:datastore-xpath-filter)\n  |           +--rw yp:datastore-xpath-filter?     yang:xpath1.0\n  |                   {sn:xpath}?\n  +--rw subscriptions\n     +--rw subscription* [id]\n        |  ...\n        +--rw (target)\n        |  +--:(stream)\n        |  |   ...\n        |  +--:(yp:datastore)\n        |     +--rw yp:datastore                     identityref\n        |     +--rw (yp:selection-filter)?\n        |        +--:(yp:by-reference)\n        |        |  +--rw yp:selection-filter-ref\n        |        |          selection-filter-ref\n        |        +--:(yp:within-subscription)\n        |           +--rw (yp:filter-spec)?\n        |              +--:(yp:datastore-subtree-filter)\n        |              |  +--rw yp:datastore-subtree-filter?\n        |              |          <anydata> {sn:subtree}?\n        |              +--:(yp:datastore-xpath-filter)\n        |                 +--rw yp:datastore-xpath-filter?\n        |                         yang:xpath1.0 {sn:xpath}?\n        | ...\n        +--rw (yp:update-trigger)\n           +--:(yp:periodic)\n           |  +--rw yp:periodic!\n           |     +--rw yp:period         centiseconds\n           |     +--rw yp:anchor-time?   yang:date-and-time\n           +--:(yp:on-change) {on-change}?\n              +--rw yp:on-change!\n                 +--rw yp:dampening-period?   centiseconds\n                 +--rw yp:sync-on-start?      boolean\n                 +--rw yp:excluded-change*    change-type",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 6: Data Model Structure: Subscription Configuration",
      "ja": "図6：データモデル構造：サブスクリプション構成"
    },
    {
      "indent": 3,
      "text": "Figure 7 depicts the augmentations of YANG module ietf-yang-push made to RPCs specified in YANG module ietf-subscribed-notifications [RFC8639]. Specifically, these augmentations concern the \"establish-subscription\" and \"modify-subscription\" RPCs, which are augmented with parameters that are needed to specify datastore push subscriptions.",
      "ja": "図7は、YANGモジュールietf-subscribed-notifications [RFC8639]で指定されたRPCに対して行われたYANGモジュールietf-yang-pushの拡張を示しています。 具体的には、これらの拡張機能は、データストアプッシュサブスクリプションを指定するために必要なパラメーターで拡張された「サブスクリプションの確立」および「サブスクリプションの変更」RPCに関係します。"
    },
    {
      "indent": 5,
      "text": "rpcs:\n  +---x establish-subscription\n  |  +---w input\n  |  |  ...\n  |  |  +---w (target)\n  |  |  |  +--:(stream)\n  |  |  |  |  ...\n  |  |  |  +--:(yp:datastore)\n  |  |  |     +---w yp:datastore                   identityref\n  |  |  |     +---w (yp:selection-filter)?\n  |  |  |        +--:(yp:by-reference)\n  |  |  |        |  +---w yp:selection-filter-ref\n  |  |  |        |          selection-filter-ref\n  |  |  |        +--:(yp:within-subscription)\n  |  |  |           +---w (yp:filter-spec)?\n  |  |  |              +--:(yp:datastore-subtree-filter)\n  |  |  |              |  +---w yp:datastore-subtree-filter?\n  |  |  |              |          <anydata> {sn:subtree}?\n  |  |  |              +--:(yp:datastore-xpath-filter)\n  |  |  |                 +---w yp:datastore-xpath-filter?\n  |  |  |                         yang:xpath1.0 {sn:xpath}?\n  |  |  | ...\n  |  |  +---w (yp:update-trigger)\n  |  |     +--:(yp:periodic)\n  |  |     |  +---w yp:periodic!\n  |  |     |     +---w yp:period         centiseconds\n  |  |     |     +---w yp:anchor-time?   yang:date-and-time\n  |  |     +--:(yp:on-change) {on-change}?\n  |  |        +---w yp:on-change!\n  |  |           +---w yp:dampening-period?   centiseconds\n  |  |           +---w yp:sync-on-start?      boolean\n  |  |           +---w yp:excluded-change*    change-type\n  |  +--ro output\n  |     +--ro id                            subscription-id\n  |     +--ro replay-start-time-revision?   yang:date-and-time\n  |             {replay}?",
      "raw": true
    },
    {
      "indent": 7,
      "text": "+---x modify-subscription\n|  +---w input\n|     ...\n|     +---w (target)\n|     |  ...\n|     |  +--:(yp:datastore)\n|     |     +---w yp:datastore                   identityref\n|     |     +---w (yp:selection-filter)?\n|     |        +--:(yp:by-reference)\n|     |        |  +---w yp:selection-filter-ref\n|     |        |          selection-filter-ref\n|     |        +--:(yp:within-subscription)\n|     |           +---w (yp:filter-spec)?\n|     |              +--:(yp:datastore-subtree-filter)\n|     |              |  +---w yp:datastore-subtree-filter?\n|     |              |          <anydata> {sn:subtree}?\n|     |              +--:(yp:datastore-xpath-filter)\n|     |                 +---w yp:datastore-xpath-filter?\n|     |                         yang:xpath1.0 {sn:xpath}?\n|     | ...\n|     +---w (yp:update-trigger)\n|        +--:(yp:periodic)\n|        |  +---w yp:periodic!\n|        |     +---w yp:period         centiseconds\n|        |     +---w yp:anchor-time?   yang:date-and-time\n|        +--:(yp:on-change) {on-change}?\n|           +---w yp:on-change!\n|              +---w yp:dampening-period?   centiseconds\n+---x delete-subscription\n|  ...\n+---x kill-subscription\n   ...",
      "raw": true
    },
    {
      "indent": 5,
      "text": "yang-data (for placement into RPC error responses) ...",
      "ja": "yang-data（RPCエラー応答への配置用）..."
    },
    {
      "indent": 19,
      "text": "Figure 7: Data Model Structure: RPCs",
      "ja": "図7：データモデル構造：RPC"
    },
    {
      "indent": 3,
      "text": "Figure 8 depicts augmentations of YANG module ietf-yang-push to the notifications that are specified in YANG module ietf-subscribed-notifications. The augmentations allow the inclusion of subscription configuration parameters that are specific to datastore push subscriptions as part of \"subscription-started\" and \"subscription-modified\" notifications.",
      "ja": "図8は、YANGモジュールietf-yang-pushの、YANGモジュールietf-subscribed-notificationsで指定された通知への拡張を示しています。 拡張により、「サブスクリプション開始」および「サブスクリプション変更」通知の一部として、データストアプッシュサブスクリプションに固有のサブスクリプション構成パラメーターを含めることができます。"
    },
    {
      "indent": 5,
      "text": "notifications:\n  +---n replay-completed {replay}?\n  |  ...\n  +---n subscription-completed\n  |  ...\n  +---n subscription-started {configured}?\n  |  |  ...\n  |  +--ro (target)\n  |  |  ...\n  |  |  +--:(yp:datastore)\n  |  |     +--ro yp:datastore                   identityref\n  |  |     +--ro (yp:selection-filter)?\n  |  |        +--:(yp:by-reference)\n  |  |        |  +--ro yp:selection-filter-ref\n  |  |        |          selection-filter-ref\n  |  |        +--:(yp:within-subscription)\n  |  |           +--ro (yp:filter-spec)?\n  |  |              +--:(yp:datastore-subtree-filter)\n  |  |              |  +--ro yp:datastore-subtree-filter?\n  |  |              |          <anydata> {sn:subtree}?\n  |  |              +--:(yp:datastore-xpath-filter)\n  |  |                 +--ro yp:datastore-xpath-filter?\n  |  |                         yang:xpath1.0 {sn:xpath}?\n  |  ...\n  |  +--ro (yp:update-trigger)\n  |     +--:(yp:periodic)\n  |     |  +--ro yp:periodic!\n  |     |     +--ro yp:period         centiseconds\n  |     |     +--ro yp:anchor-time?   yang:date-and-time\n  |     +--:(yp:on-change) {on-change}?\n  |        +--ro yp:on-change!\n  |           +--ro yp:dampening-period?   centiseconds\n  |           +--ro yp:sync-on-start?      boolean\n  |           +--ro yp:excluded-change*    change-type\n  +---n subscription-resumed\n  |  ...",
      "raw": true
    },
    {
      "indent": 7,
      "text": "+---n subscription-modified\n|  ...\n|  +--ro (target)\n|  |  |  ...\n|  |  +--:(yp:datastore)\n|  |     +--ro yp:datastore                   identityref\n|  |     +--ro (yp:selection-filter)?\n|  |        +--:(yp:by-reference)\n|  |        |  +--ro yp:selection-filter-ref\n|  |        |          selection-filter-ref\n|  |        +--:(yp:within-subscription)\n|  |           +--ro (yp:filter-spec)?\n|  |              +--:(yp:datastore-subtree-filter)\n|  |              |  +--ro yp:datastore-subtree-filter?\n|  |              |          <anydata> {sn:subtree}?\n|  |              +--:(yp:datastore-xpath-filter)\n|  |                 +--ro yp:datastore-xpath-filter?\n|  |                         yang:xpath1.0 {sn:xpath}?\n|  ...\n|  +--ro (yp:update-trigger)?\n|     +--:(yp:periodic)\n|     |  +--ro yp:periodic!\n|     |     +--ro yp:period         centiseconds\n|     |     +--ro yp:anchor-time?   yang:date-and-time\n|     +--:(yp:on-change) {on-change}?\n|        +--ro yp:on-change!\n|           +--ro yp:dampening-period?    centiseconds\n|           +--ro yp:sync-on-start?       boolean\n|           +--ro yp:excluded-change*     change-type\n+---n subscription-terminated\n|  ...\n+---n subscription-suspended\n   ...",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 8: Data Model Structure: Notifications",
      "ja": "図8：データモデル構造：通知"
    },
    {
      "indent": 3,
      "text": "Finally, Figure 9 depicts the parts of YANG module ietf-yang-push that are newly introduced in this document (i.e., that are not simply augmentations of another YANG module).",
      "ja": "最後に、図9は、このドキュメントで新たに紹介されたYANGモジュールietf-yang-pushの部分を示しています（つまり、別のYANGモジュールの単なる拡張ではありません）。"
    },
    {
      "indent": 3,
      "text": "module: ietf-yang-push",
      "ja": "モジュール：ietf-yang-push"
    },
    {
      "indent": 5,
      "text": "rpcs:\n  +---x resync-subscription {on-change}?\n     +---w input\n        +---w id    sn:subscription-id",
      "raw": true
    },
    {
      "indent": 5,
      "text": "yang-data (for placement into RPC error responses):\n  +-- resync-subscription-error\n  |  +--ro reason?                   identityref\n  |  +--ro period-hint?              centiseconds\n  |  +--ro filter-failure-hint?      string\n  |  +--ro object-count-estimate?    uint32\n  |  +--ro object-count-limit?       uint32\n  |  +--ro kilobytes-estimate?       uint32\n  |  +--ro kilobytes-limit?          uint32\n  +-- establish-subscription-error-datastore\n  |  +--ro reason?                   identityref\n  |  +--ro period-hint?              centiseconds\n  |  +--ro filter-failure-hint?      string\n  |  +--ro object-count-estimate?    uint32\n  |  +--ro object-count-limit?       uint32\n  |  +--ro kilobytes-estimate?       uint32\n  |  +--ro kilobytes-limit?          uint32\n  +-- modify-subscription-error-datastore\n     +--ro reason?                   identityref\n     +--ro period-hint?              centiseconds\n     +--ro filter-failure-hint?      string\n     +--ro object-count-estimate?    uint32\n     +--ro object-count-limit?       uint32\n     +--ro kilobytes-estimate?       uint32\n     +--ro kilobytes-limit?          uint32",
      "raw": true
    },
    {
      "indent": 8,
      "text": "notifications:\n  +---n push-update\n  |  +--ro id?                   sn:subscription-id\n  |  +--ro datastore-contents?   <anydata>\n  |  +--ro incomplete-update?    empty\n  +---n push-change-update {on-change}?\n     +--ro id?                   sn:subscription-id\n     +--ro datastore-changes\n     |  +--ro yang-patch\n     |     +--ro patch-id    string\n     |     +--ro comment?    string\n     |     +--ro edit* [edit-id]\n     |        +--ro edit-id      string\n     |        +--ro operation    enumeration\n     |        +--ro target       target-resource-offset\n     |        +--ro point?       target-resource-offset\n     |        +--ro where?       enumeration\n     |        +--ro value?       <anydata>\n     +--ro incomplete-update?    empty",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 9: Data Model Structure: Non-augmentation Portions",
      "ja": "図9：データモデル構造：非拡張部分"
    },
    {
      "indent": 3,
      "text": "Selected components of the data model are summarized below.",
      "ja": "データモデルの選択されたコンポーネントを以下に要約します。"
    },
    {
      "indent": 0,
      "text": "4.2. Subscription Configuration",
      "section_title": true,
      "ja": "4.2. サブスクリプション構成"
    },
    {
      "indent": 3,
      "text": "Both configured and dynamic subscriptions are represented in the list \"subscription\". New parameters extending the basic subscription data model in [RFC8639] include:",
      "ja": "構成されたサブスクリプションと動的なサブスクリプションの両方がリスト「サブスクリプション」に表示されます。 [RFC8639]の基本的なサブスクリプションデータモデルを拡張する新しいパラメーターは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The targeted datastore from which the selection is being made. The potential datastores include those from [RFC8342]. A platform may also choose to support a custom datastore.",
      "ja": "o 選択が行われるターゲットのデータストア。 潜在的なデータストアには、[RFC8342]のデータストアが含まれます。 プラットフォームは、カスタムデータストアをサポートすることもできます。"
    },
    {
      "indent": 3,
      "text": "o A selection filter identifying YANG nodes of interest in a datastore. Filter contents are specified via a reference to an existing filter or via an in-line definition for only that subscription. Referenced filters allow an implementation to avoid evaluating filter acceptability during a dynamic subscription request. The \"case\" statement differentiates the options.",
      "ja": "o データストア内の対象のYANGノードを識別する選択フィルター。 フィルターの内容は、既存のフィルターへの参照またはそのサブスクリプションのみのインライン定義を介して指定されます。 参照フィルターを使用すると、実装は動的サブスクリプション要求中にフィルターの受け入れ可能性を評価することを回避できます。 「case」ステートメントはオプションを区別します。"
    },
    {
      "indent": 3,
      "text": "o For periodic subscriptions, triggered updates will occur at the boundaries of a specified time interval. These boundaries can be calculated from the periodic parameters:",
      "ja": "o 定期的なサブスクリプションの場合、トリガーされた更新は、指定された時間間隔の境界で発生します。 これらの境界は、定期的なパラメーターから計算できます。"
    },
    {
      "indent": 6,
      "text": "* a \"period\" that defines the duration between push updates.",
      "ja": "* プッシュ更新間の期間を定義する「期間」。"
    },
    {
      "indent": 6,
      "text": "* an \"anchor-time\"; update intervals fall on the points in time that are a multiple of a \"period\" from an \"anchor-time\". If an \"anchor-time\" is not provided, then the \"anchor-time\" MUST be set with the creation time of the initial update record.",
      "ja": "* 「アンカー時間」。 更新間隔は、「アンカー時間」から「期間」の倍数である時点になります。 「アンカー時間」が提供されない場合、「アンカー時間」は初期更新レコードの作成時間で設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o For on-change subscriptions, assuming that any dampening period has completed, triggering occurs whenever a change in the subscribed information is detected. On-change subscriptions have more-complex semantics that are guided by their own set of parameters:",
      "ja": "o 変更時のサブスクリプションの場合、ダンプニング期間が完了したと仮定すると、サブスクリプション情報の変更が検出されるたびにトリガーが発生します。 変更時サブスクリプションには、独自のパラメーターセットによって導かれるより複雑なセマンティクスがあります。"
    },
    {
      "indent": 6,
      "text": "* a \"dampening-period\" that specifies the interval that must pass before a successive update for the subscription is sent. If no dampening period is in effect, the update is sent immediately. If a subsequent change is detected, another update is only sent once the dampening period has passed for this subscription.",
      "ja": "* サブスクリプションの連続更新が送信される前に経過しなければならない間隔を指定する「減衰期間」。 有効な減衰期間がない場合、更新はすぐに送信されます。 後続の変更が検出された場合、このサブスクリプションのダンプニング期間が経過すると、別の更新が送信されます。"
    },
    {
      "indent": 6,
      "text": "* an \"excluded-change\" that allows the restriction of the types of changes for which updates should be sent (e.g., only add to an update record on object creation).",
      "ja": "* 更新の送信対象となる変更の種類の制限を許可する「excluded-change」（たとえば、オブジェクト作成時に更新レコードにのみ追加）。"
    },
    {
      "indent": 6,
      "text": "* a \"sync-on-start\" that specifies whether a complete update with all the subscribed data is to be sent at the beginning of a subscription.",
      "ja": "* サブスクリプションの開始時に、すべてのサブスクライブ済みデータを含む完全な更新を送信するかどうかを指定する「同期開始」。"
    },
    {
      "indent": 0,
      "text": "4.3. YANG Notifications",
      "section_title": true,
      "ja": "4.3. ヤン通知"
    },
    {
      "indent": 0,
      "text": "4.3.1. State Change Notifications",
      "section_title": true,
      "ja": "4.3.1. 状態変更通知"
    },
    {
      "indent": 3,
      "text": "Subscription state notifications and mechanisms are reused from [RFC8639]. Notifications \"subscription-started\" and \"subscription-modified\" have been augmented to include the datastore-specific objects.",
      "ja": "サブスクリプション状態の通知とメカニズムは[RFC8639]から再利用されます。 通知「subscription-started」および「subscription-modified」は、データストア固有のオブジェクトを含むように拡張されました。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Notifications for Subscribed Content",
      "section_title": true,
      "ja": "4.3.2. 購読コンテンツの通知"
    },
    {
      "indent": 3,
      "text": "Along with the subscribed content, there are other objects that might be part of a \"push-update\" or \"push-change-update\" notification.",
      "ja": "サブスクライブされたコンテンツに加えて、「プッシュ更新」または「プッシュ変更更新」通知の一部である可能性のある他のオブジェクトがあります。"
    },
    {
      "indent": 3,
      "text": "o An \"id\" (that identifies the subscription). This object MUST be transported along with the subscribed contents. It allows a receiver to determine which subscription resulted in a particular update record.",
      "ja": "o 「ID」（サブスクリプションを識別する）。 このオブジェクトは、サブスクライブされたコンテンツとともに転送する必要があります。 これにより、受信者はどのサブスクリプションが特定の更新レコードになったかを判断できます。"
    },
    {
      "indent": 3,
      "text": "o An \"incomplete-update\" leaf. This leaf indicates that not all changes that have occurred since the last update are actually included with this update. In other words, the publisher has failed to fulfill its full subscription obligations. (For example, a datastore was unable to provide the full set of datastore nodes to a publisher process.) To facilitate the resynchronization of on-change subscriptions, a publisher MAY subsequently send a \"push-update\" containing a full selection snapshot of subscribed data.",
      "ja": "o 「不完全な更新」リーフ。 このリーフは、最後の更新以降に発生したすべての変更が実際にこの更新に含まれるわけではないことを示しています。 言い換えれば、出版社はその完全なサブスクリプションの義務を果たしていません。 （たとえば、データストアはパブリッシャープロセスにデータストアノードの完全なセットを提供できませんでした。）変更時サブスクリプションの再同期を容易にするために、パブリッシャーはサブスクライブ済みのフルセレクションスナップショットを含む「プッシュ更新」を送信する場合があります データ。"
    },
    {
      "indent": 0,
      "text": "4.4. YANG RPCs",
      "section_title": true,
      "ja": "4.4. ヤンRPC"
    },
    {
      "indent": 3,
      "text": "YANG-Push subscriptions are established, modified, and deleted using RPCs augmented from [RFC8639].",
      "ja": "YANG-Pushサブスクリプションは、[RFC8639]から拡張されたRPCを使用して確立、変更、および削除されます。"
    },
    {
      "indent": 0,
      "text": "4.4.1. \"establish-subscription\" RPC",
      "section_title": true,
      "ja": "4.4.1. 「確立サブスクリプション」RPC"
    },
    {
      "indent": 3,
      "text": "The subscriber sends an \"establish-subscription\" RPC with the parameters listed in Section 3.1. An example might look like:",
      "ja": "サブスクライバーは、セクション3.1にリストされているパラメーターを使用して「確立サブスクリプション」RPCを送信します。 例は次のようになります。"
    },
    {
      "indent": 1,
      "text": "<netconf:rpc message-id=\"101\"\n    xmlns:netconf=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <establish-subscription\n      xmlns=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\n      xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n    <yp:datastore\n         xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\">\n      ds:operational\n    </yp:datastore>\n    <yp:datastore-xpath-filter\n        xmlns:ex=\"https://example.com/sample-data/1.0\">\n      /ex:foo\n    </yp:datastore-xpath-filter>\n    <yp:periodic>\n      <yp:period>500</yp:period>\n    </yp:periodic>\n  </establish-subscription>\n</netconf:rpc>",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 10: \"establish-subscription\" RPC",
      "ja": "図10：「確立-サブスクリプション」RPC"
    },
    {
      "indent": 3,
      "text": "A positive response includes the \"id\" of the accepted subscription. In that case, a publisher may respond as follows:",
      "ja": "肯定的な応答には、受け入れられたサブスクリプションの「ID」が含まれます。 その場合、出版社は次のように対応できます。"
    },
    {
      "indent": 1,
      "text": "<rpc-reply message-id=\"101\"\n   xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n   <id\n     xmlns=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\">\n      52\n   </id>\n</rpc-reply>",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 11: \"establish-subscription\" Positive RPC Response",
      "ja": "図11：「establish-subscription」の肯定的なRPC応答"
    },
    {
      "indent": 3,
      "text": "A subscription can be rejected for multiple reasons, including the lack of authorization to establish a subscription, no capacity to serve the subscription at the publisher, or the inability of the publisher to select datastore content at the requested cadence.",
      "ja": "サブスクリプションは、サブスクリプションを確立するための承認の欠如、パブリッシャーでサブスクリプションを提供する能力がない、またはパブリッシャーが要求されたリズムでデータストアコンテンツを選択できないなど、複数の理由で拒否される可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a request is rejected because the publisher is not able to serve it, the publisher SHOULD include in the returned error hints that help a subscriber understand what subscription parameters might have been accepted for the request. These hints would be included in the yang-data structure \"establish-subscription-error-datastore\". However, even with these hints, there are no guarantees that subsequent requests will in fact be accepted.",
      "ja": "パブリッシャーがリクエストを処理できないためにリクエストが拒否された場合、パブリッシャーは返されたエラーヒントに含める必要があります。 これらのヒントは、yang-data構造「establish-subscription-error-datastore」に含まれます。 ただし、これらのヒントを使用しても、後続のリクエストが実際に受け入れられるという保証はありません。"
    },
    {
      "indent": 3,
      "text": "The specific parameters to be returned as part of the RPC error response depend on the specific transport that is used to manage the subscription. For NETCONF, those parameters are defined in [RFC8640]. For example, for the following NETCONF request:",
      "ja": "RPCエラー応答の一部として返される特定のパラメーターは、サブスクリプションの管理に使用される特定のトランスポートによって異なります。 NETCONFの場合、これらのパラメーターは[RFC8640]で定義されています。 たとえば、次のNETCONF要求の場合："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <establish-subscription\n      xmlns=\n        \"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\n      xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n    <yp:datastore\n        xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\">\n      ds:operational\n    </yp:datastore>\n    <yp:datastore-xpath-filter\n        xmlns:ex=\"https://example.com/sample-data/1.0\">\n      /ex:foo\n    </yp:datastore-xpath-filter>\n    <yp:on-change>\n      <yp:dampening-period>100</yp:dampening-period>\n    </yp:on-change>\n  </establish-subscription>\n</rpc>",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 12: \"establish-subscription\" Request: Example 2",
      "ja": "図12：「establish-subscription」リクエスト：例2"
    },
    {
      "indent": 3,
      "text": "A publisher that cannot serve on-change updates but can serve periodic updates might return the following NETCONF response:",
      "ja": "変更時の更新を提供できないが、定期的な更新を提供できる発行元は、次のNETCONF応答を返す場合があります。"
    },
    {
      "indent": 1,
      "text": "<rpc-reply message-id=\"101\"\n  xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n  xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\">\n  <rpc-error>\n    <error-type>application</error-type>\n    <error-tag>operation-failed</error-tag>\n    <error-severity>error</error-severity>\n    <error-path>/yp:periodic/yp:period</error-path>\n    <error-info>\n      <yp:establish-subscription-error-datastore>\n        <yp:reason>yp:on-change-unsupported</yp:reason>\n      </yp:establish-subscription-error-datastore>\n    </error-info>\n  </rpc-error>\n</rpc-reply>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 13: \"establish-subscription\" Error Response: Example 2",
      "ja": "図13：「establish-subscription」エラー応答：例2"
    },
    {
      "indent": 0,
      "text": "4.4.2. \"modify-subscription\" RPC",
      "section_title": true,
      "ja": "4.4.2. 「サブスクリプションの変更」RPC"
    },
    {
      "indent": 3,
      "text": "The subscriber MAY invoke the \"modify-subscription\" RPC for a subscription it previously established. The subscriber will include newly desired values in the \"modify-subscription\" RPC. Parameters not included MUST remain unmodified. Figure 14 provides an example where a subscriber attempts to modify the period and datastore XPath filter of a subscription using NETCONF.",
      "ja": "サブスクライバは、以前に確立したサブスクリプションの「modify-subscription」RPCを呼び出すことができます。 サブスクライバーは、「modify-subscription」RPCに新しく必要な値を含めます。 含まれていないパラメーターは変更しないでください。 図14は、サブスクライバーがNETCONFを使用してサブスクリプションの期間およびデータストアXPathフィルターを変更しようとする例を示しています。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <modify-subscription\n      xmlns=\n        \"urn:ietf:params:xml:ns:yang:ietf-subscribed-notifications\"\n      xmlns:yp=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n    <id>1011</id>\n    <yp:datastore\n        xmlns:ds=\"urn:ietf:params:xml:ns:yang:ietf-datastores\">\n      ds:operational\n    </yp:datastore>\n    <yp:datastore-xpath-filter\n        xmlns:ex=\"https://example.com/sample-data/1.0\">\n      /ex:bar\n    </yp:datastore-xpath-filter>\n    <yp:periodic>\n      <yp:period>250</yp:period>\n    </yp:periodic>\n   </modify-subscription>\n</rpc>",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 14: \"modify-subscription\" Request",
      "ja": "図14：「サブスクリプションの変更」リクエスト"
    },
    {
      "indent": 3,
      "text": "The publisher MUST respond to the subscription modification request. If the request is rejected, the existing subscription is left unchanged, and the publisher MUST send an RPC error response. This response might have hints encapsulated in the yang-data structure \"modify-subscription-error-datastore\". A subscription MAY be modified multiple times.",
      "ja": "発行者は、サブスクリプションの変更要求に応答する必要があります。 要求が拒否された場合、既存のサブスクリプションは変更されずに残り、発行者はRPCエラー応答を送信する必要があります。 この応答には、yangデータ構造「modify-subscription-error-datastore」にカプセル化されたヒントが含まれる場合があります。 サブスクリプションは複数回変更される場合があります。"
    },
    {
      "indent": 3,
      "text": "The specific parameters to be returned as part of the RPC error response depend on the specific transport that is used to manage the subscription. For NETCONF, those parameters are specified in [RFC8640].",
      "ja": "RPCエラー応答の一部として返される特定のパラメーターは、サブスクリプションの管理に使用される特定のトランスポートによって異なります。 NETCONFの場合、これらのパラメーターは[RFC8640]で指定されています。"
    },
    {
      "indent": 3,
      "text": "A configured subscription cannot be modified using a \"modify-subscription\" RPC. Instead, the configuration needs to be edited as needed.",
      "ja": "構成されたサブスクリプションは、「modify-subscription」RPCを使用して変更できません。 代わりに、構成を必要に応じて編集する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.3. \"delete-subscription\" RPC",
      "section_title": true,
      "ja": "4.4.3. 「サブスクリプションの削除」RPC"
    },
    {
      "indent": 3,
      "text": "To stop receiving updates from a subscription and effectively delete a subscription that had previously been established using an \"establish-subscription\" RPC, a subscriber can send a \"delete-subscription\" RPC, which takes as its only input the subscription's \"id\". This RPC is unmodified from [RFC8639].",
      "ja": "サブスクリプションからの更新の受信を停止し、「establish-subscription」RPCを使用して以前に確立されたサブスクリプションを効果的に削除するには、サブスクライバーは「delete-subscription」RPCを送信します。 このRPCは[RFC8639]から変更されていません。"
    },
    {
      "indent": 0,
      "text": "4.4.4. \"resync-subscription\" RPC",
      "section_title": true,
      "ja": "4.4.4. 「再同期サブスクリプション」RPC"
    },
    {
      "indent": 3,
      "text": "This RPC is supported only for on-change subscriptions previously established using an \"establish-subscription\" RPC. For example:",
      "ja": "このRPCは、以前に「確立サブスクリプション」RPCを使用して確立された変更時サブスクリプションに対してのみサポートされます。 例えば："
    },
    {
      "indent": 6,
      "text": "<rpc message-id=\"103\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n  <resync-subscription\n      xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-push\">\n    <id>1011</id>\n  </resync-subscription>\n</rpc>",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 15: \"resync-subscription\"",
      "ja": "図15：「再同期サブスクリプション」"
    },
    {
      "indent": 3,
      "text": "On receipt, a publisher must either (1) accept the request and quickly follow with a \"push-update\" or (2) send an appropriate error in an RPC error response. In its error response, the publisher MAY include, in the yang-data structure \"resync-subscription-error\", supplemental information about the reasons for the error.",
      "ja": "パブリッシャーは、受信時に（1）要求を受け入れてすぐに「プッシュ更新」を行うか、（2）RPCエラー応答で適切なエラーを送信する必要があります。 発行者は、そのエラー応答に、yang-data構造「resync-subscription-error」にエラーの理由に関する補足情報を含めることができます。"
    },
    {
      "indent": 0,
      "text": "4.4.5. YANG Module Synchronization",
      "section_title": true,
      "ja": "4.4.5. YANGモジュールの同期"
    },
    {
      "indent": 3,
      "text": "To make subscription requests, the subscriber needs to know the YANG datastore schemas used by the publisher. These schemas are available in the YANG library module ietf-yang-library.yang as defined in [RFC8525]. The receiver is expected to know the YANG library information before starting a subscription.",
      "ja": "サブスクリプション要求を行うには、サブスクライバーはパブリッシャーが使用するYANGデータストアスキーマを知っている必要があります。 これらのスキーマは、[RFC8525]で定義されているYANGライブラリモジュールietf-yang-library.yangで利用できます。 受信者は、サブスクリプションを開始する前に、YANGライブラリ情報を知っている必要があります。"
    },
    {
      "indent": 3,
      "text": "The set of modules, revisions, features, and deviations can change at runtime (if supported by the publisher implementation). For this purpose, the YANG library provides a simple \"yang-library-change\" notification that informs the subscriber that the library has changed. In this case, a subscription may need to be updated to take the updates into account. The receiver may also need to be informed of module changes in order to process updates regarding datastore nodes from changed modules correctly.",
      "ja": "モジュール、リビジョン、機能、および偏差のセットは、実行時に変更できます（パブリッシャーの実装でサポートされている場合）。 この目的のために、YANGライブラリは、ライブラリが変更されたことをサブスクライバに通知する単純な「yang-library-change」通知を提供します。 この場合、更新を考慮するためにサブスクリプションを更新する必要がある場合があります。 また、変更されたモジュールからのデータストアノードに関する更新を正しく処理するために、受信者にモジュールの変更を通知する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "5. YANG Module for YANG-Push",
      "section_title": true,
      "ja": "5. ヤンプッシュ用ヤンモジュール"
    },
    {
      "indent": 3,
      "text": "This YANG module imports typedefs from [RFC6991], identities from [RFC8342], the \"yang-data\" extension from [RFC8040], and the \"yang-patch\" grouping from [RFC8072]. In addition, it imports and augments many definitions from [RFC8639]. It also references [RFC6241], [XPATH] (\"XML Path Language (XPath) Version 1.0\"), and [RFC7950].",
      "ja": "このYANGモジュールは、[RFC6991]からtypedef、[RFC8342]からID、[RFC8040]から「yang-data」拡張、[RFC8072]から「yang-patch」グループをインポートします。 さらに、[RFC8639]から多くの定義をインポートおよび拡張します。 また、[RFC6241]、[XPATH]（ \"XML Path Language（XPath）Version 1.0\"）、および[RFC7950]も参照します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-yang-push@2019-09-09.yang\"\nmodule ietf-yang-push {\n  yang-version 1.1;\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-yang-push\";\n  prefix yp;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "import ietf-yang-types {\n  prefix yang;\n  reference\n    \"RFC 6991: Common YANG Data Types\";\n}\nimport ietf-subscribed-notifications {\n  prefix sn;\n  reference\n    \"RFC 8639: Subscription to YANG Notifications\";\n}\nimport ietf-datastores {\n  prefix ds;\n  reference\n    \"RFC 8342: Network Management Datastore Architecture (NMDA)\";\n}\nimport ietf-restconf {\n  prefix rc;\n  reference\n    \"RFC 8040: RESTCONF Protocol\";\n}\nimport ietf-yang-patch {\n  prefix ypatch;\n  reference\n    \"RFC 8072: YANG Patch Media Type\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "organization\n  \"IETF NETCONF (Network Configuration) Working Group\";\ncontact\n  \"WG Web:  <https:/datatracker.ietf.org/wg/netconf/>\n   WG List: <mailto:netconf@ietf.org>",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Author: Alexander Clemm",
      "ja": "著者：アレクサンダークレム"
    },
    {
      "indent": 17,
      "text": "<mailto:ludwig@clemm.org>",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Author:  Eric Voit\n         <mailto:evoit@cisco.com>\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "description \"This module contains YANG specifications for YANG-Push.",
      "ja": "description \"このモジュールには、YANG-PushのYANG仕様が含まれています。"
    },
    {
      "indent": 8,
      "text": "The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as described in BCP 14 (RFC 2119) (RFC 8174) when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」 'この文書のBCP 14（RFC 2119）（RFC 8174）に記載されているように解釈されるのは、ここに示すように、すべての大文字で表示されるときだけです。"
    },
    {
      "indent": 8,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよびコードの作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 8,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info).",
      "ja": "ソースおよびバイナリ形式での再配布および使用は、修正の有無にかかわらず、IETFトラストのIETF文書に関連する法的条項のセクション4.cに記載されているSimplified BSD Licenseに従い、それに含まれるライセンス条項に従って許可されます（ https://trustee.ietf.org/license-info）。"
    },
    {
      "indent": 8,
      "text": "This version of this YANG module is part of RFC 8641; see the RFC itself for full legal notices.\";",
      "ja": "このYANGモジュールのこのバージョンは、RFC 8641の一部です。 完全な法的通知については、RFCを参照してください。 \";"
    },
    {
      "indent": 5,
      "text": "revision 2019-09-09 {\n  description\n    \"Initial revision.\";\n  reference\n    \"RFC 8641: Subscriptions to YANG Datastores\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * FEATURES\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "feature on-change {\n  description\n    \"This feature indicates that on-change triggered subscriptions\n     are supported.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * IDENTITIES\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* Error type identities for datastore subscription */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity resync-subscription-error {\n  description\n    \"Problem found while attempting to fulfill a\n     'resync-subscription' RPC request.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity cant-exclude {\n  base sn:establish-subscription-error;\n  description\n    \"Unable to remove the set of 'excluded-change' parameters.\n     This means that the publisher is unable to restrict\n     'push-change-update' notifications to just the change types\n     requested for this subscription.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity datastore-not-subscribable {\n  base sn:establish-subscription-error;\n  base sn:subscription-terminated-reason;\n  description\n    \"This is not a subscribable datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity no-such-subscription-resync {\n  base resync-subscription-error;\n  description\n    \"The referenced subscription doesn't exist.  This may be as a\n     result of a nonexistent subscription ID, an ID that belongs to\n     another subscriber, or an ID for a configured subscription.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity on-change-unsupported {\n  base sn:establish-subscription-error;\n  description\n    \"On-change is not supported for any objects that are\n     selectable by this filter.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity on-change-sync-unsupported {\n  base sn:establish-subscription-error;\n  description\n    \"Neither 'sync-on-start' nor resynchronization is supported for\n     this subscription.  This error will be used for two reasons:\n     (1) if an 'establish-subscription' RPC includes\n     'sync-on-start' but the publisher can't support sending a\n     'push-update' for this subscription for reasons other than\n     'on-change-unsupported' or 'sync-too-big' (2) if the 'resync-subscription' RPC is invoked for either an\n     existing periodic subscription or an on-change subscription\n     that can't support resynchronization.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity period-unsupported {\n  base sn:establish-subscription-error;\n  base sn:modify-subscription-error;\n  base sn:subscription-suspended-reason;\n  description\n    \"The requested time period or 'dampening-period' is too short.\n     This can be for both periodic and on-change subscriptions\n     (with or without dampening).  Hints suggesting alternative\n     periods may be returned as supplemental information.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity update-too-big {\n  base sn:establish-subscription-error;\n  base sn:modify-subscription-error;\n  base sn:subscription-suspended-reason;\n  description\n    \"Periodic or on-change push update data trees exceed a maximum\n     size limit.  Hints on the estimated size of what was too big\n     may be returned as supplemental information.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity sync-too-big {\n  base sn:establish-subscription-error;\n  base sn:modify-subscription-error;\n  base resync-subscription-error;\n  base sn:subscription-suspended-reason;\n  description\n    \"The 'sync-on-start' or resynchronization data tree exceeds a\n     maximum size limit.  Hints on the estimated size of what was\n     too big may be returned as supplemental information.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity unchanging-selection {\n  base sn:establish-subscription-error;\n  base sn:modify-subscription-error;\n  base sn:subscription-terminated-reason;\n  description\n    \"The selection filter is unlikely to ever select data tree\n     nodes.  This means that based on the subscriber's current\n     access rights, the publisher recognizes that the selection\n     filter is unlikely to ever select data tree nodes that change.\n     Examples for this might be that the node or subtree doesn't\n     exist, read access is not permitted for a receiver, or static objects that only change at reboot have been chosen.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * TYPE DEFINITIONS\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "typedef change-type {\n  type enumeration {\n    enum create {\n      description\n        \"A change that refers to the creation of a new\n         datastore node.\";\n    }\n    enum delete {\n      description\n        \"A change that refers to the deletion of a\n         datastore node.\";\n    }\n    enum insert {\n      description\n        \"A change that refers to the insertion of a new\n         user-ordered datastore node.\";\n    }\n    enum move {\n      description\n        \"A change that refers to a reordering of the target\n         datastore node.\";\n    }\n    enum replace {\n      description\n        \"A change that refers to a replacement of the target\n         datastore node's value.\";\n    }\n  }\n  description\n    \"Specifies different types of datastore changes.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "     This type is based on the edit operations defined for\n     YANG Patch, with the difference that it is valid for a\n     receiver to process an update record that performs a\n     'create' operation on a datastore node the receiver believes\n     exists or to process a delete on a datastore node the\n     receiver believes is missing.\";\n  reference\n    \"RFC 8072: YANG Patch Media Type, Section 2.5\";\n} typedef selection-filter-ref {\n  type leafref {\n    path \"/sn:filters/yp:selection-filter/yp:filter-id\";\n  }\n  description\n    \"This type is used to reference a selection filter.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "typedef centiseconds {\n  type uint32;\n  description\n    \"A period of time, measured in units of 0.01 seconds.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * GROUP DEFINITIONS\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping datastore-criteria {\n  description\n    \"A grouping to define criteria for which selected objects from\n     a targeted datastore should be included in push updates.\";\n  leaf datastore {\n    type identityref {\n      base ds:datastore;\n    }\n    mandatory true;\n    description\n      \"Datastore from which to retrieve data.\";\n  }\n  uses selection-filter-objects;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping selection-filter-types {\n  description\n    \"This grouping defines the types of selectors for objects\n     from a datastore.\";\n  choice filter-spec {\n    description\n      \"The content filter specification for this request.\";\n    anydata datastore-subtree-filter {\n      if-feature \"sn:subtree\";\n      description\n        \"This parameter identifies the portions of the\n         target datastore to retrieve.\";\n      reference\n        \"RFC 6241: Network Configuration Protocol (NETCONF),\n                   Section 6\";",
      "raw": true
    },
    {
      "indent": 9,
      "text": "}\nleaf datastore-xpath-filter {\n  if-feature \"sn:xpath\";\n  type yang:xpath1.0;\n  description\n    \"This parameter contains an XPath expression identifying\n     the portions of the target datastore to retrieve.",
      "raw": true
    },
    {
      "indent": 14,
      "text": "If the expression returns a node set, all nodes in the node set are selected by the filter. Otherwise, if the expression does not return a node set, the filter doesn't select any nodes.",
      "ja": "式がノードセットを返す場合、ノードセット内のすべてのノードがフィルターによって選択されます。 それ以外の場合、式がノードセットを返さない場合、フィルターはノードを選択しません。"
    },
    {
      "indent": 14,
      "text": "The expression is evaluated in the following XPath context:",
      "ja": "式は、次のXPathコンテキストで評価されます。"
    },
    {
      "indent": 14,
      "text": "o The set of namespace declarations is the set of prefix and namespace pairs for all YANG modules implemented by the server, where the prefix is the YANG module name and the namespace is as defined by the 'namespace' statement in the YANG module.",
      "ja": "o 名前空間宣言のセットは、サーバーによって実装されるすべてのYANGモジュールのプレフィックスと名前空間のペアのセットです。プレフィックスはYANGモジュール名であり、名前空間はYANGモジュールの「namespace」ステートメントで定義されています。"
    },
    {
      "indent": 17,
      "text": "If the leaf is encoded in XML, all namespace declarations in scope on the 'stream-xpath-filter' leaf element are added to the set of namespace declarations. If a prefix found in the XML is already present in the set of namespace declarations, the namespace in the XML is used.",
      "ja": "リーフがXMLでエンコードされている場合、「stream-xpath-filter」リーフ要素のスコープ内のすべてのネームスペース宣言がネームスペース宣言のセットに追加されます。 XMLで見つかったプレフィックスが名前空間宣言のセットに既に存在する場合、XMLの名前空間が使用されます。"
    },
    {
      "indent": 14,
      "text": "o The set of variable bindings is empty.",
      "ja": "o 変数バインディングのセットは空です。"
    },
    {
      "indent": 14,
      "text": "o The function library is comprised of the core function library and the XPath functions defined in Section 10 in RFC 7950.",
      "ja": "o 関数ライブラリは、コア関数ライブラリと、RFC 7950のセクション10で定義されているXPath関数で構成されています。"
    },
    {
      "indent": 5,
      "text": "         o  The context node is the root node of the target\n            datastore.\";\n      reference\n        \"XML Path Language (XPath) Version 1.0\n         (https://www.w3.org/TR/1999/REC-xpath-19991116)\n         RFC 7950: The YANG 1.1 Data Modeling Language,\n                   Section 10\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping selection-filter-objects { description",
      "ja": "グループ化selection-filter-objects {説明"
    },
    {
      "indent": 5,
      "text": "    \"This grouping defines a selector for objects from a\n     datastore.\";\n  choice selection-filter {\n    description\n      \"The source of the selection filter applied to the\n       subscription.  This will either (1) come referenced from a\n       global list or (2) be provided in the subscription itself.\";\n    case by-reference {\n      description\n        \"Incorporates a filter that has been configured\n         separately.\";\n      leaf selection-filter-ref {\n        type selection-filter-ref;\n        mandatory true;\n        description\n          \"References an existing selection filter that is to be\n           applied to the subscription.\";\n      }\n    }\n    case within-subscription {\n      description\n        \"A local definition allows a filter to have the same\n         lifecycle as the subscription.\";\n      uses selection-filter-types;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping update-policy-modifiable {\n  description\n    \"This grouping describes the datastore-specific subscription\n     conditions that can be changed during the lifetime of the\n     subscription.\";\n  choice update-trigger {\n    description\n      \"Defines necessary conditions for sending an event record to\n       the subscriber.\";\n    case periodic {\n      container periodic {\n        presence \"indicates a periodic subscription\";\n        description\n          \"The publisher is requested to periodically notify the\n           receiver regarding the current values of the datastore\n           as defined by the selection filter.\";\n        leaf period {\n          type centiseconds;\n          mandatory true;\n          description",
      "raw": true
    },
    {
      "indent": 5,
      "text": "            \"Duration of time that should occur between periodic\n             push updates, in units of 0.01 seconds.\";\n        }\n        leaf anchor-time {\n          type yang:date-and-time;\n          description\n            \"Designates a timestamp before or after which a series\n             of periodic push updates are determined.  The next\n             update will take place at a point in time that is a\n             multiple of a period from the 'anchor-time'.\n             For example, for an 'anchor-time' that is set for the\n             top of a particular minute and a period interval of a\n             minute, updates will be sent at the top of every\n             minute that this subscription is active.\";\n        }\n      }\n    }\n    case on-change {\n      if-feature \"on-change\";\n      container on-change {\n        presence \"indicates an on-change subscription\";\n        description\n          \"The publisher is requested to notify the receiver\n           regarding changes in values in the datastore subset as\n           defined by a selection filter.\";\n        leaf dampening-period {\n          type centiseconds;\n          default \"0\";\n          description\n            \"Specifies the minimum interval between the assembly of\n             successive update records for a single receiver of a\n             subscription.  Whenever subscribed objects change and\n             a dampening-period interval (which may be zero) has\n             elapsed since the previous update record creation for\n             a receiver, any subscribed objects and properties\n             that have changed since the previous update record\n             will have their current values marshalled and placed\n             in a new update record.\";\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping update-policy {\n  description\n    \"This grouping describes the datastore-specific subscription\n     conditions of a subscription.\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  uses update-policy-modifiable {\n    augment \"update-trigger/on-change/on-change\" {\n      description\n        \"Includes objects that are not modifiable once a\n         subscription is established.\";\n      leaf sync-on-start {\n        type boolean;\n        default \"true\";\n        description\n          \"When this object is set to 'false', (1) it restricts an\n           on-change subscription from sending 'push-update'\n           notifications and (2) pushing a full selection per the\n           terms of the selection filter MUST NOT be done for\n           this subscription.  Only updates about changes\n           (i.e., only 'push-change-update' notifications)\n           are sent.  When set to 'true' (the default behavior),\n           in order to facilitate a receiver's synchronization,\n           a full update is sent, via a 'push-update' notification,\n           when the subscription starts.  After that,\n           'push-change-update' notifications are exclusively sent,\n           unless the publisher chooses to resync the subscription\n           via a new 'push-update' notification.\";\n      }\n      leaf-list excluded-change {\n        type change-type;\n        description\n          \"Used to restrict which changes trigger an update.  For\n           example, if a 'replace' operation is excluded, only the\n           creation and deletion of objects are reported.\";\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping hints {\n  description\n    \"Parameters associated with an error for a subscription\n     made upon a datastore.\";\n  leaf period-hint {\n    type centiseconds;\n    description\n      \"Returned when the requested time period is too short.  This\n       hint can assert a viable period for either a periodic push\n       cadence or an on-change dampening interval.\";\n  }\n  leaf filter-failure-hint {\n    type string;\n    description",
      "raw": true
    },
    {
      "indent": 5,
      "text": "      \"Information describing where and/or why a provided filter\n       was unsupportable for a subscription.\";\n  }\n  leaf object-count-estimate {\n    type uint32;\n    description\n      \"If there are too many objects that could potentially be\n       returned by the selection filter, this identifies the\n       estimate of the number of objects that the filter would\n       potentially pass.\";\n  }\n  leaf object-count-limit {\n    type uint32;\n    description\n      \"If there are too many objects that could be returned by\n       the selection filter, this identifies the upper limit of\n       the publisher's ability to service this subscription.\";\n  }\n  leaf kilobytes-estimate {\n    type uint32;\n    description\n      \"If the returned information could be beyond the capacity\n       of the publisher, this would identify the estimated\n       data size that could result from this selection filter.\";\n  }\n  leaf kilobytes-limit {\n    type uint32;\n    description\n      \"If the returned information would be beyond the capacity\n       of the publisher, this identifies the upper limit of the\n       publisher's ability to service this subscription.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * RPCs\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rpc resync-subscription {\n  if-feature \"on-change\";\n  description\n    \"This RPC allows a subscriber of an active on-change\n     subscription to request a full push of objects.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "A successful invocation results in a 'push-update' of all datastore nodes that the subscriber is permitted to access. This RPC can only be invoked on the same session on which the subscription is currently active. In the case of an error, a",
      "ja": "呼び出しが成功すると、サブスクライバがアクセスを許可されているすべてのデータストアノードの「プッシュ更新」が行われます。 このRPCは、サブスクリプションが現在アクティブになっている同じセッションでのみ呼び出すことができます。 エラーの場合、"
    },
    {
      "indent": 5,
      "text": "     'resync-subscription-error' is sent as part of an error\n     response.\";\n  input {\n    leaf id {\n      type sn:subscription-id;\n      mandatory true;\n      description\n        \"Identifier of the subscription that is to be resynced.\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rc:yang-data resync-subscription-error {\n  container resync-subscription-error {\n    description\n      \"If a 'resync-subscription' RPC fails, the subscription is\n       not resynced and the RPC error response MUST indicate the\n       reason for this failure.  This yang-data MAY be inserted as\n       structured data in a subscription's RPC error response\n       to indicate the reason for the failure.\";\n    leaf reason {\n      type identityref {\n        base resync-subscription-error;\n      }\n      mandatory true;\n      description\n        \"Indicates the reason why the publisher has declined a\n         request for subscription resynchronization.\";\n    }\n    uses hints;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:establish-subscription/sn:input\" {\n  description\n    \"This augmentation adds additional subscription parameters\n     that apply specifically to datastore updates to RPC input.\";\n  uses update-policy;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:establish-subscription/sn:input/sn:target\" {\n  description\n    \"This augmentation adds the datastore as a valid target\n     for the subscription to RPC input.\";\n  case datastore {\n    description\n      \"Information specifying the parameters of a request for a\n       datastore subscription.\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "    uses datastore-criteria;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rc:yang-data establish-subscription-datastore-error-info {\n  container establish-subscription-datastore-error-info {\n    description\n      \"If any 'establish-subscription' RPC parameters are\n       unsupportable against the datastore, a subscription is not\n       created and the RPC error response MUST indicate the reason\n       why the subscription failed to be created.  This yang-data\n       MAY be inserted as structured data in a subscription's\n       RPC error response to indicate the reason for the failure.\n       This yang-data MUST be inserted if hints are to be provided\n       back to the subscriber.\";\n    leaf reason {\n      type identityref {\n        base sn:establish-subscription-error;\n      }\n      description\n        \"Indicates the reason why the subscription has failed to\n         be created to a targeted datastore.\";\n    }\n    uses hints;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:modify-subscription/sn:input\" {\n  description\n    \"This augmentation adds additional subscription parameters\n     specific to datastore updates.\";\n  uses update-policy-modifiable;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:modify-subscription/sn:input/sn:target\" {\n  description\n    \"This augmentation adds the datastore as a valid target\n     for the subscription to RPC input.\";\n  case datastore {\n    description\n      \"Information specifying the parameters of a request for a\n       datastore subscription.\";\n    uses datastore-criteria;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rc:yang-data modify-subscription-datastore-error-info {\n  container modify-subscription-datastore-error-info {",
      "raw": true
    },
    {
      "indent": 5,
      "text": "    description\n      \"This yang-data MAY be provided as part of a subscription's\n       RPC error response when there is a failure of a\n       'modify-subscription' RPC that has been made against a\n       datastore.  This yang-data MUST be used if hints are to be\n       provided back to the subscriber.\";\n    leaf reason {\n      type identityref {\n        base sn:modify-subscription-error;\n      }\n      description\n        \"Indicates the reason why the subscription has failed to\n         be modified.\";\n    }\n    uses hints;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * NOTIFICATIONS\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "notification push-update {\n  description\n    \"This notification contains a push update that in turn contains\n     data subscribed to via a subscription.  In the case of a\n     periodic subscription, this notification is sent for periodic\n     updates.  It can also be used for synchronization updates of\n     an on-change subscription.  This notification shall only be\n     sent to receivers of a subscription.  It does not constitute\n     a general-purpose notification that would be subscribable as\n     part of the NETCONF event stream by any receiver.\";\n  leaf id {\n    type sn:subscription-id;\n    description\n      \"This references the subscription that drove the\n       notification to be sent.\";\n  }\n  anydata datastore-contents {\n    description\n      \"This contains the updated data.  It constitutes a snapshot\n       at the time of update of the set of data that has been\n       subscribed to.  The snapshot corresponds to the same\n       snapshot that would be returned in a corresponding 'get'\n       operation with the same selection filter parameters\n       applied.\";\n  }\n  leaf incomplete-update {",
      "raw": true
    },
    {
      "indent": 5,
      "text": "    type empty;\n    description\n      \"This is a flag that indicates that not all datastore\n       nodes subscribed to are included with this update.  In\n       other words, the publisher has failed to fulfill its full\n       subscription obligations and, despite its best efforts, is\n       providing an incomplete set of objects.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "notification push-change-update {\n  if-feature \"on-change\";\n  description\n    \"This notification contains an on-change push update.  This\n     notification shall only be sent to the receivers of a\n     subscription.  It does not constitute a general-purpose\n     notification that would be subscribable as part of the\n     NETCONF event stream by any receiver.\";\n  leaf id {\n    type sn:subscription-id;\n    description\n      \"This references the subscription that drove the\n       notification to be sent.\";\n  }\n  container datastore-changes {\n    description\n      \"This contains the set of datastore changes of the target\n       datastore, starting at the time of the previous update, per\n       the terms of the subscription.\";\n    uses ypatch:yang-patch;\n  }\n  leaf incomplete-update {\n    type empty;\n    description\n      \"The presence of this object indicates that not all changes\n       that have occurred since the last update are included with\n       this update.  In other words, the publisher has failed to\n       fulfill its full subscription obligations -- for example,\n       in cases where it was not able to keep up with a burst of\n       changes.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:subscription-started\" {\n  description\n    \"This augmentation adds datastore-specific objects to\n     the notification that a subscription has started.\";\n  uses update-policy;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 5,
      "text": "augment \"/sn:subscription-started/sn:target\" {\n  description\n    \"This augmentation allows the datastore to be included as\n     part of the notification that a subscription has started.\";\n  case datastore {\n    uses datastore-criteria {\n      refine \"selection-filter/within-subscription\" {\n        description\n          \"Specifies the selection filter and where it originated\n           from.  If the 'selection-filter-ref' is populated, the\n           filter in the subscription came from the 'filters'\n           container.  Otherwise, it is populated in-line as part\n           of the subscription itself.\";\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:subscription-modified\" {\n  description\n    \"This augmentation adds datastore-specific objects to\n     the notification that a subscription has been modified.\";\n  uses update-policy;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:subscription-modified/sn:target\" {\n  description\n    \"This augmentation allows the datastore to be included as\n     part of the notification that a subscription has been\n     modified.\";\n  case datastore {\n    uses datastore-criteria {\n      refine \"selection-filter/within-subscription\" {\n        description\n          \"Specifies the selection filter and where it originated\n           from.  If the 'selection-filter-ref' is populated, the\n           filter in the subscription came from the 'filters'\n           container.  Otherwise, it is populated in-line as part\n           of the subscription itself.\";\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * DATA NODES",
      "raw": true
    },
    {
      "indent": 6,
      "text": "*/",
      "ja": "* /"
    },
    {
      "indent": 5,
      "text": "augment \"/sn:filters\" {\n  description\n    \"This augmentation allows the datastore to be included as part\n     of the selection-filtering criteria for a subscription.\";\n  list selection-filter {\n    key \"filter-id\";\n    description\n      \"A list of preconfigured filters that can be applied\n       to datastore subscriptions.\";\n    leaf filter-id {\n      type string;\n      description\n        \"An identifier to differentiate between selection\n         filters.\";\n    }\n    uses selection-filter-types;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "augment \"/sn:subscriptions/sn:subscription\" {\n  when 'yp:datastore';\n  description\n    \"This augmentation adds objects to a subscription that are\n     specific to a datastore subscription, i.e., a subscription to\n     a stream of datastore node updates.\";\n  uses update-policy;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  augment \"/sn:subscriptions/sn:subscription/sn:target\" {\n    description\n      \"This augmentation allows the datastore to be included as\n       part of the selection-filtering criteria for a subscription.\";\n    case datastore {\n      uses datastore-criteria;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コード終了>"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers the following namespace URI in the \"IETF XML Registry\" [RFC3688]:",
      "ja": "このドキュメントは、「IETF XML Registry」[RFC3688]に以下の名前空間URIを登録します："
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:yang:ietf-yang-push",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Registrant Contact: The IESG.",
      "ja": "登録者の連絡先：IESG。"
    },
    {
      "indent": 3,
      "text": "XML: N/A; the requested URI is an XML namespace.",
      "ja": "XML：なし。 要求されたURIはXML名前空間です。"
    },
    {
      "indent": 3,
      "text": "This document registers the following YANG module in the \"YANG Module Names\" registry [RFC6020]:",
      "ja": "このドキュメントは、次のYANGモジュールを「YANG Module Names」レジストリ[RFC6020]に登録します。"
    },
    {
      "indent": 3,
      "text": "Name: ietf-yang-push",
      "ja": "名前：ietf-yang-push"
    },
    {
      "indent": 3,
      "text": "Namespace: urn:ietf:params:xml:ns:yang:ietf-yang-push",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Prefix: yp",
      "ja": "プレフィックス：上"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 8641",
      "ja": "参照：RFC 8641"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The YANG module specified in this document defines a schema for data that is designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040]. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) [RFC6242]. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS [RFC8446].",
      "ja": "このドキュメントで指定されているYANGモジュールは、NETCONF [RFC6241]やRESTCONF [RFC8040]などのネットワーク管理プロトコルを介してアクセスするように設計されたデータのスキーマを定義します。 最下位のNETCONF層はセキュアなトランスポート層であり、実装に必須のセキュアなトランスポートはSecure Shell（SSH）[RFC6242]です。 最も低いRESTCONF層はHTTPSであり、実装に必須のセキュアなトランスポートはTLSです[RFC8446]。"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Access Control Model (NACM) [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.",
      "ja": "ネットワーク構成アクセス制御モデル（NACM）[RFC8341]は、特定のNETCONFまたはRESTCONFユーザーのアクセスを、使用可能なすべてのNETCONFまたはRESTCONFプロトコル操作およびコンテンツの事前構成済みサブセットに制限する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "There are a number of data nodes defined in this YANG module that are writable/creatable/deletable (i.e., config true, which is the default). These data nodes may be considered sensitive or vulnerable in some network environments. Write operations (e.g., edit-config) to these data nodes without proper protection can have a negative effect on network operations. These are the subtrees and data nodes and their sensitivity/vulnerability. (It should be noted that the YANG module defined in this document augments the YANG module defined in [RFC8639]. All security considerations that are listed in",
      "ja": "このYANGモジュールには、書き込み可能/作成可能/削除可能な多数のデータノードがあります（つまり、デフォルトのconfig true）。 これらのデータノードは、一部のネットワーク環境では機密または脆弱であると見なされる場合があります。 適切な保護なしでこれらのデータノードに書き込み操作（たとえば、edit-config）を行うと、ネットワーク操作に悪影響を与える可能性があります。 これらは、サブツリーとデータノード、およびそれらの感度/脆弱性です。 （このドキュメントで定義されているYANGモジュールは、[RFC8639]で定義されているYANGモジュールを強化することに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC8639] are also relevant for datastore subscriptions. In the following list, we focus on the new data nodes that are introduced in this document.)",
      "ja": "[RFC8639]は、データストアのサブスクリプションにも関連しています。 次のリストでは、このドキュメントで紹介されている新しいデータノードに焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "o Subtree \"selection-filter\" under container \"filters\": This subtree allows a subscriber to specify which objects or subtrees to include in a datastore subscription. An attacker could attempt to modify the filter. For example, the filter might be modified to result in very few objects being filtered in order to attempt to overwhelm the receiver. Alternatively, the filter might be modified to result in certain objects being excluded from updates, in which case certain changes would go unnoticed.",
      "ja": "o コンテナ「フィルター」の下のサブツリー「選択フィルター」：このサブツリーにより、サブスクライバーは、データストアサブスクリプションに含めるオブジェクトまたはサブツリーを指定できます。 攻撃者はフィルターを変更しようとする可能性があります。 たとえば、受信機を圧倒しようとするために、フィルターが修正されて非常に少数のオブジェクトがフィルター処理される場合があります。 あるいは、フィルターを変更して、特定のオブジェクトが更新から除外されるようにすることもできます。その場合、特定の変更が気付かれなくなります。"
    },
    {
      "indent": 3,
      "text": "o Subtree \"datastore\" in choice \"target\" in list \"subscription\": Analogous to \"selection filter\", an attacker might attempt to modify the objects being filtered in order to overwhelm a receiver with a larger volume of object updates than expected or cause certain changes to go unnoticed.",
      "ja": "o リスト「サブスクリプション」の選択「ターゲット」のサブツリー「データストア」：「選択フィルター」と同様に、攻撃者は、予想よりも大量のオブジェクト更新でレシーバーを圧倒するため、または特定の原因となるように、フィルターされるオブジェクトを変更しようとする可能性があります 気付かないように変更します。"
    },
    {
      "indent": 3,
      "text": "o Choice \"update-trigger\" in list \"subscription\": By modifying the update trigger, an attacker might alter the updates that are being sent in order to confuse a receiver, withhold certain updates to be sent to the receiver, and/or overwhelm a receiver. For example, an attacker might modify the period with which updates are reported for a periodic subscription, or it might modify the dampening period for an on-change subscription, resulting in a greater delay for successive updates (potentially affecting the responsiveness of applications that depend on the updates) or in a high volume of updates (to exhaust receiver resources).",
      "ja": "o リスト「サブスクリプション」の選択肢「更新トリガー」：更新トリガーを変更することにより、攻撃者は受信者を混乱させたり、特定の更新を受信者に送信することを差し控えたり、および/または 受信機。 たとえば、攻撃者は定期的なサブスクリプションの更新が報告される期間を変更したり、変更中のサブスクリプションの減衰期間を変更したりして、連続する更新の遅延を大きくする可能性があります（依存するアプリケーションの応答性に影響を与える可能性があります） 更新時）または大量の更新時（受信機リソースを使い果たすため）。"
    },
    {
      "indent": 3,
      "text": "The NACM provides one means to mitigate these threats on the publisher side. In order to address those threats as a subscriber, the subscriber could monitor the subscription configuration for any unexpected changes and subscribe to updates to the YANG datastore nodes that represent its datastore subscriptions. As this volume of data is small, a paranoid subscriber could even revert to occasional polling to guard against a compromised subscription against subscription configuration updates itself.",
      "ja": "NACMは、パブリッシャー側でこれらの脅威を軽減する1つの手段を提供します。 サブスクライバーとしてこれらの脅威に対処するために、サブスクライバーは予期しない変更がないかサブスクリプション構成を監視し、データストアサブスクリプションを表すYANGデータストアノードの更新をサブスクライブできます。 このデータ量が少ないため、偏執的なサブスクライバーは、定期的なポーリングに戻って、サブスクリプション構成の更新自体に対するサブスクリプションの侵害を防ぐことさえできます。"
    },
    {
      "indent": 3,
      "text": "Some of the readable data nodes in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control read access (e.g., via get, get-config, or notification) to these data nodes. These are the subtrees and data nodes and their sensitivity/vulnerability:",
      "ja": "このYANGモジュールの読み取り可能なデータノードの一部は、一部のネットワーク環境では機密または脆弱であると見なされる場合があります。 したがって、これらのデータノードへの読み取りアクセスを制御することが重要です（例：get、get-config、または通知を使用）。 これらは、サブツリーとデータノード、およびそれらの感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "o Subtree \"selection-filter\" under container \"filters\": If access control is not properly configured, can expose system internals to those who should not have access to this information.",
      "ja": "o コンテナー「フィルター」の下のサブツリー「選択フィルター」：アクセス制御が適切に構成されていない場合、この情報へのアクセス権を持たないユーザーにシステム内部を公開できます。"
    },
    {
      "indent": 3,
      "text": "o Subtree \"datastore\" in choice \"target\" in list \"subscription\": If access control is not properly configured, can expose system internals to those who should not have access to this information.",
      "ja": "o リスト「サブスクリプション」の選択肢「ターゲット」のサブツリー「データストア」：アクセス制御が適切に構成されていない場合、この情報へのアクセス権を持たないユーザーにシステム内部を公開できます。"
    },
    {
      "indent": 3,
      "text": "o Choice \"update-trigger\" in list \"subscription\": If access control is not properly configured, can expose system internals to those who should not have access to this information.",
      "ja": "o リスト「サブスクリプション」の選択肢「更新トリガー」：アクセス制御が適切に構成されていない場合、この情報へのアクセスを許可しないユーザーにシステム内部を公開できます。"
    },
    {
      "indent": 3,
      "text": "Some of the RPC operations in this YANG module may be considered sensitive or vulnerable in some network environments. It is thus important to control access to these operations. These are the operations and their sensitivity/vulnerability:",
      "ja": "このYANGモジュールのRPC操作の一部は、一部のネットワーク環境では機密または脆弱と見なされる場合があります。 したがって、これらの操作へのアクセスを制御することが重要です。 これらは操作とその感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "o RPC \"resync-subscription\": This RPC allows a subscriber of an on-change subscription to request a full push of objects in the subscription's scope. This can result in a large volume of data. An attacker could attempt to use this RPC to exhaust resources on the server to generate the data and could then attempt to overwhelm a receiver with the resulting large volume of data.",
      "ja": "o RPC \"resync-subscription\"：このRPCにより、オンチェンジサブスクリプションのサブスクライバーは、サブスクリプションのスコープ内のオブジェクトのフルプッシュを要求できます。 これにより、大量のデータが発生する可能性があります。 攻撃者は、このRPCを使用してサーバー上のリソースを使い果たしてデータを生成し、大量のデータで受信者を圧倒しようとする可能性があります。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, DOI 10.17487/RFC3688, January 2004, <https://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M。、「IETF XML Registry」、BCP 81、RFC 3688、DOI 10.17487 / RFC3688、2004年1月、<https://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <https://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M.、Ed。、「YANG-ネットワーク構成プロトコル（NETCONF）のデータモデリング言語」、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<https：//www.rfc-editor。 org / info / rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC6991] Schoenwaelder, J., Ed., \"Common YANG Data Types\", RFC 6991, DOI 10.17487/RFC6991, July 2013, <https://www.rfc-editor.org/info/rfc6991>.",
      "ja": "[RFC6991] Schoenwaelder、J.、Ed。、 \"Common YANG Data Types\"、RFC 6991、DOI 10.17487 / RFC6991、July 2013、<https://www.rfc-editor.org/info/rfc6991>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <https://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M.、Ed。、「YANG 1.1データモデリング言語」、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<https://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 3,
      "text": "[RFC8040] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017, <https://www.rfc-editor.org/info/rfc8040>.",
      "ja": "[RFC8040] Bierman、A.、Bjorklund、M。、およびK. Watsen、「RESTCONF Protocol」、RFC 8040、DOI 10.17487 / RFC8040、2017年1月、<https://www.rfc-editor.org/info/rfc8040 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8072] Bierman, A., Bjorklund, M., and K. Watsen, \"YANG Patch Media Type\", RFC 8072, DOI 10.17487/RFC8072, February 2017, <https://www.rfc-editor.org/info/rfc8072>.",
      "ja": "[RFC8072] Bierman、A.、Bjorklund、M。、およびK. Watsen、「YANG Patch Media Type」、RFC 8072、DOI 10.17487 / RFC8072、2017年2月、<https://www.rfc-editor.org/info / rfc8072>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8341] Bierman, A. and M. Bjorklund, \"Network Configuration Access Control Model\", STD 91, RFC 8341, DOI 10.17487/RFC8341, March 2018, <https://www.rfc-editor.org/info/rfc8341>.",
      "ja": "[RFC8341] Bierman、A。およびM. Bjorklund、「ネットワーク構成アクセス制御モデル」、STD 91、RFC 8341、DOI 10.17487 / RFC8341、2018年3月、<https://www.rfc-editor.org/info/rfc8341 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8342] Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K., and R. Wilton, \"Network Management Datastore Architecture (NMDA)\", RFC 8342, DOI 10.17487/RFC8342, March 2018, <https://www.rfc-editor.org/info/rfc8342>.",
      "ja": "[RFC8342] Bjorklund、M.、Schoenwaelder、J.、Shafer、P.、Watsen、K。、およびR. Wilton、「Network Management Datastore Architecture（NMDA）」、RFC 8342、DOI 10.17487 / RFC8342、2018年3月、< https://www.rfc-editor.org/info/rfc8342>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8525] Bierman, A., Bjorklund, M., Schoenwaelder, J., Watsen, K., and R. Wilton, \"YANG Library\", RFC 8525, DOI 10.17487/RFC8525, March 2019, <https://www.rfc-editor.org/info/rfc8525>.",
      "ja": "[RFC8525] Bierman、A.、Bjorklund、M.、Schoenwaelder、J.、Watsen、K。、およびR. Wilton、「YANG Library」、RFC 8525、DOI 10.17487 / RFC8525、2019年3月、<https：// www .rfc-editor.org / info / rfc8525>。"
    },
    {
      "indent": 3,
      "text": "[RFC8639] Voit, E., Clemm, A., Gonzalez Prieto, A., Nilsen-Nygaard, E., and A. Tripathy, \"Subscription to YANG Notifications\", RFC 8639, DOI 10.17487/RFC8639, September 2019, <https://www.rfc-editor.org/info/rfc8639>.",
      "ja": "[RFC8639] Voit、E.、Clemm、A.、Gonzalez Prieto、A.、Nilsen-Nygaard、E。、およびA.Tripathy、「Subscription to YANG Notifications」、RFC 8639、DOI 10.17487 / RFC8639、2019年9月、< https://www.rfc-editor.org/info/rfc8639>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xml-20081126] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <https://www.w3.org/TR/2008/REC-xml-20081126>.",
      "ja": "[W3C.REC-xml-20081126] Bray、T.、Paoli、J.、Sperberg-McQueen、M.、Maler、E。、およびF. Yergeau、「Extensible Markup Language（XML）1.0（第5版）」、 World Wide Web Consortium Recommendation REC-xml-20081126、2008年11月、<https://www.w3.org/TR/2008/REC-xml-20081126>。"
    },
    {
      "indent": 3,
      "text": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", November 1999, <https://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "ja": "[XPATH] Clark、J。およびS. DeRose、「XMLパス言語（XPath）バージョン1.0」、1999年11月、<https://www.w3.org/TR/1999/REC-xpath-19991116>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <https://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241] Enns、R.、Ed。、Bjorklund、M.、Ed。、Schoenwaelder、J.、Ed。、およびA.Bierman、Ed。、「Network Configuration Protocol（NETCONF）」、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<https://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC6242] Wasserman, M., \"Using the NETCONF Protocol over Secure Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011, <https://www.rfc-editor.org/info/rfc6242>.",
      "ja": "[RFC6242] Wasserman、M。、「Secure Shell（SSH）を介したNETCONFプロトコルの使用」、RFC 6242、DOI 10.17487 / RFC6242、2011年6月、<https://www.rfc-editor.org/info/rfc6242>。"
    },
    {
      "indent": 3,
      "text": "[RFC7923] Voit, E., Clemm, A., and A. Gonzalez Prieto, \"Requirements for Subscription to YANG Datastores\", RFC 7923, DOI 10.17487/RFC7923, June 2016, <https://www.rfc-editor.org/info/rfc7923>.",
      "ja": "[RFC7923] Voit、E.、Clemm、A。、およびA. Gonzalez Prieto、「YANGデータストアへのサブスクリプションの要件」、RFC 7923、DOI 10.17487 / RFC7923、2016年6月、<https：//www.rfc-editor。 org / info / rfc7923>。"
    },
    {
      "indent": 3,
      "text": "[RFC8340] Bjorklund, M. and L. Berger, Ed., \"YANG Tree Diagrams\", BCP 215, RFC 8340, DOI 10.17487/RFC8340, March 2018, <https://www.rfc-editor.org/info/rfc8340>.",
      "ja": "[RFC8340] Bjorklund、M.およびL. Berger、Ed。、「YANG Tree Diagrams」、BCP 215、RFC 8340、DOI 10.17487 / RFC8340、2018年3月、<https://www.rfc-editor.org/info/ rfc8340>。"
    },
    {
      "indent": 3,
      "text": "[RFC8343] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 8343, DOI 10.17487/RFC8343, March 2018, <https://www.rfc-editor.org/info/rfc8343>.",
      "ja": "[RFC8343] Bjorklund、M.、「インターフェース管理のためのYANGデータモデル」、RFC 8343、DOI 10.17487 / RFC8343、2018年3月、<https://www.rfc-editor.org/info/rfc8343>。"
    },
    {
      "indent": 3,
      "text": "[RFC8640] Voit, E., Clemm, A., Gonzalez Prieto, A., Nilsen-Nygaard, E., and A. Tripathy, \"Dynamic Subscription to YANG Events and Datastores over NETCONF\", RFC 8640, DOI 10.17487/RFC8640, September 2019, <https://www.rfc-editor.org/info/rfc8640>.",
      "ja": "[RFC8640] Voit、E.、Clemm、A.、Gonzalez Prieto、A.、Nilsen-Nygaard、E。、およびA.Tripathy、「NETCONFを介したYANGイベントおよびデータストアへの動的サブスクリプション」、RFC 8640、DOI 10.17487 / RFC8640 、2019年9月、<https://www.rfc-editor.org/info/rfc8640>。"
    },
    {
      "indent": 3,
      "text": "[Yang-Push-Notif-Cap] Lengyel, B., Clemm, A., and B. Claise, \"Yang-Push Notification Capabilities\", Work in Progress, draft-ietf-netconf-notification-capabilities-04, September 2019.",
      "ja": "[Yang-Push-Notif-Cap] Lengyel、B.、Clemm、A。、およびB. Claise、「Yang-Push Notification Capabilities」、Work in Progress、draft-ietf-netconf-notification-capabilities-04、2019年9月 。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Subscription Errors",
      "section_title": true,
      "ja": "付録A.サブスクリプションエラー"
    },
    {
      "indent": 0,
      "text": "A.1. RPC Failures",
      "section_title": true,
      "ja": "A.1. RPCの障害"
    },
    {
      "indent": 3,
      "text": "Rejection of an RPC for any reason is indicated via an RPC error response from the publisher. Valid RPC errors returned include both (1) existing transport-layer RPC error codes, such as those seen with NETCONF in [RFC6241] and (2) subscription-specific errors, such as those defined in the YANG data model. As a result, how subscription errors are encoded in an RPC error response is transport dependent.",
      "ja": "何らかの理由でRPCが拒否されたことは、パブリッシャーからのRPCエラー応答によって示されます。 返される有効なRPCエラーには、（1）[RFC6241]のNETCONFで見られるような既存のトランスポート層RPCエラーコード、および（2）YANGデータモデルで定義されたようなサブスクリプション固有のエラーの両方が含まれます。 その結果、RPCエラー応答でサブスクリプションエラーがどのようにエンコードされるかは、トランスポートに依存します。"
    },
    {
      "indent": 3,
      "text": "References to specific identities in the ietf-subscribed-notifications YANG module [RFC8639] or the ietf-yang-push YANG module may be returned as part of the error responses resulting from failed attempts at datastore subscription. For errors defined as part of the ietf-subscribed-notifications YANG module, please refer to [RFC8639]. The errors defined in this document, grouped per RPC, are as follows:",
      "ja": "ietf-subscribed-notifications YANGモジュール[RFC8639]またはietf-yang-push YANGモジュールの特定のIDへの参照は、データストアサブスクリプションの試行の失敗に起因するエラー応答の一部として返される場合があります。 ietf-subscribed-notifications YANGモジュールの一部として定義されたエラーについては、[RFC8639]を参照してください。 RPCごとにグループ化された、このドキュメントで定義されているエラーは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "establish-subscription          modify-subscription\n---------------------------     ---------------------\n cant-exclude                    period-unsupported\n datastore-not-subscribable      update-too-big\n on-change-unsupported           sync-too-big\n on-change-sync-unsupported      unchanging-selection\n period-unsupported\n update-too-big                 resync-subscription\n sync-too-big                   ----------------------------\n unchanging-selection            no-such-subscription-resync\n                                 sync-too-big",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There is one final set of transport-independent RPC error elements included in the YANG data model. These are the four yang-data structures for failed datastore subscriptions:",
      "ja": "YANGデータモデルには、トランスポートに依存しないRPCエラー要素の最終セットが1つ含まれています。 これらは、失敗したデータストアサブスクリプションの4つのヤンデータ構造です。"
    },
    {
      "indent": 3,
      "text": "1. yang-data \"establish-subscription-error-datastore\": This MUST be returned if information identifying the reason for an RPC error has not been placed elsewhere in the transport portion of a failed \"establish-subscription\" RPC response. This MUST be sent if hints are included.",
      "ja": "1. yang-data \"establish-subscription-error-datastore\"：RPCエラーの理由を特定する情報が、失敗した「establish-subscription」RPC応答のトランスポート部分に他の場所に配置されていない場合、これを返さなければなりません。 ヒントが含まれる場合、これを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. yang-data \"modify-subscription-error-datastore\": This MUST be returned if information identifying the reason for an RPC error has not been placed elsewhere in the transport portion of a failed \"modify-subscription\" RPC response. This MUST be sent if hints are included.",
      "ja": "2. yang-data \"modify-subscription-error-datastore\"：RPCエラーの理由を特定する情報が、失敗した \"modify-subscription\" RPC応答のトランスポート部分の他の場所に配置されていない場合、これを返さなければなりません。 ヒントが含まれる場合、これを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. yang-data \"sn:delete-subscription-error\": This MUST be returned if information identifying the reason for an RPC error has not been placed elsewhere in the transport portion of a failed \"delete-subscription\" or \"kill-subscription\" RPC response.",
      "ja": "3. yang-data \"sn：delete-subscription-error\"：RPCエラーの理由を特定する情報が、失敗した「delete-subscription」または「kill-subscription」RPCのトランスポート部分のどこにも配置されていない場合、これを返さなければなりません 応答。"
    },
    {
      "indent": 3,
      "text": "4. yang-data \"resync-subscription-error\": This MUST be returned if information identifying the reason for an RPC error has not been placed elsewhere in the transport portion of a failed \"resync-subscription\" RPC response.",
      "ja": "4. yang-data \"resync-subscription-error\"：RPCエラーの理由を特定する情報が、失敗した「resync-subscription」RPC応答のトランスポート部分の他の場所に配置されていない場合、これを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "A.2. Failure Notifications",
      "section_title": true,
      "ja": "A.2. 失敗の通知"
    },
    {
      "indent": 3,
      "text": "A subscription may be unexpectedly terminated or suspended independently of any RPC or configuration operation. In such cases, indications of such a failure MUST be provided. To accomplish this, a number of errors can be returned as part of the corresponding subscription state change notification. For this purpose, the following error identities are introduced in this document, in addition to those that were already defined in [RFC8639]:",
      "ja": "サブスクリプションは、RPCまたは構成操作に関係なく、予期せずに終了または中断される場合があります。 そのような場合、そのような失敗の表示を提供しなければなりません。 これを実現するために、対応するサブスクリプション状態変更通知の一部として多くのエラーを返すことができます。 この目的のために、[RFC8639]で既に定義されているものに加えて、このドキュメントでは次のエラーIDが導入されています。"
    },
    {
      "indent": 3,
      "text": "subscription-terminated        subscription-suspended\n---------------------------    ----------------------\n datastore-not-subscribable     period-unsupported\n unchanging-selection           update-too-big\n                                synchronization-size",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "For their valuable comments, discussions, and feedback, we wish to acknowledge Tim Jenkins, Martin Bjorklund, Kent Watsen, Susan Hares, Yang Geng, Peipei Guo, Michael Scharf, Guangying Zheng, Tom Petch, Henk Birkholz, Reshad Rahman, Qin Wu, Rohit Ranade, and Rob Wilton.",
      "ja": "貴重なコメント、議論、フィードバックについては、ティムジェンキンス、マーティンビョークランド、ケントワトセン、スーザンヘアス、ヤンゲン、ペイペイグオ、マイケルシャーフ、グアンインジェン、トムペッチ、ヘンクビルホルツ、リシャッドラーマン、チンウー、 Rohit Ranade、Rob Wilton。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "貢献者"
    },
    {
      "indent": 3,
      "text": "The following individuals made substantial contributions to this document and should be considered coauthors. Their contributions include information contained in the YANG module provided in Section 5 of this document.",
      "ja": "以下の個人は、この文書に多大な貢献をしており、共著者と見なされるべきです。 彼らの貢献には、このドキュメントのセクション5で提供されるYANGモジュールに含まれる情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "Alberto Gonzalez Prieto Microsoft Email: alberto.gonzalez@microsoft.com",
      "ja": "Alberto Gonzalez Prieto Microsoft電子メール：alberto.gonzalez@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Ambika Prasad Tripathy Cisco Systems Email: ambtripa@cisco.com",
      "ja": "Ambika Prasad Tripathy Cisco Systems電子メール：ambtripa@cisco.com"
    },
    {
      "indent": 3,
      "text": "Einar Nilsen-Nygaard Cisco Systems Email: einarnn@cisco.com",
      "ja": "Einar Nilsen-Nygaard Cisco Systems電子メール：einarnn@cisco.com"
    },
    {
      "indent": 3,
      "text": "Andy Bierman YumaWorks Email: andy@yumaworks.com",
      "ja": "Andy Bierman YumaWorksメール：andy@yumaworks.com"
    },
    {
      "indent": 3,
      "text": "Balazs Lengyel Ericsson Email: balazs.lengyel@ericsson.com",
      "ja": "Balazs Lengyel Ericssonメール：balazs.lengyel@ericsson.com"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alexander Clemm Futurewei",
      "ja": "アレクサンダー・クレム・フューチャーウェイ"
    },
    {
      "indent": 3,
      "text": "Email: ludwig@clemm.org",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Eric Voit Cisco Systems",
      "ja": "エリックヴォイトシスコシステムズ"
    },
    {
      "indent": 3,
      "text": "Email: evoit@cisco.com",
      "raw": true
    }
  ]
}