{
  "title": {
    "text": "RFC 8422 - Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier",
    "ja": "RFC 8422 - 楕円曲線暗号（ECC）トランスポート層セキュリティのための暗号スイート（TLS）バージョン1.2およびそれ以前"
  },
  "number": 8422,
  "created_at": "2019-11-01 21:09:17.198178+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                            Y. Nir\nRequest for Comments: 8422                                   Check Point\nObsoletes: 4492                                             S. Josefsson\nCategory: Standards Track                                         SJD AB\nISSN: 2070-1721                                      M. Pegourie-Gonnard\n                                                                     ARM\n                                                             August 2018",
      "raw": true
    },
    {
      "indent": 6,
      "text": "      Elliptic Curve Cryptography (ECC) Cipher Suites\nfor Transport Layer Security (TLS) Versions 1.2 and Earlier",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol. In particular, it specifies the use of Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) key agreement in a TLS handshake and the use of the Elliptic Curve Digital Signature Algorithm (ECDSA) and Edwards-curve Digital Signature Algorithm (EdDSA) as authentication mechanisms.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）プロトコルの楕円曲線暗号（ECC）に基づいて、鍵交換アルゴリズムを説明します。特に、TLSハンドシェイク認証機構として楕円曲線デジタル署名アルゴリズム（ECDSA）及びエドワーズ曲線デジタル署名アルゴリズム（エドワーズ曲線デジタル署名アルゴリズム）の使用でエフェメラル楕円曲線ディフィ - ヘルマン（ECDHE）キー合意の使用を指定します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 4492.",
      "ja": "この文書はRFC 4492を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8422.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8422で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n2.  Key Exchange Algorithm  . . . . . . . . . . . . . . . . . . .   4\n  2.1.  ECDHE_ECDSA . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.2.  ECDHE_RSA . . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.3.  ECDH_anon . . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.4.  Algorithms in Certificate Chains  . . . . . . . . . . . .   7\n3.  Client Authentication . . . . . . . . . . . . . . . . . . . .   8\n  3.1.  ECDSA_sign  . . . . . . . . . . . . . . . . . . . . . . .   8\n4.  TLS Extensions for ECC  . . . . . . . . . . . . . . . . . . .   9\n5.  Data Structures and Computations  . . . . . . . . . . . . . .  10\n  5.1.  Client Hello Extensions . . . . . . . . . . . . . . . . .  10\n    5.1.1.  Supported Elliptic Curves Extension . . . . . . . . .  11\n    5.1.2.  Supported Point Formats Extension . . . . . . . . . .  13\n    5.1.3.  The signature_algorithms Extension and EdDSA  . . . .  13\n  5.2.  Server Hello Extension  . . . . . . . . . . . . . . . . .  14\n  5.3.  Server Certificate  . . . . . . . . . . . . . . . . . . .  15\n  5.4.  Server Key Exchange . . . . . . . . . . . . . . . . . . .  16\n    5.4.1.  Uncompressed Point Format for NIST Curves . . . . . .  19\n  5.5.  Certificate Request . . . . . . . . . . . . . . . . . . .  20\n  5.6.  Client Certificate  . . . . . . . . . . . . . . . . . . .  21\n  5.7.  Client Key Exchange . . . . . . . . . . . . . . . . . . .  22\n  5.8.  Certificate Verify  . . . . . . . . . . . . . . . . . . .  23\n  5.9.  Elliptic Curve Certificates . . . . . . . . . . . . . . .  24\n  5.10. ECDH, ECDSA, and RSA Computations . . . . . . . . . . . .  24\n  5.11. Public Key Validation . . . . . . . . . . . . . . . . . .  26\n6.  Cipher Suites . . . . . . . . . . . . . . . . . . . . . . . .  26\n7.  Implementation Status . . . . . . . . . . . . . . . . . . . .  27\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  27\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  29\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  31\nAppendix A.  Equivalent Curves (Informative)  . . . . . . . . . .  32\nAppendix B.  Differences from RFC 4492  . . . . . . . . . . . . .  33\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  34\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  34",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes additions to TLS to support ECC that are applicable to TLS versions 1.0 [RFC2246], 1.1 [RFC4346], and 1.2 [RFC5246]. The use of ECC in TLS 1.3 is defined in [TLS1.3] and is explicitly out of scope for this document. In particular, this document defines:",
      "ja": "この文書では、TLSバージョン1.0 [RFC2246]、1.1 [RFC4346]、および1.2 [RFC5246]に適用可能なECCをサポートするために、TLSへの追加を説明しています。 TLS 1.3でECCの使用は、[TLS1.3]で定義されており、この文書の範囲外明示的です。具体的には、この文書では定義しています。"
    },
    {
      "indent": 3,
      "text": "o the use of the ECDHE key agreement scheme with ephemeral keys to establish the TLS premaster secret, and",
      "ja": "TLSのプレマスターシークレットを確立するために、はかないキーでECDHE鍵合意スキームの使用O、および"
    },
    {
      "indent": 3,
      "text": "o the use of ECDSA and EdDSA signatures for authentication of TLS peers.",
      "ja": "TLSピアの認証のためのECDSAとエドワーズ曲線デジタル署名アルゴリズム署名の使用、O。"
    },
    {
      "indent": 3,
      "text": "The remainder of this document is organized as follows. Section 2 provides an overview of ECC-based key exchange algorithms for TLS. Section 3 describes the use of ECC certificates for client authentication. TLS extensions that allow a client to negotiate the use of specific curves and point formats are presented in Section 4. Section 5 specifies various data structures needed for an ECC-based handshake, their encoding in TLS messages, and the processing of those messages. Section 6 defines ECC-based cipher suites and identifies a small subset of these as recommended for all implementations of this specification. Section 8 discusses security considerations. Section 9 describes IANA considerations for the name spaces created by this document's predecessor. Appendix B provides differences from [RFC4492], the document that this one replaces.",
      "ja": "このドキュメントの残りは以下の通り構成されています。第2節では、TLSのためのECCベースの鍵交換アルゴリズムの概要を説明します。第3節では、クライアント認証のためのECC証明書の使用を記載しています。クライアントが特定の曲線と点フォーマットの使用を交渉することができTLS拡張機能は、第4節第5節で提示されている各種データECCベースのハンドシェイクのために必要な構造、TLSメッセージでのエンコーディング、およびそれらのメッセージの処理を指定します。セクション6は、ECCベースの暗号スイートを定義し、本明細書のすべての実装のために推奨されているように、これらの小さなサブセットを識別する。第8章では、セキュリティの考慮事項について説明します。第9章は、この文書の前任者によって作成された名前空間のためのIANAの考慮事項について説明します。付録Bには、[RFC4492]との違い、この1つは代わる文書を提供します。"
    },
    {
      "indent": 3,
      "text": "Implementation of this specification requires familiarity with TLS, TLS extensions [RFC4366], and ECC.",
      "ja": "この仕様の実装は、TLSに精通し、TLS拡張[RFC4366]、およびECCが必要です。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2. Key Exchange Algorithm",
      "section_title": true,
      "ja": "2.鍵交換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This document defines three new ECC-based key exchange algorithms for TLS. All of them use Ephemeral ECDH (ECDHE) to compute the TLS premaster secret, and they differ only in the mechanism (if any) used to authenticate them. The derivation of the TLS master secret from the premaster secret and the subsequent generation of bulk encryption/MAC keys and initialization vectors is independent of the key exchange algorithm and not impacted by the introduction of ECC.",
      "ja": "このドキュメントは、TLSのための3つの新しいECCベースの鍵交換アルゴリズムを定義します。それらのすべては、TLSプレマスターの秘密を計算するためにエフェメラルECDH（ECDHE）を使用し、彼らはそれらを認証するために使用されるメカニズム（もしあれば）のみが異なります。前マスターシークレットからTLSマスターシークレットの導出およびバルク暗号化/ MACキーと初期化ベクトルの次の世代は、鍵交換アルゴリズムとは無関係であり、ECCの導入によって影響を受けません。"
    },
    {
      "indent": 3,
      "text": "Table 1 summarizes the new key exchange algorithms. All of these key exchange algorithms provide forward secrecy if and only if fresh ephemeral keys are generated and used, and also destroyed after use.",
      "ja": "表1は、新たな鍵交換アルゴリズムをまとめました。そして新鮮なはかないキーは使用後に生成され、使用され、また、破壊された場合にのみ場合は、これらの鍵交換アルゴリズムのすべては前進の秘密保持を提供しています。"
    },
    {
      "indent": 5,
      "text": "+-------------+------------------------------------------------+\n| Algorithm   | Description                                    |\n+-------------+------------------------------------------------+\n| ECDHE_ECDSA | Ephemeral ECDH with ECDSA or EdDSA signatures. |\n| ECDHE_RSA   | Ephemeral ECDH with RSA signatures.            |\n| ECDH_anon   | Anonymous ephemeral ECDH, no signatures.       |\n+-------------+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 1: ECC Key Exchange Algorithms",
      "ja": "表1：ECC鍵交換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "These key exchanges are analogous to DHE_DSS, DHE_RSA, and DH_anon, respectively.",
      "ja": "これらのキー交換は、それぞれ、DHE_DSS、DHE_RSA、およびDH_anonに似ています。"
    },
    {
      "indent": 3,
      "text": "With ECDHE_RSA, a server can reuse its existing RSA certificate and easily comply with a constrained client's elliptic curve preferences (see Section 4). However, the computational cost incurred by a server is higher for ECDHE_RSA than for the traditional RSA key exchange, which does not provide forward secrecy.",
      "ja": "ECDHE_RSAでは、サーバーは、既存のRSA証明書を再利用することができ、容易に制約クライアントの楕円曲線の嗜好（セクション4を参照）に準拠しています。ただし、サーバーが被る計算コストは​​前進の秘密保持を提供していない従来のRSA鍵交換のためのよりECDHE_RSAの方が高いです。"
    },
    {
      "indent": 3,
      "text": "The anonymous key exchange algorithm does not provide authentication of the server or the client. Like other anonymous TLS key exchanges, it is subject to man-in-the-middle attacks. Applications using TLS with this algorithm SHOULD provide authentication by other means.",
      "ja": "匿名の鍵交換アルゴリズムは、サーバーまたはクライアントの認証を提供していません。他の匿名TLSキーの交換と同様に、man-in-the-middle攻撃の対象となります。このアルゴリズムでTLSを使用するアプリケーションは、他の手段で認証を提供する必要があります。"
    },
    {
      "indent": 10,
      "text": "Client                                        Server\n------                                        ------\nClientHello          -------->\n                                         ServerHello\n                                        Certificate*\n                                  ServerKeyExchange*\n                                CertificateRequest*+\n                     <--------       ServerHelloDone\nCertificate*+\nClientKeyExchange\nCertificateVerify*+\n[ChangeCipherSpec]\nFinished             -------->\n                                  [ChangeCipherSpec]\n                     <--------              Finished\nApplication Data     <------->      Application Data",
      "raw": true
    },
    {
      "indent": 15,
      "text": "* message is not sent under some conditions\n+ message is not sent unless client authentication\n  is desired",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 1: Message Flow in a Full TLS 1.2 Handshake",
      "ja": "図1：フルTLS 1.2ハンドシェイクでのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows all messages involved in the TLS key establishment protocol (aka full handshake). The addition of ECC has direct impact only on the ClientHello, the ServerHello, the server's Certificate message, the ServerKeyExchange, the ClientKeyExchange, the CertificateRequest, the client's Certificate message, and the CertificateVerify. Next, we describe the ECC key exchange algorithm in greater detail in terms of the content and processing of these messages. For ease of exposition, we defer discussion of client authentication and associated messages (identified with a '+' in Figure 1) until Section 3 and of the optional ECC-specific extensions (which impact the Hello messages) until Section 4.",
      "ja": "図1は、TLS鍵確立プロトコル（別名フルハンドシェーク）に関与するすべてのメッセージを示しています。 ECCの添加は唯一のClientHelloに直接影響を持っている、のServerHello、サーバのCertificateメッセージ、ServerKeyExchange、ClientKeyExchange、CertificateRequest、クライアントの証明書のメッセージ、およびCertificateVerify。次に、我々はこれらのメッセージの内容及び処理の面でより詳細にECC鍵交換アルゴリズムを記述します。説明の容易さのために、我々は、第3節まで及び任意ECC固有の拡張（耐衝撃Helloメッセージ）のセクション4まで、クライアントの認証と（「+」、図1でと識別される）関連するメッセージの議論を延期します。"
    },
    {
      "indent": 0,
      "text": "2.1. ECDHE_ECDSA",
      "section_title": true,
      "ja": "2.1。 ECDHE_ECDSA"
    },
    {
      "indent": 3,
      "text": "In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA- or EdDSA-capable public key.",
      "ja": "ECDHE_ECDSAでは、サーバーの証明書がECDSA-またはエドワーズ曲線デジタル署名アルゴリズム可能な公開鍵を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server sends its ephemeral ECDH public key and a specification of the corresponding curve in the ServerKeyExchange message. These parameters MUST be signed with ECDSA or EdDSA using the private key corresponding to the public key in the server's Certificate.",
      "ja": "サーバーは、そのはかないECDH公開鍵とServerKeyExchangeメッセージに対応する曲線の仕様を送信します。これらのパラメータは、サーバの証明書の公開鍵に対応する秘密鍵を使用して、ECDSAまたはエドワーズ曲線デジタル署名アルゴリズムで署名されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client generates an ECDH key pair on the same curve as the server's ephemeral ECDH key and sends its public key in the ClientKeyExchange message.",
      "ja": "クライアントは、サーバのはかないECDHキーと同じ曲線上ECDH鍵のペアを生成し、ClientKeyExchangeメッセージに公開鍵を送信します。"
    },
    {
      "indent": 3,
      "text": "Both client and server perform an ECDH operation (see Section 5.10) and use the resultant shared secret as the premaster secret.",
      "ja": "クライアントとサーバーの両方がECDH操作を実行（5.10節を参照）、このpremaster_secretとして秘密を共有する結果を使用しています。"
    },
    {
      "indent": 0,
      "text": "2.2. ECDHE_RSA",
      "section_title": true,
      "ja": "2.2。 ECDHE_RSA"
    },
    {
      "indent": 3,
      "text": "This key exchange algorithm is the same as ECDHE_ECDSA except that the server's certificate MUST contain an RSA public key authorized for signing and the signature in the ServerKeyExchange message must be computed with the corresponding RSA private key.",
      "ja": "この鍵交換アルゴリズムは、サーバーの証明書は、ServerKeyExchangeメッセージに署名と署名を許可RSA公開鍵は、対応するRSA秘密鍵で計算しなければならないが含まれなければならないことを除いてECDHE_ECDSAと同じです。"
    },
    {
      "indent": 0,
      "text": "2.3. ECDH_anon",
      "section_title": true,
      "ja": "2.3。 ECDH_anon"
    },
    {
      "indent": 3,
      "text": "NOTE: Despite the name beginning with \"ECDH_\" (no E), the key used in ECDH_anon is ephemeral just like the key in ECDHE_RSA and ECDHE_ECDSA. The naming follows the example of DH_anon, where the key is also ephemeral but the name does not reflect it.",
      "ja": "注：「ECDH_」（なしE）で始まる名前にもかかわらず、ECDH_anonに使用されるキーは、ちょうどECDHE_RSAとECDHE_ECDSAでキーのよう短命です。命名は、キーも短命ですが、名前はそれを反映していないDH_anon、の例に従います。"
    },
    {
      "indent": 3,
      "text": "In ECDH_anon, the server's Certificate, the CertificateRequest, the client's Certificate, and the CertificateVerify messages MUST NOT be sent.",
      "ja": "ECDH_anon、サーバーの証明書では、CertificateRequest、クライアントの証明書、およびCertificateVerifyメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The server MUST send an ephemeral ECDH public key and a specification of the corresponding curve in the ServerKeyExchange message. These parameters MUST NOT be signed.",
      "ja": "サーバは、はかないECDH公開鍵とServerKeyExchangeメッセージに対応する曲線の仕様を送らなければなりません。これらのパラメータは、署名してはなりません。"
    },
    {
      "indent": 3,
      "text": "The client generates an ECDH key pair on the same curve as the server's ephemeral ECDH key and sends its public key in the ClientKeyExchange message.",
      "ja": "クライアントは、サーバのはかないECDHキーと同じ曲線上ECDH鍵のペアを生成し、ClientKeyExchangeメッセージに公開鍵を送信します。"
    },
    {
      "indent": 3,
      "text": "Both client and server perform an ECDH operation and use the resultant shared secret as the premaster secret. All ECDH calculations are performed as specified in Section 5.10.",
      "ja": "クライアントとサーバーの両方がECDH操作を実行し、このpremaster_secretとして結果の共有秘密鍵を使用しています。 5.10節に指定されているすべてのECDH計算が実行されます。"
    },
    {
      "indent": 0,
      "text": "2.4. Algorithms in Certificate Chains",
      "section_title": true,
      "ja": "2.4。証明書チェーンにおけるアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This specification does not impose restrictions on signature schemes used anywhere in the certificate chain. The previous version of this document required the signatures to match, but this restriction, originating in previous TLS versions, is lifted here as it had been in RFC 5246.",
      "ja": "この仕様は、証明書チェーンのどこでも使用署名方式に制限を課しません。このドキュメントの以前のバージョンが一致して署名を必要ですが、それはRFC 5246であったように、この制限、以前のTLSのバージョンでは、発信元は、ここに持ち上げられます。"
    },
    {
      "indent": 0,
      "text": "3. Client Authentication",
      "section_title": true,
      "ja": "3.クライアント認証"
    },
    {
      "indent": 3,
      "text": "This document defines a client authentication mechanism named after the type of client certificate involved: ECDSA_sign. The ECDSA_sign mechanism is usable with any of the non-anonymous ECC key exchange algorithms described in Section 2 as well as other non-anonymous (non-ECC) key exchange algorithms defined in TLS.",
      "ja": "ECDSA_sign：この文書は、関係するクライアント証明書の種類にちなんで名付けられたクライアント認証メカニズムを定義します。 ECDSA_sign機構は、非匿名項2に記載のECC鍵交換アルゴリズムならびにTLSで定義された他の非匿名（非ECC）鍵交換アルゴリズムのいずれかで使用可能です。"
    },
    {
      "indent": 3,
      "text": "Note that client certificates with EdDSA public keys also use this mechanism.",
      "ja": "エドワーズ曲線デジタル署名アルゴリズムの公開鍵とクライアント証明書もこのメカニズムを使用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "The server can request ECC-based client authentication by including this certificate type in its CertificateRequest message. The client must check if it possesses a certificate appropriate for the method suggested by the server and is willing to use it for authentication.",
      "ja": "サーバーは、そのCertificateRequestメッセージにこの証明書の種類を含むことにより、ECCベースのクライアント認証を要求することができます。それは、サーバによって提案された方法のための証明書の適切なを所有し、認証のためにそれを使用して喜んでいる場合、クライアントは確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If these conditions are not met, the client SHOULD send a client Certificate message containing no certificates. In this case, the ClientKeyExchange MUST be sent as described in Section 2, and the CertificateVerify MUST NOT be sent. If the server requires client authentication, it may respond with a fatal handshake failure alert.",
      "ja": "これらの条件が満たされない場合、クライアントには、証明書を含まないクライアント証明書のメッセージを送信する必要があります。この場合には、セクション2で説明したようにClientKeyExchangeを送らなければなりません、そしてCertificateVerifyを送ってはいけません。サーバーがクライアント認証を必要とする場合、それは致命的な握手故障警報で応答することができます。"
    },
    {
      "indent": 3,
      "text": "If the client has an appropriate certificate and is willing to use it for authentication, it must send that certificate in the client's Certificate message (as per Section 5.6) and prove possession of the private key corresponding to the certified key. The process of determining an appropriate certificate and proving possession is different for each authentication mechanism and is described below.",
      "ja": "クライアントは、適切な証明書を持っており、認証のためにそれを使用する意思があるなら、それは（5.6節に従って）、クライアントの証明書のメッセージでその証明書を送信し、認証されたキーに対応する秘密鍵の所有を証明しなければなりません。適切な証明書を決定し、所有を証明するプロセスは、各認証機構のために異なっており、以下に説明します。"
    },
    {
      "indent": 3,
      "text": "NOTE: It is permissible for a server to request (and the client to send) a client certificate of a different type than the server certificate.",
      "ja": "注：サーバ証明書とは異なるタイプのクライアント証明書をサーバーに要求する（そして、クライアントが送信する）ことが許されます。"
    },
    {
      "indent": 0,
      "text": "3.1. ECDSA_sign",
      "section_title": true,
      "ja": "3.1。 ECDSA_sign"
    },
    {
      "indent": 3,
      "text": "To use this authentication mechanism, the client MUST possess a certificate containing an ECDSA- or EdDSA-capable public key.",
      "ja": "この認証メカニズムを使用するには、クライアントはECDSA-またはエドワーズ曲線デジタル署名アルゴリズム可能な公開鍵を含む証明書を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "The client proves possession of the private key corresponding to the certified key by including a signature in the CertificateVerify message as described in Section 5.8.",
      "ja": "クライアントは、5.8節で説明したようにCertificateVerifyメッセージに署名を含めることによって認定されたキーに対応する秘密鍵の所有を証明しています。"
    },
    {
      "indent": 0,
      "text": "4. TLS Extensions for ECC",
      "section_title": true,
      "ja": "ECC 4. TLS拡張"
    },
    {
      "indent": 3,
      "text": "Two TLS extensions are defined in this specification: (i) the Supported Elliptic Curves Extension and (ii) the Supported Point Formats Extension. These allow negotiating the use of specific curves and point formats (e.g., compressed vs. uncompressed, respectively) during a handshake starting a new session. These extensions are especially relevant for constrained clients that may only support a limited number of curves or point formats. They follow the general approach outlined in [RFC4366]; message details are specified in Section 5. The client enumerates the curves it supports and the point formats it can parse by including the appropriate extensions in its ClientHello message. The server similarly enumerates the point formats it can parse by including an extension in its ServerHello message.",
      "ja": "（ⅰ）サポートされている楕円曲線延長および（ii）サポートされている小数点形式拡張子：二つのTLS拡張はこの仕様で定義されています。これらは、特定の曲線と点フォーマットの使用を交渉することを可能に新しいセッションを開始ハンドシェーク中（例えば、それぞれ、非圧縮対圧縮）。これらの拡張機能はカーブやポイント形式の限られた数をサポートすることが可能に制約のクライアントのために特に関連しています。彼らは[RFC4366]に記載の一般的なアプローチに従います。メッセージの詳細はセクション5で指定されたクライアントは、それがサポートするカーブと、それはそのClientHelloメッセージに適切な拡張子を含めることによって解析できるポイント形式を列挙します。サーバは、同様に、そのServerHelloメッセージに拡張を含めることによって解析できる点フォーマットを列挙する。"
    },
    {
      "indent": 3,
      "text": "A TLS client that proposes ECC cipher suites in its ClientHello message SHOULD include these extensions. Servers implementing ECC cipher suites MUST support these extensions, and when a client uses these extensions, servers MUST NOT negotiate the use of an ECC cipher suite unless they can complete the handshake while respecting the choice of curves specified by the client. This eliminates the possibility that a negotiated ECC handshake will be subsequently aborted due to a client's inability to deal with the server's EC key.",
      "ja": "そのClientHelloメッセージでECC暗号スイートを提案しているTLSクライアントは、これらの拡張を含むべきです。 ECC暗号スイートを実装したサーバは、これらの拡張をサポートしなければならない、そしてクライアントがこれらの拡張機能を使用する場合、クライアントによって指定された曲線の選択を尊重しながら、彼らは握手を完了することができない限り、サーバーは、ECC暗号スイートの使用を交渉してはなりません。これは、交渉されたECC握手がその後により、サーバのECキーに対処するために、クライアントのできないために中止される可能性を排除します。"
    },
    {
      "indent": 3,
      "text": "The client MUST NOT include these extensions in the ClientHello message if it does not propose any ECC cipher suites. A client that proposes ECC cipher suites may choose not to include these extensions. In this case, the server is free to choose any one of the elliptic curves or point formats listed in Section 5. That section also describes the structure and processing of these extensions in greater detail.",
      "ja": "それは任意のECC暗号スイートを提案していない場合、クライアントはClientHelloメッセージにこれらの拡張機能を含んではいけません。 ECC暗号スイートを提案しているクライアントは、これらの拡張を含めないことを選択することができます。この場合、サーバは、セクションはまた、より詳細にこれらの拡張の構造と処理を記述した楕円曲線またはセクション5に記載されている点フォーマットのいずれかを選択する自由です。"
    },
    {
      "indent": 3,
      "text": "In the case of session resumption, the server simply ignores the Supported Elliptic Curves Extension and the Supported Point Formats Extension appearing in the current ClientHello message. These extensions only play a role during handshakes negotiating a new session.",
      "ja": "セッション再開の場合、サーバは単にサポートされている楕円曲線拡張し、現在のClientHelloメッセージに表示されてサポートされている小数点形式拡張子を無視します。これらの拡張機能は、新しいセッションを交渉ハンドシェイク中に役割を果たしています。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures and Computations",
      "section_title": true,
      "ja": "5.データ構造と計算"
    },
    {
      "indent": 3,
      "text": "This section specifies the data structures and computations used by ECC-based key mechanisms specified in the previous three sections. The presentation language used here is the same as that used in TLS. Since this specification extends TLS, these descriptions should be merged with those in the TLS specification and any others that extend TLS. This means that enum types may not specify all possible values, and structures with multiple formats chosen with a select() clause may not indicate all possible cases.",
      "ja": "このセクションでは、前の3つのセクションで指定されたECCベースのキーメカニズムによって使用されるデータ構造及び計算を指定します。ここで使用したプレゼンテーションの言語は、TLSで使用したものと同じです。この仕様は、TLSを拡張するため、これらの説明は、TLS仕様とTLSを拡張する任意の他のものとマージされるべきです。これは、列挙タイプは、すべての可能なケースを示していてもよいセレクト（）句を使用して選択された複数のフォーマットを有する全ての可能な値、および構造を指定しなくてもよいことを意味します。"
    },
    {
      "indent": 0,
      "text": "5.1. Client Hello Extensions",
      "section_title": true,
      "ja": "5.1。クライアントこんにちは拡張"
    },
    {
      "indent": 3,
      "text": "This section specifies two TLS extensions that can be included with the ClientHello message as described in [RFC4366]: the Supported Elliptic Curves Extension and the Supported Point Formats Extension.",
      "ja": "サポートされている楕円曲線拡張とサポートポイントフォーマット拡張子：このセクションでは、[RFC4366]に記載されているようにClientHelloメッセージに含めることができる2つのTLS拡張子を指定します。"
    },
    {
      "indent": 3,
      "text": "When these extensions are sent:",
      "ja": "これらの拡張機能は、送信された場合："
    },
    {
      "indent": 3,
      "text": "The extensions SHOULD be sent along with any ClientHello message that proposes ECC cipher suites.",
      "ja": "拡張機能は、ECC暗号スイートを提案している任意のClientHelloメッセージと一緒に送ってください。"
    },
    {
      "indent": 3,
      "text": "Meaning of these extensions:",
      "ja": "これらの拡張機能の意味："
    },
    {
      "indent": 3,
      "text": "These extensions allow a client to enumerate the elliptic curves it supports and/or the point formats it can parse.",
      "ja": "これらの拡張機能は、クライアントがそれをサポートしている楕円曲線および/またはそれを解析できるポイント形式を列挙することができます。"
    },
    {
      "indent": 3,
      "text": "Structure of these extensions:",
      "ja": "これらの拡張機能の構造："
    },
    {
      "indent": 3,
      "text": "The general structure of TLS extensions is described in [RFC4366], and this specification adds two types to ExtensionType.",
      "ja": "TLS拡張の一般的な構造は、[RFC4366]に記載され、そして本明細書はExtensionTypeに二つのタイプを追加します。"
    },
    {
      "indent": 6,
      "text": "enum {\n    elliptic_curves(10),\n    ec_point_formats(11)\n} ExtensionType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o elliptic_curves (Supported Elliptic Curves Extension): Indicates the set of elliptic curves supported by the client. For this extension, the opaque extension_data field contains NamedCurveList. See Section 5.1.1 for details.",
      "ja": "elliptic_curves O（サポートされている楕円曲線の延長は）：クライアントでサポートされている楕円曲線のセットを示します。この拡張のために、不透明な拡フィールドがNamedCurveListが含まれています。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o ec_point_formats (Supported Point Formats Extension): Indicates the set of point formats that the client can parse. For this extension, the opaque extension_data field contains ECPointFormatList. See Section 5.1.2 for details.",
      "ja": "O ec_point_formats（小数点形式拡張をサポート）：クライアントが解析できるポイント形式のセットを示します。この拡張のために、不透明な拡フィールドがECPointFormatListが含まれています。詳細については、5.1.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "A client that proposes ECC cipher suites in its ClientHello message appends these extensions (along with any others), enumerating the curves it supports and the point formats it can parse. Clients SHOULD send both the Supported Elliptic Curves Extension and the Supported Point Formats Extension. If the Supported Point Formats Extension is indeed sent, it MUST contain the value 0 (uncompressed) as one of the items in the list of point formats.",
      "ja": "そのClientHelloメッセージでECC暗号スイートを提案しているクライアントは、それがサポートするカーブと、それが解析できるポイント形式を列挙し、（他のものと一緒に）これらの拡張機能を付加します。クライアントがサポートされている楕円曲線拡張およびサポートされている小数点形式拡張の両方を送るべきです。サポートされている小数点形式拡張子が実際に送信された場合、それはポイント形式のリスト内の項目の一つとして値0（非圧縮）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "A server that receives a ClientHello containing one or both of these extensions MUST use the client's enumerated capabilities to guide its selection of an appropriate cipher suite. One of the proposed ECC cipher suites must be negotiated only if the server can successfully complete the handshake while using the curves and point formats supported by the client (cf. Sections 5.3 and 5.4).",
      "ja": "これらの拡張機能のいずれかまたは両方を含むのClientHelloを受信するサーバーは、適切な暗号スイートのその選択を導くために、クライアントの列挙機能を使用しなければなりません。提案されたECC暗号スイートの一つは、クライアントによってサポートされた曲線とポイント形式（参照：セクション5.3および5.4）を使用している間、サーバーが正常に握手を完了することができた場合にのみ交渉しなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTE: A server participating in an ECDHE_ECDSA key exchange may use different curves for the ECDSA or EdDSA key in its certificate and for the ephemeral ECDH key in the ServerKeyExchange message. The server MUST consider the extensions in both cases.",
      "ja": "注：ECDHE_ECDSA鍵交換に参加しているサーバは、その証明書にECDSA又はエドワーズ曲線デジタル署名アルゴリズム、キーおよびServerKeyExchangeメッセージではかないECDHキーの異なる曲線を使用してもよいです。サーバーは、両方のケースで拡張を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server does not understand the Supported Elliptic Curves Extension, does not understand the Supported Point Formats Extension, or is unable to complete the ECC handshake while restricting itself to the enumerated curves and point formats, it MUST NOT negotiate the use of an ECC cipher suite. Depending on what other cipher suites are proposed by the client and supported by the server, this may result in a fatal handshake failure alert due to the lack of common cipher suites.",
      "ja": "サーバがサポートされている楕円曲線拡張を理解していない場合は、それがECC暗号の使用を交渉してはならない、サポートされている小数点形式拡張子を理解し、または列挙カーブとポイント形式に自分自身を制限しながら、ECCハンドシェイクを完了することができませんしません。組。クライアントによって提案され、サーバーによってサポートされている暗号他のどのようなスイートによっては、これは、一般的な暗号スイートの不足のために致命的な握手故障警報をもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Supported Elliptic Curves Extension",
      "section_title": true,
      "ja": "5.1.1。サポートされている楕円曲線の拡張"
    },
    {
      "indent": 3,
      "text": "RFC 4492 defined 25 different curves in the NamedCurve registry (now renamed the \"TLS Supported Groups\" registry, although the enumeration below is still named NamedCurve) for use in TLS. Only three have seen much use. This specification is deprecating the rest (with numbers 1-22). This specification also deprecates the explicit curves with identifiers 0xFF01 and 0xFF02. It also adds the new curves defined in [RFC7748]. The end result is as follows:",
      "ja": "TLSで使用するためにRFC 4492がNamedCurveレジストリに25本の異なる曲線を定義した（以下の列挙はまだNamedCurve名付けているが、今、「TLSグループをサポートする」レジストリを改称）。 3つだけは、多くの使用を見てきました。この仕様は、（番号1-22で）残りを卑下されます。また、この仕様は、識別子0xFF01と0xFF02で明示的な曲線を非難します。また、[RFC7748]で定義された新しいカーブを追加します。次のように最終的な結果は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "enum {\n    deprecated(1..22),\n    secp256r1 (23), secp384r1 (24), secp521r1 (25),\n    x25519(29), x448(30),\n    reserved (0xFE00..0xFEFF),\n    deprecated(0xFF01..0xFF02),\n    (0xFFFF)\n} NamedCurve;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that other specifications have since added other values to this enumeration. Some of those values are not curves at all, but finite field groups. See [RFC7919].",
      "ja": "その他の仕様は、以来、この列挙に他の値を追加していることに注意してください。これらの値のいくつかは、すべての曲線ではなく、有限フィールドグループ。 [RFC7919]を参照してください。"
    },
    {
      "indent": 3,
      "text": "secp256r1, etc: Indicates support of the corresponding named curve or groups. The named curves secp256r1, secp384r1, and secp521r1 are specified in SEC 2 [SECG-SEC2]. These curves are also recommended in ANSI X9.62 [ANSI.X9-62.2005] and FIPS 186-4 [FIPS.186-4]. The rest of this document refers to these three curves as the \"NIST curves\" because they were originally standardized by the National Institute of Standards and Technology. The curves x25519 and x448 are defined in [RFC7748]. Values 0xFE00 through 0xFEFF are reserved for private use.",
      "ja": "secp256r1などは：対応する名前の曲線やグループのサポートを示します。名前曲線secp256r1、secp384r1、及びsecp521r1はSEC 2 [SECG-SEC2]で指定されています。これらの曲線はまた、ANSI X9.62 [ANSI.X9-62.2005]とFIPS 186から4 [FIPS.186-4]で推奨されています。彼らはもともとアメリカ国立標準技術研究所によって標準化されたため、この文書の残りの部分は、「NIST曲線」として、これらの3つの曲線を指します。曲線x25519とx448は[RFC7748]で定義されています。 0xFEFFまでの値0xFE00は、私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The predecessor of this document also supported explicitly defined prime and char2 curves, but these are deprecated by this specification.",
      "ja": "このドキュメントの前任者も、明示的に定義されたプライムとCHAR2曲線をサポートしますが、これらはこの仕様で推奨されていません。"
    },
    {
      "indent": 3,
      "text": "The NamedCurve name space (now titled \"TLS Supported Groups\") is maintained by IANA. See Section 9 for information on how new value assignments are added.",
      "ja": "（今「TLSサポートグループ」と題し）NamedCurve名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション9を参照してください。"
    },
    {
      "indent": 11,
      "text": "struct {\n    NamedCurve named_curve_list<2..2^16-1>\n} NamedCurveList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Items in named_curve_list are ordered according to the client's preferences (favorite choice first).",
      "ja": "named_curve_listのアイテムは、クライアントの好み（最初のお気に入りの選択）に従って順序付けされています。"
    },
    {
      "indent": 3,
      "text": "As an example, a client that only supports secp256r1 (aka NIST P-256; value 23 = 0x0017) and secp384r1 (aka NIST P-384; value 24 = 0x0018) and prefers to use secp256r1 would include a TLS extension consisting of the following octets. Note that the first two octets indicate the extension type (Supported Elliptic Curves Extension):",
      "ja": "例としてのみsecp256r1をサポートし、クライアント（別名NIST P-256;値23 = 0x0017）とsecp384r1（別名NIST P-384;値24 = 0x0018）とsecp256r1を使用することを好むは、次からなるTLS拡張子を含むであろうオクテット。最初の2つのオクテットは、拡張タイプ（サポートされている楕円曲線の延長）を示していることに注意してください："
    },
    {
      "indent": 11,
      "text": "00 0A 00 06 00 04 00 17 00 18",
      "ja": "00 0A 00 06 00 04 00 17 00 18"
    },
    {
      "indent": 0,
      "text": "5.1.2. Supported Point Formats Extension",
      "section_title": true,
      "ja": "5.1.2。サポートされている小数点形式拡張子"
    },
    {
      "indent": 11,
      "text": "enum {\n    uncompressed (0),\n    deprecated (1..2),\n    reserved (248..255)\n} ECPointFormat;\nstruct {\n    ECPointFormat ec_point_format_list<1..2^8-1>\n} ECPointFormatList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Three point formats were included in the definition of ECPointFormat above. This specification deprecates all but the uncompressed point format. Implementations of this document MUST support the uncompressed format for all of their supported curves and MUST NOT support other formats for curves defined in this specification. For backwards compatibility purposes, the point format list extension MAY still be included and contain exactly one value: the uncompressed point format (0). RFC 4492 specified that if this extension is missing, it means that only the uncompressed point format is supported, so interoperability with implementations that support the uncompressed format should work with or without the extension.",
      "ja": "スリーポイント・フォーマットは、上記のECPointFormatの定義に含まれていました。この仕様は、非圧縮小数点形式以外のすべてを非難します。このドキュメントの実装は、彼らのサポートの曲線のすべてのための非圧縮形式をサポートしなければならないし、この仕様で定義された曲線のために他のフォーマットをサポートしてはなりません。下位互換性のために、ポイント形式のリストの拡張子は、まだ含まれており、1つの値を含むことができる：非圧縮小数点フォーマット（0）。 RFC 4492は、この拡張機能が欠落している場合、それが唯一の非圧縮小数点形式がサポートされていることを意味し、そうでまたは拡張子なしで動作するはず非圧縮形式をサポートする実装との相互運用性と規定しました。"
    },
    {
      "indent": 3,
      "text": "If the client sends the extension and the extension does not contain the uncompressed point format, and the client has used the Supported Groups extension to indicate support for any of the curves defined in this specification, then the server MUST abort the handshake and return an illegal_parameter alert.",
      "ja": "クライアントが拡張子を送信し、拡張子が圧縮されていない小数点形式が含まれていない、そしてクライアントがこの仕様で定義された曲線のいずれかのサポートを示すために、サポートされているグループの拡張機能を使用している場合、サーバーは握手を中止しillegal_parameterを返さなければなりません警戒。"
    },
    {
      "indent": 3,
      "text": "The ECPointFormat name space (now titled \"TLS EC Point Formats\") is maintained by IANA. See Section 9 for information on how new value assignments are added.",
      "ja": "（今「TLS EC小数点形式」と題し）ECPointFormat名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "A client compliant with this specification that supports no other curves MUST send the following octets; note that the first two octets indicate the extension type (Supported Point Formats Extension):",
      "ja": "他の曲線をサポートしていないこの仕様に準拠したクライアントは、次のオクテットを送らなければなりません。最初の2つのオクテットが（小数点形式拡張をサポート）拡張タイプを示していることに注意してください："
    },
    {
      "indent": 11,
      "text": "00 0B 00 02 01 00",
      "ja": "00 0B 00 02 01 00"
    },
    {
      "indent": 0,
      "text": "5.1.3. The signature_algorithms Extension and EdDSA",
      "section_title": true,
      "ja": "5.1.3。 signature_algorithms拡張とエドワーズ曲線デジタル署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The signature_algorithms extension, defined in Section 7.4.1.4.1 of [RFC5246], advertises the combinations of signature algorithm and hash function that the client supports. The pure (non-prehashed) forms of EdDSA do not hash the data before signing it. For this reason, it does not make sense to combine them with a hash function in the extension.",
      "ja": "[RFC5246]のセクション7.4.1.4.1に規定されsignature_algorithms拡張は、クライアントがサポートする署名アルゴリズムおよびハッシュ関数の組み合わせをアドバタイズ。エドワーズ曲線デジタル署名アルゴリズムの（非prehashed）純粋な形態は、それに署名する前にデータをハッシュしません。このため、拡張におけるハッシュ関数とそれらを結合しても意味がありません。"
    },
    {
      "indent": 3,
      "text": "For bits-on-the-wire compatibility with TLS 1.3, we define a new dummy value in the \"TLS HashAlgorithm\" registry that we call \"Intrinsic\" (value 8), meaning that hashing is intrinsic to the signature algorithm.",
      "ja": "TLS 1.3ビット・オン・ザ・ワイヤの互換性のために、我々は、ハッシュが署名アルゴリズムに固有であることを意味し、我々は「組み込み」（値8）を呼び出し、「TLS HashAlgorithm」レジストリに新たなダミー値を定義します。"
    },
    {
      "indent": 3,
      "text": "To represent ed25519 and ed448 in the signature_algorithms extension, the value shall be (8,7) and (8,8), respectively.",
      "ja": "signature_algorithms拡張でed25519とed448を表すために、値は、それぞれ（8,7）及び（8,8）でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Server Hello Extension",
      "section_title": true,
      "ja": "5.2。サーバーこんにちは拡張"
    },
    {
      "indent": 3,
      "text": "This section specifies a TLS extension that can be included with the ServerHello message as described in [RFC4366], the Supported Point Formats Extension.",
      "ja": "このセクションでは、[RFC4366]に記載のサポートポイントフォーマットの拡張としてServerHelloメッセージに含めることができるTLS拡張子を指定します。"
    },
    {
      "indent": 3,
      "text": "When this extension is sent:",
      "ja": "この拡張機能は、送信された場合："
    },
    {
      "indent": 3,
      "text": "The Supported Point Formats Extension is included in a ServerHello message in response to a ClientHello message containing the Supported Point Formats Extension when negotiating an ECC cipher suite.",
      "ja": "ECC暗号スイートをネゴシエートするときにサポートされているポイントフォーマット拡張がサポートされているポイントフォーマットの拡張を含むClientHelloメッセージに応答して、ServerHelloメッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "Meaning of this extension:",
      "ja": "この拡張機能の意味："
    },
    {
      "indent": 3,
      "text": "This extension allows a server to enumerate the point formats it can parse (for the curve that will appear in its ServerKeyExchange message when using the ECDHE_ECDSA, ECDHE_RSA, or ECDH_anon key exchange algorithm.",
      "ja": "この拡張は、サーバがECDHE_ECDSA、ECDHE_RSA、又はECDH_anon鍵交換アルゴリズムを使用する場合、そのServerKeyExchangeメッセージに表示された曲線のために（解析できる点フォーマットを列挙することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Structure of this extension:",
      "ja": "この拡張機能の構造："
    },
    {
      "indent": 3,
      "text": "The server's Supported Point Formats Extension has the same structure as the client's Supported Point Formats Extension (see Section 5.1.2). Items in ec_point_format_list here are ordered according to the server's preference (favorite choice first). Note that the server MAY include items that were not found in the client's list. However, without extensions, this specification allows exactly one point format, so there is not really any opportunity for mismatches.",
      "ja": "サーバーのサポートされている小数点形式拡張子は、クライアントのサポートされている小数点形式拡張（5.1.2項を参照）と同様の構造を有しています。ここec_point_format_listの項目は、サーバーの好み（最初のお気に入りの選択）に従って順序付けされています。サーバーがクライアントのリストには検出されなかった項目を含んでもよいことに注意してください。しかし、拡張せずに、この仕様は、1つの小数点フォーマットを可能にするので、不整合のためのあらゆる機会は本当にありません。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "A server that selects an ECC cipher suite in response to a ClientHello message including a Supported Point Formats Extension appends this extension (along with others) to its ServerHello message, enumerating the point formats it can parse. The Supported Point Formats Extension, when used, MUST contain the value 0 (uncompressed) as one of the items in the list of point formats.",
      "ja": "サポートされているポイントフォーマット拡張子を含むClientHelloメッセージに応答して、ECC暗号スイートを選択し、サーバが解析できる点フォーマットを列挙し、そのServerHelloメッセージに（他の人と一緒に）この拡張機能を追加します。サポートされているポイントフォーマットの拡張は、使用される場合、小数点形式のリスト内の項目の一つとして値0（非圧縮）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "A client that receives a ServerHello message containing a Supported Point Formats Extension MUST respect the server's choice of point formats during the handshake (cf. Sections 5.6 and 5.7). If no Supported Point Formats Extension is received with the ServerHello, this is equivalent to an extension allowing only the uncompressed point format.",
      "ja": "サポートされている小数点形式拡張子を含むServerHelloメッセージを受信したクライアントは、ハンドシェイク（参照：セクション5.6および5.7）の間に小数点フォーマットのサーバの選択を尊重しなければなりません。何もサポートされている小数点形式拡張子がのServerHelloで受信されない場合、これが唯一の非圧縮小数点形式を許可する拡張機能と同等です。"
    },
    {
      "indent": 0,
      "text": "5.3. Server Certificate",
      "section_title": true,
      "ja": "5.3。サーバー証明書"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in all non-anonymous, ECC-based key exchange algorithms.",
      "ja": "このメッセージは、すべての非匿名の、ECCベースの鍵交換アルゴリズムに送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to authentically convey the server's static public key to the client. The following table shows the server certificate type appropriate for each key exchange algorithm. ECC public keys MUST be encoded in certificates as described in Section 5.9.",
      "ja": "このメッセージは、本物のクライアントに対するサーバの静的な公開鍵を伝えるために使用されます。次の表は、各鍵交換アルゴリズムに適したサーバ証明書の種類を示します。 5.9節で説明したようにECC公開鍵は、証明書にエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The server's Certificate message is capable of carrying a chain of certificates. The restrictions mentioned in Table 2 apply only to the server's certificate (first in the chain).",
      "ja": "注：サーバーの証明書のメッセージが証明書のチェーンを搬送することができます。表2に記載された制限は、（最初​​の鎖に）のみ、サーバーの証明書に適用されます。"
    },
    {
      "indent": 3,
      "text": "+-------------+-----------------------------------------------------+\n| Algorithm   | Server Certificate Type                             |\n+-------------+-----------------------------------------------------+\n| ECDHE_ECDSA | Certificate MUST contain an ECDSA- or EdDSA-capable |\n|             | public key.                                         |\n| ECDHE_RSA   | Certificate MUST contain an RSA public key.         |\n+-------------+-----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 2: Server Certificate Types",
      "ja": "表2：サーバー証明書の種類"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "Identical to the TLS Certificate format.",
      "ja": "TLS証明書の形式と同じ。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server constructs an appropriate certificate chain and conveys it to the client in the Certificate message. If the client has used a Supported Elliptic Curves Extension, the public key in the server's certificate MUST respect the client's choice of elliptic curves. A server that cannot satisfy this requirement MUST NOT choose an ECC cipher suite in its ServerHello message.)",
      "ja": "サーバーは、適切な証明書チェーンを構築し、Certificateメッセージでクライアントにそれを伝えます。クライアントがサポートされている楕円曲線の拡張を使用している場合は、サーバーの証明書の公開鍵は、楕円曲線のクライアントの選択を尊重しなければなりません。この要件を満たすことができないサーバーは、そのServerHelloメッセージでECC暗号スイートを選択してはなりません。）"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client validates the certificate chain, extracts the server's public key, and checks that the key type is appropriate for the negotiated key exchange algorithm. (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded; cf. Section 5.1.)",
      "ja": "クライアントは、証明書チェーンを検証し、サーバーの公開鍵を抽出し、キータイプが交渉の鍵交換アルゴリズムに適切であることを確認します。 （致命的なハンドシェイク失敗の可能な理由は、楕円曲線とポイント形式を処理するためのクライアントの能力を超えているということであり、節参照5.1。）"
    },
    {
      "indent": 0,
      "text": "5.4. Server Key Exchange",
      "section_title": true,
      "ja": "5.4。サーバーの鍵交換"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when using the ECDHE_ECDSA, ECDHE_RSA, and ECDH_anon key exchange algorithms.",
      "ja": "ECDHE_ECDSA、ECDHE_RSA、及びECDH_anon鍵交換アルゴリズムを使用する場合、このメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to convey the server's ephemeral ECDH public key (and the corresponding elliptic curve domain parameters) to the client.",
      "ja": "このメッセージは、クライアントに対するサーバのはかないECDH公開鍵（および対応する楕円曲線ドメインパラメータを）伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "The ECCurveType enum used to have values for explicit prime and for explicit char2 curves. Those values are now deprecated, so only one value remains:",
      "ja": "ECCurveType列挙型は、明示的なプライム用と明示的CHAR2曲線の値を持っていました。一つの値だけが残っているので、これらの値は、現在、非推奨されています。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 11,
      "text": "enum {\n    deprecated (1..2),\n    named_curve (3),\n    reserved(248..255)\n} ECCurveType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value named_curve indicates that a named curve is used. This option is now the only remaining format.",
      "ja": "値named_curveは、名前の曲線が使用されることを示しています。このオプションは、今だけで、残りのフォーマットです。"
    },
    {
      "indent": 3,
      "text": "Values 248 through 255 are reserved for private use.",
      "ja": "255までの値248は、私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The ECCurveType name space (now titled \"TLS EC Curve Types\") is maintained by IANA. See Section 9 for information on how new value assignments are added.",
      "ja": "（今「TLS ECカーブタイプ」というタイトル）ECCurveType名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "RFC 4492 had a specification for an ECCurve structure and an ECBasisType structure. Both of these are omitted now because they were only used with the now deprecated explicit curves.",
      "ja": "RFC 4492は、ECCurve構造とECBasisType構造の仕様を持っていました。彼らは唯一の廃止、明示的な曲線で使用されたため、これらの両方が、今は省略されています。"
    },
    {
      "indent": 11,
      "text": "struct {\n    opaque point <1..2^8-1>;\n} ECPoint;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "point: This is the byte string representation of an elliptic curve point following the conversion routine in Section 4.3.6 of [ANSI.X9-62.2005]. This byte string may represent an elliptic curve point in uncompressed, compressed, or hybrid format, but this specification deprecates all but the uncompressed format. For the NIST curves, the format is repeated in Section 5.4.1 for convenience. For the X25519 and X448 curves, the only valid representation is the one specified in [RFC7748], a 32- or 56-octet representation of the u value of the point. This structure MUST NOT be used with Ed25519 and Ed448 public keys.",
      "ja": "点：これは、[ANSI.X9-62.2005]のセクション4.3.6に変換ルーチン次の楕円曲線点のバイトの文字列表現です。このバイト列は、圧縮、非圧縮、またはハイブリッド形式で、楕円曲線の点を表すことができるが、この明細書は、非圧縮形式以外のすべてを非難します。 NIST曲線の場合、フォーマットは便宜上、セクション5.4.1で繰り返されます。 X25519およびX448曲線のために、唯一の有効な表現は、[RFC7748]で指定され、点のU値の32ビットまたは56オクテットです。この構造はEd25519とEd448公開鍵を使用してはいけません。"
    },
    {
      "indent": 11,
      "text": "struct {\n    ECCurveType    curve_type;\n    select (curve_type) {\n        case named_curve:\n            NamedCurve namedcurve;\n    };\n} ECParameters;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "curve_type: This identifies the type of the elliptic curve domain parameters.",
      "ja": "curve_type：これは、楕円曲線ドメインパラメータのタイプを識別する。"
    },
    {
      "indent": 3,
      "text": "namedCurve: Specifies a recommended set of elliptic curve domain parameters. All those values of NamedCurve are allowed that refer to a curve capable of Diffie-Hellman. With the deprecation of the explicit curves, this now includes all of the NamedCurve values.",
      "ja": "namedCurve：楕円曲線ドメインパラメータの推奨セットを指定します。 NamedCurveのすべてのこれらの値は、ディフィー - ヘルマンの可能な曲線を参照することを許可されています。明示的な曲線の廃止で、これは今NamedCurve値のすべてを含んでいます。"
    },
    {
      "indent": 11,
      "text": "struct {\n    ECParameters    curve_params;\n    ECPoint         public;\n} ServerECDHParams;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "curve_params: Specifies the elliptic curve domain parameters associated with the ECDH public key.",
      "ja": "curve_params：ECDH公開鍵に関連付けられた楕円曲線ドメインパラメータを指定します。"
    },
    {
      "indent": 3,
      "text": "public: The ephemeral ECDH public key.",
      "ja": "公共：はかないECDH公開鍵。"
    },
    {
      "indent": 3,
      "text": "The ServerKeyExchange message is extended as follows.",
      "ja": "次のようにServerKeyExchangeメッセージが拡張されます。"
    },
    {
      "indent": 11,
      "text": "enum {\n    ec_diffie_hellman\n} KeyExchangeAlgorithm;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o ec_diffie_hellman: Indicates the ServerKeyExchange message contains an ECDH public key.",
      "ja": "O ec_diffie_hellman：ServerKeyExchangeメッセージがECDH公開鍵が含まれていることを示します。"
    },
    {
      "indent": 6,
      "text": "select (KeyExchangeAlgorithm) {\n    case ec_diffie_hellman:\n        ServerECDHParams    params;\n        Signature           signed_params;\n} ServerKeyExchange;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o params: Specifies the ECDH public key and associated domain parameters.",
      "ja": "Oのparams：ECDH公開鍵と関連したドメインパラメータを指定します。"
    },
    {
      "indent": 3,
      "text": "o signed_params: A hash of the params, with the signature appropriate to that hash applied. The private key corresponding to the certified public key in the server's Certificate message is used for signing.",
      "ja": "signed_pa​​rams O：そのハッシュに適切な署名付きのparamsのハッシュは、適用しました。サーバーの証明書メッセージに認定された公開鍵に対応する秘密鍵は、署名に使用されます。"
    },
    {
      "indent": 6,
      "text": "  enum {\n      ecdsa(3),\n      ed25519(7)\n      ed448(8)\n  } SignatureAlgorithm;\n  select (SignatureAlgorithm) {\n     case ecdsa:\n          digitally-signed struct {\n              opaque sha_hash[sha_size];\n          };\n     case ed25519,ed448:\n          digitally-signed struct {\n              opaque rawdata[rawdata_size];\n          };\n  } Signature;\nServerKeyExchange.signed_params.sha_hash\n    SHA(ClientHello.random + ServerHello.random +\n                           ServerKeyExchange.params);\nServerKeyExchange.signed_params.rawdata\n    ClientHello.random + ServerHello.random +\n                           ServerKeyExchange.params;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NOTE: SignatureAlgorithm is \"rsa\" for the ECDHE_RSA key exchange algorithm and \"anonymous\" for ECDH_anon. These cases are defined in TLS. SignatureAlgorithm is \"ecdsa\" or \"eddsa\" for ECDHE_ECDSA.",
      "ja": "注：のsignatureAlgorithmはECDHE_RSA鍵交換アルゴリズムのための「RSA」とECDH_anonのための「匿名」です。これらの例は、TLSで定義されています。 signatureAlgorithmは「ECDSA」またはECDHE_ECDSAための「エドワーズ曲線デジタル署名アルゴリズム」です。"
    },
    {
      "indent": 3,
      "text": "ECDSA signatures are generated and verified as described in Section 5.10. SHA, in the above template for sha_hash, may denote a hash algorithm other than SHA-1. As per ANSI X9.62, an ECDSA signature consists of a pair of integers, r and s. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which are the DER encoding corresponding to the following ASN.1 notation.",
      "ja": "セクション5.10に記載されているようにECDSA署名が生成され、検証されます。 SHAは、sha_hashための上記テンプレートに、SHA-1以外のハッシュアルゴリズムを示すことができます。 ANSI X9.62に従って、ECDSA署名は整数、rおよびsの対から成ります。デジタル署名された要素は、内容は、以下のASN.1表記に対応するDER符号化され、不透明なベクトル<^ 16-1 0..2>としてコード化されます。"
    },
    {
      "indent": 14,
      "text": "Ecdsa-Sig-Value ::= SEQUENCE {\n    r       INTEGER,\n    s       INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "EdDSA signatures in both the protocol and in certificates that conform to [RFC8410] are generated and verified according to [RFC8032]. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which include the octet string output of the EdDSA signing algorithm.",
      "ja": "両方のプロトコルおよび[RFC8410]に準拠した証明書でエドワーズ曲線デジタル署名アルゴリズム署名は[RFC8032]に従って生成し、検証します。デジタル署名された要素は不透明なベクトル<^ 16-1 0..2>としてコード化され、その内容はエドワーズ曲線デジタル署名アルゴリズム署名アルゴリズムのオクテットストリングの出力を含みます。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server selects elliptic curve domain parameters and an ephemeral ECDH public key corresponding to these parameters according to the ECKAS-DH1 scheme from IEEE 1363 [IEEE.P1363]. It conveys this information to the client in the ServerKeyExchange message using the format defined above.",
      "ja": "サーバーは楕円曲線ドメインパラメータ及びIEEE 1363 [IEEE.P1363]からECKAS-DH1方式に従って、これらのパラメータに対応するはかないECDH公開鍵を選択します。これは、上記で定義されたフォーマットを使用して、ServerKeyExchangeメッセージでクライアントにこの情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client verifies the signature (when present) and retrieves the server's elliptic curve domain parameters and ephemeral ECDH public key from the ServerKeyExchange message. (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded; cf. Section 5.1.)",
      "ja": "クライアントは、署名を検証する（存在する場合）、サーバーの楕円曲線ドメインパラメータとServerKeyExchangeメッセージからはかないECDH公開鍵を取り出します。 （致命的なハンドシェイク失敗の可能な理由は、楕円曲線とポイント形式を処理するためのクライアントの能力を超えているということであり、節参照5.1。）"
    },
    {
      "indent": 0,
      "text": "5.4.1. Uncompressed Point Format for NIST Curves",
      "section_title": true,
      "ja": "5.4.1。 NIST曲線のための非圧縮小数点フォーマット"
    },
    {
      "indent": 3,
      "text": "The following represents the wire format for representing ECPoint in ServerKeyExchange records. The first octet of the representation indicates the form, which may be compressed, uncompressed, or hybrid. This specification supports only the uncompressed format for these curves. This is followed by the binary representation of the X value in \"big-endian\" or \"network\" format, followed by the binary representation of the Y value in \"big-endian\" or \"network\" format. There are no internal length markers, so each number representation occupies as many octets as implied by the curve parameters. For",
      "ja": "以下はServerKeyExchangeレコードにECPointを表すためのワイヤフォーマットを表します。表現の最初のオクテットは、圧縮されていない、またはハイブリッドを圧縮することができるフォームを示しています。この仕様は、これらの曲線のための唯一の非圧縮形式をサポートしています。これは、「ビッグエンディアン」または「ネットワーク」形式におけるY値の二進表現が続く「ビッグエンディアン」または「ネットワーク」形式のX値のバイナリ表現が続きます。そこには、内部長さマーカーはないので、曲線パラメータによって暗示されるよう各数値表現は、多くのオクテットを占有します。ために"
    },
    {
      "indent": 3,
      "text": "P-256 this means that each of X and Y use 32 octets, padded on the left by zeros if necessary. For P-384, they take 48 octets each, and for P-521, they take 66 octets each.",
      "ja": "P-256これはX及びYのそれぞれは、32オクテットを使用することを意味し、必要であればゼロが左側に埋め込ま。 P-384のために、彼らは48オクテットそれぞれを取り、P-521のために、彼らは66オクテットそれぞれを取ります。"
    },
    {
      "indent": 3,
      "text": "Here's a more formal representation:",
      "ja": "ここでは、よりフォーマルな表現があります："
    },
    {
      "indent": 13,
      "text": "enum {\n    uncompressed(4),\n    (255)\n  } PointConversionForm;",
      "raw": true
    },
    {
      "indent": 13,
      "text": "struct {\n    PointConversionForm  form;\n    opaque               X[coordinate_length];\n    opaque               Y[coordinate_length];\n} UncompressedPointRepresentation;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5. Certificate Request",
      "section_title": true,
      "ja": "5.5。証明書要求"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when requesting client authentication.",
      "ja": "クライアント認証を要求するときにこのメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "The server uses this message to suggest acceptable client authentication methods.",
      "ja": "サーバは、許容可能なクライアント認証方法を提案するために、このメッセージを使用しています。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS CertificateRequest message is extended as follows.",
      "ja": "次のようにTLS CertificateRequestメッセージが拡張されます。"
    },
    {
      "indent": 11,
      "text": "enum {\n    ecdsa_sign(64),\n    deprecated1(65),  /* was rsa_fixed_ecdh */\n    deprecated2(66),  /* was ecdsa_fixed_ecdh */\n    (255)\n} ClientCertificateType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o ecdsa_sign: Indicates that the server would like to use the corresponding client authentication method specified in Section 3.",
      "ja": "ecdsa_sign O：サーバはセクション3で指定された対応するクライアント認証方法を使用したいことを示します。"
    },
    {
      "indent": 3,
      "text": "Note that RFC 4492 also defined RSA and ECDSA certificates that included a fixed ECDH public key. These mechanisms saw very little implementation, so this specification is deprecating them.",
      "ja": "固定ECDH公開鍵が含まれているRFC 4492のにも規定されRSAおよびECDSA証明書を注意してください。これらのメカニズムは非常に少ないの実装を見たので、この仕様では、それらを卑下されます。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server decides which client authentication methods it would like to use and conveys this information to the client using the format defined above.",
      "ja": "サーバーは、それが使用したいどのクライアントの認証方法を決定し、上記で定義されたフォーマットを使用してクライアントにこの情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client determines whether it has a suitable certificate for use with any of the requested methods and whether to proceed with client authentication.",
      "ja": "クライアントは、要求のいずれかの方法で、クライアント認証を続行するかどうかの使用に適した証明書を持っているかどうかを決定します。"
    },
    {
      "indent": 0,
      "text": "5.6. Client Certificate",
      "section_title": true,
      "ja": "5.6。クライアント証明書"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in response to a CertificateRequest when a client has a suitable certificate and has decided to proceed with client authentication. (Note that if the server has used a Supported Point Formats Extension, a certificate can only be considered suitable for use with the ECDSA_sign authentication method if the public key point specified in it is uncompressed, as that is the only point format still supported.",
      "ja": "このメッセージは、クライアントが、適切な証明書を持っており、クライアント認証を続行することを決定しましたCertificateRequestに応じて送信されます。それはまだサポートされている唯一の小数点形式であるとして、それに指定された公開キーポイントは、圧縮されていない場合（サーバがサポートされている小数点形式拡張子を使用している場合があります、証明書はECDSA_sign認証方法での使用に適し考えることができます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to authentically convey the client's static public key to the server. ECC public keys must be encoded in certificates as described in Section 5.9. The certificate MUST contain an ECDSA- or EdDSA-capable public key.",
      "ja": "このメッセージは、本物のサーバーへのクライアントの静的な公開鍵を伝えるために使用されます。 5.9節で説明したようにECC公開鍵は、証明書にエンコードする必要があります。証明書は、ECDSA-またはエドワーズ曲線デジタル署名アルゴリズム可能な公開鍵を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTE: The client's Certificate message is capable of carrying a chain of certificates. The restrictions mentioned above apply only to the client's certificate (first in the chain).",
      "ja": "注：クライアントの証明書のメッセージが証明書のチェーンを搬送することができます。上記の制限はのみ（最初の鎖で）クライアントの証明書に適用されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "Identical to the TLS client Certificate format.",
      "ja": "TLSクライアント証明書の形式と同じ。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client constructs an appropriate certificate chain and conveys it to the server in the Certificate message.",
      "ja": "クライアントは、適切な証明書チェーンを構築し、Certificateメッセージ内のサーバーにそれを伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The TLS server validates the certificate chain, extracts the client's public key, and checks that the key type is appropriate for the client authentication method.",
      "ja": "TLSサーバは、証明書チェーンを検証し、クライアントの公開鍵を抽出し、キータイプは、クライアント認証方法に適していることを確認します。"
    },
    {
      "indent": 0,
      "text": "5.7. Client Key Exchange",
      "section_title": true,
      "ja": "5.7。クライアント鍵交換"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in all key exchange algorithms. It contains the client's ephemeral ECDH public key.",
      "ja": "このメッセージは、すべての鍵交換アルゴリズムに送信されます。これは、クライアントのはかないECDH公開鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "Meaning of the message:",
      "ja": "メッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to convey ephemeral data relating to the key exchange belonging to the client (such as its ephemeral ECDH public key).",
      "ja": "このメッセージは、（そのはかないECDH公開鍵として）クライアントに属する鍵交換に関連する一時的なデータを伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS ClientKeyExchange message is extended as follows.",
      "ja": "次のようにTLS ClientKeyExchangeメッセージが拡張されます。"
    },
    {
      "indent": 11,
      "text": "enum {\n    implicit,\n    explicit\n} PublicValueEncoding;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o implicit, explicit: For ECC cipher suites, this indicates whether the client's ECDH public key is in the client's certificate (\"implicit\") or is provided, as an ephemeral ECDH public key, in the ClientKeyExchange message (\"explicit\"). The implicit encoding is deprecated and is retained here for backward compatibility only.",
      "ja": "O暗黙的、明示的：ECC暗号スイートの場合、これはクライアントのECDH公開鍵が（「暗黙の」）、クライアントの証明書であるか、ClientKeyExchangeメッセージ（「明示的」）に、はかないECDH公開鍵として、提供されているかどうかを示します。暗黙のエンコーディングは廃止され、下位互換性のためにのみ、ここで保持されます。"
    },
    {
      "indent": 11,
      "text": "struct {\n    ECPoint ecdh_Yc;\n} ClientECDiffieHellmanPublic;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ecdh_Yc: Contains the client's ephemeral ECDH public key as a byte string ECPoint.point, which may represent an elliptic curve point in uncompressed format.",
      "ja": "ecdh_Ycは：非圧縮形式で、楕円曲線上の点を表すことができるバイトの文字列ECPoint.point、などクライアントのはかないECDH公開鍵が含まれています。"
    },
    {
      "indent": 11,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case ec_diffie_hellman: ClientECDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client selects an ephemeral ECDH public key corresponding to the parameters it received from the server. The format is the same as in Section 5.4.",
      "ja": "クライアントは、サーバから受信したパラメータに対応するはかないECDH公開鍵を選択します。フォーマットは5.4節と同じです。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The server retrieves the client's ephemeral ECDH public key from the ClientKeyExchange message and checks that it is on the same elliptic curve as the server's ECDH key.",
      "ja": "サーバは、サーバのECDHキーと同じ楕円曲線上にあるClientKeyExchangeメッセージとチェックから、クライアントのはかないECDH公開鍵を取得します。"
    },
    {
      "indent": 0,
      "text": "5.8. Certificate Verify",
      "section_title": true,
      "ja": "5.8。証明書は、確認してください"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when the client sends a client certificate containing a public key usable for digital signatures.",
      "ja": "クライアントがデジタル署名のために使用可能な公開鍵を含むクライアント証明書を送信するときにこのメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of the message:",
      "ja": "メッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message contains a signature that proves possession of the private key corresponding to the public key in the client's Certificate message.",
      "ja": "このメッセージは、クライアントのCertificateメッセージ内の公開鍵に対応する秘密鍵の所有を証明する署名が含まれています。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS CertificateVerify message and the underlying signature type are defined in the TLS base specifications, and the latter is extended here in Section 5.4. For the \"ecdsa\" and \"eddsa\" cases, the signature field in the CertificateVerify message contains an ECDSA or EdDSA (respectively) signature computed over handshake messages exchanged so far, exactly similar to CertificateVerify with other signing algorithms:",
      "ja": "TLS CertificateVerifyメッセージとその下の署名タイプがTLSベースの仕様で定義され、そして後者は5.4ここで拡張されます。 「ECDSA」および「エドワーズ曲線デジタル署名アルゴリズム」の場合について、CertificateVerifyメッセージに署名フィールドは、ハンドシェイクメッセージにわたって計算ECDSA又はエドワーズ曲線デジタル署名アルゴリズム（それぞれ）署名が他の署名アルゴリズムとCertificateVerifyと全く同様に、これまでの交換含ま"
    },
    {
      "indent": 11,
      "text": "CertificateVerify.signature.sha_hash\n    SHA(handshake_messages);\nCertificateVerify.signature.rawdata\n    handshake_messages;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ECDSA signatures are computed as described in Section 5.10, and SHA in the above template for sha_hash accordingly may denote a hash algorithm other than SHA-1. As per ANSI X9.62, an ECDSA signature consists of a pair of integers, r and s. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which are the DER encoding [X.690] corresponding to the following ASN.1 notation [X.680].",
      "ja": "SHA-1以外のハッシュアルゴリズムを表してもよい従ってsha_hashための上記テンプレートのセクション5.10に記載され、そしてSHAとしてECDSA署名が計算されます。 ANSI X9.62に従って、ECDSA署名は整数、rおよびsの対から成ります。デジタル署名された要素は、[X.690]以下ASN.1表記[X.680]に対応するDER符号化された内容は、不透明なベクトル<^ 16-1 0..2>としてコード化されます。"
    },
    {
      "indent": 11,
      "text": "Ecdsa-Sig-Value ::= SEQUENCE {\n    r       INTEGER,\n    s       INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "EdDSA signatures are generated and verified according to [RFC8032]. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which include the octet string output of the EdDSA signing algorithm.",
      "ja": "エドワーズ曲線デジタル署名アルゴリズム署名は[RFC8032]に従って生成し、検証します。デジタル署名された要素は不透明なベクトル<^ 16-1 0..2>としてコード化され、その内容はエドワーズ曲線デジタル署名アルゴリズム署名アルゴリズムのオクテットストリングの出力を含みます。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client computes its signature over all handshake messages sent or received starting at client hello and up to but not including this message. It uses the private key corresponding to its certified public key to compute the signature, which is conveyed in the format defined above.",
      "ja": "クライアントは、クライアントハローとまでが、このメッセージを含まないから始まる送信または受信したすべてのハンドシェイクメッセージの上にその署名を計算します。これは、上記で定義された形式で搬送される署名を計算するための証明される公開鍵に対応する秘密鍵を使用します。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The server extracts the client's signature from the CertificateVerify message and verifies the signature using the public key it received in the client's Certificate message.",
      "ja": "サーバはCertificateVerifyメッセージからクライアントの署名を抽出し、それは、クライアントの証明書メッセージで受信した公開鍵を使って署名を検証します。"
    },
    {
      "indent": 0,
      "text": "5.9. Elliptic Curve Certificates",
      "section_title": true,
      "ja": "5.9。楕円曲線証明書"
    },
    {
      "indent": 3,
      "text": "X.509 certificates containing ECC public keys or signed using ECDSA MUST comply with [RFC3279] or another RFC that replaces or extends it. X.509 certificates containing ECC public keys or signed using EdDSA MUST comply with [RFC8410]. Clients SHOULD use the elliptic curve domain parameters recommended in ANSI X9.62, FIPS 186-4, and SEC 2 [SECG-SEC2], or in [RFC8032].",
      "ja": "ECDSAを使用してECC公開鍵を含むか、署名されたX.509証明書は、[RFC3279]、または置き換え、またはそれを拡張する他のRFCに準拠しなければなりません。 ECC公開鍵を含むか、[RFC8410]に従わなければならないエドワーズ曲線デジタル署名アルゴリズムを使用して署名されたX.509証明書。クライアントは、ANSI X9.62で推奨楕円曲線ドメインパラメータを使用する186から4をFIPS、およびSEC 2 [SECG-SEC2]、または[RFC8032]にすべきです。"
    },
    {
      "indent": 3,
      "text": "EdDSA keys using the Ed25519 algorithm MUST use the ed25519 signature algorithm, and Ed448 keys MUST use the ed448 signature algorithm. This document does not define use of Ed25519ph and Ed448ph keys with TLS. Ed25519, Ed25519ph, Ed448, and Ed448ph keys MUST NOT be used with ECDSA.",
      "ja": "Ed25519アルゴリズムを用いエドワーズ曲線デジタル署名アルゴリズムのキーがed25519署名アルゴリズムを使用しなければならない、とEd448キーがed448署名アルゴリズムを使用しなければなりません。この文書では、TLSでEd25519phとEd448phキーの使用を定義していません。 Ed25519、Ed25519ph、Ed448、およびEd448phキーECDSAを使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.10. ECDH, ECDSA, and RSA Computations",
      "section_title": true,
      "ja": "5.10。 ECDH、ECDSA、およびRSA計算"
    },
    {
      "indent": 3,
      "text": "All ECDH calculations for the NIST curves (including parameter and key generation as well as the shared secret calculation) are performed according to [IEEE.P1363] using the ECKAS-DH1 scheme with the identity map as the Key Derivation Function (KDF) so that the premaster secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string. Note that this octet string (Z in IEEE 1363 terminology), as output by FE2OSP (Field",
      "ja": "（パラメータと鍵生成、ならびに共有秘密計算を含む）NIST曲線のためのすべてのECDH計算は[IEEE.P1363】ように鍵導出関数（KDF）として識別マップとECKAS-DH1方式を使用に従って行われます前マスター秘密は、オクテットストリングとして表さ秘密楕円曲線点を共有ECDHのx座標です。なおFE2OSPによる出力として、このオクテットストリング（IEEE 1363用語でZ）、（フィールド"
    },
    {
      "indent": 3,
      "text": "Element to Octet String Conversion Primitive), has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.",
      "ja": "オクテットストリングへの変換素子プリミティブ）は、任意の所与のフィールドのための一定の長さを有しています。このオクテット文字列で見つかった先行ゼロは切り捨ててはなりません。"
    },
    {
      "indent": 3,
      "text": "(Note that this use of the identity KDF is a technicality. The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use the premaster secret for anything other than for computing the master secret. In TLS 1.0 and 1.1, this means that the MD5- and SHA-1-based TLS Pseudorandom Function (PRF) serves as a KDF; in TLS 1.2, the KDF is determined by ciphersuite, and it is conceivable that future TLS versions or new TLS extensions introduced in the future may vary this computation.)",
      "ja": "（アイデンティティKDFのこの使用は、専門的であることに注意してください。完全な絵がTLSは直接マスターシークレットを計算するため以外の目的でプリマスターシークレットを使用していないので、ECDHは非自明なKDFで採用されていることである。TLS 1.0でと1.1、これはMD5-とSHA-1ベースのTLS擬似ランダム関数（PRF）はKDFとして機能することを意味し、TLS 1.2で、KDFは、暗号の組み合わせによって決定され、将来のTLSバージョンまたは新しいTLS拡張がで導入することが考えられます将来的には、この計算を変更することがあります。）"
    },
    {
      "indent": 3,
      "text": "An ECDHE key exchange using X25519 (curve x25519) goes as follows: (1) each party picks a secret key d uniformly at random and computes the corresponding public key x = X25519(d, G); (2) parties exchange their public keys and compute a shared secret as x_S = X25519(d, x_peer); and (3), if either party obtains all-zeroes x_S, it MUST abort the handshake (as required by definition of X25519 and X448). ECDHE for X448 works similarly, replacing X25519 with X448 and x25519 with x448. The derived shared secret is used directly as the premaster secret, which is always exactly 32 bytes when ECDHE with X25519 is used and 56 bytes when ECDHE with X448 is used.",
      "ja": "次のようにX25519（曲線x25519）を用いECDHE鍵交換が進む：（1）各当事者がランダムに一様dは秘密鍵をピックアップし、対応する公開鍵x = X25519（D、G）を算出します。 （2）当事者は、その公開鍵を交換し、x_S = X25519（D、x_peer）として共有秘密鍵を計算します。いずれかの当事者がすべてゼロのx_Sを取得した場合（X25519とX448の定義によって必要とされる）、および（3）、それは握手を中止しなければなりません。 X448用ECDHEは、x448とX448とx25519とX25519を置き換え、同様に動作します。誘導された共有秘密は、X448とECDHEを用いた場合、正確に常にX25519とECDHEが使用される32のバイトと56バイトで前マスター秘密として直接使用されます。"
    },
    {
      "indent": 3,
      "text": "All ECDSA computations MUST be performed according to ANSI X9.62 or its successors. Data to be signed/verified is hashed, and the result runs directly through the ECDSA algorithm with no additional hashing. A secure hash function such as SHA-256, SHA-384, or SHA-512 from [FIPS.180-4] MUST be used.",
      "ja": "全てECDSA計算は、ANSI X9.62またはその後継に従って実行されなければなりません。データは/署名されたハッシュされ検証され、その結果がない追加のハッシングとECDSAアルゴリズムによって直接実行されます。そのようなSHA-256、SHA-384、またはSHA-512 [FIPS.180-4]からなどのセキュアハッシュ関数を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "All EdDSA computations MUST be performed according to [RFC8032] or its successors. Data to be signed/verified is run through the EdDSA algorithm with no hashing (EdDSA will internally run the data through the \"prehash\" function PH). The context parameter for Ed448 MUST be set to the empty string.",
      "ja": "全てエドワーズ曲線デジタル署名アルゴリズムの計算は、[RFC8032]、またはその後継に従って実行されなければなりません。データ検証/署名することはありませんハッシングとエドワーズ曲線デジタル署名アルゴリズムのアルゴリズムを介して実行される（エドワーズ曲線デジタル署名アルゴリズムは内部で「prehash」機能PHを介してデータを実行します）。 Ed448のコンテキスト・パラメータが空の文字列に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "RFC 4492 anticipated the standardization of a mechanism for specifying the required hash function in the certificate, perhaps in the parameters field of the subjectPublicKeyInfo. Such standardization never took place, and as a result, SHA-1 is used in TLS 1.1 and earlier (except for EdDSA, which uses identity function). TLS 1.2 added a SignatureAndHashAlgorithm parameter to the DigitallySigned struct, thus allowing agility in choosing the signature hash. EdDSA signatures MUST have HashAlgorithm of 8 (Intrinsic).",
      "ja": "RFC 4492は、おそらくSubjectPublicKeyInfoでのパラメータフィールドに、証明書に必要なハッシュ関数を特定するためのメカニズムの標準化を期待しました。このような標準化は行われなかった、そしてその結果として、SHA-1は、TLS 1.1で使用され、それ以前（恒等関数を使用していますエドワーズ曲線デジタル署名アルゴリズムを除く）でした。 TLS 1.2は、このように、署名ハッシュを選択する際に俊敏性を可能にする、DigitallySigned構造体にSignatureAndHashAlgorithmパラメータを追加しました。エドワーズ曲線デジタル署名アルゴリズム署名は8のHashAlgorithm（内因性）を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "All RSA signatures must be generated and verified according to Section 7.2 of [RFC8017].",
      "ja": "すべてのRSA署名は、[RFC8017]のセクション7.2に従って生成され、検証されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.11. Public Key Validation",
      "section_title": true,
      "ja": "5.11。公開鍵の検証"
    },
    {
      "indent": 3,
      "text": "With the NIST curves, each party MUST validate the public key sent by its peer in the ClientKeyExchange and ServerKeyExchange messages. A receiving party MUST check that the x and y parameters from the peer's public value satisfy the curve equation, y^2 = x^3 + ax + b mod p. See Section 2.3 of [Menezes] for details. Failing to do so allows attackers to gain information about the private key to the point that they may recover the entire private key in a few requests if that key is not really ephemeral.",
      "ja": "NIST曲線では、各当事者は、ClientKeyExchangeとServerKeyExchangeメッセージにそのピアによって送信された公開鍵を検証する必要があります。受信側は、ピアの公開値からxおよびyパラメータは、曲線の方程式、y ^ 2 = X ^ 3 + AX + Bのmod pを満たすことを確認しなければなりません。詳細については、[メネゼス]のセクション2.3を参照してください。そうしないと、攻撃者はそのキーが本当に短命でない場合、彼らはいくつかの要求で全体の秘密鍵を回復することができるポイントに、秘密鍵の情報を得ることができます。"
    },
    {
      "indent": 3,
      "text": "With X25519 and X448, a receiving party MUST check whether the computed premaster secret is the all-zero value and abort the handshake if so, as described in Section 6 of [RFC7748].",
      "ja": "X25519およびX448と、受信側は、計算されたプリマスタ秘密は、すべてゼロの値であるかどうかをチェックしなければなりませんし、そうであれば、[RFC7748]のセクション6で説明したように、ハンドシェイクを中止します。"
    },
    {
      "indent": 3,
      "text": "Ed25519 and Ed448 internally do public key validation as part of signature verification.",
      "ja": "Ed25519とEd448は内部で署名検証の一環として、公開鍵検証を行います。"
    },
    {
      "indent": 0,
      "text": "6. Cipher Suites",
      "section_title": true,
      "ja": "6.暗号スイート"
    },
    {
      "indent": 3,
      "text": "The table below defines ECC cipher suites that use the key exchange algorithms specified in Section 2.",
      "ja": "以下の表は、セクション2で指定された鍵交換アルゴリズムを使用してECC暗号スイートを定義します。"
    },
    {
      "indent": 7,
      "text": "+-----------------------------------------+----------------+\n| CipherSuite                             | Identifier     |\n+-----------------------------------------+----------------+\n| TLS_ECDHE_ECDSA_WITH_NULL_SHA           | { 0xC0, 0x06 } |\n| TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   | { 0xC0, 0x08 } |\n| TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    | { 0xC0, 0x09 } |\n| TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    | { 0xC0, 0x0A } |\n| TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 | { 0xC0, 0x2B } |\n| TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 | { 0xC0, 0x2C } |\n|                                         |                |\n| TLS_ECDHE_RSA_WITH_NULL_SHA             | { 0xC0, 0x10 } |\n| TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x12 } |\n| TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      | { 0xC0, 0x13 } |\n| TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      | { 0xC0, 0x14 } |\n| TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   | { 0xC0, 0x2F } |\n| TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   | { 0xC0, 0x30 } |\n|                                         |                |\n| TLS_ECDH_anon_WITH_NULL_SHA             | { 0xC0, 0x15 } |\n| TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA     | { 0xC0, 0x17 } |\n| TLS_ECDH_anon_WITH_AES_128_CBC_SHA      | { 0xC0, 0x18 } |\n| TLS_ECDH_anon_WITH_AES_256_CBC_SHA      | { 0xC0, 0x19 } |\n+-----------------------------------------+----------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 3: TLS ECC Cipher Suites",
      "ja": "表3：TLS ECC暗号スイート"
    },
    {
      "indent": 3,
      "text": "The key exchange method, cipher, and hash algorithm for each of these cipher suites are easily determined by examining the name. Ciphers (other than AES ciphers) and hash algorithms are defined in [RFC2246] and [RFC4346]. AES ciphers are defined in [RFC5246], and AES-GCM ciphersuites are in [RFC5289].",
      "ja": "これらの暗号スイートのそれぞれの鍵交換方式、暗号、ハッシュアルゴリズムが簡単に名前を調べることによって決定されます。 （AES暗号以外）暗号やハッシュアルゴリズムは[RFC2246]と[RFC4346]で定義されています。 AES暗号は[RFC5246]で定義されており、AES-GCMの暗号スイートは、[RFC5289]です。"
    },
    {
      "indent": 3,
      "text": "Server implementations SHOULD support all of the following cipher suites, and client implementations SHOULD support at least one of them:",
      "ja": "サーバーの実装は、以下の暗号スイートのすべてをサポートする必要があり、クライアントの実装は、それらの少なくとも1つをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 0,
      "text": "7. Implementation Status",
      "section_title": true,
      "ja": "7.実施状況"
    },
    {
      "indent": 3,
      "text": "Both ECDHE and ECDSA with the NIST curves are widely implemented and supported in all major browsers and all widely used TLS libraries. ECDHE with Curve25519 is by now implemented in several browsers and several TLS libraries including OpenSSL. Curve448 and EdDSA have working interoperable implementations, but they are not yet as widely deployed.",
      "ja": "NIST曲線の両方ECDHEとECDSAは広く実装され、すべての主要なブラウザとすべての広く使われているTLSライブラリでサポートされています。 Curve25519とECDHEは現在、いくつかのブラウザとOpenSSLを含むいくつかのTLSライブラリで実装することです。 Curve448とエドワーズ曲線デジタル署名アルゴリズムは、相互運用可能な実装を働いてきたが、彼らはまだのように広く展開されていません。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ中で議論されています。"
    },
    {
      "indent": 3,
      "text": "For TLS handshakes using ECC cipher suites, the security considerations in Appendix D of each of the three TLS base documents apply accordingly.",
      "ja": "ECC暗号スイートを使用して、TLSハンドシェイクのために、3つのTLSベース文書の各付録Dにおけるセキュリティ上の考慮事項が適宜適用されます。"
    },
    {
      "indent": 3,
      "text": "Security discussions specific to ECC can be found in [IEEE.P1363] and [ANSI.X9-62.2005]. One important issue that implementers and users must consider is elliptic curve selection. Guidance on selecting an appropriate elliptic curve size is given in Table 1. Security considerations specific to X25519 and X448 are discussed in Section 7 of [RFC7748].",
      "ja": "ECCに固有のセキュリティに関する議論は[ANSI.X9-62.2005] [IEEE.P1363]で見つけることができます。実装者とユーザーが考慮しなければならない一つの重要な問題は、楕円曲線の選択です。適切な楕円曲線のサイズを選択するガイダンスはX25519およびX448に固有表1セキュリティ問題に与えられているが[RFC7748]のセクション7に記載されています。"
    },
    {
      "indent": 3,
      "text": "Beyond elliptic curve size, the main issue is elliptic curve structure. As a general principle, it is more conservative to use elliptic curves with as little algebraic structure as possible. Thus, random curves are more conservative than special curves such as Koblitz curves, and curves over F_p with p random are more conservative than curves over F_p with p of a special form, and curves over F_p with p random are considered more conservative than curves over F_2^m as there is no choice between multiple fields of similar size for characteristic 2.",
      "ja": "楕円曲線の大きさを超えて、主な問題は、楕円曲線構造です。一般原則として、できるだけ少ない代数構造を有する楕円曲線を使用するより保守的です。このように、ランダムな曲線は、Koblitz曲線のような特殊な曲線より保守的であり、ランダムpでF_P上の曲線は、特殊な形式のPとF_P上の曲線よりも保守的であり、ランダムpでF_P上の曲線は、上の曲線より保守的であると考えられます特性2に対する同様の大きさの複数のフィールドの間に選択の余地がないようにF_2 ^ M。"
    },
    {
      "indent": 3,
      "text": "Another issue is the potential for catastrophic failures when a single elliptic curve is widely used. In this case, an attack on the elliptic curve might result in the compromise of a large number of keys. Again, this concern may need to be balanced against efficiency and interoperability improvements associated with widely used curves. Substantial additional information on elliptic curve choice can be found in [IEEE.P1363], [ANSI.X9-62.2005], and [FIPS.186-4].",
      "ja": "もう一つの問題は、単一の楕円曲線が広く使用されている致命的な障害の可能性です。この場合には、楕円曲線上の攻撃は、キーの多数の妥協をもたらすかもしれません。再び、この懸念は、広く使用されている曲線に関連付けられた効率性と相互運用性の向上に対してバランスされる必要があるかもしれません。楕円曲線上の選択に実質的な追加情報は[ANSI.X9-62.2005]、[IEEE.P1363]に見出すことができ、そして[FIPS.186-4]。"
    },
    {
      "indent": 3,
      "text": "The Introduction of [RFC8032] lists the security, performance, and operational advantages of EdDSA signatures over ECDSA signatures using the NIST curves.",
      "ja": "[RFC8032]の導入は、NIST曲線を使用したECDSA署名の上にエドワーズ曲線デジタル署名アルゴリズム署名のセキュリティ、パフォーマンス、および動作上の利点を示しています。"
    },
    {
      "indent": 3,
      "text": "All of the key exchange algorithms defined in this document provide forward secrecy. Some of the deprecated key exchange algorithms do not.",
      "ja": "この文書で定義された鍵交換アルゴリズムのすべては前進の秘密保持を提供しています。非推奨の鍵交換アルゴリズムの一部にはありません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "[RFC4492], the predecessor of this document, defined the IANA registries for the following:",
      "ja": "[RFC4492]は、この文書の前身は、以下のためのIANAレジストリを定義しました："
    },
    {
      "indent": 3,
      "text": "o Supported Groups (Section 5.1)",
      "ja": "サポートされているグループO（5.1節）"
    },
    {
      "indent": 3,
      "text": "o EC Point Format (Section 5.1)",
      "ja": "O EC小数点形式（5.1節）"
    },
    {
      "indent": 3,
      "text": "o EC Curve Type (Section 5.4)",
      "ja": "O EC曲線タイプ（5.4節）"
    },
    {
      "indent": 3,
      "text": "IANA has prepended \"TLS\" to the names of these three registries.",
      "ja": "IANAは、これら3つのレジストリの名前に「TLS」を先頭に追加しました。"
    },
    {
      "indent": 3,
      "text": "For each name space, this document defines the initial value assignments and defines a range of 256 values (NamedCurve) or eight values (ECPointFormat and ECCurveType) reserved for Private Use. The policy for any additional assignments is \"Specification Required\". (RFC 4492 required IETF review.)",
      "ja": "各名前空間のために、この文書は、初期値の割り当てを定義し、プライベート使用のために予約さ256個の値（NamedCurve）または8つの値（ECPointFormatとECCurveType）の範囲を規定します。任意の追加割り当てのポリシーは、「仕様が必要」です。 （RFC 4492には、IETFの見直しが必要。）"
    },
    {
      "indent": 3,
      "text": "All existing entries in the \"ExtensionType Values\", \"TLS ClientCertificateType Identifiers\", \"TLS Cipher Suites\", \"TLS Supported Groups\", \"TLS EC Point Format\", and \"TLS EC Curve Type\" registries that referred to RFC 4492 have been updated to refer to this document.",
      "ja": "「ExtensionType値」、「TLS ClientCertificateType識別子」、「TLS暗号スイート」、「TLS EC小数点形式」、「TLSグループをサポート」、およびRFC 4492でいう「TLS ECカーブタイプ」レジストリがされているすべての既存のエントリこのドキュメントを参照するように更新。"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the value 29 to x25519 and the value 30 to x448 in the \"TLS Supported Groups\" registry.",
      "ja": "IANAは、「TLSサポートグループ」レジストリのx448にx25519と値30に値29を割り当てています。"
    },
    {
      "indent": 3,
      "text": "IANA has assigned two values in the \"TLS SignatureAlgorithm\" registry for ed25519 (7) and ed448 (8) with this document as reference. This keeps compatibility with TLS 1.3.",
      "ja": "IANAは、参考として本文書に（7）ed25519は、「TLSのsignatureAlgorithm」レジストリ内の2つの値を割り当てられ、ed448（8）を有しています。これは、TLS 1.3との互換性を維持します。"
    },
    {
      "indent": 3,
      "text": "IANA has assigned one value from the \"TLS HashAlgorithm\" registry for Intrinsic (8) with DTLS-OK set to true (Y) and this document as reference. This keeps compatibility with TLS 1.3.",
      "ja": "IANAは、（8）DTLS-OK真（Y）に設定され、参照としてこの文書に組み込みのために、「TLS HashAlgorithm」レジストリから1つの値を割り当てました。これは、TLS 1.3との互換性を維持します。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ANSI.X9-62.2005] American National Standards Institute, \"Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)\", ANSI X9.62, November 2005.",
      "ja": "[ANSI.X9-62.2005]米国規格協会、「金融サービス業界向け公開鍵暗号：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANSI X9.62、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS.186-4] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[FIPS.186-4]米国国立標準技術研究所、 \"デジタル署名標準（DSS）\"、FIPS PUBの186から4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月、<のhttp：// nvlpubs。 nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2246] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, DOI 10.17487/RFC2246, January 1999, <https://www.rfc-editor.org/info/rfc2246>.",
      "ja": "[RFC2246]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、DOI 10.17487 / RFC2246、1999年1月、<https://www.rfc-editor.org/info/rfc2246>。"
    },
    {
      "indent": 3,
      "text": "[RFC3279] Bassham, L., Polk, W., and R. Housley, \"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3279, DOI 10.17487/RFC3279, April 2002, <https://www.rfc-editor.org/info/rfc3279>.",
      "ja": "[RFC3279] Bassham、L.、ポーク、W.、およびR. Housley氏、RFC 3279、DOI 10.17487 / RFC3279、 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールのためのアルゴリズムと識別子\" 2002年4月、<https://www.rfc-editor.org/info/rfc3279>。"
    },
    {
      "indent": 3,
      "text": "[RFC4346] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.1\", RFC 4346, DOI 10.17487/RFC4346, April 2006, <https://www.rfc-editor.org/info/rfc4346>.",
      "ja": "[RFC4346]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.1\"、RFC 4346、DOI 10.17487 / RFC4346、2006年4月、<https://www.rfc-editor.org/info / RFC4346>。"
    },
    {
      "indent": 3,
      "text": "[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 4366, DOI 10.17487/RFC4366, April 2006, <https://www.rfc-editor.org/info/rfc4366>.",
      "ja": "[RFC4366]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 4366、DOI 10.17487 / RFC4366、2006年4月、<https://www.rfc-editor.org/info/rfc4366>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5289] Rescorla, E., \"TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)\", RFC 5289, DOI 10.17487/RFC5289, August 2008, <https://www.rfc-editor.org/info/rfc5289>.",
      "ja": "[RFC5289]レスコラ、E.、RFC 5289 \"SHA-256/384およびAESガロア・カウンタ・モード（GCM）とTLS楕円曲線暗号スイート\"、DOI 10.17487 / RFC5289、2008年8月、<HTTPS：//www.rfc- editor.org/info/rfc5289>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A.、ハンブルク、M.、およびS.ターナー、 \"セキュリティのための楕円曲線\"、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<https://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 3,
      "text": "[RFC8017] Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch, \"PKCS #1: RSA Cryptography Specifications Version 2.2\", RFC 8017, DOI 10.17487/RFC8017, November 2016, <https://www.rfc-editor.org/info/rfc8017>.",
      "ja": "[RFC8017]モリアーティ、K.、エド、Kaliski、B.、ジョンソン、J.、およびA.ラッシュ、 \"PKCS＃1：RSA暗号仕様バージョン2.2\"、RFC 8017、DOI 10.17487 / RFC8017、2016年11月、< https://www.rfc-editor.org/info/rfc8017>。"
    },
    {
      "indent": 3,
      "text": "[RFC8032] Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital Signature Algorithm (EdDSA)\", RFC 8032, DOI 10.17487/RFC8032, January 2017, <https://www.rfc-editor.org/info/rfc8032>.",
      "ja": "[RFC8032] Josefsson氏、S.及びI. Liusvaara、 \"エドワーズ - 曲線デジタル署名アルゴリズム（エドワーズ曲線デジタル署名アルゴリズム）\"、RFC 8032、DOI 10.17487 / RFC8032、2017年1月、<https://www.rfc-editor.org/info/ rfc8032>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8410] Josefsson, S. and J. Schaad, \"Algorithm Identifiers for Ed25519, Ed448, X25519 and X448 for Use in the Internet X.509 Public Key Infrastructure\", RFC 8410, DOI 10.17487/RFC8410, August 2018, <https://www.rfc-editor.org/info/rfc8410>.",
      "ja": "[RFC8410] Josefsson氏、S.とJ. Schaad、 \"Ed25519、Ed448ためのアルゴリズムの識別子、インターネットX.509公開鍵インフラストラクチャで使用するためのX25519およびX448\"、RFC 8410、DOI 10.17487 / RFC8410、2018年8月、<HTTPS： //www.rfc-editor.org/info/rfc8410>。"
    },
    {
      "indent": 3,
      "text": "[SECG-SEC2] Certicom Research, \"SEC 2: Recommended Elliptic Curve Domain Parameters\", Standards for Efficient Cryptography 2 (SEC 2), Version 2.0, January 2010, <http://www.secg.org/sec2-v2.pdf>.",
      "ja": "[SECG-SEC2] Certicomの研究、 \"SEC 2：楕円曲線ドメインパラメータの推奨\"、効率的な暗号2の基準（SEC 2）、バージョン2.0、2010年1月、<http://www.secg.org/sec2-v2。 PDF>。"
    },
    {
      "indent": 3,
      "text": "[X.680] ITU-T, \"Abstract Syntax Notation One (ASN.1): Specification of basic notation\", ITU-T Recommendation X.680, ISO/IEC 8824-1, August 2015.",
      "ja": "[X.680] ITU-T、 \"抽象構文記法1（ASN.1）：基本的な表記法の仕様\"、ITU-T勧告X.680、ISO / IEC 8824から1、2015年8月。"
    },
    {
      "indent": 3,
      "text": "[X.690] ITU-T, \"Information technology-ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, ISO/IEC 8825-1, August 2015.",
      "ja": "[X.690] ITU-T、 \"情報技術 -  ASN.1符号化ルール：基本符号化規則（BER）、Canonicalの符号化規則（CER）と識別符号化規則（DER）の仕様\"、ITU-T勧告X.690 、ISO / IEC 8825から1、2015年8月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[FIPS.180-4] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[FIPS.180-4]米国国立標準技術研究所、 \"セキュアハッシュ規格（SHS）\"、FIPS PUB 180-4の、DOI 10.6028 / NIST.FIPS.180-4、2015年8月、<のhttp：// nvlpubs。 nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IEEE.P1363] IEEE, \"Standard Specifications for Public Key Cryptography\", IEEE Std P1363, <http://ieeexplore.ieee.org/document/891000/>.",
      "ja": "[IEEE.P1363] IEEE、 \"公開鍵暗号のための標準仕様\"、IEEE規格P1363、<http://ieeexplore.ieee.org/document/891000/>。"
    },
    {
      "indent": 3,
      "text": "[Menezes] Menezes, A. and B. Ustaoglu, \"On reusing ephemeral keys in Diffie-Hellman key agreement protocols\", International Journal of Applied Cryptography, Vol. 2, Issue 2, DOI 10.1504/IJACT.2010.038308, January 2010.",
      "ja": "、応用暗号集の国際ジャーナル「のDiffie-Hellman鍵合意プロトコルではかないキーを再利用するには、」[メネゼス]メネゼス、A.およびB. Ustaoglu、。 2、問題2、DOI 10.1504 / IJACT.2010.038308、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4492] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)\", RFC 4492, DOI 10.17487/RFC4492, May 2006, <https://www.rfc-editor.org/info/rfc4492>.",
      "ja": "[RFC4492]ブレイク・ウィルソン、S.、Bolyard、N.、グプタ、V.、ホーク、C.、​​およびB.メラー、 \"楕円曲線暗号（ECC）暗号スイートトランスポート層セキュリティ（TLS）のための\"、RFC 4492 、DOI 10.17487 / RFC4492、2006年5月、<https://www.rfc-editor.org/info/rfc4492>。"
    },
    {
      "indent": 3,
      "text": "[RFC7919] Gillmor, D., \"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)\", RFC 7919, DOI 10.17487/RFC7919, August 2016, <https://www.rfc-editor.org/info/rfc7919>.",
      "ja": "[RFC7919] Gillmor氏、D.、RFC 7919 \"トランスポート層セキュリティ（TLS）の有限フィールドのDiffie-Hellmanのエフェメラルパラメータを交渉\"、DOI 10.17487 / RFC7919、2016年8月、<https://www.rfc-editor.org/情報/ rfc7919>。"
    },
    {
      "indent": 3,
      "text": "[TLS1.3] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", Work in Progress, draft-ietf-tls-tls13-28, March 2018.",
      "ja": "[TLS1.3]レスコラ、E.、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.3\" が進行中で働いて、ドラフト-IETF-TLS-tls13-28、2018年3月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Equivalent Curves (Informative)",
      "ja": "付録A.等価曲線（参考情報）"
    },
    {
      "indent": 3,
      "text": "All of the NIST curves [FIPS.186-4] and several of the ANSI curves [ANSI.X9-62.2005] are equivalent to curves listed in Section 5.1.1. The following table displays the curve names chosen by different standards organizations; multiple names in one row represent aliases for the same curve.",
      "ja": "ANSI曲線[ANSI.X9-62.2005]のNIST曲線[FIPS.186-4]のすべてのいくつかは、セクション5.1.1に記載されている曲線に相当します。次の表は、さまざまな標準化団体によって選ばれた曲線の名前を表示します。 1行の複数の名前は、同じ曲線のエイリアスを表します。"
    },
    {
      "indent": 18,
      "text": "+-----------+------------+------------+\n| SECG      | ANSI X9.62 | NIST       |\n+-----------+------------+------------+\n| sect163k1 |            | NIST K-163 |\n| sect163r1 |            |            |\n| sect163r2 |            | NIST B-163 |\n| sect193r1 |            |            |\n| sect193r2 |            |            |\n| sect233k1 |            | NIST K-233 |\n| sect233r1 |            | NIST B-233 |\n| sect239k1 |            |            |\n| sect283k1 |            | NIST K-283 |\n| sect283r1 |            | NIST B-283 |\n| sect409k1 |            | NIST K-409 |\n| sect409r1 |            | NIST B-409 |\n| sect571k1 |            | NIST K-571 |\n| sect571r1 |            | NIST B-571 |\n| secp160k1 |            |            |\n| secp160r1 |            |            |\n| secp160r2 |            |            |\n| secp192k1 |            |            |\n| secp192r1 | prime192v1 | NIST P-192 |\n| secp224k1 |            |            |\n| secp224r1 |            | NIST P-224 |\n| secp256k1 |            |            |\n| secp256r1 | prime256v1 | NIST P-256 |\n| secp384r1 |            | NIST P-384 |\n| secp521r1 |            | NIST P-521 |\n+-----------+------------+------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Table 4: Equivalent Curves Defined by SECG, ANSI, and NIST",
      "ja": "表4：SECG、ANSI、およびNISTによって定義同等の曲線"
    },
    {
      "indent": 1,
      "text": "Appendix B. Differences from",
      "ja": "から付録B.違い"
    },
    {
      "indent": 3,
      "text": "o Renamed EllipticCurveList to NamedCurveList.",
      "ja": "O NamedCurveListにEllipticCurveListの名前を変更しました。"
    },
    {
      "indent": 3,
      "text": "o Added TLS 1.2.",
      "ja": "O TLS 1.2を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Merged errata.",
      "ja": "O正誤表を吸収合併。"
    },
    {
      "indent": 3,
      "text": "o Removed the ECDH key exchange algorithms: ECDH_RSA and ECDH_ECDSA",
      "ja": "ECDH_RSAとECDH_ECDSA：O ECDH鍵交換アルゴリズムを削除"
    },
    {
      "indent": 3,
      "text": "o Deprecated a bunch of ciphersuites:",
      "ja": "O暗号スイートの束を非推奨："
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_ECDSA_WITH_NULL_SHA",
      "ja": "TLS_ECDH_ECDSA_WITH_NULL_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
      "ja": "TLS_ECDH_ECDSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
      "ja": "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
      "ja": "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_RSA_WITH_NULL_SHA",
      "ja": "TLS_ECDH_RSA_WITH_NULL_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_RSA_WITH_RC4_128_SHA",
      "ja": "TLS_ECDH_RSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
      "ja": "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
      "ja": "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 9,
      "text": "All the other RC4 ciphersuites",
      "ja": "他のすべてのRC4暗号群"
    },
    {
      "indent": 3,
      "text": "o Removed unused curves and all but the uncompressed point format.",
      "ja": "O未使用曲線と非圧縮小数点フォーマットが、すべてを削除しました。"
    },
    {
      "indent": 3,
      "text": "o Added X25519 and X448.",
      "ja": "O X25519およびX448を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Deprecated explicit curves.",
      "ja": "O明示的な曲線を推奨されていません。"
    },
    {
      "indent": 3,
      "text": "o Removed restriction on signature algorithm in certificate.",
      "ja": "O証明書に署名アルゴリズムの制限を削除しました。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Most of the text in this document is taken from [RFC4492], the predecessor of this document. The authors of that document were:",
      "ja": "この文書内のテキストのほとんどは、[RFC4492]、このドキュメントの前任者から取得されます。その文書の作成者は以下の通りでした。"
    },
    {
      "indent": 3,
      "text": "o Simon Blake-Wilson o Nelson Bolyard o Vipul Gupta o Chris Hawk o Bodo Moeller",
      "ja": "ボードーメラーOクリス・ホークOビパル・グプタOネルソンBolyard〇〇サイモン・ブレイク・ウィルソン"
    },
    {
      "indent": 3,
      "text": "In the predecessor document, the authors acknowledged the contributions of Bill Anderson and Tim Dierks.",
      "ja": "前身の文書では、著者は、ビル・アンダーソンとティム・ダークスの貢献を認めました。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Nikos Mavrogiannopoulos, Martin Thomson, and Tanja Lange for contributions to this document.",
      "ja": "作者はこのドキュメントへの貢献のためニコスMavrogiannopoulos、マーティン・トムソン、とターニャランゲに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yoav Nir Check Point Software Technologies Ltd. 5 Hasolelim st. Tel Aviv 6789735 Israel",
      "ja": "ヨアフニールは、ポイント・ソフトウェア・テクノロジーズ株式会社5 Hasolelim STをチェックしてください。テルアビブ6789735イスラエル"
    },
    {
      "indent": 3,
      "text": "Email: ynir.ietf@gmail.com",
      "ja": "メール：ynir.ietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB",
      "ja": "サイモンJosefsson氏SJD AB"
    },
    {
      "indent": 3,
      "text": "Email: simon@josefsson.org",
      "ja": "メール：simon@josefsson.org"
    },
    {
      "indent": 3,
      "text": "Manuel Pegourie-Gonnard ARM",
      "ja": "マヌエルPegourie-Gonnard ARM"
    },
    {
      "indent": 3,
      "text": "Email: mpg@elzevir.fr",
      "ja": "メール：mpg@elzevir.fr"
    }
  ]
}