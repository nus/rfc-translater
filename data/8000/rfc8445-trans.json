{
  "title": {
    "text": "RFC 8445 - Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal",
    "ja": "RFC 8445 - 対話型接続確立（ICE）：ネットワークアドレス変換（NAT）トラバーサル用のプロトコル"
  },
  "number": 8445,
  "created_at": "2019-10-23 22:38:07.279980+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        A. Keranen\nRequest for Comments: 8445                                   C. Holmberg\nObsoletes: 5245                                                 Ericsson\nCategory: Standards Track                                   J. Rosenberg\nISSN: 2070-1721                                              jdrosen.net\n                                                               July 2018",
      "raw": true
    },
    {
      "indent": 7,
      "text": "      Interactive Connectivity Establishment (ICE):\nA Protocol for Network Address Translator (NAT) Traversal",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based communication. This protocol is called Interactive Connectivity Establishment (ICE). ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).",
      "ja": "このドキュメントでは、UDPベースの通信のためのNetwork Address Translator（NAT）トラバーサルのプロトコルについて説明します。 このプロトコルは、Interactive Connectivity Establishment（ICE）と呼ばれます。 ICEは、NAT（STUN）プロトコル用のセッショントラバーサルユーティリティとその拡張機能であるリレーNATを使用したトラバーサル（TURN）を使用します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 5245.",
      "ja": "このドキュメントはRFC 5245を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8445.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8445で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2018 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれている場合があります。この資料の一部の著作権を管理する人は、IETFトラストにそのような資料の変更を許可する権利を付与していない可能性があります IETF標準プロセスの外部。 そのような資料の著作権を管理している人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセスの外で変更できず、その派生物はIETF標準プロセスの外で作成できません。 RFCとしての公開、または英語以外の言語への翻訳。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5\n2.  Overview of ICE . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  Gathering Candidates  . . . . . . . . . . . . . . . . . .   8\n  2.2.  Connectivity Checks . . . . . . . . . . . . . . . . . . .  10\n  2.3.  Nominating Candidate Pairs and Concluding ICE . . . . . .  12\n  2.4.  ICE Restart . . . . . . . . . . . . . . . . . . . . . . .  13\n  2.5.  Lite Implementations  . . . . . . . . . . . . . . . . . .  13\n3.  ICE Usage . . . . . . . . . . . . . . . . . . . . . . . . . .  13\n4.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  13\n5.  ICE Candidate Gathering and Exchange  . . . . . . . . . . . .  17\n  5.1.  Full Implementation . . . . . . . . . . . . . . . . . . .  17\n    5.1.1.  Gathering Candidates  . . . . . . . . . . . . . . . .  18\n      5.1.1.1.  Host Candidates . . . . . . . . . . . . . . . . .  18\n      5.1.1.2.  Server-Reflexive and Relayed Candidates . . . . .  20\n      5.1.1.3.  Computing Foundations . . . . . . . . . . . . . .  21\n      5.1.1.4.  Keeping Candidates Alive  . . . . . . . . . . . .  21\n    5.1.2.  Prioritizing Candidates . . . . . . . . . . . . . . .  22\n      5.1.2.1.  Recommended Formula . . . . . . . . . . . . . . .  22\n      5.1.2.2.  Guidelines for Choosing Type and Local\n                Preferences . . . . . . . . . . . . . . . . . . .  23\n    5.1.3.  Eliminating Redundant Candidates  . . . . . . . . . .  23\n  5.2.  Lite Implementation Procedures  . . . . . . . . . . . . .  23\n  5.3.  Exchanging Candidate Information  . . . . . . . . . . . .  24\n  5.4.  ICE Mismatch  . . . . . . . . . . . . . . . . . . . . . .  26\n6.  ICE Candidate Processing  . . . . . . . . . . . . . . . . . .  26\n  6.1.  Procedures for Full Implementation  . . . . . . . . . . .  26\n    6.1.1.  Determining Role  . . . . . . . . . . . . . . . . . .  26\n    6.1.2.  Forming the Checklists  . . . . . . . . . . . . . . .  28\n      6.1.2.1.  Checklist State . . . . . . . . . . . . . . . . .  28\n      6.1.2.2.  Forming Candidate Pairs . . . . . . . . . . . . .  28\n      6.1.2.3.  Computing Pair Priority and Ordering Pairs  . . .  31\n      6.1.2.4.  Pruning the Pairs . . . . . . . . . . . . . . . .  31\n      6.1.2.5.  Removing Lower-Priority Pairs . . . . . . . . . .  31\n      6.1.2.6.  Computing Candidate Pair States . . . . . . . . .  32\n    6.1.3.  ICE State . . . . . . . . . . . . . . . . . . . . . .  36\n    6.1.4.  Scheduling Checks . . . . . . . . . . . . . . . . . .  36\n      6.1.4.1.  Triggered-Check Queue . . . . . . . . . . . . . .  36\n      6.1.4.2.  Performing Connectivity Checks  . . . . . . . . .  36\n  6.2.  Lite Implementation Procedures  . . . . . . . . . . . . .  38\n7.  Performing Connectivity Checks  . . . . . . . . . . . . . . .  38\n  7.1.  STUN Extensions . . . . . . . . . . . . . . . . . . . . .  38\n    7.1.1.  PRIORITY  . . . . . . . . . . . . . . . . . . . . . .  38\n    7.1.2.  USE-CANDIDATE . . . . . . . . . . . . . . . . . . . .  38\n    7.1.3.  ICE-CONTROLLED and ICE-CONTROLLING  . . . . . . . . .  39\n  7.2.  STUN Client Procedures  . . . . . . . . . . . . . . . . .  39\n    7.2.1.  Creating Permissions for Relayed Candidates . . . . .  39",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    7.2.2.  Forming Credentials . . . . . . . . . . . . . . . . .  39\n    7.2.3.  Diffserv Treatment  . . . . . . . . . . . . . . . . .  40\n    7.2.4.  Sending the Request . . . . . . . . . . . . . . . . .  40\n    7.2.5.  Processing the Response . . . . . . . . . . . . . . .  40\n      7.2.5.1.  Role Conflict . . . . . . . . . . . . . . . . . .  40\n      7.2.5.2.  Failure . . . . . . . . . . . . . . . . . . . . .  41\n        7.2.5.2.1.  Non-Symmetric Transport Addresses . . . . . .  41\n        7.2.5.2.2.  ICMP Error  . . . . . . . . . . . . . . . . .  41\n        7.2.5.2.3.  Timeout . . . . . . . . . . . . . . . . . . .  41\n        7.2.5.2.4.  Unrecoverable STUN Response . . . . . . . . .  41\n      7.2.5.3.  Success . . . . . . . . . . . . . . . . . . . . .  42\n        7.2.5.3.1.  Discovering Peer-Reflexive Candidates . . . .  42\n        7.2.5.3.2.  Constructing a Valid Pair . . . . . . . . . .  43\n        7.2.5.3.3.  Updating Candidate Pair States  . . . . . . .  44\n        7.2.5.3.4.  Updating the Nominated Flag . . . . . . . . .  44\n      7.2.5.4.  Checklist State Updates . . . . . . . . . . . . .  44\n  7.3.  STUN Server Procedures  . . . . . . . . . . . . . . . . .  45\n    7.3.1.  Additional Procedures for Full Implementations  . . .  45\n      7.3.1.1.  Detecting and Repairing Role Conflicts  . . . . .  46\n      7.3.1.2.  Computing Mapped Addresses  . . . . . . . . . . .  47\n      7.3.1.3.  Learning Peer-Reflexive Candidates  . . . . . . .  47\n      7.3.1.4.  Triggered Checks  . . . . . . . . . . . . . . . .  47\n      7.3.1.5.  Updating the Nominated Flag . . . . . . . . . . .  49\n    7.3.2.  Additional Procedures for Lite Implementations  . . .  49\n8.  Concluding ICE Processing . . . . . . . . . . . . . . . . . .  50\n  8.1.  Procedures for Full Implementations . . . . . . . . . . .  50\n    8.1.1.  Nominating Pairs  . . . . . . . . . . . . . . . . . .  50\n    8.1.2.  Updating Checklist and ICE States . . . . . . . . . .  51\n  8.2.  Procedures for Lite Implementations . . . . . . . . . . .  52\n  8.3.  Freeing Candidates  . . . . . . . . . . . . . . . . . . .  53\n    8.3.1.  Full Implementation Procedures  . . . . . . . . . . .  53\n    8.3.2.  Lite Implementation Procedures  . . . . . . . . . . .  53\n9.  ICE Restarts  . . . . . . . . . . . . . . . . . . . . . . . .  53\n10. ICE Option  . . . . . . . . . . . . . . . . . . . . . . . . .  54\n11. Keepalives  . . . . . . . . . . . . . . . . . . . . . . . . .  54\n12. Data Handling . . . . . . . . . . . . . . . . . . . . . . . .  55\n  12.1.  Sending Data . . . . . . . . . . . . . . . . . . . . . .  55\n    12.1.1.  Procedures for Lite Implementations  . . . . . . . .  56\n  12.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . .  56\n13. Extensibility Considerations  . . . . . . . . . . . . . . . .  57\n14. Setting Ta and RTO  . . . . . . . . . . . . . . . . . . . . .  57\n  14.1.  General  . . . . . . . . . . . . . . . . . . . . . . . .  57\n  14.2.  Ta . . . . . . . . . . . . . . . . . . . . . . . . . . .  58\n  14.3.  RTO  . . . . . . . . . . . . . . . . . . . . . . . . . .  58\n15. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  59\n  15.1.  Example with IPv4 Addresses  . . . . . . . . . . . . . .  60\n  15.2.  Example with IPv6 Addresses  . . . . . . . . . . . . . .  65",
      "raw": true
    },
    {
      "indent": 3,
      "text": "16. STUN Extensions . . . . . . . . . . . . . . . . . . . . . . .  69\n  16.1.  Attributes . . . . . . . . . . . . . . . . . . . . . . .  69\n  16.2.  New Error-Response Codes . . . . . . . . . . . . . . . .  70\n17. Operational Considerations  . . . . . . . . . . . . . . . . .  70\n  17.1.  NAT and Firewall Types . . . . . . . . . . . . . . . . .  70\n  17.2.  Bandwidth Requirements . . . . . . . . . . . . . . . . .  70\n    17.2.1.  STUN and TURN Server-Capacity Planning . . . . . . .  71\n    17.2.2.  Gathering and Connectivity Checks  . . . . . . . . .  71\n    17.2.3.  Keepalives . . . . . . . . . . . . . . . . . . . . .  72\n  17.3.  ICE and ICE-Lite . . . . . . . . . . . . . . . . . . . .  72\n  17.4.  Troubleshooting and Performance Management . . . . . . .  72\n  17.5.  Endpoint Configuration . . . . . . . . . . . . . . . . .  73\n18. IAB Considerations  . . . . . . . . . . . . . . . . . . . . .  73\n  18.1.  Problem Definition . . . . . . . . . . . . . . . . . . .  73\n  18.2.  Exit Strategy  . . . . . . . . . . . . . . . . . . . . .  74\n  18.3.  Brittleness Introduced by ICE  . . . . . . . . . . . . .  74\n  18.4.  Requirements for a Long-Term Solution  . . . . . . . . .  75\n  18.5.  Issues with Existing NAPT Boxes  . . . . . . . . . . . .  75\n19. Security Considerations . . . . . . . . . . . . . . . . . . .  76\n  19.1.  IP Address Privacy . . . . . . . . . . . . . . . . . . .  76\n  19.2.  Attacks on Connectivity Checks . . . . . . . . . . . . .  77\n  19.3.  Attacks on Server-Reflexive Address Gathering  . . . . .  80\n  19.4.  Attacks on Relayed Candidate Gathering . . . . . . . . .  80\n  19.5.  Insider Attacks  . . . . . . . . . . . . . . . . . . . .  81\n    19.5.1.  STUN Amplification Attack  . . . . . . . . . . . . .  81\n20. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  82\n  20.1.  STUN Attributes  . . . . . . . . . . . . . . . . . . . .  82\n  20.2.  STUN Error Responses . . . . . . . . . . . . . . . . . .  82\n  20.3.  ICE Options  . . . . . . . . . . . . . . . . . . . . . .  82\n21. Changes from RFC 5245 . . . . . . . . . . . . . . . . . . . .  83\n22. References  . . . . . . . . . . . . . . . . . . . . . . . . .  84\n  22.1.  Normative References . . . . . . . . . . . . . . . . . .  84\n  22.2.  Informative References . . . . . . . . . . . . . . . . .  85\nAppendix A.  Lite and Full Implementations  . . . . . . . . . . .  89\nAppendix B.  Design Motivations . . . . . . . . . . . . . . . . .  90\n  B.1.  Pacing of STUN Transactions . . . . . . . . . . . . . . .  90\n  B.2.  Candidates with Multiple Bases  . . . . . . . . . . . . .  92\n  B.3.  Purpose of the Related-Address and Related-Port\n        Attributes  . . . . . . . . . . . . . . . . . . . . . . .  94\n  B.4.  Importance of the STUN Username . . . . . . . . . . . . .  95\n  B.5.  The Candidate Pair Priority Formula . . . . . . . . . . .  96\n  B.6.  Why Are Keepalives Needed?  . . . . . . . . . . . . . . .  96\n  B.7.  Why Prefer Peer-Reflexive Candidates? . . . . . . . . . .  97\n  B.8.  Why Are Binding Indications Used for Keepalives?  . . . .  97\n  B.9.  Selecting Candidate Type Preference . . . . . . . . . . .  97\nAppendix C.  Connectivity-Check Bandwidth . . . . . . . . . . . .  99\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 100\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 100",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Protocols establishing communication sessions between peers typically involve exchanging IP addresses and ports for the data sources and sinks. However, this poses challenges when operated through Network Address Translators (NATs) [RFC3235]. These protocols also seek to create a data flow directly between participants, so that there is no application-layer intermediary between them. This is done to reduce data latency, decrease packet loss, and reduce the operational costs of deploying the application. However, this is difficult to accomplish through NATs. A full treatment of the reasons for this is beyond the scope of this specification.",
      "ja": "通常、ピア間で通信セッションを確立するプロトコルには、データソースとシンクのIPアドレスとポートの交換が含まれます。 ただし、これは、ネットワークアドレス変換器（NAT）[RFC3235]を介して操作する場合に課題をもたらします。 これらのプロトコルは、参加者間で直接データフローを作成しようとするため、参加者間にアプリケーション層の仲介はありません。 これは、データの遅延を減らし、パケット損失を減らし、アプリケーションを展開する運用コストを削減するために行われます。 ただし、NATを使用してこれを達成することは困難です。 この理由の完全な取り扱いは、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Numerous solutions have been defined for allowing these protocols to operate through NATs. These include Application Layer Gateways (ALGs), the Middlebox Control Protocol [RFC3303], the original Simple Traversal of UDP Through NAT (STUN) specification [RFC3489] (note that RFC 3489 has been obsoleted by RFC 5389), and Realm Specific IP [RFC3102] [RFC3103] along with session description extensions needed to make them work, such as the Session Description Protocol (SDP) attribute [RFC4566] for the Real-Time Control Protocol (RTCP) [RFC3605]. Unfortunately, these techniques all have pros and cons that make each one optimal in some network topologies, but a poor choice in others. The result is that administrators and implementers are making assumptions about the topologies of the networks in which their solutions will be deployed. This introduces complexity and brittleness into the system.",
      "ja": "これらのプロトコルがNATを介して動作できるようにするための多数のソリューションが定義されています。 これらには、アプリケーションレイヤーゲートウェイ（ALG）、ミドルボックス制御プロトコル[RFC3303]、元のUDPスルーNAT（STUN）仕様[RFC3489]（RFC 3489はRFC 5389で廃止されていることに注意）、およびレルム固有IP [ RFC3102] [RFC3103]およびそれらを機能させるために必要なセッション記述拡張（たとえば、リアルタイム制御プロトコル（RTCP）[RFC3605]のセッション記述プロトコル（SDP）属性[RFC4566]）。 残念なことに、これらの手法にはすべて、長所と短所があり、ネットワークトポロジによっては最適化されますが、他のネットワークトポロジでは不十分な選択になります。 その結果、管理者と実装者は、ソリューションが展開されるネットワークのトポロジについて推測を行っています。 これは、システムに複雑さと脆弱性をもたらします。"
    },
    {
      "indent": 3,
      "text": "This specification defines Interactive Connectivity Establishment (ICE) as a technique for NAT traversal for UDP-based data streams (though ICE has been extended to handle other transport protocols, such as TCP [RFC6544]). ICE works by exchanging a multiplicity of IP addresses and ports, which are then tested for connectivity by peer-to-peer connectivity checks. The IP addresses and ports are exchanged using ICE-usage-specific mechanisms (e.g., in an Offer/ Answer exchange), and the connectivity checks are performed using STUN [RFC5389]. ICE also makes use of Traversal Using Relay around NAT (TURN) [RFC5766], an extension to STUN. Because ICE exchanges a multiplicity of IP addresses and ports for each media stream, it also allows for address selection for multihomed and dual-stack hosts. For this reason, RFC 5245 [RFC5245] deprecated the solutions previously defined in RFC 4091 [RFC4091] and RFC 4092 [RFC4092].",
      "ja": "この仕様では、Interactive Connectivity Establishment（ICE）をUDPベースのデータストリームのNATトラバーサルの手法として定義しています（ただし、ICEはTCP [RFC6544]などの他のトランスポートプロトコルを処理するように拡張されています）。 ICEは、多数のIPアドレスとポートを交換することで機能します。これらのIPアドレスとポートは、ピアツーピア接続チェックによって接続性がテストされます。 IPアドレスとポートは、ICE使用固有のメカニズム（たとえば、オファー/アンサー交換）を使用して交換され、接続チェックはSTUN [RFC5389]を使用して実行されます。 ICEは、STUNの拡張機能であるNATを使用したリレー（TURN）[RFC5766]を使用したトラバーサルも利用します。 ICEは各メディアストリームに対して多数のIPアドレスとポートを交換するため、マルチホームホストおよびデュアルスタックホストのアドレス選択も可能です。 このため、RFC 5245 [RFC5245]は、RFC 4091 [RFC4091]およびRFC 4092 [RFC4092]で以前に定義されたソリューションを非推奨にしました。"
    },
    {
      "indent": 3,
      "text": "Appendix B provides background information and motivations regarding the design decisions that were made when designing ICE.",
      "ja": "付録Bは、ICEを設計するときに下された設計上の決定に関する背景情報と動機を提供します。"
    },
    {
      "indent": 0,
      "text": "2. Overview of ICE",
      "section_title": true,
      "ja": "2. ICEの概要"
    },
    {
      "indent": 3,
      "text": "In a typical ICE deployment, there are two endpoints (ICE agents) that want to communicate. Note that ICE is not intended for NAT traversal for the signaling protocol, which is assumed to be provided via another mechanism. ICE assumes that the agents are able to establish a signaling connection between each other.",
      "ja": "一般的なICE展開では、通信する2つのエンドポイント（ICEエージェント）があります。 ICEは、別のメカニズムを介して提供されると想定される、シグナリングプロトコルのNATトラバーサルを目的としていないことに注意してください。 ICEは、エージェントが互いに信号接続を確立できると想定しています。"
    },
    {
      "indent": 3,
      "text": "Initially, the agents are ignorant of their own topologies. In particular, the agents may or may not be behind NATs (or multiple tiers of NATs). ICE allows the agents to discover enough information about their topologies to potentially find one or more paths by which they can establish a data session.",
      "ja": "最初は、エージェントは自分のトポロジーを知らない。 特に、エージェントはNAT（または複数のNAT層）の背後にあってもなくてもかまいません。 ICEを使用すると、エージェントはトポロジに関する十分な情報を検出して、データセッションを確立できる1つ以上のパスを潜在的に見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a typical ICE deployment. The agents are labeled L and R. Both L and R are behind their own respective NATs, though they may not be aware of it. The type of NAT and its properties are also unknown. L and R are capable of engaging in a candidate exchange process, whose purpose is to set up a data session between L and R. Typically, this exchange will occur through a signaling server (e.g., a SIP proxy).",
      "ja": "図1は、一般的なICE展開を示しています。 エージェントにはLとRというラベルが付いています。LとRは、それぞれのNATの背後にありますが、認識していない場合があります。 NATのタイプとそのプロパティも不明です。 LとRは、候補交換プロセスに関与できます。その目的は、LとRの間のデータセッションをセットアップすることです。通常、この交換は、シグナリングサーバー（たとえば、SIPプロキシ）を介して行われます。"
    },
    {
      "indent": 3,
      "text": "In addition to the agents, a signaling server, and NATs, ICE is typically used in concert with STUN or TURN servers in the network. Each agent can have its own STUN or TURN server, or they can be the same.",
      "ja": "通常、エージェント、シグナリングサーバー、およびNATに加えて、ICEはネットワーク内のSTUNまたはTURNサーバーと連携して使用されます。 各エージェントは、独自のSTUNまたはTURNサーバーを持つことも、同じサーバーにすることもできます。"
    },
    {
      "indent": 13,
      "text": "                  +---------+\n+--------+        |Signaling|         +--------+\n| STUN   |        |Server   |         | STUN   |\n| Server |        +---------+         | Server |\n+--------+       /           \\        +--------+\n                /             \\\n               /               \\\n              / <- Signaling -> \\\n             /                   \\\n      +--------+               +--------+\n      |  NAT   |               |  NAT   |\n      +--------+               +--------+\n         /                             \\\n        /                               \\\n    +-------+                       +-------+\n    | Agent |                       | Agent |\n    |   L   |                       |   R   |\n    +-------+                       +-------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 1: ICE Deployment Scenario",
      "ja": "図1：ICE展開シナリオ"
    },
    {
      "indent": 3,
      "text": "The basic idea behind ICE is as follows: each agent has a variety of candidate transport addresses (combination of IP address and port for a particular transport protocol, which is always UDP in this specification) it could use to communicate with the other agent. These might include:",
      "ja": "ICEの背後にある基本的な考え方は次のとおりです。各エージェントには、他のエージェントと通信するために使用できるさまざまな候補トランスポートアドレス（この仕様では常にUDPである特定のトランスポートプロトコルのIPアドレスとポートの組み合わせ）があります。 これらには以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "o A transport address on a directly attached network interface",
      "ja": "o直接接続されたネットワークインターフェイスのトランスポートアドレス"
    },
    {
      "indent": 3,
      "text": "o A translated transport address on the public side of a NAT (a \"server-reflexive\" address)",
      "ja": "o NATのパブリック側の変換されたトランスポートアドレス（「サーバー再帰」アドレス）"
    },
    {
      "indent": 3,
      "text": "o A transport address allocated from a TURN server (a \"relayed address\")",
      "ja": "o TURNサーバーから割り当てられたトランスポートアドレス（「リレーアドレス」）"
    },
    {
      "indent": 3,
      "text": "Potentially, any of L's candidate transport addresses can be used to communicate with any of R's candidate transport addresses. In practice, however, many combinations will not work. For instance, if L and R are both behind NATs, their directly attached interface addresses are unlikely to be able to communicate directly (this is why ICE is needed, after all!). The purpose of ICE is to discover which pairs of addresses will work. The way that ICE does this is to systematically try all possible pairs (in a carefully sorted order) until it finds one or more that work.",
      "ja": "潜在的に、Lの候補トランスポートアドレスのいずれかを使用して、Rの候補トランスポートアドレスのいずれかと通信できます。 ただし、実際には、多くの組み合わせは機能しません。 たとえば、LとRの両方がNATの背後にある場合、直接接続されたインターフェイスアドレスが直接通信できる可能性は低いです（これが、ICEが必要な理由です！）。 ICEの目的は、どのアドレスのペアが機能するかを発見することです。 ICEがこれを行う方法は、1つ以上の機能するものが見つかるまで、考えられるすべてのペアを（慎重にソートされた順序で）体系的に試すことです。"
    },
    {
      "indent": 0,
      "text": "2.1. Gathering Candidates",
      "section_title": true,
      "ja": "2.1.  候補者の収集"
    },
    {
      "indent": 3,
      "text": "In order to execute ICE, an ICE agent identifies and gathers one or more address candidates. A candidate has a transport address -- a combination of IP address and port for a particular transport protocol (with only UDP specified here). There are different types of candidates; some are derived from physical or logical network interfaces, and others are discoverable via STUN and TURN.",
      "ja": "ICEを実行するために、ICEエージェントは1つ以上のアドレス候補を識別して収集します。 候補にはトランスポートアドレスがあります-特定のトランスポートプロトコルのIPアドレスとポートの組み合わせ（ここではUDPのみが指定されています）。 候補にはさまざまな種類があります。 物理または論理ネットワークインターフェイスから派生したものもあれば、STUNおよびTURNを介して検出可能なものもあります。"
    },
    {
      "indent": 3,
      "text": "The first category of candidates are those with a transport address obtained directly from a local interface. Such a candidate is called a \"host candidate\". The local interface could be Ethernet or Wi-Fi, or it could be one that is obtained through a tunnel mechanism, such as a Virtual Private Network (VPN) or Mobile IP (MIP). In all cases, such a network interface appears to the agent as a local interface from which ports (and thus candidates) can be allocated.",
      "ja": "候補の最初のカテゴリは、ローカルインターフェイスから直接取得したトランスポートアドレスを持つものです。 このような候補は「ホスト候補」と呼ばれます。 ローカルインターフェイスは、イーサネットまたはWi-Fiであるか、仮想プライベートネットワーク（VPN）やモバイルIP（MIP）などのトンネルメカニズムを介して取得されるものです。 すべての場合において、このようなネットワークインターフェースは、ポート（および候補）を割り当てることができるローカルインターフェースとしてエージェントに見えます。"
    },
    {
      "indent": 3,
      "text": "Next, the agent uses STUN or TURN to obtain additional candidates. These come in two flavors: translated addresses on the public side of a NAT (server-reflexive candidates) and addresses on TURN servers (relayed candidates). When TURN servers are utilized, both types of candidates are obtained from the TURN server. If only STUN servers are utilized, only server-reflexive candidates are obtained from them. The relationship of these candidates to the host candidate is shown in Figure 2. In this figure, both types of candidates are discovered using TURN. In the figure, the notation X:x means IP address X and UDP port x.",
      "ja": "次に、エージェントはSTUNまたはTURNを使用して追加の候補を取得します。 これらには2つのフレーバーがあります。NATのパブリック側の変換済みアドレス（サーバー再帰候補）とTURNサーバーのアドレス（中継候補）です。 TURNサーバーを使用すると、両方のタイプの候補がTURNサーバーから取得されます。 STUNサーバーのみが使用されている場合、サーバー反射型の候補のみがそれらから取得されます。 これらの候補とホスト候補の関係を図2に示します。この図では、TURNを使用して両方のタイプの候補が検出されます。 図では、表記X：xはIPアドレスXとUDPポートxを意味します。"
    },
    {
      "indent": 22,
      "text": "To Internet",
      "ja": "インターネットへ"
    },
    {
      "indent": 19,
      "text": "       |\n       |\n       |  /------------  Relayed\n   Y:y | /               Address\n   +--------+\n   |        |\n   |  TURN  |\n   | Server |\n   |        |\n   +--------+\n       |\n       |\n       | /------------  Server\nX1':x1'|/               Reflexive\n +------------+         Address\n |    NAT     |\n +------------+\n       |\n       | /------------  Local\n   X:x |/               Address\n   +--------+\n   |        |\n   | Agent  |\n   |        |\n   +--------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 2: Candidate Relationships",
      "ja": "図2：候補者の関係"
    },
    {
      "indent": 3,
      "text": "When the agent sends a TURN Allocate request from IP address and port X:x, the NAT (assuming there is one) will create a binding X1':x1', mapping this server-reflexive candidate to the host candidate X:x. Outgoing packets sent from the host candidate will be translated by the NAT to the server-reflexive candidate. Incoming packets sent to the server-reflexive candidate will be translated by the NAT to the host candidate and forwarded to the agent. The host candidate associated with a given server-reflexive candidate is the \"base\".",
      "ja": "エージェントがIPアドレスとポートX：xからTURN Allocateリクエストを送信すると、NAT（存在すると仮定）はバインディングX1 '：x1'を作成し、このサーバー反射候補をホスト候補X：xにマッピングします。 ホスト候補から送信された発信パケットは、NATによってサーバー反射候補に変換されます。 サーバー反射候補に送信された着信パケットは、NATによってホスト候補に変換され、エージェントに転送されます。 特定のサーバー反射候補に関連付けられているホスト候補は「ベース」です。"
    },
    {
      "indent": 6,
      "text": "Note: \"Base\" refers to the address an agent sends from for a particular candidate. Thus, as a degenerate case, host candidates also have a base, but it's the same as the host candidate.",
      "ja": "注：「ベース」とは、特定の候補者に対してエージェントが送信するアドレスを指します。 したがって、退化したケースとして、ホスト候補にもベースがありますが、ホスト候補と同じです。"
    },
    {
      "indent": 3,
      "text": "When there are multiple NATs between the agent and the TURN server, the TURN request will create a binding on each NAT, but only the outermost server-reflexive candidate (the one nearest the TURN server) will be discovered by the agent. If the agent is not behind a NAT, then the base candidate will be the same as the server-reflexive candidate, and the server-reflexive candidate is redundant and will be eliminated.",
      "ja": "エージェントとTURNサーバーの間に複数のNATがある場合、TURN要求は各NATにバインディングを作成しますが、最も外側のサーバー反射候補（TURNサーバーに最も近い候補）のみがエージェントによって検出されます。 エージェントがNATの背後にない場合、ベース候補はサーバー反射候補と同じになり、サーバー反射候補は冗長であり、除去されます。"
    },
    {
      "indent": 3,
      "text": "The Allocate request then arrives at the TURN server. The TURN server allocates a port y from its local IP address Y, and generates an Allocate response, informing the agent of this relayed candidate. The TURN server also informs the agent of the server-reflexive candidate, X1':x1', by copying the source transport address of the Allocate request into the Allocate response. The TURN server acts as a packet relay, forwarding traffic between L and R. In order to send traffic to L, R sends traffic to the TURN server at Y:y, and the TURN server forwards that to X1':x1', which passes through the NAT where it is mapped to X:x and delivered to L.",
      "ja": "次に、割り当て要求がTURNサーバーに到着します。 TURNサーバーは、ローカルIPアドレスYからポートyを割り当て、Allocate応答を生成し、このリレーされた候補をエージェントに通知します。 TURNサーバーは、Allocate要求のソーストランスポートアドレスをAllocate応答にコピーすることにより、エージェントにサーバー反射候補X1 '：x1'を通知します。 TURNサーバーはパケットリレーとして機能し、LとRの間でトラフィックを転送します。Lにトラフィックを送信するために、RはY：yのTURNサーバーにトラフィックを送信し、TURNサーバーはそれをX1 '：x1'に転送します。 NATを通過し、そこでX：xにマッピングされ、Lに配信されます。"
    },
    {
      "indent": 3,
      "text": "When only STUN servers are utilized, the agent sends a STUN Binding request [RFC5389] to its STUN server. The STUN server will inform the agent of the server-reflexive candidate X1':x1' by copying the source transport address of the Binding request into the Binding response.",
      "ja": "STUNサーバーのみが使用される場合、エージェントはSTUNバインディング要求[RFC5389]をSTUNサーバーに送信します。 STUNサーバーは、Binding要求のソーストランスポートアドレスをBinding応答にコピーすることにより、エージェントにサーバー反射候補X1 '：x1'を通知します。"
    },
    {
      "indent": 0,
      "text": "2.2. Connectivity Checks",
      "section_title": true,
      "ja": "2.2.  接続性チェック"
    },
    {
      "indent": 3,
      "text": "Once L has gathered all of its candidates, it orders them by highest-to-lowest priority and sends them to R over the signaling channel. When R receives the candidates from L, it performs the same gathering process and responds with its own list of candidates. At the end of this process, each ICE agent has a complete list of both its candidates and its peer's candidates. It pairs them up, resulting in candidate pairs. To see which pairs work, each agent schedules a series of connectivity checks. Each check is a STUN request/response transaction that the client will perform on a particular candidate pair by sending a STUN request from the local candidate to the remote candidate.",
      "ja": "Lはすべての候補を収集すると、最高から最低の優先順位でそれらを並べ替え、シグナリングチャネルを介してRに送信します。 RはLから候補を受け取ると、同じ収集プロセスを実行し、独自の候補リストで応答します。 このプロセスの最後に、各ICEエージェントには、候補者とピアの候補者の完全なリストがあります。 それらはペアになり、候補ペアになります。 どのペアが機能するかを確認するために、各エージェントは一連の接続チェックをスケジュールします。 各チェックは、ローカル候補からリモート候補にSTUN要求を送信することにより、クライアントが特定の候補ペアに対して実行するSTUN要求/応答トランザクションです。"
    },
    {
      "indent": 3,
      "text": "The basic principle of the connectivity checks is simple:",
      "ja": "接続性チェックの基本原則は簡単です。"
    },
    {
      "indent": 3,
      "text": "1. Sort the candidate pairs in priority order.",
      "section_title": true,
      "ja": "1.候補ペアを優先順に並べ替えます。"
    },
    {
      "indent": 3,
      "text": "2. Send checks on each candidate pair in priority order.",
      "section_title": true,
      "ja": "2.各候補者ペアに優先順位でチェックを送信します。"
    },
    {
      "indent": 3,
      "text": "3. Acknowledge checks received from the other agent.",
      "section_title": true,
      "ja": "3.他のエージェントから受信した確認を確認します。"
    },
    {
      "indent": 3,
      "text": "With both agents performing a check on a candidate pair, the result is a 4-way handshake:",
      "ja": "両方のエージェントが候補ペアでチェックを実行すると、結果は4ウェイハンドシェイクになります。"
    },
    {
      "indent": 18,
      "text": "L                        R\n-                        -\nSTUN request ->             \\  L's\n          <- STUN response  /  check",
      "raw": true
    },
    {
      "indent": 18,
      "text": " <- STUN request \\ R's STUN response -> / check",
      "ja": "<-STUNリクエスト\\ RのSTUNレスポンス-> /チェック"
    },
    {
      "indent": 20,
      "text": "Figure 3: Basic Connectivity Check",
      "ja": "図3：基本的な接続チェック"
    },
    {
      "indent": 3,
      "text": "It is important to note that STUN requests are sent to and from the exact same IP addresses and ports that will be used for data (e.g., RTP, RTCP, or other protocols). Consequently, agents demultiplex STUN and data using the contents of the packets rather than the port on which they are received.",
      "ja": "STUN要求は、データ（RTP、RTCP、または他のプロトコルなど）に使用されるものとまったく同じIPアドレスおよびポートとの間で送受信されることに注意することが重要です。 その結果、エージェントは、受信先のポートではなくパケットのコンテンツを使用して、STUNとデータを逆多重化します。"
    },
    {
      "indent": 3,
      "text": "Because a STUN Binding request is used for the connectivity check, the STUN Binding response will contain the agent's translated transport address on the public side of any NATs between the agent and its peer. If this transport address is different from that of other candidates the agent already learned, it represents a new candidate (peer-reflexive candidate), which then gets tested by ICE just the same as any other candidate.",
      "ja": "STUNバインディング要求は接続チェックに使用されるため、STUNバインディング応答には、エージェントとそのピア間のNATのパブリック側にあるエージェントの変換済みトランスポートアドレスが含まれます。 このトランスポートアドレスが、エージェントがすでに学習した他の候補のアドレスと異なる場合、それは新しい候補（ピア反射候補）を表し、他の候補とまったく同じようにICEによってテストされます。"
    },
    {
      "indent": 3,
      "text": "Because the algorithm above searches all candidate pairs, if a working pair exists, the algorithm will eventually find it no matter what order the candidates are tried in. In order to produce faster (and better) results, the candidates are sorted in a specified order. The resulting list of sorted candidate pairs is called the \"checklist\".",
      "ja": "上記のアルゴリズムはすべての候補ペアを検索するため、作業ペアが存在する場合、アルゴリズムは候補が試行された順序に関係なく最終的にそれを検出します。 。 ソートされた候補ペアの結果リストは「チェックリスト」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The agent works through the checklist by sending a STUN request for the next candidate pair on the list periodically. These are called \"ordinary checks\". When a STUN transaction succeeds, one or more candidate pairs will become so-called \"valid pairs\" and will be added to a candidate-pair list called the \"valid list\".",
      "ja": "エージェントは、リスト上の次の候補ペアに対するSTUN要求を定期的に送信することにより、チェックリストを処理します。 これらは「通常のチェック」と呼ばれます。 STUNトランザクションが成功すると、1つ以上の候補ペアがいわゆる「有効なペア」になり、「有効なリスト」と呼ばれる候補ペアのリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "As an optimization, as soon as R gets L's check message, R schedules a connectivity-check message to be sent to L on the same candidate pair. This is called a \"triggered check\", and it accelerates the process of finding valid pairs.",
      "ja": "最適化として、RはLのチェックメッセージを取得するとすぐに、接続候補チェックメッセージが同じ候補ペアのLに送信されるようにスケジュールします。 これは「トリガーチェック」と呼ばれ、有効なペアを見つけるプロセスを高速化します。"
    },
    {
      "indent": 3,
      "text": "At the end of this handshake, both L and R know that they can send (and receive) messages end to end in both directions.",
      "ja": "このハンドシェイクの終わりに、LとRは両方ともメッセージをエンドツーエンドで双方向に送信（および受信）できることを認識します。"
    },
    {
      "indent": 3,
      "text": "In general, the priority algorithm is designed so that candidates of a similar type get similar priorities so that more direct routes (that is, routes without data relays or NATs) are preferred over indirect routes (routes with data relays or NATs). Within those guidelines, however, agents have a fair amount of discretion about how to tune their algorithms.",
      "ja": "一般に、優先度アルゴリズムは、同様のタイプの候補が同様の優先度を取得するように設計されているため、より直接的なルート（つまり、データリレーまたはNATのないルート）が間接ルート（データリレーまたはNATのあるルート）よりも優先されます。 ただし、これらのガイドラインでは、エージェントはアルゴリズムの調整方法についてかなりの裁量権を持っています。"
    },
    {
      "indent": 3,
      "text": "A data stream might consist of multiple components (pieces of a data stream that require their own set of candidates, e.g., RTP and RTCP).",
      "ja": "データストリームは、複数のコンポーネント（RTPやRTCPなどの独自の候補セットを必要とするデータストリームの一部）で構成される場合があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Nominating Candidate Pairs and Concluding ICE",
      "section_title": true,
      "ja": "2.3.  候補ペアの指名とICEの終了"
    },
    {
      "indent": 3,
      "text": "ICE assigns one of the ICE agents in the role of the controlling agent, and the other in the role of the controlled agent. For each component of a data stream, the controlling agent nominates a valid pair (from the valid list) to be used for data. The exact timing of the nomination is based on local policy.",
      "ja": "ICEは、一方のICEエージェントを制御エージェントの役割に割り当て、もう一方を制御エージェントの役割に割り当てます。 データストリームの各コンポーネントに対して、制御エージェントはデータに使用する有効なペア（有効なリストから）を指定します。 指名の正確なタイミングは、ローカルポリシーに基づいています。"
    },
    {
      "indent": 3,
      "text": "When nominating, the controlling agent lets the checks continue until at least one valid pair for each component of a data stream is found, and then it picks a valid pair and sends a STUN request on that pair, using an attribute to indicate to the controlled peer that it has been nominated. This is shown in Figure 4.",
      "ja": "指名するとき、制御エージェントは、データストリームの各コンポーネントの少なくとも1つの有効なペアが見つかるまでチェックを続行させ、次に有効なペアを選択し、そのペアに対してSTUN要求を送信します。 ノミネートされたピア。 これを図4に示します。"
    },
    {
      "indent": 13,
      "text": "L                        R\n-                        -\nSTUN request ->             \\  L's\n          <- STUN response  /  check",
      "raw": true
    },
    {
      "indent": 13,
      "text": " <- STUN request \\ R's STUN response -> / check",
      "ja": "<-STUNリクエスト\\ RのSTUNレスポンス-> /チェック"
    },
    {
      "indent": 13,
      "text": "STUN request + attribute -> \\ L's <- STUN response / check",
      "ja": "STUNリクエスト+属性-> \\ Lの<-STUNレスポンス/チェック"
    },
    {
      "indent": 27,
      "text": "Figure 4: Nomination",
      "ja": "図4：ノミネート"
    },
    {
      "indent": 3,
      "text": "Once the controlled agent receives the STUN request with the attribute, it will check (unless the check has already been done) the same pair. If the transactions above succeed, the agents will set the nominated flag for the pairs and will cancel any future checks for that component of the data stream. Once an agent has set the nominated flag for each component of a data stream, the pairs become the selected pairs. After that, only the selected pairs will be used for sending and receiving data associated with that data stream.",
      "ja": "制御されたエージェントは、属性付きのSTUN要求を受信すると、同じペアをチェックします（チェックがまだ実行されていない場合）。 上記のトランザクションが成功すると、エージェントはペアに指定されたフラグを設定し、データストリームのそのコンポーネントの今後のチェックをキャンセルします。 エージェントがデータストリームの各コンポーネントに指定フラグを設定すると、ペアが選択されたペアになります。 その後、選択したペアのみが、そのデータストリームに関連付けられたデータの送受信に使用されます。"
    },
    {
      "indent": 0,
      "text": "2.4. ICE Restart",
      "section_title": true,
      "ja": "2.4.  ICE再起動"
    },
    {
      "indent": 3,
      "text": "Once ICE is concluded, it can be restarted at any time for one or all of the data streams by either ICE agent. This is done by sending updated candidate information indicating a restart.",
      "ja": "ICEが終了すると、いずれかのICEエージェントがいつでも1つまたはすべてのデータストリームに対してICEを再起動できます。 これは、再起動を示す更新された候補情報を送信することにより行われます。"
    },
    {
      "indent": 0,
      "text": "2.5. Lite Implementations",
      "section_title": true,
      "ja": "2.5.  Liteの実装"
    },
    {
      "indent": 3,
      "text": "Certain ICE agents will always be connected to the public Internet and have a public IP address at which it can receive packets from any correspondent. To make it easier for these devices to support ICE, ICE defines a special type of implementation called \"lite\" (in contrast to the normal full implementation). Lite agents only use host candidates and do not generate connectivity checks or run state machines, though they need to be able to respond to connectivity checks.",
      "ja": "特定のICEエージェントは常にパブリックインターネットに接続され、通信員からパケットを受信できるパブリックIPアドレスを持ちます。 これらのデバイスがICEをサポートしやすくするために、ICEでは「lite」と呼ばれる特別なタイプの実装を定義しています（通常の完全な実装とは対照的です）。 Liteエージェントは、ホスト候補のみを使用し、接続チェックを生成したり、状態マシンを実行したりしませんが、接続チェックに応答できる必要があります。"
    },
    {
      "indent": 0,
      "text": "3. ICE Usage",
      "section_title": true,
      "ja": "3. ICEの使用"
    },
    {
      "indent": 3,
      "text": "This document specifies generic use of ICE with protocols that provide means to exchange candidate information between ICE agents. The specific details (i.e., how to encode candidate information and the actual candidate exchange process) for different protocols using ICE (referred to as \"using protocol\") are described in separate usage documents.",
      "ja": "このドキュメントは、ICEエージェント間で候補者情報を交換する手段を提供するプロトコルでICEの一般的な使用を指定します。 ICEを使用するさまざまなプロトコル（「プロトコルを使用する」と呼ばれる）の特定の詳細（つまり、候補情報と実際の候補交換プロセスをエンコードする方法）は、個別の使用ドキュメントに記載されています。"
    },
    {
      "indent": 3,
      "text": "One mechanism that allows agents to exchange candidate information is the utilization of Offer/Answer semantics (which are based on [RFC3264]) as part of the SIP protocol [RFC3261] [ICE-SIP-SDP].",
      "ja": "エージェントが候補情報を交換できるようにする1つのメカニズムは、SIPプロトコル[RFC3261] [ICE-SIP-SDP]の一部としてのOffer / Answerセマンティクス（[RFC3264]に基づく）の利用です。"
    },
    {
      "indent": 3,
      "text": "[RFC7825] defines an ICE usage for the Real-Time Streaming Protocol (RTSP). Note, however, that the ICE usage is based on RFC 5245.",
      "ja": "[RFC7825]は、リアルタイムストリーミングプロトコル（RTSP）のICE使用法を定義しています。 ただし、ICEの使用はRFC 5245に基づいていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4. Terminology",
      "section_title": true,
      "ja": "4.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "Readers need to be familiar with the terminology defined in [RFC5389] and NAT Behavioral requirements for UDP [RFC4787].",
      "ja": "読者は、[RFC5389]で定義されている用語とUDPのNAT動作要件[RFC4787]に精通している必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification makes use of the following additional terminology:",
      "ja": "この仕様では、次の追加の用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "ICE Session: An ICE session consists of all ICE-related actions starting with the candidate gathering, followed by the interactions (candidate exchange, connectivity checks, nominations, and keepalives) between the ICE agents until all the candidates are released or an ICE restart is triggered.",
      "ja": "ICEセッション：ICEセッションは、候補者の収集から始まり、すべての候補者が解放されるか、ICEの再起動が完了するまで、ICEエージェント間の相互作用（候補交換、接続チェック、指名、およびキープアライブ）が続くすべてのICE関連アクションで構成されます トリガーされます。"
    },
    {
      "indent": 3,
      "text": "ICE Agent, Agent: An ICE agent (sometimes simply referred to as an \"agent\") is the protocol implementation involved in the ICE candidate exchange. There are two agents involved in a typical candidate exchange.",
      "ja": "ICEエージェント、エージェント：ICEエージェント（単に「エージェント」と呼ばれることもあります）は、ICE候補交換に関係するプロトコル実装です。 一般的な候補者の交換には2つのエージェントが関与します。"
    },
    {
      "indent": 3,
      "text": "Initiating Peer, Initiating Agent, Initiator: An initiating agent is an ICE agent that initiates the ICE candidate exchange process.",
      "ja": "開始ピア、開始エージェント、開始者：開始エージェントは、ICE候補交換プロセスを開始するICEエージェントです。"
    },
    {
      "indent": 3,
      "text": "Responding Peer, Responding Agent, Responder: A responding agent is an ICE agent that receives and responds to the candidate exchange process initiated by the initiating agent.",
      "ja": "応答ピア、応答エージェント、応答者：応答エージェントは、開始エージェントによって開始された候補交換プロセスを受信して応答するICEエージェントです。"
    },
    {
      "indent": 3,
      "text": "ICE Candidate Exchange, Candidate Exchange: The process where ICE agents exchange information (e.g., candidates and passwords) that is needed to perform ICE. Offer/Answer with SDP encoding [RFC3264] is one example of a protocol that can be used for exchanging the candidate information.",
      "ja": "ICE Candidate Exchange、Candidate Exchange：ICEエージェントが、ICEを実行するために必要な情報（候補者やパスワードなど）を交換するプロセス。 SDPエンコーディング[RFC3264]によるオファー/アンサーは、候補情報の交換に使用できるプロトコルの一例です。"
    },
    {
      "indent": 3,
      "text": "Peer: From the perspective of one of the ICE agents in a session, its peer is the other agent. Specifically, from the perspective of the initiating agent, the peer is the responding agent. From the perspective of the responding agent, the peer is the initiating agent.",
      "ja": "ピア：セッション内のICEエージェントの1つから見ると、そのピアは他のエージェントです。 具体的には、開始エージェントの観点から、ピアは応答エージェントです。 応答エージェントの観点から見ると、ピアは開始エージェントです。"
    },
    {
      "indent": 3,
      "text": "Transport Address: The combination of an IP address and the transport protocol (such as UDP or TCP) port.",
      "ja": "トランスポートアドレス：IPアドレスとトランスポートプロトコル（UDPやTCPなど）ポートの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Data, Data Stream, Data Session: When ICE is used to set up data sessions, the data is transported using some protocol. Media is usually transported over RTP, composed of a stream of RTP packets. Data session refers to data packets that are exchanged between the peer on the path created and tested with ICE.",
      "ja": "データ、データストリーム、データセッション：ICEを使用してデータセッションを設定する場合、データは何らかのプロトコルを使用して転送されます。 メディアは通常、RTPパケットのストリームで構成されるRTPを介して転送されます。 データセッションとは、ICEで作成およびテストされたパス上のピア間で交換されるデータパケットのことです。"
    },
    {
      "indent": 3,
      "text": "Candidate, Candidate Information: A transport address that is a potential point of contact for receipt of data. Candidates also have properties -- their type (server reflexive, relayed, or host), priority, foundation, and base.",
      "ja": "候補者、候補者情報：データを受信するための潜在的な連絡先となるトランスポートアドレス。 候補には、プロパティ（タイプ（サーバー反射、リレー、またはホスト）、優先度、基盤、およびベース）もあります。"
    },
    {
      "indent": 3,
      "text": "Component: A component is a piece of a data stream. A data stream may require multiple components, each of which has to work in order for the data stream as a whole to work. For RTP/RTCP data streams, unless RTP and RTCP are multiplexed in the same port, there are two components per data stream -- one for RTP, and one for RTCP. A component has a candidate pair, which cannot be used by other components.",
      "ja": "コンポーネント：コンポーネントは、データストリームの一部です。 データストリームには複数のコンポーネントが必要な場合があり、各コンポーネントはデータストリーム全体が機能するために機能する必要があります。 RTP / RTCPデータストリームの場合、RTPとRTCPが同じポートで多重化されていない限り、データストリームごとに2つのコンポーネントがあります。1つはRTP用で、もう1つはRTCP用です。 コンポーネントには候補ペアがあり、他のコンポーネントでは使用できません。"
    },
    {
      "indent": 3,
      "text": "Host Candidate: A candidate obtained by binding to a specific port from an IP address on the host. This includes IP addresses on physical interfaces and logical ones, such as ones obtained through VPNs.",
      "ja": "ホスト候補：ホスト上のIPアドレスから特定のポートにバインドすることによって取得された候補。 これには、物理インターフェイス上のIPアドレスと、VPNを介して取得したものなどの論理インターフェイス上のIPアドレスが含まれます。"
    },
    {
      "indent": 3,
      "text": "Server-Reflexive Candidate: A candidate whose IP address and port are a binding allocated by a NAT for an ICE agent after it sends a packet through the NAT to a server, such as a STUN server.",
      "ja": "Server-Reflexive Candidate：IPアドレスとポートが、NATを介してSTUNサーバーなどのサーバーにパケットを送信した後、NATによってICEエージェントに割り当てられたバインディングである候補。"
    },
    {
      "indent": 3,
      "text": "Peer-Reflexive Candidate: A candidate whose IP address and port are a binding allocated by a NAT for an ICE agent after it sends a packet through the NAT to its peer.",
      "ja": "Peer-Reflexive Candidate：IPアドレスとポートが、NATを介してピアにパケットを送信した後、NATがICEエージェントに割り当てたバインディングである候補。"
    },
    {
      "indent": 3,
      "text": "Relayed Candidate: A candidate obtained from a relay server, such as a TURN server.",
      "ja": "リレー候補：TURNサーバーなどのリレーサーバーから取得した候補。"
    },
    {
      "indent": 3,
      "text": "Base: The transport address that an ICE agent sends from for a particular candidate. For host, server-reflexive, and peer-reflexive candidates, the base is the same as the host candidate. For relayed candidates, the base is the same as the relayed candidate (i.e., the transport address used by the TURN server to send from).",
      "ja": "ベース：ICEエージェントが特定の候補者に送信するトランスポートアドレス。 ホスト、サーバー反射、およびピア反射候補の場合、ベースはホスト候補と同じです。 リレー候補の場合、ベースはリレー候補と同じです（つまり、TURNサーバーが送信元として使用するトランスポートアドレス）。"
    },
    {
      "indent": 3,
      "text": "Related Address and Port: A transport address related to a candidate, which is useful for diagnostics and other purposes. If a candidate is server or peer reflexive, the related address and port is equal to the base for that server or peer-reflexive candidate. If the candidate is relayed, the related address and port are equal to the mapped address in the Allocate response that provided the client with that relayed candidate. If the candidate is a host candidate, the related address and port is identical to the host candidate.",
      "ja": "関連アドレスおよびポート：候補者に関連するトランスポートアドレス。診断およびその他の目的に役立ちます。 候補がサーバーまたはピアの再帰候補である場合、関連するアドレスとポートは、そのサーバーまたはピアの再帰候補のベースと等しくなります。 候補が中継される場合、関連するアドレスとポートは、その中継された候補をクライアントに提供したAllocate応答のマッピングアドレスに等しくなります。 候補がホスト候補である場合、関連するアドレスとポートはホスト候補と同一です。"
    },
    {
      "indent": 3,
      "text": "Foundation: An arbitrary string used in the freezing algorithm to group similar candidates. It is the same for two candidates that have the same type, base IP address, protocol (UDP, TCP, etc.), and STUN or TURN server. If any of these are different, then the foundation will be different.",
      "ja": "基盤：同様の候補をグループ化するためにフリーズアルゴリズムで使用される任意の文字列。 同じタイプ、ベースIPアドレス、プロトコル（UDP、TCPなど）、およびSTUNまたはTURNサーバーを持つ2つの候補についても同じです。 これらのいずれかが異なる場合、基盤は異なります。"
    },
    {
      "indent": 3,
      "text": "Local Candidate: A candidate that an ICE agent has obtained and may send to its peer.",
      "ja": "ローカル候補：ICEエージェントが取得し、ピアに送信する可能性のある候補。"
    },
    {
      "indent": 3,
      "text": "Remote Candidate: A candidate that an ICE agent received from its peer.",
      "ja": "リモート候補：ICEエージェントがピアから受け取った候補。"
    },
    {
      "indent": 3,
      "text": "Default Destination/Candidate: The default destination for a component of a data stream is the transport address that would be used by an ICE agent that is not ICE aware. A default candidate for a component is one whose transport address matches the default destination for that component.",
      "ja": "デフォルトの宛先/候補：データストリームのコンポーネントのデフォルトの宛先は、ICE対応でないICEエージェントが使用するトランスポートアドレスです。 コンポーネントのデフォルトの候補は、トランスポートアドレスがそのコンポーネントのデフォルトの宛先と一致するものです。"
    },
    {
      "indent": 3,
      "text": "Candidate Pair: A pair containing a local candidate and a remote candidate.",
      "ja": "候補ペア：ローカル候補とリモート候補を含むペア。"
    },
    {
      "indent": 3,
      "text": "Check, Connectivity Check, STUN Check: A STUN Binding request for the purpose of verifying connectivity. A check is sent from the base of the local candidate to the remote candidate of a candidate pair.",
      "ja": "チェック、接続性チェック、STUNチェック：接続性を検証するためのSTUNバインディング要求。 候補ペアのローカル候補のベースからリモート候補にチェックが送信されます。"
    },
    {
      "indent": 3,
      "text": "Checklist: An ordered set of candidate pairs that an ICE agent will use to generate checks.",
      "ja": "チェックリスト：ICEエージェントがチェックを生成するために使用する順序付けられた候補ペアのセット。"
    },
    {
      "indent": 3,
      "text": "Ordinary Check: A connectivity check generated by an ICE agent as a consequence of a timer that fires periodically, instructing it to send a check.",
      "ja": "通常のチェック：定期的に起動するタイマーの結果としてICEエージェントによって生成される接続チェックで、チェックを送信するように指示します。"
    },
    {
      "indent": 3,
      "text": "Triggered Check: A connectivity check generated as a consequence of the receipt of a connectivity check from the peer.",
      "ja": "トリガーチェック：ピアからの接続チェックの受信の結果として生成された接続チェック。"
    },
    {
      "indent": 3,
      "text": "Valid Pair: A candidate pair whose local candidate equals the mapped address of a successful connectivity-check response and whose remote candidate equals the destination address to which the connectivity-check request was sent.",
      "ja": "有効なペア：ローカル候補が正常な接続チェック応答のマッピングアドレスに等しく、リモート候補が接続チェック要求が送信された宛先アドレスに等しい候補ペア。"
    },
    {
      "indent": 3,
      "text": "Valid List: An ordered set of candidate pairs for a data stream that have been validated by a successful STUN transaction.",
      "ja": "有効なリスト：成功したSTUNトランザクションによって検証された、データストリームの候補ペアの順序付きセット。"
    },
    {
      "indent": 3,
      "text": "Checklist Set: The ordered list of all checklists. The order is determined by each ICE usage.",
      "ja": "チェックリストセット：すべてのチェックリストの順序付きリスト。 順序は、ICEの使用ごとに決定されます。"
    },
    {
      "indent": 3,
      "text": "Full Implementation: An ICE implementation that performs the complete set of functionality defined by this specification.",
      "ja": "完全な実装：この仕様で定義されている機能の完全なセットを実行するICE実装。"
    },
    {
      "indent": 3,
      "text": "Lite Implementation: An ICE implementation that omits certain functions, implementing only as much as is necessary for a peer that is not a lite implementation to gain the benefits of ICE. Lite implementations do not maintain any of the state machines and do not generate connectivity checks.",
      "ja": "Lite実装：特定の機能を省略し、Lite実装ではないピアがICEの利点を得るために必要なだけ実装するICE実装。 Liteの実装では、ステートマシンは保持されず、接続性チェックは生成されません。"
    },
    {
      "indent": 3,
      "text": "Controlling Agent: The ICE agent that nominates a candidate pair. In any session, there is always one controlling agent and one controlled agent.",
      "ja": "制御エージェント：候補ペアを指名するICEエージェント。 どのセッションでも、常に1つの制御エージェントと1つの制御エージェントが存在します。"
    },
    {
      "indent": 3,
      "text": "Controlled Agent: The ICE agent that waits for the controlling agent to nominate a candidate pair.",
      "ja": "管理エージェント：管理エージェントが候補ペアを指名するのを待つICEエージェント。"
    },
    {
      "indent": 3,
      "text": "Nomination: The process of the controlling agent indicating to the controlled agent which candidate pair the ICE agents will use for sending and receiving data. The nomination process defined in this specification was referred to as \"regular nomination\" in RFC 5245. The nomination process that was referred to as \"aggressive nomination\" in RFC 5245 has been deprecated in this specification.",
      "ja": "指名：ICEエージェントがデータの送受信に使用する候補ペアを制御エージェントに示す制御エージェントのプロセス。 この仕様で定義された指名プロセスは、RFC 5245で「通常の指名」と呼ばれました。RFC5245で「積極的な指名」と呼ばれた指名プロセスは、この仕様で非推奨になりました。"
    },
    {
      "indent": 3,
      "text": "Nominated, Nominated Flag: Once the nomination of a candidate pair has succeeded, the candidate pair has become nominated, and the value of its nominated flag is set to true.",
      "ja": "ノミネート、ノミネートフラグ：候補ペアのノミネートが成功すると、候補ペアがノミネートされ、そのノミネートフラグの値がtrueに設定されます。"
    },
    {
      "indent": 3,
      "text": "Selected Pair, Selected Candidate Pair: The candidate pair used for sending and receiving data for a component of a data stream is referred to as the \"selected pair\". Before selected pairs have been produced for a data stream, any valid pair associated with a component of a data stream can be used for sending and receiving data for the component. Once there are nominated pairs for each component of a data stream, the nominated pairs become the selected pairs for the data stream. The candidates associated with the selected pairs are referred to as \"selected candidates\".",
      "ja": "選択されたペア、選択された候補ペア：データストリームのコンポーネントのデータを送受信するために使用される候補ペアは、「選択されたペア」と呼ばれます。 データストリームに対して選択されたペアが生成される前に、データストリームのコンポーネントに関連付けられた有効なペアを使用して、コンポーネントのデータを送受信できます。 データストリームの各コンポーネントに指定されたペアがあると、指定されたペアがデータストリームの選択されたペアになります。 選択されたペアに関連付けられた候補は、「選択された候補」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Using Protocol, ICE Usage: The protocol that uses ICE for NAT traversal. A usage specification defines the protocol-specific details on how the procedures defined here are applied to that protocol.",
      "ja": "プロトコルの使用、ICE使用法：NATトラバーサルにICEを使用するプロトコル。 使用仕様は、ここで定義された手順がそのプロトコルに適用される方法に関するプロトコル固有の詳細を定義します。"
    },
    {
      "indent": 3,
      "text": "Timer Ta: The timer for generating new STUN or TURN transactions.",
      "ja": "タイマーTa：新しいSTUNまたはTURNトランザクションを生成するためのタイマー。"
    },
    {
      "indent": 3,
      "text": "Timer RTO (Retransmission Timeout): The retransmission timer for a given STUN or TURN transaction.",
      "ja": "タイマーRTO（再送信タイムアウト）：特定のSTUNまたはTURNトランザクションの再送信タイマー。"
    },
    {
      "indent": 0,
      "text": "5. ICE Candidate Gathering and Exchange",
      "section_title": true,
      "ja": "5. ICE候補者の収集と交換"
    },
    {
      "indent": 3,
      "text": "As part of ICE processing, both the initiating and responding agents gather candidates, prioritize and eliminate redundant candidates, and exchange candidate information with the peer as defined by the using protocol (ICE usage). Specifics of the candidate-encoding mechanism and the semantics of candidate information exchange is out of scope of this specification.",
      "ja": "ICE処理の一部として、開始エージェントと応答エージェントの両方が候補を収集し、冗長な候補に優先順位を付けて削除し、使用プロトコル（ICE使用法）で定義されたピアと候補情報を交換します。 候補エンコードメカニズムの詳細と候補情報交換のセマンティクスは、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "5.1. Full Implementation",
      "section_title": true,
      "ja": "5.1.  完全実装"
    },
    {
      "indent": 0,
      "text": "5.1.1. Gathering Candidates",
      "section_title": true,
      "ja": "5.1.1.  候補者の収集"
    },
    {
      "indent": 3,
      "text": "An ICE agent gathers candidates when it believes that communication is imminent. An initiating agent can do this based on a user interface cue or on an explicit request to initiate a session. Every candidate has a transport address. It also has a type and a base. Four types are defined and gathered by this specification -- host candidates, server-reflexive candidates, peer-reflexive candidates, and relayed candidates. The server-reflexive candidates are gathered using STUN or TURN, and relayed candidates are obtained through TURN. Peer-reflexive candidates are obtained in later phases of ICE, as a consequence of connectivity checks.",
      "ja": "ICEエージェントは、コミュニケーションが差し迫っていると考えたときに候補者を集めます。 開始エージェントは、ユーザーインターフェイスキューまたはセッションを開始する明示的な要求に基づいてこれを実行できます。 すべての候補者にはトランスポートアドレスがあります。 タイプとベースもあります。 この仕様では、ホスト候補、サーバー反射候補、ピア反射候補、およびリレー候補の4つのタイプが定義および収集されます。 サーバー反射候補はSTUNまたはTURNを使用して収集され、中継された候補はTURNを介して取得されます。 ピア反射候補は、接続性チェックの結果として、ICEの後期段階で取得されます。"
    },
    {
      "indent": 3,
      "text": "The process for gathering candidates at the responding agent is identical to the process for the initiating agent. It is RECOMMENDED that the responding agent begin this process immediately on receipt of the candidate information, prior to alerting the user of the application associated with the ICE session.",
      "ja": "応答エージェントで候補を収集するプロセスは、開始エージェントのプロセスと同じです。 ICEセッションに関連付けられたアプリケーションのユーザーに警告する前に、応答エージェントが候補情報を受信するとすぐにこのプロセスを開始することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. Host Candidates",
      "section_title": true,
      "ja": "5.1.1.1。 ホスト候補者"
    },
    {
      "indent": 3,
      "text": "Host candidates are obtained by binding to ports on an IP address attached to an interface (physical or virtual, including VPN interfaces) on the host.",
      "ja": "ホスト候補は、ホスト上のインターフェイス（VPNインターフェイスを含む物理または仮想）に接続されたIPアドレスのポートにバインドすることにより取得されます。"
    },
    {
      "indent": 3,
      "text": "For each component of each data stream the ICE agent wishes to use, the agent SHOULD obtain a candidate on each IP address that the host has, with the exceptions listed below. The agent obtains each candidate by binding to a UDP port on the specific IP address. A host candidate (and indeed every candidate) is always associated with a specific component for which it is a candidate.",
      "ja": "ICEエージェントが使用する各データストリームの各コンポーネントについて、エージェントは、ホストが持つ各IPアドレスの候補を取得する必要があります（例外は以下にリストされています）。 エージェントは、特定のIPアドレスのUDPポートにバインドすることにより、各候補を取得します。 ホスト候補（および実際にはすべての候補）は、常に候補である特定のコンポーネントに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Each component has an ID assigned to it, called the \"component ID\". For RTP/RTCP data streams, unless both RTP and RTCP are multiplexed in the same UDP port (RTP/RTCP multiplexing), the RTP itself has a component ID of 1, and RTCP has a component ID of 2. In case of RTP/ RTCP multiplexing, a component ID of 1 is used for both RTP and RTCP.",
      "ja": "各コンポーネントには、「コンポーネントID」と呼ばれるIDが割り当てられています。 RTP / RTCPデータストリームの場合、RTPとRTCPの両方が同じUDPポートで多重化されていない限り（RTP / RTCP多重化）、RTP自体のコンポーネントIDは1で、RTCPのコンポーネントIDは2です。RTP/ RTCP多重化、コンポーネントID 1はRTPとRTCPの両方に使用されます。"
    },
    {
      "indent": 3,
      "text": "When candidates are obtained, unless the agent knows for sure that RTP/RTCP multiplexing will be used (i.e., the agent knows that the other agent also supports, and is willing to use, RTP/RTCP multiplexing), or unless the agent only supports RTP/RTCP multiplexing, the agent MUST obtain a separate candidate for RTCP. If an agent has obtained a candidate for RTCP, and ends up using RTP/ RTCP multiplexing, the agent does not need to perform connectivity checks on the RTCP candidate. Absence of a component ID 2 as such does not imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is not used.",
      "ja": "RTP / RTCP多重化が使用されることをエージェントが確実に知っている場合（つまり、エージェントが他のエージェントもRTP / RTCP多重化をサポートしており、使用する意思があることを知っている場合） RTP / RTCP多重化、エージェントはRTCPの個別の候補を取得しなければなりません。 エージェントがRTCPの候補を取得し、RTP / RTCP多重化を使用することになった場合、エージェントはRTCP候補で接続性チェックを実行する必要はありません。 コンポーネントID 2の不在は、RTCP / RTP多重化の使用を意味しません。これは、RTCPが使用されていないことも意味する可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "If an agent is using separate candidates for RTP and RTCP, it will end up with 2*K host candidates if an agent has K IP addresses.",
      "ja": "エージェントがRTPとRTCPの個別の候補を使用している場合、エージェントがK個のIPアドレスを持っていると、2 * K個のホスト候補になります。"
    },
    {
      "indent": 3,
      "text": "Note that the responding agent, when obtaining its candidates, will typically know if the other agent supports RTP/RTCP multiplexing, in which case it will not need to obtain a separate candidate for RTCP. However, absence of a component ID 2 as such does not imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is not used.",
      "ja": "応答エージェントは、候補を取得するときに、通常、他のエージェントがRTP / RTCP多重化をサポートしているかどうかを知っていることに注意してください。この場合、RTCPの個別の候補を取得する必要はありません。 ただし、コンポーネントID 2が存在しないことは、RTCP / RTP多重化の使用を意味しません。これは、RTCPが使用されないことも意味する可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "The use of multiple components, other than for RTP/RTCP streams, is discouraged as it increases the complexity of ICE processing. If multiple components are needed, the component IDs SHOULD start with 1 and increase by 1 for each component.",
      "ja": "RTP / RTCPストリーム以外の複数のコンポーネントの使用は、ICE処理の複雑さを増すため推奨されません。 複数のコンポーネントが必要な場合、コンポーネントIDは1から始まり、コンポーネントごとに1ずつ増加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The base for each host candidate is set to the candidate itself.",
      "ja": "各ホスト候補のベースは、候補自体に設定されます。"
    },
    {
      "indent": 3,
      "text": "The host candidates are gathered from all IP addresses with the following exceptions:",
      "ja": "ホスト候補は、次の例外を除き、すべてのIPアドレスから収集されます。"
    },
    {
      "indent": 3,
      "text": "o Addresses from a loopback interface MUST NOT be included in the candidate addresses.",
      "ja": "oループバックインターフェイスからのアドレスを候補アドレスに含めてはいけません。"
    },
    {
      "indent": 3,
      "text": "o Deprecated IPv4-compatible IPv6 addresses [RFC4291] and IPv6 site-local unicast addresses [RFC3879] MUST NOT be included in the address candidates.",
      "ja": "o非推奨のIPv4互換IPv6アドレス[RFC4291]およびIPv6サイトローカルユニキャストアドレス[RFC3879]は、アドレス候補に含めてはいけません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o IPv4-mapped IPv6 addresses SHOULD NOT be included in the address candidates unless the application using ICE does not support IPv4 (i.e., it is an IPv6-only application [RFC4038]).",
      "ja": "o ICEを使用するアプリケーションがIPv4をサポートしない場合（つまり、IPv6専用アプリケーション[RFC4038]）を除き、IPv4-mapped IPv6アドレスをアドレス候補に含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o If gathering one or more host candidates that correspond to an IPv6 address that was generated using a mechanism that prevents location tracking [RFC7721], host candidates that correspond to IPv6 addresses that do allow location tracking, are configured on the same interface, and are part of the same network prefix MUST NOT be gathered. Similarly, when host candidates corresponding to an IPv6 address generated using a mechanism that prevents location tracking are gathered, then host candidates corresponding to IPv6 link-local addresses [RFC4291] MUST NOT be gathered.",
      "ja": "o位置追跡を防止するメカニズムを使用して生成されたIPv6アドレスに対応する1つ以上のホスト候補を収集する場合[RFC7721]、位置追跡を許可するIPv6アドレスに対応するホスト候補は、同じインターフェースで構成され、 同じネットワークプレフィックスの一部を収集してはなりません。 同様に、位置追跡を妨げるメカニズムを使用して生成されたIPv6アドレスに対応するホスト候補が収集される場合、IPv6リンクローカルアドレス[RFC4291]に対応するホスト候補を収集してはなりません。"
    },
    {
      "indent": 3,
      "text": "The IPv6 default address selection specification [RFC6724] specifies that temporary addresses [RFC4941] are to be preferred over permanent addresses.",
      "ja": "IPv6デフォルトアドレス選択仕様[RFC6724]は、一時アドレス[RFC4941]が永続アドレスよりも優先されることを指定しています。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. Server-Reflexive and Relayed Candidates",
      "section_title": true,
      "ja": "5.1.1.2。 サーバー反射およびリレー候補"
    },
    {
      "indent": 3,
      "text": "An ICE agent SHOULD gather server-reflexive and relayed candidates. However, use of STUN and TURN servers may be unnecessary in certain networks and use of TURN servers may be expensive, so some deployments may elect not to use them. If an agent does not gather server-reflexive or relayed candidates, it is RECOMMENDED that the functionality be implemented and just disabled through configuration, so that it can be re-enabled through configuration if conditions change in the future.",
      "ja": "ICEエージェントは、サーバー反射型およびリレー型の候補者を収集する必要があります。 ただし、特定のネットワークではSTUNおよびTURNサーバーを使用する必要がない場合があり、TURNサーバーを使用すると高価になる場合があるため、一部の展開ではそれらを使用しないことを選択する場合があります。 エージェントがサーバー反射候補またはリレー候補を収集しない場合は、機能が実装され、構成によって無効にされることが推奨されます。これにより、将来条件が変更された場合に構成によって再度有効にできます。"
    },
    {
      "indent": 3,
      "text": "The agent pairs each host candidate with the STUN or TURN servers with which it is configured or has discovered by some means. It is RECOMMENDED that a domain name be configured, the DNS procedures in [RFC5389] (using SRV records with the \"stun\" service) be used to discover the STUN server, and the DNS procedures in [RFC5766] (using SRV records with the \"turn\" service) be used to discover the TURN server.",
      "ja": "エージェントは、各ホスト候補と、STUNまたはTURNサーバーとをペアリングします。STUNまたはTURNサーバーは、何らかの方法で構成または検出されています。 ドメイン名を設定し、[RFC5389]のDNSプロシージャ（「stun」サービスでSRVレコードを使用）を使用してSTUNサーバーを検出し、[RFC5766]のDNSプロシージャ（SRVレコードを使用して 「turn」サービス）を使用して、TURNサーバーを検出します。"
    },
    {
      "indent": 3,
      "text": "When multiple STUN or TURN servers are available (or when they are learned through DNS records and multiple results are returned), the agent MAY gather candidates for all of them and SHOULD gather candidates for at least one of them (one STUN server and one TURN server). It does so by pairing host candidates with STUN or TURN servers, and for each pair, the agent sends a Binding or Allocate request to the server from the host candidate. Binding requests to a STUN server are not authenticated, and any ALTERNATE-SERVER attribute in a response is ignored. Agents MUST support the backwards-compatibility mode for the Binding request defined in [RFC5389]. Allocate requests SHOULD be authenticated using a long-term credential obtained by the client through some other means.",
      "ja": "複数のSTUNまたはTURNサーバーが利用可能な場合（またはDNSレコードを介してそれらが学習され、複数の結果が返される場合）、エージェントはそれらすべての候補を収集し、少なくとも1つ（1つのSTUNサーバーと1つのTURN サーバ）。 ホスト候補をSTUNまたはTURNサーバーとペアリングすることにより、各ペアに対して、エージェントがホスト候補からサーバーにバインディングまたは割り当て要求を送信します。 STUNサーバーへのバインド要求は認証されず、応答のALTERNATE-SERVER属性は無視されます。 エージェントは、[RFC5389]で定義されたBinding要求の後方互換性モードをサポートしなければなりません。 リクエストの割り当ては、クライアントが他の方法で取得した長期の認証情報を使用して認証される必要があります。"
    },
    {
      "indent": 3,
      "text": "The gathering process is controlled using a timer, Ta. Every time Ta expires, the agent can generate another new STUN or TURN transaction. This transaction can be either a retry of a previous transaction that failed with a recoverable error (such as authentication failure) or a transaction for a new host candidate and STUN or TURN server pair. The agent SHOULD NOT generate transactions more frequently than once per each ta expiration. See Section 14 for guidance on how to set Ta and the STUN retransmit timer, RTO.",
      "ja": "収集プロセスは、タイマーTaを使用して制御されます。 Taが期限切れになるたびに、エージェントは別の新しいSTUNまたはTURNトランザクションを生成できます。 このトランザクションは、回復可能なエラー（認証の失敗など）で失敗した以前のトランザクションの再試行、または新しいホスト候補とSTUNまたはTURNサーバーのペアのトランザクションのいずれかです。 エージェントは、有効期限ごとに1回よりも頻繁にトランザクションを生成すべきではありません。 TaおよびSTUN再送信タイマー、RTOの設定方法に関するガイダンスについては、セクション14を参照してください。"
    },
    {
      "indent": 3,
      "text": "The agent will receive a Binding or Allocate response. A successful Allocate response will provide the agent with a server-reflexive candidate (obtained from the mapped address) and a relayed candidate in the XOR-RELAYED-ADDRESS attribute. If the Allocate request is rejected because the server lacks resources to fulfill it, the agent SHOULD instead send a Binding request to obtain a server-reflexive candidate. A Binding response will provide the agent with only a server-reflexive candidate (also obtained from the mapped address). The base of the server-reflexive candidate is the host candidate from which the Allocate or Binding request was sent. The base of a relayed candidate is that candidate itself. If a relayed candidate is identical to a host candidate (which can happen in rare cases), the relayed candidate MUST be discarded.",
      "ja": "エージェントは、BindingまたはAllocate応答を受け取ります。 Allocate応答が成功すると、エージェントにサーバー反射候補（マップされたアドレスから取得）とXOR-RELAYED-ADDRESS属性のリレー候補が提供されます。 サーバーがそれを満たすためのリソースが不足しているために割り当て要求が拒否された場合、エージェントは代わりにバインディング要求を送信してサーバー反射候補を取得する必要があります。 バインディング応答は、エージェントにサーバー反射候補のみを提供します（マッピングされたアドレスからも取得されます）。 サーバー反射候補のベースは、割り当て要求またはバインド要求の送信元のホスト候補です。 リレーされた候補者のベースは、その候補者自身です。 中継された候補がホスト候補と同一である場合（まれに発生する可能性があります）、中継された候補は破棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an IPv6-only agent is in a network that utilizes NAT64 [RFC6146] and DNS64 [RFC6147] technologies, it may also gather IPv4 server-reflexive and/or relayed candidates from IPv4-only STUN or TURN servers. IPv6-only agents SHOULD also utilize IPv6 prefix discovery [RFC7050] to discover the IPv6 prefix used by NAT64 (if any) and generate server-reflexive candidates for each IPv6-only interface, accordingly. The NAT64 server-reflexive candidates are prioritized like IPv4 server-reflexive candidates.",
      "ja": "IPv6専用エージェントが、NAT64 [RFC6146]およびDNS64 [RFC6147]テクノロジを利用するネットワークにある場合、IPv4専用のSTUNまたはTURNサーバーからIPv4サーバー反射および/またはリレー候補を収集することもあります。 IPv6専用エージェントは、IPv6プレフィックス検出[RFC7050]も利用して、NAT64が使用するIPv6プレフィックスを検出し（存在する場合）、それに応じて各IPv6専用インターフェイスのサーバー反射候補を生成する必要があります。 NAT64サーバー反射候補は、IPv4サーバー反射候補と同様に優先順位が付けられます。"
    },
    {
      "indent": 0,
      "text": "5.1.1.3. Computing Foundations",
      "section_title": true,
      "ja": "5.1.1.3。 コンピューティング基盤"
    },
    {
      "indent": 3,
      "text": "The ICE agent assigns each candidate a foundation. Two candidates have the same foundation when all of the following are true:",
      "ja": "ICEエージェントは各候補者に基礎を割り当てます。 次のすべてに該当する場合、2つの候補者の基盤は同じです。"
    },
    {
      "indent": 3,
      "text": "o They have the same type (host, relayed, server reflexive, or peer reflexive).",
      "ja": "o同じタイプ（ホスト、リレー、サーバー反射、またはピア反射）を持っています。"
    },
    {
      "indent": 3,
      "text": "o Their bases have the same IP address (the ports can be different).",
      "ja": "oベースのIPアドレスは同じです（ポートは異なる場合があります）。"
    },
    {
      "indent": 3,
      "text": "o For reflexive and relayed candidates, the STUN or TURN servers used to obtain them have the same IP address (the IP address used by the agent to contact the STUN or TURN server).",
      "ja": "o再帰候補およびリレー候補の場合、候補を取得するために使用されるSTUNまたはTURNサーバーは同じIPアドレス（エージェントがSTUNまたはTURNサーバーに接続するために使用するIPアドレス）を持ちます。"
    },
    {
      "indent": 3,
      "text": "o They were obtained using the same transport protocol (TCP, UDP).",
      "ja": "oそれらは同じトランスポートプロトコル（TCP、UDP）を使用して取得されました。"
    },
    {
      "indent": 3,
      "text": "Similarly, two candidates have different foundations if their types are different, their bases have different IP addresses, the STUN or TURN servers used to obtain them have different IP addresses (the IP addresses used by the agent to contact the STUN or TURN server), or their transport protocols are different.",
      "ja": "同様に、2つの候補者は、タイプが異なり、ベースが異なるIPアドレスを持ち、それらを取得するために使用されるSTUNまたはTURNサーバーが異なるIPアドレス（エージェントがSTUNまたはTURNサーバーに接続するために使用するIPアドレス） またはそれらの転送プロトコルが異なります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.4. Keeping Candidates Alive",
      "section_title": true,
      "ja": "5.1.1.4。 候補者を生き続ける"
    },
    {
      "indent": 3,
      "text": "Once server-reflexive and relayed candidates are allocated, they MUST be kept alive until ICE processing has completed, as described in Section 8.3. For server-reflexive candidates learned through a Binding request, the bindings MUST be kept alive by additional Binding requests to the server. Refreshes for allocations are done using the Refresh transaction, as described in [RFC5766]. The Refresh requests will also refresh the server-reflexive candidate.",
      "ja": "サーバーリフレクティブおよびリレーされた候補が割り当てられたら、セクション8.3で説明されているように、ICE処理が完了するまで生き続けなければなりません。 バインディングリクエストを通じて学習したサーバー反射候補の場合、サーバーへの追加のバインディングリクエストによってバインディングを維持する必要があります。 [RFC5766]で説明されているように、割り当ての更新は更新トランザクションを使用して行われます。 更新要求は、サーバー反映候補も更新します。"
    },
    {
      "indent": 3,
      "text": "Host candidates do not time out, but the candidate addresses may change or disappear for a number of reasons. An ICE agent SHOULD monitor the interfaces it uses, invalidate candidates whose base has gone away, and acquire new candidates as appropriate when new IP addresses (on new or currently used interfaces) appear.",
      "ja": "ホスト候補者はタイムアウトしませんが、いくつかの理由で候補者の住所が変更または消失する場合があります。 ICEエージェントは、使用するインターフェイスを監視し、ベースがなくなった候補を無効にし、（新しいまたは現在使用されているインターフェイス上の）新しいIPアドレスが表示されたときに必要に応じて新しい候補を取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Prioritizing Candidates",
      "section_title": true,
      "ja": "5.1.2.  候補者の優先順位付け"
    },
    {
      "indent": 3,
      "text": "The prioritization process results in the assignment of a priority to each candidate. Each candidate for a data stream MUST have a unique priority that MUST be a positive integer between 1 and (2**31 - 1). This priority will be used by ICE to determine the order of the connectivity checks and the relative preference for candidates. Higher-priority values give more priority over lower values.",
      "ja": "優先順位付けプロセスにより、各候補者に優先順位が割り当てられます。 データストリームの各候補には、1〜（2 ** 31-1）の間の正の整数でなければならない一意の優先度が必要です。 この優先順位は、接続性チェックの順序と候補者の相対的な優先順位を決定するためにICEによって使用されます。 優先度の高い値は、低い値よりも優先度が高くなります。"
    },
    {
      "indent": 3,
      "text": "An ICE agent SHOULD compute this priority using the formula in Section 5.1.2.1 and choose its parameters using the guidelines in Section 5.1.2.2. If an agent elects to use a different formula, ICE may take longer to converge since the agents will not be coordinated in their checks.",
      "ja": "ICEエージェントは、5.1.2.1項の式を使用してこの優先度を計算し、5.1.2.2項のガイドラインを使用してパラメータを選択する必要があります。 エージェントが別の式を使用することを選択した場合、ICEは収束に時間がかかることがあります。これは、エージェントがチェックで調整されないためです。"
    },
    {
      "indent": 3,
      "text": "The process for prioritizing candidates is common across the initiating and the responding agent.",
      "ja": "候補者に優先順位を付けるプロセスは、開始エージェントと応答エージェントで共通です。"
    },
    {
      "indent": 0,
      "text": "5.1.2.1. Recommended Formula",
      "section_title": true,
      "ja": "5.1.2.1。 推奨フォーミュラ"
    },
    {
      "indent": 3,
      "text": "The recommended formula combines a preference for the candidate type (server reflexive, peer reflexive, relayed, and host), a preference for the IP address for which the candidate was obtained, and a component ID using the following formula:",
      "ja": "推奨される式は、次の式を使用して、候補タイプの優先（サーバー反射、ピア反射、リレー、およびホスト）、候補が取得されたIPアドレスの優先、およびコンポーネントIDを組み合わせます。"
    },
    {
      "indent": 3,
      "text": "priority = (2^24)*(type preference) + (2^8)*(local preference) + (2^0)*(256 - component ID)",
      "ja": "優先度=（2 ^ 24）*（タイプ設定）+（2 ^ 8）*（ローカル設定）+（2 ^ 0）*（256-コンポーネントID）"
    },
    {
      "indent": 3,
      "text": "The type preference MUST be an integer from 0 (lowest preference) to 126 (highest preference) inclusive, MUST be identical for all candidates of the same type, and MUST be different for candidates of different types. The type preference for peer-reflexive candidates MUST be higher than that of server-reflexive candidates. Setting the value to 0 means that candidates of this type will only be used as a last resort. Note that candidates gathered based on the procedures of Section 5.1.1 will never be peer-reflexive candidates; candidates of this type are learned from the connectivity checks performed by ICE.",
      "ja": "タイププリファレンスは、0（最低プリファレンス）から126（最高プリファレンス）までの整数でなければならず、同じタイプのすべての候補に対して同一でなければならず、異なるタイプの候補に対して異なっていなければなりません。 ピア再帰候補のタイプ設定は、サーバー再帰候補のそれよりも高くなければなりません。 値を0に設定すると、このタイプの候補は最後の手段としてのみ使用されます。 セクション5.1.1の手順に基づいて収集された候補者は、ピア反射候補者になることはありません。 このタイプの候補は、ICEによって実行される接続性チェックから学習されます。"
    },
    {
      "indent": 3,
      "text": "The local preference MUST be an integer from 0 (lowest preference) to 65535 (highest preference) inclusive. When there is only a single IP address, this value SHOULD be set to 65535. If there are multiple candidates for a particular component for a particular data stream that have the same type, the local preference MUST be unique for each one. If an ICE agent is dual stack, the local preference SHOULD be set according to the current best practice described in [RFC8421].",
      "ja": "ローカル設定は、0（最低設定）から65535（最高設定）までの整数でなければなりません（MUST）。 IPアドレスが1つしかない場合、この値は65535に設定する必要があります。同じタイプの特定のデータストリームの特定のコンポーネントに複数の候補がある場合、ローカルプリファレンスはそれぞれに対して一意でなければなりません。 ICEエージェントがデュアルスタックの場合、[RFC8421]で説明されている現在のベストプラクティスに従って、ローカルプリファレンスを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The component ID MUST be an integer between 1 and 256 inclusive.",
      "ja": "コンポーネントIDは、1〜256の整数でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.2.2. Guidelines for Choosing Type and Local Preferences",
      "section_title": true,
      "ja": "5.1.2.2。 タイプとローカルプリファレンスを選択するためのガイドライン"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED values for type preferences are 126 for host candidates, 110 for peer-reflexive candidates, 100 for server-reflexive candidates, and 0 for relayed candidates.",
      "ja": "タイププリファレンスのRECOMMENDED値は、ホスト候補の場合は126、ピア反射候補の場合は110、サーバー反射候補の場合は100、リレー候補の場合は0です。"
    },
    {
      "indent": 3,
      "text": "If an ICE agent is multihomed and has multiple IP addresses, the recommendations in [RFC8421] SHOULD be followed. If multiple TURN servers are used, local priorities for the candidates obtained from the TURN servers are chosen in a similar fashion as for multihomed local candidates: the local preference value is used to indicate a preference among different servers, but the preference MUST be unique for each one.",
      "ja": "ICEエージェントがマルチホームであり、複数のIPアドレスがある場合、[RFC8421]の推奨事項に従う必要があります。 複数のTURNサーバーを使用する場合、TURNサーバーから取得した候補のローカル優先順位は、マルチホームローカル候補と同様の方法で選択されます。ローカル優先値は、異なるサーバー間の優先を示すために使用されますが、優先は一意でなければなりません それぞれ。"
    },
    {
      "indent": 3,
      "text": "When choosing type preferences, agents may take into account factors such as latency, packet loss, cost, network topology, security, privacy, and others.",
      "ja": "タイプ設定を選択するとき、エージェントは、待ち時間、パケット損失、コスト、ネットワークトポロジ、セキュリティ、プライバシーなどの要因を考慮する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Eliminating Redundant Candidates",
      "section_title": true,
      "ja": "5.1.3.  冗長候補者の排除"
    },
    {
      "indent": 3,
      "text": "Next, the ICE agents (initiating and responding) eliminate redundant candidates. Two candidates can have the same transport address yet different bases, and these would not be considered redundant. Frequently, a server-reflexive candidate and a host candidate will be redundant when the agent is not behind a NAT. A candidate is redundant if and only if its transport address and base equal those of another candidate. The agent SHOULD eliminate the redundant candidate with the lower priority.",
      "ja": "次に、ICEエージェント（開始および応答）が冗長な候補を排除します。 2つの候補は同じトランスポートアドレスを持つことができますが、ベースは異なるため、これらは冗長とは見なされません。 多くの場合、エージェントがNATの背後にない場合、サーバー反射候補とホスト候補は冗長になります。 候補は、そのトランスポートアドレスとベースが別の候補のものと等しい場合にのみ冗長です。 エージェントは、優先度の低い冗長な候補を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Lite Implementation Procedures",
      "section_title": true,
      "ja": "5.2.  Liteの実装手順"
    },
    {
      "indent": 3,
      "text": "Lite implementations only utilize host candidates. For each IP address, independent of an IP address family, there MUST be zero or one candidate. With the lite implementation, ICE cannot be used to dynamically choose amongst candidates. Therefore, including more than one candidate from a particular IP address family is NOT RECOMMENDED, since only a connectivity check can truly determine whether to use one address or the other. Instead, it is RECOMMENDED that agents that have multiple public IP addresses run full ICE implementations to ensure the best usage of its addresses.",
      "ja": "Lite実装は、ホスト候補のみを利用します。 IPアドレスファミリに関係なく、各IPアドレスについて、候補はゼロまたは1つでなければなりません。 ライトの実装では、ICEを使用して候補の中から動的に選択することはできません。 したがって、特定のIPアドレスファミリの複数の候補を含めることはお勧めしません。1つのアドレスを使用するか、他のアドレスを使用するかを接続性チェックでのみ判断できるためです。 代わりに、複数のパブリックIPアドレスを持つエージェントが完全なICE実装を実行して、そのアドレスを最適に使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Each component has an ID assigned to it, called the \"component ID\". For RTP/RTCP data streams, unless RTCP is multiplexed in the same port with RTP, the RTP itself has a component ID of 1 and RTCP a component ID of 2. If an agent is using RTCP without multiplexing, it MUST obtain candidates for it. However, absence of a component ID 2 as such does not imply use of RTCP/RTP multiplexing, as it could also mean that RTCP is not used.",
      "ja": "各コンポーネントには、「コンポーネントID」と呼ばれるIDが割り当てられています。 RTP / RTCPデータストリームの場合、RTCPがRTPと同じポートで多重化されていない限り、RTP自体のコンポーネントIDは1、RTCPのコンポーネントIDは2です。エージェントがRTCPを多重化せずに使用している場合、その候補を取得する必要があります 。 ただし、コンポーネントID 2が存在しないことは、RTCP / RTP多重化の使用を意味しません。これは、RTCPが使用されないことも意味する可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "Each candidate is assigned a foundation. The foundation MUST be different for two candidates allocated from different IP addresses; otherwise, it MUST be the same. A simple integer that increments for each IP address will suffice. In addition, each candidate MUST be assigned a unique priority amongst all candidates for the same data stream. If the formula in Section 5.1.2.1 is used to calculate the priority, the type preference value SHOULD be set to 126. If a host is IPv4 only, the local preference value SHOULD be set to 65535. If a host is IPv6 or dual stack, the local preference value SHOULD be set to the precedence value for IP addresses described in RFC 6724 [RFC6724].",
      "ja": "各候補者には基礎が割り当てられます。 基盤は、異なるIPアドレスから割り当てられた2つの候補に対して異なっていなければなりません。 それ以外の場合は、同じでなければなりません。 IPアドレスごとに増分する単純な整数で十分です。 さらに、各候補には、同じデータストリームのすべての候補の中で一意の優先順位を割り当てる必要があります。 セクション5.1.2.1の式を使用して優先度を計算する場合、タイプ優先値は126に設定する必要があります。ホストがIPv4のみの場合、ローカル優先値は65535に設定する必要があります。ホストがIPv6またはデュアルスタックの場合 、ローカルプリファレンス値は、RFC 6724 [RFC6724]で説明されているIPアドレスの優先順位値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Next, an agent chooses a default candidate for each component of each data stream. If a host is IPv4 only, there would only be one candidate for each component of each data stream; therefore, that candidate is the default. If a host is IPv6 only, the default candidate would typically be a globally scoped IPv6 address. Dual-stack hosts SHOULD allow configuration whether IPv4 or IPv6 is used for the default candidate, and the configuration needs to be based on which one its administrator believes has a higher chance of success in the current network environment.",
      "ja": "次に、エージェントは各データストリームの各コンポーネントのデフォルト候補を選択します。 ホストがIPv4のみの場合、各データストリームの各コンポーネントに対して候補は1つだけです。 したがって、その候補がデフォルトです。 ホストがIPv6のみの場合、デフォルトの候補は通常、グローバルスコープのIPv6アドレスになります。 デュアルスタックホストは、デフォルト候補にIPv4またはIPv6が使用されているかどうかの構成を許可する必要があります。また、構成は、現在のネットワーク環境で成功する可能性が高いと管理者が判断する構成に基づく必要があります。"
    },
    {
      "indent": 3,
      "text": "The procedures in this section are common across the initiating and responding agents.",
      "ja": "このセクションの手順は、開始エージェントと応答エージェントで共通です。"
    },
    {
      "indent": 0,
      "text": "5.3. Exchanging Candidate Information",
      "section_title": true,
      "ja": "5.3.  候補者情報の交換"
    },
    {
      "indent": 3,
      "text": "ICE agents (initiating and responding) need the following information about candidates to be exchanged. Each ICE usage MUST define how the information is exchanged with the using protocol. This section describes the information that needs to be exchanged.",
      "ja": "ICEエージェント（開始および応答）には、交換する候補者に関する次の情報が必要です。 各ICEの使用法では、使用プロトコルとの情報の交換方法を定義する必要があります。 このセクションでは、交換する必要がある情報について説明します。"
    },
    {
      "indent": 3,
      "text": "Candidates: One or more candidates. For each candidate:",
      "ja": "候補者：1人以上の候補者。 各候補者について："
    },
    {
      "indent": 6,
      "text": "Address: The IP address and transport protocol port of the candidate.",
      "ja": "アドレス：候補者のIPアドレスとトランスポートプロトコルポート。"
    },
    {
      "indent": 6,
      "text": "Transport: The transport protocol of the candidate. This MAY be omitted if the using protocol only runs over a single transport protocol.",
      "ja": "トランスポート：候補者のトランスポートプロトコル。 使用プロトコルが単一のトランスポートプロトコル上でのみ実行される場合、これは省略できます。"
    },
    {
      "indent": 6,
      "text": "Foundation: A sequence of up to 32 characters.",
      "ja": "基礎：最大32文字のシーケンス。"
    },
    {
      "indent": 6,
      "text": "Component ID: The component ID of the candidate. This MAY be omitted if the using protocol does not use the concept of components.",
      "ja": "コンポーネントID：候補のコンポーネントID。 使用プロトコルがコンポーネントの概念を使用しない場合、これは省略してもよい[MAY]。"
    },
    {
      "indent": 6,
      "text": "Priority: The 32-bit priority of the candidate.",
      "ja": "優先度：候補者の32ビットの優先度。"
    },
    {
      "indent": 6,
      "text": "Type: The type of the candidate.",
      "ja": "タイプ：候補者のタイプ。"
    },
    {
      "indent": 6,
      "text": "Related Address and Port: The related IP address and port of the candidate. These MAY be omitted or set to invalid values if the agent does not want to reveal them, e.g., for privacy reasons.",
      "ja": "関連アドレスとポート：候補者の関連IPアドレスとポート。 エージェントがそれらを明らかにしたくない場合、例えばプライバシー上の理由で、これらは省略されるか、無効な値に設定されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "Extensibility Parameters: The using protocol might define means for adding new per-candidate ICE parameters in the future.",
      "ja": "拡張性パラメーター：使用プロトコルは、将来、候補ごとの新しいICEパラメーターを追加する手段を定義する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Lite or Full: Whether the agent is a lite agent or full agent.",
      "ja": "ライトまたはフル：エージェントがライトエージェントかフルエージェントか。"
    },
    {
      "indent": 3,
      "text": "Connectivity-Check Pacing Value: The pacing value for connectivity checks that the agent wishes to use. This MAY be omitted if the agent wishes to use a defined default value.",
      "ja": "接続性チェックのペーシング値：エージェントが使用したい接続性チェックのペーシング値。 エージェントが定義済みのデフォルト値を使用したい場合、これは省略してもよい[MAY]。"
    },
    {
      "indent": 3,
      "text": "Username Fragment and Password: Values used to perform connectivity checks. The values MUST be unguessable, with at least 128 bits of random number generator output used to generate the password, and at least 24 bits of output to generate the username fragment.",
      "ja": "ユーザー名フラグメントとパスワード：接続性チェックの実行に使用される値。 パスワードは、パスワードの生成に使用される乱数ジェネレータ出力の少なくとも128ビット、およびユーザー名フラグメントの生成に使用される少なくとも24ビットの出力で、推測不可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extensions: New media-stream or session-level attributes (ICE options).",
      "ja": "拡張機能：新しいメディアストリームまたはセッションレベルの属性（ICEオプション）。"
    },
    {
      "indent": 3,
      "text": "If the using protocol is vulnerable to, and able to detect, ICE mismatch (Section 5.4), a way is needed for the detecting agent to convey this information to its peer. It is a boolean flag.",
      "ja": "使用プロトコルがICEの不一致（5.4項）に対して脆弱であり、検出できる場合、検出エージェントがこの情報をピアに伝達する方法が必要です。 これはブール値のフラグです。"
    },
    {
      "indent": 3,
      "text": "The using protocol may (or may not) need to deal with backwards compatibility with older implementations that do not support ICE. If a fallback mechanism to non-ICE is supported and is being used, then presumably the using protocol provides a way of conveying the default candidate (its IP address and port) in addition to the ICE parameters.",
      "ja": "使用プロトコルは、ICEをサポートしない古い実装との後方互換性に対処する必要がある場合としない場合があります。 非ICEへのフォールバックメカニズムがサポートされて使用されている場合、おそらく使用プロトコルは、ICEパラメーターに加えてデフォルトの候補（IPアドレスとポート）を伝達する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Once an agent has sent its candidate information, it MUST be prepared to receive both STUN and data packets on each candidate. As discussed in Section 12.1, data packets can be sent to a candidate prior to its appearance as the default destination for data.",
      "ja": "エージェントが候補情報を送信すると、各候補でSTUNとデータパケットの両方を受信する準備をしなければなりません。 セクション12.1で説明したように、データのデフォルトの宛先として表示される前に、データパケットを候補に送信できます。"
    },
    {
      "indent": 0,
      "text": "5.4. ICE Mismatch",
      "section_title": true,
      "ja": "5.4.  ICEミスマッチ"
    },
    {
      "indent": 3,
      "text": "Certain middleboxes, such as ALGs, can alter signaling information in ways that break ICE (e.g., by rewriting IP addresses in SDP). This is referred to as \"ICE mismatch\". If the using protocol is vulnerable to ICE mismatch, the responding agent needs to be able to detect it and inform the peer ICE agent about the ICE mismatch.",
      "ja": "ALGなどの特定のミドルボックスは、ICEを壊す方法で（たとえば、SDPでIPアドレスを書き換えることにより）シグナリング情報を変更できます。 これは「ICEの不一致」と呼ばれます。 使用プロトコルがICEの不一致に対して脆弱である場合、応答するエージェントはそれを検出し、ICEの不一致についてピアICEエージェントに通知できる必要があります。"
    },
    {
      "indent": 3,
      "text": "Each using protocol needs to define whether the using protocol is vulnerable to ICE mismatch, how ICE mismatch is detected, and whether specific actions need to be taken when ICE mismatch is detected.",
      "ja": "各使用プロトコルは、使用プロトコルがICEの不一致に対して脆弱かどうか、ICEの不一致の検出方法、およびICEの不一致が検出されたときに特定のアクションを実行する必要があるかどうかを定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. ICE Candidate Processing",
      "section_title": true,
      "ja": "6. ICE候補の処理"
    },
    {
      "indent": 3,
      "text": "Once an ICE agent has gathered its candidates and exchanged candidates with its peer (Section 5), it will determine its own role. In addition, full implementations will form checklists and begin performing connectivity checks with the peer.",
      "ja": "ICEエージェントが候補を収集し、ピアと候補を交換すると（セクション5）、自身の役割を決定します。 さらに、完全な実装はチェックリストを形成し、ピアとの接続性チェックの実行を開始します。"
    },
    {
      "indent": 0,
      "text": "6.1. Procedures for Full Implementation",
      "section_title": true,
      "ja": "6.1.  完全実装の手順"
    },
    {
      "indent": 0,
      "text": "6.1.1. Determining Role",
      "section_title": true,
      "ja": "6.1.1.  役割の決定"
    },
    {
      "indent": 3,
      "text": "For each session, each ICE agent (initiating and responding) takes on a role. There are two roles -- controlling and controlled. The controlling agent is responsible for the choice of the final candidate pairs used for communications. The sections below describe in detail the actual procedures followed by controlling and controlled agents.",
      "ja": "セッションごとに、各ICEエージェント（開始および応答）が役割を引き受けます。 制御と制御の2つの役割があります。 制御エージェントは、通信に使用される最終候補ペアの選択を担当します。 以下のセクションでは、制御エージェントと制御エージェントが従う実際の手順について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "The rules for determining the role and the impact on behavior are as follows:",
      "ja": "ロールと動作への影響を決定するためのルールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Both agents are full: The initiating agent that started the ICE processing MUST take the controlling role, and the other MUST take the controlled role. Both agents will form checklists, run the ICE state machines, and generate connectivity checks. The controlling agent will execute the logic in Section 8.1 to nominate pairs that will become (if the connectivity checks associated with the nominations succeed) the selected pairs, and then both agents end ICE as described in Section 8.1.2.",
      "ja": "両方のエージェントがいっぱいです：ICE処理を開始した開始エージェントが制御の役割を引き受け、他のエージェントが制御の役割を引き受けなければなりません。 両方のエージェントがチェックリストを作成し、ICEステートマシンを実行し、接続性チェックを生成します。 制御エージェントは、セクション8.1のロジックを実行して、選択されたペアとなるペアを指定し（指名に関連付けられた接続チェックが成功した場合）、セクション8.1.2で説明したように両方のエージェントがICEを終了します。"
    },
    {
      "indent": 3,
      "text": "One agent full, one lite: The full agent MUST take the controlling role, and the lite agent MUST take the controlled role. The full agent will form checklists, run the ICE state machines, and generate connectivity checks. That agent will execute the logic in Section 8.1 to nominate pairs that will become (if the connectivity checks associated with the nominations succeed) the selected pairs and use the logic in Section 8.1.2 to end ICE. The lite implementation will just listen for connectivity checks, receive them and respond to them, and then conclude ICE as described in Section 8.2. For the lite implementation, the state of ICE processing for each data stream is considered to be Running, and the state of ICE overall is Running.",
      "ja": "1人のエージェントが完全、1人のライト：完全なエージェントが制御の役割を引き受けなければならず、ライトエージェントが制御の役割を引き受けなければなりません。 完全なエージェントはチェックリストを作成し、ICEステートマシンを実行し、接続性チェックを生成します。 そのエージェントは、セクション8.1のロジックを実行して、選択されたペアになるノミネートに関連する接続チェックが成功した場合にペアを指定し、セクション8.1.2のロジックを使用してICEを終了します。 ライトの実装は、接続性チェックをリッスンし、それらを受信して応答し、セクション8.2で説明されているようにICEを終了します。 ライトの実装では、各データストリームのICE処理の状態は実行中と見なされ、ICE全体の状態は実行中です。"
    },
    {
      "indent": 3,
      "text": "Both lite: The initiating agent that started the ICE processing MUST take the controlling role, and the other MUST take the controlled role. In this case, no connectivity checks are ever sent. Rather, once the candidates are exchanged, each agent performs the processing described in Section 8 without connectivity checks. It is possible that both agents will believe they are controlled or controlling. In the latter case, the conflict is resolved through glare detection capabilities in the signaling protocol enabling the candidate exchange. The state of ICE processing for each data stream is considered to be Running, and the state of ICE overall is Running.",
      "ja": "Both lite：ICE処理を開始した開始エージェントは制御の役割を引き受けなければならず、他のエージェントは制御の役割を引き受けなければなりません。 この場合、接続チェックは送信されません。 むしろ、候補が交換されると、各エージェントは接続チェックなしでセクション8で説明されている処理を実行します。 両方のエージェントが、自分が管理されている、または管理していると信じることがあります。 後者の場合、競合は、候補交換を可能にするシグナリングプロトコルのグレア検出機能によって解決されます。 各データストリームのICE処理の状態は実行中と見なされ、ICE全体の状態は実行中です。"
    },
    {
      "indent": 3,
      "text": "Once the roles are determined for a session, they persist throughout the lifetime of the session. The roles can be redetermined as part of an ICE restart (Section 9), but an ICE agent MUST NOT redetermine the role as part of an ICE restart unless one or more of the following criteria is fulfilled:",
      "ja": "セッションの役割が決定されると、それらはセッションの存続期間中持続します。 ロールはICE再起動の一部として再決定できますが（セクション9）、次の基準の1つ以上が満たされない限り、ICEエージェントはICE再起動の一部としてロールを再決定してはなりません。"
    },
    {
      "indent": 3,
      "text": "Full becomes lite: If the controlling agent is full, and switches to lite, the roles MUST be redetermined if the peer agent is also full.",
      "ja": "Fullがliteになります：制御エージェントがいっぱいになり、liteに切り替わった場合、ピアエージェントもいっぱいになった場合、ロールを再決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Role conflict: If the ICE restart causes a role conflict, the roles might be redetermined due to the role conflict procedures in Section 7.3.1.1.",
      "ja": "ロールの競合：ICEの再起動によりロールの競合が発生する場合、セクション7.3.1.1のロールの競合手順により、ロールが再決定される場合があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: There are certain Third Party Call Control (3PCC) [RFC3725] scenarios where an ICE restart might cause a role conflict.",
      "ja": "注：ICEの再起動が役割の競合を引き起こす可能性がある特定のサードパーティコール制御（3PCC）[RFC3725]シナリオがあります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The agents need to inform each other whether they are full or lite before the roles are determined. The mechanism for that is specific to the signaling protocol and outside the scope of the document.",
      "ja": "注：エージェントは、ロールが決定される前に、エージェントが満員であるかライトであるかを互いに通知する必要があります。 そのためのメカニズムは、シグナリングプロトコルに固有であり、ドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "An agent MUST accept if the peer initiates a redetermination of the roles even if the criteria for doing so are not fulfilled. This can happen if the peer is compliant with RFC 5245.",
      "ja": "ピアが役割の再決定を開始した場合でも、そうするための基準が満たされていない場合でも、エージェントは受け入れなければなりません。 これは、ピアがRFC 5245に準拠している場合に発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Forming the Checklists",
      "section_title": true,
      "ja": "6.1.2.  チェックリストの作成"
    },
    {
      "indent": 3,
      "text": "There is one checklist for each data stream. To form a checklist, initiating and responding ICE agents form candidate pairs, compute pair priorities, order pairs by priority, prune pairs, remove lower-priority pairs, and set checklist states. If candidates are added to a checklist (e.g., due to detection of peer-reflexive candidates), the agent will re-perform these steps for the updated checklist.",
      "ja": "データストリームごとに1つのチェックリストがあります。 チェックリストを作成するには、ICEエージェントの開始と応答により候補ペアを作成し、ペアの優先度を計算し、優先度でペアを順序付け、ペアを整理し、優先度の低いペアを削除し、チェックリストの状態を設定します。 候補がチェックリストに追加された場合（たとえば、ピア再帰候補の検出により）、エージェントは更新されたチェックリストに対してこれらの手順を再実行します。"
    },
    {
      "indent": 0,
      "text": "6.1.2.1. Checklist State",
      "section_title": true,
      "ja": "6.1.2.1。 チェックリストの状態"
    },
    {
      "indent": 3,
      "text": "Each checklist has a state, which captures the state of ICE checks for the data stream associated with the checklist. The states are:",
      "ja": "各チェックリストには状態があり、チェックリストに関連付けられたデータストリームのICEチェックの状態をキャプチャします。 状態は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Running: The checklist is neither Completed nor Failed yet. Checklists are initially set to the Running state.",
      "ja": "実行中：チェックリストはまだ完了も失敗もしていません。 チェックリストは、最初は実行状態に設定されています。"
    },
    {
      "indent": 3,
      "text": "Completed: The checklist contains a nominated pair for each component of the data stream.",
      "ja": "完了：チェックリストには、データストリームの各コンポーネントに指定されたペアが含まれています。"
    },
    {
      "indent": 3,
      "text": "Failed: The checklist does not have a valid pair for each component of the data stream, and all of the candidate pairs in the checklist are in either the Failed or the Succeeded state. In other words, at least one component of the checklist has candidate pairs that are all in the Failed state, which means the component has failed, which means the checklist has failed.",
      "ja": "失敗：チェックリストには、データストリームの各コンポーネントの有効なペアがありません。また、チェックリストのすべての候補ペアは、失敗または成功のいずれかの状態です。 つまり、チェックリストの少なくとも1つのコンポーネントに候補ペアがあり、それらはすべて失敗状態です。これは、コンポーネントが失敗したこと、つまりチェックリストが失敗したことを意味します。"
    },
    {
      "indent": 0,
      "text": "6.1.2.2. Forming Candidate Pairs",
      "section_title": true,
      "ja": "6.1.2.2。 候補ペアの形成"
    },
    {
      "indent": 3,
      "text": "The ICE agent pairs each local candidate with each remote candidate for the same component of the same data stream with the same IP address family. It is possible that some of the local candidates won't get paired with remote candidates, and some of the remote candidates won't get paired with local candidates. This can happen if one agent doesn't include candidates for all of the components for a data stream. If this happens, the number of components for that data stream is effectively reduced and is considered to be equal to the minimum across both agents of the maximum component ID provided by each agent across all components for the data stream.",
      "ja": "ICEエージェントは、各ローカル候補を、同じIPアドレスファミリの同じデータストリームの同じコンポーネントの各リモート候補とペアにします。 ローカル候補者の一部がリモート候補者とペアリングされず、リモート候補者の一部がローカル候補者とペアリングされない可能性があります。 これは、1つのエージェントがデータストリームのすべてのコンポーネントの候補を含まない場合に発生する可能性があります。 これが発生した場合、そのデータストリームのコンポーネント数は効果的に削減され、データストリームのすべてのコンポーネントで各エージェントが提供する最大コンポーネントIDの両方のエージェントの最小数に等しいと見なされます。"
    },
    {
      "indent": 3,
      "text": "In the case of RTP, this would happen when one agent provides candidates for RTCP, and the other does not. As another example, the initiating agent can multiplex RTP and RTCP on the same port [RFC5761]. However, since the initiating agent doesn't know if the peer agent can perform such multiplexing, it includes candidates for RTP and RTCP on separate ports. If the peer agent can perform such multiplexing, it would include just a single component for each candidate -- for the combined RTP/RTCP mux. ICE would end up acting as if there was just a single component for this candidate.",
      "ja": "RTPの場合、これは1つのエージェントがRTCPの候補を提供し、他のエージェントが提供しないときに起こります。 別の例として、開始エージェントは同じポート上でRTPとRTCPを多重化できます[RFC5761]。 ただし、開始エージェントはピアエージェントがそのような多重化を実行できるかどうかを知らないため、別のポートでRTPとRTCPの候補が含まれます。 ピアエージェントがそのような多重化を実行できる場合、各RTP / RTCP muxの候補ごとに1つのコンポーネントのみが含まれます。 ICEは、この候補のコンポーネントが1つだけであるかのように振る舞うことになります。"
    },
    {
      "indent": 3,
      "text": "With IPv6, it is common for a host to have multiple host candidates for each interface. To keep the amount of resulting candidate pairs reasonable and to avoid candidate pairs that are highly unlikely to work, IPv6 link-local addresses MUST NOT be paired with other than link-local addresses.",
      "ja": "IPv6では、ホストが各インターフェイスに対して複数のホスト候補を持つことが一般的です。 結果の候補ペアの量を合理的に保ち、動作する可能性が非常に低い候補ペアを避けるために、IPv6リンクローカルアドレスをリンクローカルアドレス以外とペアにしないでください。"
    },
    {
      "indent": 3,
      "text": "The candidate pairs whose local and remote candidates are both the default candidates for a particular component is called the \"default candidate pair\" for that component. This is the pair that would be used to transmit data if both agents had not been ICE aware.",
      "ja": "ローカル候補とリモート候補の両方が特定のコンポーネントのデフォルト候補である候補ペアは、そのコンポーネントの「デフォルト候補ペア」と呼ばれます。 これは、両方のエージェントがICE対応でない場合にデータを送信するために使用されるペアです。"
    },
    {
      "indent": 3,
      "text": "Figure 5 shows the properties of and relationships between transport addresses, candidates, candidate pairs, and checklists.",
      "ja": "図5は、トランスポートアドレス、候補、候補ペア、およびチェックリストのプロパティと関係を示しています。"
    },
    {
      "indent": 12,
      "text": "  +--------------------------------------------+\n  |                                            |\n  | +---------------------+                    |\n  | |+----+ +----+ +----+ |   +Type            |\n  | || IP | |Port| |Tran| |   +Priority        |\n  | ||Addr| |    | |    | |   +Foundation      |\n  | |+----+ +----+ +----+ |   +Component ID    |\n  | |      Transport      |   +Related Address |\n  | |        Addr         |                    |\n  | +---------------------+   +Base            |\n  |             Candidate                      |\n  +--------------------------------------------+\n  *                                         *\n  *    *************************************\n  *    *\n+-------------------------------+\n|                               |\n| Local     Remote              |\n| +----+    +----+   +default?  |\n| |Cand|    |Cand|   +valid?    |\n| +----+    +----+   +nominated?|\n|                    +State     |\n|                               |\n|                               |\n|          Candidate Pair       |\n+-------------------------------+\n*                              *\n*                  ************\n*                  *\n+------------------+\n|  Candidate Pair  |\n+------------------+\n+------------------+\n|  Candidate Pair  |\n+------------------+\n+------------------+\n|  Candidate Pair  |\n+------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Checklist",
      "ja": "チェックリスト"
    },
    {
      "indent": 16,
      "text": "Figure 5: Conceptual Diagram of a Checklist",
      "ja": "図5：チェックリストの概念図"
    },
    {
      "indent": 0,
      "text": "6.1.2.3. Computing Pair Priority and Ordering Pairs",
      "section_title": true,
      "ja": "6.1.2.3。 ペアの優先度と順序ペアの計算"
    },
    {
      "indent": 3,
      "text": "The ICE agent computes a priority for each candidate pair. Let G be the priority for the candidate provided by the controlling agent. Let D be the priority for the candidate provided by the controlled agent. The priority for a pair is computed as follows:",
      "ja": "ICEエージェントは、各候補ペアの優先順位を計算します。 Gを、制御エージェントによって提供される候補の優先順位とします。 制御されたエージェントによって提供される候補の優先度をDとします。 ペアの優先順位は次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)",
      "ja": "ペアの優先度= 2 ^ 32 * MIN（G、D）+ 2 * MAX（G、D）+（G> D？1：0）"
    },
    {
      "indent": 3,
      "text": "The agent sorts each checklist in decreasing order of candidate pair priority. If two pairs have identical priority, the ordering amongst them is arbitrary.",
      "ja": "エージェントは、候補ペアの優先度の降順で各チェックリストをソートします。 2つのペアの優先度が同じ場合、それらの間の順序は任意です。"
    },
    {
      "indent": 0,
      "text": "6.1.2.4. Pruning the Pairs",
      "section_title": true,
      "ja": "6.1.2.4。 ペアの剪定"
    },
    {
      "indent": 3,
      "text": "This sorted list of candidate pairs is used to determine a sequence of connectivity checks that will be performed. Each check involves sending a request from a local candidate to a remote candidate. Since an ICE agent cannot send requests directly from a reflexive candidate (server reflexive or peer reflexive), but only from its base, the agent next goes through the sorted list of candidate pairs. For each pair where the local candidate is reflexive, the candidate MUST be replaced by its base.",
      "ja": "このソートされた候補ペアのリストは、実行される接続性チェックのシーケンスを決定するために使用されます。 各チェックには、ローカル候補者からリモート候補者へのリクエストの送信が含まれます。 ICEエージェントは反射候補（サーバー反射またはピア反射）から直接リクエストを送信することはできず、そのベースからのみ送信するため、エージェントは候補ペアのソート済みリストを次に通過します。 ローカル候補が再帰的である各ペアに対して、候補はそのベースに置き換えられなければなりません。"
    },
    {
      "indent": 3,
      "text": "The agent prunes each checklist. This is done by removing a candidate pair if it is redundant with a higher-priority candidate pair in the same checklist. Two candidate pairs are redundant if their local candidates have the same base and their remote candidates are identical. The result is a sequence of ordered candidate pairs, called the \"checklist\" for that data stream.",
      "ja": "エージェントは各チェックリストを整理します。 これは、同じチェックリスト内の優先度の高い候補ペアと冗長である場合、候補ペアを削除することによって行われます。 2つの候補ペアは、ローカル候補が同じベースを持ち、リモート候補が同一である場合、冗長です。 結果は、そのデータストリームの「チェックリスト」と呼ばれる順序付けられた候補ペアのシーケンスです。"
    },
    {
      "indent": 0,
      "text": "6.1.2.5. Removing Lower-Priority Pairs",
      "section_title": true,
      "ja": "6.1.2.5。 優先度の低いペアの削除"
    },
    {
      "indent": 3,
      "text": "In order to limit the attacks described in Section 19.5.1, an ICE agent MUST limit the total number of connectivity checks the agent performs across all checklists in the checklist set. This is done by limiting the total number of candidate pairs in the checklist set. The default limit of candidate pairs for the checklist set is 100, but the value MUST be configurable. The limit is enforced by, within in each checklist, discarding lower-priority candidate pairs until the total number of candidate pairs in the checklist set is smaller than the limit value. The discarding SHOULD be done evenly so that the number of candidate pairs in each checklist is reduced the same amount.",
      "ja": "セクション19.5.1で説明した攻撃を制限するために、ICEエージェントは、チェックリストセット内のすべてのチェックリストでエージェントが実行する接続チェックの総数を制限する必要があります。 これは、チェックリストセット内の候補ペアの総数を制限することにより行われます。 チェックリストセットの候補ペアのデフォルトの制限は100ですが、値は構成可能でなければなりません。 制限は、各チェックリスト内で、チェックリストセット内の候補ペアの総数が制限値より小さくなるまで、優先度の低い候補ペアを破棄することによって実施されます。 各チェックリストの候補ペアの数が同じ量だけ減少するように、破棄は均等に行われる必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that a lower-limit value than the default is picked when possible, and that the value is set to the maximum number of plausible candidate pairs that might be created in an actual deployment configuration. The requirement for configuration is meant to provide a tool for fixing this value in the field if, once deployed, it is found to be problematic.",
      "ja": "可能な場合はデフォルトよりも低い値を選択し、実際の展開構成で作成される可能性のある候補ペアの最大数に値を設定することをお勧めします。 構成の要件は、展開後に問題があることが判明した場合に、フィールドでこの値を修正するためのツールを提供することを意図しています。"
    },
    {
      "indent": 0,
      "text": "6.1.2.6. Computing Candidate Pair States",
      "section_title": true,
      "ja": "6.1.2.6。 候補ペア状態の計算"
    },
    {
      "indent": 3,
      "text": "Each candidate pair in the checklist has a foundation (the combination of the foundations of the local and remote candidates in the pair) and one of the following states:",
      "ja": "チェックリストの各候補者ペアには、基礎（ペアのローカル候補とリモート候補の基礎の組み合わせ）と次のいずれかの状態があります。"
    },
    {
      "indent": 3,
      "text": "Waiting: A check has not been sent for this pair, but the pair is not Frozen.",
      "ja": "待機中：このペアのチェックは送信されていませんが、ペアは凍結されていません。"
    },
    {
      "indent": 3,
      "text": "In-Progress: A check has been sent for this pair, but the transaction is in progress.",
      "ja": "進行中：このペアに対してチェックが送信されましたが、トランザクションは進行中です。"
    },
    {
      "indent": 3,
      "text": "Succeeded: A check has been sent for this pair, and it produced a successful result.",
      "ja": "成功：このペアに対してチェックが送信され、成功の結果が生成されました。"
    },
    {
      "indent": 3,
      "text": "Failed: A check has been sent for this pair, and it failed (a response to the check was never received, or a failure response was received).",
      "ja": "失敗：このペアに対してチェックが送信され、失敗しました（チェックに対する応答が受信されなかったか、失敗応答が受信されました）。"
    },
    {
      "indent": 3,
      "text": "Frozen: A check for this pair has not been sent, and it cannot be sent until the pair is unfrozen and moved into the Waiting state.",
      "ja": "凍結：このペアのチェックは送信されておらず、ペアが凍結解除されて待機状態に移行するまで送信できません。"
    },
    {
      "indent": 3,
      "text": "Pairs move between states as shown in Figure 6.",
      "ja": "図6に示すように、ペアは状態間を移動します。"
    },
    {
      "indent": 6,
      "text": "+-----------+\n|           |\n|           |\n|  Frozen   |\n|           |\n|           |\n+-----------+\n      |\n      |unfreeze\n      |\n      V\n+-----------+         +-----------+\n|           |         |           |\n|           | perform |           |\n|  Waiting  |-------->|In-Progress|\n|           |         |           |\n|           |         |           |\n+-----------+         +-----------+\n                            / |\n                          //  |\n                        //    |\n                      //      |\n                     /        |\n                   //         |\n         failure //           |success\n               //             |\n              /               |\n            //                |\n          //                  |\n        //                    |\n       V                      V\n+-----------+         +-----------+\n|           |         |           |\n|           |         |           |\n|   Failed  |         | Succeeded |\n|           |         |           |\n|           |         |           |\n+-----------+         +-----------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 6: Pair State Finite State Machine (FSM)",
      "ja": "図6：ペア状態有限状態マシン（FSM）"
    },
    {
      "indent": 3,
      "text": "The initial states for each pair in a checklist are computed by performing the following sequence of steps:",
      "ja": "チェックリストの各ペアの初期状態は、次の一連の手順を実行して計算されます。"
    },
    {
      "indent": 3,
      "text": "1. The checklists are placed in an ordered list (the order is determined by each ICE usage), called the \"checklist set\".",
      "ja": "1.チェックリストは、「チェックリストセット」と呼ばれる順序付けられたリストに配置されます（順序は各ICEの使用によって決定されます）。"
    },
    {
      "indent": 3,
      "text": "2. The ICE agent initially places all candidate pairs in the Frozen state.",
      "ja": "2. ICEエージェントは、最初にすべての候補ペアをフローズン状態にします。"
    },
    {
      "indent": 3,
      "text": "3. The agent sets all of the checklists in the checklist set to the Running state.",
      "ja": "3.エージェントは、チェックリストセット内のすべてのチェックリストを実行状態に設定します。"
    },
    {
      "indent": 3,
      "text": "4. For each foundation, the agent sets the state of exactly one candidate pair to the Waiting state (unfreezing it). The candidate pair to unfreeze is chosen by finding the first candidate pair (ordered by the lowest component ID and then the highest priority if component IDs are equal) in the first checklist (according to the usage-defined checklist set order) that has that foundation.",
      "ja": "4.各ファンデーションについて、エージェントは1つの候補ペアの状態を待機状態（凍結解除）に設定します。 フリーズを解除する候補ペアは、その基礎を持つ最初のチェックリスト（使用法定義のチェックリストセットの順序による）で最初の候補ペア（コンポーネントIDが等しい場合は最も低いコンポーネントID、次に最高の優先順位）を見つけることによって選択されます 。"
    },
    {
      "indent": 3,
      "text": "NOTE: The procedures above are different from RFC 5245, where only candidate pairs in the first checklist were initially placed in the Waiting state. Now it applies to candidate pairs in the first checklist that have that foundation, even if the checklist is not the first one in the checklist set.",
      "ja": "注：上記の手順は、最初のチェックリストの候補ペアのみが最初に待機状態に置かれたRFC 5245とは異なります。 チェックリストがチェックリストセットの最初のものではない場合でも、その基礎を持つ最初のチェックリストの候補ペアに適用されるようになりました。"
    },
    {
      "indent": 3,
      "text": "The table below illustrates an example.",
      "ja": "次の表に例を示します。"
    },
    {
      "indent": 3,
      "text": "Table legend:",
      "ja": "表の凡例："
    },
    {
      "indent": 3,
      "text": "Each row (m1, m2,...) represents a checklist associated with a data stream. m1 represents the first checklist in the checklist set.",
      "ja": "各行（m1、m2、...）は、データストリームに関連付けられたチェックリストを表します。 m1は、チェックリストセットの最初のチェックリストを表します。"
    },
    {
      "indent": 3,
      "text": "Each column (f1, f2,...) represents a foundation. Every candidate pair within a given column share the same foundation.",
      "ja": "各列（f1、f2、...）は基盤を表します。 特定の列内のすべての候補者ペアは、同じ基盤を共有します。"
    },
    {
      "indent": 3,
      "text": "f-cp represents a candidate pair in the Frozen state.",
      "ja": "f-cpは、凍結状態の候補ペアを表します。"
    },
    {
      "indent": 3,
      "text": "w-cp represents a candidate pair in the Waiting state.",
      "ja": "w-cpは、待機状態の候補ペアを表します。"
    },
    {
      "indent": 3,
      "text": "1. The agent sets all of the pairs in the checklist set to the Frozen state.",
      "ja": "1.エージェントは、チェックリストセットのすべてのペアをフローズン状態に設定します。"
    },
    {
      "indent": 3,
      "text": "      f1    f2    f3    f4    f5\n    -----------------------------\nm1 | f-cp  f-cp  f-cp\n   |\nm2 | f-cp  f-cp  f-cp  f-cp\n   |\nm3 | f-cp                    f-cp",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. For each foundation, the candidate pair with the lowest component ID is placed in the Waiting state, unless a candidate pair associated with the same foundation has already been put in the Waiting state in one of the other examined checklists in the checklist set.",
      "ja": "2.各ファンデーションについて、チェックリストセット内の他の検査済みチェックリストのいずれかで同じファンデーションに関連付けられた候補ペアがすでに待機状態になっていない限り、コンポーネントIDが最小の候補ペアは待機状態になります。"
    },
    {
      "indent": 3,
      "text": "      f1    f2    f3    f4    f5\n    -----------------------------\nm1 | w-cp  w-cp  w-cp\n   |\nm2 | f-cp  f-cp  f-cp  w-cp\n   |\nm3 | f-cp                    w-cp",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 1: Pair State Example",
      "ja": "表1：ペア状態の例"
    },
    {
      "indent": 3,
      "text": "In the first checklist (m1), the candidate pair for each foundation is placed in the Waiting state, as no pairs for the same foundations have yet been placed in the Waiting state.",
      "ja": "最初のチェックリスト（m1）では、同じ基盤のペアがまだ待機状態になっていないため、各基盤の候補ペアは待機状態になっています。"
    },
    {
      "indent": 3,
      "text": "In the second checklist (m2), the candidate pair for foundation f4 is placed in the Waiting state. The candidate pair for foundations f1, f2, and f3 are kept in the Frozen state, as candidate pairs for those foundations have already been placed in the Waiting state (within checklist m1).",
      "ja": "2番目のチェックリスト（m2）では、ファンデーションf4の候補ペアが待機状態になります。 基礎f1、f2、およびf3の候補ペアは、それらの基礎の候補ペアが既に待機状態（チェックリストm1内）に置かれているため、凍結状態のままです。"
    },
    {
      "indent": 3,
      "text": "In the third checklist (m3), the candidate pair for foundation f5 is placed in the Waiting state. The candidate pair for foundation f1 is kept in the Frozen state, as a candidate pair for that foundation has already been placed in the Waiting state (within checklist m1).",
      "ja": "3番目のチェックリスト（m3）では、ファンデーションf5の候補ペアが待機状態になります。 ファンデーションf1の候補ペアは、そのファンデーションの候補ペアが既に待機状態（チェックリストm1内）に置かれているため、凍結状態のままになります。"
    },
    {
      "indent": 3,
      "text": "Once each checklist have been processed, one candidate pair for each foundation in the checklist set has been placed in the Waiting state.",
      "ja": "各チェックリストが処理されると、チェックリストセット内の各基盤の1つの候補ペアが待機状態になります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. ICE State",
      "section_title": true,
      "ja": "6.1.3.  ICE状態"
    },
    {
      "indent": 3,
      "text": "The ICE agent has a state determined by the state of the checklists. The state is Completed if all checklists are Completed, Failed if all checklists are Failed, or Running otherwise.",
      "ja": "ICEエージェントには、チェックリストの状態によって決定される状態があります。 状態は、すべてのチェックリストが完了した場合は完了、すべてのチェックリストが失敗した場合は失敗、その他の場合は実行中です。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Scheduling Checks",
      "section_title": true,
      "ja": "6.1.4.  スケジュールチェック"
    },
    {
      "indent": 0,
      "text": "6.1.4.1. Triggered-Check Queue",
      "section_title": true,
      "ja": "6.1.4.1。 トリガーチェックキュー"
    },
    {
      "indent": 3,
      "text": "Once the ICE agent has computed the checklists and created the checklist set, as described in Section 6.1.2, the agent will begin performing connectivity checks (ordinary and triggered). For triggered connectivity checks, the agent maintains a FIFO queue for each checklist, referred to as the \"triggered-check queue\", which contains candidate pairs for which checks are to be sent at the next available opportunity. The triggered-check queue is initially empty.",
      "ja": "セクション6.1.2で説明したように、ICEエージェントがチェックリストを計算し、チェックリストセットを作成すると、エージェントは接続チェック（通常およびトリガー）の実行を開始します。 トリガーされた接続性チェックの場合、エージェントは各チェックリストのFIFOキューを維持します。これは、「トリガーチェックキュー」と呼ばれ、次の利用可能な機会にチェックが送信される候補ペアを含みます。 トリガーされたチェックキューは最初は空です。"
    },
    {
      "indent": 0,
      "text": "6.1.4.2. Performing Connectivity Checks",
      "section_title": true,
      "ja": "6.1.4.2。 接続性チェックの実行"
    },
    {
      "indent": 3,
      "text": "The generation of ordinary and triggered connectivity checks is governed by timer Ta. As soon as the initial states for the candidate pairs in the checklist set have been set, a check is performed for a candidate pair within the first checklist in the Running state, following the procedures in Section 7. After that, whenever Ta fires the next checklist in the Running state in the checklist set is picked, and a check is performed for a candidate within that checklist. After the last checklist in the Running state in the checklist set has been processed, the first checklist is picked again, etc.",
      "ja": "通常のトリガーされた接続性チェックの生成は、タイマーTaによって制御されます。 チェックリストセット内の候補ペアの初期状態が設定されるとすぐに、セクション7の手順に従って、Running状態の最初のチェックリスト内の候補ペアに対してチェックが実行されます。その後、Taが次を起動するたびに チェックリストセットの実行状態のチェックリストが選択され、そのチェックリスト内の候補に対してチェックが実行されます。 チェックリストセットの実行状態の最後のチェックリストが処理された後、最初のチェックリストが再び選択されます。"
    },
    {
      "indent": 3,
      "text": "Whenever Ta fires, the ICE agent will perform a check for a candidate pair within the checklist that was picked by performing the following steps:",
      "ja": "Taが発動するたびに、ICEエージェントは、次の手順を実行することによって選択されたチェックリスト内の候補ペアのチェックを実行します。"
    },
    {
      "indent": 3,
      "text": "1. If the triggered-check queue associated with the checklist contains one or more candidate pairs, the agent removes the top pair from the queue, performs a connectivity check on that pair, puts the candidate pair state to In-Progress, and aborts the subsequent steps.",
      "ja": "1.チェックリストに関連付けられたトリガーチェックキューに1つ以上の候補ペアが含まれている場合、エージェントはキューから最上位ペアを削除し、そのペアで接続性チェックを実行し、候補ペアの状態を進行中にし、 その後の手順。"
    },
    {
      "indent": 3,
      "text": "2. If there is no candidate pair in the Waiting state, and if there are one or more pairs in the Frozen state, the agent checks the foundation associated with each pair in the Frozen state. For a given foundation, if there is no pair (in any checklist in the checklist set) in the Waiting or In-Progress state, the agent puts the candidate pair state to Waiting and continues with the next step.",
      "ja": "2.待機状態に候補ペアがなく、凍結状態に1つ以上のペアがある場合、エージェントは凍結状態の各ペアに関連付けられた基盤をチェックします。 特定の基盤について、待機中または進行中の状態のペアがない場合（チェックリストセットのいずれのチェックリストにも）、エージェントは候補ペアの状態を待機中にし、次のステップに進みます。"
    },
    {
      "indent": 3,
      "text": "3. If there are one or more candidate pairs in the Waiting state, the agent picks the highest-priority candidate pair (if there are multiple pairs with the same priority, the pair with the lowest component ID is picked) in the Waiting state, performs a connectivity check on that pair, puts the candidate pair state to In-Progress, and aborts the subsequent steps.",
      "ja": "3.待機状態の候補ペアが1つ以上ある場合、エージェントは待機状態で最高優先度の候補ペアを選択します（同じ優先度のペアが複数ある場合、最も低いコンポーネントIDのペアが選択されます）。 そのペアで接続性チェックを実行し、候補ペアの状態を進行中にし、後続の手順を中止します。"
    },
    {
      "indent": 3,
      "text": "4. If this step is reached, no check could be performed for the checklist that was picked. So, without waiting for timer Ta to expire again, select the next checklist in the Running state and return to step #1. If this happens for every single checklist in the Running state, meaning there are no remaining candidate pairs to perform connectivity checks for, abort these steps.",
      "ja": "4.このステップに達すると、選択されたチェックリストに対してチェックを実行できませんでした。 したがって、タイマーTaが再び期限切れになるのを待たずに、実行状態の次のチェックリストを選択して、手順1に戻ります。 Running状態のすべてのチェックリストでこれが発生する場合、つまり接続性チェックを実行する候補ペアが残っていない場合、これらの手順を中止します。"
    },
    {
      "indent": 3,
      "text": "Once the agent has picked a candidate pair for which a connectivity check is to be performed, the agent starts a check and sends the Binding request from the base associated with the local candidate of the pair to the remote candidate of the pair, as described in Section 7.2.4.",
      "ja": "エージェントが接続チェックを実行する候補ペアを選択すると、エージェントはチェックを開始し、ペアのローカル候補に関連付けられているベースからペアのリモート候補にバインディング要求を送信します。 セクション7.2.4"
    },
    {
      "indent": 3,
      "text": "Based on local policy, an agent MAY choose to terminate performing the connectivity checks for one or more checklists in the checklist set at any time. However, only the controlling agent is allowed to conclude ICE (Section 8).",
      "ja": "ローカルポリシーに基づいて、エージェントは、チェックリストセット内の1つ以上のチェックリストの接続チェックの実行をいつでも終了することを選択できます。 ただし、ICEを終了できるのは制御エージェントのみです（セクション8）。"
    },
    {
      "indent": 3,
      "text": "To compute the message integrity for the check, the agent uses the remote username fragment and password learned from the candidate information obtained from its peer. The local username fragment is known directly by the agent for its own candidate.",
      "ja": "チェックのメッセージ整合性を計算するために、エージェントはピアから取得した候補情報から学習したリモートユーザー名フラグメントとパスワードを使用します。 ローカルユーザー名のフラグメントは、エージェントによって自身の候補として直接認識されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Lite Implementation Procedures",
      "section_title": true,
      "ja": "6.2.  Liteの実装手順"
    },
    {
      "indent": 3,
      "text": "Lite implementations skip most of the steps in Section 6 except for verifying the peer's ICE support and determining its role in the ICE processing.",
      "ja": "Liteの実装では、ピアのICEサポートを確認し、ICE処理での役割を決定することを除いて、セクション6のほとんどの手順をスキップします。"
    },
    {
      "indent": 3,
      "text": "If the lite implementation is the controlling agent (which will only happen if the peer ICE agent is also a lite implementation), it selects a candidate pair based on the ones in the candidate exchange (for IPv4, there is only ever one pair) and then updates the peer with the new candidate information reflecting that selection, if needed (it is never needed for an IPv4-only host).",
      "ja": "ライトの実装が制御エージェントである場合（ピアICEエージェントもライトの実装である場合にのみ発生します）、候補交換のペアに基づいて候補ペアを選択します（IPv4の場合、ペアは1つのみです）。 次に、必要に応じて、その選択を反映する新しい候補情報でピアを更新します（IPv4のみのホストには必要ありません）。"
    },
    {
      "indent": 0,
      "text": "7. Performing Connectivity Checks",
      "section_title": true,
      "ja": "7.接続性チェックの実行"
    },
    {
      "indent": 3,
      "text": "This section describes how connectivity checks are performed.",
      "ja": "このセクションでは、接続チェックの実行方法について説明します。"
    },
    {
      "indent": 3,
      "text": "An ICE agent MUST be compliant to [RFC5389]. A full implementation acts both as a STUN client and a STUN server, while a lite implementation only acts as a STUN server (as it does not generate connectivity checks).",
      "ja": "ICEエージェントは[RFC5389]に準拠する必要があります。 完全な実装はSTUNクライアントとSTUNサーバーの両方として機能しますが、ライト実装はSTUNサーバーとしてのみ機能します（接続チェックを生成しないため）。"
    },
    {
      "indent": 0,
      "text": "7.1. STUN Extensions",
      "section_title": true,
      "ja": "7.1.  STUNエクステンション"
    },
    {
      "indent": 3,
      "text": "ICE extends STUN with the attributes: PRIORITY, USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING. These attributes are formally defined in Section 16.1. This section describes the usage of the attributes.",
      "ja": "ICEは、属性PRIORITY、USE-CANDIDATE、ICE-CONTROLLED、およびICE-CONTROLLINGでSTUNを拡張します。 これらの属性は、16.1項で正式に定義されています。 このセクションでは、属性の使用法について説明します。"
    },
    {
      "indent": 3,
      "text": "The attributes are only applicable to ICE connectivity checks.",
      "ja": "属性は、ICE接続チェックにのみ適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. PRIORITY",
      "section_title": true,
      "ja": "7.1.1.  優先"
    },
    {
      "indent": 3,
      "text": "The PRIORITY attribute MUST be included in a Binding request and be set to the value computed by the algorithm in Section 5.1.2 for the local candidate, but with the candidate type preference of peer-reflexive candidates.",
      "ja": "PRIORITY属性はBinding要求に含まれなければならず、ローカル候補に対してセクション5.1.2のアルゴリズムによって計算された値に設定されなければなりませんが、ピア反射候補の候補タイプの優先順位があります。"
    },
    {
      "indent": 0,
      "text": "7.1.2. USE-CANDIDATE",
      "section_title": true,
      "ja": "7.1.2.  使用候補"
    },
    {
      "indent": 3,
      "text": "The controlling agent MUST include the USE-CANDIDATE attribute in order to nominate a candidate pair (Section 8.1.1). The controlled agent MUST NOT include the USE-CANDIDATE attribute in a Binding request.",
      "ja": "制御エージェントは、候補ペアを指定するためにUSE-CANDIDATE属性を含めなければなりません（セクション8.1.1）。 制御されたエージェントは、バインディング要求にUSE-CANDIDATE属性を含めてはなりません。"
    },
    {
      "indent": 0,
      "text": "7.1.3. ICE-CONTROLLED and ICE-CONTROLLING",
      "section_title": true,
      "ja": "7.1.3.  ICE-CONTROLLEDおよびICE-CONTROLLING"
    },
    {
      "indent": 3,
      "text": "The controlling agent MUST include the ICE-CONTROLLING attribute in a Binding request. The controlled agent MUST include the ICE-CONTROLLED attribute in a Binding request.",
      "ja": "制御エージェントは、バインディング要求にICE-CONTROLLING属性を含める必要があります。 管理対象エージェントは、バインディング要求にICE-CONTROLLED属性を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The content of either attribute is used as tiebreaker values when an ICE role conflict occurs (Section 7.3.1.1).",
      "ja": "ICEロールの競合が発生すると、いずれかの属性のコンテンツがタイブレーカー値として使用されます（7.3.1.1項）。"
    },
    {
      "indent": 0,
      "text": "7.2. STUN Client Procedures",
      "section_title": true,
      "ja": "7.2.  STUNクライアントの手順"
    },
    {
      "indent": 0,
      "text": "7.2.1. Creating Permissions for Relayed Candidates",
      "section_title": true,
      "ja": "7.2.1.  リレーされた候補者の許可の作成"
    },
    {
      "indent": 3,
      "text": "If the connectivity check is being sent using a relayed local candidate, the client MUST create a permission first if it has not already created one previously. It would have created one previously if it had told the TURN server to create a permission for the given relayed candidate towards the IP address of the remote candidate. To create the permission, the ICE agent follows the procedures defined in [RFC5766]. The permission MUST be created towards the IP address of the remote candidate. It is RECOMMENDED that the agent defer creation of a TURN channel until ICE completes, in which case permissions for connectivity checks are normally created using a CreatePermission request. Once established, the agent MUST keep the permission active until ICE concludes.",
      "ja": "リレーされたローカル候補を使用して接続性チェックが送信されている場合、以前に許可を作成していない場合、クライアントはまず許可を作成する必要があります。 TURNサーバーに、リモート候補のIPアドレスに対する特定のリレー候補の許可を作成するように指示した場合、以前に作成されていたはずです。 許可を作成するために、ICEエージェントは[RFC5766]で定義された手順に従います。 リモートの候補者のIPアドレスに対して許可を作成する必要があります。 エージェントはICEが完了するまでTURNチャネルの作成を延期することをお勧めします。その場合、接続チェックの許可は通常、CreatePermission要求を使用して作成されます。 いったん確立されると、エージェントは、ICEが終了するまで許可をアクティブに維持する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Forming Credentials",
      "section_title": true,
      "ja": "7.2.2.  資格情報の形成"
    },
    {
      "indent": 3,
      "text": "A connectivity-check Binding request MUST utilize the STUN short-term credential mechanism.",
      "ja": "接続性検査バインディング要求は、STUN短期資格情報メカニズムを利用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The username for the credential is formed by concatenating the username fragment provided by the peer with the username fragment of the ICE agent sending the request, separated by a colon (\":\").",
      "ja": "資格情報のユーザー名は、ピアが提供するユーザー名フラグメントと、要求を送信するICEエージェントのユーザー名フラグメントを、コロン（ \"：\"）で区切って連結することにより形成されます。"
    },
    {
      "indent": 3,
      "text": "The password is equal to the password provided by the peer.",
      "ja": "パスワードは、ピアから提供されたパスワードと同じです。"
    },
    {
      "indent": 3,
      "text": "For example, consider the case where ICE agent L is the initiating agent and ICE agent R is the responding agent. Agent L included a username fragment of LFRAG for its candidates and a password of LPASS. Agent R provided a username fragment of RFRAG and a password of RPASS. A connectivity check from L to R utilizes the username RFRAG:LFRAG and a password of RPASS. A connectivity check from R to L utilizes the username LFRAG:RFRAG and a password of LPASS. The responses utilize the same usernames and passwords as the requests (note that the USERNAME attribute is not present in the response).",
      "ja": "たとえば、ICEエージェントLが開始エージェントであり、ICEエージェントRが応答エージェントである場合を考えます。 エージェントLには、候補のLFRAGのユーザー名フラグメントとLPASSのパスワードが含まれていました。 エージェントRは、RFRAGのユーザー名フラグメントとRPASSのパスワードを提供しました。 LからRへの接続チェックでは、ユーザー名RFRAG：LFRAGとパスワードRPASSを使用します。 RからLへの接続チェックでは、ユーザー名LFRAG：RFRAGとパスワードLPASSを使用します。 応答では、要求と同じユーザー名とパスワードが使用されます（応答にUSERNAME属性が存在しないことに注意してください）。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Diffserv Treatment",
      "section_title": true,
      "ja": "7.2.3.  Diffserv処理"
    },
    {
      "indent": 3,
      "text": "If the agent is using Differentiated Services Code Point (DSCP) markings [RFC2475] in data packets that it will send, the agent SHOULD apply the same markings to Binding requests and responses that it will send.",
      "ja": "エージェントが送信するデータパケットでDiffServコードポイント（DSCP）マーキング[RFC2475]を使用している場合、エージェントは、送信するバインディングリクエストとレスポンスに同じマーキングを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple DSCP markings are used on the data packets, the agent SHOULD choose one of them for use with the connectivity check.",
      "ja": "データパケットで複数のDSCPマーキングが使用されている場合、エージェントは接続チェックで使用するためにそれらの1つを選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.4. Sending the Request",
      "section_title": true,
      "ja": "7.2.4.  リクエストを送信する"
    },
    {
      "indent": 3,
      "text": "A connectivity check is generated by sending a Binding request from the base associated with a local candidate to a remote candidate. [RFC5389] describes how Binding requests are constructed and generated.",
      "ja": "接続候補チェックは、ローカル候補に関連付けられたベースからリモート候補にバインディング要求を送信することにより生成されます。 [RFC5389]は、バインディング要求がどのように構築および生成されるかを説明しています。"
    },
    {
      "indent": 3,
      "text": "Support for backwards compatibility with RFC 3489 MUST NOT be assumed when performing connectivity checks. The FINGERPRINT mechanism MUST be used for connectivity checks.",
      "ja": "接続性チェックを実行するとき、RFC 3489との後方互換性のサポートを想定してはなりません。 FINGERPRINTメカニズムは、接続性チェックに使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5. Processing the Response",
      "section_title": true,
      "ja": "7.2.5.  応答の処理"
    },
    {
      "indent": 3,
      "text": "This section defines additional procedures for processing Binding responses specific to ICE connectivity checks.",
      "ja": "このセクションでは、ICE接続チェックに固有のバインディング応答を処理するための追加手順を定義します。"
    },
    {
      "indent": 3,
      "text": "When a Binding response is received, it is correlated to the corresponding Binding request using the transaction ID [RFC5389], which then associates the response with the candidate pair for which the Binding request was sent. After that, the response is processed according to the procedures for a role conflict, a failure, or a success, according to the procedures below.",
      "ja": "バインディング応答が受信されると、トランザクションID [RFC5389]を使用して対応するバインディング要求に関連付けられ、バインディング要求が送信された候補ペアに応答が関連付けられます。 その後、以下の手順に従って、役割の競合、失敗、または成功の手順に従って応答が処理されます。"
    },
    {
      "indent": 0,
      "text": "7.2.5.1. Role Conflict",
      "section_title": true,
      "ja": "7.2.5.1。 ロールの競合"
    },
    {
      "indent": 3,
      "text": "If the Binding request generates a 487 (Role Conflict) error response (Section 7.3.1.1), and if the ICE agent included an ICE-CONTROLLED attribute in the request, the agent MUST switch to the controlling role. If the agent included an ICE-CONTROLLING attribute in the request, the agent MUST switch to the controlled role.",
      "ja": "Binding要求が487（Role Conflict）エラー応答（7.3.1.1項）を生成し、ICEエージェントが要求にICE-CONTROLLED属性を含めた場合、エージェントは制御ロールに切り替えなければなりません（MUST）。 エージェントがリクエストにICE-CONTROLLING属性を含めた場合、エージェントは制御されたロールに切り替えなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the agent has switched its role, the agent MUST add the candidate pair whose check generated the 487 error response to the triggered-check queue associated with the checklist to which the pair belongs, and set the candidate pair state to Waiting. When the triggered connectivity check is later performed, the ICE-CONTROLLING/ ICE-CONTROLLED attribute of the Binding request will indicate the agent's new role. The agent MUST change the tiebreaker value.",
      "ja": "エージェントが役割を切り替えたら、エージェントは、チェックが487エラー応答を生成した候補ペアを、ペアが属するチェックリストに関連付けられたトリガーチェックキューに追加し、候補ペアの状態を待機に設定する必要があります。 トリガーされた接続性チェックが後で実行されるとき、バインディング要求のICE-CONTROLLING / ICE-CONTROLLED属性は、エージェントの新しい役割を示します。 エージェントは、タイブレーカーの値を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: A role switch requires an agent to recompute pair priorities (Section 6.1.2.3), since the priority values depend on the role.",
      "ja": "注記：優先度の値はロールに依存するため、ロールの切り替えではペアの優先度（6.1.2.3項）を再計算するエージェントが必要です。"
    },
    {
      "indent": 3,
      "text": "NOTE: A role switch will also impact whether the agent is responsible for nominating candidate pairs, and whether the agent is responsible for initiating the exchange of the updated candidate information with the peer once ICE is concluded.",
      "ja": "注：役割の切り替えは、エージェントが候補ペアを指名する責任があるかどうか、およびエージェントがICEの終了後にピアとの更新された候補情報の交換を開始する責任があるかどうかにも影響します。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2. Failure",
      "section_title": true,
      "ja": "7.2.5.2。 失敗"
    },
    {
      "indent": 3,
      "text": "This section describes cases when the candidate pair state is set to Failed.",
      "ja": "このセクションでは、候補ペアの状態が「失敗」に設定されている場合について説明します。"
    },
    {
      "indent": 3,
      "text": "NOTE: When the ICE agent sets the candidate pair state to Failed as a result of a connectivity-check error, the agent does not change the states of other candidate pairs with the same foundation.",
      "ja": "注：接続性チェックエラーの結果、ICEエージェントが候補ペアの状態を失敗に設定すると、エージェントは同じ基盤を持つ他の候補ペアの状態を変更しません。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2.1. Non-Symmetric Transport Addresses",
      "section_title": true,
      "ja": "7.2.5.2.1。 非対称のトランスポートアドレス"
    },
    {
      "indent": 3,
      "text": "The ICE agent MUST check that the source and destination transport addresses in the Binding request and response are symmetric. That is, the source IP address and port of the response MUST be equal to the destination IP address and port to which the Binding request was sent, and the destination IP address and port of the response MUST be equal to the source IP address and port from which the Binding request was sent. If the addresses are not symmetric, the agent MUST set the candidate pair state to Failed.",
      "ja": "ICEエージェントは、バインディング要求と応答の送信元と宛先のトランスポートアドレスが対称であることを確認する必要があります。 つまり、応答のソースIPアドレスとポートは、バインディング要求が送信された宛先IPアドレスとポートに等しくなければならず、応答の宛先IPアドレスとポートはソースIPアドレスとポートに等しくなければなりません。 バインディングリクエストの送信元。 アドレスが対称ではない場合、エージェントは候補ペアの状態を失敗に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2.2. ICMP Error",
      "section_title": true,
      "ja": "7.2.5.2.2。 ICMPエラー"
    },
    {
      "indent": 3,
      "text": "An ICE agent MAY support processing of ICMP errors for connectivity checks. If the agent supports processing of ICMP errors, and if a Binding request generates a hard ICMP error, the agent SHOULD set the state of the candidate pair to Failed. Implementers need to be aware that ICMP errors can be used as a method for Denial-of-Service (DoS) attacks when making a decision on how and if to process ICMP errors.",
      "ja": "ICEエージェントは、接続性チェックのためのICMPエラーの処理をサポートする場合があります。 エージェントがICMPエラーの処理をサポートし、バインディング要求がハードICMPエラーを生成する場合、エージェントは候補ペアの状態を失敗に設定する必要があります。 実装者は、ICMPエラーの処理方法と処理方法を決定する際に、ICMPエラーをサービス拒否（DoS）攻撃の方法として使用できることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2.3. Timeout",
      "section_title": true,
      "ja": "7.2.5.2.3。 タイムアウト"
    },
    {
      "indent": 3,
      "text": "If the Binding request transaction times out, the ICE agent MUST set the candidate pair state to Failed.",
      "ja": "バインド要求トランザクションがタイムアウトした場合、ICEエージェントは候補ペアの状態を失敗に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.2.4. Unrecoverable STUN Response",
      "section_title": true,
      "ja": "7.2.5.2.4。 回復不能なSTUN応答"
    },
    {
      "indent": 3,
      "text": "If the Binding request generates a STUN error response that is unrecoverable [RFC5389], the ICE agent SHOULD set the candidate pair state to Failed.",
      "ja": "バインディング要求が回復不能な[RFC5389]のSTUNエラー応答を生成する場合、ICEエージェントは候補ペアの状態を[失敗]に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.3. Success",
      "section_title": true,
      "ja": "7.2.5.3。 成功"
    },
    {
      "indent": 3,
      "text": "A connectivity check is considered a success if each of the following criteria is true:",
      "ja": "次の各基準に該当する場合、接続チェックは成功と見なされます。"
    },
    {
      "indent": 3,
      "text": "o The Binding request generated a success response; and",
      "ja": "oバインディングリクエストは成功レスポンスを生成しました。 そして"
    },
    {
      "indent": 3,
      "text": "o The source and destination transport addresses in the Binding request and response are symmetric.",
      "ja": "oバインディング要求と応答の送信元と宛先のトランスポートアドレスは対称です。"
    },
    {
      "indent": 3,
      "text": "If a check is considered a success, the ICE agent performs (in order) the actions described in the following sections.",
      "ja": "チェックが成功したと見なされる場合、ICEエージェントは以下のセクションで説明されているアクションを（順番に）実行します。"
    },
    {
      "indent": 0,
      "text": "7.2.5.3.1. Discovering Peer-Reflexive Candidates",
      "section_title": true,
      "ja": "7.2.5.3.1。 ピア反射候補の発見"
    },
    {
      "indent": 3,
      "text": "The ICE agent MUST check the mapped address from the STUN response. If the transport address does not match any of the local candidates that the agent knows about, the mapped address represents a new candidate: a peer-reflexive candidate. Like other candidates, a peer-reflexive candidate has a type, base, priority, and foundation. They are computed as follows:",
      "ja": "ICEエージェントは、STUN応答からマッピングされたアドレスを確認する必要があります。 トランスポートアドレスがエージェントが知っているローカル候補のいずれとも一致しない場合、マッピングアドレスは新しい候補、つまりピア再帰候補を表します。 他の候補者と同様に、ピア反射候補者にはタイプ、ベース、優先度、および基盤があります。 それらは次のように計算されます。"
    },
    {
      "indent": 3,
      "text": "o The type is peer reflexive.",
      "ja": "oタイプはピア再帰的です。"
    },
    {
      "indent": 3,
      "text": "o The base is the local candidate of the candidate pair from which the Binding request was sent.",
      "ja": "oベースは、バインディングリクエストが送信された候補ペアのローカル候補です。"
    },
    {
      "indent": 3,
      "text": "o The priority is the value of the PRIORITY attribute in the Binding request.",
      "ja": "o優先度は、バインディングリクエストのPRIORITY属性の値です。"
    },
    {
      "indent": 3,
      "text": "o The foundation is described in Section 5.1.1.3.",
      "ja": "o基礎はセクション5.1.1.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "The peer-reflexive candidate is then added to the list of local candidates for the data stream. The username fragment and password are the same as for all other local candidates for that data stream.",
      "ja": "ピア反射候補は、データストリームのローカル候補のリストに追加されます。 ユーザー名のフラグメントとパスワードは、そのデータストリームの他のすべてのローカル候補と同じです。"
    },
    {
      "indent": 3,
      "text": "The ICE agent does not need to pair the peer-reflexive candidate with remote candidates, as a valid pair will be created due to the procedures in Section 7.2.5.3.2. If an agent wishes to pair the peer-reflexive candidate with remote candidates other than the one in the valid pair that will be generated, the agent MAY provide updated candidate information to the peer that includes the peer-reflexive candidate. This will cause the peer-reflexive candidate to be paired with all other remote candidates.",
      "ja": "有効なペアはセクション7.2.5.3.2の手順により作成されるため、ICEエージェントはピア反射候補とリモート候補をペアにする必要はありません。 エージェントがピア反射候補を、生成される有効なペアのペア以外のリモート候補とペアリングすることを希望する場合、エージェントは、ピア反射候補を含むピアに更新された候補情報を提供することができます。 これにより、ピア反射候補が他のすべてのリモート候補とペアになります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.3.2. Constructing a Valid Pair",
      "section_title": true,
      "ja": "7.2.5.3.2。 有効なペアの構築"
    },
    {
      "indent": 3,
      "text": "The ICE agent constructs a candidate pair whose local candidate equals the mapped address of the response and whose remote candidate equals the destination address to which the request was sent. This is called a \"valid pair\".",
      "ja": "ICEエージェントは、ローカル候補が応答のマッピングアドレスに等しく、リモート候補が要求の送信先アドレスに等しい候補ペアを構築します。 これは「有効なペア」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The valid pair might equal the pair that generated the connectivity check, a different pair in the checklist, or a pair currently not in the checklist.",
      "ja": "有効なペアは、接続チェックを生成したペア、チェックリスト内の別のペア、または現在チェックリストにないペアと等しい場合があります。"
    },
    {
      "indent": 3,
      "text": "The agent maintains a separate list, referred to as the \"valid list\". There is a valid list for each checklist in the checklist set. The valid list will contain valid pairs. Initially, each valid list is empty.",
      "ja": "エージェントは、「有効なリスト」と呼ばれる別のリストを保持します。 チェックリストセットの各チェックリストに有効なリストがあります。 有効なリストには有効なペアが含まれます。 最初は、有効な各リストは空です。"
    },
    {
      "indent": 3,
      "text": "Each valid pair within the valid list has a flag, called the \"nominated flag\". When a valid pair is added to a valid list, the flag value is set to 'false'.",
      "ja": "有効なリスト内の各有効なペアには、「指定フラグ」と呼ばれるフラグがあります。 有効なペアが有効なリストに追加されると、フラグ値は「false」に設定されます。"
    },
    {
      "indent": 3,
      "text": "The valid pair will be added to a valid list as follows:",
      "ja": "有効なペアは、次のように有効なリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "1. If the valid pair equals the pair that generated the check, the pair is added to the valid list associated with the checklist to which the pair belongs; or",
      "ja": "1.有効なペアがチェックを生成したペアと等しい場合、ペアは、ペアが属するチェックリストに関連付けられた有効なリストに追加されます。 または"
    },
    {
      "indent": 3,
      "text": "2. If the valid pair equals another pair in a checklist, that pair is added to the valid list associated with the checklist of that pair. The pair that generated the check is not added to a valid list; or",
      "ja": "2.有効なペアがチェックリスト内の別のペアと等しい場合、そのペアはそのペアのチェックリストに関連付けられた有効なリストに追加されます。 チェックを生成したペアは有効なリストに追加されません。 または"
    },
    {
      "indent": 3,
      "text": "3. If the valid pair is not in any checklist, the agent computes the priority for the pair based on the priority of each candidate, using the algorithm in Section 6.1.2. The priority of the local candidate depends on its type. Unless the type is peer reflexive, the priority is equal to the priority signaled for that candidate in the candidate exchange. If the type is peer reflexive, it is equal to the PRIORITY attribute the agent placed in the Binding request that just completed. The priority of the remote candidate is taken from the candidate information of the peer. If the candidate does not appear there, then the check has been a triggered check to a new remote candidate. In that case, the priority is taken as the value of the PRIORITY attribute in the Binding request that triggered the check that just completed. The pair is then added to the valid list.",
      "ja": "3.有効なペアがチェックリストにない場合、エージェントはセクション6.1.2のアルゴリズムを使用して、各候補の優先度に基づいてペアの優先度を計算します。 ローカル候補者の優先順位は、そのタイプによって異なります。 タイプがピア再帰型でない限り、優先順位は、候補交換でその候補に対して通知された優先順位と等しくなります。 タイプがピア再帰型である場合、エージェントは、完了したばかりのバインディングリクエストに配置されたPRIORITY属性と同じです。 リモート候補の優先度は、ピアの候補情報から取得されます。 候補がそこに表示されない場合、チェックは新しいリモート候補に対するトリガーチェックです。 その場合、優先度は、完了したチェックをトリガーしたバインディング要求のPRIORITY属性の値として取得されます。 ペアは有効なリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "NOTE: It will be very common that the valid pair will not be in any checklist. Recall that the checklist has pairs whose local candidates are never reflexive; those pairs had their local candidates converted to the base of the reflexive candidates and were then pruned if they were redundant. When the response to the Binding request arrives, the mapped address will be reflexive if there is a NAT between the two. In that case, the valid pair will have a local candidate that doesn't match any of the pairs in the checklist.",
      "ja": "注：有効なペアがチェックリストにないことは非常に一般的です。 チェックリストには、ローカル候補が決して再帰的ではないペアがあることを思い出してください。 これらのペアは、ローカル候補を反射候補のベースに変換し、冗長な場合は剪定しました。 バインディング要求への応答が到着すると、2つの間にNATがある場合、マッピングアドレスは再帰的になります。 その場合、有効なペアには、チェックリスト内のどのペアとも一致しないローカル候補があります。"
    },
    {
      "indent": 0,
      "text": "7.2.5.3.3. Updating Candidate Pair States",
      "section_title": true,
      "ja": "7.2.5.3.3。 候補ペア状態の更新"
    },
    {
      "indent": 3,
      "text": "The ICE agent sets the states of both the candidate pair that generated the check and the constructed valid pair (which may be different) to Succeeded.",
      "ja": "ICEエージェントは、チェックを生成した候補ペアと構築された有効なペア（異なる場合があります）の両方の状態をSucceededに設定します。"
    },
    {
      "indent": 3,
      "text": "The agent MUST set the states for all other Frozen candidate pairs in all checklists with the same foundation to Waiting.",
      "ja": "エージェントは、同じ基盤を持つすべてのチェックリストの他のすべての凍結候補ペアの状態を待機に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: Within a given checklist, candidate pairs with the same foundations will typically have different component ID values.",
      "ja": "注：特定のチェックリスト内で、同じ基盤を持つ候補ペアは通常、異なるコンポーネントID値を持ちます。"
    },
    {
      "indent": 0,
      "text": "7.2.5.3.4. Updating the Nominated Flag",
      "section_title": true,
      "ja": "7.2.5.3.4。 ノミネートされたフラグの更新"
    },
    {
      "indent": 3,
      "text": "If the controlling agent sends a Binding request with the USE-CANDIDATE attribute set, and if the ICE agent receives a successful response to the request, the agent sets the nominated flag of the pair to true. If the request fails (Section 7.2.5.2), the agent MUST remove the candidate pair from the valid list, set the candidate pair state to Failed, and set the checklist state to Failed.",
      "ja": "制御エージェントがUSE-CANDIDATE属性が設定されたバインディング要求を送信し、ICEエージェントが要求に対する正常な応答を受信した場合、エージェントはペアの指定フラグをtrueに設定します。 要求が失敗した場合（7.2.5.2項）、エージェントは有効なリストから候補ペアを削除し、候補ペアの状態を失敗に設定し、チェックリストの状態を失敗に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the controlled agent receives a successful response to a Binding request sent by the agent, and that Binding request was triggered by a received Binding request with the USE-CANDIDATE attribute set (Section 7.3.1.4), the agent sets the nominated flag of the pair to true. If the triggered request fails, the agent MUST remove the candidate pair from the valid list, set the candidate pair state to Failed, and set the checklist state to Failed.",
      "ja": "制御されたエージェントが、エージェントによって送信されたバインディング要求への正常な応答を受信し、そのバインディング要求が、USE-CANDIDATE属性セット（7.3.1.4節）で受信したバインディング要求によってトリガーされた場合、エージェントは、 真のペア。 トリガーされた要求が失敗した場合、エージェントは有効なリストから候補ペアを削除し、候補ペアの状態を失敗に設定し、チェックリストの状態を失敗に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the nominated flag is set for a component of a data stream, it concludes the ICE processing for that component (Section 8).",
      "ja": "指定されたフラグがデータストリームのコンポーネントに設定されると、そのコンポーネントのICE処理が終了します（セクション8）。"
    },
    {
      "indent": 0,
      "text": "7.2.5.4. Checklist State Updates",
      "section_title": true,
      "ja": "7.2.5.4。 チェックリスト状態の更新"
    },
    {
      "indent": 3,
      "text": "Regardless of whether a connectivity check was successful or failed, the completion of the check may require updating of checklist states. For each checklist in the checklist set, if all of the candidate pairs are in either Failed or Succeeded state, and if there is not a valid pair in the valid list for each component of the data stream associated with the checklist, the state of the checklist is set to Failed. If there is a valid pair for each component in the valid list, the state of the checklist is set to Succeeded.",
      "ja": "接続チェックが成功したか失敗したかに関係なく、チェックの完了にはチェックリスト状態の更新が必要になる場合があります。 チェックリストセット内の各チェックリストについて、すべての候補ペアが失敗または成功のいずれかの状態にあり、チェックリストに関連付けられたデータストリームの各コンポーネントの有効なリストに有効なペアがない場合、 チェックリストは失敗に設定されます。 有効なリストの各コンポーネントに有効なペアがある場合、チェックリストの状態は成功に設定されます。"
    },
    {
      "indent": 0,
      "text": "7.3. STUN Server Procedures",
      "section_title": true,
      "ja": "7.3.  STUNサーバーの手順"
    },
    {
      "indent": 3,
      "text": "An ICE agent (lite or full) MUST be prepared to receive Binding requests on the base of each candidate it included in its most recent candidate exchange.",
      "ja": "ICEエージェント（ライトまたはフル）は、最新の候補者交換に含まれる各候補者のベースでバインディングリクエストを受信する準備をする必要があります。"
    },
    {
      "indent": 3,
      "text": "The agent MUST use the short-term credential mechanism (i.e., the MESSAGE-INTEGRITY attribute) to authenticate the request and perform a message integrity check. Likewise, the short-term credential mechanism MUST be used for the response. The agent MUST consider the username to be valid if it consists of two values separated by a colon, where the first value is equal to the username fragment generated by the agent in a candidate exchange for a session in progress. It is possible (and in fact very likely) that the initiating agent will receive a Binding request prior to receiving the candidates from its peer. If this happens, the agent MUST immediately generate a response (including computation of the mapped address as described in Section 7.3.1.2). The agent has sufficient information at this point to generate the response; the password from the peer is not required. Once the answer is received, it MUST proceed with the remaining steps required; namely, see Sections 7.3.1.3, 7.3.1.4, and 7.3.1.5 for full implementations. In cases where multiple STUN requests are received before the answer, this may cause several pairs to be queued up in the triggered-check queue.",
      "ja": "エージェントは、短期的な認証メカニズム（つまり、MESSAGE-INTEGRITY属性）を使用して、要求を認証し、メッセージの整合性チェックを実行する必要があります。同様に、応答には短期間の資格情報メカニズムを使用する必要があります。エージェントは、コロンで区切られた2つの値で構成されている場合、ユーザー名が有効であると考えなければなりません。最初の値は、進行中のセッションの候補交換でエージェントによって生成されたユーザー名フラグメントと等しくなります。ピアから候補を受信する前に、開始エージェントがバインディング要求を受信する可能性があります（実際には非常に可能性が高い）。これが発生した場合、エージェントはすぐに応答を生成する必要があります（セクション7.3.1.2で説明されているマッピングアドレスの計算を含む）。この時点で、エージェントは応答を生成するのに十分な情報を持っています。ピアからのパスワードは必要ありません。回答を受け取ったら、必要な残りの手順を続行する必要があります。つまり、完全な実装については、セクション7.3.1.3、7.3.1.4、および7.3.1.5を参照してください。回答の前に複数のSTUN要求を受信した場合、これにより、トリガーチェックキューにいくつかのペアがキューイングされることがあります。"
    },
    {
      "indent": 3,
      "text": "An agent MUST NOT utilize the ALTERNATE-SERVER mechanism and MUST NOT support the backwards-compatibility mechanisms defined in RFC 5389 (for working with the protocol in RFC 3489). It MUST utilize the FINGERPRINT mechanism.",
      "ja": "エージェントは、ALTERNATE-SERVERメカニズムを利用してはならず、RFC 5389で定義されている後方互換性メカニズムをサポートしてはなりません（RFC 3489でプロトコルを使用するため）。 FINGERPRINTメカニズムを利用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the agent is using DSCP markings [RFC2475] in its data packets, it SHOULD apply the same markings to Binding responses. The same would apply to any Layer 2 markings the endpoint might be applying to data packets.",
      "ja": "エージェントがデータパケットでDSCPマーキング[RFC2475]を使用している場合、バインディングレスポンスに同じマーキングを適用する必要があります。 同じことが、エンドポイントがデータパケットに適用する可能性のあるレイヤー2マーキングにも適用されます。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Additional Procedures for Full Implementations",
      "section_title": true,
      "ja": "7.3.1.  完全実装の追加手順"
    },
    {
      "indent": 3,
      "text": "This subsection defines the additional server procedures applicable to full implementations, when the full implementation accepts the Binding request.",
      "ja": "このサブセクションでは、完全な実装がBinding要求を受け入れる場合に、完全な実装に適用可能な追加のサーバー手順を定義します。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1. Detecting and Repairing Role Conflicts",
      "section_title": true,
      "ja": "7.3.1.1。 ロールの競合の検出と修復"
    },
    {
      "indent": 3,
      "text": "In certain usages of ICE (such as 3PCC), both ICE agents may end up choosing the same role, resulting in a role conflict. The section describes a mechanism for detecting and repairing role conflicts. The usage document MUST specify whether this mechanism is needed.",
      "ja": "ICEの特定の使用（3PCCなど）では、両方のICEエージェントが同じ役割を選択し、役割の競合が発生する場合があります。 このセクションでは、ロールの競合を検出および修復するメカニズムについて説明します。 使用法文書では、このメカニズムが必要かどうかを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "An agent MUST examine the Binding request for either the ICE-CONTROLLING or ICE-CONTROLLED attribute. It MUST follow these procedures:",
      "ja": "エージェントは、ICE-CONTROLLINGまたはICE-CONTROLLED属性のいずれかのバインディング要求を検査する必要があります。 次の手順に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the agent is in the controlling role, and the ICE-CONTROLLING attribute is present in the request:",
      "ja": "oエージェントが制御ロールにあり、リクエストにICE-CONTROLLING属性が存在する場合："
    },
    {
      "indent": 6,
      "text": "* If the agent's tiebreaker value is larger than or equal to the contents of the ICE-CONTROLLING attribute, the agent generates a Binding error response and includes an ERROR-CODE attribute with a value of 487 (Role Conflict) but retains its role.",
      "ja": "*エージェントのタイブレーカー値がICE-CONTROLLING属性の内容以上の場合、エージェントはバインディングエラー応答を生成し、487（ロール競合）の値を持つERROR-CODE属性を含めますが、その役割は保持します。"
    },
    {
      "indent": 6,
      "text": "* If the agent's tiebreaker value is less than the contents of the ICE-CONTROLLING attribute, the agent switches to the controlled role.",
      "ja": "*エージェントのタイブレーカー値がICE-CONTROLLING属性の内容よりも小さい場合、エージェントは制御された役割に切り替わります。"
    },
    {
      "indent": 3,
      "text": "o If the agent is in the controlled role, and the ICE-CONTROLLED attribute is present in the request:",
      "ja": "oエージェントが制御された役割にあり、リクエストにICE-CONTROLLED属性が存在する場合："
    },
    {
      "indent": 6,
      "text": "* If the agent's tiebreaker value is larger than or equal to the contents of the ICE-CONTROLLED attribute, the agent switches to the controlling role.",
      "ja": "*エージェントのタイブレーカー値がICE-CONTROLLED属性の内容以上である場合、エージェントは制御ロールに切り替わります。"
    },
    {
      "indent": 6,
      "text": "* If the agent's tiebreaker value is less than the contents of the ICE-CONTROLLED attribute, the agent generates a Binding error response and includes an ERROR-CODE attribute with a value of 487 (Role Conflict) but retains its role.",
      "ja": "*エージェントのタイブレーカー値がICE-CONTROLLED属性の内容よりも小さい場合、エージェントはバインディングエラー応答を生成し、487（ロール競合）の値を持つERROR-CODE属性を含めますが、その役割は保持します。"
    },
    {
      "indent": 3,
      "text": "o If the agent is in the controlled role and the ICE-CONTROLLING attribute was present in the request, or if the agent was in the controlling role and the ICE-CONTROLLED attribute was present in the request, there is no conflict.",
      "ja": "oエージェントが制御ロールにあり、ICE-CONTROLLING属性がリクエストに存在する場合、またはエージェントが制御ロールにあり、ICE-CONTROLLED属性がリクエストに存在する場合、競合はありません。"
    },
    {
      "indent": 3,
      "text": "A change in roles will require an agent to recompute pair priorities (Section 6.1.2.3), since those priorities are a function of role. The change in role will also impact whether the agent is responsible for selecting nominated pairs and initiating exchange with updated candidate information upon conclusion of ICE.",
      "ja": "役割の変更には、エージェントがペアの優先順位を再計算する必要があります（6.1.2.3項）。これらの優先順位は役割の関数であるためです。 また、役割の変更は、指定されたペアを選択し、ICEの終了時に更新された候補者情報との交換を開始する責任があるかどうかにも影響します。"
    },
    {
      "indent": 3,
      "text": "The remaining subsections in Section 7.3.1 are followed if the agent generated a successful response to the Binding request, even if the agent changed roles.",
      "ja": "エージェントがロールを変更した場合でも、エージェントがバインディング要求に対する成功した応答を生成した場合、セクション7.3.1の残りのサブセクションが続きます。"
    },
    {
      "indent": 0,
      "text": "7.3.1.2. Computing Mapped Addresses",
      "section_title": true,
      "ja": "7.3.1.2。 マッピングされたアドレスの計算"
    },
    {
      "indent": 3,
      "text": "For requests received on a relayed candidate, the source transport address used for STUN processing (namely, generation of the XOR-MAPPED-ADDRESS attribute) is the transport address as seen by the TURN server. That source transport address will be present in the XOR-PEER-ADDRESS attribute of a Data Indication message, if the Binding request was delivered through a Data Indication. If the Binding request was delivered through a ChannelData message, the source transport address is the one that was bound to the channel.",
      "ja": "リレーされた候補で受信した要求の場合、STUN処理（つまり、XOR-MAPPED-ADDRESS属性の生成）に使用されるソーストランスポートアドレスは、TURNサーバーから見たトランスポートアドレスです。 バインディング要求がデータ表示を介して配信された場合、そのソーストランスポートアドレスは、データ表示メッセージのXOR-PEER-ADDRESS属性に存在します。 Binding要求がChannelDataメッセージを介して配信された場合、ソーストランスポートアドレスはチャネルにバインドされたものです。"
    },
    {
      "indent": 0,
      "text": "7.3.1.3. Learning Peer-Reflexive Candidates",
      "section_title": true,
      "ja": "7.3.1.3。 ピア反射候補者の学習"
    },
    {
      "indent": 3,
      "text": "If the source transport address of the request does not match any existing remote candidates, it represents a new peer-reflexive remote candidate. This candidate is constructed as follows:",
      "ja": "要求のソーストランスポートアドレスが既存のリモート候補と一致しない場合、それは新しいピア反射リモート候補を表します。 この候補は次のように構成されています。"
    },
    {
      "indent": 3,
      "text": "o The type is peer reflexive.",
      "ja": "oタイプはピア再帰的です。"
    },
    {
      "indent": 3,
      "text": "o The priority is the value of the PRIORITY attribute in the Binding request.",
      "ja": "o優先度は、バインディングリクエストのPRIORITY属性の値です。"
    },
    {
      "indent": 3,
      "text": "o The foundation is an arbitrary value, different from the foundations of all other remote candidates. If any subsequent candidate exchanges contain this peer-reflexive candidate, it will signal the actual foundation for the candidate.",
      "ja": "o基盤は、他のすべてのリモート候補者の基盤とは異なる任意の値です。 後続の候補交換にこのピア再帰候補が含まれている場合、候補の実際の基盤が示されます。"
    },
    {
      "indent": 3,
      "text": "o The component ID is the component ID of the local candidate to which the request was sent.",
      "ja": "oコンポーネントIDは、リクエストが送信されたローカル候補のコンポーネントIDです。"
    },
    {
      "indent": 3,
      "text": "This candidate is added to the list of remote candidates. However, the ICE agent does not pair this candidate with any local candidates.",
      "ja": "この候補は、リモート候補のリストに追加されます。 ただし、ICEエージェントはこの候補をローカル候補とペアリングしません。"
    },
    {
      "indent": 0,
      "text": "7.3.1.4. Triggered Checks",
      "section_title": true,
      "ja": "7.3.1.4。 トリガーチェック"
    },
    {
      "indent": 3,
      "text": "Next, the agent constructs a pair whose local candidate has the transport address (as seen by the agent) on which the STUN request was received and a remote candidate equal to the source transport address where the request came from (which may be the peer-reflexive remote candidate that was just learned). The local candidate will be either a host candidate (for cases where the request was not received through a relay) or a relayed candidate (for cases where it is received through a relay). The local candidate can never be a server-reflexive candidate. Since both candidates are known to the agent, it can obtain their priorities and compute the candidate pair priority. This pair is then looked up in the checklist. There can be one of several outcomes:",
      "ja": "次に、エージェントは、STUNリクエストを受信したトランスポートアドレス（エージェントから見た）をローカル候補に持つペアと、リクエストの送信元のトランスポートアドレス（peer- 学習したばかりの再帰的なリモート候補）。 ローカル候補は、ホスト候補（要求がリレー経由で受信されなかった場合）またはリレー候補（リレー経由で受信された場合）のいずれかになります。 ローカルの候補者がサーバー反射型の候補者になることはありません。 両方の候補がエージェントに既知であるため、エージェントは優先度を取得して、候補ペアの優先度を計算できます。 このペアは、チェックリストで検索されます。 いくつかの結果のいずれかがあります。"
    },
    {
      "indent": 3,
      "text": "o When the pair is already on the checklist:",
      "ja": "oペアが既にチェックリストにある場合："
    },
    {
      "indent": 6,
      "text": "* If the state of that pair is Succeeded, nothing further is done.",
      "ja": "*そのペアの状態がSucceededである場合、それ以上何も行われません。"
    },
    {
      "indent": 6,
      "text": "* If the state of that pair is In-Progress, the agent cancels the In-Progress transaction. Cancellation means that the agent will not retransmit the Binding requests associated with the connectivity-check transaction, will not treat the lack of response to be a failure, but will wait the duration of the transaction timeout for a response. In addition, the agent MUST enqueue the pair in the triggered checklist associated with the checklist, and set the state of the pair to Waiting, in order to trigger a new connectivity check of the pair. Creating a new connectivity check enables validating In-Progress pairs as soon as possible, without having to wait for retransmissions of the Binding requests associated with the original connectivity-check transaction.",
      "ja": "*そのペアの状態が進行中の場合、エージェントは進行中のトランザクションをキャンセルします。 キャンセルとは、エージェントが接続チェックトランザクションに関連付けられたバインディングリクエストを再送信せず、応答の欠如を失敗として扱わず、トランザクションタイムアウトの期間だけ応答を待つことを意味します。 さらに、エージェントは、ペアの新しい接続性チェックをトリガーするために、チェックリストに関連付けられたトリガーされたチェックリストのペアをキューに入れ、ペアの状態を待機に設定する必要があります。 新しい接続チェックを作成すると、元の接続チェックトランザクションに関連付けられたバインディングリクエストの再送信を待つことなく、進行中のペアをできるだけ早く検証できます。"
    },
    {
      "indent": 6,
      "text": "* If the state of that pair is Waiting, Frozen, or Failed, the agent MUST enqueue the pair in the triggered checklist associated with the checklist (if not already present), and set the state of the pair to Waiting, in order to trigger a new connectivity check of the pair. Note that a state change of the pair from Failed to Waiting might also trigger a state change of the associated checklist.",
      "ja": "*そのペアの状態がWaiting、Frozen、またはFailedの場合、エージェントは、チェックリストに関連付けられたトリガー済みチェックリスト（まだ存在しない場合）にペアをキューに入れ、トリガーするためにペアの状態をWaitingに設定する必要があります ペアの新しい接続チェック。 ペアの状態が[失敗]から[待機中]に変更されると、関連するチェックリストの状態も変更される可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "These steps are done to facilitate rapid completion of ICE when both agents are behind NAT.",
      "ja": "これらの手順は、両方のエージェントがNATの背後にある場合にICEの迅速な完了を促進するために行われます。"
    },
    {
      "indent": 3,
      "text": "o If the pair is not already on the checklist:",
      "ja": "oペアがチェックリストにない場合："
    },
    {
      "indent": 6,
      "text": "* The pair is inserted into the checklist based on its priority.",
      "ja": "*ペアは、優先度に基づいてチェックリストに挿入されます。"
    },
    {
      "indent": 6,
      "text": "* Its state is set to Waiting.",
      "ja": "*その状態は待機中に設定されます。"
    },
    {
      "indent": 6,
      "text": "* The pair is enqueued into the triggered-check queue.",
      "ja": "*ペアはトリガーチェックキューに入れられます。"
    },
    {
      "indent": 3,
      "text": "When a triggered check is to be sent, it is constructed and processed as described in Section 7.2.4. These procedures require the agent to know the transport address, username fragment, and password for the peer. The username fragment for the remote candidate is equal to the part after the colon of the USERNAME in the Binding request that was just received. Using that username fragment, the agent can check the candidates received from its peer (there may be more than one in cases of forking) and find this username fragment. The corresponding password is then picked.",
      "ja": "トリガーされたチェックが送信される場合、セクション7.2.4で説明されているように構築および処理されます。 これらの手順では、エージェントがピアのトランスポートアドレス、ユーザー名フラグメント、およびパスワードを知る必要があります。 リモート候補のユーザー名フラグメントは、受信したバインディング要求のUSERNAMEのコロンの後の部分に等しくなります。 そのユーザー名フラグメントを使用して、エージェントはそのピアから受信した候補（フォークの場合は複数ある可能性があります）を確認し、このユーザー名フラグメントを見つけることができます。 次に、対応するパスワードが選択されます。"
    },
    {
      "indent": 0,
      "text": "7.3.1.5. Updating the Nominated Flag",
      "section_title": true,
      "ja": "7.3.1.5。 ノミネートされたフラグの更新"
    },
    {
      "indent": 3,
      "text": "If the controlled agent receives a Binding request with the USE-CANDIDATE attribute set, and if the ICE agent accepts the request, the following action is based on the state of the pair computed in Section 7.3.1.4:",
      "ja": "制御エージェントがUSE-CANDIDATE属性が設定されたバインディング要求を受信し、ICEエージェントが要求を受け入れる場合、次のアクションはセクション7.3.1.4で計算されたペアの状態に基づきます。"
    },
    {
      "indent": 3,
      "text": "o If the state of this pair is Succeeded, it means that the check previously sent by this pair produced a successful response and generated a valid pair (Section 7.2.5.3.2). The agent sets the nominated flag value of the valid pair to true.",
      "ja": "oこのペアの状態が成功の場合、このペアによって以前に送信されたチェックが成功した応答を生成し、有効なペアを生成したことを意味します（セクション7.2.5.3.2）。 エージェントは、有効なペアの指定フラグ値をtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "o If the received Binding request triggered a new check to be enqueued in the triggered-check queue (Section 7.3.1.4), once the check is sent and if it generates a successful response, and generates a valid pair, the agent sets the nominated flag of the pair to true. If the request fails (Section 7.2.5.2), the agent MUST remove the candidate pair from the valid list, set the candidate pair state to Failed, and set the checklist state to Failed.",
      "ja": "o受信したバインディングリクエストがトリガーされたチェックキュー（7.3.1.4項）にキューに入れられる新しいチェックをトリガーした場合、チェックが送信され、成功した応答を生成し、有効なペアを生成すると、エージェントは指定された ペアのフラグをtrueにします。 要求が失敗した場合（7.2.5.2項）、エージェントは有効なリストから候補ペアを削除し、候補ペアの状態を失敗に設定し、チェックリストの状態を失敗に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the controlled agent does not accept the request from the controlling agent, the controlled agent MUST reject the nomination request with an appropriate error code response (e.g., 400) [RFC5389].",
      "ja": "制御エージェントが制御エージェントからの要求を受け入れない場合、制御エージェントは適切なエラーコード応答（たとえば、400）[RFC5389]で指名要求を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the nominated flag is set for a component of a data stream, it concludes the ICE processing for that component. See Section 8.",
      "ja": "指定されたフラグがデータストリームのコンポーネントに設定されると、そのコンポーネントのICE処理が終了します。 セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Additional Procedures for Lite Implementations",
      "section_title": true,
      "ja": "7.3.2.  Lite実装の追加手順"
    },
    {
      "indent": 3,
      "text": "If the controlled agent receives a Binding request with the USE-CANDIDATE attribute set, and if the ICE agent accepts the request, the agent constructs a candidate pair whose local candidate has the transport address on which the request was received, and whose remote candidate is equal to the source transport address of the request that was received. This candidate pair is assigned an arbitrary priority and placed into the valid list of the associated checklist. The agent sets the nominated flag for that pair to true.",
      "ja": "制御されたエージェントがUSE-CANDIDATE属性が設定されたバインディング要求を受信し、ICEエージェントが要求を受け入れる場合、エージェントは、候補が受信されたトランスポートアドレスをローカル候補に持ち、リモート候補が 受信したリクエストの送信元トランスポートアドレスと同じです。 この候補ペアには、任意の優先度が割り当てられ、関連するチェックリストの有効なリストに配置されます。 エージェントは、そのペアの指定フラグをtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "Once the nominated flag is set for a component of a data stream, it concludes the ICE processing for that component. See Section 8.",
      "ja": "指定されたフラグがデータストリームのコンポーネントに設定されると、そのコンポーネントのICE処理が終了します。 セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "8. Concluding ICE Processing",
      "section_title": true,
      "ja": "8. ICE処理の終了"
    },
    {
      "indent": 3,
      "text": "This section describes how an ICE agent completes ICE.",
      "ja": "このセクションでは、ICEエージェントがICEを完了する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Procedures for Full Implementations",
      "section_title": true,
      "ja": "8.1.  完全な実装の手順"
    },
    {
      "indent": 3,
      "text": "Concluding ICE involves nominating pairs by the controlling agent and updating state machinery.",
      "ja": "ICEの終了には、制御エージェントによるペアの指定と状態機械の更新が含まれます。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Nominating Pairs",
      "section_title": true,
      "ja": "8.1.1.  指名ペア"
    },
    {
      "indent": 3,
      "text": "Prior to nominating, the controlling agent lets connectivity checks continue until some stopping criterion is met. After that, based on an evaluation criterion, the controlling agent picks a pair among the valid pairs in the valid list for nomination.",
      "ja": "指名する前に、制御エージェントは、何らかの停止基準が満たされるまで接続性チェックを継続させます。 その後、評価基準に基づいて、制御エージェントは指名のために有効なリスト内の有効なペアからペアを選択します。"
    },
    {
      "indent": 3,
      "text": "Once the controlling agent has picked a valid pair for nomination, it repeats the connectivity check that produced this valid pair (by enqueueing the pair that generated the check into the triggered-check queue), this time with the USE-CANDIDATE attribute (Section 7.2.5.3.4). The procedures for the controlled agent are described in Section 7.3.1.5.",
      "ja": "制御エージェントが指名のための有効なペアを選択すると、この有効なペアを生成した接続チェックを繰り返します（チェックを生成したペアをトリガーチェックキューに入れて）、今回はUSE-CANDIDATE属性（セクション7.2） .5.3.4）。 管理対象エージェントの手順については、セクション7.3.1.5で説明しています。"
    },
    {
      "indent": 3,
      "text": "Eventually, if the nominations succeed, both the controlling and controlled agents will have a single nominated pair in the valid list for each component of the data stream. Once an ICE agent sets the state of the checklist to Completed (when there is a nominated pair for each component of the data stream), that pair becomes the selected pair for that agent and is used for sending and receiving data for that component of the data stream.",
      "ja": "最終的に、指名が成功すると、制御エージェントと被制御エージェントの両方が、データストリームの各コンポーネントの有効リストに単一の指名ペアを持ちます。 ICEエージェントがチェックリストの状態を完了に設定すると（データストリームの各コンポーネントに指定されたペアがある場合）、そのペアはそのエージェントの選択されたペアになり、そのコンポーネントのデータの送受信に使用されます データストリーム。"
    },
    {
      "indent": 3,
      "text": "If an agent is not able to produce selected pairs for each component of a data stream, the agent MUST take proper actions for informing the other agent, e.g., by removing the stream. The exact actions are outside the scope of this specification.",
      "ja": "エージェントがデータストリームの各コンポーネントに対して選択されたペアを生成できない場合、エージェントは、たとえばストリームを削除するなどして、他のエージェントに通知するための適切なアクションを実行する必要があります。 正確なアクションは、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "The criteria for stopping the connectivity checks and for picking a pair for nomination are outside the scope of this specification. They are a matter of local optimization. The only requirement is that the agent MUST eventually pick one and only one candidate pair and generate a check for that pair with the USE-CANDIDATE attribute set.",
      "ja": "接続性チェックを停止し、指名のためにペアを選択するための基準は、この仕様の範囲外です。 それらはローカル最適化の問題です。 唯一の要件は、エージェントが最終的に1つの候補ペアのみを選択し、USE-CANDIDATE属性セットを使用してそのペアのチェックを生成する必要があることです。"
    },
    {
      "indent": 3,
      "text": "Once the controlling agent has successfully nominated a candidate pair (Section 7.2.5.3.4), the agent MUST NOT nominate another pair for same component of the data stream within the ICE session. Doing so requires an ICE restart.",
      "ja": "制御エージェントが候補ペアの指定に成功すると（セクション7.2.5.3.4）、エージェントはICEセッション内のデータストリームの同じコンポーネントに別のペアを指定してはなりません。 これを行うには、ICEを再起動する必要があります。"
    },
    {
      "indent": 3,
      "text": "A controlling agent that does not support this specification (i.e., it is implemented according to RFC 5245) might nominate more than one candidate pair. This was referred to as \"aggressive nomination\" in RFC 5245. If more than one candidate pair is nominated by the controlling agent, and if the controlled agent accepts multiple nominations requests, the agents MUST produce the selected pairs and use the pairs with the highest priority.",
      "ja": "この仕様をサポートしていない（つまり、RFC 5245に従って実装されている）制御エージェントは、複数の候補ペアを指定する場合があります。 これは、RFC 5245で「積極的な指名」と呼ばれていました。複数の候補ペアが制御エージェントによって指名され、被制御エージェントが複数の指名要求を受け入れる場合、エージェントは選択されたペアを生成し、最も高いペアを使用する必要があります 優先。"
    },
    {
      "indent": 3,
      "text": "The usage of the 'ice2' ICE option (Section 10) by endpoints supporting this specification is supposed to prevent controlling agents that are implemented according to RFC 5245 from using aggressive nomination.",
      "ja": "この仕様をサポートするエンドポイントによる「ice2」ICEオプション（セクション10）の使用は、RFC 5245に従って実装された制御エージェントが積極的な指名を使用することを防止することになっています。"
    },
    {
      "indent": 3,
      "text": "NOTE: In RFC 5245, usage of \"aggressive nomination\" allowed agents to continuously nominate pairs, before a pair was eventually selected, in order to allow sending of data on those pairs. In this specification, data can always be sent on any valid pair, without nomination. Hence, there is no longer a need for aggressive nomination.",
      "ja": "注：RFC 5245では、「積極的な指名」を使用すると、ペアが最終的に選択される前に、それらのペアでデータを送信できるように、エージェントが連続してペアを指名できました。 この仕様では、指名なしで、有効なペアでデータを常に送信できます。 したがって、積極的な指名の必要はもうありません。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Updating Checklist and ICE States",
      "section_title": true,
      "ja": "8.1.2.  チェックリストとICE状態の更新"
    },
    {
      "indent": 3,
      "text": "For both a controlling and a controlled agent, when a candidate pair for a component of a data stream gets nominated, it might impact other pairs in the checklist associated with the data stream. It might also impact the state of the checklist:",
      "ja": "制御エージェントと制御エージェントの両方で、データストリームのコンポーネントの候補ペアが指定されると、データストリームに関連付けられたチェックリスト内の他のペアに影響を与える可能性があります。 また、チェックリストの状態に影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Once a candidate pair for a component of a data stream has been nominated, and the state of the checklist associated with the data stream is Running, the ICE agent MUST remove all candidate pairs for the same component from the checklist and from the triggered-check queue. If the state of a pair is In-Progress, the agent cancels the In-Progress transaction. Cancellation means that the agent will not retransmit the Binding requests associated with the connectivity-check transaction, will not treat the lack of response to be a failure, but will wait the duration of the transaction timeout for a response.",
      "ja": "oデータストリームのコンポーネントの候補ペアが指定され、データストリームに関連付けられたチェックリストの状態が実行中になると、ICEエージェントは同じコンポーネントのすべての候補ペアをチェックリストとトリガーされた チェックキュー。 ペアの状態が進行中の場合、エージェントは進行中のトランザクションをキャンセルします。 キャンセルとは、エージェントが接続チェックトランザクションに関連付けられたバインディングリクエストを再送信せず、応答の欠如を失敗として扱わず、トランザクションタイムアウトの期間だけ応答を待つことを意味します。"
    },
    {
      "indent": 3,
      "text": "o Once candidate pairs for each component of a data stream have been nominated, and the state of the checklist associated with the data stream is Running, the ICE agent sets the state of the checklist to Completed.",
      "ja": "oデータストリームの各コンポーネントの候補ペアが指定され、データストリームに関連付けられたチェックリストの状態が実行中になると、ICEエージェントはチェックリストの状態を完了に設定します。"
    },
    {
      "indent": 3,
      "text": "o Once a candidate pair for a component of a data stream has been nominated, an agent MUST continue to respond to any Binding request it might still receive for the nominated pair and for any remaining candidate pairs in the checklist associated with the data stream. As defined in Section 7.3.1.4, when the state of a pair is Succeeded, an agent will no longer generate triggered checks when receiving a Binding request for the pair.",
      "ja": "oデータストリームのコンポーネントの候補ペアが指定されると、エージェントは、指定されたペアおよびデータストリームに関連付けられたチェックリスト内の残りの候補ペアに対して受信する可能性のあるバインディングリクエストに引き続き応答する必要があります。 セクション7.3.1.4で定義されているように、ペアの状態がSucceededである場合、エージェントはペアのバインディングリクエストを受信したときにトリガーチェックを生成しなくなります。"
    },
    {
      "indent": 3,
      "text": "Once the state of each checklist in the checklist set is Completed, the agent sets the state of the ICE session to Completed.",
      "ja": "チェックリストセット内の各チェックリストの状態が完了したら、エージェントはICEセッションの状態を完了に設定します。"
    },
    {
      "indent": 3,
      "text": "If the state of a checklist is Failed, ICE has not been able to successfully complete the process for the data stream associated with the checklist. The correct behavior depends on the state of the checklists in the checklist set. If the controlling agent wants to continue the session without the data stream associated with the Failed checklist, and if there are still one or more checklists in Running or Completed mode, the agent can let the ICE processing continue. The agent MUST take proper actions for removing the failed data stream. If the controlling agent does not want to continue the session and MUST terminate the session, the state of the ICE session is set to Failed.",
      "ja": "チェックリストの状態が[失敗]の場合、ICEはチェックリストに関連付けられたデータストリームのプロセスを正常に完了できていません。 正しい動作は、チェックリストセット内のチェックリストの状態によって異なります。 制御エージェントが、失敗したチェックリストに関連付けられたデータストリームなしでセッションを続行したい場合、および実行モードまたは完了モードで1つ以上のチェックリストがまだある場合、エージェントはICE処理を続行できます。 エージェントは、失敗したデータストリームを削除するための適切なアクションを実行する必要があります。 制御エージェントがセッションの継続を望まず、セッションを終了しなければならない場合、ICEセッションの状態は「失敗」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If the state of each checklist in the checklist set is Failed, the state of the ICE session is set to Failed. Unless the controlling agent wants to continue the session without the data streams, it MUST terminate the session.",
      "ja": "チェックリストセット内の各チェックリストの状態が失敗の場合、ICEセッションの状態は失敗に設定されます。 制御エージェントがデータストリームなしでセッションを継続する場合を除き、セッションを終了する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Procedures for Lite Implementations",
      "section_title": true,
      "ja": "8.2.  Lite実装の手順"
    },
    {
      "indent": 3,
      "text": "When ICE concludes, a lite ICE agent can free host candidates that were not used by ICE, as described in Section 8.3.",
      "ja": "ICEが終了すると、ライトICEエージェントは、セクション8.3で説明されているように、ICEによって使用されなかったホスト候補を解放できます。"
    },
    {
      "indent": 3,
      "text": "If the peer is a full agent, once the lite agent accepts a nomination request for a candidate pair, the lite agent considers the pair nominated. Once there are nominated pairs for each component of a data stream, the pairs become the selected pairs for the components of the data stream. Once the lite agent has produced selected pairs for all components of all data streams, the ICE session state is set to Completed.",
      "ja": "ピアが完全なエージェントである場合、Liteエージェントが候補ペアの指名要求を受け入れると、Liteエージェントはペアが指名されたと見なします。 データストリームの各コンポーネントのペアが指定されると、そのペアがデータストリームのコンポーネントの選択されたペアになります。 ライトエージェントがすべてのデータストリームのすべてのコンポーネントに対して選択されたペアを生成すると、ICEセッションの状態はCompletedに設定されます。"
    },
    {
      "indent": 3,
      "text": "If the peer is a lite agent, the agent pairs local candidates with remote candidates that are of the same data stream and have the same component, transport protocol, and IP address family. For each component of each data stream, if there is only one candidate pair, that pair is added to the valid list. If there is more than one pair, it is RECOMMENDED that an agent follow the procedures of RFC 6724 [RFC6724] to select a pair and add it to the valid list.",
      "ja": "ピアがライトエージェントの場合、エージェントはローカル候補と、同じデータストリームであり、コンポーネント、トランスポートプロトコル、およびIPアドレスファミリが同じリモート候補をペアにします。 各データストリームの各コンポーネントについて、候補ペアが1つしかない場合、そのペアは有効なリストに追加されます。 ペアが複数ある場合、エージェントがRFC 6724 [RFC6724]の手順に従ってペアを選択し、有効なリストに追加することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "If all of the components for all data streams had one pair, the state of ICE processing is Completed. Otherwise, the controlling agent MUST send an updated candidate list to reconcile different agents selecting different candidate pairs. ICE processing is complete after and only after the updated candidate exchange is complete.",
      "ja": "すべてのデータストリームのすべてのコンポーネントに1つのペアがある場合、ICE処理の状態は完了です。 そうでない場合、制御エージェントは更新された候補リストを送信して、異なる候補ペアを選択する異なるエージェントを調整する必要があります。 ICE処理は、更新された候補者の交換が完了した後にのみ完了します。"
    },
    {
      "indent": 0,
      "text": "8.3. Freeing Candidates",
      "section_title": true,
      "ja": "8.3.  候補者の解放"
    },
    {
      "indent": 0,
      "text": "8.3.1. Full Implementation Procedures",
      "section_title": true,
      "ja": "8.3.1.  完全な実装手順"
    },
    {
      "indent": 3,
      "text": "The rules in this section describe when it is safe for an agent to cease sending or receiving checks on a candidate that did not become a selected candidate (i.e., is not associated with a selected pair) and when to free the candidate.",
      "ja": "このセクションのルールは、選択された候補にならなかった（つまり、選択されたペアに関連付けられていない）候補のチェックの送信または受信をエージェントが安全に停止できる時期と、候補を解放する時期について説明しています。"
    },
    {
      "indent": 3,
      "text": "Once a checklist has reached the Completed state, the agent SHOULD wait an additional three seconds, and then it can cease responding to checks or generating triggered checks on all local candidates other than the ones that became selected candidates. Once all ICE sessions have ceased using a given local candidate (a candidate may be used by multiple ICE sessions, e.g., in forking scenarios), the agent can free that candidate. The three-second delay handles cases when aggressive nomination is used, and the selected pairs can quickly change after ICE has completed.",
      "ja": "チェックリストが完了状態に達すると、エージェントはさらに3秒間待機する必要があり（SHOULD）、選択された候補になった候補以外のすべてのローカル候補に対するチェックへの応答またはトリガーチェックの生成を停止できます。 特定のローカル候補を使用してすべてのICEセッションが終了すると（候補は複数のICEセッションで、たとえば分岐シナリオで使用される場合があります）、エージェントはその候補を解放できます。 3秒の遅延は、積極的な指名が使用される場合を処理し、選択されたペアは、ICEが完了した後すぐに変更できます。"
    },
    {
      "indent": 3,
      "text": "Freeing of server-reflexive candidates is never explicit; it happens by lack of a keepalive.",
      "ja": "サーバー反射候補の解放は決して明示的ではありません。 それはキープアライブの欠如によって起こります。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Lite Implementation Procedures",
      "section_title": true,
      "ja": "8.3.2.  Liteの実装手順"
    },
    {
      "indent": 3,
      "text": "A lite implementation can free candidates that did not become selected candidates as soon as ICE processing has reached the Completed state for all ICE sessions using those candidates.",
      "ja": "ライトの実装では、ICE処理がそれらの候補を使用するすべてのICEセッションで完了状態に達するとすぐに、選択された候補にならなかった候補を解放できます。"
    },
    {
      "indent": 0,
      "text": "9. ICE Restarts",
      "section_title": true,
      "ja": "9. ICEの再起動"
    },
    {
      "indent": 3,
      "text": "An ICE agent MAY restart ICE for existing data streams. An ICE restart causes all previous states of the data streams, excluding the roles of the agents, to be flushed. The only difference between an ICE restart and a brand new data session is that during the restart, data can continue to be sent using existing data sessions, and a new data session always requires the roles to be determined.",
      "ja": "ICEエージェントは、既存のデータストリームのICEを再起動できます。 ICEを再起動すると、エージェントの役割を除くデータストリームの以前のすべての状態がフラッシュされます。 ICEの再起動とまったく新しいデータセッションの唯一の違いは、再起動中、既存のデータセッションを使用してデータを送信し続けることができ、新しいデータセッションでは常にロールを決定する必要があることです。"
    },
    {
      "indent": 3,
      "text": "The following actions can be accomplished only by using an ICE restart (the agent MUST use ICE restarts to do so):",
      "ja": "以下のアクションは、ICE再始動を使用することによってのみ達成できます（エージェントは、そうするためにICE再始動を使用する必要があります）。"
    },
    {
      "indent": 3,
      "text": "o Change the destinations of data streams.",
      "ja": "oデータストリームの宛先を変更します。"
    },
    {
      "indent": 3,
      "text": "o Change from a lite implementation to a full implementation.",
      "ja": "o簡易実装から完全実装に変更します。"
    },
    {
      "indent": 3,
      "text": "o Change from a full implementation to a lite implementation.",
      "ja": "o完全な実装から簡易実装に変更します。"
    },
    {
      "indent": 3,
      "text": "To restart ICE, an agent MUST change both the password and the username fragment for the data stream(s) being restarted.",
      "ja": "ICEを再起動するには、エージェントは、再起動するデータストリームのパスワードとユーザー名フラグメントの両方を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the ICE is restarted, the candidate set for the new ICE session might include some, none, or all of the candidates used in the current ICE session.",
      "ja": "ICEを再起動すると、新しいICEセッションの候補セットには、現在のICEセッションで使用された候補の一部または全部が含まれるか、まったく含まれない場合があります。"
    },
    {
      "indent": 3,
      "text": "As described in Section 6.1.1, agents MUST NOT redetermine the roles as part as an ICE restart, unless certain criteria that require the roles to be redetermined are fulfilled.",
      "ja": "セクション6.1.1で説明したように、ロールの再決定を必要とする特定の基準が満たされない限り、エージェントはICEの再起動として一部としてロールを再決定してはなりません。"
    },
    {
      "indent": 0,
      "text": "10. ICE Option",
      "section_title": true,
      "ja": "10. ICEオプション"
    },
    {
      "indent": 3,
      "text": "This section defines a new ICE option, 'ice2'. When an ICE agent includes 'ice2' in a candidate exchange, the ICE option indicates that it is compliant to this specification. For example, the agent will not use the aggressive nomination procedure defined in RFC 5245. In addition, it will ensure that a peer compliant with RFC 5245 does not use aggressive nomination either, as required by Section 14 of RFC 5245 for peers that receive unknown ICE options.",
      "ja": "このセクションでは、新しいICEオプション「ice2」を定義します。 ICEエージェントが候補交換に「ice2」を含む場合、ICEオプションは、この仕様に準拠していることを示します。 たとえば、エージェントは、RFC 5245で定義されている積極的な指名手順を使用しません。さらに、RFC 5245に準拠するピアも、未知を受信するピアに対してRFC 5245のセクション14で要求されるように、積極的な指名を使用しないようにします ICEオプション。"
    },
    {
      "indent": 3,
      "text": "An agent compliant to this specification MUST inform the peer about the compliance using the 'ice2' option.",
      "ja": "この仕様に準拠するエージェントは、「ice2」オプションを使用して、準拠についてピアに通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The encoding of the 'ice2' option, and the message(s) used to carry it to the peer, are protocol specific. The encoding for SDP [RFC4566] is defined in [ICE-SIP-SDP].",
      "ja": "注：「ice2」オプションのエンコードと、それをピアに送信するために使用されるメッセージは、プロトコル固有です。 SDP [RFC4566]のエンコーディングは[ICE-SIP-SDP]で定義されています。"
    },
    {
      "indent": 0,
      "text": "11. Keepalives",
      "section_title": true,
      "ja": "11.キープアライブ"
    },
    {
      "indent": 3,
      "text": "All endpoints MUST send keepalives for each data session. These keepalives serve the purpose of keeping NAT bindings alive for the data session. The keepalives SHOULD be sent using a format that is supported by its peer. ICE endpoints allow for STUN-based keepalives for UDP streams, and as such, STUN keepalives MUST be used when an ICE agent is a full ICE implementation and is communicating with a peer that supports ICE (lite or full).",
      "ja": "すべてのエンドポイントは、各データセッションのキープアライブを送信する必要があります。 これらのキープアライブは、データセッションのためにNATバインディングを有効に保つ目的に役立ちます。 キープアライブは、ピアでサポートされている形式を使用して送信する必要があります。 ICEエンドポイントは、UDPストリームのSTUNベースのキープアライブを許可するため、ICEエージェントが完全なICE実装であり、ICE（ライトまたはフル）をサポートするピアと通信している場合は、STUNキープアライブを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "An agent MUST send a keepalive on each candidate pair that is used for sending data if no packet has been sent on that pair in the last Tr seconds. Agents SHOULD use a Tr value of 15 seconds. Agents MAY use a bigger value but MUST NOT use a value smaller than 15 seconds.",
      "ja": "エージェントは、最後のTr秒間にそのペアでパケットが送信されなかった場合、データの送信に使用される各候補ペアでキープアライブを送信する必要があります。 エージェントは、15秒のTr値を使用する必要があります。 エージェントは、より大きな値を使用できますが、15秒未満の値を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once selected pairs have been produced for a data stream, keepalives are only sent on those pairs.",
      "ja": "データストリームに対して選択されたペアが生成されると、キープアライブはそれらのペアでのみ送信されます。"
    },
    {
      "indent": 3,
      "text": "An agent MUST stop sending keepalives on a data stream if the data stream is removed. If the ICE session is terminated, an agent MUST stop sending keepalives on all data streams.",
      "ja": "データストリームが削除された場合、エージェントはデータストリームでのキープアライブの送信を停止する必要があります。 ICEセッションが終了した場合、エージェントはすべてのデータストリームでキープアライブの送信を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "An agent MAY use another value for Tr, e.g., based on configuration or network/NAT characteristics. For example, if an agent has a dynamic way to discover the binding lifetimes of the intervening NATs, it can use that value to determine Tr. Administrators deploying ICE in more controlled networking environments SHOULD set Tr to the longest duration possible in their environment.",
      "ja": "エージェントは、たとえば構成またはネットワーク/ NAT特性に基づいて、Trに別の値を使用する場合があります。 たとえば、エージェントが、介在するNATのバインディングライフタイムを動的に検出する方法を持っている場合、その値を使用してTrを決定できます。 より制御されたネットワーク環境でICEを展開する管理者は、Trを環境内で可能な限り長い期間に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When STUN is being used for keepalives, a STUN Binding Indication is used [RFC5389]. The Indication MUST NOT utilize any authentication mechanism. It SHOULD contain the FINGERPRINT attribute to aid in demultiplexing, but it SHOULD NOT contain any other attributes. It is used solely to keep the NAT bindings alive. The Binding Indication is sent using the same local and remote candidates that are being used for data. Though Binding Indications are used for keepalives, an agent MUST be prepared to receive a connectivity check as well. If a connectivity check is received, a response is generated as discussed in [RFC5389], but there is no impact on ICE processing otherwise.",
      "ja": "キープアライブにSTUNが使用されている場合、STUNバインディング表示が使用されます[RFC5389]。 表示は、認証メカニズムを利用してはなりません。 逆多重化を支援するためにFINGERPRINT属性を含むべきであるが、他の属性を含むべきではない。 NATバインディングを維持するためだけに使用されます。 バインディング表示は、データに使用されている同じローカルおよびリモート候補を使用して送信されます。 キープアライブにはBinding Indicationsが使用されますが、接続チェックも受信するようにエージェントを準備する必要があります。 接続性チェックが受信されると、[RFC5389]で説明されているように応答が生成されますが、それ以外の場合はICE処理に影響はありません。"
    },
    {
      "indent": 3,
      "text": "Agents MUST by default use STUN keepalives. Individual ICE usages and ICE extensions MAY specify usage-/extension-specific keepalives.",
      "ja": "エージェントはデフォルトでSTUNキープアライブを使用する必要があります。 個々のICEの使用法とICE拡張機能は、使用法/拡張機能固有のキープアライブを指定できます（MAY）。"
    },
    {
      "indent": 0,
      "text": "12. Data Handling",
      "section_title": true,
      "ja": "12.データ処理"
    },
    {
      "indent": 0,
      "text": "12.1. Sending Data",
      "section_title": true,
      "ja": "12.1.  データを送信する"
    },
    {
      "indent": 3,
      "text": "An ICE agent MAY send data on any valid pair before selected pairs have been produced for the data stream.",
      "ja": "ICEエージェントは、選択したペアがデータストリーム用に生成される前に、有効なペアでデータを送信できます。"
    },
    {
      "indent": 3,
      "text": "Once selected pairs have been produced for a data stream, an agent MUST send data on those pairs only.",
      "ja": "データストリームに対して選択されたペアが生成されると、エージェントはそれらのペアでのみデータを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An agent sends data from the base of the local candidate to the remote candidate. In the case of a local relayed candidate, data is forwarded through the base (located in the TURN server), using the procedures defined in [RFC5766].",
      "ja": "エージェントは、ローカル候補のベースからリモート候補にデータを送信します。 ローカルリレー候補の場合、データは[RFC5766]で定義された手順を使用して、ベース（TURNサーバーにある）を介して転送されます。"
    },
    {
      "indent": 3,
      "text": "If the local candidate is a relayed candidate, it is RECOMMENDED that an agent creates a channel on the TURN server towards the remote candidate. This is done using the procedures for channel creation as defined in Section 11 of [RFC5766].",
      "ja": "ローカル候補者が中継候補者である場合、エージェントがTURNサーバー上でリモート候補者へのチャネルを作成することをお勧めします。 これは、[RFC5766]のセクション11で定義されているチャネル作成の手順を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "The selected pair for a component of a data stream is:",
      "ja": "データストリームのコンポーネント用に選択されたペアは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o empty if the state of the checklist for that data stream is Running, and there is no previous selected pair for that component due to an ICE restart",
      "ja": "oそのデータストリームのチェックリストの状態が実行中で、ICEの再起動のためにそのコンポーネントに対して以前に選択されたペアがない場合は空"
    },
    {
      "indent": 3,
      "text": "o equal to the previous selected pair for a component of a data stream if the state of the checklist for that data stream is Running, and there was a previous selected pair for that component due to an ICE restart",
      "ja": "oそのデータストリームのチェックリストの状態が実行中の場合、ICEの再起動によりそのコンポーネントの以前に選択されたペアがあった場合、データストリームのコンポーネントに対して以前に選択されたペアと等しい"
    },
    {
      "indent": 3,
      "text": "Unless an agent is able to produce a selected pair for each component associated with a data stream, the agent MUST NOT continue sending data for any component associated with that data stream.",
      "ja": "エージェントがデータストリームに関連付けられた各コンポーネントに対して選択されたペアを生成できない場合、エージェントはそのデータストリームに関連付けられたコンポーネントのデータの送信を継続してはなりません。"
    },
    {
      "indent": 0,
      "text": "12.1.1. Procedures for Lite Implementations",
      "section_title": true,
      "ja": "12.1.1.  Lite実装の手順"
    },
    {
      "indent": 3,
      "text": "A lite implementation MUST NOT send data until it has a valid list that contains a candidate pair for each component of that data stream. Once that happens, the ICE agent MAY begin sending data packets. To do that, it sends data to the remote candidate in the pair (setting the destination address and port of the packet equal to that remote candidate) and will send it from the base associated with the candidate pair used for sending data. In case of a relayed candidate, data is sent from the agent and forwarded through the base (located in the TURN server), using the procedures defined in [RFC5766].",
      "ja": "ライトインプリメンテーションは、そのデータストリームの各コンポーネントの候補ペアを含む有効なリストがあるまで、データを送信してはなりません。 それが起こると、ICEエージェントはデータパケットの送信を開始できます（MAY）。 そのために、ペアのリモート候補にデータを送信し（パケットの宛先アドレスとポートをそのリモート候補に等しく設定します）、データ送信に使用される候補ペアに関連付けられたベースから送信します。 リレーされた候補者の場合、データはエージェントから送信され、[RFC5766]で定義された手順を使用して、ベース（TURNサーバーにある）を介して転送されます。"
    },
    {
      "indent": 0,
      "text": "12.2. Receiving Data",
      "section_title": true,
      "ja": "12.2.  データ受信中"
    },
    {
      "indent": 3,
      "text": "Even though ICE agents are only allowed to send data using valid candidate pairs (and, once selected pairs have been produced, only on the selected pairs), ICE implementations SHOULD by default be prepared to receive data on any of the candidates provided in the most recent candidate exchange with the peer. ICE usages MAY define rules that differ from this, e.g., by defining that data will not be sent until selected pairs have been produced for a data stream.",
      "ja": "ICEエージェントは有効な候補ペアを使用してのみデータを送信できますが（選択されたペアが生成されると、選択されたペアでのみ）、ICE実装はデフォルトで、最も多く提供された候補のいずれかでデータを受信するように準備する必要があります ピアとの最近の候補者交換。 ICEの使用法では、これとは異なるルールを定義できます。たとえば、選択したペアがデータストリーム用に生成されるまでデータが送信されないように定義します。"
    },
    {
      "indent": 3,
      "text": "When an agent receives an RTP packet with a new source or destination IP address for a particular RTP/RTCP data stream, it is RECOMMENDED that the agent readjust its jitter buffers.",
      "ja": "エージェントが特定のRTP / RTCPデータストリームの新しい送信元または宛先IPアドレスを持つRTPパケットを受信した場合、エージェントがジッタバッファを再調整することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Section 8.2 of RFC 3550 [RFC3550] describes an algorithm for detecting synchronization source (SSRC) collisions and loops. These algorithms are based, in part, on seeing different source transport addresses with the same SSRC. However, when ICE is used, such changes will sometimes occur as the data streams switch between candidates. An agent will be able to determine that a data stream is from the same peer as a consequence of the STUN exchange that proceeds media data transmission. Thus, if there is a change in the source transport address, but the media data packets come from the same peer agent, this MUST NOT be treated as an SSRC collision.",
      "ja": "RFC 3550 [RFC3550]のセクション8.2は、同期ソース（SSRC）の衝突とループを検出するためのアルゴリズムについて説明しています。 これらのアルゴリズムは、同じSSRCで異なるソーストランスポートアドレスを見ることに一部基づいています。 ただし、ICEを使用する場合、データストリームが候補間で切り替わるときにこのような変更が発生することがあります。 エージェントは、メディアデータ送信を進めるSTUN交換の結果として、データストリームが同じピアからのものであることを判別できます。 したがって、ソーストランスポートアドレスに変更があるが、メディアデータパケットが同じピアエージェントから送信されている場合、これをSSRCコリジョンとして扱わないでください。"
    },
    {
      "indent": 0,
      "text": "13. Extensibility Considerations",
      "section_title": true,
      "ja": "13.拡張性に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification makes very specific choices about how both ICE agents in a session coordinate to arrive at the set of candidate pairs that are selected for data. It is anticipated that future specifications will want to alter these algorithms, whether they are simple changes like timer tweaks or larger changes like a revamp of the priority algorithm. When such a change is made, providing interoperability between the two agents in a session is critical.",
      "ja": "この仕様では、セッション内の両方のICEエージェントがデータ用に選択された候補ペアのセットに到達するための調整方法について、非常に具体的な選択を行います。 タイマーの微調整などの単純な変更であれ、優先度アルゴリズムの改良などの大きな変更であれ、将来の仕様ではこれらのアルゴリズムを変更することが予想されます。 このような変更が行われる場合、セッション内の2つのエージェント間の相互運用性を提供することが重要です。"
    },
    {
      "indent": 3,
      "text": "First, ICE provides the ICE option concept. Each extension or change to ICE is associated with an ICE option. When an agent supports such an extension or change, it provides the ICE option to the peer agent as part of the candidate exchange.",
      "ja": "まず、ICEはICEオプションの概念を提供します。 ICEの各拡張または変更は、ICEオプションに関連付けられています。 エージェントがこのような拡張または変更をサポートする場合、候補交換の一部としてピアエージェントにICEオプションを提供します。"
    },
    {
      "indent": 3,
      "text": "One of the complications in achieving interoperability is that ICE relies on a distributed algorithm running on both agents to converge on an agreed set of candidate pairs. If the two agents run different algorithms, it can be difficult to guarantee convergence on the same candidate pairs. The nomination procedure described in Section 8 eliminates some of the need for tight coordination by delegating the selection algorithm completely to the controlling agent, and ICE will converge perfectly even when both agents use different pair prioritization algorithms. One of the keys to such convergence is triggered checks, which ensure that the nominated pair is validated by both agents.",
      "ja": "相互運用性を実現する際の複雑さの1つは、ICEが両方のエージェントで実行される分散アルゴリズムに依存して、候補ペアの合意されたセットに収束することです。 2つのエージェントが異なるアルゴリズムを実行している場合、同じ候補ペアでの収束を保証することは困難です。 セクション8で説明した指名手順は、選択アルゴリズムを制御エージェントに完全に委任することにより、緊密な調整の必要性を排除します。ICEは、両方のエージェントが異なるペアの優先順位付けアルゴリズムを使用する場合でも完全に収束します。 このような収束の鍵の1つは、指定されたペアが両方のエージェントによって検証されることを確認するトリガーチェックです。"
    },
    {
      "indent": 3,
      "text": "ICE is also extensible to other data streams beyond RTP and for transport protocols beyond UDP. Extensions to ICE for non-RTP data streams need to specify how many components they utilize and assign component IDs to them, starting at 1 for the most important component ID. Specifications for new transport protocols MUST define how, if at all, various steps in the ICE processing differ from UDP.",
      "ja": "ICEは、RTPを超える他のデータストリームや、UDPを超えるトランスポートプロトコルにも拡張可能です。 非RTPデータストリーム用のICEの拡張では、利用するコンポーネントの数を指定し、最も重要なコンポーネントIDの1からコンポーネントIDを割り当てる必要があります。 新しいトランスポートプロトコルの仕様では、ICE処理のさまざまな手順がUDPとどのように異なるかを定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "14. Setting Ta and RTO",
      "section_title": true,
      "ja": "14. TaおよびRTOの設定"
    },
    {
      "indent": 0,
      "text": "14.1. General",
      "section_title": true,
      "ja": "14.1.  全般"
    },
    {
      "indent": 3,
      "text": "During the ICE gathering phase (Section 5.1.1) and while ICE is performing connectivity checks (Section 7), an ICE agent triggers STUN and TURN transactions. These transactions are paced at a rate indicated by Ta, and the retransmission interval for each transaction is calculated based on the retransmission timer for the STUN transactions (RTO) [RFC5389].",
      "ja": "ICE収集フェーズ（セクション5.1.1）およびICEが接続性チェックを実行している間（セクション7）、ICEエージェントはSTUNおよびTURNトランザクションをトリガーします。 これらのトランザクションは、Taで示されるレートで調整され、各トランザクションの再送信間隔は、STUNトランザクション（RTO）[RFC5389]の再送信タイマーに基づいて計算されます。"
    },
    {
      "indent": 3,
      "text": "This section describes how the Ta and RTO values are computed during the ICE gathering phase and while ICE is performing connectivity checks.",
      "ja": "このセクションでは、ICE収集フェーズ中およびICEが接続性チェックを実行している間のTaおよびRTO値の計算方法について説明します。"
    },
    {
      "indent": 3,
      "text": "NOTE: Previously, in RFC 5245, different formulas were defined for computing Ta and RTO, depending on whether or not ICE was used for a real-time data stream (e.g., RTP).",
      "ja": "注：以前は、RFC 5245では、リアルタイムデータストリーム（RTPなど）にICEが使用されたかどうかに応じて、TaとRTOの計算に異なる式が定義されていました。"
    },
    {
      "indent": 3,
      "text": "The formulas below result in a behavior whereby an agent will send its first packet for every single connectivity check before performing a retransmit. This can be seen in the formulas for the RTO (which represents the retransmit interval). Those formulas scale with N, the number of checks to be performed. As a result of this, ICE maintains a nicely constant rate, but it becomes more sensitive to packet loss. The loss of the first single packet for any connectivity check is likely to cause that pair to take a long time to be validated, and instead, a lower-priority check (but one for which there was no packet loss) is much more likely to complete first. This results in ICE performing suboptimally, choosing lower-priority pairs over higher-priority pairs.",
      "ja": "以下の式により、エージェントは、再送信を実行する前に、接続チェックごとに最初のパケットを送信するという動作になります。 これは、RTOの式（再送信間隔を表す）で確認できます。 これらの式は、実行されるチェックの数であるNに比例します。 この結果、ICEは一定のレートを維持しますが、パケット損失の影響を受けやすくなります。 接続チェックで最初の単一パケットが失われると、そのペアの検証に時間がかかる可能性が高くなり、代わりに、優先度の低いチェック（ただし、パケット損失がなかったもの）のほうがはるかに高い可能性があります 最初に完了します。 これにより、ICEのパフォーマンスが最適化されず、優先度の高いペアよりも優先度の低いペアが選択されます。"
    },
    {
      "indent": 0,
      "text": "14.2. Ta",
      "section_title": true,
      "ja": "14.2.  タ"
    },
    {
      "indent": 3,
      "text": "ICE agents SHOULD use a default Ta value, 50 ms, but MAY use another value based on the characteristics of the associated data.",
      "ja": "ICEエージェントはデフォルトのTa値である50ミリ秒を使用する必要がありますが、関連データの特性に基づいて別の値を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "If an agent wants to use a Ta value other than the default value, the agent MUST indicate the proposed value to its peer during the establishment of the ICE session. Both agents MUST use the higher value of the proposed values. If an agent does not propose a value, the default value is used for that agent when comparing which value is higher.",
      "ja": "エージェントがデフォルト値以外のTa値を使用したい場合、エージェントはICEセッションの確立中にピアに提案された値を示さなければなりません。 両方のエージェントは、提案された値の高い値を使用する必要があります。 エージェントが値を提案しない場合、どちらの値が高いかを比較するときにデフォルト値がそのエージェントに使用されます。"
    },
    {
      "indent": 3,
      "text": "Regardless of the Ta value chosen for each agent, the combination of all transactions from all agents (if a given implementation runs several concurrent agents) MUST NOT be sent more often than once every 5 ms (as though there were one global Ta value for pacing all agents). See Appendix B.1 for the background of using a value of 5 ms with ICE.",
      "ja": "各エージェントに選択されたTa値に関係なく、すべてのエージェントからのすべてのトランザクションの組み合わせ（特定の実装が複数の同時エージェントを実行する場合）は、5ミリ秒ごとに1回よりも頻繁に送信してはなりません（ペーシングに1つのグローバルTa値があるように） すべてのエージェント）。 ICEで5ミリ秒の値を使用する背景については、付録B.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "NOTE: Appendix C shows examples of required bandwidth, using different Ta values.",
      "ja": "注：付録Cは、さまざまなTa値を使用した、必要な帯域幅の例を示しています。"
    },
    {
      "indent": 0,
      "text": "14.3. RTO",
      "section_title": true,
      "ja": "14.3.  RTO"
    },
    {
      "indent": 3,
      "text": "During the ICE gathering phase, ICE agents SHOULD calculate the RTO value using the following formula:",
      "ja": "ICE収集フェーズでは、ICEエージェントは次の式を使用してRTO値を計算する必要があります。"
    },
    {
      "indent": 5,
      "text": "RTO = MAX (500ms, Ta * (Num-Of-Cands))",
      "ja": "RTO = MAX（500ミリ秒、宛先*（カード数））"
    },
    {
      "indent": 5,
      "text": "Num-Of-Cands: the number of server-reflexive and relay candidates",
      "ja": "Number-Of-Cards：サーバー反射型およびリレー候補の数"
    },
    {
      "indent": 3,
      "text": "For connectivity checks, agents SHOULD calculate the RTO value using the following formula:",
      "ja": "接続性チェックの場合、エージェントは次の式を使用してRTO値を計算する必要があります。"
    },
    {
      "indent": 5,
      "text": "RTO = MAX (500ms, Ta * N * (Num-Waiting + Num-In-Progress))",
      "ja": "RTO = MAX（500ms、Ta * N *（Num-Waiting + Num-In-Progress））"
    },
    {
      "indent": 5,
      "text": "N: the total number of connectivity checks to be performed.",
      "ja": "N：実行される接続チェックの総数。"
    },
    {
      "indent": 5,
      "text": "Num-Waiting: the number of checks in the checklist set in the Waiting state.",
      "ja": "Num-Waiting：待機状態に設定されたチェックリストのチェック数。"
    },
    {
      "indent": 5,
      "text": "Num-In-Progress: the number of checks in the checklist set in the In-Progress state.",
      "ja": "Num-In-Progress：In-Progress状態で設定されたチェックリスト内のチェックの数。"
    },
    {
      "indent": 5,
      "text": "Note that the RTO will be different for each transaction as the number of checks in the Waiting and In-Progress states change.",
      "ja": "待機中および進行中の状態のチェックの数が変わると、RTOはトランザクションごとに異なることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Agents MAY calculate the RTO value using other mechanisms than those described above. Agents MUST NOT use an RTO value smaller than 500 ms.",
      "ja": "エージェントは、上記以外のメカニズムを使用してRTO値を計算できます。 エージェントは、500ミリ秒未満のRTO値を使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "15. Examples",
      "section_title": true,
      "ja": "15.例"
    },
    {
      "indent": 3,
      "text": "This section shows two ICE examples: one using IPv4 addresses and one using IPv6 addresses.",
      "ja": "このセクションでは、2つのICEの例を示します。1つはIPv4アドレスを使用し、もう1つはIPv6アドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "To facilitate understanding, transport addresses are listed using variables that have mnemonic names. The format of the name is entity-type-seqno: \"entity\" refers to the entity whose IP address the transport address is on and is one of \"L\", \"R\", \"STUN\", or \"NAT\". The type is either \"PUB\" for transport addresses that are public or \"PRIV\" for transport addresses that are private [RFC1918]. Finally,",
      "ja": "理解を容易にするため、トランスポートアドレスはニーモニック名を持つ変数を使用してリストされます。 名前の形式はentity-type-seqnoです。「entity」は、トランスポートアドレスが存在するIPアドレスを持つエンティティを指し、「L」、「R」、「STUN」、または「NAT」のいずれかです。 タイプは、パブリックのトランスポートアドレスの場合は「PUB」、プライベートのトランスポートアドレスの場合は「PRIV」です[RFC1918]。 最後に、"
    },
    {
      "indent": 3,
      "text": "seq-no is a sequence number that is different for each transport address of the same type on a particular entity. Each variable has an IP address and port, denoted by varname.IP and varname.PORT, respectively, where varname is the name of the variable.",
      "ja": "seq-noは、特定のエンティティの同じタイプのトランスポートアドレスごとに異なるシーケンス番号です。 各変数にはIPアドレスとポートがあり、それぞれvarname.IPとvarname.PORTで示されます。ここで、varnameは変数の名前です。"
    },
    {
      "indent": 3,
      "text": "In the call flow itself, STUN messages are annotated with several attributes. The \"S=\" attribute indicates the source transport address of the message. The \"D=\" attribute indicates the destination transport address of the message. The \"MA=\" attribute is used in STUN Binding response messages and refers to the mapped address. \"USE-CAND\" implies the presence of the USE-CANDIDATE attribute.",
      "ja": "コールフロー自体では、STUNメッセージにはいくつかの属性が付けられています。 「S =」属性は、メッセージの送信元トランスポートアドレスを示します。 「D =」属性は、メッセージの宛先トランスポートアドレスを示します。 「MA =」属性は、STUNバインディング応答メッセージで使用され、マッピングされたアドレスを参照します。 「USE-CAND」は、USE-CANDIDATE属性の存在を意味します。"
    },
    {
      "indent": 3,
      "text": "The call flow examples omit STUN authentication operations and focus on a single data stream between two full implementations.",
      "ja": "コールフローの例では、STUN認証操作を省略し、2つの完全な実装間の単一のデータストリームに焦点を当てています。"
    },
    {
      "indent": 0,
      "text": "15.1. Example with IPv4 Addresses",
      "section_title": true,
      "ja": "15.1.  IPv4アドレスの例"
    },
    {
      "indent": 3,
      "text": "The example below is using the topology shown in Figure 7.",
      "ja": "次の例では、図7に示すトポロジを使用しています。"
    },
    {
      "indent": 22,
      "text": "            +-------+\n            |STUN   |\n            |Server |\n            +-------+\n                |\n     +---------------------+\n     |                     |\n     |      Internet       |\n     |                     |\n     +---------------------+\n       |                |\n       |                |\n+---------+             |\n|   NAT   |             |\n+---------+             |\n     |                  |\n     |                  |\n  +-----+            +-----+\n  |  L  |            |  R  |\n  +-----+            +-----+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 7: Example Topology",
      "ja": "図7：トポロジの例"
    },
    {
      "indent": 3,
      "text": "In the example, ICE agents L and R are full ICE implementations. Both agents have a single IPv4 address, and both are configured with the same STUN server. The NAT has an endpoint-independent mapping property and an address-dependent filtering property. The IP addresses of the ICE agents, the STUN server, and the NAT are shown below:",
      "ja": "この例では、ICEエージェントLおよびRは完全なICE実装です。 両方のエージェントには単一のIPv4アドレスがあり、両方とも同じSTUNサーバーで構成されています。 NATには、エンドポイントに依存しないマッピングプロパティとアドレスに依存するフィルタリングプロパティがあります。 ICEエージェント、STUNサーバー、およびNATのIPアドレスを以下に示します。"
    },
    {
      "indent": 3,
      "text": "ENTITY                   IP Address  Mnemonic name\n--------------------------------------------------\nICE Agent L:             10.0.1.1    L-PRIV-1\nICE Agent R:             192.0.2.1   R-PUB-1\nSTUN Server:             192.0.2.2   STUN-PUB-1\nNAT (Public):            192.0.2.3   NAT-PUB-1",
      "raw": true
    },
    {
      "indent": 13,
      "text": "L             NAT           STUN             R\n|STUN alloc.   |              |              |\n|(1) STUN Req  |              |              |\n|S=$L-PRIV-1   |              |              |\n|D=$STUN-PUB-1 |              |              |\n|------------->|              |              |\n|              |(2) STUN Req  |              |\n|              |S=$NAT-PUB-1  |              |\n|              |D=$STUN-PUB-1 |              |\n|              |------------->|              |\n|              |(3) STUN Res  |              |\n|              |S=$STUN-PUB-1 |              |\n|              |D=$NAT-PUB-1  |              |\n|              |MA=$NAT-PUB-1 |              |\n|              |<-------------|              |\n|(4) STUN Res  |              |              |\n|S=$STUN-PUB-1 |              |              |\n|D=$L-PRIV-1   |              |              |\n|MA=$NAT-PUB-1 |              |              |\n|<-------------|              |              |\n|(5) L's Candidate Information|              |\n|------------------------------------------->|\n|              |              |              | STUN\n|              |              |              | alloc.\n|              |              |(6) STUN Req  |\n|              |              |S=$R-PUB-1    |\n|              |              |D=$STUN-PUB-1 |\n|              |              |<-------------|\n|              |              |(7) STUN Res  |\n|              |              |S=$STUN-PUB-1 |\n|              |              |D=$R-PUB-1    |\n|              |              |MA=$R-PUB-1   |\n|              |              |------------->|",
      "raw": true
    },
    {
      "indent": 13,
      "text": "|(8) R's Candidate Information|              |\n|<-------------------------------------------|\n|              |         (9) Bind Req        |Begin\n|              |         S=$R-PUB-1          |Connectivity\n|              |         D=$L-PRIV-1         |Checks\n|              |         <-------------------|\n|              |         Dropped             |\n|(10) Bind Req |              |              |\n|S=$L-PRIV-1   |              |              |\n|D=$R-PUB-1    |              |              |\n|------------->|              |              |\n|              |(11) Bind Req |              |\n|              |S=$NAT-PUB-1  |              |\n|              |D=$R-PUB-1    |              |\n|              |---------------------------->|\n|              |(12) Bind Res |              |\n|              |S=$R-PUB-1    |              |\n|              |D=$NAT-PUB-1  |              |\n|              |MA=$NAT-PUB-1 |              |\n|              |<----------------------------|\n|(13) Bind Res |              |              |\n|S=$R-PUB-1    |              |              |\n|D=$L-PRIV-1   |              |              |\n|MA=$NAT-PUB-1 |              |              |\n|<-------------|              |              |\n|Data          |              |              |\n|===========================================>|\n|              |              |              |\n|              |(14) Bind Req |              |\n|              |S=$R-PUB-1    |              |\n|              |D=$NAT-PUB-1  |              |\n|              |<----------------------------|\n|(15) Bind Req |              |              |\n|S=$R-PUB-1    |              |              |\n|D=$L-PRIV-1   |              |              |\n|<-------------|              |              |\n|(16) Bind Res |              |              |\n|S=$L-PRIV-1   |              |              |\n|D=$R-PUB-1    |              |              |\n|MA=$R-PUB-1   |              |              |\n|------------->|              |              |\n|              |(17) Bind Res |              |\n|              |S=$NAT-PUB-1  |              |\n|              |D=$R-PUB-1    |              |\n|              |MA=$R-PUB-1   |              |\n|              |---------------------------->|\n|Data          |              |              |\n|<===========================================|",
      "raw": true
    },
    {
      "indent": 13,
      "text": "|              |              |              |\n                   .......\n|              |              |              |\n|(18) Bind Req |              |              |\n|S=$L-PRIV-1   |              |              |\n|D=$R-PUB-1    |              |              |\n|USE-CAND      |              |              |\n|------------->|              |              |\n|              |(19) Bind Req |              |\n|              |S=$NAT-PUB-1  |              |\n|              |D=$R-PUB-1    |              |\n|              |USE-CAND      |              |\n|              |---------------------------->|\n|              |(20) Bind Res |              |\n|              |S=$R-PUB-1    |              |\n|              |D=$NAT-PUB-1  |              |\n|              |MA=$NAT-PUB-1 |              |\n|              |<----------------------------|\n|(21) Bind Res |              |              |\n|S=$R-PUB-1    |              |              |\n|D=$L-PRIV-1   |              |              |\n|MA=$NAT-PUB-1 |              |              |\n|<-------------|              |              |\n|              |              |              |",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 8: Example Flow",
      "ja": "図8：フローの例"
    },
    {
      "indent": 3,
      "text": "Messages 1-4: Agent L gathers a host candidate from its local IP address, and from that it sends a STUN Binding request to the STUN server. The request creates a NAT binding. The NAT public IP address of the binding becomes agent L's server-reflexive candidate.",
      "ja": "メッセージ1-4：エージェントLは、ローカルIPアドレスからホスト候補を収集し、そこからSTUNバインディング要求をSTUNサーバーに送信します。 要求はNATバインディングを作成します。 バインディングのNATパブリックIPアドレスは、エージェントLのサーバー反射候補になります。"
    },
    {
      "indent": 3,
      "text": "Message 5: Agent L sends its local candidate information to agent R, using the signaling protocol associated with the ICE usage.",
      "ja": "メッセージ5：エージェントLは、ICEの使用に関連付けられたシグナリングプロトコルを使用して、ローカル候補情報をエージェントRに送信します。"
    },
    {
      "indent": 3,
      "text": "Messages 6-7: Agent R gathers a host candidate from its local IP address, and from that it sends a STUN Binding request to the STUN server. Since agent R is not behind a NAT, R's server-reflexive candidate will be identical to the host candidate.",
      "ja": "メッセージ6-7：エージェントRは、ローカルIPアドレスからホスト候補を収集し、そこからSTUNバインディング要求をSTUNサーバーに送信します。 エージェントRはNATの背後にないため、Rのサーバー反射候補はホスト候補と同一になります。"
    },
    {
      "indent": 3,
      "text": "Message 8: Agent R sends its local candidate information to agent L, using the signaling protocol associated with the ICE usage.",
      "ja": "メッセージ8：エージェントRは、ICEの使用に関連付けられたシグナリングプロトコルを使用して、ローカル候補情報をエージェントLに送信します。"
    },
    {
      "indent": 3,
      "text": "Since both agents are full ICE implementations, the initiating agent (agent L) becomes the controlling agent.",
      "ja": "両方のエージェントが完全なICE実装であるため、開始エージェント（エージェントL）が制御エージェントになります。"
    },
    {
      "indent": 3,
      "text": "Agents L and R both pair up the candidates. Both agents initially have two pairs. However, agent L will prune the pair containing its server-reflexive candidate, resulting in just one (L1). At agent L, this pair has a local candidate of $L_PRIV_1 and a remote candidate of $R_PUB_1. At agent R, there are two pairs. The highest-priority pair (R1) has a local candidate of $R_PUB_1 and a remote candidate of $L_PRIV_1, and the second pair (R2) has a local candidate of $R_PUB_1 and a remote candidate of $NAT_PUB_1. The pairs are shown below (the pair numbers are for reference purposes only):",
      "ja": "エージェントLとRは両方とも候補をペアにします。 両方のエージェントには、最初に2つのペアがあります。 ただし、エージェントLは、サーバー反射候補を含むペアを整理し、1つ（L1）のみにします。 エージェントLでは、このペアには$ L_PRIV_1のローカル候補と$ R_PUB_1のリモート候補があります。 エージェントRには、2つのペアがあります。 最も優先度の高いペア（R1）にはローカル候補$ R_PUB_1とリモート候補$ L_PRIV_1があり、2番目のペア（R2）にはローカル候補$ R_PUB_1とリモート候補$ NAT_PUB_1があります。 ペアを以下に示します（ペア番号は参照のみを目的としています）。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PRIV_1      R_PUB_1       L1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2",
      "ja": "ICEエージェントR：R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2"
    },
    {
      "indent": 3,
      "text": "Message 9: Agent R initiates a connectivity check for pair #2. As the remote candidate of the pair is the private address of agent L, the check will not be successful, as the request cannot be routed from R to L, and will be dropped by the network.",
      "ja": "メッセージ9：エージェントRはペア＃2の接続チェックを開始します。 ペアのリモート候補はエージェントLのプライベートアドレスであるため、要求はRからLにルーティングできず、ネットワークによってドロップされるため、チェックは成功しません。"
    },
    {
      "indent": 3,
      "text": "Messages 10-13: Agent L initiates a connectivity check for pair L1. The check succeeds, and L creates a new pair (L2). The local candidate of the new pair is $NAT_PUB_1, and the remote candidate is $R_PUB_1. The pair (L2) is added to the valid list of agent L. Agent L can now send and receive data on the pair (L2) if it wishes.",
      "ja": "メッセージ10-13：エージェントLはペアL1の接続性チェックを開始します。 チェックは成功し、Lは新しいペア（L2）を作成します。 新しいペアのローカル候補は$ NAT_PUB_1で、リモート候補は$ R_PUB_1です。 ペア（L2）はエージェントLの有効なリストに追加されます。エージェントLは、必要に応じてペア（L2）でデータを送受信できるようになりました。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PRIV_1      R_PUB_1       L1\n                         NAT_PUB_1     R_PUB_1       L2        X",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2",
      "ja": "ICEエージェントR：R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2"
    },
    {
      "indent": 3,
      "text": "Messages 14-17: When agent R receives the Binding request from agent L (message 11), it will initiate a triggered connectivity check. The pair matches one of agent R's existing pairs (R2). The check succeeds, and the pair (R2) is added to the valid list of agent R. Agent R can now send and receive data on the pair (R2) if it wishes.",
      "ja": "メッセージ14〜17：エージェントRがエージェントLからバインド要求を受信すると（メッセージ11）、トリガーされた接続チェックを開始します。 ペアは、エージェントRの既存のペア（R2）のいずれかと一致します。 チェックは成功し、ペア（R2）はエージェントRの有効なリストに追加されます。エージェントRは必要に応じてペア（R2）でデータを送受信できるようになりました。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PRIV_1      R_PUB_1       L1\n                         NAT_PUB_1     R_PUB_1       L2        X",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2 X",
      "ja": "ICEエージェントR：R_PUB_1 L_PRIV_1 R1 R_PUB_1 NAT_PUB_1 R2 X"
    },
    {
      "indent": 3,
      "text": "Messages 18-21: At some point, the controlling agent (agent L) decides to nominate a pair (L2) in the valid list. It performs a connectivity check on the pair (L2) and includes the USE-CANDIDATE attribute in the Binding request. As the check succeeds, agent L sets the nominated flag value of the pair (L2) to 'true', and agent R sets the nominated flag value of the matching pair (R2) to 'true'. As there are no more components associated with the stream, the nominated pairs become the selected pairs. Consequently, processing for this stream moves into the Completed state. The ICE process also moves into the Completed state.",
      "ja": "メッセージ18〜21：ある時点で、制御エージェント（エージェントL）が有効なリストにペア（L2）を指定することを決定します。 ペア（L2）の接続性チェックを実行し、バインド要求にUSE-CANDIDATE属性を含めます。 チェックが成功すると、エージェントLはペアの指定フラグ値（L2）を「true」に設定し、エージェントRは一致するペアの指定フラグ値（R2）を「true」に設定します。 ストリームに関連付けられたコンポーネントがなくなるため、指定されたペアが選択されたペアになります。 その結果、このストリームの処理は完了状態に移行します。 ICEプロセスも完了状態に移行します。"
    },
    {
      "indent": 0,
      "text": "15.2. Example with IPv6 Addresses",
      "section_title": true,
      "ja": "15.2.  IPv6アドレスの例"
    },
    {
      "indent": 3,
      "text": "The example below is using the topology shown in Figure 9.",
      "ja": "以下の例では、図9に示すトポロジを使用しています。"
    },
    {
      "indent": 25,
      "text": "       +-------+\n       |STUN   |\n       |Server |\n       +-------+\n           |\n+---------------------+\n|                     |\n|      Internet       |\n|                     |\n+---------------------+\n   |                |\n   |                |\n   |                |\n   |                |\n   |                |\n   |                |\n   |                |\n+-----+          +-----+\n|  L  |          |  R  |\n+-----+          +-----+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 9: Example Topology",
      "ja": "図9：トポロジの例"
    },
    {
      "indent": 3,
      "text": "In the example, ICE agents L and R are full ICE implementations. Both agents have a single IPv6 address, and both are configured with the same STUN server. The IP addresses of the ICE agents and the STUN server are shown below:",
      "ja": "この例では、ICEエージェントLおよびRは完全なICE実装です。 両方のエージェントには単一のIPv6アドレスがあり、両方とも同じSTUNサーバーで構成されています。 ICEエージェントとSTUNサーバーのIPアドレスを以下に示します。"
    },
    {
      "indent": 3,
      "text": "ENTITY                   IP Address  mnemonic name\n--------------------------------------------------\nICE Agent L:             2001:db8::3   L-PUB-1\nICE Agent R:             2001:db8::5   R-PUB-1\nSTUN Server:             2001:db8::9   STUN-PUB-1",
      "raw": true
    },
    {
      "indent": 13,
      "text": "L                           STUN             R\n|STUN alloc.                  |              |\n|(1) STUN Req                 |              |\n|S=$L-PUB-1                   |              |\n|D=$STUN-PUB-1                |              |\n|---------------------------->|              |\n|(2) STUN Res                 |              |\n| S=$STUN-PUB-1               |              |\n| D=$L-PUB-1                  |              |\n| MA=$L-PUB-1                 |              |\n|<----------------------------|              |\n|(3) L's Candidate Information|              |\n|------------------------------------------->|\n|                             |              | STUN\n|                             |              | alloc.\n|                             |(4) STUN Req  |\n|                             |S=$R-PUB-1    |\n|                             |D=$STUN-PUB-1 |\n|                             |<-------------|\n|                             |(5) STUN Res  |\n|                             |S=$STUN-PUB-1 |\n|                             |D=$R-PUB-1    |\n|                             |MA=$R-PUB-1   |\n|                             |------------->|\n|(6) R's Candidate Information|              |\n|<-------------------------------------------|\n|(7) Bind Req                 |              |\n|S=$L-PUB-1                   |              |\n|D=$R-PUB-1                   |              |\n|------------------------------------------->|\n|(8) Bind Res                 |              |\n|S=$R-PUB-1                   |              |\n|D=$L-PUB-1                   |              |\n|MA=$L-PUB-1                  |              |\n|<-------------------------------------------|",
      "raw": true
    },
    {
      "indent": 13,
      "text": "|Data                         |              |\n|===========================================>|\n|                             |              |\n|(9) Bind Req                 |              |\n|S=$R-PUB-1                   |              |\n|D=$L-PUB-1                   |              |\n|<-------------------------------------------|\n|(10) Bind Res                |              |\n|S=$L-PUB-1                   |              |\n|D=$R-PUB-1                   |              |\n|MA=$R-PUB-1                  |              |\n|------------------------------------------->|\n|Data                         |              |\n|<===========================================|\n|                             |              |\n                   .......\n|                             |              |\n|(11) Bind Req                |              |\n|S=$L-PUB-1                   |              |\n|D=$R-PUB-1                   |              |\n|USE-CAND                     |              |\n|------------------------------------------->|\n|(12) Bind Res                |              |\n|S=$R-PUB-1                   |              |\n|D=$L-PUB-1                   |              |\n|MA=$L-PUB-1                  |              |\n|<-------------------------------------------|\n|              |              |              |",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 10: Example Flow",
      "ja": "図10：フローの例"
    },
    {
      "indent": 3,
      "text": "Messages 1-2: Agent L gathers a host candidate from its local IP address, and from that it sends a STUN Binding request to the STUN server. Since agent L is not behind a NAT, L's server-reflexive candidate will be identical to the host candidate.",
      "ja": "メッセージ1-2：エージェントLは、ローカルIPアドレスからホスト候補を収集し、そこからSTUNバインディング要求をSTUNサーバーに送信します。 エージェントLはNATの背後にないため、Lのサーバー反射候補はホスト候補と同一になります。"
    },
    {
      "indent": 3,
      "text": "Message 3: Agent L sends its local candidate information to agent R, using the signaling protocol associated with the ICE usage.",
      "ja": "メッセージ3：エージェントLは、ICEの使用に関連付けられたシグナリングプロトコルを使用して、ローカル候補情報をエージェントRに送信します。"
    },
    {
      "indent": 3,
      "text": "Messages 4-5: Agent R gathers a host candidate from its local IP address, and from that it sends a STUN Binding request to the STUN server. Since agent R is not behind a NAT, R's server-reflexive candidate will be identical to the host candidate.",
      "ja": "メッセージ4〜5：エージェントRは、ローカルIPアドレスからホスト候補を収集し、そこからSTUNバインディング要求をSTUNサーバーに送信します。 エージェントRはNATの背後にないため、Rのサーバー反射候補はホスト候補と同一になります。"
    },
    {
      "indent": 3,
      "text": "Message 6: Agent R sends its local candidate information to agent L, using the signaling protocol associated with the ICE usage.",
      "ja": "メッセージ6：エージェントRは、ICEの使用に関連付けられたシグナリングプロトコルを使用して、ローカル候補情報をエージェントLに送信します。"
    },
    {
      "indent": 3,
      "text": "Since both agents are full ICE implementations, the initiating agent (agent L) becomes the controlling agent.",
      "ja": "両方のエージェントが完全なICE実装であるため、開始エージェント（エージェントL）が制御エージェントになります。"
    },
    {
      "indent": 3,
      "text": "Agents L and R both pair up the candidates. Both agents initially have one pair each. At agent L, the pair (L1) has a local candidate of $L_PUB_1 and a remote candidate of $R_PUB_1. At agent R, the pair (R1) has a local candidate of $R_PUB_1 and a remote candidate of $L_PUB_1. The pairs are shown below (the pair numbers are for reference purpose only):",
      "ja": "エージェントLとRは両方とも候補をペアにします。 両方のエージェントには、最初にそれぞれ1つのペアがあります。 エージェントLでは、ペア（L1）には$ L_PUB_1のローカル候補と$ R_PUB_1のリモート候補があります。 エージェントRでは、ペア（R1）のローカル候補は$ R_PUB_1で、リモート候補は$ L_PUB_1です。 ペアを以下に示します（ペア番号は参照専用です）。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PUB_1       R_PUB_1       L1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PUB_1 R1",
      "ja": "ICEエージェントR：R_PUB_1 L_PUB_1 R1"
    },
    {
      "indent": 3,
      "text": "Messages 7-8: Agent L initiates a connectivity check for pair L1. The check succeeds, and the pair (L1) is added to the valid list of agent L. Agent L can now send and receive data on the pair (L1) if it wishes.",
      "ja": "メッセージ7〜8：エージェントLは、ペアL1の接続チェックを開始します。 チェックは成功し、ペア（L1）はエージェントLの有効なリストに追加されます。エージェントLは、必要に応じてペア（L1）でデータを送受信できるようになりました。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PUB_1       R_PUB_1       L1         X",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PUB_1 R1",
      "ja": "ICEエージェントR：R_PUB_1 L_PUB_1 R1"
    },
    {
      "indent": 3,
      "text": "Messages 9-10: When agent R receives the Binding request from agent L (message 7), it will initiate a triggered connectivity check. The pair matches agent R's existing pair (R1). The check succeeds, and the pair (R1) is added to the valid list of agent R. Agent R can now send and receive data on the pair (R1) if it wishes.",
      "ja": "メッセージ9〜10：エージェントRがエージェントLからバインディング要求を受信すると（メッセージ7）、トリガーされた接続性チェックを開始します。 このペアは、エージェントRの既存のペア（R1）と一致します。 チェックは成功し、ペア（R1）はエージェントRの有効なリストに追加されます。エージェントRは、必要に応じてペア（R1）でデータを送受信できるようになりました。"
    },
    {
      "indent": 3,
      "text": "                         Pairs\nENTITY                   Local         Remote     Pair #     Valid\n------------------------------------------------------------------\nICE Agent L:             L_PUB_1       R_PUB_1       L1         X",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICE Agent R: R_PUB_1 L_PUB_1 R1 X",
      "ja": "ICEエージェントR：R_PUB_1 L_PUB_1 R1 X"
    },
    {
      "indent": 3,
      "text": "Messages 11-12: At some point, the controlling agent (agent L) decides to nominate a pair (L1) in the valid list. It performs a connectivity check on the pair (L1) and includes the USE-CANDIDATE attribute in the Binding request. As the check succeeds, agent L sets the nominated flag value of the pair (L1) to 'true', and agent R sets the nominated flag value of the matching pair (R1) to 'true'.",
      "ja": "メッセージ11〜12：ある時点で、制御エージェント（エージェントL）が有効なリストにペア（L1）を指定することを決定します。 ペア（L1）の接続性チェックを実行し、バインド要求にUSE-CANDIDATE属性を含めます。 チェックが成功すると、エージェントLはペアの指定フラグ値（L1）を「true」に設定し、エージェントRは一致するペアの指定フラグ値（R1）を「true」に設定します。"
    },
    {
      "indent": 3,
      "text": "As there are no more components associated with the stream, the nominated pairs become the selected pairs. Consequently, processing for this stream moves into the Completed state. The ICE process also moves into the Completed state.",
      "ja": "ストリームに関連付けられたコンポーネントがなくなるため、指定されたペアが選択されたペアになります。 その結果、このストリームの処理は完了状態に移行します。 ICEプロセスも完了状態に移行します。"
    },
    {
      "indent": 0,
      "text": "16. STUN Extensions",
      "section_title": true,
      "ja": "16. STUN拡張機能"
    },
    {
      "indent": 0,
      "text": "16.1. Attributes",
      "section_title": true,
      "ja": "16.1.  属性"
    },
    {
      "indent": 3,
      "text": "This specification defines four STUN attributes: PRIORITY, USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.",
      "ja": "この仕様では、PRIORITY、USE-CANDIDATE、ICE-CONTROLLED、およびICE-CONTROLLINGの4つのSTUN属性を定義しています。"
    },
    {
      "indent": 3,
      "text": "The PRIORITY attribute indicates the priority that is to be associated with a peer-reflexive candidate, if one will be discovered by this check. It is a 32-bit unsigned integer and has an attribute value of 0x0024.",
      "ja": "PRIORITY属性は、このチェックによって発見された場合、ピア反射候補に関連付けられる優先度を示します。 32ビットの符号なし整数であり、属性値は0x0024です。"
    },
    {
      "indent": 3,
      "text": "The USE-CANDIDATE attribute indicates that the candidate pair resulting from this check will be used for transmission of data. The attribute has no content (the Length field of the attribute is zero); it serves as a flag. It has an attribute value of 0x0025.",
      "ja": "USE-CANDIDATE属性は、このチェックの結果の候補ペアがデータの送信に使用されることを示します。 属性にはコンテンツがありません（属性の長さフィールドはゼロです）。 フラグとして機能します。 属性値は0x0025です。"
    },
    {
      "indent": 3,
      "text": "The ICE-CONTROLLED attribute is present in a Binding request. The attribute indicates that the client believes it is currently in the controlled role. The content of the attribute is a 64-bit unsigned integer in network byte order, which contains a random number. The number is used for solving role conflicts, when it is referred to as the \"tiebreaker value\". An ICE agent MUST use the same number for all Binding requests, for all streams, within an ICE session, unless it has received a 487 response, in which case it MUST change the number (Section 7.2.5.1). The agent MAY change the number when an ICE restart occurs.",
      "ja": "ICE-CONTROLLED属性は、バインディング要求に存在します。 この属性は、クライアントが現在制御されている役割にあるとクライアントが信じていることを示します。 属性の内容は、ネットワークバイト順の64ビット符号なし整数で、乱数が含まれています。 この番号は、「タイブレーカー値」と呼ばれる場合に、役割の競合を解決するために使用されます。 ICEエージェントは、487応答を受信しない限り、ICEセッション内のすべてのバインディング要求、すべてのストリーム、同じ番号を使用する必要があります。その場合、番号を変更する必要があります（セクション7.2.5.1）。 エージェントは、ICEの再起動時に番号を変更できます。"
    },
    {
      "indent": 3,
      "text": "The ICE-CONTROLLING attribute is present in a Binding request. The attribute indicates that the client believes it is currently in the controlling role. The content of the attribute is a 64-bit unsigned integer in network byte order, which contains a random number. As for the ICE-CONTROLLED attribute, the number is used for solving role conflicts. An agent MUST use the same number for all Binding requests, for all streams, within an ICE session, unless it has received a 487 response, in which case it MUST change the number (Section 7.2.5.1). The agent MAY change the number when an ICE restart occurs.",
      "ja": "ICE-CONTROLLING属性は、バインディング要求に存在します。 この属性は、クライアントが現在制御ロールにいると考えていることを示します。 属性の内容は、ネットワークバイト順の64ビット符号なし整数で、乱数が含まれています。 ICE-CONTROLLED属性に関しては、番号はロールの競合を解決するために使用されます。 エージェントは、487応答を受信しない限り、ICEセッション内のすべてのバインディング要求、すべてのストリーム、同じ番号を使用する必要があります。その場合、番号を変更する必要があります（セクション7.2.5.1）。 エージェントは、ICEの再起動時に番号を変更できます。"
    },
    {
      "indent": 0,
      "text": "16.2. New Error-Response Codes",
      "section_title": true,
      "ja": "16.2.  新しいエラー応答コード"
    },
    {
      "indent": 3,
      "text": "This specification defines a single error-response code:",
      "ja": "この仕様では、単一のエラー応答コードを定義しています。"
    },
    {
      "indent": 3,
      "text": "487 (Role Conflict): The Binding request contained either the ICE-CONTROLLING or ICE-CONTROLLED attribute, indicating an ICE role that conflicted with the server. The remote server compared the tiebreaker values of the client and the server and determined that the client needs to switch roles.",
      "ja": "487（ロールの競合）：バインディング要求にICE-CONTROLLINGまたはICE-CONTROLLED属性のいずれかが含まれ、サーバーと競合したICEロールを示しています。 リモートサーバーは、クライアントとサーバーのタイブレーカー値を比較し、クライアントがロールを切り替える必要があると判断しました。"
    },
    {
      "indent": 0,
      "text": "17. Operational Considerations",
      "section_title": true,
      "ja": "17.操作上の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses issues relevant to operators operating networks where ICE will be used by endpoints.",
      "ja": "このセクションでは、エンドポイントがICEを使用するネットワークを運用しているオペレーターに関連する問題について説明します。"
    },
    {
      "indent": 0,
      "text": "17.1. NAT and Firewall Types",
      "section_title": true,
      "ja": "17.1.  NATおよびファイアウォールタイプ"
    },
    {
      "indent": 3,
      "text": "ICE was designed to work with existing NAT and firewall equipment. Consequently, it is not necessary to replace or reconfigure existing firewall and NAT equipment in order to facilitate deployment of ICE. Indeed, ICE was developed to be deployed in environments where the Voice over IP (VoIP) operator has no control over the IP network infrastructure, including firewalls and NATs.",
      "ja": "ICEは、既存のNATおよびファイアウォール機器で動作するように設計されました。 したがって、ICEの展開を容易にするために、既存のファイアウォールおよびNAT機器を交換または再構成する必要はありません。 実際、ICEは、Voice over IP（VoIP）オペレーターがファイアウォールやNATなどのIPネットワークインフラストラクチャを制御できない環境に展開するために開発されました。"
    },
    {
      "indent": 3,
      "text": "That said, ICE works best in environments where the NAT devices are \"behave\" compliant, meeting the recommendations defined in [RFC4787] and [RFC5382]. In networks with behave-compliant NAT, ICE will work without the need for a TURN server, thus improving voice quality, decreasing call setup times, and reducing the bandwidth demands on the network operator.",
      "ja": "とは言っても、ICEは[RFC4787]および[RFC5382]で定義されている推奨事項を満たし、NATデバイスが「動作」に準拠している環境で最適に機能します。 動作準拠のNATを備えたネットワークでは、ICEはTURNサーバーを必要とせずに動作するため、音声品質が向上し、コールのセットアップ時間が短縮され、ネットワークオペレーターの帯域幅需要が削減されます。"
    },
    {
      "indent": 0,
      "text": "17.2. Bandwidth Requirements",
      "section_title": true,
      "ja": "17.2.  帯域幅の要件"
    },
    {
      "indent": 3,
      "text": "Deployment of ICE can have several interactions with available network capacity that operators need to take into consideration.",
      "ja": "ICEの展開では、オペレーターが考慮する必要のある利用可能なネットワーク容量といくつかの相互作用があります。"
    },
    {
      "indent": 0,
      "text": "17.2.1. STUN and TURN Server-Capacity Planning",
      "section_title": true,
      "ja": "17.2.1.  STUNおよびTURNサーバーの容量計画"
    },
    {
      "indent": 3,
      "text": "First and foremost, ICE makes use of TURN and STUN servers, which would typically be located in data centers. The STUN servers require relatively little bandwidth. For each component of each data stream, there will be one or more STUN transactions from each client to the STUN server. In a basic voice-only IPv4 VoIP deployment, there will be four transactions per call (one for RTP and one for RTCP, for both the caller and callee). Each transaction is a single request and a single response, the former being 20 bytes long, and the latter, 28.",
      "ja": "何よりもまず、ICEはTURNおよびSTUNサーバーを使用します。これらは通常、データセンターに配置されます。 STUNサーバーは、比較的小さな帯域幅しか必要としません。 各データストリームの各コンポーネントには、各クライアントからSTUNサーバーへの1つ以上のSTUNトランザクションがあります。 基本的な音声のみのIPv4 VoIP展開では、呼び出しごとに4つのトランザクションがあります（RTPに1つ、RTCPに1つ、呼び出し元と呼び出し先の両方に）。 各トランザクションは単一の要求と単一の応答であり、前者は20バイト、後者は28バイトです。"
    },
    {
      "indent": 3,
      "text": "Consequently, if a system has N users, and each makes four calls in a busy hour, this would require N*1.7bps. For one million users, this is 1.7 Mbps, a very small number (relatively speaking).",
      "ja": "したがって、システムにN人のユーザーがいて、各ユーザーが混雑時に4つの呼び出しを行う場合、N * 1.7bpsが必要になります。 100万人のユーザーの場合、これは1.7 Mbpsであり、非常に少ない数です（相対的に言えば）。"
    },
    {
      "indent": 3,
      "text": "TURN traffic is more substantial. The TURN server will see traffic volume equal to the STUN volume (indeed, if TURN servers are deployed, there is no need for a separate STUN server), in addition to the traffic for the actual data. The amount of calls requiring TURN for data relay is highly dependent on network topologies, and can and will vary over time. In a network with 100% behave-compliant NATs, it is exactly zero.",
      "ja": "TURNトラフィックはより重要です。 TURNサーバーは、実際のデータのトラフィックに加えて、STUNボリュームに等しいトラフィックボリューム（実際、TURNサーバーがデプロイされている場合、別個のSTUNサーバーは必要ありません）を確認します。 データリレーにTURNを必要とするコールの量は、ネットワークトポロジに大きく依存しており、時間とともに変化する可能性があります。 100％動作準拠のNATを使用するネットワークでは、正確にゼロです。"
    },
    {
      "indent": 3,
      "text": "The planning considerations above become more significant in multimedia scenarios (e.g., audio and video conferences) and when the numbers of participants in a session grow.",
      "ja": "上記の計画上の考慮事項は、マルチメディアシナリオ（音声会議やビデオ会議など）およびセッションの参加者の数が増加する場合に重要になります。"
    },
    {
      "indent": 0,
      "text": "17.2.2. Gathering and Connectivity Checks",
      "section_title": true,
      "ja": "17.2.2.  収集と接続性のチェック"
    },
    {
      "indent": 3,
      "text": "The process of gathering candidates and performing connectivity checks can be bandwidth intensive. ICE has been designed to pace both of these processes. The gathering and connectivity-check phases are meant to generate traffic at roughly the same bandwidth as the data traffic itself will consume once the ICE process concludes. This was done to ensure that if a network is designed to support communication traffic of a certain type (voice, video, or just text), it will have sufficient capacity to support the ICE checks for that data. Once ICE has concluded, the subsequent ICE keepalives will later cause a marginal increase in the total bandwidth utilization; however, this will typically be an extremely small increase.",
      "ja": "候補を収集して接続チェックを実行するプロセスは、帯域幅を集中的に使用する場合があります。 ICEは、これらのプロセスの両方に対応するように設計されています。 収集と接続チェックのフェーズは、ICEプロセスが終了するとデータトラフィック自体が消費する帯域幅とほぼ同じ帯域幅でトラフィックを生成することを目的としています。 これは、ネットワークが特定のタイプ（音声、ビデオ、またはテキストのみ）の通信トラフィックをサポートするように設計されている場合、そのデータのICEチェックをサポートするのに十分な容量を確保するために行われました。 ICEが終了すると、後続のICEキープアライブにより、合計帯域幅使用率がわずかに増加します。 ただし、これは通常、ごくわずかな増加にすぎません。"
    },
    {
      "indent": 3,
      "text": "Congestion due to the gathering and check phases has proven to be a problem in deployments that did not utilize pacing. Typically, access links became congested as the endpoints flooded the network with checks as fast as they could send them. Consequently, network operators need to ensure that their ICE implementations support the pacing feature. Though this pacing does increase call setup times, it makes ICE network friendly and easier to deploy.",
      "ja": "収集およびチェックフェーズによる輻輳は、ペーシングを使用しなかった展開で問題になることが判明しています。 通常、アクセスリンクは、エンドポイントが送信できる限り高速のチェックでネットワークをあふれさせるため、混雑しました。 したがって、ネットワークオペレータは、ICE実装がペーシング機能をサポートしていることを確認する必要があります。 このペーシングによりコールのセットアップ時間が長くなりますが、ICEネットワークが使いやすくなり、展開が容易になります。"
    },
    {
      "indent": 0,
      "text": "17.2.3. Keepalives",
      "section_title": true,
      "ja": "17.2.3.  キープアライブ"
    },
    {
      "indent": 3,
      "text": "STUN keepalives (in the form of STUN Binding Indications) are sent in the middle of a data session. However, they are sent only in the absence of actual data traffic. In deployments with continuous media and without utilizing Voice Activity Detection (VAD), or deployments where VAD is utilized together with short interval (max 1 second) comfort noise, the keepalives are never used and there is no increase in bandwidth usage. When VAD is being used without comfort noise, keepalives will be sent during silence periods. This involves a single packet every 15-20 seconds, far less than the packet every 20-30 ms that is sent when there is voice. Therefore, keepalives do not have any real impact on capacity planning.",
      "ja": "STUNキープアライブ（STUNバインディングインジケーションの形式）は、データセッションの途中で送信されます。 ただし、実際のデータトラフィックがない場合にのみ送信されます。 連続メディアを使用し、Voice Activity Detection（VAD）を使用しない展開、またはVADが短い間隔（最大1秒）のコンフォートノイズとともに使用される展開では、キープアライブは使用されず、帯域幅の使用量は増加しません。 VADがコンフォートノイズなしで使用されている場合、無音期間中にキープアライブが送信されます。 これには、音声があるときに送信される20〜30ミリ秒ごとのパケットに比べて、15〜20秒ごとに1つのパケットが含まれます。 したがって、キープアライブはキャパシティプランニングに実際の影響を与えません。"
    },
    {
      "indent": 0,
      "text": "17.3. ICE and ICE-Lite",
      "section_title": true,
      "ja": "17.3.  ICEおよびICE-Lite"
    },
    {
      "indent": 3,
      "text": "Deployments utilizing a mix of ICE and ICE-lite interoperate with each other. They have been explicitly designed to do so.",
      "ja": "ICEとICE-liteを組み合わせて使用する展開は、相互運用できます。 それらはそうするように明示的に設計されています。"
    },
    {
      "indent": 3,
      "text": "However, ICE-lite can only be deployed in limited use cases. Those cases, and the caveats involved in doing so, are documented in Appendix A.",
      "ja": "ただし、ICE-liteは限られたユースケースでのみ展開できます。 これらのケース、およびそれに伴う注意事項は、付録Aに記載されています。"
    },
    {
      "indent": 0,
      "text": "17.4. Troubleshooting and Performance Management",
      "section_title": true,
      "ja": "17.4.  トラブルシューティングとパフォーマンス管理"
    },
    {
      "indent": 3,
      "text": "ICE utilizes end-to-end connectivity checks and places much of the processing in the endpoints. This introduces a challenge to the network operator -- how can they troubleshoot ICE deployments? How can they know how ICE is performing?",
      "ja": "ICEはエンドツーエンドの接続性チェックを利用し、処理の多くをエンドポイントに配置します。 これは、ネットワークオペレーターに課題をもたらします-ICE展開のトラブルシューティング方法は？ ICEのパフォーマンスをどのように知ることができますか？"
    },
    {
      "indent": 3,
      "text": "ICE has built-in features to help deal with these problems. Signaling servers, typically deployed in data centers of the network operator, will see the contents of the candidate exchanges that convey the ICE parameters. These parameters include the type of each candidate (host, server reflexive, or relayed), along with their related addresses. Once ICE processing has completed, an updated candidate exchange takes place, signaling the selected address (and its type). This updated signaling is performed exactly for the purposes of educating network equipment (such as a diagnostic tool attached to a signaling) about the results of ICE processing.",
      "ja": "ICEには、これらの問題に対処するための組み込み機能があります。 通常、ネットワークオペレーターのデータセンターに展開されているシグナリングサーバーは、ICEパラメーターを伝達する候補交換の内容を確認します。 これらのパラメーターには、各候補のタイプ（ホスト、反射サーバー、またはリレー）が、関連アドレスとともに含まれます。 ICE処理が完了すると、更新された候補交換が行われ、選択したアドレス（およびそのタイプ）が通知されます。 この更新されたシグナリングは、ICE処理の結果についてネットワーク機器（シグナリングに接続された診断ツールなど）を教育する目的で正確に実行されます。"
    },
    {
      "indent": 3,
      "text": "As a consequence, through the logs generated by a signaling server, a network operator can observe what types of candidates are being used for each call and what addresses were selected by ICE. This is the primary information that helps evaluate how ICE is performing.",
      "ja": "その結果、シグナリングサーバーによって生成されたログを介して、ネットワークオペレーターは、各呼び出しで使用されている候補の種類と、ICEによって選択されたアドレスを確認できます。 これは、ICEのパフォーマンスの評価に役立つ主要な情報です。"
    },
    {
      "indent": 0,
      "text": "17.5. Endpoint Configuration",
      "section_title": true,
      "ja": "17.5.  エンドポイント構成"
    },
    {
      "indent": 3,
      "text": "ICE relies on several pieces of data being configured into the endpoints. This configuration data includes timers, credentials for TURN servers, and hostnames for STUN and TURN servers. ICE itself does not provide a mechanism for this configuration. Instead, it is assumed that this information is attached to whatever mechanism is used to configure all of the other parameters in the endpoint. For SIP phones, standard solutions such as the configuration framework [RFC6080] have been defined.",
      "ja": "ICEは、エンドポイントに構成されているいくつかのデータに依存しています。 この構成データには、タイマー、TURNサーバーの資格情報、STUNおよびTURNサーバーのホスト名が含まれます。 ICE自体は、この構成のメカニズムを提供しません。 代わりに、この情報は、エンドポイント内の他のすべてのパラメーターを構成するために使用されるメカニズムに添付されると想定されています。 SIP電話機の場合、構成フレームワーク[RFC6080]などの標準ソリューションが定義されています。"
    },
    {
      "indent": 0,
      "text": "18. IAB Considerations",
      "section_title": true,
      "ja": "18. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of \"Unilateral Self-Address Fixing\" (UNSAF), which is the general process by which an ICE agent attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism [RFC3424]. ICE is an example of a protocol that performs this type of function. Interestingly, the process for ICE is not unilateral, but bilateral, and the difference has a significant impact on the issues raised by the IAB. Indeed, ICE can be considered a Bilateral Self-Address Fixing (B-SAF) protocol, rather than an UNSAF protocol. Regardless, the IAB has mandated that any protocols developed for this purpose document a specific set of considerations. This section meets those requirements.",
      "ja": "IABは、「片側自己アドレス修正」（UNSAF）の問題を研究しました。これは、協調エージェントリフレクションメカニズムを介して、ICEエージェントがNATの反対側の別の領域でアドレスを決定しようとする一般的なプロセスです RFC3424]。 ICEは、このタイプの機能を実行するプロトコルの例です。 興味深いことに、ICEのプロセスは一方的ではなく、二国間であり、その違いはIABによって提起された問題に大きな影響を及ぼします。 実際、ICEはUNSAFプロトコルではなく、Bilateral Self-Address Fixing（B-SAF）プロトコルと見なすことができます。 とにかく、IABは、この目的のために開発されたプロトコルには、特定の考慮事項を文書化することを義務付けています。 このセクションはそれらの要件を満たしています。"
    },
    {
      "indent": 0,
      "text": "18.1. Problem Definition",
      "section_title": true,
      "ja": "18.1.  問題定義"
    },
    {
      "indent": 3,
      "text": "From RFC 3424, any UNSAF proposal needs to provide:",
      "ja": "RFC 3424から、UNSAFの提案は以下を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short term fix should not be generalized to solve other problems. Such generalizations lead to the the prolonged dependence on and usage of the supposed short term fix -- meaning that it is no longer accurate to call it \"short term\".",
      "ja": "UNSAF提案で解決される特定の限定された範囲の問題の正確な定義。 他の問題を解決するために短期的な修正を一般化すべきではありません。 このような一般化により、想定される短期修正への依存と使用が長くなります。つまり、「短期」と呼ぶのはもはや正確ではありません。"
    },
    {
      "indent": 3,
      "text": "The specific problems being solved by ICE are:",
      "ja": "ICEによって解決されている特定の問題は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Providing a means for two peers to determine the set of transport addresses that can be used for communication.",
      "ja": "2つのピアが通信に使用できるトランスポートアドレスのセットを決定する手段を提供します。"
    },
    {
      "indent": 6,
      "text": "Providing a means for an agent to determine an address that is reachable by another peer with which it wishes to communicate.",
      "ja": "エージェントが通信したい別のピアから到達可能なアドレスを決定する手段を提供します。"
    },
    {
      "indent": 0,
      "text": "18.2. Exit Strategy",
      "section_title": true,
      "ja": "18.2.  出口戦略"
    },
    {
      "indent": 3,
      "text": "From RFC 3424, any UNSAF proposal needs to provide:",
      "ja": "RFC 3424から、UNSAFの提案は以下を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Description of an exit strategy/transition plan. The better short term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.",
      "ja": "出口戦略/移行計画の説明。 より良い短期的な修正は、適切なテクノロジーが展開されるにつれて、当然ながら使用が少なくなる修正です。"
    },
    {
      "indent": 3,
      "text": "ICE itself doesn't easily get phased out. However, it is useful even in a globally connected Internet, to serve as a means for detecting whether a router failure has temporarily disrupted connectivity, for example. ICE also helps prevent certain security attacks that have nothing to do with NAT. However, what ICE does is help phase out other UNSAF mechanisms. ICE effectively picks amongst those mechanisms, prioritizing ones that are better and deprioritizing ones that are worse. As NATs begin to dissipate as IPv6 is introduced, server-reflexive and relayed candidates (both forms of UNSAF addresses) simply never get used, because higher-priority connectivity exists to the native host candidates. Therefore, the servers get used less and less and can eventually be removed when their usage goes to zero.",
      "ja": "ICE自体は簡単に段階的に廃止されません。 ただし、たとえばルーターの障害によって接続が一時的に中断されたかどうかを検出する手段として機能することは、グローバルに接続されたインターネットでも有用です。 ICEは、NATとは関係のない特定のセキュリティ攻撃の防止にも役立ちます。 ただし、ICEが行うことは、他のUNSAFメカニズムを段階的に廃止することです。 ICEは、これらのメカニズムの中から効果的に選択し、より良いメカニズムを優先し、より悪いメカニズムを優先します。 IPv6が導入されるとNATが消失し始めるため、ネイティブホスト候補への優先度の高い接続が存在するため、サーバー反射型およびリレー候補（UNSAFアドレスの両方の形式）が使用されることはありません。 したがって、サーバーの使用量はますます少なくなり、使用量がゼロになったときに最終的に削除できます。"
    },
    {
      "indent": 3,
      "text": "Indeed, ICE can assist in the transition from IPv4 to IPv6. It can be used to determine whether to use IPv6 or IPv4 when two dual-stack hosts communicate with SIP (IPv6 gets used). It can also allow a network with both 6to4 and native v6 connectivity to determine which address to use when communicating with a peer.",
      "ja": "実際、ICEはIPv4からIPv6への移行を支援できます。 2つのデュアルスタックホストがSIPと通信するときにIPv6とIPv4のどちらを使用するかを決定するために使用できます（IPv6が使用されます）。 また、6to4接続とネイティブv6接続の両方を備えたネットワークで、ピアと通信するときに使用するアドレスを決定できます。"
    },
    {
      "indent": 0,
      "text": "18.3. Brittleness Introduced by ICE",
      "section_title": true,
      "ja": "18.3.  ICEによって導入された脆性"
    },
    {
      "indent": 3,
      "text": "From RFC 3424, any UNSAF proposal needs to provide:",
      "ja": "RFC 3424から、UNSAFの提案は以下を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of specific issues that may render systems more \"brittle\". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.",
      "ja": "システムをより「もろくする」特定の問題の議論。 たとえば、複数のネットワーク層でデータを使用するアプローチでは、依存関係が増え、デバッグの課題が増え、移行が難しくなります。"
    },
    {
      "indent": 3,
      "text": "ICE actually removes brittleness from existing UNSAF mechanisms. In particular, classic STUN (as described in RFC 3489 [RFC3489]) has several points of brittleness. One of them is the discovery process that requires an ICE agent to try to classify the type of NAT it is behind. This process is error prone. With ICE, that discovery process is simply not used. Rather than unilaterally assessing the validity of the address, its validity is dynamically determined by measuring connectivity to a peer. The process of determining connectivity is very robust.",
      "ja": "ICEは、既存のUNSAFメカニズムから脆弱性を実際に取り除きます。 特に、従来のSTUN（RFC 3489 [RFC3489]で説明されている）には、いくつかの脆弱点があります。 それらの1つは、ICEエージェントが背後にあるNATのタイプを分類しようとすることを必要とするディスカバリプロセスです。 このプロセスはエラーを起こしやすいです。 ICEでは、その検出プロセスは単純に使用されません。 アドレスの有効性を一方的に評価するのではなく、その有効性はピアへの接続性を測定することにより動的に決定されます。 接続性を判断するプロセスは非常に堅牢です。"
    },
    {
      "indent": 3,
      "text": "Another point of brittleness in classic STUN and any other unilateral mechanism is its absolute reliance on an additional server. ICE makes use of a server for allocating unilateral addresses, but it allows agents to directly connect if possible. Therefore, in some cases, the failure of a STUN server would still allow for a call to progress when ICE is used.",
      "ja": "古典的なSTUNおよびその他の片側メカニズムの脆弱性のもう1つのポイントは、追加サーバーへの絶対的な依存です。 ICEは、一方的なアドレスの割り当てにサーバーを使用しますが、可能であればエージェントが直接接続できるようにします。 したがって、場合によっては、ICEの使用時にSTUNサーバーの障害により呼び出しが進行する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Another point of brittleness in classic STUN is that it assumes the STUN server is on the public Internet. Interestingly, with ICE, that is not necessary. There can be a multitude of STUN servers in a variety of address realms. ICE will discover the one that has provided a usable address.",
      "ja": "クラシックSTUNの脆弱性のもう1つのポイントは、STUNサーバーがパブリックインターネット上にあると想定していることです。 興味深いことに、ICEでは、これは必要ありません。 さまざまなアドレスレルムに多数のSTUNサーバーが存在する場合があります。 ICEは、使用可能なアドレスを提供したものを検出します。"
    },
    {
      "indent": 3,
      "text": "The most troubling point of brittleness in classic STUN is that it doesn't work in all network topologies. In cases where there is a shared NAT between each agent and the STUN server, traditional STUN may not work. With ICE, that restriction is removed.",
      "ja": "クラシックSTUNの脆弱性の最も厄介な点は、すべてのネットワークトポロジで機能しないことです。 各エージェントとSTUNサーバーの間に共有NATがある場合、従来のSTUNが機能しない場合があります。 ICEでは、その制限は削除されています。"
    },
    {
      "indent": 3,
      "text": "Classic STUN also introduces some security considerations. Fortunately, those security considerations are also mitigated by ICE.",
      "ja": "Classic STUNでは、セキュリティに関する考慮事項もいくつか導入されています。 幸いなことに、これらのセキュリティに関する考慮事項もICEによって緩和されます。"
    },
    {
      "indent": 3,
      "text": "Consequently, ICE serves to repair the brittleness introduced in classic STUN, and it does not introduce any additional brittleness into the system.",
      "ja": "その結果、ICEは従来のSTUNで導入された脆弱性を修復する役割を果たし、システムに追加の脆弱性を導入しません。"
    },
    {
      "indent": 3,
      "text": "The penalty of these improvements is that ICE increases session establishment times.",
      "ja": "これらの改善のペナルティは、ICEがセッション確立時間を増加させることです。"
    },
    {
      "indent": 0,
      "text": "18.4. Requirements for a Long-Term Solution",
      "section_title": true,
      "ja": "18.4.  長期的なソリューションの要件"
    },
    {
      "indent": 3,
      "text": "From RFC 3424, any UNSAF proposal needs to provide the following:",
      "ja": "RFC 3424から、UNSAFの提案はすべて以下を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Identify requirements for longer term, sound technical solutions; contribute to the process of finding the right longer term solution.",
      "ja": "長期にわたる健全な技術ソリューションの要件を特定します。 適切な長期ソリューションを見つけるプロセスに貢献する。"
    },
    {
      "indent": 3,
      "text": "Our conclusions from RFC 3489 remain unchanged. However, we feel ICE actually helps because we believe it can be part of the long-term solution.",
      "ja": "RFC 3489の結論は変わりません。 ただし、ICEは長期的なソリューションの一部になる可能性があるため、ICEが実際に役立つと感じています。"
    },
    {
      "indent": 0,
      "text": "18.5. Issues with Existing NAPT Boxes",
      "section_title": true,
      "ja": "18.5.  既存のNAPTボックスの問題"
    },
    {
      "indent": 3,
      "text": "From RFC 3424, any UNSAF proposal needs to provide:",
      "ja": "RFC 3424から、UNSAFの提案は以下を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion of the impact of the noted practical issues with existing, deployed NA[P]Ts and experience reports.",
      "ja": "既存の展開されたNA [P] Tと経験報告書に記載されている実際的な問題の影響についての議論。"
    },
    {
      "indent": 3,
      "text": "A number of NAT boxes are now being deployed into the market that try to provide \"generic\" ALG functionality. These generic ALGs hunt for IP addresses, in either text or binary form within a packet, and rewrite them if they match a binding. This interferes with classic STUN. However, the update to STUN [RFC5389] uses an encoding that hides these binary addresses from generic ALGs.",
      "ja": "「汎用」ALG機能を提供しようとする多くのNATボックスが現在市場に展開されています。 これらの汎用ALGは、パケット内のテキストまたはバイナリ形式のIPアドレスを探し、バインディングと一致する場合は書き換えます。 これは、従来のSTUNに干渉します。 ただし、STUN [RFC5389]への更新では、これらのバイナリアドレスを一般的なALGから隠すエンコードが使用されます。"
    },
    {
      "indent": 3,
      "text": "Existing NAPT boxes have non-deterministic and typically short expiration times for UDP-based bindings. This requires implementations to send periodic keepalives to maintain those bindings. ICE uses a default of 15 s, which is a very conservative estimate. Eventually, over time, as NAT boxes become compliant to behave [RFC4787], this minimum keepalive will become deterministic",
      "ja": "既存のNAPTボックスには、UDPベースのバインディングの非決定的で一般に短い有効期限があります。 これには、実装がそれらのバインディングを維持するために定期的なキープアライブを送信する必要があります。 ICEはデフォルトの15秒を使用しますが、これは非常に控えめな見積もりです。 最終的に、NATボックスが動作するように準拠するようになるにつれて[RFC4787]、この最小キープアライブは決定論的になります"
    },
    {
      "indent": 3,
      "text": "and well known, and the ICE timers can be adjusted. Having a way to discover and control the minimum keepalive interval would be far better still.",
      "ja": "よく知られています。ICEタイマーは調整できます。 最小キープアライブインターバルを検出および制御する方法があると、はるかに優れています。"
    },
    {
      "indent": 0,
      "text": "19. Security Considerations",
      "section_title": true,
      "ja": "19.セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "19.1. IP Address Privacy",
      "section_title": true,
      "ja": "19.1.  IPアドレスのプライバシー"
    },
    {
      "indent": 3,
      "text": "The process of probing for candidates reveals the source addresses of the client and its peer to any on-network listening attacker, and the process of exchanging candidates reveals the addresses to any attacker that is able to see the negotiation. Some addresses, such as the server-reflexive addresses gathered through the local interface of VPN users, may be sensitive information. If these potential attacks cannot be mitigated, ICE usages can define mechanisms for controlling which addresses are revealed to the negotiation and/or probing process. Individual implementations may also have implementation-specific rules for controlling which addresses are revealed. For example, [WebRTC-IP-HANDLING] provides additional information about the privacy aspects of revealing IP addresses via ICE for WebRTC applications. ICE implementations where such issues can arise are RECOMMENDED to provide a programmatic or user interface that provides control over which network interfaces are used to generate candidates.",
      "ja": "候補を調べるプロセスは、クライアントとそのピアのソースアドレスをネットワーク上のリスニング攻撃者に明らかにし、候補を交換するプロセスは、ネゴシエーションを見ることができる攻撃者にアドレスを明らかにします。 VPNユーザーのローカルインターフェイスを介して収集されたサーバー反射アドレスなどの一部のアドレスは、機密情報である可能性があります。これらの潜在的な攻撃を軽減できない場合、ICEの使用法により、どのアドレスをネゴシエーションや調査プロセスに公開するかを制御するメカニズムを定義できます。個々の実装には、公開するアドレスを制御するための実装固有のルールもあります。たとえば、[WebRTC-IP-HANDLING]は、WebRTCアプリケーション用にICEを介してIPアドレスを公開する際のプライバシーの側面に関する追加情報を提供します。このような問題が発生する可能性のあるICE実装は、候補を生成するために使用されるネットワークインターフェイスを制御するプログラムまたはユーザーインターフェイスを提供することを推奨します。"
    },
    {
      "indent": 3,
      "text": "Based on the types of candidates provided by the peer, and the results of the connectivity tests performed against those candidates, the peer might be able to determine characteristics of the local network, e.g., if different timings are apparent to the peer. Within the limit, the peer might be able to probe the local network.",
      "ja": "ピアによって提供された候補のタイプ、およびそれらの候補に対して実行された接続性テストの結果に基づいて、ピアは、たとえば異なるタイミングがピアに明らかな場合、ローカルネットワークの特性を決定できる場合があります。 制限内で、ピアはローカルネットワークをプローブできる可能性があります。"
    },
    {
      "indent": 3,
      "text": "There are several types of attacks possible in an ICE system. The subsections consider these attacks and their countermeasures.",
      "ja": "ICEシステムでは、いくつかのタイプの攻撃が可能です。 サブセクションでは、これらの攻撃とその対策について検討します。"
    },
    {
      "indent": 0,
      "text": "19.2. Attacks on Connectivity Checks",
      "section_title": true,
      "ja": "19.2.  接続性チェックへの攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to disrupt the STUN connectivity checks. Ultimately, all of these attacks fool an ICE agent into thinking something incorrect about the results of the connectivity checks. Depending on the type of attack, the attacker needs to have different capabilities. In some cases, the attacker needs to be on the path of the connectivity checks. In other cases, the attacker does not need to be on the path, as long as it is able to generate STUN connectivity checks. While attacks on connectivity checks are typically performed by network entities, if an attacker is able to control an endpoint, it might be able to trigger connectivity-check attacks. The possible false conclusions an attacker can try and cause are:",
      "ja": "攻撃者は、STUN接続チェックを妨害しようとする可能性があります。 最終的に、これらの攻撃はすべて、ICEエージェントをだまして、接続性チェックの結果について誤った考えをさせます。 攻撃の種類に応じて、攻撃者は異なる能力を持っている必要があります。 場合によっては、攻撃者は接続チェックのパス上にいる必要があります。 その他の場合、STUN接続チェックを生成できる限り、攻撃者はパス上にいる必要はありません。 通常、接続性チェックに対する攻撃はネットワークエンティティによって実行されますが、攻撃者がエンドポイントを制御できる場合、接続性チェック攻撃を引き起こす可能性があります。 攻撃者が試みる可能性のある誤った結論は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "False Invalid: An attacker can fool a pair of agents into thinking a candidate pair is invalid, when it isn't. This can be used to cause an agent to prefer a different candidate (such as one injected by the attacker) or to disrupt a call by forcing all candidates to fail.",
      "ja": "False無効：攻撃者は、エージェントのペアをだまして、候補のペアが無効であると思わせることができます。 これを使用して、エージェントに別の候補（攻撃者によって注入された候補など）を優先させたり、すべての候補を強制的に失敗させてコールを中断したりできます。"
    },
    {
      "indent": 3,
      "text": "False Valid: An attacker can fool a pair of agents into thinking a candidate pair is valid, when it isn't. This can cause an agent to proceed with a session but then not be able to receive any data.",
      "ja": "False Valid：攻撃者は、1対のエージェントがだまされて、候補ペアが有効でないと考えることができます。 これにより、エージェントはセッションを続行できますが、データを受信できなくなります。"
    },
    {
      "indent": 3,
      "text": "False Peer-Reflexive Candidate: An attacker can cause an agent to discover a new peer-reflexive candidate when it is not expected to. This can be used to redirect data streams to a DoS target or to the attacker, for eavesdropping or other purposes.",
      "ja": "False Peer-Reflexive Candidate：攻撃者は、予期しないときにエージェントに新しいピア反射候補を発見させることができます。 これは、盗聴またはその他の目的で、データストリームをDoSターゲットまたは攻撃者にリダイレクトするために使用できます。"
    },
    {
      "indent": 3,
      "text": "False Valid on False Candidate: An attacker has already convinced an agent that there is a candidate with an address that does not actually route to that agent (e.g., by injecting a false peer-reflexive candidate or false server-reflexive candidate). The attacker then launches an attack that forces the agents to believe that this candidate is valid.",
      "ja": "False CandidateのFalse Valid：攻撃者は、実際にそのエージェントにルーティングされないアドレスを持つ候補があることをエージェントにすでに確信させています（たとえば、偽のピア反射候補または偽のサーバー反射候補を注入することによって）。 次に、攻撃者は攻撃を開始し、この候補が有効であるとエージェントに信じ込ませます。"
    },
    {
      "indent": 6,
      "text": "If an attacker can cause a false peer-reflexive candidate or false valid on a false candidate, it can launch any of the attacks described in [RFC5389].",
      "ja": "攻撃者が、偽のピア反射候補または偽の候補に対して偽の有効を引き起こすことができる場合、[RFC5389]で説明されている攻撃のいずれかを起動できます。"
    },
    {
      "indent": 3,
      "text": "To force the false invalid result, the attacker has to wait for the connectivity check from one of the agents to be sent. When it is, the attacker needs to inject a fake response with an unrecoverable error response (such as a 400), or drop the response so that it never reaches the agent. However, since the candidate is, in fact, valid, the original request may reach the peer agent and result in a success response. The attacker needs to force this packet or its response to be dropped through a DoS attack, a Layer 2 network disruption, or another technique. If it doesn't do this, the success response will also reach the originator, alerting it to a possible attack. The ability for the attacker to generate a fake response is mitigated through the STUN short-term credential mechanism. In order for this response to be processed, the attacker needs the password. If the candidate exchange signaling is secured, the attacker will not have the password, and its response will be discarded.",
      "ja": "偽の無効な結果を強制するには、攻撃者は、エージェントの1つからの接続チェックが送信されるのを待つ必要があります。 その場合、攻撃者は回復不能なエラー応答（400など）を含む偽の応答を挿入するか、エージェントに到達しないように応答をドロップする必要があります。 ただし、候補は実際には有効であるため、元の要求がピアエージェントに到達し、成功応答が返される場合があります。 攻撃者は、DoS攻撃、レイヤー2ネットワークの中断、またはその他の手法により、このパケットまたはその応答を強制的にドロップする必要があります。 これを行わない場合、成功応答も発信者に届き、攻撃の可能性を警告します。 攻撃者が偽の応答を生成する能力は、STUN短期資格情報メカニズムによって軽減されます。 この応答を処理するには、攻撃者がパスワードを必要とします。 候補の交換シグナリングが保護されている場合、攻撃者はパスワードを持っていないため、その応答は破棄されます。"
    },
    {
      "indent": 3,
      "text": "Spoofed ICMP Hard Errors (Type 3, codes 2-4) can also be used to create false invalid results. If an ICE agent implements a response to these ICMP errors, the attacker is capable of generating an ICMP message that is delivered to the agent sending the connectivity check. The validation of the ICMP error message by the agent is its only defense. For Type 3 code=4, the outer IP header provides no validation, unless the connectivity check was sent with DF=0. For codes 2 or 3, which are originated by the host, the address is expected to be any of the remote agent's host, reflexive, or relay candidate IP addresses. The ICMP message includes the IP header and UDP header of the message triggering the error. These fields also need to be validated. The IP destination and UDP destination port need to match either the targeted candidate address and port or the candidate's base address. The source IP address and port can be any candidate for the same base address of the agent sending the connectivity check. Thus, any attacker having access to the exchange of the candidates will have the necessary information. Hence, the validation is a weak defense, and the sending of spoofed ICMP attacks is also possible for off-path attackers from a node in a network without source address validation.",
      "ja": "偽のICMPハードエラー（タイプ3、コード2〜4）を使用して、誤った無効な結果を作成することもできます。 ICEエージェントがこれらのICMPエラーへの応答を実装する場合、攻撃者は接続チェックを送信するエージェントに配信されるICMPメッセージを生成できます。エージェントによるICMPエラーメッセージの検証は、唯一の防御策です。タイプ3 code = 4の場合、DF = 0で接続チェックが送信されない限り、外部IPヘッダーは検証を提供しません。ホストによって発信されたコード2または3の場合、アドレスは、リモートエージェントのホスト、再帰、またはリレー候補IPアドレスのいずれかであると予想されます。 ICMPメッセージには、エラーをトリガーしたメッセージのIPヘッダーとUDPヘッダーが含まれます。これらのフィールドも検証する必要があります。 IP宛先およびUDP宛先ポートは、ターゲットの候補アドレスとポート、または候補のベースアドレスのいずれかと一致する必要があります。送信元IPアドレスとポートは、接続チェックを送信するエージェントの同じベースアドレスの任意の候補にすることができます。したがって、候補者の交換にアクセスできる攻撃者は、必要な情報を入手できます。したがって、検証は弱い防御であり、送信元アドレスの検証なしで、ネットワーク内のノードからのオフパス攻撃者に対して、なりすましICMP攻撃を送信することも可能です。"
    },
    {
      "indent": 3,
      "text": "Forcing the fake valid result works in a similar way. The attacker needs to wait for the Binding request from each agent and inject a fake success response. Again, due to the STUN short-term credential mechanism, in order for the attacker to inject a valid success response, the attacker needs the password. Alternatively, the attacker can route (e.g., using a tunneling mechanism) a valid success response, which normally would be dropped or rejected by the network, to the agent.",
      "ja": "偽の有効な結果を強制することも同様の方法で機能します。 攻撃者は、各エージェントからのバインディングリクエストを待機し、偽の成功応答を挿入する必要があります。 繰り返しますが、STUN短期資格情報メカニズムにより、攻撃者が有効な成功応答を挿入するためには、攻撃者はパスワードが必要です。 あるいは、攻撃者は有効な成功応答を（たとえば、トンネリングメカニズムを使用して）ルーティングすることができます。これは通常、ネットワークによってドロップまたは拒否されますが、エージェントに送信されます。"
    },
    {
      "indent": 3,
      "text": "Forcing the false peer-reflexive candidate result can be done with either fake requests or responses, or with replays. We consider the fake requests and responses case first. It requires the attacker to send a Binding request to one agent with a source IP address and port for the false candidate. In addition, the attacker needs to wait for a Binding request from the other agent and generate a fake response with a XOR-MAPPED-ADDRESS attribute containing the false candidate. Like the other attacks described here, this attack is mitigated by the STUN message integrity mechanisms and secure candidate exchanges.",
      "ja": "偽のピア反射候補の結果を強制することは、偽の要求または応答、またはリプレイで実行できます。 まず、偽のリクエストとレスポンスのケースを検討します。 攻撃者は、偽の候補のソースIPアドレスとポートを使用して、1つのエージェントにバインド要求を送信する必要があります。 さらに、攻撃者は他のエージェントからのバインディングリクエストを待機し、偽の候補を含むXOR-MAPPED-ADDRESS属性を持つ偽の応答を生成する必要があります。 ここで説明する他の攻撃と同様に、この攻撃は、STUNメッセージ整合性メカニズムと安全な候補交換によって緩和されます。"
    },
    {
      "indent": 3,
      "text": "Forcing the false peer-reflexive candidate result with packet replays is different. The attacker waits until one of the agents sends a check. It intercepts this request and replays it towards the other agent with a faked source IP address. It also needs to prevent the original request from reaching the remote agent, by either launching a DoS attack to cause the packet to be dropped or forcing it to be dropped using Layer 2 mechanisms. The replayed packet is received at the other agent, and accepted, since the integrity check passes (the integrity check cannot and does not cover the source IP address and port). It is then responded to. This response will contain a XOR-MAPPED-ADDRESS with the false candidate, and it will be sent to that false candidate. The attacker then needs to receive it and relay it towards the originator.",
      "ja": "パケットリプレイで誤ったピア反射候補結果を強制することは異なります。 攻撃者は、エージェントの1人がチェックを送信するまで待機します。 このリクエストをインターセプトし、偽のソースIPアドレスを持つ他のエージェントに向けてリプレイします。 また、DoS攻撃を開始してパケットをドロップするか、レイヤー2メカニズムを使用して強制的にドロップすることにより、元の要求がリモートエージェントに到達しないようにする必要があります。 リプレイされたパケットは、整合性チェックに合格するため、他のエージェントで受信され、受け入れられます（整合性チェックはソースIPアドレスとポートをカバーできず、カバーしません）。 その後、応答されます。 この応答には、偽の候補を持つXOR-MAPPED-ADDRESSが含まれ、その偽の候補に送信されます。 攻撃者はそれを受信し、発信者に向けて中継する必要があります。"
    },
    {
      "indent": 3,
      "text": "The other agent will then initiate a connectivity check towards that false candidate. This validation needs to succeed. This requires the attacker to force a false valid on a false candidate. The injecting of fake requests or responses to achieve this goal is prevented using the integrity mechanisms of STUN and the candidate exchange. Thus, this attack can only be launched through replays. To do that, the attacker needs to intercept the check towards this false candidate and replay it towards the other agent. Then, it needs to intercept the response and replay that back as well.",
      "ja": "次に、他のエージェントは、その誤った候補に対する接続チェックを開始します。 この検証は成功する必要があります。 このため、攻撃者は偽の候補に対して偽の有効を強制する必要があります。 この目標を達成するための偽の要求または応答の注入は、STUNおよび候補者の交換の整合性メカニズムを使用して防止されます。 したがって、この攻撃はリプレイによってのみ開始できます。 そのためには、攻撃者はこの偽の候補に対するチェックをインターセプトし、他のエージェントに対してリプレイする必要があります。 次に、応答をインターセプトし、同様に再生する必要があります。"
    },
    {
      "indent": 3,
      "text": "This attack is very hard to launch unless the attacker is identified by the fake candidate. This is because it requires the attacker to intercept and replay packets sent by two different hosts. If both agents are on different networks (e.g., across the public Internet), this attack can be hard to coordinate, since it needs to occur against two different endpoints on different parts of the network at the same time.",
      "ja": "この攻撃は、攻撃者が偽の候補者によって識別されない限り、開始するのが非常に困難です。 これは、攻撃者が2つの異なるホストから送信されたパケットを傍受して再生する必要があるためです。 両方のエージェントが異なるネットワーク上にある場合（たとえば、パブリックインターネットを介して）、この攻撃はネットワークの異なる部分にある2つの異なるエンドポイントに対して同時に発生する必要があるため、調整が難しい場合があります。"
    },
    {
      "indent": 3,
      "text": "If the attacker itself is identified by the fake candidate, the attack is easier to coordinate. However, if the data path is secured (e.g., using the Secure Real-time Transport Protocol (SRTP) [RFC3711]), the attacker will not be able to process the data packets, but will only be able to discard them, effectively disabling the data stream. However, this attack requires the agent to disrupt packets in order to block the connectivity check from reaching the target. In that case, if the goal is to disrupt the data stream, it's much easier to just disrupt it with the same mechanism, rather than attack ICE.",
      "ja": "攻撃者自身が偽の候補者によって識別された場合、攻撃の調整が容易になります。 ただし、データパスがセキュリティで保護されている場合（たとえば、セキュアリアルタイムトランスポートプロトコル（SRTP）[RFC3711]を使用）、攻撃者はデータパケットを処理できず、データパケットを破棄することしかできず、事実上無効になります。 データストリーム。 ただし、この攻撃では、接続チェックがターゲットに到達するのをブロックするために、エージェントがパケットを中断する必要があります。 その場合、目標がデータストリームを中断することである場合、ICEを攻撃するのではなく、同じメカニズムで中断する方がはるかに簡単です。"
    },
    {
      "indent": 0,
      "text": "19.3. Attacks on Server-Reflexive Address Gathering",
      "section_title": true,
      "ja": "19.3.  サーバー再帰アドレス収集への攻撃"
    },
    {
      "indent": 3,
      "text": "ICE endpoints make use of STUN Binding requests for gathering server-reflexive candidates from a STUN server. These requests are not authenticated in any way. As a consequence, there are numerous techniques an attacker can employ to provide the client with a false server-reflexive candidate:",
      "ja": "ICEエンドポイントは、STUNバインディング要求を利用して、STUNサーバーからサーバー反射候補を収集します。 これらのリクエストは、いかなる方法でも認証されません。 結果として、攻撃者がクライアントに誤ったサーバー反射候補を提供するために使用できる多くの手法があります。"
    },
    {
      "indent": 3,
      "text": "o An attacker can compromise the DNS, causing DNS queries to return a rogue STUN server address. That server can provide the client with fake server-reflexive candidates. This attack is mitigated by DNS security, though DNSSEC is not required to address it.",
      "ja": "o攻撃者はDNSを危険にさらし、DNSクエリが不正なSTUNサーバーアドレスを返す可能性があります。 そのサーバーは、クライアントに偽のサーバー反射候補を提供できます。 DNSSECはこの攻撃に対処する必要はありませんが、この攻撃はDNSセキュリティによって緩和されます。"
    },
    {
      "indent": 3,
      "text": "o An attacker that can observe STUN messages (such as an attacker on a shared network segment, like Wi-Fi) can inject a fake response that is valid and will be accepted by the client.",
      "ja": "o STUNメッセージを観察できる攻撃者（Wi-Fiなどの共有ネットワークセグメントの攻撃者など）は、有効でクライアントに受け入れられる偽の応答を挿入できます。"
    },
    {
      "indent": 3,
      "text": "o An attacker can compromise a STUN server and cause it to send responses with incorrect mapped addresses.",
      "ja": "o攻撃者は、STUNサーバーを危険にさらし、マップされたアドレスが正しくない応答を送信させる可能性があります。"
    },
    {
      "indent": 3,
      "text": "A false mapped address learned by these attacks will be used as a server-reflexive candidate in the establishment of the ICE session. For this candidate to actually be used for data, the attacker also needs to attack the connectivity checks, and in particular, force a false valid on a false candidate. This attack is very hard to launch if the false address identifies a fourth party (neither the initiator, responder, nor attacker), since it requires attacking the checks generated by each ICE agent in the session and is prevented by SRTP if it identifies the attacker itself.",
      "ja": "これらの攻撃によって学習された誤ってマッピングされたアドレスは、ICEセッションの確立においてサーバー反射型の候補として使用されます。 この候補が実際にデータに使用されるためには、攻撃者は接続チェックを攻撃する必要もあり、特に、偽の候補に対して偽の有効を強制する必要があります。 この攻撃は、セッション内の各ICEエージェントによって生成されたチェックを攻撃する必要があり、攻撃者を識別する場合にSRTPによって阻止されるため、偽のアドレスが第4パーティ（イニシエーター、レスポンダー、攻撃者のいずれでもない）を識別する場合、起動が非常に困難です 自体。"
    },
    {
      "indent": 3,
      "text": "If the attacker elects not to attack the connectivity checks, the worst it can do is prevent the server-reflexive candidate from being used. However, if the peer agent has at least one candidate that is reachable by the agent under attack, the STUN connectivity checks themselves will provide a peer-reflexive candidate that can be used for the exchange of data. Peer-reflexive candidates are generally preferred over server-reflexive candidates. As such, an attack solely on the STUN address gathering will normally have no impact on a session at all.",
      "ja": "攻撃者が接続性チェックを攻撃しないことを選択した場合、最悪の事態はサーバー反射候補が使用されないようにすることです。 ただし、攻撃を受けているエージェントが到達可能な候補が少なくとも1つピアエージェントにある場合、STUN接続性チェック自体が、データ交換に使用できるピア反射候補を提供します。 ピア反射候補者は、一般的にサーバー反射候補者よりも好まれます。 そのため、STUNアドレス収集のみに対する攻撃は通常、セッションにまったく影響を与えません。"
    },
    {
      "indent": 0,
      "text": "19.4. Attacks on Relayed Candidate Gathering",
      "section_title": true,
      "ja": "19.4.  リレーされた候補者の収集に対する攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to disrupt the gathering of relayed candidates, forcing the client to believe it has a false relayed candidate. Exchanges with the TURN server are authenticated using a long-term credential. Consequently, injection of fake responses or requests will not work. In addition, unlike Binding requests, Allocate requests are not susceptible to replay attacks with modified source IP addresses and ports, since the source IP address and port are not utilized to provide the client with its relayed candidate.",
      "ja": "攻撃者は、リレーされた候補者の収集を妨害し、クライアントに偽のリレーされた候補者がいると信じ込ませようとする可能性があります。 TURNサーバーとの交換は、長期資格情報を使用して認証されます。 その結果、偽の応答または要求の注入は機能しません。 さらに、バインディング要求とは異なり、割り当て要求は、ソースIPアドレスとポートがリレーされた候補をクライアントに提供するために使用されないため、変更されたソースIPアドレスとポートを使用したリプレイ攻撃の影響を受けません。"
    },
    {
      "indent": 3,
      "text": "Even if an attacker has caused the client to believe in a false relayed candidate, the connectivity checks cause such a candidate to be used only if they succeed. Thus, an attacker needs to launch a false valid on a false candidate, per above, which is a very difficult attack to coordinate.",
      "ja": "攻撃者がクライアントに誤った中継候補を信じさせたとしても、接続性チェックにより、成功した場合にのみそのような候補が使用されます。 したがって、攻撃者は上記のように偽の候補に対して偽の有効を起動する必要があり、これは調整が非常に難しい攻撃です。"
    },
    {
      "indent": 0,
      "text": "19.5. Insider Attacks",
      "section_title": true,
      "ja": "19.5.  インサイダー攻撃"
    },
    {
      "indent": 3,
      "text": "In addition to attacks where the attacker is a third party trying to insert fake candidate information or STUN messages, there are attacks possible with ICE when the attacker is an authenticated and valid participant in the ICE exchange.",
      "ja": "攻撃者が偽の候補情報またはSTUNメッセージを挿入しようとする第三者である攻撃に加えて、攻撃者がICE交換の認証された有効な参加者である場合、ICEで攻撃が可能です。"
    },
    {
      "indent": 0,
      "text": "19.5.1. STUN Amplification Attack",
      "section_title": true,
      "ja": "19.5.1.  スタン増幅攻撃"
    },
    {
      "indent": 3,
      "text": "The STUN amplification attack is similar to a \"voice hammer\" attack, where the attacker causes other agents to direct voice packets to the attack target. However, instead of voice packets being directed to the target, STUN connectivity checks are directed to the target. The attacker sends a large number of candidates, say, 50. The responding agent receives the candidate information and starts its checks, which are directed at the target, and consequently, never generate a response. In the case of WebRTC, the user might not even be aware that this attack is ongoing, since it might be triggered in the background by malicious JavaScript code that the user has fetched. The answerer will start a new connectivity check every Ta ms (say, Ta=50ms). However, the retransmission timers are set to a large number due to the large number of candidates. As a consequence, packets will be sent at an interval of one every Ta milliseconds and then with increasing intervals after that. Thus, STUN will not send packets at a rate faster than data would be sent, and the STUN packets persist only briefly, until ICE fails for the session. Nonetheless, this is an amplification mechanism.",
      "ja": "STUN増幅攻撃は、攻撃者が他のエージェントに音声パケットを攻撃対象に向けさせる「ボイスハンマー」攻撃に似ています。ただし、音声パケットがターゲットに送信されるのではなく、STUN接続チェックがターゲットに送信されます。攻撃者は多数の候補、たとえば50を送信します。応答エージェントは候補情報を受信し、ターゲットに向けられたチェックを開始します。その結果、応答を生成しません。 WebRTCの場合、ユーザーが取得した悪意のあるJavaScriptコードによってバックグラウンドでトリガーされる可能性があるため、ユーザーはこの攻撃が進行中であることを認識していません。回答者は、Ta ms（たとえば、Ta = 50ms）ごとに新しい接続チェックを開始します。ただし、多数の候補があるため、再送信タイマーは多数に設定されます。結果として、パケットはTaミリ秒ごとに1回の間隔で送信され、その後は間隔が長くなります。したがって、STUNは、データが送信されるよりも速い速度でパケットを送信せず、セッションでICEが失敗するまで、STUNパケットは短時間しか持続しません。それにもかかわらず、これは増幅メカニズムです。"
    },
    {
      "indent": 3,
      "text": "It is impossible to eliminate the amplification, but the volume can be reduced through a variety of heuristics. ICE agents SHOULD limit the total number of connectivity checks they perform to 100. Additionally, agents MAY limit the number of candidates they will accept.",
      "ja": "増幅を排除することは不可能ですが、さまざまなヒューリスティックによってボリュームを減らすことができます。 ICEエージェントは、実行する接続チェックの合計数を100に制限する必要があります。さらに、エージェントは、受け入れる候補の数を制限することができます。"
    },
    {
      "indent": 3,
      "text": "Frequently, protocols that wish to avoid these kinds of attacks force the initiator to wait for a response prior to sending the next message. However, in the case of ICE, this is not possible. It is not possible to differentiate the following two cases:",
      "ja": "多くの場合、これらの種類の攻撃を回避したいプロトコルは、次のメッセージを送信する前に、イニシエーターに応答を待たせます。 ただし、ICEの場合、これは不可能です。 次の2つのケースを区別することはできません。"
    },
    {
      "indent": 3,
      "text": "o There was no response because the initiator is being used to launch a DoS attack against an unsuspecting target that will not respond.",
      "ja": "oイニシエーターは、応答しない疑いのないターゲットに対してDoS攻撃を開始するために使用されているため、応答はありませんでした。"
    },
    {
      "indent": 3,
      "text": "o There was no response because the IP address and port are not reachable by the initiator.",
      "ja": "oイニシエーターがIPアドレスとポートに到達できないため、応答がありませんでした。"
    },
    {
      "indent": 3,
      "text": "In the second case, another check will be sent at the next opportunity, while in the former case, no further checks will be sent.",
      "ja": "2番目の場合、次の機会に別のチェックが送信されますが、前者の場合、それ以上のチェックは送信されません。"
    },
    {
      "indent": 0,
      "text": "20. IANA Considerations",
      "section_title": true,
      "ja": "20. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The original ICE specification registered four STUN attributes and one new STUN error response. The STUN attributes and error response are reproduced here. In addition, this specification registers a new ICE option.",
      "ja": "元のICE仕様では、4つのSTUN属性と1つの新しいSTUNエラー応答が登録されていました。 STUN属性とエラー応答がここに再現されています。 さらに、この仕様は新しいICEオプションを登録します。"
    },
    {
      "indent": 0,
      "text": "20.1. STUN Attributes",
      "section_title": true,
      "ja": "20.1.  STUN属性"
    },
    {
      "indent": 3,
      "text": "IANA has registered four STUN attributes:",
      "ja": "IANAは4つのSTUN属性を登録しました："
    },
    {
      "indent": 6,
      "text": "0x0024 PRIORITY 0x0025 USE-CANDIDATE 0x8029 ICE-CONTROLLED 0x802A ICE-CONTROLLING",
      "ja": "0x0024優先順位0x0025使用候補0x8029氷制御0x802A氷制御"
    },
    {
      "indent": 0,
      "text": "20.2. STUN Error Responses",
      "section_title": true,
      "ja": "20.2.  STUNエラー応答"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following STUN error-response code:",
      "ja": "IANAは、次のSTUNエラー応答コードを登録しました。"
    },
    {
      "indent": 4,
      "text": "487 Role Conflict: The client asserted an ICE role (controlling or controlled) that is in conflict with the role of the server.",
      "ja": "487ロールの競合：クライアントが、サーバーのロールと競合するICEロール（制御または制御）をアサートしました。"
    },
    {
      "indent": 0,
      "text": "20.3. ICE Options",
      "section_title": true,
      "ja": "20.3.  ICEオプション"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following ICE option in the \"ICE Options\" subregistry of the \"Interactive Connectivity Establishment (ICE)\" registry, following the procedures defined in [RFC6336].",
      "ja": "IANAは、[RFC6336]で定義されている手順に従って、「Interactive Connectivity Establishment（ICE）」レジストリの「ICE Options」サブレジストリに次のICEオプションを登録しました。"
    },
    {
      "indent": 3,
      "text": "ICE Option name: ice2",
      "ja": "ICEオプション名：ice2"
    },
    {
      "indent": 3,
      "text": "Contact: Name: IESG Email: iesg@ietf.org",
      "ja": "連絡先：名前：IESGメール：iesg@ietf.org"
    },
    {
      "indent": 3,
      "text": "Change Controller: IESG",
      "ja": "コントローラーの変更：IESG"
    },
    {
      "indent": 3,
      "text": "Description: The ICE option indicates that the ICE agent using the ICE option is implemented according to RFC 8445.",
      "ja": "説明：ICEオプションは、ICEオプションを使用するICEエージェントがRFC 8445に従って実装されていることを示します。"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 8445",
      "ja": "参照：RFC 8445"
    },
    {
      "indent": 1,
      "text": "21. Changes from",
      "section_title": true,
      "ja": "21.変更点"
    },
    {
      "indent": 3,
      "text": "The purpose of this updated ICE specification is to:",
      "ja": "この更新されたICE仕様の目的は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Clarify procedures in RFC 5245.",
      "ja": "o RFC 5245の手順を明確にします。"
    },
    {
      "indent": 3,
      "text": "o Make technical changes, due to discovered flaws in RFC 5245 and feedback from the community that has implemented and deployed ICE applications based on RFC 5245.",
      "ja": "o RFC 5245で発見された欠陥と、RFC 5245に基づいてICEアプリケーションを実装および展開したコミュニティからのフィードバックにより、技術的な変更を行います。"
    },
    {
      "indent": 3,
      "text": "o Make the procedures independent of the signaling protocol, by removing the SIP and SDP procedures. Procedures specific to a signaling protocol will be defined in separate usage documents. [ICE-SIP-SDP] defines ICE usage with SIP and SDP.",
      "ja": "o SIPおよびSDP手順を削除することにより、手順をシグナリングプロトコルから独立させます。 シグナリングプロトコルに固有の手順は、個別の使用ドキュメントで定義されます。 [ICE-SIP-SDP]は、SIPおよびSDPでのICEの使用を定義します。"
    },
    {
      "indent": 3,
      "text": "The following technical changes have been done:",
      "ja": "次の技術的な変更が行われました。"
    },
    {
      "indent": 3,
      "text": "o Aggressive nomination removed.",
      "ja": "o積極的な指名は削除されました。"
    },
    {
      "indent": 3,
      "text": "o The procedures for calculating candidate pair states and scheduling connectivity checks modified.",
      "ja": "o候補ペアの状態を計算し、接続性チェックをスケジュールする手順が変更されました。"
    },
    {
      "indent": 3,
      "text": "o Procedures for calculation of Ta and RTO modified.",
      "ja": "o TaおよびRTOの計算手順が変更されました。"
    },
    {
      "indent": 3,
      "text": "o Active checklist and Frozen checklist definitions removed.",
      "ja": "oアクティブなチェックリストとフローズンチェックリストの定義が削除されました。"
    },
    {
      "indent": 3,
      "text": "o 'ice2' ICE option added.",
      "ja": "o「ice2」ICEオプションが追加されました。"
    },
    {
      "indent": 3,
      "text": "o IPv6 considerations modified.",
      "ja": "o IPv6の考慮事項が変更されました。"
    },
    {
      "indent": 3,
      "text": "o Usage with no-op for keepalives, and keepalives with non-ICE peers, removed.",
      "ja": "oキープアライブのノーオペレーションでの使用、および非ICEピアのキープアライブは削除されました。"
    },
    {
      "indent": 0,
      "text": "22. References",
      "section_title": true,
      "ja": "22.参照"
    },
    {
      "indent": 0,
      "text": "22.1. Normative References",
      "section_title": true,
      "ja": "22.1.  規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4941] Narten, T., Draves, R., and S. Krishnan, \"Privacy Extensions for Stateless Address Autoconfiguration in IPv6\", RFC 4941, DOI 10.17487/RFC4941, September 2007, <https://www.rfc-editor.org/info/rfc4941>.",
      "ja": "[RFC4941] Narten、T.、Draves、R。、およびS. Krishnan、「IPv6のステートレスアドレス自動設定のプライバシー拡張」、RFC 4941、DOI 10.17487 / RFC4941、2007年9月、<https：//www.rfc-editor .org / info / rfc4941>。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, DOI 10.17487/RFC5389, October 2008, <https://www.rfc-editor.org/info/rfc5389>.",
      "ja": "[RFC5389]ローゼンバーグ、J。、マヒー、R。、マシューズ、P。、およびD.ウィング、「NAT（STUN）のセッショントラバースユーティリティ」、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、<https：// www.rfc-editor.org/info/rfc5389>。"
    },
    {
      "indent": 3,
      "text": "[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", RFC 5766, DOI 10.17487/RFC5766, April 2010, <https://www.rfc-editor.org/info/rfc5766>.",
      "ja": "[RFC5766] Mahy、R.、Matthews、P.、およびJ. Rosenberg、「NAT（TURN）でリレーを使用するトラバーサル：NAT（STUN）のセッショントラバーサルユーティリティへのリレー拡張」、RFC 5766、DOI 10.17487 / RFC5766、4月 2010、<https://www.rfc-editor.org/info/rfc5766>。"
    },
    {
      "indent": 3,
      "text": "[RFC6336] Westerlund, M. and C. Perkins, \"IANA Registry for Interactive Connectivity Establishment (ICE) Options\", RFC 6336, DOI 10.17487/RFC6336, July 2011, <https://www.rfc-editor.org/info/rfc6336>.",
      "ja": "[RFC6336] Westerlund、M。、およびC. Perkins、「インタラクティブ接続確立（ICE）オプションのためのIANAレジストリ」、RFC 6336、DOI 10.17487 / RFC6336、2011年7月、<https://www.rfc-editor.org/info / rfc6336>。"
    },
    {
      "indent": 3,
      "text": "[RFC6724] Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown, \"Default Address Selection for Internet Protocol Version 6 (IPv6)\", RFC 6724, DOI 10.17487/RFC6724, September 2012, <https://www.rfc-editor.org/info/rfc6724>.",
      "ja": "[RFC6724] Thaler、D.、Ed。、Draves、R.、Matsumoto、A。、およびT. Chown、「インターネットプロトコルバージョン6（IPv6）のデフォルトアドレス選択」、RFC 6724、DOI 10.17487 / RFC6724、2012年9月 、<https://www.rfc-editor.org/info/rfc6724>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "22.2. Informative References",
      "section_title": true,
      "ja": "22.2.  参考資料"
    },
    {
      "indent": 3,
      "text": "[ICE-SIP-SDP] Petit-Huguenin, M., Nandakumar, S., and A. Keranen, \"Session Description Protocol (SDP) Offer/Answer procedures for Interactive Connectivity Establishment (ICE)\", Work in Progress, draft-ietf-mmusic-ice-sip-sdp-21, June 2018.",
      "ja": "[ICE-SIP-SDP] Petit-Huguenin、M.、Nandakumar、S。、およびA. Keranen、「セッション記述プロトコル（SDP）インタラクティブ接続確立（ICE）のオファー/アンサー手順」、Work in Progress、ドラフト- ietf-mmusic-ice-sip-sdp-21、2018年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, <https://www.rfc-editor.org/info/rfc1918>.",
      "ja": "[RFC1918] Rekhter、Y.、Moskowitz、B.、Karrenberg、D.、de Groot、G。、およびE. Lear、「プライベートインターネットのアドレス割り当て」、BCP 5、RFC 1918、DOI 10.17487 / RFC1918、1996年2月 、<https://www.rfc-editor.org/info/rfc1918>。"
    },
    {
      "indent": 3,
      "text": "[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, \"An Architecture for Differentiated Services\", RFC 2475, DOI 10.17487/RFC2475, December 1998, <https://www.rfc-editor.org/info/rfc2475>.",
      "ja": "[RFC2475]ブレイク、S。、ブラック、D。、カールソン、M。、デイビス、E。、ワング、Z。、およびW.ヴァイス、「差別化されたサービスのためのアーキテクチャ」、RFC 2475、DOI 10.17487 / RFC2475、12月 1998、<https://www.rfc-editor.org/info/rfc2475>。"
    },
    {
      "indent": 3,
      "text": "[RFC3102] Borella, M., Lo, J., Grabelsky, D., and G. Montenegro, \"Realm Specific IP: Framework\", RFC 3102, DOI 10.17487/RFC3102, October 2001, <https://www.rfc-editor.org/info/rfc3102>.",
      "ja": "[RFC3102] Borella、M.、Lo、J.、Grabelsky、D。、およびG. Montenegro、「Realm Specific IP：Framework」、RFC 3102、DOI 10.17487 / RFC3102、2001年10月、<https：//www.rfc -editor.org/info/rfc3102>。"
    },
    {
      "indent": 3,
      "text": "[RFC3103] Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi, \"Realm Specific IP: Protocol Specification\", RFC 3103, DOI 10.17487/RFC3103, October 2001, <https://www.rfc-editor.org/info/rfc3103>.",
      "ja": "[RFC3103] Borella、M.、Grabelsky、D.、Lo、J。、およびK. Taniguchi、「Realm Specific IP：Protocol Specification」、RFC 3103、DOI 10.17487 / RFC3103、2001年10月、<https：// www。 rfc-editor.org/info/rfc3103>。"
    },
    {
      "indent": 3,
      "text": "[RFC3235] Senie, D., \"Network Address Translator (NAT)-Friendly Application Design Guidelines\", RFC 3235, DOI 10.17487/RFC3235, January 2002, <https://www.rfc-editor.org/info/rfc3235>.",
      "ja": "[RFC3235] Senie、D。、「Network Address Translator（NAT）-Friendly Application Design Guidelines」、RFC 3235、DOI 10.17487 / RFC3235、2002年1月、<https://www.rfc-editor.org/info/rfc3235> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261]ローゼンバーグ、J。、シュルズリンネ、H。、カマリロ、G。、ジョンストン、A。、ピーターソン、J。、スパークス、R。、ハンドリー、M。、およびE.スクーラー、「SIP：Session Initiation Protocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, DOI 10.17487/RFC3264, June 2002, <https://www.rfc-editor.org/info/rfc3264>.",
      "ja": "[RFC3264] Rosenberg、J。、およびH. Schulzrinne、「セッション記述プロトコル（SDP）を備えたオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org / info / rfc3264>。"
    },
    {
      "indent": 3,
      "text": "[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, \"Middlebox communication architecture and framework\", RFC 3303, DOI 10.17487/RFC3303, August 2002, <https://www.rfc-editor.org/info/rfc3303>.",
      "ja": "[RFC3303] Srisuresh、P.、Kuthan、J.、Rosenberg、J.、Molitor、A。、およびA. Rayhan、「ミドルボックス通信アーキテクチャおよびフレームワーク」、RFC 3303、DOI 10.17487 / RFC3303、2002年8月、<https： //www.rfc-editor.org/info/rfc3303>。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L., Ed. and IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, DOI 10.17487/RFC3424, November 2002, <https://www.rfc-editor.org/info/rfc3424>.",
      "ja": "[RFC3424] Daigle、L.、Ed。 およびIAB、「ネットワークアドレス変換を介した一方的自己アドレス修正（UNSAF）に関するIABの考慮事項」、RFC 3424、DOI 10.17487 / RFC3424、2002年11月、<https://www.rfc-editor.org/info/rfc3424>。"
    },
    {
      "indent": 3,
      "text": "[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, \"STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)\", RFC 3489, DOI 10.17487/RFC3489, March 2003, <https://www.rfc-editor.org/info/rfc3489>.",
      "ja": "[RFC3489]ローゼンバーグ、J。、ワインバーガー、J。、ホイテマ、C。、およびR.マヒー、「STUN-ネットワークアドレストランスレータ（NAT）によるユーザーデータグラムプロトコル（UDP）の単純なトラバース」、RFC 3489、DOI 10.17487 / RFC3489、2003年3月、<https://www.rfc-editor.org/info/rfc3489>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <https://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーションのトランスポートプロトコル」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <https://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3605] Huitema, C., \"Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)\", RFC 3605, DOI 10.17487/RFC3605, October 2003, <https://www.rfc-editor.org/info/rfc3605>.",
      "ja": "[RFC3605] Huitema、C.、「セッション記述プロトコル（SDP）のリアルタイム制御プロトコル（RTCP）属性」、RFC 3605、DOI 10.17487 / RFC3605、2003年10月、<https://www.rfc-editor.org/ info / rfc3605>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「セキュアリアルタイムトランスポートプロトコル（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月 2004、<https://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC3725] Rosenberg, J., Peterson, J., Schulzrinne, H., and G. Camarillo, \"Best Current Practices for Third Party Call Control (3pcc) in the Session Initiation Protocol (SIP)\", BCP 85, RFC 3725, DOI 10.17487/RFC3725, April 2004, <https://www.rfc-editor.org/info/rfc3725>.",
      "ja": "[RFC3725]ローゼンバーグ、J。、ピーターソン、J。、シュルズリンネ、H。、およびG.カマリロ、「セッション開始プロトコル（SIP）のサードパーティコール制御（3pcc）のベストプラクティス」、BCP 85、RFC 3725 、DOI 10.17487 / RFC3725、2004年4月、<https://www.rfc-editor.org/info/rfc3725>。"
    },
    {
      "indent": 3,
      "text": "[RFC3879] Huitema, C. and B. Carpenter, \"Deprecating Site Local Addresses\", RFC 3879, DOI 10.17487/RFC3879, September 2004, <https://www.rfc-editor.org/info/rfc3879>.",
      "ja": "[RFC3879] Huitema、C。、およびB. Carpenter、「非推奨サイトのローカルアドレス」、RFC 3879、DOI 10.17487 / RFC3879、2004年9月、<https://www.rfc-editor.org/info/rfc3879>。"
    },
    {
      "indent": 3,
      "text": "[RFC4038] Shin, M-K., Ed., Hong, Y-G., Hagino, J., Savola, P., and E. Castro, \"Application Aspects of IPv6 Transition\", RFC 4038, DOI 10.17487/RFC4038, March 2005, <https://www.rfc-editor.org/info/rfc4038>.",
      "ja": "[RFC4038] Shin、MK。、Ed。、Hong、YG。、Hagino、J.、Savola、P.、and E. Castro、 \"Application Aspects of IPv6 Transition\"、RFC 4038、DOI 10.17487 / RFC4038、March 2005、 <https://www.rfc-editor.org/info/rfc4038>。"
    },
    {
      "indent": 3,
      "text": "[RFC4091] Camarillo, G. and J. Rosenberg, \"The Alternative Network Address Types (ANAT) Semantics for the Session Description Protocol (SDP) Grouping Framework\", RFC 4091, DOI 10.17487/RFC4091, June 2005, <https://www.rfc-editor.org/info/rfc4091>.",
      "ja": "[RFC4091] Camarillo、G。、およびJ. Rosenberg、「セッション記述プロトコル（SDP）グループ化フレームワークの代替ネットワークアドレスタイプ（ANAT）セマンティクス」、RFC 4091、DOI 10.17487 / RFC4091、2005年6月、<https：// www.rfc-editor.org/info/rfc4091>。"
    },
    {
      "indent": 3,
      "text": "[RFC4092] Camarillo, G. and J. Rosenberg, \"Usage of the Session Description Protocol (SDP) Alternative Network Address Types (ANAT) Semantics in the Session Initiation Protocol (SIP)\", RFC 4092, DOI 10.17487/RFC4092, June 2005, <https://www.rfc-editor.org/info/rfc4092>.",
      "ja": "[RFC4092] Camarillo、G.、J。Rosenberg、「セッション記述プロトコル（SDP）代替ネットワークアドレスタイプ（ANAT）セマンティクスのセッション開始プロトコル（SIP）の使用」、RFC 4092、DOI 10.17487 / RFC4092、2005年6月 、<https://www.rfc-editor.org/info/rfc4092>。"
    },
    {
      "indent": 3,
      "text": "[RFC4103] Hellstrom, G. and P. Jones, \"RTP Payload for Text Conversation\", RFC 4103, DOI 10.17487/RFC4103, June 2005, <https://www.rfc-editor.org/info/rfc4103>.",
      "ja": "[RFC4103] Hellstrom、G。およびP. Jones、「テキスト会話のRTPペイロード」、RFC 4103、DOI 10.17487 / RFC4103、2005年6月、<https://www.rfc-editor.org/info/rfc4103>。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, DOI 10.17487/RFC4291, February 2006, <https://www.rfc-editor.org/info/rfc4291>.",
      "ja": "[RFC4291] Hinden、R。、およびS. Deering、「IPバージョン6アドレス指定アーキテクチャ」、RFC 4291、DOI 10.17487 / RFC4291、2006年2月、<https://www.rfc-editor.org/info/rfc4291>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <https://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566] Handley、M.、Jacobson、V。、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/ info / rfc4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F., Ed. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, <https://www.rfc-editor.org/info/rfc4787>.",
      "ja": "[RFC4787]オーデット、F。、エド。 およびC.ジェニングス、「ユニキャストUDPのネットワークアドレス変換（NAT）動作要件」、BCP 127、RFC 4787、DOI 10.17487 / RFC4787、2007年1月、<https://www.rfc-editor.org/info/rfc4787> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, DOI 10.17487/RFC5245, April 2010, <https://www.rfc-editor.org/info/rfc5245>.",
      "ja": "[RFC5245]ローゼンバーグ、J。、「Interactive Connectivity Establishment（ICE）：オファー/アンサープロトコルのネットワークアドレス変換（NAT）トラバーサルのプロトコル」、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<https：// www .rfc-editor.org / info / rfc5245>。"
    },
    {
      "indent": 3,
      "text": "[RFC5382] Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, \"NAT Behavioral Requirements for TCP\", BCP 142, RFC 5382, DOI 10.17487/RFC5382, October 2008, <https://www.rfc-editor.org/info/rfc5382>.",
      "ja": "[RFC5382] Guha、S.、Ed。、Biswas、K.、Ford、B.、Sivakumar、S.、and P. Srisuresh、 \"NAT Behavioral Requirements for TCP\"、BCP 142、RFC 5382、DOI 10.17487 / RFC5382、 2008年10月、<https://www.rfc-editor.org/info/rfc5382>。"
    },
    {
      "indent": 3,
      "text": "[RFC5761] Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and Control Packets on a Single Port\", RFC 5761, DOI 10.17487/RFC5761, April 2010, <https://www.rfc-editor.org/info/rfc5761>.",
      "ja": "[RFC5761] Perkins、C。、およびM. Westerlund、「単一ポートでのRTPデータおよび制御パケットの多重化」、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<https://www.rfc-editor.org/info / rfc5761>。"
    },
    {
      "indent": 3,
      "text": "[RFC6080] Petrie, D. and S. Channabasappa, Ed., \"A Framework for Session Initiation Protocol User Agent Profile Delivery\", RFC 6080, DOI 10.17487/RFC6080, March 2011, <https://www.rfc-editor.org/info/rfc6080>.",
      "ja": "[RFC6080] Petrie、D.およびS. Channabasappa、Ed。、「セッション開始プロトコルユーザーエージェントプロファイル配信のフレームワーク」、RFC 6080、DOI 10.17487 / RFC6080、2011年3月、<https：//www.rfc-editor。 org / info / rfc6080>。"
    },
    {
      "indent": 3,
      "text": "[RFC6146] Bagnulo, M., Matthews, P., and I. van Beijnum, \"Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers\", RFC 6146, DOI 10.17487/RFC6146, April 2011, <https://www.rfc-editor.org/info/rfc6146>.",
      "ja": "[RFC6146] Bagnulo、M.、Matthews、P。、およびI. van Beijnum、「ステートフルNAT64：IPv6クライアントからIPv4サーバーへのネットワークアドレスおよびプロトコル変換」、RFC 6146、DOI 10.17487 / RFC6146、2011年4月、<https： //www.rfc-editor.org/info/rfc6146>。"
    },
    {
      "indent": 3,
      "text": "[RFC6147] Bagnulo, M., Sullivan, A., Matthews, P., and I. van Beijnum, \"DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers\", RFC 6147, DOI 10.17487/RFC6147, April 2011, <https://www.rfc-editor.org/info/rfc6147>.",
      "ja": "[RFC6147] Bagnulo、M.、Sullivan、A.、Matthews、P。、およびI. van Beijnum、「DNS64：IPv6クライアントからIPv4サーバーへのネットワークアドレス変換のためのDNS拡張」、RFC 6147、DOI 10.17487 / RFC6147、4月 2011、<https://www.rfc-editor.org/info/rfc6147>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298] Paxson、V.、Allman、M.、Chu、J。、およびM. Sargent、「Computing TCPの再送信タイマー」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<https：//www.rfc- editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, \"TCP Candidates with Interactive Connectivity Establishment (ICE)\", RFC 6544, DOI 10.17487/RFC6544, March 2012, <https://www.rfc-editor.org/info/rfc6544>.",
      "ja": "[RFC6544]ローゼンバーグ、J。、ケラネン、A。、ローカンプ、B。、およびA.ローチ、「対話型接続確立（ICE）を使用したTCP候補」、RFC 6544、DOI 10.17487 / RFC6544、2012年3月、<https：/ /www.rfc-editor.org/info/rfc6544>。"
    },
    {
      "indent": 3,
      "text": "[RFC6928] Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis, \"Increasing TCP's Initial Window\", RFC 6928, DOI 10.17487/RFC6928, April 2013, <https://www.rfc-editor.org/info/rfc6928>.",
      "ja": "[RFC6928] Chu、J.、Dukkipati、N.、Cheng、Y。、およびM. Mathis、「TCPの初期ウィンドウの増加」、RFC 6928、DOI 10.17487 / RFC6928、2013年4月、<https：//www.rfc- editor.org/info/rfc6928>。"
    },
    {
      "indent": 3,
      "text": "[RFC7050] Savolainen, T., Korhonen, J., and D. Wing, \"Discovery of the IPv6 Prefix Used for IPv6 Address Synthesis\", RFC 7050, DOI 10.17487/RFC7050, November 2013, <https://www.rfc-editor.org/info/rfc7050>.",
      "ja": "[RFC7050] Savolainen、T.、Korhonen、J。、およびD. Wing、「IPv6アドレス合成に使用されるIPv6プレフィックスの発見」、RFC 7050、DOI 10.17487 / RFC7050、2013年11月、<https：//www.rfc -editor.org/info/rfc7050>。"
    },
    {
      "indent": 3,
      "text": "[RFC7721] Cooper, A., Gont, F., and D. Thaler, \"Security and Privacy Considerations for IPv6 Address Generation Mechanisms\", RFC 7721, DOI 10.17487/RFC7721, March 2016, <https://www.rfc-editor.org/info/rfc7721>.",
      "ja": "[RFC7721] Cooper、A.、Gont、F。、およびD. Thaler、「IPv6アドレス生成メカニズムのセキュリティおよびプライバシーに関する考慮事項」、RFC 7721、DOI 10.17487 / RFC7721、2016年3月、<https：//www.rfc- editor.org/info/rfc7721>。"
    },
    {
      "indent": 3,
      "text": "[RFC7825] Goldberg, J., Westerlund, M., and T. Zeng, \"A Network Address Translator (NAT) Traversal Mechanism for Media Controlled by the Real-Time Streaming Protocol (RTSP)\", RFC 7825, DOI 10.17487/RFC7825, December 2016, <https://www.rfc-editor.org/info/rfc7825>.",
      "ja": "[RFC7825] Goldberg、J.、Westerlund、M。、およびT. Zeng、「リアルタイムストリーミングプロトコル（RTSP）によって制御されるメディアのネットワークアドレス変換（NAT）トラバーサルメカニズム」、RFC 7825、DOI 10.17487 / RFC7825 、2016年12月、<https://www.rfc-editor.org/info/rfc7825>。"
    },
    {
      "indent": 3,
      "text": "[RFC8421] Martinsen, P., Reddy, T., and P. Patil, \"Interactive Connectivity Establishment (ICE) Multihomed and IPv4/IPv6 Dual-Stack Guidelines\", RFC 8421, DOI 10.17487/RFC8421, July 2018, <https://www.rfc-editor.org/info/rfc8421>.",
      "ja": "[RFC8421] Martinsen、P.、Reddy、T。、およびP. Patil、「Interactive Connectivity Establishment（ICE）マルチホームおよびIPv4 / IPv6デュアルスタックガイドライン」、RFC 8421、DOI 10.17487 / RFC8421、2018年7月、<https： //www.rfc-editor.org/info/rfc8421>。"
    },
    {
      "indent": 3,
      "text": "[WebRTC-IP-HANDLING] Uberti, J. and G. Shieh, \"WebRTC IP Address Handling Requirements\", Work in Progress, draft-ietf-rtcweb-ip-handling-09, June 2018.",
      "ja": "[WebRTC-IP-HANDLING] Uberti、J。、およびG. Shieh、「WebRTC IPアドレス処理要件」、Work in Progress、draft-ietf-rtcweb-ip-handling-09、2018年6月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Lite and Full Implementations",
      "ja": "付録A. Liteおよび完全な実装"
    },
    {
      "indent": 3,
      "text": "ICE allows for two types of implementations. A full implementation supports the controlling and controlled roles in a session and can also perform address gathering. In contrast, a lite implementation is a minimalist implementation that does little but respond to STUN checks, and it only supports the controlled role in a session.",
      "ja": "ICEでは、2種類の実装が可能です。 完全な実装では、セッション内の制御ロールと制御ロールがサポートされ、アドレス収集も実行できます。 対照的に、ライト実装は最小限の実装であり、STUNチェックにはほとんど応答せず、セッションで制御された役割のみをサポートします。"
    },
    {
      "indent": 3,
      "text": "Because ICE requires both endpoints to support it in order to bring benefits to either endpoint, incremental deployment of ICE in a network is more complicated. Many sessions involve an endpoint that is, by itself, not behind a NAT and not one that would worry about NAT traversal. A very common case is to have one endpoint that requires NAT traversal (such as a VoIP hard phone or soft phone) make a call to one of these devices. Even if the phone supports a full ICE implementation, ICE won't be used at all if the other device doesn't support it. The lite implementation allows for a low-cost entry point for these devices. Once they support the lite implementation, full implementations can connect to them and get the full benefits of ICE.",
      "ja": "ICEでは、どちらかのエンドポイントにメリットをもたらすために、両方のエンドポイントがそれをサポートする必要があるため、ネットワークでのICEの増分展開はより複雑になります。 多くのセッションには、NATの背後になく、NATトラバーサルを心配しないエンドポイント自体が含まれます。 非常に一般的なケースは、NATトラバーサルを必要とする1つのエンドポイント（VoIPハード電話やソフト電話など）がこれらのデバイスの1つに電話をかけることです。 電話機が完全なICE実装をサポートしていても、他のデバイスがICEをサポートしていない場合、ICEはまったく使用されません。 ライトの実装により、これらのデバイスの低コストのエントリポイントが可能になります。 lite実装をサポートすると、完全な実装がそれらに接続し、ICEのすべての利点を得ることができます。"
    },
    {
      "indent": 3,
      "text": "Consequently, a lite implementation is only appropriate for devices that will *always* be connected to the public Internet and have a public IP address at which it can receive packets from any correspondent. ICE will not function when a lite implementation is placed behind a NAT.",
      "ja": "したがって、Liteの実装は、*常に*パブリックインターネットに接続され、通信員からパケットを受信できるパブリックIPアドレスを持つデバイスにのみ適しています。 ライトの実装がNATの背後に配置されている場合、ICEは機能しません。"
    },
    {
      "indent": 3,
      "text": "ICE allows a lite implementation to have a single IPv4 host candidate and several IPv6 addresses. In that case, candidate pairs are selected by the controlling agent using a static algorithm, such as the one in RFC 6724, which is recommended by this specification. However, static mechanisms for address selection are always prone to error, since they can never reflect the actual topology or provide actual guarantees on connectivity. They are always heuristics. Consequently, if an ICE agent is implementing ICE just to select between its IPv4 and IPv6 addresses, and none of its IP addresses are behind NAT, usage of full ICE is still RECOMMENDED in order to provide the most robust form of address selection possible.",
      "ja": "ICEにより、Lite実装は単一のIPv4ホスト候補と複数のIPv6アドレスを持つことができます。 その場合、候補ペアは、この仕様で推奨されているRFC 6724のアルゴリズムなどの静的アルゴリズムを使用して、制御エージェントによって選択されます。 ただし、アドレス選択の静的なメカニズムは、実際のトポロジを反映したり、接続に関する実際の保証を提供したりすることはできないため、常にエラーが発生しやすくなります。 それらは常にヒューリスティックです。 したがって、ICEエージェントがIPv4アドレスとIPv6アドレスを選択するためだけにICEを実装しており、IPアドレスがNATの背後にない場合、可能な限り最も堅牢な形式のアドレス選択を提供するために、完全なICEの使用が引き続き推奨されます。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the lite implementation was added to this specification to provide a stepping stone to full implementation. Even for devices that are always connected to the public Internet with just a single IPv4 address, a full implementation is preferable if achievable. Full implementations also obtain the security benefits of ICE unrelated to NAT traversal. Finally, it is often the case that a device that finds itself with a public address today will be placed in a network tomorrow where it will be behind a NAT. It is difficult to definitively know, over the lifetime of a device or product, if it will always be used on the public Internet. Full implementation provides assurance that communications will always work.",
      "ja": "完全な実装への足掛かりを提供するために、この仕様にライト実装が追加されたことに注意することが重要です。 常に単一のIPv4アドレスでパブリックインターネットに接続されているデバイスでも、実現可能な場合は完全な実装が望ましいです。 完全な実装では、NATトラバーサルとは関係のないICEのセキュリティ上の利点も得られます。 最後に、今日パブリックアドレスを持つデバイスが明日ネットワークに配置され、NATの背後に配置されることがよくあります。 デバイスまたは製品の耐用年数にわたって、常にパブリックインターネットで使用されるかどうかを明確に知ることは困難です。 完全な実装により、通信が常に機能することが保証されます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Design Motivations",
      "ja": "付録B.設計の動機"
    },
    {
      "indent": 3,
      "text": "ICE contains a number of normative behaviors that may themselves be simple but derive from complicated or non-obvious thinking or use cases that merit further discussion. Since these design motivations are not necessary to understand for purposes of implementation, they are discussed here. This appendix is non-normative.",
      "ja": "ICEには多数の規範的な動作が含まれていますが、これらはそれ自体は単純ですが、複雑で自明ではない思考や、さらなる議論に値するユースケースに由来します。 これらの設計の動機は、実装の目的を理解するために必要ではないため、ここで説明します。 この付録は規範的ではありません。"
    },
    {
      "indent": 0,
      "text": "B.1. Pacing of STUN Transactions",
      "ja": "B.1。 STUNトランザクションのペーシング"
    },
    {
      "indent": 3,
      "text": "STUN transactions used to gather candidates and to verify connectivity are paced out at an approximate rate of one new transaction every Ta milliseconds. Each transaction, in turn, has a retransmission timer RTO that is a function of Ta as well. Why are these transactions paced, and why are these formulas used?",
      "ja": "候補を収集し、接続を確認するために使用されるSTUNトランザクションは、Taミリ秒ごとに1つの新しいトランザクションの概算レートでペースアウトされます。 同様に、各トランザクションには、Taの機能でもある再送信タイマーRTOがあります。 なぜこれらのトランザクションはペース調整され、なぜこれらの式が使用されるのですか？"
    },
    {
      "indent": 3,
      "text": "Sending of these STUN requests will often have the effect of creating bindings on NAT devices between the client and the STUN servers. Experience has shown that many NAT devices have upper limits on the rate at which they will create new bindings. Discussions in the IETF ICE WG during the work on this specification concluded that once every 5 ms is well supported. This is why Ta has a lower bound of 5 ms. Furthermore, transmission of these packets on the network makes use of bandwidth and needs to be rate limited by the ICE agent. Deployments based on earlier draft versions of [RFC5245] tended to overload rate-constrained access links and perform poorly overall, in addition to negatively impacting the network. As a consequence, the pacing ensures that the NAT device does not get overloaded and that traffic is kept at a reasonable rate.",
      "ja": "これらのSTUN要求の送信は、多くの場合、クライアントとSTUNサーバー間のNATデバイスにバインディングを作成する効果があります。 多くのNATデバイスは、新しいバインディングを作成するレートに上限があることが経験からわかっています。 この仕様の作業中のIETF ICE WGでの議論は、5ミリ秒ごとに1回が十分にサポートされると結論付けました。 これが、Taの下限が5ミリ秒である理由です。 さらに、ネットワーク上のこれらのパケットの送信は帯域幅を利用するため、ICEエージェントによってレート制限される必要があります。 [RFC5245]の以前のドラフトバージョンに基づく展開は、ネットワークに悪影響を与えることに加えて、レートが制限されたアクセスリンクを過負荷にし、全体的にパフォーマンスが低下する傾向がありました。 結果として、ペーシングにより、NATデバイスが過負荷にならず、トラフィックが適切なレートに維持されることが保証されます。"
    },
    {
      "indent": 3,
      "text": "The definition of a \"reasonable\" rate is that STUN MUST NOT use more bandwidth than the RTP itself will use, once data starts flowing. The formula for Ta is designed so that, if a STUN packet were sent every Ta seconds, it would consume the same amount of bandwidth as RTP packets, summed across all data streams. Of course, STUN has retransmits, and the desire is to pace those as well. For this reason, RTO is set such that the first retransmit on the first transaction happens just as the first STUN request on the last transaction occurs. Pictorially:",
      "ja": "「合理的な」レートの定義は、データが流れ始めると、STUNはRTP自体が使用するよりも多くの帯域幅を使用してはならないということです。 Taの式は、Ta秒ごとにSTUNパケットが送信されると、RTPパケットと同じ量の帯域幅を消費し、すべてのデータストリームで合計されるように設計されています。 もちろん、STUNには再送信があり、それらのペースも合わせたいと思っています。 このため、RTOは、最後のトランザクションで最初のSTUN要求が発生するのと同じように、最初のトランザクションで最初の再送信が発生するように設定されます。 絵入り："
    },
    {
      "indent": 14,
      "text": "First Packets Retransmits",
      "ja": "最初のパケットの再送信"
    },
    {
      "indent": 11,
      "text": "         |                        |\n         |                        |\n  -------+------           -------+------\n /               \\        /               \\\n/                 \\      /                 \\",
      "raw": true
    },
    {
      "indent": 11,
      "text": "+--+    +--+    +--+    +--+    +--+    +--+\n|A1|    |B1|    |C1|    |A2|    |B2|    |C2|\n+--+    +--+    +--+    +--+    +--+    +--+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "---+-------+-------+-------+-------+-------+------------ Time\n   0       Ta      2Ta     3Ta     4Ta     5Ta",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this picture, there are three transactions that will be sent (for example, in the case of candidate gathering, there are three host candidate/STUN server pairs). These are transactions A, B, and C. The retransmit timer is set so that the first retransmission on the first transaction (packet A2) is sent at time 3Ta.",
      "ja": "この図では、送信される3つのトランザクションがあります（たとえば、候補者の収集の場合、3つのホスト候補/ STUNサーバーのペアがあります）。 これらはトランザクションA、B、およびCです。再送信タイマーは、最初のトランザクション（パケットA2）の最初の再送信が時間3Taに送信されるように設定されます。"
    },
    {
      "indent": 3,
      "text": "Subsequent retransmits after the first will occur even less frequently than Ta milliseconds apart, since STUN uses an exponential backoff on its retransmissions.",
      "ja": "STUNは再送信で指数バックオフを使用するため、最初の再送信後の後続の再送信は、Taミリ秒間隔よりもさらに少ない頻度で発生します。"
    },
    {
      "indent": 3,
      "text": "This mechanism of a global minimum pacing interval of 5 ms is not generally applicable to transport protocols, but it is applicable to ICE based on the following reasoning.",
      "ja": "5 msのグローバル最小ペーシング間隔のこのメカニズムは、一般にトランスポートプロトコルには適用できませんが、次の理由に基づいてICEに適用できます。"
    },
    {
      "indent": 3,
      "text": "o Start with the following rules that would be generally applicable to transport protocols:",
      "ja": "o一般にトランスポートプロトコルに適用される次のルールから始めます。"
    },
    {
      "indent": 6,
      "text": "1. Let MaxBytes be the maximum number of bytes allowed to be outstanding in the network at startup, which SHOULD be 14600, as defined in Section 2 of [RFC6928].",
      "ja": "1. [RFC6928]のセクション2で定義されているように、MaxBytesを起動時にネットワークで未処理にすることができる最大バイト数とします。これは14600である必要があります。"
    },
    {
      "indent": 6,
      "text": "2. Let HTO be the transaction timeout, which SHOULD be 2*RTT if RTT is known or 500 ms otherwise. This is based on the RTO for STUN messages from [RFC5389] and the TCP initial RTO, which is 1 sec in [RFC6298].",
      "ja": "2. HTOをトランザクションタイムアウトとし、RTTが既知の場合は2 * RTT、それ以外の場合は500ミリ秒にする必要があります。 これは、[RFC5389]からのSTUNメッセージのRTOおよび[RFC6298]の1秒であるTCP初期RTOに基づいています。"
    },
    {
      "indent": 6,
      "text": "3. Let MinPacing be the minimum pacing interval between transactions, which is 5 ms (see above).",
      "ja": "3. MinPacingをトランザクション間の最小ペーシング間隔、5ミリ秒とします（上記を参照）。"
    },
    {
      "indent": 3,
      "text": "o Observe that agents typically do not know the RTT for ICE transactions (connectivity checks in particular), meaning that HTO will almost always be 500 ms.",
      "ja": "o通常、エージェントはICEトランザクション（特に接続性チェック）のRTTを知らないことに注意してください。つまり、HTOはほとんど常に500ミリ秒です。"
    },
    {
      "indent": 3,
      "text": "o Observe that a MinPacing of 5 ms and HTO of 500 ms gives at most 100 packets/HTO, which for a typical ICE check of less than 120 bytes means a maximum of 12000 outstanding bytes in the network, which is less than the maximum expressed by rule 1.",
      "ja": "o MinPacingが5ミリ秒、HTOが500ミリ秒で最大100パケット/ HTOが得られることに注意してください。これは、120バイト未満の一般的なICEチェックでは、ネットワーク内の最大12000未処理バイトを意味します。 ルール1により。"
    },
    {
      "indent": 3,
      "text": "o Thus, for ICE, the rule set reduces to just the MinPacing rule, which is equivalent to having a global Ta value.",
      "ja": "oしたがって、ICEの場合、ルールセットはMinPacingルールに縮小されます。これは、グローバルなTa値を持つことに相当します。"
    },
    {
      "indent": 0,
      "text": "B.2. Candidates with Multiple Bases",
      "ja": "B.2。 複数のベースを持つ候補者"
    },
    {
      "indent": 3,
      "text": "Section 5.1.3 talks about eliminating candidates that have the same transport address and base. However, candidates with the same transport addresses but different bases are not redundant. When can an ICE agent have two candidates that have the same IP address and port but different bases? Consider the topology of Figure 11:",
      "ja": "セクション5.1.3では、同じトランスポートアドレスとベースを持つ候補の削除について説明します。 ただし、トランスポートアドレスが同じでベースが異なる候補は冗長ではありません。 ICEエージェントは、同じIPアドレスとポートを持っているがベースが異なる2つの候補者をいつ持つことができますか？ 図11のトポロジーを検討してください。"
    },
    {
      "indent": 9,
      "text": " +----------+\n | STUN Srvr|\n +----------+\n      |\n      |\n    -----\n  //     \\\\\n |         |\n|  B:net10  |\n |         |\n  \\\\     //\n    -----\n      |\n      |\n +----------+\n |   NAT    |\n +----------+\n      |\n      |\n    -----\n  //     \\\\\n |    A    |\n|192.168/16 |\n |         |\n  \\\\     //\n    -----\n      |\n      |\n      |192.168.1.100      -----\n +----------+           //     \\\\             +----------+\n |          |          |         |            |          |\n | Initiator|---------|  C:net10  |-----------| Responder|\n |          |10.0.1.100|         | 10.0.1.101 |          |\n +----------+           \\\\     //             +----------+\n                          -----",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 11: Identical Candidates with Different Bases",
      "ja": "図11：異なるベースを持つ同一の候補"
    },
    {
      "indent": 3,
      "text": "In this case, the initiating agent is multihomed. It has one IP address, 10.0.1.100, on network C, which is a net 10 private network. The responding agent is on this same network. The initiating agent is also connected to network A, which is 192.168/16, and has an IP address of 192.168.1.100. There is a NAT on this network, natting into network B, which is another net 10 private network, but it is not connected to network C. There is a STUN server on network B.",
      "ja": "この場合、開始エージェントはマルチホームです。 ネット10プライベートネットワークであるネットワークCに1つのIPアドレス10.0.1.100があります。 応答するエージェントはこの同じネットワーク上にあります。 開始エージェントは、192.168 / 16のネットワークAにも接続されており、IPアドレスは192.168.1.100です。 このネットワークにはNATがあり、別のネット10プライベートネットワークであるネットワークBに接続していますが、ネットワークCには接続されていません。ネットワークBにはSTUNサーバーがあります。"
    },
    {
      "indent": 3,
      "text": "The initiating agent obtains a host candidate on its IP address on network C (10.0.1.100:2498) and a host candidate on its IP address on network A (192.168.1.100:3344). It performs a STUN query to its configured STUN server from 192.168.1.100:3344. This query passes through the NAT, which happens to assign the binding 10.0.1.100:2498. The STUN server reflects this in the STUN Binding response. Now, the initiating agent has obtained a server-reflexive candidate with a transport address that is identical to a host candidate (10.0.1.100:2498). However, the server-reflexive candidate has a base of 192.168.1.100:3344, and the host candidate has a base of 10.0.1.100:2498.",
      "ja": "開始エージェントは、ネットワークC（10.0.1.100:2498）のIPアドレスでホスト候補を取得し、ネットワークA（192.168.1.100:3344）のIPアドレスでホスト候補を取得します。 構成済みのSTUNサーバーに対して192.168.1.100:3344からSTUNクエリを実行します。 このクエリはNATを通過します。これにより、たまたまバインディング10.0.1.100:2498が割り当てられます。 STUNサーバーはこれをSTUNバインディング応答に反映します。 これで、開始エージェントは、ホスト候補（10.0.1.100:2498）と同一のトランスポートアドレスを持つサーバー反射候補を取得しました。 ただし、サーバー反映候補のベースは192.168.1.100:3344であり、ホスト候補のベースは10.0.1.100:2498です。"
    },
    {
      "indent": 0,
      "text": "B.3. Purpose of the Related-Address and Related-Port Attributes",
      "ja": "B.3。 Related-AddressおよびRelated-Port属性の目的"
    },
    {
      "indent": 3,
      "text": "The candidate attribute contains two values that are not used at all by ICE itself -- related address and related port. Why are they present?",
      "ja": "候補属性には、ICE自体によってまったく使用されない2つの値（関連アドレスと関連ポート）が含まれます。 なぜ存在するのですか？"
    },
    {
      "indent": 3,
      "text": "There are two motivations for its inclusion. The first is diagnostic. It is very useful to know the relationship between the different types of candidates. By including it, an ICE agent can know which relayed candidate is associated with which reflexive candidate, which in turn is associated with a specific host candidate. When checks for one candidate succeed but not for others, this provides useful diagnostics on what is going on in the network.",
      "ja": "含める理由は2つあります。 1つ目は診断です。 さまざまなタイプの候補者間の関係を知ることは非常に役立ちます。 それを含めることにより、ICEエージェントはどのリレー候補がどの反射候補に関連付けられているかを知ることができ、それが特定のホスト候補に関連付けられています。 ある候補のチェックは成功したが、他の候補のチェックは成功しなかった場合、これはネットワークで何が起こっているかについて有用な診断を提供します。"
    },
    {
      "indent": 3,
      "text": "The second reason has to do with off-path Quality-of-Service (QoS) mechanisms. When ICE is used in environments such as PacketCable 2.0, proxies will, in addition to performing normal SIP operations, inspect the SDP in SIP messages and extract the IP address and port for data traffic. They can then interact, through policy servers, with access routers in the network, to establish guaranteed QoS for the data flows. This QoS is provided by classifying the RTP traffic based on 5-tuple and then providing it a guaranteed rate, or marking its DSCP appropriately. When a residential NAT is present, and a relayed candidate gets selected for data, this relayed candidate will be a transport address on an actual TURN server. That address says nothing about the actual transport address in the access router that would be used to classify packets for QoS treatment. Rather, the server-reflexive candidate towards the TURN server is needed. By carrying the translation in the SDP, the proxy can use that transport address to request QoS from the access router.",
      "ja": "2番目の理由は、オフパスのQuality of Service（QoS）メカニズムに関係しています。 ICEがPacketCable 2.0などの環境で使用される場合、プロキシは通常のSIP操作の実行に加えて、SIPメッセージのSDPを検査し、データトラフィックのIPアドレスとポートを抽出します。その後、ポリシーサーバーを介してネットワーク内のアクセスルーターとやり取りして、データフローの保証されたQoSを確立できます。このQoSは、5タプルに基づいてRTPトラフィックを分類し、保証されたレートを提供するか、DSCPを適切にマークすることにより提供されます。レジデンシャルNATが存在し、中継候補がデータ用に選択されると、この中継候補は実際のTURNサーバー上のトランスポートアドレスになります。そのアドレスは、QoS処理のためにパケットを分類するために使用されるアクセスルータの実際のトランスポートアドレスについては何も言いません。むしろ、TURNサーバーに対するサーバー反射候補が必要です。 SDPで変換を実行することにより、プロキシはそのトランスポートアドレスを使用してアクセスルーターからQoSを要求できます。"
    },
    {
      "indent": 0,
      "text": "B.4. Importance of the STUN Username",
      "ja": "B.4。 STUNユーザー名の重要性"
    },
    {
      "indent": 3,
      "text": "ICE requires the usage of message integrity with STUN using its short-term credential functionality. The actual short-term credential is formed by exchanging username fragments in the candidate exchange. The need for this mechanism goes beyond just security; it is actually required for correct operation of ICE in the first place.",
      "ja": "ICEでは、短期の資格情報機能を使用して、STUNでメッセージ整合性を使用する必要があります。 実際の短期的な資格情報は、候補者交換でユーザー名フラグメントを交換することにより形成されます。 このメカニズムの必要性は、単なるセキュリティを超えています。 そもそも、実際にICEを正しく動作させるために必要です。"
    },
    {
      "indent": 3,
      "text": "Consider ICE agents L, R, and Z. L and R are within private enterprise 1, which is using 10.0.0.0/8. Z is within private enterprise 2, which is also using 10.0.0.0/8. As it turns out, R and Z both have IP address 10.0.1.1. L sends candidates to Z. Z responds to L with its host candidates. In this case, those candidates are 10.0.1.1:8866 and 10.0.1.1:8877. As it turns out, R is in a session at that same time and is also using 10.0.1.1:8866 and 10.0.1.1:8877 as host candidates. This means that R is prepared to accept STUN messages on those ports, just as Z is. L will send a STUN request to 10.0.1.1:8866 and another to 10.0.1.1:8877. However, these do not go to Z as expected. Instead, they go to R! If R just replied to them, L would believe it has connectivity to Z, when in fact it has connectivity to a completely different user, R. To fix this, STUN short-term credential mechanisms are used. The username fragments are sufficiently random; thus it is highly unlikely that R would be using the same values as Z. Consequently, R would reject the STUN request since the credentials were invalid. In essence, the STUN username fragments provide a form of transient host identifiers, bound to a particular session established as part of the candidate exchange.",
      "ja": "ICEエージェントL、R、およびZを検討してください。LおよびRは、10.0.0.0 / 8を使用している民間企業1内にあります。 Zは、10.0.0.0 / 8を使用している民間企業2内にあります。結局のところ、RとZは両方ともIPアドレス10.0.1.1を持っています。 LはZに候補を送信します。Zはホスト候補でLに応答します。この場合、これらの候補は10.0.1.1:8866および10.0.1.1:8877です。結局のところ、Rは同時にセッションに参加しており、ホスト候補として10.0.1.1:8866と10.0.1.1:8877も使用しています。これは、Zがそうであるように、RはそれらのポートでSTUNメッセージを受け入れる準備ができていることを意味します。 Lは、STUN要求を10.0.1.1:8866に送信し、別の要求を10.0.1.1:8877に送信します。ただし、これらは予想どおりZに移動しません。代わりに、彼らはRに行きます！ Rが単にそれらに応答した場合、LはZとの接続を持っていると信じますが、実際には完全に異なるユーザーRとの接続を持っています。これを修正するために、STUN短期資格情報メカニズムが使用されます。ユーザー名フラグメントは十分にランダムです。したがって、RがZと同じ値を使用することはほとんどありません。その結果、資格情報が無効であるため、RはSTUN要求を拒否します。本質的に、STUNユーザー名フラグメントは、一時的なホスト識別子の形式を提供し、候補交換の一部として確立された特定のセッションにバインドされます。"
    },
    {
      "indent": 3,
      "text": "An unfortunate consequence of the non-uniqueness of IP addresses is that, in the above example, R might not even be an ICE agent. It could be any host, and the port to which the STUN packet is directed could be any ephemeral port on that host. If there is an application listening on this socket for packets, and it is not prepared to handle malformed packets for whatever protocol is in use, the operation of that application could be affected. Fortunately, since the ports exchanged are ephemeral and usually drawn from the dynamic or registered range, the odds are good that the port is not used to run a server on host R, but rather is the agent side of some protocol. This decreases the probability of hitting an allocated port, due to the transient nature of port usage in this range. However, the possibility of a problem does exist, and network deployers need to be prepared for it. Note that this is not a problem specific to ICE; stray packets can arrive at a port at any time for any type of protocol, especially ones on the public Internet. As such, this requirement is just restating a general design guideline for Internet applications -- be prepared for unknown packets on any port.",
      "ja": "IPアドレスの非一意性の不幸な結果は、上記の例では、RがICEエージェントでさえない可能性があることです。任意のホストである可能性があり、STUNパケットが送信されるポートは、そのホスト上の任意の一時ポートである可能性があります。このソケットでパケットをリッスンするアプリケーションがあり、使用中のプロトコルにかかわらず不正なパケットを処理する準備ができていない場合、そのアプリケーションの動作に影響が及ぶ可能性があります。幸いなことに、交換されるポートは一時的なものであり、通常は動的または登録範囲から取得されるため、ホストRでサーバーを実行するためにポートが使用されず、一部のプロトコルのエージェント側である可能性が高くなります。これは、この範囲のポート使用の一時的な性質により、割り当てられたポートにヒットする可能性を減らします。ただし、問題が発生する可能性はあるため、ネットワークデプロイヤはそれに対して準備する必要があります。これはICE固有の問題ではないことに注意してください。漂遊パケットは、あらゆるタイプのプロトコル、特にパブリックインターネット上のプロトコルのポートにいつでも到着する可能性があります。そのため、この要件は、インターネットアプリケーションの一般的な設計ガイドラインを言い換えているだけです。あらゆるポートで未知のパケットに備えてください。"
    },
    {
      "indent": 0,
      "text": "B.5. The Candidate Pair Priority Formula",
      "ja": "B.5。 候補ペアの優先式"
    },
    {
      "indent": 3,
      "text": "The priority for a candidate pair has an odd form. It is:",
      "ja": "候補ペアの優先順位は奇妙な形をしています。 それは："
    },
    {
      "indent": 6,
      "text": "pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)",
      "ja": "ペアの優先度= 2 ^ 32 * MIN（G、D）+ 2 * MAX（G、D）+（G> D？1：0）"
    },
    {
      "indent": 3,
      "text": "Why is this? When the candidate pairs are sorted based on this value, the resulting sorting has the MAX/MIN property. This means that the pairs are first sorted based on decreasing value of the minimum of the two priorities. For pairs that have the same value of the minimum priority, the maximum priority is used to sort amongst them. If the max and the min priorities are the same, the controlling agent's priority is used as the tiebreaker in the last part of the expression. The factor of 2*32 is used since the priority of a single candidate is always less than 2*32, resulting in the pair priority being a \"concatenation\" of the two component priorities. This creates the MAX/MIN sorting. MAX/MIN ensures that, for a particular ICE agent, a lower-priority candidate is never used until all higher-priority candidates have been tried.",
      "ja": "どうしてこれなの？ 候補ペアがこの値に基づいてソートされる場合、結果のソートにはMAX / MINプロパティがあります。 これは、2つの優先順位の最小値の減少に基づいてペアが最初にソートされることを意味します。 最小優先度の値が同じペアの場合、最大優先度を使用してそれらの間でソートします。 最大優先順位と最小優先順位が同じ場合、制御エージェントの優先順位が式の最後の部分でタイブレーカーとして使用されます。 単一の候補の優先度は常に2 * 32未満であるため、2 * 32の係数が使用され、ペアの優先度は2つのコンポーネントの優先度の「連結」になります。 これにより、MAX / MINソートが作成されます。 MAX / MINは、特定のICEエージェントについて、優先度の高い候補がすべて試行されるまで、優先度の低い候補が使用されないようにします。"
    },
    {
      "indent": 0,
      "text": "B.6. Why Are Keepalives Needed?",
      "ja": "B.6。 キープアライブが必要な理由"
    },
    {
      "indent": 3,
      "text": "Once data begins flowing on a candidate pair, it is still necessary to keep the bindings alive at intermediate NATs for the duration of the session. Normally, the data stream packets themselves (e.g., RTP) meet this objective. However, several cases merit further discussion. Firstly, in some RTP usages, such as SIP, the data streams can be \"put on hold\". This is accomplished by using the SDP \"sendonly\" or \"inactive\" attributes, as defined in RFC 3264 [RFC3264]. RFC 3264 directs implementations to cease transmission of data in these cases. However, doing so may cause NAT bindings to time out, and data won't be able to come off hold.",
      "ja": "候補ペアでデータが流れ始めたら、セッションの間中、中間NATでバインディングを維持する必要があります。 通常、データストリームパケット自体（RTPなど）はこの目的を満たします。 ただし、いくつかのケースでさらに議論する価値があります。 まず、SIPなどの一部のRTPの使用法では、データストリームを「保留」にすることができます。 これは、RFC 3264 [RFC3264]で定義されているSDPの「sendonly」または「inactive」属性を使用することで実現されます。 RFC 3264は、これらの場合にデータの送信を停止するように実装に指示します。 ただし、そうすると、NATバインディングがタイムアウトになり、データが保留にならない場合があります。"
    },
    {
      "indent": 3,
      "text": "Secondly, some RTP payload formats, such as the payload format for text conversation [RFC4103], may send packets so infrequently that the interval exceeds the NAT binding timeouts.",
      "ja": "第二に、テキスト会話[RFC4103]のペイロード形式など、一部のRTPペイロード形式は、間隔がNATバインディングタイムアウトを超えるほど頻繁にパケットを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "Thirdly, if silence suppression is in use, long periods of silence may cause data transmission to cease sufficiently long for NAT bindings to time out.",
      "ja": "第三に、無音抑止が使用されている場合、無音の期間が長いと、データ送信がNATバインディングがタイムアウトするのに十分な時間停止する可能性があります。"
    },
    {
      "indent": 3,
      "text": "For these reasons, the data packets themselves cannot be relied upon. ICE defines a simple periodic keepalive utilizing STUN Binding Indications. This makes its bandwidth requirements highly predictable and thus amenable to QoS reservations.",
      "ja": "これらの理由により、データパケット自体は信頼できません。 ICEは、STUN Binding Indicationsを利用した単純な定期的なキープアライブを定義しています。 これにより、帯域幅の要件が非常に予測可能になり、QoSの予約を受け入れやすくなります。"
    },
    {
      "indent": 0,
      "text": "B.7. Why Prefer Peer-Reflexive Candidates?",
      "ja": "B.7。 なぜ仲間意識のある候補者を好むのか？"
    },
    {
      "indent": 3,
      "text": "Section 5.1.2 describes procedures for computing the priority of a candidate based on its type and local preferences. That section requires that the type preference for peer-reflexive candidates always be higher than server reflexive. Why is that? The reason has to do with the security considerations in Section 19. It is much easier for an attacker to cause an ICE agent to use a false server-reflexive candidate rather than a false peer-reflexive candidate. Consequently, attacks against address gathering with Binding requests are thwarted by ICE by preferring the peer-reflexive candidates.",
      "ja": "セクション5.1.2では、候補のタイプとローカルプリファレンスに基づいて候補の優先度を計算する手順について説明します。 そのセクションでは、ピア再帰候補のタイプ設定が常にサーバー再帰よりも高いことが必要です。 何故ですか？ 理由は、セクション19のセキュリティに関する考慮事項に関係しています。攻撃者にとって、ICEエージェントが偽のピア反射候補ではなく、偽のサーバー反射候補を使用するのははるかに簡単です。 その結果、バインディング要求によるアドレス収集に対する攻撃は、ピア反射候補を優先することにより、ICEによって阻止されます。"
    },
    {
      "indent": 0,
      "text": "B.8. Why Are Binding Indications Used for Keepalives?",
      "ja": "B.8。 キープアライブにバインド表示が使用される理由"
    },
    {
      "indent": 3,
      "text": "Data keepalives are described in Section 11. These keepalives make use of STUN when both endpoints are ICE capable. However, rather than using a Binding request transaction (which generates a response), the keepalives use an Indication. Why is that?",
      "ja": "データキープアライブについては、セクション11で説明します。これらのキープアライブは、両方のエンドポイントがICE対応の場合にSTUNを使用します。 ただし、（応答を生成する）バインディング要求トランザクションを使用するのではなく、キープアライブは指示を使用します。 何故ですか？"
    },
    {
      "indent": 3,
      "text": "The primary reason has to do with network QoS mechanisms. Once data begins flowing, network elements will assume that the data stream has a fairly regular structure, making use of periodic packets at fixed intervals, with the possibility of jitter. If an ICE agent is sending data packets, and then receives a Binding request, it would need to generate a response packet along with its data packets. This will increase the actual bandwidth requirements for the 5-tuple carrying the data packets and introduce jitter in the delivery of those packets. Analysis has shown that this is a concern in certain Layer 2 access networks that use fairly tight packet schedulers for data.",
      "ja": "主な理由は、ネットワークQoSメカニズムに関係しています。 データが流れ始めると、ネットワーク要素は、データストリームがかなり規則的な構造を持っていると仮定し、ジッタの可能性がある固定間隔で定期的なパケットを利用します。 ICEエージェントがデータパケットを送信していて、バインド要求を受信した場合、データパケットとともに応答パケットを生成する必要があります。 これにより、データパケットを運ぶ5タプルの実際の帯域幅要件が増加し、これらのパケットの配信にジッタが発生します。 分析により、これはデータにかなりタイトなパケットスケジューラを使用する特定のレイヤ2アクセスネットワークで懸念されることが示されています。"
    },
    {
      "indent": 3,
      "text": "Additionally, using a Binding Indication allows integrity to be disabled, which may result in better performance. This is useful for large-scale endpoints, such as Public Switched Telephone Network (PSTN) gateways and Session Border Controllers (SBCs).",
      "ja": "さらに、バインディング表示を使用すると、整合性を無効にできるため、パフォーマンスが向上する場合があります。 これは、公衆交換電話網（PSTN）ゲートウェイやセッションボーダーコントローラー（SBC）などの大規模なエンドポイントに役立ちます。"
    },
    {
      "indent": 0,
      "text": "B.9. Selecting Candidate Type Preference",
      "ja": "B.9。 候補タイプの設定の選択"
    },
    {
      "indent": 3,
      "text": "One criterion for selecting type and local preference values is the use of a data intermediary, such as a TURN server, a tunnel service such as a VPN server, or NAT. With a data intermediary, if data is sent to that candidate, it will first transit the data intermediary before being received. One type of candidate that involves a data intermediary is the relayed candidate. Another type is the host candidate, which is obtained from a VPN interface. When data is transited through a data intermediary, it can have a positive or negative effect on the latency between transmission and reception. It may or may not increase the packet losses, because of the additional router hops that may be taken. It may increase the cost of providing service, since data will be routed in and right back out of a data intermediary run by a provider. If these concerns are important, the type preference for relayed candidates needs to be carefully chosen.",
      "ja": "タイプとローカルプリファレンス値を選択する1つの基準は、TURNサーバー、VPNサーバーなどのトンネルサービス、またはNATなどのデータ中間体の使用です。 データ仲介者では、データがその候補に送信されると、受信される前に最初にデータ仲介者を通過します。 データ仲介者が関与する候補の1つのタイプは、リレーされた候補です。 別のタイプは、VPNインターフェースから取得されるホスト候補です。 データがデータ仲介者を介して転送されると、送信と受信の間の待ち時間にプラスまたはマイナスの影響を与える可能性があります。 ルーターホップが追加されるため、パケット損失が増加する場合と増加しない場合があります。 データはプロバイダーによって実行されるデータ仲介者にルーティングされ、またその逆に送られるため、サービスの提供コストが増加する可能性があります。 これらの懸念が重要である場合、リレーされた候補者のタイプ設定を慎重に選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Another criterion for selecting preferences is the IP address family. ICE works with both IPv4 and IPv6. It provides a transition mechanism that allows dual-stack hosts to prefer connectivity over IPv6 but to fall back to IPv4 in case the v6 networks are disconnected. Implementation SHOULD follow the guidelines from [RFC8421] to avoid excessive delays in the connectivity-check phase if broken paths exist.",
      "ja": "プリファレンスを選択するためのもう1つの基準は、IPアドレスファミリです。 ICEは、IPv4とIPv6の両方で機能します。 これは、デュアルスタックホストがIPv6よりも接続性を優先し、v6ネットワークが切断された場合にIPv4にフォールバックできる移行メカニズムを提供します。 実装は、[RFC8421]のガイドラインに従って、壊れたパスが存在する場合の接続性チェックフェーズでの過度の遅延を回避する必要があります。"
    },
    {
      "indent": 3,
      "text": "Another criterion for selecting preferences is topological awareness. This is beneficial for candidates that make use of intermediaries. In those cases, if an ICE agent has preconfigured or dynamically discovered knowledge of the topological proximity of the intermediaries to itself, it can use that to assign higher local preferences to candidates obtained from closer intermediaries.",
      "ja": "プリファレンスを選択するためのもう1つの基準は、トポロジ認識です。 これは、仲介者を利用する候補者にとって有益です。 そのような場合、ICEエージェントが、自身の仲介者のトポロジの近接性に関する事前構成済みまたは動的な発見を持っている場合、それを使用して、より近い仲介者から取得した候補に高いローカルプリファレンスを割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Another criterion for selecting preferences might be security or privacy. If a user is a telecommuter, and therefore connected to a corporate network and a local home network, the user may prefer their voice traffic to be routed over the VPN or similar tunnel in order to keep it on the corporate network when communicating within the enterprise but may use the local network when communicating with users outside of the enterprise. In such a case, a VPN address would have a higher local preference than any other address.",
      "ja": "プリファレンスを選択する別の基準は、セキュリティまたはプライバシーです。 ユーザーが在宅勤務者であり、したがって企業ネットワークおよびローカルホームネットワークに接続している場合、ユーザーは企業内で通信するときに音声トラフィックを企業ネットワーク上に保持するために、VPNまたは同様のトンネルを介してルーティングされることを好む場合があります 企業外のユーザーと通信するときにローカルネットワークを使用する場合があります。 このような場合、VPNアドレスは他のアドレスよりもローカルの優先度が高くなります。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Connectivity-Check Bandwidth",
      "ja": "付録C.接続性チェック帯域幅"
    },
    {
      "indent": 3,
      "text": "The tables below show, for IPv4 and IPv6, the bandwidth required for performing connectivity checks, using different Ta values (given in ms) and different ufrag sizes (given in bytes).",
      "ja": "以下の表は、IPv4およびIPv6について、さまざまなTa値（ミリ秒単位）とさまざまなufragサイズ（バイト単位）を使用して、接続性チェックを実行するために必要な帯域幅を示しています。"
    },
    {
      "indent": 3,
      "text": "The results were provided by Jusin Uberti (Google) on 11 April 2016.",
      "ja": "結果は、2016年4月11日にJusin Uberti（Google）によって提供されました。"
    },
    {
      "indent": 21,
      "text": "IP version: IPv4\nPacket len (bytes): 108 + ufrag\n     |\n  ms |     4     8    12    16\n-----|------------------------\n 500 | 1.86k 1.98k 2.11k 2.24k\n 200 | 4.64k 4.96k 5.28k  5.6k\n 100 | 9.28k 9.92k 10.6k 11.2k\n  50 | 18.6k 19.8k 21.1k 22.4k\n  20 | 46.4k 49.6k 52.8k 56.0k\n  10 | 92.8k 99.2k  105k  112k\n   5 |  185k  198k  211k  224k\n   2 |  464k  496k  528k  560k\n   1 |  928k  992k 1.06M 1.12M",
      "raw": true
    },
    {
      "indent": 21,
      "text": "IP version: IPv6\nPacket len (bytes): 128 + ufrag\n     |\n  ms |     4     8    12    16\n-----|------------------------\n 500 | 2.18k  2.3k 2.43k 2.56k\n 200 | 5.44k 5.76k 6.08k  6.4k\n 100 | 10.9k 11.5k 12.2k 12.8k\n  50 | 21.8k 23.0k 24.3k 25.6k\n  20 | 54.4k 57.6k 60.8k 64.0k\n  10 |  108k  115k  121k  128k\n   5 |  217k  230k  243k  256k\n   2 |  544k  576k  608k  640k\n   1 | 1.09M 1.15M 1.22M 1.28M",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 12: Connectivity-Check Bandwidth",
      "ja": "図12：接続性チェック帯域幅"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Most of the text in this document comes from the original ICE specification, RFC 5245. The authors would like to thank everyone who has contributed to that document. For additional contributions to this revision of the specification, we would like to thank Emil Ivov, Paul Kyzivat, Pal-Erik Martinsen, Simon Perrault, Eric Rescorla, Thomas Stach, Peter Thatcher, Martin Thomson, Justin Uberti, Suhas Nandakumar, Taylor Brandstetter, Peter Saint-Andre, Harald Alvestrand, and Roman Shpount. Ben Campbell did the AD review. Stephen Farrell did the sec-dir review. Stewart Bryant did the gen-art review. Qin We did the ops-dir review. Magnus Westerlund did the tsv-art review.",
      "ja": "このドキュメントのテキストのほとんどは、オリジナルのICE仕様であるRFC 5245に基づいています。著者は、そのドキュメントに貢献してくれたすべての人に感謝したいと思います。 この仕様の改訂へのさらなる貢献については、エミール・イヴォフ、ポール・キジヴァト、パル・エリック・マーティンセン、サイモン・ペロー、エリック・レスコルラ、トーマス・スタッハ、ピーター・サッチャー、マーティン・トムソン、ジャスティン・ウベルティ、スハス・ナンダクマール、テイラー・ブランドステッター、 ピーター・サン・アンドレ、ハラルド・アルベストランド、ローマン・シュポント。 ベンキャンベルがADレビューを行いました。 Stephen Farrellがsec-dirレビューを行いました。 スチュワートブライアントがgen-artレビューを行いました。 Qin ops-dirレビューを行いました。 Magnus Westerlundがtsv-artレビューを行いました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ari Keranen Ericsson Hirsalantie 11 02420 Jorvas Finland",
      "ja": "Ari Keranen Ericsson Hirsalantie 11 02420 Jorvas Finland"
    },
    {
      "indent": 3,
      "text": "Email: ari.keranen@ericsson.com",
      "ja": "メール：ari.keranen@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Christer Holmberg Ericsson Hirsalantie 11 02420 Jorvas Finland",
      "ja": "Christer Holmberg Ericsson Hirsalantie 11 02420 Jorvas Finland"
    },
    {
      "indent": 3,
      "text": "Email: christer.holmberg@ericsson.com",
      "ja": "メール：christer.holmberg@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg jdrosen.net Monmouth, NJ United States of America",
      "ja": "ジョナサン・ローゼンバーグjdrosen.netニュージャージー州モンマスアメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: jdrosen@jdrosen.net URI: http://www.jdrosen.net",
      "ja": "メール：jdrosen@jdrosen.net URI：http://www.jdrosen.net"
    }
  ]
}