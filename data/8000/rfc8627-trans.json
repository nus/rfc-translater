{
  "title": {
    "text": "RFC 8627 - RTP Payload Format for Flexible Forward Error Correction (FEC)",
    "ja": "RFC 8627 - Flexible Forward Error Correction（FEC）のRTPペイロード形式"
  },
  "number": 8627,
  "created_at": "2019-11-06 11:53:05.051062+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         M. Zanaty\nRequest for Comments: 8627                                         Cisco\nCategory: Standards Track                                       V. Singh\nISSN: 2070-1721                                             callstats.io\n                                                                A. Begen\n                                                         Networked Media\n                                                              G. Mandyam\n                                                           Qualcomm Inc.\n                                                               July 2019",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RTP Payload Format for Flexible Forward Error Correction (FEC)",
      "ja": "Flexible Forward Error Correction（FEC）のRTPペイロード形式"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines new RTP payload formats for the Forward Error Correction (FEC) packets that are generated by the non-interleaved and interleaved parity codes from source media encapsulated in RTP. These parity codes are systematic codes (Flexible FEC, or \"FLEX FEC\"), where a number of FEC repair packets are generated from a set of source packets from one or more source RTP streams. These FEC repair packets are sent in a redundancy RTP stream separate from the source RTP stream(s) that carries the source packets. RTP source packets that were lost in transmission can be reconstructed using the source and repair packets that were received. The non-interleaved and interleaved parity codes that are defined in this specification offer a good protection against random and bursty packet losses, respectively, at a cost of complexity. The RTP payload formats that are defined in this document address scalability issues experienced with the earlier specifications and offer several improvements. Due to these changes, the new payload formats are not backward compatible with earlier specifications; however, endpoints that do not implement this specification can still work by simply ignoring the FEC repair packets.",
      "ja": "このドキュメントでは、RTPでカプセル化されたソースメディアからの非インターリーブおよびインターリーブパリティコードによって生成されるForward Error Correction（FEC）パケットの新しいRTPペイロード形式を定義します。これらのパリティコードは体系的なコード（Flexible FEC、または「FLEX FEC」）であり、1つ以上のソースRTPストリームからのソースパケットのセットから多数のFEC修復パケットが生成されます。これらのFEC修復パケットは、ソースパケットを伝送するソースRTPストリームとは別の冗長RTPストリームで送信されます。送信で失われたRTPソースパケットは、受信したソースパケットと修復パケットを使用して再構築できます。この仕様で定義されている非インターリーブパリティコードとインターリーブパリティコードは、複雑さを犠牲にして、それぞれランダムパケット損失とバーストパケット損失に対する優れた保護を提供します。このドキュメントで定義されているRTPペイロード形式は、以前の仕様で経験したスケーラビリティの問題に対処し、いくつかの改善を提供します。これらの変更により、新しいペイロード形式には以前の仕様との下位互換性がありません。ただし、この仕様を実装していないエンドポイントは、FEC修復パケットを単に無視するだけで機能します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8627.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8627で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Parity Codes  . . . . . . . . . . . . . . . . . . . . . .   4\n    1.1.1.  One-Dimensional (1-D) Non-interleaved (Row) FEC\n            Protection  . . . . . . . . . . . . . . . . . . . . .   5\n    1.1.2.  1-D Interleaved (Column) FEC Protection . . . . . . .   6\n    1.1.3.  Use Cases for 1-D FEC Protection  . . . . . . . . . .   7\n    1.1.4.  Two-Dimensional (2-D) (Row and Column) FEC Protection   8\n    1.1.5.  FEC Protection with Flexible Mask . . . . . . . . . .  10\n    1.1.6.  FEC Overhead Considerations . . . . . . . . . . . . .  10\n    1.1.7.  FEC Protection with Retransmission  . . . . . . . . .  10\n    1.1.8.  Repair Window Considerations  . . . . . . . . . . . .  11\n2.  Requirements Notation . . . . . . . . . . . . . . . . . . . .  11\n3.  Definitions and Notations . . . . . . . . . . . . . . . . . .  11\n  3.1.  Definitions . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.2.  Notations . . . . . . . . . . . . . . . . . . . . . . . .  12\n4.  Packet Formats  . . . . . . . . . . . . . . . . . . . . . . .  12\n  4.1.  Source Packets  . . . . . . . . . . . . . . . . . . . . .  12\n  4.2.  FEC Repair Packets  . . . . . . . . . . . . . . . . . . .  13\n    4.2.1.  RTP Header of FEC Repair Packets  . . . . . . . . . .  13\n    4.2.2.  FEC Header of FEC Repair Packets  . . . . . . . . . .  15\n5.  Payload Format Parameters . . . . . . . . . . . . . . . . . .  20\n  5.1.  Media Type Registration -- Parity Codes . . . . . . . . .  20\n    5.1.1.  Registration of audio/flexfec . . . . . . . . . . . .  21\n    5.1.2.  Registration of video/flexfec . . . . . . . . . . . .  22\n    5.1.3.  Registration of text/flexfec  . . . . . . . . . . . .  23\n    5.1.4.  Registration of application/flexfec . . . . . . . . .  24\n  5.2.  Mapping to SDP Parameters . . . . . . . . . . . . . . . .  25\n    5.2.1.  Offer/Answer Model Considerations . . . . . . . . . .  25\n    5.2.2.  Declarative Considerations  . . . . . . . . . . . . .  26",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.  Protection and Recovery Procedures -- Parity Codes  . . . . .  26\n  6.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  26\n  6.2.  Repair Packet Construction  . . . . . . . . . . . . . . .  26\n  6.3.  Source Packet Reconstruction  . . . . . . . . . . . . . .  28\n    6.3.1.  Associating the Source and Repair Packets . . . . . .  28\n    6.3.2.  Recovering the RTP Header . . . . . . . . . . . . . .  30\n    6.3.3.  Recovering the RTP Payload  . . . . . . . . . . . . .  31\n    6.3.4.  Iterative Decoding Algorithm for the 2-D Parity FEC\n            Protection  . . . . . . . . . . . . . . . . . . . . .  31\n7.  Signaling Requirements  . . . . . . . . . . . . . . . . . . .  34\n  7.1.  SDP Examples  . . . . . . . . . . . . . . . . . . . . . .  35\n    7.1.1.  Example SDP for Flexible FEC Protection with In-Band\n            SSRC Mapping  . . . . . . . . . . . . . . . . . . . .  35\n    7.1.2.  Example SDP for Flexible FEC Protection with Explicit\n            Signaling in the SDP  . . . . . . . . . . . . . . . .  35\n  7.2.  On the Use of the RTP Stream Identifier Source\n        Description . . . . . . . . . . . . . . . . . . . . . . .  36\n8.  Congestion Control Considerations . . . . . . . . . . . . . .  36\n9.  Security Considerations . . . . . . . . . . . . . . . . . . .  37\n10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  37\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  38\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  38\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  39\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  40\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  41",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines new RTP payload formats for the Forward Error Correction (FEC) that is generated by the non-interleaved and interleaved parity codes from a source media encapsulated in RTP [RFC3550]. The type of the source media protected by these parity codes can be audio, video, text, or application. The FEC data are generated according to the media type parameters, which are communicated out of band (e.g., in the Session Description Protocol (SDP)). Furthermore, the associations or relationships between the source and repair RTP streams may be communicated in or out of band. The in-band mechanism is advantageous when the endpoint is adapting the FEC parameters. The out-of-band mechanism may be preferable when the FEC parameters are fixed. While this document fully defines the use of FEC to protect RTP streams, it also leverages several definitions along with the basic source/repair header description from [RFC6363] in their application to the parity codes defined here.",
      "ja": "このドキュメントは、RTP [RFC3550]でカプセル化されたソースメディアからの非インターリーブおよびインターリーブパリティコードによって生成される前方誤り訂正（FEC）の新しいRTPペイロード形式を定義します。 これらのパリティコードで保護されているソースメディアの種類は、オーディオ、ビデオ、テキスト、またはアプリケーションです。 FECデータは、メディアタイプパラメータに従って生成されます。このパラメータは、帯域外で通信されます（たとえば、セッション記述プロトコル（SDP）で）。 さらに、ソースRTPストリームと修復RTPストリーム間の関連付けまたは関係は、帯域内または帯域外で通信できます。 インバンドメカニズムは、エンドポイントがFECパラメータを適応している場合に有利です。 FECパラメータが固定されている場合、帯域外メカニズムが望ましい場合があります。 このドキュメントはRTPストリームを保護するためのFECの使用を完全に定義しますが、ここで定義されたパリティコードへのアプリケーションの[RFC6363]からの基本的なソース/修復ヘッダーの説明とともにいくつかの定義も活用します。"
    },
    {
      "indent": 3,
      "text": "The Redundancy RTP Stream [RFC7656] repair packets proposed in this document protect the Source RTP Stream packets that belong to the same RTP session.",
      "ja": "このドキュメントで提案されている冗長RTPストリーム[RFC7656]修復パケットは、同じRTPセッションに属するソースRTPストリームパケットを保護します。"
    },
    {
      "indent": 3,
      "text": "The RTP payload formats that are defined in this document address the scalability issues experienced with the formats defined in earlier specifications including [RFC2733], [RFC5109], and [SMPTE2022-1].",
      "ja": "このドキュメントで定義されるRTPペイロード形式は、[RFC2733]、[RFC5109]、および[SMPTE2022-1]を含む以前の仕様で定義された形式で経験されるスケーラビリティの問題に対処します。"
    },
    {
      "indent": 0,
      "text": "1.1. Parity Codes",
      "section_title": true,
      "ja": "1.1. パリティコード"
    },
    {
      "indent": 3,
      "text": "Both the non-interleaved and interleaved parity codes use the eXclusive OR (XOR) operation to generate the repair packets. The following steps take place:",
      "ja": "インターリーブされていないパリティコードとインターリーブされたパリティコードはどちらも、排他的OR（XOR）操作を使用して修復パケットを生成します。 次の手順が実行されます。"
    },
    {
      "indent": 3,
      "text": "1. The sender determines a set of source packets to be protected by FEC based on the media type parameters.",
      "ja": "1. 送信者は、メディアタイプパラメータに基づいてFECによって保護されるソースパケットのセットを決定します。"
    },
    {
      "indent": 3,
      "text": "2. The sender applies the XOR operation on the source packets to generate the required number of repair packets.",
      "ja": "2. 送信者は、ソースパケットにXOR操作を適用して、必要な数の修復パケットを生成します。"
    },
    {
      "indent": 3,
      "text": "3. The sender sends the repair packet(s) along with the source packets, in different RTP streams, to the receiver(s). The repair packets may be sent proactively or on demand based on RTCP feedback messages such as NACK [RFC4585].",
      "ja": "3. 送信者は、異なるRTPストリームでソースパケットとともに修復パケットを受信者に送信します。 修復パケットは、事前に送信することも、NACK [RFC4585]などのRTCPフィードバックメッセージに基づいてオンデマンドで送信することもできます。"
    },
    {
      "indent": 3,
      "text": "At the receiver side, if all of the source packets are successfully received, there is no need for FEC recovery and the repair packets are discarded. However, if there are missing source packets, the repair packets can be used to recover the missing information. Figures 1 and 2 describe example block diagrams for the systematic parity FEC encoder and decoder, respectively.",
      "ja": "受信側では、すべてのソースパケットが正常に受信された場合、FEC回復の必要はなく、修復パケットは破棄されます。 ただし、ソースパケットが欠落している場合、修復パケットを使用して欠落情報を回復できます。 図1と図2は、それぞれシステマティックパリティFECエンコーダーとデコーダーのブロック図の例を示しています。"
    },
    {
      "indent": 3,
      "text": "                           +------------+\n+--+  +--+  +--+  +--+ --> | Systematic | --> +--+  +--+  +--+  +--+\n+--+  +--+  +--+  +--+     | Parity FEC |     +--+  +--+  +--+  +--+\n                           |  Encoder   |\n                           |  (Sender)  | --> +==+  +==+\n                           +------------+     +==+  +==+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Source Packet: +--+    Repair Packet: +==+\n               +--+                   +==+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 1: Block Diagram for Systematic Parity FEC Encoder",
      "ja": "図1：システマティックパリティFECエンコーダーのブロック図"
    },
    {
      "indent": 3,
      "text": "                           +------------+\n+--+    X    X    +--+ --> | Systematic | --> +--+  +--+  +--+  +--+\n+--+              +--+     | Parity FEC |     +--+  +--+  +--+  +--+\n                           |  Decoder   |\n            +==+  +==+ --> | (Receiver) |\n            +==+  +==+     +------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Source Packet: +--+    Repair Packet: +==+    Lost Packet: X\n               +--+                   +==+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 2: Block Diagram for Systematic Parity FEC Decoder",
      "ja": "図2：システマティックパリティFECデコーダーのブロック図"
    },
    {
      "indent": 3,
      "text": "In Figure 2, it is clear that the FEC repair packets have to be received by the endpoint within a certain amount of time for the FEC recovery process to be useful. The repair window is defined as the time that spans a FEC block, which consists of the source packets and the corresponding repair packets. At the receiver side, the FEC decoder SHOULD buffer source and repair packets at least for the duration of the repair window to allow all the repair packets to arrive. The FEC decoder can start decoding the already-received packets sooner; however, it should not register a FEC decoding failure until it waits at least for the duration of the repair window.",
      "ja": "図2においては、FECリペアパケットはFEC回復プロセスが有用であるために一定時間内のエンドポイントによって受信されなければならないことは明らかです。 修復時間は、ソースパケットと対応する修復パケットで構成されるFECブロックにまたがる時間として定義されます。受信側で、FECデコーダは、すべてのリペアパケットが到着することを可能にする修復ウィンドウの期間中少なくともソースおよびリペアパケットをバッファリングすべきです。 FECデコーダーは、すでに受信したパケットのデコードをより早く開始できます。 ただし、少なくとも修復時間の間待機するまで、FECデコード失敗を登録しないでください。"
    },
    {
      "indent": 0,
      "text": "1.1.1. One-Dimensional (1-D) Non-interleaved (Row) FEC Protection",
      "section_title": true,
      "ja": "1.1.1. 一次元（1-D）非インターリーブ（行）FEC保護"
    },
    {
      "indent": 3,
      "text": "Consider a group of D x L source packets that have Sequence Numbers starting from 1 running to D x L (where D and L are as defined in Section 3.2) and a repair packet is generated by applying the XOR operation to every L consecutive packets as sketched in Figure 3. This process is referred to as \"1-D non-interleaved FEC protection\". As a result of this process, D repair packets are generated, which are referred to as non-interleaved (or row) FEC repair packets. In general, D and L represent values that describe how packets are grouped together from a depth and length perspective (respectively) when interleaving all D x L source packets.",
      "ja": "1からD x Lまでのシーケンス番号（DおよびLはセクション3.2で定義されている）から始まるD x Lソースパケットのグループを考えます。修復パケットは、L個の連続するすべてのパケットにXOR演算を適用することで生成されます このプロセスは、「1-D非インターリーブFEC保護」と呼ばれます。 このプロセスの結果、D修復パケットが生成されます。これは、非インターリーブ（または行）FEC修復パケットと呼ばれます。 一般に、DとLは、すべてのD x Lソースパケットをインターリーブするときに、深さと長さの観点から（それぞれ）パケットをグループ化する方法を説明する値を表します。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------------------------+    ---    +===+\n| S_1          S_2          S3          ...  S_L   | + |XOR| = |R_1|\n+--------------------------------------------------+    ---    +===+\n+--------------------------------------------------+    ---    +===+\n| S_L+1        S_L+2        S_L+3       ...  S_2xL | + |XOR| = |R_2|\n+--------------------------------------------------+    ---    +===+\n  .            .            .                .           .       .\n  .            .            .                .           .       .\n  .            .            .                .           .       .\n+--------------------------------------------------+    ---    +===+\n| S_(D-1)xL+1  S_(D-1)xL+2  S_(D-1)xL+3 ...  S_DxL | + |XOR| = |R_D|\n+--------------------------------------------------+    ---    +===+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 3: Generating Non-interleaved (Row) FEC Repair Packets",
      "ja": "図3：非インターリーブ（行）FEC修復パケットの生成"
    },
    {
      "indent": 0,
      "text": "1.1.2. 1-D Interleaved (Column) FEC Protection",
      "section_title": true,
      "ja": "1.1.2. 1次元インターリーブ（列）FEC保護"
    },
    {
      "indent": 3,
      "text": "Consider the case where the XOR operation is applied to the group of the source packets whose Sequence Numbers are L apart from each other, as sketched in Figure 4. In this case, the endpoint generates L repair packets. This process is referred to as \"1-D interleaved FEC protection\", and the resulting L repair packets are referred to as \"interleaved (or column) FEC repair packets\".",
      "ja": "図4に示すように、シーケンス番号が互いにL離れているソースパケットのグループにXOR操作が適用される場合を考えます。この場合、エンドポイントはL修復パケットを生成します。 このプロセスは「1-DインターリーブFEC保護」と呼ばれ、結果のL修復パケットは「インターリーブ（または列）FEC修復パケット」と呼ばれます。"
    },
    {
      "indent": 7,
      "text": "+-------------+ +-------------+ +-------------+     +-------+\n| S_1         | | S_2         | | S3          | ... | S_L   |\n| S_L+1       | | S_L+2       | | S_L+3       | ... | S_2xL |\n| .           | | .           | |             |     |       |\n| .           | | .           | |             |     |       |\n| .           | | .           | |             |     |       |\n| S_(D-1)xL+1 | | S_(D-1)xL+2 | | S_(D-1)xL+3 | ... | S_DxL |\n+-------------+ +-------------+ +-------------+     +-------+\n       +               +               +                +\n -------------   -------------   -------------       -------\n|     XOR     | |     XOR     | |     XOR     | ... |  XOR  |\n -------------   -------------   -------------       -------\n       =               =               =                =\n     +===+           +===+           +===+            +===+\n     |C_1|           |C_2|           |C_3|      ...   |C_L|\n     +===+           +===+           +===+            +===+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 4: Generating Interleaved (Column) FEC Repair Packets",
      "ja": "図4：インターリーブ（列）FEC修復パケットの生成"
    },
    {
      "indent": 0,
      "text": "1.1.3. Use Cases for 1-D FEC Protection",
      "section_title": true,
      "ja": "1.1.3. 1-D FEC保護の使用例"
    },
    {
      "indent": 3,
      "text": "A sender may generate one non-interleaved repair packet out of L consecutive source packets or one interleaved repair packet out of D nonconsecutive source packets. Regardless of whether the repair packet is a non-interleaved or an interleaved one, it can provide a full recovery of the missing information if there is only one packet missing among the corresponding source packets. This implies that 1-D non-interleaved FEC protection performs better when the source packets are randomly lost. However, if the packet losses occur in bursts, 1-D interleaved FEC protection performs better provided that L is chosen to be large enough, i.e., L-packet duration is not shorter than the observed burst duration. If the sender generates non-interleaved FEC repair packets and a burst loss hits the source packets, the repair operation fails. This is illustrated in Figure 5.",
      "ja": "送信者は、L個の連続したソースパケットから1つの非インターリーブ修復パケットを生成するか、D個の非連続ソースパケットから1つのインターリーブ修復パケットを生成できます。 修復パケットがインターリーブされていないかインターリーブされているかに関係なく、対応するソースパケットの中で欠落しているパケットが1つしかない場合、欠落している情報を完全に回復できます。 これは、ソースパケットがランダムに失われた場合、1-D非インターリーブFEC保護のパフォーマンスが向上することを意味します。 ただし、パケット損失がバーストで発生する場合、Lが十分に大きくなるように選択されている場合、つまり、Lパケットの持続時間が観測されたバースト持続時間より短くない場合、1-DインターリーブFEC保護のパフォーマンスが向上します。 送信者がインターリーブされていないFEC修復パケットを生成し、バースト損失がソースパケットにヒットした場合、修復操作は失敗します。 これを図5に示します。"
    },
    {
      "indent": 21,
      "text": "+---+                +---+  +===+\n| 1 |    X      X    | 4 |  |R_1|\n+---+                +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 9 |  | 10|  | 11|  | 12|  |R_3|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Figure 5: Example Scenario: 1-D Non-interleaved FEC Protection Fails Error Recovery (Burst Loss)",
      "ja": "図5：シナリオ例：1-DノンインターリーブFEC保護がエラー回復に失敗する（バーストロス）"
    },
    {
      "indent": 3,
      "text": "The sender may generate interleaved FEC repair packets to combat the bursty packet losses. However, two or more random packet losses may hit the source and repair packets in the same column. In that case, the repair operation fails as well. This is illustrated in Figure 6. Note that it is possible that two burst losses occur back-to-back, in which case, interleaved FEC repair packets may still fail to recover the lost data.",
      "ja": "送信者は、インターリーブされたFEC修復パケットを生成して、バースト性のパケット損失と戦うことができます。 ただし、2つ以上のランダムなパケット損失がソースにヒットし、同じ列のパケットを修復する場合があります。 その場合、修復操作も失敗します。 これを図6に示します。2つのバースト損失が連続して発生する可能性があることに注意してください。その場合、インターリーブされたFEC修復パケットは失われたデータの回復に失敗する可能性があります。"
    },
    {
      "indent": 24,
      "text": "+---+         +---+  +---+\n| 1 |    X    | 3 |  | 4 |\n+---+         +---+  +---+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "+---+         +---+  +---+\n| 5 |    X    | 7 |  | 8 |\n+---+         +---+  +---+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "+---+  +---+  +---+  +---+\n| 9 |  | 10|  | 11|  | 12|\n+---+  +---+  +---+  +---+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 4,
      "text": " Figure 6: Example Scenario: 1-D Interleaved FEC Protection Fails Error Recovery (Periodic Loss)",
      "ja": "図6：シナリオの例：1次元インターリーブFEC保護がエラー回復に失敗する（定期的な損失）"
    },
    {
      "indent": 0,
      "text": "1.1.4. Two-Dimensional (2-D) (Row and Column) FEC Protection",
      "section_title": true,
      "ja": "1.1.4. 2次元（2-D）（行および列）FEC保護"
    },
    {
      "indent": 3,
      "text": "In networks where the source packets are lost both randomly and in bursts, the sender ought to generate both non-interleaved and interleaved FEC repair packets. This type of FEC protection is known as \"2-D parity FEC protection\". At the expense of generating more FEC repair packets, thus increasing the FEC overhead, 2-D FEC provides superior protection against mixed loss patterns. However, it is still possible for 2-D parity FEC protection to fail to recover all of the lost source packets if a particular loss pattern occurs. An example scenario is illustrated in Figure 7.",
      "ja": "ソースパケットがランダムとバーストの両方で失われるネットワークでは、送信者は、インターリーブされていないFEC修復パケットとインターリーブされたFEC修復パケットの両方を生成する必要があります。 このタイプのFEC保護は、「2-DパリティFEC保護」として知られています。 より多くのFEC修復パケットを生成し、FECオーバーヘッドを増やすことを犠牲にして、2-D FECは混合損失パターンに対する優れた保護を提供します。 ただし、特定の損失パターンが発生した場合、2DパリティFEC保護がすべての失われたソースパケットの回復に失敗する可能性があります。 シナリオの例を図7に示します。"
    },
    {
      "indent": 21,
      "text": "+---+                +---+  +===+\n| 1 |    X      X    | 4 |  |R_1|\n+---+                +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+                +---+  +===+\n| 9 |    X      X    | 12|  |R_3|\n+---+                +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 14,
      "text": " Figure 7: Example Scenario #1: 2-D Parity FEC Protection Fails Error Recovery",
      "ja": "図7：シナリオ例1：2次元パリティFEC保護がエラー回復に失敗する"
    },
    {
      "indent": 3,
      "text": "2-D parity FEC protection also fails when at least two rows are missing a source and the FEC packet and the missing source packets (in at least two rows) are aligned in the same column. An example loss pattern is sketched in Figure 8. Similarly, 2-D parity FEC protection cannot repair all missing source packets when at least two columns are missing a source and the FEC packet and the missing source packets (in at least two columns) are aligned in the same row.",
      "ja": "2DパリティFEC保護は、少なくとも2行でソースが欠落しており、FECパケットと欠落しているソースパケット（少なくとも2行）が同じ列に並んでいる場合にも失敗します。 損失パターンの例を図8に示します。同様に、2次元パリティFEC保護では、少なくとも2列でソースが欠落し、FECパケットおよび欠落ソースパケット（少なくとも2列）が欠落している場合、すべての欠落ソースパケットを修復できません 同じ行に配置されます。"
    },
    {
      "indent": 21,
      "text": "+---+  +---+         +---+\n| 1 |  | 2 |    X    | 4 |    X\n+---+  +---+         +---+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+         +---+\n| 9 |  | 10|    X    | 12|    X\n+---+  +---+         +---+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 14,
      "text": " Figure 8: Example Scenario #2: 2-D Parity FEC Protection Fails Error Recovery",
      "ja": "図8：シナリオ例2：2DパリティFEC保護がエラー回復に失敗する"
    },
    {
      "indent": 0,
      "text": "1.1.5. FEC Protection with Flexible Mask",
      "section_title": true,
      "ja": "1.1.5. フレキシブルマスクによるFEC保護"
    },
    {
      "indent": 3,
      "text": "It is possible to define FEC protection for selected packets in the source stream. This would enable differential protection, i.e., application of FEC selectively to packets that require a higher level of reliability than the other packets in the source stream. The sender will be required to send a bitmap indicating the packets to be protected, i.e., a \"mask\", to the receiver. Since the mask can be modified during an RTP session (\"flexible mask\"), this kind of FEC protection can also be used to implement FEC dynamically (e.g., for adaptation to different types of traffic during the RTP session).",
      "ja": "ソースストリーム内の選択されたパケットに対してFEC保護を定義することができます。 これにより、差分保護、つまり、ソースストリーム内の他のパケットよりも高いレベルの信頼性が必要なパケットに選択的にFECを適用できます。 送信者は、保護するパケットを示すビットマップ、つまり「マスク」を受信者に送信する必要があります。 マスクはRTPセッション中に変更できるため（「フレキシブルマスク」）、この種類のFEC保護は、FECを動的に実装するためにも使用できます（RTPセッション中のさまざまなタイプのトラフィックへの適応など）。"
    },
    {
      "indent": 0,
      "text": "1.1.6. FEC Overhead Considerations",
      "section_title": true,
      "ja": "1.1.6. FECオーバーヘッドの考慮事項"
    },
    {
      "indent": 3,
      "text": "The overhead is defined as the ratio of the number of bytes belonging to the repair packets to the number of bytes belonging to the protected source packets.",
      "ja": "オーバーヘッドは、保護されたソースパケットに属するバイト数に対する修復パケットに属するバイト数の比率として定義されます。"
    },
    {
      "indent": 3,
      "text": "Generally, repair packets are larger in size than the source packets. Also, not all the source packets are necessarily equal in size. However, assuming that each repair packet carries an equal number of bytes as carried by a source packet, the overhead for different FEC protection methods can be computed as follows:",
      "ja": "一般に、修復パケットはソースパケットよりもサイズが大きくなります。 また、すべてのソースパケットのサイズが必ずしも等しいとは限りません。 ただし、各修復パケットがソースパケットによって運ばれるのと同じバイト数を運ぶと仮定すると、異なるFEC保護方法のオーバーヘッドは次のように計算できます。"
    },
    {
      "indent": 6,
      "text": "1-D Non-interleaved FEC Protection: Overhead = 1/L",
      "raw": true
    },
    {
      "indent": 6,
      "text": "1-D Interleaved FEC Protection: Overhead = 1/D",
      "raw": true
    },
    {
      "indent": 6,
      "text": "2-D Parity FEC Protection: Overhead = 1/L + 1/D",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where L and D are the number of columns and rows in the source block, respectively.",
      "ja": "ここで、LとDは、それぞれソースブロックの列と行の数です。"
    },
    {
      "indent": 0,
      "text": "1.1.7. FEC Protection with Retransmission",
      "section_title": true,
      "ja": "1.1.7. 再送信によるFEC保護"
    },
    {
      "indent": 3,
      "text": "This specification supports both forward error correction, i.e., before any loss is reported, as well as retransmission of source packets after the loss is reported. The retransmission includes the RTP header of the source packet in addition to the payload. If a peer supporting both FLEX FEC and other RTP retransmission methods (see [RFC4588]) receives an Offer including both FLEX FEC and another RTP retransmission method, it MUST respond with an Answer containing only FLEX FEC.",
      "ja": "この仕様は、損失が報告される前の、すなわち損失が報告された後のソースパケットの再送信と同様に、前方誤り訂正の両方をサポートします。 再送信には、ペイロードに加えてソースパケットのRTPヘッダーが含まれます。 FLEX FECと他のRTP再送信方法の両方をサポートするピア（[RFC4588]を参照）がFLEX FECと別のRTP再送信方法の両方を含むオファーを受信する場合、FLEX FECのみを含むアンサーで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "1.1.8. Repair Window Considerations",
      "section_title": true,
      "ja": "1.1.8. 修復ウィンドウの考慮事項"
    },
    {
      "indent": 3,
      "text": "The value for the repair window duration is related to the maximum L and D values that are expected during a FLEX FEC session; therefore, it cannot be chosen arbitrarily. Repair packets that include L and D values larger than the repair window MUST NOT be sent. The rate of the source streams should also be considered, as the repair window duration should ideally span several packetization intervals in order to leverage the error correction capabilities of the parity code.",
      "ja": "修復時間の値は、FLEX FECセッション中に予想される最大のL値とD値に関連しています。 したがって、任意に選択することはできません。 修復ウィンドウよりも大きいL値とD値を含む修復パケットは送信しないでください。 パリティコードのエラー訂正機能を活用するには、修復ウィンドウの期間が複数のパケット化間隔に及ぶことが理想的であるため、ソースストリームのレートも考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because the FEC configuration can change with each repair packet (see Section 4.2.2), for any given repair packet, the FLEX FEC receiver MUST support all possible L and D combinations (both 1-D and 2-D interleaved over all source flows) and all flexible mask configurations (over all source flows) within the repair window to which it has agreed (e.g., through SDP or out-of-band signaling) for a FLEX FEC RTP session. In addition, the FLEX FEC receiver MUST support receipt of a retransmission of any source flow packet within the repair window to which it has agreed.",
      "ja": "FEC構成は各修復パケット（セクション4.2.2を参照）で変更できるため、特定の修復パケットについて、FLEX FEC受信機はすべての可能なLとDの組み合わせをサポートしなければなりません（すべてのソースフローで1-Dと2-Dの両方がインターリーブされます） ）およびFLEX FEC RTPセッションの（たとえば、SDPまたは帯域外シグナリングを介して）合意した修復ウィンドウ内の（すべてのソースフローに対する）すべての柔軟なマスク構成。 さらに、FLEX FEC受信機は、合意した修復ウィンドウ内でのソースフローパケットの再送信の受信をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Notation",
      "section_title": true,
      "ja": "2. 要件の表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Definitions and Notations",
      "section_title": true,
      "ja": "3. 定義と表記"
    },
    {
      "indent": 0,
      "text": "3.1. Definitions",
      "section_title": true,
      "ja": "3.1. 定義"
    },
    {
      "indent": 3,
      "text": "This document uses a number of definitions from [RFC6363]. Additionally, it defines the following and/or updates their definitions from [RFC6363].",
      "ja": "このドキュメントは、[RFC6363]からの多くの定義を使用します。 さらに、以下を定義するか、[RFC6363]から定義を更新します。"
    },
    {
      "indent": 3,
      "text": "1-D Non-interleaved Row FEC: A protection scheme that operates on consecutive source packets in the source block, able to recover a single lost source packet per row of the source block.",
      "ja": "1-D非インターリーブ行FEC：ソースブロック内の連続するソースパケットで動作する保護スキーム。ソースブロックの行ごとに1つの失われたソースパケットを回復できます。"
    },
    {
      "indent": 3,
      "text": "1-D Interleaved Column FEC: A protection scheme that operates on interleaved source packets in the source block, able to recover a single lost source packet per column of the source block.",
      "ja": "1Dインターリーブ列FEC：ソースブロック内のインターリーブされたソースパケットで動作する保護スキーム。ソースブロックの列ごとに1つの失われたソースパケットを回復できます。"
    },
    {
      "indent": 3,
      "text": "2-D FEC: A protection scheme that combines row and column FEC.",
      "ja": "2-D FEC：行と列のFECを組み合わせた保護スキーム。"
    },
    {
      "indent": 3,
      "text": "Source Block: A set of source packets that are protected by a set of 1-D or 2-D FEC repair packets.",
      "ja": "ソースブロック：1次元または2次元のFEC修復パケットのセットによって保護されているソースパケットのセット。"
    },
    {
      "indent": 3,
      "text": "FEC Block: A source block and its corresponding FEC repair packets.",
      "ja": "FECブロック：ソースブロックとそれに対応するFEC修復パケット。"
    },
    {
      "indent": 3,
      "text": "Repair Window: The time that spans a FEC block, which consists of the source packets and the corresponding FEC repair packets.",
      "ja": "修復ウィンドウ：ソースパケットと対応するFEC修復パケットで構成されるFECブロックにまたがる時間。"
    },
    {
      "indent": 3,
      "text": "XOR Parity Codes: A FEC code that uses the eXclusive OR (XOR) parity operation to encode a set of source packets to form a FEC repair packet.",
      "ja": "XORパリティコード：eXclusive OR（XOR）パリティ演算を使用してソースパケットのセットをエンコードし、FEC修復パケットを形成するFECコード。"
    },
    {
      "indent": 0,
      "text": "3.2. Notations",
      "section_title": true,
      "ja": "3.2. 表記法"
    },
    {
      "indent": 3,
      "text": "L: Number of columns of the source block (length of each row).",
      "ja": "L：ソースブロックの列数（各行の長さ）。"
    },
    {
      "indent": 3,
      "text": "D: Number of rows of the source block (depth of each column).",
      "ja": "D：ソースブロックの行数（各列の深さ）。"
    },
    {
      "indent": 3,
      "text": "bitmask: A 15-bit, 46-bit, or 110-bit mask indicating which source packets are protected by a FEC repair packet. If the bit i in the mask is set to 1, the source packet number N + i is protected by this FEC repair packet, where N is the Sequence Number base indicated in the FEC repair packet. The most significant bit of the mask corresponds to i=0. The least significant bit of the mask corresponds to i=14 in the 15-bit mask, i=45 in the 46-bit mask, or i=109 in the 110-bit mask.",
      "ja": "ビットマスク：FEC修復パケットによって保護されているソースパケットを示す15ビット、46ビット、または110ビットのマスク。 マスクのビットiが1に設定されている場合、ソースパケット番号N + iはこのFEC修復パケットによって保護されます。ここで、NはFEC修復パケットで示されるシーケンス番号ベースです。 マスクの最上位ビットはi = 0に対応します。 マスクの最下位ビットは、15ビットマスクではi = 14、46ビットマスクではi = 45、110ビットマスクではi = 109に対応します。"
    },
    {
      "indent": 0,
      "text": "4. Packet Formats",
      "section_title": true,
      "ja": "4. パケット形式"
    },
    {
      "indent": 3,
      "text": "This section describes the formats of the source packets and defines the formats of the FEC repair packets.",
      "ja": "このセクションでは、ソースパケットの形式について説明し、FEC修復パケットの形式を定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. Source Packets",
      "section_title": true,
      "ja": "4.1. 送信元パケット"
    },
    {
      "indent": 3,
      "text": "The source packets contain the information that identifies the source block and the position within the source block occupied by the packet. Since the source packets that are carried within an RTP stream already contain unique Sequence Numbers in their RTP headers [RFC3550], the source packets can be identified in a straightforward manner and there is no need to append any additional fields. The primary advantage of not modifying the source packets in any way is that it provides backward compatibility for the receivers that do not support FEC at all. In multicast scenarios, this backward compatibility becomes quite useful as it allows the non-FEC-capable and FEC-capable receivers to receive and interpret the same source packets sent in the same multicast session.",
      "ja": "ソースパケットには、ソースブロックと、パケットが占めるソースブロック内の位置を識別する情報が含まれています。 RTPストリーム内で運ばれるソースパケットは既にRTPヘッダー[RFC3550]に一意のシーケンス番号を含んでいるので、ソースパケットは簡単な方法で識別でき、追加フィールドを追加する必要はありません。 ソースパケットを一切変更しないことの主な利点は、FECをまったくサポートしないレシーバーに対して下位互換性を提供することです。 マルチキャストシナリオでは、この下位互換性により、FEC非対応およびFEC対応の受信者が同じマルチキャストセッションで送信された同じソースパケットを受信および解釈できるため、非常に役立ちます。"
    },
    {
      "indent": 3,
      "text": "The source packets are transmitted as usual without altering them. They are used along with the FEC repair packets to recover any missing source packets, making this scheme a systematic code.",
      "ja": "ソースパケットは、変更せずに通常どおり送信されます。 これらは、FEC修復パケットとともに使用されて、欠落しているソースパケットを回復し、このスキームを体系的なコードにします。"
    },
    {
      "indent": 3,
      "text": "The source packets are full RTP packets with optional contributing source (CSRC) list, RTP header extension, and padding. If any of these optional elements are present in the source RTP packet, and that source packet is lost, they are recovered by the FEC repair operation, which recovers the full source RTP packet including these optional elements.",
      "ja": "ソースパケットは、オプションのコントリビューティングソース（CSRC）リスト、RTPヘッダー拡張、およびパディングを備えた完全なRTPパケットです。 これらのオプション要素のいずれかがソースRTPパケットに存在し、そのソースパケットが失われた場合、これらのオプション要素を含む完全なソースRTPパケットを回復するFEC修復操作によって回復されます。"
    },
    {
      "indent": 0,
      "text": "4.2. FEC Repair Packets",
      "section_title": true,
      "ja": "4.2. FEC修理パケット"
    },
    {
      "indent": 3,
      "text": "The FEC repair packets will contain information that identifies the source block they pertain to and the relationship between the contained repair packets and the original source block. For this purpose, the RTP header of the repair packets is used, as well as another header within the RTP payload, called the \"FEC header\", as shown in Figure 9.",
      "ja": "FEC修復パケットには、関連するソースブロックと、含まれる修復パケットと元のソースブロックの関係を識別する情報が含まれます。 この目的のために、図9に示すように、「FECヘッダー」と呼ばれるRTPペイロード内の別のヘッダーと同様に、修復パケットのRTPヘッダーが使用されます。"
    },
    {
      "indent": 3,
      "text": "Note that all the source stream packets that are protected by a particular FEC packet need to be in the same RTP session.",
      "ja": "特定のFECパケットが必要で保護されているすべてのソースストリームのパケットが同じRTPセッションになるようにすることに注意してください。"
    },
    {
      "indent": 13,
      "text": "+------------------------------+\n|          IP Header           |\n+------------------------------+\n|       Transport Header       |\n+------------------------------+\n|          RTP Header          |\n+------------------------------+ ---+\n|          FEC Header          |    |\n+------------------------------+    | RTP Payload\n|         Repair Payload       |    |\n+------------------------------+ ---+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 9: Format of FEC Repair Packets",
      "ja": "図9：FEC修復パケットの形式"
    },
    {
      "indent": 3,
      "text": "The Repair Payload, which follows the FEC header, includes repair of everything following the fixed 12-byte RTP header of each source packet, including any CSRC identifier list and header extensions if present.",
      "ja": "FECヘッダーに続く修復ペイロードには、各ソースパケットの固定12バイトRTPヘッダーに続くすべての修復が含まれます。CSRC識別子リストとヘッダー拡張（存在する場合）が含まれます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. RTP Header of FEC Repair Packets",
      "section_title": true,
      "ja": "4.2.1. FEC修復パケットのRTPヘッダー"
    },
    {
      "indent": 3,
      "text": "The RTP header is formatted according to [RFC3550] with some further clarifications listed below:",
      "ja": "RTPヘッダーは、[RFC3550]に従ってフォーマットされており、さらにいくつかの明確化が以下にリストされています。"
    },
    {
      "indent": 3,
      "text": "Version (V) 2 bits: This MUST be set to 2 (binary 10), as this specification requires all source RTP packets and all FEC repair packets to use RTP version 2.",
      "ja": "バージョン（V）2ビット：この仕様では、すべてのソースRTPパケットとすべてのFEC修復パケットがRTPバージョン2を使用する必要があるため、2（バイナリ10）に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Padding (P) bit: Source packets can have optional RTP padding, which can be recovered. FEC repair packets can have optional RTP padding, which is independent of the RTP padding of the source packets.",
      "ja": "パディング（P）ビット：ソースパケットには、回復可能なオプションのRTPパディングを含めることができます。 FEC修復パケットには、オプションのRTPパディングを含めることができます。これは、ソースパケットのRTPパディングとは無関係です。"
    },
    {
      "indent": 3,
      "text": "Extension (X) bit: Source packets can have optional RTP header extensions, which can be recovered. FEC repair packets can have optional RTP header extensions, which are independent of the RTP header extensions of the source packets.",
      "ja": "拡張（X）ビット：ソースパケットには、回復可能なオプションのRTPヘッダー拡張を含めることができます。 FEC修復パケットには、オプションのRTPヘッダー拡張を含めることができます。これは、ソースパケットのRTPヘッダー拡張とは無関係です。"
    },
    {
      "indent": 3,
      "text": "CSRC Count (CC) 4 bits, and CSRC List (CSRC_i) 32 bits each: Source packets can have an optional CSRC list and count, which can be recovered. FEC repair packets MUST use the CSRC list and count to specify the synchronization sources (SSRCs) of the source RTP stream(s) protected by this FEC repair packet.",
      "ja": "CSRCカウント（CC）4ビット、およびCSRCリスト（CSRC_i）各32ビット：ソースパケットにはオプションのCSRCリストとカウントを含めることができ、これらは回復可能です。 FEC修復パケットはCSRCリストとカウントを使用して、このFEC修復パケットによって保護されているソースRTPストリームの同期ソース（SSRC）を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Marker (M) bit: This bit is not used for this payload type, SHALL be set to 0 by senders, and SHALL be ignored by receivers.",
      "ja": "マーカー（M）ビット：このビットはこのペイロードタイプには使用されません。送信者は0に設定し、受信者はSHALLを無視します。"
    },
    {
      "indent": 3,
      "text": "Payload Type: The (dynamic) payload type for the FEC repair packets is determined through out-of-band means (e.g., SDP). Note that this document registers new payload formats for the repair packets (refer to Section 5 for details). According to [RFC3550], an RTP receiver that cannot recognize a payload type must discard it. This provides backward compatibility. If a non-FEC-capable receiver receives a repair packet, it will not recognize the payload type; hence, it will discard the repair packet.",
      "ja": "ペイロードタイプ：FEC修復パケットの（動的）ペイロードタイプは、帯域外手段（SDPなど）によって決定されます。 このドキュメントでは、修復パケットの新しいペイロード形式が登録されていることに注意してください（詳細についてはセクション5を参照）。 [RFC3550]によれば、ペイロードタイプを認識できないRTP受信機はそれを破棄する必要があります。 これにより、下位互換性が提供されます。 FEC非対応の受信機が修復パケットを受信した場合、ペイロードタイプは認識されません。 したがって、修復パケットは破棄されます。"
    },
    {
      "indent": 3,
      "text": "Sequence Number (SN): The Sequence Number follows the standard definition provided in [RFC3550]. Therefore, it must be one higher than the Sequence Number in the previously transmitted repair packet, and the initial value of the Sequence Number should be random (i.e., unpredictable).",
      "ja": "シーケンス番号（SN）：シーケンス番号は、[RFC3550]で提供される標準定義に従います。 したがって、以前に送信された修復パケットのシーケンス番号よりも1つ大きくなければならず、シーケンス番号の初期値はランダム（つまり、予測不能）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Timestamp (TS): The timestamp SHALL be set to a time corresponding to the repair packet's transmission time. Note that the timestamp value has no use in the actual FEC protection process and is usually useful for jitter calculations.",
      "ja": "タイムスタンプ（TS）：タイムスタンプは、修復パケットの送信時間に対応する時間に設定する必要があります。 タイムスタンプ値は実際のFEC保護プロセスでは使用されず、通常はジッタ計算に役立つことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Synchronization Source (SSRC): The SSRC value for each repair stream SHALL be randomly assigned as per the guidelines provided in Section 8 of [RFC3550]. This allows the sender to multiplex the source and repair RTP streams in the same RTP session, or multiplex multiple repair streams in an RTP session. The repair stream's SSRC's CNAME SHOULD be identical to the CNAME of the source RTP stream(s) that this repair stream protects. A FEC stream that protects multiple source RTP streams with different CNAME's uses the CNAME associated with the entity generating the FEC stream or the CNAME of the entity on whose behalf it performs the protection operation. In cases when the repair stream covers packets from multiple source RTP streams with different CNAME values and none of these CNAME values can be associated with the entity generating the FEC stream, any of these CNAME values MAY be used.",
      "ja": "同期ソース（SSRC）：各リペアストリームのためのSSRC値はランダムに[RFC3550]のセクション8に設けられたガイドラインに従って割り当てられます。これは、送信者がソースを多重化することを可能にし、修復RTPは、RTPセッションにおいて同じRTPセッション、またはマルチプレックス複数修復ストリームにストリーム。修理の流れのSSRCのCNAMEは、この修理・ストリームが保護することをソースRTPストリーム（複数可）のCNAMEと同一である必要があります。 異なるCNAMEを持つ複数のソースRTPストリームを保護するFECストリームは、FECストリームを生成するエンティティに関連付けられたCNAMEまたは保護操作を実行するエンティティのCNAMEを使用します。 修復ストリームが異なるCNAME値を持つ複数のソースRTPストリームからのパケットをカバーし、これらのCNAME値のいずれもFECストリームを生成するエンティティに関連付けることができない場合、これらのCNAME値のいずれかを使用できます。"
    },
    {
      "indent": 6,
      "text": "In some networks, the RTP Source, which produces the source packets, and the FEC Source, which generates the repair packets from the source packets, may not be the same host. In such scenarios, using the same CNAME for the source and repair RTP streams means that the RTP Source and the FEC Source will share the same CNAME (for this specific source-repair stream association). A common CNAME may be produced based on an algorithm that is known both to the RTP and FEC Source [RFC7022]. This usage is compliant with [RFC3550].",
      "ja": "一部のネットワークでは、ソースパケットを生成するRTPソースと、ソースパケットから修復パケットを生成するFECソースが同じホストではない場合があります。 このようなシナリオでは、ソースおよび修復RTPストリームに同じCNAMEを使用することは、RTPソースとFECソースが同じCNAMEを共有することを意味します（この特定のソース修復ストリームの関連付け）。 共通のCNAMEは、RTPとFECソース[RFC7022]の両方に知られているアルゴリズムに基づいて生成されます。 この使用法は[RFC3550]に準拠しています。"
    },
    {
      "indent": 6,
      "text": "Note that due to the randomness of the SSRC assignments, there is a possibility of SSRC collision. In such cases, the collisions must be resolved as described in [RFC3550].",
      "ja": "SSRC割り当てのランダム性により、SSRC衝突の可能性があることに注意してください。 そのような場合、[RFC3550]で説明されているように衝突を解決する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. FEC Header of FEC Repair Packets",
      "section_title": true,
      "ja": "4.2.2. FEC修復パケットのFECヘッダー"
    },
    {
      "indent": 3,
      "text": "The format of the FEC header has three variants, depending on the values in the first two bits (R and F bits) as shown in Figure 10. Note that R and F stand for \"retransmit\" and \"fixed block\", respectively. Two of these variants are meant to describe different methods for deriving the source data from a source packet for a repair packet. This allows for customizing the FEC method to allow for robustness against different levels of burst errors and random packet losses. The third variant is for a straight retransmission of the source packet.",
      "ja": "図10に示すように、FECヘッダーの形式には、最初の2ビット（RおよびFビット）の値に応じて3つのバリアントがあります。RおよびFはそれぞれ「再送信」および「固定ブロック」を表します。 これらのバリアントのうち2つは、修復パケットのソースパケットからソースデータを取得するさまざまな方法を説明することを目的としています。 これにより、FECメソッドをカスタマイズして、さまざまなレベルのバーストエラーやランダムなパケット損失に対する堅牢性を実現できます。 3番目のバリアントは、ソースパケットの直接再送信用です。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|R|F|P|X|  CC   |M| PT recovery | ...varies depending on R/F... |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 ...varies depending on R/F...                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                Repair Payload follows FEC header              :\n:                                                               :",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 10: FEC header",
      "ja": "図10：FECヘッダー"
    },
    {
      "indent": 3,
      "text": "The Repair Payload, which follows the FEC header, includes repair of everything following the fixed 12-byte RTP header of each source packet, including any CSRC identifier list and header extensions if present. An overview on how the Repair Payload can be used to recover source packets is provided in Section 6.",
      "ja": "FECヘッダーに続く修復ペイロードには、各ソースパケットの固定12バイトRTPヘッダーに続くすべての修復が含まれます。CSRC識別子リストとヘッダー拡張（存在する場合）が含まれます。 ソースパケットを回復するために修復ペイロードを使用する方法の概要は、セクション6で提供されます。"
    },
    {
      "indent": 6,
      "text": "+---+---+-----------------------------------------------------+\n| R | F | FEC header variant                                  |\n+---+---+-----------------------------------------------------+\n| 0 | 0 | Flexible FEC Mask fields indicate source packets    |\n| 0 | 1 | Fixed FEC L/D (cols/rows) indicate source packets   |\n| 1 | 0 | Retransmission of a single source packet            |\n| 1 | 1 | Reserved for future use, MUST NOT send, MUST ignore |\n+---+---+-----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 11: R and F Bit Values for FEC Header Variants",
      "ja": "図11：FECヘッダーバリアントのRおよびFビット値"
    },
    {
      "indent": 3,
      "text": "The first variant, when R=0 and F=0, has a mask to signal protected source packets, as shown in Figure 12.",
      "ja": "図12に示すように、R = 0およびF = 0の場合の最初のバリアントには、保護されたソースパケットを通知するマスクがあります。"
    },
    {
      "indent": 3,
      "text": "The second variant, when R=0 and F=1, has a number of columns (L) and rows (D) to signal protected source packets, as shown in Figure 13.",
      "ja": "図13に示すように、R = 0およびF = 1の場合の2番目のバリアントには、保護されたソースパケットを通知するための列（L）と行（D）があります。"
    },
    {
      "indent": 3,
      "text": "The final variant, when R=1 and F=0, is a retransmission format as shown in Figure 15.",
      "ja": "R = 1およびF = 0の場合の最終的なバリアントは、図15に示すような再送信フォーマットです。"
    },
    {
      "indent": 3,
      "text": "No variant presently uses R=1 and F=1, which is reserved for future use. Current FLEX FEC implementations MUST NOT send packets with this variant, and receivers MUST ignore these packets. Future FLEX FEC implementations may use this by updating the media type registration.",
      "ja": "現在、R = 1とF = 1を使用しているバリアントはありません。これは将来の使用のために予約されています。 現在のFLEX FEC実装は、このバリアントを持つパケットを送信してはならず、受信者はこれらのパケットを無視しなければなりません。 将来のFLEX FEC実装では、メディアタイプ登録を更新することでこれを使用する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The FEC header for all variants consists of the following common fields:",
      "ja": "すべてのバリアントのFECヘッダーは、次の共通フィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "o The R bit MUST be set to 1 to indicate a retransmission packet, and MUST be set to 0 for FEC repair packets.",
      "ja": "o 再送信パケットを示すためにRビットを1に設定しなければならず、FEC修復パケットの場合は0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The F bit indicates the type of FEC repair packets, as shown in Figure 11, when the R bit is 0. The F bit MUST be set to 0 when the R bit is 1 for retransmission packets.",
      "ja": "o 図11に示すように、Rビットが0の場合、FビットはFEC修復パケットのタイプを示します。再送パケットのRビットが1の場合、Fビットは0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The P, X, CC, M, and PT recovery fields are used to determine the corresponding fields of the recovered packets (see also Section 6.3.2).",
      "ja": "o P、X、CC、M、およびPT回復フィールドは、回復されたパケットの対応するフィールドを決定するために使用されます（セクション6.3.2も参照）。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. FEC Header with Flexible Mask",
      "section_title": true,
      "ja": "4.2.2.1. フレキシブルマスク付きFECヘッダー"
    },
    {
      "indent": 3,
      "text": "When R=0 and F=0, the FEC header includes flexible Mask fields.",
      "ja": "R = 0およびF = 0の場合、FECヘッダーには柔軟なマスクフィールドが含まれます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0|0|P|X|  CC   |M| PT recovery |        length recovery        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          TS recovery                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           SN base_i           |k|          Mask [0-14]        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|k|                   Mask [15-45] (optional)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Mask [46-109] (optional)                  |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   ... next SN base and Mask for CSRC_i in CSRC list ...       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                Repair Payload follows FEC header              :\n:                                                               :",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 12: FEC Header for F=0",
      "ja": "図12：F = 0のFECヘッダー"
    },
    {
      "indent": 3,
      "text": "o The Length recovery (16 bits) field is used to determine the length of the recovered packets. This length includes all octets following the fixed 12-byte RTP header of source packets, including CSRC list and optional header extension(s) if present. It excludes the fixed 12-byte RTP header of source packets.",
      "ja": "o 長さ回復（16ビット）フィールドは、回復されたパケットの長さを決定するために使用されます。 この長さには、ソースパケットの12バイトの固定RTPヘッダーに続くすべてのオクテットが含まれます。CSRCリストおよびオプションのヘッダー拡張が存在する場合はこれも含まれます。 ソースパケットの固定12バイトRTPヘッダーは除外されます。"
    },
    {
      "indent": 3,
      "text": "o The TS recovery (32 bits) field is used to determine the timestamp of the recovered packets.",
      "ja": "o TS回復（32ビット）フィールドは、回復されたパケットのタイムスタンプを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o The CSRC_i (32 bits) field in the RTP header (not FEC header) describes the SSRC of the source packets protected by this particular FEC packet. If a FEC packet protects multiple SSRCs (indicated by the CSRC Count > 1 in the RTP header), there will be multiple blocks of data containing the SN base and Mask fields.",
      "ja": "o RTPヘッダー（FECヘッダーではない）のCSRC_i（32ビット）フィールドは、この特定のFECパケットで保護されたソースパケットのSSRCを記述します。 FECパケットが複数のSSRC（RTPヘッダーのCSRCカウント> 1で示される）を保護する場合、SNベースとマスクフィールドを含むデータブロックが複数存在します。"
    },
    {
      "indent": 3,
      "text": "o The SN base_i (16 bits) field indicates the lowest sequence number, taking wrap around into account, of the source packets for a particular SSRC (indicated in CSRC_i) protected by this repair packet.",
      "ja": "o SN base_i（16ビット）フィールドは、この修復パケットで保護された特定のSSRC（CSRC_iで示される）のソースパケットのラップアラウンドを考慮した最小のシーケンス番号を示します。"
    },
    {
      "indent": 3,
      "text": "o The Mask fields indicate a bitmask of which source packets are protected by this FEC repair packet, where bit j of the mask set to 1 indicates that the source packet with Sequence Number (SN base_i + j) is protected by this FEC repair packet, where j=0 is the most significant bit in the mask.",
      "ja": "o Maskフィールドは、ソースパケットがこのFEC修復パケットによって保護されているビットマスクを示します。マスクのビットjは、シーケンス番号（SN base_i + j）のソースパケットがこのFEC修復パケットによって保護されていることを示します。 j = 0は、マスクの最上位ビットです。"
    },
    {
      "indent": 3,
      "text": "o The k-bit in the bitmasks indicates if the mask is 15, 46, or 110 bits. k=1 denotes that another mask follows, and k=0 denotes that it is the last block of mask.",
      "ja": "o ビットマスクのkビットは、マスクが15、46、または110ビットのいずれであるかを示します。 k = 1は別のマスクが続くことを示し、k = 0はそれがマスクの最後のブロックであることを示します。"
    },
    {
      "indent": 3,
      "text": "o The Repair Payload, which follows the FEC header, includes repair of everything following the fixed 12-byte RTP header of each source packet, including any CSRC identifier list and header extensions if present.",
      "ja": "o FECヘッダーに続く修復ペイロードには、各ソースパケットの固定12バイトRTPヘッダーに続くすべての修復が含まれます。CSRC識別子リストとヘッダー拡張（存在する場合）が含まれます。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. FEC Header with Fixed L Columns and D Rows",
      "section_title": true,
      "ja": "4.2.2.2. L列とD行が固定されたFECヘッダー"
    },
    {
      "indent": 3,
      "text": "When R=0 and F=1, the FEC header includes L and D fields for fixed columns and rows. The other fields are the same as the prior section. As in the previous section, the CSRC_i (32 bits) field in the RTP header (not FEC Header) describes the SSRC of the source packets protected by this particular FEC packet. If there are multiple SSRC's protected by the FEC packet, then there will be multiple blocks of data containing an SN base along with L and D fields.",
      "ja": "R = 0およびF = 1の場合、FECヘッダーには固定列および固定行のLおよびDフィールドが含まれます。 他のフィールドは前のセクションと同じです。 前のセクションと同様に、RTPヘッダー（FECヘッダーではない）のCSRC_i（32ビット）フィールドは、この特定のFECパケットで保護されたソースパケットのSSRCを記述します。 FECパケットによって保護されている複数のSSRCがある場合、LおよびDフィールドと共にSNベースを含むデータの複数のブロックがあります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0|1|P|X|  CC   |M| PT recovery |         length recovery       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          TS recovery                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           SN base_i           |  L (columns)  |    D (rows)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    ... next SN base and L/D for CSRC_i in CSRC list ...       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                Repair Payload follows FEC header              :\n:                                                               :",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 13: FEC Header for F=1",
      "ja": "図13：F = 1のFECヘッダー"
    },
    {
      "indent": 3,
      "text": "Consequently, the following conditions occur for L and D values:",
      "ja": "その結果、L値とD値に対して次の条件が発生します。"
    },
    {
      "indent": 3,
      "text": "If L=0, D=0, reserved for future use, MUST NOT send, MUST ignore if received.",
      "ja": "L = 0、D = 0、将来の使用のために予約されている場合、送信してはならず、受信した場合は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If L>0, D=0, indicates row FEC, and no column FEC will follow (1D).\n             Source packets for each row: SN, SN+1, ..., SN+(L-1)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If L>0, D=1, indicates row FEC, and column FEC will follow (2D). Source packets for each row: SN, SN+1, ..., SN+(L-1) Source packets for each col: SN, SN+L, ..., SN+(D-1)*L After all row FEC packets have been sent, the column FEC packets will be sent.",
      "ja": "L> 0、D = 1の場合、行FECを示し、列FECが続きます（2D）。 各行のソースパケット：SN、SN + 1、...、SN +（L-1）各列のソースパケット：SN、SN + L、...、SN +（D-1）* Lすべての行FECの後 パケットが送信された場合、列FECパケットが送信されます。"
    },
    {
      "indent": 3,
      "text": "If L>0, D>1, indicates column FEC of every L packet, D times.\n             Source packets for each col: SN, SN+L, ..., SN+(D-1)*L",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 14: Interpreting the L and D Field Values",
      "ja": "図14：LおよびDフィールド値の解釈"
    },
    {
      "indent": 3,
      "text": "Given the 8-bit limit on L and D (as depicted in Figure 13), the maximum value of either parameter is 255. If L=0 and D=0 are in a packet, then the repair packet MUST be ignored by the receiver. In addition, when L=1 and D=0, the repair packet becomes a retransmission of a corresponding source packet.",
      "ja": "LとDに8ビットの制限がある場合（図13を参照）、いずれかのパラメーターの最大値は255です。L= 0とD = 0がパケット内にある場合、修復パケットは受信者によって無視されなければなりません。 。 さらに、L = 1およびD = 0の場合、修復パケットは対応するソースパケットの再送信になります。"
    },
    {
      "indent": 3,
      "text": "The values of L and D for a given block of recovery data will correspond to the type of recovery in use for that block of data. In particular, for 2-D repair, the (L,D) values may not be constant across all packets for a given SSRC being repaired. Similarly, the L and D values can differ across different blocks of repair data (repairing different SSRCs) in a single packet. If the values of L and D result in a repair packet that exceed the repair window of the FLEX FEC session, then the repair packet MUST be ignored.",
      "ja": "回復データの特定のブロックのLおよびDの値は、そのデータブロックに使用されている回復のタイプに対応します。 特に、2-D修復の場合、修復される特定のSSRCのすべてのパケットで（L、D）値が一定でない場合があります。 同様に、LとDの値は、1つのパケット内の修復データの異なるブロック（異なるSSRCを修復する）で異なる場合があります。 LとDの値がFLEX FECセッションの修復ウィンドウを超える修復パケットをもたらす場合、修復パケットは無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the flexible mask-based approach may be inefficient for protecting a large number of source packets, or impossible to signal if larger than the largest mask size. In such cases, the fixed columns and rows variant may be more useful.",
      "ja": "柔軟なマスクベースのアプローチは、多数のソースパケットを保護するには非効率的であるか、最大マスクサイズよりも大きい場合は信号を送信できないことに注意してください。 このような場合、固定列と固定行のバリアントがより役立つ場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. FEC Header for Retransmissions",
      "section_title": true,
      "ja": "4.2.2.3. 再送信用のFECヘッダー"
    },
    {
      "indent": 3,
      "text": "When R=1 and F=0, the FEC packet is a retransmission of a single source packet. Note that the layout of this retransmission packet is different from other FEC repair packets. The Sequence Number (SN base_i) replaces the length recovery in the FEC header, since the length is already known for a single packet. There are no L, D, or Mask fields, since only a single packet is retransmitted, identified by the Sequence Number in the FEC header. The source packet SSRC is included in the FEC header for retransmissions, not in the RTP header CSRC list as in the FEC header variants with R=0. When performing retransmissions, a single repair packet stream (SSRC) MAY be used for retransmitting packets from multiple source packet streams (SSRCs), as well as transmitting FEC repair packets that protect multiple source packet streams (SSRCs).",
      "ja": "R = 1およびF = 0の場合、FECパケットは単一のソースパケットの再送信です。 この再送信パケットのレイアウトは、他のFEC修復パケットとは異なることに注意してください。 シーケンス番号（SN base_i）は、FECヘッダーの長さの回復を置き換えます。これは、1つのパケットの長さがすでにわかっているためです。 L、D、またはマスクフィールドはありません。これは、FECヘッダーのシーケンス番号で識別される単一のパケットのみが再送信されるためです。 ソースパケットSSRCは、再送信のFECヘッダーに含まれますが、R = 0のFECヘッダーバリアントのようなRTPヘッダーCSRCリストには含まれません。 再送信を実行するとき、単一の修復パケットストリーム（SSRC）を使用して、複数のソースパケットストリーム（SSRC）からのパケットの再送信、および複数のソースパケットストリーム（SSRC）を保護するFEC修復パケットの送信に使用できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "This FEC header layout is identical to the source RTP (version 2) packet, starting with its RTP header, where the retransmission \"payload\" is everything following the fixed 12-byte RTP header of the source packet, including the CSRC list and extensions if present. Therefore, the only operation needed for sending retransmissions is to prepend a new RTP header to the source packet.",
      "ja": "このFECヘッダーレイアウトは、RTCヘッダーで始まるソースRTP（バージョン2）パケットと同一です。ここで、「ペイロード」は、CSRCリストと拡張子を含むソースパケットの固定12バイトRTPヘッダーに続くすべてです。 プレゼント。 したがって、再送信の送信に必要な唯一の操作は、ソースパケットに新しいRTPヘッダーを追加することです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1|0|P|X|  CC   |M| Payload Type|        Sequence Number        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              SSRC                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:           Retransmission Payload follows FEC header           :\n:                                                               :",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 15: FEC Header for Retransmission",
      "ja": "図15：再送信用のFECヘッダー"
    },
    {
      "indent": 0,
      "text": "5. Payload Format Parameters",
      "section_title": true,
      "ja": "5. ペイロード形式のパラメーター"
    },
    {
      "indent": 3,
      "text": "This section provides the media subtype registration for the non-interleaved and interleaved parity FEC. The parameters that are required to configure the FEC encoding and decoding operations are also defined in this section. If no specific FEC code is specified in the subtype, then the FEC code defaults to the parity code defined in this specification.",
      "ja": "このセクションは、非インターリーブおよびインターリーブパリティFECのメディアサブタイプ登録を提供します。 このセクションでは、FECエンコードおよびデコード操作の構成に必要なパラメーターも定義されています。 サブタイプで特定のFECコードが指定されていない場合、FECコードはデフォルトでこの仕様で定義されているパリティコードになります。"
    },
    {
      "indent": 0,
      "text": "5.1. Media Type Registration -- Parity Codes",
      "section_title": true,
      "ja": "5.1. メディアタイプの登録-パリティコード"
    },
    {
      "indent": 3,
      "text": "This registration is done using the template defined in [RFC6838] and following the guidance provided in [RFC4855] along with [RFC4856].",
      "ja": "この登録は、[RFC6838]で定義されたテンプレートを使用して、[RFC4856]とともに[RFC4855]で提供されるガイダンスに従って行われます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Registration of audio/flexfec",
      "section_title": true,
      "ja": "5.1.1. オーディオ/フレックスの登録"
    },
    {
      "indent": 3,
      "text": "Type name: audio",
      "ja": "タイプ名：オーディオ"
    },
    {
      "indent": 3,
      "text": "Subtype name: flexfec",
      "ja": "サブタイプ名：flexfec"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメーター："
    },
    {
      "indent": 3,
      "text": "o rate: The RTP timestamp (clock) rate. The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.",
      "ja": "o rate：RTPタイムスタンプ（クロック）レート。 レートは、RTCP操作に十分な解像度を提供するために1000 Hzより大きくする必要があります。 ただし、保護されたソースRTPストリームのレートに一致するレートを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o repair-window: The time that spans the source packets and the corresponding repair packets. The size of the repair window is specified in microseconds.",
      "ja": "o repair-window：ソースパケットと対応する修復パケットにまたがる時間。 修復ウィンドウのサイズはマイクロ秒単位で指定されます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed (see Section 4.8 in the template document [RFC6838]) and contains binary data.",
      "ja": "エンコードに関する考慮事項：このメディアタイプはフレーム化され（テンプレートドキュメント[RFC6838]のセクション4.8を参照）、バイナリデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 9 of [RFC8627].",
      "ja": "セキュリティの考慮事項：[RFC8627]の節を参照してください9。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: [RFC8627].",
      "ja": "公開された仕様：[RFC8627]。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Multimedia applications that want to improve resiliency against packet loss by sending redundant data in addition to the source media.",
      "ja": "このメディアタイプを使用するアプリケーション：ソースメディアに加えて冗長データを送信することにより、パケット損失に対する回復力を向上させたいマルチメディアアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: None.",
      "ja": "フラグメント識別子の考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: IESG <iesg@ietf.org> and IETF Audio/Video Transport Payloads Working Group (or its successor as delegated by the IESG).",
      "ja": "詳細については、連絡先の個人と電子メールアドレス：IESG <iesg@ietf.org>およびIETF Audio / Video Transport Payloadsワーキンググループ（またはIESGから委任された後継者）。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON.",
      "ja": "使用目的：共通。"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing; hence, it is only defined for transport via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプはRTPフレーミングに依存します。 したがって、RTP [RFC3550]を介したトランスポートに対してのみ定義されます。"
    },
    {
      "indent": 3,
      "text": "Author: Varun Singh <varun@callstats.io>.",
      "ja": "作成者：Varun Singh <varun@callstats.io>。"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Audio/Video Transport Payloads Working Group delegated from the IESG (or its successor as delegated by the IESG).",
      "ja": "変更コントローラ：IESGから委任されたIETFオーディオ/ビデオトランスポートペイロードワーキンググループ（またはIESGによって委任された後継者）。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Registration of video/flexfec",
      "section_title": true,
      "ja": "5.1.2. video / flexfecの登録"
    },
    {
      "indent": 3,
      "text": "Type name: video",
      "ja": "タイプ名：ビデオ"
    },
    {
      "indent": 3,
      "text": "Subtype name: flexfec",
      "ja": "サブタイプ名：flexfec"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメーター："
    },
    {
      "indent": 3,
      "text": "o rate: The RTP timestamp (clock) rate. The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.",
      "ja": "o rate：RTPタイムスタンプ（クロック）レート。 レートは、RTCP操作に十分な解像度を提供するために1000 Hzより大きくする必要があります。 ただし、保護されたソースRTPストリームのレートに一致するレートを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o repair-window: The time that spans the source packets and the corresponding repair packets. The size of the repair window is specified in microseconds.",
      "ja": "o repair-window：ソースパケットと対応する修復パケットにまたがる時間。 修復ウィンドウのサイズはマイクロ秒単位で指定されます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed (see Section 4.8 in the template document [RFC6838]) and contains binary data.",
      "ja": "エンコードに関する考慮事項：このメディアタイプはフレーム化され（テンプレートドキュメント[RFC6838]のセクション4.8を参照）、バイナリデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 9 of [RFC8627].",
      "ja": "セキュリティの考慮事項：[RFC8627]の節を参照してください9。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: [RFC8627].",
      "ja": "公開された仕様：[RFC8627]。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Multimedia applications that want to improve resiliency against packet loss by sending redundant data in addition to the source media.",
      "ja": "このメディアタイプを使用するアプリケーション：ソースメディアに加えて冗長データを送信することにより、パケット損失に対する回復力を向上させたいマルチメディアアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: None.",
      "ja": "フラグメント識別子の考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: IESG <iesg@ietf.org> and IETF Audio/Video Transport Payloads Working Group (or its successor as delegated by the IESG).",
      "ja": "詳細については、連絡先の個人と電子メールアドレス：IESG <iesg@ietf.org>およびIETF Audio / Video Transport Payloadsワーキンググループ（またはIESGから委任された後継者）。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON.",
      "ja": "使用目的：共通。"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing; hence, it is only defined for transport via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプはRTPフレーミングに依存します。 したがって、RTP [RFC3550]を介したトランスポートに対してのみ定義されます。"
    },
    {
      "indent": 3,
      "text": "Author: Varun Singh <varun@callstats.io>.",
      "ja": "作成者：Varun Singh <varun@callstats.io>。"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Audio/Video Transport Payloads Working Group delegated from the IESG (or its successor as delegated by the IESG).",
      "ja": "変更コントローラ：IESGから委任されたIETFオーディオ/ビデオトランスポートペイロードワーキンググループ（またはIESGによって委任された後継者）。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Registration of text/flexfec",
      "section_title": true,
      "ja": "5.1.3. text / flexfecの登録"
    },
    {
      "indent": 3,
      "text": "Type name: text",
      "ja": "タイプ名：テキスト"
    },
    {
      "indent": 3,
      "text": "Subtype name: flexfec",
      "ja": "サブタイプ名：flexfec"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメーター："
    },
    {
      "indent": 3,
      "text": "o rate: The RTP timestamp (clock) rate. The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.",
      "ja": "o rate：RTPタイムスタンプ（クロック）レート。 レートは、RTCP操作に十分な解像度を提供するために1000 Hzより大きくする必要があります。 ただし、保護されたソースRTPストリームのレートに一致するレートを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o repair-window: The time that spans the source packets and the corresponding repair packets. The size of the repair window is specified in microseconds.",
      "ja": "o repair-window：ソースパケットと対応する修復パケットにまたがる時間。 修復ウィンドウのサイズはマイクロ秒単位で指定されます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed (see Section 4.8 in the template document [RFC6838]) and contains binary data.",
      "ja": "エンコードに関する考慮事項：このメディアタイプはフレーム化され（テンプレートドキュメント[RFC6838]のセクション4.8を参照）、バイナリデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 9 of [RFC8627].",
      "ja": "セキュリティの考慮事項：[RFC8627]の節を参照してください9。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: [RFC8627].",
      "ja": "公開された仕様：[RFC8627]。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Multimedia applications that want to improve resiliency against packet loss by sending redundant data in addition to the source media.",
      "ja": "このメディアタイプを使用するアプリケーション：ソースメディアに加えて冗長データを送信することにより、パケット損失に対する回復力を向上させたいマルチメディアアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: None.",
      "ja": "フラグメント識別子の考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: IESG <iesg@ietf.org> and IETF Audio/Video Transport Payloads Working Group (or its successor as delegated by the IESG).",
      "ja": "詳細については、連絡先の個人と電子メールアドレス：IESG <iesg@ietf.org>およびIETF Audio / Video Transport Payloadsワーキンググループ（またはIESGから委任された後継者）。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON.",
      "ja": "使用目的：共通。"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing; hence, it is only defined for transport via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプはRTPフレーミングに依存します。 したがって、RTP [RFC3550]を介したトランスポートに対してのみ定義されます。"
    },
    {
      "indent": 3,
      "text": "Author: Varun Singh <varun@callstats.io>.",
      "ja": "作成者：Varun Singh <varun@callstats.io>。"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Audio/Video Transport Payloads Working Group delegated from the IESG (or its successor as delegated by the IESG).",
      "ja": "変更コントローラ：IESGから委任されたIETFオーディオ/ビデオトランスポートペイロードワーキンググループ（またはIESGによって委任された後継者）。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Registration of application/flexfec",
      "section_title": true,
      "ja": "5.1.4. アプリケーション/ flexfecの登録"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: flexfec",
      "ja": "サブタイプ名：flexfec"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメーター："
    },
    {
      "indent": 3,
      "text": "o rate: The RTP timestamp (clock) rate. The rate SHALL be larger than 1000 Hz to provide sufficient resolution to RTCP operations. However, it is RECOMMENDED to select the rate that matches the rate of the protected source RTP stream.",
      "ja": "o rate：RTPタイムスタンプ（クロック）レート。 レートは、RTCP操作に十分な解像度を提供するために1000 Hzより大きくする必要があります。 ただし、保護されたソースRTPストリームのレートに一致するレートを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o repair-window: The time that spans the source packets and the corresponding repair packets. The size of the repair window is specified in microseconds.",
      "ja": "o repair-window：ソースパケットと対応する修復パケットにまたがる時間。 修復ウィンドウのサイズはマイクロ秒単位で指定されます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed (see Section 4.8 in the template document [RFC6838]) and contains binary data.",
      "ja": "エンコードに関する考慮事項：このメディアタイプはフレーム化され（テンプレートドキュメント[RFC6838]のセクション4.8を参照）、バイナリデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 9 of [RFC8627].",
      "ja": "セキュリティの考慮事項：[RFC8627]の節を参照してください9。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: [RFC8627].",
      "ja": "公開された仕様：[RFC8627]。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Multimedia applications that want to improve resiliency against packet loss by sending redundant data in addition to the source media.",
      "ja": "このメディアタイプを使用するアプリケーション：ソースメディアに加えて冗長データを送信することにより、パケット損失に対する回復力を向上させたいマルチメディアアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: None.",
      "ja": "フラグメント識別子の考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: IESG <iesg@ietf.org> and IETF Audio/Video Transport Payloads Working Group (or its successor as delegated by the IESG).",
      "ja": "詳細については、連絡先の個人と電子メールアドレス：IESG <iesg@ietf.org>およびIETF Audio / Video Transport Payloadsワーキンググループ（またはIESGから委任された後継者）。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON.",
      "ja": "使用目的：共通。"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing; hence, it is only defined for transport via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプはRTPフレーミングに依存します。 したがって、RTP [RFC3550]を介したトランスポートに対してのみ定義されます。"
    },
    {
      "indent": 3,
      "text": "Author: Varun Singh <varun@callstats.io>.",
      "ja": "作成者：Varun Singh <varun@callstats.io>。"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Audio/Video Transport Payloads Working Group delegated from the IESG (or its successor as delegated by the IESG).",
      "ja": "変更コントローラ：IESGから委任されたIETFオーディオ/ビデオトランスポートペイロードワーキンググループ（またはIESGによって委任された後継者）。"
    },
    {
      "indent": 0,
      "text": "5.2. Mapping to SDP Parameters",
      "section_title": true,
      "ja": "5.2. SDPパラメーターへのマッピング"
    },
    {
      "indent": 3,
      "text": "Applications that use the RTP transport commonly use the Session Description Protocol (SDP) [RFC4566] to describe their RTP sessions. The information that is used to specify the media types in an RTP session has specific mappings to the fields in an SDP description. This section provides these mappings for the media subtypes registered by this document. Note that if an application does not use SDP to describe the RTP sessions, an appropriate mapping must be defined and used to specify the media types and their parameters for the control/description protocol employed by the application.",
      "ja": "RTPトランスポートを使用するアプリケーションは、通常、セッション記述プロトコル（SDP）[RFC4566]を使用してRTPセッションを記述します。 RTPセッションでメディアタイプを指定するために使用される情報には、SDP記述のフィールドへの特定のマッピングがあります。 このセクションでは、このドキュメントで登録されているメディアサブタイプのこれらのマッピングについて説明します。 アプリケーションがSDPを使用してRTPセッションを記述しない場合、適切なマッピングを定義および使用して、アプリケーションが使用する制御/記述プロトコルのメディアタイプとそのパラメーターを指定する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The mapping of the media type specification for \"flexfec\" and its associated parameters in SDP is as follows:",
      "ja": "「flexfec」のメディアタイプ仕様とSDPの関連パラメータのマッピングは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The media type (e.g., \"application\") goes into the \"m=\" line as the media name.",
      "ja": "o メディアタイプ（「アプリケーション」など）は、メディア名として「m =」行に入ります。"
    },
    {
      "indent": 3,
      "text": "o The media subtype goes into the \"a=rtpmap\" line as the encoding name. The RTP clock rate parameter (\"rate\") also goes into the \"a=rtpmap\" line as the clock rate.",
      "ja": "o メディアサブタイプは、エンコーディング名として「a = rtpmap」行に入ります。 RTPクロックレートパラメータ（「レート」）も、クロックレートとして「a = rtpmap」行に入力されます。"
    },
    {
      "indent": 3,
      "text": "o The remaining required payload-format-specific parameters go into the \"a=fmtp\" line by copying them directly from the media type string as a semicolon-separated list of parameter=value pairs.",
      "ja": "o 残りの必要なペイロード形式固有のパラメータは、パラメータタイプ=値のペアのセミコロン区切りリストとしてメディアタイプ文字列から直接コピーすることにより、「a = fmtp」行に入ります。"
    },
    {
      "indent": 3,
      "text": "SDP examples are provided in Section 7.1.",
      "ja": "SDPの例は、セクション7.1で提供されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Offer/Answer Model Considerations",
      "section_title": true,
      "ja": "5.2.1. オファー/アンサーモデルの考慮事項"
    },
    {
      "indent": 3,
      "text": "When offering parity FEC over RTP using SDP in an Offer/Answer model [RFC3264], the following considerations apply:",
      "ja": "Offer / Answerモデル[RFC3264]でSDPを使用してRTP上でパリティFECを提供する場合、次の考慮事項が適用されます。"
    },
    {
      "indent": 3,
      "text": "o A sender application will indicate a repair window consistent with the desired amount of protection. Since the sender can change the FEC configuration on a packet-by-packet basis, note that the receiver must support any valid FLEX FEC configuration within the repair window associated with the offer (see Section 4.2.2). If the receiver cannot support the offered repair window it MUST reject the offer.",
      "ja": "o 送信者のアプリケーションは、保護の望ましい量と一致する修復ウィンドウを示します。 送信者はパケットごとにFEC構成を変更できるため、受信者はオファーに関連付けられた修復ウィンドウ内で有効なFLEX FEC構成をサポートする必要があることに注意してください（セクション4.2.2を参照）。 受信者が提供された修復ウィンドウをサポートできない場合、受信者は提供を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The size of the repair-window is related to the maximum delay between the transmission of a source packet and the associated repair packet. This directly impacts the buffering requirement on the receiver side and the receiver must consider this when choosing an offer.",
      "ja": "o 修復ウィンドウのサイズは、ソースパケットの送信と関連する修復パケット間の最大遅延に関連しています。 これは受信側のバッファリング要件に直接影響し、受信者はオファーを選択する際にこれを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Any unknown option in the offer must be ignored and deleted from the answer (see Section 6 of [RFC3264]). If FEC is not desired by the receiver, it can be deleted from the answer.",
      "ja": "o オファー内の不明なオプションは無視して、回答から削除する必要があります（[RFC3264]のセクション6を参照）。 受信者がFECを希望しない場合は、回答から削除できます。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Declarative Considerations",
      "section_title": true,
      "ja": "5.2.2. 宣言的な考慮事項"
    },
    {
      "indent": 3,
      "text": "In declarative usage, like SDP in the Real-time Streaming Protocol (RTSP, for RTSP 1.0 see [RFC2326] and for RTSP 2.0 see [RFC7826]) or the Session Announcement Protocol (SAP) [RFC2974], the following considerations apply:",
      "ja": "リアルタイムストリーミングプロトコルのSDP（RTSP、RTSP 1.0の場合は[RFC2326]を、RTSP 2.0の場合は[RFC7826]を参照）またはセッションアナウンスメントプロトコル（SAP）[RFC2974]のような宣言的な使用では、次の考慮事項が適用されます。"
    },
    {
      "indent": 3,
      "text": "o The payload format configuration parameters are all declarative and a participant MUST use the configuration that is provided for the session.",
      "ja": "o ペイロード形式の構成パラメータはすべて宣言的であり、参加者はセッションに提供された構成を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o More than one configuration may be provided (if desired) by declaring multiple RTP payload types. In that case, the receivers should choose the repair stream that is best for them.",
      "ja": "o 複数のRTPペイロードタイプを宣言することにより、（必要に応じて）複数の構成を提供できます。 その場合、受信者は自分に最適な修復ストリームを選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Protection and Recovery Procedures -- Parity Codes",
      "section_title": true,
      "ja": "6. 保護および回復手順-パリティコード"
    },
    {
      "indent": 3,
      "text": "This section provides a complete specification of the 1-D and 2-D parity codes and their RTP payload formats. It does not apply to the single packet retransmission format (R=1 in the FEC header).",
      "ja": "このセクションでは、1-Dおよび2-DパリティコードとそれらのRTPペイロード形式の完全な仕様を提供します。 単一パケットの再送信フォーマット（FECヘッダーのR = 1）には適用されません。"
    },
    {
      "indent": 0,
      "text": "6.1. Overview",
      "section_title": true,
      "ja": "6.1. 概要"
    },
    {
      "indent": 3,
      "text": "The following sections specify the steps involved in generating the repair packets and reconstructing the missing source packets from the repair packets.",
      "ja": "次のセクションでは、修復パケットを生成し、修復パケットから欠落しているソースパケットを再構築する手順を示します。"
    },
    {
      "indent": 0,
      "text": "6.2. Repair Packet Construction",
      "section_title": true,
      "ja": "6.2. 修理用パケットの構築"
    },
    {
      "indent": 3,
      "text": "The RTP header of a repair packet is formed based on the guidelines given in Section 4.2.",
      "ja": "修復パケットのRTPヘッダーは、セクション4.2で与えられたガイドラインに基づいて形成されます。"
    },
    {
      "indent": 3,
      "text": "The FEC header and Repair Payload of repair packets are formed by applying the XOR operation on the bit strings that are generated from the individual source packets protected by this particular repair packet. The set of the source packets that are associated with a given repair packet can be computed by the formula given in Section 6.3.1.",
      "ja": "修復パケットのFECヘッダーと修復ペイロードは、この特定の修復パケットによって保護されている個々のソースパケットから生成されたビット文字列にXOR演算を適用することにより形成されます。 特定の修復パケットに関連付けられているソースパケットのセットは、セクション6.3.1で指定された式によって計算できます。"
    },
    {
      "indent": 3,
      "text": "The bit string is formed for each source packet by concatenating the following fields together in the order specified:",
      "ja": "次のフィールドを指定された順序で連結することにより、各ソースパケットに対してビット文字列が形成されます。"
    },
    {
      "indent": 3,
      "text": "o The first 16 bits of the RTP header (16 bits), though the first two (version) bits will be ignored by the recovery procedure.",
      "ja": "o RTPヘッダーの最初の16ビット（16ビット）。ただし、最初の2（バージョン）ビットは回復手順では無視されます。"
    },
    {
      "indent": 3,
      "text": "o Unsigned network-ordered 16-bit representation of the source packet length in bytes minus 12 (for the fixed RTP header), i.e., the sum of the lengths of all the following if present: the CSRC list, extension header, RTP payload, and RTP padding (16 bits).",
      "ja": "o ソースパケットの長さのバイトから12を引いた（固定RTPヘッダーの）符号なしネットワーク順序16ビット表現、つまり、存在する場合は次のすべての長さの合計：CSRCリスト、拡張ヘッダー、RTPペイロード、および RTPパディング（16ビット）。"
    },
    {
      "indent": 3,
      "text": "o The timestamp of the RTP header (32 bits).",
      "ja": "o RTPヘッダーのタイムスタンプ（32ビット）。"
    },
    {
      "indent": 3,
      "text": "o All octets after the fixed 12-byte RTP header. (Note the SSRC field is skipped.)",
      "ja": "o 固定12バイトRTPヘッダーの後のすべてのオクテット。 （SSRCフィールドはスキップされます。）"
    },
    {
      "indent": 3,
      "text": "The FEC bit string is generated by applying the parity operation on the bit strings produced from the source packets. The FEC header is generated from the FEC bit string as follows:",
      "ja": "FECビット文字列は、ソースパケットから生成されたビット文字列にパリティ演算を適用することにより生成されます。 FECヘッダーは、次のようにFECビット文字列から生成されます。"
    },
    {
      "indent": 3,
      "text": "o The first (most significant) 2 bits in the FEC bit string, which contain the RTP version field, are skipped. The R and F bits in the FEC header are set to the appropriate value, i.e., it depends on the chosen format variant. As a consequence of overwriting the RTP version field with the R and F bits, this payload format only supports RTP version 2.",
      "ja": "o RTPバージョンフィールドを含むFECビットストリングの最初の（最上位）2ビットはスキップされます。 FECヘッダーのRおよびFビットは適切な値に設定されます。つまり、選択された形式のバリエーションに依存します。 RおよびFビットでRTPバージョンフィールドを上書きした結果、このペイロード形式はRTPバージョン2のみをサポートします。"
    },
    {
      "indent": 3,
      "text": "o The next bit in the FEC bit string is written into the P recovery bit in the FEC header.",
      "ja": "o FECビット文字列の次のビットは、FECヘッダーのP回復ビットに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next bit in the FEC bit string is written into the X recovery bit in the FEC header.",
      "ja": "o FECビット文字列の次のビットは、FECヘッダーのX回復ビットに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next 4 bits of the FEC bit string are written into the CC recovery field in the FEC header.",
      "ja": "o FECビット文字列の次の4ビットは、FECヘッダーのCC回復フィールドに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next bit is written into the M recovery bit in the FEC header.",
      "ja": "o 次のビットは、FECヘッダーのM回復ビットに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next 7 bits of the FEC bit string are written into the PT recovery field in the FEC header.",
      "ja": "o FECビット文字列の次の7ビットは、FECヘッダーのPT回復フィールドに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next 16 bits are written into the length recovery field in the FEC header.",
      "ja": "o 次の16ビットは、FECヘッダーの長さ回復フィールドに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The next 32 bits of the FEC bit string are written into the TS recovery field in the FEC header.",
      "ja": "o FECビット文字列の次の32ビットは、FECヘッダーのTS回復フィールドに書き込まれます。"
    },
    {
      "indent": 3,
      "text": "o The lowest Sequence Number of the source packets protected by this repair packet is written into the Sequence Number Base field in the FEC header. This needs to be repeated for each SSRC that has packets included in the source block.",
      "ja": "o この修復パケットによって保護されているソースパケットの最小シーケンス番号は、FECヘッダーのシーケンス番号ベースフィールドに書き込まれます。 これは、ソースブロックにパケットが含まれるSSRCごとに繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "o Depending on the chosen FEC header variant, the mask(s) is set when F=0 or the L and D values are set when F=1. This needs to be repeated for each SSRC that has packets included in the source block.",
      "ja": "o 選択したFECヘッダーバリアントに応じて、F = 0の場合はマスクが設定され、F = 1の場合はLおよびD値が設定されます。 これは、ソースブロックにパケットが含まれるSSRCごとに繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "o The rest of the FEC bit string, which contains everything after the fixed 12-byte RTP header of the source packet, is written into the Repair Payload following the FEC header, where \"Payload\" refers to everything after the fixed 12-byte RTP header, including extensions, CSRC list, true payloads, and padding.",
      "ja": "o ソースパケットの固定12バイトRTPヘッダーの後のすべてを含むFECビット文字列の残りは、FECヘッダーに続く修復ペイロードに書き込まれます。「ペイロード」は、固定12バイトRTPヘッダーの後のすべてを指します。 、拡張機能、CSRCリスト、真のペイロード、およびパディングが含まれます。"
    },
    {
      "indent": 3,
      "text": "If the lengths of the source packets are not equal, each shorter packet MUST be padded to the length of the longest packet by adding octet zeros at the end.",
      "ja": "ソースパケットの長さが等しくない場合、オクテットゼロを最後に追加することにより、それぞれの短いパケットを最長パケットの長さにパディングする必要があります。"
    },
    {
      "indent": 3,
      "text": "Due to this possible padding and mandatory FEC header, a repair packet has a larger size than the source packets it protects. This may cause problems if the resulting repair packet size exceeds the Maximum Transmission Unit (MTU) size of the path over which the repair stream is sent.",
      "ja": "この可能性のあるパディングと必須のFECヘッダーにより、修復パケットは保護するソースパケットよりもサイズが大きくなります。 その結果、修復パケットのサイズが修復ストリームが送信されるパスの最大伝送ユニット（MTU）サイズを超える場合、問題が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Source Packet Reconstruction",
      "section_title": true,
      "ja": "6.3. ソースパケットの再構築"
    },
    {
      "indent": 3,
      "text": "This section describes the recovery procedures that are required to reconstruct the missing source packets. The recovery process has two steps. In the first step, the FEC decoder determines which source and repair packets should be used in order to recover a missing packet. In the second step, the decoder recovers the missing packet, which consists of an RTP header and RTP payload.",
      "ja": "このセクションでは、欠落したソースパケットを再構築するために必要な回復手順について説明します。 回復プロセスには2つのステップがあります。 最初のステップで、FECデコーダーは、欠落したパケットを回復するために使用するソースおよび修復パケットを決定します。 2番目のステップで、デコーダーは、RTPヘッダーとRTPペイロードで構成される欠落パケットを復元します。"
    },
    {
      "indent": 3,
      "text": "The following describes the RECOMMENDED algorithms for the first and second steps. Based on the implementation, different algorithms MAY be adopted. However, the end result MUST be identical to the one produced by the algorithms described below.",
      "ja": "以下に、最初と2番目のステップの推奨アルゴリズムについて説明します。 実装に基づいて、異なるアルゴリズムが採用される場合があります。 ただし、最終結果は、以下で説明するアルゴリズムによって生成された結果と同一でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the same algorithms are used by the 1-D parity codes, regardless of whether the FEC protection is applied over a column or a row. The 2-D parity codes, on the other hand, usually require multiple iterations of the procedures described here. This iterative decoding algorithm is further explained in Section 6.3.4.",
      "ja": "FEC保護が列または行に適用されるかどうかに関係なく、同じアルゴリズムが1-Dパリティコードによって使用されることに注意してください。 一方、2次元パリティコードでは、通常、ここで説明する手順を複数回繰り返す必要があります。 この反復復号アルゴリズムについては、セクション6.3.4でさらに説明します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Associating the Source and Repair Packets",
      "section_title": true,
      "ja": "6.3.1. ソースパケットと修復パケットの関連付け"
    },
    {
      "indent": 3,
      "text": "Before associating source and repair packets, the receiver must know in which RTP sessions the source and repair, respectively, are being sent. After this is established by the receiver, the first step is associating the source and repair packets. This association can be via flexible bitmasks or fixed L and D offsets, which can be in the FEC header or signaled in SDP in optional payload format parameters when L=D=0 in the FEC header.",
      "ja": "ソースパケットと修復パケットを関連付ける前に、受信者は、送信元と修復がそれぞれどのRTPセッションで送信されているかを知る必要があります。 これがレシーバーによって確立された後、最初のステップはソースおよび修復パケットを関連付けることです。 この関連付けは、FECヘッダーにあるか、FECヘッダーでL = D = 0の場合にオプションのペイロード形式パラメーターでSDPで通知される、柔軟なビットマスクまたは固定LおよびDオフセットを介して行うことができます。"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Using Bitmasks",
      "section_title": true,
      "ja": "6.3.1.1. ビットマスクを使用する"
    },
    {
      "indent": 3,
      "text": "To use flexible bitmasks, the first two FEC header bits MUST have R=0 and F=0. A 15-bit, 46-bit, or 110-bit mask indicates which source packets are protected by a FEC repair packet. If the bit i in the mask is set to 1, the source packet number N + i is protected by this FEC repair packet, where N is the Sequence Number base indicated in the FEC header. The most significant bit of the mask corresponds to i=0. The least significant bit of the mask corresponds to i=14 in the 15-bit mask, i=45 in the 46-bit mask, or i=109 in the 110-bit mask.",
      "ja": "柔軟なビットマスクを使用するには、最初の2つのFECヘッダービットにR = 0とF = 0が必要です。 15ビット、46ビット、または110ビットのマスクは、FEC修復パケットによって保護されているソースパケットを示します。 マスクのビットiが1に設定されている場合、ソースパケット番号N + iはこのFEC修復パケットによって保護されます。NはFECヘッダーで示されるシーケンス番号ベースです。 マスクの最上位ビットはi = 0に対応します。 マスクの最下位ビットは、15ビットマスクではi = 14、46ビットマスクではi = 45、110ビットマスクではi = 109に対応します。"
    },
    {
      "indent": 3,
      "text": "The bitmasks are able to represent arbitrary protection patterns, for example, 1-D interleaved, 1-D non-interleaved, 2-D.",
      "ja": "ビットマスクは、1次元インターリーブ、1次元ノンインターリーブ、2次元など、任意の保護パターンを表すことができます。"
    },
    {
      "indent": 0,
      "text": "6.3.1.2. Using L and D Offsets",
      "section_title": true,
      "ja": "6.3.1.2. LおよびDオフセットの使用"
    },
    {
      "indent": 3,
      "text": "Denote the set of the source packets associated with repair packet p* by set T(p*). Note that in a source block whose size is L columns by D rows, set T includes D source packets plus one repair packet for the FEC protection applied over a column, and it includes L source packets plus one repair packet for the FEC protection applied over a row. Recall that 1-D interleaved and non-interleaved FEC protection can fully recover the missing information if there is only one source packet missing per column or row in set T. If more than one source packet is missing per column or row in set T, 1-D FEC protection may fail to recover all the missing information.",
      "ja": "セットT（p *）により、修復パケットp *に関連付けられたソースパケットのセットを示します。 サイズがL行X列であるソースブロックでは、セットTにはDソースパケットと列に適用されるFEC保護用の1つの修復パケットが含まれ、Lソースパケットと適用されるFEC保護用の1つの修復パケットが含まれることに注意してください 行。 セットTの列または行ごとに1つのソースパケットのみが欠落している場合、1-Dインターリーブおよび非インターリーブFEC保護は欠落情報を完全に回復できることを思い出してください。セットTの列または行ごとに複数のソースパケットが欠落している場合、 1-D FEC保護では、欠落しているすべての情報を回復できない場合があります。"
    },
    {
      "indent": 3,
      "text": "When the value of L is non-zero, the 8-bit fields indicate the offset of packets protected by an interleaved (D>0) or non-interleaved (D=0) FEC packet. Using a combination of interleaved and non-interleaved FEC repair packets can form 2-D protection patterns.",
      "ja": "Lの値がゼロ以外の場合、8ビットフィールドは、インターリーブ（D> 0）または非インターリーブ（D = 0）FECパケットで保護されたパケットのオフセットを示します。 インターリーブおよび非インターリーブFEC修復パケットの組み合わせを使用すると、2D保護パターンを形成できます。"
    },
    {
      "indent": 3,
      "text": "Mathematically, for any received repair packet, p*, the sequence numbers of the source packets that are protected by this repair packet are determined as follows, where SN is the Sequence Number base in the FEC header:",
      "ja": "数学的には、受信した修復パケットp *について、この修復パケットによって保護されるソースパケットのシーケンス番号は次のように決定されます。SNはFECヘッダーのシーケンス番号ベースです。"
    },
    {
      "indent": 4,
      "text": "For each SSRC (in CSRC list):\nWhen D <= 1: Source packets for each row: SN, SN+1, ..., SN+(L-1)\nWhen D >  1: Source packets for each col: SN, SN+L, ..., SN+(D-1)*L",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.3.2. Recovering the RTP Header",
      "section_title": true,
      "ja": "6.3.2. RTPヘッダーの回復"
    },
    {
      "indent": 3,
      "text": "For a given set T, the procedure for the recovery of the RTP header of the missing packet, whose Sequence Number is denoted by SEQNUM, is as follows:",
      "ja": "特定のセットTについて、シーケンス番号がSEQNUMで示されている欠落パケットのRTPヘッダーの回復手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. For each of the source packets that are successfully received in T, compute the 80-bit string by concatenating the first 64 bits of their RTP header and the unsigned network-ordered 16-bit representation of their length in bytes minus 12.",
      "ja": "1. Tで正常に受信された各ソースパケットについて、RTPヘッダーの最初の64ビットと、バイトから12を引いた長さの符号なしネットワーク順序16ビット表現を連結して、80ビット文字列を計算します。"
    },
    {
      "indent": 3,
      "text": "2. For the repair packet in T, extract the FEC bit string as the first 80 bits of the FEC header.",
      "ja": "2. Tの修復パケットの場合、FECヘッダーの最初の80ビットとしてFECビット文字列を抽出します。"
    },
    {
      "indent": 3,
      "text": "3. Calculate the recovered bit string as the XOR of the bit strings generated from all source packets in T and the FEC bit string generated from the repair packet in T.",
      "ja": "3. Tのすべてのソースパケットから生成されたビット文字列とTの修復パケットから生成されたFECビット文字列のXORとして、復元されたビット文字列を計算します。"
    },
    {
      "indent": 3,
      "text": "4. Create a new packet with the standard 12-byte RTP header and no payload.",
      "ja": "4. 標準の12バイトRTPヘッダーを使用してペイロードのない新しいパケットを作成します。"
    },
    {
      "indent": 3,
      "text": "5. Set the version of the new packet to 2. Skip the first 2 bits in the recovered bit string.",
      "ja": "5. 新しいパケットのバージョンを2に設定します。復元されたビット文字列の最初の2ビットをスキップします。"
    },
    {
      "indent": 3,
      "text": "6. Set the Padding bit in the new packet to the next bit in the recovered bit string.",
      "ja": "6. 新しいパケットのパディングビットを、復元されたビット文字列の次のビットに設定します。"
    },
    {
      "indent": 3,
      "text": "7. Set the Extension bit in the new packet to the next bit in the recovered bit string.",
      "ja": "7. 新しいパケットの拡張ビットを、復元されたビット文字列の次のビットに設定します。"
    },
    {
      "indent": 3,
      "text": "8. Set the CC field to the next 4 bits in the recovered bit string.",
      "ja": "8. CCフィールドを、復元されたビット文字列の次の4ビットに設定します。"
    },
    {
      "indent": 3,
      "text": "9. Set the Marker bit in the new packet to the next bit in the recovered bit string.",
      "ja": "9. 新しいパケットのマーカービットを、復元されたビット文字列の次のビットに設定します。"
    },
    {
      "indent": 3,
      "text": "10. Set the Payload type in the new packet to the next 7 bits in the recovered bit string.",
      "ja": "10. 新しいパケットのペイロードタイプを、復元されたビット文字列の次の7ビットに設定します。"
    },
    {
      "indent": 3,
      "text": "11. Set the SN field in the new packet to SEQNUM.",
      "ja": "11. 新しいパケットのSNフィールドをSEQNUMに設定します。"
    },
    {
      "indent": 3,
      "text": "12. Take the next 16 bits of the recovered bit string and set the new variable Y to whatever unsigned integer this represents (assuming network order). Convert Y to host order. Y represents the length of the new packet in bytes minus 12 (for the fixed RTP header), i.e., the sum of the lengths of all the following if present: the CSRC list, header extension, RTP payload, and RTP padding.",
      "ja": "12. 復元されたビット文字列の次の16ビットを取得し、新しい変数Yを、これが表す符号なし整数に設定します（ネットワークの順序を想定）。 Yをホスト順に変換します。 Yは、バイト単位の新しいパケットの長さ-12（固定RTPヘッダーの場合）、つまり、存在する場合はCSRCリスト、ヘッダー拡張、RTPペイロード、およびRTPパディングのすべての長さの合計を表します。"
    },
    {
      "indent": 3,
      "text": "13. Set the TS field in the new packet to the next 32 bits in the recovered bit string.",
      "ja": "13. 新しいパケットのTSフィールドを、復元されたビット文字列の次の32ビットに設定します。"
    },
    {
      "indent": 3,
      "text": "14. Set the SSRC of the new packet to the SSRC of the missing source RTP stream.",
      "ja": "14. 新しいパケットのSSRCを、欠落したソースRTPストリームのSSRCに設定します。"
    },
    {
      "indent": 3,
      "text": "This procedure recovers the header of an RTP packet up to (and including) the SSRC field.",
      "ja": "この手順では、SSRCフィールドまで（および含む）RTPパケットのヘッダーを回復します。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Recovering the RTP Payload",
      "section_title": true,
      "ja": "6.3.3. RTPペイロードの回復"
    },
    {
      "indent": 3,
      "text": "Following the recovery of the RTP header, the procedure for the recovery of the RTP \"payload\" is as follows, where \"payload\" refers to everything following the fixed 12-byte RTP header, including extensions, CSRC list, true payload, and padding.",
      "ja": "RTPヘッダーの回復後、RTPの「ペイロード」の回復手順は次のとおりです。「ペイロード」とは、拡張、CSRCリスト、真のペイロード、パディングなど、固定12バイトRTPヘッダーに続くすべてを指します。 。"
    },
    {
      "indent": 3,
      "text": "1. Allocate Y additional bytes for the new packet generated in Section 6.3.2.",
      "ja": "1. セクション6.3.2で生成された新しいパケットにYバイトを追加で割り当てます。"
    },
    {
      "indent": 3,
      "text": "2. For each of the source packets that are successfully received in T, compute the bit string from the Y octets of data starting with the 13th octet of the packet. If any of the bit strings generated from the source packets has a length shorter than Y, pad them to that length. The zero-padding octets MUST be added at the end of the bit string. Note that the information of the first 8 octets are protected by the FEC header.",
      "ja": "2. Tで正常に受信された各ソースパケットについて、パケットの13番目のオクテットから始まるデータのYオクテットからビット文字列を計算します。 ソースパケットから生成されたビット文字列のいずれかがYより短い場合、それらをその長さに埋め込みます。 ゼロパディングオクテットは、ビット文字列の最後に追加する必要があります。 最初の8オクテットの情報はFECヘッダーによって保護されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "3. For the repair packet in T, compute the FEC bit string from the repair packet payload, i.e., the Y octets of data following the FEC header. Note that the FEC header may be different sizes depending on the variant and bitmask size.",
      "ja": "3. Tの修復パケットの場合、修復パケットペイロードからFECビット文字列、つまりFECヘッダーに続くYオクテットのデータを計算します。 FECヘッダーは、バリアントとビットマスクのサイズに応じて異なるサイズになる場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "4. Calculate the recovered bit string as the XOR of the bit strings generated from all source packets in T and the FEC bit string generated from the repair packet in T.",
      "ja": "4. Tのすべてのソースパケットから生成されたビット文字列とTの修復パケットから生成されたFECビット文字列のXORとして、復元されたビット文字列を計算します。"
    },
    {
      "indent": 3,
      "text": "5. Set the last Y octets in the new packet to the recovered bit string.",
      "ja": "5. 新しいパケットの最後のYオクテットを復元されたビット文字列に設定します。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Iterative Decoding Algorithm for the 2-D Parity FEC Protection",
      "section_title": true,
      "ja": "6.3.4. 2DパリティFEC保護のための反復復号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "In 2-D parity FEC protection, the sender generates both non-interleaved and interleaved FEC repair packets to combat with the mixed loss patterns (random and bursty). At the receiver side, these FEC packets are used iteratively to overcome the shortcomings of the 1-D non-interleaved/interleaved FEC protection and improve the chances of full error recovery.",
      "ja": "2-DパリティFEC保護では、送信者は、インターリーブされていないFEC修復パケットとインターリーブされたFEC修復パケットの両方を生成して、混合損失パターン（ランダムおよびバースト）に対処します。 受信側では、これらのFECパケットを繰り返し使用して、1-D非インターリーブ/インターリーブFEC保護の欠点を克服し、完全なエラー回復の可能性を向上させます。"
    },
    {
      "indent": 3,
      "text": "The iterative decoding algorithm runs as follows:",
      "ja": "反復復号アルゴリズムは次のように実行されます。"
    },
    {
      "indent": 3,
      "text": "1. Set num_recovered_until_this_iteration to zero",
      "ja": "1. ゼロに設定num_recovered_until_this_iteration"
    },
    {
      "indent": 3,
      "text": "2. Set num_recovered_so_far to zero",
      "ja": "2. num_recovered_so_farをゼロに設定します"
    },
    {
      "indent": 3,
      "text": "3. Recover as many source packets as possible by using the non-interleaved FEC repair packets as outlined in Sections 6.3.2 and 6.3.3 and increase the value of num_recovered_so_far by the number of recovered source packets.",
      "ja": "3. セクション6.3.2および6.3.3で説明されているインターリーブされていないFEC修復パケットを使用して、できるだけ多くのソースパケットを回復し、回復されたソースパケットの数だけnum_recovered_so_farの値を増やします。"
    },
    {
      "indent": 3,
      "text": "4. Recover as many source packets as possible by using the interleaved FEC repair packets as outlined in Sections 6.3.2 and 6.3.3 and increase the value of num_recovered_so_far by the number of recovered source packets.",
      "ja": "4. セクション6.3.2および6.3.3で説明されているインターリーブFEC修復パケットを使用して、できるだけ多くのソースパケットを回復し、回復されたソースパケットの数だけnum_recovered_so_farの値を増やします。"
    },
    {
      "indent": 3,
      "text": "5. If num_recovered_so_far > num_recovered_until_this_iteration ---num_recovered_until_this_iteration = num_recovered_so_far ---Go to step 3 Else ---Terminate",
      "ja": "5. num_recovered_so_far> num_recovered_until_this_iteration --- num_recovered_until_this_iteration = num_recovered_so_far ---ステップ3に進むElse ---終了"
    },
    {
      "indent": 3,
      "text": "The algorithm terminates either when all missing source packets are fully recovered or when there are still remaining missing source packets but the FEC repair packets are not able to recover any more source packets. For the example scenarios when the 2-D parity FEC protection fails full recovery, refer to Section 1.1.4. Upon termination, variable num_recovered_so_far has a value equal to the total number of recovered source packets.",
      "ja": "アルゴリズムは、すべての欠落したソースパケットが完全に回復した場合、または欠落したソースパケットがまだ残っているが、FEC修復パケットがそれ以上ソースパケットを回復できない場合に終了します。 2-DパリティFEC保護が完全復旧に失敗するシナリオ例については、セクション1.1.4を参照してください。 終了時には、変数num_recovered_so_farの値は、回復されたソースパケットの総数に等しくなります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Suppose that the receiver experienced the loss pattern sketched in Figure 16.",
      "ja": "受信者が図16に示す損失パターンを経験したと仮定します。"
    },
    {
      "indent": 23,
      "text": "            +---+  +---+  +===+\nX      X    | 3 |  | 4 |  |R_1|\n            +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+                +---+  +===+\n| 9 |    X      X    | 12|  |R_3|\n+---+                +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 16: Example: Loss Pattern for the Iterative Decoding Algorithm",
      "ja": "図16：例：反復復号化アルゴリズムの損失パターン"
    },
    {
      "indent": 3,
      "text": "The receiver executes the iterative decoding algorithm and recovers source packets #1 and #11 in the first iteration. The resulting pattern is sketched in Figure 17.",
      "ja": "受信機は反復復号アルゴリズムを実行し、最初の反復でソースパケット＃1と＃11を復元します。 結果のパターンを図17に示します。"
    },
    {
      "indent": 21,
      "text": "+---+         +---+  +---+  +===+\n| 1 |    X    | 3 |  | 4 |  |R_1|\n+---+         +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+         +---+  +---+  +===+\n| 9 |    X    | 11|  | 12|  |R_3|\n+---+         +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 17: The Resulting Pattern after the First Iteration",
      "ja": "図17：最初の反復後の結果パターン"
    },
    {
      "indent": 3,
      "text": "Since the if condition holds true, the receiver runs a new iteration. In the second iteration, source packets #2 and #10 are recovered, resulting in a full recovery as sketched in Figure 18.",
      "ja": "if条件が真であるため、レシーバーは新しい反復を実行します。 2回目の反復では、ソースパケット＃2と＃10が回復され、図18に示すように完全に回復します。"
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 1 |  | 2 |  | 3 |  | 4 |  |R_1|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 5 |  | 6 |  | 7 |  | 8 |  |R_2|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---+  +---+  +---+  +---+  +===+\n| 9 |  | 10|  | 11|  | 12|  |R_3|\n+---+  +---+  +---+  +---+  +===+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+===+  +===+  +===+  +===+\n|C_1|  |C_2|  |C_3|  |C_4|\n+===+  +===+  +===+  +===+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 18: The Resulting Pattern after the Second Iteration",
      "ja": "図18：2回目の反復後の結果パターン"
    },
    {
      "indent": 0,
      "text": "7. Signaling Requirements",
      "section_title": true,
      "ja": "7. シグナリング要件"
    },
    {
      "indent": 3,
      "text": "Out-of-band signaling should be designed to enable the receiver to identify the RTP streams associated with source packets and repair packets, respectively. At a minimum, the signaling must be designed to allow the receiver to:",
      "ja": "帯域外シグナリングは、受信側がそれぞれソースパケットと修復パケットに関連付けられたRTPストリームを識別できるように設計する必要があります。 少なくとも、受信者が以下を行えるようにシグナリングを設計する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Determine whether one or more source RTP streams will be sent.",
      "ja": "o 1つ以上のソースRTPストリームが送信されるかどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "o Determine whether one or more repair RTP streams will be sent.",
      "ja": "o 1つ以上の修復RTPストリームを送信するかどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "o Associate the appropriate SSRC's to both source and repair streams.",
      "ja": "o 適切なSSRCをソースストリームと修復ストリームの両方に関連付けます。"
    },
    {
      "indent": 3,
      "text": "o Clearly identify which SSRC's are associated with each source block.",
      "ja": "o 各SSRCが各ソースブロックに関連付けられていることを明確に識別します。"
    },
    {
      "indent": 3,
      "text": "o Clearly identify which repair packets correspond to which source blocks.",
      "ja": "o どの修復パケットがどのソースブロックに対応するかを明確に識別します。"
    },
    {
      "indent": 3,
      "text": "o Make use of repair packets to recover source data associated with specific SSRC's.",
      "ja": "o 修復パケットを使用して、特定のSSRCに関連付けられたソースデータを回復します。"
    },
    {
      "indent": 3,
      "text": "This section provides several Session Description Protocol (SDP) examples to demonstrate how these requirements can be met.",
      "ja": "このセクションでは、これらの要件を満たす方法を示すために、いくつかのSession Description Protocol（SDP）の例を示します。"
    },
    {
      "indent": 0,
      "text": "7.1. SDP Examples",
      "section_title": true,
      "ja": "7.1. SDPの例"
    },
    {
      "indent": 3,
      "text": "This section provides two SDP [RFC4566] examples. The examples use the FEC grouping semantics defined in [RFC5956].",
      "ja": "このセクションでは、2つのSDP [RFC4566]の例を示します。 例では、[RFC5956]で定義されているFECグループ化セマンティクスを使用しています。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Example SDP for Flexible FEC Protection with In-Band SSRC Mapping",
      "ja": "7.1.1. インバンドSSRCマッピングによる柔軟なFEC保護のための例SDP"
    },
    {
      "indent": 3,
      "text": "In this example, we have one source video stream and one FEC repair stream. The source and repair streams are multiplexed on different SSRCs. The repair window is set to 200 ms.",
      "ja": "この例では、1つのソースビデオストリームと1つのFEC修復ストリームがあります。 ソースストリームと修復ストリームは、異なるSSRCで多重化されます。 修復ウィンドウは200ミリ秒に設定されています。"
    },
    {
      "indent": 8,
      "text": "v=0\no=mo 1122334455 1122334466 IN IP4 fec.example.com\ns=FlexFEC minimal SDP signaling Example\nt=0 0\nm=video 30000 RTP/AVP 96 98\nc=IN IP4 233.252.0.1/127\na=rtpmap:96 VP8/90000\na=rtpmap:98 flexfec/90000\na=fmtp:98; repair-window=200000",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.1.2. Example SDP for Flexible FEC Protection with Explicit Signaling in the SDP",
      "ja": "7.1.2. SDPで明示的なシグナリングを使用した柔軟なFEC保護のためのSDPの例"
    },
    {
      "indent": 3,
      "text": "This example shows one source video stream (ssrc:1234) and one FEC repair streams (ssrc:2345). One FEC group is formed with the \"a=ssrc-group:FEC-FR 1234 2345\" line. The source and repair streams are multiplexed on different SSRCs. The repair window is set to 200 ms.",
      "ja": "この例は、1つのソースビデオストリーム（ssrc：1234）と1つのFEC修復ストリーム（ssrc：2345）を示しています。 1つのFECグループは、「a = ssrc-group：FEC-FR 1234 2345」行で形成されます。 ソースストリームと修復ストリームは、異なるSSRCで多重化されます。 修復ウィンドウは200ミリ秒に設定されています。"
    },
    {
      "indent": 8,
      "text": "v=0\no=ali 1122334455 1122334466 IN IP4 fec.example.com\ns=2-D Parity FEC with no in band signaling Example\nt=0 0\nm=video 30000 RTP/AVP 100 110\nc=IN IP4 192.0.2.0/24\na=rtpmap:100 MP2T/90000\na=rtpmap:110 flexfec/90000\na=fmtp:110; repair-window:200000\na=ssrc:1234\na=ssrc:2345\na=ssrc-group:FEC-FR 1234 2345",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. On the Use of the RTP Stream Identifier Source Description",
      "section_title": true,
      "ja": "7.2. RTP Stream Identifier Source Descriptionの使用について"
    },
    {
      "indent": 3,
      "text": "The RTP Stream Identifier Source Description [RTP-SDES] is a format that can be used to identify a single RTP source stream along with an associated repair stream. However, this specification already defines a method of source and repair stream identification that can enable protection of multiple source streams with a single repair stream. Therefore, the RTP Stream Identifier Source Description SHOULD NOT be used for the Flexible FEC payload format.",
      "ja": "RTP Stream Identifier Source Description [RTP-SDES]は、単一のRTPソースストリームと関連する修復ストリームを識別するために使用できる形式です。 ただし、この仕様では、単一の修復ストリームで複数のソースストリームを保護できるソースおよび修復ストリームの識別方法が既に定義されています。 したがって、RTP Stream Identifier Source Descriptionは、Flexible FECペイロード形式には使用しないでください。"
    },
    {
      "indent": 0,
      "text": "8. Congestion Control Considerations",
      "section_title": true,
      "ja": "8. 輻輳制御の考慮事項"
    },
    {
      "indent": 3,
      "text": "FEC is an effective approach to provide applications resiliency against packet losses. However, in networks where the congestion is a major contributor to the packet loss, the potential impacts of using FEC should be considered carefully before injecting the repair streams into the network. In particular, in bandwidth-limited networks, FEC repair streams may consume a significant part of the available bandwidth and, consequently, may congest the network. In such cases, the applications MUST NOT arbitrarily increase the amount of FEC protection since doing so may lead to a congestion collapse. If desired, stronger FEC protection MAY be applied only after the source rate has been reduced.",
      "ja": "FECは、パケット損失に対するアプリケーションの復元力を提供するための効果的なアプローチです。 ただし、輻輳がパケット損失の主な原因となるネットワークでは、ネットワークに修復ストリームを注入する前に、FECを使用する潜在的な影響を慎重に検討する必要があります。 特に、帯域幅が制限されたネットワークでは、FEC修復ストリームが利用可能な帯域幅のかなりの部分を消費する可能性があり、その結果、ネットワークを混雑させる可能性があります。 このような場合、アプリケーションはFEC保護の量をarbitrarily意的に増加させてはなりません。これを行うと、輻輳が崩壊する可能性があるためです。 必要に応じて、ソースレートが低下した後にのみ、より強力なFEC保護を適用できます。"
    },
    {
      "indent": 3,
      "text": "In a network-friendly implementation, an application should avoid sending/receiving FEC repair streams if it knows that sending/ receiving those FEC repair streams would not help at all in recovering the missing packets. Examples of where FEC would not be beneficial are (1) if the successful recovery rate as determined by RTCP feedback is low (see [RFC5725] and [RFC7509] and (2) the application has a smaller latency requirement than the repair window adopted by the FEC configuration based on the expected burst loss duration and the target FEC overhead. It is RECOMMENDED that the amount and type (row, column, or both) of FEC protection is adjusted dynamically based on the packet loss rate and burst loss length observed by the applications.",
      "ja": "ネットワークフレンドリーな実装では、アプリケーションは、それらのFEC修復ストリームの送信/受信が失われたパケットの回復にまったく役に立たないことがわかっている場合、FEC修復ストリームの送受信を回避する必要があります。 FECが有益ではない例は、（1）RTCPフィードバックによって決定される正常な回復率が低い場合（[RFC5725]および[RFC7509]を参照）、および（2）アプリケーションが採用する修復ウィンドウよりも小さいレイテンシ要件を持っている場合です。 予想されるバースト損失期間とターゲットFECオーバーヘッドに基づくFEC構成FEC保護の量とタイプ（行、列、または両方）が、パケット損失率とバースト損失長に基づいて動的に調整されることが推奨される アプリケーション。"
    },
    {
      "indent": 3,
      "text": "In multicast scenarios, it may be difficult to optimize the FEC protection per receiver. If there is a large variation among the levels of FEC protection needed by different receivers, it is RECOMMENDED that the sender offer multiple repair streams with different levels of FEC protection and the receivers join the corresponding multicast sessions to receive the repair stream(s) that is best for them.",
      "ja": "マルチキャストシナリオでは、受信機ごとにFEC保護を最適化するのが難しい場合があります。 異なる受信者が必要とするFEC保護のレベルに大きなばらつきがある場合、送信者が異なるレベルのFEC保護を備えた複数の修復ストリームを提供し、受信者が対応するマルチキャストセッションに参加して修復ストリームを受信することをお勧めします 彼らに最適です。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [RFC3550] and in any applicable RTP profile. The main security considerations for the RTP packet carrying the RTP payload format defined within this memo are confidentiality, integrity, and source authenticity. Confidentiality can be provided by encrypting the RTP payload. Integrity of the RTP packets is achieved through a suitable cryptographic integrity protection mechanism. Such a cryptographic system may also allow the authentication of the source of the payload. A suitable security mechanism for this RTP payload format should provide confidentiality, integrity protection, and at least source authentication capable of determining if an RTP packet is from a member of the RTP session.",
      "ja": "この仕様で定義されたペイロード形式を使用するRTPパケットは、RTP仕様[RFC3550]および適用可能なRTPプロファイルで説明されているセキュリティの考慮事項に従います。 このメモ内で定義されたRTPペイロード形式を伝送するRTPパケットの主なセキュリティ上の考慮事項は、機密性、整合性、および送信元の信頼性です。 RTPペイロードを暗号化することにより、機密性を確保できます。 RTPパケットの整合性は、適切な暗号整合性保護メカニズムによって実現されます。 このような暗号化システムでは、ペイロードのソースの認証も許可されます。 このRTPペイロード形式に適したセキュリティメカニズムは、機密性、整合性保護、および少なくともRTPパケットがRTPセッションのメンバーからのものかどうかを判断できるソース認証を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the appropriate mechanism to provide security to RTP and payloads following this memo may vary. It is dependent on the application, transport, and signaling protocol employed. Therefore, a single mechanism is not sufficient; although, if suitable, using the Secure Real-time Transport Protocol (SRTP) [RFC3711] is recommended. Other mechanisms that may be used are IPsec [RFC4301], and Datagram Transport Layer Security (DTLS, see [RFC6347]) when used along with RTP-over-UDP; other alternatives may exist.",
      "ja": "このメモに続くRTPとペイロードにセキュリティを提供する適切なメカニズムが異なることに注意してください。 使用されるアプリケーション、トランスポート、およびシグナリングプロトコルに依存します。 したがって、単一のメカニズムでは十分ではありません。 ただし、適切な場合は、セキュアリアルタイムトランスポートプロトコル（SRTP）[RFC3711]を使用することをお勧めします。 使用できる他のメカニズムは、IPsec [RFC4301]、およびRTP-over-UDPと共に使用される場合のデータグラムトランスポート層セキュリティ（DTLS、[RFC6347]を参照）です。 他の選択肢が存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "Given that FLEX FEC enables the protection of multiple source streams, there exists the possibility that multiple source buffers may be created that may not be used. An attacker could leverage unused source buffers as a means of occupying memory in a FLEX FEC endpoint. In addition, an attack against the FEC parameters themselves (e.g., repair window or D or L values) can result in a receiver having to allocate source buffer space that may also lead to excessive consumption of resources. Similarly, a network attacker could modify the recovery fields corresponding to packet lengths (assuming there are no message integrity mechanisms), which, in turn, could force unnecessarily large memory allocations at the receiver. Moreover, the application source data may not be perfectly matched with FLEX FEC Source partitioning. If this is the case, there is a possibility for unprotected source data if, for instance, the FLEX FEC implementation discards data that does not fit perfectly into its source processing requirements.",
      "ja": "FLEX FECにより複数のソースストリームを保護できるため、使用されない可能性のある複数のソースバッファーが作成される可能性があります。攻撃者は、FLEX FECエンドポイントでメモリを占有する手段として、未使用のソースバッファを利用する可能性があります。さらに、FECパラメーター自体（たとえば、修復ウィンドウまたはDまたはL値）に対する攻撃により、レシーバーはソースバッファースペースを割り当てる必要があり、リソースの過剰な消費につながる可能性があります。同様に、ネットワーク攻撃者は、パケットの長さに対応する回復フィールドを変更し（メッセージ整合性メカニズムがないと仮定）、受信機で不必要に大きなメモリ割り当てを強制する可能性があります。さらに、アプリケーションのソースデータは、FLEX FECソースパーティショニングと完全に一致しない場合があります。この場合、たとえば、FLEX FEC実装がソース処理要件に完全に適合しないデータを破棄する場合、保護されていないソースデータの可能性があります。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "New media subtypes are subject to IANA registration. For the registration of the payload formats and their parameters introduced in this document, refer to Section 5.1.",
      "ja": "新しいメディアサブタイプは、IANA登録の対象です。 このドキュメントで紹介されているペイロード形式とそのパラメータの登録については、セクション5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, DOI 10.17487/RFC3264, June 2002, <https://www.rfc-editor.org/info/rfc3264>.",
      "ja": "[RFC3264] Rosenberg、J。、およびH. Schulzrinne、「セッション記述プロトコル（SDP）を備えたオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org / info / rfc3264>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <https://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーションのトランスポートプロトコル」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <https://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <https://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566] Handley、M.、Jacobson、V。、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/ info / rfc4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4855] Casner, S., \"Media Type Registration of RTP Payload Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007, <https://www.rfc-editor.org/info/rfc4855>.",
      "ja": "[RFC4855] Casner、S。、「RTPペイロードフォーマットのメディアタイプ登録」、RFC 4855、DOI 10.17487 / RFC4855、2007年2月、<https://www.rfc-editor.org/info/rfc4855>。"
    },
    {
      "indent": 3,
      "text": "[RFC4856] Casner, S., \"Media Type Registration of Payload Formats in the RTP Profile for Audio and Video Conferences\", RFC 4856, DOI 10.17487/RFC4856, February 2007, <https://www.rfc-editor.org/info/rfc4856>.",
      "ja": "[RFC4856] Casner、S.、「オーディオおよびビデオ会議用のRTPプロファイルでのペイロード形式のメディアタイプ登録」、RFC 4856、DOI 10.17487 / RFC4856、2007年2月、<https://www.rfc-editor.org/ info / rfc4856>。"
    },
    {
      "indent": 3,
      "text": "[RFC5956] Begen, A., \"Forward Error Correction Grouping Semantics in the Session Description Protocol\", RFC 5956, DOI 10.17487/RFC5956, September 2010, <https://www.rfc-editor.org/info/rfc5956>.",
      "ja": "[RFC5956] Begen、A。、「セッション記述プロトコルの前方誤り訂正グループ化セマンティクス」、RFC 5956、DOI 10.17487 / RFC5956、2010年9月、<https://www.rfc-editor.org/info/rfc5956>。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, DOI 10.17487/RFC6363, October 2011, <https://www.rfc-editor.org/info/rfc6363>.",
      "ja": "[RFC6363] Watson、M.、Begen、A。、およびV. Roca、「Forward Error Correction（FEC）Framework」、RFC 6363、DOI 10.17487 / RFC6363、2011年10月、<https：//www.rfc-editor。 org / info / rfc6363>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J。、およびT. Hansen、「Media Type Specifications and Registration Procedures」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<https：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7022] Begen, A., Perkins, C., Wing, D., and E. Rescorla, \"Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)\", RFC 7022, DOI 10.17487/RFC7022, September 2013, <https://www.rfc-editor.org/info/rfc7022>.",
      "ja": "[RFC7022] Begen、A.、Perkins、C.、Wing、D。、およびE. Rescorla、「RTP Control Protocol（RTCP）Canonical Names（CNAME）を選択するためのガイドライン」、RFC 7022、DOI 10.17487 / RFC7022、2013年9月 、<https://www.rfc-editor.org/info/rfc7022>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC2326] Schulzrinne, H., Rao, A., and R. Lanphier, \"Real Time Streaming Protocol (RTSP)\", RFC 2326, DOI 10.17487/RFC2326, April 1998, <https://www.rfc-editor.org/info/rfc2326>.",
      "ja": "[RFC2326] Schulzrinne、H.、Rao、A。、およびR. Lanphier、「リアルタイムストリーミングプロトコル（RTSP）」、RFC 2326、DOI 10.17487 / RFC2326、1998年4月、<https：//www.rfc-editor。 org / info / rfc2326>。"
    },
    {
      "indent": 3,
      "text": "[RFC2733] Rosenberg, J. and H. Schulzrinne, \"An RTP Payload Format for Generic Forward Error Correction\", RFC 2733, DOI 10.17487/RFC2733, December 1999, <https://www.rfc-editor.org/info/rfc2733>.",
      "ja": "[RFC2733] Rosenberg、J。、およびH. Schulzrinne、「Generic Forward Error CorrectionのRTPペイロード形式」、RFC 2733、DOI 10.17487 / RFC2733、1999年12月、<https://www.rfc-editor.org/info/ rfc2733>。"
    },
    {
      "indent": 3,
      "text": "[RFC2974] Handley, M., Perkins, C., and E. Whelan, \"Session Announcement Protocol\", RFC 2974, DOI 10.17487/RFC2974, October 2000, <https://www.rfc-editor.org/info/rfc2974>.",
      "ja": "[RFC2974] Handley、M.、Perkins、C。、およびE. Whelan、「Session Announcement Protocol」、RFC 2974、DOI 10.17487 / RFC2974、2000年10月、<https://www.rfc-editor.org/info/ rfc2974>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「セキュアリアルタイムトランスポートプロトコル（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月 2004、<https://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, DOI 10.17487/RFC4301, December 2005, <https://www.rfc-editor.org/info/rfc4301>.",
      "ja": "[RFC4301] Kent、S.、K。Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、DOI 10.17487 / RFC4301、2005年12月、<https://www.rfc-editor.org/info/rfc4301>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <https://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585]オット、J。、ウェンガー、S。、佐藤、N。、バーマイスター、C。、およびJ.レイ、「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / AVPF）の拡張RTPプロファイル \"、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<https://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC4588] Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, \"RTP Retransmission Payload Format\", RFC 4588, DOI 10.17487/RFC4588, July 2006, <https://www.rfc-editor.org/info/rfc4588>.",
      "ja": "[RFC4588]レイ、J。、レオン、D。、宮崎、A。、バルサ、V。、およびR.ハケンベルク、「RTP再送信ペイロード形式」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<https：/ /www.rfc-editor.org/info/rfc4588>。"
    },
    {
      "indent": 3,
      "text": "[RFC5109] Li, A., Ed., \"RTP Payload Format for Generic Forward Error Correction\", RFC 5109, DOI 10.17487/RFC5109, December 2007, <https://www.rfc-editor.org/info/rfc5109>.",
      "ja": "[RFC5109] Li、A.、Ed。、「一般的な前方誤り訂正のためのRTPペイロード形式」、RFC 5109、DOI 10.17487 / RFC5109、2007年12月、<https://www.rfc-editor.org/info/rfc5109> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5725] Begen, A., Hsu, D., and M. Lague, \"Post-Repair Loss RLE Report Block Type for RTP Control Protocol (RTCP) Extended Reports (XRs)\", RFC 5725, DOI 10.17487/RFC5725, February 2010, <https://www.rfc-editor.org/info/rfc5725>.",
      "ja": "[RFC5725] Begen、A.、Hsu、D。、およびM. Lague、「RTP制御プロトコル（RTCP）拡張レポート（XR）の修復後損失RLEレポートブロックタイプ」、RFC 5725、DOI 10.17487 / RFC5725、2月 2010、<https://www.rfc-editor.org/info/rfc5725>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「データグラムトランスポートレイヤーセキュリティバージョン1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC7509] Huang, R. and V. Singh, \"RTP Control Protocol (RTCP) Extended Report (XR) for Post-Repair Loss Count Metrics\", RFC 7509, DOI 10.17487/RFC7509, May 2015, <https://www.rfc-editor.org/info/rfc7509>.",
      "ja": "[RFC7509] Huang、R.およびV. Singh、「修理後の損失カウントメトリックのRTPコントロールプロトコル（RTCP）拡張レポート（XR）」、RFC 7509、DOI 10.17487 / RFC7509、2015年5月、<https：// www .rfc-editor.org / info / rfc7509>。"
    },
    {
      "indent": 3,
      "text": "[RFC7656] Lennox, J., Gross, K., Nandakumar, S., Salgueiro, G., and B. Burman, Ed., \"A Taxonomy of Semantics and Mechanisms for Real-Time Transport Protocol (RTP) Sources\", RFC 7656, DOI 10.17487/RFC7656, November 2015, <https://www.rfc-editor.org/info/rfc7656>.",
      "ja": "[RFC7656] Lennox、J.、Gross、K.、Nandakumar、S.、Salgueiro、G。、およびB. Burman、Ed。、「リアルタイムトランスポートプロトコル（RTP）ソースのセマンティクスおよびメカニズムの分類」、 RFC 7656、DOI 10.17487 / RFC7656、2015年11月、<https://www.rfc-editor.org/info/rfc7656>。"
    },
    {
      "indent": 3,
      "text": "[RFC7826] Schulzrinne, H., Rao, A., Lanphier, R., Westerlund, M., and M. Stiemerling, Ed., \"Real-Time Streaming Protocol Version 2.0\", RFC 7826, DOI 10.17487/RFC7826, December 2016, <https://www.rfc-editor.org/info/rfc7826>.",
      "ja": "[RFC7826] Schulzrinne、H.、Rao、A.、Lanphier、R.、Westerlund、M。、およびM. Stiemerling、Ed。、「リアルタイムストリーミングプロトコルバージョン2.0」、RFC 7826、DOI 10.17487 / RFC7826、12月 2016年、<https://www.rfc-editor.org/info/rfc7826>。"
    },
    {
      "indent": 3,
      "text": "[RTP-SDES] Roach, A., Nandakumar, S., and P. Thatcher, \"RTP Stream Identifier Source Description (SDES)\", Work in Progress, draft-ietf-avtext-rid-09, October 2016.",
      "ja": "[RTP-SDES]ローチ、A。、ナンダクマール、S.、P。サッチャー、「RTPストリーム識別子ソース記述（SDES）」、Work in Progress、draft-ietf-avtext-rid-09、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[SMPTE2022-1] SMPTE, \"Forward Error Correction for Real-Time Video/Audio Transport over IP Networks\", ST 2022-1:2007, SMPTE Standard, DOI 10.5594/SMPTE.ST2022-1.2007, May 2007.",
      "ja": "[SMPTE2022-1] SMPTE、「IPネットワークを介したリアルタイムビデオ/オーディオトランスポートの前方誤り訂正」、ST 2022-1：2007、SMPTE標準、DOI 10.5594 / SMPTE.ST2022-1.2007、2007年5月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Some parts of this document are borrowed from [RFC5109]. Thus, the author would like to thank the editor of [RFC5109] and those who contributed to [RFC5109].",
      "ja": "このドキュメントの一部は[RFC5109]から借用しています。 したがって、著者は[RFC5109]の編集者と[RFC5109]に貢献した人々に感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Thanks to Stephen Botzko, Bernard Aboba, Rasmus Brandt, Brian Baldino, Roni Even, Stefan Holmer, Jonathan Lennox, and Magnus Westerlund for providing valuable feedback on earlier draft versions of this document.",
      "ja": "このドキュメントの以前のドラフトバージョンの貴重なフィードバックを提供するためのスティーブン・Botzko、バーナードAboba、ラスマス・ブラント、ブライアンBaldino、ロニでも、ステファンHolmer、ジョナサン・レノックス、およびマグヌスウェスターに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mo Zanaty Cisco Raleigh, NC United States of America",
      "ja": "Mo Zanaty Ciscoローリー、ノースカロライナ州アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: mzanaty@cisco.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Varun Singh CALLSTATS I/O Oy Annankatu 31-33 C 42 Helsinki 00101 Finland",
      "ja": "Varun Singh CALLSTATS I / O Oy Annankatu 31-33 C 42 Helsinki 00101 Finland"
    },
    {
      "indent": 3,
      "text": "Email: varun.singh@iki.fi\nURI:   http://www.callstats.io/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Ali Begen Networked Media Konya Turkey",
      "ja": "Ali Begen Networked Mediaコンヤトルコ"
    },
    {
      "indent": 3,
      "text": "Email: ali.begen@networked.media",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Giridhar Mandyam Qualcomm Inc. 5775 Morehouse Drive San Diego, CA 92121 United States of America",
      "ja": "Giridhar Mandyam Qualcomm Inc. 5775 Morehouse Drive San Diego、CA 92121アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 858 651 7200\nEmail: mandyam@qti.qualcomm.com",
      "raw": true
    }
  ]
}