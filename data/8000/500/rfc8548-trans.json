{
  "title": {
    "text": "RFC 8548 - Cryptographic Protection of TCP Streams (tcpcrypt)",
    "ja": "RFC 8548 - TCPストリームの暗号保護（tcpcrypt）"
  },
  "number": 8548,
  "created_at": "2019-10-29 23:50:28.791167+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         A. Bittau\nRequest for Comments: 8548                                        Google\nCategory: Experimental                                         D. Giffin\nISSN: 2070-1721                                      Stanford University\n                                                              M. Handley\n                                               University College London\n                                                             D. Mazieres\n                                                     Stanford University\n                                                                Q. Slack\n                                                             Sourcegraph\n                                                                E. Smith\n                                                       Kestrel Institute\n                                                                May 2019",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Cryptographic Protection of TCP Streams (tcpcrypt)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies \"tcpcrypt\", a TCP encryption protocol designed for use in conjunction with the TCP Encryption Negotiation Option (TCP-ENO). Tcpcrypt coexists with middleboxes by tolerating resegmentation, NATs, and other manipulations of the TCP header. The protocol is self-contained and specifically tailored to TCP implementations, which often reside in kernels or other environments in which large external software dependencies can be undesirable. Because the size of TCP options is limited, the protocol requires one additional one-way message latency to perform key exchange before application data can be transmitted. However, the extra latency can be avoided between two hosts that have recently established a previous tcpcrypt connection.",
      "ja": "この文書では、「tcpcrypt」、TCP暗号化交渉オプション（TCP-ENO）と組み合わせて使用​​するために設計されたTCPの暗号化プロトコルを指定します。 Tcpcryptは再セグメンテーション、NATを、TCPヘッダの他の操作を許容することによって中間装置と共存します。プロトコルは、自己完結型と特異的にしばしば大きな外部ソフトウェア依存関係が望ましくないことが可能なカーネル又は他の環境に存在するTCP実装に調整されます。 TCPオプションのサイズが限られているため、プロトコルは、アプリケーションデータが送信される前に鍵交換を実行するために、1つの追加の一方向メッセージの待ち時間が必要です。しかし、余分な待ち時間は、最近、以前tcpcrypt接続が確立されている2つのホスト間に回避することができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書はインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8548.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8548で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2019 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   4\n3.  Encryption Protocol . . . . . . . . . . . . . . . . . . . . .   4\n  3.1.  Cryptographic Algorithms  . . . . . . . . . . . . . . . .   4\n  3.2.  Protocol Negotiation  . . . . . . . . . . . . . . . . . .   6\n  3.3.  Key Exchange  . . . . . . . . . . . . . . . . . . . . . .   7\n  3.4.  Session ID  . . . . . . . . . . . . . . . . . . . . . . .  10\n  3.5.  Session Resumption  . . . . . . . . . . . . . . . . . . .  10\n  3.6.  Data Encryption and Authentication  . . . . . . . . . . .  14\n  3.7.  TCP Header Protection . . . . . . . . . . . . . . . . . .  16\n  3.8.  Rekeying  . . . . . . . . . . . . . . . . . . . . . . . .  16\n  3.9.  Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . .  17\n4.  Encodings . . . . . . . . . . . . . . . . . . . . . . . . . .  18\n  4.1.  Key-Exchange Messages . . . . . . . . . . . . . . . . . .  18\n  4.2.  Encryption Frames . . . . . . . . . . . . . . . . . . . .  20\n    4.2.1.  Plaintext . . . . . . . . . . . . . . . . . . . . . .  20\n    4.2.2.  Associated Data . . . . . . . . . . . . . . . . . . .  21\n    4.2.3.  Frame ID  . . . . . . . . . . . . . . . . . . . . . .  21\n  4.3.  Constant Values . . . . . . . . . . . . . . . . . . . . .  22\n5.  Key-Agreement Schemes . . . . . . . . . . . . . . . . . . . .  22\n6.  AEAD Algorithms . . . . . . . . . . . . . . . . . . . . . . .  24\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25\n  8.1.  Asymmetric Roles  . . . . . . . . . . . . . . . . . . . .  27\n  8.2.  Verified Liveness . . . . . . . . . . . . . . . . . . . .  27\n  8.3.  Mandatory Key-Agreement Schemes . . . . . . . . . . . . .  27\n9.  Experiments . . . . . . . . . . . . . . . . . . . . . . . . .  28\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  29\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  30\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31\nContributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  31\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes tcpcrypt, an extension to TCP for cryptographic protection of session data. Tcpcrypt was designed to meet the following goals:",
      "ja": "この文書では、セッションデータの暗号保護のためにTCPに拡張子をtcpcryptについて説明します。 Tcpcryptは、次の目標を満たすように設計されました："
    },
    {
      "indent": 3,
      "text": "o Meet the requirements of the TCP Encryption Negotiation Option (TCP-ENO) [RFC8547] for protecting connection data.",
      "ja": "O接続データを保護するためのTCP暗号化交渉オプション（TCP-ENO）[RFC8547]の要件を満たしています。"
    },
    {
      "indent": 3,
      "text": "o Be amenable to small, self-contained implementations inside TCP stacks.",
      "ja": "O TCPスタックの中に小さな、自己完結型の実装に適して。"
    },
    {
      "indent": 3,
      "text": "o Minimize additional latency at connection startup.",
      "ja": "O接続の起動時に追加の遅延を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "o As much as possible, prevent connection failure in the presence of NATs and other middleboxes that might normalize traffic or otherwise manipulate TCP segments.",
      "ja": "O可能な限り、トラフィックを正規化または他の方法でTCPセグメントを操作する可能性があるのNATや他の中間装置の存在下での接続不良を防止します。"
    },
    {
      "indent": 3,
      "text": "o Operate independently of IP addresses, making it possible to authenticate resumed sessions efficiently even when either end changes IP address.",
      "ja": "Oが可能認証するようになって、独立してIPアドレスの操作両端にはIPアドレスを変更した場合でも効率的にセッションを再開しました。"
    },
    {
      "indent": 3,
      "text": "A companion document [TCPINC-API] describes recommended interfaces for configuring certain parameters of this protocol.",
      "ja": "仲間ドキュメント[TCPINC-APIは、このプロトコルの特定のパラメータを設定するための推奨されるインタフェースを記述する。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "3. Encryption Protocol",
      "section_title": true,
      "ja": "3.暗号化プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of the tcpcrypt protocol. The wire format of all messages is specified in Section 4.",
      "ja": "このセクションでは、tcpcryptプロトコルの動作を説明します。すべてのメッセージのワイヤ形式は、セクション4で指定されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Cryptographic Algorithms",
      "section_title": true,
      "ja": "3.1。暗号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Setting up a tcpcrypt connection employs three types of cryptographic algorithms:",
      "ja": "tcpcrypt接続を設定するには、暗号アルゴリズムの3種類を採用しています。"
    },
    {
      "indent": 3,
      "text": "o A key agreement scheme is used with a short-lived public key to agree upon a shared secret.",
      "ja": "Oキー合意方式は、共有秘密に同意する短命の公開鍵で使用されています。"
    },
    {
      "indent": 3,
      "text": "o An extract function is used to generate a pseudo-random key (PRK) from some initial keying material produced by the key agreement scheme. The notation Extract(S, IKM) denotes the output of the extract function with salt S and initial keying material IKM.",
      "ja": "O抽出機能は、キー合意方式によって生成さいくつかの初期キーイングマテリアルから擬似ランダム鍵（PRK）を生成するために使用されます。表記抽出物（S、IKM）が塩Sと抽出機能と、初期鍵材料IKMの出力を表します。"
    },
    {
      "indent": 3,
      "text": "o A collision-resistant pseudo-random function (CPRF) is used to generate multiple cryptographic keys from a pseudo-random key, typically the output of the extract function. The CPRF produces an arbitrary amount of Output Keying Material (OKM), and we use the notation CPRF(K, CONST, L) to designate the first L bytes of the OKM produced by the CPRF when parameterized by key K and the constant CONST.",
      "ja": "O衝突耐性擬似ランダム関数（CPRF）は、擬似ランダムキー、抽出機能の典型的出力から複数の暗号鍵を生成するために使用されます。 CPRFは、出力鍵材料（OKM）の任意の量を生成し、そして我々は鍵Kと定数CONSTによってパラメータ場合CPRFによって生成OKMの最初のLバイトを指定する表記CPRF（K、CONST、L）を使用します。"
    },
    {
      "indent": 3,
      "text": "The Extract and CPRF functions used by the tcpcrypt variants defined in this document are the Extract and Expand functions of the HMAC-based Key Derivation Function (HKDF) [RFC5869], which is built on Keyed-Hashing for Message Authentication (HMAC) [RFC2104]. These are defined as follows in terms of the function HMAC-Hash(key, value) for a negotiated Hash function such as SHA-256; the symbol \"|\" denotes concatenation, and the counter concatenated to the right of CONST occupies a single octet.",
      "ja": "この文書で定義されたtcpcryptバリアントで使用エキスとCPRF機能が抽出され、メッセージ認証（HMAC）[RFC2104のための鍵付きハッシング上に構築されHMACベースの鍵導出関数（HKDF）[RFC5869]の機能を拡張します]。そのようなSHA-256のようなネゴシエートハッシュ関数の関数HMAC-ハッシュ（キー、値）の観点から次のようにこれらが定義されています。記号「|」連結を表し、CONSTの右側に連結カウンタは、単一のオクテットを占有します。"
    },
    {
      "indent": 11,
      "text": "HKDF-Extract(salt, IKM) -> PRK\n   PRK = HMAC-Hash(salt, IKM)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "HKDF-Expand(PRK, CONST, L) -> OKM T(0) = empty string (zero length) T(1) = HMAC-Hash(PRK, T(0) | CONST | 0x01) T(2) = HMAC-Hash(PRK, T(1) | CONST | 0x02) T(3) = HMAC-Hash(PRK, T(2) | CONST | 0x03) ...",
      "ja": "HKDF-展開（PRK、CONST、L）を - > OKM T（0）=空の文字列（長さゼロ）T（1）= HMAC-ハッシュ（PRK、T（0）| CONST | 0x01の）T（2）= HMAC - ハッシュ（PRK、T（1）| CONST | 0x02の）T（3）= HMAC-ハッシュ（PRK、T（2）| CONST | 0×03）···"
    },
    {
      "indent": 14,
      "text": "OKM = first L octets of T(1) | T(2) | T(3) | ... where L <= 255*OutputLength(Hash)",
      "ja": "OKMは=最初のL Tのオクテット（1）| T（2）| T（3）| ...ここで、L <= 255 * OutputLength（ハッシュ）"
    },
    {
      "indent": 13,
      "text": "Figure 1: HKDF Functions Used for Key Derivation",
      "ja": "図1：キー導出するために使用さHKDF機能"
    },
    {
      "indent": 3,
      "text": "Lastly, once tcpcrypt has been successfully set up and encryption keys have been derived, an algorithm for Authenticated Encryption with Associated Data (AEAD) is used to protect the confidentiality and integrity of all transmitted application data. AEAD algorithms use a single key to encrypt their input data and also to generate a cryptographic tag to accompany the resulting ciphertext; when decryption is performed, the tag allows authentication of the encrypted data and of optional associated plaintext data.",
      "ja": "最後に、tcpcryptが成功の鍵を設定し、暗号化された後は、関連するデータとの認証暗号（AEAD）のためのアルゴリズムは、すべての送信されたアプリケーションデータの機密性と完全性を保護するために使用され、導出されています。 AEADアルゴリズムは、得られた暗号文を付随する暗号タグを生成するために、それらの入力データを暗号化するために単一のキーを使用します。復号化が行われた場合、タグは、暗号化されたデータのおよび任意の関連付けられた平文データの認証を可能にします。"
    },
    {
      "indent": 0,
      "text": "3.2. Protocol Negotiation",
      "section_title": true,
      "ja": "3.2。プロトコルのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Tcpcrypt depends on TCP-ENO [RFC8547] to negotiate whether encryption will be enabled for a connection as well as which key-agreement scheme to use. TCP-ENO negotiates the use of a particular TCP encryption protocol (TEP) by including protocol identifiers in ENO suboptions. This document associates four TEP identifiers with the tcpcrypt protocol as listed in Table 4 of Section 7. Each identifier indicates the use of a particular key-agreement scheme, with an associated CPRF and length parameter. Future standards can associate additional TEP identifiers with tcpcrypt following the assignment policy specified by TCP-ENO.",
      "ja": "Tcpcryptは、暗号化は、接続だけでなく、使用するキー・契約制度のために有効にするかどうかを交渉するためにTCP-ENO [RFC8547]に依存します。 TCP-ENOは、ENOのサブオプション内のプロトコル識別子を含むことによって、特定のTCP暗号化プロトコル（TEP）の使用をネゴシエート。記載されているように、この文書では、各識別子は、関連CPRF及び長さパラメータと、特定の鍵合意方式の使用を示す第7の表4にtcpcryptプロトコルで4つのTEP識別子を関連付けます。将来の規格は、TCP-ENOによって指定された割り当てポリシー以下tcpcryptに追加TEP識別子を関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "An active opener that wishes to negotiate the use of tcpcrypt includes an ENO option in its SYN segment. That option includes suboptions with tcpcrypt TEP identifiers indicating the key-agreement schemes it is willing to enable. The active opener MAY additionally include suboptions indicating support for encryption protocols other than tcpcrypt, as well as global suboptions as specified by TCP-ENO.",
      "ja": "tcpcryptの使用を交渉することを望む活性オープナーは、SYNセグメント内ENOオプションを含みます。そのオプションは、有効に喜んで鍵合意スキームを示すtcpcrypt TEP識別子とサブオプションが含まれています。 TCP-ENOによって指定されるように活性オープナーはさらにtcpcrypt以外の暗号化プロトコルのサポートを示すサブオプション、ならびにグローバルサブオプションを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a passive opener receives an ENO option including tcpcrypt TEPs that it supports, it MAY then attach an ENO option to its SYN-ACK segment, including solely the TEP it wishes to enable.",
      "ja": "パッシブオープナーはtcpcryptは、それがサポートしていることをTEPSなど、ENOオプションを受信した場合、それはそれは有効にしたいだけにTEPを含め、そのSYN-ACKセグメントにENOオプションをつけてもよいです。"
    },
    {
      "indent": 3,
      "text": "To establish distinct roles for the two hosts in each connection, tcpcrypt depends on the role-negotiation mechanism of TCP-ENO. As one result of the negotiation process, TCP-ENO assigns hosts unique roles abstractly called \"A\" at one end of the connection and \"B\" at the other. Generally, an active opener plays the \"A\" role and a passive opener plays the \"B\" role, but in the case of simultaneous open, an additional mechanism breaks the symmetry and assigns a distinct role to each host. TCP-ENO uses the terms \"host A\" and \"host B\" to identify each end of a connection uniquely; this document employs those terms in the same way.",
      "ja": "各接続に2つのホストのために異なる役割を確立するために、tcpcryptはTCP-ENOの役割ネゴシエーションメカニズムに依存します。ネゴシエーションプロセスの結果として、TCP-ENOは、他の接続と「B」の一端に抽象的に「A」と呼ばれるホスト固有の役割を割り当てます。一般に、アクティブオープナーは、「A」の役割を果たし、受動オープナーは、「B」の役割を果たしているが、同時オープンの場合には、付加的な機構が対称性を破壊し、各ホストに異なる役割を割り当てます。 TCP-ENO一意接続の各端部を識別するために、「ホストA」および「ホストB」という用語を使用します。この文書は、同じ方法でそれらの用語を採用しています。"
    },
    {
      "indent": 3,
      "text": "An ENO suboption includes a flag \"v\" which indicates the presence of associated variable-length data. In order to propose fresh key agreement with a particular tcpcrypt TEP, a host sends a one-byte suboption containing the TEP identifier and v = 0. In order to propose session resumption (described further below) with a particular TEP, a host sends a variable-length suboption containing the TEP identifier, the flag v = 1, an identifier derived from a session secret previously negotiated with the same host and the same TEP, and a nonce.",
      "ja": "ENOサブオプションは、関連する可変長データの存在を示すフラグ「V」を含みます。特定tcpcryptのTEP新鮮なキー合意を提案するために、ホストは特定のTEPと（さらに後述する）セッションの再開を提案するために、TEP識別子及びv = 0を含む1バイトのサブオプションを送信し、ホストが送信しますTEP識別子、フラグ、V = 1、以前に同一のホストと同じTEP、およびノンスと交渉セッション・シークレットから派生した識別子を含む可変長サブオプション。"
    },
    {
      "indent": 3,
      "text": "Once two hosts have exchanged SYN segments, TCP-ENO defines the negotiated TEP to be the last valid TEP identifier in the SYN segment of host B (that is, the passive opener in the absence of simultaneous open) that also occurs in that of host A. If there is no such TEP, hosts MUST disable TCP-ENO and tcpcrypt.",
      "ja": "2つのホストがSYNセグメントを交換した後、TCP-ENOネゴシエートTEPは、ホストBのSYNセグメント内の最後の有効なTEP識別子であると定義され（すなわち、同時オープンの非存在下での受動的オープナーである）、宿主の中で発生しますA.そのようなTEPが存在しない場合は、ホストがTCP-ENOとtcpcryptを無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the negotiated TEP was sent by host B with v = 0, it means that fresh key agreement will be performed as described in Section 3.3. If, on the other hand, host B sent the TEP with v = 1 and both hosts sent appropriate resumption identifiers in their suboption data, then the key-exchange messages will be omitted in favor of determining keys via session resumption as described in Section 3.5. With session resumption, protected application data MAY be sent immediately as detailed in Section 3.6.",
      "ja": "ネゴシエートされたTEPは、V = 0とホストBによって送信された場合、それはセクション3.3で説明したように、新鮮なキー合意が実行されることを意味します。一方、ホストBは、V = 1とTEPを送信し、両方のホストは、それらのサブオプションデータの適切な再開識別子を送信し、セクション3.5で説明したように、その後、鍵交換メッセージは、セッション再開を介してキーを決定するのに有利に省略され、場合。セクション3.6で説明するようにセッションの再開では、保護されたアプリケーションデータをすぐに送信されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that the negotiated TEP is determined without reference to the \"v\" bits in ENO suboptions, so if host A offers resumption with a particular TEP and host B replies with a non-resumption suboption with the same TEP, that could become the negotiated TEP, in which case fresh key agreement will be performed. That is, sending a resumption suboption also implies willingness to perform fresh key agreement with the indicated TEP.",
      "ja": "ホストAは、特定のTEPと再開を提供し、ホストBは同じTEPと非再開サブオプションで応答するので、もしネゴシエートTEPは、ENOのサブオプションで「V」ビットを参照することなく決定されることに注意し、ネゴシエートTEPになることができること、その場合、新鮮な鍵の合意が実行されます。これは、再開のサブオプションも示されたTEPと新鮮な鍵合意を実行する意欲を意味送ること、です。"
    },
    {
      "indent": 3,
      "text": "As REQUIRED by TCP-ENO, once a host has both sent and received an ACK segment containing a valid ENO option, encryption MUST be enabled and plaintext application data MUST NOT ever be exchanged on the connection. If the negotiated TEP is among those listed in Table 4, a host MUST follow the protocol described in this document.",
      "ja": "TCP-ENOにより必要に応じて、一度ホストが両方送信され、有効なENOオプションを含むACKセグメントを受信した、暗号化を有効にする必要がありますし、プレーンテキストのアプリケーションデータは、これまでの接続上で交換されてはなりません。ネゴシエートされたTEPは、表4に列挙されたものの中にある場合、ホストは、この文書に記載のプロトコルに従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Key Exchange",
      "section_title": true,
      "ja": "3.3。鍵交換"
    },
    {
      "indent": 3,
      "text": "Following successful negotiation of a tcpcrypt TEP, all further signaling is performed in the Data portion of TCP segments. Except when resumption was negotiated (described in Section 3.5), the two hosts perform key exchange through two messages, Init1 and Init2, at the start of the data streams of host A and host B, respectively. These messages MAY span multiple TCP segments and need not end at a segment boundary. However, the segment containing the last byte of an Init1 or Init2 message MUST have TCP's push flag (PSH) set.",
      "ja": "tcpcryptのTEPの成功した交渉の後、全ての更なるシグナリングは、TCPセグメントのデータ部分に実行されます。 （セクション3.5を参照）再開をネゴシエートされた場合を除いて、二つのホストがそれぞれ、ホストAとホストBのデータストリームの開始時に、二つのメッセージ、INIT1及びINIT2を通して鍵交換を行います。これらのメッセージは、複数のTCPセグメントにまたがると、セグメント境界で終わらない必要があるかもしれません。しかし、INIT1又はINIT2メッセージの最後のバイトを含むセグメントは、TCPのプッシュフラグ（PSH）設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The key exchange protocol, in abstract, proceeds as follows:",
      "ja": "次のように鍵交換プロトコルは、抽象的で、進行します："
    },
    {
      "indent": 7,
      "text": "A -> B:  Init1 = { INIT1_MAGIC, sym_cipher_list, N_A, Pub_A }\nB -> A:  Init2 = { INIT2_MAGIC, sym_cipher, N_B, Pub_B }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The concrete format of these messages is specified in Section 4.1.",
      "ja": "これらのメッセージの具体的なフォーマットは、4.1節で指定されています。"
    },
    {
      "indent": 3,
      "text": "The parameters are defined as follows:",
      "ja": "次のようにパラメータが定義されています。"
    },
    {
      "indent": 3,
      "text": "o INIT1_MAGIC, INIT2_MAGIC: Constants defined in Section 4.3.",
      "ja": "INIT1_MAGIC、INIT2_MAGIC O：4.3節で定義された定数。"
    },
    {
      "indent": 3,
      "text": "o sym_cipher_list: A list of identifiers of symmetric ciphers (AEAD algorithms) acceptable to host A. These are specified in Table 5 of Section 7.",
      "ja": "O sym_cipher_list：A.をホストに許容される対称暗号（AEADアルゴリズム）の識別子のリストは、これらは、第7の表5に規定されています。"
    },
    {
      "indent": 3,
      "text": "o sym_cipher: The symmetric cipher selected by host B from the sym_cipher_list sent by host A.",
      "ja": "O sym_cipher：ホストAによって送信されたsym_cipher_listからホストBによって選択された対称暗号"
    },
    {
      "indent": 3,
      "text": "o N_A, N_B: Nonces chosen at random by hosts A and B, respectively.",
      "ja": "O N_A、N_B：それぞれホストA及びB、によってランダムに選択されたナンス。"
    },
    {
      "indent": 3,
      "text": "o Pub_A, Pub_B: Ephemeral public keys for hosts A and B, respectively. These, as well as their corresponding private keys, are short-lived values that MUST be refreshed frequently. The private keys SHOULD NOT ever be written to persistent storage. The security risks associated with the storage of these keys are discussed in Section 8.",
      "ja": "O Pub_A、Pub_B：それぞれホストA及びBについてエフェメラルパブリックキー。これらの、並びにそれらの対応する秘密鍵は、頻繁にリフレッシュしなければならない短命値です。秘密鍵は、これまで永続ストレージに書き込まれるべきではありません。これらのキーのストレージに関連したセキュリティリスクは、セクション8で議論されています。"
    },
    {
      "indent": 3,
      "text": "If a host receives an ephemeral public key from its peer and a key-validation step fails (see Section 5), it MUST abort the connection and raise an error condition distinct from the end-of-file condition.",
      "ja": "（第5節を参照）ホストがピアからのはかない公開鍵を受け取り、キーの検証ステップが失敗した場合は、接続を中止し、ファイル終了条件は異なるエラー条件を上げる必要があります。"
    },
    {
      "indent": 3,
      "text": "The ephemeral secret ES is the result of the key-agreement algorithm (see Section 5) indicated by the negotiated TEP. The inputs to the algorithm are the local host's ephemeral private key and the remote host's ephemeral public key. For example, host A would compute ES using its own private key (not transmitted) and host B's public key, Pub_B.",
      "ja": "はかない秘密ESは交渉さTEPで示されるキー合意アルゴリズム（セクション5を参照）の結果です。アルゴリズムへの入力は、ローカルホストのはかない秘密鍵とリモートホストのはかない公開鍵です。たとえば、ホストAは自身の秘密鍵（送信しない）とホストBの公開鍵、Pub_Bを使用してESを計算します。"
    },
    {
      "indent": 3,
      "text": "The two sides then compute a pseudo-random key, PRK, from which all session secrets are derived, as follows:",
      "ja": "次の2つの側面は、次に、すべてのセッションの秘密が由来する疑似ランダムキー、PRKを計算します。"
    },
    {
      "indent": 10,
      "text": "PRK = Extract(N_A, eno_transcript | Init1 | Init2 | ES)",
      "ja": "PRK =エキス（N_A、eno_transcript | INIT1 | INIT2 | ES）"
    },
    {
      "indent": 3,
      "text": "Above, \"|\" denotes concatenation, eno_transcript is the protocol-negotiation transcript defined in Section 4.8 of [RFC8547], and Init1 and Init2 are the transmitted encodings of the messages described in Section 4.1.",
      "ja": "上記、 \"|\"連結を表し、eno_transcriptは[RFC8547]のセクション4.8で定義されたプロトコルネゴシエーション転写物であり、INIT1及びINIT2は、セクション4.1で説明したメッセージの送信エンコーディングです。"
    },
    {
      "indent": 3,
      "text": "A series of session secrets are computed from PRK as follows:",
      "ja": "次のようにセッション秘密のシリーズは、PRKから計算されます。"
    },
    {
      "indent": 17,
      "text": "ss[0] = PRK\nss[i] = CPRF(ss[i-1], CONST_NEXTK, K_LEN)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value ss[0] is used to generate all key material for the current connection. The values ss[i] for i > 0 are used by session resumption to avoid public key cryptography when establishing subsequent connections between the same two hosts as described in Section 3.5. The CONST_* values are constants defined in Section 4.3. The length K_LEN depends on the tcpcrypt TEP in use, and is specified in Section 5.",
      "ja": "値SS [0]は、現在の接続のためのすべての鍵素材を生成するために使用されます。値SS [i]はiについて> 0は、セクション3.5に記載したのと同じ2つのホスト間の後続の接続を確立するとき、公開鍵暗号を回避するために、セッションの再開によって使用されています。 CONST_ *値は、4.3節で定義された定数です。長K_LENは、使用中tcpcryptのTEPに依存し、セクション5で指定されています。"
    },
    {
      "indent": 3,
      "text": "Given a session secret ss[i], the two sides compute a series of master keys as follows:",
      "ja": "次のようにセッション秘密SS [i]が与えられ、双方がマスターキーのシリーズを計算します。"
    },
    {
      "indent": 14,
      "text": "mk[0] = CPRF(ss[i], CONST_REKEY | sn[i], K_LEN)\nmk[j] = CPRF(mk[j-1], CONST_REKEY, K_LEN)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The process of advancing through the series of master keys is described in Section 3.8. The values represented by sn[i] are session nonces. For the initial session with i = 0, the session nonce is zero bytes long. The values for subsequent sessions are derived from fresh connection data as described in Section 3.5.",
      "ja": "マスターキーの一連の前進のプロセスは、セクション3.8に記載されています。 SN [I]で表される値は、セッション・ナンスです。 I = 0の最初のセッションのために、セッション・ナンスがゼロバイト長です。後続のセッションの値は、セクション3.5で説明したように新鮮な接続データから導出されます。"
    },
    {
      "indent": 3,
      "text": "Finally, each master key mk[j] is used to generate traffic keys for protecting application data using authenticated encryption:",
      "ja": "最後に、各マスターキーMK [j]は、認証済みの暗号化を使用してアプリケーション・データを保護するため、トラフィックキーを生成するために使用されます。"
    },
    {
      "indent": 7,
      "text": "k_ab[j] = CPRF(mk[j], CONST_KEY_A, ae_key_len + ae_nonce_len)\nk_ba[j] = CPRF(mk[j], CONST_KEY_B, ae_key_len + ae_nonce_len)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the first session derived from fresh key agreement, traffic keys k_ab[j] are used by host A to encrypt and host B to decrypt, while keys k_ba[j] are used by host B to encrypt and host A to decrypt. In a resumed session, as described more thoroughly in Section 3.5, each host uses the keys in the same way as it did in the original session, regardless of its role in the current session; for example, if a host played role \"A\" in the first session, it will use keys k_ab[j] to encrypt in each derived session.",
      "ja": "ホストBによって使用されるk_ba [J]キーを暗号化するために、ホストAを解読するながら、新鮮な鍵合意に由来する最初のセッションでは、トラフィックキーがk_ab [j]を、復号化するために暗号化してホストBにホストAによって使用されます。 3.5節でより徹底的に説明したように、元のセッションで行ったように再開セッションでは、各ホストに関係なく、現在のセッションにおけるその役割の、同じようにキーを使用しています。ホストは最初のセッションで役割「A」をプレイした場合、たとえば、それはk_ab [j]は、各派生セッションで暗号化するためにキーを使用します。"
    },
    {
      "indent": 3,
      "text": "The values ae_key_len and ae_nonce_len depend on the authenticated-encryption algorithm selected and are given in Table 3 of Section 6. The algorithm uses the first ae_key_len bytes of each traffic key as an authenticated-encryption key, and it uses the following ae_nonce_len bytes as a nonce randomizer.",
      "ja": "値ae_key_lenとae_nonce_lenは、選択された認証された暗号化アルゴリズムに依存し、アルゴリズムが認証暗号鍵として各トラフィックキーの最初ae_key_lenバイトを使用し、そしてそれはとして以下ae_nonce_lenバイトを使用する第6節の表3に示しますナンスランダマイザ。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD provide an interface allowing the user to specify, for a particular connection, the set of AEAD algorithms to advertise in sym_cipher_list (when playing role \"A\") and also the order of preference to use when selecting an algorithm from those offered (when playing role \"B\"). A companion document [TCPINC-API] describes recommended interfaces for this purpose.",
      "ja": "提供されるものからアルゴリズムを選択する際場合（優先順位を使用することも実装では、ユーザが指定することを可能にするインタフェースを提供すべきである（ロール「A」を再生する場合）、特定の接続のために、AEADアルゴリズムのセットはsym_cipher_listにアドバタイズすると）役割 \"B\" を演奏。仲間ドキュメント[TCPINC-API]は、この目的のために推奨されるインタフェースについて説明します。"
    },
    {
      "indent": 3,
      "text": "After host B sends Init2 or host A receives it, that host MAY immediately begin transmitting protected application data as described in Section 3.6.",
      "ja": "ホストBはINIT2を送信するか、ホストAは、それを受信した後、そのホストは直ちにセクション3.6に記載されているように保護されたアプリケーションデータの送信を開始することができます。"
    },
    {
      "indent": 3,
      "text": "If host A receives Init2 with a sym_cipher value that was not present in the sym_cipher_list it previously transmitted in Init1, it MUST abort the connection and raise an error condition distinct from the end-of-file condition.",
      "ja": "ホストAは、それが以前にINIT1で送信sym_cipher_list中に存在しなかったsym_cipher値とINIT2を受信した場合、接続を中断し、エンドオブファイル条件とは異なるエラー条件を提起しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Throughout this document, to \"abort the connection\" means to issue the \"Abort\" command as described in Section 3.8 of [RFC793]. That is, the TCP connection is destroyed, RESET is transmitted, and the local user is alerted to the abort event.",
      "ja": "本書では、「接続を中止」することは、[RFC793]の3.8節で説明したように「中止」コマンドを発行することを意味します。 TCP接続が破壊されるが、RESETが送信され、ローカルユーザは、中断イベントに警告されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Session ID",
      "section_title": true,
      "ja": "3.4。セッションID"
    },
    {
      "indent": 3,
      "text": "TCP-ENO requires each TEP to define a session ID value that uniquely identifies each encrypted connection.",
      "ja": "TCP-ENOは、一意の暗号化接続を識別するセッションID値を定義するために各TEPを必要とします。"
    },
    {
      "indent": 3,
      "text": "A tcpcrypt session ID begins with the byte transmitted by host B that contains the negotiated TEP identifier along with the \"v\" bit. The remainder of the ID is derived from the session secret and session nonce, as follows:",
      "ja": "tcpcryptセッションIDは、「V」ビットと共にネゴシエートTEP識別子が含まれているホストBによって送信されたバイトで始まります。次のようにIDの残りは、セッション・シークレット及びセッションナンスから誘導されます。"
    },
    {
      "indent": 4,
      "text": "session_id[i] = TEP-byte | CPRF(ss[i], CONST_SESSID | sn[i], K_LEN)",
      "ja": "session_idの[i]を= TEPバイト| CPRF（SS [i]は、CONST_SESSID | SN [i]は、K_LEN）"
    },
    {
      "indent": 3,
      "text": "Again, the length K_LEN depends on the TEP and is specified in Section 5.",
      "ja": "ここでも、長さK_LENはTEPに依存し、第5節で指定されています。"
    },
    {
      "indent": 0,
      "text": "3.5. Session Resumption",
      "section_title": true,
      "ja": "3.5。セッション再開"
    },
    {
      "indent": 3,
      "text": "If two hosts have previously negotiated a session with secret ss[i-1], they can establish a new connection without public-key operations using ss[i], the next session secret in the sequence derived from the original PRK.",
      "ja": "2つのホストが以前に秘密SS [I-1]とのセッションを交渉している場合、彼らは元PRK由来の配列で、[i]は、次のセッションの秘密SSを使用して、公開鍵操作をせずに新しい接続を確立することができます。"
    },
    {
      "indent": 3,
      "text": "A host signals its willingness to resume with a particular session secret by sending a SYN segment with a resumption suboption, i.e., an ENO suboption containing the negotiated TEP identifier of the previous session, half of the resumption identifier for the new session, and a resumption nonce.",
      "ja": "ホストは、再開サブオプションでSYNセグメントを送信することにより、特定のセッションの秘密と再開する意思を知らせるすなわち、前のセッションのネゴシエートTEP識別子、新しいセッションの再開識別子の半分、および再開を含むENOサブオプションナンス。"
    },
    {
      "indent": 3,
      "text": "The resumption nonce MUST have a minimum length of zero bytes and maximum length of eight bytes. The value MUST be chosen randomly or using a mechanism that guarantees uniqueness even in the face of virtual-machine cloning or other re-execution of the same session. An attacker who can force either side of a connection to reuse a session secret with the same nonce will completely break the security of tcpcrypt. Reuse of session secrets is possible in the event of virtual-machine cloning or reuse of system-level hibernation state. Implementations SHOULD provide an API through which to set the resumption nonce length and MUST default to eight bytes if they cannot prohibit the reuse of session secrets.",
      "ja": "再開ナンスは、8バイトのゼロバイトの最小長さと最大長さを有さなければなりません。値は、ランダムに選択され、あるいは仮想マシンクローニングまたは同じセッションの他の再実行の面で一意性を保証するメカニズムを使用しなければなりません。同じナンスとのセッションの秘密を再利用するために、接続のどちらかの側を強制することができ、攻撃者は完全にtcpcryptのセキュリティを破るだろう。セッション秘密の再利用は、システムレベルの休止状態の仮想マシンのクローニングまたは再使用の場合に可能です。実装は再開ナンスの長さを設定するために、彼らはセッションの秘密の再利用を禁止することができない場合は8つのバイトをデフォルトとしなければならない、それを通してAPIを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "The resumption identifier is calculated from a session secret ss[i] as follows:",
      "ja": "次のように再開識別子は、セッション秘密SS [I]から計算されます。"
    },
    {
      "indent": 17,
      "text": "resume[i] = CPRF(ss[i], CONST_RESUME, 18)",
      "ja": "再開[I] = CPRF（SS [i]が、CONST_RESUME、18）"
    },
    {
      "indent": 3,
      "text": "To name a session for resumption, a host sends either the first or second half of the resumption identifier according to the role it played in the original session with secret ss[0].",
      "ja": "再開のためのセッションに名前を付けるには、ホストは、それが秘密のSS [0]と元のセッションに果たした役割に応じて再開識別子の第一または第二の半分のどちらかを送信します。"
    },
    {
      "indent": 3,
      "text": "A host that originally played role \"A\" and wishes to resume from a cached session sends a suboption with the first half of the resumption identifier:",
      "ja": "もともとは「A」の役割を果たし、キャッシュされたセッションから再開することを希望するホストが再開識別子の前半とサブオプションを送信します。"
    },
    {
      "indent": 9,
      "text": "byte     0      1             9      10\n     +------+------+--...--+------+------+--...--+------+\n     | TEP- |   resume[i]{0..8}   |       nonce_a       |\n     | byte |                     |                     |\n     +------+------+--...--+------+------+--...--+------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 2: Resumption suboption sent when original role was \"A\".",
      "ja": "図2：オリジナルの役割が「A」であったときに送信再開サブオプション。"
    },
    {
      "indent": 3,
      "text": "The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.",
      "ja": "TEPバイトはtcpcryptのTEP識別子を含み、V = 1のnonce値が0と8バイトの長さでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Similarly, a host that originally played role \"B\" sends a suboption with the second half of the resumption identifier:",
      "ja": "同様に、もともと役割「B」を果たしたホストが再開識別子の後半でサブオプションを送信します。"
    },
    {
      "indent": 9,
      "text": "byte     0      1             9      10\n     +------+------+--...--+------+------+--...--+------+\n     | TEP- |   resume[i]{9..17}  |       nonce_b       |\n     | byte |                     |                     |\n     +------+------+--...--+------+------+--...--+------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 3: Resumption suboption sent when original role was \"B\".",
      "ja": "図3：オリジナルの役割が「B」であったときに送信再開サブオプション。"
    },
    {
      "indent": 3,
      "text": "The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.",
      "ja": "TEPバイトはtcpcryptのTEP識別子を含み、V = 1のnonce値が0と8バイトの長さでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a passive opener receives a resumption suboption containing an identifier-half that names a session secret that it has cached, and the subobtion's TEP matches the TEP used in the previous session, it SHOULD (with exceptions specified below) agree to resume from the cached session by sending its own resumption suboption, which will contain the other half of the identifier. Otherwise, it MUST NOT agree to resumption.",
      "ja": "パッシブオープナーは、それがキャッシュされていることを名前セッション秘密識別子半分を含む再開サブオプションを受け取り、subobtionのTEPは、前のセッションで使用されるTEPと一致した場合（以下、指定の例外がで）同意する、それがキャッシュされてから再開するべきです識別子の残りの半分が含まれています独自の再開サブオプションを、送信することでセッション。それ以外の場合は、再開に同意してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a passive opener does not agree to resumption with a particular TEP, it MAY either request fresh key exchange by responding with a non-resumption suboption using the same TEP or else respond to any other received TEP suboption.",
      "ja": "パッシブオープナーは、特定のTEPとの再開に同意しない場合、それは同じTEPを使用して、非再開サブオプションで応答することによって、新鮮な鍵交換を要求するか、他の任意他の受信TEPのサブオプションに応答することができるいずれか。"
    },
    {
      "indent": 3,
      "text": "If a passive opener receives an ENO suboption with a TEP identifier and v = 1, but the suboption data is less than 9 bytes in length, it MUST behave as if the same TEP had been sent with v = 0. That is, the suboption MUST be interpreted as an offer to negotiate fresh key exchange with that TEP.",
      "ja": "受動オープナーはTEP識別子及びv = 1とENOサブオプションを受信するが、サブオプションデータ長未満9バイトで同じTEPであることがV = 0で送信されたかのように、それは、サブオプションに動作する必要がある場合そのTEPと新鮮な鍵交換を交渉するの申し出と解釈されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an active opener sends a resumption suboption with a particular TEP and the appropriate half of a resumption identifier, and then, in the same TCP handshake, it receives a resumption suboption with the same TEP and an identifier-half that does not match that resumption identifier, it MUST ignore that suboption. In the typical case that this was the only ENO suboption received, this means the host MUST disable TCP-ENO and tcpcrypt; it MUST NOT send any more ENO options and MUST NOT encrypt the connection.",
      "ja": "アクティブオープナーは、特定のTEPと再開識別子の適切な半分と再開サブオプションを送信し、次いで、同じTCPハンドシェークに、その再開一致しない同じTEPと識別子半分と再開サブオプションを受信した場合識別子、そのサブオプションを無視しなければなりません。これが唯一のENOサブオプションが受信された典型的なケースでは、これは、ホストがTCP-ENOとtcpcryptを無効にしなければならないことを意味します。これ以上ENOオプションを送ってはならないとの接続を暗号化してはなりません。"
    },
    {
      "indent": 3,
      "text": "When a host concludes that TCP-ENO negotiation has succeeded for some TEP that was received in a resumption suboption, it MUST then enable encryption with that TEP using the cached session secret. To do this, it first constructs sn[i] as follows:",
      "ja": "ホストがTCP-ENO交渉が再開サブオプションで受信されたいくつかのTEPのために成功したと判断すると、それがキャッシュされたセッションの秘密を使用して、そのTEPと暗号化を有効にする必要があります。これを行うには、その最初の構築物SN [i]は次のように："
    },
    {
      "indent": 25,
      "text": "sn[i] = nonce_a | nonce_b",
      "ja": "SN [I] = nonce_a | nonce_b"
    },
    {
      "indent": 3,
      "text": "Master keys are then computed from s[i] and sn[i] as described in Section 3.3 as well as from application data encrypted as described in Section 3.6.",
      "ja": "マスターキーは、その後、[i]はsから計算され、SN [i]のセクション3.3で、並びに第3.6節に記載したように暗号化されたアプリケーションデータから記載されるようにされています。"
    },
    {
      "indent": 3,
      "text": "The session ID (Section 3.4) is constructed in the same way for resumed sessions as it is for fresh ones. In this case, the first byte will always have v = 1. The remainder of the ID is derived from the cached session secret and the session nonce that was generated during resumption.",
      "ja": "それは新鮮なもののためであるとして、セッションID（3.4節）が再開されたセッションのために同じように構成されています。この場合、最初のバイトは常にVを有するであろう= IDの1の残りの部分は、キャッシュされたセッション・シークレットと再開時に生成されたセッション・ナンスから誘導されます。"
    },
    {
      "indent": 3,
      "text": "In the case of simultaneous open where TCP-ENO is able to establish asymmetric roles, two hosts that simultaneously send SYN segments with compatible resumption suboptions MAY resume the associated session.",
      "ja": "TCP-ENOが非対称の役割を確立することができる同時オープンの場合には、同時に互換再開サブオプションでSYNセグメントを送信する二つのホストは、関連するセッションを再開することができます。"
    },
    {
      "indent": 3,
      "text": "In a particular SYN segment, a host SHOULD NOT send more than one resumption suboption (because this consumes TCP option space and is unlikely to be a useful practice), and it MUST NOT send more than one resumption suboption with the same TEP identifier. But in addition to any resumption suboptions, an active opener MAY include non-resumption suboptions describing other TEPs it supports (in addition to the TEP in the resumption suboption).",
      "ja": "特定のSYNセグメントでは、（これはTCPオプションのスペースを消費し、有益な練習になることはほとんどありませんので）ホストは、複数の再開サブオプションを送るべきではありません、それは同じTEP識別子を持つ複数の再開サブオプションを送ってはいけません。しかし、任意の再開サブオプションに加えて、アクティブオープナーは（再開サブオプション内のTEPに加えて）それがサポートする他のTEPSを記述する非再開サブオプションを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "After using the session secret ss[i] to compute mk[0], implementations SHOULD compute and cache ss[i+1] for possible use by a later session and then erase ss[i] from memory. Hosts MAY retain ss[i+1] until it is used or the memory needs to be reclaimed. Hosts SHOULD NOT write any session secrets to non-volatile storage.",
      "ja": "セッション秘密SSを使用した後に[i]は、MK [0]、実装は、計算すべきであり、それ以降のセッションによって可能な使用のためにキャッシュSS [I + 1]を計算し、その後、メモリからSS [i]を消去します。それが使用されるか、またはメモリを再利用する必要があるまで、ホストは、[I 1を+] SSを保持することができます。ホストは、不揮発性ストレージに任意のセッションの秘密を書くべきではありません。"
    },
    {
      "indent": 3,
      "text": "When proposing resumption, the active opener MUST use the lowest value of \"i\" that has not already been used (successfully or not) to negotiate resumption with the same host and for the same original session secret ss[0].",
      "ja": "再開を提案する場合、アクティブオープナーはすでに[0]は同じホストと再開を交渉する（正常か否か）を使用し、同じ元のセッション秘密SSのためされていない「I」の最小値を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A given session secret ss[i] MUST NOT be used to secure more than one TCP connection. To prevent this, a host MUST NOT resume with a session secret if it has ever enabled encryption in the past with the same secret, in either role. In the event that two hosts simultaneously send SYN segments to each other that propose resumption with the same session secret but with both segments not part of a simultaneous open, both connections would need to revert to fresh key exchange. To avoid this limitation, implementations MAY choose to implement session resumption such that all session secrets derived from a given ss[0] are used for either passive or active opens at the same host, not both.",
      "ja": "特定のセッション秘密SS [i]は、複数のTCP接続を保護するために使用してはいけません。それは、これまでのいずれかの役割で、同じ秘密と過去に暗号化を有効にした場合は、これを防ぐために、ホストは、セッション秘密を再開してはなりません。 2つのホストが同時に同じセッション秘密ではなく、両方のセグメントではない同時オープンの一部で再開を提案しているお互いにSYNセグメントを送信した場合には、両方の接続には、新鮮な鍵交換に戻す必要があります。この制限を回避するために、実装が両方ではない、同じホストにセッション所与SSに由来するすべてのセッション秘密[0]受動的または能動的のいずれかのために使用されるように再開開きを実装することを選ぶかもしれ。"
    },
    {
      "indent": 3,
      "text": "If two hosts have previously negotiated a tcpcrypt session, either host MAY later initiate session resumption regardless of which host was the active opener or played the \"A\" role in the previous session.",
      "ja": "2つのホストが以前にtcpcryptセッションを交渉している場合は、いずれかのホストは、後にかかわらず、どのホストのセッションの再開を開始するアクティブオープナーだったか、以前のセッションで「A」の役割を果たしたかもしれません。"
    },
    {
      "indent": 3,
      "text": "However, a given host MUST either encrypt with keys k_ab[j] for all sessions derived from the same original session secret ss[0], or with keys k_ba[j]. Thus, which keys a host uses to send segments is not affected by the role it plays in the current connection: it depends only on whether the host played the \"A\" or \"B\" role in the initial session.",
      "ja": "しかし、特定のホスト[0]、又はk_ba [J]キーと同じ元のセッション秘密SSに由来するすべてのセッションのキーk_ab [j]を用いて暗号化する必要があります。したがって、ホストは、セグメントを送信するために使用するキーは、それが現在の接続で果たす役割には影響されません。これは、ホストが最初のセッションでは、「A」または「B」の役割を果たしたかどうかにのみ依存します。"
    },
    {
      "indent": 3,
      "text": "Implementations that cache session secrets MUST provide a means for applications to control that caching. In particular, when an application requests a new TCP connection, it MUST have a way to specify two policies for the duration of the connection: 1) that resumption requests will be ignored, and thus fresh key exchange will be necessary; and 2) that no session secrets will be cached. (These policies can be specified independently or as a unit.) And for an established connection, an application MUST have a means to cause any cache state that was used in or resulted from establishing the connection to be flushed. A companion document [TCPINC-API] describes recommended interfaces for this purpose.",
      "ja": "セッションの秘密をキャッシュ実装はそのキャッシュを制御するためのアプリケーションのための手段を提供しなければなりません。具体的には、アプリケーションが新しいTCP接続を要求したとき、それは、接続中に2つのポリシーを指定する方法を持っている必要があります。1）その再開の要求は無視されますので、新鮮なキー交換が必要になります。及び2）は、セッション秘密がキャッシュされないことを。 （これらのポリシーは。単独または単位として指定することができます）そして、確立された接続のために、アプリケーションが使用またはフラッシュする接続を確立により生じたいかなるキャッシュ状態を引き起こすための手段を持たなければなりません。仲間ドキュメント[TCPINC-API]は、この目的のために推奨されるインタフェースについて説明します。"
    },
    {
      "indent": 0,
      "text": "3.6. Data Encryption and Authentication",
      "section_title": true,
      "ja": "3.6。データの暗号化と認証"
    },
    {
      "indent": 3,
      "text": "Following key exchange (or its omission via session resumption), all further communication in a tcpcrypt-enabled connection is carried out within delimited encryption frames that are encrypted and authenticated using the agreed-upon keys.",
      "ja": "鍵交換（またはセッション再開を経由してその省略）に続いて、tcpcrypt対応の接続でのすべての通信は暗号化され、合意されたキーを使用して認証され区切られた暗号化フレーム内で行われます。"
    },
    {
      "indent": 3,
      "text": "This protection is provided via algorithms for Authenticated Encryption with Associated Data (AEAD). The permitted algorithms are listed in Table 5 of Section 7. Additional algorithms can be specified in the future according to the policy in that section. One algorithm is selected during the negotiation described in Section 3.3. The lengths ae_key_len and ae_nonce_len associated with each algorithm are found in Table 3 of Section 6 along with requirements for which algorithms MUST be implemented.",
      "ja": "この保護は、関連するデータ（AEAD）で認証、暗号化のためのアルゴリズムを介して提供されます。許可アルゴリズムは、第7のさらなるアルゴリズムの表5に記載されているそのセクション内のポリシーに応じて、将来的に特定することができます。一つのアルゴリズムは、3.3節で説明したネゴシエーション時に選択されています。各アルゴリズムに関連付けられた長さae_key_lenとae_nonce_lenはアルゴリズムを実装する必要があるための要件と一緒に第6節の表3に見られます。"
    },
    {
      "indent": 3,
      "text": "The format of an encryption frame is specified in Section 4.2. A sending host breaks its stream of application data into a series of chunks. Each chunk is placed in the data field of a plaintext value, which is then encrypted to yield a frame's ciphertext field. Chunks MUST be small enough that the ciphertext (whose length depends on the AEAD cipher used, and is generally slightly longer than the plaintext) has length less than 2^16 bytes.",
      "ja": "暗号化フレームのフォーマットはセクション4.2で指定されています。送信ホストは一連のチャンクにアプリケーションデータのその流れを壊します。各チャンクは、次いで、フレームの暗号文フィールドを生成するために暗号化される平文値のデータフィールドに置かれます。チャンクは、暗号文（長さが使用AEAD暗号に依存し、平文よりも若干長く、一般的に）2 ^ 16バイト未満の長さを有していることを十分に小さくなければなりません。"
    },
    {
      "indent": 3,
      "text": "An \"associated data\" value (see Section 4.2.2) is constructed for the frame. It contains the frame's control field and the length of the ciphertext.",
      "ja": "「関連データ」の値は、（4.2.2を参照）フレームのために構築されています。これは、フレームの制御フィールドと暗号文の長さが含まれています。"
    },
    {
      "indent": 3,
      "text": "A \"frame ID\" value (see Section 4.2.3) is also constructed for the frame, but not explicitly transmitted. It contains a 64-bit offset field whose integer value is the zero-indexed byte offset of the beginning of the current encryption frame in the underlying TCP datastream. (That is, the offset in the framing stream, not the plaintext application stream.) The offset is then left-padded with zero-valued bytes to form a value of length ae_nonce_len. Because it is strictly necessary for the security of the AEAD algorithms specified in this document, an implementation MUST NOT ever transmit distinct frames with the same frame ID value under the same encryption key. In particular, a retransmitted TCP segment MUST contain the same payload bytes for the same TCP sequence numbers, and a host MUST NOT transmit more than 2^64 bytes in the underlying TCP datastream (which would cause the offset field to wrap) before rekeying as described in Section 3.8.",
      "ja": "「フレームID」の値（セクション4.2.3を参照）、フレームのために構築するが、明示的に伝達されません。それは、その整数値基本となるTCPデータストリームにおける現在の暗号化フレームの先頭のオフセットをゼロインデックス付きバイトである64ビットのオフセットフィールドが含まれています。 （すなわち、フレーミング・ストリーム内のオフセットではなく、平文のアプリケーションストリームである。）を左詰めされたゼロ値のバイトのae_nonce_len長さの値を形成するオフセット。それは、この文書で指定AEADアルゴリズムの安全保障のために厳密に必要であるため、実装はこれまでと同じ暗号化キーの下に同じフレームIDの値を個別のフレームを送信してはなりません。具体的には、再送されたTCPセグメントが同じTCPシーケンス番号の同じペイロードバイトを含まなければならない、そしてホストは、再入力する前に（オフセットフィールドは、ラップさせるような）基本的なTCPデータストリームに複数の2 ^ 64バイトを送信してはなりません3.8節で説明しました。"
    },
    {
      "indent": 3,
      "text": "Keys for AEAD encryption are taken from the traffic key k_ab[j] or k_ba[j] for some \"j\", according to the host's role as described in Section 3.3. First, the appropriate traffic key is divided into two parts:",
      "ja": "AEAD暗号化のための鍵は、3.3節で説明したように、ホストの役割に応じて、いくつかの「J」のトラフィックキーk_ab [J]またはk_ba [J]から取得されます。まず、適切なトラフィックキーは2つの部分に分かれています。"
    },
    {
      "indent": 8,
      "text": "                              ae_key_len + ae_nonce_len - 1\n                                               |\nbyte  0                    ae_key_len          |\n      |                           |            |\n      v                           v            v\n    +----+----+--...--+----+----+----+--...--+----+\n    |             K             |        NR       |\n    +----+----+--...--+----+----+----+--...--+----+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 4: Format of Traffic Key",
      "ja": "図4：トラフィックキーのフォーマット"
    },
    {
      "indent": 3,
      "text": "With reference to the \"AEAD Interface\" described in Section 2 of [RFC5116], the first ae_key_len bytes of the traffic key provide the AEAD key K. The remaining ae_nonce_len bytes provide a nonce randomizer value NR, which is combined via bitwise exclusive-or with the frame ID to yield N, the AEAD nonce for the frame:",
      "ja": "[RFC5116]のセクション2に記載された「AEADインタフェース」を参照して、トラフィックキーの最初ae_key_lenバイトは、残りae_nonce_lenバイトはビット単位の排他的論理和を介して結合されたnonceランダマイザ値NRを提供AEAD鍵Kを提供しますフレームIDとN、フレームのAEAD nonceを得ました。"
    },
    {
      "indent": 28,
      "text": "N = frame_ID XOR NR",
      "ja": "N = frame_ID XOR NR"
    },
    {
      "indent": 3,
      "text": "The remaining AEAD inputs, P and A, are provided by the frame's plaintext value and associated data, respectively. The output of the AEAD operation, C, is transmitted in the frame's ciphertext field.",
      "ja": "残りAEAD入力、P及びAは、それぞれ、フレームの平文の値と関連付けられたデータによって提供されます。 AEAD動作、Cの出力は、フレームの暗号文フィールドで送信されます。"
    },
    {
      "indent": 3,
      "text": "When a frame is received, tcpcrypt reconstructs the associated data and frame ID values (the former contains only data sent in the clear, and the latter is implicit in the TCP stream), computes the nonce N as above, and provides these and the ciphertext value to the AEAD decryption operation. The output of this operation is either a plaintext value P or the special symbol FAIL. In the latter case, the implementation SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if none of the TCP segment(s) containing the frame have been acknowledged and retransmission could potentially result in a valid frame, an implementation MAY instead drop these segments (and renege if they have been selectively acknowledged (SACKed), according to Section 8 of [RFC2018]).",
      "ja": "フレームが受信されると、tcpcryptは、関連データとフレームID値を（前者は平文で送信データのみを含み、後者は、TCPストリーム内の暗黙的である）、上記のようにノンスNを計算し再構成し、これらの暗号文を提供しますAEAD復号操作に値。このオペレーションの出力は、平文値Pまたは特殊記号FAILのいずれかです。後者の場合、実装は、接続を中止し、エンドオブファイル条件とは異なるエラー条件を上げるべきです。しかし、フレームを含むTCPセグメント（S）のいずれも認められていないと再送が潜在的に有効なフレームをもたらすことができれば、実装が代わりにこれらのセグメントを削除でき（それらは選択部8によれば、）解雇（承認された場合renege [RFC2018]）。"
    },
    {
      "indent": 0,
      "text": "3.7. TCP Header Protection",
      "section_title": true,
      "ja": "3.7。 TCPヘッダ保護"
    },
    {
      "indent": 3,
      "text": "The ciphertext field of the encryption frame contains protected versions of certain TCP header values.",
      "ja": "暗号化フレームの暗号文フィールドは、特定のTCPヘッダ値の保護されたバージョンを含んでいます。"
    },
    {
      "indent": 3,
      "text": "When the URGp bit is set, the urgent field indicates an offset from the current frame's beginning offset; the sum of these offsets gives the index of the last byte of urgent data in the application datastream.",
      "ja": "URGpビットがセットされている場合、緊急のフィールドには、現在のオフセットフレームの先頭からのオフセットを示します。これらのオフセットの合計は、アプリケーションのデータストリームにおける緊急データの最後のバイトのインデックスを提供します。"
    },
    {
      "indent": 3,
      "text": "A sender MUST set the FINp bit on the last frame it sends in the connection (unless it aborts the connection) and MUST NOT set FINp on any other frame.",
      "ja": "送信者は、（それが接続を中止しない限り）接続では、送信する最後のフレームにFINpビットを設定しなければなりませんし、他のフレームにFINpを設定してはいけません。"
    },
    {
      "indent": 3,
      "text": "TCP sets the FIN flag when a sender has no more data, which with tcpcrypt means setting FIN on the segment containing the last byte of the last frame. However, a receiver MUST report the end-of-file condition to the connection's local user when and only when it receives a frame with the FINp bit set. If a host receives a segment with the TCP FIN flag set but the received datastream including this segment does not contain a frame with FINp set, the host SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if there are unacknowledged segments whose retransmission could potentially result in a valid frame, the host MAY instead drop the segment with the TCP FIN flag set (and renege if it has been SACKed, according to Section 8 of [RFC2018]).",
      "ja": "TCPは、送信者がtcpcryptと最後のフレームの最後のバイトを含むセグメントにFINを設定することを意味し、それ以上データがないFINフラグを設定します。しかし、受信機は、接続するときのローカルユーザーにファイル終了条件を報告しなければなりませんし、それがFINpビットがセットされたフレームを受信した場合にのみ。ホストが設定TCP FINフラグが、FINpが設定されたフレームが含まれていないこのセグメントを含む受信データストリームを有するセグメントを受信した場合、ホストは接続を中止し、エンドオブファイル条件とは異なるエラー条件を上げるべきです。しかし、その再送潜在的に有効なフレームが生じる可能性が未確認のセグメントがある場合、ホストは代わりにTCP FINフラグが設定されたセグメントを削除でき（[RFC2018]のセクション8によれば、それは解雇されている場合renege）。"
    },
    {
      "indent": 0,
      "text": "3.8. Rekeying",
      "section_title": true,
      "ja": "3.8。鍵の変更"
    },
    {
      "indent": 3,
      "text": "Rekeying allows hosts to wipe from memory keys that could decrypt previously transmitted segments. It also allows the use of AEAD ciphers that can securely encrypt only a bounded number of messages under a given key.",
      "ja": "リキーは、ホストが以前に送信されたセグメントを復号することができ、メモリキーからワイプすることを可能にします。また、安全に与えられたキーの下のメッセージのみ有界数を暗号化することができますAEAD暗号を使用することができます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3.3, a master key mk[j] is used to generate two encryption keys k_ab[j] and k_ba[j]. We refer to these as a key set with generation number \"j\". Each host maintains both a local generation number that determines which key set it uses to encrypt outgoing frames and a remote generation number equal to the highest generation used in frames received from its peer. Initially, these two generation numbers are set to zero.",
      "ja": "セクション3.3で説明したように、マスター鍵MK [j]は2つの暗号化鍵k_ab [J]とk_ba [j]を生成するために使用されます。私たちは、世代番号「J」に設定したキーとしてこれらを参照してください。各ホストは、それが送信フレームを暗号化するために使用するキーセットとそのピアから受信したフレームに使用される最高世代に等しいリモート世代番号を決定ローカル世代番号の両方を維持します。最初は、これらの二つの世代番号はゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "A host MAY increment its local generation number beyond the remote generation number it has recorded. We call this action \"initiating rekeying\".",
      "ja": "ホストは、それが記録しているリモート世代数を超えてその地域の世代番号をインクリメントするかもしれません。私たちは、このアクション「再入力を開始する」と呼びます。"
    },
    {
      "indent": 3,
      "text": "When a host has incremented its local generation number and uses the new key set for the first time to encrypt an outgoing frame, it MUST set rekey = 1 for that frame. It MUST set rekey = 0 in all other cases.",
      "ja": "ホストはそのローカル世代番号をインクリメントし、送信フレームを暗号化するために最初に新しいキーセットを使用した場合、そのフレームについてリキー= 1を設定しなければなりません。これは、他のすべての場合にリキー= 0を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a host receives a frame with rekey = 1, it increments its record of the remote generation number. If the remote generation number is now greater than the local generation number, the receiver MUST immediately increment its local generation number to match. Moreover, if the receiver has not yet transmitted a segment with the FIN flag set, it MUST immediately send a frame (with empty application data if necessary) with rekey = 1.",
      "ja": "ホストはリキー= 1のフレームを受信すると、遠隔世代番号のそのレコードをインクリメントします。リモート世代番号が現在ローカル世代番号よりも大きい場合、受信機はすぐに一致するようにそのローカル世代番号をインクリメントしなければなりません。受信機はまだFINフラグが設定されたセグメントを送信していない場合には（必要であれば、空のアプリケーションデータを含む）また、それはすぐに再入力= 1のフレームを送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A host MUST NOT initiate more than one concurrent rekey operation if it has no data to send; that is, it MUST NOT initiate rekeying with an empty encryption frame more than once while its record of the remote generation number is less than its own.",
      "ja": "それが送信するデータがない場合は、ホストは、複数の同時再入力操作を開始してはなりません。リモート世代番号のその記録は、自身のより小さい間つまり、それは複数回の空の暗号化フレームと再入力を開始してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that when parts of the datastream are retransmitted, TCP requires that implementations always send the same data bytes for the same TCP sequence numbers. Thus, frame data in retransmitted segments MUST be encrypted with the same key as when it was first transmitted, regardless of the current local generation number.",
      "ja": "データストリームの部分が再送されるとき、TCPは実装が常に同じTCPシーケンス番号の同じデータバイトを送信することを必要とすることに注意してください。したがって、再送セグメント内のフレームデータは、それが最初にかかわらず、現在のローカル世代番号の、送信されたときと同じキーで暗号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD delete older-generation keys from memory once they have received all frames they will need to decrypt with the old keys and have encrypted all outgoing frames under the old keys.",
      "ja": "彼らは古いキーで復号化するために必要なすべてのフレームを受信して​​いると古いキーの下にあるすべての発信フレームを暗号化した後、実装はメモリから旧世代のキーを削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.9. Keep-Alive",
      "section_title": true,
      "ja": "3.9。生き続ける"
    },
    {
      "indent": 3,
      "text": "Instead of using TCP keep-alives to verify that the remote endpoint is still responsive, tcpcrypt implementations SHOULD employ the rekeying mechanism for this purpose, as follows. When necessary, a host SHOULD probe the liveness of its peer by initiating rekeying and transmitting a new frame immediately (with empty application data if necessary).",
      "ja": "代わりに、リモートエンドポイントがまだ応答性であることを確認するためのTCPキープアライブを使用するのでは、次のように、tcpcrypt実装は、この目的のためにキーの再発行メカニズムを採用する必要があります。必要な場合、ホストは、キー更新を開始し、（必要であれば、空のアプリケーションデータと）すぐに新しいフレームを送信することによってピアの生存性を調べるべきです。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3.8, a host receiving a frame encrypted under a generation number greater than its own MUST increment its own generation number and (if it has not already transmitted a segment with FIN set) immediately transmit a new frame (with zero-length application data if necessary).",
      "ja": "3.8節で説明したように（それが既にFIN設定されたセグメントを送信していない場合）、それ自身よりも大きい世代番号の下で暗号化されたフレームを受信したホストは、自身の世代番号とを増加しなければならない直ちにゼロ長さ（新しいフレームを送信アプリケーションのデータを必要に応じて）。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY use TCP keep-alives for purposes that do not require endpoint authentication, as discussed in Section 8.2.",
      "ja": "実装は8.2節で述べたように、エンドポイント認証を必要としない目的のためのTCPキープアライブを使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "4. Encodings",
      "section_title": true,
      "ja": "4.エンコーディング"
    },
    {
      "indent": 3,
      "text": "This section provides byte-level encodings for values transmitted or computed by the protocol.",
      "ja": "このセクションでは、透過又はプロトコルによって計算された値のバイト・レベル・エンコーディングを提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. Key-Exchange Messages",
      "section_title": true,
      "ja": "4.1。キーメッセージを交換します"
    },
    {
      "indent": 3,
      "text": "The Init1 message has the following encoding:",
      "ja": "INIT1メッセージは、次のエンコードがあります。"
    },
    {
      "indent": 7,
      "text": "byte   0       1       2       3\n   +-------+-------+-------+-------+\n   |          INIT1_MAGIC          |\n   |                               |\n   +-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "    4        5      6       7\n+-------+-------+-------+-------+\n|          message_len          |\n|              = M              |\n+-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "    8\n+--------+-----+----+-----+----+---...---+-----+-----+\n|nciphers|sym_      |sym_      |         |sym_       |\n| = K    |cipher[0] |cipher[1] |         |cipher[K-1]|\n+--------+-----+----+-----+----+---...---+-----+-----+",
      "raw": true
    },
    {
      "indent": 14,
      "text": " 2*K + 9                     2*K + 9 + N_A_LEN\n    |                         |\n    v                         v\n+-------+---...---+-------+-------+---...---+-------+\n|           N_A           |          Pub_A          |\n|                         |                         |\n+-------+---...---+-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "                    M - 1\n+-------+---...---+-------+\n|         ignored         |\n|                         |\n+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The constant INIT1_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init1 message, encoded as a big-endian integer. The nciphers field contains an integer value that specifies the number of two-byte symmetric-cipher identifiers that follow. The sym_cipher[i] identifiers indicate cryptographic algorithms in Table 5 in Section 7. The length N_A_LEN and the length of Pub_A are both determined by the negotiated TEP as described in Section 5.",
      "ja": "定数INIT1_MAGICは、4.3節で定義されています。 4バイトのフィールドmessage_lenはビッグエンディアン整数としてエンコード、全体INIT1メッセージの長さを与えます。 nciphersフィールドは、続く2つのバイトの対称暗号識別子の数を指定する整数値を含みます。 sym_cipher [i]の識別子は、セクション5で説明したように第7表5における暗号アルゴリズム長N_A_LENとPub_Aの長さが両方のネゴシエートTEPによって決定される示します。"
    },
    {
      "indent": 3,
      "text": "Implementations of this protocol MUST construct Init1 such that the ignored field has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the field Pub_A. When receiving Init1, however, implementations MUST permit and ignore any bytes following Pub_A.",
      "ja": "このプロトコルの実装は無視フィールドはゼロ長さを有するようINIT1を構築しなければなりません。つまり、それらはmessage_lenによって決定されるように、その端部が、フィールドPub_Aの端部と一致するようにメッセージを構成しなければなりません。 INIT1を受信すると、しかし、実装が許可しPub_A以下のいずれかのバイトを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Init2 message has the following encoding:",
      "ja": "INIT2メッセージは、次のエンコードがあります。"
    },
    {
      "indent": 7,
      "text": "byte   0       1       2       3\n   +-------+-------+-------+-------+\n   |          INIT2_MAGIC          |\n   |                               |\n   +-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "    4        5      6       7       8       9\n+-------+-------+-------+-------+-------+-------+\n|          message_len          |  sym_cipher   |\n|              = M              |               |\n+-------+-------+-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "    10                      10 + N_B_LEN\n    |                         |\n    v                         v\n+-------+---...---+-------+-------+---...---+-------+\n|           N_B           |          Pub_B          |\n|                         |                         |\n+-------+---...---+-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "                    M - 1\n+-------+---...---+-------+\n|          ignored        |\n|                         |\n+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The constant INIT2_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init2 message, encoded as a big-endian integer. The sym_cipher value is a selection from the symmetric-cipher identifiers in the previously-received Init1 message. The length N_B_LEN and the length of Pub_B are both determined by the negotiated TEP as described in Section 5.",
      "ja": "定数INIT2_MAGICは、4.3節で定義されています。 4バイトのフィールドmessage_lenはビッグエンディアン整数としてエンコード、全体INIT2メッセージの長さを与えます。 sym_cipher値は、以前に受信したINIT1メッセージ内の対称暗号識別子から選択です。セクション5で説明したように長さN_B_LENとPub_Bの長さは、両方のネゴシエートTEPによって決定されます。"
    },
    {
      "indent": 3,
      "text": "Implementations of this protocol MUST construct Init2 such that the field \"ignored\" has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the Pub_B field. When receiving Init2, however, implementations MUST permit and ignore any bytes following Pub_B.",
      "ja": "このプロトコルの実装はINIT2を構築しなければならない「無視」フィールドはゼロ長さを有するように。つまり、それらはmessage_lenによって決定されるように、その端部が、Pub_Bフィールドの終わりと一致するようにメッセージを構成しなければなりません。 INIT2を受信すると、しかし、実装が許可しPub_B以下のいずれかのバイトを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Encryption Frames",
      "section_title": true,
      "ja": "4.2。暗号化フレーム"
    },
    {
      "indent": 3,
      "text": "An encryption frame comprises a control byte and a length-prefixed ciphertext value:",
      "ja": "暗号化フレームは、制御バイトと長さ接頭辞暗号文値を含みます。"
    },
    {
      "indent": 10,
      "text": "byte   0       1       2       3               clen+2\n   +-------+-------+-------+-------+---...---+-------+\n   |control|      clen     |        ciphertext       |\n   +-------+-------+-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The field clen is an integer in big-endian format and gives the length of the ciphertext field.",
      "ja": "フィールドクレンは、ビッグエンディアン形式で整数で、暗号文フィールドの長さを与えます。"
    },
    {
      "indent": 3,
      "text": "The control field has this structure:",
      "ja": "制御フィールドは、この構造を有します："
    },
    {
      "indent": 18,
      "text": "bit     7                 1       0\n    +-------+---...---+-------+-------+\n    |          cres           | rekey |\n    +-------+---...---+-------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The seven-bit field cres is reserved; implementations MUST set these bits to zero when sending and MUST ignore them when receiving.",
      "ja": "7ビットのフィールドCRESが予約されています。実装は、送信時にゼロにこれらのビットを設定しなければならなくて、受信した場合、それらを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The use of the rekey field is described in Section 3.8.",
      "ja": "再入力フィールドの使用は、3.8節に記述されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Plaintext",
      "section_title": true,
      "ja": "4.2.1。プレーンテキスト"
    },
    {
      "indent": 3,
      "text": "The ciphertext field is the result of applying the negotiated authenticated-encryption algorithm to a plaintext value, which has one of these two formats:",
      "ja": "暗号文フィールドは、これら二つのフォーマットのうちの1つを有する平文値にネゴシエートされた認証された暗号化アルゴリズムを適用した結果です。"
    },
    {
      "indent": 10,
      "text": "byte   0       1               plen-1\n   +-------+-------+---...---+-------+\n   | flags |           data          |\n   +-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "byte   0       1       2       3               plen-1\n   +-------+-------+-------+-------+---...---+-------+\n   | flags |    urgent     |          data           |\n   +-------+-------+-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(Note that clen in the previous section will generally be greater than plen, as the ciphertext produced by the authenticated-encryption scheme both encrypts the application data and provides redundancy with which to verify its integrity.)",
      "ja": "（両方のアプリケーションデータを暗号化し、その完全性を検証すると共に冗長性を提供し、認証・暗号化方式によって生成された暗号文として、一般PLENより大きくなる前のセクションでそのクレンに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The flags field has this structure:",
      "ja": "フラグフィールドは、この構造を有します："
    },
    {
      "indent": 15,
      "text": "bit    7    6    5    4    3    2    1    0\n    +----+----+----+----+----+----+----+----+\n    |            fres             |URGp|FINp|\n    +----+----+----+----+----+----+----+----+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The six-bit field fres is reserved; implementations MUST set these six bits to zero when sending, and MUST ignore them when receiving.",
      "ja": "6ビットのフィールドFRESが予約されています。実装は、送信時にゼロにこれらの6ビットを設定しなければなりません、そして受信した場合、それらを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the URGp bit is set, it indicates that the urgent field is present, and thus that the plaintext value has the second structure variant above; otherwise, the first variant is used.",
      "ja": "URGpビットがセットされている場合、それは緊急フィールドが存在すること、及び平文値が上記第2の構造変異体を有し、したがってことを示しています。それ以外の場合は、最初のバリアントが使用されています。"
    },
    {
      "indent": 3,
      "text": "The meaning of the urgent field and of the flag bits is described in Section 3.7.",
      "ja": "緊急フィールドのフラグビットの意味は、3.7節に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Associated Data",
      "section_title": true,
      "ja": "4.2.2。関連するデータ"
    },
    {
      "indent": 3,
      "text": "An encryption frame's associated data (which is supplied to the AEAD algorithm when decrypting the ciphertext and verifying the frame's integrity) has this format:",
      "ja": "（暗号文を復号化し、フレームの整合性を検証する場合AEADアルゴリズムに供給される）暗号化フレームの関連するデータは、この形式になっています。"
    },
    {
      "indent": 23,
      "text": "byte   0       1       2\n   +-------+-------+-------+\n   |control|     clen      |\n   +-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It contains the same values as the frame's control and clen fields.",
      "ja": "これは、フレームの制御やクレンフィールドと同じ値が含まれています。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Frame ID",
      "section_title": true,
      "ja": "4.2.3。フレームID"
    },
    {
      "indent": 3,
      "text": "Lastly, a frame ID (used to construct the nonce for the AEAD algorithm) has this format:",
      "ja": "最後に、（AEADアルゴリズムのnonceを構築するために使用される）、フレームIDは、このフォーマットを有します。"
    },
    {
      "indent": 10,
      "text": "byte  0            ae_nonce_len - 8    ae_nonce_len - 1\n      |                   |             |\n      v                   v             v\n   +-----+--...--+-----+-----+--...--+-----+\n   |  0  |       |  0  |       offset      |\n   +-----+--...--+-----+-----+--...--+-----+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The 8-byte offset field contains an integer in big-endian format. Its value is specified in Section 3.6. Zero-valued bytes are prepended to the offset field to form a structure of length ae_nonce_len.",
      "ja": "8バイトのオフセットフィールドは、ビッグエンディアン形式の整数が含まれています。その値はセクション3.6で指定されています。ゼロ値のバイトは、長さae_nonce_lenの構造を形成するために、オフセット・フィールドの前に付加されています。"
    },
    {
      "indent": 0,
      "text": "4.3. Constant Values",
      "section_title": true,
      "ja": "4.3。定数値"
    },
    {
      "indent": 3,
      "text": "The table below defines values for the constants used in the protocol.",
      "ja": "以下の表は、プロトコルで使用される定数の値を定義します。"
    },
    {
      "indent": 23,
      "text": "+------------+--------------+\n| Value      | Name         |\n+------------+--------------+\n| 0x01       | CONST_NEXTK  |\n| 0x02       | CONST_SESSID |\n| 0x03       | CONST_REKEY  |\n| 0x04       | CONST_KEY_A  |\n| 0x05       | CONST_KEY_B  |\n| 0x06       | CONST_RESUME |\n| 0x15101a0e | INIT1_MAGIC  |\n| 0x097105e0 | INIT2_MAGIC  |\n+------------+--------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Table 1: Constant Values Used in the Protocol",
      "ja": "表1：プロトコルで使用される定数値"
    },
    {
      "indent": 0,
      "text": "5. Key-Agreement Schemes",
      "section_title": true,
      "ja": "5.キー契約スキーム"
    },
    {
      "indent": 3,
      "text": "The TEP negotiated via TCP-ENO indicates the use of one of the key-agreement schemes named in Table 4 in Section 7. For example, TCPCRYPT_ECDHE_P256 names the tcpcrypt protocol using ECDHE-P256 together with the CPRF and length parameters specified below.",
      "ja": "TCP-ENOを介して交渉さTEPは、例えば、セクション7の表4で指定された鍵合意方式の1つの使用を示し、TCPCRYPT_ECDHE_P256名以下に指定CPRF及び長さパラメータと共にECDHE-P256を用いtcpcryptプロトコル。"
    },
    {
      "indent": 3,
      "text": "All the TEPs specified in this document require the use of HKDF-Expand-SHA256 as the CPRF, and these lengths for nonces and session secrets:",
      "ja": "この文書で指定されたすべてのTEPSはCPRFとしてHKDF-展開-SHA256の使用、およびナンスおよびセッションの秘密のためのこれらの長さが必要です。"
    },
    {
      "indent": 29,
      "text": "N_A_LEN: 32 bytes\nN_B_LEN: 32 bytes\nK_LEN:   32 bytes",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Future documents assigning additional TEPs for use with tcpcrypt might specify different values for the lengths above. Note that the minimum session ID length specified by TCP-ENO, together with the way tcpcrypt constructs session IDs, implies that K_LEN MUST have length at least 32 bytes.",
      "ja": "tcpcryptで使用するための追加TEPSを割り当てる将来の文書は、上記の長さに異なる値を指定できます。一緒にセッションIDを構築tcpcrypt方法で、TCP-ENOによって指定された最小のセッションID長ことに注意してください、K_LENは長さは少なくとも32バイトが必要であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Key-agreement schemes ECDHE-P256 and ECDHE-P521 employ the Elliptic Curve Secret Value Derivation Primitive, Diffie-Hellman version (ECSVDP-DH) defined in [IEEE-1363]. The named curves are defined in [NIST-DSS]. When the public-key values Pub_A and Pub_B are transmitted as described in Section 4.1, they are encoded with the \"Elliptic Curve Point to Octet String Conversion Primitive\" described in Section E.2.3 of [IEEE-1363] and are prefixed by a two-byte length in big-endian format:",
      "ja": "キー契約スキームECDHE-P256とECDHE-P521は、[IEEE-1363]で定義されたプリミティブ楕円曲線秘密値の導出、のDiffie-Hellmanバージョン（ECSVDP-DH）を採用します。名前の曲線は[NIST-DSS]で定義されています。公開鍵値Pub_AとPub_Bは、セクション4.1で説明したように、彼らは[IEEE-1363]のセクションE.2.3に記載の「プリミティブオクテットストリングへの変換に楕円曲線点」で符号化され、2つの前置され送信された場合ビッグエンディアン形式で-byte長さ："
    },
    {
      "indent": 14,
      "text": "byte   0       1       2               L - 1\n   +-------+-------+-------+---...---+-------+\n   |   pubkey_len  |          pubkey         |\n   |      = L      |                         |\n   +-------+-------+-------+---...---+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Implementations MUST encode these pubkey values in \"compressed format\". Implementations MUST validate these pubkey values according to the algorithm in Section A.16.10 of [IEEE-1363].",
      "ja": "実装は、「圧縮形式」でこれらpubkeyで値を符号化しなければなりません。実装は[IEEE-1363]のセクションA.16.10におけるアルゴリズムに従ってこれらpubkeyで値を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Key-agreement schemes ECDHE-Curve25519 and ECDHE-Curve448 perform the Diffie-Hellman protocol using the functions X25519 and X448, respectively. Implementations SHOULD compute these functions using the algorithms described in [RFC7748]. When they do so, implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. Alternative implementations of these functions SHOULD abort when either input forces the shared secret to one of a small set of values as discussed in Section 7 of [RFC7748].",
      "ja": "キー契約スキームECDHE-Curve25519とECDHE-Curve448は、それぞれの機能のX25519とX448を使用してのDiffie-Hellmanプロトコルを実行します。実装は、[RFC7748]に記載されたアルゴリズムを使用してこれらの関数を計算すべきです。彼らがそうする場合、実装は、計算ディフィ - ヘルマン秘密は、すべてゼロの値であり、そうであれば、[RFC7748]のセクション6で説明したように、アボート共有するかどうかをチェックしなければなりません。 [RFC7748]のセクション7で説明したように、入力は、値の小さなセットのうちの1つに共有秘密を強制的にいずれかの場合、これらの機能の代替の実装は中止すべきです。"
    },
    {
      "indent": 3,
      "text": "For these schemes, public-key values Pub_A and Pub_B are transmitted directly with no length prefix: 32 bytes for ECDHE-Curve25519 and 56 bytes for ECDHE-Curve448.",
      "ja": "これらのスキームのために、公開鍵値Pub_AとPub_Bはない長さのプレフィックスを直接伝送される。ECDHE-Curve25519ための32バイト、56のバイトをECDHE-Curve448ため。"
    },
    {
      "indent": 3,
      "text": "Table 2 below specifies the requirement levels of the four TEPs specified in this document. In particular, all implementations of tcpcrypt MUST support TCPCRYPT_ECDHE_Curve25519. However, system administrators MAY configure which TEPs a host will negotiate independent of these implementation requirements.",
      "ja": "2以下の表は、この文書で指定された4つのTEPSの要求レベルを指定します。特に、tcpcryptのすべての実装はTCPCRYPT_ECDHE_Curve25519をサポートしなければなりません。しかし、システム管理者は、ホストがこれらの実装要件とは独立して交渉しますTEPSどの設定することができます。"
    },
    {
      "indent": 16,
      "text": "+-------------+---------------------------+\n| Requirement | TEP                       |\n+-------------+---------------------------+\n| REQUIRED    | TCPCRYPT_ECDHE_Curve25519 |\n| RECOMMENDED | TCPCRYPT_ECDHE_Curve448   |\n| OPTIONAL    | TCPCRYPT_ECDHE_P256       |\n| OPTIONAL    | TCPCRYPT_ECDHE_P521       |\n+-------------+---------------------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Table 2: Requirements for Implementation of TEPs",
      "ja": "表2：TEPSの実装のための要件"
    },
    {
      "indent": 0,
      "text": "6. AEAD Algorithms",
      "section_title": true,
      "ja": "6. AEADアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This document uses sym_cipher identifiers in the messages Init1 and Init2 (see Section 3.3) to negotiate the use of AEAD algorithms; the values of these identifiers are given in Table 5 in Section 7. The algorithms AEAD_AES_128_GCM and AEAD_AES_256_GCM are specified in [RFC5116]. The algorithm AEAD_CHACHA20_POLY1305 is specified in [RFC8439].",
      "ja": "この文書では、AEADアルゴリズムの使用を交渉する（セクション3.3を参照）メッセージINIT1及びINIT2にsym_cipher識別子を使用します。これらの識別子の値は、アルゴリズムAEAD_AES_128_GCMとAEAD_AES_256_GCMは[RFC5116]で指定された第7の表5に示します。アルゴリズムAEAD_CHACHA20_POLY1305は[RFC8439]で指定されています。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support certain AEAD algorithms according to Table 3. Note that system administrators MAY configure which algorithms a host will negotiate independently of these requirements.",
      "ja": "実装は、システム管理者は、独立して、これらの要件を交渉するホストのアルゴリズムれる構成してもよいことが、表3注に従って特定AEADアルゴリズムをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Lastly, this document uses the lengths ae_key_len and ae_nonce_len to specify aspects of encryption and data formats. These values depend on the negotiated AEAD algorithm, also according to the table below.",
      "ja": "最後に、この文書は、暗号化およびデータのフォーマットの側面を指定するae_key_lenとae_nonce_len長さを使用しています。これらの値は、以下の表に従って、ネゴシエートAEADアルゴリズムに依存します。"
    },
    {
      "indent": 3,
      "text": "+------------------------+-------------+------------+--------------+\n| AEAD Algorithm         | Requirement | ae_key_len | ae_nonce_len |\n+------------------------+-------------+------------+--------------+\n| AEAD_AES_128_GCM       | REQUIRED    | 16 bytes   | 12 bytes     |\n| AEAD_AES_256_GCM       | RECOMMENDED | 32 bytes   | 12 bytes     |\n| AEAD_CHACHA20_POLY1305 | RECOMMENDED | 32 bytes   | 12 bytes     |\n+------------------------+-------------+------------+--------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Table 3: Requirement and Lengths for Each AEAD Algorithm",
      "ja": "表3：各AEADアルゴリズムのための要件と長さ"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "For use with TCP-ENO's negotiation mechanism, tcpcrypt's TEP identifiers have been incorporated in IANA's \"TCP Encryption Protocol Identifiers\" registry under the \"Transmission Control Protocol (TCP) Parameters\" registry, as in Table 4. The various key-agreement schemes used by these tcpcrypt variants are defined in Section 5.",
      "ja": "TCP-ENOの交渉メカニズムで使用する場合は、tcpcryptのTEP識別子がで使用される様々なキー合意スキーム表4のように、「伝送制御プロトコル（TCP）パラメータ」レジストリの下でIANAの「TCP暗号化プロトコル識別子」レジストリに組み込まれていますこれらtcpcrypt変異体は、第5節で定義されています。"
    },
    {
      "indent": 13,
      "text": "+-------+---------------------------+-----------+\n| Value | Meaning                   | Reference |\n+-------+---------------------------+-----------+\n| 0x21  | TCPCRYPT_ECDHE_P256       | [RFC8548] |\n| 0x22  | TCPCRYPT_ECDHE_P521       | [RFC8548] |\n| 0x23  | TCPCRYPT_ECDHE_Curve25519 | [RFC8548] |\n| 0x24  | TCPCRYPT_ECDHE_Curve448   | [RFC8548] |\n+-------+---------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 4: TEP Identifiers for Use with tcpcrypt",
      "ja": "表4：tcpcryptで使用するためのTEP識別子"
    },
    {
      "indent": 3,
      "text": "In Section 6, this document defines the use of several AEAD algorithms for encrypting application data. To name these algorithms, the tcpcrypt protocol uses two-byte identifiers in the range 0x0001 to 0xFFFF, inclusively, for which IANA maintains a new \"tcpcrypt AEAD Algorithms\" registry under the \"Transmission Control Protocol (TCP) Parameters\" registry. The initial values for this registry are given in Table 5. Future assignments are to be made upon satisfying either of two policies defined in [RFC8126]: \"IETF Review\" or (for non-IETF stream specifications) \"Expert Review with RFC Required.\" IANA will furthermore provide early allocation [RFC7120] to facilitate testing before RFCs are finalized.",
      "ja": "第6節では、この文書では、アプリケーションデータを暗号化するためのいくつかのAEADアルゴリズムの使用を規定します。これらのアルゴリズムに名前を付けるには、tcpcryptプロトコルが、0xFFFFの範囲は0x0001に2バイトの識別子を使用して、包括的に、そのためにIANAは、「伝送制御プロトコル（TCP）パラメータ」レジストリの下に新しい「AEADアルゴリズムtcpcrypt」レジストリを維持します。 「IETFレビュー」または（のための非IETFストリーム仕様）「RFC必要と専門家レビュー：このレジストリの初期値は、今後の割り当ては、[RFC8126]で定義された2つのポリシーのいずれかを満たす時に行わなければならない表に示されています。 \" IANAはさらに、RFCのが確定される前に、テストを容易にするために、初期割り当て[RFC7120]を提供します。"
    },
    {
      "indent": 8,
      "text": "+--------+------------------------+----------------------+\n| Value  | AEAD Algorithm         | Reference            |\n+--------+------------------------+----------------------+\n| 0x0001 | AEAD_AES_128_GCM       | [RFC8548], Section 6 |\n| 0x0002 | AEAD_AES_256_GCM       | [RFC8548], Section 6 |\n| 0x0010 | AEAD_CHACHA20_POLY1305 | [RFC8548], Section 6 |\n+--------+------------------------+----------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Table 5: Authenticated-Encryption Algorithms for Use with tcpcrypt",
      "ja": "表5：tcpcryptで使用するための認証・暗号化アルゴリズム"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "All of the security considerations of TCP-ENO apply to tcpcrypt. In particular, tcpcrypt does not protect against active network attackers unless applications authenticate the session ID. If it can be established that the session IDs computed at each end of the connection match, then tcpcrypt guarantees that no man-in-the-middle attacks occurred unless the attacker has broken the underlying cryptographic primitives, e.g., Elliptic Curve Diffie-Hellman (ECDH). A proof of this property for an earlier version of the protocol has been published [tcpcrypt].",
      "ja": "TCP-ENOのセキュリティ上の考慮事項のすべてがtcpcryptに適用されます。アプリケーションは、セッションIDを認証しない限り、特に、tcpcryptは、アクティブなネットワーク攻撃を防ぐことはできません。セッションIDは、接続の試合の両端に計算することを確立することができるならば、tcpcryptは、楕円曲線のDiffie-Hellmanの（例えば、攻撃者は、基礎となる暗号プリミティブが壊れていない限り、man-in-the-middle攻撃が発生していないことを保証しますECDH）。プロトコルの以前のバージョンのために、このプロパティの証拠は、[tcpcrypt】公開されています。"
    },
    {
      "indent": 3,
      "text": "To ensure middlebox compatibility, tcpcrypt does not protect TCP headers. Therefore, the protocol is vulnerable to denial-of-service from off-path attackers just as plain TCP is. Possible attacks include desynchronizing the underlying TCP stream, injecting RST or FIN segments, and forging rekey bits. These attacks will cause a tcpcrypt connection to hang or fail with an error, but not in any circumstance where plain TCP could continue uncorrupted. Implementations MUST give higher-level software a way to distinguish such errors from a clean end-of-stream (indicated by an authenticated FINp bit) so that applications can avoid semantic truncation attacks.",
      "ja": "ミドルの互換性を確保するために、tcpcryptは、TCPヘッダを保護することはできません。したがって、プロトコルは普通TCPが同様のサービス拒否オフパス攻撃からに対して脆弱です。可能性のある攻撃は、基本的なTCPストリームを非同期化RSTまたはFINセグメントを注入して、再入力ビットを鍛造あります。これらの攻撃はtcpcrypt接続がなく、プレーンなTCPが破損していない続けることができるどのような状況で、ハングアップまたはエラーで失敗します。実装は、より高いレベルのソフトウェアにアプリケーションがセマンティックトランケーション攻撃を避けることができるように、清浄なエンドオブストリーム（認証FINpビットによって示される）から、このようなエラーを区別するための方法を与えなければなりません。"
    },
    {
      "indent": 3,
      "text": "There is no \"key confirmation\" step in tcpcrypt. This is not needed because tcpcrypt's threat model includes the possibility of a connection to an adversary. If key negotiation is compromised and yields two different keys, failed integrity checks on every subsequent frame will cause the connection either to hang or to abort. This is not a new threat as an active attacker can achieve the same results against a plain TCP connection by injecting RST segments or modifying sequence and acknowledgement numbers.",
      "ja": "tcpcryptには、「キーの確認」のステップはありません。 tcpcryptの脅威モデルが敵との接続の可能性を含んでいるので、これは必要ありません。キー交渉が損なわ2つの異なる鍵を生成している場合、すべての後続フレームに整合性チェックに失敗しましたハングアップするか中止するかのいずれかの接続が発生します。これは、RSTセグメントを注入またはシーケンスおよび確認応答番号を変更することで、プレーンなTCPコネクションに対して同じ結果を得ることができ、アクティブ攻撃など新たな脅威ではありません。"
    },
    {
      "indent": 3,
      "text": "Tcpcrypt uses short-lived public keys to provide forward secrecy; once an implementation removes these keys from memory, a compromise of the system will not provide any means to derive the session secrets for past connections. All currently-specified key agreement schemes involve key agreement based on Ephemeral Elliptic Curve Diffie-Hellman (ECDHE), meaning a new key pair can be efficiently computed for each connection. If implementations reuse these parameters, they MUST limit the lifetime of the private parameters as far as is practical in order to minimize the number of past connections that are vulnerable. Of course, placing private keys in persistent storage introduces severe risks that they will not be destroyed reliably and in a timely fashion, and it SHOULD be avoided whenever possible.",
      "ja": "Tcpcryptは前進の秘密保持を提供するために、短命の公開キーを使用しています。実装がメモリからこれらのキーを削除したら、システムの妥協は過去の接続のためのセッションの秘密を導出するための任意の手段を提供することはありません。すべての現在指定された鍵合意方式は、新しい鍵ペアが効率的に接続ごとに計算されることができることを意味し、エフェメラル楕円曲線のDiffie-Hellmanの（ECDHE）に基づいて、鍵の合意を必要とします。実装は、これらのパラメータを再利用した場合、彼らは脆弱で、過去の接続数を最小限にするために実用的である限り、プライベート・パラメータの寿命を制限しなければなりません。もちろん、永続ストレージに秘密鍵を置くことは、彼らが確実かつタイムリーに破壊されることはありません深刻なリスクを紹介し、それは可能な限り避けるべきです。"
    },
    {
      "indent": 3,
      "text": "Attackers cannot force passive openers to move forward in their session resumption chain without guessing the content of the resumption identifier, which will be difficult without key knowledge.",
      "ja": "攻撃者は、キー知識がなくても困難であろう再開識別子の内容を推測することなく、セッション再開チェーンに前進するパッシブオープナーを強制することはできません。"
    },
    {
      "indent": 3,
      "text": "The cipher-suites specified in this document all use HMAC-SHA256 to implement the collision-resistant pseudo-random function denoted by CPRF. A collision-resistant function is one for which, for sufficiently large L, an attacker cannot find two distinct inputs (K_1, CONST_1) and (K_2, CONST_2) such that CPRF(K_1, CONST_1, L) = CPRF(K_2, CONST_2, L). Collision resistance is important to assure the uniqueness of session IDs, which are generated using the CPRF.",
      "ja": "この文書で指定された暗号スイートはすべて、CPRFで示さ衝突耐性擬似ランダム関数を実装するためにHMAC-SHA256を使用します。衝突耐性関数は、十分に大きいLのために、攻撃者は、2つの別個の入力（K_1、CONST_1）及び（K_2、CONST_2）ようCPRF（K_1、CONST_1、L）= CPRF（K_2、CONST_2を見つけることができない、ためのものですL）。衝突抵抗はCPRFを使用して生成されたセッションIDの一意性を保証することが重要です。"
    },
    {
      "indent": 3,
      "text": "Lastly, many of tcpcrypt's cryptographic functions require random input, and thus any host implementing tcpcrypt MUST have access to a cryptographically-secure source of randomness or pseudo-randomness. [RFC4086] provides recommendations on how to achieve this.",
      "ja": "最後に、tcpcryptの暗号化機能の多くは、ランダムな入力を必要とし、ひいてはtcpcryptを実装する任意のホストは、ランダムまたは擬似ランダムの暗号的に安全なソースにアクセスする必要があります。 [RFC4086]はこれを達成するための方法に関する推奨事項を提供します。"
    },
    {
      "indent": 3,
      "text": "Most implementations will rely on a device's pseudo-random generator, seeded from hardware events and a seed carried over from the previous boot. Once a pseudo-random generator has been properly seeded, it can generate effectively arbitrary amounts of pseudo-random data. However, until a pseudo-random generator has been seeded with sufficient entropy, not only will tcpcrypt be insecure, it will reveal information that further weakens the security of the pseudo-random generator, potentially harming other applications. As REQUIRED by TCP-ENO, implementations MUST NOT send ENO options unless they have access to an adequate source of randomness.",
      "ja": "ほとんどの実装では、ハードウェアイベントと以前のブートから引き継が種子から播種デバイスの擬似乱数発生器に依存しています。擬似乱数発生器が正常にシードされていたら、それは擬似ランダムデータの効果的、任意の量を生成することができます。擬似乱数発生器は安全でないことtcpcryptだけでなく、十分なエントロピーを播種されるまでしかし、それは潜在的に、他のアプリケーションに悪影響を与える、さらに擬似乱数生成器のセキュリティを弱める情報を明らかにする。 TCP-ENOで要求されているように、彼らはランダム性の十分なソースへのアクセスを持っていない限り、実装はENOオプションを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "8.1. Asymmetric Roles",
      "section_title": true,
      "ja": "8.1。非対称の役割"
    },
    {
      "indent": 3,
      "text": "Tcpcrypt transforms a shared pseudo-random key (PRK) into cryptographic traffic keys for each direction. Doing so requires an asymmetry in the protocol, as the key derivation function must be perturbed differently to generate different keys in each direction. Tcpcrypt includes other asymmetries in the roles of the two hosts, such as the process of negotiating algorithms (e.g., proposing vs. selecting cipher suites).",
      "ja": "Tcpcryptは、各方向の暗号化トラフィックキーに共有擬似ランダム鍵（PRK）を変換します。鍵導出関数は、各方向に異なる鍵を生成するために、異なる摂動されなければならないように行うと、プロトコルの非対称性を必要とします。 Tcpcryptは、このようなアルゴリズムを交渉するプロセスのような2つのホストの役割に他の非対称（例えば、暗号スイートを選択対提案）を含みます。"
    },
    {
      "indent": 0,
      "text": "8.2. Verified Liveness",
      "section_title": true,
      "ja": "8.2。確認済みライブネス"
    },
    {
      "indent": 3,
      "text": "Many hosts implement TCP keep-alives [RFC1122] as an option for applications to ensure that the other end of a TCP connection still exists even when there is no data to be sent. A TCP keep-alive segment carries a sequence number one prior to the beginning of the send window and may carry one byte of \"garbage\" data. Such a segment causes the remote side to send an acknowledgment.",
      "ja": "多くのホストが送信するデータが存在しない場合でも、TCP接続のもう一方の端がまだ存在することを確実にするアプリケーションのためのオプションとしてのTCPキープアライブ[RFC1122]を実装します。 TCPキープアライブセグメントは、送信ウィンドウの開始に先立って、シーケンス番号1を運び、「ゴミ」1バイトのデータを運ぶことができます。そのようなセグメントは、確認応答を送信するようにリモート側を引き起こします。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, tcpcrypt cannot cryptographically verify keep-alive acknowledgments. Therefore, an attacker could prolong the existence of a session at one host after the other end of the connection no longer exists. (Such an attack might prevent a process with sensitive data from exiting, giving an attacker more time to compromise a host and extract the sensitive data.)",
      "ja": "残念ながら、tcpcryptは、暗号キープアライブの確認応答を検証することはできません。そのため、攻撃者は、もはや存在しない、接続のもう一方の端の後に一つのホストでのセッションの存在を延長することができます。 （このような攻撃は、攻撃者はホストを危うくし、機密データを抽出するために多くの時間を与えるから出る機密データとプロセスを妨げる可能性があります。）"
    },
    {
      "indent": 3,
      "text": "To counter this threat, tcpcrypt specifies a way to stimulate the remote host to send verifiably fresh and authentic data, described in Section 3.9.",
      "ja": "この脅威に対抗するため、tcpcryptは3.9節で説明した検証可能新鮮で本物のデータを送信するリモートホストを刺激する方法を指定します。"
    },
    {
      "indent": 3,
      "text": "The TCP keep-alive mechanism has also been used for its effects on intermediate nodes in the network, such as preventing flow state from expiring at NAT boxes or firewalls. As these purposes do not require the authentication of endpoints, implementations MAY safely accomplish them using either the existing TCP keep-alive mechanism or tcpcrypt's verified keep-alive mechanism.",
      "ja": "TCPのキープアライブ機構はまた、NATボックスやファイアウォールで期限切れのフロー状態を防止するようなネットワーク内の中間ノードに対するその効果のために使用されてきました。これらの目的は、エンドポイントの認証を必要としないため、実装が安全には、既存のTCPキープアライブ機構やtcpcryptの検証キープアライブメカニズムのいずれかを使用して達成することができます。"
    },
    {
      "indent": 0,
      "text": "8.3. Mandatory Key-Agreement Schemes",
      "section_title": true,
      "ja": "8.3。必須のキー・契約方式"
    },
    {
      "indent": 3,
      "text": "This document mandates that tcpcrypt implementations provide support for at least one key-agreement scheme: ECDHE using Curve25519. This choice of a single mandatory algorithm is the result of a difficult tradeoff between cryptographic diversity and the ease and security of actual deployment.",
      "ja": "ECDHE Curve25519を使用して：実装をtcpcryptこの文書の義務化は、少なくとも1つのキーの契約スキームのためのサポートを提供します。単一の必須アルゴリズムのこの選択は、暗号多様性と実際の展開のしやすさとセキュリティの難しいトレードオフの結果です。"
    },
    {
      "indent": 3,
      "text": "The IETF's appraisal of best current practice on this matter [RFC7696] says, \"Ideally, two independent sets of mandatory-to-implement algorithms will be specified, allowing for a primary suite and a secondary suite. This approach ensures that the secondary suite is widely deployed if a flaw is found in the primary one.\"",
      "ja": "この問題に関する現在のベストプラクティスのIETFの評価[RFC7696]と言い、「理想的には、実装に必須のアルゴリズムの2つの独立したセットは、プライマリスイートと二スイートを考慮して、指定されます。このアプローチは、二次的スイートであることを保証します欠陥が主な1で発見された場合に広く展開されています。」"
    },
    {
      "indent": 3,
      "text": "To meet that ideal, it might appear natural to also mandate ECDHE using P-256. However, implementing the Diffie-Hellman function using NIST elliptic curves (including those specified for use with tcpcrypt, P-256 and P-521) appears to be very difficult to achieve without introducing vulnerability to side-channel attacks [NIST-fail]. Although well-trusted implementations are available as part of large cryptographic libraries, these can be difficult to extract for use in operating-system kernels where tcpcrypt is usually best implemented. In contrast, the characteristics of Curve25519 together with its recent popularity has led to many safe and efficient implementations, including some that fit naturally into the kernel environment.",
      "ja": "その理想的なを満たすために、また、P-256を使用してECDHEを強制するために自然に見えるかもしれません。しかし、NIST楕円曲線（tcpcryptで使用するために指定されたものを含めて、P-256およびP-521）を用いてのDiffie-Hellman関数を実装する[NISTフェイル]攻撃チャネル側への脆弱性を導入することなく達成することが非常に困難であると思われます。よく、信頼できる実装が大きな暗号化ライブラリの一部として利用可能であるが、これらはtcpcryptは通常、最高実装されているオペレーティング・システムのカーネルで使用するために抽出することが困難な場合があります。これとは対照的に、最近の人気とともにCurve25519の特性は、カーネル環境に自然にフィットするものも含め、多くの安全で効率的な実装、につながっています。"
    },
    {
      "indent": 3,
      "text": "[RFC7696] insists that, \"The selected algorithms need to be resistant to side-channel attacks and also meet the performance, power, and code size requirements on a wide variety of platforms.\" On this principle, tcpcrypt excludes the NIST curves from the set of mandatory-to-implement key-agreement algorithms.",
      "ja": "[RFC7696]は、「選択されたアルゴリズムが耐性にするサイドチャネル攻撃であり、また、プラットフォームの多種多様な性能、消費電力、及びコードのサイズ要件を満たす必要がある。」と主張しますこの原理に、tcpcryptは、実装に必須の鍵合意アルゴリズムのセットからNIST曲線を除外します。"
    },
    {
      "indent": 3,
      "text": "Lastly, this document encourages support for key agreement with Curve448, categorizing it as RECOMMENDED. Curve448 appears likely to admit safe and efficient implementations. However, support is not REQUIRED because existing implementations might not yet be sufficiently well proven.",
      "ja": "最後に、この文書では推奨されているように、それを分類、Curve448との鍵合意のためのサポートを奨励しています。 Curve448は、安全で効率的な実装を認める可能性が表示されます。既存の実装がまだ十分に証明されない場合がありますのでただし、サポートは必要ありません。"
    },
    {
      "indent": 0,
      "text": "9. Experiments",
      "section_title": true,
      "ja": "9.実験"
    },
    {
      "indent": 3,
      "text": "Some experience will be required to determine whether the tcpcrypt protocol can be deployed safely and successfully across the diverse environments of the global internet.",
      "ja": "いくつかの経験がtcpcryptプロトコルは、グローバルなインターネットの多様な環境全体を安全かつ成功裏に展開することができるかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "Safety means that TCP implementations that support tcpcrypt are able to communicate reliably in all the same settings as they would without tcpcrypt. As described in Section 9 of [RFC8547], this property can be subverted if middleboxes strip ENO options from non-SYN segments after allowing them in SYN segments, or if the particular communication patterns of tcpcrypt offend the policies of middleboxes doing deep-packet inspection.",
      "ja": "安全性はtcpcryptをサポートするTCP実装は、彼らがtcpcryptせずに同じように、すべて同じ設定で確実に通信できることを意味します。 [RFC8547]のセクション9で説明したように、このプロパティは、SYNセグメントにそれらを可能にした後、非SYNセグメントから中間装置ストリップENOオプション場合に打倒することができ、又はtcpcryptの特定の通信パターンは、ディープパケットインスペクションを行う中間装置のポリシーを怒ら場合。"
    },
    {
      "indent": 3,
      "text": "Success, in addition to safety, means hosts that implement tcpcrypt actually enable encryption when connecting to one another. This property depends on the network's treatment of the TCP-ENO handshake and can be subverted if middleboxes merely strip unknown TCP options or terminate TCP connections and relay data back and forth unencrypted.",
      "ja": "成功は、安全性に加えて、相互に接続する際tcpcryptが実際に暗号化を有効に実装するホストを意味します。このプロパティは、TCP-ENOハンドシェークのネットワークの治療に依存し、ミドルボックスは、単に未知のTCPオプションを取り除くか、TCP接続を終了し、前後に暗号化されていないデータを中継する場合は堕落することができます。"
    },
    {
      "indent": 3,
      "text": "Ease of implementation will be a further challenge to deployment. Because tcpcrypt requires encryption operations on frames that may span TCP segments, kernel implementations are forced to buffer segments in different ways than are necessary for plain TCP. More implementation experience will show how much additional code complexity is required in various operating systems and what kind of performance effects can be expected.",
      "ja": "実装のしやすさは、展開に更なる挑戦となります。 tcpcryptはTCPセグメントにまたがることがフレーム上の暗号化操作を必要とするため、カーネルの実装は、プレーンなTCPのために必要であるよりも、さまざまな方法でセグメントをバッファリングすることを余儀なくされています。その他の実装経験は、様々なオペレーティング・システムで必要とされると、パフォーマンスへの影響の種類を期待することができますどのくらいの追加のコードの複雑さが表示されます。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[IEEE-1363] IEEE, \"IEEE Standard Specifications for Public-Key Cryptography\", IEEE Standard 1363-2000, DOI 10.1109/IEEESTD.2000.92292.",
      "ja": "[IEEE-1363] IEEE、 \"公開鍵暗号のためのIEEE標準仕様\"、IEEE規格1363から2000、DOI 10.1109 / IEEESTD.2000.92292。"
    },
    {
      "indent": 3,
      "text": "[NIST-DSS] National Institute of Standards and Technology (NIST), \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.",
      "ja": "[NIST-DSS]国立標準技術研究所（NIST）、 \"デジタル署名標準（DSS）\"、FIPS PUBの186から4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <https://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<https://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, DOI 10.17487/RFC2018, October 1996, <https://www.rfc-editor.org/info/rfc2018>.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、<HTTPS：//www.rfc- editor.org/info/rfc2018>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<HTTPS：//www.rfc-editor .ORG /情報/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <https://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116]マグリュー、D.、 \"認証暗号化のためのインタフェースとアルゴリズム\"、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<https://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <https://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H.、およびP. Eronen、 \"HMACベースの抽出物と、拡大鍵導出関数（HKDF）\"、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、<HTTPS：//www.rfc-editor .ORG /情報/ rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC7120] Cotton, M., \"Early IANA Allocation of Standards Track Code Points\", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, <https://www.rfc-editor.org/info/rfc7120>.",
      "ja": "[RFC7120]コットン、M.、 \"標準化過程のコードポイントの初期のIANA配分\"、BCP 100、RFC 7120、DOI 10.17487 / RFC7120、2014年1月、<https://www.rfc-editor.org/info/rfc7120> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A.、ハンブルク、M.、およびS.ターナー、 \"セキュリティのための楕円曲線\"、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<https://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8439] Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF Protocols\", RFC 8439, DOI 10.17487/RFC8439, June 2018, <https://www.rfc-editor.org/info/rfc8439>.",
      "ja": "[RFC8439]ニール、Y.及びA.ラングレー、 \"IETFプロトコルのためのChaCha20とPoly1305\"、RFC 8439、DOI 10.17487 / RFC8439、2018年6月、<https://www.rfc-editor.org/info/rfc8439>。"
    },
    {
      "indent": 3,
      "text": "[RFC8547] Bittau, A., Giffin, D., Handley, M., Mazieres, D., and E. Smith, \"TCP-ENO: Encryption Negotiation Option\", RFC 8547, DOI 10.17487/RFC8547, May 2019, <https://www.rfc-editor.org/info/rfc8547>.",
      "ja": "[RFC8547] Bittau、A.、Giffin、D.、ハンドレー、M.、Mazieres、D.、およびE.スミス、 \"TCP-ENO：暗号化交渉オプション\"、RFC 8547、DOI 10.17487 / RFC8547、2019年5月、< https://www.rfc-editor.org/info/rfc8547>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[NIST-fail] Bernstein, D. and T. Lange, \"Failures in NIST's ECC Standards\", January 2016, <https://cr.yp.to/newelliptic/nistecc-20160106.pdf>.",
      "ja": "[NIST-失敗]バーンスタイン、D.とT.ランゲ、 \"NISTのECC規格における失敗\"、2016年1月、<https://cr.yp.to/newelliptic/nistecc-20160106.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTPS：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC7696] Housley, R., \"Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms\", BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015, <https://www.rfc-editor.org/info/rfc7696>.",
      "ja": "[RFC7696] Housley氏、R.、 \"暗号アルゴリズムアジリティのガイドラインと強制的に実装アルゴリズムの選択\"、BCP 201、RFC 7696、DOI 10.17487 / RFC7696、2015年11月、<https://www.rfc-editor.org /情報/ rfc7696>。"
    },
    {
      "indent": 3,
      "text": "[tcpcrypt] Bittau, A., Hamburg, M., Handley, M., Mazieres, D., and D. Boneh, \"The case for ubiquitous transport-level encryption\", USENIX Security Symposium, August 2010.",
      "ja": "【tcpcrypt] Bittau、A.、ハンブルク、M.、ハンドレー、M.、Mazieres、D.、およびD. Boneh、 \"ユビキタストランスポートレベルの暗号化のためのケース\"、USENIXセキュリティシンポジウム、2010年8月。"
    },
    {
      "indent": 3,
      "text": "[TCPINC-API] Bittau, A., Boneh, D., Giffin, D., Handley, M., Mazieres, D., and E. Smith, \"Interface Extensions for TCP-ENO and tcpcrypt\", Work in Progress, draft-ietf-tcpinc-api-06, June 2018.",
      "ja": "[TCPINC-API] Bittau、A.、Boneh、D.、Giffin、D.、ハンドリー、M.、Mazieres、D.、およびE.スミス、 \"TCP-ENOとtcpcryptためのインタフェース拡張\" が進行中で働いていますが、ドラフト-IETF-tcpinc-API-06、2018年6月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We are grateful for contributions, help, discussions, and feedback from the TCPINC Working Group and from other IETF reviewers, including Marcelo Bagnulo, David Black, Bob Briscoe, Jana Iyengar, Stephen Kent, Tero Kivinen, Mirja Kuhlewind, Yoav Nir, Christoph Paasch, Eric Rescorla, Kyle Rose, and Dale Worley.",
      "ja": "私たちは、寄付に感謝してい、助け、議論、およびTCPINCワーキンググループからとマルセロBagnulo、デビッド・ブラック、ボブ・ブリスコー、ヤナアイアンガー、スティーブン・ケント、TERO Kivinen、Mirja Kuhlewind、ヨアフニール、クリストフPaaschを含む他のIETFのレビュー、からのフィードバック、エリックレスコラ、カイル・ローズ、そしてデールウォーリー。"
    },
    {
      "indent": 3,
      "text": "This work was funded by gifts from Intel (to Brad Karp) and from Google; by NSF award CNS-0716806 (A Clean-Slate Infrastructure for Information Flow Control); by DARPA CRASH under contract #N66001-10-2-4088; and by the Stanford Secure Internet of Things Project.",
      "ja": "この作品は、インテル（ブラッドカープへ）とGoogleからの贈り物によって賄われていました。 NSF賞CNS-0716806（情報フロー制御のためのクリーン・スレート・インフラストラクチャー）によります。 DARPA CRASHによる契約＃N66001-10-2-4088の下で、そして物事プロジェクトのスタンフォード安全なインターネットによって。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "Dan Boneh and Michael Hamburg were coauthors of the draft that became this document.",
      "ja": "ダン・ボネとマイケル・ハンブルクは、この文書になった草案の共著者でした。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Andrea Bittau Google 345 Spear Street San Francisco, CA 94105 United States of America",
      "ja": "アンドレアBittau Googleの345スピアストリートサンフランシスコ、CAアメリカの94105米国"
    },
    {
      "indent": 3,
      "text": "Email: bittau@google.com",
      "ja": "メール：bittau@google.com"
    },
    {
      "indent": 3,
      "text": "Daniel B. Giffin Stanford University 353 Serra Mall, Room 288 Stanford, CA 94305 United States of America",
      "ja": "ダニエルB. Giffinスタンフォード大学353セラモールオブアメリカ、ルーム288スタンフォード、CA 94305米国"
    },
    {
      "indent": 3,
      "text": "Email: daniel@beech-grove.net",
      "ja": "メール：daniel@beech-grove.net"
    },
    {
      "indent": 3,
      "text": "Mark Handley University College London Gower St. London WC1E 6BT United Kingdom",
      "ja": "マーク・ハンドリーロンドン大学ガウアーセントロンドンWC1E 6BTイギリス"
    },
    {
      "indent": 3,
      "text": "Email: M.Handley@cs.ucl.ac.uk",
      "ja": "メール：M.Handley@cs.ucl.ac.uk"
    },
    {
      "indent": 3,
      "text": "David Mazieres Stanford University 353 Serra Mall, Room 290 Stanford, CA 94305 United States of America",
      "ja": "デイビット・マジャーズスタンフォード大学353セラモールオブアメリカ、ルーム290スタンフォード、CA 94305米国"
    },
    {
      "indent": 3,
      "text": "Email: dm@uun.org",
      "ja": "メール：dm@uun.org"
    },
    {
      "indent": 3,
      "text": "Quinn Slack Sourcegraph 121 2nd St Ste 200 San Francisco, CA 94105 United States of America",
      "ja": "アメリカのクインがSourcegraph 121第二セントマリースラック200サンフランシスコ、CA 94105米国"
    },
    {
      "indent": 3,
      "text": "Email: sqs@sourcegraph.com",
      "ja": "メール：sqs@sourcegraph.com"
    },
    {
      "indent": 3,
      "text": "Eric W. Smith Kestrel Institute 3260 Hillview Avenue Palo Alto, CA 94304 United States of America",
      "ja": "エリック・W.スミスケストレル研究所3260ヒルビュー・アベニューカリフォルニア州パロアルトアメリカの94304米国"
    },
    {
      "indent": 3,
      "text": "Email: eric.smith@kestrel.edu",
      "ja": "メール：eric.smith@kestrel.edu"
    }
  ]
}