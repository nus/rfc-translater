{
  "title": {
    "text": "RFC 8132 - PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)",
    "ja": "RFC 8132 - 制約アプリケーションプロトコル（CoAP）のための方法をPATCHとFETCH"
  },
  "number": 8132,
  "created_at": "2019-10-23 18:07:08.527630+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   P. van der Stok\nRequest for Comments: 8132                                    Consultant\nCategory: Standards Track                                     C. Bormann\nISSN: 2070-1721                                  Universitaet Bremen TZI\n                                                               A. Sehgal\n                                                            NAVOMI, Inc.\n                                                              April 2017",
      "raw": true
    },
    {
      "indent": 0,
      "text": "PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)",
      "ja": "制約アプリケーションプロトコル（CoAP）のための方法をPATCHとFETCH"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The methods defined in RFC 7252 for the Constrained Application Protocol (CoAP) only allow access to a complete resource, not to parts of a resource. In case of resources with larger or complex data, or in situations where resource continuity is required, replacing or requesting the whole resource is undesirable. Several applications using CoAP need to access parts of the resources.",
      "ja": "制約アプリケーションプロトコル（CoAP）は、RFC 7252で定義された方法のみではないリソースの部分に、完全なリソースへのアクセスを可能にします。大きいまたは複雑なデータとリソースの場合に、またはリソースの継続が必要とされる状況で、置換又は要求に全リソースは望ましくありません。 CoAPを使用して、いくつかのアプリケーションがリソースの部分にアクセスする必要があります。"
    },
    {
      "indent": 3,
      "text": "This specification defines the new CoAP methods, FETCH, PATCH, and iPATCH, which are used to access and update parts of a resource.",
      "ja": "この仕様は新しいCoAPメソッドを定義し、FETCH、PATCH、およびリソースの部分にアクセスし、更新するために使用されるiPATCH、。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8132.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8132で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  FETCH . . . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.2.  PATCH and iPATCH  . . . . . . . . . . . . . . . . . . . .   4\n  1.3.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n  1.4.  Terminology and Acronyms  . . . . . . . . . . . . . . . .   5\n2.  FETCH Method  . . . . . . . . . . . . . . . . . . . . . . . .   5\n  2.1.  Response Codes  . . . . . . . . . . . . . . . . . . . . .   6\n  2.2.  Error Handling  . . . . . . . . . . . . . . . . . . . . .   6\n  2.3.  Option Numbers  . . . . . . . . . . . . . . . . . . . . .   7\n    2.3.1.  The Content-Format Option . . . . . . . . . . . . . .   7\n    2.3.2.  The ETag Option . . . . . . . . . . . . . . . . . . .   8\n  2.4.  Working with Observe  . . . . . . . . . . . . . . . . . .   8\n  2.5.  Working with Block  . . . . . . . . . . . . . . . . . . .   8\n  2.6.  Building FETCH Requests . . . . . . . . . . . . . . . . .   8\n  2.7.  A Simple Example for FETCH  . . . . . . . . . . . . . . .   8\n3.  PATCH and iPATCH Methods  . . . . . . . . . . . . . . . . . .   9\n  3.1.  Simple Examples for PATCH and iPATCH  . . . . . . . . . .  12\n  3.2.  Response Codes  . . . . . . . . . . . . . . . . . . . . .  14\n  3.3.  Option Numbers  . . . . . . . . . . . . . . . . . . . . .  14\n  3.4.  Error Handling  . . . . . . . . . . . . . . . . . . . . .  15\n4.  The New Set of CoAP Methods . . . . . . . . . . . . . . . . .  16\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  17\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  18\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  19\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  19\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  19\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Similar to HTTP, the GET method defined in [RFC7252] for the Constrained Application Protocol (CoAP) only allows the specification of a URI and request parameters in CoAP options, not the transfer of a request payload detailing the request. This leads some applications to use POST where a cacheable, idempotent, safe request is actually desired.",
      "ja": "HTTPと同様、制約アプリケーションプロトコル（CoAP）のために[RFC7252]で定義されたGETメソッドのみCoAPオプションでURIとリクエストパラメータの仕様ではなく、要求の詳細を要求ペイロードの転送を可能にします。これはキャッシュ可能、冪等は、安全な要求が実際に要求されるPOSTを使用するためにいくつかのアプリケーションをリードしています。"
    },
    {
      "indent": 3,
      "text": "Again, similar to the original specification of HTTP, the PUT method defined in [RFC7252] only allows a complete resource to be replaced. This also leads applications to use POST where a cacheable, possibly idempotent request is actually desired.",
      "ja": "再び、HTTPの元の仕様と同様に、[RFC7252]で定義されたPUT方法が唯一の完全なリソースを交換することを可能にします。これはまた、キャッシュ可能な、多分べき等の要求が実際に要求されるPOSTを使用するようにアプリケーションをリードしています。"
    },
    {
      "indent": 3,
      "text": "The present specification adds new CoAP methods: FETCH, to perform the equivalent of a GET with a request body; and the twin methods, PATCH and iPATCH, to modify parts of a CoAP resource.",
      "ja": "本明細書は、新たなCoAPメソッドを追加します：リクエストボディを持つGETと同等のものを実行するために、FETCH。そして双子の方法、PATCHとiPATCHは、CoAPリソースの一部を変更します。"
    },
    {
      "indent": 0,
      "text": "1.1. FETCH",
      "section_title": true,
      "ja": "1.1. フェッチ"
    },
    {
      "indent": 3,
      "text": "The CoAP GET method [RFC7252] is used to obtain the representation of a resource, where the resource is specified by a URI and additional request parameters can also shape the representation. This has been modeled after the HTTP GET operation and the REST model in general.",
      "ja": "CoAP GETメソッド[RFC7252]も表現を形作ることができるリソースがURIと追加のリクエストパラメータで指定されたリソースの表現を取得するために使用されます。これは、HTTPのGET操作や一般的なRESTモデルをモデルにしてきました。"
    },
    {
      "indent": 3,
      "text": "In HTTP, a resource is often used to search for information, and existing systems varyingly use the HTTP GET and POST methods to perform a search. Often, a POST method is used solely so that a larger set of parameters to the search can be supplied in the request body than can comfortably be transferred in the URI with a GET request. [HTTP-SEARCH] proposes a SEARCH method that is similar to GET in most properties but enables sending a request body, as is done with POST. The FETCH method defined in the present specification is inspired by [HTTP-SEARCH], which updates the definition and semantics of the HTTP SEARCH request method previously defined by [RFC5323]. However, there is no intention to limit FETCH to search-type operations, and the resulting properties may not be the same as those of HTTP SEARCH.",
      "ja": "HTTPでは、リソースは、多くの場合、情報を検索するために使用され、既存のシステムは時々刻々検索を実行するためにHTTP GETを使用して、POSTメソッド。検索に必要なパラメータの大きなセットが快適にGET要求にURIに転送することができるよりも、要求本体に供給することができるように、多くの場合、POSTメソッドは、単独で用いられています。 [HTTP-SEARCH]ほとんどのプロパティに取得するために類似しているが、POSTを用いて行われているように、リクエストボディを送信可能にする検索方法を提案します。本明細書で定義されたFETCH方法は、以前に[RFC5323]で定義されたHTTP検索要求方法の定義と意味論を更新[HTTP-SEARCH]、触発されます。しかし、操作型検索するFETCH限定を意図するものではない、そして得られた特性は、HTTP検索のと同じではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "A major problem with GET is that the information that controls the request needs to be bundled up in some unspecified way into the URI. Using the request body for this information has a number of advantages:",
      "ja": "GETとの大きな問題は、要求を制御する情報は、URIの中にいくつかの不特定の方法で束ねする必要があるということです。この情報は、リクエストボディを使用することは多くの利点があります。"
    },
    {
      "indent": 3,
      "text": "o The client can specify a media type (and a content coding) that enables the server to unambiguously interpret the request parameters in the context of that media type. Also, the request body is not limited by the character set limitations of URIs, which enables a more natural (and more efficient) representation of certain domain-specific parameters.",
      "ja": "Oクライアントは明確にそのメディアタイプのコンテキストでリクエストパラメータを解釈するためにサーバーを可能メディアタイプ（およびコーディングコンテンツ）を指定することができます。また、リクエストボディは、特定のドメイン固有のパラメータのより自然な（そしてより効率的な）表現を可能にする、URIの文字セットの制限により限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "o The request parameters are not limited by the maximum size of the URI. In HTTP, that is a problem, as the practical limit for this size varies. In CoAP, another problem is that the block-wise transfer is not available for transferring large URI options in multiple rounds.",
      "ja": "O要求パラメータは、URIの最大サイズによって限定されるものではありません。このサイズの実際的な限界が変化するようにHTTPでは、それは、問題です。 CoAPでは、別の問題がブロック単位の転送は、複数のラウンドで大規模なURIオプションを転送するために利用できないということです。"
    },
    {
      "indent": 3,
      "text": "As an alternative to using GET, many implementations make use of the POST method to perform extended requests (even if they are semantically idempotent, safe, and even cacheable) to be able to pass along the input parameters within the request payload as opposed to using the request URI.",
      "ja": "GETを使用する代わりに、多くの実装は、使用とは対照的に、要求ペイロード内の入力パラメータに沿って通過することができるように拡張されたリクエストを（それらが意味的に、べき等安全、さらにはキャッシュ可能であっても）を実行するためにPOSTメソッドを利用しますリクエストURI。"
    },
    {
      "indent": 3,
      "text": "The FETCH method provides a solution that spans the gap between the use of GET and POST. As with POST, the input to the FETCH operation is passed along within the payload of the request rather than as part of the request URI. Unlike POST, however, the semantics of the FETCH method are more specifically defined.",
      "ja": "FETCH方法は、GETおよびPOSTの使用との間のギャップにまたがるソリューションを提供します。 POSTと同様に、FETCH操作への入力は、要求のペイロード内ではなく、要求URIの一部として渡され。 POSTとは異なり、しかし、FETCHメソッドのセマンティクスは、より具体的に定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. PATCH and iPATCH",
      "section_title": true,
      "ja": "1.2.  PATCHとiPATCH"
    },
    {
      "indent": 3,
      "text": "PATCH is also specified for HTTP in [RFC5789]. Most of the motivation for PATCH described in [RFC5789] also applies here. iPATCH is the idempotent version of PATCH.",
      "ja": "パッチはまた、[RFC5789]でHTTP用に指定されています。 [RFC5789]で説明PATCHの動機のほとんどは、ここに適用されます。 iPATCHはPATCHの冪等バージョンです。"
    },
    {
      "indent": 3,
      "text": "The PUT method exists to overwrite a resource with completely new contents and cannot be used to perform partial changes. When using PUT for partial changes, proxies and caches, and even clients and servers, may get confused as to the result of the operation. PATCH was not adopted in an early design stage of CoAP; however, it has become necessary with the arrival of applications that require partial updates to resources (e.g., [COAP-MGMNT]). Using PATCH avoids transferring all data associated with a resource in case of modifications, thereby not burdening the constrained communication medium.",
      "ja": "PUTメソッドは、完全に新しいコンテンツとリソースを上書きするために存在し、部分的な変更を行うために使用することができません。一部変更、プロキシやキャッシュ、さらにはクライアントとサーバのためのPUTを使用する場合は、操作の結果に関しては混乱してしまうことがあります。 PATCHはCoAPの初期の設計段階で採用されませんでした。しかし、リソースへの部分的な更新を必要とするアプリケーションの到着と必要になってきている（例えば、[COAP-MGMNT]）。パッチを使用すると、それによって拘束通信媒体に負担をかけない、修飾の場合にリソースに関連するすべてのデータ転送が回避されます。"
    },
    {
      "indent": 3,
      "text": "This document relies on knowledge of the PATCH specification for HTTP [RFC5789]. This document provides extracts from [RFC5789] to make independent reading possible.",
      "ja": "この文書では、HTTP [RFC5789]のためのPATCH仕様の知識に依存しています。この文書では、独立した読み取りを可能にするために、[RFC5789]からの抽出物を提供します。"
    },
    {
      "indent": 0,
      "text": "1.3. Requirements Language",
      "section_title": true,
      "ja": "1.3. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "1.4. Terminology and Acronyms",
      "section_title": true,
      "ja": "1.4. 用語と略語"
    },
    {
      "indent": 3,
      "text": "This document uses terminology defined in [RFC5789] and [RFC7252].",
      "ja": "この文書では、[RFC5789]と[RFC7252]で定義された用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "Specifically, it uses the terms \"safe\" and \"idempotent\" as defined in Section 5.1 of [RFC7252]. (Further discussion of safe and idempotent methods can now be found in Sections 4.2.1 and 4.2.2 of [RFC7231], respectively; the implications of idempotence of methods on server implementations are also discussed in Section 4.5 of [RFC7252].)",
      "ja": "[RFC7252]のセクション5.1で定義されるように具体的には、「安全」と「冪等」という用語を使用します。 （安全かつ冪等の方法のさらなる議論は、現在、それぞれ、[RFC7231]のセクション4.2.1および4.2.2に見出すことができ、サーバ実装のメソッドの冪等の影響もまた、[RFC7252]のセクション4.5に記載されています。）"
    },
    {
      "indent": 0,
      "text": "2. FETCH Method",
      "section_title": true,
      "ja": "2.メソッドをFETCH"
    },
    {
      "indent": 3,
      "text": "The CoAP FETCH method is used to obtain a representation of a resource, specified by a number of request parameters. Unlike the CoAP GET method, which requests that a server return a representation of the resource identified by the effective request URI (as defined by [RFC7252]), the FETCH method is used by a client to ask the server to produce a representation as described by the request parameters (including the request options and the payload) based on the resource specified by the effective request URI. The payload returned in response to a FETCH cannot be assumed to be a complete representation of the resource identified by the effective request URI, i.e., it cannot be used by a cache as a payload to be returned by a GET request.",
      "ja": "CoAP FETCHメソッドは、要求パラメータの数で指定されたリソースの表現を取得するために使用されます。 CoAPとは異なり、サーバーが有効なリクエストURI（[RFC7252]で定義される）によって識別されたリソースの表現を返すことを要求する方法を、GET、FETCH方法が記載されているような表現を生成するためにサーバに要求するクライアントによって使用されリクエストパラメータで有効な要求URIによって指定されたリソースに基づいて、（要求オプションとペイロードを含みます）。 FETCHに応答して返されたペイロード、すなわち、それがGET要求によって返されるペイロードとしてキャッシュによって使用することができない、有効なリクエストURIによって識別されたリソースの完全な表現であると仮定することはできません。"
    },
    {
      "indent": 3,
      "text": "Together with the request options, the body of the request (which may be constructed from multiple payloads using the block protocol [RFC7959]) defines the request parameters. With the FETCH method, implementations may submit a request body of any media type that is defined with the semantics of selecting information from a resource in such a FETCH request; it is outside the scope of this document how information about media types admissible for the specific resource is obtained by the client (although we can hint that form relations [CORE-APP] might be a preferred way). It is RECOMMENDED that any discovery method that allows a client to find out that the server supports FETCH also provides information regarding what FETCH payload media types are applicable.",
      "ja": "一緒に要求オプションで、要求の本体（ブロックプロトコルを使用して複数のペイロードから構成されてもよい[RFC7959]）が要求パラメータを定義します。 FETCH方法で、インプリメンテーションは、フェッチ要求内のリソースから情報を選択することの意味で定義される任意のメディアタイプのリクエストボディを提出することができます。それは（私たちは、フォームの関係[CORE-APP】好ましい方法かもしれないことを暗示することができますが）特定のリソースのための許容メディアタイプについての情報がクライアントによって得られるか、この文書の範囲外です。クライアントがサーバにもFETCHサポートしていることを知ることを可能にする任意の検出方法が、ペイロードのメディアタイプが適用されるFETCH何に関する情報を提供することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "FETCH requests are both safe and idempotent with regards to the resource identified by the request URI. That is, the performance of a FETCH is not intended to alter the state of the targeted resource. (However, while processing a FETCH request, a server can be expected to allocate computing and memory resources or even create additional server resources through which the response to the search can be retrieved.)",
      "ja": "FETCH要求は、要求URIで識別されるリソースにに関して安全でべき等の両方です。それはFETCHの性能が目標とリソースの状態を変更するものではありません、です。 （フェッチ要求を処理している間しかし、サーバは、コンピューティングリソースとメモリリソースを割り当てること、あるいは検索に対する応答を取得することができ、それを通して追加のサーバーリソースを作成することが期待できます。）"
    },
    {
      "indent": 3,
      "text": "A successful response to a FETCH request is expected to provide some indication as to the final disposition of the requested operation. If a successful response includes a body payload, the payload is expected to describe the results of the FETCH operation.",
      "ja": "フェッチ要求に対する成功応答は、要求された操作の最終的な配置に関していくつかの指標を提供することが期待されます。正常な応答は、本体ペイロードが含まれている場合、ペイロードはFETCH操作の結果を説明することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Depending on the response code as defined by [RFC7252], the response to a FETCH request is cacheable; the request body is part of the cache key. Specifically, 2.05 (Content) response codes (the responses for which are cacheable) are a typical way to respond to a FETCH request. (Note that this aspect differs markedly from [HTTP-SEARCH] and also that caches that cannot use the request payload as part of the cache key will not be able to cache responses to FETCH requests at all.) The Max-Age option in the response has equivalent semantics to its use in a GET.",
      "ja": "[RFC7252]で定義されるような応答コードに応じて、フェッチ要求に対する応答がキャッシュ可能です。リクエストボディは、キャッシュキーの一部です。具体的には、2.05（コンテンツ）応答コード（キャッシュ可能であるため応答）がフェッチ要求に対応する典型的な方法です。 （この態様は著しく異なることに注意してください[HTTP-SEARCH]ですべての要求を取得するためにキャッシュ応答することができませんキャッシュキーの一部として要求ペイロードを使用することはできませんし、また、そのキャッシュ。）における最大エイジオプション応答がGETでの使用と同等の意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "The semantics of the FETCH method change to a \"conditional FETCH\" if the request message includes an If-Match or If-None-Match option [RFC7252]. A conditional FETCH requests that the query be performed only under the circumstances described by the conditional option(s). It is important to note, however, that such conditions are evaluated against the state of the target resource itself as opposed to the results of the FETCH operation.",
      "ja": "要求メッセージは、もしマッチを含む場合、または、なしマッチオプション[RFC7252]場合にFETCH方法変更のセマンティクス「条件フェッチ」。条件付きクエリのみ、条件オプション（複数可）に記載の環境下で行うことが要求をFETCH。 FETCH操作の結果とは対照的に、そのような条件はターゲット・リソース自体の状態に対して評価されていること、しかし、注意することが重要です。"
    },
    {
      "indent": 0,
      "text": "2.1. Response Codes",
      "section_title": true,
      "ja": "2.1. 応答コード"
    },
    {
      "indent": 3,
      "text": "FETCH for CoAP adopts the response codes as specified in Sections 5.9 and 12.1.2 of [RFC7252] as well as the additional response codes mentioned in Section 2.2.",
      "ja": "CoAPためFETCHセクション5.9と[RFC7252]の12.1.2ならびに2.2節で述べた追加のレスポンスコードで指定された応答コードを採用しています。"
    },
    {
      "indent": 0,
      "text": "2.2. Error Handling",
      "section_title": true,
      "ja": "2.2. エラー処理"
    },
    {
      "indent": 3,
      "text": "A FETCH request may fail under certain known conditions. Beyond the conditions already defined in [RFC7252] for GET, noteworthy ones are:",
      "ja": "フェッチ要求は、特定の既知の条件下で失敗する可能性があります。すでにGETのために[RFC7252]で定義された条件を超えて、注目すべきものは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Malformed FETCH payload: If a server determines that the payload provided with a FETCH request is not properly formatted, it can return a 4.00 (Bad Request) CoAP error. The definition of a malformed payload depends upon the CoAP Content-Format specified with the request.",
      "ja": "不正な形式のペイロードをFETCH：サーバはフェッチ要求を提供ペイロードが適切にフォーマットされていないこと、それは4.00（不正な要求）CoAPエラーを返すことができると判断した場合。不正なペイロードの定義は、リクエストで指定されたCoAPコンテンツフォーマットに依存します。"
    },
    {
      "indent": 3,
      "text": "Unsupported FETCH payload: In case a client sends a payload that is inappropriate for the resource identified by the Request-URI, the server can return a 4.15 (Unsupported Content-Format) CoAP error. The server can determine if the payload is supported by checking the CoAP Content-Format specified with the request.",
      "ja": "サポートされていないペイロードをFETCH：クライアントは、Request-URIによって識別されるリソースには不適切であるペイロードを送る場合、サーバは、4.15（サポートされていないコンテンツフォーマット）CoAPエラーを返すことができます。ペイロードは、要求で指定されたCoAPコンテンツフォーマットをチェックすることによって、サポートされている場合、サーバーが決定することができます。"
    },
    {
      "indent": 3,
      "text": "Unprocessable request: This situation occurs when the payload of a FETCH request is determined to be valid (i.e., well-formed and supported) but the server is unable to or is incapable of processing the request. The server can return a 4.22 (Unprocessable Entity) CoAP error. In situations when the server has insufficient computing resources to complete the request successfully, it can return a 4.13 (Request Entity Too Large) CoAP error (see also below). If there are more specific errors that provide additional insight into the problem, then those should be used.",
      "ja": "処理不可能なリクエスト：リクエストをFETCHのペイロードが有効であると判定された（すなわち、十分に形成され、サポートされている）が、サーバーができないか、要求を処理できないときにこの状況が発生します。サーバーは、4.22（処理不能エンティティ）CoAPエラーを返すことができます。サーバーが正常に要求を完了するために十分なコンピューティングリソースを持っている状況では、4.13（リクエストエンティティが大きすぎます）CoAPエラー（下記参照）を返すことができます。問題への追加的な洞察を提供し、より具体的なエラーがある場合は、それらを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Request too large: If the payload of the FETCH request is larger than a CoAP server can process, then it can return the 4.13 (Request Entity Too Large) CoAP error.",
      "ja": "要求が大きすぎる：FETCH要求のペイロードがCoAPサーバが処理できるよりも大きい場合、それは4.13（リクエストエンティティが大きすぎます）CoAPエラーを返すことができます。"
    },
    {
      "indent": 3,
      "text": "It is possible that other error situations not mentioned here are encountered by a CoAP server while processing the FETCH request. In these situations, other appropriate CoAP response codes can also be returned.",
      "ja": "FETCH要求を処理しながら、ここに記載されていない他のエラー状態がCoAPサーバが遭遇されている可能性があります。このような状況では、他の適切なCoAP応答コードも返すことができます。"
    },
    {
      "indent": 0,
      "text": "2.3. Option Numbers",
      "section_title": true,
      "ja": "2.3. オプション番号"
    },
    {
      "indent": 3,
      "text": "FETCH for CoAP adopts the option numbers as specified in Sections 5.10 and 12.2 of [RFC7252].",
      "ja": "CoAPためFETCHセクション5.10及び[RFC7252]の12.2で指定されたオプション番号を採用しています。"
    },
    {
      "indent": 3,
      "text": "Generally, options defined for GET act in an analogous way for FETCH. Two specific cases are called out in the rest of this section.",
      "ja": "一般的に、FETCHのための類似の方法でGET行為のために定義されたオプション。 2つの特定の例は、このセクションの残りの部分で呼び出されています。"
    },
    {
      "indent": 0,
      "text": "2.3.1. The Content-Format Option",
      "section_title": true,
      "ja": "2.3.1. コンテンツフォーマットオプション"
    },
    {
      "indent": 3,
      "text": "A FETCH request MUST include a Content-Format option (see Section 5.10.3 of [RFC7252]) to specify the media type and content coding of the request body. (Typically, the media type will have been specifically designed to specify details for a selection or a search on a resource.)",
      "ja": "FETCH要求には、Content-Formatオプションを指定するには、メディアタイプとリクエストボディの内容符号化（[RFC7252]のセクション5.10.3を参照）を含まなければなりません。 （典型的には、メディア種別は、具体的に選択またはリソースの検索のための詳細を指定するように設計されています。）"
    },
    {
      "indent": 0,
      "text": "2.3.2. The ETag Option",
      "section_title": true,
      "ja": "2.3.2.  ETagのオプション"
    },
    {
      "indent": 3,
      "text": "The ETag option on a FETCH result has the same semantics as defined in Section 5.10.6 of [RFC7252]. In particular, its use as a response option describes the \"tagged representation\", which for FETCH is the same as the \"selected representation\". The FETCH payload is input to that selection process and therefore needs to be part of the cache key. Similarly, the use of ETag as a request option can elicit a 2.03 (Valid) response if the representation associated with the ETag would still be selected by the FETCH request (including its payload).",
      "ja": "[RFC7252]のセクション5.10.6で定義されているようFETCH結果にETagのオプションは、同じ意味を持っています。具体的には、応答オプションとしての使用フェッチするためには、「選択された表現」と同じで「タグ付けされた表現」を記載しています。 FETCHペイロードは、選択プロセスに入力され、したがって、キャッシュキーの一部である必要があります。同様に、ETagの関連付けられた表現がまだ（そのペイロードを含む）フェッチ要求によって選択される場合2.03（有効）応答を誘発することができ、要求オプションとしてのETagの使用。"
    },
    {
      "indent": 0,
      "text": "2.4. Working with Observe",
      "section_title": true,
      "ja": "2.4. 観察での作業"
    },
    {
      "indent": 3,
      "text": "The Observe option [RFC7641] can be used with a FETCH request as it can be used with a GET request.",
      "ja": "それはGETリクエストで使用できるよう守っオプション[RFC7641]はFETCH要求で使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.5. Working with Block",
      "section_title": true,
      "ja": "2.5. ブロックを使用した作業"
    },
    {
      "indent": 3,
      "text": "The Block1 option [RFC7959] can be used with a FETCH request as it would be used with a POST request; the Block2 option can then be used as it would with GET or POST.",
      "ja": "ブロック1オプション[RFC7959]は、それがPOSTリクエストで使用されるようフェッチ要求とともに使用することができます。ブロック2のオプションは、それがGETまたはPOSTと同じように使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.6. Building FETCH Requests",
      "section_title": true,
      "ja": "2.6. 建物はフェッチ要求"
    },
    {
      "indent": 3,
      "text": "One property of FETCH that may be non-obvious is that a FETCH request cannot be generated from a link alone; the client also needs a way to generate the request payload. Again, form relations [CORE-APP] may be able to fill parts of this gap.",
      "ja": "それは非自明かもしれFETCHの1つの特性はFETCH要求が単独のリンクから生成することができないということです。また、クライアントは、要求ペイロードを生成するための方法が必要です。再度、フォームの関係[CORE-APPは、この隙間の部分を埋めることができてもよいです。"
    },
    {
      "indent": 0,
      "text": "2.7. A Simple Example for FETCH",
      "section_title": true,
      "ja": "2.7.  FETCHのための簡単な例"
    },
    {
      "indent": 3,
      "text": "The FETCH method needs a media type for its payload (as expressed by the Content-Format request option) that specifies the search query in similar detail as is shown for the PATCH payload in the PATCH example in Section 3.1. ([HTTP-SEARCH] invents a \"text/query\" format based on some hypothetical SQL dialect for its examples.)",
      "ja": "FETCH方法は、3.1節でPATCH例におけるパッチペイロードのために示されているのと同様の詳細な検索クエリを指定する（コンテンツフォーマット要求オプションで表されるように）、そのペイロードのメディアタイプを必要とします。 （[HTTP-SEARCH]その例については、いくつかの仮定のSQLダイアレクトに基づいて、「テキスト/クエリ」形式を発明）。"
    },
    {
      "indent": 3,
      "text": "The example below illustrates retrieval of a subset of a JSON [RFC7159] object (the same object as used in Section 3.1). Using a hypothetical media type \"application/example-map-keys+json\" (with a Content-Format ID of NNN, which is not defined as this is just an example), the client specifies the items in the object that it wants: it supplies a JSON array that gives the map keys for these items. A resource located at <coap://www.example.com/object> can be represented by a JSON document that we will consider as the target of the FETCH. The client wants to learn the contents of the single map key \"foo\" within this target:",
      "ja": "以下の例では、JSON [RFC7159]オブジェクト（セクション3.1で使用したものと同じオブジェクト）のサブセットの検索を示します。 （これは単なる例であると定義されていないNNNのコンテンツフォーマットのIDと）「アプリケーション/例-マップキー+ jsonの」架空のメディアタイプを使用して、クライアントは、それが望んでいるオブジェクト内の項目を指定します。それは、これらの項目のマップキーを与えるJSON配列を提供します。あるリソースは、<coap：//www.example.com/object>私たちはFETCHの対象として検討するJSONドキュメントで表すことができます。クライアントは、このターゲット内の単一のマップキー「foo」という内容を学びたいです："
    },
    {
      "indent": 3,
      "text": "{\n  \"x-coord\": 256,\n  \"y-coord\": 45,\n  \"foo\": [\"bar\",\"baz\"]\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "FETCH Example: JSON Document Returned by GET",
      "ja": "例をFETCH：JSONドキュメントはGETで返されます"
    },
    {
      "indent": 3,
      "text": "The example FETCH request specifies a single top-level member desired by giving its map key as the sole element of the \"example-map-keys\" payload:",
      "ja": "要求をFETCH例は、「例マップ鍵」ペイロードの唯一の要素としてのマップキーを与えることによって、所望の単一のトップレベルのメンバを指定します。"
    },
    {
      "indent": 3,
      "text": "FETCH CoAP://www.example.com/object Content-Format: NNN (application/example-map-keys+json) Accept: application/json [ \"foo\" ]",
      "ja": "CoAPをFETCH：//www.example.com/objectコンテンツフォーマット：NNN（アプリケーション/たとえば、マップのキー+ JSON）が受け入れ：アプリケーション/ JSON [ \"foo\" を]"
    },
    {
      "indent": 26,
      "text": "FETCH Example: Request",
      "ja": "例をFETCH：リクエスト"
    },
    {
      "indent": 3,
      "text": "The server returns a subset document with just the selected member:",
      "ja": "サーバは単に選択されたメンバーでサブセットの文書を返します。"
    },
    {
      "indent": 3,
      "text": "2.05 Content\nContent-Format: 50 (application/json)\n{\n  \"foo\": [\"bar\",\"baz\"]\n}",
      "raw": true
    },
    {
      "indent": 13,
      "text": "FETCH Example: Response with Subset JSON Document",
      "ja": "例をFETCH：サブセットJSONドキュメントと応答"
    },
    {
      "indent": 3,
      "text": "By the logic of this example, the requester could have entered more than one map key into the request payload array and would have received a more complete subset of the top-level JSON object that is representing the resource.",
      "ja": "この例のロジックによって、要求者は、要求ペイロード・アレイに複数のマップキーを入力した可能性があり、リソースを表しているトップレベルのJSONオブジェクトのより完全なサブセットを受け取ったであろう。"
    },
    {
      "indent": 0,
      "text": "3. PATCH and iPATCH Methods",
      "section_title": true,
      "ja": "3. PATCHとiPATCH方法"
    },
    {
      "indent": 3,
      "text": "The PATCH and iPATCH methods request that a set of changes described in the request payload be applied to the target resource of the request. The set of changes is represented in a format identified by a media type. If the Request-URI does not point to an existing resource, the server MAY create a new resource with that URI, depending on the PATCH document type (whether it can logically modify a null resource) and permissions, as well as other conditions such as the degree of control the server gives clients in creating new entries in its URI space (see also Section 3.4). Creation of a new resource would result in a 2.01 (Created) response code dependent on the PATCH document type.",
      "ja": "PATCHとiPATCH方法が要求ペイロードに記載の変更セットは、要求のターゲットリソースに適用されることを要求します。変更のセットは、メディアタイプによって識別形式で表現されます。リクエスト-URIが既存のリソースを指していない場合、サーバは（それが論理的にヌルリソースを変更できるかどうか）PATCHドキュメントの種類に応じて、そのURIを持つ新しいリソースを作成し、MAY権限、ならびに他の条件制御の程度は、サーバがそのURI空間で新しいエントリを作成するには、クライアントを提供します（セクション3.4を参照してください）。新しいリソースの作成は、PATCHドキュメントタイプに依存2.01（作成者）応答コードをもたらすであろう。"
    },
    {
      "indent": 3,
      "text": "Restrictions to a PATCH or iPATCH request can be made by including the If-Match or If-None-Match options in the request (see Sections 5.10.8.1 and 5.10.8.2 of [RFC7252]). If the resource could not be created or modified, then an appropriate error response code SHOULD be sent.",
      "ja": "パッチまたはiPATCH要求に対する制限は（セクション5.10.8.1と[RFC7252]の5.10.8.2を参照）要求であればマッチ場合、または、なしマッチオプションなどによって作製することができます。リソースを作成または変更することができなかった場合には、適切なエラー応答コードが送信されるべきです。"
    },
    {
      "indent": 3,
      "text": "The difference between the PUT and PATCH requests is documented in [RFC5789]. When a request is intended to effect a partial update of a given resource, clients cannot use PUT while supplying just the update, but they might be able to use PATCH or iPATCH.",
      "ja": "PUTとPATCHリクエストの違いは、[RFC5789]に記載されています。要求が与えられたリソースの部分更新を行うように意図されている場合、単に更新を供給しながら、クライアントは、PUTを使用することはできませんが、彼らはPATCHまたはiPATCHを使用することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The PATCH method is \"not safe\" and \"not idempotent\", as is the HTTP PATCH method specified in [RFC5789].",
      "ja": "[RFC5789]で指定されたHTTPパッチ方法は、パッチの方法は、「冪等ではない」「安全でない」となります。"
    },
    {
      "indent": 3,
      "text": "The iPATCH method is not safe but idempotent, as with the CoAP PUT method specified in Section 5.8.3 of [RFC7252].",
      "ja": "iPATCH方法は、[RFC7252]のセクション5.8.3で指定さCoAP PUTメソッドと同様に、安全でなく冪等ではありません。"
    },
    {
      "indent": 3,
      "text": "A client can mark a request as idempotent by using the iPATCH method instead of the PATCH method. This is the only difference between the two. The indication of idempotence may enable the server to keep less state about the interaction; some constrained servers may only implement the iPATCH variant for this reason.",
      "ja": "クライアントはiPATCHメソッドの代わりに、PATCHメソッドを使用して、冪等として要求をマークすることができます。これは、両者の唯一の違いです。冪等の表示は、相互作用について以下の状態を維持するために、サーバーを可能にしてもよいです。いくつかの制約のあるサーバーにのみ、この理由のためにiPATCHバリアントを実装することができます。"
    },
    {
      "indent": 3,
      "text": "PATCH and iPATCH are both atomic. The server MUST apply the entire set of changes atomically and never provide a partially modified representation to a concurrently executed GET request. Given the constrained nature of the servers, most servers will only execute CoAP requests consecutively, thus preventing a concurrent partial overlapping of request modifications. In other words, modifications MUST NOT be applied to the server state when an error occurs or when only a partial execution is possible on the resources present in the server.",
      "ja": "PATCHとiPATCHは両方アトミックです。サーバが同時に実行GETリクエストに一部変更表現を提供アトミック、決して変更のセット全体を適用しなければなりません。サーバの制約性質を考えると、ほとんどのサーバーのみので、要求変更の同時部分的重複を防止、連続CoAP要求を実行します。エラーが発生したとき換言すれば、変更は、サーバ状態に適用してはいけません、または部分的にしか実行がサーバに存在するリソースに可能である場合。"
    },
    {
      "indent": 3,
      "text": "The atomicity applies to a single server. When a PATCH or iPATCH request is multicast to a set of servers, each server can either execute all required modifications or not. It is not required that all servers execute all modifications or none. An Atomic Commit protocol that provides multiple server atomicity is out of scope.",
      "ja": "アトミックは、単一のサーバーに適用されます。 PATCHまたはiPATCH要求がサーバーのセットにマルチキャストされる場合は、各サーバは、すべての必要な変更を実行したりすることはできませんどちらか。すべてのサーバーがすべての修正またはnoneを実行することを必要とされていません。複数のサーバーの原子性を提供アトミックコミットプロトコルは範囲外です。"
    },
    {
      "indent": 3,
      "text": "A PATCH or iPATCH response can invalidate a cache in a similar manner to the PUT response. For the successful (2.xx) response codes, PATCH or iPATCH have the following caching behavior:",
      "ja": "PATCHまたはiPATCH応答がPUT応答と同様の方法でキャッシュを無効にすることができます。成功した（2.xxの）レスポンスコードについては、PATCHまたはiPATCHは以下のキャッシュ動作を持っています："
    },
    {
      "indent": 3,
      "text": "o A 2.01 (Created) response invalidates any cache entry for the resource indicated by the Location-* options; the payload is a representation of the action result.",
      "ja": "O 2.01（作成）応答は、場所に*オプションによって示されるリソースのための任意のキャッシュ・エントリを無効化します。ペイロードは、アクションの結果を表したものです。"
    },
    {
      "indent": 3,
      "text": "o A 2.04 (Changed) response invalidates any cache entry for the target resource; the payload is a representation of the action result.",
      "ja": "O 2.04（変更）応答は、ターゲットリソースのための任意のキャッシュ・エントリを無効化します。ペイロードは、アクションの結果を表したものです。"
    },
    {
      "indent": 3,
      "text": "There is no guarantee that a resource can be modified with PATCH or iPATCH. Servers MUST ensure that a received PATCH body is appropriate for the type of resource identified by the target resource of the request.",
      "ja": "リソースがPATCHまたはiPATCHで変更することができるという保証はありません。サーバは、受信したPATCH本体が要求の対象リソースによって識別されたリソースのタイプに適していることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that any discovery method that allows a client to find out that the server supports one of PATCH and iPATCH also provide information regarding what PATCH payload media types are applicable and which of the two methods are implemented by the server for each of these media types.",
      "ja": "クライアントがサーバがPATCHのいずれかをサポートしていることを見つけることができますし、iPATCHも何PATCHペイロードメディアタイプに関する情報を提供する任意の検出方法が適用可能であり、二つの方法のどちらがこれらのメディアの各サーバーで実装することをお勧めしますタイプ。"
    },
    {
      "indent": 3,
      "text": "Servers that do not rely on the idempotence of iPATCH can easily support both PATCH and iPATCH, and it is RECOMMENDED they do so. This is inexpensive to do, as, for iPATCH, there is no requirement on the server to check that the client's intention that the request be idempotent is fulfilled (although there is diagnostic value in that check, so a less-constrained implementation may want to perform it).",
      "ja": "iPATCHの冪等に依存しないサーバーを簡単PATCHとiPATCHの両方をサポートすることができ、彼らがそうする推奨されます。 iPATCHのために、クライアントの意図の要求があることを冪等が満たされていることを確認するには、サーバー上の要件がない、これは、診断値がそのチェックにもあるが、そのあまりに制約の実装がしたいこと（、行うことが安価ですそれを実行します）。"
    },
    {
      "indent": 0,
      "text": "3.1. Simple Examples for PATCH and iPATCH",
      "section_title": true,
      "ja": "3.1.  PATCHとiPATCHのための簡単な例"
    },
    {
      "indent": 3,
      "text": "The example is taken over from [RFC6902], which specifies a JSON notation for PATCH operations. A resource located at <coap://www.example.com/object> contains a target JSON document.",
      "ja": "例は、パッチ操作のためのJSON表記を指定する[RFC6902]、から引き継がれます。あるリソース<coap：//www.example.com/object>は、ターゲットJSONドキュメントが含まれています。"
    },
    {
      "indent": 3,
      "text": "JSON document original state:\n    {\n      \"x-coord\": 256,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "REQ: iPATCH CoAP://www.example.com/object Content-Format: 51 (application/json-patch+json) [ { \"op\":\"replace\", \"path\":\"x-coord\", \"value\":45} ]",
      "ja": "REQ：iPATCH CoAP：//www.example.com/objectコンテンツ形式：51（アプリケーション/ JSONパッチ+ JSON）{ \"OP\"： \"置換\"、 \"パス\"： \"X-COORD\"、「値「：45}]"
    },
    {
      "indent": 3,
      "text": "RET: CoAP 2.04 Changed",
      "ja": "ルール：COAP 2.04を変更"
    },
    {
      "indent": 3,
      "text": "JSON document final state:\n    {\n      \"x-coord\": 45,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This example illustrates use of an idempotent modification to the x-coord member of the existing resource \"object\". The 2.04 (Changed) response code conforms with the CoAP PUT method.",
      "ja": "この例では、既存のリソース「オブジェクト」のX-COORD部材に冪等の修飾の使用を示します。 2.04（変更）応答コードはCoAP PUTメソッドに準拠します。"
    },
    {
      "indent": 3,
      "text": "The same example using the Content-Format application/merge-patch+json from [RFC7396] looks like the following:",
      "ja": "[RFC7396]からコンテンツフォーマットのアプリケーション/マージ・パッチ+ JSONを使用して同じ例は次のようになります。"
    },
    {
      "indent": 3,
      "text": "JSON document original state:\n    {\n      \"x-coord\": 256,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "REQ: iPATCH CoAP://www.example.com/object Content-Format: 52 (application/merge-patch+json) { \"x-coord\":45}",
      "ja": "REQ：iPATCH CoAP：//www.example.com/objectコンテンツ形式：52（アプリケーション/マージパッチ+ JSON）{ \"X-COORD\"：45}"
    },
    {
      "indent": 3,
      "text": "RET: CoAP 2.04 Changed",
      "ja": "ルール：COAP 2.04を変更"
    },
    {
      "indent": 3,
      "text": "JSON document final state:\n    {\n      \"x-coord\": 45,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The examples show the use of the iPATCH method, but the use of the PATCH method would have led to the same result. Below, a non-idempotent modification is shown. Because the action is non-idempotent, iPATCH returns an error, while PATCH executes the action.",
      "ja": "例はiPATCH方法の使用を示すが、PATCHメソッドを使用すると、同じ結果につながっていると思います。以下は、非冪等の変更が示されています。アクションが非冪等であるため、パッチがアクションを実行しながら、iPATCHは、エラーを返します。"
    },
    {
      "indent": 3,
      "text": "JSON document original state:\n    {\n      \"x-coord\": 256,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "REQ: iPATCH CoAP://www.example.com/object Content-Format: 51 (application/json-patch+json) [ { \"op\":\"add\",\"path\":\"foo/1\",\"value\":\"bar\"} ] RET: CoAP 4.00 Bad Request Diagnostic payload: Patch format not idempotent",
      "ja": "REQ：iPATCH CoAP：//www.example.com/objectコンテンツ形式：51（アプリケーション/ JSONパッチ+ JSON）{ \"OP\"： \"追加\"、 \"パス\"： \"FOO / 1\"、 \"値「：」バー \"}] RET：CoAP 4.00不正な要求診断ペイロード：パッチ形式は冪等でありません"
    },
    {
      "indent": 3,
      "text": "JSON document final state is unchanged",
      "ja": "JSONドキュメントは、最終的な状態は変更されません"
    },
    {
      "indent": 3,
      "text": "REQ: PATCH CoAP://www.example.com/object Content-Format: 51 (application/json-patch+json) [ { \"op\":\"add\",\"path\":\"foo/1\",\"value\":\"bar\"} ] RET: CoAP 2.04 Changed",
      "ja": "REQ：PATCH CoAP：//www.example.com/objectコンテンツ形式：51（アプリケーション/ JSONパッチ+ JSON）{ \"OP\"： \"追加\"、 \"パス\"： \"FOO / 1\"、 \"値\"：\" バー \"}] RET：CoAP 2.04を変更"
    },
    {
      "indent": 3,
      "text": "JSON document final state:\n    {\n      \"x-coord\": 45,\n      \"y-coord\": 45,\n      \"foo\": [\"bar\",\"bar\",\"baz\"]\n    }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2. Response Codes",
      "section_title": true,
      "ja": "3.2. 応答コード"
    },
    {
      "indent": 3,
      "text": "PATCH and iPATCH for CoAP adopt the response codes as specified in Sections 5.9 and 12.1.2 of [RFC7252] and add 4.09 (Conflict) and 4.22 (Unprocessable Entity) with the semantics specified in Section 3.4 of the present specification.",
      "ja": "CoAPのパッチとiPATCHはセクション5.9と[RFC7252]の12.1.2で指定された応答コードを採用し、本明細書のセクション3.4で指定された意味論と4.09（競合）及び4.22（処理不可能なエンティティ）を加えます。"
    },
    {
      "indent": 0,
      "text": "3.3. Option Numbers",
      "section_title": true,
      "ja": "3.3. オプション番号"
    },
    {
      "indent": 3,
      "text": "PATCH and iPATCH for CoAP adopt the option numbers as specified in Sections 5.10 and 12.2 of [RFC7252].",
      "ja": "セクション5.10で指定し、[RFC7252]の12.2としてCoAPためPATCHとiPATCHは、オプション番号を採用します。"
    },
    {
      "indent": 0,
      "text": "3.4. Error Handling",
      "section_title": true,
      "ja": "3.4. エラー処理"
    },
    {
      "indent": 3,
      "text": "A PATCH or iPATCH request may fail under certain known conditions. These situations should be dealt with as expressed below.",
      "ja": "パッチまたはiPATCH要求は、特定の既知の条件下で失敗する可能性があります。これらの状況は、以下の表現として扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "Malformed PATCH or iPATCH payload: If a server determines that the payload provided with a PATCH or iPATCH request is not properly formatted, it can return a 4.00 (Bad Request) CoAP error. The definition of a malformed payload depends upon the CoAP Content-Format specified with the request.",
      "ja": "不正な形式のパッチまたはiPATCHペイロード：サーバーがPATCHまたはiPATCH要求を提供ペイロードが適切にフォーマットされていないと判断した場合、それは4.00（不正な要求）CoAPエラーを返すことができます。不正なペイロードの定義は、リクエストで指定されたCoAPコンテンツフォーマットに依存します。"
    },
    {
      "indent": 3,
      "text": "Unsupported PATCH or iPATCH payload: In case a client sends a payload that is inappropriate for the resource identified by the Request-URI, the server can return a 4.15 (Unsupported Content-Format) CoAP error. The server can determine if the payload is supported by checking the CoAP Content-Format specified with the request.",
      "ja": "サポートされていないPATCHまたはiPATCHペイロード：クライアントは、Request-URIによって識別されるリソースには不適切であるペイロードを送る場合、サーバは4.15（サポートされていないコンテンツフォーマット）CoAPエラーを返すことができます。ペイロードは、要求で指定されたCoAPコンテンツフォーマットをチェックすることによって、サポートされている場合、サーバーが決定することができます。"
    },
    {
      "indent": 3,
      "text": "Unprocessable request: This situation occurs when the payload of a PATCH request is determined to be valid (i.e., well-formed and supported) but the server is unable to or is incapable of processing the request. The server can return a 4.22 (Unprocessable Entity) CoAP error. More specific scenarios might include situations such as:",
      "ja": "処理不可能な要求：PATCH要求のペイロードが有効であると判定された場合に、この状況が発生する（すなわち、十分に形成され、サポートされている）が、サーバができないか、要求を処理することができません。サーバーは、4.22（処理不能エンティティ）CoAPエラーを返すことができます。より具体的なシナリオは、次のような状況を含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "* the server has insufficient computing resources to complete the request successfully -- 4.13 (Request Entity Too Large) CoAP response code (see below); or",
      "ja": "*サーバーが正常に要求を完了するのに十分なコンピューティングリソースを持っている -  4.13（リクエストエンティティが大きすぎます）CoAP応答コード（下記参照します）。または"
    },
    {
      "indent": 6,
      "text": "* the resource specified in the request becomes invalid by applying the payload -- 4.09 (Conflict) CoAP response code (see \"Conflicting state\" below)).",
      "ja": "）（以下「競合状態」を参照）4.09（競合）CoAP応答コード -  *要求で指定されたリソースは、ペイロードを適用することにより無効になります。"
    },
    {
      "indent": 6,
      "text": "In case there are more specific errors that provide additional insight into the problem, then those should be used.",
      "ja": "場合には問題に追加の洞察を提供し、より具体的なエラーが発生し、それらを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Resource not found: The 4.04 (Not Found) error should be returned if the payload of a PATCH request cannot be applied to a non-existent resource.",
      "ja": "リソースが見つかりません：PATCH要求のペイロードが存在しないリソースに適用することができない場合は4.04（見つかりません）エラーが返されるべきです。"
    },
    {
      "indent": 3,
      "text": "Failed precondition: In case the client uses the conditional If-Match or If-None-Match option to define a precondition for the PATCH request, and that precondition fails, then the server can return the 4.12 (Precondition Failed) CoAP error.",
      "ja": "失敗した前提条件：場合、クライアントは、PATCHリクエストのための前提条件を定義するための条件付きマッチする場合もしくはIf-None-Matchのオプションを使用し、その前提条件が失敗した場合、サーバは4.12（前提条件が失敗した）CoAPエラーを返すことができます。"
    },
    {
      "indent": 3,
      "text": "Request too large: If the payload of the PATCH request is larger than a CoAP server can process, then it can return the 4.13 (Request Entity Too Large) CoAP error.",
      "ja": "要求が大きすぎる：PATCH要求のペイロードがCoAPサーバが処理できるよりも大きい場合、それは4.13（リクエストエンティティが大きすぎます）CoAPエラーを返すことができます。"
    },
    {
      "indent": 3,
      "text": "Conflicting state: If the modification specified by a PATCH or iPATCH request causes the resource to enter an inconsistent state that the server cannot resolve, the server can return the 4.09 (Conflict) CoAP response. The server SHOULD generate a payload that includes enough information for a user to recognize the source of the conflict. The server MAY return the actual resource state to provide the client with the means to create a new consistent resource state. Such a situation might be encountered when a structural modification is applied to a configuration data store but the structures being modified do not exist.",
      "ja": "矛盾状態：PATCHまたはiPATCH要求で指定された変更は、サーバーが解決できないという矛盾した状態に入るようにリソースが発生した場合、サーバは4.09（競合）CoAP応答を返すことができます。サーバは、ユーザが競合のソースを認識するための十分な情報を含むペイロードを生成する必要があります。サーバーは、新しい一貫性のあるリソースの状態を作成するための手段をクライアントに提供するために、実際のリソースの状態を返すことがあります。構造的な変更は、構成データストアに適用されたときにこのような状況が発生することがありますが、変更されている構造が存在しません。"
    },
    {
      "indent": 3,
      "text": "Concurrent modification: Resource-constrained devices might need to process requests in the order they are received. In case requests are received concurrently to modify the same resource but they cannot be queued, the server can return a 5.03 (Service Unavailable) CoAP response code.",
      "ja": "同時修正：リソースに制約のあるデバイスは、それらが受信された順序で要求を処理する必要がある場合があります。場合には要求は同じリソースを変更するために、同時に受信されているが、それらはキューに入れることができない、サーバーは、5.03（サービス利用不可）CoAPレスポンスコードを返すことができます。"
    },
    {
      "indent": 3,
      "text": "Conflict handling failure: If the modification implies the reservation of resources or the wait time for conditions to become true leads to a too-long request execution time, the server can return a 5.03 (Service Unavailable) response code.",
      "ja": "紛争処理の失敗：修正はリソースの予約や、長すぎる要求実行時に真のリードになるための条件のための待ち時間を意味している場合、サーバは5.03（サービス使用不可）レスポンスコードを返すことができます。"
    },
    {
      "indent": 3,
      "text": "It is possible that other error situations not mentioned here are encountered by a CoAP server while processing the PATCH request. In these situations, other appropriate CoAP status codes can also be returned.",
      "ja": "PATCHリクエストを処理している間、ここで言及されていない他のエラー状況がCoAPサーバが遭遇されている可能性があります。このような状況では、他の適切なCoAPステータスコードも返すことができます。"
    },
    {
      "indent": 0,
      "text": "4. The New Set of CoAP Methods",
      "section_title": true,
      "ja": "4. CoAPメソッドの新しいセット"
    },
    {
      "indent": 3,
      "text": "Adding three new methods to CoAP's existing four may seem like a major change. However, FETCH and the two PATCH variants fit well into the REST paradigm and have been anticipated on the HTTP side. Adding both a non-idempotent and an idempotent PATCH variant allows interoperability with HTTP's PATCH method to be kept and allows the use/indication of an idempotent PATCH when that is possible, which saves significant effort on the server side.",
      "ja": "CoAPの既存4に3つの新しいメソッドを追加すると、大きな変化のように見えるかもしれません。しかし、FETCHおよび2つのPATCH変異体は、RESTパラダイムにうまく適合し、HTTP側で予想されています。非冪等と冪等パッチ変異体の両方を追加すると、HTTPのPATCHメソッドとの相互運用性を維持することを可能にし、それが可能な場合、サーバ側に多大な労力を節約する、冪等パッチの使用/表示を可能にします。"
    },
    {
      "indent": 3,
      "text": "Interestingly, the three new methods fit into the old table of methods with a surprising similarity in the idempotence and safety attributes:",
      "ja": "興味深いことに、3の新しいメソッドは冪等性と安全性の属性で驚くべき類似性を持つメソッドの古いテーブルに適合します："
    },
    {
      "indent": 11,
      "text": "+------+--------+------+--------+------+------------+\n| Code | Name   | Code | Name   | safe | idempotent |\n+------+--------+------+--------+------+------------+\n| 0.01 | GET    | 0.05 | FETCH  | yes  | yes        |\n| 0.02 | POST   | 0.06 | PATCH  | no   | no         |\n| 0.03 | PUT    | 0.07 | iPATCH | no   | yes        |\n| 0.04 | DELETE |      |        | no   | yes        |\n+------+--------+------+--------+------+------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This section analyzes the possible threats to the CoAP FETCH and PATCH or iPATCH methods. It is meant to inform protocol and application developers about the security limitations of CoAP FETCH and PATCH or iPATCH as described in this document.",
      "ja": "このセクションでは、CoAPへの脅威の可能性は、FETCHおよびPATCHまたはiPATCH方法を分析します。この文書で説明したようにFETCHおよびPATCHまたはiPATCH CoAPのセキュリティ制限についてのプロトコルおよびアプリケーション開発者に通知するものとします。"
    },
    {
      "indent": 3,
      "text": "The FETCH method is subject to the same general security considerations as all CoAP methods as described in Section 11 of [RFC7252]. Specifically, the security considerations for FETCH are closest to those of GET, except that the FETCH request carries a payload that may need additional protection. The payload of a FETCH request may reveal more detailed information about the specific portions of a resource of interest to the requester than a GET request for the entire resource would; this may mean that confidentiality protection of the request by Datagram Transport Layer Security (DTLS) or other means is needed for FETCH where it wouldn't be needed for GET.",
      "ja": "[RFC7252]のセクション11に記載されているようにFETCH方法は、すべてのCoAP方法と同じ一般的なセキュリティ問題を受けます。具体的には、FETCHのためのセキュリティの考慮事項は、フェッチ要求を除いて、GETのものに最も近い追加的な保護を必要とするかもしれないペイロードを運びます。フェッチ要求のペイロードは、全リソースだろうためのGET要求よりも要求者に関心のあるリソースの特定の部分についての詳細な情報を明らかにすることができます。これは、データグラムトランスポート層セキュリティ（DTLS）、またはそれがGETのために必要ではないでしょうどこFETCHのために必要とされる他の手段による要求の機密保護を意味するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The PATCH and iPATCH methods are subject to the same general security considerations as all CoAP methods as described in Section 11 of [RFC7252]. The specific security considerations for PATCH or iPATCH are nearly identical to the security considerations for PUT [RFC7252]; the security considerations of Section 5 of [RFC5789] also apply to PATCH and iPATCH. Specifically, there is likely to be a need for authorizing requests (possibly through access control and/or authentication) and for ensuring that data is not corrupted through transport errors or through accidental overwrites. The mechanisms used for PUT can be used for PATCH or iPATCH as well.",
      "ja": "[RFC7252]のセクション11に記載されているようにPATCHとiPATCH方法は全てCoAP方法と同じ一般的なセキュリティの考慮の対象となっています。パッチまたはiPATCHに特異的なセキュリティ問題は、PUT [RFC7252]のためのセキュリティ上の考慮事項とほぼ同じです。 [RFC5789]のセクション5のセキュリティ上の考慮事項は、パッチとiPATCHに適用されます。具体的には、（おそらくアクセス制御および/または認証を介して）要求を認可するため、データが転送エラーを介して、または偶発上書きによって破損していないことを確実にする必要がありそうです。 PUTのために使用されるメカニズムは、同様にパッチまたはiPATCHのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The new methods defined in the present specification are secured following the CoAP recommendations for the existing methods as specified in Section 9 of [RFC7252]. When additional security techniques are standardized for CoAP (e.g., Object Security), these techniques are then also available for securing the new methods.",
      "ja": "[RFC7252]のセクション9で指定されるように、本明細書で定義された新しい方法は、既存の方法のためのCoAPの推奨に従って固定されます。追加のセキュリティ技術はCoAP（例えば、セキュリティオブジェクト）のために標準化されている場合は、これらの技術はまた、新しい方法を確保するために用意されています。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entries to the subregistry \"CoAP Method Codes\":",
      "ja": "IANAは副登録「CoAPメソッドのコード」に、次のエントリを追加しました："
    },
    {
      "indent": 23,
      "text": "+------+--------+-----------+\n| Code | Name   | Reference |\n+------+--------+-----------+\n| 0.05 | FETCH  | RFC 8132  |\n| 0.06 | PATCH  | RFC 8132  |\n| 0.07 | iPATCH | RFC 8132  |\n+------+--------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The FETCH method is idempotent and safe, and it returns the same response codes that GET can return, plus 4.13 (Request Entity Too Large), 4.15 (Unsupported Content-Format), and 4.22 (Unprocessable Entity) with the semantics specified in Section 2.2.",
      "ja": "FETCHメソッドは冪等で安全であり、それは返すことができGET同じ応答コードを返し、プラス2.2節で指定されたセマンティクスを持つ4.13（リクエストエンティティが大きすぎ）、4.15（サポートされていないコンテンツフォーマット）、および4.22（処理不能エンティティ） 。"
    },
    {
      "indent": 3,
      "text": "The PATCH method is neither idempotent nor safe. It returns the same response codes that POST can return, plus 4.09 (Conflict) and 4.22 (Unprocessable Entity) with the semantics specified in Section 3.4.",
      "ja": "PATCHメソッドは冪等でも安全でもありません。これは、3.4節で指定された意味論と同じ応答POSTを返すことができるコード、プラス4.09（紛争）および4.22（処理不能エンティティ）を返します。"
    },
    {
      "indent": 3,
      "text": "The iPATCH method is identical to the PATCH method, except that it is idempotent.",
      "ja": "iPATCH方法は、それが冪等であることを除いて、PATCHメソッドと同じです。"
    },
    {
      "indent": 3,
      "text": "IANA has added the following code to the subregistry \"CoAP Response Codes\":",
      "ja": "IANAは副登録「CoAPレスポンスコード」に、次のコードを追加しました："
    },
    {
      "indent": 16,
      "text": "+------+----------------------+-----------+\n| Code | Name                 | Reference |\n+------+----------------------+-----------+\n| 4.09 | Conflict             | RFC 8132  |\n| 4.22 | Unprocessable Entity | RFC 8132  |\n+------+----------------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IANA has added entries to the subregistry \"CoAP Content-Formats\":",
      "ja": "IANAは、「CoAPコンテンツフォーマット」副登録にエントリを追加しました："
    },
    {
      "indent": 4,
      "text": "+------------------------------+----------------+----+-----------+\n| Media Type                   | Content Coding | ID | Reference |\n+------------------------------+----------------+----+-----------+\n| application/json-patch+json  | identity       | 51 | [RFC6902] |\n| application/merge-patch+json | identity       | 52 | [RFC7396] |\n+------------------------------+----------------+----+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5789] Dusseault, L. and J. Snell, \"PATCH Method for HTTP\", RFC 5789, DOI 10.17487/RFC5789, March 2010, <http://www.rfc-editor.org/info/rfc5789>.",
      "ja": "[RFC5789] Dusseault、L.及びJ.スネル、 \"HTTPのパッチ方法\"、RFC 5789、DOI 10.17487 / RFC5789、2010年3月<http://www.rfc-editor.org/info/rfc5789>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7641] Hartke, K., \"Observing Resources in the Constrained Application Protocol (CoAP)\", RFC 7641, DOI 10.17487/RFC7641, September 2015, <http://www.rfc-editor.org/info/rfc7641>.",
      "ja": "[RFC7641] HARTKE、K.、 \"制約アプリケーションプロトコル（CoAP）で観測資源\"、RFC 7641、DOI 10.17487 / RFC7641、2015年9月、<http://www.rfc-editor.org/info/rfc7641>。"
    },
    {
      "indent": 3,
      "text": "[RFC7959] Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in the Constrained Application Protocol (CoAP)\", RFC 7959, DOI 10.17487/RFC7959, August 2016, <http://www.rfc-editor.org/info/rfc7959>.",
      "ja": "[RFC7959]ボルマン、C.およびZ.シェルビー、エド、 \"制約アプリケーションプロトコル（CoAP）でブロックワイズ転送\"、RFC 7959、DOI 10.17487 / RFC7959、2016年8月、<HTTP：//www.rfc- editor.org/info/rfc7959>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC5323] Reschke, J., Ed., Reddy, S., Davis, J., and A. Babich, \"Web Distributed Authoring and Versioning (WebDAV) SEARCH\", RFC 5323, DOI 10.17487/RFC5323, November 2008, <http://www.rfc-editor.org/info/rfc5323>.",
      "ja": "[RFC5323] Reschke、J.、編、レディ、S.、デイビス、J.、およびA. Babich、 \"Web分散オーサリングとバージョン管理（WebDAV）SEARCH\"、RFC 5323、DOI 10.17487 / RFC5323、2008年11月、< http://www.rfc-editor.org/info/rfc5323>。"
    },
    {
      "indent": 3,
      "text": "[RFC6902] Bryan, P., Ed. and M. Nottingham, Ed., \"JavaScript Object Notation (JSON) Patch\", RFC 6902, DOI 10.17487/RFC6902, April 2013, <http://www.rfc-editor.org/info/rfc6902>.",
      "ja": "[RFC6902]ブライアン、P.、エド。そして、M.ノッティンガム、エド。、 \"JavaScriptのオブジェクト表記法（JSON）パッチ\"、RFC 6902、DOI 10.17487 / RFC6902、2013年4月、<http://www.rfc-editor.org/info/rfc6902>。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T.、エド。、 \"JavaScriptのObject Notation（JSON）形式のデータ交換フォーマット\"、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<http://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7396] Hoffman, P. and J. Snell, \"JSON Merge Patch\", RFC 7396, DOI 10.17487/RFC7396, October 2014, <http://www.rfc-editor.org/info/rfc7396>.",
      "ja": "[RFC7396]ホフマン、P.及びJ.スネル、 \"JSONパッチをマージ\"、RFC 7396、DOI 10.17487 / RFC7396、2014年10月、<http://www.rfc-editor.org/info/rfc7396>。"
    },
    {
      "indent": 3,
      "text": "[COAP-MGMNT] Stok, P., Bierman, A., Veillette, M., and A. Pelov, \"CoAP Management Interface\", Work in Progress, draft-ietf-core-comi-00, January 2017.",
      "ja": "[COAP-MGMNT] STOK、P.、Bierman、A.、Veillette、M.、およびA. Pelov、 \"CoAP管理インターフェース\" が進行中で働いて、ドラフト-IETF-コア-COMI-00、2017年1月。"
    },
    {
      "indent": 3,
      "text": "[CORE-APP] Hartke, K., \"CoRE Application Descriptions\", Work in Progress, draft-hartke-core-apps-07, February 2017.",
      "ja": "[CORE-APP] HARTKE、K.、 \"Coreアプリケーションの説明\" が進行中で働いて、ドラフトHARTKEコア・アプリケーション-07、2017年2月。"
    },
    {
      "indent": 3,
      "text": "[HTTP-SEARCH] Reschke, J., Malhotra, A., and J. Snell, \"HTTP SEARCH Method\", Work in Progress, draft-snell-search-method-00, April 2015.",
      "ja": "[HTTP-SEARCH] Reschke、J.、マルホトラ、A.、およびJ.スネル、 \"HTTP検索方法\"、進行中で働いて、ドラフトスネル探索法-00、2015年4月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Klaus Hartke has pointed out some essential differences between CoAP and HTTP concerning PATCH and found a number of problems in an earlier draft version of Section 2. We are grateful for discussions with Christian Amsuss, Andy Bierman, Timothy Carey, Paul Duffy, Matthias Kovatsch, Michel Veillette, Michael Verschoor, Thomas Watteyne, and Gengyu Wei. Christian Groves provided detailed comments during the Working Group Last Call, and Christer Holmberg's Gen-ART review provided some further editorial improvement. Further Last Call reviews were provided by Sheng Jiang and Phillip Hallam-Baker. As usual, the IESG had some very good reviews, and we would like to specifically call out those by Alexey Melnikov (responsible AD) and Alissa Cooper.",
      "ja": "クラウスHARTKEは、PATCHに関するCoAPとHTTPの間にいくつかの重要な相違点を指摘し、私たちはクリスチャンAmsuss、アンディBierman、ティモシー・キャリー、ポール・ダフィー、マティアスKovatschとの協議のために感謝している第2節の以前のドラフト版で多くの問題を発見しましたマイケル・ベイレット、マイケル・Verschoor、トーマスWatteyne、およびGengyu魏。クリスチャン・グローブスは、ワーキンググループラストコール中に詳細なコメントを提供し、クリステルHolmbergの者のGen-ARTのレビューは、さらにいくつかの社説の改善を提供します。さらにラストコールレビューはシェン・ジャンフィリップハラム - ベイカーによって提供されました。いつものように、IESGは、いくつかの非常に良いレビューを持っていた、そして我々は、具体的アレクセイ・メルニコフ（責任AD）とアリッサ・クーパーによってそれらを呼び出すしたいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Peter van der Stok Consultant",
      "ja": "ピーター・ファン・デル・STOKコンサルタント"
    },
    {
      "indent": 3,
      "text": "Email: consultancy@vanderstok.org",
      "ja": "メール：consultancy@vanderstok.org"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universitaet Bremen TZI Postfach 330440 Bremen D-28359 Germany",
      "ja": "カルステンボルマンUniversitaetブレーメンTZI POSTFACH 330440 D-28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63921 Email: cabo@tzi.org",
      "ja": "電話：+ 49-421-218-63921 Eメール：cabo@tzi.org"
    },
    {
      "indent": 3,
      "text": "Anuj Sehgal NAVOMI, Inc.",
      "ja": "AnujセーガルNavamiこれ。"
    },
    {
      "indent": 3,
      "text": "Email: anuj.sehgal@navomi.com",
      "ja": "メール：anuj.sehgal@navomi.com"
    }
  ]
}