{
  "title": {
    "text": "RFC 8434 - Requirements for Parallel NFS (pNFS) Layout Types",
    "ja": "RFC 8434 - パラレルNFS（pNFSの）レイアウトタイプの要件"
  },
  "number": 8434,
  "created_at": "2019-11-02 00:50:18.813891+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         T. Haynes\nRequest for Comments: 8434                                   Hammerspace\nUpdates: 5661                                                August 2018\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Requirements for Parallel NFS (pNFS) Layout Types",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines the requirements that individual Parallel NFS (pNFS) layout types need to meet in order to work within the pNFS framework as defined in RFC 5661. In so doing, this document aims to clearly distinguish between requirements for pNFS as a whole and those specifically directed to the pNFS file layout. The lack of a clear separation between the two sets of requirements has been troublesome for those specifying and evaluating new layout types. In this regard, this document updates RFC 5661.",
      "ja": "この文書は、個々のパラレルNFS（pNFSの）レイアウトの種類はそうではRFC 5661.で定義されているpNFSのフレームワーク内で動作するために満たすために必要な要件を定義し、この文書は明らかに全体としてのpNFS、それらの要件を区別することを目指して特にpNFSのファイルレイアウトに指示しました。要件の2つのセットの間の明確な分離の欠如は、新しいレイアウトの種類を指定し、評価する人のため面倒となっています。この点で、この文書はRFC 5661に更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8434.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8434で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Definitions .....................................................3\n   2.1. Use of the Terms \"Data Server\" and \"Storage Device\" ........5\n   2.2. Requirements Language ......................................6\n3. The Control Protocol ............................................6\n   3.1. Control Protocol Requirements ..............................8\n   3.2. Previously Undocumented Protocol Requirements ..............9\n   3.3. Editorial Requirements ....................................10\n4. Specifications of Original Layout Types ........................11\n   4.1. File Layout Type ..........................................11\n   4.2. Block Layout Type .........................................12\n   4.3. Object Layout Type ........................................13\n5. Summary ........................................................14\n6. Security Considerations ........................................15\n7. IANA Considerations ............................................15\n8. References .....................................................16\n   8.1. Normative References ......................................16\n   8.2. Informative References ....................................16\nAcknowledgments ...................................................17\nAuthor's Address ..................................................17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The concept of \"layout type\" has a central role in the definition and implementation of Parallel NFS (pNFS) (see [RFC5661]). Clients and servers implementing different layout types behave differently in many ways while conforming to the overall pNFS framework defined in [RFC5661] and this document. Layout types may differ as to:",
      "ja": "「レイアウトタイプ」の概念はパラレルNFS（pNFSの）の定義と実装において中心的な役割を持っている（[RFC5661]を参照）。 [RFC5661]で定義された全体的なpNFSのフレームワークと、この文書に準拠しながら、別のレイアウトタイプを実装するクライアントとサーバーは、多くの点で異なる動作をします。へと異なる場合がありレイアウトのタイプ："
    },
    {
      "indent": 3,
      "text": "o The method used to do I/O operations directed to data storage devices.",
      "ja": "データ・ストレージ・デバイスに向けられたI / O操作を実行するために使用される方法、O。"
    },
    {
      "indent": 3,
      "text": "o The requirements for communication between the metadata server (MDS) and the storage devices.",
      "ja": "メタデータサーバ（MDS）とストレージデバイス間の通信のための要件O。"
    },
    {
      "indent": 3,
      "text": "o The means used to ensure that I/O requests are only processed when the client holds an appropriate layout.",
      "ja": "クライアントは、適切なレイアウトを保持しているとき、I / O要求がのみ処理されることを保証するために使用される手段O。"
    },
    {
      "indent": 3,
      "text": "o The format and interpretation of nominally opaque data fields in pNFS-related NFSv4.x data structures.",
      "ja": "pNFSの関連NFSv4.xデータ構造内の名目上の不透明なデータフィールドのフォーマット及び解釈O。"
    },
    {
      "indent": 3,
      "text": "Each layout type will define the needed details for its usage in the specification for that layout type; layout type specifications are always Standards Track RFCs. Except for the file layout type defined in Section 13 of [RFC5661], existing layout types are defined in their own Standards Track documents, and it is anticipated that new layout types will be defined in similar documents.",
      "ja": "各レイアウトタイプは、レイアウトタイプの仕様におけるその使用のために必要な詳細情報を定義します。レイアウトタイプの仕様は、常に標準化過程のRFCです。 [RFC5661]のセクション13で定義されたファイルのレイアウトタイプを除き、既存のレイアウトタイプは、独自の標準化過程文書で定義されている、そして新しいレイアウトタイプが類似した文書で定義されることが予想されます。"
    },
    {
      "indent": 3,
      "text": "The file layout type was defined in the Network File System (NFS) version 4.1 protocol specification [RFC5661]. The block layout type was defined in [RFC5663], and the object layout type was defined in [RFC5664]. Subsequently, the Small Computer System Interface (SCSI) layout type was defined in [RFC8154].",
      "ja": "ファイル・レイアウト・タイプは、ネットワークファイルシステム（NFS）バージョン4.1プロトコル仕様[RFC5661]で定義されました。ブロックレイアウトタイプは[RFC5663]で定義された、オブジェクトのレイアウトタイプは、[RFC5664]で定義されました。その後、小型コンピュータシステムインタフェース（SCSI）のレイアウトタイプは[RFC8154]で定義されました。"
    },
    {
      "indent": 3,
      "text": "Some implementers have interpreted the text in Sections 12 (\"Parallel NFS (pNFS)\") and 13 (\"NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type\") of [RFC5661] as applying only to the file layout type. Because Section 13 was not covered in a separate Standards Track document such as those for both the block and object layout types, there was some confusion as to the responsibilities of both the metadata server and the data servers (DSs) that were laid out in Section 12.",
      "ja": "ファイルのレイアウトタイプにのみ適用されると、[RFC5661]の：いくつかの実装では、セクション12内のテキスト（「パラレルNFS（pNFSの）」）及び13（「ファイルのレイアウトタイプのpNFSにおけるストレージプロトコルとしてNFSv4.1」）を解釈しています。第13節は、そのようなブロックやオブジェクトのレイアウトタイプの両方のためのものと別の標準化過程文書でカバーされていなかったので、セクションにレイアウトされたメタデータ・サーバとデータ・サーバ（DSS）の両方の責任に関しては、いくつかの混乱がありました12。"
    },
    {
      "indent": 3,
      "text": "As a consequence, authors of new specifications (see [RFC8435] and [Lustre]) may struggle to meet the requirements to be a pNFS layout type. This document gathers the requirements from all of the original Standards Track documents regarding layout type and then specifies the requirements placed on all layout types independent of the particular type chosen.",
      "ja": "その結果、新仕様の著者は、pNFSのレイアウトタイプであることを要件を満たすために苦労することがあり（[RFC8435]と[光沢]を参照します）。この文書では、レイアウトの種類について、元の標準化過程文書のすべての要件を収集して、選択された特定のタイプに関係なく、すべてのレイアウトタイプに置か要件を指定します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "control communication requirement: the specification for information on layouts, stateids, file metadata, and file data that must be communicated between the metadata server and the storage devices. There is a separate set of requirements for each layout type.",
      "ja": "制御通信要件：メタデータサーバとストレージデバイス間で通信されなければならないレイアウト、のstateids、ファイル・メタデータ、およびファイルデータに関する情報の仕様。各レイアウトタイプの要件の別々のセットがあります。"
    },
    {
      "indent": 3,
      "text": "control protocol: the particular mechanism that an implementation of a layout type would use to meet the control communication requirement for that layout type. This need not be a protocol as normally understood. In some cases, the same protocol may be used as both a control protocol and storage protocol.",
      "ja": "制御プロトコル：レイアウトタイプの実装は、そのレイアウトタイプの制御通信の要件を満たすために使用する特定の機構。通常理解されるようにこれはプロトコルである必要はありません。いくつかのケースでは、同じプロトコル制御プロトコルとストレージプロトコルの両方として使用することができます。"
    },
    {
      "indent": 3,
      "text": "storage protocol: the protocol used by clients to do I/O operations to the storage device. Each layout type specifies the set of storage protocols.",
      "ja": "ストレージプロトコル：ストレージ・デバイスへのI / O操作を行うためにクライアントが使用するプロトコル。それぞれのレイアウトタイプは、ストレージプロトコルのセットを指定します。"
    },
    {
      "indent": 3,
      "text": "loose coupling: when the control protocol is a storage protocol.",
      "ja": "疎結合：制御プロトコルは、ストレージプロトコルです。"
    },
    {
      "indent": 3,
      "text": "tight coupling: an arrangement in which the control protocol is one designed specifically for control communication. It may be either a proprietary protocol adapted specifically to a particular metadata server or a protocol based on a Standards Track document.",
      "ja": "密結合：制御プロトコルは、制御通信のために特別に設計された1つである構成。これは、特定のメタデータサーバに特異的に適合独自のプロトコルまたは標準化過程文書に基づいてプロトコルのいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "(file) data: that part of the file system object that contains the data to be read or written. It is the contents of the object rather than the attributes of the object.",
      "ja": "（ファイル）データ：読み書きされるデータを含むファイル・システム・オブジェクトのその部分。これは、オブジェクトの内容ではなく、オブジェクトの属性です。"
    },
    {
      "indent": 3,
      "text": "data server (DS): a pNFS server that provides the file's data when the file system object is accessed over a file-based protocol. Note that this usage differs from that in [RFC5661], which applies the term in some cases even when other sorts of protocols are being used. Depending on the layout, there might be one or more data servers over which the data is striped. While the metadata server is strictly accessed over the NFSv4.1 protocol, the data server could be accessed via any file access protocol that meets the pNFS requirements.",
      "ja": "データサーバ（DS）：ファイル・システム・オブジェクトがファイルベースのプロトコルを介してアクセスされたときにファイルのデータを提供するのpNFSサーバ。この使用は、プロトコルの他の種類が使用されてもいくつかの場合に用語を適用する[RFC5661]のものと異なることに留意されたいです。レイアウトによっては、データがストライプ化され、その上一台の以上のデータ・サーバがあるかもしれません。メタデータサーバは、厳密NFSv4.1プロトコルを介してアクセスされている間、データ・サーバは、pNFSの要件を満たす任意のファイルアクセスプロトコルを介してアクセスすることができます。"
    },
    {
      "indent": 6,
      "text": "See Section 2.1 for a comparison of this term and \"storage device\".",
      "ja": "この用語と「ストレージデバイス」の比較については、セクション2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "storage device: the target to which clients may direct I/O requests when they hold an appropriate layout. Note that each data server is a storage device but that some storage device are not data servers. See Section 2.1 for further discussion.",
      "ja": "ストレージデバイス：彼らは適切なレイアウトを保持したときに、クライアントがI / O要求を指示することができる先のターゲット。各データ・サーバがストレージデバイスであることに注意してくださいが、いくつかのストレージデバイスは、データ・サーバではないこと。さらなる議論については、セクション2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "fencing: the process by which the metadata server prevents the storage devices from processing I/O from a specific client to a specific file.",
      "ja": "フェンシング：メタデータサーバは特定のファイルに特定のクライアントからのI / Oを処理してからストレージデバイスを防止するプロセス。"
    },
    {
      "indent": 3,
      "text": "layout: the information a client uses to access file data on a storage device. This information includes specification of the protocol (layout type) and the identity of the storage devices to be used.",
      "ja": "レイアウト：クライアントは、ストレージ・デバイス上のファイルデータにアクセスするために使用する情報。この情報は、プロトコル（レイアウトタイプ）、使用される記憶装置の同一の仕様を含みます。"
    },
    {
      "indent": 6,
      "text": "The bulk of the contents of the layout are defined in [RFC5661] as nominally opaque, but individual layout types are responsible for specifying the format of the layout data.",
      "ja": "レイアウトの内容の大部分は、名目上、不透明として[RFC5661]で定義されているが、個々のレイアウトタイプは、レイアウトデータのフォーマットを指定する責任があります。"
    },
    {
      "indent": 3,
      "text": "layout iomode: a grant of either read-only or read/write I/O to the client.",
      "ja": "レイアウトIOModeに：クライアントへの読み取り専用または読み取り/書き込みI / Oのいずれかの助成金。"
    },
    {
      "indent": 3,
      "text": "layout stateid: a 128-bit quantity returned by a server that uniquely defines the layout state provided by the server for a specific layout that describes a layout type and file (see",
      "ja": "レイアウトのstateid一意レイアウトタイプとファイルを記述する特定のレイアウトのためにサーバによって提供されるレイアウトの状態を定義するサーバによって返された128ビットの量（参照"
    },
    {
      "indent": 6,
      "text": "Section 12.5.2 of [RFC5661]). Further, Section 12.5.3 of [RFC5661] describes differences in handling between layout stateids and other stateid types.",
      "ja": "[RFC5661]のセクション12.5.2）。さらに、[RFC5661]のセクション12.5.3は、レイアウトのstateidsおよび他のstateidタイプの間の取り扱いの違いを説明しています。"
    },
    {
      "indent": 3,
      "text": "layout type: a specification of both the storage protocol used to access the data and the aggregation scheme used to lay out the file data on the underlying storage devices.",
      "ja": "レイアウトタイプ：データにアクセスするために使用されるストレージプロトコルと、基礎となるストレージデバイス上のファイルのデータをレイアウトするために使用される集計方式の両方の仕様。"
    },
    {
      "indent": 3,
      "text": "recalling a layout: a graceful recall, via a callback, of a specific layout by the metadata server to the client. Graceful here means that the client would have the opportunity to flush any WRITEs, etc., before returning the layout to the metadata server.",
      "ja": "クライアントへのメタデータサーバによって特定のレイアウトで、コールバックを経由して、優雅なリコール：レイアウトをリコール。ここでの優雅は、クライアントがメタデータサーバへのレイアウトを返す前に、任意の書き込み、などをフラッシュする機会を持つことを意味します。"
    },
    {
      "indent": 3,
      "text": "revoking a layout: an invalidation of a specific layout by the metadata server. Once revocation occurs, the metadata server will not accept as valid any reference to the revoked layout, and a storage device will not accept any client access based on the layout.",
      "ja": "メタデータサーバによって特定のレイアウトの無効化：レイアウトを取り消します。失効が発生すると、メタデータサーバは取り消され、レイアウトに有効な任意の参照を受け入れないだろう、とストレージデバイスは、レイアウトに基づいて、任意のクライアントアクセスを受け付けません。"
    },
    {
      "indent": 3,
      "text": "(file) metadata: the part of the file system object that contains various descriptive data relevant to the file object, as opposed to the file data itself. This could include the time of last modification, access time, EOF position, etc.",
      "ja": "（ファイル）メタデータ：ファイルデータ自体とは対照的に、ファイル・オブジェクトに関連する様々な記述データを含むファイル・システム・オブジェクトの一部。これが最後の変更、アクセス時刻、EOFの位置などの時間を含めることができます"
    },
    {
      "indent": 3,
      "text": "metadata server (MDS): the pNFS server that provides metadata information for a file system object. It is also responsible for generating, recalling, and revoking layouts for file system objects, for performing directory operations, and for performing I/O operations to regular files when the clients direct these to the metadata server itself.",
      "ja": "メタデータサーバ（MDS）：ファイル・システム・オブジェクトのメタデータ情報を提供するのpNFSサーバ。また、生成リコール、およびディレクトリ操作を実行するため、およびクライアントは、メタデータサーバ自体にこれらを指示したときに通常のファイルへのI / O操作を実行するため、ファイル・システム・オブジェクトのためのレイアウトを取り消すための責任があります。"
    },
    {
      "indent": 3,
      "text": "stateid: a 128-bit quantity returned by a server that uniquely defines the set of locking-related state provided by the server. Stateids may designate state related to open files, byte-range locks, delegations, or layouts.",
      "ja": "stateid一意サーバによって提供されるロック関連状態のセットを定義し、サーバによって返された128ビットの量。 stateidsは、ファイル、バイト範囲ロック、代表団、またはレイアウトを開くには、関連する状態を指定することができます。"
    },
    {
      "indent": 0,
      "text": "2.1. Use of the Terms \"Data Server\" and \"Storage Device\"",
      "section_title": true,
      "ja": "2.1。用語の使用「データサーバ」と「ストレージデバイス」"
    },
    {
      "indent": 3,
      "text": "In [RFC5661], the terms \"data server\" and \"storage device\" are used somewhat inconsistently:",
      "ja": "[RFC5661]に、用語「データ・サーバ」と「記憶装置」は幾分矛盾使用されます："
    },
    {
      "indent": 3,
      "text": "o In Section 12, where pNFS in general is discussed, the term \"storage device\" is used.",
      "ja": "O一般にpNFSのが議論されている第12章では、用語「記憶装置」が使用されます。"
    },
    {
      "indent": 3,
      "text": "o In Section 13, where the file layout type is discussed, the term \"data server\" is used.",
      "ja": "Oファイルレイアウトの種類が説明されている第13において、用語「データ・サーバ」が使用されます。"
    },
    {
      "indent": 3,
      "text": "o In other sections, the term \"data server\" is used, even in contexts where the storage access type is not NFSv4.1 or any other file access protocol.",
      "ja": "O他のセクションでは、用語「データ・サーバ」があっても、ストレージアクセスタイプがNFSv4.1または他のファイル・アクセス・プロトコルではない状況で、使用されています。"
    },
    {
      "indent": 3,
      "text": "As this document deals with pNFS in general, it uses the more generic term \"storage device\" in preference to \"data server\". The term \"data server\" is used only in contexts in which a file server is used as a storage device. Note that every data server is a storage device, but storage devices that use protocols that are not file access protocols (such as NFS) are not data servers.",
      "ja": "一般的に、pNFSのこのドキュメントのお得な情報として、「データ・サーバ」に優先して、より一般的な用語である「ストレージデバイス」を使用しています。用語「データ・サーバは、」専用ファイルサーバーがストレージ・デバイスとして使用されるコンテキストで使用されています。すべてのデータ・サーバは、記憶装置であることに注意してください、しかし（NFSなど）のアクセス・プロトコルを提出していないプロトコルを使用するストレージデバイスは、データ・サーバではありません。"
    },
    {
      "indent": 3,
      "text": "Since a given storage device may support multiple layout types, a given device can potentially act as a data server for some set of storage protocols while simultaneously acting as a storage device for others.",
      "ja": "所定の記憶装置は、複数のレイアウトタイプをサポートすることができるので、所与のデバイスは、潜在的に同時に他の人のための記憶装置として動作するストレージプロトコルのいくつかのセットのためのデータサーバとして働くことができます。"
    },
    {
      "indent": 0,
      "text": "2.2. Requirements Language",
      "section_title": true,
      "ja": "2.2。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 3,
      "text": "This document differs from most Standards Track documents in that it specifies requirements for those defining future layout types rather than defining the requirements for implementations directly. This document makes clear whether:",
      "ja": "この文書では、それが将来のレイアウトタイプを定義するのではなく、直接実装するための要件を定義するこれらの要件を指定することで、ほとんどの標準化過程文書とは異なります。この文書では、かどうかを明らかに："
    },
    {
      "indent": 3,
      "text": "(1) any particular requirement applies to implementations.",
      "ja": "（1）任意の特定の要件は、実装に適用されます。"
    },
    {
      "indent": 3,
      "text": "(2) any particular requirement applies to those defining layout types.",
      "ja": "（2）任意の特定の要件は、レイアウトの種類を定義するものにも適用されます。"
    },
    {
      "indent": 3,
      "text": "(3) the requirement is a general requirement that implementations need to conform to, with the specific means left to layout type definitions type to specify.",
      "ja": "特定の手段が指定したレイアウトタイプ定義型に左と（3）の要件は、実装が準拠する必要がある一般的な要件です。"
    },
    {
      "indent": 0,
      "text": "3. The Control Protocol",
      "section_title": true,
      "ja": "3.制御プロトコル"
    },
    {
      "indent": 3,
      "text": "A layout type has to meet the requirements that apply to the interaction between the metadata server and the storage device such that they present to the client a consistent view of stored data and locking state (Section 12.2.6 of [RFC5661]). Particular implementations may satisfy these requirements in any manner they choose, and the mechanism chosen need not be described as a protocol. Specifications defining layout types need to clearly show how implementations can meet the requirements discussed below, especially with respect to those that have security implications. In addition, such specifications may find it necessary to impose requirements on implementations of the layout type to ensure appropriate interoperability.",
      "ja": "レイアウトタイプは、メタデータサーバとは、クライアントに保存されたデータの一貫したビューを提示し、ロック状態（[RFC5661]のセクション12.2.6）は、記憶装置との間の相互作用に適用される要件を満たさなければなりません。特定の実装では、彼らが選択した任意の方法でこれらの要件を満たすことができ、選択された機構は、プロトコルとして説明する必要はありません。レイアウトタイプを定義する仕様は明らかに実装は、特にセキュリティに影響を持っているものに関して、以下で説明する要件を満たすことができる方法を示す必要があります。加えて、そのような仕様は、適切な相互運用性を確保することが必要なレイアウトの種類の実装に要求を課すかもしれません。"
    },
    {
      "indent": 3,
      "text": "In some cases, there may be no control protocol other than the storage protocol. This is often described as using a \"loosely coupled\" model. In such cases, the assumption is that the metadata server, storage devices, and client may be changed independently and that the implementation requirements in the layout type specification need to ensure this degree of interoperability. This model is used in the block and object layout type specification.",
      "ja": "いくつかのケースでは、ストレージ・プロトコル以外の制御プロトコルが存在しなくてもよいです。これは、多くの場合、「疎結合」モデルを使用するものとして説明されます。このような場合、仮定は、メタデータサーバ、ストレージデバイス、およびクライアントは、独立して変更することができ、レイアウトタイプ仕様の実装要件は、相互運用性のこの程度を確保する必要があるということです。このモデルは、ブロックとオブジェクトレイアウト型明細書中で使用されます。"
    },
    {
      "indent": 3,
      "text": "In other cases, it is assumed that there will be a purpose-built control protocol that may be different for different implementations of the metadata server and data server. The assumption here is that the metadata server and data servers are designed and implemented as a unit and interoperability needs to be assured between clients and metadata-data server pairs, developed independently. This is the model used for the file layout.",
      "ja": "他の場合では、メタデータサーバとデータサーバの異なる実装のために異なっていてもよく、専用の制御プロトコルが存在するであろうことが想定されます。ここでの仮定は、ユニットと相互運用性は、クライアントと独立して開発されたメタデータ・データ・サーバのペアの間で保証される必要があるメタデータサーバとデータサーバの設計と実装されていることです。これは、ファイルのレイアウトのために使用されるモデルです。"
    },
    {
      "indent": 3,
      "text": "Another possibility is for the definition of a control protocol to be specified in a Standards Track document. There are two subcases to consider:",
      "ja": "制御プロトコルの定義は標準化過程文書で指定されるために別の可能性があります。検討するには、2つのサブケースがあります。"
    },
    {
      "indent": 3,
      "text": "o A new layout type includes a definition of a particular control protocol whose use is obligatory for metadata servers and storage devices implementing the layout type. In this case, the interoperability model is similar to the first case above, and the defining document should assure interoperability among metadata servers, storage devices, and clients developed independently.",
      "ja": "O新しいレイアウトタイプが使用レイアウト・タイプを実装するメタデータサーバとストレージ・デバイスのため必須である特定の制御プロトコルの定義を含みます。この場合には、相互運用性モデルは、前述の第1の場合と同様である、と定義文書は、独自に開発し、メタデータサーバ、ストレージデバイス、およびクライアント間の相互運用性を保証すべきです。"
    },
    {
      "indent": 3,
      "text": "o A control protocol is defined in a Standards Track document that meets the control protocol requirements for one of the existing layout types. In this case, the new document's job is to assure interoperability between metadata servers and storage devices developed separately. The existing definition document for the selected layout type retains the function of assuring interoperability between clients and a given collection of metadata servers and storage devices. In this context, implementations that implement the new protocol are treated in the same way as those that use an internal control protocol or a functional equivalent.",
      "ja": "O制御プロトコルは、既存のレイアウトの種類のいずれかのための制御プロトコル要件を満たす標準化過程文書で定義されています。この場合、新しい文書の仕事は別々に開発メタデータサーバとストレージデバイス間の相互運用性を保証することです。選択されたレイアウトタイプの既存の定義文書は、クライアントとメタデータサーバとストレージデバイスの指定されたコレクション間の相互運用性を確保する機能を保持しています。この文脈において、新しいプロトコルを実装する実装は、内部制御プロトコルまたはその機能的等価物を使用するものと同じ方法で処理されます。"
    },
    {
      "indent": 3,
      "text": "An example of this last case is the SCSI layout type [RFC8154], which extends the block layout type. The block layout type had a requirement for fencing of clients but did not present a way for the control protocol (in this case, the SCSI storage protocol) to fence the client. The SCSI layout type remedies that in [RFC8154] and, in effect, has a tightly coupled model.",
      "ja": "この最後の場合の例は、ブロックレイアウトタイプを拡張SCSIレイアウトタイプ[RFC8154]です。ブロックレイアウトのタイプは、クライアントのフェンシングのための要件が​​あったが、フェンスにクライアント（この場合は、SCSIストレージプロトコルで）制御プロトコルのための方法を提示していませんでした。 [RFC8154]であり、実際には、密結合モデルを有することSCSIレイアウト型の救済。"
    },
    {
      "indent": 0,
      "text": "3.1. Control Protocol Requirements",
      "section_title": true,
      "ja": "3.1。制御プロトコルの要件"
    },
    {
      "indent": 3,
      "text": "The requirements of interactions between the metadata server and the storage devices are:",
      "ja": "メタデータサーバとストレージデバイス間の相互作用の要件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "(1) The metadata server MUST be able to service the client's I/O requests if the client decides to make such requests to the metadata server instead of to the storage device. The metadata server must be able to retrieve the data from the constituent storage devices and present it back to the client. A corollary to this is that even though the metadata server has successfully given the client a layout, the client MAY still send I/O requests to the metadata server.",
      "ja": "クライアントではなく、ストレージデバイスへのメタデータ・サーバに、このような要求を行うことを決定した場合（1）メタデータ・サーバは、クライアントのI / O要求に対応することができなければなりません。メタデータサーバは、構成のストレージデバイスからデータを取得し、クライアントにそれを提示できなければなりません。これまで当然の結果は、メタデータサーバが正常にクライアントにレイアウトを与えているにもかかわらず、クライアントがメタデータサーバへのI / O要求を送信かもしれないということです。"
    },
    {
      "indent": 3,
      "text": "(2) The metadata server MUST be able to restrict access to a file on the storage devices when it revokes a layout. The metadata server typically would revoke a layout whenever a client fails to respond to a recall or a client's lease is expired due to non-renewal. It might also revoke the layout as a means of enforcing a change in locking state or access permissions that the storage device cannot directly enforce.",
      "ja": "（2）メタデータサーバは、レイアウトを取り消したときに、ストレージデバイス上のファイルへのアクセスを制限することができなければなりません。クライアントは、クライアントのリースが原因非更新に有効期限が切れているか、リコールへの応答に失敗したときに、メタデータ・サーバは、一般的なレイアウトを取り消すでしょう。また、記憶装置が直接適用することができないロック状態またはアクセス権の変更を強制する手段としてレイアウトを取り消すかもしれません。"
    },
    {
      "indent": 8,
      "text": "Effective revocation may require client cooperation in using a\nparticular stateid (file layout) or principal (e.g., flexible\nfile layout) when performing I/O.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "In contrast, there is no requirement to restrict access to a file on the storage devices when a layout is recalled. It is only after the metadata server determines that the client is not gracefully returning the layout and starts the revocation that this requirement is enforced.",
      "ja": "これとは対照的に、レイアウトがリコールされたストレージデバイス上のファイルへのアクセスを制限する必要はありません。これは、メタデータサーバは、クライアントが優雅なレイアウトを返していないと判断すると、この要件が適用され、失効を開始した後のみです。"
    },
    {
      "indent": 3,
      "text": "(3) A pNFS implementation MUST NOT allow the violation of NFSv4.1's access controls: Access Control Lists (ACLs) and file open modes. Section 12.9 of [RFC5661] specifically lays this burden on the combination of clients, storage devices, and the metadata server. However, the specification of the individual layout type might create requirements as to how this is to be done. This may include a possible requirement for the metadata server to update the storage device so that it can enforce security.",
      "ja": "（3）AのpNFSの実装は、NFSv4.1のアクセス制御に違反許してはなりません：アクセス制御リスト（ACL）を、オープンモードを提出します。 [RFC5661]のセクション12.9には、特にこのクライアントの組み合わせの負担、ストレージデバイス、およびメタデータ・サーバを産みます。しかし、個々のレイアウトタイプの仕様では、これを実行する方法などの要件を作成することができます。これは、セキュリティを強化できるように、ストレージデバイスを更新するメタデータサーバのための可能な要件を含むことができます。"
    },
    {
      "indent": 8,
      "text": "The file layout requires the storage device to enforce access\nwhereas the flexible file layout requires both the storage\ndevice and the client to enforce security.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(4) Interactions between locking and I/O operations MUST obey existing semantic restrictions. In particular, if an I/O operation would be invalid when directed at the metadata server, it is not to be allowed when performed on the storage device.",
      "ja": "（4）ロックおよびI / O操作の間の相互作用は、既存の意味上の制限に従わなければなりません。具体的には、メタデータサーバに向けられたときにI / O操作が無効であるならば、そうではない記憶装置上で実行するとき許可します。"
    },
    {
      "indent": 8,
      "text": "For the block and SCSI layouts, as the storage device is not\nable to reject the I/O operation, the client is responsible for\nenforcing this requirement.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(5) Any disagreement between the metadata server and the data server as to the value of attributes such as modify time, the change attribute, and the EOF position MUST be of limited duration with clear means of resolution of any discrepancies being provided. Note the following:",
      "ja": "（5）メタデータサーバと、時間、変化属性を変更するなどの属性の値としてデータサーバ、および矛盾の解決の明確な手段を限られた期間でなければならないEOF位置との間の任意の不一致が設けられています。次の点に注意してください。"
    },
    {
      "indent": 8,
      "text": "(a)  Discrepancies need not be resolved unless any client has\n     accessed the file in question via the metadata server,\n     typically by performing a GETATTR.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(b) A particular storage device might be striped, and as such, its local view of the EOF position does not match the global EOF position.",
      "ja": "（B）特定の記憶装置は、ストライプされるかもしれない、そのようなものとして、EOFの位置のローカルビューは、グローバルEOFの位置と一致していません。"
    },
    {
      "indent": 8,
      "text": "(c) Both clock skew and network delay can lead to the metadata server and the storage device having different values of the time attributes. As long as those differences can be accounted for in what is presented to the client in a GETATTR, then no violation results.",
      "ja": "（c）のクロック・スキューとネットワーク遅延の両方がメタデータサーバと時間属性の異なる値を有する記憶装置をもたらすことができます。限り、これらの違いは、その後違反の結果、GETATTRにクライアントに提示されたものの中に計上することはできないとして。"
    },
    {
      "indent": 8,
      "text": "(d) A LAYOUTCOMMIT requires that changes in attributes resulting from operations on the storage device need to be reflected in the metadata server by the completion of the operation.",
      "ja": "（D）LAYOUTCOMMITは、記憶装置の操作に起因する属性の変化が動作の完了により、メタデータサーバに反映させる必要があることが必要です。"
    },
    {
      "indent": 3,
      "text": "These requirements may be satisfied in different ways by different layout types. As an example, while the file layout type uses the stateid to fence off the client, there is no requirement that other layout types use this stateid approach.",
      "ja": "これらの要件は、異なるレイアウトの種類によって異なる方法で満足することができます。ファイルレイアウトの種類がクライアントオフフェンスへのstateidを使用しながら、一例として、他のレイアウトタイプは、このアプローチのstateidを使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Each new Standards Track document for a layout type MUST address how the client, metadata server, and storage devices are to interact to meet these requirements.",
      "ja": "レイアウトタイプのそれぞれの新しい標準化過程文書は、クライアント、メタデータサーバ、およびストレージデバイスは、これらの要件を満たすために相互作用するどのように対処しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Previously Undocumented Protocol Requirements",
      "section_title": true,
      "ja": "3.2。以前は文書化されていないプロトコル要件"
    },
    {
      "indent": 3,
      "text": "While not explicitly stated as requirements in Section 12 of [RFC5661], the existing layout types do have more requirements that they need to enforce.",
      "ja": "明示的に[RFC5661]のセクション12の要求事項として明記されていないが、既存のレイアウトタイプは、彼らが施行する必要があるより多くの要件があります。"
    },
    {
      "indent": 3,
      "text": "The client has these obligations when making I/O requests to the storage devices:",
      "ja": "ストレージデバイスへのI / O要求を行うときに、クライアントは、これらの義務があります。"
    },
    {
      "indent": 3,
      "text": "(1) Clients MUST NOT perform I/O to the storage device if they do not have layouts for the files in question.",
      "ja": "彼らは問題のファイルのためのレイアウトを持っていない場合（1）クライアントは、ストレージデバイスへのI / Oを実行してはなりません。"
    },
    {
      "indent": 3,
      "text": "(2) Clients MUST NOT perform I/O operations outside of the specified ranges in the layout segment.",
      "ja": "（2）クライアントがレイアウト・セグメント内の指定された範囲外でI / O操作を実行してはいけません。"
    },
    {
      "indent": 3,
      "text": "(3) Clients MUST NOT perform I/O operations that would be inconsistent with the iomode specified in the layout segments it holds.",
      "ja": "（3）クライアントは、それが保持するレイアウト・セグメントに指定IOModeにと矛盾することになるI / O操作を実行してはいけません。"
    },
    {
      "indent": 3,
      "text": "Under the file layout type, the storage devices are able to reject any request made not conforming to these requirements. This may not be possible for other known layout types, which puts the burden of enforcing such violations solely on the client. For these layout types:",
      "ja": "ファイルのレイアウトタイプの下では、ストレージデバイスは、これらの要件に適合しない作られたすべての要求を拒否することができます。これは単に、クライアント上で、このような違反行為を強制する負担を置く他の既知のレイアウトタイプ、のためにできない場合があります。これらのレイアウト・タイプの場合："
    },
    {
      "indent": 3,
      "text": "(1) The metadata server MAY use fencing operations to the storage devices to enforce layout revocation against the client.",
      "ja": "（1）メタデータサーバは、クライアントに対するレイアウト失効を強制するためにストレージデバイスにフェンシング操作を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "(2) The metadata server MUST allow the clients to perform data I/O against it, even if it has already granted the client a layout. A layout type might discourage such I/O, but it cannot forbid it.",
      "ja": "（2）メタデータサーバは、クライアントが、それはすでにクライアントにレイアウトを付与している場合でも、それに対してデータのI / Oを実行できるようにしなければなりません。レイアウトの種類は、このようなI / Oを阻止かもしれないが、それはそれを禁止することはできません。"
    },
    {
      "indent": 3,
      "text": "(3) The metadata server MUST be able to do storage allocation, whether that is to create, delete, extend, or truncate files.",
      "ja": "（3）メタデータサーバはそれが作成、削除、拡張、またはファイルを切り捨てるかどうかを、ストレージの割り当てを行うことができなければなりません。"
    },
    {
      "indent": 3,
      "text": "The means to address these requirements will vary with the layout type. A control protocol will be used to effect these; the control protocol could be a purpose-built one, one identical to the storage protocol, or a new Standards Track control protocol.",
      "ja": "これらの要件に対処するための手段は、レイアウトの種類によって異なります。制御プロトコルは、これらを行うために使用されます。制御プロトコルは、専用の1、ストレージ・プロトコル、または新しい標準化過程の制御プロトコルと同一のいずれかになります。"
    },
    {
      "indent": 0,
      "text": "3.3. Editorial Requirements",
      "section_title": true,
      "ja": "3.3。社説要件"
    },
    {
      "indent": 3,
      "text": "This section discusses how the protocol requirements discussed above need to be addressed in documents specifying a new layout type. Depending on the interoperability model for the layout type in question, this may involve the imposition of layout-type-specific requirements that ensure appropriate interoperability of pNFS components that are developed separately.",
      "ja": "このセクションでは、上述のプロトコル要件は、新しいレイアウトタイプを指定する文書に対処する必要があります方法について説明します。問題のレイアウトタイプのための相互運用性のモデルに応じて、これは別々に開発されているのpNFSコンポーネントの適切な相互運用性を確保するため、レイアウト型固有の要件を課すことを含むことができます。"
    },
    {
      "indent": 3,
      "text": "The specification of the layout type needs to make clear how the client, metadata server, and storage device act together to meet the protocol requirements discussed previously. If the document does not impose implementation requirements sufficient to ensure that these semantic requirements are met, it is not appropriate for publication as an RFC from the IETF stream.",
      "ja": "クライアント、メタデータサーバ、およびストレージ・デバイスの行為は一緒に前に述べたプロトコル要件を満たすためにどのようにレイアウトタイプの仕様は明確にする必要があります。文書は、これらのセマンティック要件が満たされていることを保証するのに十分な実装要件を課していない場合、それはIETFストリームからRFCとして公表のために適切ではありません。"
    },
    {
      "indent": 3,
      "text": "Some examples include:",
      "ja": "いくつかの例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the metadata server does not have a means to invalidate a stateid issued to the storage device to keep a particular client from accessing a specific file, then the layout type specification has to document how the metadata server is going to fence the client from access to the file on that storage device.",
      "ja": "メタデータサーバは、特定のファイルへのアクセスを特定のクライアントを維持するためにストレージデバイスに発行されたstateidを無効にする手段を持っていない場合は、O、その後、レイアウトタイプ仕様は、メタデータサーバがアクセスからフェンスにクライアントを起こっているか文書化する必要がありますそのストレージデバイス上のファイルへ。"
    },
    {
      "indent": 3,
      "text": "o If the metadata server implements mandatory byte-range locking when accessed directly by the client, then the layout type specification must require that this also be done when data is read or written using the designated storage protocol.",
      "ja": "メタデータサーバは、クライアントから直接アクセス必須のバイト範囲ロックを実装する場合、O、次いでレイアウトタイプ指定は、データを読み取る、または指定された記憶プロトコルを使用して書かれている場合、これはまた、行われることを必要としなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Specifications of Original Layout Types",
      "section_title": true,
      "ja": "元のレイアウト・タイプの4仕様"
    },
    {
      "indent": 3,
      "text": "This section discusses how the original layout types interact with Section 12 of [RFC5661], which enumerates the requirements of pNFS layout type specifications. It is not normative with regards to the file layout type presented in Section 13 of [RFC5661], the block layout type [RFC5663], and the object layout type [RFC5664]. These are discussed here only to illuminate the updates Section 3 of this document makes to Section 12 of [RFC5661].",
      "ja": "このセクションでは、元のレイアウトタイプはpNFSのレイアウトタイプ仕様の要件を列挙します[RFC5661]のセクション12、と対話する方法について説明します。それは、[RFC5661]のセクション13に提示ファイルレイアウトタイプ、ブロックレイアウトタイプ[RFC5663]、およびオブジェクトのレイアウトタイプ[RFC5664]へに関して規範的ではありません。これらは、このドキュメントの更新第3節は、[RFC5661]のセクション12になり照らすためにここで説明されています。"
    },
    {
      "indent": 0,
      "text": "4.1. File Layout Type",
      "section_title": true,
      "ja": "4.1。ファイルのレイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "Because the storage protocol is a subset of NFSv4.1, the semantics of the file layout type comes closest to the semantics of NFSv4.1 in the absence of pNFS. In particular, the stateid and principal used for I/O MUST have the same effect and be subject to the same validation on a data server as it would have if the I/O were being performed on the metadata server itself. The same set of validations are applied whether or not pNFS is in effect.",
      "ja": "ストレージプロトコルはNFSv4.1のサブセットであるため、ファイルのレイアウトタイプのセマンティクスはpNFSの非存在下でのNFSv4.1の意味に最も近いです。具体的には、I / Oのために使用されるのstateidと主は同じ効果を有していなければならず、それがI / Oは、メタデータサーバ自体で実行された場合であろうように、データサーバ上の同じ検証の対象となります。検証の同じセットは、pNFSのが有効であるか否かが適用されます。"
    },
    {
      "indent": 3,
      "text": "While for most implementations, the storage devices can do the following validations that are each presented as a \"SHOULD\" and not a \"MUST\" in [RFC5661]:",
      "ja": "ほとんどの実装のための一方で、ストレージデバイスは、それぞれ「SHOULD」ではなく、[RFC5661]で「MUST」として提示されている以下の検証を行うことができます。"
    },
    {
      "indent": 3,
      "text": "(1) client holds a valid layout,",
      "ja": "（1）クライアントは有効なレイアウトを保持し、"
    },
    {
      "indent": 3,
      "text": "(2) client I/O matches the layout iomode, and",
      "ja": "（2）クライアントは、I / Oは、レイアウトIOModeにマッチし、"
    },
    {
      "indent": 3,
      "text": "(3) client does not go out of the byte ranges,",
      "ja": "（3）クライアントは、バイト範囲の外に出ていません、"
    },
    {
      "indent": 3,
      "text": "Actually, the first point is presented in [RFC5661] as both:",
      "ja": "実際、最初のポイントは両方として[RFC5661]に提示されています。"
    },
    {
      "indent": 3,
      "text": "\"MUST\": in Section 13.6",
      "ja": "\"MUST\"：セクション13.6で"
    },
    {
      "indent": 6,
      "text": "As described in Section 12.5.1, a client MUST NOT send an I/O to a data server for which it does not hold a valid layout; the data server MUST reject such an I/O.",
      "ja": "12.5.1項で説明したように、クライアントは、それが有効なレイアウトを保持していない対象のデータ・サーバへのI / Oを送ってはいけません。データ・サーバは、このようなI / Oを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"SHOULD\": in Section 13.8",
      "ja": "\"SHOULD\"：セクション13.8で"
    },
    {
      "indent": 6,
      "text": "The iomode need not be checked by the data servers when clients perform I/O. However, the data servers SHOULD still validate that the client holds a valid layout and return an error if the client does not.",
      "ja": "クライアントは、I / Oを実行するときIOModeには、データ・サーバによって確認される必要がありません。しかし、データ・サーバは、まだクライアントが有効なレイアウトを保持していることを検証し、クライアントがない場合はエラーを返すべきです。"
    },
    {
      "indent": 3,
      "text": "It should be noted that it is just these layout-specific checks that are optional, not the normal file access semantics. The storage devices MUST make all of the required access checks on each READ or WRITE I/O as determined by the NFSv4.1 protocol. If the metadata server would deny a READ or WRITE operation on a file due to its ACL, mode attribute, open access mode, open deny mode, mandatory byte-range locking state, or any other attributes and state, the storage device MUST also deny the READ or WRITE operation. Also, while the NFSv4.1 protocol does not mandate export access checks based on the client's IP address, if the metadata server implements such a policy, then that counts as such state as outlined above.",
      "ja": "単なるオプションであるこれらのレイアウト固有のチェックはなく、通常のファイルアクセスセマンティクスであることに留意すべきです。記憶装置は各READに必要なアクセスチェックのすべてを作るか、またはNFSv4.1プロトコルによって決定されるようなI / Oを書き込む必要があります。メタデータサーバは、そのACL、mode属性、オープンアクセスモードにファイルにREADまたはWRITE操作を拒否したい場合、オープンモード、必須バイト範囲ロック状態、または任意の他の属性と状態を否定し、ストレージデバイスも拒否しなければなりませんREADまたはWRITE操作。メタデータサーバは、このようなポリシーを実装している場合も、一方でNFSv4.1プロトコルは、上で概説したような状態としてカウントする、その後、クライアントのIPアドレスに基づいて輸出アクセスチェックを強制しません。"
    },
    {
      "indent": 3,
      "text": "The data filehandle provided by the PUTFH operation to the data server provides sufficient context to enable the data server to ensure that the client has a valid layout for the I/O being performed for the subsequent READ or WRITE operation in the compound.",
      "ja": "データ・サーバへPUTFH動作によって提供されるデータファイルハンドルは、クライアントが、化合物の後続のREADまたはWRITE動作のために実行されるI / Oのための有効な配置であることを保証するためにデータ・サーバを有効にするのに十分なコンテキストを提供します。"
    },
    {
      "indent": 3,
      "text": "Finally, the data server can check the stateid presented in the READ or WRITE operation to see if that stateid has been rejected by the metadata server; if so, the data server will cause the I/O to be fenced. Whilst it might just be the open owner or lock owner on that client being fenced, the client should take the NFS4ERR_BAD_STATEID error code to mean it has been fenced from the file and contact the metadata server.",
      "ja": "最後に、データ・サーバは、そののstateidは、メタデータサーバによって拒否されたかどうかを確認するためにREADまたはWRITE操作で提示したstateidを確認することができます。その場合、データ・サーバは、I / Oは、フェンスで囲まれることになります。それだけで囲われているクライアント上で開いて所有者またはロック所有者である可能性がある一方で、クライアントは、ファイルからフェンスとメタデータサーバーに接続されたことを意味するNFS4ERR_BAD_STATEIDエラーコードを取る必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Block Layout Type",
      "section_title": true,
      "ja": "4.2。ブロックレイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "With the block layout type, the storage devices are generally not able to enforce file-based security. Typically, storage area network (SAN) disk arrays and SAN protocols provide coarse-grained access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), with a target granularity of disks rather than individual blocks and a source granularity of individual hosts rather than of users or owners. Access to block storage is logically at a lower layer of the I/O stack than NFSv4. Since NFSv4 security is not directly applicable to protocols that access such storage directly, Section 2.1 of [RFC5663] specifies that:",
      "ja": "ブロックレイアウトタイプを用いて、記憶装置は、一般的に、ファイルベースのセキュリティを強化することができません。典型的には、ストレージエリアネットワーク（SAN）ディスクアレイとSANプロトコルは、ディスクではなく、個々のブロックの目標粒度とソース粒度で、粗粒度のアクセス制御メカニズム（例えば、論理ユニット番号（LUN）マッピング及び/又はマスキング）を提供します個々のホストのではなく、ユーザーまたは所有者の。ブロック・ストレージへのアクセスが可能なNFSv4よりI / Oスタックの下層に論理的です。 NFSv4のセキュリティは、直接そのようなストレージにアクセスプロトコルに直接適用できないので、[RFC5663]のセクション2.1はそれを指定します。"
    },
    {
      "indent": 6,
      "text": "in environments where pNFS clients cannot be trusted to enforce such policies, pNFS block layout types SHOULD NOT be used.",
      "ja": "pNFSのクライアントは、このようなポリシーを適用するために信頼することができない環境では、pNFSのブロックレイアウトのタイプを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Due to these granularity issues, the security burden has been shifted from the storage devices to the client. Those deploying implementations of this layout type need to be sure that the client implementation can be trusted. This is not a new sort of requirement in the context of SAN protocols. In such environments, the client is expected to provide block-based protection.",
      "ja": "これらの粒度の問題のために、セキュリティの負担は、クライアントへのストレージデバイスからシフトされています。このレイアウトタイプのものを導入する実装は、クライアントの実装が信頼できることを確認する必要があります。これは、SANプロトコルの文脈における要件の新しいソートではありません。このような環境では、クライアントは、ブロックベースの保護を提供することが期待されます。"
    },
    {
      "indent": 3,
      "text": "This shift of the burden also extends to locks and layouts. The storage devices are not able to enforce any of these, and the burden is pushed to the client to make the appropriate checks before sending I/O to the storage devices. For example, the server may use a layout iomode only allowing reading to enforce a mandatory read-only lock. In such cases, the client has to support that use by not sending WRITEs to the storage devices. The fundamental issue here is that the storage device is treated by this layout type in the same fashion as a local disk device. Once the client has access to the storage device, it is able to perform both READ and WRITE I/O to the entire storage device. The byte ranges in the layout, any locks, the layout iomode, etc., can only be enforced by the client. Therefore, the client is required to provide that enforcement.",
      "ja": "負担のこのシフトはまた、ロックやレイアウトにも及びます。ストレージデバイスは、これらのいずれかを強制することはできません、と負担は、ストレージデバイスへのI / Oを送信する前に適切なチェックを行うために、クライアントにプッシュされます。例えば、サーバはIOModeにのみ必須の読み取り専用ロックを強制する読取可能なレイアウトを使用してもよいです。このような場合には、クライアントは、ストレージ・デバイスへの書き込みを送信しないことにより、その使用をサポートする必要があります。ここでの基本的な問題は、ストレージデバイスがローカルディスクデバイスと同じ方法で、このレイアウトタイプによって処理されていることです。クライアントは、ストレージデバイスへのアクセスを持っていたら、両方のREADを実行し、全体のストレージデバイスへのI / Oを書き込むことができます。等のレイアウト、すべてのロック、レイアウトIOModeに、内バイト範囲は、クライアントのみによって強制することができます。そのため、クライアントは、その執行を提供するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "In the context of fencing off of the client upon revocation of a layout, these limitations come into play again, i.e., the granularity of the fencing can only be at the level of the host and logical unit. Thus, if one of a client's layouts is revoked by the server, it will effectively revoke all of the client's layouts for files located on the storage units comprising the logical volume. This may extend to the client's layouts for files in other file systems. Clients need to be prepared for such revocations and reacquire layouts as needed.",
      "ja": "レイアウトの失効時のクライアントのオフフェンシングの文脈では、これらの制限は、すなわち、フェンシングの粒度のみホスト論理ユニットのレベルであることができる、再び遊びに来ます。クライアントのレイアウトのいずれかがサーバーによって取り消される場合、それは効果的に論理ボリュームを備えたストレージユニット上にあるファイルのためのクライアントのレイアウトのすべてを取り消すでしょう。これは、他のファイルシステム内のファイルを、クライアントのレイアウトに延長することができます。クライアントは、そのような取消しのために準備し、必要に応じてレイアウトを再取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Object Layout Type",
      "section_title": true,
      "ja": "4.3。オブジェクトのレイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "With the object layout type, security checks occur during the allocation of the layout. The client will typically ask for layouts covering all of the file and may do so for either READ or READ/WRITE. This enables it to do subsequent I/O operations without the need to obtain layouts for specific byte ranges. At that time, the metadata server should verify permissions against the layout iomode, the file mode bits or ACLs, etc. As the client may be acting for multiple local users, it MUST authenticate and authorize the user by issuing respective OPEN and ACCESS calls to the metadata server, similar to having NFSv4 data delegations.",
      "ja": "オブジェクトのレイアウトタイプと、セキュリティチェックは、レイアウトの割り当ての際に起こります。クライアントは通常、ファイルのすべてをカバーするレイアウトを尋ねてきますし、READまたはREAD / WRITEのいずれかのためにそうすることがあります。これは、特定のバイト範囲のためのレイアウトを取得する必要がなく、後続のI / O操作を行うには、それを可能にします。その時に、メタデータサーバは、クライアントが複数のローカルユーザーのために行動することができるとして、それはそれぞれのOPENを発行してユーザーを認証し、認可しなければならないなどのレイアウトIOModeに、ファイルモードビットまたはACLは、反対の権限を確認する必要があり、アクセスがへの呼び出しNFSv4のデータ代表団を持つに似てメタデータサーバ、。"
    },
    {
      "indent": 3,
      "text": "Upon successful authorization, the client receives within the layout a set of object capabilities allowing it I/O access to the specified objects corresponding to the requested iomode. These capabilities are used to enforce access control and locking semantics at the storage devices. Whenever one of the following occurs on the metadata server, then the metadata server MUST change the capability version attribute on all objects comprising the file in order to invalidate any outstanding capabilities before committing to one of these changes:",
      "ja": "認証が成功すると、クライアントは、レイアウト内で要求されたIOModeに対応する指定されたオブジェクトへのI / Oアクセス許可オブジェクト機能のセットを受け取ります。これらの機能は、ストレージデバイスのアクセス制御とロックセマンティクスを強制するために使用されています。次のいずれかが、メタデータサーバ上で発生するたびに、その後、メタデータサーバは、これらの変化のいずれかにコミットする前に、未処理の機能を無効にするために、ファイルを構成するすべてのオブジェクトに対する機能のバージョン属性を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "o the permissions on the object change,",
      "ja": "オブジェクト変更の権限O、"
    },
    {
      "indent": 3,
      "text": "o a conflicting mandatory byte-range lock is granted, or",
      "ja": "競合必須バイト範囲ロックが付与され、O、または"
    },
    {
      "indent": 3,
      "text": "o a layout is revoked and reassigned to another client.",
      "ja": "Oレイアウトが取り消され、別のクライアントに再割り当てされます。"
    },
    {
      "indent": 3,
      "text": "When the metadata server wishes to fence off a client to a particular object, then it can use the above approach to invalidate the capability attribute on the given object. The client can be informed via the storage device that the capability has been rejected and is allowed to fetch a refreshed set of capabilities, i.e., reacquire the layout.",
      "ja": "メタデータサーバは、特定のオブジェクトへのクライアントオフフェンスしようとするとき、それは指定されたオブジェクトで能力属性を無効にするには、上記のアプローチを使用することができます。クライアントは、機能が拒否されたと、能力のリフレッシュセットをフェッチすなわち、レイアウトを再取得することが許可されているストレージデバイスを介して通知することができます。"
    },
    {
      "indent": 0,
      "text": "5. Summary",
      "section_title": true,
      "ja": "5.まとめ"
    },
    {
      "indent": 3,
      "text": "In the three original layout types, the burden of enforcing the security of NFSv4.1 can fall to either the storage devices (files), the client (blocks), or the metadata server (objects). Such choices are conditioned by the native capabilities of the storage devices -- if a control protocol can be implemented, then the burden can be shifted primarily to the storage devices.",
      "ja": "3元のレイアウトのタイプでは、NFSv4.1のセキュリティを強化するの負担は、ストレージ・デバイス（ファイル）、クライアント（ブロック）、またはメタデータサーバ（オブジェクト）のいずれかに落ちることができます。そのような選択は、ストレージ・デバイスのネイティブ機能によって調整されている - 制御プロトコルを実装することができれば、その負担はストレージデバイスに主にシフトさせることができます。"
    },
    {
      "indent": 3,
      "text": "In the context of this document, we treat the control protocol as a set of requirements. As new layout types are published, the defining documents MUST address:",
      "ja": "この文書の文脈において、我々は、要件のセットのような制御プロトコルを扱います。新しいレイアウトタイプが公開されると、定義する文書が対処しなければなりません："
    },
    {
      "indent": 3,
      "text": "(1) The fencing of clients after a layout is revoked.",
      "ja": "（1）レイアウト後のクライアントのフェンシングが取り消されます。"
    },
    {
      "indent": 3,
      "text": "(2) The security implications of the native capabilities of the storage devices with respect to the requirements of the NFSv4.1 security model.",
      "ja": "（2）NFSv4.1セキュリティモデルの要求に対するストレージ装置のネイティブ機能のセキュリティへの影響。"
    },
    {
      "indent": 3,
      "text": "In addition, these defining documents need to make clear how other semantic requirements of NFSv4.1 (e.g., locking) are met in the context of the proposed layout type.",
      "ja": "また、これらの定義文書はNFSv4.1の明確な方法を他のセマンティック要件（例えば、ロック）を提案したレイアウトタイプのコンテキストで満たされているを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section does not deal directly with security considerations for existing or new layout types. Instead, it provides a general framework for understating security-related issues within the pNFS framework. Specific security considerations will be addressed in the Security Considerations sections of documents specifying layout types. For example, in Section 3 of [RFC5663], the lack of finer-than-physical disk access control necessitates that the client is delegated the responsibility to enforce the access provided to them in the layout extent that they were granted by the metadata server.",
      "ja": "このセクションでは、既存または新規のレイアウトタイプのセキュリティ上の考慮事項と直接取引しません。その代わりに、pNFSのフレームワーク内でセキュリティ関連の問題を過小ための一般的なフレームワークを提供します。特定のセキュリティの考慮事項は、レイアウトの種類を指定する文書のセキュリティの考慮事項のセクションで対処されます。例えば、[RFC5663]のセクション3で、細かい-よりも物理ディスクのアクセス制御の欠如は、クライアントがそれらをメタデータサーバによって付与されたことをレイアウト範囲で彼らに提供されるアクセスを強制する責任を委任されていることを必要とします。"
    },
    {
      "indent": 3,
      "text": "The layout type specification must ensure that only data access consistent with the NFSV4.1 security model is allowed. It may do this directly, by providing that appropriate checks be performed at the time each access is performed. It may do it indirectly by allowing the client or the storage device to be responsible for making the appropriate checks. In the latter case, I/O access rights are reflected in layouts, and the layout type must provide a way to prevent inappropriate access due to permissions changes between the time a layout is granted and the time the access is performed.",
      "ja": "レイアウトタイプ仕様NFSV4.1セキュリティモデルと一致するデータのみアクセスが許可されていることを確認する必要があります。これは、適切なチェックは、各アクセスが実行される時に実行されることを提供することによって、これを直接行うことができます。これは、クライアントまたはストレージデバイスは、適切なチェックを行うための責任があるようにすることによって、間接的にそれを行うことがあります。後者の場合には、I / Oアクセス権はレイアウトに反映され、レイアウトタイプによるレイアウトが許可された時間、アクセスが行われた時刻との間のアクセス許可の変更に不適切なアクセスを防止するための方法を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The metadata server MUST be able to fence off a client's access to the data file on a storage device. When it revokes the layout, the client's access MUST be terminated at the storage devices. The client has a subsequent opportunity to reacquire the layout and perform the security check in the context of the newly current access permissions.",
      "ja": "メタデータサーバは、フェンスオフストレージデバイス上のデータファイルへのクライアントのアクセスをすることができなければなりません。それは、レイアウトを取り消す場合は、クライアントのアクセスは、ストレージ・デバイスで終えなければなりません。クライアントは、レイアウトを再取得し、新たに現在のアクセス権限のコンテキストでセキュリティチェックを実行するために、後続の機会を持っています。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントには、IANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <https://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<https://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC5663] Black, D., Fridella, S., and J. Glasgow, \"Parallel NFS (pNFS) Block/Volume Layout\", RFC 5663, DOI 10.17487/RFC5663, January 2010, <https://www.rfc-editor.org/info/rfc5663>.",
      "ja": "[RFC5663]黒、D.、Fridella、S.、およびJ.グラスゴー、 \"パラレルNFS（pNFSの）ブロック/ボリュームレイアウト\"、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、<HTTPS：//www.rfc- editor.org/info/rfc5663>。"
    },
    {
      "indent": 3,
      "text": "[RFC5664] Halevy, B., Welch, B., and J. Zelenka, \"Object-Based Parallel NFS (pNFS) Operations\", RFC 5664, DOI 10.17487/RFC5664, January 2010, <https://www.rfc-editor.org/info/rfc5664>.",
      "ja": "[RFC5664] HALEVY、B.、ウェルチ、B.、およびJ.ゼレンカ、 \"オブジェクトベースのパラレルNFS（pNFSの）操作\"、RFC 5664、DOI 10.17487 / RFC5664、2010年1月、<HTTPS：//www.rfc- editor.org/info/rfc5664>。"
    },
    {
      "indent": 3,
      "text": "[RFC8154] Hellwig, C., \"Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout\", RFC 8154, DOI 10.17487/RFC8154, May 2017, <https://www.rfc-editor.org/info/rfc8154>.",
      "ja": "[RFC8154] Hellwigさん、C.、 \"パラレルNFS（pNFSの）小型コンピュータシステムインタフェース（SCSI）レイアウト\"、RFC 8154、DOI 10.17487 / RFC8154、2017年5月、<https://www.rfc-editor.org/info/ rfc8154>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Lustre] Faibish, S., Cote, D., and P. Tao, \"Parallel NFS (pNFS) Lustre Layout Operations\", Work in Progress, draft-faibish-nfsv4-pnfs-lustre-layout-07, May 2014.",
      "ja": "[光沢] Faibish、S.、コート、D.、およびP.タオ、 \"パラレルNFS（pNFSの）光沢レイアウト操作\"、プログレス、ドラフトfaibish-のNFSv4-pNFSの-光沢レイアウト-07、2014年5月に働いています。"
    },
    {
      "indent": 3,
      "text": "[RFC8435] Halevy, B. and T. Haynes, \"Parallel NFS (pNFS) Flexible File Layout\", RFC 8435, DOI 10.17487/RFC8435, August 2018, <https://www.rfc-editor.org/info/rfc8435>.",
      "ja": "[RFC8435] HALEVY、B.及びT.ヘインズ、 \"パラレルNFS（pNFSの）柔軟なファイルレイアウト\"、RFC 8435、DOI 10.17487 / RFC8435、2018年8月、<https://www.rfc-editor.org/info/rfc8435 >。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Dave Noveck provided an early review that sharpened the clarity of the definitions. He also provided a more comprehensive review of the document.",
      "ja": "デイブNoveckは、定義の明確さを削っ早期審査を提供しました。彼はまた、ドキュメントのより包括的な見直しを提供します。"
    },
    {
      "indent": 3,
      "text": "Both Chuck Lever and Christoph Helwig provided insightful comments during the working group last call.",
      "ja": "チャックレバーとクリストフHelwigの両方が、ワーキンググループの最後の通話中に洞察に満ちたコメントを提供しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Thomas Haynes Hammerspace 4300 El Camino Real Ste 105 Los Altos, CA 94022 United States of America",
      "ja": "トーマス・ヘインズHammerspace 4300エル・カミノレアルサントアメリカの105ロスアルトス、CA 94022米国"
    },
    {
      "indent": 3,
      "text": "Email: loghyr@gmail.com",
      "ja": "メール：loghyr@gmail.com"
    }
  ]
}