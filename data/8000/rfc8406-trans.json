{
  "title": {
    "text": "RFC 8406 - Taxonomy of Coding Techniques for Efficient Network Communications",
    "ja": "RFC 8406 - 効率的なネットワーク通信のためのコーディング手法の分類"
  },
  "number": 8406,
  "created_at": "2019-11-01 19:05:40.948991+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                           B. Adamson\nRequest for Comments: 8406                                           NRL\nCategory: Informational                                         C. Adjih\nISSN: 2070-1721                                                    INRIA\n                                                               J. Bilbao\n                                                                 Ikerlan\n                                                               V. Firoiu\n                                                             BAE Systems\n                                                               F. Fitzek\n                                                              TU Dresden\n                                                               S. Ghanem\n                                                             Independent\n                                                               E. Lochin\n                                                          ISAE - Supaero\n                                                              A. Masucci\n                                                                  Orange\n                                                          M-J. Montpetit\n                                                             Independent\n                                                             M. Pedersen\n                                                      Aalborg University\n                                                              G. Peralta\n                                                                 Ikerlan\n                                                            V. Roca, Ed.\n                                                                   INRIA\n                                                               P. Saxena\n                                                      AnsuR Technologies\n                                                            S. Sivakumar\n                                                                   Cisco\n                                                               June 2018",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Taxonomy of Coding Techniques for Efficient Network Communications",
      "ja": "効率的なネットワーク通信のためのコーディング手法の分類"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document summarizes recommended terminology for Network Coding concepts and constructs. It provides a comprehensive set of terms in order to avoid ambiguities in future IRTF and IETF documents on Network Coding. This document is the product of the Coding for Efficient Network Communications Research Group (NWCRG), and it is in line with the terminology used by the RFCs produced by the Reliable Multicast Transport (RMT) and FEC Framework (FECFRAME) IETF working groups.",
      "ja": "この文書では、ネットワークコーディングの概念と構築物について推奨用語をまとめています。これは、将来のIRTFとネットワークコーディング上のIETF文書であいまいさを避けるために、用語の包括的なセットを提供します。この文書では、効率的なネットワーク通信研究グループ（NWCRG）のためのコーディングの製品であり、それは信頼性の高いマルチキャストトランスポート（RMT）とFECフレームワーク（FECFRAME）IETFワーキンググループによって生成RFCで使用される用語に沿ったものです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Coding for Efficient Network Communications Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の効率的なネットワーク通信研究グループのためのコーディングのコンセンサスを表しています。 IRSGによって公表のために承認された文書はインターネットStandardのどんなレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8406.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8406で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  General Definitions and Concepts  . . . . . . . . . . . . . .   4\n3.  Taxonomy of Code Uses . . . . . . . . . . . . . . . . . . . .   7\n4.  Coding Details  . . . . . . . . . . . . . . . . . . . . . . .   8\n  4.1.  Coding Types  . . . . . . . . . . . . . . . . . . . . . .   8\n  4.2.  Coding Basics . . . . . . . . . . . . . . . . . . . . . .   9\n  4.3.  Coding in Practice  . . . . . . . . . . . . . . . . . . .  12\n5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  13\n7.  Informative References  . . . . . . . . . . . . . . . . . . .  13\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  14",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document is the product of and represents the collaborative work and consensus of the Coding for Efficient Network Communications Research Group (NWCRG); it is not an IETF product and is not a standard. In 2017, the document was discussed during three audio conferences, each of them gathering 6 to 8 key experts; it was co-edited and subjected to an RG Last Call. The general feeling was that the document was ready. Additional information about Network Coding may be found on these NWCRG pages: <https://irtf.org/nwcrg> and <https://datatracker.ietf.org/rg/nwcrg/about/>.",
      "ja": "この文書はの製品であり、効率的なネットワーク通信研究グループ（NWCRG）のためのコーディングの共同作業とコンセンサスを表し、それは、IETFの製品ではなく、標準ではありません。 2017年に、文書は、それらの各々は、8つのキー業者に6を集め、3回のオーディオ会議中に議論されました。それは、共同編集、RGラストコールを行いました。一般的な感覚は、文書が準備ができていたということでした。 <https://irtf.org/nwcrg>と<https://datatracker.ietf.org/rg/nwcrg/about/>：ネットワークコーディングに関する追加情報は、これらNWCRGページで見ることができます。"
    },
    {
      "indent": 3,
      "text": "The literature on Network Coding research and system design, including IETF documentation, led to a rich set of concepts and constructs. This document collects terminology used in the domain, both outside and inside IETF, provides concise definitions, and introduces a high-level taxonomy. Its primary goal is to be useful to IETF and IRTF activities. It is also in line with the terminology already used by the RFCs produced by the Reliable Multicast Transport (RMT) and FEC Framework (FECFRAME) IETF working groups, in particular [RFC5052], [RFC5740], [RFC5775], [RFC6363], and [RFC6726]. This document is also related to IETF work being done in the PAYLOAD and TSVWG WGs (in particular, the extension of FECFRAME to support Sliding Window Codes and the Random Linear Coding (RLC) sliding window FEC scheme) and past work in the AVTCORE and MMUSIC WGs. Note that in the definitions, the \"(IETF)\" tag indicates that the associated term is already used in IETF documents (Internet-Drafts and RFCs).",
      "ja": "IETF文書を含む研究とシステム設計を、ネットワークコーディングに関する文献は、概念や構造の豊富なセットにつながりました。この文書は、両方の外側と内側IETF、ドメイン内で使用される用語を収集する簡潔な定義を提供し、高レベルの分類を導入します。その主な目的は、IETFとIRTF活動に有用であることがあります。それは、[RFC5740]、[RFC5775]、[RFC6363]特定の[RFC5052]に、既に高信頼マルチキャストトランスポート（RMT）とFECフレームワーク（FECFRAME）IETFワーキンググループによって生成されるRFCで使用される用語と一致しても、そして、[RFC6726]。この文書はまた、AVTCORE及びMMUSICに、過去の仕事（（RLC）ウィンドウFECスキームをスライドコーディングスライディングウィンドウコードとランダムリニアをサポートするために、特に、FECFRAMEの拡張）IETFペイロードに行われている作業とTSVWGのWGに関連していますWG。定義では、「（IETF）」タグが関連付けられている用語はすでにIETF文書（インターネットドラフトおよびRFC）で使用されていることを示していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "This document focuses on packet transmissions and losses. These losses will typically be triggered by various types of networking issues and/or impairments (e.g., congested routers or intermittent wireless connectivity). The notion of \"packet\" itself is multiform, depending on the target use case and the notion of network (e.g., in which layer of the protocol stack does the coding middleware operate?). For instance, a \"packet\" may be a data unit to be carried as a UDP payload because the coding middleware is located between the application and UDP. In another configuration, coding may be applied within an overlay network and the notion of \"packet\" will be totally different. In any case, the goals of Network Coding can be to improve the network throughput, efficiency, latency, and scalability, as well as to provide resilience to partition, attacks, and eavesdropping (NWCRG charter). Both End-to-End Coding and systems that also perform recoding within intermediate forwarding nodes are considered in this document.",
      "ja": "この文書では、パケットの送信および損失に焦点を当てています。これらの損失は、典型的には、ネットワークの問題および/または障害（例えば、輻輳ルータまたは断続無線接続）の様々なタイプによってトリガされます。 「パケット」の概念自体は、ターゲットユースケース及びネットワークの概念に依存して、多形である（符号化ミドルウェアが動作しないプロトコルスタックのどの層に、例えば、？）。例えば、「パケット」は、コードミドルウェアは、アプリケーションとUDPとの間に配置されているため、UDPペイロードとして搬送されるデータユニットであってもよいです。別の構成では、コーディングは、オーバーレイ・ネットワーク内で適用することができると、「パケット」の概念は全く異なるものになります。いずれの場合においても、ネットワークコーディングの目標は、ネットワークスループット、効率、潜時、およびスケーラビリティを向上させるため、ならびにパーティション、攻撃、盗聴（NWCRGチャーター）に復元力を提供することができます。両方のエンドツーエンドのコーディング及び中間転送ノード内で再符号行うシステムが本書で考慮されます。"
    },
    {
      "indent": 3,
      "text": "This document does not consider physical-layer transmission issues, physical-layer codes, or error detection: if low-layer error codes detect but fail to correct bit errors, or if an upper-layer checksum (e.g., within IP or UDP) identifies a corrupted packet, then the packet is supposed to be dropped.",
      "ja": "低レイヤのエラーコードが検出した場合が、ビットエラーを修正するために失敗する、または上位レイヤのチェックサム（例えば、IPまたはUDP内）を識別した場合：この文書では、物理層の送信の問題、物理レイヤコード、またはエラー検出を考慮していません破損したパケットは、パケットは廃棄されることになっています。"
    },
    {
      "indent": 0,
      "text": "2. General Definitions and Concepts",
      "section_title": true,
      "ja": "2.一般的な定義と概念"
    },
    {
      "indent": 3,
      "text": "This section provides general definitions and concepts that are used throughout this document.",
      "ja": "このセクションでは、この文書全体で使用されている一般的な定義や概念を提供します。"
    },
    {
      "indent": 3,
      "text": "Packet Erasure Channel: A communication path where packets are either dropped or received without any error. This type of packet drop is referred to as an \"erasure\" or \"loss\". The term \"channel\" must be understood as a generic term for any type of communication technology (e.g., an Ethernet link, a WiFi network, or a full path between two nodes over the Internet). As opposed to the \"Erasure\" channels, \"Error\" channels are where one or multiple bit errors may happen during a packet transmission. These \"Error\" channels are out of scope.",
      "ja": "パケット消失チャンネル：パケットがいずれかのエラーなしドロップまたは受信された通信経路。パケットドロップのこのタイプは、「消去」または「損失」と呼ばれます。用語「チャネル」は、通信技術の任意のタイプ（例えば、イーサネットリンク、WiFiネットワーク、又はインターネットを介して2つのノード間の完全なパス）の総称として理解されなければなりません。 「消去」チャネルとは対照的に、一つまたは複数のビットエラーがパケット伝送中に発生することができる場合、「エラー」チャネルです。これらの「エラー」のチャネルは範囲外です。"
    },
    {
      "indent": 3,
      "text": "Erasure Correcting Code (ECC) or (IETF) Forward Erasure Correction (FEC): A code for the Packet Erasure Channel (only). These codes are also called \"Application-Level FECs\" to highlight that they have been designed for use within the higher layers of the protocol stack to protect against packet losses. As opposed to ECCs/FECs, \"Error\" correction codes are capable of identifying the presence of bit errors and perhaps correcting them. The \"Error\" correction codes are out of scope.",
      "ja": "消失訂正コード（ECC）または（IETF）前方消失訂正（FEC）パケット消失チャネル（のみ）のためのコード。これらのコードはまた、彼らは、パケット損失から保護するために、プロトコル・スタックの上位層内に使用するために設計されていることを強調するために、「アプリケーションレベルのFEC」と呼ばれています。 ECC /のFECとは対照的に、「エラー」訂正符号は、ビットエラーの存在を識別し、おそらくそれらを補正することが可能です。 「エラー」訂正符号は、範囲外です。"
    },
    {
      "indent": 3,
      "text": "End-to-End Coding: A system where coding is performed at the source or (coding) middlebox, and decoding is performed at the destination(s) or (decoding) middlebox. There is no recoding operation at intermediate nodes. This is the approach followed in the FLUTE/ALC [RFC6726] [RFC5775], NORM [RFC5740], and FECFRAME [RFC6363] protocols.",
      "ja": "エンドツーエンドの符号化：符号化はソースまたは（コーディング）ミドルボックスで行われ、そしてデコードが先（S）または（復号化）ミドルボックスで実行されるシステム。中間ノードでは何も再符号化操作はありません。このアプローチは、FLUTE / ALC [RFC6726]、[RFC5775]、NORM [RFC5740]、およびFECFRAME [RFC6363]プロトコルに続いています。"
    },
    {
      "indent": 3,
      "text": "Network Coding: A system where coding can be performed at the source as well as at intermediate forwarding nodes (all or a subset of them). End-to-End Coding is regarded as a special case of Network Coding. Depending on the use case, additional assumptions can be made: for instance, the destination knowing the Coding Nodes' topology and coding operations can help during decoding operations.",
      "ja": "ネットワーク符号化：符号化方式は、ソースにおいて、ならびに中間転送ノード（すべて又はそれらのサブセット）で行うことができます。エンドツーエンドのコーディングは、ネットワークコーディングの特殊なケースとみなされています。ユースケースによっては、追加的な仮定を行うことができます。例えば、送信先は、符号化ノードのトポロジーを知り、コーディング操作が操作をデコードする時に役立ちます。"
    },
    {
      "indent": 3,
      "text": "Packet versus Symbol: Generally speaking, a Packet is the unit of data that is sent in the Packet Erasure Channel, while a Symbol is the unit of data that is manipulated during the encoding and decoding operations.",
      "ja": "シンボル対パケット：一般的に、パケットは、シンボルが符号化及び復号化動作中に操作されるデータの単位であるが、パケット消失チャネルで送信されるデータの単位です。"
    },
    {
      "indent": 3,
      "text": "Original Payload, Uncoded Payload, Systematic Symbol, or (IETF) Source Symbol: A unit of data originating from the source that is used as input to encoding operations.",
      "ja": "元のペイロード、符号化されていないペイロード、系統的記号、または（IETF）ソースシンボル：操作をコードへの入力として使用されているソースに由来するデータの単位。"
    },
    {
      "indent": 3,
      "text": "Coded Payload, Coded Symbol, or (IETF) Repair Symbol: A unit of data that is the result of a coding operation, applied either to Source Symbols or (in case of recoding) Source and/or Repair Symbols. When there is a single Repair Symbol per Repair Packet, a Repair Symbol corresponds to a Repair Packet.",
      "ja": "符号化ペイロード、符号化シンボル、または（IETF）の修復シンボル：符号化演算の結果であるデータの単位は、ソースシンボルまたはソースおよび/または修復シンボル（再符号化の場合）のいずれかを適用しました。修復パケットごとに単一のリペアシンボルが存在する場合、修復シンボルは、修復パケットに相当します。"
    },
    {
      "indent": 3,
      "text": "Input Symbol and Output Symbol: A unit of data that is used as input to an encoding operation or that is generated as output of an encoding operation. At a recoding node, Repair Symbols are also part of the Input Symbols. With Systematic Coding, Source Symbols are also part of the Output Symbols.",
      "ja": "入力シンボルと出力シンボル：符号化処理への入力として使用されるか、またはそれは、符号化操作の出力として生成されるデータの単位。再符号化ノードでは、リペアシンボルも、入力シンボルの一部です。体系的なコーディングで、ソースシンボルはまた、出力シンボルの一部です。"
    },
    {
      "indent": 3,
      "text": "(IETF) Encoding Symbol: A Source or a Repair Symbol.",
      "ja": "（IETF）符号化シンボル：ソースまたは修復シンボル。"
    },
    {
      "indent": 3,
      "text": "(En)coding versus Recoding versus Decoding: (En)coding is an operation that takes Source Symbols as input and produces Encoding Symbols as output. Recoding is an operation that takes Encoding Symbols as input and produces Encoding Symbols as output. Decoding is an operation takes Encoding Symbols as input and produces Source Symbols as output.",
      "ja": "（JA）復号対リコーディング対コーディング：（JA）符号化入力としてソースシンボルを受け取り、出力として符号化シンボルを生成する操作です。再符号化は、入力として符号化シンボルを受け取り、出力として符号化シンボルを生成する操作です。復号化は、操作が入力として符号化シンボルを受け取り、出力としてソースシンボルを生成しています。"
    },
    {
      "indent": 3,
      "text": "(IETF) Source Packet: A packet originating from the source that contributes to one or more Source Symbols. For instance, an RTP packet as a whole can constitute a Source Symbol. In other situations (e.g., to address variable size packets), a single RTP packet may contribute to various Source Symbols.",
      "ja": "（IETF）ソースパケット：一つ以上のソースシンボルに寄与するソースから発信パケット。例えば、全体としてRTPパケットは、ソースシンボルを構成することができます。他の状況（例えば、可変サイズのパケットに対処するため）に、単一のRTPパケットは、様々なソースシンボルに寄与し得ます。"
    },
    {
      "indent": 3,
      "text": "(IETF) Repair Packet: A packet containing one or more Repair Symbols.",
      "ja": "（IETF）の修復パケット：一つ以上のリペアシンボルを含むパケット。"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates the relationships between packets (what is sent in the Packet Erasure Channel) and symbols (what is manipulated during encoding and decoding operations) in case of a Systematic",
      "ja": "図1は、体系の場合には（符号化および復号化動作中に操作されたもの）のパケット（パケット消失チャネルで送信されたもの）とシンボル間の関係を示し"
    },
    {
      "indent": 3,
      "text": "Coding at a Coding Node that performs Encoding (rather than Recoding). FEC decoding procedures are similarly performed in the reverse order.",
      "ja": "（むしろリコーディングより）符号化を行う符号化ノードでコーディング。 FEC復号手順は同様に逆の順序で実行されています。"
    },
    {
      "indent": 3,
      "text": "        Source Packet\n              |\n              | Source Packet to Source Symbols transform\n              | (one or more symbols per packet)\n              v\n        Source Symbols\n              |\n              v Input Symbols\n   +----------------------+\n   |     FEC encoding     |\n   +----------------------+\n      | Output Symbols |\n      v                v\nSource Symbols   Repair Symbols\n      |                |\n      |                | symbol-to-packet transform\n      |                | (one or more symbols per packet)\n      v                v\nSource Packet    Repair Packet",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 1: Packet and Symbol Relationships at a Coding Node That Performs Encoding (Rather Than Recoding)",
      "ja": "図1：パケットと符号化を行う符号化ノードのシンボルの関係（むしろよりリコーディング）"
    },
    {
      "indent": 3,
      "text": "Source Node: A node that generates one or more Source Flows.",
      "ja": "ソース・ノード：1つ以上のソース・フローを生成したノード。"
    },
    {
      "indent": 3,
      "text": "Coding Node: A node that performs FEC Encoding or Recoding operations. It may be an end host or a middlebox (Encoding case), or a forwarding node (Recoding case).",
      "ja": "符号化ノード：FEC符号化またはリコーディング操作を実行するノード。これは、エンドホストまたはミドル（エンコーディング場合）、又は転送ノード（リコーディングの場合）であってもよいです。"
    },
    {
      "indent": 3,
      "text": "(IETF) Flow: A stream of packets logically grouped.",
      "ja": "（IETF）フロー：パケットのストリームは、論理的にグループ化されました。"
    },
    {
      "indent": 3,
      "text": "(IETF) Source Flow: A flow of Source Packets coming from an application on a given host and to which FEC encoding is to be applied, potentially along with other Source Flows. Depending on the use case, Source Flows may come from the same application, from different applications on the same host, or from different applications on different hosts.",
      "ja": "（IETF）ソースフロー：ソースパケットのフローが与えられたホスト上のアプリケーションから来てFEC符号化には、潜在的に他のソース・フローと共に、適用されます。ユースケースによっては、ソース・フローは、同じアプリケーションから、同じホスト上の異なるアプリケーションから、または異なるホスト上の別のアプリケーションから来るかもしれません。"
    },
    {
      "indent": 3,
      "text": "(IETF) Repair Flow: A flow containing Repair Packets after FEC encoding.",
      "ja": "FEC符号化の後にリペアパケットを含む流れ（IETF）の流れを修復。"
    },
    {
      "indent": 0,
      "text": "3. Taxonomy of Code Uses",
      "section_title": true,
      "ja": "コードの使用方法の3分類"
    },
    {
      "indent": 3,
      "text": "This section discusses the various ways of using coding, without going into coding details.",
      "ja": "このセクションでは、コーディングの詳細に行くことなく、コーディングを使用してのさまざまな方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Source Coding versus Channel Coding: (see Figure 2) When both terms are used, \"Source Coding\" usually refers to compression techniques (e.g., audio and video compression) within the upper application that generates the Source Flow. \"Channel Coding\" refers to FEC encoding in order to improve transmission robustness, for instance, within the lower physical layer (out of scope of this document) or as part of Network Coding. These terms should not be confused with \"FEC coding within the Source Node\" and \"FEC recoding within an intermediate Coding Node\", respectively.",
      "ja": "チャネルコーディング対ソース符号化（図2参照）両方の用語は、「ソースコーディング」が使用される通常のソース・フローを生成する上位アプリケーション内圧縮技術（例えば、オーディオ及びビデオ圧縮）を意味します。 「チャネル符号化」（この文書の範囲外）下位の物理層内またはネットワークコーディングの一部として、例えば、送信ロバスト性を向上させるためにFEC符号化を指します。これらの用語は、それぞれ、「ソースノード内のFEC符号化」と「中間コーディングノード内のFEC再コーディング」と混同してはなりません。"
    },
    {
      "indent": 3,
      "text": "raw data flow from camera     ^              video flow display\n            |                 |                      ^\n            v                 | upper                |\n+------------------------+    |           +-------------------------+\n|     source coding      |    | applica-  |  source (de)coding      |\n|(e.g., mpeg compression)|    | tion      |(e.g., mpg decompression)|\n+------------------------+    v           +-------------------------+\n            |                                        ^\n            v                                        |\n+------------------------+    ^           +-------------------------+\n| network/AL-FEC coding  |    | middle-   | network/AL-FEC coding   |\n|  (e.g., RLC encoding)  |    | ware      |  (e.g., RLC decoding)   |\n+------------------------+    v           +-------------------------+\n            |                                        ^\n            v                                        |\n+------------------------+    ^           +-------------------------+\n|     packetization      |    |           |    depacketization      |\n|     (e.g., UDP/IP)     |    | communi-  |     (e.g., UDP/IP)      |\n+------------------------+    | cation    +-------------------------+\n            |                 |                      ^\n            v                 | layers               |\n+-----------------------+     |           +-------------------------+\n|       PHY layer       |     |           |       PHY layer         |\n|    (channel coding)   |     |           |   (channel decoding)    |\n+-----------------------+     v           +-------------------------+\n            |                                         ^\n            |          source + repair traffic        |\n            +-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2: Example of End-to-End Flow Manipulation with Network Coding",
      "ja": "図2：ネットワークコーディングを用いたエンド・ツー・エンドのフロー操作の例"
    },
    {
      "indent": 6,
      "text": "Figure 2 shows Network Coding between the application and UDP layers (as with RMT or FECFRAME architectures). Other architectures are possible, for instance, with Network Coding below the transport layer to allow recoding within the network.",
      "ja": "図2は、ネットワーク（RMT又はFECFRAMEアーキテクチャと同様に）アプリケーションとUDPレイヤ間コーディング示します。他のアーキテクチャは、ネットワークがネットワーク内の再符号化を可能にするために、トランスポート層の下コーディングで、例えば、可能です。"
    },
    {
      "indent": 3,
      "text": "Intra-Flow Coding or Single-Source Network Coding: Process where incoming packets to the Coding Node belong to the same flow.",
      "ja": "コーディング・ノードへの着信パケットは、同じフローに属しているプロセス：イントラフローコーディングまたはシングルソースネットワークコーディング。"
    },
    {
      "indent": 3,
      "text": "Inter-Flow Coding or Multi-Source Network Coding: Process where incoming packets to the Coding Node belong to different flows.",
      "ja": "インターフローは、コーディングやマルチソースネットワークコーディング：コーディング・ノードへの着信パケットが異なるフローに属しているプロセス。"
    },
    {
      "indent": 3,
      "text": "Single-Path Coding: Network Coding over a route that has a single path from the source to each destination(s). In case of multicast or broadcast traffic, this route is a tree. Coding may be done end to end and/or at intermediate forwarding nodes.",
      "ja": "シングルパスコーディング：ネットワークは、各宛先（複数の）ソースから単一経路を有する経路上でコーディング。マルチキャストまたはブロードキャストトラフィックの場合、このルートはツリーです。符号化はエンドツーエンドで行わおよび/または中間転送ノードでもよいです。"
    },
    {
      "indent": 3,
      "text": "Multi-Path Coding: Network Coding over a route that has multiple (at least partially) disjoint paths from the source to each given destination. Coding may be done end to end and/or at intermediate forwarding nodes.",
      "ja": "マルチパスコーディング：ネットワークは、各所定のソースから宛先への複数（少なくとも部分的に）互いに素な経路を有する経路上にコーディング。符号化はエンドツーエンドで行わおよび/または中間転送ノードでもよいです。"
    },
    {
      "indent": 0,
      "text": "4. Coding Details",
      "section_title": true,
      "ja": "4.コーディング詳細"
    },
    {
      "indent": 0,
      "text": "4.1. Coding Types",
      "section_title": true,
      "ja": "4.1。符号化タイプ"
    },
    {
      "indent": 3,
      "text": "This section provides a high-level taxonomy of coding techniques. Technical details are discussed in subsequent sections.",
      "ja": "このセクションでは、符号化技術の高レベルの分類を提供します。技術的な詳細は、以降のセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "Linear Coding: Linear combination of a set of Input Symbols (i.e., Source and/or Repair Symbols) using a given set of coefficients and resulting in a Repair Symbol. Many linear codes exist that differ from the way coding coefficients are drawn from a Finite Field of a given size.",
      "ja": "線形コーディング：入力記号（すなわち、ソース及び/又は修復シンボル）係数の所与のセットを使用して修復シンボルをもたらすのセットの線形結合。係数符号化方法とは異なる多くの線形符号が存在する所定の大きさの有限フィールドから引き出されます。"
    },
    {
      "indent": 3,
      "text": "Random Linear Coding (RLC): Particular case of Linear Coding using a set of random coding coefficients.",
      "ja": "ランダム線形符号化（RLC）：リニアランダム符号化係数のセットを用いて符号化の特定の場合。"
    },
    {
      "indent": 3,
      "text": "Adaptive Linear Coding: Linear Coding that utilizes cross-layer adaptation. For instance, an adaptive coding scheme may adapt the generation and transmission of Repair Packets according to the channel variations over time, accounting for the predictive loss of degrees of freedom due to erasures.",
      "ja": "アダプティブリニアコーディング：クロスレイヤ適応を利用リニアコーディングを。例えば、適応符号化方式が原因消去に自由度の予測損失を占め、時間をかけてチャネル変動に応じて修復パケットの生成及び送信を適応させることができます。"
    },
    {
      "indent": 3,
      "text": "Block Coding: Coding technique where the input Flow(s) must first be segmented into a sequence of blocks; FEC encoding and decoding are performed independently on a per-block basis. The term \"Chunk Coding\" is sometimes used, where a \"Chunk\" denotes a block.",
      "ja": "ブロック符号化：入力フロー（s）は最初のブロックのシーケンスに分割されなければならない符号化技術。 FEC符号化および復号化はブロック単位で独立して行われます。 「チャンク」は、ブロックを表す用語「コーディングチャンク」は、時々、使用されています。"
    },
    {
      "indent": 3,
      "text": "Sliding Window Coding or Convolutional Coding: General class of coding techniques that rely on a sliding encoding window. This is an alternative solution to Block Coding.",
      "ja": "ウィンドウコーディングまたは畳み込み符号化をスライディング：スライディングエンコードウィンドウに依存している符号化技術の一般的なクラスを。これは、ブロック符号化するための代替ソリューションです。"
    },
    {
      "indent": 3,
      "text": "Fixed or Elastic Sliding Window Coding: Coding technique that generates Repair Symbol(s) on the fly, from the set of Source Symbols present in the sliding encoding window at that time, usually by using Linear Coding. The sliding window may be either of fixed size or of variable size over the time (also known as \"Elastic Sliding Window\"). For instance, the size may depend on acknowledgments sent by the receiver(s) for a particular Source Symbol or Source Packet (received, decoded, or decodable).",
      "ja": "固定された弾性スライディングウィンドウ符号化：符号化技法通常、コード線形を用いてその時のスライディングコードウィンドウ内に存在するソースシンボルの集合から、その場で修復シンボル（S）を生成します。スライディングウィンドウは、（また、「弾性スライディングウィンドウ」としても知られる）、経時固定サイズまたは可変サイズのいずれであってもよいです。例えば、サイズは、特定のソースシンボルまたはソースパケットのための受信機（単数または複数）によって送信された肯定応答に依存してもよい（受信、復号化、または復号可能）。"
    },
    {
      "indent": 3,
      "text": "Systematic Coding: A coding technique where Source Symbols are part of the output Flow generated by a Coding Node.",
      "ja": "系統的コーディング：ソースシンボルは、符号化ノードによって生成された出力の流れの一部である符号化技術。"
    },
    {
      "indent": 3,
      "text": "Rateless and Non-rateless Coding: Rateless Coding can generate an unlimited number of Repair Symbols (in practice, this number can be limited by practical considerations or because of use-case requirements) from a given set of Source Symbols, meaning that the code rate is null. RLC codes are an example of Rateless Codes. Alternately, Non-rateless Coding usually has a predefined maximum number of Repair Symbols that can be generated from a given set of Source Symbols.",
      "ja": "レートレスおよび非レートレスコーディング：レートレスはリペアシンボルを無制限に生成することができますコーディングコードレートつまり、ソースシンボルの特定のセットから（実際には、この数は、実用性を考慮するか、理由はユースケースの要件を制限することができます）無効である。 RLCコードは、レートレスコードの一例です。あるいは、非レートレス符号化は、通常、ソースシンボルの所定のセットから生成することができるリペアシンボルの所定の最大数を有します。"
    },
    {
      "indent": 0,
      "text": "4.2. Coding Basics",
      "section_title": true,
      "ja": "4.2。基本コーディング"
    },
    {
      "indent": 3,
      "text": "This section discusses and defines low-level coding aspects.",
      "ja": "このセクションでは、低レベルの符号化態様を説明し、定義します。"
    },
    {
      "indent": 3,
      "text": "Code Rate: In case of a Block Code, the Code Rate is the k/n ratio between the number of Source Symbols, k, and the number of Source plus Repair Symbols, n. With a Sliding Window Code, the Code Rate is defined similarly over a certain time interval, since the Code Rate may change dynamically. By definition, the Code Rate is such that: 0 < Code Rate <= 1. A Code Rate close to 1 indicates that a small number of Repair Symbols have been produced during the encoding process and vice versa.",
      "ja": "コードレート：ブロックコードの場合、コードレートは、ソースシンボルの数、K、ソースプラスリペアシンボルの数との間のK / N比であり、n。コードレートを動的に変更することができるので、スライディングウィンドウコードと、コードレートは、一定の時間間隔で同様に定義されます。 0 <コードレート<1 = 1のAコードレート閉じるリペアシンボルの数が少ない符号化プロセスおよびその逆の間に生産されていることを示している：定義によって、コードレートようなものです。"
    },
    {
      "indent": 3,
      "text": "(En)coding Window: A set of Source (and Repair in the case of recoding) Symbols used as input to the coding operations. The set of symbols will typically change over time, as the Coding Window slides over the input Flow(s).",
      "ja": "（JA）コードウィンドウ：（再符号化の場合と修理）ソースのセット符号化操作への入力として使用されるシンボル。シンボルのセットは、典型的には、入力フロー（S）上コーディングウィンドウスライドとして、時間の経過とともに変化します。"
    },
    {
      "indent": 3,
      "text": "(En)coding Window Size: The number of Source (and Repair in case of recoding) Symbols in the current Encoding Window. This size may change over the time.",
      "ja": "（JA）符号化ウィンドウのサイズ：現在の符号化ウインドウのソースの数（及び再符号化の場合には修復が）シンボル。このサイズは、時間の経過とともに変化することがあります。"
    },
    {
      "indent": 3,
      "text": "Payload Set: The set of Source and Repair Symbols available (i.e., received or previously decoded) at the receiver and used during FEC decoding operations.",
      "ja": "ペイロードセット：受信機で（即ち、受信されたか、以前に復号可能）とFEC復号動作中に使用されるソースおよびリペアシンボルのセット。"
    },
    {
      "indent": 3,
      "text": "Decoding Window: The set of Source Symbols (only) that are considered in the current linear system of a receiver, independently of the fact these Source Symbols have been received, decoded, or lost. The Decoding Window will typically change over time, as transmissions and decoding progress, and may be different for different receivers of a session where content is multicast or broadcast.",
      "ja": "復号ウィンドウ：（のみ）受信機の現在の線形システムで考慮されるソースシンボルの組は、独立して実際のこれらのソースシンボルは、復号化、受信された、または失われています。復号化ウィンドウは、典型的には、送信および復号化の進行として、時間とともに変化し、コンテンツをマルチキャストまたはブロードキャストであるセッションの異なる受信機のために異なっていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Decoding Window Size: The number of Source Symbols (only) in the current Decoding Window. This size may change over time.",
      "ja": "デコードウィンドウのサイズ：現在の復号ウィンドウのソースシンボル（のみ）の数。このサイズは、時間の経過とともに変化することがあります。"
    },
    {
      "indent": 3,
      "text": "Rank of a Payload Set or Rank of the Linear System: At a receiver, number of linearly independent members of a Payload Set, or equivalently the number of linearly independent equations of the linear system. It is also known as \"Degrees of Freedom\". The system may be of \"full rank\" where decoding is possible or \"partial rank\" where only partial decoding is possible.",
      "ja": "線形システムのペイロードセット又はランクの順位：受信、ペイロードセットの線形独立のメンバーの数、又は等価的に線形システムの線形独立な方程式の数で。また、「運動自由度」として知られています。システムは、復号化が可能であるか、または一部のみ復号化が可能である「部分ランク」「フルランク」であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Seen Payload or Seen Symbol: A Source Symbol is Seen when the receiver can compute a linear combination with this symbol and Source Symbols that are strictly more recent (i.e., with logically higher Encoding Symbol Identifiers). Otherwise, the Source Symbol is considered as \"Unseen\".",
      "ja": "見ペイロードか見記号：受信機は、厳密に、より最近の（すなわち、論理的に高い符号化シンボル識別子を持つ）され、このシンボルとソースシンボルとの線形結合を計算することができたときに、ソースシンボルが見られています。それ以外の場合は、ソースシンボルは、「目に見えない」と考えられています。"
    },
    {
      "indent": 3,
      "text": "Generation or (IETF) Block: With Block Codes, the set of Source Symbols of the input Flow(s) that are logically grouped into a Block, before doing encoding.",
      "ja": "世代または（IETF）ブロック：ブロック符号、論理的にエンコーディングを行う前に、ブロックにグループ化された入力フロー（複数可）のソースシンボルのセットで。"
    },
    {
      "indent": 3,
      "text": "Generation Size, Code Dimension, or (IETF) Block Size: With Block Codes, the number of Source Symbols, k, belonging to a Block.",
      "ja": "世代のサイズ、コード寸法、または（IETF）ブロックサイズ：ブロック符号、ソースシンボルの数、Kで、ブロックに属します。"
    },
    {
      "indent": 3,
      "text": "Coding Matrix or Generator Matrix: A matrix G that transforms the set of Input Symbols X into a set of Repair Symbols: Y = X * G. Defining a Generator Matrix is typical with Block Codes. The set of Input Symbols X can consist only of Source Symbols (e.g., with End-to-End Coding) or can consist of Source and Repair Symbols (e.g., with recoding in an intermediate node).",
      "ja": "ジェネレータ行列はブロック符号を有する典型的である定義Y = X * G.：リペアシンボルのセットに入力シンボルXの集合を変換行列G：マトリックスまたはジェネレータマトリックスコード。入力シンボルのセットは、Xは、OR（中間ノードに再符号化して、例えば、）ソースおよびリペアシンボルで構成することができる（エンドツーエンドコーディングと例えば、）のみソースシンボルを構成することができます。"
    },
    {
      "indent": 3,
      "text": "Coding Coefficient: With Linear Coding, this is a coefficient in a certain Finite Field. This coefficient may be chosen in different ways: for instance, randomly, in a predefined table, or using a predefined algorithm plus a seed.",
      "ja": "係数をコーディング：リニアコーディングでは、これは、特定の有限フィールドにおける係数です。事前定義されたテーブルに、ランダムに、例えば、若しくは所定のアルゴリズムに加えてシードを使用してこの係数は、様々な方法で選択することができます。"
    },
    {
      "indent": 3,
      "text": "Coding Vector: A set of Coding Coefficients used to generate a certain Repair Symbol through Linear Coding. The number of nonzero coefficients in the Coding Vector defines its density.",
      "ja": "コーディングベクトル：リニアコードを介して特定の修復シンボルを生成するために使用される符号化係数のセット。コーディングベクトル内の非ゼロ係数の数は、その密度を規定します。"
    },
    {
      "indent": 3,
      "text": "Finite Field, Galois Field, or Coding Field: Finite Fields, used in Linear Codes, have the desired property of having all elements (except zero) invertible for the + and * operators, and all operations over any elements do not result in an overflow or underflow. Examples of Finite Fields are prime fields {0..p^m-1}, where p is prime. The most used fields use p=2 and are called binary extension fields {0..2^m-1}, where m often equals 1, 4, or 8 for practical reasons.",
      "ja": "有限体、ガロア体、またはフィールドコーディング：線形符号で使用される有限体は、+及び*オペレータの可逆（ゼロを除く）のすべての要素を有する所望の特性を有する、任意の要素上すべての操作は、オーバーフローを生じませんまたはアンダーフロー。有限体の例としては、pが素数である素体{0..p ^ M-1}です。最も使用されるフィールドは、p = 2を使用し、mはしばしば実用的な理由から、1、4、または8に等しいバイナリ拡張フィールド{0..2 ^ M-1}と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Finite Field size or Coding Field size: The number of elements in a Finite Field. For example, the binary extension field {0..2^m-1} has size q=2^m.",
      "ja": "有限体サイズまたはコードフィールドサイズ：有限体の要素数。例えば、バイナリ拡張フィールド{0..2 ^ M-1} = 2 ^ MサイズQを有しています。"
    },
    {
      "indent": 3,
      "text": "Feedback: Feedback information sent by a decoding node to a Coding Node (or from a receiver to a source in case of End-to-End Coding). The nature of information contained in a feedback packet varies, depending on the use case. It can provide reception and/or FEC decoding statistics, the list of available Source Packets received or decoded (acknowledgement), the list of lost Source Packets that should be retransmitted (negative acknowledgement), or a number of additional Repair Symbols needed to have a Full Rank Linear System.",
      "ja": "フィードバック：コーディングノードに復号化ノードによって送信されたフィードバック情報（または受信機からのEnd-to-Endの符号化の場合のソースに）。フィードバックパケットに含まれる情報の性質は、ユースケースに応じて、変化します。これは、受信および/またはFEC復号統計情報を提供することができ、利用可能なソースパケットのリストは、（承認）再送されるべきで失われたSourceパケットのリスト（否定応答）、または持っているために必要な追加のリペアシンボルの数を受信またはデコードフルランク線形システム。"
    },
    {
      "indent": 0,
      "text": "4.3. Coding in Practice",
      "section_title": true,
      "ja": "4.3。実際にコーディング"
    },
    {
      "indent": 3,
      "text": "This section discusses practical aspects. Indeed, a practical solution must specify the exact manner in which encoding and decoding are performed but also detail all the peripheral aspects, for instance, how an encoder informs a decoder about the parameters used to generate a certain Repair Packet (signaling).",
      "ja": "このセクションでは、実用的な側面について説明します。実際には、現実的な解決策は、正確な符号化及び復号化が実行される方法だけでなく、詳細すべての周辺の側面を指定する必要があり、例えば、どのエンコーダが特定の修復パケット（シグナリング）を生成するために使用されるパラメータについてデコーダに通知します。"
    },
    {
      "indent": 3,
      "text": "(IETF) FEC Scheme: A specification that defines a particular FEC code as well as the additional protocol aspects required to use this FEC code. In particular, the FEC Scheme defines in-band (e.g., information contained in Source and Repair Packet header or trailers) and out-of-band (e.g., information contained in an SDP description) signaling needed to synchronize encoders and decoders.",
      "ja": "（IETF）FECスキーム：特定のFEC符号、ならびにこのFECコードを使用するために必要な追加のプロトコルの態様を定義する仕様。具体的には、FECスキームは、帯域内（例えば、情報ソースに含まれる修復パケットヘッダ又はトレーラ）と帯域外（例えば、SDP記述に含まれる情報）はエンコーダおよびデコーダを同期させるために必要なシグナリングを定義します。"
    },
    {
      "indent": 3,
      "text": "Payload Index or (IETF) Encoding Symbol Identifier (ESI): An identifier of a Source or Repair Symbol. With Block Coding, each symbol of a given block is identified by a unique ESI value. With Sliding Window Coding, a continuous Source Flow and a limited field size to hold the ESI, wrapping to zero is unavoidable and the same integer value will be reused several times.",
      "ja": "ペイロードインデックスまたは（IETF）符号化シンボル識別子（ESI）：ソースの識別子または記号を修復します。ブロック符号化を用いて、与えられたブロックの各シンボルは、一意のESIの値により識別されます。ウィンドウコーディング、連続フローソースおよびESIを保持するための限られたフィールドサイズをスライドして、ゼロにラップすることは不可避であり、同じ整数値が数回再利用されます。"
    },
    {
      "indent": 3,
      "text": "(IETF) FEC Payload ID: Information that identifies the contents of a packet with respect to the FEC Scheme. The FEC Payload ID of a packet containing Source Symbol(s) is usually different from that of a packet containing Repair Symbol(s). The FEC Payload ID typically contains at least an ESI.",
      "ja": "（IETF）FECペイロードID：FECスキームに対するパケットの内容を特定する情報。ソースシンボルを含むパケットのFECペイロードID（複数可）修理記号（複数可）を含むパケットとは通常異なっています。 FECペイロードIDは、典型的には少なくともESIが含まれています。"
    },
    {
      "indent": 3,
      "text": "Coding Vector and Encoding Window Signaling: With Sliding Window Codes, the FEC Payload ID of a Repair Packet contains information needed and sufficient to identify the Coding Vector and Coding Window. Concerning the Coding Vector, this may consist of a full list of Coding Coefficients (that may or may not be compressed), or a piece of information (e.g., a seed) that can be used to generate the list of Coding Coefficients thanks to a predefined algorithm known by encoders and decoders (e.g., a Pseudorandom Number Generator, or PRNG) or an ESI that points to a given entry in a Generator Matrix in case of a Block Code. Concerning the Coding Window, this may consist of the full list of ESI of symbols in the Coding Window (that may or may not be compressed) or the ESI of the first Source Symbol along with their number (assuming there is no gap).",
      "ja": "ベクトルとエンコーディングウィンドウシグナリングコーディング：スライディングウィンドウコードで、修復パケットのFECペイロードIDは、情報必要とコードベクトルとコード・ウィンドウを識別するのに十分含ま。コーディングベクトルについて、これは符号化係数の完全なリスト（それはまたは圧縮してもしなくてもよい）、または情報のピースからなっていてもよい（例えば、種子）に係数おかげコーディングのリストを生成するために使用することができますエンコーダおよびデコーダによって知られている所定のアルゴリズム（例えば、擬似乱数発生器、又はPRNG）またはブロック符号の場合に発生マトリックス中に与えられたエントリを指すESI。コーディングウィンドウについて、これはその数とともにコーディングウィンドウ内のシンボルのESI（即ち、または圧縮してもしなくてもよい）、または最初のソースシンボルのESIの完全なリストからなっていてもよい（仮定隙間がありません）。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントには、IANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document introduces a recommended terminology for Network Coding and therefore does not contain any security considerations. This does not mean that Network Coding systems do not have any security implication.",
      "ja": "このドキュメントは、セキュリティ上の考慮事項が含まれていないため、ネットワークコーディングのための推奨用語を紹介します。これは、ネットワークコーディングシステムは、任意のセキュリティ意味を持っていないことを意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "7. Informative References",
      "section_title": true,
      "ja": "7.参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, DOI 10.17487/RFC5052, August 2007, <https://www.rfc-editor.org/info/rfc5052>.",
      "ja": "[RFC5052]ワトソン、M.、ルビー、M.、およびL. Vicisano、 \"前方誤り訂正（FEC）ビルディングブロック\"、RFC 5052、DOI 10.17487 / RFC5052、2007年8月、<HTTPS：//www.rfc-editor .ORG /情報/ rfc5052>。"
    },
    {
      "indent": 3,
      "text": "[RFC5740] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"NACK-Oriented Reliable Multicast (NORM) Transport Protocol\", RFC 5740, DOI 10.17487/RFC5740, November 2009, <https://www.rfc-editor.org/info/rfc5740>.",
      "ja": "[RFC5740]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 \"NACK指向高信頼マルチキャスト（NORM）トランスポートプロトコル\"、RFC 5740、DOI 10.17487 / RFC5740、2009年11月<HTTPS： //www.rfc-editor.org/info/rfc5740>。"
    },
    {
      "indent": 3,
      "text": "[RFC5775] Luby, M., Watson, M., and L. Vicisano, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", RFC 5775, DOI 10.17487/RFC5775, April 2010, <https://www.rfc-editor.org/info/rfc5775>.",
      "ja": "[RFC5775]ルビー、M.、ワトソン、M.、およびL. Vicisano、 \"非同期階層コーディング（ALC）プロトコルのインスタンス化\"、RFC 5775、DOI 10.17487 / RFC5775、2010年4月<HTTPS：//www.rfc-editor .ORG /情報/ rfc5775>。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, DOI 10.17487/RFC6363, October 2011, <https://www.rfc-editor.org/info/rfc6363>.",
      "ja": "[RFC6363]ワトソン、M.、Begen、A.、およびV.ロカ、 \"前方誤り訂正（FEC）フレームワーク\"、RFC 6363、DOI 10.17487 / RFC6363、2011年10月、<HTTPS：//www.rfc-editor。組織/情報/ rfc6363>。"
    },
    {
      "indent": 3,
      "text": "[RFC6726] Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen, \"FLUTE - File Delivery over Unidirectional Transport\", RFC 6726, DOI 10.17487/RFC6726, November 2012, <https://www.rfc-editor.org/info/rfc6726>.",
      "ja": "[RFC6726] Paila、T.、ウォルシュ、R.、ルビー、M.、ロカ、V.、およびR. Lehtonenの、 \"FLUTE  - 単方向トランスポート上でファイル配信\"、RFC 6726、DOI 10.17487 / RFC6726、2012年11月、< https://www.rfc-editor.org/info/rfc6726>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Adamson NRL United States of America",
      "ja": "アメリカのブライアン・アダムソンNRL米国"
    },
    {
      "indent": 3,
      "text": "Email: brian.adamson@nrl.navy.mil",
      "ja": "メール：brian.adamson@nrl.navy.mil"
    },
    {
      "indent": 3,
      "text": "Cedric Adjih INRIA France",
      "ja": "セドリックAdjih INRIAフランス"
    },
    {
      "indent": 3,
      "text": "Email: cedric.adjih@inria.fr",
      "ja": "メール：cedric.adjih@inria.fr"
    },
    {
      "indent": 3,
      "text": "Josu Bilbao Ikerlan Spain",
      "ja": "Josuビルバオ研究スペイン"
    },
    {
      "indent": 3,
      "text": "Email: jbilbao@ikerlan.es",
      "ja": "メール：jbilbao@ikerlan.es"
    },
    {
      "indent": 3,
      "text": "Victor Firoiu BAE Systems United States of America",
      "ja": "アメリカのビクターFiroiu BAEシステムズ米国"
    },
    {
      "indent": 3,
      "text": "Email: victor.firoiu@baesystems.com",
      "ja": "メール：victor.firoiu@baesystems.com"
    },
    {
      "indent": 3,
      "text": "Frank Fitzek TU Dresden Germany",
      "ja": "フランクFitzek TUドレスデンドイツ"
    },
    {
      "indent": 3,
      "text": "Email: frank.fitzek@tu-dresden.de",
      "ja": "メール：frank.fitzek@tu-dresden.de"
    },
    {
      "indent": 3,
      "text": "Samah A. M. Ghanem Independent",
      "ja": "Samah A. M.ガーネム独立"
    },
    {
      "indent": 3,
      "text": "Email: samah.ghanem@gmail.com",
      "ja": "メール：samah.ghanem@gmail.com"
    },
    {
      "indent": 3,
      "text": "Emmanuel Lochin ISAE - Supaero France",
      "ja": "Supaeroフランス - エマニュエルはIsaevを過ごしました"
    },
    {
      "indent": 3,
      "text": "Email: emmanuel.lochin@isae-supaero.fr",
      "ja": "メール：emmanuel.lochin@isae-supaero.fr"
    },
    {
      "indent": 3,
      "text": "Antonia Masucci Orange France",
      "ja": "アントニアMasucciオレンジフランス"
    },
    {
      "indent": 3,
      "text": "Email: antoniamaria.masucci@orange.com",
      "ja": "メール：antoniamaria.masucci@orange.com"
    },
    {
      "indent": 3,
      "text": "Marie-Jose Montpetit Independent United States of America",
      "ja": "アメリカのマリー・ジョゼMontpetit独立米国"
    },
    {
      "indent": 3,
      "text": "Email: marie@mjmontpetit.com",
      "ja": "メール：marie@mjmontpetit.com"
    },
    {
      "indent": 3,
      "text": "Morten V. Pedersen Aalborg University Denmark",
      "ja": "モルテンV.ペデルセンオールボー大学、デンマーク"
    },
    {
      "indent": 3,
      "text": "Email: mvp@es.aau.dk",
      "ja": "メール：mvp@es.aau.dk"
    },
    {
      "indent": 3,
      "text": "Goiuri Peralta Ikerlan Spain",
      "ja": "ペラルタGoiuri研究スペイン"
    },
    {
      "indent": 3,
      "text": "Email: gperalta@ikerlan.es",
      "ja": "メール：gperalta@ikerlan.es"
    },
    {
      "indent": 3,
      "text": "Vincent Roca (editor) INRIA France",
      "ja": "ヴィンセントロカ（エディタ）INRIAフランス"
    },
    {
      "indent": 3,
      "text": "Email: vincent.roca@inria.fr",
      "ja": "メール：vincent.roca@inria.fr"
    },
    {
      "indent": 3,
      "text": "Paresh Saxena AnsuR Technologies Norway",
      "ja": "Paresh Saxenaマンスール・テクノロジーズノルウェー"
    },
    {
      "indent": 3,
      "text": "Email: paresh.saxena@ansur.es",
      "ja": "メール：paresh.saxena@ansur.es"
    },
    {
      "indent": 3,
      "text": "Senthil Sivakumar Cisco United States of America",
      "ja": "アメリカのSenthilさんシバクマーシスコ米国"
    },
    {
      "indent": 3,
      "text": "Email: ssenthil@cisco.com",
      "ja": "メール：ssenthil@cisco.com"
    }
  ]
}