{
  "title": {
    "text": "RFC 8290 - The Flow Queue CoDel Packet Scheduler and Active Queue Management Algorithm",
    "ja": "RFC 8290 - フローキューCODELパケットスケジューラおよびアクティブキュー管理アルゴリズム"
  },
  "number": 8290,
  "created_at": "2019-10-29 17:17:45.602700+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)            T. Hoeiland-Joergensen\nRequest for Comments: 8290                           Karlstad University\nCategory: Experimental                                       P. McKenney\nISSN: 2070-1721                              IBM Linux Technology Center\n                                                                 D. Taht\n                                                                Teklibre\n                                                               J. Gettys",
      "raw": true
    },
    {
      "indent": 60,
      "text": "  E. Dumazet\nGoogle, Inc.\nJanuary 2018",
      "raw": true
    },
    {
      "indent": 15,
      "text": "The Flow Queue CoDel Packet Scheduler and\n    Active Queue Management Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo presents the FQ-CoDel hybrid packet scheduler and Active Queue Management (AQM) algorithm, a powerful tool for fighting bufferbloat and reducing latency.",
      "ja": "このメモはFQ-CODELハイブリッドパケットスケジューラおよびアクティブキュー管理（AQM）アルゴリズム、bufferbloatを戦うし、待ち時間を短縮するための強力なツールを提供します。"
    },
    {
      "indent": 3,
      "text": "FQ-CoDel mixes packets from multiple flows and reduces the impact of head-of-line blocking from bursty traffic. It provides isolation for low-rate traffic such as DNS, web, and videoconferencing traffic. It improves utilisation across the networking fabric, especially for bidirectional traffic, by keeping queue lengths short, and it can be implemented in a memory- and CPU-efficient fashion across a wide range of hardware.",
      "ja": "FQ-CODELは、複数のフローからのパケットを混合し、ヘッドオブラインバーストトラフィックのブロッキングの影響を低減します。それは、このようなDNS、Web、およびビデオ会議トラフィックとして低レートトラフィックのためのアイソレーションを提供します。これは、短いキューの長さを保つことによって、特に双方向トラフィックのために、ネットワーク・ファブリック全体で利用率を向上させ、そしてそれは、ハードウェアの幅広いメモリ - とCPU効率の高い方式で実装することができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8290.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8290で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Conventions Used in This Document . . . . . . . . . . . .   4\n  1.2.  Terminology and Concepts  . . . . . . . . . . . . . . . .   5\n  1.3.  Informal Summary of FQ-CoDel  . . . . . . . . . . . . . .   5\n2.  CoDel . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n3.  Flow Queueing . . . . . . . . . . . . . . . . . . . . . . . .   7\n4.  The FQ-CoDel Scheduler  . . . . . . . . . . . . . . . . . . .   8\n  4.1.  Enqueue . . . . . . . . . . . . . . . . . . . . . . . . .   8\n    4.1.1.  Alternative Classification Schemes  . . . . . . . . .   9\n  4.2.  Dequeue . . . . . . . . . . . . . . . . . . . . . . . . .  10\n5.  Implementation Considerations . . . . . . . . . . . . . . . .  11\n  5.1.  Data Structures . . . . . . . . . . . . . . . . . . . . .  11\n  5.2.  Parameters  . . . . . . . . . . . . . . . . . . . . . . .  12\n    5.2.1.  Interval  . . . . . . . . . . . . . . . . . . . . . .  12\n    5.2.2.  Target  . . . . . . . . . . . . . . . . . . . . . . .  12\n    5.2.3.  Packet Limit  . . . . . . . . . . . . . . . . . . . .  13\n    5.2.4.  Quantum . . . . . . . . . . . . . . . . . . . . . . .  13\n    5.2.5.  Flows . . . . . . . . . . . . . . . . . . . . . . . .  13\n    5.2.6.  Explicit Congestion Notification (ECN)  . . . . . . .  14\n    5.2.7.  CE Threshold  . . . . . . . . . . . . . . . . . . . .  14\n  5.3.  Probability of Hash Collisions  . . . . . . . . . . . . .  14\n  5.4.  Memory Overhead . . . . . . . . . . . . . . . . . . . . .  15\n  5.5.  Per-Packet Timestamping . . . . . . . . . . . . . . . . .  16\n  5.6.  Limiting Queueing in Lower Layers . . . . . . . . . . . .  16\n  5.7.  Other Forms of Fair Queueing  . . . . . . . . . . . . . .  17\n  5.8.  Differences between CoDel and FQ-CoDel Behaviour  . . . .  17\n6.  Limitations of Flow Queueing  . . . . . . . . . . . . . . . .  18\n  6.1.  Fairness between Things Other Than Flows  . . . . . . . .  18\n  6.2.  Flow Bunching by Opaque Encapsulation . . . . . . . . . .  18\n  6.3.  Low-Priority Congestion Control Algorithms  . . . . . . .  19\n7.  Deployment Status and Future Work . . . . . . . . . . . . . .  19\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  20\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  21\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  21\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  24\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  25",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Flow Queue CoDel (FQ-CoDel) algorithm is a combined packet scheduler and Active Queue Management (AQM) [RFC3168] algorithm developed as part of the bufferbloat-fighting community effort [BLOATWEB]. It is based on a modified Deficit Round Robin (DRR) queue scheduler [DRR] [DRRPP] with the CoDel AQM [RFC8289] algorithm operating on each queue. This document describes the combined algorithm; reference implementations are available for the ns-2 [NS2] and ns-3 [NS3] network simulators, and the algorithm is included in the mainline Linux kernel as the fq_codel queueing discipline [LINUXSRC].",
      "ja": "フローキューCODEL（FQ-CODEL）アルゴリズムがbufferbloat-戦うコミュニティの努力[BLOATWEB]の一環として開発された複合パケットスケジューラおよびアクティブキュー管理（AQM）[RFC3168]アルゴリズムです。これは、各キューに動作修飾不足ラウンドロビン（DRR）キュースケジューラ[DRR] [DRRPP] CODEL AQMと[RFC8289]のアルゴリズムに基づいています。この文書では、結合アルゴリズムを記述する。リファレンス実装は、NS-2 [NS2]およびNS-3 [NS3]ネットワークシミュレータのために利用可能であり、アルゴリズムはfq_codelイング規律[LINUXSRC]としてメインラインのLinuxカーネルに含まれています。"
    },
    {
      "indent": 3,
      "text": "FQ-CoDel is a general, efficient, nearly parameterless queue management approach combining flow queueing with CoDel. It is a powerful tool for solving bufferbloat [BLOAT] and has already been turned on by default in a number of Linux distributions. In this document, we describe the Linux implementation in sufficient detail for others to independently implement the algorithm for deployment outside the Linux ecosystem.",
      "ja": "FQ-CODELはCODELでキューイング一般的、効率的、ほぼパラメータなしキュー管理アプローチ合成フローです。それはbufferbloat [BLOAT]を解決するための強力なツールであり、すでにLinuxディストリビューションの数ではデフォルトでオンになっています。この文書では、我々は独立して、Linuxのエコシステム外の展開のためのアルゴリズムを実装するために他の人のために十分に詳細にLinuxの実装を記述します。"
    },
    {
      "indent": 3,
      "text": "Since the FQ-CoDel algorithm was originally developed in the Linux kernel, that implementation is still considered canonical. This document describes the algorithm in the abstract in Sections 1-4 and separates out most implementation details in subsequent sections; however, the Linux implementation is used as a reference for default behaviour in the abstract algorithm description.",
      "ja": "FQ-CODELアルゴリズムは、もともとLinuxカーネルで開発されたので、その実装はまだ標準的な考えられています。この文書は、セクション1-4で抽象的でアルゴリズムを記述し、以降のセクションでは、ほとんどの実装の詳細を分離します。しかし、Linuxの実装は、抽象アルゴリズム記述のデフォルトの動作のための基準として使用されます。"
    },
    {
      "indent": 3,
      "text": "This document is structured as follows. This section gives some concepts and terminology used in the rest of the document and gives a short informal summary of the FQ-CoDel algorithm. Section 2 gives an overview of the CoDel algorithm. Section 3 covers the flow hashing and DRR portion. Section 4 then describes the working of the algorithm in detail, while Section 5 describes implementation details and considerations. Section 6 lists some of the limitations of using flow queueing. Section 7 outlines the current status of FQ-CoDel deployment and lists some possible future areas of inquiry. Finally, Section 8 reiterates some important security points that must be observed in the implementation.",
      "ja": "次のようにこの文書では、構成されています。このセクションでは、ドキュメントの残りの部分で使用されるいくつかの概念と用語を与え、FQ-CODELアルゴリズムの短い非公式の要約を示します。第2節ではCODELアルゴリズムの概要を説明します。セクション3は、フローハッシュとDRR部を覆います。第5節は、実装の詳細や注意事項を説明しながら、第4章では、その後、詳細にアルゴリズムの動作を説明します。第6節のリストフローキューイングを使用してのいくつかの制限。第7節はFQ-CODEL展開の現状を概説し、問い合わせのいくつかの可能な将来の地域を示しています。最後に、第8節は、実装に観察しなければならないいくつかの重要なセキュリティ上のポイントを改めて表明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology and Concepts",
      "section_title": true,
      "ja": "1.2. 用語と概念"
    },
    {
      "indent": 3,
      "text": "Flow: A flow is typically identified by a 5-tuple of source IP address, destination IP address, source port number, destination port number, and protocol number. It can also be identified by a superset or subset of those parameters, by Media Access Control (MAC) address, or by other means. FQ-CoDel hashes flows into a configurable number of buckets to assign packets to internal queues.",
      "ja": "フロー：フローは、典型的には、送信元IPアドレス、宛先IPアドレス、送信元ポート番号、宛先ポート番号、およびプロトコル番号の5タプルによって識別されます。また、メディアアクセス制御（MAC）アドレス、または他の手段によって、これらのパラメータのスーパーセットまたはサブセットによって同定することができます。 FQ-CODELハッシュは内部キューにパケットを割り当てるバケットの設定可能な数に流れ込みます。"
    },
    {
      "indent": 3,
      "text": "Queue: A queue of packets represented internally in FQ-CoDel. In most instances, each flow gets its own queue; however, because of the possibility of hash collisions, this is not always the case. In an attempt to avoid confusion, the word \"queue\" is used to refer to the internal data structure, and \"flow\" is used to refer to the actual stream of packets being delivered to the FQ-CoDel algorithm.",
      "ja": "キュー：FQ-CODELで内部表現のパケットのキュー。ほとんどの場合、各フローは、独自のキューを取得します。しかし、ハッシュ衝突の可能性、これは必ずしもそうではありません。混乱を避けるための試みにおいて、単語「キュー」は、内部データ構造を指すために使用され、そして「フロー」FQ-CODELアルゴリズムに配信されるパケットの実際のストリームを参照するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Scheduler: A mechanism to select which queue a packet is dequeued from.",
      "ja": "スケジューラ：パケットがからデキューされるキューかを選択するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "CoDel AQM: The Active Queue Management algorithm employed by FQ-CoDel as described in [RFC8289].",
      "ja": "CODEL AQM：[RFC8289]に記載されているようにFQ-CODELによって採用アクティブキュー管理アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "DRR: Deficit Round Robin scheduling [DRR].",
      "ja": "DRR：不足ラウンドロビンは、[DRR]スケジュール。"
    },
    {
      "indent": 3,
      "text": "Quantum: The maximum amount of bytes to be dequeued from a queue at once.",
      "ja": "量子：一度にキューからデキューされるバイト数の最大量。"
    },
    {
      "indent": 3,
      "text": "Interval: Characteristic time period used by the control loop of CoDel to detect when a persistent queue is developing (see Section 4.2 of [RFC8289]).",
      "ja": "間隔：永続キューが開発されているときを検出するCODELの制御ループで使用される特徴的な時間期間（[RFC8289]のセクション4.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Target: Setpoint value of the minimum sojourn time of packets in a queue used as the target of the control loop in CoDel (see Section 4.3 of [RFC8289]).",
      "ja": "ターゲット：CODELにおける制御ループの標的として使用されるキュー内のパケットの最小滞在時間の設定点値（[RFC8289]のセクション4.3を参照）。"
    },
    {
      "indent": 0,
      "text": "1.3. Informal Summary of FQ-CoDel",
      "section_title": true,
      "ja": "1.3.  FQ-CODELの非公式まとめ"
    },
    {
      "indent": 3,
      "text": "FQ-CoDel is a hybrid of DRR [DRR] and CoDel [RFC8289], with an optimisation for sparse flows similar to Shortest Queue First (SQF) [SQF] and DRR++ [DRRPP]. We call this \"flow queueing\" rather than \"fair queueing\", as flows that build a queue are treated differently from flows that do not.",
      "ja": "FQ-CODEL最短待ち行列ファースト（SQF）SQF]及びDRR ++ [DRRPP]と同様スパースフローの最適化と、[RFC8289] DRR [DRR]とCODELのハイブリッドです。キューを構築フローがないフローから異なる方法で処理されているとして私たちは、この「フローイング」ではなく、「公平キューイング」と呼んでいます。"
    },
    {
      "indent": 3,
      "text": "By default, FQ-CoDel stochastically classifies incoming packets into different queues by hashing the 5-tuple of protocol number, source and destination IP addresses, and source and destination port numbers, perturbed with a random number selected at initiation time (although other flow classification schemes can optionally be configured instead; see Section 4.1.1). Each queue is managed by the CoDel AQM algorithm [CODEL] [RFC8289]. Packet ordering within a queue is preserved, since queues have FIFO ordering.",
      "ja": "デフォルトでは、FQ-CODELは、確率的に開始時に選択された乱数（ただし、他のフロー分類と摂動、プロトコル番号、送信元および宛先IPアドレス、送信元および宛先ポート番号の5タプルをハッシュすることによって、異なるキューに着信パケットを分類しますスキームは、必要に応じて代わりに構成することができ、セクション4.1.1を参照します）。各キューはCODEL AQMアルゴリズム[CODEL] [RFC8289]によって管理されています。キューはFIFOの順序を持​​っているので、キュー内のパケットの順序は、保存されています。"
    },
    {
      "indent": 3,
      "text": "The FQ-CoDel algorithm consists of two logical parts: (1) the scheduler, which selects which queue to dequeue a packet from, and (2) the CoDel AQM, which works on each of the queues. The subtleties of FQ-CoDel are mostly in the scheduling part, whereas the interaction between the scheduler and the CoDel algorithm are fairly straightforward.",
      "ja": "FQ-CODELアルゴリズムは、2つの論理部分からなる：（1）からパケットをデキューするキューかを選択し、スケジューラ、（2）キューのそれぞれで動作CODEL AQM、。スケジューラとCODELアルゴリズムの間の相互作用はかなり簡単であるのに対し、FQ-CODELの機微は、スケジュール部ではほとんどです。"
    },
    {
      "indent": 3,
      "text": "At initialisation, each queue is set up to have a separate set of CoDel state variables. By default, 1024 queues are created. The Linux implementation at the time of writing supports anywhere from one to 65535 separate queues, and each queue maintains the state variables throughout its lifetime, and so acts the same as the non-FQ variant of CoDel would. This means that with only one queue, FQ-CoDel behaves essentially the same as CoDel by itself.",
      "ja": "初期設定では、各キューはCODEL状態変数の別のセットを持つように設定されています。デフォルトでは、1024個のキューが作成されます。執筆時のLinuxの実装はどこでも1〜65535別々のキューからサポートしており、各キューは、その生涯を通じて状態変数を維持し、そのCODELのだろう非FQバリアントと同じように動作します。これが唯一のキューで、FQ-CODEL自体がCODELと本質的に同じように動作していることを意味します。"
    },
    {
      "indent": 3,
      "text": "On dequeue, FQ-CoDel selects a queue from which to dequeue by a two-tier, round-robin scheme, in which each queue is allowed to dequeue up to a configurable quantum of bytes for each iteration. Deviations from this quantum are maintained as byte credits for the queue, which serves to make the fairness scheme byte-based rather than packet-based. The two-tier, round-robin mechanism distinguishes between \"new\" queues (which don't build up a standing queue) and \"old\" queues (which have queued enough data to be active for more than one iteration of the round-robin scheduler).",
      "ja": "デキューに、FQ-CODELは、各キューは各反復のバイトの設定量子までデキューさせた二層、ラウンドロビン方式によってデキューからキューを選択します。この量子からの逸脱はバイトベースではなく、パケットベースの公平性スキームを作るのに役立つキューのためのバイトのクレジットとして維持されます。二層、ラウンドロビンメカニズムは、ラウンドロビンの複数の反復のためにアクティブになるように十分なデータをキューに入れられている（立っキューを構築していない）「新しい」キューと「古い」のキュー（区別しスケジューラ）。"
    },
    {
      "indent": 3,
      "text": "This new/old queue distinction has a particular consequence for queues that don't build up more than a quantum of bytes before being visited by the scheduler: such a queue will be removed from the list after it empties and then re-added as a new queue the next time a packet arrives for it. This means it will effectively get priority over queues that do not empty out each round (a minor caveat is required here to protect against starvation, see below). Exactly how little data a flow has to send to keep its queue in this state is somewhat difficult to reason about, because it depends on both the egress link speed and the number of concurrent flows. However, in practice, many things that are beneficial to have prioritised for typical internet use (ACKs, DNS lookups, interactive Secure Shell (SSH), HTTP requests, Voice over IP (VoIP)) _tend_ to fall in this category, which is why FQ-CoDel performs so well for many practical applications. However, the implicitness of the prioritisation means that for applications that require guaranteed priority (for instance, multiplexing the network control plane over the network itself), explicit classification is still needed.",
      "ja": "この新しい/古いキューの区別は、スケジューラによって訪問される前のバイトの量よりも多くを構築していないキューの特定の結果を持っている：それは空にして、として再追加した後、このようなキューは、リストから削除されます新しいキューのパケットがそれのために到着した次の時間。これは、効果的に（マイナー警告が飢餓から保護するために、ここで必要とされ、下記を参照）、各ラウンドを空していないキューに優先し得ることを意味します。それは出口のリンク速度と並行フローの数の両方に依存するため、フローは、この状態でそのキューを維持するために送信する必要があります正確にどのように少しのデータは、およそ理由にやや困難です。しかし、実際には、有益であり、多くのものは、一般的なインターネット利用を優先していると（ACKを、DNSルックアップ、対話型のセキュアシェル（SSH）、HTTPリクエスト、ボイスオーバーIP（VoIP）の）_tend_が理由である、このカテゴリに落ちますFQ-CODELは、多くの実用的なアプリケーションのためにとてもよく実行されます。しかし、優先順位付けのimplicitness保証優先順位を必要とするアプリケーションのために（例えば、ネットワーク自体を介してネットワーク制御プレーンを多重化する）ことを意味し、明示的な分類が依然として必要とされています。"
    },
    {
      "indent": 3,
      "text": "This scheduling scheme has some subtlety to it, which is explained in detail in the remainder of this document.",
      "ja": "このスケジューリング方式は、この文書の残りの部分で詳細に説明され、それにはいくつかの微妙を、持っています。"
    },
    {
      "indent": 0,
      "text": "2. CoDel",
      "section_title": true,
      "ja": "2. CODEL"
    },
    {
      "indent": 3,
      "text": "CoDel is described in the Communications of the ACM paper [CODEL] and the IETF document [RFC8289]. The basic idea is to control queue length, maintaining sufficient queueing to keep the outgoing link busy but avoiding building up the queue beyond that point. This is done by preferentially dropping packets that remain in the queue for \"too long\". Packets are dropped by head drop, which lowers the time for the drop signal to propagate back to the sender by the length of the queue and helps trigger TCP fast retransmit sooner.",
      "ja": "CODELはACM紙のコミュニケーション[CODEL]とIETFドキュメント[RFC8289]に記載されています。基本的な考え方は、忙しい発信リンクを維持するために十分なキューイングを維持しますが、その点を超えてキューを構築避け、キューの長さを制御することです。これは、優先的に「長すぎる」ためにキューに残りのパケットをドロップすることによって行われます。パケットはドロップ信号は、キューの長さによって、送信者に戻って伝播するための時間を低下させ、早くトリガTCP高速再送を助けヘッドドロップ、によって廃棄されます。"
    },
    {
      "indent": 3,
      "text": "The CoDel algorithm itself will not be described here; instead, we refer the reader to the CoDel document [RFC8289].",
      "ja": "CODELアルゴリズム自体は、ここでは説明しません。代わりに、我々はCODELドキュメント[RFC8289]を読者に参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Flow Queueing",
      "section_title": true,
      "ja": "3.フローイング"
    },
    {
      "indent": 3,
      "text": "The intention of FQ-CoDel's scheduler is to give each flow its own queue, hence the term \"flow queueing\". Rather than a perfect realisation of this, a hashing-based scheme is used, where flows are hashed into a number of buckets, each of which has its own queue. The number of buckets is configurable and presently defaults to 1024 in the Linux implementation. This is enough to avoid hash collisions on a moderate number of flows as seen, for instance, in a home gateway. Depending on the characteristics of the link, this can be tuned to trade off memory for a lower probability of hash collisions. See Sections 5.3 and 5.4 for a more in-depth discussion of this.",
      "ja": "FQ-CODELのスケジューラの意図は、それぞれが、そのため「フローイング」を独自のキューを流し与えることです。フローはそれ自身のキューをそれぞれ有するバケットの数にハッシュされる、むしろ本の完全実現よりも、ハッシュベースのスキームが、使用されています。バケットの数は設定可能で、Linuxの実装では1024年に現在のデフォルト値。これは、ホームゲートウェイに、例えば、見られるような流れの緩やかな数にハッシュ衝突を回避するのに十分です。リンクの特性に応じて、これはハッシュの衝突の確率が低いためにメモリをトレードオフするように調整することができます。こののより詳細な議論については、セクション5.3と5.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "By default, the flow hashing is performed on the 5-tuple of source and destination IP addresses, source and destination port numbers, and protocol number. While the hashing can be customised to match on arbitrary packet bytes, care should be taken when doing so; much of the benefit of the FQ-CoDel scheduler comes from this per-flow distinction. However, the default hashing does have some limitations, as discussed in Section 6.",
      "ja": "デフォルトでは、フローハッシングは、ソースおよび宛先IPアドレス、送信元および宛先ポート番号、およびプロトコル番号の5タプルに対して実行されます。ハッシュは、任意のパケットのバイトに一致するようにカスタマイズすることができるが、そうする際に、注意が必要です。 FQ-CODELスケジューラの利点の多くは、このフローごとの違いから来ています。ただし、デフォルトのハッシュは、第6節で述べたように、いくつかの制限があります。"
    },
    {
      "indent": 3,
      "text": "FQ-CoDel's DRR scheduler is byte-based, employing a deficit round-robin mechanism between queues. This works by keeping track of the current number of \"byte credits\" of each queue. This number is initialised to the configurable quantum; each time a queue gets a dequeue opportunity, it gets to dequeue packets, thus decreasing the number of credits by the packet size for each packet. This continues until the value of the byte credits counter becomes zero or less, at which point the counter is increased by one quantum, and the dequeue opportunity ends.",
      "ja": "FQ-CODELのDRRスケジューラは、キュー間で赤字ラウンドロビンメカニズムを採用し、バイトベースです。これは、各キューの「バイトクレジット」の現在の数を追跡することによって動作します。この番号は、設定量子に初期化されます。キューがデキュー機会を得るたびに、それはこのように各パケットのパケットサイズによってクレジットの数を減らし、パケットのデキューを取得します。バイトのクレジットカウンタの値がカウンタが1つの量子増加、およびデキュー機会が終了された時点で、ゼロ以下になるまでこれが続きます。"
    },
    {
      "indent": 3,
      "text": "This means that if one queue contains packets of, for instance, size quantum/3, and another contains quantum-sized packets, the first queue will dequeue three packets each time it gets a turn, whereas the second only dequeues one. This means that flows that send small packets are not penalised by the difference in packet sizes; rather, the DRR scheme approximates a byte-based fairness queueing scheme. The size of the quantum determines the scheduling granularity, with the trade-off from too small a quantum being scheduling overhead. For small bandwidths, lowering the quantum from the default MTU size can be advantageous.",
      "ja": "これは、1つのキューは、例えば、サイズの量子/ 3のパケットを含み、別の量子サイズのパケットが含まれている場合、最初のキューが3つのパケットを第二の一方のみをデキューし、一方、それは、順番を取得するたびにデキューすることを意味します。これは、小さなパケットを送信するフローはパケットサイズの違いにより罰せされていないことを意味します。むしろ、DRR方式は、バイトベース公平キューイングスキームを近似します。量子のサイズが小さすぎる量子ビーイングスケジューリングオーバーヘッドからのトレードオフで、スケジューリング粒度を決定します。小さな帯域幅の場合は、デフォルトのMTUサイズから量子を低下させることが有利である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Unlike plain DRR, there are two sets of flows: a \"new\" list for flows that have not built a queue recently and an \"old\" list for queues that build a backlog. This distinction is an integral part of the FQ-CoDel scheduler and is described in more detail in Section 4.",
      "ja": "最近、キューとバックログを構築キューの「古い」リストを作成していないフローのための「新しい」リスト：プレーンDRRとは異なり、流れの2セットがあります。この区別はFQ-CODELスケジューラの不可欠な部分であり、第4章でより詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "4. The FQ-CoDel Scheduler",
      "section_title": true,
      "ja": "4. FQ-CODELスケジューラ"
    },
    {
      "indent": 3,
      "text": "To make its scheduling decisions, FQ-CoDel maintains two ordered lists of active queues: new and old queues. When a packet is added to a queue that is not currently active, that queue becomes active by being added to the list of new queues. Later on, it is moved to the list of old queues, from which it is removed when it is no longer active. This behaviour is the source of some subtlety in the packet scheduling at dequeue time, as explained below.",
      "ja": "新旧キュー：そのスケジューリングの決定を行うために、FQ-CODELは、アクティブキューの2つの命じたリストを維持します。パケットが現在アクティブでないキューに追加された場合、そのキューは、新しいキューのリストに追加されることによってアクティブになります。その後、それはもはやアクティブである場合、それは削除されていないから、古いキューのリストに移動します。以下に説明するように、この動作は、デキュー時にパケットスケジューリングにおけるいくつかの微妙な源です。"
    },
    {
      "indent": 0,
      "text": "4.1. Enqueue",
      "section_title": true,
      "ja": "4.1. エンキュー"
    },
    {
      "indent": 3,
      "text": "The packet enqueue mechanism consists of three stages: classifying into a queue, timestamping and bookkeeping, and optionally dropping a packet when the total number of enqueued packets goes over the maximum.",
      "ja": "パケット・エンキュー・メカニズムは、三の段階からなる：、キューに分類タイムスタンプと簿記、およびエンキューされたパケットの総数が最大乗り越えるときに必要に応じてパケットをドロップします。"
    },
    {
      "indent": 3,
      "text": "When a packet is enqueued, it is first classified into the appropriate queue. By default, this is done by hashing (using a Jenkins hash function [JENKINS]) on the 5-tuple of IP protocol, source and destination IP addresses, and source and destination port numbers (if they exist) and then taking the hash value modulo the number of queues. The hash is salted by modulo addition of a random value selected at initialisation time to prevent possible DoS attacks if the hash is predictable ahead of time (see Section 8). The Linux",
      "ja": "パケットがエンキューされると、それは最初に適切なキューに分類されています。デフォルトでは、IPプロトコル、送信元および宛先IPアドレスの5タプルに（ジェンキンスハッシュ関数[JENKINS]を使用して）ハッシング、ソース及び宛先ポート番号（存在する場合）、次に、ハッシュ値をとることによって行われますキューの数を法。ハッシュは、ハッシュは（セクション8を参照）事前に予測可能である場合に可能DoS攻撃を防ぐために、初期化時に選択されたランダム値のモジュロ加算で塩漬けされます。 Linuxの"
    },
    {
      "indent": 3,
      "text": "kernel implements the Jenkins hash function by mixing three 32-bit values into a single 32-bit output value. Inputs larger than 96 bits are reduced by additional mixing steps, 96 bits at a time.",
      "ja": "カーネルは、単一の32ビット出力値に3つの32ビット値を混合することにより、ジェンキンスハッシュ関数を実装します。 96ビットよりも大きい入力は、追加の混合工程によって一度に96ビットに低減されます。"
    },
    {
      "indent": 3,
      "text": "Once the packet has been successfully classified into a queue, it is handed over to the CoDel algorithm for timestamping. It is then added to the tail of the selected queue, and the queue's byte count is updated by the packet size. Then, if the queue is not currently active (i.e., if it is not in either the list of new queues or the list of old queues), it is added to the end of the list of new queues, and its number of credits is initiated to the configured quantum. Otherwise, the queue is left in its current queue list.",
      "ja": "パケットが正常にキューに分類されていたら、それをタイムスタンプ用CODELアルゴリズムに引き渡されます。次に、これを選択したキューの末尾に追加され、キューのバイト数は、パケットサイズによって更新されます。キューが現在アクティブでない場合（これは新しいキューのリストや、古いキューのリストのいずれかにない場合、すなわち、）すると、それは新しいキューのリストの最後に追加し、クレジットのその数があるさ構成された量子に開始しました。それ以外の場合は、キューは、現在のキューリストに残っています。"
    },
    {
      "indent": 3,
      "text": "Finally, to protect against overload, the total number of enqueued packets is compared with the configured limit. If the limit is exceeded (which can happen since a packet was just enqueued), the queue with the largest current byte count is selected and half the number of packets from this queue (up to a maximum of 64 packets) are dropped from the head of that queue. Dropping several packets at once helps amortise the cost of finding the longest queue, significantly lowering CPU usage in an overload situation.",
      "ja": "最後に、過負荷から保護するために、エンキューされたパケットの総数が設定された制限と比較されます。限界を超えている場合は現在の最大のバイト数を持つキューが選択され、（パケットがちょうどエンキューされたので、これは起こることができる）及び（64のパケットの最大まで）このキューからのパケットの数の半分が頭から落とされますそのキューの。一度に複数のパケットをドロップすると大幅に過負荷状況でCPU使用率を下げ、最も長い待ち行列を見つけるのコストを償却するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Alternative Classification Schemes",
      "section_title": true,
      "ja": "4.1.1. 代替分類スキーマ"
    },
    {
      "indent": 3,
      "text": "As mentioned previously, it is possible to modify the classification scheme to provide a different notion of a flow. The Linux implementation provides this option in the form of the \"tc filter\" command. While this can add capabilities (for instance, matching on other possible parameters such as MAC address, Diffserv code point values, firewall rules, flow-specific markings, IPv6 flow label, etc.), care should be taken to preserve the notion of flow because much of the benefit of the FQ-CoDel scheduler comes from keeping flows in separate queues.",
      "ja": "前述したように、流れの異なる概念を提供するために、分類方式を変更することが可能です。 Linuxの実装は、「TCフィルタ」コマンドの形式では、このオプションを提供します。これは、（例えば、MACアドレス、Diffservのコードポイント値、ファイアウォールルール、フロー固有のマーキングのIPv6フローラベル、等のような他の可能なパラメータに一致する、例えば）機能を追加することができるが、ケアは、フローの概念を維持するために注意しなければなりませんFQ-CODELスケジューラの利点の多くは別々のキューにフローを維持するから来ているので。"
    },
    {
      "indent": 3,
      "text": "For protocols that do not contain a port number (such as ICMP), the Linux implementation simply sets the port numbers to zero and performs the hashing as usual. In practice, this results in such protocols each getting their own queue (except in the case of hash collisions). An implementation can perform other classifications for protocols that have their own notion of a flow but SHOULD fall back to simply hashing on source and destination IP address and protocol number in the absence of other information.",
      "ja": "（ICMPなど）のポート番号が含まれていないプロトコルのために、Linuxの実装は、単にゼロにポート番号を設定し、通常通りハッシュを行います。実際には、これはそのようなプロトコルごと（ハッシュ衝突の場合を除いて）、自分のキューを得ることになります。実装は、流れの独自の概念を持っていますが、単純に他の情報が存在しない場合に、送信元と宛先のIPアドレス、プロトコル番号にハッシングにフォールバックすべきであるプロトコルのための他の分類を行うことができます。"
    },
    {
      "indent": 3,
      "text": "The default classification scheme can additionally be improved by performing decapsulation of tunnelled packets prior to hashing on the 5-tuple in the encapsulated payload. The Linux implementation does this for common encapsulations known to the kernel, such as 6in4 [RFC4213], IP-in-IP [RFC2003], and Generic Routing Encapsulation",
      "ja": "デフォルトの分類スキームがさらに前にカプセル化ペイロードに5タプルにハッシュにトンネルパケットのデカプセル化を行うことにより改善することができます。 Linuxの実装では、このような6in4 [RFC4213]、IP・イン・IP [RFC2003]、および汎用ルーティングカプセル化としてカーネルに知られている一般的なカプセル化のためにこれを行います"
    },
    {
      "indent": 3,
      "text": "(GRE) [RFC2890]. This helps to distinguish between flows that share the same (outer) 5-tuple but, of course, is limited to unencrypted tunnels (see Section 6.2 for a discussion of encrypted tunnels).",
      "ja": "（GRE）[RFC2890]。もちろん、これは、暗号化されていないトンネル（暗号化されたトンネルの議論については、セクション6.2を参照）に制限され、同一の（外側の）5タプルを共有するが、流れを区別するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.2. Dequeue",
      "section_title": true,
      "ja": "4.2. デキュー"
    },
    {
      "indent": 3,
      "text": "Most of FQ-CoDel's work is done at packet dequeue time. It consists of three parts: selecting a queue from which to dequeue a packet, actually dequeueing it (employing the CoDel algorithm in the process), and some final bookkeeping.",
      "ja": "FQ-CODELの仕事のほとんどは、パケットのデキュー時に行われます。それは3つの部分から構成：（実際プロセスにおいてCODELアルゴリズムを採用しているもの）をデキュー、パケットをデキューするからキューを選択し、いくつかの最終的な簿記。"
    },
    {
      "indent": 3,
      "text": "For the first part, the scheduler first looks at the list of new queues; for the queue at the head of that list, if that queue has a negative number of credits (i.e., it has already dequeued at least a quantum of bytes), it is given an additional quantum of credits, the queue is put onto _the end of_ the list of old queues, and the routine selects the next queue and starts again.",
      "ja": "最初の部分では、スケジューラは、最初に新しいキューのリストを見ます。そのキューはクレジット（すなわち、それはすでにバイトの少なくとも量子をデキューしている）の負の数を持っている場合、そのリストの先頭にキューのために、それはクレジットの追加の量子が与えられ、キューは_The最後に置かれています古いキューのリスト、およびルーチンOF_次のキューを選択し、再び開始します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, that queue is selected for dequeue. If the list of new queues is empty, the scheduler proceeds down the list of old queues in the same fashion (checking the credits and either selecting the queue for dequeueing or adding credits and putting the queue back at the end of the list).",
      "ja": "それ以外の場合は、そのキューは、デキューのために選択されています。新しいキューのリストが空の場合、スケジューラは同じ方法（クレジットをチェックし、デキューまたはクレジットを追加すると、リストの最後にバックキューを置くためのキューを選択するのいずれか）で、古いキューのリストを下に進みます。"
    },
    {
      "indent": 3,
      "text": "After having selected a queue from which to dequeue a packet, the CoDel algorithm is invoked on that queue. This applies the CoDel control law, which is the mechanism CoDel uses to determine when to drop packets (see [RFC8289]). As a result of this, one or more packets may be discarded from the head of the selected queue before the packet that should be dequeued is returned (or nothing is returned if the queue is or becomes empty while being handled by the CoDel algorithm).",
      "ja": "パケットをデキューするからキューを選択した後、CODELアルゴリズムは、そのキューに呼び出されます。これはCODELがパケットをドロップするかを決定するために使用する機構であるCODEL制御則を適用する（参照[RFC8289]）。デキューされるべきパケットが返される（またはキューであるか、またはCODELアルゴリズムによって処理された状態で空になった場合は何も返されない）前に、この結果として、1つ以上のパケットは、選択されたキューの先頭から廃棄することができます。"
    },
    {
      "indent": 3,
      "text": "Finally, if the CoDel algorithm does not return a packet, then the queue must be empty, and the scheduler does one of two things. If the queue selected for dequeue came from the list of new queues, it is moved to _the end of_ the list of old queues. If instead it came from the list of old queues, that queue is removed from the list, to be added back (as a new queue) the next time a packet arrives that hashes to that queue. Then (since no packet was available for dequeue), the whole dequeue process is restarted from the beginning.",
      "ja": "CODELアルゴリズムは、パケットを返さないときには、キューが空でなければなりません、そしてスケジューラは、2つのいずれかを行います。デキューのために選択したキューが新しいキューのリストから来た場合は、古いキューのリストOF_ _The端まで移動されます。それは古いキューのリストから来た代わりにした場合、そのキューは、（新しいキューとして）そのキューにハッシュパケットが到着した次の時間を戻って追加するには、リストから削除されます。 （何のパケットがデキューのために入手できなかったので）すると、全体のデキュープロセスが最初から再開されます。"
    },
    {
      "indent": 3,
      "text": "If, instead, the scheduler _did_ get a packet back from the CoDel algorithm, it subtracts the size of the packet from the byte credits for the selected queue and returns the packet as the result of the dequeue operation.",
      "ja": "代わりに、スケジューラはバックCODELアルゴリズムからのパケットを取得し_did_場合は、選択されたキューのバイト単位のパケットのサイズを減算し、デキュー操作の結果としてパケットを返します。"
    },
    {
      "indent": 3,
      "text": "The step that moves an empty queue from the list of new queues to the end of the list of old queues before it is removed is crucial to prevent starvation. Otherwise, the queue could reappear (the next time a packet arrives for it) before the list of old queues is visited; this can go on indefinitely, even with a small number of active flows, if the flow providing packets to the queue in question transmits at just the right rate. This is prevented by first moving the queue to the end of the list of old queues, forcing the scheduler to service all old queues before the empty queue is removed and thus preventing starvation.",
      "ja": "それが削除される前に、古いキューのリストの末尾に新しいキューのリストから空のキューを動かすステップは、飢餓を防ぐために重要です。それ以外の場合は、キューが訪問されている古いキューのリストの前に（パケットがそれのために到着した次の時間）を再表示さことができ;問題のキューにパケットを提供するフローがちょうどいいレートで送信した場合、これは、さえアクティブフローの数が少ないと、無期限に行くことができます。これは最初に、古いキューのリストの最後にキューを移動し、空のキューが削除される前に、すべての古いキューにサービスを提供するために、スケジューラを強制ので、飢餓を防ぐことによって阻止されます。"
    },
    {
      "indent": 3,
      "text": "The resulting migration of queues between the different states is summarised in the state diagram shown in Figure 1. Note that both the new and old queue states can additionally have arrival and dequeue events that do not change the state; these are omitted in the figure.",
      "ja": "異なる状態間のキューの結果の移行は、新旧両方のキューの状態はさらに状態を変更しない到着とデキューイベントを持つことができることを、図1に示す注意状態図に要約されています。これらは、図では省略されています。"
    },
    {
      "indent": 3,
      "text": "+-----------------+                +------------------+\n|                 |     Empty      |                  |\n|     Empty       |<---------------+       Old        +----+\n|                 |                |                  |    |\n+-------+---------+                +------------------+    |\n        |                             ^            ^       |Credits\n        |Arrival                      |            |       |Exhausted\n        v                             |            |       |\n+-----------------+                   |            |       |\n|                 |      Empty or     |            |       |\n|      New        +-------------------+            +-------+\n|                 | Credits Exhausted\n+-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1: Partial State Diagram for Queues between Different States",
      "ja": "図1：異なる国間のキューのための部分的な状態図"
    },
    {
      "indent": 0,
      "text": "5. Implementation Considerations",
      "section_title": true,
      "ja": "5.実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section contains implementation details for the FQ-CoDel algorithm. This includes the data structures and parameters used in the Linux implementation, as well as discussion of some required features of the target platform and other considerations.",
      "ja": "このセクションでは、FQ-CODELアルゴリズムの実装の詳細が含まれています。これは、データ構造とパラメータLinuxの実装で使用されるだけでなく、いくつかのターゲットプラットフォームの必要な機能およびその他の考慮事項の説明を含んでいます。"
    },
    {
      "indent": 0,
      "text": "5.1. Data Structures",
      "section_title": true,
      "ja": "5.1. データ構造"
    },
    {
      "indent": 3,
      "text": "The main data structure of FQ-CoDel is the array of queues, which is instantiated with the number of queues specified by the \"flows\" parameter at instantiation time. Each queue consists simply of an ordered list of packets with FIFO semantics, two state variables tracking the queue credits and total number of bytes enqueued, and the set of CoDel state variables. Other state variables to track queue statistics can also be included; for instance, the Linux implementation keeps a count of dropped packets.",
      "ja": "FQ-CODELのメインデータ構造は、インスタンス化時に「流れ」パラメータで指定されたキューの数でインスタンス化されたキューの配列です。各キューは、単にFIFOセマンティクスを持つパケットの順序付きリストで構成され、キュークレジットとエンキューの総バイト数、およびCODEL状態変数のセットを追跡する2つの状態変数。キューの統計情報を追跡するために、他の状態変数を含めることもできます。例えば、Linuxの実装は、ドロップされたパケットの数を保持します。"
    },
    {
      "indent": 3,
      "text": "In addition to the queue structures themselves, FQ-CoDel maintains two ordered lists containing references to the subset of queues that are currently active. These are the lists of new and old queues, as explained in Section 4 above.",
      "ja": "キュー構造そのものに加えて、FQ-CODELは、現在アクティブなキューのサブセットへの参照を含む2つの命じたリストを維持します。上記第4節で説明したように、これらは、新旧のキューのリストです。"
    },
    {
      "indent": 3,
      "text": "In the Linux implementation, queue space is shared: there's a global limit on the number of packets the queues can hold, but not a limit for each queue.",
      "ja": "各キューの制限をキューが保持できるパケット数のグローバル制限がありますが、ありません：Linuxの実装では、キュースペースが共有されています。"
    },
    {
      "indent": 0,
      "text": "5.2. Parameters",
      "section_title": true,
      "ja": "5.2. パラメーター"
    },
    {
      "indent": 3,
      "text": "The following are the user configuration parameters exposed by the Linux implementation of FQ-CoDel.",
      "ja": "次FQ-CODELのLinuxの実装によって公開されたユーザの設定パラメータです。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Interval",
      "section_title": true,
      "ja": "5.2.1. 間隔"
    },
    {
      "indent": 3,
      "text": "The \"interval\" parameter has the same semantics as CoDel and is used to ensure that the minimum sojourn time of packets in a queue used as an estimator by the CoDel control algorithm is a relatively up-to-date value. That is, CoDel only reacts to delay experienced in the last epoch of length interval. It SHOULD be set to be on the order of the worst-case RTT through the bottleneck to give end points sufficient time to react.",
      "ja": "「間隔」パラメータはCODELと同じ意味を有し、CODEL制御アルゴリズムによって推定として使用されるキュー内のパケットの最小滞在時間が比較的最新の値であることを保証するために使用されます。それはCODELは長さだけ間隔の最後のエポックで経験豊富遅らせるために反応し、です。エンドポイントに反応するのに十分な時間を与えるために、ボトルネックによって、最悪の場合RTTのオーダーになるように設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The default interval value is 100 ms.",
      "ja": "デフォルトの間隔値は100ミリ秒です。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Target",
      "section_title": true,
      "ja": "5.2.2. ターゲット"
    },
    {
      "indent": 3,
      "text": "The \"target\" parameter has the same semantics as CoDel. It is the acceptable minimum standing/persistent queue delay for each FQ-CoDel queue. This minimum delay is identified by tracking the local minimum queue delay that packets experience.",
      "ja": "「ターゲット」パラメータはCODELと同じ意味を持っています。これは、各FQ-CODELキューの許容最小立っ/永続キュー遅延です。この最小遅延は、経験をパケットローカルキューの最小遅延を追跡することによって識別されます。"
    },
    {
      "indent": 3,
      "text": "The default target value is 5 ms, but this value should be tuned to be at least the transmission time of a single MTU-sized packet at the prevalent egress link speed (which, for example, is ~15 ms for 1 Mbps and MTU 1500). This prevents CoDel from being too aggressive at low bandwidths. It should otherwise be set to 5-10% of the configured interval.",
      "ja": "デフォルトの目標値は5ミリ秒であるが、この値は、例えば、1 MbpsおよびMTU 1500〜15ミリ秒である、優勢イグレスリンク速度（AT単一MTUサイズのパケットの少なくとも送信時間であるように調整されるべきです）。これは、低帯域幅で、あまりにも積極的であることからCODELを防ぐことができます。これは、そうでない場合は、設定された間隔5〜10％に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Packet Limit",
      "section_title": true,
      "ja": "5.2.3. パケット制限"
    },
    {
      "indent": 3,
      "text": "Routers do not have infinite memory, so some packet limit MUST be enforced.",
      "ja": "ルータは無限のメモリを持っていないので、いくつかのパケット制限が実施されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"limit\" parameter is the hard limit on the real queue size, measured in number of packets. This limit is a global limit on the number of packets in all queues; each individual queue does not have an upper limit. When the limit is reached and a new packet arrives for enqueue, packets are dropped from the head of the largest queue (measured in bytes) to make room for the new packet.",
      "ja": "「リミット」パラメータはパケット数で測定された実際のキューサイズのハード制限、です。この制限は、すべてのキュー内のパケット数のグローバル制限です。個々のキューは上限はありません。制限に達すると、新たなパケットがエンキューのために到着すると、パケットが新しいパケットのための余地を作るために（バイト単位で測定）の最大キューの先頭から削除されます。"
    },
    {
      "indent": 3,
      "text": "In Linux, the default packet limit is 10240 packets, which is suitable for up to 10-Gigabit Ethernet speeds. In practice, the hard limit is rarely (if ever) hit, as drops are performed by the CoDel algorithm long before the limit is hit. For platforms that are severely memory constrained, a lower limit can be used.",
      "ja": "Linuxでは、デフォルトのパケット制限は最大10ギガビットイーサネット速度に適した、10240のパケットです。滴は制限がヒットしたずっと前にCODELアルゴリズムによって実行される実際には、ハードリミットは、（これまでの場合）めったにヒットではありません。ひどくメモリ制約されるプラットフォームのため、下限を使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Quantum",
      "section_title": true,
      "ja": "5.2.4. 量子"
    },
    {
      "indent": 3,
      "text": "The \"quantum\" parameter is the number of bytes each queue gets to dequeue on each round of the scheduling algorithm. The default is set to 1514 bytes, which corresponds to the Ethernet MTU plus the hardware header length of 14 bytes.",
      "ja": "「量子」パラメータは、各キューがスケジューリングアルゴリズムの各ラウンドにデキューなるバイト数です。デフォルトでは、イーサネットMTUプラス14バイトのハードウェアヘッダの長さに対応する1514バイトに設定されています。"
    },
    {
      "indent": 3,
      "text": "In systems employing TCP Segmentation Offload (TSO), where a \"packet\" consists of an offloaded packet train, it can presently be as large as 64 kilobytes. In systems using Generic Receive Offload (GRO), they can be up to 17 times the TCP max segment size (or 25 kilobytes). These mega-packets severely impact FQ-CoDel's ability to schedule traffic, and they hurt latency needlessly. There is ongoing work in Linux to make smarter use of offload engines.",
      "ja": "「パケット」は、オフロードパケット列から成るTCPセグメンテーションオフロード（TSO）を使用するシステムでは、現在64キロバイトほど大きくすることができます。ジェネリックは、オフロード（GRO）を受信使用しているシステムでは、彼らは、最大17倍のTCP最大セグメントサイズ（または25キロバイト）することができます。これらのメガパケットは厳しくトラフィックをスケジュールするFQ-CODELの能力に影響を与え、彼らは不レイテンシーを傷つけます。オフロードエンジンを賢く利用するために、Linuxで進行中の作業があります。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Flows",
      "section_title": true,
      "ja": "5.2.5. 流れ"
    },
    {
      "indent": 3,
      "text": "The \"flows\" parameter sets the number of queues into which the incoming packets are classified. Due to the stochastic nature of hashing, multiple flows may end up being hashed into the same slot.",
      "ja": "「流れ」パラメータは、着信パケットが分類されたキューの数を設定します。ハッシュの確率的性質のために、複数のフローが同じスロットにハッシュされてしまうことができます。"
    },
    {
      "indent": 3,
      "text": "This parameter can be set only at initialisation time in the current implementation, since memory has to be allocated for the hash table.",
      "ja": "メモリは、ハッシュテーブルのために割り当てられなければならないので、このパラメータは、現在の実装でのみ初期化時に設定することができます。"
    },
    {
      "indent": 3,
      "text": "The default value is 1024 in the current Linux implementation.",
      "ja": "デフォルト値は、現在のLinuxの実装では1024年です。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Explicit Congestion Notification (ECN)",
      "section_title": true,
      "ja": "5.2.6. 明示的輻輳通知（ECN）"
    },
    {
      "indent": 3,
      "text": "ECN [RFC3168] is enabled by default. Rather than do anything special with misbehaved ECN flows, FQ-CoDel relies on the packet scheduling system to minimise their impact; thus, the number of unresponsive packets in a flow being marked with ECN can grow to the overall packet limit but will not otherwise affect the performance of the system.",
      "ja": "ECN [RFC3168]はデフォルトで有効になっています。むしろmisbehaved ECNフローと特別な何かを行うよりも、FQ-CODELは、その影響を最小限に抑えるために、パケットスケジューリングシステムに依存しています。このように、フロー内の無応答パケット数が全体のパケット限界まで成長することができますECNでマークされているが、それ以外のシステムのパフォーマンスに影響を与えません。"
    },
    {
      "indent": 3,
      "text": "ECN can be disabled by specifying the \"noecn\" parameter.",
      "ja": "ECNは「noecn」パラメータを指定することで無効にすることができます。"
    },
    {
      "indent": 0,
      "text": "5.2.7. CE Threshold",
      "section_title": true,
      "ja": "5.2.7.  CEしきい値"
    },
    {
      "indent": 3,
      "text": "This parameter enables DCTCP-like processing resulting in Congestion Encountered (CE) marking on ECN-Capable Transport (ECT) packets [RFC3168] starting at a lower sojourn delay setpoint than the default CoDel target. Details of Data Center TCP (DCTCP) can be found in [RFC8257].",
      "ja": "このパラメータは、デフォルトCODELの目標より低い滞在遅延設定値から始まるECN-可能なトランスポート（ECT）パケット[RFC3168]にマーキング輻輳で遭遇（CE）を得DCTCPような処理を可能にします。データセンターTCP（DCTCP）の詳細は、[RFC8257]で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The \"ce_threshold\" parameter is disabled by default; it can be enabled by setting it to a number of microseconds.",
      "ja": "「ce_threshold」パラメータはデフォルトで無効になっています。それは、マイクロ秒数に設定することで有効にすることができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Probability of Hash Collisions",
      "section_title": true,
      "ja": "5.3. ハッシュ衝突の可能性"
    },
    {
      "indent": 3,
      "text": "Since the Linux FQ-CoDel implementation by default uses 1024 hash buckets, the probability that (say) 100 flows will all hash to the same bucket is something like ten to the power of minus 300. Thus, at least one of the flows will almost certainly hash to some other queue.",
      "ja": "デフォルトでは、LinuxのFQ-CODELの実装は1024のハッシュバケット、確率（例えば）100のフローが同じバケットにすべてのハッシュは、このようにマイナス300のパワーに10のようなものであるということ、流れの少なくとも一つは、ほとんど意志を使用していますので、確かにいくつかの他のキューにハッシュ。"
    },
    {
      "indent": 3,
      "text": "Expanding on this, based on analytical equations for hash collision probabilities, for 100 flows, the probability of no collision is 90.78%; the probability that no more than two of the 100 flows will be involved in any given collision is 99.57%; and the probability that no more than three of the 100 flows will be involved in any given collision is 99.99%. These probabilities assume a hypothetical perfect hashing function, so in practice, they may be a bit lower. We have not found this difference to matter in practice.",
      "ja": "ハッシュの衝突確率の分析式に基づいて、この上に拡大、100のフローについて、無衝突の確率が90.78パーセントです。 100の流れの2つ以下が任意の衝突に関与しないであろう確率が99.57パーセントです。 100の流れのないつ以上が任意の衝突に関与しないであろう確率が99.99％です。これらの確率は、架空の完璧なハッシュ関数を想定し、その実際には、彼らは少し低くてもよいです。私たちは、実際には問題には、この差は認められませんでした。"
    },
    {
      "indent": 3,
      "text": "These probabilities can be improved upon by using set-associative hashing, a technique used in the Cake algorithm currently being developed as a further refinement of the FQ-CoDel principles [CAKE]. For a 4-way associative hash with the same number of total queues, the probability of no collisions for 100 flows is 99.93%, while for an 8-way associative hash, it is ~100%.",
      "ja": "これらの確率は、ケーキアルゴリズムで使用される技術は、現在、FQ-CODEL原則[ケーキ]のさらなる改良として開発され、セットアソシアティブハッシュを使用することによって大幅に改善することができます。 8ウェイアソシエハッシュのために、それは〜100％である合計キューの同じ数の4ウェイ・アソシエハッシュのために、100のフローのない衝突の確率は、99.93パーセントです。"
    },
    {
      "indent": 0,
      "text": "5.4. Memory Overhead",
      "section_title": true,
      "ja": "5.4. メモリー・オーバーヘッド"
    },
    {
      "indent": 3,
      "text": "FQ-CoDel can be implemented with a low memory footprint (less than 64 bytes per queue on 64-bit systems). These are the data structures used in the Linux implementation:",
      "ja": "FQ-CODELは、低メモリフットプリント（64ビットシステム上のキューごとに64バイト未満）で実施することができます。これらは、Linuxの実装で使用されるデータ構造です："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "struct codel_vars {\n   u32             count;             /* number of dropped packets */\n   u32             lastcount;     /* count entry to dropping state */\n   bool            dropping;                /* currently dropping? */\n   u16             rec_inv_sqrt;    /* reciprocal sqrt computation */\n   codel_time_t    first_above_time;    /* when delay above target */\n   codel_time_t    drop_next;                 /* next time to drop */\n   codel_time_t    ldelay; /* sojourn time of last dequeued packet */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct fq_codel_flow {\n   struct sk_buff    *head;\n   struct sk_buff    *tail;\n   struct list_head  flowchain;\n   int               credits;   /* current number of queue credits */\n   u32               dropped; /* # of drops (or ECN marks) on flow */\n   struct codel_vars cvars;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "The master table managing all queues looks like this:",
      "ja": "すべてのキューを管理するマスターテーブルは次のようになります。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "struct fq_codel_sched_data {\n   struct tcf_proto *filter_list;  /* optional external classifier */\n   struct fq_codel_flow *flows;    /* Flows table [flows_cnt] */\n   u32             *backlogs;      /* backlog table [flows_cnt] */\n   u32             flows_cnt;      /* number of flows */\n   u32             perturbation;   /* hash perturbation */\n   u32             quantum;        /* psched_mtu(qdisc_dev(sch)); */\n   struct codel_params cparams;\n   struct codel_stats cstats;\n   u32             drop_overlimit;\n   u32             new_flow_count;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   struct list_head new_flows;     /* list of new flows */\n   struct list_head old_flows;     /* list of old flows */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "5.5. Per-Packet Timestamping",
      "section_title": true,
      "ja": "5.5. パケットごとのタイムスタンプ"
    },
    {
      "indent": 3,
      "text": "The CoDel portion of the algorithm requires per-packet timestamps be stored along with the packet. While this approach works well for software-based routers, it may be impossible to retrofit devices that do most of their processing in silicon and lack the space or mechanism for timestamping.",
      "ja": "アルゴリズムのCODEL部ごとのパケットのタイムスタンプは、パケットと一緒に格納することが必要です。このアプローチは、ソフトウェアベースのルータに適していますが、シリコンで彼らのほとんどの処理を行うと、タイムスタンプのためのスペースやメカニズムが欠けている機器を改造することは不可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "Also, while perfect resolution is not needed, timestamp resolution finer than the CoDel target setting is necessary. Furthermore, timestamping functions in the core OS need to be efficient, as they are called at least once on each packet enqueue and dequeue.",
      "ja": "完璧な解決が必要とされていないながらも、CODEL目標設定よりもタイムスタンプ細かい分解能が必要です。それらは各パケット・エンキューおよびデキューに少なくとも一度呼び出されるように、さらに、コアOSにタイムスタンプ機能は、効率的である必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. Limiting Queueing in Lower Layers",
      "section_title": true,
      "ja": "5.6. 下位層でキューイングを制限"
    },
    {
      "indent": 3,
      "text": "When deploying a queue management algorithm such as FQ-CoDel, it is important to ensure that the algorithm actually runs in the right place to control the queue. In particular, lower layers of the operating system networking stack can have queues of their own, as can device drivers and hardware. Thus, it is desirable that the queue management algorithm runs as close to the hardware as possible. However, scheduling such complexity at interrupt time is difficult, so a small standing queue between the algorithm and the wire is often needed at higher transmit rates.",
      "ja": "このようFQ-CODELとしてキュー管理アルゴリズムを展開する場合、アルゴリズムが実際にキューを制御するために適切な場所で実行されることを確認することが重要です。具体的には、オペレーティングシステムのネットワークスタックの下位層は、CANデバイスドライバおよびハードウェアとして、彼ら自身のキューを有することができます。したがって、キュー管理アルゴリズムは、可能な限りハードウェアに近い動作することが望ましいです。しかし、割り込み時に、このような複雑さをスケジュールすることは困難であり、そのアルゴリズムとワイヤとの間の小さな立っキューは、多くの場合、より高い送信レートで必要とされています。"
    },
    {
      "indent": 3,
      "text": "In Linux, the mechanism to ensure these different needs are balanced is called \"Byte Queue Limits\" [BQL]; it controls the device driver ring buffer (for physical line rates). For cases where this functionality is not available, the queue can be controlled by means of a software rate limiter such as Hierarchical Token Bucket [HTB] or Hierarchical Fair-Service Curve [HFSC]. The Cake algorithm [CAKE] integrates a software rate limiter for this purpose.",
      "ja": "Linuxでは、これらの異なるニーズがバランスしていることを確認するためのメカニズムは、「バイトキュー制限」[BQL]と呼ばれています。それは（物理回線レートの）デバイスドライバのリングバッファを制御します。この機能が利用できない場合のために、キューは、階層トークンバケット【HTB]または階層フェアサービスカーブ[HFSC]などのソフトウェア・レート・リミッタの手段によって制御することができます。ケーキアルゴリズム[ケーキ]は、この目的のためのソフトウェア・レートリミッタを統合しています。"
    },
    {
      "indent": 3,
      "text": "Other issues with queues at lower layers are described in [CODEL].",
      "ja": "下位層でキューに他の問題が[CODEL]に記載されています。"
    },
    {
      "indent": 0,
      "text": "5.7. Other Forms of Fair Queueing",
      "section_title": true,
      "ja": "5.7. 均等化キューイングの他の形態"
    },
    {
      "indent": 3,
      "text": "Much of the scheduling portion of FQ-CoDel is derived from DRR and is substantially similar to DRR++. Versions based on Stochastic Fair Queueing [SFQ] have also been produced and tested in ns2. Other forms of fair queueing, such as Weighted Fair Queueing [WFQ] or Quick Fair Queueing [QFQ], have not been thoroughly explored, but there's no a priori reason why the round-robin scheduling of FQ-CoDel couldn't be replaced with something else.",
      "ja": "FQ-CODELのスケジューリング部の多くは、DRR由来し、DRR ++と実質的に同様です。確率均等化キューイング[SFQ]に基づいたバージョンもNS2で生産され、テストされています。そのような均等化キューイング[WFQ]またはクイック・フェア・キューイング[QFQ]として公平キューイングの他の形態は、徹底的に調査されていないが、FQ-CODELのラウンドロビンスケジューリングを置き換えることができなかった理由を先験的な理由はありません何か他のもの。"
    },
    {
      "indent": 3,
      "text": "For a comprehensive discussion of fairness queueing algorithms and their combination with AQM, see [RFC7806].",
      "ja": "包括的公正キューイングアルゴリズムの議論とAQMとの組み合わせの場合は、[RFC7806]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Differences between CoDel and FQ-CoDel Behaviour",
      "section_title": true,
      "ja": "5.8.  CODELとFQ-CODELの動作の違い"
    },
    {
      "indent": 3,
      "text": "CoDel can be applied to a single queue system as a straight AQM, where it converges towards an \"ideal\" drop rate (i.e., one that minimises delay while keeping a high link utilisation) and then optimises around that control point.",
      "ja": "CODELは、「理想的な」ドロップ率（高いリンク利用率を維持しつつ、遅延を最小化する、すなわち、1つ）に向かって収束し、その制御点の周囲に最適化直AQM、のような単一のキュー・システムにも適用することができます。"
    },
    {
      "indent": 3,
      "text": "The scheduling of FQ-CoDel mixes packets of competing flows, which acts to pace bursty flows to better fill the pipe. Additionally, a new flow gets substantial leeway over other flows until CoDel finds an ideal drop rate for it. However, for a new flow that exceeds the configured quantum, more time passes before all of its data is delivered (as packets from it, too, are mixed across the other existing queue-building flows). Thus, FQ-CoDel takes longer (as measured in time) to converge towards an ideal drop rate for a given new flow but does so within fewer delivered _packets_ from that flow.",
      "ja": "FQ-CODELのスケジューリングは、より良いパイプを埋めるために、バースト的な流れのペースように作用する、競合するフローのパケットをミックス。 CODELはそれのための理想的なドロップ率を見つけるまでさらに、新しい流れは、他のフローに対する実質的な余裕を取得します。すべてのデータは、（そこからパケットとしても、他の既存のキュー構築を横切って流れる混合される）送達される前に、しかし、構成量子を超える新たなフローのために、より多くの時間が経過します。したがって、FQ-CODELは、与えられた新たなフローのための理想的な降下速度に向かって収束する（時間で測定されるように）時間がかかりますが、その流れから、より少ない送達_packets_内そう。"
    },
    {
      "indent": 3,
      "text": "Finally, the flow isolation provided by FQ-CoDel means that the CoDel drop mechanism operates on the flows actually building queues; this results in packets being dropped more accurately from the largest flows than when only CoDel is used. Additionally, flow isolation radically improves the transient behaviour of the network when traffic or link characteristics change (e.g., when new flows start up or the link bandwidth changes); while CoDel itself can take a while to respond, FQ-CoDel reacts almost immediately.",
      "ja": "最後に、FQ-CODELによって提供される流れ分離はCODEL降下機構は、実際のキューを構築するフローに動作することを意味します。これはCODELを用いた場合よりも最大フローから、より正確にドロップされたパケットになります。 ;さらに、流れ分離は、ラジカルトラフィック又はリンク特性が変化（例えば、新しいフローが起動またはリンク帯域幅が変化するとき）ネットワークの過渡的挙動を改善しますCODEL自体が応答に時間がかかることができますが、FQ-CODELはほとんど即座に反応します。"
    },
    {
      "indent": 0,
      "text": "6. Limitations of Flow Queueing",
      "section_title": true,
      "ja": "フローイングの6.制限事項"
    },
    {
      "indent": 3,
      "text": "While FQ-CoDel has been shown in many scenarios to offer significant performance gains compared to alternative queue management strategies, there are some scenarios where the scheduling algorithm in particular is not a good fit. This section documents some of the known cases in which either the default behaviour may require tweaking or alternatives to flow queueing should be considered.",
      "ja": "FQ-CODELが代替キュー管理戦略に比べて大幅なパフォーマンス向上を提供するために、多くのシナリオで示されているが、特にスケジューリングアルゴリズムが良いフィットされていないいくつかのシナリオがあります。このセクションでは、考慮すべきデフォルトの動作のいずれかが、キューイングを流れるように微調整や代替案が必要なことがあるで知られているいくつかの例を説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Fairness between Things Other Than Flows",
      "section_title": true,
      "ja": "6.1. 物事以外の間の公平性・フロー"
    },
    {
      "indent": 3,
      "text": "In some parts of the network, enforcing flow-level fairness may not be desirable, or some other form of fairness may be more important. Some examples of this include an ISP that may be more interested in ensuring fairness between customers than between flows or a hosting or transit provider that wishes to ensure fairness between connecting Autonomous Systems or networks. Another issue can be that the number of simultaneous flows experienced at a particular link can be too high for flow-based fairness queueing to be effective.",
      "ja": "ネットワークの一部では、フローレベルの公平性を強制することは望ましくないかもしれない、又は公正いくつかの他の形態は、より重要であるかもしれません。このいくつかの例は、フロー又は自律システムまたはネットワークを接続間の公平性を確保したいホストまたはトランジット・プロバイダとの間のより顧客間の公平性を確保する上でより興味がある可能性がありISPが挙げられます。もう一つの問題は、特定のリンクで経験した同時フローの数が有効であることがキューイングフローベースの公平性のための高すぎることができることをすることができます。"
    },
    {
      "indent": 3,
      "text": "Whatever the reason, in a scenario where fairness between flows is not desirable, reconfiguring FQ-CoDel to match on a different characteristic can be a way forward. The implementation in Linux can leverage the packet matching mechanism of the \"tc\" subsystem to use any available packet field to partition packets into virtual queues, for instance, to match on address or subnet source/destination pairs, application-layer characteristics, etc.",
      "ja": "理由が何であれ、フロー間の公平性が望ましくないシナリオでは、異なる特性に一致するようにFQ-CODELを再構成する往路とすることができます。 Linuxで実装等アドレスまたはサブネット送信元/宛先ペア、アプリケーション層の特性に一致するように、例えば、仮想キューにパケットを分割するために任意の利用可能なパケットフィールドを使用する「TC」サブシステムのパケット整合機構を活用することができ"
    },
    {
      "indent": 3,
      "text": "Furthermore, as commonly deployed today, FQ-CoDel is used with three or more tiers of service classification, based on Diffserv markings: priority, best effort, and background. Some products do more detailed classification, including deep packet inspection and destination-specific filters to achieve their desired result.",
      "ja": "優先度、ベストエフォート、および背景：現在一般的に展開してさらに、FQ-CODELはDiffservのマーキングに基づいてサービスの分類、3つの以上の層で使用されます。一部の製品は、それらの所望の結果を達成するために、ディープパケットインスペクションと宛先固有のフィルタを含む、より詳細な分類を行います。"
    },
    {
      "indent": 0,
      "text": "6.2. Flow Bunching by Opaque Encapsulation",
      "section_title": true,
      "ja": "6.2. 不透明なカプセル化によりバンチングフロー"
    },
    {
      "indent": 3,
      "text": "Where possible, FQ-CoDel will attempt to decapsulate packets before matching on the header fields for the flow hashing. However, for some encapsulation techniques, most notably encrypted VPNs, this is not possible. If several flows are bunched into one such encapsulated tunnel, they will be seen as one flow by the FQ-CoDel algorithm. This means that they will share a queue and drop behaviour, so flows inside the encapsulation will not benefit from the implicit prioritisation of FQ-CoDel but will continue to benefit from the reduced overall queue length from the CoDel algorithm operating on the queue. In addition, when such an encapsulated bunch competes against other flows, it will count as one flow and not assigned a share of the bandwidth based on how many flows are inside the encapsulation.",
      "ja": "可能であれば、FQ-CODELフローハッシングのためのヘッダーフィールドに一致する前にパケットをデカプセル化しようとします。しかし、いくつかのカプセル化技術のために、VPNを暗号化し、最も顕著なのは、これは不可能です。いくつかのフローがそのようなカプセル化されたトンネル内に束ねられている場合、それらは、FQ-CODELアルゴリズムずつフローとして理解されるであろう。これは、彼らがキューを共有し、カプセル内部のフローはFQ-CODELの暗黙の優先順位付けの恩恵を受けないであろうが、キュー上で動作CODELアルゴリズムから減少し、全体のキューの長さの恩恵を受けるしていきますので、行動をドロップすることを意味します。そのようなカプセル化された束は、他のフローに対して競合する場合に加えて、それは一つのフローとしてカウントされ、カプセル内にあるどのように多くのフローに基づいて帯域幅のシェアを割り当てられていません。"
    },
    {
      "indent": 3,
      "text": "Depending on the application, this may or may not be desirable behaviour. In cases where it is not, changing FQ-CoDel's matching to not be flow-based (as detailed in the previous subsection above) can be a mitigation. Going forward, having some mechanism for opaque encapsulations to express to the outer layer which flow a packet belongs to could be a way to mitigate this. Naturally, care needs to be taken when designing such a mechanism to ensure no new privacy and security issues are raised by exposing information from inside the encapsulation to the outside world. Keeping the extra information out of band and dropping it before it hits the network could be one way to achieve this.",
      "ja": "アプリケーションに応じて、これは、または望ましい行動であってもなくてもよいです。それは、フローベース（上記前サブセクションで詳述されるように）ではないとFQ-CODELのマッチングを変更されていない場合には緩和することができます。パケットは、これを軽減するための方法であってもよい属する流れ外層に表現する不透明なカプセル化のためのいくつかの機構を有する、今後。新しいプライバシーとセキュリティの問題が外の世界にカプセル内部からの情報を暴露することによって提起されていないことを確認するために、このような仕組みを設計する際に当然のことながら、注意が必要です。帯域外の余分な情報を維持し、それは、ネットワークがこれを達成する一つの方法かもしれヒットする前にそれをドロップします。"
    },
    {
      "indent": 0,
      "text": "6.3. Low-Priority Congestion Control Algorithms",
      "section_title": true,
      "ja": "6.3. 優先度の低い輻輳制御アルゴリズム"
    },
    {
      "indent": 3,
      "text": "In the presence of queue management schemes that limit latency under load, low-priority congestion control algorithms such as Low Extra Delay Background Transport (LEDBAT) [RFC6817] (or, in general, algorithms that try to voluntarily use up less than their fair share of bandwidth) experience little added latency when the link is congested. Thus, they lack the signal to back off that added latency previously afforded them. This effect is seen with FQ-CoDel as well as with any effective AQM [GONG2014].",
      "ja": "負荷の下での待ち時間を制限するキュー管理スキームは、そのような低余分な遅延の背景トランスポートなどの低優先度の輻輳制御アルゴリズム（LEDBAT）[RFC6817]（または、自発的に公正な取り分未満を使用しようとする一般的には、アルゴリズムの存在下ではリンクが混雑している時に、帯域幅の）経験が少しの待ち時間を追加しました。このように、彼らは追加の待ち時間が以前にそれらを与えたことをバックオフする信号を欠いています。この効果は、FQ-CODELと同様に任意の有効なAQM [GONG2014]で見られます。"
    },
    {
      "indent": 3,
      "text": "As such, these delay-based algorithms tend to revert to loss-based congestion control and will consume the fair share of bandwidth afforded to them by the FQ-CoDel scheduler. However, low-priority congestion control mechanisms may be able to take steps to continue to be low priority, for instance, by taking into account the vastly reduced level of delay afforded by an AQM or by using a coupled approach to observing the behaviour of multiple flows.",
      "ja": "このように、これらの遅延ベースのアルゴリズムは、損失ベースの輻輳制御に復帰する傾向があり、FQ-CODELスケジューラによってそれらに与えられる帯域幅の公平な分配を消費します。しかしながら、低優先輻輳制御メカニズムは、例えば、アカウントにAQMによって、または複数の挙動を観察するに結合されたアプローチを使用して得た遅延の非常に低いレベルをとることによって、低優先度であることを継続する手順を実行することができるかもしれません流れ。"
    },
    {
      "indent": 0,
      "text": "7. Deployment Status and Future Work",
      "section_title": true,
      "ja": "7.展開状況と今後の課題"
    },
    {
      "indent": 3,
      "text": "The FQ-CoDel algorithm as described in this document has been shipped as part of the Linux kernel since version 3.5 (released on the 21st of July, 2012), with the ce_threshold being added in version 4.2. The algorithm has seen widespread testing in a variety of contexts and is configured as the default queueing discipline in a number of mainline Linux distributions (as of this writing, at least OpenWRT, Arch Linux, and Fedora). In addition, a BSD implementation is available. All data resulting from these trials have shown FQ-CoDel to be a massive improvement over the previous default FIFO queue, and people are encouraged to turn it on.",
      "ja": "FQ-CODELアルゴリズムこの文書で説明したようにce_thresholdは、バージョン4.2で追加された状態で、（7月、2012年の21日にリリース）バージョン3.5以降のLinuxカーネルの一部として出荷されています。このアルゴリズムは、様々な状況に広範なテストを見ていると（これを書いている時点では、少なくともOpenWrtの、アーチのLinux、およびFedoraの）メインラインのLinuxディストリビューションの数に規律をキューイングデフォルトとして設定されています。また、BSDの実装が可能です。これらの試験から生じたすべてのデータは、以前のデフォルトのFIFOキューを超える大規模な改善であることをFQ-CODELを示している、と人々はそれをオンにすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Of course, there is always room for improvement, and this document has listed some of the known limitations of the algorithm. As such, we encourage further research into algorithm refinements and addressing of limitations. One such effort has been undertaken by the bufferbloat community in the form of the Cake queue management scheme [CAKE]. In addition to this, we believe the following (non-exhaustive) list of issues to be worthy of further enquiry:",
      "ja": "もちろん、そこには常に改善の余地あり、この文書は、アルゴリズムの既知の制限のいくつかをリストされています。そのため、我々はアルゴリズムの改良にさらなる研究を奨励し、制限のアドレッシング。そのような努力はケーキキュー管理スキーム[ケーキ]の形でbufferbloatコミュニティによって行われてきました。これに加えて、我々は問題の次（非網羅）リストはさらに、問い合わせの価値があると信じています："
    },
    {
      "indent": 3,
      "text": "o Variations on the flow classification mechanism to fit different notions of flows. For instance, an ISP might want to deploy per-subscriber scheduling, while in other cases, several flows can share a 5-tuple, as exemplified by the RTCWEB QoS recommendations [WEBRTC-QOS].",
      "ja": "流れの異なる概念を合わせてフロー分類メカニズム上のOバリエーション。例えば、ISPはRTCWEB QoSの推奨[のWebRTC-QOS]によって例示されるような他の場合には、いくつかのフローは、5タプルを共有することができながら、毎加入者スケジュールを展開するかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Interactions between flow queueing and delay-based congestion control algorithms and scavenger protocols.",
      "ja": "フローキューイングおよび遅延ベースの輻輳制御アルゴリズムとスカベンジャープロトコル間の相互作用O。"
    },
    {
      "indent": 3,
      "text": "o Other scheduling mechanisms to replace the DRR portion of the algorithm, e.g., QFQ or WFQ.",
      "ja": "アルゴリズムのDRR部分を置換する他のスケジューリングメカニズム、例えば、QFQ又はWFQ O。"
    },
    {
      "indent": 3,
      "text": "o Sensitivity of parameters, most notably, the number of queues and the CoDel parameters.",
      "ja": "O感度パラメータの、最も顕著なのは、キューの数とCODELパラメータ。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "There are no specific security exposures associated with FQ-CoDel that are not also present in current FIFO systems. On the contrary, some vulnerabilities of FIFO systems are reduced with FQ-CoDel (e.g., simple minded packet floods). However, some care is needed in the implementation to ensure this is the case. These are included in the description above, but we reiterate them here:",
      "ja": "また、現在のFIFOシステムに存在しないFQ-CODELに関連付けられた特定のセキュリティ・エクスポージャーはありません。逆に、FIFOシステムのいくつかの脆弱性は、FQ-CODEL（例えば、単純な心パケットフラッド）で還元されています。しかし、いくつかの注意がそうであることを確認するために、実装に必要とされています。これらは、上記の説明に含まれますが、ここではそれらを繰り返すされています。"
    },
    {
      "indent": 3,
      "text": "o To prevent packets in the new queues from starving old queues, it is important that when a queue on the list of new queues empties, it is moved to _the end of_ the list of old queues. This is described at the end of Section 4.2.",
      "ja": "古いキューを飢えから新しいキューのパケットを防ぐためにoが、新しいキューのリスト上のキューが、それは古いキューのリストOF_ _The最後に移動したときに空にすることが重要です。これは、4.2節の末尾に記載されています。"
    },
    {
      "indent": 3,
      "text": "o To prevent an attacker targeting a specific flow for a denial-of-service attack, the hash that maps packets to queues should not be predictable. To achieve this, FQ-CoDel salts the hash, as described in the beginning of Section 4.1. The size of the salt and the strength of the hash function is obviously a trade-off between performance and security. The Linux implementation uses a 32-bit random value as the salt and a Jenkins hash function. This makes it possible to achieve high throughput, and we consider it sufficient to ward off the most obvious attacks.",
      "ja": "サービス拒否攻撃のための具体的な流れをターゲットに攻撃を防止するために、O、キューにパケットをマッピングし、ハッシュは予測すべきではありません。これを達成するために、FQ-CODEL塩ハッシュ、4.1節の冒頭で説明したように。塩のサイズとハッシュ関数の強度は明らかに、パフォーマンスとセキュリティの間のトレードオフです。 Linuxの実装は、塩およびジェンキンスハッシュ関数として、32ビットのランダム値を使用します。これにより、高いスループットを達成することを可能にする、と我々はそれが十分で最も明白な攻撃を撃退するために検討してください。"
    },
    {
      "indent": 3,
      "text": "o Packet fragments without a Layer 4 header can be hashed into different bins than the first fragment with the header intact. This can cause reordering and/or adversely affect the performance of the flow. Keeping state to match the fragments to the beginning of the packet or simply putting all packet fragments (including the first fragment of each fragmented packet) into the same queue are two ways to alleviate this.",
      "ja": "Oレイヤ4ヘッダなしでパケットのフラグメントは、無傷のヘッダと最初のフラグメントとは異なるビンにハッシュすることができます。これは、並べ替え原因および/または悪影響フローのパフォーマンスに影響を与えることができます。パケットの先頭に断片に一致するように状態を維持するか、単に同じキューに（各断片化されたパケットの最初のフラグメントを含む）すべてのパケットフラグメントを置くことは、これを軽減するには、2つの方法があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7806] Baker, F. and R. Pan, \"On Queuing, Marking, and Dropping\", RFC 7806, DOI 10.17487/RFC7806, April 2016, <https://www.rfc-editor.org/info/rfc7806>.",
      "ja": "[RFC7806]ベーカー、F. R.及びパン、 \"キューに、マーキング、および削除\"、RFC 7806、DOI 10.17487 / RFC7806、2016年4月、<https://www.rfc-editor.org/info/rfc7806> 。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8289] Nichols, K., Jacobson, V., McGregor, A., Ed., and J. Iyengar, Ed., \"Controlled Delay Active Queue Management\", RFC 8289, DOI 10.17487/RFC8289, January 2018, <https://www.rfc-editor.org/info/rfc8289>.",
      "ja": "[RFC8289]ニコルズ、K.、ヤコブソン、V.、マクレガー、A.、エド。、およびJ.アイアンガー、エド。、 \"制御された遅延アクティブキュー管理\"、RFC 8289、DOI 10.17487 / RFC8289、2018年1月、<HTTPS ：//www.rfc-editor.org/info/rfc8289>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BLOAT] Gettys, J. and K. Nichols, \"Bufferbloat: Dark Buffers in the Internet\", Communications of the ACM, Volume 55, Issue 1, DOI 10.1145/2063176.2063196, January 2012.",
      "ja": "【BLOAT]ゲティス、J.及びK.ニコルズ、 \"Bufferbloat：インターネットにおけるダークバッファ\"、ACMのコミュニケーション、55巻、1号、DOI 10.1145 / 2063176.2063196、2012年1月。"
    },
    {
      "indent": 3,
      "text": "[BLOATWEB] \"Bufferbloat\", <https://www.bufferbloat.net>.",
      "ja": "[BLOATWEB] \"Bufferbloat\"、<https://www.bufferbloat.net>。"
    },
    {
      "indent": 3,
      "text": "[BQL] Herbert, T., \"bql: Byte Queue Limits\", August 2011, <https://lwn.net/Articles/454378/>.",
      "ja": "[BQL]ハーバート、T.、 \"BQL：バイトキュー制限\"、2011年8月、<https://lwn.net/Articles/454378/>。"
    },
    {
      "indent": 3,
      "text": "[CAKE] \"Cake - Common Applications Kept Enhanced\", <http://www.bufferbloat.net/projects/codel/wiki/Cake>.",
      "ja": "[ケーキ] \"ケーキ - 拡張を保持一般的なアプリケーション\"、<http://www.bufferbloat.net/projects/codel/wiki/Cake>。"
    },
    {
      "indent": 3,
      "text": "[CODEL] Nichols, K. and V. Jacobson, \"Controlling Queue Delay\", ACM Queue, Volume 10, Issue 5, DOI 10.1145/2208917.2209336, May 2012, <http://queue.acm.org/detail.cfm?id=2209336>.",
      "ja": "[CODEL]ニコルズ、K.およびV. Jacobson氏、 \"制御しているキュー遅延\"、ACMキュー、10巻は、第5号、DOI 10.1145 / 2208917.2209336、2012年5月、<http://queue.acm.org/detail.cfm？ ID = 2209336>。"
    },
    {
      "indent": 3,
      "text": "[DRR] Shreedhar, M. and G. Varghese, \"Efficient Fair Queueing Using Deficit Round Robin\", IEEE/ACM Transactions on Networking, Volume 4, Issue 3, DOI 10.1109/90.502236, June 1996.",
      "ja": "【DRR] Shreedhar、M.およびG. Varghese、 \"効率的な均等化キューイング使用不足ラウンドロビン\"、ネットワーキング、4巻、第3号のIEEE / ACMトランザクション、DOI 10.1109 / 90.502236、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[DRRPP] MacGregor, M. and W. Shi, \"Deficits for Bursty Latency-Critical Flows: DRR++\", Proceedings of the IEEE International Conference on Networks 2000 (ICON 2000), DOI 10.1109/ICON.2000.875803, September 2000, <http://ieeexplore.ieee.org/xpls/ abs_all.jsp?arnumber=875803>.",
      "ja": "[DRRPP]マクレガー、M.およびW.市、 \"バースト性レイテンシークリティカルフローのための赤字：DRR ++\"、ネットワーク上のIEEE国際会議の議事録（ICON 2000）2000、DOI 10.1109 / ICON.2000.875803、2000年9月、<HTTP ：？//ieeexplore.ieee.org/xpls/ abs_all.jsp arnumber = 875803>。"
    },
    {
      "indent": 3,
      "text": "[GONG2014] Gong, Y., Rossi, D., Testa, C., Valenti, S., and D. Taht, \"Fighting the bufferbloat: On the coexistence of AQM and low priority congestion control\", Elsevier Computer Networks, Volume 65, DOI 10.1016/j.bjp.2014.01.009, June 2014, <https://www.sciencedirect.com/science/article/pii/ S1389128614000188>.",
      "ja": "【GONG2014]ゴング、Y.、ロッシ、D.、テスタ、C.、バレン、S.、およびD. Taht、 \"bufferbloatファイティング：AQMの共存および低優先輻輳制御に\"、エルゼビアコンピュータネットワーク、ボリューム65、DOI 10.1016 / j.bjp.2014.01.009、2014年6月、<https://www.sciencedirect.com/science/article/pii/ S1389128614000188>。"
    },
    {
      "indent": 3,
      "text": "[HFSC] Stoica, I., Zhang, H., and T. Eugene Ng, \"A Hierarchical Fair Service Curve Algorithm for Link-Sharing, Real-Time and Priority Services\", Proceedings of ACM SIGCOMM, DOI 10.1145/263105.263175, September 1997, <http://conferences.sigcomm.org/sigcomm/1997/papers/ p011.pdf>.",
      "ja": "[HFSC]ストイカ、I.、張、H.、およびT.ユージンン、「リンクの共有、リアルタイムと優先サービスのための階層的なフェアサービスカーブアルゴリズム」、ACM SIGCOMM、DOI 10.1145 / 263105.263175、9月の議事録1997年、<http://conferences.sigcomm.org/sigcomm/1997/papers/ p011.pdf>。"
    },
    {
      "indent": 3,
      "text": "[HTB] Wikipedia, \"Token Bucket: Variations\", October 2017, <https://en.wikipedia.org/w/ index.php?title=Token_bucket&oldid=803574657>.",
      "ja": "[HTB]ウィキペディア、 \"トークンバケット：変奏曲\"、2017年10月、<https://en.wikipedia.org/w/ index.phpのタイトル= Token_bucket＆oldid = 803574657？>。"
    },
    {
      "indent": 3,
      "text": "[JENKINS] Jenkins, B., \"A Hash Function for Hash Table Lookup\", <http://www.burtleburtle.net/bob/hash/doobs.html>.",
      "ja": "[JENKINS]ジェンキンス、B.、 \"ハッシュテーブルルックアップのハッシュ関数\"、<http://www.burtleburtle.net/bob/hash/doobs.html>。"
    },
    {
      "indent": 3,
      "text": "[LINUXSRC] \"Linux Kernel Source Tree\", <https://git.kernel.org/cgit/l inux/kernel/git/torvalds/linux.git/tree/net/sched/ sch_fq_codel.c>.",
      "ja": "[LINUXSRC] \"Linuxカーネルソースツリー\"、<https://git.kernel.org/cgit/l inux /カーネル/ gitの/ Torvalds氏/ linux.git /木/ネット/ SCHED / sch_fq_codel.c>。"
    },
    {
      "indent": 3,
      "text": "[NS2] \"ns-2\", December 2014, <http://nsnam.sourceforge.net/wiki/ index.php?title=Main_Page&oldid=8076>.",
      "ja": "[NS2] \"NS-2\"、2014年12月、<http://nsnam.sourceforge.net/wiki/のindex.php？タイトル= Main_Page＆oldid = 8076>。"
    },
    {
      "indent": 3,
      "text": "[NS3] \"ns-3\", February 2016, <https://www.nsnam.org/mediawiki/ index.php?title=Main_Page&oldid=9883>.",
      "ja": "[NS3] \"NS-3\"、2016年2月、<https://www.nsnam.org/mediawiki/のindex.php？タイトル= Main_Page＆oldid = 9883>。"
    },
    {
      "indent": 3,
      "text": "[QFQ] Checconi, F., Rizzo, L., and P. Valente, \"QFQ: Efficient Packet Scheduling with Tight Guarantees\", IEEE/ACM Transactions on Networking (TON), Volume 21, Issue 3, pp. 802-816, DOI 10.1109/TNET.2012.2215881, June 2013, <http://dl.acm.org/citation.cfm?id=2525552>.",
      "ja": "【QFQ] Checconi、F.、リゾー、L.、およびP.ヴァレンテ、：、ネットワーク（TON）上のIEEE / ACMトランザクション、21巻、3号、PP \"QFQタイト保証と効率的なパケットスケジューリング\" 802から816。 、DOI 10.1109 / TNET.2012.2215881、2013年6月、<http://dl.acm.org/citation.cfm?id=2525552>。"
    },
    {
      "indent": 3,
      "text": "[RFC2003] Perkins, C., \"IP Encapsulation within IP\", RFC 2003, DOI 10.17487/RFC2003, October 1996, <https://www.rfc-editor.org/info/rfc2003>.",
      "ja": "[RFC2003]パーキンス、C.、 \"IP内IPカプセル化\"、RFC 2003、DOI 10.17487 / RFC2003、1996年10月、<https://www.rfc-editor.org/info/rfc2003>。"
    },
    {
      "indent": 3,
      "text": "[RFC2890] Dommety, G., \"Key and Sequence Number Extensions to GRE\", RFC 2890, DOI 10.17487/RFC2890, September 2000, <https://www.rfc-editor.org/info/rfc2890>.",
      "ja": "[RFC2890] Dommety、G.、 \"GREのキーと一連番号拡大\"、RFC 2890、DOI 10.17487 / RFC2890、2000年9月、<https://www.rfc-editor.org/info/rfc2890>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：//でWWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC4213] Nordmark, E. and R. Gilligan, \"Basic Transition Mechanisms for IPv6 Hosts and Routers\", RFC 4213, DOI 10.17487/RFC4213, October 2005, <https://www.rfc-editor.org/info/rfc4213>.",
      "ja": "[RFC4213] Nordmarkと、E.およびR.ギリガン、 \"IPv6ホストとルータのための基本的な移行メカニズム\"、RFC 4213、DOI 10.17487 / RFC4213、2005年10月、<https://www.rfc-editor.org/info/rfc4213 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, \"Low Extra Delay Background Transport (LEDBAT)\", RFC 6817, DOI 10.17487/RFC6817, December 2012, <https://www.rfc-editor.org/info/rfc6817>.",
      "ja": "[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 \"低余分な遅延の背景トランスポート（LEDBAT）\"、RFC 6817、DOI 10.17487 / RFC6817、2012年12月、<https：//でwww.rfc-editor.org/info/rfc6817>。"
    },
    {
      "indent": 3,
      "text": "[RFC8257] Bensley, S., Thaler, D., Balasubramanian, P., Eggert, L., and G. Judd, \"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers\", RFC 8257, DOI 10.17487/RFC8257, October 2017, <https://www.rfc-editor.org/info/rfc8257>.",
      "ja": "[RFC8257] Bensley、S.、ターラー、D.、Balasubramanian、P.、Eggertの、L.、及びG.ジャッド、 \"データセンターTCP（DCTCP）：データセンターのためのTCP輻輳制御\"、RFC 8257、DOI 10.17487 / RFC8257、2017年10月、<https://www.rfc-editor.org/info/rfc8257>。"
    },
    {
      "indent": 3,
      "text": "[SFQ] McKenney, P., \"Stochastic Fairness Queueing\", Proceedings of IEEE INFOCOM, DOI 10.1109/INFCOM.1990.91316, June 1990, <http://perso.telecom-paristech.fr/~bonald/Publications_files/BMO2011.pdf>.",
      "ja": "[SFQ] McKenney、P.、 \"確率的公正キューイング\"、IEEE INFOCOM、DOI 10.1109 / INFCOM.1990.91316、1990年6月、<http://perso.telecom-paristech.fr/~bonald/Publications_files/BMO2011.pdfの議事録>。"
    },
    {
      "indent": 3,
      "text": "[SQF] Carofiglio, G. and L. Muscariello, \"On the Impact of TCP and Per-Flow Scheduling on Internet Performance\", IEEE/ACM Transactions on Networking, Volume 20, Issue 2, DOI 10.1109/TNET.2011.2164553, August 2011.",
      "ja": "[SQF] Carofiglio、G.とL. Muscariello、 \"インターネットのパフォーマンス上のTCPのとのフローごとのスケジュールへの影響について\"、ネットワーキング、20巻、2号、DOI 10.1109 / TNET.2011.2164553、2011年8月にIEEEが/ ACM取引。"
    },
    {
      "indent": 3,
      "text": "[WEBRTC-QOS] Jones, P., Dhesikan, S., Jennings, C., and D. Druta, \"DSCP Packet Markings for WebRTC QoS\", Work in Progress, draft-ietf-tsvwg-rtcweb-qos-18, August 2016.",
      "ja": "【のWebRTC-QOS]ジョーンズ、P.、Dhesikan、S.、ジェニングス、C.、およびD. Druta \"のWebRTC QoSのDSCPパケットマーキング\"、進行中で働いて、ドラフトIETF-TSVWG-rtcweb-QOS-18、 2016年8月。"
    },
    {
      "indent": 3,
      "text": "[WFQ] Demers, A., Keshav, S., and S. Shenker, \"Analysis and Simulation of a Fair Queueing Algorithm\", ACM SIGCOMM Computer Communication Review, Volume 19, Issue 4, pp. 1-12, DOI 10.1145/75247.75248, September 1989, <http://doi.acm.org/10.1145/75247.75248>.",
      "ja": "[WFQ]デマーズ、A.、Keshav、S.、およびS. Shenker、 \"分析と公平キューイングアルゴリズムのシミュレーション\"、ACM SIGCOMMコンピュータコミュニケーションレビュー、第19巻、第4号、頁1-12、DOI 10.1145 / 75247.75248、1989年9月、<http://doi.acm.org/10.1145/75247.75248>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Our deepest thanks to Kathie Nichols, Van Jacobson, and all the members of the bufferbloat.net effort for all the help on developing and testing the algorithm. In addition, our thanks to Anil Agarwal for his help with getting the hash collision probabilities in this document right.",
      "ja": "アルゴリズムを開発およびテストのすべての助けのためのキャシーニコルズ、バン・ジェイコブソン、およびbufferbloat.netの努力のすべてのメンバーに心から感謝します。また、この文書の右にハッシュ衝突確率を取得して彼の助けのためのアニルAgarwalさんに感謝。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Toke Hoeiland-Joergensen Karlstad University Dept. of Computer Science Karlstad 65188 Sweden Email: toke@toke.dk",
      "ja": "コンピュータサイエンスカールスタードの土気Hoeiland-Joergensenカールスタード大学部門65188スウェーデンメールアドレス：toke@toke.dk"
    },
    {
      "indent": 3,
      "text": "Paul McKenney IBM Linux Technology Center 1385 NW Amberglen Parkway Hillsboro, OR 97006 United States of America Email: paulmck@linux.vnet.ibm.com URI: http://www2.rdrop.com/~paulmck/",
      "ja": "ポールMcKenney IBMのLinuxテクノロジー・センター1385 NW Amberglenパークウェイヒルズボロ、OR 97006アメリカ合衆国Eメール：paulmck@linux.vnet.ibm.com URI：http://www2.rdrop.com/~paulmck/"
    },
    {
      "indent": 3,
      "text": "Dave Taht Teklibre 2104 W First street Apt 2002 FT Myers, FL 33901 United States of America Email: dave.taht@gmail.com URI: http://www.teklibre.com/",
      "ja": "デイブTaht Teklibre 2104 W最初の通りアプト2002 FTマイヤーズ、FL 33901アメリカ合衆国Eメール：dave.taht@gmail.com URI：http://www.teklibre.com/"
    },
    {
      "indent": 3,
      "text": "Jim Gettys 21 Oak Knoll Road Carlisle, MA 993 United States of America Email: jg@freedesktop.org URI: https://en.wikipedia.org/wiki/Jim_Gettys",
      "ja": "ジム・ゲティーズ21オークノール道路カーライル、MA 993アメリカ合衆国Eメール：jg@freedesktop.org URI：https://en.wikipedia.org/wiki/Jim_Gettys"
    },
    {
      "indent": 3,
      "text": "Eric Dumazet Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States of America Email: edumazet@gmail.com",
      "ja": "エリックDumazetグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043アメリカ合衆国Eメール：edumazet@gmail.com"
    }
  ]
}