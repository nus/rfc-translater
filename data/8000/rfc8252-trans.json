{
  "title": {
    "text": "RFC 8252 - OAuth 2.0 for Native Apps",
    "ja": "RFC 8252 - ネイティブアプリのOAuth 2.0"
  },
  "number": 8252,
  "created_at": "2019-10-27 11:54:04.202430+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        W. Denniss\nRequest for Comments: 8252                                        Google\nBCP: 212                                                      J. Bradley\nUpdates: 6749                                              Ping Identity\nCategory: Best Current Practice                             October 2017\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 23,
      "text": "OAuth 2.0 for Native Apps",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 authorization requests from native apps should only be made through external user-agents, primarily the user's browser. This specification details the security and usability reasons why this is the case and how native apps and authorization servers can implement this best practice.",
      "ja": "ネイティブアプリケーションからOAuth 2.0の認証要求は、外部ユーザーエージェント、主にユーザーのブラウザを介して行われるべきです。この仕様は、このような場合は、どのようにネイティブアプリケーションと許可サーバこのベストプラクティスを実装することができ、なぜセキュリティと使いやすさの理由を詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo documents an Internet Best Current Practice.",
      "ja": "このメモはインターネット最も良い現在の練習を説明します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 BCPの詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8252.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8252で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Notational Conventions  . . . . . . . . . . . . . . . . . . .   3\n3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3\n4.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n  4.1.  Authorization Flow for Native Apps Using the Browser  . .   5\n5.  Using Inter-App URI Communication for OAuth . . . . . . . . .   6\n6.  Initiating the Authorization Request from a Native App  . . .   6\n7.  Receiving the Authorization Response in a Native App  . . . .   7\n  7.1.  Private-Use URI Scheme Redirection  . . . . . . . . . . .   8\n  7.2.  Claimed \"https\" Scheme URI Redirection  . . . . . . . . .   9\n  7.3.  Loopback Interface Redirection  . . . . . . . . . . . . .   9\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  10\n  8.1.  Protecting the Authorization Code . . . . . . . . . . . .  10\n  8.2.  OAuth Implicit Grant Authorization Flow . . . . . . . . .  11\n  8.3.  Loopback Redirect Considerations  . . . . . . . . . . . .  11\n  8.4.  Registration of Native App Clients  . . . . . . . . . . .  12\n  8.5.  Client Authentication . . . . . . . . . . . . . . . . . .  12\n  8.6.  Client Impersonation  . . . . . . . . . . . . . . . . . .  13\n  8.7.  Fake External User-Agents . . . . . . . . . . . . . . . .  13\n  8.8.  Malicious External User-Agents  . . . . . . . . . . . . .  14\n  8.9.  Cross-App Request Forgery Protections . . . . . . . . . .  14\n  8.10. Authorization Server Mix-Up Mitigation  . . . . . . . . .  14\n  8.11. Non-Browser External User-Agents  . . . . . . . . . . . .  15\n  8.12. Embedded User-Agents  . . . . . . . . . . . . . . . . . .  15\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  16\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  16\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  17\nAppendix A.  Server Support Checklist . . . . . . . . . . . . . .  18\nAppendix B.  Platform-Specific Implementation Details . . . . . .  18\n  B.1.  iOS Implementation Details  . . . . . . . . . . . . . . .  18\n  B.2.  Android Implementation Details  . . . . . . . . . . . . .  19\n  B.3.  Windows Implementation Details  . . . . . . . . . . . . .  19\n  B.4.  macOS Implementation Details  . . . . . . . . . . . . . .  20\n  B.5.  Linux Implementation Details  . . . . . . . . . . . . . .  21\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  21\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Section 9 of the OAuth 2.0 authorization framework [RFC6749] documents two approaches for native apps to interact with the authorization endpoint: an embedded user-agent and an external user-agent.",
      "ja": "埋め込まれたユーザ・エージェントおよび外部ユーザーエージェント：OAuth 2.0の承認フレームワークのセクション9は、[RFC6749]の文書がネイティブアプリケーションのための2つのアプローチが許可エンドポイントと相互作用します。"
    },
    {
      "indent": 3,
      "text": "This best current practice requires that only external user-agents like the browser are used for OAuth by native apps. It documents how native apps can implement authorization flows using the browser as the preferred external user-agent as well as the requirements for authorization servers to support such usage.",
      "ja": "この現在のベストプラクティスは、ブラウザのような唯一の外部ユーザーエージェントは、ネイティブアプリケーションでOAuthのた​​めに使用されていることが必要です。これは、ネイティブアプリが承認は、そのような使用をサポートするために有利な外部のユーザーエージェントとしてブラウザだけでなく、認可サーバの要件を使用してフローを実装する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "This practice is also known as the \"AppAuth pattern\", in reference to open-source libraries [AppAuth] that implement it.",
      "ja": "この方法はまた、「AppAuthパターン」、それを実装基準にするオープンソースのライブラリ[AppAuth]として知られています。"
    },
    {
      "indent": 0,
      "text": "2. Notational Conventions",
      "section_title": true,
      "ja": "2.表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "In addition to the terms defined in referenced specifications, this document uses the following terms:",
      "ja": "参照仕様で定義された用語に加えて、この文書は、次の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "\"native app\" An app or application that is installed by the user to their device, as distinct from a web app that runs in the browser context only. Apps implemented using web-based technology but distributed as a native app, so-called \"hybrid apps\", are considered equivalent to native apps for the purpose of this specification.",
      "ja": "「ネイティブアプリケーション」のみブラウザコンテキストで実行するWebアプリケーションとは異なるように、それらのデバイスにユーザによってインストールされるアプリケーションやアプリケーション。アプリは、Webベースの技術を使用して実装が、ネイティブアプリとして配布、いわゆる「ハイブリッドアプリケーション」、本明細書の目的のためのネイティブアプリケーションと同等であると考えられます。"
    },
    {
      "indent": 3,
      "text": "\"app\" A \"native app\" unless further specified.",
      "ja": "さらに、指定されない限り、「アプリ」「ネイティブアプリ」。"
    },
    {
      "indent": 3,
      "text": "\"app store\" An e-commerce store where users can download and purchase apps.",
      "ja": "「アプリストア」ユーザーがアプリをダウンロードして購入することができ、eコマースストア。"
    },
    {
      "indent": 3,
      "text": "\"OAuth\" Authorization protocol specified by the OAuth 2.0 Authorization Framework [RFC6749].",
      "ja": "OAuth 2.0の認証フレームワーク[RFC6749]で指定された「OAuthの」認可プロトコル。"
    },
    {
      "indent": 3,
      "text": "\"external user-agent\" A user-agent capable of handling the authorization request that is a separate entity or security domain to the native app making the request, such that the app cannot access the cookie storage, nor inspect or modify page content.",
      "ja": "「外部ユーザー・エージェント」アプリは、クッキーストレージにアクセス、また検査やページのコンテンツを変更できないように、要求を、作るネイティブアプリとは別のエンティティまたはセキュリティドメインで認証要求を処理できるユーザーエージェント。"
    },
    {
      "indent": 3,
      "text": "\"embedded user-agent\" A user-agent hosted by the native app making the authorization request that forms a part of the app or shares the same security domain such that the app can access the cookie storage and/or inspect or modify page content.",
      "ja": "「組み込みユーザーエージェント」のアプリやアプリはクッキーストレージにアクセスおよび/または点検やページのコンテンツを変更することができ、同じセキュリティドメインように株式の一部を構成する認証要求を行うネイティブアプリによってホストされているユーザエージェント。"
    },
    {
      "indent": 3,
      "text": "\"browser\" The default application launched by the operating system to handle \"http\" and \"https\" scheme URI content.",
      "ja": "「ブラウザ」「http」と「https」スキームURIのコンテンツを処理するために、オペレーティング・システムによって起動デフォルトアプリケーション。"
    },
    {
      "indent": 3,
      "text": "\"in-app browser tab\" A programmatic instantiation of the browser that is displayed inside a host app but that retains the full security properties and authentication state of the browser. It has different platform-specific product names, several of which are detailed in Appendix B.",
      "ja": "「アプリ内のブラウザタブ」ホストアプリ内で表示されますが、それは完全なセキュリティ特性やブラウザの認証状態を保持しているブラウザのプログラムでインスタンス化。これは、付録Bで詳しく説明されているそのうちのいくつかの異なるプラットフォーム固有の製品名を、持っています"
    },
    {
      "indent": 3,
      "text": "\"web-view\" A web browser UI (user interface) component that is embedded in apps to render web pages under the control of the app.",
      "ja": "「ウェブビュー」アプリケーションの制御下でウェブページをレンダリングするアプリケーションに埋め込まれているウェブブラウザUI（ユーザインタフェース）コンポーネント。"
    },
    {
      "indent": 3,
      "text": "\"inter-app communication\" Communication between two apps on a device.",
      "ja": "デバイス上の2つのアプリケーション間の「相互のアプリ通信」の通信。"
    },
    {
      "indent": 3,
      "text": "\"claimed \"https\" scheme URI\" Some platforms allow apps to claim an \"https\" scheme URI after proving ownership of the domain name. URIs claimed in such a way are then opened in the app instead of the browser.",
      "ja": "一部のプラットフォームでは、アプリは、ドメイン名の所有権を証明した後に「https」のスキームURIを請求することができます。https「スキームURI 『を』主張」。 URIは、代わりに、ブラウザのアプリで開くように主張しました。"
    },
    {
      "indent": 3,
      "text": "\"private-use URI scheme\" As used by this document, a URI scheme defined by the app (following the requirements of Section 3.8 of [RFC7595]) and registered with the operating system. URI requests to such schemes launch the app that registered it to handle the request.",
      "ja": "「私的利用URIスキーム」この文書で使用されるように、URIスキームは（[RFC7595]のセクション3.8の要件以下）アプリケーションによって定義され、オペレーティングシステムに登録されました。そのようなスキームのURI要求は、要求を処理するために、それを登録してアプリを起動します。"
    },
    {
      "indent": 3,
      "text": "\"reverse domain name notation\" A naming convention based on the domain name system, but one where the domain components are reversed, for example, \"app.example.com\" becomes \"com.example.app\".",
      "ja": "「逆ドメイン名表記」ドメインネームシステムに基づく命名規則が、ドメイン成分は、例えば、反転された1つは、「app.example.com」は「com.example.app」となります。"
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "ja": "4.概要"
    },
    {
      "indent": 3,
      "text": "For authorizing users in native apps, the best current practice is to perform the OAuth authorization request in an external user-agent (typically the browser) rather than an embedded user-agent (such as one implemented with web-views).",
      "ja": "ネイティブアプリケーションでユーザーを認証するために、現在のベストプラクティスは、外部のユーザーエージェントでのOAuth認証要求（通常はブラウザ）ではなく、埋め込まれたユーザエージェント（ウェブビューで実装のようなもの）を実行することです。"
    },
    {
      "indent": 3,
      "text": "Previously, it was common for native apps to use embedded user-agents (commonly implemented with web-views) for OAuth authorization requests. That approach has many drawbacks, including the host app being able to copy user credentials and cookies as well as the user needing to authenticate from scratch in each app. See Section 8.12",
      "ja": "ネイティブアプリがOAuthの認証要求のために（一般のWebビューで実装）埋め込まれたユーザーエージェントを使用するために以前は、それが一般的でした。このアプローチは、ホストアプリがユーザーの資格情報やクッキーなど、各アプリでゼロからの認証に必要ユーザーをコピーすることができることなど、多くの欠点を持っています。セクション8.12を参照してください。"
    },
    {
      "indent": 3,
      "text": "for a deeper analysis of the drawbacks of using embedded user-agents for OAuth.",
      "ja": "OAuthのた​​めの組み込みユーザーエージェントを使用しての欠点のより深い分析のため。"
    },
    {
      "indent": 3,
      "text": "Native app authorization requests that use the browser are more secure and can take advantage of the user's authentication state. Being able to use the existing authentication session in the browser enables single sign-on, as users don't need to authenticate to the authorization server each time they use a new app (unless required by the authorization server policy).",
      "ja": "ブラウザを使用して、ネイティブアプリの認証要求は、より安全であり、利用者の認証状態を利用することができます。 （認証サーバポリシーによって要求されない限り）ユーザーは認証サーバに、彼らは新しいアプリを使用するたびに認証する必要がないので、ブラウザで既存の認証セッションを使用できることは、シングルサインオンを可能にします。"
    },
    {
      "indent": 3,
      "text": "Supporting authorization flows between a native app and the browser is possible without changing the OAuth protocol itself, as the OAuth authorization request and response are already defined in terms of URIs. This encompasses URIs that can be used for inter-app communication. Some OAuth server implementations that assume all clients are confidential web clients will need to add an understanding of public native app clients and the types of redirect URIs they use to support this best practice.",
      "ja": "認証をサポートするネイティブアプリケーションとの間に流れ、ブラウザが既にURIの用語で定義されているOAuthの認可リクエストとレスポンスとして、OAuthプロトコル自体を変更することなく可能です。これは、インターアプリケーション通信のために使用することができるURIを包含する。すべてのクライアントが機密ウェブクライアントであると仮定し、一部のOAuthサーバの実装は、パブリックネイティブアプリのクライアントと彼らはこのベストプラクティスをサポートするために使用したリダイレクトURIの種類の理解を追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Authorization Flow for Native Apps Using the Browser",
      "section_title": true,
      "ja": "4.1。ブラウザを使用したネイティブアプリの承認フロー"
    },
    {
      "indent": 2,
      "text": "+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|          User Device          |\n|                               |\n| +--------------------------+  | (5) Authorization  +---------------+\n| |                          |  |     Code           |               |\n| |        Client App        |---------------------->|     Token     |\n| |                          |<----------------------|    Endpoint   |\n| +--------------------------+  | (6) Access Token,  |               |\n|   |             ^             |     Refresh Token  +---------------+\n|   |             |             |\n|   |             |             |\n|   | (1)         | (4)         |\n|   | Authorizat- | Authoriza-  |\n|   | ion Request | tion Code   |\n|   |             |             |\n|   |             |             |\n|   v             |             |\n| +---------------------------+ | (2) Authorization  +---------------+\n| |                           | |     Request        |               |\n| |          Browser          |--------------------->| Authorization |\n| |                           |<---------------------|    Endpoint   |\n| +---------------------------+ | (3) Authorization  |               |\n|                               |     Code           +---------------+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 1: Native App Authorization via an External User-Agent",
      "ja": "図1：外部のUser-Agentを経由してネイティブアプリの認証"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates the interaction between a native app and the browser to authorize the user.",
      "ja": "図1は、ネイティブアプリケーションとユーザを認証するためのブラウザとの間の相互作用を示します。"
    },
    {
      "indent": 3,
      "text": "(1) Client app opens a browser tab with the authorization request.",
      "ja": "（1）クライアントアプリは、認証要求とブラウザのタブを開きます。"
    },
    {
      "indent": 3,
      "text": "(2) Authorization endpoint receives the authorization request, authenticates the user, and obtains authorization. Authenticating the user may involve chaining to other authentication systems.",
      "ja": "（2）認可エンドポイントは、認証要求を受信するユーザを認証し、認証を取得します。ユーザを認証すると、他の認証システムに連鎖することを含むことができます。"
    },
    {
      "indent": 3,
      "text": "(3) Authorization server issues an authorization code to the redirect URI.",
      "ja": "（3）認証サーバは、リダイレクトURIに認証コードを発行します。"
    },
    {
      "indent": 3,
      "text": "(4) Client receives the authorization code from the redirect URI.",
      "ja": "（4）クライアントは、リダイレクトURIから認証コードを受信します。"
    },
    {
      "indent": 3,
      "text": "(5) Client app presents the authorization code at the token endpoint.",
      "ja": "（5）クライアントアプリはトークンエンドポイントで認証コードを提示しています。"
    },
    {
      "indent": 3,
      "text": "(6) Token endpoint validates the authorization code and issues the tokens requested.",
      "ja": "（6）トークンエンドポイントは、認証コードを検証し、要求されたトークンを発行します。"
    },
    {
      "indent": 0,
      "text": "5. Using Inter-App URI Communication for OAuth",
      "section_title": true,
      "ja": "5. OAuthのた​​めのInter-アプリのURI通信を使用"
    },
    {
      "indent": 3,
      "text": "Just as URIs are used for OAuth 2.0 [RFC6749] on the web to initiate the authorization request and return the authorization response to the requesting website, URIs can be used by native apps to initiate the authorization request in the device's browser and return the response to the requesting native app.",
      "ja": "URIは、認証要求を開始し、要求ウェブサイトへの許可応答を返すために、ウェブ上でのOAuth 2.0 [RFC6749]のために使用されているのと同じように、URIは、デバイスのブラウザに認証リクエストを開始し、への応答を返すために、ネイティブアプリケーションで使用することができます要求してネイティブアプリ。"
    },
    {
      "indent": 3,
      "text": "By adopting the same methods used on the web for OAuth, benefits seen in the web context like the usability of a single sign-on session and the security of a separate authentication context are likewise gained in the native app context. Reusing the same approach also reduces the implementation complexity and increases interoperability by relying on standards-based web flows that are not specific to a particular platform.",
      "ja": "OAuthのた​​めにウェブ上で使用したのと同じ方法を採用することにより、セッションシングルサインオンと独立した認証コンテキストのセキュリティの利便性などのWebコンテキストで見られる利点は、同様に、ネイティブアプリケーションのコンテキストで獲得されています。同じアプローチを再利用することも、実装の複雑さを低減し、特定のプラットフォームに固有ではない標準ベースのウェブ・フローに依存することによって、相互運用性を増加させます。"
    },
    {
      "indent": 3,
      "text": "To conform to this best practice, native apps MUST use an external user-agent to perform OAuth authorization requests. This is achieved by opening the authorization request in the browser (detailed in Section 6) and using a redirect URI that will return the authorization response back to the native app (defined in Section 7).",
      "ja": "このベストプラクティスに準拠するには、ネイティブアプリケーションは、OAuthの認証要求を実行するために外部のユーザーエージェントを使用しなければなりません。これは、（第6節に詳述）ブラウザで認証要求を開き、ネイティブアプリに戻って許可応答を返すだろうリダイレクトURIを使用することにより達成される（セクション7で定義されます）。"
    },
    {
      "indent": 0,
      "text": "6. Initiating the Authorization Request from a Native App",
      "section_title": true,
      "ja": "6.ネイティブアプリから認証要求を開始"
    },
    {
      "indent": 3,
      "text": "Native apps needing user authorization create an authorization request URI with the authorization code grant type per Section 4.1 of OAuth 2.0 [RFC6749], using a redirect URI capable of being received by the native app.",
      "ja": "ユーザ認証を必要とするネイティブアプリケーションは、ネイティブアプリケーションによって受信可能なリダイレクトURIを使用して、OAuth 2.0の[RFC6749]のセクション4.1あたり認可コードグラントタイプの許可要求URIを作成します。"
    },
    {
      "indent": 3,
      "text": "The function of the redirect URI for a native app authorization request is similar to that of a web-based authorization request. Rather than returning the authorization response to the OAuth client's server, the redirect URI used by a native app returns the response to the app. Several options for a redirect URI that will return the authorization response to the native app in different platforms are documented in Section 7. Any redirect URI that allows the app to receive the URI and inspect its parameters is viable.",
      "ja": "ネイティブアプリの認証要求のリダイレクトURIの機能は、Webベースの認証要求の場合と同様です。むしろのOAuthクライアントのサーバーに許可応答を返すよりも、ネイティブアプリで使用されるリダイレクトURIは、アプリへの応答を返します。異なるプラットフォームでのネイティブアプリに許可応答を返しますリダイレクトURIのためのいくつかのオプションは、どれがそのパラメータをURIを受信して​​検査するアプリが実行可能であることができますURIをリダイレクトセクション7に記載されています。"
    },
    {
      "indent": 3,
      "text": "Public native app clients MUST implement the Proof Key for Code Exchange (PKCE [RFC7636]) extension to OAuth, and authorization servers MUST support PKCE for such clients, for the reasons detailed in Section 8.1.",
      "ja": "公共のネイティブアプリのクライアントはOAuthのた​​めのコード取引所（PKCE [RFC7636]）の拡張、および承認サーバー用の証明キーを実装しなければならない8.1節で詳述する理由のために、そのようなクライアントのためにPKCEをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "After constructing the authorization request URI, the app uses platform-specific APIs to open the URI in an external user-agent. Typically, the external user-agent used is the default browser, that is, the application configured for handling \"http\" and \"https\" scheme URIs on the system; however, different browser selection criteria and other categories of external user-agents MAY be used.",
      "ja": "認可リクエストURIを構築した後、アプリが外部のユーザーエージェントでURIを開くには、プラットフォーム固有のAPIを使用しています。典型的には、使用される外部ユーザー・エージェントがデフォルトのブラウザであり、それは、システム上で「HTTP」と「HTTPS」スキームURIを処理するために構成されたアプリケーションです。しかし、別のブラウザ選択基準と外部のユーザーエージェントの他のカテゴリを使用することができます。"
    },
    {
      "indent": 3,
      "text": "This best practice focuses on the browser as the RECOMMENDED external user-agent for native apps. An external user-agent designed specifically for user authorization and capable of processing authorization requests and responses like a browser MAY also be used. Other external user-agents, such as a native app provided by the authorization server may meet the criteria set out in this best practice, including using the same redirection URI properties, but their use is out of scope for this specification.",
      "ja": "このベストプラクティスは、ネイティブアプリケーションのための推奨外部ユーザーエージェントとしてブラウザに焦点を当てています。ユーザー認証やブラウザなどの認証要求と応答を処理できるために特別に設計された外部ユーザーエージェントを使用することもできます。そのような認証サーバが提供するネイティブアプリケーションのような他の外部ユーザーエージェントは、同じリダイレクトURIプロパティの使用を含め、このベスト・プラクティスに定める基準を満たすかもしれないが、その使用はこの仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Some platforms support a browser feature known as \"in-app browser tabs\", where an app can present a tab of the browser within the app context without switching apps, but still retain key benefits of the browser such as a shared authentication state and security context. On platforms where they are supported, it is RECOMMENDED, for usability reasons, that apps use in-app browser tabs for the authorization request.",
      "ja": "一部のプラットフォームでは、このような共有の認証状態やセキュリティなどのアプリがアプリケーションを切り替えることなく、アプリケーションのコンテキスト内でブラウザのタブを提示するが、それでもブラウザの主要な利点を保持できる「アプリ内のブラウザタブ」、として知られているブラウザの機能をサポート状況。彼らはサポートされているプラ​​ットフォームでは、アプリが認証要求のためのアプリ内ブラウザのタブを使用していること、ユーザビリティ上の理由から、推奨されます。"
    },
    {
      "indent": 0,
      "text": "7. Receiving the Authorization Response in a Native App",
      "section_title": true,
      "ja": "7.ネイティブAppで認証応答を受信します"
    },
    {
      "indent": 3,
      "text": "There are several redirect URI options available to native apps for receiving the authorization response from the browser, the availability and user experience of which varies by platform.",
      "ja": "プラットフォームによって異なり可用性とユーザー体験そのブラウザからの許可応答を受信するためのネイティブアプリケーションに利用可能ないくつかのリダイレクトURIのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "To fully support this best practice, authorization servers MUST offer at least the three redirect URI options described in the following subsections to native apps. Native apps MAY use whichever redirect option suits their needs best, taking into account platform-specific implementation details.",
      "ja": "完全にこのベストプラクティスをサポートするために、認証サーバは、少なくとも3つのネイティブアプリケーションに以下のサブセクションで説明したURIオプションをリダイレクト提供しなければなりません。ネイティブアプリケーションは、オプションをリダイレクトする方使用するかもしれアカウントのプラットフォーム固有の実装の詳細を考慮して、最高の自分のニーズに合いました。"
    },
    {
      "indent": 0,
      "text": "7.1. Private-Use URI Scheme Redirection",
      "section_title": true,
      "ja": "7.1。プライベート-使用URIスキームのリダイレクト"
    },
    {
      "indent": 3,
      "text": "Many mobile and desktop computing platforms support inter-app communication via URIs by allowing apps to register private-use URI schemes (sometimes colloquially referred to as \"custom URL schemes\") like \"com.example.app\". When the browser or another app attempts to load a URI with a private-use URI scheme, the app that registered it is launched to handle the request.",
      "ja": "多くのモバイルおよびデスクトップコンピューティング・プラットフォームは、アプリは「com.example.app」のような（時には口語的に「カスタムURLスキーム」と呼ばれる）私的利用のURIスキームを登録できるようにすることで、URIを介して、相互のアプリの通信をサポートします。ブラウザや他のアプリが民間使用URIスキームでURIをロードしようとすると、それを登録アプリは、要求を処理するために起動されます。"
    },
    {
      "indent": 3,
      "text": "To perform an OAuth 2.0 authorization request with a private-use URI scheme redirect, the native app launches the browser with a standard authorization request, but one where the redirection URI utilizes a private-use URI scheme it registered with the operating system.",
      "ja": "URIスキームがリダイレクト私的利用とOAuth 2.0の認証要求を実行するには、ネイティブアプリは、標準の認証要求でブラウザを起動しますが、リダイレクトURIが、それは、オペレーティングシステムに登録された私的使用URIスキームを利用するもの。"
    },
    {
      "indent": 3,
      "text": "When choosing a URI scheme to associate with the app, apps MUST use a URI scheme based on a domain name under their control, expressed in reverse order, as recommended by Section 3.8 of [RFC7595] for private-use URI schemes.",
      "ja": "アプリに関連付けるURIスキームを選択するとき、アプリケーションは、その管理下にドメイン名に基づいてURIスキームを使用しなければならない私的利用のURIスキームのために[RFC7595]のセクション3.8で推奨されているように、逆の順序で表現。"
    },
    {
      "indent": 3,
      "text": "For example, an app that controls the domain name \"app.example.com\" can use \"com.example.app\" as their scheme. Some authorization servers assign client identifiers based on domain names, for example, \"client1234.usercontent.example.net\", which can also be used as the domain name for the scheme when reversed in the same manner. A scheme such as \"myapp\", however, would not meet this requirement, as it is not based on a domain name.",
      "ja": "たとえば、ドメイン名をコントロールアプリ「app.example.comは、」彼らのスキームとして「com.example.app」を使用することができます。いくつかの認可サーバも同様に逆転スキームのためのドメイン名として使用することができ、例えば、「client1234.usercontent.example.net」、ドメイン名に基づいてクライアント識別子を割り当てます。それは、ドメイン名に基づいていないような「myappに」などのスキームは、しかし、この要件を満たしていないだろう。"
    },
    {
      "indent": 3,
      "text": "When there are multiple apps by the same publisher, care must be taken so that each scheme is unique within that group. On platforms that use app identifiers based on reverse-order domain names, those identifiers can be reused as the private-use URI scheme for the OAuth redirect to help avoid this problem.",
      "ja": "同じ出版社によって複数のアプリケーションがある場合、それぞれの方式は、そのグループ内で一意になるように、注意しなければなりません。逆順ドメイン名に基づいてアプリの識別子を使用するプラットフォームでは、これらの識別子は、この問題を避けるためにリダイレクトOAuthのた​​めの私的利用URIスキームとして再利用することができます。"
    },
    {
      "indent": 3,
      "text": "Following the requirements of Section 3.2 of [RFC3986], as there is no naming authority for private-use URI scheme redirects, only a single slash (\"/\") appears after the scheme component. A complete example of a redirect URI utilizing a private-use URI scheme is:",
      "ja": "リダイレクトなし命名機関が民間使用URIスキームのために存在しないとして、[RFC3986]のセクション3.2の要件に続いて、単一のスラッシュ（「/」）方式の構成要素の後に表示されます。私的使用のURIスキームを活用し、リダイレクトURIの完全な例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "com.example.app:/oauth2redirect/example-provider",
      "ja": "こｍ。えぁｍｐぇ。あっｐ：／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ"
    },
    {
      "indent": 3,
      "text": "When the authorization server completes the request, it redirects to the client's redirection URI as it would normally. As the redirection URI uses a private-use URI scheme, it results in the operating system launching the native app, passing in the URI as a launch parameter. Then, the native app uses normal processing for the authorization response.",
      "ja": "認証サーバは要求を完了すると、それは通常どおり、それは、クライアントのリダイレクトURIにリダイレクトします。リダイレクトURIが私的利用URIスキームを使用するので、それが起動パラメータとしてURIを渡し、ネイティブアプリを起動し、オペレーティング・システムになります。その後、ネイティブアプリは許可応答のための通常の処理を使用しています。"
    },
    {
      "indent": 0,
      "text": "7.2. Claimed \"https\" Scheme URI Redirection",
      "section_title": true,
      "ja": "7.2。 「https」のスキームURIリダイレクトを主張"
    },
    {
      "indent": 3,
      "text": "Some operating systems allow apps to claim \"https\" scheme [RFC7230] URIs in the domains they control. When the browser encounters a claimed URI, instead of the page being loaded in the browser, the native app is launched with the URI supplied as a launch parameter.",
      "ja": "一部のオペレーティングシステムは、アプリは、彼らが制御ドメインで「https」のスキーム[RFC7230] URIを主張することができます。ブラウザがブラウザにロードされている主張URI、代わりのページに遭遇したときにURIが起動パラメータとして供給して、ネイティブアプリが起動されます。"
    },
    {
      "indent": 3,
      "text": "Such URIs can be used as redirect URIs by native apps. They are indistinguishable to the authorization server from a regular web-based client redirect URI. An example is:",
      "ja": "そのようなURIは、ネイティブアプリケーションによるリダイレクトのURIとして使用することができます。彼らは、URIをリダイレクトし、通常のWebベースのクライアントから認証サーバへの見分けがつきません。例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "https://app.example.com/oauth2redirect/example-provider",
      "ja": "ｈっｔｐｓ：／／あっｐ。えぁｍｐぇ。こｍ／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ"
    },
    {
      "indent": 3,
      "text": "As the redirect URI alone is not enough to distinguish public native app clients from confidential web clients, it is REQUIRED in Section 8.4 that the client type be recorded during client registration to enable the server to determine the client type and act accordingly.",
      "ja": "一人でリダイレクトURIが機密Webクライアントからパブリックネイティブアプリのクライアントを区別するのに十分ではないとして、それは、クライアントタイプは、クライアントの種類を決定し、それに応じて行動するサーバーを可能にするために、クライアントの登録時に記録されることセクション8.4で必要とされます。"
    },
    {
      "indent": 3,
      "text": "App-claimed \"https\" scheme redirect URIs have some advantages compared to other native app redirect options in that the identity of the destination app is guaranteed to the authorization server by the operating system. For this reason, native apps SHOULD use them over the other options where possible.",
      "ja": "App-主張し、「https」のスキームは、URIが他のネイティブアプリに比べていくつかの利点が先アプリの識別は、オペレーティング・システムによって認証サーバーに保証されていることでオプションをリダイレクトしていリダイレクト。このため、ネイティブアプリケーションは、可能な場合、他のオプションの上にそれらを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Loopback Interface Redirection",
      "section_title": true,
      "ja": "7.3。ループバックインターフェイスのリダイレクト"
    },
    {
      "indent": 3,
      "text": "Native apps that are able to open a port on the loopback network interface without needing special permissions (typically, those on desktop operating systems) can use the loopback interface to receive the OAuth redirect.",
      "ja": "特別な権限を必要とせずにループバックネットワークインタフェース上のポートを開くことができるネイティブアプリケーションは、（典型的には、デスクトップオペレーティングシステム上のもの）のOAuthリダイレクトを受信するためにループバックインターフェースを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Loopback redirect URIs use the \"http\" scheme and are constructed with the loopback IP literal and whatever port the client is listening on.",
      "ja": "ループバックは、URIが「HTTP」スキームを使用して、リテラルとクライアントが待機しているものは何でもポートループバックIPで構築されているリダイレクト。"
    },
    {
      "indent": 3,
      "text": "That is, \"http://127.0.0.1:{port}/{path}\" for IPv4, and \"http://[::1]:{port}/{path}\" for IPv6. An example redirect using the IPv4 loopback interface with a randomly assigned port:",
      "ja": "すなわち、IPv4の \"http://127.0.0.1:{port}/{path}\" であり、 \"HTTP：// [:: 1]：{ポート} / {パス}の\" IPv6のため。例では、ランダムに割り当てられたポートとIPv4のループバック・インターフェースを使用してリダイレクトします。"
    },
    {
      "indent": 5,
      "text": "http://127.0.0.1:51004/oauth2redirect/example-provider",
      "ja": "ｈっｔｐ：／／１２７。０。０。１：５１００４／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ"
    },
    {
      "indent": 3,
      "text": "An example redirect using the IPv6 loopback interface with a randomly assigned port:",
      "ja": "例は、ランダムに割り当てられたポートを持つIPv6ループバックインタフェースを使用してリダイレクトします。"
    },
    {
      "indent": 5,
      "text": "http://[::1]:61023/oauth2redirect/example-provider",
      "ja": "http：// [:: 1]：61023 / oauth2redirect /例-プロバイダ"
    },
    {
      "indent": 3,
      "text": "The authorization server MUST allow any port to be specified at the time of the request for loopback IP redirect URIs, to accommodate clients that obtain an available ephemeral port from the operating system at the time of the request.",
      "ja": "認証サーバは、要求時にオペレーティングシステムから利用できる一時的なポートを取得するクライアントに対応するために、任意のポートがループバックIPは、URIをリダイレクトするための要求時に指定できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT assume that the device supports a particular version of the Internet Protocol. It is RECOMMENDED that clients attempt to bind to the loopback interface using both IPv4 and IPv6 and use whichever is available.",
      "ja": "クライアントは、デバイスがインターネットプロトコルの特定のバージョンをサポートしていることを仮定するべきではありません。クライアントが利用できる方、IPv4とIPv6と使用の両方を使用してループバックインターフェイスにバインドしようとしていることを推奨します。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Protecting the Authorization Code",
      "section_title": true,
      "ja": "8.1。認証コードを保護します"
    },
    {
      "indent": 3,
      "text": "The redirect URI options documented in Section 7 share the benefit that only a native app on the same device or the app's own website can receive the authorization code, which limits the attack surface. However, code interception by a different native app running on the same device may be possible.",
      "ja": "第7節のシェアで、同じデバイス上のネイティブアプリやアプリの自身のウェブサイトが攻撃面を制限し、認証コードを受け取ることができるという利点を文書化URIオプションをリダイレクトします。しかし、同じデバイス上で実行中の異なるネイティブアプリケーションによってコード傍受が可能です。"
    },
    {
      "indent": 3,
      "text": "A limitation of using private-use URI schemes for redirect URIs is that multiple apps can typically register the same scheme, which makes it indeterminate as to which app will receive the authorization code. Section 1 of PKCE [RFC7636] details how this limitation can be used to execute a code interception attack.",
      "ja": "リダイレクトURIの私的利用URIスキームを使用することの制限は、複数のアプリケーションは、典型的には、アプリケーションが認証コードを受信するためにどのようにそれが不確定になり、同じスキームを登録することができるということです。 PKCE [RFC7636]のセクション1は、この制限は、コード傍受攻撃を実行するために使用することができる方法を詳述します。"
    },
    {
      "indent": 3,
      "text": "Loopback IP-based redirect URIs may be susceptible to interception by other apps accessing the same loopback interface on some operating systems.",
      "ja": "ループバックIPベースのリダイレクトURIはいくつかのオペレーティングシステム上の同じループバック・インターフェースにアクセスする他のアプリケーションによって傍受の影響を受けやすいかもしれません。"
    },
    {
      "indent": 3,
      "text": "App-claimed \"https\" scheme redirects are less susceptible to URI interception due to the presence of the URI authority, but the app is still a public client; further, the URI is sent using the operating system's URI dispatch handler with unknown security properties.",
      "ja": "App-主張し、「https」のスキームのリダイレクトが原因URIの権限の有無にURIの傍受を受けにくいですが、アプリはまだパブリッククライアントです。さらに、URIは、未知のセキュリティプロパティを持つオペレーティング・システムのURIディスパッチハンドラを使用して送信されます。"
    },
    {
      "indent": 3,
      "text": "The PKCE [RFC7636] protocol was created specifically to mitigate this attack. It is a proof-of-possession extension to OAuth 2.0 that protects the authorization code from being used if it is intercepted. To provide protection, this extension has the client generate a secret verifier; it passes a hash of this verifier in the initial authorization request, and must present the unhashed verifier when redeeming the authorization code. An app that intercepted the authorization code would not be in possession of this secret, rendering the code useless.",
      "ja": "PKCE [RFC7636]プロトコルは、この攻撃を軽減するために特別に作成されました。それが傍受された場合に使用されてから認証コードを保護するのOAuth 2.0プルーフ・オブ・所持拡張です。保護を提供するために、この拡張機能は、クライアントが秘密の検証を生成しています。それが最初の認証要求は、この検証のハッシュを通過し、認証コードを償還する際未ハッシュ検証を提示しなければなりません。認証コードを傍受アプリは役に立たないコードをレンダリング、この秘密を所有してはならないでしょう。"
    },
    {
      "indent": 3,
      "text": "Section 6 requires that both clients and servers use PKCE for public native app clients. Authorization servers SHOULD reject authorization requests from native apps that don't use PKCE by returning an error message, as defined in Section 4.4.1 of PKCE [RFC7636].",
      "ja": "第6章では、クライアントとサーバーの両方が公共のネイティブアプリのクライアントに対してPKCEを使用する必要があります。認証サーバは、PKCE [RFC7636]のセクション4.4.1で定義され、エラーメッセージを返すことによってPKCEを使用していないネイティブアプリケーションからの認証要求を拒否すべきです。"
    },
    {
      "indent": 0,
      "text": "8.2. OAuth Implicit Grant Authorization Flow",
      "section_title": true,
      "ja": "8.2。 OAuthの暗黙のグラント承認フロー"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 implicit grant authorization flow (defined in Section 4.2 of OAuth 2.0 [RFC6749]) generally works with the practice of performing the authorization request in the browser and receiving the authorization response via URI-based inter-app communication. However, as the implicit flow cannot be protected by PKCE [RFC7636] (which is required in Section 8.1), the use of the Implicit Flow with native apps is NOT RECOMMENDED.",
      "ja": "（OAuth 2.0の[RFC6749]のセクション4.2で定義される）OAuth 2.0の暗黙的な許可承認フローは、一般に、ブラウザに認証要求を行い、URIベースの間アプリ通信を介して許可応答を受信するの実践で動作します。暗黙的な流れは（セクション8.1で必要とされる）PKCE [RFC7636]で保護することができないようしかし、ネイティブアプリケーションと暗黙的フローを使用することは推奨されません。"
    },
    {
      "indent": 3,
      "text": "Access tokens granted via the implicit flow also cannot be refreshed without user interaction, making the authorization code grant flow -- which can issue refresh tokens -- the more practical option for native app authorizations that require refreshing of access tokens.",
      "ja": "リフレッシュトークンを発行することができます -   - アクセストークンのさわやか必要とネイティブアプリの承認のためのより実用的なオプションも暗黙の流れを経て許可されたアクセストークンは、認証コードの助成金の流れを作り、ユーザーの操作なしにリフレッシュすることができません。"
    },
    {
      "indent": 0,
      "text": "8.3. Loopback Redirect Considerations",
      "section_title": true,
      "ja": "8.3。ループバックリダイレクトの考慮事項"
    },
    {
      "indent": 3,
      "text": "Loopback interface redirect URIs use the \"http\" scheme (i.e., without Transport Layer Security (TLS)). This is acceptable for loopback interface redirect URIs as the HTTP request never leaves the device.",
      "ja": "ループバックインターフェイスは、URIは「HTTP」の方式（すなわち、トランスポート層セキュリティ（TLS）なし）を使用してリダイレクトします。 HTTPリクエストがデバイスを離れることはありませんとしてループバックインターフェイスは、URIをリダイレクトするためにこれが許容可能です。"
    },
    {
      "indent": 3,
      "text": "Clients should open the network port only when starting the authorization request and close it once the response is returned.",
      "ja": "クライアントは、認証要求を開始する場合にのみ、ネットワークポートを開いて、応答が返されると、それを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients should listen on the loopback network interface only, in order to avoid interference by other network actors.",
      "ja": "クライアントは、他のネットワーク主体による干渉を回避するために、専用のループバックネットワークインタフェースをリッスンする必要があります。"
    },
    {
      "indent": 3,
      "text": "While redirect URIs using localhost (i.e., \"http://localhost:{port}/{path}\") function similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED. Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently listening on network interfaces other than the loopback interface. It is also less susceptible to client-side firewalls and misconfigured host name resolution on the user's device.",
      "ja": "ローカルホストを使用してURIをリダイレクトしながら（すなわち、「HTTP：// localhostの：{ポート} / {パス}」）同様にIPループバック機能7.3節で説明リダイレクト、ローカルホストを使用することは推奨されません。むしろローカルホストよりリテラルループバックIPとリダイレクトURIを指定すると、誤ってループバックインタフェース以外のネットワークインタフェースをリッスン回避します。また、クライアント側のファイアウォールやユーザーのデバイスに誤って設定ホスト名解決の影響を受けにくいです。"
    },
    {
      "indent": 0,
      "text": "8.4. Registration of Native App Clients",
      "section_title": true,
      "ja": "8.4。ネイティブアプリケーションのクライアントの登録"
    },
    {
      "indent": 3,
      "text": "Except when using a mechanism like Dynamic Client Registration [RFC7591] to provision per-instance secrets, native apps are classified as public clients, as defined by Section 2.1 of OAuth 2.0 [RFC6749]; they MUST be registered with the authorization server as such. Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly.",
      "ja": "OAuth 2.0の[RFC6749]のセクション2.1で定義されるよう規定インスタンスごとの秘密に動的クライアントの登録[RFC7591]のようなメカニズムを使用する場合を除いて、ネイティブアプリケーションは、公共のクライアントとして分類されます。彼らは、次のような認証サーバに登録しなければなりません。認証サーバは、それに応じて要求を識別し、処理するために、クライアント登録の詳細をクライアントタイプを記録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Authorization servers MUST require clients to register their complete redirect URI (including the path component) and reject authorization requests that specify a redirect URI that doesn't exactly match the one that was registered; the exception is loopback redirects, where an exact match is required except for the port URI component.",
      "ja": "認証サーバは、（パスコンポーネントを含む）が完全なリダイレクトURIを登録して、正確に登録されたものと一致しませんリダイレクトURIを指定する認証要求を拒否するようにクライアントに要求しなければなりません。例外は、正確な一致がポートURI成分を除いて必要とされるループバックリダイレクト、です。"
    },
    {
      "indent": 3,
      "text": "For private-use URI scheme-based redirects, authorization servers SHOULD enforce the requirement in Section 7.1 that clients use schemes that are reverse domain name based. At a minimum, any private-use URI scheme that doesn't contain a period character (\".\") SHOULD be rejected.",
      "ja": "私的使用のURIスキームに基づくリダイレ​​クトするために、認証サーバは、クライアントがベースの逆ドメイン名ですスキームを使用する7.1節で要件を適用すべきです。最低でも、ピリオド文字が含まれていない任意の私的使用のURIスキームは（「」）拒絶されるべきです。"
    },
    {
      "indent": 3,
      "text": "In addition to the collision-resistant properties, requiring a URI scheme based on a domain name that is under the control of the app can help to prove ownership in the event of a dispute where two apps claim the same private-use URI scheme (where one app is acting maliciously). For example, if two apps claimed \"com.example.app\", the owner of \"example.com\" could petition the app store operator to remove the counterfeit app. Such a petition is harder to prove if a generic URI scheme was used.",
      "ja": "衝突耐性の特性に加えて、アプリの制御下にあるドメイン名に基づいてURIスキームを必要とすると、2つのアプリはURIスキーム（同じプライベート利用を主張する紛争が生じた場合に所有権を証明するために助けることができます1つのアプリ）が悪意を持って行動しています。 2つのアプリケーションが「com.example.app」を主張した場合、例えば、「example.com」の所有者が偽造アプリケーションを削除するためにアプリケーションストア演算子を請願ができました。このような請願書は、一般的なURIスキームが使用された場合を証明するのは難しいです。"
    },
    {
      "indent": 3,
      "text": "Authorization servers MAY request the inclusion of other platform-specific information, such as the app package or bundle name, or other information that may be useful for verifying the calling app's identity on operating systems that support such functions.",
      "ja": "認証サーバは、このような機能をサポートするオペレーティングシステム上で呼び出すアプリの身元を確認するために有用である可能性があるアプリのパッケージまたはバンドル名、またはその他の情報などの他のプラットフォーム固有の情報、を含めることを要求することができます。"
    },
    {
      "indent": 0,
      "text": "8.5. Client Authentication",
      "section_title": true,
      "ja": "8.5。クライアント認証"
    },
    {
      "indent": 3,
      "text": "Secrets that are statically included as part of an app distributed to multiple users should not be treated as confidential secrets, as one user may inspect their copy and learn the shared secret. For this reason, and those stated in Section 5.3.1 of [RFC6819], it is NOT RECOMMENDED for authorization servers to require client authentication of public native apps clients using a shared secret, as this serves little value beyond client identification which is already provided by the \"client_id\" request parameter.",
      "ja": "1人のユーザーが自分のコピーを検査し、共有秘密を学ぶことのように静的に複数のユーザーに配布アプリの一部として含まれている秘密は、機密秘密として扱われるべきではありません。これは、すでに提供されているクライアントの識別を超えてほとんど価値を提供していますように、この理由、および[RFC6819]のセクション5.3.1で述べられているものについては、共有秘密を使用してパブリックネイティブアプリケーションのクライアントのクライアント認証を要求するように、認証サーバにはお勧めしません「CLIENT_ID」リクエストパラメータによって。"
    },
    {
      "indent": 3,
      "text": "Authorization servers that still require a statically included shared secret for native app clients MUST treat the client as a public client (as defined by Section 2.1 of OAuth 2.0 [RFC6749]), and not accept the secret as proof of the client's identity. Without additional measures, such clients are subject to client impersonation (see Section 8.6).",
      "ja": "まだネイティブアプリクライアントの静的共有含ま秘密を必要とする認証サーバは、（OAuth 2.0の[RFC6749]のセクション2.1で定義されている）パブリッククライアントとしてクライアントを扱い、クライアントの身元の証明として秘密を受け入れてはいけません。追加的な措置がなければ、このようなクライアントは、クライアントの偽装（8.6節を参照）の対象となっています。"
    },
    {
      "indent": 0,
      "text": "8.6. Client Impersonation",
      "section_title": true,
      "ja": "8.6。クライアントの偽装"
    },
    {
      "indent": 3,
      "text": "As stated in Section 10.2 of OAuth 2.0 [RFC6749], the authorization server SHOULD NOT process authorization requests automatically without user consent or interaction, except when the identity of the client can be assured. This includes the case where the user has previously approved an authorization request for a given client id -- unless the identity of the client can be proven, the request SHOULD be processed as if no previous request had been approved.",
      "ja": "OAuth 2.0の[RFC6749]のセクション10.2で述べたように、認証サーバは、クライアントのアイデンティティを確保することができる場合を除き、ユーザーの同意または相互作用することなく、自動的に認証要求を処理しないでください。これは、ユーザーが以前に与えられたクライアントIDの認証要求を承認した場合も含まれる - クライアントの身元を証明できない限り、要求が以前の要求が承認されなかったかのように処理されるべきです。"
    },
    {
      "indent": 3,
      "text": "Measures such as claimed \"https\" scheme redirects MAY be accepted by authorization servers as identity proof. Some operating systems may offer alternative platform-specific identity features that MAY be accepted, as appropriate.",
      "ja": "このよう主張し、「https」のスキームのリダイレクトなどの対策は身分証として認可サーバによって受け入れられます。一部のオペレーティングシステムは、必要に応じて、受け入れられる代替プラットフォーム固有の識別機能を提供することがあります。"
    },
    {
      "indent": 0,
      "text": "8.7. Fake External User-Agents",
      "section_title": true,
      "ja": "8.7。フェイク外部ユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "The native app that is initiating the authorization request has a large degree of control over the user interface and can potentially present a fake external user-agent, that is, an embedded user-agent made to appear as an external user-agent.",
      "ja": "許可要求を開始しているネイティブアプリケーションは、ユーザインタフェースの制御の大きい度を有し、潜在的に、埋め込まれたユーザーエージェントは、外部ユーザ・エージェントとして表示するように構成されている偽の外部ユーザーエージェントを提示することができます。"
    },
    {
      "indent": 3,
      "text": "When all good actors are using external user-agents, the advantage is that it is possible for security experts to detect bad actors, as anyone faking an external user-agent is provably bad. On the other hand, if good and bad actors alike are using embedded user-agents, bad actors don't need to fake anything, making them harder to detect. Once a malicious app is detected, it may be possible to use this knowledge to blacklist the app's signature in malware scanning software, take removal action (in the case of apps distributed by app stores) and other steps to reduce the impact and spread of the malicious app.",
      "ja": "すべての良い俳優が外部のユーザーエージェントを使用している場合は、利点は、外部のユーザーエージェントを偽造誰が証明可能不良であるとして、セキュリティの専門家は、悪役を検出することが可能であるということです。一方、良い面と悪い俳優が似て埋め込まれたユーザーエージェントを使用している場合は、悪役を検出するのが、彼らが難しくなって、偽何もする必要はありません。悪意のあるアプリケーションが検出されると、の影響と拡散を低減するために、マルウェアスキャンソフトウェアでアプリの署名をブラックリストには、この知識を使用して、他のステップ（アプリストアによって分散アプリケーションの場合）の除去アクションを実行することも可能です悪質なアプリ。"
    },
    {
      "indent": 3,
      "text": "Authorization servers can also directly protect against fake external user-agents by requiring an authentication factor only available to true external user-agents.",
      "ja": "認証サーバは、直接真の外部ユーザー・エージェントのみが利用できる認証要素を必要とすることによって、偽の外部のユーザーエージェントから保護することができます。"
    },
    {
      "indent": 3,
      "text": "Users who are particularly concerned about their security when using in-app browser tabs may also take the additional step of opening the request in the full browser from the in-app browser tab and complete the authorization there, as most implementations of the in-app browser tab pattern offer such functionality.",
      "ja": "アプリ内ブラウザのタブを使用している場合、セキュリティについて特に懸念しているユーザーはまた、アプリ内ブラウザタブから、フルブラウザでリクエストを開く追加のステップを取ると、そこに認証を完了し、アプリ内のほとんどの実装としてもブラウザタブパターンは、このような機能を提供します。"
    },
    {
      "indent": 0,
      "text": "8.8. Malicious External User-Agents",
      "section_title": true,
      "ja": "8.8。悪意のある外部ユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "If a malicious app is able to configure itself as the default handler for \"https\" scheme URIs in the operating system, it will be able to intercept authorization requests that use the default browser and abuse this position of trust for malicious ends such as phishing the user.",
      "ja": "悪質なアプリは、オペレーティング・システムの「https」のスキームのURIのデフォルトハンドラとして自身を構成することが可能であるならば、デフォルトのブラウザを使用して認証要求をインターセプトし、このようなフィッシングなどの悪意のある両端の信頼のこの位置を濫用することができるようになりますユーザー。"
    },
    {
      "indent": 3,
      "text": "This attack is not confined to OAuth; a malicious app configured in this way would present a general and ongoing risk to the user beyond OAuth usage by native apps. Many operating systems mitigate this issue by requiring an explicit user action to change the default handler for \"http\" and \"https\" scheme URIs.",
      "ja": "この攻撃は、OAuthのに限定されません。このように構成された悪質なアプリがネイティブアプリケーションによってはOAuthの使用量を超えたユーザーへの一般的な、継続的なリスクを提示します。多くのオペレーティングシステムは、「http」と「https」スキームのURIのためのデフォルトのハンドラを変更するには、明示的なユーザーのアクションを必要とすることにより、この問題を軽減します。"
    },
    {
      "indent": 0,
      "text": "8.9. Cross-App Request Forgery Protections",
      "section_title": true,
      "ja": "8.9。クロスアプリケーションリクエストフォージェリの保護"
    },
    {
      "indent": 3,
      "text": "Section 5.3.5 of [RFC6819] recommends using the \"state\" parameter to link client requests and responses to prevent CSRF (Cross-Site Request Forgery) attacks.",
      "ja": "[RFC6819]のセクション5.3.5は、CSRF（クロスサイトリクエストフォージェリ）攻撃を防ぐために、クライアントの要求と応答をリンクする「状態」パラメータを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "To mitigate CSRF-style attacks over inter-app URI communication channels (so called \"cross-app request forgery\"), it is similarly RECOMMENDED that native apps include a high-entropy secure random number in the \"state\" parameter of the authorization request and reject any incoming authorization responses without a state value that matches a pending outgoing authorization request.",
      "ja": "（いわゆる「クロスアプリリクエストフォージェリ」と呼ばれる）間のアプリURIの通信チャネルを介してCSRFスタイルの攻撃を軽減するために、同様にネイティブアプリは、高エントロピーが認可要求の「状態」パラメータで乱数を確保含めることが推奨されますそして、保留中の発信承認要求に合致する状態値なしの着信の許可応答を拒否します。"
    },
    {
      "indent": 0,
      "text": "8.10. Authorization Server Mix-Up Mitigation",
      "section_title": true,
      "ja": "8.10。認証サーバーミックスアップの軽減"
    },
    {
      "indent": 3,
      "text": "To protect against a compromised or malicious authorization server attacking another authorization server used by the same app, it is REQUIRED that a unique redirect URI is used for each authorization server used by the app (for example, by varying the path component), and that authorization responses are rejected if the redirect URI they were received on doesn't match the redirect URI in an outgoing authorization request.",
      "ja": "同じアプリケーションで使用される別の認証サーバを攻撃損なわまたは悪意のある認証サーバから保護するために、それが必要であることURIは、アプリケーションによって使用される各認証サーバに使用される一意のリダイレクト（例えば、パス成分を変化させることにより）、そのURIは、彼らが上で受信したリダイレクトは、発信認証要求にリダイレクトURIと一致しない場合は、許可応答が拒否されます。"
    },
    {
      "indent": 3,
      "text": "The native app MUST store the redirect URI used in the authorization request with the authorization session data (i.e., along with \"state\" and other related data) and MUST verify that the URI on which the authorization response was received exactly matches it.",
      "ja": "ネイティブアプリケーションは、URIが（「状態」および他の関連データと共にすなわち、）承認セッションデータとの認可要求に使用されるリダイレクトを格納しなければならないし、許可応答が受信されたURIが正確に一致することを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The requirement of Section 8.4, specifically that authorization servers reject requests with URIs that don't match what was registered, is also required to prevent such attacks.",
      "ja": "セクション8.4の要件、特にその認証サーバが登録されたものと一致していないのURIで要求を拒否は、また、そのような攻撃を防ぐために必要とされます。"
    },
    {
      "indent": 0,
      "text": "8.11. Non-Browser External User-Agents",
      "section_title": true,
      "ja": "8.11。非ブラウザ外部のユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "This best practice recommends a particular type of external user-agent: the user's browser. Other external user-agent patterns may also be viable for secure and usable OAuth. This document makes no comment on those patterns.",
      "ja": "ユーザーのブラウザ：このベストプラクティスは、外部のユーザーエージェントの特定のタイプをお勧めします。その他の外部ユーザーエージェントパターンも安全で使用可能なOAuthのた​​めの実行可能なことがあります。この文書では、これらのパターンには何のコメントも行いません。"
    },
    {
      "indent": 0,
      "text": "8.12. Embedded User-Agents",
      "section_title": true,
      "ja": "8.12。組み込みユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "Section 9 of OAuth 2.0 [RFC6749] documents two approaches for native apps to interact with the authorization endpoint. This best current practice requires that native apps MUST NOT use embedded user-agents to perform authorization requests and allows that authorization endpoints MAY take steps to detect and block authorization requests in embedded user-agents. The security considerations for these requirements are detailed herein.",
      "ja": "OAuth 2.0ののセクション9 [RFC6749]は認可エンドポイントと対話するネイティブアプリケーションのための2つのアプローチを説明します。この現在のベストプラクティスは、ネイティブアプリが承認要求を実行するために埋め込まれたユーザーエージェントを使用してはならないことを要求し、承認エンドポイントが埋め込まれたユーザーエージェントでの認証要求を検出し、ブロックするための措置をとるかもしれないことができます。これらの要件のためのセキュリティの考慮事項は、本明細書に詳述されています。"
    },
    {
      "indent": 3,
      "text": "Embedded user-agents are an alternative method for authorizing native apps. These embedded user-agents are unsafe for use by third parties to the authorization server by definition, as the app that hosts the embedded user-agent can access the user's full authentication credential, not just the OAuth authorization grant that was intended for the app.",
      "ja": "組み込みユーザーエージェントは、ネイティブアプリケーションを承認するための別の方法です。これらの組み込みユーザーエージェントは、ユーザーの完全な認証資格情報、アプリのために意図されただけでなく、OAuthの認証許可をアクセスすることができ組み込みユーザーエージェントをホストするアプリケーションとして、定義により、認証サーバへの第三者による使用のために安全ではありません。"
    },
    {
      "indent": 3,
      "text": "In typical web-view-based implementations of embedded user-agents, the host application can record every keystroke entered in the login form to capture usernames and passwords, automatically submit forms to bypass user consent, and copy session cookies and use them to perform authenticated actions as the user.",
      "ja": "組み込みユーザーエージェントの一般的なウェブ・ビューベースの実装では、ホストアプリケーションは自動的にユーザーの同意をバイパスするフォームを送信し、セッションクッキーをコピーして、認証を実行するためにそれらを使用し、ユーザ名とパスワードをキャプチャするために、ログインフォームに入力されたすべてのキーストロークを記録することができますユーザーなどのアクション。"
    },
    {
      "indent": 3,
      "text": "Even when used by trusted apps belonging to the same party as the authorization server, embedded user-agents violate the principle of least privilege by having access to more powerful credentials than they need, potentially increasing the attack surface.",
      "ja": "認証サーバーと同じパーティーに属している、信頼できるアプリケーションで使用される場合でも、埋め込まれたユーザーエージェントは、潜在的に攻撃面を増加、彼らが必要とするよりも、より強力な資格情報へのアクセスを持つことにより、最小限の特権の原則に違反します。"
    },
    {
      "indent": 3,
      "text": "Encouraging users to enter credentials in an embedded user-agent without the usual address bar and visible certificate validation features that browsers have makes it impossible for the user to know if they are signing in to the legitimate site; even when they are, it trains them that it's OK to enter credentials without validating the site first.",
      "ja": "通常のアドレスバーとブラウザが、それは不可能彼らは合法的なサイトにサインインしている場合、ユーザーが知るようになり持っている目に見える、証明書の検証機能せずに埋め込まれたユーザーエージェントで資格情報を入力するようユーザーに奨励。彼らは場合でも、それは最初のサイトを検証せずに資格情報を入力し、[OKだとそれらを訓練します。"
    },
    {
      "indent": 3,
      "text": "Aside from the security concerns, embedded user-agents do not share the authentication state with other apps or the browser, requiring the user to log in for every authorization request, which is often considered an inferior user experience.",
      "ja": "別にセキュリティ上の懸念から、埋め込まれたユーザーエージェントは、多くの場合、劣ったユーザーエクスペリエンスと考えられているすべての認証要求のためにログインするユーザーを必要とする、他のアプリやブラウザを使用して認証状態を共有することはありません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 3,
      "text": "Section 7.1 specifies how private-use URI schemes are used for inter-app communication in OAuth protocol flows. This document requires in Section 7.1 that such schemes are based on domain names owned or assigned to the app, as recommended in Section 3.8 of [RFC7595]. Per Section 6 of [RFC7595], registration of domain-based URI schemes with IANA is not required.",
      "ja": "7.1節は、プライベート利用URIスキームはOAuthプロトコル・フローの間アプリの通信に使用される方法を指定します。 [RFC7595]のセクション3.8で推奨されているようにこの文書では、このようなスキームが所有または、アプリに割り当てられたドメイン名に基づいていることセクション7.1で必要です。 [RFC7595]のセクション6当たり、IANAとドメインベースのURIスキームの登録が必要とされません。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTPS：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749]ハルト、D.編、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <https://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<https://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7595] Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines and Registration Procedures for URI Schemes\", BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015, <https://www.rfc-editor.org/info/rfc7595>.",
      "ja": "[RFC7595]ターラー、D.、エド、ハンセン、T.、およびT.ハーディ、 \"URIスキームのためのガイドラインと登録手順\"、BCP 35、RFC 7595、DOI 10.17487 / RFC7595、2015年6月、<HTTPS：// www.rfc-editor.org/info/rfc7595>。"
    },
    {
      "indent": 3,
      "text": "[RFC7636] Sakimura, N., Ed., Bradley, J., and N. Agarwal, \"Proof Key for Code Exchange by OAuth Public Clients\", RFC 7636, DOI 10.17487/RFC7636, September 2015, <https://www.rfc-editor.org/info/rfc7636>.",
      "ja": "[RFC7636] Sakimura、N.、エド、ブラッドリー、J.、およびN. Agarwalさん、 \"OAuthの公共のクライアントによってコードExchange用の証明キー\"、RFC 7636、DOI 10.17487 / RFC7636、2015年9月、<HTTPS：// WWW .rfc-editor.org /情報/ rfc7636>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC6819] Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0 Threat Model and Security Considerations\", RFC 6819, DOI 10.17487/RFC6819, January 2013, <https://www.rfc-editor.org/info/rfc6819>.",
      "ja": "[RFC6819] Lodderstedt、T.、エド、McGloin、M.、およびP.ハント、 \"OAuth 2.0の脅威モデルおよびセキュリティに関する注意事項\"、RFC 6819、DOI 10.17487 / RFC6819、2013年1月、<HTTPS：。//www.rfc -editor.org/info/rfc6819>。"
    },
    {
      "indent": 3,
      "text": "[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\", RFC 7591, DOI 10.17487/RFC7591, July 2015, <https://www.rfc-editor.org/info/rfc7591>.",
      "ja": "[RFC7591]豊かな、J.、編、ジョーンズ、M.、ブラッドリー、J.、Machulak、M.、およびP.ハント、 \"OAuth 2.0のダイナミッククライアント登録プロトコル\"、RFC 7591、DOI 10.17487 / RFC7591、2015年7月、<https://www.rfc-editor.org/info/rfc7591>。"
    },
    {
      "indent": 3,
      "text": "[AppAuth] OpenID Connect Working Group, \"AppAuth\", September 2017, <https://openid.net/code/AppAuth>.",
      "ja": "[AppAuth] OpenIDの接続ワーキンググループ、 \"AppAuth\"、2017年9月、<https://openid.net/code/AppAuth>。"
    },
    {
      "indent": 3,
      "text": "[AppAuth.iOSmacOS] Wright, S., Denniss, W., et al., \"AppAuth for iOS and macOS\", February 2016, <https://openid.net/code/AppAuth-iOS>.",
      "ja": "【AppAuth.iOSmacOS】ライト、S.、Denniss、W.ら、 \"AppAuth iOSとMacOSのための\"、2016年2月、<https://openid.net/code/AppAuth-iOS>。"
    },
    {
      "indent": 3,
      "text": "[AppAuth.Android] McGinniss, I., Denniss, W., et al., \"AppAuth for Android\", February 2016, <https://openid.net/code/AppAuth-Android>.",
      "ja": "【AppAuth.Android] McGinniss、I.、Denniss、W.ら、 \"アンドロイド用AppAuth\"、2016年2月、<https://openid.net/code/AppAuth-Android>。"
    },
    {
      "indent": 3,
      "text": "[SamplesForWindows] Denniss, W., \"OAuth for Apps: Samples for Windows\", July 2016, <https://openid.net/code/sample-oauth-apps-for-windows>.",
      "ja": "[SamplesForWindows] Denniss、W.、 \"アプリのOAuth：Windows用のサンプル\"、2016年7月、<https://openid.net/code/sample-oauth-apps-for-windows>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Server Support Checklist",
      "ja": "付録A.サーバーサポートのチェックリスト"
    },
    {
      "indent": 3,
      "text": "OAuth servers that support native apps must:",
      "ja": "ネイティブアプリケーションをサポートするのOAuthサーバーには、次の条件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Support private-use URI scheme redirect URIs. This is required to support mobile operating systems. See Section 7.1.",
      "ja": "1.サポート私的使用のURIスキームはURIをリダイレクトします。これは、モバイルオペレーティングシステムをサポートするために必要です。 7.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. Support \"https\" scheme redirect URIs for use with public native app clients. This is used by apps on advanced mobile operating systems that allow app-claimed \"https\" scheme URIs. See Section 7.2.",
      "ja": "2.サポート「https」を体系は、公共のネイティブアプリのクライアントで使用するURIをリダイレクトします。これは、アプリ-主張「https」のスキームのURIを許可する高度なモバイルオペレーティングシステム上のアプリケーションで使用されています。 7.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "3. Support loopback IP redirect URIs. This is required to support desktop operating systems. See Section 7.3.",
      "ja": "3.サポートループバックIP URIをリダイレクトします。これは、デスクトップオペレーティングシステムをサポートするために必要です。 7.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "4. Not assume that native app clients can keep a secret. If secrets are distributed to multiple installs of the same native app, they should not be treated as confidential. See Section 8.5.",
      "ja": "4.ネイティブアプリのクライアントが秘密を保つことができることを前提としていません。秘密は同じネイティブアプリの複数のインストールに配布されている場合、それらは機密として扱われるべきではありません。セクション8.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "5. Support PKCE [RFC7636]. Required to protect authorization code grants sent to public clients over inter-app communication channels. See Section 8.1",
      "ja": "5.サポートPKCE [RFC7636]。間アプリの通信チャネルを介して公衆のクライアントに送信される認証コードの助成金を保護するために必要。 8.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Platform-Specific Implementation Details",
      "ja": "付録B.プラットフォーム固有の実装の詳細"
    },
    {
      "indent": 3,
      "text": "This document primarily defines best practices in a generic manner, referencing techniques commonly available in a variety of environments. This non-normative section documents implementation details of the best practice for various operating systems.",
      "ja": "この文書では、主に、さまざまな環境で一般的に利用可能な技術を参照し、一般的な方法でのベストプラクティスを定義します。これは、非規範的部分文書さまざまなオペレーティングシステムのためのベストプラクティスの実装の詳細を。"
    },
    {
      "indent": 3,
      "text": "The implementation details herein are considered accurate at the time of publishing but will likely change over time. It is hoped that such a change won't invalidate the generic principles in the rest of the document and that those principles should take precedence in the event of a conflict.",
      "ja": "実装の詳細は、本明細書出版の時点で正確と考えられているが、そう時間をかけて変化します。このような変更は、文書の残りの部分で一般的な原理を無効にし、これらの原則は、紛争が発生した場合に優先すべきことではないだろうことが期待されています。"
    },
    {
      "indent": 0,
      "text": "B.1. iOS Implementation Details",
      "ja": "B.1。 iOSの実装の詳細"
    },
    {
      "indent": 3,
      "text": "Apps can initiate an authorization request in the browser, without the user leaving the app, through the \"SFSafariViewController\" class or its successor \"SFAuthenticationSession\", which implement the in-app browser tab pattern. Safari can be used to handle requests on old versions of iOS without in-app browser tab functionality.",
      "ja": "アプリは、ユーザーが「SFSafariViewController」クラスまたはアプリ内ブラウザタブパターンを実装し、その後継者「SFAuthenticationSession」を通じて、アプリを離れることなく、ブラウザでの認証要求を開始することができます。 Safariはアプリ内ブラウザのタブ機能のないのiOSの古いバージョンの要求を処理するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "To receive the authorization response, both private-use URI scheme (referred to as \"custom URL scheme\") redirects and claimed \"https\" scheme URIs (known as \"Universal Links\") are viable choices. Apps can claim private-use URI schemes with the \"CFBundleURLTypes\" key in the application's property list file, \"Info.plist\", and \"https\" scheme URIs using the Universal Links feature with an entitlement file in the app and an association file hosted on the domain.",
      "ja": "許可応答を受信するには、（「カスタムURLスキーム」と呼ばれる）の両方の私的利用URIスキームはリダイレクトし、（「ユニバーサルリンク」として知られている）「https」のスキームのURIを主張は、実行可能な選択肢です。アプリは、アプリでエンタイトルメントファイルとホストされた関連ファイルとユニバーサルリンク機能を使用して「CFBundleURLTypes」アプリケーションのプロパティリストファイルのキー、「Info.plistファイル」、および「https」のスキームのURIを持つプライベート・使用URIスキームを請求することができますドメイン上。"
    },
    {
      "indent": 3,
      "text": "Claimed \"https\" scheme URIs are the preferred redirect choice on iOS 9 and above due to the ownership proof that is provided by the operating system.",
      "ja": "「HTTPS」スキームURIはIOSの9上の好ましいリダイレクト選択であり、上記により、オペレーティングシステムによって提供された所有権の証拠と主張しました。"
    },
    {
      "indent": 3,
      "text": "A complete open-source sample is included in the AppAuth for iOS and macOS [AppAuth.iOSmacOS] library.",
      "ja": "完全なオープンソースのサンプルは、iOSとMacOSの[AppAuth.iOSmacOS]ライブラリのAppAuthに含まれています。"
    },
    {
      "indent": 0,
      "text": "B.2. Android Implementation Details",
      "ja": "B.2。 Androidの実装の詳細"
    },
    {
      "indent": 3,
      "text": "Apps can initiate an authorization request in the browser, without the user leaving the app, through the Android Custom Tab feature, which implements the in-app browser tab pattern. The user's default browser can be used to handle requests when no browser supports Custom Tabs.",
      "ja": "アプリは、ユーザーがアプリ内ブラウザタブパターンを実装してAndroidのカスタムタブの機能を通じて、アプリを離れることなく、ブラウザでの認証要求を開始することができます。ユーザーのデフォルトのブラウザにはブラウザがカスタムタブをサポートしていないときに要求を処理するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Android browser vendors should support the Custom Tabs protocol (by providing an implementation of the \"CustomTabsService\" class), to provide the in-app browser tab user-experience optimization to their users. Chrome is one such browser that implements Custom Tabs.",
      "ja": "Androidのブラウザベンダーがユーザーにアプリ内のブラウザタブユーザーエクスペリエンスの最適化を実現するために、（「CustomTabsService」クラスの実装を提供することで）カスタムタブのプロトコルをサポートする必要があります。 Chromeはカスタムタブを実装してそのようなブラウザです。"
    },
    {
      "indent": 3,
      "text": "To receive the authorization response, private-use URI schemes are broadly supported through Android Implicit Intents. Claimed \"https\" scheme redirect URIs through Android App Links are available on Android 6.0 and above. Both types of redirect URIs are registered in the application's manifest.",
      "ja": "許可応答を受信するには、私的使用のURIスキームは広くAndroidの暗黙インテントを介してサポートされています。 「https」のスキームは、Androidアプリのリンクを介してURIをリダイレクト主張することはアンドロイド6.0以上でご利用いただけます。リダイレクトURIの両方のタイプは、アプリケーションのマニフェストに登録されています。"
    },
    {
      "indent": 3,
      "text": "A complete open-source sample is included in the AppAuth for Android [AppAuth.Android] library.",
      "ja": "完全なオープンソースのサンプルは、Androidの[AppAuth.Android]ライブラリのAppAuthに含まれています。"
    },
    {
      "indent": 0,
      "text": "B.3. Windows Implementation Details",
      "ja": "B.3。 Windowsの実装の詳細"
    },
    {
      "indent": 3,
      "text": "Both traditional and Universal Windows Platform (UWP) apps can perform authorization requests in the user's browser. Traditional apps typically use a loopback redirect to receive the authorization response, and listening on the loopback interface is allowed by default firewall rules. When creating the loopback network socket, apps SHOULD set the \"SO_EXCLUSIVEADDRUSE\" socket option to prevent other apps binding to the same socket.",
      "ja": "どちらも伝統的なユニバーサルのWindowsプラットフォーム（UWP）のアプリがユーザーのブラウザに認証要求を行うことができます。従来のアプリケーションは通常、許可応答を受け取るために、ループバックのリダイレクトを使用して、ループバックインターフェイスをリッスンし、デフォルトのファイアウォールルールで許可されています。ループバックネットワークソケットを作成する場合、アプリケーションは、同じソケットに結合する他のアプリを防ぐために、「SO_EXCLUSIVEADDRUSE」ソケットオプションを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "UWP apps can use private-use URI scheme redirects to receive the authorization response from the browser, which will bring the app to the foreground. Known on the platform as \"URI Activation\", the URI scheme is limited to 39 characters in length, and it may include the \".\" character, making short reverse domain name based schemes (as required in Section 7.1) possible.",
      "ja": "UWPのアプリはURIスキームがフォアグラウンドにアプリをもたらすブラウザからの許可応答を受け取るためにリダイレクト私的利用を使用することができます。 「URIのアクティベーション」などのプラットフォーム上で知られている、URIスキームは、長さが39文字に制限され、それが含まれます「」文字、（セクション7.1で必要とされる）可能性、短い逆ドメイン名ベースのスキームを作ります。"
    },
    {
      "indent": 3,
      "text": "UWP apps can alternatively use the Web Authentication Broker API in Single Sign-on (SSO) mode, which is an external user-agent designed for authorization flows. Cookies are shared between invocations of the broker but not the user's preferred browser, meaning the user will need to log in again, even if they have an active session in their browser; but the session created in the broker will be available to subsequent apps that use the broker. Personalizations the user has made to their browser, such as configuring a password manager, may not be available in the broker. To qualify as an external user-agent, the broker MUST be used in SSO mode.",
      "ja": "UWPのアプリケーションは、代わりに承認フローのために設計された外部ユーザエージェントでのシングルサインオン（SSO）モードでWeb認証ブローカーのAPIを使用することができます。クッキーは、ユーザーが彼らのブラウザでアクティブなセッションを持っている場合でも、再度ログインする必要がありますを意味し、ブローカーの呼び出しではなく、ユーザの好みのブラウザ間で共有されています。しかし、ブローカーで作成されたセッションは、ブローカーを使用し、後続のアプリケーションに利用できるようになります。ユーザーは、このようなパスワードマネージャを設定すると、そのブラウザに行われたパーソナライズは、ブローカーでは利用できない場合があります。外部ユーザー・エージェントとしての資格には、ブローカーは、SSOモードで使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "To use the Web Authentication Broker in SSO mode, the redirect URI must be of the form \"msapp://{appSID}\" where \"{appSID}\" is the app's security identifier (SID), which can be found in the app's registration information or by calling the \"GetCurrentApplicationCallbackUri\" method. While Windows enforces the URI authority on such redirects, ensuring that only the app with the matching SID can receive the response on Windows, the URI scheme could be claimed by apps on other platforms without the same authority present; thus, this redirect type should be treated similarly to private-use URI scheme redirects for security purposes.",
      "ja": "SSOモードでWeb認証ブローカを使用するように、リダイレクトURIの形式でなければなりません「msapp：// {appSID}」ここで、「{appSID}は」アプリの登録中に見出すことができるアプリケーションのセキュリティ識別子（SID）、あります情報または「GetCurrentApplicationCallbackUri」メソッドを呼び出すことによって。 Windowsが一致するSIDを持つ唯一のアプリケーションは、Windows上の応答を受信できることを保証する、そのようなリダイレクトURIに権限を適用しながら、URIスキームは、同じ権限が存在しない他のプラットフォーム上のアプリケーションによって要求され得ます。したがって、このリダイレクトの種類はURIスキームは、セキュリティ目的のためにリダイレクト私的利用と同様に扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "An open-source sample demonstrating these patterns is available [SamplesForWindows].",
      "ja": "これらのパターンを示すオープンソースのサンプルは、利用可能な[SamplesForWindows]です。"
    },
    {
      "indent": 0,
      "text": "B.4. macOS Implementation Details",
      "ja": "B.4。 MacOSの実装の詳細"
    },
    {
      "indent": 3,
      "text": "Apps can initiate an authorization request in the user's default browser using platform APIs for opening URIs in the browser.",
      "ja": "アプリは、ブラウザでURIを開くためのプラットフォームAPIを使用して、ユーザーの既定のブラウザに認証要求を開始することができます。"
    },
    {
      "indent": 3,
      "text": "To receive the authorization response, private-use URI schemes are a good redirect URI choice on macOS, as the user is returned right back to the app they launched the request from. These are registered in the application's bundle information property list using the \"CFBundleURLSchemes\" key. Loopback IP redirects are another viable option, and listening on the loopback interface is allowed by default firewall rules.",
      "ja": "ユーザーはすぐに戻ってアプリに返され、彼らはからの要求を開始したとして、許可応答を受信するには、私的使用のURIスキームは、MacOSで良いリダイレクトURIの選択です。これらは、「CFBundleURLSchemes」キーを使用して、アプリケーションのバンドル情報プロパティリストに登録されています。ループバックIPリダイレクトは、別の実行可能な選択肢であり、ループバックインターフェイスをリッスンし、デフォルトのファイアウォールルールで許可されています。"
    },
    {
      "indent": 3,
      "text": "A complete open-source sample is included in the AppAuth for iOS and macOS [AppAuth.iOSmacOS] library.",
      "ja": "完全なオープンソースのサンプルは、iOSとMacOSの[AppAuth.iOSmacOS]ライブラリのAppAuthに含まれています。"
    },
    {
      "indent": 0,
      "text": "B.5. Linux Implementation Details",
      "ja": "B.5。 Linuxの実装の詳細"
    },
    {
      "indent": 3,
      "text": "Opening the authorization request in the user's default browser requires a distro-specific command: \"xdg-open\" is one such tool.",
      "ja": "ユーザーのデフォルトのブラウザで認証要求を開くと、ディストリビューション固有のコマンドが必要です「のxdg-openが、」そのようなツールです。"
    },
    {
      "indent": 3,
      "text": "The loopback redirect is the recommended redirect choice for desktop apps on Linux to receive the authorization response. Apps SHOULD NOT set the \"SO_REUSEPORT\" or \"SO_REUSEADDR\" socket options in order to prevent other apps binding to the same socket.",
      "ja": "ループバックリダイレクトは許可応答を受信するためにLinux上でデスクトップアプリケーションのための推奨されるリダイレクトの選択肢です。アプリは、同じソケットに結合する他のアプリを防ぐために「SO_REUSEPORT」または「SO_REUSEADDR」ソケットオプションを設定しないでください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge the work of Marius Scurtescu and Ben Wiley Sittler, whose design for using private-use URI schemes in native app OAuth 2.0 clients at Google formed the basis of Section 7.1.",
      "ja": "著者は、マリウスScurtescuとその設計2.0クライアントGoogleのネイティブアプリのOAuthのプライベート利用のURIスキームを使用するためのセクション7.1の基礎を形成ベン・ワイリーSittler、の作業を確認したいと思います。"
    },
    {
      "indent": 3,
      "text": "The following individuals contributed ideas, feedback, and wording that shaped and formed the final specification:",
      "ja": "以下の個人は形のアイデア、フィードバック、および文言に貢献し、最終的な仕様を形成しました："
    },
    {
      "indent": 3,
      "text": "Andy Zmolek, Steven E. Wright, Brian Campbell, Nat Sakimura, Eric Sachs, Paul Madsen, Iain McGinniss, Rahul Ravikumar, Breno de Medeiros, Hannes Tschofenig, Ashish Jain, Erik Wahlstrom, Bill Fisher, Sudhi Umarji, Michael B. Jones, Vittorio Bertocci, Dick Hardt, David Waite, Ignacio Fiorentino, Kathleen Moriarty, and Elwyn Davies.",
      "ja": "アンディZmolek、スティーブン・E.ライト、ブライアン・キャンベル、ナットSakimura、エリック・サックス、ポール・マドセン、イアンMcGinniss、ラーフルRavikumar、Breno・デ・メデイロス、ハンネスTschofenig、アシシュジャイナ教、エリックWahlstrom、ビル・フィッシャー、Sudhi Umarji、マイケルB.ジョーンズ、ヴィットリオBertocci、ディック・ハート、デイビット・ウェイト、イグナシオ・フィオレンティーノ、キャスリーン・モリアーティ、およびエルウィン・デイヴィス。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "William Denniss Google 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States of America",
      "ja": "ウィリアムDenniss Googleのアメリカの1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "Email: rfc8252@wdenniss.com URI: http://wdenniss.com/appauth",
      "ja": "メール：rfc8252@wdenniss.com URI：http://wdenniss.com/appauth"
    },
    {
      "indent": 3,
      "text": "John Bradley Ping Identity",
      "ja": "ジョン・ブラッドリーピング・アイデンティティ"
    },
    {
      "indent": 3,
      "text": "Phone: +1 202-630-5272 Email: rfc8252@ve7jtb.com URI: http://www.thread-safe.com/p/appauth.html",
      "ja": "電話：+1 202-630-5272電子メール：rfc8252@ve7jtb.com URI：http://www.thread-safe.com/p/appauth.html"
    }
  ]
}