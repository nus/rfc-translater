{
  "title": {
    "text": "RFC 8609 - Content-Centric Networking (CCNx) Messages in TLV Format",
    "ja": "RFC 8609 - TLV形式のコンテンツ中心ネットワーキング（CCNx）メッセージ"
  },
  "number": 8609,
  "created_at": "2019-11-05 10:29:37.818085+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                             M. Mosko\nRequest for Comments: 8609                                    PARC, Inc.\nCategory: Experimental                                          I. Solis\nISSN: 2070-1721                                                 LinkedIn\n                                                                 C. Wood\n                                        University of California, Irvine\n                                                               July 2019",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Content-Centric Networking (CCNx) Messages in TLV Format",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Content-Centric Networking (CCNx) is a network protocol that uses a hierarchical name to forward requests and to match responses to requests. This document specifies the encoding of CCNx messages in a TLV packet format, including the TLV types used by each message element and the encoding of each value. The semantics of CCNx messages follow the encoding-independent CCNx Semantics specification.",
      "ja": "Content-Centric Networking（CCNx）は、階層名を使用して要求を転送し、応答を要求に一致させるネットワークプロトコルです。 このドキュメントは、各メッセージ要素と各値のエンコーディングで使用されるTLVタイプを含むTLVパケット形式でCCNxメッセージのエンコーディングを指定します。 CCNxメッセージのセマンティクスは、エンコーディングに依存しないCCNxセマンティクス仕様に従います。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Information Centric Networking research group (ICNRG). The document received wide review among ICNRG participants and has two full implementations currently in active use, which have informed the technical maturity of the protocol specification.",
      "ja": "このドキュメントは、情報中心ネットワーキング研究グループ（ICNRG）の製品です。 このドキュメントは、ICNRG参加者の間で幅広いレビューを受け、現在アクティブに使用されている2つの完全な実装を持ち、プロトコル仕様の技術的成熟度を通知しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 調査、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Information-Centric Networking Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントでは、インターネットコミュニティの実験プロトコルを定義しています。 このドキュメントは、Internet Research Task Force（IRTF）の製品です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。 これらの結果は、展開に適さない場合があります。 このRFCは、Internet Research Task Force（IRTF）の情報中心ネットワーキング研究グループのコンセンサスを表しています。 IRSGによる公開が承認された文書は、どのレベルのインターネット標準の候補でもありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8609.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8609で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n2.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Type-Length-Value (TLV) Packets . . . . . . . . . . . . . . .   5\n  3.1.  Overall Packet Format . . . . . . . . . . . . . . . . . .   7\n  3.2.  Fixed Headers . . . . . . . . . . . . . . . . . . . . . .   8\n    3.2.1.  Interest Fixed Header . . . . . . . . . . . . . . . .   9\n      3.2.1.1.  Interest HopLimit . . . . . . . . . . . . . . . .   9\n    3.2.2.  Content Object Fixed Header . . . . . . . . . . . . .   9\n    3.2.3.  Interest Return Fixed Header  . . . . . . . . . . . .  10\n      3.2.3.1.  Interest Return HopLimit  . . . . . . . . . . . .  10\n      3.2.3.2.  Interest Return Flags . . . . . . . . . . . . . .  10\n      3.2.3.3.  Return Code . . . . . . . . . . . . . . . . . . .  10\n  3.3.  Global Formats  . . . . . . . . . . . . . . . . . . . . .  11\n    3.3.1.  Pad . . . . . . . . . . . . . . . . . . . . . . . . .  11\n    3.3.2.  Organization-Specific TLVs  . . . . . . . . . . . . .  12\n    3.3.3.  Hash Format . . . . . . . . . . . . . . . . . . . . .  12\n    3.3.4.  Link  . . . . . . . . . . . . . . . . . . . . . . . .  13\n  3.4.  Hop-by-Hop TLV Headers  . . . . . . . . . . . . . . . . .  14\n    3.4.1.  Interest Lifetime . . . . . . . . . . . . . . . . . .  14\n    3.4.2.  Recommended Cache Time  . . . . . . . . . . . . . . .  15\n    3.4.3.  Message Hash  . . . . . . . . . . . . . . . . . . . .  16\n  3.5.  Top-Level Types . . . . . . . . . . . . . . . . . . . . .  17\n  3.6.  CCNx Message TLV  . . . . . . . . . . . . . . . . . . . .  18\n    3.6.1.  Name  . . . . . . . . . . . . . . . . . . . . . . . .  19\n      3.6.1.1.  Name Segments . . . . . . . . . . . . . . . . . .  20\n      3.6.1.2.  Interest Payload ID . . . . . . . . . . . . . . .  20\n    3.6.2.  Message TLVs  . . . . . . . . . . . . . . . . . . . .  21\n      3.6.2.1.  Interest Message TLVs . . . . . . . . . . . . . .  21\n      3.6.2.2.  Content Object Message TLVs . . . . . . . . . . .  23\n    3.6.3.  Payload . . . . . . . . . . . . . . . . . . . . . . .  25\n    3.6.4.  Validation  . . . . . . . . . . . . . . . . . . . . .  25\n      3.6.4.1.  Validation Algorithm  . . . . . . . . . . . . . .  25\n      3.6.4.2.  Validation Payload  . . . . . . . . . . . . . . .  32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  33\n  4.1.  Packet Type Registry  . . . . . . . . . . . . . . . . . .  33\n  4.2.  Interest Return Code Registry . . . . . . . . . . . . . .  34\n  4.3.  Hop-by-Hop Type Registry  . . . . . . . . . . . . . . . .  35\n  4.4.  Top-Level Type Registry . . . . . . . . . . . . . . . . .  36\n  4.5.  Name Segment Type Registry  . . . . . . . . . . . . . . .  37\n  4.6.  Message Type Registry . . . . . . . . . . . . . . . . . .  37\n  4.7.  Payload Type Registry . . . . . . . . . . . . . . . . . .  38\n  4.8.  Validation Algorithm Type Registry  . . . . . . . . . . .  39\n  4.9.  Validation-Dependent Data Type Registry . . . . . . . . .  40\n  4.10. Hash Function Type Registry . . . . . . . . . . . . . . .  40\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  41\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  44\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  44\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  44\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  46",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies a Type-Length-Value (TLV) packet format and the TLV type and value encodings for CCNx messages. A full description of the CCNx network protocol, providing an encoding-free description of CCNx messages and message elements, may be found in [RFC8569]. CCNx is a network protocol that uses a hierarchical name to forward requests and to match responses to requests. It does not use endpoint addresses; the Internet Protocol does. Restrictions in a request can limit the response by the public key of the response's signer or the cryptographic hash of the response. Every CCNx forwarder along the path does the name matching and restriction checking. The CCNx protocol fits within the broader framework of Information-Centric Networking (ICN) protocols [RFC7927].",
      "ja": "このドキュメントでは、Type-Length-Value（TLV）パケット形式と、CCNxメッセージのTLVタイプと値のエンコードを指定します。 CCNxネットワークプロトコルの完全な説明は、CCNxメッセージとメッセージ要素のエンコードフリーの説明を提供し、[RFC8569]にあります。 CCNxは、階層名を使用して要求を転送し、応答を要求に一致させるネットワークプロトコルです。 エンドポイントアドレスは使用しません。 インターネットプロトコルはそうです。 リクエストの制限により、レスポンスの署名者の公開鍵またはレスポンスの暗号化ハッシュによってレスポンスを制限できます。 パスに沿ったすべてのCCNxフォワーダーは、名前の一致と制限のチェックを行います。 CCNxプロトコルは、情報中心ネットワーキング（ICN）プロトコル[RFC7927]のより広範なフレームワークに適合します。"
    },
    {
      "indent": 3,
      "text": "This document describes a TLV scheme using a fixed 2-byte T and a fixed 2-byte L field. The rational for this choice is described in Section 5. Briefly, this choice avoids multiple encodings of the same value (aliases) and reduces the work of a validator to ensure compliance. Unlike some uses of TLV in networking, each network hop must evaluate the encoding, so even small validation latencies at each hop could add up to a large overall forwarding delay. For very small packets or low-throughput links, where the extra bytes may become a concern, one may use a TLV compression protocol, for example, [compress] and [CCNxz].",
      "ja": "このドキュメントでは、固定2バイトTフィールドと固定2バイトLフィールドを使用したTLVスキームについて説明します。 この選択の合理性については、セクション5で説明します。簡単に言うと、この選択により、同じ値の複数のエンコード（エイリアス）が回避され、バリデーターの作業が軽減され、コンプライアンスが確保されます。 ネットワーキングでのTLVの一部の使用とは異なり、各ネットワークホップはエンコーディングを評価する必要があるため、各ホップでの小さな検証遅延でも、全体的な転送遅延が大きくなる可能性があります。 余分なバイトが問題になる可能性のある非常に小さなパケットまたは低スループットリンクの場合、TLV圧縮プロトコル（[compress]や[CCNxz]など）を使用できます。"
    },
    {
      "indent": 3,
      "text": "This document uses the terms CCNx Packet, CCNx Message, and CCNx Message TLV. A CCNx Packet refers to the entire Layer 3 datagram as specified in Section 3.1. A CCNx Message is the ABNF token defined in the CCNx Semantics document [RFC8569]. A CCNx Message TLV refers to the encoding of a CCNx Message as specified in Section 3.6.",
      "ja": "このドキュメントでは、CCNxパケット、CCNxメッセージ、およびCCNxメッセージTLVという用語を使用しています。 CCNxパケットは、セクション3.1で指定されているレイヤ3データグラム全体を指します。 CCNxメッセージは、CCNxセマンティクスドキュメント[RFC8569]で定義されているABNFトークンです。 CCNxメッセージTLVは、セクション3.6で指定されているCCNxメッセージのエンコーディングを指します。"
    },
    {
      "indent": 3,
      "text": "This document specifies:",
      "ja": "このドキュメントは以下を指定します："
    },
    {
      "indent": 3,
      "text": "o the CCNx Packet format,",
      "ja": "o CCNxパケット形式"
    },
    {
      "indent": 3,
      "text": "o the CCNx Message TLV format,",
      "ja": "o CCNxメッセージTLV形式、"
    },
    {
      "indent": 3,
      "text": "o the TLV types used by CCNx messages,",
      "ja": "o CCNxメッセージで使用されるTLVタイプ、"
    },
    {
      "indent": 3,
      "text": "o the encoding of values for each type,",
      "ja": "o 各タイプの値のエンコード、"
    },
    {
      "indent": 3,
      "text": "o top-level types that exist at the outermost containment,",
      "ja": "o 最も外側の封じ込めに存在するトップレベルのタイプ、"
    },
    {
      "indent": 3,
      "text": "o Interest TLVs that exist within Interest containment, and",
      "ja": "o 関心の封じ込め内に存在する関心TLV、および"
    },
    {
      "indent": 3,
      "text": "o Content Object TLVs that exist within Content Object containment.",
      "ja": "o コンテンツオブジェクトコンテインメント内に存在するコンテンツオブジェクトTLV。"
    },
    {
      "indent": 3,
      "text": "This document is supplemented by these documents:",
      "ja": "このドキュメントには、次のドキュメントが補足されています。"
    },
    {
      "indent": 3,
      "text": "o [RFC8569], which covers message semantics and the protocol operation regarding Interest and Content Object, including the Interest Return protocol.",
      "ja": "o [RFC8569]、メッセージセマンティクスと、インタレストおよびコンテンツオブジェクト（インタレストリターンプロトコルを含む）に関するプロトコル操作をカバーしています。"
    },
    {
      "indent": 3,
      "text": "o [CCNxURI], which covers the CCNx URI notation.",
      "ja": "o [CCNxURI]。CCNxURI表記をカバーしています。"
    },
    {
      "indent": 3,
      "text": "The type values in Section 4 conform to the IANA-assigned numbers for the CCNx protocol. This document uses the symbolic names defined in that section. All TLV type values are relative to their parent containers. For example, each level of a nested TLV structure might define a \"type = 1\" with a completely different meaning.",
      "ja": "セクション4のタイプ値は、CCNxプロトコルにIANAが割り当てた番号に準拠しています。 このドキュメントでは、そのセクションで定義されている記号名を使用します。 すべてのTLVタイプの値は、その親コンテナーに関連しています。 たとえば、ネストされたTLV構造の各レベルは、完全に異なる意味を持つ「タイプ= 1」を定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "Packets are represented as 32-bit wide words using ASCII art. Due to the nested levels of TLV encoding and the presence of optional fields and variable sizes, there is no concise way to represent all possibilities. We use the convention that ASCII art fields enclosed by vertical bars \"|\" represent exact bit widths. Fields with a forward slash \"/\" are variable bit widths, which we typically pad out to word alignment for picture readability.",
      "ja": "パケットは、ASCIIアートを使用して32ビット幅のワードとして表されます。 TLVエンコードのネストされたレベルと、オプションのフィールドと変数サイズの存在により、すべての可能性を簡潔に表現する方法はありません。 ASCIIアートフィールドが縦棒「|」で囲まれているという規則を使用します 正確なビット幅を表します。 スラッシュ「/」が付いたフィールドは可変ビット幅であり、通常、画像を読みやすくするためにワードアライメントまでパディングします。"
    },
    {
      "indent": 3,
      "text": "The document represents the consensus of the ICN RG. It is the first ICN protocol from the RG, created from the early CCNx protocol [nnc] with significant revision and input from the ICN community and RG members. The document has received critical reading by several members of the ICN community and the RG. The authors and RG chairs approve of the contents. The document is sponsored under the IRTF and is not issued by the IETF and is not an IETF standard. This is an experimental protocol and may not be suitable for any specific application and the specification may change in the future.",
      "ja": "この文書は、ICN RGのコンセンサスを表しています。 初期のCCNxプロトコル[nnc]から作成されたRGからの最初のICNプロトコルであり、ICNコミュニティとRGメンバーからの大幅な改訂と入力が行われています。 この文書は、ICNコミュニティのいくつかのメンバーとRGから批判的な読み物を受けています。 著者とRG議長が内容を承認します。 このドキュメントはIRTFの下でスポンサーされており、IETFによって発行されたものではなく、IETF標準ではありません。 これは実験的なプロトコルであり、特定のアプリケーションには適していない可能性があり、仕様は将来変更される可能性があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」 この文書の「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すようにすべての大文字で表示される場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "These definitions summarize items defined in [RFC8569]. This document defines their encodings.",
      "ja": "これらの定義は、[RFC8569]で定義されている項目を要約しています。 このドキュメントでは、エンコーディングを定義しています。"
    },
    {
      "indent": 3,
      "text": "o Name: A hierarchically structured variable-length identifier. It is an ordered list of path segments, which are variable-length octet strings. In human-readable form, it is represented in URI format as \"ccnx:/path/part\". There is no host or query string. See [CCNxURI] for complete details.",
      "ja": "o 名前：階層構造の可変長識別子。 これは、可変長のオクテット文字列であるパスセグメントの順序付きリストです。 人間が読める形式では、「ccnx：/ path / part」としてURI形式で表されます。 ホストまたはクエリ文字列はありません。 詳細については、[CCNxURI]を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Interest: A message requesting a Content Object with a matching Name and other optional selectors to choose from multiple objects with the same Name. Any Content Object with a Name and attributes that matches the Name and optional selectors of the Interest is said to satisfy the Interest.",
      "ja": "o 関心：一致する名前を持つコンテンツオブジェクトと、同じ名前を持つ複数のオブジェクトから選択する他のオプションセレクターを要求するメッセージ。 関心の名前とオプションのセレクタに一致する名前と属性を持つコンテンツオブジェクトは、関心を満たすと言われます。"
    },
    {
      "indent": 3,
      "text": "o Content Object: A data object sent in response to an Interest request. It has an optional Name and a content payload that are bound together via cryptographic means.",
      "ja": "o コンテンツオブジェクト：インタレストリクエストへの応答として送信されるデータオブジェクト。 オプションの名前とコンテンツペイロードがあり、これらは暗号化手段を介して結合されています。"
    },
    {
      "indent": 0,
      "text": "3. Type-Length-Value (TLV) Packets",
      "section_title": true,
      "ja": "3. Type-Length-Value（TLV）パケット"
    },
    {
      "indent": 3,
      "text": "We use 16-bit Type and 16-bit Length fields to encode TLV-based packets. This provides 65,536 different possible types and value field lengths of up to 64 KiB. With 65,536 possible types at each level of TLV encoding, there should be sufficient space for basic protocol types, while also allowing ample room for experimentation, application use, vendor extensions, and growth. This encoding does not allow for jumbo packets beyond 64 KiB total length. If used on a media that allows for jumbo frames, we suggest defining a media adaptation envelope that allows for multiple smaller frames.",
      "ja": "16ビットのTypeフィールドと16ビットのLengthフィールドを使用して、TLVベースのパケットをエンコードします。 これにより、65,536の異なるタイプと最大64 KiBの値フィールド長が提供されます。 TLVエンコーディングの各レベルで65,536の可能なタイプがあるため、実験、アプリケーションの使用、ベンダー拡張、および成長のための十分なスペースを確保しながら、基本的なプロトコルタイプに十分なスペースが必要です。 このエンコードでは、合計64 KiBを超えるジャンボパケットは許可されません。 ジャンボフレームを許可するメディアで使用する場合は、複数の小さなフレームを許可するメディアアダプテーションエンベロープを定義することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "+--------+------------------+---------------------------------------+\n| Abbrev |       Name       | Description                           |\n+--------+------------------+---------------------------------------+\n| T_ORG  | Vendor Specific  | Information specific to a vendor      |\n|        |   Information    | implementation (Section 3.3.2).       |\n|        |                  |                                       |\n| T_PAD  |     Padding      | Adds padding to a field (Section      |\n|        |                  | 3.3.1).                               |\n|        |                  |                                       |\n|  n/a   |   Experimental   | Experimental use.                     |\n+--------+------------------+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 1: Reserved TLV Types",
      "ja": "表1：予約済みTLVタイプ"
    },
    {
      "indent": 3,
      "text": "There are several global TLV definitions that we reserve at all hierarchical contexts. The TLV types in the range 0x1000 - 0x1FFF are Reserved for Experimental Use. The TLV type T_ORG is also Reserved for Vendor Extensions (see Section 3.3.2). The TLV type T_PAD is used to optionally pad a field out to some desired alignment.",
      "ja": "すべての階層コンテキストで予約されているいくつかのグローバルTLV定義があります。 0x1000-0x1FFFの範囲のTLVタイプは、実験用に予約されています。 TLVタイプT_ORGは、ベンダー拡張用にも予約されています（セクション3.3.2を参照）。 TLVタイプT_PADを使用して、オプションでフィールドを望ましい配置にパディングします。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|              Type             |            Length             |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 1: Type and Length encoding",
      "ja": "図1：タイプと長さのエンコード"
    },
    {
      "indent": 3,
      "text": "The Length field contains the length of the Value field in octets. It does not include the length of the Type and Length fields. The Length MAY be zero.",
      "ja": "長さフィールドには、オクテット単位の値フィールドの長さが含まれます。 TypeおよびLengthフィールドの長さは含まれません。 長さはゼロである場合があります。"
    },
    {
      "indent": 3,
      "text": "TLV structures are nestable, allowing the Value field of one TLV structure to contain additional TLV structures. The enclosing TLV structure is called the container of the enclosed TLV.",
      "ja": "TLV構造はネスト可能で、1つのTLV構造の値フィールドに追加のTLV構造を含めることができます。 囲まれたTLV構造は、囲まれたTLVのコンテナと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Type values are context dependent. Within a TLV container, one may reuse previous type values for new context-dependent purposes.",
      "ja": "型の値はコンテキストに依存します。 TLVコンテナ内では、新しいコンテキスト依存の目的で以前のタイプ値を再利用できます。"
    },
    {
      "indent": 0,
      "text": "3.1. Overall Packet Format",
      "section_title": true,
      "ja": "3.1. 全体的なパケット形式"
    },
    {
      "indent": 3,
      "text": "Each CCNx Packet includes the 8-byte fixed header, described below, followed by a set of TLV fields. These fields are optional hop-by-hop headers and the Packet Payload.",
      "ja": "各CCNxパケットには、次に説明する8バイトの固定ヘッダーと、それに続く一連のTLVフィールドが含まれます。 これらのフィールドは、オプションのホップバイホップヘッダーとパケットペイロードです。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|    Version    |  PacketType   |         PacketLength          |\n+---------------+---------------+---------------+---------------+\n|           PacketType-specific fields          | HeaderLength  |\n+---------------+---------------+---------------+---------------+\n/ Optional hop-by-hop header TLVs                               /\n+---------------+---------------+---------------+---------------+\n/ PacketPayload TLVs                                            /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2: Overall Packet Format",
      "ja": "図2：全体的なパケット形式"
    },
    {
      "indent": 3,
      "text": "The PacketPayload of a CCNx Packet is the protocol message itself. The Content Object Hash is computed over the PacketPayload only, excluding the fixed and hop-by-hop headers, as those might change from hop to hop. Signed information or similarity hashes should not include any of the fixed or hop-by-hop headers. The PacketPayload should be self-sufficient in the event that the fixed and hop-by-hop headers are removed. See Message Hash (Section 3.4.3).",
      "ja": "CCNxパケットのPacketPayloadは、プロトコルメッセージそのものです。 コンテンツオブジェクトハッシュは、PacketPayloadのみで計算されます。固定ヘッダーとホップバイホップヘッダーは除外されます。これらはホップごとに変化する可能性があるためです。 署名情報または類似ハッシュには、固定ヘッダーまたはホップバイホップヘッダーを含めないでください。 PacketPayloadは、固定ヘッダーとホップバイホップヘッダーが削除された場合に十分なものでなければなりません。 メッセージハッシュ（セクション3.4.3）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Following the CCNx Message TLV, the PacketPayload may include optional Validation TLVs.",
      "ja": "CCNxメッセージTLVに続いて、PacketPayloadにオプションの検証TLVを含めることができます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n| CCNx Message TLV                                              /\n+---------------+---------------+---------------+---------------+\n/ Optional CCNx ValidationAlgorithm TLV                         /\n+---------------+---------------+---------------+---------------+\n/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 3: PacketPayload TLVs",
      "ja": "図3：PacketPayload TLV"
    },
    {
      "indent": 3,
      "text": "After discarding the fixed and hop-by-hop headers, the remaining PacketPayload should be a valid protocol message. Therefore, the PacketPayload always begins with 4 bytes of type-length that specifies the protocol message (whether it is an Interest, Content Object, or other message type) and its total length. The embedding of a self-sufficient protocol data unit inside the fixed and hop-by-hop headers allows a network stack to discard the headers and operate only on the embedded message. It also decouples the PacketType field -- which specifies how to forward the packet -- from the PacketPayload.",
      "ja": "固定ヘッダーとホップバイホップヘッダーを破棄した後、残りのPacketPayloadは有効なプロトコルメッセージである必要があります。 したがって、PacketPayloadは、プロトコルメッセージ（インタレスト、コンテンツオブジェクト、またはその他のメッセージタイプ）とその全長を指定する4バイトのtype-lengthで常に始まります。 固定およびホップバイホップヘッダー内に自給自足のプロトコルデータユニットを埋め込むことにより、ネットワークスタックはヘッダーを破棄し、埋め込みメッセージのみで動作することができます。 また、PacketPayloadからPacketTypeフィールド（パケットの転送方法を指定する）を分離します。"
    },
    {
      "indent": 3,
      "text": "The range of bytes protected by the Validation includes the CCNx Message TLV and the ValidationAlgorithm TLV.",
      "ja": "検証によって保護されるバイトの範囲には、CCNxメッセージTLVおよびValidationAlgorithm TLVが含まれます。"
    },
    {
      "indent": 3,
      "text": "The ContentObjectHash begins with the CCNx Message TLV and ends at the tail of the CCNx Packet.",
      "ja": "ContentObjectHashは、CCNxメッセージTLVで始まり、CCNxパケットの末尾で終わります。"
    },
    {
      "indent": 0,
      "text": "3.2. Fixed Headers",
      "section_title": true,
      "ja": "3.2. 固定ヘッダー"
    },
    {
      "indent": 3,
      "text": "In Figure 2, the fixed header fields are:",
      "ja": "図2では、固定ヘッダーフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Version: defines the version of the packet, which MUST be 1.",
      "ja": "o バージョン：パケットのバージョンを定義します。1でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o HeaderLength: The length of the fixed header (8 bytes) and hop-by-hop headers. The minimum value MUST be 8.",
      "ja": "o HeaderLength：固定ヘッダー（8バイト）およびホップバイホップヘッダーの長さ。 最小値は8でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o PacketType: describes forwarder actions to take on the packet.",
      "ja": "o PacketType：パケットに対して実行するフォワーダーアクションを記述します。"
    },
    {
      "indent": 3,
      "text": "o PacketLength: Total octets of packet including all headers (fixed header plus hop-by-hop headers) and protocol message.",
      "ja": "o PacketLength：すべてのヘッダー（固定ヘッダーとホップバイホップヘッダー）およびプロトコルメッセージを含むパケットの合計オクテット。"
    },
    {
      "indent": 3,
      "text": "o PacketType-specific Fields: specific PacketTypes define the use of these bits.",
      "ja": "o PacketType固有のフィールド：特定のPacketTypesは、これらのビットの使用を定義します。"
    },
    {
      "indent": 3,
      "text": "The PacketType field indicates how the forwarder should process the packet. A Request Packet (Interest) has PacketType PT_INTEREST, a Response (Content Object) has PacketType PT_CONTENT, and an Interest Return has PacketType PT_RETURN.",
      "ja": "PacketTypeフィールドは、フォワーダーがパケットを処理する方法を示します。 要求パケット（インタレスト）にはPacketType PT_INTERESTがあり、応答（コンテンツオブジェクト）にはPacketType PT_CONTENTがあり、インタレストリターンにはPacketType PT_RETURNがあります。"
    },
    {
      "indent": 3,
      "text": "HeaderLength is the number of octets from the start of the CCNx Packet (Version) to the end of the hop-by-hop headers. PacketLength is the number of octets from the start of the packet to the end of the packet. Both lengths have a minimum value of 8 (the fixed header itself).",
      "ja": "HeaderLengthは、CCNxパケット（バージョン）の開始からホップバイホップヘッダーの終了までのオクテット数です。 PacketLengthは、パケットの開始からパケットの終了までのオクテットの数です。 両方の長さの最小値は8です（固定ヘッダー自体）。"
    },
    {
      "indent": 3,
      "text": "The PacketType-specific fields are reserved bits whose use depends on the PacketType. They are used for network-level signaling.",
      "ja": "PacketType固有のフィールドは予約されたビットであり、その用途はPacketTypeに依存します。 これらは、ネットワークレベルのシグナリングに使用されます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Interest Fixed Header",
      "section_title": true,
      "ja": "3.2.1. 関心固定ヘッダー"
    },
    {
      "indent": 3,
      "text": "If the PacketType is PT_INTEREST, it indicates that the packet should be forwarded following the Interest pipeline in Section 2.4.4 of [RFC8569]. For this type of packet, the Fixed Header includes a field for a HopLimit as well as Reserved and Flags fields. The Reserved field MUST be set to 0 in an Interest. There are currently no flags defined, so the Flags field MUST be set to 0.",
      "ja": "PacketTypeがPT_INTERESTである場合、[RFC8569]のSection 2.4.4のInterestパイプラインに従ってパケットを転送する必要があることを示します。 このタイプのパケットの場合、固定ヘッダーにはHopLimitのフィールドと、予約済みフィールドとフラグフィールドが含まれます。 Reservedフィールドは、インタレストで0に設定する必要があります。 現在、フラグは定義されていないため、フラグフィールドは0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|    Version    |  PT_INTEREST  |         PacketLength          |\n+---------------+---------------+---------------+---------------+\n|   HopLimit    |   Reserved    |     Flags     | HeaderLength  |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 4: Interest Header",
      "ja": "図4：インタレストヘッダー"
    },
    {
      "indent": 0,
      "text": "3.2.1.1. Interest HopLimit",
      "section_title": true,
      "ja": "3.2.1.1. Interest HopLimit"
    },
    {
      "indent": 3,
      "text": "For an Interest message, the HopLimit is a counter that is decremented with each hop. It limits the distance an Interest may travel on the network. The node originating the Interest MAY put in any value up to the maximum of 255. Each node that receives an Interest with a HopLimit decrements the value upon reception. If the value is 0 after the decrement, the Interest MUST NOT be forwarded off the node.",
      "ja": "Interestメッセージの場合、HopLimitは、ホップごとに減少するカウンターです。 インタレストがネットワーク上を移動できる距離を制限します。 Interestを生成するノードは、最大255までの任意の値を入力できます。HopLimitでInterestを受信する各ノードは、受信時に値を減らします。 値が減少後0の場合、ノードからインタレストを転送してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "It is an error to receive an Interest from a remote node with the HopLimit field set to 0.",
      "ja": "HopLimitフィールドが0に設定されたリモートノードからInterestを受信するとエラーになります。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Content Object Fixed Header",
      "section_title": true,
      "ja": "3.2.2. コンテンツオブジェクトの固定ヘッダー"
    },
    {
      "indent": 3,
      "text": "If the PacketType is PT_CONTENT, it indicates that the packet should be forwarded following the Content Object pipeline in Section 2.4.4 of [RFC8569]. A Content Object defines a Flags field; however, there are currently no flags defined, so the Flags field must be set to 0.",
      "ja": "PacketTypeがPT_CONTENTの場合、[RFC8569]のセクション2.4.4のコンテンツオブジェクトパイプラインに従ってパケットを転送する必要があることを示します。 コンテンツオブジェクトは、フラグフィールドを定義します。 ただし、現在はフラグが定義されていないため、フラグフィールドを0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|    Version    |  PT_CONTENT   |         PacketLength          |\n+---------------+---------------+---------------+---------------+\n|            Reserved           |     Flags     | HeaderLength  |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 5: Content Object Header",
      "ja": "図5：コンテンツオブジェクトヘッダー"
    },
    {
      "indent": 0,
      "text": "3.2.3. Interest Return Fixed Header",
      "section_title": true,
      "ja": "3.2.3. 利息リターン固定ヘッダー"
    },
    {
      "indent": 3,
      "text": "If the PacketType is PT_RETURN, it indicates that the packet should be processed following the Interest Return rules in Section 10 of [RFC8569]. The only difference between this Interest Return message and the original Interest is that the PacketType is changed to PT_RETURN and a ReturnCode is put into the ReturnCode field. All other fields are unchanged from the Interest packet. The purpose of this encoding is to prevent packet length changes so no additional bytes are needed to return an Interest to the previous hop.",
      "ja": "PacketTypeがPT_RETURNの場合、[RFC8569]のセクション10のインタレストリターン規則に従ってパケットを処理する必要があることを示します。 このInterest Returnメッセージと元のInterestとの唯一の違いは、PacketTypeがPT_RETURNに変更され、ReturnCodeがReturnCodeフィールドに入れられることです。 他のすべてのフィールドはInterestパケットから変更されていません。 このエンコードの目的は、パケット長の変更を防ぐことで、前のホップにInterestを返すために追加のバイトが必要ないようにします。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|    Version    |   PT_RETURN   |         PacketLength          |\n+---------------+---------------+---------------+---------------+\n|   HopLimit    |  ReturnCode   |     Flags     | HeaderLength  |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 6: Interest Return Header",
      "ja": "図6：インタレストリターンヘッダー"
    },
    {
      "indent": 0,
      "text": "3.2.3.1. Interest Return HopLimit",
      "section_title": true,
      "ja": "3.2.3.1. インタレストリターンホップリミット"
    },
    {
      "indent": 3,
      "text": "This is the original Interest's HopLimit, as received before decrement at the node sending the Interest Return.",
      "ja": "これは、インタレストリターンを送信するノードでデクリメントする前に受信した元のインタレストのHopLimitです。"
    },
    {
      "indent": 0,
      "text": "3.2.3.2. Interest Return Flags",
      "section_title": true,
      "ja": "3.2.3.2. 利息返還フラグ"
    },
    {
      "indent": 3,
      "text": "These are the original Flags as set in the Interest.",
      "ja": "これらは、インタレストで設定された元のフラグです。"
    },
    {
      "indent": 0,
      "text": "3.2.3.3. Return Code",
      "section_title": true,
      "ja": "3.2.3.3. リターンコード"
    },
    {
      "indent": 3,
      "text": "This section maps the Return Code name [RFC8569] to the TLV symbolic name. Section 4.2 maps the symbolic names to numeric values. This field is set by the node creating the Interest Return.",
      "ja": "このセクションでは、リターンコード名[RFC8569]をTLVシンボリック名にマップします。 セクション4.2は、シンボル名を数値にマップします。 このフィールドは、インタレストリターンを作成するノードによって設定されます。"
    },
    {
      "indent": 3,
      "text": "A return code of \"0\" MUST NOT be used, as it indicates that the returning system did not modify the Return Code field.",
      "ja": "「0」の戻りコードは使用しないでください。これは、戻りシステムが「戻りコード」フィールドを変更しなかったことを示すためです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------+-----------------------------+\n|             Return Type             | Name in RFC 8569            |\n+-------------------------------------+-----------------------------+\n|          T_RETURN_NO_ROUTE          | No Route                    |\n|                                     |                             |\n|       T_RETURN_LIMIT_EXCEEDED       | Hop Limit Exceeded          |\n|                                     |                             |\n|        T_RETURN_NO_RESOURCES        | No Resources                |\n|                                     |                             |\n|         T_RETURN_PATH_ERROR         | Path Error                  |\n|                                     |                             |\n|         T_RETURN_PROHIBITED         | Prohibited                  |\n|                                     |                             |\n|          T_RETURN_CONGESTED         | Congested                   |\n|                                     |                             |\n|        T_RETURN_MTU_TOO_LARGE       | MTU too large               |\n|                                     |                             |\n| T_RETURN_UNSUPPORTED_HASH_RESTRICTI | Unsupported ContentObjectHa |\n|                  ON                 | shRestriction               |\n|                                     |                             |\n|     T_RETURN_MALFORMED_INTEREST     | Malformed Interest          |\n+-------------------------------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 2: Return Codes",
      "ja": "表2：戻りコード"
    },
    {
      "indent": 0,
      "text": "3.3. Global Formats",
      "section_title": true,
      "ja": "3.3. グローバルフォーマット"
    },
    {
      "indent": 3,
      "text": "This section defines global formats that may be nested within other TLVs.",
      "ja": "このセクションでは、他のTLV内にネストできるグローバル形式を定義します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Pad",
      "section_title": true,
      "ja": "3.3.1. パッド"
    },
    {
      "indent": 3,
      "text": "The pad type may be used by sources that prefer word-aligned data. Padding 4-byte words, for example, would use a 1-byte, 2-byte, and 3-byte Length. Padding 8-byte words would use a (0, 1, 2, 3, 5, 6, 7)-byte Length.",
      "ja": "パッドタイプは、ワード境界で整列されたデータを好むソースによって使用されます。 たとえば、4バイトのワードをパディングするには、1バイト、2バイト、および3バイトの長さを使用します。 8バイトのワードをパディングするには、（0、1、2、3、5、6、7）バイトの長さを使用します。"
    },
    {
      "indent": 3,
      "text": "One MUST NOT pad inside a Name. Apart from that, a pad MAY be inserted after any other TLV in the CCNx Message TLV or in the ValidationAlgorithm TLV. In the remainder of this document, we will not show optional Pad TLVs.",
      "ja": "名前の中にパディングしてはいけません。 それとは別に、CCNxメッセージTLVまたはValidationAlgorithm TLVの他のTLVの後にパッドを挿入することができます。 このドキュメントの残りの部分では、オプションのパッドTLVは表示しません。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|             T_PAD             |             Length            |\n+---------------+---------------+---------------+---------------+\n/                 variable-length pad MUST be zeros             /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 7: Pad Encoding",
      "ja": "図7：パッドエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.3.2. Organization-Specific TLVs",
      "section_title": true,
      "ja": "3.3.2. 組織固有のTLV"
    },
    {
      "indent": 3,
      "text": "Organization-specific TLVs (also known as Vendor TLVs) MUST use the T_ORG type. The Length field is the length of the organization-specific information plus 3. The Value begins with the 3 byte organization number derived from the network byte order encoding of the IANA \"Private Enterprise Numbers\" registry [IANA-PEN], followed by the organization-specific information.",
      "ja": "組織固有のTLV（ベンダーTLVとも呼ばれる）は、T_ORGタイプを使用する必要があります。 長さフィールドは、組織固有の情報に3を加えた長さです。値は、IANA「プライベートエンタープライズ番号」レジストリ[IANA-PEN]のネットワークバイト順エンコーディングから派生した3バイトの組織番号で始まり、その後に組織が続きます。 固有の情報。"
    },
    {
      "indent": 3,
      "text": "A T_ORG MAY be used as a path segment in a Name. It is treated like any other path segment.",
      "ja": "T_ORGは、名前のパスセグメントとして使用できます。 他のパスセグメントと同様に扱われます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|             T_ORG             |     Length (3+value length)   |\n+---------------+---------------+---------------+---------------+\n|   PEN[0]      |    PEN[1]     |     PEN[2]    |               /\n+---------------+---------------+---------------+               +\n/                  Vendor Specific Value                        /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 8: Organization-Specific TLVs",
      "ja": "図8：組織固有のTLV"
    },
    {
      "indent": 0,
      "text": "3.3.3. Hash Format",
      "section_title": true,
      "ja": "3.3.3. ハッシュ形式"
    },
    {
      "indent": 3,
      "text": "Hash values are used in several fields throughout a packet. This TLV encoding is commonly embedded inside those fields to specify the specific hash function used and its value. Note that the reserved TLV types are also reserved here for user-defined experimental functions.",
      "ja": "ハッシュ値は、パケット全体のいくつかのフィールドで使用されます。 このTLVエンコーディングは、一般にこれらのフィールド内に埋め込まれ、使用される特定のハッシュ関数とその値を指定します。 予約済みのTLVタイプは、ここでユーザー定義の実験関数用にも予約されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The LENGTH field of the hash value MUST be less than or equal to the hash function length. If the LENGTH is less than the full length, it is taken as the left LENGTH bytes of the hash function output. Only specified truncations are allowed, not arbitrary truncations.",
      "ja": "ハッシュ値のLENGTHフィールドは、ハッシュ関数の長さ以下でなければなりません。 LENGTHが全長より短い場合、ハッシュ関数出力の左LENGTHバイトとして取得されます。 指定された切り捨てのみが許可され、任意の切り捨ては許可されません。"
    },
    {
      "indent": 3,
      "text": "This nested format is used because it allows binary comparison of hash values for certain fields without a router needing to understand a new hash function. For example, the KeyIdRestriction is bit-wise compared between an Interest's KeyIdRestriction field and a ContentObject's KeyId field. This format means the outer field values do not change with differing hash functions so a router can still identify those fields and do a binary comparison of the hash TLV without need to understand the specific hash used. An alternative approach, such as using T_KEYID_SHA512-256, would require each router keeps an up-to-date parser and supporting user-defined hash functions here would explode the parsing state-space.",
      "ja": "このネストされたフォーマットは、ルーターが新しいハッシュ関数を理解する必要なく、特定のフィールドのハッシュ値のバイナリ比較を許可するために使用されます。 たとえば、KeyIdRestrictionは、インタレストのKeyIdRestrictionフィールドとContentObjectのKeyIdフィールドの間でビット単位で比較されます。 この形式は、外側のフィールド値が異なるハッシュ関数で変化しないことを意味するため、ルーターはこれらのフィールドを識別し、使用される特定のハッシュを理解する必要なくハッシュTLVのバイナリ比較を行うことができます。 T_KEYID_SHA512-256を使用するなどの代替アプローチでは、各ルーターが最新のパーサーを保持する必要があり、ここでユーザー定義のハッシュ関数をサポートすると、解析状態空間が爆発します。"
    },
    {
      "indent": 3,
      "text": "A CCNx entity MUST support the hash type T_SHA-256. An entity MAY support the remaining hash types.",
      "ja": "CCNxエンティティは、ハッシュタイプT_SHA-256をサポートする必要があります。 エンティティは、残りのハッシュタイプをサポートする場合があります。"
    },
    {
      "indent": 18,
      "text": "+-----------+------------------------+\n|   Abbrev  |    Lengths (octets)    |\n+-----------+------------------------+\n| T_SHA-256 |           32           |\n|           |                        |\n| T_SHA-512 |         64, 32         |\n|           |                        |\n|    n/a    | Experimental TLV types |\n+-----------+------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 3: CCNx Hash Functions",
      "ja": "表3：CCNxハッシュ関数"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|             T_FOO             |              36               |\n+---------------+---------------+---------------+---------------+\n|           T_SHA512            |               32              |\n+---------------+---------------+---------------+---------------+\n/                        32-byte hash value                     /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 9: Example nesting inside type T_FOO",
      "ja": "図9：T_FOO型内のネストの例"
    },
    {
      "indent": 0,
      "text": "3.3.4. Link",
      "section_title": true,
      "ja": "3.3.4. リンク"
    },
    {
      "indent": 3,
      "text": "A Link is the tuple: {Name, [KeyIdRestr], [ContentObjectHashRestr]}. It is a general encoding that is used in both the payload of a Content Object with PayloadType = \"Link\" and in a Content Object's KeyLink field. A Link is essentially the body of an Interest.",
      "ja": "リンクはタプルです：{Name、[KeyIdRestr]、[ContentObjectHashRestr]}。 PayloadType = \"Link\"のコンテンツオブジェクトのペイロードとコンテンツオブジェクトのKeyLinkフィールドの両方で使用される一般的なエンコーディングです。 リンクは、本質的に関心の対象です。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n/ Mandatory CCNx Name                                           /\n+---------------+---------------+---------------+---------------+\n/ Optional KeyIdRestriction                                     /\n+---------------+---------------+---------------+---------------+\n/ Optional ContentObjectHashRestriction                         /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 10: Link Encoding",
      "ja": "図10：リンクエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.4. Hop-by-Hop TLV Headers",
      "section_title": true,
      "ja": "3.4. ホップバイホップTLVヘッダー"
    },
    {
      "indent": 3,
      "text": "Hop-by-hop TLV headers are unordered and meaning MUST NOT be attached to their ordering. Three hop-by-hop headers are described in this document:",
      "ja": "ホップバイホップTLVヘッダーは順序付けられていないため、順序付けに意味を付けてはなりません（MUST NOT）。 このドキュメントでは、3つのホップバイホップヘッダーについて説明します。"
    },
    {
      "indent": 3,
      "text": "+-------------+--------------------+--------------------------------+\n|    Abbrev   |        Name        | Description                    |\n+-------------+--------------------+--------------------------------+\n|  T_INTLIFE  | Interest Lifetime  | The time an Interest should    |\n|             |  (Section 3.4.1)   | stay pending at an             |\n|             |                    | intermediate node.             |\n|             |                    |                                |\n| T_CACHETIME | Recommended Cache  | The Recommended Cache Time for |\n|             |   Time (Section    | Content Objects.               |\n|             |       3.4.2)       |                                |\n|             |                    |                                |\n|  T_MSGHASH  |    Message Hash    | A cryptographic hash (Section  |\n|             |  (Section 3.4.3)   | 3.3.3).                        |\n+-------------+--------------------+--------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 4: Hop-by-Hop Header Types",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Additional hop-by-hop headers are defined in higher level specifications such as the fragmentation specification.",
      "ja": "追加のホップバイホップヘッダーは、フラグメンテーション仕様などの上位レベルの仕様で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Interest Lifetime",
      "section_title": true,
      "ja": "3.4.1. インタレストライフタイム"
    },
    {
      "indent": 3,
      "text": "The Interest Lifetime is the time that an Interest should stay pending at an intermediate node. It is expressed in milliseconds as an unsigned integer in network byte order.",
      "ja": "インタレストライフタイムは、インタレストが中間ノードで保留状態になる時間です。 ネットワークバイト順の符号なし整数としてミリ秒単位で表されます。"
    },
    {
      "indent": 3,
      "text": "A value of 0 (encoded as 1 byte 0x00) indicates the Interest does not elicit a Content Object response. It should still be forwarded, but no reply is expected and a forwarder could skip creating a PIT entry.",
      "ja": "値0（1バイト0x00としてエンコード）は、インタレストがコンテンツオブジェクトの応答を誘発しないことを示します。 それでも転送する必要がありますが、応答は期待されず、フォワーダーはPITエントリの作成をスキップできます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|          T_INTLIFE            |             Length            |\n+---------------+---------------+---------------+---------------+\n/                                                               /\n/                      Lifetime (Length octets)                 /\n/                                                               /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 11: Interest Lifetime Encoding",
      "ja": "図11：インタレストライフタイムエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.4.2. Recommended Cache Time",
      "section_title": true,
      "ja": "3.4.2. 推奨キャッシュ時間"
    },
    {
      "indent": 3,
      "text": "The Recommended Cache Time (RCT) is a measure of the useful lifetime of a Content Object as assigned by a content producer or upstream node. It serves as a guideline to the Content Store cache in determining how long to keep the Content Object. It is a recommendation only and may be ignored by the cache. This is in contrast to the ExpiryTime (described in Section 3.6.2.2.2) which takes precedence over the RCT and must be obeyed.",
      "ja": "推奨キャッシュ時間（RCT）は、コンテンツプロデューサーまたはアップストリームノードによって割り当てられたコンテンツオブジェクトの有効期間の尺度です。 コンテンツオブジェクトを保持する期間を決定する際に、コンテンツストアキャッシュのガイドラインとして機能します。 これは推奨のみであり、キャッシュによって無視される場合があります。 これは、RCTよりも優先され、従わなければならないExpiryTime（セクション3.6.2.2.2で説明）とは対照的です。"
    },
    {
      "indent": 3,
      "text": "Because the Recommended Cache Time is an optional hop-by-hop header and not a part of the signed message, a content producer may re-issue a previously signed Content Object with an updated RCT without needing to re-sign the message. There is little ill effect from an attacker changing the RCT as the RCT serves as a guideline only.",
      "ja": "Recommended Cache Timeはオプションのホップバイホップヘッダーであり、署名されたメッセージの一部ではないため、コンテンツプロデューサーは、メッセージに再署名する必要なく、更新されたRCTで以前に署名されたコンテンツオブジェクトを再発行できます。 RCTはガイドラインとしてのみ機能するため、攻撃者がRCTを変更してもほとんど悪影響はありません。"
    },
    {
      "indent": 3,
      "text": "The Recommended Cache Time (a millisecond timestamp) is an unsigned integer in network byte order that indicates the time when the payload expires (as the number of milliseconds since the epoch in UTC). It is a 64-bit field.",
      "ja": "推奨キャッシュ時間（ミリ秒のタイムスタンプ）は、ペイロードが期限切れになる時間（UTCのエポックからのミリ秒数）を示すネットワークバイト順の符号なし整数です。 これは64ビットのフィールドです。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|         T_CACHETIME           |               8               |\n+---------------+---------------+---------------+---------------+\n/                                                               /\n/                    Recommended Cache Time                     /\n/                                                               /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 12: Recommended Cache Time Encoding",
      "ja": "図12：推奨されるキャッシュ時間エンコーディング"
    },
    {
      "indent": 0,
      "text": "3.4.3. Message Hash",
      "section_title": true,
      "ja": "3.4.3. メッセージハッシュ"
    },
    {
      "indent": 3,
      "text": "Within a trusted domain, an operator may calculate the message hash at a border device and insert that value into the hop-by-hop headers of a message. An egress device should remove the value. This permits intermediate devices within that trusted domain to match against a ContentObjectHashRestriction without calculating it at every hop.",
      "ja": "信頼できるドメイン内で、オペレーターは境界デバイスでメッセージハッシュを計算し、その値をメッセージのホップバイホップヘッダーに挿入できます。 出力デバイスは値を削除する必要があります。 これにより、その信頼されたドメイン内の中間デバイスは、すべてのホップで計算することなく、ContentObjectHashRestrictionと照合できます。"
    },
    {
      "indent": 3,
      "text": "The message hash is a cryptographic hash from the start of the CCNx Message TLV to the end of the packet. It is used to match against the ContentObjectHashRestriction (Section 3.6.2.1.2). The Message Hash may be of longer length than an Interest's restriction, in which case the device should use the left bytes of the Message Hash to check against the Interest's value.",
      "ja": "メッセージハッシュは、CCNxメッセージTLVの開始からパケットの終了までの暗号化ハッシュです。 ContentObjectHashRestriction（セクション3.6.2.1.2）との照合に使用されます。 メッセージハッシュはインタレストの制限よりも長い場合があります。その場合、デバイスはメッセージハッシュの左バイトを使用してインタレストの値をチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "The Message Hash may only carry one hash type and there may only be one Message Hash header.",
      "ja": "メッセージハッシュには1つのハッシュタイプのみを含めることができ、メッセージハッシュヘッダーは1つだけにすることができます。"
    },
    {
      "indent": 3,
      "text": "The Message Hash header is unprotected, so this header is only of practical use within a trusted domain, such as an operator's autonomous system.",
      "ja": "メッセージハッシュヘッダーは保護されていないため、このヘッダーは、オペレータの自律システムなどの信頼できるドメイン内でのみ実用的です。"
    },
    {
      "indent": 3,
      "text": "                    1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|          T_MSGHASH            |         (length + 4)          |\n+---------------+---------------+---------------+---------------+\n|          hash type            |            length             |\n+---------------+---------------+---------------+---------------+\n/                           hash value                          /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 13: Message Hash Header",
      "ja": "図13：メッセージハッシュヘッダー"
    },
    {
      "indent": 0,
      "text": "3.5. Top-Level Types",
      "section_title": true,
      "ja": "3.5. トップレベルのタイプ"
    },
    {
      "indent": 3,
      "text": "The top-level TLV types listed below exist at the outermost level of a CCNx Message TLV.",
      "ja": "以下にリストされている最上位のTLVタイプは、CCNxメッセージTLVの最も外側のレベルに存在します。"
    },
    {
      "indent": 3,
      "text": "+----------------------+------------+-------------------------------+\n|        Abbrev        |    Name    | Description                   |\n+----------------------+------------+-------------------------------+\n|      T_INTEREST      |  Interest  | An Interest MessageType.      |\n|                      |  (Section  |                               |\n|                      |    3.6)    |                               |\n|                      |            |                               |\n|       T_OBJECT       |  Content   | A Content Object MessageType  |\n|                      |   Object   |                               |\n|                      |  (Section  |                               |\n|                      |    3.6)    |                               |\n|                      |            |                               |\n|   T_VALIDATION_ALG   | Validation | The method of message         |\n|                      | Algorithm  | verification such as a        |\n|                      |  (Section  | Message Integrity Check       |\n|                      |  3.6.4.1)  | (MIC), Message Authentication |\n|                      |            | Code (MAC), or cryptographic  |\n|                      |            | signature.                    |\n|                      |            |                               |\n| T_VALIDATION_PAYLOAD | Validation | The validation output, such   |\n|                      |  Payload   | as the CRC32C code or the RSA |\n|                      |  (Section  | signature.                    |\n|                      |  3.6.4.2)  |                               |\n+----------------------+------------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 5: CCNx Top Level Types",
      "ja": "表5：CCNxトップレベルタイプ"
    },
    {
      "indent": 0,
      "text": "3.6. CCNx Message TLV",
      "section_title": true,
      "ja": "3.6. CCNxメッセージTLV"
    },
    {
      "indent": 3,
      "text": "This is the format for the CCNx Message itself. The CCNx Message TLV is the portion of the CCNx Packet between the hop-by-hop headers and the Validation TLVs. The figure below is an expansion of the \"CCNx Message TLV\" depicted in the beginning of Section 3. The CCNx Message TLV begins with MessageType and runs through the optional Payload. The same general format is used for both Interest and Content Object messages which are differentiated by the MessageType field. The first enclosed TLV of a CCNx Message TLV is always the Name TLV, if present. This is followed by an optional Message TLVs and an optional Payload TLV.",
      "ja": "これは、CCNxメッセージ自体の形式です。 CCNxメッセージTLVは、ホップバイホップヘッダーと検証TLVの間のCCNxパケットの部分です。 次の図は、セクション3の冒頭に示した「CCNxメッセージTLV」の拡張です。CCNxメッセージTLVは、MessageTypeで始まり、オプションのペイロードを実行します。 同じ一般的な形式が、MessageTypeフィールドによって区別されるインタレストメッセージとコンテンツオブジェクトメッセージの両方に使用されます。 CCNxメッセージTLVの最初に囲まれたTLVは、存在する場合は常に名前TLVです。 この後に、オプションのメッセージTLVとオプションのペイロードTLVが続きます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|         MessageType           |         MessageLength         |\n+---------------+---------------+---------------+---------------+\n/ Name TLV       (Type = T_NAME)                                /\n+---------------+---------------+---------------+---------------+\n/ Optional Message TLVs   (Various Types)                       /\n+---------------+---------------+---------------+---------------+\n/ Optional Payload TLV  (Type = T_PAYLOAD)                      /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 14: CCNx Message TLV Encoding",
      "ja": "図14：CCNxメッセージTLVエンコーディング"
    },
    {
      "indent": 3,
      "text": "+-----------+---------------+---------------------------------------+\n|   Abbrev  |      Name     | Description                           |\n+-----------+---------------+---------------------------------------+\n|   T_NAME  | Name (Section | The CCNx Name requested in an         |\n|           |     3.6.1)    | Interest or published in a Content    |\n|           |               | Object.                               |\n|           |               |                                       |\n| T_PAYLOAD |    Payload    | The message payload.                  |\n|           |    (Section   |                                       |\n|           |     3.6.3)    |                                       |\n+-----------+---------------+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 6: CCNx Message TLV Types",
      "ja": "表6：CCNxメッセージTLVタイプ"
    },
    {
      "indent": 0,
      "text": "3.6.1. Name",
      "section_title": true,
      "ja": "3.6.1. 名前"
    },
    {
      "indent": 3,
      "text": "A Name is a TLV encoded sequence of segments. The table below lists the type values appropriate for these name segments. A Name MUST NOT include Pad TLVs.",
      "ja": "名前は、TLVエンコードされたセグメントのシーケンスです。 次の表に、これらの名前セグメントに適したタイプ値を示します。 名前にパッドTLVを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "As described in CCNx Semantics [RFC8569], using the CCNx URI [CCNxURI] notation, a T_NAME with zero length corresponds to \"ccnx:/\" (the default route). The message grammar does not allow the first name segment to have zero length in a CCNx Message TLV Name. In the TLV encoding, \"ccnx:/\" corresponds to T_NAME with zero length.",
      "ja": "CCNxセマンティクス[RFC8569]で説明されているように、CCNx URI [CCNxURI]表記を使用すると、長さがゼロのT_NAMEは「ccnx：/」（デフォルトルート）に対応します。 メッセージグラマーでは、CCNxメッセージTLV名の最初の名前セグメントの長さをゼロにすることはできません。 TLVエンコーディングでは、「ccnx：/」は長さがゼロのT_NAMEに対応します。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|            T_NAME             |            Length             |\n+---------------+---------------+---------------+---------------+\n/ Name segment TLVs                                             /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 15: Name Encoding",
      "ja": "図15：名前のエンコード"
    },
    {
      "indent": 3,
      "text": "+---------------+-------------+-------------------------------------+\n| Symbolic Name |     Name    | Description                         |\n+---------------+-------------+-------------------------------------+\n| T_NAMESEGMENT |     Name    | A generic name segment.             |\n|               |   segment   |                                     |\n|               |   (Section  |                                     |\n|               |   3.6.1.1)  |                                     |\n|               |             |                                     |\n|     T_IPID    |   Interest  | An identifier that represents the   |\n|               |  Payload ID | Interest Payload field. As an       |\n|               |   (Section  | example, the Payload ID might be a  |\n|               |   3.6.1.2)  | hash of the Interest Payload.  This |\n|               |             | provides a way to differentiate     |\n|               |             | between Interests based on their    |\n|               |             | payloads without having to parse    |\n|               |             | all the bytes of the payload        |\n|               |             | itself, and instead using only this |\n|               |             | Payload ID name segment.            |\n|               |             |                                     |\n|   T_APP:00 -  | Application | Application-specific payload in a   |\n|   T_APP:4096  |  Components | name segment.  An application may   |\n|               |   (Section  | apply its own semantics to the 4096 |\n|               |   3.6.1.1)  | reserved types.                     |\n+---------------+-------------+-------------------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Table 7: CCNx Name Types",
      "ja": "表7：CCNx名前タイプ"
    },
    {
      "indent": 0,
      "text": "3.6.1.1. Name Segments",
      "section_title": true,
      "ja": "3.6.1.1. 名前セグメント"
    },
    {
      "indent": 3,
      "text": "4096 special application payload name segments are allocated. These have application semantics applied to them. A good convention is to put the application's identity in the name prior to using these name segments.",
      "ja": "4096 特別なアプリケーションペイロード名セグメントが割り当てられます。 これらにはアプリケーションセマンティクスが適用されます。 これらの名前セグメントを使用する前に、名前にアプリケーションのIDを含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "For example, a name like \"ccnx:/foo/bar/hi\" would be encoded as:",
      "ja": "たとえば、「ccnx：/ foo / bar / hi」などの名前は次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|            (T_NAME)           |           0x14 (20)           |\n+---------------+---------------+---------------+---------------+\n|        (T_NAME_SEGMENT)       |           0x03 (3)            |\n+---------------+---------------+---------------+---------------+\n|       f                o               o      |(T_NAME_SEGMENT)\n+---------------+---------------+---------------+---------------+\n|               |            0x03 (3)           |       b       |\n+---------------+---------------+---------------+---------------+\n|      a                r       |           (T_NAME_SEGMENT)    |\n+---------------+---------------+---------------+---------------+\n|           0x02 (2)            |       h       |       i       |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 16: Name Encoding Example",
      "ja": "図16：名前エンコードの例"
    },
    {
      "indent": 0,
      "text": "3.6.1.2. Interest Payload ID",
      "section_title": true,
      "ja": "3.6.1.2. インタレストペイロードID"
    },
    {
      "indent": 3,
      "text": "The InterestPayloadID is a name segment created by the origin of an Interest to represent the Interest Payload. This allows the proper multiplexing of Interests based on their name if they have different payloads. A common representation is to use a hash of the Interest Payload as the InterestPayloadID.",
      "ja": "InterestPayloadIDは、Interestペイロードを表すためにInterestのオリジンによって作成された名前セグメントです。 これにより、異なるペイロードがある場合、名前に基づいて興味の適切な多重化が可能になります。 一般的な表現は、インタレストペイロードのハッシュをInterestPayloadIDとして使用することです。"
    },
    {
      "indent": 3,
      "text": "As part of the Value of the TLV, the InterestPayloadID contains a one-octet identifier of the method used to create the InterestPayloadID followed by a variable-length octet string. An implementation is not required to implement any of the methods to receive an Interest; the InterestPayloadID may be treated only as an opaque octet string for the purposes of multiplexing Interests with different payloads. Only a device creating an InterestPayloadID name segment or a device verifying such a segment needs to implement the algorithms.",
      "ja": "TLVの値の一部として、InterestPayloadIDには、InterestPayloadIDの作成に使用されるメソッドの1オクテット識別子とそれに続く可変長オクテット文字列が含まれます。 実装は、インタレストを受け取るためのメソッドを実装する必要はありません。 InterestPayloadIDは、異なるペイロードを持つInterestを多重化するために、不透明なオクテット文字列としてのみ扱うことができます。 InterestPayloadID名前セグメントを作成するデバイスまたはそのようなセグメントを検証するデバイスのみが、アルゴリズムを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "It uses the encoding of hash values specified in Section 3.3.3.",
      "ja": "セクション3.3.3で指定されたハッシュ値のエンコードを使用します。"
    },
    {
      "indent": 3,
      "text": "In normal operations, we recommend displaying the InterestPayloadID as an opaque octet string in a CCNx URI, as this is the common denominator for implementation parsing.",
      "ja": "通常の操作では、InterestPayloadIDをCCNx URIの不透明なオクテット文字列として表示することをお勧めします。これは実装の解析の共通点です。"
    },
    {
      "indent": 3,
      "text": "The InterestPayloadID, even if it is a hash, should not convey any security context. If a system requires confirmation that a specific entity created the InterestPayload, it should use a cryptographic signature on the Interest via the ValidationAlgorithm and ValidationPayload or use its own methods inside the Interest Payload.",
      "ja": "InterestPayloadIDは、それがハッシュであっても、セキュリティコンテキストを伝えてはなりません。 特定のエンティティがInterestPayloadを作成したことを確認する必要がある場合、ValidationAlgorithmおよびValidationPayloadを介してInterestの暗号署名を使用するか、Interest Payload内で独自のメソッドを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Message TLVs",
      "section_title": true,
      "ja": "3.6.2. メッセージTLV"
    },
    {
      "indent": 3,
      "text": "Each message type (Interest or Content Object) is associated with a set of optional Message TLVs. Additional specification documents may extend the types associated with each.",
      "ja": "各メッセージタイプ（インタレストまたはコンテンツオブジェクト）は、オプションのメッセージTLVのセットに関連付けられています。 追加の仕様文書では、それぞれに関連付けられているタイプを拡張できます。"
    },
    {
      "indent": 0,
      "text": "3.6.2.1. Interest Message TLVs",
      "section_title": true,
      "ja": "3.6.2.1. インタレストメッセージTLV"
    },
    {
      "indent": 3,
      "text": "There are two Message TLVs currently associated with an Interest message: the KeyIdRestriction selector and the ContentObjectHashRestr selector are used to narrow the universe of acceptable Content Objects that would satisfy the Interest.",
      "ja": "インタレストメッセージに現在関連付けられているメッセージTLVは2つあります。KeyIdRestrictionセレクタとContentObjectHashRestrセレクタは、インタレストを満たす許容可能なコンテンツオブジェクトのユニバースを絞り込むために使用されます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|         MessageType           |         MessageLength         |\n+---------------+---------------+---------------+---------------+\n| Name TLV                                                      |\n+---------------+---------------+---------------+---------------+\n/ Optional KeyIdRestriction TLV                                 /\n+---------------------------------------------------------------+\n/ Optional ContentObjectHashRestriction TLV                     /\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 17: Interest Message TLVs",
      "ja": "図17：インタレストメッセージTLV"
    },
    {
      "indent": 3,
      "text": "+----------------+------------------------------+-------------------+\n|     Abbrev     |             Name             | Description       |\n+----------------+------------------------------+-------------------+\n|  T_KEYIDRESTR  |  KeyIdRestriction (Section   | A representation  |\n|                |          3.6.2.1.1)          | (as per Section   |\n|                |                              | 3.3.3) of the     |\n|                |                              | KeyId             |\n|                |                              |                   |\n| T_OBJHASHRESTR | ContentObjectHashRestriction | A representation  |\n|                |     (Section 3.6.2.1.2)      | (as per Section   |\n|                |                              | 3.3.3) of the     |\n|                |                              | hash of the       |\n|                |                              | specific Content  |\n|                |                              | Object that would |\n|                |                              | satisfy the       |\n|                |                              | Interest.         |\n+----------------+------------------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 8: CCNx Interest Message TLV Types",
      "ja": "表8：CCNx関心メッセージTLVタイプ"
    },
    {
      "indent": 0,
      "text": "3.6.2.1.1. KeyIdRestriction",
      "section_title": true,
      "ja": "3.6.2.1.1. KeyIdRestriction"
    },
    {
      "indent": 3,
      "text": "An Interest MAY include a KeyIdRestriction selector. This ensures that only Content Objects with matching KeyIds will satisfy the Interest. See Section 3.6.4.1.4.1 for the format of a KeyId.",
      "ja": "InterestにはKeyIdRestrictionセレクターを含めることができます。 これにより、一致するKeyIdを持つコンテンツオブジェクトのみがインタレストを満たします。 KeyIdの形式については、セクション3.6.4.1.4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.6.2.1.2. ContentObjectHashRestriction",
      "section_title": true,
      "ja": "3.6.2.1.2. ContentObjectHashRestriction"
    },
    {
      "indent": 3,
      "text": "An Interest MAY contain a ContentObjectHashRestriction selector. This is the hash of the Content Object -- the self-certifying name restriction that must be verified in the network, if an Interest carried this restriction (see Message Hash (Section 3.4.3)). The LENGTH MUST be from one of the allowed values for that hash (see Section 3.3.3).",
      "ja": "インタレストには、ContentObjectHashRestrictionセレクターを含めることができます。 これはコンテンツオブジェクトのハッシュです-利害関係者がこの制限を実施した場合、ネットワークで検証する必要がある自己証明名の制限です（メッセージハッシュ（セクション3.4.3）を参照）。 LENGTHは、そのハッシュで許可されている値のいずれかからのものでなければなりません（セクション3.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The ContentObjectHashRestriction SHOULD be of type T_SHA-256 and of length 32 bytes.",
      "ja": "ContentObjectHashRestrictionは、タイプがT_SHA-256で、長さが32バイトである必要があります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|        T_OBJHASHRESTR         |           (LENGTH+4)          |\n+---------------+---------------+---------------+---------------+\n|           hash type           |             LENGTH            |\n+---------------+---------------+---------------+---------------+\n/                     LENGTH octets of hash                     /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 18: ContentObjectHashRestriction Encoding",
      "ja": "図18：ContentObjectHashRestrictionエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.2.2. Content Object Message TLVs",
      "section_title": true,
      "ja": "3.6.2.2. コンテンツオブジェクトメッセージTLV"
    },
    {
      "indent": 3,
      "text": "The following message TLVs are currently defined for Content Objects: PayloadType (optional) and ExpiryTime (optional).",
      "ja": "現在、コンテンツオブジェクトに対してメッセージTLVが定義されています：PayloadType（オプション）およびExpiryTime（オプション）。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|         MessageType           |         MessageLength         |\n+---------------+---------------+---------------+---------------+\n| Name TLV                                                      |\n+---------------+---------------+---------------+---------------+\n/ Optional PayloadType TLV                                      /\n+---------------------------------------------------------------+\n/ Optional ExpiryTime TLV                                       /\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 19: Content Object Message TLVs",
      "ja": "図19：コンテンツオブジェクトメッセージTLV"
    },
    {
      "indent": 3,
      "text": "+-------------+-------------+---------------------------------------+\n|    Abbrev   |     Name    | Description                           |\n+-------------+-------------+---------------------------------------+\n| T_PAYLDTYPE | PayloadType | Indicates the type of Payload         |\n|             |   (Section  | contents.                             |\n|             |  3.6.2.2.1) |                                       |\n|             |             |                                       |\n|   T_EXPIRY  |  ExpiryTime | The time at which the Payload         |\n|             |   (Section  | expires, as expressed in the number   |\n|             |  3.6.2.2.2) | of milliseconds since the epoch in    |\n|             |             | UTC.  If missing, Content Object may  |\n|             |             | be used as long as desired.           |\n+-------------+-------------+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 9: CCNx Content Object Message TLV Types",
      "ja": "表9：CCNxコンテンツオブジェクトメッセージTLVタイプ"
    },
    {
      "indent": 0,
      "text": "3.6.2.2.1. PayloadType",
      "section_title": true,
      "ja": "3.6.2.2.1. PayloadType"
    },
    {
      "indent": 3,
      "text": "The PayloadType is an octet representing the general type of the Payload TLV.",
      "ja": "PayloadTypeは、ペイロードTLVの一般的なタイプを表すオクテットです。"
    },
    {
      "indent": 3,
      "text": "o T_PAYLOADTYPE_DATA: Data (possibly encrypted)",
      "ja": "o T_PAYLOADTYPE_DATA：データ（暗号化されている可能性があります）"
    },
    {
      "indent": 3,
      "text": "o T_PAYLOADTYPE_KEY: Key",
      "ja": "o T_PAYLOADTYPE_KEY：キー"
    },
    {
      "indent": 3,
      "text": "o T_PAYLOADTYPE_LINK: Link",
      "ja": "o T_PAYLOADTYPE_LINK：リンク"
    },
    {
      "indent": 3,
      "text": "The Data type indicates that the Payload of the ContentObject is opaque application bytes. The Key type indicates that the Payload is a DER-encoded public key. The Link type indicates that the Payload is one or more Links (Section 3.3.4). If this field is missing, a Data type is assumed.",
      "ja": "データ型は、ContentObjectのペイロードが不透明なアプリケーションバイトであることを示します。 Keyタイプは、ペイロードがDERエンコードされた公開キーであることを示します。 リンクタイプは、ペイロードが1つ以上のリンクであることを示します（セクション3.3.4）。 このフィールドが欠落している場合、データ型が想定されます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|            T_PAYLDTYPE        |               1               |\n+---------------+---------------+---------------+---------------+\n|  PayloadType  |\n+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 20: PayloadType Encoding",
      "ja": "図20：PayloadTypeエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.2.2.2. ExpiryTime",
      "section_title": true,
      "ja": "3.6.2.2.2. ExpiryTime"
    },
    {
      "indent": 3,
      "text": "The ExpiryTime is the time at which the Payload expires, as expressed by a timestamp containing the number of milliseconds since the epoch in UTC. It is a network byte order unsigned integer in a 64-bit field. A cache or end system should not respond with a Content Object past its ExpiryTime. Routers forwarding a Content Object do not need to check the ExpiryTime. If the ExpiryTime field is missing, the Content Object has no expressed expiration, and a cache or end system may use the Content Object for as long as desired.",
      "ja": "ExpiryTimeはペイロードの有効期限です。UTCのエポック以降のミリ秒数を含むタイムスタンプで表されます。 これは、64ビットフィールドのネットワークバイト順符号なし整数です。 キャッシュまたはエンドシステムは、ExpiryTimeを超えてコンテンツオブジェクトで応答するべきではありません。 コンテンツオブジェクトを転送するルーターは、ExpiryTimeを確認する必要はありません。 ExpiryTimeフィールドが欠落している場合、コンテンツオブジェクトには有効期限が明示されておらず、キャッシュまたはエンドシステムは必要な限りコンテンツオブジェクトを使用できます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|           T_EXPIRY            |               8               |\n+---------------+---------------+---------------+---------------+\n/                          ExpiryTime                           /\n/                                                               /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 21: ExpiryTime encoding",
      "ja": "図21：ExpiryTimeエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.3. Payload",
      "section_title": true,
      "ja": "3.6.3. ペイロード"
    },
    {
      "indent": 3,
      "text": "The Payload TLV contains the content of the packet. It MAY be of zero length. If a packet does not have any payload, this field SHOULD be omitted, rather than being of zero length.",
      "ja": "ペイロードTLVには、パケットのコンテンツが含まれます。 長さがゼロの場合があります。 パケットにペイロードがない場合、このフィールドは長さがゼロではなく、省略される必要があります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|           T_PAYLOAD           |            Length             |\n+---------------+---------------+---------------+---------------+\n/                        Payload Contents                       /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 22: Payload Encoding",
      "ja": "図22：ペイロードエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.4. Validation",
      "section_title": true,
      "ja": "3.6.4. 検証"
    },
    {
      "indent": 3,
      "text": "Both Interests and Content Objects have the option to include information about how to validate the CCNx Message. This information is contained in two TLVs: the ValidationAlgorithm TLV and the ValidationPayload TLV. The ValidationAlgorithm TLV specifies the mechanism to be used to verify the CCNx Message. Examples include verification with a Message Integrity Check (MIC), a Message Authentication Code (MAC), or a cryptographic signature. The ValidationPayload TLV contains the validation output, such as the CRC32C code or the RSA signature.",
      "ja": "インタレストとコンテンツオブジェクトの両方に、CCNxメッセージの検証方法に関する情報を含めるオプションがあります。 この情報は、ValidationAlgorithm TLVとValidationPayload TLVの2つのTLVに含まれています。 ValidationAlgorithm TLVは、CCNxメッセージの検証に使用されるメカニズムを指定します。 例には、メッセージ整合性チェック（MIC）、メッセージ認証コード（MAC）、または暗号署名による検証が含まれます。 ValidationPayload TLVには、CRC32CコードやRSA署名などの検証出力が含まれています。"
    },
    {
      "indent": 3,
      "text": "An Interest would most likely only use a MIC type of validation -- a CRC, checksum, or digest.",
      "ja": "インタレストは、MICタイプの検証（CRC、チェックサム、またはダイジェスト）のみを使用する可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1. Validation Algorithm",
      "section_title": true,
      "ja": "3.6.4.1. 検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The ValidationAlgorithm is a set of nested TLVs containing all of the information needed to verify the message. The outermost container has type = T_VALIDATION_ALG. The first nested TLV defines the specific type of validation to be performed on the message. The type is identified with the \"ValidationType\" as shown in the figure below and elaborated in the table below. Nested within that container are the TLVs for any ValidationType-dependent data -- for example, a Key Id, Key Locator, etc.",
      "ja": "ValidationAlgorithmは、メッセージの検証に必要なすべての情報を含むネストされたTLVのセットです。 一番外側のコンテナのタイプはT_VALIDATION_ALGです。 最初のネストされたTLVは、メッセージで実行される特定のタイプの検証を定義します。 タイプは、下の図に示すように「ValidationType」で識別され、下の表に詳しく説明されています。 そのコンテナ内にネストされているのは、ValidationTypeに依存するデータ（たとえば、キーID、キーロケーターなど）のTLVです。"
    },
    {
      "indent": 3,
      "text": "Complete examples of several types may be found in Section 3.6.4.1.5.",
      "ja": "いくつかのタイプの完全な例は、セクション3.6.4.1.5にあります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|       T_VALIDATION_ALG        |      ValidationAlgLength      |\n+---------------+---------------+---------------+---------------+\n|        ValidationType         |            Length             |\n+---------------+---------------+---------------+---------------+\n/ ValidationType-dependent data                                 /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 23: Validation Algorithm Encoding",
      "ja": "図23：検証アルゴリズムのエンコード"
    },
    {
      "indent": 3,
      "text": "+-----------------+---------------+---------------------------------+\n|      Abbrev     |      Name     | Description                     |\n+-----------------+---------------+---------------------------------+\n|     T_CRC32C    |     CRC32C    | Castagnoli CRC32 (iSCSI, ext4,  |\n|                 |    (Section   | etc.) with normal form          |\n|                 |   3.6.4.1.1)  | polynomial 0x1EDC6F41.          |\n|                 |               |                                 |\n|  T_HMAC-SHA256  |  HMAC-SHA256  | HMAC (RFC 2104) using SHA256    |\n|                 |    (Section   | hash.                           |\n|                 |   3.6.4.1.2)  |                                 |\n|                 |               |                                 |\n|   T_RSA-SHA256  |   RSA-SHA256  | RSA public-key signature using  |\n|                 |    (Section   | SHA256 digest.                  |\n|                 |   3.6.4.1.3)  |                                 |\n|                 |               |                                 |\n| T_EC-SECP-256K1 |   SECP-256K1  | Elliptic Curve signature with   |\n|                 |    (Section   | SECP-256K1 parameters (see      |\n|                 |   3.6.4.1.3)  | [ECC]).                         |\n|                 |               |                                 |\n| T_EC-SECP-384R1 |   SECP-384R1  | Elliptic Curve signature with   |\n|                 |    (Section   | SECP-384R1 parameters (see      |\n|                 |   3.6.4.1.3)  | [ECC]).                         |\n+-----------------+---------------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 10: CCNx Validation Types",
      "ja": "表10：CCNx検証タイプ"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.1. Message Integrity Checks",
      "section_title": true,
      "ja": "3.6.4.1.1. メッセージの整合性チェック"
    },
    {
      "indent": 3,
      "text": "MICs do not require additional data in order to perform the verification. An example is CRC32C that has a zero-length value.",
      "ja": "MICは、検証を実行するために追加のデータを必要としません。 例は、長さがゼロの値を持つCRC32Cです。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.2. Message Authentication Codes",
      "section_title": true,
      "ja": "3.6.4.1.2. メッセージ認証コード"
    },
    {
      "indent": 3,
      "text": "MACs are useful for communication between two trusting parties who have already shared secret keys. An example is the HMAC algorithm. A MAC uses the KeyId field to identify which shared secret is in use. The meaning of the KeyId is specific to the two parties involved and could be simply an integer to enumerate keys. If a new MAC requires an additional field, such as an Initialization Vector, that field would need to be defined as part of the updated specification.",
      "ja": "MACは、すでに秘密鍵を共有している2つの信頼できる当事者間の通信に役立ちます。 例は、HMACアルゴリズムです。 MACは、KeyIdフィールドを使用して、使用されている共有秘密を識別します。 KeyIdの意味は、関係する2つの関係者に固有であり、キーを列挙するための単なる整数にすることができます。 新しいMACが初期化ベクトルなどの追加フィールドを必要とする場合、そのフィールドは更新された仕様の一部として定義される必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.3. Signature",
      "section_title": true,
      "ja": "3.6.4.1.3. 署名"
    },
    {
      "indent": 3,
      "text": "Signature type Validators specify a digest mechanism and a signing algorithm to verify the message. Examples include an RSA signature on a SHA256 digest, an Elliptic Curve signature with SECP-256K1 parameters, etc. These Validators require a KeyId and a mechanism for locating the publisher's public key (a KeyLocator) -- and optionally a PublicKey or Certificate or KeyLink.",
      "ja": "署名タイプバリデーターは、ダイジェストメカニズムと署名アルゴリズムを指定して、メッセージを検証します。 例には、SHA256ダイジェストのRSA署名、SECP-256K1パラメーターを使用した楕円曲線署名などが含まれます。これらのバリデーターには、KeyIdと、発行者の公開キー（KeyLocator）を検索するメカニズムと、オプションでPublicKeyまたはCertificateまたはKeyLinkが必要です 。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4. Validation-Dependent Data",
      "section_title": true,
      "ja": "3.6.4.1.4. 検証依存データ"
    },
    {
      "indent": 3,
      "text": "Different Validation Algorithms require access to different pieces of data contained in the ValidationAlgorithm TLV. As described above, Key Ids, Key Locators, Public Keys, Certificates, Links, and Key Names all play a role in different Validation Algorithms. Any number of Validation-Dependent Data containers can be present in a Validation Algorithm TLV.",
      "ja": "さまざまな検証アルゴリズムでは、ValidationAlgorithm TLVに含まれるさまざまなデータにアクセスする必要があります。 上記のように、キーID、キーロケーター、公開キー、証明書、リンク、およびキー名はすべて、さまざまな検証アルゴリズムで役割を果たします。 検証アルゴリズムTLVには、検証依存データコンテナをいくつでも含めることができます。"
    },
    {
      "indent": 3,
      "text": "Below is a table of CCNx ValidationType-dependent data types:",
      "ja": "以下は、CCNx ValidationTypeに依存するデータ型の表です。"
    },
    {
      "indent": 3,
      "text": "+-------------+-----------------+-----------------------------------+\n|    Abbrev   |       Name      | Description                       |\n+-------------+-----------------+-----------------------------------+\n|   T_KEYID   |   SignerKeyId   | An identifier of the shared       |\n|             |     (Section    | secret or public key associated   |\n|             |   3.6.4.1.4.1)  | with a MAC or Signature.          |\n|             |                 |                                   |\n| T_PUBLICKEY |    Public Key   | DER-encoded public key.           |\n|             |     (Section    |                                   |\n|             |   3.6.4.1.4.2)  |                                   |\n|             |                 |                                   |\n|    T_CERT   |   Certificate   | DER-encoded X.509 certificate.    |\n|             |     (Section    |                                   |\n|             |   3.6.4.1.4.3)  |                                   |\n|             |                 |                                   |\n|  T_KEYLINK  |     KeyLink     | A CCNx Link object.               |\n|             |     (Section    |                                   |\n|             |   3.6.4.1.4.4)  |                                   |\n|             |                 |                                   |\n|  T_SIGTIME  |  SignatureTime  | A millisecond timestamp           |\n|             |     (Section    | indicating the time when the      |\n|             |   3.6.4.1.4.5)  | signature was created.            |\n+-------------+-----------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 11: CCNx Validation-Dependent Data Types",
      "ja": "表11：CCNx検証に依存するデータ型"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4.1. KeyId",
      "section_title": true,
      "ja": "3.6.4.1.4.1. KeyId"
    },
    {
      "indent": 3,
      "text": "The KeyId for a signature is the publisher key identifier. It is similar to a Subject Key Identifier from X.509 (see Section 4.2.1.2 of [RFC5280]). It should be derived from the key used to sign, such as from the SHA-256 hash of the key. It applies to both public and private key systems and to symmetric key systems.",
      "ja": "署名のKeyIdは、発行者のキー識別子です。 X.509のサブジェクトキー識別子に似ています（[RFC5280]のセクション4.2.1.2を参照）。 キーのSHA-256ハッシュなど、署名に使用されるキーから派生する必要があります。 公開鍵システムと秘密鍵システムの両方、および対称鍵システムに適用されます。"
    },
    {
      "indent": 3,
      "text": "The KeyId is represented using the hash format in Section 3.3.3. If an application protocol uses a non-hash identifier, it should use one of the reserved values.",
      "ja": "KeyIdは、セクション3.3.3のハッシュ形式を使用して表されます。 アプリケーションプロトコルが非ハッシュ識別子を使用する場合、予約済みの値の1つを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|            T_KEYID            |            LENGTH+4           |\n+---------------+---------------+---------------+---------------+\n|          <hash type>          |             LENGTH            |\n+---------------+---------------+---------------+---------------+\n/                     LENGTH octets of hash                     /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 24: KeyId Encoding",
      "ja": "図24：KeyIdエンコード"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4.2. Public Key",
      "section_title": true,
      "ja": "3.6.4.1.4.2. 公開鍵"
    },
    {
      "indent": 3,
      "text": "A Public Key is a DER-encoded Subject Public Key Info block, as in an X.509 certificate.",
      "ja": "公開鍵は、X.509証明書のように、DERエンコードされたSubject Public Key Infoブロックです。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|          T_PUBLICKEY          |            Length             |\n+---------------+---------------+---------------+---------------+\n/                Public Key (DER-encoded SPKI)                  /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 25: Public Key Encoding",
      "ja": "図25：公開鍵エンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4.3. Certificate",
      "section_title": true,
      "ja": "3.6.4.1.4.3. 証明書"
    },
    {
      "indent": 3,
      "text": "A Certificate is a DER-encoded X.509 certificate. The KeyId (Section 3.6.4.1.4.1) is derived from this encoding.",
      "ja": "証明書は、DERエンコードされたX.509証明書です。 KeyId（3.6.4.1.4.1項）は、このエンコーディングから導出されます。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|            T_CERT             |            Length             |\n+---------------+---------------+---------------+---------------+\n/                 Certificate (DER-encoded X.509)               /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 26: Certificate Encoding",
      "ja": "図26：証明書のエンコード"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4.4. KeyLink",
      "section_title": true,
      "ja": "3.6.4.1.4.4. KeyLink"
    },
    {
      "indent": 3,
      "text": "A KeyLink type KeyLocator is a Link.",
      "ja": "KeyLinkタイプのKeyLocatorはリンクです。"
    },
    {
      "indent": 3,
      "text": "The KeyLink ContentObjectHashRestr, if included, is the digest of the Content Object identified by KeyLink, not the digest of the public key. Likewise, the KeyIdRestr of the KeyLink is the KeyId of the ContentObject, not necessarily of the wrapped key.",
      "ja": "KeyLink ContentObjectHashRestrが含まれる場合、KeyLinkによって識別されるコンテンツオブジェクトのダイジェストであり、公開キーのダイジェストではありません。 同様に、KeyLinkのKeyIdRestrはContentObjectのKeyIdであり、必ずしもラップされたキーのものではありません。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------------------------------+\n|          T_KEYLINK            |            Length             |\n+---------------+---------------+-------------------------------+\n/ Link                                                          /\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 27: KeyLink Encoding",
      "ja": "図27：KeyLinkエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.4.5. SignatureTime",
      "section_title": true,
      "ja": "3.6.4.1.4.5. SignatureTime"
    },
    {
      "indent": 3,
      "text": "The SignatureTime is a millisecond timestamp indicating the time at which a signature was created. The signer sets this field to the current time when creating a signature. A verifier may use this time to determine whether or not the signature was created during the validity period of a key, or if it occurred in a reasonable sequence with other associated signatures. The SignatureTime is unrelated to any time associated with the actual CCNx Message, which could have been created long before the signature. The default behavior is to always include a SignatureTime when creating an authenticated message (e.g., HMAC or RSA).",
      "ja": "SignatureTimeは、署名が作成された時刻を示すミリ秒のタイムスタンプです。 署名者は、署名の作成時にこのフィールドを現在の時刻に設定します。 検証者はこの時間を使用して、キーの有効期間中に署名が作成されたかどうか、または他の関連する署名と合理的な順序で署名が作成されたかどうかを判断できます。 SignatureTimeは、署名のずっと前に作成された実際のCCNxメッセージに関連付けられた時間とは無関係です。 デフォルトの動作では、認証されたメッセージ（HMACやRSAなど）を作成するときに常にSignatureTimeが含まれます。"
    },
    {
      "indent": 3,
      "text": "SignatureTime is an unsigned integer in network byte order that indicates when the signature was created (as the number of milliseconds since the epoch in UTC). It is a fixed 64-bit field.",
      "ja": "SignatureTimeは、署名がいつ作成されたかを示すネットワークバイト順の符号なし整数です（UTCのエポックからのミリ秒数として）。 これは、固定の64ビットフィールドです。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------------------------------+\n|           T_SIGTIME           |               8               |\n+---------------+---------------+-------------------------------+\n/                         SignatureTime                         /\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 28: SignatureTime Encoding",
      "ja": "図28：SignatureTimeエンコーディング"
    },
    {
      "indent": 0,
      "text": "3.6.4.1.5. Validation Examples",
      "section_title": true,
      "ja": "3.6.4.1.5. 検証例"
    },
    {
      "indent": 3,
      "text": "As an example of a MIC-type validation, the encoding for CRC32C validation would be:",
      "ja": "MICタイプの検証の例として、CRC32C検証のエンコードは次のようになります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|      T_VALIDATION_ALG         |               4               |\n+---------------+---------------+---------------+---------------+\n|            T_CRC32C           |               0               |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 29: CRC32C Encoding Example",
      "ja": "図29：CRC32Cエンコードの例"
    },
    {
      "indent": 3,
      "text": "As an example of a MAC-type validation, the encoding for an HMAC using a SHA256 hash would be:",
      "ja": "MACタイプの検証の例として、SHA256ハッシュを使用したHMACのエンコードは次のようになります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|       T_VALIDATION_ALG        |               40              |\n+---------------+---------------+---------------+---------------+\n|        T_HMAC-SHA256          |               36              |\n+---------------+---------------+---------------+---------------+\n|             T_KEYID           |               32              |\n+---------------+---------------+---------------+---------------+\n/                            KeyId                              /\n/---------------+---------------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 30: HMAC-SHA256 Encoding Example",
      "ja": "図30：HMAC-SHA256エンコードの例"
    },
    {
      "indent": 3,
      "text": "As an example of a Signature-type validation, the encoding for an RSA public-key signature using a SHA256 digest and Public Key would be:",
      "ja": "署名タイプの検証の例として、SHA256ダイジェストと公開鍵を使用したRSA公開鍵署名のエンコードは次のようになります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|       T_VALIDATION_ALG        |   44 octets + Variable Length |\n+---------------+---------------+---------------+---------------+\n|          T_RSA-SHA256         |   40 octets + Variable Length |\n+---------------+---------------+---------------+---------------+\n|             T_KEYID           |               32              |\n+---------------+---------------+---------------+---------------+\n/                            KeyId                              /\n/---------------+---------------+-------------------------------+\n|          T_PUBLICKEY          |  Variable Length (~160 octets)|\n+---------------+---------------+---------------+---------------+\n/                Public Key (DER-encoded SPKI)                  /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 31: RSA-SHA256 Encoding Example",
      "ja": "図31：RSA-SHA256エンコードの例"
    },
    {
      "indent": 0,
      "text": "3.6.4.2. Validation Payload",
      "section_title": true,
      "ja": "3.6.4.2. 検証ペイロード"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|     T_VALIDATION_PAYLOAD      |  ValidationPayloadLength      |\n+---------------+---------------+---------------+---------------+\n/ Type-dependent data                                           /\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 32: Validation Payload Encoding",
      "ja": "図32：検証ペイロードのエンコード"
    },
    {
      "indent": 3,
      "text": "The ValidationPayload contains the validation output, such as the CRC32C code or the RSA signature.",
      "ja": "ValidationPayloadには、CRC32CコードやRSA署名などの検証出力が含まれています。"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section details each kind of CCNx protocol value that can be registered. Each type registry can be updated by incrementally expanding the type space, i.e., by allocating and reserving new types. As per [RFC8126], this section details the creation of the \"Content-Centric Networking (CCNx)\" registry and several subregistries.",
      "ja": "このセクションでは、登録可能なCCNxプロトコル値の種類について詳しく説明します。 各タイプレジストリは、タイプスペースを段階的に拡張することによって、つまり新しいタイプを割り当てて予約することによって更新できます。 [RFC8126]に従って、このセクションでは、「コンテンツ中心ネットワーキング（CCNx）」レジストリおよびいくつかのサブレジストリの作成について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Packet Type Registry",
      "section_title": true,
      "ja": "4.1. パケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Packet Types\" registry and allocated the packet types described below. The registration procedure is RFC Required. The Type value is 1 octet. The range is 0x00-0xFF.",
      "ja": "IANAは「CCNxパケットタイプ」レジストリを作成し、以下で説明するパケットタイプを割り当てました。 登録手順はRFC必須です。 Type値は1オクテットです。 範囲は0x00-0xFFです。"
    },
    {
      "indent": 9,
      "text": "+------+-------------+----------------------------------+\n| Type |     Name    |            Reference             |\n+------+-------------+----------------------------------+\n| 0x00 | PT_INTEREST | Fixed Header Types (Section 3.2) |\n|      |             |                                  |\n| 0x01 |  PT_CONTENT | Fixed Header Types (Section 3.2) |\n|      |             |                                  |\n| 0x02 |  PT_RETURN  | Fixed Header Types (Section 3.2) |\n+------+-------------+----------------------------------+",
      "raw": true
    },
    {
      "indent": 31,
      "text": "Packet Types",
      "ja": "パケットタイプ"
    },
    {
      "indent": 0,
      "text": "4.2. Interest Return Code Registry",
      "section_title": true,
      "ja": "4.2. 利息リターンコードレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Interest Return Code Types\" registry and allocated the Interest Return code types described below. The registration procedure is Specification Required. The Type value is 1 octet. The range is 0x00-0xFF.",
      "ja": "IANAは「CCNx Interest Return Code Types」レジストリを作成し、以下に説明するInterest Returnコードタイプを割り当てました。 登録手順は仕様が必要です。 Type値は1オクテットです。 範囲は0x00-0xFFです。"
    },
    {
      "indent": 3,
      "text": "+------+---------------------------------------+--------------------+\n| Type |                  Name                 |     Reference      |\n+------+---------------------------------------+--------------------+\n| 0x00 |                Reserved               |                    |\n|      |                                       |                    |\n| 0x01 |           T_RETURN_NO_ROUTE           | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x02 |        T_RETURN_LIMIT_EXCEEDED        | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x03 |         T_RETURN_NO_RESOURCES         | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x04 |          T_RETURN_PATH_ERROR          | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x05 |          T_RETURN_PROHIBITED          | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x06 |           T_RETURN_CONGESTED          | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x07 |         T_RETURN_MTU_TOO_LARGE        | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x08 | T_RETURN_UNSUPPORTED_HASH_RESTRICTION | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n|      |                                       |                    |\n| 0x09 |      T_RETURN_MALFORMED_INTEREST      | Fixed Header Types |\n|      |                                       | (Section 3.2.3.3)  |\n+------+---------------------------------------+--------------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "CCNx Interest Return Types",
      "ja": "CCNx利息返還タイプ"
    },
    {
      "indent": 0,
      "text": "4.3. Hop-by-Hop Type Registry",
      "section_title": true,
      "ja": "4.3. ホップバイホップ型レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Hop-by-Hop Types\" registry and allocated the hop-by-hop types described below. The registration procedure is RFC Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNxホップバイホップタイプ」レジストリを作成し、以下で説明するホップごとのタイプを割り当てました。 登録手順はRFC必須です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+---------------+-------------+-------------------------------------+\n|      Type     |     Name    |              Reference              |\n+---------------+-------------+-------------------------------------+\n|     0x0000    |   Reserved  |                                     |\n|               |             |                                     |\n|     0x0001    |  T_INTLIFE  |   Hop-by-hop TLV headers (Section   |\n|               |             |                 3.4)                |\n|               |             |                                     |\n|     0x0002    | T_CACHETIME |   Hop-by-hop TLV headers (Section   |\n|               |             |                 3.4)                |\n|               |             |                                     |\n|     0x0003    |  T_MSGHASH  |   Hop-by-hop TLV headers (Section   |\n|               |             |                 3.4)                |\n|               |             |                                     |\n|    0x0004 -   |   Reserved  |                                     |\n|     0x0007    |             |                                     |\n|               |             |                                     |\n|     0x0FFE    |    T_PAD    |         Pad (Section 3.3.1)         |\n|               |             |                                     |\n|     0x0FFF    |    T_ORG    | Organization-Specific TLVs (Section |\n|               |             |                3.3.2)               |\n|               |             |                                     |\n| 0x1000-0x1FFF |   Reserved  |     Experimental Use (Section 3)    |\n+---------------+-------------+-------------------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "CCNx Hop-by-Hop Types",
      "ja": "CCNxホップバイホップタイプ"
    },
    {
      "indent": 0,
      "text": "4.4. Top-Level Type Registry",
      "section_title": true,
      "ja": "4.4. トップレベルのタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Top-Level Types\" registry and allocated the top-level types described below. The registration procedure is RFC Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNxトップレベルタイプ」レジストリを作成し、以下で説明するトップレベルタイプを割り当てました。 登録手順はRFC必須です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 5,
      "text": "+--------+----------------------+-------------------------------+\n|  Type  |         Name         |           Reference           |\n+--------+----------------------+-------------------------------+\n| 0x0000 |       Reserved       |                               |\n|        |                      |                               |\n| 0x0001 |      T_INTEREST      | Top-Level Types (Section 3.5) |\n|        |                      |                               |\n| 0x0002 |       T_OBJECT       | Top-Level Types (Section 3.5) |\n|        |                      |                               |\n| 0x0003 |   T_VALIDATION_ALG   | Top-Level Types (Section 3.5) |\n|        |                      |                               |\n| 0x0004 | T_VALIDATION_PAYLOAD | Top-Level Types (Section 3.5) |\n+--------+----------------------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "CCNx Top-Level Types",
      "ja": "CCNxトップレベルタイプ"
    },
    {
      "indent": 0,
      "text": "4.5. Name Segment Type Registry",
      "section_title": true,
      "ja": "4.5. 名前セグメントタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Name Segment Types\" registry and allocated the name segment types described below. The registration procedure is Specification Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNx名前セグメントタイプ」レジストリを作成し、以下に説明する名前セグメントタイプを割り当てました。 登録手順は仕様が必要です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+--------------+------------------+---------------------------------+\n|     Type     |       Name       |            Reference            |\n+--------------+------------------+---------------------------------+\n|    0x0000    |     Reserved     |                                 |\n|              |                  |                                 |\n|    0x0001    |  T_NAMESEGMENT   |       Name (Section 3.6.1)      |\n|              |                  |                                 |\n|    0x0002    |      T_IPID      |       Name (Section 3.6.1)      |\n|              |                  |                                 |\n|   0x0010 -   |     Reserved     |             RFC 8609            |\n|    0x0013    |                  |                                 |\n|              |                  |                                 |\n|    0x0FFF    |      T_ORG       |    Organization-Specific TLVs   |\n|              |                  |         (Section 3.3.2)         |\n|              |                  |                                 |\n|   0x1000 -   |    T_APP:00 -    | Application Components (Section |\n|    0x1FFF    |    T_APP:4096    |              3.6.1)             |\n+--------------+------------------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "CCNx Name Segment Types",
      "ja": "CCNx名前セグメントタイプ"
    },
    {
      "indent": 0,
      "text": "4.6. Message Type Registry",
      "section_title": true,
      "ja": "4.6. メッセージタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Message Types\" registry and registered the message segment types described below. The registration procedure is RFC Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNxメッセージタイプ」レジストリを作成し、以下で説明するメッセージセグメントタイプを登録しました。 登録手順はRFC必須です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+---------------+----------------+----------------------------------+\n|      Type     |      Name      |            Reference             |\n+---------------+----------------+----------------------------------+\n|     0x0000    |     T_NAME     |   Message Types (Section 3.6)    |\n|               |                |                                  |\n|     0x0001    |   T_PAYLOAD    |   Message Types (Section 3.6)    |\n|               |                |                                  |\n|     0x0002    |  T_KEYIDRESTR  |   Message Types (Section 3.6)    |\n|               |                |                                  |\n|     0x0003    | T_OBJHASHRESTR |   Message Types (Section 3.6)    |\n|               |                |                                  |\n|     0x0005    |  T_PAYLDTYPE   |   Content Object Message Types   |\n|               |                |        (Section 3.6.2.2)         |\n|               |                |                                  |\n|     0x0006    |    T_EXPIRY    |   Content Object Message Types   |\n|               |                |        (Section 3.6.2.2)         |\n|               |                |                                  |\n|    0x0007 -   |    Reserved    |             RFC 8609             |\n|     0x000C    |                |                                  |\n|               |                |                                  |\n|     0x0FFE    |     T_PAD      |       Pad (Section 3.3.1)        |\n|               |                |                                  |\n|     0x0FFF    |     T_ORG      |    Organization-Specific TLVs    |\n|               |                |         (Section 3.3.2)          |\n|               |                |                                  |\n| 0x1000-0x1FFF |    Reserved    |   Experimental Use (Section 3)   |\n+---------------+----------------+----------------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "CCNx Message Types",
      "ja": "CCNxメッセージタイプ"
    },
    {
      "indent": 0,
      "text": "4.7. Payload Type Registry",
      "section_title": true,
      "ja": "4.7. ペイロードタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Payload Types\" registry and allocated the payload types described below. The registration procedure is Specification Required. The Type value is 1 octet. The range is 0x00-0xFF.",
      "ja": "IANAは「CCNxペイロードタイプ」レジストリを作成し、以下に説明するペイロードタイプを割り当てました。 登録手順は仕様が必要です。 Type値は1オクテットです。 範囲は0x00-0xFFです。"
    },
    {
      "indent": 5,
      "text": "+------+--------------------+-----------------------------------+\n| Type |        Name        |             Reference             |\n+------+--------------------+-----------------------------------+\n| 0x00 | T_PAYLOADTYPE_DATA | Payload Types (Section 3.6.2.2.1) |\n|      |                    |                                   |\n| 0x01 | T_PAYLOADTYPE_KEY  | Payload Types (Section 3.6.2.2.1) |\n|      |                    |                                   |\n| 0x02 | T_PAYLOADTYPE_LINK | Payload Types (Section 3.6.2.2.1) |\n+------+--------------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "CCNx Payload Types",
      "ja": "CCNxペイロードタイプ"
    },
    {
      "indent": 0,
      "text": "4.8. Validation Algorithm Type Registry",
      "section_title": true,
      "ja": "4.8. 検証アルゴリズムタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Validation Algorithm Types\" registry and allocated the validation algorithm types described below. The registration procedure is Specification Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNx Validation Algorithm Types」レジストリを作成し、以下で説明する検証アルゴリズムタイプを割り当てました。 登録手順は仕様が必要です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+---------------+-----------------+---------------------------------+\n|      Type     |       Name      |            Reference            |\n+---------------+-----------------+---------------------------------+\n|     0x0000    |     Reserved    |                                 |\n|               |                 |                                 |\n|     0x0002    |     T_CRC32C    |  Validation Algorithm (Section  |\n|               |                 |             3.6.4.1)            |\n|               |                 |                                 |\n|     0x0004    |  T_HMAC-SHA256  |  Validation Algorithm (Section  |\n|               |                 |             3.6.4.1)            |\n|               |                 |                                 |\n|     0x0005    |   T_RSA-SHA256  |  Validation Algorithm (Section  |\n|               |                 |             3.6.4.1)            |\n|               |                 |                                 |\n|     0x0006    | T_EC-SECP-256K1 |  Validation Algorithm (Section  |\n|               |                 |             3.6.4.1)            |\n|               |                 |                                 |\n|     0x0007    | T_EC-SECP-384R1 |  Validation Algorithm (Section  |\n|               |                 |             3.6.4.1)            |\n|               |                 |                                 |\n|     0x0FFE    |      T_PAD      |       Pad (Section 3.3.1)       |\n|               |                 |                                 |\n|     0x0FFF    |      T_ORG      |    Organization-Specific TLVs   |\n|               |                 |         (Section 3.3.2)         |\n|               |                 |                                 |\n| 0x1000-0x1FFF |     Reserved    |   Experimental Use (Section 3)  |\n+---------------+-----------------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "CCNx Validation Algorithm Types",
      "ja": "CCNx検証アルゴリズムタイプ"
    },
    {
      "indent": 0,
      "text": "4.9. Validation-Dependent Data Type Registry",
      "section_title": true,
      "ja": "4.9. 検証依存のデータ型レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Validation-Dependent Data Types\" registry and allocated the validation-dependent data types described below. The registration procedure is RFC Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNx Validation-Dependent Data Types」レジストリを作成し、以下で説明する検証依存のデータ型を割り当てました。 登録手順はRFC必須です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+---------------+----------------+----------------------------------+\n|      Type     |      Name      |            Reference             |\n+---------------+----------------+----------------------------------+\n|     0x0000    |    Reserved    |                                  |\n|               |                |                                  |\n|     0x0009    |    T_KEYID     |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000A    | T_PUBLICKEYLOC |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000B    |  T_PUBLICKEY   |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000C    |     T_CERT     |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000D    |     T_LINK     |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000E    |   T_KEYLINK    |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x000F    |   T_SIGTIME    |    Validation-Dependent Data     |\n|               |                |       (Section 3.6.4.1.4)        |\n|               |                |                                  |\n|     0x0FFF    |     T_ORG      |    Organization-Specific TLVs    |\n|               |                |         (Section 3.3.2)          |\n|               |                |                                  |\n| 0x1000-0x1FFF |    Reserved    |   Experimental Use (Section 3)   |\n+---------------+----------------+----------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "CCNx Validation-Dependent Data Types",
      "ja": "CCNx検証依存のデータ型"
    },
    {
      "indent": 0,
      "text": "4.10. Hash Function Type Registry",
      "section_title": true,
      "ja": "4.10. ハッシュ関数型レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"CCNx Hash Function Types\" registry and allocated the hash function types described below. The registration procedure is Specification Required. The Type value is 2 octets. The range is 0x0000-0xFFFF.",
      "ja": "IANAは「CCNxハッシュ関数タイプ」レジストリを作成し、以下に説明するハッシュ関数タイプを割り当てました。 登録手順は仕様が必要です。 Type値は2オクテットです。 範囲は0x0000-0xFFFFです。"
    },
    {
      "indent": 3,
      "text": "+---------------+-----------+---------------------------------------+\n|      Type     |    Name   |               Reference               |\n+---------------+-----------+---------------------------------------+\n|     0x0000    |  Reserved |                                       |\n|               |           |                                       |\n|     0x0001    | T_SHA-256 |      Hash Format (Section 3.3.3)      |\n|               |           |                                       |\n|     0x0002    | T_SHA-512 |      Hash Format (Section 3.3.3)      |\n|               |           |                                       |\n|     0x0FFF    |   T_ORG   |  Organization-Specific TLVs (Section  |\n|               |           |                 3.3.2)                |\n|               |           |                                       |\n| 0x1000-0x1FFF |  Reserved |      Experimental Use (Section 3)     |\n+---------------+-----------+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "CCNx Hash Function Types",
      "ja": "CCNxハッシュ関数タイプ"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The CCNx protocol is a Layer 3 network protocol, which may also operate as an overlay using other transports such as UDP or other tunnels. It includes intrinsic support for message authentication via a signature (e.g., RSA or elliptic curve) or Message Authentication Code (e.g., HMAC). In lieu of an authenticator, it may instead use a Message Integrity Check (e.g., SHA or CRC). CCNx does not specify an encryption envelope; that function is left to a high-layer protocol (e.g., Encrypted Sessions in CCNx [esic]).",
      "ja": "CCNxプロトコルは、レイヤー3ネットワークプロトコルであり、UDPや他のトンネルなどの他のトランスポートを使用するオーバーレイとしても動作します。 署名（RSAや楕円曲線など）またはメッセージ認証コード（HMACなど）を介したメッセージ認証の本質的なサポートが含まれています。 オーセンティケーターの代わりに、代わりにメッセージ整合性チェック（SHAやCRCなど）を使用する場合があります。 CCNxは暗号化エンベロープを指定しません。 その機能は上位層プロトコルに委ねられます（例：CCNxの暗号化セッション[esic]）。"
    },
    {
      "indent": 3,
      "text": "The CCNx Packet format includes the ability to attach MICs (e.g., SHA-256 or CRC), MACs (e.g., HMAC), and Signatures (e.g., RSA or ECDSA) to all packet types. Because Interest packets can be sent at will, an application should carefully select when to use a given ValidationAlgorithm in an Interest to avoid DoS attacks. MICs, for example, are inexpensive and could be used as desired, whereas MACs and Signatures are more expensive and their inappropriate use could open a computational DoS attack surface. Applications should use an explicit protocol to guide their use of packet signatures. As a general guideline, an application might use a MIC on an Interest to detect unintentionally corrupted packets. If one wishes to secure an Interest, one should consider using an encrypted wrapper and a protocol that prevents replay attacks, especially if the Interest is being used as an actuator. Simply using an authentication code or signature does not make an Interest secure. There are several examples in the literature on how to secure ICN-style messaging [mobile] [ace].",
      "ja": "CCNxパケット形式には、MIC（SHA-256やCRCなど）、MAC（HMACなど）、および署名（RSAやECDSAなど）をすべてのパケットタイプに付加する機能が含まれています。 Interestパケットは自由に送信できるため、DoS攻撃を回避するために、アプリケーションは特定のValidationAlgorithmをInterestで使用するタイミングを慎重に選択する必要があります。たとえば、MICは安価であり、必要に応じて使用できますが、MACと署名はより高価であり、不適切に使用すると計算上のDoS攻撃を受ける可能性があります。アプリケーションは、明示的なプロトコルを使用して、パケット署名の使用をガイドする必要があります。一般的なガイドラインとして、アプリケーションは、意図しない破損パケットを検出するために、インタレストでMICを使用する場合があります。インタレストを保護したい場合、特にインタレストがアクチュエータとして使用されている場合、リプレイ攻撃を防ぐ暗号化されたラッパーとプロトコルの使用を検討する必要があります。単に認証コードまたは署名を使用するだけでは、インタレストは安全になりません。文献には、ICNスタイルのメッセージング[モバイル] [エース]を保護する方法に関するいくつかの例があります。"
    },
    {
      "indent": 3,
      "text": "As a Layer 3 protocol, this document does not describe how one arrives at keys or how one trusts keys. The CCNx content object may include a public key embedded in the object or may use the PublicKeyLocator field to point to a public key (or public-key certificate) that authenticates the message. One key exchange specification is CCNxKE [ccnxke] [mobile], which is similar to the TLS 1.3 key exchange except it is over the CCNx Layer 3 messages. Trust is beyond the scope of a Layer 3 protocol and is left to applications or application frameworks.",
      "ja": "レイヤー3プロトコルとして、このドキュメントでは、キーに到達する方法やキーを信頼する方法については説明しません。 CCNxコンテンツオブジェクトには、オブジェクトに埋め込まれた公開キーを含めるか、PublicKeyLocatorフィールドを使用して、メッセージを認証する公開キー（または公開キー証明書）を指定できます。 1つの鍵交換仕様はCCNxKE [ccnxke] [モバイル]です。これは、CCNxレイヤー3メッセージを介することを除き、TLS 1.3鍵交換に似ています。 信頼は、レイヤ3プロトコルの範囲を超えており、アプリケーションまたはアプリケーションフレームワークに委ねられています。"
    },
    {
      "indent": 3,
      "text": "The combination of an ephemeral key exchange (e.g., CCNxKE [ccnxke]) and an encapsulating encryption (e.g., [esic]) provides the equivalent of a TLS tunnel. Intermediate nodes may forward the Interests and Content Objects but have no visibility inside. It also completely hides the internal names in those used by the encryption layer. This type of tunneling encryption is useful for content that has little or no cacheability, as it can only be used by someone with the ephemeral key. Short-term caching may help with lossy links or mobility, but long-term caching is usually not of interest.",
      "ja": "一時キー交換（CCNxKE [ccnxke]など）とカプセル化暗号化（[esic]など）の組み合わせにより、TLSトンネルと同等の機能が提供されます。 中間ノードは、インタレストとコンテンツオブジェクトを転送できますが、内部に可視性はありません。 また、暗号化層で使用される内部名を完全に隠します。 このタイプのトンネリング暗号化は、一時キーを持つユーザーのみが使用できるため、キャッシュ可能性がほとんどまたはまったくないコンテンツに役立ちます。 短期キャッシングは、損失の多いリンクまたはモビリティに役立ちますが、通常、長期キャッシングは重要ではありません。"
    },
    {
      "indent": 3,
      "text": "Broadcast encryption or proxy re-encryption may be useful for content with multiple uses over time or many consumers. There is currently no recommendation for this form of encryption.",
      "ja": "ブロードキャスト暗号化またはプロキシの再暗号化は、時間の経過とともに複数の用途があるコンテンツや多くの消費者に役立つ場合があります。 現在、この形式の暗号化に関する推奨事項はありません。"
    },
    {
      "indent": 3,
      "text": "The specific encoding of messages will have security implications. This document uses a Type-Length-Value (TLV) encoding. We chose to compromise between extensibility and unambiguous encodings of types and lengths. Some TLV encodings use variable-length T and variable-length L fields to accommodate a wide gamut of values while trying to be byte efficient. Our TLV encoding uses a fixed length 2-byte T and 2-byte L. Using fixed-length T and L fields solves two problems. The first is aliases. If one is able to encode the same value, such as 0x02 and 0x0002, in different byte lengths, then one must decide if they mean the same thing, if they are different, or if one is illegal. If they are different, then one must always compare on the buffers not the integer equivalents. If one is illegal, then one must validate the TLV encoding -- every field of every packet at every hop. If they are the same, then one has the second problem: how to specify packet filters. For example, if a name has 6 name components, then there are 7 T fields and 7 L fields, each of which might have up to 4 representations of the same value. That would be 14 fields with 4 encodings each, or 1001 combinations. It also means that one cannot compare, for example, a name via a memory function, as one needs to consider that any embedded T or L might have a different format.",
      "ja": "メッセージの特定のエンコードは、セキュリティに影響します。このドキュメントでは、Type-Length-Value（TLV）エンコーディングを使用しています。拡張性と、タイプと長さの明確なエンコーディングの間で妥協することを選択しました。一部のTLVエンコードでは、可変長Tフィールドと可変長Lフィールドを使用して、バイトの効率化を図りながら値の広い範囲に対応します。 TLVエンコードは、固定長の2バイトTと2バイトLを使用します。固定長のTフィールドとLフィールドを使用すると、2つの問題が解決します。最初はエイリアスです。異なるバイト長で0x02や0x0002などの同じ値をエンコードできる場合、それらが同じものを意味するか、異なるか、または違法であるかを判断する必要があります。それらが異なる場合、整数の等価物ではなく、常にバッファで比較する必要があります。 1つが違法である場合、TLVエンコーディング（すべてのホップのすべてのパケットのすべてのフィールド）を検証する必要があります。それらが同じ場合、2番目の問題があります。パケットフィルタを指定する方法です。たとえば、名前に6つの名前コンポーネントがある場合、7つのTフィールドと7つのLフィールドがあり、それぞれに同じ値の最大4つの表現がある場合があります。それは、それぞれ4つのエンコード、または1001の組み合わせを持つ14のフィールドになります。また、埋め込まれたTまたはLの形式が異なる可能性があることを考慮する必要があるため、たとえば、メモリ関数を介して名前を比較できないことも意味します。"
    },
    {
      "indent": 3,
      "text": "The Interest Return message has no authenticator from the previous hop. Therefore, the payload of the Interest Return should only be used locally to match an Interest. A node should never forward that Interest payload as an Interest. It should also verify that it sent the Interest in the Interest Return to that node and not allow anyone to negate Interest messages.",
      "ja": "Interest Returnメッセージには、前のホップからの認証子がありません。 したがって、インタレストリターンのペイロードは、インタレストと一致するためにローカルでのみ使用する必要があります。 ノードは、そのInterestペイロードをInterestとして転送してはなりません。 また、インタレストリターンのインタレストをそのノードに送信し、誰もインタレストメッセージを否定できないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Caching nodes must take caution when processing content objects. It is essential that the Content Store obey the rules outlined in [RFC8569] to avoid certain types of attacks. CCNx 1.0 has no mechanism to work around an undesired result from the network (there are no \"excludes\"), so if a cache becomes poisoned with bad content it might cause problems retrieving content. There are three types of access to content from a Content Store: unrestricted, signature restricted, and hash restricted. If an Interest has no restrictions, then the requester is not particular about what they get back, so any matching cached object is OK. In the hash restricted case, the requester is very specific about what they want, and the Content Store (and every forward hop) can easily verify that the content matches the request. In the signature restricted case (which is often used for initial manifest discovery), the requester only knows the KeyId that signed the content. This case requires the closest attention in the Content Store to avoid amplifying bad data. The Content Store must only respond with a content object if it can verify the signature -- this means either the content object carries the public key inside it or the Interest carries the public key in addition to the KeyId. If that is not the case, then the Content Store should treat the Interest as a cache miss and let an endpoint respond.",
      "ja": "キャッシュオブジェクトは、コンテンツオブジェクトの処理時に注意する必要があります。特定の種類の攻撃を回避するには、Content Storeが[RFC8569]で概説されているルールに従うことが不可欠です。 CCNx 1.0には、ネットワークからの望ましくない結果（「除外」はありません）を回避するメカニズムがないため、キャッシュが不適切なコンテンツでポイズニングされると、コンテンツの取得で問題が発生する可能性があります。 Content Storeからのコンテンツへのアクセスには、無制限、署名制限、ハッシュ制限の3つのタイプがあります。インタレストに制限がない場合、リクエスタは返されるものに特に関心がないため、一致するキャッシュオブジェクトは問題ありません。ハッシュ制限の場合、リクエスターは必要なものについて非常に具体的であり、Content Store（およびすべてのフォワードホップ）は、コンテンツがリクエストに一致することを簡単に確認できます。署名が制限されている場合（初期マニフェストの検出によく使用されます）、要求者はコンテンツに署名したKeyIdのみを知っています。この場合、不正なデータの増幅を回避するために、Content Storeでの細心の注意が必要です。 Content Storeは、署名を検証できる場合にのみコンテンツオブジェクトで応答する必要があります。これは、コンテンツオブジェクトが内部に公開キーを保持するか、またはInterestがKeyIdに加えて公開キーを保持することを意味します。そうでない場合、Content StoreはInterestをキャッシュミスとして扱い、エンドポイントに応答させる必要があります。"
    },
    {
      "indent": 3,
      "text": "A user-level cache could perform full signature verification by fetching a public key according to the PublicKeyLocator. However, that is not a burden we wish to impose on the forwarder. A user-level cache could also rely on out-of-band attestation, such as the cache operator only inserting content that it knows has the correct signature.",
      "ja": "ユーザーレベルのキャッシュは、PublicKeyLocatorに従って公開鍵を取得することにより、完全な署名検証を実行できます。 ただし、それはフォワーダーに課したい負担ではありません。 また、ユーザーレベルのキャッシュは、キャッシュオペレーターが正しい署名を持っていることがわかっているコンテンツのみを挿入するなど、帯域外認証にも依存する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The CCNx grammar allows for hash algorithm agility via the HashType. It specifies a short list of acceptable hash algorithms that should be implemented at each forwarder. Some hash values only apply to end systems, so updating the hash algorithm does not affect forwarders -- they would simply match the buffer that includes the type-length-hash buffer. Some fields, such as the ConObjHash, must be verified at each hop, so a forwarder (or related system) must know the hash algorithm, and it could cause backward compatibility problems if the hash type is updated.",
      "ja": "CCNx文法は、HashTypeを介してハッシュアルゴリズムの俊敏性を可能にします。 各フォワーダで実装する必要がある受け入れ可能なハッシュアルゴリズムの短いリストを指定します。 一部のハッシュ値はエンドシステムにのみ適用されるため、ハッシュアルゴリズムを更新してもフォワーダーに影響はありません。type-length-hashバッファーを含むバッファーと単純に一致します。 ConObjHashなどの一部のフィールドは各ホップで検証する必要があるため、フォワーダー（または関連システム）はハッシュアルゴリズムを認識している必要があり、ハッシュタイプが更新されると下位互換性の問題が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A CCNx name uses binary matching, whereas a URI uses a case-insensitive hostname. Some systems may also use case-insensitive matching of the URI path to a resource. An implication of this is that human-entered CCNx names will likely have case or non-ASCII symbol mismatches unless one uses a consistent URI normalization for the CCNx name. It also means that an entity that registers a CCNx-routable prefix -- say, \"ccnx:/example.com\" -- would need separate registrations for simple variations like \"ccnx:/Example.com\". Unless this is addressed in URI normalization and routing protocol conventions, there could be phishing attacks.",
      "ja": "CCNx名はバイナリマッチングを使用しますが、URIは大文字と小文字を区別しないホスト名を使用します。 一部のシステムでは、リソースへのURIパスの大文字と小文字を区別しないマッチングも使用できます。 これが意味することは、CCNx名に一貫したURI正規化を使用しない限り、人間が入力したCCNx名は大文字小文字または非ASCIIシンボルの不一致を持っている可能性が高いことです。 また、CCNxルーティング可能なプレフィックスを登録するエンティティ（たとえば、「ccnx：/example.com」）は、「ccnx：/Example.com」などの単純なバリエーションに対して個別の登録が必要であることを意味します。 これがURI正規化およびルーティングプロトコルの規則で対処されていない限り、フィッシング攻撃が行われる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For a more general introduction to ICN-related security concerns and approaches, see [RFC7927] and [RFC7945].",
      "ja": "ICN関連のセキュリティの懸念とアプローチのより一般的な概要については、[RFC7927]および[RFC7945]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参照資料"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードでの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考資料"
    },
    {
      "indent": 3,
      "text": "[ace] Shang, W., Yu, Y., Liang, T., Zhang, B., and L. Zhang, \"NDN-ACE: Access control for constrained environments over named data networking\", NDN Technical Report NDN-0036, 2015, <http://new.named-data.net/wp-content/uploads/2015/ 12/ndn-0036-1-ndn-ace.pdf>.",
      "ja": "[ace] Shang、W.、Yu、Y.、Liang、T.、Zhang、B.、およびL. Zhang、「NDN-ACE：名前付きデータネットワーキング上の制約された環境のアクセス制御」、NDNテクニカルレポートNDN-0036 、2015、<http://new.named-data.net/wp-content/uploads/2015/ 12 / ndn-0036-1-ndn-ace.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ccnxke] Mosko, M., Uzun, E., and C. Wood, \"CCNx Key Exchange Protocol Version 1.0\", Work in Progress, draft-wood-icnrg-ccnxkeyexchange-02, March 2017.",
      "ja": "[ccnxke] Mosko、M.、Uzun、E。、およびC. Wood、「CCNx Key Exchange Protocol Version 1.0」、Work in Progress、draft-wood-icnrg-ccnxkeyexchange-02、2017年3月。"
    },
    {
      "indent": 3,
      "text": "[CCNxURI] Mosko, M. and C. Wood, \"The CCNx URI Scheme\", Work in Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016.",
      "ja": "[CCNxURI] Mosko、M.、C。Wood、「The CCNx URI Scheme」、Work in Progress、draft-mosko-icnrg-ccnxurischeme-01、2016年4月。"
    },
    {
      "indent": 3,
      "text": "[CCNxz] Mosko, M., \"CCNxz TLV Header Compression Experimental Code\", commit f1093a2, March 2018, <https://github.com/PARC/CCNxz>.",
      "ja": "[CCNxz] Mosko、M。、「CCNxz TLVヘッダー圧縮実験コード」、f1093a2、2018年3月、<https://github.com/PARC/CCNxz>をコミット。"
    },
    {
      "indent": 3,
      "text": "[compress] Mosko, M., \"Header Compression for TLV-based Packets\", ICNRG Interim Meeting, 2016, <https://datatracker.ietf.org/meeting/interim-2016-icnrg-02/materials/slides-interim-2016-icnrg-2-7>.",
      "ja": "[compress] Mosko、M。、「TLVベースのパケットのヘッダー圧縮」、ICNRG暫定会議、2016年、<https://datatracker.ietf.org/meeting/interim-2016-icnrg-02/materials/slides-interim -2016-icnrg-2-7>。"
    },
    {
      "indent": 3,
      "text": "[ECC] Certicom Research, \"SEC 2: Recommended Elliptic Curve Domain Parameters\", 2010, <http://www.secg.org/sec2-v2.pdf>.",
      "ja": "[ECC] Certicom Research、「SEC 2：推奨される楕円曲線ドメインパラメーター」、2010、<http://www.secg.org/sec2-v2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[esic] Mosko, M. and C. Wood, \"Encrypted Sessions In CCNx (ESIC)\", Work in Progress, draft-wood-icnrg-esic-01, September 2017.",
      "ja": "[esic] Mosko、M.、C。Wood、「Encrypted Sessions In CCNx（ESIC）」、Work in Progress、draft-wood-icnrg-esic-01、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[IANA-PEN] IANA, \"Private Enterprise Numbers\", <http://www.iana.org/assignments/enterprise-numbers>.",
      "ja": "[IANA-PEN] IANA、「企業番号」、<http://www.iana.org/assignments/enterprise-numbers>。"
    },
    {
      "indent": 3,
      "text": "[mobile] Mosko, M., Uzun, E., and C. Wood, \"Mobile Sessions in Content-Centric Networks\", IFIP Networking, 2017, <http://dl.ifip.org/db/conf/networking/ networking2017/1570334964.pdf>.",
      "ja": "[モバイル]モスコ、M。、ウズン、E。、およびC.ウッド、「コンテンツ中心ネットワークにおけるモバイルセッション」、IFIPネットワーキング、2017年、<http://dl.ifip.org/db/conf/networking/ networking2017 / 1570334964.pdf>。"
    },
    {
      "indent": 3,
      "text": "[nnc] Jacobson, V., Smetters, D., Thornton, J., Plass, M., Briggs, N., and R. Braynard, \"Networking Named Content\", Proceedings of the 5th international conference on Emerging networking experiments and technologies (CoNEXT '09), 2009, <http://dx.doi.org/10.1145/1658939.1658941>.",
      "ja": "[nnc] Jacobson、V.、Smetters、D.、Thornton、J.、Plass、M.、Briggs、N.、R. Braynard、 \"Networking Named Content\"、Proceedings of the 5th international conference on Emerging network experiment and テクノロジー（CoNEXT '09）、2009、<http://dx.doi.org/10.1145/1658939.1658941>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、およびW. Polk、 \"インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC7927] Kutscher, D., Ed., Eum, S., Pentikousis, K., Psaras, I., Corujo, D., Saucez, D., Schmidt, T., and M. Waehlisch, \"Information-Centric Networking (ICN) Research Challenges\", RFC 7927, DOI 10.17487/RFC7927, July 2016, <https://www.rfc-editor.org/info/rfc7927>.",
      "ja": "[RFC7927] Kutscher、D.、Ed。、Eum、S.、Pentikousis、K.、Psaras、I.、Corujo、D.、Saucez、D.、Schmidt、T.、およびM. Waehlisch、 \"Information-Centric Networking（ICN）Research Challenges」、RFC 7927、DOI 10.17487 / RFC7927、2016年7月、<https://www.rfc-editor.org/info/rfc7927>。"
    },
    {
      "indent": 3,
      "text": "[RFC7945] Pentikousis, K., Ed., Ohlman, B., Davies, E., Spirou, S., and G. Boggia, \"Information-Centric Networking: Evaluation and Security Considerations\", RFC 7945, DOI 10.17487/RFC7945, September 2016, <https://www.rfc-editor.org/info/rfc7945>.",
      "ja": "[RFC7945] Pentikousis、K.、Ed。、Ohlman、B.、Davies、E.、Spirou、S。、およびG. Boggia、「情報中心ネットワーキング：評価とセキュリティに関する考慮事項」、RFC 7945、DOI 10.17487 / RFC7945 、2016年9月、<https://www.rfc-editor.org/info/rfc7945>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8569] Mosko, M., Solis, I., and C. Wood, \"Content-Centric Networking (CCNx) Semantics\", RFC 8569, DOI 10.17487/RFC8569, July 2019, <https://www.rfc-editor.org/info/rfc8569>.",
      "ja": "[RFC8569]モスコ、M。、ソリス、I。、およびC.ウッド、「コンテンツ中心ネットワーキング（CCNx）セマンティクス」、RFC 8569、DOI 10.17487 / RFC8569、2019年7月、<https：//www.rfc-editor .org / info / rfc8569>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Marc Mosko PARC, Inc. Palo Alto, California 94304 United States of America",
      "ja": "Marc Mosko PARC、Inc.パロアルト、カリフォルニア94304アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +01 650-812-4405\nEmail: mmosko@parc.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Ignacio Solis LinkedIn Mountain View, California 94043 United States of America",
      "ja": "イグナシオソリスLinkedInマウンテンビュー、カリフォルニア94043アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: nsolis@linkedin.com",
      "ja": "メール：nsolis@linkedin.com"
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood University of California, Irvine Irvine, California 92697 United States of America",
      "ja": "クリストファー・A・ウッドカリフォルニア大学アーバインアーバインカリフォルニア92697アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Phone: +01 315-806-5939\nEmail: woodc1@uci.edu",
      "raw": true
    }
  ]
}