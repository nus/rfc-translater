{
  "title": {
    "text": "RFC 8595 - An MPLS-Based Forwarding Plane for Service Function Chaining",
    "ja": "RFC 8595 - サービス機能の連鎖のためのMPLSベースのフォワーディングプレーン"
  },
  "number": 8595,
  "created_at": "2019-10-30 16:19:10.320408+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         A. Farrel\nRequest for Comments: 8595                            Old Dog Consulting\nCategory: Standards Track                                      S. Bryant\nISSN: 2070-1721                                                Futurewei\n                                                                J. Drake\n                                                        Juniper Networks\n                                                               June 2019",
      "raw": true
    },
    {
      "indent": 6,
      "text": "An MPLS-Based Forwarding Plane for Service Function Chaining",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes how Service Function Chaining (SFC) can be achieved in an MPLS network by means of a logical representation of the Network Service Header (NSH) in an MPLS label stack. That is, the NSH is not used, but the fields of the NSH are mapped to fields in the MPLS label stack. This approach does not deprecate or replace the NSH, but it acknowledges that there may be a need for an interim deployment of SFC functionality in brownfield networks.",
      "ja": "このドキュメントでは、サービス機能の連鎖（SFC）はMPLSラベルスタック内のネットワークサービスヘッダ（NSH）の論理的な表現によって、MPLSネットワークで達成することができる方法を説明します。これは、NSHが使用されていないが、NSHのフィールドは、MPLSラベルスタック内のフィールドにマップされます。このアプローチは、廃止またはNSHを交換するが、それはブラウンフィールドネットワークのSFC機能の暫定配備する必要があるかもしれないことを認めていません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8595.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8595で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2019 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Requirements Language ...........................................4\n3. Choice of Data-Plane SPI/SI Representation ......................4\n4. Use Case Scenarios ..............................................5\n   4.1. Label Swapping for Logical NSH .............................5\n   4.2. Hierarchical Encapsulation .................................5\n   4.3. Fine Control of Service Function Instances .................6\n   4.4. Micro Chains and Label Stacking ............................6\n   4.5. SFC and Segment Routing ....................................6\n5. Basic Unit of Representation ....................................6\n6. MPLS Label Swapping .............................................7\n7. MPLS Label Stacking ............................................10\n8. Mixed-Mode Forwarding ..........................................12\n9. A Note on Service Function Capabilities and SFC Proxies ........13\n10. Control-Plane Considerations ..................................14\n11. Use of the Entropy Label ......................................14\n12. Metadata ......................................................15\n   12.1. Indicating Metadata in User Data Packets .................16\n   12.2. In-Band Programming of Metadata ..........................18\n        12.2.1. Loss of In-Band Metadata ..........................21\n13. Worked Examples ...............................................22\n14. Implementation Notes ..........................................26\n15. Security Considerations .......................................26\n16. IANA Considerations ...........................................28\n17. References ....................................................29\n   17.1. Normative References .....................................29\n   17.2. Informative References ...................................30\nAcknowledgements ..................................................31\nContributors ......................................................31\nAuthors' Addresses ................................................32",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Service Function Chaining (SFC) is the process of directing packets through a network so that they can be acted on by an ordered set of abstract Service Functions (SFs) before being delivered to the intended destination. An architecture for SFC is defined in [RFC7665].",
      "ja": "サービス機能の連鎖（SFC）は、彼らが意図した宛先に配信される前に、抽象サービス関数（のSF）の順序集合によって作用することができるようにネットワークを介してパケットを指示する過程です。 SFCのためのアーキテクチャは、[RFC7665]で定義されています。"
    },
    {
      "indent": 3,
      "text": "When applying a particular service function chain to the traffic selected by a service classifier, the traffic needs to be steered through an ordered set of SFs in the network. This ordered set of SFs is termed a Service Function Path (SFP), and the traffic is passed between Service Function Forwarders (SFFs) that are responsible for delivering the packets to the SFs and for forwarding them onward to the next SFF.",
      "ja": "サービス分類器により選択されたトラフィックに特定のサービス機能チェーンを適用する場合、トラフィックは、ネットワーク内のSFの順序付けられたセットを通して操縦する必要があります。これはSFのセット注文したサービス機能パス（SFP）と呼ばれ、トラフィックはのSFにパケットを配信するため、次のSFFに以降それらを転送するための責任があるサービス機能フォワーダ（スキャンフリップフロップ）との間で渡されます。"
    },
    {
      "indent": 3,
      "text": "In order to steer the selected traffic between SFFs and to the correct SFs, the service classifier needs to attach information to each packet. This information indicates the SFP on which the packet is being forwarded and hence the SFs to which it must be delivered. The information also indicates the progress the packet has already made along the SFP.",
      "ja": "スキャンフリップフロップの間、正しいのSFに選択されたトラフィックを操縦するためには、サービスの分類器は、各パケットに情報を添付する必要があります。この情報は、パケットが転送され、従って、サービスフローが、それが送達されなければならないためにその上にSFPを示しています。情報は、パケットがすでにSFPに沿って作られた進捗状況を示します。"
    },
    {
      "indent": 3,
      "text": "The Network Service Header (NSH) [RFC8300] has been defined to carry the necessary information for SFC in packets. The NSH can be inserted into packets and contains various information, including a Service Path Identifier (SPI), a Service Index (SI), and a Time To Live (TTL) counter.",
      "ja": "ネットワークサービスヘッダ（NSH）[RFC8300]は、パケット内のSFCに必要な情報を運ぶために定義されています。 NSHは、パケットに挿入され、サービス・パス識別子（SPI）、サービスインデックス（SI）、及び生存時間（TTL）カウンタを含む様々な情報を含むことができます。"
    },
    {
      "indent": 3,
      "text": "Multiprotocol Label Switching (MPLS) [RFC3031] is a widely deployed forwarding technology that uses labels placed in a packet in a label stack to identify the forwarding actions to be taken at each hop through a network. Actions may include swapping or popping the labels as well as using the labels to determine the next hop for forwarding the packet. Labels may also be used to establish the context under which the packet is forwarded. In many cases, MPLS will be used as a tunneling technology to carry packets through networks between SFFs.",
      "ja": "マルチプロトコルラベルスイッチング（MPLS）[RFC3031]ネットワークを介して各ホップで取るべき転送アクションを識別するためのラベルスタック内のパケットに配置されたラベルを使用して広く展開転送技術です。アクションは、スワッピングやラベルをポップならびにパケットを転送するための次のホップを決定するためにラベルを使用することを含むことができます。ラベルはまた、パケットが転送され、その下のコンテキストを確立するために使用することができます。多くの場合、MPLSは、スキャンフリップフロップ間のネットワークを介してパケットを運ぶためにトンネリング技術として使用されます。"
    },
    {
      "indent": 3,
      "text": "This document describes how SFC can be achieved in an MPLS network by means of a logical representation of the NSH in an MPLS label stack. This approach is applicable to all forms of MPLS forwarding (where labels are looked up at each hop and are swapped or popped [RFC3031]). It does not deprecate or replace the NSH, but it acknowledges that there may be a need for an interim deployment of SFC functionality in brownfield networks. The mechanisms described in this document are a compromise between the full function that can be achieved using the NSH and the benefits of reusing the existing",
      "ja": "この文書では、SFCは、MPLSラベルスタックのNSHの論理的な表現によって、MPLSネットワークで達成することができる方法を説明します。このアプローチは、MPLS転送（ラベルが各ホップでルックアップされ、交換され又はポップここで、[RFC3031]）の全ての形態に適用可能です。これは、廃止またはNSHを交換するが、それはブラウンフィールドネットワークのSFC機能の暫定配備する必要があるかもしれないことを認めていません。この文書で説明したメカニズムは、NSHと既存を再利用することの利点を使用して達成することができるフル機能の間の妥協です"
    },
    {
      "indent": 3,
      "text": "MPLS forwarding paradigms (the approach defined here does not include the O bit defined in [RFC8300] and has some limitations to the use of metadata as described in Section 12).",
      "ja": "MPLS転送パラダイム（セクション12で説明したようにここで定義されたアプローチは、[RFC8300]で定義されたOビットを含み、メタデータの使用にはいくつかの制限がありません）。"
    },
    {
      "indent": 3,
      "text": "Section 4 provides a short overview of several use case scenarios that help to explain the relationship between the MPLS label operations (swapping, popping, stacking) and the MPLS encoding of the logical NSH described in this document.",
      "ja": "セクション4は、この文書に記載されたMPLSラベル操作との関係（スワッピングポッピング、スタッキング）と論理NSHのMPLS符号化を説明するのに役立ついくつかのユース・ケース・シナリオの簡単な概要を提供します。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the reader is fully familiar with the terms and concepts introduced in [RFC7665] and [RFC8300].",
      "ja": "読者が用語及び[RFC7665]及び[RFC8300]で導入された概念と完全に精通しているものとします。"
    },
    {
      "indent": 3,
      "text": "Note that one of the features of the SFC architecture described in [RFC7665] is the \"SFC proxy\", which exists to include legacy SFs that are not able to process NSH-encapsulated packets. This issue is equally applicable to the use of MPLS-encapsulated packets that encode a logical representation of an NSH. It is discussed further in Section 9.",
      "ja": "[RFC7665]で説明SFCアーキテクチャの特徴の一つは、NSHカプセル化パケットを処理することができないレガシーサービスフローを含むように存在する「SFCプロキシ」、であることに留意されたいです。この問題は、NSHの論理的表現をコードMPLSカプセル化パケットの使用にも同様に適用可能です。これは、第9章で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Choice of Data-Plane SPI/SI Representation",
      "section_title": true,
      "ja": "データプレーンSPI / SI表現3.選択"
    },
    {
      "indent": 3,
      "text": "While [RFC8300] defines the NSH that can be used in a number of environments, this document provides a mechanism to handle situations in which the NSH is not ubiquitously deployed. In this case, it is possible to use an alternative data-plane representation of the SPI/SI by carrying the identical semantics in MPLS labels.",
      "ja": "[RFC8300]は環境の数で使用することができるNSHを定義しながら、この文書はNSHが遍在展開されていない状況に対処するためのメカニズムを提供します。この場合には、MPLSラベルに同じセマンティクスを実施することによってSPI / SIの代替データプレーン表現を使用することが可能です。"
    },
    {
      "indent": 3,
      "text": "In order to correctly select the mechanism by which SFC information is encoded and carried between SFFs, it may be necessary to configure the capabilities and choices either within the whole Service Function Overlay Network or on a hop-by-hop basis. It is a requirement that both ends of a tunnel over the underlay network (i.e., a pair of SFFs adjacent in the SFP) know that the tunnel is used for SFC and know what form of NSH representation is used. A control-plane signaling approach to achieve these objectives is provided using BGP in [BGP-NSH-SFC].",
      "ja": "正しくSFC情報が符号化され、スキャンフリップフロップとの間に搬送される機構を選択するために、全体サービス機能オーバレイネットワーク内またはホップバイホップ基づいていずれかの機能及び選択肢を設定する必要があるかもしれません。これは、アンダーレイネットワーク上のトンネルの両端（すなわち、SFPに隣接するスキャンフリップフロップのペア）トンネルがSFCに使用され、使用されているNSH表現のどのような形式を知っていることを知っている必要があります。これらの目的を達成するための制御プレーンシグナリングアプローチは、[BGP-NSH-SFC]でBGPを使用して提供されます。"
    },
    {
      "indent": 3,
      "text": "Note that the encoding of the SFC information is independent of the choice of tunneling technology used between SFFs. Thus, an MPLS representation of the logical NSH (as defined in this document) may be used even if the tunnel between a pair of SFFs is not an MPLS tunnel. Conversely, MPLS tunnels may be used to carry other encodings of the logical NSH (specifically, the NSH itself).",
      "ja": "SFC情報の符号化は、スキャンフリップフロップの間で使用されるトンネリング技術の選択とは無関係であることに注意してください。したがって、論理NSHのMPLS表現は、（本書で定義されるように）スキャンフリップフロップの対の間のトンネルがMPLSトンネルでない場合であっても使用することができます。逆に、MPLSトンネルは論理NSH（具体的には、NSH自体）の他のエンコーディングを運ぶために使用されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4. Use Case Scenarios",
      "section_title": true,
      "ja": "4.ユースケースのシナリオ"
    },
    {
      "indent": 3,
      "text": "There are five scenarios that can be considered for the use of an MPLS encoding in support of SFC. These are set out in the following subsections.",
      "ja": "SFCの支援におけるMPLSエンコーディングの使用を考慮することができる5つのシナリオがあります。これらは、以下のサブセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Label Swapping for Logical NSH",
      "section_title": true,
      "ja": "4.1. 論理NSH用ラベルスワッピング"
    },
    {
      "indent": 3,
      "text": "The primary use case for SFC is described in [RFC7665] and delivered using the NSH, which, as described in [RFC8300], uses an encapsulation with a position indicator that is modified at each SFC hop along the chain to indicate the next hop.",
      "ja": "SFCのための主要なユースケースは、[RFC7665]で説明した、[RFC8300]に記載されているように、次のホップを示すために、鎖に沿って各SFCホップで修飾された位置指示器とのカプセル化を使用NSHを用いて送達されます。"
    },
    {
      "indent": 3,
      "text": "The label-swapping use case scenario effectively replaces the NSH with an MPLS encapsulation as described in Section 6. The MPLS labels encode the same information as the NSH to form a logical NSH. The labels are modified (swapped per [RFC3031]) at each SFC hop along the chain to indicate the next hop. The processing and the forwarding state for a chain (i.e., the actions to take on a received label) are programmed into the network using a control plane or management plane.",
      "ja": "MPLSラベルは、論理NSHを形成するNSHと同じ情報を符号化する第6節に記載したようにラベルスワッピングユース・ケース・シナリオを効果的MPLSカプセル化でNSHを置き換えます。ラベルは次のホップを示すために、チェーンに沿った各SFCのホップで（[RFC3031]あたりのスワップ）修飾されています。チェーンのための処理及び転送状態（すなわち、受信されたラベルに取るべきアクション）は、制御プレーン又は管理プレーンを使用してネットワークにプログラムされます。"
    },
    {
      "indent": 0,
      "text": "4.2. Hierarchical Encapsulation",
      "section_title": true,
      "ja": "4.2. 階層カプセル化"
    },
    {
      "indent": 3,
      "text": "[RFC8459] describes an architecture for hierarchical encapsulation using the NSH. It facilitates partitioning of SFC domains for administrative reasons and allows concatenation of service function chains under the control of a service classifier.",
      "ja": "[RFC8459]はNSHを使用して階層的カプセル化のためのアーキテクチャを説明しています。これは、管理上の理由でSFCドメインの分割を容易にし、サービスの分類器の制御下で、サービス機能チェーンの連結を可能にします。"
    },
    {
      "indent": 3,
      "text": "The same function can be achieved in an MPLS network using an MPLS encoding of the logical NSH, and label stacking as defined in [RFC3031] and described in Section 7. In this model, swapping is used per Section 4.1 to navigate one chain, and when the end of the chain is reached, the final label is popped, revealing the label for another chain. Thus, the primary mode is swapping, but stacking is used to enable the ingress classifier to control concatenation of service function chains.",
      "ja": "同様の機能は、論理NSHのMPLSエンコーディングを使用してMPLSネットワーク内で達成することができ、そして、[RFC3031]で定義されており、このモデルでは、セクション7で説明したように積層ラベルは、スワッピングは、一つの鎖をナビゲートするために4.1節ごとに使用され、そしてチェーンの最後に到達したとき、最後のラベルは別の鎖のラベルを明らかにし、ポップされます。このように、主モードはスワップですが、スタッキングは、サービス機能のチェーンの連結を制御するための入口分類器を有効にするために使用されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Fine Control of Service Function Instances",
      "section_title": true,
      "ja": "4.3. サービス機能インスタンスの微調整"
    },
    {
      "indent": 3,
      "text": "It may be that a service function chain (as described in Section 4.1) allows some leeway in the choice of service function instances along the chain. However, it may be that a service classifier wishes to constrain the choice and this can be achieved using chain concatenation so that the first chain ends at the point of choice, the next label in the stack indicates the specific service function instance to be executed, and the next label in the stack starts a new chain. Thus, a mixture of label swapping and stacking is used.",
      "ja": "これは、サービス機能チェーンは（セクション4.1で説明したように）鎖に沿ったサービス機能インスタンスの選択に余裕を可能にすることであってもよいです。しかし、それはサービス分類器は選択を制約することを望むと、第1のチェーンは、任意の時点で終了するように、これはチェーン連結を使用して達成することができることであってもよいし、スタック内の次のラベルは、実行される特定のサービス機能のインスタンスを示し、スタック内の次のラベルが新しいチェーンを開始します。このように、ラベルスワッピングとスタッキングの混合物が使用されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Micro Chains and Label Stacking",
      "section_title": true,
      "ja": "4.4. マイクロチェーンとラベルのスタッキング"
    },
    {
      "indent": 3,
      "text": "The scenario in Section 4.2 may be extended to its logical extreme by making each concatenated chain as short as it can be: one SF. Each label in the stack indicates the next SF to be executed, and the network is programmed through the control plane or management plane to know how to route to the next (i.e., first) hop in each chain just as it would be to support the scenarios in Sections 4.1 and 4.2.",
      "ja": "1 SF：4.2項におけるシナリオは、それができる限り短く各連結鎖を作ることによって、その論理極端に拡張することができます。スタック内の各ラベルは、次のSFを示して実行される、ネットワークが知るために、制御プレーン又は管理プレーンによってプログラムされているどのようにサポートすることと同じように、各チェーン内の次の（すなわち、最初の）ホップにルーティングしますセクション4.1と4.2でのシナリオ。"
    },
    {
      "indent": 3,
      "text": "This scenario is functionally identical to the use of Segment Routing (SR) in an MPLS network (known as SR-MPLS) for SFC, as described in Section 4.5, and the discussion in that section applies to this section as well.",
      "ja": "セクション4.5で説明したように、このシナリオでは、SFCのための（SR-MPLSとしても知られる）MPLSネットワークにおけるセグメントルーティング（SR）の使用と機能的に同一であり、そのセクションにおける議論は、同様に、このセクションに適用されます。"
    },
    {
      "indent": 0,
      "text": "4.5. SFC and Segment Routing",
      "section_title": true,
      "ja": "4.5.  SFCとセグメントルーティング"
    },
    {
      "indent": 3,
      "text": "SR-MPLS uses a stack of MPLS labels to encode information about the path and network functions that a packet should traverse. SR-MPLS is achieved by applying control-plane and management-plane techniques to program the MPLS forwarding plane and by imposing labels on packets at the entrance to the SR-MPLS network. An implementation proposal for achieving SFC using SR-MPLS can be found in [SR-Srv-Prog] and is not discussed further in this document.",
      "ja": "SR-MPLSパケットが横断しなければならないパスとネットワーク機能についての情報を符号化するためにMPLSラベルのスタックを使用します。 SR-MPLSは、平面を転送MPLSをプログラムするために制御プレーンおよび管理プレーン技術を適用することによって、およびSR-MPLSネットワークへの入口でパケットにラベルを課すことによって達成されます。 SR-MPLSを使用してSFCを達成するための実装案は、[SR-SRV-PROG]に見出すことができ、この文書ではさらに説明しません。"
    },
    {
      "indent": 0,
      "text": "5. Basic Unit of Representation",
      "section_title": true,
      "ja": "表現の5.基本ユニット"
    },
    {
      "indent": 3,
      "text": "When an MPLS label stack is used to carry a logical NSH, a basic unit of representation is used. This unit comprises two MPLS labels, as shown below. The unit may be present one or more times in the label stack as explained in subsequent sections.",
      "ja": "MPLSラベルスタックは、論理NSHを搬送するために使用される場合、表現の基本単位が使用されます。以下に示すように、このユニットは二つのMPLSラベルを含みます。後続のセクションで説明したようなユニットは、ラベルスタックに一回以上存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "In order to convey the same information as is present in the NSH, two MPLS label stack entries are used. One carries a label to provide context within the SFC scope (the SFC Context Label), and the other carries a label to show which SF is to be actioned (the SF Label). This two-label unit is shown in Figure 1.",
      "ja": "NSH中に存在するのと同じ情報を伝達するために、2つのMPLSラベルスタックエントリが使用されています。一つは、SFCスコープ（SFCコンテキストラベル）内にコンテキストを提供するためにラベルを搬送し、他方は、SFが（SFラベル）actionedすべき表示するラベルを運びます。この二ラベル部は、図1に示されています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           SFC Context Label           | TC  |S|       TTL     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           SF Label                    | TC  |S|       TTL     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 1: The Basic Unit of MPLS Label Stack for SFC",
      "ja": "図1：SFCのためのMPLSラベルスタックの基本単位"
    },
    {
      "indent": 3,
      "text": "The fields of these two label stack entries are encoded as follows:",
      "ja": "以下のように、これらの2つのラベルスタックエントリーのフィールドはエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Label: The Label fields contain the values of the SFC Context Label and the SF Label encoded as 20-bit integers. The precise semantics of these Label fields are dependent on whether the label stack entries are used for MPLS label swapping (see Section 6) or MPLS label stacking (see Section 7).",
      "ja": "ラベル：ラベルフィールドはSFCコンテキストラベルと20ビット整数としてエンコードされたSFラベルの値が含まれています。これらのラベルフィールドの正確な意味は、ラベルスタックエントリはMPLSラベルスワッピングのために使用されているかどうかに依存しているか、スタッキングMPLSラベル（セクション7を参照）（6章を参照してください）。"
    },
    {
      "indent": 3,
      "text": "TC: The TC bits have no meaning in this case. They SHOULD be set to zero in both label stack entries when a packet is sent and MUST be ignored on receipt.",
      "ja": "TC：TCビットは、この場合には意味を持ちません。パケットが送信され、領収書の上で無視しなければなりませんとき、彼らは両方のラベルスタックエントリにゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "S: The \"Bottom of Stack\" bit has its usual meaning in MPLS. It MUST be clear in the SFC Context Label stack entry. In the SF Label stack entry, it MUST be clear in all cases except when the label is the bottom of the stack, when it MUST be set.",
      "ja": "S：「スタックの最下部」ビットMPLSにおけるその通常の意味を有します。これは、SFCコンテキストラベルスタックエントリに明確でなければなりません。 SFラベルスタックエントリーでは、それが設定しなければならないときラベルは、スタックの最下部であるときを除いて、すべての場合には明確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "TTL: The TTL field in the SFC Context Label stack entry SHOULD be set to 1. The TTL in the SF Label stack entry (called the SF TTL) is set according to its use for MPLS label swapping (see Section 6) or MPLS label stacking (see Section 7) and is used to mitigate packet loops.",
      "ja": "TTL：SFCコンテキストラベルスタックエントリ内のTTLフィールドが（SF TTLと呼ばれる）SFラベルスタックエントリ内のTTLがMPLSラベルスワッピング（第6節を参照）またはMPLSラベルのためのその使用に応じて設定されている1に設定されるべきである（SHOULD）スタッキング（セクション7を参照）、パケットのループを軽減するために使用されています。"
    },
    {
      "indent": 3,
      "text": "The sections that follow show how this basic unit of MPLS label stack may be used for SFC in the MPLS label-swapping case and in the MPLS label-stacking case. For simplicity, these sections do not describe the use of metadata; that topic is covered separately in Section 12.",
      "ja": "以下のセクションでは、MPLSラベルスタックのこの基本的な単位は、MPLSラベルスワッピング場合とMPLSラベル・スタックの場合にはSFCのために使用することができる方法を示しています。簡単にするために、これらのセクションでは、メタデータの使用を記載していません。そのトピックは、セクション12で個別に覆われています。"
    },
    {
      "indent": 0,
      "text": "6. MPLS Label Swapping",
      "section_title": true,
      "ja": "6. MPLSラベルスワッピング"
    },
    {
      "indent": 3,
      "text": "This section describes how the basic unit of MPLS label stack for SFC (introduced in Section 5) is used when MPLS label swapping is in use. The use case scenario for this approach is introduced in Section 4.1.",
      "ja": "このセクションでは、MPLSラベルスワッピングが使用されているとき（第5節で導入）SFCのためのMPLSラベルスタックの基本的な単位を使用する方法について説明します。このアプローチのためのユースケースシナリオは、セクション4.1で導入されました。"
    },
    {
      "indent": 3,
      "text": "As can be seen in Figure 2, the top of the label stack comprises the labels necessary to deliver the packet over the MPLS tunnel between SFFs. Any MPLS encapsulation may be used (i.e., MPLS, MPLS in UDP, MPLS in GRE, and MPLS in Virtual Extensible Local Area Networks (VXLANs) or the Generic Protocol Extension for VXLAN (GPE)); thus, the tunnel technology does not need to be MPLS, but MPLS is shown here for simplicity.",
      "ja": "図2から分かるように、ラベルスタックの最上位は、スキャンフリップフロップ間のMPLSトンネルを介してパケットを配信するために必要な標識を含みます。任意のMPLSカプセル化を使用してもよい（すなわち、MPLS、UDP、GREにおけるMPLS、仮想拡張ローカルエリアネットワークにおけるMPLS（VXLANs）またはVXLANための汎用プロトコル拡張（GPE）でMPLS）。このように、トンネル技術は、MPLSである必要はありませんが、MPLSは、単純化のためにここに示されています。"
    },
    {
      "indent": 3,
      "text": "An entropy label [RFC6790] may also be present, as described in Section 11.",
      "ja": "セクション11で説明したように、エントロピーラベル[RFC6790]も、存在してもよいです。"
    },
    {
      "indent": 6,
      "text": " ---------------\n~ Tunnel Labels ~\n+---------------+\n~   Optional    ~\n~ Entropy Label ~\n+---------------+ - - -\n|   SPI Label   |\n+---------------+  Basic unit of MPLS label stack for SFC\n|   SI Label    |\n+---------------+ - - -\n|               |\n~    Payload    ~\n|               |\n ---------------",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2: The MPLS SFC Label Stack",
      "ja": "図2：MPLSラベルスタックSFC"
    },
    {
      "indent": 3,
      "text": "Under these labels (or other encapsulation) comes a single instance of the basic unit of MPLS label stack for SFC. In addition to the interpretation of the fields of these label stack entries (provided in Section 5), the following meanings are applied:",
      "ja": "これらのラベル（または他のカプセル化）の下にSFCのためのMPLSラベルスタックの基本単位の単一のインスタンスが来ます。 （第5節で提供）これらのラベルスタックエントリーのフィールドの解釈に加えて、以下の意味が適用されます。"
    },
    {
      "indent": 3,
      "text": "SPI Label: The Label field of the SFC Context Label stack entry contains the value of the SPI encoded as a 20-bit integer. The semantics of the SPI are exactly as defined in [RFC8300]. Note that an SPI as defined by [RFC8300] can be encoded in 3 octets (i.e., 24 bits), but that the Label field allows for only 20 bits and reserves the values 0 through 15 as \"special-purpose labels\" [RFC7274]. Thus, a system using MPLS representation of the logical NSH MUST NOT assign SPI values greater than 2^20 - 1 or less than 16.",
      "ja": "SPIラベル：SFCコンテキストラベルスタックエントリのラベルフィールドは、20ビットの整数として符号化SPIの値を含みます。 [RFC8300]で定義されているSPIの意味はまったく同じです。 [RFC8300]で定義されるようにSPIが3つのオクテット（すなわち、24ビット）で符号化することが可能であるが、ラベルフィールドのみ20ビットを可能にし、「特殊目的ラベル」として15を介して値0を保有していること[RFC7274] 。 1又は16未満 - したがって、論理NSHのMPLS表現を使用するシステムは、SPIが2 ^ 20を超える値割り当ててはいけません。"
    },
    {
      "indent": 3,
      "text": "SI Label: The Label field of the SF Label stack entry contains the value of the SI exactly as defined in [RFC8300]. Since the SI requires only 8 bits, and to avoid overlap with the special-purpose label range of 0 through 15 [RFC7274], the SI is carried in the top (most significant) 8 bits of the Label field with the low-order 12 bits set to zero.",
      "ja": "SIラベル：SFラベルスタックエントリーのLabelフィールドは、[RFC8300]で定義されたとおりにSIの値が含まれています。 SIは、下位12で（最も重要な）ラベルフィールドの8ビットを8ビットのみを必要とし、15を介して[RFC7274]を0の専用のラベル範囲との重複を避けるために、SIは、上部に搭載しているのでビットはゼロに設定します。"
    },
    {
      "indent": 3,
      "text": "TC: The TC fields are as described in Section 5.",
      "ja": "TC：TCフィールドセクション5で説明したようにしています。"
    },
    {
      "indent": 3,
      "text": "S: The S bits are as described in Section 5.",
      "ja": "S：Sビット項5に記載の通りです。"
    },
    {
      "indent": 3,
      "text": "TTL: The TTL field in the SPI Label stack entry SHOULD be set to 1 as stated in Section 5. The TTL in the SF Label stack entry is decremented once for each forwarding hop in the SFP, i.e., for each SFF transited, and so mirrors the TTL field in the NSH.",
      "ja": "TTL：SPIラベルスタックエントリ内のTTLフィールドは、各SFFの遷移のために、SFラベルスタックエントリ内のTTLはすなわちSFP、各転送ホップのために一回デクリメントされ、セクション5で述べたように1に設定し、そうすべきである（SHOULD） NSHにTTLフィールドを反映しています。"
    },
    {
      "indent": 3,
      "text": "The following processing rules apply to the Label fields:",
      "ja": "以下の処理規則は、ラベルの分野に適用されます。"
    },
    {
      "indent": 3,
      "text": "o When a classifier inserts a packet onto an SFP, it sets the SPI Label to indicate the identity of the SFP and sets the SI Label to indicate the first SF in the path.",
      "ja": "分類器は、SFPにパケットを挿入すると、Oは、SFPのアイデンティティを示すために、SPIラベルを設定し、パスの最初のSFを示すために、SIのラベルを設定します。"
    },
    {
      "indent": 3,
      "text": "o When a component of the SFC system processes a packet, it uses the SPI Label to identify the SFP and the SI Label to determine which SFF or instance of an SF (an SFI) to deliver the packet to. Under normal circumstances (with the exception of branching and reclassification -- see [BGP-NSH-SFC]), the SPI Label value is preserved on all packets. The SI Label value is modified by SFFs and through reclassification to indicate the next hop along the SFP.",
      "ja": "SFCシステムの構成要素がパケットを処理するとき、O、それにパケットを配信するためにどのSFFまたはSF（SFI）のインスタンスを決定するためにSFPとSIラベルを識別するために、SPIラベルを使用します。 （分岐して再分類を除く -  [BGP-NSH-SFC]参照）通常の状況下では、SPIラベル値はすべてのパケットに保存されています。 SIラベル値は、SFPに沿った次のホップを示すために、スキャンフリップフロップによって、および再分類によって変更されます。"
    },
    {
      "indent": 3,
      "text": "The following processing rules apply to the TTL field of the SF Label stack entry and are derived from Section 2.2 of [RFC8300]:",
      "ja": "以下の処理規則はSFラベルスタックエントリのTTLフィールドに適用され、[RFC8300]のセクション2.2に由来します。"
    },
    {
      "indent": 3,
      "text": "o When a classifier places a packet onto an SFP, it MUST set the TTL to a value between 1 and 255. It SHOULD set this according to the expected length of the SFP (i.e., the number of SFs on the SFP), but it MAY set it to a larger value according to local configuration. The maximum TTL value supported in an NSH is 63, and so the practical limit here may also be 63.",
      "ja": "分類器は、SFPにパケットを配置する場合、O、それは、このSFPの予想される長さ（すなわち、SFPにSFの数）に応じて設定すべきである1と255の間の値にTTLを設定し、それしなければなりませんローカル構成によれば、より大きな値に設定してもよいです。 NSHにサポートされる最大TTL値が63であるので、ここで実際的な限界はまた、63であってもよいです。"
    },
    {
      "indent": 3,
      "text": "o When an SFF receives a packet from any component of the SFC system (classifier, SFI, or another SFF), it MUST discard any packets with TTL set to zero. It SHOULD log such occurrences but MUST apply rate limiting to any such logs.",
      "ja": "SFFは、SFCシステム（クラシファイア、SFI、または別のSFF）のいずれかの構成要素からパケットを受信すると、O、それはゼロに設定TTLを持つパケットを廃棄しなければなりません。それは、このような出来事を記録する必要がありますが、そのようなログにレート制限を適用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o An SFF MUST decrement the TTL by one each time it performs a lookup to forward a packet to the next SFF.",
      "ja": "O SFFは、いずれかによって、それが次のSFFにパケットを転送するためにルックアップを実行するたびにTTLをデクリメントしなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If an SFF decrements the TTL to zero, it MUST NOT send the packet and MUST discard the packet. It SHOULD log such occurrences but MUST apply rate limiting to any such logs.",
      "ja": "SFFがゼロにTTLを減少した場合は、O、それはパケットを送ってはいけませんし、パケットを捨てなければなりません。それは、このような出来事を記録する必要がありますが、そのようなログにレート制限を適用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SFIs MUST ignore the TTL but MUST mirror it back to the SFF unmodified along with the SI (which may have been changed by local reclassification).",
      "ja": "O SFISはTTLを無視しなければなりませんが、バックSFF（ローカル再分類することによって変更されていてもよい）SIと一緒に非修飾にそれを反映しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If a classifier along the SFP makes any change to the intended path of the packet, including for looping, jumping, or branching (see [BGP-NSH-SFC]), it MUST NOT change the SI TTL of the packet. In particular, each component of the SFC system MUST NOT increase the SI TTL value; otherwise, loops may go undetected.",
      "ja": "SFPに沿った分類器は（[BGP-NSH-SFC]参照）、ループジャンプまたは分岐を含め、パケットの意図した経路に変更を行った場合のO、パケットのSI TTLを変更しないでください。具体的に、SFCシステムの各構成要素は、SI TTL値を増加させなければなりません。そうでない場合は、ループが検出されないことがあります。"
    },
    {
      "indent": 0,
      "text": "7. MPLS Label Stacking",
      "section_title": true,
      "ja": "7. MPLSラベルスタッキング"
    },
    {
      "indent": 3,
      "text": "This section describes how the basic unit of MPLS label stack for SFC (introduced in Section 5) is used when MPLS label stacking is used to carry information about the SFP and SFs to be executed. The use case scenarios for this approach are introduced in Section 4.",
      "ja": "このセクションでは、MPLSラベルスタックは、SFPおよびSFS実行すべき情報を運ぶために使用された場合（セクション5で導入）SFCのためのMPLSラベルスタックの基本単位が使用される方法について説明します。このアプローチのためのユースケースシナリオは第4節で導入されています。"
    },
    {
      "indent": 3,
      "text": "As can be seen in Figure 3, the top of the label stack comprises the labels necessary to deliver the packet over the MPLS tunnel between SFFs. Any MPLS encapsulation may be used.",
      "ja": "図3から分かるように、ラベルスタックの最上位は、スキャンフリップフロップ間のMPLSトンネルを介してパケットを配信するために必要な標識を含みます。任意のMPLSカプセル化を使用することができます。"
    },
    {
      "indent": 6,
      "text": " -------------------\n~   Tunnel Labels   ~\n+-------------------+\n~     Optional      ~\n~   Entropy Label   ~\n+-------------------+ - - -\n| SFC Context Label |\n+-------------------+  Basic unit of MPLS label stack for SFC\n|     SF Label      |\n+-------------------+ - - -\n| SFC Context Label |\n+-------------------+  Basic unit of MPLS label stack for SFC\n|     SF Label      |\n+-------------------+ - - -\n~                   ~\n+-------------------+ - - -\n| SFC Context Label |\n+-------------------+  Basic unit of MPLS label stack for SFC\n|     SF Label      |\n+-------------------+ - - -\n|                   |\n~      Payload      ~\n|                   |\n -------------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 3: The MPLS SFC Label Stack for Label Stacking",
      "ja": "図3：ラベルのスタッキングのためのMPLSラベルスタックSFC"
    },
    {
      "indent": 3,
      "text": "An entropy label [RFC6790] may also be present, as described in Section 11.",
      "ja": "セクション11で説明したように、エントロピーラベル[RFC6790]も、存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "Under these labels comes one or more instances of the basic unit of MPLS label stack for SFC. In addition to the interpretation of the fields of these label stack entries (provided in Section 5), the following meanings are applied:",
      "ja": "これらのラベルの下にSFCのためのMPLSラベルスタックの基本単位の1つ以上のインスタンスが来ます。 （第5節で提供）これらのラベルスタックエントリーのフィールドの解釈に加えて、以下の意味が適用されます。"
    },
    {
      "indent": 3,
      "text": "SFC Context Label: The Label field of the SFC Context Label stack entry contains a label that delivers SFC context. This label contains the SPI, encoded as a 20-bit integer using the semantics exactly as defined in [RFC8300]. Note that in this case a system using MPLS representation of the logical NSH MUST NOT assign SPI values greater than 2^20 - 1 or less than 16. This label may also be used to convey other SFC context-specific semantics, such as indicating how to interpret the SF Label or how to forward the packet to the node that offers the SF if so configured and coordinated with the controller that programs the labels for the SFP.",
      "ja": "SFCコンテキストレーベル：SFCコンテキストラベルスタックエントリーのLabelフィールドは、SFCのコンテキストを提供するラベルが含まれています。このラベルは、[RFC8300]で定義されたとおりにセマンティクスを使用して、20ビット整数としてエンコードされ、SPIを含んでいます。このラベルはまた、どのように示すような他のSFCコンテキスト固有の意味を伝えるために使用することができる16より1以下 - この場合、論理NSHのMPLS表現を使用して、システムがSPIは2 ^ 20を超える値割り当てない必要がありますSFレーベルまたはどのように設定され、そのプログラムのSFPのラベルをコントローラと連携した場合にSFを提供していますノードにパケットを転送する方法を解釈します。"
    },
    {
      "indent": 3,
      "text": "SF Label: The Label field of the SF Label stack entry contains a value that identifies the next SFI to be actioned for the packet. This label may be scoped globally or within the context of the preceding SFC Context Label and comes from the range 16 ... 2^20 - 1.",
      "ja": "SFラベル：SFラベルスタックエントリーのLabelフィールドは、パケットのためにactionedされる次のSFIを識別する値が含まれています。このラベルは、グローバルまたは前のSFCコンテキストラベルのコンテキスト内でスコープと範囲16 ... 2 ^ 20から来てすることができる -  1。"
    },
    {
      "indent": 3,
      "text": "TC: The TC fields are as described in Section 5.",
      "ja": "TC：TCフィールドセクション5で説明したようにしています。"
    },
    {
      "indent": 3,
      "text": "S: The S bits are as described in Section 5.",
      "ja": "S：Sビット項5に記載の通りです。"
    },
    {
      "indent": 3,
      "text": "TTL: The TTL fields in the SFC Context Label stack entry and in the SF Label stack entry SHOULD be set to 1 as stated in Section 5 but MAY be set to larger values if the label indicated a forwarding operation towards the node that hosts the SF.",
      "ja": "TTL：SFCコンテキストラベルスタックエントリおよびSFラベルスタックエントリ内のTTLフィールドはセクション5で述べたように1に設定されるべきであるが、ラベルがSFをホストするノードに向かって転送動作を示した場合、より大きな値に設定されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The following processing rules apply to the Label fields:",
      "ja": "以下の処理規則は、ラベルの分野に適用されます。"
    },
    {
      "indent": 3,
      "text": "o When a classifier inserts a packet onto an SFP, it adds a stack comprising one or more instances of the basic unit of MPLS label stack for SFC. Taken together, this stack defines the SFs to be actioned and so defines the SFP that the packet will traverse.",
      "ja": "分類器はSFPへパケットを挿入すると、Oは、SFCのためのMPLSラベルスタックの基本単位の1つまたは複数のインスタンスを含むスタックを追加します。まとめると、このスタックはactionedするサービスフローを定義するので、パケットが横断するSFPを定義します。"
    },
    {
      "indent": 3,
      "text": "o When a component of the SFC system processes a packet, it uses the top basic unit of label stack for SFC to determine to which SFI to next deliver the packet. When an SFF receives a packet, it examines the top basic unit of MPLS label stack for SFC to determine where to send the packet next. If the next recipient is a local SFI, the SFF strips the basic unit of MPLS label stack for SFC before forwarding the packet.",
      "ja": "SFCシステムの構成要素がパケットを処理するとき、Oは、SFIは次のパケットを配信するためにどの決定するSFCのラベルスタックの最上位の基本単位を使用します。 SFFがパケットを受信すると、それはどこ次のパケットの送信先を決定するためにSFCのためのMPLSラベルスタックの最上位の基本単位を調べます。次の受信者がローカルSFIの場合は、SFFは、パケットを転送する前にSFCのためのMPLSラベルスタックの基本単位を取り除きます。"
    },
    {
      "indent": 0,
      "text": "8. Mixed-Mode Forwarding",
      "section_title": true,
      "ja": "8.ミックスモード転送"
    },
    {
      "indent": 3,
      "text": "The previous sections describe homogeneous networks where SFC forwarding is either all label swapping or all label popping (stacking). This simplification helps to clarify the explanation of the mechanisms.",
      "ja": "前のセクションでは、SFCの転送は、すべてのラベルスワッピングまたはすべてのラベル（スタッキング）ポップのいずれかである均質なネットワークを記述する。この単純化のメカニズムの説明を明確にすることができます。"
    },
    {
      "indent": 3,
      "text": "However, as described in Section 4.2, some use cases may use label swapping and stacking at the same time. Furthermore, it is also possible that different parts of the network utilize swapping or popping such that an end-to-end service chain has to utilize a combination of both techniques. It is also worth noting that a classifier may be content to use an SFP as installed in the network by a control plane or management plane and so would use label swapping, but that there may be a point in the SFP where a choice of SFIs can be made (perhaps for load balancing) and where, in this instance, the classifier wishes to exert control over that choice by use of a specific entry on the label stack as described in Section 4.3.",
      "ja": "しかし、4.2節で説明したように、いくつかのユースケースを同時に交換し、スタッキングラベルを使用することができます。また、ネットワークの異なる部分がスワップ又はエンドツーエンドのサービス鎖は両方の技術の組み合わせを利用しなければならないように飛び出る利用することも可能です。それはまた、ラベルスワッピングを使用するので、制御プレーン又は管理プレーンによってネットワークにインストールされたように分類器がSFPを使用するコンテンツであってもよいことが、ここでSFISの選択ができSFP点があるかもしれないことは注目に値しますどこで（おそらく負荷分散のために）行うことが、この例では、分類器は、4.3節で説明したようにラベルスタック上の特定のエントリを使用することにより、その選択の制御を発揮したいです。"
    },
    {
      "indent": 3,
      "text": "When an SFF receives a packet containing an MPLS label stack, it checks from the context of the incoming interface, and from the SFP indicated by the top label, whether it is processing an {SPI, SI} label pair for label swapping or a {context label, SFI index} label pair for label stacking. It then selects the appropriate SFI to which to send the packet. When it receives the packet back from the SFI, it has four cases to consider.",
      "ja": "SFFは、MPLSラベルスタックを含むパケットを受信すると、着信インターフェイスのコンテキストからチェックし、それがラベルスワッピング又はため{SPI、SI}ラベル対を処理しているかどうかをSFPから、トップラベルで示さ{コンテキストラベル、SFIインデックス}ラベルスタックのラベルのペア。これは、パケットの送信先となる適切なSFIを選択します。それが戻っSFIからのパケットを受信すると、それは考慮すべき4例があります。"
    },
    {
      "indent": 3,
      "text": "o If the current hop requires an {SPI, SI} and the next hop requires an {SPI, SI}, it sets the SPI Label according to the SFP to be traversed, selects an instance of the SF to be executed at the next hop, sets the SI Label to the SI value of the next hop, and tunnels the packet to the SFF for that SFI.",
      "ja": "現在のホップが{SPI、SI}を必要とし、次ホップが{SPI、SI}を必要とする場合、O、それが次のホップで実行されるSFのインスタンスを選択し、横断するSFPに従ってSPIラベルを設定します、次のホップのSI値にSIラベルを設定し、そのSFIのためのSFFにパケットをトンネルします。"
    },
    {
      "indent": 3,
      "text": "o If the current hop requires an {SPI, SI} and the next hop requires a {context label, SFI Label}, it pops the {SPI, SI} from the top of the MPLS label stack and tunnels the packet to the SFF indicated by the context label.",
      "ja": "現在のホップが{SPI、SI}、次のホップが必要{コンテキストラベルを、SFIラベル}を必要とする場合、Oは、MPLSラベルスタックの最上部から{SPI、SIを}ポップと示さSFFにパケットをトンネリングコンテキストラベルによります。"
    },
    {
      "indent": 3,
      "text": "o If the current hop requires a {context label, SFI Label}, it pops the {context label, SFI Label} from the top of the MPLS label stack.",
      "ja": "現在のホップが{コンテキストラベル、SFIラベル}を必要とする場合、Oは、MPLSラベルスタックの先頭から{コンテキストラベル、SFIラベル}ポップ。"
    },
    {
      "indent": 6,
      "text": "* If the new top of the MPLS label stack contains an {SPI, SI} label pair, it selects an SFI to use at the next hop and tunnels the packet to the SFF for that SFI.",
      "ja": "MPLSラベルスタックの新しいトップ{SPI、SI}ラベルのペアが含まれている場合*は、次のホップで使用するSFIを選択し、そのSFIのためのSFFにパケットをトンネルします。"
    },
    {
      "indent": 6,
      "text": "* If the new top of the MPLS label stack contains a {context label, SFI Label}, it tunnels the packet to the SFF indicated by the context label.",
      "ja": "MPLSラベルスタックの新しいトップ{コンテキストラベル、SFIラベル}が含まれている場合*は、コンテキスト・ラベルで示さSFFにパケットをトンネルします。"
    },
    {
      "indent": 0,
      "text": "9. A Note on Service Function Capabilities and SFC Proxies",
      "section_title": true,
      "ja": "9.サービス機能の機能とSFCプロキシ上の注意事項"
    },
    {
      "indent": 3,
      "text": "The concept of an \"SFC proxy\" is introduced in [RFC7665]. An SFC proxy is logically located between an SFF and an SFI that is not \"SFC aware\". Such SFIs are not capable of handling the SFC encapsulation (whether that be NSH or MPLS) and need the encapsulation stripped from the packets they are to process. In many cases, legacy SFIs that were once deployed as \"bumps in the wire\" fit into this category until they have been upgraded to be SFC aware.",
      "ja": "「SFCプロキシ」の概念は、[RFC7665]で導入されます。 SFCプロキシは、論理的にSFFと「SFC対応」ではありませんSFIとの間に位置しています。そのようなSFISはSFCカプセル化を扱うことができない（すなわち、NSHまたはMPLSあるかどうか）、それらが処理するようにしているパケットから剥離カプセル化を必要とします。彼らは意識SFCようにアップグレードされるまで、多くの場合、一度「ワイヤでバンプ」として展開されたレガシーSFISはこのカテゴリーに収まります。"
    },
    {
      "indent": 3,
      "text": "The job of an SFC proxy is to remove and then reimpose SFC encapsulation so that the SFF is able to process as though it was communication with an SFC-aware SFI, and so that the SFI is unaware of the SFC encapsulation. In this regard, the job of an SFC proxy is no different when NSH encapsulation is used and when MPLS encapsulation is used as described in this document, although (of course) it is different encapsulation bytes that must be removed and reimposed.",
      "ja": "SFCプロキシのジョブを削除し、SFFは、それがSFC対応SFIとの通信であり、SFIはSFCカプセル化を知らないようかのように処理することができるように、SFCカプセル化をreimposeすることです。 NSHカプセル化を使用した場合、この文書に記載されているように、それが除去されreimposedされなければならない異なるカプセル化バイトである（もちろん）がMPLSカプセル化が使用される場合、この点に関して、SFCプロキシの役割は異なっていません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the SFC proxy is a logical function. It could be implemented as a separate physical component on the path from the SFF to the SFI, but it could be co-resident with the SFF or it could be a component of the SFI. This is purely an implementation choice.",
      "ja": "SFCプロキシが論理的な機能であることに留意すべきです。これは、SFIのSFFからの経路上の別の物理コンポーネントとして実装することができ、それはSFFと共存することができ、またはそれはSFIのコンポーネントとすることができます。これは純粋な実装の選択です。"
    },
    {
      "indent": 3,
      "text": "Note also that the delivery of metadata (see Section 12) requires specific processing if an SFC proxy is in use. This is also no different when NSH functionality or the MPLS encoding defined in this document is in use, and how it is handled will depend on how (or if) each non-SFC-aware SFI can receive metadata.",
      "ja": "SFCプロキシが使用中である場合はまた、メタデータ（セクション12を参照）の送達は、特定の処理を必要とすること。 NSH機能又は本書で定義されたMPLSエンコーディングが使用されている場合にも違いはありません、そして、それは（または場合）各非SFC対応SFIは、メタデータを受信することができる方法に依存する処理方法。"
    },
    {
      "indent": 0,
      "text": "10. Control-Plane Considerations",
      "section_title": true,
      "ja": "10.コントロールプレーンの考慮事項"
    },
    {
      "indent": 3,
      "text": "In order that a packet may be forwarded along an SFP, several functional elements must be executed.",
      "ja": "パケットは、SFPに沿って転送することができるようにするために、いくつかの機能要素は、実行されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Discovery/advertisement of SFIs.",
      "ja": "SFISのO発見/広告。"
    },
    {
      "indent": 3,
      "text": "o Computation of the SFP.",
      "ja": "O SFPの計算。"
    },
    {
      "indent": 3,
      "text": "o Programming of classifiers.",
      "ja": "分類のOプログラミング。"
    },
    {
      "indent": 3,
      "text": "o Advertisement of forwarding instructions.",
      "ja": "転送命令のO広告。"
    },
    {
      "indent": 3,
      "text": "Various approaches may be taken. These include a fully centralized model where SFFs report to a central controller the SFIs that they support, the central controller computes the SFP and programs the classifiers, and (if the label-swapping approach is taken) the central controller installs forwarding state in the SFFs that lie on the SFP.",
      "ja": "様々なアプローチが取られてもよいです。これらは、中央コントローラがサポートすることSFISにスキャンフリップフロップレポートは、中央制御装置は、SFPおよびプログラム分類子を計算し、（ラベルスワッピングのアプローチが取られている場合）、中央制御装置は、スキャンフリップフロップの状態を転送インストール完全集中型モデルを含みますSFP上の嘘。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a dynamic control plane may be used, such as that described in [BGP-NSH-SFC]. In this case, the SFFs use the control plane to advertise the SFIs that they support, a central controller computes the SFP and programs the classifiers, and (if the label-swapping approach is taken) the central controller uses the control plane to advertise the SFPs so that SFFs that lie on the SFP can install the necessary forwarding state.",
      "ja": "代替的に、動的制御プレーンは、[BGP-NSH-SFC]に記載されているように、使用することができます。それらがサポートすることを、この場合に、スキャンフリップフロップは、SFISをアドバタイズするために、制御プレーンを使用して、中央コントローラはSFPとプログラム分類子を計算し、（ラベルスワッピングアプローチがとられている場合）、中央制御装置は、宣伝するための制御プレーンを使用しますSFPは、SFP上にあるスキャンフリップフロップは、必要に応じて転送状態をインストールできるように。"
    },
    {
      "indent": 0,
      "text": "11. Use of the Entropy Label",
      "section_title": true,
      "ja": "エントロピーラベルの使用11"
    },
    {
      "indent": 3,
      "text": "Entropy is used in ECMP situations to ensure that packets from the same flow travel down the same path, thus avoiding jitter or reordering issues within a flow.",
      "ja": "エントロピーは、このようにジッタを回避またはフロー内の問題を並べ替え、同じフローからのパケットが同じ道を移動することを保証するために、ECMPの状況で使用されています。"
    },
    {
      "indent": 3,
      "text": "Entropy is often determined by hashing on specific fields in a packet header, such as the \"five-tuple\" in the IP and transport headers. However, when an MPLS label stack is present, the depth of the stack could be too large for some processors to correctly determine the entropy hash. This problem is addressed by the inclusion of an entropy label as described in [RFC6790].",
      "ja": "エントロピーは、多くの場合、IPおよびトランスポートヘッダ内の「5タプル」として、パケットヘッダの特定のフィールドにハッシュすることによって決定されます。 MPLSラベルスタックが存在する場合、いくつかのプロセッサが正しくエントロピーハッシュを決定するためしかし、スタックの深さが大きすぎる可能性があります。 [RFC6790]に記載されているように、この問題は、エントロピーラベルを含めることによって対処されます。"
    },
    {
      "indent": 3,
      "text": "When entropy is desired for packets as they are carried in MPLS tunnels over the underlay network, it is RECOMMENDED that an entropy label be included in the label stack immediately after the tunnel labels and before the SFC Labels, as shown in Figures 2 and 3.",
      "ja": "エントロピーは、それらがアンダーレイネットワーク上のMPLSトンネルで搬送されるパケットのために望まれる場合には、図2及び図3に示すように、エントロピーラベルは、直ちにトンネルラベル後及びSFCラベルの前にラベルスタックに含まれることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "If an entropy label is present in an MPLS payload, it is RECOMMENDED that the initial classifier use that value in an entropy label inserted in the label stack when the packet is forwarded (on the first tunnel) to the first SFF. In this case, it is not necessary to remove the entropy label from the payload.",
      "ja": "エントロピーラベルは、MPLSペイロードに存在する場合、パケットが転送されるときに初期分類器は、最初のSFF（第1トンネルで）ラベルスタックに挿入されたエントロピーラベルにその値を使用することをお勧めします。この場合には、ペイロードからエントロピーラベルを除去する必要はありません。"
    },
    {
      "indent": 0,
      "text": "12. Metadata",
      "section_title": true,
      "ja": "12.メタデータ"
    },
    {
      "indent": 3,
      "text": "Metadata is defined in [RFC7665] as providing \"the ability to exchange context information between classifiers and SFs, and among SFs.\" [RFC8300] defines how this context information can be directly encoded in fields that form part of the NSH encapsulation.",
      "ja": "メタデータを提供するように[RFC7665]で定義され、「分類およびSFS、およびSFSのうちの間でコンテキスト情報を交換する機能。」 [RFC8300]は、このコンテキスト情報は、直接的NSHカプセル化の一部を形成するフィールドで符号化することができる方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Sections 12.1 and 12.2 describe how metadata is associated with user data packets, and how metadata may be exchanged between SFC nodes in the network, when using an MPLS encoding of the logical representation of the NSH.",
      "ja": "セクション12.1および12.2は、メタデータは、ユーザ・データ・パケットに関連付けられ、及びNSHの論理表現のMPLS符号化を使用する場合どのようにメタデータが、ネットワーク内のSFCノードの間で交換することができる方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the MPLS encoding is less functional than the direct use of the NSH. Both methods support metadata that is \"per-SFP\" or \"per-flow\" (see [RFC8393] for definitions of these terms), but \"per-packet\" metadata (where the metadata must be carried on each packet because it differs from one packet to the next even on the same flow or SFP) is only supported using the NSH and not using the mechanisms defined in this document.",
      "ja": "MPLS符号化がNSHの直接使用より少ない機能的であることに留意すべきです。両方の方法は、それが異なるため、メタデータは、各パケットに対して実行されなければならない「パケットごとの」メタデータ（または「-SFPあたり」「フロー毎」（これらの用語の定義については、[RFC8393]を参照）メタデータをサポートするが、同じフローまたはSFPの次に1つのパケット）のみNSHを使用してサポートし、この文書で定義されたメカニズムを使用していません。"
    },
    {
      "indent": 0,
      "text": "12.1. Indicating Metadata in User Data Packets",
      "section_title": true,
      "ja": "12.1. ユーザーデータパケットに示すメタデータ"
    },
    {
      "indent": 3,
      "text": "Metadata is achieved in the MPLS realization of the logical NSH by the use of an SFC Metadata Label, which uses the extended special-purpose label construct [RFC7274]. Thus, three label stack entries are present, as shown in Figure 4:",
      "ja": "メタデータは、[RFC7274]を構築拡張専用のラベルを使用するSFCメタデータラベルの使用によって論理NSHのMPLS実現で達成されます。図4に示すような三のラベルスタックエントリは、存在しています。"
    },
    {
      "indent": 3,
      "text": "o The Extension Label (value 15).",
      "ja": "O拡張ラベル（値15）。"
    },
    {
      "indent": 3,
      "text": "o An extended special-purpose label called the Metadata Label Indicator (MLI) (value 16).",
      "ja": "O拡張専用のラベルには、メタデータラベルインジケータ（MLI）（値16）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o The Metadata Label (ML).",
      "ja": "メタデータ・ラベル（ML）O。"
    },
    {
      "indent": 29,
      "text": " ----------------\n| Extension = 15 |\n+----------------+\n|      MLI       |\n+----------------+\n| Metadata Label |\n ----------------",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 4: The MPLS SFC Metadata Label",
      "ja": "図4：MPLS SFCメタデータラベル"
    },
    {
      "indent": 3,
      "text": "The Metadata Label value is an index into a table of metadata that is programmed into the network using in-band or out-of-band mechanisms. Out-of-band mechanisms potentially include management-plane and control-plane solutions (such as [BGP-NSH-SFC]) but are out of scope for this document. The in-band mechanism is described in Section 12.2.",
      "ja": "メタデータラベルの値は、インバンドまたはアウトオブバンドメカニズムを使用してネットワークにプログラムされたメタデータのテーブルへのインデックスです。アウトオブバンドメカニズムは、潜在的に（例えば、[BGP-NSH-SFC]など）管理プレーンとコントロールプレーンソリューションが含まれるが、この文書の範囲外です。インバンド・メカニズムは、セクション12.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "The SFC Metadata Label (as a set of three labels as indicated in Figure 4) may be present zero, one, or more times in an MPLS SFC packet. For MPLS label swapping, the SFC Metadata Labels are placed immediately after the basic unit of MPLS label stack for SFC, as shown in Figure 5. For MPLS label stacking, the SFC Metadata Labels are placed at the bottom of the label stack, as shown in Figure 6.",
      "ja": "（図4に示すように、3つのラベルのセットなど）SFCメタデータラベルは、MPLS SFCパケットに存在するゼロ、1つ、または複数回であってもよいです。示されるようにMPLSラベルスタックは、図5に示すように、MPLSラベルスワッピングのために、SFCメタデータ・ラベルは、SFCのためのMPLSラベルスタックの基本単位の直後に配置され、SFCメタデータ・ラベルは、ラベルスタックの底部に配置されています図6インチ"
    },
    {
      "indent": 27,
      "text": " ----------------\n~ Tunnel Labels  ~\n+----------------+\n~   Optional     ~\n~ Entropy Label  ~\n+----------------+\n|   SPI Label    |\n+----------------+\n|   SI Label     |\n+----------------+\n| Extension = 15 |\n+----------------+\n|     MLI        |\n+----------------+\n| Metadata Label |\n+----------------+\n~     Other      ~\n|    Metadata    |\n~  Label Triples ~\n+----------------+\n|                |\n~    Payload     ~\n|                |\n ----------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 5: The MPLS SFC Label Stack for Label Swapping with Metadata Label",
      "ja": "図5：メタデータラベルとラベルスワッピングのためのMPLS SFCのラベルスタック"
    },
    {
      "indent": 26,
      "text": " -------------------\n~   Tunnel Labels   ~\n+-------------------+\n~     Optional      ~\n~   Entropy Label   ~\n+-------------------+\n| SFC Context Label |\n+-------------------+\n|     SF Label      |\n+-------------------+\n~                   ~\n+-------------------+\n| SFC Context Label |\n+-------------------+\n|     SF Label      |\n+-------------------+\n|   Extension = 15  |\n+-------------------+\n|        MLI        |\n+-------------------+\n|  Metadata Label   |\n+-------------------+\n~       Other       ~\n|      Metadata     |\n~   Label Triples   ~\n+-------------------+\n|                   |\n~      Payload      ~\n|                   |\n -------------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 6: The MPLS SFC Label Stack for Label Stacking with Metadata Label",
      "ja": "図6：MPLS SFCのラベルスタックラベルのメタデータラベルとスタッキング"
    },
    {
      "indent": 0,
      "text": "12.2. In-Band Programming of Metadata",
      "section_title": true,
      "ja": "12.2. メタデータのインバンドプログラミング"
    },
    {
      "indent": 3,
      "text": "A mechanism for sending metadata associated with an SFP without a payload packet is described in [RFC8393]. The same approach can be used in an MPLS network where the NSH is logically represented by an MPLS label stack.",
      "ja": "ペイロードパケットなしSFPに関連付けられたメタデータを送信するためのメカニズムは、[RFC8393]に記載されています。同じアプローチがNSHが論理的にMPLSラベルスタックによって表されるMPLSネットワークで使用することができます。"
    },
    {
      "indent": 3,
      "text": "The packet header is formed exactly as previously described in this document so that the packet will follow the SFP through the SFC network. However, instead of payload data, metadata is included after the bottom of the MPLS label stack. An extended special-purpose label is used to indicate that the metadata is present. Thus, three label stack entries are present:",
      "ja": "パケットヘッダは、パケットがSFCネットワークを介してSFPに追従するように、正確に、先に本書では説明形成されています。しかし、代わりに、ペイロードデータの、メタデータは、MPLSラベルスタックの最下部の後に含まれています。拡張された専用のラベルは、メタデータが存在していることを示すために使用されます。このように、3つのラベルスタックエントリが存在します。"
    },
    {
      "indent": 3,
      "text": "o The Extension Label (value 15).",
      "ja": "O拡張ラベル（値15）。"
    },
    {
      "indent": 3,
      "text": "o An extended special-purpose label called the Metadata Present Indicator (MPI) (value 17).",
      "ja": "O拡張専用のラベルは、メタデータの現在のインジケータ（MPI）（値17）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o The Metadata Label (ML) that is associated with this metadata on this SFP and can be used to indicate the use of the metadata as described in Section 12.",
      "ja": "このSFPにこのメタデータに関連付けられている、セクション12で説明したように、メタデータの使用を示すために使用することができるメタデータラベル（ML）O。"
    },
    {
      "indent": 3,
      "text": "The MPI, if present, is placed immediately after the last basic unit of MPLS label stack for SFC. The resultant label stacks are shown in Figure 7 for the MPLS label-swapping case and Figure 8 for the MPLS label-stacking case.",
      "ja": "MPIは、存在する場合、SFCのためのMPLSラベルスタックの最後の基本単位の直後に配置されます。得られたラベルスタックは、MPLSラベルスワッピングケースとMPLSラベルスタッキング場合については、図8は、図7に示されています。"
    },
    {
      "indent": 29,
      "text": " ---------------\n~ Tunnel Labels ~\n+---------------+\n~   Optional    ~\n~ Entropy Label ~\n+---------------+\n|   SPI Label   |\n+---------------+\n|   SI Label    |\n+---------------+\n| Extension = 15|\n+---------------+\n|     MPI       |\n+---------------+\n| Metadata Label|\n+---------------+\n|               |\n~    Metadata   ~\n|               |\n ---------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 7: The MPLS SFC Label Stack for Label Swapping Carrying Metadata",
      "ja": "図7：メタデータキャリングラベルスワッピングのためのMPLSラベルスタックSFC"
    },
    {
      "indent": 27,
      "text": " -------------------\n~   Tunnel Labels   ~\n+-------------------+\n~     Optional      ~\n~   Entropy Label   ~\n+-------------------+\n| SFC Context Label |\n+-------------------+\n|     SF Label      |\n+-------------------+\n| SFC Context Label |\n+-------------------+\n|     SF Label      |\n+-------------------+\n~                   ~\n+-------------------+\n| SFC Context Label |\n+-------------------+\n|     SF Label      |\n+-------------------+\n|   Extension = 15  |\n+-------------------+\n|        MPI        |\n+-------------------+\n|  Metadata Label   |\n+-------------------+\n|                   |\n~    Metadata       ~\n|                   |\n -------------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 8: The MPLS SFC Label Stack for Label Stacking Carrying Metadata",
      "ja": "図8：MPLSラベルスタックSFCラベルのスタッキングのためのメタデータキャリング"
    },
    {
      "indent": 3,
      "text": "In both cases, the metadata is formatted as a TLV, as shown in Figure 9.",
      "ja": "図9に示すように、両方の場合において、メタデータは、TLVとしてフォーマットされます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Length              |        Metadata Type          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                         Metadata                              ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 9: The Metadata TLV",
      "ja": "図9：メタデータTLV"
    },
    {
      "indent": 3,
      "text": "The fields of this TLV are interpreted as follows:",
      "ja": "次のようにこのTLVのフィールドが解釈されます。"
    },
    {
      "indent": 3,
      "text": "Length: The length of the metadata carried in the Metadata field in octets, not including any padding.",
      "ja": "長さ：任意の詰め物を含まない、オクテット単位でのメタデータフィールドで運ばれたメタデータの長さ。"
    },
    {
      "indent": 3,
      "text": "Metadata Type: The type of the metadata present. Values for this field are taken from the \"NSH MD Types\" registry maintained by IANA and defined in [RFC8300] and encoded with the most significant bit first.",
      "ja": "メタデータタイプ：メタデータの存在のタイプ。このフィールドの値は、「NSH MDタイプ」レジストリIANAによって維持され、[RFC8300]で定義されており、最初の最上位ビットでエンコードから取得されます。"
    },
    {
      "indent": 3,
      "text": "Metadata: The actual metadata formatted as described in whatever document defines the metadata. This field is end-padded with zero to 3 octets of zeroes to take it up to a 4-octet boundary.",
      "ja": "メタデータ：メタデータを定義するどの文書に記載されているようにフォーマットされた実際のメタデータ。このフィールドは、4オクテット境界にそれを取るために、エンド詰めゼロのゼロ3オクテットです。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Loss of In-Band Metadata",
      "section_title": true,
      "ja": "12.2.1. インバンドメタデータの損失"
    },
    {
      "indent": 3,
      "text": "Note that in-band exchange of metadata is vulnerable to packet loss. This is both a risk arising from network faults and an attack vulnerability.",
      "ja": "帯域内のメタデータの交換がパケットロスに対して脆弱であることに注意してください。これは、ネットワーク障害や攻撃の脆弱性に起因するリスクの両方です。"
    },
    {
      "indent": 3,
      "text": "If packets that arrive at an SFF use an MLI that does not have an entry in the metadata table, an alarm can be raised and the packet can be discarded or processed without the metadata according to local configuration. This provides some long-term mitigation but is not an ideal solution.",
      "ja": "SFFに到着したパケットは、メタデータテーブル内のエントリを持っていませんMLIを使用する場合は、ローカル設定に応じてアラームが発生することができ、パケットは、メタデータなしで廃棄されるか、または処理することができます。これは、いくつかの長期的な緩和策を提供しますが、理想的なソリューションではありません。"
    },
    {
      "indent": 3,
      "text": "Further mitigation of loss of metadata packets can be achieved by retransmitting them at a configurable interval. This is a relatively cheap, but only partial, solution because there may still be a window during which the metadata has not been received.",
      "ja": "メタデータパケットの損失の更なる緩和が設定可能な間隔でそれらを再送信することによって達成することができます。まだメタデータを受信して​​いない時に窓があるかもしれないので、これは比較的安価で、しかし、部分的にしか、解決策です。"
    },
    {
      "indent": 3,
      "text": "The concern of lost metadata may be particularly important when the metadata applicable to a specific MPI is being changed. This could result in out-of-date metadata being applied to a packet. If this is a concern, it is RECOMMENDED that a new MPI be used to install a new entry in the metadata table, and the packets in the flow should be marked with the equivalent new MLI.",
      "ja": "特定のMPIに適用できるメタデータが変更されたときに失われたメタデータの懸念が特に重要であるかもしれません。これは、パケットに適用されている期限切れのメタデータにつながる可能性があります。これが懸念される場合は、新しいMPIは、メタデータテーブルに新しいエントリをインストールするために使用することをお勧めして、フロー内のパケットは、同等の新しいMLIでマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, if an application that requires metadata is sensitive to this potential loss or attack, it SHOULD NOT use in-band metadata distribution but SHOULD rely on control-plane or management-plane mechanisms, because these approaches can use a more sophisticated protocol that includes confirmation of delivery and can perform verification or inspection of entries in the metadata table.",
      "ja": "最後にメタデータを必要とするアプリケーションは、この潜在的な損失や攻撃に敏感であれば、それは、帯域内のメタデータの分布を使用するべきではなく、これらのアプローチが含まれ、より洗練されたプロトコルを使用することができますので、コントロールプレーンや管理プレーンのメカニズムに依存しているべきです配信の確認とは、メタデータテーブルのエントリの確認や検査を行うことができます。"
    },
    {
      "indent": 0,
      "text": "13. Worked Examples",
      "section_title": true,
      "ja": "13.従事例"
    },
    {
      "indent": 3,
      "text": "This section reverts to the simplified descriptions of networks that rely wholly on label swapping or label stacking. As described in Section 4, actual deployment scenarios may depend on the use of both mechanisms and utilize a mixed mode as described in Section 8.",
      "ja": "このセクションでは、ラベルスワッピングまたはラベルのスタッキングに完全に依存しているネットワークの単純化された説明に戻ります。セクション4で説明したように、実際の展開シナリオは、両方のメカニズムの使用に依存してもよいし、セクション8に記載されているように、混合モードを利用します。"
    },
    {
      "indent": 3,
      "text": "Consider the simplistic MPLS SFC overlay network shown in Figure 10. A packet is classified for an SFP that will see it pass through two SFs (SFa and SFb) that are accessed through two SFFs (SFFa and SFFb, respectively). The packet is ultimately delivered to the destination, D.",
      "ja": "パケットは、それが2つのスキャンフリップフロップ（SFFaとSFFb、それぞれ）を介してアクセスされる2つのSF（SFA及びSFB）を通過表示されるSFPに分類され、図10に示す単純MPLS SFCオーバーレイネットワークを考えます。パケットは、最終的に目的地、Dに配信されます"
    },
    {
      "indent": 7,
      "text": "     +---------------------------------------------------+\n     |                   MPLS SFC Network                |\n     |                                                   |\n     |            +---------+       +---------+          |\n     |            |   SFa   |       |   SFb   |          |\n     |            +----+----+       +----+----+          |\n     |               ^ | |             ^ | |             |\n     |            (2)| | |(3)       (5)| | |(6)          |\n     |       (1)     | | V     (4)     | | V    (7)      |\n+----------+ ---> +----+----+ ----> +----+----+ ---> +-------+\n|Classifier+------+  SFFa   +-------+  SFFb   +------+   D   |\n+----------+      +---------+       +---------+      +-------+\n     |                                                   |\n     +---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 10: Service Function Chaining in an MPLS Network",
      "ja": "図10：MPLSネットワークにおけるサービス機能の連鎖"
    },
    {
      "indent": 3,
      "text": "Let us assume that the SFP is computed and assigned an SPI value of 239. The forwarding details of the SFP are distributed (perhaps using the mechanisms of [BGP-NSH-SFC]) so that the SFFs are programmed with the necessary forwarding instructions.",
      "ja": "私たちはSFPがスキャンフリップフロップが必要転送命令でプログラムされるように、SFPの転送の詳細は（おそらく[BGP-NSH-SFC]のメカニズムを使用して）分配される計算及び239のSPI値が割り当てられていると仮定する。"
    },
    {
      "indent": 3,
      "text": "The packet progresses as follows:",
      "ja": "次のようにパケットが進行します："
    },
    {
      "indent": 3,
      "text": "1. The classifier assigns the packet to the SFP and imposes two label stack entries comprising a single basic unit of MPLS SFC representation:",
      "ja": "1分類器は、SFPにパケットを割り当て、MPLS SFC表現の1つの基本ユニットを含む二ラベルスタックエントリを課します。"
    },
    {
      "indent": 7,
      "text": "*  The higher label stack entry contains a label carrying the SPI\n   value of 239.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* The lower label stack entry contains a label carrying the SI value of 255.",
      "ja": "*下のラベルスタックエントリーは255のSI値を運ぶラベルが含まれています。"
    },
    {
      "indent": 7,
      "text": "Further labels may be imposed to tunnel the packet from the classifier to SFFa.",
      "ja": "さらに、ラベルはSFFaにクラシファイアからトンネルにパケットを課してもよいです。"
    },
    {
      "indent": 3,
      "text": "2. When the packet arrives at SFFa, SFFa strips any labels associated with the tunnel that runs from the classifier to SFFa. SFFa examines the top labels and matches the SPI/SI to identify that the packet should be forwarded to SFa. The packet is forwarded to SFa unmodified.",
      "ja": "2.パケットがSFFaに到着すると、SFFaは、分類からSFFaに実行トンネルに関連付けられた任意のラベルを取り除き。 SFFaは、トップラベルを調べて、パケットがSFAに転送する必要があることを識別するために、SPI / SIと一致します。パケットが変更されていないSFAに転送されます。"
    },
    {
      "indent": 3,
      "text": "3. SFa performs its designated function and returns the packet to SFFa.",
      "ja": "3. SFAは、その指定された機能を実行し、SFFaにパケットを返します。"
    },
    {
      "indent": 3,
      "text": "4. SFFa modifies the SI in the lower label stack entry (to 254) and uses the SPI/SI to look up the forwarding instructions. It sends the packet with two label stack entries:",
      "ja": "4. SFFaは、（254）下部ラベルスタックエントリにSIを変更し、転送命令をルックアップするためにSPI / SIを使用します。これは、2つのラベルスタックエントリを持つパケットを送信します。"
    },
    {
      "indent": 7,
      "text": "*  The higher label stack entry contains a label carrying the SPI\n   value of 239.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* The lower label stack entry contains a label carrying the SI value of 254.",
      "ja": "*下のラベルスタックエントリーは254のSI値を運ぶラベルが含まれています。"
    },
    {
      "indent": 7,
      "text": "Further labels may be imposed to tunnel the packet from SFFa to SFFb.",
      "ja": "さらに、ラベルはSFFbにSFFaからトンネルにパケットを課してもよいです。"
    },
    {
      "indent": 3,
      "text": "5. When the packet arrives at SFFb, SFFb strips any labels associated with the tunnel from SFFa. SFFb examines the top labels and matches the SPI/SI to identify that the packet should be forwarded to SFb. The packet is forwarded to SFb unmodified.",
      "ja": "前記パケットがSFFbに到着すると、SFFbはSFFaからトンネルに関連する任意のラベルを取り除き。 SFFbは、トップラベルを調べて、パケットがSFBに転送する必要があることを識別するために、SPI / SIと一致します。パケットが変更されていないSFBに転送されます。"
    },
    {
      "indent": 3,
      "text": "6. SFb performs its designated function and returns the packet to SFFb.",
      "ja": "6. SFBは、その指定された機能を実行し、SFFbにパケットを返します。"
    },
    {
      "indent": 3,
      "text": "7. SFFb modifies the SI in the lower label stack entry (to 253) and uses the SPI/SI to look up the forwarding instructions. It determines that it is the last SFF in the SFP, so it strips the two SFC Label stack entries and forwards the payload toward D using the payload protocol.",
      "ja": "7. SFFbは（253）下のラベルスタックエントリーでSIを修正し、転送命令をルックアップするためにSPI / SIを使用しています。それはSFP内の最後のSFFであると判断し、それは、二つのSFCラベルスタックエントリを取り除き、ペイロードプロトコルを使用してDに向かってペイロードを転送します。"
    },
    {
      "indent": 3,
      "text": "Alternatively, consider the MPLS SFC overlay network shown in Figure 11. A packet is classified for an SFP that will see it pass through two SFs (SFx and SFy) that are accessed through two SFFs (SFFx and SFFy, respectively). The packet is ultimately delivered to the destination, D.",
      "ja": "代替的に、パケットは、それが2つのスキャンフリップフロップ（SFFxとSFFy、それぞれ）を介してアクセスされる2つのSF（SFxのとSFY）を通過表示されるSFPのために分類され、図11に示すMPLS SFCオーバーレイネットワークを考えます。パケットは、最終的に目的地、Dに配信されます"
    },
    {
      "indent": 6,
      "text": "     +---------------------------------------------------+\n     |                   MPLS SFC Network                |\n     |                                                   |\n     |            +---------+       +---------+          |\n     |            |   SFx   |       |   SFy   |          |\n     |            +----+----+       +----+----+          |\n     |               ^ | |             ^ | |             |\n     |            (2)| | |(3)       (5)| | |(6)          |\n     |       (1)     | | V     (4)     | | V    (7)      |\n+----------+ ---> +----+----+ ----> +----+----+ ---> +-------+\n|Classifier+------+  SFFx   +-------+  SFFy   +------+   D   |\n+----------+      +---------+       +---------+      +-------+\n     |                                                   |\n     +---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 11: Service Function Chaining Using MPLS Label Stacking",
      "ja": "図11：サービス機能の連鎖MPLSラベルスタックを使用します"
    },
    {
      "indent": 3,
      "text": "Let us assume that the SFP is computed and assigned an SPI value of 239. However, the forwarding state for the SFP is not distributed and installed in the network. Instead, it will be attached to the individual packets using the MPLS label stack.",
      "ja": "私たちは、SFPはSFPの転送状態をネットワークで配布され、インストールされていない、しかし、239のSPI値を計算し、割り当てられていると仮定しよう。その代わりに、MPLSラベルスタックを使用して、個々のパケットに添付されます。"
    },
    {
      "indent": 3,
      "text": "The packet progresses as follows:",
      "ja": "次のようにパケットが進行します："
    },
    {
      "indent": 3,
      "text": "1. The classifier assigns the packet to the SFP and imposes two basic units of MPLS SFC representation to describe the full SFP:",
      "ja": "1分類器は、SFPにパケットを割り当て、完全なSFPを記述するためにMPLS SFC表現の二つの基本的な単位を課します。"
    },
    {
      "indent": 7,
      "text": "*  The top basic unit comprises two label stack entries as\n   follows:",
      "raw": true
    },
    {
      "indent": 10,
      "text": "+ The higher label stack entry contains a label carrying the SFC context.",
      "ja": "+高いラベルスタックエントリは、SFCのコンテキストを運ぶラベルが含まれています。"
    },
    {
      "indent": 10,
      "text": "+ The lower label stack entry contains a label carrying the SF indicator for SFx.",
      "ja": "+下のラベルスタックエントリはSFxのためのSFインジケータを運ぶラベルが含まれています。"
    },
    {
      "indent": 7,
      "text": "* The lower basic unit comprises two label stack entries as follows:",
      "ja": "次のように*下の基本ユニットは、2つのラベルスタックエントリーを含みます："
    },
    {
      "indent": 10,
      "text": "+ The higher label stack entry contains a label carrying the SFC context.",
      "ja": "+高いラベルスタックエントリは、SFCのコンテキストを運ぶラベルが含まれています。"
    },
    {
      "indent": 10,
      "text": "+ The lower label stack entry contains a label carrying the SF indicator for SFy.",
      "ja": "+下のラベルスタックエントリはSFYのためのSFインジケータを運ぶラベルが含まれています。"
    },
    {
      "indent": 7,
      "text": "Further labels may be imposed to tunnel the packet from the classifier to SFFx.",
      "ja": "さらに、ラベルはSFFxにクラシファイアからトンネルにパケットを課してもよいです。"
    },
    {
      "indent": 3,
      "text": "2. When the packet arrives at SFFx, SFFx strips any labels associated with the tunnel from the classifier. SFFx examines the top labels and matches the context/SF values to identify that the packet should be forwarded to SFx. The packet is forwarded to SFx unmodified.",
      "ja": "2.パケットがSFFxに到着すると、SFFxは、分類からトンネルに関連する任意のラベルを取り除き。 SFFxは、トップラベルを調べて、パケットがSFxのに転送する必要があることを識別するために、コンテキスト/ SF値と一致しました。パケットが変更されていないSFxのに転送されます。"
    },
    {
      "indent": 3,
      "text": "3. SFx performs its designated function and returns the packet to SFFx.",
      "ja": "3. SFxのは、その指定された機能を実行し、SFFxにパケットを返します。"
    },
    {
      "indent": 3,
      "text": "4. SFFx strips the top basic unit of MPLS SFC representation, revealing the next basic unit. It then uses the revealed context/SF values to determine how to route the packet to the next SFF, SFFy. It sends the packet with just one basic unit of MPLS SFC representation comprising two label stack entries:",
      "ja": "4. SFFxは、次の基本単位を明らかに、MPLS SFC表現のトップ基本単位ストリップ。その後、どのように次のSFF、SFFyへパケットをルーティングするかを決定するために/ SF値を明らかにしたコンテキストを使用しています。これは、2つのラベルスタックエントリーを備えたMPLS SFC表現のただ一つの基本単位でパケットを送信します。"
    },
    {
      "indent": 7,
      "text": "*  The higher label stack entry contains a label carrying the SFC\n   context.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* The lower label stack entry contains a label carrying the SF indicator for SFy.",
      "ja": "*下のラベルスタックエントリはSFYのためのSFインジケータを運ぶラベルが含まれています。"
    },
    {
      "indent": 7,
      "text": "Further labels may be imposed to tunnel the packet from SFFx to SFFy.",
      "ja": "さらに、ラベルはSFFyにSFFxからトンネルにパケットを課してもよいです。"
    },
    {
      "indent": 3,
      "text": "5. When the packet arrives at SFFy, SFFy strips any labels associated with the tunnel from SFFx. SFFy examines the top labels and matches the context/SF values to identify that the packet should be forwarded to SFy. The packet is forwarded to SFy unmodified.",
      "ja": "前記パケットがSFFyに到着すると、SFFyはSFFxからトンネルに関連する任意のラベルを取り除き。 SFFyは、トップラベルを調べて、パケットがSFYに転送する必要があることを識別するために、コンテキスト/ SF値と一致しました。パケットが変更されていないSFYに転送されます。"
    },
    {
      "indent": 3,
      "text": "6. SFy performs its designated function and returns the packet to SFFy.",
      "ja": "6. SFYは、その指定された機能を実行し、SFFyにパケットを返します。"
    },
    {
      "indent": 3,
      "text": "7. SFFy strips the top basic unit of MPLS SFC representation, revealing the payload packet. It forwards the payload toward D using the payload protocol.",
      "ja": "7. SFFyは、ペイロードパケットを明らかにし、MPLS SFC表現のトップ基本単位ストリップ。これは、ペイロードプロトコルを使用してDに向かってペイロードを転送します。"
    },
    {
      "indent": 0,
      "text": "14. Implementation Notes",
      "section_title": true,
      "ja": "14.実装の注意事項"
    },
    {
      "indent": 3,
      "text": "It is not the job of an IETF specification to describe the internals of an implementation, except where that directly impacts upon the bits on the wire that change the likelihood of interoperability or where the availability of configuration or security options directly affects the utility of an implementation.",
      "ja": "実装の内部を説明するためのIETF仕様の仕事ではない、場合を除き、相互運用性の可能性を変更するワイヤ上のビットにその直接影響または構成またはセキュリティオプションの可用性を直接実装の有用性に影響を与える場合。"
    },
    {
      "indent": 3,
      "text": "However, in view of the objective of this document to acknowledge that there may be a need for an interim deployment of SFC functionality in brownfield MPLS networks, this section provides some observations about how an SFF might utilize MPLS features that are available in existing routers. This section is not intended to be definitive or technically complete; rather, it is indicative.",
      "ja": "しかし、この文書の目的の観点から、ブラウンフィールドMPLSネットワークにおけるSFC機能の暫定配備する必要があるかもしれないことを確認するために、このセクションでは、SFFは、既存のルータで使用可能なMPLS機能を利用する方法をについていくつかの観察を提供します。このセクションでは、決定的または技術的に完全であることを意図したものではありません。むしろ、それが指標となります。"
    },
    {
      "indent": 3,
      "text": "Consider the mechanism used to indicate to which Virtual Routing and Forwarding (VRF) system an incoming MPLS packet should be routed in a Layer 3 Virtual Private Network (L3VPN) [RFC4364]. In this case, the top MPLS label is an indicator of the VRF system that is to be used to route the payload.",
      "ja": "着信MPLSパケットは、レイヤ3仮想プライベートネットワーク（L3VPN）[RFC4364]にルーティングされるべき仮想ルーティングおよび転送（VRF）システムに知らせるために使用されるメカニズムを考えてみましょう。この場合、上部MPLSラベルがルートペイロードに使用されるVRF系の指標です。"
    },
    {
      "indent": 3,
      "text": "A similar approach can be taken with the label-swapping SFC technique described in Section 6 such that the SFC Context Label identifies a routing table specific to the SFP. The SF Label can be looked up in the context of this routing table to determine to which SF to direct the packet and how to forward it to the next SFF.",
      "ja": "同様のアプローチは、SFCコンテキストラベルがSFPに特定のルーティングテーブルを識別するように、第6節に記載のラベルスワップSFC技法で撮影することができます。 SFラベルはSFのパケットとどのように次のSFFに転送するに指示するためにするのかを判定するために、このルーティングテーブルのコンテキスト内で検索することができます。"
    },
    {
      "indent": 3,
      "text": "Advanced features (such as metadata) are not inspected by SFFs. The packets are passed to SFIs that are MPLS-SFC aware or to SFC proxies, and those components are responsible for handling all metadata issues.",
      "ja": "（メタデータなど）の高度な機能は、スキャンフリップフロップによって検査されていません。パケットがMPLS-SFC対応またはにSFCプロキシですSFISに渡され、これらのコンポーネントは、すべてのメタデータの問題を処理する責任があります。"
    },
    {
      "indent": 3,
      "text": "Of course, an actual implementation might make considerable optimizations on this approach, but this section should provide hints about how MPLS-based SFC might be achieved with relatively small modifications to deployed MPLS devices.",
      "ja": "もちろん、実際の実装は、このアプローチにはかなりの最適化を行うことがありますが、このセクションでは、MPLSベースのSFCが展開MPLSデバイスへの比較的小さな変更で達成されるかもしれない方法についてのヒントを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. Security Considerations",
      "section_title": true,
      "ja": "15.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Discussion of the security properties of SFC networks can be found in [RFC7665]. Further security discussion for the NSH and its use is provided in [RFC8300]. Those documents provide analysis and present a set of requirements and recommendations for security, and the normative security requirements from those documents apply to this specification. However, it should be noted that those documents do not describe any mechanisms for securing NSH systems.",
      "ja": "SFCネットワークのセキュリティプロパティの議論は[RFC7665]で見つけることができます。 NSHおよびその使用のためのさらなるセキュリティの議論は[RFC8300]で提供されています。これらの文書は、分析を提供し、セキュリティのための要件と推奨事項のセットを提示し、それらの文書から規範的なセキュリティ要件は、この仕様に適用されます。しかし、それらの文書は、NSHシステムを確保するための任意のメカニズムを説明していないことに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "It is fundamental to the SFC design that the classifier is a fully trusted element. That is, the classification decision process is not visible to the other elements, and its output is treated as accurate. As such, the classifier has responsibility for determining the processing that the packet will be subject to, including, for example, firewall functions. It is also fundamental to the MPLS design that packets are routed through the network using the path specified by the node imposing the labels and that the labels are swapped or popped correctly. Where an SF is not encapsulation aware, the encapsulation may be stripped by an SFC proxy such that a packet may exist as a native packet (perhaps IP) on the path between the SFC proxy and the SF; however, this is an intrinsic part of the SFC design, which needs to define how a packet is protected in that environment.",
      "ja": "これは、分類器は完全に信頼できる要素であるSFCの設計の基本です。すなわち、分類決定プロセスは、他の要素には見えない、であり、その出力は正確として扱われます。このように、分類器は、パケットは、例えば、ファイアウォール機能を含む、対象となり、処理を決定する責任を負っています。また、パケットがラベルを課すことにより、ノードとラベルが入れ替わったり、正しくポップしていることを指定したパスを使用して、ネットワークを介してルーティングされるMPLSの設計の基本です。 SFが認識カプセル化されていない場合、カプセル化パケットはSFCプロキシとSFとの間の経路上にネイティブパケット（おそらくIP）として存在することができるようにSFCプロキシによって剥離することができます。しかし、これは、パケットがその環境で保護されてどのように定義する必要があるSFCデザインの本質的な部分です。"
    },
    {
      "indent": 3,
      "text": "SFC components are configured and enabled through a management system or a control plane. This document does not make any assumptions about what mechanisms are used. Deployments should, however, be aware that vulnerabilities in the management plane or control plane of an SFC system imply vulnerabilities in the whole SFC system. Thus, control-plane solutions (such as [BGP-NSH-SFC]) and management-plane mechanisms must include security measures that can be enabled by operators to protect their SFC systems.",
      "ja": "SFCの構成要素は、構成管理システム又は制御プレーンを介して有効になっています。この文書では、メカニズムが使用されているかについて何らかの仮定をしていません。展開では、しかし、SFCシステムの管理プレーン又は制御プレーンの脆弱性は、全体SFCシステムの脆弱性を意味することに注意すべきです。したがって、（例えば[BGP-NSH-SFC]など）コントロールプレーンソリューションおよび管理プレーンメカニズムは、そのSFCシステムを保護するためにオペレータによって有効にすることができるセキュリティ対策を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "An analysis of the security of MPLS systems is provided in [RFC5920], which also notes that the MPLS forwarding plane has no built-in security mechanisms. Some proposals to add encryption to the MPLS forwarding plane have been suggested [MPLS-Opp-Sec], but no mechanisms have been agreed upon at the time of publication of this document. Additionally, MPLS does not provide any cryptographic integrity protection on the MPLS headers. That means that procedures described in this document rely on three basic principles:",
      "ja": "MPLSシステムのセキュリティの分析はまた、MPLS転送プレーンはないビルトインセキュリティメカニズムを持っていないことに注意[RFC5920]に提供されます。 MPLSフォワーディングプレーンに暗号化を追加するためのいくつかの提案は、[MPLS-オップ-SEC]提案されているが、何のメカニズムは、このドキュメントの発行時点で合意されていません。さらに、MPLSは、MPLSヘッダ上の任意の暗号の完全性保護を提供していません。つまり、この文書で説明する手順は、3つの基本的な原則に依存していることを意味します。"
    },
    {
      "indent": 3,
      "text": "o The MPLS network is often considered to be a closed network such that insertion, modification, or inspection of packets by an outside party is not possible. MPLS networks are operated with closed boundaries so that MPLS-encapsulated packets are not admitted to the network, and MPLS headers are stripped before packets are forwarded from the network. This is particularly pertinent in the SFC context because [RFC7665] notes that \"The architecture described herein is assumed to be applicable to a single network administrative domain.\" Furthermore, [RFC8300] states that packets originating outside the SFC-enabled domain MUST be dropped if they contain an NSH and packets exiting the SFC-enabled domain MUST be dropped if they contain an NSH. These constraints apply equally to the use of MPLS to encode a logical representation of the NSH.",
      "ja": "O MPLSネットワークは、多くの場合、外部者によるパケットの挿入、変更、または検査が不可能であるように、閉じたネットワークであると考えられます。 MPLSカプセル化パケットがネットワークに是認されないように、MPLSネットワークは、閉じた境界で操作され、パケットがネットワークから転送される前に、MPLSヘッダは取り除かれます。 [RFC7665]は、「本明細書に記載のアーキテクチャは、単一のネットワーク管理ドメインにも適用可能であるものとする。」と述べているので、これはSFC文脈において特に適切ですさらに、[RFC8300]は、彼らがNSHが含まれている場合NSH及びSFC対応ドメインを出るパケットが廃棄されなければならない含まれている場合、SFC-有効領域外に発信パケットが廃棄されなければならないと述べています。これらの制約は、NSHの論理表現を符号化するためにMPLSの使用に等しく適用されます。"
    },
    {
      "indent": 3,
      "text": "o The underlying transport mechanisms (such as Ethernet) between adjacent MPLS nodes may offer security mechanisms that can be used to defend packets \"on the wire\".",
      "ja": "oを隣接MPLSノード間（イーサネットなど）、基礎となるトランスポート機構は、「ワイヤ上に」パケットを守るために使用することができるセキュリティメカニズムを提供することができます。"
    },
    {
      "indent": 3,
      "text": "o The SFC-capable devices participating in an SFC system are responsible for verifying and protecting payload packets and their contents as well as providing other security capabilities that might be required in the particular system.",
      "ja": "SFCシステムに参加SFC対応デバイスoを検証し、ペイロードパケットおよびその内容を保護するだけでなく、特定のシステムに必要とされるかもしれない他のセキュリティ機能を提供する責任があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, where a tunnel is used to link two non-MPLS domains, the tunnel design needs to specify how the tunnel is secured.",
      "ja": "トンネルが二つの非MPLSドメインを連結するために使用される場合、さらに、トンネル設計は、トンネルが確保される方法を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Thus, this design relies on the component underlying technologies to address the potential security vulnerabilities, and it documents the necessary protections (or risk of their absence) above. It does not include any native security mechanisms in-band with the MPLS encoding of the NSH functionality.",
      "ja": "したがって、この設計は、潜在的なセキュリティの脆弱性に対処するための技術の基礎となるコンポーネントに依存している、そしてそれは、上記の必要な保護（またはその欠如のリスクを）説明します。これは、NSH機能のMPLSエンコーディングで帯域内の任意のネイティブセキュリティメカニズムが含まれていません。"
    },
    {
      "indent": 3,
      "text": "Note that configuration elements of this system (such as the programming of the table of metadata; see Section 12) must also be adequately secured, although such mechanisms are not in scope for this protocol specification.",
      "ja": "このシステムの構成要素を注（例えば、メタデータのテーブルのプログラムとして、セクション12を参照）、このような機構は、このプロトコル仕様の範囲内にはないが、また十分に確保されなければなりません。"
    },
    {
      "indent": 3,
      "text": "No known new security vulnerabilities over the SFC architecture [RFC7665] and the NSH specification [RFC8300] are introduced by this design, but if issues are discovered in the future, it is expected that they will be addressed through modifications to control/ management components of any solution or through changes to the underlying technology.",
      "ja": "SFCアーキテクチャ[RFC7665]とNSH仕様[RFC8300]の上に、新たなセキュリティの脆弱性は、この設計によって導入されている知られていないが、問題は、将来的に発見された場合、彼らがの/管理コンポーネントを制御するための変更で対処されることが期待されるんすべてのソリューションや基本的な技術への変更による。"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "ja": "16. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made allocations from the \"Extended Special-Purpose MPLS Label Values\" subregistry of the \"Special-Purpose Multiprotocol Label Switching (MPLS) Label Values\" registry as follows:",
      "ja": "次のようにIANAは、「特別な目的のマルチプロトコルラベルスイッチング（MPLS）ラベル値」レジストリの「拡張特殊目的のMPLSラベル値」副登録から割り当てを行っています。"
    },
    {
      "indent": 6,
      "text": "Value  | Description                       | Reference\n-------+-----------------------------------+--------------\n 16    | Metadata Label Indicator (MLI)    | RFC 8595\n 17    | Metadata Present Indicator (MPI)  | RFC 8595",
      "raw": true
    },
    {
      "indent": 0,
      "text": "17. References",
      "section_title": true,
      "ja": "17.参考文献"
    },
    {
      "indent": 0,
      "text": "17.1. Normative References",
      "section_title": true,
      "ja": "17.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6790] Kompella, K., Drake, J., Amante, S., Henderickx, W., and L. Yong, \"The Use of Entropy Labels in MPLS Forwarding\", RFC 6790, DOI 10.17487/RFC6790, November 2012, <https://www.rfc-editor.org/info/rfc6790>.",
      "ja": "[RFC6790] Kompella、K.、ドレイク、J.、Amante、S.、Henderickx、W.、およびL.龍、 \"MPLS転送にエントロピー標識の使用\"、RFC 6790、DOI 10.17487 / RFC6790、2012年11月、 <https://www.rfc-editor.org/info/rfc6790>。"
    },
    {
      "indent": 3,
      "text": "[RFC7274] Kompella, K., Andersson, L., and A. Farrel, \"Allocating and Retiring Special-Purpose MPLS Labels\", RFC 7274, DOI 10.17487/RFC7274, June 2014, <https://www.rfc-editor.org/info/rfc7274>.",
      "ja": "[RFC7274] Kompella、K.、アンダーソン、L.、およびA.ファレル、 \"割り当てと特殊目的のMPLSラベルを引退\"、RFC 7274、DOI 10.17487 / RFC7274、2014年6月、<HTTPS：//www.rfc-editor .ORG /情報/ rfc7274>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8300] Quinn, P., Ed., Elzur, U., Ed., and C. Pignataro, Ed., \"Network Service Header (NSH)\", RFC 8300, DOI 10.17487/RFC8300, January 2018, <https://www.rfc-editor.org/info/rfc8300>.",
      "ja": "[RFC8300]クイン、P.、エド、Elzur、U.、エド、およびC. Pignataro、エド、 \"ネットワークサービスヘッダ（NSH）\"、RFC 8300、DOI 10.17487 / RFC8300、2018年1月、<httpsを。。。： //www.rfc-editor.org/info/rfc8300>。"
    },
    {
      "indent": 3,
      "text": "[RFC8393] Farrel, A. and J. Drake, \"Operating the Network Service Header (NSH) with Next Protocol \"None\"\", RFC 8393, DOI 10.17487/RFC8393, May 2018, <https://www.rfc-editor.org/info/rfc8393>.",
      "ja": "[RFC8393]ファレル、A.およびJ.ドレイク、 \"オペレーティング次のプロトコルとネットワークサービスヘッダ（NSH） \"なし\"\"、RFC 8393、DOI 10.17487 / RFC8393、2018年5月、<HTTPS：//www.rfc-editor .ORG /情報/ rfc8393>。"
    },
    {
      "indent": 0,
      "text": "17.2. Informative References",
      "section_title": true,
      "ja": "17.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BGP-NSH-SFC] Farrel, A., Drake, J., Rosen, E., Uttaro, J., and L. Jalil, \"BGP Control Plane for NSH SFC\", Work in Progress, draft-ietf-bess-nsh-bgp-control-plane-11, May 2019.",
      "ja": "[BGP-NSH-SFC]ファレル、A.、ドレイク、J.、ローゼン、E.、Uttaro、J.、およびL.ジャリル、 \"NSH SFCのためのBGPコントロールプレーン\" を、進行中で働いて、ドラフトIETF、ベス-nsh-BGP-コントロールプレーン-11、2019年5月。"
    },
    {
      "indent": 3,
      "text": "[MPLS-Opp-Sec] Farrel, A. and S. Farrell, \"Opportunistic Security in MPLS Networks\", Work in Progress, draft-ietf-mpls-opportunistic-encrypt-03, March 2017.",
      "ja": "[MPLS-オップ-SEC]ファレル、A.とS.ファレル、 \"日和見はMPLSネットワークにおけるセキュリティ\" が進行中で働いて、ドラフト-IETF-MPLS-日和見暗号化-03、2017年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3031] Rosen, E., Viswanathan, A., and R. Callon, \"Multiprotocol Label Switching Architecture\", RFC 3031, DOI 10.17487/RFC3031, January 2001, <https://www.rfc-editor.org/info/rfc3031>.",
      "ja": "[RFC3031]ローゼン、E.、Viswanathanの、A.、およびR. Callon、 \"マルチプロトコルラベルスイッチングアーキテクチャ\"、RFC 3031、DOI 10.17487 / RFC3031、2001年1月、<https://www.rfc-editor.org/info / RFC3031>。"
    },
    {
      "indent": 3,
      "text": "[RFC4364] Rosen, E. and Y. Rekhter, \"BGP/MPLS IP Virtual Private Networks (VPNs)\", RFC 4364, DOI 10.17487/RFC4364, February 2006, <https://www.rfc-editor.org/info/rfc4364>.",
      "ja": "[RFC4364]ローゼン、E.およびY. Rekhter、 \"BGP / MPLS IP仮想プライベートネットワーク（VPN）\"、RFC 4364、DOI 10.17487 / RFC4364、2006年2月、<https://www.rfc-editor.org/info / RFC4364>。"
    },
    {
      "indent": 3,
      "text": "[RFC5920] Fang, L., Ed., \"Security Framework for MPLS and GMPLS Networks\", RFC 5920, DOI 10.17487/RFC5920, July 2010, <https://www.rfc-editor.org/info/rfc5920>.",
      "ja": "[RFC5920]牙、L.、エド。、 \"MPLSおよびGMPLSネットワークのセキュリティフレームワーク\"、RFC 5920、DOI 10.17487 / RFC5920、2010年7月、<https://www.rfc-editor.org/info/rfc5920>。"
    },
    {
      "indent": 3,
      "text": "[RFC7665] Halpern, J., Ed. and C. Pignataro, Ed., \"Service Function Chaining (SFC) Architecture\", RFC 7665, DOI 10.17487/RFC7665, October 2015, <https://www.rfc-editor.org/info/rfc7665>.",
      "ja": "[RFC7665]アルペルン、J.、エド。そして、C. Pignataro、エド。、 \"サービス機能の連鎖（SFC）アーキテクチャ\"、RFC 7665、DOI 10.17487 / RFC7665、2015年10月、<https://www.rfc-editor.org/info/rfc7665>。"
    },
    {
      "indent": 3,
      "text": "[RFC8402] Filsfils, C., Ed., Previdi, S., Ed., Ginsberg, L., Decraene, B., Litkowski, S., and R. Shakir, \"Segment Routing Architecture\", RFC 8402, DOI 10.17487/RFC8402, July 2018, <https://www.rfc-editor.org/info/rfc8402>.",
      "ja": "[RFC8402] Filsfils、C.、エド。、Previdi、S.編、ギンズバーグ、L.、Decraene、B.、Litkowski、S.、およびR. Shakir、 \"セグメントルーティングアーキテクチャ\"、RFC 8402、DOI 10.17487 / RFC8402、2018年7月、<https://www.rfc-editor.org/info/rfc8402>。"
    },
    {
      "indent": 3,
      "text": "[RFC8459] Dolson, D., Homma, S., Lopez, D., and M. Boucadair, \"Hierarchical Service Function Chaining (hSFC)\", RFC 8459, DOI 10.17487/RFC8459, September 2018, <https://www.rfc-editor.org/info/rfc8459>.",
      "ja": "[RFC8459] Dolson、D.、本間、S.、ロペス、D.、およびM. Boucadair、 \"階層サービス機能チェーン（hSFC）\"、RFC 8459、DOI 10.17487 / RFC8459、2018年9月、<https：//でWWW .rfc-editor.org /情報/ rfc8459>。"
    },
    {
      "indent": 3,
      "text": "[SR-Srv-Prog] Clad, F., Ed., Xu, X., Ed., Filsfils, C., Bernier, D., Li, C., Decraene, B., Ma, S., Yadlapalli, C., Henderickx, W., and S. Salsano, \"Service Programming with Segment Routing\", Work in Progress, draft-xuclad-spring-sr-service-programming-02, April 2019.",
      "ja": "[SR-SRV-PROG]クラッド、F.編、徐、X.、編、Filsfils、C.、ベルニエ、D.、リチウム、C.、Decraene、B.、馬、S.、Yadlapalli、 C.、Henderickx、W.、およびS. Salsano、 \"セグメントルーティングとサービスのプログラミング\" が進行中で働いて、ドラフトxucladスプリング-SR-サービス - プログラミング -  02、2019年4月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document derives ideas and text from [BGP-NSH-SFC]. The authors are grateful to all those who contributed to the discussions that led to that work: Loa Andersson, Andrew G. Malis, Alexander (Sasha) Vainshtein, Joel Halpern, Tony Przygienda, Stuart Mackie, Keyur Patel, and Jim Guichard. Loa Andersson provided helpful review comments.",
      "ja": "この文書では、[BGP-NSH-SFC]からアイデアやテキストを導出します。ロア・アンダーソン、アンドリューG. Malis、アレクサンダー（サーシャ）Vainshtein、ジョエル・ハルパーン、トニーPrzygienda、スチュアート・マッキー、Keyurパテル、そしてジム・ギシャール：著者は、その仕事につながった議論に貢献したすべての人に感謝しています。ロア・アンダーソンは、役に立つレビューコメントを提供しました。"
    },
    {
      "indent": 3,
      "text": "Thanks to Loa Andersson, Lizhong Jin, Matthew Bocci, Joel Halpern, and Mach Chen for reviews of this text. Thanks to Russ Mundy for his Security Directorate review and to S Moonesamy for useful discussions. Thanks also to Benjamin Kaduk, Alissa Cooper, Eric Rescorla, Mirja Kuehlewind, Alvaro Retana, and Martin Vigoureux for comprehensive reviews during IESG evaluation.",
      "ja": "このテキストのレビューのためのLoaアンデション、Lizhongジン、マシューボッチ、ジョエル・ハルパーン、マッハチェンに感謝します。彼のセキュリティ総局の審査のために、有用な議論のためのS Moonesamyへラスマンディに感謝します。 IESG評価時の包括的なレビューにもベンジャミンKaduk、アリッサ・クーパー、エリックレスコラ、Mirja Kuehlewind、アルバロRetana、そしてマーティンVigoureuxに感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors would like to be able to thank the authors of [SR-Srv-Prog] and [RFC8402] whose original work on service chaining and the identification of services using Segment Identifiers (SIDs), and conversation with whom, helped clarify the application of SR-MPLS to SFC.",
      "ja": "著者は、[SR-SRV-PROG]の著者に感謝できるようにしたい、そのオリジナル作品の連鎖サービスおよびセグメント識別子（SID）を使用して、サービスの識別、およびとの会話の[RFC8402]、アプリケーションを明確に役立ったでしょうSR-MPLS SFCへの。"
    },
    {
      "indent": 3,
      "text": "Particular thanks to Loa Andersson for conversations and advice about working group process.",
      "ja": "グループ・プロセスの作業についての会話やアドバイスのためのLoaアンデションに特に感謝します。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "The following individual contributed text to this document:",
      "ja": "この文書に次の個々の貢献のテキスト："
    },
    {
      "indent": 6,
      "text": "Andrew G. Malis Email: agmalis@gmail.com",
      "ja": "アンドリューG. Malis Eメール：agmalis@gmail.com"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Adrian Farrel Old Dog Consulting",
      "ja": "エードリアンファレル古い犬のコンサルティング"
    },
    {
      "indent": 3,
      "text": "Email: adrian@olddog.co.uk",
      "ja": "メール：adrian@olddog.co.uk"
    },
    {
      "indent": 3,
      "text": "Stewart Bryant Futurewei",
      "ja": "スチュワートブライアントFuturewei"
    },
    {
      "indent": 3,
      "text": "Email: stewart.bryant@gmail.com",
      "ja": "メール：stewart.bryant@gmail.com"
    },
    {
      "indent": 3,
      "text": "John Drake Juniper Networks",
      "ja": "ジョン・ドレイクジュニパーネットワークス"
    },
    {
      "indent": 3,
      "text": "Email: jdrake@juniper.net",
      "ja": "メール：jdrake@juniper.net"
    }
  ]
}