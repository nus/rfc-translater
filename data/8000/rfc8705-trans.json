{
  "title": {
    "text": "RFC 8705 - OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens",
    "ja": "RFC 8705 - OAuth 2.0相互TLSクライアント認証および証明書バインドアクセストークン"
  },
  "number": 8705,
  "created_at": "2020-03-11 14:47:31.309578+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       B. Campbell\nRequest for Comments: 8705                                 Ping Identity\nCategory: Standards Track                                     J. Bradley\nISSN: 2070-1721                                                   Yubico\n                                                             N. Sakimura\n                                               Nomura Research Institute\n                                                          T. Lodderstedt\n                                                              YES.com AG\n                                                           February 2020",
      "raw": true
    },
    {
      "indent": 4,
      "text": "OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens",
      "ja": "OAuth 2.0相互TLSクライアント認証および証明書バインドアクセストークン"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes OAuth client authentication and certificate-bound access and refresh tokens using mutual Transport Layer Security (TLS) authentication with X.509 certificates. OAuth clients are provided a mechanism for authentication to the authorization server using mutual TLS, based on either self-signed certificates or public key infrastructure (PKI). OAuth authorization servers are provided a mechanism for binding access tokens to a client's mutual-TLS certificate, and OAuth protected resources are provided a method for ensuring that such an access token presented to it was issued to the client presenting the token.",
      "ja": "このドキュメントでは、X.509証明書を使用した相互トランスポート層セキュリティ（TLS）認証を使用したOAuthクライアント認証と証明書バインドアクセスおよび更新トークンについて説明します。 OAuthクライアントには、自己署名証明書または公開キー基盤（PKI）のいずれかに基づいて、相互TLSを使用した承認サーバーへの認証メカニズムが提供されます。 OAuth承認サーバーには、アクセストークンをクライアントの相互TLS証明書にバインドするためのメカニズムが提供され、OAuthで保護されたリソースには、提示されたそのようなアクセストークンがトークンを提示するクライアントに発行されたことを保証するための方法が提供されます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8705.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8705で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 1.1. Requirements Notation and Conventions 1.2. Terminology 2. Mutual TLS for OAuth Client Authentication 2.1. PKI Mutual-TLS Method 2.1.1. PKI Method Metadata Value 2.1.2. Client Registration Metadata 2.2. Self-Signed Certificate Mutual-TLS Method 2.2.1. Self-Signed Method Metadata Value 2.2.2. Client Registration Metadata 3. Mutual-TLS Client Certificate-Bound Access Tokens 3.1. JWT Certificate Thumbprint Confirmation Method 3.2. Confirmation Method for Token Introspection 3.3. Authorization Server Metadata 3.4. Client Registration Metadata 4. Public Clients and Certificate-Bound Tokens 5. Metadata for Mutual-TLS Endpoint Aliases 6. Implementation Considerations 6.1. Authorization Server 6.2. Resource Server 6.3. Certificate Expiration and Bound Access Tokens 6.4. Implicit Grant Unsupported 6.5. TLS Termination 7. Security Considerations 7.1. Certificate-Bound Refresh Tokens 7.2. Certificate Thumbprint Binding 7.3. TLS Versions and Best Practices 7.4. X.509 Certificate Spoofing 7.5. X.509 Certificate Parsing and Validation Complexity 8. Privacy Considerations 9. IANA Considerations 9.1. JWT Confirmation Methods Registration 9.2. Authorization Server Metadata Registration 9.3. Token Endpoint Authentication Method Registration 9.4. Token Introspection Response Registration 9.5. Dynamic Client Registration Metadata Registration 10. References 10.1. Normative References 10.2. Informative References Appendix A. Example \"cnf\" Claim, Certificate, and JWK Appendix B. Relationship to Token Binding Acknowledgements Authors' Addresses",
      "ja": "1. はじめに1.1。要件の表記と規則1.2。用語2. OAuthクライアント認証用の相互TLS 2.1。 PKI相互TLS方法2.1.1。 PKIメソッドメタデータ値2.1.2。クライアント登録メタデータ2.2。自己署名証明書相互TLS方法2.2.1。自己署名方式のメタデータ値2.2.2。クライアント登録メタデータ3.相互TLSクライアント証明書バインドアクセストークン3.1。 JWT証明書のprint印確認方法3.2。トークンイントロスペクションの確認方法3.3。認可サーバーのメタデータ3.4。クライアント登録メタデータ4.パブリッククライアントと証明書バインドトークン5.相互TLSエンドポイントエイリアスのメタデータ6.実装に関する考慮事項6.1。認可サーバー6.2。リソースサーバー6.3。証明書の有効期限とバインドされたアクセストークン6.4。暗黙的な補助金サポートなし6.5。 TLS終了7.セキュリティに関する考慮事項7.1。証明書バインドリフレッシュトークン7.2。証明書のprint印のバインド7.3。 TLSバージョンとベストプラクティス7.4。 X.509証明書のなりすまし7.5。 X.509証明書の解析と検証の複雑さ8.プライバシーに関する考慮事項9. IANAに関する考慮事項9.1。 JWT確認メソッドの登録9.2。認可サーバーのメタデータ登録9.3。トークンエンドポイント認証方法の登録9.4。トークンイントロスペクション応答登録9.5。動的クライアント登録メタデータ登録10.参照10.1。規範的参考文献10.2。参考情報付録A.「cnf」クレーム、証明書、およびJWKの例付録B.トークンバインディングアクノレッジメントの作成者のアドレスとの関係"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 Authorization Framework [RFC6749] enables third-party client applications to obtain delegated access to protected resources. In the prototypical abstract OAuth flow, illustrated in Figure 1, the client obtains an access token from an entity known as an authorization server and then uses that token when accessing protected resources, such as HTTPS APIs.",
      "ja": "OAuth 2.0認可フレームワーク[RFC6749]により、サードパーティのクライアントアプリケーションは、保護されたリソースへの委任されたアクセスを取得できます。 図1に示すプロトタイプの抽象OAuthフローでは、クライアントは承認サーバーと呼ばれるエンティティからアクセストークンを取得し、HTTPS APIなどの保護されたリソースにアクセスするときにそのトークンを使用します。"
    },
    {
      "indent": 5,
      "text": "+--------+                                 +---------------+\n|        |                                 |               |\n|        |<--(A)-- Get an access token --->| Authorization |\n|        |                                 |     Server    |\n|        |                                 |               |\n|        |                                 +---------------+\n|        |                                         ^\n|        |                                         |\n|        |\n|        |                               (C)       |\n| Client |                           Validate the\n|        |                           access token  |\n|        |\n|        |                                         |\n|        |                                         v\n|        |                                 +---------------+\n|        |                                 |      (C)      |\n|        |                                 |               |\n|        |<--(B)-- Use the access token -->|   Protected   |\n|        |                                 |    Resource   |\n|        |                                 |               |\n+--------+                                 +---------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 1: Abstract OAuth 2.0 Protocol Flow",
      "ja": "図1：抽象OAuth 2.0プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "The flow illustrated in Figure 1 includes the following steps:",
      "ja": "図1に示すフローには、次の手順が含まれます。"
    },
    {
      "indent": 3,
      "text": "(A) The client makes an HTTPS \"POST\" request to the authorization server and presents a credential representing the authorization grant. For certain types of clients (those that have been issued or otherwise established a set of client credentials) the request must be authenticated. In the response, the authorization server issues an access token to the client.",
      "ja": "（A）クライアントは、HTTPS「POST」リクエストを許可サーバーに送信し、許可付与を表す資格情報を提示します。 特定のタイプのクライアント（クライアント資格情報のセットを発行または確立したクライアント）の場合、要求を認証する必要があります。 応答で、承認サーバーはアクセストークンをクライアントに発行します。"
    },
    {
      "indent": 3,
      "text": "(B) The client includes the access token when making a request to access a protected resource.",
      "ja": "（B）クライアントは、保護されたリソースへのアクセスを要求するときにアクセストークンを含めます。"
    },
    {
      "indent": 3,
      "text": "(C) The protected resource validates the access token in order to authorize the request. In some cases, such as when the token is self-contained and cryptographically secured, the validation can be done locally by the protected resource. Other cases require that the protected resource call out to the authorization server to determine the state of the token and obtain metainformation about it.",
      "ja": "（C）要求を承認するために、保護されたリソースはアクセストークンを検証します。 トークンが自己完結型で暗号的に保護されている場合など、場合によっては、保護されたリソースによってローカルで検証を実行できます。 その他の場合、保護されたリソースが認可サーバーを呼び出してトークンの状態を判断し、トークンに関するメタ情報を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Layering on the abstract flow above, this document standardizes enhanced security options for OAuth 2.0 utilizing client-certificate-based mutual TLS. Section 2 provides options for authenticating the request in Step (A). Step (C) is supported with semantics to express the binding of the token to the client certificate for both local and remote processing in Sections 3.1 and 3.2, respectively. This ensures that, as described in Section 3, protected resource access in Step (B) is only possible by the legitimate client using a certificate-bound token and holding the private key corresponding to the certificate.",
      "ja": "上記の抽象的なフローに基づいて、このドキュメントでは、クライアント証明書ベースの相互TLSを利用したOAuth 2.0の強化されたセキュリティオプションを標準化します。 セクション2では、ステップ（A）で要求を認証するためのオプションを提供します。 ステップ（C）は、それぞれセクション3.1と3.2のローカル処理とリモート処理の両方で、クライアント証明書へのトークンのバインディングを表すセマンティクスでサポートされています。 これにより、セクション3で説明したように、ステップ（B）の保護されたリソースアクセスは、証明書にバインドされたトークンを使用し、証明書に対応する秘密キーを保持する正当なクライアントによってのみ可能になります。"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 defines a shared-secret method of client authentication but also allows for defining and using additional client authentication mechanisms when interacting directly with the authorization server. This document describes an additional mechanism of client authentication utilizing mutual-TLS certificate-based authentication that provides better security characteristics than shared secrets. While [RFC6749] documents client authentication for requests to the token endpoint, extensions to OAuth 2.0 (such as Introspection [RFC7662], Revocation [RFC7009], and the Backchannel Authentication Endpoint in [OpenID.CIBA]) define endpoints that also utilize client authentication, and the mutual-TLS methods defined herein are applicable to those endpoints as well.",
      "ja": "OAuth 2.0は、クライアント認証の共有秘密方式を定義しますが、許可サーバーと直接対話するときに追加のクライアント認証メカニズムを定義および使用することもできます。 このドキュメントでは、共有秘密よりも優れたセキュリティ特性を提供する相互TLS証明書ベースの認証を利用するクライアント認証の追加メカニズムについて説明します。 [RFC6749]はトークンエンドポイントへのリクエストのクライアント認証を文書化しますが、OAuth 2.0の拡張（Introspection [RFC7662]、Revocation [RFC7009]、[OpenID.CIBA]のバックチャネル認証エンドポイントなど）はクライアント認証も利用するエンドポイントを定義します 、およびここで定義されている相互TLSメソッドは、それらのエンドポイントにも適用できます。"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS certificate-bound access tokens ensure that only the party in possession of the private key corresponding to the certificate can utilize the token to access the associated resources. Such a constraint is sometimes referred to as key confirmation, proof-of-possession, or holder-of-key and is unlike the case of the bearer token described in [RFC6750], where any party in possession of the access token can use it to access the associated resources. Binding an access token to the client's certificate prevents the use of stolen access tokens or replay of access tokens by unauthorized parties.",
      "ja": "相互TLS証明書にバインドされたアクセストークンにより、証明書に対応する秘密キーを所持している当事者のみが、トークンを使用して関連リソースにアクセスできるようになります。 そのような制約は、キー確認、所有証明、またはキーホルダーと呼ばれることもあり、[RFC6750]で説明されているベアラートークンの場合とは異なります。 関連するリソースにアクセスします。 アクセストークンをクライアントの証明書にバインドすると、盗まれたアクセストークンの使用や、権限のない者によるアクセストークンの再生を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS certificate-bound access tokens and mutual-TLS client authentication are distinct mechanisms that are complementary but don't necessarily need to be deployed or used together.",
      "ja": "相互TLS証明書バインドアクセストークンと相互TLSクライアント認証は補完的な別個のメカニズムですが、必ずしも一緒に展開または使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Additional client metadata parameters are introduced by this document in support of certificate-bound access tokens and mutual-TLS client authentication. The authorization server can obtain client metadata via the Dynamic Client Registration Protocol [RFC7591], which defines mechanisms for dynamically registering OAuth 2.0 client metadata with authorization servers. Also the metadata defined by [RFC7591], and registered extensions to it, imply a general data model for clients that is useful for authorization server implementations, even when the Dynamic Client Registration Protocol isn't in play. Such implementations will typically have some sort of user interface available for managing client configuration.",
      "ja": "このドキュメントでは、証明書バインドアクセストークンと相互TLSクライアント認証をサポートする追加のクライアントメタデータパラメーターが導入されています。 認可サーバーは、OAuth 2.0クライアントメタデータを認可サーバーに動的に登録するメカニズムを定義するDynamic Client Registration Protocol [RFC7591]を介してクライアントメタデータを取得できます。 また、[RFC7591]で定義されたメタデータとそれに登録された拡張は、ダイナミッククライアント登録プロトコルが機能していない場合でも、承認サーバーの実装に役立つクライアントの一般的なデータモデルを意味します。 通常、このような実装には、クライアント構成の管理に使用できるユーザーインターフェイスがあります。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation and Conventions",
      "section_title": true,
      "ja": "1.1. 要件の表記と規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "Throughout this document the term \"mutual TLS\" refers to the process whereby, in addition to the normal TLS server authentication with a certificate, a client presents its X.509 certificate and proves possession of the corresponding private key to a server when negotiating a TLS session. In contemporary versions of TLS [RFC5246] [RFC8446], this requires that the client send the Certificate and CertificateVerify messages during the handshake and for the server to verify the CertificateVerify and Finished messages.",
      "ja": "このドキュメントを通して、「相互TLS」という用語は、証明書を使用した通常のTLSサーバー認証に加えて、クライアントがX.509証明書を提示し、TLSをネゴシエートするときにサーバーに対応する秘密鍵を所有していることを証明するプロセスを指します セッション。 TLSの最新バージョン[RFC5246] [RFC8446]では、これには、クライアントがハンドシェイク中に証明書とCertificateVerifyメッセージを送信し、サーバーがCertificateVerifyおよびFinishedメッセージを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Mutual TLS for OAuth Client Authentication",
      "section_title": true,
      "ja": "2. OAuthクライアント認証用の相互TLS"
    },
    {
      "indent": 3,
      "text": "This section defines, as an extension of Section 2.3 of OAuth 2.0 [RFC6749], two distinct methods of using mutual-TLS X.509 client certificates as client credentials. The requirement of mutual TLS for client authentication is determined by the authorization server, based on policy or configuration for the given client (regardless of whether the client was dynamically registered, statically configured, or otherwise established).",
      "ja": "このセクションでは、OAuth 2.0 [RFC6749]のセクション2.3の拡張として、相互TLS X.509クライアント証明書をクライアント資格情報として使用する2つの異なる方法を定義します。 クライアント認証の相互TLSの要件は、特定のクライアントのポリシーまたは構成に基づいて、認可サーバーによって決定されます（クライアントが動的に登録、静的に構成、または確立されたかどうかに関係なく）。"
    },
    {
      "indent": 3,
      "text": "In order to utilize TLS for OAuth client authentication, the TLS connection between the client and the authorization server MUST have been established or re-established with mutual-TLS X.509 certificate authentication (i.e., the client Certificate and CertificateVerify messages are sent during the TLS handshake).",
      "ja": "OAuthクライアント認証にTLSを使用するには、クライアントと承認サーバー間のTLS接続が相互TLS X.509証明書認証で確立または再確立されている必要があります（つまり、クライアント証明書とCertificateVerifyメッセージは TLSハンドシェイク）。"
    },
    {
      "indent": 3,
      "text": "For all requests to the authorization server utilizing mutual-TLS client authentication, the client MUST include the \"client_id\" parameter described in Section 2.2 of OAuth 2.0 [RFC6749]. The presence of the \"client_id\" parameter enables the authorization server to easily identify the client independently from the content of the certificate. The authorization server can locate the client configuration using the client identifier and check the certificate presented in the TLS handshake against the expected credentials for that client. The authorization server MUST enforce the binding between client and certificate, as described in either Section 2.1 or 2.2 below. If no certificate is presented, or that which is presented doesn't match that which is expected for the given \"client_id\", the authorization server returns a normal OAuth 2.0 error response per Section 5.2 of [RFC6749] with the \"invalid_client\" error code to indicate failed client authentication.",
      "ja": "相互TLSクライアント認証を利用する認可サーバーへのすべてのリクエストに対して、クライアントはOAuth 2.0 [RFC6749]のセクション2.2で説明されている「client_id」パラメーターを含まなければなりません。 「client_id」パラメーターの存在により、許可サーバーは証明書の内容とは無関係にクライアントを簡単に識別できます。 許可サーバーは、クライアントIDを使用してクライアント構成を見つけ、TLSハンドシェークで提示された証明書を、そのクライアントの予想される資格情報と照合して確認できます。 認可サーバーは、以下のセクション2.1または2.2で説明されているように、クライアントと証明書の間のバインディングを実施しなければなりません。 証明書が提示されない場合、または提示された証明書が特定の「client_id」に期待されるものと一致しない場合、認可サーバーは「invalid_client」エラーコードとともに[RFC6749]のセクション5.2に従って通常のOAuth 2.0エラー応答を返します 失敗したクライアント認証を示します。"
    },
    {
      "indent": 0,
      "text": "2.1. PKI Mutual-TLS Method",
      "section_title": true,
      "ja": "2.1. PKI相互TLSメソッド"
    },
    {
      "indent": 3,
      "text": "The PKI (public key infrastructure) method of mutual-TLS OAuth client authentication adheres to the way in which X.509 certificates are traditionally used for authentication. It relies on a validated certificate chain [RFC5280] and a single subject distinguished name (DN) or a single subject alternative name (SAN) to authenticate the client. Only one subject name value of any type is used for each client. The TLS handshake is utilized to validate the client's possession of the private key corresponding to the public key in the certificate and to validate the corresponding certificate chain. The client is successfully authenticated if the subject information in the certificate matches the single expected subject configured or registered for that particular client (note that a predictable treatment of DN values, such as the distinguishedNameMatch rule from [RFC4517], is needed in comparing the certificate's subject DN to the client's registered DN). Revocation checking is possible with the PKI method but if and how to check a certificate's revocation status is a deployment decision at the discretion of the authorization server. Clients can rotate their X.509 certificates without the need to modify the respective authentication data at the authorization server by obtaining a new certificate with the same subject from a trusted certificate authority (CA).",
      "ja": "相互TLS OAuthクライアント認証のPKI（公開鍵インフラストラクチャ）方式は、X.509証明書が認証に従来使用されている方法に準拠しています。クライアントを認証するために、検証済み証明書チェーン[RFC5280]と単一のサブジェクト識別名（DN）または単一のサブジェクト代替名（SAN）に依存します。各クライアントには、任意のタイプの1つのサブジェクト名値のみが使用されます。 TLSハンドシェイクは、証明書内の公開鍵に対応する秘密鍵のクライアントの所有を検証し、対応する証明書チェーンを検証するために利用されます。証明書のサブジェクト情報がその特定のクライアント用に構成または登録された単一の予想サブジェクトと一致する場合、クライアントは正常に認証されます（証明書の比較には[RFC4517]のdistinguishedNameMatchルールなどのDN値の予測可能な処理が必要です）サブジェクトDNをクライアントの登録済みDN）。失効確認はPKIメソッドを使用して可能ですが、証明書の失効ステータスを確認する方法と方法は、承認サーバーの裁量による展開の決定です。クライアントは、信頼できる認証局（CA）から同じサブジェクトを持つ新しい証明書を取得することにより、承認サーバーでそれぞれの認証データを変更することなく、X.509証明書をローテーションできます。"
    },
    {
      "indent": 0,
      "text": "2.1.1. PKI Method Metadata Value",
      "section_title": true,
      "ja": "2.1.1. PKIメソッドメタデータ値"
    },
    {
      "indent": 3,
      "text": "For the PKI method of mutual-TLS client authentication, this specification defines and registers the following authentication method metadata value into the \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters].",
      "ja": "相互TLSクライアント認証のPKIメソッドの場合、この仕様は、次の認証メソッドメタデータ値を定義し、「OAuthトークンエンドポイント認証メソッド」レジストリ[IANA.OAuth.Parameters]に登録します。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth Indicates that client authentication to the authorization server will occur with mutual TLS utilizing the PKI method of associating a certificate to a client.",
      "ja": "tls_client_auth証明書をクライアントに関連付けるPKIメソッドを利用する相互TLSで、承認サーバーへのクライアント認証が発生することを示します。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Client Registration Metadata",
      "section_title": true,
      "ja": "2.1.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "In order to convey the expected subject of the certificate, the following metadata parameters are introduced for the OAuth 2.0 Dynamic Client Registration Protocol [RFC7591] in support of the PKI method of mutual-TLS client authentication. A client using the \"tls_client_auth\" authentication method MUST use exactly one of the below metadata parameters to indicate the certificate subject value that the authorization server is to expect when authenticating the respective client.",
      "ja": "証明書の予想されるサブジェクトを伝達するために、相互TLSクライアント認証のPKIメソッドをサポートするOAuth 2.0動的クライアント登録プロトコル[RFC7591]に次のメタデータパラメータが導入されています。 「tls_client_auth」認証方式を使用するクライアントは、以下のメタデータパラメータのいずれか1つを正確に使用して、それぞれのクライアントを認証するときに認可サーバーが期待する証明書サブジェクト値を示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_subject_dn A string representation -- as defined in [RFC4514] -- of the expected subject distinguished name of the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_subject_dn [RFC4514]で定義されているように、OAuthクライアントが相互TLS認証で使用する証明書の予想されるサブジェクト識別名の文字列表現。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_dns A string containing the value of an expected dNSName SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_dns OAuthクライアントが相互TLS認証で使用する証明書内の予想されるdNSName SANエントリの値を含む文字列。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_uri A string containing the value of an expected uniformResourceIdentifier SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_uri OAuthクライアントが相互TLS認証で使用する証明書の予想されるuniformResourceIdentifier SANエントリの値を含む文字列。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_ip A string representation of an IP address in either dotted decimal notation (for IPv4) or colon-delimited hexadecimal (for IPv6, as defined in [RFC5952]) that is expected to be present as an iPAddress SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication. Per Section 8 of [RFC5952], the IP address comparison of the value in this parameter and the SAN entry in the certificate is to be done in binary format.",
      "ja": "tls_client_auth_san_ipドット付き10進表記（IPv4の場合）またはコロン区切り16進（[RFC5952]で定義されているIPv6の場合）のIPアドレスの文字列表現。 クライアントは相互TLS認証で使用します。 [RFC5952]のセクション8に従って、このパラメータの値と証明書のSANエントリのIPアドレス比較は、バイナリ形式で行われます。"
    },
    {
      "indent": 3,
      "text": "tls_client_auth_san_email A string containing the value of an expected rfc822Name SAN entry in the certificate that the OAuth client will use in mutual-TLS authentication.",
      "ja": "tls_client_auth_san_email OAuthクライアントが相互TLS認証で使用する証明書内の予想されるrfc822Name SANエントリの値を含む文字列。"
    },
    {
      "indent": 0,
      "text": "2.2. Self-Signed Certificate Mutual-TLS Method",
      "section_title": true,
      "ja": "2.2. 自己署名証明書相互TLSメソッド"
    },
    {
      "indent": 3,
      "text": "This method of mutual-TLS OAuth client authentication is intended to support client authentication using self-signed certificates. As a prerequisite, the client registers its X.509 certificates (using \"jwks\" defined in [RFC7591]) or a reference to a trusted source for its X.509 certificates (using \"jwks_uri\" from [RFC7591]) with the authorization server. During authentication, TLS is utilized to validate the client's possession of the private key corresponding to the public key presented within the certificate in the respective TLS handshake. In contrast to the PKI method, the client's certificate chain is not validated by the server in this case. The client is successfully authenticated if the certificate that it presented during the handshake matches one of the certificates configured or registered for that particular client. The Self-Signed Certificate method allows the use of mutual TLS to authenticate clients without the need to maintain a PKI. When used in conjunction with a \"jwks_uri\" for the client, it also allows the client to rotate its X.509 certificates without the need to change its respective authentication data directly with the authorization server.",
      "ja": "相互TLS OAuthクライアント認証のこの方法は、自己署名証明書を使用したクライアント認証をサポートすることを目的としています。前提条件として、クライアントはX.509証明書（[RFC7591]で定義された \"jwks\"を使用）またはX.509証明書の信頼できるソースへの参照（[RFC7591]の \"jwks_uri\"を使用）を承認サーバーに登録します。認証中に、TLSを使用して、それぞれのTLSハンドシェイクで証明書内に提示された公開キーに対応する秘密キーのクライアントの所有を検証します。 PKI方式とは対照的に、この場合、クライアントの証明書チェーンはサーバーによって検証されません。ハンドシェイク中に提示した証明書が、その特定のクライアント用に構成または登録された証明書のいずれかと一致する場合、クライアントは正常に認証されます。自己署名証明書方式では、相互TLSを使用して、PKIを維持する必要なくクライアントを認証できます。クライアントの「jwks_uri」と組み合わせて使用​​すると、クライアントはそれぞれの認証データを承認サーバーで直接変更する必要なく、X.509証明書をローテーションできます。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Self-Signed Method Metadata Value",
      "section_title": true,
      "ja": "2.2.1. 自己署名メソッドのメタデータ値"
    },
    {
      "indent": 3,
      "text": "For the Self-Signed Certificate method of mutual-TLS client authentication, this specification defines and registers the following authentication method metadata value into the \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters].",
      "ja": "相互TLSクライアント認証の自己署名証明書方式の場合、この仕様は次の認証方式メタデータ値を定義し、「OAuthトークンエンドポイント認証方式」レジストリ[IANA.OAuth.Parameters]に登録します。"
    },
    {
      "indent": 3,
      "text": "self_signed_tls_client_auth Indicates that client authentication to the authorization server will occur using mutual TLS with the client utilizing a self-signed certificate.",
      "ja": "self_signed_tls_client_auth自己署名証明書を使用するクライアントとの相互TLSを使用して、許可サーバーへのクライアント認証が行われることを示します。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Client Registration Metadata",
      "section_title": true,
      "ja": "2.2.2. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "For the Self-Signed Certificate method of binding a certificate with a client using mutual-TLS client authentication, the existing \"jwks_uri\" or \"jwks\" metadata parameters from [RFC7591] are used to convey the client's certificates via JSON Web Key (JWK) in a JWK Set [RFC7517]. The \"jwks\" metadata parameter is a JWK Set containing the client's public keys as an array of JWKs, while the \"jwks_uri\" parameter is a URL that references a client's JWK Set. A certificate is represented with the \"x5c\" parameter of an individual JWK within the set. Note that the members of the JWK representing the public key (e.g., \"n\" and \"e\" for RSA, \"x\" and \"y\" for Elliptic Curve (EC)) are required parameters per [RFC7518] so will be present even though they are not utilized in this context. Also note that Section 4.7 of [RFC7517] requires that the key in the first certificate of the \"x5c\" parameter match the public key represented by those other members of the JWK.",
      "ja": "相互TLSクライアント認証を使用してクライアントに証明書をバインドする自己署名証明書方式の場合、[RFC7591]の既存の「jwks_uri」または「jwks」メタデータパラメーターを使用して、JSON Webキー（JWK）を介してクライアントの証明書を伝達します JWKセット[RFC7517]。 「jwks」メタデータパラメータは、クライアントの公開キーをJWKの配列として含むJWKセットです。「jwks_uri」パラメータは、クライアントのJWKセットを参照するURLです。 証明書は、セット内の個々のJWKの「x5c」パラメーターで表されます。 公開鍵を表すJWKのメンバー（たとえば、RSAの「n」と「e」、楕円曲線（EC）の「x」と「y」）は、[RFC7518]ごとの必須パラメーターであるため、 ただし、このコンテキストでは使用されません。 また、[RFC7517]のセクション4.7では、「x5c」パラメータの最初の証明書のキーが、JWKの他のメンバーによって表される公開キーと一致する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3. Mutual-TLS Client Certificate-Bound Access Tokens",
      "section_title": true,
      "ja": "3. 相互TLSクライアント証明書バインドアクセストークン"
    },
    {
      "indent": 3,
      "text": "When mutual TLS is used by the client on the connection to the token endpoint, the authorization server is able to bind the issued access token to the client certificate. Such a binding is accomplished by associating the certificate with the token in a way that can be accessed by the protected resource, such as embedding the certificate hash in the issued access token directly, using the syntax described in Section 3.1, or through token introspection as described in Section 3.2. Binding the access token to the client certificate in that fashion has the benefit of decoupling that binding from the client's authentication with the authorization server, which enables mutual TLS during protected resource access to serve purely as a proof-of-possession mechanism. Other methods of associating a certificate with an access token are possible, per agreement by the authorization server and the protected resource, but are beyond the scope of this specification.",
      "ja": "トークンエンドポイントへの接続でクライアントが相互TLSを使用する場合、承認サーバーは発行されたアクセストークンをクライアント証明書にバインドできます。 このようなバインディングは、発行されたアクセストークンに証明書ハッシュを直接埋め込む、セクション3.1で説明されている構文を使用する、またはトークンのイントロスペクションを通じて、保護されたリソースからアクセスできる方法で証明書をトークンに関連付けることによって実現されます セクション3.2で説明されています。 この方法でアクセストークンをクライアント証明書にバインドすると、そのバインドを承認サーバーとのクライアント認証から切り離すという利点があります。これにより、保護されたリソースアクセス中の相互TLSが純粋に所有の証明メカニズムとして機能します。 認可サーバーと保護されたリソースの合意により、証明書をアクセストークンに関連付ける他の方法も可能ですが、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In order for a resource server to use certificate-bound access tokens, it must have advance knowledge that mutual TLS is to be used for some or all resource accesses. In particular, the access token itself cannot be used as input to the decision of whether or not to request mutual TLS because (from the TLS perspective) it is \"Application Data\", only exchanged after the TLS handshake has been completed, and the initial CertificateRequest occurs during the handshake, before the Application Data is available. Although subsequent opportunities for a TLS client to present a certificate may be available, e.g., via TLS 1.2 renegotiation [RFC5246] or TLS 1.3 post-handshake authentication [RFC8446], this document makes no provision for their usage. It is expected to be common that a mutual-TLS-using resource server will require mutual TLS for all resources hosted thereupon or will serve mutual-TLS-protected and regular resources on separate hostname and port combinations, though other workflows are possible. How resource server policy is synchronized with the authorization server (AS) is out of scope for this document.",
      "ja": "リソースサーバーが証明書にバインドされたアクセストークンを使用するには、一部またはすべてのリソースアクセスに相互TLSが使用されることを事前に知っている必要があります。特に、アクセストークン自体は、（TLSの観点から）「アプリケーションデータ」であり、TLSハンドシェイクの完了後にのみ交換されるため、相互TLSを要求するかどうかの決定への入力として使用できません。 CertificateRequestは、ハンドシェイク中に、アプリケーションデータが利用可能になる前に発生します。 TLSクライアントが証明書を提示する後続の機会は、たとえば、TLS 1.2再ネゴシエーション[RFC5246]またはTLS 1.3ポストハンドシェイク認証[RFC8446]を介して利用できる場合がありますが、このドキュメントではそれらの使用について規定していません。相互TLSを使用するリソースサーバーは、ホストされているすべてのリソースに対して相互TLSを必要とするか、別のホスト名とポートの組み合わせで相互TLSで保護された通常のリソースを提供することが一般的であると予想されますが、他のワークフローも可能です。リソースサーバーポリシーと承認サーバー（AS）の同期方法は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Within the scope of a mutual-TLS-protected resource-access flow, the client makes protected resource requests, as described in [RFC6750], however, those requests MUST be made over a mutually authenticated TLS connection using the same certificate that was used for mutual TLS at the token endpoint.",
      "ja": "相互TLSで保護されたリソースアクセスフローの範囲内で、クライアントは[RFC6750]で説明されているように保護されたリソース要求を行いますが、これらの要求は、使用された同じ証明書を使用して相互認証されたTLS接続で行われなければなりません（MUST） トークンエンドポイントでの相互TLS。"
    },
    {
      "indent": 3,
      "text": "The protected resource MUST obtain, from its TLS implementation layer, the client certificate used for mutual TLS and MUST verify that the certificate matches the certificate associated with the access token. If they do not match, the resource access attempt MUST be rejected with an error, per [RFC6750], using an HTTP 401 status code and the \"invalid_token\" error code.",
      "ja": "保護されたリソースは、そのTLS実装層から相互TLSに使用されるクライアント証明書を取得する必要があり、証明書がアクセストークンに関連付けられた証明書と一致することを確認する必要があります。 それらが一致しない場合、HTTP 401ステータスコードと「invalid_token」エラーコードを使用して、[RFC6750]に従って、エラーでリソースアクセス試行を拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Metadata to convey server and client capabilities for mutual-TLS client certificate-bound access tokens is defined in Sections 3.3 and 3.4, respectively.",
      "ja": "相互TLSクライアント証明書バインドアクセストークンのサーバーおよびクライアント機能を伝達するメタデータは、それぞれセクション3.3および3.4で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.1. JWT Certificate Thumbprint Confirmation Method",
      "section_title": true,
      "ja": "3.1. JWT証明書のprint印の確認方法"
    },
    {
      "indent": 3,
      "text": "When access tokens are represented as JSON Web Tokens (JWT) [RFC7519], the certificate hash information SHOULD be represented using the \"x5t#S256\" confirmation method member defined herein.",
      "ja": "アクセストークンがJSON Web Token（JWT）[RFC7519]として表される場合、証明書ハッシュ情報は、ここで定義された「x5t＃S256」確認メソッドメンバーを使用して表される必要があります。"
    },
    {
      "indent": 3,
      "text": "To represent the hash of a certificate in a JWT, this specification defines the new JWT Confirmation Method [RFC7800] member \"x5t#S256\" for the X.509 Certificate SHA-256 Thumbprint. The value of the \"x5t#S256\" member is a base64url-encoded [RFC4648] SHA-256 [SHS] hash (a.k.a., thumbprint, fingerprint, or digest) of the DER encoding [X690] of the X.509 certificate [RFC5280]. The base64url-encoded value MUST omit all trailing pad '=' characters and MUST NOT include any line breaks, whitespace, or other additional characters.",
      "ja": "JWTの証明書のハッシュを表すために、この仕様では、X.509証明書SHA-256 print印の新しいJWT確認メソッド[RFC7800]メンバー「x5t＃S256」を定義しています。 「x5t＃S256」メンバーの値は、X.509証明書[RFC5280]のDERエンコーディング[X690]のbase64urlエンコード[RFC4648] SHA-256 [SHS]ハッシュ（別名、thumb印、指紋、またはダイジェスト）です。 ]。 base64urlでエンコードされた値は、すべての後続パッド「=」文字を省略しなければならず、改行、空白、またはその他の追加文字を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The following is an example of a JWT payload containing an \"x5t#S256\" certificate thumbprint confirmation method. The new JWT content introduced by this specification is the \"cnf\" confirmation method claim at the bottom of the example that has the \"x5t#S256\" confirmation method member containing the value that is the hash of the client certificate to which the access token is bound.",
      "ja": "以下は、「x5t＃S256」証明書のprint印確認メソッドを含むJWTペイロードの例です。 この仕様で導入された新しいJWTコンテンツは、アクセストークンが属するクライアント証明書のハッシュである値を含む「x5t＃S256」確認メソッドメンバーを持つ、例の下部にある「cnf」確認メソッドクレームです。 バウンド。"
    },
    {
      "indent": 5,
      "text": "{\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2: Example JWT Claims Set with an X.509 Certificate Thumbprint Confirmation Method",
      "ja": "図2：X.509証明書のprint印確認方法が設定されたJWTクレームセットの例"
    },
    {
      "indent": 0,
      "text": "3.2. Confirmation Method for Token Introspection",
      "section_title": true,
      "ja": "3.2. トークンイントロスペクションの確認方法"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 Token Introspection [RFC7662] defines a method for a protected resource to query an authorization server about the active state of an access token as well as to determine metainformation about the token.",
      "ja": "OAuth 2.0トークンイントロスペクション[RFC7662]は、保護されたリソースがアクセストークンのアクティブ状態について認可サーバーに照会し、トークンに関するメタ情報を決定するためのメソッドを定義します。"
    },
    {
      "indent": 3,
      "text": "For a mutual-TLS client certificate-bound access token, the hash of the certificate to which the token is bound is conveyed to the protected resource as metainformation in a token introspection response. The hash is conveyed using the same \"cnf\" with \"x5t#S256\" member structure as the certificate SHA-256 thumbprint confirmation method, described in Section 3.1, as a top-level member of the introspection response JSON. The protected resource compares that certificate hash to a hash of the client certificate used for mutual-TLS authentication and rejects the request if they do not match.",
      "ja": "相互TLSクライアント証明書バインドアクセストークンの場合、トークンがバインドされている証明書のハッシュは、トークンイントロスペクション応答でメタ情報として保護されたリソースに伝達されます。 ハッシュは、イントロスペクション応答JSONの最上位メンバーとして、セクション3.1で説明した証明書SHA-256 print印確認方法と同じ「cn5」と「x5t＃S256」メンバー構造を使用して伝えられます。 保護されたリソースは、その証明書ハッシュを相互TLS認証に使用されるクライアント証明書のハッシュと比較し、一致しない場合は要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "The following is an example of an introspection response for an active token with an \"x5t#S256\" certificate thumbprint confirmation method. The new introspection response content introduced by this specification is the \"cnf\" confirmation method at the bottom of the example that has the \"x5t#S256\" confirmation method member containing the value that is the hash of the client certificate to which the access token is bound.",
      "ja": "「x5t＃S256」証明書のprint印確認方法を使用したアクティブトークンのイントロスペクション応答の例を次に示します。 この仕様によって導入された新しいイントロスペクション応答コンテンツは、アクセストークンが送信されるクライアント証明書のハッシュである値を含む「x5t＃S256」確認メソッドメンバーを持つ、例の下部にある「cnf」確認メソッドです。 バウンド。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Content-Type: application/json",
      "ja": "HTTP / 1.1 200 OKコンテンツタイプ：application / json"
    },
    {
      "indent": 5,
      "text": "{\n  \"active\": true,\n  \"iss\": \"https://server.example.com\",\n  \"sub\": \"ty.webb@example.com\",\n  \"exp\": 1493726400,\n  \"nbf\": 1493722800,\n  \"cnf\":{\n    \"x5t#S256\": \"bwcK0esc3ACC3DB2Y5_lESsXE8o9ltc05O89jdN-dg2\"\n  }\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 3: Example Introspection Response for a Certificate-Bound Access Token",
      "ja": "図3：証明書バインドアクセストークンのイントロスペクション応答の例"
    },
    {
      "indent": 0,
      "text": "3.3. Authorization Server Metadata",
      "section_title": true,
      "ja": "3.3. 認可サーバーのメタデータ"
    },
    {
      "indent": 3,
      "text": "This document introduces the following new authorization server metadata [RFC8414] parameter to signal the server's capability to issue certificate-bound access tokens:",
      "ja": "このドキュメントでは、次の新しい承認サーバーメタデータ[RFC8414]パラメーターを導入して、証明書バインドアクセストークンを発行するサーバーの機能を通知します。"
    },
    {
      "indent": 3,
      "text": "tls_client_certificate_bound_access_tokens OPTIONAL. Boolean value indicating server support for mutual-TLS client certificate-bound access tokens. If omitted, the default value is \"false\".",
      "ja": "tls_client_certificate_bound_access_tokensオプション。 相互TLSクライアント証明書バインドアクセストークンのサーバーサポートを示すブール値。 省略した場合、デフォルト値は「false」です。"
    },
    {
      "indent": 0,
      "text": "3.4. Client Registration Metadata",
      "section_title": true,
      "ja": "3.4. クライアント登録メタデータ"
    },
    {
      "indent": 3,
      "text": "The following new client metadata parameter is introduced to convey the client's intention to use certificate-bound access tokens:",
      "ja": "証明書にバインドされたアクセストークンを使用するというクライアントの意図を伝えるために、次の新しいクライアントメタデータパラメータが導入されました。"
    },
    {
      "indent": 3,
      "text": "tls_client_certificate_bound_access_tokens OPTIONAL. Boolean value used to indicate the client's intention to use mutual-TLS client certificate-bound access tokens. If omitted, the default value is \"false\".",
      "ja": "tls_client_certificate_bound_access_tokensオプション。 相互TLSクライアント証明書バインドアクセストークンを使用するクライアントの意図を示すために使用されるブール値。 省略した場合、デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "Note that if a client that has indicated the intention to use mutual-TLS client certificate-bound tokens makes a request to the token endpoint over a non-mutual-TLS connection, it is at the authorization server's discretion as to whether to return an error or issue an unbound token.",
      "ja": "相互TLSクライアント証明書バインドトークンを使用する意図を示したクライアントが、非相互TLS接続を介してトークンエンドポイントに要求を行う場合、エラーを返すかどうかについては承認サーバーの裁量であることに注意してください。 または、バインドされていないトークンを発行します。"
    },
    {
      "indent": 0,
      "text": "4. Public Clients and Certificate-Bound Tokens",
      "section_title": true,
      "ja": "4. パブリッククライアントと証明書バインドトークン"
    },
    {
      "indent": 3,
      "text": "Mutual-TLS OAuth client authentication and certificate-bound access tokens can be used independently of each other. Use of certificate-bound access tokens without mutual-TLS OAuth client authentication, for example, is possible in support of binding access tokens to a TLS client certificate for public clients (those without authentication credentials associated with the \"client_id\"). The authorization server would configure the TLS stack in the same manner as for the Self-Signed Certificate method such that it does not verify that the certificate presented by the client during the handshake is signed by a trusted CA. Individual instances of a client would create a self-signed certificate for mutual TLS with both the authorization server and resource server. The authorization server would not use the mutual-TLS certificate to authenticate the client at the OAuth layer but would bind the issued access token to the certificate for which the client has proven possession of the corresponding private key. The access token is then bound to the certificate and can only be used by the client possessing the certificate and corresponding private key and utilizing them to negotiate mutual TLS on connections to the resource server. When the authorization server issues a refresh token to such a client, it SHOULD also bind the refresh token to the respective certificate and check the binding when the refresh token is presented to get new access tokens. The implementation details of the binding of the refresh token are at the discretion of the authorization server.",
      "ja": "相互TLS OAuthクライアント認証と証明書バインドアクセストークンは、互いに独立して使用できます。たとえば、相互TLS OAuthクライアント認証なしの証明書バインドアクセストークンの使用は、パブリッククライアント（「client_id」に関連付けられた認証資格情報のないもの）のTLSクライアント証明書へのアクセストークンのバインドのサポートで可能です。承認サーバーは、自己署名証明書方式と同じ方法でTLSスタックを構成し、ハンドシェイク中にクライアントによって提示された証明書が信頼できるCAによって署名されていることを検証しません。クライアントの個々のインスタンスは、承認サーバーとリソースサーバーの両方との相互TLS用の自己署名証明書を作成します。認可サーバーは、相互TLS証明書を使用してOAuthレイヤーでクライアントを認証しませんが、発行されたアクセストークンを、クライアントが対応する秘密キーを所有していることが証明された証明書にバインドします。その後、アクセストークンは証明書にバインドされ、証明書と対応する秘密キーを所有し、それらを利用してリソースサーバーへの接続で相互TLSをネゴシエートするクライアントのみが使用できます。認可サーバーがそのようなクライアントにリフレッシュトークンを発行する場合、リフレッシュトークンをそれぞれの証明書にバインドし、新しいアクセストークンを取得するためにリフレッシュトークンが提示されたときにバインディングをチェックする必要があります。リフレッシュトークンのバインディングの実装の詳細は、承認サーバーの裁量によります。"
    },
    {
      "indent": 0,
      "text": "5. Metadata for Mutual-TLS Endpoint Aliases",
      "section_title": true,
      "ja": "5. 相互TLSエンドポイントエイリアスのメタデータ"
    },
    {
      "indent": 3,
      "text": "The process of negotiating client certificate-based mutual TLS involves a TLS server requesting a certificate from the TLS client (the client does not provide one unsolicited). Although a server can be configured such that client certificates are optional, meaning that the connection is allowed to continue when the client does not provide a certificate, the act of a server requesting a certificate can result in undesirable behavior from some clients. This is particularly true of web browsers as TLS clients, which will typically present the end user with an intrusive certificate selection interface when the server requests a certificate.",
      "ja": "クライアント証明書ベースの相互TLSをネゴシエートするプロセスには、TLSクライアントからの証明書を要求するTLSサーバーが含まれます（クライアントは一方的な非送信請求を提供しません）。 クライアント証明書がオプションであるようにサーバーを構成できます。つまり、クライアントが証明書を提供しない場合でも接続を継続できますが、サーバーが証明書を要求すると、一部のクライアントから望ましくない動作が発生する可能性があります。 これは、TLSクライアントとしてのWebブラウザに特に当てはまります。TLSクライアントは、通常、サーバーが証明書を要求したときに、侵入的な証明書選択インターフェイスをエンドユーザーに提示します。"
    },
    {
      "indent": 3,
      "text": "Authorization servers supporting both clients using mutual TLS and conventional clients MAY chose to isolate the server side mutual-TLS behavior to only clients intending to do mutual TLS, thus avoiding any undesirable effects it might have on conventional clients. The following authorization server metadata parameter is introduced to facilitate such separation:",
      "ja": "相互TLSを使用するクライアントと従来のクライアントの両方をサポートする承認サーバーは、相互TLSを実行しようとするクライアントのみにサーバー側の相互TLS動作を分離することを選択できます。これにより、従来のクライアントに及ぼす可能性のある望ましくない影響を回避できます。 このような分離を容易にするために、次の許可サーバーメタデータパラメーターが導入されています。"
    },
    {
      "indent": 3,
      "text": "mtls_endpoint_aliases OPTIONAL. A JSON object containing alternative authorization server endpoints that, when present, an OAuth client intending to do mutual TLS uses in preference to the conventional endpoints. The parameter value itself consists of one or more endpoint parameters, such as \"token_endpoint\", \"revocation_endpoint\", \"introspection_endpoint\", etc., conventionally defined for the top level of authorization server metadata. An OAuth client intending to do mutual TLS (for OAuth client authentication and/or to acquire or use certificate-bound tokens) when making a request directly to the authorization server MUST use the alias URL of the endpoint within the \"mtls_endpoint_aliases\", when present, in preference to the endpoint URL of the same name at the top level of metadata. When an endpoint is not present in \"mtls_endpoint_aliases\", then the client uses the conventional endpoint URL defined at the top level of the authorization server metadata. Metadata parameters within \"mtls_endpoint_aliases\" that do not define endpoints to which an OAuth client makes a direct request have no meaning and SHOULD be ignored.",
      "ja": "mtls_endpoint_aliasesオプション。代替の承認サーバーエンドポイントを含むJSONオブジェクト。存在する場合、従来のエンドポイントより優先して相互TLSを実行しようとするOAuthクライアントが使用します。パラメーター値自体は、「token_endpoint」、「revocation_endpoint」、「introspection_endpoint」などのように1つ以上のエンドポイントパラメーターで構成されます。これらは、承認サーバーメタデータの最上位レベルに対して従来定義されています。認可サーバーに直接リクエストを行うときに、相互TLSを実行する（OAuthクライアント認証および/または証明書バインドトークンを取得または使用する）OAuthクライアントは、「mtls_endpoint_aliases」内のエンドポイントのエイリアスURLを使用する必要があります、メタデータの最上位にある同じ名前のエンドポイントURLよりも優先されます。エンドポイントが「mtls_endpoint_aliases」に存在しない場合、クライアントは承認サーバーメタデータの最上位レベルで定義された従来のエンドポイントURLを使用します。 Omtクライアントが直接リクエストを行うエンドポイントを定義しない「mtls_endpoint_aliases」内のメタデータパラメータには意味がなく、無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Below is an example of an authorization server metadata document with the \"mtls_endpoint_aliases\" parameter, which indicates aliases for the token, revocation, and introspection endpoints that an OAuth client intending to do mutual TLS would use in preference to the conventional token, revocation, and introspection endpoints. Note that the endpoints in \"mtls_endpoint_aliases\" use a different host than their conventional counterparts, which allows the authorization server (via TLS \"server_name\" extension [RFC6066] or actual distinct hosts) to differentiate its TLS behavior as appropriate.",
      "ja": "相互TLSを実行しようとするOAuthクライアントが従来のトークン、失効、および優先度で使用するトークン、失効、およびイントロスペクションエンドポイントのエイリアスを示す、「mtls_endpoint_aliases」パラメーターを含む承認サーバーメタデータドキュメントの例を次に示します。 イントロスペクションのエンドポイント。 「mtls_endpoint_aliases」のエンドポイントは従来の対応するホストとは異なるホストを使用するため、承認サーバーは（TLS「server_name」拡張[RFC6066]または実際の個別ホストを介して）TLS動作を適切に区別できます。"
    },
    {
      "indent": 3,
      "text": "{\n  \"issuer\": \"https://server.example.com\",\n  \"authorization_endpoint\": \"https://server.example.com/authz\",\n  \"token_endpoint\": \"https://server.example.com/token\",\n  \"introspection_endpoint\": \"https://server.example.com/introspect\",\n  \"revocation_endpoint\": \"https://server.example.com/revo\",\n  \"jwks_uri\": \"https://server.example.com/jwks\",\n  \"response_types_supported\": [\"code\"],\n  \"response_modes_supported\": [\"fragment\",\"query\",\"form_post\"],\n  \"grant_types_supported\": [\"authorization_code\", \"refresh_token\"],\n  \"token_endpoint_auth_methods_supported\":\n                  [\"tls_client_auth\",\"client_secret_basic\",\"none\"],\n  \"tls_client_certificate_bound_access_tokens\": true,\n  \"mtls_endpoint_aliases\": {\n    \"token_endpoint\": \"https://mtls.example.com/token\",\n    \"revocation_endpoint\": \"https://mtls.example.com/revo\",\n    \"introspection_endpoint\": \"https://mtls.example.com/introspect\"\n  }\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 4: Example Authorization Server Metadata with Mutual-TLS Endpoint Aliases",
      "ja": "図4：相互TLSエンドポイントエイリアスを使用した認可サーバーメタデータの例"
    },
    {
      "indent": 0,
      "text": "6. Implementation Considerations",
      "section_title": true,
      "ja": "6. 実装に関する考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Authorization Server",
      "section_title": true,
      "ja": "6.1. 認可サーバー"
    },
    {
      "indent": 3,
      "text": "The authorization server needs to set up its TLS configuration appropriately for the OAuth client authentication methods it supports.",
      "ja": "承認サーバーは、サポートするOAuthクライアント認証方法に合わせてTLS構成を適切にセットアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "An authorization server that supports mutual-TLS client authentication and other client authentication methods or public clients in parallel would make mutual TLS optional (i.e., allowing a handshake to continue after the server requests a client certificate but the client does not send one).",
      "ja": "相互TLSクライアント認証と他のクライアント認証方法またはパブリッククライアントを並行してサポートする承認サーバーは、相互TLSをオプションにします（つまり、サーバーがクライアント証明書を要求したが、クライアントが証明書を送信しない後もハンドシェイクを続行できるようにします）。"
    },
    {
      "indent": 3,
      "text": "In order to support the Self-Signed Certificate method alone, the authorization server would configure the TLS stack in such a way that it does not verify whether the certificate presented by the client during the handshake is signed by a trusted CA certificate.",
      "ja": "自己署名証明書方式のみをサポートするために、承認サーバーは、ハンドシェイク中にクライアントによって提示された証明書が信頼できるCA証明書によって署名されているかどうかを検証しないようにTLSスタックを構成します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, the authorization server binds the issued access token to the TLS client certificate, which means that it will only issue certificate-bound tokens for a certificate that the client has proven possession of the corresponding private key.",
      "ja": "セクション3で説明したように、承認サーバーは発行されたアクセストークンをTLSクライアント証明書にバインドします。つまり、クライアントが対応する秘密キーを所有していることが証明された証明書の証明書バインドトークンのみを発行します。"
    },
    {
      "indent": 3,
      "text": "The authorization server may also consider hosting the token endpoint and other endpoints requiring client authentication on a separate host name or port in order to prevent unintended impact on the TLS behavior of its other endpoints, e.g., the authorization endpoint. As described in Section 5, it may further isolate any potential impact of the server requesting client certificates by offering a distinct set of endpoints on a separate host or port, which are aliases for the originals that a client intending to do mutual TLS will use in preference to the conventional endpoints.",
      "ja": "承認サーバーは、他のエンドポイント（承認エンドポイントなど）のTLS動作への意図しない影響を防ぐために、トークンエンドポイントおよび別のホスト名またはポートでクライアント認証を必要とする他のエンドポイントをホストすることも検討できます。 セクション5で説明したように、個別のホストまたはポート上にエンドポイントの別個のセットを提供することにより、サーバーがクライアント証明書を要求する潜在的な影響をさらに分離できます。エンドポイントは、相互TLSを実行しようとするクライアントが使用する元のエイリアスです 従来のエンドポイントよりも優先されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Resource Server",
      "section_title": true,
      "ja": "6.2. リソースサーバー"
    },
    {
      "indent": 3,
      "text": "OAuth divides the roles and responsibilities such that the resource server relies on the authorization server to perform client authentication and obtain resource-owner (end-user) authorization. The resource server makes authorization decisions based on the access token presented by the client but does not directly authenticate the client per se. The manner in which an access token is bound to the client certificate and how a protected resource verifies the proof-of-possession decouples that from the specific method that the client used to authenticate with the authorization server. Mutual TLS during protected resource access can, therefore, serve purely as a proof-of-possession mechanism. As such, it is not necessary for the resource server to validate the trust chain of the client's certificate in any of the methods defined in this document. The resource server would, therefore, configure the TLS stack in a way that it does not verify whether the certificate presented by the client during the handshake is signed by a trusted CA certificate.",
      "ja": "OAuthは、リソースサーバーが承認サーバーに依存してクライアント認証を実行し、リソース所有者（エンドユーザー）の承認を取得するように、役割と責任を分割します。リソースサーバーは、クライアントから提示されたアクセストークンに基づいて承認を決定しますが、クライアント自体を直接認証することはありません。アクセストークンがクライアント証明書にバインドされる方法と、保護されたリソースが所有証明を検証する方法は、クライアントが許可サーバーで認証するために使用した特定の方法からそれを切り離します。したがって、保護されたリソースアクセス中の相互TLSは、純粋に所有の証明メカニズムとして機能します。そのため、リソースサーバーは、このドキュメントで定義されているメソッドのいずれかでクライアントの証明書の信頼チェーンを検証する必要はありません。したがって、リソースサーバーは、ハンドシェイク中にクライアントから提示された証明書が信頼できるCA証明書によって署名されているかどうかを検証しない方法でTLSスタックを構成します。"
    },
    {
      "indent": 0,
      "text": "6.3. Certificate Expiration and Bound Access Tokens",
      "section_title": true,
      "ja": "6.3. 証明書の有効期限とバインドされたアクセストークン"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, an access token is bound to a specific client certificate, which means that the same certificate must be used for mutual TLS on protected resource access. It also implies that access tokens are invalidated when a client updates the certificate, which can be handled similarly to expired access tokens where the client requests a new access token (typically with a refresh token) and retries the protected resource request.",
      "ja": "セクション3で説明したように、アクセストークンは特定のクライアント証明書にバインドされます。つまり、同じ証明書を保護されたリソースアクセスの相互TLSに使用する必要があります。 また、クライアントが証明書を更新するとアクセストークンが無効になることも意味します。これは、クライアントが新しいアクセストークンを要求し（通常は更新トークンを使用）、保護されたリソース要求を再試行する期限切れのアクセストークンと同様に処理できます。"
    },
    {
      "indent": 0,
      "text": "6.4. Implicit Grant Unsupported",
      "section_title": true,
      "ja": "6.4. 暗黙的な補助金はサポートされていません"
    },
    {
      "indent": 3,
      "text": "This document describes binding an access token to the client certificate presented on the TLS connection from the client to the authorization server's token endpoint, however, such binding of access tokens issued directly from the authorization endpoint via the implicit grant flow is explicitly out of scope. End users interact directly with the authorization endpoint using a web browser, and the use of client certificates in user's browsers bring operational and usability issues that make it undesirable to support certificate-bound access tokens issued in the implicit grant flow. Implementations wanting to employ certificate-bound access tokens should utilize grant types that involve the client making an access token request directly to the token endpoint (e.g., the authorization code and refresh token grant types).",
      "ja": "このドキュメントでは、クライアントから承認サーバーのトークンエンドポイントへのTLS接続で提示されるクライアント証明書へのアクセストークンのバインドについて説明しますが、暗黙的な許可フローを介して承認エンドポイントから直接発行されたアクセストークンのこのようなバインドは、明示的に範囲外です。 エンドユーザーは、Webブラウザーを使用して承認エンドポイントと直接対話します。ユーザーのブラウザーでクライアント証明書を使用すると、操作上の問題と使いやすさの問題が発生し、暗黙的な許可フローで発行された証明書バインドアクセストークンのサポートが望ましくなくなります。 証明書にバインドされたアクセストークンを使用したい実装では、クライアントがトークンエンドポイントに直接アクセストークンリクエストを行うことを含む許可タイプ（認証コードや更新トークン許可タイプなど）を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. TLS Termination",
      "section_title": true,
      "ja": "6.5. TLS終了"
    },
    {
      "indent": 3,
      "text": "An authorization server or resource server MAY choose to terminate TLS connections at a load balancer, reverse proxy, or other network intermediary. How the client certificate metadata is securely communicated between the intermediary and the application server, in this case, is out of scope of this specification.",
      "ja": "認可サーバーまたはリソースサーバーは、ロードバランサー、リバースプロキシ、または他のネットワーク仲介者でTLS接続を終了することを選択できます。 この場合、クライアント証明書メタデータが中間サーバーとアプリケーションサーバー間で安全に通信される方法は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Certificate-Bound Refresh Tokens",
      "section_title": true,
      "ja": "7.1. 証明書バインドリフレッシュトークン"
    },
    {
      "indent": 3,
      "text": "The OAuth 2.0 Authorization Framework [RFC6749] requires that an authorization server (AS) bind refresh tokens to the client to which they were issued and that confidential clients (those having established authentication credentials with the AS) authenticate to the AS when presenting a refresh token. As a result, refresh tokens are indirectly certificate-bound by way of the client ID and the associated requirement for (certificate-based) authentication to the AS when issued to clients utilizing the \"tls_client_auth\" or \"self_signed_tls_client_auth\" methods of client authentication. Section 4 describes certificate-bound refresh tokens issued to public clients (those without authentication credentials associated with the \"client_id\").",
      "ja": "OAuth 2.0承認フレームワーク[RFC6749]では、承認サーバー（AS）が発行されたクライアントに更新トークンをバインドし、更新トークンを提示するときに機密クライアント（ASで認証資格を確立したクライアント）がASを認証する必要があります 。 その結果、クライアントトークンの「tls_client_auth」または「self_signed_tls_client_auth」メソッドを使用してクライアントに発行された場合、リフレッシュトークンは、クライアントIDおよびASへの（証明書ベースの）認証の関連要件によって間接的に証明書バインドされます。 セクション4では、パブリッククライアント（「client_id」に関連付けられた認証資格情報のないクライアント）に発行された証明書バインドリフレッシュトークンについて説明します。"
    },
    {
      "indent": 0,
      "text": "7.2. Certificate Thumbprint Binding",
      "section_title": true,
      "ja": "7.2. 証明書のprint印のバインド"
    },
    {
      "indent": 3,
      "text": "The binding between the certificate and access token specified in Section 3.1 uses a cryptographic hash of the certificate. It relies on the hash function having sufficient second-preimage resistance so as to make it computationally infeasible to find or create another certificate that produces to the same hash output value. The SHA-256 hash function was used because it meets the aforementioned requirement while being widely available. If, in the future, certificate thumbprints need to be computed using hash function(s) other than SHA-256, it is suggested that, for additional related JWT confirmation methods, members be defined for that purpose and registered in the IANA \"JWT Confirmation Methods\" registry [IANA.JWT.Claims] for JWT \"cnf\" member values.",
      "ja": "セクション3.1で指定された証明書とアクセストークンのバインドでは、証明書の暗号化ハッシュを使用します。 同じハッシュ出力値を生成する別の証明書を見つけたり作成したりするのが計算上実行不可能になるように、十分な2次プリイメージ耐性を持つハッシュ関数に依存しています。 SHA-256ハッシュ関数が使用されたのは、広く利用可能であると同時に前述の要件を満たしているためです。 将来、SHA-256以外のハッシュ関数を使用して証明書のprint印を計算する必要がある場合は、追加の関連JWT確認方法について、その目的のためにメンバーを定義し、IANAの「JWT確認」に登録することをお勧めします JWT「cnf」メンバー値用のメソッド」レジストリ[IANA.JWT.Claims]。"
    },
    {
      "indent": 3,
      "text": "Community knowledge about the strength of various algorithms and feasible attacks can change suddenly, and experience shows that a document about security is a point-in-time statement. Readers are advised to seek out any errata or updates that apply to this document.",
      "ja": "さまざまなアルゴリズムの強さおよび実行可能な攻撃に関するコミュニティの知識は突然変化する可能性があり、経験から、セキュリティに関するドキュメントは特定の時点のステートメントであることがわかります。 読者は、このドキュメントに適用されるエラッタまたはアップデートを探すことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.3. TLS Versions and Best Practices",
      "section_title": true,
      "ja": "7.3. TLSバージョンとベストプラクティス"
    },
    {
      "indent": 3,
      "text": "This document is applicable with any TLS version supporting certificate-based client authentication. Both TLS 1.3 [RFC8446] and TLS 1.2 [RFC5246] are cited herein, because, at the time of writing, 1.3 is the newest version, while 1.2 is the most widely deployed. General implementation and security considerations for TLS, including version recommendations, can be found in [BCP195].",
      "ja": "このドキュメントは、証明書ベースのクライアント認証をサポートするすべてのTLSバージョンに適用できます。 TLS 1.3 [RFC8446]とTLS 1.2 [RFC5246]の両方がここに引用されています。これは、執筆時点で1.3が最新バージョンであり、1.2が最も広く展開されているためです。 バージョン推奨を含む、TLSの一般的な実装とセキュリティの考慮事項は[BCP195]にあります。"
    },
    {
      "indent": 3,
      "text": "TLS certificate validation (for both client and server certificates) requires a local database of trusted certificate authorities (CAs). Decisions about what CAs to trust and how to make such a determination of trust are out of scope for this document.",
      "ja": "TLS証明書の検証（クライアント証明書とサーバー証明書の両方）には、信頼できる認証局（CA）のローカルデータベースが必要です。 信頼するCAとそのような信頼の決定を行う方法に関する決定は、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "7.4. X.509 Certificate Spoofing",
      "section_title": true,
      "ja": "7.4. X.509証明書のなりすまし"
    },
    {
      "indent": 3,
      "text": "If the PKI method of client authentication is used, an attacker could try to impersonate a client using a certificate with the same subject (DN or SAN) but issued by a different CA that the authorization server trusts. To cope with that threat, the authorization server SHOULD only accept, as trust anchors, a limited number of CAs whose certificate issuance policy meets its security requirements. There is an assumption then that the client and server agree out of band on the set of trust anchors that the server uses to create and validate the certificate chain. Without this assumption the use of a subject to identify the client certificate would open the server up to certificate spoofing attacks.",
      "ja": "クライアント認証のPKI方式が使用されている場合、攻撃者は、同じサブジェクト（DNまたはSAN）を持つ証明書を使用してクライアントを偽装しようとする可能性があります。 その脅威に対処するため、認可サーバーは、証明書の発行ポリシーがセキュリティ要件を満たす限られた数のCAのみをトラストアンカーとして受け入れる必要があります。 クライアントとサーバーは、サーバーが証明書チェーンの作成と検証に使用するトラストアンカーのセットで帯域外で合意しているという前提があります。 この前提がないと、クライアント証明書を識別するためにサブジェクトを使用すると、サーバーが証明書のなりすまし攻撃を受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.5. X.509 Certificate Parsing and Validation Complexity",
      "section_title": true,
      "ja": "7.5. X.509証明書の解析と検証の複雑さ"
    },
    {
      "indent": 3,
      "text": "Parsing and validation of X.509 certificates and certificate chains is complex, and implementation mistakes have previously exposed security vulnerabilities. Complexities of validation include (but are not limited to) [CX5P] [DCW] [RFC5280]:",
      "ja": "X.509証明書と証明書チェーンの解析と検証は複雑であり、実装の誤りによりセキュリティの脆弱性が以前に公開されていました。 検証の複雑性には次のものが含まれます（ただし、これらに限定されません）[CX5P] [DCW] [RFC5280]："
    },
    {
      "indent": 3,
      "text": "* checking of basic constraints, basic and extended key usage constraints, validity periods, and critical extensions;",
      "ja": "* 基本的な制約、基本的および拡張されたキー使用の制約、有効期間、および重要な拡張のチェック。"
    },
    {
      "indent": 3,
      "text": "* handling of embedded NUL bytes in ASN.1 counted-length strings and non-canonical or non-normalized string representations in subject names;",
      "ja": "* ASN.1のカウントされた長さの文字列に埋め込まれたNULバイトと、サブジェクト名の非正規または非正規化文字列表現の処理。"
    },
    {
      "indent": 3,
      "text": "* handling of wildcard patterns in subject names;",
      "ja": "* サブジェクト名のワイルドカードパターンの処理。"
    },
    {
      "indent": 3,
      "text": "* recursive verification of certificate chains and checking certificate revocation.",
      "ja": "* 証明書チェーンの再帰的検証と証明書失効の確認。"
    },
    {
      "indent": 3,
      "text": "For these reasons, implementors SHOULD use an established and well-tested X.509 library (such as one used by an established TLS library) for validation of X.509 certificate chains and SHOULD NOT attempt to write their own X.509 certificate validation procedures.",
      "ja": "これらの理由により、実装者は、X.509証明書チェーンの検証に、確立され十分にテストされたX.509ライブラリ（確立されたTLSライブラリで使用されるライブラリなど）を使用する必要があり（SHOULD NOT）、独自のX.509証明書検証手順を記述しないでください 。"
    },
    {
      "indent": 0,
      "text": "8. Privacy Considerations",
      "section_title": true,
      "ja": "8. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In TLS versions prior to 1.3, the client's certificate is sent unencrypted in the initial handshake and can potentially be used by third parties to monitor, track, and correlate client activity. This is likely of little concern for clients that act on behalf of a significant number of end users because individual user activity will not be discernible amidst the client activity as a whole. However, clients that act on behalf of a single end user, such as a native application on a mobile device, should use TLS version 1.3 whenever possible or consider the potential privacy implications of using mutual TLS on earlier versions.",
      "ja": "1.3より前のTLSバージョンでは、クライアントの証明書は最初のハンドシェイクで暗号化されずに送信され、クライアントアクティビティを監視、追跡、および相関させるためにサードパーティによって使用される可能性があります。 個々のユーザーアクティビティは、クライアントアクティビティ全体では識別できないため、これは、かなりの数のエンドユーザーに代わって行動するクライアントにとってはほとんど問題になりません。 ただし、モバイルデバイスのネイティブアプリケーションなど、単一のエンドユーザーに代わって動作するクライアントは、可能な限りTLSバージョン1.3を使用するか、以前のバージョンで相互TLSを使用する場合のプライバシーへの影響を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. JWT Confirmation Methods Registration",
      "section_title": true,
      "ja": "9.1. JWT確認方法の登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following value has been registered in the IANA \"JWT Confirmation Methods\" registry [IANA.JWT.Claims] for JWT \"cnf\" member values established by [RFC7800].",
      "ja": "この仕様に従って、[RFC7800]によって確立されたJWT \"cnf\"メンバー値に対して、次の値がIANA \"JWT Confirmation Methods\"レジストリ[IANA.JWT.Claims]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Confirmation Method Value:  \"x5t#S256\"\nConfirmation Method Description:  X.509 Certificate SHA-256\n   Thumbprint\nChange Controller:  IESG\nSpecification Document(s):  Section 3.1 of RFC 8705",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.2. Authorization Server Metadata Registration",
      "section_title": true,
      "ja": "9.2. 認可サーバーのメタデータ登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following values have been registered in the IANA \"OAuth Authorization Server Metadata\" registry [IANA.OAuth.Parameters] established by [RFC8414].",
      "ja": "この仕様に従って、次の値が[RFC8414]によって確立されたIANA \"OAuth Authorization Server Metadata\"レジストリ[IANA.OAuth.Parameters]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Metadata Name: \"tls_client_certificate_bound_access_tokens\" Metadata Description: Indicates authorization server support for mutual-TLS client certificate-bound access tokens. Change Controller: IESG Specification Document(s): Section 3.3 of RFC 8705",
      "ja": "メタデータ名： \"tls_client_certificate_bound_access_tokens\"メタデータの説明：相互TLSクライアント証明書バインドアクセストークンに対する承認サーバーのサポートを示します。 コントローラーの変更：IESG仕様書：RFC 8705のセクション3.3"
    },
    {
      "indent": 3,
      "text": "Metadata Name: \"mtls_endpoint_aliases\" Metadata Description: JSON object containing alternative authorization server endpoints, which a client intending to do mutual TLS will use in preference to the conventional endpoints. Change Controller: IESG Specification Document(s): Section 5 of RFC 8705",
      "ja": "メタデータ名： \"mtls_endpoint_aliases\"メタデータの説明：代替TLSサーバーエンドポイントを含むJSONオブジェクト。相互TLSを実行しようとするクライアントは、従来のエンドポイントよりも優先して使用します。 コントローラーの変更：IESG仕様書：RFC 8705のセクション5"
    },
    {
      "indent": 0,
      "text": "9.3. Token Endpoint Authentication Method Registration",
      "section_title": true,
      "ja": "9.3. トークンエンドポイント認証方法の登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following values have been registered in the IANA \"OAuth Token Endpoint Authentication Methods\" registry [IANA.OAuth.Parameters] established by [RFC7591].",
      "ja": "この仕様に従って、次の値が[RFC7591]によって確立されたIANA「OAuthトークンエンドポイント認証方法」レジストリ[IANA.OAuth.Parameters]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Token Endpoint Authentication Method Name:  \"tls_client_auth\"\nChange Controller:  IESG\nSpecification Document(s):  Section 2.1.1 of RFC 8705",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Token Endpoint Authentication Method Name: \"self_signed_tls_client_ auth\" Change Controller: IESG Specification Document(s): Section 2.2.1 of RFC 8705",
      "ja": "トークンエンドポイント認証メソッド名： \"self_signed_tls_client_ auth\"変更コントローラー：IESG仕様ドキュメント：RFC 8705のセクション2.2.1"
    },
    {
      "indent": 0,
      "text": "9.4. Token Introspection Response Registration",
      "section_title": true,
      "ja": "9.4. トークンイントロスペクション応答登録"
    },
    {
      "indent": 3,
      "text": "\"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\" [RFC7800] defined the \"cnf\" (confirmation) claim that enables confirmation key information to be carried in a JWT. However, the same proof-of-possession semantics are also useful for introspected access tokens whereby the protected resource obtains the confirmation key data as metainformation of a token introspection response and uses that information in verifying proof-of-possession. Therefore, this specification defines and registers proof-of-possession semantics for OAuth 2.0 Token Introspection [RFC7662] using the \"cnf\" structure. When included as a top-level member of an OAuth token introspection response, \"cnf\" has the same semantics and format as the claim of the same name defined in [RFC7800]. While this specification only explicitly uses the \"x5t#S256\" confirmation method member (see Section 3.2), it needs to define and register the higher-level \"cnf\" structure as an introspection response member in order to define and use the more specific certificate thumbprint confirmation method.",
      "ja": "「JSON Webトークン（JWT）の所有権証明キーセマンティクス」[RFC7800]は、確認キー情報をJWTで伝送できるようにする「cnf」（確認）クレームを定義しました。ただし、同じ所有証明のセマンティクスは、保護されたリソースがトークンイントロスペクションレスポンスのメタ情報として確認キーデータを取得し、その情報を所有証明の検証に使用するイントロスペクトアクセストークンにも役立ちます。したがって、この仕様では、「cnf」構造を使用して、OAuth 2.0トークンイントロスペクション[RFC7662]の所有権証明のセマンティクスを定義および登録します。 Ocnトークンイントロスペクションレスポンスのトップレベルメンバーとして含まれる場合、「cnf」は、[RFC7800]で定義された同じ名前のクレームと同じセマンティクスと形式を持ちます。この仕様では「x5t＃S256」確認メソッドメンバーのみを明示的に使用しますが（セクション3.2を参照）、より具体的な証明書を定義および使用するには、上位レベルの「cnf」構造をイントロスペクション応答メンバーとして定義および登録する必要がありますthumb印の確認方法。"
    },
    {
      "indent": 3,
      "text": "As such, the following values have been registered in the IANA \"OAuth Token Introspection Response\" registry [IANA.OAuth.Parameters] established by [RFC7662].",
      "ja": "そのため、次の値が[RFC7662]によって確立されたIANA \"OAuth Token Introspection Response\"レジストリ[IANA.OAuth.Parameters]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Claim Name:  \"cnf\"\nClaim Description:  Confirmation\nChange Controller:  IESG\nSpecification Document(s):  [RFC7800] and RFC 8705",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.5. Dynamic Client Registration Metadata Registration",
      "section_title": true,
      "ja": "9.5. 動的クライアント登録メタデータ登録"
    },
    {
      "indent": 3,
      "text": "Per this specification, the following client metadata definitions have been registered in the IANA \"OAuth Dynamic Client Registration Metadata\" registry [IANA.OAuth.Parameters] established by [RFC7591]:",
      "ja": "この仕様に従って、次のクライアントメタデータ定義が、[RFC7591]によって確立されたIANA「OAuth動的クライアント登録メタデータ」レジストリ[IANA.OAuth.Parameters]に登録されています。"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_certificate_bound_access_tokens\" Client Metadata Description: Indicates the client's intention to use mutual-TLS client certificate-bound access tokens. Change Controller: IESG Specification Document(s): Section 3.4 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_certificate_bound_access_tokens\"クライアントメタデータの説明：相互TLSクライアント証明書バインドアクセストークンを使用するクライアントの意図を示します。 変更コントローラ：IESG仕様ドキュメント：RFC 8705のセクション3.4"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_subject_dn\" Client Metadata Description: String value specifying the expected subject DN of the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_subject_dn\"クライアントメタデータ説明：クライアント証明書の予想されるサブジェクトDNを指定する文字列値。 コントローラの変更：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_dns\" Client Metadata Description: String value specifying the expected dNSName SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_san_dns\"クライアントメタデータの説明：クライアント証明書の期待されるdNSName SANエントリを指定する文字列値。 コントローラの変更：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_uri\" Client Metadata Description: String value specifying the expected uniformResourceIdentifier SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_san_uri\"クライアントメタデータ説明：クライアント証明書内の予想されるuniformResourceIdentifier SANエントリを指定する文字列値。 コントローラの変更：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_ip\" Client Metadata Description: String value specifying the expected iPAddress SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_san_ip\"クライアントメタデータの説明：クライアント証明書の予想されるiPAddress SANエントリを指定する文字列値。 コントローラの変更：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: \"tls_client_auth_san_email\" Client Metadata Description: String value specifying the expected rfc822Name SAN entry in the client certificate. Change Controller: IESG Specification Document(s): Section 2.1.2 of RFC 8705",
      "ja": "クライアントメタデータ名： \"tls_client_auth_san_email\"クライアントメタデータの説明：クライアント証明書の予想されるrfc822Name SANエントリを指定する文字列値。 コントローラの変更：IESG仕様書：RFC 8705のセクション2.1.2"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, May 2015, <https://www.rfc-editor.org/info/bcp195>.",
      "ja": "[BCP195] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、2015年5月 、<https://www.rfc-editor.org/info/bcp195>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4514] Zeilenga, K., Ed., \"Lightweight Directory Access Protocol (LDAP): String Representation of Distinguished Names\", RFC 4514, DOI 10.17487/RFC4514, June 2006, <https://www.rfc-editor.org/info/rfc4514>.",
      "ja": "[RFC4514] Zeilenga、K.、Ed。、「ライトウェイトディレクトリアクセスプロトコル（LDAP）：識別名の文字列表現」、RFC 4514、DOI 10.17487 / RFC4514、2006年6月、<https://www.rfc-editor.org / info / rfc4514>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <https://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<https://www.rfc-editor.org/info / rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、W. Polk、 \"インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル \"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <https://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749] Hardt、D.、Ed。、「The OAuth 2.0 Authorization Framework」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<https://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, DOI 10.17487/RFC6750, October 2012, <https://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M。およびD.ハード、「OAuth 2.0認可フレームワーク：ベアラートークンの使用」、RFC 6750、DOI 10.17487 / RFC6750、2012年10月、<https://www.rfc-editor.org/info/ rfc6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <https://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M。、「JSON Web Key（JWK）」、RFC 7517、DOI 10.17487 / RFC7517、2015年5月、<https://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <https://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519]ジョーンズ、M。、ブラッドリー、J。、およびN.サキムラ、「JSON Web Token（JWT）」、RFC 7519、DOI 10.17487 / RFC7519、2015年5月、<https://www.rfc-editor.org / info / rfc7519>。"
    },
    {
      "indent": 3,
      "text": "[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, \"OAuth 2.0 Dynamic Client Registration Protocol\", RFC 7591, DOI 10.17487/RFC7591, July 2015, <https://www.rfc-editor.org/info/rfc7591>.",
      "ja": "[RFC7591] Richer、J.、Ed。、Jones、M.、Bradley、J.、Machulak、M。、およびP. Hunt、「OAuth 2.0動的クライアント登録プロトコル」、RFC 7591、DOI 10.17487 / RFC7591、2015年7月 、<https://www.rfc-editor.org/info/rfc7591>。"
    },
    {
      "indent": 3,
      "text": "[RFC7662] Richer, J., Ed., \"OAuth 2.0 Token Introspection\", RFC 7662, DOI 10.17487/RFC7662, October 2015, <https://www.rfc-editor.org/info/rfc7662>.",
      "ja": "[RFC7662] Richer、J.、Ed。、「OAuth 2.0 Token Introspection」、RFC 7662、DOI 10.17487 / RFC7662、2015年10月、<https://www.rfc-editor.org/info/rfc7662>。"
    },
    {
      "indent": 3,
      "text": "[RFC7800] Jones, M., Bradley, J., and H. Tschofenig, \"Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)\", RFC 7800, DOI 10.17487/RFC7800, April 2016, <https://www.rfc-editor.org/info/rfc7800>.",
      "ja": "[RFC7800]ジョーンズ、M。、ブラッドリー、J。、およびH.ツコフェニグ、「JSON Webトークン（JWT）の所有鍵の意味論」、RFC 7800、DOI 10.17487 / RFC7800、2016年4月、<https：/ /www.rfc-editor.org/info/rfc7800>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8414] Jones, M., Sakimura, N., and J. Bradley, \"OAuth 2.0 Authorization Server Metadata\", RFC 8414, DOI 10.17487/RFC8414, June 2018, <https://www.rfc-editor.org/info/rfc8414>.",
      "ja": "[RFC8414]ジョーンズ、M。、サキムラ、N。、およびJ.ブラッドリー、「OAuth 2.0認証サーバーメタデータ」、RFC 8414、DOI 10.17487 / RFC8414、2018年6月、<https://www.rfc-editor.org/ info / rfc8414>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[SHS] National Institute of Standards and Technology (NIST), \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, August 2015, <https://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[SHS]米国国立標準技術研究所（NIST）、「Secure Hash Standard（SHS）」、FIPS PUB 180-4、DOI 10.6028 / NIST.FIPS.180-4、2015年8月、<https：//nvlpubs.nist .gov / nistpubs / FIPS / NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[X690] ITU-T, \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, August 2015.",
      "ja": "[X690] ITU-T、「情報技術-ASN.1エンコードルール：基本エンコードルール（BER）、標準エンコードルール（CER）および識別エンコードルール（DER）の仕様」、ITU-T勧告X.690、8月 2015年。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CX5P] Wong, D., \"Common x509 certificate validation/creation pitfalls\", September 2016, <https://www.cryptologie.net/article/374/common-x509- certificate-validationcreation-pitfalls>.",
      "ja": "[CX5P] Wong、D。、「一般的なx509証明書の検証/作成の落とし穴」、2016年9月、<https://www.cryptologie.net/article/374/common-x509- certificate-validationcreation-pitfalls>。"
    },
    {
      "indent": 3,
      "text": "[DCW] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, \"The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software\", DOI 10.1145/2382196.2382204, October 2012, <http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>.",
      "ja": "[DCW] Georgiev、M.、Iyengar、S.、Jana、S.、Anubhai、R.、Boneh、D.、およびV. Shmatikov、 \"世界で最も危険なコード：非ブラウザソフトウェアでのSSL証明書の検証 \"、DOI 10.1145 / 2382196.2382204、2012年10月、<http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IANA.JWT.Claims] IANA, \"JSON Web Token Claims\", <https://www.iana.org/assignments/jwt>.",
      "ja": "[IANA.JWT.Claims] IANA、「JSON Web Token Claims」、<https://www.iana.org/assignments/jwt>。"
    },
    {
      "indent": 3,
      "text": "[IANA.OAuth.Parameters] IANA, \"OAuth Parameters\", <https://www.iana.org/assignments/oauth-parameters>.",
      "ja": "[IANA.OAuth.Parameters] IANA、「OAuthパラメーター」、<https://www.iana.org/assignments/oauth-parameters>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.CIBA] Fernandez, G., Walter, F., Nennker, A., Tonge, D., and B. Campbell, \"OpenID Connect Client Initiated Backchannel Authentication Flow - Core 1.0\", 16 January 2019, <https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>.",
      "ja": "[OpenID.CIBA] Fernandez、G.、Walter、F.、Nennker、A.、Tonge、D.、およびB. Campbell、 \"OpenID Connect Client Initiated Backchannel Authentication Flow-Core 1.0\"、16 January 2019、<https： //openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC4517] Legg, S., Ed., \"Lightweight Directory Access Protocol (LDAP): Syntaxes and Matching Rules\", RFC 4517, DOI 10.17487/RFC4517, June 2006, <https://www.rfc-editor.org/info/rfc4517>.",
      "ja": "[RFC4517] Legg、S.、Ed。、「ライトウェイトディレクトリアクセスプロトコル（LDAP）：構文とマッチングルール」、RFC 4517、DOI 10.17487 / RFC4517、2006年6月、<https://www.rfc-editor.org/ info / rfc4517>。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, DOI 10.17487/RFC5952, August 2010, <https://www.rfc-editor.org/info/rfc5952>.",
      "ja": "[RFC5952] Kawamura、S. and M. Kawashima、 \"A Recommendation for IPv6 Address Text Representation\"、RFC 5952、DOI 10.17487 / RFC5952、August 2010、<https://www.rfc-editor.org/info/rfc5952> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <https://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<https://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7009] Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"OAuth 2.0 Token Revocation\", RFC 7009, DOI 10.17487/RFC7009, August 2013, <https://www.rfc-editor.org/info/rfc7009>.",
      "ja": "[RFC7009] Lodderstedt、T.、Ed。、Dronia、S。、およびM. Scurtescu、「OAuth 2.0 Token Revocation」、RFC 7009、DOI 10.17487 / RFC7009、2013年8月、<https：//www.rfc-editor。 org / info / rfc7009>。"
    },
    {
      "indent": 3,
      "text": "[RFC7518] Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518, DOI 10.17487/RFC7518, May 2015, <https://www.rfc-editor.org/info/rfc7518>.",
      "ja": "[RFC7518]ジョーンズ、M。、「JSON Web Algorithms（JWA）」、RFC 7518、DOI 10.17487 / RFC7518、2015年5月、<https://www.rfc-editor.org/info/rfc7518>。"
    },
    {
      "indent": 3,
      "text": "[TOKEN] Jones, M., Campbell, B., Bradley, J., and W. Denniss, \"OAuth 2.0 Token Binding\", Work in Progress, Internet-Draft, draft-ietf-oauth-token-binding-08, 19 October 2018, <https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>.",
      "ja": "[トークン]ジョーンズ、M。、キャンベル、B。、ブラッドリー、J。、およびW.デニス、「OAuth 2.0トークンバインディング」、Work in Progress、インターネットドラフト、draft-ietf-oauth-token-binding-08、 2018年10月19日、<https://tools.ietf.org/html/draft-ietf-oauth-token-binding-08>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example \"cnf\" Claim, Certificate, and JWK",
      "section_title": true,
      "ja": "付録A.「cnf」クレーム、証明書、およびJWKの例"
    },
    {
      "indent": 3,
      "text": "For reference, an \"x5t#S256\" value and the X.509 certificate from which it was calculated are provided in the following examples, Figures 5 and 6, respectively. A JWK representation of the certificate's public key along with the \"x5c\" member is also provided in Figure 7.",
      "ja": "参照用に、「x5t＃S256」値と、それが計算されたX.509証明書が、それぞれ次の図5と6の例で提供されています。 「x5c」メンバーとともに証明書の公開鍵のJWK表現も図7に示します。"
    },
    {
      "indent": 3,
      "text": "\"cnf\":{\"x5t#S256\":\"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0\"}",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 5: x5t#S256 Confirmation Claim",
      "ja": "図5：x5t＃S256確認要求"
    },
    {
      "indent": 3,
      "text": "-----BEGIN CERTIFICATE-----\nMIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTAx\nODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGByqG\nSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZjjJ\n/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0EAwID\nSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2eXZOV\nbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\n-----END CERTIFICATE-----",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 6: PEM Encoded Self-Signed Certificate",
      "ja": "図6：PEMエンコードされた自己署名証明書"
    },
    {
      "indent": 3,
      "text": "{\n \"kty\":\"EC\",\n \"x\":\"1yfLHCpXqFjxCeHHHMVDTcLscpb07KUxudBmOMn8C7Q\",\n \"y\":\"8_coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8\",\n \"crv\":\"P-256\",\n \"x5c\":[\n  \"MIIBBjCBrAIBAjAKBggqhkjOPQQDAjAPMQ0wCwYDVQQDDARtdGxzMB4XDTE4MTA\n   xODEyMzcwOVoXDTIyMDUwMjEyMzcwOVowDzENMAsGA1UEAwwEbXRsczBZMBMGBy\n   qGSM49AgEGCCqGSM49AwEHA0IABNcnyxwqV6hY8QnhxxzFQ03C7HKW9OylMbnQZ\n   jjJ/Au08/coZwxS7LfA4vOLS9WuneIXhbGGWvsDSb0tH6IxLm8wCgYIKoZIzj0E\n   AwIDSQAwRgIhAP0RC1E+vwJD/D1AGHGzuri+hlV/PpQEKTWUVeORWz83AiEA5x2\n   eXZOVbUlJSGQgjwD5vaUaKlLR50Q2DmFfQj1L+SY=\"\n   ]\n }",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 7: JSON Web Key",
      "ja": "図7：JSON Webキー"
    },
    {
      "indent": 0,
      "text": "Appendix B. Relationship to Token Binding",
      "section_title": true,
      "ja": "付録B.トークンバインディングとの関係"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 Token Binding [TOKEN] enables the application of Token Binding to the various artifacts and tokens employed throughout OAuth. That includes binding of an access token to a Token Binding key, which bears some similarities in motivation and design to the mutual-TLS client certificate-bound access tokens defined in this document. Both documents define what is often called a proof-of-possession security mechanism for access tokens, whereby a client must demonstrate possession of cryptographic keying material when accessing a protected resource. The details differ somewhat between the two documents but both have the authorization server bind the access token that it issues to an asymmetric key pair held by the client. The client then proves possession of the private key from that pair with respect to the TLS connection over which the protected resource is accessed.",
      "ja": "OAuth 2.0トークンバインディング[トークン]を使用すると、OAuth全体で使用されるさまざまなアーティファクトとトークンにトークンバインディングを適用できます。 これには、トークンバインディングキーへのアクセストークンのバインドが含まれます。トークンバインドキーには、このドキュメントで定義されている相互TLSクライアント証明書バインドアクセストークンとの動機付けおよび設計の類似性があります。 どちらのドキュメントも、アクセストークンの所持証明セキュリティメカニズムと呼ばれるものを定義しています。これにより、クライアントは、保護されたリソースにアクセスするときに暗号化キー情報の所有を証明する必要があります。 詳細は2つのドキュメント間で多少異なりますが、どちらも承認サーバーが、クライアントが保持する非対称キーペアに発行するアクセストークンをバインドします。 クライアントは、保護されたリソースにアクセスするTLS接続に関して、そのペアからの秘密キーの所有を証明します。"
    },
    {
      "indent": 3,
      "text": "Token Binding uses bare keys that are generated on the client, which avoids many of the difficulties of creating, distributing, and managing certificates used in this specification. However, at the time of writing, Token Binding is fairly new, and there is relatively little support for it in available application development platforms and tooling. Until better support for the underlying core Token Binding specifications exists, practical implementations of OAuth 2.0 Token Binding are infeasible. Mutual TLS, on the other hand, has been around for some time and enjoys widespread support in web servers and development platforms. As a consequence, OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens can be built and deployed now using existing platforms and tools. In the future, the two specifications are likely to be deployed in parallel for solving similar problems in different environments. Authorization servers may even support both specifications simultaneously using different proof-of-possession mechanisms for tokens issued to different clients.",
      "ja": "トークンバインディングは、クライアントで生成されたベアキーを使用するため、この仕様で使用される証明書を作成、配布、管理する際の多くの困難を回避できます。ただし、この記事の執筆時点では、トークンバインディングはかなり新しく、利用可能なアプリケーション開発プラットフォームおよびツールでのサポートは比較的わずかです。基盤となるコアトークンバインディング仕様のサポートが改善されるまで、OAuth 2.0トークンバインディングの実用的な実装は実行不可能です。一方、相互TLSはしばらく前から存在しており、Webサーバーと開発プラットフォームで広くサポートされています。その結果、既存のプラットフォームとツールを使用して、OAuth 2.0相互TLSクライアント認証と証明書バインドアクセストークンを構築および展開できるようになりました。将来的には、異なる環境で同様の問題を解決するために、2つの仕様が並行して展開される可能性があります。認可サーバーは、異なるクライアントに発行されたトークンに対して異なる所有証明メカニズムを使用して、両方の仕様を同時にサポートすることさえあります。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Scott \"not Tomlinson\" Tomilson and Matt Peterson were involved in design and development work on a mutual-TLS OAuth client authentication implementation that predates this document. Experience and learning from that work informed some of the content of this document.",
      "ja": "Scott \"not Tomlinson\" TomilsonとMatt Petersonは、このドキュメントより前の相互TLS OAuthクライアント認証実装の設計および開発作業に関与していました。 その作業からの経験と学習により、このドキュメントの内容の一部がわかりました。"
    },
    {
      "indent": 3,
      "text": "This specification was developed within the OAuth Working Group under the chairmanship of Hannes Tschofenig and Rifaat Shekh-Yusef with Eric Rescorla, Benjamin Kaduk, and Roman Danyliw serving as Security Area Directors. Additionally, the following individuals contributed ideas, feedback, and wording that helped shape this specification: Vittorio Bertocci, Sergey Beryozkin, Ralph Bragg, Sophie Bremer, Roman Danyliw, Vladimir Dzhuvinov, Samuel Erdtman, Evan Gilman, Leif Johansson, Michael Jones, Phil Hunt, Benjamin Kaduk, Takahiko Kawasaki, Sean Leonard, Kepeng Li, Neil Madden, James Manger, Jim Manico, Nov Matake, Sascha Preibisch, Eric Rescorla, Justin Richer, Vincent Roca, Filip Skokan, Dave Tonge, and Hannes Tschofenig.",
      "ja": "この仕様は、Hanenes TschofenigとRifaat Shekh-Yusefの議長の下でOAuthワーキンググループ内で開発され、Eric Rescorla、Benjamin Kaduk、およびRoman Danyliwがセキュリティエリアディレクターを務めています。 さらに、次の個人がこの仕様を形作るのに役立つアイデア、フィードバック、および文言を提供しました：Vittorio Bertocci、Sergey Beryozkin、Ralph Bragg、Sophie Bremer、Roman Danyliw、Vladimir Dzhuvinov、Samuel Erdtman、Evan Gilman、Leif Johansson、Michael Jones、Phil Hunt 、ベンジャミン・カダック、川崎貴彦、ショーン・レナード、ケペン・リー、ニール・マッデン、ジェームズ・マンガー、ジム・マニコ、ノヴ・マタケ、サシャ・プレイビッシュ、エリック・レスコーラ、ジャスティン・リッチャー、ビンセント・ロカ、フィリップ・スコカン、デイヴ・トンゲ、ハンネス・ツコフェニグ"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Campbell Ping Identity",
      "ja": "ブライアン・キャンベル・ピン・アイデンティティー"
    },
    {
      "indent": 3,
      "text": "Email: brian.d.campbell@gmail.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "John Bradley Yubico",
      "ja": "ジョン・ブラッドリー・ユビコ"
    },
    {
      "indent": 3,
      "text": "Email: ve7jtb@ve7jtb.com\nURI:   http://www.thread-safe.com/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Nat Sakimura Nomura Research Institute",
      "ja": "崎村ナット野村総合研究所"
    },
    {
      "indent": 3,
      "text": "Email: n-sakimura@nri.co.jp\nURI:   https://nat.sakimura.org/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt YES.com AG",
      "ja": "Torsten Lodderstedt YES.com AG"
    },
    {
      "indent": 3,
      "text": "Email: torsten@lodderstedt.net",
      "raw": true
    }
  ]
}