{
  "title": {
    "text": "RFC 8618 - Compacted-DNS (C-DNS): A Format for DNS Packet Capture",
    "ja": "RFC 8618 - コンパクトDNS（C-DNS）：DNSパケットキャプチャの形式"
  },
  "number": 8618,
  "created_at": "2019-11-05 19:13:43.584526+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      J. Dickinson\nRequest for Comments: 8618                                      J. Hague\nCategory: Standards Track                                   S. Dickinson\nISSN: 2070-1721                                               Sinodun IT\n                                                            T. Manderson\n                                                                   ICANN\n                                                                 J. Bond\n                                              Wikimedia Foundation, Inc.\n                                                          September 2019",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Compacted-DNS (C-DNS): A Format for DNS Packet Capture",
      "ja": "コンパクトDNS（C-DNS）：DNSパケットキャプチャの形式"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a data representation for collections of DNS messages. The format is designed for efficient storage and transmission of large packet captures of DNS traffic; it attempts to minimize the size of such packet capture files but retain the full DNS message contents along with the most useful transport metadata. It is intended to assist with the development of DNS traffic-monitoring applications.",
      "ja": "このドキュメントでは、DNSメッセージのコレクションのデータ表現について説明します。 この形式は、DNSトラフィックの大きなパケットキャプチャの効率的な保存と送信のために設計されています。 そのようなパケットキャプチャファイルのサイズを最小限に抑えようとしますが、最も有用なトランスポートメタデータとともに完全なDNSメッセージコンテンツを保持します。 DNSトラフィック監視アプリケーションの開発を支援することを目的としています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8618.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8618で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Data Collection Use Cases . . . . . . . . . . . . . . . . . .   5\n4.  Design Considerations . . . . . . . . . . . . . . . . . . . .   8\n5.  Choice of CBOR  . . . . . . . . . . . . . . . . . . . . . . .  10\n6.  C-DNS Format Conceptual Overview  . . . . . . . . . . . . . .  10\n  6.1.  Block Parameters  . . . . . . . . . . . . . . . . . . . .  14\n  6.2.  Storage Parameters  . . . . . . . . . . . . . . . . . . .  14\n    6.2.1.  Optional Data Items . . . . . . . . . . . . . . . . .  15\n    6.2.2.  Optional RRs and OPCODEs  . . . . . . . . . . . . . .  16\n    6.2.3.  Storage Flags . . . . . . . . . . . . . . . . . . . .  17\n    6.2.4.  IP Address Storage  . . . . . . . . . . . . . . . . .  17\n7.  C-DNS Format Detailed Description . . . . . . . . . . . . . .  18\n  7.1.  Map Quantities and Indexes  . . . . . . . . . . . . . . .  18\n  7.2.  Tabular Representation  . . . . . . . . . . . . . . . . .  18\n  7.3.  \"File\"  . . . . . . . . . . . . . . . . . . . . . . . . .  19\n    7.3.1.  \"FilePreamble\"  . . . . . . . . . . . . . . . . . . .  20\n      7.3.1.1.  \"BlockParameters\" . . . . . . . . . . . . . . . .  20\n        7.3.1.1.1.  \"StorageParameters\" . . . . . . . . . . . . .  21\n          7.3.1.1.1.1.  \"StorageHints\"  . . . . . . . . . . . . .  22\n        7.3.1.1.2.  \"CollectionParameters\"  . . . . . . . . . . .  24\n    7.3.2.  \"Block\" . . . . . . . . . . . . . . . . . . . . . . .  25\n      7.3.2.1.  \"BlockPreamble\" . . . . . . . . . . . . . . . . .  26\n      7.3.2.2.  \"BlockStatistics\" . . . . . . . . . . . . . . . .  27\n      7.3.2.3.  \"BlockTables\" . . . . . . . . . . . . . . . . . .  28\n        7.3.2.3.1.  \"ClassType\" . . . . . . . . . . . . . . . . .  29\n        7.3.2.3.2.  \"QueryResponseSignature\"  . . . . . . . . . .  30\n        7.3.2.3.3.  \"Question\"  . . . . . . . . . . . . . . . . .  33\n        7.3.2.3.4.  \"RR\"  . . . . . . . . . . . . . . . . . . . .  34\n        7.3.2.3.5.  \"MalformedMessageData\"  . . . . . . . . . . .  34",
      "raw": true
    },
    {
      "indent": 3,
      "text": "      7.3.2.4.  \"QueryResponse\" . . . . . . . . . . . . . . . . .  35\n        7.3.2.4.1.  \"ResponseProcessingData\"  . . . . . . . . . .  36\n        7.3.2.4.2.  \"QueryResponseExtended\" . . . . . . . . . . .  37\n      7.3.2.5.  \"AddressEventCount\" . . . . . . . . . . . . . . .  38\n      7.3.2.6.  \"MalformedMessage\"  . . . . . . . . . . . . . . .  39\n8.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  39\n9.  C-DNS to PCAP . . . . . . . . . . . . . . . . . . . . . . . .  40\n  9.1.  Name Compression  . . . . . . . . . . . . . . . . . . . .  42\n10. Data Collection . . . . . . . . . . . . . . . . . . . . . . .  42\n  10.1.  Matching Algorithm . . . . . . . . . . . . . . . . . . .  43\n  10.2.  Message Identifiers  . . . . . . . . . . . . . . . . . .  45\n    10.2.1.  Primary ID (Required)  . . . . . . . . . . . . . . .  45\n    10.2.2.  Secondary ID (Optional)  . . . . . . . . . . . . . .  46\n  10.3.  Algorithm Parameters . . . . . . . . . . . . . . . . . .  46\n  10.4.  Algorithm Requirements . . . . . . . . . . . . . . . . .  46\n  10.5.  Algorithm Limitations  . . . . . . . . . . . . . . . . .  47\n  10.6.  Workspace  . . . . . . . . . . . . . . . . . . . . . . .  47\n  10.7.  Output . . . . . . . . . . . . . . . . . . . . . . . . .  47\n  10.8.  Post-Processing  . . . . . . . . . . . . . . . . . . . .  47\n11. Implementation Guidance . . . . . . . . . . . . . . . . . . .  47\n  11.1.  Optional Data  . . . . . . . . . . . . . . . . . . . . .  48\n  11.2.  Trailing Bytes . . . . . . . . . . . . . . . . . . . . .  48\n  11.3.  Limiting Collection of RDATA . . . . . . . . . . . . . .  49\n  11.4.  Timestamps . . . . . . . . . . . . . . . . . . . . . . .  49\n12. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  49\n  12.1.  Transport Types  . . . . . . . . . . . . . . . . . . . .  49\n  12.2.  Data Storage Flags . . . . . . . . . . . . . . . . . . .  50\n  12.3.  Response-Processing Flags  . . . . . . . . . . . . . . .  51\n  12.4.  AddressEvent Types . . . . . . . . . . . . . . . . . . .  51\n13. Security Considerations . . . . . . . . . . . . . . . . . . .  52\n14. Privacy Considerations  . . . . . . . . . . . . . . . . . . .  52\n15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  53\n  15.1.  Normative References . . . . . . . . . . . . . . . . . .  53\n  15.2.  Informative References . . . . . . . . . . . . . . . . .  55\nAppendix A.  CDDL . . . . . . . . . . . . . . . . . . . . . . . .  58\nAppendix B.  DNS Name Compression Example . . . . . . . . . . . .  69\n  B.1.  NSD Compression Algorithm . . . . . . . . . . . . . . . .  70\n  B.2.  Knot Authoritative Compression Algorithm  . . . . . . . .  70\n  B.3.  Observed Differences  . . . . . . . . . . . . . . . . . .  71\nAppendix C.  Comparison of Binary Formats . . . . . . . . . . . .  71\n  C.1.  Comparison with Full PCAP Files . . . . . . . . . . . . .  74\n  C.2.  Simple versus Block Coding  . . . . . . . . . . . . . . .  74\n  C.3.  Binary versus Text Formats  . . . . . . . . . . . . . . .  75\n  C.4.  Performance . . . . . . . . . . . . . . . . . . . . . . .  75\n  C.5.  Conclusions . . . . . . . . . . . . . . . . . . . . . . .  75\n  C.6.  Block Size Choice . . . . . . . . . . . . . . . . . . . .  76",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix D.  Data Fields for Traffic Regeneration . . . . . . . .  77\n  D.1.  Recommended Fields for Traffic Regeneration . . . . . . .  77\n  D.2.  Issues with Small Data Captures . . . . . . . . . . . . .  77\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  78\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  79",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There has long been a need for server operators to collect DNS Queries and Responses on authoritative and recursive name servers for monitoring and analysis. This data is used in a number of ways, including traffic monitoring, analyzing network attacks, and \"day in the life\" (DITL) [ditl] analysis.",
      "ja": "サーバーオペレーターは、監視と分析のために信頼できるネームサーバーでDNSクエリと応答を収集する必要が長い間ありました。 このデータは、トラフィックの監視、ネットワーク攻撃の分析、「日常生活」（DITL）[ditl]分析など、さまざまな方法で使用されます。"
    },
    {
      "indent": 3,
      "text": "A wide variety of tools already exist that facilitate the collection of DNS traffic data, such as the DNS Statistics Collector (DSC) [dsc], packetq [packetq], dnscap [dnscap], and dnstap [dnstap]. However, there is no standard exchange format for large DNS packet captures. The PCAP (\"packet capture\") [pcap] format or the PCAP Next Generation (PCAP-NG) [pcapng] format is typically used in practice for packet captures, but these file formats can contain a great deal of additional information that is not directly pertinent to DNS traffic analysis and thus unnecessarily increases the capture file size. Additionally, these tools and formats typically have no filter mechanism to selectively record only certain fields at capture time, requiring post-processing for anonymization or pseudonymization of data to protect user privacy.",
      "ja": "DNS Statistics Collector（DSC）[dsc]、packetq [packetq]、dnscap [dnscap]、dnstap [dnstap]など、DNSトラフィックデータの収集を容易にするさまざまなツールが既に存在します。 ただし、大規模なDNSパケットキャプチャ用の標準の交換形式はありません。 PCAP（「パケットキャプチャ」）[pcap]形式またはPCAP Next Generation（PCAP-NG）[pcapng]形式は通常、パケットキャプチャに実際に使用されますが、これらのファイル形式には、 DNSトラフィック分析に直接関係するため、キャプチャファイルのサイズが不必要に大きくなります。 さらに、これらのツールと形式には通常、キャプチャ時に特定のフィールドのみを選択的に記録するフィルター機構がないため、ユーザーのプライバシーを保護するためにデータの匿名化または匿名化のための後処理が必要です。"
    },
    {
      "indent": 3,
      "text": "There has also been work on using text-based formats to describe DNS packets (for example, see [dnsxml] and [RFC8427]), but this work is largely aimed at producing convenient representations of single messages.",
      "ja": "テキストベースの形式を使用してDNSパケットを記述する作業も行われていますが（たとえば、[dnsxml]および[RFC8427]を参照）、この作業の主な目的は単一メッセージの便利な表現を作成することです。"
    },
    {
      "indent": 3,
      "text": "Many DNS operators may receive hundreds of thousands of Queries per second on a single name server instance, so a mechanism to minimize the storage and transmission size (and therefore upload overhead) of the data collected is highly desirable.",
      "ja": "多くのDNSオペレーターは、単一のネームサーバーインスタンスで毎秒数十万件のクエリを受信する可能性があるため、収集されたデータのストレージと送信サイズ（したがってアップロードオーバーヘッド）を最小限に抑えるメカニズムが非常に望ましいです。"
    },
    {
      "indent": 3,
      "text": "The format described in this document, C-DNS (Compacted-DNS), focuses on the problem of capturing and storing large packet capture files of DNS traffic with the following goals in mind:",
      "ja": "このドキュメントで説明するC-DNS（Compacted-DNS）形式は、次の目標を念頭に置いてDNSトラフィックの大きなパケットキャプチャファイルをキャプチャおよび保存する問題に焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "o Minimize the file size for storage and transmission.",
      "ja": "o ストレージと送信用のファイルサイズを最小化します。"
    },
    {
      "indent": 3,
      "text": "o Minimize the overhead of producing the packet capture file and the cost of any further (general-purpose) compression of the file.",
      "ja": "o パケットキャプチャファイルを生成するオーバーヘッドと、ファイルのさらなる（汎用）圧縮のコストを最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "This document contains:",
      "ja": "このドキュメントには以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "o A discussion of some common use cases in which DNS data is collected; see Section 3.",
      "ja": "o DNSデータが収集される一般的なユースケースの説明。 セクション3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A discussion of the major design considerations in developing an efficient data representation for collections of DNS messages; see Section 4.",
      "ja": "o DNSメッセージのコレクションの効率的なデータ表現を開発する際の主要な設計上の考慮事項の議論。 セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A description of why the Concise Binary Object Representation (CBOR) [RFC7049] was chosen for this format; see Section 5.",
      "ja": "o 簡潔なバイナリオブジェクト表現（CBOR）[RFC7049]がこの形式に選択された理由の説明。 セクション5を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A conceptual overview of the C-DNS format; see Section 6.",
      "ja": "o C-DNS形式の概念的な概要。 セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "o The definition of the C-DNS format for the collection of DNS messages; see Section 7.",
      "ja": "o DNSメッセージの収集のためのC-DNS形式の定義。 セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Notes on converting C-DNS data to PCAP format; see Section 9.",
      "ja": "o C-DNSデータをPCAP形式に変換する際の注意事項。 セクション9を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Some high-level implementation considerations for applications designed to produce C-DNS; see Section 10.",
      "ja": "o C-DNSを生成するように設計されたアプリケーションの実装に関する高度な考慮事項。 セクション10を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "\"Packet\" refers to an individual IPv4 or IPv6 packet. Typically, packets are UDP datagrams, but such packets may also be part of a TCP data stream. \"Message\", unless otherwise qualified, refers to a DNS payload extracted from a UDP datagram or a TCP data stream.",
      "ja": "「パケット」とは、個々のIPv4またはIPv6パケットを指します。 通常、パケットはUDPデータグラムですが、そのようなパケットはTCPデータストリームの一部である場合もあります。 「メッセージ」は、特に限定されない限り、UDPデータグラムまたはTCPデータストリームから抽出されたDNSペイロードを指します。"
    },
    {
      "indent": 3,
      "text": "The parts of DNS messages are named as they are in [RFC1035]. Specifically, the DNS message has five sections: Header, Question, Answer, Authority, and Additional.",
      "ja": "DNSメッセージの部分は、[RFC1035]にあるように名前が付けられています。 具体的には、DNSメッセージには、ヘッダー、質問、回答、権限、および追加の5つのセクションがあります。"
    },
    {
      "indent": 0,
      "text": "3. Data Collection Use Cases",
      "section_title": true,
      "ja": "3. データ収集のユースケース"
    },
    {
      "indent": 3,
      "text": "From a purely server operator perspective, collecting full packet captures of all packets going into or out of a name server provides the most comprehensive picture of network activity. However, there are several design choices or other limitations that are common to many DNS installations and operators.",
      "ja": "純粋にサーバーオペレーターの観点から見ると、ネームサーバーに出入りするすべてのパケットの完全なパケットキャプチャを収集すると、ネットワークアクティビティの最も包括的な全体像が得られます。 ただし、多くのDNSインストールおよびオペレーターに共通する設計上の選択またはその他の制限がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "o DNS servers are hosted in a variety of situations:",
      "ja": "o DNSサーバーは、さまざまな状況でホストされます。"
    },
    {
      "indent": 6,
      "text": "* Self-hosted servers",
      "ja": "* 自己ホスト型サーバー"
    },
    {
      "indent": 6,
      "text": "* Third-party hosting (including multiple third parties)",
      "ja": "* サードパーティのホスティング（複数のサードパーティを含む）"
    },
    {
      "indent": 6,
      "text": "* Third-party hardware (including multiple third parties)",
      "ja": "* サードパーティのハードウェア（複数のサードパーティを含む）"
    },
    {
      "indent": 3,
      "text": "o Data is collected under different conditions:",
      "ja": "o データはさまざまな条件下で収集されます。"
    },
    {
      "indent": 6,
      "text": "* On well-provisioned servers running in a steady state",
      "ja": "* 安定した状態で実行されている、適切にプロビジョニングされたサーバー上"
    },
    {
      "indent": 6,
      "text": "* On heavily loaded servers",
      "ja": "* 負荷の高いサーバー"
    },
    {
      "indent": 6,
      "text": "* On virtualized servers",
      "ja": "* 仮想化サーバー"
    },
    {
      "indent": 6,
      "text": "* On servers that are under DoS attack",
      "ja": "* DoS攻撃を受けているサーバー上"
    },
    {
      "indent": 6,
      "text": "* On servers that are unwitting intermediaries in DoS attacks",
      "ja": "* DoS攻撃の仲介者を知らないサーバー"
    },
    {
      "indent": 3,
      "text": "o Traffic can be collected via a variety of mechanisms:",
      "ja": "o トラフィックは、さまざまなメカニズムを介して収集できます。"
    },
    {
      "indent": 6,
      "text": "* Within the name server implementation itself",
      "ja": "* ネームサーバーの実装自体の中"
    },
    {
      "indent": 6,
      "text": "* On the same hardware as the name server itself",
      "ja": "* ネームサーバー自体と同じハードウェア上"
    },
    {
      "indent": 6,
      "text": "* Using a network tap on an adjacent host to listen to DNS traffic",
      "ja": "* 隣接ホストのネットワークタップを使用してDNSトラフィックをリッスンする"
    },
    {
      "indent": 6,
      "text": "* Using port mirroring to listen from another host",
      "ja": "* ポートミラーリングを使用して別のホストからリッスンする"
    },
    {
      "indent": 3,
      "text": "o The capabilities of data collection (and upload) networks vary:",
      "ja": "o データ収集（およびアップロード）ネットワークの機能はさまざまです。"
    },
    {
      "indent": 6,
      "text": "* Out-of-band networks with the same capacity as the in-band network",
      "ja": "* 帯域内ネットワークと同じ容量の帯域外ネットワーク"
    },
    {
      "indent": 6,
      "text": "* Out-of-band networks with less capacity than the in-band network",
      "ja": "* 帯域内ネットワークよりも容量の少ない帯域外ネットワーク"
    },
    {
      "indent": 6,
      "text": "* Everything being on the in-band network",
      "ja": "* インバンドネットワーク上にあるすべてのもの"
    },
    {
      "indent": 3,
      "text": "Thus, there is a wide range of use cases, from very limited data collection environments (third-party hardware, servers that are under attack, packet capture on the name server itself and no out-of-band network) to \"limitless\" environments (self-hosted, well-provisioned servers, using a network tap or port mirroring with out-of-band networks with the same capacity as the in-band network). In the former case, it is infeasible to reliably collect full packet captures, especially if the server is under attack. In the latter case, collection of full packet captures may be reasonable.",
      "ja": "したがって、非常に限られたデータ収集環境（サードパーティのハードウェア、攻撃を受けているサーバー、ネームサーバー自体でのパケットキャプチャー、帯域外ネットワークなし）から「無制限」環境まで、幅広いユースケースがあります。 （帯域内ネットワークと同じ容量の帯域外ネットワークでネットワークタップまたはポートミラーリングを使用する、自己ホスト型の適切にプロビジョニングされたサーバー）。 前者の場合、特にサーバーが攻撃を受けている場合は、完全なパケットキャプチャを確実に収集することは不可能です。 後者の場合、完全なパケットキャプチャの収集は合理的です。"
    },
    {
      "indent": 3,
      "text": "As a result of these restrictions, the C-DNS data format is designed with the most limited use case in mind, such that:",
      "ja": "これらの制限の結果、C-DNSデータ形式は、次のような最も限定的なユースケースを考慮して設計されています。"
    },
    {
      "indent": 3,
      "text": "o Data collection will occur on the same hardware as the name server itself",
      "ja": "o データ収集は、ネームサーバー自体と同じハードウェアで行われます"
    },
    {
      "indent": 3,
      "text": "o Collected data will be stored on the same hardware as the name server itself, at least temporarily",
      "ja": "o 収集されたデータは、少なくとも一時的にネームサーバー自体と同じハードウェアに保存されます"
    },
    {
      "indent": 3,
      "text": "o Collected data being returned to some central analysis system will use the same network interface as the DNS Queries and Responses",
      "ja": "o いくつかの中央分析システムに返される収集データは、DNSクエリおよび応答と同じネットワークインターフェイスを使用します"
    },
    {
      "indent": 3,
      "text": "o There can be multiple third-party servers involved",
      "ja": "o 複数のサードパーティのサーバーが関係している可能性があります"
    },
    {
      "indent": 3,
      "text": "Because of these considerations, a major factor in the design of the format is minimal storage size of the capture files.",
      "ja": "これらの考慮事項のため、形式の設計における主要な要因は、キャプチャファイルの最小ストレージサイズです。"
    },
    {
      "indent": 3,
      "text": "Another significant consideration for any application that records DNS traffic is that the running of the name server software and the transmission of DNS Queries and Responses are the most important jobs of a name server; capturing data is not. Any data collection system co-located with the name server needs to be intelligent enough to carefully manage its CPU, disk, memory, and network utilization. This leads to designing a format that requires a relatively low overhead to produce and minimizes the requirement for further potentially costly compression.",
      "ja": "DNSトラフィックを記録するアプリケーションのもう1つの重要な考慮事項は、ネームサーバーソフトウェアの実行とDNSクエリと応答の送信がネームサーバーの最も重要な仕事であることです。 データをキャプチャすることはできません。 ネームサーバーと同じ場所に配置されたデータ収集システムは、CPU、ディスク、メモリ、およびネットワークの使用率を慎重に管理するのに十分なインテリジェントである必要があります。 これにより、生成するのに比較的低いオーバーヘッドを必要とするフォーマットの設計につながり、潜在的にコストのかかる圧縮の要件を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "However, it is also essential that interoperability with less restricted infrastructure is maintained. In particular, it is highly desirable that the collection format should facilitate the re-creation of common formats (such as PCAP) that are as close to the original as is realistic, given the restrictions above.",
      "ja": "ただし、制限の少ないインフラストラクチャとの相互運用性を維持することも重要です。 特に、上記の制限を考慮すると、コレクション形式は、現実に近いほどオリジナルに近い共通形式（PCAPなど）の再作成を促進することが非常に望ましいです。"
    },
    {
      "indent": 0,
      "text": "4. Design Considerations",
      "section_title": true,
      "ja": "4. 設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section presents some of the major design considerations used in the development of the C-DNS format.",
      "ja": "このセクションでは、C-DNS形式の開発で使用される主要な設計上の考慮事項のいくつかを示します。"
    },
    {
      "indent": 3,
      "text": "1. The basic unit of data is a combined DNS Query and the associated Response (a \"Query/Response (Q/R) data item\"). The same structure will be used for unmatched Queries and Responses. Queries without Responses will be captured omitting the Response data. Responses without Queries will be captured omitting the Query data (but using the Question section from the Response, if present, as an identifying QNAME).",
      "ja": "1. データの基本単位は、DNSクエリと関連付けられた応答（「クエリ/応答（Q / R）データ項目」）の組み合わせです。 同じ構造が、一致しないクエリと応答に使用されます。 応答のないクエリは、応答データを省略してキャプチャされます。 クエリなしの応答は、クエリデータを省略してキャプチャされます（ただし、応答の質問セクションが存在する場合は、それを識別QNAMEとして使用します）。"
    },
    {
      "indent": 7,
      "text": "* Rationale: A Query and the associated Response represent the basic level of a client's interaction with the server. Also, combining the Query and Response into one item often reduces storage requirements due to commonality in the data of the two messages.",
      "ja": "* 根拠：クエリと関連する応答は、クライアントとサーバーとの対話の基本レベルを表します。 また、クエリと応答を1つのアイテムに結合すると、2つのメッセージのデータの共通性により、ストレージ要件が削減されることがよくあります。"
    },
    {
      "indent": 7,
      "text": "In the context of generating a C-DNS file, it is assumed that only those DNS payloads that can be parsed to produce a well-formed DNS message are stored in the structured Query/ Response data items of the C-DNS format and that all other messages will (optionally) be recorded as separate malformed messages. Parsing a well-formed message means, at a minimum, the following:",
      "ja": "C-DNSファイルの生成のコンテキストでは、適切な形式のDNSメッセージを生成するために解析できるDNSペイロードのみがC-DNS形式の構造化されたクエリ/応答データ項目に格納され、すべての 他のメッセージは（オプションで）別の不正な形式のメッセージとして記録されます。 整形式メッセージの解析とは、少なくとも次のことを意味します。"
    },
    {
      "indent": 7,
      "text": "* The packet has a well-formed 12-byte DNS Header with a recognized OPCODE.",
      "ja": "* パケットには、認識されたOPCODEを含む整形式の12バイトDNSヘッダーがあります。"
    },
    {
      "indent": 7,
      "text": "* The section counts are consistent with the section contents.",
      "ja": "* セクション数は、セクションの内容と一致しています。"
    },
    {
      "indent": 7,
      "text": "* All of the Resource Records (RRs) can be fully parsed.",
      "ja": "* すべてのリソースレコード（RR）を完全に解析できます。"
    },
    {
      "indent": 3,
      "text": "2. All top-level fields in each Query/Response data item will be optional.",
      "ja": "2. 各クエリ/応答データ項目のすべての最上位フィールドはオプションです。"
    },
    {
      "indent": 7,
      "text": "* Rationale: Different operators will have different requirements for data to be available for analysis. Operators with minimal requirements should not have to pay the cost of recording full data, though this will limit the ability to perform certain kinds of data analysis and also to reconstruct packet captures. For example, omitting the RRs from a Response will reduce the C-DNS file size; in principle, Responses can be synthesized if there is enough context. Operators may have different policies for collecting user data and can choose to omit or anonymize certain fields at capture time, e.g., client address.",
      "ja": "* 理論的根拠：オペレータが異なれば、分析に利用できるデータの要件も異なります。 最小限の要件を持つオペレーターは、完全なデータを記録するコストを支払う必要はありませんが、これにより、特定の種類のデータ分析を実行したり、パケットキャプチャを再構築したりする能力が制限されます。 たとえば、応答からRRを省略すると、C-DNSファイルのサイズが小さくなります。 原則として、十分なコンテキストがあれば応答を合成できます。 オペレーターは、ユーザーデータを収集するためのさまざまなポリシーを持ち、キャプチャ時に特定のフィールド（クライアントアドレスなど）を省略または匿名化することを選択できます。"
    },
    {
      "indent": 3,
      "text": "3. Multiple Query/Response data items will be collected into blocks in the format. Common data in a block will be abstracted and referenced from individual Query/Response data items by indexing. The maximum number of Query/Response data items in a block will be configurable.",
      "ja": "3. 複数のクエリ/応答データ項目は、形式でブロックに収集されます。 ブロック内の共通データは抽象化され、インデックス付けによって個々のクエリ/レスポンスデータ項目から参照されます。 ブロック内のクエリ/応答データ項目の最大数は構成可能です。"
    },
    {
      "indent": 7,
      "text": "* Rationale: This blocking and indexing action provides a significant reduction in the volume of file data generated. Although this introduces complexity, it provides compression of the data that makes use of knowledge of the DNS message structure.",
      "ja": "* 理論的根拠：このブロックおよびインデックス作成アクションにより、生成されるファイルデータの量が大幅に削減されます。 これは複雑さをもたらしますが、DNSメッセージ構造の知識を利用するデータの圧縮を提供します。"
    },
    {
      "indent": 7,
      "text": "* It is anticipated that the files produced can be subject to further compression using general-purpose compression tools. Measurements show that blocking significantly reduces the CPU required to perform such strong compression. See Appendix C.2.",
      "ja": "* 生成されたファイルは、汎用圧縮ツールを使用してさらに圧縮されることが予想されます。 測定により、ブロッキングにより、このような強力な圧縮を実行するために必要なCPUが大幅に削減されることが示されています。 付録C.2を参照してください。"
    },
    {
      "indent": 7,
      "text": "* Examples of commonality between DNS messages are that in most cases the QUESTION RR is the same in the Query and Response and that there is a finite set of Query \"signatures\" (based on a subset of attributes). For many authoritative servers, there is very likely to be a finite set of Responses that are generated, of which a large number are NXDOMAIN.",
      "ja": "* DNSメッセージ間の共通性の例は、ほとんどの場合、クエリと応答でQUESTION RRが同じであり、（属性のサブセットに基づく）クエリの「署名」の有限セットがあることです。 多くの権限のあるサーバーでは、生成される応答のセットが有限である可能性が非常に高く、その多くがNXDOMAINです。"
    },
    {
      "indent": 3,
      "text": "4. Traffic metadata can optionally be included in each block. Specifically, counts of some types of non-DNS packets (e.g., ICMP, TCP resets) sent to the server may be of interest.",
      "ja": "4. オプションで、トラフィックメタデータを各ブロックに含めることができます。 具体的には、サーバーに送信されたDNS以外のパケットの種類（ICMP、TCPリセットなど）のカウントが重要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "5. The wire-format content of malformed DNS messages may optionally be recorded.",
      "ja": "5. 不正な形式のDNSメッセージのワイヤー形式のコンテンツは、オプションで記録される場合があります。"
    },
    {
      "indent": 7,
      "text": "* Rationale: Any structured capture format that does not capture the DNS payload byte for byte will be limited to some extent in that it cannot represent malformed DNS messages. Only those messages that can be fully parsed and transformed into the structured format can be fully represented. Note, however, that this can result in rather misleading statistics. For example, a malformed Query that cannot be represented in the C-DNS format will lead to the (well-formed) DNS Response with error code FORMERR appearing as \"unmatched\". Therefore, it can greatly aid downstream analysis to have the wire format of the malformed DNS messages available directly in the C-DNS file.",
      "ja": "* 理由：バイトごとにDNSペイロードバイトをキャプチャしない構造化されたキャプチャ形式は、不正なDNSメッセージを表すことができないという点である程度制限されます。 完全に解析して構造化形式に変換できるメッセージのみを完全に表現できます。 ただし、これにより統計が誤解を招く可能性があることに注意してください。 たとえば、C-DNS形式で表現できない不正な形式のクエリは、エラーコードFORMERRが「不一致」として表示される（整形式の）DNS応答につながります。 したがって、不正な形式のDNSメッセージのワイヤー形式をC-DNSファイルで直接利用できるようにすることで、ダウンストリーム分析を大幅に支援できます。"
    },
    {
      "indent": 0,
      "text": "5. Choice of CBOR",
      "section_title": true,
      "ja": "5. CBORの選択"
    },
    {
      "indent": 3,
      "text": "This document presents a detailed format description for C-DNS. The format uses CBOR [RFC7049].",
      "ja": "このドキュメントでは、C-DNSの詳細な形式の説明を示します。 形式はCBOR [RFC7049]を使用します。"
    },
    {
      "indent": 3,
      "text": "The choice of CBOR was made taking a number of factors into account.",
      "ja": "CBORの選択は、多くの要因を考慮して行われました。"
    },
    {
      "indent": 3,
      "text": "o CBOR is a binary representation and thus is economical in storage space.",
      "ja": "o CBORはバイナリ表現であるため、ストレージスペースで経済的です。"
    },
    {
      "indent": 3,
      "text": "o Other binary representations were investigated, and whilst all had attractive features, none had a significant advantage over CBOR. See Appendix C for some discussion of this.",
      "ja": "o 他のバイナリ表現が調査され、すべてに魅力的な特徴がありましたが、CBORよりも大きな利点はありませんでした。 これについては、付録Cを参照してください。"
    },
    {
      "indent": 3,
      "text": "o CBOR is an IETF specification and is familiar to IETF participants. It is based on the now-common ideas of lists and objects and thus requires very little familiarization for those in the wider industry.",
      "ja": "o CBORはIETF仕様であり、IETF参加者になじみがあります。 これは、リストとオブジェクトの現在一般的なアイデアに基づいているため、より広範な業界の人々にとってはほとんど慣れる必要はありません。"
    },
    {
      "indent": 3,
      "text": "o CBOR is a simple format and can easily be implemented from scratch if necessary. Formats that are more complex require library support, which may present problems on unusual platforms.",
      "ja": "o CBORは単純な形式であり、必要に応じてゼロから簡単に実装できます。 より複雑な形式にはライブラリのサポートが必要であり、通常とは異なるプラットフォームで問題が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o CBOR can also be easily converted to text formats such as JSON [RFC8259] for debugging and other human inspection requirements.",
      "ja": "o CBORは、デバッグやその他の人間の検査要件のために、JSON [RFC8259]などのテキスト形式に簡単に変換することもできます。"
    },
    {
      "indent": 3,
      "text": "o CBOR data schemas can be described using the Concise Data Definition Language (CDDL) [RFC8610].",
      "ja": "o CBORデータスキーマは、Concise Data Definition Language（CDDL）[RFC8610]を使用して説明できます。"
    },
    {
      "indent": 0,
      "text": "6. C-DNS Format Conceptual Overview",
      "section_title": true,
      "ja": "6. C-DNS形式の概念の概要"
    },
    {
      "indent": 3,
      "text": "The following figures show purely schematic representations of the C-DNS format to convey the high-level structure of the C-DNS format. Section 7 provides a detailed discussion of the CBOR representation and individual elements.",
      "ja": "次の図は、C-DNS形式の高レベルの構造を伝えるために、C-DNS形式の純粋な概略図を示しています。 セクション7では、CBOR表現と個々の要素について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the C-DNS format at the top level, including the file header and data blocks. The Query/Response data items, Address/Event Count data items, and Malformed Message data items link to various Block Tables.",
      "ja": "図1は、ファイルヘッダーとデータブロックを含む最上位のC-DNS形式を示しています。 Query / Responseデータ項目、Address / Event Countデータ項目、およびMalformed Messageデータ項目は、さまざまなブロックテーブルにリンクしています。"
    },
    {
      "indent": 19,
      "text": "+-------+\n+ C-DNS |\n+-------+--------------------------+\n| File Type Identifier             |\n+----------------------------------+\n| File Preamble                    |\n| +--------------------------------+\n| | Format Version                 |\n| +--------------------------------+\n| | Block Parameters               |\n+-+--------------------------------+\n| Block                            |\n| +--------------------------------+\n| | Block Preamble                 |\n| +--------------------------------+\n| | Block Statistics               |\n| +--------------------------------+\n| | Block Tables                   |\n| +--------------------------------+\n| | Query/Response data items      |\n| +--------------------------------+\n| | Address/Event Count data items |\n| +--------------------------------+\n| | Malformed Message data items   |\n+-+--------------------------------+\n| Block                            |\n| +--------------------------------+\n| | Block Preamble                 |\n| +--------------------------------+\n| | Block Statistics               |\n| +--------------------------------+\n| | Block Tables                   |\n| +--------------------------------+\n| | Query/Response data items      |\n| +--------------------------------+\n| | Address/Event Count data items |\n| +--------------------------------+\n| | Malformed Message data items   |\n+-+--------------------------------+\n| Further Blocks...                |\n+----------------------------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 1: The C-DNS Format",
      "ja": "図1：C-DNS形式"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows some more-detailed relationships within each Block, specifically those between the Query/Response data item and the relevant Block Tables. Some fields have been omitted for clarity.",
      "ja": "図2に、各ブロック内のより詳細な関係、特にクエリ/レスポンスデータ項目と関連するブロックテーブル間の関係を示します。 明確にするために、一部のフィールドは省略されています。"
    },
    {
      "indent": 3,
      "text": "+----------------+\n| Query/Response |\n+-------------------------+\n| Time Offset             |\n+-------------------------+            +------------------+\n| Client Address          |---------+->| IP Address array |\n+-------------------------+         |  +------------------+\n| Client Port             |         |\n+-------------------------+         |  +------------------+\n| Transaction ID          |     +---)->| Name/RDATA array |<--------+\n+-------------------------+     |   |  +------------------+         |\n| Query Signature         |--+  |   |                               |\n+-------------------------+  |  |   |  +-----------------+          |\n| Client Hoplimit (q)     |  +--)---)->| Query Signature |          |\n+-------------------------+     |   |  +-----------------+-------+  |\n| Response Delay (r)      |     |   +--| Server Address          |  |\n+-------------------------+     |      +-------------------------+  |\n| Query Name              |--+--+      | Server Port             |  |\n+-------------------------+  |         +-------------------------+  |\n| Query Size (q)          |  |         | Transport Flags         |  |\n+-------------------------+  |         +-------------------------+  |\n| Response Size (r)       |  |         | QR Type                 |  |\n+-------------------------+  |         +-------------------------+  |\n| Response Processing (r) |  |         | QR Signature Flags      |  |\n| +-----------------------+  |         +-------------------------+  |\n| | Bailiwick             |--+         | Query OPCODE (q)        |  |\n| +-----------------------+            +-------------------------+  |\n| | Flags                 |            | QR DNS Flags            |  |\n+-+-----------------------+            +-------------------------+  |\n| Extra Query Info (q)    |            | Query RCODE (q)         |  |\n| +-----------------------+            +-------------------------+  |\n| | Question              |--+---+  +--+-Query Class/Type (q)    |  |\n| +-----------------------+      |  |  +-------------------------+  |\n| | Answer                |--+   |  |  | Query QDCOUNT (q)       |  |\n| +-----------------------+  |   |  |  +-------------------------+  |\n| | Authority             |--+   |  |  | Query ANCOUNT (q)       |  |\n| +-----------------------+  |   |  |  +-------------------------+  |\n| | Additional            |--+   |  |  | Query NSCOUNT (q)       |  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-+-----------------------+  |   |  |  +-------------------------+  |\n| Extra Response Info (r) |  |-+ |  |  | Query ARCOUNT (q)       |  |\n| +-----------------------+  | | |  |  +-------------------------+  |\n| | Answer                |--+ | |  |  | Query EDNS version (q)  |  |\n| +-----------------------+  | | |  |  +-------------------------+  |\n| | Authority             |--+ | |  |  | Query EDNS UDP Size (q) |  |\n| +-----------------------+  | | |  |  +-------------------------+  |\n| | Additional            |--+ | |  |  | Query OPT RDATA (q)     |--+\n+-+-----------------------+    | |  |  +-------------------------+  |\n                               | |  |  | Response RCODE (r)      |  |\n                               | |  |  +-------------------------+  |\n+ -----------------------------+ |  +----------+                    |\n|                                |             |                    |\n| + -----------------------------+             |                    |\n| |  +---------------+  +----------+           |                    |\n| +->| Question List |->| Question |           |                    |\n|    | array         |  | array    |           |                    |\n|    +---------------+  +----------+--+        |                    |\n|                       | Name        |--+-----)--------------------+\n|                       +-------------+  |     |  +------------+\n|                       | Class/Type  |--)---+-+->| Class/Type |\n|                       +-------------+  |   |    | array      |\n|                                        |   |    +------------+--+\n|                                        |   |    | CLASS         |\n|    +---------------+  +----------+     |   |    +---------------+\n+--->| RR List array |->| RR array |     |   |    | TYPE          |\n     +---------+-----+  +----------+--+  |   |    +---------------+\n                        | Name        |--+   |\n                        +-------------+      |\n                        | Class/Type  |------+\n                        +-------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 2: The Query/Response Data Item and Subsidiary Tables",
      "ja": "図2：クエリ/レスポンスデータアイテムと補助テーブル"
    },
    {
      "indent": 3,
      "text": "In Figure 2, data items annotated (q) are only present when a Query/Response has a Query, and those annotated (r) are only present when a Query/Response Response is present.",
      "ja": "図2では、注釈付きのデータ項目（q）はクエリ/レスポンスにクエリがある場合にのみ存在し、注釈付きのデータ項目（r）はクエリ/レスポンス応答が存在する場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "A C-DNS file begins with a file header containing a File Type Identifier and a File Preamble. The File Preamble contains information on the file Format Version and an array of Block Parameters items (the contents of which include Collection and Storage Parameters used for one or more Blocks).",
      "ja": "C-DNSファイルは、ファイルタイプ識別子とファイルプリアンブルを含むファイルヘッダーで始まります。 ファイルプリアンブルには、ファイルのフォーマットバージョンとブロックパラメーター項目の配列に関する情報が含まれます（その内容には、1つ以上のブロックに使用されるコレクションパラメーターとストレージパラメーターが含まれます）。"
    },
    {
      "indent": 3,
      "text": "The file header is followed by a series of Blocks.",
      "ja": "ファイルヘッダーの後には一連のブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "A Block consists of a Block Preamble item, some Block Statistics for the traffic stored within the Block, and then various arrays of common data collectively called the Block Tables. This is then followed by an array of the Query/Response data items detailing the Queries and Responses stored within the Block. The array of Query/Response data items is in turn followed by the Address/Event Count data items (an array of per-client counts of particular IP events) and then Malformed Message data items (an array of malformed messages that are stored in the Block).",
      "ja": "ブロックは、ブロックプリアンブルアイテム、ブロック内に格納されたトラフィックのブロック統計、およびブロックテーブルと総称される一般的なデータのさまざまな配列で構成されます。 次に、ブロック内に保存されているクエリと応答の詳細を示すクエリ/応答データ項目の配列が続きます。 クエリ/レスポンスデータ項目の配列の後には、アドレス/イベントカウントデータ項目（特定のIPイベントのクライアントごとのカウントの配列）が続き、その後、不正な形式のメッセージデータ項目（に格納される不正な形式のメッセージの配列） ブロック）。"
    },
    {
      "indent": 3,
      "text": "The exact nature of the DNS data will affect what Block size is the best fit; however, sample data for a root server indicated that Block sizes up to 10,000 Query/Response data items give good results. See Appendix C.6 for more details.",
      "ja": "DNSデータの正確な性質は、最適なブロックサイズに影響します。 ただし、ルートサーバーのサンプルデータは、最大10,000個のクエリ/応答データアイテムのブロックサイズが良い結果をもたらすことを示しています。 詳細については、付録C.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "This design exploits data commonality and block-based storage to minimize the C-DNS file size. As a result, C-DNS cannot be streamed below the level of a Block.",
      "ja": "この設計では、データの共通性とブロックベースのストレージを活用して、C-DNSファイルサイズを最小化します。 その結果、C-DNSをブロックのレベルより下にストリーミングすることはできません。"
    },
    {
      "indent": 0,
      "text": "6.1. Block Parameters",
      "section_title": true,
      "ja": "6.1. ブロックパラメーター"
    },
    {
      "indent": 3,
      "text": "The details of the Block Parameters items are not shown in the diagrams but are discussed here for context.",
      "ja": "ブロックパラメーターアイテムの詳細は図には示されていませんが、ここではコンテキストについて説明します。"
    },
    {
      "indent": 3,
      "text": "An array of Block Parameters items is stored in the File Preamble (with a minimum of one item at index 0); a Block Parameters item consists of a collection of Storage and Collection Parameters that applies to any given Block. An array is used in order to support use cases such as wanting to merge C-DNS files from different sources. The Block Preamble item then contains an optional index for the Block Parameters item that applies for that Block; if not present, the index defaults to 0. Hence, in effect, a global Block Parameters item is defined that can then be overridden per Block.",
      "ja": "ブロックパラメーターアイテムの配列は、ファイルプリアンブルに格納されます（インデックス0に少なくとも1つのアイテムがあります）。 ブロックパラメーターアイテムは、特定のブロックに適用されるストレージおよびコレクションパラメーターのコレクションで構成されます。 配列は、さまざまなソースからのC-DNSファイルをマージするなどのユースケースをサポートするために使用されます。 ブロックプリアンブルアイテムには、そのブロックに適用されるブロックパラメーターアイテムのオプションのインデックスが含まれます。 存在しない場合、インデックスはデフォルトで0になります。したがって、実際には、ブロックごとにオーバーライドできるグローバルブロックパラメーターアイテムが定義されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Storage Parameters",
      "section_title": true,
      "ja": "6.2. ストレージパラメータ"
    },
    {
      "indent": 3,
      "text": "The Block Parameters item includes a Storage Parameters item -- this contains information about the specific data fields stored in the C-DNS file.",
      "ja": "Block Parametersアイテムには、Storage Parametersアイテムが含まれています。これには、C-DNSファイルに保存されている特定のデータフィールドに関する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "These parameters include:",
      "ja": "これらのパラメーターは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The sub-second timing resolution used by the data.",
      "ja": "o データが使用するサブ秒のタイミング解像度。"
    },
    {
      "indent": 3,
      "text": "o Information (hints) on which optional data are omitted. See Section 6.2.1.",
      "ja": "o オプションのデータが省略される情報（ヒント）。 セクション6.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Recorded OPCODES [opcodes] and RR TYPEs [rrtypes]. See Section 6.2.2.",
      "ja": "o 記録されたOPCODES [opcodes]およびRR TYPEs [rrtypes]。 セクション6.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Flags indicating, for example, whether the data is sampled or anonymized. See Sections 6.2.3 and 14.",
      "ja": "o たとえば、データがサンプリングされるか匿名化されるかを示すフラグ。 セクション6.2.3および14を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Client and server IPv4 and IPv6 address prefixes. See Section 6.2.4.",
      "ja": "o クライアントおよびサーバーのIPv4およびIPv6アドレスプレフィックス。 セクション6.2.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Optional Data Items",
      "section_title": true,
      "ja": "6.2.1. オプションのデータ項目"
    },
    {
      "indent": 3,
      "text": "To enable implementations to store data to their precise requirements in as space-efficient a manner as possible, all fields in the following arrays are optional:",
      "ja": "実装が可能な限りスペース効率の良い方法でデータを正確な要件に保存できるようにするために、次の配列のすべてのフィールドはオプションです。"
    },
    {
      "indent": 3,
      "text": "o Query/Response",
      "ja": "o クエリ/レスポンス"
    },
    {
      "indent": 3,
      "text": "o Query Signature",
      "ja": "o クエリ署名"
    },
    {
      "indent": 3,
      "text": "o Malformed Messages",
      "ja": "o 不正なメッセージ"
    },
    {
      "indent": 3,
      "text": "In other words, an implementation can choose to omit any data item that is not required for its use case (whilst observing the restrictions relating to IP address storage described in Section 6.2.4). In addition, implementations may be configured to not record all RRs or to only record messages with certain OPCODES.",
      "ja": "言い換えると、実装は、ユースケースに必要のないデータ項目を省略することを選択できます（セクション6.2.4で説明されているIPアドレスストレージに関連する制限を順守します）。 さらに、すべてのRRを記録しないように、または特定のOPCODEを持つメッセージのみを記録するように実装を構成できます。"
    },
    {
      "indent": 3,
      "text": "This does, however, mean that a consumer of a C-DNS file faces two problems:",
      "ja": "ただし、これは、C-DNSファイルのコンシューマーが2つの問題に直面していることを意味します。"
    },
    {
      "indent": 3,
      "text": "1. How can it quickly determine if a file definitely does not contain the data items it requires to complete a particular task (e.g., reconstructing DNS traffic or performing a specific piece of data analysis)?",
      "ja": "1. 特定のタスク（たとえば、DNSトラフィックの再構築や特定のデータ分析の実行）を完了するために必要なデータ項目がファイルに含まれていないかどうかをすばやく判断するにはどうすればよいですか？"
    },
    {
      "indent": 3,
      "text": "2. How can it determine whether a data item is not present because it was (1) explicitly not recorded or (2) not available/present?",
      "ja": "2. （1）明示的に記録されていない、または（2）利用できない/存在するために、データ項目が存在しないかどうかをどのように判断できますか？"
    },
    {
      "indent": 3,
      "text": "For example, capturing C-DNS data from within a name server implementation makes it unlikely that the Client Hoplimit can be recorded. Or, if there is no Query ARCOUNT recorded and no Query OPT RDATA [RFC6891] recorded, is that because no Query contained an OPT RR, or because that data was not stored?",
      "ja": "たとえば、ネームサーバーの実装内からC-DNSデータをキャプチャすると、Client Hoplimitを記録できない可能性が高くなります。 または、クエリARCOUNTが記録されておらず、クエリOPT RDATA [RFC6891]が記録されていない場合、クエリにOPT RRが含まれていなかったため、またはそのデータが保存されなかったためですか？"
    },
    {
      "indent": 3,
      "text": "The Storage Parameters item therefore also contains a Storage Hints item, which specifies which items the encoder of the file omits from the stored data and will therefore never be present. (This approach is taken because a flag that indicated which items were included for collection would not guarantee that the item was present -- only that it might be.) An implementation decoding that file can then use these flags to quickly determine whether the input data is not rich enough for its needs.",
      "ja": "したがって、Storage ParametersアイテムにはStorage Hintsアイテムも含まれます。これは、ファイルのエンコーダーが保存されたデータから除外するために存在しないアイテムを指定します。 （コレクションに含まれるアイテムを示すフラグは、アイテムが存在することを保証しないため、このアプローチが採用されます。そのファイルをデコードする実装は、これらのフラグを使用して、入力データが ニーズを満たすには十分ではありません。"
    },
    {
      "indent": 3,
      "text": "One scenario where this may be particularly important is the case of regenerating traffic. It is possible to collect such a small set of data items that an implementation decoding the file cannot determine if a given Query/Response data item was generated from just a Query, just a Response, or a Query/Response pair. This makes it impossible to reconstruct DNS traffic even if sensible defaults are provided for the missing data items. This is discussed in more detail in Section 9.",
      "ja": "これが特に重要なシナリオの1つは、トラフィックを再生成する場合です。 ファイルをデコードする実装では、特定のクエリ/レスポンスデータ項目がクエリのみ、レスポンスのみ、またはクエリ/レスポンスペアのどちらから生成されたかを判断できないほど小さなデータセットを収集することができます。 これにより、欠落しているデータ項目に適切なデフォルトが提供されていても、DNSトラフィックを再構築できなくなります。 これについては、セクション9で詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Optional RRs and OPCODEs",
      "section_title": true,
      "ja": "6.2.2. オプションのRRおよびOPCODE"
    },
    {
      "indent": 3,
      "text": "Also included in the Storage Parameters item are explicit arrays listing the RR TYPEs and the OPCODEs to be recorded. These arrays remove any ambiguity over whether, for example, messages containing particular OPCODEs are not present because (1) certain OPCODEs did not occur or (2) the implementation is not configured to record them.",
      "ja": "Storage Parametersアイテムには、記録されるRRタイプとOPCODEをリストする明示的な配列も含まれます。 これらの配列は、たとえば、（1）特定のOPCODEが発生しなかったため、または（2）実装がそれらを記録するように構成されていないため、特定のOPCODEを含むメッセージが存在しないかどうかのあいまいさを取り除きます。"
    },
    {
      "indent": 3,
      "text": "In the case of OPCODEs, for a message to be fully parsable, the OPCODE must be known to the collecting implementation. Any message with an OPCODE unknown to the collecting implementation cannot be validated as correctly formed and so must be treated as malformed. Messages with OPCODES known to the recording application but not listed in the Storage Parameters item are discarded by the recording application during C-DNS capture (regardless of whether they are malformed or not).",
      "ja": "OPCODEの場合、メッセージを完全に解析可能にするには、収集する実装にOPCODEを認識させる必要があります。 収集の実装に未知のOPCODEを持つメッセージは、正しい形式であると検証できないため、不正な形式として扱う必要があります。 記録アプリケーションに認識されているが[ストレージパラメータ]項目にリストされていないOPCODEを含むメッセージは、C-DNSキャプチャ中に記録アプリケーションによって破棄されます（不正な形式であるかどうかに関係なく）。"
    },
    {
      "indent": 3,
      "text": "In the case of RRs, each record in a message must be fully parsable, including parsing the record RDATA, as otherwise the message cannot be validated as correctly formed. Any RR with an RR TYPE not known to the collecting implementation cannot be validated as correctly formed and so must be treated as malformed.",
      "ja": "RRの場合、メッセージの各レコードは、レコードRDATAの解析を含め、完全に解析可能である必要があります。そうしないと、メッセージが正しく形成されていると検証できません。 収集実装で認識されていないRRタイプのRRは、正しい形式であると検証できないため、不正な形式として処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a message is correctly parsed, an implementation is free to record only a subset of the RRs present.",
      "ja": "メッセージが正しく解析されると、実装は存在するRRのサブセットのみを自由に記録できます。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Storage Flags",
      "section_title": true,
      "ja": "6.2.3. ストレージフラグ"
    },
    {
      "indent": 3,
      "text": "The Storage Parameters item contains flags that can be used to indicate if:",
      "ja": "Storage Parametersアイテムには、次のことを示すために使用できるフラグが含まれています。"
    },
    {
      "indent": 3,
      "text": "o the data is anonymized,",
      "ja": "o データは匿名化され、"
    },
    {
      "indent": 3,
      "text": "o the data is produced from sample data, or",
      "ja": "o データがサンプルデータから生成される、または"
    },
    {
      "indent": 3,
      "text": "o names in the data have been normalized (converted to uniform case).",
      "ja": "o データ内の名前は正規化されています（統一された大文字小文字に変換されます）。"
    },
    {
      "indent": 3,
      "text": "The Storage Parameters item also contains optional fields holding details of the sampling method used and the anonymization method used. It is RECOMMENDED that these fields contain URIs [RFC3986] pointing to resources describing the methods used. See Section 14 for further discussion of anonymization and normalization.",
      "ja": "Storage Parametersアイテムには、使用されるサンプリング方法と使用される匿名化方法の詳細を保持するオプションのフィールドも含まれます。 これらのフィールドには、使用されるメソッドを説明するリソースを指すURI [RFC3986]が含まれることが推奨されます。 匿名化と正規化の詳細については、セクション14を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2.4. IP Address Storage",
      "section_title": true,
      "ja": "6.2.4. IPアドレスストレージ"
    },
    {
      "indent": 3,
      "text": "The format can store either full IP addresses or just IP prefixes; the Storage Parameters item contains fields to indicate if only IP prefixes were stored.",
      "ja": "この形式では、完全なIPアドレスまたはIPプレフィックスのみを保存できます。 Storage Parametersアイテムには、IPプレフィックスのみが保存されているかどうかを示すフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "If the IP address prefixes are absent, then full addresses are stored. In this case, the IP version can be directly inferred from the stored address length and the fields \"qr-transport-flags\" in QueryResponseSignature, \"ae-transport-flags\" in AddressEventCount, and \"mm-transport-flags\" in MalformedMessageData (which contain the IP version bit) are optional.",
      "ja": "IPアドレスのプレフィックスが存在しない場合、完全なアドレスが保存されます。 この場合、IPバージョンは、保存されたアドレス長とQueryResponseSignatureのフィールド「qr-transport-flags」、AddressEventCountの「ae-transport-flags」、およびMalformedMessageDataの「mm-transport-flags」から直接推測できます（ IPバージョンビットを含む）はオプションです。"
    },
    {
      "indent": 3,
      "text": "If IP address prefixes are given, only the prefix bits of addresses are stored. In this case, in order to determine the IP version, the fields \"qr-transport-flags\" in QueryResponseSignature, \"ae-transport-flags\" in AddressEventCount, and \"mm-transport-flags\" in MalformedMessageData MUST be present. See Sections 7.3.2.3.2 and 7.3.2.3.5.",
      "ja": "IPアドレスのプレフィックスが指定されている場合、アドレスのプレフィックスビットのみが保存されます。 この場合、IPバージョンを判別するには、QueryResponseSignatureのフィールド「qr-transport-flags」、AddressEventCountの「ae-transport-flags」、およびMalformedMessageDataの「mm-transport-flags」が存在する必要があります。 セクション7.3.2.3.2および7.3.2.3.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "As an example of storing only IP prefixes, if a client IPv6 prefix of 48 is specified, a client address of 2001:db8:85a3::8a2e:370:7334 will be stored as 0x20010db885a3, reducing address storage space requirements. Similarly, if a client IPv4 prefix of 16 is specified, a client address of 192.0.2.1 will be stored as 0xc000 (192.0).",
      "ja": "IPプレフィックスのみを保存する例として、48のクライアントIPv6プレフィックスが指定されている場合、2001：db8：85a3 :: 8a2e：370：7334のクライアントアドレスが0x20010db885a3として保存され、アドレスストレージスペースの要件が削減されます。 同様に、16のクライアントIPv4プレフィックスが指定されている場合、192.0.2.1のクライアントアドレスは0xc000（192.0）として保存されます。"
    },
    {
      "indent": 0,
      "text": "7. C-DNS Format Detailed Description",
      "section_title": true,
      "ja": "7. C-DNS形式の詳細な説明"
    },
    {
      "indent": 3,
      "text": "The CDDL definition for the C-DNS format is given in Appendix A.",
      "ja": "C-DNS形式のCDDL定義は、付録Aに記載されています。"
    },
    {
      "indent": 0,
      "text": "7.1. Map Quantities and Indexes",
      "section_title": true,
      "ja": "7.1. マップの量とインデックス"
    },
    {
      "indent": 3,
      "text": "All map keys are integers with values specified in the CDDL. String keys would significantly bloat the file size.",
      "ja": "すべてのマップキーは、CDDLで指定された値を持つ整数です。 文字列キーはファイルサイズを大幅に増大させます。"
    },
    {
      "indent": 3,
      "text": "All key values specified are positive integers under 24, so their CBOR representation is a single byte. Positive integer values not currently used as keys in a map are reserved for use in future standard extensions.",
      "ja": "指定されたすべてのキー値は24未満の正の整数であるため、それらのCBOR表現は1バイトです。 現在マップでキーとして使用されていない正の整数値は、将来の標準拡張で使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Implementations may choose to add additional implementation-specific entries to any map. Negative integer map keys are reserved for these values. Key values from -1 to -24 also have a single-byte CBOR representation, so such implementation-specific extensions are not at any space efficiency disadvantage.",
      "ja": "実装は、マップに実装固有のエントリを追加することを選択できます。 負の整数マップキーは、これらの値用に予約されています。 -1から-24までのキー値もシングルバイトCBOR表現を持っているため、このような実装固有の拡張はスペース効率の面で不利にはなりません。"
    },
    {
      "indent": 3,
      "text": "An item described as an index is the index of the data item in the referenced array. Indexes are 0-based.",
      "ja": "インデックスとして記述されるアイテムは、参照配列内のデータアイテムのインデックスです。 インデックスは0ベースです。"
    },
    {
      "indent": 0,
      "text": "7.2. Tabular Representation",
      "section_title": true,
      "ja": "7.2. 表形式表現"
    },
    {
      "indent": 3,
      "text": "The following sections present the C-DNS specification in tabular format with a detailed description of each item.",
      "ja": "次のセクションでは、各項目の詳細な説明とともに表形式でC-DNS仕様を示します。"
    },
    {
      "indent": 3,
      "text": "In all quantities that contain bit flags, bit 0 indicates the least significant bit, i.e., flag \"n\" in quantity \"q\" is on if \"(q & (1 << n)) != 0\".",
      "ja": "ビットフラグを含むすべての数量で、ビット0は最下位ビットを示します。つまり、「（q＆（1 << n））！= 0」の場合、数量「q」のフラグ「n」がオンになります。"
    },
    {
      "indent": 3,
      "text": "For the sake of readability, all type and field names defined in the CDDL definition are shown in double quotes. Type names are by convention camel case (e.g., \"BlockTables\"), and field names are lowercase with hyphens (e.g., \"block-tables\").",
      "ja": "読みやすくするために、CDDL定義で定義されているすべてのタイプ名とフィールド名は二重引用符で囲んで示しています。 型名は慣例によりキャメルケース（「BlockTables」など）であり、フィールド名はハイフン付きの小文字（「block-tables」など）です。"
    },
    {
      "indent": 3,
      "text": "For the sake of brevity, the following conventions are used in the tables:",
      "ja": "簡潔にするために、以下の規則が表で使用されています。"
    },
    {
      "indent": 3,
      "text": "o The column M marks whether items in a map are mandatory.",
      "ja": "o 列Mは、マップ内のアイテムが必須かどうかを示します。"
    },
    {
      "indent": 6,
      "text": "* X - Mandatory items.",
      "ja": "* X-必須アイテム。"
    },
    {
      "indent": 6,
      "text": "* C - Conditionally mandatory items. Such items are usually optional but may be mandatory in some configurations.",
      "ja": "* C-条件付き必須アイテム。 通常、このような項目はオプションですが、構成によっては必須になる場合があります。"
    },
    {
      "indent": 6,
      "text": "* If the column is empty, the item is optional.",
      "ja": "* 列が空の場合、アイテムはオプションです。"
    },
    {
      "indent": 3,
      "text": "o The column T gives the CBOR datatype of the item.",
      "ja": "o 列Tは、アイテムのCBORデータ型を示します。"
    },
    {
      "indent": 6,
      "text": "* U - Unsigned integer.",
      "ja": "* U-符号なし整数。"
    },
    {
      "indent": 6,
      "text": "* I - Signed integer (i.e., either a CBOR unsigned integer or a CBOR negative integer).",
      "ja": "* I-符号付き整数（つまり、CBOR符号なし整数またはCBOR負の整数）。"
    },
    {
      "indent": 6,
      "text": "* B - Boolean.",
      "ja": "* B-ブール。"
    },
    {
      "indent": 6,
      "text": "* S - Byte string.",
      "ja": "* S-バイト文字列。"
    },
    {
      "indent": 6,
      "text": "* T - Text string.",
      "ja": "* T-テキスト文字列。"
    },
    {
      "indent": 6,
      "text": "* M - Map.",
      "ja": "* M-マップ。"
    },
    {
      "indent": 6,
      "text": "* A - Array.",
      "ja": "* A-配列。"
    },
    {
      "indent": 3,
      "text": "In the case of maps and arrays, more information on the type of each value, including the CDDL definition name if applicable, is given in the description.",
      "ja": "マップおよび配列の場合、各値のタイプに関する詳細情報（該当する場合はCDDL定義名を含む）が説明に記載されています。"
    },
    {
      "indent": 0,
      "text": "7.3. \"File\"",
      "section_title": true,
      "ja": "7.3. \"ファイル\""
    },
    {
      "indent": 3,
      "text": "A C-DNS file has an outer structure \"File\", an array that contains the following:",
      "ja": "C-DNSファイルには、「File」という外部構造があり、次の要素を含む配列があります。"
    },
    {
      "indent": 3,
      "text": "+---------------+---+---+-------------------------------------------+\n| Field         | M | T | Description                               |\n+---------------+---+---+-------------------------------------------+\n| file-type-id  | X | T | String \"C-DNS\" identifying the file type. |\n|               |   |   |                                           |\n| file-preamble | X | M | Version and parameter information for the |\n|               |   |   | whole file.  Map of type \"FilePreamble\";  |\n|               |   |   | see Section 7.3.1.                        |\n|               |   |   |                                           |\n| file-blocks   | X | A | Array of items of type \"Block\"; see       |\n|               |   |   | Section 7.3.2.  The array may be empty if |\n|               |   |   | the file contains no data.                |\n+---------------+---+---+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.1. \"FilePreamble\"",
      "section_title": true,
      "ja": "7.3.1. 「FilePreamble」"
    },
    {
      "indent": 3,
      "text": "Information about data in the file. A map containing the following:",
      "ja": "ファイル内のデータに関する情報。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+----------------------+---+---+------------------------------------+\n| Field                | M | T | Description                        |\n+----------------------+---+---+------------------------------------+\n| major-format-version | X | U | Unsigned integer \"1\".  The major   |\n|                      |   |   | version of the format used in the  |\n|                      |   |   | file.  See Section 8.              |\n|                      |   |   |                                    |\n| minor-format-version | X | U | Unsigned integer \"0\".  The minor   |\n|                      |   |   | version of the format used in the  |\n|                      |   |   | file.  See Section 8.              |\n|                      |   |   |                                    |\n| private-version      |   | U | Version indicator available for    |\n|                      |   |   | private use by implementations.    |\n|                      |   |   |                                    |\n| block-parameters     | X | A | Array of items of type             |\n|                      |   |   | \"BlockParameters\".  See Section    |\n|                      |   |   | 7.3.1.1.  The array must contain   |\n|                      |   |   | at least one entry.  (The          |\n|                      |   |   | \"block-parameters-index\" item in   |\n|                      |   |   | each \"BlockPreamble\" indicates     |\n|                      |   |   | which array entry applies to that  |\n|                      |   |   | \"Block\".)                          |\n+----------------------+---+---+------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.1.1. \"BlockParameters\"",
      "section_title": true,
      "ja": "7.3.1.1. 「BlockParameters」"
    },
    {
      "indent": 3,
      "text": "Parameters relating to data storage and collection that apply to one or more items of type \"Block\". A map containing the following:",
      "ja": "タイプ「ブロック」の1つ以上のアイテムに適用されるデータストレージおよびコレクションに関連するパラメーター。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+-----------------------+---+---+-----------------------------------+\n| Field                 | M | T | Description                       |\n+-----------------------+---+---+-----------------------------------+\n| storage-parameters    | X | M | Parameters relating to data       |\n|                       |   |   | storage in a \"Block\" item.  Map   |\n|                       |   |   | of type \"StorageParameters\"; see  |\n|                       |   |   | Section 7.3.1.1.1.                |\n|                       |   |   |                                   |\n| collection-parameters |   | M | Parameters relating to collection |\n|                       |   |   | of the data in a \"Block\" item.    |\n|                       |   |   | Map of type                       |\n|                       |   |   | \"CollectionParameters\"; see       |\n|                       |   |   | Section 7.3.1.1.2.                |\n+-----------------------+---+---+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.1.1.1. \"StorageParameters\"",
      "section_title": true,
      "ja": "7.3.1.1.1. 「StorageParameters」"
    },
    {
      "indent": 3,
      "text": "Parameters relating to how data is stored in the items of type \"Block\". A map containing the following:",
      "ja": "タイプが「ブロック」のアイテムにデータを保存する方法に関するパラメータ。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| ticks-per-second | X | U | Sub-second timing is recorded in       |\n|                  |   |   | ticks.  This specifies the number of   |\n|                  |   |   | ticks in a second.                     |\n|                  |   |   |                                        |\n| max-block-items  | X | U | The maximum number of items stored in  |\n|                  |   |   | any of the arrays in a \"Block\" item    |\n|                  |   |   | (Q/R, Address/Event Count, or          |\n|                  |   |   | Malformed Message data items).  An     |\n|                  |   |   | indication to a decoder of the         |\n|                  |   |   | resources needed to process the file.  |\n|                  |   |   |                                        |\n| storage-hints    | X | M | Collection of hints as to which fields |\n|                  |   |   | are omitted in the arrays that have    |\n|                  |   |   | optional fields.  Map of type          |\n|                  |   |   | \"StorageHints\".  See Section           |\n|                  |   |   | 7.3.1.1.1.1.                           |\n|                  |   |   |                                        |\n| opcodes          | X | A | Array of OPCODES [opcodes] (unsigned   |\n|                  |   |   | integers, each in the range 0 to 15    |\n|                  |   |   | inclusive) recorded by the collecting  |\n|                  |   |   | implementation.  See Section 6.2.2.    |\n|                  |   |   |                                        |\n| rr-types         | X | A | Array of RR TYPEs [rrtypes] (unsigned  |\n|                  |   |   | integers, each in the range 0 to 65535 |\n|                  |   |   | inclusive) recorded by the collecting  |\n|                  |   |   | implementation.  See Section 6.2.2.    |\n|                  |   |   |                                        |\n| storage-flags    |   | U | Bit flags indicating attributes of     |\n|                  |   |   | stored data.                           |\n|                  |   |   | Bit 0.  1 if the data has been         |\n|                  |   |   | anonymized.                            |\n|                  |   |   | Bit 1.  1 if the data is sampled data. |\n|                  |   |   | Bit 2.  1 if the names have been       |\n|                  |   |   | normalized (converted to uniform       |\n|                  |   |   | case).                                 |\n|                  |   |   |                                        |\n| client-address   |   | U | IPv4 client address prefix length, in  |\n| -prefix-ipv4     |   |   | the range 1 to 32 inclusive.  If       |\n|                  |   |   | specified, only the address prefix     |\n|                  |   |   | bits are stored.                       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|                  |   |   |                                        |\n| client-address   |   | U | IPv6 client address prefix length, in  |\n| -prefix-ipv6     |   |   | the range 1 to 128 inclusive.  If      |\n|                  |   |   | specified, only the address prefix     |\n|                  |   |   | bits are stored.                       |\n|                  |   |   |                                        |\n| server-address   |   | U | IPv4 server address prefix length, in  |\n| -prefix-ipv4     |   |   | the range 1 to 32 inclusive.  If       |\n|                  |   |   | specified, only the address prefix     |\n|                  |   |   | bits are stored.                       |\n|                  |   |   |                                        |\n| server-address   |   | U | IPv6 server address prefix length, in  |\n| -prefix-ipv6     |   |   | the range 1 to 128 inclusive.  If      |\n|                  |   |   | specified, only the address prefix     |\n|                  |   |   | bits are stored.                       |\n|                  |   |   |                                        |\n| sampling-method  |   | T | Information on the sampling method     |\n|                  |   |   | used.  See Section 6.2.3.              |\n|                  |   |   |                                        |\n| anonymization    |   | T | Information on the anonymization       |\n| -method          |   |   | method used.  See Section 6.2.3.       |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.1.1.1.1. \"StorageHints\"",
      "section_title": true,
      "ja": "7.3.1.1.1.1. 「StorageHints」"
    },
    {
      "indent": 3,
      "text": "An indicator of which fields the collecting implementation omits in the maps with optional fields. Note that hints have a top-down precedence. In other words, where a map contains another map, the hint on the containing map overrides any hints in the contained map and the contained map is omitted. A map containing the following:",
      "ja": "収集実装がオプションのフィールドを含むマップでどのフィールドを省略するかのインジケーター。 ヒントにはトップダウンの優先順位があることに注意してください。 つまり、マップに別のマップが含まれる場合、含まれるマップのヒントは含まれるマップのヒントをオーバーライドし、含まれるマップは省略されます。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| query-response   | X | U | Hints indicating which \"QueryResponse\" |\n| -hints           |   |   | fields are omitted; see Section        |\n|                  |   |   | 7.3.2.4.  If a bit is unset, the field |\n|                  |   |   | is omitted from the capture.           |\n|                  |   |   | Bit 0.  time-offset                    |\n|                  |   |   | Bit 1.  client-address-index           |\n|                  |   |   | Bit 2.  client-port                    |\n|                  |   |   | Bit 3.  transaction-id                 |\n|                  |   |   | Bit 4.  qr-signature-index             |\n|                  |   |   | Bit 5.  client-hoplimit                |\n|                  |   |   | Bit 6.  response-delay                 |\n|                  |   |   | Bit 7.  query-name-index               |\n|                  |   |   | Bit 8.  query-size                     |\n|                  |   |   | Bit 9.  response-size                  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|                  |   |   | Bit 10.  response-processing-data      |\n|                  |   |   | Bit 11.  query-question-sections       |\n|                  |   |   | Bit 12.  query-answer-sections         |\n|                  |   |   | Bit 13.  query-authority-sections      |\n|                  |   |   | Bit 14.  query-additional-sections     |\n|                  |   |   | Bit 15.  response-answer-sections      |\n|                  |   |   | Bit 16.  response-authority-sections   |\n|                  |   |   | Bit 17.  response-additional-sections  |\n|                  |   |   |                                        |\n| query-response   | X | U | Hints indicating which                 |\n| -signature-hints |   |   | \"QueryResponseSignature\" fields are    |\n|                  |   |   | omitted; see Section 7.3.2.3.2.  If a  |\n|                  |   |   | bit is unset, the field is omitted     |\n|                  |   |   | from the capture.                      |\n|                  |   |   | Bit 0.  server-address-index           |\n|                  |   |   | Bit 1.  server-port                    |\n|                  |   |   | Bit 2.  qr-transport-flags             |\n|                  |   |   | Bit 3.  qr-type                        |\n|                  |   |   | Bit 4.  qr-sig-flags                   |\n|                  |   |   | Bit 5.  query-opcode                   |\n|                  |   |   | Bit 6.  qr-dns-flags                   |\n|                  |   |   | Bit 7.  query-rcode                    |\n|                  |   |   | Bit 8.  query-classtype-index          |\n|                  |   |   | Bit 9.  query-qdcount                  |\n|                  |   |   | Bit 10.  query-ancount                 |\n|                  |   |   | Bit 11.  query-nscount                 |\n|                  |   |   | Bit 12.  query-arcount                 |\n|                  |   |   | Bit 13.  query-edns-version            |\n|                  |   |   | Bit 14.  query-udp-size                |\n|                  |   |   | Bit 15.  query-opt-rdata-index         |\n|                  |   |   | Bit 16.  response-rcode                |\n|                  |   |   |                                        |\n| rr-hints         | X | U | Hints indicating which optional \"RR\"   |\n|                  |   |   | fields are omitted; see Section        |\n|                  |   |   | 7.3.2.3.4.  If a bit is unset, the     |\n|                  |   |   | field is omitted from the capture.     |\n|                  |   |   | Bit 0.  ttl                            |\n|                  |   |   | Bit 1.  rdata-index                    |\n| other-data-hints | X | U | Hints indicating which other datatypes |\n|                  |   |   | are omitted.  If a bit is unset, the   |\n|                  |   |   | datatype is omitted from the capture.  |\n|                  |   |   | Bit 0.  malformed-messages             |\n|                  |   |   | Bit 1.  address-event-counts           |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2. \"CollectionParameters\"",
      "section_title": true,
      "ja": "7.3.1.1.2. 「CollectionParameters」"
    },
    {
      "indent": 3,
      "text": "Parameters providing information regarding how data in the file was collected (applicable for some, but not all, collection environments). The values are informational only and serve as metadata to downstream analyzers as to the configuration of a collecting implementation. They can provide context when interpreting what data is present/absent from the capture but cannot necessarily be validated against the data captured.",
      "ja": "ファイル内のデータが収集された方法に関する情報を提供するパラメーター（すべてではありませんが、一部の収集環境に適用可能）。 値は情報のみであり、収集実装の構成に関するダウンストリームアナライザーのメタデータとして機能します。 キャプチャに存在する/存在しないデータを解釈するときにコンテキストを提供できますが、キャプチャされたデータに対して必ずしも検証できるとは限りません。"
    },
    {
      "indent": 3,
      "text": "These parameters have no default. If they do not appear, nothing can be inferred about their value.",
      "ja": "これらのパラメーターにはデフォルトはありません。 表示されない場合、その値については何も推測できません。"
    },
    {
      "indent": 3,
      "text": "A map containing the following items:",
      "ja": "次のアイテムを含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| query-timeout    |   | U | To be matched with a Query, a Response |\n|                  |   |   | must arrive within this number of      |\n|                  |   |   | milliseconds.                          |\n|                  |   |   |                                        |\n| skew-timeout     |   | U | The network stack may report a         |\n|                  |   |   | Response before the corresponding      |\n|                  |   |   | Query.  A Response is not considered   |\n|                  |   |   | to be missing a Query until after this |\n|                  |   |   | many microseconds.                     |\n|                  |   |   |                                        |\n| snaplen          |   | U | Collect up to this many bytes per      |\n|                  |   |   | packet.                                |\n|                  |   |   |                                        |\n| promisc          |   | B | \"true\" if promiscuous mode             |\n|                  |   |   | [pcap-options] was enabled on the      |\n|                  |   |   | interface, \"false\" otherwise.          |\n|                  |   |   |                                        |\n| interfaces       |   | A | Array of identifiers (of type text     |\n|                  |   |   | string) of the interfaces used for     |\n|                  |   |   | collection.                            |\n|                  |   |   |                                        |\n| server-addresses |   | A | Array of server collection IP          |\n|                  |   |   | addresses (of type byte string).       |\n|                  |   |   | Metadata for downstream analyzers;     |\n|                  |   |   | does not affect collection.            |\n|                  |   |   |                                        |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| vlan-ids         |   | A | Array of identifiers (of type unsigned |\n|                  |   |   | integer, each in the range 1 to 4094   |\n|                  |   |   | inclusive) of VLANs [IEEE802.1Q]       |\n|                  |   |   | selected for collection.  VLAN IDs are |\n|                  |   |   | unique only within an administrative   |\n|                  |   |   | domain.                                |\n|                  |   |   |                                        |\n| filter           |   | T | Filter for input, in \"tcpdump\"         |\n|                  |   |   | [pcap-filter] style.                   |\n|                  |   |   |                                        |\n| generator-id     |   | T | Implementation-specific human-readable |\n|                  |   |   | string identifying the collection      |\n|                  |   |   | method.                                |\n|                  |   |   |                                        |\n| host-id          |   | T | String identifying the collecting      |\n|                  |   |   | host.                                  |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2. \"Block\"",
      "section_title": true,
      "ja": "7.3.2. \"ブロック\""
    },
    {
      "indent": 3,
      "text": "Container for data with common collection and storage parameters. A map containing the following:",
      "ja": "共通の収集および保管パラメーターを持つデータのコンテナー。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+--------------------+---+---+--------------------------------------+\n| Field              | M | T | Description                          |\n+--------------------+---+---+--------------------------------------+\n| block-preamble     | X | M | Overall information for the \"Block\"  |\n|                    |   |   | item.  Map of type \"BlockPreamble\";  |\n|                    |   |   | see Section 7.3.2.1.                 |\n|                    |   |   |                                      |\n| block-statistics   |   | M | Statistics about the \"Block\" item.   |\n|                    |   |   | Map of type \"BlockStatistics\"; see   |\n|                    |   |   | Section 7.3.2.2.                     |\n|                    |   |   |                                      |\n| block-tables       |   | M | The arrays containing data           |\n|                    |   |   | referenced by individual             |\n|                    |   |   | \"QueryResponse\" or                   |\n|                    |   |   | \"MalformedMessage\" items.  Map of    |\n|                    |   |   | type \"BlockTables\"; see Section      |\n|                    |   |   | 7.3.2.3.                             |\n|                    |   |   |                                      |\n| query-responses    |   | A | Details of individual C-DNS Q/R data |\n|                    |   |   | items.  Array of items of type       |\n|                    |   |   | \"QueryResponse\"; see Section         |\n|                    |   |   | 7.3.2.4.  If present, the array must |\n|                    |   |   | not be empty.                        |\n|                    |   |   |                                      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| address-event      |   | A | Per-client counts of ICMP messages   |\n| -counts            |   |   | and TCP resets.  Array of items of   |\n|                    |   |   | type \"AddressEventCount\"; see        |\n|                    |   |   | Section 7.3.2.5.  If present, the    |\n|                    |   |   | array must not be empty.             |\n|                    |   |   |                                      |\n| malformed-messages |   | A | Details of malformed DNS messages.   |\n|                    |   |   | Array of items of type               |\n|                    |   |   | \"MalformedMessage\"; see Section      |\n|                    |   |   | 7.3.2.6.  If present, the array must |\n|                    |   |   | not be empty.                        |\n+--------------------+---+---+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.1. \"BlockPreamble\"",
      "section_title": true,
      "ja": "7.3.2.1. 「BlockPreamble」"
    },
    {
      "indent": 3,
      "text": "Overall information for a \"Block\" item. A map containing the following:",
      "ja": "「ブロック」アイテムの全体的な情報。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| earliest-time    | C | A | A timestamp (two unsigned integers, of |\n|                  |   |   | type \"Timestamp\") for the earliest     |\n|                  |   |   | record in the \"Block\" item.  The first |\n|                  |   |   | integer is the number of seconds since |\n|                  |   |   | the POSIX epoch [posix-time]           |\n|                  |   |   | (\"time_t\"), excluding leap seconds.    |\n|                  |   |   | The second integer is the number of    |\n|                  |   |   | ticks (see Section 7.3.1.1.1) since    |\n|                  |   |   | the start of the second.  This field   |\n|                  |   |   | is mandatory unless all block items    |\n|                  |   |   | containing a time offset from the      |\n|                  |   |   | start of the Block also omit that time |\n|                  |   |   | offset.                                |\n|                  |   |   |                                        |\n| block-parameters |   | U | The index of the item in the           |\n| -index           |   |   | \"block-parameters\" array (in the       |\n|                  |   |   | \"file-preamble\" item) applicable to    |\n|                  |   |   | this block.  If not present, index 0   |\n|                  |   |   | is used.  See Section 7.3.1.           |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.2. \"BlockStatistics\"",
      "section_title": true,
      "ja": "7.3.2.2. 「BlockStatistics」"
    },
    {
      "indent": 3,
      "text": "Basic statistical information about a \"Block\" item. A map containing the following:",
      "ja": "「ブロック」アイテムに関する基本的な統計情報。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+---------------------+---+---+-------------------------------------+\n| Field               | M | T | Description                         |\n+---------------------+---+---+-------------------------------------+\n| processed-messages  |   | U | Total number of well-formed DNS     |\n|                     |   |   | messages processed from the input   |\n|                     |   |   | traffic stream during collection of |\n|                     |   |   | data in this \"Block\" item.          |\n|                     |   |   |                                     |\n| qr-data-items       |   | U | Total number of Q/R data items in   |\n|                     |   |   | this \"Block\" item.                  |\n|                     |   |   |                                     |\n| unmatched-queries   |   | U | Number of unmatched Queries in this |\n|                     |   |   | \"Block\" item.                       |\n|                     |   |   |                                     |\n| unmatched-responses |   | U | Number of unmatched Responses in    |\n|                     |   |   | this \"Block\" item.                  |\n|                     |   |   |                                     |\n| discarded-opcode    |   | U | Number of DNS messages processed    |\n|                     |   |   | from the input traffic stream       |\n|                     |   |   | during collection of data in this   |\n|                     |   |   | \"Block\" item but not recorded       |\n|                     |   |   | because their OPCODE is not in the  |\n|                     |   |   | list to be collected.               |\n|                     |   |   |                                     |\n| malformed-items     |   | U | Number of malformed messages        |\n|                     |   |   | processed from the input traffic    |\n|                     |   |   | stream during collection of data in |\n|                     |   |   | this \"Block\" item.                  |\n+---------------------+---+---+-------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.3. \"BlockTables\"",
      "section_title": true,
      "ja": "7.3.2.3. 「BlockTables」"
    },
    {
      "indent": 3,
      "text": "Map of arrays containing data referenced by individual \"QueryResponse\" or \"MalformedMessage\" items in this \"Block\". Each element is an array that, if present, must not be empty.",
      "ja": "この「ブロック」内の個々の「QueryResponse」または「MalformedMessage」項目によって参照されるデータを含む配列のマップ。 各要素は配列であり、存在する場合は空にできません。"
    },
    {
      "indent": 3,
      "text": "An item in the \"qlist\" array contains indexes to values in the \"qrr\" array. Therefore, if \"qlist\" is present, \"qrr\" must also be present. Similarly, if \"rrlist\" is present, \"rr\" must also be present.",
      "ja": "「qlist」配列内の項目には、「qrr」配列内の値へのインデックスが含まれます。 したがって、「qlist」が存在する場合、「qrr」も存在する必要があります。 同様に、「rrlist」が存在する場合、「rr」も存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "The map contains the following items:",
      "ja": "マップには次のアイテムが含まれます。"
    },
    {
      "indent": 3,
      "text": "+-------------------+---+---+---------------------------------------+\n| Field             | M | T | Description                           |\n+-------------------+---+---+---------------------------------------+\n| ip-address        |   | A | Array of IP addresses, in network     |\n|                   |   |   | byte order (of type byte string).  If |\n|                   |   |   | client or server address prefixes are |\n|                   |   |   | set, only the address prefix bits are |\n|                   |   |   | stored.  Each string is therefore up  |\n|                   |   |   | to 4 bytes long for an IPv4 address,  |\n|                   |   |   | or up to 16 bytes long for an IPv6    |\n|                   |   |   | address.  See Section 7.3.1.1.1.      |\n|                   |   |   |                                       |\n| classtype         |   | A | Array of RR CLASS and TYPE            |\n|                   |   |   | information.  Type is \"ClassType\".    |\n|                   |   |   | See Section 7.3.2.3.1.                |\n|                   |   |   |                                       |\n| name-rdata        |   | A | Array where each entry is the         |\n|                   |   |   | contents of a single NAME or RDATA in |\n|                   |   |   | wire format (of type byte string).    |\n|                   |   |   | Note that NAMEs, and labels within    |\n|                   |   |   | RDATA contents, are full domain names |\n|                   |   |   | or labels; no name compression (per   |\n|                   |   |   | [RFC1035]) is used on the individual  |\n|                   |   |   | names/labels within the format.       |\n|                   |   |   |                                       |\n| qr-sig            |   | A | Array of Q/R data item signatures.    |\n|                   |   |   | Type is \"QueryResponseSignature\".     |\n|                   |   |   | See Section 7.3.2.3.2.                |\n|                   |   |   |                                       |\n| qlist             |   | A | Array of type \"QuestionList\".  A      |\n|                   |   |   | \"QuestionList\" is an array of         |\n|                   |   |   | unsigned integers, indexes to         |\n|                   |   |   | \"Question\" items in the \"qrr\" array.  |\n|                   |   |   |                                       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| qrr               |   | A | Array of type \"Question\".  Each entry |\n|                   |   |   | is the contents of a single Question, |\n|                   |   |   | where a Question is the second or     |\n|                   |   |   | subsequent Question in a Query.  See  |\n|                   |   |   | Section 7.3.2.3.3.                    |\n|                   |   |   |                                       |\n| rrlist            |   | A | Array of type \"RRList\".  An \"RRList\"  |\n|                   |   |   | is an array of unsigned integers,     |\n|                   |   |   | indexes to \"RR\" items in the \"rr\"     |\n|                   |   |   | array.                                |\n|                   |   |   |                                       |\n| rr                |   | A | Array of type \"RR\".  Each entry is    |\n|                   |   |   | the contents of a single RR.  See     |\n|                   |   |   | Section 7.3.2.3.4.                    |\n|                   |   |   |                                       |\n| malformed-message |   | A | Array of the contents of malformed    |\n| -data             |   |   | messages.  Array of type              |\n|                   |   |   | \"MalformedMessageData\".  See Section  |\n|                   |   |   | 7.3.2.3.5.                            |\n+-------------------+---+---+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.3.1. \"ClassType\"",
      "section_title": true,
      "ja": "7.3.2.3.1. 「ClassType」"
    },
    {
      "indent": 3,
      "text": "RR CLASS and TYPE information. A map containing the following:",
      "ja": "RRクラスおよびタイプ情報。 次を含むマップ："
    },
    {
      "indent": 15,
      "text": "+-------+---+---+--------------------------+\n| Field | M | T | Description              |\n+-------+---+---+--------------------------+\n| type  | X | U | TYPE value [rrtypes].    |\n|       |   |   |                          |\n| class | X | U | CLASS value [rrclasses]. |\n+-------+---+---+--------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.3.2. \"QueryResponseSignature\"",
      "section_title": true,
      "ja": "7.3.2.3.2. 「QueryResponseSignature」"
    },
    {
      "indent": 3,
      "text": "Elements of a Q/R data item that are often common between multiple individual Q/R data items. A map containing the following:",
      "ja": "多くの場合、複数の個々のQ / Rデータ項目間で共通するQ / Rデータ項目の要素。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+--------------------+---+---+--------------------------------------+\n| Field              | M | T | Description                          |\n+--------------------+---+---+--------------------------------------+\n| server-address     |   | U | The index in the \"ip-address\" array  |\n| -index             |   |   | of the server IP address.  See       |\n|                    |   |   | Section 7.3.2.3.                     |\n|                    |   |   |                                      |\n| server-port        |   | U | The server port.                     |\n|                    |   |   |                                      |\n| qr-transport-flags | C | U | Bit flags describing the transport   |\n|                    |   |   | used to service the Query.  Same     |\n|                    |   |   | definition as \"mm-transport-flags\"   |\n|                    |   |   | in Section 7.3.2.3.5, with an        |\n|                    |   |   | additional indicator for trailing    |\n|                    |   |   | bytes.  See Appendix A.              |\n|                    |   |   | Bit 0.  IP version.  0 if IPv4, 1 if |\n|                    |   |   | IPv6.  See Section 6.2.4.            |\n|                    |   |   | Bits 1-4.  Transport.  4-bit         |\n|                    |   |   | unsigned value where                 |\n|                    |   |   | 0 = UDP [RFC1035]                    |\n|                    |   |   | 1 = TCP [RFC1035]                    |\n|                    |   |   | 2 = TLS [RFC7858]                    |\n|                    |   |   | 3 = DTLS [RFC8094]                   |\n|                    |   |   | 4 = HTTPS [RFC8484]                  |\n|                    |   |   | 15 = Non-standard transport (see     |\n|                    |   |   | below)                               |\n|                    |   |   | Values 5-14 are reserved for future  |\n|                    |   |   | use.                                 |\n|                    |   |   | Bit 5.  1 if trailing bytes in Query |\n|                    |   |   | packet.  See Section 11.2.           |\n|                    |   |   |                                      |\n| qr-type            |   | U | Type of Query/Response transaction   |\n|                    |   |   | based on the definitions in the      |\n|                    |   |   | dnstap schema [dnstap-schema].       |\n|                    |   |   | 0 = Stub.  A transaction between a   |\n|                    |   |   | stub resolver and a DNS server from  |\n|                    |   |   | the perspective of the stub          |\n|                    |   |   | resolver.                            |\n|                    |   |   | 1 = Client.  A transaction between a |\n|                    |   |   | client and a DNS server (a proxy or  |\n|                    |   |   | full recursive resolver) from the    |\n|                    |   |   | perspective of the DNS server.       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|                    |   |   | 2 = Resolver.  A transaction between |\n|                    |   |   | a recursive resolver and an          |\n|                    |   |   | authoritative server from the        |\n|                    |   |   | perspective of the recursive         |\n|                    |   |   | resolver.                            |\n|                    |   |   | 3 = Authoritative.  A transaction    |\n|                    |   |   | between a recursive resolver and an  |\n|                    |   |   | authoritative server from the        |\n|                    |   |   | perspective of the authoritative     |\n|                    |   |   | server.                              |\n|                    |   |   | 4 = Forwarder.  A transaction        |\n|                    |   |   | between a downstream forwarder and   |\n|                    |   |   | an upstream DNS server (a recursive  |\n|                    |   |   | resolver) from the perspective of    |\n|                    |   |   | the downstream forwarder.            |\n|                    |   |   | 5 = Tool.  A transaction between a   |\n|                    |   |   | DNS software tool and a DNS server,  |\n|                    |   |   | from the perspective of the tool.    |\n|                    |   |   |                                      |\n| qr-sig-flags       |   | U | Bit flags explicitly indicating      |\n|                    |   |   | attributes of the message pair       |\n|                    |   |   | represented by this Q/R data item    |\n|                    |   |   | (not all attributes may be recorded  |\n|                    |   |   | or deducible).                       |\n|                    |   |   | Bit 0.  1 if a Query was present.    |\n|                    |   |   | Bit 1.  1 if a Response was present. |\n|                    |   |   | Bit 2.  1 if a Query was present and |\n|                    |   |   | it had an OPT RR.                    |\n|                    |   |   | Bit 3.  1 if a Response was present  |\n|                    |   |   | and it had an OPT RR.                |\n|                    |   |   | Bit 4.  1 if a Query was present but |\n|                    |   |   | had no Question.                     |\n|                    |   |   | Bit 5.  1 if a Response was present  |\n|                    |   |   | but had no Question (only one        |\n|                    |   |   | query-name-index is stored per Q/R   |\n|                    |   |   | data item).                          |\n|                    |   |   |                                      |\n| query-opcode       |   | U | Query OPCODE.                        |\n|                    |   |   |                                      |\n| qr-dns-flags       |   | U | Bit flags with values from the Query |\n|                    |   |   | and Response DNS flags.  Flag values |\n|                    |   |   | are 0 if the Query or Response is    |\n|                    |   |   | not present.                         |\n|                    |   |   | Bit 0.  Query Checking Disabled      |\n|                    |   |   | (CD).                                |\n|                    |   |   | Bit 1.  Query Authenticated Data     |\n|                    |   |   | (AD).                                |\n|                    |   |   | Bit 2.  Query reserved (Z).          |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|                    |   |   | Bit 3.  Query Recursion Available    |\n|                    |   |   | (RA).                                |\n|                    |   |   | Bit 4.  Query Recursion Desired      |\n|                    |   |   | (RD).                                |\n|                    |   |   | Bit 5.  Query TrunCation (TC).       |\n|                    |   |   | Bit 6.  Query Authoritative Answer   |\n|                    |   |   | (AA).                                |\n|                    |   |   | Bit 7.  Query DNSSEC answer OK (DO). |\n|                    |   |   | Bit 8.  Response Checking Disabled   |\n|                    |   |   | (CD).                                |\n|                    |   |   | Bit 9.  Response Authenticated Data  |\n|                    |   |   | (AD).                                |\n|                    |   |   | Bit 10.  Response reserved (Z).      |\n|                    |   |   | Bit 11.  Response Recursion          |\n|                    |   |   | Available (RA).                      |\n|                    |   |   | Bit 12.  Response Recursion Desired  |\n|                    |   |   | (RD).                                |\n|                    |   |   | Bit 13.  Response TrunCation (TC).   |\n|                    |   |   | Bit 14.  Response Authoritative      |\n|                    |   |   | Answer (AA).                         |\n|                    |   |   |                                      |\n| query-rcode        |   | U | Query RCODE.  If the Query contains  |\n|                    |   |   | an OPT RR [RFC6891], this value      |\n|                    |   |   | incorporates any EXTENDED-RCODE      |\n|                    |   |   | value [rcodes].                      |\n|                    |   |   |                                      |\n| query-classtype    |   | U | The index in the \"classtype\" array   |\n| -index             |   |   | of the CLASS and TYPE of the first   |\n|                    |   |   | Question.  See Section 7.3.2.3.      |\n|                    |   |   |                                      |\n| query-qdcount      |   | U | The QDCOUNT in the Query, or         |\n|                    |   |   | Response if no Query present.        |\n|                    |   |   |                                      |\n| query-ancount      |   | U | Query ANCOUNT.                       |\n|                    |   |   |                                      |\n| query-nscount      |   | U | Query NSCOUNT.                       |\n|                    |   |   |                                      |\n| query-arcount      |   | U | Query ARCOUNT.                       |\n|                    |   |   |                                      |\n| query-edns-version |   | U | The Query EDNS version.  (\"EDNS\"     |\n|                    |   |   | stands for Extension Mechanisms for  |\n|                    |   |   | DNS.)                                |\n|                    |   |   |                                      |\n| query-udp-size     |   | U | The Query EDNS sender's UDP payload  |\n|                    |   |   | size.                                |\n|                    |   |   |                                      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| query-opt-rdata    |   | U | The index in the \"name-rdata\" array  |\n| -index             |   |   | of the OPT RDATA.  See Section       |\n|                    |   |   | 7.3.2.3.                             |\n|                    |   |   |                                      |\n| response-rcode     |   | U | Response RCODE.  If the Response     |\n|                    |   |   | contains an OPT RR [RFC6891], this   |\n|                    |   |   | value incorporates any EXTENDED-     |\n|                    |   |   | RCODE value [rcodes].                |\n+--------------------+---+---+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Version 1.0 of C-DNS supports transport values corresponding to DNS transports defined in IETF Standards Track documents at the time of writing. There are numerous non-standard methods of sending DNS messages over various transports using a variety of protocols, but they are out of scope for this document. With the current specification, these can be generically stored using value 15 (Non-standard transport), or implementations are free to use the negative integer map keys to define their own mappings. Such non-standard transports may also be the subject of a future extension to the specification.",
      "ja": "C-DNSのバージョン1.0は、執筆時点でIETF Standards Trackドキュメントで定義されているDNSトランスポートに対応するトランスポート値をサポートしています。 さまざまなプロトコルを使用してさまざまなトランスポートを介してDNSメッセージを送信する多くの非標準の方法がありますが、それらはこのドキュメントの範囲外です。 現在の仕様では、これらは一般に値15（非標準トランスポート）を使用して保存できます。または、実装は自由に負の整数マップキーを使用して独自のマッピングを定義できます。 このような非標準のトランスポートも、仕様の将来の拡張の対象になる可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.3.2.3.3. \"Question\"",
      "section_title": true,
      "ja": "7.3.2.3.3. \"質問\""
    },
    {
      "indent": 3,
      "text": "Details on individual Questions in a Question section. A map containing the following:",
      "ja": "質問セクションの個々の質問の詳細。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+-----------------+---+---+-----------------------------------------+\n| Field           | M | T | Description                             |\n+-----------------+---+---+-----------------------------------------+\n| name-index      | X | U | The index in the \"name-rdata\" array of  |\n|                 |   |   | the QNAME.  See Section 7.3.2.3.        |\n|                 |   |   |                                         |\n| classtype-index | X | U | The index in the \"classtype\" array of   |\n|                 |   |   | the CLASS and TYPE of the Question.     |\n|                 |   |   | See Section 7.3.2.3.                    |\n+-----------------+---+---+-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.3.4. \"RR\"",
      "section_title": true,
      "ja": "7.3.2.3.4. 「RR」"
    },
    {
      "indent": 3,
      "text": "Details on individual RRs in RR sections. A map containing the following:",
      "ja": "RRセクションの個々のRRの詳細。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+-----------------+---+---+-----------------------------------------+\n| Field           | M | T | Description                             |\n+-----------------+---+---+-----------------------------------------+\n| name-index      | X | U | The index in the \"name-rdata\" array of  |\n|                 |   |   | the NAME.  See Section 7.3.2.3.         |\n|                 |   |   |                                         |\n| classtype-index | X | U | The index in the \"classtype\" array of   |\n|                 |   |   | the CLASS and TYPE of the RR.  See      |\n|                 |   |   | Section 7.3.2.3.                        |\n|                 |   |   |                                         |\n| ttl             |   | U | The RR Time to Live.                    |\n|                 |   |   |                                         |\n| rdata-index     |   | U | The index in the \"name-rdata\" array of  |\n|                 |   |   | the RR RDATA.  See Section 7.3.2.3.     |\n+-----------------+---+---+-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.3.5. \"MalformedMessageData\"",
      "section_title": true,
      "ja": "7.3.2.3.5. 「MalformedMessageData」"
    },
    {
      "indent": 3,
      "text": "Details on malformed DNS messages stored in this \"Block\" item. A map containing the following:",
      "ja": "この「ブロック」項目に保存されている不正なDNSメッセージの詳細。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+--------------------+---+---+--------------------------------------+\n| Field              | M | T | Description                          |\n+--------------------+---+---+--------------------------------------+\n| server-address     |   | U | The index in the \"ip-address\" array  |\n| -index             |   |   | of the server IP address.  See       |\n|                    |   |   | Section 7.3.2.3.                     |\n|                    |   |   |                                      |\n| server-port        |   | U | The server port.                     |\n|                    |   |   |                                      |\n| mm-transport-flags | C | U | Bit flags describing the transport   |\n|                    |   |   | used to service the Query.  See      |\n|                    |   |   | Section 6.2.4.                       |\n|                    |   |   | Bits 1-4.  Transport.  4-bit         |\n|                    |   |   | unsigned value where                 |\n|                    |   |   | 0 = UDP [RFC1035]                    |\n|                    |   |   | 1 = TCP [RFC1035]                    |\n|                    |   |   | 2 = TLS [RFC7858]                    |\n|                    |   |   | 3 = DTLS [RFC8094]                   |\n|                    |   |   | 4 = HTTPS [RFC8484]                  |\n|                    |   |   | 15 = Non-standard transport          |\n|                    |   |   | Values 5-14 are reserved for future  |\n|                    |   |   | use.                                 |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|                    |   |   |                                      |\n| mm-payload         |   | S | The payload (raw bytes) of the DNS   |\n|                    |   |   | message.                             |\n+--------------------+---+---+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.4. \"QueryResponse\"",
      "section_title": true,
      "ja": "7.3.2.4. 「QueryResponse」"
    },
    {
      "indent": 3,
      "text": "Details on individual Q/R data items.",
      "ja": "個々のQ / Rデータ項目の詳細。"
    },
    {
      "indent": 3,
      "text": "Note that there is no requirement that the elements of the \"query-responses\" array are presented in strict chronological order.",
      "ja": "「query-responses」配列の要素が厳密な時系列順に表示される必要はないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A map containing the following items:",
      "ja": "次のアイテムを含むマップ："
    },
    {
      "indent": 3,
      "text": "+----------------------+---+---+------------------------------------+\n| Field                | M | T | Description                        |\n+----------------------+---+---+------------------------------------+\n| time-offset          |   | U | Q/R timestamp as an offset in      |\n|                      |   |   | ticks (see Section 7.3.1.1.1) from |\n|                      |   |   | \"earliest-time\".  The timestamp is |\n|                      |   |   | the timestamp of the Query, or the |\n|                      |   |   | Response if there is no Query.     |\n|                      |   |   |                                    |\n| client-address-index |   | U | The index in the \"ip-address\"      |\n|                      |   |   | array of the client IP address.    |\n|                      |   |   | See Section 7.3.2.3.               |\n|                      |   |   |                                    |\n| client-port          |   | U | The client port.                   |\n|                      |   |   |                                    |\n| transaction-id       |   | U | DNS transaction identifier.        |\n|                      |   |   |                                    |\n| qr-signature-index   |   | U | The index in the \"qr-sig\" array of |\n|                      |   |   | the \"QueryResponseSignature\" item. |\n|                      |   |   | See Section 7.3.2.3.               |\n|                      |   |   |                                    |\n| client-hoplimit      |   | U | The IPv4 TTL or IPv6 Hoplimit from |\n|                      |   |   | the Query packet.                  |\n|                      |   |   |                                    |\n| response-delay       |   | I | The time difference between Query  |\n|                      |   |   | and Response, in ticks.  See       |\n|                      |   |   | Section 7.3.1.1.1.  Only present   |\n|                      |   |   | if there is a Query and a          |\n|                      |   |   | Response.  The delay can be        |\n|                      |   |   | negative if the network            |\n|                      |   |   | stack/capture library returns      |\n|                      |   |   | packets out of order.              |\n|                      |   |   |                                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| query-name-index     |   | U | The index in the \"name-rdata\"      |\n|                      |   |   | array of the item containing the   |\n|                      |   |   | QNAME for the first Question.  See |\n|                      |   |   | Section 7.3.2.3.                   |\n|                      |   |   |                                    |\n| query-size           |   | U | DNS Query message size (see        |\n|                      |   |   | below).                            |\n|                      |   |   |                                    |\n| response-size        |   | U | DNS Response message size (see     |\n|                      |   |   | below).                            |\n|                      |   |   |                                    |\n| response-processing  |   | M | Data on Response processing.  Map  |\n| -data                |   |   | of type \"ResponseProcessingData\".  |\n|                      |   |   | See Section 7.3.2.4.1.             |\n|                      |   |   |                                    |\n| query-extended       |   | M | Extended Query data.  Map of type  |\n|                      |   |   | \"QueryResponseExtended\".  See      |\n|                      |   |   | Section 7.3.2.4.2.                 |\n|                      |   |   |                                    |\n| response-extended    |   | M | Extended Response data.  Map of    |\n|                      |   |   | type \"QueryResponseExtended\".  See |\n|                      |   |   | Section 7.3.2.4.2.                 |\n+----------------------+---+---+------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"query-size\" and \"response-size\" fields hold the DNS message size. For UDP, this is the size of the UDP payload that contained the DNS message. For TCP, it is the size of the DNS message as specified in the two-byte message length header. Trailing bytes in UDP Queries are routinely observed in traffic to authoritative servers, and this value allows a calculation of how many trailing bytes were present.",
      "ja": "「query-size」および「response-size」フィールドには、DNSメッセージサイズが保持されます。 UDPの場合、これはDNSメッセージを含むUDPペイロードのサイズです。 TCPの場合、2バイトのメッセージ長ヘッダーで指定されているDNSメッセージのサイズです。 UDPクエリの末尾のバイトは、信頼できるサーバーへのトラフィックで定期的に観察され、この値により、存在する末尾のバイト数を計算できます。"
    },
    {
      "indent": 0,
      "text": "7.3.2.4.1. \"ResponseProcessingData\"",
      "section_title": true,
      "ja": "7.3.2.4.1. 「ResponseProcessingData」"
    },
    {
      "indent": 3,
      "text": "Information on the server processing that produced the Response. A map containing the following:",
      "ja": "応答を生成したサーバー処理に関する情報。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| bailiwick-index  |   | U | The index in the \"name-rdata\" array of |\n|                  |   |   | the owner name for the Response        |\n|                  |   |   | bailiwick.  See Section 7.3.2.3.       |\n|                  |   |   |                                        |\n| processing-flags |   | U | Flags relating to Response processing. |\n|                  |   |   | Bit 0.  1 if the Response came from    |\n|                  |   |   | cache.                                 |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.4.2. \"QueryResponseExtended\"",
      "section_title": true,
      "ja": "7.3.2.4.2. 「QueryResponse拡張」"
    },
    {
      "indent": 3,
      "text": "Extended data on the Q/R data item.",
      "ja": "Q / Rデータ項目の拡張データ。"
    },
    {
      "indent": 3,
      "text": "Each item in the map is present only if collection of the relevant details is configured.",
      "ja": "マップ内の各アイテムは、関連する詳細のコレクションが構成されている場合にのみ表示されます。"
    },
    {
      "indent": 3,
      "text": "A map containing the following items:",
      "ja": "次のアイテムを含むマップ："
    },
    {
      "indent": 3,
      "text": "+------------------+---+---+----------------------------------------+\n| Field            | M | T | Description                            |\n+------------------+---+---+----------------------------------------+\n| question-index   |   | U | The index in the \"qlist\" array of the  |\n|                  |   |   | entry listing any second and           |\n|                  |   |   | subsequent Questions in the Question   |\n|                  |   |   | section for the Query or Response.     |\n|                  |   |   | See Section 7.3.2.3.                   |\n|                  |   |   |                                        |\n| answer-index     |   | U | The index in the \"rrlist\" array of the |\n|                  |   |   | entry listing the Answer RR sections   |\n|                  |   |   | for the Query or Response.  See        |\n|                  |   |   | Section 7.3.2.3.                       |\n|                  |   |   |                                        |\n| authority-index  |   | U | The index in the \"rrlist\" array of the |\n|                  |   |   | entry listing the Authority RR         |\n|                  |   |   | sections for the Query or Response.    |\n|                  |   |   | See Section 7.3.2.3.                   |\n|                  |   |   |                                        |\n| additional-index |   | U | The index in the \"rrlist\" array of the |\n|                  |   |   | entry listing the Additional RR        |\n|                  |   |   | sections for the Query or Response.    |\n|                  |   |   | See Section 7.3.2.3.  Note that Query  |\n|                  |   |   | OPT RR data can optionally be stored   |\n|                  |   |   | in the QuerySignature.                 |\n+------------------+---+---+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.5. \"AddressEventCount\"",
      "section_title": true,
      "ja": "7.3.2.5. 「AddressEventCount」"
    },
    {
      "indent": 3,
      "text": "Counts of various IP-related events relating to traffic with individual client addresses. A map containing the following:",
      "ja": "個々のクライアントアドレスを持つトラフィックに関連するさまざまなIP関連イベントのカウント。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+--------------------+---+---+--------------------------------------+\n| Field              | M | T | Description                          |\n+--------------------+---+---+--------------------------------------+\n| ae-type            | X | U | The type of event.  The following    |\n|                    |   |   | event types are currently defined:   |\n|                    |   |   | 0.  TCP reset.                       |\n|                    |   |   | 1.  ICMP time exceeded.              |\n|                    |   |   | 2.  ICMP destination unreachable.    |\n|                    |   |   | 3.  ICMPv6 time exceeded.            |\n|                    |   |   | 4.  ICMPv6 destination unreachable.  |\n|                    |   |   | 5.  ICMPv6 packet too big.           |\n|                    |   |   |                                      |\n| ae-code            |   | U | A code relating to the event.  For   |\n|                    |   |   | ICMP or ICMPv6 events, this MUST be  |\n|                    |   |   | the ICMP [RFC792] or ICMPv6          |\n|                    |   |   | [RFC4443] code.  For other events,   |\n|                    |   |   | the contents are undefined.          |\n|                    |   |   |                                      |\n| ae-transport-flags | C | U | Bit flags describing the transport   |\n|                    |   |   | used to service the event.  See      |\n|                    |   |   | Section 6.2.4.                       |\n|                    |   |   | Bit 0.  IP version.  0 if IPv4, 1 if |\n|                    |   |   | IPv6.                                |\n|                    |   |   | Bits 1-4.  Transport.  4-bit         |\n|                    |   |   | unsigned value where                 |\n|                    |   |   | 0 = UDP [RFC1035]                    |\n|                    |   |   | 1 = TCP [RFC1035]                    |\n|                    |   |   | 2 = TLS [RFC7858]                    |\n|                    |   |   | 3 = DTLS [RFC8094]                   |\n|                    |   |   | 4 = HTTPS [RFC8484]                  |\n|                    |   |   | 15 = Non-standard transport          |\n|                    |   |   | Values 5-14 are reserved for future  |\n|                    |   |   | use.                                 |\n|                    |   |   |                                      |\n| ae-address-index   | X | U | The index in the \"ip-address\" array  |\n|                    |   |   | of the client address.  See Section  |\n|                    |   |   | 7.3.2.3.                             |\n|                    |   |   |                                      |\n| ae-count           | X | U | The number of occurrences of this    |\n|                    |   |   | event during the Block collection    |\n|                    |   |   | period.                              |\n+--------------------+---+---+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2.6. \"MalformedMessage\"",
      "section_title": true,
      "ja": "7.3.2.6. 「MalformedMessage」"
    },
    {
      "indent": 3,
      "text": "Details on Malformed Message data items. A map containing the following:",
      "ja": "不正な形式のメッセージデータ項目の詳細。 次を含むマップ："
    },
    {
      "indent": 3,
      "text": "+----------------------+---+---+------------------------------------+\n| Field                | M | T | Description                        |\n+----------------------+---+---+------------------------------------+\n| time-offset          |   | U | Message timestamp as an offset in  |\n|                      |   |   | ticks (see Section 7.3.1.1.1) from |\n|                      |   |   | \"earliest-time\".                   |\n|                      |   |   |                                    |\n| client-address-index |   | U | The index in the \"ip-address\"      |\n|                      |   |   | array of the client IP address.    |\n|                      |   |   | See Section 7.3.2.3.               |\n|                      |   |   |                                    |\n| client-port          |   | U | The client port.                   |\n|                      |   |   |                                    |\n| message-data-index   |   | U | The index in the \"malformed-       |\n|                      |   |   | message-data\" array of the message |\n|                      |   |   | data for this message.  See        |\n|                      |   |   | Section 7.3.2.3.                   |\n+----------------------+---+---+------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Versioning",
      "section_title": true,
      "ja": "8. バージョニング"
    },
    {
      "indent": 3,
      "text": "The C-DNS File Preamble includes a file Format Version; a major and minor version number are required fields. This document defines version 1.0 of the C-DNS specification. This section describes the intended use of these version numbers in future specifications.",
      "ja": "C-DNSファイルプリアンブルには、ファイル形式バージョンが含まれています。 メジャーバージョン番号とマイナーバージョン番号は必須フィールドです。 このドキュメントでは、C-DNS仕様のバージョン1.0を定義しています。 このセクションでは、将来の仕様におけるこれらのバージョン番号の使用目的について説明します。"
    },
    {
      "indent": 3,
      "text": "It is noted that version 1.0 includes many optional fields; therefore, consumers of version 1.0 should be inherently robust to parsing files with variable data content.",
      "ja": "バージョン1.0には多くのオプションフィールドが含まれていることに注意してください。 したがって、バージョン1.0のコンシューマは、可変データコンテンツを含むファイルの解析に対して本質的に堅牢である必要があります。"
    },
    {
      "indent": 3,
      "text": "Within a major version, a new minor version MUST be a strict superset of the previous minor version, with no semantic changes to existing fields. New keys MAY be added to existing maps, and new maps MAY be added. A consumer capable of reading a particular major.minor version MUST also be capable of reading all previous minor versions of the same major version. It SHOULD also be capable of parsing all subsequent minor versions, ignoring any keys or maps that it does not recognize.",
      "ja": "メジャーバージョン内では、新しいマイナーバージョンは、既存のフィールドに意味的な変更を加えずに、前のマイナーバージョンの厳密なスーパーセットでなければなりません。 既存のマップに新しいキーを追加できます。また、新しいマップを追加できます。 特定のmajor.minorバージョンを読み取ることができるコンシューマは、同じメジャーバージョンの以前のすべてのマイナーバージョンも読み取ることができる必要があります。 また、後続のすべてのマイナーバージョンを解析し、認識できないキーやマップを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "A new major version indicates changes to the format that are not backwards compatible with previous major versions. A consumer capable of only reading a particular major version (greater than 1) is neither required nor expected to be capable of reading a previous major version.",
      "ja": "新しいメジャーバージョンは、以前のメジャーバージョンとの下位互換性がない形式への変更を示します。 特定のメジャーバージョン（1を超える）のみを読み取ることができるコンシューマーは、以前のメジャーバージョンを読み取ることができる必要はありません。"
    },
    {
      "indent": 0,
      "text": "9. C-DNS to PCAP",
      "section_title": true,
      "ja": "9. C-DNSからPCAP"
    },
    {
      "indent": 3,
      "text": "It is usually possible to reconstruct PCAP files from the C-DNS format in a lossy fashion. Some of the issues with reconstructing both the DNS payload and the full packet stream are outlined here.",
      "ja": "通常、損失のある方法でC-DNS形式からPCAPファイルを再構築することが可能です。 ここでは、DNSペイロードと完全なパケットストリームの両方を再構築する際の問題の一部を概説します。"
    },
    {
      "indent": 3,
      "text": "The reconstruction of well-formed DNS messages depends on two factors:",
      "ja": "整形式DNSメッセージの再構築は、2つの要因に依存します。"
    },
    {
      "indent": 3,
      "text": "1. Whether or not a particular subset of the optional fields were captured in the C-DNS file, specifically the data fields necessary to reconstruct a valid IP header and DNS payload for both Query and Response (see Appendix D.1). Clearly, if not all these data fields were captured, the reconstruction is likely to be imperfect even if reasonable defaults are provided for the reconstruction.",
      "ja": "1. オプションフィールドの特定のサブセットがC-DNSファイルにキャプチャされたかどうか、具体的にはクエリとレスポンスの両方に対して有効なIPヘッダーとDNSペイロードを再構築するために必要なデータフィールド（付録D.1を参照）。 明らかに、これらのすべてのデータフィールドがキャプチャされなかった場合、再構築に合理的なデフォルトが提供されていても、再構築は不完全である可能性が高い。"
    },
    {
      "indent": 3,
      "text": "2. Whether or not at least one field was captured that unambiguously identifies the Query/Response data item as containing just a Query, just a Response, or a Query/Response pair. Obviously, the qr-sig-flags defined in Section 7.3.2.3.2 is such a field; however, this field is optional. For more details, see Appendix D.2.",
      "ja": "2. クエリ、レスポンス、またはクエリ/レスポンスペアのみを含むクエリ/レスポンスデータ項目を明確に識別する少なくとも1つのフィールドがキャプチャされたかどうか。 明らかに、セクション7.3.2.3.2で定義されているqr-sig-flagsはそのようなフィールドです。 ただし、このフィールドはオプションです。 詳細については、付録D.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is noted again that simply having hints that indicate that certain data fields were not omitted does not guarantee that those data fields were actually captured. Therefore, the ability to reconstruct PCAP data (in the absence of defaults) can in principle vary for each record captured in a C-DNS file, and between Blocks that have differing hints.",
      "ja": "特定のデータフィールドが省略されなかったことを示すヒントを単に持っているだけでは、それらのデータフィールドが実際にキャプチャされたことを保証しないことに再び注意してください。 そのため、PCAPデータを再構築する機能（デフォルトがない場合）は、原則として、C-DNSファイルでキャプチャされた各レコード、およびヒントが異なるブロック間で異なります。"
    },
    {
      "indent": 3,
      "text": "Even if all sections of the Response were captured, one cannot reconstruct the DNS Response payload exactly, due to the fact that some DNS names in the message on the wire may have been compressed. Section 9.1 discusses this in more detail.",
      "ja": "応答のすべてのセクションがキャプチャされた場合でも、ワイヤ上のメッセージの一部のDNS名が圧縮されている可能性があるため、DNS応答ペイロードを正確に再構築することはできません。 これについては、セクション9.1で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Some transport information is not captured in the C-DNS format. For example, the following aspects of the original packet stream cannot be reconstructed from the C-DNS format:",
      "ja": "一部のトランスポート情報は、C-DNS形式でキャプチャされません。 たとえば、元のパケットストリームの次の側面は、C-DNS形式から再構築できません。"
    },
    {
      "indent": 3,
      "text": "o IP fragmentation",
      "ja": "o IPフラグメンテーション"
    },
    {
      "indent": 3,
      "text": "o TCP stream information:",
      "ja": "o TCPストリーム情報："
    },
    {
      "indent": 6,
      "text": "* Multiple DNS messages may have been sent in a single TCP segment",
      "ja": "* 複数のDNSメッセージが単一のTCPセグメントで送信された可能性があります"
    },
    {
      "indent": 6,
      "text": "* A DNS payload may have been split across multiple TCP segments",
      "ja": "* DNSペイロードが複数のTCPセグメントに分割されている可能性があります"
    },
    {
      "indent": 6,
      "text": "* Multiple DNS messages may have been sent on a single TCP session",
      "ja": "* 単一のTCPセッションで複数のDNSメッセージが送信された可能性があります"
    },
    {
      "indent": 3,
      "text": "o TLS session information:",
      "ja": "o TLSセッション情報："
    },
    {
      "indent": 6,
      "text": "* TLS version or cipher suites",
      "ja": "* TLSバージョンまたは暗号スイート"
    },
    {
      "indent": 6,
      "text": "* TLS-related features such as TCP Fast Open (TFO) [RFC7413] or TLS session resumption [RFC5077]",
      "ja": "* TCP Fast Open（TFO）[RFC7413]やTLSセッション再開[RFC5077]などのTLS関連機能"
    },
    {
      "indent": 3,
      "text": "o DNS-over-HTTPS [RFC8484] message details:",
      "ja": "o DNS-over-HTTPS [RFC8484]メッセージの詳細："
    },
    {
      "indent": 6,
      "text": "* Whether the message used POST or GET",
      "ja": "* メッセージがPOSTまたはGETを使用したかどうか"
    },
    {
      "indent": 6,
      "text": "* HTTPS Headers",
      "ja": "* HTTPSヘッダー"
    },
    {
      "indent": 3,
      "text": "o Malformed DNS messages if the wire format is not recorded",
      "ja": "o ワイヤー形式が記録されていない場合の不正なDNSメッセージ"
    },
    {
      "indent": 3,
      "text": "o Any non-DNS messages that were in the original packet stream, e.g., ICMP",
      "ja": "o 元のパケットストリームにあった非DNSメッセージ（ICMPなど）"
    },
    {
      "indent": 3,
      "text": "Simple assumptions can be made on the reconstruction: fragmented and DNS-over-TCP messages can be reconstructed into single packets, and a single TCP session can be constructed for each TCP packet.",
      "ja": "再構築では、単純な仮定を立てることができます。断片化されたメッセージとDNS-over-TCPメッセージを単一のパケットに再構築し、各TCPパケットに対して単一のTCPセッションを構築できます。"
    },
    {
      "indent": 3,
      "text": "Additionally, if malformed messages and non-DNS packets are captured separately, they can be merged with packet captures reconstructed from C-DNS to produce a more complete packet stream.",
      "ja": "さらに、不正な形式のメッセージとDNS以外のパケットが別々にキャプチャされた場合、C-DNSから再構築されたパケットキャプチャとマージして、より完全なパケットストリームを生成できます。"
    },
    {
      "indent": 0,
      "text": "9.1. Name Compression",
      "section_title": true,
      "ja": "9.1. 名前の圧縮"
    },
    {
      "indent": 3,
      "text": "All the names stored in the C-DNS format are full domain names; no name compression (per [RFC1035]) is used on the individual names within the format. Therefore, when reconstructing a packet, name compression must be used in order to reproduce the on-the-wire representation of the packet.",
      "ja": "C-DNS形式で保存される名前はすべて完全なドメイン名です。 （[RFC1035]による）名前の圧縮は、形式内の個々の名前には使用されません。 したがって、パケットを再構築する場合、パケットのオンワイヤ表現を再現するために名前圧縮を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Name compression per [RFC1035] works by substituting trailing sections of a name with a reference back to the occurrence of those sections earlier in the message. Not all name server software uses the same algorithm when compressing domain names within the Responses. Some attempt maximum recompression at the expense of runtime resources, others use heuristics to balance compression and speed, and others use different rules for what is a valid compression target.",
      "ja": "[RFC1035]による名前の圧縮は、名前の末尾のセクションを、メッセージの前の部分の出現に戻る参照で置き換えることにより機能します。 レスポンス内のドメイン名を圧縮するときに、すべてのネームサーバーソフトウェアが同じアルゴリズムを使用するわけではありません。 ランタイムリソースを犠牲にして最大の再圧縮を試みるものもあれば、ヒューリスティックを使用して圧縮と速度のバランスをとるものもあれば、有効な圧縮ターゲットに対して異なるルールを使用するものもあります。"
    },
    {
      "indent": 3,
      "text": "This means that Responses to the same Query from different name server software that match in terms of DNS payload content (header, counts, RRs with name compression removed) do not necessarily match byte for byte on the wire.",
      "ja": "これは、DNSペイロードコンテンツ（ヘッダー、カウント、名前圧縮が削除されたRR）の点で一致する異なるネームサーバーソフトウェアからの同じクエリへの応答が、ワイヤ上のバイトごとに必ずしも一致しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Therefore, it is not possible to ensure that the DNS Response payload is reconstructed byte for byte from C-DNS data. However, it can at least, in principle, be reconstructed to have the correct payload length (since the original Response length is captured) if there is enough knowledge of the commonly implemented name compression algorithms. For example, a simplistic approach would be to try each algorithm in turn to see if it reproduces the original length, stopping at the first match. This would not guarantee that the correct algorithm has been used, as it is possible to match the length whilst still not matching the on-the-wire bytes; however, without further information added to the C-DNS data, this is the best that can be achieved.",
      "ja": "したがって、DNS応答ペイロードがC-DNSデータからバイトごとに再構築されることを保証することはできません。 ただし、一般に実装されている名前圧縮アルゴリズムの十分な知識があれば、少なくとも原則として、正しいペイロード長になるように再構築できます（元の応答長がキャプチャされるため）。 たとえば、単純なアプローチでは、各アルゴリズムを順番に試して、最初の一致で停止して元の長さを再現するかどうかを確認します。 これは正しいアルゴリズムが使用されていることを保証するものではありません。それは、送信中のバイトと一致しないままで長さを一致させることが可能であるためです。 ただし、C-DNSデータに追加の情報が追加されていない場合、これは達成可能な最善の方法です。"
    },
    {
      "indent": 3,
      "text": "Appendix B presents an example of two different compression algorithms used by well-known name server software.",
      "ja": "付録Bでは、有名なネームサーバーソフトウェアで使用される2つの異なる圧縮アルゴリズムの例を示します。"
    },
    {
      "indent": 0,
      "text": "10. Data Collection",
      "section_title": true,
      "ja": "10. データ収集"
    },
    {
      "indent": 3,
      "text": "This section describes a non-normative proposed algorithm for the processing of a captured stream of DNS Queries and Responses and production of a stream of Q/R data items, matching Queries and Responses where possible.",
      "ja": "このセクションでは、DNSクエリと応答のキャプチャされたストリームの処理と、可能な場合はクエリと応答に一致するQ / Rデータ項目のストリームの生成のための非規範的な提案アルゴリズムについて説明します。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this discussion, it is assumed that the input has been preprocessed such that:",
      "ja": "この説明の目的上、入力は次のように前処理されていると想定されます。"
    },
    {
      "indent": 3,
      "text": "1. All IP fragmentation reassembly, TCP stream reassembly, and so on, have already been performed.",
      "ja": "1. すべてのIPフラグメンテーションの再構成、TCPストリームの再構成などがすでに実行されています。"
    },
    {
      "indent": 3,
      "text": "2. Each message is associated with transport metadata required to generate the Primary ID (see Section 10.2.1).",
      "ja": "2. 各メッセージは、プライマリIDの生成に必要なトランスポートメタデータに関連付けられています（セクション10.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "3. Each message has a well-formed DNS Header of 12 bytes, and (if present) the first Question in the Question section can be parsed to generate the Secondary ID (see below). As noted earlier, this requirement can result in a malformed Query being removed in the preprocessing stage, but the correctly formed Response with RCODE of FORMERR being present.",
      "ja": "3. 各メッセージには12バイトの整形式DNSヘッダーがあり、（存在する場合）質問セクションの最初の質問を解析して、セカンダリIDを生成できます（以下を参照）。 前述のように、この要件により、前処理段階で不正な形式のクエリが削除される可能性がありますが、FORMERRのRCODEを含む正しい形式の応答が存在します。"
    },
    {
      "indent": 3,
      "text": "DNS messages are processed in the order they are delivered to the implementation.",
      "ja": "DNSメッセージは、実装に配信される順序で処理されます。"
    },
    {
      "indent": 3,
      "text": "It should be noted that packet capture libraries do not necessarily provide packets in strict chronological order. This can, for example, arise on multi-core platforms where packets arriving at a network device are processed by different cores. On systems where this behavior has been observed, the timestamps associated with each packet are consistent; Queries always have a timestamp prior to the Response timestamp. However, the order in which these packets appear in the packet capture stream is not necessarily strictly chronological; a Response can appear in the capture stream before the Query that provoked the Response. For this discussion, this non-chronological delivery is termed \"skew\".",
      "ja": "パケットキャプチャライブラリは必ずしも厳密な時系列順にパケットを提供するわけではないことに注意してください。 これは、たとえば、ネットワークデバイスに到着するパケットが異なるコアで処理されるマルチコアプラットフォームで発生する可能性があります。 この動作が観察されたシステムでは、各パケットに関連付けられたタイムスタンプは一貫しています。 クエリには常に、応答タイムスタンプの前にタイムスタンプがあります。 ただし、これらのパケットがパケットキャプチャストリームに表示される順序は、必ずしも厳密に時系列ではありません。 応答は、応答を引き起こしたクエリの前のキャプチャストリームに表示できます。 この議論では、この時系列ではない配信を「スキュー」と呼びます。"
    },
    {
      "indent": 3,
      "text": "In the presence of skew, Response packets can arrive for matching before the corresponding Query. To avoid generating false instances of Responses without a matching Query, and Queries without a matching Response, the matching algorithm must take the possibility of skew into account.",
      "ja": "スキューがある場合、応答パケットは、対応するクエリの前に一致するように到着できます。 一致するクエリのない応答、および一致する応答のないクエリの誤ったインスタンスを生成しないようにするには、一致するアルゴリズムでスキューの可能性を考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.1. Matching Algorithm",
      "section_title": true,
      "ja": "10.1. マッチングアルゴリズム"
    },
    {
      "indent": 3,
      "text": "A schematic representation of the algorithm for matching Q/R data items is shown in Figure 3. It takes individual DNS Query or Response messages as input, and it outputs matched Q/R data items. The numbers in the figure identify matching operations listed in Table 1. Specific details of the algorithm -- for example, queues, timers, and identifiers -- are given in the following sections.",
      "ja": "Q / Rデータ項目を照合するためのアルゴリズムの概略図を図3に示します。個々のDNSクエリまたは応答メッセージを入力として受け取り、一致したQ / Rデータ項目を出力します。 図の番号は、表1にリストされている一致する操作を識別します。たとえば、キュー、タイマー、識別子など、アルゴリズムの特定の詳細については、次のセクションで説明します。"
    },
    {
      "indent": 4,
      "text": "                   .----------------------.\n                   | Process next message |<------------------+\n                   `----------------------'                   |\n                               |                              |\n               +------------------------------+               |\n               | Generate message identifiers |               |\n               +------------------------------+               |\n                               |                              |\n                      Response | Query                        |\n               +--------------< >---------------+             |\n               |                                |             |\n     +--------------------+           +--------------------+  |\n     | Find earliest QR   |           | Create QR item (2) |  |\n     | item in OFIFO (1)  |           +--------------------+  |\n     +--------------------+                     |             |\n                |                        +---------------+    |\n          Match | No match               | Append new QR |    |\n      +--------< >------+                | item to OFIFO |    |\n      |                 |                +---------------+    |\n+-----------+      +--------+                   |             |\n| Update QR |      | Add to |          +-------------------+  |\n| item (3)  |      | RFIFO  |          | Find earliest QR  |  |\n+-----------+      +--------+          | item in RFIFO (1) |  |\n      |                 |              +-------------------+  |\n      +-----------------+                       |             |\n                |                               |             |\n                |     +----------------+  Match | No match    |\n                |     | Remove R       |-------< >-----+      |\n                |     | from RFIFO (3) |               |      |\n                |     +----------------+               |      |\n                |              |                       |      |\n                +--------------+-----------------------+      |\n                               |                              |\n        +----------------------------------------------+      |\n        | Update all timed-out (QT) OFIFO QR items (4) |      |\n        +----------------------------------------------+      |\n                               |                              |\n               +--------------------------------+             |\n               | Remove all timed-out (ST) R    |             |\n               | from RFIFO, create QR item (5) |             |\n               +--------------------------------+             |\n           ____________________|_______________________       |\n          /                                            /      |\n         /  Remove all consecutive done entries from  /-------+\n        /   front of OFIFO for further processing    /\n       /____________________________________________/ OFIFO = output FIFO containing Q/R data items (Section 10.6)\n       RFIFO = Response FIFO containing unmatched Response items\n               (Section 10.6)\n       QT = Query Timeout (Section 10.3)\n       ST = Skew Timeout (Section 10.3)",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 3: Query/Response Matching Algorithm",
      "ja": "図3：クエリ/レスポンス一致アルゴリズム"
    },
    {
      "indent": 9,
      "text": "+-----------+-------------------------------------------+\n| Reference | Operation                                 |\n+-----------+-------------------------------------------+\n| (1)       | Find earliest QR item in FIFO where:      |\n|           | * QR.done = false                         |\n|           | * QR.Q.PrimaryID == R.PrimaryID           |\n|           | and, if both QR.Q and R have SecondaryID: |\n|           | * QR.Q.SecondaryID == R.SecondaryID       |\n|           |                                           |\n| (2)       | Set:                                      |\n|           | QR.Q := Q                                 |\n|           | QR.R := nil                               |\n|           | QR.done := false                          |\n|           |                                           |\n| (3)       | Set:                                      |\n|           | QR.R := R                                 |\n|           | QR.done := true                           |\n|           |                                           |\n| (4)       | Set:                                      |\n|           | QR.done := true                           |\n|           |                                           |\n| (5)       | Set:                                      |\n|           | QR.Q := nil                               |\n|           | QR.R := R                                 |\n|           | QR.done := true                           |\n+-----------+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 1: Operations Used in the Matching Algorithm",
      "ja": "表1：マッチングアルゴリズムで使用される操作"
    },
    {
      "indent": 0,
      "text": "10.2. Message Identifiers",
      "section_title": true,
      "ja": "10.2. メッセージ識別子"
    },
    {
      "indent": 0,
      "text": "10.2.1. Primary ID (Required)",
      "section_title": true,
      "ja": "10.2.1. プライマリID（必須）"
    },
    {
      "indent": 3,
      "text": "A Primary ID is constructed for each message. It is composed of the following data:",
      "ja": "メッセージごとにプライマリIDが作成されます。 次のデータで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Source IP Address",
      "ja": "1. 送信元IPアドレス"
    },
    {
      "indent": 3,
      "text": "2. Destination IP Address 3. Source Port",
      "ja": "2. 宛先IPアドレス3.送信元ポート"
    },
    {
      "indent": 3,
      "text": "4. Destination Port",
      "ja": "4. 宛先ポート"
    },
    {
      "indent": 3,
      "text": "5. Transport",
      "ja": "5. 輸送"
    },
    {
      "indent": 3,
      "text": "6. DNS Message ID",
      "ja": "6. DNSメッセージID"
    },
    {
      "indent": 0,
      "text": "10.2.2. Secondary ID (Optional)",
      "section_title": true,
      "ja": "10.2.2. セカンダリID（オプション）"
    },
    {
      "indent": 3,
      "text": "If present, the first Question in the Question section is used as a Secondary ID for each message. Note that there may be well-formed DNS Queries that have a QDCOUNT of 0, and some Responses may have a QDCOUNT of 0 (for example, Responses with RCODE=FORMERR or NOTIMP). In this case, the Secondary ID is not used in matching.",
      "ja": "存在する場合、質問セクションの最初の質問は各メッセージのセカンダリIDとして使用されます。 QDCOUNTが0の整形式DNSクエリがあり、一部の応答のQDCOUNTが0である場合があることに注意してください（たとえば、RCODE = FORMERRまたはNOTIMPの応答）。 この場合、セカンダリIDは照合に使用されません。"
    },
    {
      "indent": 0,
      "text": "10.3. Algorithm Parameters",
      "section_title": true,
      "ja": "10.3. アルゴリズムパラメータ"
    },
    {
      "indent": 3,
      "text": "1. Query Timeout (QT). A Query arrives with timestamp t1. If no Response matching that Query has arrived before other input arrives timestamped later than (t1 + QT), a Q/R data item containing only a Query is recorded. The QT value is typically on the order of 5 seconds.",
      "ja": "1. クエリタイムアウト（QT）。 タイムスタンプt1でクエリが到着します。 他の入力が（t1 + QT）よりも後のタイムスタンプで到着する前に、そのクエリに一致する応答が到着しない場合、クエリのみを含むQ / Rデータ項目が記録されます。 QT値は通常、5秒程度です。"
    },
    {
      "indent": 3,
      "text": "2. Skew Timeout (ST). A Response arrives with timestamp t2. If a Response has not been matched by a Query before input arrives timestamped later than (t2 + ST), a Q/R data item containing only a Response is recorded. The ST value is typically a few microseconds.",
      "ja": "2. スキュータイムアウト（ST）。 タイムスタンプt2で応答が到着します。 入力が（t2 + ST）より遅いタイムスタンプで到着する前に応答がクエリと一致しなかった場合、応答のみを含むQ / Rデータ項目が記録されます。 ST値は通常、数マイクロ秒です。"
    },
    {
      "indent": 0,
      "text": "10.4. Algorithm Requirements",
      "section_title": true,
      "ja": "10.4. アルゴリズム要件"
    },
    {
      "indent": 3,
      "text": "The algorithm is designed to handle the following input data:",
      "ja": "このアルゴリズムは、次の入力データを処理するように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. Multiple Queries with the same Primary ID (but different Secondary ID) arriving before any Responses for these Queries are seen.",
      "ja": "1. 同じプライマリID（ただし、異なるセカンダリID）を持つ複数のクエリは、これらのクエリの応答が表示される前に到着します。"
    },
    {
      "indent": 3,
      "text": "2. Multiple Queries with the same Primary and Secondary ID arriving before any Responses for these Queries are seen.",
      "ja": "2. 同じプライマリIDとセカンダリIDを持つ複数のクエリは、これらのクエリの応答が表示される前に到着します。"
    },
    {
      "indent": 3,
      "text": "3. Queries for which no later Response can be found within the specified timeout.",
      "ja": "3. 指定されたタイムアウト内に後の応答が見つからないクエリ。"
    },
    {
      "indent": 3,
      "text": "4. Responses for which no previous Query can be found within the specified timeout.",
      "ja": "4. 指定されたタイムアウト内に以前のクエリが見つからない応答。"
    },
    {
      "indent": 0,
      "text": "10.5. Algorithm Limitations",
      "section_title": true,
      "ja": "10.5. アルゴリズムの制限"
    },
    {
      "indent": 3,
      "text": "For cases 1 and 2 listed in the above requirements, it is not possible to unambiguously match Queries with Responses. This algorithm chooses to match to the earliest Query with the correct Primary and Secondary ID.",
      "ja": "上記の要件にリストされているケース1および2の場合、クエリと応答を明確に一致させることはできません。 このアルゴリズムは、正しいプライマリIDとセカンダリIDを持つ最も古いクエリに一致することを選択します。"
    },
    {
      "indent": 0,
      "text": "10.6. Workspace",
      "section_title": true,
      "ja": "10.6. ワークスペース"
    },
    {
      "indent": 3,
      "text": "The algorithm employs two FIFO queues:",
      "ja": "アルゴリズムは2つのFIFOキューを使用します。"
    },
    {
      "indent": 3,
      "text": "o OFIFO: an output FIFO containing Q/R data items in chronological order.",
      "ja": "o OFIFO：発生順にQ / Rデータ項目を含む出力FIFO。"
    },
    {
      "indent": 3,
      "text": "o RFIFO: a FIFO holding Responses without a matching Query in order of arrival.",
      "ja": "o RFIFO：一致するクエリのない応答を到着順に保持するFIFO。"
    },
    {
      "indent": 0,
      "text": "10.7. Output",
      "section_title": true,
      "ja": "10.7. 出力"
    },
    {
      "indent": 3,
      "text": "The output is a list of Q/R data items. Both the Query and Response elements are optional in these items; therefore, Q/R data items have one of three types of content:",
      "ja": "出力は、Q / Rデータ項目のリストです。 これらの項目では、クエリ要素と応答要素の両方がオプションです。 したがって、Q / Rデータ項目には、3つのタイプのコンテンツのいずれかがあります。"
    },
    {
      "indent": 3,
      "text": "1. A matched pair of Query and Response messages",
      "ja": "1. 一致したクエリメッセージと応答メッセージのペア"
    },
    {
      "indent": 3,
      "text": "2. A Query message with no Response",
      "ja": "2. 応答のないクエリメッセージ"
    },
    {
      "indent": 3,
      "text": "3. A Response message with no Query",
      "ja": "3. クエリのない応答メッセージ"
    },
    {
      "indent": 3,
      "text": "The timestamp of a list item is that of the Query for cases 1 and 2 and that of the Response for case 3.",
      "ja": "リスト項目のタイムスタンプは、ケース1と2のクエリのタイムスタンプと、ケース3の応答のタイムスタンプです。"
    },
    {
      "indent": 0,
      "text": "10.8. Post-Processing",
      "section_title": true,
      "ja": "10.8. 後処理"
    },
    {
      "indent": 3,
      "text": "When ending a capture, all items in the RFIFO are timed out immediately, generating Response only entries to the OFIFO. These and all other remaining entries in the OFIFO should be treated as timed-out Queries.",
      "ja": "キャプチャを終了すると、RFIFO内のすべてのアイテムがすぐにタイムアウトし、OFIFOへの応答のみのエントリが生成されます。 OFIFOのこれらのエントリおよびその他のすべてのエントリは、タイムアウトしたクエリとして処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. Implementation Guidance",
      "section_title": true,
      "ja": "11. 実施ガイダンス"
    },
    {
      "indent": 3,
      "text": "Whilst this document makes no specific recommendations with respect to \"Canonical CBOR\" (see Section 3.9 of [RFC7049]), the following guidance may be of use to implementers.",
      "ja": "このドキュメントは、「標準CBOR」（[RFC7049]のセクション3.9を参照）に関して特定の推奨事項を作成していませんが、実装者には次のガイダンスが役立つ可能性があります。"
    },
    {
      "indent": 3,
      "text": "Adherence to the first two rules given in Section 3.9 of [RFC7049] will minimize file sizes.",
      "ja": "[RFC7049]のセクション3.9に記載されている最初の2つの規則を順守すると、ファイルサイズが最小になります。"
    },
    {
      "indent": 3,
      "text": "Adherence to the last two rules given in Section 3.9 of [RFC7049] for all maps and arrays would unacceptably constrain implementations -- for example, in the use case of real-time data collection in constrained environments where outputting Block Tables after Q/R data items and allowing indefinite-length maps and arrays could reduce memory requirements.",
      "ja": "[RFC7049]のセクション3.9に記載されているすべてのマップと配列に関する最後の2つの規則を順守すると、たとえば、Q / Rデータの後にブロックテーブルを出力する制約された環境でのリアルタイムデータ収集のユースケースで、実装が容認できないほど制約されます アイテムと無制限の長さのマップと配列を許可すると、メモリ要件を削減できます。"
    },
    {
      "indent": 3,
      "text": "It is recommended that implementations that have fundamental restrictions on what data fields they can collect SHOULD always store hints with the bits unset for those fields, i.e., they unambiguously indicate that those data fields will be omitted from captured C-DNS.",
      "ja": "収集できるデータフィールドに基本的な制限がある実装は、それらのフィールドのビットが設定されていないヒントを常に保存する必要があります（つまり、それらのデータフィールドがキャプチャされたC-DNSから省略されることを明確に示す）。"
    },
    {
      "indent": 0,
      "text": "11.1. Optional Data",
      "section_title": true,
      "ja": "11.1. オプションデータ"
    },
    {
      "indent": 3,
      "text": "When decoding C-DNS data, some of the items required for a particular function that the consumer wishes to perform may be missing. Consumers should consider providing configurable default values to be used in place of the missing values in their output.",
      "ja": "C-DNSデータをデコードするときに、消費者が実行したい特定の機能に必要なアイテムの一部が欠落している場合があります。 消費者は、出力の欠損値の代わりに使用される構成可能なデフォルト値の提供を検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.2. Trailing Bytes",
      "section_title": true,
      "ja": "11.2. 後続バイト"
    },
    {
      "indent": 3,
      "text": "A DNS Query message in a UDP or TCP payload can be followed by some additional (spurious) bytes, which are not stored in C-DNS.",
      "ja": "UDPまたはTCPペイロードのDNSクエリメッセージの後に、C-DNSに保存されない追加の（スプリアス）バイトが続く場合があります。"
    },
    {
      "indent": 3,
      "text": "When DNS traffic is sent over TCP, each message is prefixed with a two-byte length field, which gives the message length, excluding the two-byte length field. In this context, trailing bytes can occur in two circumstances, with different results:",
      "ja": "DNSトラフィックがTCPを介して送信される場合、各メッセージの前に2バイトの長さフィールドが付加され、2バイトの長さフィールドを除くメッセージの長さが与えられます。 このコンテキストでは、2つの状況で後続バイトが発生し、結果が異なります。"
    },
    {
      "indent": 3,
      "text": "1. The number of bytes consumed by fully parsing the message is less than the number of bytes given in the length field (i.e., the length field is incorrect and too large). In this case, the surplus bytes are considered trailing bytes in a manner analogous to UDP and recorded as such. If only this case occurs, it is possible to process a packet containing multiple DNS messages where one or more have trailing bytes.",
      "ja": "1. メッセージを完全に解析することで消費されるバイト数は、長さフィールドで指定されたバイト数よりも少なくなります（つまり、長さフィールドが正しくなく、大きすぎます）。 この場合、余剰バイトはUDPに類似した方法で後続バイトと見なされ、そのように記録されます。 この場合にのみ、1つ以上に後続バイトがある複数のDNSメッセージを含むパケットを処理できます。"
    },
    {
      "indent": 3,
      "text": "2. There are surplus bytes between the end of a well-formed message and the start of the length field for the next message. In this case, the first of the surplus bytes will be processed as the first byte of the next length field, and parsing will proceed from there, almost certainly leading to the next and any subsequent messages in the packet being considered malformed. This will not generate a trailing-bytes record for the processed well-formed message.",
      "ja": "2. 整形式メッセージの終わりと次のメッセージの長さフィールドの始まりとの間に余分なバイトがあります。 この場合、余剰バイトの最初が次の長さフィールドの最初のバイトとして処理され、そこから解析が行われ、ほぼ間違いなく、パケット内の次のメッセージと後続のメッセージが不正と見なされます。 これは、処理された整形式メッセージの末尾バイトレコードを生成しません。"
    },
    {
      "indent": 0,
      "text": "11.3. Limiting Collection of RDATA",
      "section_title": true,
      "ja": "11.3. RDATAのコレクションの制限"
    },
    {
      "indent": 3,
      "text": "Implementations should consider providing a configurable maximum RDATA size for captures -- for example, to avoid memory issues when confronted with large zone transfer records.",
      "ja": "実装では、キャプチャ用に構成可能な最大RDATAサイズを提供することを検討する必要があります。たとえば、大きなゾーン転送レコードに直面したときのメモリの問題を回避するためです。"
    },
    {
      "indent": 0,
      "text": "11.4. Timestamps",
      "section_title": true,
      "ja": "11.4. タイムスタンプ"
    },
    {
      "indent": 3,
      "text": "The preamble to each block includes a timestamp of the earliest record in the Block. As described in Section 7.3.2.1, the timestamp is an array of two unsigned integers. The first is a POSIX \"time_t\" [posix-time]. Consumers of C-DNS should be aware of this, as it excludes leap seconds and therefore may cause minor anomalies in the data, e.g., when calculating Query throughput.",
      "ja": "各ブロックのプリアンブルには、ブロック内の最初のレコードのタイムスタンプが含まれます。 セクション7.3.2.1で説明したように、タイムスタンプは2つの符号なし整数の配列です。 最初はPOSIX \"time_t\" [posix-time]です。 C-DNSの消費者はこれに注意する必要があります。これはうるう秒を除外するため、たとえばクエリスループットを計算するときにデータに小さな異常を引き起こす可能性があるためです。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry \"C-DNS DNS Capture Format\" containing the subregistries defined in Sections 12.1 to 12.4 inclusive.",
      "ja": "IANAは、セクション12.1〜12.4で定義されたサブレジストリを含むレジストリ「C-DNS DNSキャプチャフォーマット」を作成しました。"
    },
    {
      "indent": 3,
      "text": "In all cases, new entries may be added to the subregistries by Expert Review as defined in [RFC8126]. Experts are expected to exercise their own expert judgment and should consider the following general guidelines in addition to any provided guidelines that are particular to a subregistry.",
      "ja": "すべての場合において、[RFC8126]で定義されているように、Expert Reviewによってサブレジストリに新しいエントリを追加できます。 専門家は、独自の専門家の判断を行使することが期待されており、サブレジストリに固有の提供されたガイドラインに加えて、以下の一般的なガイドラインを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o There should be a real and compelling use for any new value.",
      "ja": "o どんな新しい価値に対しても、真に魅力的な用途があるはずです。"
    },
    {
      "indent": 3,
      "text": "o Values assigned should be carefully chosen to minimize storage requirements for common cases.",
      "ja": "o 割り当てられる値は、一般的な場合のストレージ要件を最小限に抑えるために慎重に選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.1. Transport Types",
      "section_title": true,
      "ja": "12.1. 輸送タイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry \"C-DNS Transports\" of C-DNS transport type identifiers. The primary purpose of this registry is to provide unique identifiers for all transports used for DNS Queries.",
      "ja": "IANAは、C-DNSトランスポートタイプ識別子のレジストリ「C-DNSトランスポート」を作成しました。 このレジストリの主な目的は、DNSクエリに使用されるすべてのトランスポートに一意の識別子を提供することです。"
    },
    {
      "indent": 3,
      "text": "The following note is included in this registry: \"In version 1.0 of C-DNS [RFC8618], there is a field to identify the type of DNS transport. This field is 4 bits in size.\" The initial contents of the registry are as follows. See Sections 7.3.2.3.2, 7.3.2.3.5, and 7.3.2.5 of this document:",
      "ja": "このレジストリには、次の注意が含まれています。「C-DNS [RFC8618]のバージョン1.0には、DNSトランスポートのタイプを識別するフィールドがあります。このフィールドのサイズは4ビットです。」 レジストリの初期内容は次のとおりです。 このドキュメントのセクション7.3.2.3.2、7.3.2.3.5、および7.3.2.5を参照してください。"
    },
    {
      "indent": 12,
      "text": "+------------+------------------------+-----------+\n| Identifier | Name                   | Reference |\n+------------+------------------------+-----------+\n|     0      | UDP                    | RFC 8618  |\n|     1      | TCP                    | RFC 8618  |\n|     2      | TLS                    | RFC 8618  |\n|     3      | DTLS                   | RFC 8618  |\n|     4      | HTTPS                  | RFC 8618  |\n|    5-14    | Unassigned             |           |\n|     15     | Non-standard transport | RFC 8618  |\n+------------+------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take the following point into consideration: Is the requested DNS transport described by a Standards Track RFC?",
      "ja": "専門のレビュー担当者は、次の点を考慮に入れる必要があります。要求されたDNSトランスポートは、Standards Track RFCによって記述されていますか？"
    },
    {
      "indent": 0,
      "text": "12.2. Data Storage Flags",
      "section_title": true,
      "ja": "12.2. データ保存フラグ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry \"C-DNS Storage Flags\" of C-DNS data storage flags. The primary purpose of this registry is to provide indicators giving hints on processing of the data stored.",
      "ja": "IANAは、C-DNSデータストレージフラグのレジストリ「C-DNSストレージフラグ」を作成しました。 このレジストリの主な目的は、保存されたデータの処理に関するヒントを提供するインジケータを提供することです。"
    },
    {
      "indent": 3,
      "text": "The following note is included in this registry: \"In version 1.0 of C-DNS [RFC8618], there is a field describing attributes of the data recorded. The field is a CBOR [RFC7049] unsigned integer holding bit flags.\"",
      "ja": "このレジストリには、「C-DNS [RFC8618]のバージョン1.0に、記録されたデータの属性を説明するフィールドがあります。このフィールドは、ビットフラグを保持するCBOR [RFC7049]符号なし整数です。」"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry are as follows. See Section 7.3.1.1.1 of this document:",
      "ja": "レジストリの初期内容は次のとおりです。 このドキュメントのセクション7.3.1.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "+------+------------------+-----------------------------+-----------+\n| Bit  | Name             | Description                 | Reference |\n+------+------------------+-----------------------------+-----------+\n|  0   | anonymized-data  | The data has been           | RFC 8618  |\n|      |                  | anonymized.                 |           |\n|      |                  |                             |           |\n|  1   | sampled-data     | The data is sampled data.   | RFC 8618  |\n|      |                  |                             |           |\n|  2   | normalized-names | Names in the data have been | RFC 8618  |\n|      |                  | normalized.                 |           |\n|      |                  |                             |           |\n| 3-63 | Unassigned       |                             |           |\n+------+------------------+-----------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "12.3. Response-Processing Flags",
      "section_title": true,
      "ja": "12.3. 応答処理フラグ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry \"C-DNS Response Flags\" of C-DNS response-processing flags. The primary purpose of this registry is to provide indicators giving hints on the generation of a particular Response.",
      "ja": "IANAは、C-DNS応答処理フラグのレジストリ「C-DNS応答フラグ」を作成しました。 このレジストリの主な目的は、特定の応答の生成に関するヒントを提供するインジケータを提供することです。"
    },
    {
      "indent": 3,
      "text": "The following note is included in this registry: \"In version 1.0 of C-DNS [RFC8618], there is a field describing attributes of the Responses recorded. The field is a CBOR [RFC7049] unsigned integer holding bit flags.\"",
      "ja": "このレジストリには次の注意事項が含まれています。「C-DNS [RFC8618]のバージョン1.0には、記録された応答の属性を記述するフィールドがあります。このフィールドはビットフラグを保持するCBOR [RFC7049]符号なし整数です。」"
    },
    {
      "indent": 3,
      "text": "The initial contents of the registry are as follows. See Section 7.3.2.4.1 of this document:",
      "ja": "レジストリの初期内容は次のとおりです。 このドキュメントのセクション7.3.2.4.1を参照してください。"
    },
    {
      "indent": 5,
      "text": "+------+------------+-------------------------------+-----------+\n| Bit  | Name       | Description                   | Reference |\n+------+------------+-------------------------------+-----------+\n|  0   | from-cache | The Response came from cache. | RFC 8618  |\n| 1-63 | Unassigned |                               |           |\n+------+------------+-------------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "12.4. AddressEvent Types",
      "section_title": true,
      "ja": "12.4. AddressEventタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry \"C-DNS Address Event Types\" of C-DNS AddressEvent types. The primary purpose of this registry is to provide unique identifiers of different types of C-DNS address events and so specify the contents of the optional companion field \"ae-code\" for each type.",
      "ja": "IANAは、C-DNS AddressEventタイプのレジストリ「C-DNSアドレスイベントタイプ」を作成しました。 このレジストリの主な目的は、さまざまなタイプのC-DNSアドレスイベントの一意の識別子を提供し、各タイプのオプションのコンパニオンフィールド「ae-code」の内容を指定することです。"
    },
    {
      "indent": 3,
      "text": "The following note is included in this registry: \"In version 1.0 of C-DNS [RFC8618], there is a field identifying types of the events related to client addresses. This field is a CBOR [RFC7049] unsigned integer. There is a related optional field \"ae-code\", which, if present, holds an additional CBOR unsigned integer giving additional information specific to the event type.\" The initial contents of the registry are as follows. See Section 7.3.2.5 of this document:",
      "ja": "このレジストリには、次の注意が含まれています。「C-DNS [RFC8618]のバージョン1.0には、クライアントアドレスに関連するイベントのタイプを識別するフィールドがあります。このフィールドは、CBOR [RFC7049]符号なし整数です。 オプションフィールド「ae-code」。存在する場合は、イベントタイプに固有の追加情報を提供する追加のCBOR符号なし整数を保持します。 レジストリの初期内容は次のとおりです。 このドキュメントのセクション7.3.2.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "+------------------------+---------------+--------------+-----------+\n|       Identifier       | Event Type    | ae-code      | Reference |\n|                        |               | Contents     |           |\n+------------------------+---------------+--------------+-----------+\n|           0            | TCP reset     | None         | RFC 8618  |\n|                        |               |              |           |\n|           1            | ICMP time     | ICMP code    | RFC 8618  |\n|                        | exceeded      | [icmpcodes]  |           |\n|                        |               |              |           |\n|           2            | ICMP          | ICMP code    | RFC 8618  |\n|                        | destination   | [icmpcodes]  |           |\n|                        | unreachable   |              |           |\n|                        |               |              |           |\n|           3            | ICMPv6 time   | ICMPv6 code  | RFC 8618  |\n|                        | exceeded      | [icmp6codes] |           |\n|                        |               |              |           |\n|           4            | ICMPv6        | ICMPv6 code  | RFC 8618  |\n|                        | destination   | [icmp6codes] |           |\n|                        | unreachable   |              |           |\n|                        |               |              |           |\n|           5            | ICMPv6 packet | ICMPv6 code  | RFC 8618  |\n|                        | too big       | [icmp6codes] |           |\n|                        |               |              |           |\n| 6-18446744073709551615 | Unassigned    |              |           |\n+------------------------+---------------+--------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take the following point into consideration: \"ae-code\" contents must be defined for a type or, if not appropriate, specified as \"None\". A specification of \"None\" requires less storage and is therefore preferred.",
      "ja": "専門のレビュー担当者は、次の点を考慮に入れる必要があります。「ae-code」コンテンツは、タイプに対して定義するか、適切でない場合は「なし」として指定する必要があります。 「なし」を指定すると、必要なストレージが少なくなるため、推奨されます。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Any control interface MUST perform authentication and encryption.",
      "ja": "制御インターフェイスは、認証と暗号化を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Any data upload MUST be authenticated and encrypted.",
      "ja": "データのアップロードはすべて認証および暗号化する必要があります。"
    },
    {
      "indent": 0,
      "text": "14. Privacy Considerations",
      "section_title": true,
      "ja": "14. プライバシーに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Storage of DNS traffic by operators in PCAP and other formats is a long-standing and widespread practice. Section 2.5 of [DNS-Priv-Cons] provides an analysis of the risks to Internet users regarding the storage of DNS traffic data in servers (recursive resolvers, authoritative servers, and rogue servers).",
      "ja": "オペレータによるDNSトラフィックのPCAPおよびその他の形式での保存は、長年にわたって広く行われている慣行です。 [DNS-Priv-Cons]のセクション2.5は、サーバー（再帰リゾルバー、権限のあるサーバー、および不正サーバー）でのDNSトラフィックデータの保存に関するインターネットユーザーへのリスクの分析を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 5.2 of [DNS-Priv-Svc] describes mitigations for those risks for data stored on recursive resolvers (but that could by extension apply to authoritative servers). These include data-handling practices and methods for data minimization, IP address pseudonymization, and anonymization. Appendix C of [DNS-Priv-Svc] presents an analysis of seven published anonymization processes. In addition, the ICANN Root Server System Advisory Committee (RSSAC) have recently published [RSSAC04] (\"Recommendations on Anonymization Processes for Source IP Addresses Submitted for Future Analysis\").",
      "ja": "[DNS-Priv-Svc]のセクション5.2では、再帰リゾルバに保存されているデータのリスクの軽減策について説明しています（ただし、拡張機能によって権限のあるサーバーに適用される可能性があります）。 これらには、データ処理の実践と、データの最小化、IPアドレスの仮名化、匿名化の方法が含まれます。 [DNS-Priv-Svc]の付録Cは、公開されている7つの匿名化プロセスの分析を示しています。 さらに、ICANNルートサーバーシステム諮問委員会（RSSAC）が最近公開しました[RSSAC04]（「将来の分析のために送信されたソースIPアドレスの匿名化プロセスに関する推奨事項」）。"
    },
    {
      "indent": 3,
      "text": "The above analyses consider full data capture (e.g., using PCAP) as a baseline for privacy considerations; therefore, this format specification introduces no new user privacy issues beyond those of full data capture (which are quite severe). It does provide mechanisms to selectively record only certain fields at the time of data capture, to improve user privacy and to explicitly indicate that data is sampled, anonymized, or both. It also provides flags to indicate if data normalization has been performed; data normalization increases user privacy by reducing the potential for fingerprinting individuals. However, a trade-off is the potential reduction of the capacity to identify attack traffic via Query name signatures. Operators should carefully consider their operational requirements and privacy policies and SHOULD capture at the source the minimum user data required to meet their needs.",
      "ja": "上記の分析では、完全なデータキャプチャ（たとえば、PCAPを使用）をプライバシーに関する考慮事項のベースラインとして検討しています。 したがって、この形式の仕様では、完全なデータキャプチャ（非常に厳しい）の問題を超える新しいユーザープライバシーの問題は発生しません。 データキャプチャ時に特定のフィールドのみを選択的に記録し、ユーザーのプライバシーを改善し、データのサンプリング、匿名化、またはその両方を明示的に示すメカニズムを提供します。 また、データの正規化が実行されたかどうかを示すフラグも提供します。 データの正規化は、個人の指紋をとる可能性を減らすことにより、ユーザーのプライバシーを高めます。 ただし、トレードオフは、クエリ名の署名を介して攻撃トラフィックを識別する能力の潜在的な削減です。 オペレータは、運用要件とプライバシーポリシーを慎重に検討し、ニーズを満たすために必要な最小限のユーザーデータをソースで取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15. 参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[pcap-filter] tcpdump.org, \"Manpage of PCAP-FILTER\", November 2017, <https://www.tcpdump.org/manpages/pcap-filter.7.html>.",
      "ja": "[pcap-filter] tcpdump.org、「PCAP-FILTERのマンページ」、2017年11月、<https://www.tcpdump.org/manpages/pcap-filter.7.html>。"
    },
    {
      "indent": 3,
      "text": "[pcap-options] tcpdump.org, \"Manpage of PCAP\", July 2018, <https://www.tcpdump.org/manpages/pcap.3pcap.html>.",
      "ja": "[pcap-options] tcpdump.org、「PCAPのマンページ」、2018年7月、<https://www.tcpdump.org/manpages/pcap.3pcap.html>。"
    },
    {
      "indent": 3,
      "text": "[posix-time] The Open Group, \"IEEE Standard for Information Technology--Portable Operating System Interface (POSIX(R)) Base Specifications, Issue 7\", IEEE Standard 1003.1-2017, Section 4.16, DOI 10.1109/IEEESTD.2018.8277153.",
      "ja": "[posix-time] Open Group、「情報技術のIEEE標準-ポータブルオペレーティングシステムインターフェイス（POSIX（R））基本仕様、問題7」、IEEE標準1003.1-2017、セクション4.16、DOI 10.1109 / IEEESTD.2018.8277153。"
    },
    {
      "indent": 3,
      "text": "[RFC792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <https://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC792]ポステル、J。、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<https://www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <https://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名-実装と仕様」、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、<https://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <https://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ・リー、T。、フィールディング、R。、およびL.マスインター、「Uniform Resource Identifier（URI）：Generic Syntax」、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月、<https：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006, <https://www.rfc-editor.org/info/rfc4443>.",
      "ja": "[RFC4443] Conta、A.、Deering、S。、およびM. Gupta、Ed。、「インターネットプロトコルバージョン6（IPv6）仕様のインターネット制御メッセージプロトコル（ICMPv6）」、STD 89、RFC 4443、DOI 10.17487 / RFC4443、2006年3月、<https://www.rfc-editor.org/info/rfc4443>。"
    },
    {
      "indent": 3,
      "text": "[RFC6891] Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms for DNS (EDNS(0))\", STD 75, RFC 6891, DOI 10.17487/RFC6891, April 2013, <https://www.rfc-editor.org/info/rfc6891>.",
      "ja": "[RFC6891] Damas、J.、Graff、M。、およびP. Vixie、「DNSの拡張メカニズム（EDNS（0））」、STD 75、RFC 6891、DOI 10.17487 / RFC6891、2013年4月、<https：// www.rfc-editor.org/info/rfc6891>。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", RFC 7049, DOI 10.17487/RFC7049, October 2013, <https://www.rfc-editor.org/info/rfc7049>.",
      "ja": "[RFC7049] Bormann、C.、P。Hoffman、「簡潔なバイナリオブジェクト表現（CBOR）」、RFC 7049、DOI 10.17487 / RFC7049、2013年10月、<https://www.rfc-editor.org/info/rfc7049> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7858] Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D., and P. Hoffman, \"Specification for DNS over Transport Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May 2016, <https://www.rfc-editor.org/info/rfc7858>.",
      "ja": "[RFC7858] Hu、Z.、Zhu、L.、Heidemann、J.、Mankin、A.、Wessels、D。、およびP. Hoffman、「Transport Layer Security（TLS）上のDNSの仕様」、RFC 7858、DOI 10.17487 / RFC7858、2016年5月、<https://www.rfc-editor.org/info/rfc7858>。"
    },
    {
      "indent": 3,
      "text": "[RFC8094] Reddy, T., Wing, D., and P. Patil, \"DNS over Datagram Transport Layer Security (DTLS)\", RFC 8094, DOI 10.17487/RFC8094, February 2017, <https://www.rfc-editor.org/info/rfc8094>.",
      "ja": "[RFC8094] Reddy、T.、Wing、D.、P。Patil、「DNS over Datagram Transport Layer Security（DTLS）」、RFC 8094、DOI 10.17487 / RFC8094、2017年2月、<https：//www.rfc- editor.org/info/rfc8094>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8484] Hoffman, P. and P. McManus, \"DNS Queries over HTTPS (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018, <https://www.rfc-editor.org/info/rfc8484>.",
      "ja": "[RFC8484] Hoffman、P。およびP. McManus、「DNSクエリover HTTPS（DoH）」、RFC 8484、DOI 10.17487 / RFC8484、2018年10月、<https://www.rfc-editor.org/info/rfc8484> 。"
    },
    {
      "indent": 3,
      "text": "[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures\", RFC 8610, DOI 10.17487/RFC8610, June 2019, <https://www.rfc-editor.org/info/rfc8610>.",
      "ja": "[RFC8610] Birkholz、H.、Vigano、C。、およびC. Bormann、「簡潔なデータ定義言語（CDDL）：簡潔なバイナリオブジェクト表現（CBOR）およびJSONデータ構造を表現する表記規則」、RFC 8610、DOI 10.17487 / RFC8610、2019年6月、<https://www.rfc-editor.org/info/rfc8610>。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Avro] The Apache Software Foundation, \"Apache Avro(TM)\", 2019, <https://avro.apache.org/>.",
      "ja": "[Avro] Apache Software Foundation、「Apache Avro（TM）」、2019、<https://avro.apache.org/>。"
    },
    {
      "indent": 3,
      "text": "[ditl] DNS-OARC, \"DITL\", 2018, <https://www.dns-oarc.net/oarc/data/ditl>.",
      "ja": "[ditl] DNS-OARC、「DITL」、2018、<https://www.dns-oarc.net/oarc/data/ditl>。"
    },
    {
      "indent": 3,
      "text": "[DNS-Priv-Cons] Bortzmeyer, S. and S. Dickinson, \"DNS Privacy Considerations\", Work in Progress, draft-ietf-dprive-rfc7626-bis-00, July 2019.",
      "ja": "[DNS-Priv-Cons] Bortzmeyer、S。およびS. Dickinson、「DNSプライバシーに関する考慮事項」、Work in Progress、draft-ietf-dprive-rfc7626-bis-00、2019年7月。"
    },
    {
      "indent": 3,
      "text": "[DNS-Priv-Svc] Dickinson, S., Overeinder, B., van Rijswijk-Deij, R., and A. Mankin, \"Recommendations for DNS Privacy Service Operators\", Work in Progress, draft-ietf-dprive-bcp-op-03, July 2019.",
      "ja": "[DNS-Priv-Svc] Dickinson、S.、Overeinder、B.、van Rijswijk-Deij、R。、およびA. Mankin、「DNSプライバシーサービスオペレーター向けの推奨事項」、Work in Progress、draft-ietf-dprive-bcp -op-03、2019年7月。"
    },
    {
      "indent": 3,
      "text": "[dnscap] DNS-OARC, \"DNSCAP\", 2018, <https://www.dns-oarc.net/tools/dnscap>.",
      "ja": "[dnscap] DNS-OARC、「DNSCAP」、2018、<https://www.dns-oarc.net/tools/dnscap>。"
    },
    {
      "indent": 3,
      "text": "[dnstap] \"dnstap\", 2016, <https://dnstap.info/>.",
      "ja": "[dnstap]「dnstap」、2016年、<https://dnstap.info/>。"
    },
    {
      "indent": 3,
      "text": "[dnstap-schema] \"dnstap schema\", commit d860ec1, November 2016, <https://github.com/dnstap/dnstap.pb/blob/master/ dnstap.proto>.",
      "ja": "[dnstap-schema]「dnstap schema」、コミットd860ec1、2016年11月、<https://github.com/dnstap/dnstap.pb/blob/master/ dnstap.proto>。"
    },
    {
      "indent": 3,
      "text": "[dnsxml] Daley, J., Ed., Morris, S., and J. Dickinson, \"dnsxml - A standard XML representation of DNS data\", Work in Progress, draft-daley-dnsxml-00, July 2013.",
      "ja": "[dnsxml] Daley、J.、Ed。、Morris、S。、およびJ. Dickinson、「dnsxml-DNSデータの標準XML表現」、Work in Progress、draft-daley-dnsxml-00、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[dsc] Wessels, D. and J. Lundstrom, \"DSC\", 2016, <https://www.dns-oarc.net/tools/dsc>.",
      "ja": "[dsc] Wessels、D。およびJ. Lundstrom、「DSC」、2016年、<https://www.dns-oarc.net/tools/dsc>。"
    },
    {
      "indent": 3,
      "text": "[gzip] \"gzip\", <https://www.gzip.org/>.",
      "ja": "[gzip]「gzip」、<https://www.gzip.org/>。"
    },
    {
      "indent": 3,
      "text": "[icmp6codes] IANA, \"ICMPv6 \"Code\" Fields\", <https://www.iana.org/assignments/icmpv6-parameters/>.",
      "ja": "[icmp6codes] IANA、「ICMPv6「コード」フィールド」、<https://www.iana.org/assignments/icmpv6-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[icmpcodes] IANA, \"Code Fields\", <https://www.iana.org/assignments/icmp-parameters/>.",
      "ja": "[icmpcodes] IANA、「コードフィールド」、<https://www.iana.org/assignments/icmp-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[IEEE802.1Q] IEEE, \"IEEE Standard for Local and Metropolitan Area Networks--Bridges and Bridged Networks\", IEEE Standard 802.1Q.",
      "ja": "[IEEE802.1Q] IEEE、「ローカルおよびメトロポリタンエリアネットワークのIEEE標準-ブリッジおよびブリッジネットワーク」、IEEE標準802.1Q。"
    },
    {
      "indent": 3,
      "text": "[Knot] \"Knot DNS\", <https://www.knot-dns.cz/>.",
      "ja": "[ノット]「ノットDNS」、<https://www.knot-dns.cz/>。"
    },
    {
      "indent": 3,
      "text": "[lz4] \"LZ4\", <https://lz4.github.io/lz4/>.",
      "ja": "[lz4]「LZ4」、<https://lz4.github.io/lz4/>。"
    },
    {
      "indent": 3,
      "text": "[mmark] Gieben, M., \"mmark\", commit de69698, May 2019, <https://github.com/mmarkdown/mmark>.",
      "ja": "[mmark] Gieben、M。、「mmark」、de69698のコミット、2019年5月、<https://github.com/mmarkdown/mmark>。"
    },
    {
      "indent": 3,
      "text": "[NSD] NLnet Labs, \"NSD\", 2019, <https://www.nlnetlabs.nl/projects/nsd/about/>.",
      "ja": "[NSD] NLnet Labs、「NSD」、2019、<https://www.nlnetlabs.nl/projects/nsd/about/>。"
    },
    {
      "indent": 3,
      "text": "[opcodes] IANA, \"DNS OpCodes\", <https://www.iana.org/assignments/dns-parameters/>.",
      "ja": "[opcodes] IANA、「DNS OpCodes」、<https://www.iana.org/assignments/dns-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[packetq] .SE - The Internet Infrastructure Foundation, \"PacketQ\", commit c9b2e89, February 2019, <https://github.com/DNS-OARC/PacketQ>.",
      "ja": "[packetq] .SE-インターネットインフラストラクチャ財団、「PacketQ」、コミットc9b2e89、2019年2月、<https://github.com/DNS-OARC/PacketQ>。"
    },
    {
      "indent": 3,
      "text": "[pcap] \"PCAP\", 2019, <https://www.tcpdump.org/>.",
      "ja": "[pcap]「PCAP」、2019、<https://www.tcpdump.org/>。"
    },
    {
      "indent": 3,
      "text": "[pcapng] \"pcapng: PCAP next generation file format specification\", commit 3c35b6a, March 2019, <https://github.com/pcapng/pcapng>.",
      "ja": "[pcapng]「pcapng：PCAP次世代ファイル形式仕様」、コミット3c35b6a、2019年3月、<https://github.com/pcapng/pcapng>。"
    },
    {
      "indent": 3,
      "text": "[Protocol-Buffers] Google LLC, \"Protocol Buffers\", <https://developers.google.com/protocol-buffers/>.",
      "ja": "[Protocol-Buffers] Google LLC、「Protocol Buffers」、<https://developers.google.com/protocol-buffers/>。"
    },
    {
      "indent": 3,
      "text": "[rcodes] IANA, \"DNS RCODEs\", <https://www.iana.org/assignments/dns-parameters/>.",
      "ja": "[rcodes] IANA、「DNS RCODEs」、<https://www.iana.org/assignments/dns-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <https://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、Zhou、H.、Eronen、P。、およびH. Tschofenig、「サーバー側の状態なしのトランスポート層セキュリティ（TLS）セッション再開」、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 <https://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC7413] Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP Fast Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014, <https://www.rfc-editor.org/info/rfc7413>.",
      "ja": "[RFC7413] Cheng、Y.、Chu、J.、Radhakrishnan、S。、およびA.Jain、「TCP Fast Open」、RFC 7413、DOI 10.17487 / RFC7413、2014年12月、<https：//www.rfc-editor .org / info / rfc7413>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、Ed。、「JavaScriptオブジェクト表記（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、<https://www.rfc-editor.org / info / rfc8259>。"
    },
    {
      "indent": 3,
      "text": "[RFC8427] Hoffman, P., \"Representing DNS Messages in JSON\", RFC 8427, DOI 10.17487/RFC8427, July 2018, <https://www.rfc-editor.org/info/rfc8427>.",
      "ja": "[RFC8427] Hoffman、P。、「JSONでのDNSメッセージの表現」、RFC 8427、DOI 10.17487 / RFC8427、2018年7月、<https://www.rfc-editor.org/info/rfc8427>。"
    },
    {
      "indent": 3,
      "text": "[rrclasses] IANA, \"DNS CLASSes\", <https://www.iana.org/assignments/dns-parameters/>.",
      "ja": "[rrclasses] IANA、「DNSクラス」、<https://www.iana.org/assignments/dns-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[rrtypes] IANA, \"Resource Record (RR) TYPEs\", <https://www.iana.org/assignments/dns-parameters/>.",
      "ja": "[rrtypes] IANA、「リソースレコード（RR）タイプ」、<https://www.iana.org/assignments/dns-parameters/>。"
    },
    {
      "indent": 3,
      "text": "[RSSAC04] ICANN, \"Recommendations on Anonymization Processes for Source IP Addresses Submitted for Future Analysis\", August 2018, <https://www.icann.org/en/system/files/files/ rssac-040-07aug18-en.pdf>.",
      "ja": "[RSSAC04] ICANN、「将来の分析のために送信されたソースIPアドレスの匿名化プロセスに関する推奨事項」、2018年8月、<https://www.icann.org/en/system/files/files/ rssac-040-07aug18-en pdf>。"
    },
    {
      "indent": 3,
      "text": "[snappy] \"snappy\", <https://google.github.io/snappy/>.",
      "ja": "[snappy]「snappy」、<https://google.github.io/snappy/>。"
    },
    {
      "indent": 3,
      "text": "[snzip] \"Snzip, a compression/decompression tool based on snappy\", commit 809c6f2, October 2018, <https://github.com/kubo/snzip>.",
      "ja": "[snzip]「Snzip、snappyに基づく圧縮/解凍ツール」、コミット809c6f2、2018年10月、<https://github.com/kubo/snzip>。"
    },
    {
      "indent": 3,
      "text": "[xz] \"XZ Utils\", <https://tukaani.org/xz/>.",
      "ja": "[xz]「XZ Utils」、<https://tukaani.org/xz/>。"
    },
    {
      "indent": 3,
      "text": "[zstd] \"Zstandard - Real-time data compression algorithm\", <https://facebook.github.io/zstd/>.",
      "ja": "[zstd]「Zstandard-リアルタイムデータ圧縮アルゴリズム」、<https://facebook.github.io/zstd/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. CDDL",
      "section_title": true,
      "ja": "付録A.CDDL"
    },
    {
      "indent": 3,
      "text": "This appendix gives a CDDL [RFC8610] specification for C-DNS.",
      "ja": "この付録では、C-DNSのCDDL [RFC8610]仕様を示します。"
    },
    {
      "indent": 3,
      "text": "CDDL does not permit a range of allowed values to be specified for a bitfield. Where necessary, those values are given as a CDDL group, but the group definition is commented out to prevent CDDL tooling from warning that the group is unused.",
      "ja": "CDDLは、ビットフィールドに許可された値の範囲を指定することを許可していません。 必要な場合、これらの値はCDDLグループとして指定されますが、グループが未使用であることをCDDLツールが警告しないように、グループ定義はコメント化されています。"
    },
    {
      "indent": 3,
      "text": "; CDDL specification of the file format for C-DNS, ; which describes a collection of DNS messages and ; traffic metadata.",
      "ja": "; C-DNSのファイル形式のCDDL仕様。 DNSメッセージのコレクションを記述し、; トラフィックメタデータ。"
    },
    {
      "indent": 3,
      "text": ";\n; The overall structure of a file.\n;\nFile = [\n    file-type-id  : \"C-DNS\",\n    file-preamble : FilePreamble,\n    file-blocks   : [* Block],\n]",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; The File Preamble.\n;\nFilePreamble = {\n    major-format-version => 1,\n    minor-format-version => 0,\n    ? private-version    => uint,\n    block-parameters     => [+ BlockParameters],\n}\nmajor-format-version = 0\nminor-format-version = 1\nprivate-version      = 2\nblock-parameters     = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "BlockParameters = {\n    storage-parameters      => StorageParameters,\n    ? collection-parameters => CollectionParameters,\n}\nstorage-parameters    = 0\ncollection-parameters = 1",
      "raw": true
    },
    {
      "indent": 5,
      "text": "IPv6PrefixLength = 1..128\nIPv4PrefixLength = 1..32\nOpcodeRange = 0..15\nRRTypeRange = 0..65535 StorageParameters = {\n    ticks-per-second             => uint,\n    max-block-items              => uint,\n    storage-hints                => StorageHints,\n    opcodes                      => [+ OpcodeRange],\n    rr-types                     => [+ RRTypeRange],\n    ? storage-flags              => StorageFlags,\n    ? client-address-prefix-ipv4 => IPv4PrefixLength,\n    ? client-address-prefix-ipv6 => IPv6PrefixLength,\n    ? server-address-prefix-ipv4 => IPv4PrefixLength,\n    ? server-address-prefix-ipv6 => IPv6PrefixLength,\n    ? sampling-method            => tstr,\n    ? anonymization-method       => tstr,\n}\nticks-per-second           = 0\nmax-block-items            = 1\nstorage-hints              = 2\nopcodes                    = 3\nrr-types                   = 4\nstorage-flags              = 5\nclient-address-prefix-ipv4 = 6\nclient-address-prefix-ipv6 = 7\nserver-address-prefix-ipv4 = 8\nserver-address-prefix-ipv6 = 9\nsampling-method            = 10\nanonymization-method       = 11",
      "raw": true
    },
    {
      "indent": 7,
      "text": "; A hint indicates whether the collection method will always omit\n; the item from the file.\nStorageHints = {\n    query-response-hints           => QueryResponseHints,\n    query-response-signature-hints =>\n        QueryResponseSignatureHints,\n    rr-hints                       => RRHints,\n    other-data-hints               => OtherDataHints,\n}\nquery-response-hints           = 0\nquery-response-signature-hints = 1\nrr-hints                       = 2\nother-data-hints               = 3",
      "raw": true
    },
    {
      "indent": 9,
      "text": "QueryResponseHintValues = &(\n    time-offset                  : 0,\n    client-address-index         : 1,\n    client-port                  : 2,\n    transaction-id               : 3,\n    qr-signature-index           : 4,\n    client-hoplimit              : 5, response-delay               : 6,\n    query-name-index             : 7,\n    query-size                   : 8,\n    response-size                : 9,\n    response-processing-data     : 10,\n    query-question-sections      : 11,    ; Second & subsequent\n                                          ; Questions\n    query-answer-sections        : 12,\n    query-authority-sections     : 13,\n    query-additional-sections    : 14,\n    response-answer-sections     : 15,\n    response-authority-sections  : 16,\n    response-additional-sections : 17,\n)\nQueryResponseHints = uint .bits QueryResponseHintValues",
      "raw": true
    },
    {
      "indent": 9,
      "text": "QueryResponseSignatureHintValues = &( server-address-index : 0, server-port : 1, qr-transport-flags : 2, qr-type : 3, qr-sig-flags : 4, query-opcode : 5, qr-dns-flags : 6, query-rcode : 7, query-classtype-index : 8, query-qdcount : 9, query-ancount : 10, query-nscount : 11, query-arcount : 12, query-edns-version : 13, query-udp-size : 14, query-opt-rdata-index : 15, response-rcode : 16, ) QueryResponseSignatureHints = uint .bits QueryResponseSignatureHintValues",
      "ja": "QueryResponseSignatureHintValues =＆（server-address-index：0、server-port：1、qr-transport-flags：2、qr-type：3、qr-sig-flags：4、query-opcode：5、qr-dns- フラグ：6、query-rcode：7、query-classtype-index：8、query-qdcount：9、query-ancount：10、query-nscount：11、query-arcount：12、query-edns-version：13 query-udp-size：14、query-opt-rdata-index：15、response-rcode：16、）QueryResponseSignatureHints = uint .bits QueryResponseSignatureHintValues"
    },
    {
      "indent": 9,
      "text": "RRHintValues = &( ttl : 0, rdata-index : 1, ) RRHints = uint .bits RRHintValues",
      "ja": "RRHintValues =＆（ttl：0、rdata-index：1、）RRHints = uint .bits RRHintValues"
    },
    {
      "indent": 9,
      "text": "OtherDataHintValues = &(\n    malformed-messages   : 0,\n    address-event-counts : 1,\n) OtherDataHints = uint .bits OtherDataHintValues",
      "raw": true
    },
    {
      "indent": 7,
      "text": "StorageFlagValues = &( anonymized-data : 0, sampled-data : 1, normalized-names : 2, ) StorageFlags = uint .bits StorageFlagValues",
      "ja": "StorageFlagValues =＆（anonymized-data：0、sampled-data：1、normalized-names：2、）StorageFlags = uint .bits StorageFlagValues"
    },
    {
      "indent": 4,
      "text": "; Metadata about data collection VLANIdRange = 1..4094",
      "ja": "; データ収集に関するメタデータVLANIdRange = 1..4094"
    },
    {
      "indent": 4,
      "text": "CollectionParameters = {\n     ? query-timeout      => uint,             ; Milliseconds\n     ? skew-timeout       => uint,             ; Microseconds\n     ? snaplen            => uint,\n     ? promisc            => bool,\n     ? interfaces         => [+ tstr],\n     ? server-addresses   => [+ IPAddress],\n     ? vlan-ids           => [+ VLANIdRange],\n     ? filter             => tstr,\n     ? generator-id       => tstr,\n     ? host-id            => tstr,\n }\n query-timeout      = 0\n skew-timeout       = 1\n snaplen            = 2\n promisc            = 3\n interfaces         = 4\n server-addresses   = 5\n vlan-ids           = 6\n filter             = 7\n generator-id       = 8\n host-id            = 9",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; Data in the file is stored in Blocks.\n;\nBlock = {\n    block-preamble          => BlockPreamble,\n    ? block-statistics      => BlockStatistics, ; Much of this\n                                                ; could be derived\n    ? block-tables          => BlockTables,\n    ? query-responses       => [+ QueryResponse],\n    ? address-event-counts  => [+ AddressEventCount],\n    ? malformed-messages    => [+ MalformedMessage],\n} block-preamble        = 0\nblock-statistics      = 1\nblock-tables          = 2\nquery-responses       = 3\naddress-event-counts  = 4\nmalformed-messages    = 5",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; The (mandatory) preamble to a Block.\n;\nBlockPreamble = {\n    ? earliest-time          => Timestamp,\n    ? block-parameters-index => uint .default 0,\n}\nearliest-time          = 0\nblock-parameters-index = 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "; Ticks are sub-second intervals. The number of ticks in a second is ; file/block metadata. Signed and unsigned tick types are defined. ticks = int uticks = uint",
      "ja": "; 目盛りは1秒未満の間隔です。 1秒のティック数は;です。 ファイル/ブロックのメタデータ。 符号付きおよび符号なしのティックタイプが定義されています。 ticks = int uticks = uint"
    },
    {
      "indent": 3,
      "text": "Timestamp = [\n    timestamp-secs   : uint,      ; POSIX time\n    timestamp-ticks  : uticks,\n]",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; Statistics about the Block contents.\n;\nBlockStatistics = {\n    ? processed-messages  => uint,\n    ? qr-data-items       => uint,\n    ? unmatched-queries   => uint,\n    ? unmatched-responses => uint,\n    ? discarded-opcode    => uint,\n    ? malformed-items     => uint,\n}\nprocessed-messages  = 0\nqr-data-items       = 1\nunmatched-queries   = 2\nunmatched-responses = 3\ndiscarded-opcode    = 4\nmalformed-items     = 5",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; Tables of common data referenced from records in a Block.\n;\nBlockTables = {\n    ? ip-address             => [+ IPAddress],\n    ? classtype              => [+ ClassType],\n    ? name-rdata             => [+ bstr],    ; Holds both names\n                                             ; and RDATA\n    ? qr-sig                 => [+ QueryResponseSignature],\n    ? QuestionTables,\n    ? RRTables,\n    ? malformed-message-data => [+ MalformedMessageData],\n}\nip-address             = 0\nclasstype              = 1\nname-rdata             = 2\nqr-sig                 = 3\nqlist                  = 4\nqrr                    = 5\nrrlist                 = 6\nrr                     = 7\nmalformed-message-data = 8",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IPv4Address = bstr .size (0..4)\nIPv6Address = bstr .size (0..16)\nIPAddress = IPv4Address / IPv6Address",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ClassType = {\n    type  => uint,\n    class => uint,\n}\ntype  = 0\nclass = 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "QueryResponseSignature = {\n    ? server-address-index  => uint,\n    ? server-port           => uint,\n    ? qr-transport-flags    => QueryResponseTransportFlags,\n    ? qr-type               => QueryResponseType,\n    ? qr-sig-flags          => QueryResponseFlags,\n    ? query-opcode          => uint,\n    ? qr-dns-flags          => DNSFlags,\n    ? query-rcode           => uint,\n    ? query-classtype-index => uint,\n    ? query-qdcount         => uint,\n    ? query-ancount         => uint,\n    ? query-nscount         => uint,\n    ? query-arcount         => uint,",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    ? query-edns-version    => uint,\n    ? query-udp-size        => uint,\n    ? query-opt-rdata-index => uint,\n    ? response-rcode        => uint,\n}\nserver-address-index  = 0\nserver-port           = 1\nqr-transport-flags    = 2\nqr-type               = 3\nqr-sig-flags          = 4\nquery-opcode          = 5\nqr-dns-flags          = 6\nquery-rcode           = 7\nquery-classtype-index = 8\nquery-qdcount         = 9\nquery-ancount         = 10\nquery-nscount         = 11\nquery-arcount         = 12\nquery-edns-version    = 13\nquery-udp-size        = 14\nquery-opt-rdata-index = 15\nresponse-rcode        = 16",
      "raw": true
    },
    {
      "indent": 5,
      "text": "; Transport gives the values that may appear in bits 1..4 of\n; TransportFlags.  There is currently no way to express this in\n; CDDL, so Transport is unused.  To avoid confusion when used\n; with CDDL tools, it is commented out.\n;\n; Transport = &(\n;     udp               : 0,\n;     tcp               : 1,\n;     tls               : 2,\n;     dtls              : 3,\n;     https             : 4,\n;     non-standard      : 15,\n; )",
      "raw": true
    },
    {
      "indent": 5,
      "text": "TransportFlagValues = &(\n    ip-version         : 0,     ; 0=IPv4, 1=IPv6\n) / (1..4)\nTransportFlags = uint .bits TransportFlagValues",
      "raw": true
    },
    {
      "indent": 5,
      "text": "QueryResponseTransportFlagValues = &( query-trailingdata : 5, ) / TransportFlagValues QueryResponseTransportFlags = uint .bits QueryResponseTransportFlagValues",
      "ja": "QueryResponseTransportFlagValues =＆（query-trailingdata：5、）/ TransportFlagValues QueryResponseTransportFlags = uint .bits QueryResponseTransportFlagValues"
    },
    {
      "indent": 5,
      "text": "QueryResponseType = &( stub : 0, client : 1, resolver : 2, auth : 3, forwarder : 4, tool : 5, )",
      "ja": "QueryResponseType =＆（スタブ：0、クライアント：1、リゾルバー：2、認証：3、フォワーダー：4、ツール：5、）"
    },
    {
      "indent": 5,
      "text": "QueryResponseFlagValues = &( has-query : 0, has-response : 1, query-has-opt : 2, response-has-opt : 3, query-has-no-question : 4, response-has-no-question: 5, ) QueryResponseFlags = uint .bits QueryResponseFlagValues",
      "ja": "QueryResponseFlagValues =＆（has-query：0、has-response：1、query-has-opt：2、response-has-opt：3、query-has-no-question：4、response-has-no-question： 5、）QueryResponseFlags = uint .bits QueryResponseFlagValues"
    },
    {
      "indent": 5,
      "text": "DNSFlagValues = &( query-cd : 0, query-ad : 1, query-z : 2, query-ra : 3, query-rd : 4, query-tc : 5, query-aa : 6, query-do : 7, response-cd: 8, response-ad: 9, response-z : 10, response-ra: 11, response-rd: 12, response-tc: 13, response-aa: 14, ) DNSFlags = uint .bits DNSFlagValues",
      "ja": "DNSFlagValues =＆（query-cd：0、query-ad：1、query-z：2、query-ra：3、query-rd：4、query-tc：5、query-aa：6、query-do： 7、応答cd：8、応答ad：9、応答z：10、応答ra：11、応答rd：12、応答tc：13、応答aa：14、）DNSFlags = uint .bits DNSFlagValues"
    },
    {
      "indent": 3,
      "text": "QuestionTables = (\n    qlist => [+ QuestionList],\n    qrr   => [+ Question]\n)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "QuestionList = [+ uint]           ; Index of Question",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Question = {                      ; Second and subsequent Questions\n    name-index      => uint,      ; Index to a name in the\n                                  ; name-rdata table\n    classtype-index => uint,\n}\nname-index      = 0\nclasstype-index = 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "RRTables = (\n    rrlist => [+ RRList],\n    rr     => [+ RR]\n)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RRList = [+ uint]                     ; Index of RR",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RR = {\n    name-index      => uint,          ; Index to a name in the\n                                      ; name-rdata table\n    classtype-index => uint,\n    ? ttl           => uint,\n    ? rdata-index   => uint,          ; Index to RDATA in the\n                                      ; name-rdata table\n}\n; Other map key values already defined above.\nttl         = 2\nrdata-index = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "MalformedMessageData = {\n    ? server-address-index   => uint,\n    ? server-port            => uint,\n    ? mm-transport-flags     => TransportFlags,\n    ? mm-payload             => bstr,\n}\n; Other map key values already defined above.\nmm-transport-flags      = 2\nmm-payload              = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; A single Query/Response data item.\n;\nQueryResponse = {\n    ? time-offset              => uticks,     ; Time offset from\n                                              ; start of Block\n    ? client-address-index     => uint,\n    ? client-port              => uint,\n    ? transaction-id           => uint,\n    ? qr-signature-index       => uint,\n    ? client-hoplimit          => uint,\n    ? response-delay           => ticks,\n    ? query-name-index         => uint,\n    ? query-size               => uint,       ; DNS size of Query\n    ? response-size            => uint,       ; DNS size of Response\n    ? response-processing-data => ResponseProcessingData,\n    ? query-extended           => QueryResponseExtended,\n    ? response-extended        => QueryResponseExtended,\n}\ntime-offset              = 0\nclient-address-index     = 1\nclient-port              = 2\ntransaction-id           = 3\nqr-signature-index       = 4\nclient-hoplimit          = 5\nresponse-delay           = 6\nquery-name-index         = 7\nquery-size               = 8\nresponse-size            = 9\nresponse-processing-data = 10\nquery-extended           = 11\nresponse-extended        = 12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ResponseProcessingData = {\n    ? bailiwick-index  => uint,\n    ? processing-flags => ResponseProcessingFlags,\n}\nbailiwick-index = 0\nprocessing-flags = 1",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ResponseProcessingFlagValues = &( from-cache : 0, ) ResponseProcessingFlags = uint .bits ResponseProcessingFlagValues",
      "ja": "ResponseProcessingFlagValues =＆（from-cache：0、）ResponseProcessingFlags = uint .bits ResponseProcessingFlagValues"
    },
    {
      "indent": 3,
      "text": "QueryResponseExtended = {\n    ? question-index   => uint,       ; Index of QuestionList\n    ? answer-index     => uint,       ; Index of RRList\n    ? authority-index  => uint,\n    ? additional-index => uint,\n}\nquestion-index   = 0\nanswer-index     = 1\nauthority-index  = 2\nadditional-index = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; Address event data.\n;\nAddressEventCount = {\n    ae-type              => &AddressEventType,\n    ? ae-code            => uint,\n    ae-address-index     => uint,\n    ? ae-transport-flags => TransportFlags,\n    ae-count             => uint,\n}\nae-type            = 0\nae-code            = 1\nae-address-index   = 2\nae-transport-flags = 3\nae-count           = 4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AddressEventType = (\n    tcp-reset              : 0,\n    icmp-time-exceeded     : 1,\n    icmp-dest-unreachable  : 2,\n    icmpv6-time-exceeded   : 3,\n    icmpv6-dest-unreachable: 4,\n    icmpv6-packet-too-big  : 5,\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": ";\n; Malformed messages.\n;\nMalformedMessage = {\n    ? time-offset           => uticks,   ; Time offset from\n                                         ; start of Block\n    ? client-address-index  => uint,\n    ? client-port           => uint,\n    ? message-data-index    => uint,\n}\n; Other map key values already defined above.\nmessage-data-index = 3",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. DNS Name Compression Example",
      "section_title": true,
      "ja": "付録B. DNS名圧縮の例"
    },
    {
      "indent": 3,
      "text": "The basic algorithm, which follows the guidance in [RFC1035], is simply to collect each name, and the offset in the packet at which it starts, during packet construction. As each name is added, it is offered to each of the collected names in order of collection, starting from the first name. If (1) labels at the end of the name can be replaced with a reference back to part (or all) of the earlier name and (2) the uncompressed part of the name is shorter than any compression already found, the earlier name is noted as the compression target for the name.",
      "ja": "[RFC1035]のガイダンスに従う基本的なアルゴリズムは、パケット構築中に各名前とそれが開始するパケットのオフセットを収集することです。 各名前が追加されると、収集された名前のそれぞれに、名前の最初から収集順に収集されます。 （1）名前の最後のラベルを以前の名前の一部（またはすべて）への参照に置き換えることができ、（2）名前の非圧縮部分がすでに見つかった圧縮よりも短い場合、以前の名前は 名前の圧縮ターゲットとして示されます。"
    },
    {
      "indent": 3,
      "text": "The following tables illustrate the step-by-step process of adding names and performing name compression. In an example packet, the first name added is foo.example, which cannot be compressed.",
      "ja": "次の表は、名前を追加して名前の圧縮を実行する段階的なプロセスを示しています。 パケットの例では、追加される最初の名前はfoo.exampleであり、圧縮できません。"
    },
    {
      "indent": 10,
      "text": "+---+-------------+--------------+--------------------+\n| N | Name        | Uncompressed | Compression Target |\n+---+-------------+--------------+--------------------+\n| 1 | foo.example | foo.example  | None               |\n+---+-------------+--------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The next name added is bar.example. This is matched against foo.example. The example part of this can be used as a compression target, with the remaining uncompressed part of the name being bar.",
      "ja": "次に追加される名前はbar.exampleです。 これは、foo.exampleと照合されます。 この例の部分は、圧縮ターゲットとして使用できます。名前の残りの非圧縮部分はbarです。"
    },
    {
      "indent": 8,
      "text": "+---+-------------+--------------+-----------------------+\n| N | Name        | Uncompressed | Compression Target    |\n+---+-------------+--------------+-----------------------+\n| 1 | foo.example | foo.example  | None                  |\n| 2 | bar.example | bar          | 1 + offset to example |\n+---+-------------+--------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The third name added is www.bar.example. This is first matched against foo.example, and as before this is recorded as a compression target, with the remaining uncompressed part of the name being www.bar. It is then matched against the second name, which again can be a compression target. Because the remaining uncompressed part of the name is www, this is an improved compression, and so it is adopted.",
      "ja": "追加される3番目の名前はwww.bar.exampleです。 これは最初にfoo.exampleと照合され、以前のようにこれが圧縮ターゲットとして記録され、名前の残りの非圧縮部分はwww.barになります。 次に、2番目の名前と照合されます。この名前も圧縮のターゲットになります。 名前の残りの非圧縮部分はwwwであるため、これは改善された圧縮であり、採用されています。"
    },
    {
      "indent": 6,
      "text": "+---+-----------------+--------------+-----------------------+\n| N | Name            | Uncompressed | Compression Target    |\n+---+-----------------+--------------+-----------------------+\n| 1 | foo.example     | foo.example  | None                  |\n| 2 | bar.example     | bar          | 1 + offset to example |\n| 3 | www.bar.example | www          | 2                     |\n+---+-----------------+--------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As an optimization, if a name is already perfectly compressed (in other words, the uncompressed part of the name is empty), then no further names will be considered for compression.",
      "ja": "最適化として、名前がすでに完全に圧縮されている場合（つまり、名前の圧縮されていない部分が空の場合）、それ以上の名前は圧縮と見なされません。"
    },
    {
      "indent": 0,
      "text": "B.1. NSD Compression Algorithm",
      "section_title": true,
      "ja": "B.1. NSD圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Using the above basic algorithm, the packet lengths of Responses generated by the Name Server Daemon (NSD) [NSD] can be matched almost exactly. At the time of writing, a tiny number (<.01%) of the reconstructed packets had incorrect lengths.",
      "ja": "上記の基本アルゴリズムを使用すると、ネームサーバーデーモン（NSD）[NSD]によって生成された応答のパケット長をほぼ正確に一致させることができます。 執筆時点では、再構成されたパケットのごく一部（<.01％）の長さが正しくありませんでした。"
    },
    {
      "indent": 0,
      "text": "B.2. Knot Authoritative Compression Algorithm",
      "section_title": true,
      "ja": "B.2. 結び目信頼圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The Knot Authoritative name server [Knot] uses different compression behavior, which is the result of internal optimization designed to balance runtime speed with compression size gains. In brief, and omitting complications, Knot Authoritative will only consider the QNAME and names in the immediately preceding RR section in an RRSET as compression targets.",
      "ja": "Knot Authoritativeネームサーバー[Knot]は、異なる圧縮動作を使用します。これは、実行速度と圧縮サイズの増加のバランスをとるように設計された内部最適化の結果です。 簡潔に、そして複雑さを省いて、Knot AuthoritativeはRRSETの直前のRRセクションのQNAMEと名前のみを圧縮ターゲットと見なします。"
    },
    {
      "indent": 3,
      "text": "A set of smart heuristics as described below can be implemented to mimic this, and while not perfect, it produces output nearly, but not quite, as good a match as with NSD. The heuristics are as follows:",
      "ja": "以下に説明する一連のスマートヒューリスティックを実装してこれを模倣することができますが、完全ではありませんが、NSDとほぼ同じではありますが、完全には一致しません。 ヒューリスティックは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. A match is only perfect if the name is completely compressed AND the TYPE of the section in which the name occurs matches the TYPE of the name used as the compression target.",
      "ja": "1. 名前が完全に圧縮され、名前が発生するセクションのTYPEが圧縮ターゲットとして使用される名前のTYPEと一致する場合にのみ、一致は完全です。"
    },
    {
      "indent": 3,
      "text": "2. If the name occurs in RDATA:",
      "ja": "2. 名前がRDATAにある場合："
    },
    {
      "indent": 7,
      "text": "* If the compression target name is in a Query, then only the first RR in an RRSET can use that name as a compression target.",
      "ja": "* 圧縮ターゲット名がクエリにある場合、RRSETの最初のRRのみがその名前を圧縮ターゲットとして使用できます。"
    },
    {
      "indent": 7,
      "text": "* The compression target name MUST be in RDATA.",
      "ja": "* 圧縮ターゲット名はRDATAになければなりません。"
    },
    {
      "indent": 7,
      "text": "* The name section TYPE must match the compression target name section TYPE.",
      "ja": "* 名前セクションTYPEは、圧縮ターゲットの名前セクションTYPEと一致する必要があります。"
    },
    {
      "indent": 7,
      "text": "* The compression target name MUST be in the immediately preceding RR in the RRSET.",
      "ja": "* 圧縮ターゲット名は、RRSETの直前のRRになければなりません。"
    },
    {
      "indent": 3,
      "text": "Using this algorithm, less than 0.1% of the reconstructed packets had incorrect lengths.",
      "ja": "このアルゴリズムを使用すると、再構成されたパケットの長さが0.1％未満でした。"
    },
    {
      "indent": 0,
      "text": "B.3. Observed Differences",
      "section_title": true,
      "ja": "B.3. 観察された違い"
    },
    {
      "indent": 3,
      "text": "In sample traffic collected on a root name server, around 2-4% of Responses generated by Knot had different packet lengths than those produced by NSD.",
      "ja": "ルートネームサーバーで収集されたサンプルトラフィックでは、Knotによって生成された応答の約2〜4％が、NSDによって生成されたものとは異なるパケット長でした。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Comparison of Binary Formats",
      "section_title": true,
      "ja": "付録C.バイナリ形式の比較"
    },
    {
      "indent": 3,
      "text": "Several binary serialization formats were considered. For completeness, they were also compared to JSON.",
      "ja": "いくつかのバイナリシリアル化形式が検討されました。 完全を期すため、JSONと比較しました。"
    },
    {
      "indent": 3,
      "text": "o Apache Avro [Avro]. Data is stored according to a predefined schema. The schema itself is always included in the data file. Data can therefore be stored untagged, for a smaller serialization size, and be written and read by an Avro library.",
      "ja": "o Apache Avro [Avro]。 データは、事前定義されたスキーマに従って保存されます。 スキーマ自体は常にデータファイルに含まれています。 したがって、シリアル化サイズを小さくするために、データをタグなしで保存し、Avroライブラリで読み書きすることができます。"
    },
    {
      "indent": 6,
      "text": "* At the time of writing, Avro libraries are available for C, C++, C#, Java, Python, Ruby, and PHP. Optionally, tools are available for C++, Java, and C# to generate code for encoding and decoding.",
      "ja": "* 執筆時点では、AvroライブラリはC、C ++、C＃、Java、Python、Ruby、およびPHPで使用できます。 オプションで、C ++、Java、およびC＃のツールを使用して、エンコードおよびデコード用のコードを生成できます。"
    },
    {
      "indent": 3,
      "text": "o Google Protocol Buffers [Protocol-Buffers]. Data is stored according to a predefined schema. The schema is used by a generator to generate code for encoding and decoding the data. Data can therefore be stored untagged, for a smaller serialization size. The schema is not stored with the data, so unlike Avro, it cannot be read with a generic library.",
      "ja": "o Google Protocol Buffers [Protocol-Buffers]。 データは、事前定義されたスキーマに従って保存されます。 スキーマは、データをエンコードおよびデコードするためのコードを生成するためにジェネレーターによって使用されます。 したがって、シリアル化サイズを小さくするために、データをタグなしで保存できます。 スキーマはデータと共に保存されないため、Avroとは異なり、汎用ライブラリで読み取ることはできません。"
    },
    {
      "indent": 6,
      "text": "* Code must be generated for a particular data schema to read and write data using that schema. At the time of writing, the Google code generator can currently generate code for encoding and decoding a schema for C++, Go, Java, Python, Ruby, C#, Objective-C, JavaScript, and PHP.",
      "ja": "* 特定のデータスキーマを使用してデータを読み書きするには、そのスキーマを使用してコードを生成する必要があります。 執筆時点で、Googleコードジェネレーターは現在、C ++、Go、Java、Python、Ruby、C＃、Objective-C、JavaScript、およびPHPのスキーマをエンコードおよびデコードするためのコードを生成できます。"
    },
    {
      "indent": 3,
      "text": "o CBOR [RFC7049]. This serialization format is comparable to JSON but with a binary representation. It does not use a predefined schema, so data is always stored tagged. However, CBOR data schemas can be described using CDDL [RFC8610], and tools exist to verify that data files conform to the schema.",
      "ja": "o CBOR [RFC7049]。 このシリアル化形式はJSONに匹敵しますが、バイナリ表現を備えています。 事前定義されたスキーマを使用しないため、データは常にタグ付きで保存されます。 ただし、CDDL [RFC8610]を使用してCBORデータスキーマを記述することができ、データファイルがスキーマに準拠していることを確認するツールが存在します。"
    },
    {
      "indent": 6,
      "text": "* CBOR is a simple format and is simple to implement. At the time of writing, the CBOR website lists implementations for 16 languages.",
      "ja": "* CBORは単純な形式であり、実装が簡単です。 執筆時点で、CBOR Webサイトには16言語の実装がリストされています。"
    },
    {
      "indent": 3,
      "text": "Avro and Protocol Buffers both allow storage of untagged data, but because they rely on the data schema for this, their implementation is considerably more complex than CBOR. Using Avro or Protocol Buffers in an unsupported environment would require notably greater development effort compared to CBOR.",
      "ja": "AvroとProtocol Buffersはどちらもタグなしデータの保存を許可しますが、これはデータスキーマに依存しているため、それらの実装はCBORよりもかなり複雑です。 サポートされていない環境でAvroまたはProtocol Buffersを使用するには、CBORと比較して著しく大きな開発努力が必要です。"
    },
    {
      "indent": 3,
      "text": "A test program was written that reads input from a PCAP file and writes output using one of two basic structures: either a simple structure, where each Query/Response pair is represented in a single record entry, or the C-DNS block structure.",
      "ja": "PCAPファイルから入力を読み取り、2つの基本構造のいずれかを使用して出力を書き込むテストプログラムが作成されました。単純な構造（各クエリ/応答ペアが単一のレコードエントリで表される）、またはC-DNSブロック構造のいずれかです。"
    },
    {
      "indent": 3,
      "text": "The resulting output files were then compressed using a variety of common general-purpose lossless compression tools to explore the compressibility of the formats. The compression tools employed were:",
      "ja": "次に、結果の出力ファイルをさまざまな一般的な汎用ロスレス圧縮ツールを使用して圧縮し、形式の圧縮率を調べました。 使用された圧縮ツールは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o snzip [snzip]. A command-line compression tool based on the Google Snappy library [snappy].",
      "ja": "o snzip [snzip]。 Google Snappyライブラリ[snappy]に基づいたコマンドライン圧縮ツール。"
    },
    {
      "indent": 3,
      "text": "o lz4 [lz4]. The command-line compression tool from the reference C LZ4 implementation.",
      "ja": "o lz4 [lz4]。 リファレンスC LZ4実装のコマンドライン圧縮ツール。"
    },
    {
      "indent": 3,
      "text": "o gzip [gzip]. The ubiquitous GNU zip tool.",
      "ja": "o gzip [gzip]。 ユビキタスGNU zipツール。"
    },
    {
      "indent": 3,
      "text": "o zstd [zstd]. Compression using the Zstandard algorithm.",
      "ja": "o zstd [zstd]。 Zstandardアルゴリズムを使用した圧縮。"
    },
    {
      "indent": 3,
      "text": "o xz [xz]. A popular compression tool noted for high compression.",
      "ja": "o xz [xz]。 高い圧縮率で有名な人気の圧縮ツール。"
    },
    {
      "indent": 3,
      "text": "In all cases, the compression tools were run using their default settings.",
      "ja": "いずれの場合も、圧縮ツールはデフォルト設定を使用して実行されました。"
    },
    {
      "indent": 3,
      "text": "Note that this document does not mandate the use of compression, nor any particular compression scheme, but it anticipates that in practice output data will be subject to general-purpose compression, and so this should be taken into consideration.",
      "ja": "このドキュメントでは、圧縮の使用も特定の圧縮スキームも義務付けられていませんが、実際には出力データは汎用圧縮の対象となるため、これを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "\"test.pcap\", a 662 MB capture of sample data from a root instance, was used for the comparison. The following table shows the formatted size and size after compression (abbreviated to Comp. in the table headers), together with the task Resident Set Size (RSS) and the user time taken by the compression. File sizes are in MB, RSS is in kB, and user time is in seconds.",
      "ja": "ルートインスタンスからのサンプルデータの662 MBのキャプチャである「test.pcap」が比較に使用されました。 次の表は、フォーマット後のサイズと圧縮後のサイズ（テーブルヘッダーではComp。に省略）、および常駐セットサイズ（RSS）タスクと圧縮にかかったユーザー時間を示しています。 ファイルサイズはMB、RSSはkB、ユーザー時間は秒です。"
    },
    {
      "indent": 3,
      "text": "+-------------+-----------+-------+------------+-------+-----------+\n| Format      | File Size | Comp. | Comp. Size |   RSS | User Time |\n+-------------+-----------+-------+------------+-------+-----------+\n| PCAP        |    661.87 | snzip |     212.48 |  2696 |      1.26 |\n|             |           | lz4   |     181.58 |  6336 |      1.35 |\n|             |           | gzip  |     153.46 |  1428 |     18.20 |\n|             |           | zstd  |      87.07 |  3544 |      4.27 |\n|             |           | xz    |      49.09 | 97416 |    160.79 |\n|             |           |       |            |       |           |\n| JSON simple |   4113.92 | snzip |     603.78 |  2656 |      5.72 |\n|             |           | lz4   |     386.42 |  5636 |      5.25 |\n|             |           | gzip  |     271.11 |  1492 |     73.00 |\n|             |           | zstd  |     133.43 |  3284 |      8.68 |\n|             |           | xz    |      51.98 | 97412 |    600.74 |\n|             |           |       |            |       |           |\n| Avro simple |    640.45 | snzip |     148.98 |  2656 |      0.90 |\n|             |           | lz4   |     111.92 |  5828 |      0.99 |\n|             |           | gzip  |     103.07 |  1540 |     11.52 |\n|             |           | zstd  |      49.08 |  3524 |      2.50 |\n|             |           | xz    |      22.87 | 97308 |     90.34 |\n|             |           |       |            |       |           |\n| CBOR simple |    764.82 | snzip |     164.57 |  2664 |      1.11 |\n|             |           | lz4   |     120.98 |  5892 |      1.13 |\n|             |           | gzip  |     110.61 |  1428 |     12.88 |\n|             |           | zstd  |      54.14 |  3224 |      2.77 |\n|             |           | xz    |      23.43 | 97276 |    111.48 |\n|             |           |       |            |       |           |\n| PBuf simple |    749.51 | snzip |     167.16 |  2660 |      1.08 |\n|             |           | lz4   |     123.09 |  5824 |      1.14 |\n|             |           | gzip  |     112.05 |  1424 |     12.75 |\n|             |           | zstd  |      53.39 |  3388 |      2.76 |\n|             |           | xz    |      23.99 | 97348 |    106.47 |\n|             |           |       |            |       |           |\n| JSON block  |    519.77 | snzip |     106.12 |  2812 |      0.93 |\n|             |           | lz4   |     104.34 |  6080 |      0.97 |\n|             |           | gzip  |      57.97 |  1604 |     12.70 |\n|             |           | zstd  |      61.51 |  3396 |      3.45 |\n|             |           | xz    |      27.67 | 97524 |    169.10 |\n|             |           |       |            |       |           |\n| Avro block  |     60.45 | snzip |      48.38 |  2688 |      0.20 |\n|             |           | lz4   |      48.78 |  8540 |      0.22 |\n|             |           | gzip  |      39.62 |  1576 |      2.92 |\n|             |           | zstd  |      29.63 |  3612 |      1.25 |\n|             |           | xz    |      18.28 | 97564 |     25.81 |\n|             |           |       |            |       |           |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| CBOR block  |     75.25 | snzip |      53.27 |  2684 |      0.24 |\n|             |           | lz4   |      51.88 |  8008 |      0.28 |\n|             |           | gzip  |      41.17 |  1548 |      4.36 |\n|             |           | zstd  |      30.61 |  3476 |      1.48 |\n|             |           | xz    |      18.15 | 97556 |     38.78 |\n|             |           |       |            |       |           |\n| PBuf block  |     67.98 | snzip |      51.10 |  2636 |      0.24 |\n|             |           | lz4   |      52.39 |  8304 |      0.24 |\n|             |           | gzip  |      40.19 |  1520 |      3.63 |\n|             |           | zstd  |      31.61 |  3576 |      1.40 |\n|             |           | xz    |      17.94 | 97440 |     33.99 |\n+-------------+-----------+-------+------------+-------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above results are discussed in the following sections.",
      "ja": "上記の結果については、次のセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "C.1. Comparison with Full PCAP Files",
      "section_title": true,
      "ja": "C.1. 完全なPCAPファイルとの比較"
    },
    {
      "indent": 3,
      "text": "An important first consideration is whether moving away from PCAP offers significant benefits.",
      "ja": "重要な最初の考慮事項は、PCAPからの移行が大きなメリットをもたらすかどうかです。"
    },
    {
      "indent": 3,
      "text": "The simple binary formats are typically larger than PCAP, even though they omit some information such as Ethernet Media Access Control (MAC) addresses. But not only do they require less CPU to compress than PCAP, the resulting compressed files are smaller than compressed PCAP.",
      "ja": "単純なバイナリ形式は、イーサネットメディアアクセス制御（MAC）アドレスなどの一部の情報が省略されていても、通常はPCAPよりも大きくなります。 ただし、圧縮に必要なCPUがPCAPよりも少ないだけでなく、結果の圧縮ファイルは圧縮PCAPよりも小さくなります。"
    },
    {
      "indent": 0,
      "text": "C.2. Simple versus Block Coding",
      "section_title": true,
      "ja": "C.2. 単純コーディングとブロックコーディング"
    },
    {
      "indent": 3,
      "text": "The intention of the block coding is to perform data deduplication on Query/Response records within the block. The simple and block formats shown above store exactly the same information for each Query/Response record. This information is parsed from the DNS traffic in the input PCAP file, and in all cases each field has an identifier and the field data is typed.",
      "ja": "ブロックコーディングの目的は、ブロック内のクエリ/レスポンスレコードでデータ重複排除を実行することです。 上記の単純な形式とブロック形式では、各クエリ/応答レコードについてまったく同じ情報が保存されます。 この情報は、入力PCAPファイルのDNSトラフィックから解析され、すべての場合で各フィールドに識別子があり、フィールドデータが入力されます。"
    },
    {
      "indent": 3,
      "text": "The data deduplication on the block formats show an order-of-magnitude reduction in the size of the format file size against the simple formats. As would be expected, the compression tools are able to find and exploit a lot of this duplication, but as the deduplication process uses knowledge of DNS traffic, it is able to retain a size advantage. This advantage reduces as stronger compression is applied, as again would be expected, but even with the strongest compression applied the block-formatted data remains around 75% of the size of the simple format and its compression requires roughly a third of the CPU time.",
      "ja": "ブロック形式でのデータ重複排除は、単純な形式と比較して、形式ファイルのサイズが桁違いに小さくなることを示しています。 予想されるように、圧縮ツールはこの重複の多くを検出して活用できますが、重複排除プロセスはDNSトラフィックの知識を使用するため、サイズの優位性を維持できます。 再び予想されるように、この利点はより強力な圧縮が適用されると低下しますが、最も強力な圧縮を適用しても、ブロック形式のデータは単純な形式のサイズの約75％のままであり、その圧縮にはCPU時間の約3分の1が必要です。"
    },
    {
      "indent": 0,
      "text": "C.3. Binary versus Text Formats",
      "section_title": true,
      "ja": "C.3. バイナリ形式とテキスト形式"
    },
    {
      "indent": 3,
      "text": "Text data formats offer many advantages over binary formats, particularly in the areas of ad hoc data inspection and extraction. It was therefore felt worthwhile to carry out a direct comparison, implementing JSON versions of the simple and block formats.",
      "ja": "テキストデータ形式は、特にアドホックデータの検査と抽出の分野で、バイナリ形式よりも多くの利点を提供します。 そのため、単純な形式とブロック形式のJSONバージョンを実装して、直接比較する価値がありました。"
    },
    {
      "indent": 3,
      "text": "Concentrating on JSON block format, the format files produced are a significant fraction of an order of magnitude larger than binary formats. The impact on file size after compression is as might be expected from that starting point; the stronger compression produces files that are 150% of the size of similarly compressed binary format and require over 4x more CPU to compress.",
      "ja": "JSONブロック形式に集中しているため、生成される形式ファイルは、バイナリ形式よりも桁違いに大きくなっています。 圧縮後のファイルサイズへの影響は、その開始点から予想されるとおりです。 より強力な圧縮により、同様に圧縮されたバイナリ形式のサイズの150％のファイルが生成され、圧縮には4倍以上のCPUが必要になります。"
    },
    {
      "indent": 0,
      "text": "C.4. Performance",
      "section_title": true,
      "ja": "C.4. 性能"
    },
    {
      "indent": 3,
      "text": "Concentrating again on the block formats, all three produce format files that are close to an order of magnitude smaller than the original \"test.pcap\" file. CBOR produces the largest files and Avro the smallest, 20% smaller than CBOR.",
      "ja": "ブロック形式に再び集中すると、3つすべてが元の「test.pcap」ファイルよりも1桁小さい形式ファイルを生成します。 CBORは最大のファイルを生成し、AvroはCBORよりも20％小さい最小のファイルを生成します。"
    },
    {
      "indent": 3,
      "text": "However, once compression is taken into account, the size difference narrows. At medium compression (with gzip), the size difference is 4%. Using strong compression (with xz), the difference reduces to 2%, with Avro the largest and Protocol Buffers the smallest, although CBOR and Protocol Buffers require slightly more compression CPU.",
      "ja": "ただし、圧縮が考慮されると、サイズの差は狭くなります。 中程度の圧縮（gzipを使用）では、サイズの違いは4％です。 強力な圧縮（xzを使用）を使用すると、差は2％に減少し、Avroが最大になり、プロトコルバッファーが最小になりますが、CBORおよびプロトコルバッファーには若干多くの圧縮CPUが必要です。"
    },
    {
      "indent": 3,
      "text": "The measurements presented above do not include data on the CPU required to generate the format files. Measurements indicate that writing Avro requires 10% more CPU than CBOR or Protocol Buffers. It appears, therefore, that Avro's advantage in compression CPU usage is probably offset by a larger CPU requirement in writing Avro.",
      "ja": "上記の測定値には、フォーマットファイルの生成に必要なCPUのデータは含まれていません。 測定によると、Avroの書き込みには、CBORまたはプロトコルバッファーよりも10％多くのCPUが必要です。 したがって、Avroの圧縮CPU使用率におけるAvroの利点は、Avroを作成する際のより大きなCPU要件によって相殺されると思われます。"
    },
    {
      "indent": 0,
      "text": "C.5. Conclusions",
      "section_title": true,
      "ja": "C.5. 結論"
    },
    {
      "indent": 3,
      "text": "The above assessments lead us to the choice of a binary format file using blocking.",
      "ja": "上記の評価により、ブロッキングを使用してバイナリ形式のファイルを選択することになります。"
    },
    {
      "indent": 3,
      "text": "As noted previously, this document anticipates that output data will be subject to compression. There is no compelling case for one particular binary serialization format in terms of either final file size or machine resources consumed, so the choice must be largely based on other factors. CBOR was therefore chosen as the binary serialization format for the reasons listed in Section 5.",
      "ja": "前述したように、このドキュメントでは、出力データが圧縮の対象になることを想定しています。 最終的なファイルサイズまたは消費されるマシンリソースに関して、特定のバイナリシリアル化形式について説得力のあるケースはないため、選択は主に他の要因に基づいている必要があります。 したがって、セクション5に記載されている理由により、CBORがバイナリシリアル化形式として選択されました。"
    },
    {
      "indent": 0,
      "text": "C.6. Block Size Choice",
      "section_title": true,
      "ja": "C.6. ブロックサイズの選択"
    },
    {
      "indent": 3,
      "text": "Given the choice of a CBOR format using blocking, the question arises of what an appropriate default value for the maximum number of Query/Response pairs in a block should be. This has two components:",
      "ja": "ブロッキングを使用したCBOR形式の選択を考えると、ブロック内のクエリ/レスポンスペアの最大数の適切なデフォルト値はどうあるべきかという疑問が生じます。 これには2つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "1. What is the impact on performance of using different block sizes in the format file?",
      "ja": "1. フォーマットファイルで異なるブロックサイズを使用すると、パフォーマンスにどのような影響がありますか？"
    },
    {
      "indent": 3,
      "text": "2. What is the impact on the size of the format file before and after compression?",
      "ja": "2. 圧縮前後のフォーマットファイルのサイズへの影響は何ですか？"
    },
    {
      "indent": 3,
      "text": "The following table addresses the performance question, showing the impact on the performance of a C++ program converting \"test.pcap\" to C-DNS. File sizes are in MB, RSS is in kB, and user time is in seconds.",
      "ja": "次の表は、「test.pcap」をC-DNSに変換するC ++プログラムのパフォーマンスへの影響を示す、パフォーマンスの質問に対応しています。 ファイルサイズはMB、RSSはkB、ユーザー時間は秒です。"
    },
    {
      "indent": 14,
      "text": "+------------+-----------+--------+-----------+\n| Block Size | File Size |    RSS | User Time |\n+------------+-----------+--------+-----------+\n|      1,000 |    133.46 | 612.27 |     15.25 |\n|      5,000 |     89.85 | 676.82 |     14.99 |\n|     10,000 |     76.87 | 752.40 |     14.53 |\n|     20,000 |     67.86 | 750.75 |     14.49 |\n|     40,000 |     61.88 | 736.30 |     14.29 |\n|     80,000 |     58.08 | 694.16 |     14.28 |\n|    160,000 |     55.94 | 733.84 |     14.44 |\n|    320,000 |     54.41 | 799.20 |     13.97 |\n+------------+-----------+--------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Therefore, increasing block size tends to increase maximum RSS a little, with no significant effect (if anything, a small reduction) on CPU consumption.",
      "ja": "したがって、ブロックサイズを大きくすると、最大RSSが少し増加する傾向があり、CPU消費に大きな影響はありません（もしあれば）。"
    },
    {
      "indent": 3,
      "text": "The following table demonstrates the effect of increasing block size on output file size for different compressions.",
      "ja": "次の表は、さまざまな圧縮の出力ファイルサイズに対するブロックサイズの増加の影響を示しています。"
    },
    {
      "indent": 6,
      "text": "+------------+--------+-------+-------+-------+-------+-------+\n| Block Size |   None | snzip |   lz4 |  gzip |  zstd |    xz |\n+------------+--------+-------+-------+-------+-------+-------+\n|      1,000 | 133.46 | 90.52 | 90.03 | 74.65 | 44.78 | 25.63 |\n|      5,000 |  89.85 | 59.69 | 59.43 | 46.99 | 37.33 | 22.34 |\n|     10,000 |  76.87 | 50.39 | 50.28 | 38.94 | 33.62 | 21.09 |\n|     20,000 |  67.86 | 43.91 | 43.90 | 33.24 | 32.62 | 20.16 |\n|     40,000 |  61.88 | 39.63 | 39.69 | 29.44 | 28.72 | 19.52 |\n|     80,000 |  58.08 | 36.93 | 37.01 | 27.05 | 26.25 | 19.00 |\n|    160,000 |  55.94 | 35.10 | 35.06 | 25.44 | 24.56 | 19.63 |\n|    320,000 |  54.41 | 33.87 | 33.74 | 24.36 | 23.44 | 18.66 |\n+------------+--------+-------+-------+-------+-------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There is obviously scope for tuning the default block size to the compression being employed, traffic characteristics, frequency of output file rollover, etc. Using a strong compression scheme, block sizes over 10,000 Query/Response pairs would seem to offer limited improvements.",
      "ja": "使用される圧縮、トラフィック特性、出力ファイルのロールオーバーの頻度などに合わせてデフォルトのブロックサイズを調整する範囲があることは明らかです。強力な圧縮スキームを使用すると、10,000を超えるクエリ/レスポンスペアのブロックサイズは限定的な改善を提供するようです。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Data Fields for Traffic Regeneration",
      "section_title": true,
      "ja": "付録D.トラフィック再生成のデータフィールド"
    },
    {
      "indent": 0,
      "text": "D.1. Recommended Fields for Traffic Regeneration",
      "section_title": true,
      "ja": "D.1. トラフィック再生の推奨フィールド"
    },
    {
      "indent": 3,
      "text": "This section specifies the data fields that would need to be captured in order to perform the fullest PCAP traffic reconstruction for well-formed DNS messages that is possible with C-DNS.",
      "ja": "このセクションでは、C-DNSで可能な整形式DNSメッセージの完全なPCAPトラフィック再構築を実行するためにキャプチャする必要があるデータフィールドを指定します。"
    },
    {
      "indent": 3,
      "text": "o All data fields in the QueryResponse type except response-processing-data.",
      "ja": "o response-processing-dataを除くQueryResponseタイプのすべてのデータフィールド。"
    },
    {
      "indent": 3,
      "text": "o All data fields in the QueryResponseSignature type except qr-type.",
      "ja": "o qr-typeを除くQueryResponseSignatureタイプのすべてのデータフィールド。"
    },
    {
      "indent": 3,
      "text": "o All data fields in the RR TYPE.",
      "ja": "o RRタイプのすべてのデータフィールド。"
    },
    {
      "indent": 0,
      "text": "D.2. Issues with Small Data Captures",
      "section_title": true,
      "ja": "D.2. スモールデータキャプチャの問題"
    },
    {
      "indent": 3,
      "text": "At the other extreme, an interesting corner case arises when opting to perform captures with a smaller data set than that recommended above. The following list specifies a subset of the above data fields; if only these data fields are captured, then even a minimal traffic reconstruction is problematic because there is not enough information to determine if the Query/Response data item contained just a Query, just a Response, or a Query/Response pair.",
      "ja": "他の極端な場合、上記で推奨されているよりも小さなデータセットでキャプチャを実行することを選択した場合、興味深いコーナーケースが発生します。 次のリストは、上記のデータフィールドのサブセットを指定しています。 これらのデータフィールドのみがキャプチャされる場合、クエリ/レスポンスデータ項目にクエリのみ、レスポンスのみ、またはクエリ/レスポンスペアが含まれているかどうかを判断するのに十分な情報がないため、最小限のトラフィックの再構築でも問題があります。"
    },
    {
      "indent": 3,
      "text": "o The following data fields from the QueryResponse type:",
      "ja": "o QueryResponseタイプの次のデータフィールド："
    },
    {
      "indent": 6,
      "text": "* time-offset",
      "ja": "* タイムオフセット"
    },
    {
      "indent": 6,
      "text": "* client-address-index",
      "ja": "* クライアントアドレスインデックス"
    },
    {
      "indent": 6,
      "text": "* client-port",
      "ja": "* クライアントポート"
    },
    {
      "indent": 6,
      "text": "* transaction-id",
      "ja": "* トランザクションID"
    },
    {
      "indent": 6,
      "text": "* query-name-index",
      "ja": "* クエリ名インデックス"
    },
    {
      "indent": 3,
      "text": "o The following data fields from the QueryResponseSignature type:",
      "ja": "o QueryResponseSignatureタイプの次のデータフィールド："
    },
    {
      "indent": 6,
      "text": "* server-address-index",
      "ja": "* サーバーアドレスインデックス"
    },
    {
      "indent": 6,
      "text": "* server-port",
      "ja": "* サーバポート"
    },
    {
      "indent": 6,
      "text": "* qr-transport-flags",
      "ja": "* qr-transport-flags"
    },
    {
      "indent": 6,
      "text": "* query-classtype-index",
      "ja": "* クエリクラスタイプインデックス"
    },
    {
      "indent": 3,
      "text": "In this case, simply also capturing the qr-sig-flags will provide enough information to perform a minimal traffic reconstruction (assuming that suitable defaults for the remaining fields are provided). Additionally, capturing response-delay, query-opcode, and response-rcode will avoid having to rely on potentially misleading defaults for these values and should result in a PCAP that represents the basics of the real traffic flow.",
      "ja": "この場合、qr-sig-flagsをキャプチャするだけで、最小限のトラフィックの再構築を実行するのに十分な情報が提供されます（残りのフィールドに適切なデフォルトが提供されると仮定）。 さらに、response-delay、query-opcode、およびresponse-rcodeをキャプチャすると、これらの値を誤解を招く可能性のあるデフォルトに依存する必要がなくなり、実際のトラフィックフローの基本を表すPCAPが得られます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank CZ.NIC -- in particular, Tomas Gavenciak -- for many useful discussions on binary formats, compression, and packet matching. Thanks also to Jan Vcelak and Wouter Wijngaards for discussions on name compression, and Paul Hoffman for a detailed review of this document and the C-DNS CDDL.",
      "ja": "著者は、バイナリ形式、圧縮、およびパケットマッチングに関する多くの有益な議論について、CZ.NIC、特にTomas Gavenciakに感謝します。 また、名前の圧縮に関する議論をしてくれたJan VcelakとWouter Wijngaards、そしてこのドキュメントとC-DNS CDDLの詳細なレビューをしてくれたPaul Hoffmanにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks also to Robert Edmonds, Jerry Lundstrom, Richard Gibson, Stephane Bortzmeyer, and many other members of DNSOP for review.",
      "ja": "また、レビューのためにRobert Edmonds、Jerry Lundstrom、Richard Gibson、Stephane Bortzmeyer、およびDNSOPの他の多くのメンバーに感謝します。"
    },
    {
      "indent": 3,
      "text": "Also, thanks to Miek Gieben for [mmark].",
      "ja": "また、[mmark]のMiek Giebenに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "John Dickinson Sinodun IT Magdalen Centre Oxford Science Park Oxford OX4 4GA United Kingdom Email: jad@sinodun.com",
      "ja": "John Dickinson Sinodun ITマグダレンセンターオックスフォードサイエンスパークオックスフォードOX4 4GAイギリスメール：jad@sinodun.com"
    },
    {
      "indent": 3,
      "text": "Jim Hague Sinodun IT Magdalen Centre Oxford Science Park Oxford OX4 4GA United Kingdom Email: jim@sinodun.com",
      "ja": "ジムハーグシノダンITマグダレンセンターオックスフォードサイエンスパークオックスフォードOX4 4GAイギリスメール：jim@sinodun.com"
    },
    {
      "indent": 3,
      "text": "Sara Dickinson Sinodun IT Magdalen Centre Oxford Science Park Oxford OX4 4GA United Kingdom Email: sara@sinodun.com",
      "ja": "サラディキンソンシノダンITマグダレンセンターオックスフォードサイエンスパークオックスフォードOX4 4GAイギリスメール：sara@sinodun.com"
    },
    {
      "indent": 3,
      "text": "Terry Manderson ICANN 12025 Waterfront Drive Suite 300 Los Angeles, CA 90094-2536 United States of America Email: terry.manderson@icann.org",
      "ja": "Terry Manderson ICANN 12025 Waterfront Drive Suite 300 Los Angeles、CA 90094-2536アメリカ合衆国メール：terry.manderson@icann.org"
    },
    {
      "indent": 3,
      "text": "John Bond Wikimedia Foundation, Inc. 1 Montgomery Street Suite 1600 San Francisco, CA 94104 United States of America Email: ietf-wikimedia@johnbond.org",
      "ja": "John Bond Wikimedia Foundation、Inc. 1 Montgomery Street Suite 1600 San Francisco、CA 94104アメリカ合衆国Eメール：ietf-wikimedia@johnbond.org"
    }
  ]
}