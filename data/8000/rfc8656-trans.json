{
  "title": {
    "text": "RFC 8656 - Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)",
    "ja": "RFC 8656 - NATの周りのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティ（STUN）へのリレー拡張"
  },
  "number": 8656,
  "created_at": "2020-03-09 20:55:59.688788+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     T. Reddy, Ed.\nRequest for Comments: 8656                                        McAfee\nObsoletes: 5766, 6156                                   A. Johnston, Ed.\nCategory: Standards Track                           Villanova University\nISSN: 2070-1721                                              P. Matthews\n                                                          Alcatel-Lucent\n                                                            J. Rosenberg\n                                                             jdrosen.net\n                                                           February 2020",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)",
      "ja": "NATの周りのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティ（STUN）へのリレー拡張"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "If a host is located behind a NAT, it can be impossible for that host to communicate directly with other hosts (peers) in certain situations. In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay. This specification defines a protocol, called \"Traversal Using Relays around NAT\" (TURN), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay. TURN differs from other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address.",
      "ja": "ホストがNATの背後にある場合、特定の状況でそのホストが他のホスト（ピア）と直接通信することは不可能です。 これらの状況では、ホストが通信リレーとして機能する中間ノードのサービスを使用する必要があります。 この仕様は、ホストがリレーの動作を制御し、リレーを使用してピアとパケットを交換できるようにする「Traversal Using Relays around NATs」（TURN）と呼ばれるプロトコルを定義しています。 TURNは、クライアントが単一のリレーアドレスを使用して複数のピアと通信できるという点で、他のリレー制御プロトコルとは異なります。"
    },
    {
      "indent": 3,
      "text": "The TURN protocol was designed to be used as part of the Interactive Connectivity Establishment (ICE) approach to NAT traversal, though it can also be used without ICE.",
      "ja": "TURNプロトコルは、NATトラバーサルに対する対話型接続確立（ICE）アプローチの一部として使用されるように設計されましたが、ICEなしでも使用できます。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFCs 5766 and 6156.",
      "ja": "このドキュメントはRFC 5766および6156を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8656.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8656で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 2. Terminology 3. Overview of Operation 3.1. Transports 3.2. Allocations 3.3. Permissions 3.4. Send Mechanism 3.5. Channels 3.6. Unprivileged TURN Servers 3.7. Avoiding IP Fragmentation 3.8. RTP Support 3.9. Happy Eyeballs for TURN 4. Discovery of TURN Server 4.1. TURN URI Scheme Semantics 5. General Behavior 6. Allocations 7. Creating an Allocation 7.1. Sending an Allocate Request 7.2. Receiving an Allocate Request 7.3. Receiving an Allocate Success Response 7.4. Receiving an Allocate Error Response 8. Refreshing an Allocation 8.1. Sending a Refresh Request 8.2. Receiving a Refresh Request 8.3. Receiving a Refresh Response 9. Permissions 10. CreatePermission 10.1. Forming a CreatePermission Request 10.2. Receiving a CreatePermission Request 10.3. Receiving a CreatePermission Response 11. Send and Data Methods 11.1. Forming a Send Indication 11.2. Receiving a Send Indication 11.3. Receiving a UDP Datagram 11.4. Receiving a Data Indication 11.5. Receiving an ICMP Packet 11.6. Receiving a Data Indication with an ICMP Attribute 12. Channels 12.1. Sending a ChannelBind Request 12.2. Receiving a ChannelBind Request 12.3. Receiving a ChannelBind Response 12.4. The ChannelData Message 12.5. Sending a ChannelData Message 12.6. Receiving a ChannelData Message 12.7. Relaying Data from the Peer 13. Packet Translations 13.1. IPv4-to-IPv6 Translations 13.2. IPv6-to-IPv6 Translations 13.3. IPv6-to-IPv4 Translations 14. UDP-to-UDP Relay 15. TCP-to-UDP Relay 16. UDP-to-TCP Relay 17. STUN Methods 18. STUN Attributes 18.1. CHANNEL-NUMBER 18.2. LIFETIME 18.3. XOR-PEER-ADDRESS 18.4. DATA 18.5. XOR-RELAYED-ADDRESS 18.6. REQUESTED-ADDRESS-FAMILY 18.7. EVEN-PORT 18.8. REQUESTED-TRANSPORT 18.9. DONT-FRAGMENT 18.10. RESERVATION-TOKEN 18.11. ADDITIONAL-ADDRESS-FAMILY 18.12. ADDRESS-ERROR-CODE 18.13. ICMP 19. STUN Error Response Codes 20. Detailed Example 21. Security Considerations 21.1. Outsider Attacks 21.1.1. Obtaining Unauthorized Allocations 21.1.2. Offline Dictionary Attacks 21.1.3. Faked Refreshes and Permissions 21.1.4. Fake Data 21.1.5. Impersonating a Server 21.1.6. Eavesdropping Traffic 21.1.7. TURN Loop Attack 21.2. Firewall Considerations 21.2.1. Faked Permissions 21.2.2. Blacklisted IP Addresses 21.2.3. Running Servers on Well-Known Ports 21.3. Insider Attacks 21.3.1. DoS against TURN Server 21.3.2. Anonymous Relaying of Malicious Traffic 21.3.3. Manipulating Other Allocations 21.4. Tunnel Amplification Attack 21.5. Other Considerations 22. IANA Considerations 23. IAB Considerations 24. Changes since RFC 5766 25. Updates to RFC 6156 26. References 26.1. Normative References 26.2. Informative References Acknowledgements Authors' Addresses",
      "ja": "1. はじめに2.用語3.操作の概要3.1。トランスポート3.2。割り当て3.3。パーミッション3.4。送信メカニズム3.5。チャンネル3.6。非特権TURNサーバー3.7。 IPフラグメンテーションの回避3.8。 RTPサポート3.9。 TURN 4のハッピーアイボール4. TURN Serverの発見4.1。 TURN URIスキームのセマンティクス5.一般的な動作6.割り当て7.割り当ての作成7.1。割り当て要求の送信7.2。割り当て要求の受信7.3。割り当て成功応答の受信7.4。割り当てエラー応答の受信8.割り当ての更新8.1。更新要求の送信8.2。更新リクエストの受信8.3。更新応答の受信9.パーミッション10. CreatePermission 10.1。 CreatePermissionリクエストの作成10.2。 CreatePermissionリクエストの受信10.3。 CreatePermission応答の受信11.送信およびデータメソッド11.1送信指示の作成11.2。送信指示の受信11.3。 UDPデータグラムの受信11.4データ表示の受信11.5。 ICMPパケットの受信11.6。 ICMP属性を持つデータ表示の受信12.チャネル12.1。 ChannelBindリクエストの送信12.2。 ChannelBind要求の受信12.3。 ChannelBind応答の受信12.4。 ChannelDataメッセージ12.5。 ChannelDataメッセージの送信12.6。 ChannelDataメッセージの受信12.7。ピアからのデータの中継13.パケット変換13.1。 IPv4-to-IPv6変換13.2。 IPv6-to-IPv6変換13.3。 IPv6-to-IPv4変換14. UDP-to-UDPリレー15. TCP-to-UDPリレー16. UDP-to-TCPリレー17. STUNメソッド18. STUN属性18.1。チャンネル番号18.2。ライフタイム18.3。 XOR-PEER-ADDRESS 18.4。データ18.5 XOR-RELAY-ADDRESS 18.6。要求されたアドレス-ファミリー18.7。偶数ポート18.8要求されたトランスポート18.9。 DONT-FRAGMENT 18.10。予約トークン18.11。追加住所家族18.12。アドレスエラーコード18.13。 ICMP 19. STUNエラー応答コード20.詳細な例21.セキュリティに関する考慮事項21.1。部外者の攻撃21.1.1。不正な割り当ての取得21.1.2。オフライン辞書攻撃21.1.3。偽造リフレッシュと権限21.1.4。偽データ21.1.5。サーバーの偽装21.1.6。盗聴トラフィック21.1.7。 TURNループ攻撃21.2。ファイアウォールに関する考慮事項21.2.1。偽造許可21.2.2。ブラックリストに登録されたIPアドレス21.2.3。既知のポートでのサーバーの実行21.3。インサイダー攻撃21.3.1。 TURN Server 21.3.2に対するDoS。悪意のあるトラフィックの匿名中継21.3.3。他の割り当ての操作21.4。トンネル増幅攻撃21.5。その他の考慮事項22. IANAの考慮事項23. IABの考慮事項24. RFC 5766以降の変更25. RFC 6156の更新26.参照26.1。規範的参考文献26.2。参考情報謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A host behind a NAT may wish to exchange packets with other hosts, some of which may also be behind NATs. To do this, the hosts involved can use \"hole punching\" techniques (see [RFC5128]) in an attempt to discover a direct communication path; that is, a communication path that goes from one host to another through intervening NATs and routers but does not traverse any relays.",
      "ja": "NATの背後にあるホストは、他のホストとパケットを交換したい場合があり、その一部はNATの背後にある場合もあります。 これを行うために、関与するホストは、直接通信パスを発見しようとして「ホールパンチ」技術（[RFC5128]を参照）を使用できます。 つまり、あるホストから別のホストに、NATとルーターを介して通過するが、リレーを通過しない通信パス。"
    },
    {
      "indent": 3,
      "text": "As described in [RFC5128] and [RFC4787], hole punching techniques will fail if both hosts are behind NATs that are not well behaved. For example, if both hosts are behind NATs that have a mapping behavior of \"address-dependent mapping\" or \"address- and port-dependent mapping\" (see Section 4.1 of [RFC4787]), then hole punching techniques generally fail.",
      "ja": "[RFC5128]および[RFC4787]で説明されているように、両方のホストが適切に動作しないNATの背後にある場合、ホールパンチ技術は失敗します。 たとえば、両方のホストが「アドレス依存マッピング」または「アドレスおよびポート依存マッピング」（[RFC4787]のセクション4.1を参照）のマッピング動作を持つNATの背後にある場合、一般にホールパンチ技術は失敗します。"
    },
    {
      "indent": 3,
      "text": "When a direct communication path cannot be found, it is necessary to use the services of an intermediate host that acts as a relay for the packets. This relay typically sits in the public Internet and relays packets between two hosts that both sit behind NATs.",
      "ja": "直接通信パスが見つからない場合、パケットのリレーとして機能する中間ホストのサービスを使用する必要があります。 通常、このリレーはパブリックインターネットに配置され、両方がNATの背後にある2つのホスト間でパケットを中継します。"
    },
    {
      "indent": 3,
      "text": "In many enterprise networks, direct UDP transmissions are not permitted between clients on the internal networks and external IP addresses. To permit media sessions in such a situation to use UDP and avoid forcing them through TCP, an Enterprise Firewall can be configured to allow UDP traffic relayed through an Enterprise relay server. WebRTC requires support for this scenario (see Section 2.3.5.1 of [RFC7478]). Some users of SIP or WebRTC want IP location privacy from the remote peer. In this scenario, the client can select a relay server offering IP location privacy and only convey the relayed candidates to the peer for ICE connectivity checks (see Section 4.2.4 of [SEC-WEBRTC]).",
      "ja": "多くの企業ネットワークでは、内部ネットワーク上のクライアントと外部IPアドレス間の直接UDP送信は許可されていません。 このような状況のメディアセッションでUDPの使用を許可し、TCPを強制的に通過させないようにするには、エンタープライズファイアウォールを設定して、UDPトラフィックがエンタープライズリレーサーバーを介してリレーされるようにします。 WebRTCでは、このシナリオのサポートが必要です（[RFC7478]のセクション2.3.5.1を参照）。 SIPまたはWebRTCの一部のユーザーは、リモートピアからのIPロケーションプライバシーを求めています。 このシナリオでは、クライアントは、IPロケーションプライバシを提供するリレーサーバーを選択し、リレーされた候補のみをICE接続性チェックのピアに伝えることができます（[SEC-WEBRTC]のセクション4.2.4を参照）。"
    },
    {
      "indent": 3,
      "text": "This specification defines a protocol, called \"TURN\", that allows a host behind a NAT (called the \"TURN client\") to request that another host (called the \"TURN server\") act as a relay. The client can arrange for the server to relay packets to and from certain other hosts (called \"peers\"), and the client can control aspects of how the relaying is done. The client does this by obtaining an IP address and port on the server, called the \"relayed transport address\". When a peer sends a packet to the relayed transport address, the server relays the transport protocol data from the packet to the client. The data encapsulated within a message header that allows the client to know the peer from which the transport protocol data was relayed by the server. If the server receives an ICMP error packet, the server also relays certain Layer 3 and 4 header fields from the ICMP header to the client. When the client sends a message to the server, the server identifies the remote peer from the message header and relays the message data to the intended peer.",
      "ja": "この仕様は、「TURN」と呼ばれるプロトコルを定義します。これにより、NATの背後にあるホスト（「TURNクライアント」と呼ばれる）が別のホスト（「TURNサーバー」と呼ばれる）がリレーとして動作するように要求できます。クライアントは、サーバーが他の特定のホスト（「ピア」と呼ばれる）との間でパケットを中継するように手配でき、クライアントは中継の実行方法の側面を制御できます。クライアントは、「中継されたトランスポートアドレス」と呼ばれるサーバー上のIPアドレスとポートを取得することでこれを行います。ピアが中継されたトランスポートアドレスにパケットを送信すると、サーバーはパケットからクライアントにトランスポートプロトコルデータを中継します。クライアントがトランスポートプロトコルデータがサーバーによって中継されたピアを知ることができるメッセージヘッダー内にカプセル化されたデータ。サーバーがICMPエラーパケットを受信した場合、サーバーはICMPヘッダーからクライアントに特定のレイヤー3および4ヘッダーフィールドも中継します。クライアントがサーバーにメッセージを送信すると、サーバーはメッセージヘッダーからリモートピアを識別し、メッセージデータを目的のピアに中継します。"
    },
    {
      "indent": 3,
      "text": "A client using TURN must have some way to communicate the relayed transport address to its peers and to learn each peer's IP address and port (more precisely, each peer's server-reflexive transport address; see Section 3). How this is done is out of the scope of the TURN protocol. One way this might be done is for the client and peers to exchange email messages. Another way is for the client and its peers to use a special-purpose \"introduction\" or \"rendezvous\" protocol (see [RFC5128] for more details).",
      "ja": "TURNを使用するクライアントは、リレーされたトランスポートアドレスをピアに通信し、各ピアのIPアドレスとポート（より正確には、各ピアのサーバー反射トランスポートアドレス。セクション3を参照）を学習する方法が必要です。 これを行う方法は、TURNプロトコルの範囲外です。 これを行う1つの方法は、クライアントとピアが電子メールメッセージを交換することです。 別の方法は、クライアントとそのピアが特別な目的の「導入」または「ランデブー」プロトコルを使用することです（詳細については[RFC5128]を参照）。"
    },
    {
      "indent": 3,
      "text": "If TURN is used with ICE [RFC8445], then the relayed transport address and the IP addresses and ports of the peers are included in the ICE candidate information that the rendezvous protocol must carry. For example, if TURN and ICE are used as part of a multimedia solution using SIP [RFC3261], then SIP serves the role of the rendezvous protocol, carrying the ICE candidate information inside the body of SIP messages [SDP-ICE]. If TURN and ICE are used with some other rendezvous protocol, then ICE provides guidance on the services the rendezvous protocol must perform.",
      "ja": "TURNがICE [RFC8445]で使用される場合、中継されたトランスポートアドレスとピアのIPアドレスとポートは、ランデブープロトコルが伝送する必要があるICE候補情報に含まれます。 たとえば、TURNとICEがSIP [RFC3261]を使用するマルチメディアソリューションの一部として使用される場合、SIPはランデブープロトコルの役割を果たし、SIPメッセージの本体内でICE候補情報を伝達します[SDP-ICE]。 TURNおよびICEが他のランデブープロトコルで使用される場合、ICEはランデブープロトコルが実行する必要があるサービスに関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Though the use of a TURN server to enable communication between two hosts behind NATs is very likely to work, it comes at a high cost to the provider of the TURN server since the server typically needs a high-bandwidth connection to the Internet. As a consequence, it is best to use a TURN server only when a direct communication path cannot be found. When the client and a peer use ICE to determine the communication path, ICE will use hole punching techniques to search for a direct path first and only use a TURN server when a direct path cannot be found.",
      "ja": "NATの背後にある2つのホスト間の通信を可能にするTURNサーバーの使用は機能する可能性が非常に高いですが、サーバーは通常インターネットへの高帯域幅接続を必要とするため、TURNサーバーのプロバイダーにとっては高コストになります。 結果として、直接通信パスが見つからない場合にのみTURNサーバーを使用するのが最善です。 クライアントとピアがICEを使用して通信パスを決定する場合、ICEはホールパンチ技術を使用して最初に直接パスを検索し、直接パスが見つからない場合にのみTURNサーバーを使用します。"
    },
    {
      "indent": 3,
      "text": "TURN was originally invented to support multimedia sessions signaled using SIP. Since SIP supports forking, TURN supports multiple peers per relayed transport address; a feature not supported by other approaches (e.g., SOCKS [RFC1928]). However, care has been taken to make sure that TURN is suitable for other types of applications.",
      "ja": "TURNはもともと、SIPを使用してシグナリングされるマルチメディアセッションをサポートするために発明されました。 SIPは分岐をサポートしているため、TURNはリレーされたトランスポートアドレスごとに複数のピアをサポートします。 他のアプローチではサポートされていない機能（例：SOCKS [RFC1928]）。 ただし、TURNが他のタイプのアプリケーションに適していることを確認するように注意が払われています。"
    },
    {
      "indent": 3,
      "text": "TURN was designed as one piece in the larger ICE approach to NAT traversal. Implementors of TURN are urged to investigate ICE and seriously consider using it for their application. However, it is possible to use TURN without ICE.",
      "ja": "TURNは、NATトラバーサルに対するより大きなICEアプローチの一部として設計されました。 TURNの実装者は、ICEを調査し、アプリケーションでの使用を真剣に検討することをお勧めします。 ただし、ICEなしでTURNを使用することは可能です。"
    },
    {
      "indent": 3,
      "text": "TURN is an extension to the Session Traversal Utilities for NAT (STUN) protocol [RFC8489]. Most, though not all, TURN messages are STUN-formatted messages. A reader of this document should be familiar with STUN.",
      "ja": "TURNは、NAT（STUN）プロトコルのセッショントラバーサルユーティリティ[RFC8489]の拡張です。 すべてではありませんが、ほとんどのTURNメッセージはSTUN形式のメッセージです。 このドキュメントの読者は、STUNに精通している必要があります。"
    },
    {
      "indent": 3,
      "text": "The TURN specification was originally published as [RFC5766], which was updated by [RFC6156] to add IPv6 support. This document supersedes and obsoletes both [RFC5766] and [RFC6156].",
      "ja": "TURN仕様は元々[RFC5766]として公開され、[RFC6156]によってIPv6サポートを追加するために更新されました。 このドキュメントは、[RFC5766]と[RFC6156]の両方に取って代わります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "Readers are expected to be familiar with [RFC8489] and the terms defined there.",
      "ja": "読者は[RFC8489]とそこで定義されている用語に精通していることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The following terms are used in this document:",
      "ja": "このドキュメントでは、次の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "TURN: The protocol spoken between a TURN client and a TURN server. It is an extension to the STUN protocol [RFC8489]. The protocol allows a client to allocate and use a relayed transport address.",
      "ja": "TURN：TURNクライアントとTURNサーバーの間で話されるプロトコル。 これは、STUNプロトコル[RFC8489]の拡張です。 このプロトコルにより、クライアントは中継されたトランスポートアドレスを割り当てて使用できます。"
    },
    {
      "indent": 3,
      "text": "TURN client: A STUN client that implements this specification.",
      "ja": "TURNクライアント：この仕様を実装するSTUNクライアント。"
    },
    {
      "indent": 3,
      "text": "TURN server: A STUN server that implements this specification. It relays data between a TURN client and its peer(s).",
      "ja": "TURNサーバー：この仕様を実装するSTUNサーバー。 TURNクライアントとそのピアとの間でデータを中継します。"
    },
    {
      "indent": 3,
      "text": "Peer: A host with which the TURN client wishes to communicate. The TURN server relays traffic between the TURN client and its peer(s). The peer does not interact with the TURN server using the protocol defined in this document; rather, the peer receives data sent by the TURN server, and the peer sends data towards the TURN server.",
      "ja": "ピア：TURNクライアントが通信したいホスト。 TURNサーバーは、TURNクライアントとそのピアとの間のトラフィックを中継します。 ピアは、このドキュメントで定義されているプロトコルを使用してTURNサーバーと対話しません。 むしろ、ピアはTURNサーバーから送信されたデータを受信し、ピアはTURNサーバーにデータを送信します。"
    },
    {
      "indent": 3,
      "text": "Transport Address: The combination of an IP address and a port.",
      "ja": "トランスポートアドレス：IPアドレスとポートの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Host Transport Address: A transport address on a client or a peer.",
      "ja": "ホストトランスポートアドレス：クライアントまたはピアのトランスポートアドレス。"
    },
    {
      "indent": 3,
      "text": "Server-Reflexive Transport Address: A transport address on the \"external side\" of a NAT. This address is allocated by the NAT to correspond to a specific host transport address.",
      "ja": "サーバー反射トランスポートアドレス：NATの「外部側」のトランスポートアドレス。 このアドレスは、特定のホストトランスポートアドレスに対応するためにNATによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Relayed Transport Address: A transport address on the TURN server that is used for relaying packets between the client and a peer. A peer sends to this address on the TURN server, and the packet is then relayed to the client.",
      "ja": "リレーされたトランスポートアドレス：クライアントとピア間のパケットのリレーに使用されるTURNサーバーのトランスポートアドレス。 ピアがTURNサーバーのこのアドレスに送信すると、パケットはクライアントに中継されます。"
    },
    {
      "indent": 3,
      "text": "TURN Server Transport Address: A transport address on the TURN server that is used for sending TURN messages to the server. This is the transport address that the client uses to communicate with the server.",
      "ja": "TURN Serverのトランスポートアドレス：TURNサーバーにTURNメッセージを送信するために使用されるTURNサーバーのトランスポートアドレス。 これは、クライアントがサーバーとの通信に使用するトランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "Peer Transport Address: The transport address of the peer as seen by the server. When the peer is behind a NAT, this is the peer's server-reflexive transport address.",
      "ja": "ピアトランスポートアドレス：サーバーから見たピアのトランスポートアドレス。 ピアがNATの背後にある場合、これはピアのサーバー反射トランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "Allocation: The relayed transport address granted to a client through an Allocate request, along with related state, such as permissions and expiration timers.",
      "ja": "割り当て：割り当て要求を介してクライアントに許可された中継されたトランスポートアドレスと、アクセス許可や有効期限タイマーなどの関連状態。"
    },
    {
      "indent": 3,
      "text": "5-tuple: The combination (client IP address and port, server IP address and port, and transport protocol (currently one of UDP, TCP, DTLS/UDP, or TLS/TCP)) used to communicate between the client and the server. The 5-tuple uniquely identifies this communication stream. The 5-tuple also uniquely identifies the Allocation on the server.",
      "ja": "5タプル：クライアントとサーバー間の通信に使用される組み合わせ（クライアントIPアドレスとポート、サーバーIPアドレスとポート、およびトランスポートプロトコル（現在はUDP、TCP、DTLS / UDP、またはTLS / TCPのいずれか））。 5タプルは、この通信ストリームを一意に識別します。 5タプルは、サーバー上の割り当ても一意に識別します。"
    },
    {
      "indent": 3,
      "text": "Transport Protocol: The protocol above IP that carries TURN Requests, Responses, and Indications as well as providing identifiable flows using a 5-tuple. In this specification, UDP and TCP are defined as transport protocols; this document also describes the use of UDP and TCP in combination with a security layer using DTLS and TLS, respectively.",
      "ja": "トランスポートプロトコル：TURN要求、応答、および指示を伝送し、5タプルを使用して識別可能なフローを提供する、IP上のプロトコル。 この仕様では、UDPおよびTCPはトランスポートプロトコルとして定義されています。 このドキュメントは、それぞれDTLSとTLSを使用するセキュリティレイヤーと組み合わせたUDPとTCPの使用についても説明しています。"
    },
    {
      "indent": 3,
      "text": "Channel: A channel number and associated peer transport address. Once a channel number is bound to a peer's transport address, the client and server can use the more bandwidth-efficient ChannelData message to exchange data.",
      "ja": "チャネル：チャネル番号と関連するピアトランスポートアドレス。 チャネル番号がピアのトランスポートアドレスにバインドされると、クライアントとサーバーは帯域幅効率の高いChannelDataメッセージを使用してデータを交換できます。"
    },
    {
      "indent": 3,
      "text": "Permission: The IP address and transport protocol (but not the port) of a peer that is permitted to send traffic to the TURN server and have that traffic relayed to the TURN client. The TURN server will only forward traffic to its client from peers that match an existing permission.",
      "ja": "許可：トラフィックをTURNサーバーに送信し、そのトラフィックをTURNクライアントに中継することを許可されているピアのIPアドレスとトランスポートプロトコル（ポートではありません）。 TURNサーバーは、既存の許可に一致するピアからのみクライアントにトラフィックを転送します。"
    },
    {
      "indent": 3,
      "text": "Realm: A string used to describe the server or a context within the server. The realm tells the client which username and password combination to use to authenticate requests.",
      "ja": "レルム：サーバーまたはサーバー内のコンテキストを記述するために使用される文字列。 レルムは、リクエストの認証に使用するユーザー名とパスワードの組み合わせをクライアントに伝えます。"
    },
    {
      "indent": 3,
      "text": "Nonce: A string chosen at random by the server and included in the server response. To prevent replay attacks, the server should change the nonce regularly.",
      "ja": "Nonce：サーバーによってランダムに選択され、サーバー応答に含まれる文字列。 リプレイ攻撃を防ぐために、サーバーはナンスを定期的に変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "(D)TLS: This term is used for statements that apply to both Transport Layer Security [RFC8446] and Datagram Transport Layer Security [RFC6347].",
      "ja": "（D）TLS：この用語は、トランスポート層セキュリティ[RFC8446]とデータグラムトランスポート層セキュリティ[RFC6347]の両方に適用されるステートメントに使用されます。"
    },
    {
      "indent": 0,
      "text": "3. Overview of Operation",
      "section_title": true,
      "ja": "3. 操作の概要"
    },
    {
      "indent": 3,
      "text": "This section gives an overview of the operation of TURN. It is non-normative.",
      "ja": "このセクションでは、TURNの操作の概要を説明します。 非規範的です。"
    },
    {
      "indent": 3,
      "text": "In a typical configuration, a TURN client is connected to a private network [RFC1918] and, through one or more NATs, to the public Internet. On the public Internet is a TURN server. Elsewhere in the Internet are one or more peers with which the TURN client wishes to communicate. These peers may or may not be behind one or more NATs. The client uses the server as a relay to send packets to these peers and to receive packets from these peers.",
      "ja": "一般的な構成では、TURNクライアントはプライベートネットワーク[RFC1918]に接続され、1つ以上のNATを介してパブリックインターネットに接続されます。 公共のインターネットにはTURNサーバーがあります。 インターネットの他の場所には、TURNクライアントが通信を希望する1つ以上のピアがあります。 これらのピアは、1つ以上のNATの背後にある場合とない場合があります。 クライアントはサーバーをリレーとして使用して、これらのピアにパケットを送信し、これらのピアからパケットを受信します。"
    },
    {
      "indent": 3,
      "text": "                                    Peer A\n                                    Server-Reflexive    +---------+\n                                    Transport Address   |         |\n                                    192.0.2.150:32102   |         |\n                                        |              /|         |\n                      TURN              |            / ^|  Peer A |\n   Client's           Server            |           /  ||         |\n   Host Transport     Transport         |         //   ||         |\n   Address            Address           |       //     |+---------+\n198.51.100.2:49721  192.0.2.15:3478     |+-+  //     Peer A\n           |            |               ||N| /       Host Transport\n           |   +-+      |               ||A|/        Address\n           |   | |      |               v|T|     203.0.113.2:49582\n           |   | |      |               /+-+\n+---------+|   | |      |+---------+   /              +---------+\n|         ||   |N|      ||         | //               |         |\n| TURN    |v   | |      v| TURN    |/                 |         |\n| Client  |----|A|-------| Server  |------------------|  Peer B |\n|         |    | |^      |         |^                ^|         |\n|         |    |T||      |         ||                ||         |\n+---------+    | ||      +---------+|                |+---------+\n               | ||                 |                |\n               | ||                 |                |\n               +-+|                 |                |\n                  |                 |                |\n                  |                 |                |\n         Client's                   |             Peer B\n         Server-Reflexive     Relayed             Transport\n         Transport Address    Transport Address   Address\n         192.0.2.1:7000       192.0.2.15:50000    192.0.2.210:49191",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a typical deployment. In this figure, the TURN client and the TURN server are separated by a NAT, with the client on the private side and the server on the public side of the NAT. This NAT is assumed to be a \"bad\" NAT; for example, it might have a mapping property of \"address-and-port-dependent mapping\" (see [RFC4787]).",
      "ja": "図1は、典型的な展開を示しています。 この図では、TURNクライアントとTURNサーバーはNATによって分離されており、クライアントはプライベート側にあり、サーバーはNATのパブリック側にあります。 このNATは、「不良」NATと見なされます。 たとえば、「アドレスとポートに依存するマッピング」のマッピングプロパティを持つ場合があります（[RFC4787]を参照）。"
    },
    {
      "indent": 3,
      "text": "The client talks to the server from a (IP address, port) combination called the client's \"host transport address\". (The combination of an IP address and port is called a \"transport address\".)",
      "ja": "クライアントは、クライアントの「ホストトランスポートアドレス」と呼ばれる（IPアドレス、ポート）の組み合わせからサーバーと通信します。 （IPアドレスとポートの組み合わせは、「トランスポートアドレス」と呼ばれます。）"
    },
    {
      "indent": 3,
      "text": "The client sends TURN messages from its host transport address to a transport address on the TURN server that is known as the \"TURN server transport address\". The client learns the TURN server transport address through some unspecified means (e.g., configuration), and this address is typically used by many clients simultaneously.",
      "ja": "クライアントは、TURNメッセージをホストトランスポートアドレスから、TURNサーバー上の「TURNサーバートランスポートアドレス」と呼ばれるトランスポートアドレスに送信します。 クライアントは、不特定の手段（構成など）でTURNサーバーのトランスポートアドレスを学習します。このアドレスは通常、多くのクライアントが同時に使用します。"
    },
    {
      "indent": 3,
      "text": "Since the client is behind a NAT, the server sees packets from the client as coming from a transport address on the NAT itself. This address is known as the client's \"server-reflexive transport address\"; packets sent by the server to the client's server-reflexive transport address will be forwarded by the NAT to the client's host transport address.",
      "ja": "クライアントはNATの背後にあるため、サーバーはクライアントからのパケットをNAT自体のトランスポートアドレスから送信されるものと見なします。 このアドレスは、クライアントの「サーバー再帰トランスポートアドレス」と呼ばれます。 サーバーによってクライアントのサーバー再帰トランスポートアドレスに送信されたパケットは、NATによってクライアントのホストトランスポートアドレスに転送されます。"
    },
    {
      "indent": 3,
      "text": "The client uses TURN commands to create and manipulate an ALLOCATION on the server. An allocation is a data structure on the server. This data structure contains, amongst other things, the relayed transport address for the allocation. The relayed transport address is the transport address on the server that peers can use to have the server relay data to the client. An allocation is uniquely identified by its relayed transport address.",
      "ja": "クライアントは、TURNコマンドを使用して、サーバー上でALLOCATIONを作成および操作します。 割り当ては、サーバー上のデータ構造です。 このデータ構造には、とりわけ、割り当てのための中継されたトランスポートアドレスが含まれます。 リレーされたトランスポートアドレスは、サーバーがクライアントにデータをリレーするためにピアが使用できるサーバー上のトランスポートアドレスです。 割り当ては、中継されたトランスポートアドレスによって一意に識別されます。"
    },
    {
      "indent": 3,
      "text": "Once an allocation is created, the client can send application data to the server along with an indication of to which peer the data is to be sent, and the server will relay this data to the intended peer. The client sends the application data to the server inside a TURN message; at the server, the data is extracted from the TURN message and sent to the peer in a UDP datagram. In the reverse direction, a peer can send application data in a UDP datagram to the relayed transport address for the allocation; the server will then encapsulate this data inside a TURN message and send it to the client along with an indication of which peer sent the data. Since the TURN message always contains an indication of which peer the client is communicating with, the client can use a single allocation to communicate with multiple peers.",
      "ja": "割り当てが作成されると、クライアントはアプリケーションデータをサーバーに送信し、どのピアにデータを送信するかを指定できます。サーバーはこのデータを目的のピアに中継します。 クライアントは、TURNメッセージ内でアプリケーションデータをサーバーに送信します。 サーバーでは、TURNメッセージからデータが抽出され、UDPデータグラムでピアに送信されます。 逆方向では、ピアはアプリケーションデータをUDPデータグラムで、割り当てのために中継されたトランスポートアドレスに送信できます。 サーバーは、このデータをTURNメッセージ内にカプセル化し、データを送信したピアの指示とともにクライアントに送信します。 TURNメッセージには、クライアントが通信しているピアの指示が常に含まれているため、クライアントは単一の割り当てを使用して複数のピアと通信できます。"
    },
    {
      "indent": 3,
      "text": "When the peer is behind a NAT, the client must identify the peer using its server-reflexive transport address rather than its host transport address. For example, to send application data to Peer A in the example above, the client must specify 192.0.2.150:32102 (Peer A's server-reflexive transport address) rather than 203.0.113.2:49582 (Peer A's host transport address).",
      "ja": "ピアがNATの背後にある場合、クライアントはホストトランスポートアドレスではなくサーバー反射トランスポートアドレスを使用してピアを識別する必要があります。 たとえば、上記の例でアプリケーションデータをピアAに送信するには、クライアントは203.0.113.2:49582（ピアAのホストトランスポートアドレス）ではなく192.0.2.150:32102（ピアAのサーバー再帰トランスポートアドレス）を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each allocation on the server belongs to a single client and has either one or two relayed transport addresses that are used only by that allocation. Thus, when a packet arrives at a relayed transport address on the server, the server knows for which client the data is intended.",
      "ja": "サーバー上の各割り当ては単一のクライアントに属し、その割り当てでのみ使用される1つまたは2つの中継トランスポートアドレスを持ちます。 したがって、パケットがサーバー上の中継されたトランスポートアドレスに到着すると、サーバーはどのクライアントに対してデータが送信されるかを認識します。"
    },
    {
      "indent": 3,
      "text": "The client may have multiple allocations on a server at the same time.",
      "ja": "クライアントは、サーバー上で同時に複数の割り当てを持つことができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Transports",
      "section_title": true,
      "ja": "3.1. 輸送"
    },
    {
      "indent": 3,
      "text": "TURN, as defined in this specification, always uses UDP between the server and the peer. However, this specification allows the use of any one of UDP, TCP, Transport Layer Security (TLS) over TCP, or Datagram Transport Layer Security (DTLS) over UDP to carry the TURN messages between the client and the server.",
      "ja": "この仕様で定義されているTURNは、サーバーとピアの間で常にUDPを使用します。 ただし、この仕様では、UDP、TCP、TCP上のトランスポート層セキュリティ（TLS）、またはUDP上のデータグラムトランスポート層セキュリティ（DTLS）のいずれかを使用して、クライアントとサーバー間でTURNメッセージを伝送できます。"
    },
    {
      "indent": 11,
      "text": "+----------------------------+---------------------+\n| TURN client to TURN server | TURN server to peer |\n+============================+=====================+\n|            UDP             |         UDP         |\n+----------------------------+---------------------+\n|            TCP             |         UDP         |\n+----------------------------+---------------------+\n|        TLS-over-TCP        |         UDP         |\n+----------------------------+---------------------+\n|       DTLS-over-UDP        |         UDP         |\n+----------------------------+---------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "If TCP or TLS-over-TCP is used between the client and the server, then the server will convert between these transports and UDP transport when relaying data to/from the peer.",
      "ja": "TCPまたはTLS-over-TCPがクライアントとサーバー間で使用される場合、サーバーはピアとの間でデータを中継するときにこれらのトランスポートとUDPトランスポートを変換します。"
    },
    {
      "indent": 3,
      "text": "Since this version of TURN only supports UDP between the server and the peer, it is expected that most clients will prefer to use UDP between the client and the server as well. That being the case, some readers may wonder: Why also support TCP and TLS-over-TCP?",
      "ja": "このバージョンのTURNはサーバーとピア間のUDPのみをサポートするため、ほとんどのクライアントはクライアントとサーバー間でもUDPを使用することを好むことが予想されます。 その場合、読者の中には「TCPとTLS-over-TCPもサポートしているのはなぜですか？」"
    },
    {
      "indent": 3,
      "text": "TURN supports TCP transport between the client and the server because some firewalls are configured to block UDP entirely. These firewalls block UDP but not TCP, in part because TCP has properties that make the intention of the nodes being protected by the firewall more obvious to the firewall. For example, TCP has a three-way handshake that makes it clearer that the protected node really wishes to have that particular connection established, while for UDP, the best the firewall can do is guess which flows are desired by using filtering rules. Also, TCP has explicit connection teardown; while for UDP, the firewall has to use timers to guess when the flow is finished.",
      "ja": "一部のファイアウォールはUDPを完全にブロックするように構成されているため、TURNはクライアントとサーバー間のTCPトランスポートをサポートしています。 これらのファイアウォールは、UDPをブロックしますが、TCPはブロックしません。TCPには、ファイアウォールによって保護されているノードの意図をファイアウォールにとってより明確にするプロパティがあるためです。 たとえば、TCPには、保護されたノードが特定の接続を確立することを本当に望んでいることを明確にする3ウェイハンドシェイクがありますが、UDPの場合、ファイアウォールができる最善の方法は、フィルタリングルールを使用してどのフローが望ましいかを推測することです。 また、TCPには明示的な接続の切断があります。 一方、UDPの場合、ファイアウォールはタイマーを使用してフローの終了を推測する必要があります。"
    },
    {
      "indent": 3,
      "text": "TURN supports TLS-over-TCP transport and DTLS-over-UDP transport between the client and the server because (D)TLS provides additional security properties not provided by TURN's default digest authentication, properties that some clients may wish to take advantage of. In particular, (D)TLS provides a way for the client to ascertain that it is talking to the correct server and provides for confidentiality of TURN control messages. If (D)TLS transport is used between the TURN client and the TURN server, refer to Section 6.2.3 of [RFC8489] for more information about cipher suites, server certificate validation, and authentication of TURN servers. The guidance given in [RFC7525] MUST be followed to avoid attacks on (D)TLS. TURN does not require (D)TLS because the overhead of using (D)TLS is higher than that of digest authentication; for example, using (D)TLS likely means that most application data will be doubly encrypted (once by (D)TLS and once to ensure it is still encrypted in the UDP datagram).",
      "ja": "（D）TLSはTURNのデフォルトダイジェスト認証では提供されない追加のセキュリティプロパティ、一部のクライアントが利用したいプロパティを提供するため、TURNはクライアントとサーバー間のTLS-over-TCPトランスポートとDTLS-over-UDPトランスポートをサポートします。特に、（D）TLSは、クライアントが正しいサーバーと通信していることを確認する方法を提供し、TURN制御メッセージの機密性を提供します。 （D）TLSトランスポートがTURNクライアントとTURNサーバー間で使用される場合、暗号スイート、サーバー証明書の検証、TURNサーバーの認証の詳細については、[RFC8489]のセクション6.2.3を参照してください。 （D）TLSへの攻撃を避けるために、[RFC7525]で与えられたガイダンスに従わなければなりません。 （D）TLSを使用するオーバーヘッドはダイジェスト認証のオーバーヘッドよりも大きいため、TURNは（D）TLSを必要としません。たとえば、（D）TLSを使用することは、ほとんどのアプリケーションデータが二重に暗号化されることを意味します（（D）TLSによって1回、UDPデータグラムで暗号化されていることを確認するために一度）。"
    },
    {
      "indent": 3,
      "text": "There is an extension to TURN for TCP transport between the server and the peers [RFC6062]. For this reason, allocations that use UDP between the server and the peers are known as \"UDP allocations\", while allocations that use TCP between the server and the peers are known as \"TCP allocations\". This specification describes only UDP allocations.",
      "ja": "サーバーとピアの間のTCPトランスポートのためのTURNの拡張があります[RFC6062]。 このため、サーバーとピア間のUDPを使用する割り当ては「UDP割り当て」と呼ばれ、サーバーとピア間のTCPを使用する割り当ては「TCP割り当て」と呼ばれます。 この仕様では、UDP割り当てのみを説明しています。"
    },
    {
      "indent": 3,
      "text": "In some applications for TURN, the client may send and receive packets other than TURN packets on the host transport address it uses to communicate with the server. This can happen, for example, when using TURN with ICE. In these cases, the client can distinguish TURN packets from other packets by examining the source address of the arriving packet; those arriving from the TURN server will be TURN packets. The algorithm of demultiplexing packets received from multiple protocols on the host transport address is discussed in [RFC7983].",
      "ja": "TURNの一部のアプリケーションでは、クライアントは、サーバーとの通信に使用するホストトランスポートアドレスでTURNパケット以外のパケットを送受信する場合があります。 これは、たとえばTURNをICEで使用している場合に発生する可能性があります。 これらの場合、クライアントは到着パケットの送信元アドレスを調べることにより、TURNパケットを他のパケットと区別できます。 TURNサーバーから到着するのはTURNパケットです。 ホストトランスポートアドレス上の複数のプロトコルから受信したパケットを逆多重化するアルゴリズムは、[RFC7983]で説明されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Allocations",
      "section_title": true,
      "ja": "3.2. 割り当て"
    },
    {
      "indent": 3,
      "text": "To create an allocation on the server, the client uses an Allocate transaction. The client sends an Allocate request to the server, and the server replies with an Allocate success response containing the allocated relayed transport address. The client can include attributes in the Allocate request that describe the type of allocation it desires (e.g., the lifetime of the allocation). Since relaying data has security implications, the server requires that the client authenticate itself, typically using STUN's long-term credential mechanism or the STUN Extension for Third-Party Authorization [RFC7635], to show that it is authorized to use the server.",
      "ja": "サーバーで割り当てを作成するために、クライアントはAllocateトランザクションを使用します。 クライアントはAllocate要求をサーバーに送信し、サーバーは割り当てられた中継トランスポートアドレスを含むAllocate成功応答で応答します。 クライアントは、必要な割り当てのタイプ（割り当ての有効期間など）を記述する属性をAllocateリクエストに含めることができます。 データの中継にはセキュリティ上の意味があるため、サーバーは、クライアントがサーバーを使用する権限があることを示すために、通常、STUNの長期資格情報メカニズムまたは第三者認証用のSTUN拡張機能[RFC7635]を使用して、クライアント自身を認証することを要求します。"
    },
    {
      "indent": 3,
      "text": "Once a relayed transport address is allocated, a client must keep the allocation alive. To do this, the client periodically sends a Refresh request to the server. TURN deliberately uses a different method (Refresh rather than Allocate) for refreshes to ensure that the client is informed if the allocation vanishes for some reason.",
      "ja": "中継されたトランスポートアドレスが割り当てられると、クライアントは割り当てを維持する必要があります。 これを行うために、クライアントはサーバーに更新要求を定期的に送信します。 TURNは、何らかの理由で割り当てが消失した場合にクライアントに確実に通知されるように、リフレッシュに別の方法（割り当てではなくリフレッシュ）を意図的に使用します。"
    },
    {
      "indent": 3,
      "text": "The frequency of the Refresh transaction is determined by the lifetime of the allocation. The default lifetime of an allocation is 10 minutes; this value was chosen to be long enough so that refreshing is not typically a burden on the client while expiring allocations where the client has unexpectedly quit in a timely manner. However, the client can request a longer lifetime in the Allocate request and may modify its request in a Refresh request, and the server always indicates the actual lifetime in the response. The client must issue a new Refresh transaction within \"lifetime\" seconds of the previous Allocate or Refresh transaction. Once a client no longer wishes to use an allocation, it should delete the allocation using a Refresh request with a requested lifetime of zero.",
      "ja": "更新トランザクションの頻度は、割り当ての存続期間によって決まります。 割り当てのデフォルトの有効期間は10分です。 この値は、クライアントが予期せずにタイムリーに終了した割り当てを期限切れにしながら、通常は更新がクライアントの負担にならないように十分に長く選択されました。 ただし、クライアントはAllocateリクエストでより長いライフタイムをリクエストでき、Refreshリクエストでリクエストを変更できます。また、サーバーは常にレスポンスで実際のライフタイムを示します。 クライアントは、以前の割り当てまたは更新トランザクションの「ライフタイム」秒以内に新しい更新トランザクションを発行する必要があります。 クライアントが割り当てを使用したくない場合、要求された有効期間がゼロのRefresh要求を使用して割り当てを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Both the server and client keep track of a value known as the \"5-tuple\". At the client, the 5-tuple consists of the client's host transport address, the server transport address, and the transport protocol used by the client to communicate with the server. At the server, the 5-tuple value is the same except that the client's host transport address is replaced by the client's server-reflexive address since that is the client's address as seen by the server.",
      "ja": "サーバーとクライアントの両方が、「5タプル」と呼ばれる値を追跡します。 クライアントでは、5タプルは、クライアントのホストトランスポートアドレス、サーバートランスポートアドレス、およびサーバーと通信するためにクライアントが使用するトランスポートプロトコルで構成されます。 サーバーでは、5タプルの値は同じですが、クライアントのホストトランスポートアドレスは、サーバーから見えるクライアントのアドレスであるため、クライアントのサーバー反射アドレスに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "Both the client and the server remember the 5-tuple used in the Allocate request. Subsequent messages between the client and the server use the same 5-tuple. In this way, the client and server know which allocation is being referred to. If the client wishes to allocate a second relayed transport address, it must create a second allocation using a different 5-tuple (e.g., by using a different client host address or port).",
      "ja": "クライアントとサーバーの両方が、Allocate要求で使用される5タプルを記憶しています。 クライアントとサーバー間の後続のメッセージは、同じ5タプルを使用します。 このようにして、クライアントとサーバーは、どの割り当てが参照されているかを認識します。 クライアントが2番目の中継トランスポートアドレスを割り当てる場合、異なる5タプルを使用して（たとえば、異なるクライアントホストアドレスまたはポートを使用して）2番目の割り当てを作成する必要があります。"
    },
    {
      "indent": 6,
      "text": "| NOTE: While the terminology used in this document refers to | 5-tuples, the TURN server can store whatever identifier it | likes that yields identical results. Specifically, an | implementation may use a file descriptor in place of a 5-tuple | to represent a TCP connection.",
      "ja": "| 注：このドキュメントで使用されている用語は次を指します| 5タプル、TURNサーバーは、識別子を保存できます| 同じ結果が得られることが好きです。 具体的には、| 実装では、5タプルの代わりにファイル記述子を使用できます。 TCP接続を表します。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |-- Allocate request --------------->|            |            |\n  |   (invalid or missing credentials) |            |            |\n  |                                    |            |            |\n  |<--------------- Allocate failure --|            |            |\n  |              (401 Unauthenticated) |            |            |\n  |                                    |            |            |\n  |-- Allocate request --------------->|            |            |\n  |               (valid credentials)  |            |            |\n  |                                    |            |            |\n  |<---------- Allocate success resp --|            |            |\n  |            (192.0.2.15:50000)      |            |            |\n  //                                   //           //           //\n  |                                    |            |            |\n  |-- Refresh request ---------------->|            |            |\n  |                                    |            |            |\n  |<----------- Refresh success resp --|            |            |\n  |                                    |            |            |",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "In Figure 2, the client sends an Allocate request to the server with invalid or missing credentials. Since the server requires that all requests be authenticated using STUN's long-term credential mechanism, the server rejects the request with a 401 (Unauthorized) error code. The client then tries again, this time including credentials. This time, the server accepts the Allocate request and returns an Allocate success response containing (amongst other things) the relayed transport address assigned to the allocation. Sometime later, the client decides to refresh the allocation; thus, it sends a Refresh request to the server. The refresh is accepted and the server replies with a Refresh success response.",
      "ja": "図2では、クライアントは、資格情報が無効または欠落しているサーバーにAllocate要求を送信します。 サーバーは、すべての要求がSTUNの長期資格情報メカニズムを使用して認証されることを要求するため、サーバーは401（Unauthorized）エラーコードで要求を拒否します。 クライアントは、今度は資格情報を含めて再試行します。 今回は、サーバーはAllocate要求を受け入れ、（とりわけ）割り当てに割り当てられた中継トランスポートアドレスを含むAllocate成功応答を返します。 しばらくして、クライアントは割り当てを更新することにしました。 したがって、サーバーに更新要求を送信します。 更新が受け入れられ、サーバーは更新成功応答で応答します。"
    },
    {
      "indent": 0,
      "text": "3.3. Permissions",
      "section_title": true,
      "ja": "3.3. 許可"
    },
    {
      "indent": 3,
      "text": "To ease concerns amongst enterprise IT administrators that TURN could be used to bypass corporate firewall security, TURN includes the notion of permissions. TURN permissions mimic the address-restricted filtering mechanism of NATs that comply with [RFC4787].",
      "ja": "TURNを使用して企業のファイアウォールセキュリティをバイパスできるという企業のIT管理者の懸念を緩和するために、TURNには許可の概念が含まれています。 TURN許可は、[RFC4787]に準拠するNATのアドレス制限フィルタリングメカニズムを模倣します。"
    },
    {
      "indent": 3,
      "text": "An allocation can have zero or more permissions. Each permission consists of an IP address and a lifetime. When the server receives a UDP datagram on the allocation's relayed transport address, it first checks the list of permissions. If the source IP address of the datagram matches a permission, the application data is relayed to the client; otherwise, the UDP datagram is silently discarded.",
      "ja": "割り当てには、0個以上のアクセス許可を設定できます。 各許可は、IPアドレスとライフタイムで構成されます。 サーバーは、割り当ての中継されたトランスポートアドレスでUDPデータグラムを受信すると、最初にアクセス許可のリストを確認します。 データグラムのソースIPアドレスが許可と一致する場合、アプリケーションデータはクライアントに中継されます。 それ以外の場合、UDPデータグラムは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "A permission expires after 5 minutes if it is not refreshed, and there is no way to explicitly delete a permission. This behavior was selected to match the behavior of a NAT that complies with [RFC4787].",
      "ja": "更新されない場合、許可は5分後に期限切れになり、許可を明示的に削除する方法はありません。 この動作は、[RFC4787]に準拠するNATの動作と一致するように選択されました。"
    },
    {
      "indent": 3,
      "text": "The client can install or refresh a permission using either a CreatePermission request or a ChannelBind request. Using the CreatePermission request, multiple permissions can be installed or refreshed with a single request; this is important for applications that use ICE. For security reasons, permissions can only be installed or refreshed by transactions that can be authenticated; thus, Send indications and ChannelData messages (which are used to send data to peers) do not install or refresh any permissions.",
      "ja": "クライアントは、CreatePermission要求またはChannelBind要求のいずれかを使用して、許可をインストールまたは更新できます。 CreatePermissionリクエストを使用すると、1つのリクエストで複数の権限をインストールまたは更新できます。 これは、ICEを使用するアプリケーションにとって重要です。 セキュリティ上の理由から、認証できるトランザクションによってのみ許可をインストールまたは更新できます。 したがって、送信指示とChannelDataメッセージ（データをピアに送信するために使用されます）は、許可をインストールまたは更新しません。"
    },
    {
      "indent": 3,
      "text": "Note that permissions are within the context of an allocation, so adding or expiring a permission in one allocation does not affect other allocations.",
      "ja": "権限は割り当てのコンテキスト内にあるため、ある割り当てで権限を追加または期限切れにしても、他の割り当てには影響しません。"
    },
    {
      "indent": 0,
      "text": "3.4. Send Mechanism",
      "section_title": true,
      "ja": "3.4. 送信メカニズム"
    },
    {
      "indent": 3,
      "text": "There are two mechanisms for the client and peers to exchange application data using the TURN server. The first mechanism uses the Send and Data methods, the second mechanism uses channels. Common to both mechanisms is the ability of the client to communicate with multiple peers using a single allocated relayed transport address; thus, both mechanisms include a means for the client to indicate to the server which peer should receive the data and for the server to indicate to the client which peer sent the data.",
      "ja": "クライアントとピアがTURNサーバーを使用してアプリケーションデータを交換するための2つのメカニズムがあります。 最初のメカニズムはSendメソッドとDataメソッドを使用し、2番目のメカニズムはチャネルを使用します。 両方のメカニズムに共通するのは、単一の割り当てられた中継トランスポートアドレスを使用して複数のピアと通信するクライアントの機能です。 したがって、両方のメカニズムには、クライアントがサーバーにピアがデータを受信する必要があることを示し、サーバーがクライアントにクライアントがデータを送信したことを示す手段が含まれています。"
    },
    {
      "indent": 3,
      "text": "The Send mechanism uses Send and Data indications. Send indications are used to send application data from the client to the server, while Data indications are used to send application data from the server to the client.",
      "ja": "送信メカニズムは、送信およびデータ表示を使用します。 送信指示は、クライアントからサーバーにアプリケーションデータを送信するために使用され、データ指示は、サーバーからクライアントにアプリケーションデータを送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "When using the Send mechanism, the client sends a Send indication to the TURN server containing (a) an XOR-PEER-ADDRESS attribute specifying the (server-reflexive) transport address of the peer and (b) a DATA attribute holding the application data. When the TURN server receives the Send indication, it extracts the application data from the DATA attribute and sends it in a UDP datagram to the peer, using the allocated relay address as the source address. Note that there is no need to specify the relayed transport address since it is implied by the 5-tuple used for the Send indication.",
      "ja": "送信メカニズムを使用する場合、クライアントは（a）ピアの（サーバー再帰）トランスポートアドレスを指定するXOR-PEER-ADDRESS属性と（b）アプリケーションデータを保持するDATA属性を含む送信指示をTURNサーバーに送信します 。 TURNサーバーは、送信指示を受信すると、DATA属性からアプリケーションデータを抽出し、UDPデータグラムでピアに送信します。割り当てられたリレーアドレスをソースアドレスとして使用します。 送信指示に使用される5タプルによって暗示されるため、中継されるトランスポートアドレスを指定する必要がないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In the reverse direction, UDP datagrams arriving at the relayed transport address on the TURN server are converted into Data indications and sent to the client, with the server-reflexive transport address of the peer included in an XOR-PEER-ADDRESS attribute and the data itself in a DATA attribute. Since the relayed transport address uniquely identified the allocation, the server knows which client should receive the data.",
      "ja": "逆方向では、TURNサーバー上の中継されたトランスポートアドレスに到着するUDPデータグラムは、XOR-PEER-ADDRESS属性とデータに含まれるピアのサーバー反射トランスポートアドレスとともに、データ表示に変換されてクライアントに送信されます。 DATA属性内のそれ自体。 中継されたトランスポートアドレスは割り当てを一意に識別したため、サーバーはどのクライアントがデータを受信する必要があるかを認識しています。"
    },
    {
      "indent": 3,
      "text": "Some ICMP (Internet Control Message Protocol) packets arriving at the relayed transport address on the TURN server may be converted into Data indications and sent to the client, with the transport address of the peer included in an XOR-PEER-ADDRESS attribute and the ICMP type and code in an ICMP attribute. ICMP attribute forwarding always uses Data indications containing the XOR-PEER-ADDRESS and ICMP attributes, even when using the channel mechanism to forward UDP data.",
      "ja": "TURNサーバー上の中継されたトランスポートアドレスに到着する一部のICMP（インターネットコントロールメッセージプロトコル）パケットは、XOR-PEER-ADDRESS属性とICMPに含まれるピアのトランスポートアドレスとともに、データ表示に変換されてクライアントに送信されます。 ICMP属性のタイプとコード。 ICMPメカニズムの転送では、チャネルメカニズムを使用してUDPデータを転送する場合でも、常にXOR-PEER-ADDRESSおよびICMP属性を含むデータ表示が使用されます。"
    },
    {
      "indent": 3,
      "text": "Send and Data indications cannot be authenticated since the long-term credential mechanism of STUN does not support authenticating indications. This is not as big an issue as it might first appear since the client-to-server leg is only half of the total path to the peer. Applications that want end-to-end security should encrypt the data sent between the client and a peer.",
      "ja": "STUNの長期的なクレデンシャルメカニズムはインジケーションの認証をサポートしていないため、送信およびデータインジケーションは認証できません。 クライアントからサーバーへのレグはピアへの合計パスの半分にすぎないため、これは最初に現れるほど大きな問題ではありません。 エンドツーエンドのセキュリティが必要なアプリケーションは、クライアントとピア間で送信されるデータを暗号化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because Send indications are not authenticated, it is possible for an attacker to send bogus Send indications to the server, which will then relay these to a peer. To partly mitigate this attack, TURN requires that the client install a permission towards a peer before sending data to it using a Send indication. The technique to fully mitigate the attack is discussed in Section 21.1.4.",
      "ja": "送信指示は認証されないため、攻撃者が偽の送信指示をサーバーに送信し、サーバーがこれらをピアに中継する可能性があります。 この攻撃を部分的に軽減するために、TURNでは、クライアントが送信指示を使用してデータを送信する前に、クライアントがピアに対して許可をインストールする必要があります。 攻撃を完全に軽減する手法については、セクション21.1.4で説明します。"
    },
    {
      "indent": 3,
      "text": "TURN                                TURN           Peer          Peer\nclient                              server          A             B\n  |                                   |             |             |\n  |-- CreatePermission req (Peer A) ->|             |             |\n  |<- CreatePermission success resp --|             |             |\n  |                                   |             |             |\n  |--- Send ind (Peer A)------------->|             |             |\n  |                                   |=== data ===>|             |\n  |                                   |             |             |\n  |                                   |<== data ====|             |\n  |<------------- Data ind (Peer A) --|             |             |\n  |                                   |             |             |\n  |                                   |             |             |\n  |--- Send ind (Peer B)------------->|             |             |\n  |                                   | dropped     |             |\n  |                                   |             |             |\n  |                                   |<== data ==================|\n  |                           dropped |             |             |\n  |                                   |             |             |",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "In Figure 3, the client has already created an allocation and now wishes to send data to its peers. The client first creates a permission by sending the server a CreatePermission request specifying Peer A's (server-reflexive) IP address in the XOR-PEER-ADDRESS attribute; if this was not done, the server would not relay data between the client and the server. The client then sends data to Peer A using a Send indication; at the server, the application data is extracted and forwarded in a UDP datagram to Peer A, using the relayed transport address as the source transport address. When a UDP datagram from Peer A is received at the relayed transport address, the contents are placed into a Data indication and forwarded to the client. Later, the client attempts to exchange data with Peer B; however, no permission has been installed for Peer B, so the Send indication from the client and the UDP datagram from the peer are both dropped by the server.",
      "ja": "図3では、クライアントはすでに割り当てを作成しており、ピアにデータを送信したいと考えています。 クライアントは最初に、XOR-PEER-ADDRESS属性でピアA（サーバーを反映する）IPアドレスを指定してCreatePermission要求をサーバーに送信することにより、許可を作成します。 これが行われない場合、サーバーはクライアントとサーバー間でデータを中継しません。 次に、クライアントは送信指示を使用してピアAにデータを送信します。 サーバーで、アプリケーションデータが抽出され、UDPデータグラムでピアAに転送されます。このとき、中継されたトランスポートアドレスをソーストランスポートアドレスとして使用します。 ピアAからのUDPデータグラムが中継されたトランスポートアドレスで受信されると、コンテンツはデータ表示に入れられ、クライアントに転送されます。 その後、クライアントはピアBとデータを交換しようとします。 ただし、ピアBには許可がインストールされていないため、クライアントからの送信指示とピアからのUDPデータグラムは両方ともサーバーによってドロップされます。"
    },
    {
      "indent": 0,
      "text": "3.5. Channels",
      "section_title": true,
      "ja": "3.5. チャンネル"
    },
    {
      "indent": 3,
      "text": "For some applications (e.g., Voice over IP (VoIP)), the 36 bytes of overhead that a Send indication or Data indication adds to the application data can substantially increase the bandwidth required between the client and the server. To remedy this, TURN offers a second way for the client and server to associate data with a specific peer.",
      "ja": "一部のアプリケーション（Voice over IP（VoIP）など）では、送信指示またはデータ指示がアプリケーションデータに追加する36バイトのオーバーヘッドにより、クライアントとサーバー間に必要な帯域幅が大幅に増加する可能性があります。 これを改善するために、TURNはクライアントとサーバーがデータを特定のピアに関連付けるための2番目の方法を提供します。"
    },
    {
      "indent": 3,
      "text": "This second way uses an alternate packet format known as the \"ChannelData message\". The ChannelData message does not use the STUN header used by other TURN messages, but instead has a 4-byte header that includes a number known as a \"channel number\". Each channel number in use is bound to a specific peer; thus, it serves as a shorthand for the peer's host transport address.",
      "ja": "この2番目の方法では、「ChannelDataメッセージ」と呼ばれる代替パケット形式を使用します。 ChannelDataメッセージは、他のTURNメッセージで使用されるSTUNヘッダーを使用しませんが、代わりに「チャネル番号」と呼ばれる番号を含む4バイトのヘッダーがあります。 使用中の各チャネル番号は特定のピアにバインドされています。 したがって、ピアのホストトランスポートアドレスの省略形として機能します。"
    },
    {
      "indent": 3,
      "text": "To bind a channel to a peer, the client sends a ChannelBind request to the server and includes an unbound channel number and the transport address of the peer. Once the channel is bound, the client can use a ChannelData message to send the server data destined for the peer. Similarly, the server can relay data from that peer towards the client using a ChannelData message.",
      "ja": "チャネルをピアにバインドするには、クライアントはChannelBind要求をサーバーに送信し、バインドされていないチャネル番号とピアのトランスポートアドレスを含めます。 チャネルがバインドされると、クライアントはChannelDataメッセージを使用して、ピア宛てのサーバーデータを送信できます。 同様に、サーバーはChannelDataメッセージを使用して、そのピアからクライアントに向けてデータを中継できます。"
    },
    {
      "indent": 3,
      "text": "Channel bindings last for 10 minutes unless refreshed; this lifetime was chosen to be longer than the permission lifetime. Channel bindings are refreshed by sending another ChannelBind request rebinding the channel to the peer. Like permissions (but unlike allocations), there is no way to explicitly delete a channel binding; the client must simply wait for it to time out.",
      "ja": "更新されない限り、チャネルバインディングは10分間持続します。 この有効期間は、許可の有効期間よりも長くなるように選択されました。 別のChannelBind要求を送信して、チャネルをピアに再バインドすることにより、チャネルバインディングが更新されます。 許可と同様（ただし、割り当てとは異なります）、チャネルバインディングを明示的に削除する方法はありません。 クライアントは単にタイムアウトするまで待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "TURN                                TURN           Peer          Peer\nclient                              server          A             B\n  |                                   |             |             |\n  |-- ChannelBind req --------------->|             |             |\n  | (Peer A to 0x4001)                |             |             |\n  |                                   |             |             |\n  |<---------- ChannelBind succ resp -|             |             |\n  |                                   |             |             |\n  |-- (0x4001) data ----------------->|             |             |\n  |                                   |=== data ===>|             |\n  |                                   |             |             |\n  |                                   |<== data ====|             |\n  |<------------------ (0x4001) data -|             |             |\n  |                                   |             |             |\n  |--- Send ind (Peer A)------------->|             |             |\n  |                                   |=== data ===>|             |\n  |                                   |             |             |\n  |                                   |<== data ====|             |\n  |<------------------ (0x4001) data -|             |             |\n  |                                   |             |             |",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the channel mechanism in use. The client has already created an allocation and now wishes to bind a channel to Peer A. To do this, the client sends a ChannelBind request to the server, specifying the transport address of Peer A and a channel number (0x4001). After that, the client can send application data encapsulated inside ChannelData messages to Peer A: this is shown as \"(0x4001) data\" where 0x4001 is the channel number. When the ChannelData message arrives at the server, the server transfers the data to a UDP datagram and sends it to Peer A (which is the peer bound to channel number 0x4001).",
      "ja": "図4は、使用中のチャネルメカニズムを示しています。 クライアントは既に割り当てを作成しており、チャネルをピアAにバインドすることを希望しています。これを行うには、クライアントはサーバーにChannelBind要求を送信し、ピアAのトランスポートアドレスとチャネル番号（0x4001）を指定します。 その後、クライアントはChannelDataメッセージ内にカプセル化されたアプリケーションデータをピアAに送信できます。これは、「（0x4001）data」として表示されます。0x4001はチャネル番号です。 ChannelDataメッセージがサーバーに到着すると、サーバーはデータをUDPデータグラムに転送し、それをピアA（チャネル番号0x4001にバインドされたピア）に送信します。"
    },
    {
      "indent": 3,
      "text": "In the reverse direction, when Peer A sends a UDP datagram to the relayed transport address, this UDP datagram arrives at the server on the relayed transport address assigned to the allocation. Since the UDP datagram was received from Peer A, which has a channel number assigned to it, the server encapsulates the data into a ChannelData message when sending the data to the client.",
      "ja": "逆方向に、ピアAがUDPデータグラムを中継されたトランスポートアドレスに送信すると、このUDPデータグラムは、割り当てに割り当てられた中継されたトランスポートアドレスでサーバーに到着します。 UDPデータグラムは、チャネル番号が割り当てられたピアAから受信されたため、データをクライアントに送信するときに、サーバーはデータをChannelDataメッセージにカプセル化します。"
    },
    {
      "indent": 3,
      "text": "Once a channel has been bound, the client is free to intermix ChannelData messages and Send indications. In the figure, the client later decides to use a Send indication rather than a ChannelData message to send additional data to Peer A. The client might decide to do this, for example, so it can use the DONT-FRAGMENT attribute (see the next section). However, once a channel is bound, the server will always use a ChannelData message, as shown in the call flow.",
      "ja": "チャンネルがバインドされると、クライアントはChannelDataメッセージと送信指示を自由に混在させることができます。 図では、クライアントは後で追加データをピアAに送信するためにChannelDataメッセージではなく送信指示を使用することを決定します。たとえば、クライアントはこれを行うことを決定する場合があるため、DONT-FRAGMENT属性を使用できます（次を参照） セクション）。 ただし、チャネルがバインドされると、コールフローに示されているように、サーバーは常にChannelDataメッセージを使用します。"
    },
    {
      "indent": 3,
      "text": "Note that ChannelData messages can only be used for peers to which the client has bound a channel. In the example above, Peer A has been bound to a channel, but Peer B has not, so application data to and from Peer B would use the Send mechanism.",
      "ja": "ChannelDataメッセージは、クライアントがチャネルをバインドしたピアに対してのみ使用できることに注意してください。 上記の例では、ピアAはチャネルにバインドされていますが、ピアBはバインドされていないため、ピアBとの間のアプリケーションデータは送信メカニズムを使用します。"
    },
    {
      "indent": 0,
      "text": "3.6. Unprivileged TURN Servers",
      "section_title": true,
      "ja": "3.6. 非特権TURNサーバー"
    },
    {
      "indent": 3,
      "text": "This version of TURN is designed so that the server can be implemented as an application that runs in user space under commonly available operating systems without requiring special privileges. This design decision was made to make it easy to deploy a TURN server: for example, to allow a TURN server to be integrated into a peer-to-peer application so that one peer can offer NAT traversal services to another peer and to use (D)TLS to secure the TURN connection.",
      "ja": "TURNのこのバージョンは、特別な特権を必要とせずに、一般的に利用可能なオペレーティングシステムのユーザー空間で実行されるアプリケーションとしてサーバーを実装できるように設計されています。 この設計上の決定は、TURNサーバーのデプロイを簡単にするために行われました。たとえば、1つのピアが別のピアにNATトラバーサルサービスを提供して使用できるように、TURNサーバーをピアツーピアアプリケーションに統合できるようにします（ D）TURN接続を保護するためのTLS。"
    },
    {
      "indent": 3,
      "text": "This design decision has the following implications for data relayed by a TURN server:",
      "ja": "この設計上の決定は、TURNサーバーによって中継されるデータに対して次の意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "* The value of the Diffserv field may not be preserved across the server;",
      "ja": "* Diffservフィールドの値は、サーバー全体で保持されない場合があります。"
    },
    {
      "indent": 3,
      "text": "* The Time to Live (TTL) field may be reset, rather than decremented, across the server;",
      "ja": "* Time to Live（TTL）フィールドは、サーバー全体でデクリメントされるのではなく、リセットされる場合があります。"
    },
    {
      "indent": 3,
      "text": "* The Explicit Congestion Notification (ECN) field may be reset by the server;",
      "ja": "* 明示的輻輳通知（ECN）フィールドは、サーバーによってリセットされる場合があります。"
    },
    {
      "indent": 3,
      "text": "* There is no end-to-end fragmentation since the packet is reassembled at the server.",
      "ja": "* パケットはサーバーで再構築されるため、エンドツーエンドのフラグメンテーションはありません。"
    },
    {
      "indent": 3,
      "text": "Future work may specify alternate TURN semantics that address these limitations.",
      "ja": "今後の作業では、これらの制限に対処する代替のTURNセマンティクスを指定する可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.7. Avoiding IP Fragmentation",
      "section_title": true,
      "ja": "3.7. IPフラグメンテーションの回避"
    },
    {
      "indent": 3,
      "text": "For reasons described in [FRAG-HARMFUL], applications, especially those sending large volumes of data, should avoid having their packets fragmented. [FRAG-FRAGILE] discusses issues associated with IP fragmentation and proposes alternatives to IP fragmentation. Applications using TCP can, more or less, ignore this issue because fragmentation avoidance is now a standard part of TCP, but applications using UDP (and, thus, any application using this version of TURN) need to avoid IP fragmentation by sending sufficiently small messages or by using UDP fragmentation [UDP-OPT]. Note that the UDP fragmentation option needs to be supported by both endpoints, and at the time of writing of this document, UDP fragmentation support is under discussion and is not deployed.",
      "ja": "[FRAG-HARMFUL]で説明されている理由により、アプリケーション、特に大量のデータを送信するアプリケーションでは、パケットの断片化を避ける必要があります。 [FRAG-FRAGILE]は、IPフラグメンテーションに関連する問題を議論し、IPフラグメンテーションの代替案を提案します。 TCPを使用するアプリケーションは、断片化の回避がTCPの標準部分になったため、この問題を多かれ少なかれ無視できますが、UDPを使用するアプリケーション（したがって、このバージョンのTURNを使用するアプリケーション）は、十分に小さなメッセージを送信してIP断片化を回避する必要があります または、UDPフラグメンテーション[UDP-OPT]を使用します。 UDPフラグメンテーションオプションは両方のエンドポイントでサポートされる必要があることに注意してください。このドキュメントの執筆時点では、UDPフラグメンテーションサポートは議論中であり、展開されていません。"
    },
    {
      "indent": 3,
      "text": "The application running on the client and the peer can take one of two approaches to avoid IP fragmentation until UDP fragmentation support is available. The first uses messages that are limited to a predetermined fixed maximum, and the second relies on network feedback to adapt that maximum.",
      "ja": "クライアントとピアで実行されているアプリケーションは、UDPフラグメンテーションサポートが利用可能になるまでIPフラグメンテーションを回避するために2つのアプローチのいずれかを取ることができます。 1つ目は、所定の固定最大値に制限されているメッセージを使用し、2つ目は、ネットワークフィードバックに依存してその最大値を調整します。"
    },
    {
      "indent": 3,
      "text": "The first approach is to avoid sending large amounts of application data in the TURN messages/UDP datagrams exchanged between the client and the peer. This is the approach taken by most VoIP applications. In this approach, the application MUST assume a Path MTU (PMTU) of 1280 bytes because IPv6 requires that every link in the Internet has an MTU of 1280 octets or greater as specified in [RFC8200]. If IPv4 support on legacy or otherwise unusual networks is a consideration, the application MAY assume an effective MTU of 576 bytes for IPv4 datagrams, as every IPv4 host must be capable of receiving a packet with a length equal to 576 bytes as discussed in [RFC0791] and [RFC1122].",
      "ja": "最初のアプローチは、クライアントとピア間で交換されるTURNメッセージ/ UDPデータグラムで大量のアプリケーションデータを送信しないようにすることです。 これは、ほとんどのVoIPアプリケーションで採用されているアプローチです。 このアプローチでは、IPv6ではインターネットのすべてのリンクが[RFC8200]で指定された1280オクテット以上のMTUを持つ必要があるため、アプリケーションは1280バイトのパスMTU（PMTU）を想定しなければなりません。 [RFC0791 ]および[RFC1122]。"
    },
    {
      "indent": 3,
      "text": "The exact amount of application data that can be included while avoiding fragmentation depends on the details of the TURN session between the client and the server: whether UDP, TCP, or (D)TLS transport is used; whether ChannelData messages or Send/Data indications are used; and whether any additional attributes (such as the DONT-FRAGMENT attribute) are included. Another factor, which is hard to determine, is whether the MTU is reduced somewhere along the path for other reasons, such as the use of IP-in-IP tunneling.",
      "ja": "断片化を回避しながら含めることができるアプリケーションデータの正確な量は、クライアントとサーバー間のTURNセッションの詳細によって異なります。UDP、TCP、または（D）TLSトランスポートが使用されるかどうか。 ChannelDataメッセージまたはSend / Data指示が使用されるかどうか。 また、追加の属性（DONT-FRAGMENT属性など）が含まれているかどうか。 判断が難しいもう1つの要因は、IP-in-IPトンネリングの使用など、他の理由でパスのどこかでMTUが減少するかどうかです。"
    },
    {
      "indent": 3,
      "text": "As a guideline, sending a maximum of 500 bytes of application data in a single TURN message (by the client on the client-to-server leg) or a UDP datagram (by the peer on the peer-to-server leg) will generally avoid IP fragmentation. To further reduce the chance of fragmentation, it is recommended that the client use ChannelData messages when transferring significant volumes of data since the overhead of the ChannelData message is less than Send and Data indications.",
      "ja": "ガイドラインとして、単一のTURNメッセージ（クライアントからサーバーへのレッグのクライアントによる）またはUDPデータグラム（ピアからサーバーへのレッグのピアによる）で最大500バイトのアプリケーションデータを送信するのが一般的です。 IPフラグメンテーションを回避します。 フラグメンテーションの可能性をさらに減らすには、ChannelDataメッセージのオーバーヘッドがSendおよびData指示よりも小さいため、クライアントが大量のデータを転送するときにChannelDataメッセージを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The second approach the client and peer can take to avoid fragmentation is to use a path MTU discovery algorithm to determine the maximum amount of application data that can be sent without fragmentation. The classic path MTU discovery algorithm defined in [RFC1191] may not be able to discover the MTU of the transmission path between the client and the peer since:",
      "ja": "クライアントとピアがフラグメンテーションを回避するために取ることができる2番目のアプローチは、パスMTUディスカバリアルゴリズムを使用して、フラグメンテーションなしで送信できるアプリケーションデータの最大量を決定することです。 [RFC1191]で定義されているクラシックパスMTU発見アルゴリズムは、クライアントとピア間の伝送パスのMTUを発見できない場合があります。"
    },
    {
      "indent": 3,
      "text": "* A probe packet with a Don't Fragment (DF) bit in the IPv4 header set to test a path for a larger MTU can be dropped by routers, or",
      "ja": "* より大きなMTUのパスをテストするためにIPv4ヘッダーセットにDo n't Fragment（DF）ビットが含まれるプローブパケットは、ルーターによってドロップされるか、または"
    },
    {
      "indent": 3,
      "text": "* ICMP error messages can be dropped by middleboxes.",
      "ja": "* ICMPエラーメッセージは、ミドルボックスによってドロップされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "As a result, the client and server need to use a path MTU discovery algorithm that does not require ICMP messages. The Packetized Path MTU Discovery algorithm defined in [RFC4821] is one such algorithm, and a set of algorithms is defined in [MTU-DATAGRAM].",
      "ja": "その結果、クライアントとサーバーは、ICMPメッセージを必要としないパスMTU発見アルゴリズムを使用する必要があります。 [RFC4821]で定義されているPacketized Path MTU Discoveryアルゴリズムはそのようなアルゴリズムの1つであり、アルゴリズムのセットは[MTU-DATAGRAM]で定義されています。"
    },
    {
      "indent": 3,
      "text": "[MTU-STUN] is an implementation of [RFC4821] that uses STUN to discover the path MTU; so it might be a suitable approach to be used in conjunction with a TURN server that supports the DONT-FRAGMENT attribute. When the client includes the DONT-FRAGMENT attribute in a Send indication, this tells the server to set the DF bit in the resulting UDP datagram that it sends to the peer. Since some servers may be unable to set the DF bit, the client should also include this attribute in the Allocate request; any server that does not support the DONT-FRAGMENT attribute will indicate this by rejecting the Allocate request. If the TURN server carrying out packet translation from IPv4-to-IPv6 is unable to access the state of the Don't Fragment (DF) bit in the IPv4 header, it MUST reject the Allocate request with the DONT-FRAGMENT attribute.",
      "ja": "[MTU-STUN]は[RFC4821]の実装であり、STUNを使用してパスMTUを検出します。 そのため、DONT-FRAGMENT属性をサポートするTURNサーバーと組み合わせて使用するのに適したアプローチになる可能性があります。 クライアントが送信指示にDONT-FRAGMENT属性を含めると、これは、ピアに送信する結果のUDPデータグラムにDFビットを設定するようサーバーに指示します。 一部のサーバーではDFビットを設定できない場合があるため、クライアントはこの属性をAllocateリクエストに含める必要があります。 DONT-FRAGMENT属性をサポートしないサーバーは、割り当て要求を拒否することでこれを示します。 IPv4-to-IPv6からパケット変換を実行するTURNサーバーがIPv4ヘッダーのDo n't Fragment（DF）ビットの状態にアクセスできない場合、DONT-FRAGMENT属性を持つAllocate要求を拒否しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.8. RTP Support",
      "section_title": true,
      "ja": "3.8. RTPサポート"
    },
    {
      "indent": 3,
      "text": "One of the envisioned uses of TURN is as a relay for clients and peers wishing to exchange real-time data (e.g., voice or video) using RTP. To facilitate the use of TURN for this purpose, TURN includes some special support for older versions of RTP.",
      "ja": "TURNの想定される用途の1つは、RTPを使用してリアルタイムデータ（音声やビデオなど）を交換したいクライアントとピアのリレーとして使用することです。 この目的でTURNを使用しやすくするために、TURNにはRTPの古いバージョンに対する特別なサポートが含まれています。"
    },
    {
      "indent": 3,
      "text": "Old versions of RTP [RFC3550] required that the RTP stream be on an even port number and the associated RTP Control Protocol (RTCP) stream, if present, be on the next highest port. To allow clients to work with peers that still require this, TURN allows the client to request that the server allocate a relayed transport address with an even port number and optionally request the server reserve the next-highest port number for a subsequent allocation.",
      "ja": "RTP [RFC3550]の古いバージョンでは、RTPストリームが偶数のポート番号に存在し、関連するRTP制御プロトコル（RTCP）ストリームが存在する場合、次に高いポートに存在する必要がありました。 クライアントがこれを必要とするピアと連携できるようにするために、TURNは、クライアントがサーバーに偶数のポート番号で中継されたトランスポートアドレスを割り当てることを要求し、必要に応じてサーバーが後続の割り当てのために次に高いポート番号を予約するように要求することを許可します。"
    },
    {
      "indent": 0,
      "text": "3.9. Happy Eyeballs for TURN",
      "section_title": true,
      "ja": "3.9. TURNのハッピーアイボール"
    },
    {
      "indent": 3,
      "text": "If an IPv4 path to reach a TURN server is found, but the TURN server's IPv6 path is not working, a dual-stack TURN client can experience a significant connection delay compared to an IPv4-only TURN client. To overcome these connection setup problems, the TURN client needs to query both A and AAAA records for the TURN server specified using a domain name and try connecting to the TURN server using both IPv6 and IPv4 addresses in a fashion similar to the Happy Eyeballs mechanism defined in [RFC8305]. The TURN client performs the following steps based on the transport protocol being used to connect to the TURN server.",
      "ja": "TURNサーバーに到達するためのIPv4パスが見つかったが、TURNサーバーのIPv6パスが機能していない場合、デュアルスタックTURNクライアントは、IPv4のみのTURNクライアントと比較して大幅な接続遅延を経験する可能性があります。 これらの接続設定の問題を解決するには、TURNクライアントは、ドメイン名を使用して指定されたTURNサーバーのAレコードとAAAAレコードの両方を照会し、定義されたHappy Eyeballsメカニズムと同様の方法でIPv6アドレスとIPv4アドレスの両方を使用してTURNサーバーに接続する必要があります [RFC8305]で。 TURNクライアントは、TURNサーバーへの接続に使用されているトランスポートプロトコルに基づいて、次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "* For TCP or TLS-over-TCP, the results of the Happy Eyeballs procedure [RFC8305] are used by the TURN client for sending its TURN messages to the server.",
      "ja": "* TCPまたはTLS-over-TCPの場合、Happy Eyeballs手順[RFC8305]の結果は、TURNクライアントがTURNメッセージをサーバーに送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "* For clear text UDP, send TURN Allocate requests to both IP address families as discussed in [RFC8305] without authentication information. If the TURN server requires authentication, it will send back a 401 unauthenticated response; the TURN client will use the first UDP connection on which a 401 error response is received. If a 401 error response is received from both IP address families, then the TURN client can silently abandon the UDP connection on the IP address family with lower precedence. If the TURN server does not require authentication (as described in Section 9 of [RFC8155]), it is possible for both Allocate requests to succeed. In this case, the TURN client sends a Refresh with a LIFETIME value of zero on the allocation using the IP address family with lower precedence to delete the allocation.",
      "ja": "* クリアテキストUDPの場合、[RFC8305]で説明されているように、認証情報なしで両方のIPアドレスファミリにTURN Allocate要求を送信します。 TURNサーバーが認証を必要とする場合、401認証されていない応答を送り返します。 TURNクライアントは、401エラー応答が受信される最初のUDP接続を使用します。 両方のIPアドレスファミリから401エラー応答を受信した場合、TURNクライアントは、IPアドレスファミリのUDP接続をより低い優先順位で静かに放棄できます。 TURNサーバーが認証を必要としない場合（[RFC8155]のセクション9で説明されているように）、両方のAllocate要求が成功する可能性があります。 この場合、TURNクライアントは、優先順位の低いIPアドレスファミリを使用して割り当てを削除するため、割り当てでLIFETIME値がゼロのRefreshを送信します。"
    },
    {
      "indent": 3,
      "text": "* For DTLS over UDP, initiate a DTLS handshake to both IP address families as discussed in [RFC8305], and use the first DTLS session that is established. If the DTLS session is established on both IP address families, then the client sends a DTLS close_notify alert to terminate the DTLS session using the IP address family with lower precedence. If the TURN over DTLS server has been configured to require a cookie exchange (Section 4.2 of [RFC6347]) and a HelloVerifyRequest is received from the TURN servers on both IP address families, then the client can silently abandon the connection on the IP address family with lower precedence.",
      "ja": "* DTLS over UDPの場合、[RFC8305]で説明されているように両方のIPアドレスファミリへのDTLSハンドシェイクを開始し、確立された最初のDTLSセッションを使用します。 DTLSセッションが両方のIPアドレスファミリで確立された場合、クライアントはDTLS close_notifyアラートを送信して、優先順位の低いIPアドレスファミリを使用してDTLSセッションを終了します。 TURN over DTLSサーバーがCookie交換（[RFC6347]のセクション4.2）を必要とするように構成されており、両方のIPアドレスファミリーのTURNサーバーからHelloVerifyRequestを受信した場合、クライアントはIPアドレスファミリーの接続を静かに放棄できます 優先順位が低い。"
    },
    {
      "indent": 0,
      "text": "4. Discovery of TURN Server",
      "section_title": true,
      "ja": "4. TURN Serverのディスカバリー"
    },
    {
      "indent": 3,
      "text": "Methods of TURN server discovery, including using anycast, are described in [RFC8155]. If a host with multiple interfaces discovers a TURN server in each interface, the mechanism described in [RFC7982] can be used by the TURN client to influence the TURN server selection. The syntax of the \"turn\" and \"turns\" URIs are defined in Section 3.1 of [RFC7065]. DTLS as a transport protocol for TURN is defined in [RFC7350].",
      "ja": "エニーキャストの使用を含む、TURNサーバーの検出方法は、[RFC8155]で説明されています。 複数のインターフェースを持つホストが各インターフェースでTURNサーバーを発見した場合、[RFC7982]で説明されているメカニズムをTURNクライアントで使用して、TURNサーバーの選択に影響を与えることができます。 「turn」および「turns」URIの構文は、[RFC7065]のセクション3.1で定義されています。 TURNのトランスポートプロトコルとしてのDTLSは[RFC7350]で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.1. TURN URI Scheme Semantics",
      "section_title": true,
      "ja": "4.1. TURN URIスキームのセマンティクス"
    },
    {
      "indent": 3,
      "text": "The \"turn\" and \"turns\" URI schemes are used to designate a TURN server (also known as a \"relay\") on Internet hosts accessible using the TURN protocol. The TURN protocol supports sending messages over UDP, TCP, TLS-over-TCP, or DTLS-over-UDP. The \"turns\" URI scheme MUST be used when TURN is run over TLS-over-TCP or in DTLS-over-UDP, and the \"turn\" scheme MUST be used otherwise. The required <host> part of the \"turn\" URI denotes the TURN server host. The <port> part, if present, denotes the port on which the TURN server is awaiting connection requests. If it is absent, the default port is 3478 for both UDP and TCP. The default port for TURN over TLS and TURN over DTLS is 5349.",
      "ja": "「turn」および「turns」URIスキームは、TURNプロトコルを使用してアクセス可能なインターネットホスト上のTURNサーバー（「リレー」とも呼ばれる）を指定するために使用されます。 TURNプロトコルは、UDP、TCP、TLS-over-TCP、またはDTLS-over-UDPを介したメッセージの送信をサポートしています。 TURNがTLS-over-TCPまたはDTLS-over-UDPで実行される場合、「ターン」URIスキームを使用する必要があり、そうでない場合は「ターン」スキームを使用する必要があります。 「turn」URIの必須の<host>部分は、TURNサーバーホストを示します。 <port>部分（存在する場合）は、TURNサーバーが接続要求を待機しているポートを示します。 存在しない場合、デフォルトのポートはUDPとTCPの両方で3478です。 TURN over TLSおよびTURN over DTLSのデフォルトポートは5349です。"
    },
    {
      "indent": 0,
      "text": "5. General Behavior",
      "section_title": true,
      "ja": "5. 一般的な行動"
    },
    {
      "indent": 3,
      "text": "This section contains general TURN processing rules that apply to all TURN messages.",
      "ja": "このセクションには、すべてのTURNメッセージに適用される一般的なTURN処理ルールが含まれています。"
    },
    {
      "indent": 3,
      "text": "TURN is an extension to STUN. All TURN messages, with the exception of the ChannelData message, are STUN-formatted messages. All the base processing rules described in [RFC8489] apply to STUN-formatted messages. This means that all the message-forming and message-processing descriptions in this document are implicitly prefixed with the rules of [RFC8489].",
      "ja": "TURNはSTUNの拡張です。 ChannelDataメッセージを除くすべてのTURNメッセージは、STUN形式のメッセージです。 [RFC8489]で説明されているすべての基本処理ルールは、STUN形式のメッセージに適用されます。 これは、このドキュメントのすべてのメッセージ形成およびメッセージ処理の説明が[RFC8489]のルールを暗黙的にプレフィックスすることを意味します。"
    },
    {
      "indent": 3,
      "text": "[RFC8489] specifies an authentication mechanism called the \"long-term credential mechanism\". TURN servers and clients MUST implement this mechanism, and the authentication options are discussed in Section 7.2.",
      "ja": "[RFC8489]は、「長期資格情報メカニズム」と呼ばれる認証メカニズムを指定します。 TURNサーバーとクライアントはこのメカニズムを実装する必要があり、認証オプションについてはセクション7.2で説明します。"
    },
    {
      "indent": 3,
      "text": "Note that the long-term credential mechanism applies only to requests and cannot be used to authenticate indications; thus, indications in TURN are never authenticated. If the server requires requests to be authenticated, then the server's administrator MUST choose a realm value that will uniquely identify the username and password combination that the client must use, even if the client uses multiple servers under different administrations. The server's administrator MAY choose to allocate a unique username to each client, or it MAY choose to allocate the same username to more than one client (for example, to all clients from the same department or company). For each Allocate request, the server SHOULD generate a new random nonce when the allocation is first attempted following the randomness recommendations in [RFC4086] and SHOULD expire the nonce at least once every hour during the lifetime of the allocation. The server uses the mechanism described in Section 9.2 of [RFC8489] to indicate that it supports [RFC8489].",
      "ja": "長期資格情報メカニズムは要求にのみ適用され、指示の認証には使用できないことに注意してください。したがって、TURNの指示は認証されません。サーバーが要求の認証を要求する場合、サーバーの管理者は、クライアントが異なる管理下で複数のサーバーを使用する場合でも、クライアントが使用する必要があるユーザー名とパスワードの組み合わせを一意に識別するレルム値を選択する必要があります。サーバーの管理者は、各クライアントに一意のユーザー名を割り当てるか、複数のクライアント（たとえば、同じ部門または会社のすべてのクライアント）に同じユーザー名を割り当てることを選択できます。各割り振り要求に対して、サーバーは[RFC4086]のランダム性の推奨に従って割り振りが最初に試行されたときに新しいランダムナンスを生成する必要があり（SHOULD）、割り振りの存続期間中に少なくとも1時間に1回ナンスを期限切れにする必要があります。サーバーは、[RFC8489]のセクション9.2で説明されているメカニズムを使用して、[RFC8489]をサポートしていることを示します。"
    },
    {
      "indent": 3,
      "text": "All requests after the initial Allocate must use the same username as that used to create the allocation to prevent attackers from hijacking the client's allocation.",
      "ja": "最初のAllocateの後のすべての要求は、攻撃者がクライアントの割り当てをハイジャックすることを防ぐために、割り当ての作成に使用したものと同じユーザー名を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Specifically, if:",
      "ja": "特に、次の場合："
    },
    {
      "indent": 3,
      "text": "* the server requires the use of the long-term credential mechanism, and;",
      "ja": "* サーバーは、長期資格情報メカニズムの使用を必要とします。"
    },
    {
      "indent": 3,
      "text": "* a non-Allocate request passes authentication under this mechanism, and;",
      "ja": "* 非割り当て要求は、このメカニズムの下で認証を渡します。"
    },
    {
      "indent": 3,
      "text": "* the 5-tuple identifies an existing allocation, but;",
      "ja": "* 5タプルは既存の割り当てを識別しますが、"
    },
    {
      "indent": 3,
      "text": "* the request does not use the same username as used to create the allocation,",
      "ja": "* リクエストでは、割り当ての作成に使用したものと同じユーザー名は使用しません。"
    },
    {
      "indent": 3,
      "text": "then the request MUST be rejected with a 441 (Wrong Credentials) error.",
      "ja": "リクエストは441（間違った資格情報）エラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a TURN message arrives at the server from the client, the server uses the 5-tuple in the message to identify the associated allocation. For all TURN messages (including ChannelData) EXCEPT an Allocate request, if the 5-tuple does not identify an existing allocation, then the message MUST either be rejected with a 437 Allocation Mismatch error (if it is a request) or be silently ignored (if it is an indication or a ChannelData message). A client receiving a 437 error response to a request other than Allocate MUST assume the allocation no longer exists.",
      "ja": "TURNメッセージがクライアントからサーバーに到着すると、サーバーはメッセージ内の5タプルを使用して、関連付けられた割り当てを識別します。 Allocate要求を除くすべてのTURNメッセージ（ChannelDataを含む）について、5タプルが既存の割り当てを識別しない場合、メッセージは437 Allocation Mismatchエラー（要求の場合）で拒否されるか、黙って無視されなければなりません（ 表示またはChannelDataメッセージの場合）。 Allocate以外のリクエストに対する437エラー応答を受信したクライアントは、割り当てがもはや存在しないと仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "[RFC8489] defines a number of attributes, including the SOFTWARE and FINGERPRINT attributes. The client SHOULD include the SOFTWARE attribute in all Allocate and Refresh requests and MAY include it in any other requests or indications. The server SHOULD include the SOFTWARE attribute in all Allocate and Refresh responses (either success or failure) and MAY include it in other responses or indications. The client and the server MAY include the FINGERPRINT attribute in any STUN-formatted messages defined in this document.",
      "ja": "[RFC8489]は、SOFTWAREおよびFINGERPRINT属性を含む多くの属性を定義します。 クライアントは、すべての割り当ておよび更新要求にソフトウェア属性を含める必要があり（SHOULD）、他の要求または指示に含めることができます（MAY）。 サーバーは、すべてのAllocateおよびRefresh応答（成功または失敗）にSOFTWARE属性を含める必要があり（SHOULD）、他の応答または指示にそれを含めることができます（MAY）。 クライアントとサーバーは、このドキュメントで定義されているSTUN形式のメッセージにFINGERPRINT属性を含めることができます。"
    },
    {
      "indent": 3,
      "text": "TURN does not use the backwards-compatibility mechanism described in [RFC8489].",
      "ja": "TURNは、[RFC8489]で説明されている後方互換性メカニズムを使用しません。"
    },
    {
      "indent": 3,
      "text": "TURN, as defined in this specification, supports both IPv4 and IPv6. IPv6 support in TURN includes IPv4-to-IPv6, IPv6-to-IPv6, and IPv6- to-IPv4 relaying. When only a single address type is desired, the REQUESTED-ADDRESS-FAMILY attribute is used to explicitly request the address type the TURN server will allocate (e.g., an IPv4-only node may request the TURN server to allocate an IPv6 address). If both IPv4 and IPv6 are desired, the single ADDITIONAL-ADDRESS-FAMILY attribute indicates a request to the server to allocate one IPv4 and one IPv6 relay address in a single Allocate request. This saves local ports on the client and reduces the number of messages sent between the client and the TURN server.",
      "ja": "この仕様で定義されているTURNは、IPv4とIPv6の両方をサポートしています。 TURNでのIPv6サポートには、IPv4-to-IPv6、IPv6-to-IPv6、およびIPv6-to-IPv4リレーが含まれます。 単一のアドレスタイプのみが必要な場合、REQUESTED-ADDRESS-FAMILY属性を使用して、TURNサーバーが割り当てるアドレスタイプを明示的に要求します（たとえば、IPv4専用ノードがTURNサーバーにIPv6アドレスを割り当てるよう要求する場合があります）。 IPv4とIPv6の両方が必要な場合、単一のADDITIONAL-ADDRESS-FAMILY属性は、単一の割り当て要求で1つのIPv4と1つのIPv6リレーアドレスを割り当てるサーバーへの要求を示します。 これにより、クライアントのローカルポートが節約され、クライアントとTURNサーバー間で送信されるメッセージの数が削減されます。"
    },
    {
      "indent": 3,
      "text": "By default, TURN runs on the same ports as STUN: 3478 for TURN over UDP and TCP, and 5349 for TURN over (D)TLS. However, TURN has its own set of Service Record (SRV) names: \"turn\" for UDP and TCP, and \"turns\" for (D)TLS. Either the DNS resolution procedures or the ALTERNATE-SERVER procedures, both described in Section 7, can be used to run TURN on a different port.",
      "ja": "デフォルトでは、TURNはSTUNと同じポートで実行されます。UDPおよびTCPを介したTURNでは3478、（D）TLSでのTURNは5349です。 ただし、TURNには独自のサービスレコード（SRV）名のセットがあります：UDPおよびTCPの場合は「turn」、（D）TLSの場合は「turns」 セクション7で説明されているDNS解決手順またはALTERNATE-SERVER手順のいずれかを使用して、異なるポートでTURNを実行できます。"
    },
    {
      "indent": 3,
      "text": "To ensure interoperability, a TURN server MUST support the use of UDP transport between the client and the server, and it SHOULD support the use of TCP, TLS-over-TCP, and DTLS-over-UDP transports.",
      "ja": "相互運用性を確保するために、TURNサーバーはクライアントとサーバー間のUDPトランスポートの使用をサポートする必要があり、TCP、TLS-over-TCP、およびDTLS-over-UDPトランスポートの使用をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When UDP or DTLS-over-UDP transport is used between the client and the server, the client will retransmit a request if it does not receive a response within a certain timeout period. Because of this, the server may receive two (or more) requests with the same 5-tuple and same transaction id. STUN requires that the server recognize this case and treat the request as idempotent (see [RFC8489]). Some implementations may choose to meet this requirement by remembering all received requests and the corresponding responses for 40 seconds (Section 6.3.1 of [RFC8489]). Other implementations may choose to reprocess the request and arrange that such reprocessing returns essentially the same response. To aid implementors who choose the latter approach (the so-called \"stateless stack approach\"), this specification includes some implementation notes on how this might be done. Implementations are free to choose either approach or some other approach that gives the same results.",
      "ja": "UDPまたはDTLS-over-UDPトランスポートがクライアントとサーバー間で使用される場合、クライアントは、特定のタイムアウト期間内に応答を受信しない場合、要求を再送信します。 このため、サーバーは同じ5タプルと同じトランザクションIDを持つ2つ（またはそれ以上）の要求を受信する場合があります。 STUNでは、サーバーがこのケースを認識し、リクエストをべき等として扱う必要があります（[RFC8489]を参照）。 一部の実装では、受信したすべての要求と対応する応答を40秒間記憶することにより、この要件を満たすことを選択できます（[RFC8489]のセクション6.3.1）。 他の実装では、要求を再処理し、そのような再処理が本質的に同じ応答を返すように調整することを選択できます。 後者のアプローチ（いわゆる「ステートレススタックアプローチ」）を選択する実装者を支援するために、この仕様には、これを行う方法に関する実装上の注意が含まれています。 実装では、アプローチまたは同じ結果をもたらす他のアプローチのいずれかを自由に選択できます。"
    },
    {
      "indent": 3,
      "text": "To mitigate either intentional or unintentional denial-of-service attacks against the server by clients with valid usernames and passwords, it is RECOMMENDED that the server impose limits on both the number of allocations active at one time for a given username and on the amount of bandwidth those allocations can use. The server should reject new allocations that would exceed the limit on the allowed number of allocations active at one time with a 486 (Allocation Quota Exceeded) (see Section 7.2), and since UDP does not include a congestion control mechanism, it should discard application data traffic that exceeds the bandwidth quota.",
      "ja": "有効なユーザー名とパスワードを持つクライアントによるサーバーに対する意図的または非意図的なサービス拒否攻撃を軽減するために、サーバーは特定のユーザー名に対して一度にアクティブな割り当ての数とその量の両方に制限を課すことが推奨されます これらの割り当てが使用できる帯域幅。 サーバーは、486（Allocation Quota Exceeded）（セクション7.2を参照）で一度にアクティブな割り当ての許可数の制限を超える新しい割り当てを拒否する必要があり、UDPには輻輳制御メカニズムが含まれていないため、アプリケーションを破棄する必要があります 帯域幅クォータを超えるデータトラフィック。"
    },
    {
      "indent": 0,
      "text": "6. Allocations",
      "section_title": true,
      "ja": "6. 割り当て"
    },
    {
      "indent": 3,
      "text": "All TURN operations revolve around allocations, and all TURN messages are associated with either a single or dual allocation. An allocation conceptually consists of the following state data:",
      "ja": "すべてのTURN操作は割り当てを中心に展開され、すべてのTURNメッセージは単一または二重の割り当てに関連付けられます。 割り当ては、概念的に次の状態データで構成されます。"
    },
    {
      "indent": 3,
      "text": "* the relayed transport address or addresses;",
      "ja": "* 中継されたトランスポートアドレス。"
    },
    {
      "indent": 3,
      "text": "* the 5-tuple: (client's IP address, client's port, server IP address, server port, and transport protocol);",
      "ja": "* 5タプル：（クライアントのIPアドレス、クライアントのポート、サーバーIPアドレス、サーバーポート、およびトランスポートプロトコル）;"
    },
    {
      "indent": 3,
      "text": "* the authentication information;",
      "ja": "* 認証情報。"
    },
    {
      "indent": 3,
      "text": "* the time-to-expiry for each relayed transport address;",
      "ja": "* 中継された各トランスポートアドレスの有効期限。"
    },
    {
      "indent": 3,
      "text": "* a list of permissions for each relayed transport address;",
      "ja": "* リレーされた各トランスポートアドレスの権限のリスト。"
    },
    {
      "indent": 3,
      "text": "* a list of channel-to-peer bindings for each relayed transport address.",
      "ja": "* リレーされた各トランスポートアドレスのチャネルツーピアバインディングのリスト。"
    },
    {
      "indent": 3,
      "text": "The relayed transport address is the transport address allocated by the server for communicating with peers, while the 5-tuple describes the communication path between the client and the server. On the client, the 5-tuple uses the client's host transport address; on the server, the 5-tuple uses the client's server-reflexive transport address. The relayed transport address MUST be unique across all allocations so it can be used to uniquely identify the allocation, and an allocation in this context can be either a single or dual allocation.",
      "ja": "リレーされたトランスポートアドレスは、ピアとの通信用にサーバーによって割り当てられたトランスポートアドレスであり、5タプルはクライアントとサーバー間の通信パスを記述します。 クライアントでは、5タプルはクライアントのホストトランスポートアドレスを使用します。 サーバーでは、5タプルはクライアントのサーバー反射トランスポートアドレスを使用します。 中継されたトランスポートアドレスは、すべての割り当てにわたって一意でなければならないため、割り当てを一意に識別するために使用でき、このコンテキストでの割り当ては、単一割り当てまたは二重割り当てのいずれかになります。"
    },
    {
      "indent": 3,
      "text": "The authentication information (e.g., username, password, realm, and nonce) is used to both verify subsequent requests and to compute the message integrity of responses. The username, realm, and nonce values are initially those used in the authenticated Allocate request that creates the allocation, though the server can change the nonce value during the lifetime of the allocation using a 438 (Stale Nonce) reply. For security reasons, the server MUST NOT store the password explicitly and MUST store the key value, which is a cryptographic hash over the username, realm, and password (see Section 16.1.3 of [RFC8489]).",
      "ja": "認証情報（ユーザー名、パスワード、レルム、ノンスなど）は、後続の要求を検証し、応答のメッセージ整合性を計算するために使用されます。 ユーザー名、レルム、ナンスの値は、最初は割り当てを作成する認証されたAllocateリクエストで使用されますが、サーバーは438（Stale Nonce）応答を使用して割り当ての有効期間中にノンスの値を変更できます。 セキュリティ上の理由から、サーバーはパスワードを明示的に保存してはならず、ユーザー名、レルム、パスワードの暗号化ハッシュであるキー値を保存しなければなりません（[RFC8489]のセクション16.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that if the response contains a PASSWORD-ALGORITHMS attribute and this attribute contains both MD5 and SHA-256 algorithms, and the client also supports both the algorithms, the request MUST contain a PASSWORD-ALGORITHM attribute with the SHA-256 algorithm.",
      "ja": "応答にPASSWORD-ALGORITHMS属性が含まれ、この属性にMD5アルゴリズムとSHA-256アルゴリズムの両方が含まれ、クライアントも両方のアルゴリズムをサポートしている場合、要求にはSHA-256アルゴリズムのPASSWORD-ALGORITHM属性が含まれなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The time-to-expiry is the time in seconds left until the allocation expires. Each Allocate or Refresh transaction sets this timer, which then ticks down towards zero. By default, each Allocate or Refresh transaction resets this timer to the default lifetime value of 600 seconds (10 minutes), but the client can request a different value in the Allocate and Refresh request. Allocations can only be refreshed using the Refresh request; sending data to a peer does not refresh an allocation. When an allocation expires, the state data associated with the allocation can be freed.",
      "ja": "有効期限は、割り当てが期限切れになるまでの残り時間（秒単位）です。 各割り当てまたは更新トランザクションはこのタイマーを設定し、その後ゼロに向かって進みます。 デフォルトでは、各AllocateまたはRefreshトランザクションはこのタイマーをデフォルトのライフタイム値である600秒（10分）にリセットしますが、クライアントはAllocate and Refresh要求で異なる値を要求できます。 割り当ては、更新要求を使用してのみ更新できます。 ピアにデータを送信しても、割り当ては更新されません。 割り当てが期限切れになると、割り当てに関連付けられた状態データを解放できます。"
    },
    {
      "indent": 3,
      "text": "The list of permissions is described in Section 9 and the list of channels is described in Section 12.",
      "ja": "許可のリストについてはセクション9で説明し、チャネルのリストについてはセクション12で説明します。"
    },
    {
      "indent": 0,
      "text": "7. Creating an Allocation",
      "section_title": true,
      "ja": "7. 割り当ての作成"
    },
    {
      "indent": 3,
      "text": "An allocation on the server is created using an Allocate transaction.",
      "ja": "サーバー上の割り当ては、Allocateトランザクションを使用して作成されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Sending an Allocate Request",
      "section_title": true,
      "ja": "7.1. 割り当てリクエストの送信"
    },
    {
      "indent": 3,
      "text": "The client forms an Allocate request as follows.",
      "ja": "クライアントは、次のように割り当て要求を作成します。"
    },
    {
      "indent": 3,
      "text": "The client first picks a host transport address. It is RECOMMENDED that the client pick a currently unused transport address, typically by allowing the underlying OS to pick a currently unused port.",
      "ja": "クライアントは最初にホストトランスポートアドレスを選択します。 通常、基盤となるOSが現在未使用のポートを選択できるようにすることにより、クライアントが現在未使用のトランスポートアドレスを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The client then picks a transport protocol that the client supports to use between the client and the server based on the transport protocols supported by the server. Since this specification only allows UDP between the server and the peers, it is RECOMMENDED that the client pick UDP unless it has a reason to use a different transport. One reason to pick a different transport would be that the client believes, either through configuration or discovery or by experiment, that it is unable to contact any TURN server using UDP. See Section 3.1 for more discussion.",
      "ja": "次に、クライアントは、サーバーがサポートするトランスポートプロトコルに基づいて、クライアントとサーバーの間で使用するためにクライアントがサポートするトランスポートプロトコルを選択します。 この仕様ではサーバーとピア間のUDPのみが許可されているため、クライアントが別のトランスポートを使用する理由がない限り、UDPを選択することをお勧めします。 別のトランスポートを選択する理由の1つは、クライアントが、構成またはディスカバリーを介して、または実験により、UDPを使用してTURNサーバーに接続できないと考えていることです。 詳細については、セクション3.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client also picks a server transport address, which SHOULD be done as follows. The client uses one or more procedures described in [RFC8155] to discover a TURN server and uses the TURN server resolution mechanism defined in [RFC5928] and [RFC7350] to get a list of server transport addresses that can be tried to create a TURN allocation.",
      "ja": "また、クライアントはサーバートランスポートアドレスを選択します。これは次のように実行する必要があります。 クライアントは、[RFC8155]で説明されている1つ以上の手順を使用してTURNサーバーを検出し、[RFC5928]および[RFC7350]で定義されたTURNサーバー解決メカニズムを使用して、TURN割り当てを作成できるサーバートランスポートアドレスのリストを取得します 。"
    },
    {
      "indent": 3,
      "text": "The client MUST include a REQUESTED-TRANSPORT attribute in the request. This attribute specifies the transport protocol between the server and the peers (note that this is *not* the transport protocol that appears in the 5-tuple). In this specification, the REQUESTED-TRANSPORT type is always UDP. This attribute is included to allow future extensions to specify other protocols.",
      "ja": "クライアントは、リクエストにREQUESTED-TRANSPORT属性を含めなければなりません。 この属性は、サーバーとピア間のトランスポートプロトコルを指定します（これは、5タプルに表示されるトランスポートプロトコルではないことに注意してください）。 この仕様では、REQUESTED-TRANSPORTタイプは常にUDPです。 この属性は、将来の拡張が他のプロトコルを指定できるようにするために含まれています。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to obtain a relayed transport address of a specific address type, then it includes a REQUESTED-ADDRESS-FAMILY attribute in the request. This attribute indicates the specific address type the client wishes the TURN server to allocate. Clients MUST NOT include more than one REQUESTED-ADDRESS-FAMILY attribute in an Allocate request. Clients MUST NOT include a REQUESTED-ADDRESS-FAMILY attribute in an Allocate request that contains a RESERVATION-TOKEN attribute, for the reason that the server uses the previously reserved transport address corresponding to the included token and the client cannot obtain a relayed transport address of a specific address type.",
      "ja": "クライアントが特定のアドレスタイプの中継されたトランスポートアドレスを取得する場合、リクエストにREQUESTED-ADDRESS-FAMILY属性が含まれます。 この属性は、クライアントがTURNサーバーに割り当てたい特定のアドレスタイプを示します。 クライアントは、Allocate要求に複数のREQUESTED-ADDRESS-FAMILY属性を含めてはいけません。 サーバーは、含まれるトークンに対応する以前に予約されたトランスポートアドレスを使用し、クライアントが次の中継トランスポートアドレスを取得できないため、RESERVATION-TOKEN属性を含むAllocate要求にREQUESTED-ADDRESS-FAMILY属性を含めてはなりません。 特定のアドレスタイプ。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to obtain one IPv6 and one IPv4 relayed transport address, then it includes an ADDITIONAL-ADDRESS-FAMILY attribute in the request. This attribute specifies that the server must allocate both address types. The attribute value in the ADDITIONAL-ADDRESS-FAMILY MUST be set to 0x02 (IPv6 address family). Clients MUST NOT include REQUESTED-ADDRESS-FAMILY and ADDITIONAL-ADDRESS-FAMILY attributes in the same request. Clients MUST NOT include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate request that contains a RESERVATION-TOKEN attribute. Clients MUST NOT include the ADDITIONAL-ADDRESS-FAMILY attribute in an Allocate request that contains an EVEN-PORT attribute with the R (Reserved) bit set to 1. The reason behind the restriction is that if the EVEN-PORT attribute with the R bit set to 1 is allowed with the ADDITIONAL-ADDRESS-FAMILY attribute, two tokens will have to be returned in the success response and changes will be required to the way the RESERVATION-TOKEN attribute is handled.",
      "ja": "クライアントが1つのIPv6および1つのIPv4中継トランスポートアドレスを取得する場合、リクエストにADDITIONAL-ADDRESS-FAMILY属性が含まれます。この属性は、サーバーが両方のアドレスタイプを割り当てる必要があることを指定します。 ADDITIONAL-ADDRESS-FAMILYの属性値は0x02（IPv6アドレスファミリ）に設定する必要があります。クライアントは、同じリクエストにREQUESTED-ADDRESS-FAMILYおよびADDITIONAL-ADDRESS-FAMILY属性を含めてはいけません。クライアントは、RESERVATION-TOKEN属性を含むAllocate要求にADDITIONAL-ADDRESS-FAMILY属性を含めてはなりません。クライアントは、R（予約済み）ビットが1に設定されたEVEN-PORT属性を含むAllocate要求に、ADDITIONAL-ADDRESS-FAMILY属性を含めてはなりません（MUST NOT）。 ADDITIONAL-ADDRESS-FAMILY属性では1に設定できます。成功応答で2つのトークンを返す必要があり、RESERVATION-TOKEN属性の処理方法を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client wishes the server to initialize the time-to-expiry field of the allocation to some value other than the default lifetime, then it MAY include a LIFETIME attribute specifying its desired value. This is just a hint, and the server may elect to use a different value. Note that the server will ignore requests to initialize the field to less than the default value.",
      "ja": "クライアントが、サーバーに割り当ての有効期限フィールドをデフォルトの有効期間以外の値に初期化することを希望する場合、希望する値を指定するLIFETIME属性を含めることができます。 これは単なるヒントであり、サーバーは別の値を使用することを選択できます。 サーバーは、フィールドをデフォルト値未満に初期化する要求を無視することに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to later use the DONT-FRAGMENT attribute in one or more Send indications on this allocation, then the client SHOULD include the DONT-FRAGMENT attribute in the Allocate request. This allows the client to test whether this attribute is supported by the server.",
      "ja": "クライアントがこの割り当ての1つ以上の送信指示でDONT-FRAGMENT属性を後で使用する場合、クライアントは割り当て要求にDONT-FRAGMENT属性を含める必要があります。 これにより、クライアントはこの属性がサーバーでサポートされているかどうかをテストできます。"
    },
    {
      "indent": 3,
      "text": "If the client requires the port number of the relayed transport address to be even, the client includes the EVEN-PORT attribute. If this attribute is not included, then the port can be even or odd. By setting the R bit in the EVEN-PORT attribute to 1, the client can request that the server reserve the next highest port number (on the same IP address) for a subsequent allocation. If the R bit is 0, no such request is made.",
      "ja": "クライアントが中継されるトランスポートアドレスのポート番号を偶数にする必要がある場合、クライアントにはEVEN-PORT属性が含まれます。 この属性が含まれていない場合、ポートは偶数でも奇数でもかまいません。 EVEN-PORT属性のRビットを1に設定することにより、クライアントは、サーバーが次の割り当てのために（同じIPアドレスで）次に大きいポート番号を予約するように要求できます。 Rビットが0の場合、そのような要求は行われません。"
    },
    {
      "indent": 3,
      "text": "The client MAY also include a RESERVATION-TOKEN attribute in the request to ask the server to use a previously reserved port for the allocation. If the RESERVATION-TOKEN attribute is included, then the client MUST omit the EVEN-PORT attribute.",
      "ja": "クライアントは、割り当てに以前に予約されたポートを使用するようサーバーに要求するために、リクエストにRESERVATION-TOKEN属性を含めることもできます。 RESERVATION-TOKEN属性が含まれている場合、クライアントはEVEN-PORT属性を省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once constructed, the client sends the Allocate request on the 5-tuple.",
      "ja": "構築されると、クライアントは5タプルでAllocateリクエストを送信します。"
    },
    {
      "indent": 0,
      "text": "7.2. Receiving an Allocate Request",
      "section_title": true,
      "ja": "7.2. 割り当て要求の受信"
    },
    {
      "indent": 3,
      "text": "When the server receives an Allocate request, it performs the following checks:",
      "ja": "サーバーがAllocate要求を受信すると、次のチェックを実行します。"
    },
    {
      "indent": 3,
      "text": "1. The TURN server provided by the local or access network MAY allow an unauthenticated request in order to accept Allocation requests from new and/or guest users in the network who do not necessarily possess long-term credentials for STUN authentication. The security implications of STUN and making STUN authentication optional are discussed in [RFC8155]. Otherwise, the server MUST require that the request be authenticated. If the request is authenticated, the authentication MUST be done either using the long-term credential mechanism of [RFC8489] or using the STUN Extension for Third-Party Authorization [RFC7635] unless the client and server agree to use another mechanism through some procedure outside the scope of this document.",
      "ja": "1. ローカルネットワークまたはアクセスネットワークによって提供されるTURNサーバーは、ネットワーク内の新規および/またはゲストユーザーからの割り当て要求を受け入れるために、認証されていない要求を許可する場合があります。 STUNのセキュリティへの影響とSTUN認証をオプションにすることは[RFC8155]で議論されています。 それ以外の場合、サーバーは要求の認証を要求する必要があります。 要求が認証される場合、[RFC8489]の長期資格情報メカニズムを使用するか、または第三者認証[RFC7635]のSTUN拡張を使用して、外部の何らかの手順で別のメカニズムを使用することに同意しない限り、認証を行う必要があります このドキュメントの範囲。"
    },
    {
      "indent": 3,
      "text": "2. The server checks if the 5-tuple is currently in use by an existing allocation. If yes, the server rejects the request with a 437 (Allocation Mismatch) error.",
      "ja": "2. サーバーは、既存の割り当てで5タプルが現在使用されているかどうかを確認します。 はいの場合、サーバーは437（Allocation Mismatch）エラーでリクエストを拒否します。"
    },
    {
      "indent": 3,
      "text": "3. The server checks if the request contains a REQUESTED-TRANSPORT attribute. If the REQUESTED-TRANSPORT attribute is not included or is malformed, the server rejects the request with a 400 (Bad Request) error. Otherwise, if the attribute is included but specifies a protocol that is not supported by the server, the server rejects the request with a 442 (Unsupported Transport Protocol) error.",
      "ja": "3. サーバーは、要求にREQUESTED-TRANSPORT属性が含まれているかどうかを確認します。 REQUESTED-TRANSPORT属性が含まれていないか、形式が正しくない場合、サーバーは400（Bad Request）エラーで要求を拒否します。 それ以外の場合、属性は含まれているが、サーバーでサポートされていないプロトコルを指定している場合、サーバーは442（サポートされていないトランスポートプロトコル）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "4. The request may contain a DONT-FRAGMENT attribute. If it does, but the server does not support sending UDP datagrams with the DF bit set to 1 (see Sections 14 and 15), then the server treats the DONT-FRAGMENT attribute in the Allocate request as an unknown comprehension-required attribute.",
      "ja": "4. 要求にはDONT-FRAGMENT属性が含まれる場合があります。 サポートしているが、サーバーがDFビットを1に設定したUDPデータグラムの送信をサポートしていない場合（セクション14および15を参照）、サーバーはAllocateリクエストのDONT-FRAGMENT属性を不明な内包必須属性として扱います。"
    },
    {
      "indent": 3,
      "text": "5. The server checks if the request contains a RESERVATION-TOKEN attribute. If yes, and the request also contains an EVEN-PORT or REQUESTED-ADDRESS-FAMILY or ADDITIONAL-ADDRESS-FAMILY attribute, the server rejects the request with a 400 (Bad Request) error. Otherwise, it checks to see if the token is valid (i.e., the token is in range and has not expired, and the corresponding relayed transport address is still available). If the token is not valid for some reason, the server rejects the request with a 508 (Insufficient Capacity) error.",
      "ja": "5. サーバーは、リクエストにRESERVATION-TOKEN属性が含まれているかどうかを確認します。 「はい」で、リクエストにEVEN-PORTまたはREQUESTED-ADDRESS-FAMILYまたはADDITIONAL-ADDRESS-FAMILY属性も含まれている場合、サーバーは400（Bad Request）エラーでリクエストを拒否します。 それ以外の場合、トークンが有効かどうかを確認します（つまり、トークンは範囲内にあり、有効期限が切れておらず、対応する中継されたトランスポートアドレスはまだ利用可能です）。 トークンが何らかの理由で有効でない場合、サーバーは508（Insufficient Capacity）エラーでリクエストを拒否します。"
    },
    {
      "indent": 3,
      "text": "6. The server checks if the request contains both REQUESTED-ADDRESS-FAMILY and ADDITIONAL-ADDRESS-FAMILY attributes. If yes, then the server rejects the request with a 400 (Bad Request) error.",
      "ja": "6. サーバーは、要求にREQUESTED-ADDRESS-FAMILY属性とADDITIONAL-ADDRESS-FAMILY属性の両方が含まれているかどうかを確認します。 「はい」の場合、サーバーは400（Bad Request）エラーでリクエストを拒否します。"
    },
    {
      "indent": 3,
      "text": "7. If the server does not support the address family requested by the client in REQUESTED-ADDRESS-FAMILY, or if the allocation of the requested address family is disabled by local policy, it MUST generate an Allocate error response, and it MUST include an ERROR-CODE attribute with the 440 (Address Family not Supported) response code. If the REQUESTED-ADDRESS-FAMILY attribute is absent and the server does not support the IPv4 address family, the server MUST include an ERROR-CODE attribute with the 440 (Address Family not Supported) response code. If the REQUESTED-ADDRESS-FAMILY attribute is absent and the server supports the IPv4 address family, the server MUST allocate an IPv4 relayed transport address for the TURN client.",
      "ja": "7. サーバーがREQUESTED-ADDRESS-FAMILYでクライアントによって要求されたアドレスファミリをサポートしていない場合、または要求されたアドレスファミリの割り当てがローカルポリシーによって無効になっている場合、Allocateエラー応答を生成し、エラーを含めなければなりません 440（アドレスファミリはサポートされていません）応答コードを持つCODE属性。 REQUESTED-ADDRESS-FAMILY属性が存在せず、サーバーがIPv4アドレスファミリをサポートしていない場合、サーバーは440（アドレスファミリがサポートされていない）応答コードにERROR-CODE属性を含める必要があります。 REQUESTED-ADDRESS-FAMILY属性がなく、サーバーがIPv4アドレスファミリをサポートしている場合、サーバーはTURNクライアントにIPv4中継トランスポートアドレスを割り当てなければなりません。"
    },
    {
      "indent": 3,
      "text": "8. The server checks if the request contains an EVEN-PORT attribute with the R bit set to 1. If yes, and the request also contains an ADDITIONAL-ADDRESS-FAMILY attribute, the server rejects the request with a 400 (Bad Request) error. Otherwise, the server checks if it can satisfy the request (i.e., can allocate a relayed transport address as described below). If the server cannot satisfy the request, then the server rejects the request with a 508 (Insufficient Capacity) error.",
      "ja": "8. サーバーは、リクエストにRビットが1に設定されたEVEN-PORT属性が含まれているかどうかを確認します。yesで、リクエストにADDITIONAL-ADDRESS-FAMILY属性も含まれる場合、サーバーは400（Bad Request）エラーでリクエストを拒否します。 それ以外の場合、サーバーは、要求を満たすことができるかどうかを確認します（つまり、以下に説明するように中継されたトランスポートアドレスを割り当てることができます）。 サーバーが要求を満たすことができない場合、サーバーは508（Insufficient Capacity）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "9. The server checks if the request contains an ADDITIONAL-ADDRESS-FAMILY attribute. If yes, and the attribute value is 0x01 (IPv4 address family), then the server rejects the request with a 400 (Bad Request) error. Otherwise, the server checks if it can allocate relayed transport addresses of both address types. If the server cannot satisfy the request, then the server rejects the request with a 508 (Insufficient Capacity) error. If the server can partially meet the request, i.e., if it can only allocate one relayed transport address of a specific address type, then it includes ADDRESS-ERROR-CODE attribute in the success response to inform the client the reason for partial failure of the request. The error code value signaled in the ADDRESS-ERROR-CODE attribute could be 440 (Address Family not Supported) or 508 (Insufficient Capacity). If the server can fully meet the request, then the server allocates one IPv4 and one IPv6 relay address and returns an Allocate success response containing the relayed transport addresses assigned to the dual allocation in two XOR-RELAYED-ADDRESS attributes.",
      "ja": "9. サーバーは、リクエストにADDITIONAL-ADDRESS-FAMILY属性が含まれているかどうかを確認します。はい、属性値が0x01（IPv4アドレスファミリ）の場合、サーバーは400（Bad Request）エラーで要求を拒否します。それ以外の場合、サーバーは両方のアドレスタイプの中継トランスポートアドレスを割り当てることができるかどうかを確認します。サーバーが要求を満たすことができない場合、サーバーは508（Insufficient Capacity）エラーで要求を拒否します。サーバーが要求を部分的に満たすことができる場合、つまり、特定のアドレスタイプの中継されたトランスポートアドレスを1つしか割り当てることができない場合、成功応答にADDRESS-ERROR-CODE属性を含めて、クライアントに部分的な失敗の理由を通知しますリクエスト。 ADDRESS-ERROR-CODE属性で通知されるエラーコード値は、440（サポートされていないアドレスファミリ）または508（容量不足）です。サーバーが要求を完全に満たすことができる場合、サーバーは1つのIPv4および1つのIPv6リレーアドレスを割り当て、2つのXOR-RELAYED-ADDRESS属性で二重割り当てに割り当てられたリレーされたトランスポートアドレスを含むAllocate成功応答を返します。"
    },
    {
      "indent": 3,
      "text": "10. At any point, the server MAY choose to reject the request with a 486 (Allocation Quota Reached) error if it feels the client is trying to exceed some locally defined allocation quota. The server is free to define this allocation quota any way it wishes, but it SHOULD define it based on the username used to authenticate the request and not on the client's transport address.",
      "ja": "10. サーバーは、クライアントがローカルで定義された割り当てクォータを超えようとしていると感じた場合、486（割り当てクォータに達しました）エラーでリクエストを拒否することを選択できます。 サーバーは、この割り当てクォータを自由に定義できますが、クライアントのトランスポートアドレスではなく、要求の認証に使用されるユーザー名に基づいて定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "11. Also, at any point, the server MAY choose to reject the request with a 300 (Try Alternate) error if it wishes to redirect the client to a different server. The use of this error code and attribute follows the specification in [RFC8489].",
      "ja": "11. また、任意の時点で、クライアントを別のサーバーにリダイレクトする場合、サーバーは300（代替を試行）エラーでリクエストを拒否することを選択できます。 このエラーコードと属性の使用は、[RFC8489]の仕様に従います。"
    },
    {
      "indent": 3,
      "text": "If all the checks pass, the server creates the allocation. The 5-tuple is set to the 5-tuple from the Allocate request, while the list of permissions and the list of channels are initially empty.",
      "ja": "すべてのチェックに合格すると、サーバーは割り当てを作成します。 5タプルは、割り当て要求からの5タプルに設定されますが、許可のリストとチャネルのリストは最初は空です。"
    },
    {
      "indent": 3,
      "text": "The server chooses a relayed transport address for the allocation as follows:",
      "ja": "サーバーは、次のように割り当ての中継トランスポートアドレスを選択します。"
    },
    {
      "indent": 3,
      "text": "* If the request contains a RESERVATION-TOKEN attribute, the server uses the previously reserved transport address corresponding to the included token (if it is still available). Note that the reservation is a server-wide reservation and is not specific to a particular allocation since the Allocate request containing the RESERVATION-TOKEN uses a different 5-tuple than the Allocate request that made the reservation. The 5-tuple for the Allocate request containing the RESERVATION-TOKEN attribute can be any allowed 5-tuple; it can use a different client IP address and port, a different transport protocol, and even a different server IP address and port (provided, of course, that the server IP address and port are ones on which the server is listening for TURN requests).",
      "ja": "* 要求にRESERVATION-TOKEN属性が含まれている場合、サーバーは、含まれているトークンに対応する以前に予約されたトランスポートアドレスを使用します（まだ使用可能な場合）。 予約はサーバー全体の予約であり、RESERVATION-TOKENを含むAllocate要求は予約を行ったAllocate要求とは異なる5タプルを使用するため、特定の割り当てに固有ではないことに注意してください。 RESERVATION-TOKEN属性を含むAllocateリクエストの5タプルには、許可されている5タプルを使用できます。 異なるクライアントIPアドレスとポート、異なるトランスポートプロトコル、さらに異なるサーバーIPアドレスとポートを使用できます（もちろん、サーバーIPアドレスとポートがサーバーがTURN要求をリッスンしているものである場合） 。"
    },
    {
      "indent": 3,
      "text": "* If the request contains an EVEN-PORT attribute with the R bit set to 0, then the server allocates a relayed transport address with an even port number.",
      "ja": "* 要求にRビットが0に設定されたEVEN-PORT属性が含まれている場合、サーバーは中継されたトランスポートアドレスに偶数のポート番号を割り当てます。"
    },
    {
      "indent": 3,
      "text": "* If the request contains an EVEN-PORT attribute with the R bit set to 1, then the server looks for a pair of port numbers N and N+1 on the same IP address, where N is even. Port N is used in the current allocation, while the relayed transport address with port N+1 is assigned a token and reserved for a future allocation. The server MUST hold this reservation for at least 30 seconds and MAY choose to hold longer (e.g., until the allocation with port N expires). The server then includes the token in a RESERVATION-TOKEN attribute in the success response.",
      "ja": "* 要求にRビットが1に設定されたEVEN-PORT属性が含まれる場合、サーバーは同じIPアドレスでNとN + 1のポート番号のペアを探します（Nは偶数）。 ポートNは現在の割り当てで使用されますが、ポートN + 1の中継トランスポートアドレスにはトークンが割り当てられ、将来の割り当てのために予約されています。 サーバーは、この予約を少なくとも30秒間保持しなければならず、より長く保持することを選択できます（たとえば、ポートNの割り当てが期限切れになるまで）。 サーバーは、成功応答のRESERVATION-TOKEN属性にトークンを含めます。"
    },
    {
      "indent": 3,
      "text": "* Otherwise, the server allocates any available relayed transport address.",
      "ja": "* それ以外の場合、サーバーは利用可能な中継トランスポートアドレスを割り当てます。"
    },
    {
      "indent": 3,
      "text": "In all cases, the server SHOULD only allocate ports from the range 49152 - 65535 (the Dynamic and/or Private Port range [PORT-NUMBERS]), unless the TURN server application knows, through some means not specified here, that other applications running on the same host as the TURN server application will not be impacted by allocating ports outside this range. This condition can often be satisfied by running the TURN server application on a dedicated machine and/or by arranging that any other applications on the machine allocate ports before the TURN server application starts. In any case, the TURN server SHOULD NOT allocate ports in the range 0 - 1023 (the Well-Known Port range) to discourage clients from using TURN to run standard services.",
      "ja": "いずれの場合も、TURNサーバーアプリケーションがここで指定されていない何らかの方法で他のアプリケーションが実行されていることを知らない限り、サーバーは49152から65535の範囲（動的および/またはプライベートポート範囲[PORT-NUMBERS]）からのみポートを割り当てる必要があります TURNサーバーアプリケーションと同じホスト上では、この範囲外のポートを割り当てても影響を受けません。 多くの場合、この条件は、TURNサーバーアプリケーションを専用マシンで実行するか、マシン上の他のアプリケーションがTURNサーバーアプリケーションを開始する前にポートを割り当てるように調整することで満たすことができます。 いずれの場合でも、TURNサーバーは、クライアントがTURNを使用して標準サービスを実行することを思いとどまらせるために、0から1023の範囲（既知のポート範囲）のポートを割り振るべきではありません。"
    },
    {
      "indent": 6,
      "text": "| NOTE: The use of randomized port assignments to avoid certain | types of attacks is described in [RFC6056]. It is RECOMMENDED | that a TURN server implement a randomized port assignment | algorithm from [RFC6056]. This is especially applicable to | servers that choose to pre-allocate a number of ports from the | underlying OS and then later assign them to allocations; for | example, a server may choose this technique to implement the | EVEN-PORT attribute.",
      "ja": "| 注：ランダム化されたポート割り当てを使用して特定の 攻撃の種類は[RFC6056]で説明されています。 お勧めです| TURNサーバーがランダム化ポート割り当てを実装すること| [RFC6056]のアルゴリズム。 これは特に適用されます| |から多数のポートを事前に割り振ることを選択するサーバー 基盤となるOSを割り当て、後で割り当てに割り当てます。 のために| たとえば、サーバーはこの手法を選択して、 EVEN-PORT属性。"
    },
    {
      "indent": 3,
      "text": "The server determines the initial value of the time-to-expiry field as follows. If the request contains a LIFETIME attribute, then the server computes the minimum of the client's proposed lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the server uses the computed lifetime as the initial value of the time-to-expiry field. Otherwise, the server uses the default lifetime. It is RECOMMENDED that the server use a maximum allowed lifetime value of no more than 3600 seconds (1 hour). Servers that implement allocation quotas or charge users for allocations in some way may wish to use a smaller maximum allowed lifetime (perhaps as small as the default lifetime) to more quickly remove orphaned allocations (that is, allocations where the corresponding client has crashed or terminated, or the client connection has been lost for some reason). Also, note that the time-to-expiry is recomputed with each successful Refresh request, and thus, the value computed here applies only until the first refresh.",
      "ja": "サーバーは、有効期限までの時間フィールドの初期値を次のように決定します。要求にLIFETIME属性が含まれている場合、サーバーはクライアントの提案された有効期間の最小値とサーバーの最大許容有効期間を計算します。この計算された値がデフォルトのライフタイムよりも大きい場合、サーバーは、計算されたライフタイムを有効期限フィールドの初期値として使用します。それ以外の場合、サーバーはデフォルトの有効期間を使用します。サーバーは3600秒（1時間）以下の最大許容ライフタイム値を使用することをお勧めします。割り当てクォータを実装するか、何らかの方法でユーザーに割り当てを請求するサーバーは、孤立した割り当て（つまり、対応するクライアントがクラッシュまたは終了した割り当て）をより迅速に削除するために、最大許容有効期間（デフォルトの有効期間と同じくらい短い）を使用したい場合があります、または何らかの理由でクライアント接続が失われました）。また、有効な更新リクエストごとに有効期限が再計算されるため、ここで計算される値は最初の更新までしか適用されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Once the allocation is created, the server replies with a success response. The success response contains:",
      "ja": "割り当てが作成されると、サーバーは成功応答で応答します。 成功応答には以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "* An XOR-RELAYED-ADDRESS attribute containing the relayed transport address or two XOR-RELAYED-ADDRESS attributes containing the relayed transport addresses.",
      "ja": "* リレーされたトランスポートアドレスを含むXOR-RELAYED-ADDRESS属性、またはリレーされたトランスポートアドレスを含む2つのXOR-RELAYED-ADDRESS属性。"
    },
    {
      "indent": 3,
      "text": "* A LIFETIME attribute containing the current value of the time-to-expiry timer.",
      "ja": "* 期限切れタイマーの現在の値を含むLIFETIME属性。"
    },
    {
      "indent": 3,
      "text": "* A RESERVATION-TOKEN attribute (if a second relayed transport address was reserved).",
      "ja": "* RESERVATION-TOKEN属性（2番目の中継トランスポートアドレスが予約されている場合）。"
    },
    {
      "indent": 3,
      "text": "* An XOR-MAPPED-ADDRESS attribute containing the client's IP address and port (from the 5-tuple).",
      "ja": "* クライアントのIPアドレスとポート（5タプルから）を含むXOR-MAPPED-ADDRESS属性。"
    },
    {
      "indent": 6,
      "text": "| NOTE: The XOR-MAPPED-ADDRESS attribute is included in the | response as a convenience to the client. TURN itself does not | make use of this value, but clients running ICE can often need | this value and can thus avoid having to do an extra Binding | transaction with some STUN server to learn it.",
      "ja": "| 注：XOR-MAPPED-ADDRESS属性は| クライアントの利便性としての応答。 TURN自体は| この値を使用しますが、ICEを実行しているクライアントは多くの場合必要です。 この値により、追加のBinding | 学習するために、STUNサーバーとのトランザクション。"
    },
    {
      "indent": 3,
      "text": "The response (either success or error) is sent back to the client on the 5-tuple.",
      "ja": "応答（成功またはエラー）は、5タプルでクライアントに送り返されます。"
    },
    {
      "indent": 6,
      "text": "| NOTE: When the Allocate request is sent over UDP, [RFC8489] | requires that the server handle the possible retransmissions of | the request so that retransmissions do not cause multiple | allocations to be created. Implementations may achieve this | using the so-called \"stateless stack approach\" as follows. To | detect retransmissions when the original request was successful | in creating an allocation, the server can store the transaction | id that created the request with the allocation data and | compare it with incoming Allocate requests on the same 5-tuple. | Once such a request is detected, the server can stop parsing | the request and immediately generate a success response. When | building this response, the value of the LIFETIME attribute can | be taken from the time-to-expiry field in the allocate state | data, even though this value may differ slightly from the | LIFETIME value originally returned. In addition, the server | may need to store an indication of any reservation token | returned in the original response so that this may be returned | in any retransmitted responses. | | For the case where the original request was unsuccessful in | creating an allocation, the server may choose to do nothing | special. Note, however, that there is a rare case where the | server rejects the original request but accepts the | retransmitted request (because conditions have changed in the | brief intervening time period). If the client receives the | first failure response, it will ignore the second (success) | response and believe that an allocation was not created. An | allocation created in this manner will eventually time out | since the client will not refresh it. Furthermore, if the | client later retries with the same 5-tuple but a different | transaction id, it will receive a 437 (Allocation Mismatch) | error response, which will cause it to retry with a different | 5-tuple. The server may use a smaller maximum lifetime value | to minimize the lifetime of allocations \"orphaned\" in this | manner.",
      "ja": "|注：割り当て要求がUDPを介して送信される場合、[RFC8489] |サーバーが可能な再送信を処理する必要があります|再送信が複数の原因にならないように要求を処理します。作成される割り当て。実装はこれを達成するかもしれません|いわゆる「ステートレススタックアプローチ」を次のように使用します。へ|元のリクエストが成功したときに再送信を検出する割り当てを作成する際に、サーバーはトランザクションを保存できます|割り当てデータと|リクエストを作成したID同じ5タプルの着信Allocate要求と比較します。 |このような要求が検出されると、サーバーは解析を停止できます|リクエストを送信し、すぐに成功レスポンスを生成します。いつ|この応答を構築すると、LIFETIME属性の値は|割り当て状態の有効期限フィールドから取得する|この値は、|とはわずかに異なる場合がありますが、元々返されたLIFETIME値。さらに、サーバー|予約トークンの表示を保存する必要があります|これが返されるように、元の応答で返された|再送された応答。 | |元の要求が失敗した場合|割り当てを作成すると、サーバーは何もしないことを選択できます。特別。ただし、|がまれにあることに注意してください。サーバーは元の要求を拒否しますが、受け入れます|再送信されたリクエスト（条件が短時間の間に変更されたため）。クライアントが|を受信した場合最初の失敗応答、2番目（成功）を無視します|応答し、割り当てが作成されていないと考えています。 |この方法で作成された割り当ては、最終的にタイムアウトします|クライアントが更新しないためです。さらに、|クライアントは後で同じ5タプルで異なる再試行を行います|トランザクションID、それは437（割り当ての不一致）を受け取ります|エラー応答。異なるエラーで再試行します。 5タプル。サーバーは、より短い最大ライフタイム値を使用する場合があります。これで「孤立」した割り当ての存続期間を最小化する|マナー。"
    },
    {
      "indent": 0,
      "text": "7.3. Receiving an Allocate Success Response",
      "section_title": true,
      "ja": "7.3. 割り当て成功応答の受信"
    },
    {
      "indent": 3,
      "text": "If the client receives an Allocate success response, then it MUST check that the mapped address and the relayed transport address or addresses are part of an address family or families that the client understands and is prepared to handle. If these addresses are not part of an address family or families that the client is prepared to handle, then the client MUST delete the allocation (Section 8) and MUST NOT attempt to create another allocation on that server until it believes the mismatch has been fixed.",
      "ja": "クライアントがAllocate成功応答を受信した場合、マッピングされたアドレスと中継されたトランスポートアドレスは、クライアントが理解し、処理できるアドレスファミリの一部であることを確認する必要があります。 これらのアドレスが、クライアントが処理する準備ができているアドレスファミリの一部ではない場合、クライアントは割り当てを削除する必要があり（セクション8）、不一致が修正されたと判断されるまで、そのサーバーに別の割り当てを作成してはなりません 。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the client creates its own copy of the allocation data structure to track what is happening on the server. In particular, the client needs to remember the actual lifetime received back from the server, rather than the value sent to the server in the request. The client must also remember the 5-tuple used for the request and the username and password it used to authenticate the request to ensure that it reuses them for subsequent messages. The client also needs to track the channels and permissions it establishes on the server.",
      "ja": "それ以外の場合、クライアントは割り当てデータ構造の独自のコピーを作成して、サーバーで発生していることを追跡します。 特に、クライアントは、リクエストでサーバーに送信された値ではなく、サーバーから返された実際の有効期間を記憶する必要があります。 また、クライアントは、リクエストに使用される5タプルと、リクエストの認証に使用されるユーザー名とパスワードを覚えて、後続のメッセージで再利用できるようにする必要があります。 また、クライアントは、サーバー上で確立したチャネルと許可を追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client receives an Allocate success response but with an ADDRESS-ERROR-CODE attribute in the response and the error code value signaled in the ADDRESS-ERROR-CODE attribute is 440 (Address Family not Supported), the client MUST NOT retry its request for the rejected address type. If the client receives an ADDRESS-ERROR-CODE attribute in the response and the error code value signaled in the ADDRESS-ERROR-CODE attribute is 508 (Insufficient Capacity), the client SHOULD wait at least 1 minute before trying to request any more allocations on this server for the rejected address type.",
      "ja": "クライアントが成功の割り当て応答を受信したが、応答にADDRESS-ERROR-CODE属性があり、ADDRESS-ERROR-CODE属性で通知されたエラーコード値が440（アドレスファミリがサポートされていない）の場合、クライアントは要求を再試行してはならない 拒否されたアドレスタイプの場合。 クライアントが応答でADDRESS-ERROR-CODE属性を受信し、ADDRESS-ERROR-CODE属性で通知されたエラーコード値が508（Insufficient Capacity）である場合、クライアントは、追加の割り当てを要求する前に少なくとも1分間待機する必要があります 拒否されたアドレスタイプのこのサーバー上。"
    },
    {
      "indent": 3,
      "text": "The client will probably wish to send the relayed transport address to peers (using some method not specified here) so the peers can communicate with it. The client may also wish to use the server-reflexive address it receives in the XOR-MAPPED-ADDRESS attribute in its ICE processing.",
      "ja": "クライアントはおそらく、ここで指定されていない何らかの方法を使用して、中継されたトランスポートアドレスをピアに送信して、ピアがそれと通信できるようにしたいと思うでしょう。 また、クライアントは、ICE処理でXOR-MAPPED-ADDRESS属性で受信したサーバー再帰アドレスを使用することもできます。"
    },
    {
      "indent": 0,
      "text": "7.4. Receiving an Allocate Error Response",
      "section_title": true,
      "ja": "7.4. 割り当てエラー応答の受信"
    },
    {
      "indent": 3,
      "text": "If the client receives an Allocate error response, then the processing depends on the actual error code returned:",
      "ja": "クライアントがAllocateエラー応答を受信した場合、処理は返される実際のエラーコードに依存します。"
    },
    {
      "indent": 3,
      "text": "408 (Request timed out): There is either a problem with the server or a problem reaching the server with the chosen transport. The client considers the current transaction as having failed but MAY choose to retry the Allocate request using a different transport (e.g., TCP instead of UDP).",
      "ja": "408（リクエストがタイムアウトしました）：サーバーに問題があるか、選択したトランスポートでサーバーに到達する問題があります。 クライアントは、現在のトランザクションが失敗したと見なしますが、別のトランスポート（UDPの代わりにTCPなど）を使用してAllocate要求を再試行することを選択できます。"
    },
    {
      "indent": 3,
      "text": "300 (Try Alternate): The server would like the client to use the server specified in the ALTERNATE-SERVER attribute instead. The client considers the current transaction as having failed, but it SHOULD try the Allocate request with the alternate server before trying any other servers (e.g., other servers discovered using the DNS resolution procedures). When trying the Allocate request with the alternate server, the client follows the ALTERNATE-SERVER procedures specified in [RFC8489].",
      "ja": "300（代替を試行）：サーバーは、クライアントがALTERNATE-SERVER属性で指定されたサーバーを代わりに使用することを希望します。 クライアントは現在のトランザクションが失敗したとみなしますが、他のサーバー（DNS解決手順を使用して発見された他のサーバーなど）を試す前に、代替サーバーでAllocate要求を試す必要があります。 代替サーバーでAllocate要求を試みるとき、クライアントは[RFC8489]で指定されたALTERNATE-SERVERプロシージャに従います。"
    },
    {
      "indent": 3,
      "text": "400 (Bad Request): The server believes the client's request is malformed for some reason. The client considers the current transaction as having failed. The client MAY notify the user or operator and SHOULD NOT retry the request with this server until it believes the problem has been fixed.",
      "ja": "400（不良リクエスト）：サーバーは、何らかの理由でクライアントのリクエストが不正な形式であると考えています。 クライアントは、現在のトランザクションが失敗したと見なします。 クライアントはユーザーまたはオペレーターに通知してもよいし、問題が解決されたと信じるまでこのサーバーでリクエストを再試行すべきではない。"
    },
    {
      "indent": 3,
      "text": "401 (Unauthorized): If the client has followed the procedures of the long-term credential mechanism and still gets this error, then the server is not accepting the client's credentials. In this case, the client considers the current transaction as having failed and SHOULD notify the user or operator. The client SHOULD NOT send any further requests to this server until it believes the problem has been fixed.",
      "ja": "401（無許可）：クライアントが長期資格情報メカニズムの手順を実行してもこのエラーが発生する場合、サーバーはクライアントの資格情報を受け入れていません。 この場合、クライアントは現在のトランザクションが失敗したと見なし、ユーザーまたはオペレーターに通知する必要があります。 クライアントは、問題が修正されたと信じるまで、このサーバーにそれ以上のリクエストを送信すべきではありません。"
    },
    {
      "indent": 3,
      "text": "403 (Forbidden): The request is valid, but the server is refusing to perform it, likely due to administrative restrictions. The client considers the current transaction as having failed. The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.",
      "ja": "403（禁止）：要求は有効ですが、サーバーは管理上の制限が原因で実行を拒否しています。 クライアントは、現在のトランザクションが失敗したと見なします。 クライアントはユーザーまたはオペレーターに通知してもよいし、問題が解決されたと信じるまでこのサーバーで同じリクエストを再試行すべきではない。"
    },
    {
      "indent": 3,
      "text": "420 (Unknown Attribute): If the client included a DONT-FRAGMENT attribute in the request and the server rejected the request with a 420 error code and listed the DONT-FRAGMENT attribute in the UNKNOWN-ATTRIBUTES attribute in the error response, then the client now knows that the server does not support the DONT-FRAGMENT attribute. The client considers the current transaction as having failed but MAY choose to retry the Allocate request without the DONT-FRAGMENT attribute.",
      "ja": "420（不明な属性）：クライアントがリクエストにDONT-FRAGMENT属性を含め、サーバーがエラーコード420でリクエストを拒否し、エラー応答のUNKNOWN-ATTRIBUTES属性にDONT-FRAGMENT属性をリストした場合、クライアント サーバーがDONT-FRAGMENT属性をサポートしていないことがわかりました。 クライアントは、現在のトランザクションが失敗したと見なしますが、DONT-FRAGMENT属性なしで割り当て要求を再試行することを選択できます。"
    },
    {
      "indent": 3,
      "text": "437 (Allocation Mismatch): This indicates that the client has picked a 5-tuple that the server sees as already in use. One way this could happen is if an intervening NAT assigned a mapped transport address that was used by another client that recently crashed. The client considers the current transaction as having failed. The client SHOULD pick another client transport address and retry the Allocate request (using a different transaction id). The client SHOULD try three different client transport addresses before giving up on this server. Once the client gives up on the server, it SHOULD NOT try to create another allocation on the server for 2 minutes.",
      "ja": "437（割り当ての不一致）：これは、クライアントが5タプルを選択したことを示します。5タプルは、サーバーがすでに使用されていると見なします。 これが発生する可能性のある1つの方法は、介在するNATが、最近クラッシュした別のクライアントによって使用されたマッピングされたトランスポートアドレスを割り当てた場合です。 クライアントは、現在のトランザクションが失敗したと見なします。 クライアントは、別のクライアントトランスポートアドレスを選択し、（別のトランザクションIDを使用して）割り当て要求を再試行する必要があります。 クライアントは、このサーバーを放棄する前に3つの異なるクライアントトランスポートアドレスを試行する必要があります。 クライアントがサーバーを放棄すると、2分間サーバー上に別の割り当てを作成しないでください。"
    },
    {
      "indent": 3,
      "text": "438 (Stale Nonce): See the procedures for the long-term credential mechanism [RFC8489].",
      "ja": "438（Stale Nonce）：長期資格情報メカニズム[RFC8489]の手順を参照してください。"
    },
    {
      "indent": 3,
      "text": "440 (Address Family not Supported): The server does not support the address family requested by the client. If the client receives an Allocate error response with the 440 (Address Family not Supported) error code, the client MUST NOT retry the request.",
      "ja": "440（アドレスファミリはサポートされていません）：サーバーは、クライアントが要求したアドレスファミリをサポートしていません。 クライアントが440（サポートされていないアドレスファミリ）エラーコードの割り当てエラー応答を受信した場合、クライアントはリクエストを再試行してはなりません。"
    },
    {
      "indent": 3,
      "text": "441 (Wrong Credentials): The client should not receive this error in response to an Allocate request. The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.",
      "ja": "441（間違った資格情報）：クライアントは、割り当て要求への応答でこのエラーを受け取るべきではありません。 クライアントはユーザーまたはオペレーターに通知してもよいし、問題が解決されたと信じるまでこのサーバーで同じリクエストを再試行すべきではない。"
    },
    {
      "indent": 3,
      "text": "442 (Unsupported Transport Address): The client should not receive this error in response to a request for a UDP allocation. The client MAY notify the user or operator and SHOULD NOT reattempt the request with this server until it believes the problem has been fixed.",
      "ja": "442（サポートされていないトランスポートアドレス）：クライアントは、UDP割り当ての要求への応答でこのエラーを受け取るべきではありません。 クライアントは、ユーザーまたはオペレーターに通知してもよく、問題が修正されたと思われるまで、このサーバーで要求を再試行しないでください。"
    },
    {
      "indent": 3,
      "text": "486 (Allocation Quota Reached): The server is currently unable to create any more allocations with this username. The client considers the current transaction as having failed. The client SHOULD wait at least 1 minute before trying to create any more allocations on the server.",
      "ja": "486（割り当てクォータに達しました）：サーバーは現在、このユーザー名でこれ以上の割り当てを作成できません。 クライアントは、現在のトランザクションが失敗したと見なします。 クライアントは、サーバー上でさらに割り当てを作成する前に、少なくとも1分間待機する必要があります。"
    },
    {
      "indent": 3,
      "text": "508 (Insufficient Capacity): The server has no more relayed transport addresses available or has none with the requested properties, or the one that was reserved is no longer available. The client considers the current operation as having failed. If the client is using either the EVEN-PORT or the RESERVATION-TOKEN attribute, then the client MAY choose to remove or modify this attribute and try again immediately. Otherwise, the client SHOULD wait at least 1 minute before trying to create any more allocations on this server.",
      "ja": "508（容量不足）：サーバーに利用可能な中継されたトランスポートアドレスがないか、要求されたプロパティを持つものがないか、予約されていたものが利用できなくなりました。 クライアントは、現在の操作が失敗したと見なします。 クライアントがEVEN-PORTまたはRESERVATION-TOKEN属性のいずれかを使用している場合、クライアントはこの属性を削除または変更して、すぐに再試行することを選択できます。 それ以外の場合、クライアントは、このサーバーでさらに割り当てを作成しようとする前に、少なくとも1分間待機する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the error code values 486 and 508 indicate to a eavesdropper that several other users are using the server at this time, similar to that of the HTTP error response code 503, but it does not reveal any information about the users using the TURN server.",
      "ja": "エラーコード値486および508は、HTTPエラー応答コード503のように、現時点で他の複数のユーザーがサーバーを使用していることを盗聴者に示しますが、TURNサーバーを使用しているユーザーに関する情報は明らかにしません 。"
    },
    {
      "indent": 3,
      "text": "An unknown error response MUST be handled as described in [RFC8489].",
      "ja": "[RFC8489]で説明されているように、不明なエラー応答を処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Refreshing an Allocation",
      "section_title": true,
      "ja": "8. 割り当ての更新"
    },
    {
      "indent": 3,
      "text": "A Refresh transaction can be used to either (a) refresh an existing allocation and update its time-to-expiry or (b) delete an existing allocation.",
      "ja": "更新トランザクションを使用して、（a）既存の割り当てを更新してその有効期限を更新するか、（b）既存の割り当てを削除できます。"
    },
    {
      "indent": 3,
      "text": "If a client wishes to continue using an allocation, then the client MUST refresh it before it expires. It is suggested that the client refresh the allocation roughly 1 minute before it expires. If a client no longer wishes to use an allocation, then it SHOULD explicitly delete the allocation. A client MAY refresh an allocation at any time for other reasons.",
      "ja": "クライアントが割り当ての使用を継続する場合、クライアントは有効期限が切れる前にそれを更新する必要があります。 クライアントは、有効期限が切れる約1分前に割り当てを更新することをお勧めします。 クライアントが割り当てを使用したくない場合、明示的に割り当てを削除する必要があります。 クライアントは、他の理由でいつでも割り当てを更新できます。"
    },
    {
      "indent": 0,
      "text": "8.1. Sending a Refresh Request",
      "section_title": true,
      "ja": "8.1. 更新リクエストを送信する"
    },
    {
      "indent": 3,
      "text": "If the client wishes to immediately delete an existing allocation, it includes a LIFETIME attribute with a value of zero. All other forms of the request refresh the allocation.",
      "ja": "クライアントが既存の割り当てをすぐに削除する場合、値が0のLIFETIME属性が含まれます。 リクエストの他のすべての形式は、割り当てを更新します。"
    },
    {
      "indent": 3,
      "text": "When refreshing a dual allocation, the client includes a REQUESTED-ADDRESS-FAMILY attribute indicating the address family type that should be refreshed. If no REQUESTED-ADDRESS-FAMILY attribute is included, then the request should be treated as applying to all current allocations. The client MUST only include a family type it previously allocated and has not yet deleted. This process can also be used to delete an allocation of a specific address type by setting the lifetime of that Refresh request to zero. Deleting a single allocation destroys any permissions or channels associated with that particular allocation; it MUST NOT affect any permissions or channels associated with allocations for the other address family.",
      "ja": "二重割り当てを更新する場合、クライアントには、更新する必要があるアドレスファミリタイプを示すREQUESTED-ADDRESS-FAMILY属性が含まれます。 REQUESTED-ADDRESS-FAMILY属性が含まれていない場合、リクエストは現在のすべての割り当てに適用されるものとして扱われる必要があります。 クライアントは、以前に割り当てられ、まだ削除されていないファミリタイプのみを含める必要があります。 このプロセスは、Refresh要求のライフタイムをゼロに設定することにより、特定のアドレスタイプの割り当てを削除するためにも使用できます。 単一の割り当てを削除すると、その特定の割り当てに関連付けられたアクセス許可またはチャネルが破壊されます。 他のアドレスファミリの割り当てに関連付けられたアクセス許可またはチャネルに影響してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Refresh transaction updates the time-to-expiry timer of an allocation. If the client wishes the server to set the time-to-expiry timer to something other than the default lifetime, it includes a LIFETIME attribute with the requested value. The server then computes a new time-to-expiry value in the same way as it does for an Allocate transaction, with the exception that a requested lifetime of zero causes the server to immediately delete the allocation.",
      "ja": "更新トランザクションは、割り当ての有効期限タイマーを更新します。 クライアントがサーバーに有効期限タイマーをデフォルトの有効期間以外に設定することを希望する場合、要求された値を持つLIFETIME属性が含まれます。 次に、サーバーは、割り当てられたトランザクションの場合と同じ方法で、新しい有効期限値を計算します。ただし、要求された有効期間がゼロの場合、サーバーは直ちに割り当てを削除します。"
    },
    {
      "indent": 0,
      "text": "8.2. Receiving a Refresh Request",
      "section_title": true,
      "ja": "8.2. リフレッシュリクエストの受信"
    },
    {
      "indent": 3,
      "text": "When the server receives a Refresh request, it processes the request as per Section 5 plus the specific rules mentioned here.",
      "ja": "サーバーは、更新要求を受信すると、セクション5に加えて、ここで説明した特定の規則に従って要求を処理します。"
    },
    {
      "indent": 3,
      "text": "If the server receives a Refresh Request with a REQUESTED-ADDRESS-FAMILY attribute and the attribute value does not match the address family of the allocation, the server MUST reply with a 443 (Peer Address Family Mismatch) Refresh error response.",
      "ja": "サーバーがREQUESTED-ADDRESS-FAMILY属性を持つ更新要求を受信し、属性値が割り当てのアドレスファミリーと一致しない場合、サーバーは443（ピアアドレスファミリー不一致）更新エラー応答で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server computes a value called the \"desired lifetime\" as follows: if the request contains a LIFETIME attribute and the attribute value is zero, then the \"desired lifetime\" is zero. Otherwise, if the request contains a LIFETIME attribute, then the server computes the minimum of the client's requested lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the \"desired lifetime\" is the computed value. Otherwise, the \"desired lifetime\" is the default lifetime.",
      "ja": "サーバーは、「望ましいライフタイム」と呼ばれる値を次のように計算します。リクエストにLIFETIME属性が含まれ、属性値がゼロの場合、「望ましいライフタイム」はゼロです。 それ以外の場合、リクエストにLIFETIME属性が含まれていると、サーバーはクライアントのリクエストされたライフタイムの最小値とサーバーの最大許容ライフタイムを計算します。 この計算値がデフォルトのライフタイムよりも大きい場合、「望ましいライフタイム」が計算値になります。 それ以外の場合、「望ましいライフタイム」がデフォルトのライフタイムです。"
    },
    {
      "indent": 3,
      "text": "Subsequent processing depends on the \"desired lifetime\" value:",
      "ja": "後続の処理は、「望ましい存続期間」の値に依存します。"
    },
    {
      "indent": 3,
      "text": "* If the \"desired lifetime\" is zero, then the request succeeds and the allocation is deleted.",
      "ja": "* 「望ましいライフタイム」がゼロの場合、リクエストは成功し、割り当ては削除されます。"
    },
    {
      "indent": 3,
      "text": "* If the \"desired lifetime\" is non-zero, then the request succeeds and the allocation's time-to-expiry is set to the \"desired lifetime\".",
      "ja": "* 「望ましいライフタイム」がゼロ以外の場合、リクエストは成功し、割り当ての有効期限は「望ましいライフタイム」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If the request succeeds, then the server sends a success response containing:",
      "ja": "要求が成功すると、サーバーは次を含む成功応答を送信します。"
    },
    {
      "indent": 3,
      "text": "* A LIFETIME attribute containing the current value of the time-to-expiry timer.",
      "ja": "* 期限切れタイマーの現在の値を含むLIFETIME属性。"
    },
    {
      "indent": 6,
      "text": "| NOTE: A server need not do anything special to implement | idempotency of Refresh requests over UDP using the \"stateless | stack approach\". Retransmitted Refresh requests with a non-| zero \"desired lifetime\" will simply refresh the allocation. A | retransmitted Refresh request with a zero \"desired lifetime\" | will cause a 437 (Allocation Mismatch) response if the | allocation has already been deleted, but the client will treat | this as equivalent to a success response (see below).",
      "ja": "| 注：サーバーは、実装するために特別なことをする必要はありません。 「ステートレス|スタックアプローチ」を使用したUDP上でのリフレッシュ要求のべき等性。 |以外で再送信された更新要求 「望ましい存続期間」がゼロの場合、単に割り当てが更新されます。 A | ゼロの「望ましいライフタイム」で再送信されたリフレッシュ要求| |の場合、437（Allocation Mismatch）応答が発生します。 割り当てはすでに削除されていますが、クライアントは次を扱います| これは成功応答に相当します（以下を参照）。"
    },
    {
      "indent": 0,
      "text": "8.3. Receiving a Refresh Response",
      "section_title": true,
      "ja": "8.3. 更新応答の受信"
    },
    {
      "indent": 3,
      "text": "If the client receives a success response to its Refresh request with a non-zero lifetime, it updates its copy of the allocation data structure with the time-to-expiry value contained in the response. If the client receives a 437 (Allocation Mismatch) error response to its request to refresh the allocation, it should consider the allocation no longer exists. If the client receives a 438 (Stale Nonce) error to its request to refresh the allocation, it should reattempt the request with the new nonce value.",
      "ja": "クライアントは、Refresh要求に対して有効期間がゼロ以外の成功応答を受信すると、応答に含まれる有効期限までの値で割り当てデータ構造のコピーを更新します。 クライアントが割り当てを更新する要求に対して437（割り当ての不一致）エラー応答を受け取った場合、割り当てがもう存在しないと見なす必要があります。 クライアントが割り当てを更新する要求に対して438（Stale Nonce）エラーを受け取った場合、クライアントは新しいnonce値で要求を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client receives a 437 (Allocation Mismatch) error response to a request to delete the allocation, then the allocation no longer exists and it should consider its request as having effectively succeeded.",
      "ja": "クライアントが、割り当てを削除する要求に対する437（割り当ての不一致）エラー応答を受信した場合、割り当てはもはや存在せず、その要求は事実上成功したと見なす必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Permissions",
      "section_title": true,
      "ja": "9. 許可"
    },
    {
      "indent": 3,
      "text": "For each allocation, the server keeps a list of zero or more permissions. Each permission consists of an IP address and an associated time-to-expiry. While a permission exists, all peers using the IP address in the permission are allowed to send data to the client. The time-to-expiry is the number of seconds until the permission expires. Within the context of an allocation, a permission is uniquely identified by its associated IP address.",
      "ja": "サーバーは、割り当てごとに、0個以上のアクセス許可のリストを保持します。 各許可は、IPアドレスと関連する有効期限から構成されます。 許可が存在する間、許可でIPアドレスを使用するすべてのピアは、クライアントにデータを送信できます。 有効期限は、許可が期限切れになるまでの秒数です。 割り当てのコンテキスト内で、許可は、関連付けられたIPアドレスによって一意に識別されます。"
    },
    {
      "indent": 3,
      "text": "By sending either CreatePermission requests or ChannelBind requests, the client can cause the server to install or refresh a permission for a given IP address. This causes one of two things to happen:",
      "ja": "クライアントは、CreatePermission要求またはChannelBind要求のいずれかを送信することにより、サーバーに特定のIPアドレスのアクセス許可をインストールまたは更新させることができます。 これにより、次の2つのいずれかが発生します。"
    },
    {
      "indent": 3,
      "text": "* If no permission for that IP address exists, then a permission is created with the given IP address and a time-to-expiry equal to Permission Lifetime.",
      "ja": "* そのIPアドレスに対するアクセス許可が存在しない場合、指定されたIPアドレスとアクセス許可の有効期限に等しい有効期限でアクセス許可が作成されます。"
    },
    {
      "indent": 3,
      "text": "* If a permission for that IP address already exists, then the time-to-expiry for that permission is reset to Permission Lifetime.",
      "ja": "* そのIPアドレスのアクセス許可が既に存在する場合、そのアクセス許可の有効期限はPermission Lifetimeにリセットされます。"
    },
    {
      "indent": 3,
      "text": "The Permission Lifetime MUST be 300 seconds (= 5 minutes).",
      "ja": "許可の有効期間は300秒（= 5分）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each permission's time-to-expiry decreases down once per second until it reaches zero, at which point, the permission expires and is deleted.",
      "ja": "各アクセス許可の有効期限は、ゼロに達するまで1秒に1回減少します。ゼロになると、アクセス許可は有効期限が切れて削除されます。"
    },
    {
      "indent": 3,
      "text": "CreatePermission and ChannelBind requests may be freely intermixed on a permission. A given permission may be initially installed and/or refreshed with a CreatePermission request and then later refreshed with a ChannelBind request, or vice versa.",
      "ja": "CreatePermission要求とChannelBind要求は、許可で自由に混在させることができます。 指定された許可は、最初にCreatePermission要求でインストールおよび/または更新され、その後ChannelBind要求で更新されるか、またはその逆です。"
    },
    {
      "indent": 3,
      "text": "When a UDP datagram arrives at the relayed transport address for the allocation, the server extracts the source IP address from the IP header. The server then compares this address with the IP address associated with each permission in the list of permissions for the allocation. Note that only addresses are compared and port numbers are not considered. If no match is found, relaying is not permitted and the server silently discards the UDP datagram. If an exact match is found, the permission check is considered to have succeeded and the server continues to process the UDP datagram as specified elsewhere (Section 11.3).",
      "ja": "UDPデータグラムが割り当てのために中継されたトランスポートアドレスに到着すると、サーバーはIPヘッダーからソースIPアドレスを抽出します。 サーバーは、このアドレスを、割り当ての許可のリスト内の各許可に関連付けられたIPアドレスと比較します。 アドレスのみが比較され、ポート番号は考慮されないことに注意してください。 一致するものが見つからない場合、中継は許可されず、サーバーはUDPデータグラムを静かに破棄します。 完全に一致するものが見つかった場合、許可チェックは成功したとみなされ、サーバーは他の場所で指定されたUDPデータグラムの処理を継続します（セクション11.3）。"
    },
    {
      "indent": 3,
      "text": "The permissions for one allocation are totally unrelated to the permissions for a different allocation. If an allocation expires, all its permissions expire with it.",
      "ja": "1つの割り当てのアクセス許可は、別の割り当てのアクセス許可とはまったく関係ありません。 割り当ての有効期限が切れると、そのすべてのアクセス許可も有効期限が切れます。"
    },
    {
      "indent": 6,
      "text": "| NOTE: Though TURN permissions expire after 5 minutes, many NATs | deployed at the time of publication expire their UDP bindings | considerably faster. Thus, an application using TURN will | probably wish to send some sort of keep-alive traffic at a much | faster rate. Applications using ICE should follow the keep-| alive guidelines of ICE [RFC8445], and applications not using | ICE are advised to do something similar.",
      "ja": "| 注：TURN許可は5分後に期限切れになりますが、多くのNAT | 公開時に展開されたUDPバインディングの有効期限が切れる| かなり高速です。 したがって、TURNを使用するアプリケーションは| たぶん、ある種のキープアライブトラフィックを送信したいでしょう。 より速いレート。 ICEを使用するアプリケーションは、keep- |に従う必要があります。 ICE [RFC8445]のaliveガイドライン、および使用していないアプリケーション| ICEは同様のことを行うことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "10. CreatePermission",
      "section_title": true,
      "ja": "10. CreatePermission"
    },
    {
      "indent": 3,
      "text": "TURN supports two ways for the client to install or refresh permissions on the server. This section describes one way: the CreatePermission request.",
      "ja": "TURNは、クライアントがサーバーに権限をインストールまたは更新するための2つの方法をサポートしています。 このセクションでは、1つの方法、CreatePermission要求について説明します。"
    },
    {
      "indent": 3,
      "text": "A CreatePermission request may be used in conjunction with either the Send mechanism in Section 11 or the Channel mechanism in Section 12.",
      "ja": "CreatePermissionリクエストは、セクション11の送信メカニズムまたはセクション12のチャネルメカニズムと組み合わせて使用できます。"
    },
    {
      "indent": 0,
      "text": "10.1. Forming a CreatePermission Request",
      "section_title": true,
      "ja": "10.1. CreatePermissionリクエストの作成"
    },
    {
      "indent": 3,
      "text": "The client who wishes to install or refresh one or more permissions can send a CreatePermission request to the server.",
      "ja": "1つ以上のアクセス許可をインストールまたは更新するクライアントは、サーバーにCreatePermission要求を送信できます。"
    },
    {
      "indent": 3,
      "text": "When forming a CreatePermission request, the client MUST include at least one XOR-PEER-ADDRESS attribute and MAY include more than one such attribute. The IP address portion of each XOR-PEER-ADDRESS attribute contains the IP address for which a permission should be installed or refreshed. The port portion of each XOR-PEER-ADDRESS attribute will be ignored and can be any arbitrary value. The various XOR-PEER-ADDRESS attributes MAY appear in any order. The client MUST only include XOR-PEER-ADDRESS attributes with addresses of the same address family as that of the relayed transport address for the allocation. For dual allocations obtained using the ADDITIONAL-ADDRESS-FAMILY attribute, the client MAY include XOR-PEER-ADDRESS attributes with addresses of IPv4 and IPv6 address families.",
      "ja": "CreatePermissionリクエストを作成するとき、クライアントは少なくとも1つのXOR-PEER-ADDRESS属性を含まなければならず、そのような属性を複数含めることができます。 各XOR-PEER-ADDRESS属性のIPアドレス部分には、許可をインストールまたは更新するIPアドレスが含まれています。 各XOR-PEER-ADDRESS属性のポート部分は無視され、任意の値にすることができます。 さまざまなXOR-PEER-ADDRESS属性が任意の順序で表示される場合があります。 クライアントは、割り当てのために中継されたトランスポートアドレスと同じアドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性のみを含めなければなりません。 ADDITIONAL-ADDRESS-FAMILY属性を使用して取得した二重割り当ての場合、クライアントには、IPv4およびIPv6アドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性を含めることができます。"
    },
    {
      "indent": 0,
      "text": "10.2. Receiving a CreatePermission Request",
      "section_title": true,
      "ja": "10.2. CreatePermissionリクエストを受信する"
    },
    {
      "indent": 3,
      "text": "When the server receives the CreatePermission request, it processes as per Section 5 plus the specific rules mentioned here.",
      "ja": "サーバーがCreatePermission要求を受信すると、セクション5に加えて、ここで説明した特定のルールに従って処理します。"
    },
    {
      "indent": 3,
      "text": "The message is checked for validity. The CreatePermission request MUST contain at least one XOR-PEER-ADDRESS attribute and MAY contain multiple such attributes. If no such attribute exists, or if any of these attributes are invalid, then a 400 (Bad Request) error is returned. If the request is valid, but the server is unable to satisfy the request due to some capacity limit or similar, then a 508 (Insufficient Capacity) error is returned.",
      "ja": "メッセージの有効性が確認されます。 CreatePermissionリクエストには、少なくとも1つのXOR-PEER-ADDRESS属性を含める必要があり、そのような属性を複数含めることができます。 そのような属性が存在しない場合、またはこれらの属性のいずれかが無効な場合、400（Bad Request）エラーが返されます。 要求は有効であるが、何らかの容量制限などのためにサーバーが要求を満たすことができない場合、508（Insufficient Capacity）エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If an XOR-PEER-ADDRESS attribute contains an address of an address family that is not the same as that of a relayed transport address for the allocation, the server MUST generate an error response with the 443 (Peer Address Family Mismatch) response code.",
      "ja": "XOR-PEER-ADDRESS属性に、割り当てのために中継されたトランスポートアドレスとは異なるアドレスファミリのアドレスが含まれている場合、サーバーは443（ピアアドレスファミリ不一致）応答コードでエラー応答を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.",
      "ja": "サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスに制限を課すことができます。 値が許可されない場合、サーバーは403（禁止）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "If the message is valid and the server is capable of carrying out the request, then the server installs or refreshes a permission for the IP address contained in each XOR-PEER-ADDRESS attribute as described in Section 9. The port portion of each attribute is ignored and may be any arbitrary value.",
      "ja": "メッセージが有効で、サーバーが要求を実行できる場合、サーバーはセクション9で説明されているように、各XOR-PEER-ADDRESS属性に含まれるIPアドレスの許可をインストールまたは更新します。各属性のポート部分は 無視され、任意の値が可能です。"
    },
    {
      "indent": 3,
      "text": "The server then responds with a CreatePermission success response. There are no mandatory attributes in the success response.",
      "ja": "サーバーは、CreatePermission成功応答で応答します。 成功応答には必須の属性はありません。"
    },
    {
      "indent": 6,
      "text": "| NOTE: A server need not do anything special to implement | idempotency of CreatePermission requests over UDP using the | \"stateless stack approach\". Retransmitted CreatePermission | requests will simply refresh the permissions.",
      "ja": "| 注：サーバーは、実装するために特別なことをする必要はありません。 |を使用したUDPを介したCreatePermission要求のべき等性 「ステートレススタックアプローチ」。 再送されたCreatePermission | リクエストは許可を更新するだけです。"
    },
    {
      "indent": 0,
      "text": "10.3. Receiving a CreatePermission Response",
      "section_title": true,
      "ja": "10.3. CreatePermission応答を受信する"
    },
    {
      "indent": 3,
      "text": "If the client receives a valid CreatePermission success response, then the client updates its data structures to indicate that the permissions have been installed or refreshed.",
      "ja": "クライアントが有効なCreatePermission成功応答を受信した場合、クライアントはデータ構造を更新して、アクセス許可がインストールまたは更新されたことを示します。"
    },
    {
      "indent": 0,
      "text": "11. Send and Data Methods",
      "section_title": true,
      "ja": "11. 送信およびデータメソッド"
    },
    {
      "indent": 3,
      "text": "TURN supports two mechanisms for sending and receiving data from peers. This section describes the use of the Send and Data mechanisms, while Section 12 describes the use of the Channel mechanism.",
      "ja": "TURNは、ピアからデータを送受信するための2つのメカニズムをサポートしています。 このセクションでは、送信およびデータメカニズムの使用について説明し、セクション12ではチャネルメカニズムの使用について説明します。"
    },
    {
      "indent": 0,
      "text": "11.1. Forming a Send Indication",
      "section_title": true,
      "ja": "11.1. 送信指示の形成"
    },
    {
      "indent": 3,
      "text": "The client can use a Send indication to pass data to the server for relaying to a peer. A client may use a Send indication even if a channel is bound to that peer. However, the client MUST ensure that there is a permission installed for the IP address of the peer to which the Send indication is being sent; this prevents a third party from using a TURN server to send data to arbitrary destinations.",
      "ja": "クライアントは、送信指示を使用して、ピアに中継するためにサーバーにデータを渡すことができます。 チャネルがそのピアにバインドされている場合でも、クライアントは送信指示を使用できます。 ただし、クライアントは、送信指示の送信先のピアのIPアドレスにインストールされた許可があることを確認する必要があります。 これにより、サードパーティがTURNサーバーを使用して任意の宛先にデータを送信することを防ぎます。"
    },
    {
      "indent": 3,
      "text": "When forming a Send indication, the client MUST include an XOR-PEER-ADDRESS attribute and a DATA attribute. The XOR-PEER-ADDRESS attribute contains the transport address of the peer to which the data is to be sent, and the DATA attribute contains the actual application data to be sent to the peer.",
      "ja": "送信指示を形成するとき、クライアントはXOR-PEER-ADDRESS属性とDATA属性を含まなければなりません。 XOR-PEER-ADDRESS属性には、データの送信先のピアのトランスポートアドレスが含まれ、DATA属性には、ピアに送信される実際のアプリケーションデータが含まれます。"
    },
    {
      "indent": 3,
      "text": "The client MAY include a DONT-FRAGMENT attribute in the Send indication if it wishes the server to set the DF bit on the UDP datagram sent to the peer.",
      "ja": "サーバーは、ピアに送信されるUDPデータグラムにDFビットを設定することを希望する場合、クライアントは送信指示にDONT-FRAGMENT属性を含めることができます。"
    },
    {
      "indent": 0,
      "text": "11.2. Receiving a Send Indication",
      "section_title": true,
      "ja": "11.2. 送信指示の受信"
    },
    {
      "indent": 3,
      "text": "When the server receives a Send indication, it processes as per Section 5 plus the specific rules mentioned here.",
      "ja": "サーバーは、送信指示を受信すると、セクション5に加えて、ここで説明した特定のルールに従って処理します。"
    },
    {
      "indent": 3,
      "text": "The message is first checked for validity. The Send indication MUST contain both an XOR-PEER-ADDRESS attribute and a DATA attribute. If one of these attributes is missing or invalid, then the message is discarded. Note that the DATA attribute is allowed to contain zero bytes of data.",
      "ja": "メッセージの有効性が最初に確認されます。 送信指示には、XOR-PEER-ADDRESS属性とDATA属性の両方を含める必要があります。 これらの属性のいずれかが欠落しているか無効である場合、メッセージは破棄されます。 DATA属性にはゼロバイトのデータを含めることができます。"
    },
    {
      "indent": 3,
      "text": "The Send indication may also contain the DONT-FRAGMENT attribute. If the server is unable to set the DF bit on outgoing UDP datagrams when this attribute is present, then the server acts as if the DONT-FRAGMENT attribute is an unknown comprehension-required attribute (and thus the Send indication is discarded).",
      "ja": "送信指示にはDONT-FRAGMENT属性も含まれる場合があります。 この属性が存在するときにサーバーが発信UDPデータグラムにDFビットを設定できない場合、サーバーはDONT-FRAGMENT属性が不明な内包必須属性であるように動作します（したがって、送信指示は破棄されます）。"
    },
    {
      "indent": 3,
      "text": "The server also checks that there is a permission installed for the IP address contained in the XOR-PEER-ADDRESS attribute. If no such permission exists, the message is discarded. Note that a Send indication never causes the server to refresh the permission.",
      "ja": "また、サーバーは、XOR-PEER-ADDRESS属性に含まれるIPアドレスにインストールされた許可があることを確認します。 そのような許可が存在しない場合、メッセージは破棄されます。 送信指示によってサーバーが許可を更新することはありません。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server silently discards the Send indication.",
      "ja": "サーバーは、XOR-PEER-ADDRESS属性で許可されているIPアドレスとポート値に制限を課すことができます。 値が許可されない場合、サーバーは送信指示を静かに破棄します。"
    },
    {
      "indent": 3,
      "text": "If everything is OK, then the server forms a UDP datagram as follows:",
      "ja": "すべてが正常であれば、サーバーは次のようにUDPデータグラムを形成します。"
    },
    {
      "indent": 3,
      "text": "* the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the Send indication arrived;",
      "ja": "* 送信元トランスポートアドレスは、割り当ての中継されたトランスポートアドレスです。割り当ては、送信指示が到着した5タプルによって決定されます。"
    },
    {
      "indent": 3,
      "text": "* the destination transport address is taken from the XOR-PEER-ADDRESS attribute;",
      "ja": "* 宛先トランスポートアドレスは、XOR-PEER-ADDRESS属性から取得されます。"
    },
    {
      "indent": 3,
      "text": "* the data following the UDP header is the contents of the value field of the DATA attribute.",
      "ja": "* UDPヘッダーに続くデータは、DATA属性の値フィールドの内容です。"
    },
    {
      "indent": 3,
      "text": "The handling of the DONT-FRAGMENT attribute (if present), is described in Sections 14 and 15.",
      "ja": "DONT-FRAGMENT属性（存在する場合）の処理については、セクション14および15で説明しています。"
    },
    {
      "indent": 3,
      "text": "The resulting UDP datagram is then sent to the peer.",
      "ja": "次に、結果のUDPデータグラムがピアに送信されます。"
    },
    {
      "indent": 0,
      "text": "11.3. Receiving a UDP Datagram",
      "section_title": true,
      "ja": "11.3. UDPデータグラムの受信"
    },
    {
      "indent": 3,
      "text": "When the server receives a UDP datagram at a currently allocated relayed transport address, the server looks up the allocation associated with the relayed transport address. The server then checks to see whether the set of permissions for the allocation allow the relaying of the UDP datagram as described in Section 9.",
      "ja": "サーバーは、現在割り当てられているリレーされたトランスポートアドレスでUDPデータグラムを受信すると、リレーされたトランスポートアドレスに関連付けられた割り当てを検索します。 サーバーは、セクション9で説明されているように、割り当てに対する一連の許可がUDPデータグラムの中継を許可するかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "If relaying is permitted, then the server checks if there is a channel bound to the peer that sent the UDP datagram (see Section 12). If a channel is bound, then processing proceeds as described in Section 12.7.",
      "ja": "中継が許可されている場合、サーバーはUDPデータグラムを送信したピアにバインドされたチャネルがあるかどうかを確認します（セクション12を参照）。 チャネルがバインドされている場合、処理はセクション12.7で説明されているように進行します。"
    },
    {
      "indent": 3,
      "text": "If relaying is permitted but no channel is bound to the peer, then the server forms and sends a Data indication. The Data indication MUST contain both an XOR-PEER-ADDRESS and a DATA attribute. The DATA attribute is set to the value of the \"data octets\" field from the datagram, and the XOR-PEER-ADDRESS attribute is set to the source transport address of the received UDP datagram. The Data indication is then sent on the 5-tuple associated with the allocation.",
      "ja": "中継が許可されているが、ピアにバインドされているチャネルがない場合、サーバーはデータ表示を形成して送信します。 データ指示は、XOR-PEER-ADDRESSとDATA属性の両方を含まなければなりません。 DATA属性はデータグラムの「データオクテット」フィールドの値に設定され、XOR-PEER-ADDRESS属性は受信したUDPデータグラムのソーストランスポートアドレスに設定されます。 データ表示は、割り当てに関連付けられた5タプルで送信されます。"
    },
    {
      "indent": 0,
      "text": "11.4. Receiving a Data Indication",
      "section_title": true,
      "ja": "11.4. データ表示の受信"
    },
    {
      "indent": 3,
      "text": "When the client receives a Data indication, it checks that the Data indication contains an XOR-PEER-ADDRESS attribute and discards the indication if it does not. The client SHOULD also check that the XOR-PEER-ADDRESS attribute value contains an IP address with which the client believes there is an active permission and discard the Data indication otherwise.",
      "ja": "クライアントは、データ表示を受信すると、データ表示にXOR-PEER-ADDRESS属性が含まれていることを確認し、含まれていない場合は表示を破棄します。 クライアントは、XOR-PEER-ADDRESS属性値に、クライアントがアクティブな許可があると信じるIPアドレスが含まれていることも確認する必要があります。"
    },
    {
      "indent": 6,
      "text": "| NOTE: The latter check protects the client against an attacker | who somehow manages to trick the server into installing | permissions not desired by the client.",
      "ja": "| 注：後者のチェックは、クライアントを攻撃者から保護します。 どうにかしてサーバーをだましてインストールさせようとする人| クライアントが望まない許可。"
    },
    {
      "indent": 3,
      "text": "If the XOR-PEER-ADDRESS is present and valid, the client checks that the Data indication contains either a DATA attribute or an ICMP attribute and discards the indication if it does not. Note that a DATA attribute is allowed to contain zero bytes of data. Processing of Data indications with an ICMP attribute is described in Section 11.6.",
      "ja": "XOR-PEER-ADDRESSが存在して有効な場合、クライアントは、データ表示にDATA属性またはICMP属性が含まれていることを確認し、含まれていない場合は表示を破棄します。 DATA属性にはゼロバイトのデータを含めることができます。 ICMP属性を持つデータ表示の処理については、セクション11.6で説明しています。"
    },
    {
      "indent": 3,
      "text": "If the Data indication passes the above checks, the client delivers the data octets inside the DATA attribute to the application, along with an indication that they were received from the peer whose transport address is given by the XOR-PEER-ADDRESS attribute.",
      "ja": "Data指示が上記のチェックに合格した場合、クライアントは、DATA属性内のデータオクテットを、XOR-PEER-ADDRESS属性で指定されたトランスポートアドレスを持つピアから受信したという指示とともに、アプリケーションに配信します。"
    },
    {
      "indent": 0,
      "text": "11.5. Receiving an ICMP Packet",
      "section_title": true,
      "ja": "11.5. ICMPパケットを受信する"
    },
    {
      "indent": 3,
      "text": "When the server receives an ICMP packet, the server verifies that the type is either 3 or 11 for an ICMPv4 [RFC0792] packet or either 1, 2, or 3 for an ICMPv6 [RFC4443] packet. It also verifies that the IP packet in the ICMP packet payload contains a UDP header. If either of these conditions fail, then the ICMP packet is silently dropped. If a UDP header is present, the server extracts the source and destination IP address and UDP port information.",
      "ja": "サーバーがICMPパケットを受信すると、サーバーは、タイプがICMPv4 [RFC0792]パケットの場合は3または11、ICMPv6 [RFC4443]パケットの場合は1、2、または3であることを確認します。 また、ICMPパケットペイロードのIPパケットにUDPヘッダーが含まれていることも確認します。 これらの条件のいずれかが失敗すると、ICMPパケットは静かにドロップされます。 UDPヘッダーが存在する場合、サーバーは送信元および宛先IPアドレスとUDPポート情報を抽出します。"
    },
    {
      "indent": 3,
      "text": "The server looks up the allocation whose relayed transport address corresponds to the encapsulated packet's source IP address and UDP port. If no such allocation exists, the packet is silently dropped. The server then checks to see whether the set of permissions for the allocation allows the relaying of the ICMP packet. For ICMP packets, the source IP address MUST NOT be checked against the permissions list as it would be for UDP packets. Instead, the server extracts the destination IP address from the encapsulated IP header. The server then compares this address with the IP address associated with each permission in the list of permissions for the allocation. If no match is found, relaying is not permitted and the server silently discards the ICMP packet. Note that only addresses are compared and port numbers are not considered.",
      "ja": "サーバーは、カプセル化されたパケットのソースIPアドレスとUDPポートに対応する中継トランスポートアドレスを持つ割り当てを検索します。 そのような割り当てが存在しない場合、パケットは静かにドロップされます。 サーバーは、割り当てのアクセス許可のセットがICMPパケットの中継を許可するかどうかを確認します。 ICMPパケットの場合、UDPパケットの場合と同様に、許可リストに対してソースIPアドレスをチェックしてはなりません（MUST NOT）。 代わりに、サーバーはカプセル化されたIPヘッダーから宛先IPアドレスを抽出します。 サーバーは、このアドレスを、割り当ての許可のリスト内の各許可に関連付けられたIPアドレスと比較します。 一致が見つからない場合、リレーは許可されず、サーバーはICMPパケットを静かに破棄します。 アドレスのみが比較され、ポート番号は考慮されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If relaying is permitted, then the server forms and sends a Data indication. The Data indication MUST contain both an XOR-PEER-ADDRESS and an ICMP attribute. The ICMP attribute is set to the value of the type and code fields from the ICMP packet. The IP address portion of XOR-PEER-ADDRESS attribute is set to the destination IP address in the encapsulated IP header. At the time of writing of this specification, Socket APIs on some operating systems do not deliver the destination port in the encapsulated UDP header to applications without superuser privileges. If destination port in the encapsulated UDP header is available to the server, then the port portion of the XOR-PEER-ADDRESS attribute is set to the destination port; otherwise, the port portion is set to zero. The Data indication is then sent on the 5-tuple associated with the allocation.",
      "ja": "中継が許可されている場合、サーバーはデータ表示を作成して送信します。 データ指示は、XOR-PEER-ADDRESSとICMP属性の両方を含まなければなりません。 ICMP属性は、ICMPパケットのタイプおよびコードフィールドの値に設定されます。 XOR-PEER-ADDRESS属性のIPアドレス部分は、カプセル化されたIPヘッダーの宛先IPアドレスに設定されます。 この仕様の執筆時点では、一部のオペレーティングシステムのソケットAPIは、カプセル化されたUDPヘッダーの宛先ポートをスーパーユーザー権限のないアプリケーションに配信しません。 カプセル化されたUDPヘッダーの宛先ポートがサーバーで使用できる場合、XOR-PEER-ADDRESS属性のポート部分が宛先ポートに設定されます。 それ以外の場合、ポート部分はゼロに設定されます。 データ表示は、割り当てに関連付けられた5タプルで送信されます。"
    },
    {
      "indent": 6,
      "text": "| Implementation Note: New ICMP types or codes can be defined in | future specifications. If the server receives an ICMP error | packet, and the new type or code field can help the client to | make use of the ICMP error notification and generate feedback | to the application layer, the server sends the Data indication | with an ICMP attribute conveying the new ICMP type or code.",
      "ja": "| 実装上の注意：新しいICMPタイプまたはコードは|で定義できます。 将来の仕様。 サーバーがICMPエラーを受信した場合| パケット、および新しいタイプまたはコードフィールドは、クライアントが ICMPエラー通知を利用してフィードバックを生成する| サーバーはアプリケーション層にデータ表示を送信します| 新しいICMPタイプまたはコードを伝えるICMP属性を使用します。"
    },
    {
      "indent": 0,
      "text": "11.6. Receiving a Data Indication with an ICMP Attribute",
      "section_title": true,
      "ja": "11.6. ICMP属性を持つデータ表示の受信"
    },
    {
      "indent": 3,
      "text": "When the client receives a Data indication with an ICMP attribute, it checks that the Data indication contains an XOR-PEER-ADDRESS attribute and discards the indication if it does not. The client SHOULD also check that the XOR-PEER-ADDRESS attribute value contains an IP address with an active permission and discard the Data indication otherwise.",
      "ja": "クライアントは、ICMP属性を持つデータ表示を受信すると、データ表示にXOR-PEER-ADDRESS属性が含まれていることを確認し、含まれていない場合はその表示を破棄します。 クライアントは、XOR-PEER-ADDRESS属性値にアクティブな許可を持つIPアドレスが含まれていることも確認する必要があります。そうでない場合は、データ表示を破棄します。"
    },
    {
      "indent": 3,
      "text": "If the Data indication passes the above checks, the client signals the application of the error condition along with an indication that it was received from the peer whose transport address is given by the XOR-PEER-ADDRESS attribute. The application can make sense of the meaning of the type and code values in the ICMP attribute by using the family field in the XOR-PEER-ADDRESS attribute.",
      "ja": "データ表示が上記のチェックに合格した場合、クライアントは、XOR-PEER-ADDRESS属性によってトランスポートアドレスが指定されたピアから受信したという表示とともに、エラー状態のアプリケーションに信号を送ります。 アプリケーションは、XOR-PEER-ADDRESS属性のfamilyフィールドを使用して、ICMP属性のタイプとコード値の意味を理解できます。"
    },
    {
      "indent": 0,
      "text": "12. Channels",
      "section_title": true,
      "ja": "12. チャンネル"
    },
    {
      "indent": 3,
      "text": "Channels provide a way for the client and server to send application data using ChannelData messages, which have less overhead than Send and Data indications.",
      "ja": "チャネルは、クライアントとサーバーがChannelDataメッセージを使用してアプリケーションデータを送信する方法を提供します。ChannelDataメッセージは、SendおよびData指示よりもオーバーヘッドが少なくなります。"
    },
    {
      "indent": 3,
      "text": "The ChannelData message (see Section 12.4) starts with a two-byte field that carries the channel number. The values of this field are allocated as follows:",
      "ja": "ChannelDataメッセージ（セクション12.4を参照）は、チャネル番号を伝える2バイトのフィールドで始まります。 このフィールドの値は次のように割り当てられます。"
    },
    {
      "indent": 5,
      "text": "+------------------------+--------------------------------------+\n| 0x0000 through 0x3FFF: | These values can never be used for   |\n|                        | channel numbers.                     |\n+------------------------+--------------------------------------+\n| 0x4000 through 0x4FFF: | These values are the allowed channel |\n|                        | numbers (4096 possible values).      |\n+------------------------+--------------------------------------+\n| 0x5000 through 0xFFFF: | Reserved (For DTLS-SRTP multiplexing |\n|                        | collision avoidance, see [RFC7983]). |\n+------------------------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 3,
      "text": "Note that the channel number range is not backwards compatible with [RFC5766], which could prevent a client compliant with RFC 5766 from establishing channel bindings with a TURN server that complies with this specification.",
      "ja": "チャネル番号範囲は[RFC5766]と後方互換性がないことに注意してください。これにより、RFC 5766に準拠するクライアントが、この仕様に準拠するTURNサーバーとのチャネルバインディングを確立できなくなります。"
    },
    {
      "indent": 3,
      "text": "According to [RFC7983], ChannelData messages can be distinguished from other multiplexed protocols by examining the first byte of the message:",
      "ja": "[RFC7983]によると、メッセージの最初のバイトを調べることにより、ChannelDataメッセージを他の多重化プロトコルと区別できます。"
    },
    {
      "indent": 3,
      "text": "+------------+------------------------------------------------------+\n| [0..3]     |                         STUN                         |\n+------------+------------------------------------------------------+\n| [16..19]   |                         ZRTP                         |\n+------------+------------------------------------------------------+\n| [20..63]   |                         DTLS                         |\n+------------+------------------------------------------------------+\n| [64..79]   |                     TURN Channel                     |\n+------------+------------------------------------------------------+\n| [128..191] |                       RTP/RTCP                       |\n+------------+------------------------------------------------------+\n| Others     |              Reserved; MUST be dropped               |\n|            |              and an alert MAY be logged              |\n+------------+------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 3,
      "text": "Reserved values may be used in the future by other protocols. When the client uses channel binding, it MUST comply with the demultiplexing scheme discussed above.",
      "ja": "予約された値は、将来他のプロトコルで使用される可能性があります。 クライアントがチャネルバインディングを使用する場合、上記で説明した逆多重化スキームに準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "Channel bindings are always initiated by the client. The client can bind a channel to a peer at any time during the lifetime of the allocation. The client may bind a channel to a peer before exchanging data with it or after exchanging data with it (using Send and Data indications) for some time, or may choose never to bind a channel to it. The client can also bind channels to some peers while not binding channels to other peers.",
      "ja": "チャネルバインディングは常にクライアントによって開始されます。 クライアントは、割り当ての有効期間中いつでもチャネルをピアにバインドできます。 クライアントは、データを交換する前、またはデータを（送信およびデータ表示を使用して）しばらく交換した後、チャネルをピアにバインドするか、チャネルをバインドしないことを選択できます。 クライアントは、チャネルを他のピアにバインドせずに、一部のピアにチャネルをバインドすることもできます。"
    },
    {
      "indent": 3,
      "text": "Channel bindings are specific to an allocation so that the use of a channel number or peer transport address in a channel binding in one allocation has no impact on their use in a different allocation. If an allocation expires, all its channel bindings expire with it.",
      "ja": "チャネルバインディングは割り当てに固有であるため、ある割り当てのチャネルバインドでチャネル番号またはピアトランスポートアドレスを使用しても、別の割り当てでの使用には影響しません。 割り当ての有効期限が切れると、そのすべてのチャネルバインディングも一緒に期限切れになります。"
    },
    {
      "indent": 3,
      "text": "A channel binding consists of:",
      "ja": "チャネルバインディングは以下で構成されます。"
    },
    {
      "indent": 3,
      "text": "* a channel number;",
      "ja": "* チャンネル番号。"
    },
    {
      "indent": 3,
      "text": "* a transport address (of the peer); and",
      "ja": "* （ピアの）トランスポートアドレス。 そして"
    },
    {
      "indent": 3,
      "text": "* A time-to-expiry timer.",
      "ja": "* 有効期限までのタイマー。"
    },
    {
      "indent": 3,
      "text": "Within the context of an allocation, a channel binding is uniquely identified either by the channel number or by the peer's transport address. Thus, the same channel cannot be bound to two different transport addresses, nor can the same transport address be bound to two different channels.",
      "ja": "割り当てのコンテキスト内で、チャネルバインディングは、チャネル番号またはピアのトランスポートアドレスによって一意に識別されます。 したがって、同じチャネルを2つの異なるトランスポートアドレスにバインドすることも、同じトランスポートアドレスを2つの異なるチャネルにバインドすることもできません。"
    },
    {
      "indent": 3,
      "text": "A channel binding lasts for 10 minutes unless refreshed. Refreshing the binding (by the server receiving a ChannelBind request rebinding the channel to the same peer) resets the time-to-expiry timer back to 10 minutes.",
      "ja": "更新されない限り、チャネルバインドは10分間続きます。 （チャネルを同じピアに再バインドするChannelBind要求を受信するサーバーによって）バインドを更新すると、有効期限までのタイマーが10分にリセットされます。"
    },
    {
      "indent": 3,
      "text": "When the channel binding expires, the channel becomes unbound. Once unbound, the channel number can be bound to a different transport address, and the transport address can be bound to a different channel number. To prevent race conditions, the client MUST wait 5 minutes after the channel binding expires before attempting to bind the channel number to a different transport address or the transport address to a different channel number.",
      "ja": "チャネルバインディングの有効期限が切れると、チャネルはバインドされなくなります。 バインドが解除されると、チャネル番号は別のトランスポートアドレスにバインドされ、トランスポートアドレスは別のチャネル番号にバインドされます。 競合状態を防ぐために、クライアントは、チャネルバインディングが期限切れになった後5分間待ってから、チャネル番号を別のトランスポートアドレスに、またはトランスポートアドレスを別のチャネル番号にバインドしようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "When binding a channel to a peer, the client SHOULD be prepared to receive ChannelData messages on the channel from the server as soon as it has sent the ChannelBind request. Over UDP, it is possible for the client to receive ChannelData messages from the server before it receives a ChannelBind success response.",
      "ja": "チャネルをピアにバインドするとき、クライアントは、ChannelBind要求を送信するとすぐに、サーバーからチャネルでChannelDataメッセージを受信するように準備する必要があります。 UDPを介して、クライアントがChannelBind成功応答を受信する前に、サーバーからChannelDataメッセージを受信することが可能です。"
    },
    {
      "indent": 3,
      "text": "In the other direction, the client MAY elect to send ChannelData messages before receiving the ChannelBind success response. Doing so, however, runs the risk of having the ChannelData messages dropped by the server if the ChannelBind request does not succeed for some reason (e.g., packet lost if the request is sent over UDP or the server being unable to fulfill the request). A client that wishes to be safe should either queue the data or use Send indications until the channel binding is confirmed.",
      "ja": "もう一方の方向では、クライアントはChannelBind成功応答を受信する前にChannelDataメッセージを送信することを選択する場合があります。 ただし、そうすると、何らかの理由でChannelBindリクエストが成功しなかった場合（たとえば、リクエストがUDP経由で送信された場合にパケットが失われたり、サーバーがリクエストを実行できない場合）、サーバーによってChannelDataメッセージがドロップされるリスクがあります。 安全にしたいクライアントは、チャネルバインディングが確認されるまで、データをキューに入れるか、送信指示を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.1. Sending a ChannelBind Request",
      "section_title": true,
      "ja": "12.1. ChannelBindリクエストの送信"
    },
    {
      "indent": 3,
      "text": "A channel binding is created or refreshed using a ChannelBind transaction. A ChannelBind transaction also creates or refreshes a permission towards the peer (see Section 9).",
      "ja": "チャネルバインドは、ChannelBindトランザクションを使用して作成または更新されます。 ChannelBindトランザクションは、ピアに対する許可を作成または更新します（セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "To initiate the ChannelBind transaction, the client forms a ChannelBind request. The channel to be bound is specified in a CHANNEL-NUMBER attribute, and the peer's transport address is specified in an XOR-PEER-ADDRESS attribute. Section 12.2 describes the restrictions on these attributes. The client MUST only include an XOR-PEER-ADDRESS attribute with an address of the same address family as that of a relayed transport address for the allocation.",
      "ja": "ChannelBindトランザクションを開始するために、クライアントはChannelBind要求を作成します。 バインドされるチャネルはCHANNEL-NUMBER属性で指定され、ピアのトランスポートアドレスはXOR-PEER-ADDRESS属性で指定されます。 セクション12.2では、これらの属性の制限について説明しています。 クライアントは、割り当てのために中継されるトランスポートアドレスと同じアドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性のみを含めなければなりません。"
    },
    {
      "indent": 3,
      "text": "Rebinding a channel to the same transport address that it is already bound to provides a way to refresh a channel binding and the corresponding permission without sending data to the peer. Note, however, that permissions need to be refreshed more frequently than channels.",
      "ja": "既にバインドされている同じトランスポートアドレスにチャネルを再バインドすると、ピアにデータを送信せずにチャネルバインドと対応するアクセス許可を更新する方法が提供されます。 ただし、チャネルよりも頻繁に権限を更新する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "12.2. Receiving a ChannelBind Request",
      "section_title": true,
      "ja": "12.2. ChannelBindリクエストの受信"
    },
    {
      "indent": 3,
      "text": "When the server receives a ChannelBind request, it processes as per Section 5 plus the specific rules mentioned here.",
      "ja": "サーバーがChannelBind要求を受信すると、セクション5に加えて、ここで説明した特定のルールに従って処理します。"
    },
    {
      "indent": 3,
      "text": "The server checks the following:",
      "ja": "サーバーは次をチェックします。"
    },
    {
      "indent": 3,
      "text": "* The request contains both a CHANNEL-NUMBER and an XOR-PEER-ADDRESS attribute;",
      "ja": "* 要求には、CHANNEL-NUMBER属性とXOR-PEER-ADDRESS属性の両方が含まれています。"
    },
    {
      "indent": 3,
      "text": "* The channel number is in the range 0x4000 through 0x4FFF (inclusive);",
      "ja": "* チャネル番号の範囲は0x4000〜0x4FFF（両端を含む）です。"
    },
    {
      "indent": 3,
      "text": "* The channel number is not currently bound to a different transport address (same transport address is OK);",
      "ja": "* 現在、チャネル番号は別のトランスポートアドレスにバインドされていません（同じトランスポートアドレスでも構いません）。"
    },
    {
      "indent": 3,
      "text": "* The transport address is not currently bound to a different channel number.",
      "ja": "* 現在、トランスポートアドレスは別のチャネル番号にバインドされていません。"
    },
    {
      "indent": 3,
      "text": "If any of these tests fail, the server replies with a 400 (Bad Request) error. If the XOR-PEER-ADDRESS attribute contains an address of an address family that is not the same as that of a relayed transport address for the allocation, the server MUST generate an error response with the 443 (Peer Address Family Mismatch) response code.",
      "ja": "これらのテストのいずれかが失敗すると、サーバーは400（Bad Request）エラーで応答します。 XOR-PEER-ADDRESS属性に、割り当てのための中継されたトランスポートアドレスとは異なるアドレスファミリのアドレスが含まれている場合、サーバーは443（ピアアドレスファミリ不一致）応答コードでエラー応答を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute; if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.",
      "ja": "サーバーは、XOR-PEER-ADDRESS属性で許可されているIPアドレスとポート値に制限を課すことができます。 値が許可されない場合、サーバーは403（禁止）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "If the request is valid, but the server is unable to fulfill the request due to some capacity limit or similar, the server replies with a 508 (Insufficient Capacity) error.",
      "ja": "要求は有効であるが、キャパシティーの制限などのためにサーバーが要求を満たすことができない場合、サーバーは508（Insufficient Capacity）エラーで応答します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the server replies with a ChannelBind success response. There are no required attributes in a successful ChannelBind response.",
      "ja": "それ以外の場合、サーバーはChannelBind成功応答で応答します。 成功したChannelBind応答には必須の属性はありません。"
    },
    {
      "indent": 3,
      "text": "If the server can satisfy the request, then the server creates or refreshes the channel binding using the channel number in the CHANNEL-NUMBER attribute and the transport address in the XOR-PEER-ADDRESS attribute. The server also installs or refreshes a permission for the IP address in the XOR-PEER-ADDRESS attribute as described in Section 9.",
      "ja": "サーバーが要求を満たすことができる場合、サーバーはCHANNEL-NUMBER属性のチャネル番号とXOR-PEER-ADDRESS属性のトランスポートアドレスを使用してチャネルバインディングを作成または更新します。 サーバーは、セクション9で説明されているように、XOR-PEER-ADDRESS属性のIPアドレスのアクセス許可もインストールまたは更新します。"
    },
    {
      "indent": 6,
      "text": "| NOTE: A server need not do anything special to implement | idempotency of ChannelBind requests over UDP using the | \"stateless stack approach\". Retransmitted ChannelBind requests | will simply refresh the channel binding and the corresponding | permission. Furthermore, the client must wait 5 minutes before | binding a previously bound channel number or peer address to a | different channel, eliminating the possibility that the | transaction would initially fail but succeed on a | retransmission.",
      "ja": "| 注：サーバーは、実装するために特別なことをする必要はありません。 |を使用したUDP経由のChannelBind要求のべき等性 「ステートレススタックアプローチ」。 再送されたChannelBind要求| チャネルバインディングと対応する|を単に更新します。 許可。 さらに、クライアントは5分前に待機する必要があります。 以前にバインドされたチャネル番号またはピアアドレスを 別のチャネル、 トランザクションは最初は失敗しますが、 再送信。"
    },
    {
      "indent": 0,
      "text": "12.3. Receiving a ChannelBind Response",
      "section_title": true,
      "ja": "12.3. ChannelBind応答の受信"
    },
    {
      "indent": 3,
      "text": "When the client receives a ChannelBind success response, it updates its data structures to record that the channel binding is now active. It also updates its data structures to record that the corresponding permission has been installed or refreshed.",
      "ja": "クライアントはChannelBind成功応答を受信すると、データ構造を更新して、チャネルバインディングがアクティブになったことを記録します。 また、データ構造を更新して、対応する権限がインストールまたは更新されたことを記録します。"
    },
    {
      "indent": 3,
      "text": "If the client receives a ChannelBind failure response that indicates that the channel information is out of sync between the client and the server (e.g., an unexpected 400 \"Bad Request\" response), then it is RECOMMENDED that the client immediately delete the allocation and start afresh with a new allocation.",
      "ja": "クライアントが、チャネル情報がクライアントとサーバー間で同期していないことを示すChannelBind失敗応答を受信した場合（たとえば、予期しない400 \"Bad Request\"応答）、クライアントがすぐに割り当てを削除して開始することをお勧めします 新しい割り当てで新たに。"
    },
    {
      "indent": 0,
      "text": "12.4. The ChannelData Message",
      "section_title": true,
      "ja": "12.4. ChannelDataメッセージ"
    },
    {
      "indent": 3,
      "text": "The ChannelData message is used to carry application data between the client and the server. It has the following format:",
      "ja": "ChannelDataメッセージは、クライアントとサーバー間でアプリケーションデータを伝送するために使用されます。 次の形式があります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Channel Number        |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                       Application Data                        /\n/                                                               /\n|                                                               |\n|                               +-------------------------------+\n|                               |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "The Channel Number field specifies the number of the channel on which the data is traveling, and thus, the address of the peer that is sending or is to receive the data.",
      "ja": "[チャネル番号]フィールドは、データが移動しているチャネルの番号を指定します。したがって、データを送信中または受信しようとしているピアのアドレスを指定します。"
    },
    {
      "indent": 3,
      "text": "The Length field specifies the length in bytes of the application data field (i.e., it does not include the size of the ChannelData header). Note that 0 is a valid length.",
      "ja": "Lengthフィールドは、アプリケーションデータフィールドの長さをバイト単位で指定します（つまり、ChannelDataヘッダーのサイズは含まれません）。 0は有効な長さであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Application Data field carries the data the client is trying to send to the peer, or that the peer is sending to the client.",
      "ja": "アプリケーションデータフィールドには、クライアントがピアに送信しようとしているデータ、またはピアがクライアントに送信しているデータが含まれます。"
    },
    {
      "indent": 0,
      "text": "12.5. Sending a ChannelData Message",
      "section_title": true,
      "ja": "12.5. ChannelDataメッセージの送信"
    },
    {
      "indent": 3,
      "text": "Once a client has bound a channel to a peer, then when the client has data to send to that peer, it may use either a ChannelData message or a Send indication; that is, the client is not obligated to use the channel when it exists and may freely intermix the two message types when sending data to the peer. The server, on the other hand, MUST use the ChannelData message if a channel has been bound to the peer. The server uses a Data indication to signal the XOR-PEER-ADDRESS and ICMP attributes to the client even if a channel has been bound to the peer.",
      "ja": "クライアントがチャネルをピアにバインドすると、そのピアに送信するデータがある場合、ChannelDataメッセージまたは送信指示のいずれかを使用できます。 つまり、クライアントは、存在するチャネルを使用する義務がなく、データをピアに送信するときに2つのメッセージタイプを自由に混在させることができます。 一方、チャネルがピアにバインドされている場合、サーバーはChannelDataメッセージを使用する必要があります。 サーバーは、チャネルがピアにバインドされている場合でも、データ指示を使用してXOR-PEER-ADDRESSおよびICMP属性をクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "The fields of the ChannelData message are filled in as described in Section 12.4.",
      "ja": "ChannelDataメッセージのフィールドは、12.4項で説明されているように入力されます。"
    },
    {
      "indent": 3,
      "text": "Over TCP and TLS-over-TCP, the ChannelData message MUST be padded to a multiple of four bytes in order to ensure the alignment of subsequent messages. The padding is not reflected in the length field of the ChannelData message, so the actual size of a ChannelData message (including padding) is (4 + Length) rounded up to the nearest multiple of 4 (see Section 14 of [RFC8489]). Over UDP, the padding is not required but MAY be included.",
      "ja": "TCPおよびTLS-over-TCPでは、後続のメッセージのアライメントを保証するために、ChannelDataメッセージを4バイトの倍数にパディングする必要があります。 パディングはChannelDataメッセージの長さフィールドに反映されないため、ChannelDataメッセージの実際のサイズ（パディングを含む）は、最も近い4の倍数に切り上げられた（4 +長さ）です（[RFC8489]のセクション14を参照）。 UDPでは、パディングは必要ありませんが、含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "The ChannelData message is then sent on the 5-tuple associated with the allocation.",
      "ja": "ChannelDataメッセージは、割り当てに関連付けられた5タプルで送信されます。"
    },
    {
      "indent": 0,
      "text": "12.6. Receiving a ChannelData Message",
      "section_title": true,
      "ja": "12.6. ChannelDataメッセージの受信"
    },
    {
      "indent": 3,
      "text": "The receiver of the ChannelData message uses the first byte to distinguish it from other multiplexed protocols as described in Table 3. If the message uses a value in the reserved range (0x5000 through 0xFFFF), then the message is silently discarded.",
      "ja": "ChannelDataメッセージの受信者は、最初のバイトを使用して、表3で説明されている他の多重化プロトコルと区別します。メッセージが予約範囲（0x5000〜0xFFFF）の値を使用する場合、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received in a UDP datagram, and if the UDP datagram is too short to contain the claimed length of the ChannelData message (i.e., the UDP header length field value is less than the ChannelData header length field value + 4 + 8), then the message is silently discarded.",
      "ja": "ChannelDataメッセージがUDPデータグラムで受信され、UDPデータグラムが短すぎてChannelDataメッセージの要求された長さを含めることができない場合（つまり、UDPヘッダー長フィールド値がChannelDataヘッダー長フィールド値+ 4 + 8より小さい場合） ）、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received over TCP or over TLS-over-TCP, then the actual length of the ChannelData message is as described in Section 12.5.",
      "ja": "ChannelDataメッセージがTCPまたはTLS-over-TCPで受信される場合、ChannelDataメッセージの実際の長さはセクション12.5で説明されているとおりです。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received on a channel that is not bound to any peer, then the message is silently discarded.",
      "ja": "ChannelDataメッセージがピアにバインドされていないチャネルで受信された場合、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "On the client, it is RECOMMENDED that the client discard the ChannelData message if the client believes there is no active permission towards the peer. On the server, the receipt of a ChannelData message MUST NOT refresh either the channel binding or the permission towards the peer.",
      "ja": "クライアントでは、ピアに対するアクティブな許可がないとクライアントが判断した場合、クライアントがChannelDataメッセージを破棄することが推奨されます。 サーバー上で、ChannelDataメッセージの受信は、チャネルバインディングまたはピアへのアクセス許可を更新してはなりません。"
    },
    {
      "indent": 3,
      "text": "On the server, if no errors are detected, the server relays the application data to the peer by forming a UDP datagram as follows:",
      "ja": "サーバーでエラーが検出されない場合、サーバーは次のようにUDPデータグラムを形成することにより、アプリケーションデータをピアに中継します。"
    },
    {
      "indent": 3,
      "text": "* the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the ChannelData message arrived;",
      "ja": "* ソーストランスポートアドレスは、割り当ての中継されたトランスポートアドレスです。割り当ては、ChannelDataメッセージが到着した5タプルによって決定されます。"
    },
    {
      "indent": 3,
      "text": "* the destination transport address is the transport address to which the channel is bound;",
      "ja": "* 宛先トランスポートアドレスは、チャネルがバインドされているトランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "* the data following the UDP header is the contents of the data field of the ChannelData message.",
      "ja": "* UDPヘッダーに続くデータは、ChannelDataメッセージのデータフィールドの内容です。"
    },
    {
      "indent": 3,
      "text": "The resulting UDP datagram is then sent to the peer. Note that if the Length field in the ChannelData message is 0, then there will be no data in the UDP datagram, but the UDP datagram is still formed and sent (Section 4.1 of [RFC6263]).",
      "ja": "次に、結果のUDPデータグラムがピアに送信されます。 ChannelDataメッセージのLengthフィールドが0の場合、UDPデータグラムにはデータがありませんが、UDPデータグラムはまだ形成されて送信されます（[RFC6263]のセクション4.1）。"
    },
    {
      "indent": 0,
      "text": "12.7. Relaying Data from the Peer",
      "section_title": true,
      "ja": "12.7. ピアからのデータの中継"
    },
    {
      "indent": 3,
      "text": "When the server receives a UDP datagram on the relayed transport address associated with an allocation, the server processes it as described in Section 11.3. If that section indicates that a ChannelData message should be sent (because there is a channel bound to the peer that sent to the UDP datagram), then the server forms and sends a ChannelData message as described in Section 12.5.",
      "ja": "サーバーは、割り当てに関連付けられた中継トランスポートアドレスでUDPデータグラムを受信すると、セクション11.3で説明されているようにそれを処理します。 そのセクションが（UDPデータグラムに送信したピアにバインドされたチャネルがあるために）ChannelDataメッセージを送信する必要があることを示す場合、サーバーはセクション12.5で説明されているようにChannelDataメッセージを形成して送信します。"
    },
    {
      "indent": 3,
      "text": "When the server receives an ICMP packet, the server processes it as described in Section 11.5.",
      "ja": "サーバーがICMPパケットを受信すると、サーバーはセクション11.5の説明に従ってそれを処理します。"
    },
    {
      "indent": 0,
      "text": "13. Packet Translations",
      "section_title": true,
      "ja": "13. パケット翻訳"
    },
    {
      "indent": 3,
      "text": "This section addresses IPv4-to-IPv6, IPv6-to-IPv4, and IPv6-to-IPv6 translations. Requirements for translation of the IP addresses and port numbers of the packets are described above. The following sections specify how to translate other header fields.",
      "ja": "このセクションでは、IPv4-to-IPv6、IPv6-to-IPv4、およびIPv6-to-IPv6変換について説明します。 パケットのIPアドレスとポート番号の変換の要件は上記で説明されています。 以下のセクションでは、他のヘッダーフィールドを変換する方法を指定します。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.6, translations in TURN are designed so that a TURN server can be implemented as an application that runs in user space under commonly available operating systems and that does not require special privileges. The translations specified in the following sections follow this principle.",
      "ja": "セクション3.6で説明したように、TURNの変換は、TURNサーバーを、一般に利用可能なオペレーティングシステムのユーザー空間で実行し、特別な特権を必要としないアプリケーションとして実装できるように設計されています。 次のセクションで指定される翻訳は、この原則に従います。"
    },
    {
      "indent": 3,
      "text": "The descriptions below have two parts: a preferred behavior and an alternate behavior. The server SHOULD implement the preferred behavior, but if that is not possible for a particular field, the server MUST implement the alternate behavior and MUST NOT do anything else for the reasons detailed in [RFC7915]. The TURN server solely relies on the DF bit in the IPv4 header and the Fragment header in the IPv6 header to handle fragmentation using the approach described in [RFC7915] and does not rely on the DONT-FRAGMENT attribute; ignoring the DONT-FRAGMENT attribute is only applicable for UDP-to-UDP relay and not for TCP-to-UDP relay.",
      "ja": "以下の説明には、優先動作と代替動作の2つの部分があります。 サーバーは優先動作を実装すべきである（SHOULD）が、特定のフィールドでそれが不可能な場合、サーバーは代替動作を実装する必要があり、[RFC7915]で詳述されている理由で他に何もしてはならない。 TURNサーバーは、IPv4ヘッダーのDFビットとIPv6ヘッダーのFragmentヘッダーのみに依存して、[RFC7915]で説明されているアプローチを使用してフラグメンテーションを処理し、DONT-FRAGMENT属性に依存しません。 DONT-FRAGMENT属性を無視することは、UDPからUDPへのリレーにのみ適用され、TCPからUDPへのリレーには適用されません。"
    },
    {
      "indent": 0,
      "text": "13.1. IPv4-to-IPv6 Translations",
      "section_title": true,
      "ja": "13.1. IPv4-to-IPv6変換"
    },
    {
      "indent": 3,
      "text": "Time to Live (TTL) field",
      "ja": "存続時間（TTL）フィールド"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: As specified in Section 4 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション4で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to the default for outgoing packets.",
      "ja": "代替動作：発信値を発信パケットのデフォルトに設定します。"
    },
    {
      "indent": 3,
      "text": "Traffic Class",
      "ja": "トラフィッククラス"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 4 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション4で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server sets the Traffic Class to the default value for outgoing packets.",
      "ja": "代替動作：TURNサーバーは、トラフィッククラスを発信パケットのデフォルト値に設定します。"
    },
    {
      "indent": 3,
      "text": "Flow Label",
      "ja": "フローラベル"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The TURN server can use the 5-tuple of relayed transport address, peer transport address, and UDP protocol number to identify each flow and to generate and set the flow label value in the IPv6 packet as discussed in Section 3 of [RFC6437]. If the TURN server is incapable of generating the flow label value from the IPv6 packet's 5-tuple, it sets the Flow label to zero.",
      "ja": "推奨される動作：TURNサーバーは、[RFC6437 ]。 TURNサーバーがIPv6パケットの5タプルからフローラベル値を生成できない場合、フローラベルをゼロに設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The alternate behavior is the same as the preferred behavior for a TURN server that does not support flow labels.",
      "ja": "代替動作：代替動作は、フローラベルをサポートしないTURNサーバーの推奨動作と同じです。"
    },
    {
      "indent": 3,
      "text": "Hop Limit",
      "ja": "ホップ制限"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 4 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション4で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server sets the Hop Limit to the default value for outgoing packets.",
      "ja": "代替動作：TURNサーバーは、ホップ制限を発信パケットのデフォルト値に設定します。"
    },
    {
      "indent": 3,
      "text": "Fragmentation",
      "ja": "フラグメンテーション"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 4 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション4で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.",
      "ja": "代替動作：TURNサーバーは着信フラグメントを組み立てます。 TURNサーバーは、デフォルトの動作に従って発信パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "For both preferred and alternate behavior, the DONT-FRAGMENT attribute MUST be ignored by the server.",
      "ja": "優先動作と代替動作の両方について、DONT-FRAGMENT属性はサーバーによって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extension Headers",
      "ja": "拡張ヘッダー"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers, with the exception of the Fragment header as described above.",
      "ja": "推奨される動作：送信パケットは、上記のフラグメントヘッダーを除き、IPv6拡張ヘッダーのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 0,
      "text": "13.2. IPv6-to-IPv6 Translations",
      "section_title": true,
      "ja": "13.2. IPv6-to-IPv6変換"
    },
    {
      "indent": 3,
      "text": "Flow Label",
      "ja": "フローラベル"
    },
    {
      "indent": 3,
      "text": "NOTE: The TURN server should consider that it is handling two different IPv6 flows. Therefore, the Flow label [RFC6437] SHOULD NOT be copied as part of the translation.",
      "ja": "注：TURNサーバーは、2つの異なるIPv6フローを処理していることを考慮する必要があります。 したがって、フローラベル[RFC6437]は、翻訳の一部としてコピーされるべきではありません。"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The TURN server can use the 5-tuple of relayed transport address, peer transport address, and UDP protocol number to identify each flow and to generate and set the flow label value in the IPv6 packet as discussed in Section 3 of [RFC6437]. If the TURN server is incapable of generating the flow label value from the IPv6 packet's 5-tuple, it sets the Flow label to zero.",
      "ja": "推奨される動作：TURNサーバーは、[RFC6437 ]。 TURNサーバーがIPv6パケットの5タプルからフローラベル値を生成できない場合、フローラベルをゼロに設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The alternate behavior is the same as the preferred behavior for a TURN server that does not support flow labels.",
      "ja": "代替動作：代替動作は、フローラベルをサポートしないTURNサーバーの推奨動作と同じです。"
    },
    {
      "indent": 3,
      "text": "Hop Limit",
      "ja": "ホップ制限"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The TURN server acts as a regular router with respect to decrementing the Hop Limit and generating an ICMPv6 error if it reaches zero.",
      "ja": "推奨される動作：TURNサーバーは、ホップリミットをデクリメントし、ゼロに達するとICMPv6エラーを生成するという点で通常のルーターとして機能します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server sets the Hop Limit to the default value for outgoing packets.",
      "ja": "代替動作：TURNサーバーは、ホップ制限を発信パケットのデフォルト値に設定します。"
    },
    {
      "indent": 3,
      "text": "Fragmentation",
      "ja": "フラグメンテーション"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: If the incoming packet did not include a Fragment header and the outgoing packet size does not exceed the outgoing link's MTU, the TURN server sends the outgoing packet without a Fragment header.",
      "ja": "推奨される動作：着信パケットにフラグメントヘッダーが含まれておらず、発信パケットサイズが発信リンクのMTUを超えていない場合、TURNサーバーはフラグメントヘッダーなしで発信パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "If the incoming packet did not include a Fragment header and the outgoing packet size exceeds the outgoing link's MTU, the TURN server drops the outgoing packet and sends an ICMP message of type 2 code 0 (\"Packet too big\") to the sender of the incoming packet. If the ICMPv6 packet (\"Packet too big\") is being sent to the peer, the TURN server SHOULD reduce the MTU reported in the ICMP message by 48 bytes to allow room for the overhead of a Data indication.",
      "ja": "着信パケットにフラグメントヘッダーが含まれておらず、発信パケットサイズが発信リンクのMTUを超えている場合、TURNサーバーは発信パケットをドロップし、タイプ2コード0（「パケットが大きすぎます」）のICMPメッセージを送信者に送信します 着信パケット。 ICMPv6パケット（「パケットが大きすぎる」）がピアに送信されている場合、TURNサーバーは、ICMPメッセージで報告されたMTUを48バイト削減して、データ表示のオーバーヘッドのためのスペースを確保する必要があります。"
    },
    {
      "indent": 6,
      "text": "If the incoming packet included a Fragment header and the outgoing packet size (with a Fragment header included) does not exceed the outgoing link's MTU, the TURN server sends the outgoing packet with a Fragment header. The TURN server sets the fields of the Fragment header as appropriate for a packet originating from the server.",
      "ja": "着信パケットにフラグメントヘッダーが含まれていて、発信パケットサイズ（フラグメントヘッダーが含まれている）が発信リンクのMTUを超えていない場合、TURNサーバーは発信パケットにフラグメントヘッダーを送信します。 TURNサーバーは、サーバーから発信されたパケットに適切なフラグメントヘッダーのフィールドを設定します。"
    },
    {
      "indent": 6,
      "text": "If the incoming packet included a Fragment header and the outgoing packet size exceeds the outgoing link's MTU, the TURN server MUST fragment the outgoing packet into fragments of no more than 1280 bytes. The TURN server sets the fields of the Fragment header as appropriate for a packet originating from the server.",
      "ja": "着信パケットにフラグメントヘッダーが含まれ、発信パケットサイズが発信リンクのMTUを超える場合、TURNサーバーは発信パケットを1280バイト以下のフラグメントにフラグメント化する必要があります。 TURNサーバーは、サーバーから発信されたパケットに適切なフラグメントヘッダーのフィールドを設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.",
      "ja": "代替動作：TURNサーバーは着信フラグメントを組み立てます。 TURNサーバーは、デフォルトの動作に従って発信パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "For both preferred and alternate behavior, the DONT-FRAGMENT attribute MUST be ignored by the server.",
      "ja": "優先動作と代替動作の両方について、DONT-FRAGMENT属性はサーバーによって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extension Headers",
      "ja": "拡張ヘッダー"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers, with the exception of the Fragment header as described above.",
      "ja": "推奨される動作：送信パケットは、上記のフラグメントヘッダーを除き、IPv6拡張ヘッダーのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 0,
      "text": "13.3. IPv6-to-IPv4 Translations",
      "section_title": true,
      "ja": "13.3. IPv6-to-IPv4変換"
    },
    {
      "indent": 3,
      "text": "Type of Service and Precedence",
      "ja": "サービスの種類と優先順位"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 5 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション5で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server sets the Type of Service and Precedence to the default value for outgoing packets.",
      "ja": "代替動作：TURNサーバーは、発信パケットのタイプオブサービスと優先順位をデフォルト値に設定します。"
    },
    {
      "indent": 3,
      "text": "Time to Live",
      "ja": "有効期間"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 5 of [RFC7915].",
      "ja": "推奨される動作：[RFC7915]のセクション5で指定されているとおり。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server sets the Time to Live to the default value for outgoing packets.",
      "ja": "代替動作：TURNサーバーは、送信パケットの生存時間をデフォルト値に設定します。"
    },
    {
      "indent": 3,
      "text": "Fragmentation",
      "ja": "フラグメンテーション"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: As specified in Section 5 of [RFC7915]. Additionally, when the outgoing packet's size exceeds the outgoing link's MTU, the TURN server needs to generate an ICMP error (ICMPv6 \"Packet too big\") reporting the MTU size. If the ICMPv4 packet (Destination Unreachable (Type 3) with Code 4) is being sent to the peer, the TURN server SHOULD reduce the MTU reported in the ICMP message by 48 bytes to allow room for the overhead of a Data indication.",
      "ja": "推奨される動作：[RFC7915]のセクション5で指定されているとおり。 さらに、発信パケットのサイズが発信リンクのMTUを超えると、TURNサーバーは、MTUサイズを報告するICMPエラー（ICMPv6「パケットが大きすぎます」）を生成する必要があります。 ICMPv4パケット（コード4の宛先到達不能（タイプ3））がピアに送信されている場合、TURNサーバーは、ICMPメッセージで報告されるMTUを48バイト削減して、データ表示のオーバーヘッドのためのスペースを確保する必要があります。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: The TURN server assembles incoming fragments. The TURN server follows its default behavior to send outgoing packets.",
      "ja": "代替動作：TURNサーバーは着信フラグメントを組み立てます。 TURNサーバーは、デフォルトの動作に従って発信パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "For both preferred and alternate behavior, the DONT-FRAGMENT attribute MUST be ignored by the server.",
      "ja": "優先動作と代替動作の両方について、DONT-FRAGMENT属性はサーバーによって無視されなければなりません。"
    },
    {
      "indent": 0,
      "text": "14. UDP-to-UDP Relay",
      "section_title": true,
      "ja": "14. UDP-to-UDPリレー"
    },
    {
      "indent": 3,
      "text": "This section describes how the server sets various fields in the IP header for UDP-to-UDP relay from the client to the peer or vice versa. The descriptions in this section apply (a) when the server sends a UDP datagram to the peer or (b) when the server sends a Data indication or ChannelData message to the client over UDP transport. The descriptions in this section do not apply to TURN messages sent over TCP or TLS transport from the server to the client.",
      "ja": "このセクションでは、サーバーがクライアントからピアへ、またはその逆へのUDPからUDPへのリレーのIPヘッダーにさまざまなフィールドを設定する方法について説明します。 このセクションの説明は、（a）サーバーがピアにUDPデータグラムを送信するとき、または（b）サーバーがUDP転送を介してクライアントにデータ表示またはChannelDataメッセージを送信するときに適用されます。 このセクションの説明は、TCPまたはTLSトランスポートを介してサーバーからクライアントに送信されるTURNメッセージには適用されません。"
    },
    {
      "indent": 3,
      "text": "The descriptions below have two parts: a preferred behavior and an alternate behavior. The server SHOULD implement the preferred behavior, but if that is not possible for a particular field, then it SHOULD implement the alternative behavior.",
      "ja": "以下の説明には、優先動作と代替動作の2つの部分があります。 サーバーは優先動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Differentiated Services Code Point (DSCP) field [RFC2474]",
      "ja": "DiffServコードポイント（DSCP）フィールド[RFC2474]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Set the outgoing value to the incoming value unless the server includes a differentiated services classifier and marker [RFC2474].",
      "ja": "推奨される動作：サーバーにDifferentiated Services Classifier and Marker [RFC2474]が含まれていない限り、発信値を着信値に設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to a fixed value, which by default is Best Effort unless configured otherwise.",
      "ja": "代替動作：発信値を固定値に設定します。これは、特に設定しない限り、デフォルトではベストエフォートです。"
    },
    {
      "indent": 6,
      "text": "In both cases, if the server is immediately adjacent to a differentiated services classifier and marker, then DSCP MAY be set to any arbitrary value in the direction towards the classifier.",
      "ja": "どちらの場合でも、サーバーが差別化サービス分類子とマーカーにすぐ隣接している場合、DSCPは分類子に向かう方向の任意の値に設定される場合があります。"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) field [RFC3168]",
      "ja": "明示的な輻輳通知（ECN）フィールド[RFC3168]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Set the outgoing value to the incoming value. The server may perform Active Queue Management, in which case it SHOULD behave as an ECN-aware router [RFC3168] and can mark traffic with Congestion Experienced (CE) instead of dropping the packet. The use of ECT(1) is subject to experimental usage [RFC8311].",
      "ja": "好ましい動作：発信値を着信値に設定します。 サーバーはActive Queue Managementを実行できます。この場合、ECN対応ルーター[RFC3168]として動作する必要があり（SHOULD）、パケットをドロップする代わりにCongestion Experienced（CE）でトラフィックをマークできます。 ECT（1）の使用は、実験的な使用法の対象となります[RFC8311]。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to Not-ECT (=0b00).",
      "ja": "代替動作：発信値をNot-ECT（= 0b00）に設定します。"
    },
    {
      "indent": 3,
      "text": "IPv4 Fragmentation fields (applicable only for IPv4-to-IPv4 relay)",
      "ja": "IPv4フラグメンテーションフィールド（IPv4-to-IPv4リレーにのみ適用可能）"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: When the server sends a packet to a peer in response to a Send indication containing the DONT-FRAGMENT attribute, then set the outgoing UDP packet to not fragment. In all other cases, when sending an outgoing packet containing application data (e.g., Data indication, a ChannelData message, or the DONT-FRAGMENT attribute not included in the Send indication), copy the DF bit from the DF bit of the incoming packet that contained the application data.",
      "ja": "推奨される動作：サーバーがDONT-FRAGMENT属性を含む送信指示に応答してパケットをピアに送信する場合、発信UDPパケットをフラグメント化しないように設定します。 他のすべての場合、アプリケーションデータ（たとえば、Data指示、ChannelDataメッセージ、またはSend指示に含まれていないDONT-FRAGMENT属性）を含む発信パケットを送信する場合、着信パケットのDFビットからDFビットをコピーします。 アプリケーションデータが含まれていました。"
    },
    {
      "indent": 6,
      "text": "Set the other fragmentation fields (Identification, More Fragments, Fragment Offset) as appropriate for a packet originating from the server.",
      "ja": "サーバーから発信されたパケットに応じて、他の断片化フィールド（識別、追加フラグメント、フラグメントオフセット）を設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: As described in the Preferred Behavior, except always assume the incoming DF bit is 0.",
      "ja": "代替動作：優先される動作で説明されているように、常に着信DFビットが0であると仮定します。"
    },
    {
      "indent": 6,
      "text": "In both the Preferred and Alternate Behaviors, the resulting packet may be too large for the outgoing link. If this is the case, then the normal fragmentation rules apply [RFC1122].",
      "ja": "優先動作と代替動作の両方で、結果のパケットが発信リンクに対して大きすぎる可能性があります。 この場合、通常のフラグメンテーションルールが適用されます[RFC1122]。"
    },
    {
      "indent": 3,
      "text": "IPv4 Options",
      "ja": "IPv4オプション"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.",
      "ja": "推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 0,
      "text": "15. TCP-to-UDP Relay",
      "section_title": true,
      "ja": "15. TCPからUDPへのリレー"
    },
    {
      "indent": 3,
      "text": "This section describes how the server sets various fields in the IP header for TCP-to-UDP relay from the client to the peer. The descriptions in this section apply when the server sends a UDP datagram to the peer. Note that the server does not perform per-packet translation for TCP-to-UDP relaying.",
      "ja": "このセクションでは、サーバーがクライアントからピアへのTCPからUDPへのリレーのIPヘッダーにさまざまなフィールドを設定する方法について説明します。 このセクションの説明は、サーバーがUDPデータグラムをピアに送信するときに適用されます。 サーバーは、TCPからUDPへのリレーのパケットごとの変換を実行しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Multipath TCP [TCP-EXT] is not supported by this version of TURN because TCP multipath is not used by either SIP or WebRTC protocols [RFC7478] for media and non-media data. TCP connection between the TURN client and server can use the TCP Authentication Option (TCP-AO) [RFC5925], but UDP does not provide a similar type of authentication, though it might be added in the future [UDP-OPT]. Even if both TCP-AO and UDP authentication would be used between TURN client and server, it would not change the end-to-end security properties of the application payload being relayed. Therefore, applications using TURN will need to secure their application data end to end appropriately, e.g., Secure Real-time Transport Protocol (SRTP) for RTP applications. Note that the TCP-AO option obsoletes the TCP MD5 option.",
      "ja": "マルチパスTCP [TCP-EXT]は、このバージョンのTURNではサポートされません。これは、TCPマルチパスが、SIPまたはWebRTCプロトコル[RFC7478]でメディアおよび非メディアデータに使用されないためです。 TURNクライアントとサーバー間のTCP接続はTCP認証オプション（TCP-AO）[RFC5925]を使用できますが、UDPは同様のタイプの認証を提供しませんが、将来追加される可能性があります[UDP-OPT]。 TURNクライアントとサーバーの間でTCP-AO認証とUDP認証の両方が使用される場合でも、中継されるアプリケーションペイロードのエンドツーエンドのセキュリティプロパティは変更されません。 したがって、TURNを使用するアプリケーションは、アプリケーションデータをエンドツーエンドで適切に保護する必要があります（RTPアプリケーションのSRTP（Secure Real-time Transport Protocol）など）。 TCP-AOオプションは、TCP MD5オプションを廃止することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Unlike UDP, TCP without the TCP Fast Open extension [RFC7413] does not support 0-RTT session resumption. The TCP user timeout [RFC5482] equivalent for application data relayed by the TURN is the use of RTP control protocol (RTCP). As a reminder, RTCP is a fundamental and integral part of RTP.",
      "ja": "UDPとは異なり、TCP Fast Open拡張機能[RFC7413]を使用しないTCPは、0-RTTセッション再開をサポートしません。 TURNによってリレーされるアプリケーションデータに相当するTCPユーザータイムアウト[RFC5482]は、RTP制御プロトコル（RTCP）の使用です。 念のため、RTCPはRTPの基本的かつ不可欠な部分です。"
    },
    {
      "indent": 3,
      "text": "The descriptions below have two parts: a preferred behavior and an alternate behavior. The server SHOULD implement the preferred behavior, but if that is not possible for a particular field, then it SHOULD implement the alternative behavior.",
      "ja": "以下の説明には、優先動作と代替動作の2つの部分があります。 サーバーは優先動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the UDP datagram sent to the peer based on a Send Indication or ChannelData message arriving at the TURN server over a TCP Transport, the server sets various fields in the IP header as follows:",
      "ja": "TCPトランスポートを介してTURNサーバーに到着したSend IndicationまたはChannelDataメッセージに基づいてピアに送信されるUDPデータグラムの場合、サーバーはIPヘッダーのさまざまなフィールドを次のように設定します。"
    },
    {
      "indent": 3,
      "text": "Differentiated Services Code Point (DSCP) field [RFC2474]",
      "ja": "DiffServコードポイント（DSCP）フィールド[RFC2474]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: The TCP connection can only use a single DSCP, so inter-flow differentiation is not possible; see Section 5.1 of [RFC7657]. The server sets the outgoing value to the DSCP used by the TCP connection, unless the server includes a differentiated services classifier and marker [RFC2474].",
      "ja": "推奨される動作：TCP接続は単一のDSCPのみを使用できるため、フロー間の区別はできません。 [RFC7657]のセクション5.1を参照してください。 サーバーは、差別化されたサービス分類子とマーカー[RFC2474]が含まれていない限り、発信値をTCP接続で使用されるDSCPに設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to a fixed value, which by default is Best Effort unless configured otherwise.",
      "ja": "代替動作：発信値を固定値に設定します。これは、特に設定しない限り、デフォルトではベストエフォートです。"
    },
    {
      "indent": 6,
      "text": "In both cases, if the server is immediately adjacent to a differentiated services classifier and marker, then DSCP MAY be set to any arbitrary value in the direction towards the classifier.",
      "ja": "どちらの場合でも、サーバーが差別化サービス分類子とマーカーにすぐ隣接している場合、DSCPは分類子に向かう方向の任意の値に設定される場合があります。"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) field [RFC3168]",
      "ja": "明示的な輻輳通知（ECN）フィールド[RFC3168]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: No mechanism is defined to indicate what ECN value should be used for the outgoing UDP datagrams of an allocation; therefore, set the outgoing value to Not-ECT (=0b00).",
      "ja": "推奨される動作：割り当ての発信UDPデータグラムに使用するECN値を示すメカニズムは定義されていません。 したがって、発信値をNot-ECT（= 0b00）に設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "IPv4 Fragmentation fields (applicable only for IPv4-to-IPv4 relay)",
      "ja": "IPv4フラグメンテーションフィールド（IPv4-to-IPv4リレーにのみ適用可能）"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: When the server sends a packet to a peer in response to a Send indication containing the DONT-FRAGMENT attribute, set the outgoing UDP packet to not fragment. In all other cases, when sending an outgoing UDP packet containing application data (e.g., Data indication, ChannelData message, or DONT-FRAGMENT attribute not included in the Send indication), set the DF bit in the outgoing IP header to 0.",
      "ja": "推奨される動作：サーバーがDONT-FRAGMENT属性を含む送信指示に応答してパケットをピアに送信する場合、発信UDPパケットをフラグメント化しないように設定します。 他のすべての場合、アプリケーションデータ（たとえば、データ表示、ChannelDataメッセージ、または送信表示に含まれないDONT-FRAGMENT属性）を含む発信UDPパケットを送信する場合、発信IPヘッダーのDFビットを0に設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "IPv6 Fragmentation fields",
      "ja": "IPv6フラグメンテーションフィールド"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: If the TCP traffic arrives over IPv6, the server relies on the presence of the DONT-FRAGMENT attribute in the send indication to set the outgoing UDP packet to not fragment.",
      "ja": "推奨される動作：TCPトラフィックがIPv6を介して到着した場合、サーバーは送信指示のDONT-FRAGMENT属性の存在に依存して、発信UDPパケットをフラグメント化しないように設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "IPv4 Options",
      "ja": "IPv4オプション"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.",
      "ja": "推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 0,
      "text": "16. UDP-to-TCP Relay",
      "section_title": true,
      "ja": "16. UDPからTCPへのリレー"
    },
    {
      "indent": 3,
      "text": "This section describes how the server sets various fields in the IP header for UDP-to-TCP relay from the peer to the client. The descriptions in this section apply when the server sends a Data indication or ChannelData message to the client over TCP or TLS transport. Note that the server does not perform per-packet translation for UDP-to-TCP relaying.",
      "ja": "このセクションでは、サーバーがピアからクライアントへのUDPからTCPへのリレーのIPヘッダーにさまざまなフィールドを設定する方法について説明します。 このセクションの説明は、サーバーがTCPまたはTLSトランスポートを介してデータ表示またはChannelDataメッセージをクライアントに送信するときに適用されます。 サーバーは、UDPからTCPへのリレーのパケットごとの変換を実行しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The descriptions below have two parts: a preferred behavior and an alternate behavior. The server SHOULD implement the preferred behavior, but if that is not possible for a particular field, then it SHOULD implement the alternative behavior.",
      "ja": "以下の説明には、優先動作と代替動作の2つの部分があります。 サーバーは優先動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "The TURN server sets IP header fields in the TCP packets on a per-connection basis for the TCP connection as follows:",
      "ja": "TURNサーバーは、次のように、TCP接続の接続ごとにTCPパケットにIPヘッダーフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "Differentiated Services Code Point (DSCP) field [RFC2474]",
      "ja": "DiffServコードポイント（DSCP）フィールド[RFC2474]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Ignore the incoming DSCP value. When TCP is used between the client and the server, a single DSCP should be used for all traffic on that TCP connection. Note, TURN/ICE occurs before application data is exchanged.",
      "ja": "好ましい動作：着信DSCP値を無視します。 クライアントとサーバー間でTCPを使用する場合、そのTCP接続のすべてのトラフィックに単一のDSCPを使用する必要があります。 アプリケーションデータが交換される前に、TURN / ICEが発生することに注意してください。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) field [RFC3168]",
      "ja": "明示的な輻輳通知（ECN）フィールド[RFC3168]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Ignore; ECN signals are dropped in the TURN server for the incoming UDP datagrams from the peer.",
      "ja": "推奨される動作：無視; ECN信号は、ピアからの着信UDPデータグラムのTURNサーバーでドロップされます。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "Fragmentation",
      "ja": "フラグメンテーション"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Any fragmented packets are reassembled in the server and then forwarded to the client over the TCP connection. ICMP messages resulting from the UDP datagrams sent to the peer are processed by the server as described in Section 11.5 and forwarded to the client using TURN's mechanism for relevant ICMP types and codes.",
      "ja": "推奨される動作：断片化されたパケットはサーバーで再構築され、TCP接続を介してクライアントに転送されます。 ピアに送信されたUDPデータグラムから生じるICMPメッセージは、セクション11.5で説明されているようにサーバーによって処理され、関連するICMPタイプとコードのTURNのメカニズムを使用してクライアントに転送されます。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "Extension Headers",
      "ja": "拡張ヘッダー"
    },
    {
      "indent": 6,
      "text": "Preferred behavior: The outgoing packet uses the system defaults for IPv6 extension headers.",
      "ja": "推奨される動作：発信パケットは、IPv6拡張ヘッダーのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 3,
      "text": "IPv4 Options",
      "ja": "IPv4オプション"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: The outgoing packet uses the system defaults for IPv4 options.",
      "ja": "推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：推奨と同じ。"
    },
    {
      "indent": 0,
      "text": "17. STUN Methods",
      "section_title": true,
      "ja": "17. STUNメソッド"
    },
    {
      "indent": 3,
      "text": "This section lists the code points for the STUN methods defined in this specification. See elsewhere in this document for the semantics of these methods.",
      "ja": "このセクションでは、この仕様で定義されているSTUNメソッドのコードポイントを示します。 これらのメソッドのセマンティクスについては、このドキュメントの別の場所を参照してください。"
    },
    {
      "indent": 11,
      "text": "+-------+------------------+------------------------+\n| 0x003 | Allocate         | (only request/response |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+\n| 0x004 | Refresh          | (only request/response |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+\n| 0x006 | Send             | (only indication       |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+\n| 0x007 | Data             | (only indication       |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+\n| 0x008 | CreatePermission | (only request/response |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+\n| 0x009 | ChannelBind      | (only request/response |\n|       |                  | semantics defined)     |\n+-------+------------------+------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 0,
      "text": "18. STUN Attributes",
      "section_title": true,
      "ja": "18. STUN属性"
    },
    {
      "indent": 3,
      "text": "This STUN extension defines the following attributes:",
      "ja": "このSTUN拡張機能は、次の属性を定義します。"
    },
    {
      "indent": 18,
      "text": "+--------+---------------------------+\n| 0x000C | CHANNEL-NUMBER            |\n+--------+---------------------------+\n| 0x000D | LIFETIME                  |\n+--------+---------------------------+\n| 0x0010 | Reserved (was BANDWIDTH)  |\n+--------+---------------------------+\n| 0x0012 | XOR-PEER-ADDRESS          |\n+--------+---------------------------+\n| 0x0013 | DATA                      |\n+--------+---------------------------+\n| 0x0016 | XOR-RELAYED-ADDRESS       |\n+--------+---------------------------+\n| 0x0017 | REQUESTED-ADDRESS-FAMILY  |\n+--------+---------------------------+\n| 0x0018 | EVEN-PORT                 |\n+--------+---------------------------+\n| 0x0019 | REQUESTED-TRANSPORT       |\n+--------+---------------------------+\n| 0x001A | DONT-FRAGMENT             |\n+--------+---------------------------+\n| 0x0021 | Reserved (was TIMER-VAL)  |\n+--------+---------------------------+\n| 0x0022 | RESERVATION-TOKEN         |\n+--------+---------------------------+\n| 0x8000 | ADDITIONAL-ADDRESS-FAMILY |\n+--------+---------------------------+\n| 0x8001 | ADDRESS-ERROR-CODE        |\n+--------+---------------------------+\n| 0x8004 | ICMP                      |\n+--------+---------------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 5",
      "ja": "表5"
    },
    {
      "indent": 3,
      "text": "Some of these attributes have lengths that are not multiples of 4. By the rules of STUN, any attribute whose length is not a multiple of 4 bytes MUST be immediately followed by 1 to 3 padding bytes to ensure the next attribute (if any) would start on a 4-byte boundary (see [RFC8489]).",
      "ja": "これらの属性の一部の長さは4の倍数ではありません。STUNの規則により、長さが4バイトの倍数ではない属性の直後には、次の属性（存在する場合） 4バイト境界で開始します（[RFC8489]を参照）。"
    },
    {
      "indent": 0,
      "text": "18.1. CHANNEL-NUMBER",
      "section_title": true,
      "ja": "18.1. チャンネル番号"
    },
    {
      "indent": 3,
      "text": "The CHANNEL-NUMBER attribute contains the number of the channel. The value portion of this attribute is 4 bytes long and consists of a 16-bit unsigned integer followed by a two-octet RFFU (Reserved For Future Use) field, which MUST be set to 0 on transmission and MUST be ignored on reception.",
      "ja": "CHANNEL-NUMBER属性には、チャネルの番号が含まれています。 この属性の値の部分は4バイト長で、16ビットの符号なし整数とそれに続く2オクテットのRFFU（Reserved For Future Use）フィールドで構成されます。送信時に0に設定し、受信時に無視する必要があります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Channel Number         |         RFFU = 0              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 0,
      "text": "18.2. LIFETIME",
      "section_title": true,
      "ja": "18.2. 一生"
    },
    {
      "indent": 3,
      "text": "The LIFETIME attribute represents the duration for which the server will maintain an allocation in the absence of a refresh. The TURN client can include the LIFETIME attribute with the desired lifetime in Allocate and Refresh requests. The value portion of this attribute is 4 bytes long and consists of a 32-bit unsigned integral value representing the number of seconds remaining until expiration.",
      "ja": "LIFETIME属性は、更新がない場合にサーバーが割り当てを維持する期間を表します。 TURNクライアントは、割り当て要求および更新要求に、希望するライフタイムを持つLIFETIME属性を含めることができます。 この属性の値部分は4バイト長で、有効期限までの残りの秒数を表す32ビットの符号なし整数値で構成されます。"
    },
    {
      "indent": 0,
      "text": "18.3. XOR-PEER-ADDRESS",
      "section_title": true,
      "ja": "18.3. XOR-PEER-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The XOR-PEER-ADDRESS attribute specifies the address and port of the peer as seen from the TURN server. (For example, the peer's server-reflexive transport address if the peer is behind a NAT.) It is encoded in the same way as the XOR-MAPPED-ADDRESS attribute [RFC8489].",
      "ja": "XOR-PEER-ADDRESS属性は、TURNサーバーから見たピアのアドレスとポートを指定します。 （たとえば、ピアがNATの背後にある場合、ピアのサーバー反射トランスポートアドレス。）XOR-MAPPED-ADDRESS属性[RFC8489]と同じ方法でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "18.4. DATA",
      "section_title": true,
      "ja": "18.4. データ"
    },
    {
      "indent": 3,
      "text": "The DATA attribute is present in all Send indications. If the ICMP attribute is not present in a Data indication, it contains a DATA attribute. The value portion of this attribute is variable length and consists of the application data (that is, the data that would immediately follow the UDP header if the data was sent directly between the client and the peer). The application data is equivalent to the \"UDP user data\" and does not include the \"surplus area\" defined in Section 4 of [UDP-OPT]. If the length of this attribute is not a multiple of 4, then padding must be added after this attribute.",
      "ja": "DATA属性は、すべての送信指示に存在します。 ICMP属性がデータ表示に存在しない場合、DATA属性が含まれています。 この属性の値部分は可変長であり、アプリケーションデータ（つまり、データがクライアントとピア間で直接送信された場合、UDPヘッダーの直後に続くデータ）で構成されます。 アプリケーションデータは「UDPユーザーデータ」と同等であり、[UDP-OPT]のセクション4で定義された「余剰領域」を含みません。 この属性の長さが4の倍数でない場合、この属性の後にパディングを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.5. XOR-RELAYED-ADDRESS",
      "section_title": true,
      "ja": "18.5. XOR-RELAYED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The XOR-RELAYED-ADDRESS attribute is present in Allocate responses. It specifies the address and port that the server allocated to the client. It is encoded in the same way as the XOR-MAPPED-ADDRESS attribute [RFC8489].",
      "ja": "XOR-RELAYED-ADDRESS属性は、応答の割り当てに存在します。 サーバーがクライアントに割り当てたアドレスとポートを指定します。 XOR-MAPPED-ADDRESS属性[RFC8489]と同じ方法でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "18.6. REQUESTED-ADDRESS-FAMILY",
      "section_title": true,
      "ja": "18.6. 要求された住所の家族"
    },
    {
      "indent": 3,
      "text": "This attribute is used in Allocate and Refresh requests to specify the address type requested by the client. The value of this attribute is 4 bytes with the following format:",
      "ja": "この属性は、クライアントによって要求されたアドレスタイプを指定するために、割り当ておよび更新要求で使用されます。 この属性の値は、次の形式の4バイトです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Family    |            Reserved                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 7",
      "ja": "図7"
    },
    {
      "indent": 3,
      "text": "Family: There are two values defined for this field and specified in Section 14.1 of [RFC8489]: 0x01 for IPv4 addresses and 0x02 for IPv6 addresses.",
      "ja": "ファミリ：このフィールドに対して定義され、[RFC8489]のセクション14.1で指定されている2つの値があります。IPv4アドレスの場合は0x01、IPv6アドレスの場合は0x02です。"
    },
    {
      "indent": 3,
      "text": "Reserved: At this point, the 24 bits in the Reserved field MUST be set to zero by the client and MUST be ignored by the server.",
      "ja": "予約済み：この時点で、予約済みフィールドの24ビットは、クライアントによってゼロに設定されなければならず、サーバーによって無視されなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.7. EVEN-PORT",
      "section_title": true,
      "ja": "18.7. イーブンポート"
    },
    {
      "indent": 3,
      "text": "This attribute allows the client to request that the port in the relayed transport address be even and (optionally) that the server reserve the next-higher port number. The value portion of this attribute is 1 byte long. Its format is:",
      "ja": "この属性により、クライアントは、中継されたトランスポートアドレスのポートが偶数であること、および（オプションで）サーバーが次に高いポート番号を予約することを要求できます。 この属性の値部分は1バイト長です。 その形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0\n 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|R|    RFFU     |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 8",
      "ja": "図8"
    },
    {
      "indent": 3,
      "text": "The value contains a single 1-bit flag:",
      "ja": "値には、単一の1ビットフラグが含まれます。"
    },
    {
      "indent": 3,
      "text": "R: If 1, the server is requested to reserve the next-higher port number (on the same IP address) for a subsequent allocation. If 0, no such reservation is requested.",
      "ja": "R：1の場合、サーバーは、後続の割り当てのために（同じIPアドレスで）次に高いポート番号を予約するように要求されます。 0の場合、そのような予約は要求されません。"
    },
    {
      "indent": 3,
      "text": "RFFU: Reserved For Future Use.",
      "ja": "RFFU：将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The RFFU field must be set to zero on transmission and ignored on reception.",
      "ja": "RFFUフィールドは、送信時にゼロに設定し、受信時に無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the length of this attribute is not a multiple of 4, padding must immediately follow this attribute.",
      "ja": "この属性の長さは4の倍数ではないため、この属性の直後にパディングが必要です。"
    },
    {
      "indent": 0,
      "text": "18.8. REQUESTED-TRANSPORT",
      "section_title": true,
      "ja": "18.8. 要求された輸送"
    },
    {
      "indent": 3,
      "text": "This attribute is used by the client to request a specific transport protocol for the allocated transport address. The value of this attribute is 4 bytes with the following format:",
      "ja": "クライアントは、この属性を使用して、割り当てられたトランスポートアドレスの特定のトランスポートプロトコルを要求します。 この属性の値は、次の形式の4バイトです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Protocol   |                    RFFU                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Figure 9",
      "ja": "図9"
    },
    {
      "indent": 3,
      "text": "The Protocol field specifies the desired protocol. The code points used in this field are taken from those allowed in the Protocol field in the IPv4 header and the NextHeader field in the IPv6 header [PROTOCOL-NUMBERS]. This specification only allows the use of code point 17 (User Datagram Protocol).",
      "ja": "Protocolフィールドは、目的のプロトコルを指定します。 このフィールドで使用されるコードポイントは、IPv4ヘッダーのプロトコルフィールドおよびIPv6ヘッダーの[PROTOCOL-NUMBERS]のNextHeaderフィールドで許可されているコードポイントから取得されます。 この仕様では、コードポイント17（ユーザーデータグラムプロトコル）のみを使用できます。"
    },
    {
      "indent": 3,
      "text": "The RFFU field MUST be set to zero on transmission and MUST be ignored on reception. It is reserved for future uses.",
      "ja": "RFFUフィールドは送信時にゼロに設定する必要があり、受信時には無視する必要があります。 将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "18.9. DONT-FRAGMENT",
      "section_title": true,
      "ja": "18.9. DONT-FRAGMENT"
    },
    {
      "indent": 3,
      "text": "This attribute is used by the client to request that the server set the DF (Don't Fragment) bit in the IP header when relaying the application data onward to the peer and for determining the server capability in Allocate requests. This attribute has no value part, and thus, the attribute length field is 0.",
      "ja": "クライアントは、この属性を使用して、アプリケーションデータをピアにリレーするときにサーバーがIPヘッダーにDF（Do n't Fragment）ビットを設定することを要求し、要求の割り当てのサーバー機能を決定します。 この属性には値の部分がないため、属性の長さフィールドは0です。"
    },
    {
      "indent": 0,
      "text": "18.10. RESERVATION-TOKEN",
      "section_title": true,
      "ja": "18.10. 予約トークン"
    },
    {
      "indent": 3,
      "text": "The RESERVATION-TOKEN attribute contains a token that uniquely identifies a relayed transport address being held in reserve by the server. The server includes this attribute in a success response to tell the client about the token, and the client includes this attribute in a subsequent Allocate request to request the server use that relayed transport address for the allocation.",
      "ja": "RESERVATION-TOKEN属性には、サーバーによって予約されている中継トランスポートアドレスを一意に識別するトークンが含まれています。 サーバーは、成功応答にこの属性を含めてトークンについてクライアントに伝え、クライアントはこの属性を後続のAllocate要求に含めて、サーバーが割り当てに中継されたトランスポートアドレスを使用することを要求します。"
    },
    {
      "indent": 3,
      "text": "The attribute value is 8 bytes and contains the token value.",
      "ja": "属性値は8バイトで、トークン値が含まれています。"
    },
    {
      "indent": 0,
      "text": "18.11. ADDITIONAL-ADDRESS-FAMILY",
      "section_title": true,
      "ja": "18.11. 追加住所家族"
    },
    {
      "indent": 3,
      "text": "This attribute is used by clients to request the allocation of an IPv4 and IPv6 address type from a server. It is encoded in the same way as the REQUESTED-ADDRESS-FAMILY attribute; see Section 18.6. The ADDITIONAL-ADDRESS-FAMILY attribute MAY be present in the Allocate request. The attribute value of 0x02 (IPv6 address) is the only valid value in Allocate request.",
      "ja": "この属性は、クライアントがサーバーにIPv4およびIPv6アドレスタイプの割り当てを要求するために使用されます。 REQUESTED-ADDRESS-FAMILY属性と同じ方法でエンコードされます。 セクション18.6を参照してください。 ADDITIONAL-ADDRESS-FAMILY属性は、割り当て要求に含まれている場合があります。 属性値0x02（IPv6アドレス）は、割り当て要求で唯一の有効な値です。"
    },
    {
      "indent": 0,
      "text": "18.12. ADDRESS-ERROR-CODE",
      "section_title": true,
      "ja": "18.12. ADDRESS-ERROR-CODE"
    },
    {
      "indent": 3,
      "text": "This attribute is used by servers to signal the reason for not allocating the requested address family. The value portion of this attribute is variable length with the following format:",
      "ja": "この属性は、要求されたアドレスファミリを割り当てない理由を示すためにサーバーによって使用されます。 この属性の値部分は、次の形式の可変長です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Family       |    Reserved             |Class|     Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Reason Phrase (variable)                                ..\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 10",
      "ja": "図10"
    },
    {
      "indent": 3,
      "text": "Family: There are two values defined for this field and specified in Section 14.1 of [RFC8489]: 0x01 for IPv4 addresses and 0x02 for IPv6 addresses.",
      "ja": "ファミリ：このフィールドに対して定義され、[RFC8489]のセクション14.1で指定されている2つの値があります。IPv4アドレスの場合は0x01、IPv6アドレスの場合は0x02です。"
    },
    {
      "indent": 3,
      "text": "Reserved: At this point, the 13 bits in the Reserved field MUST be set to zero by the server and MUST be ignored by the client.",
      "ja": "予約済み：この時点で、予約済みフィールドの13ビットは、サーバーによってゼロに設定されなければならず、クライアントによって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Class: The Class represents the hundreds digit of the error code and is defined in Section 14.8 of [RFC8489].",
      "ja": "クラス：クラスはエラーコードの数百桁を表し、[RFC8489]のセクション14.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "Number: This 8-bit field contains the reason the server cannot allocate one of the requested address types. The error code values could be either 440 (Address Family not Supported) or 508 (Insufficient Capacity). The number representation is defined in Section 14.8 of [RFC8489].",
      "ja": "番号：この8ビットフィールドには、サーバーが要求されたアドレスタイプの1つを割り当てることができない理由が含まれています。 エラーコードの値は、440（サポートされていないアドレスファミリ）または508（容量不足）のいずれかです。 番号表現は[RFC8489]のセクション14.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "Reason Phrase: The recommended reason phrases for error codes 440 and 508 are explained in Section 19. The reason phrase MUST be a UTF-8 [RFC3629] encoded sequence of less than 128 characters (which can be as long as 509 bytes when encoding them or 763 bytes when decoding them).",
      "ja": "理由フレーズ：エラーコード440および508の推奨理由フレーズはセクション19で説明されています。理由フレーズは、UTF-8 [RFC3629]でエンコードされた128文字未満のシーケンスである必要があります。 またはデコードする場合は763バイト）。"
    },
    {
      "indent": 0,
      "text": "18.13. ICMP",
      "section_title": true,
      "ja": "18.13. ICMP"
    },
    {
      "indent": 3,
      "text": "This attribute is used by servers to signal the reason a UDP packet was dropped. The following is the format of the ICMP attribute.",
      "ja": "この属性は、UDPパケットがドロップされた理由を示すためにサーバーによって使用されます。 ICMP属性の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Reserved                     |  ICMP Type  |  ICMP Code      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Error Data                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 11",
      "ja": "図11"
    },
    {
      "indent": 3,
      "text": "Reserved: This field MUST be set to 0 when sent and MUST be ignored when received.",
      "ja": "予約済み：このフィールドは送信時に0に設定しなければならず、受信時には無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ICMP Type: The field contains the value of the ICMP type. Its interpretation depends on whether the ICMP was received over IPv4 or IPv6.",
      "ja": "ICMPタイプ：フィールドにはICMPタイプの値が含まれます。 その解釈は、ICMPがIPv4またはIPv6のどちらで受信されたかによって異なります。"
    },
    {
      "indent": 3,
      "text": "ICMP Code: The field contains the value of the ICMP code. Its interpretation depends on whether the ICMP was received over IPv4 or IPv6.",
      "ja": "ICMPコード：フィールドにはICMPコードの値が含まれます。 その解釈は、ICMPがIPv4またはIPv6のどちらで受信されたかによって異なります。"
    },
    {
      "indent": 3,
      "text": "Error Data: This field size is 4 bytes long. If the ICMPv6 type is 2 (\"Packet too big\" message) or ICMPv4 type is 3 (Destination Unreachable) and Code is 4 (fragmentation needed and DF set), the Error Data field will be set to the Maximum Transmission Unit of the next-hop link (Section 3.2 of [RFC4443] and Section 4 of [RFC1191]). For other ICMPv6 types and ICMPv4 types and codes, the Error Data field MUST be set to zero.",
      "ja": "エラーデータ：このフィールドサイズは4バイト長です。 ICMPv6タイプが2（「パケットが大きすぎる」メッセージ）またはICMPv4タイプが3（宛先未到達）でコードが4（断片化が必要でDFが設定されている）の場合、エラーデータフィールドは次の最大伝送単位に設定されます。 -hopリンク（[RFC4443]のセクション3.2および[RFC1191]のセクション4）。 他のICMPv6タイプとICMPv4タイプとコードの場合、エラーデータフィールドをゼロに設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "19. STUN Error Response Codes",
      "section_title": true,
      "ja": "19. STUNエラー応答コード"
    },
    {
      "indent": 3,
      "text": "This document defines the following error response codes:",
      "ja": "このドキュメントでは、次のエラー応答コードを定義しています。"
    },
    {
      "indent": 3,
      "text": "403 (Forbidden): The request was valid but cannot be performed due to administrative or similar restrictions.",
      "ja": "403（禁止）：要求は有効でしたが、管理上の制限または同様の制限により実行できません。"
    },
    {
      "indent": 3,
      "text": "437 (Allocation Mismatch): A request was received by the server that requires an allocation to be in place, but no allocation exists, or a request was received that requires no allocation, but an allocation exists.",
      "ja": "437（割り当ての不一致）：割り当てを行う必要があるサーバーが要求を受け取りましたが、割り当てが存在しないか、割り当てを必要としないが割り当てが存在する要求を受け取りました。"
    },
    {
      "indent": 3,
      "text": "440 (Address Family not Supported): The server does not support the address family requested by the client.",
      "ja": "440（アドレスファミリはサポートされていません）：サーバーは、クライアントが要求したアドレスファミリをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "441 (Wrong Credentials): (Wrong Credentials): The credentials in the (non-Allocate) request do not match those used to create the allocation.",
      "ja": "441（間違った資格情報）：（間違った資格情報）：（非割り当て）要求の資格情報は、割り当ての作成に使用された資格情報と一致しません。"
    },
    {
      "indent": 3,
      "text": "442 (Unsupported Transport Protocol): The Allocate request asked the server to use a transport protocol between the server and the peer that the server does not support. NOTE: This does NOT refer to the transport protocol used in the 5-tuple.",
      "ja": "442（サポートされていないトランスポートプロトコル）：割り当て要求は、サーバーと、サーバーがサポートしていないピアとの間のトランスポートプロトコルを使用するようサーバーに要求しました。 注：これは、5タプルで使用されるトランスポートプロトコルを指すものではありません。"
    },
    {
      "indent": 3,
      "text": "443 (Peer Address Family Mismatch): A peer address is part of a different address family than that of the relayed transport address of the allocation.",
      "ja": "443（ピアアドレスファミリの不一致）：ピアアドレスは、割り当ての中継されたトランスポートアドレスとは異なるアドレスファミリの一部です。"
    },
    {
      "indent": 3,
      "text": "486 (Allocation Quota Reached): No more allocations using this username can be created at the present time.",
      "ja": "486（割り当てクォータに達しました）：現在、このユーザー名を使用した割り当てはこれ以上作成できません。"
    },
    {
      "indent": 3,
      "text": "508 (Insufficient Capacity): The server is unable to carry out the request due to some capacity limit being reached. In an Allocate response, this could be due to the server having no more relayed transport addresses available at that time, having none with the requested properties, or the one that corresponds to the specified reservation token is not available.",
      "ja": "508（容量不足）：容量制限に達しているため、サーバーは要求を実行できません。 Allocate応答では、サーバーがその時点で利用可能な中継トランスポートアドレスを持たないか、要求されたプロパティを持たないか、指定された予約トークンに対応するものが利用できないことが原因である可能性があります。"
    },
    {
      "indent": 0,
      "text": "20. Detailed Example",
      "section_title": true,
      "ja": "20. 詳細な例"
    },
    {
      "indent": 3,
      "text": "This section gives an example of the use of TURN, showing in detail the contents of the messages exchanged. The example uses the network diagram shown in the Overview (Figure 1).",
      "ja": "このセクションでは、TURNの使用例を示し、交換されるメッセージの内容を詳細に示します。 この例では、概要に示されているネットワーク図を使用しています（図1）。"
    },
    {
      "indent": 3,
      "text": "For each message, the attributes included in the message and their values are shown. For convenience, values are shown in a human-readable format rather than showing the actual octets; for example, \"XOR-RELAYED-ADDRESS=192.0.2.15:9000\" shows that the XOR-RELAYED-ADDRESS attribute is included with an address of 192.0.2.15 and a port of 9000; here, the address and port are shown before the xor-ing is done. For attributes with string-like values (e.g., SOFTWARE=\"Example client, version 1.03\" and NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"), the value of the attribute is shown in quotes for readability, but these quotes do not appear in the actual value.",
      "ja": "各メッセージについて、メッセージに含まれる属性とその値が表示されます。 便宜上、値は実際のオクテットではなく、人間が読める形式で表示されます。 たとえば、「XOR-RELAYED-ADDRESS = 192.0.2.15：9000」は、XOR-RELAYED-ADDRESS属性がアドレス192.0.2.15とポート9000に含まれていることを示しています。 ここでは、xor-ingが実行される前にアドレスとポートが表示されます。 文字列のような値を持つ属性（例：SOFTWARE = \"Example client、version 1.03\"およびNONCE = \"obMatJos2gAAAadl7W7PeDU4hKE72jda\"）の場合、属性の値は読みやすいように引用符で表示されますが、実際の値には表示されません。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |                                    |            |            |\n  |--- Allocate request -------------->|            |            |\n  |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |\n  |    SOFTWARE=\"Example client, version 1.03\"      |            |\n  |    LIFETIME=3600 (1 hour)          |            |            |\n  |    REQUESTED-TRANSPORT=17 (UDP)    |            |            |\n  |    DONT-FRAGMENT                   |            |            |\n  |                                    |            |            |\n  |<-- Allocate error response --------|            |            |\n  |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |\n  |    SOFTWARE=\"Example server, version 1.17\"      |            |\n  |    ERROR-CODE=401 (Unauthorized)   |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |                                    |            |            |\n  |--- Allocate request -------------->|            |            |\n  |    Transaction-Id=0xC271E932AD7446A32C234492    |            |\n  |    SOFTWARE=\"Example client 1.03\"  |            |            |\n  |    LIFETIME=3600 (1 hour)          |            |            |\n  |    REQUESTED-TRANSPORT=17 (UDP)    |            |            |\n  |    DONT-FRAGMENT                   |            |            |\n  |    USERNAME=\"George\"               |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |    PASSWORD-ALGORITHM=SHA256       |            |            |\n  |    MESSAGE-INTEGRITY=...           |            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n  |                                    |            |            |\n  |<-- Allocate success response ------|            |            |\n  |    Transaction-Id=0xC271E932AD7446A32C234492    |            |\n  |    SOFTWARE=\"Example server, version 1.17\"      |            |\n  |    LIFETIME=1200 (20 minutes)      |            |            |\n  |    XOR-RELAYED-ADDRESS=192.0.2.15:50000         |            |\n  |    XOR-MAPPED-ADDRESS=192.0.2.1:7000            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 12",
      "ja": "図12"
    },
    {
      "indent": 3,
      "text": "The client begins by selecting a host transport address to use for the TURN session; in this example, the client has selected 198.51.100.2:49721 as shown in Figure 1. The client then sends an Allocate request to the server at the server transport address. The client randomly selects a 96-bit transaction id of 0xA56250D3F17ABE679422DE85 for this transaction; this is encoded in the transaction id field in the fixed header. The client includes a SOFTWARE attribute that gives information about the client's software; here, the value is \"Example client, version 1.03\" to indicate that this is version 1.03 of something called the \"Example client\". The client includes the LIFETIME attribute because it wishes the allocation to have a longer lifetime than the default of 10 minutes; the value of this attribute is 3600 seconds, which corresponds to 1 hour. The client must always include a REQUESTED-TRANSPORT attribute in an Allocate request, and the only value allowed by this specification is 17, which indicates UDP transport between the server and the peers. The client also includes the DONT-FRAGMENT attribute because it wishes to use the DONT-FRAGMENT attribute later in Send indications; this attribute consists of only an attribute header; there is no value part. We assume the client has not recently interacted with the server; thus, the client does not include the USERNAME, USERHASH, REALM, NONCE, PASSWORD-ALGORITHMS, PASSWORD-ALGORITHM, MESSAGE-INTEGRITY, or MESSAGE-INTEGRITY-SHA256 attribute. Finally, note that the order of attributes in a message is arbitrary (except for the MESSAGE-INTEGRITY, MESSAGE-INTEGRITY-SHA256 and FINGERPRINT attributes), and the client could have used a different order.",
      "ja": "クライアントは、TURNセッションに使用するホストトランスポートアドレスを選択することから始めます。この例では、図1に示すように、クライアントは198.51.100.2:49721を選択しています。クライアントは、サーバートランスポートアドレスのサーバーにAllocate要求を送信します。クライアントは、このトランザクションに対して0xA56250D3F17ABE679422DE85の96ビットトランザクションIDをランダムに選択します。これは、固定ヘッダーのトランザクションIDフィールドにエンコードされます。クライアントには、クライアントのソフトウェアに関する情報を提供するSOFTWARE属性が含まれています。ここでは、値は「Example client、version 1.03」であり、これが「Example client」と呼ばれるもののバージョン1.03であることを示しています。クライアントは、割り当てにデフォルトの10分よりも長い有効期間を持たせたいので、LIFETIME属性を含めます。この属性の値は3600秒で、1時間に相当します。クライアントは常にREQUESTED-TRANSPORT属性をAllocate要求に含める必要があり、この仕様で許可される唯一の値は17です。これはサーバーとピア間のUDPトランスポートを示します。クライアントは、指示の送信でDONT-FRAGMENT属性を使用することを希望するため、DONT-FRAGMENT属性も含めます。この属性は、属性ヘッダーのみで構成されています。価値のある部分はありません。クライアントが最近サーバーと対話していないと仮定します。したがって、クライアントには、USERNAME、USERHASH、REALM、NONCE、PASSWORD-ALGORITHMS、PASSWORD-ALGORITHM、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性は含まれません。最後に、メッセージ内の属性の順序は任意であり（MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256、およびFINGERPRINT属性を除く）、クライアントは別の順序を使用できます。"
    },
    {
      "indent": 3,
      "text": "Servers require any request to be authenticated. Thus, when the server receives the initial Allocate request, it rejects the request because the request does not contain the authentication attributes. Following the procedures of the long-term credential mechanism of STUN [RFC8489], the server includes an ERROR-CODE attribute with a value of 401 (Unauthorized), a REALM attribute that specifies the authentication realm used by the server (in this case, the server's domain \"example.com\"), and a nonce value in a NONCE attribute. The NONCE attribute starts with the \"nonce cookie\" with the STUN Security Feature \"Password algorithm\" bit set to 1. The server includes a PASSWORD-ALGORITHMS attribute that specifies the list of algorithms that the server can use to derive the long-term password. If the server sets the STUN Security Feature \"Username anonymity\" bit to 1, then the client uses the USERHASH attribute instead of the USERNAME attribute in the Allocate request to anonymize the username. The server also includes a SOFTWARE attribute that gives information about the server's software.",
      "ja": "サーバーでは、要求を認証する必要があります。したがって、サーバーは最初のAllocate要求を受信すると、要求に認証属性が含まれていないため、要求を拒否します。 STUN [RFC8489]の長期資格情報メカニズムの手順に従って、サーバーには、401（Unauthorized）の値を持つERROR-CODE属性、サーバーが使用する認証領域を指定するREALM属性（この場合、サーバーのドメイン「example.com」）、およびNONCE属性のナンス値。 NONCE属性は、STUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「nonce cookie」で始まります。サーバーには、サーバーが長期パスワードの導出に使用できるアルゴリズムのリストを指定するPASSWORD-ALGORITHMS属性が含まれます。 。サーバーがSTUNセキュリティ機能の「ユーザー名匿名性」ビットを1に設定すると、クライアントはユーザー名を匿名化するために、割り当て要求でUSERNAME属性の代わりにUSERHASH属性を使用します。サーバーには、サーバーのソフトウェアに関する情報を提供するSOFTWARE属性も含まれています。"
    },
    {
      "indent": 3,
      "text": "The client, upon receipt of the 401 error, reattempts the Allocate request, this time including the authentication attributes. The client selects a new transaction id and then populates the new Allocate request with the same attributes as before. The client includes a USERNAME attribute and uses the realm value received from the server to help it determine which value to use; here, the client is configured to use the username \"George\" for the realm \"example.com\". The client includes the PASSWORD-ALGORITHM attribute indicating the algorithm that the server must use to derive the long-term password. The client also includes the REALM, PASSWORD-ALGORITHMS, and NONCE attributes, which are just copied from the 401 error response. Finally, the client includes MESSAGE-INTEGRITY-SHA256 attribute as the last attributes in the message whose value is Hashed Message Authentication Code - Secure Hash Algorithm 2 (HMAC-SHA2) hash over the contents of the message (shown as just \"...\" above); this HMAC-SHA2 computation includes a password value. Thus, an attacker cannot compute the message integrity value without somehow knowing the secret password.",
      "ja": "クライアントは、401エラーを受信すると、今度は認証属性を含むAllocate要求を再試行します。クライアントは新しいトランザクションIDを選択してから、新しいAllocateリクエストに以前と同じ属性を設定します。クライアントにはUSERNAME属性が含まれており、サーバーから受信したレルム値を使用して、使用する値の決定に役立ちます。ここでは、クライアントはレルム「example.com」にユーザー名「George」を使用するように構成されています。クライアントには、サーバーが長期パスワードの導出に使用する必要があるアルゴリズムを示すPASSWORD-ALGORITHM属性が含まれています。クライアントには、401エラー応答からコピーされたばかりのREALM、PASSWORD-ALGORITHMS、およびNONCE属性も含まれます。最後に、クライアントはメッセージの最後の属性としてMESSAGE-INTEGRITY-SHA256属性を含みます。値はハッシュメッセージ認証コード-メッセージのコンテンツに対するハッシュ（Secure Hash Algorithm 2（HMAC-SHA2））です（「... 「上記）;このHMAC-SHA2計算にはパスワード値が含まれます。したがって、攻撃者は何らかの方法で秘密のパスワードを知らない限り、メッセージの整合性の値を計算できません。"
    },
    {
      "indent": 3,
      "text": "The server, upon receipt of the authenticated Allocate request, checks that everything is OK, then creates an allocation. The server replies with an Allocate success response. The server includes a LIFETIME attribute giving the lifetime of the allocation; here, the server has reduced the client's requested 1-hour lifetime to just 20 minutes because this particular server doesn't allow lifetimes longer than 20 minutes. The server includes an XOR-RELAYED-ADDRESS attribute whose value is the relayed transport address of the allocation. The server includes an XOR-MAPPED-ADDRESS attribute whose value is the server-reflexive address of the client; this value is not used otherwise in TURN but is returned as a convenience to the client. The server includes a MESSAGE-INTEGRITY-SHA256 attribute to authenticate the response and to ensure its integrity; note that the response does not contain the USERNAME, REALM, and NONCE attributes. The server also includes a SOFTWARE attribute.",
      "ja": "サーバーは、認証されたAllocate要求を受信すると、すべてが正常であることを確認してから、割り当てを作成します。 サーバーは、Allocate成功応答で応答します。 サーバーには、割り当ての有効期間を示すLIFETIME属性が含まれています。 ここでは、この特定のサーバーは20分より長いライフタイムを許可しないため、サーバーはクライアントの要求した1時間のライフタイムをわずか20分に短縮しました。 サーバーにはXOR-RELAYED-ADDRESS属性が含まれ、その属性の値は割り当ての中継されたトランスポートアドレスです。 サーバーには、値がクライアントのサーバー再帰アドレスであるXOR-MAPPED-ADDRESS属性が含まれています。 この値は、TURNで使用されませんが、クライアントの利便性のために返されます。 サーバーには、応答を認証し、その整合性を確保するために、MESSAGE-INTEGRITY-SHA256属性が含まれています。 応答には、USERNAME、REALM、およびNONCE属性が含まれていないことに注意してください。 サーバーには、SOFTWARE属性も含まれています。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |--- CreatePermission request ------>|            |            |\n  |    Transaction-Id=0xE5913A8F460956CA277D3319    |            |\n  |    XOR-PEER-ADDRESS=192.0.2.150:0  |            |            |\n  |    USERNAME=\"George\"               |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |    PASSWORD-ALGORITHM=SHA256       |            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n  |                                    |            |            |\n  |<-- CreatePermission success resp.--|            |            |\n  |    Transaction-Id=0xE5913A8F460956CA277D3319    |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 13",
      "ja": "図13"
    },
    {
      "indent": 3,
      "text": "The client then creates a permission towards Peer A in preparation for sending it some application data. This is done through a CreatePermission request. The XOR-PEER-ADDRESS attribute contains the IP address for which a permission is established (the IP address of peer A); note that the port number in the attribute is ignored when used in a CreatePermission request, and here it has been set to 0; also, note how the client uses Peer A's server-reflexive IP address and not its (private) host address. The client uses the same username, realm, and nonce values as in the previous request on the allocation. Though it is allowed to do so, the client has chosen not to include a SOFTWARE attribute in this request.",
      "ja": "クライアントは、アプリケーションデータを送信する準備として、ピアAに対する許可を作成します。 これは、CreatePermission要求を介して行われます。 XOR-PEER-ADDRESS属性には、許可が確立されたIPアドレス（ピアAのIPアドレス）が含まれます。 CreatePermissionリクエストで使用される場合、属性のポート番号は無視され、ここでは0に設定されていることに注意してください。 また、クライアントが（プライベート）ホストアドレスではなく、ピアAのサーバー反射IPアドレスを使用する方法にも注意してください。 クライアントは、以前の割り当て要求と同じユーザー名、レルム、ナンス値を使用します。 そうすることは許可されていますが、クライアントはこの要求にSOFTWARE属性を含めないことを選択しました。"
    },
    {
      "indent": 3,
      "text": "The server receives the CreatePermission request, creates the corresponding permission, and then replies with a CreatePermission success response. Like the client, the server chooses not to include the SOFTWARE attribute in its reply. Again, note how success responses contain a MESSAGE-INTEGRITY-SHA256 attribute (assuming the server uses the long-term credential mechanism) but no USERNAME, REALM, and NONCE attributes.",
      "ja": "サーバーはCreatePermission要求を受信し、対応する許可を作成してから、CreatePermission成功応答で応答します。 クライアントと同様に、サーバーは応答にSOFTWARE属性を含めないことを選択します。 繰り返しますが、成功応答にはMESSAGE-INTEGRITY-SHA256属性が含まれていることに注意してください（サーバーが長期資格情報メカニズムを使用している場合）、USERNAME、REALM、およびNONCE属性は含まれません。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |--- Send indication --------------->|            |            |\n  |    Transaction-Id=0x1278E9ACA2711637EF7D3328    |            |\n  |    XOR-PEER-ADDRESS=192.0.2.150:32102           |            |\n  |    DONT-FRAGMENT                   |            |            |\n  |    DATA=...                        |            |            |\n  |                                    |- UDP dgm ->|            |\n  |                                    | data=...   |            |\n  |                                    |            |            |\n  |                                    |<- UDP dgm -|            |\n  |                                    |  data=...  |            |\n  |<-- Data indication ----------------|            |            |\n  |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF    |            |\n  |    XOR-PEER-ADDRESS=192.0.2.150:32102           |            |\n  |    DATA=...                        |            |            |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 14",
      "ja": "図14"
    },
    {
      "indent": 3,
      "text": "The client now sends application data to Peer A using a Send indication. Peer A's server-reflexive transport address is specified in the XOR-PEER-ADDRESS attribute, and the application data (shown here as just \"...\") is specified in the DATA attribute. The client is doing a form of path MTU discovery at the application layer and, thus, specifies (by including the DONT-FRAGMENT attribute) that the server should set the DF bit in the UDP datagram to send to the peer. Indications cannot be authenticated using the long-term credential mechanism of STUN, so no MESSAGE-INTEGRITY or MESSAGE-INTEGRITY-SHA256 attribute is included in the message. An application wishing to ensure that its data is not altered or forged must integrity-protect its data at the application level.",
      "ja": "クライアントは、送信指示を使用してアプリケーションデータをピアAに送信するようになりました。 ピアAのサーバー再帰トランスポートアドレスはXOR-PEER-ADDRESS属性で指定され、アプリケーションデータ（ここでは「...」と表示）はDATA属性で指定されます。 クライアントは、アプリケーションレイヤーでパスMTUディスカバリの形式を実行しているため、（DONT-FRAGMENT属性を含めることにより）サーバーがピアに送信するUDPデータグラムのDFビットを設定することを指定します。 STUNの長期資格情報メカニズムを使用して指示を認証することはできないため、MESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性はメッセージに含まれません。 データが変更または偽造されないことを保証したいアプリケーションは、アプリケーションレベルでデータを完全に保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the Send indication, the server extracts the application data and sends it in a UDP datagram to Peer A, with the relayed transport address as the source transport address of the datagram and with the DF bit set as requested. Note that had the client not previously established a permission for Peer A's server-reflexive IP address, the server would have silently discarded the Send indication instead.",
      "ja": "送信指示を受信すると、サーバーはアプリケーションデータを抽出し、UDPデータグラムでピアAに送信します。中継されたトランスポートアドレスをデータグラムのソーストランスポートアドレスとして、DFビットを要求どおりに設定します。 クライアントが以前にピアAのサーバー再帰IPアドレスの許可を確立していなかった場合、サーバーは代わりに送信指示をサイレントに破棄することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Peer A then replies with its own UDP datagram containing application data. The datagram is sent to the relayed transport address on the server. When this arrives, the server creates a Data indication containing the source of the UDP datagram in the XOR-PEER-ADDRESS attribute, and the data from the UDP datagram in the DATA attribute. The resulting Data indication is then sent to the client.",
      "ja": "ピアAは、アプリケーションデータを含む独自のUDPデータグラムで応答します。 データグラムは、サーバー上の中継されたトランスポートアドレスに送信されます。 これが到着すると、サーバーは、XOR-PEER-ADDRESS属性のUDPデータグラムのソースと、DATA属性のUDPデータグラムのデータを含むデータ表示を作成します。 次に、結果のデータ表示がクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer          Peer\nclient                               server         A             B\n  |--- ChannelBind request ----------->|            |             |\n  |    Transaction-Id=0x6490D3BC175AFF3D84513212    |             |\n  |    CHANNEL-NUMBER=0x4000           |            |             |\n  |    XOR-PEER-ADDRESS=192.0.2.210:49191           |             |\n  |    USERNAME=\"George\"               |            |             |\n  |    REALM=\"example.com\"             |            |             |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |             |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |             |\n  |    PASSWORD-ALGORITHM=SHA256       |            |             |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |             |\n  |                                    |            |             |\n  |<-- ChannelBind success response ---|            |             |\n  |    Transaction-Id=0x6490D3BC175AFF3D84513212    |             |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |             |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 15",
      "ja": "図15"
    },
    {
      "indent": 3,
      "text": "The client now binds a channel to Peer B, specifying a free channel number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's transport address in the XOR-PEER-ADDRESS attribute. As before, the client reuses the username, realm, and nonce from its last request in the message.",
      "ja": "クライアントは、チャネルをピアBにバインドし、CHANNEL-NUMBER属性に空きチャネル番号（0x4000）を指定し、XOR-PEER-ADDRESS属性にピアBのトランスポートアドレスを指定します。 前と同様に、クライアントはメッセージ内の最後のリクエストからユーザー名、レルム、ノンスを再利用します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the request, the server binds the channel number to the peer, installs a permission for Peer B's IP address, and then replies with a ChannelBind success response.",
      "ja": "要求を受信すると、サーバーはチャネル番号をピアにバインドし、ピアBのIPアドレスのアクセス許可をインストールしてから、ChannelBind成功応答で応答します。"
    },
    {
      "indent": 3,
      "text": "TURN                                TURN           Peer          Peer\nclient                              server          A             B\n  |--- ChannelData ------------------>|             |             |\n  |    Channel-number=0x4000          |--- UDP datagram --------->|\n  |    Data=...                       |    Data=...               |\n  |                                   |             |             |\n  |                                   |<-- UDP datagram ----------|\n  |                                   |    Data=... |             |\n  |<-- ChannelData -------------------|             |             |\n  |    Channel-number=0x4000          |             |             |\n  |    Data=...                       |             |             |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 16",
      "ja": "図16"
    },
    {
      "indent": 3,
      "text": "The client now sends a ChannelData message to the server with data destined for Peer B. The ChannelData message is not a STUN message; thus, it has no transaction id. Instead, it has only three fields: a channel number, data, and data length; here, the channel number field is 0x4000 (the channel the client just bound to Peer B). When the server receives the ChannelData message, it checks that the channel is currently bound (which it is) and then sends the data onward to Peer B in a UDP datagram, using the relayed transport address as the source transport address, and 192.0.2.210:49191 (the value of the XOR-PEER-ADDRESS attribute in the ChannelBind request) as the destination transport address.",
      "ja": "クライアントは、ピアB宛てのデータとともにChannelDataメッセージをサーバーに送信します。ChannelDataメッセージはSTUNメッセージではありません。 したがって、トランザクションIDはありません。 代わりに、チャネル番号、データ、データ長の3つのフィールドのみがあります。 ここでは、チャネル番号フィールドは0x4000（クライアントがピアBにバインドしたばかりのチャネル）です。 サーバーは、ChannelDataメッセージを受信すると、チャネルが現在バインドされていること（これがバインドされていること）を確認し、リレーされたトランスポートアドレスをソーストランスポートアドレスとして使用して、データをUDPデータグラムでピアBに送信し、192.0.2.210 ：49191（ChannelBind要求のXOR-PEER-ADDRESS属性の値）を宛先転送アドレスとして。"
    },
    {
      "indent": 3,
      "text": "Later, Peer B sends a UDP datagram back to the relayed transport address. This causes the server to send a ChannelData message to the client containing the data from the UDP datagram. The server knows to which client to send the ChannelData message because of the relayed transport address at which the UDP datagram arrived, and it knows to use channel 0x4000 because this is the channel bound to 192.0.2.210:49191. Note that if there had not been any channel number bound to that address, the server would have used a Data indication instead.",
      "ja": "後で、ピアBはUDPデータグラムを中継されたトランスポートアドレスに送り返します。 これにより、サーバーはUDPデータグラムからのデータを含むChannelDataメッセージをクライアントに送信します。 サーバーは、UDPデータグラムが到着した中継トランスポートアドレスのためにどのクライアントにChannelDataメッセージを送信するかを認識し、これが192.0.2.210:49191にバインドされたチャネルであるため、チャネル0x4000を使用することを認識します。 そのアドレスにバインドされたチャネル番号がなかった場合、サーバーは代わりにデータ表示を使用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |--- ChannelBind request ----------->|            |            |\n  |    Transaction-Id=0xE5913A8F46091637EF7D3328    |            |\n  |    CHANNEL-NUMBER=0x4000           |            |            |\n  |    XOR-PEER-ADDRESS=192.0.2.210:49191           |            |\n  |    USERNAME=\"George\"               |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |    PASSWORD-ALGORITHM=SHA256       |            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n  |                                    |            |            |\n  |<-- ChannelBind success response ---|            |            |\n  |    Transaction-Id=0xE5913A8F46091637EF7D3328    |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 17",
      "ja": "図17"
    },
    {
      "indent": 3,
      "text": "The channel binding lasts for 10 minutes unless refreshed. The TURN client refreshes the binding by sending a ChannelBind request rebinding the channel to the same peer (Peer B's IP address). The server processes the ChannelBind request, rebinds the channel to the same peer, and resets the time-to-expiry timer back to 10 minutes.",
      "ja": "更新されない限り、チャネルバインディングは10分間続きます。 TURNクライアントは、チャネルを同じピア（ピアBのIPアドレス）に再バインドするChannelBind要求を送信することにより、バインドを更新します。 サーバーはChannelBind要求を処理し、チャネルを同じピアに再バインドし、有効期限までのタイマーを10分にリセットします。"
    },
    {
      "indent": 3,
      "text": "TURN                                 TURN          Peer         Peer\nclient                               server         A            B\n  |--- Refresh request --------------->|            |            |\n  |    Transaction-Id=0x0864B3C27ADE9354B4312414    |            |\n  |    SOFTWARE=\"Example client 1.03\"  |            |            |\n  |    USERNAME=\"George\"               |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"oobMatJos2gAAAadl7W7PeDU4hKE72jda\"    |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |    PASSWORD-ALGORITHM=SHA256       |            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n  |                                    |            |            |\n  |<-- Refresh error response ---------|            |            |\n  |    Transaction-Id=0x0864B3C27ADE9354B4312414    |            |\n  |    SOFTWARE=\"Example server, version 1.17\"      |            |\n  |    ERROR-CODE=438 (Stale Nonce)    |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |                                    |            |            |\n  |--- Refresh request --------------->|            |            |\n  |    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |\n  |    SOFTWARE=\"Example client 1.03\"  |            |            |\n  |    USERNAME=\"George\"               |            |            |\n  |    REALM=\"example.com\"             |            |            |\n  |    NONCE=\"obMatJos2gAAAadl7W7PeDU4hKE72jda\"     |            |\n  |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |\n  |    PASSWORD-ALGORITHM=SHA256       |            |            |\n  |    MESSAGE-INTEGRITY-SHA256=...    |            |            |\n  |                                    |            |            |\n  |<-- Refresh success response -------|            |            |\n  |    Transaction-Id=0x427BD3E625A85FC731DC4191    |            |\n  |    SOFTWARE=\"Example server, version 1.17\"      |            |\n  |    LIFETIME=600 (10 minutes)       |            |            |\n  |    MESSAGE-INTEGRITY=...           |            |            |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 18",
      "ja": "図18"
    },
    {
      "indent": 3,
      "text": "Sometime before the 20-minute lifetime is up, the client refreshes the allocation. This is done using a Refresh request. As before, the client includes the latest username, realm, and nonce values in the request. The client also includes the SOFTWARE attribute, following the recommended practice of always including this attribute in Allocate and Refresh messages. When the server receives the Refresh request, it notices that the nonce value has expired and so replies with a 438 (Stale Nonce) error given a new nonce value. The client then reattempts the request, this time with the new nonce value. This second attempt is accepted, and the server replies with a success response. Note that the client did not include a LIFETIME attribute in the request, so the server refreshes the allocation for the default lifetime of 10 minutes (as can be seen by the LIFETIME attribute in the success response).",
      "ja": "20分間の有効期間が切れる少し前に、クライアントは割り当てを更新します。 これは、更新要求を使用して行われます。 前と同様に、クライアントはリクエストに最新のユーザー名、レルム、ナンス値を含めます。 クライアントには、割り当ておよび更新メッセージに常にこの属性を含めることをお勧めするプラクティスに従って、SOFTWARE属性も含まれています。 サーバーは、更新要求を受信すると、ナンス値が期限切れになったことに気づくため、新しいナンス値が与えられた場合に438（Stale Nonce）エラーで応答します。 次に、クライアントは要求を再試行しますが、今回は新しいnonce値を使用します。 この2回目の試行は受け入れられ、サーバーは成功応答で応答します。 クライアントはリクエストにLIFETIME属性を含めなかったため、サーバーはデフォルトの有効期間である10分の割り当てを更新します（成功応答のLIFETIME属性で確認できます）。"
    },
    {
      "indent": 0,
      "text": "21. Security Considerations",
      "section_title": true,
      "ja": "21. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section considers attacks that are possible in a TURN deployment and discusses how they are mitigated by mechanisms in the protocol or recommended practices in the implementation.",
      "ja": "このセクションでは、TURN展開で発生する可能性のある攻撃を検討し、プロトコルのメカニズムまたは実装で推奨されるプラクティスによってそれらがどのように緩和されるかについて説明します。"
    },
    {
      "indent": 3,
      "text": "Most of the attacks on TURN are mitigated by the server requiring requests be authenticated. Thus, this specification requires the use of authentication. The mandatory-to-implement mechanism is the long-term credential mechanism of STUN. Other authentication mechanisms of equal or stronger security properties may be used. However, it is important to ensure that they can be invoked in an interoperable way.",
      "ja": "TURNへの攻撃のほとんどは、要求の認証を必要とするサーバーによって軽減されます。 したがって、この仕様では認証を使用する必要があります。 実装必須のメカニズムは、STUNの長期的な認証メカニズムです。 同等またはより強力なセキュリティプロパティの他の認証メカニズムを使用できます。 ただし、相互運用可能な方法で呼び出すことができるようにすることが重要です。"
    },
    {
      "indent": 0,
      "text": "21.1. Outsider Attacks",
      "section_title": true,
      "ja": "21.1. 部外者の攻撃"
    },
    {
      "indent": 3,
      "text": "Outsider attacks are ones where the attacker has no credentials in the system and is attempting to disrupt the service seen by the client or the server.",
      "ja": "部外者攻撃とは、攻撃者がシステムに資格情報を持たず、クライアントまたはサーバーから見たサービスを妨害しようとする攻撃です。"
    },
    {
      "indent": 0,
      "text": "21.1.1. Obtaining Unauthorized Allocations",
      "section_title": true,
      "ja": "21.1.1. 不正な割り当ての取得"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to obtain allocations on a TURN server for any number of nefarious purposes. A TURN server provides a mechanism for sending and receiving packets while cloaking the actual IP address of the client. This makes TURN servers an attractive target for attackers who wish to use it to mask their true identity.",
      "ja": "攻撃者は、任意の数の悪質な目的のためにTURNサーバーで割り当てを取得することを望む場合があります。 TURNサーバーは、クライアントの実際のIPアドレスを隠蔽しながらパケットを送受信するためのメカニズムを提供します。 これにより、TURNサーバーは、真のアイデンティティを隠すためにそれを使用したい攻撃者にとって魅力的な標的になります。"
    },
    {
      "indent": 3,
      "text": "An attacker might also wish to simply utilize the services of a TURN server without paying for them. Since TURN services require resources from the provider, it is anticipated that their usage will come with a cost.",
      "ja": "また、攻撃者は、TURNサーバーのサービスに料金を支払うことなく単に利用したい場合があります。 TURNサービスにはプロバイダーからのリソースが必要であるため、その使用にはコストがかかることが予想されます。"
    },
    {
      "indent": 3,
      "text": "These attacks are prevented using the long-term credential mechanism, which allows the TURN server to determine the identity of the requestor and whether the requestor is allowed to obtain the allocation.",
      "ja": "これらの攻撃は、長期の認証メカニズムを使用して防止されます。これにより、TURNサーバーは、リクエスターのIDおよびリクエスターが割り当てを取得できるかどうかを判別できます。"
    },
    {
      "indent": 0,
      "text": "21.1.2. Offline Dictionary Attacks",
      "section_title": true,
      "ja": "21.1.2. オフライン辞書攻撃"
    },
    {
      "indent": 3,
      "text": "The long-term credential mechanism used by TURN is subject to offline dictionary attacks. An attacker that is capable of eavesdropping on a message exchange between a client and server can determine the password by trying a number of candidate passwords and seeing if one of them is correct. This attack works when the passwords are low entropy such as a word from the dictionary. This attack can be mitigated by using strong passwords with large entropy. In situations where even stronger mitigation is required, (D)TLS transport between the client and the server can be used.",
      "ja": "TURNが使用する長期的な認証メカニズムは、オフライン辞書攻撃の影響を受けます。 クライアントとサーバー間のメッセージ交換を盗聴できる攻撃者は、多数の候補パスワードを試し、そのうちの1つが正しいかどうかを確認することでパスワードを決定できます。 この攻撃は、辞書の単語など、パスワードのエントロピーが低い場合に機能します。 この攻撃は、エントロピーが大きい強力なパスワードを使用することで軽減できます。 さらに強力な緩和が必要な状況では、クライアントとサーバー間の（D）TLSトランスポートを使用できます。"
    },
    {
      "indent": 0,
      "text": "21.1.3. Faked Refreshes and Permissions",
      "section_title": true,
      "ja": "21.1.3. 偽造リフレッシュと許可"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to attack an active allocation by sending it a Refresh request with an immediate expiration in order to delete it and disrupt service to the client. This is prevented by authentication of refreshes. Similarly, an attacker wishing to send CreatePermission requests to create permissions to undesirable destinations is prevented from doing so through authentication. The motivations for such an attack are described in Section 21.2.",
      "ja": "攻撃者は、アクティブな割り当てを削除し、クライアントへのサービスを中断するために、有効期限がすぐに切れる更新要求を送信することにより、アクティブな割り当てを攻撃することを望む場合があります。 これは、更新の認証によって防止されます。 同様に、望ましくない宛先へのアクセス許可を作成するためにCreatePermission要求を送信することを望む攻撃者は、認証を介してそうすることを防ぎます。 このような攻撃の動機については、セクション21.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "21.1.4. Fake Data",
      "section_title": true,
      "ja": "21.1.4. 偽データ"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to send data to the client or the peer as if they came from the peer or client, respectively. To do that, the attacker can send the client a faked Data indication or ChannelData message, or send the TURN server a faked Send indication or ChannelData message.",
      "ja": "攻撃者は、それぞれピアまたはクライアントから来たかのように、クライアントまたはピアにデータを送信したい場合があります。 そのために、攻撃者はクライアントに偽のデータ表示またはChannelDataメッセージを送信するか、TURNサーバーに偽の送信表示またはChannelDataメッセージを送信できます。"
    },
    {
      "indent": 3,
      "text": "Since indications and ChannelData messages are not authenticated, this attack is not prevented by TURN. However, this attack is generally present in IP-based communications and is not substantially worsened by TURN. Consider a normal, non-TURN IP session between hosts A and B. An attacker can send packets to B as if they came from A by sending packets towards B with a spoofed IP address of A. This attack requires the attacker to know the IP addresses of A and B. With TURN, an attacker wishing to send packets towards a client using a Data indication needs to know its IP address (and port), the IP address and port of the TURN server, and the IP address and port of the peer (for inclusion in the XOR-PEER-ADDRESS attribute). To send a fake ChannelData message to a client, an attacker needs to know the IP address and port of the client, the IP address and port of the TURN server, and the channel number. This particular combination is mildly more guessable than in the non-TURN case.",
      "ja": "インジケーションとChannelDataメッセージは認証されないため、この攻撃はTURNによって防止されません。 ただし、この攻撃は一般にIPベースの通信に存在し、TURNによって大幅に悪化することはありません。 ホストAとBの間の通常の非TURN IPセッションを考えます。攻撃者は、偽装IPアドレスAを使用してBにパケットを送信することにより、Aから来たかのようにBにパケットを送信できます。 AおよびBのアドレス。TURNを使用して、データ表示を使用してクライアントにパケットを送信する攻撃者は、そのIPアドレス（およびポート）、TURNサーバーのIPアドレスとポート、およびIPアドレスとポートを知る必要があります。 ピア（XOR-PEER-ADDRESS属性に含めるため）。 偽のChannelDataメッセージをクライアントに送信するには、攻撃者はクライアントのIPアドレスとポート、TURNサーバーのIPアドレスとポート、およびチャネル番号を知る必要があります。 この特定の組み合わせは、非ターンの場合よりもやや推測しやすいです。"
    },
    {
      "indent": 3,
      "text": "These attacks are more properly mitigated by application-layer authentication techniques. In the case of real-time traffic, usage of SRTP [RFC3711] prevents these attacks.",
      "ja": "これらの攻撃は、アプリケーション層の認証技術により適切に緩和されます。 リアルタイムトラフィックの場合、SRTP [RFC3711]を使用すると、これらの攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "In some situations, the TURN server may be situated in the network such that it is able to send to hosts to which the client cannot directly send. This can happen, for example, if the server is located behind a firewall that allows packets from outside the firewall to be delivered to the server, but not to other hosts behind the firewall. In these situations, an attacker could send the server a Send indication with an XOR-PEER-ADDRESS attribute containing the transport address of one of the other hosts behind the firewall. If the server was to allow relaying of traffic to arbitrary peers, then this would provide a way for the attacker to attack arbitrary hosts behind the firewall.",
      "ja": "状況によっては、TURNサーバーは、クライアントが直接送信できないホストに送信できるようにネットワーク内に配置される場合があります。 これは、たとえば、サーバーがファイアウォールの背後にあり、ファイアウォールの外側からのパケットをサーバーに配信できるが、ファイアウォールの背後にある他のホストには配信できない場合に発生する可能性があります。 これらの状況では、攻撃者は、ファイアウォールの背後にある他のホストのいずれかのトランスポートアドレスを含むXOR-PEER-ADDRESS属性を持つ送信指示をサーバーに送信する可能性があります。 サーバーが任意のピアへのトラフィックの中継を許可する場合、これは攻撃者がファイアウォールの背後にある任意のホストを攻撃する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "To mitigate this attack, TURN requires that the client establish a permission to a host before sending it data. Thus, an attacker can only attack hosts with which the client is already communicating unless the attacker is able to create authenticated requests. Furthermore, the server administrator may configure the server to restrict the range of IP addresses and ports to which it will relay data. To provide even greater security, the server administrator can require that the client use (D)TLS for all communication between the client and the server.",
      "ja": "この攻撃を軽減するために、TURNでは、データを送信する前にクライアントがホストへの許可を確立する必要があります。 したがって、攻撃者は、認証された要求を作成できない限り、クライアントが既に通信しているホストのみを攻撃できます。 さらに、サーバー管理者は、データを中継するIPアドレスとポートの範囲を制限するようにサーバーを構成できます。 セキュリティをさらに強化するために、サーバー管理者は、クライアントとサーバー間のすべての通信に（D）TLSを使用するようにクライアントに要求できます。"
    },
    {
      "indent": 0,
      "text": "21.1.5. Impersonating a Server",
      "section_title": true,
      "ja": "21.1.5. サーバーの偽装"
    },
    {
      "indent": 3,
      "text": "When a client learns a relayed address from a TURN server, it uses that relayed address in application protocols to receive traffic. Therefore, an attacker wishing to intercept or redirect that traffic might try to impersonate a TURN server and provide the client with a faked relayed address.",
      "ja": "クライアントは、TURNサーバーからリレーされたアドレスを学習すると、アプリケーションプロトコルでそのリレーされたアドレスを使用してトラフィックを受信します。 そのため、そのトラフィックを傍受またはリダイレクトしようとする攻撃者は、TURNサーバーになりすまして、偽の中継アドレスをクライアントに提供しようとする可能性があります。"
    },
    {
      "indent": 3,
      "text": "This attack is prevented through the long-term credential mechanism, which provides message integrity for responses in addition to verifying that they came from the server. Furthermore, an attacker cannot replay old server responses as the transaction id in the STUN header prevents this. Replay attacks are further thwarted through frequent changes to the nonce value.",
      "ja": "この攻撃は、サーバーから送信されたことを確認するだけでなく、応答のメッセージの整合性を提供する長期資格情報メカニズムによって防止されます。 さらに、STUNヘッダーのトランザクションIDがこれを防ぐため、攻撃者は古いサーバーの応答を再生できません。 ノンス値の頻繁な変更により、リプレイ攻撃はさらに阻止されます。"
    },
    {
      "indent": 0,
      "text": "21.1.6. Eavesdropping Traffic",
      "section_title": true,
      "ja": "21.1.6. 盗聴トラフィック"
    },
    {
      "indent": 3,
      "text": "If the TURN client and server use the STUN Extension for Third-Party Authorization [RFC7635] (for example, it is used in WebRTC), the username does not reveal the real user's identity; the USERNAME attribute carries an ephemeral and unique key identifier. If the TURN client and server use the STUN long-term credential mechanism and the username reveals the real user's identity, the client MUST either use the USERHASH attribute instead of the USERNAME attribute to anonymize the username or use (D)TLS transport between the client and the server.",
      "ja": "TURNクライアントとサーバーがサードパーティ認証[RFC7635]にSTUN拡張機能を使用する場合（たとえば、WebRTCで使用される場合）、ユーザー名は実際のユーザーのIDを明らかにしません。 USERNAME属性には、一時的な一意のキー識別子が含まれます。 TURNクライアントとサーバーがSTUN長期資格情報メカニズムを使用し、ユーザー名が実際のユーザーのIDを明らかにする場合、クライアントは、USERNAME属性の代わりにUSERHASH属性を使用してユーザー名を匿名化するか、クライアント間で（D）TLSトランスポートを使用する必要があります およびサーバー。"
    },
    {
      "indent": 3,
      "text": "If the TURN client and server use the STUN long-term credential mechanism, and realm information is privacy sensitive, TURN can be run over (D)TLS. As a reminder, STUN Extension for Third-Party Authorization does not use realm.",
      "ja": "TURNクライアントおよびサーバーがSTUN長期資格情報メカニズムを使用し、レルム情報がプライバシーに敏感な場合、TURNは（D）TLSで実行できます。 念のため、STUN Extension for Third-Party Authorizationはレルムを使用しません。"
    },
    {
      "indent": 3,
      "text": "The SOFTWARE attribute can reveal the specific software version of the TURN client and server to the eavesdropper, and it might possibly allow attacks against vulnerable software that is known to contain security vulnerabilities. If the software version is known to contain security vulnerabilities, TURN SHOULD be run over (D)TLS to prevent leaking the SOFTWARE attribute in clear text. If zero-day vulnerabilities are detected in the software version, the endpoint policy can be modified to mandate the use of (D)TLS until the patch is in place to fix the flaw.",
      "ja": "SOFTWARE属性は、TURNクライアントとサーバーの特定のソフトウェアバージョンを盗聴者に明らかにする可能性があり、セキュリティの脆弱性を含むことが知られている脆弱なソフトウェアに対する攻撃を許可する可能性があります。 ソフトウェアバージョンにセキュリティ脆弱性が含まれていることがわかっている場合は、TURNを（D）TLSで実行して、クリアテキストのSOFTWARE属性のリークを防止する必要があります。 ソフトウェアバージョンでゼロデイ脆弱性が検出された場合、エンドポイントポリシーを変更して、欠陥を修正するパッチが適用されるまで（D）TLSの使用を義務付けることができます。"
    },
    {
      "indent": 3,
      "text": "TURN concerns itself primarily with authentication and message integrity. Confidentiality is only a secondary concern as TURN control messages do not include information that is particularly sensitive with the exception of USERNAME, REALM, and SOFTWARE. The primary protocol content of the messages is the IP address of the peer. If it is important to prevent an eavesdropper on a TURN connection from learning this, TURN can be run over (D)TLS.",
      "ja": "TURNは、主に認証とメッセージの整合性に関係しています。 TURN制御メッセージには、USERNAME、REALM、およびSOFTWAREを除き、特に機密性の高い情報が含まれていないため、機密性は二次的な懸念事項にすぎません。 メッセージの主要なプロトコルコンテンツは、ピアのIPアドレスです。 TURN接続の盗聴者がこれを学習しないようにすることが重要な場合は、TURNを（D）TLSで実行できます。"
    },
    {
      "indent": 3,
      "text": "Confidentiality for the application data relayed by TURN is best provided by the application protocol itself since running TURN over (D)TLS does not protect application data between the server and the peer. If confidentiality of application data is important, then the application should encrypt or otherwise protect its data. For example, for real-time media, confidentiality can be provided by using SRTP.",
      "ja": "TURNオーバー（D）TLSを実行してもサーバーとピア間のアプリケーションデータは保護されないため、TURNによって中継されるアプリケーションデータの機密性はアプリケーションプロトコル自体によって提供されるのが最適です。 アプリケーションデータの機密性が重要な場合、アプリケーションはデータを暗号化するか、そうでなければ保護する必要があります。 たとえば、リアルタイムメディアの場合、SRTPを使用して機密性を提供できます。"
    },
    {
      "indent": 0,
      "text": "21.1.7. TURN Loop Attack",
      "section_title": true,
      "ja": "21.1.7. TURNループ攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to cause data packets to loop indefinitely between two TURN servers. The attack goes as follows: first, the attacker sends an Allocate request to server A using the source address of server B. Server A will send its response to server B, and for the attack to succeed, the attacker must have the ability to either view or guess the contents of this response so that the attacker can learn the allocated relayed transport address. The attacker then sends an Allocate request to server B using the source address of server A. Again, the attacker must be able to view or guess the contents of the response so it can learn the allocated relayed transport address. Using the same spoofed source address technique, the attacker then binds a channel number on server A to the relayed transport address on server B and similarly binds the same channel number on server B to the relayed transport address on server A. Finally, the attacker sends a ChannelData message to server A.",
      "ja": "攻撃者は、2つのTURNサーバー間でデータパケットを無期限にループさせようとする可能性があります。 攻撃は次のように進行します。最初に、攻撃者はサーバーBの送信元アドレスを使用してサーバーAに割り当て要求を送信します。サーバーAはサーバーBに応答を送信し、攻撃が成功するためには、攻撃者は この応答の内容を表示または推測して、攻撃者が割り当てられた中継トランスポートアドレスを学習できるようにします。 その後、攻撃者はサーバーAの送信元アドレスを使用して、サーバーBに割り当て要求を送信します。攻撃者は、割り当てられた中継トランスポートアドレスを学習できるように、応答の内容を表示または推測できる必要があります。 同じスプーフィングされたソースアドレス手法を使用して、攻撃者はサーバーAのチャネル番号をサーバーBの中継トランスポートアドレスにバインドし、同様にサーバーBの同じチャネル番号をサーバーAの中継トランスポートアドレスにバインドします サーバーAへのChannelDataメッセージ"
    },
    {
      "indent": 3,
      "text": "The result is a data packet that loops from the relayed transport address on server A to the relayed transport address on server B, then from server B's transport address to server A's transport address, and then around the loop again.",
      "ja": "結果は、サーバーAの中継されたトランスポートアドレスからサーバーBの中継されたトランスポートアドレスにループし、次にサーバーBのトランスポートアドレスからサーバーAのトランスポートアドレスにループし、その後ループを繰り返すデータパケットです。"
    },
    {
      "indent": 3,
      "text": "This attack is mitigated as follows: by requiring all requests to be authenticated and/or by randomizing the port number allocated for the relayed transport address, the server forces the attacker to either intercept or view responses sent to a third party (in this case, the other server) so that the attacker can authenticate the requests and learn the relayed transport address. Without one of these two measures, an attacker can guess the contents of the responses without needing to see them, which makes the attack much easier to perform. Furthermore, by requiring authenticated requests, the server forces the attacker to have credentials acceptable to the server, which turns this from an outsider attack into an insider attack and allows the attack to be traced back to the client initiating it.",
      "ja": "この攻撃は次のように軽減されます。すべての要求の認証を要求するか、中継されたトランスポートアドレスに割り当てられたポート番号をランダム化することにより、サーバーは攻撃者に第三者に送信された応答を傍受または表示させます（この場合、 攻撃者がリクエストを認証し、中継されたトランスポートアドレスを学習できるようにするためです。 これらの2つの対策のいずれかがなければ、攻撃者は応答を見なくても応答の内容を推測できるため、攻撃の実行がはるかに容易になります。 さらに、認証された要求を要求することにより、サーバーは攻撃者にサーバーに受け入れられる資格情報を強制します。これにより、これは部外者攻撃から内部者攻撃に変わり、攻撃を開始したクライアントにまで遡ることができます。"
    },
    {
      "indent": 3,
      "text": "The attack can be further mitigated by imposing a per-username limit on the bandwidth used to relay data by allocations owned by that username to limit the impact of this attack on other allocations. More mitigation can be achieved by decrementing the TTL when relaying data packets (if the underlying OS allows this).",
      "ja": "そのユーザー名が所有する割り当てによってデータを中継するために使用される帯域幅にユーザー名ごとの制限を課すことにより、攻撃をさらに緩和し、他の割り当てに対するこの攻撃の影響を制限できます。 データパケットを中継するときにTTLをデクリメントすることで、さらに軽減することができます（基になるOSで許可されている場合）。"
    },
    {
      "indent": 0,
      "text": "21.2. Firewall Considerations",
      "section_title": true,
      "ja": "21.2. ファイアウォールの考慮事項"
    },
    {
      "indent": 3,
      "text": "A key security consideration of TURN is that TURN should not weaken the protections afforded by firewalls deployed between a client and a TURN server. It is anticipated that TURN servers will often be present on the public Internet, and clients may often be inside enterprise networks with corporate firewalls. If TURN servers provide a \"backdoor\" for reaching into the enterprise, TURN will be blocked by these firewalls.",
      "ja": "TURNの重要なセキュリティ上の考慮事項は、クライアントとTURNサーバーの間に展開されたファイアウォールによって提供される保護をTURNが弱めないことです。 多くの場合、TURNサーバーはパブリックインターネット上に存在し、クライアントは企業ファイアウォールを備えた企業ネットワーク内にあることが予想されます。 TURNサーバーが企業に到達するための「バックドア」を提供する場合、TURNはこれらのファイアウォールによってブロックされます。"
    },
    {
      "indent": 3,
      "text": "TURN servers therefore emulate the behavior of NAT devices that implement address-dependent filtering [RFC4787], a property common in many firewalls as well. When a NAT or firewall implements this behavior, packets from an outside IP address are only allowed to be sent to an internal IP address and port if the internal IP address and port had recently sent a packet to that outside IP address. TURN servers introduce the concept of permissions, which provide exactly this same behavior on the TURN server. An attacker cannot send a packet to a TURN server and expect it to be relayed towards the client, unless the client has tried to contact the attacker first.",
      "ja": "したがって、TURNサーバーは、アドレス依存フィルタリング[RFC4787]を実装するNATデバイスの動作をエミュレートします。これは、多くのファイアウォールでも一般的なプロパティです。 NATまたはファイアウォールがこの動作を実装する場合、外部IPアドレスからのパケットは、内部IPアドレスとポートが最近その外部IPアドレスにパケットを送信した場合にのみ、内部IPアドレスとポートに送信できます。 TURNサーバーは、TURNサーバーでまったく同じ動作を提供する許可の概念を導入します。 クライアントが最初に攻撃者と連絡を取ろうとした場合を除き、攻撃者はTURNサーバーにパケットを送信し、クライアントに向けてリレーされることを期待できません。"
    },
    {
      "indent": 3,
      "text": "It is important to note that some firewalls have policies that are even more restrictive than address-dependent filtering. Firewalls can also be configured with address- and port-dependent filtering, or they can be configured to disallow inbound traffic entirely. In these cases, if a client is allowed to connect the TURN server, communications to the client will be less restrictive than what the firewall would normally allow.",
      "ja": "一部のファイアウォールには、アドレス依存のフィルタリングよりもさらに制限の厳しいポリシーがあることに注意することが重要です。 ファイアウォールは、アドレスおよびポートに依存するフィルタリングを使用して構成することも、着信トラフィックを完全に禁止するように構成することもできます。 これらの場合、クライアントがTURNサーバーへの接続を許可されている場合、クライアントへの通信は、ファイアウォールが通常許可するものよりも制限が少なくなります。"
    },
    {
      "indent": 0,
      "text": "21.2.1. Faked Permissions",
      "section_title": true,
      "ja": "21.2.1. 偽造許可"
    },
    {
      "indent": 3,
      "text": "In firewalls and NAT devices, permissions are granted implicitly through the traversal of a packet from the inside of the network towards the outside peer. Thus, a permission cannot, by definition, be created by any entity except one inside the firewall or NAT. With TURN, this restriction no longer holds. Since the TURN server sits outside the firewall, an attacker outside the firewall can now send a message to the TURN server and try to create a permission for itself.",
      "ja": "ファイアウォールおよびNATデバイスでは、ネットワークの内部から外部のピアに向かってパケットを走査することにより、暗黙的に許可が付与されます。 したがって、ファイアウォールまたはNATの内側にあるエンティティ以外のエンティティは、定義により許可を作成できません。 TURNでは、この制限はなくなりました。 TURNサーバーはファイアウォールの外側にあるため、ファイアウォールの外側の攻撃者はTURNサーバーにメッセージを送信し、自身の許可を作成しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "This attack is prevented because all messages that create permissions (i.e., ChannelBind and CreatePermission) are authenticated.",
      "ja": "権限を作成するすべてのメッセージ（つまり、ChannelBindおよびCreatePermission）が認証されるため、この攻撃は防止されます。"
    },
    {
      "indent": 0,
      "text": "21.2.2. Blacklisted IP Addresses",
      "section_title": true,
      "ja": "21.2.2. ブラックリストに登録されたIPアドレス"
    },
    {
      "indent": 3,
      "text": "Many firewalls can be configured with blacklists that prevent a client behind the firewall from sending packets to, or receiving packets from, ranges of blacklisted IP addresses. This is accomplished by inspecting the source and destination addresses of packets entering and exiting the firewall, respectively.",
      "ja": "多くのファイアウォールは、ファイアウォールの背後にあるクライアントがブラックリストに登録されたIPアドレスの範囲に対してパケットを送受信できないようにするブラックリストを使用して構成できます。 これは、ファイアウォールに出入りするパケットの送信元アドレスと宛先アドレスをそれぞれ検査することで実現されます。"
    },
    {
      "indent": 3,
      "text": "This feature is also present in TURN since TURN servers are allowed to arbitrarily restrict the range of addresses of peers that they will relay to.",
      "ja": "TURNサーバーは中継先のピアのアドレス範囲を任意に制限できるため、この機能はTURNにも存在します。"
    },
    {
      "indent": 0,
      "text": "21.2.3. Running Servers on Well-Known Ports",
      "section_title": true,
      "ja": "21.2.3. 既知のポートでのサーバーの実行"
    },
    {
      "indent": 3,
      "text": "A malicious client behind a firewall might try to connect to a TURN server and obtain an allocation that it then uses to run a server. For example, a client might try to run a DNS server or FTP server.",
      "ja": "ファイアウォールの背後にある悪意のあるクライアントは、TURNサーバーに接続し、サーバーを実行するために使用する割り当てを取得しようとする場合があります。 たとえば、クライアントがDNSサーバーまたはFTPサーバーを実行しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "This is not possible in TURN. A TURN server will never accept traffic from a peer for which the client has not installed a permission. Thus, peers cannot just connect to the allocated port in order to obtain the service.",
      "ja": "これはTURNでは不可能です。 TURNサーバーは、クライアントが許可をインストールしていないピアからのトラフィックを決して受け入れません。 したがって、ピアは、割り当てられたポートに接続してサービスを取得することはできません。"
    },
    {
      "indent": 0,
      "text": "21.3. Insider Attacks",
      "section_title": true,
      "ja": "21.3. インサイダー攻撃"
    },
    {
      "indent": 3,
      "text": "In insider attacks, a client has legitimate credentials but defies the trust relationship that goes with those credentials. These attacks cannot be prevented by cryptographic means but need to be considered in the design of the protocol.",
      "ja": "インサイダー攻撃では、クライアントには正当な資格情報がありますが、それらの資格情報に伴う信頼関係は無視されます。 これらの攻撃は暗号化手段によって防止することはできませんが、プロトコルの設計で考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "21.3.1. DoS against TURN Server",
      "section_title": true,
      "ja": "21.3.1. TURN Serverに対するDoS"
    },
    {
      "indent": 3,
      "text": "A client wishing to disrupt service to other clients might obtain an allocation and then flood it with traffic in an attempt to swamp the server and prevent it from servicing other legitimate clients. This is mitigated by the recommendation that the server limit the amount of bandwidth it will relay for a given username. This won't prevent a client from sending a large amount of traffic, but it allows the server to immediately discard traffic in excess.",
      "ja": "他のクライアントへのサービスを中断したいクライアントは、割り当てを取得し、サーバーを圧迫して他の正当なクライアントにサービスを提供することを防ぐためにトラフィックを殺到する可能性があります。 これは、サーバーが特定のユーザー名に対して中継する帯域幅の量を制限するという推奨事項によって緩和されます。 これにより、クライアントが大量のトラフィックを送信するのを防ぐことはできませんが、サーバーは過剰なトラフィックをすぐに破棄できます。"
    },
    {
      "indent": 3,
      "text": "Since each allocation uses a port number on the IP address of the TURN server, the number of allocations on a server is finite. An attacker might attempt to consume all of them by requesting a large number of allocations. This is prevented by the recommendation that the server impose a limit on the number of allocations active at a time for a given username.",
      "ja": "各割り当てはTURNサーバーのIPアドレスのポート番号を使用するため、サーバー上の割り当ての数は有限です。 攻撃者は、大量の割り当てを要求することにより、それらすべてを消費しようとする可能性があります。 これは、サーバーが特定のユーザー名に対して一度にアクティブな割り当ての数に制限を課すことを推奨することによって防止されます。"
    },
    {
      "indent": 0,
      "text": "21.3.2. Anonymous Relaying of Malicious Traffic",
      "section_title": true,
      "ja": "21.3.2. 悪意のあるトラフィックの匿名中継"
    },
    {
      "indent": 3,
      "text": "TURN servers provide a degree of anonymization. A client can send data to peers without revealing its own IP address. TURN servers may therefore become attractive vehicles for attackers to launch attacks against targets without fear of detection. Indeed, it is possible for a client to chain together multiple TURN servers such that any number of relays can be used before a target receives a packet.",
      "ja": "TURNサーバーは、ある程度の匿名化を提供します。 クライアントは、自身のIPアドレスを公開せずに、ピアにデータを送信できます。 したがって、TURNサーバーは、検出を恐れることなく攻撃者が標的に対して攻撃を仕掛ける魅力的な手段になる可能性があります。 実際、クライアントが複数のTURNサーバーをチェーン化して、ターゲットがパケットを受信する前に任意の数のリレーを使用できるようにすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Administrators who are worried about this attack can maintain logs that capture the actual source IP and port of the client and perhaps even every permission that client installs. This will allow for forensic tracing to determine the original source should it be discovered that an attack is being relayed through a TURN server.",
      "ja": "この攻撃を心配している管理者は、クライアントの実際のソースIPとポート、さらにはクライアントがインストールするすべての許可をキャプチャするログを保持できます。 これにより、攻撃がTURNサーバーを介してリレーされていることが発見された場合に、フォレンシックトレースで元のソースを特定できます。"
    },
    {
      "indent": 0,
      "text": "21.3.3. Manipulating Other Allocations",
      "section_title": true,
      "ja": "21.3.3. 他の割り当ての操作"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to disrupt service to other users of the TURN server by sending Refresh requests or CreatePermission requests that (through source address spoofing) appear to be coming from another user of the TURN server. TURN prevents this by requiring that the credentials used in CreatePermission, Refresh, and ChannelBind messages match those used to create the initial allocation. Thus, the fake requests from the attacker will be rejected.",
      "ja": "攻撃者は、（送信元アドレスのなりすましを介して）TURNサーバーの別のユーザーから来ているように見えるRefresh要求またはCreatePermission要求を送信することにより、TURNサーバーの他のユーザーへのサービスを妨害しようとする可能性があります。 TURNは、CreatePermission、Refresh、およびChannelBindメッセージで使用される資格情報が、初期割り当ての作成に使用される資格情報と一致することを要求することにより、これを防ぎます。 したがって、攻撃者からの偽のリクエストは拒否されます。"
    },
    {
      "indent": 0,
      "text": "21.4. Tunnel Amplification Attack",
      "section_title": true,
      "ja": "21.4. トンネル増幅攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to cause data packets to loop numerous times between a TURN server and a tunnel between IPv4 and IPv6. The attack goes as follows:",
      "ja": "攻撃者は、TURNサーバーとIPv4とIPv6の間のトンネルとの間でデータパケットを何度もループさせようとする可能性があります。 攻撃は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Suppose an attacker knows that a tunnel endpoint will forward encapsulated packets from a given IPv6 address (this doesn't necessarily need to be the tunnel endpoint's address). Suppose he then spoofs two packets from this address:",
      "ja": "トンネルエンドポイントが特定のIPv6アドレスからカプセル化されたパケットを転送することを攻撃者が知っているとします（これは必ずしもトンネルエンドポイントのアドレスである必要はありません）。 次に、このアドレスから2つのパケットをスプーフィングするとします。"
    },
    {
      "indent": 3,
      "text": "1. An Allocate request asking for a v4 address, and",
      "ja": "1. v4アドレスを要求する割り当て要求、および"
    },
    {
      "indent": 3,
      "text": "2. A ChannelBind request establishing a channel to the IPv4 address of the tunnel endpoint.",
      "ja": "2. トンネルエンドポイントのIPv4アドレスへのチャネルを確立するChannelBind要求。"
    },
    {
      "indent": 3,
      "text": "Then, he has set up an amplification attack:",
      "ja": "次に、彼は増幅攻撃を設定しました。"
    },
    {
      "indent": 3,
      "text": "* The TURN server will re-encapsulate IPv6 UDP data in v4 and send it to the tunnel endpoint.",
      "ja": "* TURNサーバーは、v4でIPv6 UDPデータを再カプセル化し、トンネルエンドポイントに送信します。"
    },
    {
      "indent": 3,
      "text": "* The tunnel endpoint will de-encapsulate packets from the v4 interface and send them to v6.",
      "ja": "* トンネルエンドポイントは、v4インターフェイスからのパケットのカプセル化を解除し、v6に送信します。"
    },
    {
      "indent": 3,
      "text": "So, if the attacker sends a packet of the following form:",
      "ja": "したがって、攻撃者が次の形式のパケットを送信した場合："
    },
    {
      "indent": 5,
      "text": "IPv6: src=2001:DB8:1::1 dst=2001:DB8::2 UDP: <ports> TURN: <channel id> IPv6: src=2001:DB8:1::1 dst=2001:DB8::2 UDP: <ports> TURN: <channel id> IPv6: src=2001:DB8:1::1 dst=2001:DB8::2 UDP: <ports> TURN: <channel id> ...",
      "ja": "IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ports> TURN：<channel id> IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ports> TURN：<channel id> IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ports> TURN：<channel id> ..."
    },
    {
      "indent": 33,
      "text": "Figure 19",
      "ja": "図19"
    },
    {
      "indent": 3,
      "text": "then the TURN server and the tunnel endpoint will send it back and forth until the last TURN header is consumed, at which point the TURN server will send an empty packet that the tunnel endpoint will drop.",
      "ja": "その後、TURNサーバーとトンネルエンドポイントは、最後のTURNヘッダーが消費されるまで往復します。その時点で、TURNサーバーは、トンネルエンドポイントがドロップする空のパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "The amplification potential here is limited by the MTU, so it's not huge: IPv6+UDP+TURN takes 334 bytes, so a four-to-one amplification out of a 1500-byte packet is possible. But, the attacker could still increase traffic volume by sending multiple packets or by establishing multiple channels spoofed from different addresses behind the same tunnel endpoint.",
      "ja": "ここでの増幅の可能性はMTUによって制限されるため、それほど大きくはありません。IPv6+ UDP + TURNは334バイトかかるため、1500バイトのパケットから4対1の増幅が可能です。 ただし、攻撃者は複数のパケットを送信するか、同じトンネルエンドポイントの背後にある異なるアドレスから偽装された複数のチャネルを確立することにより、トラフィック量を増やすことができます。"
    },
    {
      "indent": 3,
      "text": "The attack is mitigated as follows. It is RECOMMENDED that TURN servers not accept allocation or channel-binding requests from addresses known to be tunneled, and that they not forward data to such addresses. In particular, a TURN server MUST NOT accept Teredo or 6to4 addresses in these requests.",
      "ja": "攻撃は次のように軽減されます。 TURNサーバーは、トンネリングされることがわかっているアドレスからの割り当てまたはチャネルバインド要求を受け入れず、そのようなアドレスにデータを転送しないことをお勧めします。 特に、TURNサーバーは、これらの要求でTeredoまたは6to4アドレスを受け入れてはなりません。"
    },
    {
      "indent": 0,
      "text": "21.5. Other Considerations",
      "section_title": true,
      "ja": "21.5. その他の考慮事項"
    },
    {
      "indent": 3,
      "text": "Any relay addresses learned through an Allocate request will not operate properly with IPsec Authentication Header (AH) [RFC4302] in transport or tunnel mode. However, tunnel-mode IPsec Encapsulating Security Payload (ESP) [RFC4303] should still operate.",
      "ja": "Allocate要求を介して学習されたリレーアドレスは、トランスポートモードまたはトンネルモードのIPsec認証ヘッダー（AH）[RFC4302]では正常に動作しません。 ただし、トンネルモードIPsecカプセル化セキュリティペイロード（ESP）[RFC4303]は引き続き動作するはずです。"
    },
    {
      "indent": 0,
      "text": "22. IANA Considerations",
      "section_title": true,
      "ja": "22. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The code points for the STUN methods defined in this specification are listed in Section 17. IANA has updated the references from [RFC5766] to this document (for the STUN methods listed in Section 17).",
      "ja": "この仕様で定義されたSTUNメソッドのコードポイントはセクション17にリストされています。IANAは[RFC5766]からこのドキュメントへの参照を更新しました（セクション17にリストされたSTUNメソッドの場合）。"
    },
    {
      "indent": 3,
      "text": "The code points for the STUN attributes defined in this specification are listed in Section 18. IANA has updated the references from [RFC5766] to this document (for the STUN attributes CHANNEL-NUMBER, LIFETIME, Reserved (was BANDWIDTH), XOR-PEER-ADDRESS, DATA, XOR-RELAYED-ADDRESS, REQUESTED-ADDRESS-FAMILY, EVEN-PORT, REQUESTED-TRANSPORT, DONT-FRAGMENT, Reserved (was TIMER-VAL), and RESERVATION-TOKEN listed in Section 18).",
      "ja": "この仕様で定義されたSTUN属性のコードポイントはセクション18にリストされています。IANAは[RFC5766]からこのドキュメントへの参照を更新しました（STUN属性CHANNEL-NUMBER、LIFETIME、Reserved（was BANDWIDTH）、XOR-PEER- アドレス、データ、XOR-RELAYED-ADDRESS、REQUESTED-ADDRESS-FAMILY、EVEN-PORT、REQUESTED-TRANSPORT、DONT-FRAGMENT、予約済み（TIMER-VAL）、およびRESERVATION-TOKENはセクション18にリストされています）。"
    },
    {
      "indent": 3,
      "text": "The code points for the STUN error codes defined in this specification are listed in Section 19. IANA has updated the references from [RFC5766] and [RFC6156] to this document (for the STUN error codes listed in Section 19).",
      "ja": "この仕様で定義されたSTUNエラーコードのコードポイントはセクション19にリストされています。IANAは[RFC5766]と[RFC6156]からこのドキュメントへの参照を更新しました（セクション19にリストされたSTUNエラーコードのために）。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the references to [RFC5766] to this document for the SRV service name of \"turn\" for TURN over UDP or TCP and the service name of \"turns\" for TURN over (D)TLS.",
      "ja": "IANAは、TURN over UDPまたはTCPの「turn」のSRVサービス名およびTURN over（D）TLSの「turns」のサービス名について、このドキュメントへの[RFC5766]への参照を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry for TURN channel numbers (the \"Traversal Using Relays around NAT (TURN) Channel Numbers\" registry), initially populated as follows:",
      "ja": "IANAはTURNチャネル番号のレジストリ（「NAT（TURN）チャネル番号の周りのリレーを使用するトラバーサル」レジストリ）を作成し、最初は次のように入力しました。"
    },
    {
      "indent": 3,
      "text": "+------------------------+------------------------------------------+\n| 0x0000 through         | Reserved and not available for use since |\n| 0x3FFF:                | they conflict with the STUN header.      |\n+------------------------+------------------------------------------+\n| 0x4000 through         | A TURN implementation is free to use     |\n| 0x4FFF:                | channel numbers in this range.           |\n+------------------------+------------------------------------------+\n| 0x5000 through         | Reserved (For DTLS-SRTP multiplexing     |\n| 0xFFFF:                | collision avoidance, see [RFC7983])      |\n+------------------------+------------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 6",
      "ja": "表6"
    },
    {
      "indent": 3,
      "text": "Any change to this registry must be made through an IETF Standards Action.",
      "ja": "このレジストリへの変更は、IETF標準アクションを通じて行う必要があります。"
    },
    {
      "indent": 0,
      "text": "23. IAB Considerations",
      "section_title": true,
      "ja": "23. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of Unilateral Self-Address Fixing (UNSAF), which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism [RFC3424]. The TURN extension is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. These considerations and the responses for TURN are documented in this section.",
      "ja": "IABは、Unilateral Self-Address Fixing（UNSAF）の問題を研究しました。これは、クライアントが協調プロトコルリフレクションメカニズム[RFC3424]を介してNATの反対側の別の領域でアドレスを決定しようとする一般的なプロセスです。 TURN拡張は、このタイプの機能を実行するプロトコルの例です。 IABは、この目的のために開発されたプロトコルは、特定の考慮事項を文書化することを義務付けています。 TURNのこれらの考慮事項と応答は、このセクションで文書化されています。"
    },
    {
      "indent": 3,
      "text": "Consideration 1: Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short-term fix should not be generalized to solve other problems. Such generalizations lead to the prolonged dependence on and usage of the supposed short-term fix, meaning that it is no longer accurate to call it \"short-term\".",
      "ja": "考慮事項1：UNSAF提案で解決される特定の限定された範囲の問題の正確な定義。 他の問題を解決するために短期的な修正を一般化すべきではありません。 このような一般化は、想定される短期修正への依存と使用の長期化につながります。つまり、「短期」と呼ぶのはもはや正確ではありません。"
    },
    {
      "indent": 3,
      "text": "Response: TURN is a protocol for communication between a relay (= TURN server) and its client. The protocol allows a client that is behind a NAT to obtain and use a public IP address on the relay. As a convenience to the client, TURN also allows the client to determine its server-reflexive transport address.",
      "ja": "応答：TURNは、リレー（= TURNサーバー）とそのクライアント間の通信用のプロトコルです。 このプロトコルにより、NATの背後にあるクライアントは、リレーでパブリックIPアドレスを取得して使用できます。 クライアントの利便性として、TURNでは、クライアントがサーバー反射トランスポートアドレスを決定することもできます。"
    },
    {
      "indent": 3,
      "text": "Consideration 2: Description of an exit strategy/transition plan. The better short-term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.",
      "ja": "考慮事項2：出口戦略/移行計画の説明。 より適切な短期的な修正は、適切な技術が展開されるにつれて、当然ながら使用が少なくなる修正です。"
    },
    {
      "indent": 3,
      "text": "Response: TURN will no longer be needed once there are no longer any NATs. Unfortunately, as of the date of publication of this document, it no longer seems very likely that NATs will go away any time soon. However, the need for TURN will also decrease as the number of NATs with the mapping property of Endpoint-Independent Mapping [RFC4787] increases.",
      "ja": "応答：NATがなくなると、TURNは不要になります。 残念ながら、このドキュメントの公開日現在、NATがすぐになくなることはほとんどありません。 ただし、エンドポイントに依存しないマッピング[RFC4787]のマッピングプロパティを持つNATの数が増えると、TURNの必要性も減少します。"
    },
    {
      "indent": 3,
      "text": "Consideration 3: Discussion of specific issues that may render systems more \"brittle\". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.",
      "ja": "考慮事項3：システムをより「脆弱」にする特定の問題の議論。 たとえば、複数のネットワーク層でデータを使用するアプローチでは、依存関係が増え、デバッグの課題が増え、移行が難しくなります。"
    },
    {
      "indent": 3,
      "text": "Response: TURN is \"brittle\" in that it requires the NAT bindings between the client and the server to be maintained unchanged for the lifetime of the allocation. This is typically done using keep-alives. If this is not done, then the client will lose its allocation and can no longer exchange data with its peers.",
      "ja": "応答：TURNは、クライアントとサーバー間のNATバインディングが割り当ての存続期間中変更されないように維持されることを要求するという点で「脆弱」です。 これは通常、キープアライブを使用して行われます。 これを行わないと、クライアントは割り当てを失い、ピアとデータを交換できなくなります。"
    },
    {
      "indent": 3,
      "text": "Consideration 4: Identify requirements for longer-term, sound technical solutions; contribute to the process of finding the right longer-term solution.",
      "ja": "考慮事項4：長期にわたる健全な技術的ソリューションの要件を特定します。 適切な長期的なソリューションを見つけるプロセスに貢献する。"
    },
    {
      "indent": 3,
      "text": "Response: The need for TURN will be reduced once NATs implement the recommendations for NAT UDP behavior documented in [RFC4787]. Applications are also strongly urged to use ICE [RFC8445] to communicate with peers; though ICE uses TURN, it does so only as a last resort, and it uses it in a controlled manner.",
      "ja": "応答：[RFC4787]で文書化されたNAT UDP動作の推奨事項をNATが実装すると、TURNの必要性が減ります。 また、アプリケーションは、ICE [RFC8445]を使用してピアと通信することを強くお勧めします。 ICEはTURNを使用しますが、最後の手段としてのみ使用し、制御された方法で使用します。"
    },
    {
      "indent": 3,
      "text": "Consideration 5: Discussion of the impact of the noted practical issues with existing deployed NATs and experience reports.",
      "ja": "考慮事項5：既存の展開されたNATと経験レポートでの実際的な問題の影響の議論。"
    },
    {
      "indent": 3,
      "text": "Response: Some NATs deployed today exhibit a mapping behavior other than Endpoint-Independent mapping. These NATs are difficult to work with, as they make it difficult or impossible for protocols like ICE to use server-reflexive transport addresses on those NATs. A client behind such a NAT is often forced to use a relay protocol like TURN because \"UDP hole punching\" techniques [RFC5128] do not work.",
      "ja": "応答：現在展開されている一部のNATは、エンドポイントに依存しないマッピング以外のマッピング動作を示します。 これらのNATは、ICEなどのプロトコルがこれらのNATでサーバー反射トランスポートアドレスを使用することを困難または不可能にするため、操作が困難です。 このようなNATの背後にあるクライアントは、「UDPホールパンチ」技術[RFC5128]が機能しないため、TURNのようなリレープロトコルの使用を強制されることがよくあります。"
    },
    {
      "indent": 0,
      "text": "24. Changes since RFC 5766",
      "section_title": true,
      "ja": "24. RFC 5766以降の変更"
    },
    {
      "indent": 3,
      "text": "This section lists the major changes in the TURN protocol from the original [RFC5766] specification.",
      "ja": "このセクションでは、元の[RFC5766]仕様からのTURNプロトコルの主要な変更をリストします。"
    },
    {
      "indent": 3,
      "text": "* IPv6 support.",
      "ja": "* IPv6サポート。"
    },
    {
      "indent": 3,
      "text": "* REQUESTED-ADDRESS-FAMILY attribute.",
      "ja": "* REQUESTED-ADDRESS-FAMILY属性。"
    },
    {
      "indent": 3,
      "text": "* Description of the tunnel amplification attack.",
      "ja": "* トンネル増幅攻撃の説明。"
    },
    {
      "indent": 3,
      "text": "* DTLS support.",
      "ja": "* DTLSサポート。"
    },
    {
      "indent": 3,
      "text": "* Add support for receiving ICMP packets.",
      "ja": "* ICMPパケットの受信のサポートを追加します。"
    },
    {
      "indent": 3,
      "text": "* Updates PMTUD.",
      "ja": "* PMTUDを更新します。"
    },
    {
      "indent": 3,
      "text": "* Discovery of TURN server.",
      "ja": "* TURNサーバーの発見。"
    },
    {
      "indent": 3,
      "text": "* TURN URI Scheme Semantics.",
      "ja": "* TURN URIスキームのセマンティクス。"
    },
    {
      "indent": 3,
      "text": "* Happy Eyeballs for TURN.",
      "ja": "* TURNのハッピーアイボール。"
    },
    {
      "indent": 3,
      "text": "* Align with the changes in STUN [RFC8489].",
      "ja": "* STUN [RFC8489]の変更に合わせます。"
    },
    {
      "indent": 0,
      "text": "25. Updates to RFC 6156",
      "section_title": true,
      "ja": "25. RFC 6156の更新"
    },
    {
      "indent": 3,
      "text": "This section lists the major updates to [RFC6156] in this specification.",
      "ja": "このセクションでは、この仕様の[RFC6156]の主要な更新を示します。"
    },
    {
      "indent": 3,
      "text": "* ADDITIONAL-ADDRESS-FAMILY and ADDRESS-ERROR-CODE attributes.",
      "ja": "* ADDITIONAL-ADDRESS-FAMILYおよびADDRESS-ERROR-CODE属性。"
    },
    {
      "indent": 3,
      "text": "* 440 (Address Family not Supported) and 443 (Peer Address Family Mismatch) responses.",
      "ja": "* 440（アドレスファミリはサポートされていません）および443（ピアアドレスファミリの不一致）応答。"
    },
    {
      "indent": 3,
      "text": "* More details on packet translation.",
      "ja": "* パケット変換の詳細。"
    },
    {
      "indent": 3,
      "text": "* TCP-to-UDP and UDP-to-TCP relaying.",
      "ja": "* TCP-to-UDPおよびUDP-to-TCPリレー。"
    },
    {
      "indent": 0,
      "text": "26. References",
      "section_title": true,
      "ja": "26. 参考文献"
    },
    {
      "indent": 0,
      "text": "26.1. Normative References",
      "section_title": true,
      "ja": "26.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[PROTOCOL-NUMBERS] IANA, \"Protocol Numbers\", <https://www.iana.org/assignments/protocol-numbers>.",
      "ja": "[プロトコル番号] IANA、「プロトコル番号」、<https://www.iana.org/assignments/protocol-numbers>。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <https://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC0792]ポステル、J。、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<https://www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R。、「インターネットホストの要件-通信層」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https://www.rfc-editor.org/info/ rfc1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2474] Nichols, K., Blake, S., Baker, F., and D. Black, \"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers\", RFC 2474, DOI 10.17487/RFC2474, December 1998, <https://www.rfc-editor.org/info/rfc2474>.",
      "ja": "[RFC2474]ニコルズ、K。、ブレイク、S。、ベイカー、F。、およびD.ブラック、「IPv4およびIPv6ヘッダーの差別化サービスフィールド（DSフィールド）の定義」、RFC 2474、DOI 10.17487 / RFC2474、 1998年12月、<https://www.rfc-editor.org/info/rfc2474>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "[RFC3168]ラマクリシュナン、K。、フロイド、S。、およびD.ブラック、「IPへの明示的な輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：// www。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、変換フォーマットISO 10646」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006, <https://www.rfc-editor.org/info/rfc4443>.",
      "ja": "[RFC4443] Conta、A.、Deering、S。、およびM. Gupta、Ed。、「インターネットプロトコルバージョン6（IPv6）仕様のインターネット制御メッセージプロトコル（ICMPv6）」、STD 89、RFC 4443、DOI 10.17487 / RFC4443、2006年3月、<https://www.rfc-editor.org/info/rfc4443>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347] Rescorla、E。およびN. Modadugu、「データグラムトランスポートレイヤーセキュリティバージョン1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6437] Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme, \"IPv6 Flow Label Specification\", RFC 6437, DOI 10.17487/RFC6437, November 2011, <https://www.rfc-editor.org/info/rfc6437>.",
      "ja": "[RFC6437]アマンテ、S。、カーペンター、B。、ジャン、S。、およびJ.ラジャハルメ、「IPv6フローラベル仕様」、RFC 6437、DOI 10.17487 / RFC6437、2011年11月、<https：//www.rfc- editor.org/info/rfc6437>。"
    },
    {
      "indent": 3,
      "text": "[RFC7065] Petit-Huguenin, M., Nandakumar, S., Salgueiro, G., and P. Jones, \"Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers\", RFC 7065, DOI 10.17487/RFC7065, November 2013, <https://www.rfc-editor.org/info/rfc7065>.",
      "ja": "[RFC7065] Petit-Huguenin、M.、Nandakumar、S.、Salgueiro、G。、およびP. Jones、「NAT（TURN）Uniform Resource Identifiers周辺のリレーを使用したトラバーサル」、RFC 7065、DOI 10.17487 / RFC7065、2013年11月、 <https://www.rfc-editor.org/info/rfc7065>。"
    },
    {
      "indent": 3,
      "text": "[RFC7350] Petit-Huguenin, M. and G. Salgueiro, \"Datagram Transport Layer Security (DTLS) as Transport for Session Traversal Utilities for NAT (STUN)\", RFC 7350, DOI 10.17487/RFC7350, August 2014, <https://www.rfc-editor.org/info/rfc7350>.",
      "ja": "[RFC7350] Petit-Huguenin、M。、およびG. /www.rfc-editor.org/info/rfc7350>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <https://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<https://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7915] Bao, C., Li, X., Baker, F., Anderson, T., and F. Gont, \"IP/ICMP Translation Algorithm\", RFC 7915, DOI 10.17487/RFC7915, June 2016, <https://www.rfc-editor.org/info/rfc7915>.",
      "ja": "[RFC7915]バオ、C。、リー、X。、ベイカー、F。、アンダーソン、T。、およびF.ゴント、「IP / ICMP変換アルゴリズム」、RFC 7915、DOI 10.17487 / RFC7915、2016年6月、<https： //www.rfc-editor.org/info/rfc7915>。"
    },
    {
      "indent": 3,
      "text": "[RFC7982] Martinsen, P., Reddy, T., Wing, D., and V. Singh, \"Measurement of Round-Trip Time and Fractional Loss Using Session Traversal Utilities for NAT (STUN)\", RFC 7982, DOI 10.17487/RFC7982, September 2016, <https://www.rfc-editor.org/info/rfc7982>.",
      "ja": "[RFC7982] Martinsen、P.、Reddy、T.、Wing、D。、およびV. Singh、「NAT（STUN）のセッショントラバーサルユーティリティを使用したラウンドトリップ時間とフラクショナルロスの測定」、RFC 7982、DOI 10.17487 / RFC7982、2016年9月、<https://www.rfc-editor.org/info/rfc7982>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8200] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.",
      "ja": "[RFC8200] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https://www.rfc-editor.org / info / rfc8200>。"
    },
    {
      "indent": 3,
      "text": "[RFC8305] Schinazi, D. and T. Pauly, \"Happy Eyeballs Version 2: Better Connectivity Using Concurrency\", RFC 8305, DOI 10.17487/RFC8305, December 2017, <https://www.rfc-editor.org/info/rfc8305>.",
      "ja": "[RFC8305] Schinazi、D。およびT. Pauly、「Happy Eyeballsバージョン2：並行性を使用した接続の改善」、RFC 8305、DOI 10.17487 / RFC8305、2017年12月、<https://www.rfc-editor.org/info/ rfc8305>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 3,
      "text": "[RFC8489] Petit-Huguenin, M., Salgueiro, G., Rosenberg, J., Wing, D., Mahy, R., and P. Matthews, \"Session Traversal Utilities for NAT (STUN)\", RFC 8489, DOI 10.17487/RFC8489, February 2020, <https://www.rfc-editor.org/info/rfc8489>.",
      "ja": "[RFC8489] Petit-Huguenin、M.、Salgueiro、G.、Rosenberg、J.、Wing、D.、Mahy、R。、およびP. Matthews、「NAT（STUN）のセッショントラバースユーティリティ」、RFC 8489、DOI 10.17487 / RFC8489、2020年2月、<https://www.rfc-editor.org/info/rfc8489>。"
    },
    {
      "indent": 0,
      "text": "26.2. Informative References",
      "section_title": true,
      "ja": "26.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[FRAG-FRAGILE] Bonica, R., Baker, F., Huston, G., Hinden, R., Troan, O., and F. Gont, \"IP Fragmentation Considered Fragile\", Work in Progress, Internet-Draft, draft-ietf-intarea-frag-fragile-17, 30 September 2019, <https://tools.ietf.org/html/draft-ietf-intarea-frag-fragile-17>.",
      "ja": "[FRAG-FRAGILE] Bonica、R.、Baker、F.、Huston、G.、Hinden、R.、Troan、O.、and F. Gont、 \"IP Fragmentation考慮された壊れやすい\"、Work in Progress、Internet-Draft、 draft-ietf-intarea-frag-fragile-17、2019年9月30日、<https://tools.ietf.org/html/draft-ietf-intarea-frag-fragile-17>。"
    },
    {
      "indent": 3,
      "text": "[FRAG-HARMFUL] Kent, C. and J. Mogul, \"Fragmentation Considered Harmful\", December 1987, <https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf>.",
      "ja": "[FRAG-HARMFUL] Kent、C.、J。Mogul、「有害と考えられる断片化」、1987年12月、<https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[MTU-DATAGRAM] Fairhurst, G., Jones, T., Tuexen, M., Ruengeler, I., and T. Voelker, \"Packetization Layer Path MTU Discovery for Datagram Transports\", Work in Progress, Internet-Draft, draft-ietf-tsvwg-datagram-plpmtud-14, 12 February 2020, <https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-plpmtud-14>.",
      "ja": "[MTU-DATAGRAM] Fairhurst、G.、Jones、T.、Tuexen、M.、Ruengeler、I。、およびT. Voelker、「データグラムトランスポートのパケット化レイヤーパスMTUディスカバリー」、Work in Progress、Internet-Draft、ドラフト -ietf-tsvwg-datagram-plpmtud-14、2020年2月12日、<https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-plpmtud-14>。"
    },
    {
      "indent": 3,
      "text": "[MTU-STUN] Petit-Huguenin, M., Salgueiro, G., and F. Garrido, \"Packetization Layer Path MTU Discovery (PLMTUD) For UDP Transports Using Session Traversal Utilities for NAT (STUN)\", Work in Progress, Internet-Draft, draft-ietf-tram-stun-pmtud-15, 17 December 2019, <https://tools.ietf.org/html/draft-ietf-tram-stun-pmtud-15>.",
      "ja": "[MTU-STUN] Petit-Huguenin、M.、Salgueiro、G。、およびF. Garrido、「NAT（STUN）のセッショントラバーサルユーティリティを使用したUDPトランスポートのパケット化レイヤーパスMTUディスカバリー（PLMTUD）」、Work in Progress、インターネット -ドラフト、draft-ietf-tram-stun-pmtud-15、2019年12月17日、<https://tools.ietf.org/html/draft-ietf-tram-stun-pmtud-15>"
    },
    {
      "indent": 3,
      "text": "[PORT-NUMBERS] IANA, \"Service Name and Transport Protocol Port Number Registry\", <https://www.iana.org/assignments/port-numbers>.",
      "ja": "[PORT-NUMBERS] IANA、「サービス名およびトランスポートプロトコルポート番号レジストリ」、<https://www.iana.org/assignments/port-numbers>。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <https://www.rfc-editor.org/info/rfc791>.",
      "ja": "[RFC0791]ポステル、J。、「インターネットプロトコル」、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<https://www.rfc-editor.org/info/rfc791>。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, DOI 10.17487/RFC1191, November 1990, <https://www.rfc-editor.org/info/rfc1191>.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU discovery」、RFC 1191、DOI 10.17487 / RFC1191、1990年11月、<https://www.rfc-editor.org/info/rfc1191>。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G. J., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, <https://www.rfc-editor.org/info/rfc1918>.",
      "ja": "[RFC1918] Rekhter、Y.、Moskowitz、B.、Karrenberg、D.、de Groot、GJ、およびE. Lear、「プライベートインターネットのアドレス割り当て」、BCP 5、RFC 1918、DOI 10.17487 / RFC1918、1996年2月、 <https://www.rfc-editor.org/info/rfc1918>。"
    },
    {
      "indent": 3,
      "text": "[RFC1928] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, \"SOCKS Protocol Version 5\", RFC 1928, DOI 10.17487/RFC1928, March 1996, <https://www.rfc-editor.org/info/rfc1928>.",
      "ja": "[RFC1928]リーチ、M。、ガニス、M。、リー、Y。、クリス、R。、コブラス、D。、およびL.ジョーンズ、「SOCKSプロトコルバージョン5」、RFC 1928、DOI 10.17487 / RFC1928、1996年3月 、<https://www.rfc-editor.org/info/rfc1928>。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261]ローゼンバーグ、J。、シュルズリンネ、H。、カマリロ、G。、ジョンストン、A。、ピーターソン、J。、スパークス、R。、ハンドリー、M。、およびE.スクーラー、「SIP：Session Initiation Protocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L., Ed. and IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, DOI 10.17487/RFC3424, November 2002, <https://www.rfc-editor.org/info/rfc3424>.",
      "ja": "[RFC3424] Daigle、L.、Ed。 およびIAB、「ネットワークアドレス変換全体にわたる一方的な自己アドレス修正（UNSAF）に関するIABの考慮事項」、RFC 3424、DOI 10.17487 / RFC3424、2002年11月、<https://www.rfc-editor.org/info/rfc3424>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <https://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーションのトランスポートプロトコル」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <https://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「セキュアリアルタイムトランスポートプロトコル（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月 2004、<https://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] Eastlake 3rd、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム要件」、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<https：//www.rfc-editor .org / info / rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, DOI 10.17487/RFC4302, December 2005, <https://www.rfc-editor.org/info/rfc4302>.",
      "ja": "[RFC4302]ケント、S。、「IP認証ヘッダー」、RFC 4302、DOI 10.17487 / RFC4302、2005年12月、<https://www.rfc-editor.org/info/rfc4302>。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, DOI 10.17487/RFC4303, December 2005, <https://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[RFC4303]ケント、S。、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、<https://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F., Ed. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, <https://www.rfc-editor.org/info/rfc4787>.",
      "ja": "[RFC4787]オーデット、F。、エド。 およびC.ジェニングス、「ユニキャストUDPのネットワークアドレス変換（NAT）動作要件」、BCP 127、RFC 4787、DOI 10.17487 / RFC4787、2007年1月、<https://www.rfc-editor.org/info/rfc4787> 。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <https://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821] Mathis、M。、およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<https://www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC5128] Srisuresh, P., Ford, B., and D. Kegel, \"State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)\", RFC 5128, DOI 10.17487/RFC5128, March 2008, <https://www.rfc-editor.org/info/rfc5128>.",
      "ja": "[RFC5128] Srisuresh、P.、Ford、B。、およびD. Kegel、「ネットワークアドレストランスレータ（NAT）を介したピアツーピア（P2P）通信の状態」、RFC 5128、DOI 10.17487 / RFC5128、2008年3月、 <https://www.rfc-editor.org/info/rfc5128>。"
    },
    {
      "indent": 3,
      "text": "[RFC5482] Eggert, L. and F. Gont, \"TCP User Timeout Option\", RFC 5482, DOI 10.17487/RFC5482, March 2009, <https://www.rfc-editor.org/info/rfc5482>.",
      "ja": "[RFC5482] Eggert、L。およびF. Gont、「TCPユーザータイムアウトオプション」、RFC 5482、DOI 10.17487 / RFC5482、2009年3月、<https://www.rfc-editor.org/info/rfc5482>。"
    },
    {
      "indent": 3,
      "text": "[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", RFC 5766, DOI 10.17487/RFC5766, April 2010, <https://www.rfc-editor.org/info/rfc5766>.",
      "ja": "[RFC5766] Mahy、R.、Matthews、P。、およびJ. Rosenberg、「NAT（TURN）の周りのリレーを使用したトラバーサル：NAT（STUN）のセッショントラバーサルユーティリティへのリレー拡張」、RFC 5766、DOI 10.17487 / RFC5766、4月 2010、<https://www.rfc-editor.org/info/rfc5766>。"
    },
    {
      "indent": 3,
      "text": "[RFC5925] Touch, J., Mankin, A., and R. Bonica, \"The TCP Authentication Option\", RFC 5925, DOI 10.17487/RFC5925, June 2010, <https://www.rfc-editor.org/info/rfc5925>.",
      "ja": "[RFC5925] Touch、J.、Mankin、A。、およびR. Bonica、「TCP認証オプション」、RFC 5925、DOI 10.17487 / RFC5925、2010年6月、<https://www.rfc-editor.org/info / rfc5925>。"
    },
    {
      "indent": 3,
      "text": "[RFC5928] Petit-Huguenin, M., \"Traversal Using Relays around NAT (TURN) Resolution Mechanism\", RFC 5928, DOI 10.17487/RFC5928, August 2010, <https://www.rfc-editor.org/info/rfc5928>.",
      "ja": "[RFC5928] Petit-Huguenin、M。、「NAT（TURN）解決メカニズムの周りのリレーを使用したトラバーサル」、RFC 5928、DOI 10.17487 / RFC5928、2010年8月、<https://www.rfc-editor.org/info/rfc5928 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6056] Larsen, M. and F. Gont, \"Recommendations for Transport-Protocol Port Randomization\", BCP 156, RFC 6056, DOI 10.17487/RFC6056, January 2011, <https://www.rfc-editor.org/info/rfc6056>.",
      "ja": "[RFC6056] Larsen、M。およびF. Gont、「Transport-Protocol Port Randomizationの推奨事項」、BCP 156、RFC 6056、DOI 10.17487 / RFC6056、2011年1月、<https://www.rfc-editor.org/info / rfc6056>。"
    },
    {
      "indent": 3,
      "text": "[RFC6062] Perreault, S., Ed. and J. Rosenberg, \"Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations\", RFC 6062, DOI 10.17487/RFC6062, November 2010, <https://www.rfc-editor.org/info/rfc6062>.",
      "ja": "[RFC6062]ペロー、S。、エド。 およびJ. Rosenberg、「TCP割り当てのためのNAT（TURN）拡張機能の周りのリレーの使用」、RFC 6062、DOI 10.17487 / RFC6062、2010年11月、<https://www.rfc-editor.org/info/rfc6062>。"
    },
    {
      "indent": 3,
      "text": "[RFC6156] Camarillo, G., Novo, O., and S. Perreault, Ed., \"Traversal Using Relays around NAT (TURN) Extension for IPv6\", RFC 6156, DOI 10.17487/RFC6156, April 2011, <https://www.rfc-editor.org/info/rfc6156>.",
      "ja": "[RFC6156] Camarillo、G.、Novo、O。、およびS. Perreault、Ed。、「IPv6のNAT（TURN）拡張機能の周りのリレーを使用したトラバーサル」、RFC 6156、DOI 10.17487 / RFC6156、2011年4月、<https：/ /www.rfc-editor.org/info/rfc6156>。"
    },
    {
      "indent": 3,
      "text": "[RFC6263] Marjou, X. and A. Sollaud, \"Application Mechanism for Keeping Alive the NAT Mappings Associated with RTP / RTP Control Protocol (RTCP) Flows\", RFC 6263, DOI 10.17487/RFC6263, June 2011, <https://www.rfc-editor.org/info/rfc6263>.",
      "ja": "[RFC6263] Marjou、X.およびA. Sollaud、「RTP / RTP制御プロトコル（RTCP）フローに関連付けられたNATマッピングを維持するためのアプリケーションメカニズム」、RFC 6263、DOI 10.17487 / RFC6263、2011年6月、<https：// www.rfc-editor.org/info/rfc6263>。"
    },
    {
      "indent": 3,
      "text": "[RFC7413] Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP Fast Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014, <https://www.rfc-editor.org/info/rfc7413>.",
      "ja": "[RFC7413] Cheng、Y.、Chu、J.、Radhakrishnan、S。、およびA.Jain、「TCP Fast Open」、RFC 7413、DOI 10.17487 / RFC7413、2014年12月、<https：//www.rfc-editor .org / info / rfc7413>。"
    },
    {
      "indent": 3,
      "text": "[RFC7478] Holmberg, C., Hakansson, S., and G. Eriksson, \"Web Real-Time Communication Use Cases and Requirements\", RFC 7478, DOI 10.17487/RFC7478, March 2015, <https://www.rfc-editor.org/info/rfc7478>.",
      "ja": "[RFC7478] Holmberg、C.、Hakansson、S。、およびG. Eriksson、「Webリアルタイム通信の使用例と要件」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、<https：//www.rfc- editor.org/info/rfc7478>。"
    },
    {
      "indent": 3,
      "text": "[RFC7635] Reddy, T., Patil, P., Ravindranath, R., and J. Uberti, \"Session Traversal Utilities for NAT (STUN) Extension for Third-Party Authorization\", RFC 7635, DOI 10.17487/RFC7635, August 2015, <https://www.rfc-editor.org/info/rfc7635>.",
      "ja": "[RFC7635] Reddy、T.、Patil、P.、Ravindranath、R。、およびJ. Uberti、「サードパーティ認証のためのNAT（STUN）拡張のためのセッショントラバースユーティリティ」、RFC 7635、DOI 10.17487 / RFC7635、2015年8月 、<https://www.rfc-editor.org/info/rfc7635>。"
    },
    {
      "indent": 3,
      "text": "[RFC7657] Black, D., Ed. and P. Jones, \"Differentiated Services (Diffserv) and Real-Time Communication\", RFC 7657, DOI 10.17487/RFC7657, November 2015, <https://www.rfc-editor.org/info/rfc7657>.",
      "ja": "[RFC7657]ブラック、D。、エド。 およびP.ジョーンズ、「Differentiated Services（Diffserv）and Real-Time Communication」、RFC 7657、DOI 10.17487 / RFC7657、2015年11月、<https://www.rfc-editor.org/info/rfc7657>。"
    },
    {
      "indent": 3,
      "text": "[RFC7983] Petit-Huguenin, M. and G. Salgueiro, \"Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)\", RFC 7983, DOI 10.17487/RFC7983, September 2016, <https://www.rfc-editor.org/info/rfc7983>.",
      "ja": "[RFC7983] Petit-Huguenin、M。、およびG. Salgueiro、「Datagram Transport Layer Security（DTLS）のセキュアリアルタイムトランスポートプロトコル（SRTP）拡張のための多重化スキームの更新」、RFC 7983、DOI 10.17487 / RFC7983、2016年9月、 <https://www.rfc-editor.org/info/rfc7983>。"
    },
    {
      "indent": 3,
      "text": "[RFC8155] Patil, P., Reddy, T., and D. Wing, \"Traversal Using Relays around NAT (TURN) Server Auto Discovery\", RFC 8155, DOI 10.17487/RFC8155, April 2017, <https://www.rfc-editor.org/info/rfc8155>.",
      "ja": "[RFC8155] Patil、P.、Reddy、T。、およびD. Wing、「Traversal Using Relays around NAT（TURN）Server Auto Discovery」、RFC 8155、DOI 10.17487 / RFC8155、2017年4月、<https：// www。 rfc-editor.org/info/rfc8155>。"
    },
    {
      "indent": 3,
      "text": "[RFC8311] Black, D., \"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation\", RFC 8311, DOI 10.17487/RFC8311, January 2018, <https://www.rfc-editor.org/info/rfc8311>.",
      "ja": "[RFC8311]ブラック、D。、「明示的輻輳通知（ECN）実験の制限の緩和」、RFC 8311、DOI 10.17487 / RFC8311、2018年1月、<https://www.rfc-editor.org/info/rfc8311>。"
    },
    {
      "indent": 3,
      "text": "[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal\", RFC 8445, DOI 10.17487/RFC8445, July 2018, <https://www.rfc-editor.org/info/rfc8445>.",
      "ja": "[RFC8445] Keranen、A.、Holmberg、C。、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：ネットワークアドレス変換（NAT）トラバーサルのプロトコル」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>。"
    },
    {
      "indent": 3,
      "text": "[SDP-ICE] Petit-Huguenin, M., Nandakumar, S., Holmberg, C., Keranen, A., and R. Shpount, \"Session Description Protocol (SDP) Offer/Answer procedures for Interactive Connectivity Establishment (ICE)\", Work in Progress, Internet-Draft, draft-ietf-mmusic-ice-sip-sdp-39, 13 August 2019, <https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-39>.",
      "ja": "[SDP-ICE] Petit-Huguenin、M.、Nandakumar、S.、Holmberg、C.、Kerenen、A。、およびR. Shpount、「Interactive Connectivity Establishment（ICE）のセッション記述プロトコル（SDP）オファー/アンサー手順」 \"、Work in Progress、Internet-Draft、draft-ietf-mmusic-ice-sip-sdp-39、2019年8月13日、<https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip -sdp-39>。"
    },
    {
      "indent": 3,
      "text": "[SEC-WEBRTC] Rescorla, E., \"Security Considerations for WebRTC\", Work in Progress, Internet-Draft, draft-ietf-rtcweb-security-12, 5 July 2019, <https://tools.ietf.org/html/draft-ietf-rtcweb-security-12>.",
      "ja": "[SEC-WEBRTC] Rescorla、E。、「WebRTCのセキュリティに関する考慮事項」、Work in Progress、インターネットドラフト、draft-ietf-rtcweb-security-12、2019年7月5日、<https://tools.ietf.org/ html / draft-ietf-rtcweb-security-12>。"
    },
    {
      "indent": 3,
      "text": "[TCP-EXT] Ford, A., Raiciu, C., Handley, M., Bonaventure, O., and C. Paasch, \"TCP Extensions for Multipath Operation with Multiple Addresses\", Work in Progress, Internet-Draft, draft-ietf-mptcp-rfc6824bis-18, 8 June 2019, <https://tools.ietf.org/html/draft-ietf-mptcp-rfc6824bis-18>.",
      "ja": "[TCP-EXT] Ford、A.、Raiciu、C.、Handley、M.、Bonaventure、O。、およびC. Paasch、「複数アドレスによるマルチパス操作のためのTCP拡張」、Work in Progress、Internet-Draft、ドラフト -ietf-mptcp-rfc6824bis-18、2019年6月8日、<https://tools.ietf.org/html/draft-ietf-mptcp-rfc6824bis-18>。"
    },
    {
      "indent": 3,
      "text": "[UDP-OPT] Touch, J., \"Transport Options for UDP\", Work in Progress, Internet-Draft, draft-ietf-tsvwg-udp-options-08, 12 September 2019, <https://tools.ietf.org/html/draft-ietf-tsvwg-udp-options-08>.",
      "ja": "[UDP-OPT] Touch、J。、「UDPのトランスポートオプション」、Work in Progress、Internet-Draft、draft-ietf-tsvwg-udp-options-08、2019年9月12日、<https：//tools.ietf。 org / html / draft-ietf-tsvwg-udp-options-08>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Most of the text in this note comes from the original TURN specification, [RFC5766]. The authors would like to thank Rohan Mahy, coauthor of the original TURN specification, and everyone who had contributed to that document. The authors would also like to acknowledge that this document inherits material from [RFC6156].",
      "ja": "このノートのテキストのほとんどは、元のTURN仕様[RFC5766]からのものです。 著者は、元のTURN仕様の共著者であるRohan Mahyと、その文書に貢献してくれたすべての人に感謝します。 また、著者は、このドキュメントが[RFC6156]から材料を継承することを認めたいです。"
    },
    {
      "indent": 3,
      "text": "Thanks to Justin Uberti, Pal Martinsen, Oleg Moskalenko, Aijun Wang, and Simon Perreault for their help on the ADDITIONAL-ADDRESS-FAMILY mechanism. The authors would like to thank Gonzalo Salgueiro, Simon Perreault, Jonathan Lennox, Brandon Williams, Karl Stahl, Noriyuki Torii, Nils Ohlmeier, Dan Wing, Vijay Gurbani, Joseph Touch, Justin Uberti, Christopher Wood, Roman Danyliw, Eric Vyncke, Adam Roach, Suresh Krishnan, Mirja Kuehlewind, Benjamin Kaduk, and Oleg Moskalenko for comments and review. The authors would like to thank Marc Petit-Huguenin for his contributions to the text.",
      "ja": "ADDITIONAL-ADDRESS-FAMILYメカニズムの支援をしてくれたJustin Uberti、Pal Martinsen、Oleg Moskalenko、Aijun Wang、およびSimon Perreaultに感謝します。 著者は、ゴンサロ・サルゲイロ、サイモン・ペロー、ジョナサン・レノックス、ブランドン・ウィリアムズ、カール・スタール、鳥居典之、ニルス・オールマイヤー、ダン・ウィング、ヴィジェイ・ガルバーニ、ジョセフ・タッチ、ジャスティン・ウベルティ、クリストファー・ウッド、ローマン・ダニリウ、エリック・ビンケ、アダム・ローチに感謝します 、Suresh Krishnan、Mirja Kuehlewind、Benjamin Kaduk、およびOleg Moskalenkoがコメントとレビューを求めています。 著者は、テキストへの彼の貢献に対してマーク・プティ・フグニンに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Special thanks to Magnus Westerlund for the detailed AD review.",
      "ja": "ADの詳細なレビューについてMagnus Westerlundに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tirumaleswar Reddy (editor) McAfee, Inc. Embassy Golf Link Business Park Bangalore 560071 Karnataka India",
      "ja": "Tirumaleswar Reddy（編集者）McAfee、Inc. Embassy Golf Link Business Parkバンガロール560071カルナータカ州インド"
    },
    {
      "indent": 3,
      "text": "Email: kondtir@gmail.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Alan Johnston (editor) Villanova University Villanova, PA United States of America",
      "ja": "アラン・ジョンストン（編集者）ヴィラノバ大学ペンシルベニア州ヴィラノバアメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: alan.b.johnston@gmail.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Philip Matthews Alcatel-Lucent 600 March Road Ottawa Ontario Canada",
      "ja": "フィリップマシューズアルカテル-ルーセント600 March Roadオタワオンタリオ州カナダ"
    },
    {
      "indent": 3,
      "text": "Email: philip_matthews@magma.ca",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg jdrosen.net Edison, NJ United States of America",
      "ja": "ジョナサンローゼンバーグjdrosen.netニュージャージー州エジソンアメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: jdrosen@jdrosen.net\nURI:   http://www.jdrosen.net",
      "raw": true
    }
  ]
}