{
  "title": {
    "text": "RFC 8681 - Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes for FECFRAME",
    "ja": "RFC 8681 - FECFRAMEのスライディングウィンドウランダム線形コード（RLC）前方消去補正（FEC）スキーム"
  },
  "number": 8681,
  "created_at": "2020-03-10 13:34:45.529804+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           V. Roca\nRequest for Comments: 8681                                      B. Teibi\nCategory: Standards Track                                          INRIA\nISSN: 2070-1721                                             January 2020",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes for FECFRAME",
      "ja": "FECFRAMEのスライディングウィンドウランダム線形コード（RLC）前方消去補正（FEC）スキーム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes two fully specified Forward Erasure Correction (FEC) Schemes for Sliding Window Random Linear Codes (RLC), one for RLC over the Galois Field (a.k.a., Finite Field) GF(2), a second one for RLC over the Galois Field GF(2^(8)), each time with the possibility of controlling the code density. They can protect arbitrary media streams along the lines defined by FECFRAME extended to Sliding Window FEC Codes. These Sliding Window FEC Codes rely on an encoding window that slides over the source symbols, generating new repair symbols whenever needed. Compared to block FEC codes, these Sliding Window FEC Codes offer key advantages with real-time flows in terms of reduced FEC-related latency while often providing improved packet erasure recovery capabilities.",
      "ja": "このドキュメントでは、スライディングウィンドウランダム線形コード（RLC）用の完全に指定された2つの前方消去補正（FEC）スキーム、ガロア体上のRLC（別名、有限体）GF（2）、ガロア体上のRLC用 GF（2 ^（8））、毎回コード密度を制御する可能性。 スライディングウィンドウFECコードに拡張されたFECFRAMEで定義されたラインに沿った任意のメディアストリームを保護できます。 これらのスライディングウィンドウFECコードは、ソースシンボル上をスライドするエンコードウィンドウに依存しており、必要に応じて新しい修復シンボルを生成します。 ブロックFECコードと比較して、これらのスライディングウィンドウFECコードは、多くの場合パケット消去回復機能を改善しながら、FEC関連の遅延を削減するという点で、リアルタイムフローで重要な利点を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8681.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8681で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 1.1. Limits of Block Codes with Real-Time Flows 1.2. Lower Latency and Better Protection of Real-Time Flows with the Sliding Window RLC Codes 1.3. Small Transmission Overheads with the Sliding Window RLC FEC Scheme 1.4. Document Organization 2. Definitions and Abbreviations 3. Common Procedures 3.1. Codec Parameters 3.2. ADU, ADUI, and Source Symbols Mappings 3.3. Encoding Window Management 3.4. Source Symbol Identification 3.5. Pseudorandom Number Generator (PRNG) 3.6. Coding Coefficients Generation Function 3.7. Finite Field Operations 3.7.1. Finite Field Definitions 3.7.2. Linear Combination of Source Symbol Computation 4. Sliding Window RLC FEC Scheme over GF(2^(8)) for Arbitrary Packet Flows 4.1. Formats and Codes 4.1.1. FEC Framework Configuration Information 4.1.2. Explicit Source FEC Payload ID 4.1.3. Repair FEC Payload ID 4.2. Procedures 5. Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows 5.1. Formats and Codes 5.1.1. FEC Framework Configuration Information 5.1.2. Explicit Source FEC Payload ID 5.1.3. Repair FEC Payload ID 5.2. Procedures 6. FEC Code Specification 6.1. Encoding Side 6.2. Decoding Side 7. Security Considerations 7.1. Attacks Against the Data Flow 7.1.1. Access to Confidential Content 7.1.2. Content Corruption 7.2. Attacks Against the FEC Parameters 7.3. When Several Source Flows are to be Protected Together 7.4. Baseline Secure FEC Framework Operation 7.5. Additional Security Considerations for Numerical Computations 8. Operations and Management Considerations 8.1. Operational Recommendations: Finite Field GF(2) Versus GF(2^(8)) 8.2. Operational Recommendations: Coding Coefficients Density Threshold 9. IANA Considerations 10. References 10.1. Normative References 10.2. Informative References Appendix A. TinyMT32 Validation Criteria (Normative) Appendix B. Assessing the PRNG Adequacy (Informational) Appendix C. Possible Parameter Derivation (Informational) C.1. Case of a CBR Real-Time Flow C.2. Other Types of Real-Time Flow C.3. Case of a Non-Real-Time Flow Appendix D. Decoding Beyond Maximum Latency Optimization (Informational) Acknowledgments Authors' Addresses",
      "ja": "1. はじめに1.1。リアルタイムフローを使用したブロックコードの制限1.2。スライディングウィンドウRLCコード1.3を使用して、リアルタイムフローの遅延を短縮し、保護を強化します。スライディングウィンドウRLC FECスキームによる小さな伝送オーバーヘッド1.4。文書構成2.定義と略語3.共通手順3.1。コーデックパラメータ3.2。 ADU、ADUI、およびソースシンボルマッピング3.3。エンコードウィンドウ管理3.4。ソースシンボルの識別3.5。疑似乱数ジェネレーター（PRNG）3.6。コーディング係数生成関数3.7。有限フィールド操作3.7.1。有限フィールド定義3.7.2。ソースシンボル計算の線形結合4.任意のパケットフローのGF（2 ^（8））上のスライディングウィンドウRLC FECスキーム4.1。フォーマットとコード4.1.1。 FECフレームワーク設定情報4.1.2。明示的なソースFECペイロードID 4.1.3。 FECペイロードID 4.2を修復します。手順5.任意のパケットフローのGF（2）上のスライディングウィンドウRLC FECスキーム5.1。フォーマットとコード5.1.1。 FECフレームワーク設定情報5.1.2。明示的なソースFECペイロードID 5.1.3。 FECペイロードID 5.2を修復します。手順6. FECコード仕様6.1。エンコード側6.2。デコード側7.セキュリティに関する考慮事項7.1。データフローに対する攻撃7.1.1。機密コンテンツへのアクセス7.1.2。コンテンツの破損7.2。 FECパラメーターに対する攻撃7.3。複数のソースフローをまとめて保護する場合7.4。ベースラインセキュアFECフレームワーク操作7.5。数値計算の追加のセキュリティに関する考慮事項8.運用および管理に関する考慮事項8.1。運用上の推奨事項：有限フィールドGF（2）対GF（2 ^（8））8.2。運用上の推奨事項：コーディング係数密度しきい値9. IANAの考慮事項10.参照10.1。規範的参考文献10.2。参考情報付録A. TinyMT32検証基準（規範）付録B. PRNGの妥当性の評価（情報）付録C.可能なパラメーターの導出（情報）C.1。 CBRリアルタイムフローのケースC.2。他の種類のリアルタイムフローC.3。非リアルタイムフローの場合付録D.最大遅延最適化を超えるデコード（情報）謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Application-Level Forward Erasure Correction (AL-FEC) codes, or simply FEC codes, are a key element of communication systems. They are used to recover from packet losses (or erasures) during content delivery sessions to a potentially large number of receivers (multicast/broadcast transmissions). This is the case with the File Delivery over Unidirectional Transport (FLUTE)/Asynchronous Layered Coding (ALC) protocol [RFC6726] when used for reliable file transfers over lossy networks, and the FECFRAME protocol [RFC6363] when used for reliable continuous media transfers over lossy networks.",
      "ja": "アプリケーションレベルの前方消去訂正（AL-FEC）コード、または単にFECコードは、通信システムの重要な要素です。 潜在的に多数の受信者へのコンテンツ配信セッション中のパケット損失（または消去）から回復するために使用されます（マルチキャスト/ブロードキャスト送信）。 これは、損失の多いネットワークを介した信頼性の高いファイル転送に使用される単方向トランスポート（FLUTE）/非同期レイヤコーディング（ALC）プロトコル[RFC6726]上のファイル配信と、信頼性の高い連続メディア転送に使用されるFECFRAMEプロトコル[RFC6363]の場合です 損失の多いネットワーク。"
    },
    {
      "indent": 3,
      "text": "The present document only focuses on the FECFRAME protocol, which is used in multicast/broadcast delivery mode, particularly for content that features stringent real-time constraints: each source packet has a maximum validity period after which it will not be considered by the destination application.",
      "ja": "現在のドキュメントは、特に厳しいリアルタイム制約を特徴とするコンテンツのために、マルチキャスト/ブロードキャスト配信モードで使用されるFECFRAMプロトコルのみに焦点を当てています。各ソースパケットには、宛先アプリケーションによって考慮されない最大有効期間があります。 。"
    },
    {
      "indent": 0,
      "text": "1.1. Limits of Block Codes with Real-Time Flows",
      "section_title": true,
      "ja": "1.1. リアルタイムフローを使用したブロックコードの制限"
    },
    {
      "indent": 3,
      "text": "With FECFRAME, there is a single FEC encoding point (either an end host/server (source) or a middlebox) and a single FEC decoding point per receiver (either an end host (receiver) or middlebox). In this context, currently standardized AL-FEC codes for FECFRAME like Reed-Solomon [RFC6865], LDPC-Staircase [RFC6816], or Raptor/RaptorQ [RFC6681], are all linear block codes: they require the data flow to be segmented into blocks of a predefined maximum size.",
      "ja": "FECFRAMEには、単一のFECエンコードポイント（エンドホスト/サーバー（ソース）またはミドルボックス）と、レシーバーごとに1つのFECデコードポイント（エンドホスト（レシーバ）またはミドルボックス）があります。 これに関連して、リードソロモン[RFC6865]、LDPC-Staircase [RFC6816]、またはRaptor / RaptorQ [RFC6681]のようなFECFRAMEの現在標準化されているAL-FECコードは、すべて線形ブロックコードです。 定義済みの最大サイズのブロック。"
    },
    {
      "indent": 3,
      "text": "To define this block size, it is required to find an appropriate balance between robustness and decoding latency: the larger the block size, the higher the robustness (e.g., in case of long packet erasure bursts), but also the higher the maximum decoding latency (i.e., the maximum time required to recover a lost (erased) packet thanks to FEC protection). Therefore, with a multicast/broadcast session where different receivers experience different packet loss rates, the block size should be chosen by considering the worst communication conditions one wants to support, but without exceeding the desired maximum decoding latency. This choice then impacts the FEC-related latency of all receivers, even those experiencing a good communication quality, since no FEC encoding can happen until all the source data of the block is available at the sender, which directly depends on the block size.",
      "ja": "このブロックサイズを定義するには、堅牢性とデコードレイテンシの適切なバランスを見つける必要があります。ブロックサイズが大きいほど、堅牢性は高くなります（たとえば、パケット消去バーストが長い場合）が、最大デコードレイテンシも高くなります。 （つまり、FEC保護のおかげで失われた（消去された）パケットを回復するのに必要な最大時間）。 したがって、異なる受信者が異なるパケット損失率を経験するマルチキャスト/ブロードキャストセッションでは、ブロックサイズは、サポートしたい最悪の通信条件を考慮して選択する必要がありますが、目的の最大デコードレイテンシを超えることはありません。 この選択は、ブロックサイズに直接依存するブロックのすべてのソースデータが送信側で利用可能になるまでFECエンコーディングが発生しないため、良好な通信品質を経験している受信者でも、すべての受信者のFEC関連のレイテンシに影響を与えます。"
    },
    {
      "indent": 0,
      "text": "1.2. Lower Latency and Better Protection of Real-Time Flows with the Sliding Window RLC Codes",
      "ja": "1.2. スライディングウィンドウRLCコードを使用した、リアルタイムフローの低遅延とより優れた保護"
    },
    {
      "indent": 3,
      "text": "This document introduces two fully specified FEC schemes that do not follow the block code approach: the Sliding Window Random Linear Codes (RLC) over either Galois Fields (a.k.a., Finite Fields) GF(2) (the \"binary case\") or GF(2^(8)), each time with the possibility of controlling the code density. These FEC schemes are used to protect arbitrary media streams along the lines defined by FECFRAME extended to Sliding Window FEC Codes [RFC8680]. These FEC schemes and, more generally, Sliding Window FEC Codes are recommended, for instance, with media that feature real-time constraints sent within a multicast/broadcast session [Roca17].",
      "ja": "このドキュメントでは、ブロックコードアプローチに従わない2つの完全に指定されたFECスキームを紹介します。ガロア体（別名、有限体）GF（2）（「バイナリケース」）またはGF（ 2 ^（8））、毎回コード密度を制御する可能性。 これらのFECスキームは、スライディングウィンドウFECコード[RFC8680]に拡張されたFECFRAMEによって定義されたラインに沿った任意のメディアストリームを保護するために使用されます。 これらのFECスキーム、より一般的には、たとえば、マルチキャスト/ブロードキャストセッション[Roca17]内で送信されるリアルタイムの制約を特徴とするメディアでは、スライディングウィンドウFECコードが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The RLC codes belong to the broad class of Sliding Window AL-FEC Codes (a.k.a., convolutional codes) [RFC8406]. The encoding process is based on an encoding window that slides over the set of source packets (in fact source symbols as we will see in Section 3.2), this window being either of fixed size or variable size (a.k.a., an elastic window). Repair symbols are generated on-the-fly, by computing a random linear combination of the source symbols present in the current encoding window, and passed to the transport layer.",
      "ja": "RLCコードは、広範なスライディングウィンドウAL-FECコード（別名、畳み込みコード）[RFC8406]に属します。 エンコードプロセスは、ソースパケットのセット（実際にはセクション3.2で説明するソースシンボル）の上をスライドするエンコードウィンドウに基づいています。このウィンドウは、固定サイズまたは可変サイズのいずれかです（別名、弾性ウィンドウ）。 修復シンボルは、現在のエンコードウィンドウに存在するソースシンボルのランダムな線形結合を計算することにより、オンザフライで生成され、トランスポートレイヤーに渡されます。"
    },
    {
      "indent": 3,
      "text": "At the receiver, a linear system is managed from the set of received source and repair packets. New variables (representing source symbols) and equations (representing the linear combination carried by each repair symbol received) are added upon receiving new packets. Variables and the equations they are involved in are removed when they are too old with respect to their validity period (real-time constraints). Lost source symbols are then recovered thanks to this linear system whenever its rank permits to solve it (at least partially).",
      "ja": "受信側では、受信したソースパケットと修復パケットのセットから線形システムが管理されます。 新しいパケットを受信すると、新しい変数（ソースシンボルを表す）と方程式（受信した各修復シンボルが運ぶ線形結合を表す）が追加されます。 それらが関係している変数と方程式は、それらの有効期間（リアルタイム制約）に関して古すぎる場合に削除されます。 失われたソースシンボルは、ランクが（少なくとも部分的に）解決できる場合、この線形システムのおかげで回復されます。"
    },
    {
      "indent": 3,
      "text": "The protection of any multicast/broadcast session needs to be dimensioned by considering the worst communication conditions one wants to support. This is also true with RLC (more generally, any sliding window) code. However, the receivers experiencing a good to medium communication quality will observe a reduced FEC-related latency compared to block codes [Roca17] since an isolated lost source packet is quickly recovered with the following repair packet. On the opposite, with a block code, recovering an isolated lost source packet always requires waiting for the first repair packet to arrive after the end of the block. Additionally, under certain situations (e.g., with a limited FEC-related latency budget and with constant bitrate transmissions after FECFRAME encoding), Sliding Window Codes can more efficiently achieve a target transmission quality (e.g., measured by the residual loss after FEC decoding) by sending fewer repair packets (i.e., higher code rate) than block codes.",
      "ja": "マルチキャスト/ブロードキャストセッションの保護は、サポートしたい最悪の通信条件を考慮することで決定する必要があります。 これは、RLC（より一般的には、任意のスライディングウィンドウ）コードにも当てはまります。 ただし、良好な通信品質から中程度の通信品質を経験している受信者は、ブロックコード[Roca17]と比較してFEC関連のレイテンシが減少します。 反対に、ブロックコードでは、孤立した失われたソースパケットを回復するには、ブロックの終了後に最初の修復パケットが到着するのを常に待機する必要があります。 さらに、特定の状況（たとえば、FEC関連の遅延バジェットが制限され、FECFRAMEエンコード後のビットレートが一定の場合）で、スライディングウィンドウコードは、ターゲット送信品質（たとえば、FECデコード後の残留損失で測定）をより効率的に達成できます ブロックコードよりも少ない修復パケット（つまり、高いコードレート）を送信します。"
    },
    {
      "indent": 0,
      "text": "1.3. Small Transmission Overheads with the Sliding Window RLC FEC Scheme",
      "ja": "1.3. スライディングウィンドウRLC FECスキームによる小さな伝送オーバーヘッド"
    },
    {
      "indent": 3,
      "text": "The Sliding Window RLC FEC scheme is designed to limit the packet header overhead. The main requirement is that each repair packet header must enable a receiver to reconstruct the set of source symbols plus the associated coefficients used during the encoding process. In order to minimize packet overhead, the set of source symbols in the encoding window as well as the set of coefficients over GF(2^(m)) (where m is 1 or 8, depending on the FEC scheme) used in the linear combination are not individually listed in the repair packet header. Instead, each FEC Repair Packet header contains:",
      "ja": "スライディングウィンドウRLC FECスキームは、パケットヘッダーのオーバーヘッドを制限するように設計されています。 主な要件は、各修復パケットヘッダーが、受信機がソースシンボルのセットとエンコードプロセス中に使用される関連係数を再構築できるようにする必要があることです。 パケットのオーバーヘッドを最小限に抑えるため、エンコードウィンドウ内のソースシンボルのセットと、GF（2 ^（m））上の係数のセット（mはFECスキームに応じて1または8）が線形で使用されます 組み合わせは、修復パケットヘッダーに個別にリストされません。 代わりに、各FEC Repair Packetヘッダーには次が含まれます。"
    },
    {
      "indent": 3,
      "text": "* the Encoding Symbol Identifier (ESI) of the first source symbol in the encoding window as well as the number of symbols (since this number may vary with a variable size, elastic window). These two pieces of information enable each receiver to reconstruct the set of source symbols considered during encoding, the only constraint being that there cannot be any gap;",
      "ja": "* エンコードウィンドウ内の最初のソースシンボルのエンコードシンボル識別子（ESI）とシンボルの数（この数は可変サイズのエラスティックウィンドウによって異なる場合があるため）。 これらの2つの情報により、各受信機はエンコード中に考慮されたソースシンボルのセットを再構築できます。唯一の制約は、ギャップがないことです。"
    },
    {
      "indent": 3,
      "text": "* the seed and density threshold parameters used by a coding coefficients generation function (Section 3.6). These two pieces of information enable each receiver to generate the same set of coding coefficients over GF(2^(m)) as the sender;",
      "ja": "* コーディング係数生成関数（セクション3.6）で使用されるシードおよび密度のしきい値パラメーター。 これらの2つの情報により、各受信者は送信者と同じGF（2 ^（m））の符号化係数セットを生成できます。"
    },
    {
      "indent": 3,
      "text": "Therefore, no matter the number of source symbols present in the encoding window, each FEC Repair Packet features a fixed 64-bit long header, called Repair FEC Payload ID (Figure 8). Similarly, each FEC Source Packet features a fixed 32-bit long trailer, called Explicit Source FEC Payload ID (Figure 6), that contains the ESI of the first source symbol (Section 3.2).",
      "ja": "したがって、エンコードウィンドウに存在するソースシンボルの数に関係なく、各FEC修復パケットは、修復FECペイロードIDと呼ばれる固定64ビットの長いヘッダーを備えています（図8）。 同様に、各FECソースパケットには、明示的なソースFECペイロードID（図6）と呼ばれる32ビットの固定長トレーラーがあり、最初のソースシンボルのESIが含まれています（セクション3.2）。"
    },
    {
      "indent": 0,
      "text": "1.4. Document Organization",
      "section_title": true,
      "ja": "1.4. 文書構成"
    },
    {
      "indent": 3,
      "text": "This fully-specified FEC scheme follows the structure required by [RFC6363], Section 5.6 (\"FEC Scheme Requirements\"), namely:",
      "ja": "この完全に指定されたFECスキームは、[RFC6363]、セクション5.6（「FECスキームの要件」）で必要な構造、つまり次のとおりです。"
    },
    {
      "indent": 3,
      "text": "3. Procedures: This section describes procedures specific to this FEC scheme, namely: RLC parameters derivation, ADUI and source symbols mapping, pseudorandom number generator, and coding coefficients generation function;",
      "ja": "3. 手順：このセクションでは、このFECスキームに固有の手順について説明します。RLCパラメーターの導出、ADUIおよびソースシンボルのマッピング、疑似乱数ジェネレーター、およびコーディング係数生成関数。"
    },
    {
      "indent": 3,
      "text": "4. Formats and Codes: This section defines the Source FEC Payload ID and Repair FEC Payload ID formats, carrying the signaling information associated to each source or repair symbol. It also defines the FEC Framework Configuration Information (FFCI) carrying signaling information for the session;",
      "ja": "4. フォーマットとコード：このセクションでは、ソースFECペイロードIDと修復FECペイロードIDのフォーマットを定義し、各ソースまたは修復シンボルに関連付けられたシグナリング情報を伝達します。 また、セッションのシグナリング情報を伝送するFECフレームワーク構成情報（FFCI）も定義します。"
    },
    {
      "indent": 3,
      "text": "5. FEC Code Specification: Finally this section provides the code specification.",
      "ja": "5. FECコード仕様：最後に、このセクションではコード仕様を示します。"
    },
    {
      "indent": 0,
      "text": "2. Definitions and Abbreviations",
      "section_title": true,
      "ja": "2. 定義と略語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the following definitions and abbreviations:",
      "ja": "このドキュメントでは、次の定義と略語を使用しています。"
    },
    {
      "indent": 3,
      "text": "a^(b) a to the power of b",
      "ja": "a ^（b）aのb乗"
    },
    {
      "indent": 3,
      "text": "GF(q)  denotes a finite field (also known as the Galois Field) with q\n   elements.  We assume that q = 2^(m) in this document",
      "raw": true
    },
    {
      "indent": 3,
      "text": "m defines the length of the elements in the finite field, in bits. In this document, m is equal to 1 or 8",
      "ja": "mは、有限フィールドの要素の長さをビット単位で定義します。 このドキュメントでは、mは1または8です。"
    },
    {
      "indent": 3,
      "text": "ADU: Application Data Unit",
      "ja": "ADU：アプリケーションデータユニット"
    },
    {
      "indent": 3,
      "text": "ADUI: Application Data Unit Information (includes the F, L and padding fields in addition to the ADU)",
      "ja": "ADUI：アプリケーションデータユニット情報（ADUに加えてF、L、パディングフィールドを含む）"
    },
    {
      "indent": 3,
      "text": "E: size of an encoding symbol (i.e., source or repair symbol), assumed fixed (in bytes)",
      "ja": "E：エンコードシンボル（つまり、ソースまたは修復シンボル）のサイズ、固定と想定（バイト単位）"
    },
    {
      "indent": 3,
      "text": "br_in: transmission bitrate at the input of the FECFRAME sender, assumed fixed (in bits/s)",
      "ja": "br_in：FECFRAME送信側の入力での伝送ビットレート、固定と想定（ビット/秒）"
    },
    {
      "indent": 3,
      "text": "br_out: transmission bitrate at the output of the FECFRAME sender, assumed fixed (in bits/s)",
      "ja": "br_out：FECFRAME送信側の出力での伝送ビットレート、固定と想定（ビット/秒）"
    },
    {
      "indent": 3,
      "text": "max_lat: maximum FEC-related latency within FECFRAME (a decimal number expressed in seconds)",
      "ja": "max_lat：FECFRAME内の最大FEC関連レイテンシ（秒単位で表される10進数）"
    },
    {
      "indent": 3,
      "text": "cr: RLC coding rate, ratio between the total number of source symbols and the total number of source plus repair symbols",
      "ja": "cr：RLCコーディングレート、ソースシンボルの総数とソースと修復シンボルの総数の比率"
    },
    {
      "indent": 3,
      "text": "ew_size: encoding window current size at a sender (in symbols)",
      "ja": "ew_size：送信者でのウィンドウの現在のサイズのエンコード（シンボル単位）"
    },
    {
      "indent": 3,
      "text": "ew_max_size: encoding window maximum size at a sender (in symbols)",
      "ja": "ew_max_size：送信者でのエンコードウィンドウの最大サイズ（シンボル単位）"
    },
    {
      "indent": 3,
      "text": "dw_max_size: decoding window maximum size at a receiver (in symbols)",
      "ja": "dw_max_size：受信側でのデコードウィンドウの最大サイズ（シンボル単位）"
    },
    {
      "indent": 3,
      "text": "ls_max_size: linear system maximum size (or width) at a receiver (in symbols)",
      "ja": "ls_max_size：レシーバーでの線形システムの最大サイズ（または幅）（シンボル単位）"
    },
    {
      "indent": 3,
      "text": "WSR: window size ratio parameter used to derive ew_max_size (encoder) and ls_max_size (decoder).",
      "ja": "WSR：ew_max_size（エンコーダー）およびls_max_size（デコーダー）の導出に使用されるウィンドウサイズ比パラメーター。"
    },
    {
      "indent": 3,
      "text": "PRNG: pseudorandom number generator",
      "ja": "PRNG：擬似乱数ジェネレーター"
    },
    {
      "indent": 3,
      "text": "TinyMT32: PRNG used in this specification.",
      "ja": "TinyMT32：この仕様で使用されるPRNG。"
    },
    {
      "indent": 3,
      "text": "DT: coding coefficients density threshold, an integer between 0 and 15 (inclusive) the controls the fraction of coefficients that are nonzero",
      "ja": "DT：コーディング係数密度のしきい値、0〜15の整数（両端を含む）は、ゼロ以外の係数の割合を制御します"
    },
    {
      "indent": 0,
      "text": "3. Common Procedures",
      "section_title": true,
      "ja": "3. 一般的な手順"
    },
    {
      "indent": 3,
      "text": "This section introduces the procedures that are used by these FEC schemes.",
      "ja": "このセクションでは、これらのFECスキームで使用される手順を紹介します。"
    },
    {
      "indent": 0,
      "text": "3.1. Codec Parameters",
      "section_title": true,
      "ja": "3.1. コーデックパラメータ"
    },
    {
      "indent": 3,
      "text": "A codec implementing the Sliding Window RLC FEC scheme relies on several parameters:",
      "ja": "スライディングウィンドウRLC FECスキームを実装するコーデックは、いくつかのパラメーターに依存しています。"
    },
    {
      "indent": 3,
      "text": "Maximum FEC-related latency budget, max_lat (a decimal number expressed in seconds) with real-time flows: a source ADU flow can have real-time constraints, and therefore any FECFRAME related operation should take place within the validity period of each ADU (Appendix D describes an exception to this rule). When there are multiple flows with different real-time constraints, we consider the most stringent constraints (see item 6 in Section 10.2 of [RFC6363], for recommendations when several flows are globally protected). The maximum FEC-related latency budget, max_lat, accounts for all sources of latency added by FEC encoding (at a sender) and FEC decoding (at a receiver). Other sources of latency (e.g., added by network communications) are out of scope and must be considered separately (said differently, they have already been deducted from max_lat). max_lat can be regarded as the latency budget permitted for all FEC-related operations. This is an input parameter that enables a FECFRAME sender to derive other internal parameters (see Appendix C);",
      "ja": "最大FEC関連レイテンシバジェット、max_lat（秒単位で表される10進数）とリアルタイムフロー：ソースADUフローにはリアルタイム制約があるため、FECFRAME関連の操作は各ADUの有効期間内に実行する必要があります（付録Dでは、この規則の例外について説明しています。リアルタイム制約が異なる複数のフローがある場合、最も厳しい制約を考慮します（複数のフローがグローバルに保護されている場合の推奨事項については、[RFC6363]のセクション10.2の項目6を参照）。 FEC関連の最大レイテンシバジェットmax_latは、FECエンコード（送信側）およびFECデコード（受信側）によって追加されるレイテンシのすべてのソースを考慮します。他の遅延の原因（ネットワーク通信によって追加されるなど）は範囲外であり、個別に考慮する必要があります（別の言い方をすれば、既にmax_latから差し引かれています）。 max_latは、FEC関連のすべての操作に許可される遅延バジェットと見なすことができます。これは、FECFRAME送信者が他の内部パラメーターを導出できるようにする入力パラメーターです（付録Cを参照）。"
    },
    {
      "indent": 3,
      "text": "Encoding window current (resp. maximum) size, ew_size (resp. ew_max_size) (in symbols): at a FECFRAME sender, during FEC encoding, a repair symbol is computed as a linear combination of the ew_size source symbols present in the encoding window. The ew_max_size is the maximum size of this window, while ew_size is the current size. For example, in the common case at session start, upon receiving new source ADUs, the ew_size progressively increases until it reaches its maximum value, ew_max_size. We have:",
      "ja": "エンコードウィンドウの現在の（それぞれ最大の）サイズ、ew_size（それぞれew_max_size）（シンボル単位）：FECFRAME送信側では、FECエンコード中に、エンコードウィンドウに存在するew_sizeソースシンボルの線形結合として修復シンボルが計算されます。 ew_max_sizeはこのウィンドウの最大サイズであり、ew_sizeは現在のサイズです。 たとえば、セッション開始時の一般的なケースでは、新しいソースADUを受信すると、ew_sizeは最大値ew_max_sizeに達するまで徐々に増加します。 我々は持っています："
    },
    {
      "indent": 9,
      "text": "0 < ew_size <= ew_max_size",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Decoding window maximum size, dw_max_size (in symbols): at a FECFRAME receiver, dw_max_size is the maximum number of received or lost source symbols that are still within their latency budget;",
      "ja": "デコードウィンドウの最大サイズ、dw_max_size（シンボル単位）：FECFRAMEレシーバーでは、dw_max_sizeは、まだレイテンシバジェット内にある受信または損失ソースシンボルの最大数です。"
    },
    {
      "indent": 3,
      "text": "Linear system maximum size, ls_max_size (in symbols): at a FECFRAME receiver, the linear system maximum size, ls_max_size, is the maximum number of received or lost source symbols in the linear system (i.e., the variables). It SHOULD NOT be smaller than dw_max_size since it would mean that, even after receiving a sufficient number of FEC Repair Packets, a lost ADU may not be recovered just because the associated source symbols have been prematurely removed from the linear system, which is usually counter-productive. On the opposite, the linear system MAY grow beyond the dw_max_size (Appendix D);",
      "ja": "線形システムの最大サイズls_max_size（シンボル単位）：FECFRAME受信機では、線形システムの最大サイズls_max_sizeは、線形システムで受信または損失したソースシンボル（変数など）の最大数です。 dw_max_sizeより小さくしてはいけません。これは、十分な数のFEC修復パケットを受信した後でも、関連するソースシンボルが通常はカウンターである時期尚早に線形システムから削除されたために、失われたADUを回復できないことを意味するためです -生産的。 反対に、線形システムはdw_max_sizeを超えて成長する場合があります（付録D）。"
    },
    {
      "indent": 3,
      "text": "Symbol size, E (in bytes): the E parameter determines the source and repair symbol sizes (necessarily equal). This is an input parameter that enables a FECFRAME sender to derive other internal parameters, as explained below. An implementation at a sender MUST fix the E parameter and MUST communicate it as part of the FEC Scheme-Specific Information (Section 4.1.1.2).",
      "ja": "シンボルサイズ、E（バイト単位）：Eパラメーターは、ソースと修復のシンボルサイズを決定します（必然的に等しい）。 以下に説明するように、これはFECFRAME送信者が他の内部パラメーターを導出できるようにする入力パラメーターです。 送信側での実装は、Eパラメータを修正する必要があり、FECスキーム固有情報（セクション4.1.1.2）の一部としてそれを伝達する必要があります。"
    },
    {
      "indent": 3,
      "text": "Code rate, cr: The code rate parameter determines the amount of redundancy added to the flow. More precisely the cr is the ratio between the total number of source symbols and the total number of source plus repair symbols and by definition: 0 < cr <= 1. This is an input parameter that enables a FECFRAME sender to derive other internal parameters, as explained below. However, there is no need to communicate the cr parameter per see (it's not required to process a repair symbol at a receiver). This code rate parameter can be static. However, in specific use-cases (e.g., with unicast transmissions in presence of a feedback mechanism that estimates the communication quality, out of scope of FECFRAME), the code rate may be adjusted dynamically.",
      "ja": "コードレート、cr：コードレートパラメーターは、フローに追加される冗長性の量を決定します。 より正確には、crは、ソースシンボルの総数とソースと修復シンボルの総数の比であり、定義により：0 <cr <=1。これは、FECFRAM送信者が他の内部パラメーターを導出できるようにする入力パラメーターです。 以下で説明します。 ただし、参照ごとにcrパラメーターを通信する必要はありません（受信側で修復シンボルを処理する必要はありません）。 このコードレートパラメータは静的にすることができます。 ただし、特定のユースケース（たとえば、FECFRAMEの範囲外の通信品質を推定するフィードバックメカニズムが存在するユニキャスト送信の場合）では、コードレートを動的に調整できます。"
    },
    {
      "indent": 3,
      "text": "Appendix C proposes non-normative techniques to derive those parameters, depending on the use-case specificities.",
      "ja": "付録Cは、ユースケースの特異性に応じて、これらのパラメーターを導出するための非規範的な手法を提案しています。"
    },
    {
      "indent": 0,
      "text": "3.2. ADU, ADUI, and Source Symbols Mappings",
      "section_title": true,
      "ja": "3.2. ADU、ADUI、およびソースシンボルマッピング"
    },
    {
      "indent": 3,
      "text": "At a sender, an ADU coming from the application is not directly mapped to source symbols. When multiple source flows (e.g., media streams) are mapped onto the same FECFRAME instance, each flow is assigned its own Flow ID value (see below). This Flow ID is then prepended to each ADU before FEC encoding. This way, FEC decoding at a receiver also recovers this Flow ID and the recovered ADU can be assigned to the right source flow (note that the 5-tuple used to identify the right source flow of a received ADU is absent with a recovered ADU since it is not FEC protected).",
      "ja": "送信側では、アプリケーションからのADUはソースシンボルに直接マッピングされません。 複数のソースフロー（メディアストリームなど）が同じFECFRAMEインスタンスにマッピングされると、各フローには独自のフローID値が割り当てられます（以下を参照）。 このフローIDは、FECエンコーディングの前に各ADUに付加されます。 このように、受信機でのFECデコードもこのフローIDを復元し、復元されたADUを正しいソースフローに割り当てることができます（受信したADUの正しいソースフローを識別するために使用される5タプルは、復元されたADUがないため、 FEC保護されていません）。"
    },
    {
      "indent": 3,
      "text": "Additionally, since ADUs are of variable size, padding is needed so that each ADU (with its flow identifier) contribute to an integral number of source symbols. This requires adding the original ADU length to each ADU before doing FEC encoding. Because of these requirements, an intermediate format, the ADUI, or ADU Information, is considered [RFC6363].",
      "ja": "さらに、ADUは可変サイズであるため、各ADU（およびそのフロー識別子）が整数個のソースシンボルに寄与するようにパディングが必要です。 これには、FECエンコードを行う前に、各ADUに元のADU長を追加する必要があります。 これらの要件のため、中間フォーマット、ADUI、またはADU情報は[RFC6363]と考えられます。"
    },
    {
      "indent": 3,
      "text": "For each incoming ADU, an ADUI MUST be created as follows. First of all, 3 bytes are prepended (Figure 1):",
      "ja": "着信ADUごとに、次のようにADUIを作成する必要があります。 まず、3バイトが付加されます（図1）："
    },
    {
      "indent": 3,
      "text": "Flow ID (F) (8-bit field): this unsigned byte contains the integer identifier associated to the source ADU flow to which this ADU belongs. It is assumed that a single byte is sufficient, which implies that no more than 256 flows will be protected by a single FECFRAME session instance.",
      "ja": "フローID（F）（8ビットフィールド）：この符号なしバイトには、このADUが属するソースADUフローに関連付けられた整数識別子が含まれます。 単一のバイトで十分であると想定されます。これは、単一のFECFRAMEセッションインスタンスによって保護されるフローが256以下であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Length (L) (16-bit field): this unsigned integer contains the length of this ADU, in network byte order (i.e., big endian). This length is for the ADU itself and does not include the F, L, or Pad fields.",
      "ja": "長さ（L）（16ビットフィールド）：この符号なし整数には、ネットワークバイト順（つまり、ビッグエンディアン）でこのADUの長さが含まれます。 この長さはADU自体のものであり、F、L、またはPadフィールドは含まれません。"
    },
    {
      "indent": 3,
      "text": "Then, zero padding is added to the ADU if needed:",
      "ja": "次に、必要に応じてゼロパディングがADUに追加されます。"
    },
    {
      "indent": 3,
      "text": "Padding (Pad) (variable size field): this field contains zero padding to align the F, L, ADU and padding up to a size that is multiple of E bytes (i.e., the source and repair symbol length).",
      "ja": "パディング（パッド）（可変サイズフィールド）：このフィールドには、F、L、ADUを揃えるためのゼロパディングと、Eバイトの倍数のサイズ（つまり、ソースおよび修復シンボルの長さ）までのパディングが含まれます。"
    },
    {
      "indent": 3,
      "text": "The data unit resulting from the ADU and the F, L, and Pad fields is called ADUI. Since ADUs can have different sizes, this is also the case for ADUIs. However, an ADUI always contributes to an integral number of source symbols.",
      "ja": "ADUおよびF、L、およびPadフィールドから得られるデータ単位はADUIと呼ばれます。 ADUは異なるサイズを持つことができるため、これはADUIにも当てはまります。 ただし、ADUIは常に整数個のソースシンボルに寄与します。"
    },
    {
      "indent": 3,
      "text": "   symbol length, E              E                     E\n< ------------------ >< ------------------ >< ------------------ >\n+-+--+---------------------------------------------+-------------+\n|F| L|                     ADU                     |     Pad     |\n+-+--+---------------------------------------------+-------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: ADUI Creation Example, Resulting in Three Source Symbols",
      "ja": "図1：ADUIの作成例、結果として3つのソースシンボル"
    },
    {
      "indent": 3,
      "text": "Note that neither the initial 3 bytes nor the optional padding are sent over the network. However, they are considered during FEC encoding, and a receiver that lost a certain FEC Source Packet (e.g., the UDP datagram containing this FEC Source Packet when UDP is used as the transport protocol) will be able to recover the ADUI if FEC decoding succeeds. Thanks to the initial 3 bytes, this receiver will get rid of the padding (if any) and identify the corresponding ADU flow.",
      "ja": "最初の3バイトもオプションのパディングもネットワーク経由で送信されないことに注意してください。 ただし、それらはFECエンコード中に考慮され、特定のFECソースパケット（UDPがトランスポートプロトコルとして使用される場合、このFECソースパケットを含むUDPデータグラム）を失ったレシーバーは、FECデコードが成功した場合、ADUIを回復できます 。 最初の3バイトのおかげで、このレシーバーはパディング（存在する場合）を取り除き、対応するADUフローを識別します。"
    },
    {
      "indent": 0,
      "text": "3.3. Encoding Window Management",
      "section_title": true,
      "ja": "3.3. エンコードウィンドウ管理"
    },
    {
      "indent": 3,
      "text": "Source symbols and the corresponding ADUs are removed from the encoding window:",
      "ja": "ソースシンボルと対応するADUは、エンコードウィンドウから削除されます。"
    },
    {
      "indent": 3,
      "text": "* when the sliding encoding window has reached its maximum size, ew_max_size. In that case the oldest symbol MUST be removed before adding a new symbol, so that the current encoding window size always remains inferior or equal to the maximum size: ew_size <= ew_max_size;",
      "ja": "* スライディングエンコーディングウィンドウが最大サイズew_max_sizeに達したとき。 その場合、新しいシンボルを追加する前に最も古いシンボルを削除する必要があります。これにより、現在のエンコーディングウィンドウサイズは常に最大サイズ以下になります：ew_size <= ew_max_size;"
    },
    {
      "indent": 3,
      "text": "* when an ADU has reached its maximum validity duration in case of a real-time flow. When this happens, all source symbols corresponding to the ADUI that expired SHOULD be removed from the encoding window;",
      "ja": "* リアルタイムフローの場合、ADUが最大有効期間に達したとき。 これが発生した場合、期限切れになったADUIに対応するすべてのソースシンボルをエンコードウィンドウから削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Source symbols are added to the sliding encoding window each time a new ADU arrives, once the ADU-to-source symbols mapping has been performed (Section 3.2). The current size of the encoding window, ew_size, is updated after adding new source symbols. This process may require to remove old source symbols so that: ew_size <= ew_max_size.",
      "ja": "ソースシンボルは、ADUからソースシンボルへのマッピングが実行されると、新しいADUが到着するたびにスライディングエンコーディングウィンドウに追加されます（セクション3.2）。 エンコーディングウィンドウの現在のサイズew_sizeは、新しいソースシンボルを追加した後に更新されます。 このプロセスでは、ew_size <= ew_max_sizeになるように、古いソースシンボルを削除する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that a FEC codec may feature practical limits in the number of source symbols in the encoding window (e.g., for computational complexity reasons). This factor may further limit the ew_max_size value, in addition to the maximum FEC-related latency budget (Section 3.1).",
      "ja": "FECコーデックは、エンコードウィンドウ内のソースシンボルの数に実際的な制限がある場合があることに注意してください（たとえば、計算の複雑さのため）。 この要因は、FEC関連の最大レイテンシバジェット（セクション3.1）に加えて、ew_max_size値をさらに制限する場合があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Source Symbol Identification",
      "section_title": true,
      "ja": "3.4. ソースシンボルの識別"
    },
    {
      "indent": 3,
      "text": "Each source symbol is identified by an Encoding Symbol ID (ESI), an unsigned integer. The ESI of source symbols MUST start with value 0 for the first source symbol and MUST be managed sequentially. Wrapping to zero happens after reaching the maximum value made possible by the ESI field size (this maximum value is FEC scheme dependent, for instance, 2^(32)-1 with FEC schemes 9 and 10).",
      "ja": "各ソースシンボルは、符号化されていない整数であるEncoding Symbol ID（ESI）によって識別されます。 ソースシンボルのESIは、最初のソースシンボルの値0で開始する必要があり、順番に管理する必要があります。 ESIフィールドサイズによって可能になった最大値に達した後、ゼロへの折り返しが発生します（この最大値は、FECスキームに依存します。たとえば、FECスキーム9および10では2 ^（32）-1です）。"
    },
    {
      "indent": 3,
      "text": "No such consideration applies to repair symbols.",
      "ja": "シンボルの修復にはこのような考慮事項は適用されません。"
    },
    {
      "indent": 0,
      "text": "3.5. Pseudorandom Number Generator (PRNG)",
      "section_title": true,
      "ja": "3.5. 疑似乱数ジェネレーター（PRNG）"
    },
    {
      "indent": 3,
      "text": "In order to compute coding coefficients (see Section 3.6), the RLC FEC schemes rely on the TinyMT32 PRNG defined in [RFC8682] with two additional functions defined in this section.",
      "ja": "コーディング係数（セクション3.6を参照）を計算するために、RLC FECスキームは、[RFC8682]で定義されたTinyMT32 PRNGと、このセクションで定義された2つの追加機能に依存しています。"
    },
    {
      "indent": 3,
      "text": "This PRNG MUST first be initialized with a 32-bit unsigned integer, used as a seed, with:",
      "ja": "このPRNGは、最初にシードとして使用される32ビットの符号なし整数で初期化する必要があります。"
    },
    {
      "indent": 6,
      "text": "void   tinymt32_init (tinymt32_t * s, uint32_t seed);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "With the FEC schemes defined in this document, the seed is in practice restricted to a value between 0 and 0xFFFF inclusive (note that this PRNG accepts a seed value equal to 0), since this is the Repair_Key 16-bit field value of the Repair FEC Payload ID (Section 4.1.3). In practice, how to manage the seed and Repair_Key values (both are equal) is left to the implementer, using a monotonically increasing counter being one possibility (Section 6.1). In addition to the seed, this function takes as parameter a pointer to an instance of a tinymt32_t structure that is used to keep the internal state of the PRNG.",
      "ja": "このドキュメントで定義されるFECスキームでは、シードは実際には0から0xFFFFまでの値に制限されます（このPRNGは0に等しいシード値を受け入れることに注意してください）。これはRepair_Key 16ビットフィールド値のRepair FECペイロードID（セクション4.1.3）。 実際には、シード値とRepair_Key値（両方が等しい）の管理方法は実装者に任されており、単調に増加するカウンターを1つの可能性として使用しています（セクション6.1）。 シードに加えて、この関数は、PRNGの内部状態を保持するために使用されるtinymt32_t構造体のインスタンスへのポインターをパラメーターとして受け取ります。"
    },
    {
      "indent": 3,
      "text": "Then, each time a new pseudorandom integer between 0 and 15 inclusive (4-bit pseudorandom integer) is needed, the following function is used:",
      "ja": "次に、0から15までの新しい擬似乱数整数（4ビットの擬似乱数整数）が必要になるたびに、次の関数が使用されます。"
    },
    {
      "indent": 6,
      "text": "uint32_t   tinymt32_rand16 (tinymt32_t * s);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function takes as parameter a pointer to the same tinymt32_t structure (that is left unchanged between successive calls to the function).",
      "ja": "この関数は、同じtinymt32_t構造体へのポインターをパラメーターとして受け取ります（関数への連続した呼び出し間で変更されないままです）。"
    },
    {
      "indent": 3,
      "text": "Similarly, each time a new pseudorandom integer between 0 and 255 inclusive (8-bit pseudorandom integer) is needed, the following function is used:",
      "ja": "同様に、0から255までの新しい擬似乱数整数（8ビットの擬似乱数整数）が必要になるたびに、次の関数が使用されます。"
    },
    {
      "indent": 6,
      "text": "uint32_t   tinymt32_rand256 (tinymt32_t * s);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These two functions keep respectively the 4 or 8 less significant bits of the 32-bit pseudorandom number generated by the tinymt32_generate_uint32() function of [RFC8682]. This is done by computing the result of a binary AND between the tinymt32_generate_uint32() output and respectively the 0xF or 0xFF constants, using 32-bit unsigned integer operations. Figure 2 shows a possible implementation. This is a C language implementation, written for C99 [C99]. Test results discussed in Appendix B show that this simple technique, applied to this PRNG, is in line with the RLC FEC schemes needs.",
      "ja": "これらの2つの関数は、[RFC8682]のtinymt32_generate_uint32（）関数によって生成された32ビット擬似乱数の下位4ビットまたは8ビットをそれぞれ保持します。 これは、32ビット符号なし整数演算を使用して、tinymt32_generate_uint32（）出力とそれぞれ0xFまたは0xFF定数とのバイナリANDの結果を計算することにより行われます。 図2は、可能な実装を示しています。 これは、C99 [C99]向けに作成されたC言語の実装です。 付録Bで説明したテスト結果は、このPRNGに適用されるこの単純な手法が、RLC FECスキームのニーズに沿っていることを示しています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n/**\n * This function outputs a pseudorandom integer in [0 .. 15] range.\n *\n * @param s     pointer to tinymt internal state.\n * @return      unsigned integer between 0 and 15 inclusive.\n */\nuint32_t tinymt32_rand16(tinymt32_t *s)\n{\n    return (tinymt32_generate_uint32(s) & 0xF);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/**\n * This function outputs a pseudorandom integer in [0 .. 255] range.\n *\n * @param s     pointer to tinymt internal state.\n * @return      unsigned integer between 0 and 255 inclusive.\n */\nuint32_t tinymt32_rand256(tinymt32_t *s)\n{\n    return (tinymt32_generate_uint32(s) & 0xFF);\n}\n<CODE ENDS>",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 2: 4-bit and 8-bit Mapping Functions for TinyMT32",
      "ja": "図2：TinyMT32の4ビットおよび8ビットのマッピング関数"
    },
    {
      "indent": 3,
      "text": "Any implementation of this PRNG MUST have the same output as that provided by the reference implementation of [RFC8682]. In order to increase the compliance confidence, three criteria are proposed: the one described in [RFC8682] (for the TinyMT32 32-bit unsigned integer generator), and the two others detailed in Appendix A (for the mapping to 4-bit and 8-bit intervals). Because of the way the mapping functions work, it is unlikely that an implementation that fulfills the first criterion fails to fulfill the two others.",
      "ja": "このPRNGの実装は、[RFC8682]の参照実装によって提供される出力と同じ出力を持たなければなりません。 コンプライアンスの信頼性を高めるために、3つの基準が提案されています。[RFC8682]（TinyMT32 32ビット符号なし整数ジェネレーター）で説明されている基準と、付録A（4ビットおよび8 ビット間隔）。 マッピング関数の動作方法により、最初の基準を満たす実装が他の2つの基準を満たすことができないことはほとんどありません。"
    },
    {
      "indent": 0,
      "text": "3.6. Coding Coefficients Generation Function",
      "section_title": true,
      "ja": "3.6. コーディング係数生成関数"
    },
    {
      "indent": 3,
      "text": "The coding coefficients used during the encoding process are generated at the RLC encoder by the generate_coding_coefficients() function each time a new repair symbol needs to be produced. The fraction of coefficients that are nonzero (i.e., the density) is controlled by the DT (Density Threshold) parameter. DT has values between 0 (the minimum value) and 15 (the maximum value), and the average probability of having a nonzero coefficient equals (DT + 1) / 16. In particular, when DT equals 15 the function guaranties that all coefficients are nonzero (i.e., maximum density).",
      "ja": "エンコード処理中に使用されるコーディング係数は、新しい修復シンボルを生成する必要があるたびにgenerate_coding_coefficients（）関数によってRLCエンコーダーで生成されます。 ゼロ以外の係数の割合（つまり、密度）は、DT（密度しきい値）パラメーターによって制御されます。 DTの値は0（最小値）〜15（最大値）であり、非ゼロ係数を持つ平均確率は（DT + 1）/ 16に等しくなります。特に、DTが15に等しい場合、関数はすべての係数が 非ゼロ（つまり、最大密度）。"
    },
    {
      "indent": 3,
      "text": "These considerations apply to both the RLC over GF(2) and RLC over GF(2^(8)), the only difference being the value of the m parameter. With the RLC over GF(2) FEC scheme (Section 5), m is equal to 1. With RLC over GF(2^(8)) FEC scheme (Section 4), m is equal to 8.",
      "ja": "これらの考慮事項は、GF（2）上のRLCとGF（2 ^（8））上のRLCの両方に適用されます。唯一の違いはmパラメーターの値です。 RLC over GF（2）FECスキーム（セクション5）では、mは1です。RLCover GF（2 ^（8））FECスキーム（セクション4）では、mは8です。"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows the reference generate_coding_coefficients() implementation. This is a C language implementation, written for C99 [C99].",
      "ja": "図3は、参照generate_coding_coefficients（）の実装を示しています。 これは、C99 [C99]向けに作成されたC言語の実装です。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n#include <string.h>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Fills in the table of coding coefficients (of the right size)\n * provided with the appropriate number of coding coefficients to\n * use for the repair symbol key provided.\n *\n * (in) repair_key    key associated to this repair symbol. This\n *                    parameter is ignored (useless) if m=1 and dt=15\n * (in/out) cc_tab    pointer to a table of the right size to store\n *                    coding coefficients. All coefficients are\n *                    stored as bytes, regardless of the m parameter,\n *                    upon return of this function.\n * (in) cc_nb         number of entries in the cc_tab table. This\n *                    value is equal to the current encoding window\n *                    size.\n * (in) dt            integer between 0 and 15 (inclusive) that\n *                    controls the density. With value 15, all\n *                    coefficients are guaranteed to be nonzero\n *                    (i.e., equal to 1 with GF(2) and equal to a\n *                    value in {1,... 255} with GF(2^^8)), otherwise\n *                    a fraction of them will be 0.\n * (in) m             Finite Field GF(2^^m) parameter. In this\n *                    document only values 1 and 8 are considered.\n * (out)              returns 0 in case of success, an error code\n *                    different than 0 otherwise.\n */\nint generate_coding_coefficients (uint16_t  repair_key,\n                                  uint8_t*  cc_tab,\n                                  uint16_t  cc_nb,\n                                  uint8_t   dt,\n                                  uint8_t   m)\n{\n    uint32_t      i;\n    tinymt32_t    s;    /* PRNG internal state */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (dt > 15) {\n    return -1; /* error, bad dt parameter */\n}\nswitch (m) {\ncase 1:\n    if (dt == 15) {\n        /* all coefficients are 1 */\n        memset(cc_tab, 1, cc_nb);\n    } else {\n        /* here coefficients are either 0 or 1 */\n        tinymt32_init(&s, repair_key);\n        for (i = 0 ; i < cc_nb ; i++) {\n            cc_tab[i] = (tinymt32_rand16(&s) <= dt) ? 1 : 0;\n        }\n    }\n    break;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "case 8:\n    tinymt32_init(&s, repair_key);\n    if (dt == 15) {\n        /* coefficient 0 is avoided here in order to include\n         * all the source symbols */\n        for (i = 0 ; i < cc_nb ; i++) {\n            do {\n                cc_tab[i] = (uint8_t) tinymt32_rand256(&s);\n            } while (cc_tab[i] == 0);\n        }\n    } else {\n        /* here a certain number of coefficients should be 0 */\n        for (i = 0 ; i < cc_nb ; i++) {\n            if (tinymt32_rand16(&s) <= dt) {\n                do {\n                    cc_tab[i] = (uint8_t) tinymt32_rand256(&s);\n                } while (cc_tab[i] == 0);\n            } else {\n                cc_tab[i] = 0;\n            }\n        }\n    }\n    break;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    default:\n        return -2; /* error, bad parameter m */\n    }\n    return 0; /* success */\n}\n<CODE ENDS>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 3: Reference Implementation of the Coding Coefficients Generation Function",
      "ja": "図3：コーディング係数生成関数のリファレンス実装"
    },
    {
      "indent": 0,
      "text": "3.7. Finite Field Operations",
      "section_title": true,
      "ja": "3.7. 有限フィールドオペレーション"
    },
    {
      "indent": 0,
      "text": "3.7.1. Finite Field Definitions",
      "section_title": true,
      "ja": "3.7.1. 有限フィールド定義"
    },
    {
      "indent": 3,
      "text": "The two RLC FEC schemes specified in this document reuse the Finite Fields defined in [RFC5510], Section 8.1. More specifically, the elements of the field GF(2^(m)) are represented by polynomials with binary coefficients (i.e., over GF(2)) and degree lower or equal to m-1. The addition between two elements is defined as the addition of binary polynomials in GF(2), which is equivalent to a bitwise XOR operation on the binary representation of these elements.",
      "ja": "このドキュメントで指定された2つのRLC FECスキームは、[RFC5510]、セクション8.1で定義された有限フィールドを再利用します。 より具体的には、体GF（2 ^（m））の要素は、バイナリ係数（すなわち、GF（2）上の）とm-1以下の多項式で表されます。 2つの要素間の加算は、GF（2）のバイナリ多項式の加算として定義されます。これは、これらの要素のバイナリ表現のビットごとのXOR演算に相当します。"
    },
    {
      "indent": 3,
      "text": "With GF(2^(8)), multiplication between two elements is the multiplication modulo a given irreducible polynomial of degree 8. The following irreducible polynomial is used for GF(2^(8)):",
      "ja": "GF（2 ^（8））では、2つの要素間の乗算は、次数8の既約多項式を法とする乗算です。次の既約多項式がGF（2 ^（8））に使用されます。"
    },
    {
      "indent": 6,
      "text": "x^(8) + x^(4) + x^(3) + x^(2) + 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "With GF(2), multiplication corresponds to a logical AND operation.",
      "ja": "GF（2）では、乗算は論理AND演算に対応します。"
    },
    {
      "indent": 0,
      "text": "3.7.2. Linear Combination of Source Symbol Computation",
      "section_title": true,
      "ja": "3.7.2. ソースシンボル計算の線形結合"
    },
    {
      "indent": 3,
      "text": "The two RLC FEC schemes require the computation of a linear combination of source symbols, using the coding coefficients produced by the generate_coding_coefficients() function and stored in the cc_tab[] array.",
      "ja": "2つのRLC FECスキームでは、generate_coding_coefficients（）関数によって生成され、cc_tab []配列に格納されたコーディング係数を使用して、ソースシンボルの線形結合の計算が必要です。"
    },
    {
      "indent": 3,
      "text": "With the RLC over GF(2^(8)) FEC scheme, a linear combination of the ew_size source symbol present in the encoding window, say src_0 to src_ew_size_1, in order to generate a repair symbol, is computed as follows. For each byte of position i in each source and the repair symbol, where i belongs to [0; E-1], compute:",
      "ja": "RLC over GF（2 ^（8））FECスキームでは、修復シンボルを生成するために、エンコードウィンドウにあるew_sizeソースシンボルの線形結合、たとえばsrc_0〜src_ew_size_1が次のように計算されます。 各ソースの位置iの各バイトおよび修復シンボル。iは[0;に属します。 E-1]、計算："
    },
    {
      "indent": 6,
      "text": "repair[i] = cc_tab[0] * src_0[i] XOR cc_tab[1] * src_1[i] XOR ...\nXOR cc_tab[ew_size - 1] * src_ew_size_1[i]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where * is the multiplication over GF(2^(8)). In practice various optimizations need to be used in order to make this computation efficient (see in particular [PGM13]).",
      "ja": "ここで、*はGF（2 ^（8））の乗算です。 実際には、この計算を効率的にするために、さまざまな最適化を使用する必要があります（特に[PGM13]を参照）。"
    },
    {
      "indent": 3,
      "text": "With the RLC over GF(2) FEC scheme (binary case), a linear combination is computed as follows. The repair symbol is the XOR sum of all the source symbols corresponding to a coding coefficient cc_tab[j] equal to 1 (i.e., the source symbols corresponding to zero coding coefficients are ignored). The XOR sum of the byte of position i in each source is computed and stored in the corresponding byte of the repair symbol, where i belongs to [0; E-1]. In practice, the XOR sums will be computed several bytes at a time (e.g., on 64 bit words, or on arrays of 16 or more bytes when using SIMD CPU extensions).",
      "ja": "RLC over GF（2）FECスキーム（バイナリケース）では、線形結合は次のように計算されます。 修復シンボルは、1に等しいコーディング係数cc_tab [j]に対応するすべてのソースシンボルのXOR合計です（つまり、ゼロのコーディング係数に対応するソースシンボルは無視されます）。 各ソースの位置iのバイトのXOR合計が計算され、修復シンボルの対応するバイトに格納されます。ここで、iは[0;に属します。 E-1]。 実際には、XORの合計は一度に数バイトで計算されます（たとえば、64ビットワード、またはSIMD CPU拡張機能を使用する場合は16バイト以上の配列で）。"
    },
    {
      "indent": 3,
      "text": "With both FEC schemes, the details of how to optimize the computation of these linear combinations are of high practical importance but out of scope of this document.",
      "ja": "両方のFECスキームでは、これらの線形結合の計算を最適化する方法の詳細は実用的に非常に重要ですが、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "4. Sliding Window RLC FEC Scheme over GF(2^(8)) for Arbitrary Packet Flows",
      "ja": "4. 任意のパケットフローのためのGF（2 ^（8））上のスライディングウィンドウRLC FECスキーム"
    },
    {
      "indent": 3,
      "text": "This fully-specified FEC scheme defines the Sliding Window Random Linear Codes (RLC) over GF(2^(8)).",
      "ja": "この完全に指定されたFECスキームは、GF（2 ^（8））上のスライディングウィンドウランダム線形コード（RLC）を定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. Formats and Codes",
      "section_title": true,
      "ja": "4.1. フォーマットとコード"
    },
    {
      "indent": 0,
      "text": "4.1.1. FEC Framework Configuration Information",
      "section_title": true,
      "ja": "4.1.1. FECフレームワークの構成情報"
    },
    {
      "indent": 3,
      "text": "Following the guidelines of Section 5.6 of [RFC6363], this section provides the FEC Framework Configuration Information (or FFCI). This FCCI needs to be shared (e.g., using SDP) between the FECFRAME sender and receiver instances in order to synchronize them. It includes a FEC Encoding ID, mandatory for any FEC scheme specification, plus scheme-specific elements.",
      "ja": "[RFC6363]のセクション5.6のガイドラインに従って、このセクションはFECフレームワーク構成情報（またはFFCI）を提供します。 このFCCIは、FECFRAMEの送信者と受信者のインスタンスを同期させるために、それらの間で共有する必要があります（たとえば、SDPを使用）。 これには、FECスキーム仕様に必須のFECエンコーディングIDと、スキーム固有の要素が含まれます。"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. FEC Encoding ID",
      "section_title": true,
      "ja": "4.1.1.1. FECエンコーディングID"
    },
    {
      "indent": 3,
      "text": "FEC Encoding ID: the value assigned to this fully specified FEC scheme MUST be 10, as assigned by IANA (Section 9).",
      "ja": "FECエンコーディングID：この完全に指定されたFECスキームに割り当てられた値は、IANAによって割り当てられた10でなければなりません（セクション9）。"
    },
    {
      "indent": 3,
      "text": "When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in the 'encoding-id' parameter.",
      "ja": "SDPを使用してFFCIを通信する場合、このFECエンコーディングIDは「encoding-id」パラメータで伝送されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1.2. FEC Scheme-Specific Information",
      "section_title": true,
      "ja": "4.1.1.2. FECスキーム固有の情報"
    },
    {
      "indent": 3,
      "text": "The FEC Scheme-Specific Information (FSSI) includes elements that are specific to the present FEC scheme. More precisely:",
      "ja": "FECスキーム固有情報（FSSI）には、現在のFECスキームに固有の要素が含まれています。 より正確に："
    },
    {
      "indent": 3,
      "text": "Encoding symbol size (E): a non-negative integer that indicates the size of each encoding symbol in bytes;",
      "ja": "エンコードシンボルサイズ（E）：各エンコードシンボルのサイズをバイト単位で示す負でない整数。"
    },
    {
      "indent": 3,
      "text": "Window Size Ratio (WSR) parameter: a non-negative integer between 0 and 255 (both inclusive) used to initialize window sizes. A value of 0 indicates this parameter is not considered (e.g., a fixed encoding window size may be chosen). A value between 1 and 255 inclusive is required by certain of the parameter derivation techniques described in Appendix C;",
      "ja": "ウィンドウサイズ比（WSR）パラメーター：ウィンドウサイズを初期化するために使用される0〜255（両方を含む）の非負整数。 値0は、このパラメーターが考慮されないことを示します（たとえば、固定エンコードウィンドウサイズを選択できます）。 付録Cに記載されている特定のパラメーター派生手法では、1〜255の値が必要です。"
    },
    {
      "indent": 3,
      "text": "This element is required both by the sender (RLC encoder) and the receiver(s) (RLC decoder).",
      "ja": "この要素は、送信者（RLCエンコーダー）と受信者（RLCデコーダー）の両方に必要です。"
    },
    {
      "indent": 3,
      "text": "When SDP is used to communicate the FFCI, this FEC Scheme-Specific Information is carried in the 'fssi' parameter in textual representation as specified in [RFC6364]. For instance:",
      "ja": "SDPがFFCIの通信に使用される場合、このFECスキーム固有の情報は、[RFC6364]で指定されているテキスト表現の「fssi」パラメータで運ばれます。 例えば："
    },
    {
      "indent": 6,
      "text": "fssi=E:1400,WSR:191",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In that case the name values \"E\" and \"WSR\" are used to convey the E and WSR parameters respectively.",
      "ja": "その場合、名前の値「E」および「WSR」は、それぞれEおよびWSRパラメーターを伝達するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If another mechanism requires the FSSI to be carried as an opaque octet string, the encoding format consists of the following three octets, where the E field is carried in \"big-endian\" or \"network order\" format, that is, most significant byte first:",
      "ja": "別のメカニズムでFSSIを不透明なオクテット文字列として送信する必要がある場合、エンコード形式は次の3つのオクテットで構成され、Eフィールドは「ビッグエンディアン」または「ネットワーク順序」形式、つまり最上位バイトで送信されます 最初："
    },
    {
      "indent": 6,
      "text": "Encoding symbol length (E): 16-bit field;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Window Size Ratio Parameter (WSR): 8-bit field.",
      "ja": "ウィンドウサイズ比パラメーター（WSR）：8ビットフィールド。"
    },
    {
      "indent": 3,
      "text": "These three octets can be communicated as such, or for instance, be subject to an additional Base64 encoding.",
      "ja": "これらの3つのオクテットは、そのまま通信することも、たとえば、追加のBase64エンコードの対象にすることもできます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Encoding Symbol Length (E)  |      WSR      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 4: FSSI Encoding Format",
      "ja": "図4：FSSIエンコード形式"
    },
    {
      "indent": 0,
      "text": "4.1.2. Explicit Source FEC Payload ID",
      "section_title": true,
      "ja": "4.1.2. 明示的なソースFECペイロードID"
    },
    {
      "indent": 3,
      "text": "A FEC Source Packet MUST contain an Explicit Source FEC Payload ID that is appended to the end of the packet as illustrated in Figure 5.",
      "ja": "FECソースパケットには、図5に示すように、パケットの末尾に追加される明示的なソースFECペイロードIDが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+\n|           IP Header            |\n+--------------------------------+\n|        Transport Header        |\n+--------------------------------+\n|              ADU               |\n+--------------------------------+\n| Explicit Source FEC Payload ID |\n+--------------------------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 5: Structure of an FEC Source Packet with the Explicit Source FEC Payload ID",
      "ja": "図5：明示的なソースFECペイロードIDを持つFECソースパケットの構造"
    },
    {
      "indent": 3,
      "text": "More precisely, the Explicit Source FEC Payload ID is composed of the following field, carried in \"big-endian\" or \"network order\" format, that is, most significant byte first (Figure 6):",
      "ja": "より正確には、明示的ソースFECペイロードIDは、「ビッグエンディアン」または「ネットワーク順序」形式で搬送される次のフィールドで構成されます。つまり、最上位バイトが最初になります（図6）。"
    },
    {
      "indent": 3,
      "text": "Encoding Symbol ID (ESI) (32-bit field): this unsigned integer identifies the first source symbol of the ADUI corresponding to this FEC Source Packet. The ESI is incremented for each new source symbol, and after reaching the maximum value (2^(32)-1), wrapping to zero occurs.",
      "ja": "エンコードシンボルID（ESI）（32ビットフィールド）：この符号なし整数は、このFECソースパケットに対応するADUIの最初のソースシンボルを識別します。 ESIは新しいソースシンボルごとに増分され、最大値（2 ^（32）-1）に達した後、ゼロへのラップが発生します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Encoding Symbol ID (ESI)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 6: Source FEC Payload ID Encoding Format",
      "ja": "図6：ソースFECペイロードIDエンコード形式"
    },
    {
      "indent": 0,
      "text": "4.1.3. Repair FEC Payload ID",
      "section_title": true,
      "ja": "4.1.3. FECペイロードIDの修復"
    },
    {
      "indent": 3,
      "text": "A FEC Repair Packet MAY contain one or more repair symbols. When there are several repair symbols, all of them MUST have been generated from the same encoding window, using Repair_Key values that are managed as explained below. A receiver can easily deduce the number of repair symbols within a FEC Repair Packet by comparing the received FEC Repair Packet size (equal to the UDP payload size when UDP is the underlying transport protocol) and the symbol size, E, communicated in the FFCI.",
      "ja": "FEC修復パケットには、1つ以上の修復シンボルが含まれている場合があります。 いくつかの修復シンボルがある場合、それらのすべては、以下で説明するように管理されるRepair_Key値を使用して、同じエンコーディングウィンドウから生成されている必要があります。 受信者は、受信したFEC Repair Packetサイズ（UDPが基になるトランスポートプロトコルである場合はUDPペイロードサイズに等しい）とFFCIで通信されたシンボルサイズEを比較することで、FEC Repair Packet内の修復シンボルの数を簡単に推測できます。"
    },
    {
      "indent": 3,
      "text": "A FEC Repair Packet MUST contain a Repair FEC Payload ID that is prepended to the repair symbol as illustrated in Figure 7.",
      "ja": "FEC修復パケットには、図7に示すように、修復シンボルに付加される修復FECペイロードIDが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+\n|           IP Header            |\n+--------------------------------+\n|        Transport Header        |\n+--------------------------------+\n|     Repair FEC Payload ID      |\n+--------------------------------+\n|         Repair Symbol          |\n+--------------------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 7: Structure of an FEC Repair Packet with the Repair FEC Payload ID",
      "ja": "図7：修復FECペイロードIDを使用したFEC修復パケットの構造"
    },
    {
      "indent": 3,
      "text": "More precisely, the Repair FEC Payload ID is composed of the following fields where all integer fields are carried in \"big-endian\" or \"network order\" format, that is, most significant byte first (Figure 8):",
      "ja": "より正確には、修復FECペイロードIDは、すべての整数フィールドが「ビッグエンディアン」または「ネットワーク順序」形式、つまり最上位バイトが先頭にある次のフィールドで構成されます（図8）。"
    },
    {
      "indent": 3,
      "text": "Repair_Key (16-bit field): this unsigned integer is used as a seed by the coefficient generation function (Section 3.6) in order to generate the desired number of coding coefficients. This repair key may be a monotonically increasing integer value that loops back to 0 after reaching 65535 (see Section 6.1). When a FEC Repair Packet contains several repair symbols, this repair key value is that of the first repair symbol. The remaining repair keys can be deduced by incrementing by 1 this value, up to a maximum value of 65535 after which it loops back to 0.",
      "ja": "Repair_Key（16ビットフィールド）：この符号なし整数は、係数生成関数（3.6節）でシードとして使用され、必要な数のコーディング係数を生成します。 この修復キーは、65535に達した後に0にループバックする単調に増加する整数値である場合があります（セクション6.1を参照）。 FEC修復パケットに複数の修復シンボルが含まれている場合、この修復キーの値は最初の修復シンボルの値です。 残りの修復キーは、この値を1増やして最大値65535まで増やし、その後0にループバックすることで推測できます。"
    },
    {
      "indent": 3,
      "text": "Density Threshold for the coding coefficients, DT (4-bit field): this unsigned integer carries the Density Threshold (DT) used by the coding coefficient generation function Section 3.6. More precisely, it controls the probability of having a nonzero coding coefficient, which equals (DT+1) / 16. When a FEC Repair Packet contains several repair symbols, the DT value applies to all of them;",
      "ja": "符号化係数の密度しきい値、DT（4ビットフィールド）：この符号なし整数は、符号化係数生成機能セクション3.6で使用される密度しきい値（DT）を保持します。 より正確には、（DT + 1）/ 16に等しい非ゼロコーディング係数を持つ確率を制御します。FEC修復パケットに複数の修復シンボルが含まれる場合、DT値はそれらすべてに適用されます。"
    },
    {
      "indent": 3,
      "text": "Number of Source Symbols in the encoding window, NSS (12-bit field): this unsigned integer indicates the number of source symbols in the encoding window when this repair symbol was generated. When a FEC Repair Packet contains several repair symbols, this NSS value applies to all of them;",
      "ja": "エンコードウィンドウ内のソースシンボルの数、NSS（12ビットフィールド）：この符号なし整数は、この修復シンボルが生成されたときのエンコードウィンドウ内のソースシンボルの数を示します。 FEC修復パケットに複数の修復シンボルが含まれる場合、このNSS値はそれらすべてに適用されます。"
    },
    {
      "indent": 3,
      "text": "ESI of First Source Symbol in the encoding window, FSS_ESI (32-bit field): this unsigned integer indicates the ESI of the first source symbol in the encoding window when this repair symbol was generated. When a FEC Repair Packet contains several repair symbols, this FSS_ESI value applies to all of them;",
      "ja": "エンコーディングウィンドウの最初のソースシンボルのESI、FSS_ESI（32ビットフィールド）：この符号なし整数は、この修復シンボルが生成されたときのエンコーディングウィンドウの最初のソースシンボルのESIを示します。 FEC修復パケットに複数の修復シンボルが含まれている場合、このFSS_ESI値はそれらすべてに適用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Repair_Key              |  DT   |NSS (# src symb in ew) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            FSS_ESI                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 8: Repair FEC Payload ID Encoding Format",
      "ja": "図8：修復FECペイロードIDエンコード形式"
    },
    {
      "indent": 0,
      "text": "4.2. Procedures",
      "section_title": true,
      "ja": "4.2. 手続き"
    },
    {
      "indent": 3,
      "text": "All the procedures of Section 3 apply to this FEC scheme.",
      "ja": "セクション3のすべての手順は、このFECスキームに適用されます。"
    },
    {
      "indent": 0,
      "text": "5. Sliding Window RLC FEC Scheme over GF(2) for Arbitrary Packet Flows",
      "section_title": true,
      "ja": "5. 任意のパケットフローのためのGF（2）上のスライディングウィンドウRLC FECスキーム"
    },
    {
      "indent": 3,
      "text": "This fully-specified FEC scheme defines the Sliding Window Random Linear Codes (RLC) over GF(2) (binary case).",
      "ja": "この完全に指定されたFECスキームは、GF（2）上のスライディングウィンドウランダム線形コード（RLC）を定義します（バイナリケース）。"
    },
    {
      "indent": 0,
      "text": "5.1. Formats and Codes",
      "section_title": true,
      "ja": "5.1. フォーマットとコード"
    },
    {
      "indent": 0,
      "text": "5.1.1. FEC Framework Configuration Information",
      "section_title": true,
      "ja": "5.1.1. FECフレームワークの構成情報"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. FEC Encoding ID",
      "section_title": true,
      "ja": "5.1.1.1. FECエンコーディングID"
    },
    {
      "indent": 3,
      "text": "FEC Encoding ID: the value assigned to this fully specified FEC scheme MUST be 9, as assigned by IANA (Section 9).",
      "ja": "FECエンコーディングID：この完全に指定されたFECスキームに割り当てられた値は、IANAによって割り当てられた9でなければなりません（セクション9）。"
    },
    {
      "indent": 3,
      "text": "When SDP is used to communicate the FFCI, this FEC Encoding ID is carried in the 'encoding-id' parameter.",
      "ja": "SDPを使用してFFCIを通信する場合、このFECエンコーディングIDは「encoding-id」パラメータで伝送されます。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. FEC Scheme-Specific Information",
      "section_title": true,
      "ja": "5.1.1.2. FECスキーム固有の情報"
    },
    {
      "indent": 3,
      "text": "All the considerations of Section 4.1.1.2 apply here.",
      "ja": "セクション4.1.1.2のすべての考慮事項がここに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Explicit Source FEC Payload ID",
      "section_title": true,
      "ja": "5.1.2. 明示的なソースFECペイロードID"
    },
    {
      "indent": 3,
      "text": "All the considerations of Section 4.1.2 apply here.",
      "ja": "セクション4.1.2のすべての考慮事項がここに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Repair FEC Payload ID",
      "section_title": true,
      "ja": "5.1.3. FECペイロードIDの修復"
    },
    {
      "indent": 3,
      "text": "All the considerations of Section 4.1.3 apply here, with the only exception that the Repair_Key field is useless if DT = 15 (indeed, in that case all the coefficients are necessarily equal to 1 and the coefficient generation function does not use any PRNG). When DT = 15 the FECFRAME sender MUST set the Repair_Key field to zero on transmission and a receiver MUST ignore it on receipt.",
      "ja": "セクション4.1.3のすべての考慮事項がここに適用されます。ただし、DT = 15の場合、Repair_Keyフィールドは無効です（実際、その場合、すべての係数は必ず1に等しく、係数生成関数はPRNGを使用しません） 。 DT = 15の場合、FECFRAME送信者は送信時にRepair_Keyフィールドをゼロに設定しなければならず、受信者は受信時にそれを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Procedures",
      "section_title": true,
      "ja": "5.2. 手続き"
    },
    {
      "indent": 3,
      "text": "All the procedures of Section 3 apply to this FEC scheme.",
      "ja": "セクション3のすべての手順は、このFECスキームに適用されます。"
    },
    {
      "indent": 0,
      "text": "6. FEC Code Specification",
      "section_title": true,
      "ja": "6. FECコード仕様"
    },
    {
      "indent": 0,
      "text": "6.1. Encoding Side",
      "section_title": true,
      "ja": "6.1. エンコード側"
    },
    {
      "indent": 3,
      "text": "This section provides a high level description of a Sliding Window RLC encoder.",
      "ja": "このセクションでは、スライディングウィンドウRLCエンコーダーの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "Whenever a new FEC Repair Packet is needed, the RLC encoder instance first gathers the ew_size source symbols currently in the sliding encoding window. Then it chooses a repair key, which can be a monotonically increasing integer value, incremented for each repair symbol up to a maximum value of 65535 (as it is carried within a 16-bit field) after which it loops back to 0. This repair key is communicated to the coefficient generation function (Section 3.6) in order to generate ew_size coding coefficients. Finally, the FECFRAME sender computes the repair symbol as a linear combination of the ew_size source symbols using the ew_size coding coefficients (Section 3.7). When E is small and when there is an incentive to pack several repair symbols within the same FEC Repair Packet, the appropriate number of repair symbols are computed. In that case the repair key for each of them MUST be incremented by 1, keeping the same ew_size source symbols, since only the first repair key will be carried in the Repair FEC Payload ID. The FEC Repair Packet can then be passed to the transport layer for transmission. The source versus repair FEC packet transmission order is out of scope of this document and several approaches exist that are implementation-specific.",
      "ja": "新しいFEC修復パケットが必要になるたびに、RLCエンコーダーインスタンスは最初に、現在スライディングエンコーディングウィンドウにあるew_sizeソースシンボルを収集します。次に、修復キーを選択します。これは単調に増加する整数値で、各修復シンボルごとに最大値65535（16ビットフィールド内で運ばれる）までインクリメントされ、その後0に戻ります。この修復キーは、ew_sizeコーディング係数を生成するために、係数生成関数（セクション3.6）に通信されます。最後に、FECFRAME送信側は、ew_sizeコーディング係数を使用して、ew_sizeソースシンボルの線形結合として修復シンボルを計算します（セクション3.7）。 Eが小さく、同じFEC修復パケット内にいくつかの修復シンボルをパックするインセンティブがある場合、修復シンボルの適切な数が計算されます。その場合、最初の修復キーのみが修復FECペイロードIDで運ばれるため、同じew_sizeソースシンボルを保持したまま、それぞれの修復キーを1ずつ増加させる必要があります。 FEC Repair Packetは、送信のためにトランスポート層に渡されます。ソースと修復FECパケットの送信順序はこのドキュメントの範囲外であり、実装固有のアプローチがいくつかあります。"
    },
    {
      "indent": 3,
      "text": "Other solutions are possible to select a repair key value when a new FEC Repair Packet is needed, for instance, by choosing a random integer between 0 and 65535. However, selecting the same repair key as before (which may happen in case of a random process) is only meaningful if the encoding window has changed, otherwise the same FEC Repair Packet will be generated. In any case, choosing the repair key is entirely at the discretion of the sender, since it is communicated to the receiver(s) in each Repair FEC Payload ID. A receiver should not make any assumption on the way the repair key is managed.",
      "ja": "たとえば、0〜65535のランダムな整数を選択することにより、新しいFEC修復パケットが必要なときに修復キーの値を選択することもできます。ただし、以前と同じ修復キーを選択する（ランダムの場合は、 プロセス）は、エンコードウィンドウが変更された場合にのみ意味があります。変更されていない場合、同じFEC修復パケットが生成されます。 いずれにせよ、修理FECペイロードIDで受信者に通信されるため、修理キーの選択は完全に送信者の裁量に任されています。 受信者は、修復キーの管理方法について想定しないでください。"
    },
    {
      "indent": 0,
      "text": "6.2. Decoding Side",
      "section_title": true,
      "ja": "6.2. デコード側"
    },
    {
      "indent": 3,
      "text": "This section provides a high level description of a Sliding Window RLC decoder.",
      "ja": "このセクションでは、スライディングウィンドウRLCデコーダーの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "A FECFRAME receiver needs to maintain a linear system whose variables are the received and lost source symbols. Upon receiving a FEC Repair Packet, a receiver first extracts all the repair symbols it contains (in case several repair symbols are packed together). For each repair symbol, when at least one of the corresponding source symbols it protects has been lost, the receiver adds an equation to the linear system (or no equation if this repair packet does not change the linear system rank). This equation of course re-uses the ew_size coding coefficients that are computed by the same coefficient generation function (Section 3.6), using the repair key and encoding window descriptions carried in the Repair FEC Payload ID. Whenever possible (i.e., when a sub-system covering one or more lost source symbols is of full rank), decoding is performed in order to recover lost source symbols. Gaussian elimination is one possible algorithm to solve this linear system. Each time an ADUI can be totally recovered, padding is removed (thanks to the Length field, L, of the ADUI) and the ADU is assigned to the corresponding application flow (thanks to the Flow ID field, F, of the ADUI). This ADU is finally passed to the corresponding upper application. Received FEC Source Packets, containing an ADU, MAY be passed to the application either immediately or after some time to guaranty an ordered delivery to the application. This document does not mandate any approach as this is an operational and management decision.",
      "ja": "FECFRAME受信機は、受信および損失したソースシンボルを変数とする線形システムを維持する必要があります。 FEC修復パケットを受信すると、受信者はまず、含まれているすべての修復シンボルを抽出します（複数の修復シンボルが一緒にパックされている場合）。各修復シンボルについて、保護する対応するソースシンボルの少なくとも1つが失われた場合、受信機は線形システムに方程式を追加します（または、この修復パケットが線形システムランクを変更しない場合は方程式を追加しません）。もちろん、この方程式は、修復FECペイロードIDに含まれる修復キーとエンコードウィンドウの説明を使用して、同じ係数生成関数（3.6項）で計算されるew_sizeコーディング係数を再利用します。可能な場合はいつでも（つまり、1つ以上の失われたソースシンボルをカバーするサブシステムがフルランクの場合）、失われたソースシンボルを回復するためにデコードが実行されます。ガウス消去法は、この線形システムを解決するための可能なアルゴリズムの1つです。 ADUIを完全に回復できるたびに、パディングが削除され（ADUIのLengthフィールドLのおかげ）、ADUが対応するアプリケーションフローに割り当てられます（ADUIのFlow IDフィールドFのおかげ）。このADUは最終的に、対応する上位アプリケーションに渡されます。 ADUを含む受信したFECソースパケットは、すぐに、またはアプリケーションへの順序付き配信を保証するためにしばらくしてからアプリケーションに渡すことができます。これは運用および管理上の決定であるため、このドキュメントではアプローチを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "With real-time flows, a lost ADU that is decoded after the maximum latency or an ADU received after this delay has no value to the application. This raises the question of deciding whether or not an ADU is late. This decision MAY be taken within the FECFRAME receiver (e.g., using the decoding window, see Section 3.1) or within the application (e.g., using RTP timestamps within the ADU). Deciding which option to follow and whether or not to pass all ADUs, including those assumed late, to the application are operational decisions that depend on the application and are therefore out of scope of this document. Additionally, Appendix D discusses a backward compatible optimization whereby late source symbols MAY still be used within the FECFRAME receiver in order to improve transmission robustness.",
      "ja": "リアルタイムフローでは、最大遅延後にデコードされた失われたADU、またはこの遅延後に受信されたADUは、アプリケーションにとって価値がありません。 これにより、ADUが遅れているかどうかを判断する問題が生じます。 この決定は、FECFRAME受信機内で（たとえば、デコードウィンドウを使用して、セクション3.1を参照）、またはアプリケーション内で（たとえば、ADU内のRTPタイムスタンプを使用して）行うことができます。 従うべきオプションと、すべてのADU（後で想定されるものを含む）をアプリケーションに渡すかどうかの決定は、アプリケーションに依存する運用上の決定であるため、このドキュメントの範囲外です。 さらに、付録Dでは、後方互換性のある最適化について説明します。これにより、伝送の堅牢性を向上させるために、FECFRAME受信機内で遅延ソースシンボルを使用することができます。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The FEC Framework document [RFC6363] provides a fairly comprehensive analysis of security considerations applicable to FEC schemes. Therefore, the present section follows the security considerations section of [RFC6363] and only discusses specific topics.",
      "ja": "FECフレームワークドキュメント[RFC6363]は、FECスキームに適用可能なセキュリティに関する考慮事項のかなり包括的な分析を提供します。 したがって、このセクションは[RFC6363]のセキュリティに関する考慮事項のセクションに続き、特定のトピックのみを説明します。"
    },
    {
      "indent": 0,
      "text": "7.1. Attacks Against the Data Flow",
      "section_title": true,
      "ja": "7.1. データフローに対する攻撃"
    },
    {
      "indent": 0,
      "text": "7.1.1. Access to Confidential Content",
      "section_title": true,
      "ja": "7.1.1. 機密コンテンツへのアクセス"
    },
    {
      "indent": 3,
      "text": "The Sliding Window RLC FEC scheme specified in this document does not change the recommendations of [RFC6363]. To summarize, if confidentiality is a concern, it is RECOMMENDED that one of the solutions mentioned in [RFC6363] is used with special considerations to the way this solution is applied (e.g., is encryption applied before or after FEC protection, within the end system or in a middlebox), to the operational constraints (e.g., performing FEC decoding in a protected environment may be complicated or even impossible) and to the threat model.",
      "ja": "このドキュメントで指定されたスライディングウィンドウRLC FECスキームは、[RFC6363]の推奨事項を変更しません。 要約すると、機密性が懸念される場合は、[RFC6363]に記載されているソリューションのいずれかを、このソリューションの適用方法に特別な考慮を払って使用することをお勧めします（たとえば、FEC保護の前後にエンドシステム内で暗号化を適用します） または、ミドルボックス内）、運用上の制約（たとえば、保護された環境でFECデコードを実行することは複雑または不可能な場合もあります）および脅威モデルに対して。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Content Corruption",
      "section_title": true,
      "ja": "7.1.2. コンテンツの破損"
    },
    {
      "indent": 3,
      "text": "The Sliding Window RLC FEC scheme specified in this document does not change the recommendations of [RFC6363]. To summarize, it is RECOMMENDED that one of the solutions mentioned in [RFC6363] is used on both the FEC Source and Repair Packets.",
      "ja": "このドキュメントで指定されたスライディングウィンドウRLC FECスキームは、[RFC6363]の推奨事項を変更しません。 要約すると、[RFC6363]に記載されているソリューションの1つがFECソースと修復パケットの両方で使用されることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Attacks Against the FEC Parameters",
      "section_title": true,
      "ja": "7.2. FECパラメータに対する攻撃"
    },
    {
      "indent": 3,
      "text": "The FEC scheme specified in this document defines parameters that can be the basis of attacks. More specifically, the following parameters of the FFCI may be modified by an attacker who targets receivers (Section 4.1.1.2):",
      "ja": "このドキュメントで指定されたFECスキームは、攻撃の基礎となりうるパラメータを定義しています。 より具体的には、FFCIの以下のパラメーターは、受信者をターゲットとする攻撃者によって変更される可能性があります（4.1.1.2項）。"
    },
    {
      "indent": 3,
      "text": "FEC Encoding ID: changing this parameter leads a receiver to consider a different FEC scheme. The consequences are severe, the format of the Explicit Source FEC Payload ID and Repair FEC Payload ID of received packets will probably differ, leading to various malfunctions. Even if the original and modified FEC schemes share the same format, FEC decoding will either fail or lead to corrupted decoded symbols. This will happen if an attacker turns value 9 (i.e., RLC over GF(2)) to value 10 (RLC over GF(2^(8))), an additional consequence being a higher processing overhead at the receiver. In any case, the attack results in a form of Denial of Service (DoS) or corrupted content.",
      "ja": "FECエンコーディングID：このパラメーターを変更すると、受信者は異なるFECスキームを考慮するようになります。 結果は深刻であり、受信パケットの明示的ソースFECペイロードIDと修復FECペイロードIDの形式がおそらく異なるため、さまざまな誤動作が発生します。 元のFECスキームと変更されたFECスキームが同じ形式を共有している場合でも、FECデコードは失敗するか、デコードされたシンボルが破損します。 これは、攻撃者が値9（つまり、GF（2）上のRLC）を値10（GF（2 ^（8））上のRLC）に変更した場合に発生します。追加の結果は、受信側での処理オーバーヘッドが高くなります。 いずれにせよ、攻撃の結果、サービス拒否（DoS）または破損したコンテンツが発生します。"
    },
    {
      "indent": 3,
      "text": "Encoding symbol length (E): setting this E parameter to a different value will confuse a receiver. If the size of a received FEC Repair Packet is no longer multiple of the modified E value, a receiver quickly detects a problem and SHOULD reject the packet. If the new E value is a sub-multiple of the original E value (e.g., half the original value), then receivers may not detect the problem immediately. For instance, a receiver may think that a received FEC Repair Packet contains more repair symbols (e.g., twice as many if E is reduced by half), leading to malfunctions whose nature depends on implementation details. Here also, the attack always results in a form of DoS or corrupted content.",
      "ja": "エンコードシンボル長（E）：このEパラメーターを別の値に設定すると、レシーバーが混乱します。 受信したFEC修復パケットのサイズが変更されたE値の倍数でなくなった場合、受信者は問題をすぐに検出し、パケットを拒否する必要があります。 新しいE値が元のE値の約数（たとえば、元の値の半分）である場合、受信者は問題をすぐに検出しない可能性があります。 たとえば、受信者は、受信したFEC修復パケットがより多くの修復シンボル（たとえば、Eを半分に減らすと2倍）を含むと考え、実装の詳細に依存する性質の誤動作を引き起こすことがあります。 ここでも、攻撃は常にDoSまたは破損したコンテンツの形になります。"
    },
    {
      "indent": 3,
      "text": "It is therefore RECOMMENDED that security measures be taken to guarantee the FFCI integrity, as specified in [RFC6363]. How to achieve this depends on the way the FFCI is communicated from the sender to the receiver, which is not specified in this document.",
      "ja": "したがって、[RFC6363]で指定されているように、FFCIの整合性を保証するためにセキュリティ対策を講じることをお勧めします。 これを実現する方法は、FFCIが送信者から受信者に通信される方法によって異なりますが、このドキュメントでは指定されていません。"
    },
    {
      "indent": 3,
      "text": "Similarly, attacks are possible against the Explicit Source FEC Payload ID and Repair FEC Payload ID. More specifically, in case of a FEC Source Packet, the following value can be modified by an attacker who targets receivers:",
      "ja": "同様に、明示的なソースFECペイロードIDおよび修復FECペイロードIDに対する攻撃が可能です。 より具体的には、FECソースパケットの場合、受信者をターゲットとする攻撃者は次の値を変更できます。"
    },
    {
      "indent": 3,
      "text": "Encoding Symbol ID (ESI): changing the ESI leads a receiver to consider a wrong ADU, resulting in severe consequences, including corrupted content passed to the receiving application;",
      "ja": "エンコードシンボルID（ESI）：ESIを変更すると、受信者は間違ったADUを考慮するようになり、受信アプリケーションに渡された破損したコンテンツを含む深刻な結果になります。"
    },
    {
      "indent": 3,
      "text": "And in case of a FEC Repair Packet:",
      "ja": "FEC修理パケットの場合："
    },
    {
      "indent": 3,
      "text": "Repair Key: changing this value leads a receiver to generate a wrong coding coefficient sequence, and therefore any source symbol decoded using the repair symbols contained in this packet will be corrupted;",
      "ja": "修復キー：この値を変更すると、受信機が誤ったコーディング係数シーケンスを生成するため、このパケットに含まれる修復シンボルを使用してデコードされたソースシンボルが破損します。"
    },
    {
      "indent": 3,
      "text": "DT: changing this value also leads a receiver to generate a wrong coding coefficient sequence, and therefore any source symbol decoded using the repair symbols contained in this packet will be corrupted. In addition, if the DT value is significantly increased, it will generate a higher processing overhead at a receiver. In case of very large encoding windows, this may impact the terminal performance;",
      "ja": "DT：この値を変更すると、レシーバーが誤ったコーディング係数シーケンスを生成するため、このパケットに含まれる修復シンボルを使用してデコードされたソースシンボルが破損します。 さらに、DT値が大幅に増加すると、受信側でより高い処理オーバーヘッドが生成されます。 エンコードウィンドウが非常に大きい場合、これは端末のパフォーマンスに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "NSS: changing this value leads a receiver to consider a different set of source symbols, and therefore any source symbol decoded using the repair symbols contained in this packet will be corrupted. In addition, if the NSS value is significantly increased, it will generate a higher processing overhead at a receiver, which may impact the terminal performance;",
      "ja": "NSS：この値を変更すると、レシーバーは異なるソースシンボルセットを考慮するようになるため、このパケットに含まれる修復シンボルを使用してデコードされたソースシンボルは破損します。 さらに、NSS値が大幅に増加すると、受信機でより高い処理オーバーヘッドが生成され、端末のパフォーマンスに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "FSS_ESI: changing this value also leads a receiver to consider a different set of source symbols and therefore any source symbol decoded using the repair symbols contained in this packet will be corrupted.",
      "ja": "FSS_ESI：この値を変更すると、受信者はソースシンボルの異なるセットを考慮するようになるため、このパケットに含まれる修復シンボルを使用してデコードされたソースシンボルは破損します。"
    },
    {
      "indent": 3,
      "text": "It is therefore RECOMMENDED that security measures are taken to guarantee the FEC Source and Repair Packets as stated in [RFC6363].",
      "ja": "したがって、[RFC6363]で述べられているように、FECソースと修理パケットを保証するためにセキュリティ対策が講じられることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.3. When Several Source Flows are to be Protected Together",
      "section_title": true,
      "ja": "7.3. 複数のソースフローを一緒に保護する場合"
    },
    {
      "indent": 3,
      "text": "The Sliding Window RLC FEC scheme specified in this document does not change the recommendations of [RFC6363].",
      "ja": "このドキュメントで指定されたスライディングウィンドウRLC FECスキームは、[RFC6363]の推奨事項を変更しません。"
    },
    {
      "indent": 0,
      "text": "7.4. Baseline Secure FEC Framework Operation",
      "section_title": true,
      "ja": "7.4. ベースラインセキュアFECフレームワークの運用"
    },
    {
      "indent": 3,
      "text": "The Sliding Window RLC FEC scheme specified in this document does not change the recommendations of [RFC6363] concerning the use of the IPsec/Encapsulating Security Payload (ESP) security protocol as a mandatory-to-implement (but not mandatory-to-use) security scheme. This is well suited to situations where the only insecure domain is the one over which the FEC Framework operates.",
      "ja": "このドキュメントで指定されたスライディングウィンドウRLC FECスキームは、実装必須（ただし、必須ではない）としてのIPsec / Encapsulating Security Payload（ESP）セキュリティプロトコルの使用に関する[RFC6363]の推奨事項を変更しません。 セキュリティスキーム。 これは、安全でないドメインがFECフレームワークが動作するドメインのみである場合に適しています。"
    },
    {
      "indent": 0,
      "text": "7.5. Additional Security Considerations for Numerical Computations",
      "section_title": true,
      "ja": "7.5. 数値計算に関する追加のセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "In addition to the above security considerations, inherited from [RFC6363], the present document introduces several formulae, in particular in Appendix C.1. It is RECOMMENDED to check that the computed values stay within reasonable bounds since numerical overflows, caused by an erroneous implementation or an erroneous input value, may lead to hazardous behaviors. However, what \"reasonable bounds\" means is use-case and implementation dependent and is not detailed in this document.",
      "ja": "[RFC6363]から継承した上記のセキュリティの考慮事項に加えて、本書では、特に付録C.1でいくつかの式を紹介しています。 誤った実装または誤った入力値に起因する数値のオーバーフローが危険な動作を引き起こす可能性があるため、計算値が妥当な範囲内にあることを確認することをお勧めします。 ただし、「合理的な範囲」が意味するものはユースケースと実装に依存するため、このドキュメントでは詳しく説明しません。"
    },
    {
      "indent": 3,
      "text": "Appendix C.2 also mentions the possibility of \"using the timestamp field of an RTP packet header\" when applicable. A malicious attacker may deliberately corrupt this header field in order to trigger hazardous behaviors at a FECFRAME receiver. Protection against this type of content corruption can be addressed with the above recommendations on a baseline secure operation. In addition, it is also RECOMMENDED to check that the timestamp value be within reasonable bounds.",
      "ja": "付録C.2では、該当する場合に「RTPパケットヘッダーのタイムスタンプフィールドを使用する」可能性についても言及しています。 悪意のある攻撃者は、FECFRAMEレシーバーで危険な動作をトリガーするために、このヘッダーフィールドを故意に破損する可能性があります。 このタイプのコンテンツ破損に対する保護は、ベースラインの安全な運用に関する上記の推奨事項で対処できます。 さらに、タイムスタンプ値が妥当な範囲内にあることを確認することもお勧めします。"
    },
    {
      "indent": 0,
      "text": "8. Operations and Management Considerations",
      "section_title": true,
      "ja": "8. 運用と管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The FEC Framework document [RFC6363] provides a fairly comprehensive analysis of operations and management considerations applicable to FEC schemes. Therefore, the present section only discusses specific topics.",
      "ja": "FECフレームワーク文書[RFC6363]は、FECスキームに適用可能な運用と管理の考慮事項のかなり包括的な分析を提供します。 したがって、このセクションでは特定のトピックについてのみ説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Operational Recommendations: Finite Field GF(2) Versus GF(2^(8))",
      "section_title": true,
      "ja": "8.1. 運用上の推奨事項：有限体GF（2）対GF（2 ^（8））"
    },
    {
      "indent": 3,
      "text": "The present document specifies two FEC schemes that differ on the Finite Field used for the coding coefficients. It is expected that the RLC over GF(2^(8)) FEC scheme will be mostly used since it warrants a higher packet loss protection. In case of small encoding windows, the associated processing overhead is not an issue (e.g., we measured decoding speeds between 745 Mbps and 2.8 Gbps on an ARM Cortex-A15 embedded board in [Roca17] depending on the code rate and the channel conditions, using an encoding window of size 18 or 23 symbols; see the above article for the details). Of course the CPU overhead will increase with the encoding window size, because more operations in the GF(2^(8)) finite field will be needed.",
      "ja": "本書では、コーディング係数に使用される有限フィールドが異なる2つのFECスキームを指定します。 RLC over GF（2 ^（8））FECスキームは、より高いパケット損失保護を保証するため、主に使用されることが予想されます。 エンコードウィンドウが小さい場合、関連する処理オーバーヘッドは問題になりません（たとえば、[Roca17]のARM Cortex-A15組み込みボードで、コードレートとチャネル条件に応じて、745 Mbps〜2.8 Gbpsのデコード速度を測定しました。 サイズ18または23シンボルのエンコードウィンドウを使用します。詳細については、上記の記事を参照してください。 もちろん、GF（2 ^（8））有限体でより多くの操作が必要になるため、エンコードウィンドウサイズとともにCPUオーバーヘッドが増加します。"
    },
    {
      "indent": 3,
      "text": "The RLC over GF(2) FEC scheme offers an alternative. In that case operations symbols can be directly XOR-ed together which warrants high bitrate encoding and decoding operations, and can be an advantage with large encoding windows. However, packet loss protection is significantly reduced by using this FEC scheme.",
      "ja": "RLC over GF（2）FECスキームは、代替手段を提供します。 その場合、操作シンボルを直接XORで結合できます。これにより、高ビットレートのエンコードおよびデコード操作が保証され、大きなエンコードウィンドウでの利点が得られます。 ただし、このFECスキームを使用すると、パケット損失保護が大幅に低下します。"
    },
    {
      "indent": 0,
      "text": "8.2. Operational Recommendations: Coding Coefficients Density Threshold",
      "section_title": true,
      "ja": "8.2. 運用上の推奨事項：コーディング係数密度しきい値"
    },
    {
      "indent": 3,
      "text": "In addition to the choice of the Finite Field, the two FEC schemes define a coding coefficient density threshold (DT) parameter. This parameter enables a sender to control the code density, i.e., the proportion of coefficients that are nonzero on average. With RLC over GF(2^(8)), it is usually appropriate that small encoding windows be associated to a density threshold equal to 15, the maximum value, in order to warrant a high loss protection.",
      "ja": "有限フィールドの選択に加えて、2つのFECスキームはコーディング係数密度しきい値（DT）パラメーターを定義します。 このパラメーターにより、送信者はコード密度、つまり平均でゼロ以外の係数の割合を制御できます。 GF（2 ^（8））を介したRLCでは、高い損失保護を保証するために、小さなエンコードウィンドウを最大値である15に等しい密度しきい値に関連付けることが通常適切です。"
    },
    {
      "indent": 3,
      "text": "On the opposite, with larger encoding windows, it is usually appropriate that the density threshold be reduced. With large encoding windows, an alternative can be to use RLC over GF(2) and a density threshold equal to 7 (i.e., an average density equal to 1/2) or smaller.",
      "ja": "反対に、エンコードウィンドウが大きい場合、通常は密度のしきい値を下げることが適切です。 エンコードウィンドウが大きい場合、代替手段として、GF（2）上のRLCと7に等しい密度しきい値（つまり、平均密度が1/2に等しい）以下を使用できます。"
    },
    {
      "indent": 3,
      "text": "Note that using a density threshold equal to 15 with RLC over GF(2) is equivalent to using an XOR code that computes the XOR sum of all the source symbols in the encoding window. In that case: (1) only a single repair symbol can be produced for any encoding window, and (2) the repair_key parameter becomes useless (the coding coefficients generation function does not rely on the PRNG).",
      "ja": "GF（2）上のRLCで15に等しい密度しきい値を使用することは、エンコードウィンドウ内のすべてのソースシンボルのXOR合計を計算するXORコードを使用することと同等であることに注意してください。 その場合：（1）任意のエンコードウィンドウに対して1つの修復シンボルしか生成できず、（2）repair_keyパラメーターが使用できなくなります（コーディング係数生成関数はPRNGに依存しません）。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers two values in the \"FEC Framework (FECFRAME) FEC Encoding IDs\" registry [RFC6363] as follows:",
      "ja": "このドキュメントは、「FECフレームワーク（FECFRAME）FECエンコーディングID」レジストリ[RFC6363]に次の2つの値を登録します。"
    },
    {
      "indent": 3,
      "text": "* 9 refers to the Sliding Window Random Linear Codes (RLC) over GF(2) FEC Scheme for Arbitrary Packet Flows, as defined in Section 5 of this document.",
      "ja": "* 9は、このドキュメントのセクション5で定義されている、任意のパケットフロー用のGF（2）FECスキーム上のスライディングウィンドウランダム線形コード（RLC）を指します。"
    },
    {
      "indent": 3,
      "text": "* 10 refers to the Sliding Window Random Linear Codes (RLC) over GF(2^(8)) FEC Scheme for Arbitrary Packet Flows, as defined in Section 4 of this document.",
      "ja": "* 10は、このドキュメントのセクション4で定義されている任意のパケットフローのGF（2 ^（8））FECスキーム上のスライディングウィンドウランダム線形コード（RLC）を指します。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[C99] International Organization for Standardization, \"Programming languages - C: C99, correction 3:2007\", ISO/ IEC 9899:1999/Cor 3:2007, November 2007.",
      "ja": "[C99]国際標準化機構、「プログラミング言語-C：C99、修正3：2007」、ISO / IEC 9899：1999 / Cor 3：2007、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, DOI 10.17487/RFC6363, October 2011, <https://www.rfc-editor.org/info/rfc6363>.",
      "ja": "[RFC6363] Watson、M.、Begen、A。、およびV. Roca、「Forward Error Correction（FEC）Framework」、RFC 6363、DOI 10.17487 / RFC6363、2011年10月、<https：//www.rfc-editor。 org / info / rfc6363>。"
    },
    {
      "indent": 3,
      "text": "[RFC6364] Begen, A., \"Session Description Protocol Elements for the Forward Error Correction (FEC) Framework\", RFC 6364, DOI 10.17487/RFC6364, October 2011, <https://www.rfc-editor.org/info/rfc6364>.",
      "ja": "[RFC6364] Begen、A。、「前方誤り訂正（FEC）フレームワークのセッション記述プロトコル要素」、RFC 6364、DOI 10.17487 / RFC6364、2011年10月、<https://www.rfc-editor.org/info/ rfc6364>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8680] Roca, V. and A. Begen, \"Forward Error Correction (FEC) Framework Extension to Sliding Window Codes\", RFC 8680, DOI 10.17487/RFC8680, January 2020, <https://www.rfc-editor.org/info/rfc8680>.",
      "ja": "[RFC8680] Roca、V。、およびA. Begen、「スライディングウィンドウコードへの前方誤り訂正（FEC）フレームワーク拡張」、RFC 8680、DOI 10.17487 / RFC8680、2020年1月、<https://www.rfc-editor.org / info / rfc8680>。"
    },
    {
      "indent": 3,
      "text": "[RFC8682] Saito, M., Matsumoto, M., Roca, V., Ed., and E. Baccelli, \"TinyMT32 Pseudorandom Number Generator (PRNG)\", RFC 8682, DOI 10.17487/RFC8682, January 2020, <https://www.rfc-editor.org/info/rfc8682>.",
      "ja": "[RFC8682]斉藤M.、松本M.、ロカV.、Ed。、およびE. Baccelli、「TinyMT32疑似乱数ジェネレーター（PRNG）」、RFC 8682、DOI 10.17487 / RFC8682、2020年1月、<https： //www.rfc-editor.org/info/rfc8682>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[PGM13] Plank, J., Greenan, K., and E. Miller, \"A Complete Treatment of Software Implementations of Finite Field Arithmetic for Erasure Coding Applications\", University of Tennessee Technical Report UT-CS-13-717, October 2013, <http://web.eecs.utk.edu/~plank/plank/papers/UT-CS-13-717.html>.",
      "ja": "[PGM13] Plank、J.、Greenan、K。、およびE. Miller、「Erasure Coding Applicationsの有限フィールド演算のソフトウェア実装の完全な取り扱い」、テネシー大学テクニカルレポートUT-CS-13-717、2013年10月 、<http://web.eecs.utk.edu/~plank/plank/papers/UT-CS-13-717.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC5170] Roca, V., Neumann, C., and D. Furodet, \"Low Density Parity Check (LDPC) Staircase and Triangle Forward Error Correction (FEC) Schemes\", RFC 5170, DOI 10.17487/RFC5170, June 2008, <https://www.rfc-editor.org/info/rfc5170>.",
      "ja": "[RFC5170] Roca、V.、Neumann、C。、およびD. Furodet、「低密度パリティチェック（LDPC）階段および三角形前方誤り訂正（FEC）スキーム」、RFC 5170、DOI 10.17487 / RFC5170、2008年6月、< https://www.rfc-editor.org/info/rfc5170>。"
    },
    {
      "indent": 3,
      "text": "[RFC5510] Lacan, J., Roca, V., Peltotalo, J., and S. Peltotalo, \"Reed-Solomon Forward Error Correction (FEC) Schemes\", RFC 5510, DOI 10.17487/RFC5510, April 2009, <https://www.rfc-editor.org/info/rfc5510>.",
      "ja": "[RFC5510] Lacan、J.、Roca、V.、Peltotalo、J。、およびS. Peltotalo、「リードソロモン前方誤り訂正（FEC）スキーム」、RFC 5510、DOI 10.17487 / RFC5510、2009年4月、<https： //www.rfc-editor.org/info/rfc5510>。"
    },
    {
      "indent": 3,
      "text": "[RFC6681] Watson, M., Stockhammer, T., and M. Luby, \"Raptor Forward Error Correction (FEC) Schemes for FECFRAME\", RFC 6681, DOI 10.17487/RFC6681, August 2012, <https://www.rfc-editor.org/info/rfc6681>.",
      "ja": "[RFC6681]ワトソン、M。、ストックハンマー、T。、およびM.ルビー、「FECFRAMEのラプターフォワードエラー訂正（FEC）スキーム」、RFC 6681、DOI 10.17487 / RFC6681、2012年8月、<https：//www.rfc -editor.org/info/rfc6681>。"
    },
    {
      "indent": 3,
      "text": "[RFC6726] Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen, \"FLUTE - File Delivery over Unidirectional Transport\", RFC 6726, DOI 10.17487/RFC6726, November 2012, <https://www.rfc-editor.org/info/rfc6726>.",
      "ja": "[RFC6726]パイラ、T。、ウォルシュ、R。、ルビー、M。、ロカ、V。、およびR.レートネン、「FLUTE-単方向トランスポートを介したファイル配信」、RFC 6726、DOI 10.17487 / RFC6726、2012年11月、< https://www.rfc-editor.org/info/rfc6726>。"
    },
    {
      "indent": 3,
      "text": "[RFC6816] Roca, V., Cunche, M., and J. Lacan, \"Simple Low-Density Parity Check (LDPC) Staircase Forward Error Correction (FEC) Scheme for FECFRAME\", RFC 6816, DOI 10.17487/RFC6816, December 2012, <https://www.rfc-editor.org/info/rfc6816>.",
      "ja": "[RFC6816] Roca、V.、Cunche、M。、およびJ. Lacan、「FECFRAMEの簡易低密度パリティチェック（LDPC）階段順方向誤り訂正（FEC）スキーム」、RFC 6816、DOI 10.17487 / RFC6816、2012年12月 、<https://www.rfc-editor.org/info/rfc6816>。"
    },
    {
      "indent": 3,
      "text": "[RFC6865] Roca, V., Cunche, M., Lacan, J., Bouabdallah, A., and K. Matsuzono, \"Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME\", RFC 6865, DOI 10.17487/RFC6865, February 2013, <https://www.rfc-editor.org/info/rfc6865>.",
      "ja": "[RFC6865] Roca、V.、Cunche、M.、Lacan、J.、Bouabdallah、A.、K。 RFC6865、2013年2月、<https://www.rfc-editor.org/info/rfc6865>。"
    },
    {
      "indent": 3,
      "text": "[RFC8406] Adamson, B., Adjih, C., Bilbao, J., Firoiu, V., Fitzek, F., Ghanem, S., Lochin, E., Masucci, A., Montpetit, M-J., Pedersen, M., Peralta, G., Roca, V., Ed., Saxena, P., and S. Sivakumar, \"Taxonomy of Coding Techniques for Efficient Network Communications\", RFC 8406, DOI 10.17487/RFC8406, June 2018, <https://www.rfc-editor.org/info/rfc8406>.",
      "ja": "[RFC8406] Adamson、B.、Adjih、C.、Bilbao、J.、Firoiu、V.、Fitzek、F.、Ghanem、S.、Lochin、E.、Masucci、A.、Montpetit、MJ。、Pedersen、 M.、Peralta、G.、Roca、V.、Ed。、Saxena、P。、およびS. Sivakumar、「効率的なネットワーク通信のためのコーディング技術の分類」、RFC 8406、DOI 10.17487 / RFC8406、2018年6月、<https ：//www.rfc-editor.org/info/rfc8406>。"
    },
    {
      "indent": 3,
      "text": "[Roca16] Roca, V., Teibi, B., Burdinat, C., Tran-Thai, T., and C. Thienot, \"Block or Convolutional AL-FEC Codes? A Performance Comparison for Robust Low-Latency Communications\", HAL ID hal-01395937v2, February 2017, <https://hal.inria.fr/hal-01395937/en/>.",
      "ja": "[Roca16] Roca、V.、Teibi、B.、Burdinat、C.、Tran-Thai、T。、およびC. Thienot、「ブロックまたは畳み込みAL-FECコード？堅牢な低遅延通信のパフォーマンス比較」、 HAL ID hal-01395937v2、2017年2月、<https://hal.inria.fr/hal-01395937/en/>。"
    },
    {
      "indent": 3,
      "text": "[Roca17] Roca, V., Teibi, B., Burdinat, C., Tran, T., and C. Thienot, \"Less Latency and Better Protection with AL-FEC Sliding Window Codes: a Robust Multimedia CBR Broadcast Case Study\", 13th IEEE International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob17), HAL ID hal-01571609, October 2017, <https://hal.inria.fr/hal-01571609v1/en/>.",
      "ja": "[Roca17] Roca、V.、Teibi、B.、Burdinat、C.、Tran、T。、およびC. Thienot、「AL-FECスライディングウィンドウコードを使用したレイテンシーの低減と保護の強化：堅牢なマルチメディアCBRブロードキャストケーススタディ」 、ワイヤレスおよびモバイルコンピューティング、ネットワーキングおよび通信に関する第13回IEEE国際会議（WiMob17）、HAL ID hal-01571609、2017年10月、<https://hal.inria.fr/hal-01571609v1/en/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. TinyMT32 Validation Criteria (Normative)",
      "section_title": true,
      "ja": "付録A. TinyMT32検証基準（規範）"
    },
    {
      "indent": 3,
      "text": "PRNG determinism, for a given seed, is a requirement. Consequently, in order to validate an implementation of the TinyMT32 PRNG, the following criteria MUST be met.",
      "ja": "所定のシードに対するPRNG決定論は必須です。 したがって、TinyMT32 PRNGの実装を検証するには、次の基準を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "The first criterion focuses on the tinymt32_rand256(), where the 32-bit integer of the core TinyMT32 PRNG is scaled down to an 8-bit integer. Using a seed value of 1, the first 50 values returned by: tinymt32_rand256() as 8-bit unsigned integers MUST be equal to values provided in Figure 9, to be read line by line.",
      "ja": "最初の基準は、コアTinyMT32 PRNGの32ビット整数が8ビット整数に縮小されるtinymt32_rand256（）に焦点を当てています。 シード値1を使用すると、8ビットの符号なし整数としてtinymt32_rand256（）が返す最初の50個の値は、図9で提供される値と等しくなければならず、1行ずつ読み取られます。"
    },
    {
      "indent": 10,
      "text": " 37 225 177 176 21 246 54 139 168 237 211 187 62 190 104 135 210 99 176 11 207 35 40 113 179 214 254 101 212 211 226 41 234 232 203 29 194 211 112 107 217 104 197 135 23 89 210 252 109 166",
      "ja": "37 225 177 176 21 246 54139 168 237 211 187 62 190 104 135 210 99 176 11 207 35 40 113 179 214 254 101 212 211 226 41 234 232 203 29 194 211 112 107 217 104 197 135 23 89 210 252 109166"
    },
    {
      "indent": 3,
      "text": " Figure 9: First 50 decimal values (to be read per line) returned by\ntinymt32_rand256() as 8-bit unsigned integers, with a seed value of 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The second criterion focuses on the tinymt32_rand16(), where the 32-bit integer of the core TinyMT32 PRNG is scaled down to a 4-bit integer. Using a seed value of 1, the first 50 values returned by: tinymt32_rand16() as 4-bit unsigned integers MUST be equal to values provided in Figure 10, to be read line by line.",
      "ja": "2番目の基準は、コアTinyMT32 PRNGの32ビット整数が4ビット整数に縮小されるtinymt32_rand16（）に焦点を当てています。 シード値1を使用すると、4ビットの符号なし整数としてtinymt32_rand16（）によって返される最初の50個の値は、図10で提供される値と等しくなければならず、1行ずつ読み取られます。"
    },
    {
      "indent": 11,
      "text": " 5 1 1 0 5 6 6 11 8 13 3 11 14 14 8 7 2 3 0 11 15 3 8 1 3 6 14 5 4 3 2 9 10 8 11 13 2 3 0 11 9 8 5 7 7 9 2 12 13 6",
      "ja": "5 1 1 0 5 6 6 11 8 13 3 11 14 14 8 7 2 3 0 11 15 3 8 1 3 6 14 5 4 3 2 9 10 8 11 13 2 3 0 11 9 8 5 7 7 9 2 12 13 6"
    },
    {
      "indent": 4,
      "text": "Figure 10: First 50 decimal values (to be read per line) returned by\ntinymt32_rand16() as 4-bit unsigned integers, with a seed value of 1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. Assessing the PRNG Adequacy (Informational)",
      "section_title": true,
      "ja": "付録B. PRNGの妥当性の評価（情報）"
    },
    {
      "indent": 3,
      "text": "This annex discusses the adequacy of the TinyMT32 PRNG and the tinymt32_rand16() and tinymt32_rand256() functions, to the RLC FEC schemes. The goal is to assess the adequacy of these two functions in producing coding coefficients that are sufficiently different from one another, across various repair symbols with repair key values in sequence (we can expect this approach to be commonly used by implementers, see Section 6.1). This section is purely informational and does not claim to be a solid evaluation.",
      "ja": "この付録では、TinyMT32 PRNG、tinymt32_rand16（）およびtinymt32_rand256（）関数のRLC FECスキームに対する妥当性について説明します。 目標は、これらの2つの関数の妥当性を評価し、修復キー値を含むさまざまな修復シンボルにわたって、互いに十分に異なるコーディング係数を生成することです（このアプローチは、実装者が一般的に使用することを期待できます。セクション6.1を参照）。 。 このセクションは純粋に情報提供であり、確実な評価であると主張するものではありません。"
    },
    {
      "indent": 3,
      "text": "The two RLC FEC schemes use the PRNG to produce pseudorandom coding coefficients (Section 3.6), each time a new repair symbol is needed. A different repair key is used for each repair symbol, usually by incrementing the repair key value (Section 6.1). For each repair symbol, a limited number of pseudorandom numbers is needed, depending on the DT and encoding window size (Section 3.6), using either tinymt32_rand16() or tinymt32_rand256(). Therefore, we are more interested in the randomness of small sequences of random numbers mapped to 4-bit or 8-bit integers, than in the randomness of a very large sequence of random numbers which is not representative of the usage of the PRNG.",
      "ja": "2つのRLC FECスキームは、新しい修復シンボルが必要になるたびに、PRNGを使用して擬似ランダムコーディング係数（3.6項）を生成します。 通常、修復キーの値をインクリメントすることにより、各修復シンボルに異なる修復キーが使用されます（セクション6.1）。 修復シンボルごとに、tinymt32_rand16（）またはtinymt32_rand256（）を使用して、DTおよびエンコードウィンドウサイズ（3.6項）に応じて、限られた数の疑似乱数が必要です。 したがって、PRNGの使用法を表していない非常に大きな乱数シーケンスのランダム性よりも、4ビットまたは8ビット整数にマップされた小さな乱数シーケンスのランダム性に関心があります。"
    },
    {
      "indent": 3,
      "text": "Evaluation of tinymt32_rand16(): We first generate a huge number (1,000,000,000) of small sequences (20 pseudorandom numbers per sequence), increasing the seed value for each sequence, and perform statistics on the number of occurrences of each of the 16 possible values across all sequences. In this first test we consider 32-bit seed values in order to assess the PRNG quality after output truncation to 4 bits.",
      "ja": "tinymt32_rand16（）の評価：最初に膨大な数（1,000,000,000）の小さなシーケンス（シーケンスごとに20の擬似乱数）を生成し、各シーケンスのシード値を増やし、16の可能な値のそれぞれの出現回数に関する統計を実行します すべてのシーケンス。 この最初のテストでは、4ビットへの出力切り捨て後のPRNG品質を評価するために、32ビットのシード値を考慮します。"
    },
    {
      "indent": 17,
      "text": "+-------+-------------+----------------+\n| Value | Occurrences | Percentage (%) |\n+=======+=============+================+\n| 0     | 1250036799  | 6.2502         |\n+-------+-------------+----------------+\n| 1     | 1249995831  | 6.2500         |\n+-------+-------------+----------------+\n| 2     | 1250038674  | 6.2502         |\n+-------+-------------+----------------+\n| 3     | 1250000881  | 6.2500         |\n+-------+-------------+----------------+\n| 4     | 1250023929  | 6.2501         |\n+-------+-------------+----------------+\n| 5     | 1249986320  | 6.2499         |\n+-------+-------------+----------------+\n| 6     | 1249995587  | 6.2500         |\n+-------+-------------+----------------+\n| 7     | 1250020363  | 6.2501         |\n+-------+-------------+----------------+\n| 8     | 1249995276  | 6.2500         |\n+-------+-------------+----------------+\n| 9     | 1249982856  | 6.2499         |\n+-------+-------------+----------------+\n| 10    | 1249984111  | 6.2499         |\n+-------+-------------+----------------+\n| 11    | 1250009551  | 6.2500         |\n+-------+-------------+----------------+\n| 12    | 1249955768  | 6.2498         |\n+-------+-------------+----------------+\n| 13    | 1249994654  | 6.2500         |\n+-------+-------------+----------------+\n| 14    | 1250000569  | 6.2500         |\n+-------+-------------+----------------+\n| 15    | 1249978831  | 6.2499         |\n+-------+-------------+----------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 1: tinymt32_rand16() Occurrence Statistics",
      "ja": "表1：tinymt32_rand16（）オカレンス統計"
    },
    {
      "indent": 3,
      "text": "Evaluation of tinymt32_rand16(): We first generate a huge number (1,000,000,000) of small sequences (20 pseudorandom numbers per sequence), increasing the seed value for each sequence, and perform statistics on the number of occurrences of each of the 16 possible values across the 20,000,000,000 numbers of all sequences. In this first test, we consider 32-bit seed values in order to assess the PRNG quality after output truncation to 4 bits.",
      "ja": "tinymt32_rand16（）の評価：最初に膨大な数（1,000,000,000）の小さなシーケンス（シーケンスごとに20の疑似乱数）を生成し、各シーケンスのシード値を増やして、16の可能な値のそれぞれの出現回数に関する統計を実行します すべてのシーケンスの20,000,000,000数。 この最初のテストでは、4ビットへの出力切り捨て後のPRNG品質を評価するために、32ビットのシード値を考慮します。"
    },
    {
      "indent": 3,
      "text": "The results (Table 1) show that all possible values are almost equally represented, or said differently, that the tinymt32_rand16() output converges to a uniform distribution where each of the 16 possible values would appear exactly 1 / 16 * 100 = 6.25% of times.",
      "ja": "結果（表1）は、すべての可能な値がほぼ等しく表現されている、または異なる言い方をして、tinymt32_rand16（）出力が均一な分布に収束し、16の可能な値のそれぞれが正確に1/16 * 100 = 6.25％ 回。"
    },
    {
      "indent": 3,
      "text": "Since the RLC FEC schemes use of this PRNG will be limited to 16-bit seed values, we carried out the same test for the first 2^(16) seed values only. The distribution (not shown) is of course less uniform, with value occurrences ranging between 6.2121% (i.e., 81,423 occurrences out of a total of 65536*20=1,310,720) and 6.2948% (i.e., 82,507 occurrences). However, we do not believe it significantly impacts the RLC FEC scheme behavior.",
      "ja": "このPRNGのRLC FECスキームの使用は16ビットシード値に制限されるため、最初の2 ^（16）シード値に対してのみ同じテストを実行しました。 分布（図示せず）は、もちろん、それほど均一ではなく、値の発生は6.2121％（つまり、合計65536 * 20 = 1,310,720のうち81,423回）と6.2948％（すなわち、82,507回）の範囲です。 ただし、RLC FECスキームの動作に大きな影響を与えるとは考えていません。"
    },
    {
      "indent": 3,
      "text": "Other types of biases may exist that may be visible with smaller tests, for instance to evaluate the convergence speed to a uniform distribution. We therefore perform 200 tests, each of them producing 200 sequences, keeping only the first value of each sequence. We use non-overlapping repair keys for each sequence, starting with value 0 and increasing it after each use.",
      "ja": "たとえば、均一な分布への収束速度を評価するために、より小さなテストで見られる他のタイプのバイアスが存在する場合があります。 したがって、200のテストを実行し、それぞれが200のシーケンスを生成し、各シーケンスの最初の値のみを保持します。 各シーケンスには重複しない修復キーを使用します。値0から開始し、使用するたびに値を増やします。"
    },
    {
      "indent": 4,
      "text": "+-------+-----------------+-----------------+---------------------+\n| Value | Min Occurrences | Max Occurrences | Average Occurrences |\n+=======+=================+=================+=====================+\n| 0     | 4               | 21              | 6.3675              |\n+-------+-----------------+-----------------+---------------------+\n| 1     | 4               | 22              | 6.0200              |\n+-------+-----------------+-----------------+---------------------+\n| 2     | 4               | 20              | 6.3125              |\n+-------+-----------------+-----------------+---------------------+\n| 3     | 5               | 23              | 6.1775              |\n+-------+-----------------+-----------------+---------------------+\n| 4     | 5               | 24              | 6.1000              |\n+-------+-----------------+-----------------+---------------------+\n| 5     | 4               | 21              | 6.5925              |\n+-------+-----------------+-----------------+---------------------+\n| 6     | 5               | 30              | 6.3075              |\n+-------+-----------------+-----------------+---------------------+\n| 7     | 6               | 22              | 6.2225              |\n+-------+-----------------+-----------------+---------------------+\n| 8     | 5               | 26              | 6.1750              |\n+-------+-----------------+-----------------+---------------------+\n| 9     | 3               | 21              | 5.9425              |\n+-------+-----------------+-----------------+---------------------+\n| 10    | 5               | 24              | 6.3175              |\n+-------+-----------------+-----------------+---------------------+\n| 11    | 4               | 22              | 6.4300              |\n+-------+-----------------+-----------------+---------------------+\n| 12    | 5               | 21              | 6.1600              |\n+-------+-----------------+-----------------+---------------------+\n| 13    | 5               | 22              | 6.3100              |\n+-------+-----------------+-----------------+---------------------+\n| 14    | 4               | 26              | 6.3950              |\n+-------+-----------------+-----------------+---------------------+\n| 15    | 4               | 21              | 6.1700              |\n+-------+-----------------+-----------------+---------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 2: tinymt32_rand16() Occurrence Statistics",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 2 shows across all 200 tests, for each of the 16 possible pseudorandom number values, the minimum (resp. maximum) number of times it appeared in a test, as well as the average number of occurrences across the 200 tests. Although the distribution is not perfect, there is no major bias. On the contrary, in the same conditions, the Park-Miller linear congruential PRNG of [RFC5170] with a result scaled down to 4-bit values, using seeds in sequence starting from 1, systematically returns 0 as the first value during some time. Then, after a certain repair key value threshold, it systematically returns 1, etc.",
      "ja": "表2は、200のすべてのテストで、16の可能な擬似乱数値のそれぞれ、テストに出現した最小（または最大）回数、および200のテスト全体の平均発生回数を示しています。 分布は完全ではありませんが、大きな偏りはありません。 それどころか、同じ条件で、[RFC5170]のPark-Miller線形合同PRNGは、結果を4ビット値に縮小し、1から順にシードを使用して、しばらくの間最初の値として0を体系的に返します。 次に、特定の修復キー値のしきい値の後、体系的に1を返します。"
    },
    {
      "indent": 3,
      "text": "Evaluation of tinymt32_rand256(): The same approach is used here. Results (not shown) are similar: occurrences vary between 7,810,3368 (i.e., 0.3905%) and 7,814,7952 (i.e., 0.3907%). Here also we see a convergence to the theoretical uniform distribution where each of the 256 possible values would appear exactly 1 / 256 * 100 = 0.390625% of times.",
      "ja": "tinymt32_rand256（）の評価：同じアプローチがここで使用されます。 結果（表示されていません）は似ています：発生は7,810,3368（つまり、0.3905％）から7,814,7952（つまり、0.3907％）の間で異なります。 ここでも、可能な256個の値のそれぞれが正確に1/256 * 100 = 0.390625％の時間で現れる理論上の均一分布への収束が見られます。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Possible Parameter Derivation (Informational)",
      "section_title": true,
      "ja": "付録C.可能なパラメーターの派生（情報）"
    },
    {
      "indent": 3,
      "text": "Section 3.1 defines several parameters to control the encoder or decoder. This annex proposes techniques to derive these parameters according to the target use-case. This annex is informational, in the sense that using a different derivation technique will not prevent the encoder and decoder to interoperate: a decoder can still recover an erased source symbol without any error. However, in case of a real-time flow, an inappropriate parameter derivation may lead to the decoding of erased source packets after their validity period, making them useless to the target application. This annex proposes an approach to reduce this risk, among other things.",
      "ja": "セクション3.1では、エンコーダーまたはデコーダーを制御するためのいくつかのパラメーターを定義しています。 この附属書では、ターゲットのユースケースに従ってこれらのパラメーターを導出する手法を提案しています。 この別館は、異なる導出手法を使用してもエンコーダとデコーダの相互運用を妨げないという意味で情報提供です。デコーダは、エラーなしで消去されたソースシンボルを回復できます。 ただし、リアルタイムフローの場合、不適切なパラメーターの派生により、有効期間後に消去されたソースパケットがデコードされ、ターゲットアプリケーションにとって役に立たなくなる可能性があります。 この附属書は、とりわけこのリスクを軽減するアプローチを提案しています。"
    },
    {
      "indent": 3,
      "text": "The FEC schemes defined in this document can be used in various manners, depending on the target use-case:",
      "ja": "このドキュメントで定義されているFECスキームは、ターゲットのユースケースに応じて、さまざまな方法で使用できます。"
    },
    {
      "indent": 3,
      "text": "* the source ADU flow they protect may or may not have real-time constraints;",
      "ja": "* 保護するソースADUフローには、リアルタイム制約がある場合とない場合があります。"
    },
    {
      "indent": 3,
      "text": "* the source ADU flow may be a Constant Bitrate (CBR) or Variable Bitrate (VBR) flow;",
      "ja": "* ソースADUフローは、固定ビットレート（CBR）フローまたは可変ビットレート（VBR）フローです。"
    },
    {
      "indent": 3,
      "text": "* with a VBR source ADU flow, the flow's minimum and maximum bitrates may or may not be known;",
      "ja": "* VBRソースADUフローでは、フローの最小および最大ビットレートがわかっている場合とわかっていない場合があります。"
    },
    {
      "indent": 3,
      "text": "* and the communication path between encoder and decoder may be a CBR communication path (e.g., as with certain LTE-based broadcast channels) or not (general case, e.g., with Internet).",
      "ja": "* エンコーダーとデコーダー間の通信パスは、CBR通信パス（たとえば、特定のLTEベースのブロードキャストチャネルの場合）またはそうでない場合があります（一般的な場合、たとえばインターネット）。"
    },
    {
      "indent": 3,
      "text": "The parameter derivation technique should be suited to the use-case, as described in the following sections.",
      "ja": "次のセクションで説明するように、パラメータの導出手法はユースケースに適している必要があります。"
    },
    {
      "indent": 0,
      "text": "C.1. Case of a CBR Real-Time Flow",
      "section_title": true,
      "ja": "C.1. CBRリアルタイムフローの場合"
    },
    {
      "indent": 3,
      "text": "In the following, we consider a real-time flow with max_lat latency budget. The encoding symbol size, E, is constant. The code rate, cr, is also constant, its value depending on the expected communication loss model (this choice is out of scope of this document).",
      "ja": "以下では、max_lat遅延バジェットを持つリアルタイムフローを検討します。 エンコードシンボルサイズEは一定です。 コードレートcrも一定であり、その値は予想される通信損失モデルによって異なります（この選択はこのドキュメントの範囲外です）。"
    },
    {
      "indent": 3,
      "text": "In a first configuration, the source ADU flow bitrate at the input of the FECFRAME sender is fixed and equal to br_in (in bits/s), and this value is known by the FECFRAME sender. It follows that the transmission bitrate at the output of the FECFRAME sender will be higher, depending on the added repair flow overhead. In order to comply with the maximum FEC-related latency budget, we have:",
      "ja": "最初の構成では、FECFRAME送信側の入力でのソースADUフロービットレートは固定され、br_in（ビット/秒）に等しく、この値はFECFRAME送信側に知られています。 追加された修復フローのオーバーヘッドに応じて、FECFRAM送信者の出力での伝送ビットレートが高くなります。 FEC関連の最大遅延バジェットに準拠するために、次のものを用意しています。"
    },
    {
      "indent": 6,
      "text": "dw_max_size = (max_lat * br_in) / (8 * E)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assuming that the encoding and decoding times are negligible with respect to the target max_lat. This is a reasonable assumption in many situations (e.g., see Section 8.1 in case of small window sizes). Otherwise the max_lat parameter should be adjusted in order to avoid the problem. In any case, interoperability will never be compromised by choosing a too large value.",
      "ja": "ターゲットのmax_latに関してエンコードおよびデコード時間が無視できると仮定します。 これは、多くの状況で合理的な仮定です（たとえば、ウィンドウサイズが小さい場合はセクション8.1を参照）。 そうでない場合は、max_latパラメーターを調整して問題を回避する必要があります。 いずれにしても、大きすぎる値を選択しても相互運用性が損なわれることはありません。"
    },
    {
      "indent": 3,
      "text": "In a second configuration, the FECFRAME sender generates a fixed bitrate flow, equal to the CBR communication path bitrate equal to br_out (in bits/s), and this value is known by the FECFRAME sender, as in [Roca17]. The maximum source flow bitrate needs to be such that, with the added repair flow overhead, the total transmission bitrate remains inferior or equal to br_out. We have:",
      "ja": "2番目の構成では、FECFRAME送信者は、br_out（ビット/秒）に等しいCBR通信パスビットレートに等しい固定ビットレートフローを生成し、この値は[Roca17]のようにFECFRAME送信者に知られています。 最大ソースフロービットレートは、追加された修復フローオーバーヘッドにより、総送信ビットレートがbr_outと同等かそれ以下である必要があります。 我々は持っています："
    },
    {
      "indent": 6,
      "text": "dw_max_size = (max_lat * br_out * cr) / (8 * E)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assuming here also that the encoding and decoding times are negligible with respect to the target max_lat.",
      "ja": "ここでも、ターゲットのmax_latに関してエンコードおよびデコード時間が無視できると仮定しています。"
    },
    {
      "indent": 3,
      "text": "For decoding to be possible within the latency budget, it is required that the encoding window maximum size be smaller than or at most equal to the decoding window maximum size. The ew_max_size is the main parameter at a FECFRAME sender, but its exact value has no impact on the FEC-related latency budget. The ew_max_size parameter is computed as follows:",
      "ja": "レイテンシバジェット内でデコードを可能にするには、エンコードウィンドウの最大サイズがデコードウィンドウの最大サイズ以下である必要があります。 ew_max_sizeはFECFRAME送信側のメインパラメーターですが、その正確な値はFEC関連のレイテンシバジェットに影響を与えません。 ew_max_sizeパラメーターは、次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "ew_max_size = dw_max_size * WSR / 255",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In line with [Roca17], WSR = 191 is considered as a reasonable value (the resulting encoding to decoding window size ratio is then close to 0.75), but other values between 1 and 255 inclusive are possible, depending on the use-case.",
      "ja": "[Roca17]に沿って、WSR = 191は妥当な値と見なされます（その結果、エンコードウィンドウとデコードウィンドウのサイズ比は0.75に近くなります）が、ユースケースに応じて、1から255までの他の値も可能です。"
    },
    {
      "indent": 3,
      "text": "The dw_max_size is computed by a FECFRAME sender but not explicitly communicated to a FECFRAME receiver. However, a FECFRAME receiver can easily evaluate the ew_max_size by observing the maximum Number of Source Symbols (NSS) value contained in the Repair FEC Payload ID of received FEC Repair Packets (Section 4.1.3). A receiver can then easily compute dw_max_size:",
      "ja": "dw_max_sizeはFECFRAME送信者によって計算されますが、FECFRAME受信者に明示的に通信されることはありません。 ただし、FECFRAMEレシーバーは、受信したFEC修復パケット（セクション4.1.3）の修復FECペイロードIDに含まれるソースシンボル（NSS）の最大数を観察することで、ew_max_sizeを簡単に評価できます。 受信者は、dw_max_sizeを簡単に計算できます。"
    },
    {
      "indent": 6,
      "text": "dw_max_size = max_NSS_observed * 255 / WSR",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A receiver can then choose an appropriate linear system maximum size:",
      "ja": "受信者は、適切な線形システムの最大サイズを選択できます。"
    },
    {
      "indent": 6,
      "text": "ls_max_size >= dw_max_size",
      "ja": "ls_max_size> = dw_max_size"
    },
    {
      "indent": 3,
      "text": "It is good practice to use a larger value for ls_max_size as explained in Appendix D, which does not impact maximum latency nor interoperability.",
      "ja": "付録Dで説明されているように、ls_max_sizeに大きな値を使用することをお勧めします。これは、最大遅延や相互運用性に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "In any case, for a given use-case (i.e., for target encoding and decoding devices and desired protection levels in front of communication impairments) and for the computed ew_max_size, dw_max_size and ls_max_size values, it is RECOMMENDED to check that the maximum encoding time and maximum memory requirements at a FECFRAME sender, and maximum decoding time and maximum memory requirements at a FECFRAME receiver, stay within reasonable bounds. When assuming that the encoding and decoding times are negligible with respect to the target max_lat, this should be verified as well, otherwise the max_lat SHOULD be adjusted accordingly.",
      "ja": "いずれにせよ、特定のユースケース（つまり、通信障害の前のターゲットエンコーディングおよびデコーディングデバイスと目的の保護レベル）および計算されたew_max_size、dw_max_size、ls_max_sizeの値については、最大エンコーディング時間を確認することをお勧めします FECFRAME送信側での最大メモリ要件、およびFECFRAME受信側での最大デコード時間と最大メモリ要件は、妥当な範囲内に留まります。 ターゲットのmax_latに関してエンコードとデコードの時間が無視できると仮定する場合、これも同様に検証する必要があります。そうでない場合は、max_latをそれに応じて調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "The particular case of session start needs to be managed appropriately since the ew_size, starting at zero, increases each time a new source ADU is received by the FECFRAME sender, until it reaches the ew_max_size value. Therefore, a FECFRAME receiver SHOULD continuously observe the received FEC Repair Packets, since the NSS value carried in the Repair FEC Payload ID will increase too, and adjust its ls_max_size accordingly if need be. With a CBR flow, session start is expected to be the only moment when the encoding window size will increase. Similarly, with a CBR real-time flow, the session end is expected to be the only moment when the encoding window size will progressively decrease. No adjustment of the ls_max_size is required at the FECFRAME receiver in that case.",
      "ja": "新しいソースADUがFECFRAME送信者によって受信されるたびにew_max_size値に達するまで、ゼロから始まるew_sizeが増加するため、セッション開始の特定のケースを適切に管理する必要があります。 したがって、FEC FRAMEペイロードIDで運ばれるNSS値も増加するため、FECFRAME受信機は受信したFEC修復パケットを継続的に観察する必要があります（必要に応じてls_max_sizeを調整します）。 CBRフローでは、エンコードウィンドウサイズが増加するのはセッションの開始のみであると予想されます。 同様に、CBRリアルタイムフローでは、セッション終了は、エンコードウィンドウサイズが次第に小さくなる唯一の瞬間であると予想されます。 その場合、FECFRAMEレシーバーでls_max_sizeを調整する必要はありません。"
    },
    {
      "indent": 0,
      "text": "C.2. Other Types of Real-Time Flow",
      "section_title": true,
      "ja": "C.2. 他の種類のリアルタイムフロー"
    },
    {
      "indent": 3,
      "text": "In the following, we consider a real-time source ADU flow with a max_lat latency budget and a variable bitrate (VBR) measured at the entry of the FECFRAME sender. A first approach consists in considering the smallest instantaneous bitrate of the source ADU flow, when this parameter is known, and to reuse the derivation of Appendix C.1. Considering the smallest bitrate means that the encoding and decoding window maximum size estimations are pessimistic: these windows have the smallest size required to enable on-time decoding at a FECFRAME receiver. If the instantaneous bitrate is higher than this smallest bitrate, this approach leads to an encoding window that is unnecessarily small, which reduces robustness in front of long erasure bursts.",
      "ja": "以下では、FECFRAME送信者のエントリで測定されたmax_latレイテンシバジェットと可変ビットレート（VBR）を持つリアルタイムソースADUフローを検討します。 最初のアプローチは、このパラメータがわかっている場合、ソースADUフローの最小瞬間ビットレートを考慮し、付録C.1の導出を再利用することです。 最小ビットレートを考慮するということは、エンコードおよびデコードウィンドウの最大サイズの推定が悲観的であることを意味します。これらのウィンドウは、FECFRAME受信機でのオンタイムデコードを可能にするために必要な最小サイズです。 瞬間ビットレートがこの最小ビットレートよりも高い場合、このアプローチは不必要に小さいエンコーディングウィンドウをもたらし、長い消去バーストの前の堅牢性を低下させます。"
    },
    {
      "indent": 3,
      "text": "Another approach consists in using ADU timing information (e.g., using the timestamp field of an RTP packet header, or registering the time upon receiving a new ADU). From the global FEC-related latency budget, the FECFRAME sender can derive a practical maximum latency budget for encoding operations, max_lat_for_encoding. For the FEC schemes specified in this document, this latency budget SHOULD be computed with:",
      "ja": "別のアプローチは、ADUタイミング情報を使用することです（たとえば、RTPパケットヘッダーのタイムスタンプフィールドを使用するか、新しいADUを受信すると時間を登録します）。 グローバルなFEC関連のレイテンシバジェットから、FECFRAMEセンダは、エンコード操作の実用的な最大レイテンシバジェットmax_lat_for_encodingを導出できます。 このドキュメントで指定されたFECスキームの場合、このレイテンシバジェットは次のように計算する必要があります。"
    },
    {
      "indent": 6,
      "text": "max_lat_for_encoding = max_lat * WSR / 255",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It follows that any source symbols associated to an ADU that has timed-out with respect to max_lat_for_encoding SHOULD be removed from the encoding window. With this approach there is no pre-determined ew_size value: this value fluctuates over the time according to the instantaneous source ADU flow bitrate. For practical reasons, a FECFRAME sender may still require that ew_size does not increase beyond a maximum value (Appendix C.3).",
      "ja": "したがって、max_lat_for_encodingに関してタイムアウトになったADUに関連付けられたソースシンボルは、エンコードウィンドウから削除する必要があります。 このアプローチでは、事前に決められたew_size値はありません。この値は、瞬間的なソースADUフロービットレートに従って時間とともに変動します。 実際的な理由から、FECFRAM送信者は、ew_sizeが最大値を超えて増加しないように要求する場合があります（付録C.3）。"
    },
    {
      "indent": 3,
      "text": "With both approaches, and no matter the choice of the FECFRAME sender, a FECFRAME receiver can still easily evaluate the ew_max_size by observing the maximum Number of Source Symbols (NSS) value contained in the Repair FEC Payload ID of received FEC Repair Packets. A receiver can then compute dw_max_size and derive an appropriate ls_max_size as explained in Appendix C.1.",
      "ja": "両方のアプローチで、FECFRAME送信者の選択に関係なく、FECFRAME受信者は、受信したFEC修復パケットの修復FECペイロードIDに含まれるソースシンボルの最大数（NSS）値を観察することで、ew_max_sizeを簡単に評価できます。 次に、受信者はdw_max_sizeを計算し、付録C.1で説明されているように適切なls_max_sizeを導出できます。"
    },
    {
      "indent": 3,
      "text": "When the observed NSS fluctuates significantly, a FECFRAME receiver may want to adapt its ls_max_size accordingly. In particular when the NSS is significantly reduced, a FECFRAME receiver may want to reduce the ls_max_size too in order to limit computation complexity. A balance must be found between using an ls_max_size \"too large\" (which increases computation complexity and memory requirements) and the opposite (which reduces recovery performance).",
      "ja": "観測されたNSSが大幅に変動する場合、FECFRAME受信者は、それに応じてls_max_sizeを適応させたい場合があります。 特に、NSSが大幅に削減される場合、FECFRAME受信機は、計算の複雑さを制限するために、ls_max_sizeも削減する必要がある場合があります。 「大きすぎる」ls_max_sizeを使用する（計算の複雑さとメモリ要件が増加する）ことと、逆（回復パフォーマンスが低下する）のバランスをとる必要があります。"
    },
    {
      "indent": 0,
      "text": "C.3. Case of a Non-Real-Time Flow",
      "section_title": true,
      "ja": "C.3. 非リアルタイムフローの場合"
    },
    {
      "indent": 3,
      "text": "Finally there are configurations where a source ADU flow has no real-time constraints. FECFRAME and the FEC schemes defined in this document can still be used. The choice of appropriate parameter values can be directed by practical considerations. For instance, it can derive from an estimation of the maximum memory amount that could be dedicated to the linear system at a FECFRAME receiver, or the maximum computation complexity at a FECFRAME receiver, both of them depending on the ls_max_size parameter. The same considerations also apply to the FECFRAME sender, where the maximum memory amount and computation complexity depend on the ew_max_size parameter.",
      "ja": "最後に、ソースADUフローにリアルタイムの制約がない構成があります。 このドキュメントで定義されているFECFRAMEおよびFECスキームは引き続き使用できます。 適切なパラメーター値の選択は、実際の考慮事項によって指示できます。 たとえば、FECFRAME受信機の線形システム専用の最大メモリ量、またはFECFRAME受信機の最大計算複雑度の推定値から導き出すことができます。どちらもls_max_sizeパラメーターに依存します。 同じ考慮事項は、最大メモリ量と計算の複雑さがew_max_sizeパラメーターに依存するFECFRAME送信者にも適用されます。"
    },
    {
      "indent": 3,
      "text": "Here also, the NSS value contained in FEC Repair Packets is used by a FECFRAME receiver to determine the current coding window size and ew_max_size by observing its maximum value over the time.",
      "ja": "ここでも、FEC Repair Packetsに含まれるNSS値は、FECFRAME受信機によって使用され、現在のコーディングウィンドウサイズとew_max_sizeを、その最大値を経時的に観察することによって決定します。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Decoding Beyond Maximum Latency Optimization (Informational)",
      "ja": "付録D.最大遅延最適化を超えるデコード（情報）"
    },
    {
      "indent": 3,
      "text": "This annex introduces non-normative considerations. It is provided as suggestions, without any impact on interoperability. For more information see [Roca16].",
      "ja": "この付録では、非規範的な考慮事項を紹介します。 相互運用性に影響を与えることなく、提案として提供されます。 詳細については、[Roca16]を参照してください。"
    },
    {
      "indent": 3,
      "text": "With a real-time source ADU flow, it is possible to improve the decoding performance of Sliding Window Codes without impacting maximum latency, at the cost of extra memory and CPU overhead. The optimization consists, for a FECFRAME receiver, to extend the linear system beyond the decoding window maximum size, by keeping a certain number of old source symbols whereas their associated ADUs timed-out:",
      "ja": "リアルタイムのソースADUフローを使用すると、余分なメモリとCPUオーバーヘッドを犠牲にして、最大遅延に影響を与えることなく、スライディングウィンドウコードのデコードパフォーマンスを向上させることができます。 FECFRAME受信機の最適化は、一定の数の古いソースシンボルを保持する一方で、関連するADUがタイムアウトすることにより、デコードウィンドウの最大サイズを超えて線形システムを拡張することから成ります。"
    },
    {
      "indent": 6,
      "text": "ls_max_size > dw_max_size",
      "ja": "ls_max_size> dw_max_size"
    },
    {
      "indent": 3,
      "text": "Usually the following choice is a good trade-off between decoding performance and extra CPU overhead:",
      "ja": "通常、次の選択は、デコードパフォーマンスと余分なCPUオーバーヘッドの間の適切なトレードオフです。"
    },
    {
      "indent": 6,
      "text": "ls_max_size = 2 * dw_max_size",
      "ja": "ls_max_size = 2 * dw_max_size"
    },
    {
      "indent": 3,
      "text": "When the dw_max_size is very small, it may be preferable to keep a minimum ls_max_size value (e.g., LS_MIN_SIZE_DEFAULT = 40 symbols). Going below this threshold will not save a significant amount of memory nor CPU cycles. Therefore:",
      "ja": "dw_max_sizeが非常に小さい場合、最小のls_max_size値を保持することが望ましい場合があります（LS_MIN_SIZE_DEFAULT = 40シンボルなど）。 このしきい値を下回っても、メモリやCPUサイクルの大幅な節約にはなりません。 したがって："
    },
    {
      "indent": 6,
      "text": "ls_max_size = max(2 * dw_max_size, LS_MIN_SIZE_DEFAULT)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Finally, it is worth noting that a receiver that benefits from an FEC protection significantly higher than what is required to recover from packet losses, can choose to reduce the ls_max_size. In that case lost ADUs will be recovered without relying on this optimization.",
      "ja": "最後に、パケット損失からの回復に必要なものよりも大幅に高いFEC保護の恩恵を受けるレシーバーは、ls_max_sizeを減らすことを選択できることに注意する価値があります。 その場合、失われたADUは、この最適化に依存せずに回復されます。"
    },
    {
      "indent": 3,
      "text": "                             ls_max_size\n/---------------------------------^-------------------------------\\",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        late source symbols\n (pot. decoded but not delivered)            dw_max_size\n/--------------^-----------------\\ /--------------^---------------\\\nsrc0 src1 src2 src3 src4 src5 src6 src7 src8 src9 src10 src11 src12",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 11: Relationship between Parameters to Decode beyond Maximum Latency",
      "ja": "図11：最大レイテンシを超えてデコードするパラメーター間の関係"
    },
    {
      "indent": 3,
      "text": "It means that source symbols, and therefore ADUs, may be decoded even if the added latency exceeds the maximum value permitted by the application (the \"late source symbols\" of Figure 11). It follows that the corresponding ADUs will not be useful to the application. However, decoding these \"late symbols\" significantly improves the global robustness in bad reception conditions and is therefore recommended for receivers experiencing bad communication conditions [Roca16]. In any case whether or not to use this optimization and what exact value to use for the ls_max_size parameter are local decisions made by each receiver independently, without any impact on the other receivers nor on the source.",
      "ja": "これは、追加されたレイテンシがアプリケーションで許可されている最大値を超えても、ソースシンボル、したがってADUがデコードされる可能性があることを意味します（図11の「後のソースシンボル」）。 その結果、対応するADUはアプリケーションにとって有用ではなくなります。 ただし、これらの「後期シンボル」をデコードすると、受信状態が悪い場合のグローバルな堅牢性が大幅に向上するため、通信状態が悪い受信者に推奨されます[Roca16]。 いずれの場合も、この最適化を使用するかどうか、およびls_max_sizeパラメーターに使用する正確な値は、他のレシーバーにもソースにも影響を与えずに、各レシーバーが個別に行うローカルな決定です。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the three TSVWG chairs, Wesley Eddy (our shepherd), David Black, and Gorry Fairhurst; as well as Spencer Dawkins, our responsible AD; and all those who provided comments -- namely (in alphabetical order), Alan DeKok, Jonathan Detchart, Russ Housley, Emmanuel Lochin, Marie-Jose Montpetit, and Greg Skinner. Last but not least, the authors are really grateful to the IESG members, in particular Benjamin Kaduk, Mirja Kuehlewind, Eric Rescorla, Adam Roach, and Roman Danyliw for their highly valuable feedback that greatly contributed to improving this specification.",
      "ja": "著者は、3つのTSVWG議長、Wesley Eddy（羊飼い）、David Black、およびGorry Fairhurstに感謝します。 責任あるADのスペンサー・ドーキンスと同様に。 そして、コメントを提供したすべての人-すなわち（アルファベット順）、Alan DeKok、Jonathan Detchart、Russ Housley、Emmanuel Lochin、Marie-Jose Montpetit、およびGreg Skinner。 最後になりましたが、作者はIESGメンバー、特にBenjamin Kaduk、Mirja Kuehlewind、Eric Rescorla、Adam Roach、Roman Danyliwに、この仕様の改善に大きく貢献した非常に貴重なフィードバックに本当に感謝しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vincent Roca INRIA Univ. Grenoble Alpes France",
      "ja": "ヴィンセントロカINRIA大学 グルノーブルアルプフランス"
    },
    {
      "indent": 3,
      "text": "Email: vincent.roca@inria.fr",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Belkacem Teibi INRIA Univ. Grenoble Alpes France",
      "ja": "Belkacem Teibi INRIA大学 グルノーブルアルプフランス"
    },
    {
      "indent": 3,
      "text": "Email: belkacem.teibi@gmail.com",
      "raw": true
    }
  ]
}