{
  "title": {
    "text": "RFC 8029 - Detecting Multiprotocol Label Switched (MPLS) Data-Plane Failures",
    "ja": "RFC 8029 - 検出マルチプロトコルラベルは、データプレーンの障害を（MPLS）を交換しました"
  },
  "number": 8029,
  "created_at": "2019-10-22 08:52:29.339120+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       K. Kompella\nRequest for Comments: 8029                        Juniper Networks, Inc.\nObsoletes: 4379, 6424, 6829, 7537                             G. Swallow\nUpdates: 1122                                          C. Pignataro, Ed.\nCategory: Standards Track                                       N. Kumar\nISSN: 2070-1721                                                    Cisco\n                                                               S. Aldrin\n                                                                  Google\n                                                                 M. Chen\n                                                                  Huawei\n                                                              March 2017",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Detecting Multiprotocol Label Switched (MPLS) Data-Plane Failures",
      "ja": "検出マルチプロトコルラベルは、データプレーンの障害を（MPLS）を交換しました"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism to detect data-plane failures in Multiprotocol Label Switching (MPLS) Label Switched Paths (LSPs). It defines a probe message called an \"MPLS echo request\" and a response message called an \"MPLS echo reply\" for returning the result of the probe. The MPLS echo request is intended to contain sufficient information to check correct operation of the data plane and to verify the data plane against the control plane, thereby localizing faults.",
      "ja": "この文書では、マルチプロトコルラベルスイッチングにおけるデータプレーンの障害を検出するための簡単で効率的なメカニズムを説明し（MPLS）ラベルスイッチパス（LSP）。これは、「MPLSエコー要求」およびプローブの結果を戻すための「MPLSエコー応答」と呼ばれる応答メッセージと呼ばれるプローブメッセージを定義します。 MPLSエコー要求は、データプレーンの正しい動作を確認するために、それによって障害をローカライズ、制御プレーンに対してデータプレーンを確認するために十分な情報を含むことが意図されます。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFCs 4379, 6424, 6829, and 7537, and updates RFC 1122.",
      "ja": "この文書は、RFCの4379、6424、6829、および7537、およびアップデートRFC 1122を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8029.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8029で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.1.  Conventions . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.2.  Structure of This Document  . . . . . . . . . . . . . . .   6\n  1.3.  Scope of This Specification . . . . . . . . . . . . . . .   6\n2.  Motivation  . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.1.  Use of Address Range 127/8  . . . . . . . . . . . . . . .   8\n  2.2.  Router Alert Option . . . . . . . . . . . . . . . . . . .  10\n3.  Packet Format . . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.1.  Return Codes  . . . . . . . . . . . . . . . . . . . . . .  16\n  3.2.  Target FEC Stack  . . . . . . . . . . . . . . . . . . . .  17\n    3.2.1.  LDP IPv4 Prefix . . . . . . . . . . . . . . . . . . .  19\n    3.2.2.  LDP IPv6 Prefix . . . . . . . . . . . . . . . . . . .  19\n    3.2.3.  RSVP IPv4 LSP . . . . . . . . . . . . . . . . . . . .  20\n    3.2.4.  RSVP IPv6 LSP . . . . . . . . . . . . . . . . . . . .  20\n    3.2.5.  VPN IPv4 Prefix . . . . . . . . . . . . . . . . . . .  21\n    3.2.6.  VPN IPv6 Prefix . . . . . . . . . . . . . . . . . . .  22\n    3.2.7.  L2 VPN Endpoint . . . . . . . . . . . . . . . . . . .  23\n    3.2.8.  FEC 128 Pseudowire - IPv4 (Deprecated)  . . . . . . .  23\n    3.2.9.  FEC 128 Pseudowire - IPv4 (Current) . . . . . . . . .  24\n    3.2.10. FEC 129 Pseudowire - IPv4 . . . . . . . . . . . . . .  25\n    3.2.11. FEC 128 Pseudowire - IPv6 . . . . . . . . . . . . . .  26\n    3.2.12. FEC 129 Pseudowire - IPv6 . . . . . . . . . . . . . .  27\n    3.2.13. BGP Labeled IPv4 Prefix . . . . . . . . . . . . . . .  28\n    3.2.14. BGP Labeled IPv6 Prefix . . . . . . . . . . . . . . .  28\n    3.2.15. Generic IPv4 Prefix . . . . . . . . . . . . . . . . .  29\n    3.2.16. Generic IPv6 Prefix . . . . . . . . . . . . . . . . .  29\n    3.2.17. Nil FEC . . . . . . . . . . . . . . . . . . . . . . .  29\n  3.3.  Downstream Mapping (Deprecated) . . . . . . . . . . . . .  30\n  3.4.  Downstream Detailed Mapping TLV . . . . . . . . . . . . .  30\n    3.4.1.  Sub-TLVs  . . . . . . . . . . . . . . . . . . . . . .  34\n    3.4.2.  Downstream Router and Interface . . . . . . . . . . .  40\n  3.5.  Pad TLV . . . . . . . . . . . . . . . . . . . . . . . . .  41\n  3.6.  Vendor Enterprise Number  . . . . . . . . . . . . . . . .  41\n  3.7.  Interface and Label Stack . . . . . . . . . . . . . . . .  42\n  3.8.  Errored TLVs  . . . . . . . . . . . . . . . . . . . . . .  43\n  3.9.  Reply TOS Octet TLV . . . . . . . . . . . . . . . . . . .  44\n4.  Theory of Operation . . . . . . . . . . . . . . . . . . . . .  44\n  4.1.  Dealing with Equal-Cost Multipath (ECMP)  . . . . . . . .  44\n  4.2.  Testing LSPs That Are Used to Carry MPLS Payloads . . . .  45\n  4.3.  Sending an MPLS Echo Request  . . . . . . . . . . . . . .  46\n  4.4.  Receiving an MPLS Echo Request  . . . . . . . . . . . . .  47\n    4.4.1.  FEC Validation  . . . . . . . . . . . . . . . . . . .  53",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  4.5.  Sending an MPLS Echo Reply  . . . . . . . . . . . . . . .  54\n    4.5.1.  Addition of a New Tunnel  . . . . . . . . . . . . . .  55\n    4.5.2.  Transition between Tunnels  . . . . . . . . . . . . .  56\n  4.6.  Receiving an MPLS Echo Reply  . . . . . . . . . . . . . .  56\n  4.7.  Issue with VPN IPv4 and IPv6 Prefixes . . . . . . . . . .  58\n  4.8.  Non-compliant Routers . . . . . . . . . . . . . . . . . .  59\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  59\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  61\n  6.1.  TCP and UDP Port Number . . . . . . . . . . . . . . . . .  61\n  6.2.  MPLS LSP Ping Parameters  . . . . . . . . . . . . . . . .  61\n    6.2.1.  Message Types, Reply Modes, Return Codes  . . . . . .  61\n    6.2.2.  TLVs  . . . . . . . . . . . . . . . . . . . . . . . .  62\n    6.2.3.  Global Flags  . . . . . . . . . . . . . . . . . . . .  64\n    6.2.4.  Downstream Detailed Mapping Address Type  . . . . . .  64\n    6.2.5.  DS Flags  . . . . . . . . . . . . . . . . . . . . . .  65\n    6.2.6.  Multipath         Types . . . . . . . . . . . . . . .  66\n    6.2.7.  Pad Type  . . . . . . . . . . . . . . . . . . . . . .  66\n    6.2.8.  Interface and Label Stack Address Type  . . . . . . .  67\n  6.3.  IPv4 Special-Purpose Address Registry . . . . . . . . . .  67\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  67\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  67\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  68\nAppendix A.  Deprecated TLVs and Sub-TLVs (Non-normative) . . . .  72\n  A.1.  Target FEC Stack  . . . . . . . . . . . . . . . . . . . .  72\n    A.1.1.  FEC 128 Pseudowire - IPv4 (Deprecated)  . . . . . . .  72\n  A.2.  Downstream Mapping (Deprecated) . . . . . . . . . . . . .  72\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  77\nContributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  77\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  78",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism to detect data-plane failures in MPLS Label Switched Paths (LSPs). It defines a probe message called an \"MPLS echo request\" and a response message called an \"MPLS echo reply\" for returning the result of the probe. The MPLS echo request is intended to contain sufficient information to check correct operation of the data plane, as well as a mechanism to verify the data plane against the control plane, thereby localizing faults.",
      "ja": "この文書は、単純かつ効率的なMPLSラベルにデータプレーンの障害を検出するための機構スイッチパス（LSPを）記載されています。これは、「MPLSエコー要求」およびプローブの結果を戻すための「MPLSエコー応答」と呼ばれる応答メッセージと呼ばれるプローブメッセージを定義します。 MPLSエコー要求は、正しいデータプレーンの動作、ならびにそれによって障害をローカライズ、制御プレーンに対してデータプレーンを検証するメカニズムを確認するために十分な情報を含むことが意図されます。"
    },
    {
      "indent": 3,
      "text": "An important consideration in this design is that MPLS echo requests follow the same data path that normal MPLS packets would traverse. MPLS echo requests are meant primarily to validate the data plane and secondarily to verify the data plane against the control plane. Mechanisms to check the control plane are valuable but are not covered in this document.",
      "ja": "この設計で考慮すべき重要な点は、それがエコー要求は、通常のMPLSパケットが通過するのと同じデータ・パスをたどるMPLSです。 MPLSエコー要求は、データプレーンを検証し、二次制御プレーンに対するデータプレーンを確認するために主に意図されています。コントロールプレーンをチェックするメカニズムは貴重であるが、この文書でカバーされていません。"
    },
    {
      "indent": 3,
      "text": "This document makes special use of the address range 127/8. This is an exception to the behavior defined in RFC 1122 [RFC1122], and this specification updates that RFC. The motivation for this change and the details of this exceptional use are discussed in Section 2.1 below.",
      "ja": "この文書では、アドレス範囲8分の127の特殊な使用しています。これは、RFC 1122 [RFC1122]で定義された動作の例外であり、この明細書は、RFCを更新します。この変更と、この例外的使用の詳細については、動機は以下のセクション2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 4379 [RFC4379], RFC 6424 [RFC6424], RFC 6829 [RFC6829], and RFC 7537 [RFC7537].",
      "ja": "この文書は、RFC 4379 [RFC4379]、RFC 6424 [RFC6424]、RFC 6829 [RFC6829]、およびRFC 7537 [RFC7537]を廃止します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions",
      "section_title": true,
      "ja": "1.1. 表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"Must Be Zero\" (MBZ) is used in object descriptions for reserved fields. These fields MUST be set to zero when sent and ignored on receipt.",
      "ja": "用語「ゼロでなければならない」（MBZ）は予約フィールドのためのオブジェクト記述に使用されています。送られて、領収書の上で無視する場合、これらのフィールドをゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Terminology pertaining to L2 and L3 Virtual Private Networks (VPNs) is defined in [RFC4026].",
      "ja": "L2及びL3仮想プライベートネットワーク（VPN）に関連する用語は、[RFC4026]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Since this document refers to the MPLS Time to Live (TTL) far more frequently than the IP TTL, the authors have chosen the convention of using the unqualified \"TTL\" to mean \"MPLS TTL\" and using \"IP TTL\" for the TTL value in the IP header.",
      "ja": "この文書は生きるためのMPLS時間（TTL）これまでよりも頻繁にIP TTLを指しているので、著者は、TTL値は、「MPLS TTL」を意味する資格のない「TTL」を使って「IP TTL」を使用しての規則を選択していますIPヘッダです。"
    },
    {
      "indent": 0,
      "text": "1.2. Structure of This Document",
      "section_title": true,
      "ja": "1.2. このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The body of this memo contains four main parts: motivation, MPLS echo request/reply packet format, LSP ping operation, and a reliable return path. It is suggested that first-time readers skip the actual packet formats and read the \"Theory of Operation\" (Section 4) first; the document is structured the way it is to avoid forward references.",
      "ja": "モチベーション、MPLSエコー要求/応答パケットフォーマット、LSPピング操作、および信頼性の高いリターンパス：このメモの本体は4つの主な部品を含んでいます。初めての読者は、実際のパケットフォーマットをスキップして最初の「動作原理」（第4章）を読み取ることが示唆されています。文書は、それが前方参照を避けるためにある方法を構成されています。"
    },
    {
      "indent": 0,
      "text": "1.3. Scope of This Specification",
      "section_title": true,
      "ja": "1.3. この仕様の範囲"
    },
    {
      "indent": 3,
      "text": "The primary goal of this document is to provide a clean and updated LSP ping specification.",
      "ja": "このドキュメントの主な目的は、清潔で更新LSPピング仕様を提供することです。"
    },
    {
      "indent": 3,
      "text": "[RFC4379] defines the basic mechanism for MPLS LSP validation that can be used for fault detection and isolation. The scope of this document also includes various updates to MPLS LSP ping, including:",
      "ja": "[RFC4379]は、障害検出および分離のために使用することができるMPLS LSP検証のための基本的なメカニズムを定義します。この文書の範囲も含めて、MPLS LSPのpingに様々な更新を含みます。"
    },
    {
      "indent": 3,
      "text": "o Update all references and citations.",
      "ja": "Oすべての参照や引用を更新します。"
    },
    {
      "indent": 6,
      "text": "* Obsoleted RFCs 2434, 2030, and 3036 are respectively replaced with RFCs 5226, 5905, and 5036.",
      "ja": "*廃止のRFC 2434、2030、および3036は、それぞれのRFC 5226、5905、および5036に置き換えられています。"
    },
    {
      "indent": 6,
      "text": "* Additionally, some informative references were published as RFCs: RFCs 4761, 5085, 5885, and 8077.",
      "ja": "RFC 4761、5085、5885、および8077：*また、いくつかの有益な参照はRFCとして公開されました。"
    },
    {
      "indent": 3,
      "text": "o Incorporate all outstanding RFC errata.",
      "ja": "Oすべての未RFC正誤表を組み込みます。"
    },
    {
      "indent": 6,
      "text": "* See [Err108], [Err742], [Err1418], [Err1714], [Err1786], [Err2978], [Err3399].",
      "ja": "* [Err3399]、[Err2978]、[Err1786]、[Err1714]、[Err1418]、[Err742]、[Err108]を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Replace EXP with Traffic Class (TC), based on the update from RFC 5462.",
      "ja": "O RFC 5462からの更新に基づいて、トラフィッククラス（TC）とEXPを交換します。"
    },
    {
      "indent": 3,
      "text": "o Incorporate the updates from RFC 6829, by adding the pseudowire (PW) Forwarding Equivalence Classes (FECs) advertised over IPv6 and obsoleting RFC 6829.",
      "ja": "O疑似回線（PW）の転送等価クラス（のFEC）IPv6でアドバタイズを添加し、RFC 6829を時代遅れにすることによって、RFC 6829からの更新を組み込んでいます。"
    },
    {
      "indent": 3,
      "text": "o Incorporate the updates from RFC 7506, by adding the IPv6 Router Alert Option (RAO) for MPLS Operations, Administration, and Maintenance (OAM).",
      "ja": "O MPLS運用、管理、および保守（OAM）のIPv6ルータアラートオプション（RAO）を加えることにより、RFC 7506から更新を組み込みます。"
    },
    {
      "indent": 3,
      "text": "o Incorporate newly defined bits on the Global Flags field from RFCs 6425 and 6426.",
      "ja": "OのRFC 6425および6426からグローバルFlagsフィールドに新しく定義されたビットを組み込みます。"
    },
    {
      "indent": 3,
      "text": "o Update the IPv4 addresses used in examples to utilize the documentation prefix. Add examples with IPv6 addresses.",
      "ja": "Oドキュメントの接頭辞を利用する例で使用したIPv4アドレスを更新します。 IPv6アドレスを持つ例を追加します。"
    },
    {
      "indent": 3,
      "text": "o Incorporate the updates from RFC 6424, by deprecating the Downstream Mapping TLV (DSMAP) and adding the Downstream Detailed Mapping TLV (DDMAP); updating two new Return Codes; adding the motivations of tunneled or stitched LSPs; updating the procedures, IANA considerations, and security considerations; and obsoleting RFC 6424.",
      "ja": "O下流マッピングTLV（DSMAP）を廃止し、下流の詳細なマッピングTLV（DDMAP）を添加することによって、RFC 6424からの更新を組み込みます。二つの新しいリターンコードを更新。トンネル化やステッチLSPの動機を加えます。手順、IANAの考慮事項、およびセキュリティ上の考慮事項を更新します。およびRFC 6424を時代遅れ。"
    },
    {
      "indent": 3,
      "text": "o Incorporate the updates from RFC 7537, by updating the IANA Considerations section and obsoleting RFC 7537.",
      "ja": "O IANAの考慮事項のセクションを更新し、RFC 7537を時代遅れにすることにより、RFC 7537から更新を組み込みます。"
    },
    {
      "indent": 3,
      "text": "o Finally, obsolete RFC 4379.",
      "ja": "O最後に、廃止されたRFC 4379。"
    },
    {
      "indent": 0,
      "text": "2. Motivation",
      "section_title": true,
      "ja": "2.動機"
    },
    {
      "indent": 3,
      "text": "When an LSP fails to deliver user traffic, the failure cannot always be detected by the MPLS control plane. There is a need to provide a tool that would enable users to detect such traffic \"black holes\" or misrouting within a reasonable period of time and a mechanism to isolate faults.",
      "ja": "LSPは、ユーザトラフィックを提供するために失敗した場合、障害は常にMPLS制御プレーンによって検出することができません。障害を隔離するために、時間とメカニズムの合理的な期間内に、このようなトラフィック「ブラックホール」またはmisroutingを検出するために、ユーザーを可能にするツールを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this document, we describe a mechanism that accomplishes these goals. This mechanism is modeled after the ping/traceroute paradigm: ping (ICMP echo request [RFC0792]) is used for connectivity checks, and traceroute is used for hop-by-hop fault localization as well as path tracing. This document specifies a \"ping\" mode and a \"traceroute\" mode for testing MPLS LSPs.",
      "ja": "この文書では、我々はこれらの目標を達成メカニズムを説明します。この機構は、ピング/トレースルートパラダイムの後にモデル化されます。ping（ICMPエコー要求[RFC0792]）は接続性チェックのために使用され、およびtracerouteは、ホップバイホップ障害局在ならびに経路追跡のために使用されます。この文書では、MPLS LSPをテストするための「ピング」モードと「トレースルート」モードを指定します。"
    },
    {
      "indent": 3,
      "text": "The basic idea is to verify that packets that belong to a particular FEC actually end their MPLS path on a Label Switching Router (LSR) that is an egress for that FEC. This document proposes that this test be carried out by sending a packet (called an \"MPLS echo request\") along the same data path as other packets belonging to this FEC. An MPLS echo request also carries information about the FEC whose MPLS path is being verified. This echo request is forwarded just like any other packet belonging to that FEC. In \"ping\" mode (basic connectivity check), the packet should reach the end of the path, at which point it is sent to the control plane of the egress LSR, which then verifies whether it is indeed an egress for the FEC. In \"traceroute\" mode (fault isolation), the packet is sent to the control plane of each transit LSR, which performs various checks to confirm that it is indeed a transit LSR for this path; this LSR also returns further information that helps check the control plane against the data plane, i.e., that forwarding matches what the routing protocols determined as the path.",
      "ja": "基本的な考え方は、特定のFECに属するパケットが実際にそのFECのための出口であるルータ（LSR）のラベルスイッチング上でのMPLSパスを終了することを確認することです。この文書は、この試験は、このFECに属する他のパケットと同じデータ・パスに沿って（「MPLSエコー要求」と呼ばれる）パケットを送信することによって行うことが提案されています。 MPLSエコー要求は、MPLSパス検証されているFECについての情報を運びます。このエコー要求は、ちょうどそのFECに属する他のパケットと同様に転送されます。 「ピング」モード（基本的な接続性チェック）において、パケットは、それが、それが実際にFEC用の出口であるかどうかを検証出口LSRの制御プレーンに送られ、その時点で、パスの末尾に到達しなければなりません。 「トレースルート」モード（障害分離）では、パケットは、それが実際にこのパスの中継LSRであることを確認するために、様々なチェックを実行し、各中継LSRの制御プレーンに送られます。このLSRはまた、データプレーンに対する制御プレーンを確認に役立つさらなる情報を返す、すなわち、その転送は、ルーティングプロトコルがパスとして決定ものと一致します。"
    },
    {
      "indent": 3,
      "text": "An LSP traceroute may cross a tunneled or stitched LSP en route to the destination. While performing end-to-end LSP validation in such scenarios, the FEC information included in the packet by the Initiator may be different from the one assigned by the transit node in a different segment of a stitched LSP or tunnel. Let us consider a simple case.",
      "ja": "LSPのトレースルートは、目的地への途中トンネリングまたはステッチLSPを横切ることができます。そのようなシナリオでは、エンドツーエンドのLSPの検証を行いながら、イニシエータがパケットに含まれるFEC情報は、縫合LSPまたはトンネルの異なるセグメントにトランジットノードによって割り当てられたものとは異なっていてもよいです。私たちは、単純なケースを考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "A          B          C           D           E\no -------- o -------- o --------- o --------- o\n  \\_____/  | \\______/   \\______/  | \\______/\n    LDP    |   RSVP       RSVP    |    LDP\n           |                      |\n            \\____________________/\n                    LDP",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When an LSP traceroute is initiated from Router A to Router E, the FEC information included in the packet will be LDP while Router C along the path is a pure RSVP node and does not run LDP. Consequently, node C will be unable to perform FEC validation. The MPLS echo request should contain sufficient information to allow any transit node within a stitched or tunneled LSP to perform FEC validations to detect any misrouted echo requests.",
      "ja": "LSPのトレースルートは、ルータAからルータEに開始されたときの経路に沿ったルータCは、純粋なRSVPノードであり、LDPを実行していない間、パケットに含まれるFEC情報は、LDPであろう。結果として、ノードCは、FEC検証を実行することができません。 MPLSエコー要求は、縫合又はトンネリングLSP内の任意の中継ノードが正しくルーティングされなかったエコー要求を検出するためにFEC検証を実行できるように十分な情報を含むべきです。"
    },
    {
      "indent": 3,
      "text": "One way these tools can be used is to periodically ping a FEC to ensure connectivity. If the ping fails, one can then initiate a traceroute to determine where the fault lies. One can also periodically traceroute FECs to verify that forwarding matches the control plane; however, this places a greater burden on transit LSRs and thus should be used with caution.",
      "ja": "これらのツールを使用することができる一つの方法は、定期的に接続性を確保するためにFECをpingすることです。 pingが失敗した場合、1は、障害がどこにあるかを決定するためにtracerouteを開始することができます。一つは、その転送が制御プレーンと一致確認することも、定期的にトレースルートのFECことができ、しかし、これはトランジットLSRの上の大きな負担を課すので、注意して使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Use of Address Range 127/8",
      "section_title": true,
      "ja": "2.1. アドレス範囲の使用8分の127"
    },
    {
      "indent": 3,
      "text": "As described above, LSP ping is intended as a diagnostic tool. It is intended to enable providers of an MPLS-based service to isolate network faults. In particular, LSP ping needs to diagnose situations where the control and data planes are out of sync. It performs this by routing an MPLS echo request packet based solely on its label stack. That is, the IP destination address is never used in a forwarding decision. In fact, the sender of an MPLS echo request packet may not know, a priori, the address of the router at the end of the LSP.",
      "ja": "上述したように、LSPピングは、診断ツールとして意図されています。ネットワーク障害を隔離するMPLSベースのサービスの提供を可能にするためのものです。具体的には、LSPピングは、制御プレーンとデータプレーンが同期していない状況を診断する必要があります。それは、そのラベルスタックのみに基づいてMPLSエコー要求パケットをルーティングすることによって、これを実行します。これは、転送決定に使用されることはありませんIP宛先アドレスです。実際には、MPLSエコー要求パケットの送信者は、先験的に、LSPの最後にルータのアドレスを知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Providers of MPLS-based services also need the ability to trace all of the possible paths that an LSP may take. Since most MPLS services are based on IP unicast forwarding, these paths are subject to Equal-Cost Multipath (ECMP) load sharing.",
      "ja": "MPLSベースのサービスの提供者はまた、LSPが取る可能性のあるすべてのパスをトレースする能力が必要です。ほとんどのMPLSサービスは、IPユニキャスト転送に基づいているので、これらのパスは、等価コストマルチパス（ECMP）負荷分散の対象となっています。"
    },
    {
      "indent": 3,
      "text": "This leads to the following requirements:",
      "ja": "これは、次の要件につながります："
    },
    {
      "indent": 3,
      "text": "1. Although the LSP in question may be broken in unknown ways, the likelihood of a diagnostic packet being delivered to a user of an MPLS service MUST be held to an absolute minimum.",
      "ja": "1.当該LSPが未知の方法で破壊することができるが、MPLSサービスのユーザに配信される診断用パケットの可能性が最小限に保持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If an LSP is broken in such a way that it prematurely terminates, the diagnostic packet MUST NOT be IP forwarded.",
      "ja": "LSPは、それが途中で終了するように、壊れている場合2.は、診断パケットは、IPは、転送されてはなりません。"
    },
    {
      "indent": 3,
      "text": "3. A means of varying the diagnostic packets such that they exercise all ECMP paths is thus REQUIRED.",
      "ja": "3.それらは全てECMPパスを行使するように診断パケットを変化させる手段は、このように必要とされます。"
    },
    {
      "indent": 3,
      "text": "Clearly, using general unicast addresses satisfies neither of the first two requirements. A number of other options for addresses were considered, including a portion of the private address space (as determined by the network operator) and the IPv4 link-local addresses. Use of the private address space was deemed ineffective since the leading MPLS-based service is an IPv4 VPN. VPNs often use private addresses.",
      "ja": "明らかに、どちらも最初の二つの要件の一般的なユニキャストアドレスを満たすを使用していません。アドレスの他のオプションの数は、プライベートアドレス空間の部分（ネットワークオペレータによって決定される）とIPv4リンクローカルアドレスを含むと考えられました。主要なMPLSベースのサービスは、IPv4 VPNであるため、プライベートアドレス空間の使用は効果がないと考えられました。 VPNは、多くの場合、プライベートアドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "The IPv4 link-local addresses are more attractive in that the scope over which they can be forwarded is limited. However, if one were to use an address from this range, it would still be possible for the first recipient of a diagnostic packet that \"escaped\" from a broken LSP to have that address assigned to the interface on which it arrived and thus could mistakenly receive such a packet. Older deployed routers may not (correctly) implement IPv4 link-local addresses and would forward a packet with an address from that range toward the default route.",
      "ja": "IPv4リンクローカルアドレスは、彼らが転送することができ、その上範囲が限られているという点で、より魅力的です。一つは、この範囲のアドレスを使用した場合しかし、それはまだ誤っ従ってができ、それが到着したインターフェイスに割り当てられ、そのアドレスを有することが壊れたLSPから「エスケープ」という診断用パケットの最初の受信者のために可能となりますこのようなパケットを受信します。古い展開ルータは、（正しく）IPv4リンクローカルアドレスを実装していないことと、デフォルトルートに向けて、その範囲からアドレスを持つパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "The 127/8 range for IPv4 and that same range embedded in an IPv4-mapped IPv6 address for IPv6 was chosen for a number of reasons.",
      "ja": "IPv4の8分の127の範囲とIPv6のIPv4マッピングされたIPv6アドレスに埋め込まれたその同じ範囲が多くの理由のために選択しました。"
    },
    {
      "indent": 3,
      "text": "RFC 1122 allocates the 127/8 as the \"Internal host loopback address\" and states: \"Addresses of this form MUST NOT appear outside a host.\" Thus, the default behavior of hosts is to discard such packets. This helps to ensure that if a diagnostic packet is misdirected to a host, it will be silently discarded.",
      "ja": "RFC 1122は、「内部ホストのループバックアドレス」として8分の127を割り当て、状態：「この形式のアドレスは、ホストの外に現れてはなりません」このように、ホストのデフォルトの動作は、このようなパケットを破棄することです。これは、診断パケットがホストに誤って誘導されている場合、それは黙って廃棄されることを確実にするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "RFC 1812 [RFC1812] states:",
      "ja": "RFC 1812 [RFC1812]は述べています："
    },
    {
      "indent": 6,
      "text": "A router SHOULD NOT forward, except over a loopback interface, any packet that has a destination address on network 127. A router MAY have a switch that allows the network manager to disable these checks. If such a switch is provided, it MUST default to performing the checks.",
      "ja": "ルータは、ループバックインタフェースを介し除き、ネットワーク管理者がこれらのチェックを無効にすることを可能にするスイッチを持っているかもしれませんネットワーク127ルータの宛先アドレスを持つすべてのパケットを転送すべきではありません。そのようなスイッチが用意されている場合は、チェックを実行するデフォルトしなければなりません。"
    },
    {
      "indent": 3,
      "text": "This helps to ensure that diagnostic packets are never IP forwarded.",
      "ja": "これは、診断パケットがIP転送されないことを確実にするために役立ちます。"
    },
    {
      "indent": 3,
      "text": "The 127/8 address range provides 16M addresses allowing wide flexibility in varying addresses to exercise ECMP paths. Finally, as an implementation optimization, the 127/8 range provides an easy means of identifying possible LSP packets.",
      "ja": "8分の127のアドレス範囲は、ECMPパスを行使するアドレスを変更することで、広い柔軟性を可能16Mアドレスを提供します。最後に、実装の最適化として、8分の127の範囲は、可能なLSPパケットを特定する簡単な手段を提供します。"
    },
    {
      "indent": 0,
      "text": "2.2. Router Alert Option",
      "section_title": true,
      "ja": "2.2. ルータアラートオプション"
    },
    {
      "indent": 3,
      "text": "This document requires the use of the RAO set in an IP header in order to have the transit node process the MPLS OAM payload.",
      "ja": "この文書では、RAOの使用がトランジットノード処理MPLS OAMペイロードを有するためにIPヘッダに設定が必要です。"
    },
    {
      "indent": 3,
      "text": "[RFC2113] defines a generic Option Value 0x0 for IPv4 RAO that alerts the transit router to examine the IPv4 packet. [RFC7506] defines MPLS OAM Option Value 69 for IPv6 RAO to alert transit routers to examine the IPv6 packet more closely for MPLS OAM purposes.",
      "ja": "[RFC2113]は、IPv4パケットを調べるために、トランジットルータに警告したIPv4 RAOのための一般的なオプション値は0x0を定義します。 [RFC7506]はMPLS OAMの目的のために、より密接にIPv6パケットを検査するためにトランジットルータに警告するためのIPv6 RAOの値が69 MPLS OAMオプションを定義します。"
    },
    {
      "indent": 3,
      "text": "The use of the Router Alert IP Option in this document is as follows:",
      "ja": "次のようにこの文書に記載されているルータアラートIPオプションの使用は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "In case of an IPv4 header, the generic IPv4 RAO value 0x0 [RFC2113] SHOULD be used. In case of an IPv6 header, the IPv6 RAO value (69) for MPLS OAM [RFC7506] MUST be used.",
      "ja": "IPv4ヘッダーの場合には、一般的なIPv4のRAO値は0x0 [RFC2113]は使用されるべきです。 IPv6ヘッダーの場合には、MPLS OAM [RFC7506]のIPv6 RAO値（69）を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3. Packet Format",
      "section_title": true,
      "ja": "3.パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request/reply is a (possibly labeled) IPv4 or IPv6 UDP packet; the contents of the UDP packet have the following format:",
      "ja": "MPLSエコー要求/応答が（おそらく標識された）IPv4またはIPv6 UDPパケットです。 UDPパケットの内容は、次の形式を持っています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Version Number        |         Global Flags          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Message Type |   Reply Mode  |  Return Code  | Return Subcode|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sender's Handle                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    TimeStamp Sent (seconds)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                TimeStamp Sent (seconds fraction)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  TimeStamp Received (seconds)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              TimeStamp Received (seconds fraction)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            TLVs ...                           |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Version Number is currently 1. (Note: the version number is to be incremented whenever a change is made that affects the ability of an implementation to correctly parse or process an MPLS echo request/ reply. These changes include any syntactic or semantic changes made to any of the fixed fields, or to any Type-Length-Value (TLV) or sub-TLV assignment or format that is defined at a certain version number. The version number may not need to be changed if an optional TLV or sub-TLV is added.)",
      "ja": "バージョン番号は、現在、1（注です：バージョン番号は変更が正しく解析やMPLSエコー要求/応答を処理する実装の能力に影響を与える行われるたびにインクリメントされるこれらの変更が行われた構文や意味の変更が含まれます。固定フィールドのいずれかに、または特定のバージョン番号で定義される任意のタイプレングス値（TLV）またはサブTLV割り当てまたはフォーマットに。バージョン番号は、オプションTLVまたはサブ場合に変更する必要がないかもしれませんTLVが追加されます。）"
    },
    {
      "indent": 3,
      "text": "The Global Flags field is a bit vector with the following format:",
      "ja": "グローバルFlagsフィールドは、次の形式のビットベクトルであります："
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           MBZ           |R|T|V|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "At the time of writing, three flags are defined: the R, T, and V bits; the rest MUST be set to zero when sending and ignored on receipt.",
      "ja": "書き込み時には、3つのフラグが定義される：R、T、およびVビットを、残りは、送信時にゼロに設定して、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The V (Validate FEC Stack) flag is set to 1 if the sender wants the receiver to perform FEC Stack validation; if V is 0, the choice is left to the receiver.",
      "ja": "送信者は、受信機がFECスタックの検証を行いたい場合にV（検証FECスタック）フラグが1に設定されています。 Vが0の場合、選択は、受信機に任されています。"
    },
    {
      "indent": 3,
      "text": "The T (Respond Only If TTL Expired) flag MUST be set only in the echo request packet by the sender. If the T flag is set to 1 in an incoming echo request, and the TTL of the incoming MPLS label is more than 1, then the receiving node MUST drop the incoming echo request and MUST NOT send any echo reply to the sender. This flag MUST NOT be set in the echo reply packet. If this flag is set in an echo reply packet, then it MUST be ignored. The T flag is defined in Section 3.4 of [RFC6425].",
      "ja": "T（TTLが期限切れの場合のみ応答）フラグは、送信者によってエコー要求パケットに設定されなければなりません。 Tフラグは、着信エコー要求に1に設定され、着信MPLSラベルのTTLが1以上である場合、受信ノードは、着信エコー要求をドロップしなければならないし、送信者へのエコー応答を送信してはいけません。このフラグは、エコー応答パケットに設定してはいけません。このフラグがエコー応答パケットに設定されている場合は、それを無視しなければなりません。 Tフラグが[RFC6425]のセクション3.4で定義されています。"
    },
    {
      "indent": 3,
      "text": "The R (Validate Reverse Path) flag is defined in [RFC6426]. When this flag is set in the echo request, the Responder SHOULD return reverse-path FEC information, as described in Section 3.4.2 of [RFC6426].",
      "ja": "R（リバースパスの検証）フラグは[RFC6426]で定義されています。このフラグは、エコー要求に設定されている場合、[RFC6426]のセクション3.4.2に記載したように、レスポンダは、リバースパスFEC情報を返すべきです。"
    },
    {
      "indent": 3,
      "text": "The Message Type is one of the following:",
      "ja": "メッセージタイプは、次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS Echo Request\n    2    MPLS Echo Reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Reply Mode can take one of the following values:",
      "ja": "返信モードは、次のいずれかの値をとることができます。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application-level control channel",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An MPLS echo request with 1 (Do not reply) in the Reply Mode field may be used for one-way connectivity tests; the receiving router may log gaps in the Sequence Numbers and/or maintain delay/jitter statistics. An MPLS echo request would normally have 2 (Reply via an IPv4/IPv6 UDP packet) in the Reply Mode field. If the normal IP return path is deemed unreliable, one may use 3 (Reply via an IPv4/ IPv6 UDP packet with Router Alert). Note that this requires that all intermediate routers understand and know how to forward MPLS echo replies. The echo reply uses the same IP version number as the received echo request, i.e., an IPv4 encapsulated echo reply is sent in response to an IPv4 encapsulated echo request.",
      "ja": "応答モードフィールドに1 MPLSエコー要求（応答しない）一方向の接続テストに使用することができます。受信したルータは、シーケンス番号のギャップをログに記録および/または遅延/ジッタ統計を維持することができます。 MPLSエコー要求は、通常応答モードフィールドで（のIPv4 / IPv6のUDPパケットを介して返信）2を有するであろう。通常のIP戻り経路が信頼できないとみなされる場合、一つは3（ルータ警告付きのIPv4 / IPv6のUDPパケットを介して返信）を使用することができます。これは、すべての中間ルータを理解し、MPLSエコー応答を転送する方法を知っている必要があることに注意してください。エコー応答が受信されたエコー要求、すなわち、同じIPバージョン番号を使用して、IPv4のカプセル化されたエコー応答がエコー要求をカプセル化されたIPv4に応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "Some applications support an IP control channel. One such example is the associated control channel defined in Virtual Circuit Connectivity Verification (VCCV) [RFC5085][RFC5885]. Any application that supports an IP control channel between its control entities may set the Reply Mode to 4 (Reply via application-level control channel) to ensure that replies use that same channel. Further definition of this code point is application specific and thus beyond the scope of this document.",
      "ja": "一部のアプリケーションでは、IP制御チャネルをサポートしています。その一例は、仮想回線接続検証（VCCV）[RFC5085]、[RFC5885]で定義された関連する制御チャネルです。その制御エンティティとの間のIP制御チャネルをサポートする任意のアプリケーションは応答が同じチャネルを使用することを保証するために、（アプリケーションレベルの制御チャネルを介して返信）4への応答モードを設定してもよいです。このコードポイントの更なる定義は、特定用途、したがって、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Return Codes and Subcodes are described in Section 3.1.",
      "ja": "リターンコードとサブコードは、セクション3.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "The Sender's Handle is filled in by the sender and returned unchanged by the receiver in the echo reply (if any). There are no semantics associated with this handle, although a sender may find this useful for matching up requests with replies.",
      "ja": "送信者のハンドルは、送信者が記入し、エコー応答（もしあれば）に受信機でそのまま返されます。送信者が回答して要求を一致させるため、これは便利かもしれないが、このハンドルに関連付けられた意味は、ありません。"
    },
    {
      "indent": 3,
      "text": "The Sequence Number is assigned by the sender of the MPLS echo request and can be (for example) used to detect missed replies.",
      "ja": "シーケンス番号は、MPLSエコー要求の送信者によって割り当てられ、（例えば）逃した応答を検出するために用いることができます。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is the time of day (according to the sender's clock) in 64-bit NTP timestamp format [RFC5905] when the MPLS echo request is sent. The TimeStamp Received in an echo reply is the time of day (according to the receiver's clock) in 64-bit NTP timestamp format in which the corresponding echo request was received.",
      "ja": "送信されたタイムスタンプは、MPLSエコー要求が送信される64ビットのNTPタイムスタンプ形式[RFC5905]に（送信側のクロックに応じて）時刻です。タイムスタンプは、エコー応答に対応する受信エコー要求を受信した64ビットのNTPタイムスタンプ形式で（受信機のクロックに応じて）時刻です。"
    },
    {
      "indent": 3,
      "text": "TLVs (Type-Length-Value tuples) have the following format:",
      "ja": "TLV（タイプ - 長さ - 値タプル）次の形式を持っています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Types are defined below; Length is the length of the Value field in octets. The Value field depends on the Type; it is zero padded to align to a 4-octet boundary. TLVs may be nested within other TLVs, in which case the nested TLVs are called sub-TLVs. Sub-TLVs have independent types and MUST also be 4-octet aligned.",
      "ja": "種類は、以下に定義されています。長さはオクテット単位で値フィールドの長さです。 Valueフィールドはタイプによって異なります。それはゼロが4オクテット境界に整列させるためにパディングされます。 TLVのTLVは、ネストされたサブTLVを呼ばれた場合に他のTLV内にネストされてもよいです。サブTLVが独立したタイプがあり、また、4オクテットを整列させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Two examples of how TLV and sub-TLV lengths are computed, and how sub-TLVs are padded to be 4-octet aligned, are as follows:",
      "ja": "：TLVサブTLVの長さが計算され、どのサブTLVの整列4オクテットであることがパディングされ、以下の通りである方法の2つの例"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 1 (LDP IPv4 FEC)    |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Length for this TLV is 5. A Target FEC Stack TLV that contains an LDP IPv4 FEC sub-TLV and a VPN IPv4 prefix sub-TLV has the following format:",
      "ja": "このTLVの長さがLDPのIPv4 FECサブTLVとサブTLVは以下のフォーマットを有するVPN IPv4プレフィクスが含まれている5 AターゲットFECスタックTLVです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type = 1 (FEC TLV)       |          Length = 32          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Sub-Type = 1 (LDP IPv4 FEC)  |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Sub-Type = 6 (VPN IPv4 prefix)|          Length = 13          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A description of the Types and Values of the top-level TLVs for LSP ping are given below:",
      "ja": "LSPピングのための最上位のTLVのタイプと値の説明を以下に示します。"
    },
    {
      "indent": 10,
      "text": "Type #                  Value Field\n------                  -----------\n     1                  Target FEC Stack\n     2                  Downstream Mapping (Deprecated)\n     3                  Pad\n     4                  Unassigned\n     5                  Vendor Enterprise Number\n     6                  Unassigned\n     7                  Interface and Label Stack\n     8                  Unassigned\n     9                  Errored TLVs\n    10                  Reply TOS Byte\n    20                  Downstream Detailed Mapping",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Types less than 32768 (i.e., with the high-order bit equal to 0) are mandatory TLVs that MUST either be supported by an implementation or result in the Return Code of 2 (\"One or more of the TLVs was not understood\") being sent in the echo response.",
      "ja": "32768未満の種類（すなわち、0に等しい上位ビットを有する）のいずれかのインプリメンテーションによってサポートまたは戻りコードをもたらすされなければならない必須のTLVは、2（「1つのTLVの複数が理解されていなかった」）でありますエコー応答で送信されました。"
    },
    {
      "indent": 3,
      "text": "Types greater than or equal to 32768 (i.e., with the high-order bit equal to 1) are optional TLVs that SHOULD be ignored if the implementation does not understand or support them.",
      "ja": "（すなわち、1に等しい最上位ビットを有する）よりも大きいか、または32768に等しいタイプは実装がそれらを理解し、またはサポートしていない場合は無視されるべき任意のTLVです。"
    },
    {
      "indent": 3,
      "text": "In Sections 3.2 through 3.9 and their various subsections, only the Value field of the TLV is included.",
      "ja": "セクション3.9を通じて3.2およびその様々なサブセクションでは、TLVの値のみフィールドが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.1. Return Codes",
      "section_title": true,
      "ja": "3.1. リターンコード"
    },
    {
      "indent": 3,
      "text": "The Return Code is set to zero by the sender of an echo request. The receiver of said echo request can set it to one of the values listed below in the corresponding echo reply that it generates. The notation <RSC> refers to the Return Subcode. This field is filled in with the stack-depth for those codes that specify that. For all other codes, the Return Subcode MUST be set to zero.",
      "ja": "リターンコードは、エコー要求の送信者によってゼロに設定されています。前記エコー要求の受信機は、それが生成する対応するエコー応答で下記のいずれかの値に設定することができます。表記<RSCは>リターンサブコードを指します。このフィールドは、その指定これらのコードのためのスタック深さで充填されています。他のすべてのコードの場合、リターン・サブコードをゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Value    Meaning\n-----    -------\n    0    No Return Code\n    1    Malformed echo request received\n    2    One or more of the TLVs was not understood\n    3    Replying router is an egress for the FEC at\n         stack-depth <RSC>\n    4    Replying router has no mapping for the FEC at\n         stack-depth <RSC>\n    5    Downstream Mapping Mismatch (See Note 1)\n    6    Upstream Interface Index Unknown (See Note 1)\n    7    Reserved\n    8    Label switched at stack-depth <RSC>\n    9    Label switched but no MPLS forwarding at stack-depth <RSC>\n   10    Mapping for this FEC is not the given label at\n         stack-depth <RSC>\n   11    No label entry at stack-depth <RSC>\n   12    Protocol not associated with interface at FEC\n         stack-depth <RSC>\n   13    Premature termination of ping due to label stack\n         shrinking to a single label\n   14    See DDMAP TLV for meaning of Return Code and Return\n         Subcode (See Note 2)\n   15    Label switched with FEC change",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 1",
      "ja": "注1"
    },
    {
      "indent": 6,
      "text": "The Return Subcode (RSC) contains the point in the label stack where processing was terminated. If the RSC is 0, no labels were processed. Otherwise, the packet was label switched at depth RSC.",
      "ja": "リターンサブコード（RSC）は、処理が終了したラベルスタック内のポイントが含まれています。 RSCが0の場合、ラベルは処理されませんでした。そうでない場合、パケットは、ラベルが深さRSCに切り替えました。"
    },
    {
      "indent": 3,
      "text": "Note 2",
      "ja": "注2"
    },
    {
      "indent": 6,
      "text": "The Return Code is per \"Downstream Detailed Mapping TLV\" (Section 3.4). This Return Code MUST be used only in the message header and MUST be set only in the MPLS echo reply message. If the Return Code is set in the MPLS echo request message, then it MUST be ignored. When this Return Code is set, each Downstream Detailed Mapping TLV MUST have an appropriate Return Code and Return Subcode. This Return Code MUST be used when there are multiple downstreams for a given node (such as Point-to-Multipoint (P2MP) or ECMP), and the node needs to return a Return Code/Return Subcode for each downstream. This Return Code MAY be used even when there is only one downstream for a given node.",
      "ja": "リターンコードは、「川下詳細なマッピングTLV」（3.4節）あたりにあります。この戻りコードは、メッセージヘッダで使用されなければならないだけMPLSエコー応答メッセージに設定されなければなりません。リターンコードがMPLSエコー要求メッセージに設定されている場合は、それを無視しなければなりません。このリターンコードが設定されている場合は、各ダウンストリームの詳細なマッピングTLVは、適切なリターンコードとリターンサブコードを持たなければなりません。 （例えば、ポイントツーマルチポイント（P2MP）又はECMPなどの）所与のノードのための複数のダウンストリームが存在する場合、このリターンコードを使用しなければなりません、そして、ノードは、それぞれ下流のリターンコード/リターンサブコードを返す必要があります。指定されたノードのための唯一のダウンストリームがある場合でも、このリターンコードを使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Target FEC Stack",
      "section_title": true,
      "ja": "3.2. ターゲットFECスタック"
    },
    {
      "indent": 3,
      "text": "A Target FEC Stack is a list of sub-TLVs. The number of elements is determined by looking at the sub-TLV length fields.",
      "ja": "ターゲットFECスタックは、サブのTLVのリストです。要素の数は、サブTLVの長さフィールドを見ることによって決定されます。"
    },
    {
      "indent": 4,
      "text": "Sub-Type     Length         Value Field\n--------     ------         -----------\n       1          5         LDP IPv4 prefix\n       2         17         LDP IPv6 prefix\n       3         20         RSVP IPv4 LSP\n       4         56         RSVP IPv6 LSP\n       5                    Unassigned\n       6         13         VPN IPv4 prefix\n       7         25         VPN IPv6 prefix\n       8         14         L2 VPN endpoint\n       9         10         \"FEC 128\" Pseudowire - IPv4 (deprecated)\n      10         14         \"FEC 128\" Pseudowire - IPv4\n      11        16+         \"FEC 129\" Pseudowire - IPv4\n      12          5         BGP labeled IPv4 prefix\n      13         17         BGP labeled IPv6 prefix\n      14          5         Generic IPv4 prefix\n      15         17         Generic IPv6 prefix\n      16          4         Nil FEC\n      24         38         \"FEC 128\" Pseudowire - IPv6\n      25         40+        \"FEC 129\" Pseudowire - IPv6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other FEC types have been defined and will be defined as needed.",
      "ja": "他のFECタイプが定義されていて、必要に応じて定義されます。"
    },
    {
      "indent": 3,
      "text": "Note that this TLV defines a stack of FECs, the first FEC element corresponding to the top of the label stack, etc.",
      "ja": "このTLV等のFEC、ラベルスタックの最上位に対応する最初のFEC要素のスタックを定義することに注意してください"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have a Target FEC Stack that describes the FEC Stack being tested. For example, if an LSR X has an LDP mapping [RFC5036] for 192.0.2.1 (say, label 1001), then to verify that label 1001 does indeed reach an egress LSR that announced this prefix via LDP, X can send an MPLS echo request with a FEC Stack TLV with one FEC in it, namely, of type LDP IPv4 prefix, with prefix 192.0.2.1/32, and send the echo request with a label of 1001.",
      "ja": "MPLSエコー要求は、FECスタックがテストされている記述のターゲットFECスタックを持たなければなりません。 LSR Xは、LDPマッピング[RFC5036] 192.0.2.1のための（たとえば、ラベル1001）がある場合たとえば、そのラベル1001は確かに自民党を経由して、この接頭辞を発表しました出口LSRに到達ん検証するために、Xは、MPLSエコーを送信することができますプリフィックス192.0.2.1/32と、タイプLDPのIPv4プレフィックス、すなわち、その中で1つのFECとFECスタックTLVを要求し、1001のラベルを持つエコー要求を送信します。"
    },
    {
      "indent": 3,
      "text": "Say LSR X wanted to verify that a label stack of <1001, 23456> is the right label stack to use to reach a VPN IPv4 prefix (see Section 3.2.5) of 203.0.113.0/24 in VPN foo. Say further that LSR Y with loopback address 192.0.2.1 announced prefix 203.0.113.0/24 with Route Distinguisher (RD) RD-foo-Y (which may in general be different from the RD that LSR X uses in its own advertisements for VPN foo), label 23456, and BGP next hop 192.0.2.1 [RFC4271]. Finally, suppose that LSR X receives a label binding of 1001 for 192.0.2.1 via LDP. X has two choices in sending an MPLS echo request: X can send an MPLS echo request with a FEC Stack TLV with a single FEC of type VPN IPv4 prefix with a prefix of 203.0.113.0/24 and an RD of RD-foo-Y. Alternatively, X can send a FEC Stack TLV with two FECs, the first of type LDP IPv4 with a prefix of 192.0.2.1/32 and the second of type of IP VPN with a prefix 203.0.113.0/24 with an RD of RD-foo-Y. In either case, the MPLS echo request would have a label stack of <1001, 23456>. (Note: in this example, 1001 is the \"outer\" label and 23456 is the \"inner\" label.)",
      "ja": "LSR Xは<1001、23456>のラベルスタックは、VPNのIPv4プレフィックスに到達するために使用する権利ラベルスタックであることを確認したかったと言うVPN fooの中203.0.113.0/24の（3.2.5項を参照してください）。 LSR Yは、ループバックアドレス192.0.2.1と一般的にLSR XはVPN fooの独自の広告で使用するRD異なっていてもよいルート識別子（RD）RD-FOO-Y（接頭辞203.0.113.0/24を発表することをさらに言います）、ラベル23456、およびBGPネクストホップ192.0.2.1 [RFC4271]。最後に、LSR XはLDP経由192.0.2.1のための1001の結合ラベルを受けることとします。 Xは、MPLSエコー要求を送信するには2つの選択肢があります：Xは203.0.113.0/24のプレフィックスとRD-FOO-YのRDと種類VPNのIPv4プレフィックスの単一FECとFECスタックTLVとMPLSエコー要求を送信することができます。あるいは、Xは192.0.2.1/32のプレフィックスとRD-のRDと接頭203.0.113.0/24とIP VPNの種類の第有する2つのFEC、タイプLDPのIPv4の最初とFECスタックTLVを送信することができFOO-Y。いずれの場合も、MPLSエコー要求は<1001、23456>のラベルスタックを持っているでしょう。 （注：この例では、1001は、「外側」ラベルであり、23456は、「内側」ラベルです。）"
    },
    {
      "indent": 3,
      "text": "If, for example, an LSR Y has an LDP mapping for the IPv6 address 2001:db8::1 (say, label 2001), then to verify that label 2001 does reach an egress LSR that announced this prefix via LDP, LSR Y can send an MPLS echo request with a FEC Stack TLV with one LDP IPv6 prefix FEC, with prefix 2001:db8::1/128, and with a label of 2001.",
      "ja": "例えば、LSR Yは、IPv6アドレス2001 LDPマッピングされている場合：DB8 :: 1（たとえば、ラベル2001）、そして、LSR YはできLDPを経由して、この接頭辞を発表しました出口LSRに達しないそのラベル2001を検証しますプレフィックス2001で、1 LDP IPv6プレフィックスFECとFECスタックTLVとMPLSエコー要求を送信：DB8 :: 1/128、および2001のラベルを持ちます。"
    },
    {
      "indent": 3,
      "text": "If an end-to-end path comprises of one or more tunneled or stitched LSPs, each transit node that is the originating point of a new tunnel or segment SHOULD reply back notifying the FEC stack change along with the new FEC details, for example, if LSR X has an LDP mapping for IPv4 prefix 192.0.2.10 on LSR Z (say, label 3001). Say further that LSR A and LSR B are transit nodes along the path, which also have an RSVP tunnel over which LDP is enabled. While replying back, A SHOULD notify that the FEC changes from LDP to <RSVP, LDP>. If the new tunnel is a transparent pipe, i.e., the data-plane trace will not expire in the middle of the tunnel, then the transit node SHOULD NOT reply back notifying the FEC stack change or the new FEC details. If the transit node wishes to hide the nature of the tunnel from the ingress of the echo request, then the transit node MAY notify the FEC stack change and include Nil FEC as the new FEC.",
      "ja": "エンドツーエンドのパスは、1つ以上のトンネリングまたはステッチLSPの含む場合、新しいトンネルまたはセグメントの発信点である各中継ノードは、例えば、新たなFEC詳細と共にFECスタックの変更を通知する返信SHOULD LSR Xは、LSR Z上のIPv4プレフィックス192.0.2.10（たとえば、ラベル3001）のためのLDPマッピングを持っている場合。 LSR AおよびLSR Bはまた、LDPがイネーブルされている上にRSVPのトンネルを有する経路に沿って通過ノードであることがさらに言います。バック返信しながら、Aを通知する必要があることをLDPからのFEC変更<RSVP、LDP>。新しいトンネルが透明な管、すなわちである場合、データプレーントレースはトンネルの中央に期限切れになりません、その後トランジットノードはFECスタック変更または新しいFECの詳細を通知する返信すべきではありません。トランジットノードは、エコー要求の進入からトンネルの性質を隠すことを望む場合、トランジットノードはFECスタックの変更を通知し、新たなFECとして無記号FECを含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.2.1. LDP IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.1.  LDP IPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv4 Prefix FEC is defined in [RFC5036]. When an LDP IPv4 prefix is encoded in a label stack, the following format is used. The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, trailing bits SHOULD be set to zero. See [RFC5036] for an example of a Mapping for an IPv4 FEC.",
      "ja": "IPv4のプレフィックスFECは[RFC5036]で定義されています。 LDP IPv4のプレフィックスがラベルスタックで符号化された場合、以下の形式が使用されます。値は、ビットでプレフィックス長の1つのオクテット続いIPv4プレフィクスの4つのオクテットから成ります。フォーマットは以下のとおりです。 IPv4のプレフィックスは、ネットワークバイトオーダです。プレフィックスが32ビットよりも短い場合、末尾のビットはゼロに設定されるべきです。 IPv4のFECのためのマッピングの例については、[RFC5036]を参照。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.2. LDP IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.2. 自民党のIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv6 Prefix FEC is defined in [RFC5036]. When an LDP IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero. See [RFC5036] for an example of a Mapping for an IPv6 FEC.",
      "ja": "IPv6のプレフィックスFECは[RFC5036]で定義されています。 LDP IPv6プレフィックスをラベルスタックに符号化される場合、以下の形式が使用されます。値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。 IPv6のFECのためのマッピングの例については、[RFC5036]を参照。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.3. RSVP IPv4 LSP",
      "section_title": true,
      "ja": "3.2.3.  RSVP IPv4のLSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The Value fields are taken from RFC 3209 [RFC3209], Sections 4.6.1.1 and 4.6.2.1.",
      "ja": "値は以下の形式があります。値フィールドは、RFC 3209 [RFC3209]から取得され、セクション4.6.1.1および4.6.2.1。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv4 Tunnel Endpoint Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |     Tunnel ID                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv4 Tunnel Sender Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.4. RSVP IPv6 LSP",
      "section_title": true,
      "ja": "3.2.4.  RSVP IPv6のLSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The Value fields are taken from RFC 3209 [RFC3209], Sections 4.6.1.2 and 4.6.2.2.",
      "ja": "値は以下の形式があります。値フィールドは、RFC 3209 [RFC3209]から取得され、セクション4.6.1.2および4.6.2.2。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv6 Tunnel Endpoint Address                  |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |          Tunnel ID            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv6 Tunnel Sender Address                  |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.5. VPN IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.5.  VPN IPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv4 Network Layer Routing Information (NLRI) is defined in [RFC4365]. This document uses the term VPN IPv4 prefix for a VPN-IPv4 NLRI that has been advertised with an MPLS label in BGP. See [RFC3107].",
      "ja": "VPN-IPv4のネットワークレイヤルーティング情報（NLRI）は[RFC4365]で定義されています。この文書は、BGPでのMPLSラベルでアドバタイズされたVPN-IPv4のNLRIのための用語VPNのIPv4プレフィックスを使用しています。 [RFC3107]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv4 prefix is encoded in a label stack, the following format is used. The Value field consists of the RD advertised with the VPN IPv4 prefix, the IPv4 prefix (with trailing 0 bits to make 32 bits in all), and a prefix length, as follows:",
      "ja": "VPN IPv4プレフィクスをラベルスタックに符号化される場合、以下の形式が使用されます。次のようにValueフィールドは、VPN IPv4のプレフィックス、（全部で32ビットを作るために0ビットを末尾で）IPv4プレフィクス、およびプレフィックス長でアドバタイズRDから構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The RD is an 8-octet identifier; it does not contain any inherent information. The purpose of the RD is solely to allow one to create distinct routes to a common IPv4 address prefix. The encoding of the RD is not important here. When matching this field to the local FEC information, it is treated as an opaque value.",
      "ja": "RDは、8オクテット識別子です。それは、どんな固有の情報が含まれていません。 RDの目的は1つが、共通のIPv4アドレスのプレフィックスに明確なルートを作成できるようにするためだけです。 RDのエンコーディングは、ここでは重要ではありません。ローカルFEC情報にこのフィールドに一致する場合には、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.6. VPN IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.6.  VPNのIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv6 NLRI is defined in [RFC4365]. This document uses the term VPN IPv6 prefix for a VPN-IPv6 NLRI that has been advertised with an MPLS label in BGP. See [RFC3107].",
      "ja": "VPN-IPv6のNLRIは、[RFC4365]で定義されています。この文書は、BGPでのMPLSラベルでアドバタイズされたVPN-IPv6のNLRIのための用語VPN IPv6プレフィックスを使用しています。 [RFC3107]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv6 prefix is encoded in a label stack, the following format is used. The Value field consists of the RD advertised with the VPN IPv6 prefix, the IPv6 prefix (with trailing 0 bits to make 128 bits in all), and a prefix length, as follows:",
      "ja": "VPNのIPv6プレフィックスがラベルスタックでコード化された場合、以下のフォーマットが使用されています。次のようにValueフィールドは、VPN IPv6プレフィックス、（全部で128ビットを作るために0ビットを末尾で）IPv6プレフィックス、及びプレフィックス長でアドバタイズRDから構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv6 prefix                           |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The RD is identical to the VPN IPv4 Prefix RD, except that it functions here to allow the creation of distinct routes to IPv6 prefixes. See Section 3.2.5. When matching this field to local FEC information, it is treated as an opaque value.",
      "ja": "RDは、IPv6プレフィックスに異なるルートの作成を可能にするためにここで機能することを除いて、VPN IPv4のプレフィックスRDと同じです。 3.2.5項を参照してください。ローカルFEC情報にこのフィールドに一致する場合には、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.7. L2 VPN Endpoint",
      "section_title": true,
      "ja": "3.2.7.  L2 VPNエンドポイント"
    },
    {
      "indent": 3,
      "text": "VPLS stands for Virtual Private LAN Service. The terms VPLS BGP NLRI and VPLS Edge Identifier (VE ID) are defined in [RFC4761]. This document uses the simpler term L2 VPN endpoint when referring to a VPLS BGP NLRI. The RD is an 8-octet identifier used to distinguish information about various L2 VPNs advertised by a node. The VE ID is a 2-octet identifier used to identify a particular node that serves as the service attachment point within a VPLS. The structure of these two identifiers is unimportant here; when matching these fields to local FEC information, they are treated as opaque values. The encapsulation type is identical to the Pseudowire (PW) Type in Section 3.2.9.",
      "ja": "VPLSは、仮想プライベートLANサービスの略です。用語VPLS BGP NLRIとVPLSエッジ識別子（ID VE）[RFC4761]で定義されています。 VPLS BGP NLRIを参照するときにこの文書では、単純な用語L2 VPNエンドポイントを使用しています。 RDノードによってアドバタイズ各種L2 VPNの情報を区別するために使用される8オクテット識別子です。ザは、IDがVPLS内のサービス接続ポイントとして機能する特定のノードを識別するために使用される2オクテットの識別子であるVE。これら二つの識別子の構造は、ここでは重要ではありません。地元のFEC情報にこれらのフィールドを照合するとき、彼らは不透明な値として扱われます。カプセル化タイプは、疑似回線（PW）セクション3.2.9を入力と同じです。"
    },
    {
      "indent": 3,
      "text": "When an L2 VPN endpoint is encoded in a label stack, the following format is used. The Value field consists of an RD (8 octets), the sender's (of the ping) VE ID (2 octets), the receiver's VE ID (2 octets), and an encapsulation type (2 octets), formatted as follows:",
      "ja": "L2 VPNエンドポイントは、ラベルスタックに符号化される場合、以下の形式が使用されます。値フィールドは、RD（8つのオクテット）、送信者（PINGの）から成る、ID（2つのオクテット）VEレシーバの次のようにフォーマットされ、ID（2つのオクテット）、およびカプセル化タイプ（2つのオクテット）VE："
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Sender's VE ID        |       Receiver's VE ID        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Encapsulation Type       |         Must Be Zero          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.8. FEC 128 Pseudowire - IPv4 (Deprecated)",
      "section_title": true,
      "ja": "3.2.8.  FEC 128疑似 -  IPv4の（非推奨）"
    },
    {
      "indent": 3,
      "text": "See Appendix A.1.1 for details.",
      "ja": "詳細については、付録A.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.9. FEC 128 Pseudowire - IPv4 (Current)",
      "section_title": true,
      "ja": "3.2.9.  FEC 128スードワイヤ -  IPv4の（現在の）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [RFC8077], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed \"encapsulation type\" with the high-order bit set to zero.",
      "ja": "用語PW ID（疑似回線ID）とPWタイプ（疑似タイプ）であるとしてFEC 128（0x80の）は、[RFC8077]で定義されています。 PW IDは、非ゼロの32ビット接続IDです。 PWタイプのカプセル化タイプを示す15ビットの数です。それはゼロに設定上位ビットと呼ばれる「カプセル化タイプ」の下のフィールドに右詰め運ばれます。"
    },
    {
      "indent": 3,
      "text": "Both of these fields are treated in this protocol as opaque values. When matching these fields to the local FEC information, the match MUST be exact.",
      "ja": "これらのフィールドの両方が不透明な値として、このプロトコルで処理されます。ローカルFEC情報にこれらのフィールドを照合すると、マッチは正確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a FEC 128 is encoded in a label stack, the following format is used. The Value field consists of the Sender's Provider Edge (PE) IPv4 Address (the source address of the targeted LDP session), the Remote PE IPv4 Address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128はラベルスタックに符号化される場合、以下の形式が使用されます。 Valueフィールドは、送信者のプロバイダエッジ（PE）のIPv4アドレス（ターゲットLDPセッションの送信元アドレス）、リモートPE IPv4アドレス（ターゲットLDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプなどから構成され次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE IPv4 Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE IPv4 Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.10. FEC 129 Pseudowire - IPv4",
      "section_title": true,
      "ja": "3.2.10.  FEC 129スードワイヤ -  IPv4の"
    },
    {
      "indent": 3,
      "text": "FEC 129 (0x81) and the terms PW Type, Attachment Group Identifier (AGI), Attachment Group Identifier Type (AGI Type), Attachment Individual Identifier Type (AII Type), Source Attachment Individual Identifier (SAII), and Target Attachment Individual Identifier (TAII) are defined in [RFC8077]. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below PW Type with the high-order bit set to zero. All the other fields are treated as opaque values and copied directly from the FEC 129 format. All of these values together uniquely define the FEC within the scope of the LDP session identified by the source and remote PE IPv4 addresses.",
      "ja": "FEC 129（0x81と）や用語PWタイプ、アタッチメントグループ識別子（AGI）、アタッチメントグループの識別子タイプ（AGIタイプ）、アタッチメント個別識別子タイプ（AII型）、ソースアタッチメント個別識別子（SAII）、およびターゲット添付ファイルの個別識別子（ TAII）[RFC8077]で定義されています。 PWタイプのカプセル化タイプを示す15ビットの数です。それはゼロに設定上位ビットとPWタイプの下のフィールドに右詰め運ばれます。他のすべてのフィールドは、不透明な値として扱われ、FEC 129フォーマットから直接コピーされます。一緒に、これらの値の全ては、一意のソース及びリモートPE IPv4アドレスによって識別されるLDPセッションの範囲内でFECを定義します。"
    },
    {
      "indent": 3,
      "text": "When a FEC 129 is encoded in a label stack, the following format is used. The Length of this TLV is 16 + AGI length + SAII length + TAII length. Padding is used to make the total length a multiple of 4; the length of the padding is not included in the Length field.",
      "ja": "FEC 129はラベルスタックに符号化される場合、以下の形式が使用されます。このTLVの長さは、16 + AGI長+ SAII長+ TAII長さです。パディングは、全長4の倍数を作製するために使用されます。詰め物の長さは、長さフィールドに含まれていません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE IPv4 Address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE IPv4 Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |   AGI Type    |  AGI Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           AGI Value                           ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  SAII Length  |      SAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    SAII Value (continued)                     ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  TAII Length  |      TAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    TAII Value (continued)                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  TAII (cont.) |  0-3 octets of zero padding                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.11. FEC 128 Pseudowire - IPv6",
      "section_title": true,
      "ja": "3.2.11.  FEC 128スードワイヤ -  IPv6の"
    },
    {
      "indent": 3,
      "text": "The FEC 128 Pseudowire IPv6 sub-TLV has a structure consistent with the FEC 128 Pseudowire IPv4 sub-TLV as described in Section 3.2.9. The Value field consists of the Sender's PE IPv6 Address (the source address of the targeted LDP session), the Remote PE IPv6 Address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "セクション3.2.9に記載したようにFEC 128スードワイヤのIPv6サブTLVは、FEC 128スードワイヤのIPv4サブTLVと一致する構造を有しています。次のように値フィールドには、送信者のPEのIPv6アドレス（目標LDPセッションの送信元アドレス）、リモートPE IPv6アドレス（目標LDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                     Sender's PE IPv6 Address                  ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                      Remote PE IPv6 Address                   ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Sender's PE IPv6 Address: The source IP address of the target IPv6 LDP session. 16 octets.",
      "ja": "送信者のPE IPv6アドレス：対象のIPv6 LDPセッションの送信元IPアドレス。 16オクテット。"
    },
    {
      "indent": 3,
      "text": "Remote PE IPv6 Address: The destination IP address of the target IPv6 LDP session. 16 octets.",
      "ja": "リモートPE IPv6アドレス：対象のIPv6 LDPセッションの宛先IPアドレス。 16オクテット。"
    },
    {
      "indent": 3,
      "text": "PW ID: Same as FEC 128 Pseudowire IPv4 in Section 3.2.9.",
      "ja": "PWのID：3.2.9項でFEC 128擬似回線はIPv4と同じです。"
    },
    {
      "indent": 3,
      "text": "PW Type: Same as FEC 128 Pseudowire IPv4 in Section 3.2.9.",
      "ja": "PWタイプ：セクション3.2.9におけるFEC 128擬似回線はIPv4と同じです。"
    },
    {
      "indent": 0,
      "text": "3.2.12. FEC 129 Pseudowire - IPv6",
      "section_title": true,
      "ja": "3.2.12.  FEC 129スードワイヤ -  IPv6の"
    },
    {
      "indent": 3,
      "text": "The FEC 129 Pseudowire IPv6 sub-TLV has a structure consistent with the FEC 129 Pseudowire IPv4 sub-TLV as described in Section 3.2.10. When a FEC 129 is encoded in a label stack, the following format is used. The length of this TLV is 40 + AGI (Attachment Group Identifier) length + SAII (Source Attachment Individual Identifier) length + TAII (Target Attachment Individual Identifier) length. Padding is used to make the total length a multiple of 4; the length of the padding is not included in the Length field.",
      "ja": "セクション3.2.10に記載されているようにFEC 129スードワイヤのIPv6サブTLVは、FEC 129スードワイヤのIPv4サブTLVと一致する構造を有しています。 FEC 129はラベルスタックに符号化される場合、以下の形式が使用されます。このTLVの長さは、40 + AGI（添付グループ識別子）長さ+ SAII（ソース添付個体識別子）長さ+ TAII（ターゲット添付個体識別子）長さです。パディングは、全長4の倍数を作製するために使用されます。詰め物の長さは、長さフィールドに含まれていません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                   Sender's PE IPv6 Address                    ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    Remote PE IPv6 Address                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |   AGI Type    |  AGI Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           AGI Value                           ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  SAII Length  |      SAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    SAII Value (continued)                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  TAII Length  |      TAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    TAII Value (continued)                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  TAII (cont.) |  0-3 octets of zero padding                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Sender's PE IPv6 Address: The source IP address of the target IPv6 LDP session. 16 octets.",
      "ja": "送信者のPE IPv6アドレス：対象のIPv6 LDPセッションの送信元IPアドレス。 16オクテット。"
    },
    {
      "indent": 3,
      "text": "Remote PE IPv6 Address: The destination IP address of the target IPv6 LDP session. 16 octets.",
      "ja": "リモートPE IPv6アドレス：対象のIPv6 LDPセッションの宛先IPアドレス。 16オクテット。"
    },
    {
      "indent": 3,
      "text": "The other fields are the same as FEC 129 Pseudowire IPv4 in Section 3.2.10.",
      "ja": "他のフィールドは、セクション3.2.10にFEC 129スードワイヤはIPv4と同じです。"
    },
    {
      "indent": 0,
      "text": "3.2.13. BGP Labeled IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.13.  BGPはIPv4プレフィックス標識"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv4 prefixes are defined in [RFC3107]. When a BGP labeled IPv4 prefix is encoded in a label stack, the following format is used. The Value field consists of the IPv4 prefix (with trailing 0 bits to make 32 bits in all) and the prefix length, as follows:",
      "ja": "BGPは、IPv4のプレフィックスが[RFC3107]で定義される標識されました。 BGP標識されたIPv4のプレフィックスがラベルスタックで符号化された場合、以下の形式が使用されます。次のように値フィールドは、（全部で32ビットを作るために0ビットを末尾で）IPv4のプレフィックスとプレフィックス長で構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.14. BGP Labeled IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.14.  BGPのIPv6プレフィックス標識"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv6 prefixes are defined in [RFC3107]. When a BGP labeled IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "BGPは、IPv6プレフィックスは[RFC3107]で定義される標識されました。 BGPラベルされたIPv6プレフィックスがラベルスタックでコード化された場合、以下のフォーマットが使用されています。値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.15. Generic IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.15. 一般的なIPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, the trailing bits SHOULD be set to zero. This FEC is used if the protocol advertising the label is unknown or may change during the course of the LSP. An example is an inter-AS LSP that may be signaled by LDP in one Autonomous System (AS), by RSVP-TE [RFC3209] in another AS, and by BGP between the ASes, such as is common for inter-AS VPNs.",
      "ja": "値は、ビットでプレフィックス長の1つのオクテット続いIPv4プレフィクスの4つのオクテットから成ります。フォーマットは以下のとおりです。 IPv4のプレフィックスは、ネットワークバイトオーダです。接頭語が32ビットよりも短い場合、後続のビットがゼロに設定されるべきです。ラベルを広告するプロトコルが不明であるか、LSPの進行中に変更されることがあれば、このFECが使用されます。例は、インターAS VPNのが一般的であるような、AS間相互AS別のASにRSVP-TE [RFC3209]で一自律システム（AS）にLDPによってシグナリングすることができるLSP、およびBGPによるものです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.16. Generic IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.16. ジェネリックのIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.17. Nil FEC",
      "section_title": true,
      "ja": "3.2.17. 何FEC"
    },
    {
      "indent": 3,
      "text": "At times, labels from the reserved range, e.g., Router Alert and Explicit-null, may be added to the label stack for various diagnostic purposes such as influencing load-balancing. These labels may have no explicit FEC associated with them. The Nil FEC Stack is defined to allow a Target FEC Stack sub-TLV to be added to the Target FEC Stack to account for such labels so that proper validation can still be performed.",
      "ja": "時間に、予約された範囲からのラベルは、例えば、ルータ警告および明示的ヌルは、このような負荷バランシングに影響を与えるような様々な診断目的のためにラベルスタックに追加することができます。これらのラベルは、それらに関連付けられている明示的なFECを有していなくてもよいです。無記号FECスタックはターゲットFECスタックサブTLVは、適切な検証が依然として行うことができるように、そのような標識を考慮するために、ターゲットFECスタックに追加できるように定義されます。"
    },
    {
      "indent": 3,
      "text": "The Length is 4. Labels are 20-bit values treated as numbers.",
      "ja": "長さ4のラベルが数値として扱われる20ビット値です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Label                 |          MBZ          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Label is the actual label value inserted in the label stack; the MBZ fields MUST be zero when sent and ignored on receipt.",
      "ja": "ラベルは、ラベルスタックに挿入された実際のラベル値です。送られて、領収書の上で無視するときMBZフィールドはゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Downstream Mapping (Deprecated)",
      "section_title": true,
      "ja": "3.3. ダウンストリームマッピング（非推奨）"
    },
    {
      "indent": 3,
      "text": "See Appendix A.2 for more details.",
      "ja": "詳細については、付録A.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4. Downstream Detailed Mapping TLV",
      "section_title": true,
      "ja": "3.4. 下流の詳細なマッピングTLV"
    },
    {
      "indent": 3,
      "text": "The Downstream Detailed Mapping object is a TLV that MAY be included in an MPLS echo request message. Only one Downstream Detailed Mapping object may appear in an echo request. The presence of a Downstream Detailed Mapping object is a request that Downstream Detailed Mapping objects be included in the MPLS echo reply. If the replying router is the destination (Label Edge Router) of the FEC, then a Downstream Detailed Mapping TLV SHOULD NOT be included in the MPLS echo reply. Otherwise, the replying router SHOULD include a Downstream Detailed Mapping object for each interface over which this FEC could be forwarded. For a more precise definition of the notion of \"downstream\", see Section 3.4.2, \"Downstream Router and Interface\".",
      "ja": "下流詳細なマッピングオブジェクトは、MPLSエコー要求メッセージに含まれるかもしれTLVです。唯一のダウンストリームの詳細なマッピングオブジェクトは、エコー要求に表示される場合があります。下流詳細なマッピングオブジェクトの存在は下流の詳細なマッピングオブジェクトはMPLSエコー応答に含まれる要求です。返答ルータがFECの先（ラベルエッジルータ）である場合には、川下詳細なマッピングTLVは、MPLSエコー応答に含まれるべきではありません。そうでなければ、応答ルータは、このFECを転送することができ、その上、各インターフェイスのダウンストリーム詳細なマッピング・オブジェクトが含まれるべきです。 「下流」の概念のより正確な定義については、セクション3.4.2、「ダウンストリームルータとインタフェース」を参照してください。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               MTU             | Address Type  |    DS Flags   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Address (4 or 16 octets)             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Downstream Interface Address (4 or 16 octets)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Return Code  | Return Subcode|        Sub-TLV Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                      List of Sub-TLVs                         .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Downstream Detailed Mapping TLV format is derived from the deprecated Downstream Mapping TLV format (see Appendix A.2.) The key change is that variable length and optional fields have been converted into sub-TLVs.",
      "ja": "下流詳細マッピングTLVフォーマットは廃止下流マッピングTLVフォーマットから導出される（付録A.2を参照。）キー変更が可変長とオプションフィールドは、サブのTLVに変換されていることです。"
    },
    {
      "indent": 3,
      "text": "Maximum Transmission Unit (MTU)",
      "ja": "最大転送単位（MTU）"
    },
    {
      "indent": 6,
      "text": "The MTU is the size in octets of the largest MPLS frame (including label stack) that fits on the interface to the downstream LSR.",
      "ja": "MTUは、下流のLSRへのインタフェースに収まる（ラベルスタックを含む）最大のMPLSフレームのオクテットサイズです。"
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the Downstream IP Address and Downstream Interface fields. The Address Type is set to one of the following values:",
      "ja": "インターフェースは、番号または番号なしの場合はアドレスタイプを示します。また、ダウンストリームIPアドレスとダウンストリームインターフェイスフィールドの長さを決定します。アドレスタイプは、次のいずれかの値に設定されています："
    },
    {
      "indent": 7,
      "text": "Type #        Address Type\n------        ------------\n     1        IPv4 Numbered\n     2        IPv4 Unnumbered\n     3        IPv6 Numbered\n     4        IPv6 Unnumbered",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DS Flags",
      "ja": "DSフラグ"
    },
    {
      "indent": 6,
      "text": "The DS Flags field is a bit vector of various flags with the following format:",
      "ja": "DSのFlagsフィールドは、次の形式の様々なフラグのビットベクトルであります："
    },
    {
      "indent": 7,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| Rsvd(MBZ) |I|N|\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Two flags are defined currently, I and N. The remaining flags MUST be set to zero when sending and ignored on receipt.",
      "ja": "二つのフラグが現在定義され、IおよびN.残りのフラグは、送信時にゼロに設定して、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 7,
      "text": "Flag  Name and Meaning\n----  ----------------\n   I  Interface and Label Stack Object Request",
      "raw": true
    },
    {
      "indent": 13,
      "text": "When this flag is set, it indicates that the replying\nrouter SHOULD include an Interface and Label Stack\nObject in the echo reply message.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "N Treat as a Non-IP Packet",
      "ja": "N非IPパケットとして扱います"
    },
    {
      "indent": 13,
      "text": "Echo request messages will be used to diagnose non-IP flows. However, these messages are carried in IP packets. For a router that alters its ECMP algorithm based on the FEC or deep packet examination, this flag requests that the router treat this as it would if the determination of an IP payload had failed.",
      "ja": "エコー要求メッセージは、非IPフローを診断するために使用されます。しかし、これらのメッセージは、IPパケットで運ばれます。 、FECまたはディープパケット検査に基づいてIPペイロードの決意が失敗した場合、ルータはそれと同じように、これを扱うこのフラグ要求をそのECMPアルゴリズムを変更ルータの。"
    },
    {
      "indent": 3,
      "text": "Downstream Address and Downstream Interface Address",
      "ja": "下流の住所と下流のインターフェイスアドレス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスが4つのオクテットで符号化されます。 IPv6アドレスは16個のオクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is numbered, then the Address Type MUST be set to IPv4 or IPv6, the Downstream Address MUST be set to either the downstream LSR's Router ID or the interface address of the downstream LSR, and the Downstream Interface Address MUST be set to the downstream LSR's interface address.",
      "ja": "下流のLSRへのインタフェースが番号付けされている場合は、アドレスタイプはIPv4またはIPv6に設定しなければならなくて、ダウンストリームアドレスは、ダウンストリームLSRのルータIDまたは下流のLSRのインターフェースアドレスのいずれかに設定され、ダウンストリームインターフェイスアドレスでなければなりませんMUST下流のLSRのインターフェースアドレスに設定すること。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is unnumbered, the Address Type MUST be IPv4 Unnumbered or IPv6 Unnumbered, the Downstream Address MUST be the downstream LSR's Router ID, and the Downstream Interface Address MUST be set to the index assigned by the upstream LSR to the interface.",
      "ja": "ダウンストリームLSRへのインターフェースに番号が付いていない場合、アドレスタイプは、IPv4またはIPv6番号なし番号なしで、ダウンストリームアドレス下流LSRのルータIDでなければなりません、そしてダウンストリームインターフェイスアドレスは上流LSRによって割り当てられたインデックスに設定しなければなりませんインタフェース。"
    },
    {
      "indent": 6,
      "text": "If an LSR does not know the IP address of its neighbor, then it MUST set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it must set the Downstream Address to 127.0.0.1; for IPv6, the address is set to 0::1. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with either of these addresses in the Downstream Address field, this indicates that it MUST bypass interface verification but continue with label validation.",
      "ja": "LSRがネイバーのIPアドレスを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定しなければなりません。 IPv4の場合、それは127.0.0.1へのダウンストリームのアドレスを設定する必要があります。 IPv6のために、アドレスが0 :: 1に設定されています。 LSRは、ダウンストリームAddressフィールドに、これらのアドレスのいずれかでエコー要求パケットを受信した場合、両方のケースでは、インターフェイス・インデックスは、0に設定しなければならない、これはインタフェースの検証をバイパスするが、ラベルの検証を継続しなければならないことを示しています。"
    },
    {
      "indent": 6,
      "text": "If the originator of an echo request packet wishes to obtain Downstream Detailed Mapping information but does not know the expected label stack, then it SHOULD set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it MUST set the Downstream Address to 224.0.0.2; for IPv6, the address MUST be set to FF02::2. In both cases, the interface index MUST be set to 0. If an LSR receives an echo request packet with the all-routers multicast address, then this indicates that it MUST bypass both interface and label stack validation but return Downstream Mapping TLVs using the information provided.",
      "ja": "エコー要求パケットの発信元は、ダウンストリームの詳細なマッピング情報を得たいが、予想されるラベルスタックを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定する必要があります。 IPv4の場合、それは224.0.0.2へのダウンストリームアドレスを設定する必要があります。 IPv6のために、アドレスがFF02 :: 2に設定しなければなりません。 LSRは、全ルータのマルチキャストアドレスを有するエコー要求パケットを受信した場合の両方の場合において、インターフェースインデックスが0に設定されなければならない、これは、それが両方のインターフェースとラベルスタックの検証をバイパスするが、ダウンストリームマッピングのTLV情報を使用して返さなければならないことを示しています提供。"
    },
    {
      "indent": 3,
      "text": "Return Code",
      "ja": "リターンコード"
    },
    {
      "indent": 6,
      "text": "The Return Code is set to zero by the sender of an echo request. The receiver of said echo request can set it in the corresponding echo reply that it generates to one of the values specified in Section 3.1 other than 14.",
      "ja": "リターンコードは、エコー要求の送信者によってゼロに設定されています。前記エコー要求の受信機は、それが14以外のセクション3.1で指定された値のいずれかに発生する対応するエコー応答でそれを設定することができます。"
    },
    {
      "indent": 6,
      "text": "If the receiver sets a non-zero value of the Return Code field in the Downstream Detailed Mapping TLV, then the receiver MUST also set the Return Code field in the echo reply header to \"See DDMAP TLV for Return Code and Return Subcode\" (Section 3.1). An exception to this is if the receiver is a bud node [RFC4461] and is replying as both an egress and a transit node with a Return Code of 3 (\"Replying router is an egress for the FEC at stack-depth <RSC>\") in the echo reply header.",
      "ja": "受信機は、ダウンストリームの詳細なマッピングTLVに戻りコードフィールドの非ゼロ値を設定した場合、受信機は、「リターンコードとリターンサブコードためDDMAP TLVを見る」ためにエコー応答ヘッダに戻りコードフィールドを設定しなければならない（セクション3.1）。受信機は、芽ノード[RFC4461]であり、出口3の戻りコードを有するトランジットノードの両方として返信された場合、この例外は、「ルータを返信するスタック深さでのFECのための出口である<RSC>」（あります）エコー応答ヘッダです。"
    },
    {
      "indent": 6,
      "text": "If the Return Code of the echo reply message is not set to either \"See DDMAP TLV for Return Code and Return Subcode\" (Section 3.1) or \"Replying router is an egress for the FEC at stack-depth <RSC>\", then the Return Code specified in the Downstream Detailed Mapping TLV MUST be ignored.",
      "ja": "エコー応答メッセージの戻りコードは（3.1節）、または「リターンコードとリターンサブコードを参照してくださいDDMAP TLV」のいずれかに設定されていない場合は、「ルータを返信するスタックの深さでFECのための出口がある<RSC>」、そして、リターンコードは、TLVを無視しなければなりません川下詳細なマッピングで指定されました。"
    },
    {
      "indent": 3,
      "text": "Return Subcode",
      "ja": "リターンサブコード"
    },
    {
      "indent": 6,
      "text": "The Return Subcode is set to zero by the sender. The receiver can set this field to an appropriate value as specified in Section 3.1: The Return Subcode is filled in with the stack-depth for those codes that specify the stack-depth. For all other codes, the Return Subcode MUST be set to zero.",
      "ja": "リターンサブコードは、送信者によってゼロに設定されています。セクション3.1で指定されるように受信機が適切な値にこのフィールドを設定することができる：リターンサブコードは、スタックの深さを指定し、それらのコードのスタック深さで充填されています。他のすべてのコードの場合、リターン・サブコードをゼロに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the Return Code of the echo reply message is not set to either \"See DDMAP TLV for Return Code and Return Subcode\" (Section 3.1) or \"Replying router is an egress for the FEC at stack-depth <RSC>\", then the Return Subcode specified in the Downstream Detailed Mapping TLV MUST be ignored.",
      "ja": "エコー応答メッセージの戻りコードは（3.1節）、または「リターンコードとリターンサブコードを参照してくださいDDMAP TLV」のいずれかに設定されていない場合は、「ルータを返信するスタックの深さでFECのための出口がある<RSC>」、そして、川下詳細なマッピングTLVで指定されたサブコードを返しますが無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Sub-TLV Length",
      "ja": "サブTLVの長さ"
    },
    {
      "indent": 6,
      "text": "Total length in octets of the sub-TLVs associated with this TLV.",
      "ja": "このTLVに関連付けられたサブのTLVのオクテットで全長。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Sub-TLVs",
      "section_title": true,
      "ja": "3.4.1. サブのTLV"
    },
    {
      "indent": 3,
      "text": "This section defines the sub-TLVs that MAY be included as part of the Downstream Detailed Mapping TLV.",
      "ja": "このセクションでは、下流詳細マッピングTLVの一部として含まれ得るサブTLVを定義します。"
    },
    {
      "indent": 11,
      "text": " Sub-Type    Value Field\n---------   ------------\n  1         Multipath data\n  2         Label stack\n  3         FEC stack change",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.4.1.1. Multipath Data Sub-TLV",
      "section_title": true,
      "ja": "3.4.1.1。マルチパスデータサブTLV"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Multipath Type |       Multipath Length        |Reserved (MBZ) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                  (Multipath Information)                      |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The multipath data sub-TLV includes Multipath Information.",
      "ja": "マルチパスデータサブTLVは、マルチパスの情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Multipath Type",
      "ja": "マルチタイプ"
    },
    {
      "indent": 6,
      "text": "The type of the encoding for the Multipath Information.",
      "ja": "マルチパス情報のエンコードの種類。"
    },
    {
      "indent": 6,
      "text": "The following Multipath Types are defined in this document:",
      "ja": "以下のマルチパスの種類は、この文書で定義されています。"
    },
    {
      "indent": 6,
      "text": "Key   Type                  Multipath Information\n---   ----------------      ---------------------\n 0    no multipath          Empty (Multipath Length = 0)\n 2    IP address            IP addresses\n 4    IP address range      low/high address pairs\n 8    Bit-masked IP         IP address prefix and bit mask\n        address set\n 9    Bit-masked label set  Label prefix and bit mask",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 0 indicates that all packets will be forwarded out this one interface.",
      "ja": "タイプ0は、すべてのパケットはこの1つのインターフェイスから転送されることを示します。"
    },
    {
      "indent": 6,
      "text": "Types 2, 4, 8, and 9 specify that the supplied Multipath Information will serve to exercise this path.",
      "ja": "タイプ2、4、8、および9は、供給マルチパスの情報は、このパスを行使するのに役立つであろうことを指定します。"
    },
    {
      "indent": 3,
      "text": "Multipath Length",
      "ja": "マルチパスの長さ"
    },
    {
      "indent": 6,
      "text": "The length in octets of the Multipath Information.",
      "ja": "マルチパス情報のオクテットの長さ。"
    },
    {
      "indent": 3,
      "text": "MBZ",
      "ja": "QN"
    },
    {
      "indent": 6,
      "text": "MUST be set to zero when sending; MUST be ignored on receipt.",
      "ja": "送信する際に、ゼロに設定しなければなりません。領収書で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Multipath Information",
      "ja": "マルチインフォメーション"
    },
    {
      "indent": 6,
      "text": "Encoded multipath data (e.g., encoded address or label values), according to the Multipath Type. See Section 3.4.1.1.1 for encoding details.",
      "ja": "マルチパスタイプに応じて符号化されたマルチパスデータ（例えば、符号化されたアドレス又はラベル値）。エンコードの詳細については、セクション3.4.1.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.1.1.1. Multipath Information Encoding",
      "section_title": true,
      "ja": "3.4.1.1.1。マルチパス情報のエンコーディング"
    },
    {
      "indent": 3,
      "text": "The Multipath Information encodes labels or addresses that will exercise this path. The Multipath Information depends on the Multipath Type. The contents of the field are shown in the table above. IPv4 addresses are drawn from the range 127/8; IPv6 addresses are drawn from the range 0:0:0:0:0:FFFF:7F00:0/104. Labels are treated as numbers, i.e., they are right justified in the field. For Type 4, ranges indicated by address pairs MUST NOT overlap and MUST be in ascending sequence.",
      "ja": "マルチパス情報は、このパスを行使するラベルやアドレスを符号化します。マルチパス情報は、マルチパスの種類に依存します。フィールドの内容は、上記の表に示されています。 IPv4アドレスは、範囲8分の127から引き出されます。 0：0：0：0：FFFF：7F00：0/104 IPv6アドレスは範囲0から描かれています。ラベルはつまり、彼らはフィールドで右詰めされ、数値として扱われます。タイプ4のために、アドレスのペアで示される範囲が重複してはならないと昇順でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Type 8 allows a more dense encoding of IP addresses. The IP prefix is formatted as a base IP address with the non-prefix low-order bits set to zero. The maximum prefix length is 27. Following the prefix is a mask of length 2^(32 - prefix length) bits for IPv4 and 2^(128 - prefix length) bits for IPv6. Each bit set to 1 represents a valid address. The address is the base IPv4 address plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. For example, the IPv4 addresses 127.2.1.0, 127.2.1.5-127.2.1.15, and 127.2.1.20-127.2.1.29 would be encoded as follows:",
      "ja": "タイプ8は、IPアドレスのより密なエンコーディングを可能にします。 IPプレフィックスはゼロに設定非接頭下位ビットとベースIPアドレスとしてフォーマットされます。最大プレフィックス長は、プレフィックスの後に27の長さ2 ^（32  - プレフィックス長）のマスクであるIPv4のビットと2 ^（128  - プレフィックス長）IPv6のためのビット。 1に設定された各ビットは、有効なアドレスを表します。アドレスは、ベースのIPv4アドレスとビットはゼロから始まり右に左番号付けされたマスク内のビットの位置です。例えば、IPv4が127.2.1.0、127.2.1.5-127.2.1.15に対処し、そして次のように127.2.1.20-127.2.1.29は、符号化されるであろう。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Those same addresses embedded in IPv6 would be encoded as follows:",
      "ja": "次のようにIPv6の中に埋め込まれたものと同じアドレスをエンコードすることになります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Type 9 allows a more dense encoding of labels. The label prefix is formatted as a base label value with the non-prefix low-order bits set to zero. The maximum prefix (including leading zeros due to encoding) length is 27. Following the prefix is a mask of length 2^(32 - prefix length) bits. Each bit set to one represents a valid label. The label is the base label plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. Label values of all the odd numbers between 1152 and 1279 would be encoded as follows:",
      "ja": "タイプ9は、ラベルのより密なエンコーディングを可能にします。ラベルプレフィックスはゼロに設定非接頭下位ビットとベースラベル値としてフォーマットされます。ビット - 長さは、接頭辞に続いて27である（符号化による先行ゼロを含む）の最大プレフィックス長2 ^（プレフィックス長32）のマスクです。 1に設定された各ビットは、有効なラベルを表します。ラベルは、ベースラベルプラスビットはゼロから始まる左から右に番号付けされたマスク内のビットの位置です。次のように1152と1279の間の全ての奇数番号のラベル値は、符号化されるであろう。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the received Multipath Information is non-null, the labels and IP addresses MUST be picked from the set provided. If none of these labels or addresses map to a particular downstream interface, then for that interface, the type MUST be set to 0. If the received Multipath Information is null (i.e., Multipath Length = 0, or for Types 8 and 9, a mask of all zeros), the type MUST be set to 0.",
      "ja": "受信マルチパス情報が非nullの場合、ラベルとIPアドレスが提供集合から選ばれなければなりません。これらのラベルまたはアドレスのいずれも、特定のダウンストリームインタフェースにマップしない場合は受信したマルチパス情報（すなわち、マルチパス長= 0、またはタイプ8と9のためにnullである場合、そのインターフェイスのために、タイプ0に設定しなければなりません、Aすべてゼロのマスク）、タイプが0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, suppose LSR X at hop 10 has two downstream LSRs, Y and Z, for the FEC in question. The received X could return Multipath Type 4, with low/high IP addresses of 127.1.1.1->127.1.1.255 for downstream LSR Y and 127.2.1.1->127.2.1.255 for downstream LSR Z. The head end reflects this information to LSR Y. Y, which has three downstream LSRs, U, V, and W, computes that 127.1.1.1->127.1.1.127 would go to U and 127.1.1.128-> 127.1.1.255 would go to V. Y would then respond with 3 Downstream Detailed Mapping TLVs: to U, with Multipath Type 4 (127.1.1.1->127.1.1.127); to V, with Multipath Type 4 (127.1.1.127->127.1.1.255); and to W, with Multipath Type 0.",
      "ja": "例えば、ホップ10におけるLSR Xが問題のFECのための2つの下流のLSR、Y及びZを、有していると仮定する。受信されたXは、ヘッドエンドは、LSRにこの情報を反映下流LSR Y用127.1.1.1-> 127.1.1.255と下流LSRのZ.ため127.2.1.1-> 127.2.1.255の低/高IPアドレスと、マルチパスタイプ4を返すことができ3つの下流のLSR、U、V、およびWを持っているY. Yは、127.1.1.1-> 127.1.1.127がUに行くだろうと> 127.1.1.255 127.1.1.128-がV. Yに行くだろうと計算して、その後に応答することになります3つの下流詳細なマッピングのTLV：Uに、マルチタイプ4（> 127.1.1.127 127.1.1.1-）を有します。 Vに、マルチパスタイプ4（127.1.1.127-> 127.1.1.255）を有します。そしてマルチパスタイプ0とWへ。"
    },
    {
      "indent": 3,
      "text": "Note that computing Multipath Information may impose a significant processing burden on the receiver. A receiver MAY thus choose to process a subset of the received prefixes. The sender, on receiving a reply to a Downstream Detailed Mapping with partial information, SHOULD assume that the prefixes missing in the reply were skipped by the receiver and MAY re-request information about them in a new echo request.",
      "ja": "マルチパス情報を計算すると、受信機にかなりの処理負担を課すことに注意してください。受信機は、受信したプレフィックスのサブセットを処理するために選ぶかもしれ。送信者は、部分的な情報と川下の詳細なマッピングへの応答を受信すると、返信に欠けているプレフィックスが受信機によってスキップされた、新たなエコー要求でそれらの情報要求を再かもしれないことを前提とすべきです。"
    },
    {
      "indent": 3,
      "text": "The encoding of Multipath Information in scenarios where a few LSRs apply Entropy-label-based load-balancing while other LSRs are non-EL (IP-based) load balanced will be defined in a different document.",
      "ja": "他のLSRがバランス非EL（IPベース）ロードしている間、いくつかのLSRは、エントロピー・ラベル・ベースのロードバランシングを適用するシナリオにおけるマルチパス情報の符号化は、異なるドキュメントで定義されます。"
    },
    {
      "indent": 3,
      "text": "The encoding of Multipath Information in scenarios where LSRs have Layer 2 ECMP over Link Aggregation Group (LAG) interfaces will be defined in a different document.",
      "ja": "LSRは、ECMPリンクアグリゲーショングループ（LAG）のインターフェイス上でレイヤ2を持っているシナリオでマルチパス情報の符号化は、異なるドキュメントで定義されます。"
    },
    {
      "indent": 0,
      "text": "3.4.1.2. Label Stack Sub-TLV",
      "section_title": true,
      "ja": "3.4.1.2。ラベルスタックサブTLV"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Label Stack sub-TLV contains the set of labels in the label stack as it would have appeared if this router were forwarding the packet through this interface. Any Implicit Null labels are explicitly included. The number of label/protocol pairs present in the sub-TLV is determined based on the sub-TLV data length. When the Downstream Detailed Mapping TLV is sent in the echo reply, this sub-TLV MUST be included.",
      "ja": "このルータは、このインターフェイスを介してパケットを転送した場合、それは登場していたとして、ラベルスタックのサブTLVはラベルスタックのラベルのセットが含まれています。暗黙的ヌルラベルは、明示的に含まれています。サブTLVに存在するラベル/プロトコルのペアの数は、サブTLVデータ長に基づいて決定されます。下流詳細マッピングTLVがエコー応答で送信されると、このサブTLVを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Downstream Label",
      "ja": "下流ラベル"
    },
    {
      "indent": 6,
      "text": "A downstream label is 24 bits, in the same format as an MPLS label minus the TTL field, i.e., the MSBit of the label is bit 0, the LSBit is bit 19, the TC field [RFC5462] is bits 20-22, and S is bit 23. The replying router SHOULD fill in the TC field and S bit; the LSR receiving the echo reply MAY choose to ignore these.",
      "ja": "ダウンストリームラベルは、MPLSラベルマイナスTTLフィールドと同じ形式で、すなわち、ラベルのMSBitからビット0 24ビットとし、最下位ビットはビット19であり、TCフィールド[RFC5462]はビット20-22であり、そしてSは、返答ルータがTCフィールドとSビットを記入すべきビット23です。エコー応答を受信LSRはこれらを無視することを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Protocol",
      "ja": "プロトコル"
    },
    {
      "indent": 6,
      "text": "This specifies the label distribution protocol for the Downstream label. Protocol values are taken from the following table:",
      "ja": "これは、ダウンストリームラベルのラベル配布プロトコルを指定します。プロトコル値は、次の表から取られています。"
    },
    {
      "indent": 6,
      "text": "Protocol #        Signaling Protocol\n----------        ------------------\n         0        Unknown\n         1        Static\n         2        BGP\n         3        LDP\n         4        RSVP-TE",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.4.1.3. FEC Stack Change Sub-TLV",
      "section_title": true,
      "ja": "3.4.1.3。 FECスタックの変更サブTLV"
    },
    {
      "indent": 3,
      "text": "A router MUST include the FEC stack change sub-TLV when the downstream node in the echo reply has a different FEC Stack than the FEC Stack received in the echo request. One or more FEC stack change sub-TLVs MAY be present in the Downstream Detailed Mapping TLV. The format is as below.",
      "ja": "エコー応答における下流ノードがFECスタックとは異なるFECスタックがエコー要求で受信したときにルータがFECスタック切り替えサブTLVを含まなければなりません。一つ以上のFECスタック切り替えサブTLVが下流詳細マッピングTLVに存在してもよいです。書式は以下の通りです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Operation Type | Address Type  | FEC-tlv length|  Reserved     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Remote Peer Address (0, 4, or 16 octets)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                         FEC TLV                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Operation Type",
      "ja": "操作タイプ"
    },
    {
      "indent": 6,
      "text": "The operation type specifies the action associated with the FEC stack change. The following operation types are defined:",
      "ja": "操作タイプは、FECスタックの変更に関連するアクションを指定します。次の操作タイプが定義されています。"
    },
    {
      "indent": 12,
      "text": "Type #     Operation\n------     ---------\n1          Push\n2          Pop",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates the remote peer's address type. The Address Type is set to one of the following values. The length of the peer address is determined based on the address type. The address type MAY be different from the address type included in the Downstream Detailed Mapping TLV. This can happen when the LSP goes over a tunnel of a different address family. The address type MAY be set to Unspecified if the peer address is either unavailable or the transit router does not wish to provide it for security or administrative reasons.",
      "ja": "アドレスタイプは、リモートピアのアドレスタイプを示します。アドレスタイプは、次のいずれかの値に設定されています。ピアアドレスの長さは、アドレス・タイプに基づいて決定されます。アドレスタイプは、下流の詳細なマッピングTLVに含まれるアドレス・タイプと異なっていてもよいです。 LSPは異なるアドレスファミリのトンネル上になったときに発生することがあります。ピアアドレスが使用できないか、トランジットルータのどちらかである場合は、アドレスの種類は、セキュリティや管理上の理由のためにそれを提供したくない未指定に設定されるかもしれません。"
    },
    {
      "indent": 11,
      "text": "Type #   Address Type   Address length\n------   ------------   --------------\n0        Unspecified    0\n1        IPv4           4\n2        IPv6           16",
      "raw": true
    },
    {
      "indent": 3,
      "text": "FEC TLV Length",
      "ja": "FEC TLVの長さ"
    },
    {
      "indent": 6,
      "text": "Length in octets of the FEC TLV.",
      "ja": "FEC TLVのオクテットの長さ。"
    },
    {
      "indent": 3,
      "text": "Reserved",
      "ja": "予約済み"
    },
    {
      "indent": 6,
      "text": "This field is reserved for future use and MUST be set to zero.",
      "ja": "このフィールドは、将来の使用のために予約され、ゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Address",
      "ja": "リモートピアアドレス"
    },
    {
      "indent": 6,
      "text": "The remote peer address specifies the remote peer that is the next hop for the FEC being currently traced. If the operation type is PUSH, the remote peer address is the address of the peer from which the FEC being pushed was learned. If the operation type is pop, the remote peer address MAY be set to Unspecified.",
      "ja": "リモートピアのアドレスは、現在トレースされるFECのための次のホップであるリモートピアを指定します。操作種別がPUSHである場合、リモートピアのアドレスがプッシュされてFECが学習されたピアのアドレスです。操作タイプがポップされた場合は、リモートピアアドレスは未指定に設定されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "For upstream-assigned labels [RFC5331], an operation type of pop will have a remote peer address (the upstream node that assigned the label), and this SHOULD be included in the FEC stack change sub-TLV. The remote peer address MAY be set to Unspecified if the address needs to be hidden.",
      "ja": "上流割り当てられたラベル[RFC5331]のために、ポップの操作タイプは、リモートピアのアドレス（ラベルを割り当て上流ノード）を有し、これはFECスタック変化サブTLVに含まれるべきです。アドレスを非表示にする必要がある場合は、リモートピアアドレスは未指定に設定されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "FEC TLV",
      "ja": "FEC TLV"
    },
    {
      "indent": 6,
      "text": "The FEC TLV is present only when the FEC-tlv length field is non-zero. The FEC TLV specifies the FEC associated with the FEC stack change operation. This TLV MAY be included when the operation type is pop. It MUST be included when the operation type is PUSH. The FEC TLV contains exactly one FEC from the list of FECs specified in Section 3.2. A Nil FEC MAY be associated with a PUSH operation if the responding router wishes to hide the details of the FEC being pushed.",
      "ja": "FEC TLVはFEC-TLVの長さフィールドが非ゼロである場合にのみ存在します。 FEC TLVはFECスタックの変更操作に関連付けられているFECを指定します。操作タイプがポップであるとき、このTLVが含まれるかもしれません。操作タイプがPUSHがあるときにそれを含まなければなりません。 FEC TLVは、3.2節で指定されたのFECのリストから、正確に1つのFECが含まれています。応答ルータが押されるFECの詳細を隠すことを望む場合ナシFECは、プッシュ操作に関連付けられてもよいです。"
    },
    {
      "indent": 3,
      "text": "FEC stack change sub-TLV operation rules are as follows:",
      "ja": "次のようにFECスタック変更サブTLV運用規則は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "a. A FEC stack change sub-TLV containing a PUSH operation MUST NOT be followed by a FEC stack change sub-TLV containing a pop operation.",
      "ja": "A。プッシュ動作を含むFECスタック切り替えサブTLVはFECスタック変化ポップ操作を含むサブTLVに続いてはいけません。"
    },
    {
      "indent": 3,
      "text": "b. One or more pop operations MAY be followed by one or more PUSH operations.",
      "ja": "B。 1つまたは複数のウィンドウ操作が一つ以上のPUSH操作を行ってもよいです。"
    },
    {
      "indent": 3,
      "text": "c. One FEC stack change sub-TLV MUST be included per FEC stack change. For example, if 2 labels are going to be pushed, then one FEC stack change sub-TLV MUST be included for each FEC.",
      "ja": "C。一つのFECスタック切り替えサブTLVはFECスタック切り替え当たりに含まれるなければなりません。 2つのラベルは、次いで、プッシュしようとしている場合、例えば、1つのFECスタック切り替えサブTLVは、各FECのために含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "d. A FEC splice operation (an operation where one FEC ends and another FEC starts, MUST be performed by including a pop type FEC stack change sub-TLV followed by a PUSH type FEC stack change sub-TLV.",
      "ja": "D。 1つのFEC終了し、別のFEC開始は、ポップタイプFECスタック変化サブTLVを含めることによって実行されなければならないFECスプライス動作（動作PUSH型FECスタック変化サブTLVが続きます。"
    },
    {
      "indent": 3,
      "text": "e. A Downstream Detailed Mapping TLV containing only one FEC stack change sub-TLV with pop operation is equivalent to IS_EGRESS (Return Code 3, Section 3.1) for the outermost FEC in the FEC stack. The ingress router performing the LSP traceroute MUST treat such a case as an IS_EGRESS for the outermost FEC.",
      "ja": "電子。ポップ操作で一つだけFECスタック切り替えサブTLVを含む下流の詳細なマッピングTLVはFECスタックの最も外側のFECのためIS_EGRESS（戻りコード3、セクション3.1）と同等です。 LSPのtracerouteを実行入口ルータは、最も外側のFECのためIS_EGRESSようなケースを扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Downstream Router and Interface",
      "section_title": true,
      "ja": "3.4.2. ダウンストリームルータとのインターフェイス"
    },
    {
      "indent": 3,
      "text": "The notion of \"downstream router\" and \"downstream interface\" should be explained. Consider an LSR X. If a packet that was originated with TTL n>1 arrived with outermost label L and TTL=1 at LSR X, X must be able to compute which LSRs could receive the packet if it was originated with TTL=n+1, over which interface the request would arrive and what label stack those LSRs would see. (It is outside the scope of this document to specify how this computation is done.) The set of these LSRs/interfaces consists of the downstream routers/ interfaces (and their corresponding labels) for X with respect to L. Each pair of downstream router and interface requires a separate Downstream Detailed Mapping to be added to the reply.",
      "ja": "「下流ルータ」と「下流インターフェース」の概念を説明する必要があります。 TTLで発信されたパケットN> 1 LSR Xに最も外側のラベルLとTTL = 1で到着した場合、XはそれがTTL = N +で発信された場合、パケットを受信できたのLSRを計算することができなければならないLSR Xを考えます1は、そのインタフェースを介して要求が到着し、どのようなラベルは、それらのLSRが見るであろうスタックでしょう。 （なお、この計算がどのように行われるかを指定するには、この文書の範囲外である。）これらのLSR /インターフェースのセットが下流ルータ/インターフェース（およびそれらの対応するラベル）で構成L.に対するXのための下流のルータの各対インターフェースは、応答に追加される別個の下流の詳細なマッピングを必要とします。"
    },
    {
      "indent": 3,
      "text": "The case where X is the LSR originating the echo request is a special case. X needs to figure out what LSRs would receive the MPLS echo request for a given FEC Stack that X originates with TTL=1.",
      "ja": "Xは、エコー要求を発信するLSRである場合は特殊なケースです。 Xは、のLSRは、Xは、TTL = 1で発信することを考えるとFECスタックのためのMPLSエコー要求を受け取ることになるかを把握する必要があります。"
    },
    {
      "indent": 3,
      "text": "The set of downstream routers at X may be alternative paths (see the discussion below on ECMP) or simultaneous paths (e.g., for MPLS multicast). In the former case, the Multipath Information is used as a hint to the sender as to how it may influence the choice of these alternatives.",
      "ja": "Xにおける下流ルータのセットは、代替パス（ECMP上の以下の説明を参照）または同時パス（例えば、MPLSのマルチキャストのための）であってもよいです。前者の場合には、マルチパスの情報は、として、それはこれらの選択肢の選択に影響を与えることがどのように送信者へのヒントとして使用されています。"
    },
    {
      "indent": 0,
      "text": "3.5. Pad TLV",
      "section_title": true,
      "ja": "3.5. パッドTLV"
    },
    {
      "indent": 3,
      "text": "The value part of the Pad TLV contains a variable number (>= 1) of octets. The first octet takes values from the following table; all the other octets (if any) are ignored. The receiver SHOULD verify that the TLV is received in its entirety, but otherwise ignores the contents of this TLV, apart from the first octet.",
      "ja": "パッドTLVの値の一部は、オクテットの可変数（> = 1）を含みます。最初のオクテットは、次の表の値をとります。他のすべてのオクテット（もしあれば）は無視されます。受信機は、TLVは、その全体が受信されていることを確認し、それ以外離れ最初のオクテットから、このTLVの内容を無視すべきです。"
    },
    {
      "indent": 4,
      "text": "  Value        Meaning\n  -----        -------\n      0        Reserved\n      1        Drop Pad TLV from reply\n      2        Copy Pad TLV to reply\n  3-250        Unassigned\n251-254        Reserved for Experimental Use\n    255        Reserved",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Pad TLV can be added to an echo request to create a message of a specific length in cases where messages of various sizes are needed for troubleshooting. The first octet allows for controlling the inclusion of this additional padding in the respective echo reply.",
      "ja": "パッドTLVは、様々なサイズのメッセージをトラブルシューティングするために必要とされる場合には、特定の長さのメッセージを作成するために、エコー要求に追加することができます。最初のオクテットは、それぞれエコー応答におけるこの追加のパディングを含めるを制御することを可能にします。"
    },
    {
      "indent": 0,
      "text": "3.6. Vendor Enterprise Number",
      "section_title": true,
      "ja": "3.6. ベンダー企業数"
    },
    {
      "indent": 3,
      "text": "\"Private Enterprise Numbers\" [IANA-ENT] are maintained by IANA. The Length of this TLV is always 4; the value is the Structure of Management Information (SMI) Private Enterprise Code, in network octet order, of the vendor with a Vendor Private extension to any of the fields in the fixed part of the message, in which case this TLV MUST be present. If none of the fields in the fixed part of the message have Vendor Private extensions, inclusion of this TLV is OPTIONAL. Vendor Private ranges for Message Types, Reply Modes, and Return Codes have been defined. When any of these are used, the Vendor Enterprise Number TLV MUST be included in the message.",
      "ja": "\"民間企業番号\" [IANA-ENT]はIANAによって維持されています。このTLVの長さは常に4です。値は、このTLVが存在しなければならない場合には、メッセージの固定部分のフィールドのいずれかにベンダープライベート拡張を持つベンダーのネットワークオクテット順に管理情報（SMI）プライベート企業コードの構造、です。メッセージの固定部分のフィールドのいずれもベンダー専用の拡張機能を持っていない場合は、このTLVを含めることは任意です。メッセージタイプのベンダーのプライベート範囲、モードを返信し、リターンコードが定義されています。これらのいずれかが使用される場合、ベンダー企業の数TLVは、メッセージに含まれなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.7. Interface and Label Stack",
      "section_title": true,
      "ja": "3.7. インタフェースとラベルスタック"
    },
    {
      "indent": 3,
      "text": "The Interface and Label Stack TLV MAY be included in a reply message to report the interface on which the request message was received and the label stack that was on the packet when it was received. Only one such object may appear. The purpose of the object is to allow the upstream router to obtain the exact interface and label stack information as it appears at the replying LSR.",
      "ja": "インターフェイスおよびラベルスタックTLVは、要求メッセージを受信したインターフェイスと、それを受信した際のパケットにあったラベルスタックを報告する応答メッセージに含まれるかもしれません。唯一のそのようなオブジェクトが表示されることがあります。オブジェクトの目的は、それが返信するのLSRで表示される上流のルータが正確なインターフェースとラベルスタック情報を取得できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The Length is K + 4*N octets; N is the number of labels in the label stack. Values for K are found in the description of Address Type below. The Value field of this TLV has the following format:",
      "ja": "長さK + 4 * Nオクテットです。 Nは、ラベルスタックのラベルの数です。 Kの値は、以下のアドレスタイプの記述に記載されています。このTLVの値フィールドの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Address Type  |             Must Be Zero                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IP Address (4 or 16 octets)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Interface (4 or 16 octets)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                          Label Stack                          .\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the IP Address and Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "インターフェースは、番号または番号なしの場合はアドレスタイプを示します。また、IPアドレスとインターフェイスフィールドの長さを決定します。 TLVの最初の部分のために得られた合計「Kオクテット」として以下の表に記載されています。アドレスタイプは、次のいずれかの値に設定されています："
    },
    {
      "indent": 8,
      "text": " Type #        Address Type           K Octets\n ------        ------------           --------\n      0        Reserved                      4\n      1        IPv4 Numbered                12\n      2        IPv4 Unnumbered              12\n      3        IPv6 Numbered                36\n      4        IPv6 Unnumbered              24\n  5-250        Unassigned\n251-254        Reserved for Experimental Use\n    255        Reserved",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IP Address and Interface",
      "ja": "IPアドレスとインターフェイス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスが4つのオクテットで符号化されます。 IPv6アドレスは16個のオクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface upon which the echo request message was received is numbered, then the Address Type MUST be set to IPv4 or IPv6, the IP Address MUST be set to either the LSR's Router ID or the interface address, and the Interface MUST be set to the interface address.",
      "ja": "エコー要求メッセージを受信した時にインターフェースが番号付けされた場合、アドレスタイプがIPv4またはIPv6に設定しなければなりません、IPアドレスは、LSRのルータIDまたはインターフェイスアドレスのいずれかに設定しなければなりません、そしてインタフェースに設定しなければなりませんインターフェイスアドレス。"
    },
    {
      "indent": 6,
      "text": "If the interface is unnumbered, the Address Type MUST be either IPv4 Unnumbered or IPv6 Unnumbered, the IP Address MUST be the LSR's Router ID, and the Interface MUST be set to the index assigned to the interface.",
      "ja": "インターフェースに番号が付いていない場合、アドレスタイプは、IPv4またはIPv6アンナンバード番号なしのいずれかでなければならない、IPアドレスはLSRのルータIDでなければならない、とのインターフェイスは、インターフェイスに割り当てられたインデックスに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Label Stack",
      "ja": "ラベルスタック"
    },
    {
      "indent": 6,
      "text": "The label stack of the received echo request message. If any TTL values have been changed by this router, they SHOULD be restored.",
      "ja": "受信されたエコー要求メッセージのラベルスタック。任意のTTL値はこのルータによって変更された場合は、それらを復元する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.8. Errored TLVs",
      "section_title": true,
      "ja": "3.8. エラー状態のTLV"
    },
    {
      "indent": 3,
      "text": "The following TLV is a TLV that MAY be included in an echo reply to inform the sender of an echo request of mandatory TLVs either not supported by an implementation or parsed and found to be in error.",
      "ja": "次のTLVは必須のTLV実装によってサポートまたは解析され、エラーであることが見出されていないいずれかのエコー要求の送信者に通知するために、エコー応答に含まれてもよいことTLVです。"
    },
    {
      "indent": 3,
      "text": "The Value field contains the TLVs that were not understood, encoded as sub-TLVs.",
      "ja": "Valueフィールドは、理解サブのTLVとして符号化されなかったTLVを含んでいます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type = 9          |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.9. Reply TOS Octet TLV",
      "section_title": true,
      "ja": "3.9.  TOSオクテットTLV返信"
    },
    {
      "indent": 3,
      "text": "This TLV MAY be used by the originator of the echo request to request that an echo reply be sent with the IP header Type of Service (TOS) octet set to the value specified in the TLV. This TLV has a length of 4 with the following Value field.",
      "ja": "このTLVは、エコー応答がTLVで指定された値に設定されたサービス（TOS）オクテットのIPヘッダタイプで送信することを要求するエコー要求の発信者によって使用されてもよいです。このTLVは、次の値フィールドと4の長さを有しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reply-TOS Byte|                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Theory of Operation",
      "section_title": true,
      "ja": "操作の4論"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is used to test a particular LSP. The LSP to be tested is identified by the \"FEC Stack\"; for example, if the LSP was set up via LDP, and a label is mapped to an egress IP address of 198.51.100.1, the FEC Stack contains a single element, namely, an LDP IPv4 prefix sub-TLV with value 198.51.100.1/32. If the LSP being tested is an RSVP LSP, the FEC Stack consists of a single element that captures the RSVP Session and Sender Template that uniquely identifies the LSP.",
      "ja": "MPLSエコー要求は、特定のLSPをテストするために使用されます。 LSPは、「FECスタック」によって識別されるテストされます。 LSPは、LDPを介して設定し、ラベルが198.51.100.1の出口IPアドレスにマップされている場合、例えば、FECスタックの値を持つ単一の要素、即ち、LDP IPv4プレフィクスのサブTLVが含ま198.51.100.1/ 32。試験されるLSPは、RSVPのLSPである場合、FECスタック一意LSPを識別RSVPセッションおよび送信者テンプレートをキャプチャ単一の要素から構成されています。"
    },
    {
      "indent": 3,
      "text": "FEC Stacks can be more complex. For example, one may wish to test a VPN IPv4 prefix of 203.0.113.0/24 that is tunneled over an LDP LSP with egress 192.0.2.1. The FEC Stack would then contain two sub-TLVs, the bottom being a VPN IPv4 prefix, and the top being an LDP IPv4 prefix. If the underlying (LDP) tunnel were not known, or was considered irrelevant, the FEC Stack could be a single element with just the VPN IPv4 sub-TLV.",
      "ja": "FECスタックは、より複雑になることがあります。例えば、一方が出口192.0.2.1とLDP LSP上をトンネルされる203.0.113.0/24のVPN IPv4プレフィクスをテストすることを望むかもしれません。 FECスタックは、2つのサブTLVを、VPN IPv4プレフィクスである底部、およびLDP IPv4のプレフィックスである上面を含むであろう。基礎となる（LDP）トンネルが知られていなかった、または無関係と考えられた場合、FECスタックだけVPNのIPv4サブTLVを持つ単一の要素であってもよいです。"
    },
    {
      "indent": 3,
      "text": "When an MPLS echo request is received, the receiver is expected to verify that the control plane and data plane are both healthy (for the FEC Stack being pinged), and that the two planes are in sync. The procedures for this are in Section 4.4.",
      "ja": "MPLSエコー要求を受信した場合、受信機は、制御プレーンとデータプレーンは（FECスタックはpingされているため）、健康、および2つの平面が同期していることの両方であることを確認することが期待されます。このための手順は、セクション4.4です。"
    },
    {
      "indent": 0,
      "text": "4.1. Dealing with Equal-Cost Multipath (ECMP)",
      "section_title": true,
      "ja": "4.1. 等価コストマルチパス（ECMP）への対応"
    },
    {
      "indent": 3,
      "text": "LSPs need not be simple point-to-point tunnels. Frequently, a single LSP may originate at several ingresses and terminate at several egresses; this is very common with LDP LSPs. LSPs for a given FEC may also have multiple \"next hops\" at transit LSRs. At an ingress, there may also be several different LSPs to choose from to get to the desired endpoint. Finally, LSPs may have backup paths, detour paths, and other alternative paths to take should the primary LSP go down.",
      "ja": "LSPは、単純なポイントツーポイントトンネルである必要はありません。しばしば、単一のLSPは、いくつかのingressesで始まり、いくつかのegressesで終端してもよいです。これは自民党のLSPと非常に一般的です。与えられたFECのためのLSPはまた、トランジットのLSRに複数の「次のホップ」を有していてもよいです。入口で、また、所望の終点に到達するために中から選択するために、いくつかの異なったLSPがあるかもしれません。最後に、LSPは主LSPがダウンした取るために、バックアップパス、迂回パス、およびその他の代替経路を有することができます。"
    },
    {
      "indent": 3,
      "text": "Regarding the last two points stated above: it is assumed that the LSR sourcing MPLS echo requests can force the echo request into any desired LSP, so choosing among multiple LSPs at the ingress is not an issue. The problem of probing the various flavors of backup paths that will typically not be used for forwarding data unless the primary LSP is down will not be addressed here.",
      "ja": "最後の2つの点が前述について：LSRソーシングMPLSエコー要求は、任意の所望のLSPにエコー要求を強制することができることが想定されるので、入力における複数のLSPの中から選択することは問題ではありません。主LSPがダウンしている場合を除き、通常の転送データのために使用されることはありませんバックアップパスのさまざまな味をプロービングの問題はここで扱われることはありません。"
    },
    {
      "indent": 3,
      "text": "Since the actual LSP and path that a given packet may take may not be known a priori, it is useful if MPLS echo requests can exercise all possible paths. This, although desirable, may not be practical because the algorithms that a given LSR uses to distribute packets over alternative paths may be proprietary.",
      "ja": "与えられたパケットがかかる場合があり、実際のLSPとパスが事前に知られないかもしれないので、MPLSエコー要求は、すべての可能なパスを行使することができれば、それは便利です。与えられたLSRは、代替パス上でパケットを配信するために使用するアルゴリズムはプロプライエタリであってもよいので、これは、望ましいが、実用的ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "To achieve some degree of coverage of alternate paths, there is a certain latitude in choosing the destination IP address and source UDP port for an MPLS echo request. This is clearly not sufficient; in the case of traceroute, more latitude is offered by means of the Multipath Information of the Downstream Detailed Mapping TLV. This is used as follows. An ingress LSR periodically sends an LSP traceroute message to determine whether there are multipaths for a given LSP. If so, each hop will provide some information as to how each of its downstream paths can be exercised. The ingress can then send MPLS echo requests that exercise these paths. If several transit LSRs have ECMP, the ingress may attempt to compose these to exercise all possible paths. However, full coverage may not be possible.",
      "ja": "代替パスのカバレッジをある程度達成するために、MPLSエコー要求の宛先IPアドレスとソースUDPポートを選択することで、特定の緯度があります。これは明らかに十分ではありません。トレースルートの場合には、より多くの緯度は、下流の詳細マッピングTLVのマルチパス情報を用いて提供されます。これは次のように使用されています。入口LSRは、定期的に与えられたLSPのためにマルチパスが存在するかどうかを判定するためにLSPのトレースルート・メッセージを送信します。その場合、各ホップは、その下流経路の各々を行使することができる方法として、いくつかの情報を提供します。イングレスは、これらのパスを行使MPLSエコー要求を送信することができます。いくつかのトランジットのLSRは、ECMPを持っている場合は、侵入が可能なすべてのパスを行使するためにこれらを構成しようとすることができます。しかし、完全にカバーできない場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Testing LSPs That Are Used to Carry MPLS Payloads",
      "section_title": true,
      "ja": "4.2.  MPLSペイロードを運ぶために使用されているLSPをテスト"
    },
    {
      "indent": 3,
      "text": "To detect certain LSP breakages, it may be necessary to encapsulate an MPLS echo request packet with at least one additional label when testing LSPs that are used to carry MPLS payloads (such as LSPs used to carry L2VPN and L3VPN traffic. For example, when testing LDP or RSVP-TE LSPs, just sending an MPLS echo request packet may not detect instances where the router immediately upstream of the destination of the LSP ping may forward the MPLS echo request successfully over an interface not configured to carry MPLS payloads because of the use of penultimate hop popping. Since the receiving router has no means to ascertain whether the IP packet was sent unlabeled or implicitly labeled, the addition of labels shimmed above the MPLS echo request (using the Nil FEC) will prevent a router from forwarding such a packet out to unlabeled interfaces.",
      "ja": "特定のLSPの破損を検出するために、そのようなL2VPNとL3VPNトラフィックを運ぶために使用されるのLSPとしてMPLSペイロードを（運ぶために使用されるLSPをテストするときに少なくとも一つの追加のラベルとMPLSエコー要求パケットをカプセル化する必要があるかもしれない。例えば、試験LDPまたはRSVP-TE LSPを、直ちにLSPピングの先のアップストリームルータが原因使用のMPLSペイロードを運ぶように構成されていないインタフェースを介して正常にMPLSにエコー要求を転送することができる場合だけでMPLSエコー要求パケットを送信するインスタンスを検出しないかもしれませんポッピング最後から二番目のホップの受信ルータは、IPパケットが標識されていない送信または暗黙的に標識されたかどうかを確認する手段を持たないので、（NIL FECを使用して）MPLSエコー要求上方シム標識の添加は、このようなパケットを転送からルータを防止します標識されていないインターフェイスにアウト。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending an MPLS Echo Request",
      "section_title": true,
      "ja": "4.3.  MPLSエコー要求を送信します"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is a UDP packet. The IP header is set as follows: the source IP address is a routable address of the sender; the destination IP address is a (randomly chosen) IPv4 address from the range 127/8 or an IPv6 address from the range 0:0:0:0:0:FFFF:7F00:0/104. The IP TTL is set to 1. The source UDP port is chosen by the sender; the destination UDP port is set to 3503 (assigned by IANA for MPLS echo requests). The Router Alert IP Option of value 0x0 [RFC2113] for IPv4 or value 69 [RFC7506] for IPv6 MUST be set in the IP header.",
      "ja": "MPLSエコー要求は、UDPパケットです。次のようにIPヘッダが設定されている：送信元IPアドレスは、送信者のルーティング可能なアドレスです。 0：0：0：0：FFFF：7F00：0/104宛先IPアドレスは、範囲8分の127又は範囲0からIPv6アドレスからの（ランダムに選択される）のIPv4アドレスです。 IP TTLは、ソースUDPポートが送信者によって選択された1に設定されています。先UDPポートは（MPLSエコー要求のためにIANAによって割り当てられた）3503に設定されています。 IPv6のIPv4または値69の値が0x0に[RFC2113]、[RFC7506]のルータ警告IPオプションは、IPヘッダに設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is sent with a label stack corresponding to the FEC Stack being tested. Note that further labels could be applied if, for example, the normal route to the topmost FEC in the stack is via a Traffic Engineered Tunnel [RFC3209]. If all of the FECs in the stack correspond to Implicit Null labels, the MPLS echo request is considered unlabeled even if further labels will be applied in sending the packet.",
      "ja": "MPLSエコー要求は、FECスタックに対応するラベルスタックがテストされて送信されます。例えば、スタックの一番上のFECに対して垂直経路がトラヒックエンジニアリングトンネル[RFC3209]を介して行われる、場合さらに、ラベルが適用され得ることに留意されたいです。スタック内のFECのすべてが暗黙的ヌルラベルに対応する場合、MPLSエコー要求は、さらに、ラベルはパケットの送信に適用される場合であっても非標識であると考えられます。"
    },
    {
      "indent": 3,
      "text": "If the echo request is labeled, one MAY (depending on what is being pinged) set the TTL of the innermost label to 1, to prevent the ping request going farther than it should. Examples of where this SHOULD be done include pinging a VPN IPv4 or IPv6 prefix, an L2 VPN endpoint, or a pseudowire. Preventing the ping request from going too far can also be accomplished by inserting a Router Alert label above this label; however, this may lead to the undesired side effect that MPLS echo requests take a different data path than actual data. For more information on how these mechanisms can be used for pseudowire connectivity verification, see [RFC5085][RFC5885].",
      "ja": "エコー要求が標識されている場合は、（pingを実行されているものに応じて）1 MAYは遠く、それが必要以上に行くping要求を防ぐために、1に最も内側のラベルのTTLを設定します。これが行われるべき場所の例は、VPN IPv4またはIPv6プレフィックス、L2 VPNエンドポイント、または疑似回線をping含みます。あまりにも遠くも、このラベル上のルータ警告ラベルを挿入することによって達成することができるだろうからping要求を防止すること;しかしながら、これは、エコー要求が実際のデータとは異なるデータパスを取るMPLS望ましくない副作用をもたらし得ます。これらのメカニズムは、疑似回線接続性検証のために使用することができる方法の詳細については、[RFC5085]、[RFC5885]を参照。"
    },
    {
      "indent": 3,
      "text": "In \"ping\" mode (end-to-end connectivity check), the TTL in the outermost label is set to 255. In \"traceroute\" mode (fault isolation mode), the TTL is set successively to 1, 2, and so on.",
      "ja": "「ピング」モード（エンドツーエンド接続性チェック）において、最も外側のラベルにTTLを「トレースルート」モード（障害分離モード）、TTLのように2,1に順次設定され、255に設定されています。"
    },
    {
      "indent": 3,
      "text": "The sender chooses a Sender's Handle and a Sequence Number. When sending subsequent MPLS echo requests, the sender SHOULD increment the Sequence Number by 1. However, a sender MAY choose to send a group of echo requests with the same Sequence Number to improve the chance of arrival of at least one packet with that Sequence Number.",
      "ja": "送信者は送信者のハンドルとシーケンス番号を選択します。エコー要求を、後続のMPLSを送信すると、送信者は、しかし、送信者がそのシーケンス番号を持つ少なくとも1つのパケットの到着のチャンスを改善するために、同じシーケンス番号をエコー要求のグループを送るのを選ぶかもしれ1.でシーケンス番号をインクリメントすべきです。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is set to the time of day in NTP format that the echo request is sent. The TimeStamp Received is set to zero.",
      "ja": "送信されたタイムスタンプはエコー要求が送信されるNTP形式で、一日の時間に設定されています。受信したタイムスタンプはゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have a FEC Stack TLV. Also, the Reply Mode must be set to the desired Reply Mode; the Return Code and Subcode are set to zero. In the \"traceroute\" mode, the echo request SHOULD include a Downstream Detailed Mapping TLV.",
      "ja": "MPLSエコー要求は、FECスタックTLVを持たなければなりません。また、応答モードは、所望の応答モードに設定されなければなりません。戻りコードとサブコードはゼロに設定されています。 「トレースルート」モードでは、エコー要求は、ダウンストリームの詳細なマッピングTLVを含むべきです。"
    },
    {
      "indent": 0,
      "text": "4.4. Receiving an MPLS Echo Request",
      "section_title": true,
      "ja": "4.4.  MPLSエコー要求を受信します"
    },
    {
      "indent": 3,
      "text": "Sending an MPLS echo request to the control plane is triggered by one of the following packet processing exceptions: Router Alert option, IP TTL expiration, MPLS TTL expiration, MPLS Router Alert label, or the destination address in the 127/8 address range. The control plane further identifies it by UDP destination port 3503.",
      "ja": "ルータ警告オプション、IP TTLの期限切れ、MPLS TTLの期限切れ、MPLSルータ警告ラベル、または8分の127のアドレス範囲の宛先アドレス：コントロールプレーンにMPLSエコー要求を送信することは、次のパケット処理例外のいずれかによってトリガされます。制御プレーンはさらに、UDP宛先ポート3503によってそれを識別する。"
    },
    {
      "indent": 3,
      "text": "For reporting purposes, the bottom of the stack is considered to be a stack-depth of 1. This is to establish an absolute reference for the case where the actual stack may have more labels than there are FECs in the Target FEC Stack.",
      "ja": "目的を報告するため、スタックの底部は、これは、実際のスタックがターゲットFECスタック内のFECがあるより多くのラベルを有していてもよい場合の絶対的な基準を確立することである1のスタック深さであると考えられます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in all the Return Codes listed in this document, a stack-depth of 0 means \"no value specified\". This allows compatibility with existing implementations that do not use the Return Subcode field.",
      "ja": "さらに、この文書に記載されているすべてのリターンコードでは、0のスタックの深さは、「指定された値なし」を意味しません。これは、リターンサブコードフィールドを使用していない既存の実装との互換性を可能にします。"
    },
    {
      "indent": 3,
      "text": "An LSR X that receives an MPLS echo request then processes it as follows.",
      "ja": "その後、MPLSエコー要求を受信し、次のようにそれを処理LSRのX。"
    },
    {
      "indent": 3,
      "text": "1. General packet sanity is verified. If the packet is not well-formed, LSR X SHOULD send an MPLS echo reply with the Return Code set to \"Malformed echo request received\" and the Subcode set to zero. If there are any TLVs not marked as \"Ignore\" (i.e., if the TLV type is less than 32768, see Section 3) that LSR X does not understand, LSR X SHOULD send an MPLS \"TLV not understood\" (as appropriate), and set the Subcode to zero. In the latter case, the misunderstood TLVs (only) are included as sub-TLVs in an Errored TLVs TLV in the reply. The header field's Sender's Handle, Sequence Number, and Timestamp Sent are not examined but are included in the MPLS echo reply message.",
      "ja": "1.一般的なパケット正気が検証されます。パケットがうまく形成されていない場合は、LSR Xは、MPLSエコーリターンコードは「不正な形式のエコー要求を受信」に設定し、サブコードをゼロに設定して返信送るべきです。どんなのTLVがある場合LSR Xは理解していないこと（TLVタイプが32768未満の場合、第3節を参照してください、すなわち）「無視」としてマークされていない、LSR Xは、（適切に）「理解されないTLV」MPLSを送るべきで、そしてゼロにサブコードを設定します。後者の場合には、誤解のTLV（のみ）が応答でエラー状態TLVのTLVサブのTLVとして含まれます。送信されたヘッダフィールドの送信者のハンドル、シーケンス番号、タイムスタンプが検査されないが、MPLSエコー応答メッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "The algorithm uses the following variables and identifiers:",
      "ja": "このアルゴリズムは、以下の変数および識別子を使用しています。"
    },
    {
      "indent": 3,
      "text": "Interface-I: the interface on which the MPLS echo request was received.",
      "ja": "インタフェース-I：MPLSエコー要求を受信したインタフェース。"
    },
    {
      "indent": 3,
      "text": "Stack-R: the label stack on the packet as it was received.",
      "ja": "スタック-R：それは受信されたように、パケットにラベルスタック。"
    },
    {
      "indent": 3,
      "text": "Stack-D: the label stack carried in the \"Label stack sub-TLV\" in the Downstream Detailed Mapping TLV (not always present).",
      "ja": "スタック-D：川下詳細なマッピング（常に存在していない）TLVに「ラベルスタックサブTLV」で運ばれたラベルスタック。"
    },
    {
      "indent": 3,
      "text": "Label-L: the label from the actual stack currently being examined. Requires no initialization.",
      "ja": "ラベルL：実際のスタックからラベルが現在検討されています。何の初期化を必要としません。"
    },
    {
      "indent": 3,
      "text": "Label-stack-depth: the depth of the label being verified. Initialized to the number of labels in the received label stack S.",
      "ja": "ラベルスタックの深さ：ラベルの深さが確認されています。受信したラベルスタックS.のラベルの数に初期化"
    },
    {
      "indent": 3,
      "text": "FEC-stack-depth: depth of the FEC in the Target FEC Stack that should be used to verify the current actual label. Requires no initialization.",
      "ja": "FEC-スタックの深さ：現在の実際のラベルを確認するために使用されるべきターゲットFECスタックにおけるFECの深さ。何の初期化を必要としません。"
    },
    {
      "indent": 3,
      "text": "Best-return-code: contains the Return Code for the echo reply packet as currently best known. As the algorithm progresses, this code may change depending on the results of further checks that it performs.",
      "ja": "ベスト・リターン・コードは：として現在最もよく知られたエコー応答パケットのためのリターンコードが含まれています。アルゴリズムが進行するにつれて、このコードは、実行さらにチェックの結果に応じて変化してもよいです。"
    },
    {
      "indent": 3,
      "text": "Best-rtn-subcode: similar to Best-return-code, but for the echo reply Subcode.",
      "ja": "ベスト-rtnをサブコード：ベスト・リターン・コードに似ていますが、エコー応答サブコードのために。"
    },
    {
      "indent": 3,
      "text": "FEC-status: result value returned by the FEC Checking algorithm described in Section 4.4.1.",
      "ja": "FECステータス：セクション4.4.1で説明したFECチェックアルゴリズムによって返された結果の値。"
    },
    {
      "indent": 3,
      "text": "/* Save receive context information */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. If the echo request is good, LSR X stores the interface over which the echo was received in Interface-I, and the label stack with which it came in Stack-R.",
      "ja": "2.エコー要求が良好であれば、LSR Xは、それがスタック-Rに来たとエコーがインターフェイス-Iで受信された上でインターフェイス、およびラベルスタックを格納します。"
    },
    {
      "indent": 3,
      "text": "/* The rest of the algorithm iterates over the labels in Stack-R,\nverifies validity of label values, reports associated label switching\noperations (for traceroute), verifies correspondence between the\nStack-R and the Target FEC Stack description in the body of the echo\nrequest, and reports any errors. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* The algorithm iterates as follows. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Label Validation:",
      "section_title": true,
      "ja": "3.ラベルの検証："
    },
    {
      "indent": 6,
      "text": "If Label-stack-depth is 0 {",
      "ja": "ラベルスタックの深さが0の場合{"
    },
    {
      "indent": 6,
      "text": "/* The LSR needs to report that it is a tail end for the LSP */",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Set FEC-stack-depth to 1, set Label-L to 3 (Implicit Null). Set Best-return-code to 3 (\"Replying router is an egress for the FEC at stack-depth\"), set Best-rtn-subcode to the value of FEC-stack-depth (1), and go to step 5 (Egress Processing).",
      "ja": "1にFECスタック深さを設定し、（暗黙NULL）3にラベルLを設定します。 （3への最良リターンコードを設定する（「ルータを返信するスタック深さでのFECのための出口である」）、（1）FECスタック深さの値にベストrtnを、サブコードを設定し、ステップ5に進み出力処理）。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "/* This step assumes there is always an entry for well-known label\nvalues */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Set Label-L to the value extracted from Stack-R at depth Label-stack-depth. Look up Label-L in the Incoming Label Map (ILM) to determine if the label has been allocated and an operation is associated with it.",
      "ja": "深さのラベルスタックの深さにスタックRから抽出​​された値に設定するラベルL。ラベルが割り当てられていると操作は、それに関連付けられているかどうかを判断するために着信ラベルマップ（ILM）にラベルLを検索します。"
    },
    {
      "indent": 6,
      "text": "If there is no entry for Label-L {",
      "ja": "ラベル-L {のためのエントリが存在しない場合"
    },
    {
      "indent": 6,
      "text": "/* Indicates a temporary or permanent label synchronization\nproblem, and the LSR needs to report an error */",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Set Best-return-code to 11 (\"No label entry at stack-depth\") and Best-rtn-subcode to Label-stack-depth. Go to step 7 (Send Reply Packet).",
      "ja": "11に最高のリターンコードを設定します（「スタックの深さではありませんラベルエントリ」）と、スタックの深さを標識するのに最高のrtnをサブコード。 （応答パケットを送信します）7に進みます。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "Else {",
      "ja": "エルス{"
    },
    {
      "indent": 9,
      "text": "Retrieve the associated label operation from the corresponding Next Hop Label Forwarding Entry (NHLFE), and proceed to step 4 (Label Operation Check).",
      "ja": "対応するネクストホップラベル転送エントリ（NHLFE）から関連するラベル操作を取得し、4（ラベル動作確認を）に進みます。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "4. Label Operation Check",
      "section_title": true,
      "ja": "4.ラベルの動作確認"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Pop and Continue Processing\" {",
      "ja": "ラベル操作がある場合は、{「ポップと処理を継続」"
    },
    {
      "indent": 6,
      "text": "/* Includes Explicit Null and Router Alert label cases */",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Iterate to the next label by decrementing Label-stack-depth, and loop back to step 3 (Label Validation).",
      "ja": "3（ラベル検証）をステップバックラベルスタックの深さを減少することにより次のラベルを繰り返し、ループ。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Swap or Pop and Switch based on Popped Label\" {",
      "ja": "ラベル操作は{「ポップラベルに基づいて、スワップやポップとスイッチ」である場合"
    },
    {
      "indent": 9,
      "text": "Set Best-return-code to 8 (\"Label switched at stack-depth\") and Best-rtn-subcode to Label-stack-depth to report transit switching.",
      "ja": "8に最高のリターンコードを設定し、ラベルスタックの深さをするトランジット切り替えを報告するベスト-rtnをサブコード（「ラベルスタック深さで切り換え」）。"
    },
    {
      "indent": 9,
      "text": "If a Downstream Detailed Mapping TLV is present in the received echo request {",
      "ja": "下流詳細マッピングTLVは、受信されたエコー要求中に存在する場合{"
    },
    {
      "indent": 12,
      "text": "If the IP address in the TLV is 127.0.0.1 or 0::1 {",
      "ja": "TLVでのIPアドレスは127.0.0.1または0 :: 1 {の場合"
    },
    {
      "indent": 15,
      "text": "Set Best-return-code to 6 (\"Upstream Interface Index Unknown\"). An Interface and Label Stack TLV SHOULD be included in the reply and filled with Interface-I and Stack-R.",
      "ja": "6（「アップストリームインターフェイスインデックス不明」）に最高のリターンコードを設定します。インターフェイスおよびラベルスタックTLVは、回答に含まれており、インターフェイス-Iおよびスタック-Rで満たされるべきです。"
    },
    {
      "indent": 12,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 12,
      "text": "Else {",
      "ja": "エルス{"
    },
    {
      "indent": 15,
      "text": "Verify that the IP address, interface address, and label stack in the Downstream Detailed Mapping TLV match Interface-I and Stack-R. If there is a mismatch, set Best-return-code to 5, \"Downstream Mapping Mismatch\". An Interface and Label Stack TLV SHOULD be included in the reply and filled in based on Interface-I and Stack-R. Go to step 7 (Send Reply Packet).",
      "ja": "川下詳細なマッピングTLVマッチインタフェース-Iおよびスタック-RでのIPアドレス、インターフェイスアドレス、およびラベルスタックいることを確認します。不一致がある場合は、5に最高のリターンコードを設定し、「川下のマッピングの不一致」。インターフェイスおよびラベルスタックTLVは、回答に含まれており、インターフェイス-Iおよびスタック-Rに基づいて記入されるべきである（SHOULD）。 （応答パケットを送信します）7に進みます。"
    },
    {
      "indent": 12,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 9,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 9,
      "text": "For each available downstream ECMP path {",
      "ja": "各利用可能な下流ECMPパスの{"
    },
    {
      "indent": 12,
      "text": "Retrieve output interface from the NHLFE entry.",
      "ja": "NHLFEエントリーから出力インタフェースを取得します。"
    },
    {
      "indent": 12,
      "text": "/* Note: this Return Code is set even if Label-stack-depth\nis one */",
      "raw": true
    },
    {
      "indent": 12,
      "text": "If the output interface is not MPLS enabled {",
      "ja": "出力インタフェースは、イネーブルMPLSされていない場合は{"
    },
    {
      "indent": 15,
      "text": "Set Best-return-code to Return Code 9, \"Label switched but no MPLS forwarding at stack-depth\" and set Best-rtn-subcode to Label-stack-depth and go to step 7 (Send Reply Packet).",
      "ja": "コード9を返すために最高のリターンコードを設定し、（応答パケットを送信）「ラベルが切り替わりませんが、スタックの深さで何のMPLSフォワーディング」と-スタックの深さをラベル付けし、ステップ7に行くためにベスト-rtnを-サブコードを設定します。"
    },
    {
      "indent": 12,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 12,
      "text": "If a Downstream Detailed Mapping TLV is present {",
      "ja": "下流詳細マッピングTLVは{存在する場合"
    },
    {
      "indent": 15,
      "text": "A Downstream Detailed Mapping TLV SHOULD be included in the echo reply (see Section 3.4) filled in with information about the current ECMP path.",
      "ja": "TLVは、エコー応答（セクション3.4を参照）に含まれるべきである下流詳細なマッピングは、現在のECMPパスに関する情報で埋め。"
    },
    {
      "indent": 12,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 9,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 9,
      "text": "If no Downstream Detailed Mapping TLV is present, or the Downstream IP Address is set to the ALLROUTERS multicast address, go to step 7 (Send Reply Packet).",
      "ja": "何の川下詳細なマッピングTLVが存在しない、またはダウンストリームIPアドレスがALLROUTERSマルチキャストアドレスに設定されている場合、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 9,
      "text": "If the \"Validate FEC Stack\" flag is not set and the LSR is not configured to perform FEC checking by default, go to step 7 (Send Reply Packet).",
      "ja": "「検証FECスタック」フラグが設定されていないとLSRはデフォルトでFECチェックを実行するように構成されていない場合は、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 9,
      "text": "/* Validate the Target FEC Stack in the received echo request.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "First determine FEC-stack-depth from the Downstream Detailed Mapping TLV. This is done by walking through Stack-D (the Downstream labels) from the bottom, decrementing the number of labels for each non-Implicit Null label, while incrementing FEC-stack-depth for each label. If the Downstream Detailed Mapping TLV contains one or more Implicit Null labels, FEC-stack-depth may be greater than Label-stack-depth. To be consistent with the above stack-depths, the bottom is considered to be entry 1. */",
      "ja": "第一下流詳細マッピングTLVからFECスタック深さを決定します。これは、各ラベルにFECスタック深さをインクリメントしながら、下からスタック-D（下流ラベル）を歩いて、各非暗黙的ヌルラベルのラベルの数を減少することによって行われます。川下詳細なマッピングTLVは、1つまたは複数の暗黙的ヌルラベルが含まれている場合は、FEC-スタックの深さは、ラベルスタックの深さよりも大きくすることができます。上記スタック深さと一致するように、底部がエントリであると考えられている1 * /"
    },
    {
      "indent": 9,
      "text": "Set FEC-stack-depth to 0. Set i to Label-stack-depth.",
      "ja": "私はラベルスタックの深さを0に設定するFEC-スタックの深さを設定します。"
    },
    {
      "indent": 9,
      "text": "While (i > 0) do {",
      "ja": "（私は> 0）{んが"
    },
    {
      "indent": 9,
      "text": " ++FEC-stack-depth. if Stack-D [ FEC-stack-depth ] != 3 (Implicit Null) --i. }",
      "ja": "++ FEC-スタックの深さ。もしスタックD [FECスタック深]！= 3（暗黙NULL）--I。 }"
    },
    {
      "indent": 9,
      "text": "If the number of FECs in the FEC stack is greater than or equal to FEC-stack-depth { Perform the FEC Checking procedure (see Section 4.4.1).",
      "ja": "FECスタック内のFEC数がFECスタック深さ以上である場合、{FECチェック手順（セクション4.4.1を参照）を実行します。"
    },
    {
      "indent": 12,
      "text": "If FEC-status is 2, set Best-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\").",
      "ja": "FEC-ステータスは10から2、セットベスト・リターン・コードである場合（「このFECのためのマッピングは、スタックの深さで与えられたラベルではありません」）。"
    },
    {
      "indent": 9,
      "text": " If the Return Code is 1, set Best-return-code to FEC-return-code and Best-rtn-subcode to FEC-stack-depth. }",
      "ja": "戻りコードが1の場合、FEC-スタックの深さにFEC-リターン・コードおよびベスト・rtnをサブコードに最高のリターン・コードを設定します。 }"
    },
    {
      "indent": 6,
      "text": " Go to step 7 (Send Reply Packet). }",
      "ja": "（応答パケットを送信します）7に進みます。 }"
    },
    {
      "indent": 3,
      "text": "5. Egress Processing:",
      "section_title": true,
      "ja": "5.出口処理："
    },
    {
      "indent": 6,
      "text": "/* These steps are performed by the LSR that identified itself as\nthe tail-end LSR for an LSP. */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If the received echo request contains no Downstream Detailed Mapping TLV, or the Downstream IP Address is set to 127.0.0.1 or 0::1, go to step 6 (Egress FEC Validation).",
      "ja": "受信されたエコー要求は何の川下詳細なマッピングTLVが含まれていない、またはダウンストリームIPアドレスが127.0.0.1または0 :: 1に設定されている場合は、6（出口FECの検証を）に進みます。"
    },
    {
      "indent": 6,
      "text": "Verify that the IP address, interface address, and label stack in the Downstream Detailed Mapping TLV match Interface-I and Stack-R. If not, set Best-return-code to 5, \"Downstream Mapping Mismatch\". A Received Interface and Label Stack TLV SHOULD be created for the echo response packet. Go to step 7 (Send Reply Packet).",
      "ja": "川下詳細なマッピングTLVマッチインタフェース-Iおよびスタック-RでのIPアドレス、インターフェイスアドレス、およびラベルスタックいることを確認します。ない場合は、5に「川下のマッピングの不一致を」ベスト・リターン・コードを設定します。受信したインターフェイスとラベルスタックTLVは、エコー応答パケットのために作成する必要があります。 （応答パケットを送信します）7に進みます。"
    },
    {
      "indent": 3,
      "text": "6. Egress FEC Validation:",
      "section_title": true,
      "ja": "6.出口FEC検証："
    },
    {
      "indent": 6,
      "text": "/* This is a loop for all entries in the Target FEC Stack starting\nwith FEC-stack-depth. */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Perform FEC checking by following the algorithm described in Section 4.4.1 for Label-L and the FEC at FEC-stack-depth.",
      "ja": "FEC-スタックの深さでラベルLとFECについては、セクション4.4.1で説明したアルゴリズムに従って、FECチェックを実行します。"
    },
    {
      "indent": 6,
      "text": "Set Best-return-code to FEC-code and Best-rtn-subcode to the value in FEC-stack-depth.",
      "ja": "FEC-スタックの深さの値にFECコードとベスト・rtnをサブコードに最高のリターンコードを設定します。"
    },
    {
      "indent": 6,
      "text": "If FEC-status (the result of the check) is 1, go to step 7 (Send Reply Packet).",
      "ja": "FEC-状態（チェックの結果）が1である場合には、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 6,
      "text": "/* Iterate to the next FEC entry */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "++FEC-stack-depth. If FEC-stack-depth > the number of FECs in the FEC-stack, go to step 7 (Send Reply Packet).",
      "ja": "++ FEC-スタックの深さ。 FEC-スタックの深さ> FECスタック内のFECの数は、7ステップに進みます（応答パケットを送信します）。"
    },
    {
      "indent": 6,
      "text": "If FEC-status is 0 {",
      "ja": "FEC-状態である場合には0 {"
    },
    {
      "indent": 9,
      "text": "++Label-stack-depth. If Label-stack-depth > the number of labels in Stack-R, go to step 7 (Send Reply Packet).",
      "ja": "++ラベルスタックの深さ。ラベルスタックの深さ>スタック-Rのラベルの数は、7ステップに進みます（応答パケットを送信します）。"
    },
    {
      "indent": 6,
      "text": " Label-L = extracted label from Stack-R at depth Label-stack-depth. Loop back to step 6 (Egress FEC Validation). }",
      "ja": "ラベルL =深度ラベルスタック深さでスタックRから抽出​​されたラベル。ループバック6（出力FEC検証）を進みます。 }"
    },
    {
      "indent": 3,
      "text": "7. Send Reply Packet:",
      "section_title": true,
      "ja": "7.応答パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "Send an MPLS echo reply with a Return Code of Best-return-code and a Return Subcode of Best-rtn-subcode. Include any TLVs created during the above process. The procedures for sending the echo reply are found in Section 4.5.",
      "ja": "ベスト・リターン・コードの戻りコードとベスト・rtnをサブコードのリターンサブコードとMPLSエコー応答を送信します。上記のプロセス中に作成されたすべてのTLVを含めます。エコー応答を送信するための手順は、セクション4.5に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.4.1. FEC Validation",
      "section_title": true,
      "ja": "4.4.1.  FECの検証"
    },
    {
      "indent": 3,
      "text": "/* This section describes validation of a FEC entry within the Target\nFEC Stack and accepts a FEC, Label-L, and Interface-I.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the outermost FEC of the Target FEC stack is the Nil FEC, then the node MUST skip the Target FEC validation completely. This is to support FEC hiding, in which the outer hidden FEC can be the Nil FEC. Else, the algorithm performs the following steps. */",
      "ja": "ターゲットFECスタックの最FECがnil FECの場合、ノードは完全にターゲットFEC検証をスキップしなければなりません。これは、外側の隠されたFECがnil FECすることができるFEC隠しを、サポートすることです。そうでなければ、アルゴリズムは、次の手順を実行します。 * /"
    },
    {
      "indent": 3,
      "text": "1. Two return values, FEC-status and FEC-return-code, are initialized to 0.",
      "ja": "1. 2つの戻り値、FEC-状態とFEC-リターンコードは、0に初期化されています。"
    },
    {
      "indent": 3,
      "text": "2. If the FEC is the Nil FEC {",
      "section_title": true,
      "ja": "2. FECは、FEC無記号{場合"
    },
    {
      "indent": 10,
      "text": "If Label-L is either Explicit_Null or Router_Alert, return.",
      "ja": "ラベルLがExplicit_NullかRouter_Alertのいずれかである場合、戻ります。"
    },
    {
      "indent": 10,
      "text": "Else {",
      "ja": "エルス{"
    },
    {
      "indent": 10,
      "text": " Set FEC-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\"). Set FEC-status to 1 Return. }",
      "ja": "（「このFECのためのマッピングは、スタックの深さで与えられたラベルではありません」）10にFEC-リターンコードを設定します。 1つのリターンにFECステータスを設定します。 }"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "3. Check the FEC label mapping that describes how traffic received on the LSP is further switched or which application it is associated with. If no mapping exists, set FEC-return-code to Return 4, \"Replying router has no mapping for the FEC at stack-depth\". Set FEC-status to 1. Return.",
      "ja": "3.トラフィックがさらに切り替わっているか、どのアプリケーションが関連付けられているLSP上で受信方法について説明FECラベルマッピングを確認してください。マッピングが存在しない場合、4を返すために、FEC-リターンコードを設定し、「返信ルータは、スタックの深さでFECのためのマッピングを持っていません」。 1.リターンにFECステータスを設定します。"
    },
    {
      "indent": 3,
      "text": "4. If the label mapping for FEC is Implicit Null, set FEC-status to 2 and proceed to step 5. Otherwise, if the label mapping for FEC is Label-L, proceed to step 5. Otherwise, set FEC-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\"), set FEC-status to 1, and return.",
      "ja": "4. FECのラベルマッピングは、FECリターンコードセット、2 FECステータスを設定し、それ以外の場合はステップ5に進み、FECのラベルマッピングはラベルLであれば、そうでない場合はステップ5に進み、暗黙のNULLの場合10に、1に設定FECステータス、およびリターン（「このFECのためのマッピングは、所与のスタック深さのラベルではありません」）。"
    },
    {
      "indent": 3,
      "text": "5. This is a protocol check. Check what protocol would be used to advertise the FEC. If it can be determined that no protocol associated with Interface-I would have advertised a FEC of that FEC-Type, set FEC-return-code to 12 (\"Protocol not associated with interface at FEC stack-depth\"). Set FEC-status to 1.",
      "ja": "5.これは、プロトコルチェックです。 FECを宣伝するために使用されるもののプロトコルを確認してください。プロトコルが関連付けられていないと判断できる場合インターフェイス-Iは、そのFECタイプのFECをアドバタイズ（「FECスタック深さのインタフェースに関連付けられていないプロトコル」）12にFECリターンコードを設定しているであろう。 1にFECステータスを設定します。"
    },
    {
      "indent": 3,
      "text": "6. Return.",
      "section_title": true,
      "ja": "6.戻ります。"
    },
    {
      "indent": 0,
      "text": "4.5. Sending an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.5.  MPLSエコー応答を送信します"
    },
    {
      "indent": 3,
      "text": "An MPLS echo reply is a UDP packet. It MUST ONLY be sent in response to an MPLS echo request. The source IP address is a routable address of the replier; the source port is the well-known UDP port for LSP ping. The destination IP address and UDP port are copied from the source IP address and UDP port of the echo request. The IP TTL is set to 255. If the Reply Mode in the echo request is \"Reply via an IPv4 UDP packet with Router Alert\", then the IP header MUST contain the Router Alert IP Option of value 0x0 [RFC2113] for IPv4 or 69 [RFC7506] for IPv6. If the reply is sent over an LSP, the topmost label MUST in this case be the Router Alert label (1) (see [RFC3032]).",
      "ja": "MPLSエコー応答がUDPパケットです。それだけでMPLSエコー要求に応答して送らなければなりません。送信元IPアドレスはリプライヤのルーティング可能なアドレスです。送信元ポートは、LSPピングのためのよく知られたUDPポートです。宛先IPアドレスとUDPポートは、エコー要求の送信元IPアドレスとUDPポートからコピーされます。エコー要求に応答モードは、次にIPヘッダはIPv4または69のための値は0x0 [RFC2113]のルータ警告IPオプションを含まなければならない、「ルータアラートとのIPv4 UDPパケットを介して返信」である場合、IP TTLは255に設定されていますIPv6のための[RFC7506]。応答がLSPを介して送信された場合、この場合の最上位ラベルのMUSTは、ルータ警告ラベルである（1）（[RFC3032]を参照）。"
    },
    {
      "indent": 3,
      "text": "The format of the echo reply is the same as the echo request. The Sender's Handle, the Sequence Number, and TimeStamp Sent are copied from the echo request; the TimeStamp Received is set to the time of day that the echo request is received (note that this information is most useful if the time-of-day clocks on the requester and the replier are synchronized). The FEC Stack TLV from the echo request MAY be copied to the reply.",
      "ja": "エコー応答の形式は、エコー要求と同じです。エコー要求からコピーされて送信された送信者のハンドル、シーケンス番号、およびタイムスタンプ。受信したタイムスタンプはエコー要求を受信した時刻に設定されている（リクエスタとリプライヤ上の時刻クロックが同期している場合は、この情報が最も有用であることに注意してください）。エコー要求からFECスタックTLVは、返信にコピーされてもよいです。"
    },
    {
      "indent": 3,
      "text": "The replier MUST fill in the Return Code and Subcode, as determined in the previous section.",
      "ja": "前節で決定されたようリプライヤは、戻りコードおよびサブコードを入力する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Pad TLV, the replier MUST interpret the first octet for instructions regarding how to reply.",
      "ja": "エコー要求はパッドTLVが含まれている場合は、リプライヤは返信する方法に関する指示のための最初のオクテットを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the replying router is the destination of the FEC, then Downstream Detailed Mapping TLVs SHOULD NOT be included in the echo reply.",
      "ja": "返答ルータがFECの宛先がある場合には、川下の詳細なマッピングのTLVは、エコー応答に含まれるべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Downstream Detailed Mapping TLV, and the replying router is not the destination of the FEC, the replier SHOULD compute its downstream routers and corresponding labels for the incoming label and add Downstream Detailed Mapping TLVs for each one to the echo reply it sends back. A replying node should follow the procedures defined in Section 4.5.1 if there is a FEC stack change due to tunneled LSP. If the FEC stack change is due to stitched LSP, it should follow the procedures defined in Section 4.5.2.",
      "ja": "エコー要求が下流詳細マッピングTLVが含まれており、返答ルータがFECの宛先ではない場合、回答者は、着信ラベルにその下流のルータと対応するラベルを計算し、エコー応答にそれぞれのダウンストリームの詳細なマッピングTLVを追加すべきですそれが戻って送信します。トンネリングされたLSPのためにFECスタックの変更がある場合、応答ノードは、セクション4.5.1で定義された手順に従うべきです。 FECスタックの変更はステッチLSPが原因である場合、それはセクション4.5.2で定義されている手順に従ってください。"
    },
    {
      "indent": 3,
      "text": "If the Downstream Detailed Mapping TLV contains Multipath Information requiring more processing than the receiving router is willing to perform, the responding router MAY choose to respond with only a subset of multipaths contained in the echo request Downstream Detailed Mapping. (Note: The originator of the echo request MAY send another echo request with the Multipath Information that was not included in the reply.)",
      "ja": "川下詳細マッピングTLVが受信ルータが実行していく所存ですより多くの処理を必要とするマルチパスの情報が含まれている場合は、応答ルータはエコー要求川下詳細なマッピングに含まれるマルチパスのサブセットのみで応答することを選択するかもしれません。 （注意：エコー要求の発信元は、回答に含まれていなかったマルチパス情報を持つ別のエコー要求を送信することができます。）"
    },
    {
      "indent": 3,
      "text": "Except in the case of Reply Mode 4, \"Reply via application-level control channel\", echo replies are always sent in the context of the IP/MPLS network.",
      "ja": "応答モード4の場合を除いて、「アプリケーションレベルの制御チャネルを介して返信」、エコー応答は常に、IP / MPLSネットワークのコンテキストで送信されます。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Addition of a New Tunnel",
      "section_title": true,
      "ja": "4.5.1. 新しいトンネルの追加"
    },
    {
      "indent": 3,
      "text": "A transit node knows when the FEC being traced is going to enter a tunnel at that node. Thus, it knows about the new outer FEC. All transit nodes that are the origination point of a new tunnel SHOULD add the FEC stack change sub-TLV (Section 3.4.1.3) to the Downstream Detailed Mapping TLV in the echo reply. The transit node SHOULD add one FEC stack change sub-TLV of operation type PUSH, per new tunnel being originated at the transit node.",
      "ja": "トレースされているFECは、そのノードでトンネルを入力しようとしている時にトランジットノードが知っています。したがって、それは新しい外FECについて知っています。新しいトンネルの起点であるすべてのトランジットノードは、エコー応答下流詳細マッピングTLVにFECスタック切り替えサブTLV（セクション3.4.1.3）を追加する必要があります。トランジットノードは、トランジットノードで発信され、新しいトンネル単位操作型PUSHのFECスタック切り替えサブTLVを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "A transit node that sends a Downstream FEC stack change sub-TLV in the echo reply SHOULD fill the address of the remote peer, which is the peer of the current LSP being traced. If the transit node does not know the address of the remote peer, it MUST set the address type to Unspecified.",
      "ja": "エコー応答下流FECスタック切り替えサブTLVを送信する中継ノードは、トレースされている現在のLSPのピアであるリモートピアのアドレスを記入すべきです。トランジットノードは、リモートピアのアドレスを知らない場合には、未指定のアドレスタイプを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Label Stack sub-TLV MUST contain one additional label per FEC being PUSHed. The label MUST be encoded as defined in Section 3.4.1.2. The label value MUST be the value used to switch the data traffic. If the tunnel is a transparent pipe to the node, i.e., the data-plane trace will not expire in the middle of the new tunnel, then a FEC stack change sub-TLV SHOULD NOT be added, and the Label Stack sub-TLV SHOULD NOT contain a label corresponding to the hidden tunnel.",
      "ja": "ラベルスタックのサブTLVはFECが押されごとに1つの追加のラベルを含まなければなりません。セクション3.4.1.2で定義されたラベルは、符号化されなければなりません。ラベル値は、データトラフィックを切り替えるために使用される値でなければなりません。トンネルがノードに透明パイプである場合、すなわち、データプレーントレースは新しいトンネルの途中で期限切れになりません、そして、FECスタック切り替えサブTLVを追加しないでください、とラベルスタックサブTLV SHOULD隠されたトンネルに対応するラベルが含まれていません。"
    },
    {
      "indent": 3,
      "text": "If the transit node wishes to hide the nature of the tunnel from the ingress of the echo request, then it MAY not want to send details about the new tunnel FEC to the ingress. In such a case, the transit node SHOULD use the Nil FEC. The echo reply would then contain a FEC stack change sub-TLV with operation type PUSH and a Nil FEC. The value of the label in the Nil FEC MUST be set to zero. The remote peer address type MUST be set to Unspecified. The transit node SHOULD add one FEC stack change sub-TLV of operation type PUSH, per new tunnel being originated at the transit node. The Label Stack sub-TLV MUST contain one additional label per FEC being PUSHed. The label value MUST be the value used to switch the data traffic.",
      "ja": "トランジットノードは、エコー要求の進入からトンネルの本質を隠蔽しようとする場合、それは、入口に新しいトンネルFECについての詳細を送信したくない場合があります。このような場合、トランジットノードは、無記号FECを使用すべきです。エコー応答は、操作型PUSH及びナシFECとFECスタック変化サブTLVを含むであろう。無記号FEC内のラベルの値をゼロに設定しなければなりません。リモートピアのアドレス型が未指定に設定しなければなりません。トランジットノードは、トランジットノードで発信され、新しいトンネル単位操作型PUSHのFECスタック切り替えサブTLVを追加する必要があります。ラベルスタックのサブTLVはFECが押されごとに1つの追加のラベルを含まなければなりません。ラベル値は、データトラフィックを切り替えるために使用される値でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Transition between Tunnels",
      "section_title": true,
      "ja": "4.5.2. トンネルの間の遷移"
    },
    {
      "indent": 3,
      "text": "A transit node stitching two LSPs SHOULD include two FEC stack change sub-TLVs. One with a pop operation for the old FEC (ingress) and one with the PUSH operation for the new FEC (egress). The replying node SHOULD set the Return Code to \"Label switched with FEC change\" to indicate change in the FEC being traced.",
      "ja": "2つのLSPをステッチトランジットノードは、二つのFECスタック切り替えサブTLVを含むべきです。古いFEC（入力）のためのポップ操作でワンと新しいFEC（出口）のためのプッシュ操作で1。応答ノードは、トレースされているFECの変化を示すために、「ラベルがFEC変化に切り替え」に戻りコードを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the replying node wishes to perform FEC hiding, it SHOULD respond back with two FEC stack change sub-TLVs, one pop followed by one PUSH. The pop operation MAY either exclude the FEC TLV (by setting the FEC TLV length to 0) or set the FEC TLV to contain the LDP FEC. The PUSH operation SHOULD have the FEC TLV containing the Nil FEC. The Return Code SHOULD be set to \"Label switched with FEC change\".",
      "ja": "応答ノードはFECの隠蔽を実行したい場合、それは2 FECスタック切り替えサブTLVの、1つのPUSH続い1つのポップで戻って応答する必要があります。ポップ操作はどちらか（0にFEC TLVの長さを設定することにより）FEC TLVを除外するか、LDP FECを含むようにFEC TLVを設定することができます。 PUSH操作は無記号FECを含むFEC TLVを持つべきである（SHOULD）。リターンコードは、「ラベルがFEC変化に切り替える」に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the replying node wishes to perform FEC hiding, it MAY choose to not send any FEC stack change sub-TLVs in the echo reply if the number of labels does not change for the downstream node and the FEC type also does not change (Nil FEC). In such case, the replying node MUST NOT set the Return Code to \"Label switched with FEC change\".",
      "ja": "応答ノードはFECの隠蔽を実行したい場合は、ラベルの数は、下流ノードのために変更されません。また、FECタイプも変更されない場合（エコー応答で無記号FECを任意のFECスタック切り替えサブTLVを送信しないことを選択するかもしれません）。そのような場合には、応答ノードは、「ラベルはFEC変化に切り替え」に戻りコードを設定してはいけません。"
    },
    {
      "indent": 0,
      "text": "4.6. Receiving an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.6.  MPLSエコー応答を受け取ります"
    },
    {
      "indent": 3,
      "text": "An LSR X should only receive an MPLS echo reply in response to an MPLS echo request that it sent. Thus, on receipt of an MPLS echo reply, X should parse the packet to ensure that it is well-formed, then attempt to match up the echo reply with an echo request that it had previously sent, using the destination UDP port and the Sender's Handle. If no match is found, then X jettisons the echo reply; otherwise, it checks the Sequence Number to see if it matches.",
      "ja": "LSR Xは、それが送られたMPLSエコー要求に応じて、MPLSエコー応答を受け取る必要があります。このように、MPLSエコー応答の受信時に、Xは送信者の、それは以前に送られていたことをエコー要求とエコー応答を照合し、宛先UDPポートを使用して、その後、それはよく形成されることを保証するために、パケットを解析しなければなりません扱う。一致が見つからない場合には、Xは、エコー応答をjettisons。そうでない場合は、それが一致するかどうかを確認するためにシーケンス番号をチェックします。"
    },
    {
      "indent": 3,
      "text": "If the echo reply contains Downstream Detailed Mappings, and X wishes to traceroute further, it SHOULD copy the Downstream Detailed Mapping(s) into its next echo request(s) (with TTL incremented by one).",
      "ja": "エコー応答が下流詳細なマッピングを含み、Xはさらにトレースルートを望む場合、その次のエコー要求（単数または複数）（インクリメントTTL付き）に下流詳細マッピング（複数可）をコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "If one or more FEC stack change sub-TLVs are received in the MPLS echo reply, the ingress node SHOULD process them and perform some validation.",
      "ja": "一つ以上のFECスタック切り替えサブのTLVはMPLSエコー応答を受信した場合、入口ノードは、それらを処理し、いくつかの検証を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The FEC stack changes are associated with a downstream neighbor and along a particular path of the LSP. Consequently, the ingress will need to maintain a FEC stack per path being traced (in case of multipath). All changes to the FEC stack resulting from the processing of a FEC stack change sub-TLV(s) should be applied only for the path along a given downstream neighbor. The following algorithm should be followed for processing FEC stack change sub-TLVs.",
      "ja": "FECスタックの変更は、下流ネイバーとし、LSPの特定の経路に沿って関連付けられています。その結果、入口は、（マルチパスの場合）トレースされる経路ごとFECスタックを維持する必要があります。 FECスタック変化サブTLV（S）の処理に起因するFECスタックに対するすべての変更は、所定のダウンストリームネイバーに沿った経路に適用されるべきです。以下のアルゴリズムは、FECスタック切り替えサブTLVを処理するために従うべきです。"
    },
    {
      "indent": 7,
      "text": "push_seen = FALSE\nfec_stack_depth = current-depth-of-fec-stack-being-traced\nsaved_fec_stack = current_fec_stack",
      "raw": true
    },
    {
      "indent": 7,
      "text": "while (sub-tlv = get_next_sub_tlv(downstream_detailed_map_tlv))",
      "ja": "一方、（サブTLV = get_next_sub_tlv（downstream_detailed_map_tlv））"
    },
    {
      "indent": 11,
      "text": "if (sub-tlv == NULL) break",
      "ja": "もし（サブTLV == NULL）休憩"
    },
    {
      "indent": 11,
      "text": "if (sub-tlv.type == FEC-Stack-Change) {",
      "ja": "IF（サブtlv.type == FECスタック-変更）{"
    },
    {
      "indent": 15,
      "text": "if (sub-tlv.operation == POP) {\n    if (push_seen) {\n        Drop the echo reply\n        current_fec_stack = saved_fec_stack\n        return\n    }",
      "raw": true
    },
    {
      "indent": 19,
      "text": "if (fec_stack_depth == 0) {\n    Drop the echo reply\n    current_fec_stack = saved_fec_stack\n    return\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": " Pop FEC from FEC stack being traced fec_stack_depth--; }",
      "ja": "fec_stack_depth--トレースされているFECスタックからFECをポップ。 }"
    },
    {
      "indent": 8,
      "text": " if (sub-tlv.operation == PUSH) { push_seen = 1 Push FEC on FEC stack being traced fec_stack_depth++; } } }",
      "ja": "IF（サブtlv.operation == PUSH）{push_seen = 1 ++ fec_stack_depthをトレースされてFECスタックにFECを押します。 }}}"
    },
    {
      "indent": 8,
      "text": "if (fec_stack_depth == 0) { Drop the echo reply current_fec_stack = saved_fec_stack return }",
      "ja": "（fec_stack_depth == 0）{エコー応答current_fec_stack = saved_fec_stackリターンドロップ}場合"
    },
    {
      "indent": 3,
      "text": "The next MPLS echo request along the same path should use the modified FEC stack obtained after processing the FEC stack change sub-TLVs. A non-Nil FEC guarantees that the next echo request along the same path will have the Downstream Detailed Mapping TLV validated for IP address, interface address, and label stack mismatches.",
      "ja": "同じ経路に沿って次のMPLSエコー要求は、FECスタック切り替えサブTLVを処理した後に得られる変性FECスタックを使用する必要があります。非無記号FEC同じパスに沿って次のエコー要求は、IPアドレス、インターフェイスアドレス、およびラベルスタックの不一致を検証ダウンストリームの詳細なマッピングTLVをもつことが保証されます。"
    },
    {
      "indent": 3,
      "text": "If the top of the FEC stack is a Nil FEC and the MPLS echo reply does not contain any FEC stack change sub-TLVs, then it does not necessarily mean that the LSP has not started traversing a different tunnel. It could be that the LSP associated with the Nil FEC terminated at a transit node, and at the same time, a new LSP started at the same transit node. The Nil FEC would now be associated with the new LSP (and the ingress has no way of knowing this). Thus, it is not possible to build an accurate hierarchical LSP topology if a traceroute contains Nil FECs.",
      "ja": "FECスタックのトップがゼロFEC及びMPLS任意FECスタック切り替えサブTLVを含んでいないエコー応答である場合、それは必ずしもLSPが異なるトンネルを横断開始していないことを意味するものではありません。それは無記号FECに関連したLSPは、中継ノードで終端すると同時に、新しいLSPが同じトランジットノードで開始している可能性があります。無記号FECは、新しいLSPに関連するであろう（と進入はこれを知る方法はありません）。したがって、トレースルートがnilのFECが含まれている場合は、正確な階層的なLSPトポロジを構築することはできません。"
    },
    {
      "indent": 3,
      "text": "A reply from a downstream node with Return Code 3, may not necessarily be for the FEC being traced. It could be for one of the new FECs that was added. On receipt of an IS_EGRESS reply, the LSP ingress should check if the depth of Target FEC sent to the node that just responded was the same as the depth of the FEC that was being traced. If it was not, then it should pop an entry from the Target FEC stack and resend the request with the same TTL (as previously sent). The process of popping a FEC is to be repeated until either the LSP ingress receives a non-IS_EGRESS reply or until all the additional FECs added to the FEC stack have already been popped. Using an IS_EGRESS reply, an ingress can build a map of the hierarchical LSP structure traversed by a given FEC.",
      "ja": "戻りコード3と下流ノードからの応答は、必ずしもFECがトレースされるためではないかもしれません。これは、追加された新しいのFECのいずれかの可能性があります。単に応答ノードに送信されたターゲットFECの深さは、追跡されたFECの深さと同じであった場合IS_EGRESS応答の受信時に、LSPの入口を確認してください。そうでない場合、それはターゲットFECスタックからエントリをポップし、（以前に送信されたように）同じTTLで要求を再送信すべきです。 LSPの入口のいずれかが非IS_EGRESS応答を受信するか、すべての追加のFECは、FECスタックに追加されるまで、既にポップされるまで、FECをポップの処理が繰り返されます。 IS_EGRESS応答を使用して、入力が与えられたFECが横断階層LSP構造のマップを構築することができます。"
    },
    {
      "indent": 3,
      "text": "When the MPLS echo reply Return Code is \"Label switched with FEC change\", the ingress node SHOULD manipulate the FEC stack as per the FEC stack change sub-TLVs contained in the Downstream Detailed Mapping TLV. A transit node can use this Return Code for stitched LSPs and for hierarchical LSPs. In case of ECMP or P2MP, there could be multiple paths and Downstream Detailed Mapping TLVs with different Return Codes (see Section 3.1, Note 2). The ingress node should build the topology based on the Return Code per ECMP path/P2MP branch.",
      "ja": "MPLSエコー応答リターンコードが「ラベルFEC変化に切り替える」であるとき、入口ノードは、ダウンストリームの詳細なマッピングTLVに含まれるFECスタック切り替えサブTLVの通りのFECスタックを操作すべきです。トランジットノードは、ステッチのLSPのために、階層のLSPのために、このリターンコードを使用することができます。 ECMPまたはP2MPの場合には、複数のパスと異なる戻りコード下流詳細なマッピングのTLV（セクション3.1、注2を参照）が存在し得ます。入口ノードは、ECMPパス/ P2MP分岐あたりの戻りコードに基づいてトポロジを構築する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7. Issue with VPN IPv4 and IPv6 Prefixes",
      "section_title": true,
      "ja": "4.7.  VPN IPv4およびIPv6プレフィックスを持つ問題"
    },
    {
      "indent": 3,
      "text": "Typically, an LSP ping for a VPN IPv4 prefix or VPN IPv6 prefix is sent with a label stack of depth greater than 1, with the innermost label having a TTL of 1. This is to terminate the ping at the egress PE, before it gets sent to the customer device. However, under certain circumstances, the label stack can shrink to a single label before the ping hits the egress PE; this will result in the ping terminating prematurely. One such scenario is a multi-AS Carrier's Carrier VPN.",
      "ja": "典型的には、VPN IPv4プレフィクスまたはVPNのIPv6プレフィックスのLSPピングは、最も内側のラベルこれはそれを取得する前に、出口PEでのpingを終了する1のTTLを有する、1を超える深さのラベルスタックを用いて送信されますお客様のデバイスに送信されます。 pingが出口PEを打つ前しかし、特定の状況下で、ラベルスタックは、単一のラベルに縮小することができます。これは途中で終了ピングになります。そのようなシナリオの1つは、マルチASキャリアのキャリアVPNです。"
    },
    {
      "indent": 3,
      "text": "To get around this problem, one approach is for the LSR that receives such a ping to realize that the ping terminated prematurely and to send back Return Code 13. In that case, the initiating LSR can retry the ping after incrementing the TTL on the VPN label. In this fashion, the ingress LSR will sequentially try TTL values until it finds one that allows the VPN ping to reach the egress PE.",
      "ja": "この問題を回避するには、1つのアプローチは、pingが途中で終了したことを実現するために、その場合、戻りコード13を返送するようにPINGを受け取るLSRのためである、開始LSRは、VPN上でTTLをインクリメントした後にpingを再試行することができますラベル。それはVPNのpingが出口PEに到達することを可能にするものを見つけるまでこのように、入口LSRが順次TTL値を試みます。"
    },
    {
      "indent": 0,
      "text": "4.8. Non-compliant Routers",
      "section_title": true,
      "ja": "4.8. 非対応ルータ"
    },
    {
      "indent": 3,
      "text": "If the egress for the FEC Stack being pinged does not support LSP ping, then no reply will be sent, resulting in possible \"false negatives\". When in \"traceroute\" mode, if a transit LSR does not support LSP ping, then no reply will be forthcoming from that LSR for some TTL, say, n. The LSR originating the echo request SHOULD try sending the echo request with TTL=n+1, n+2, ..., n+k to probe LSRs further down the path. In such a case, the echo request for TTL > n SHOULD be sent with the Downstream Detailed Mapping TLV \"Downstream IP Address\" field set to the ALLROUTERs multicast address until a reply is received with a Downstream Detailed Mapping TLV. The label Stack TLV MAY be omitted from the Downstream Detailed Mapping TLV. Furthermore, the \"Validate FEC Stack\" flag SHOULD NOT be set until an echo reply packet with a Downstream Detailed Mapping TLV is received.",
      "ja": "FECスタックのための出口は、LSPピングをサポートしていないpingを実行している場合は、何も返信が可能「偽陰性」で、その結果、送信されません。トランジットLSRがLSPのPINGをサポートしていない場合場合は、「トレースルート」モードでは、その後、何の返事は、いくつかのTTL、たとえば、nに対してそのLSRから来ることはありません。エコー要求元LSRはTTL有するエコー要求を送信してください= N + 1、N + 2、...、N + kがパスさらに下のLSRをプローブするべきです。このような場合、TTLのためのエコー要求>において、n応答を下流の詳細なマッピングTLVで受信されるまでALLROUTERsマルチキャストアドレスに設定下流詳細マッピングTLV「下流IPアドレス」フィールドで送信されるべきです。ラベルスタックTLVは、ダウンストリームの詳細なマッピングTLVから省略されるかもしれません。また、「検証FECスタック」フラグは、TLVが受信されたダウンストリームの詳細なマッピングとエコー応答パケットまで設定しないでください。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Overall, the security needs for LSP ping are similar to those of ICMP ping.",
      "ja": "全体的に、LSPピングのためのセキュリティニーズは、ICMP pingのと同様です。"
    },
    {
      "indent": 3,
      "text": "There are at least three approaches to attacking LSRs using the mechanisms defined here. One is a Denial-of-Service (DoS) attack, by sending MPLS echo requests/replies to LSRs and thereby increasing their workload. The second is obfuscating the state of the MPLS data-plane liveness by spoofing, hijacking, replaying, or otherwise tampering with MPLS echo requests and replies. The third is an unauthorized source using an LSP ping to obtain information about the network.",
      "ja": "ここで定義されたメカニズムを使用してのLSRを攻撃する、少なくとも3つのアプローチがあります。一つは、MPLSエコー要求を送信することにより、サービス拒否（DoS）攻撃、である/のLSRに応答し、それによって彼らのワークロードが増加します。第二は、なりすまし、ハイジャック、再生、または他の方法でMPLSエコー要求および応答を改ざんすることによってMPLSデータプレーンライブネスの状態を難読化されています。第三には、ネットワークに関する情報を取得するLSPピングを使用して、不正なソースです。"
    },
    {
      "indent": 3,
      "text": "To avoid potential DoS attacks, it is RECOMMENDED that implementations regulate the LSP ping traffic going to the control plane. A rate limiter SHOULD be applied to the well-known UDP port defined in Section 6.1.",
      "ja": "潜在的なDoS攻撃を回避するために、実装はコントロールプレーンに行くのLSP pingトラフィックを制御することが推奨されます。レートリミッタは、6.1節で定義された、よく知られているUDPポートに適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Unsophisticated replay and spoofing attacks involving faking or replaying MPLS echo reply messages are unlikely to be effective. These replies would have to match the Sender's Handle and Sequence Number of an outstanding MPLS echo request message. A non-matching replay would be discarded as the sequence has moved on, thus a spoof has only a small window of opportunity. However, to provide a stronger defense, an implementation MAY also validate the TimeStamp Sent by requiring an exact match on this field.",
      "ja": "MPLSを偽造または再生エコー応答メッセージを含む素朴な再生とスプーフィング攻撃が有効であることがほとんどありません。これらの応答は、優れたMPLSエコー要求メッセージの送信者のハンドルとシーケンス番号と一致しなければなりません。配列は、このようになりすまし機会の少ない窓を有する、上に移動したような非整合リプレイは廃棄されるであろう。しかし、より強力な防御力を提供するために、実装は、この分野での正確な一致を必要とすることによって送信されたタイムスタンプを検証することができます。"
    },
    {
      "indent": 3,
      "text": "To protect against unauthorized sources using MPLS echo request messages to obtain network information, it is RECOMMENDED that implementations provide a means of checking the source addresses of MPLS echo request messages against an access list before accepting the message.",
      "ja": "ネットワーク情報を得るために、MPLSにエコー要求メッセージを使用して、不正なソースから保護するためには、実装がメッセージを受け入れる前に、アクセスリストに対してMPLSエコー要求メッセージの送信元アドレスをチェックする手段を提供することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "It is not clear how to prevent hijacking (non-delivery) of echo requests or replies; however, if these messages are indeed hijacked, LSP ping will report that the data plane is not working as it should.",
      "ja": "エコー要求や応答のハイジャック（非配信）を防止する方法は明らかではありません。これらのメッセージは確かにハイジャックされている場合は、LSPピングは、データプレーンは、それが必要として動作していないことを報告します。"
    },
    {
      "indent": 3,
      "text": "It does not seem vital (at this point) to secure the data carried in MPLS echo requests and replies, although knowledge of the state of the MPLS data plane may be considered confidential by some. Implementations SHOULD, however, provide a means of filtering the addresses to which echo reply messages may be sent.",
      "ja": "MPLSデータプレーンの状態の知識がいくつかによって機密と見なすことができるが、MPLSエコー要求と応答で搬送されたデータを保護するために（この時点で）重要ないないようです。実装は、しかし、メッセージが送信されても​​よい返信エコーたアドレスをフィルタリングする手段を提供すべきです。"
    },
    {
      "indent": 3,
      "text": "The value part of the Pad TLV contains a variable number of octets. With the exception of the first octet, these contents, if any, are ignored on receipt, and can therefore serve as a clandestine channel.",
      "ja": "パッドTLVの値の一部は、オクテットの可変数が含まれています。最初のオクテットを除いて、これらの内容は、いずれの場合、領収書の上で無視されているため、秘密のチャネルとして機能することができます。"
    },
    {
      "indent": 3,
      "text": "When MPLS LSP ping is used within an administrative domain, a deployment can increase security by using border filtering of incoming LSP ping packets as well as outgoing LSP ping packets.",
      "ja": "MPLS LSPピングは、管理ドメイン内で使用される場合、配備は、着信LSP pingパケットの境界フィルタリングならびに発信LSP pingパケットを使用してセキュリティを高めることができます。"
    },
    {
      "indent": 3,
      "text": "Although this document makes special use of 127/8 addresses, these are used only in conjunction with the UDP port 3503. Furthermore, these packets are only processed by routers. All other hosts MUST treat all packets with a destination address in the range 127/8 in accordance to RFC 1122. Any packet received by a router with a destination address in the range 127/8 without a destination UDP port of 3503 MUST be treated in accordance to RFC 1812. In particular, the default behavior is to treat packets destined to a 127/8 address as \"martians\".",
      "ja": "この文書は8分の127のアドレスの特別利用しますが、これらだけさらにUDPポート3503と組み合わせて使用​​され、これらのパケットはルータによって処理されます。他のすべてのホストは、RFC 1122に合わせて3503の宛先UDPポートなし範囲8分の127の宛先アドレスを持つルータが受信した任意のパケットが中で処理しなければならない範囲8分の127内の宛先アドレスを持つすべてのパケットを扱わなければなりません特に、RFC 1812に基づき、デフォルトの動作は、「火星人」として8分の127のアドレス宛てのパケットを処理することです。"
    },
    {
      "indent": 3,
      "text": "If a network operator wants to prevent tracing inside a tunnel, one can use the Pipe Model [RFC3443], i.e., hide the outer MPLS tunnel by not propagating the MPLS TTL into the outer tunnel (at the start of the outer tunnel). By doing this, LSP traceroute packets will not expire in the outer tunnel, and the outer tunnel will not get traced.",
      "ja": "ネットワークオペレータは、トンネル内トレースを防止したい場合、一方はパイプモデル[RFC3443]を使用することができ、すなわち、（外側のトンネルの開始時に）外側トンネルにMPLS TTLを伝播しないことにより、外側のMPLSトンネルを隠します。これにより、LSPトレースルートパケットは、外側トンネルに期限切れになりません、そして外側のトンネルがトレースされません。"
    },
    {
      "indent": 3,
      "text": "If one doesn't wish to expose the details of the new outer LSP, then the Nil FEC can be used to hide those details. Using the Nil FEC ensures that the trace progresses without false negatives and all transit nodes (of the new outer tunnel) perform some minimal validations on the received MPLS echo requests.",
      "ja": "1は、新しい外LSPの詳細を公開したくない場合は、無記号FECは、それらの詳細を隠すために使用することができます。無記号FECを使用すると、受信したMPLSエコー要求である最小検証を実行トレースは偽陰性と（新しいアウタートンネルの）すべてのトランジットノードなしで進行することを確実にします。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. TCP and UDP Port Number",
      "section_title": true,
      "ja": "6.1.  TCPおよびUDPポート番号"
    },
    {
      "indent": 3,
      "text": "The TCP and UDP port number 3503 has been allocated by IANA for LSP echo requests and replies.",
      "ja": "TCPとUDPのポート番号3503は、LSPエコー要求および応答のためにIANAによって割り当てられています。"
    },
    {
      "indent": 0,
      "text": "6.2. MPLS LSP Ping Parameters",
      "section_title": true,
      "ja": "6.2.  MPLS LSP pingのパラメータ"
    },
    {
      "indent": 3,
      "text": "IANA maintains the \"Multiprotocol Label Switching (MPLS) Label Switched Paths (LSPs) Ping Parameters\" registry at [IANA-MPLS-LSP-PING].",
      "ja": "IANAが管理する[IANA-MPLS-LSP-PING]でレジストリ \"マルチプロトコルラベルスイッチング（MPLS）は、ラベル（のLSP）Pingのパラメータをパスの交換しました\"。"
    },
    {
      "indent": 3,
      "text": "The following subsections detail the name spaces managed by IANA. For some of these name spaces, the space is divided into assignment ranges; the following terms are used in describing the procedures by which IANA allocates values: \"Standards Action\" (as defined in [RFC5226]), \"Specification Required\", and \"Vendor Private Use\".",
      "ja": "以下のサブセクションの詳細IANAによって管理される名前空間。これらの名前空間の一部では、スペースが割り当て範囲に分割されます。 「標準アクション」（[RFC5226]で定義されるように）、「仕様が必要」、および「ベンダープライベート使用」：以下の用語は、IANAに値を割り当てるれる手順を説明するのに使用されます。"
    },
    {
      "indent": 3,
      "text": "Values from \"Specification Required\" ranges MUST be registered with IANA. The request MUST be made via an RFC that describes the format and procedures for using the code point; the actual assignment is made during the IANA actions for the RFC.",
      "ja": "「仕様が必要」の範囲からの値はIANAに登録しなければなりません。要求は、コードポイントを使用するためのフォーマットおよび手順を説明RFCを介して行わなければなりません。実際の割り当てはRFCのIANAアクション中に行われます。"
    },
    {
      "indent": 3,
      "text": "Values from \"Vendor Private\" ranges MUST NOT be registered with IANA; however, the message MUST contain an enterprise code as registered with the IANA SMI Private Network Management Private Enterprise Numbers. For each name space that has a Vendor Private range, it must be specified where exactly the SMI Private Enterprise Number resides; see below for examples. In this way, several enterprises (vendors) can use the same code point without fear of collision.",
      "ja": "「ベンダープライベート」の範囲からの値はIANAに登録されてはなりません。 IANA SMIプライベートネットワーク管理プライベート・エンタープライズ番号に登録されしかし、メッセージは、エンタープライズコードを含まなければなりません。正確にSMI民間企業の数はどこにあるベンダーのプライベート範囲を持つ各名前空間の場合は、指定する必要があります。例については以下を参照してください。このように、いくつかの企業（ベンダー）は衝突の恐れなしに同じコードポイントを使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Message Types, Reply Modes, Return Codes",
      "section_title": true,
      "ja": "6.2.1. メッセージタイプは、モードの返信、リターンコード"
    },
    {
      "indent": 3,
      "text": "IANA has created and will maintain registries for Message Types, Reply Modes, and Return Codes. Each of these can take values in the range 0-255. Assignments in the range 0-191 are via Standards Action; assignments in the range 192-251 are made via \"Specification Required\"; values in the range 252-255 are for Vendor Private Use and MUST NOT be allocated.",
      "ja": "IANAは、作成していると、メッセージタイプのためのレジストリを維持するモードの返信、およびコードを返します。これらのそれぞれは、0〜255の範囲の値を取ることができます。範囲0から191での割り当ては標準アクションを経由しています。範囲192から251での割り当ては、「仕様が必要」を経由して作られています。範囲252から255の値は、ベンダー私的使用のためであり、割り当てられてはなりません。"
    },
    {
      "indent": 3,
      "text": "If any of these fields fall in the Vendor Private range, a top-level Vendor Enterprise Number TLV MUST be present in the message.",
      "ja": "これらのフィールドのいずれかがベンダーのプライベート範囲にいる場合、トップレベルのベンダー企業の数TLVは、メッセージ内に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Types defined in this document are the following:",
      "ja": "この文書で定義されたメッセージタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS Echo Request\n    2    MPLS Echo Reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reply Modes defined in this document are the following:",
      "ja": "以下の通り、この文書で定義されたモードの返信："
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application-level control channel",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Return Codes defined in this document are listed in Section 3.1.",
      "ja": "この文書で定義されたリターンコードは、セクション3.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the reference for each these values to this document.",
      "ja": "IANAはこのドキュメントへの各これらの値の参照を更新しました。"
    },
    {
      "indent": 0,
      "text": "6.2.2. TLVs",
      "section_title": true,
      "ja": "6.2.2.  TLV"
    },
    {
      "indent": 3,
      "text": "IANA has created and maintains a registry for the Type field of top-level TLVs as well as for any associated sub-TLVs. Note that the meaning of a sub-TLV is scoped by the TLV. The number spaces for the sub-TLVs of various TLVs are independent.",
      "ja": "IANAが作成され、最上位のTLVのTypeフィールドのためだけでなく、任意の関連するサブTLVのためのレジストリを維持しています。サブTLVの意味はTLVによってスコープされることに注意してください。種々のTLVのサブTLVのための番号空間は独立しています。"
    },
    {
      "indent": 3,
      "text": "The valid range for TLVs and sub-TLVs is 0-65535. Assignments in the ranges 0-16383 and 32768-49161 are made via Standards Action as defined in [RFC5226]; assignments in the ranges 16384-31743 and 49162-64511 are made via \"Specification Required\"; values in the ranges 31744-32767 and 64512-65535 are for Vendor Private Use and MUST NOT be allocated.",
      "ja": "TLVのサブTLVのための有効な範囲は0〜65535です。 [RFC5226]で定義されるように範囲0から16383と32768から49161で割り当ては標準アクションを介して行われます。範囲16384から31743と49162から64511での割り当ては、「仕様が必要」を経由して作られています。範囲31744から32767と64512から65535の値はベンダー私的使用のためであり、割り当てられてはなりません。"
    },
    {
      "indent": 3,
      "text": "If a TLV or sub-TLV has a Type that falls in the range for Vendor Private Use, the Length MUST be at least 4, and the first four octets MUST be that vendor's SMI Private Enterprise Number, in network octet order. The rest of the Value field is private to the vendor.",
      "ja": "TLVまたはサブTLVは、ベンダー私的使用のための範囲内に収まるタイプを持っている場合、長さは少なくとも4でなければならない、と最初の4つのオクテットは、ネットワークオクテット順に、そのベンダーのSMI民間企業数でなければなりません。 Valueフィールドの残りの部分は、ベンダーにプライベートです。"
    },
    {
      "indent": 3,
      "text": "TLVs and sub-TLVs defined in this document are the following:",
      "ja": "この文書で定義されたTLVとサブのTLVは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Type     Sub-Type        Value Field\n----     --------        -----------\n   1                     Target FEC Stack\n                1        LDP IPv4 prefix\n                2        LDP IPv6 prefix\n                3        RSVP IPv4 LSP\n                4        RSVP IPv6 LSP\n                5        Unassigned\n                6        VPN IPv4 prefix\n                7        VPN IPv6 prefix\n                8        L2 VPN endpoint\n                9        \"FEC 128\" Pseudowire - IPv4 (Deprecated)\n               10        \"FEC 128\" Pseudowire - IPv4\n               11        \"FEC 129\" Pseudowire -  IPv4\n               12        BGP labeled IPv4 prefix\n               13        BGP labeled IPv6 prefix\n               14        Generic IPv4 prefix\n               15        Generic IPv6 prefix\n               16        Nil FEC\n               24        \"FEC 128\" Pseudowire - IPv6\n               25        \"FEC 129\" Pseudowire - IPv6\n   2                     Downstream Mapping (Deprecated)\n   3                     Pad\n   4                     Unassigned\n   5                     Vendor Enterprise Number\n   6                     Unassigned\n   7                     Interface and Label Stack\n   8                     Unassigned\n   9                     Errored TLVs\n        Any value        The TLV not understood\n  10                     Reply TOS Byte\n  20                     Downstream Detailed Mapping",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IANA has updated the reference for each of these values to this document.",
      "ja": "IANAは、この文書にこれらの値のそれぞれについて参照を更新しました。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Global Flags",
      "section_title": true,
      "ja": "6.2.3. グローバルフラグ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"Global Flags\" subregistry of the \"Multiprotocol Label Switching (MPLS) Label Switched Paths (LSPs) Ping Parameters\" registry.",
      "ja": "IANAは、の「グローバル・フラッグ」副登録作成したレジストリ「マルチプロトコルラベルスイッチング（MPLS）をラベル（のLSP）Pingのパラメータをパスの交換しました」。"
    },
    {
      "indent": 3,
      "text": "This registry tracks the assignment of 16 flags in the Global Flags field of the MPLS LSP ping echo request message. The flags are numbered from 0 (most significant bit, transmitted first) to 15.",
      "ja": "このレジストリは、MPLS LSP pingのエコー要求メッセージのグローバルフラグ欄に16個のフラグの割り当てを追跡します。フラグが0（最初の送信最上位ビット）から15まで番号が付けられています。"
    },
    {
      "indent": 3,
      "text": "New entries are assigned by Standards Action.",
      "ja": "新しいエントリは標準アクションによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Initial entries in the registry are as follows:",
      "ja": "次のようにレジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Bit number  |  Name                      | Reference\n------------+----------------------------+--------------\n  15        |  V Flag                    | [RFC8029]\n  14        |  T Flag                    | [RFC6425]\n  13        |  R Flag                    | [RFC6426]\n  12-0      |  Unassigned                | [RFC8029]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2.4. Downstream Detailed Mapping Address Type",
      "section_title": true,
      "ja": "6.2.4. 下流の詳細なマッピングアドレスタイプ"
    },
    {
      "indent": 3,
      "text": "This document extends RFC 4379 by defining a new address type for use with the Downstream Mapping and Downstream Detailed Mapping TLVs. IANA has established a registry to assign address types for use with the Downstream Mapping and Downstream Detailed Mapping TLVs, which initially allocates the following assignments:",
      "ja": "この文書では、ダウンストリームマッピングと川下の詳細なマッピングのTLVで使用する新しいアドレスタイプを定義することによって、RFC 4379を拡張します。 IANAは、最初に、次の割り当てを割り当て、ダウンストリームマッピングと川下の詳細なマッピングのTLVで使用するためのアドレスの種類を割り当てるために、レジストリを確立しています："
    },
    {
      "indent": 6,
      "text": "Type #     Address Type      K Octets    Reference\n------     ------------      --------    ---------\n     1     IPv4 Numbered           16    [RFC8029]\n     2     IPv4 Unnumbered         16    [RFC8029]\n     3     IPv6 Numbered           40    [RFC8029]\n     4     IPv6 Unnumbered         28    [RFC8029]\n     5     Non IP                  12    [RFC6426]",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Downstream Detailed Mapping Address Type Registry",
      "ja": "下流の詳細なマッピングアドレスタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "Because the field in this case is an 8-bit field, the allocation policy for this registry is \"Standards Action\".",
      "ja": "この場合、フィールドは8ビットのフィールドであるため、このレジストリの割り当てポリシーは、「標準化アクション」です。"
    },
    {
      "indent": 0,
      "text": "6.2.5. DS Flags",
      "section_title": true,
      "ja": "6.2.5.  DSフラグ"
    },
    {
      "indent": 3,
      "text": "This document defines the Downstream Mapping (DSMAP) TLV and the Downstream Detailed Mapping (DDMAP) TLV, which have Type 2 and Type 20, respectively, assigned from the \"TLVs\" subregistry of the \"Multiprotocol Label Switching (MPLS) Label Switched Paths (LSPs) Ping Parameters\" registry.",
      "ja": "この文書では、ダウンストリームマッピング（DSMAP）TLV及び「マルチプロトコルラベルスイッチング（MPLS）の「TLVを」副登録から割り当てられたタイプ2を有し、それぞれ、20を入力し下流詳細マッピング（DDMAP）TLVは、ラベル（パススイッチ定義しますLSP）Pingのパラメータ」のレジストリ。"
    },
    {
      "indent": 3,
      "text": "DSMAP has been deprecated by DDMAP, but both TLVs share a field: DS Flags.",
      "ja": "DSMAPはDDMAPによって廃止されていますが、両方のTLVフィールドを共有する：DSフラグを。"
    },
    {
      "indent": 3,
      "text": "IANA has created and now maintains a registry entitled \"DS Flags\".",
      "ja": "IANAは、作成され、現在は「DSフラグ」と題されたレジストリを維持しています。"
    },
    {
      "indent": 3,
      "text": "The registration policy for this registry is Standards Action [RFC5226].",
      "ja": "このレジストリの登録ポリシーは、標準アクション[RFC5226]です。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following assignments:",
      "ja": "IANAは、次の割り当てを行っています。"
    },
    {
      "indent": 4,
      "text": "Bit Number Name                                         Reference\n---------- -------------------------------------------  ---------\n      7    N: Treat as a Non-IP Packet                  [RFC8029]\n      6    I: Interface and Label Stack Object Request  [RFC8029]\n      5    E: ELI/EL push indicator                     [RFC8012]\n      4    L: Label-based load balance indicator        [RFC8012]\n    3-0    Unassigned",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2.6. Multipath Types",
      "section_title": true,
      "ja": "6.2.6. マルチパスの種類"
    },
    {
      "indent": 3,
      "text": "IANA has created and now maintains a registry entitled \"Multipath Types\".",
      "ja": "IANAが作成され、今や「マルチタイプ」と題し、レジストリを維持しています。"
    },
    {
      "indent": 3,
      "text": "The registration policy [RFC5226] for this registry is Standards Action.",
      "ja": "このレジストリの登録ポリシー[RFC5226]は標準アクションです。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following assignments:",
      "ja": "IANAは、次の割り当てを行っています。"
    },
    {
      "indent": 4,
      "text": "Value      Meaning                                  Reference\n---------- ---------------------------------------- ---------\n      0    no multipath                             [RFC8029]\n      1    Unassigned\n      2    IP address                               [RFC8029]\n      3    Unassigned\n      4    IP address range                         [RFC8029]\n    5-7    Unassigned\n      8    Bit-masked IP address set                [RFC8029]\n      9    Bit-masked label set                     [RFC8029]\n     10    IP and label set                         [RFC8012]\n 11-250    Unassigned\n251-254    Reserved for Experimental Use            [RFC8029]\n    255    Reserved                                 [RFC8029]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2.7. Pad Type",
      "section_title": true,
      "ja": "6.2.7. パッドタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created and now maintains a registry entitled \"Pad Types\".",
      "ja": "IANAは、作成され、現在は「パッドタイプ」と題し、レジストリを維持しています。"
    },
    {
      "indent": 3,
      "text": "The registration policy [RFC5226] for this registry is Standards Action.",
      "ja": "このレジストリの登録ポリシー[RFC5226]は標準アクションです。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following initial assignments:",
      "ja": "IANAは以下の初期割り当てを行っています。"
    },
    {
      "indent": 3,
      "text": "Registry Name: Pad Types",
      "ja": "レジストリ名：パッドタイプ"
    },
    {
      "indent": 4,
      "text": "Value      Meaning                                  Reference\n---------- ---------------------------------------- ---------\n      0    Reserved                                 [RFC8029]\n      1    Drop Pad TLV from reply                  [RFC8029]\n      2    Copy Pad TLV to reply                    [RFC8029]\n  3-250    Unassigned\n251-254    Experimental Use                         [RFC8029]\n    255    Reserved                                 [RFC8029]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2.8. Interface and Label Stack Address Type",
      "section_title": true,
      "ja": "6.2.8. インタフェースとラベルスタックのアドレスタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created and now maintains a registry entitled \"Interface and Label Stack Address Types\".",
      "ja": "IANAは、作成され、現在は「インタフェースとラベルスタックアドレスタイプ」と題し、レジストリを維持しています。"
    },
    {
      "indent": 3,
      "text": "The registration policy [RFC5226] for this registry is Standards Action.",
      "ja": "このレジストリの登録ポリシー[RFC5226]は標準アクションです。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following initial assignments:",
      "ja": "IANAは以下の初期割り当てを行っています。"
    },
    {
      "indent": 3,
      "text": "Registry Name: Interface and Label Stack Address Types",
      "ja": "レジストリ名：インタフェースとラベルスタックアドレスの種類"
    },
    {
      "indent": 4,
      "text": "Value      Meaning                                  Reference\n---------- ---------------------------------------- ---------\n      0    Reserved                                 [RFC8029]\n      1    IPv4 Numbered                            [RFC8029]\n      2    IPv4 Unnumbered                          [RFC8029]\n      3    IPv6 Numbered                            [RFC8029]\n      4    IPv6 Unnumbered                          [RFC8029]\n  5-250    Unassigned\n251-254    Experimental Use                         [RFC8029]\n    255    Reserved                                 [RFC8029]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.3. IPv4 Special-Purpose Address Registry",
      "section_title": true,
      "ja": "6.3.  IPv4の特別な目的の住所レジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has updated the reference in Note 1 of the \"IANA IPv4 Special-Purpose Address Registry\" [IANA-SPECIAL-IPv4] to point to this document.",
      "ja": "IANAはこのドキュメントを指すように「IANAのIPv4特別な目的のアドレス登録」[IANA-SPECIAL-のIPv4]のNote 1に参照を更新しました。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <http://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<http://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., Ed., \"Requirements for IP Version 4 Routers\", RFC 1812, DOI 10.17487/RFC1812, June 1995, <http://www.rfc-editor.org/info/rfc1812>.",
      "ja": "[RFC1812]ベイカー、F.、エド。、 \"IPバージョン4つのルータのための要件\"、RFC 1812、DOI 10.17487 / RFC1812、1995年6月、<http://www.rfc-editor.org/info/rfc1812>。"
    },
    {
      "indent": 3,
      "text": "[RFC2113] Katz, D., \"IP Router Alert Option\", RFC 2113, DOI 10.17487/RFC2113, February 1997, <http://www.rfc-editor.org/info/rfc2113>.",
      "ja": "[RFC2113]カッツ、D.、 \"IPルータアラートオプション\"、RFC 2113、DOI 10.17487 / RFC2113、1997年2月、<http://www.rfc-editor.org/info/rfc2113>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3032] Rosen, E., Tappan, D., Fedorkow, G., Rekhter, Y., Farinacci, D., Li, T., and A. Conta, \"MPLS Label Stack Encoding\", RFC 3032, DOI 10.17487/RFC3032, January 2001, <http://www.rfc-editor.org/info/rfc3032>.",
      "ja": "[RFC3032]ローゼン、E.、タッパン、D.、Fedorkow、G.、Rekhter、Y.、ファリナッチ、D.、李、T.、およびA.コンタ、 \"MPLSラベルスタックエンコーディング\"、RFC 3032、DOI 10.17487 / RFC3032、2001年1月、<http://www.rfc-editor.org/info/rfc3032>。"
    },
    {
      "indent": 3,
      "text": "[RFC4271] Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., \"A Border Gateway Protocol 4 (BGP-4)\", RFC 4271, DOI 10.17487/RFC4271, January 2006, <http://www.rfc-editor.org/info/rfc4271>.",
      "ja": "[RFC4271] Rekhter、Y.、エド。、李、T.、エド。、およびS.野兎、編、 \"ボーダーゲートウェイプロトコル4（BGP-4）\"、RFC 4271、DOI 10.17487 / RFC4271、2006年1月、<http://www.rfc-editor.org/info/rfc4271>。"
    },
    {
      "indent": 3,
      "text": "[RFC4379] Kompella, K. and G. Swallow, \"Detecting Multi-Protocol Label Switched (MPLS) Data Plane Failures\", RFC 4379, DOI 10.17487/RFC4379, February 2006, <http://www.rfc-editor.org/info/rfc4379>.",
      "ja": "[RFC4379] Kompella、K.とG.ツバメ、 \"検出マルチプロトコルラベル（MPLS）データプレーン障害のスイッチ\"、RFC 4379、DOI 10.17487 / RFC4379、2006年2月、<http://www.rfc-editor.org /情報/ rfc4379>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010, <http://www.rfc-editor.org/info/rfc5905>.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"。、RFC 5905、DOI 10.17487 / RFC5905、2010年6月、 <http://www.rfc-editor.org/info/rfc5905>。"
    },
    {
      "indent": 3,
      "text": "[RFC6424] Bahadur, N., Kompella, K., and G. Swallow, \"Mechanism for Performing Label Switched Path Ping (LSP Ping) over MPLS Tunnels\", RFC 6424, DOI 10.17487/RFC6424, November 2011, <http://www.rfc-editor.org/info/rfc6424>.",
      "ja": "[RFC6424]バハドゥール、N.、Kompella、K.、およびG.ツバメ、RFC 6424、 \"MPLSトンネルの上にラベルスイッチパスのPing（LSPのPing）を実行するためのメカニズム\"、DOI 10.17487 / RFC6424、2011年11月、<のhttp：/ /www.rfc-editor.org/info/rfc6424>。"
    },
    {
      "indent": 3,
      "text": "[RFC7506] Raza, K., Akiya, N., and C. Pignataro, \"IPv6 Router Alert Option for MPLS Operations, Administration, and Maintenance (OAM)\", RFC 7506, DOI 10.17487/RFC7506, April 2015, <http://www.rfc-editor.org/info/rfc7506>.",
      "ja": "[RFC7506]ラザ、K.、秋谷、N.、およびC. Pignataro、 \"MPLS運用、管理、および保守（OAM）のIPv6ルータアラートオプション\"、RFC 7506、DOI 10.17487 / RFC7506、2015年4月、<のhttp： //www.rfc-editor.org/info/rfc7506>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Err108] RFC Errata, Erratum ID 108, RFC 4379.",
      "ja": "【Err108] RFCエラッタ、エラータID 108、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err742] RFC Errata, Erratum ID 742, RFC 4379.",
      "ja": "【Err742] RFCエラッタ、エラータID 742、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err1418] RFC Errata, Erratum ID 1418, RFC 4379.",
      "ja": "【Err1418] RFCエラッタ、エラータID 1418、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err1714] RFC Errata, Erratum ID 1714, RFC 4379.",
      "ja": "【Err1714] RFCエラッタ、エラータID 1714、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err1786] RFC Errata, Erratum ID 1786, RFC 4379.",
      "ja": "【Err1786] RFCエラッタ、エラータID 1786、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err2978] RFC Errata, Erratum ID 2978, RFC 4379.",
      "ja": "【Err2978] RFCエラッタ、エラータID 2978、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[Err3399] RFC Errata, Erratum ID 3399, RFC 4379.",
      "ja": "【Err3399] RFCエラッタ、エラータID 3399、RFC 4379。"
    },
    {
      "indent": 3,
      "text": "[IANA-ENT] IANA, \"PRIVATE ENTERPRISE NUMBERS\", <http://www.iana.org/assignments/enterprise-numbers>.",
      "ja": "[IANA-ENT] IANA、 \"民間企業番号\"、<http://www.iana.org/assignments/enterprise-numbers>。"
    },
    {
      "indent": 3,
      "text": "[IANA-MPLS-LSP-PING] IANA, \"Multiprotocol Label Switching (MPLS) Label Switched Paths (LSPs) Ping Parameters\", <http://www.iana.org/assignments/ mpls-lsp-ping-parameters>.",
      "ja": "[IANA-MPLS-LSP-PING] IANA、<http://www.iana.org/assignments/ MPLS-LSPピングパラメータ>、 \"マルチプロトコルラベルスイッチング（MPLS）ラベル（のLSP）のPingパラメータパスの交換しました\"。"
    },
    {
      "indent": 3,
      "text": "[IANA-SPECIAL-IPv4] IANA, \"IANA IPv4 Special-Purpose Address Registry\", <http://www.iana.org/assignments/ iana-ipv4-special-registry>.",
      "ja": "[IANA-SPECIAL-のIPv4] IANA、 \"IANAのIPv4特別な目的のアドレス登録\"、<http://www.iana.org/assignments/ IANAのIPv4--特別レジストリ>。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <http://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC0792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<http://www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC3107] Rekhter, Y. and E. Rosen, \"Carrying Label Information in BGP-4\", RFC 3107, DOI 10.17487/RFC3107, May 2001, <http://www.rfc-editor.org/info/rfc3107>.",
      "ja": "[RFC3107] Rekhter、Y.、およびE.ローゼン、 \"BGP-4のラベル情報を運ぶ\"、RFC 3107、DOI 10.17487 / RFC3107、2001年5月、<http://www.rfc-editor.org/info/rfc3107> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3209] Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V., and G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP Tunnels\", RFC 3209, DOI 10.17487/RFC3209, December 2001, <http://www.rfc-editor.org/info/rfc3209>.",
      "ja": "[RFC3209] Awduche、D.、バーガー、L.、ガン、D.、李、T.、スリニヴァサン、V.、およびG.ツバメ、 \"RSVP-TE：ExtensionsがLSPトンネルのためのRSVPする\"、RFC 3209、DOI 10.17487 / RFC3209、2001年12月、<http://www.rfc-editor.org/info/rfc3209>。"
    },
    {
      "indent": 3,
      "text": "[RFC3443] Agarwal, P. and B. Akyol, \"Time To Live (TTL) Processing in Multi-Protocol Label Switching (MPLS) Networks\", RFC 3443, DOI 10.17487/RFC3443, January 2003, <http://www.rfc-editor.org/info/rfc3443>.",
      "ja": "[RFC3443] Agarwalさん、P.とB. Akyol、 \"生存時間（TTL）（MPLS）ネットワークのマルチプロトコルラベルスイッチングの処理\"、RFC 3443、DOI 10.17487 / RFC3443、2003年1月、<のhttp：// WWW。 rfc-editor.org/info/rfc3443>。"
    },
    {
      "indent": 3,
      "text": "[RFC4026] Andersson, L. and T. Madsen, \"Provider Provisioned Virtual Private Network (VPN) Terminology\", RFC 4026, DOI 10.17487/RFC4026, March 2005, <http://www.rfc-editor.org/info/rfc4026>.",
      "ja": "[RFC4026]アンデションとL.とT.マドセンは、RFC 4026 \"プロバイダーの仮想プライベートネットワーク（VPN）の用語をプロビジョニング\"、DOI 10.17487 / RFC4026、2005年3月、<http://www.rfc-editor.org/info/ rfc4026>。"
    },
    {
      "indent": 3,
      "text": "[RFC4365] Rosen, E., \"Applicability Statement for BGP/MPLS IP Virtual Private Networks (VPNs)\", RFC 4365, DOI 10.17487/RFC4365, February 2006, <http://www.rfc-editor.org/info/rfc4365>.",
      "ja": "[RFC4365]ローゼン、E.、 \"BGP / MPLS IP仮想プライベートネットワーク（VPN）のための適用性に関する声明\"、RFC 4365、DOI 10.17487 / RFC4365、2006年2月、<http://www.rfc-editor.org/info/ rfc4365>。"
    },
    {
      "indent": 3,
      "text": "[RFC4461] Yasukawa, S., Ed., \"Signaling Requirements for Point-to-Multipoint Traffic-Engineered MPLS Label Switched Paths (LSPs)\", RFC 4461, DOI 10.17487/RFC4461, April 2006, <http://www.rfc-editor.org/info/rfc4461>.",
      "ja": "[RFC4461]安川、S.、エド、2006年4月、RFC 4461、DOI 10.17487 / RFC4461、 \"ポイントツーマルチポイントトラフィック・エンジニアMPLSラベルのためのシグナリング要件は、スイッチパス（LSP）\"、<のhttp：// WWW。 rfc-editor.org/info/rfc4461>。"
    },
    {
      "indent": 3,
      "text": "[RFC4761] Kompella, K., Ed. and Y. Rekhter, Ed., \"Virtual Private LAN Service (VPLS) Using BGP for Auto-Discovery and Signaling\", RFC 4761, DOI 10.17487/RFC4761, January 2007, <http://www.rfc-editor.org/info/rfc4761>.",
      "ja": "[RFC4761] Kompella、K.、エド。そして、Y. Rekhter、エド。、 \"仮想プライベートLANサービス（VPLS）自動検出およびシグナリングのためにBGPを使用する\"、RFC 4761、DOI 10.17487 / RFC4761、2007年1月、<http://www.rfc-editor.org/情報/ rfc4761>。"
    },
    {
      "indent": 3,
      "text": "[RFC5036] Andersson, L., Ed., Minei, I., Ed., and B. Thomas, Ed., \"LDP Specification\", RFC 5036, DOI 10.17487/RFC5036, October 2007, <http://www.rfc-editor.org/info/rfc5036>.",
      "ja": "[RFC5036]アンデション、L.、エド、Minei、I.、エド、およびB.トーマス、エド、 \"LDP仕様\"、RFC 5036、DOI 10.17487 / RFC5036、2007年10月、<のhttp：。。。// WWW。 rfc-editor.org/info/rfc5036>。"
    },
    {
      "indent": 3,
      "text": "[RFC5085] Nadeau, T., Ed. and C. Pignataro, Ed., \"Pseudowire Virtual Circuit Connectivity Verification (VCCV): A Control Channel for Pseudowires\", RFC 5085, DOI 10.17487/RFC5085, December 2007, <http://www.rfc-editor.org/info/rfc5085>.",
      "ja": "[RFC5085]ナドー、T.、エド。そして、C. Pignataro、エド、 \"Pseudowireの仮想回線接続性検証（VCCV）：スードワイヤ用制御チャネル\"、RFC 5085、DOI 10.17487 / RFC5085、2007年12月、<http://www.rfc-editor.org/info / rfc5085>。"
    },
    {
      "indent": 3,
      "text": "[RFC5331] Aggarwal, R., Rekhter, Y., and E. Rosen, \"MPLS Upstream Label Assignment and Context-Specific Label Space\", RFC 5331, DOI 10.17487/RFC5331, August 2008, <http://www.rfc-editor.org/info/rfc5331>.",
      "ja": "[RFC5331]アガルワル、R.、Rekhter、Y.、およびE.ローゼン、 \"MPLS上流ラベルの割り当てとコンテキスト固有のラベルスペース\"、RFC 5331、DOI 10.17487 / RFC5331、2008年8月、<のhttp：//www.rfc -editor.org/info/rfc5331>。"
    },
    {
      "indent": 3,
      "text": "[RFC5462] Andersson, L. and R. Asati, \"Multiprotocol Label Switching (MPLS) Label Stack Entry: \"EXP\" Field Renamed to \"Traffic Class\" Field\", RFC 5462, DOI 10.17487/RFC5462, February 2009, <http://www.rfc-editor.org/info/rfc5462>.",
      "ja": "[RFC5462]アンデション、L.およびR. Asati、 \"マルチプロトコルラベルスイッチング（MPLS）ラベルスタックエントリ： \"EXPトラフィッククラス \"フィールド\"\" に改名フィールド\"、RFC 5462、DOI 10.17487 / RFC5462、2009年2月、<のhttp： //www.rfc-editor.org/info/rfc5462>。"
    },
    {
      "indent": 3,
      "text": "[RFC5885] Nadeau, T., Ed. and C. Pignataro, Ed., \"Bidirectional Forwarding Detection (BFD) for the Pseudowire Virtual Circuit Connectivity Verification (VCCV)\", RFC 5885, DOI 10.17487/RFC5885, June 2010, <http://www.rfc-editor.org/info/rfc5885>.",
      "ja": "[RFC5885]ナドー、T.、エド。そして \"スードワイヤ仮想回線接続性検証（VCCV）のための双方向フォワーディング検出（BFD）\" C. Pignataro、エド。、RFC 5885、DOI 10.17487 / RFC5885、2010年6月、<http://www.rfc-editor.org /情報/ rfc5885>。"
    },
    {
      "indent": 3,
      "text": "[RFC6425] Saxena, S., Ed., Swallow, G., Ali, Z., Farrel, A., Yasukawa, S., and T. Nadeau, \"Detecting Data-Plane Failures in Point-to-Multipoint MPLS - Extensions to LSP Ping\", RFC 6425, DOI 10.17487/RFC6425, November 2011, <http://www.rfc-editor.org/info/rfc6425>.",
      "ja": "[RFC6425] Saxena、S.、エド、ツバメ、G.、アリ、Z.、ファレル、A.、安川、S.、およびT.ナドー、ポイントツーマルチポイントMPLSにおける「検出するデータプレーン障害。 - LSP pingに拡張機能」、RFC 6425、DOI 10.17487 / RFC6425、2011年11月、<http://www.rfc-editor.org/info/rfc6425>。"
    },
    {
      "indent": 3,
      "text": "[RFC6426] Gray, E., Bahadur, N., Boutros, S., and R. Aggarwal, \"MPLS On-Demand Connectivity Verification and Route Tracing\", RFC 6426, DOI 10.17487/RFC6426, November 2011, <http://www.rfc-editor.org/info/rfc6426>.",
      "ja": "[RFC6426]グレー、E.、バハドゥール、N.、Boutros、S.、およびR.アガルワル、 \"MPLSオンデマンド接続検証とルートトレース\"、RFC 6426、DOI 10.17487 / RFC6426、2011年11月、<のhttp：/ /www.rfc-editor.org/info/rfc6426>。"
    },
    {
      "indent": 3,
      "text": "[RFC6829] Chen, M., Pan, P., Pignataro, C., and R. Asati, \"Label Switched Path (LSP) Ping for Pseudowire Forwarding Equivalence Classes (FECs) Advertised over IPv6\", RFC 6829, DOI 10.17487/RFC6829, January 2013, <http://www.rfc-editor.org/info/rfc6829>.",
      "ja": "[RFC6829]チェン、M.、パン、P.、Pignataro、C.、およびR. Asati、 \"擬似回線転送等価クラスのラベルスイッチパス（LSP）のPing（のFEC）IPv6の上にアドバタイズ\"、RFC 6829、DOI 10.17487 / RFC6829、2013年1月、<http://www.rfc-editor.org/info/rfc6829>。"
    },
    {
      "indent": 3,
      "text": "[RFC7537] Decraene, B., Akiya, N., Pignataro, C., Andersson, L., and S. Aldrin, \"IANA Registries for LSP Ping Code Points\", RFC 7537, DOI 10.17487/RFC7537, May 2015, <http://www.rfc-editor.org/info/rfc7537>.",
      "ja": "[RFC7537] Decraene、B.、秋谷、N.、Pignataro、C.、アンダーソン、L.、およびS.アルドリン、RFC 7537、DOI 10.17487は/ RFC7537、 \"IANAレジストリLSP Pingのコードポイントは、\" 2015年5月、< http://www.rfc-editor.org/info/rfc7537>。"
    },
    {
      "indent": 3,
      "text": "[RFC8012] Akiya, N., Swallow, G., Pignataro, C., Malis, A., and S. Aldrin, \"Label Switched Path (LSP) and Pseudowire (PW) Ping/Trace over MPLS Networks Using Entropy Labels (ELs)\", RFC 8012, DOI 10.17487/RFC8012, November 2016, <http://www.rfc-editor.org/info/rfc8012>.",
      "ja": "[RFC8012]秋谷、N.、ツバメ、G.、Pignataro、C.、Malis、A.、およびS.アルドリン、「ラベルスイッチパス（LSP）及び疑似回線（PW）のPing /エントロピーラベルを使用してMPLSネットワーク上でトレース（ ELS）」、RFC 8012、DOI 10.17487 / RFC8012、2016年11月、<http://www.rfc-editor.org/info/rfc8012>。"
    },
    {
      "indent": 3,
      "text": "[RFC8077] Martini, L., Ed., and G. Heron, Ed., \"Pseudowire Setup and Maintenance Using the Label Distribution Protocol (LDP)\", STD 84, RFC 8077, DOI 10.17487/RFC8077, February 2017, <http://www.rfc-editor.org/info/rfc8077>.",
      "ja": "[RFC8077]マティーニ、L.、エド。、およびG.サギ、エド。、 \"ラベル配布プロトコル（LDP）を使用して擬似回線の設定とメンテナンス\"、STD 84、RFC 8077、DOI 10.17487 / RFC8077、2017年2月、<HTTP ：//www.rfc-editor.org/info/rfc8077>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Deprecated TLVs and Sub-TLVs (Non-normative)",
      "ja": "付録A.非推奨のTLVとサブのTLV（非規範的）"
    },
    {
      "indent": 3,
      "text": "This appendix describes deprecated elements, which are non-normative for an implementation. They are included in this document for historical and informational purposes.",
      "ja": "この付録では、実装のための非規範的です非推奨の要素を、説明しています。彼らは歴史や情報提供の目的のために、この文書に含まれています。"
    },
    {
      "indent": 0,
      "text": "A.1. Target FEC Stack",
      "ja": "A.1。ターゲットFECスタック"
    },
    {
      "indent": 0,
      "text": "A.1.1. FEC 128 Pseudowire - IPv4 (Deprecated)",
      "ja": "A.1.1。 FEC 128疑似 -  IPv4の（非推奨）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [RFC4447], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed encapsulation type with the high-order bit set to zero. Both of these fields are treated in this protocol as opaque values.",
      "ja": "用語PW ID（疑似回線ID）とPWタイプ（疑似タイプ）であるとしてFEC 128（0x80の）は、[RFC4447]で定義されています。 PW IDは、非ゼロの32ビット接続IDです。 PWタイプのカプセル化タイプを示す15ビットの数です。ゼロ以下に設定し、上位ビットでカプセル化タイプと呼ばれる分野での右寄せ行われます。これらのフィールドの両方が不透明な値として、このプロトコルで処理されます。"
    },
    {
      "indent": 3,
      "text": "When a FEC 128 is encoded in a label stack, the following format is used. The Value field consists of the Remote PE IPv4 Address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128はラベルスタックに符号化される場合、以下の形式が使用されます。次のようにValueフィールドは、リモートPE IPv4アドレス（ターゲットLDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE IPv4 Address                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This FEC is deprecated and is retained only for backward compatibility. Implementations of LSP ping SHOULD accept and process this TLV, but SHOULD send LSP ping echo requests with the new TLV (see Section 3.2.9), unless explicitly configured to use the old TLV.",
      "ja": "このFECは非推奨となっており、下位互換性のためにのみ保持されます。 LSPピングの実装が受け入れ、このTLVを処理しますが、明示的に古いTLVを使用するように構成されていない限り、新しいTLV（セクション3.2.9を参照）とLSPピングエコー要求を送信するべきです。"
    },
    {
      "indent": 3,
      "text": "An LSR receiving this TLV SHOULD use the source IP address of the LSP echo request to infer the sender's PE address.",
      "ja": "このTLVを受けたLSRは、送信者のPEアドレスを推測するための要求をエコーLSPの送信元IPアドレスを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "A.2. Downstream Mapping (Deprecated)",
      "ja": "A.2。ダウンストリームマッピング（非推奨）"
    },
    {
      "indent": 3,
      "text": "The Downstream Mapping object is a TLV that MAY be included in an echo request message. Only one Downstream Mapping object may appear in an echo request. The presence of a Downstream Mapping object is a request that Downstream Mapping objects be included in the echo reply. If the replying router is the destination of the FEC, then a Downstream Mapping TLV SHOULD NOT be included in the echo reply.",
      "ja": "ダウンストリームマッピングオブジェクトは、エコー要求メッセージに含まれるかもしれTLVです。唯一のダウンストリームマッピングオブジェクトは、エコー要求に表示される場合があります。ダウンストリームマッピングオブジェクトの存在は下流マッピングオブジェクトがエコー応答に含まれる要求です。返答ルータがFECの宛先である場合には、川下のマッピングTLVは、エコー応答に含まれるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the replying router SHOULD include a Downstream Mapping object for each interface over which this FEC could be forwarded. For a more precise definition of the notion of \"downstream\", see Section 3.4.2, \"Downstream Router and Interface\".",
      "ja": "そうでなければ、応答ルータは、このFECを転送することができ、その上、各インターフェイスのダウンストリームマッピングオブジェクトを含むべきです。 「下流」の概念のより正確な定義については、セクション3.4.2、「ダウンストリームルータとインタフェース」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Length is K + M + 4*N octets, where M is the Multipath Length, and N is the number of downstream labels. Values for K are found in the description of Address Type below. The Value field of a Downstream Mapping has the following format:",
      "ja": "長さMはマルチパスの長さK + M + 4 * Nオクテットであり、そしてNは、下流のラベルの数です。 Kの値は、以下のアドレスタイプの記述に記載されています。ダウンストリームマッピングの値フィールドの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               MTU             | Address Type  |    DS Flags   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Downstream IP Address (4 or 16 octets)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Downstream Interface Address (4 or 16 octets)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Multipath Type| Depth Limit   |        Multipath Length       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                     (Multipath Information)                   .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Maximum Transmission Unit (MTU)",
      "ja": "最大転送単位（MTU）"
    },
    {
      "indent": 6,
      "text": "The MTU is the size in octets of the largest MPLS frame (including label stack) that fits on the interface to the downstream LSR.",
      "ja": "MTUは、下流のLSRへのインタフェースに収まる（ラベルスタックを含む）最大のMPLSフレームのオクテットサイズです。"
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the Downstream IP Address and Downstream Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "インターフェースは、番号または番号なしの場合はアドレスタイプを示します。また、ダウンストリームIPアドレスとダウンストリームインターフェイスフィールドの長さを決定します。 TLVの最初の部分のために得られた合計「Kオクテット」として以下の表に記載されています。アドレスタイプは、次のいずれかの値に設定されています："
    },
    {
      "indent": 7,
      "text": "Type #        Address Type           K Octets\n------        ------------           --------\n     1        IPv4 Numbered                16\n     2        IPv4 Unnumbered              16\n     3        IPv6 Numbered                40\n     4        IPv6 Unnumbered              28\n     5        Non IP                       12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DS Flags",
      "ja": "DSフラグ"
    },
    {
      "indent": 6,
      "text": "The DS Flags field is a bit vector with the following format:",
      "ja": "DSのFlagsフィールドは、次の形式のビットベクトルであります："
    },
    {
      "indent": 7,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| Rsvd(MBZ) |I|N|\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Two flags are defined currently, I and N. The remaining flags MUST be set to zero when sending and ignored on receipt.",
      "ja": "二つのフラグが現在定義され、IおよびN.残りのフラグは、送信時にゼロに設定して、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Flag  Name and Meaning\n----  ----------------\n   I  Interface and Label Stack Object Request",
      "raw": true
    },
    {
      "indent": 9,
      "text": "When this flag is set, it indicates that the replying\nrouter SHOULD include an Interface and Label Stack\nObject in the echo reply message.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "N Treat as a Non-IP Packet",
      "ja": "N非IPパケットとして扱います"
    },
    {
      "indent": 9,
      "text": "Echo request messages will be used to diagnose non-IP flows. However, these messages are carried in IP packets. For a router that alters its ECMP algorithm based on the FEC or deep packet examination, this flag requests that the router treat this as it would if the determination of an IP payload had failed.",
      "ja": "エコー要求メッセージは、非IPフローを診断するために使用されます。しかし、これらのメッセージは、IPパケットで運ばれます。 、FECまたはディープパケット検査に基づいてIPペイロードの決意が失敗した場合、ルータはそれと同じように、これを扱うこのフラグ要求をそのECMPアルゴリズムを変更ルータの。"
    },
    {
      "indent": 3,
      "text": "Downstream IP Address and Downstream Interface Address",
      "ja": "下流のIPアドレスと下流のインターフェイスアドレス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスが4つのオクテットで符号化されます。 IPv6アドレスは16個のオクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is numbered, then the Address Type MUST be set to IPv4 or IPv6, the Downstream IP Address MUST be set to either the downstream LSR's Router ID or the interface address of the downstream LSR, and the Downstream Interface Address MUST be set to the downstream LSR's interface address.",
      "ja": "下流のLSRへのインタフェースが番号付けされている場合は、アドレスタイプはIPv4またはIPv6に設定しなければならなくて、ダウンストリームIPアドレスは、ダウンストリームLSRのルータIDまたは下流のLSRのインターフェースアドレス、およびダウンストリームインターフェイスアドレスのどちらかに設定しなければなりません。下流のLSRのインターフェースアドレスに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is unnumbered, the Address Type MUST be IPv4 Unnumbered or IPv6 Unnumbered, the Downstream IP Address MUST be the downstream LSR's Router ID, and the Downstream Interface Address MUST be set to the index assigned by the upstream LSR to the interface.",
      "ja": "ダウンストリームLSRへのインターフェースに番号が付いていない場合、アドレスタイプは、IPv4アンナンバードまたはIPv6番号なしで、ダウンストリームIPアドレスは、下流LSRのルータIDでなければなりません、そしてダウンストリームインターフェイスアドレスは上流のLSRによって割り当てられたインデックスに設定しなければなりませんインタフェース。"
    },
    {
      "indent": 6,
      "text": "If an LSR does not know the IP address of its neighbor, then it MUST set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it must set the Downstream IP Address to 127.0.0.1; for IPv6, the address is set to 0::1. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with either of these addresses in the Downstream IP Address field, this indicates that it MUST bypass interface verification but continue with label validation.",
      "ja": "LSRがネイバーのIPアドレスを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定しなければなりません。 IPv4の場合、それは127.0.0.1へのダウンストリームIPアドレスを設定する必要があります。 IPv6のために、アドレスが0 :: 1に設定されています。 LSRは川下IP Addressフィールドに、これらのアドレスのいずれかでエコー要求パケットを受信した場合、両方のケースでは、インターフェイス・インデックスは、0に設定しなければならない、これはインタフェースの検証をバイパスするが、ラベルの検証を継続しなければならないことを示しています。"
    },
    {
      "indent": 6,
      "text": "If the originator of an echo request packet wishes to obtain Downstream Mapping information but does not know the expected label stack, then it SHOULD set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it MUST set the Downstream IP Address to 224.0.0.2; for IPv6, the address MUST be set to FF02::2. In both cases, the interface index MUST be set to 0. If an LSR receives an echo request packet with the all-routers multicast address, then this indicates that it MUST bypass both interface and label stack validation, but return Downstream Mapping TLVs using the information provided.",
      "ja": "エコー要求パケットの発信元は、ダウンストリームのマッピング情報を取得したいが、予想されるラベルスタックを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定する必要があります。 IPv4の場合、それは224.0.0.2へのダウンストリームIPアドレスを設定しなければなりません。 IPv6のために、アドレスがFF02 :: 2に設定しなければなりません。 LSRは、全ルータのマルチキャストアドレスを有するエコー要求パケットを受信した場合の両方の場合において、インターフェースインデックスが0に設定されなければならない、これは、それが両方のインターフェースとラベルスタックの検証をバイパスするが、ダウンストリームマッピングのTLVを使用して返さなければならないことを示しています情報提供。"
    },
    {
      "indent": 3,
      "text": "Multipath Type",
      "ja": "マルチタイプ"
    },
    {
      "indent": 6,
      "text": "The following Multipath Types are defined:",
      "ja": "以下のマルチパスの種類が定義されています。"
    },
    {
      "indent": 6,
      "text": "Key   Type                  Multipath Information\n---   ----------------      ---------------------\n 0    no multipath          Empty (Multipath Length = 0)\n 2    IP address            IP addresses\n 4    IP address range      low/high address pairs\n 8    Bit-masked IP         IP address prefix and bit mask\n        address set\n 9    Bit-masked label set  Label prefix and bit mask",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 0 indicates that all packets will be forwarded out this one interface.",
      "ja": "タイプ0は、すべてのパケットはこの1つのインターフェイスから転送されることを示します。"
    },
    {
      "indent": 6,
      "text": "Types 2, 4, 8, and 9 specify that the supplied Multipath Information will serve to exercise this path.",
      "ja": "タイプ2、4、8、および9は、供給マルチパスの情報は、このパスを行使するのに役立つであろうことを指定します。"
    },
    {
      "indent": 3,
      "text": "Depth Limit",
      "ja": "深さの制限"
    },
    {
      "indent": 6,
      "text": "The Depth Limit is applicable only to a label stack and is the maximum number of labels considered in the hash; this SHOULD be set to zero if unspecified or unlimited.",
      "ja": "深さ制限はラベルスタックに適用可能であり、ハッシュで考慮ラベルの最大数です。未指定または無制限の場合、これはゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Multipath Length",
      "ja": "マルチパスの長さ"
    },
    {
      "indent": 6,
      "text": "The length in octets of the Multipath Information.",
      "ja": "マルチパス情報のオクテットの長さ。"
    },
    {
      "indent": 3,
      "text": "Multipath Information",
      "ja": "マルチインフォメーション"
    },
    {
      "indent": 6,
      "text": "Address or label values encoded according to the Multipath Type. See Section 3.4.1.1.1 for encoding details.",
      "ja": "マルチパスの種類に応じてエンコードされたアドレスまたはラベルの値。エンコードの詳細については、セクション3.4.1.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Downstream Label(s)",
      "ja": "下流ラベル（S）"
    },
    {
      "indent": 6,
      "text": "The set of labels in the label stack as it would have appeared if this router were forwarding the packet through this interface. Any Implicit Null labels are explicitly included. Labels are treated as numbers, i.e., they are right justified in the field.",
      "ja": "このルータは、このインターフェイスを介してパケットを転送した場合、それは登場していたとして、ラベルスタックのラベルのセット。暗黙的ヌルラベルは、明示的に含まれています。ラベルはつまり、彼らはフィールドで右詰めされ、数値として扱われます。"
    },
    {
      "indent": 6,
      "text": "A downstream label is 24 bits, in the same format as an MPLS label minus the TTL field, i.e., the MSBit of the label is bit 0, the LSBit is bit 19, the TC bits are bits 20-22, and bit 23 is the S bit. The replying router SHOULD fill in the TC and S bits; the LSR receiving the echo reply MAY choose to ignore these bits.",
      "ja": "下流ラベルがMPLSラベルマイナスTTLフィールドと同じ形式で、すなわち、ラベルのMSBitからビット0であり、最下位ビットはビット19であり、24ビットであり、TCビットは、ビット20〜22であり、23ビットでありますSビット。返答ルータはTCとSビットを記入すべきです。エコー応答を受信LSRはこれらのビットを無視することを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Protocol",
      "ja": "プロトコル"
    },
    {
      "indent": 6,
      "text": "The protocol is taken from the following table:",
      "ja": "プロトコルは、以下の表から取られます。"
    },
    {
      "indent": 6,
      "text": "Protocol #        Signaling Protocol\n----------        ------------------\n         0        Unknown\n         1        Static\n         2        BGP\n         3        LDP\n         4        RSVP-TE",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The original acknowledgements from RFC 4379 state the following:",
      "ja": "RFC 4379の状態から元の謝辞以下："
    },
    {
      "indent": 6,
      "text": "This document is the outcome of many discussions among many people, including Manoj Leelanivas, Paul Traina, Yakov Rekhter, Der-Hwa Gan, Brook Bailey, Eric Rosen, Ina Minei, Shivani Aggarwal, and Vanson Lim.",
      "ja": "この文書では、ManojさんLeelanivas、ポールTrainaの、ヤコフ・レックター、デア・ファガン、ブルック・ベイリー、エリック・ローゼン、伊那Minei、シヴァーニアガルワル、およびバンソン・リムを含む多くの人々の間で多くの議論の結果です。"
    },
    {
      "indent": 6,
      "text": "The description of the Multipath Information sub-field of the Downstream Mapping TLV was adapted from text suggested by Curtis Villamizar.",
      "ja": "ダウンストリームマッピングTLVのマルチパス情報サブフィールドの説明は、カーティスVillamizarによって提案されたテキストから適応されました。"
    },
    {
      "indent": 3,
      "text": "We would like to thank Loa Andersson for motivating the advancement of this specification.",
      "ja": "私たちは、この仕様の前進を動機づけるためロア・アンダーソンに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "We also would like to thank Alexander Vainshtein, Yimin Shen, Curtis Villamizar, David Allan, Vincent Roca, Mirja Kuhlewind, and Elwyn Davies for their review and useful comments.",
      "ja": "我々はまた、彼らのレビューと有益なコメントをアレクサンダーVainshtein、義民シェン、カーティスVillamizar、デビッド・アラン、ヴィンセントロカ、Mirja Kuhlewind、とエルウィン・デイヴィスに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "A mechanism used to detect data-plane failures in MPLS LSPs was originally published as RFC 4379 in February 2006. It was produced by the MPLS Working Group of the IETF and was jointly authored by Kireeti Kompella and George Swallow.",
      "ja": "MPLS LSPの中のデータプレーンの障害を検出するのに使用されるメカニズムは、もともと2006年2月にRFC 4379として発行された。これは、IETFのMPLSワーキンググループによって作成されたと共同でKireeti Kompellaとジョージツバメによって作成されました。"
    },
    {
      "indent": 3,
      "text": "The following made vital contributions to all aspects of the original RFC 4379, and much of the material came out of debate and discussion among this group.",
      "ja": "以下は、オリジナルのRFC 4379のすべての面に重要な貢献をした、と材料の多くは、このグループ間の議論から出てきました。"
    },
    {
      "indent": 6,
      "text": "Ronald P. Bonica, Juniper Networks, Inc. Dave Cooper, Global Crossing Ping Pan, Hammerhead Systems Nischal Sheth, Juniper Networks, Inc. Sanjay Wadhwa, Juniper Networks, Inc.",
      "ja": "ロナルドP. Bonica、ジュニパーネットワークス社デイブ・クーパー、グローバル・クロッシングのPingパン、ハンマーシステムズNischal Sheth、ジュニパーネットワークス社のSanjay Wadhwa、ジュニパーネットワークス株式会社"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Kireeti Kompella Juniper Networks, Inc.",
      "ja": "Kireeti Kompellaジュニパーネットワークス株式会社"
    },
    {
      "indent": 3,
      "text": "Email: kireeti.kompella@gmail.com",
      "ja": "メール：kireeti.kompella@gmail.com"
    },
    {
      "indent": 3,
      "text": "George Swallow Cisco Systems, Inc.",
      "ja": "ジョージツバメシスコシステムズ株式会社"
    },
    {
      "indent": 3,
      "text": "Email: swallow.ietf@gmail.com",
      "ja": "メール：swallow.ietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Carlos Pignataro (editor) Cisco Systems, Inc.",
      "ja": "カルロスPignataro（エディタ）は、シスコシステムズ、株式会社"
    },
    {
      "indent": 3,
      "text": "Email: cpignata@cisco.com",
      "ja": "メール：cpignata@cisco.com"
    },
    {
      "indent": 3,
      "text": "Nagendra Kumar Cisco Systems, Inc.",
      "ja": "Nagendra Kumar氏シスコシステムズ株式会社"
    },
    {
      "indent": 3,
      "text": "Email: naikumar@cisco.com",
      "ja": "メール：naikumar@cisco.com"
    },
    {
      "indent": 3,
      "text": "Sam Aldrin Google",
      "ja": "サム・オルドリングーグル"
    },
    {
      "indent": 3,
      "text": "Email: aldrin.ietf@gmail.com",
      "ja": "メール：aldrin.ietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Mach(Guoyi) Chen Huawei",
      "ja": "マッハ（GU O a）のチェンHU Aがあります"
    },
    {
      "indent": 3,
      "text": "Email: mach.chen@huawei.com",
      "ja": "メール：mach.chen@huawei.com"
    }
  ]
}