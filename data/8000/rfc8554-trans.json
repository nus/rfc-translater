{
  "title": {
    "text": "RFC 8554 - Leighton-Micali Hash-Based Signatures",
    "ja": "RFC 8554 - レイトン-Micaliのハッシュベースの署名"
  },
  "number": 8554,
  "created_at": "2019-10-30 02:18:12.679524+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                            D. McGrew\nRequest for Comments: 8554                                     M. Curcio\nCategory: Informational                                       S. Fluhrer\nISSN: 2070-1721                                            Cisco Systems\n                                                              April 2019",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Leighton-Micali Hash-Based Signatures",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This note describes a digital-signature system based on cryptographic hash functions, following the seminal work in this area of Lamport, Diffie, Winternitz, and Merkle, as adapted by Leighton and Micali in 1995. It specifies a one-time signature scheme and a general signature scheme. These systems provide asymmetric authentication without using large integer mathematics and can achieve a high security level. They are suitable for compact implementations, are relatively simple to implement, and are naturally resistant to side-channel attacks. Unlike many other signature systems, hash-based signatures would still be secure even if it proves feasible for an attacker to build a quantum computer.",
      "ja": "1995年にレイトンとMicaliによって適合このノートはランポート、ディフィー、Winternitz、及びマークルのこの分野における独創的な研究以下の暗号ハッシュ関数に基づいて、デジタル署名システムを記載し、これは、ワンタイム署名方式と指定します一般的な署名方式。これらのシステムは、大きな整数の数学を使用せずに、非対称認証を提供し、高いセキュリティレベルを達成することができます。彼らは、コンパクトな実装に適して実装するのが比較的簡単であり、サイドチャネル攻撃に対して自然に耐性です。攻撃者は、量子コンピュータを構築するために他の多くの署名システムとは異なり、ハッシュベースのシグネチャはまだそれが実現可能なことを証明しても、セキュアになります。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF. This has been reviewed by many researchers, both in the research group and outside of it. The Acknowledgements section lists many of them.",
      "ja": "この文書では、IRTFで暗号フォーラム研究グループ（CFRG）の製品です。これは、研究グループでは、それの内外、多くの研究者によって検討されています。謝辞セクションは、それらの多くを示しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の暗号化フォーラム研究グループのコンセンサスを表しています。 IRSGによって公表のために承認された文書はインターネットStandardのどんなレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8554.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8554で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2019 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  CFRG Note on Post-Quantum Cryptography  . . . . . . . . .   5\n  1.2.  Intellectual Property . . . . . . . . . . . . . . . . . .   6\n    1.2.1.  Disclaimer  . . . . . . . . . . . . . . . . . . . . .   6\n  1.3.  Conventions Used in This Document . . . . . . . . . . . .   6\n2.  Interface . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n3.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.1.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .   7\n    3.1.1.  Operators . . . . . . . . . . . . . . . . . . . . . .   7\n    3.1.2.  Functions . . . . . . . . . . . . . . . . . . . . . .   8\n    3.1.3.  Strings of w-Bit Elements . . . . . . . . . . . . . .   8\n  3.2.  Typecodes . . . . . . . . . . . . . . . . . . . . . . . .   9\n  3.3.  Notation and Formats  . . . . . . . . . . . . . . . . . .   9\n4.  LM-OTS One-Time Signatures  . . . . . . . . . . . . . . . . .  12\n  4.1.  Parameters  . . . . . . . . . . . . . . . . . . . . . . .  13\n  4.2.  Private Key . . . . . . . . . . . . . . . . . . . . . . .  14\n  4.3.  Public Key  . . . . . . . . . . . . . . . . . . . . . . .  15\n  4.4.  Checksum  . . . . . . . . . . . . . . . . . . . . . . . .  15\n  4.5.  Signature Generation  . . . . . . . . . . . . . . . . . .  16\n  4.6.  Signature Verification  . . . . . . . . . . . . . . . . .  17\n5.  Leighton-Micali Signatures  . . . . . . . . . . . . . . . . .  19\n  5.1.  Parameters  . . . . . . . . . . . . . . . . . . . . . . .  19\n  5.2.  LMS Private Key . . . . . . . . . . . . . . . . . . . . .  20\n  5.3.  LMS Public Key  . . . . . . . . . . . . . . . . . . . . .  21\n  5.4.  LMS Signature . . . . . . . . . . . . . . . . . . . . . .  22\n    5.4.1.  LMS Signature Generation  . . . . . . . . . . . . . .  23\n    5.4.2.  LMS Signature Verification  . . . . . . . . . . . . .  24\n6.  Hierarchical Signatures . . . . . . . . . . . . . . . . . . .  26\n  6.1.  Key Generation  . . . . . . . . . . . . . . . . . . . . .  29\n  6.2.  Signature Generation  . . . . . . . . . . . . . . . . . .  30\n  6.3.  Signature Verification  . . . . . . . . . . . . . . . . .  32\n  6.4.  Parameter Set Recommendations . . . . . . . . . . . . . .  32\n7.  Rationale . . . . . . . . . . . . . . . . . . . . . . . . . .  34\n  7.1.  Security String . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  36\n9.  Security Considerations . . . . . . . . . . . . . . . . . . .  38\n  9.1.  Hash Formats  . . . . . . . . . . . . . . . . . . . . . .  39\n  9.2.  Stateful Signature Algorithm  . . . . . . . . . . . . . .  40\n  9.3.  Security of LM-OTS Checksum . . . . . . . . . . . . . . .  41\n10. Comparison with Other Work  . . . . . . . . . . . . . . . . .  42\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  43\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  43\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  43\nAppendix A.  Pseudorandom Key Generation  . . . . . . . . . . . .  45\nAppendix B.  LM-OTS Parameter Options . . . . . . . . . . . . . .  45\nAppendix C.  An Iterative Algorithm for Computing an LMS Public\n             Key  . . . . . . . . . . . . . . . . . . . . . . . .  47\nAppendix D.  Method for Deriving Authentication Path for a\n             Signature  . . . . . . . . . . . . . . . . . . . . .  48\nAppendix E.  Example Implementation . . . . . . . . . . . . . . .  49\nAppendix F.  Test Cases . . . . . . . . . . . . . . . . . . . . .  49\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  60\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  61",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "One-time signature systems, and general-purpose signature systems built out of one-time signature systems, have been known since 1979 [Merkle79], were well studied in the 1990s [USPTO5432852], and have benefited from renewed attention in the last decade. The characteristics of these signature systems are small private and public keys and fast signature generation and verification, but large signatures and moderately slow key generation (in comparison with RSA and ECDSA (Elliptic Curve Digital Signature Algorithm)). Private keys can be made very small by appropriate key generation, for example, as described in Appendix A. In recent years, there has been interest in these systems because of their post-quantum security and their suitability for compact verifier implementations.",
      "ja": "ワンタイム署名システム、およびワンタイム署名システムの外に構築された汎用的な署名システム、1979年以来知られている[Merkle79]、よく1990年代[USPTO5432852]で研究し、10年間で再び注目の恩恵を受けています。これらの署名システムの特徴は、（RSAおよびECDSA（楕円曲線デジタル署名アルゴリズム）と比較して）小さな秘密鍵と公開鍵と高速署名生成と検証されているが、大きな署名と適度に遅い鍵生成。近年では、付録Aで説明したようにプライベートキーは、例えば、適切なキーの生成によって非常に小さくすることができ、それらのポスト量子セキュリティとコンパクトな検証の実装のための適性のこれらのシステムに関心がありました。"
    },
    {
      "indent": 3,
      "text": "This note describes the Leighton and Micali adaptation [USPTO5432852] of the original Lamport-Diffie-Winternitz-Merkle one-time signature system [Merkle79] [C:Merkle87] [C:Merkle89a] [C:Merkle89b] and general signature system [Merkle79] with enough specificity to ensure interoperability between implementations.",
      "ja": "[C：Merkle89a] [C：Merkle89b]および一般署名システム[Merkle79：このメモは、[USPTO5432852】オリジナルランポート-のDiffie-Winternitz-マークルワンタイム署名方式[Merkle79] [Merkle87 C]のレイトンとMicali適応を説明します]実装間の相互運用性を確保するのに十分な特異性を有します。"
    },
    {
      "indent": 3,
      "text": "A signature system provides asymmetric message authentication. The key-generation algorithm produces a public/private key pair. A message is signed by a private key, producing a signature, and a message/signature pair can be verified by a public key. A One-Time Signature (OTS) system can be used to sign one message securely but will become insecure if more than one is signed with the same public/ private key pair. An N-time signature system can be used to sign N or fewer messages securely. A Merkle-tree signature scheme is an N-time signature system that uses an OTS system as a component.",
      "ja": "署名システムは、非対称メッセージ認証を提供します。鍵生成アルゴリズムは、公開鍵/秘密鍵のペアを生成します。メッセージが署名を生成し、秘密鍵によって署名され、およびメッセージ/署名ペアは、公開鍵によって検証することができます。ワンタイム署名（OTS）システムが確実つのメッセージに署名するために使用することができるが、2つ以上が同一の公開/秘密鍵ペアで署名された場合に安全ではないとなるであろう。 N-拍子システムが確実N個以下のメッセージに署名するために使用することができます。マークル木署名方式は、成分としてOTSシステムを使用してN-タイム署名方式です。"
    },
    {
      "indent": 3,
      "text": "In the Merkle scheme, a binary tree of height h is used to hold 2^h OTS key pairs. Each interior node of the tree holds a value that is the hash of the values of its two child nodes. The public key of the tree is the value of the root node (a recursive hash of the OTS public keys), while the private key of the tree is the collection of all the OTS private keys, together with the index of the next OTS private key to sign the next message with.",
      "ja": "マークル方式では、高さhのバイナリツリーは2 ^ H OTS鍵ペアを保持するために使用されます。ツリーの各内部ノードは、2つのつの子ノードの値のハッシュ値を保持します。木の秘密鍵は、次のOTS民間のインデックスと一緒に、すべてのOTSのプライベートキーのコレクションである一方、木の公開鍵は、ルートノード（OTS公開鍵の再帰的ハッシュ）の値であり、と次のメッセージに署名するための鍵。"
    },
    {
      "indent": 3,
      "text": "In this note, we describe the Leighton-Micali Signature (LMS) system (a variant of the Merkle scheme) with the Hierarchical Signature System (HSS) built on top of it that allows it to efficiently scale to larger numbers of signatures. In order to support signing a large number of messages on resource-constrained systems, the Merkle tree can be subdivided into a number of smaller trees. Only the bottommost tree is used to sign messages, while trees above that are used to sign the public keys of their children. For example, in the simplest case with two levels with both levels consisting of height h trees, the root tree is used to sign 2^h trees with 2^h OTS key pairs, and each second-level tree has 2^h OTS key pairs, for a total of 2^(2h) bottom-level key pairs, and so can sign 2^(2h) messages. The advantage of this scheme is that only the active trees need to be instantiated, which saves both time (for key generation) and space (for key storage). On the other hand, using a multilevel signature scheme increases the size of the signature as well as the signature verification time.",
      "ja": "このノートでは、我々はそれが効率的に署名の大きな数に拡張することができ、それの上に構築された階層署名システム（HSS）とレイトン-Micali署名（LMS）システム（マークル方式の変異体）を記載しています。リソース制約システム上の多数のメッセージに署名サポートするために、マークル木は、小さな木の数に細分することができます。それ以上の木は子供たちの公開鍵に署名するために使用されている間のみ、一番下のツリーは、メッセージに署名するために使用されます。例えば、高さhの木からなる両方のレベルを有する2つのレベルを有する最も簡単な場合には、ルートツリーは2 ^ H OTS鍵ペアと2 ^ Hツリーを署名するために使用され、各第二レベルのツリーは2 ^ H OTSキーを有しています2 ^（2H）ボトムレベル鍵ペアの合計対、及びSO 2 ^（2H）メッセージに署名することができます。この方式の利点は、アクティブ木（鍵生成のための）時間及び（鍵保管のための）スペースの両方を節約する、インスタンス化される必要があることです。一方、多値署名方式を使用して、署名のサイズ、並びに署名検証時間を増加させます。"
    },
    {
      "indent": 3,
      "text": "This note is structured as follows. Notes on post-quantum cryptography are discussed in Section 1.1. Intellectual property issues are discussed in Section 1.2. The notation used within this note is defined in Section 3, and the public formats are described in Section 3.3. The Leighton-Micali One-Time Signature (LM-OTS) system is described in Section 4, and the LMS and HSS N-time signature systems are described in Sections 5 and 6, respectively. Sufficient detail is provided to ensure interoperability. The rationale for the design decisions is given in Section 7. The IANA registry for these signature systems is described in Section 8. Security considerations are presented in Section 9. Comparison with another hash-based signature algorithm (eXtended Merkle Signature Scheme (XMSS)) is in Section 10.",
      "ja": "次のようにこのノートは構成されています。ポスト量子暗号の注意事項は、第1.1項で説明されています。知的財産権の問題は、1.2節で議論されています。このノート内で使用される表記法は、セクション3で定義され、公共のフォーマットはセクション3.3に記載されています。レイトン-Micaliワンタイム署名（LM-OTS）システムは、第4、及びLMSに記載されており、HSS N-拍子システムはそれぞれ、セクション5及び6に記載されています。十分な詳細は、相互運用性を確保するために設けられています。設計上の決定の根拠は、セクション7に与えられているこれらの署名システムのためのIANAレジストリは、セクション内の別のハッシュベースの署名アルゴリズムと9の比較を提示している節8.セキュリティの考慮事項に記述されている（拡張マークル署名方式（XMSS））セクション10です。"
    },
    {
      "indent": 3,
      "text": "This document represents the rough consensus of the CFRG.",
      "ja": "この文書では、CFRGのラフコンセンサスを表しています。"
    },
    {
      "indent": 0,
      "text": "1.1. CFRG Note on Post-Quantum Cryptography",
      "section_title": true,
      "ja": "1.1。ポスト量子暗号のCFRG注意"
    },
    {
      "indent": 3,
      "text": "All post-quantum algorithms documented by the Crypto Forum Research Group (CFRG) are today considered ready for experimentation and further engineering development (e.g., to establish the impact of performance and sizes on IETF protocols). However, at the time of writing, we do not have significant deployment experience with such algorithms.",
      "ja": "暗号フォーラム研究グループ（CFRG）によって文書のすべてのポスト量子アルゴリズムが今日ある（例えば、IETFプロトコルのパフォーマンスとサイズの影響を確立するために）実験やさらなる技術開発のための準備を検討しました。しかし、執筆の時点で、我々はそのようなアルゴリズムと有意な展開の経験を持っていません。"
    },
    {
      "indent": 3,
      "text": "Many of these algorithms come with specific restrictions, e.g., change of classical interface or less cryptanalysis of proposed parameters than established schemes. The CFRG has consensus that all documents describing post-quantum technologies include the above paragraph and a clear additional warning about any specific restrictions, especially as those might affect use or deployment of the specific scheme. That guidance may be changed over time via document updates.",
      "ja": "これらのアルゴリズムの多くは、特定の制限、古典的なインターフェイスまたは確立の方式より提案されたパラメータの少ない暗号解読の、例えば、変化してきます。 CFRGは、ポスト量子技術を記述するすべての文書は、それらが特定のスキームの使用または展開に影響を与える可能性がある、特にとして、上の段落および任意の特定の制限について明確な追加の警告が含まれていることを合意しています。そのガイダンスは、ドキュメントの更新を経て時間をかけて変更することができます。"
    },
    {
      "indent": 3,
      "text": "Additionally, for LMS:",
      "ja": "また、LMSのために："
    },
    {
      "indent": 3,
      "text": "CFRG consensus is that we are confident in the cryptographic security of the signature schemes described in this document against quantum computers, given the current state of the research community's knowledge about quantum algorithms. Indeed, we are confident that the security of a significant part of the Internet could be made dependent on the signature schemes defined in this document, if developers take care of the following.",
      "ja": "CFRGコンセンサスは、我々は、量子アルゴリズムに関する研究コミュニティの知識の現在の状態を考えると、量子コンピュータに対してこの文書で説明した署名方式の暗号化セキュリティに自信を持っているということです。確かに、我々は、開発者は、次のの世話をする場合は、インターネットの重要な部分のセキュリティは、この文書で定義された署名方式に依存させることができると確信しています。"
    },
    {
      "indent": 3,
      "text": "In contrast to traditional signature schemes, the signature schemes described in this document are stateful, meaning the secret key changes over time. If a secret key state is used twice, no cryptographic security guarantees remain. In consequence, it becomes feasible to forge a signature on a new message. This is a new property that most developers will not be familiar with and requires careful handling of secret keys. Developers should not use the schemes described here except in systems that prevent the reuse of secret key states.",
      "ja": "伝統的な署名方式とは対照的に、このドキュメントで説明する署名方式は、時間をかけて、秘密鍵の変更を意味し、ステートフルです。秘密キーの状態が2回使用されている場合、暗号化セキュリティの保証が残っていません。その結果、それが新しいメッセージに署名を偽造することが可能となります。これは、ほとんどの開発者が精通していないだろう新しいプロパティであり、秘密鍵の慎重な取り扱いが必要です。開発者は、秘密鍵の状態の再利用を防止するためのシステムを除き、ここで説明するスキームを使用するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note that the fact that the schemes described in this document are stateful also implies that classical APIs for digital signatures cannot be used without modification. The API MUST be able to handle a dynamic secret key state; that is, the API MUST allow the signature-generation algorithm to update the secret key state.",
      "ja": "この文書に記載さスキームは、ステートフルであるという事実は、デジタル署名のための古典的なAPIをそのまま使用することができないことを意味することに留意されたいです。 APIは、動的な秘密鍵の状態を扱うことができなければなりません。つまり、APIは、署名生成アルゴリズムは、秘密鍵の状態を更新するために許容しなければなりません。"
    },
    {
      "indent": 0,
      "text": "1.2. Intellectual Property",
      "section_title": true,
      "ja": "1.2。知的財産"
    },
    {
      "indent": 3,
      "text": "This document is based on U.S. Patent 5,432,852, which was issued over twenty years ago and is thus expired.",
      "ja": "この文書は、20年以上前に発行されたため、有効期限が切れている、米国特許5432852、に基づいています。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Disclaimer",
      "section_title": true,
      "ja": "1.2.1。免責条項"
    },
    {
      "indent": 3,
      "text": "This document is not intended as legal advice. Readers are advised to consult with their own legal advisers if they would like a legal interpretation of their rights.",
      "ja": "この文書は、法的助言として意図されていません。読者は、彼らが自分たちの権利の法的解釈を希望の場合は、独自の法律顧問に相談することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The IETF policies and processes regarding intellectual property and patents are outlined in [RFC8179] and at <https://datatracker.ietf.org/ipr/about>.",
      "ja": "知的財産や特許に関するIETFポリシーとプロセスは、[RFC8179]にし、<https://datatracker.ietf.org/ipr/about>で概説されています。"
    },
    {
      "indent": 0,
      "text": "1.3. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.3。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2. Interface",
      "section_title": true,
      "ja": "2.インタフェース"
    },
    {
      "indent": 3,
      "text": "The LMS signing algorithm is stateful; it modifies and updates the private key as a side effect of generating a signature. Once a particular value of the private key is used to sign one message, it MUST NOT be used to sign another.",
      "ja": "LMSの署名アルゴリズムは、ステートフルです。それは修正および署名を生成するの副作用として秘密鍵を更新します。秘密鍵の特定の値は、1つのメッセージに署名するために使用されると、別の署名に使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "The key-generation algorithm takes as input an indication of the parameters for the signature system. If it is successful, it returns both a private key and a public key. Otherwise, it returns an indication of failure.",
      "ja": "鍵生成アルゴリズムは、入力として、署名システムのパラメータの表示を取ります。それが成功すれば、それは秘密鍵と公開鍵の両方を返します。それ以外の場合は、失敗の表示を返します。"
    },
    {
      "indent": 3,
      "text": "The signing algorithm takes as input the message to be signed and the current value of the private key. If successful, it returns a signature and the next value of the private key, if there is such a value. After the private key of an N-time signature system has signed N messages, the signing algorithm returns the signature and an indication that there is no next value of the private key that can be used for signing. If unsuccessful, it returns an indication of failure.",
      "ja": "署名アルゴリズムは、入力として、署名されるべきメッセージと秘密鍵の現在の値をとります。成功した場合には、そのような値がある場合、それは、署名とプライベートキーの次の値を返します。 Nタイム署名方式の秘密鍵は、Nメッセージに署名した後、署名アルゴリズムは、署名と署名のために使用することができる秘密鍵のない次の値が存在しないという指示を返します。失敗した場合、それは失敗の表示を返します。"
    },
    {
      "indent": 3,
      "text": "The verification algorithm takes as input the public key, a message, and a signature; it returns an indication of whether or not the signature-and-message pair is valid.",
      "ja": "検証アルゴリズムは、入力として公開鍵と、メッセージと、署名を取ります。それは署名とメッセージのペアが有効であるか否かの指示を返します。"
    },
    {
      "indent": 3,
      "text": "A message/signature pair is valid if the signature was returned by the signing algorithm upon input of the message and the private key corresponding to the public key; otherwise, the signature and message pair is not valid with probability very close to one.",
      "ja": "署名は、メッセージおよび公開鍵に対応する秘密鍵の入力時に署名アルゴリズムによって返された場合、メッセージ/署名ペアが有効です。そうでない場合、署名とメッセージペアは1に非常に近い確率で有効ではありません。"
    },
    {
      "indent": 0,
      "text": "3. Notation",
      "section_title": true,
      "ja": "3.表記"
    },
    {
      "indent": 0,
      "text": "3.1. Data Types",
      "section_title": true,
      "ja": "3.1。データの種類"
    },
    {
      "indent": 3,
      "text": "Bytes and byte strings are the fundamental data types. A single byte is denoted as a pair of hexadecimal digits with a leading \"0x\". A byte string is an ordered sequence of zero or more bytes and is denoted as an ordered sequence of hexadecimal characters with a leading \"0x\". For example, 0xe534f0 is a byte string with a length of three. An array of byte strings is an ordered set, indexed starting at zero, in which all strings have the same length.",
      "ja": "バイト、バイト文字列は、基本的なデータ型です。単一バイトは先頭の「0x」で16進数の対として示されます。バイト列は、ゼロ以上のバイトの順序付きシーケンスであり、先頭の「0x」で進文字の順序付きシーケンスとして示されます。たとえば、3つの長さのバイト列は0xe534f0です。バイト文字列の配列が順序付けられた集合であり、すべての文字列が同じ長さを有している、ゼロから始まるインデックスが付け。"
    },
    {
      "indent": 3,
      "text": "Unsigned integers are converted into byte strings by representing them in network byte order. To make the number of bytes in the representation explicit, we define the functions u8str(X), u16str(X), and u32str(X), which take a nonnegative integer X as input and return one-, two-, and four-byte strings, respectively. We also make use of the function strTou32(S), which takes a four-byte string S as input and returns a nonnegative integer; the identity u32str(strTou32(S)) = S holds for any four-byte string S.",
      "ja": "符号なし整数はネットワークバイトオーダーでそれらを表現することにより、バイト文字列に変換されます。明示的な表現のバイト数を作るために、我々はu8str（X）、u16str（X）、及びu32str（X）、入力として非負整数Xを取り、ワン戻り、二、及び四関数を定義しますバイト文字列、それぞれ。我々はまた、入力として4バイトのストリングSを受け取り、非負整数を返す関数strTou32（S）を利用します。アイデンティティu32str（strTou32（S））= Sは、任意の4バイトの文字列S.当てはまります"
    },
    {
      "indent": 0,
      "text": "3.1.1. Operators",
      "section_title": true,
      "ja": "3.1.1。演算子"
    },
    {
      "indent": 3,
      "text": "When a and b are real numbers, mathematical operators are defined as follows:",
      "ja": "a、bは実数である場合には、以下のように、数学的な演算子が定義されています。"
    },
    {
      "indent": 6,
      "text": "^ : a ^ b denotes the result of a raised to the power of b",
      "ja": "^：A ^ Bは、B乗の結果を示し、"
    },
    {
      "indent": 6,
      "text": "* : a * b denotes the product of a multiplied by b",
      "ja": "*：* bはBを掛けたの積を表し、"
    },
    {
      "indent": 6,
      "text": "/ : a / b denotes the quotient of a divided by b",
      "ja": "/ A / Bは、Bで割った商を示し"
    },
    {
      "indent": 6,
      "text": "% : a % b denotes the remainder of the integer division of a by b (with a and b being restricted to integers in this case)",
      "ja": "％：％Bは、（ここでは整数に制限されるとBとの）Bによっての整数除算の余りを表します"
    },
    {
      "indent": 6,
      "text": "+ : a + b denotes the sum of a and b",
      "ja": "+：A + bはaとbの合計を表し、"
    },
    {
      "indent": 6,
      "text": "- : a - b denotes the difference of a and b",
      "ja": " - ： -  bがaとbの差を示し"
    },
    {
      "indent": 6,
      "text": "AND : a AND b denotes the bitwise AND of the two nonnegative integers a and b (represented in binary notation)",
      "ja": "AND：AおよびBはビット単位を示し、（2進数で表される）は、2つの非負整数a、bの"
    },
    {
      "indent": 3,
      "text": "The standard order of operations is used when evaluating arithmetic expressions.",
      "ja": "算術式を評価する際の動作の標準的な順序が使用されます。"
    },
    {
      "indent": 3,
      "text": "When B is a byte and i is an integer, then B >> i denotes the logical right-shift operation by i bit positions. Similarly, B << i denotes the logical left-shift operation.",
      "ja": "Bはバイトであり、iは整数であるとき、Bは>> iはビット位置によって論理右シフト演算を表します。同様に、Bは<< iが論理左シフト演算を表します。"
    },
    {
      "indent": 3,
      "text": "If S and T are byte strings, then S || T denotes the concatenation of S and T. If S and T are equal-length byte strings, then S AND T denotes the bitwise logical and operation.",
      "ja": "SおよびTは、バイト文字列、Sであれば|| SおよびTは、等しい長さのバイト列は、Sであり、Tは論理AND演算ビット単位を表す場合、TはSとTの連結を意味します。"
    },
    {
      "indent": 3,
      "text": "The i-th element in an array A is denoted as A[i].",
      "ja": "アレイA内のi番目の要素は、[I]と表記します。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Functions",
      "section_title": true,
      "ja": "3.1.2。機能"
    },
    {
      "indent": 3,
      "text": "If r is a nonnegative real number, then we define the following functions:",
      "ja": "rは非負実数であるならば、我々は次の関数を定義します。"
    },
    {
      "indent": 6,
      "text": "ceil(r) : returns the smallest integer greater than or equal to r",
      "ja": "CEIL（r）は：より大きいまたはrに等しい最小の整数を返します"
    },
    {
      "indent": 6,
      "text": "floor(r) : returns the largest integer less than or equal to r",
      "ja": "フロアー（r）は：未満またはrに等しい最大の整数を返します"
    },
    {
      "indent": 6,
      "text": "lg(r) : returns the base-2 logarithm of r",
      "ja": "LG（R）：Rの2を底とする対数を返します"
    },
    {
      "indent": 0,
      "text": "3.1.3. Strings of w-Bit Elements",
      "section_title": true,
      "ja": "3.1.3。 Wビット要素の文字列"
    },
    {
      "indent": 3,
      "text": "If S is a byte string, then byte(S, i) denotes its i-th byte, where the index starts at 0 at the left. Hence, byte(S, 0) is the leftmost byte of S, byte(S, 1) is the second byte from the left, and (assuming S is n bytes long) byte(S, n-1) is the rightmost byte of S. In addition, bytes(S, i, j) denotes the range of bytes from the i-th to the j-th byte, inclusive. For example, if S = 0x02040608, then byte(S, 0) is 0x02 and bytes(S, 1, 2) is 0x0406.",
      "ja": "Sは、バイト文字列の場合は、バイト（S、i）は、インデックスが左側に0から始まり、そのi番目のバイトを意味します。従って、バイトが（S、0）S、バイトの左端のバイトである（Sは、1）左から2番目のバイトであり、バイト（仮定Sは、nバイトの長さである）（S、N-1）の右端のバイトでありますS.添加で、バイト（S、iは、j）は包括i番目からj番目のバイトまでのバイトの範囲を意味します。例えば、S = 0x02040608場合、バイト（S、0）0x0406（2、S、1）及び0x02のバイトです。"
    },
    {
      "indent": 3,
      "text": "A byte string can be considered to be a string of w-bit unsigned integers; the correspondence is defined by the function coef(S, i, w) as follows:",
      "ja": "バイト列は、Wビット符号なし整数の列であると考えることができます。以下のような対応は、関数COEF（S、I、W）によって定義されます。"
    },
    {
      "indent": 3,
      "text": "If S is a string, i is a positive integer, and w is a member of the set { 1, 2, 4, 8 }, then coef(S, i, w) is the i-th, w-bit value, if S is interpreted as a sequence of w-bit values. That is,",
      "ja": "Sが文字列である場合、iは正の整数であり、wはセットのメンバーであり、{1、2、4、8}、次いでCOEF（S、Iは、W）は、i番目、Wビットの値でありますSは、Wビット値のシーケンスとして解釈されている場合。あれは、"
    },
    {
      "indent": 7,
      "text": "coef(S, i, w) = (2^w - 1) AND\n                ( byte(S, floor(i * w / 8)) >>\n                  (8 - (w * (i % (8 / w)) + w)) )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For example, if S is the string 0x1234, then coef(S, 7, 1) is 0 and coef(S, 0, 4) is 1.",
      "ja": "Sが文字列0x1234の、次いでCOEF（S、7,1）であり、0とCOEFである場合、例えば、（S、0、4）1です。"
    },
    {
      "indent": 9,
      "text": "             S (represented as bits)\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n| 0| 0| 0| 1| 0| 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0|\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n                       ^\n                       |\n                 coef(S, 7, 1)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "        S (represented as four-bit values)\n+-----------+-----------+-----------+-----------+\n|     1     |     2     |     3     |     4     |\n+-----------+-----------+-----------+-----------+\n      ^\n      |\ncoef(S, 0, 4)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The return value of coef is an unsigned integer. If i is larger than the number of w-bit values in S, then coef(S, i, w) is undefined, and an attempt to compute that value MUST raise an error.",
      "ja": "COEFの戻り値は、符号なし整数です。 iは、S中のWビット値の数よりも大きい場合、次いでCOEF（S、iが、w）は未定義であり、その値を計算しようとすると、エラーが発生しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Typecodes",
      "section_title": true,
      "ja": "3.2。型コード"
    },
    {
      "indent": 3,
      "text": "A typecode is an unsigned integer that is associated with a particular data format. The format of the LM-OTS, LMS, and HSS signatures and public keys all begin with a typecode that indicates the precise details used in that format. These typecodes are represented as four-byte unsigned integers in network byte order; equivalently, they are External Data Representation (XDR) enumerations (see Section 3.3).",
      "ja": "タイプコードは、特定のデータ形式に関連付けられている符号なし整数です。 LM-OTS、LMS、およびHSS署名と公開鍵の形式はすべて、その形式で使用される正確な詳細を示すタイプコードで始まります。これらのタイプコードは、ネットワークバイト順で4バイトの符号なし整数として表現されます。同等に、彼らは外部データ表現（XDR）列挙型（3.3節を参照）です。"
    },
    {
      "indent": 0,
      "text": "3.3. Notation and Formats",
      "section_title": true,
      "ja": "3.3。表記およびフォーマット"
    },
    {
      "indent": 3,
      "text": "The signature and public key formats are formally defined in XDR to provide an unambiguous, machine-readable definition [RFC4506]. The private key format is not included as it is not needed for interoperability and an implementation MAY use any private key format. However, for clarity, we include an example of private key data in Test Case 2 of Appendix F. Though XDR is used, these formats",
      "ja": "署名と公開鍵の形式は、形式的に明白な、機械可読定義[RFC4506]を提供するために、XDRで定義されています。それは、相互運用性のために必要されていないとして、秘密鍵フォーマットが含まれていないと実装は任意の秘密鍵のフォーマットを使用するかもしれません。しかし、明確にするため、私たちは、付録F.けれどもXDRの2が使用されているテストケースでは、秘密鍵データ、これらのフォーマットの一例を含めます"
    },
    {
      "indent": 3,
      "text": "are simple and easy to parse without any special tools. An illustration of the layout of data in these objects is provided below. The definitions are as follows:",
      "ja": "シンプルで特別な道具なしで解析するのは簡単です。これらのオブジェクト内のデータのレイアウトの図は、以下に提供されます。次のような定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "/* one-time signatures */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum lmots_algorithm_type { lmots_reserved = 0, lmots_sha256_n32_w1 = 1, lmots_sha256_n32_w2 = 2, lmots_sha256_n32_w4 = 3, lmots_sha256_n32_w8 = 4 };",
      "ja": "列挙lmots_algorithm_type {lmots_reserved = 0、lmots_sha256_n32_w1 = 1、lmots_sha256_n32_w2 = 2、lmots_sha256_n32_w4 = 3、lmots_sha256_n32_w8 = 4}。"
    },
    {
      "indent": 3,
      "text": "typedef opaque bytestring32[32];",
      "ja": "[32]不透明bytestring32のtypedef。"
    },
    {
      "indent": 3,
      "text": "struct lmots_signature_n32_p265 {\n  bytestring32 C;\n  bytestring32 y[265];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct lmots_signature_n32_p133 {\n  bytestring32 C;\n  bytestring32 y[133];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct lmots_signature_n32_p67 {\n  bytestring32 C;\n  bytestring32 y[67];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct lmots_signature_n32_p34 {\n  bytestring32 C;\n  bytestring32 y[34];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union lmots_signature switch (lmots_algorithm_type type) {\n case lmots_sha256_n32_w1:\n   lmots_signature_n32_p265 sig_n32_p265;\n case lmots_sha256_n32_w2:\n   lmots_signature_n32_p133 sig_n32_p133;\n case lmots_sha256_n32_w4:\n   lmots_signature_n32_p67  sig_n32_p67;\n case lmots_sha256_n32_w8:\n   lmots_signature_n32_p34  sig_n32_p34;\n default:\n   void;   /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* hash-based signatures (hbs) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum lms_algorithm_type {",
      "ja": "列挙lms_algorithm_type {"
    },
    {
      "indent": 3,
      "text": " lms_reserved = 0, lms_sha256_n32_h5 = 5, lms_sha256_n32_h10 = 6, lms_sha256_n32_h15 = 7, lms_sha256_n32_h20 = 8, lms_sha256_n32_h25 = 9 };",
      "ja": "lms_reserved = 0、lms_sha256_n32_h5 = 5、lms_sha256_n32_h10 = 6、lms_sha256_n32_h15 = 7、lms_sha256_n32_h20 = 8、lms_sha256_n32_h25 = 9}。"
    },
    {
      "indent": 3,
      "text": "/* leighton-micali signatures (lms) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union lms_path switch (lms_algorithm_type type) {\n case lms_sha256_n32_h5:\n   bytestring32 path_n32_h5[5];\n case lms_sha256_n32_h10:\n   bytestring32 path_n32_h10[10];\n case lms_sha256_n32_h15:\n   bytestring32 path_n32_h15[15];\n case lms_sha256_n32_h20:\n   bytestring32 path_n32_h20[20];\n case lms_sha256_n32_h25:\n   bytestring32 path_n32_h25[25];\n default:\n   void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct lms_signature {\n  unsigned int q;\n  lmots_signature lmots_sig;\n  lms_path nodes;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct lms_key_n32 {\n  lmots_algorithm_type ots_alg_type;\n  opaque I[16];\n  opaque K[32];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union lms_public_key switch (lms_algorithm_type type) { case lms_sha256_n32_h5: case lms_sha256_n32_h10: case lms_sha256_n32_h15: case lms_sha256_n32_h20: case lms_sha256_n32_h25: lms_key_n32 z_n32;",
      "ja": "組合lms_public_keyスイッチ（lms_algorithm_type型）{ケースlms_sha256_n32_h5：ケースlms_sha256_n32_h10：ケースlms_sha256_n32_h15：ケースlms_sha256_n32_h20：ケースlms_sha256_n32_h25：lms_key_n32 z_n32。"
    },
    {
      "indent": 3,
      "text": " default:\n   void;     /* error condition */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* hierarchical signature system (hss) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct hss_public_key {\n  unsigned int L;\n  lms_public_key pub;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct signed_public_key {\n  lms_signature sig;\n  lms_public_key pub;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct hss_signature {\n  signed_public_key signed_keys<7>;\n  lms_signature sig_of_message;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. LM-OTS One-Time Signatures",
      "section_title": true,
      "ja": "4. LM-OTSワンタイム署名"
    },
    {
      "indent": 3,
      "text": "This section defines LM-OTS signatures. The signature is used to validate the authenticity of a message by associating a secret private key with a shared public key. These are one-time signatures; each private key MUST be used at most one time to sign any given message.",
      "ja": "このセクションでは、LM-OTSシグネチャを定義します。署名は、共有、公開鍵と秘密秘密鍵を関連付けることにより、メッセージの信憑性を検証するために使用されます。これらは、ワンタイム署名されています。各プライベートキーは、任意の与えられたメッセージに署名する最も一度に使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "As part of the signing process, a digest of the original message is computed using the cryptographic hash function H (see Section 4.1), and the resulting digest is signed.",
      "ja": "署名プロセスの一部として、元のメッセージのダイジェストは、暗号ハッシュ関数H（セクション4.1を参照）を使用して計算され、得られたダイジェストが署名されています。"
    },
    {
      "indent": 3,
      "text": "In order to facilitate its use in an N-time signature system, the LM-OTS key generation, signing, and verification algorithms all take as input parameters I and q. The parameter I is a 16-byte string that indicates which Merkle tree this LM-OTS is used with. The parameter q is a 32-bit integer that indicates the leaf of the Merkle tree where the OTS public key appears. These parameters are used as part of the security string, as listed in Section 7.1. When the LM-OTS signature system is used outside of an N-time signature system, the value I MAY be used to differentiate this one-time signature from others; however, the value q MUST be set to the all-zero value.",
      "ja": "N回の署名システム、LM-OTS鍵生成、署名、検証アルゴリズムのすべてにおけるその使用を容易にするために、入力パラメータIおよびQとして取ります。パラメータ私は、このLM-OTSはで使用されているマークル木を示す16バイトの文字列です。パラメータqは、OTS公開鍵が表示されマークル木のリーフを示す32ビットの整数です。セクション7.1に記載されているように、これらのパラメータは、セキュリティ文字列の一部として使用されています。 LM-OTS署名システムは、N回の署名システムの外で使用される場合、値Iは、他人からこのワンタイム署名を区別するために使用されるかもしれません。しかし、Q値は全てゼロの値に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Parameters",
      "section_title": true,
      "ja": "4.1。パラメーター"
    },
    {
      "indent": 3,
      "text": "The signature system uses the parameters n and w, which are both positive integers. The algorithm description also makes use of the internal parameters p and ls, which are dependent on n and w. These parameters are summarized as follows:",
      "ja": "署名システムは、両方の正の整数であるパラメータnおよびWは、使用します。アルゴリズム記述はまた、nおよびWに依存する内部パラメータp及びLS、を利用します。これらのパラメータは以下のように要約されます。"
    },
    {
      "indent": 6,
      "text": "n : the number of bytes of the output of the hash function.",
      "ja": "N：ハッシュ関数の出力のバイト数。"
    },
    {
      "indent": 6,
      "text": "w : the width (in bits) of the Winternitz coefficients; that is, the number of bits from the hash or checksum that is used with a single Winternitz chain. It is a member of the set { 1, 2, 4, 8 }.",
      "ja": "W：Winternitz係数の（ビット単位の）幅。それは、単一Winternitzチェーンとともに使用されるハッシュまたはチェックサムからのビットの数です。これは、集合{1、2、4、8}のメンバーです。"
    },
    {
      "indent": 6,
      "text": "p : the number of n-byte string elements that make up the LM-OTS signature. This is a function of n and w; the values for the defined parameter sets are listed in Table 1; it can also be computed by the algorithm given in Appendix B.",
      "ja": "P：LM-OTS署名を構成するnバイトの文字列要素の数。これは、nおよびWの関数です。定義されたパラメータセットの値は、表1に列挙されています。それはまた、付録Bに与えられたアルゴリズムによって計算することができます"
    },
    {
      "indent": 6,
      "text": "ls : the number of left-shift bits used in the checksum function Cksm (defined in Section 4.4).",
      "ja": "LS：チェックサム関数Cksmに使用左シフトビットの数（セクション4.4で定義されます）。"
    },
    {
      "indent": 6,
      "text": "H : a second-preimage-resistant cryptographic hash function that accepts byte strings of any length and returns an n-byte string.",
      "ja": "H：任意の長さのバイト列を受け取り、nバイトの文字列を返す二プリイメージ耐性暗号ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "For more background on the cryptographic security requirements for H, see Section 9.",
      "ja": "Hのための暗号化セキュリティ要件の詳細な背景については、第9章を参照してください。"
    },
    {
      "indent": 3,
      "text": "The value of n is determined by the hash function selected for use as part of the LM-OTS algorithm; the choice of this value has a strong effect on the security of the system. The parameter w determines the length of the Winternitz chains computed as a part of the OTS signature (which involve 2^w - 1 invocations of the hash function); it has little effect on security. Increasing w will shorten the signature, but at a cost of a larger computation to generate and verify a signature. The values of p and ls are dependent on the choices of the parameters n and w, as described in Appendix B. Table 1 illustrates various combinations of n, w, p and ls, along with the resulting signature length.",
      "ja": "nの値は、LM-OTSアルゴリズムの一部として使用するために選択したハッシュ関数により決定されます。この値の選択は、システムのセキュリティに強い影響を持っています。パラメータwはOTS署名（2 ^ Wを含む - ハッシュ関数の呼び出し1）の一部として計算Winternitz鎖の長さを決定します。それは、セキュリティにほとんど影響を与えません。 Wを大きくすると、署名が短くなり、より大きな計算コストで生成した署名を検証します。付録B、表1に記載したように、pの値およびLSは、パラメータnおよびWの選択に依存して、得られた署名長とともに、pおよびLS wは、n個の様々な組み合わせを示しています。"
    },
    {
      "indent": 3,
      "text": "The value of w describes a space/time trade-off; increasing the value of w will cause the signature to shrink (by decreasing the value of p) while increasing the amount of time needed to perform operations with it: generate the public key and generate and verify the signature. In general, the LM-OTS signature is 4+n*(p+1) bytes long, and public key generation will take p*(2^w - 1) + 1 hash computations (and signature generation and verification will take approximately half that on average).",
      "ja": "Wの値は、空間/時間のトレードオフを説明し、公開鍵を生成し、生成した署名を検証する：Wの値を大きくすると、署名がそれに操作を実行するのに必要な時間の量を増加させながら（pの値を減少させることによって）縮小します。一般的に、LM-OTS署名は4 + N *（P + 1）バイトの長さ、及び公開鍵の生成は、（2 ^ W  -  1）P *を取る+ 1つのハッシュ計算（および署名生成および検証は約半分になりますその平均で）。"
    },
    {
      "indent": 6,
      "text": "+---------------------+--------+----+---+-----+----+---------+\n| Parameter Set Name  | H      | n  | w | p   | ls | sig_len |\n+---------------------+--------+----+---+-----+----+---------+\n| LMOTS_SHA256_N32_W1 | SHA256 | 32 | 1 | 265 | 7  | 8516    |\n|                     |        |    |   |     |    |         |\n| LMOTS_SHA256_N32_W2 | SHA256 | 32 | 2 | 133 | 6  | 4292    |\n|                     |        |    |   |     |    |         |\n| LMOTS_SHA256_N32_W4 | SHA256 | 32 | 4 | 67  | 4  | 2180    |\n|                     |        |    |   |     |    |         |\n| LMOTS_SHA256_N32_W8 | SHA256 | 32 | 8 | 34  | 0  | 1124    |\n+---------------------+--------+----+---+-----+----+---------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "Here SHA256 denotes the SHA-256 hash function defined in NIST standard [FIPS180].",
      "ja": "ここでSHA256は、NIST標準[FIPS180]で定義されたSHA256ハッシュ関数です。"
    },
    {
      "indent": 0,
      "text": "4.2. Private Key",
      "section_title": true,
      "ja": "4.2。秘密鍵"
    },
    {
      "indent": 3,
      "text": "The format of the LM-OTS private key is an internal matter to the implementation, and this document does not attempt to define it. One possibility is that the private key may consist of a typecode indicating the particular LM-OTS algorithm, an array x[] containing p n-byte strings, and the 16-byte string I and the 4-byte string q. This private key MUST be used to sign (at most) one message. The following algorithm shows pseudocode for generating a private key.",
      "ja": "LM-OTS秘密鍵の形式は実装に内部の問題であり、この文書は、それを定義しようとしません。一つの可能​​性は、秘密キーが配列X [] P Nバイトの文字列を含む、16バイトの文字列Iと4バイトの文字列Q、特定のLM-OTSアルゴリズムを示すタイプコードから構成されてもよいということです。この秘密鍵は、（最大で）一つのメッセージに署名するために使用されなければなりません。次のアルゴリズムは、秘密鍵を生成するための擬似コードを示します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 0: Generating a Private Key",
      "ja": "アルゴリズム0：秘密鍵の生成"
    },
    {
      "indent": 5,
      "text": "1. Retrieve the values of q and I (the 16-byte identifier of the LMS public/private key pair) from the LMS tree that this LM-OTS private key will be used with",
      "ja": "1. Qの値を取得し、このLM-OTS秘密鍵を用いて使用されるLMSツリーからI（LMS公開/秘密鍵ペアの16バイトの識別子）"
    },
    {
      "indent": 5,
      "text": "2. Set type to the typecode of the algorithm",
      "section_title": true,
      "ja": "アルゴリズムのタイプコードに2セットタイプ"
    },
    {
      "indent": 5,
      "text": "3. Set n and p according to the typecode and Table 1",
      "section_title": true,
      "ja": "タイプコードと、表1に記載の集合NおよびP"
    },
    {
      "indent": 5,
      "text": "4. Compute the array x as follows: for ( i = 0; i < p; i = i + 1 ) { set x[i] to a uniformly random n-byte string }",
      "ja": "4.計算次のようにXアレイのための：（i = 0; iは、P <; I = I + 1）{セットX [i]は一様にランダムなnバイト文字列へ}"
    },
    {
      "indent": 5,
      "text": "5. Return u32str(type) || I || u32str(q) || x[0] || x[1] || ... || x[p-1]",
      "ja": "5.戻りu32str（タイプ）|| I || u32str（Q）|| X [0] || X [1] || ... || X [P-1]"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use a pseudorandom method to compute x[i], as suggested in [Merkle79], page 46. The details of the pseudorandom method do not affect interoperability, but the cryptographic strength",
      "ja": "実装は、[Merkle79]で提案されているように、X [I]を計算するために、擬似ランダム方式を使用することができるが、46ページの相互運用性には影響を与えません擬似ランダム方法の詳細が、暗号の強度"
    },
    {
      "indent": 3,
      "text": "MUST match that of the LM-OTS algorithm. Appendix A provides an example of a pseudorandom method for computing the LM-OTS private key.",
      "ja": "LM-OTSアルゴリズムのものと一致しなければなりません。付録Aは、LM-OTS秘密鍵を計算するための擬似ランダム方法の例を提供します。"
    },
    {
      "indent": 0,
      "text": "4.3. Public Key",
      "section_title": true,
      "ja": "4.3。公開鍵"
    },
    {
      "indent": 3,
      "text": "The LM-OTS public key is generated from the private key by iteratively applying the function H to each individual element of x, for 2^w - 1 iterations, then hashing all of the resulting values.",
      "ja": "その後、1回の反復結果の値の全てをハッシュ -  LM-OTS公開鍵を反復W 2 ^ため、xの個々の要素に関数Hを適用することにより、秘密鍵から生成されます。"
    },
    {
      "indent": 3,
      "text": "The public key is generated from the private key using the following algorithm, or any equivalent process.",
      "ja": "公開鍵は、次のアルゴリズムを使用して、秘密鍵、または任意の同等のプロセスから生成されます。"
    },
    {
      "indent": 3,
      "text": "Algorithm 1: Generating a One-Time Signature Public Key From a Private Key",
      "ja": "アルゴリズム1：プライベート・キーからワンタイム署名公開鍵の生成"
    },
    {
      "indent": 5,
      "text": "1. Set type to the typecode of the algorithm",
      "section_title": true,
      "ja": "アルゴリズムのタイプコードに1セットタイプ"
    },
    {
      "indent": 5,
      "text": "2. Set the integers n, p, and w according to the typecode and Table 1",
      "ja": "2.整数N、Pを設定し、タイプコードと、表1によれば、W"
    },
    {
      "indent": 5,
      "text": "3. Determine x, I, and q from the private key",
      "section_title": true,
      "ja": "3.秘密鍵からのx、I、およびQを決定"
    },
    {
      "indent": 5,
      "text": "4. Compute the string K as follows: for ( i = 0; i < p; i = i + 1 ) { tmp = x[i] for ( j = 0; j < 2^w - 1; j = j + 1 ) { tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp) } y[i] = tmp } K = H(I || u32str(q) || u16str(D_PBLC) || y[0] || ... || y[p-1])",
      "ja": "4.計算文字列Kを次のようにするための（i = 0; iは、Pを<; I = I + 1）{TMP = X [i]のための（j = 0; J <2 ^ W  -  1、J = J + 1）{TMPは= H（Iは|| u32str（Q）|| u16str（I）|| u8str（J）|| TMP）} Y [i]は、TMP} K = H（私は（Qをu32strを||を）= | | u16str（D_PBLC）|| Y [0] || ... || Y [P-1]）"
    },
    {
      "indent": 5,
      "text": "5. Return u32str(type) || I || u32str(q) || K",
      "section_title": true,
      "ja": "5.戻りu32str（タイプ）|| I || u32str（Q）|| K"
    },
    {
      "indent": 3,
      "text": "where D_PBLC is the fixed two-byte value 0x8080, which is used to distinguish the last hash from every other hash in this system.",
      "ja": "D_PBLCは、このシステム内の他のすべてのハッシュから最後のハッシュを区別するために使用される固定された2つのバイトの値0x8080、です。"
    },
    {
      "indent": 3,
      "text": "The public key is the value returned by Algorithm 1.",
      "ja": "公開鍵は、アルゴリズム1で返される値です。"
    },
    {
      "indent": 0,
      "text": "4.4. Checksum",
      "section_title": true,
      "ja": "4.4。チェックサム"
    },
    {
      "indent": 3,
      "text": "A checksum is used to ensure that any forgery attempt that manipulates the elements of an existing signature will be detected. This checksum is needed because an attacker can freely advance any of the Winternitz chains. That is, if this checksum were not present, then an attacker who could find a hash that has every digit larger than the valid hash could replace it (and adjust the Winternitz chains). The security property that the checksum provides is detailed in Section 9. The checksum function Cksm is defined as follows, where S denotes the n-byte string that is input to that function, and the value sum is a 16-bit unsigned integer:",
      "ja": "チェックサムは、既存の署名の要素を操作する任意の偽造の試みが検出されることを保証するために使用されます。攻撃者が自由にWinternitzチェーンのいずれかを進めることができるので、このチェックサムが必要とされています。つまり、このチェックサムが存在しない場合、有効なハッシュよりも、すべての数字が大きいことをハッシュを見つけることができる攻撃者はそれを交換（およびWinternitzチェーンを調整する）ことができ、あります。チェックサムが提供するセキュリティプロパティは、セクション9 CksmがSは、その関数に入力されるnバイト列であり、値の合計が16ビットの符号なし整数であり、以下のように定義されるチェックサム機能の詳細です。"
    },
    {
      "indent": 3,
      "text": "Algorithm 2: Checksum Calculation",
      "ja": "アルゴリズム2：チェックサム計算"
    },
    {
      "indent": 5,
      "text": "sum = 0 for ( i = 0; i < (n*8/w); i = i + 1 ) { sum = sum + (2^w - 1) - coef(S, i, w) } return (sum << ls)",
      "ja": "和= 0（i = 0; iが<（N * 8 / W）; I = I + 1）{合計=合計+（2 ^ W  -  1） -  COEF（S、I、W）}リターン（SUM << LS）"
    },
    {
      "indent": 3,
      "text": "ls is the parameter that shifts the significant bits of the checksum into the positions that will actually be used by the coef function when encoding the digits of the checksum. The actual ls parameter is a function of the n and w parameters; the values for the currently defined parameter sets are shown in Table 1. It is calculated by the algorithm given in Appendix B.",
      "ja": "LSは、チェックサムの数字を符号化する際、実際にCOEF関数によって使用される位置に、チェックサムの上位ビットをシフトさせるパラメータです。実際のLSパラメータは、nおよびWのパラメータの関数です。現在定義されているパラメータセットの値を表1に示す。これは、付録Bに与えられたアルゴリズムによって計算されます"
    },
    {
      "indent": 3,
      "text": "Because of the left-shift operation, the rightmost bits of the result of Cksm will often be zeros. Due to the value of p, these bits will not be used during signature generation or verification.",
      "ja": "なぜなら左シフト動作、Cksmの結果の右端のビットは、多くの場合、ゼロであろう。 pの値に、これらのビットは、署名生成や検証中に使用されません。"
    },
    {
      "indent": 0,
      "text": "4.5. Signature Generation",
      "section_title": true,
      "ja": "4.5。署名生成"
    },
    {
      "indent": 3,
      "text": "The LM-OTS signature of a message is generated by doing the following in sequence: prepending the LMS key identifier I, the LMS leaf identifier q, the value D_MESG (0x8181), and the randomizer C to the message; computing the hash; concatenating the checksum of the hash to the hash itself; considering the resulting value as a sequence of w-bit values; and using each of the w-bit values to determine the number of times to apply the function H to the corresponding element of the private key. The outputs of the function H are concatenated together and returned as the signature. The pseudocode for this procedure is shown below.",
      "ja": "メッセージのLM-OTS署名を順次次のようにして生成される：メッセージにLMSキー識別子I、LMSリーフ識別子Q、値D_MESG（0x8181）、及びランダム化Cを付加します。ハッシュを計算します。ハッシュ自体のハッシュのチェックサムを連結します。 Wビット値のシーケンスとして得られた値を考慮します。そして、秘密鍵の対応する要素に関数Hを適用する回数を決定するために、W-ビット値のそれぞれを使用して。関数Hの出力は一緒に連結し、署名として返されます。この手順のための疑似コードを以下に示します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 3: Generating a One-Time Signature From a Private Key and a Message",
      "ja": "アルゴリズム3：秘密鍵とメッセージからワンタイム署名を生成します"
    },
    {
      "indent": 5,
      "text": "1. Set type to the typecode of the algorithm",
      "section_title": true,
      "ja": "アルゴリズムのタイプコードに1セットタイプ"
    },
    {
      "indent": 5,
      "text": "2. Set n, p, and w according to the typecode and Table 1",
      "section_title": true,
      "ja": "2.集合N、P、およびWタイプコード及び表1に従って"
    },
    {
      "indent": 5,
      "text": "3. Determine x, I, and q from the private key",
      "section_title": true,
      "ja": "3.秘密鍵からのx、I、およびQを決定"
    },
    {
      "indent": 5,
      "text": "4. Set C to a uniformly random n-byte string",
      "section_title": true,
      "ja": "一様にランダムなnバイトの文字列に4セットC"
    },
    {
      "indent": 5,
      "text": "5. Compute the array y as follows: Q = H(I || u32str(q) || u16str(D_MESG) || C || message) for ( i = 0; i < p; i = i + 1 ) { a = coef(Q || Cksm(Q), i, w) tmp = x[i] for ( j = 0; j < a; j = j + 1 ) { tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp) } y[i] = tmp }",
      "ja": "5.計算配列y次のように：（i = 0; iは、Pを<; I = I + 1）についてのQ = H（Iはu32strを||（Q）|| u16str（D_MESG）|| C ||メッセージ）{ = COEF（Q || Cksm（Q）、I、W）TMP = X [i]は（J = 0であり、j <J = J + 1）のために{TMP = H（I）は、Q（u32strを||します|| u16str（I）|| u8str（J）|| TMP）} Y [i]は} TMP ="
    },
    {
      "indent": 6,
      "text": "6. Return u32str(type) || C || y[0] || ... || y[p-1]",
      "section_title": true,
      "ja": "6.戻りu32str（タイプ）|| C || Y [0] || ... || Y [P-1]"
    },
    {
      "indent": 3,
      "text": "Note that this algorithm results in a signature whose elements are intermediate values of the elements computed by the public key algorithm in Section 4.3.",
      "ja": "要素セクション4.3で公開鍵アルゴリズムによって計算要素の中間値である署名に、このアルゴリズムは、結果ことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The signature is the string returned by Algorithm 3. Section 3.3 formally defines the structure of the string as the lmots_signature union.",
      "ja": "署名は、正式lmots_signature組合として文字列の構造を定義するアルゴリズム3. 3.3節によって返される文字列です。"
    },
    {
      "indent": 0,
      "text": "4.6. Signature Verification",
      "section_title": true,
      "ja": "4.6。署名検証"
    },
    {
      "indent": 3,
      "text": "In order to verify a message with its signature (an array of n-byte strings, denoted as y), the receiver must \"complete\" the chain of iterations of H using the w-bit coefficients of the string resulting from the concatenation of the message hash and its checksum. This computation should result in a value that matches the provided public key.",
      "ja": "（Yと表記nバイトの文字列の配列）、その署名付きメッセージを確認するために、受信機は、連結の結果の文字列のWビット係数を用いてHの反復の鎖を「完了」する必要がありますメッセージのハッシュとそのチェックサム。この計算は、提供された公開キーと一致する値になるはずです。"
    },
    {
      "indent": 3,
      "text": "Algorithm 4a: Verifying a Signature and Message Using a Public Key",
      "ja": "アルゴリズム4A：公開鍵を使って署名とメッセージを確認"
    },
    {
      "indent": 5,
      "text": "1. If the public key is not at least four bytes long, return INVALID.",
      "ja": "1.公開鍵は、少なくとも4バイト長ではありません、無効な戻ります。"
    },
    {
      "indent": 5,
      "text": "2. Parse pubtype, I, q, and K from the public key as follows: a. pubtype = strTou32(first 4 bytes of public key)",
      "ja": "：次のように公開鍵から2.解析のpubtype、I、Q、およびK。 pubtype = strTou32（公開鍵の最初の4バイト）"
    },
    {
      "indent": 8,
      "text": "b. Set n according to the pubkey and Table 1; if the public key is not exactly 24 + n bytes long, return INVALID.",
      "ja": "B。集合N pubkeyで、表1に記載の方法。公開鍵は正確に24 + nバイトの長でない場合は、無効な戻り。"
    },
    {
      "indent": 8,
      "text": "c. I = next 16 bytes of public key",
      "ja": "C。公開鍵のI =次の16のバイト"
    },
    {
      "indent": 8,
      "text": "d. q = strTou32(next 4 bytes of public key)",
      "ja": "D。 Q = strTou32（公開鍵の次の4バイト）"
    },
    {
      "indent": 8,
      "text": "e. K = next n bytes of public key",
      "ja": "電子。公開鍵のK =次のnバイト"
    },
    {
      "indent": 5,
      "text": "3. Compute the public key candidate Kc from the signature, message, pubtype, and the identifiers I and q obtained from the public key, using Algorithm 4b. If Algorithm 4b returns INVALID, then return INVALID.",
      "ja": "3.計算署名、メッセージ、pubtype、およびアルゴリズム4Bを用いて、公開鍵から得られた識別子IおよびQから公開鍵Kcを候補。アルゴリズム4bがINVALID返す場合、INVALIDを戻します。"
    },
    {
      "indent": 5,
      "text": "4. If Kc is equal to K, return VALID; otherwise, return INVALID.",
      "section_title": true,
      "ja": "4. KcがKに等しい場合、有効な戻り。そうでない場合は、無効な戻り。"
    },
    {
      "indent": 3,
      "text": "Algorithm 4b: Computing a Public Key Candidate Kc from a Signature, Message, Signature Typecode pubtype, and Identifiers I, q",
      "ja": "アルゴリズム図4b：署名、メッセージ、署名タイプコードのpubtype、及び識別子I、Qから公開鍵候補Kcのコンピューティング"
    },
    {
      "indent": 5,
      "text": "1. If the signature is not at least four bytes long, return INVALID.",
      "ja": "署名がない、少なくとも4バイト長である場合は1、INVALID返します。"
    },
    {
      "indent": 5,
      "text": "2. Parse sigtype, C, and y from the signature as follows: a. sigtype = strTou32(first 4 bytes of signature)",
      "ja": "2.解析のsigtype、C、および次のように署名からY：。 sigtype = strTou32（署名の最初の4バイト）"
    },
    {
      "indent": 8,
      "text": "b. If sigtype is not equal to pubtype, return INVALID.",
      "ja": "B。 sigtypeがpubtypeに等しくない場合、無効な戻り。"
    },
    {
      "indent": 8,
      "text": "c. Set n and p according to the pubtype and Table 1; if the signature is not exactly 4 + n * (p+1) bytes long, return INVALID.",
      "ja": "C。 pubtype表1に従って設定n及びp。署名は4 + N *（p + 1）バイト長正確でない場合、INVALID返します。"
    },
    {
      "indent": 8,
      "text": "d. C = next n bytes of signature",
      "ja": "D。署名のCは、=次のnバイト"
    },
    {
      "indent": 8,
      "text": "e. y[0] = next n bytes of signature y[1] = next n bytes of signature ... y[p-1] = next n bytes of signature",
      "ja": "電子。 Y署名yの[0] =次のnバイトの署名の[1] =次のnバイト...署名のY [P-1] =次のnバイト"
    },
    {
      "indent": 5,
      "text": "3. Compute the string Kc as follows: Q = H(I || u32str(q) || u16str(D_MESG) || C || message) for ( i = 0; i < p; i = i + 1 ) { a = coef(Q || Cksm(Q), i, w) tmp = y[i] for ( j = a; j < 2^w - 1; j = j + 1 ) { tmp = H(I || u32str(q) || u16str(i) || u8str(j) || tmp) } z[i] = tmp } Kc = H(I || u32str(q) || u16str(D_PBLC) || z[0] || z[1] || ... || z[p-1])",
      "ja": "3.計算Kcは次のように文字列：Q = Hのために（私はu32str（Q）|| u16str（D_MESG）|| C ||メッセージ||）（i = 0; iは<P、Iを= I + 1）{ = COEF（Q || Cksm（Q）、I、W）TMP = Y [i]のための（J =、J <2 ^ W  -  1、J = J + 1）{TMP = H（I || || u16str（I）|| u8str（J）|| TMP）} Z [i]は= u32str（Q）TMP} Kcを= H（Iはu32str（Qを||）|| u16str（D_PBLC）|| Z [0 ] || Z [1] || ... || Z [P-1]）"
    },
    {
      "indent": 5,
      "text": "4. Return Kc.",
      "section_title": true,
      "ja": "4.戻りKcを。"
    },
    {
      "indent": 0,
      "text": "5. Leighton-Micali Signatures",
      "section_title": true,
      "ja": "5.レイトン-Micaliの署名"
    },
    {
      "indent": 3,
      "text": "The Leighton-Micali Signature (LMS) method can sign a potentially large but fixed number of messages. An LMS system uses two cryptographic components: a one-time signature method and a hash function. Each LMS public/private key pair is associated with a perfect binary tree, each node of which contains an m-byte value, where m is the output length of the hash function. Each leaf of the tree contains the value of the public key of an LM-OTS public/private key pair. The value contained by the root of the tree is the LMS public key. Each interior node is computed by applying the hash function to the concatenation of the values of its children nodes.",
      "ja": "レイトン-Micali署名（LMS）メソッドは、メッセージの潜在的に大きいが一定数に署名することができます。ワンタイム署名方式とハッシュ関数：LMSシステムは、2つの暗号化コンポーネントを使用します。各LMS公開/秘密鍵ペアは、mは、ハッシュ関数の出力長さMバイトの値を含み、各ノードはその完全二分木、関連付けられています。ツリーの各リーフは、LM-OTSの公開鍵/秘密鍵ペアの公開キーの値が含まれています。ツリーのルートに含まれる値は、LMS公開鍵です。各内部ノードは、その子ノードの値の連結にハッシュ関数を適用することによって計算されます。"
    },
    {
      "indent": 3,
      "text": "Each node of the tree is associated with a node number, an unsigned integer that is denoted as node_num in the algorithms below, which is computed as follows. The root node has node number 1; for each node with node number N < 2^h (where h is the height of the tree), its left child has node number 2*N, while its right child has node number 2*N + 1. The result of this is that each node within the tree will have a unique node number, and the leaves will have node numbers 2^h, (2^h)+1, (2^h)+2, ..., (2^h)+(2^h)-1. In general, the j-th node at level i has node number 2^i + j. The node number can conveniently be computed when it is needed in the LMS algorithms, as described in those algorithms.",
      "ja": "ツリーの各ノードは、以下のように計算されるノード番号は、以下のアルゴリズムにおいてNODE_NUMとして示される符号なし整数、関連付けられています。ルートノードはノード番号1を有しています。ノード数N <2 ^ H（Hは、ツリーの高さである）を有する各ノード、その右の子ノード番号2を有するが、その左の子は、N *ノード番号2を持つ* N + 1のために、この結果はツリー内の各ノードは、一意のノード番号を持つことになり、葉がノード番号を有することが2 ^ H、（2 ^ H）+1、（2 ^ H）+2、···、（^ H 2）+ （2 ^ H）-1。一般的にレベルで、j番目のノードiがノード数2 ^ I + Jを有します。それはLMSアルゴリズムに必要とされるとき、これらのアルゴリズムで説明したようにノード番号は、好都合には、計算することができます。"
    },
    {
      "indent": 0,
      "text": "5.1. Parameters",
      "section_title": true,
      "ja": "5.1。パラメーター"
    },
    {
      "indent": 3,
      "text": "An LMS system has the following parameters:",
      "ja": "LMSシステムは、次のパラメータがあります。"
    },
    {
      "indent": 6,
      "text": "h : the height of the tree",
      "ja": "時間：木の高さ"
    },
    {
      "indent": 6,
      "text": "m : the number of bytes associated with each node",
      "ja": "M：各ノードに関連付けられたバイトの数"
    },
    {
      "indent": 6,
      "text": "H : a second-preimage-resistant cryptographic hash function that accepts byte strings of any length and returns an m-byte string.",
      "ja": "H：任意の長さのバイト列を受け取り、Mバイトの文字列を返す二プリイメージ耐性暗号ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "There are 2^h leaves in the tree.",
      "ja": "ツリー内の2 ^ Hの葉があります。"
    },
    {
      "indent": 3,
      "text": "The overall strength of LMS signatures is governed by the weaker of the hash function used within the LM-OTS and the hash function used within the LMS system. In order to minimize the risk, these two hash functions SHOULD be the same (so that an attacker could not take advantage of the weaker hash function choice).",
      "ja": "LMSシグネチャの全体的な強度は、LM-OTSとLMSシステム内で使用されるハッシュ関数内で使用されるハッシュ関数の弱いによって支配されます。 （攻撃者が弱いハッシュ関数の選択の利点を取ることができなかったように）リスクを最小限に抑えるためには、これら2つのハッシュ関数は、同じである必要があります。"
    },
    {
      "indent": 17,
      "text": "+--------------------+--------+----+----+\n| Name               | H      | m  | h  |\n+--------------------+--------+----+----+\n| LMS_SHA256_M32_H5  | SHA256 | 32 | 5  |\n|                    |        |    |    |\n| LMS_SHA256_M32_H10 | SHA256 | 32 | 10 |\n|                    |        |    |    |\n| LMS_SHA256_M32_H15 | SHA256 | 32 | 15 |\n|                    |        |    |    |\n| LMS_SHA256_M32_H20 | SHA256 | 32 | 20 |\n|                    |        |    |    |\n| LMS_SHA256_M32_H25 | SHA256 | 32 | 25 |\n+--------------------+--------+----+----+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 0,
      "text": "5.2. LMS Private Key",
      "section_title": true,
      "ja": "5.2。 LMS秘密鍵"
    },
    {
      "indent": 3,
      "text": "The format of the LMS private key is an internal matter to the implementation, and this document does not attempt to define it. One possibility is that it may consist of an array OTS_PRIV[] of 2^h LM-OTS private keys and the leaf number q of the next LM-OTS private key that has not yet been used. The q-th element of OTS_PRIV[] is generated using Algorithm 0 with the identifiers I, q. The leaf number q is initialized to zero when the LMS private key is created. The process is as follows:",
      "ja": "LMS秘密鍵の形式は実装に内部の問題であり、この文書は、それを定義しようとしません。一つの可能​​性は、それがOTS_PRIV []は2 ^ HのLM-OTS秘密鍵と、まだ使用されていない次のLM-OTS秘密鍵の葉の数qのアレイから構成されてもよいということです。 OTS_PRIV []のq番目の要素は、識別子I、Qとアルゴリズム0を使用して生成されます。 LMS秘密鍵が作成されたときに葉の数qはゼロに初期化されます。次のようにプロセスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Algorithm 5: Computing an LMS Private Key.",
      "ja": "アルゴリズム5：LMS秘密鍵を計算します。"
    },
    {
      "indent": 5,
      "text": "1. Determine h and m from the typecode and Table 2.",
      "section_title": true,
      "ja": "1.タイプコード及び表2からのHとMを決定します。"
    },
    {
      "indent": 5,
      "text": "2. Set I to a uniformly random 16-byte string.",
      "section_title": true,
      "ja": "一様にランダムな16バイトの文字列に2セットI。"
    },
    {
      "indent": 5,
      "text": "3. Compute the array OTS_PRIV[] as follows: for ( q = 0; q < 2^h; q = q + 1) { OTS_PRIV[q] = LM-OTS private key with identifiers I, q }",
      "ja": "3.計算アレイOTS_PRIV []次のようにするため（q = 0であり、q <2 ^ H; Q = Q + 1）{OTS_PRIV [Q] =識別子を持つLM-OTS秘密鍵I、Q}"
    },
    {
      "indent": 5,
      "text": "4. q = 0",
      "section_title": true,
      "ja": "4. q = 0で"
    },
    {
      "indent": 3,
      "text": "An LMS private key MAY be generated pseudorandomly from a secret value; in this case, the secret value MUST be at least m bytes long and uniformly random and MUST NOT be used for any other purpose than the generation of the LMS private key. The details of how this process is done do not affect interoperability; that is, the public key verification operation is independent of these details. Appendix A provides an example of a pseudorandom method for computing an LMS private key.",
      "ja": "LMS秘密鍵は秘密値から疑似ランダムに発生させることができます。この場合には、秘密の値は、少なくともmが長くかつ均一にランダムバイトでなければならなくて、LMSの秘密鍵の生成以外の目的のために使用してはいけません。このプロセスがどのように行われるかの詳細については、相互運用性に影響を与えません。つまり、公開鍵検証作業は、これらの詳細は無関係です。付録Aは、LMS秘密鍵を計算するための擬似ランダム方法の一例を提供します。"
    },
    {
      "indent": 3,
      "text": "The signature-generation logic uses q as the next leaf to use; hence, step 4 starts it off at the leftmost leaf. Because the signature process increments q after the signature operation, the first signature will have q=0.",
      "ja": "署名生成ロジックは、使用する次のリーフとしてQを使用します。従って、ステップ4は、左端の葉でそれを開始します。署名プロセスは、署名操作後のqをインクリメントするので、最初の署名は、Q = 0を有することになります。"
    },
    {
      "indent": 0,
      "text": "5.3. LMS Public Key",
      "section_title": true,
      "ja": "5.3。 LMS公開鍵"
    },
    {
      "indent": 3,
      "text": "An LMS public key is defined as follows, where we denote the public key final hash value (namely, the K value computed in Algorithm 1) associated with the i-th LM-OTS private key as OTS_PUB_HASH[i], with i ranging from 0 to (2^h)-1. Each instance of an LMS public/private key pair is associated with a balanced binary tree, and the nodes of that tree are indexed from 1 to 2^(h+1)-1. Each node is associated with an m-byte string. The string for the r-th node is denoted as T[r] and defined as",
      "ja": "LMS公開鍵は、次のように定義されている我々は、公開鍵、最終ハッシュ値を示す場合（すなわち、アルゴリズム1で計算されたK値）iは範囲で、OTS_PUB_HASH [I]とi番目のLM-OTS秘密鍵に関連付けられています0〜（2 ^ H）-1。 LMS公開鍵/秘密鍵のペアの各インスタンスは、平衡二分木に関連付けられ、そのツリーのノードは、1から2 ^（H + 1）にインデックスされている-1。各ノードは、Mバイトの文字列に関連付けられています。 R番目のノードの文字列は、T [R]として示され、のように定義されます"
    },
    {
      "indent": 5,
      "text": "if r >= 2^h: H(I||u32str(r)||u16str(D_LEAF)||OTS_PUB_HASH[r-2^h]) else H(I||u32str(r)||u16str(D_INTR)||T[2*r]||T[2*r+1])",
      "ja": "もしR> = 2 ^ H：H（I || u32str（R）|| u16str（D_LEAF）|| OTS_PUB_HASH [R-2 ^ H]）他H（I || u32str（R）|| u16str（D_INTR） || T [2 * R] || T [2 * R + 1]）"
    },
    {
      "indent": 3,
      "text": "where D_LEAF is the fixed two-byte value 0x8282 and D_INTR is the fixed two-byte value 0x8383, both of which are used to distinguish this hash from every other hash in this system.",
      "ja": "D_LEAFは、固定された2つのバイトの値0x8282であるとD_INTRは、このシステム内の他のすべてのハッシュからこのハッシュを区別するために使用されるどちらも固定された2つのバイトの値0x8383、です。"
    },
    {
      "indent": 3,
      "text": "When we have r >= 2^h, then we are processing a leaf node (and thus hashing only a single LM-OTS public key). When we have r < 2^h, then we are processing an internal node -- that is, a node with two child nodes that we need to combine.",
      "ja": "我々はR> = 2 ^ Hを有している場合、我々はリーフノードを処理している（したがって、単一のLM-OTS公開鍵のハッシュ）。我々はR <2 ^ Hを持っている場合は、次に我々は、内部ノードを処理している - 、我々は結合する必要のある2つの子ノードを持つノードです。"
    },
    {
      "indent": 3,
      "text": "The LMS public key can be represented as the byte string",
      "ja": "LMS公開鍵は、バイト文字列として表すことができます"
    },
    {
      "indent": 5,
      "text": "u32str(type) || u32str(otstype) || I || T[1]",
      "ja": "u32str（タイプ）|| u32str（otstype）|| I || T [1]"
    },
    {
      "indent": 3,
      "text": "Section 3.3 specifies the format of the type variable. The value otstype is the parameter set for the LM-OTS public/private key pairs used. The value I is the private key identifier and is the value used for all computations for the same LMS tree. The value T[1] can be computed via recursive application of the above equation or by any equivalent method. An iterative procedure is outlined in Appendix C.",
      "ja": "3.3節は、型変数の形式を指定します。値otstypeは使用LM-OTSの公開鍵/秘密鍵のペアのためのパラメータセットです。値Iは、秘密鍵の識別子であり、同じLMSツリーのすべての計算に使用される値です。値T [1]上記の式の再帰的なアプリケーションを介して又は任意の同等の方法により算出することができます。反復手順は、付録Cに概説されています。"
    },
    {
      "indent": 0,
      "text": "5.4. LMS Signature",
      "section_title": true,
      "ja": "5.4。 LMS署名"
    },
    {
      "indent": 3,
      "text": "An LMS signature consists of",
      "ja": "LMS署名がから成り"
    },
    {
      "indent": 6,
      "text": "the number q of the leaf associated with the LM-OTS signature, as a four-byte unsigned integer in network byte order, an LM-OTS signature,",
      "ja": "ネットワークバイト順に4バイトの符号なし整数として、LM-OTS署名に関連付けられている葉の数q、LM-OTS署名、"
    },
    {
      "indent": 6,
      "text": "a typecode indicating the particular LMS algorithm,",
      "ja": "特定のLMSアルゴリズムを示すタイプコード、"
    },
    {
      "indent": 6,
      "text": "an array of h m-byte values that is associated with the path through the tree from the leaf associated with the LM-OTS signature to the root.",
      "ja": "ルートへのLM-OTS署名に関連付けられているリーフからツリーを通るパスに関連付けられたH Mバイト値の配列。"
    },
    {
      "indent": 3,
      "text": "Symbolically, the signature can be represented as",
      "ja": "象徴的に、署名は次のように表すことができます。"
    },
    {
      "indent": 7,
      "text": "u32str(q) || lmots_signature || u32str(type) ||\n          path[0] || path[1] || path[2] || ... || path[h-1]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section 3.3 formally defines the format of the signature as the lms_signature structure. The array for a tree with height h will have h values and contains the values of the siblings of (that is, is adjacent to) the nodes on the path from the leaf to the root, where the sibling to node A is the other node that shares node A's parent. In the signature, 0 is counted from the bottom level of the tree, and so path[0] is the value of the node adjacent to leaf node q; path[1] is the second-level node that is adjacent to leaf node q's parent, and so on up the tree until we get to path[h-1], which is the value of the next-to-the-top-level node whose branch the leaf node q does not reside in.",
      "ja": "セクション3.3は正式lms_signature構造として署名のフォーマットを定義します。高さhを持つツリーのアレイは、h値を有するとの兄弟の値（すなわち、に隣接する）Aをノードに兄弟が他のノードであるルート、の葉からの経路上のノードが含まれています株式ノードAの親ています。署名では、0は、ツリーの最下位レベルから数えて、そのためのパス[0]リーフノードQに隣接するノードの値です。パス我々はパスされるまで[1]リーフノードQの親に隣接する第2レベルのノードである、というようにツリーアップ[H-1]、次ツー・トップの値でありますその枝の葉ノードqを内に存在していないレベルのノード。"
    },
    {
      "indent": 3,
      "text": "Below is a simple example of the authentication path for h=3 and q=2. The leaf marked OTS is the one-time signature that is used to sign the actual message. The nodes on the path from the OTS public key to the root are marked with a *, while the nodes that are used within the path array are marked with **. The values in the path array are those nodes that are siblings of the nodes on the path; path[0] is the leaf** node that is adjacent to the OTS public key (which is the start of the path); path[1] is the T[4]** node that is the sibling of the second node T[5]* on the path, and path[2] is the T[3]** node that is the sibling of the third node T[2]* on the path.",
      "ja": "以下、H = 3、Q = 2の認証パスの単純な例です。 OTSをマークされた葉は、実際のメッセージに署名するために使用されるワンタイム署名です。パスアレイ内で使用されているノードは**でマークされながらルートにOTS公開鍵からパス上のノードは、*が付いています。パス・アレイ内の値は、経路上のノードの兄弟であるこれらのノードです。パスは、[0]（パスの開始である）OTS公開鍵に隣接するリーフ**ノードです。経路[1]であるT [4] **第2のノードの兄弟であるノードT [5] *経路上、及びパス[2]がT [3] **の兄弟であるノード第3のノードT [2] *パスに。"
    },
    {
      "indent": 5,
      "text": "                           Root\n                            |\n            ---------------------------------\n            |                               |\n          T[2]*                          T[3]**\n            |                               |\n     ------------------            -----------------\n     |                |            |               |\n  T[4]**           T[5]*         T[6]            T[7]\n     |                |            |               |\n ---------       ----------     --------       ---------\n |       |       |        |     |      |       |       |\nleaf    leaf    OTS  leaf**   leaf   leaf    leaf    leaf",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The idea behind this authentication path is that it allows us to validate the OTS hash with using h path array values and hash computations. What the verifier does is recompute the hashes up the path; first, it hashes the given OTS and path[0] value, giving a tentative T[5]' value. Then, it hashes its path[1] and tentative T[5]' value to get a tentative T[2]' value. Then, it hashes that and the path[2] value to get a tentative Root' value. If that value is the known public key of the Merkle tree, then we can assume that the value T[2]' it got was the correct T[2] value in the original tree, and so the T[5]' value it got was the correct T[5] value in the original tree, and so the OTS public key is the same as in the original and, hence, is correct.",
      "ja": "この認証パスの背後にある考え方は、それが私たちは、Hパスアレイ値とハッシュ計算を用いてOTSのハッシュを検証することを可能にすることです。どのような検証を行うことは、パスアップハッシュを再計算です。まず、仮T [5]」値を与える、[0]の値が所定のOTSとパスをハッシュ。そして、その経路[1]及び仮T [5]の値「値が仮T [2]を取得する」ハッシュ。そして、仮ルート」の値を取得する[2]の値と、そのパスをハッシュ。その値は、Merkle木の知られている公開鍵であれば、我々はT [2]が値「それはだが、元のツリー内の正しいT [2]の値だったので、T [5]」と仮定することができ、それ値GOTは、元のツリー内の正しいT [5]の値であり、そうOTS公開鍵は、したがって、正しい、元と同じであると。"
    },
    {
      "indent": 0,
      "text": "5.4.1. LMS Signature Generation",
      "section_title": true,
      "ja": "5.4.1。 LMSの署名生成"
    },
    {
      "indent": 3,
      "text": "To compute the LMS signature of a message with an LMS private key, the signer first computes the LM-OTS signature of the message using the leaf number of the next unused LM-OTS private key. The leaf number q in the signature is set to the leaf number of the LMS private key that was used in the signature. Before releasing the signature, the leaf number q in the LMS private key MUST be incremented to prevent the LM-OTS private key from being used again. If the LMS private key is maintained in nonvolatile memory, then the implementation MUST ensure that the incremented value has been stored before releasing the signature. The issue this tries to prevent is a scenario where a) we generate a signature using one LM-OTS private key and release it to the application, b) before we update the nonvolatile memory, we crash, and c) we reboot and generate a second signature using the same LM-OTS private key. With two different signatures using the same LM-OTS private key, an attacker could potentially generate a forged signature of a third message.",
      "ja": "LMS秘密鍵でメッセージのLMS署名を計算するために、署名者は、第一次の未使用のLM-OTS秘密鍵の葉の数を使用してメッセージのLM-OTS署名を計算します。署名のリーフの数qは、署名に使用されたLMS秘密鍵の葉の数に設定されています。署名を解放する前に、LMSの秘密鍵で葉の数qが再び使用されているからLM-OTS秘密鍵を防ぐために増加しなければなりません。 LMS秘密鍵は、不揮発性メモリに保持されている場合は、その実装は、インクリメントされた値が署名をリリースする前に保存されていることを保証しなければなりません。これは予防しようとする課題は、a）は、我々は1 LM-OTS秘密鍵を使って署名を生成し、アプリケーションにそれを解放し、私たちは、不揮発性メモリを更新する前にB）、我々はクラッシュ、およびc）我々が再起動し、生成したシナリオであります同じLM-OTSの秘密鍵を使用して第2の署名。同じLM-OTS秘密鍵を使用して、2つの異なるシグネチャを使用すると、攻撃者は、潜在的に第3のメッセージの偽造署名を生成することができます。"
    },
    {
      "indent": 3,
      "text": "The array of node values in the signature MAY be computed in any way. There are many potential time/storage trade-offs that can be applied. The fastest alternative is to store all of the nodes of the tree and set the array in the signature by copying them; pseudocode to do so appears in Appendix D. The least storage-intensive alternative is to recompute all of the nodes for each signature. Note that the details of this procedure are not important for interoperability; it is not necessary to know any of these details in order to perform the signature-verification operation. The internal nodes of the tree need not be kept secret, and thus a node-caching scheme that stores only internal nodes can sidestep the need for strong protections.",
      "ja": "署名のノード値の配列は、任意の方法で計算することができます。適用することができ、多くの潜在的な時間/ストレージのトレードオフがあります。最速の代替は、ツリーのすべてのノードを格納し、それらをコピーすることによって署名の配列を設定することです。そうする擬似コードは、少なくともストレージ集約型の代替は、各署名のためにすべてのノードを再計算することで、付録D.に表示されます。この手順の詳細については、相互運用性のために重要ではないことに注意してください。署名検証動作を実行するためにこれらの詳細のいずれかを知る必要はありません。ツリーの内部ノードは、このように強力な保護の必要性を回避することができる唯一の内部ノードを格納したノード・キャッシング・スキームを秘密にし、する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Several useful time/storage trade-offs are described in the \"Small-Memory LM Schemes\" section of [USPTO5432852].",
      "ja": "いくつかの有用な時間/ストレージのトレードオフは、[USPTO5432852]の「小メモリLMスキーム」セクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "5.4.2. LMS Signature Verification",
      "section_title": true,
      "ja": "5.4.2。 LMSの署名の確認"
    },
    {
      "indent": 3,
      "text": "An LMS signature is verified by first using the LM-OTS signature verification algorithm (Algorithm 4b) to compute the LM-OTS public key from the LM-OTS signature and the message. The value of that public key is then assigned to the associated leaf of the LMS tree, and then the root of the tree is computed from the leaf value and the array path[] as described in Algorithm 6 below. If the root value matches the public key, then the signature is valid; otherwise, the signature verification fails.",
      "ja": "LMS署名が最初LM-OTS署名とメッセージからLM-OTS公開鍵を計算するためにLM-OTS署名検証アルゴリズム（アルゴリズム4B）を用いて検証されます。以下のアルゴリズム6に記載のように[]その公開鍵の値は、LMSツリーの関連するリーフに割り当てられ、その後、ツリーのルートは、リーフ値とアレイ・パスから計算されます。ルート値は、公開鍵と一致した場合、署名が有効です。それ以外の場合は、署名の検証は失敗します。"
    },
    {
      "indent": 3,
      "text": "Algorithm 6: LMS Signature Verification",
      "ja": "アルゴリズム6：LMSの署名の確認"
    },
    {
      "indent": 5,
      "text": "1. If the public key is not at least eight bytes long, return INVALID.",
      "ja": "1.公開鍵は、少なくとも8バイト長ではありません、無効な戻ります。"
    },
    {
      "indent": 5,
      "text": "2. Parse pubtype, I, and T[1] from the public key as follows:",
      "section_title": true,
      "ja": "2.解析のpubtype、I、およびT [1]は次のように公開鍵から。"
    },
    {
      "indent": 8,
      "text": "a. pubtype = strTou32(first 4 bytes of public key)",
      "ja": "A。 pubtype = strTou32（公開鍵の最初の4バイト）"
    },
    {
      "indent": 8,
      "text": "b. ots_typecode = strTou32(next 4 bytes of public key)",
      "ja": "B。 ots_typecode = strTou32（公開鍵の次の4バイト）"
    },
    {
      "indent": 8,
      "text": "c. Set m according to pubtype, based on Table 2.",
      "ja": "C。 pubtypeに従ってMを設定し、表2に基づきます。"
    },
    {
      "indent": 8,
      "text": "d. If the public key is not exactly 24 + m bytes long, return INVALID.",
      "ja": "D。公開鍵は正確に24 + Mバイト長でない場合は、無効な戻り。"
    },
    {
      "indent": 8,
      "text": "e. I = next 16 bytes of the public key",
      "ja": "電子。 I公開鍵の=次の16のバイト"
    },
    {
      "indent": 8,
      "text": "f. T[1] = next m bytes of the public key",
      "ja": "F。 T公開鍵の[1] =次mバイト"
    },
    {
      "indent": 5,
      "text": "3. Compute the LMS Public Key Candidate Tc from the signature, message, identifier, pubtype, and ots_typecode, using Algorithm 6a.",
      "ja": "3.計算アルゴリズム部6aを用いて署名、メッセージ、識別子、pubtype、及びots_typecodeからLMS公開鍵候補Tcは、。"
    },
    {
      "indent": 5,
      "text": "4. If Tc is equal to T[1], return VALID; otherwise, return INVALID.",
      "section_title": true,
      "ja": "TcはT [1]に等しい場合4. VALID返します。そうでない場合は、無効な戻り。"
    },
    {
      "indent": 3,
      "text": "Algorithm 6a: Computing an LMS Public Key Candidate from a Signature, Message, Identifier, and Algorithm Typecodes",
      "ja": "アルゴリズム図6a：署名、メッセージ、識別子、およびアルゴリズム型コードからLMS公開鍵候補を計算"
    },
    {
      "indent": 5,
      "text": "1. If the signature is not at least eight bytes long, return INVALID.",
      "ja": "署名がない、少なくとも8バイトの長さである場合は1、無効な戻り。"
    },
    {
      "indent": 5,
      "text": "2. Parse sigtype, q, lmots_signature, and path from the signature as follows:",
      "ja": "2.解析のsigtype、Q、lmots_signature、署名からのパスを次のように"
    },
    {
      "indent": 8,
      "text": "a. q = strTou32(first 4 bytes of signature)",
      "ja": "A。 Q = strTou32（署名の最初の4バイト）"
    },
    {
      "indent": 8,
      "text": "b. otssigtype = strTou32(next 4 bytes of signature)",
      "ja": "B。 otssigtype = strTou32（署名の次の4バイト）"
    },
    {
      "indent": 8,
      "text": "c. If otssigtype is not the OTS typecode from the public key, return INVALID.",
      "ja": "C。公開鍵からOTS型コードがotssigtypeでない場合は、無効な戻り。"
    },
    {
      "indent": 8,
      "text": "d. Set n, p according to otssigtype and Table 1; if the signature is not at least 12 + n * (p + 1) bytes long, return INVALID.",
      "ja": "D。 P otssigtype表1によれば、nはセット。署名が長、少なくとも12 + N×（P + 1）バイトでない場合、INVALID返します。"
    },
    {
      "indent": 8,
      "text": "e. lmots_signature = bytes 4 through 7 + n * (p + 1) of signature",
      "ja": "電子。署名の7 + N×（P + 1）〜lmots_signature =バイト4"
    },
    {
      "indent": 8,
      "text": "f. sigtype = strTou32(bytes 8 + n * (p + 1)) through 11 + n * (p + 1) of signature)",
      "ja": "F。 sigtype = strTou32（バイト8 + N *（P + 1））11 + N *署名の（P + 1））を介して"
    },
    {
      "indent": 8,
      "text": "g. If sigtype is not the LM typecode from the public key, return INVALID.",
      "ja": "グラム。 sigtypeは、公開鍵からLM型コードでない場合は、無効な戻り。"
    },
    {
      "indent": 8,
      "text": "h. Set m, h according to sigtype and Table 2.",
      "ja": "時間。 sigtype及び表2によれば、M、Hを設定します。"
    },
    {
      "indent": 8,
      "text": "i. If q >= 2^h or the signature is not exactly 12 + n * (p + 1) + m * h bytes long, return INVALID.",
      "ja": "私。 Q> = 2 ^ Hまたは署名が正確でない場合12 + N *（P + 1）+ M * hでバイトの長さ、INVALID返します。"
    },
    {
      "indent": 8,
      "text": "j. Set path as follows: path[0] = next m bytes of signature path[1] = next m bytes of signature ... path[h-1] = next m bytes of signature",
      "ja": "J。設定パス次のようにパス[0] =署名経路署名の[1] =署名...パスの次のmバイト[H-1] =次mバイトの次のmバイト"
    },
    {
      "indent": 5,
      "text": "3. Kc = candidate public key computed by applying Algorithm 4b to the signature lmots_signature, the message, and the identifiers I, q",
      "ja": "3. Kcを署名lmots_signature、メッセージにアルゴリズム4Bを適用することにより計算=候補者の公開鍵、及び識別子I、Q"
    },
    {
      "indent": 5,
      "text": "4. Compute the candidate LMS root value Tc as follows: node_num = 2^h + q tmp = H(I || u32str(node_num) || u16str(D_LEAF) || Kc) i = 0 while (node_num > 1) { if (node_num is odd): tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||path[i]||tmp) else: tmp = H(I||u32str(node_num/2)||u16str(D_INTR)||tmp||path[i]) node_num = node_num/2 i = i + 1 } Tc = tmp",
      "ja": "4.計算次のように候補LMSルート値Tcは：NODE_NUM = 2 ^ H + Q TMP = H（I || u32str（NODE_NUM）|| u16str（D_LEAF）|| Kcの）I = 0一方（NODE_NUM> 1）{ （NODE_NUMが奇数である）場合：TMP = H（Iはu32str（NODE_NUM / 2 ||）|| u16str（D_INTR）||パス[I] || TMP）他：TMP = Hが（私は（u32strを|| NODE_NUM / 2 ）|| u16str（D_INTR）|| || TMPパス[I]）NODE_NUM = NODE_NUM / 2 I = I + 1}のTc = TMP"
    },
    {
      "indent": 5,
      "text": "5. Return Tc.",
      "section_title": true,
      "ja": "5.戻りTcが。"
    },
    {
      "indent": 0,
      "text": "6. Hierarchical Signatures",
      "section_title": true,
      "ja": "6.階層署名"
    },
    {
      "indent": 3,
      "text": "In scenarios where it is necessary to minimize the time taken by the public key generation process, the Hierarchical Signature System (HSS) can be used. This hierarchical scheme, which we describe in this section, uses the LMS scheme as a component. In HSS, we have a sequence of L LMS trees, where the public key for the first LMS tree is included in the public key of the HSS system, each LMS private key signs the next LMS public key, and the last LMS private key signs the actual message. For example, if we have a three-level hierarchy (L=3), then to sign a message, we would have:",
      "ja": "公開鍵生成処理にかかる時間を最小化する必要があるシナリオでは、階層署名システム（HSS）を用いることができます。我々は、このセクションで説明この階層方式は、成分としてLMS方式を使用します。 HSSでは、まずLMSツリーの公開鍵はHSSシステムは、各LMS秘密鍵兆候次のLMS公開鍵の公開鍵に含まれるLのLMSの木、一連の、そして最後のLMS秘密鍵の兆候を持っています実際のメッセージ。我々は、3レベルの階層（L = 3）がある場合、例えば、メッセージに署名するために、我々はだろう。"
    },
    {
      "indent": 6,
      "text": "The first LMS private key (level 0) signs a level 1 LMS public key.",
      "ja": "最初のLMSの秘密鍵（レベル0）レベル1 LMS公開鍵に署名します。"
    },
    {
      "indent": 6,
      "text": "The second LMS private key (level 1) signs a level 2 LMS public key.",
      "ja": "第LMS秘密鍵（レベル1）はレベル2 LMS公開鍵に署名します。"
    },
    {
      "indent": 6,
      "text": "The third LMS private key (level 2) signs the message.",
      "ja": "第LMS秘密鍵（レベル2）は、メッセージに署名します。"
    },
    {
      "indent": 3,
      "text": "The root of the level 0 LMS tree is contained in the HSS public key.",
      "ja": "レベル0 LMSツリーのルートは、HSS、公開鍵に含まれています。"
    },
    {
      "indent": 3,
      "text": "To verify the LMS signature, we would verify all the signatures:",
      "ja": "LMSの署名を検証するために、我々は、すべての署名を検証します："
    },
    {
      "indent": 6,
      "text": "We would verify that the level 1 LMS public key is correctly signed by the level 0 signature.",
      "ja": "私たちは、レベル1 LMS公開鍵が正しくレベル0署名によって署名されていることを確認します。"
    },
    {
      "indent": 6,
      "text": "We would verify that the level 2 LMS public key is correctly signed by the level 1 signature.",
      "ja": "私たちは、レベル2 LMS公開鍵が正しくレベル1の署名によって署名されていることを確認します。"
    },
    {
      "indent": 6,
      "text": "We would verify that the message is correctly signed by the level 2 signature.",
      "ja": "私たちは、メッセージが正しくレベル2の署名によって署名されていることを確認します。"
    },
    {
      "indent": 3,
      "text": "We would accept the HSS signature only if all the signatures validated.",
      "ja": "我々は、すべての署名が検証された場合にのみHSS署名を受け入れるだろう。"
    },
    {
      "indent": 3,
      "text": "During the signature-generation process, we sign messages with the lowest (level L-1) LMS tree. Once we have used all the leafs in that tree to sign messages, we would discard it, generate a fresh LMS tree, and sign it with the next (level L-2) LMS tree (and when that is used up, recursively generate and sign a fresh level L-2 LMS tree).",
      "ja": "署名生成プロセスの間に、我々は最も低い（レベルL-1）LMSツリーのメッセージに署名します。私たちがメッセージに署名するために、そのツリー内のすべての葉を使用していたら、私たちは、それを破棄し、新鮮なLMSツリーを生成し、次の（レベルL-2）とそれを署名するLMSツリー（とそれがアップに使用されたときに、再帰的に生成し、新鮮レベルL-2 LMSツリー）に署名。"
    },
    {
      "indent": 3,
      "text": "HSS, in essence, utilizes a tree of LMS trees. There is a single LMS tree at level 0 (the root). Each LMS tree (actually, the private key corresponding to the LMS tree) at level i is used to sign 2^h objects (where h is the height of trees at level i). If i < L-1, then each object will be another LMS tree (actually, the public key) at level i+1; if i = L-1, we've reached the bottom of the HSS tree, and so each object will be a message from the application. The HSS public key contains the public key of the LMS tree at the root, and an HSS signature is associated with a path from the root of the HSS tree to the leaf.",
      "ja": "HSSは、本質的には、LMSの木のツリーを利用しています。レベル0（ルート）で、単一のLMSの木があります。 （hは、レベルiにおける樹木の高さである）（実際には、LMSツリーに対応する秘密鍵）レベルでiが2 ^ Hオブジェクトに署名するために使用される各LMS木。 iがL-1 <場合、各オブジェクトは、レベルI + 1に別のLMSツリー（実際には、公開鍵）となります。私はL-1 =場合、我々はHSSツリーの最下部に達した、とので、各オブジェクトは、アプリケーションからのメッセージになります。 HSS公開鍵は、ルートにLMSツリーの公開鍵を含み、HSS署名が葉にHSSツリーのルートからのパスに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Compared to LMS, HSS has a much reduced public key generation time, as only the root tree needs to be generated prior to the distribution of the HSS public key. For example, an L=3 tree (with h=10 at each level) would have one level 0 LMS tree, 2^10 level 1 LMS trees (with each such level 1 public key signed by one of the 1024 level 0 OTS public keys), and 2^20 level 2 LMS trees. Only 1024 OTS public keys need to be computed to generate the HSS public key (as you need to compute only the level 0 LMS tree to compute that value; you can, of course, decide to compute the initial level 1 and level 2 LMS trees). In addition, the 2^20 level 2 LMS trees can jointly sign a total of over a billion messages. In contrast, a single LMS tree that could sign a billion messages would require a billion OTS public keys to be computed first (if h=30 were allowed in a supported parameter set).",
      "ja": "唯一のルートツリー前HSS公開鍵の配布を生成する必要があるとしてLMSに比べ、HSSは、非常に減少公開鍵生成時間を有します。例えば、（各レベルで、H = 10を有する）L = 3ツリーは、1024レベル0 OTSの公共のいずれかによって署名されたような各レベル1の公開鍵であるレベル0 LMSツリー、2 ^ 10レベル1 LMSの木（だろうキー）、及び2 ^ 20レベル2 LMS木。あなたは、その値を計算するためにのみレベル0 LMSツリー計算する必要があるとしてのみ1024 OTS公開鍵は、（HSS公開鍵を生成するために計算する必要がある、あなたは、もちろん、最初のレベル1とレベル2 LMSの木を計算することを決定することができます）。また、2 ^ 20レベル2 LMSツリーが共同億を超えるメッセージの合計に署名することができます。対照的に、十億メッセージに署名することができ、単一のLMSツリーは（H = 30が支持されたパラメータセットに許可された場合）最初に計算される公開鍵億OTSを必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "Each LMS tree within the hierarchy is associated with a distinct LMS public key, private key, signature, and identifier. The number of levels is denoted as L and is between one and eight, inclusive. The following notation is used, where i is an integer between 0 and L-1 inclusive, and the root of the hierarchy is level 0:",
      "ja": "階層内の各LMSツリーは異なるLMS公開鍵、秘密鍵、署名、及び識別子に関連付けられています。レベルの数はLと表記と、1から8の間で包括的です。 ：iが0とL-1までの整数であり、階層のルートは、レベル0である場合、以下の表記が使用され"
    },
    {
      "indent": 6,
      "text": "prv[i] is the current LMS private key of the i-th level.",
      "ja": "PRV [i]はi番目のレベルの現在のLMS秘密鍵です。"
    },
    {
      "indent": 6,
      "text": "pub[i] is the current LMS public key of the i-th level, as described in Section 5.3.",
      "ja": "セクション5.3で説明したようにパブ[i]は、i番目のレベルの現在のLMS公開鍵です。"
    },
    {
      "indent": 6,
      "text": "sig[i] is the LMS signature of public key pub[i+1] generated using the private key prv[i].",
      "ja": "SIGは、[i]は、秘密鍵PRV [I]を使用してLMSの公開鍵パブの署名[I + 1]が生成されます。"
    },
    {
      "indent": 3,
      "text": "It is expected that the above arrays are maintained for the course of the HSS key. The contents of the prv[] array MUST be kept private; the pub[] and sig[] array may be revealed should the implementation find that convenient.",
      "ja": "なお、上記アレイはHSSキーのコースのために維持されることが期待されます。 PRV []配列の内容は非公開にされなければなりません。パブ[]とsigを[]配列は、実装がその便利を見つける必要が明らかにされてもよいです。"
    },
    {
      "indent": 3,
      "text": "In this section, we say that an N-time private key is exhausted when it has generated N signatures; thus, it can no longer be used for signing.",
      "ja": "このセクションでは、我々はそれがN署名を生成したときN-時間秘密鍵が排出されることを言います。したがって、それはもはや署名に使用することはできません。"
    },
    {
      "indent": 3,
      "text": "For i > 0, the values prv[i], pub[i], and (for all values of i) sig[i] will be updated over time as private keys are exhausted and replaced by newer keys.",
      "ja": "I> 0の場合、値は[i]は、パブ[i]は、と（私のすべての値に対して）SIG秘密鍵が枯渇し、新しいキーに置き換えられているよう[i]は時間をかけて更新されますがPRV。"
    },
    {
      "indent": 3,
      "text": "When these key pairs are updated (or initially generated before the first message is signed), then the LMS key generation processes outlined in Sections 5.2 and 5.3 are performed. If the generated key pairs are for level i of the HSS hierarchy, then we store the public key in pub[i] and the private key in prv[i]. In addition, if i > 0, then we sign the generated public key with the LMS private key at level i-1, placing the signature into sig[i-1]. When the LMS key pair is generated, the key pair and the corresponding identifier MUST be generated independently of all other key pairs.",
      "ja": "（最初のメッセージが署名される前、または最初に生成）するとき、これらの鍵ペアは、その後、セクション5.2および5.3に概説LMS鍵生成処理が実行され、更新されます。生成した鍵ペアは、HSS階層のレベルのために、私の場合は、我々は、[i]はパブでの公開鍵[i]とPRVで秘密鍵を格納します。また、I> 0の場合、我々は[I-1] SIGに署名を配置、レベルI-1におけるLMS秘密鍵で生成された公開鍵に署名します。 LMS鍵ペアが生成されると、鍵ペアおよび対応する識別子は、独立して、他のすべての鍵ペアを生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "HSS allows L=1, in which case the HSS public key and signature formats are essentially the LMS public key and signature formats, prepended by a fixed field. Since HSS with L=1 has very little overhead compared to LMS, all implementations MUST support HSS in order to maximize interoperability.",
      "ja": "HSSは、HSS公開鍵と署名フォーマットは、本質的に一定の電界によって付加LMS公開鍵と署名フォーマットである場合にはL = 1を、可能にします。 L = 1のHSSは、LMSに比べて非常に少ないオーバーヘッドを有しているので、すべての実装は、相互運用性を最大にするためにHSSをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "We specifically allow different LMS levels to use different parameter sets. For example, the 0-th LMS public key (the root) may use the LMS_SHA256_M32_H15 parameter set, while the 1-th public key may use LMS_SHA256_M32_H10. There are practical reasons to allow this; for one, the signer may decide to store parts of the 0-th LMS tree (that it needs to construct while computing the public key) to accelerate later operations. As the 0-th tree is never updated, these internal nodes will never need to be recomputed. In addition, during the signature-generation operation, almost all the operations involved with updating the authentication path occur with the bottom (L-1th) LMS public key; hence, it may be useful to select the parameter set for that public key to have a shorter LMS tree.",
      "ja": "我々は、特に異なるLMSレベルが異なるパラメータセットを使用することができます。 1番目の公開鍵がLMS_SHA256_M32_H10を使用することができながら、例えば、0番目のLMS公開鍵（ルート）は、LMS_SHA256_M32_H15パラメータセットを使用してもよいです。これを許可するための実用的な理由があります。一方に、署名者は、後の操作を加速する（公開鍵を計算しながら、それが構築する必要がある）0番目LMSツリーの部分を格納することを決定することができます。 0番目のツリーが更新されることはありませんように、これらの内部ノードを再計算する必要はありません。また、署名生成動作中、認証パスの更新に関わるほとんどすべての操作は、底部（L-1番目）LMS公開鍵で起こります。したがって、短いLMSの木を持っているために、その公開鍵のパラメータセットを選択することが有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "A close reading of the HSS verification pseudocode shows that it would allow the parameters of the nontop LMS public keys to change over time; for example, the signer might initially have the 1-th LMS public key use the LMS_SHA256_M32_H10 parameter set, but when that tree is exhausted, the signer might replace it with an LMS public key that uses the LMS_SHA256_M32_H15 parameter set. While this would work with the example verification pseudocode, the signer MUST NOT change the parameter sets for a specific level. This prohibition is to support verifiers that may keep state over the course of several signature verifications.",
      "ja": "HSS検証擬似コードの近い読書はそれがnontop LMS公開鍵のパラメータが時間とともに変化することができるようになることを示しています。例えば、署名者は、最初にLMS_SHA256_M32_H10パラメータセット1回目のLMSの公開鍵を使用している場合がありますが、その木がなくなったとき、署名者はLMS_SHA256_M32_H15パラメータセットを使用してLMS公開鍵でそれを置き換えることがあります。これは例の検証擬似コードで動作するだろうが、署名者は、特定のレベルのためのパラメータセットを変更しないでください。この禁止は、いくつかの署名検証の過程で状態を保つことが検証をサポートすることです。"
    },
    {
      "indent": 0,
      "text": "6.1. Key Generation",
      "section_title": true,
      "ja": "6.1。キー生成"
    },
    {
      "indent": 3,
      "text": "The public key of the HSS scheme consists of the number of levels L, followed by pub[0], the public key of the top level.",
      "ja": "HSS方式の公開鍵は、トップレベルの[0]、公開鍵パブ続いレベルLの数、から成ります。"
    },
    {
      "indent": 3,
      "text": "The HSS private key consists of prv[0], ... , prv[L-1], along with the associated pub[0], ... pub[L-1] and sig[0], ..., sig[L-2] values. As stated earlier, the values of the pub[] and sig[] arrays need not be kept secret and may be revealed. The value of pub[0] does not change (and, except for the index q, the value of prv[0] need not change); however, the values of pub[i] and prv[i] are dynamic for i > 0 and are changed by the signature-generation algorithm.",
      "ja": "HSS秘密鍵は、PRVから成る[0]、...、関連パブ[0]、...パブ[L-1]とSIGと共にPRV [L-1]、[0]、...、 SIG [L-2]の値。先に述べたように、パブ[]及びSIG []アレイの値は秘密にする必要はないと明らかにすることができます。パブの値が[0]に変更（及び、指標Qを除いて、PRVの値[0]を変更する必要はない）しません。しかし、パブ[i]とPRV [I]の値は、I> 0のための動的であり、署名生成アルゴリズムによって変更されます。"
    },
    {
      "indent": 3,
      "text": "During the key generation, the public and private keys are initialized. Here is some pseudocode that explains the key-generation logic:",
      "ja": "鍵の生成時には、公開鍵と秘密鍵が初期化されます。ここで鍵生成ロジックを説明し、いくつかの擬似コードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Algorithm 7: Generating an HSS Key Pair",
      "ja": "アルゴリズム7：HSS鍵ペアの生成"
    },
    {
      "indent": 5,
      "text": "1. Generate an LMS key pair, as specified in Sections 5.2 and 5.3, placing the private key into priv[0], and the public key into pub[0]",
      "ja": "1. [0] PRIVにプライベートキー[0]、およびパブに公開鍵を配置し、セクション5.2および5.3に指定されているように、LMSの鍵ペアを生成します"
    },
    {
      "indent": 5,
      "text": "2. For i = 1 to L-1 do { generate an LMS key pair, placing the private key into priv[i] and the public key into pub[i]",
      "ja": "L-1のiについて2 = 1 {PRIV [i]とパブに公開鍵に秘密鍵を置くこと、LMS鍵ペアを生成しない[I]"
    },
    {
      "indent": 8,
      "text": " sig[i-1] = lms_signature( pub[i], priv[i-1] ) }",
      "ja": "SIGは[I-1] = lms_signature（パブ[i]は、PRIV [I-1]）}"
    },
    {
      "indent": 5,
      "text": "3. Return u32str(L) || pub[0] as the public key and the priv[], pub[], and sig[] arrays as the private key",
      "ja": "3.戻りu32str（L）||公開鍵およびpriv []、パブ、[]、および秘密鍵と[]の配列をsigをとしてパブ[0]"
    },
    {
      "indent": 3,
      "text": "In the above algorithm, each LMS public/private key pair generated MUST be generated independently.",
      "ja": "上記のアルゴリズムでは、生成された各LMS公開/秘密鍵ペアが独立に生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the value of the public key does not depend on the execution of step 2. As a result, an implementation may decide to delay step 2 until later -- for example, during the initial signature-generation operation.",
      "ja": "例えば、最初の署名生成動作中 - 公開鍵の値は、結果としてステップ2の実行に依存しない、実装は後になるまでステップ2を遅らせることを決定してもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "6.2. Signature Generation",
      "section_title": true,
      "ja": "6.2。署名生成"
    },
    {
      "indent": 3,
      "text": "To sign a message using an HSS key pair, the following steps are performed:",
      "ja": "HSS鍵ペアを使用してメッセージに署名するために、以下のステップが実行されます。"
    },
    {
      "indent": 6,
      "text": "If prv[L-1] is exhausted, then determine the smallest integer d such that all of the private keys prv[d], prv[d+1], ... , prv[L-1] are exhausted. If d is equal to zero, then the HSS key pair is exhausted, and it MUST NOT generate any more signatures. Otherwise, the key pairs for levels d through L-1 must be regenerated during the signature-generation process, as follows. For i from d to L-1, a new LMS public and private key pair with a new identifier is generated, pub[i] and prv[i] are set to those values, then the public key pub[i] is signed with prv[i-1], and sig[i-1] is set to the resulting value.",
      "ja": "PRV [L-1]が排出される場合、最小の整数dを決定する秘密鍵の全てが[D]、PRV [D + 1] PRVように、...、PRV [L-1]は排出されます。 dがゼロに等しい場合、HSS鍵ペアが排出される、そしてそれはそれ以上の署名を生成してはいけません。次のようにそうでなければ、L-1を介してdのレベルのための鍵ペアは、署名生成プロセスの間に再生されなければなりません。 I DからL-1までのために、新しい識別子を有する新しいLMS公開鍵と秘密鍵のペアが生成され、パブ[i]とPRV [I]はこれらの値に設定され、その後、公開鍵パブ[I]はで署名されていますPRV [I-1]、およびSIGは[I-1]得られた値に設定されています。"
    },
    {
      "indent": 6,
      "text": "The message is signed with prv[L-1], and the value sig[L-1] is set to that result.",
      "ja": "メッセージは、PRV [L-1]で署名され、そして値SIG [L-1]はその結果に設定されています。"
    },
    {
      "indent": 6,
      "text": "The value of the HSS signature is set as follows. We let signed_pub_key denote an array of octet strings, where signed_pub_key[i] = sig[i] || pub[i+1], for i between 0 and Nspk-1, inclusive, where Nspk = L-1 denotes the number of signed public keys. Then the HSS signature is u32str(Nspk) || signed_pub_key[0] || ... || signed_pub_key[Nspk-1] || sig[Nspk].",
      "ja": "次のようにHSS署名の値が設定されています。我々はsigned_pub_keyオクテットストリング、signed_pub_key [I] = SIG [I] ||の配列を示すものとI Nspk = L-1は、署名された公開鍵の数を表し、0とNspk-1、包括的、間パブ[I + 1]。次いでHSS署名はu32str（Nspk）であり、|| signed_pub_key [0] || ... || signed_pub_key [Nspk-1] || SIG [Nspk]。"
    },
    {
      "indent": 6,
      "text": "Note that the number of signed_pub_key elements in the signature is indicated by the value Nspk that appears in the initial four bytes of the signature.",
      "ja": "署名でsigned_pub_key要素の数は、署名の最初の4バイトに表示される値Nspkによって示されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Here is some pseudocode of the above logic:",
      "ja": "ここでは上記のロジックのいくつかの擬似コードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Algorithm 8: Generating an HSS signature",
      "ja": "アルゴリズム8：HSSの署名を生成します"
    },
    {
      "indent": 5,
      "text": "1. If the message-signing key prv[L-1] is exhausted, regenerate that key pair, together with any parent key pairs that might be necessary.",
      "ja": "1.メッセージ署名鍵PRV [L-1]は排出される場合、一緒に必要になる可能性がある親キーのペアと、その鍵ペアを再生成します。"
    },
    {
      "indent": 8,
      "text": "If the root key pair is exhausted, then the HSS key pair is exhausted and MUST NOT generate any more signatures.",
      "ja": "ルート鍵ペアが排出される場合には、HSS鍵のペアが消耗していると、それ以上の署名を生成してはなりません。"
    },
    {
      "indent": 8,
      "text": "d = L while (prv[d-1].q == 2^(prv[d-1].h)) { d = d - 1 if (d == 0) return FAILURE } while (d < L) { create lms key pair pub[d], prv[d] sig[d-1] = lms_signature( pub[d], prv[d-1] ) d = d + 1 }",
      "ja": "D = L（PRV [D-1] .Q == 2 ^（PRV [D-1]・H））、一方 - （D <L）、一方{D = D 1の場合（D == 0）戻りFAILURE} {[D] SIG [D-1] = lms_signature（パブ[D]、PRV [D-1]）、D = D + 1 PRV、LMSに鍵ペアパブ[D]を作成}"
    },
    {
      "indent": 5,
      "text": "2. Sign the message. sig[L-1] = lms_signature( msg, prv[L-1] )",
      "ja": "2.メッセージに署名します。 SIG [L-1] = lms_signature（MSG、PRV [L-1]）"
    },
    {
      "indent": 5,
      "text": "3. Create the list of signed public keys. i = 0; while (i < L-1) { signed_pub_key[i] = sig[i] || pub[i+1] i = i + 1 }",
      "ja": "3.署名の公開鍵のリストを作成します。 I = 0; [I]（iはL-1 <）{signed_pub_key [I] = SIG一方||パブ[I + 1] = iはiは} 1 +"
    },
    {
      "indent": 5,
      "text": "4. Return u32str(L-1) || signed_pub_key[0] || ... || signed_pub_key[L-2] || sig[L-1]",
      "ja": "4.戻りu32str（L-1）|| signed_pub_key [0] || ... || signed_pub_key [L-2] || SIG [L-1]"
    },
    {
      "indent": 3,
      "text": "In the specific case of L=1, the format of an HSS signature is",
      "ja": "L = 1の特定の場合には、HSS署名の形式であります"
    },
    {
      "indent": 5,
      "text": "u32str(0) || sig[0]",
      "ja": "u32str（0）||アウト[0]"
    },
    {
      "indent": 3,
      "text": "In the general case, the format of an HSS signature is",
      "ja": "一般的な場合では、HSS署名の形式であります"
    },
    {
      "indent": 5,
      "text": "u32str(Nspk) || signed_pub_key[0] || ... || signed_pub_key[Nspk-1] || sig[Nspk]",
      "ja": "u32str（Nspk）|| signed_pub_key [0] || ... || signed_pub_key [Nspk-1] || SIG [Nspk]"
    },
    {
      "indent": 3,
      "text": "which is equivalent to",
      "ja": "に相当します"
    },
    {
      "indent": 5,
      "text": "u32str(Nspk) || sig[0] || pub[1] || ... || sig[Nspk-1] || pub[Nspk] || sig[Nspk]",
      "ja": "u32str（Nspk）||アウト[0] ||パブ[1] || ... ||見つかりました[Nspk-1] ||パブ[Nspk] ||見つかった[Nspk]"
    },
    {
      "indent": 0,
      "text": "6.3. Signature Verification",
      "section_title": true,
      "ja": "6.3。署名検証"
    },
    {
      "indent": 3,
      "text": "To verify a signature S and message using the public key pub, perform the following steps:",
      "ja": "公開鍵パブを使用して、署名Sとメッセージを確認するには、次の手順を実行します。"
    },
    {
      "indent": 5,
      "text": "The signature S is parsed into its components as follows:",
      "ja": "次のように署名Sは、その成分に解析されます。"
    },
    {
      "indent": 5,
      "text": "Nspk = strTou32(first four bytes of S) if Nspk+1 is not equal to the number of levels L in pub: return INVALID for (i = 0; i < Nspk; i = i + 1) { siglist[i] = next LMS signature parsed from S publist[i] = next LMS public key parsed from S } siglist[Nspk] = next LMS signature parsed from S",
      "ja": "Nspk = strTou32（Sの最初の4バイト）Nspk + 1は、パブでレベルLの数に等しくない場合：の無効なリターン（i = 0; iがNspkを<; I = I + 1）{siglist [I] = Sのpublistから解析次LMS署名Sから解析S} siglist [Nspk] =次のLMS署名から解析[I] =次のLMS公開鍵"
    },
    {
      "indent": 5,
      "text": "key = pub for (i = 0; i < Nspk; i = i + 1) { sig = siglist[i] msg = publist[i] if (lms_verify(msg, key, sig) != VALID): return INVALID key = msg } return lms_verify(message, key, siglist[Nspk])",
      "ja": "以下のためのキー=パブ（; iはNspkを<; I = 0、I = I + 1）{SIG = siglist [i]はMSG = publist [i]の場合（lms_verify（MSG、キー、SIG）= VALID！）：無効なキーを返します= MSG} lms_verify返す（メッセージ、キー、siglist [Nspk]）"
    },
    {
      "indent": 3,
      "text": "Since the length of an LMS signature cannot be known without parsing it, the HSS signature verification algorithm makes use of an LMS signature parsing routine that takes as input a string consisting of an LMS signature with an arbitrary string appended to it and returns both the LMS signature and the appended string. The latter is passed on for further processing.",
      "ja": "LMS署名の長さは、それを解析することなく知ることができないため、HSS署名検証アルゴリズムは、LMSの両方を入力としてそれに添付任意の文字列でLMS署名からなる文字列を受け取り、返しLMSシグネチャ解析ルーチンを利用します署名および添付のストリング。後者は、さらなる処理のために渡されます。"
    },
    {
      "indent": 0,
      "text": "6.4. Parameter Set Recommendations",
      "section_title": true,
      "ja": "6.4。パラメータセットの推奨事項"
    },
    {
      "indent": 3,
      "text": "As for guidance as to the number of LMS levels and the size of each, any discussion of performance is implementation specific. In general, the sole drawback for a single LMS tree is the time it takes to generate the public key; as every LM-OTS public key needs to be generated, the time this takes can be substantial. For a two-level tree, only the top-level LMS tree and the initial bottom-level LMS tree need to be generated initially (before the first signature is generated); this will in general be significantly quicker.",
      "ja": "LMSレベルの数とそれぞれのサイズについてのガイダンスについては、パフォーマンスの任意の議論は、実装固有です。一般に、単一のLMSツリーの唯一の欠点は、公開鍵を生成するのに要する時間です。すべてのLM-OTS公開鍵を生成する必要があるとして、これにかかる時間が大幅にすることができます。二レベル・ツリーのトップレベルLMSツリーと初期ボトムレベルLMSツリーのみが（最初の署名が生成される前に）最初に生成される必要があります。これは、一般的には大幅に速くなります。"
    },
    {
      "indent": 3,
      "text": "To give a general idea of the trade-offs available, we include some measurements taken with the LMS implementation available at <https://github.com/cisco/hash-sigs>, taken on a 3.3 GHz Xeon processor with threading enabled. We tried various parameter sets, all with W=8 (which minimizes signature size, while increasing time). These are here to give a guideline as to what's possible; for the computational time, your mileage may vary, depending on the computing resources you have. The machine these tests were performed on does not have the SHA-256 extensions; you could possibly do significantly better.",
      "ja": "利用可能なトレードオフの一般的なアイデアを与えるために、我々は有効なスレッドで3.3 GHzのXeonプロセッサ上で撮影した<https://github.com/cisco/hash-sigs>で入手可能なLMSの実装、で撮影したいくつかの測定が含まれます。我々は、すべてのW = 8（その時間を増加させながら、署名のサイズを最小化する）と、様々なパラメータセットを試してみました。これらは、可能な何についての指針を与えるためにここにいます。計算時間のために、あなたの走行距離は、使用しているコンピューティング・リソースに応じて、異なる場合があります。マシンは、これらのテストは、SHA-256の拡張機能を持っていないに行われました。あなたは、おそらくかなり良く行うことができます。"
    },
    {
      "indent": 13,
      "text": "+---------+------------+---------+-------------+\n| ParmSet | KeyGenTime | SigSize | KeyLifetime |\n+---------+------------+---------+-------------+\n| 15      | 6 sec      | 1616    | 30 seconds  |\n|         |            |         |             |\n| 20      | 3 min      | 1776    | 16 minutes  |\n|         |            |         |             |\n| 25      | 1.5 hour   | 1936    | 9 hours     |\n|         |            |         |             |\n| 15/10   | 6 sec      | 3172    | 9 hours     |\n|         |            |         |             |\n| 15/15   | 6 sec      | 3332    | 12 days     |\n|         |            |         |             |\n| 20/10   | 3 min      | 3332    | 12 days     |\n|         |            |         |             |\n| 20/15   | 3 min      | 3492    | 1 year      |\n|         |            |         |             |\n| 25/10   | 1.5 hour   | 3492    | 1 year      |\n|         |            |         |             |\n| 25/15   | 1.5 hour   | 3652    | 34 years    |\n+---------+------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 3,
      "text": "ParmSet: this is the height of the Merkle tree(s); parameter sets listed as a single integer have L=1 and consist of a single Merkle tree of that height; parameter sets with L=2 are listed as x/y, with x being the height of the top-level Merkle tree and y being the bottom level.",
      "ja": "ParmSet：これはマークル木（複数可）の高さです。単一の整数としてリストされたパラメータセットは、L = 1を有し、その高さの単一マークル木から成ります。 L = 2のパラメータセットは、xは、トップレベルのマークル木の高さであり、かつyはボトムレベルであると、X / Yとして記載されています。"
    },
    {
      "indent": 3,
      "text": "KeyGenTime: the measured key-generation time; that is, the time needed to generate the public/private key pair.",
      "ja": "KeyGenTime：測定された鍵生成時。それは、公開鍵/秘密鍵のペアを生成するのに必要な時間です。"
    },
    {
      "indent": 3,
      "text": "SigSize: the size of a signature (in bytes)",
      "ja": "SigSize：（バイト）署名のサイズ"
    },
    {
      "indent": 3,
      "text": "KeyLifetime: the lifetime of a key, assuming we generated 1000 signatures per second. In practice, we're not likely to get anywhere close to 1000 signatures per second sustained; if you have a more appropriate figure for your scenario, this column is easy to recompute.",
      "ja": "KeyLifetime：キーの有効期間、我々は毎秒1000人の署名を生成したと仮定。実際には、我々は、第二の持続的な1000人の署名にどこか近くに取得する可能性じゃありません。あなたのシナリオのより適切な数字を持っている場合、この列には、再計算することは容易です。"
    },
    {
      "indent": 3,
      "text": "As for signature generation or verification times, those are moderately insensitive to the above parameter settings (except for the Winternitz setting and the number of Merkle trees for verification). Tests on the same machine (without multithreading) gave approximately 4 msec to sign a short message, 2.6 msec to verify; these tests used a two-level ParmSet; a single level would approximately halve the verification time. All times can be significantly improved (by perhaps a factor of 8) by using a parameter set with W=4; however, that also about doubles the signature size.",
      "ja": "署名生成や検証回として、それらは、（Winternitz設定および検証のためのマークル木の数を除く）上記パラメータの設定に適度に鈍感です。 （マルチスレッドなし）同じマシン上でテストが確認するため、2.6ミリ秒の短いメッセージに署名するために約4ミリ秒を与えました。これらの試験は、2レベルのParmSetを用います。シングルレベルは約検証時間を半減させるだろう。全ての時間は大幅W = 4で設定されたパラメータを用いて、（8おそらく倍）に向上させることができます。しかし、それはまた、約署名サイズが倍になります。"
    },
    {
      "indent": 0,
      "text": "7. Rationale",
      "section_title": true,
      "ja": "7.理論的根拠"
    },
    {
      "indent": 3,
      "text": "The goal of this note is to describe the LM-OTS, LMS, and HSS algorithms following the original references and present the modern security analysis of those algorithms. Other signature methods are out of scope and may be interesting follow-on work.",
      "ja": "このノートの目標は、元の参照、以下LM-OTS、LMS、およびHSSアルゴリズムを記述し、これらのアルゴリズムの近代的なセキュリティ分析を提示することです。他の署名法は適用範囲外であると、後続の仕事は興味深いかもしれません。"
    },
    {
      "indent": 3,
      "text": "We adopt the techniques described by Leighton and Micali to mitigate attacks that amortize their work over multiple invocations of the hash function.",
      "ja": "私たちは、ハッシュ関数の複数の呼び出しを介して自分の仕事を償却攻撃を軽減するために、レイトンとMicaliによって記載されている技術を採用しています。"
    },
    {
      "indent": 3,
      "text": "The values taken by the identifier I across different LMS public/ private key pairs are chosen randomly in order to improve security. The analysis of this method in [Fluhrer17] shows that we do not need uniqueness to ensure security; we do need to ensure that we don't have a large number of private keys that use the same I value. By randomly selecting 16-byte I values, the chance that, out of 2^64 private keys, 4 or more of them will use the same I value is negligible (that is, has probability less than 2^-128).",
      "ja": "異なるLMS公開鍵/秘密鍵のペアを越えた識別子Iが取る値は、セキュリティを向上させるために、ランダムに選択されています。私たちは、セキュリティを確保するために一意性を必要としない[Fluhrer17]のショーでは、この方法の分析。我々は同じI値を使用する秘密鍵の多数を持っていないことを確認する必要があります。ランダムに16バイトのIの値を選択することで、チャンスは2 ^ 64の秘密鍵のうち、それらの4以上が同一のI値は無視できる使用する、ということ（つまり、確率未満2 ^ -128を持っています）。"
    },
    {
      "indent": 3,
      "text": "The reason 16-byte I values were selected was to optimize the Winternitz hash-chain operation. With the current settings, the value being hashed is exactly 55 bytes long (for a 32-byte hash function), which SHA-256 can hash in a single hash-compression operation. Other hash functions may be used in future specifications; all the ones that we will be likely to support (SHA-512/256 and the various SHA-3 hashes) would work well with a 16-byte I value.",
      "ja": "16バイトのI値を選択した理由はWinternitzハッシュチェーン動作を最適化することでした。現在の設定で、ハッシュされた値は、SHA-256は、単一のハッシュ圧縮動作でハッシュすることができ、（32バイトのハッシュ関数の）正確に55バイト長です。他のハッシュ関数は、将来の仕様で使用することができます。我々は（SHA-256分の512と、様々なSHA-3ハッシュ）をサポートする可能性が高いだろうすべてのものは16バイトのI値とうまく動作します。"
    },
    {
      "indent": 3,
      "text": "The signature and public key formats are designed so that they are relatively easy to parse. Each format starts with a 32-bit enumeration value that indicates the details of the signature algorithm and provides all of the information that is needed in order to parse the format.",
      "ja": "彼らは解析が比較的容易になるように、署名と公開鍵のフォーマットが設計されています。各フォーマットは、署名アルゴリズムの詳細を示し、形式を解析するために必要な情報の全てを提供する32ビットの列挙値で始まります。"
    },
    {
      "indent": 3,
      "text": "The Checksum (Section 4.4) is calculated using a nonnegative integer \"sum\" whose width was chosen to be an integer number of w-bit fields such that it is capable of holding the difference of the total possible number of applications of the function H (as defined in the signing algorithm of Section 4.5) and the total actual number. In the case that the number of times H is applied is 0, the sum is (2^w - 1) * (8*n/w). Thus, for the purposes of this document, which describes signature methods based on H = SHA256 (n = 32 bytes) and w = { 1, 2, 4, 8 }, the sum variable is a 16-bit nonnegative integer for all combinations of n and w. The calculation uses the parameter ls defined in Section 4.1 and calculated in Appendix B, which indicates the number of bits used in the left-shift operation.",
      "ja": "チェックサム（セクション4.4）は、その幅が関数H（のアプリケーションの合計の可能な数の差を保持することができるようにWビットフィールドの整数となるように選択された非負整数「和」を用いて計算されますセクション4.5の署名アルゴリズム）および総実際の数で定義されています。 *（8 * N / W） -  Hが印加された回数が0である場合には、合計は（1 2 ^ w）です。したがって、署名H = SHA256（N = 32バイト）に基づく方法であり、w =説明本文書の目的のため、{1、2、4、8}、和変数は全ての組み合わせのための16ビットの負でない整数でありますnおよびWの。計算パラメータLSセクション4.1で定義され、左シフト演算に使用されるビットの数を示し、付録Bで計算を使用します。"
    },
    {
      "indent": 0,
      "text": "7.1. Security String",
      "section_title": true,
      "ja": "7.1。セキュリティ文字列"
    },
    {
      "indent": 3,
      "text": "To improve security against attacks that amortize their effort against multiple invocations of the hash function, Leighton and Micali introduced a \"security string\" that is distinct for each invocation of that function. Whenever this process computes a hash, the string being hashed will start with a string formed from the fields below. These fields will appear in fixed locations in the value we compute the hash of, and so we list where in the hash these fields would be present. The fields that make up this string are as follows:",
      "ja": "ハッシュ関数の複数の呼び出しに対して、彼らの努力を償却攻撃に対するセキュリティを向上させるために、レイトンとMicaliは、その関数の呼び出しごとに別個である「セキュリティ文字列」を導入しました。このプロセスは、ハッシュを計算するたびに、ハッシュされている文字列は、以下のフィールドから形成された文字列で開始します。これらのフィールドは、我々はのハッシュを計算した値に固定された場所に表示され、ハッシュでこれらのフィールドが存在するであろう場所を私たちはリストアップ。次のようにこの文字列を構成するフィールドは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "I A 16-byte identifier for the LMS public/private key pair. It MUST be chosen uniformly at random, or via a pseudorandom process, at the time that a key pair is generated, in order to minimize the probability that any specific value of I be used for a large number of different LMS private keys. This is always bytes 0-15 of the value being hashed.",
      "ja": "I LMS公開鍵/秘密鍵のペアのための16バイトの識別子。これは、Iのいずれかの特定の値が別のLMS秘密鍵の多数のために使用することの確率を最小にするために、鍵のペアが生成される時に、ランダムに一様に選択された、または擬似ランダムプロセスを介して、しなければなりません。これは、常にハッシュ化された値の0〜15バイトです。"
    },
    {
      "indent": 3,
      "text": "r In the LMS N-time signature scheme, the node number r associated with a particular node of a hash tree is used as an input to the hash used to compute that node. This value is represented as a 32-bit (four byte) unsigned integer in network byte order. Either r or q (depending on the domain-separation parameter) will be bytes 16-19 of the value being hashed.",
      "ja": "LMS N-タイム署名方式において、Rは、ハッシュツリーの特定のノードに関連付けられているノードの数rは、そのノードを計算するために使用されるハッシュへの入力として使用されます。この値は、ネットワークバイト順で32ビット（4バイト）の符号なし整数として表現されます。 RまたはQ（ドメイン分離パラメータに依存する）のいずれかは、ハッシュされた値のバイト16-19であろう。"
    },
    {
      "indent": 3,
      "text": "q In the LMS N-time signature scheme, each LM-OTS signature is associated with the leaf of a hash tree, and q is set to the leaf number. This ensures that a distinct value of q is used for each distinct LM-OTS public/private key pair. This value is represented as a 32-bit (four byte) unsigned integer in network byte order. Either r or q (depending on the domain-separation parameter) will be bytes 16-19 of the value being hashed.",
      "ja": "LMS N-タイム署名方式では、Qは、各LM-OTS署名は、ハッシュツリーの葉に関連付けられ、そしてqがリーフ番号に設定されています。これは、Qの異なる値がそれぞれ異なるLM-OTS公開/秘密鍵ペアのために使用されることを保証します。この値は、ネットワークバイト順で32ビット（4バイト）の符号なし整数として表現されます。 RまたはQ（ドメイン分離パラメータに依存する）のいずれかは、ハッシュされた値のバイト16-19であろう。"
    },
    {
      "indent": 3,
      "text": "D A domain-separation parameter, which is a two-byte identifier that takes on different values in the different contexts in which the hash function is invoked. D occurs in bytes 20 and 21 of the value being hashed and takes on the following values:",
      "ja": "ハッシュ関数が呼び出された異なる状況において異なる値をとる2バイトの識別子であるD領域分離パラメータ。 Dは、バイト20およびハッシュされた値の21で発生し、次の値をとります。"
    },
    {
      "indent": 12,
      "text": "D_PBLC = 0x8080 when computing the hash of all of the\niterates in the LM-OTS algorithm",
      "raw": true
    },
    {
      "indent": 12,
      "text": "D_MESG = 0x8181 when computing the hash of the message in the LM-OTS algorithms",
      "ja": "D_MESG = 0x8181 LM-OTSアルゴリズムにおいてメッセージのハッシュを計算するとき"
    },
    {
      "indent": 12,
      "text": "D_LEAF = 0x8282 when computing the hash of the leaf of an LMS tree",
      "ja": "D_LEAF = 0x8282 LMSツリーの葉のハッシュを計算するとき"
    },
    {
      "indent": 12,
      "text": "D_INTR = 0x8383 when computing the hash of an interior node of an LMS tree",
      "ja": "D_INTR = 0x8383 LMSツリーの内部ノードのハッシュを計算するとき"
    },
    {
      "indent": 3,
      "text": "i A value between 0 and 264; this is used in the LM-OTS scheme when either computing the iterations of the Winternitz chain or using the suggested LM-OTS private key generation process. It is represented as a 16-bit (two-byte) unsigned integer in network byte order. If present, it occurs at bytes 20 and 21 of the value being hashed.",
      "ja": "I 0と264の間の値。 Winternitz鎖の反復を計算または推奨LM-OTS秘密鍵生成プロセスを使用して、いずれかの場合、これはLM-OTS方式で使用されています。これは、ネットワークバイト順で16ビット（2バイト）の符号なし整数として表現されます。存在する場合、それはバイト20およびハッシュされた値の21で生じます。"
    },
    {
      "indent": 3,
      "text": "j In the LM-OTS scheme, j is the iteration number used when the private key element is being iteratively hashed. It is represented as an 8-bit (one byte) unsigned integer and is present if i is a value between 0 and 264. If present, it occurs at bytes 22 to 21+n of the value being hashed.",
      "ja": "LM-OTS方式でjは、jは、秘密鍵の要素を反復的にハッシュ化されているときに使用される反復数です。これは8ビット（1バイト）の符号なし整数として表現し、存在する場合iは0と264の間の値である場合、それはハッシュされた値の21 + nにバイト22で発生存在しています。"
    },
    {
      "indent": 3,
      "text": "C An n-byte randomizer that is included with the message whenever it is being hashed to improve security. C MUST be chosen uniformly at random or via another unpredictable process. It is present if D=D_MESG, and it occurs at bytes 22 to 21+n of the value being hashed.",
      "ja": "セキュリティを向上させるためにハッシュされるたびにメッセージに含まれているCにnバイトのランダム化。 Cは、ランダムにまたは別の予測不可能なプロセスを介して一様に選択されなければなりません。 D = D_MESG場合が存在し、それはハッシュされた値の21 + nにバイト22で起こります。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created two registries: \"LM-OTS Signatures\", which includes all of the LM-OTS signatures as defined in Section 4, and \"Leighton-Micali Signatures (LMS)\" for LMS as defined in Section 5.",
      "ja": "セクション4で定義されるように、そして「レイトン-Micali署名（LMS）は、」LMSについては、セクション5で定義されるように「LM-OTS署名」、LM-OTSシグネチャのすべてを含む：IANAは、二つのレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Additions to these registries require that a specification be documented in an RFC or another permanent and readily available reference in sufficient detail that interoperability between independent implementations is possible [RFC8126]. IANA MUST verify that all applications for additions to these registries have first been reviewed by the IRTF Crypto Forum Research Group (CFRG).",
      "ja": "これらのレジストリへの追加は、仕様がRFCまたは独立した実装の間の相互運用性が可能であることを十分に詳細に別の永久的で容易に入手可能な参考文献[RFC8126]に記録されることを必要とします。 IANAは、これらのレジストリへの追加のために、すべてのアプリケーションが最初IRTF暗号フォーラム研究グループ（CFRG）によって検討されていることを確かめなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each entry in either of the registries contains the following elements:",
      "ja": "レジストリのいずれかの各エントリには、次の要素が含まれます。"
    },
    {
      "indent": 6,
      "text": "a short name (Name), such as \"LMS_SHA256_M32_H10\",",
      "ja": "こうした「LMS_SHA256_M32_H10」などの短い名前（名）、"
    },
    {
      "indent": 6,
      "text": "a positive number (Numeric Identifier), and",
      "ja": "正の数（数値識別子）、及び"
    },
    {
      "indent": 6,
      "text": "a Reference to a specification that completely defines the signature-method test cases that can be used to verify the correctness of an implementation.",
      "ja": "完全実装の正しさを検証するために使用することができる署名方式のテストケースを定義する明細書を参照。"
    },
    {
      "indent": 3,
      "text": "The numbers between 0xDDDDDDDD (decimal 3,722,304,989) and 0xFFFFFFFF (decimal 4,294,967,295), inclusive, will not be assigned by IANA and are reserved for private use; no attempt will be made to prevent multiple sites from using the same value in different (and incompatible) ways [RFC8126].",
      "ja": "（3722304989小数）と0xFFFFFFFFの0xDDDDDDDDの間の数値（小数点4294967295）、包括的、IANAによって割り当てられず、私的使用のために予約されています。試みは、異なる（および互換性のない）方法[RFC8126]に同じ値を使用することから、複数のサイトを防ぐために行われません。"
    },
    {
      "indent": 3,
      "text": "The initial contents of the \"LM-OTS Signatures\" registry are as follows.",
      "ja": "以下のように「LM-OTS署名」レジストリの初期の内容です。"
    },
    {
      "indent": 4,
      "text": "+--------------------------+-----------+--------------------------+\n| Name                     | Reference |    Numeric Identifier    |\n+--------------------------+-----------+--------------------------+\n| Reserved                 |           |        0x00000000        |\n|                          |           |                          |\n| LMOTS_SHA256_N32_W1      | Section 4 |        0x00000001        |\n|                          |           |                          |\n| LMOTS_SHA256_N32_W2      | Section 4 |        0x00000002        |\n|                          |           |                          |\n| LMOTS_SHA256_N32_W4      | Section 4 |        0x00000003        |\n|                          |           |                          |\n| LMOTS_SHA256_N32_W8      | Section 4 |        0x00000004        |\n|                          |           |                          |\n| Unassigned               |           | 0x00000005 - 0xDDDDDDDC  |\n|                          |           |                          |\n| Reserved for Private Use |           | 0xDDDDDDDD - 0xFFFFFFFF  |\n+--------------------------+-----------+--------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 3,
      "text": "The initial contents of the \"Leighton Micali Signatures (LMS)\" registry are as follows.",
      "ja": "以下のように「レイトンMicali署名（LMS）」レジストリの初期の内容です。"
    },
    {
      "indent": 4,
      "text": "+--------------------------+-----------+--------------------------+\n| Name                     | Reference |    Numeric Identifier    |\n+--------------------------+-----------+--------------------------+\n| Reserved                 |           |        0x0 - 0x4         |\n|                          |           |                          |\n| LMS_SHA256_M32_H5        | Section 5 |        0x00000005        |\n|                          |           |                          |\n| LMS_SHA256_M32_H10       | Section 5 |        0x00000006        |\n|                          |           |                          |\n| LMS_SHA256_M32_H15       | Section 5 |        0x00000007        |\n|                          |           |                          |\n| LMS_SHA256_M32_H20       | Section 5 |        0x00000008        |\n|                          |           |                          |\n| LMS_SHA256_M32_H25       | Section 5 |        0x00000009        |\n|                          |           |                          |\n| Unassigned               |           | 0x0000000A - 0xDDDDDDDC  |\n|                          |           |                          |\n| Reserved for Private Use |           | 0xDDDDDDDD - 0xFFFFFFFF  |\n+--------------------------+-----------+--------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 5",
      "ja": "表5"
    },
    {
      "indent": 3,
      "text": "An IANA registration of a signature system does not constitute an endorsement of that system or its security.",
      "ja": "署名システムのIANA登録は、そのシステムまたはセキュリティの承認を構成するものではありません。"
    },
    {
      "indent": 3,
      "text": "Currently, the two registries assign a disjoint set of values to the defined parameter sets. This coincidence is a historical accident; the correctness of the system does not depend on this. IANA is not required to maintain this situation.",
      "ja": "現在、2つのレジストリは、定義されたパラメータセットに値の互いに素な集合を割り当てます。この偶然の一致では歴史的な偶然です。システムの正しさは、これに依存しません。 IANAは、この状況を維持するために必要とされていません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The hash function H MUST have second preimage resistance: it must be computationally infeasible for an attacker that is given one message M to be able to find a second message M' such that H(M) = H(M').",
      "ja": "ハッシュ関数Hは、第二のプリイメージ耐性を持たなければならない：それは第2のメッセージMを見つけることができる1つのメッセージMが与えられる攻撃者計算上実行不可能でなければならない「ようにH（M）= H（M」）。"
    },
    {
      "indent": 3,
      "text": "The security goal of a signature system is to prevent forgeries. A successful forgery occurs when an attacker who does not know the private key associated with a public key can find a message (distinct from all previously signed ones) and signature that is valid with that public key (that is, the Signature Verification algorithm applied to that signature and message and public key will return VALID). Such an attacker, in the strongest case, may have the ability to forge valid signatures for an arbitrary number of other messages.",
      "ja": "署名システムのセキュリティ目標は、偽造を防ぐためです。公開鍵に関連付けられた秘密鍵を知らない攻撃者が（つまり、に適用される署名検証アルゴリズムである公開鍵で有効である（すべての以前に署名したものとは別の）メッセージと署名を見つけることができたときに成功した偽造が発生しますその署名とメッセージと公開鍵）は、有効な戻ります。そのような攻撃者は、最も強い場合には、他のメッセージの任意の数のための有効な署名を偽造する能力を有していてもよいです。"
    },
    {
      "indent": 3,
      "text": "LMS is provably secure in the random oracle model, as shown by [Katz16]. In addition, further analysis is done by [Fluhrer17], where the hash compression function (rather than the entire hash function) is considered to be a random oracle. Corollary 1 of the latter paper states:",
      "ja": "LMS [Katz16]によって示されるように、ランダムオラクルモデルで証明可能に安全です。加えて、更なる分析は、ハッシュ圧縮機能（全体ではなく、ハッシュ関数）はランダムオラクルであると考えられている[Fluhrer17]、によって行われます。後者の紙状態の系1："
    },
    {
      "indent": 6,
      "text": "If we have no more than 2^64 randomly chosen LMS private keys, allow the attacker access to a signing oracle and a SHA-256 hash compression oracle, and allow a maximum of 2^120 hash compression computations, then the probability of an attacker being able to generate a single forgery against any of those LMS keys is less than 2^-129.",
      "ja": "我々はせいぜい2 ^ 64個のランダムに選択されたLMS秘密鍵を持たない場合、署名オラクルとSHA-256ハッシュ圧縮Oracleへの攻撃者のアクセスを許可し、2 ^ 120のハッシュ圧縮計算の最大値、攻撃者のその後確率を許可これらのLMSのキーのいずれかに対して、単一の偽造を生成することができるということは2 ^ -129未満です。"
    },
    {
      "indent": 3,
      "text": "Many of the objects within the public key and the signature start with a typecode. A verifier MUST check each of these typecodes, and a verification operation on a signature with an unknown type, or a type that does not correspond to the type within the public key, MUST return INVALID. The expected length of a variable-length object can be determined from its typecode; if an object has a different length, then any signature computed from the object is INVALID.",
      "ja": "公開鍵と署名内のオブジェクトの多くは、タイプコードで始まります。検証者は、これらの型コードのそれぞれをチェックしなければなりません、そして未知のタイプ、または公開鍵内のタイプに対応していないタイプの署名に対する検証動作は、INVALID返さなければなりません。可変長オブジェクトの予想される長さは、そのタイプコードから決定することができます。オブジェクトが異なる長さを有する場合、そのオブジェクトから計算され、任意の署名が無効です。"
    },
    {
      "indent": 0,
      "text": "9.1. Hash Formats",
      "section_title": true,
      "ja": "9.1。ハッシュフォーマット"
    },
    {
      "indent": 3,
      "text": "The format of the inputs to the hash function H has the property that each invocation of that function has an input that is repeated by a small bounded number of other inputs (due to potential repeats of the I value). In particular, it will vary somewhere in the first 23 bytes of the value being hashed. This property is important for a proof of security in the random oracle model.",
      "ja": "ハッシュ関数Hへの入力の形式は、その関数の各呼び出しは、（これはI値の電位繰り返す）他の入力の小さい有界数だけ繰り返される入力を有する性質を有します。特に、ハッシュされた値の最初の23バイトのどこかで変化するであろう。このプロパティは、ランダムオラクルモデルにおけるセキュリティの証明のために重要です。"
    },
    {
      "indent": 3,
      "text": "The formats used during key generation and signing (including the recommended pseudorandom key-generation procedure in Appendix A) are as follows:",
      "ja": "次のようにキーの生成及び（付録Aの推奨される擬似ランダム鍵生成手順を含む）の署名の間に使用されるフォーマットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "I || u32str(q) || u16str(i) || u8str(j) || tmp I || u32str(q) || u16str(D_PBLC) || y[0] || ... || y[p-1] I || u32str(q) || u16str(D_MESG) || C || message I || u32str(r) || u16str(D_LEAF) || OTS_PUB_HASH[r-2^h] I || u32str(r) || u16str(D_INTR) || T[2*r] || T[2*r+1] I || u32str(q) || u16str(i) || u8str(0xff) || SEED",
      "ja": "I || u32str（Q）|| u16str（I）|| u8str（J）|| TMP I || u32str（Q）|| u16str（D_PBLC）|| Y [0] || ... || Y [P-1] I || u32str（Q）|| u16str（D_MESG）|| C ||私は||メッセージu32str（R）|| u16str（D_LEAF）|| OTS_PUB_HASH [R-2 ^ H] I || u32str（R）|| u16str（D_INTR）|| T [2 * R] || T [2 * R + 1] I || u32str（Q）|| u16str（I）|| u8str（0xffの）||シード"
    },
    {
      "indent": 3,
      "text": "Each hash type listed is distinct; at locations 20 and 21 of the value being hashed, there exists either a fixed value D_PBLC, D_MESG, D_LEAF, D_INTR, or a 16-bit value i. These fixed values are distinct from each other and are large (over 32768), while the 16-bit values of i are small (currently no more than 265; possibly being slightly larger if larger hash functions are supported); hence, the range of possible values of i will not collide any of the D_PBLC, D_MESG,",
      "ja": "リストされた各ハッシュタイプが区別されます。位置20およびハッシュされた値の21で、固定値D_PBLC、D_MESG、D_LEAF、D_INTR、または16ビット値Iのいずれかが存在します。これらの固定値は、互いに異なっていると私の16ビット値が小さいながら、（32768を超える）大きい（現在はこれ以上265以下、おそらく僅かに大きいが、大きなハッシュ関数がサポートされていないれている場合）。従って、私の可能な値の範囲は、D_PBLC、D_MESGのいずれかを衝突しません"
    },
    {
      "indent": 3,
      "text": "D_LEAF, D_INTR identifiers. The only other collision possibility is the Winternitz chain hash colliding with the recommended pseudorandom key-generation process; here, at location 22 of the value being hashed, the Winternitz chain function has the value u8str(j), where j is a value between 0 and 254, while location 22 of the recommended pseudorandom key-generation process has value 255.",
      "ja": "D_LEAF、D_INTR識別子。他の唯一の衝突の可能性が推奨擬似ランダム鍵生成プロセスと衝突Winternitz鎖のハッシュです。ここで、ハッシュされた値の位置22において、Winternitzチェーン機能は推奨擬似ランダム鍵生成プロセスの位置22が値255を有しているjは、0と254の間の値である値u8str（j）を、有しています。"
    },
    {
      "indent": 3,
      "text": "For the Winternitz chaining function, D_PBLC, and D_MESG, the value of I || u32str(q) is distinct for each LMS leaf (or equivalently, for each q value). For the Winternitz chaining function, the value of u16str(i) || u8str(j) is distinct for each invocation of H for a given leaf. For D_PBLC and D_MESG, the input format is used only once for each value of q and, thus, distinctness is assured. The formats for D_INTR and D_LEAF are used exactly once for each value of r, which ensures their distinctness. For the recommended pseudorandom key-generation process, for a given value of I, q and j are distinct for each invocation of H.",
      "ja": "Winternitzチェーン機能については、D_PBLC、およびD_MESG、Iの値|| u32str（q）は、それぞれLMS葉用の別個の（または等価的に、それぞれのQ値のため）です。 Winternitz連鎖機能のために、u16str（i）の値|| u8str（j）は、所与のリーフのためのHの各呼び出しのために異なっています。 D_PBLCとD_MESGため、入力フォーマットは、Qの各値に対して一度だけ使用され、従って、明瞭が保証されます。 D_INTRとD_LEAFのためのフォーマットは、それらの鮮明を確実にRの各値のために一度だけ使用されます。推奨される擬似ランダム鍵生成プロセスのために、Iの所与の値について、qおよびjがHの各呼び出しのために異なっています"
    },
    {
      "indent": 3,
      "text": "The value of I is chosen uniformly at random from the set of all 128-bit strings. If 2^64 public keys are generated (and, hence, 2^64 random I values), there is a nontrivial probability of a duplicate (which would imply duplicate prefixes). However, there will be an extremely high probability there will not be a four-way collision (that is, any I value used for four distinct LMS keys; probability < 2^-132), and, hence, the number of repeats for any specific prefix will be limited to at most three. This is shown (in [Fluhrer17]) to have only a limited effect on the security of the system.",
      "ja": "Iの値は、すべての128ビットストリングの集合から一様にランダムに選択されます。 2 ^ 64個の公開鍵が生成される場合（従って、及び、2 ^ 64ランダムI値）は、（重複プレフィックスを暗示する）重複の自明でない可能性があります。 、したがって、任意のリピート数、および;ただし、（^ -132確率<2すなわち、4つの異なるLMSキーのために使用される任意のI値である）四方衝突が存在しないであろう非常に高い確率が存在するであろう特定のプレフィックスは最大で3つに限定されます。これは、システムのセキュリティにのみ限られた効果を有すること（[Fluhrer17]に）示されています。"
    },
    {
      "indent": 0,
      "text": "9.2. Stateful Signature Algorithm",
      "section_title": true,
      "ja": "9.2。ステートフル署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The LMS signature system, like all N-time signature systems, requires that the signer maintain state across different invocations of the signing algorithm to ensure that none of the component one-time signature systems are used more than once. This section calls out some important practical considerations around this statefulness. These issues are discussed in greater detail in [STMGMT].",
      "ja": "LMS署名システムは、全てのN拍子システムと同様に、署名者は、コンポーネントワンタイム署名方式のいずれも複数回使用されていないことを保証するために、署名アルゴリズムの異なる呼び出しを横切って状態を維持することを必要とします。このセクションでは、このステートフル周りにいくつかの重要な実用的な考慮事項を呼び出します。これらの問題は、[STMGMT]でより詳細に説明されています。"
    },
    {
      "indent": 3,
      "text": "In a typical computing environment, a private key will be stored in nonvolatile media such as on a hard drive. Before it is used to sign a message, it will be read into an application's Random-Access Memory (RAM). After a signature is generated, the value of the private key will need to be updated by writing the new value of the private key into nonvolatile storage. It is essential for security that the application ensures that this value is actually written into that storage, yet there may be one or more memory caches between it and the application. Memory caching is commonly done in the file system and in a physical memory unit on the hard disk that is dedicated to that purpose. To ensure that the updated value is written to physical media, the application may need to take several special steps. In a POSIX environment, for instance, the O_SYNC flag (for the open() system call) will cause invocations of the write() system call to block the calling process until the data has been written to the underlying hardware. However, if that hardware has its own memory cache, it must be separately dealt with using an operating system or device-specific tool such as hdparm to flush the on-drive cache or turn off write caching for that drive. Because these details vary across different operating systems and devices, this note does not attempt to provide complete guidance; instead, we call the implementer's attention to these issues.",
      "ja": "典型的なコンピューティング環境では、秘密鍵は、ハードドライブ上のような不揮発性媒体に格納されます。それはメッセージの署名に使用される前に、アプリケーションのランダムアクセスメモリ（RAM）に読み込まれます。署名が生成された後、秘密鍵の値は、不揮発性記憶装置へのプライベートキーの新しい値を書き込むことによって更新する必要があります。アプリケーションが、この値は実際にはそのストレージに書き込まれることを保証し、まだそれとアプリケーションの間の1つの以上のメモリキャッシュがあるかもしれないこと、セキュリティのために不可欠です。メモリキャッシュは、通常のファイルシステムで、その目的に専用されているハードディスク上の物理メモリユニットで行われます。更新された値が物理メディアに書き込まれていることを確認するために、アプリケーションはいくつかの特別な手順を実行する必要があるかもしれません。 POSIX環境では、例えば、（オープン（）システムコール用）O_SYNCフラグは、データが基盤となるハードウェアに書き込まれるまでwrite（）システムコールの呼び出しは、呼び出し元のプロセスをブロックします。そのハードウェアは、独自のメモリキャッシュを持っている場合しかし、それは個別にオンドライブキャッシュをフラッシュまたはそのドライブの書き込みキャッシュをオフにするなどのhdparmなどのオペレーティングシステムやデバイス固有のツールを使用して対処されなければなりません。これらの詳細は、異なるオペレーティングシステムやデバイスごとに異なるため、このノートは完全なガイダンスを提供しようとしません。代わりに、我々はこれらの問題に実装者の注意を喚起する。"
    },
    {
      "indent": 3,
      "text": "When hierarchical signatures are used, an easy way to minimize the private key synchronization issues is to have the private key for the second-level resident in RAM only and never write that value into nonvolatile memory. A new second-level public/private key pair will be generated whenever the application (re)starts; thus, failures such as a power outage or application crash are automatically accommodated. Implementations SHOULD use this approach wherever possible.",
      "ja": "階層的な署名が使用されている場合は、秘密鍵の同期の問題を最小限にする簡単な方法は、決して不揮発性メモリにその値を書き込むRAMで2番目にレベルの居住者のための秘密鍵を持っていることです。アプリケーションが（再）起動するたびに新たな第2レベルの公開/秘密鍵ペアが生成されます。従って、このような停電またはアプリケーションのクラッシュなどの障害が自動的に収納されています。可能な限り実装は、このアプローチを使用すべきです。"
    },
    {
      "indent": 0,
      "text": "9.3. Security of LM-OTS Checksum",
      "section_title": true,
      "ja": "9.3。 LM-OTSチェックサムのセキュリティ"
    },
    {
      "indent": 3,
      "text": "To show the security of LM-OTS checksum, we consider the signature y of a message with a private key x and let h = H(message) and c = Cksm(H(message)) (see Section 4.5). To attempt a forgery, an attacker may try to change the values of h and c. Let h' and c' denote the values used in the forgery attempt. If for some integer j in the range 0 to u, where u = ceil(8*n/w) is the size of the range that the checksum value can cover, inclusive,",
      "ja": "LM-OTSチェックサムのセキュリティを表示するには、我々は、プライベート鍵xでメッセージの署名yを考えるとh = H（メッセージを）させ、およびc = Cksm（H（メッセージ））（4.5節を参照してください）。偽造を試みるために、攻撃者は、H及びCの値を変更しようとするかもしれません。 H「とC」は偽造の試みで使用される値を示すものとします。 Uの範囲0である整数jの場合、ここで、u = CEIL（8 * N / W）は、包括的、チェックサム値を覆うことができる範囲の大きさであります"
    },
    {
      "indent": 6,
      "text": "a' = coef(h', j, w),",
      "ja": "'= COEF（H'、J、W）"
    },
    {
      "indent": 6,
      "text": "a = coef(h, j, w), and",
      "ja": "= COEF（H、J、W）、および"
    },
    {
      "indent": 6,
      "text": "a' > a",
      "ja": "」> A"
    },
    {
      "indent": 3,
      "text": "then the attacker can compute F^a'(x[j]) from F^a(x[j]) = y[j] by iteratively applying function F to the j-th term of the signature an additional (a' - a) times. However, as a result of the increased number of hashing iterations, the checksum value c' will decrease from its original value of c. Thus, a valid signature's checksum will have, for some number k in the range u to (p-1), inclusive,",
      "ja": "その後、攻撃者は、 '反復署名の追加（Aのj番目の項に関数Fを適用することによって、（X [J]）Fから^ A（X [J]）= Y [j]が' ^ A Fを計算することができます - a）の回。しかしながら、ハッシュ反復数の増加の結果として、チェックサム値C」はCの元の値から減少します。したがって、有効な署名のチェックサムは、（P-1）の範囲U内のいくつかの数k、包括のために、必要があります"
    },
    {
      "indent": 6,
      "text": "b' = coef(c', k, w),",
      "ja": "B '= COEF（C'、K、W）、"
    },
    {
      "indent": 6,
      "text": "b = coef(c, k, w), and",
      "ja": "B = COEF（C、K、W）、および"
    },
    {
      "indent": 6,
      "text": "b' < b",
      "ja": "B」<B"
    },
    {
      "indent": 3,
      "text": "Due to the one-way property of F, the attacker cannot easily compute F^b'(x[k]) from F^b(x[k]) = y[k].",
      "ja": "Fの一方向性に、攻撃者が容易F ^ B 'Fからの（X [K]）^ B（X [K]）= Y [k]を計算することができません。"
    },
    {
      "indent": 0,
      "text": "10. Comparison with Other Work",
      "section_title": true,
      "ja": "他の作業を10の比較"
    },
    {
      "indent": 3,
      "text": "The eXtended Merkle Signature Scheme (XMSS) is similar to HSS in several ways [XMSS][RFC8391]. Both are stateful hash-based signature schemes, and both use a hierarchical approach, with a Merkle tree at each level of the hierarchy. XMSS signatures are slightly shorter than HSS signatures, for equivalent security and an equal number of signatures.",
      "ja": "拡張マークル署名方式（XMSS）は、いくつかの方法[XMSS] [RFC8391]にHSSと同様です。双方は、ステートフルハッシュベース署名方式であり、階層の各レベルでマークル木を用いて、階層的アプローチを使用し、両方。 XMSS署名は、同等のセキュリティと署名の等しい数の、HSSシグネチャよりもわずかに短いです。"
    },
    {
      "indent": 3,
      "text": "HSS has several advantages over XMSS. HSS operations are roughly four times faster than the comparable XMSS ones, when SHA256 is used as the underlying hash. This occurs because the hash operation done as a part of the Winternitz iterations dominates performance, and XMSS performs four compression-function invocations (two for the PRF, two for the F function) where HSS only needs to perform one. Additionally, HSS is somewhat simpler (as each hash invocation is just a prefix followed by the data being hashed).",
      "ja": "HSSはXMSS比べていくつかの利点を有します。 SHA256を下地ハッシュとして使用する場合HSS操作は、同等XMSSのものよりも約4倍高速です。 Winternitz反復の一部として行わハッシュ演算が性能を支配し、そしてXMSSは、4つの圧縮関数呼び出し（PRFのための2つ、F関数のための2つの）HSSは一つだけを実行する必要が実行されるために起こります。 （各ハッシュ呼び出しがハッシュされているデータに続くだけ接頭辞であるように）また、HSSは幾分簡単です。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS180] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4, March 2012.",
      "ja": "[FIPS180]アメリカ国立標準技術研究所、 \"セキュアハッシュ規格（SHS）\"、FIPS PUB 180-4の、DOI 10.6028 / NIST.FIPS.180-4、2012年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <https://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506]アイスラー、M.、エド、 \"XDR：外部データ表現標準\"。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<https://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8179] Bradner, S. and J. Contreras, \"Intellectual Property Rights in IETF Technology\", BCP 79, RFC 8179, DOI 10.17487/RFC8179, May 2017, <https://www.rfc-editor.org/info/rfc8179>.",
      "ja": "[RFC8179]ブラドナー、S.およびJ.コントレラス、BCP 79、RFC 8179、DOI 10.17487 / RFC8179、2017年5月、 \"IETF技術の知的財産権\" <https://www.rfc-editor.org/info/ rfc8179>。"
    },
    {
      "indent": 3,
      "text": "[USPTO5432852] Leighton, T. and S. Micali, \"Large provably fast and secure digital signature schemes based on secure hash functions\", U.S. Patent 5,432,852, July 1995.",
      "ja": "【USPTO5432852]レイトン、T.及びS. Micaliは、米国特許5432852、1995年7月に「大証明可能迅速かつ安全なデジタル署名方式は、セキュアハッシュ関数に基づいて」。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[C:Merkle87] Merkle, R., \"A Digital Signature Based on a Conventional Encryption Function\", in Advances in Cryptology -- CRYPTO '87 Proceedings, Lecture Notes in Computer Science Vol. 293, DOI 10.1007/3-540-48184-2_32, 1988.",
      "ja": "[C：Merkle87]マークル、R.、暗号学の進歩で、「従来の暗号化機能に基づいて、デジタル署名」 - コンピュータサイエンス巻でCRYPTO '87の議事録、講義ノート。 293、DOI 10.1007 / 3-540-48184-2_32、1988。"
    },
    {
      "indent": 3,
      "text": "[C:Merkle89a] Merkle, R., \"A Certified Digital Signature\", in Advances in Cryptology -- CRYPTO '89 Proceedings, Lecture Notes in Computer Science Vol. 435, DOI 10.1007/0-387-34805-0_21, 1990.",
      "ja": "[C：Merkle89a]マークル、R.、暗号学の進歩で、「認定デジタル署名」、 - コンピュータサイエンス巻でCRYPTO '89の議事録、講義ノート。 435、DOI 10.1007 / 0-387-34805-0_21、1990。"
    },
    {
      "indent": 3,
      "text": "[C:Merkle89b] Merkle, R., \"One Way Hash Functions and DES\", in Advances in Cryptology -- CRYPTO '89 Proceedings, Lecture Notes in Computer Science Vol. 435, DOI 10.1007/0-387-34805-0_40, 1990.",
      "ja": "[C：Merkle89b]マークル、R.、「一方向ハッシュ関数とDES」、暗号学の進歩で - コンピュータサイエンス巻でCRYPTO '89予稿集、講義ノート。 435、DOI 10.1007 / 0-387-34805-0_40、1990。"
    },
    {
      "indent": 3,
      "text": "[Fluhrer17] Fluhrer, S., \"Further Analysis of a Proposed Hash-Based Signature Standard\", Cryptology ePrint Archive Report 2017/553, 2017, <https://eprint.iacr.org/2017/553>.",
      "ja": "【Fluhrer17] Fluhrer、S.、暗号理論のePrintアーカイブレポート553分の2017、2017、<https://eprint.iacr.org/2017/553>「を提案ハッシュベースの署名標準のさらなる分析」。"
    },
    {
      "indent": 3,
      "text": "[Katz16] Katz, J., \"Analysis of a Proposed Hash-Based Signature Standard\", in SSR 2016: Security Standardisation Research (SSR) pp. 261-273, Lecture Notes in Computer Science Vol. 10074, DOI 10.1007/978-3-319-49100-4_12, 2016.",
      "ja": "【Katz16]カッツ、J.、「提案ハッシュベースの署名標準の分析」、SSR 2016年：セキュリティ標準研究所（SSR）頁261~273、コンピュータサイエンスVOLに講義ノート。 10074、DOI 10.1007 / 978-3-319-49100-4_12、2016。"
    },
    {
      "indent": 3,
      "text": "[Merkle79] Merkle, R., \"Secrecy, Authentication, and Public Key Systems\", Technical Report No. 1979-1, Information Systems Laboratory, Stanford University, 1979, <http://www.merkle.com/papers/Thesis1979.pdf>.",
      "ja": "[Merkle79]マークル、R.、「プライバシー、認証、および公開鍵システム」、技術報告書番号1979から1、情報システム研究所、スタンフォード大学、1979年、<http://www.merkle.com/papers/Thesis1979 .PDF>。"
    },
    {
      "indent": 3,
      "text": "[RFC8391] Huelsing, A., Butin, D., Gazdag, S., Rijneveld, J., and A. Mohaisen, \"XMSS: eXtended Merkle Signature Scheme\", RFC 8391, DOI 10.17487/RFC8391, May 2018, <https://www.rfc-editor.org/info/rfc8391>.",
      "ja": "[RFC8391] Huelsing、A.、ブチン、D.、Gazdag、S.、Rijneveld、J.、およびA. Mohaisen、：、RFC 8391、DOI 10.17487 / RFC8391、2018年5月、<HTTPS \"XMSSは、マークル署名方式を拡張しました\" ：//www.rfc-editor.org/info/rfc8391>。"
    },
    {
      "indent": 3,
      "text": "[STMGMT] McGrew, D., Kampanakis, P., Fluhrer, S., Gazdag, S., Butin, D., and J. Buchmann, \"State Management for Hash-Based Signatures.\", in SSR 2016: Security Standardisation Research (SSR) pp. 244-260, Lecture Notes in Computer Science Vol. 10074, DOI 10.1007/978-3-319-49100-4_11, 2016.",
      "ja": "\"ハッシュベースの署名のための国家管理。\" [STMGMT]マグリュー、D.、Kampanakis、P.、Fluhrer、S.、Gazdag、S.、ブチン、D.、およびJ. Buchmann、SSR 2016年：セキュリティ標準化リサーチ（SSR）頁244から260まで、コンピュータサイエンス巻で講義ノート。 10074、DOI 10.1007 / 978-3-319-49100-4_11、2016。"
    },
    {
      "indent": 3,
      "text": "[XMSS] Buchmann, J., Dahmen, E., and , \"XMSS -- A Practical Forward Secure Signature Scheme Based on Minimal Security Assumptions.\", in PQCrypto 2011: Post-Quantum Cryptography pp. 117-129, Lecture Notes in Computer Science Vol. 7071, DOI 10.1007/978-3-642-25405-5_8, 2011.",
      "ja": "[XMSS] Buchmann、J.、Dahmen、E.、および、 \"XMSS  - 最小限のセキュリティの仮定に基づいて実用的なフォワードセキュア署名方式。\"、PQCrypto 2011年：ポスト量子暗号の頁117-129、講義ノートで。コンピュータサイエンス巻。 7071、DOI 10.1007 / 978-3-642-25405-5_8、2011。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Pseudorandom Key Generation",
      "ja": "付録A.擬似ランダムキーの生成"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use the following pseudorandom process for generating an LMS private key.",
      "ja": "実装はLMS秘密鍵を生成するために、以下の擬似ランダムプロセスを使用するかもしれません。"
    },
    {
      "indent": 6,
      "text": "SEED is an m-byte value that is generated uniformly at random at the start of the process,",
      "ja": "SEEDは、プロセスの開始時にランダムで均一に生成されるMバイトの値であります"
    },
    {
      "indent": 6,
      "text": "I is the LMS key pair identifier,",
      "ja": "私はLMSの鍵ペアの識別子であり、"
    },
    {
      "indent": 6,
      "text": "q denotes the LMS leaf number of an LM-OTS private key,",
      "ja": "qは、LM-OTS秘密鍵のLMSの葉の数を示し、"
    },
    {
      "indent": 6,
      "text": "x_q denotes the x array of private elements in the LM-OTS private key with leaf number q,",
      "ja": "x_qは、葉の数qとLM-OTS秘密鍵でプライベート要素のxアレイを示し"
    },
    {
      "indent": 6,
      "text": "i is the index of the private key element, and",
      "ja": "私は、秘密鍵の要素のインデックスであり、"
    },
    {
      "indent": 6,
      "text": "H is the hash function used in LM-OTS.",
      "ja": "Hは、LM-OTSで使用されるハッシュ関数です。"
    },
    {
      "indent": 3,
      "text": "The elements of the LM-OTS private keys are computed as:",
      "ja": "LM-OTS秘密鍵の要素は次のように計算されています。"
    },
    {
      "indent": 3,
      "text": "x_q[i] = H(I || u32str(q) || u16str(i) || u8str(0xff) || SEED).",
      "ja": "x_q [I] = H（Iはu32str（Q）|| u16str（I）|| u8str（0xffの）|| SEEDを||）。"
    },
    {
      "indent": 3,
      "text": "This process stretches the m-byte random value SEED into a (much larger) set of pseudorandom values, using a unique counter in each invocation of H. The format of the inputs to H are chosen so that they are distinct from all other uses of H in LMS and LM-OTS. A careful reader will note that this is similar to the hash we perform when iterating through the Winternitz chain; however, in that chain, the iteration index will vary between 0 and 254 maximum (for W=8), while the corresponding value in this formula is 255. This algorithm is included in the proof of security in [Fluhrer17] and hence this method is safe when used within the LMS system; however, any other cryptographically secure method of generating private keys would also be safe.",
      "ja": "このプロセスは、にMバイトのランダム値SEEDを伸ばす（はるかに大きい）は、すべての他の用途は異なるように選択されるH. Hへの入力の形式を呼び出すたびに一意のカウンタを使用して、擬似乱数値のセットLMSとLM-OTSでH。注意深い読者は、これがWinternitzチェーンを反復処理するとき、我々は実行ハッシュに似ていることに注意します。しかし、その鎖中に、反復インデックスは、この方法ので、この式中の対応する値が255であるが、このアルゴリズムは、[Fluhrer17]のセキュリティの証明に含まれており、（W = 8の場合）0〜254最大値を変化することになりますLMSシステム内で使用された場合に安全です。しかし、秘密鍵を生成する任意の他の安全な暗号化方式も安心だろう。"
    },
    {
      "indent": 0,
      "text": "Appendix B. LM-OTS Parameter Options",
      "ja": "付録B. LM-OTSパラメータオプション"
    },
    {
      "indent": 3,
      "text": "The LM-OTS one-time signature method uses several internal parameters, which are a function of the selected parameter set. These internal parameters include the following:",
      "ja": "LM-OTSワンタイム署名方式は、選択されたパラメータセットの関数であるいくつかの内部パラメータを使用します。これらの内部パラメータには次のものがあります。"
    },
    {
      "indent": 3,
      "text": "p This is the number of independent Winternitz chains used in the signature; it will be the number of w-bit digits needed to hold the n-bit hash (u in the below equations), along with the number of digits needed to hold the checksum (v in the below equations)",
      "ja": "Pこれは、署名に使用される独立Winternitz鎖の数です。それはチェックサム（以下の式においてV）を保持するのに必要な桁数に伴って、nビットのハッシュ（以下の式でU）を保持するために必要なWビット桁数となり"
    },
    {
      "indent": 3,
      "text": "ls This is the size of the shift needed to move the checksum so that it appears in the checksum digits",
      "ja": "LSこれは、それがチェックサム数字で表示されるように、チェックサムを動かすのに必要なシフトの大きさであります"
    },
    {
      "indent": 3,
      "text": "ls is needed because, while we express the checksum internally as a 16-bit value, we don't always express all 16 bits in the signature; for example, if w=4, we might use only the top 12 bits. Because we read the checksum in network order, this means that, without the shift, we'll use the higher-order bits (which may be always 0) and omit the lower-order bits (where the checksum value actually resides). This shift is here to ensure that the parts of the checksum we need to express (for security) actually contribute to the signature; when multiple such shifts are possible, we take the minimal value.",
      "ja": "LSは、我々は、16ビット値として内部的にチェックサムを表現しながら、我々は常に、署名内のすべての16ビットを発現しない、ために必要とされます。例えば、4 = wの場合、我々は唯一のトップ12ビットを使用するかもしれません。我々はネットワーク順にチェックサムを読み取るので、これはシフトせず、私たちは（常に0であってもよい）上位ビットを使用し、（チェックサム値が実際に存在する）下位ビットを省略するだろう、ということを意味します。このシフトは、チェックサムの部分は、私たちが実際に署名への貢献（セキュリティのため）を発現する必要があることを確実にするためにここにあります。複数のそのようなシフトが可能な場合、我々は、最小限の値をとります。"
    },
    {
      "indent": 3,
      "text": "The parameters ls and p are computed as follows:",
      "ja": "次のようにパラメータLSとpが計算されます。"
    },
    {
      "indent": 5,
      "text": "u = ceil(8*n/w) v = ceil((floor(lg((2^w - 1) * u)) + 1) / w) ls = 16 - (v * w) p = u + v",
      "ja": "U = CEIL（8 * N / W）V = CEIL（（床（LG（（2 ^ W  -  1）* U））+ 1）/ W）LS = 16  - （V * W）P = U + V"
    },
    {
      "indent": 3,
      "text": "Here, u and v represent the number of w-bit fields required to contain the hash of the message and the checksum byte strings, respectively. And as the value of p is the number of w-bit elements of ( H(message) || Cksm(H(message)) ), it is also equivalently the number of byte strings that form the private key and the number of byte strings in the signature. The value 16 in the ls computation of ls corresponds to the 16-bit value used for the sum variable in Algorithm 2 in Section 4.4",
      "ja": "ここで、uおよびvは、それぞれ、メッセージ及びチェックサム・バイトストリングのハッシュを含むことが必要Wビットフィールドの数を表します。 pの値は（H（メッセージ）|| Cksm（H（メッセージ）））のWビット要素の数であるように、それは等価的プライベートキーを形成するバイト列の数とバイト数であります署名の文字列。 LSのLS計算で値16は、セクション4.4でアルゴリズム2で合計変数に使用される16ビット値に対応します"
    },
    {
      "indent": 3,
      "text": "A table illustrating various combinations of n and w with the associated values of u, v, ls, and p is provided in Table 6.",
      "ja": "テーブルは、nおよびuの関連する値をW、V、LSの様々な組み合わせを示し、そしてPは、表6に設けられています。"
    },
    {
      "indent": 3,
      "text": "+---------+------------+-----------+-----------+-------+------------+\n|   Hash  | Winternitz |   w-bit   |   w-bit   |  Left |   Total    |\n|  Length | Parameter  |  Elements |  Elements | Shift | Number of  |\n|    in   |    (w)     |  in Hash  |     in    |  (ls) |   w-bit    |\n|  Bytes  |            |    (u)    |  Checksum |       |  Elements  |\n|   (n)   |            |           |    (v)    |       |    (p)     |\n+---------+------------+-----------+-----------+-------+------------+\n|    32   |     1      |    256    |     9     |   7   |    265     |\n|         |            |           |           |       |            |\n|    32   |     2      |    128    |     5     |   6   |    133     |\n|         |            |           |           |       |            |\n|    32   |     4      |     64    |     3     |   4   |     67     |\n|         |            |           |           |       |            |\n|    32   |     8      |     32    |     2     |   0   |     34     |\n+---------+------------+-----------+-----------+-------+------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 6",
      "ja": "表6"
    },
    {
      "indent": 0,
      "text": "Appendix C. An Iterative Algorithm for Computing an LMS Public Key",
      "ja": "LMS公開鍵を計算するための付録C.アン反復アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The LMS public key can be computed using the following algorithm or any equivalent method. The algorithm uses a stack of hashes for data. It also makes use of a hash function with the typical init/update/final interface to hash functions; the result of the invocations hash_init(), hash_update(N[1]), hash_update(N[2]), ... , hash_update(N[n]), v = hash_final(), in that order, is identical to that of the invocation of H(N[1] || N[2] || ... || N[n]).",
      "ja": "LMS公開鍵は、次のアルゴリズムまたは任意の同等の方法を用いて計算することができます。このアルゴリズムは、データのハッシュのスタックを使用しています。それはまた、典型的な初期化/更新/最終的なインタフェースを備えたハッシュ関数の使用は、機能をハッシュすることができます。するhash_init（）、hash_update（N [1]）、hash_update（N [2]）、···、hash_update（N [N]）、V = hash_final（）の呼び出しの結果は、この順序で、同一でありますH（N [1] || N [2] || ... || N [N]）の呼び出しのこと。"
    },
    {
      "indent": 3,
      "text": "Generating an LMS Public Key from an LMS Private Key",
      "ja": "LMS秘密鍵からLMS公開鍵の生成"
    },
    {
      "indent": 4,
      "text": " for ( i = 0; i < 2^h; i = i + 1 ) {\n   r = i + num_lmots_keys;\n   temp = H(I || u32str(r) || u16str(D_LEAF) || OTS_PUB_HASH[i])\n   j = i;\n   while (j % 2 == 1) {\n     r = (r - 1)/2;\n     j = (j-1) / 2;\n     left_side = pop(data stack);\n     temp = H(I || u32str(r) || u16str(D_INTR) || left_side || temp)\n   }\n   push temp onto the data stack\n}\npublic_key = pop(data stack)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that this pseudocode expects that all 2^h leaves of the tree have equal depth -- that is, it expects num_lmots_keys to be a power of 2. The maximum depth of the stack will be h-1 elements -- that is, a total of (h-1)*n bytes; for the currently defined parameter sets, this will never be more than 768 bytes of data.",
      "ja": "すなわち、 - つまり、それはnum_lmots_keysスタックの最大深さがH 1の要素であろう2の累乗であることを期待 - この擬似コードは、ツリーのすべての2 ^ H葉が等しい深さを有することを期待していることに注意してください（H-1）* Nバイトの合計。現在定義されているパラメータセットのために、これ以上のデータ768バイトになることはありません。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Method for Deriving Authentication Path for a Signature",
      "ja": "署名の認証パスを導出するための付録D.方法"
    },
    {
      "indent": 3,
      "text": "The LMS signature consists of u32str(q) || lmots_signature || u32str(type) || path[0] || path[1] || ... || path[h-1]. This appendix shows one method of constructing this signature, assuming that the implementation has stored the T[] array that was used to construct the public key. Note that this is not the only possible method; other methods exist that don't assume that you have the entire T[] array in memory. To construct a signature, you perform the following algorithm:",
      "ja": "LMS署名はu32str（Q）からなる|| lmots_signature || u32str（タイプ）||パス[0] ||経路[1] || ... ||経路[H-1]。この付録では、実装は、公開鍵を構築するために使用したT []配列が格納されていると仮定すると、この署名を構築する1つの方法を示しています。これが唯一の可能な方法ではないことに注意してください。他の方法は、あなたがメモリ内全体T []配列を持っていることを前提としていないことが存在します。署名を構築するには、次のアルゴリズムを実行します。"
    },
    {
      "indent": 3,
      "text": "Generating an LMS Signature",
      "ja": "LMSの署名を生成します"
    },
    {
      "indent": 5,
      "text": "1. Set type to the typecode of the LMS algorithm.",
      "section_title": true,
      "ja": "LMSアルゴリズムのタイプコードに1セットタイプ。"
    },
    {
      "indent": 5,
      "text": "2. Extract h from the typecode, according to Table 2.",
      "section_title": true,
      "ja": "表2に記載の型コードから2抽出時間、。"
    },
    {
      "indent": 5,
      "text": "3. Create the LM-OTS signature for the message: ots_signature = lmots_sign(message, LMS_PRIV[q])",
      "ja": "ots_signature = lmots_sign（メッセージ、LMS_PRIV [Q]）：3.メッセージのLM-OTSの署名を作成します"
    },
    {
      "indent": 5,
      "text": "4. Compute the array path as follows: i = 0 r = 2^h + q while (i < h) { temp = (r / 2^i) xor 1 path[i] = T[temp] i = i + 1 }",
      "ja": "4.計算アレイのパスを次のようにI = 0、R = 2 ^ H + 1、Q、一方（iはHを<）{TEMP =（R / 2 ^ I）XOR 1つのパス[I] = T [TEMP] I = I + 1}"
    },
    {
      "indent": 5,
      "text": "5. S = u32str(q) || ots_signature || u32str(type) || path[0] || path[1] || ... || path[h-1]",
      "ja": "5. S = u32str（Q）|| ots_signature || u32str（タイプ）||パス[0] ||経路[1] || ... ||経路[H-1]"
    },
    {
      "indent": 5,
      "text": "6. q = q + 1",
      "section_title": true,
      "ja": "6. Q = Q + 1"
    },
    {
      "indent": 5,
      "text": "7. Return S.",
      "section_title": true,
      "ja": "7.戻りS."
    },
    {
      "indent": 3,
      "text": "Here \"xor\" is the bitwise exclusive-or operation, and / is integer division (that is, rounded down to an integer value).",
      "ja": "ここで、「XOR」はビット単位の排他的論理和演算であり、及び/整数除算である（すなわち、整数値に切り捨て）。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Example Implementation",
      "ja": "付録E.実装例"
    },
    {
      "indent": 3,
      "text": "An example implementation can be found online at <https://github.com/cisco/hash-sigs>.",
      "ja": "実装例では、<https://github.com/cisco/hash-sigs>でオンラインで見つけることができます。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Test Cases",
      "ja": "付録F.テストケース"
    },
    {
      "indent": 3,
      "text": "This section provides test cases that can be used to verify or debug an implementation. This data is formatted with the name of the elements on the left and the hexadecimal value of the elements on the right. The concatenation of all of the values within a public key or signature produces that public key or signature, and values that do not fit within a single line are listed across successive lines.",
      "ja": "このセクションでは、実装を検証またはデバッグするために使用することができるテストケースを提供します。このデータは、左右の要素の16進数の値の要素の名前でフォーマットされています。公開鍵または署名内の値の全ての連結は、公開鍵または署名、および単一ライン内に収まらない値は、連続する行に記載されていることを作り出します。"
    },
    {
      "indent": 3,
      "text": "Test Case 1 Public Key",
      "ja": "テストケース1の公開鍵"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nHSS public key\nlevels      00000002\n--------------------------------------------\nLMS type    00000005                         # LM_SHA256_M32_H5\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nI           61a5d57d37f5e46bfb7520806b07a1b8\nK           50650e3b31fe4a773ea29a07f09cf2ea\n            30e579f0df58ef8e298da0434cb2b878\n--------------------------------------------\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 1 Message",
      "ja": "テスト・ケース1のメッセージ"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nMessage     54686520706f77657273206e6f742064  |The powers not d|\n            656c65676174656420746f2074686520  |elegated to the |\n            556e6974656420537461746573206279  |United States by|\n            2074686520436f6e737469747574696f  | the Constitutio|\n            6e2c206e6f722070726f686962697465  |n, nor prohibite|\n            6420627920697420746f207468652053  |d by it to the S|\n            74617465732c20617265207265736572  |tates, are reser|\n            76656420746f20746865205374617465  |ved to the State|\n            7320726573706563746976656c792c20  |s respectively, |\n            6f7220746f207468652070656f706c65  |or to the people|\n            2e0a                              |..|\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 1 Signature",
      "ja": "テストケース1の署名"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nHSS signature\nNspk        00000001\nsig[0]:\n--------------------------------------------\nLMS signature\nq           00000005\n--------------------------------------------\nLMOTS signature\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nC           d32b56671d7eb98833c49b433c272586\n            bc4a1c8a8970528ffa04b966f9426eb9\ny[0]        965a25bfd37f196b9073f3d4a232feb6\n            9128ec45146f86292f9dff9610a7bf95\ny[1]        a64c7f60f6261a62043f86c70324b770\n            7f5b4a8a6e19c114c7be866d488778a0\ny[2]        e05fd5c6509a6e61d559cf1a77a970de\n            927d60c70d3de31a7fa0100994e162a2\ny[3]        582e8ff1b10cd99d4e8e413ef469559f\n            7d7ed12c838342f9b9c96b83a4943d16\ny[4]        81d84b15357ff48ca579f19f5e71f184\n            66f2bbef4bf660c2518eb20de2f66e3b\ny[5]        14784269d7d876f5d35d3fbfc7039a46\n            2c716bb9f6891a7f41ad133e9e1f6d95\ny[6]        60b960e7777c52f060492f2d7c660e14\n            71e07e72655562035abc9a701b473ecb\ny[7]        c3943c6b9c4f2405a3cb8bf8a691ca51\n            d3f6ad2f428bab6f3a30f55dd9625563\ny[8]        f0a75ee390e385e3ae0b906961ecf41a\n            e073a0590c2eb6204f44831c26dd768c\ny[9]        35b167b28ce8dc988a3748255230cef9\n            9ebf14e730632f27414489808afab1d1\ny[10]       e783ed04516de012498682212b078105\n            79b250365941bcc98142da13609e9768\ny[11]       aaf65de7620dabec29eb82a17fde35af\n            15ad238c73f81bdb8dec2fc0e7f93270\ny[12]       1099762b37f43c4a3c20010a3d72e2f6\n            06be108d310e639f09ce7286800d9ef8\ny[13]       a1a40281cc5a7ea98d2adc7c7400c2fe\n            5a101552df4e3cccfd0cbf2ddf5dc677\ny[14]       9cbbc68fee0c3efe4ec22b83a2caa3e4\n            8e0809a0a750b73ccdcf3c79e6580c15\ny[15]       4f8a58f7f24335eec5c5eb5e0cf01dcf\n            4439424095fceb077f66ded5bec73b27\ny[16]       c5b9f64a2a9af2f07c05e99e5cf80f00\n            252e39db32f6c19674f190c9fbc506d8",
      "raw": true
    },
    {
      "indent": 3,
      "text": "y[17]       26857713afd2ca6bb85cd8c107347552\n            f30575a5417816ab4db3f603f2df56fb\ny[18]       c413e7d0acd8bdd81352b2471fc1bc4f\n            1ef296fea1220403466b1afe78b94f7e\ny[19]       cf7cc62fb92be14f18c2192384ebceaf\n            8801afdf947f698ce9c6ceb696ed70e9\ny[20]       e87b0144417e8d7baf25eb5f70f09f01\n            6fc925b4db048ab8d8cb2a661ce3b57a\ny[21]       da67571f5dd546fc22cb1f97e0ebd1a6\n            5926b1234fd04f171cf469c76b884cf3\ny[22]       115cce6f792cc84e36da58960c5f1d76\n            0f32c12faef477e94c92eb75625b6a37\ny[23]       1efc72d60ca5e908b3a7dd69fef02491\n            50e3eebdfed39cbdc3ce9704882a2072\ny[24]       c75e13527b7a581a556168783dc1e975\n            45e31865ddc46b3c957835da252bb732\ny[25]       8d3ee2062445dfb85ef8c35f8e1f3371\n            af34023cef626e0af1e0bc017351aae2\ny[26]       ab8f5c612ead0b729a1d059d02bfe18e\n            fa971b7300e882360a93b025ff97e9e0\ny[27]       eec0f3f3f13039a17f88b0cf808f4884\n            31606cb13f9241f40f44e537d302c64a\ny[28]       4f1f4ab949b9feefadcb71ab50ef27d6\n            d6ca8510f150c85fb525bf25703df720\ny[29]       9b6066f09c37280d59128d2f0f637c7d\n            7d7fad4ed1c1ea04e628d221e3d8db77\ny[30]       b7c878c9411cafc5071a34a00f4cf077\n            38912753dfce48f07576f0d4f94f42c6\ny[31]       d76f7ce973e9367095ba7e9a3649b7f4\n            61d9f9ac1332a4d1044c96aefee67676\ny[32]       401b64457c54d65fef6500c59cdfb69a\n            f7b6dddfcb0f086278dd8ad0686078df\ny[33]       b0f3f79cd893d314168648499898fbc0\n            ced5f95b74e8ff14d735cdea968bee74\n--------------------------------------------\nLMS type    00000005                         # LM_SHA256_M32_H5\npath[0]     d8b8112f9200a5e50c4a262165bd342c\n            d800b8496810bc716277435ac376728d\npath[1]     129ac6eda839a6f357b5a04387c5ce97\n            382a78f2a4372917eefcbf93f63bb591\npath[2]     12f5dbe400bd49e4501e859f885bf073\n            6e90a509b30a26bfac8c17b5991c157e\npath[3]     b5971115aa39efd8d564a6b90282c316\n            8af2d30ef89d51bf14654510a12b8a14\npath[4]     4cca1848cf7da59cc2b3d9d0692dd2a2\n            0ba3863480e25b1b85ee860c62bf5136\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "LMS public key\nLMS type    00000005                         # LM_SHA256_M32_H5\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nI           d2f14ff6346af964569f7d6cb880a1b6\nK           6c5004917da6eafe4d9ef6c6407b3db0\n            e5485b122d9ebe15cda93cfec582d7ab\n--------------------------------------------\nfinal_signature:\n--------------------------------------------\nLMS signature\nq           0000000a\n--------------------------------------------\nLMOTS signature\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nC           0703c491e7558b35011ece3592eaa5da\n            4d918786771233e8353bc4f62323185c\ny[0]        95cae05b899e35dffd71705470620998\n            8ebfdf6e37960bb5c38d7657e8bffeef\ny[1]        9bc042da4b4525650485c66d0ce19b31\n            7587c6ba4bffcc428e25d08931e72dfb\ny[2]        6a120c5612344258b85efdb7db1db9e1\n            865a73caf96557eb39ed3e3f426933ac\ny[3]        9eeddb03a1d2374af7bf771855774562\n            37f9de2d60113c23f846df26fa942008\ny[4]        a698994c0827d90e86d43e0df7f4bfcd\n            b09b86a373b98288b7094ad81a0185ac\ny[5]        100e4f2c5fc38c003c1ab6fea479eb2f\n            5ebe48f584d7159b8ada03586e65ad9c\ny[6]        969f6aecbfe44cf356888a7b15a3ff07\n            4f771760b26f9c04884ee1faa329fbf4\ny[7]        e61af23aee7fa5d4d9a5dfcf43c4c26c\n            e8aea2ce8a2990d7ba7b57108b47dabf\ny[8]        beadb2b25b3cacc1ac0cef346cbb90fb\n            044beee4fac2603a442bdf7e507243b7\ny[9]        319c9944b1586e899d431c7f91bcccc8\n            690dbf59b28386b2315f3d36ef2eaa3c\ny[10]       f30b2b51f48b71b003dfb08249484201\n            043f65f5a3ef6bbd61ddfee81aca9ce6\ny[11]       0081262a00000480dcbc9a3da6fbef5c\n            1c0a55e48a0e729f9184fcb1407c3152\ny[12]       9db268f6fe50032a363c9801306837fa\n            fabdf957fd97eafc80dbd165e435d0e2\ny[13]       dfd836a28b354023924b6fb7e48bc0b3\n            ed95eea64c2d402f4d734c8dc26f3ac5\ny[14]       91825daef01eae3c38e3328d00a77dc6\n            57034f287ccb0f0e1c9a7cbdc828f627\ny[15]       205e4737b84b58376551d44c12c3c215\n            c812a0970789c83de51d6ad787271963",
      "raw": true
    },
    {
      "indent": 3,
      "text": "y[16]       327f0a5fbb6b5907dec02c9a90934af5\n            a1c63b72c82653605d1dcce51596b3c2\ny[17]       b45696689f2eb382007497557692caac\n            4d57b5de9f5569bc2ad0137fd47fb47e\ny[18]       664fcb6db4971f5b3e07aceda9ac130e\n            9f38182de994cff192ec0e82fd6d4cb7\ny[19]       f3fe00812589b7a7ce51544045643301\n            6b84a59bec6619a1c6c0b37dd1450ed4\ny[20]       f2d8b584410ceda8025f5d2d8dd0d217\n            6fc1cf2cc06fa8c82bed4d944e71339e\ny[21]       ce780fd025bd41ec34ebff9d4270a322\n            4e019fcb444474d482fd2dbe75efb203\ny[22]       89cc10cd600abb54c47ede93e08c114e\n            db04117d714dc1d525e11bed8756192f\ny[23]       929d15462b939ff3f52f2252da2ed64d\n            8fae88818b1efa2c7b08c8794fb1b214\ny[24]       aa233db3162833141ea4383f1a6f120b\n            e1db82ce3630b3429114463157a64e91\ny[25]       234d475e2f79cbf05e4db6a9407d72c6\n            bff7d1198b5c4d6aad2831db61274993\ny[26]       715a0182c7dc8089e32c8531deed4f74\n            31c07c02195eba2ef91efb5613c37af7\ny[27]       ae0c066babc69369700e1dd26eddc0d2\n            16c781d56e4ce47e3303fa73007ff7b9\ny[28]       49ef23be2aa4dbf25206fe45c20dd888\n            395b2526391a724996a44156beac8082\ny[29]       12858792bf8e74cba49dee5e8812e019\n            da87454bff9e847ed83db07af3137430\ny[30]       82f880a278f682c2bd0ad6887cb59f65\n            2e155987d61bbf6a88d36ee93b6072e6\ny[31]       656d9ccbaae3d655852e38deb3a2dcf8\n            058dc9fb6f2ab3d3b3539eb77b248a66\ny[32]       1091d05eb6e2f297774fe6053598457c\n            c61908318de4b826f0fc86d4bb117d33\ny[33]       e865aa805009cc2918d9c2f840c4da43\n            a703ad9f5b5806163d7161696b5a0adc\n--------------------------------------------\nLMS type    00000005                         # LM_SHA256_M32_H5\npath[0]     d5c0d1bebb06048ed6fe2ef2c6cef305\n            b3ed633941ebc8b3bec9738754cddd60\npath[1]     e1920ada52f43d055b5031cee6192520\n            d6a5115514851ce7fd448d4a39fae2ab\npath[2]     2335b525f484e9b40d6a4a969394843b\n            dcf6d14c48e8015e08ab92662c05c6e9\npath[3]     f90b65a7a6201689999f32bfd368e5e3\n            ec9cb70ac7b8399003f175c40885081a\npath[4]     09ab3034911fe125631051df0408b394\n            6b0bde790911e8978ba07dd56c73e7ee",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 2 Private Key",
      "ja": "テストケース2秘密鍵"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\n(note: procedure in Appendix A is used)\nTop level LMS tree\nSEED        558b8966c48ae9cb898b423c83443aae\n            014a72f1b1ab5cc85cf1d892903b5439\nI           d08fabd4a2091ff0a8cb4ed834e74534\nSecond level LMS tree\nSEED        a1c4696e2608035a886100d05cd99945\n            eb3370731884a8235e2fb3d4d71f2547\nI           215f83b7ccb9acbcd08db97b0d04dc2b\n--------------------------------------------\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 2 Public Key",
      "ja": "テストケース2の公開鍵"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nHSS public key\nlevels      00000002\n--------------------------------------------\nLMS type    00000006                         # LM_SHA256_M32_H10\nLMOTS type  00000003                         # LMOTS_SHA256_N32_W4\nI           d08fabd4a2091ff0a8cb4ed834e74534\nK           32a58885cd9ba0431235466bff9651c6\n            c92124404d45fa53cf161c28f1ad5a8e\n--------------------------------------------\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 2 Message",
      "ja": "テストケース2のメッセージ"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nMessage     54686520656e756d65726174696f6e20  |The enumeration |\n            696e2074686520436f6e737469747574  |in the Constitut|\n            696f6e2c206f66206365727461696e20  |ion, of certain |\n            7269676874732c207368616c6c206e6f  |rights, shall no|\n            7420626520636f6e7374727565642074  |t be construed t|\n            6f2064656e79206f7220646973706172  |o deny or dispar|\n            616765206f7468657273207265746169  |age others retai|\n            6e6564206279207468652070656f706c  |ned by the peopl|\n            652e0a                            |e..|\n--------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Test Case 2 Signature",
      "ja": "テストケース2署名"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------\nHSS signature\nNspk        00000001\nsig[0]:\n--------------------------------------------\nLMS signature\nq           00000003\n--------------------------------------------\nLMOTS signature\nLMOTS type  00000003                         # LMOTS_SHA256_N32_W4\nC           3d46bee8660f8f215d3f96408a7a64cf\n            1c4da02b63a55f62c666ef5707a914ce\ny[0]        0674e8cb7a55f0c48d484f31f3aa4af9\n            719a74f22cf823b94431d01c926e2a76\ny[1]        bb71226d279700ec81c9e95fb11a0d10\n            d065279a5796e265ae17737c44eb8c59\ny[2]        4508e126a9a7870bf4360820bdeb9a01\n            d9693779e416828e75bddd7d8c70d50a\ny[3]        0ac8ba39810909d445f44cb5bb58de73\n            7e60cb4345302786ef2c6b14af212ca1\ny[4]        9edeaa3bfcfe8baa6621ce88480df237\n            1dd37add732c9de4ea2ce0dffa53c926\ny[5]        49a18d39a50788f4652987f226a1d481\n            68205df6ae7c58e049a25d4907edc1aa\ny[6]        90da8aa5e5f7671773e941d805536021\n            5c6b60dd35463cf2240a9c06d694e9cb\ny[7]        54e7b1e1bf494d0d1a28c0d31acc7516\n            1f4f485dfd3cb9578e836ec2dc722f37\ny[8]        ed30872e07f2b8bd0374eb57d22c614e\n            09150f6c0d8774a39a6e168211035dc5\ny[9]        2988ab46eaca9ec597fb18b4936e66ef\n            2f0df26e8d1e34da28cbb3af75231372\ny[10]       0c7b345434f72d65314328bbb030d0f0\n            f6d5e47b28ea91008fb11b05017705a8\ny[11]       be3b2adb83c60a54f9d1d1b2f476f9e3\n            93eb5695203d2ba6ad815e6a111ea293\ny[12]       dcc21033f9453d49c8e5a6387f588b1e\n            a4f706217c151e05f55a6eb7997be09d\ny[13]       56a326a32f9cba1fbe1c07bb49fa04ce\n            cf9df1a1b815483c75d7a27cc88ad1b1\ny[14]       238e5ea986b53e087045723ce16187ed\n            a22e33b2c70709e53251025abde89396\ny[15]       45fc8c0693e97763928f00b2e3c75af3\n            942d8ddaee81b59a6f1f67efda0ef81d\ny[16]       11873b59137f67800b35e81b01563d18\n            7c4a1575a1acb92d087b517a8833383f",
      "raw": true
    },
    {
      "indent": 3,
      "text": "y[17] 05d357ef4678de0c57ff9f1b2da61dfd e5d88318bcdde4d9061cc75c2de3cd47 y[18] 40dd7739ca3ef66f1930026f47d9ebaa 713b07176f76f953e1c2e7f8f271a6ca y[19] 375dbfb83d719b1635a7d8a138919579 44b1c29bb101913e166e11bd5f34186f y[20] a6c0a555c9026b256a6860f4866bd6d0 b5bf90627086c6149133f8282ce6c9b3 y[21] 622442443d5eca959d6c14ca8389d12c 4068b503e4e3c39b635bea245d9d05a2 y[22] 558f249c9661c0427d2e489ca5b5dde2 20a90333f4862aec793223c781997da9 y[23] 8266c12c50ea28b2c438e7a379eb106e ca0c7fd6006e9bf612f3ea0a454ba3bd y[24] b76e8027992e60de01e9094fddeb3349 883914fb17a9621ab929d970d101e45f y[25] 8278c14b032bcab02bd15692d21b6c5c 204abbf077d465553bd6eda645e6c306 y[26] 5d33b10d518a61e15ed0f092c3222628 1a29c8a0f50cde0a8c66236e29c2f310 y[27] a375cebda1dc6bb9a1a01dae6c7aba8e bedc6371a7d52aacb955f83bd6e4f84d y[28] 2949dcc198fb77c7e5cdf6040b0f84fa f82808bf985577f0a2acf2ec7ed7c0b0 y[29] ae8a270e951743ff23e0b2dd12e9c3c8 28fb5598a22461af94d568f29240ba28 y[30] 20c4591f71c088f96e095dd98beae456 579ebbba36f6d9ca2613d1c26eee4d8c y[31] 73217ac5962b5f3147b492e8831597fd 89b64aa7fde82e1974d2f6779504dc21 y[32] 435eb3109350756b9fdabe1c6f368081 bd40b27ebcb9819a75d7df8bb07bb05d y[33] b1bab705a4b7e37125186339464ad8fa aa4f052cc1272919fde3e025bb64aa8e y[34] 0eb1fcbfcc25acb5f718ce4f7c2182fb 393a1814b0e942490e52d3bca817b2b2 y[35] 6e90d4c9b0cc38608a6cef5eb153af08 58acc867c9922aed43bb67d7b33acc51 y[36] 9313d28d41a5c6fe6cf3595dd5ee63f0 a4c4065a083590b275788bee7ad875a7 y[37] f88dd73720708c6c6c0ecf1f43bbaada e6f208557fdc07bd4ed91f88ce4c0de8 y[38] 42761c70c186bfdafafc444834bd3418 be4253a71eaf41d718753ad07754ca3e y[39] ffd5960b0336981795721426803599ed 5b2b7516920efcbe32ada4bcf6c73bd2 y[40] 9e3fa152d9adeca36020fdeeee1b7395 21d3ea8c0da497003df1513897b0f547",
      "ja": "そして[17] 05d357ef4678de0c57ff9f1b2da61dfd e5d88318bcdde4d9061cc75c2de3cd47及び[18] 40dd7739ca3ef66f1930026f47d9ebaa 713b07176f76f953e1c2e7f8f271a6ca及び[19] 375dbfb83d719b1635a7d8a138919579 44b1c29bb101913e166e11bd5f34186f及び[20] a6c0a555c9026b256a6860f4866bd6d0 b5bf90627086c6149133f8282ce6c9b3及び[21] 622442443d5eca959d6c14ca8389d12c 4068b503e4e3c39b635bea245d9d05a2及び[22] 558f249c9661c0427d2e489ca5b5dde2 20a90333f4862aec793223c781997da9及び[23] 8266c12c50ea28b2c438e7a379eb106e ca0c7fd6006e9bf612f3ea0a454ba3bd及び[24] b76e8027992e60de01e9094fddeb3349 883914fb17a9621ab929d970d101e45fと[ 25] 8278c14b032bcab02bd15692d21b6c5c 204abbf077d465553bd6eda645e6c306及び[26] 5d33b10d518a61e15ed0f092c3222628 1a29c8a0f50cde0a8c66236e29c2f310及び[27] a375cebda1dc6bb9a1a01dae6c7aba8e bedc6371a7d52aacb955f83bd6e4f84d及び[28] 2949dcc198fb77c7e5cdf6040b0f84fa f82808bf985577f0a2acf2ec7ed7c0b0及び[29] 28fb5598a22461af94d568f29240ba28及び[30] 20c4591f71c088f96e095dd98beae456 579ebbba36f6d9ca2613d1c26 ae8a270e951743ff23e0b2dd12e9c3c8 eee4d8c及び[31] 73217ac5962b5f3147b492e8831597fd 89b64aa7fde82e1974d2f6779504dc21及び[32] 435eb3109350756b9fdabe1c6f368081 bd40b27ebcb9819a75d7df8bb07bb05d及び[33] b1bab705a4b7e37125186339464ad8faのaa4f052cc1272919fde3e025bb64aa8e及び[34] 0eb1fcbfcc25acb5f718ce4f7c2182fb 393a1814b0e942490e52d3bca817b2b2及び[35] 6e90d4c9b0cc38608a6cef5eb153af08 58acc867c9922aed43bb67d7b33acc51及び[36] 9313d28d41a5c6fe6cf3595dd5ee63f0 a4c4065a083590b275788bee7ad875a7及び[37] f88dd73720708c6c6c0ecf1f43bbaada e6f208557fdc07bd4ed91f88ce4c0de8及び[38] 42761c70c186bfdafafc444834bd3418 be4253a71eaf41d718753ad07754ca3eと[39] 5b2b7516920efcbe32ada4bcf6c73bd2及び[40] 9e3fa152d9adeca36020fdeeee1b7395 21d3ea8c0da497003df1513897b0f547をffd5960b0336981795721426803599ed"
    },
    {
      "indent": 3,
      "text": "y[41] 94a873670b8d93bcca2ae47e64424b74 23e1f078d9554bb5232cc6de8aae9b83 y[42] fa5b9510beb39ccf4b4e1d9c0f19d5e1 7f58e5b8705d9a6837a7d9bf99cd1338 y[43] 7af256a8491671f1f2f22af253bcff54 b673199bdb7d05d81064ef05f80f0153 y[44] d0be7919684b23da8d42ff3effdb7ca0 985033f389181f47659138003d712b5e y[45] c0a614d31cc7487f52de8664916af79c 98456b2c94a8038083db55391e347586 y[46] 2250274a1de2584fec975fb09536792c fbfcf6192856cc76eb5b13dc4709e2f7 y[47] 301ddff26ec1b23de2d188c999166c74 e1e14bbc15f457cf4e471ae13dcbdd9c y[48] 50f4d646fc6278e8fe7eb6cb5c94100f a870187380b777ed19d7868fd8ca7ceb y[49] 7fa7d5cc861c5bdac98e7495eb0a2cee c1924ae979f44c5390ebedddc65d6ec1 y[50] 1287d978b8df064219bc5679f7d7b264 a76ff272b2ac9f2f7cfc9fdcfb6a5142 y[51] 8240027afd9d52a79b647c90c2709e06 0ed70f87299dd798d68f4fadd3da6c51 y[52] d839f851f98f67840b964ebe73f8cec4 1572538ec6bc131034ca2894eb736b3b y[53] da93d9f5f6fa6f6c0f03ce43362b8414 940355fb54d3dfdd03633ae108f3de3e y[54] bc85a3ff51efeea3bc2cf27e1658f178 9ee612c83d0f5fd56f7cd071930e2946 y[55] beeecaa04dccea9f97786001475e0294 bc2852f62eb5d39bb9fbeef75916efe4 y[56] 4a662ecae37ede27e9d6eadfdeb8f8b2 b2dbccbf96fa6dbaf7321fb0e701f4d4 y[57] 29c2f4dcd153a2742574126e5eaccc77 686acf6e3ee48f423766e0fc466810a9 y[58] 05ff5453ec99897b56bc55dd49b99114 2f65043f2d744eeb935ba7f4ef23cf80 y[59] cc5a8a335d3619d781e7454826df720e ec82e06034c44699b5f0c44a8787752e y[60] 057fa3419b5bb0e25d30981e41cb1361 322dba8f69931cf42fad3f3bce6ded5b y[61] 8bfc3d20a2148861b2afc14562ddd27f 12897abf0685288dcc5c4982f8260268 y[62] 46a24bf77e383c7aacab1ab692b29ed8 c018a65f3dc2b87ff619a633c41b4fad y[63] b1c78725c1f8f922f6009787b1964247 df0136b1bc614ab575c59a16d089917b y[64] d4a8b6f04d95c581279a139be09fcf6e 98a470a0bceca191fce476f9370021cb",
      "ja": "[41] 94a873670b8d93bcca2ae47e64424b74 23e1f078d9554bb5232cc6de8aae9b83及び[42] fa5b9510beb39ccf4b4e1d9c0f19d5e1 7f58e5b8705d9a6837a7d9bf99cd1338及び[43] 7af256a8491671f1f2f22af253bcff54 b673199bdb7d05d81064ef05f80f0153及び[44] d0be7919684b23da8d42ff3effdb7ca0の985033f389181f47659138003d712b5e及び[45] c0a614d31cc7487f52de8664916af79c 98456b2c94a8038083db55391e347586及び[46] 2250274a1de2584fec975fb09536792cのfbfcf6192856cc76eb5b13dc4709e2f7及​​び[47] 301ddff26ec1b23de2d188c999166c74 e1e14bbc15f457cf4e471ae13dcbdd9c及び[48] 50f4d646fc6278e8fe7eb6cb5c94100f a870187380b777ed19d7868fd8ca7cebとして[ 49] 7fa7d5cc861c5bdac98e7495eb0a2cee c1924ae979f44c5390ebedddc65d6ec1及び[50] 1287d978b8df064219bc5679f7d7b264 a76ff272b2ac9f2f7cfc9fdcfb6a5142及び[51] 8240027afd9d52a79b647c90c2709e06 0ed70f87299dd798d68f4fadd3da6c51及び[52] d839f851f98f67840b964ebe73f8cec4の1572538ec6bc131034ca2894eb736b3b及び[53] da93d9f5f6fa6f6c0f03ce43362b8414 940355fb54d3dfdd03633ae108f3de3e及び[54] bc85a3ff51efeea3bc2cf27e1658f178 9ee612c83d0f5fd56f7cd0719 12897abf0685288dcc5c4982f8260268及び[62] 46a24bf77e383c7aacab1ab692b29ed8 c018a65f3dc2b87ff619a633c41b4fad 8bfc3d20a2148861b2afc14562ddd27f 30e2946及び[55] beeecaa04dccea9f97786001475e0294 bc2852f62eb5d39bb9fbeef75916efe4及び[56] 4a662ecae37ede27e9d6eadfdeb8f8b2 b2dbccbf96fa6dbaf7321fb0e701f4d4及び[57] 29c2f4dcd153a2742574126e5eaccc77 686acf6e3ee48f423766e0fc466810a9及び[58] 05ff5453ec99897b56bc55dd49b99114 2f65043f2d744eeb935ba7f4ef23cf80及び[59] cc5a8a335d3619d781e7454826df720eのec82e06034c44699b5f0c44a8787752e及び[60] 057fa3419b5bb0e25d30981e41cb1361 322dba8f69931cf42fad3f3bce6ded5b及び[61]及び[63] b1c78725c1f8f922f6009787b1964247のdf0136b1bc614ab575c59a16d089917b及び[64] d4a8b6f04d95c581279a139be09fcf6e 98a470a0bceca191fce476f9370021cb"
    },
    {
      "indent": 3,
      "text": "y[65]       c05518a7efd35d89d8577c990a5e1996\n            1ba16203c959c91829ba7497cffcbb4b\ny[66]       294546454fa5388a23a22e805a5ca35f\n            956598848bda678615fec28afd5da61a\n--------------------------------------------\nLMS type    00000006                         # LM_SHA256_M32_H10\npath[0]     b326493313053ced3876db9d23714818\n            1b7173bc7d042cefb4dbe94d2e58cd21\npath[1]     a769db4657a103279ba8ef3a629ca84e\n            e836172a9c50e51f45581741cf808315\npath[2]     0b491cb4ecbbabec128e7c81a46e62a6\n            7b57640a0a78be1cbf7dd9d419a10cd8\npath[3]     686d16621a80816bfdb5bdc56211d72c\n            a70b81f1117d129529a7570cf79cf52a\npath[4]     7028a48538ecdd3b38d3d5d62d262465\n            95c4fb73a525a5ed2c30524ebb1d8cc8\npath[5]     2e0c19bc4977c6898ff95fd3d310b0ba\n            e71696cef93c6a552456bf96e9d075e3\npath[6]     83bb7543c675842bafbfc7cdb88483b3\n            276c29d4f0a341c2d406e40d4653b7e4\npath[7]     d045851acf6a0a0ea9c710b805cced46\n            35ee8c107362f0fc8d80c14d0ac49c51\npath[8]     6703d26d14752f34c1c0d2c4247581c1\n            8c2cf4de48e9ce949be7c888e9caebe4\npath[9]     a415e291fd107d21dc1f084b11582082\n            49f28f4f7c7e931ba7b3bd0d824a4570\n--------------------------------------------\nLMS public key\nLMS type    00000005                         # LM_SHA256_M32_H5\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nI           215f83b7ccb9acbcd08db97b0d04dc2b\nK           a1cd035833e0e90059603f26e07ad2aa\n            d152338e7a5e5984bcd5f7bb4eba40b7\n--------------------------------------------\nfinal_signature:\n--------------------------------------------\nLMS signature\nq           00000004\n--------------------------------------------\nLMOTS signature\nLMOTS type  00000004                         # LMOTS_SHA256_N32_W8\nC           0eb1ed54a2460d512388cad533138d24\n            0534e97b1e82d33bd927d201dfc24ebb\ny[0]        11b3649023696f85150b189e50c00e98\n            850ac343a77b3638319c347d7310269d\ny[1]        3b7714fa406b8c35b021d54d4fdada7b\n            9ce5d4ba5b06719e72aaf58c5aae7aca",
      "raw": true
    },
    {
      "indent": 3,
      "text": "y[2] 057aa0e2e74e7dcfd17a0823429db629 65b7d563c57b4cec942cc865e29c1dad y[3] 83cac8b4d61aacc457f336e6a10b6632 3f5887bf3523dfcadee158503bfaa89d y[4] c6bf59daa82afd2b5ebb2a9ca6572a60 67cee7c327e9039b3b6ea6a1edc7fdc3 y[5] df927aade10c1c9f2d5ff446450d2a39 98d0f9f6202b5e07c3f97d2458c69d3c y[6] 8190643978d7a7f4d64e97e3f1c4a08a 7c5bc03fd55682c017e2907eab07e5bb y[7] 2f190143475a6043d5e6d5263471f4ee cf6e2575fbc6ff37edfa249d6cda1a09 y[8] f797fd5a3cd53a066700f45863f04b6c 8a58cfd341241e002d0d2c0217472bf1 y[9] 8b636ae547c1771368d9f317835c9b0e f430b3df4034f6af00d0da44f4af7800 y[10] bc7a5cf8a5abdb12dc718b559b74cab9 090e33cc58a955300981c420c4da8ffd y[11] 67df540890a062fe40dba8b2c1c548ce d22473219c534911d48ccaabfb71bc71 y[12] 862f4a24ebd376d288fd4e6fb06ed870 5787c5fedc813cd2697e5b1aac1ced45 y[13] 767b14ce88409eaebb601a93559aae89 3e143d1c395bc326da821d79a9ed41dc y[14] fbe549147f71c092f4f3ac522b5cc572 90706650487bae9bb5671ecc9ccc2ce5 y[15] 1ead87ac01985268521222fb9057df7e d41810b5ef0d4f7cc67368c90f573b1a y[16] c2ce956c365ed38e893ce7b2fae15d36 85a3df2fa3d4cc098fa57dd60d2c9754 y[17] a8ade980ad0f93f6787075c3f680a2ba 1936a8c61d1af52ab7e21f416be09d2a y[18] 8d64c3d3d8582968c2839902229f85ae e297e717c094c8df4a23bb5db658dd37 y[19] 7bf0f4ff3ffd8fba5e383a48574802ed 545bbe7a6b4753533353d73706067640 y[20] 135a7ce517279cd683039747d218647c 86e097b0daa2872d54b8f3e508598762 y[21] 9547b830d8118161b65079fe7bc59a99 e9c3c7380e3e70b7138fe5d9be255150 y[22] 2b698d09ae193972f27d40f38dea264a 0126e637d74ae4c92a6249fa103436d3 y[23] eb0d4029ac712bfc7a5eacbdd7518d6d 4fe903a5ae65527cd65bb0d4e9925ca2 y[24] 4fd7214dc617c150544e423f450c99ce 51ac8005d33acd74f1bed3b17b7266a4 y[25] a3bb86da7eba80b101e15cb79de9a207 852cf91249ef480619ff2af8cabca831",
      "ja": "及び[2] 057aa0e2e74e7dcfd17a0823429db629 65b7d563c57b4cec942cc865e29c1dad [3] 83cac8b4d61aacc457f336e6a10b6632 3f5887bf3523dfcadee158503bfaa89d及び[4] c6bf59daa82afd2b5ebb2a9ca6572a60 67cee7c327e9039b3b6ea6a1edc7fdc3及び[5] df927aade10c1c9f2d5ff446450d2a39の98d0f9f6202b5e07c3f97d2458c69d3c及び[6] 8190643978d7a7f4d64e97e3f1c4a08a 7c5bc03fd55682c017e2907eab07e5bb及び[7] 2f190143475a6043d5e6d5263471f4ee cf6e2575fbc6ff37edfa249d6cda1a09及び[8] f797fd5a3cd53a066700f45863f04b6cの8a58cfd341241e002d0d2c0217472bf1と[9] 8b636ae547c1771368d9f317835c9b0eのf430b3df4034f6af00d0da44f4af7800と[ 10] bc7a5cf8a5abdb12dc718b559b74cab9 090e33cc58a955300981c420c4da8ffd及び[11] 67df540890a062fe40dba8b2c1c548ceのd22473219c534911d48ccaabfb71bc71及び[12] 862f4a24ebd376d288fd4e6fb06ed870 5787c5fedc813cd2697e5b1aac1ced45及び[13] 767b14ce88409eaebb601a93559aae89 3e143d1c395bc326da821d79a9ed41dc及び[14] fbe549147f71c092f4f3ac522b5cc572 90706650487bae9bb5671ecc9ccc2ce5及び[15] 1ead87ac01985268521222fb9057df7eのd41810b5ef0d4f7cc67368c90f573b1aそして[16] c2ce956c365ed38e893ce7b2fae15d36 85a3df2fa3d4cc098fa57dd60d2c9754及び[17] a8ade980ad0f93f6787075c3f680a2ba 1936a8c61d1af52ab7e21f416be09d2a及び[18] 8d64c3d3d8582968c2839902229f85ae e297e717c094c8df4a23bb5db658dd37及び[19] 545bbe7a6b4753533353d73706067640及び[20] 135a7ce517279cd683039747d218647c 86e097b0daa2872d54b8f3e508598762及び[21] 9547b830d8118161b65079fe7bc59a99 e9c3c7380e3e70b7138fe5d9be255150及び[22] 2b698d09ae193972f27d40f38dea264a 0126e637d74ae4c92a6249fa103436d3及び[23] eb0d4029ac712bfc7a5eacbdd7518d6dの4fe903a5ae65527cd65bb0d4e9925ca2とを7bf0f4ff3ffd8fba5e383a48574802ed [ 24] 4fd7214dc617c150544e423f450c99ceの51ac8005d33acd74f1bed3b17b7266a4及び[25] a3bb86da7eba80b101e15cb79de9a207 852cf91249ef480619ff2af8cabca831"
    },
    {
      "indent": 3,
      "text": "y[26]       25d1faa94cbb0a03a906f683b3f47a97\n            c871fd513e510a7a25f283b196075778\ny[27]       496152a91c2bf9da76ebe089f4654877\n            f2d586ae7149c406e663eadeb2b5c7e8\ny[28]       2429b9e8cb4834c83464f079995332e4\n            b3c8f5a72bb4b8c6f74b0d45dc6c1f79\ny[29]       952c0b7420df525e37c15377b5f09843\n            19c3993921e5ccd97e097592064530d3\ny[30]       3de3afad5733cbe7703c5296263f7734\n            2efbf5a04755b0b3c997c4328463e84c\ny[31]       aa2de3ffdcd297baaaacd7ae646e44b5\n            c0f16044df38fabd296a47b3a838a913\ny[32]       982fb2e370c078edb042c84db34ce36b\n            46ccb76460a690cc86c302457dd1cde1\ny[33]       97ec8075e82b393d542075134e2a17ee\n            70a5e187075d03ae3c853cff60729ba4\n--------------------------------------------\nLMS type    00000005                         # LM_SHA256_M32_H5\npath[0]     4de1f6965bdabc676c5a4dc7c35f97f8\n            2cb0e31c68d04f1dad96314ff09e6b3d\npath[1]     e96aeee300d1f68bf1bca9fc58e40323\n            36cd819aaf578744e50d1357a0e42867\npath[2]     04d341aa0a337b19fe4bc43c2e79964d\n            4f351089f2e0e41c7c43ae0d49e7f404\npath[3]     b0f75be80ea3af098c9752420a8ac0ea\n            2bbb1f4eeba05238aef0d8ce63f0c6e5\npath[4]     e4041d95398a6f7f3e0ee97cc1591849\n            d4ed236338b147abde9f51ef9fd4e1c1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks are due to Chirag Shroff, Andreas Huelsing, Burt Kaliski, Eric Osterweil, Ahmed Kosba, Russ Housley, Philip Lafrance, Alexander Truskovsky, Mark Peruzel, and Jim Schaad for constructive suggestions and valuable detailed review. We especially acknowledge Jerry Solinas, Laurie Law, and Kevin Igoe, who pointed out the security benefits of the approach of Leighton and Micali [USPTO5432852], Jonathan Katz, who gave us security guidance, and Bruno Couillard and Jim Goodman for an especially thorough review.",
      "ja": "おかげで建設的な提案と貴重な詳細なレビューのためチラグShroff、アンドレアスHuelsing、バート・カリスキー、エリックOsterweil、アーメドKosba、ラスHousley、フィリップLafrance、アレクサンダーTruskovsky、マーク・Peruzel、とジムSchaadに起因するものです。我々は、特に、特に徹底的な見直しのためにジェリーSolinas、ローリー法、およびケビンIgoe、レイトンとMicaliのアプローチのセキュリティ上の利点を指摘[USPTO5432852]、私たちのセキュリティガイダンスを与えたジョナサン・カッツ、そしてブルーノCouillardとジム・グッドマンを認めます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David McGrew Cisco Systems 13600 Dulles Technology Drive Herndon, VA 20171 United States of America",
      "ja": "デビッドマグリューシスコシステムズ13600ダレステクノロジードライブアメリカのバージニア州ハーンドン20171米国"
    },
    {
      "indent": 3,
      "text": "Email: mcgrew@cisco.com",
      "ja": "メール：mcgrew@cisco.com"
    },
    {
      "indent": 3,
      "text": "Michael Curcio Cisco Systems 7025-2 Kit Creek Road Research Triangle Park, NC 27709-4987 United States of America",
      "ja": "マイケルCurcioシスコシステムズ7025から2キットクリーク道路リサーチトライアングルパーク、NCアメリカの27709から4987米国"
    },
    {
      "indent": 3,
      "text": "Email: micurcio@cisco.com",
      "ja": "メール：micurcio@cisco.com"
    },
    {
      "indent": 3,
      "text": "Scott Fluhrer Cisco Systems 170 West Tasman Drive San Jose, CA United States of America",
      "ja": "スコットFluhrerシスコシステムズ170西タスマン・ドライブサンノゼ、アメリカのカリフォルニア州、米国"
    },
    {
      "indent": 3,
      "text": "Email: sfluhrer@cisco.com",
      "ja": "メール：sfluhrer@cisco.com"
    }
  ]
}