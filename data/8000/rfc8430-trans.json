{
  "title": {
    "text": "RFC 8430 - RIB Information Model",
    "ja": "RFC 8430 - RIB情報モデル"
  },
  "number": 8430,
  "created_at": "2019-11-01 22:58:08.337673+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   N. Bahadur, Ed.\nRequest for Comments: 8430                                          Uber\nCategory: Informational                                     S. Kini, Ed.\nISSN: 2070-1721\n                                                               J. Medved\n                                                                   Cisco\n                                                          September 2018",
      "raw": true
    },
    {
      "indent": 25,
      "text": "RIB Information Model",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Routing and routing functions in enterprise and carrier networks are typically performed by network devices (routers and switches) using a Routing Information Base (RIB). Protocols and configurations push data into the RIB, and the RIB manager installs state into the hardware for packet forwarding. This document specifies an information model for the RIB to enable defining a standardized data model. The IETF's I2RS WG used this document to design the I2RS RIB data model. This document is being published to record the higher-level information model decisions for RIBs so that other developers of RIBs may benefit from the design concepts.",
      "ja": "企業およびキャリアネットワークにおけるルーティングおよびルーティング機能は、典型的には、ルーティング情報ベース（RIB）を使用して、ネットワークデバイス（ルータやスイッチ）によって行われます。プロトコルおよび構成はRIBにデータをプッシュし、RIB・マネージャは、パケット転送のためのハードウェアに状態をインストールします。この文書では、標準化されたデータモデルを定義可能にするためのRIBのための情報モデルを指定します。 IETFのI2RS WGはI2RS RIBデータモデルを設計するために、この文書を使用していました。この文書では、リブの他の開発者は、設計コンセプトから利益を得ることができるように、肋骨のために、より高いレベルの情報モデルの決定を記録するために、公開されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書はインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8430.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8430で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Conventions Used in This Document . . . . . . . . . . . .   6\n2.  RIB Data  . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  RIB Definition  . . . . . . . . . . . . . . . . . . . . .   7\n  2.2.  Routing Instance  . . . . . . . . . . . . . . . . . . . .   7\n  2.3.  Route . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n  2.4.  Nexthop . . . . . . . . . . . . . . . . . . . . . . . . .  10\n    2.4.1.  Base Nexthops . . . . . . . . . . . . . . . . . . . .  12\n    2.4.2.  Derived Nexthops  . . . . . . . . . . . . . . . . . .  14\n    2.4.3.  Nexthop Indirection . . . . . . . . . . . . . . . . .  15\n3.  Reading from the RIB  . . . . . . . . . . . . . . . . . . . .  16\n4.  Writing to the RIB  . . . . . . . . . . . . . . . . . . . . .  16\n5.  Notifications . . . . . . . . . . . . . . . . . . . . . . . .  17\n6.  RIB Grammar . . . . . . . . . . . . . . . . . . . . . . . . .  17\n  6.1.  Nexthop Grammar Explained . . . . . . . . . . . . . . . .  20\n7.  Using the RIB Grammar . . . . . . . . . . . . . . . . . . . .  20\n  7.1.  Using Route Preference  . . . . . . . . . . . . . . . . .  20\n  7.2.  Using Different Nexthop Types . . . . . . . . . . . . . .  20\n    7.2.1.  Tunnel Nexthops . . . . . . . . . . . . . . . . . . .  21\n    7.2.2.  Replication Lists . . . . . . . . . . . . . . . . . .  21\n    7.2.3.  Weighted Lists  . . . . . . . . . . . . . . . . . . .  21\n    7.2.4.  Protection  . . . . . . . . . . . . . . . . . . . . .  22\n    7.2.5.  Nexthop Chains  . . . . . . . . . . . . . . . . . . .  22\n    7.2.6.  Lists of Lists  . . . . . . . . . . . . . . . . . . .  23\n  7.3.  Performing Multicast  . . . . . . . . . . . . . . . . . .  24\n8.  RIB Operations at Scale . . . . . . . . . . . . . . . . . . .  25\n  8.1.  RIB Reads . . . . . . . . . . . . . . . . . . . . . . . .  25\n  8.2.  RIB Writes  . . . . . . . . . . . . . . . . . . . . . . .  25\n  8.3.  RIB Events and Notifications  . . . . . . . . . . . . . .  25\n9.  Security Considerations . . . . . . . . . . . . . . . . . . .  25\n10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  26\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  26\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  26\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Routing and routing functions in enterprise and carrier networks are traditionally performed in network devices. Customarily, routers run routing protocols, and the routing protocols (along with static configuration information) populate the Routing Information Base (RIB) of the router. The RIB is managed by the RIB manager, and the RIB manager provides a northbound interface to its clients (i.e., the routing protocols) to insert routes into the RIB. The RIB manager consults the RIB and decides how to program the Forwarding Information Base (FIB) of the hardware by interfacing with the FIB manager. The relationship between these entities is shown in Figure 1.",
      "ja": "企業およびキャリアネットワークにおけるルーティングおよびルーティング機能は、従来のネットワークデバイスで実行されます。通例、ルータは、ルーティングプロトコルを実行し、（静的設定情報と一緒に）ルーティングプロトコルは、ルータのルーティング情報ベース（RIB）を取り込みます。 RIBは、RIBマネージャによって管理され、RIBマネージャはRIBにルートを挿入するために、クライアント（すなわち、ルーティングプロトコル）にノースバウンドインターフェイスを提供します。 RIB・マネージャは、RIBを参照し、FIBマネージャとインターフェースすることによってハードウェアの転送情報ベース（FIB）をプログラムする方法を決定します。これらのエンティティ間の関係は、図1に示されています。"
    },
    {
      "indent": 3,
      "text": "      +-------------+        +-------------+\n      |RIB Client 1 | ...... |RIB Client N |\n      +-------------+        +-------------+\n             ^                      ^\n             |                      |\n             +----------------------+\n                        |\n                        V\n             +---------------------+\n             |    RIB Manager      |\n             |                     |\n             |     +--------+      |\n             |     | RIB(s) |      |\n             |     +--------+      |\n             +---------------------+\n                        ^\n                        |\n       +---------------------------------+\n       |                                 |\n       V                                 V\n+----------------+               +----------------+\n| FIB Manager 1  |               | FIB Manager M  |\n|   +--------+   |  ..........   |   +--------+   |\n|   | FIB(s) |   |               |   | FIB(s) |   |\n|   +--------+   |               |   +--------+   |\n+----------------+               +----------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 1: RIB Manager, RIB Clients, and FIB Managers",
      "ja": "図1：RIBマネージャ、RIBクライアント、およびFIBマネージャ"
    },
    {
      "indent": 3,
      "text": "Routing protocols are inherently distributed in nature, and each router makes an independent decision based on the routing data received from its peers. With the advent of newer deployment paradigms and the need for specialized applications, there is an emerging need to guide the router's routing function [RFC7920]. The",
      "ja": "ルーティングプロトコルは、本質的に自然界に分布しており、各ルータはそのピアから受信したルーティング情報に基づいて独立した決定を下します。新しい展開のパラダイムや特殊なアプリケーションのための必要性の出現により、ルータのルーティング機能[RFC7920]を案内する新興必要があります。ザ・"
    },
    {
      "indent": 3,
      "text": "traditional network-device RIB population that is protocol based suffices for most use cases where distributed network control is used. However, there are use cases that the network operators currently address by configuring static routes, policies, and RIB import/export rules on the routers. There is also a growing list of use cases in which a network operator might want to program the RIB based on data unrelated to just routing (within that network's domain). Programming the RIB could be based on other information (such as routing data in the adjacent domain or the load on storage and compute) in the given domain. Or, it could simply be a programmatic way of creating on-demand dynamic overlays (e.g., GRE tunnels) between compute hosts (without requiring the hosts to run traditional routing protocols). If there was a standardized, publicly documented programmatic interface to a RIB, it would enable further networking applications that address a variety of use cases [RFC7920].",
      "ja": "プロトコルが基づいている従来のネットワーク・デバイスRIB集団は、分散ネットワーク制御が使用されているほとんどのユースケースで十分。しかし、ネットワークオペレータは、現在のルータでスタティックルート、ポリシー、およびRIBのインポート/エクスポートのルールを設定することによって対処することを使用する場合があります。ネットワークオペレータはちょうど（そのネットワークのドメイン内）のルーティングとは無関係なデータに基づいてRIBをプログラムする可能性のある使用例成長のリストもあります。 RIBをプログラムする特定のドメイン内の（例えば、隣接するドメインまたはストレージおよび計算の負荷のルーティングデータのような）他の情報に基づくことができます。または、単にオンデマンド（伝統的なルーティングプロトコルを実行するホストを必要とせずに）計算ホストとの間の動的オーバーレイ（例えば、GREトンネルを）作成のプログラム方法であってもよいです。 RIBに標準化され、一般に公開プログラム・インタフェースがあった場合、それは、ユースケース[RFC7920]の様々な対処、さらにネットワーキング・アプリケーションを可能にします。"
    },
    {
      "indent": 3,
      "text": "A programmatic interface to the RIB involves two types of operations: reading from the RIB and writing (adding/modifying/deleting) to the RIB.",
      "ja": "RIBから読み取り、RIBに（追加/修正/削除）を書き込む：RIBへのプログラムインターフェースは、操作の二つのタイプを含みます。"
    },
    {
      "indent": 3,
      "text": "In order to understand what is in a router's RIB, methods like per-protocol SNMP MIBs and screen scraping are used. These methods are not scalable since they are client pull mechanisms and not proactive push (from the router) mechanisms. Screen scraping is error prone (since the output format can change) and is vendor dependent. Building a RIB from per-protocol MIBs is error prone since the MIB data represents protocol data and not the exact information that went into the RIB. Thus, just getting read-only RIB information from a router is a hard task.",
      "ja": "ルータのRIBであるかを理解するためには、プロトコルごとのSNMPのMIBとスクリーンスクレイピングなどの方法が使用されています。彼らは、クライアントプルメカニズムとメカニズム（ルータから）積極的ではないプッシュされているので、これらのメソッドは、スケーラブルではありません。スクリーン・スクレイピングは、誤りやすい（出力フォーマットが変更できるため）及びベンダーに依存します。 MIBデータは、プロトコルデータなくRIBに入った正確な情報を表すのでごとプロトコルのMIBからRIBを構築すると、エラー傾向があります。このように、単にルータから読み取り専用のRIB情報を得ることは難しい作業です。"
    },
    {
      "indent": 3,
      "text": "Adding content to the RIB from a RIB client can be done today using static configuration mechanisms provided by router vendors. However, the mix of what can be modified in the RIB varies from vendor to vendor, and the method of configuring it is also vendor dependent. This makes it hard for a RIB client to program a multi-vendor network in a consistent and vendor-independent way.",
      "ja": "RIBクライアントからRIBへの追加コンテンツは、ルータベンダが提供する静的な設定メカニズムを使用して、今日行うことができます。しかし、RIBで変更することができるもののミックスは、ベンダーからベンダーに変化し、それを構成する方法も、ベンダーに依存しています。これは、ハードRIBクライアントは、一貫して、ベンダーに依存しない方法でマルチベンダーネットワークをプログラムできるようになります。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to specify an information model for the RIB. Using the information model, one can build a detailed data model for the RIB. That data model could then be used by a RIB client to program a network device. One data model that has been based on this document is the I2RS RIB data model [RFC8431].",
      "ja": "このドキュメントの目的は、RIBのための情報モデルを指定することです。情報モデルを使用して、一つはRIBの詳細なデータモデルを構築することができます。このデータモデルは、ネットワークデバイスをプログラムするRIBクライアントで使用することができます。この文書に基づいてされた一つのデータモデルは、I2RS RIBデータモデル[RFC8431]です。"
    },
    {
      "indent": 3,
      "text": "The rest of this document is organized as follows. Section 2 goes into the details of what constitutes and can be programmed in a RIB. Guidelines for reading and writing the RIB are provided in Sections 3 and 4, respectively. Section 5 provides a high-level view of the",
      "ja": "このドキュメントの残りは以下の通り構成されています。第2節では、構成するものの細部に入り、RIBにプログラムすることができます。 RIBを読み書きするためのガイドラインは、それぞれ、セクション3と4に設けられています。セクション5は、高レベルのビューを提供します"
    },
    {
      "indent": 3,
      "text": "events and notifications going from a network device to a RIB client to update the RIB client on asynchronous events. The RIB grammar is specified in Section 6. Examples of using the RIB grammar are shown in Section 7. Section 8 covers considerations for performing RIB operations at scale.",
      "ja": "非同期イベントにRIBクライアントを更新するために、RIBクライアントにネットワークデバイスから行くイベントと通知。 RIB文法はRIB文法を使用しての6例はセクション8がスケールでRIB操作を実行するための考慮事項をカバーセクション7に示されているセクションで指定されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. RIB Data",
      "section_title": true,
      "ja": "2. RIBデータ"
    },
    {
      "indent": 3,
      "text": "This section describes the details of a RIB. It makes forward references to objects in the RIB grammar (see Section 6). A high-level description of the RIB contents is as shown in Figure 2. Please note that for ease of representation in ASCII art, this drawing shows a single routing instance, a single RIB, and a single route. Subsections of this section describe the logical data nodes that should be contained within a RIB. Sections 3 and 4 describe the high-level read and write operations.",
      "ja": "このセクションでは、RIBの詳細を説明します。これは、（セクション6を参照）RIB文法内のオブジェクトへの前方参照を行います。アスキーアートでの表現を容易にするために、この図は、単一のルーティングインスタンス、単一RIB、および単一のルートを示すことに注意してください図2に示すように、RIBコンテンツのハイレベルの説明があります。このセクションのサブセクションでは、RIB内に含まれるべきである論理データ・ノードを記述する。セクション3と4は、高レベルのリードを記述し、書き込み操作。"
    },
    {
      "indent": 20,
      "text": "      network-device\n            |\n            | 0..N\n            |\n     routing instance(s)\n      |             |\n      |             |\n0..N  |             | 0..N\n      |             |\n interface(s)     RIB(s)\n                    |\n                    |\n                    | 0..N\n                    |\n                  route(s)",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2: RIB Information Model",
      "ja": "図2：RIB情報モデル"
    },
    {
      "indent": 0,
      "text": "2.1. RIB Definition",
      "section_title": true,
      "ja": "2.1.  RIBの定義"
    },
    {
      "indent": 3,
      "text": "A RIB, in the context of the RIB information model, is an entity that contains routes. It is identified by its name and is contained within a routing instance (see Section 2.2). A network device MAY contain routing instances, and each routing instance MAY contain RIBs. The name MUST be unique within a routing instance. All routes in a given RIB MUST be of the same address family (e.g., IPv4). Each RIB MUST belong to a routing instance.",
      "ja": "RIBは、RIB情報モデルのコンテキスト内で、ルートを含むエンティティです。それは、その名前によって識別され、ルーティングインスタンス内に含まれる（セクション2.2参照）。ネットワークデバイスは、ルーティングインスタンスを含むことができ、各ルーティングインスタンスリブを含むかもしれません。名前は、ルーティングインスタンス内で一意でなければなりません。所与RIBのすべてのルートが同じアドレスファミリー（例えば、IPv4）のでなければなりません。各リブは、ルーティングインスタンスに属している必要があります。"
    },
    {
      "indent": 3,
      "text": "A routing instance may contain two or more RIBs of the same address family (e.g., IPv6). A typical case where this can be used is for multi-topology routing [RFC4915] [RFC5120].",
      "ja": "ルーティングインスタンスは、同一のアドレスファミリー（例えば、IPv6）の二以上のリブを含むことができます。これを使用することができる典型的なケースは、マルチトポロジルーティング[RFC4915]、[RFC5120]のためのものです。"
    },
    {
      "indent": 3,
      "text": "Each RIB MAY be associated with an ENABLE_IP_RPF_CHECK attribute that enables Reverse Path Forwarding (RPF) checks on all IP routes in that RIB. The RPF check is used to prevent spoofing and limit malicious traffic. For IP packets, the IP source address is looked up and the RPF interface(s) associated with the route for that IP source address is found. If the incoming IP packet's interface matches one of the RPF interfaces, then the IP packet is forwarded based on its IP destination address; otherwise, the IP packet is discarded.",
      "ja": "各リブは、そのRIB内のすべてのIPルート上のReverse Path Forwarding（RPF）チェックを可能にENABLE_IP_RPF_CHECK属性に関連付けることができます。 RPFチェックは、なりすましを防止し、悪意のあるトラフィックを制限するために使用されます。 IPパケットは、IPソースアドレスが検索され、そのIPソースアドレスのルートに関連するRPFインターフェイス（複数可）が見出されます。着信IPパケットのインターフェイスは、RPFインターフェイスのいずれかと一致する場合、IPパケットは、そのIP宛先アドレスに基づいて転送されます。そうでない場合は、IPパケットが破棄されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Routing Instance",
      "section_title": true,
      "ja": "2.2. ルーティングインスタンス"
    },
    {
      "indent": 3,
      "text": "A routing instance, in the context of the RIB information model, is a collection of RIBs, interfaces, and routing parameters. A routing instance creates a logical slice of the router. It allows different logical slices across a set of routers to communicate with each other. Layer 3 VPNs, Layer 2 VPNs (L2VPNs), and Virtual Private LAN Service (VPLS) can be modeled as routing instances. Note that modeling an L2VPN using a routing instance only models the Layer 3 (RIB) aspect and does not model any Layer 2 information (like ARP) that might be associated with the L2VPN.",
      "ja": "ルーティングインスタンスは、RIB情報モデルの文脈において、リブ、インターフェース、およびルーティングパラメータの集合です。ルーティングインスタンスは、ルータの論理スライスを作成します。これは、ルータのセットにわたって異なる論理スライスが互いに通信することを可能にします。レイヤ3つのVPN、レイヤ2つのVPN（のL2VPN）、および仮想プライベートLANサービス（VPLS）は、ルーティングインスタンスとしてモデル化することができます。唯一のモデルのレイヤ3（RIB）の態様をルーティングインスタンスを使用してL2VPNをモデル化し、（ARPなど）任意のレイヤ2情報をモデル化しないことL2VPNに関連付けられるかもしれないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The set of interfaces indicates which interfaces are associated with this routing instance. The RIBs specify how incoming traffic is to be forwarded, and the routing parameters control the information in the RIBs. The intersection set of interfaces of two routing instances MUST be the null set. In other words, an interface MUST NOT be present in two routing instances. Thus, a routing instance describes the routing information and parameters across a set of interfaces.",
      "ja": "インターフェイスのセットは、このルーティングインスタンスに関連付けられているインタフェースを示します。リブは、トラフィックが転送されるべきであり、ルーティングパラメータリブで制御情報を受信する方法を指定します。 2つのルーティングインスタンスのインターフェイスのセットの交差をnullに設定する必要があります。換言すれば、インタフェースは、2つのルーティングインスタンスに存在してはなりません。したがって、ルーティングインスタンスは、インタフェースのセットを横切ってルーティング情報とパラメータを記載しています。"
    },
    {
      "indent": 3,
      "text": "A routing instance MUST contain the following mandatory fields:",
      "ja": "ルーティングインスタンスは、次の必須フィールドが含まれている必要があります"
    },
    {
      "indent": 3,
      "text": "o INSTANCE_NAME: A routing instance is identified by its name, INSTANCE_NAME. This MUST be unique across all routing instances in a given network device.",
      "ja": "O INSTANCE_NAME：ルーティングインスタンスは、その名前、INSTANCE_NAMEによって識別されます。これは、特定のネットワークデバイス内のすべてのルーティングインスタンスで一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "o rib-list: This is the list of RIBs associated with this routing instance. Each routing instance can have multiple RIBs to represent routes of different types. For example, one would put IPv4 routes in one RIB and MPLS routes in another RIB. The list of RIBs can be an empty list.",
      "ja": "Oリブリスト：これは、このルーティングインスタンスに関連付けられたリブのリストです。各ルーティングインスタンスは、異なる種類の経路を表す複数の肋骨を有することができます。例えば、1は別のRIBに1つのRIBでのIPv4ルートおよびMPLSのルートを置きます。リブのリストは空のリストにすることができます。"
    },
    {
      "indent": 3,
      "text": "A routing instance MAY contain the following fields:",
      "ja": "ルーティングインスタンスは、次のフィールドが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "o interface-list: This represents the list of interfaces associated with this routing instance. The interface list helps constrain the boundaries of packet forwarding. Packets coming in on these interfaces are directly associated with the given routing instance. The interface list contains a list of identifiers, with each identifier uniquely identifying an interface.",
      "ja": "Oインタフェースリスト：これは、このルーティングインスタンスに関連付けられているインタフェースのリストを表します。インタフェースリストは、パケット転送の境界を制約することができます。これらのインタフェースに着信パケットが直接指定されたルーティングインスタンスに関連付けられています。インタフェースリストは、各識別子は一意のインターフェイスを識別して、識別子のリストを含みます。"
    },
    {
      "indent": 3,
      "text": "o ROUTER_ID: This field identifies the network device in control plane interactions with other network devices. This field is to be used if one wants to virtualize a physical router into multiple virtual routers. Each virtual router MUST have a unique ROUTER_ID. A ROUTER_ID MUST be unique across all network devices in a given domain.",
      "ja": "O ROUTER_ID：このフィールドは、他のネットワーク機器と制御プレーン相互作用におけるネットワークデバイスを識別する。このフィールドは1つが、複数の仮想ルータに物理的なルータを仮想化したい場合に使用されます。各仮想ルータはユニークROUTER_IDを持たなければなりません。 ROUTER_IDは、特定のドメイン内のすべてのネットワークデバイス間で一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "A routing instance may be created purely for the purposes of packet processing and may not have any interfaces associated with it. For example, an incoming packet in routing instance A might have a nexthop of routing instance B, and after packet processing in B, the nexthop might be routing instance C. Thus, routing instance B is not associated with any interface. And, given that this routing instance does not do any control-plane interaction with other network devices, a ROUTER_ID is also not needed.",
      "ja": "ルーティングインスタンスは、パケット処理のために純粋に作成されてもよいし、それに関連する任意のインターフェースを有していなくてもよいです。例えば、インスタンスAルーティングにおける着信パケットは、ルーティングインスタンスBのネクストホップがあるかもしれない、そしてBにおけるパケット処理の後、ネクストホップは、任意のインターフェイスに関連付けられていないインスタンスBルーティング、したがってインスタンスC.ルーティングかもしれません。そして、このルーティングインスタンスは、他のネットワークデバイスとの任意のコントロールプレーンの相互作用をしないことを考えると、ROUTER_IDも必要ありません。"
    },
    {
      "indent": 0,
      "text": "2.3. Route",
      "section_title": true,
      "ja": "2.3. ルート"
    },
    {
      "indent": 3,
      "text": "A route is essentially a match condition and an action following the match. The match condition specifies the kind of route (IPv4, MPLS, etc.) and the set of fields to match on. Figure 3 represents the overall contents of a route. Please note that for ease of depiction in ASCII art, only a single instance of the route-attribute, match flags, and nexthop is depicted.",
      "ja": "経路は、本質的に一致条件と一致する次のアクションです。一致条件は、経路の種類（IPv4の、MPLSなど）とに一致するフィールドのセットを指定します。図3は、経路の全体的な内容を示しています。 ASCIIアートでの描写を容易にするために、ルート属性、一致フラグ、およびネクストホップの単一インスタンスのみが描かれていることに注意してください。"
    },
    {
      "indent": 18,
      "text": "               route\n               | | |\n     +---------+ | +----------+\n     |           |            |\n0..N |           |            |",
      "raw": true
    },
    {
      "indent": 9,
      "text": "route-attribute         match         nexthop\n                          |\n                          |\n          +-------+-------+-------+--------+\n          |       |       |       |        |\n          |       |       |       |        |",
      "raw": true
    },
    {
      "indent": 18,
      "text": "IPv4 IPv6 MPLS MAC Interface",
      "ja": "IPv4からIPv6 MPLS MACインターフェース"
    },
    {
      "indent": 27,
      "text": "Figure 3: Route Model",
      "ja": "図3：ルートモデル"
    },
    {
      "indent": 3,
      "text": "This document specifies the following match types:",
      "ja": "このドキュメントでは、次のマッチタイプを指定します。"
    },
    {
      "indent": 3,
      "text": "o IPv4: Match on destination and/or source IP address in the IPv4 header",
      "ja": "OのIPv4：IPv4ヘッダ内の宛先及び/又はソースIPアドレスに一致"
    },
    {
      "indent": 3,
      "text": "o IPv6: Match on destination and/or source IP address in the IPv6 header",
      "ja": "OのIPv6：IPv6ヘッダーの宛先及び/又はソースIPアドレスに一致"
    },
    {
      "indent": 3,
      "text": "o MPLS: Match on an MPLS label at the top of the MPLS label stack",
      "ja": "MPLS O：MPLSラベルスタックの最上位にMPLSラベルに一致"
    },
    {
      "indent": 3,
      "text": "o MAC: Match on Media Access Control (MAC) destination addresses in the Ethernet header",
      "ja": "O MAC：イーサネットヘッダにマッチメディアアクセス制御（MAC）上の宛先アドレス"
    },
    {
      "indent": 3,
      "text": "o Interface: Match on the incoming interface of the packet",
      "ja": "Oインタフェース：パケットの着信インターフェイスにマッチ"
    },
    {
      "indent": 3,
      "text": "A route MAY be matched on one or more of these match types by policy as either an \"AND\" (to restrict the number of routes) or an \"OR\" (to combine two filters).",
      "ja": "ルートは、1つまたは複数のポリシーによって、これらのマッチタイプのいずれかの「AND」（ルートの数を制限する）または「OR」（2つのフィルタを結合する）に一致させることができます。"
    },
    {
      "indent": 3,
      "text": "Each route MUST have the following mandatory route-attributes associated with it:",
      "ja": "各ルートは、それに関連付けられた次の必須ルートの属性を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "o ROUTE_PREFERENCE: This is a numerical value that allows for comparing routes from different protocols. Static configuration is also considered a protocol for the purpose of this field. It is also known as \"administrative distance\". The lower the value, the higher the preference. For example, there can be an OSPF route for 192.0.2.1/32 (or IPv6 2001:DB8::1/128) with a preference of 5. If a controller programs a route for 192.0.2.1/32 (or IPv6 2001:DB8::1/128) with a preference of 2, then the controller's route will be preferred by the RIB manager. Preference should be used to dictate behavior. For more examples of preference, see Section 7.1.",
      "ja": "ROUTE_PREFERENCE O：これは、異なるプロトコルからのルートを比較することを可能にする数値です。静的な構成も、このフィールドの目的のためのプロトコルと考えられています。また、「管理距離」として知られています。嗜好より高い値より低いです。例えば、192.0.2.1/32のOSPF経路が存在することができる（またはIPv6 2001：DB8 :: 1/128）制御プログラムの場合5の嗜好192.0.2.1/32（またはIPv6 2001ルートに： DB8 :: 1/128）2の嗜好とは、コントローラのルートはRIBマネージャによって好ましいであろう。好ましくは、動作を指示するために使用されるべきです。好みのその他の例については、7.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Each route can have one or more optional route-attributes associated with it.",
      "ja": "各ルートは、それに関連する1つ以上のオプションのルートの属性を持つことができます。"
    },
    {
      "indent": 3,
      "text": "o route-vendor-attributes: Vendors can specify vendor-specific attributes using this. The details of this attribute are outside the scope of this document.",
      "ja": "ルート・ベンダーの属性O：ベンダーはこれを使用して、ベンダー固有の属性を指定することができます。この属性の詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Each route has a nexthop associated with it. Nexthops are described in Section 2.4.",
      "ja": "各ルートは、それに関連付けられているネクストホップを持っています。 Nexthopsは、2.4節で説明されています。"
    },
    {
      "indent": 3,
      "text": "Additional features to match multicast packets were considered (e.g., TTL of the packet to limit the range of a multicast group), but these were not added to this information model. Future RIB information models should investigate these multicast features.",
      "ja": "追加機能は、マルチキャストパケット（例えば、パケットのTTLは、マルチキャストグループの範囲を制限するために）と考えられた一致するが、これらはこの情報モデルに追加されませんでした。将来のRIB情報モデルは、これらのマルチキャスト機能を調査する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Nexthop",
      "section_title": true,
      "ja": "2.4. ネクスト"
    },
    {
      "indent": 3,
      "text": "A nexthop represents an object resulting from a route lookup. For example, if a route lookup results in sending the packet out of a given interface, then the nexthop represents that interface.",
      "ja": "ネクストホップは、ルートルックアップに起因するオブジェクトを表します。例えば、所定のインターフェイスからパケットを送信することでルートルックアップをもたらす場合、ネクストホップは、そのインタフェースを表します。"
    },
    {
      "indent": 3,
      "text": "Nexthops can be either fully resolved or unresolved. A resolved nexthop has adequate information to send the outgoing packet to the destination by forwarding it on an interface to a directly connected neighbor. For example, a nexthop to a point-to-point interface or a nexthop to an IP address on an Ethernet interface has the nexthop resolved. An unresolved nexthop is something that requires the RIB manager to determine the final resolved nexthop. For example, a nexthop could be an IP address. The RIB manager would resolve how to reach that IP address; for example, is the IP address reachable by regular IP forwarding, by an MPLS tunnel, or by both? If the RIB manager cannot resolve the nexthop, then the nexthop remains in an unresolved state and is NOT a candidate for installation in the FIB. Future RIB events can cause an unresolved nexthop to get resolved (e.g., an IP address being advertised by an IGP neighbor). Conversely, resolved nexthops can also become unresolved (e.g., in the case of a tunnel going down); hence, they would no longer be candidates to be installed in the FIB.",
      "ja": "Nexthopsは完全に解決または未解決することができます。解決ネクストホップは直接接続されたネイバーのインターフェイス上で転送することによって先に発信パケットを送信するために十分な情報を有しています。例えば、ポイントツーポイントインターフェースまたはイーサネットインターフェイスのIPアドレスへのネクストホップへのネクストホップは、ネクストホップが解決しています。未解決のネクストホップは、最終的な解決ネクストホップを決定するために、RIB管理を必要とするものです。たとえば、ネクストホップはIPアドレスである可能性があります。 RIBマネージャは、そのIPアドレスに到達するためにどのように解決するでしょう。例えば、定期的なIP転送によって、MPLSトンネルによって、または両方によって到達可能なIPアドレスは？ RIBマネージャがネクストホップを解決できない場合は、ネクストホップは未解決の状態のままで、FIBでのインストールのための候補ではありません。将来のRIBイベントが未解決のネクストホップが解決を取得することがあります（たとえば、IPアドレスは、IGPネイバによってアドバタイズされています）。逆に、解決nexthopsはまた、（例えば、ダウントンネルの場合）未解決になることができます。それゆえ、彼らはもはや、FIBにインストールするための候補としないであろう。"
    },
    {
      "indent": 3,
      "text": "When at least one of a route's nexthops is resolved, then the route can be used to forward packets. Such a route is considered eligible to be installed in the FIB and is henceforth referred to as a FIB-eligible route. Conversely, when all the nexthops of a route are unresolved, that route can no longer be used to forward packets. Such a route is considered ineligible to be installed in the FIB and is henceforth referred to as a FIB-ineligible route. The RIB information model allows a RIB client to program routes whose nexthops may be unresolved initially. Whenever an unresolved nexthop gets resolved, the RIB manager will send a notification of the same (see Section 5).",
      "ja": "ルートのnexthopsの少なくとも一つが解決されると、ルートはパケットを転送するために使用することができます。そのような経路がFIBにインストールの対象とみなされ、以後FIB適格経路と呼ばれます。経路の全てnexthopsが未解決である場合、逆に、その経路はもはやパケットを転送するために使用することができません。そのような経路がFIBにインストールすることが不適格とみなされ、以後FIB-不適格経路と呼ばれます。 RIB情報モデルはnexthops最初未解決であってもよいプログラムルートにRIBクライアントを可能にします。未解決のネクストホップが解決されるたびに、RIBマネージャは（セクション5を参照）と同じの通知を送信します。"
    },
    {
      "indent": 3,
      "text": "The overall structure and usage of a nexthop is as shown in the figure below. For ease of description using ASCII art, only a single instance of any component of the nexthop is shown in Figure 4.",
      "ja": "下図に示すように、ネクストホップの全体的な構造および使用方法です。 ASCIIアートを用いて説明を容易にするため、ネクストホップの任意のコンポーネントの単一のインスタンスは、図4に示されています。"
    },
    {
      "indent": 1,
      "text": "                              route\n                                |\n                                | 0..N\n                                |\n                              nexthop <-------------------------------+\n                                |                                     |\n         +-------+----------------------------+-------------+         |\n         |       |              |             |             |         |\n         |       |              |             |             |         |\n      base   load-balance   protection      replicate     chain       |\n         |       |              |             |             |         |\n         |       |2..N          |2..N         |2..N         |1..N     |\n         |       |              |             |             |         |\n         |       |              V             |             |         |\n         |       +------------->+<------------+-------------+         |\n         |                      |                                     |\n         |                      +-------------------------------------+\n         |\n         +-------------------+\n                             |\n                             |\n                             |\n                             |\n    +---------------+--------+--------+--------------+----------+\n    |               |                 |              |          |\n    |               |                 |              |          |\n nexthop-id  egress-interface  ip-address     logical-tunnel    |\n                                                                |\n                                                                |\n                         +--------------------------------------+\n                         |\n      +----------------------+------------------+-------------+\n      |                      |                  |             |\n      |                      |                  |             |\ntunnel-encapsulation   tunnel-decapsulation  rib-name   special-nexthop",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 4: Nexthop Model",
      "ja": "図4：ネクストモデル"
    },
    {
      "indent": 3,
      "text": "This document specifies a very generic, extensible, and recursive grammar for nexthops. A nexthop can be a base nexthop or a derived nexthop. Section 2.4.1 details base nexthops, and Section 2.4.2 explains various kinds of derived nexthops. There are certain special nexthops, and those are described in Section 2.4.1.1. Lastly, Section 2.4.3 delves into nexthop indirection and its use. Examples of when and how to use tunnel nexthops and derived nexthops are shown in Section 7.2.",
      "ja": "この文書では、nexthopsのために非常に一般的な、拡張性、および再帰的な文法を指定します。ネクストホップは、ベースネクストホップまたは派生ネクストホップであることができます。 2.4.1詳細ベースnexthops、および2.4.2項は、派生nexthopsの様々な種類を説明しています。そこ特定の特殊nexthopsがあり、それらは、2.4.1.1項で説明されています。最後に、セクション2.4.3は、ネクストホップの間接およびその使用掘り下げ。トンネルnexthopsと派生nexthopsを使用する場合と方法の例はセクション7.2に示されています。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Base Nexthops",
      "section_title": true,
      "ja": "2.4.1. ベースNexthops"
    },
    {
      "indent": 3,
      "text": "At the lowest level, a nexthop can be one of the following:",
      "ja": "最低レベルでは、ネクストホップは、次のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "o Identifier: This is an identifier returned by the network device representing a nexthop. This can be used as a way of reusing a nexthop when programming derived nexthops.",
      "ja": "O識別子：これは、ネクストホップを表すネットワークデバイスによって返される識別子です。これは、派生nexthopsをプログラミングする際にネクストホップを再利用する方法として使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Interface nexthops: These are nexthops that are pointing to an interface. Various attributes associated with these nexthops are:",
      "ja": "Oインタフェースはnexthops：これらは、インタフェースを指しているnexthopsです。これらnexthopsに関連する様々な属性は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface: This represents a physical, logical, or virtual interface on the network device. Address resolution must not be required on this interface. This interface may belong to any routing instance.",
      "ja": "*出口インタフェース：これは、ネットワークデバイス上の、物理的、論理、または仮想インタフェースを表します。アドレス解決は、このインターフェイス上で必要とされてはなりません。このインタフェースは、任意のルーティングインスタンスに属していてもよいです。"
    },
    {
      "indent": 6,
      "text": "* IP address: A route lookup on this IP address is done to determine the egress-interface. Address resolution may be required depending on the interface.",
      "ja": "* IPアドレス：このIPアドレス上のルート検索は、出力インターフェイスを決定するために行われます。アドレス解決は、インターフェイスに応じ必要とすることができます。"
    },
    {
      "indent": 9,
      "text": "+ An optional rib-name can also be specified to indicate the RIB in which the IP address is to be looked up. One can use the rib-name field to direct the packet from one domain into another domain. By default the RIB will be the same as the one that route belongs to.",
      "ja": "+オプションのリブ名前もIPアドレスが検索されるべきRIBを示すために指定することができます。一つは、別のドメインにあるドメインからのパケットを指示するためにリブ名前のフィールドを使用することができます。デフォルトでは、RIBは、ルートが属しているものと同じになります。"
    },
    {
      "indent": 6,
      "text": "These attributes can be used in combination as follows:",
      "ja": "次のようにこれらの属性を組み合わせて使用​​することができます。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface and IP address: This can be used in cases where, e.g., the IP address is a link-local address.",
      "ja": "*出口インタフェースとIPアドレス：これは、例えば、IPアドレスがリンクローカルアドレスである場合に使用することができます。"
    },
    {
      "indent": 6,
      "text": "* Egress-interface and MAC address: The egress-interface must be an Ethernet interface. Address resolution is not required for this nexthop.",
      "ja": "*出口インターフェイスおよびMACアドレス：出口インターフェイスは、イーサネットインターフェイスでなければなりません。アドレス解決は、このネクストホップのために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "o Tunnel nexthops: These are nexthops that are pointing to a tunnel. The types of tunnel nexthops are:",
      "ja": "トンネルnexthops O：これらは、トンネルを指しているnexthopsです。トンネルnexthopsのタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* tunnel-encapsulation: This can be an encapsulation representing an IP tunnel, MPLS tunnel, or others as defined in this document. An optional egress-interface can be chained to the tunnel-encapsulation to indicate which interface to send the packet out on. The egress-interface is useful when the network device contains Ethernet interfaces and one needs to perform address resolution for the IP packet.",
      "ja": "*トンネルカプセル化：これは、この文書で定義されるようにIPトンネルを表すカプセル、MPLSトンネル、等とすることができます。オプションの出力インタフェースは、アウトにパケットを送信するためにどのインタフェースを示すために、トンネルカプセル化に連鎖させることができます。ネットワークデバイスは、イーサネットインターフェイスを含み、一方はIPパケットのアドレス解決を実行する必要がある場合に出力インタフェースは有用です。"
    },
    {
      "indent": 6,
      "text": "* tunnel-decapsulation: This is to specify decapsulating a tunnel header. After decapsulation, further lookup on the packet can be done via chaining it with another nexthop. The packet can also be sent out via an egress-interface directly.",
      "ja": "*トンネルカプセル化解除：これは、トンネルヘッダをデカプセル化を指定することです。カプセル解除した後、パケットの更なるルックアップは別のネクストホップでそれをチェーンを介して行うことができます。また、パケットは直接出力インタフェースを介して送信することができます。"
    },
    {
      "indent": 6,
      "text": "* logical-tunnel: This can be an MPLS Label Switched Path (LSP) or a GRE tunnel (or others as defined in this document) that is represented by a unique identifier (e.g., name).",
      "ja": "*論理トンネル：これは、MPLSラベルスイッチパス（LSP）またはGREトンネル（又は本文書で定義されているなど）固有の識別子（例えば、名前）で表されることができます。"
    },
    {
      "indent": 3,
      "text": "o rib-name: A nexthop pointing to a RIB. This indicates that the route lookup needs to continue in the specified RIB. This is a way to perform chained lookups.",
      "ja": "Oリブ名：RIBを指すネクストホップ。これは、ルートルックアップは、指定されたRIBに継続する必要があることを示しています。これは、チェーンルックアップを実行する方法です。"
    },
    {
      "indent": 3,
      "text": "Tunnel nexthops allow a RIB client to program static tunnel headers. There can be cases where the remote tunnel endpoint does not support dynamic signaling (e.g., no LDP support on a host); in those cases, the RIB client might want to program the tunnel header on both ends of the tunnel. The tunnel nexthop is kept generic with specifications provided for some commonly used tunnels. It is expected that the data model will model these tunnel types with complete accuracy.",
      "ja": "トンネルnexthopsはRIBクライアントが静的トンネルヘッダをプログラムすることができます。リモートトンネルエンドポイントは、動的なシグナリングをサポートしない場合があり得る（例えば、ホストにはLDPサポート）。これらの例では、RIBクライアントは、トンネルの両端のトンネルヘッダーをプログラムすることがあります。トンネルネクストホップは、いくつかの一般的に使用されるトンネルのために提供された仕様とジェネリック保たれています。データモデルは、完全な精度でこれらのトンネルタイプをモデル化することが期待されます。"
    },
    {
      "indent": 0,
      "text": "2.4.1.1. Special Nexthops",
      "section_title": true,
      "ja": "2.4.1.1。特別Nexthops"
    },
    {
      "indent": 3,
      "text": "Special nexthops are for performing specific well-defined functions (e.g., DISCARD). The purpose of each of them is explained below:",
      "ja": "特別nexthopsは、特定の明確に定義された機能（例えば、DISCARD）を行うためのものです。それらのそれぞれの目的を説明します。"
    },
    {
      "indent": 3,
      "text": "o DISCARD: This indicates that the network device should drop the packet and increment a drop counter.",
      "ja": "O DISCARD：これは、ネットワークデバイスは、パケットをドロップすると、ドロップカウンタをインクリメントする必要があることを示しています。"
    },
    {
      "indent": 3,
      "text": "o DISCARD_WITH_ERROR: This indicates that the network device should drop the packet, increment a drop counter, and send back an appropriate error message (like ICMP error).",
      "ja": "O DISCARD_WITH_ERROR：これは、ネットワークデバイスは、パケットをドロップするドロップカウンタをインクリメントし、（ICMPエラーなど）、適切なエラーメッセージを返すべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": "o RECEIVE: This indicates that the traffic is destined for the network device, for example, protocol packets or Operations, Administration, and Maintenance (OAM) packets. All locally destined traffic SHOULD be throttled to avoid a denial-of-service attack on the router's control plane. An optional rate limiter can be specified to indicate how to throttle traffic destined for the control plane. The description of the rate limiter is outside the scope of this document.",
      "ja": "O RECEIVE：これは、トラフィックは、ネットワークデバイスのために、例えば、プロトコルパケットや運用、管理、および保守（OAM）パケットを宛先としていることを示します。すべてのローカル宛てのトラフィックは、ルータのコントロールプレーン上のサービス拒否攻撃を回避するために絞るべきである（SHOULD）。オプションのレートリミッタは、コントロールプレーン宛てのトラフィックを絞る方法を示すために指定することができます。レートリミッタの説明は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Derived Nexthops",
      "section_title": true,
      "ja": "2.4.2. 派生Nexthops"
    },
    {
      "indent": 3,
      "text": "Derived nexthops can be:",
      "ja": "派生nexthopsは指定できます"
    },
    {
      "indent": 3,
      "text": "o weighted lists, which are used for load-balancing;",
      "ja": "負荷分散のために使用されている加重リスト、O;"
    },
    {
      "indent": 3,
      "text": "o preference lists, which are used for protection using primary and backup;",
      "ja": "プライマリおよびバックアップを使用して保護するために使用されているO優先リスト、;"
    },
    {
      "indent": 3,
      "text": "o replication lists, which are lists of nexthops to which to replicate a packet;",
      "ja": "パケットを複製するためにnexthopsのリストであるO複製リスト、;"
    },
    {
      "indent": 3,
      "text": "o nexthop chains, which are for chaining multiple operations or attaching multiple headers; or",
      "ja": "複数の操作を連鎖または複数のヘッダを取り付けるためのものであるネクストホップチェーン、O。または"
    },
    {
      "indent": 3,
      "text": "o lists of lists, which are a recursive application of the above.",
      "ja": "上記の再帰的適用されているリストのOリスト、。"
    },
    {
      "indent": 3,
      "text": "Nexthop chains (see Section 7.2.5 for usage) are a way to perform multiple operations on a packet by logically combining them. For example, one can chain together \"decapsulate MPLS header\" and \"send it out a specific egress-interface\". Chains can be used to specify multiple headers over a packet before a packet is forwarded. One simple example is that of MPLS over GRE, wherein the packet has an inner MPLS header followed by a GRE header followed by an IP header. The outermost IP header is decided by the network device, whereas the MPLS header or GRE header is specified by the controller. Not every network device will be able to support all kinds of nexthop chains and an arbitrary number of headers chained together. The RIB data model SHOULD provide a way to expose a nexthop chaining capability supported by a given network device.",
      "ja": "ネクストホップチェーンは、（使用については、セクション7.2.5を参照）、論理的にそれらを組み合わせることで、パケットに複数の操作を実行するための方法です。例えば、一緒に1缶鎖「デカプセル化のMPLSヘッダ」とは、「特定のイグレスインタフェースをそれを送ります」。チェーンは、パケットが転送される前に、パケット上で複数のヘッダを指定するために使用することができます。一つの簡単な例は、パケットがIPヘッダに続くGREヘッダに続いて、内側MPLSヘッダを有し、GRE上MPLSのものです。 MPLSヘッダーまたはGREヘッダがコントローラによって指定され、一方、最も外側のIPヘッダは、ネットワークデバイスによって決定されます。必ずしもすべてのネットワークデバイスは、ネクストホップチェーンのすべての種類と一緒にチェーンのヘッダの任意の数をサポートすることができるようになります。 RIB・データ・モデルは、所与のネットワークデバイスによってサポートされているネクストホップチェーンの能力を公開する方法を提供すべきです。"
    },
    {
      "indent": 3,
      "text": "It is expected that all network devices will have a limit on how many levels of lookup can be performed, and not all hardware will be able to support all kinds of nexthops. RIB capability negotiation becomes very important for this reason, and a RIB data model MUST specify a way for a RIB client to learn about the network device's capabilities.",
      "ja": "すべてのネットワークデバイスは、ルックアップの多くのレベルを実行することができる方法に制限があります、そしてないすべてのハードウェアがnexthopsのすべての種類をサポートできるようになることを期待されています。 RIB機能ネゴシエーションは、このような理由のために非常に重要になってくると、RIBデータモデルは、ネットワークデバイスの機能について学ぶためにRIBクライアントのための方法を指定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4.2.1. Nexthop List Attributes",
      "section_title": true,
      "ja": "2.4.2.1。ネクストホップリストの属性"
    },
    {
      "indent": 3,
      "text": "For nexthops that are of the form of a list(s), attributes can be associated with each member of the list to indicate the role of an individual member of the list. Two attributes are specified:",
      "ja": "リスト（S）の形態であるnexthopsため、属性がリストの個々のメンバーの役割を示すために、リストの各メンバーに関連付けることができます。二つの属性が指定されています。"
    },
    {
      "indent": 3,
      "text": "o NEXTHOP_PREFERENCE: This is used for protection schemes. It is an integer value between 1 and 99. A lower value indicates higher preference. To download a primary/standby pair to the FIB, the nexthops that are resolved and have the two highest preferences are selected. Each <NEXTHOP_PREFERENCE> should have a unique value within a <nexthop-protection> (see Section 6).",
      "ja": "NEXTHOP_PREFERENCE O：これは、保護スキームのために使用されています。より低い値は、より高い優先度を示す1から99までの整数値です。 FIBへの主/スタンバイ・ペアをダウンロードするには、解決されnexthopsは、2つの最高のプリファレンスが選択されています。各<NEXTHOP_PREFERENCE> <ネクスト・保護>内で一意の値を持つべきである（第6節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o NEXTHOP_LB_WEIGHT: This is used for load-balancing. Each list member MUST be assigned a weight between 1 and 99. The weight determines the proportion of traffic to be sent over a nexthop used for forwarding as a ratio of the weight of this nexthop divided by the weights of all the nexthops of this route that are used for forwarding. To perform equal load-balancing, one MAY specify a weight of \"0\" for all the member nexthops. The value \"0\" is reserved for equal load-balancing and, if applied, MUST be applied to all member nexthops. Note that a weight of 0 is special because of historical reasons.",
      "ja": "NEXTHOP_LB_WEIGHT O：これは、負荷分散のために使用されています。各リスト部材は、1と99との間に重みを割り当てなければならない量は、トラフィックの割合は、この経路の全てnexthopsの重みで割っこのネクストホップの重量の比として転送するために使用されるネクストホップを介して送信されることを決定すること転送に使用されています。均等負荷分散を実行するためには、すべてのメンバーnexthopsのために「0」の重みを指定するかもしれません。値「0」は、すべてのメンバnexthopsに適用する必要があり、適用された場合、同じロードバランシングのために予約されています。 0の重量があるため、歴史的な理由で特別であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Nexthop Indirection",
      "section_title": true,
      "ja": "2.4.3. ネクストホップ間接"
    },
    {
      "indent": 3,
      "text": "Nexthops can be identified by an identifier to create a level of indirection. The identifier is set by the RIB manager and returned to the RIB client on request.",
      "ja": "Nexthopsは、間接のレベルを作成するために、識別子によって識別することができます。識別子は、RIB管理者が設定し、リクエストに応じてRIBクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "One example of usage of indirection is a nexthop that points to another network device (e.g., a BGP peer). The returned nexthop identifier can then be used for programming routes to point to the this nexthop. Given that the RIB manager has created an indirection using the nexthop identifier, if the transport path to the network device (BGP peer) changes, that change in path will be seamless to the RIB client and all routes that point to that network device will automatically start going over the new transport path. Nexthop indirection using identifiers could be applied to not only unicast nexthops but also nexthops that contain chains and nested nexthops. See Section 2.4.2 for examples.",
      "ja": "間接の使用の一例は、他のネットワーク装置（例えば、BGPピア）を指すネクストホップです。返されたネクストホップ識別子は、このネクストホップを指すようにプログラミング経路のために使用することができます。 RIBマネージャがネクストホップ識別子を使用して、インダイレクションを作成したことを考えると、ネットワークデバイス（BGPピア）変化へ搬送経路場合、自動的に経路におけるその変化はRIBクライアントにシームレスになり、そのネットワークデバイスを指すすべてのルートは、意志新しい搬送経路上に行くを開始。識別子を使用してネクストホップの間接は、ユニキャストnexthopsだけでなく、チェーンとネストnexthopsを含まnexthopsないだけに適用することができます。例については、2.4.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Reading from the RIB",
      "section_title": true,
      "ja": "3. RIBからの読み込み"
    },
    {
      "indent": 3,
      "text": "A RIB data model MUST allow a RIB client to read entries for RIBs created by that entity. The network device administrator MAY allow reading of other RIBs by a RIB client through access lists on the network device. The details of access lists are outside the scope of this document.",
      "ja": "RIBデータモデルは、RIBクライアントはそのエンティティによって作成されたのRIBのエントリを読むことを許容しなければなりません。ネットワークデバイスの管理者は、ネットワークデバイス上のアクセスリストを通じてRIBクライアントによって他のリブの読み取りを可能にすることができます。アクセスリストの詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "The data model MUST support a full read of the RIB and subsequent incremental reads of changes to the RIB. When sending data to a RIB client, the RIB manager SHOULD try to send all dependencies of an object prior to sending that object.",
      "ja": "データモデルは、RIBの完全な読み取りをサポートしなければならないし、後続の増分はRIBへの変更を読み込みます。 RIBクライアントにデータを送信する場合、RIBマネージャは、その前のオブジェクトを送信するオブジェクトのすべての依存関係を送信しようとする必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Writing to the RIB",
      "section_title": true,
      "ja": "RIB 4.書き込み"
    },
    {
      "indent": 3,
      "text": "A RIB data model MUST allow a RIB client to write entries for RIBs created by that entity. The network device administrator MAY allow writes to other RIBs by a RIB client through access lists on the network device. The details of access lists are outside the scope of this document.",
      "ja": "RIBデータモデルは、RIBクライアントはそのエンティティによって作成されたのRIBのエントリを書くことができるようにしなければなりません。管理者が許可するかもしれないネットワークデバイスは、ネットワークデバイス上のアクセスリストを通じてRIBクライアントによって他のRIBに書き込みます。アクセスリストの詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "When writing an object to a RIB, the RIB client SHOULD try to write all dependencies of the object prior to sending that object. The data model SHOULD support requesting identifiers for nexthops and collecting the identifiers back in the response.",
      "ja": "RIBにオブジェクトを書き込むとき、RIBクライアントは、その前のオブジェクトを送信するオブジェクトのすべての依存関係を記述してみてください。データモデルはnexthopsの識別子を要求し、それに応答して、識別子をバック収集をサポートすべきです。"
    },
    {
      "indent": 3,
      "text": "Route programming in the RIB MUST result in a return code that contains the following attributes:",
      "ja": "RIBでのルートプログラミングは次の属性が含まれているリターンコードをもたらさなければなりません："
    },
    {
      "indent": 3,
      "text": "o Installed: Yes/No (indicates whether the route got installed in the FIB)",
      "ja": "Oインストール済み：はい/いいえ（ルートがFIBにインストールされてしまったかどうかを示します）"
    },
    {
      "indent": 3,
      "text": "o Active: Yes/No (indicates whether a route is fully resolved and is a candidate for selection)",
      "ja": "Oアクティブ：はい/いいえ（ルートが完全に解決されているかどうかを示し、選択のための候補です）"
    },
    {
      "indent": 3,
      "text": "o Reason: E.g., \"Not authorized\"",
      "ja": "O理由：例えば、「認証されていません」"
    },
    {
      "indent": 3,
      "text": "The data model MUST specify which objects can be modified. An object that can be modified is one whose contents can be changed without having to change objects that depend on it and without affecting any data forwarding. To change a non-modifiable object, one will need to create a new object and delete the old one. For example, routes that use a nexthop that is identified by a nexthop identifier should be unaffected when the contents of that nexthop changes.",
      "ja": "データモデルは、オブジェクトを変更できるかを指定しなければなりません。修正することができるオブジェクトは、その内容をその上に任意のデータ転送に影響を与えずに依存するオブジェクトを変更することなく変更することができるものです。非修正のオブジェクトを変更するためには、新しいオブジェクトを作成し、古いものを削除する必要があります。たとえば、ネクストホップ識別子によって識別されるネクストホップを使用するルートは影響を受けなければならない場合、そのネクストホップの内容が変更。"
    },
    {
      "indent": 0,
      "text": "5. Notifications",
      "section_title": true,
      "ja": "5.通知"
    },
    {
      "indent": 3,
      "text": "Asynchronous notifications are sent by the network device's RIB manager to a RIB client when some event occurs on the network device. A RIB data model MUST support sending asynchronous notifications. A brief list of suggested notifications is as below:",
      "ja": "一部のイベントは、ネットワークデバイス上で発生したときに非同期通知はRIBクライアントにネットワークデバイスのRIBマネージャによって送信されます。 RIBデータモデルは、非同期通知の送信をサポートしなければなりません。提案された通知の簡単なリストは以下の通りです："
    },
    {
      "indent": 3,
      "text": "o Route change notification (with a return code as specified in Section 4)",
      "ja": "（セクション4で指定されるように戻りコードを伴う）O経路変更通知"
    },
    {
      "indent": 3,
      "text": "o Nexthop resolution status (resolved/unresolved) notification",
      "ja": "Oネクストホップ解決状態（分解/未解決）通知"
    },
    {
      "indent": 0,
      "text": "6. RIB Grammar",
      "section_title": true,
      "ja": "6. RIBの文法"
    },
    {
      "indent": 3,
      "text": "This section specifies the RIB information model in Routing Backus-Naur Form (rBNF) [RFC5511]. This grammar is intended to help the reader better understand Section 2 in order to derive a data model.",
      "ja": "このセクションでは、[RFC5511]ルーティングバッカスナウア記法（rBNF）でRIB情報モデルを特定します。この文法は、読者がより良いデータモデルを導出するために、第2節を理解するためのものです。"
    },
    {
      "indent": 1,
      "text": "<routing-instance> ::= <INSTANCE_NAME>\n                       [<interface-list>] <rib-list>\n                       [<ROUTER_ID>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<interface-list> ::= (<INTERFACE_IDENTIFIER> ...)",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<rib-list> ::= (<rib> ...)\n<rib> ::= <rib-name> <address-family>\n                    [<route> ... ]\n                    [ENABLE_IP_RPF_CHECK]\n<address-family> ::= <IPV4_ADDRESS_FAMILY> | <IPV6_ADDRESS_FAMILY> |\n                     <MPLS_ADDRESS_FAMILY> | <IEEE_MAC_ADDRESS_FAMILY>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<route> ::= <match> <nexthop>\n            [<route-attributes>]\n            [<route-vendor-attributes>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<match> ::= <IPV4> <ipv4-route> | <IPV6> <ipv6-route> |\n            <MPLS> <MPLS_LABEL> | <IEEE_MAC> <MAC_ADDRESS> |\n            <INTERFACE> <INTERFACE_IDENTIFIER>\n<route-type> ::= <IPV4> | <IPV6> | <MPLS> | <IEEE_MAC> | <INTERFACE>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<ipv4-route> ::= <ip-route-type>\n                 (<destination-ipv4-address> | <source-ipv4-address> |\n                  (<destination-ipv4-address> <source-ipv4-address>))\n<destination-ipv4-address> ::= <ipv4-prefix>\n<source-ipv4-address> ::= <ipv4-prefix>\n<ipv4-prefix> ::= <IPV4_ADDRESS> <IPV4_PREFIX_LENGTH>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<ipv6-route> ::= <ip-route-type>\n                 (<destination-ipv6-address> | <source-ipv6-address> |\n                  (<destination-ipv6-address> <source-ipv6-address>))\n<destination-ipv6-address> ::= <ipv6-prefix>\n<source-ipv6-address> ::= <ipv6-prefix>\n<ipv6-prefix> ::= <IPV6_ADDRESS> <IPV6_PREFIX_LENGTH>\n<ip-route-type> ::= <SRC> | <DEST> | <DEST_SRC>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<route-attributes> ::= <ROUTE_PREFERENCE> [<LOCAL_ONLY>]\n                       [<address-family-route-attributes>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<address-family-route-attributes> ::= <ip-route-attributes> |\n                                      <mpls-route-attributes> |\n                                      <ethernet-route-attributes>\n<ip-route-attributes> ::= <>\n<mpls-route-attributes> ::= <>\n<ethernet-route-attributes> ::= <>\n<route-vendor-attributes> ::= <>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop> ::= <nexthop-base> |\n              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>) |\n              (<NEXTHOP_PROTECTION> <nexthop-protection>) |\n              (<NEXTHOP_REPLICATE> <nexthop-replicate>) |\n              <nexthop-chain>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop-base> ::= <NEXTHOP_ID> |\n                   <nexthop-special> |\n                   <egress-interface> |\n                   <ipv4-address> | <ipv6-address> |\n                   (<egress-interface>\n                       (<ipv4-address> | <ipv6-address>)) |\n                   (<egress-interface> <IEEE_MAC_ADDRESS>) |\n                   <tunnel-encapsulation> | <tunnel-decapsulation> |\n                   <logical-tunnel> |\n                   <rib-name>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<egress-interface> ::= <INTERFACE_IDENTIFIER>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop-special> ::= <DISCARD> | <DISCARD_WITH_ERROR> |\n                      (<RECEIVE> [<COS_VALUE>])",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop-lb> ::= <NEXTHOP_LB_WEIGHT> <nexthop>\n                 (<NEXTHOP_LB_WEIGHT> <nexthop) ...",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop-protection> = <NEXTHOP_PREFERENCE> <nexthop> (<NEXTHOP_PREFERENCE> <nexthop>)...",
      "ja": "<ネクスト・保護> = <NEXTHOP_PREFERENCE> <ネクストホップ>（<NEXTHOP_PREFERENCE> <ネクストホップ>）..."
    },
    {
      "indent": 1,
      "text": "<nexthop-replicate> ::= <nexthop> <nexthop> ...",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<nexthop-chain> ::= <nexthop> ...",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<logical-tunnel> ::= <tunnel-type> <TUNNEL_NAME>\n<tunnel-type> ::= <IPV4> | <IPV6> | <MPLS> | <GRE> | <VxLAN> | <NVGRE>",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<tunnel-encapsulation> ::= (<IPV4> <ipv4-header>) |\n                           (<IPV6> <ipv6-header>) |\n                           (<MPLS> <mpls-header>) |\n                           (<GRE> <gre-header>) |\n                           (<VXLAN> <vxlan-header>) |\n                           (<NVGRE> <nvgre-header>)",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<ipv4-header> ::= <SOURCE_IPv4_ADDRESS> <DESTINATION_IPv4_ADDRESS>\n                  <PROTOCOL> [<TTL>] [<DSCP>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<ipv6-header> ::= <SOURCE_IPV6_ADDRESS> <DESTINATION_IPV6_ADDRESS>\n                  <NEXT_HEADER> [<TRAFFIC_CLASS>]\n                  [<FLOW_LABEL>] [<HOP_LIMIT>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<mpls-header> ::= (<mpls-label-operation> ...)\n<mpls-label-operation> ::= (<MPLS_PUSH> <MPLS_LABEL> [<S_BIT>]\n                                        [<TOS_VALUE>] [<TTL_VALUE>]) |\n                           (<MPLS_SWAP> <IN_LABEL> <OUT_LABEL>\n                                       [<TTL_ACTION>])",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<gre-header> ::= <GRE_IP_DESTINATION> <GRE_PROTOCOL_TYPE> [<GRE_KEY>]\n<vxlan-header> ::= (<ipv4-header> | <ipv6-header>)\n                   [<VXLAN_IDENTIFIER>]\n<nvgre-header> ::= (<ipv4-header> | <ipv6-header>)\n                   <VIRTUAL_SUBNET_ID>\n                   [<FLOW_ID>]",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<tunnel-decapsulation> ::= ((<IPV4> <IPV4_DECAP> [<TTL_ACTION>]) |\n                           (<IPV6> <IPV6_DECAP> [<HOP_LIMIT_ACTION>]) |\n                           (<MPLS> <MPLS_POP> [<TTL_ACTION>]))",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 5: RIB rBNF Grammar",
      "ja": "図5：RIB rBNF文法"
    },
    {
      "indent": 0,
      "text": "6.1. Nexthop Grammar Explained",
      "section_title": true,
      "ja": "6.1. ネクスト文法を説明しました"
    },
    {
      "indent": 3,
      "text": "A nexthop is used to specify the next network element to forward the traffic to. It is also used to specify how the traffic should be load-balanced, protected using preference, or multicast using replication. This is explicitly specified in the grammar. The nexthop has recursion built in to address complex use cases like the one defined in Section 7.2.6.",
      "ja": "ネクストホップはにトラフィックを転送するために、次のネットワーク要素を指定するために使用されます。また、トラフィックが負荷分散され、レプリケーションを使用して好み、またはマルチキャストを使用して保護する方法を指定するために使用されます。これは、明示的文法で指定されています。ネクストホップは、セクション7.2.6で定義されたような複雑なユースケースに対処するために内蔵再帰を持っています。"
    },
    {
      "indent": 0,
      "text": "7. Using the RIB Grammar",
      "section_title": true,
      "ja": "7. RIBの文法を使用して"
    },
    {
      "indent": 3,
      "text": "The RIB grammar is very generic and covers a variety of features. This section provides examples on using objects in the RIB grammar and examples to program certain use cases.",
      "ja": "RIB文法は非常に一般的で、さまざまな機能をカバーしています。このセクションでは、特定のユースケースをプログラムするRIB文法内のオブジェクトおよび例の使用例を提供します。"
    },
    {
      "indent": 0,
      "text": "7.1. Using Route Preference",
      "section_title": true,
      "ja": "7.1. ルートプリファレンスを使用して"
    },
    {
      "indent": 3,
      "text": "Using route preference, a client can preinstall alternate paths in the network. For example, if OSPF has a route preference of 10, then another client can install a route with a route preference of 20 to the same destination. The OSPF route will get precedence and will get installed in the FIB. When the OSPF route is withdrawn, the alternate path will get installed in the FIB.",
      "ja": "ルートプリファレンスを使用して、クライアントは、ネットワーク内の代替パスをプレインストールすることができます。 OSPFは、10の経路優先度を有する場合、例えば、別のクライアントが同じ宛先への20の経路優先のルートをインストールすることができます。 OSPFルートが優先されますし、FIBにインストールされます。 OSPF経路が引き抜かれるときに、代替パスは、FIBにインストールされます。"
    },
    {
      "indent": 3,
      "text": "Route preference can also be used to prevent denial-of-service attacks by installing routes with the best preference, which either drops the offending traffic or routes it to some monitoring/analysis station. Since the routes are installed with the best preference, they will supersede any route installed by any other protocol.",
      "ja": "ルート設定はまた、いずれかの問題のトラフィックまたはいくつかの監視/分析ステーションへのルートを低下最良優先でルートをインストールすることにより、サービス拒否攻撃を防止するために使用することができます。ルートが最良優先して設置されているので、他のプロトコルによってインストールされたルートに取って代わるであろう。"
    },
    {
      "indent": 0,
      "text": "7.2. Using Different Nexthop Types",
      "section_title": true,
      "ja": "7.2. 別のネクストホップ型の使用"
    },
    {
      "indent": 3,
      "text": "The RIB grammar allows one to create a variety of nexthops. This section describes uses for certain types of nexthops.",
      "ja": "RIB文法は1つがnexthopsの様々なを作成することができます。このセクションでは、nexthops、特定の種類の用途を説明しています。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Tunnel Nexthops",
      "section_title": true,
      "ja": "7.2.1. トンネルNexthops"
    },
    {
      "indent": 3,
      "text": "A tunnel nexthop points to a tunnel of some kind. Traffic that goes over the tunnel gets encapsulated with the tunnel-encapsulation. Tunnel nexthops are useful for abstracting out details of the network by having the traffic seamlessly route between network edges. At the end of a tunnel, the tunnel will get decapsulated. Thus, the grammar supports two kinds of operations: one for encapsulation and another for decapsulation.",
      "ja": "トンネルは、いくつかの種類のトンネルにポイントをネクストホップ。トンネル経由で行くトラフィックは、トンネルカプセル化でカプセル化されます。トンネルnexthopsトラフィックネットワークエッジ間のシームレスな経路を有することによって、ネットワークの詳細を抽象化するのに有用です。トンネルの終わりには、トンネルがカプセル化が解除されます。カプセル化解除のためのカプセル化用と別：したがって、文法は、オペレーションの2種類をサポートしています。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Replication Lists",
      "section_title": true,
      "ja": "7.2.2. レプリケーションリスト"
    },
    {
      "indent": 3,
      "text": "One can create a replication list for replicating traffic to multiple destinations. The destinations, in turn, could be derived nexthops in themselves (at a level supported by the network device); point to multipoint and broadcast are examples that involve replication.",
      "ja": "一つは、複数の宛先へのトラフィックを複製するレプリケーション一覧を作成することができます。宛先は、順番に、（ネットワークデバイスによってサポートされるレベルで）それ自体nexthopsを誘導することができました。ポイントツーマルチポイントとブロードキャストは、レプリケーションを伴う例です。"
    },
    {
      "indent": 3,
      "text": "A replication list (at the simplest level) can be represented as:",
      "ja": "（最も単純なレベルで）複製リストとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> [ <nexthop> ... ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "次のように上記の文法から誘導することができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <nexthop-replicate>\n<nexthop> ::= <NEXTHOP_REPLICATE> <nexthop> <nexthop> ...",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.3. Weighted Lists",
      "section_title": true,
      "ja": "7.2.3. 加重リスト"
    },
    {
      "indent": 3,
      "text": "A weighted list is used to load-balance traffic among a set of nexthops. From a modeling perspective, a weighted list is very similar to a replication list, with the difference that each member nexthop MUST have a NEXTHOP_LB_WEIGHT associated with it.",
      "ja": "加重リストはnexthopsのセット間で負荷バランストラフィックに使用されています。モデリングの観点から、重み付けされたリストには、各メンバーのネクストホップは、それに関連付けられたNEXTHOP_LB_WEIGHTを持たなければならない違いで、レプリケーション一覧に非常によく似ています。"
    },
    {
      "indent": 3,
      "text": "A weighted list (at the simplest level) can be represented as:",
      "ja": "（最も単純なレベルで）重み付きリストとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<nexthop> <NEXTHOP_LB_WEIGHT>)\n                   [(<nexthop> <NEXTHOP_LB_WEIGHT>)... ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "次のように上記の文法から誘導することができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <nexthop-lb>\n<nexthop> ::= <NEXTHOP_LOAD_BALANCE>\n                <NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...\n<nexthop> ::= <NEXTHOP_LOAD_BALANCE> (<NEXTHOP_LB_WEIGHT> <nexthop>)\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.4. Protection",
      "section_title": true,
      "ja": "7.2.4. 保護"
    },
    {
      "indent": 3,
      "text": "A primary/backup protection can be represented as:",
      "ja": "プライマリー/バックアップ保護は、次のように表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> <1> <interface-primary>\n                                   <2> <interface-backup>)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "次のように上記の文法から誘導することができます。"
    },
    {
      "indent": 0,
      "text": "<nexthop> ::= <nexthop-protection>\n<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n                      (<NEXTHOP_PREFERENCE> <nexthop>)...)\n<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n                      (<NEXTHOP_PREFERENCE> <nexthop>))\n<nexthop> ::= <NEXTHOP_PROTECTION> ((<NEXTHOP_PREFERENCE> <nexthop-base>\n                      (<NEXTHOP_PREFERENCE> <nexthop-base>))\n<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <interface-primary>\n                      (<2> <interface-backup>))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Traffic can be load-balanced among multiple primary nexthops and a single backup. In such a case, the nexthop will look like:",
      "ja": "トラフィックは、複数の一次nexthopsと単一のバックアップ間で負荷のバランスをとることができます。そのような場合には、ネクストホップは、次のようになります。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> (<1>\n              (<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop-base>\n               (<NEXTHOP_LB_WEIGHT> <nexthop-base>) ...))\n                <2> <nexthop-base>)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A backup can also have another backup. In such a case, the list will look like:",
      "ja": "バックアップは、別のバックアップを持っていることができます。そのような場合には、リストは次のようになります。"
    },
    {
      "indent": 3,
      "text": "<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <nexthop>\n              <2> <NEXTHOP_PROTECTION>(<1> <nexthop> <2> <nexthop>))",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.5. Nexthop Chains",
      "section_title": true,
      "ja": "7.2.5. ネクストホップチェーン"
    },
    {
      "indent": 3,
      "text": "A nexthop chain is a way to perform multiple operations on a packet by logically combining them. For example, when a VPN packet comes on the WAN interface and has to be forwarded to the correct VPN interface, one needs to pop the VPN label before sending the packet out. Using a nexthop chain, one can chain together \"pop MPLS header\" and \"send it out a specific egress-interface\".",
      "ja": "ネクストホップチェーンは、論理的にそれらを組み合わせることで、パケットに複数の操作を実行するための方法です。 VPNパケットがWANインターフェイスに来て、正しいVPNインターフェイスに転送する必要がある場合たとえば、1が出てパケットを送信する前にVPNラベルをポップする必要があります。ネクスト・チェーンを使用して、一緒に1缶鎖「ポップMPLSヘッダ」とは、「特定のイグレスインタフェースをそれを送ります」。"
    },
    {
      "indent": 3,
      "text": "The above example can be derived from the grammar as follows:",
      "ja": "次のように上記の例では、文法から誘導することができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= <nexthop> <nexthop>\n<nexthop-chain> ::= <nexthop-base> <nexthop-base>\n<nexthop-chain> ::= <tunnel-decapsulation> <egress-interface>\n<nexthop-chain> ::= (<MPLS> <MPLS_POP>) <interface-outgoing>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Elements in a nexthop chain are evaluated left to right.",
      "ja": "ネクストホップチェーン内の要素は左から右に評価されています。"
    },
    {
      "indent": 3,
      "text": "A nexthop chain can also be used to put one or more headers on an outgoing packet. One example is a pseudowire, which is MPLS over some transport (MPLS or GRE, for instance). Another example is Virtual eXtensible Local Area Network (VXLAN) over IP. A nexthop chain thus allows a RIB client to break up the programming of the nexthop into independent pieces (one per encapsulation).",
      "ja": "ネクストホップチェーンはまた、発信パケットに1枚の以上のヘッダを置くために使用することができます。一例では、（例えば、MPLSまたはGRE）は、いくつかのトランスポート上でMPLS擬似回線、です。別の例は、IP上の仮想拡張可能ローカルエリアネットワーク（VXLAN）です。ネクストホップチェーンは、このようにRIBクライアントは、独立した作品（カプセルあたり1）へのネクストホップのプログラミングを壊すことができます。"
    },
    {
      "indent": 3,
      "text": "A simple example of MPLS over GRE can be represented as follows:",
      "ja": "次のようにGRE上MPLSの簡単な例を表すことができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)\n                    <interface-outgoing>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above can be derived from the grammar as follows:",
      "ja": "次のように上記の文法から誘導することができます。"
    },
    {
      "indent": 3,
      "text": "<nexthop-chain> ::= <nexthop> <nexthop> <nexthop>\n<nexthop-chain> ::= <nexthop-base> <nexthop-base> <nexthop-base>\n<nexthop-chain> ::= <tunnel-encapsulation> <tunnel-encapsulation>\n                    <egress-interface>\n<nexthop-chain> ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)\n                    <interface-outgoing>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.6. Lists of Lists",
      "section_title": true,
      "ja": "7.2.6. リストのリスト"
    },
    {
      "indent": 3,
      "text": "Lists of lists is a derived construct. One example of usage of such a construct is to replicate traffic to multiple destinations with load-balancing. In other words, for each branch of the replication tree, there are multiple interfaces on which traffic needs to be load-balanced. So, the outer list is a replication list for multicast and the inner lists are weighted lists for load-balancing. Let's take an example of a network element that has to replicate traffic to two other network elements. Traffic to the first network element should be load-balanced equally over two interfaces: outgoing-1-1 and outgoing-1-2. Traffic to the second network element should be load-balanced over three interfaces: outgoing-2-1, outgoing-2-2, and outgoing-2-3 (in the ratio 20:20:60).",
      "ja": "リストのリストは派生構造です。このような構築の使用方法の一例は、負荷分散と複数の宛先へのトラフィックを複製することです。換言すれば、レプリケーションツリーの各ブランチのために、トラフィック負荷分散する必要があるれている複数のインターフェイスがあります。だから、外側のリストは、ロードバランシングのためのマルチキャストと内側のリストは重み付けされているリストのレプリケーション一覧です。他の2つのネットワーク要素へのトラフィックを複製しなければならないネットワーク要素の例を見てみましょう。発信-1-1および発信-1-2：第1のネットワーク要素へのトラフィックが均等に二つのインタフェース上の負荷バランスがなければなりません。 （比20:20:60で）発信-2-1、出射2-2、および発信-2-3：第2のネットワーク要素へのトラフィック負荷バランス3つのインターフェイス上であるべきです。"
    },
    {
      "indent": 3,
      "text": "This can be derived from the grammar as follows:",
      "ja": "これは次のように文法から派生することができます。"
    },
    {
      "indent": 0,
      "text": "<nexthop> ::= <nexthop-replicate>\n<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>...)\n<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>)\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE> <nexthop-lb>)\n              (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n               ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n                ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>)\n                (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n               ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n<nexthop> ::= <NEXTHOP_REPLICATE>\n               ((<NEXTHOP_LOAD_BALANCE>\n                 (50 <outgoing-1-1>)\n                 (50 <outgoing-1-2>)))\n                ((<NEXTHOP_LOAD_BALANCE>\n                  (20 <outgoing-2-1>)\n                  (20 <outgoing-2-2>)\n                  (60 <outgoing-2-3>)))",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. Performing Multicast",
      "section_title": true,
      "ja": "7.3. マルチキャストを実行します"
    },
    {
      "indent": 3,
      "text": "IP multicast involves matching a packet on (S,G) or (*,G), where both S (Source) and G (Group) are IP prefixes. Following the match, the packet is replicated to one or more recipients. How the recipients subscribe to the multicast group is outside the scope of this document.",
      "ja": "IPマルチキャストは、S（ソース）とG（グループ）の両方がIPプレフィックスである（S、G）または（*、G）にパケットをマッチングすることを含みます。試合後、パケットは、1つまたは複数の受信者に複製されます。受信者がマルチキャストグループに加入する方法このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "In PIM-based multicast, the packets are IP forwarded on an IP multicast tree. The downstream nodes on each point in the multicast tree are one or more IP addresses. These can be represented as a replication list (see Section 7.2.2).",
      "ja": "PIMベースのマルチキャストでは、パケットがIP IPマルチキャストツリー上で転送されます。マルチキャストツリー内の各点における下流のノードは、1つ以上のIPアドレスです。これらは、（7.2.2項を参照）、複製リストとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "In MPLS-based multicast, the packets are forwarded on a Point-to-Multipoint (P2MP) LSP. The nexthop for a P2MP LSP can be represented in the nexthop grammar as a <logical-tunnel> (P2MP LSP identifier) or a replication list (see Section 7.2.2) of <tunnel-encapsulation>, with each tunnel-encapsulation representing a single MPLS downstream nexthop.",
      "ja": "MPLSベースのマルチキャストでは、パケットは、ポイントツーマルチポイント（P2MP）LSPに転送されます。 P2MP LSPのためのネクストホップを表す各トンネルカプセル化、<トンネルカプセル化>の<論理トンネル>（P2MP LSP識別子）または複製リスト（セクション7.2.2を参照）のようなネクストホップ文法で表現することができます単一MPLS下流ネクストホップ。"
    },
    {
      "indent": 0,
      "text": "8. RIB Operations at Scale",
      "section_title": true,
      "ja": "スケールで8 RIB操作"
    },
    {
      "indent": 3,
      "text": "This section discusses the scale requirements for a RIB data model. The RIB data model should be able to handle a large scale of operations to enable deployment of RIB applications in large networks.",
      "ja": "このセクションでは、RIBデータモデルのスケールの要件について説明します。 RIBデータモデルは、大規模ネットワークでのRIBアプリケーションの展開を可能にするための操作の大規模を扱うことができるはずです。"
    },
    {
      "indent": 0,
      "text": "8.1. RIB Reads",
      "section_title": true,
      "ja": "8.1.  RIB読み込み"
    },
    {
      "indent": 3,
      "text": "Bulking (grouping of multiple objects in a single message) MUST be supported when a network device sends RIB data to a RIB client. Similarly, the data model MUST enable a RIB client to request data in bulk from a network device.",
      "ja": "ネットワークデバイスは、RIBクライアントにRIBデータを送信するときに増量（単一メッセージ内の複数のオブジェクトのグループ化）をサポートしなければなりません。同様に、データモデルは、ネットワーク装置から一括してデータを要求するRIBクライアントを有効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. RIB Writes",
      "section_title": true,
      "ja": "8.2.  RIBは、書き込み"
    },
    {
      "indent": 3,
      "text": "Bulking (grouping of multiple write operations in a single message) MUST be supported when a RIB client wants to write to the RIB. The response from the network device MUST include a return-code for each write operation in the bulk message.",
      "ja": "RIBクライアントがRIBに書き込みたい場合に増量（単一のメッセージで複数の書き込み操作のグループ化）がサポートしなければなりません。ネットワークデバイスからの応答は、バルクメッセージの各書き込み動作の戻りコードを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3. RIB Events and Notifications",
      "section_title": true,
      "ja": "8.3.  RIBイベントと通知"
    },
    {
      "indent": 3,
      "text": "There can be cases where a single network event results in multiple events and/or notifications from the network device to a RIB client. On the other hand, due to timing of multiple things happening at the same time, a network device might have to send multiple events and/or notifications to a RIB client. The network-device-originated event/ notification message MUST support the bulking of multiple events and notifications in a single message.",
      "ja": "複数のイベントおよび/またはRIBクライアントへのネットワークデバイスからの通知では、単一のネットワークイベントの結果例が存在する場合があります。一方、原因が同時に起こって、複数の物事のタイミングに、ネットワークデバイスは、RIBクライアントに複数のイベントおよび/または通知を送信する必要がある場合があります。ネットワークデバイス発イベント/通知メッセージは単一のメッセージに複数のイベントおよび通知の増量がサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The information model specified in this document defines a schema for data models that are designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040]. The lowest NETCONF layer is the secure transport layer, and the mandatory-to-implement secure transport is Secure Shell (SSH) [RFC6242]. The lowest RESTCONF layer is HTTPS, and the mandatory-to-implement secure transport is TLS [RFC8446].",
      "ja": "この文書で指定された情報モデルは、NETCONF [RFC6241]またはRESTCONF [RFC8040]などのネットワーク管理プロトコルを介してアクセスされるように設計されたデータモデルのスキーマを定義します。最低NETCONF層は、セキュアトランスポート層であり、強制的に実装安全な輸送は、セキュアシェル（SSH）[RFC6242]です。最低RESTCONF層はHTTPSであり、強制的に実装安全な輸送は、TLS [RFC8446]です。"
    },
    {
      "indent": 3,
      "text": "The NETCONF access control model [RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.",
      "ja": "NETCONFアクセス制御モデル[RFC8341]は、すべての利用可能なNETCONF又はRESTCONFプロトコル操作とコンテンツの事前設定されたサブセットに特定のNETCONF又はRESTCONFユーザーのアクセスを制限するための手段を提供します。"
    },
    {
      "indent": 3,
      "text": "The RIB information model specifies read and write operations to network devices. These network devices might be considered sensitive or vulnerable in some network environments. Write operations to these network devices without proper protection can have a negative effect on network operations. Due to this factor, it is recommended that data models also consider the following in their design:",
      "ja": "RIB情報モデルを読み込み、ネットワークデバイスへの書き込み操作を指定します。これらのネットワークデバイスは、いくつかのネットワーク環境で敏感であるか、または脆弱考えられるかもしれません。適切な保護のないこれらのネットワークデバイスへの書き込み操作はネットワーク操作のときにマイナスの影響を持つことができます。この要因のために、データモデルはまた、彼らのデザインに次の点を考慮することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Require utilization of the authentication and authorization features of the NETCONF or RESTCONF suite of protocols.",
      "ja": "OプロトコルのNETCONFまたはRESTCONFスイートの認証および承認機能の利用を必要とします。"
    },
    {
      "indent": 3,
      "text": "o Augment the limits on how much data can be written or updated by a remote entity built to include enough protection for a RIB data model.",
      "ja": "O RIBデータモデルのための十分な保護を含めるように構築されたリモートエンティティによって書かれた、または更新することができますどのくらいのデータの制限を強化します。"
    },
    {
      "indent": 3,
      "text": "o Expose the specific RIB data model implemented via NETCONF/ RESTCONF data models.",
      "ja": "O NETCONF / RESTCONFデータモデルを介して実装特定RIBデータモデルを公開。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントには、IANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <https://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 \"ネットワーク構成プロトコル（NETCONF）\"、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<https://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC6242] Wasserman, M., \"Using the NETCONF Protocol over Secure Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011, <https://www.rfc-editor.org/info/rfc6242>.",
      "ja": "[RFC6242]ワッサーマン、M.、RFC 6242、DOI 10.17487 / RFC6242、2011年6月、 \"NETCONFプロトコルを使用してセキュアシェル（SSH）上\" <https://www.rfc-editor.org/info/rfc6242>。"
    },
    {
      "indent": 3,
      "text": "[RFC8040] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017, <https://www.rfc-editor.org/info/rfc8040>.",
      "ja": "[RFC8040] Bierman、A. Bjorklund、M.、およびK. Watsen、 \"RESTCONFプロトコル\"、RFC 8040、DOI 10.17487 / RFC8040、2017年1月、<https://www.rfc-editor.org/info/rfc8040 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8341] Bierman, A. and M. Bjorklund, \"Network Configuration Access Control Model\", STD 91, RFC 8341, DOI 10.17487/RFC8341, March 2018, <https://www.rfc-editor.org/info/rfc8341>.",
      "ja": "[RFC8341] Bierman、A.とM. Bjorklund、 \"ネットワーク設定のアクセス制御モデル\"、STD 91、RFC 8341、DOI 10.17487 / RFC8341、2018年3月、<https://www.rfc-editor.org/info/rfc8341 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446]レスコラ、E.、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.3\"、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC4915] Psenak, P., Mirtorabi, S., Roy, A., Nguyen, L., and P. Pillay-Esnault, \"Multi-Topology (MT) Routing in OSPF\", RFC 4915, DOI 10.17487/RFC4915, June 2007, <https://www.rfc-editor.org/info/rfc4915>.",
      "ja": "[RFC4915] Psenak、P.、Mirtorabi、S.、ロイ、A.、グエン、L.、およびP. Pillay-Esnault、 \"OSPFにおけるマルチトポロジー（MT）ルーティング\"、RFC 4915、DOI 10.17487 / RFC4915、 2007年6月、<https://www.rfc-editor.org/info/rfc4915>。"
    },
    {
      "indent": 3,
      "text": "[RFC5120] Przygienda, T., Shen, N., and N. Sheth, \"M-ISIS: Multi Topology (MT) Routing in Intermediate System to Intermediate Systems (IS-ISs)\", RFC 5120, DOI 10.17487/RFC5120, February 2008, <https://www.rfc-editor.org/info/rfc5120>.",
      "ja": "[RFC5120] Przygienda、T.、シェン、N.、およびN. Sheth、 \"M-ISIS：中間システムへの中間システムにおけるマルチトポロジー（MT）ルーティング（IS-ISS）\"、RFC 5120、DOI 10.17487 / RFC5120、 2008年2月、<https://www.rfc-editor.org/info/rfc5120>。"
    },
    {
      "indent": 3,
      "text": "[RFC5511] Farrel, A., \"Routing Backus-Naur Form (RBNF): A Syntax Used to Form Encoding Rules in Various Routing Protocol Specifications\", RFC 5511, DOI 10.17487/RFC5511, April 2009, <https://www.rfc-editor.org/info/rfc5511>.",
      "ja": "[RFC5511]ファレル、A.、 \"ルーティングバッカス記法（RBNF）：さまざまなルーティングプロトコル仕様に符号化規則を形成するのに使用される構文\"、RFC 5511、DOI 10.17487 / RFC5511、2009年4月、<https：//でWWW。 rfc-editor.org/info/rfc5511>。"
    },
    {
      "indent": 3,
      "text": "[RFC7920] Atlas, A., Ed., Nadeau, T., Ed., and D. Ward, \"Problem Statement for the Interface to the Routing System\", RFC 7920, DOI 10.17487/RFC7920, June 2016, <https://www.rfc-editor.org/info/rfc7920>.",
      "ja": "[RFC7920]アトラス、A.、エド、ナドー、T.、エド、およびD.区、 \"ルーティングシステムへのインタフェースのための問題文\"、RFC 7920、DOI 10.17487 / RFC7920、2016年6月、<httpsを。。： //www.rfc-editor.org/info/rfc7920>。"
    },
    {
      "indent": 3,
      "text": "[RFC8431] Wang, L., Chen, M., Dass, A., Ananthakrishnan, H., Kini, S., and N. Bahadur, \"A YANG Data Model for the Routing Information Base (RIB)\", RFC 8431, DOI 10.17487/RFC8431, September 2018, <http://www.rfc-editor.org/info/rfc8431>.",
      "ja": "[RFC8431]王、L.、チェン、M.、ダス、A.、Ananthakrishnan、H.、KINI、S.、およびN.バハドゥール、 \"ルーティング情報ベース（RIB）のためYANGデータモデル\"、RFC 8431 、DOI 10.17487 / RFC8431、2018年9月、<http://www.rfc-editor.org/info/rfc8431>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Ron Folkes, Jeffrey Zhang, the WG co-Chairs, and reviewers for their comments and suggestions on this document. The following people contributed to the design of the RIB information model as part of the I2RS Interim meeting in April 2013:",
      "ja": "作者はこのドキュメントの彼らのコメントや提案のためにロンFolkes、ジェフリー・チャン、WGの共同議長、および査読に感謝したいと思います。次の人は2013年4月でI2RS暫定会議の一環としてRIB情報モデルの設計に貢献しました："
    },
    {
      "indent": 3,
      "text": "Wes George, Chris Liljenstolpe, Jeff Tantsura, Susan Hares, and Fabian Schneider.",
      "ja": "ウェス・ジョージ、クリスLiljenstolpe、ジェフTantsura、スーザンノウサギ、およびファビアン・シュナイダー。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Nitin Bahadur (editor) Uber 900 Arastradero Rd Palo Alto, CA 94304 United States of America",
      "ja": "アメリカのニティン・バハドゥール（エディタ）ユーバー900 Arastradero Rdのパロアルト、CA 94304米国"
    },
    {
      "indent": 3,
      "text": "Email: nitin_bahadur@yahoo.com",
      "ja": "メール：nitin_bahadur@yahoo.com"
    },
    {
      "indent": 3,
      "text": "Sriganesh Kini (editor)",
      "ja": "Sriganesa購入（編集者）"
    },
    {
      "indent": 3,
      "text": "Email: sriganeshkini@gmail.com",
      "ja": "メール：sriganeshkini@gmail.com"
    },
    {
      "indent": 3,
      "text": "Jan Medved Cisco",
      "ja": "ヤンMedvedシスコ"
    },
    {
      "indent": 3,
      "text": "Email: jmedved@cisco.com",
      "ja": "メール：jmedved@cisco.com"
    }
  ]
}