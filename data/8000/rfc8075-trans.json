{
  "title": {
    "text": "RFC 8075 - Guidelines for Mapping Implementations: HTTP to the Constrained Application Protocol (CoAP)",
    "ja": "RFC 8075 - マッピング実装のためのガイドライン：HTTPへの制約アプリケーションプロトコル（CoAP）"
  },
  "number": 8075,
  "created_at": "2019-10-23 00:10:02.982359+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     A. Castellani\nRequest for Comments: 8075                          University of Padova\nCategory: Standards Track                                      S. Loreto\nISSN: 2070-1721                                                 Ericsson\n                                                               A. Rahman\n                                        InterDigital Communications, LLC\n                                                              T. Fossati\n                                                                   Nokia\n                                                                 E. Dijk\n                                                        Philips Lighting\n                                                           February 2017",
      "raw": true
    },
    {
      "indent": 10,
      "text": "      Guidelines for Mapping Implementations:\nHTTP to the Constrained Application Protocol (CoAP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document provides reference information for implementing a cross-protocol network proxy that performs translation from the HTTP protocol to the Constrained Application Protocol (CoAP). This will enable an HTTP client to access resources on a CoAP server through the proxy. This document describes how an HTTP request is mapped to a CoAP request and how a CoAP response is mapped back to an HTTP response. This includes guidelines for status code, URI, and media type mappings, as well as additional interworking advice.",
      "ja": "この文書では、制約アプリケーションプロトコル（CoAP）にHTTPプロトコルの変換を行うクロスプロトコルネットワークプロキシを実装するための参照情報を提供します。これは、プロキシ経由でCoAPサーバー上のリソースにアクセスするためにHTTPクライアントを有効にします。このドキュメントでは、HTTPリクエストがCoAP応答はHTTP応答に戻ってマッピングされているCoAP要求とどのようにマッピングされている方法を説明します。これは、ステータスコード、URI、およびメディア形式のマッピングだけでなく、追加のインターワーキングのアドバイスのためのガイドラインが含まれています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8075.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8075で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  HTTP-to-CoAP Proxy  . . . . . . . . . . . . . . . . . . . . .   6\n4.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n5.  URI Mapping . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  5.1.  URI Terminology . . . . . . . . . . . . . . . . . . . . .   8\n  5.2.  Null Mapping  . . . . . . . . . . . . . . . . . . . . . .   9\n  5.3.  Default Mapping . . . . . . . . . . . . . . . . . . . . .   9\n    5.3.1.  Optional Scheme Omission  . . . . . . . . . . . . . .   9\n    5.3.2.  Encoding Caveats  . . . . . . . . . . . . . . . . . .  10\n  5.4.  URI Mapping Template  . . . . . . . . . . . . . . . . . .  10\n    5.4.1.  Simple Form . . . . . . . . . . . . . . . . . . . . .  10\n    5.4.2.  Enhanced Form . . . . . . . . . . . . . . . . . . . .  12\n  5.5.  Discovery . . . . . . . . . . . . . . . . . . . . . . . .  13\n    5.5.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .  14\n6.  Media Type Mapping  . . . . . . . . . . . . . . . . . . . . .  15\n  6.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  15\n  6.2.  'application/coap-payload' Media Type . . . . . . . . . .  16\n  6.3.  Loose Media Type Mapping  . . . . . . . . . . . . . . . .  17\n  6.4.  Media Type to Content-Format Mapping Algorithm  . . . . .  18\n  6.5.  Content Transcoding . . . . . . . . . . . . . . . . . . .  19\n    6.5.1.  General . . . . . . . . . . . . . . . . . . . . . . .  19\n    6.5.2.  CoRE Link Format  . . . . . . . . . . . . . . . . . .  20\n  6.6.  Diagnostic Payloads . . . . . . . . . . . . . . . . . . .  20\n7.  Response Code Mapping . . . . . . . . . . . . . . . . . . . .  21\n8.  Additional Mapping Guidelines . . . . . . . . . . . . . . . .  23\n  8.1.  Caching and Congestion Control  . . . . . . . . . . . . .  23\n  8.2.  Cache Refresh via Observe . . . . . . . . . . . . . . . .  24\n  8.3.  Use of CoAP Block-Wise Transfer . . . . . . . . . . . . .  24\n  8.4.  CoAP Multicast  . . . . . . . . . . . . . . . . . . . . .  25\n  8.5.  Timeouts  . . . . . . . . . . . . . . . . . . . . . . . .  26\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  26\n  9.1.  New 'core.hc' Resource Type . . . . . . . . . . . . . . .  26\n  9.2.  New 'coap-payload' Internet Media Type  . . . . . . . . .  26\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  28\n  10.1.  Multicast  . . . . . . . . . . . . . . . . . . . . . . .  29\n  10.2.  Traffic Overflow . . . . . . . . . . . . . . . . . . . .  29\n  10.3.  Handling Secured Exchanges . . . . . . . . . . . . . . .  30\n  10.4.  URI Mapping  . . . . . . . . . . . . . . . . . . . . . .  30\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  31\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  31\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  32\nAppendix A.  Media Type Mapping Source Code . . . . . . . . . . .  35\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  39\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  40",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Constrained Application Protocol (CoAP) [RFC7252] has been designed with a twofold aim: it's an application protocol specialized for constrained environments and it's easily used in architectures based on Representational State Transfer (REST) [Fielding], such as the web. The latter goal has led to defining CoAP to easily interoperate with HTTP [RFC7230] through an intermediary proxy that performs cross-protocol conversion.",
      "ja": "制約アプリケーションプロトコル（CoAP）[RFC7252]は二重の目的で設計されている：それは、アプリケーションプロトコルは、制限された環境に特化しています、それは容易に、ウェブなどのRepresentational State Transfer（REST）[フィールディング]、に基づくアーキテクチャで使われています。後者の目的は、容易にクロスプロトコル変換を行う仲介プロキシを介してHTTP [RFC7230]と相互運用するCoAPを定義するに至りました。"
    },
    {
      "indent": 3,
      "text": "Section 10 of [RFC7252] describes the fundamentals of the CoAP-to-HTTP and the HTTP-to-CoAP cross-protocol mapping process. However, [RFC7252] focuses on the basic mapping of request methods and simple response code mapping between HTTP and CoAP, while leaving many details of the cross-protocol proxy for future definition. Therefore, a primary goal of this document is to define a consistent set of guidelines that an HTTP-to-CoAP proxy implementation should adhere to. The key benefit to adhering to such guidelines is to reduce variation between proxy implementations, thereby increasing interoperability between an HTTP client and a CoAP server independent of the proxy that implements the cross-protocol mapping. (For example, a proxy conforming to these guidelines made by vendor A can be easily replaced by a proxy from vendor B that also conforms to the guidelines without breaking API semantics.)",
      "ja": "[RFC7252]のセクション10はCoAPツーHTTPおよびHTTPツーCoAPクロスプロトコルマッピング処理の基本を説明しています。将来の定義のクロスプロトコルプロキシの多くの詳細を残ししかし、[RFC7252]は、リクエストメソッドとHTTPとCoAP間の単純な応答コードマッピングの基本的なマッピングに焦点を当てます。したがって、この文書の主な目的は、HTTPツーCoAPプロキシの実装が付着すべきガイドラインの一貫性のあるセットを定義することです。このようなガイドラインに付着する主な利点は、それによってHTTPクライアントとクロスプロトコルマッピングを実装するプロキシの独立CoAPサーバ間の相互運用性を増加させる、プロキシ実装間のばらつきを低減することです。 （例えば、ベンダAによって行われたガイドラインに準拠したプロキシが容易また、APIのセマンティックスを壊すことなく、ガイドラインに準拠ベンダーBからプロキシによって置き換えることができます。）"
    },
    {
      "indent": 3,
      "text": "This document describes HTTP mappings that apply to protocol elements defined in the base CoAP specification [RFC7252] and in the CoAP block-wise transfer specification [RFC7959]. It is up to CoAP protocol extensions (new methods, response codes, options, content-formats) to describe their own HTTP mappings, if applicable.",
      "ja": "この文書は、ベースCoAP仕様[RFC7252]及びCoAPブロック単位転送仕様[RFC7959]で定義されたプロトコル要素に適用されるHTTPマッピングを記述する。これは、該当する場合、自分自身のHTTPのマッピングを記述するためにCoAPプロトコル拡張（新しいメソッド、応答コード、オプション、コンテンツ・フォーマット）までです。"
    },
    {
      "indent": 3,
      "text": "The rest of this document is organized as follows:",
      "ja": "このドキュメントの残りは以下の通り構成されています。"
    },
    {
      "indent": 3,
      "text": "o Section 2 defines proxy terminology;",
      "ja": "O部2は、プロキシ用語を定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 3 introduces the HTTP-to-CoAP proxy;",
      "ja": "O部3は、HTTPツーCoAPプロキシを導入します。"
    },
    {
      "indent": 3,
      "text": "o Section 4 lists use cases in which HTTP clients need to contact CoAP servers;",
      "ja": "O部4つのリストは、HTTPクライアントがCoAPサーバーに接続する必要がある場合を使用します。"
    },
    {
      "indent": 3,
      "text": "o Section 5 introduces a null, default, and advanced HTTP-to-CoAP URI mapping syntax;",
      "ja": "O部5は、NULL、デフォルト、および高度なHTTPツーCoAP URIマッピングの構文を紹介します。"
    },
    {
      "indent": 3,
      "text": "o Section 6 describes how to map HTTP media types to CoAP content-formats, and vice versa;",
      "ja": "Oセクション6はCoAPコンテンツ・フォーマット、およびその逆にHTTPのメディアタイプをマップする方法について説明します。"
    },
    {
      "indent": 3,
      "text": "o Section 7 describes how to map CoAP responses to HTTP responses;",
      "ja": "O部7は、HTTPレスポンスにCoAP応答をマッピングする方法について説明します。"
    },
    {
      "indent": 3,
      "text": "o Section 8 describes additional mapping guidelines related to caching, congestion, multicast, timeouts, etc.; and",
      "ja": "O部8は、キャッシング、混雑、マルチキャスト、タイムアウトなどに関連する追加のマッピングのガイドラインを説明し;そして"
    },
    {
      "indent": 3,
      "text": "o Section 10 discusses the possible security impact of HTTP-to-CoAP protocol mapping.",
      "ja": "O部10は、HTTPツーCoAPプロトコルマッピングの可能なセキュリティへの影響を論じています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、 \"推奨NOT\"、および \"OPTIONAL\"本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "This specification requires readers to be familiar with the vocabulary and concepts discussed in [RFC7228], in particular, the terms \"constrained nodes\" and \"constrained networks\". Readers must also be familiar with all of the terminology of the normative references listed in this document, in particular [RFC7252] (CoAP) and [RFC7230] (HTTP). In addition, this specification makes use of the following terms:",
      "ja": "本明細書は、特に、用語「制約ノード」及び「拘束ネットワーク」、[RFC7228]で説明した語彙と概念に精通している読者を必要とします。読者は、特定の[RFC7252]（CoAP）と[RFC7230]（HTTP）は、本文書に記載されている引用規格の用語のすべてに精通しなければなりません。また、この仕様は、以下の用語を使用します："
    },
    {
      "indent": 3,
      "text": "HC Proxy A proxy performing a cross-protocol mapping, in the context of this document an HTTP-to-CoAP (HC) mapping. Specifically, the HC Proxy acts as an HTTP server and a CoAP client. The HC Proxy can take on the role of a forward, reverse, or interception Proxy.",
      "ja": "HCプロキシAプロキシこの文書HTTPツーCoAP（HC）マッピングの文脈において、クロスプロトコルのマッピングを行います。具体的には、HCプロキシは、HTTPサーバとCoAPクライアントとして機能します。 HCプロキシは、前方の役割を担う逆転、または傍受プロキシすることができます。"
    },
    {
      "indent": 3,
      "text": "Application Level Gateway (ALG) An application-specific translation agent that allows an application on a host in one address realm to connect to its counterpart running on a host in a different realm transparently. See Section 2.9 of [RFC2663].",
      "ja": "アプリケーションレベルゲートウェイ（ALG）一つのアドレスレルム内のホスト上のアプリケーションが透過的に異なるレルム内のホスト上で実行してその対応に接続することを可能にするアプリケーション固有の翻訳エージェント。 [RFC2663]のセクション2.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "forward-proxy A message-forwarding agent that is selected by the HTTP client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and to attempt to satisfy those requests via translation to the protocol indicated by the absolute URI. The user agent decides (is willing) to use the proxy as the forwarding/dereferencing agent for a predefined subset of the URI space. In [RFC7230], this is called a \"proxy\". [RFC7252] defines forward-proxy similarly.",
      "ja": "絶対URIの何らかのタイプの要求を受信し、絶対で示されるプロトコルに翻訳を介してこれらの要求を満たすために試みること、通常ローカル構成規則を介してHTTPクライアントによって選択されたメッセージ転送エージェント、フォワードプロキシURI。ユーザエージェントは、URI空間の所定のサブセットの転送/参照解除剤としてプロキシを使用する（意思がある）を決定します。 [RFC7230]で、これは「プロキシ」と呼ばれています。 [RFC7252]は、同様にフォワードプロキシ定義します。"
    },
    {
      "indent": 3,
      "text": "reverse-proxy As in [RFC7230], a receiving agent that acts as a layer above some other server(s) and translates the received requests to the underlying server's protocol. A reverse-proxy behaves as an origin (HTTP) server on its connection from the HTTP client. The",
      "ja": "[RFC7230]にリバースプロキシとして、いくつかの他のサーバ（複数可）上の層として機能し、基礎となるサーバのプロトコルに受信された要求を変換する受信エージェント。リバースプロキシは、HTTPクライアントからの接続上の原点（HTTP）サーバとして動作します。ザ・"
    },
    {
      "indent": 7,
      "text": "HTTP client uses the \"origin-form\" (Section 5.3.1 of [RFC7230])\nas a request-target URI.  (Note that a reverse-proxy appears to\nan HTTP client as an origin server while a forward-proxy does\nnot.  So, when communicating with a reverse-proxy, a client may\nbe unaware it is communicating with a proxy at all.)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "interception proxy As in [RFC3040], a proxy that receives inbound HTTP traffic flows through the process of traffic redirection, transparent to the HTTP client.",
      "ja": "[RFC3040]のように傍受プロキシは、インバウンドHTTPトラフィックを受信プロキシは、HTTPクライアントに対して透過的、トラフィックリダイレクションのプロセスを介して流れます。"
    },
    {
      "indent": 0,
      "text": "3. HTTP-to-CoAP Proxy",
      "section_title": true,
      "ja": "3. HTTPツーCoAPプロキシ"
    },
    {
      "indent": 3,
      "text": "An HC Proxy is accessed by an HTTP client that needs to fetch a resource on a CoAP server. The HC Proxy handles the HTTP request by mapping it to the equivalent CoAP request, which is then forwarded to the appropriate CoAP server. The received CoAP response is then mapped to an appropriate HTTP response and finally sent back to the originating HTTP client.",
      "ja": "HCプロキシは、CoAPサーバー上のリソースを取得する必要があるHTTPクライアントによってアクセスされます。 HCプロキシは、次いで、適切なCoAPサーバに転送される等価CoAP要求、それをマッピングすることにより、HTTPリクエストを処理します。受信CoAP応答は、適切なHTTPレスポンスにマッピングされ、最終的に元のHTTPクライアントに送り返されます。"
    },
    {
      "indent": 3,
      "text": "Section 10.2 of [RFC7252] defines basic normative requirements on HTTP-to-CoAP mapping. This document provides additional details and guidelines for the implementation of an HC Proxy.",
      "ja": "[RFC7252]のセクション10.2 HTTPツーCoAPマッピングの基本的な規範的要件を定義します。この文書では、HCプロキシの実装のための追加の詳細およびガイドラインを提供しています。"
    },
    {
      "indent": 5,
      "text": "                                          Constrained Network\n                                         .-------------------.\n                                        /      .------.       \\\n                                       /       | CoAP |        \\\n                                      /        |server|         \\\n                                     ||        '------'         ||\n                                     ||                         ||\n.--------.  HTTP Request   .------------.  CoAP Req  .------.   ||\n|  HTTP  |---------------->|HTTP-to-CoAP|----------->| CoAP |   ||\n| Client |<----------------|   Proxy    |<-----------|server|   ||\n'--------'  HTTP Response  '------------'  CoAP Resp '------'   ||\n                                     ||                         ||\n                                     ||   .------.              ||\n                                     ||   | CoAP |              ||\n                                      \\   |server|  .------.    /\n                                       \\  '------'  | CoAP |   /\n                                        \\           |server|  /\n                                         \\          '------' /\n                                          '-----------------'",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 1: HTTP-To-CoAP Proxy Deployment Scenario",
      "ja": "図1：HTTP-TO-CoAPプロキシの展開シナリオ"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates an example deployment scenario. There, an HC Proxy is located at the boundary of the constrained network domain and acts as an ALG that allows only a very specific type of traffic (i.e., authorized inbound HTTP requests and their associated outbound CoAP responses) to pass through. All other kinds of traffic are segregated within the respective network segments.",
      "ja": "図1は、例示的な展開シナリオを示しています。そこに、HCプロキシは、トラフィックの非常に特定のタイプ（すなわち、着信HTTP要求とそれに関連するアウトバウンドCoAP応答を承認）を通過することを可能にする制約ネットワークドメインとALGとして作用するの境界に位置しています。トラフィックの他のすべての種類は、それぞれのネットワークセグメント内で分離されています。"
    },
    {
      "indent": 0,
      "text": "4. Use Cases",
      "section_title": true,
      "ja": "4.ユースケース"
    },
    {
      "indent": 3,
      "text": "To illustrate a few situations in which HTTP-to-CoAP protocol translation may be used, three use cases are described below.",
      "ja": "HTTPツーCoAPプロトコル変換を使用することができるいくつかの状況を示すために、3つのユースケースを以下に記載します。"
    },
    {
      "indent": 3,
      "text": "1. Legacy building control application without CoAP: A building control application that uses HTTP but not CoAP can check the status of CoAP sensors and/or control actuators via an HC Proxy.",
      "ja": "CoAP無し1.レガシービル制御アプリケーション：CoAPはHCプロキシ経由CoAPセンサおよび/または制御アクチュエータのステータスを確認することができ、HTTPを使用してではなく、建物制御アプリケーション。"
    },
    {
      "indent": 3,
      "text": "2. Making sensor data available to third parties on the web: For demonstration or public interest purposes, an HC Proxy may be configured to expose the contents of a CoAP sensor to the world via the web (HTTP and/or HTTPS). Some sensors may only accept secure 'coaps' requests; therefore, the proxy is configured to translate requests to those devices accordingly. The HC Proxy is furthermore configured to only pass through GET requests in order to protect the constrained network.",
      "ja": "2.ウェブ上の第三者へのセンサデータを利用可能にする：デモや公益目的のために、HCプロキシは、Web（HTTPおよび/またはHTTPS）を経由して世界にCoAPセンサーの内容を公開するように構成することができます。いくつかのセンサーは、安全な「coapsの要求を受け入れることができ、そのため、プロキシはそれに応じてそれらのデバイスに要求を変換するように構成されています。 HCプロキシは、さらにのみ制約ネットワークを保護するために、GETリクエストを通過するように構成されています。"
    },
    {
      "indent": 3,
      "text": "3. Smartphone and home sensor: A smartphone can access directly a CoAP home sensor using a mutually authenticated 'https' request, provided its home router runs an HC Proxy and is configured with the appropriate certificate. An HTML5 [W3C.REC-html5-20141028] application on the smartphone can provide a friendly UI using the standard (HTTP) networking functions of HTML5.",
      "ja": "3.スマートフォンとホームセンサ：スマートフォンは、相互認証「HTTPS」要求を使用して直接CoAPホームセンサにアクセスすることができるが、そのホームルータはHCプロキシを実行し、適切な証明書で構成されました。スマートフォン上のHTML5 [W3C.REC-html5-20141028]アプリケーションは、HTML5の標準（HTTP）ネットワーク機能を使用してフレンドリーなUIを提供することができます。"
    },
    {
      "indent": 3,
      "text": "A key point in the above use cases is the expected nature of the URI to be used by the HTTP client initiating the HTTP request to the HC Proxy. Specifically, in use case #1, there will be no information related to 'coap' or 'coaps' embedded in the HTTP URI as it is a legacy HTTP client sending the request. Use case #2 is also expected to be similar. In contrast, in use case #3, it is likely that the HTTP client will specifically embed information related to 'coap' or 'coaps' in the HTTP URI of the HTTP request to the HC Proxy.",
      "ja": "上記のユースケースのキーポイントは、HCプロキシへのHTTPリクエストを開始するHTTPクライアントが使用するURIの予想性質です。具体的には、ユースケース＃1において、「coap」またはそれがリクエストを送信し、レガシーHTTPクライアントであるとしてHTTP URIに埋め込ま「coaps」に関連した情報が存在しないであろう。ケース＃2を使用しても同様のことが予想されます。これとは対照的に、ユースケース＃3には、HTTPクライアントは、特にHCプロキシへのHTTPリクエストのHTTP URIに「coap」または「coaps」に関連する情報を埋め込むする可能性があります。"
    },
    {
      "indent": 0,
      "text": "5. URI Mapping",
      "section_title": true,
      "ja": "5. URIマッピング"
    },
    {
      "indent": 3,
      "text": "Though, in principle, a CoAP URI could be directly used by an HTTP client to dereference a CoAP resource through an HC Proxy; the reality is that all major web browsers, networking libraries, and command-line tools do not allow making HTTP requests using URIs with a scheme 'coap' or 'coaps'.",
      "ja": "しかし、原則的に、CoAP URIは直接HCプロキシ経由CoAPリソースデリファレンスにHTTPクライアントで使用できます。現実には、すべての主要なWebブラウザ、ネットワーキングライブラリ、およびコマンドラインツールは、スキーム「coap」または「coaps」がURIを使用してHTTPリクエストを作成することはできませんということです。"
    },
    {
      "indent": 3,
      "text": "Thus, there is a need for web applications to embed or \"pack\" a CoAP URI into an HTTP URI so that it can be (non-destructively) transported from the HTTP client to the HC Proxy. The HC Proxy can then \"unpack\" the CoAP URI and finally dereference it via a CoAP request to the target server.",
      "ja": "したがって、それはHCプロキシへのHTTPクライアントから輸送（非破壊的に）できるようにHTTP URIにCoAP URIを埋め込むか、「パック」するウェブアプリケーションの必要性があります。 HCプロキシは、ターゲット・サーバーへCoAPの要求を介して間接参照し、最終的CoAP URIを「解凍」とすることができます。"
    },
    {
      "indent": 3,
      "text": "URI mapping is the term used in this document to describe the process through which the URI of a CoAP resource is transformed into an HTTP URI so that:",
      "ja": "URIマッピングは、そのようCoAPリソースのURIをHTTP URIに変換される過程を説明するために本書で使用される用語です。"
    },
    {
      "indent": 3,
      "text": "o The requesting HTTP client can handle it; and",
      "ja": "O要求HTTPクライアントはそれを扱うことができます。そして"
    },
    {
      "indent": 3,
      "text": "o The receiving HC Proxy can extract the intended CoAP URI unambiguously.",
      "ja": "oを受信HCプロキシは明白意図CoAP URIを抽出することができます。"
    },
    {
      "indent": 3,
      "text": "To this end, the remainder of this section will identify:",
      "ja": "この目的のために、このセクションの残りの部分は、識別されます。"
    },
    {
      "indent": 3,
      "text": "o The default mechanism to map a CoAP URI into an HTTP URI;",
      "ja": "HTTP URIにCoAP URIをマッピングするためのデフォルトのメカニズムO;"
    },
    {
      "indent": 3,
      "text": "o The URI Template format to express a class of CoAP-HTTP URI mapping functions; and",
      "ja": "CoAP-HTTP URIマッピング関数のクラスを表現するURIテンプレート形式O;そして"
    },
    {
      "indent": 3,
      "text": "o The discovery mechanism based on \"Constrained RESTful Environments (CoRE) Link Format\" [RFC6690] through which clients of an HC Proxy can dynamically learn about the supported URI mapping template(s), as well as the URI where the HC Proxy function is anchored.",
      "ja": "O HCプロキシのクライアントが動的にHCプロキシ機能は、サポートされているURIのマッピングテンプレート（S）と同様に、URIについて学ぶことができ、それを通して、「制約RESTfulな環境（コア）リンク形式」[RFC6690]に基づく発見メカニズムアンカー。"
    },
    {
      "indent": 0,
      "text": "5.1. URI Terminology",
      "section_title": true,
      "ja": "5.1。 URI用語"
    },
    {
      "indent": 3,
      "text": "In the remainder of this section, the following terms will be used with a distinctive meaning:",
      "ja": "このセクションの残りの部分では、以下の用語は、特徴的な意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "HC Proxy URI: URI that refers to the HC Proxy function. It conforms to syntax defined in Section 2.7 of [RFC7230].",
      "ja": "HCプロキシURI：URI HCプロキシ機能を指します。これは、[RFC7230]のセクション2.7で定義された構文に準拠しています。"
    },
    {
      "indent": 3,
      "text": "Target CoAP URI: URI that refers to the (final) CoAP resource that has to be dereferenced. It conforms to syntax defined in Section 6 of [RFC7252]. Specifically, its scheme is either 'coap' or 'coaps'.",
      "ja": "ターゲットCoAP URI：URI間接参照しなければならない（最終）CoAPリソースを指します。それは、[RFC7252]のセクション6で定義された構文に準拠します。具体的には、そのスキームは「coap」または「coaps」のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Hosting HTTP URI: URI that conforms to syntax in Section 2.7 of [RFC7230]. Its authority component refers to an HC Proxy, whereas a path and/or query component(s) embed the information used by an HC Proxy to extract the Target CoAP URI.",
      "ja": "[RFC7230]のセクション2.7で構文に準拠URI：ホスティングHTTP URI。パスおよび/またはクエリコンポーネント（複数可）が目標CoAP URIを抽出するために、HCプロキシによって使用される情報を埋め込む一方、その権限コンポーネントは、HCプロキシを指します。"
    },
    {
      "indent": 0,
      "text": "5.2. Null Mapping",
      "section_title": true,
      "ja": "5.2。ヌルマッピング"
    },
    {
      "indent": 3,
      "text": "The null mapping is the case where there is no Target CoAP URI appended to the HC Proxy URI. In other words, it is a \"pure\" HTTP URI that is sent to the HC Proxy. This would typically occur in situations like use case #1 described in Section 4, and the proxy would typically be a reverse-proxy. In this scenario, the HC Proxy will determine through its own private algorithms what the Target CoAP URI should be.",
      "ja": "ヌルマッピングはHCプロキシURIに付加無ターゲットCoAP URIが存在しない場合です。言い換えれば、HCプロキシに送信され、「純粋な」HTTP URIです。これは、典型的には、セクション4で説明ユースケース＃1のような状況で発生する、プロキシは、典型的には、リバースプロキシであろう。このシナリオでは、HCプロキシがターゲットCoAP URIがどうあるべきか、独自のプライベートのアルゴリズムによって決定されます。"
    },
    {
      "indent": 0,
      "text": "5.3. Default Mapping",
      "section_title": true,
      "ja": "5.3。デフォルトのマッピング"
    },
    {
      "indent": 3,
      "text": "The default mapping is for the Target CoAP URI to be appended as is (with the only caveat discussed in Section 5.3.2) to the HC Proxy URI, to form the Hosting HTTP URI. This is the effective request URI (see Section 5.5 of [RFC7230]) that will then be sent by the HTTP client in the HTTP request to the HC Proxy.",
      "ja": "ターゲットCoAP URIをホスティングHTTP URIを形成するために、HCプロキシURIに（セクション5.3.2で説明した唯一の注意点を有する）であるとして付加されるため、既定のマッピングがあります。これは、その後、HCプロキシへのHTTPリクエストでHTTPクライアントによって送信されます効果的なリクエストURI（[RFC7230]の5.5節を参照）です。"
    },
    {
      "indent": 3,
      "text": "For example: given an HC Proxy URI https://p.example.com/hc/ and a Target CoAP URI coap://s.example.com/light, the resulting Hosting HTTP URI would be https://p.example.com/hc/coap://s.example.com/ light.",
      "ja": "たとえば：HCプロキシURIがhttps://p.example.com/hc/とターゲットCoAP URIのcoap与えられる：// P：//s.example.com/light、結果のホスティングHTTP URIは、HTTPSだろう。 example.com/hc/coap://s.example.com/光。"
    },
    {
      "indent": 3,
      "text": "Provided a correct Target CoAP URI, the Hosting HTTP URI resulting from the default mapping will be a syntactically valid HTTP URI. Furthermore, the Target CoAP URI can always be extracted unambiguously from the Hosting HTTP URI.",
      "ja": "提供正しいターゲットCoAP URI、デフォルトのマッピングから生じたホスティングHTTPのURIは、構文的に有効なHTTP URIとなります。さらに、ターゲットCoAP URIは常にホスティングHTTP URIから明確に抽出することができます。"
    },
    {
      "indent": 3,
      "text": "There is no default for the HC Proxy URI. Therefore, it is either known in advance, e.g., as a configuration preset, or dynamically discovered using the mechanism described in Section 5.5.",
      "ja": "HCプロキシURIのデフォルトはありません。したがって、いずれの構成のプリセットとして、例えば、予め分かっている、または動的にセクション5.5で説明されたメカニズムを使用して発見しました。"
    },
    {
      "indent": 3,
      "text": "The default URI mapping function SHOULD be implemented and SHOULD be activated by default in an HC Proxy, unless there are valid reasons (e.g., application specific) to use a different mapping function.",
      "ja": "デフォルトURIマッピング機能が実現されるべきであり、異なるマッピング関数を使用する正当な理由（例えば、特定用途向け）がある場合を除き、HCプロキシのデフォルトによって活性化されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Optional Scheme Omission",
      "section_title": true,
      "ja": "5.3.1。オプションのスキーム省略"
    },
    {
      "indent": 3,
      "text": "When constructing a Hosting HTTP URI by embedding a Target CoAP URI, the scheme (i.e., 'coap' or 'coaps'), the scheme component delimiter (\":\"), and the double slash (\"//\") preceding the authority MAY be omitted if a local default -- not defined by this document -- applies. If no prior mutual agreement exists between the client and the HC Proxy, then a Target CoAP URI without the scheme component is syntactically incorrect, and therefore:",
      "ja": "権威の前に、ダブルスラッシュ（「//」）：ターゲットCoAP URIスキーム（すなわち、「coap」または「coaps」）、スキーマコンポーネントの区切り文字（「」）を埋め込むことにより、ホスティングHTTP URIを構築する場合この文書で定義されていない -   - ローカルのデフォルトた場合に省略されるかもしれません適用されます。事前の合意は、クライアントとHCプロキシの間に存在しない場合には、スキームのコンポーネントなしのターゲットCoAP URIは文法的に間違っているので、："
    },
    {
      "indent": 3,
      "text": "o It MUST NOT be emitted by clients; and o It MUST elicit a suitable client error status (i.e., 4xx) by the HC Proxy.",
      "ja": "Oそれはクライアントによって放出されてはなりません。そしてOはHCプロキシによって適切なクライアントエラーステータス（すなわち、4XX）を誘発しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Encoding Caveats",
      "section_title": true,
      "ja": "5.3.2。エンコーディングに関する注意事項"
    },
    {
      "indent": 3,
      "text": "When the authority of the Target CoAP URI is given as an IPv6address, then the surrounding square brackets must be percent-encoded in the Hosting HTTP URI, in order to comply with the syntax defined in Section 3.3. of [RFC3986] for a URI path segment. For example: coap://[2001:db8::1]/light?on becomes https://p.example.com/hc/coap://%5B2001:db8::1%5D/light?on. (Note that the percent-encoded square brackets shall be reverted to their non-percent-encoded form when the HC Proxy unpacks the Target CoAP URI.)",
      "ja": "ターゲットCoAP URIの権限がIPv6addressとして与えられたとき、次に周囲の角括弧は、セクション3.3で定義された構文に準拠するために、ホストHTTP URIにパーセントエンコードしなければなりません。 URIパスセグメントのための[RFC3986]。たとえば：coap：//？[2001：DB8 :: 1] /光のhttps://p.example.com/hc/coap://%5B2001:db8::1%5D/light?onになります。 （HCプロキシが目標CoAP URIをアンパックするときパーセントエンコード角括弧は、それらの非パーセントエンコード形式に戻さなければならないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Everything else can be safely copied verbatim from the Target CoAP URI to the Hosting HTTP URI.",
      "ja": "他のすべてが安全にホスティングHTTP URIへのターゲットCoAP URIからそのままコピーすることができます。"
    },
    {
      "indent": 0,
      "text": "5.4. URI Mapping Template",
      "section_title": true,
      "ja": "5.4。 URIマッピングテンプレート"
    },
    {
      "indent": 3,
      "text": "This section defines a format for the URI Template [RFC6570] used by an HC Proxy to inform its clients about the expected syntax for the Hosting HTTP URI. This can then be used by the HTTP client to construct the effective request URI to be sent in the HTTP request to the HC Proxy.",
      "ja": "このセクションでは、ホスティングHTTP URIのために期待される構文については、そのクライアントに通知するために、HCプロキシが使用するURIテンプレート[RFC6570]のためのフォーマットを定義します。これは、その後、HCプロキシへのHTTPリクエストに送信する効果的な要求URIを構築するためにHTTPクライアントで使用することができます。"
    },
    {
      "indent": 3,
      "text": "When instantiated, a URI mapping template is always concatenated to an HC Proxy URI provided by the HC Proxy via discovery (see Section 5.5), or by other means.",
      "ja": "インスタンス化されたときに、URIマッピングテンプレートは常に発見を介してHCプロキシによって提供HCプロキシURIに連結されている（第5.5節を参照）、または他の手段によって。"
    },
    {
      "indent": 3,
      "text": "A simple form (Section 5.4.1) and an enhanced form (Section 5.4.2) are provided to fit different users' requirements.",
      "ja": "シンプルなフォーム（5.4.1項）と強化されたフォーム（5.4.2項）は、異なるユーザーの要件に合うように設けられています。"
    },
    {
      "indent": 3,
      "text": "Both forms are expressed as Level 2 URI Templates [RFC6570] to take care of the expansion of values that are allowed to include reserved URI characters. The syntax of all URI formats is specified in this section in Augmented Backus-Naur Form (ABNF) [RFC5234].",
      "ja": "両方の形態は、予約済みのURI文字を含むように許可されている値の膨張の世話をするために、レベル2 URIテンプレート[RFC6570]として表されます。すべてのURIフォーマットの構文は[RFC5234]増補バッカス - ナウアフォーム（ABNF）でこのセクションで指定されています。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Simple Form",
      "section_title": true,
      "ja": "5.4.1。シンプルなフォルム"
    },
    {
      "indent": 3,
      "text": "The simple form MUST be used for mappings where the Target CoAP URI is going to be copied (using rules of Section 5.3.2) at some fixed position into the Hosting HTTP URI.",
      "ja": "単純な形式は、ターゲットCoAP URIホスティングHTTP URIにある固定位置（5.3.2項の規則を使用して）コピーされようとしているマッピングのために使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"tu\" template variable is defined below using the ABNF rules from [RFC3986], Sections 3.2.2, 3.2.3, 3.3, and 3.4. It is intended to be used in a template definition to represent a Target CoAP URI:",
      "ja": "\"TU\" テンプレート変数は、[RFC3986]、セクション3.2.2、3.2.3、3.3、および3.4​​からABNF規則を用いて以下に定義されます。ターゲットCoAP URIを表現するためにテンプレート定義で使用されることが意図されています。"
    },
    {
      "indent": 5,
      "text": "tu = [ ( \"coap:\" / \"coaps:\" ) \"//\" ] host [ \":\" port ] path-abempty [ \"?\" query ]",
      "ja": "TU = [（ \"coap：\" / \"coaps：\"） \"//\"]ホスト[ \"：\" ポート]パスabemptyの[ \"？\"クエリ]"
    },
    {
      "indent": 3,
      "text": "Note that the same considerations as in Section 5.3.1 apply, in that the CoAP scheme may be omitted from the Hosting HTTP URI.",
      "ja": "CoAP方式はホスティングHTTP URIから省略することができるという点で、5.3.1と同じ考慮事項が適用されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4.1.1. Examples",
      "section_title": true,
      "ja": "5.4.1.1。例"
    },
    {
      "indent": 3,
      "text": "All the following examples (given as a specific URI mapping template, a Target CoAP URI, and the produced Hosting HTTP URI) use https://p.example.com/hc/ as the HC Proxy URI. Note that these examples all define mapping templates that deviate from the default template of Section 5.3 in order to illustrate the use of the above template variables.",
      "ja": "全て（特定URIマッピングテンプレートとして与えられ、ターゲットCoAP URI、および生成ホスティングHTTP URI）以下の実施例は、HCプロキシURIとしてhttps://p.example.com/hc/を使用します。これらの例は、上記のすべてのテンプレート変数の使用方法を説明するために、5.3節のデフォルトテンプレートから逸脱マッピングテンプレートを定義することに注意してください。"
    },
    {
      "indent": 3,
      "text": "1. Target CoAP URI is a query argument of the Hosting HTTP URI:",
      "section_title": true,
      "ja": "1.ターゲットCoAP URIは、ホスティングHTTP URIのクエリー引数です："
    },
    {
      "indent": 3,
      "text": "?target_uri={+tu}",
      "ja": "？target_uri = {+} TU"
    },
    {
      "indent": 3,
      "text": "coap://s.example.com/light",
      "ja": "coap：//s.example.com/light"
    },
    {
      "indent": 3,
      "text": "=> https://p.example.com/hc/?target_uri=coap://s.example.com/light",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／？たｒげｔ＿うり＝こあｐ：／／ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ"
    },
    {
      "indent": 3,
      "text": "whereas",
      "ja": "一方、"
    },
    {
      "indent": 3,
      "text": "coaps://s.example.com/light",
      "ja": "coaps：//s.example.com/light"
    },
    {
      "indent": 3,
      "text": "=> https://p.example.com/hc/?target_uri=coaps://s.example.com/light",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／？たｒげｔ＿うり＝こあｐｓ：／／ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ"
    },
    {
      "indent": 3,
      "text": "2. Target CoAP URI in the path component of the Hosting HTTP URI:",
      "section_title": true,
      "ja": "ホスティングHTTP URIのパスコンポーネント2.ターゲットCoAP URI："
    },
    {
      "indent": 3,
      "text": "forward/{+tu}",
      "ja": "フォワード/ {+} TU"
    },
    {
      "indent": 3,
      "text": "coap://s.example.com/light",
      "ja": "coap：//s.example.com/light"
    },
    {
      "indent": 3,
      "text": "=> https://p.example.com/hc/forward/coap://s.example.com/light",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／ふぉｒわｒｄ／こあｐ：／／ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ"
    },
    {
      "indent": 3,
      "text": "whereas",
      "ja": "一方、"
    },
    {
      "indent": 3,
      "text": "coaps://s.example.com/light",
      "ja": "coaps：//s.example.com/light"
    },
    {
      "indent": 3,
      "text": "=> https://p.example.com/hc/forward/coaps://s.example.com/light",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／ふぉｒわｒｄ／こあｐｓ：／／ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ"
    },
    {
      "indent": 3,
      "text": "3. Target CoAP URI is a query argument of the Hosting HTTP URI; client decides to omit the scheme because a default is agreed beforehand between client and proxy:",
      "ja": "3.ターゲットCoAP URIは、ホスティングHTTP URIのクエリー引数です。デフォルトでは、事前にクライアントとプロキシの間で合意されているため、クライアントは、スキームを省略することを決定しました。"
    },
    {
      "indent": 3,
      "text": "?coap_uri={+tu}",
      "ja": "？Coap_uri} = {+あなた"
    },
    {
      "indent": 3,
      "text": "coap://s.example.com/light",
      "ja": "coap：//s.example.com/light"
    },
    {
      "indent": 3,
      "text": "=> https://p.example.com/hc/?coap_uri=s.example.com/light",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／？こあｐ＿うり＝ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ"
    },
    {
      "indent": 0,
      "text": "5.4.2. Enhanced Form",
      "section_title": true,
      "ja": "5.4.2。強化されたフォーム"
    },
    {
      "indent": 3,
      "text": "The enhanced form can be used to express more sophisticated mappings of the Target CoAP URI into the Hosting HTTP URI, i.e., mappings that do not fit into the simple form.",
      "ja": "強化フォームは、ホスティングHTTP URIに単純な形式に適合しない、すなわち、マッピングをターゲットCoAP URIのより洗練されたマッピングを表現するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "There MUST be at most one instance of each of the following template variables in a URI mapping template definition:",
      "ja": "URIマッピングテンプレート定義に次のテンプレート変数のそれぞれの最大1つのインスタンスが存在でなければなりません。"
    },
    {
      "indent": 5,
      "text": "s = \"coap\" / \"coaps\" ; from [RFC7252], Sections 6.1 and 6.2 hp = host [\":\" port] ; from [RFC3986], Sections 3.2.2 and 3.2.3 p = path-abempty ; from [RFC3986], Section 3.3 q = query ; from [RFC3986], Section 3.4 qq = [ \"?\" query ] ; qq is empty if and only if 'query' is empty",
      "ja": "S = \"coap\" / \"coaps\"。 [RFC7252]から、セクション6.1および6.2馬力=ホスト[ \"：\" ポート]; [RFC3986]、セクション3.2.2および3.2.3 P =パスabemptyから。 [RFC3986]、セクション3.3 Q =クエリから。 [RFC3986]、セクション3.4 QQ = [から \"？\"クエリ]; QQは、もし空であると「クエリ」が空の場合のみ"
    },
    {
      "indent": 3,
      "text": "The qq form is used when the path and the (optional) query components are to be copied verbatim from the Target CoAP URI into the Hosting HTTP URI, i.e., as \"{+p}{+qq}\". Instead, the q form is used when the query and path are mapped as separate entities, e.g., as in \"coap_path={+p}&coap_query={+q}\". So q and qq MUST be used in mutual exclusion in a template definition.",
      "ja": "パス（オプション）クエリコンポーネント、すなわち、「{+ P} {+} QQ」として、ホスティングHTTP URIにターゲットCoAP URIからそのままコピーする場合。QQのフォームが使用されていますクエリパス「はcoap_path = {+ P}＆coap_query = {+ Q}」のように、例えば、別々のエンティティとしてマッピングされている場合代わりに、Qフォームが使用されます。だから、Q及びqqはテンプレート定義に相互排他で使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.2.1. Examples",
      "section_title": true,
      "ja": "5.4.2.1。例"
    },
    {
      "indent": 3,
      "text": "All the following examples (given as a specific URI mapping template, a Target CoAP URI, and the produced Hosting HTTP URI) use https://p.example.com/hc/ as the HC Proxy URI.",
      "ja": "全て（特定URIマッピングテンプレートとして与えられ、ターゲットCoAP URI、および生成ホスティングHTTP URI）以下の実施例は、HCプロキシURIとしてhttps://p.example.com/hc/を使用します。"
    },
    {
      "indent": 3,
      "text": "1. Target CoAP URI components in path segments and optional query in query component:",
      "ja": "クエリコンポーネントのパスセグメントおよび任意のクエリ内の1ターゲットCoAP URI成分："
    },
    {
      "indent": 7,
      "text": "{+s}/{+hp}{+p}{+qq}",
      "ja": "{+ S} / {+ HP} {+ P} {+} QQ"
    },
    {
      "indent": 7,
      "text": "coap://s.example.com/light",
      "ja": "coap：//s.example.com/light"
    },
    {
      "indent": 7,
      "text": "=> https://p.example.com/hc/coap/s.example.com/light whereas",
      "ja": "=> https://p.example.com/hc/coap/s.example.com/lightに対し"
    },
    {
      "indent": 7,
      "text": "coap://s.example.com/light?on",
      "ja": "coap：？//s.example.com/lightに"
    },
    {
      "indent": 7,
      "text": "=> https://p.example.com/hc/coap/s.example.com/light?on",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／こあｐ／ｓ。えぁｍｐぇ。こｍ／ぃｇｈｔ？おん"
    },
    {
      "indent": 3,
      "text": "2. Target CoAP URI components split in individual query arguments:",
      "section_title": true,
      "ja": "2.ターゲットCoAP URIコンポーネントは、個々のクエリの引数に分割しました："
    },
    {
      "indent": 5,
      "text": "?s={+s}&hp={+hp}&p={+p}&q={+q}",
      "ja": "？S = {+ S}＆HP = {+ HP}＆P = {+ P}＆Q = {+ Q}"
    },
    {
      "indent": 5,
      "text": "coap://s.example.com/light",
      "ja": "coap：//s.example.com/light"
    },
    {
      "indent": 5,
      "text": "=> https://p.example.com/hc/?s=coap&hp=s.example.com&p=/light&q=",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／？ｓ＝こあｐ＆ｈｐ＝ｓ。えぁｍｐぇ。こｍ＆ｐ＝／ぃｇｈｔ＆ｑ＝"
    },
    {
      "indent": 5,
      "text": "whereas",
      "ja": "一方、"
    },
    {
      "indent": 5,
      "text": "coaps://s.example.com/light?on",
      "ja": "coaps：？上//s.example.com/light"
    },
    {
      "indent": 5,
      "text": "=> https://p.example.com/hc/?s=coaps&hp=s.example.com&p=/light&q=on",
      "ja": "＝＞ ｈっｔｐｓ：／／ｐ。えぁｍｐぇ。こｍ／ｈｃ／？ｓ＝こあｐｓ＆ｈｐ＝ｓ。えぁｍｐぇ。こｍ＆ｐ＝／ぃｇｈｔ＆ｑ＝おん"
    },
    {
      "indent": 0,
      "text": "5.5. Discovery",
      "section_title": true,
      "ja": "5.5。発見"
    },
    {
      "indent": 3,
      "text": "In order to accommodate site-specific needs while allowing third parties to discover the proxy function, the HC Proxy SHOULD publish information related to the location and syntax of the HC Proxy function using the CoRE Link Format [RFC6690] interface.",
      "ja": "第三者がプロキシ機能を発見することを可能にしながら、サイト固有のニーズに対応するために、HCプロキシは、コア・リンク形式[RFC6690]のインターフェイスを使用して、HCプロキシ機能の位置と構文に関する情報を公開すべきです。"
    },
    {
      "indent": 3,
      "text": "To this aim, a new Resource Type, \"core.hc\", is defined in this document. It can be used as the value for the \"rt\" attribute in a query to the \"/.well-known/core\" resource in order to locate the URI where the HC Proxy function is anchored, i.e., the HC Proxy URI.",
      "ja": "この目的のために、新しいリソースタイプ、「core.hcは」、この文書で定義されています。これは、HCプロキシ機能が固定されているURI、すなわち、HCプロキシURIを見つけるために「/.well-known/core」リソースへのクエリで「RT」属性の値として使用することができます。"
    },
    {
      "indent": 3,
      "text": "Along with it, the new target attribute \"hct\" is defined in this document. This attribute MAY be returned in a \"core.hc\" link to provide the URI mapping template associated with the mapping resource. The default template given in Section 5.3, i.e., {+tu}, MUST be assumed if no \"hct\" attribute is found in a returned link. If a \"hct\" attribute is present in a returned link, the client MUST use it to create a Hosting HTTP URI.",
      "ja": "それに加えて、新たなターゲット属性「HCT」は、本文書で定義されています。この属性は、マッピングリソースに関連付けられているURIのマッピングテンプレートを提供するために、「core.hc」リンクに返されることがあります。いかなる「HCT」属性が返さリンクで見つからない場合、セクション5.3で与えられたデフォルトのテンプレート、すなわち、{+ TU}は、想定されなければなりません。 「HCT」属性が返されたリンクに存在する場合、クライアントは、ホスティングHTTP URIを作成するためにそれを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The URI mapping SHOULD be discoverable (as specified in [RFC6690]) on both the HTTP and the CoAP side of the HC Proxy, with one important difference: on the CoAP side, the link associated with the \"core.hc\" resource always needs an explicit anchor parameter referring to the HTTP origin [RFC6454], while on the HTTP interface, the context URI of the link may be equal to the HTTP origin of the discovery request: in that case, the anchor parameter is not needed.",
      "ja": "URIマッピングは一つの重要な違いは、HTTP及びHCプロキシのCoAP側の両方に（[RFC6690]で指定されるように）発見する必要がありますCoAP側に、「core.hc」リソースに関連付けられたリンクが常に必要HTTPインターフェイスで、リンクのコンテキストURIは、ディスカバリ要求のHTTPの起源に等しくてもよいが、HTTPの起源[RFC6454]を参照の明示的なアンカーパラメータは：その場合、アンカーパラメータが必要とされません。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Examples",
      "section_title": true,
      "ja": "5.5.1。例"
    },
    {
      "indent": 3,
      "text": "o The first example exercises the CoAP interface and assumes that the default template, {+tu}, is used. For example, a smartphone may discover the public HC Proxy before leaving the home network. Then, when outside the home network, the smartphone will be able to query the appropriate home sensor.",
      "ja": "Oの最初の例では、CoAPインターフェイスを行使し、デフォルトのテンプレートは、{+ TU}は、使用されることを想定しています。例えば、スマートフォンは、ホームネットワークを離れる前に、パブリックHCプロキシを発見することがあります。そして、ホームネットワークの外に、スマートフォンは適切なホームセンサを照会することができるようになります。"
    },
    {
      "indent": 7,
      "text": "Req: GET coap://[ff02::fd]/.well-known/core?rt=core.hc",
      "ja": "必須：coapをGET：// [FF02 :: FD] /.well-known/core?rt=core.hc"
    },
    {
      "indent": 7,
      "text": "Res: 2.05 Content </hc/>;anchor=\"https://p.example.com\";rt=\"core.hc\"",
      "ja": "RES：2.05コンテンツ</ HC />;アンカー= \"https://p.example.com\"; RT = \"core.hc\""
    },
    {
      "indent": 3,
      "text": "o The second example -- also on the CoAP side of the HC Proxy -- uses a custom template, i.e., one where the CoAP URI is carried inside the query component, thus the returned link carries the URI Template to be used in an explicit \"hct\" attribute:",
      "ja": "第二の例o  - でもHCプロキシのCoAP側 - は、すなわち、カスタムテンプレートを使用CoAP URIは、クエリコンポーネントの内部に担持されたもの、こうして返さリンクが明示的に使用されるURIテンプレートを運びます\"HCT\" 属性："
    },
    {
      "indent": 7,
      "text": "Req: GET coap://[ff02::fd]/.well-known/core?rt=core.hc",
      "ja": "必須：coapをGET：// [FF02 :: FD] /.well-known/core?rt=core.hc"
    },
    {
      "indent": 7,
      "text": "Res: 2.05 Content </hc/>;anchor=\"https://p.example.com\"; rt=\"core.hc\";hct=\"?uri={+tu}\"",
      "ja": "RES：2：05コンテンツ</ HC />; =アンカー \"https://p.example.com\"。 RT = \"core.hc\"; HCTは= \"？URI = {+}あなた\""
    },
    {
      "indent": 3,
      "text": "On the HTTP side, link information can be serialized in more than one way:",
      "ja": "HTTP側では、リンク情報には、複数の方法でシリアライズすることができます。"
    },
    {
      "indent": 3,
      "text": "o using the 'application/link-format' content type:",
      "ja": "「アプリケーション/リンク形式のコンテンツタイプを使用してO："
    },
    {
      "indent": 7,
      "text": "Req:  GET /.well-known/core?rt=core.hc HTTP/1.1\n      Host: p.example.com",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Res: HTTP/1.1 200 OK Content-Type: application/link-format Content-Length: 19",
      "ja": "RES：HTTP / 1.1 200 OKのContent-Type：アプリケーション/リンクフォーマットのContent-Length：19"
    },
    {
      "indent": 13,
      "text": "</hc/>;rt=\"core.hc\"",
      "ja": "＜／ｈｃ／＞；ｒｔ＝”これ。ｈｃ”"
    },
    {
      "indent": 3,
      "text": "o using the 'application/link-format+json' content type as defined in [CoRE-JSON-CBOR]:",
      "ja": "[コアJSON-CBOR]で定義されるように 'アプリケーション/リンクフォーマット+ JSON' コンテンツタイプを使用して、O："
    },
    {
      "indent": 7,
      "text": "Req:  GET /.well-known/core?rt=core.hc HTTP/1.1\n      Host: p.example.com",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Res: HTTP/1.1 200 OK Content-Type: application/link-format+json Content-Length: 32",
      "ja": "RES：HTTP / 1.1 200 OKのContent-Type：アプリケーション/リンクフォーマット+ JSON形式のコンテンツの長さ：32"
    },
    {
      "indent": 13,
      "text": "[{\"href\":\"/hc/\",\"rt\":\"core.hc\"}]",
      "ja": "[{ \"HREF\"： \"/ HC /\"、 \"RT\"： \"core.hc\"}]"
    },
    {
      "indent": 0,
      "text": "6. Media Type Mapping",
      "section_title": true,
      "ja": "6.メディアタイプのマッピング"
    },
    {
      "indent": 0,
      "text": "6.1. Overview",
      "section_title": true,
      "ja": "6.1。概要"
    },
    {
      "indent": 3,
      "text": "An HC Proxy needs to translate HTTP media types (Section 3.1.1.1 of [RFC7231]) and content codings (Section 3.1.2.2 of [RFC7231]) into CoAP content-formats (Section 12.3 of [RFC7252]), and vice versa.",
      "ja": "HCプロキシCoAPコンテンツ・フォーマット（[RFC7252]のセクション12.3）にHTTPメディアタイプ（[RFC7231]のセクション3.1.1.1）とコンテンツコーディング（[RFC7231]のセクション3.1.2.2）を翻訳する必要があり、逆もまた同様です。"
    },
    {
      "indent": 3,
      "text": "Media type translation can happen in GET, PUT, or POST requests going from HTTP to CoAP, in 2.xx (i.e., successful) responses going from CoAP to HTTP, and in 4.xx/5.xx error responses with a diagnostic payload. Specifically, PUT and POST need to map both the Content-Type and Content-Encoding HTTP headers into a single CoAP Content-Format option, whereas GET needs to map Accept and Accept-Encoding HTTP headers into a single CoAP Accept option. To generate the HTTP response, the CoAP Content-Format option is mapped back to a suitable HTTP Content-Type and Content-Encoding combination.",
      "ja": "メディアの種類の翻訳はCoAPからHTTPに行く2.xxの（すなわち、成功）応答で、GET、PUT、またはCoAPにHTTPから行くPOSTリクエストで発生し、診断ペイロードを持つ4.XX / 5.XXのエラー応答することができます。具体的には、PUTやPOSTはニーズがオプションを受け入れ、単一のCoAPにHTTPヘッダを受け入れ、受け入れエンコードマッピングするために、GETのに対し、単一CoAPコンテンツフォーマットオプションへのContent-TypeとContent-エンコーディングHTTPヘッダの両方をマップする必要があります。 HTTPレスポンスを生成するには、CoAPコンテンツフォーマットオプションはバックに適したHTTPのContent-TypeとContent-エンコーディングの組み合わせにマッピングされています。"
    },
    {
      "indent": 3,
      "text": "An HTTP request carrying a Content-Type and Content-Encoding combination that the HC Proxy is unable to map to an equivalent CoAP Content-Format SHALL elicit a 415 (Unsupported Media Type) response by the HC Proxy.",
      "ja": "HCプロキシがHCプロキシによって415（サポートされていないメディアタイプ）応答を惹起するものと同等のCoAPコンテンツ・フォーマットにマッピングすることができないのContent-TypeとContent-エンコーディングの組み合わせを運ぶHTTPリクエスト。"
    },
    {
      "indent": 3,
      "text": "On the content negotiation side, failure to map Accept and Accept-*\nheaders SHOULD be silently ignored: the HC Proxy SHOULD therefore\nforward as a CoAP request with no Accept option.  The HC Proxy thus\ndisregards the Accept/Accept-* header fields by treating the response\nas if it is not subject to content negotiation, as mentioned in\nSection 5.3 of [RFC7231].  However, an HC Proxy implementation is\nfree to attempt mapping a single Accept header in a GET request to\nmultiple CoAP GET requests, each with a single Accept option, which\nare then tried in sequence until one succeeds.  Note that an HTTP\nAccept */* MUST be mapped to a CoAP request without an Accept option.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "While the CoAP-to-HTTP direction always has a well-defined mapping (with the exception examined in Section 6.2), the HTTP-to-CoAP",
      "ja": "CoAPツーHTTP方向は常に（セクション6.2で検査を除いて）、HTTPツーCoAP明確に定義されたマッピングを有しています"
    },
    {
      "indent": 3,
      "text": "direction is more problematic because the source set, i.e., potentially 1000+ IANA-registered media types, is much bigger than the destination set, i.e., the mere six values initially defined in Section 12.3 of [RFC7252].",
      "ja": "ソースセットは、即ち、潜在1000+メディアタイプをIANAに登録、即ち宛先セットよりもはるかに大きいので、方向がより問題となる、単なる6つの値は、最初は、[RFC7252]のセクション12.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Depending on the tight/loose coupling with the application(s) for which it proxies, the HC Proxy could implement different media type mappings.",
      "ja": "それがプロキシするアプリケーション（複数可）との緊密な/疎結合によっては、HCプロキシは、異なるメディア形式のマッピングを実装することができます。"
    },
    {
      "indent": 3,
      "text": "When tightly coupled, the HC Proxy knows exactly which content-formats are supported by the applications and can be strict when enforcing its forwarding policies in general, and the media type mapping in particular.",
      "ja": "密結合の場合、HCプロキシは、アプリケーションによってサポートされており、一般的に、その転送ポリシーを適用するとき厳密であることができ、特定のメディア・タイプ・マッピングたコンテンツのフォーマットを正確に知っています。"
    },
    {
      "indent": 3,
      "text": "On the other hand, when the HC Proxy is a general purpose ALG, being too strict could significantly reduce the amount of traffic that it would be able to successfully forward. In this case, the \"loose\" media type mapping detailed in Section 6.3 MAY be implemented.",
      "ja": "一方、HCプロキシが汎用ALGあるとき、あまりにも厳格であることは非常にそれが前方に成功することができるだろうトラフィックの量を減らすことができます。この場合には、セクション6.3に詳述「ルーズ」メディアタイプマッピングが実装されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The latter grants more evolution of the surrounding ecosystem, at the cost of allowing more attack surface. In fact, as a result of such strategy, payloads would be forwarded more liberally across the unconstrained/constrained network boundary of the communication path.",
      "ja": "より攻撃面を可能にするコストで周囲の生態系の後者のグラントより進化。実際に、そのような戦略の結果として、ペイロードは、通信経路の非拘束/拘束ネットワーク境界を横切ってより自由に転送されるであろう。"
    },
    {
      "indent": 0,
      "text": "6.2. 'application/coap-payload' Media Type",
      "section_title": true,
      "ja": "6.2。 「アプリケーション/ coap-ペイロード」メディアの種類"
    },
    {
      "indent": 3,
      "text": "If the HC Proxy receives a CoAP response with a Content-Format that it does not recognize (e.g., because the value has been registered after the proxy has been deployed, or the CoAP server uses an experimental value that is not registered), then the HC Proxy SHALL return a generic \"application/coap-payload\" media type with numeric parameter \"cf\" as defined in Section 9.2.",
      "ja": "HCプロキシは、その後、（値はプロキシが展開された後に登録されている、またはCoAPサーバが登録されていない実験値を使用しているため、例えば）それは認識していないコンテンツフォーマットでCoAP応答を受信した場合セクション9.2で定義されたHCプロキシは、数値パラメータ「CF」との一般的な「アプリケーション/ coap-ペイロード」メディアタイプを返還しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the CoAP content-format '60' (\"application/cbor\") would be represented by \"application/coap-payload;cf=60\", if the HC Proxy doesn't recognize the content-format '60'.",
      "ja": "例えば、CoAPコンテンツフォーマット「60」（「アプリケーション/ cborは」）で表されることになる「アプリケーション/ coapペイロード; CF = 60」、HCプロキシは、コンテンツ形式「60」を認識しない場合。"
    },
    {
      "indent": 3,
      "text": "An HTTP client may use the media type \"application/coap-payload\" as a means to send a specific content-format to a CoAP server via an HC Proxy if the client has determined that the HC Proxy does not directly support the type mapping it needs. This case may happen when dealing, for example, with newly registered, yet to be registered, or experimental CoAP content-formats. However, unless explicitly configured to allow pass-through of unknown content-formats, the HC Proxy SHOULD NOT forward requests carrying a Content-Type or Accept header with an \"application/coap-payload\", and return an appropriate client error instead.",
      "ja": "HTTPクライアントは、クライアントがHCプロキシは直接型マッピングにそれをサポートしていないと判断した場合にはHCプロキシを経由してCoAPサーバに特定のコンテンツフォーマットを送信するための手段として、メディアタイプ「アプリケーション/ coap-ペイロード」を使用することができますニーズ。この場合は、新たに登録して、例えば、扱うときに発生する可能性があり、未だ登録する、または実験CoAPコンテンツ・フォーマット。しかし、明示的に未知のコンテンツ・フォーマットのパススルーを許可するように構成されていない限り、HCプロキシは、NOT前方のContent-Typeを運ぶ要求するべきであるか、「アプリケーション/ coap-ペイロード」との見出しを受け入れ、代わりに適切なクライアントのエラーを返します。"
    },
    {
      "indent": 0,
      "text": "6.3. Loose Media Type Mapping",
      "section_title": true,
      "ja": "6.3。ルースメディアタイプのマッピング"
    },
    {
      "indent": 3,
      "text": "By structuring the type information in a super-class (e.g., \"text\") followed by a finer-grained sub-class (e.g., \"html\"), and optional parameters (e.g., \"charset=utf-8\"), Internet media types provide a rich and scalable framework for encoding the type of any given entity.",
      "ja": "より細かいサブクラス（例えば、「HTML」）、およびオプションのパラメータ（例えば、「文字セット= UTF-8」）、インターネットに続いてスーパークラス（例えば、「テキスト」）に型情報を構造化することにより、メディアタイプは、任意のエンティティのタイプを符号化するための豊富でスケーラブルなフレームワークを提供します。"
    },
    {
      "indent": 3,
      "text": "This approach is not applicable to CoAP, where content-formats conflate an Internet media type (potentially with specific parameters) and a content coding into one small integer value.",
      "ja": "このアプローチは、コンテンツのフォーマットはインターネットメディアタイプ（潜在的に特定のパラメータを有する）および1つの小さな整数値に符号化コンテンツをconflate CoAP、に適用されません。"
    },
    {
      "indent": 3,
      "text": "To remedy this loss of flexibility, we introduce the concept of a \"loose\" media type mapping, where media types that are specializations of a more generic media type can be aliased to their super-class and then mapped (if possible) to one of the CoAP content-formats. For example, \"application/soap+xml\" can be aliased to \"application/xml\", which has a known conversion to CoAP. In the context of this \"loose\" media type mapping, \"application/ octet-stream\" can be used as a fallback when no better alias is found for a specific media type.",
      "ja": "この柔軟性の損失を改善するために、我々は、のいずれかにより一般的なメディアタイプの特殊化されているメディアタイプは、そのスーパークラスにエイリアスし、その後マッピングすることができ、「緩い」メディアタイプのマッピング、（可能であれば）の概念を導入しますCoAPのコンテンツ形式。例えば、「アプリケーション/石鹸+ XMLは」CoAPに既知の変換を有し、「アプリケーション/ XML」にエイリアスすることができます。何より良いエイリアスが特定のメディアタイプのために見つからない場合、この「緩い」メディア・タイプ・マッピングの文脈では、「アプリケーション/オクテットストリーム」フォールバックとして使用することができます。"
    },
    {
      "indent": 3,
      "text": "Table 1 defines the default lookup table for the \"loose\" media type mapping. It is expected that an implementation can refine it because either application-specific knowledge is given or new Content-Formats are defined. Given an input media type, the table returns its best generalized media type using the most specific match, i.e., the table entries are compared to the input in top to bottom order until an entry matches.",
      "ja": "表1は、「緩い」メディアタイプのマッピングのデフォルトのルックアップテーブルを定義します。どちらかのアプリケーション固有の知識が与えられているか、新しいコンテンツのフォーマットが定義されているので、実装はそれを絞り込むことが期待されます。入力メディアタイプ指定された、テーブル、すなわち、最も具体的な一致を使用して、最良の一般的なメディアタイプを返し、テーブルエントリは、エントリが一致するまで、下ために上部に入力と比較されます。"
    },
    {
      "indent": 8,
      "text": "+-----------------------------+--------------------------+\n| Internet media type pattern | Generalized media type   |\n+-----------------------------+--------------------------+\n| application/*+xml           | application/xml          |\n| application/*+json          | application/json         |\n| application/*+cbor          | application/cbor         |\n| text/xml                    | application/xml          |\n| text/*                      | text/plain               |\n| */*                         | application/octet-stream |\n+-----------------------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 1: Media Type Generalization Lookup Table",
      "ja": "表1：メディアの種類汎化ルックアップテーブル"
    },
    {
      "indent": 3,
      "text": "The \"loose\" media type mapping is an OPTIONAL feature. Implementations supporting this kind of mapping should provide a flexible way to define the set of media type generalizations allowed.",
      "ja": "「緩い」メディアタイプのマッピングはオプション機能です。マッピングのこの種類をサポートする実装は、許容メディアタイプの一般化のセットを定義するための柔軟な方法を提供するべきです。"
    },
    {
      "indent": 0,
      "text": "6.4. Media Type to Content-Format Mapping Algorithm",
      "section_title": true,
      "ja": "6.4。コンテンツフォーマットマッピングアルゴリズムにメディアタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines the algorithm used to map an HTTP Internet media type to its correspondent CoAP content-format; it can be used as a building block for translating HTTP Content-Type and Accept headers into CoAP Content-Format and Accept Options.",
      "ja": "このセクションでは、その対応CoAPコンテンツフォーマットにHTTPインターネットメディアタイプをマップするために使用されるアルゴリズムを定義します。それはHTTPのContent-Typeを変換するためのビルディングブロックとして使用し、CoAPのコンテンツフォーマットにヘッダを受け入れ、オプションを受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "The algorithm uses an IANA-maintained table, \"CoAP Content-Formats\", as established by Section 12.3 of [RFC7252] plus, possibly, any locally defined extension of it. Optionally, the table and lookup mechanism described in Section 6.3 can be used if the implementation chooses so.",
      "ja": "[RFC7252]のセクション12.3に加えて、おそらく、それのいずれかの局所的に定義された拡張によって確立されるアルゴリズムは、IANA-保持テーブル、「CoAPコンテンツ・フォーマット」を使用します。実装がそう選択した場合に必要に応じて、セクション6.3に記載のテーブルルックアップ機構を使用することができます。"
    },
    {
      "indent": 3,
      "text": "Note that the algorithm assumes an \"identity\" Content-Encoding and expects the resource body has been already successfully content decoded or transcoded to the desired format.",
      "ja": "アルゴリズムは「同一性」のContent-encodingを想定しており、資源本体はすでに正常に復号コンテンツまたは所望の形式にトランスコードされた期待していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "In the following (Figure 2):",
      "ja": "以下（図2）において："
    },
    {
      "indent": 3,
      "text": "o media_type is the media type to translate;",
      "ja": "O media_typeこのオプションでは、変換するメディアタイプがあります。"
    },
    {
      "indent": 3,
      "text": "o coap_cf_registry is a lookup table matching the \"CoAP Content-Formats\" registry; and",
      "ja": "O coap_cf_registryは「CoAPのコンテンツフォーマット」レジストリに一致するルックアップテーブルです。そして"
    },
    {
      "indent": 3,
      "text": "o loose_mapper is an optional lookup table describing the loose media type mappings (e.g., the one defined in Table 1).",
      "ja": "O loose_mapperはルーズメディアタイプマッピング（例えば、表1で定義されたもの）を記述するオプションのルックアップテーブルです。"
    },
    {
      "indent": 3,
      "text": "The full source code is provided in Appendix A.",
      "ja": "完全なソースコードは付録Aに設けられています。"
    },
    {
      "indent": 1,
      "text": "def mt2cf(media_type, encoding=None, coap_cf_registry=CoAPContentFormatRegistry(), loose_mapper=None): \"\"\"Return a CoAP Content-Format given an Internet media type and its optional encoding. The current (as of 2016/10/24) \"CoAP Content-Formats\" registry is supplied by default. An optional 'loose-mapping' implementation can be supplied by the caller.\"\"\" assert media_type is not None assert coap_cf_registry is not None",
      "ja": "デフmt2cf（media_typeこの、エンコーディング=なし、coap_cf_registry = CoAPContentFormatRegistry（）、loose_mapper =なし）：「」 \"インターネットメディアタイプとオプションのエンコーディングを指定したCoAPコンテンツ・フォーマットを返し、現在（2016年10月24日現在） 「CoAPのコンテンツフォーマット」レジストリがデフォルトで提供されています。オプションの「ルーズマッピング」実装は、呼び出し側によって供給することができる。「」」media_typeこの主張をなしアサートcoap_cf_registryではありませんNoneでありません"
    },
    {
      "indent": 5,
      "text": "# Lookup the \"CoAP Content-Formats\" registry\ncontent_format = coap_cf_registry.lookup(media_type, encoding)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "# If an exact match is not found and a loose mapper has been # supplied, try to use it to get a media type with which to # retry the \"CoAP Content-Formats\" registry lookup. if content_format is None and loose_mapper is not None: content_format = coap_cf_registry.lookup( loose_mapper.lookup(media_type), encoding)",
      "ja": "＃完全一致が見つからない場合や緩いマッパーは＃供給された、＃に「CoAPコンテンツ・フォーマット」のレジストリ検索を再試行しているとのメディアタイプを得るためにそれを使用するようにしてください。 content_format = coap_cf_registry.lookup（loose_mapper.lookup（media_typeこのオプション）、符号化）：content_formatであればなしとloose_mapperをなしません。"
    },
    {
      "indent": 5,
      "text": "return content_format",
      "ja": "リターンcontent_format"
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 0,
      "text": "6.5. Content Transcoding",
      "section_title": true,
      "ja": "6.5。コンテンツトランスコーディング"
    },
    {
      "indent": 0,
      "text": "6.5.1. General",
      "section_title": true,
      "ja": "6.5.1。一般的な"
    },
    {
      "indent": 3,
      "text": "Payload content transcoding is an OPTIONAL feature. Implementations supporting this feature should provide a flexible way to define the set of transcodings allowed.",
      "ja": "ペイロードコンテンツのトランスコーディングはオプション機能です。この機能をサポートする実装は許さトランスコーディングのセットを定義するための柔軟な方法を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "The HC Proxy might decide to transcode the received representation to a different (compatible) format when an optimized version of a specific format exists. For example, an XML-encoded resource could be transcoded to Efficient XML Interchange (EXI) format, or a JSON-encoded resource into Concise Binary Object Representation (CBOR) [RFC7049], effectively achieving compression without losing any information.",
      "ja": "HCプロキシは、特定の形式の最適化されたバージョンが存在する場合、異なる（互換）フォーマットに受信された表現を変換することを決定するかもしれません。例えば、XMLでエンコードされたリソースを効果的に任意の情報を失うことなく圧縮を達成する、効率的なXMLインターチェンジ（EXI）形式、または簡潔なバイナリオブジェクト表現（CBOR）[RFC7049]にJSONエンコードリソースにトランスコードすることができます。"
    },
    {
      "indent": 3,
      "text": "However, there are a few important factors to keep in mind when enabling a transcoding function:",
      "ja": "しかし、トランスコーディング機能を有効にする際に心に留めておくべきいくつかの重要な要因があります。"
    },
    {
      "indent": 3,
      "text": "1. Maliciously crafted inputs coming from the HTTP side might inflate in size (see, for example, Section 4.2 of [RFC7049]), therefore creating a security threat for both the HC Proxy and the target resource.",
      "ja": "HTTP側から来る1悪意を持って作成された入力は、したがってHCプロキシおよびターゲット・リソースの両方に対するセキュリティ脅威を作成する、（例えば、[RFC7049]のセクション4.2を参照）のサイズに膨張することがあります。"
    },
    {
      "indent": 3,
      "text": "2. Transcoding can lose information in non-obvious ways. For example, encoding an XML document using schema-informed EXI encoding leads to a loss of information when the destination does not know the exact schema version used by the encoder. That means that whenever the HC Proxy transcodes \"application/xml\" to \"application/exi\", in-band metadata could be lost.",
      "ja": "2.トランスコーディングは、非自明な方法で情報を失うことができます。例えば、スキーマ通知EXI符号化を使用してXMLドキュメントをコードする宛先がエンコーダによって使用される正確なスキーマのバージョンを知らない情報の損失につながります。それはHCプロキシは、「アプリケーション/ XML」を「アプリケーション/ EXI」をトランスコードしたときに、インバンドメタデータが失われる可能性があることを意味しています。"
    },
    {
      "indent": 3,
      "text": "3. When the Content-Type is mapped, there is a risk that the content with the destination type would have malware not active in the source type.",
      "ja": "Content-Typeがマッピングされている場合は3、宛先タイプを持つコンテンツソースの種類に積極的ではないマルウェアを持っているでしょう恐れがあります。"
    },
    {
      "indent": 3,
      "text": "It is crucial that these risks are well understood and carefully weighed against the actual benefits before deploying the transcoding function.",
      "ja": "これらのリスクを十分に理解し、慎重にトランスコーディング機能を配備する前に実際の利益と比較検討されていることが重要です。"
    },
    {
      "indent": 0,
      "text": "6.5.2. CoRE Link Format",
      "section_title": true,
      "ja": "6.5.2。コアリンクフォーマット"
    },
    {
      "indent": 3,
      "text": "The CoRE Link Format [RFC6690] is a set of links (i.e., URIs and their formal relationships) that is carried as content payload in a CoAP response. These links usually include CoAP URIs that might be translated by the HC Proxy to the correspondent HTTP URIs using the implemented URI mapping function (see Section 5). Such a translation process would inspect the forwarded traffic and attempt to rewrite the body of resources with an application/link-format media type, mapping the embedded CoAP URIs to their HTTP counterparts. Some potential issues with this approach are:",
      "ja": "コアリンク形式[RFC6690]はCoAP応答にコンテンツペイロードとして搬送されるリンク（すなわち、URIとその正式な関係）の集合です。これらのリンクは、通常、（第5節参照）を実装URIのマッピング機能を使用して対応するHTTPのURIにHCプロキシによって翻訳される可能性がありますCoAP URIを含んでいます。このような変換プロセスは、転送されたトラフィックを検査し、そのHTTPの対応に埋め込まれたCoAP URIをマッピングし、アプリケーション/リンク形式のメディアタイプとリソースの本体を書き換えるしようとしていました。このアプローチにはいくつかの潜在的な問題は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The client may be interested in retrieving original (unaltered) CoAP payloads through the HC Proxy, not modified versions.",
      "ja": "1.クライアントは、HCプロキシを介して元の（未変更）CoAPペイロードを取得するに興味がある可能性があり、バージョンを変更しません。"
    },
    {
      "indent": 3,
      "text": "2. Tampering with payloads is incompatible with resources that are integrity protected (although this is a problem with transcoding in general).",
      "ja": "2.ペイロードが改ざんされる（これは一般的には、トランスコーディングの問題ですが）完全性が保護されたリソースと互換性がありません。"
    },
    {
      "indent": 3,
      "text": "3. The HC Proxy needs to fully understand syntax and semantics defined in [RFC6690], otherwise there is an inherent risk to corrupt the payloads.",
      "ja": "3. HCプロキシは、それ以外の場合は破損しているペイロードに固有のリスクがあり、完全に[RFC6690]で定義された構文とセマンティクスを理解する必要があります。"
    },
    {
      "indent": 3,
      "text": "Therefore, CoRE Link Format payload should only be transcoded at the risk and discretion of the proxy implementer.",
      "ja": "そのため、コアリンクのフォーマットペイロードは、プロキシ実装のリスクと裁量でトランスコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Diagnostic Payloads",
      "section_title": true,
      "ja": "6.6。診断ペイロード"
    },
    {
      "indent": 3,
      "text": "CoAP responses may, in certain error cases, contain a diagnostic message in the payload explaining the error situation, as described in Section 5.5.2 of [RFC7252]. If present, the CoAP diagnostic payload SHOULD be copied into the HTTP response body with the media type of the response set to \"text/plain;charset=utf-8\". The CoAP diagnostic payload MUST NOT be copied into the HTTP reason-phrase, since it potentially contains CR-LF characters that are incompatible with HTTP reason-phrase syntax.",
      "ja": "[RFC7252]のセクション5.5.2に記載したようにCoAP応答は、特定のエラーの場合には、エラー状況を説明ペイロードに診断メッセージを含んでいてもよいです。存在する場合、CoAP診断ペイロードに設定され、応答のメディアタイプとHTTPレスポンスボディにコピーする必要があり、「プレーンテキスト/;のcharset = UTF-8」。それは潜在的にHTTPの理由フレーズの構文と互換性のないCR-LF文字が含まれているのでCoAP診断ペイロードは、HTTPの理由フレーズにコピーしてはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Response Code Mapping",
      "section_title": true,
      "ja": "7.応答コードマッピング"
    },
    {
      "indent": 3,
      "text": "Table 2 defines the HTTP response status codes to which each CoAP response code SHOULD be mapped. Multiple HTTP status codes in the second column for a given CoAP response code indicates that multiple HTTP responses are possible for the same CoAP response code, depending on the conditions cited in the Notes (see the third column and text below the table).",
      "ja": "表2は、各CoAP応答コードがマッピングすべきHTTPレスポンスステータスコードを定義します。所与CoAP応答コードの第2列の複数のHTTPステータスコードは、複数のHTTP応答がノートに引用条件（下表3番目の列とテキストを参照）に応じて、同じCoAP応答コードに対して可能であることを示しています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------+----------------------------+------+\n| CoAP Response Code            | HTTP Status Code           | Note |\n+-------------------------------+----------------------------+------+\n| 2.01 Created                  | 201 Created                | 1    |\n| 2.02 Deleted                  | 200 OK                     | 2    |\n|                               | 204 No Content             | 2    |\n| 2.03 Valid                    | 304 Not Modified           | 3    |\n|                               | 200 OK                     | 4    |\n| 2.04 Changed                  | 200 OK                     | 2    |\n|                               | 204 No Content             | 2    |\n| 2.05 Content                  | 200 OK                     |      |\n| 2.31 Continue                 | N/A                        | 10   |\n| 4.00 Bad Request              | 400 Bad Request            |      |\n| 4.01 Unauthorized             | 403 Forbidden              | 5    |\n| 4.02 Bad Option               | 400 Bad Request            | 6    |\n|                               | 500 Internal Server Error  | 6    |\n| 4.03 Forbidden                | 403 Forbidden              |      |\n| 4.04 Not Found                | 404 Not Found              |      |\n| 4.05 Method Not Allowed       | 400 Bad Request            | 7    |\n|                               | 405 Method Not Allowed     | 7    |\n| 4.06 Not Acceptable           | 406 Not Acceptable         |      |\n| 4.08 Request Entity Incomplt. | N/A                        | 10   |\n| 4.12 Precondition Failed      | 412 Precondition Failed    |      |\n| 4.13 Request Ent. Too Large   | 413 Payload Too Large      | 11   |\n| 4.15 Unsupported Content-Fmt. | 415 Unsupported Media Type |      |\n| 5.00 Internal Server Error    | 500 Internal Server Error  |      |\n| 5.01 Not Implemented          | 501 Not Implemented        |      |\n| 5.02 Bad Gateway              | 502 Bad Gateway            |      |\n| 5.03 Service Unavailable      | 503 Service Unavailable    | 8    |\n| 5.04 Gateway Timeout          | 504 Gateway Timeout        |      |\n| 5.05 Proxying Not Supported   | 502 Bad Gateway            | 9    |\n+-------------------------------+----------------------------+------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 2: CoAP-HTTP Response Code Mappings",
      "ja": "表2：CoAP-HTTPレスポンスコードのマッピング"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "1. A CoAP server may return an arbitrary format payload along with this response. If present, this payload MUST be returned as an entity in the HTTP 201 response. Section 6.3.2 of [RFC7231] does not put any requirement on the format of the entity. (In the past, [RFC2616] did. Note that [RFC2616] has been obsoleted by [RFC7230].)",
      "ja": "1. CoAPサーバはこの応答と共に任意の形式のペイロードを返すことができます。存在する場合、このペイロードは、HTTP 201応答エンティティとして返さなければなりません。 [RFC7231]のセクション6.3.2は、エンティティのフォーマットにどのような要件を入れていません。 （過去には、[RFC2616]はなかった。[RFC2616]が[RFC7230]によって廃止されたことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "2. The HTTP code is 200 or 204, respectively, for the case where a CoAP server returns a payload or not. [RFC7231], Section 6.3 requires code 200 in case a representation of the action result is returned for DELETE/POST/PUT, and code 204 if not. Hence, a proxy MUST transfer any CoAP payload contained in a CoAP 2.02 response to the HTTP client using a 200 OK response.",
      "ja": "2. HTTPコードがCoAPサーバはペイロードを返すかどうかの場合について、それぞれ、200または204です。 [RFC7231]、セクション6.3は、アクション結果の表現はDELETE / POST / PUTのために返され、コード204ならない場合にはコード200を必要とします。したがって、プロキシは、200 OK応答を使用してHTTPクライアントにCoAP 2.02応答に含まれる任意CoAPペイロードを転送しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. HTTP code 304 (Not Modified) is sent if the HTTP client performed a conditional HTTP request and the CoAP server responded with 2.03 (Valid) to the corresponding CoAP validation request. Note that Section 4.1 of [RFC7232] puts some requirements on header fields that must be present in the HTTP 304 response.",
      "ja": "3. HTTPコード304（変更されていません）HTTPクライアントが、条件付きHTTP要求を行い、CoAPサーバが対応CoAP検証要求に2.03（有効）で応答した場合に送信されます。 [RFC7232]の4.1 HTTP 304応答して存在しなければならないヘッダフィールドにいくつかの要件を置き、そのセクションに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "4. A 200 response to a CoAP 2.03 occurs only when the HC Proxy, for efficiency reasons, is running a local cache. An unconditional HTTP GET that produces a cache-hit could trigger a revalidation (i.e., a conditional GET) on the CoAP side. The proxy receiving 2.03 updates the freshness of its cached representation and returns it to the HTTP client.",
      "ja": "CoAP 2.03 4. A 200の応答は、HCプロキシは、効率上の理由から、ローカルキャッシュが実行されている場合にのみ発生します。 CoAP側の再検証（すなわち、条件付きのGET）を引き起こす可能性がキャッシュヒットを生成無条件HTTPのGET。 2.03を受けたプロキシは、そのキャッシュされた表現の鮮度を更新し、HTTPクライアントに返します。"
    },
    {
      "indent": 3,
      "text": "5. An HTTP 401 Unauthorized (Section 3.1 of [RFC7235]) response is not applicable because there is no equivalent of WWW-Authenticate in CoAP, which is mandatory in an HTTP 401 response.",
      "ja": "HTTP 401応答に必須であるCoAPにおけるWWW認証の同等がないため応答5. HTTP 401不正（[RFC7235]のセクション3.1）が適用されません。"
    },
    {
      "indent": 3,
      "text": "6. If the proxy has a way to determine that the Bad Option is due to the straightforward mapping of a client request header into a CoAP option, then returning HTTP 400 (Bad Request) is appropriate. In all other cases, the proxy MUST return HTTP 500 (Internal Server Error) stating its inability to provide a suitable translation to the client's request.",
      "ja": "プロキシが不正なオプションがCoAPオプションにクライアント要求ヘッダーの単純マッピングによるものであることを決定する方法を持っている場合6.は、HTTP 400（不正な要求）を返すことが適切です。他のすべての例では、プロキシは、クライアントの要求に適した翻訳を提供することをできないことを述べHTTP 500（内部サーバーエラー）を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "7. A CoAP 4.05 (Method Not Allowed) response SHOULD normally be mapped to an HTTP 400 (Bad Request) code, because the HTTP 405 response would require specifying the supported methods -- which are generally unknown. In this case, the HC Proxy SHOULD also return an HTTP reason-phrase in the HTTP status line that starts with the string \"CoAP server returned 4.05\" in order to facilitate troubleshooting. However, if the HC Proxy has more granular information about the supported methods for the requested resource (e.g., via a Resource Directory ([CoRE-RD])), then it MAY send back an HTTP 405 (Method Not Allowed) with a properly filled in \"Allow\" response-header field (Section 7.4.1 of [RFC7231]).",
      "ja": "一般的に知られていない -  HTTP 405応答がサポートされている方法を指定する必要になるため、7 A CoAP 4.05（方法不可）応答は、通常、HTTP 400（不正な要求）コードにマッピングされるべきです。この場合、HCプロキシも、トラブルシューティングを容易にするために、「CoAPサーバは4.05を返した」という文字列で始まるHTTPステータスラインでHTTPの理由フレーズを返すべきです。 HCプロキシ（リソース・ディレクトリ（[CORE-RD]）を介して、例えば）要求されたリソースのためのサポート方法について、より詳細な情報を持っている場合は、それが適切でHTTP 405（方法不可）を送り返します「許可」の応答ヘッダフィールド内に充填された（[RFC7231]のセクション7.4.1）。"
    },
    {
      "indent": 3,
      "text": "8. The value of the HTTP \"Retry-After\" response-header field is taken from the value of the CoAP Max-Age Option, if present.",
      "ja": "存在する場合8. HTTP「再試行の後に」レスポンス・ヘッダー・フィールドの値は、CoAP最大年齢オプションの値から取られます。"
    },
    {
      "indent": 3,
      "text": "9. This CoAP response can only happen if the proxy itself is configured to use a CoAP forward-proxy (Section 5.7 of [RFC7252]) to execute some, or all, of its CoAP requests.",
      "ja": "プロキシ自体は、そのCoAP要求の一部、または全てを実行するCoAPフォワードプロキシ（[RFC7252]のセクション5.7）を使用するように構成されている場合、この9 CoAP応答のみ起こることができます。"
    },
    {
      "indent": 3,
      "text": "10. Only used in CoAP block-wise transfer [RFC7959] between HC Proxy and CoAP server; never translated into an HTTP response.",
      "ja": "のみHCプロキシとCoAPサーバ間CoAPブロック単位転送[RFC7959]で使用される10。 HTTPレスポンスに翻訳されません。"
    },
    {
      "indent": 3,
      "text": "11. Only returned to the HTTP client if the HC Proxy was unable to successfully complete the request by retrying it with CoAP block-wise transfer; see Section 8.3.",
      "ja": "HCプロキシが正常にCoAPブロック単位で転送して再試行することによってそれを要求を完了できなかった場合11のみHTTPクライアントに返します。セクション8.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "8. Additional Mapping Guidelines",
      "section_title": true,
      "ja": "8.追加のマッピングのガイドライン"
    },
    {
      "indent": 0,
      "text": "8.1. Caching and Congestion Control",
      "section_title": true,
      "ja": "8.1。キャッシングと輻輳制御"
    },
    {
      "indent": 3,
      "text": "An HC Proxy should cache CoAP responses and reply whenever applicable with a cached representation of the requested resource.",
      "ja": "HCプロキシは、CoAP応答をキャッシュし、要求されたリソースのキャッシュされた表現でいつでも適用を返信すべきです。"
    },
    {
      "indent": 3,
      "text": "If the HTTP client drops the connection after the HTTP request was made, an HC Proxy should wait for the associated CoAP response and cache it if possible. Subsequent requests to the HC Proxy for the same resource can use the result present in cache, or, if a response has still to come, the HTTP requests will wait on the open CoAP request.",
      "ja": "HTTPクライアントが接続を切断する場合は、HTTP要求が行われた後、HCプロキシは、関連するCoAPの応答を待つ必要があり、可能であれば、それをキャッシュします。同じリソースに対するHCプロキシへの後続の要求には応答がまだ来て持っている場合は、HTTPリクエストがオープンCoAP要求に待機します、キャッシュ内に存在し、結果を使用するか、またはすることができます。"
    },
    {
      "indent": 3,
      "text": "According to [RFC7252], a proxy must limit the number of outstanding requests to a given CoAP server to NSTART. To limit the amount of aggregate traffic to a constrained network, the HC Proxy should also put a limit on the number of concurrent CoAP requests pending on the same constrained network; further incoming requests may either be queued or be dropped (returning 503 Service Unavailable). This limit and the proxy queueing/dropping behavior should be configurable.",
      "ja": "[RFC7252]によると、プロキシは、n始動に与えられたCoAPサーバへの未処理の要求の数を制限する必要があります。拘束されたネットワークへの集約トラフィックの量を制限するには、HCプロキシも同じ制約ネットワーク上の保留中の要求の同時CoAPの数に制限を置く必要があります。さらに、着信要求がいずれかのキューに入れられてもよいし、（503サービス利用不可復帰）を滴下します。この制限およびプロキシキューイング/ドロップ動作を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Highly volatile resources that are being frequently requested may be observed [RFC7641] by the HC Proxy to keep their cached representation fresh while minimizing the amount of CoAP traffic in the constrained network (see Section 8.2).",
      "ja": "頻繁に要求されている揮発性の高い資源が制約ネットワークにCoAPトラフィックの量を最小限に抑えながら、新鮮な彼らのキャッシュされた表現を維持するためにHCプロキシで[RFC7641]を観察することができる（8.2節を参照してください）。"
    },
    {
      "indent": 0,
      "text": "8.2. Cache Refresh via Observe",
      "section_title": true,
      "ja": "8.2。キャッシュ・リフレッシュを経由して観察します"
    },
    {
      "indent": 3,
      "text": "There are cases where using the CoAP observe protocol [RFC7641] to handle proxy cache refresh is preferable to the validation mechanism based on the entity-tag (ETag) as defined in [RFC7252]. Such scenarios include sleepy CoAP nodes -- with possibly high variance in requests' distribution -- which would greatly benefit from a server-driven cache update mechanism. Ideal candidates for CoAP observe are also crowded or very low throughput networks, where reduction of the total number of exchanged messages is an important requirement.",
      "ja": "[RFC7252]で定義されるようCoAPプロキシキャッシュの更新を処理するためのプロトコル[RFC7641]を使用して観察するエンティティタグ（ETagの）に基づいて、検証機構に好ましい場合があります。リクエスト分布の可能性の高い分散を有する -   - 大幅サーバ主導キャッシュ更新機構から利益を得るようなシナリオは、眠いCoAPノードを含みます。 CoAPのための理想的な候補者はまた、混雑しているか、交換されたメッセージの総数の削減が重要な要件である非常に低いスループットネットワーク、観察します。"
    },
    {
      "indent": 3,
      "text": "This subsection aims at providing a practical evaluation method to decide whether refreshing a cached resource R is more efficiently handled via ETag validation or by establishing an observation on R. The idea being that the HC Proxy proactively installs an observation on a \"popular enough\" resource and actively monitors:",
      "ja": "ここでは、さわやかなキャッシュされたリソースRをより効率的にETagの検証を介して、またはアイデアはHCプロキシが積極的に「人気の十分な」リソース上での観測をインストールするということでR.に観察を確立することにより処理されるかどうかを決定するための実用的な評価方法を提供することを目的とそして、積極的に監視します。"
    },
    {
      "indent": 3,
      "text": "a. Its update pattern on the CoAP side",
      "ja": "A。 CoAP側でその更新パターン"
    },
    {
      "indent": 3,
      "text": "b. The request pattern on the HTTP side",
      "ja": "B。 HTTP側の要求パターン"
    },
    {
      "indent": 3,
      "text": "and uses the formula below to determine whether the observation should be kept alive or shut down.",
      "ja": "観察が生かさまたはシャットダウンされるべきかどうかを決定するために、以下の式を使用します。"
    },
    {
      "indent": 3,
      "text": "Let T_R be the mean time between two client requests to resource R, let T_C be the mean time between two representation changes of R, and let M_R be the mean number of CoAP messages per second exchanged to and from resource R. If we assume that the initial cost for establishing the observation is negligible, an observation on R reduces M_R if and only if T_R < 2*T_C with respect to using ETag validation, that is, if and only if the mean arrival rate of requests for resource R is greater than half the change rate of R.",
      "ja": "私たちがいることを前提とした場合T_Rは、RリソースT_Cは、Rの2つの表現の変化間の平均時間であるとすると、M_R毎秒CoAPメッセージの平均数であるとするには、2つのクライアント要求間の平均時間は、資源Rにしてから交換することがしてみましょう観察を確立するための初期コストは無視できる程度である、R上の観察はM_Rの場合減少し、リソースRの要求の平均到着率が大きい場合にのみ場合T_RのETag検証を使用してに対して<2 * T_Cは、それが、場合のみR.の半分の変化率よりも"
    },
    {
      "indent": 3,
      "text": "When observing the resource R, M_R is always upper bounded by 2/T_C.",
      "ja": "リソースRを観察する場合、M_Rは常に上位2 / T_Cによって制限されます。"
    },
    {
      "indent": 0,
      "text": "8.3. Use of CoAP Block-Wise Transfer",
      "section_title": true,
      "ja": "8.3。 CoAPブロック単位の転送の使用"
    },
    {
      "indent": 3,
      "text": "An HC Proxy SHOULD support CoAP block-wise transfers [RFC7959] to allow transport of large CoAP payloads while avoiding excessive link-layer fragmentation in constrained networks and to cope with small datagram buffers in CoAP endpoints as described in [RFC7252], Section 4.6.",
      "ja": "HCプロキシCoAPブロック単位転送[RFC7959]に制約ネットワークにおける過剰なリンク層断片化を回避しながら、大型CoAPペイロードの輸送を可能にすると[RFC7252]で説明されるようにCoAPエンドポイントに小さなデータグラム・バッファに対応する、第4.6節をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "An HC Proxy SHOULD attempt to retry a payload-carrying CoAP PUT or POST request with block-wise transfer if the destination CoAP server responded with 4.13 (Request Entity Too Large) to the original request. An HC Proxy SHOULD attempt to use block-wise transfer when sending a CoAP PUT or POST request message that is larger than",
      "ja": "先CoAPサーバは元の要求に4.13（要求エンティティが大きすぎる）と応答した場合HCプロキシは、ブロック単位の転送とペイロード担持CoAPのPUTまたはPOSTリクエストを再試行を試みます。 HCプロキシより大きいCoAPのPUTまたはPOSTリクエストメッセージを送信するときにブロック単位転送を使用しようとするべきです"
    },
    {
      "indent": 3,
      "text": "BLOCKWISE_THRESHOLD bytes. The value of BLOCKWISE_THRESHOLD is implementation specific; for example, it can be:",
      "ja": "BLOCKWISE_THRESHOLDバイト。 BLOCKWISE_THRESHOLDの値は実装固有です。例えば、それはすることができます。"
    },
    {
      "indent": 3,
      "text": "o Calculated based on a known or typical UDP datagram buffer size for CoAP endpoints, or",
      "ja": "O CoAPエンドポイントの既知または一般的なUDPデータグラムバッファサイズに基づいて計算され、又は"
    },
    {
      "indent": 3,
      "text": "o Set to N times the known size of a link-layer frame in a constrained network where, e.g., N=5, or",
      "ja": "O例えば、N倍にここ制約ネットワークにおけるリンク層フレームの既知のサイズを設定し、N = 5、又は"
    },
    {
      "indent": 3,
      "text": "o Preset to a known IP MTU value, or",
      "ja": "O既知のIP MTU値にプリセット、または"
    },
    {
      "indent": 3,
      "text": "o Set to a known Path MTU value.",
      "ja": "O知られているパスMTU値に設定します。"
    },
    {
      "indent": 3,
      "text": "The value BLOCKWISE_THRESHOLD, or the parameters from which it is calculated, should be configurable in a proxy implementation. The maximum block size the proxy will attempt to use in CoAP requests should also be configurable.",
      "ja": "値BLOCKWISE_THRESHOLD、またはそれが計算されたパラメータが、プロキシ実装で構成可能でなければなりません。プロキシがCoAPリクエストで使用しようとする最大ブロックサイズも設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The HC Proxy SHOULD detect CoAP endpoints not supporting block-wise transfers. This can be done by checking for a 4.02 (Bad Option) response returned by an endpoint in response to a CoAP request with a Block* Option, and subsequent absence of the 4.02 in response to the same request without Block* Options. This allows the HC Proxy to be more efficient, not attempting repeated block-wise transfers to CoAP servers that do not support it.",
      "ja": "HCプロキシは、ブロック単位の転送をサポートしていないCoAPエンドポイントを検出する必要があります。これは、ブロック*オプションなしで同じ要求に応じて、4.02のブロック*オプション、およびその後の不在とCoAP要求に応じて、エンドポイントで返さ4.02（バート・オプション）の応答をチェックすることによって行うことができます。これは、HCプロキシがそれをサポートしていないCoAPサーバーに繰り返しブロック単位の転送をしようとしていない、より効率的にすることができます。"
    },
    {
      "indent": 0,
      "text": "8.4. CoAP Multicast",
      "section_title": true,
      "ja": "8.4。 CoAPマルチキャスト"
    },
    {
      "indent": 3,
      "text": "An HC Proxy MAY support CoAP multicast. If it does, the HC Proxy sends out a multicast CoAP request if the Target CoAP URI's authority is a multicast IP literal or resolves to a multicast IP address. If the HC Proxy does not support CoAP multicast, it SHOULD respond 403 (Forbidden) to any valid HTTP request that maps to a CoAP multicast request.",
      "ja": "HCプロキシは、CoAPマルチキャストをサポートするかもしれません。それがない場合は、ターゲットCoAP URIの権限はリテラルのマルチキャストIPであるか、マルチキャストIPアドレスに解決される場合は、HCプロキシは、マルチキャストCoAP要求を送信します。 HCプロキシがCoAPマルチキャストをサポートしていない場合、それはCoAPマルチキャスト要求にマップする任意の有効なHTTPリクエストに403（禁止）に応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "Details related to supporting CoAP multicast are currently out of scope of this document since in a proxy scenario, an HTTP client typically expects to receive a single response, not multiple. However, an HC Proxy that implements CoAP multicast may include application-specific functions to aggregate multiple CoAP responses into a single HTTP response. We suggest using the \"application/http\" Internet media type (Section 8.3.2 of [RFC7230]) to enclose a set of one or more HTTP response messages, each representing the mapping of one CoAP response.",
      "ja": "プロキシシナリオでは、HTTPクライアントは通常、単一の応答ではなく、複数を受信することを期待するのでCoAPマルチキャストをサポートすることに関連する詳細は、このドキュメントの範囲の外に現在あります。しかし、CoAPマルチキャストを実装HCプロキシは、単一のHTTPレスポンスに複数のCoAP応答を集約するアプリケーション固有の機能を含むことができます。私たちは、それぞれが1つのCoAP応答のマッピングを表す、一つ以上のHTTP応答メッセージのセットを囲むために、「アプリケーション/ HTTP」インターネットメディアタイプ（[RFC7230]のセクション8.3.2）を使用してお勧めします。"
    },
    {
      "indent": 3,
      "text": "For further considerations related to the handling of multicast requests, see Section 10.1.",
      "ja": "マルチキャスト要求の処理に関連するさらなる考慮事項については、10.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.5. Timeouts",
      "section_title": true,
      "ja": "8.5。タイムアウト"
    },
    {
      "indent": 3,
      "text": "If the CoAP server takes a long time in responding, the HTTP client or any other proxy in between may timeout. Further discussion of timeouts in HTTP is available in Section 6.5 of [RFC7230].",
      "ja": "CoAPサーバが応答に時間がかかる場合は、HTTPクライアントまたは月タイムアウトの間のいずれかの他のプロキシ。 HTTPにおけるタイムアウトのさらなる議論は、[RFC7230]のセクション6.5で利用可能です。"
    },
    {
      "indent": 3,
      "text": "An HC Proxy MUST define an internal timeout for each pending CoAP request, because the CoAP server may silently die before completing the request. Assuming the proxy uses confirmable CoAP requests, such timeout value T SHOULD be",
      "ja": "CoAPサーバは黙って要求を完了する前に死ぬ可能性があるため、HCプロキシは、保留中の各CoAP要求用の内部タイムアウトを定義しなければなりません。プロキシが確認可能CoAP要求を使用して仮定すると、そのようなタイムアウト値Tは次のようになり"
    },
    {
      "indent": 3,
      "text": "T = MAX_RTT + MAX_SERVER_RESPONSE_DELAY",
      "ja": "T = MAX_RTT + MAX_SERVER_RESPONSE_DELAY"
    },
    {
      "indent": 3,
      "text": "where MAX_RTT is defined in [RFC7252] and MAX_SERVER_RESPONSE_DELAY is defined as the worst-case expected response delay of the CoAP server. If unknown, a default value of 250 seconds can be used for MAX_SERVER_RESPONSE_DELAY as in Section 2.5 of [RFC7390].",
      "ja": "MAX_RTTは[RFC7252]で定義され、MAX_SERVER_RESPONSE_DELAYはCoAPサーバの最悪の場合の予想される応答遅れとして定義されます。不明な場合は、250秒のデフォルト値は[RFC7390]の2.5節のようにMAX_SERVER_RESPONSE_DELAYのために使用することができます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. New 'core.hc' Resource Type",
      "section_title": true,
      "ja": "9.1。新しい「core.hc」リソースタイプ"
    },
    {
      "indent": 3,
      "text": "This document registers a new Resource Type (rt=) Link Target Attribute, 'core.hc', in the \"Resource Type (rt=) Link Target Attribute Values\" subregistry under the \"Constrained RESTful Environments (CoRE) Parameters\" registry.",
      "ja": "この文書はで、新しいリソースタイプ（RT =）リンクのターゲット属性「core.hc」を登録する「制約RESTfulな環境（CORE）パラメータ」レジストリの下に副登録「リソースタイプ（RT =）リンクのターゲット属性値」。"
    },
    {
      "indent": 3,
      "text": "Attribute Value: core.hc",
      "ja": "属性値：core.hc"
    },
    {
      "indent": 3,
      "text": "Description: HTTP-to-CoAP mapping base resource.",
      "ja": "説明：HTTPツーCoAPマッピングベースのリソース。"
    },
    {
      "indent": 3,
      "text": "Reference: See Section 5.5 of RFC 8075.",
      "ja": "参考：RFC 8075のセクション5.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.2. New 'coap-payload' Internet Media Type",
      "section_title": true,
      "ja": "9.2。新しい「coap-ペイロードのインターネットメディアタイプ"
    },
    {
      "indent": 3,
      "text": "This document defines the \"application/coap-payload\" media type with a single parameter \"cf\". This media type represents any payload that a CoAP message can carry, having a content-format that can be identified by an integer in range 0-65535 corresponding to a CoAP Content-Format parameter ([RFC7252], Section 12.3). The parameter \"cf\" is the integer defining the CoAP content-format.",
      "ja": "この文書では、単一のパラメータ「CF」と「アプリケーション/ coapペイロード」メディアタイプを定義します。このメディアタイプはCoAPコンテンツ - 形式パラメータ（[RFC7252]、セクション12.3）に対応する0〜65535の整数により同定することができるコンテンツフォーマットを有する、CoAPメッセージを運ぶことができる任意のペイロードを表します。パラメータ「CF」はCoAPコンテンツフォーマットを定義する整数です。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "型名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: coap-payload",
      "ja": "サブタイプ名：coapペイロード"
    },
    {
      "indent": 3,
      "text": "Required parameters: \"cf\" (CoAP Content-Format integer in range 0-65535 denoting the content-format of the CoAP payload carried, as defined by the \"CoAP Content-Formats\" subregistry that is part of the \"Constrained RESTful Environments (CoRE) Parameters\" registry).",
      "ja": "必要なパラメータ：「制約RESTfulな環境（コアの一部である「CoAPコンテンツ・フォーマット」副登録によって定義される範囲0-65535に「CF」（CoAPコンテンツフォーマット整数、実施CoAPペイロードのコンテンツフォーマットを表します）パラメータ」レジストリ）。"
    },
    {
      "indent": 3,
      "text": "Optional parameters: None",
      "ja": "オプションのパラメータ：なし"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: Common use is BINARY. The specific CoAP content-format encoding considerations for the selected Content-Format (\"cf\" parameter) apply. The encoding can vary based on the value of the \"cf\" parameter.",
      "ja": "エンコードの考慮事項：一般的な使用はBINARYです。選択したコンテンツ・フォーマット（「CF」パラメータ）のための具体的なCoAPコンテンツフォーマットのエンコードの考慮事項が適用されます。符号化は、「CF」パラメータの値に基づいて変化することができます。"
    },
    {
      "indent": 3,
      "text": "Security considerations: The specific CoAP content-format security considerations for the selected Content-Format (\"cf\" parameter) apply.",
      "ja": "セキュリティに関する注意事項：選択したコンテンツ・フォーマット（「CF」パラメータ）のための具体的なCoAPコンテンツフォーマットのセキュリティに関する考慮事項が適用されます。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: This media type can never be used directly in CoAP messages because there are no means available to encode the mandatory \"cf\" parameter in CoAP.",
      "ja": "相互運用性に関する注意事項：CoAPで必須「CF」のパラメータを符号化するために利用可能な手段が存在しないため、このメディアタイプがCoAPメッセージで直接使用することはできません。"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 8075",
      "ja": "公開された仕様：RFC 8075"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: HTTP-to-CoAP proxies.",
      "ja": "HTTPツーCoAPプロキシ：このメディアタイプを使用するアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: CoAP does not support URI fragments; therefore, a CoAP payload fragment cannot be identified. Fragments are not applicable for this media type.",
      "ja": "フラグメント識別子の考慮事項：CoAPは、URIのフラグメントをサポートしていません。従って、CoAPペイロードフラグメントは特定できません。フラグメントは、このメディアタイプには適用されません。"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Deprecated alias names for this type: N/A",
      "ja": "このタイプの非推奨別名：N / A"
    },
    {
      "indent": 6,
      "text": "Magic number(s): N/A",
      "ja": "マジックナンバー（S）：N / A"
    },
    {
      "indent": 6,
      "text": "File extension(s): N/A",
      "ja": "ファイルの拡張子（S）：N / A"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshのファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information:",
      "ja": "詳細のために連絡する人とEメールアドレス："
    },
    {
      "indent": 6,
      "text": "Esko Dijk (\"esko@ieee.org\")",
      "ja": "エスコダイク（ \"esko@ieee.org\"）"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage:",
      "ja": "使用に関する制限事項："
    },
    {
      "indent": 3,
      "text": "An application (or user) can only use this media type if it has to represent a CoAP payload of which the specified CoAP Content-Format is an unrecognized number, such that a proper translation directly to the equivalent HTTP media type is not possible.",
      "ja": "それは、指定CoAPコンテンツ・フォーマットを直接等価HTTPメディアタイプに適切な翻訳が不可能であるように認識されていない番号であり、そのCoAPペイロードを表す必要がある場合、アプリケーション（またはユーザ）のみがこのメディアタイプを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Author: CoRE WG",
      "ja": "著者：コアWG"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Provisional registration: No",
      "ja": "仮登録：いいえ"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security considerations in Section 9.2 of [RFC7230] apply in full to the HC Proxy. This section discusses security aspects and requirements that are specific to the deployment and operation of an HC Proxy.",
      "ja": "[RFC7230]のセクション9.2におけるセキュリティの考慮事項は、HCプロキシへの完全に適用されます。このセクションでは、セキュリティ面やHCプロキシの展開と運用に固有の要件について説明します。"
    },
    {
      "indent": 3,
      "text": "An HC Proxy located at the boundary of a constrained network is an easy single point of failure for reducing availability. As such, special care should be taken in designing, developing, and operating it, keeping in mind that, in most cases, it has fewer limitations than the constrained devices it is serving. In particular, its quality of implementation and operation -- i.e., use of current software development practices, careful selection of third-party libraries, sane configuration defaults, and an expedited way to upgrade a running instance -- are all essential attributes of the HC Proxy.",
      "ja": "制約ネットワークの境界に位置するHCプロキシは、可用性を低下させるための障害の容易単一点です。そのため、特別なケアは、ほとんどの場合、それがサービスを提供している制約のあるデバイスよりも少ない制限があり、ということを念頭に置いて、設計、開発、およびそれを動作させるには注意が必要です。具体的には、実装と運用のその品質 - すなわち、現在のソフトウェア開発手法、サードパーティのライブラリ、まともな設定のデフォルト値を慎重に選択し、実行中のインスタンスをアップグレードするための迅速な方法の使用 -  HCのあるすべての本質的属性プロキシ。"
    },
    {
      "indent": 3,
      "text": "The correctness of request parsing in general (including any content transcoding), and of URI translation in particular, is essential to the security of the HC Proxy function. This is especially true when the constrained network hosts devices with genuinely limited capabilities. For this purpose, see also Sections 9.3, 9.4, 9.5 and 9.6 of [RFC7230] for well-known issues related to HTTP request parsing and Section 11.1 of [RFC7252] for an overview of CoAP-specific concerns related to URI processing -- in particular, the potential impact on access control mechanisms that are based on URIs.",
      "ja": "具体的には（任意のコンテンツのトランスコーディングを含む）一般的に、とURIの翻訳の解析要求の正当性は、HCプロキシ機能のセキュリティに不可欠です。これは、制約されたネットワークは本当に限られた機能を持つデバイスをホストする場合は特にそうです。で - この目的のために、また、URI処理に関連するCoAP特有の懸念事項の概要については、HTTPリクエストの解析と[RFC7252]のセクション11.1に関連した、よく知られた問題については、[RFC7230]のセクション9.3、9.4、9.5および9.6を参照してください特に、のURIに基づいてアクセス制御メカニズムに潜在的な影響。"
    },
    {
      "indent": 3,
      "text": "An HC Proxy MUST implement Transport Layer Security (TLS) with a Pre-Shared Key (PSK) [RFC4279] and SHOULD implement TLS [RFC5246] with support for client authentication using X.509 certificates. A prerequisite of the latter is the availability of a Certification Authority (CA) to issue suitable certificates. Although this can be a challenging requirement in certain application scenarios, it is worth noting that there exist open-source tools (e.g., [OpenSSL]) that can be used to set up and operate an application-specific CA.",
      "ja": "HCプロキシは、事前共有鍵（PSK）[RFC4279]でトランスポート層セキュリティ（TLS）を実装しなければならないとX.509証明書を使用してクライアント認証をサポートするTLS [RFC5246]を実装する必要があります。後者の前提条件は、適切な証明書を発行する認証局（CA）の可用性です。これは、特定のアプリケーションシナリオに挑戦的な要件であることができるが、アプリケーション固有のCAを設定および操作するために使用することができるオープンソースツール（例えば、[OpenSSLの]）が存在することは注目に値します"
    },
    {
      "indent": 3,
      "text": "By default, the HC Proxy MUST authenticate all incoming requests prior to forwarding them to the CoAP server. This default behavior MAY be explicitly disabled by an administrator.",
      "ja": "デフォルトでは、HCプロキシはCoAPサーバーに転送する前に、すべての着信要求を認証しなければなりません。このデフォルトの動作は、管理者が明示的に無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "The following subparagraphs categorize and discuss a set of specific security issues related to the translation, caching, and forwarding functionality exposed by an HC Proxy.",
      "ja": "次の各号に分類し、HCプロキシによって公開された翻訳、キャッシング、および転送機能に関連する特定のセキュリティ問題のセットを議論します。"
    },
    {
      "indent": 0,
      "text": "10.1. Multicast",
      "section_title": true,
      "ja": "10.1。マルチキャスト"
    },
    {
      "indent": 3,
      "text": "Multicast requests impose a non-trivial cost on the constrained network and endpoints and might be exploited as a DoS attack vector (see also Section 10.2). From a privacy perspective, they can be used to gather detailed information about the resources hosted in the constrained network. For example, an outsider that is able to successfully query the \"/.well-known/core\" resource could obtain a comprehensive list of the target's home appliances and devices. From a security perspective, they can be used to carry out a network reconnaissance attack to gather information about possible vulnerabilities that could be exploited at a later point in time. For these reasons, it is RECOMMENDED that requests to multicast resources are access controlled with a default-deny policy. It is RECOMMENDED that the requestor of a multicast resource be strongly authenticated. If privacy and/or security are first class requirements, for example, whenever the HTTP request transits through the public Internet, the request SHOULD be transported over a mutually authenticated and encrypted TLS connection.",
      "ja": "マルチキャスト要求は、制約ネットワークおよびエンドポイント上の非自明なコストを課し、（も10.2項を参照してください）DoS攻撃ベクトルとして利用される可能性があります。プライバシーの観点から、彼らは拘束されたネットワークでホストされているリソースに関する詳細な情報を収集するために使用することができます。例えば、成功した「/.well-known/core」リソースを照会することができます部外者には、ターゲットの家電製品とデバイスの包括的なリストを得ることができました。セキュリティの観点から、彼らは後の時点で悪用される可能性が可能な脆弱性に関する情報を収集するために、ネットワーク偵察攻撃を実行するために使用することができます。これらの理由から、マルチキャストリソースへの要求がデフォルト-拒否ポリシーにアクセス制御することをお勧めします。マルチキャストリソースの要求者が強く認証されることが推奨されます。プライバシーおよび/またはセキュリティがファーストクラスの要件であれば、例えば、いつでもHTTPリクエスト遷移公共のインターネットを介し、要求は相互に認証と暗号化されたTLS接続上で転送されるべきである（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "10.2. Traffic Overflow",
      "section_title": true,
      "ja": "10.2。トラフィックオーバーフロー"
    },
    {
      "indent": 3,
      "text": "Due to the typically constrained nature of CoAP nodes, particular attention should be given to the implementation of traffic reduction mechanisms (see Section 8.1), because an inefficient proxy implementation can be targeted by unconstrained Internet attackers. Bandwidth or complexity involved in such attacks is very low.",
      "ja": "非効率的なプロキシの実装は、制約のないインターネットの攻撃者が標的とすることができるのでによるCoAPノードの通常制約性質のために、特別な注意が、トラフィックの減速機構（8.1節を参照）の実装に与えられるべきです。このような攻撃に関与帯域幅や複雑さが非常に低いです。"
    },
    {
      "indent": 3,
      "text": "An amplification attack to the constrained network may be triggered by a multicast request generated by a single HTTP request that is mapped to a CoAP multicast resource, as discussed in Section 11.3 of [RFC7252].",
      "ja": "[RFC7252]のセクション11.3で説明したように制約ネットワークに増幅攻撃は、CoAPマルチキャストリソースにマッピングされる単一のHTTP要求によって生成されるマルチキャスト要求によってトリガされてもよいです。"
    },
    {
      "indent": 3,
      "text": "The risk likelihood of this amplification technique is higher than an amplification attack carried out by a malicious constrained device (e.g., ICMPv6 flooding, like Packet Too Big, or Parameter Problem on a multicast destination [RFC4732]) since it does not require direct access to the constrained network.",
      "ja": "この増幅技術のリスク可能性が悪質な制約デバイスによって行われた増幅攻撃よりも高くなっている（例えば、ICMPv6の氾濫は、マルチキャスト宛先にパケット過大、またはパラメータ問題[RFC4732]のように）それはへの直接アクセスを必要としないので、制約ネットワーク。"
    },
    {
      "indent": 3,
      "text": "The feasibility of this attack, which disrupts availability of the targeted CoAP server, can be limited by access controlling the exposed multicast resources, so that only known/authorized users can access such URIs.",
      "ja": "のみ/知られ、権限のあるユーザーは、そのようなURIをアクセスできるように目標CoAPサーバーの可用性を乱し、この攻撃の可能性は、露出マルチキャストリソースをアクセス制御によって制限することができます。"
    },
    {
      "indent": 0,
      "text": "10.3. Handling Secured Exchanges",
      "section_title": true,
      "ja": "10.3。担保付取引所の取り扱い"
    },
    {
      "indent": 3,
      "text": "An HTTP request can be sent to the HC Proxy over a secured connection. However, there may not always exist a secure connection mapping to CoAP. For example, a secure distribution method for multicast traffic is complex and may not be implemented (see [RFC7390]).",
      "ja": "HTTPリクエストは、セキュアな接続を介しHCプロキシに送信することができます。しかし、常にCoAPへの安全な接続のマッピングが存在しない場合があります。例えば、マルチキャストトラフィックのためのセキュアな配布方法が複雑であり、実現されなくてもよい（[RFC7390]を参照）。"
    },
    {
      "indent": 3,
      "text": "An HC Proxy should implement rules for security context translations. For example, all 'https' unicast requests are translated to 'coaps' requests, or 'https' requests are translated to unsecured 'coap' requests. Another rule could specify the security policy and parameters used for Datagram Transport Layer Security (DTLS) sessions [RFC7925]. Such rules will largely depend on the application and network context in which the HC Proxy operates. These rules should be configurable.",
      "ja": "HCプロキシは、セキュリティコンテキストの翻訳のためのルールを実装する必要があります。たとえば、すべての「HTTPS」のユニキャスト要求が「coapsの要求に変換され、または「httpsの要求は、無担保 \"coapの要求に変換されます。別のルールは、データグラムトランスポート層セキュリティ（DTLS）セッション[RFC7925]のために使用されるセキュリティポリシーとパラメータを指定することもできます。そのようなルールは、主にHCプロキシが動作するアプリケーションとネットワークコンテキストに依存するであろう。これらのルールは、設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that, by default, accessing a 'coaps' URI is only allowed from a corresponding 'https' URI.",
      "ja": "デフォルトでは、「coaps」URIにアクセスするだけで、対応する「HTTPS」URIから許可されている、ことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "By default, an HC Proxy SHOULD reject any secured CoAP client request (i.e., one with a 'coaps' scheme) if there is no configured security policy mapping. This recommendation may be relaxed in case the destination network is believed to be secured by other means. Assuming that CoAP nodes are isolated behind a firewall as in the HC Proxy deployment shown in Figure 1, the HC Proxy may be configured to translate the incoming HTTPS request using plain CoAP (NoSec mode).",
      "ja": "全く設定されたセキュリティポリシー・マッピングが存在しない場合、デフォルトで、HCプロキシは、任意のセキュアCoAPクライアント要求を（すなわち、「coaps」スキーム1）拒絶すべきです。宛先ネットワークが他の手段によって固定されると考えられる場合には、この推奨は緩和することができます。 CoAPノードは、図1に示されるHCプロキシ展開のようにファイアウォールの背後に隔離されていると仮定すると、HCプロキシプレーンCoAP（NoSecモード）を使用して、着信HTTPS要求を変換するように構成されてもよいです。"
    },
    {
      "indent": 0,
      "text": "10.4. URI Mapping",
      "section_title": true,
      "ja": "10.4。 URIマッピング"
    },
    {
      "indent": 3,
      "text": "The following risks related to the URI mapping described in Section 5 and its use by an HC Proxy have been identified:",
      "ja": "HCプロキシによって第5及びその使用で説明したURIのマッピングに関連する以下のリスクが確認されています。"
    },
    {
      "indent": 3,
      "text": "DoS attack on the constrained/CoAP network. Mitigation: by default, deny any Target CoAP URI whose authority is (or maps to) a multicast address. Then explicitly whitelist multicast resources/authorities that are allowed to be dereferenced. See also Section 8.4.",
      "ja": "制約/ CoAPネットワーク上のDoS攻撃。緩和：デフォルトでは、権威ある（またはマップへの）マルチキャストアドレスの任意のターゲットCoAP URIを拒否。間接参照することが許可されている続いて、明示的にホワイトリストマルチキャストリソース/当局。また、8.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Leaking information on the constrained/CoAP network resources and topology. Mitigation: by default, deny any Target CoAP URI (especially \"/.well-known/core\" is a resource to be protected), and then explicitly whitelist resources that are allowed to be seen by clients outside the constrained network.",
      "ja": "制約/ CoAPネットワークリソースやトポロジーに関する情報をリーク。緩和：デフォルトでは、すべてのターゲットCoAP URI（特に「/.well-known/coreが」保護されるリソースである）を否定し、拘束されたネットワークの外部のクライアントによって見られることを許可され、その後、明示的にホワイトリストのリソース。"
    },
    {
      "indent": 3,
      "text": "The CoAP target resource is totally transparent from outside the constrained network. Mitigation: implement an HTTPS-only interface, which makes the Target CoAP URI totally opaque to a passive attacker outside the constrained network.",
      "ja": "CoAP対象リソースが制約されたネットワークの外部から完全に透過的です。緩和：制約ネットワークの外部受動攻撃者にターゲットCoAP URIが完全に不透明になりHTTPS専用インタフェースを実装します。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4279] Eronen, P., Ed. and H. Tschofenig, Ed., \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, DOI 10.17487/RFC4279, December 2005, <http://www.rfc-editor.org/info/rfc4279>.",
      "ja": "[RFC4279] Eronen、P.、エド。そして、H. Tschofenig、エド。、 \"事前共有鍵暗号の組み合わせトランスポート層セキュリティ（TLS）のために\"、RFC 4279、DOI 10.17487 / RFC4279、2005年12月、<http://www.rfc-editor.org/info/rfc4279 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6570] Gregorio, J., Fielding, R., Hadley, M., Nottingham, M., and D. Orchard, \"URI Template\", RFC 6570, DOI 10.17487/RFC6570, March 2012, <http://www.rfc-editor.org/info/rfc6570>.",
      "ja": "[RFC6570]グレゴリオ、J.、フィールディング、R.、ハドレー、M.、ノッティンガム、M.、およびD.オーチャード、 \"URIテンプレート\"、RFC 6570、DOI 10.17487 / RFC6570、2012年3月、<のhttp：// WWW .rfc-editor.org /情報/ rfc6570>。"
    },
    {
      "indent": 3,
      "text": "[RFC6690] Shelby, Z., \"Constrained RESTful Environments (CoRE) Link Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012, <http://www.rfc-editor.org/info/rfc6690>.",
      "ja": "[RFC6690]シェルビー、Z.、 \"制約RESTfulな環境（コア）リンク・フォーマット\"、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、<http://www.rfc-editor.org/info/rfc6690>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, DOI 10.17487/RFC7232, June 2014, <http://www.rfc-editor.org/info/rfc7232>.",
      "ja": "[RFC7232]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、DOI 10.17487 / RFC7232、2014年6月、<http://www.rfc-editor.org/info/rfc7232> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7641] Hartke, K., \"Observing Resources in the Constrained Application Protocol (CoAP)\", RFC 7641, DOI 10.17487/RFC7641, September 2015, <http://www.rfc-editor.org/info/rfc7641>.",
      "ja": "[RFC7641] HARTKE、K.、 \"制約アプリケーションプロトコル（CoAP）で観測資源\"、RFC 7641、DOI 10.17487 / RFC7641、2015年9月、<http://www.rfc-editor.org/info/rfc7641>。"
    },
    {
      "indent": 3,
      "text": "[RFC7959] Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in the Constrained Application Protocol (CoAP)\", RFC 7959, DOI 10.17487/RFC7959, August 2016, <http://www.rfc-editor.org/info/rfc7959>.",
      "ja": "[RFC7959]ボルマン、C.およびZ.シェルビー、エド、 \"制約アプリケーションプロトコル（CoAP）でブロックワイズ転送\"、RFC 7959、DOI 10.17487 / RFC7959、2016年8月、<HTTP：//www.rfc- editor.org/info/rfc7959>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CoRE-JSON-CBOR] Li, K., Rahman, A., and C. Bormann, \"Representing CoRE Formats in JSON and CBOR\", Work in Progress, draft-ietf-core-links-json-06, July 2016.",
      "ja": "[コアJSON-CBOR]のLi、K.、ラーマン、A.、およびC.ボルマン、 \"JSONとCBORコアフォーマットを表現\"、プログレス、ドラフトIETFコアリンク-JSON-06、2016年7月に働いて。"
    },
    {
      "indent": 3,
      "text": "[CoRE-RD] Shelby, Z., Koster, M., Bormann, C., and P. Stok, \"CoRE Resource Directory\", Work in Progress, draft-ietf-core-resource-directory-09, October 2016.",
      "ja": "[CORE-RD]シェルビー、Z.、コスター、M.、ボルマン、C.、およびP. STOK、 \"コアリソースディレクトリ\" が進行中で働いて、ドラフト-IETF-コア・リソース・ディレクトリ-09、2016年10月。"
    },
    {
      "indent": 3,
      "text": "[Fielding] Fielding, R., \"Architectural Styles and the Design of Network-based Software Architectures\", PhD Dissertation, University of California, Irvine, ISBN 0-599-87118-0, 2000.",
      "ja": "[フィールディング]フィールディング、R.、「建築スタイルとネットワークベースのソフトウェアアーキテクチャの設計」、博士論文、カリフォルニア大学アーバイン校、ISBN 0-599-87118-0、2000。"
    },
    {
      "indent": 3,
      "text": "[OpenSSL] The OpenSSL Project, , \"ca - sample minimal CA application\", 2000-2016, <https://www.openssl.org/docs/manmaster/man1/ca.html>.",
      "ja": "[OpenSSLの] OpenSSL Projectが、 -  <https://www.openssl.org/docs/manmaster/man1/ca.html>、2000年から2016年 \"CAは、最小限のCAアプリケーションをサンプリング\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, DOI 10.17487/RFC2616, June 1999, <http://www.rfc-editor.org/info/rfc2616>.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、DOI 10.17487 / RFC2616、1999年6月、<http://www.rfc-editor.org/info/rfc2616>。"
    },
    {
      "indent": 3,
      "text": "[RFC2663] Srisuresh, P. and M. Holdrege, \"IP Network Address Translator (NAT) Terminology and Considerations\", RFC 2663, DOI 10.17487/RFC2663, August 1999, <http://www.rfc-editor.org/info/rfc2663>.",
      "ja": "[RFC2663] Srisuresh、P.とM.ホールドレッジ、 \"IPネットワークアドレス変換（NAT）用語と考慮事項\"、RFC 2663、DOI 10.17487 / RFC2663、1999年8月、<http://www.rfc-editor.org/info / RFC2663>。"
    },
    {
      "indent": 3,
      "text": "[RFC3040] Cooper, I., Melve, I., and G. Tomlinson, \"Internet Web Replication and Caching Taxonomy\", RFC 3040, DOI 10.17487/RFC3040, January 2001, <http://www.rfc-editor.org/info/rfc3040>.",
      "ja": "[RFC3040]クーパー、I.、Melve、I.、およびG.トムリンソン、 \"インターネットのWebレプリケーションおよびキャッシング分類学\"、RFC 3040、DOI 10.17487 / RFC3040、2001年1月、<http://www.rfc-editor.org /情報/ rfc3040>。"
    },
    {
      "indent": 3,
      "text": "[RFC4732] Handley, M., Ed., Rescorla, E., Ed., and IAB, \"Internet Denial-of-Service Considerations\", RFC 4732, DOI 10.17487/RFC4732, December 2006, <http://www.rfc-editor.org/info/rfc4732>.",
      "ja": "[RFC4732]ハンドリー、M.、エド、レスコラ、E.、エド、およびIAB、 \"インターネットサービス拒否の注意事項\"、RFC 4732、DOI 10.17487 / RFC4732、2006年12月、<HTTP：// WWW。 rfc-editor.org/info/rfc4732>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", RFC 7049, DOI 10.17487/RFC7049, October 2013, <http://www.rfc-editor.org/info/rfc7049>.",
      "ja": "[RFC7049]ボルマン、C.およびP.ホフマン、 \"コンサイスバイナリオブジェクトの表現（CBOR）\"、RFC 7049、DOI 10.17487 / RFC7049、2013年10月、<http://www.rfc-editor.org/info/rfc7049> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <http://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードのネットワークのための用語\"、RFC 7228、DOI 10.17487 / RFC7228、2014年5月、<http://www.rfc-editor.org /情報/ rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7390] Rahman, A., Ed. and E. Dijk, Ed., \"Group Communication for the Constrained Application Protocol (CoAP)\", RFC 7390, DOI 10.17487/RFC7390, October 2014, <http://www.rfc-editor.org/info/rfc7390>.",
      "ja": "[RFC7390]ラーマン、A.編。そしてE.ダイク、エド。、 \"制約アプリケーションプロトコル（CoAP）のためのグループ通信\"、RFC 7390、DOI 10.17487 / RFC7390、2014年10月、<http://www.rfc-editor.org/info/rfc7390>。"
    },
    {
      "indent": 3,
      "text": "[RFC7925] Tschofenig, H., Ed. and T. Fossati, \"Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things\", RFC 7925, DOI 10.17487/RFC7925, July 2016, <http://www.rfc-editor.org/info/rfc7925>.",
      "ja": "[RFC7925] Tschofenig、H.、エド。そして、T.フォッサーティ、 \"トランスポート層セキュリティ（TLS）/データグラムトランスポート層セキュリティ（DTLS）モノのインターネットのプロファイル\"、RFC 7925、DOI 10.17487 / RFC7925、2016年7月、<のhttp：//www.rfc-editor。組織/情報/ rfc7925>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-html5-20141028] Hickson, I., Berjon, R., Faulkner, S., Leithead, T., Navara, E., O'Connor, E., and S. Pfeiffer, \"HTML5\", World Wide Web Consortium Recommendation REC-html5-20141028, October 2014, <http://www.w3.org/TR/2014/REC-html5-20141028>.",
      "ja": "[W3C.REC-html5-20141028]ヒクソン、I.、ベルジョン、R.、フォークナー、S.、Leithead、T.、ナバラ、E.、オコナー、E.、およびS.ファイファー、 \"HTML5\"、 World Wide Web Consortium（W3C）の勧告REC-html5-20141028、2014年10月、<http://www.w3.org/TR/2014/REC-html5-20141028>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Media Type Mapping Source Code",
      "ja": "付録A.メディアタイプのマッピングソースコード"
    },
    {
      "indent": 0,
      "text": "#!/usr/bin/env python",
      "ja": "＃！は/ usr / binに/ ENVパイソン"
    },
    {
      "indent": 0,
      "text": "import unittest import re",
      "ja": "輸入再unittestのインポート"
    },
    {
      "indent": 0,
      "text": "class CoAPContentFormatRegistry(object): \"\"\"Map an Internet media type (and optional inherent encoding) to a CoAP Content-Format. \"\"\" TEXT_PLAIN = 0 LINK_FORMAT = 40 XML = 41 OCTET_STREAM = 42 EXI = 47 JSON = 50 CBOR = 60 GROUP_JSON = 256",
      "ja": "クラスCoAPContentFormatRegistry（オブジェクト）： \"\" \"CoAPコンテンツ・フォーマットへのインターネットメディアタイプ（および任意の固有の符号化）をマップ \"\"\" TEXT_PLAIN = 0 LINK_FORMAT = 40 XML = 41 OCTET_STREAM = 42 EXI = 47 JSON = 50 CBOR = 60 GROUP_JSON = 256"
    },
    {
      "indent": 0,
      "text": "# http://www.iana.org/assignments/core-parameters # as of 2016/10/24. LOOKUP_TABLE = { (\"text/plain;charset=utf-8\", None): TEXT_PLAIN, (\"application/link-format\", None): LINK_FORMAT, (\"application/xml\", None): XML, (\"application/octet-stream\", None): OCTET_STREAM, (\"application/exi\", None): EXI, (\"application/json\", None): JSON, (\"application/cbor\", None): CBOR, (\"application/coap-group+json\", \"utf-8\"): GROUP_JSON, }",
      "ja": "＃http://www.iana.org/assignments/core-parameters＃2016年10月24日のように。 LOOKUP_TABLE = {（ \"text / plainの;のcharset = UTF-8\"、なし）：TEXT_PLAIN、（ \"アプリケーション/リンクフォーマット\"、なし）：LINK_FORMAT、（ \"アプリケーション/ XML\"、なし）：XML、（「アプリケーション/オクテットストリーム \"なし）：OCTET_STREAM、（ \"アプリケーション/ EXI\"、なし）：EXI、（ \"アプリケーション/ JSON\"、なし）：JSON（ \"アプリケーション/ cbor\"、なし）：CBOR、（\" アプリケーション/ coapグループ+ JSON」、 \"UTF-8\"）：GROUP_JSON、}"
    },
    {
      "indent": 4,
      "text": "def lookup(self, media_type, encoding):\n    \"\"\"Return the CoAP Content-Format matching the supplied\n       media type (and optional encoding), or None if no\n       match can be found.\"\"\"\n    return CoAPContentFormatRegistry.LOOKUP_TABLE.get(\n        (media_type, encoding), None)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "class LooseMediaTypeMapper(object): # Order matters in this table: more specific types have higher rank # compared to less specific types. # This code only performs a shallow validation of acceptable # characters and assumes overall validation of the media type and # subtype has been done beforehand. LOOKUP_TABLE = [ (re.compile(\"application/.+\\+xml$\"), \"application/xml\"), (re.compile(\"application/.+\\+json$\"), \"application/json\"), (re.compile(\"application/.+\\+cbor$\"), \"application/cbor\"), (re.compile(\"text/xml$\"), \"application/xml\"), (re.compile(\"text/[a-z\\.\\-\\+]+$\"), \"text/plain;charset=utf-8\"), (re.compile(\"[a-z]+/[a-z\\.\\-\\+]+$\"), \"application/octet-stream\") ]",
      "ja": "クラスLooseMediaTypeMapper（オブジェクト）：この表の＃注文事項：より具体的な種類が少なく、特定のタイプに比べて高いランク＃を持っています。 ＃このコードは、許容される＃文字の浅い検証を実行し、メディアタイプと＃サブタイプの全体的な検証が予め行われている前提としています。 LOOKUP_TABLE = [（re.compile（ \"アプリケーション/.+\\+のXML $\"）、 \"アプリケーション/ XML\"）、（re.compile（ \"アプリケーション/.+\\+のJSON $\"）、 \"アプリケーション/ JSON\"） 、（re.compile（ \"アプリケーション/.+\\+ cborの$\"）、 \"アプリケーション/ cbor\"）、（re.compile（ \"text / xmlでの$\"）、 \"アプリケーション/ XML\"）、（re.compile（ \"テキスト/ [AZ \\ \\  -  \\ +] + $\"）、 \"text / plainの;のcharset = UTF-8\"）、（re.compile（ \"[AZ] + / [AZ \\ \\  -  \\ +。] + $ \"）、 \"アプリケーション/オクテットストリーム\"）]"
    },
    {
      "indent": 4,
      "text": "def lookup(self, media_type):\n    \"\"\"Return the best loose media type match available using\n       the contents of LOOKUP_TABLE.\"\"\"\n    for entry in LooseMediaTypeMapper.LOOKUP_TABLE:\n        if entry[0].match(media_type) is not None:\n            return entry[1]\n    return None",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def mt2cf(media_type, encoding=None, coap_cf_registry=CoAPContentFormatRegistry(), loose_mapper=None): \"\"\"Return a CoAP Content-Format given an Internet media type and its optional encoding. The current (as of 2016/10/24) \"CoAP Content-Formats\" registry is supplied by default. An optional 'loose-mapping' implementation can be supplied by the caller.\"\"\" assert media_type is not None assert coap_cf_registry is not None",
      "ja": "デフmt2cf（media_typeこの、エンコーディング=なし、coap_cf_registry = CoAPContentFormatRegistry（）、loose_mapper =なし）：「」 \"インターネットメディアタイプとオプションのエンコーディングを指定したCoAPコンテンツ・フォーマットを返し、現在（2016年10月24日現在） 「CoAPのコンテンツフォーマット」レジストリがデフォルトで提供されています。オプションの「ルーズマッピング」実装は、呼び出し側によって供給することができる。「」」media_typeこの主張をなしアサートcoap_cf_registryではありませんNoneでありません"
    },
    {
      "indent": 4,
      "text": "# Lookup the \"CoAP Content-Formats\" registry\ncontent_format = coap_cf_registry.lookup(media_type, encoding)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "# If an exact match is not found and a loose mapper has been # supplied, try to use it to get a media type with which to # retry the \"CoAP Content-Formats\" registry lookup. if content_format is None and loose_mapper is not None: content_format = coap_cf_registry.lookup( loose_mapper.lookup(media_type), encoding)",
      "ja": "＃完全一致が見つからない場合や緩いマッパーは＃供給された、＃に「CoAPコンテンツ・フォーマット」のレジストリ検索を再試行しているとのメディアタイプを得るためにそれを使用するようにしてください。 content_format = coap_cf_registry.lookup（loose_mapper.lookup（media_typeこのオプション）、符号化）：content_formatであればなしとloose_mapperをなしません。"
    },
    {
      "indent": 4,
      "text": "return content_format",
      "ja": "リターンcontent_format"
    },
    {
      "indent": 0,
      "text": "class TestMT2CF(unittest.TestCase):",
      "ja": "クラスTestMT2CF（たunittest.TestCase）："
    },
    {
      "indent": 4,
      "text": "def testMissingContentType(self):\n    with self.assertRaises(AssertionError):\n        mt2cf(None)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "def testMissingContentFormatRegistry(self): with self.assertRaises(AssertionError): mt2cf(None, coap_cf_registry=None)",
      "ja": "デフtestMissingContentFormatRegistry（自己）：self.assertRaises（AssertionErrorが）を持つ：mt2cf（なし、coap_cf_registry =なし）"
    },
    {
      "indent": 4,
      "text": "def testTextPlain(self): self.assertEqual(mt2cf(\"text/plain;charset=utf-8\"), CoAPContentFormatRegistry.TEXT_PLAIN)",
      "ja": "DEF testTextPlain（自己）：self.assertEqual（mt2cf（ \"text / plainの;のcharset = UTF-8\"）、CoAPContentFormatRegistry.TEXT_PLAIN）"
    },
    {
      "indent": 4,
      "text": "def testLinkFormat(self): self.assertEqual(mt2cf(\"application/link-format\"), CoAPContentFormatRegistry.LINK_FORMAT)",
      "ja": "デフtestLinkFormat（自己）：self.assertEqual（mt2cf（ \"アプリケーション/リンク形式\"）、CoAPContentFormatRegistry.LINK_FORMAT）"
    },
    {
      "indent": 4,
      "text": "def testXML(self): self.assertEqual(mt2cf(\"application/xml\"), CoAPContentFormatRegistry.XML)",
      "ja": "デフtestXML（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ XML\"）、CoAPContentFormatRegistry.XML）"
    },
    {
      "indent": 4,
      "text": "def testOctetStream(self): self.assertEqual(mt2cf(\"application/octet-stream\"), CoAPContentFormatRegistry.OCTET_STREAM)",
      "ja": "デフtestOctetStream（自己）：self.assertEqual（mt2cf（ \"アプリケーション/オクテットストリーム\"）、CoAPContentFormatRegistry.OCTET_STREAM）"
    },
    {
      "indent": 4,
      "text": "def testEXI(self): self.assertEqual(mt2cf(\"application/exi\"), CoAPContentFormatRegistry.EXI)",
      "ja": "秒testIXI（自己）：self.assertIkoal（mt2cf（ \"applikation / 6\"）、KoAPKontentFormatRegistry.EXI）"
    },
    {
      "indent": 4,
      "text": "def testJSON(self): self.assertEqual(mt2cf(\"application/json\"), CoAPContentFormatRegistry.JSON)",
      "ja": "デフtestJSON（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ JSON\"）、CoAPContentFormatRegistry.JSON）"
    },
    {
      "indent": 4,
      "text": "def testCBOR(self): self.assertEqual(mt2cf(\"application/cbor\"), CoAPContentFormatRegistry.CBOR)",
      "ja": "デフtestCBOR（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ cbor\"）、CoAPContentFormatRegistry.CBOR）"
    },
    {
      "indent": 4,
      "text": "def testCoAPGroupJSON(self): self.assertEqual(mt2cf(\"application/coap-group+json\", \"utf-8\"), CoAPContentFormatRegistry.GROUP_JSON)",
      "ja": "DEF testCoAPGroupJSON（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ coapグループ+ JSON\"、 \"UTF-8\"）、CoAPContentFormatRegistry.GROUP_JSON）"
    },
    {
      "indent": 4,
      "text": "def testUnknownMediaType(self): self.assertFalse(mt2cf(\"unknown/media-type\"))",
      "ja": "デフtestUnknownMediaType（自己）：self.assertFalse（mt2cf（ \"不明/メディアタイプ\"））"
    },
    {
      "indent": 4,
      "text": "def testLooseXML1(self): self.assertEqual( mt2cf( \"application/somesubtype+xml\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.XML)",
      "ja": "DEF testLooseXML1（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ somesubtype + XML\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.XML）"
    },
    {
      "indent": 4,
      "text": "def testLooseXML2(self): self.assertEqual( mt2cf( \"text/xml\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.XML)",
      "ja": "デフtestLooseXML2（自己）：self.assertEqual（mt2cf（ \"text / xmlで\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.XML）"
    },
    {
      "indent": 4,
      "text": "def testLooseJSON(self): self.assertEqual( mt2cf( \"application/somesubtype+json\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.JSON)",
      "ja": "DEF testLooseJSON（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ somesubtype + JSON\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.JSON）"
    },
    {
      "indent": 4,
      "text": "def testLooseCBOR(self): self.assertEqual( mt2cf( \"application/somesubtype+cbor\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.CBOR)",
      "ja": "DEF testLooseCBOR（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ somesubtype + cbor\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.CBOR）"
    },
    {
      "indent": 4,
      "text": "def testLooseText(self): self.assertEqual( mt2cf( \"text/somesubtype\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.TEXT_PLAIN)",
      "ja": "デフtestLooseText（自己）：self.assertEqual（mt2cf（ \"テキスト/ somesubtype\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.TEXT_PLAIN）"
    },
    {
      "indent": 4,
      "text": "def testLooseUnknown(self): self.assertEqual( mt2cf( \"application/somesubtype-of-some-sort+format\", loose_mapper=LooseMediaTypeMapper()), CoAPContentFormatRegistry.OCTET_STREAM)",
      "ja": "DEF testLooseUnknown（自己）：self.assertEqual（mt2cf（ \"アプリケーション/ somesubtypeオブ一部ソート+フォーマット\"、loose_mapper = LooseMediaTypeMapper（））、CoAPContentFormatRegistry.OCTET_STREAM）"
    },
    {
      "indent": 4,
      "text": "def testLooseInvalidStartsWithNonAlpha(self): self.assertFalse( mt2cf( \" application/somesubtype\", loose_mapper=LooseMediaTypeMapper()))",
      "ja": "DEF testLooseInvalidStartsWithNonAlpha（自己）：self.assertFalse（mt2cf（ \"アプリケーション/ somesubtype\"、loose_mapper = LooseMediaTypeMapper（）））"
    },
    {
      "indent": 4,
      "text": "def testLooseInvalidEndsWithUnexpectedChar(self): self.assertFalse( mt2cf( \"application/somesubtype \", loose_mapper=LooseMediaTypeMapper()))",
      "ja": "DEF testLooseInvalidEndsWithUnexpectedChar（自己）：self.assertFalse（mt2cf（ \"アプリケーション/ somesubtype\"、loose_mapper = LooseMediaTypeMapper（）））"
    },
    {
      "indent": 4,
      "text": "def testLooseInvalidUnexpectedCharInTheMiddle(self): self.assertFalse( mt2cf( \"application /somesubtype\", loose_mapper=LooseMediaTypeMapper()))",
      "ja": "DEF testLooseInvalidUnexpectedCharInTheMiddle（自己）：self.assertFalse（mt2cf（ \"アプリケーション/ somesubtype\"、loose_mapper = LooseMediaTypeMapper（）））"
    },
    {
      "indent": 4,
      "text": "def testLooseInvalidNoSubType1(self): self.assertFalse( mt2cf( \"application\", loose_mapper=LooseMediaTypeMapper()))",
      "ja": "デフtestLooseInvalidNoSubType1（自己）：self.assertFalse（mt2cf（ \"アプリケーション\"、loose_mapper = LooseMediaTypeMapper（）））"
    },
    {
      "indent": 4,
      "text": "def testLooseInvalidNoSubType2(self): self.assertFalse( mt2cf( \"application/\", loose_mapper=LooseMediaTypeMapper()))",
      "ja": "DEF testLooseInvalidNoSubType2（自己）：self.assertFalse（mt2cf（ \"アプリケーション/\"、loose_mapper = LooseMediaTypeMapper（）））"
    },
    {
      "indent": 0,
      "text": "if __name__ == \"__main__\": unittest.main(verbosity=2)",
      "ja": "もし__name__ == \"__main__\"：unittest.main（冗長= 2）"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "An initial version of Table 2 in Section 7 has been provided in revision -05 of the CoRE CoAP I-D. Special thanks to Peter van der Stok for countless comments and discussions on this document that contributed to its current structure and text.",
      "ja": "第7表2の最初のバージョンは、コアCoAP I-Dの改正-05に提供されています。その現在の構造とテキストに貢献し、この文書に無数のコメントや議論のためのピーター・ファン・デル・STOKに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Abhijan Bhattacharyya, Alexey Melnikov, Brian Frank, Carsten Bormann, Christian Amsuess, Christian Groves, Cullen Jennings, Dorothy Gellert, Francesco Corazza, Francis Dupont, Hannes Tschofenig, Jaime Jimenez, Kathleen Moriarty, Kepeng Li, Kerry Lynn, Klaus Hartke, Larry Masinter, Linyi Tian, Michele Rossi, Michele Zorzi, Nicola Bui, Peter Saint-Andre, Sean Leonard, Spencer Dawkins, Stephen Farrell, Suresh Krishnan, and Zach Shelby for helpful comments and discussions that have shaped the document.",
      "ja": "Abhijanバッタチャリヤ、アレクセイ・メルニコフ、ブライアン・フランク、カルステンボルマン、クリスチャンAmsuess、クリスチャン・グローブス、カレン・ジェニングス、ドロシーゲラート、フランチェスコCorazza、フランシスデュポン、ハンネスTschofenig、ハイメ・ヒメネス、キャスリーン・モリアーティ、Kepengリー、ケリー・リン、クラウスHARTKEのおかげで、有益なコメントや文書を形作ってきた議論のためのラリーMasinter、臨沂天、ミケーレ・ロッシ、ミシェルZORZI、ニコラ・ブイ、ピーター・サン・アンドレ、ショーン・レナ​​ード、スペンサードーキンス、スティーブン・ファレル、スレシュクリシュナン、そしてザックシェルビー。"
    },
    {
      "indent": 3,
      "text": "The research leading to these results has received funding from the European Community's Seventh Framework Programme [FP7/2007-2013] under grant agreement n.251557.",
      "ja": "これらの結果につながる研究は、助成金の契約n.251557下欧州共同体のセブンスフレームワークプログラム[FP7 / 2007から2013]から資金提供を受けています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Angelo P. Castellani University of Padova Via Gradenigo 6/B Padova 35131 Italy",
      "ja": "アンジェロP.カステラーニ大学パドヴァの経由Gradenigo 6 / B 35131パドヴァイタリア"
    },
    {
      "indent": 3,
      "text": "Email: angelo@castellani.net",
      "ja": "メール：angelo@castellani.net"
    },
    {
      "indent": 3,
      "text": "Salvatore Loreto Ericsson Hirsalantie 11 Jorvas 02420 Finland",
      "ja": "サルヴァトーレ・ロレートエリクソンHirsalantie 11 Jorvas 02420フィンランド"
    },
    {
      "indent": 3,
      "text": "Email: salvatore.loreto@ericsson.com",
      "ja": "メール：salvatore.loreto@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Akbar Rahman InterDigital Communications, LLC 1000 Sherbrooke Street West Montreal H3A 3G4 Canada",
      "ja": "アクバル・ラーマンインターデジタルコミュニケーションズ、LLC 1000年シャーブルックストリートウェスト・モントリオールH3A 3G4カナダ"
    },
    {
      "indent": 3,
      "text": "Phone: +1 514 585 0761 Email: Akbar.Rahman@InterDigital.com",
      "ja": "電話：+1 514 585 0761 Eメール：Akbar.Rahman@InterDigital.com"
    },
    {
      "indent": 3,
      "text": "Thomas Fossati Nokia 3 Ely Road Milton, Cambridge CB24 6DD United Kingdom",
      "ja": "トーマス・フォッサーティノキア3エリー道路ミルトン、ケンブリッジCB24 6DDイギリス"
    },
    {
      "indent": 3,
      "text": "Email: thomas.fossati@nokia.com",
      "ja": "メール：thomas.fossati@nokia.com"
    },
    {
      "indent": 3,
      "text": "Esko Dijk Philips Lighting High Tech Campus 7 Eindhoven 5656 AE The Netherlands",
      "ja": "エスコダイクフィリップスライティングハイテクキャンパス7アイントホーフェン5656 AEオランダ"
    },
    {
      "indent": 3,
      "text": "Email: esko.dijk@philips.com",
      "ja": "メール：esko.dijk@philips.com"
    }
  ]
}