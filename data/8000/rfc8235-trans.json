{
  "title": {
    "text": "RFC 8235 - Schnorr Non-interactive Zero-Knowledge Proof",
    "ja": "RFC 8235 - シュ非対話ゼロ知識証明"
  },
  "number": 8235,
  "created_at": "2019-10-27 06:55:16.106192+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                       F. Hao, Ed.\nRequest for Comments: 8235                     Newcastle University (UK)\nCategory: Informational                                   September 2017\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Schnorr Non-interactive Zero-Knowledge Proof",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the Schnorr non-interactive zero-knowledge (NIZK) proof, a non-interactive variant of the three-pass Schnorr identification scheme. The Schnorr NIZK proof allows one to prove the knowledge of a discrete logarithm without leaking any information about its value. It can serve as a useful building block for many cryptographic protocols to ensure that participants follow the protocol specification honestly. This document specifies the Schnorr NIZK proof in both the finite field and the elliptic curve settings.",
      "ja": "この文書は、シュノール非対話型ゼロ知識（NIZK）証明、三パスシュノール識別方式の非対話型変異体を記載しています。シュノールNIZK証拠は1つが、その値に関する情報を漏洩することなく、離散対数の知識を証明することを可能にします。これは、参加者が正直プロトコル仕様に従うことを確実にするために、多くの暗号化プロトコルのための便利なビルディングブロックとしての役割を果たすことができます。この文書では、有限体の両方でシュノールNIZKの証拠と楕円曲線の設定を指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8235.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8235で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3\n  1.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Schnorr NIZK Proof over Finite Field  . . . . . . . . . . . .   4\n  2.1.  Group Parameters  . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  Schnorr Identification Scheme . . . . . . . . . . . . . .   4\n  2.3.  Non-interactive Zero-Knowledge Proof  . . . . . . . . . .   5\n  2.4.  Computation Cost  . . . . . . . . . . . . . . . . . . . .   6\n3.  Schnorr NIZK Proof over Elliptic Curve  . . . . . . . . . . .   6\n  3.1.  Group Parameters  . . . . . . . . . . . . . . . . . . . .   6\n  3.2.  Schnorr Identification Scheme . . . . . . . . . . . . . .   7\n  3.3.  Non-interactive Zero-Knowledge Proof  . . . . . . . . . .   8\n  3.4.  Computation Cost  . . . . . . . . . . . . . . . . . . . .   8\n4.  Variants of Schnorr NIZK proof  . . . . . . . . . . . . . . .   9\n5.  Applications of Schnorr NIZK proof  . . . . . . . . . . . . .   9\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  10\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  11\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  12\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  13\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  13",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A well-known principle for designing robust public key protocols is as follows: \"Do not assume that a message you receive has a particular form (such as g^r for known r) unless you can check this\" [AN95]. This is the sixth of the eight principles defined by Ross Anderson and Roger Needham at Crypto '95. Hence, it is also known as the \"sixth principle\". In the past thirty years, many public key protocols failed to prevent attacks, which can be explained by the violation of this principle [Hao10].",
      "ja": "「あなたが受け取るメッセージは、特定の形式を持っていることを前提としないでくださいあなたはこれをチェックすることができない限り、（そのような既知のR用G ^ Rなど）」[AN95]：堅牢な公開鍵プロトコルを設計するためのよく知られた原理は以下のとおりです。これは、暗号'95にロスアンダーソン、ロジャーニーダムによって定義された8つの原則の第六です。したがって、それはまた「第六の原理」として知られています。過去30年間で、多くの公開鍵プロトコルは、この原則[Hao10]の違反によって説明できるの攻撃を防ぐことができませんでした。"
    },
    {
      "indent": 3,
      "text": "While there may be several ways to satisfy the sixth principle, this document describes one technique that allows one to prove the knowledge of a discrete logarithm (e.g., r for g^r) without revealing its value. This technique is called the Schnorr NIZK proof, which is a non-interactive variant of the three-pass Schnorr identification scheme [Stinson06]. The original Schnorr identification scheme is made non-interactive through a Fiat-Shamir transformation [FS86], assuming that there exists a secure cryptographic hash function (i.e., the so-called random oracle model).",
      "ja": "第六の原理を満足するいくつかの方法があるかもしれないが、このドキュメントは1つが、その値を明らかにすることなく離散対数（例えば、G ^ Rに対するR）の知識を証明することを可能にする一つの技術が記載されています。この技術は、三パスシュノール識別スキーム[Stinson06]の非対話型変異体であるシュノールNIZKプルーフと呼ばれます。オリジナルシュノール識別方式は安全な暗号ハッシュ関数（すなわち、いわゆるランダムオラクルモデル）が存在すると仮定すると、[FS86]フィアット - シャミール変換によって非インタラクティブなります。"
    },
    {
      "indent": 3,
      "text": "The Schnorr NIZK proof can be implemented over a finite field or an elliptic curve (EC). The technical specification is basically the same, except that the underlying cyclic group is different. For completeness, this document describes the Schnorr NIZK proof in both the finite field and the EC settings.",
      "ja": "シュノールNIZK証拠は有限体、楕円曲線（EC）上に実装することができます。技術仕様は、基礎となる環状基が異なることを除いて、基本的に同じです。完全を期すため、このドキュメントは、有限体とECの両方の設定でシュノールNIZKの証拠を示しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Notation",
      "section_title": true,
      "ja": "1.2. 表記法"
    },
    {
      "indent": 3,
      "text": "The following notation is used in this document:",
      "ja": "以下の表記は、このドキュメントで使用されます。"
    },
    {
      "indent": 3,
      "text": "o Alice: the assumed identity of the prover in the protocol",
      "ja": "Oアリス：プロトコルでの証明の前提とアイデンティティ"
    },
    {
      "indent": 3,
      "text": "o Bob: the assumed identity of the verifier in the protocol",
      "ja": "Oボブ：プロトコルにおける検証の仮定アイデンティティ"
    },
    {
      "indent": 3,
      "text": "o a | b: a divides b",
      "ja": "O | B：AはBを分割します"
    },
    {
      "indent": 3,
      "text": "o a || b: concatenation of a and b",
      "ja": "O || B：aとbの連結"
    },
    {
      "indent": 3,
      "text": "o [a, b]: the interval of integers between and including a and b",
      "ja": "O [A、B]とを含むとBとの間の整数の間隔"
    },
    {
      "indent": 3,
      "text": "o t: the bit length of the challenge chosen by Bob",
      "ja": "O T：ボブによって選択されたチャレンジのビット長"
    },
    {
      "indent": 3,
      "text": "o H: a secure cryptographic hash function",
      "ja": "O H：セキュアな暗号学的ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "o p: a large prime",
      "ja": "OのP：大きな素数"
    },
    {
      "indent": 3,
      "text": "o q: a large prime divisor of p-1, i.e., q | p-1",
      "ja": "O Q：P-1の大きな素数除数、すなわち、Q | P-1"
    },
    {
      "indent": 3,
      "text": "o Zp*: a multiplicative group of integers modulo p",
      "ja": "Zpの* O：整数の乗法群は、pを法"
    },
    {
      "indent": 3,
      "text": "o Gq: a subgroup of Zp* with prime order q",
      "ja": "OのGq：プライム次数qとのZp *のサブグループ"
    },
    {
      "indent": 3,
      "text": "o g: a generator of Gq",
      "ja": "O G：のGqの発生を"
    },
    {
      "indent": 3,
      "text": "o g^d: g raised to the power of d",
      "ja": "O G ^ D：G D乗"
    },
    {
      "indent": 3,
      "text": "o a mod b: a modulo b",
      "ja": "モジュロB：MOD B O"
    },
    {
      "indent": 3,
      "text": "o Fp: a finite field of p elements, where p is a prime o E(Fp): an elliptic curve defined over Fp",
      "ja": "O FP：p要素の有限体、pは素数入出力E（FP）である：Fpの上に定義された楕円曲線"
    },
    {
      "indent": 3,
      "text": "o G: a generator of the subgroup over E(Fp) with prime order n",
      "ja": "O G：プライム次数nを有するE上のサブグループのジェネレータ（FP）"
    },
    {
      "indent": 3,
      "text": "o n: the order of G",
      "ja": "O N：Gの順序"
    },
    {
      "indent": 3,
      "text": "o h: the cofactor of the subgroup generated by G, which is equal to the order of the elliptic curve divided by n",
      "ja": "OのH：nで割った楕円曲線の次数に等しいGによって生成されたサブグループの補因子"
    },
    {
      "indent": 3,
      "text": "o P x [b]: multiplication of a point P with a scalar b over E(Fp)",
      "ja": "O P X [B]：E上スカラBと点Pの乗算（FP）"
    },
    {
      "indent": 0,
      "text": "2. Schnorr NIZK Proof over Finite Field",
      "section_title": true,
      "ja": "有限体上の2シュNIZK証明"
    },
    {
      "indent": 0,
      "text": "2.1. Group Parameters",
      "section_title": true,
      "ja": "2.1. グループのパラメータ"
    },
    {
      "indent": 3,
      "text": "When implemented over a finite field, the Schnorr NIZK proof may use the same group setting as DSA [FIPS186-4]. Let p and q be two large primes with q | p-1. Let Gq denote the subgroup of Zp* of prime order q, and g be a generator for the subgroup. Refer to the DSA examples in the NIST Cryptographic Toolkit [NIST_DSA] for values of (p, q, g) that provide different security levels. A level of 128-bit security or above is recommended. Here, DSA groups are used only as an example. Other multiplicative groups where the discrete logarithm problem (DLP) is intractable are also suitable for the implementation of the Schnorr NIZK proof.",
      "ja": "有限体上に実装される場合、シュノールNIZK証拠はDSA [FIPS186-4]と同じグループ設定を使用することができます。 pとqをqを持つ2つの大きな素数とします| P-1。 Gqのはプライム次数qのZpの*の部分群を示すものとし、Gはサブグループの発電可能。異なるセキュリティレベルを提供する（P、Q、G）の値に対するNIST暗号化ツールキットでDSA例[NIST_DSA]を参照。上記128ビットのセキュリティまたはレベルが推奨されます。ここでは、DSAグループは、例としてのみ使用されます。離散対数問題（DLP）は難治性である他の乗法グループもシュノールNIZK証明の実装に適しています。"
    },
    {
      "indent": 0,
      "text": "2.2. Schnorr Identification Scheme",
      "section_title": true,
      "ja": "2.2. シュノールの識別スキーム"
    },
    {
      "indent": 3,
      "text": "The Schnorr identification scheme runs interactively between Alice (prover) and Bob (verifier). In the setup of the scheme, Alice publishes her public key A = g^a mod p, where a is the private key chosen uniformly at random from [0, q-1].",
      "ja": "シュノール識別スキームは、アリス（証明）とボブ（検証者）との間で対話的に実行されます。スキームの設定では、アリスは[0、Q-1]からランダムに一様に選択された秘密鍵であり、彼女の公開鍵A = G ^ MOD pは、パブリッシュ。"
    },
    {
      "indent": 3,
      "text": "The protocol works in three passes:",
      "ja": "プロトコルは、3つのパスで動作します。"
    },
    {
      "indent": 3,
      "text": "1. Alice chooses a number v uniformly at random from [0, q-1] and computes V = g^v mod p. She sends V to Bob.",
      "ja": "1.アリスは[0、Q-1]からランダムに一様に数Vを選択し、V = G ^のV MOD pを計算します。彼女はボブにVを送信します。"
    },
    {
      "indent": 3,
      "text": "2. Bob chooses a challenge c uniformly at random from [0, 2^t-1], where t is the bit length of the challenge (say, t = 160). Bob sends c to Alice.",
      "ja": "2.ボブは、tは、チャレンジのビット長である[0、2 ^ T-1]、（たとえば、Tは= 160）からランダムに一様にチャレンジCを選択します。ボブはアリスにCを送信します。"
    },
    {
      "indent": 3,
      "text": "3. Alice computes r = v - a * c mod q and sends it to Bob.",
      "section_title": true,
      "ja": "3.アリスは、R = V計算 -  *のC MOD Qをボブに送ります。"
    },
    {
      "indent": 3,
      "text": "At the end of the protocol, Bob performs the following checks. If any check fails, the identification is unsuccessful.",
      "ja": "プロトコルの最後に、ボブは以下のチェックを行います。いずれかのチェックが失敗した場合、識別は失敗します。"
    },
    {
      "indent": 3,
      "text": "1. To verify A is within [1, p-1] and A^q = 1 mod p;",
      "section_title": true,
      "ja": "1. A [1、P-1]、A ^ q = 1つのでMOD P内にあることを確認します。"
    },
    {
      "indent": 3,
      "text": "2. To verify V = g^r * A^c mod p.",
      "section_title": true,
      "ja": "V = G ^ R * A ^ C MOD Pを検証する2。"
    },
    {
      "indent": 3,
      "text": "The first check ensures that A is a valid public key, hence the discrete logarithm of A with respect to the base g actually exists. It is worth noting that some applications may specifically exclude the identity element as a valid public key. In that case, one shall check A is within [2, p-1] instead of [1, p-1].",
      "ja": "最初のチェックは、従って底gに対するAの離散対数が実際に存在する、Aが有効な公開鍵であることを保証します。これは、いくつかのアプリケーションは、特に有効な公開鍵としてのアイデンティティの要素を除外してもよいことは注目に値します。その場合、一方がチェックしなければならないAが範囲内である[2、P-1]の代わりに[1、P-1]。"
    },
    {
      "indent": 3,
      "text": "The process is summarized in the following diagram.",
      "ja": "プロセスは、以下の図に要約されています。"
    },
    {
      "indent": 9,
      "text": " Alice                               Bob\n-------                             -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "choose random v from [0, q-1]",
      "ja": "[0、Q-1]からランダムにVを選択"
    },
    {
      "indent": 3,
      "text": "compute V = g^v mod p -- V ->",
      "ja": "モードnのコンピュータF = R  -  B  - >"
    },
    {
      "indent": 3,
      "text": "compute r = v-a*c mod q <- c -- choose random c from [0, 2^t-1]",
      "ja": "計算はR = V-A * C MOD Q < -  cは - からランダムCを選択し、[0、2 ^ T-1]"
    },
    {
      "indent": 28,
      "text": "-- b -> check 1) A is a valid public key\n              2) V = g^r * A^c mod p",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Information Flows in Schnorr Identification Scheme over Finite Field",
      "ja": "情報は、有限体上のシュ識別スキームに流れます"
    },
    {
      "indent": 0,
      "text": "2.3. Non-interactive Zero-Knowledge Proof",
      "section_title": true,
      "ja": "2.3. 非対話零知識証明"
    },
    {
      "indent": 3,
      "text": "The Schnorr NIZK proof is obtained from the interactive Schnorr identification scheme through a Fiat-Shamir transformation [FS86]. This transformation involves using a secure cryptographic hash function to issue the challenge instead. More specifically, the challenge is redefined as c = H(g || V || A || UserID || OtherInfo), where UserID is a unique identifier for the prover and OtherInfo is OPTIONAL data. Here, the hash function H SHALL be a secure cryptographic hash function, e.g., SHA-256, SHA-384, SHA-512, SHA3-256, SHA3-384, or SHA3-512. The bit length of the hash output should be at least equal to that of the order q of the considered subgroup.",
      "ja": "シュノールNIZKプルーフはフィアット - シャミール変換[FS86]を介して対話シュノール識別スキームから得られます。この変換ではなく挑戦を発行するために、安全な暗号ハッシュ関数を使用することを含みます。より具体的には、チャレンジは、C = H（G || V || ||ユーザID || OtherInfo）、ユーザIDは、証明者の一意の識別子であり、OtherInfoは任意のデータであるとして再定義されます。ここで、ハッシュ関数Hは、安全な暗号ハッシュ関数、例えば、SHA-256、SHA-384、SHA-512、SHA3-256、SHA3-384、又はSHA3-512でなければなりません。ハッシュ出力のビット長は、考慮サブグループの数qと少なくとも等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "OtherInfo is defined to allow flexible inclusion of contextual information (also known as \"labels\" in [ABM15]) in the Schnorr NIZK proof so that the technique defined in this document can be generally useful. For example, some security protocols built on top of the Schnorr NIZK proof may wish to include more contextual information such as the protocol name, timestamp, and so on. The exact items (if any) in OtherInfo shall be left to specific protocols to define. However, the format of OtherInfo in any specific protocol must be fixed and explicitly defined in the protocol specification.",
      "ja": "OtherInfoは本書で定義された技術は、一般的に有用であることができるようにシュノールNIZKプルーフで（も[ABM15]における「標識」としても知られる）コンテキスト情報の柔軟な包含を可能にするように定義されています。例えば、シュノールNIZKプルーフの上に​​構築されたいくつかのセキュリティプロトコルは、このようなようにプロトコル名、タイムスタンプ、および、より多くのコンテキスト情報を含めることを望むかもしれません。 OtherInfoの正確な項目は（もしあれば）を定義する特定のプロトコルに委ねなければなりません。しかし、任意の特定のプロトコルにおけるOtherInfoのフォーマットは、固定されなければならないと明示的プロトコル仕様で定義されています。"
    },
    {
      "indent": 3,
      "text": "Within the hash function, there must be a clear boundary between any two concatenated items. It is RECOMMENDED that one should always prepend each item with a 4-byte integer that represents the byte length of that item. OtherInfo may contain multiple subitems. In that case, the same rule shall apply to ensure a clear boundary between adjacent subitems.",
      "ja": "ハッシュ関数内で、任意の二つの連結されたアイテムとの間に明確な境界が存在しなければなりません。 1つは、常にそのアイテムのバイト長を示す4バイトの整数で各項目を付加することが推奨されます。 OtherInfoは、複数のサブ項目が含まれていてもよいです。その場合、同じ規則は、隣接するサブアイテムの間に明確な境界を確実にするために適用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4. Computation Cost",
      "section_title": true,
      "ja": "2.4. 計算コスト"
    },
    {
      "indent": 3,
      "text": "In summary, to prove the knowledge of the exponent for A = g^a, Alice generates a Schnorr NIZK proof that contains: {UserID, OtherInfo, V = g^v mod p, r = v - a*c mod q}, where c = H(g || V || A || UserID || OtherInfo).",
      "ja": "、 -  {*のC MOD QユーザID、OtherInfo、V = G ^ V MOD P、R = V}：要約すると、A = G ^ Aの指数の知識を証明するために、アリスは含まシュノールNIZKプルーフを生成しますここで、c = H（V || A ||ユーザID || OtherInfo || g）を得ました。"
    },
    {
      "indent": 3,
      "text": "To generate a Schnorr NIZK proof, the cost is roughly one modular exponentiation: that is to compute g^v mod p. In practice, this exponentiation may be precomputed in the offline manner to optimize efficiency. The cost of the remaining operations (random number generation, modular multiplication, and hashing) is negligible as compared with the modular exponentiation.",
      "ja": "^ V MODのpグラムを計算することである：シュNIZK証明を生成するには、費用は約1べき乗剰余演算です。実際には、このべき乗は、効率を最適化するために、オフラインで予め計算されてもよいです。べき乗剰余と比較して、残りの動作（乱数発生、モジュラ乗算、およびハッシュ）のコストは無視できます。"
    },
    {
      "indent": 3,
      "text": "To verify the Schnorr NIZK proof, the cost is approximately two exponentiations: one for computing A^q mod p and the other for computing g^r * A^c mod p. (It takes roughly one exponentiation to compute the latter using a simultaneous exponentiation technique as described in [MOV96].)",
      "ja": "^ R * A ^ C MOD P Gを計算するためにA ^ Q MOD pおよび他を計算するための1つ：シュノールNIZKの証拠を確認するために、コストは約2累乗です。 （これは、[MOV96]に記載されているように同時べき乗法を用いて後者を計算するために約1つのべき乗をとります。）"
    },
    {
      "indent": 0,
      "text": "3. Schnorr NIZK Proof over Elliptic Curve",
      "section_title": true,
      "ja": "楕円曲線の上に3シュNIZK証明"
    },
    {
      "indent": 0,
      "text": "3.1. Group Parameters",
      "section_title": true,
      "ja": "3.1. グループのパラメータ"
    },
    {
      "indent": 3,
      "text": "When implemented over an elliptic curve, the Schnorr NIZK proof may use the same EC setting as ECDSA [FIPS186-4]. For the illustration purpose, only curves over the prime fields (e.g., NIST P-256) are described here. Other curves over the binary fields (see [FIPS186-4]) that are suitable for ECDSA can also be used for implementing the Schnorr NIZK proof. Let E(Fp) be an elliptic curve defined over a finite field Fp, where p is a large prime. Let G be a base point on the curve that serves as a generator for the subgroup over E(Fp) of prime order n. The cofactor of the subgroup is denoted h, which is usually a small value (not more than 4). Details on EC operations, such as addition, negation and scalar multiplications, can be found in [MOV96]. Data types and conversions including",
      "ja": "楕円曲線上に実装される場合、シュノールNIZK証拠はECDSA [FIPS186-4]と同じEC設定を使用してもよいです。例示の目的のために、プライムフィールド（例えば、NIST P-256）上のみ曲線がここに記載されています。 ECDSAのに適しているバイナリフィールド上の他の曲線は、（[FIPS186-4]を参照）も、シュノールNIZK証明を実現するために使用することができます。 E（FP）は、pは大きな素数である有限体Fpは、上に定義された楕円曲線とします。 Gが素数次数nのE上のサブグループ（FP）のための発電機として機能する曲線上のベースポイントとします。サブグループの補因子は、通常は小さな値（4以下）である時間を、示されています。そのような添加、否定及びスカラー乗算としてEC操作の詳細は、[MOV96]に見出すことができます。含むデータ型との変換"
    },
    {
      "indent": 3,
      "text": "elliptic-curve-point-to-octet-string and vice versa can be found in Section 2.3 of [SEC1]. Here, the NIST curves are used only as an example. Other secure curves such as Curve25519 are also suitable for the implementation as long as the elliptic curve discrete logarithm problem (ECDLP) remains intractable.",
      "ja": "楕円曲線ポイント・ツー・オクテットストリングおよびその逆は[SEC1]の2.3節に見出すことができます。ここで、NIST曲線は、例としてのみ使用されています。例えばCurve25519のような他の安全な曲線であれば、楕円曲線上の離散対数問題（ECDLP）は難治性のままとしても実装するのに適しています。"
    },
    {
      "indent": 0,
      "text": "3.2. Schnorr Identification Scheme",
      "section_title": true,
      "ja": "3.2. シュノールの識別スキーム"
    },
    {
      "indent": 3,
      "text": "In the setup of the scheme, Alice publishes her public key A = G x [a], where a is the private key chosen uniformly at random from [1, n-1].",
      "ja": "ランダムに一様に選択された秘密鍵である[1、N-1]ここでスキームの設定では、アリスは、[A]は彼女の公開鍵A = G xをパブリッシュ。"
    },
    {
      "indent": 3,
      "text": "The protocol works in three passes:",
      "ja": "プロトコルは、3つのパスで動作します。"
    },
    {
      "indent": 3,
      "text": "1. Alice chooses a number v uniformly at random from [1, n-1] and computes V = G x [v]. She sends V to Bob.",
      "ja": "1.アリスは[1、N-1]からランダムに均一V番号を選択し、V = GのX [V]を算出します。彼女はボブにVを送信します。"
    },
    {
      "indent": 3,
      "text": "2. Bob chooses a challenge c uniformly at random from [0, 2^t-1], where t is the bit length of the challenge (say, t = 80). Bob sends c to Alice.",
      "ja": "2.ボブは、tは、チャレンジのビット長である[0、2 ^ T-1]、（たとえば、Tは= 80）からランダムに一様にチャレンジCを選択します。ボブはアリスにCを送信します。"
    },
    {
      "indent": 3,
      "text": "3. Alice computes r = v - a * c mod n and sends it to Bob.",
      "section_title": true,
      "ja": "3.アリスは、R = V計算 -  *のC mod nををボブに送ります。"
    },
    {
      "indent": 3,
      "text": "At the end of the protocol, Bob performs the following checks. If any check fails, the verification is unsuccessful.",
      "ja": "プロトコルの最後に、ボブは以下のチェックを行います。いずれかのチェックが失敗した場合、検証は失敗します。"
    },
    {
      "indent": 3,
      "text": "1. To verify A is a valid point on the curve and A x [h] is not the point at infinity;",
      "ja": "Aを確認する1.曲線上有効なポイントであり、x [H]は無限遠点ではありません。"
    },
    {
      "indent": 3,
      "text": "2. To verify V = G x [r] + A x [c].",
      "section_title": true,
      "ja": "V = G Xの[R] + A X [C]を検証する2。"
    },
    {
      "indent": 3,
      "text": "The first check ensures that A is a valid public key, hence the discrete logarithm of A with respect to the base G actually exists. Unlike in the DSA-like group setting where a full modular exponentiation is required to validate a public key, in the ECDSA-like setting, the public key validation incurs almost negligible cost due to the cofactor being small (e.g., 1, 2, or 4).",
      "ja": "最初のチェックは、Aが有効な公開鍵、Gが実際に存在する塩基に対するAの従って離散対数であることを保証します。完全べき乗剰余がECDSAのような設定では、公開鍵を検証するために必要とされるDSA-ようなグループ設定では、公開鍵の検証が原因補因子にほとんど無視できるコストを招くとは異なりある小さな（例えば、1、2、または4）。"
    },
    {
      "indent": 3,
      "text": "The process is summarized in the following diagram.",
      "ja": "プロセスは、以下の図に要約されています。"
    },
    {
      "indent": 3,
      "text": "Alice                               Bob\n-------                             -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "choose random v from [1, n-1]",
      "ja": "[1、N-1]からランダムにVを選択"
    },
    {
      "indent": 3,
      "text": "compute V = G x [v] -- V ->",
      "ja": "コンピュータF = F X yuvsch  - で - >"
    },
    {
      "indent": 3,
      "text": "compute r = v - a * c mod n <- c -- choose random c from [0, 2^t-1]",
      "ja": "計算R = V  -  *のC mod nを< -  C  -  [0 ^ T-1 2]からランダムにCを選択"
    },
    {
      "indent": 32,
      "text": "-- b -> check 1) A is a valid public key\n              2) V = G x [r] + A x [c]",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Information Flows in Schnorr Identification Scheme over Elliptic Curve",
      "ja": "情報は、楕円曲線上のシュ識別スキームに流れます"
    },
    {
      "indent": 0,
      "text": "3.3. Non-interactive Zero-Knowledge Proof",
      "section_title": true,
      "ja": "3.3. 非対話零知識証明"
    },
    {
      "indent": 3,
      "text": "Same as before, the non-interactive variant is obtained through a Fiat-Shamir transformation [FS86], by using a secure cryptographic hash function to issue the challenge instead. The challenge c is defined as c = H(G || V || A || UserID || OtherInfo), where UserID is a unique identifier for the prover and OtherInfo is OPTIONAL data as explained earlier.",
      "ja": "前と同様、非対話型の変異体ではなく、チャレンジを発行するために安全な暗号ハッシュ関数を用いて、フィアット - シャミール変換[FS86]によって得られます。チャレンジCは、ユーザIDが証明者の一意の識別子であり、上述したようOtherInfoが任意のデータであり、C = H（G || V || A ||ユーザID || OtherInfo）として定義されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Computation Cost",
      "section_title": true,
      "ja": "3.4. 計算コスト"
    },
    {
      "indent": 3,
      "text": "In summary, to prove the knowledge of the discrete logarithm for A = G x [a] with respect to base G over the elliptic curve, Alice generates a Schnorr NIZK proof that contains: {UserID, OtherInfo, V = G x [v], r = v - a*c mod n}, where c = H(G || V || A || UserID || OtherInfo).",
      "ja": "要約すると、A = G xの離散対数の知識を証明するために、[A]は、楕円曲線上にGをベースに対して、アリスが含まシュノールNIZKプルーフ生成：{ユーザID、OtherInfo、V = G xを[V] 、R = V  -  *のC mod nを}、C = H（G || V || A ||ユーザID || OtherInfo）。"
    },
    {
      "indent": 3,
      "text": "To generate a Schnorr NIZK proof, the cost is one scalar multiplication: that is to compute G x [v].",
      "ja": "GのX [V]を計算することである：シュノールNIZK証明を生成するために、コストは、一つのスカラー乗算です。"
    },
    {
      "indent": 3,
      "text": "To verify the Schnorr NIZK proof in the EC setting, the cost is approximately one multiplication over the elliptic curve: i.e., computing G x [r] + A x [c] (using the same simultaneous computation technique as before). The cost of public key validation in the EC setting is essentially free.",
      "ja": "[C]（以前と同じ同時計算手法を用いて）、すなわち、コンピューティング・G Xの[R] + X：EC設定でシュノールNIZKの証拠を確認するために、コストは、楕円曲線上の1個の乗算は約あります。 ECの設定における公開鍵の検証のコストは基本的に無料です。"
    },
    {
      "indent": 0,
      "text": "4. Variants of Schnorr NIZK proof",
      "section_title": true,
      "ja": "シュNIZK証明の4バリアント"
    },
    {
      "indent": 3,
      "text": "In the finite field setting, the prover sends (V, r) (along with UserID and OtherInfo), and the verifier first computes c, and then checks for V = g^r * A^c mod p. This requires the transmission of an element V of Zp, whose size is typically between 2048 and 3072 bits, and an element r of Zq whose size is typically between 224 and 256 bits. It is possible to reduce the amount of transmitted data to two elements of Zq as below.",
      "ja": "有限体設定で、証明者は、（ユーザーIDとOtherInfoとともに）（V、R）を送信し、検証者は最初のCを計算し、次いでV = G ^ R * A ^ C MOD pについてチェックします。これは、サイズ2048と3072ビットの間、典型的にはZpを、の素子Vの送信、およびサイズ224と256ビットの間、典型的にZ qの要素rを必要とします。以下のようにZ qの二つの要素に送信されるデータの量を削減することができます。"
    },
    {
      "indent": 3,
      "text": "In the modified variant, the prover works exactly the same as before, except that it sends (c, r) instead of (V, r). The verifier computes V = g^r * A^c mod p and then checks whether H(g || V || A || UserID || OtherInfo) = c. The security of this modified variant follows from the fact that one can compute V from (c, r) and c from (V, r). Therefore, sending (c, r) is equivalent to sending (V, c, r), which in turn is equivalent to sending (V, r). Thus, the size of the Schnorr NIZK proof is significantly reduced. However, the computation costs for both the prover and the verifier stay the same.",
      "ja": "修飾された変異体では、証明者は、代わりに（C、R）（V、R）を送信することを除いて、正確に前と同じように機能します。検証者は、V = G ^ R * A ^ Cのmod Pを計算し、次いで、H（G || V || ||ユーザID || OtherInfo）はCを=かどうかをチェックします。この修飾された変異体のセキュリティは、1つの（V、R）から（C、R）からV及びCを計算することができるという事実から得られます。したがって、（C、r）を送信する順番に送信することと等価である（V、C、R）、（V、R）を送信することと等価です。したがって、シュノールNIZK証明のサイズが大幅に削減されます。しかし、証明者と検証の両方のための計算コストは​​同じまま。"
    },
    {
      "indent": 3,
      "text": "The same optimization technique also applies to the elliptic curve setting by replacing (V, r) with (c, r), but the benefit is extremely limited. When V is encoded in the compressed form, this optimization only saves 1 bit. The computation costs for generating and verifying the NIZK proof remain the same as before.",
      "ja": "同じ最適化手法は、（C、R）と（V、R）を置換することによって、楕円曲線の設定に適用するが、利点は、非常に限られています。 Vは、圧縮形式で符号化されたときに、この最適化は1ビットのみを保存します。 NIZKの証拠を生成し、検証するための計算コストは​​以前と同じまま。"
    },
    {
      "indent": 0,
      "text": "5. Applications of Schnorr NIZK proof",
      "section_title": true,
      "ja": "シュNIZK証明5.応用"
    },
    {
      "indent": 3,
      "text": "Some key exchange protocols, such as J-PAKE [HR08] and YAK [Hao10], rely on the Schnorr NIZK proof to ensure participants have the knowledge of discrete logarithms, hence following the protocol specification honestly. The technique described in this document can be directly applied to those protocols.",
      "ja": "そのようなJ-PAKE [HR08]およびYAK [Hao10]のようないくつかの鍵交換プロトコルは、参加者が故に正直プロトコル仕様を以下、離散対数の知識を持っていることを確認するためにシュノールNIZK証拠に依存しています。この文書に記載された技術は、直接それらのプロトコルに適用することができます。"
    },
    {
      "indent": 3,
      "text": "The inclusion of OtherInfo also makes the Schnorr NIZK proof generally useful and flexible to cater for a wide range of applications. For example, the described technique may be used to allow a user to demonstrate the proof of possession (PoP) of a long-term private key to a Certification Authority (CA) during the public key registration phrase. It must be ensured that the hash contains data that links the proof to one particular key registration procedure (e.g., by including the CA name, the expiry date, the applicant's email contact, and so on, in OtherInfo). In this case, the Schnorr NIZK proof is functionally equivalent to a self-signed Certificate Signing Request generated by using DSA or ECDSA.",
      "ja": "OtherInfoの包含はまた、幅広い用途に対応するためにシュノールNIZK証拠が一般的に有用かつ柔軟なります。例えば、記載された技術では、ユーザーは、公開鍵登録フレーズの間に認証局（CA）への長期秘密鍵の所有（POP）の証拠を証明できるようにするために使用することができます。ハッシュは（OtherInfoで、その上のCA名、有効期限、申請者の電子メールの連絡先を含めることによって、例えば、と）一つの特定のキー登録手続きに証拠をリンクするデータが含まれていることを確実にしなければなりません。この場合、シュノールNIZK証拠はDSAまたはECDSAを使用して生成された自己署名証明書署名要求と機能的に同等です。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Schnorr identification protocol has been proven to satisfy the following properties, assuming that the verifier is honest and the discrete logarithm problem is intractable (see [Stinson06]).",
      "ja": "シュノール識別プロトコルは、検証者が誠実であり、離散対数問題は、（[Stinson06]参照）、難治性であると仮定すると、以下の特性を満足することが証明されています。"
    },
    {
      "indent": 3,
      "text": "1. Completeness -- a prover who knows the discrete logarithm is always able to pass the verification challenge.",
      "ja": "1.完全性 - 離散対数を知っている証明者が常に検証課題に合格することができます。"
    },
    {
      "indent": 3,
      "text": "2. Soundness -- an adversary who does not know the discrete logarithm has only a negligible probability (i.e., 2^(-t)) to pass the verification challenge.",
      "ja": "2.健全性 - 検証のチャレンジを渡す - 敵離散対数を知らないだけ無視できる確率（T）すなわち、2 ^（）を有しています。"
    },
    {
      "indent": 3,
      "text": "3. Honest verifier zero-knowledge -- a prover leaks no more than one bit of information to the honest verifier: whether the prover knows the discrete logarithm.",
      "ja": "3.正直検証者ゼロ知識 - 証明漏れ正直な検証者に情報のない複数のビット：証明者は、離散対数を知っているかどうか。"
    },
    {
      "indent": 3,
      "text": "The Fiat-Shamir transformation is a standard technique to transform a three-pass interactive Zero-Knowledge Proof protocol (in which the verifier chooses a random challenge) to a non-interactive one, assuming that there exists a secure cryptographic hash function. Since the hash function is publicly defined, the prover is able to compute the challenge by itself, hence making the protocol non-interactive. In this case, the hash function (more precisely, the random oracle in the security proof) implements an honest verifier, because it assigns a uniformly random challenge c to each commitment (g^v or G x [v]) sent by the prover. This is exactly what an honest verifier would do.",
      "ja": "フィアット - シャミール変換は、安全な暗号ハッシュ関数が存在すると仮定し、非対話型いずれか（ここで、検証者は、ランダムチャレンジを選択）は、3つのパス対話零知識証明プロトコルを変換するための標準的な技術です。ハッシュ関数は、公に定義されているため、証明者は、したがって、プロトコル非対話作り、単独でチャレンジを計算することができます。それは証明者によって送信されたそれぞれのコミットメント（G ^ VまたはGのX [V]）に一様にランダムチャレンジCを割り当てるので、この場合には、ハッシュ関数は、（より正確には、セキュリティ証明にランダムオラクル）は、正直な検証を実現します。これは、正直な検証がどうなるのかを正確です。"
    },
    {
      "indent": 3,
      "text": "It is important to note that in Schnorr's identification scheme and its non-interactive variant, a secure random number generator is REQUIRED. In particular, bad randomness in v may reveal the secret discrete logarithm. For example, suppose the same random value V = g^v mod p is used twice by the prover (e.g., because its random number generator failed), but the verifier chooses different challenges c and c' (or the hash function is used on two different OtherInfo data, producing two different values c and c'). The adversary now observes two proof transcripts (V, c, r) and (V, c', r'), based on which he can compute the secret key a by:",
      "ja": "シュノールの識別スキームとその非対話型のバリアントでは、安全な乱数生成器が必要であることに注意することが重要です。具体的には、V INの悪いランダム秘密離散対数を明らかにすることができます。例えば、V = G ^ V（その乱数発生器が失敗したため、例えば、）MOD pは、証明者によって2回使用されるのと同じランダム値を想定するが、検証者は、異なる課題のCおよびC」を選択する（又はハッシュ関数がで使用され2つの異なる値のCおよびC 'を生成二つの異なるOtherInfoデータ）。敵は今、彼はで秘密鍵aを計算することができますかに基づいて、2つのプルーフ転写物（V、C、R）および（V、C「R」）を観察します："
    },
    {
      "indent": 3,
      "text": "(r-r')/(c'-c) = (v-a*c-v+a*c')/(c'-c) = a mod q.",
      "ja": "（R-R '）/（C'-C）=（V  -  *のC-V + *のC'）/（C'-C）がMOD Qを=。"
    },
    {
      "indent": 3,
      "text": "More generally, such an attack may even work for a slightly better (but still bad) random number generator, where the value v is not repeated, but the adversary knows a relation between two values v and v' such as v' = v + w for some known value w. Suppose the adversary observes two proof transcripts (V, c, r) and (V', c', r'). He can compute the secret key a by:",
      "ja": "より一般的には、このような攻撃は、偶数値vが繰り返されないわずかに良い（まだ悪い）乱数発生器、のために働くかもしれないが、敵対者は=のV +「はV」として二つの値VとVとの関係を知っていますいくつかの既知の値Wのワット敵対者は、2つのプルーフ転写（V、C、R）及び（V 'C'、R '）を観察すると仮定する。彼は、秘密鍵aをすることによって計算することができます。"
    },
    {
      "indent": 3,
      "text": "(r-r'+w)/(c'-c) = (v-a*c-v-w+a*c'+w)/(c'-c) = a mod q.",
      "ja": "（R-R '+ W）/（C'-C）=（V  -  *のC-V-W + *のC' + W）/（C'-C）がMOD Qを=。"
    },
    {
      "indent": 3,
      "text": "This example reinforces the importance of using a secure random number generator to generate the ephemeral secret v in Schnorr's schemes.",
      "ja": "この例では、シュノールのスキームではかない秘密Vを生成するために、安全な乱数生成器を使用することの重要性を強調しています。"
    },
    {
      "indent": 3,
      "text": "Finally, when a security protocol relies on the Schnorr NIZK proof for proving the knowledge of a discrete logarithm in a non-interactive way, the threat of replay attacks shall be considered. For example, the Schnorr NIZK proof might be replayed back to the prover itself (to introduce some undesirable correlation between items in a cryptographic protocol). This particular attack is prevented by the inclusion of the unique UserID in the hash. The verifier shall check the prover's UserID is a valid identity and is different from its own. Depending on the context of specific protocols, other forms of replay attacks should be considered, and appropriate contextual information included in OtherInfo whenever necessary.",
      "ja": "セキュリティプロトコルは、非対話型の方法で、離散対数の知識を証明するためのシュNIZKの証拠に依存していたときに最後に、リプレイ攻撃の脅威を考慮しなければなりません。例えば、シュノールNIZK証明が証明者自身に戻って再生されるかもしれない（暗号プロトコルの項目の間にいくつかの望ましくない相関を導入します）。この特定の攻撃は、ハッシュ内の一意のユーザIDを含めることによって阻止されます。検証者は、証明者のユーザーIDをチェックしなければならない有効なIDで、独自の異なるものです。特定のプロトコルのコンテキストに応じて、リプレイ攻撃の他の形態を検討する必要があり、適切なコンテキスト情報は、必要に応じOtherInfoに含まれています。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ABM15] Abdalla, M., Benhamouda, F., and P. MacKenzie, \"Security of the J-PAKE Password-Authenticated Key Exchange Protocol\", 2015 IEEE Symposium on Security and Privacy, DOI 10.1109/sp.2015.41, May 2015.",
      "ja": "[ABM15]アブダラ、M.、Benhamouda、F.、およびP.マッケンジー、2015年のセキュリティとプライバシーに関するIEEEシンポジウム、DOI 10.1109 / sp.2015.41、2015年5月 \"J-PAKEのパスワード認証鍵交換プロトコルのセキュリティ\" 。"
    },
    {
      "indent": 3,
      "text": "[AN95] Anderson, R. and R. Needham, \"Robustness principles for public key protocols\", Proceedings of the 15th Annual International Cryptology Conference on Advances in Cryptology, DOI 10.1007/3-540-44750-4_19, 1995.",
      "ja": "[AN95]アンダーソン、R.とR.ニーダム、「公開鍵プロトコルに対する頑健性の原則」、暗号学の進歩の第15回国際暗号学会議議事録、DOI 10.1007 / 3-540-44750-4_19、1995。"
    },
    {
      "indent": 3,
      "text": "[FS86] Fiat, A. and A. Shamir, \"How to Prove Yourself: Practical Solutions to Identification and Signature Problems\", Proceedings of the 6th Annual International Cryptology Conference on Advances in Cryptology, DOI 10.1007/3-540-47721-7_12, 1986.",
      "ja": "[FS86]フィアット、A.とA.シャミル、「自分を証明する方法：実用的な識別にソリューションおよび署名の問題」、暗号学、DOI 10.1007 / 3-540-47721-7_12の進歩の第六回国際暗号学会議議事録1986年。"
    },
    {
      "indent": 3,
      "text": "[MOV96] Menezes, A., Oorschot, P., and S. Vanstone, \"Handbook of Applied Cryptography\", 1996.",
      "ja": "[MOV96]メネゼス、A.、Oorschot、P.、およびS. Vanstone著、 \"応用暗号のハンドブック\"、1996。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[SEC1] \"Standards for Efficient Cryptography. SEC 1: Elliptic Curve Cryptography\", SECG SEC1-v2, May 2009, <http://www.secg.org/sec1-v2.pdf>.",
      "ja": "[SEC1] \"効率的な暗号化のための基準SEC 1：楕円曲線暗号\"、SECG SEC1-V2、2009年5月、<http://www.secg.org/sec1-v2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Stinson06] Stinson, D., \"Cryptography: Theory and Practice\", 3rd Edition, CRC, 2006.",
      "ja": "[Stinson06]スティンソン、D.、 \"暗号：理論と実践\"、第3版、CRC、2006。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[FIPS186-4]米国国立標準技術研究所、 \"デジタル署名標準（DSS）\"、FIPS PUBの186から4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月、<のhttp：//nvlpubs.nist。 GOV / nistpubs / FIPS / NIST.FIPS.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Hao10] Hao, F., \"On Robust Key Agreement Based on Public Key Authentication\", 14th International Conference on Financial Cryptography and Data Security, DOI 10.1007/978-3-642-14577-3_33, February 2010.",
      "ja": "[Hao10]ハオ、F.、金融暗号とデータセキュリティ、DOI 10.1007 / 978-3-642-14577-3_33、2010年2月に第14回国際会議「公開鍵認証に基づいて堅牢なキー合意に」。"
    },
    {
      "indent": 3,
      "text": "[HR08] Hao, F. and P. Ryan, \"Password Authenticated Key Exchange by Juggling\", Lecture Notes in Computer Science, pp. 159-171, from 16th Security Protocols Workshop (SPW'08), DOI 10.1007/978-3-642-22137-8_23, 2011.",
      "ja": "[HR08]ハオ、F.およびP.ライアン、「ジャグリングにより、パスワード認証鍵交換」、コンピュータサイエンスの講義ノート、頁159から171まで、第16回セキュリティプロトコルワークショップ（SPW'08）から、DOI 10.1007 / 978から3 -642-22137-8_23、2011。"
    },
    {
      "indent": 3,
      "text": "[NIST_DSA] NIST Cryptographic Toolkit, \"DSA Examples\", <http://csrc.nist.gov/groups/ST/toolkit/documents/ Examples/DSA2_All.pdf>.",
      "ja": "【NIST_DSA] NIST暗号化ツールキット、 \"DSA例\"、<http://csrc.nist.gov/groups/ST/toolkit/documents/例/ DSA2_All.pdf>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor of this document would like to thank Dylan Clarke, Robert Ransom, Siamak Shahandashti, Robert Cragie, Stanislav Smyshlyaev, and Tibor Jager for many useful comments. Tibor Jager pointed out the optimization technique and the vulnerability issue when the ephemeral secret v is not generated randomly. This work is supported by the EPSRC First Grant (EP/J011541/1) and the ERC Starting Grant (No. 306994).",
      "ja": "このドキュメントの編集者は、多くの有用なコメントをディラン・クラーク、ロバート・ランサム、Siamak Shahandashti、ロバートCragie、スタニスラフSmyshlyaev、およびティボーイェーガーに感謝したいと思います。ティボーイェーガーは、最適化手法と短命秘密vはランダムに生成されていない脆弱性の問題を指摘しました。この作品は、EPSRCまずグラント（EP / J011541 / 1）とERC開始グラント（番号306994）によってサポートされています。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Feng Hao (editor) Newcastle University (UK) Urban Sciences Building, School of Computing, Newcastle University Newcastle Upon Tyne United Kingdom",
      "ja": "風水ハオ（エディタ）ニューカッスル大学（UK）アーバン・サイエンスビル、コンピューティングの学校、ニューカッスル大学ニューカッスル・アポン・タインイギリスの際"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)191-208-6384 Email: feng.hao@ncl.ac.uk",
      "ja": "電話：+44（0）191-208-6384 Eメール：feng.hao@ncl.ac.uk"
    }
  ]
}