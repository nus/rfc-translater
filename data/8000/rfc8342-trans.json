{
  "title": {
    "text": "RFC 8342 - Network Management Datastore Architecture (NMDA)",
    "ja": "RFC 8342 - ネットワーク管理データストア・アーキテクチャ（NMDA）"
  },
  "number": 8342,
  "created_at": "2019-10-30 11:56:53.197974+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      M. Bjorklund\nRequest for Comments: 8342                                Tail-f Systems\nUpdates: 7950                                           J. Schoenwaelder\nCategory: Standards Track                              Jacobs University\nISSN: 2070-1721                                                P. Shafer\n                                                               K. Watsen\n                                                        Juniper Networks\n                                                               R. Wilton\n                                                           Cisco Systems\n                                                              March 2018",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Network Management Datastore Architecture (NMDA)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Datastores are a fundamental concept binding the data models written in the YANG data modeling language to network management protocols such as the Network Configuration Protocol (NETCONF) and RESTCONF. This document defines an architectural framework for datastores based on the experience gained with the initial simpler model, addressing requirements that were not well supported in the initial model. This document updates RFC 7950.",
      "ja": "データストアは、このようなネットワーク構成プロトコル（NETCONF）とRESTCONFなどの管理プロトコルをネットワークにYANGデータモデリング言語で記述されたデータモデルを結合基本的な概念です。この文書ではよく初期モデルではサポートされていなかった要件に対応し、初期の単純なモデルで得られた経験に基づいて、データストアのアーキテクチャフレームワークを定義します。この文書は、RFC 7950に更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8342.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8342で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Objectives ......................................................4\n3. Terminology .....................................................5\n4. Background ......................................................8\n   4.1. Original Model of Datastores ...............................9\n5. Architectural Model of Datastores ..............................11\n   5.1. Conventional Configuration Datastores .....................12\n        5.1.1. The Startup Configuration Datastore (<startup>) ....12\n        5.1.2. The Candidate Configuration Datastore\n               (<candidate>) ......................................13\n        5.1.3. The Running Configuration Datastore (<running>) ....13\n        5.1.4. The Intended Configuration Datastore (<intended>) ..13\n   5.2. Dynamic Configuration Datastores ..........................14\n   5.3. The Operational State Datastore (<operational>) ...........14\n        5.3.1. Remnant Configuration ..............................16\n        5.3.2. Missing Resources ..................................16\n        5.3.3. System-Controlled Resources ........................16\n        5.3.4. Origin Metadata Annotation .........................17\n6. Implications on YANG ...........................................18\n   6.1. XPath Context .............................................18\n   6.2. Invocation of Actions and RPCs ............................19\n7. YANG Modules ...................................................20\n8. IANA Considerations ............................................26\n   8.1. Updates to the IETF XML Registry ..........................26\n   8.2. Updates to the YANG Module Names Registry .................27\n9. Security Considerations ........................................27\n10. References ....................................................28\n   10.1. Normative References .....................................28\n   10.2. Informative References ...................................29",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix A. Guidelines for Defining Datastores ....................31\n  A.1. Define Which YANG Modules Can Be Used in the Datastore .....31\n  A.2. Define Which Subset of YANG-Modeled Data Applies ...........31\n  A.3. Define How Data Is Actualized ..............................31\n  A.4. Define Which Protocols Can Be Used .........................31\n  A.5. Define YANG Identities for the Datastore ...................32\nAppendix B. Example of an Ephemeral Dynamic Configuration\n            Datastore .............................................32\nAppendix C. Example Data ..........................................33\n  C.1. System Example .............................................34\n  C.2. BGP Example ................................................37\n    C.2.1. Datastores .............................................38\n    C.2.2. Adding a Peer ..........................................38\n    C.2.3. Removing a Peer ........................................39\n  C.3. Interface Example ..........................................40\n    C.3.1. Pre-provisioned Interfaces .............................41\n    C.3.2. System-Provided Interface ..............................42\nAcknowledgments ...................................................43\nAuthors' Addresses ................................................44",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides an architectural framework for datastores as they are used by network management protocols such as the Network Configuration Protocol (NETCONF) [RFC6241], RESTCONF [RFC8040], and the YANG data modeling language [RFC7950]. Datastores are a fundamental concept binding network management data models to network management protocols. Agreement on a common architectural model of datastores ensures that data models can be written in a way that is network management protocol agnostic. This architectural framework identifies a set of conceptual datastores, but it does not mandate that all network management protocols expose all these conceptual datastores. This architecture is agnostic with regard to the encoding used by network management protocols.",
      "ja": "彼らはそのようなネットワークコンフィギュレーションプロトコル（NETCONF）[RFC6241]、RESTCONF [RFC8040]、およびYANGデータモデリング言語[RFC7950]などのネットワーク管理プロトコルによって使用されるように、このドキュメントは、データストアのためのアーキテクチャフレームワークを提供します。データストアは、管理プロトコルをネットワークにネットワーク管理データモデルバインディングの基本的な概念です。データストアの共通アーキテクチャモデルに関する協定は、データモデルは、ネットワーク管理プロトコルはとらわれない方法で書くことができることを保証します。このアーキテクチャフレームワークは、概念データストアのセットを識別し、それは、すべてのネットワーク管理プロトコルは、これらすべての概念のデータストアを公開することを強制しません。このアーキテクチャは、ネットワーク管理プロトコルによって使用される符号化に関してはとらわれません。"
    },
    {
      "indent": 3,
      "text": "This document updates RFC 7950 by refining the definition of the accessible tree for some XML Path Language (XPath) context (see Section 6.1) and the invocation context of operations (see Section 6.2).",
      "ja": "いくつかのXMLパス言語（XPath）コンテキストのアクセスツリーの定義を改良することにより、このドキュメントの更新RFC 7950（セクション6.2を参照）、操作の呼び出しコンテキスト（6.1節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "2. Objectives",
      "section_title": true,
      "ja": "2.目的"
    },
    {
      "indent": 3,
      "text": "Network management data objects can often take two different values: the value configured by the user or an application (configuration) and the value that the device is actually using (operational state). These two values may be different for a number of reasons, e.g., system internal interactions with hardware, interaction with protocols or other devices, or simply the time it takes to propagate a configuration change to the software and hardware components of a system. Furthermore, configuration and operational state data objects may have different lifetimes.",
      "ja": "ネットワーク管理データオブジェクトは、多くの場合、2つの異なる値を取ることができる：ユーザーまたはアプリケーション（コンフィギュレーション）によって設定された値とデバイスが実際に使用される値（動作状態）。これらの2つの値は、例えば、ハードウェア、プロトコルまたは他のデバイスとの相互作用、または単にそれがシステムのソフトウェアおよびハードウェアコンポーネントの構成の変更を伝播するのにかかる時間とシステム内部の相互作用いくつかの理由でも異なっていてもよいです。さらに、設定および動作状態のデータオブジェクトは、異なる寿命を有することができます。"
    },
    {
      "indent": 3,
      "text": "The original model of datastores required these data objects to be modeled twice in the YANG schema -- as \"config true\" objects and as \"config false\" objects. The convention adopted by the interfaces data model [RFC8343] and the IP data model [RFC8344] was to use two separate branches rooted at the root of the data tree: one branch for configuration data objects and one branch for operational state data objects.",
      "ja": "「コンフィグ真」オブジェクトとしておよび「コンフィグ偽」オブジェクトとして - データストアのオリジナルモデルは、YANGスキーマに二度モデル化するために、これらのデータオブジェクトを必要としていました。構成データオブジェクトのための1つのブランチと動作状態のデータオブジェクトのための1つのブランチ：インターフェース・データ・モデル[RFC8343]とIPデータモデル[RFC8344]によって採用された規則は、データツリーのルートをルート二つの別個のブランチを使用することでした。"
    },
    {
      "indent": 3,
      "text": "The duplication of definitions and the ad hoc separation of operational state data from configuration data lead to a number of problems. Having configuration and operational state data in separate branches in the data model is operationally complicated and impacts the readability of module definitions. Furthermore, the relationship between the branches is not machine readable, and filter expressions operating on configuration and on related operational state are different.",
      "ja": "定義と構成データから動作状態データのアドホック分離の重複が多くの問題を引き起こします。データモデル内の別の支店での構成と動作状態のデータを持つことは運用上複雑であり、モジュール定義の影響可読性。さらに、枝の間の関係は、機械可読ではない、と構成にし、関連する動作状態で動作するフィルタ式が異なります。"
    },
    {
      "indent": 3,
      "text": "With the revised architectural model of datastores defined in this document, the data objects are defined only once in the YANG schema but independent instantiations can appear in different datastores, e.g., one for a configured value and another for an operationally used value. This provides a more elegant and simpler solution to the problem.",
      "ja": "この文書で定義されたデータストアの修正された建築モデルと、データオブジェクトはYANGスキーマに一度だけ定義されているが、独立したインスタンスは、異なるデータストアに表示されることができ、例えば、運用に使用される値のために設定された値と別のもの。これは問題に、よりエレガントでシンプルなソリューションを提供します。"
    },
    {
      "indent": 3,
      "text": "The revised architectural model of datastores supports additional datastores for systems that support more advanced processing chains converting configuration to operational state. For example, some systems support configuration that is not currently used (so-called \"inactive configuration\") or they support configuration templates that are used to expand configuration data via a common template.",
      "ja": "データストアの改訂アーキテクチャモデルは、動作状態に設定を変換し、より高度な処理チェーンをサポートするシステムのための追加的なデータストアをサポートしています。例えば、現在使用されていない、いくつかのシステムサポートの設定（「非アクティブコンフィギュレーション」と呼ばれる）、またはそれらは、共通のテンプレートを経由して、構成データを拡張するために使用されている設定テンプレートをサポートしています。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "This document defines the following terminology. Some of the terms are revised definitions of terms originally defined in [RFC6241] and [RFC7950] (see also Section 4). The revised definitions are semantically equivalent to the definitions found in [RFC6241] and [RFC7950]. It is expected that the revised definitions provided in this section will replace the definitions in [RFC6241] and [RFC7950] when these documents are revised.",
      "ja": "このドキュメントでは、次の用語を定義します。用語のいくつかは元々[RFC6241]及び[RFC7950]で定義された用語の定義が修正される（セクション4を参照）。改訂された定義は[RFC6241]及び[RFC7950]に見出される定義と意味的に等価です。これらの文書が改訂されている場合、このセクションで提供改定定義は[RFC6241]と[RFC7950]で定義を置き換えることが期待されます。"
    },
    {
      "indent": 3,
      "text": "o datastore: A conceptual place to store and access information. A datastore might be implemented, for example, using files, a database, flash memory locations, or combinations thereof. A datastore maps to an instantiated YANG data tree.",
      "ja": "Oデータストア：情報を保存し、アクセスするための概念的な場所。データストアは、ファイル、データベース、フラッシュメモリ位置、またはそれらの組み合わせを用いて、例えば、実装されるかもしれません。データストアは、インスタンス化YANGデータツリーにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "o schema node: A node in the schema tree. The formal definition is provided in RFC 7950.",
      "ja": "Oスキーマノード：スキーマ・ツリー内のノード。正式な定義は、RFC 7950で提供されます。"
    },
    {
      "indent": 3,
      "text": "o datastore schema: The combined set of schema nodes for all modules supported by a particular datastore, taking into consideration any deviations and enabled features for that datastore.",
      "ja": "Oデータストアスキーマ：特定のデータストアでサポートされているすべてのモジュールのスキーマノードの組み合わせセット、考慮にそのデータストアの任意の偏差と有効な機能を取ります。"
    },
    {
      "indent": 3,
      "text": "o configuration: Data that is required to get a device from its initial default state into a desired operational state. This data is modeled in YANG using \"config true\" nodes. Configuration can originate from different sources.",
      "ja": "O構成：データ所望の動作状態にその初期デフォルト状態からデバイスを取得するために必要とされます。このデータは、「コンフィグ真」ノードを使用してYANGでモデル化されます。コンフィギュレーションは、異なるソースから発信することができます。"
    },
    {
      "indent": 3,
      "text": "o configuration datastore: A datastore holding configuration.",
      "ja": "O構成データストア：データストア保持した構成。"
    },
    {
      "indent": 3,
      "text": "o running configuration datastore: A configuration datastore holding the current configuration of the device. It may include configuration that requires further transformations before it can be applied. This datastore is referred to as \"<running>\".",
      "ja": "Oコンフィギュレーションデータストアを実行している：コンフィギュレーションデータストアは、デバイスの現在の構成を保持します。それは、それが適用される前に、さらなる変換を必要とする構成を含んでいてもよいです。このデータストアは、「<ランニング>」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o candidate configuration datastore: A configuration datastore that can be manipulated without impacting the device's running configuration datastore and that can be committed to the running configuration datastore. This datastore is referred to as \"<candidate>\".",
      "ja": "O候補のコンフィギュレーション・データストア：デバイスの実行コンフィギュレーションデータストアに影響を与えずに操作することができ、それが実行中のコンフィギュレーションデータストアにコミットすることができ、構成データストア。このデータストアは、「<候補>」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o startup configuration datastore: A configuration datastore holding the configuration loaded by the device into the running configuration datastore when it boots. This datastore is referred to as \"<startup>\".",
      "ja": "Oスタートアップコンフィギュレーションデータストア：それは起動時に実行コンフィギュレーションデータストアにデバイスによってロードされたコンフィギュレーションを保持するコンフィギュレーションデータストア。このデータストアは、「<スタートアップ>」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o intended configuration: Configuration that is intended to be used by the device. It represents the configuration after all configuration transformations to <running> have been performed and is the configuration that the system attempts to apply.",
      "ja": "デバイスが使用することを意図している構成：O構成を意図。これは、<実行>にすべての構成変換後のコンフィギュレーション実行されたを表し、システムが適用しようとした構成です。"
    },
    {
      "indent": 3,
      "text": "o intended configuration datastore: A configuration datastore holding the complete intended configuration of the device. This datastore is referred to as \"<intended>\".",
      "ja": "デバイスの完全な所望の形状を保持する構成データストア：Oコンフィギュレーションデータストアを意図。このデータストアは、「<意図>」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o configuration transformation: The addition, modification, or removal of configuration between the <running> and <intended> datastores. Examples of configuration transformations include the removal of inactive configuration and the configuration produced through the expansion of templates.",
      "ja": "O構成変換：<実行>と<意図>データストア間で構成の付加、変更、または削除。構成変換の例は、非アクティブ構成の除去およびテンプレートの膨張により生成構成を含みます。"
    },
    {
      "indent": 3,
      "text": "o conventional configuration datastore: One of the following set of configuration datastores: <running>, <startup>, <candidate>, and <intended>. These datastores share a common datastore schema, and protocol operations allow copying data between these datastores. The term \"conventional\" is chosen as a generic umbrella term for these datastores.",
      "ja": "従来の構成データストアO：<意図> <ランニング>、<スタートアップ>、<候補>、および：コンフィギュレーション・データストアの以下のセットの1つ。これらのデータストアは、共通のデータストアスキーマを共有し、プロトコルの動作は、これらのデータストアの間でデータのコピーを可能にします。用語「従来は、」これらのデータストアのための一般的な包括的な用語として選択されています。"
    },
    {
      "indent": 3,
      "text": "o conventional configuration: Configuration that is stored in any of the conventional configuration datastores.",
      "ja": "O従来の構成：従来の構成データストアのいずれかに格納されている構成。"
    },
    {
      "indent": 3,
      "text": "o dynamic configuration datastore: A configuration datastore holding configuration obtained dynamically during the operation of a device through interaction with other systems, rather than through one of the conventional configuration datastores.",
      "ja": "O動的構成データストア：他のシステムとの相互作用によって、デバイスの動作中に動的に取得した構成データストア保持構成ではなく、従来の構成データストアのいずれかを介し。"
    },
    {
      "indent": 3,
      "text": "o dynamic configuration: Configuration obtained via a dynamic configuration datastore.",
      "ja": "O動的構成：動的構成データストアを介した構成。"
    },
    {
      "indent": 3,
      "text": "o learned configuration: Configuration that has been learned via protocol interactions with other systems and that is neither conventional nor dynamic configuration.",
      "ja": "他のシステムとプロトコルの相互作用を介して学習し、それはどちらも従来のNOR動的構成されてきた構成：O構成を学びました。"
    },
    {
      "indent": 3,
      "text": "o system configuration: Configuration that is supplied by the device itself.",
      "ja": "Oシステムの構成：デバイス自体によって供給される構成。"
    },
    {
      "indent": 3,
      "text": "o default configuration: Configuration that is not explicitly provided but for which a value defined in the data model is used.",
      "ja": "Oのデフォルトの設定：明示的に提供されていないが、データモデルで定義された値が使用されている設定。"
    },
    {
      "indent": 3,
      "text": "o applied configuration: Configuration that is actively in use by a device. Applied configuration originates from conventional, dynamic, learned, system, and default configuration.",
      "ja": "Oコンフィギュレーションを適用：デバイスが使用して積極的にある設定。応用構成は、従来、ダイナミック、学び、システム、およびデフォルトの設定に由来します。"
    },
    {
      "indent": 3,
      "text": "o system state: The additional data on a system that is not configuration, such as read-only status information and collected statistics. System state is transient and modified by interactions with internal components or other systems. System state is modeled in YANG using \"config false\" nodes.",
      "ja": "Oシステムの状態：例えば読み取り専用ステータス情報と統計情報を収集するよう構成されていないシステム上で追加データ、。システムの状態は、一時的および内部コンポーネントまたは他のシステムとの相互作用によって修飾されます。システム状態が「コンフィグ偽」ノードを使用してYANGでモデル化されます。"
    },
    {
      "indent": 3,
      "text": "o operational state: The combination of applied configuration and system state.",
      "ja": "O動作状態：適用された設定とシステムの状態の組み合わせ。"
    },
    {
      "indent": 3,
      "text": "o operational state datastore: A datastore holding the complete operational state of the device. This datastore is referred to as \"<operational>\".",
      "ja": "O動作状態データストア：デバイスの完全な動作状態を保持するデータストア。このデータストアは、「<運用>」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o origin: A metadata annotation indicating the origin of a data item.",
      "ja": "O起源：データ項目の原点を示すメタデータ注釈。"
    },
    {
      "indent": 3,
      "text": "o remnant configuration: Configuration that remains part of the applied configuration for a period of time after it has been removed from the intended configuration or dynamic configuration. The time period may be minimal or may last until all resources used by the newly deleted configuration (e.g., network connections, memory allocations, file handles) have been deallocated.",
      "ja": "O残骸の構成：それは意図したコンフィギュレーションまたは動的コンフィギュレーションから削除された後の一定期間適用される設定の一部のままの構成。期間は最小であってもよいし、新たに削除コンフィギュレーションで使用されるすべてのリソースが（例えば、ネットワーク接続、メモリ割り当て、ファイルハンドル）が割り当て解除されるまで続くことができます。"
    },
    {
      "indent": 3,
      "text": "The following additional terms are not datastore specific, but they are commonly used and are thus defined here as well:",
      "ja": "以下の追加条件は、特定のデータストア（datastore）されていませんが、一般的に使用されているので、ここにも定義されています。"
    },
    {
      "indent": 3,
      "text": "o client: An entity that can access YANG-defined data on a server, over some network management protocol.",
      "ja": "Oクライアント：一部のネットワーク管理プロトコルを介して、サーバー上YANG定義のデータにアクセスすることができますエンティティ。"
    },
    {
      "indent": 3,
      "text": "o server: An entity that provides access to YANG-defined data to a client, over some network management protocol.",
      "ja": "Oサーバ：一部のネットワーク管理プロトコルを介して、クライアントへYANG、定義されたデータへのアクセスを提供するエンティティ。"
    },
    {
      "indent": 3,
      "text": "o notification: A server-initiated message indicating that a certain event has been recognized by the server.",
      "ja": "O通知：特定のイベントがサーバによって認識されたことを示すサーバ起動メッセージ。"
    },
    {
      "indent": 3,
      "text": "o remote procedure call: An operation that can be invoked by a client on a server.",
      "ja": "Oリモートプロシージャコール：サーバー上のクライアントによって呼び出すことができる操作。"
    },
    {
      "indent": 0,
      "text": "4. Background",
      "section_title": true,
      "ja": "4.背景"
    },
    {
      "indent": 3,
      "text": "NETCONF [RFC6241] provides the following definitions:",
      "ja": "NETCONF [RFC6241]は以下の定義を提供します。"
    },
    {
      "indent": 3,
      "text": "o datastore: A conceptual place to store and access information. A datastore might be implemented, for example, using files, a database, flash memory locations, or combinations thereof.",
      "ja": "Oデータストア：情報を保存し、アクセスするための概念的な場所。データストアは、ファイル、データベース、フラッシュメモリ位置、またはそれらの組み合わせを用いて、例えば、実装されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "o configuration datastore: The datastore holding the complete set of configuration that is required to get a device from its initial default state into a desired operational state.",
      "ja": "O構成データストア：データストアが所望の動作状態にその初期デフォルト状態からデバイスを取得するために必要とされるコンフィギュレーションの完全なセットを保持しています。"
    },
    {
      "indent": 3,
      "text": "YANG 1.1 [RFC7950] provides the following refinements when NETCONF is used with YANG (which is the usual case, but note that NETCONF was defined before YANG existed):",
      "ja": "NETCONFは（通常の場合であるが、YANGが存在する前にNETCONFを定義したことに注意）YANGと共に使用される場合YANG 1.1 [RFC7950]は、以下の改良を提供します。"
    },
    {
      "indent": 3,
      "text": "o datastore: When modeled with YANG, a datastore is realized as an instantiated data tree.",
      "ja": "Oデータストア：YANGでモデル化する場合、データストアは、インスタンス化データツリーとして実現されます。"
    },
    {
      "indent": 3,
      "text": "o configuration datastore: When modeled with YANG, a configuration datastore is realized as an instantiated data tree with configuration.",
      "ja": "Oコンフィギュレーションデータストア：YANGでモデル化する場合、コンフィギュレーションデータストアが設定でインスタンス化データツリーとして実現されます。"
    },
    {
      "indent": 3,
      "text": "[RFC6244] defined operational state data as follows:",
      "ja": "[RFC6244]次のように動作状態データを定義："
    },
    {
      "indent": 3,
      "text": "o Operational state data is a set of data that has been obtained by the system at runtime and influences the system's behavior similar to configuration data. In contrast to configuration data, operational state is transient and modified by interactions with internal components or other systems via specialized protocols.",
      "ja": "O動作状態データは、実行時にシステムによって得られたデータの集合であり、コンフィギュレーションデータと同様、システムの動作に影響を与えます。コンフィギュレーションデータとは対照的に、動作状態が過渡及び内部コンポーネントまたは専用プロトコルを介して他のシステムとの相互作用によって修飾されます。"
    },
    {
      "indent": 3,
      "text": "Section 4.3.3 of [RFC6244] discusses operational state and mentions, among other things, the option to consider operational state as being stored in another datastore. Section 4.4 of [RFC6244] then concludes that, at the time of its writing, modeling state as distinct leafs and distinct branches is the recommended approach.",
      "ja": "[RFC6244]のセクション4.3.3は、とりわけ、オプションは、別のデータストアに格納されているものとして動作状態を考慮して、動作状態を説明し、言及しています。 [RFC6244]のセクション4.4は、その執筆時点では、個別の葉や個別の枝のようにモデル化状態が推奨されるアプローチである、と結論づけています。"
    },
    {
      "indent": 3,
      "text": "Implementation experience and requests from operators [OpState-Reqs] [OpState-Modeling] indicate that the datastore model initially designed for NETCONF and refined by YANG needs to be extended. In particular, the notion of intended configuration and applied configuration has developed.",
      "ja": "実装経験と事業者からの要求は、[のOpState-要求数] [のOpState-モデル]データストアモデル最初はNETCONFのために設計されており、YANGによって洗練を延長する必要があることを示しています。具体的には、意図した構成と適用されたコンフィギュレーションの概念が開発しました。"
    },
    {
      "indent": 0,
      "text": "4.1. Original Model of Datastores",
      "section_title": true,
      "ja": "4.1。データストアのオリジナルモデル"
    },
    {
      "indent": 3,
      "text": "The following drawing shows the original model of datastores as it is currently used by NETCONF [RFC6241]:",
      "ja": "それは現在NETCONF [RFC6241]で使用される次の図面は、データストアの元のモデルを示しています。"
    },
    {
      "indent": 10,
      "text": "+-------------+                 +-----------+\n| <candidate> |                 | <startup> |\n|  (ct, rw)   |<---+       +--->| (ct, rw)  |\n+-------------+    |       |    +-----------+\n       |           |       |           |\n       |         +-----------+         |\n       +-------->| <running> |<--------+\n                 | (ct, rw)  |\n                 +-----------+\n                       |\n                       v\n                operational state  <--- control plane\n                    (cf, ro)",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ct = config true; cf = config false rw = read-write; ro = read-only boxes denote datastores",
      "ja": "CT = configの場合はtrue。 CF = configの偽RW =読み書き; RO =読み取り専用ボックスには、データストアを表し"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Note that this diagram simplifies the model: \"read-only\" (ro) and \"read-write\" (rw) are to be understood from the client's perspective, at a conceptual level. In NETCONF, for example, support for <candidate> and <startup> is optional, and <running> does not have to be writable. Furthermore, <startup> can only be modified by copying <running> to <startup> in the standardized NETCONF datastore editing model. The RESTCONF protocol does not expose these differences and instead provides only a writable unified datastore, which hides whether edits are done through <candidate>, by directly modifying <running>, or via some other implementation-specific mechanism. RESTCONF also hides how configuration is made persistent. Note that implementations may also have additional datastores that can propagate changes to <running>. NETCONF explicitly mentions so-called \"named datastores\".",
      "ja": "この図は、モデルを単純化することに注意：「読み取り専用」（RO）と「読み書き」（RW）は、概念レベルで、クライアントの観点から理解されるべきです。 NETCONFでは、例えば、<候補>と<スタートアップ>のサポートは任意であり、そして<ランニング>書き込み可能である必要はありません。また、<起動>は唯一の標準化NETCONFデータストア編集モデルの<起動>から<実行>コピーすることによって修飾することができます。 RESTCONFプロトコルは、これらの違いを露出し、代わりにのみ書き込み可能な統一された直接<実行>を変更することによって、編集が<候補>を介して行われているかどうかを隠しデータストア、または他のいくつかの実装固有の機構を介しを提供しません。 RESTCONFも設定が永続化する方法を非表示にします。実装はまた、<ランニング>に変更を伝播することができ、追加のデータストアを持っていることに注意してください。 NETCONFは、明示的に、いわゆる「という名前のデータストア」を言及しています。"
    },
    {
      "indent": 3,
      "text": "Some observations:",
      "ja": "いくつかの所見："
    },
    {
      "indent": 3,
      "text": "o Operational state has not been defined as a datastore, although there were proposals in the past to introduce an operational state datastore.",
      "ja": "動作状態のデータストアを紹介する過去の提案があったものの、O動作状態は、データストアとして定義されていません。"
    },
    {
      "indent": 3,
      "text": "o The NETCONF <get> operation returns the contents of <running> together with the operational state. It is therefore necessary that \"config false\" data be in a different branch than the \"config true\" data if the operational state can have a different lifetime compared to configuration or if configuration is not immediately or successfully applied.",
      "ja": "oをNETCONF <GET>操作が動作状態と一緒に<ランニング>の内容を返します。動作状態が構成や設定をすぐにまたは正常に適用されていない場合に比較して、異なる寿命を持つことができる場合は、「コンフィグ偽」のデータは「コンフィグ真」のデータとは別の支店にあることが必要です。"
    },
    {
      "indent": 3,
      "text": "o Several implementations have proprietary mechanisms that allow clients to store inactive data in <running>. Inactive data is conceptually removed before validation.",
      "ja": "Oいくつかの実装では、クライアントは、<ランニング>に非アクティブなデータを格納できるようにする独自の機構を有しています。非アクティブなデータは、概念的には、検証前に除去されます。"
    },
    {
      "indent": 3,
      "text": "o Some implementations have proprietary mechanisms that allow clients to define configuration templates in <running>. These templates are expanded automatically by the system, and the resulting configuration is applied internally.",
      "ja": "O一部の実装では、クライアントが、<ランニング>で構成テンプレートを定義することができ、独自の機構を有しています。これらのテンプレートは、システムによって自動的に展開され、そして得られたコンフィギュレーションは内部で適用されます。"
    },
    {
      "indent": 3,
      "text": "o Some operators have reported that it is essential for them to be able to retrieve the configuration that has actually been successfully applied, which may be a subset or a superset of the <running> configuration.",
      "ja": "O一部の事業者は、彼らがサブセットまたは<ランニング>コンフィギュレーションのスーパーセットであり、実際に正常に適用された設定を、取得できるようにすることが不可欠であることを報告しています。"
    },
    {
      "indent": 0,
      "text": "5. Architectural Model of Datastores",
      "section_title": true,
      "ja": "データストアの5アーキテクチャモデル"
    },
    {
      "indent": 3,
      "text": "Below is a new conceptual model of datastores, extending the original model in order to reflect the experience gained with the original model.",
      "ja": "以下は、オリジナルモデルで得られた経験を反映するために、元のモデルを拡張し、データストアの新しい概念モデルです。"
    },
    {
      "indent": 5,
      "text": "+-------------+                 +-----------+\n| <candidate> |                 | <startup> |\n|  (ct, rw)   |<---+       +--->| (ct, rw)  |\n+-------------+    |       |    +-----------+\n       |           |       |           |\n       |         +-----------+         |\n       +-------->| <running> |<--------+\n                 | (ct, rw)  |\n                 +-----------+\n                       |\n                       |        // configuration transformations,\n                       |        // e.g., removal of nodes marked as\n                       |        // \"inactive\", expansion of\n                       |        // templates\n                       v\n                 +------------+\n                 | <intended> | // subject to validation\n                 | (ct, ro)   |\n                 +------------+\n                       |        // changes applied, subject to\n                       |        // local factors, e.g., missing\n                       |        // resources, delays\n                       |\n  dynamic              |   +-------- learned configuration\n  configuration        |   +-------- system configuration\n  datastores -----+    |   +-------- default configuration\n                  |    |   |\n                  v    v   v\n               +---------------+\n               | <operational> | <-- system state\n               | (ct + cf, ro) |\n               +---------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ct = config true; cf = config false rw = read-write; ro = read-only boxes denote named datastores",
      "ja": "CT = configの場合はtrue。 CF = configの偽RW =読み書き; RO =読み取り専用ボックスには、名前のデータストアを表し"
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 0,
      "text": "5.1. Conventional Configuration Datastores",
      "section_title": true,
      "ja": "5.1。従来の構成データストア"
    },
    {
      "indent": 3,
      "text": "The conventional configuration datastores are a set of configuration datastores that share exactly the same datastore schema, allowing data to be copied between them. The term is meant as a generic umbrella description of these datastores. If a module does not contain any configuration data nodes and it is not needed to satisfy any imports, then it MAY be omitted from the datastore schema for the conventional configuration datastores. The set of datastores include:",
      "ja": "従来の構成データストアは、データがそれらの間にコピーされることを可能にする、全く同じデータストアスキーマを共有する構成データストアのセットです。この用語は、これらのデータストアの一般的な傘の記述として意図されています。モジュールは、任意の構成データ・ノードが含まれていないと、任意のインポートを満足させるために必要とされない場合、それは従来の構成データストアのデータストアスキーマから省略されてもよいです。データストアのセットが含まれます："
    },
    {
      "indent": 3,
      "text": "o <running>",
      "ja": "O <ランニング>"
    },
    {
      "indent": 3,
      "text": "o <candidate>",
      "ja": "O <候補>"
    },
    {
      "indent": 3,
      "text": "o <startup>",
      "ja": "O <スタートアップ>"
    },
    {
      "indent": 3,
      "text": "o <intended>",
      "ja": "O <意図>"
    },
    {
      "indent": 3,
      "text": "Other conventional configuration datastores may be defined in future documents.",
      "ja": "他の従来のコンフィギュレーション・データストアは、将来の文書で定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The flow of data between these datastores is depicted in Section 5.",
      "ja": "これらのデータストアの間のデータの流れは、第5節に示されています。"
    },
    {
      "indent": 3,
      "text": "The specific protocols may define explicit operations to copy between these datastores, e.g., NETCONF defines the <copy-config> operation.",
      "ja": "特定のプロトコルは、これらのデータストア間でコピーする明示的な操作を定義してもよい、例えば、NETCONFは、<コピー設定>操作を定義します。"
    },
    {
      "indent": 0,
      "text": "5.1.1. The Startup Configuration Datastore (<startup>)",
      "section_title": true,
      "ja": "5.1.1。スタートアップコンフィギュレーションデータストア（<スタートアップ>）"
    },
    {
      "indent": 3,
      "text": "The startup configuration datastore (<startup>) is a configuration datastore holding the configuration loaded by the device when it boots. <startup> is only present on devices that separate the startup configuration from the running configuration datastore.",
      "ja": "スタートアップコンフィギュレーションデータストア（<起動時>）は、それが起動時にデバイスによってロードされたコンフィギュレーションを保持するコンフィギュレーションデータストアです。 <起動時>実行コンフィギュレーションデータストアからスタートアップコンフィギュレーションを別個のデバイス上にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "The startup configuration datastore may not be supported by all protocols or implementations.",
      "ja": "スタートアップコンフィギュレーションデータストアは、すべてのプロトコルや実装によってサポートされない場合があります。"
    },
    {
      "indent": 3,
      "text": "On devices that support non-volatile storage, the contents of <startup> will typically persist across reboots via that storage. At boot time, the device loads the saved startup configuration into <running>. To save a new startup configuration, data is copied to <startup> via either implicit or explicit protocol operations.",
      "ja": "不揮発性ストレージをサポートするデバイスでは、<スタートアップ>の内容は、典型的には、そのストレージを経由して再起動しても持続します。ブート時に、デバイスは、<ランニング>に保存されたスタートアップコンフィギュレーションをロードします。新しいスタートアップコンフィギュレーションを保存するには、データが暗黙的または明示的なプロトコル動作のいずれかを介して、<スタートアップ>にコピーされます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. The Candidate Configuration Datastore (<candidate>)",
      "section_title": true,
      "ja": "5.1.2。候補者の構成データストア（<候補>）"
    },
    {
      "indent": 3,
      "text": "The candidate configuration datastore (<candidate>) is a configuration datastore that can be manipulated without impacting the device's current configuration and that can be committed to <running>.",
      "ja": "候補コンフィギュレーションデータストア（<候補>）は、デバイスの現在の設定に影響を与えずに操作することができ、それが<ランニング>にコミットすることができ、構成データストアです。"
    },
    {
      "indent": 3,
      "text": "The candidate configuration datastore may not be supported by all protocols or implementations.",
      "ja": "候補設定データストアは、すべてのプロトコルまたは実装によってサポートされなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "<candidate> does not typically persist across reboots, even in the presence of non-volatile storage. If <candidate> is stored using non-volatile storage, it is reset at boot time to the contents of <running>.",
      "ja": "<候補>一般的にも、不揮発性記憶装置の存在下で、リブート後も保持しません。 <候補は>不揮発性ストレージを使用して格納されている場合は、<ランニング>の内容にブート時にリセットされます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. The Running Configuration Datastore (<running>)",
      "section_title": true,
      "ja": "5.1.3。実行コンフィギュレーションデータストア（<ランニング>）"
    },
    {
      "indent": 3,
      "text": "The running configuration datastore (<running>) is a configuration datastore that holds the current configuration of the device. It MAY include configuration that requires further transformation before it can be applied, e.g., inactive configuration, or template-mechanism-oriented configuration that needs further expansion. However, <running> MUST always be a valid configuration data tree, as defined in Section 8.1 of [RFC7950].",
      "ja": "実行コンフィギュレーションデータストア（<ランニング>）は、デバイスの現在の設定を保持するコンフィギュレーションデータストアです。それは適用することができる前にさらなる変換を必要とする構成、例えば、不活性なコンフィギュレーション、またはさらなる拡大を必要とテンプレート機構指向の構成を含んでいてもよいです。しかし、<ランニング>常に[RFC7950]のセクション8.1で定義されているように、有効な構成データツリーでなければなりません。"
    },
    {
      "indent": 3,
      "text": "<running> MUST be supported if the device can be configured via conventional configuration datastores.",
      "ja": "デバイスは、従来の構成データストアを介して構成することができる場合は、<実行>をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a device does not have a distinct <startup> and non-volatile storage is available, the device will typically use that non-volatile storage to allow <running> to persist across reboots.",
      "ja": "デバイスは、個別の<スタートアップ>と不揮発性ストレージが提供されていない場合、デバイスは、一般的に再起動しても持続する<ランニング>できるようにすること不揮発性ストレージを使用します。"
    },
    {
      "indent": 0,
      "text": "5.1.4. The Intended Configuration Datastore (<intended>)",
      "section_title": true,
      "ja": "5.1.4。意図したコンフィギュレーションデータストア（<意図>）"
    },
    {
      "indent": 3,
      "text": "The intended configuration datastore (<intended>) is a read-only configuration datastore. It represents the configuration after all configuration transformations to <running> are performed (e.g., template expansion, removal of inactive configuration) and is the configuration that the system attempts to apply.",
      "ja": "意図されたコンフィギュレーションデータストア（<意図>）は読み出し専用構成データストアです。これは、（例えば、テンプレートの拡大、非アクティブ構成の除去）を行うと、システムが適用しようとする構成では<実行>にすべての構成変換後の構成を表しています。"
    },
    {
      "indent": 3,
      "text": "<intended> is tightly coupled to <running>. Whenever data is written to <running>, the server MUST also immediately update and validate <intended>.",
      "ja": "<意図>しっかり<ランニング>に接続されています。データは<ランニング>に書き込まれるたびに、サーバーは、すぐに<意図>更新して検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "<intended> MAY also be updated independently of <running> if the effect of a configuration transformation changes, but <intended> MUST always be a valid configuration data tree, as defined in Section 8.1 of [RFC7950].",
      "ja": "<意図>はまた、独立して、<実行>を更新することができる場合、構成変換の変更の影響が、<意図> [RFC7950]のセクション8.1で定義されるように、常に、有効なコンフィギュレーション・データ・ツリーでなければなりません。"
    },
    {
      "indent": 3,
      "text": "For simple implementations, <running> and <intended> are identical.",
      "ja": "簡単な実装では、<ランニング>と<意図>は同じです。"
    },
    {
      "indent": 3,
      "text": "The contents of <intended> are also related to the \"config true\" subset of <operational>; hence, a client can determine to what extent the intended configuration is currently in use by checking to see whether the contents of <intended> also appear in <operational>.",
      "ja": "<意図>の内容も、<運用>の「コンフィグ真」のサブセットに関連しています。したがって、クライアントが意図した設定は、<意図>の内容も、<運用>に表示されるかどうかをチェックすることにより、現在使用中のどの程度に決定することができます。"
    },
    {
      "indent": 3,
      "text": "<intended> does not persist across reboots; its relationship with <running> makes that unnecessary.",
      "ja": "<意図>再起動しても保持されません。 <ランニング>との関係は、それが不要になります。"
    },
    {
      "indent": 3,
      "text": "Currently, there are no standard mechanisms defined that affect <intended> so that it would have different content than <running>, but this architecture allows for such mechanisms to be defined.",
      "ja": "現在のところ、そこには<ランニング>とは異なる内容を有するなるようにそれは、<意図>影響を及ぼす定義された標準的なメカニズムはありませんが、そのようなメカニズムを定義するために、このアーキテクチャができます。"
    },
    {
      "indent": 3,
      "text": "One example of such a mechanism is support for marking nodes as inactive in <running>. Inactive nodes are not copied to <intended>. A second example is support for templates, which can perform transformations on the configuration from <running> to the configuration written to <intended>.",
      "ja": "そのような機構の一例は、<実行>に非アクティブとしてノードをマークするための支持体です。非アクティブノードは、<意図>にコピーされません。第二の例では、<意図>に書き込まれた構成に<実行>から構成変換を実行することができるテンプレートのサポート、です。"
    },
    {
      "indent": 0,
      "text": "5.2. Dynamic Configuration Datastores",
      "section_title": true,
      "ja": "5.2。動的構成データストア"
    },
    {
      "indent": 3,
      "text": "The model recognizes the need for dynamic configuration datastores that are, by definition, not part of the persistent configuration of a device. In some contexts, these have been termed \"ephemeral datastores\", since the information is ephemeral, i.e., lost upon reboot. The dynamic configuration datastores interact with the rest of the system through <operational>.",
      "ja": "このモデルは、定義により、デバイスの永続的な構成の一部ではありません動的構成データストアの必要性を認識しています。情報が短命であるため、いくつかの状況では、これらはすなわち、再起動時に失われた、「一時的なデータストア」と呼ばれています。動的構成データストアは、<運用>を介してシステムの他の部分と対話します。"
    },
    {
      "indent": 3,
      "text": "The datastore schema for a dynamic configuration datastore MAY differ from the datastore schema used for conventional configuration datastores. If a module does not contain any configuration data nodes and it is not needed to satisfy any imports, then it MAY be omitted from the datastore schema for the dynamic configuration datastore.",
      "ja": "動的構成データストアのデータストアスキーマは、従来の構成データストアに使用されるデータストアスキーマ異なっていてもよいです。モジュールは、任意の構成データ・ノードが含まれていないと、任意のインポートを満足させるために必要とされない場合、それは、動的構成データストアのデータストアスキーマから省略されてもよいです。"
    },
    {
      "indent": 0,
      "text": "5.3. The Operational State Datastore (<operational>)",
      "section_title": true,
      "ja": "5.3。運用状態のデータストア（<運用>）"
    },
    {
      "indent": 3,
      "text": "The operational state datastore (<operational>) is a read-only datastore that consists of all \"config true\" and \"config false\" nodes defined in the datastore's schema. In the original NETCONF model, the operational state only had \"config false\" nodes. The reason for incorporating \"config true\" nodes here is to be able to expose all operational settings without having to replicate definitions in the data models.",
      "ja": "動作状態のデータストアは、（<運用>）データストアのスキーマで定義されているすべての「真の設定」および「コンフィグ偽」のノードで構成され、読み取り専用のデータストアです。オリジナルのNETCONFのモデルでは、動作状態は、「コンフィグ偽」のノードを持っていました。ここでは、「コンフィグ真」のノードを組み込むための理由は、データモデルで定義を複製することなく、すべての動作設定を公開できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "<operational> contains system state and all configuration actually used by the system. This includes all applied configuration from <intended>, learned configuration, system-provided configuration, and default values defined by any supported data models. In addition, <operational> also contains applied configuration from dynamic configuration datastores.",
      "ja": "<運用>システム状態と、実際にシステムで使用されるすべての設定が含まれています。これは、<意図>からすべての適用構成を含む、任意のサポートされるデータモデルによって定義されたデフォルト値の設定、システムが提供する構成、を学びました。また、<動作>また、動的構成データストアから適用された設定が含まれています。"
    },
    {
      "indent": 3,
      "text": "The datastore schema for <operational> MUST be a superset of the combined datastore schema used in all configuration datastores, except that configuration data nodes supported in a configuration datastore MAY be omitted from <operational> if a server is not able to accurately report them.",
      "ja": "サーバはそれらを正確に報告することができない場合は、構成データストアでサポートされているコンフィギュレーション・データ・ノードは、<運用>から省略されるかもしれ除い<運用>のデータストアスキーマは、すべての構成データストアで使用される複合データストアスキーマのスーパーセットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requests to retrieve nodes from <operational> always return the value in use if the node exists, regardless of any default value specified in the YANG module. If no value is returned for a given node, then this implies that the node is not used by the device.",
      "ja": "ノードが存在する場合は、<運用>からノードを取得するための要求は関係なく、常にYANGモジュールで指定されたデフォルト値を、使用中の値を返します。値が与えられたノードに対して返されない場合、これは、ノードがデバイスによって使用されていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The interpretation of what constitutes being \"in use\" by the system is dependent on both the schema definition and the device implementation. Generally, functionality that is enabled and operational on the system would be considered to be \"in use\". Conversely, functionality that is neither enabled nor operational on the system is considered not to be \"in use\"; hence, it SHOULD be omitted from <operational>.",
      "ja": "システムが「使用中」で構成するものの解釈は、スキーマ定義とデバイス実装の両方に依存します。一般的には、システム上で有効にして運用される機能は「使用中」であると考えられます。逆に、システム上で有効になっていないにも運用もされていない機能は「使用中」ではないと考えられています。したがって、それは、<運用>から省略します。"
    },
    {
      "indent": 3,
      "text": "<operational> SHOULD conform to any constraints specified in the data model, but given the principal aim of returning \"in use\" values, it is possible that constraints MAY be violated under some circumstances (e.g., an abnormal value is \"in use\", the structure of a list is being modified, or remnant configuration (see Section 5.3.1) still exists). Note that deviations SHOULD be used when it is known in advance that a device does not fully conform to the <operational> schema.",
      "ja": "<操作>データモデルに指定された制約に準拠している必要がありますが、値が「使用中」を返すの主な目的を考えると、それは制約がいくつかの状況（例えば下違反している可能性があり、異常値は「使用中」です、 ）リストの構造が変更されている、または残りの構成は、（セクション5.3.1を参照）がまだ存在しています。デバイスが完全に<運用>スキーマに準拠していないことが事前に分かっている場合に偏差が使用されるべきであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Only semantic constraints MAY be violated. These are the YANG \"when\", \"must\", \"mandatory\", \"unique\", \"min-elements\", and \"max-elements\" statements; and the uniqueness of key values.",
      "ja": "唯一の意味制約に違反するかもしれません。これらは、YANG「」、「MUST」、「必須」、「ユニーク」、「最小の要素」、および「MAX-要素」ステートメントです。およびキー値の一意性。"
    },
    {
      "indent": 3,
      "text": "Syntactic constraints MUST NOT be violated, including hierarchical organization, identifiers, and type-based constraints. If a node in <operational> does not meet the syntactic constraints, then it MUST NOT be returned, and some other mechanism should be used to flag the error.",
      "ja": "構文の制約は階層的な組織、識別子、およびタイプに基づく制約を含む、違反してはなりません。内のノードは、<運用>構文制約を満たしていない場合は、それが返されてはならない、といくつかの他のメカニズムは、エラーフラグを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "<operational> does not persist across reboots.",
      "ja": "<運用>リブート後も保持しません。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Remnant Configuration",
      "section_title": true,
      "ja": "5.3.1。レムナントの設定"
    },
    {
      "indent": 3,
      "text": "Changes to configuration may take time to percolate through to <operational>. During this period, <operational> may contain nodes for both the previous and current configuration, as closely as possible tracking the current operation of the device. Such remnant configuration from the previous configuration persists until the system has released resources used by the newly deleted configuration (e.g., network connections, memory allocations, file handles).",
      "ja": "設定の変更は、<運用>に通じ浸透するには時間がかかる場合があります。この期間中、<動作>デバイスの現在の動作を追跡可能な限り厳密に、以前と現在の設定の両方のためのノードを含んでいてもよいです。システムは、新たに削除の構成（例えば、ネットワーク接続、メモリ割り当て、ファイルハンドル）によって使用されるリソースを解放するまで、以前の構成からそのような残りの構成は、持続します。"
    },
    {
      "indent": 3,
      "text": "Remnant configuration is a common example of where the semantic constraints defined in the data model cannot be relied upon for <operational>, since the system may have remnant configuration whose constraints were valid with the previous configuration and that are not valid with the current configuration. Since constraints on \"config false\" nodes may refer to \"config true\" nodes, remnant configuration may force the violation of those constraints.",
      "ja": "残りの構成は、システムがその制約以前の構成と有効であり、現在の構成で有効ではない残りの構成を有することができるので、データモデルで定義されたセマンティック制約は、<動作>のために頼ることができない場合の一般的な例です。 「コンフィグ偽」のノード上の制約は、「コンフィグ真」のノードを参照してください可能性があるため、残りの構成は、これらの制約の違反を強制することがあります。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Missing Resources",
      "section_title": true,
      "ja": "5.3.2。欠落リソース"
    },
    {
      "indent": 3,
      "text": "Configuration in <intended> can refer to resources that are not available or otherwise not physically present. In these situations, these parts of <intended> are not applied. The data appears in <intended> but does not appear in <operational>.",
      "ja": "<意図>での設定は、それ以外の場合は物理的に存在しない利用できないか、リソースを参照することができます。このような状況では、<意図>のこれらの部分は適用されません。データは<意図>に表示されますが、<運用>には表示されません。"
    },
    {
      "indent": 3,
      "text": "A typical example is an interface configuration that refers to an interface that is not currently present. In such a situation, the interface configuration remains in <intended> but the interface configuration will not appear in <operational>.",
      "ja": "典型的な例では、現在存在しないインターフェイスを指すインターフェイスコンフィギュレーションです。このような状況では、インターフェイスコンフィギュレーションは、<意図>に残りますが、インターフェイスコンフィギュレーションは、<運用>には表示されません。"
    },
    {
      "indent": 3,
      "text": "Note that configuration validity cannot depend on the current state of such resources, since that would imply that removing a resource might render the configuration invalid. This is unacceptable, especially given that rebooting such a device would cause it to restart with an invalid configuration. Instead, we allow configuration for missing resources to exist in <running> and <intended>, but it will not appear in <operational>.",
      "ja": "それがリソースを削除すると設定が無効レンダリングかもしれないことを示唆するものであろうから、その設定の妥当性は、そのようなリソースの現在の状態に依存することはできません。これは、特に、そのようなデバイスを再起動すると、それは無効な設定で再起動させるようなことを考えると、容認できません。代わりに、私たちは<ランニング>内に存在するためのリソースが不足しての設定を可能にし、<意図>が、それは、<運用>には表示されません。"
    },
    {
      "indent": 0,
      "text": "5.3.3. System-Controlled Resources",
      "section_title": true,
      "ja": "5.3.3。システム制御によるリソース"
    },
    {
      "indent": 3,
      "text": "Sometimes, resources are controlled by the device and the corresponding system-controlled data appears in (and disappears from) <operational> dynamically. If a system-controlled resource has matching configuration in <intended> when it appears, the system will try to apply the configuration; this causes the configuration to appear in <operational> eventually (if application of the configuration was successful).",
      "ja": "時々動的に<動作>、リソースはデバイスによって制御され、対応するシステム制御データは、に表示され（とから消えます）。それが表示されたら、システム管理されたリソースは、<意図>で設定を一致している場合、システムは、設定を適用しようとします。これは、<運用>最終的には（設定の適用が成功した場合）に表示される設定になります。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Origin Metadata Annotation",
      "section_title": true,
      "ja": "5.3.4。起源のメタデータ注釈"
    },
    {
      "indent": 3,
      "text": "As configuration flows into <operational>, it is conceptually marked with a metadata annotation [RFC7952] that indicates its origin. The origin applies to all configuration nodes except non-presence containers. The \"origin\" metadata annotation is defined in Section 7. The values are YANG identities. The following identities are defined:",
      "ja": "設定は、<運用>に流れると、それは、概念的にその起源を示すメタデータ注釈[RFC7952]とマークされています。原点は、非存在のコンテナを除くすべての構成ノードに適用されます。 「起源」メタデータアノテーションは7節で定義された値は、YANGアイデンティティです。以下のIDが定義されています。"
    },
    {
      "indent": 3,
      "text": "o origin: abstract base identity from which the other origin identities are derived.",
      "ja": "O原産地：他の起源のアイデンティティが派生する抽象ベースのアイデンティティ。"
    },
    {
      "indent": 3,
      "text": "o intended: represents configuration provided by <intended>.",
      "ja": "O意図<意図>によって提供される構成を表します。"
    },
    {
      "indent": 3,
      "text": "o dynamic: represents configuration provided by a dynamic configuration datastore.",
      "ja": "O動的：動的構成データストアによって提供される構成を表します。"
    },
    {
      "indent": 3,
      "text": "o system: represents configuration provided by the system itself. Examples of system configuration include applied configuration for an always-existing loopback interface, or interface configuration that is auto-created due to the hardware currently present in the device.",
      "ja": "Oシステム：システム自体によって提供される構成を表します。システム構成例は、デバイス内に現在存在するハードウェアに自動作成され、常に、既存のループバックインターフェイス、またはインターフェイスコンフィギュレーションのためのコンフィギュレーションを適用することを含みます。"
    },
    {
      "indent": 3,
      "text": "o learned: represents configuration that has been learned via protocol interactions with other systems, including such protocols as link-layer negotiations, routing protocols, and DHCP.",
      "ja": "O学習した：リンク層交渉、ルーティングプロトコル、およびDHCPのようなプロトコルを含む他のシステムとのプロトコル相互作用を介して学習された構成を表します。"
    },
    {
      "indent": 3,
      "text": "o default: represents configuration using a default value specified in the data model, using either values in the \"default\" statement or any values described in the \"description\" statement. The default origin is only used when the configuration has not been provided by any other source.",
      "ja": "Oデフォルト：「説明」文に記載された「デフォルト」のステートメントのいずれかの値を使用してデータ・モデルで指定されたデフォルト値、または任意の値を用いた構成を示しています。設定は、他のソースによって提供されていない場合、デフォルトの原点にのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "o unknown: represents configuration for which the system cannot identify the origin.",
      "ja": "O不明：システムは、原点を識別することができないための設定を表しています。"
    },
    {
      "indent": 3,
      "text": "These identities can be further refined, e.g., there could be separate identities for particular types or instances of dynamic configuration datastores derived from \"dynamic\".",
      "ja": "これらのIDは、特定のタイプまたは「ダイナミック」に由来する動的構成データストアのインスタンスのための別個のアイデンティティが存在し得る、例えば、さらに精製することができます。"
    },
    {
      "indent": 3,
      "text": "For all configuration data nodes in <operational>, the device SHOULD report the origin that most accurately reflects the source of the configuration that is in use by the system.",
      "ja": "<動作>内のすべてのコンフィギュレーションデータノードに対して、デバイスは、最も正確にシステムによって使用されているコンフィギュレーションのソースを反映原点を報告すべきです。"
    },
    {
      "indent": 3,
      "text": "In cases where it could be ambiguous as to which origin should be used, i.e., where the same data node value has originated from multiple sources, the \"description\" statement in the YANG module SHOULD be used as guidance for choosing the appropriate origin. For example:",
      "ja": "同じデータノード値は、複数のソースから発信した原点が使用されるべきであるよう、それは曖昧であり得る場合、すなわち、で、YANGモジュールの「説明」の文は、適切な原点を選択するための指針として使用されるべきです。例えば："
    },
    {
      "indent": 3,
      "text": "If, for a particular configuration node, the associated YANG \"description\" statement indicates that a protocol-negotiated value overrides any configured value, then the origin would be reported as \"learned\", even when a learned value is the same as the configured value.",
      "ja": "、特定の構成ノードのために、関連するYANG「説明」文はプロトコルネゴシエーション値が任意の設定された値をオーバーライドすることを示す場合、「学習した」とは、原点学習値が設定値と同じであっても、報告されます。"
    },
    {
      "indent": 3,
      "text": "Conversely, if, for a particular configuration node, the associated YANG \"description\" statement indicates that a protocol-negotiated value does not override an explicitly configured value, then the origin would be reported as \"intended\", even when a learned value is the same as the configured value.",
      "ja": "逆に、場合は、特定の構成ノードのために、関連するYANG「説明」ステートメントは、次に原点学習値であっても、「意図」として報告されるであろう、プロトコル交渉値が明示的に設定値を上書きしないことを示し設定された値と同じ。"
    },
    {
      "indent": 3,
      "text": "In the case that a device cannot provide an accurate origin for a particular configuration data node, it SHOULD use the origin \"unknown\".",
      "ja": "デバイスは、特定のコンフィギュレーション・データ・ノードの正確な起源を提供することができない場合には、「不明」の起源を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "6. Implications on YANG",
      "section_title": true,
      "ja": "YANG 6.影響"
    },
    {
      "indent": 0,
      "text": "6.1. XPath Context",
      "section_title": true,
      "ja": "6.1。 XPathのコンテキスト"
    },
    {
      "indent": 3,
      "text": "This section updates Section 6.4.1 of RFC 7950.",
      "ja": "このセクションでは、RFC 7950のセクション6.4.1を更新します。"
    },
    {
      "indent": 3,
      "text": "If a server implements the architecture defined in this document, the accessible trees for some XPath contexts are refined as follows:",
      "ja": "サーバがこの文書で定義されたアーキテクチャを実装している場合、次のように、いくつかのXPathコンテキストにアクセスできる木は洗練されています。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents system state, the accessible tree is all operational state in the server. The root node has all top-level data nodes in all modules as children.",
      "ja": "XPath式は、システム状態を表すデータノードにサプで定義されている場合、O、アクセス可能なツリーは、サーバ内のすべての動作状態です。ルートノードは子としてすべてのモジュール内のすべてのトップレベル・データ・ノードを有します。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a \"notification\" statement, the accessible tree is the notification instance and all operational state in the server. If the notification is defined on the top level in a module, then the root node has the node representing the notification being defined and all top-level data nodes in all modules as children. Otherwise, the root node has all top-level data nodes in all modules as children.",
      "ja": "XPath式は「通知」の文にサブステートメントで定義されている場合は、O、アクセスツリーが通知インスタンスおよびサーバー内のすべての動作状態があります。通知は、モジュール内の最上位レベルで定義されている場合、ルートノードは、定義された通知や子供などのすべてのモジュール内のすべてのトップレベルのデータノードを表すノードを有します。そうでなければ、ルートノードは子としてすべてのモジュール内のすべてのトップレベル・データ・ノードを有します。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"input\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance and all operational state in the server. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's input parameters as children.",
      "ja": "XPath式は、「RPC」または「アクション」声明の中で「入力」声明にサブステートメントで定義されているO場合、アクセスツリーはRPCやアクション操作インスタンスおよびサーバー内のすべての動作状態があります。ルートノードは子としてすべてのモジュールのトップレベル・データ・ノードを有します。加えて、RPCのために、ルートノードは、子として定義されるRPC操作を表すノードを有します。定義されている操作を表すノードは、子供のように、操作者の入力パラメータがあります。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"output\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance and all operational state in the server. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's output parameters as children.",
      "ja": "XPath式は、「RPC」または「アクション」声明で「出力」ステートメントにサブステートメントで定義されているO場合、アクセスツリーはRPCやアクション操作インスタンスおよびサーバー内のすべての動作状態があります。ルートノードは子としてすべてのモジュールのトップレベル・データ・ノードを有します。加えて、RPCのために、ルートノードは、子として定義されるRPC操作を表すノードを有します。定義されている操作を表すノードは、子供のように操作の出力パラメータがあります。"
    },
    {
      "indent": 0,
      "text": "6.2. Invocation of Actions and RPCs",
      "section_title": true,
      "ja": "6.2。アクションとRPCの呼び出し"
    },
    {
      "indent": 3,
      "text": "This section updates Section 7.15 of RFC 7950.",
      "ja": "このセクションでは、RFC 7950のセクション7.15を更新します。"
    },
    {
      "indent": 3,
      "text": "Actions are always invoked in the context of the operational state datastore. The node for which the action is invoked MUST exist in the operational state datastore.",
      "ja": "アクションは常に動作状態データストアのコンテキストで呼び出されます。アクションが起動されたノードが動作状態データストアに存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this document does not constrain the result of invoking an RPC or action in any way. For example, an RPC might be defined to modify the contents of some datastore.",
      "ja": "この文書は、どのような方法でRPCまたはアクションを呼び出した結果を制約しないことに注意してください。たとえば、RPCは、いくつかのデータストアの内容を変更するように定義される可能性があります。"
    },
    {
      "indent": 0,
      "text": "7. YANG Modules",
      "section_title": true,
      "ja": "7.モジュール"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-datastores@2018-02-14.yang\"",
      "ja": "ファイル \"ietf-datastores@2018-02-14.yang\" <CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "module ietf-datastores {\n  yang-version 1.1;\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-datastores\";\n  prefix ds;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "organization \"IETF Network Modeling (NETMOD) Working Group\";",
      "ja": "組織「IETFネットワークモデリング（NETMOD）ワーキンググループ」。"
    },
    {
      "indent": 5,
      "text": "contact \"WG Web: <https://datatracker.ietf.org/wg/netmod/>",
      "ja": "「連絡WGのWeb：<https://datatracker.ietf.org/wg/netmod/>"
    },
    {
      "indent": 8,
      "text": "WG List: <mailto:netmod@ietf.org>",
      "ja": "WGリスト：<mailtoの：netmod@ietf.org>"
    },
    {
      "indent": 8,
      "text": "Author: Martin Bjorklund <mailto:mbj@tail-f.com>",
      "ja": "著者：マーティンBjorklund <mailtoの：mbj@tail-f.com>"
    },
    {
      "indent": 8,
      "text": "Author: Juergen Schoenwaelder <mailto:j.schoenwaelder@jacobs-university.de>",
      "ja": "著者：ユルゲンSchoenwaelder <mailtoの：j.schoenwaelder@jacobs-university.de>"
    },
    {
      "indent": 8,
      "text": "Author: Phil Shafer <mailto:phil@juniper.net>",
      "ja": "著者：フィル・シェーファー<mailtoの：phil@juniper.net>"
    },
    {
      "indent": 8,
      "text": "Author: Kent Watsen <mailto:kwatsen@juniper.net>",
      "ja": "著者：ケントWatsen <mailtoの：kwatsen@juniper.net>"
    },
    {
      "indent": 8,
      "text": "Author: Rob Wilton <rwilton@cisco.com>\";",
      "ja": "著者：ロブ・ウィルトン<rwilton@cisco.com> \";"
    },
    {
      "indent": 5,
      "text": "description \"This YANG module defines a set of identities for identifying datastores.",
      "ja": "説明は「このYANGモジュールは、データストアを識別するための識別情報のセットを定義します。"
    },
    {
      "indent": 8,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託コードの作者として特定の人物。全著作権所有。"
    },
    {
      "indent": 8,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info).",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用https://trustee.ietf.org/license-info）。"
    },
    {
      "indent": 8,
      "text": "This version of this YANG module is part of RFC 8342 (https://www.rfc-editor.org/info/rfc8342); see the RFC itself for full legal notices.\";",
      "ja": "このYANGモジュールのこのバージョンは、RFC 8342（https://www.rfc-editor.org/info/rfc8342）の一部です。完全な適法な通知についてはRFC自体を参照してください。 \";"
    },
    {
      "indent": 5,
      "text": "revision 2018-02-14 {\n  description\n    \"Initial revision.\";\n  reference\n    \"RFC 8342: Network Management Datastore Architecture (NMDA)\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * Identities\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity datastore { description \"Abstract base identity for datastore identities.\"; }",
      "ja": "アイデンティティデータストア{説明「データストアのアイデンティティのための抽象ベースのアイデンティティ。」; }"
    },
    {
      "indent": 5,
      "text": "identity conventional {\n  base datastore;\n  description\n    \"Abstract base identity for conventional configuration\n     datastores.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity running {\n  base conventional;\n  description\n    \"The running configuration datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity candidate {\n  base conventional;\n  description\n    \"The candidate configuration datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity startup {\n  base conventional;\n  description\n    \"The startup configuration datastore.\";\n} identity intended {\n  base conventional;\n  description\n    \"The intended configuration datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity dynamic {\n  base datastore;\n  description\n    \"Abstract base identity for dynamic configuration datastores.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity operational {\n  base datastore;\n  description\n    \"The operational state datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * Type definitions\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  typedef datastore-ref {\n    type identityref {\n      base datastore;\n    }\n    description\n      \"A datastore identity reference.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"ietf-origin@2018-02-14.yang\"",
      "ja": "ファイル \"ietf-origin@2018-02-14.yang\" <CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "module ietf-origin {\n  yang-version 1.1;\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-origin\";\n  prefix or;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "import ietf-yang-metadata { prefix md; }",
      "ja": "IETF-陽メタデータ{プレフィックスMDを読み込みます。 }"
    },
    {
      "indent": 5,
      "text": "organization \"IETF Network Modeling (NETMOD) Working Group\";",
      "ja": "組織「IETFネットワークモデリング（NETMOD）ワーキンググループ」。"
    },
    {
      "indent": 5,
      "text": "contact \"WG Web: <https://datatracker.ietf.org/wg/netmod/>",
      "ja": "「連絡WGのWeb：<https://datatracker.ietf.org/wg/netmod/>"
    },
    {
      "indent": 8,
      "text": "WG List: <mailto:netmod@ietf.org>",
      "ja": "WGリスト：<mailtoの：netmod@ietf.org>"
    },
    {
      "indent": 8,
      "text": "Author: Martin Bjorklund <mailto:mbj@tail-f.com>",
      "ja": "著者：マーティンBjorklund <mailtoの：mbj@tail-f.com>"
    },
    {
      "indent": 8,
      "text": "Author: Juergen Schoenwaelder <mailto:j.schoenwaelder@jacobs-university.de>",
      "ja": "著者：ユルゲンSchoenwaelder <mailtoの：j.schoenwaelder@jacobs-university.de>"
    },
    {
      "indent": 8,
      "text": "Author: Phil Shafer <mailto:phil@juniper.net>",
      "ja": "著者：フィル・シェーファー<mailtoの：phil@juniper.net>"
    },
    {
      "indent": 8,
      "text": "Author: Kent Watsen <mailto:kwatsen@juniper.net>",
      "ja": "著者：ケントWatsen <mailtoの：kwatsen@juniper.net>"
    },
    {
      "indent": 8,
      "text": "Author: Rob Wilton <rwilton@cisco.com>\";",
      "ja": "著者：ロブ・ウィルトン<rwilton@cisco.com> \";"
    },
    {
      "indent": 5,
      "text": "description \"This YANG module defines an 'origin' metadata annotation and a set of identities for the origin value.",
      "ja": "説明は「このYANGモジュールは、原点値のための「起源のメタデータの注釈およびアイデンティティのセットを定義します。"
    },
    {
      "indent": 8,
      "text": "Copyright (c) 2018 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "ja": "著作権（C）2018 IETF信託コードの作者として特定の人物。全著作権所有。"
    },
    {
      "indent": 8,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info).",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用https://trustee.ietf.org/license-info）。"
    },
    {
      "indent": 8,
      "text": "This version of this YANG module is part of RFC 8342 (https://www.rfc-editor.org/info/rfc8342); see the RFC itself for full legal notices.\";",
      "ja": "このYANGモジュールのこのバージョンは、RFC 8342（https://www.rfc-editor.org/info/rfc8342）の一部です。完全な適法な通知についてはRFC自体を参照してください。 \";"
    },
    {
      "indent": 5,
      "text": "revision 2018-02-14 {\n  description\n    \"Initial revision.\";\n  reference\n    \"RFC 8342: Network Management Datastore Architecture (NMDA)\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * Identities\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity origin { description \"Abstract base identity for the origin annotation.\"; }",
      "ja": "同一起源{説明「原点注釈のための抽象ベースアイデンティティ。」; }"
    },
    {
      "indent": 5,
      "text": "identity intended {\n  base origin;\n  description\n    \"Denotes configuration from the intended configuration\n     datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity dynamic {\n  base origin;\n  description\n    \"Denotes configuration from a dynamic configuration\n     datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity system { base origin; description \"Denotes configuration originated by the system itself.",
      "ja": "アイデンティティシステム{塩基原点。説明は、「システム自体が発信した構成を示します。"
    },
    {
      "indent": 5,
      "text": "     Examples of system configuration include applied configuration\n     for an always-existing loopback interface, or interface\n     configuration that is auto-created due to the hardware\n     currently present in the device.\";\n} identity learned {\n  base origin;\n  description\n    \"Denotes configuration learned from protocol interactions with\n     other devices, instead of via either the intended\n     configuration datastore or any dynamic configuration\n     datastore.",
      "raw": true
    },
    {
      "indent": 5,
      "text": " Examples of protocols that provide learned configuration include link-layer negotiations, routing protocols, and DHCP.\"; }",
      "ja": "学習された構成を提供するプロトコルの例は、リンク層交渉、ルーティングプロトコル、およびDHCPを含みます \";}"
    },
    {
      "indent": 5,
      "text": "identity default {\n  base origin;\n  description\n    \"Denotes configuration that does not have a configured or\n     learned value but has a default value in use.  Covers both\n     values defined in a 'default' statement and values defined\n     via an explanation in a 'description' statement.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "identity unknown {\n  base origin;\n  description\n    \"Denotes configuration for which the system cannot identify the\n     origin.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * Type definitions\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "typedef origin-ref {\n  type identityref {\n    base origin;\n  }\n  description\n    \"An origin identity reference.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/*\n * Metadata annotations\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  md:annotation origin {\n    type origin-ref;\n    description\n      \"The 'origin' annotation can be present on any configuration\n       data node in the operational state datastore.  It specifies\n       from where the node originated.  If not specified for a given\n       configuration data node, then the origin is the same as the\n       origin of its parent node in the data tree.  The origin for\n       any top-level configuration data nodes must be specified.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Updates to the IETF XML Registry",
      "section_title": true,
      "ja": "8.1。 IETF XMLレジストリの更新"
    },
    {
      "indent": 3,
      "text": "This document registers two URIs in the \"IETF XML Registry\" [RFC3688]. Following the format in [RFC3688], the following registrations have been made:",
      "ja": "この文書では、「IETF XMLレジストリ」[RFC3688]で2つのURIを登録します。 [RFC3688]でフォーマットした後、以下の登録が行われています。"
    },
    {
      "indent": 6,
      "text": "URI: urn:ietf:params:xml:ns:yang:ietf-datastores Registrant Contact: The IESG. XML: N/A; the requested URI is an XML namespace.",
      "ja": "URI：URN：IETF：のparams：XML：NS：ヤン：IETF-データストアの登録者の連絡先：IESG。 XML：N / A。要求されたURIは、XML名前空間です。"
    },
    {
      "indent": 6,
      "text": "URI: urn:ietf:params:xml:ns:yang:ietf-origin Registrant Contact: The IESG. XML: N/A; the requested URI is an XML namespace.",
      "ja": "URI：URN：IETF：のparams：XML：NS：ヤン：IETF-起源登録者連絡先：IESG。 XML：N / A。要求されたURIは、XML名前空間です。"
    },
    {
      "indent": 0,
      "text": "8.2. Updates to the YANG Module Names Registry",
      "section_title": true,
      "ja": "8.2。 YANGモジュール名レジストリの更新"
    },
    {
      "indent": 3,
      "text": "This document registers two YANG modules in the \"YANG Module Names\" registry [RFC6020]. Following the format in [RFC6020], the following registrations have been made:",
      "ja": "この文書は、「YANGモジュール名」レジストリ[RFC6020]で2つのYANGモジュールを登録します。 [RFC6020]でフォーマットした後、以下の登録が行われています。"
    },
    {
      "indent": 6,
      "text": "name: ietf-datastores namespace: urn:ietf:params:xml:ns:yang:ietf-datastores prefix: ds reference: RFC 8342",
      "ja": "名前：IETF-データストアの名前空間：URN：IETF：のparams：XML：NS：ヤン：IETF-データストアのプレフィックス：DS参照：RFC 8342"
    },
    {
      "indent": 6,
      "text": "name: ietf-origin namespace: urn:ietf:params:xml:ns:yang:ietf-origin prefix: or reference: RFC 8342",
      "ja": "名前：IETF-起源の名前空間：URN：IETF：のparams：XML：NS：ヤン：IETF-起源の接頭辞：または参照：RFC 8342"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document discusses an architectural model of datastores for network management using NETCONF/RESTCONF and YANG. It has no security impact on the Internet.",
      "ja": "この文書では、NETCONF / RESTCONFとYANGを使用して、ネットワーク管理のためのデータストアのアーキテクチャモデルについて説明します。これは、インターネット上ではセキュリティへの影響はありません。"
    },
    {
      "indent": 3,
      "text": "Although this document specifies several YANG modules, these modules only define identities and a metadata annotation; hence, the \"YANG module security guidelines\" [YANG-SEC] do not apply.",
      "ja": "この文書は、いくつかのYANGモジュールを指定しますが、これらのモジュールは、唯一のアイデンティティとメタデータアノテーションを定義します。それゆえ、「YANGモジュールのセキュリティガイドライン」[YANG-SEC]は適用されません。"
    },
    {
      "indent": 3,
      "text": "The origin metadata annotation exposes the origin of values in the applied configuration. Origin information may provide hints that certain control-plane protocols are active on a device. Since origin information is tied to applied configuration values, it is only accessible to clients that have the permissions to read the applied configuration values. Security administrators should consider the sensitivity of origin information while defining access control rules.",
      "ja": "原点メタデータアノテーションは適用される設定値の起源を公開します。原点情報は、特定の制御プレーンプロトコルは、デバイス上でアクティブであるヒントを提供することができます。原点情報が適用された設定値に固定されているので、それが適用される設定値を読み取るための権限を持っているクライアントにのみアクセス可能です。アクセス制御ルールを定義しながら、セキュリティ管理者は、原点情報の感度を考慮すべきです。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <https://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 \"ネットワーク構成プロトコル（NETCONF）\"、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<https://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <https://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M.編、 \"YANG 1.1データモデリング言語\"、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<https://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 3,
      "text": "[RFC7952] Lhotka, L., \"Defining and Using Metadata with YANG\", RFC 7952, DOI 10.17487/RFC7952, August 2016, <https://www.rfc-editor.org/info/rfc7952>.",
      "ja": "[RFC7952] Lhotka、L.、 \"定義とYANGでメタデータを使用する\"、RFC 7952、DOI 10.17487 / RFC7952、2016年8月、<https://www.rfc-editor.org/info/rfc7952>。"
    },
    {
      "indent": 3,
      "text": "[RFC8040] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017, <https://www.rfc-editor.org/info/rfc8040>.",
      "ja": "[RFC8040] Bierman、A. Bjorklund、M.、およびK. Watsen、 \"RESTCONFプロトコル\"、RFC 8040、DOI 10.17487 / RFC8040、2017年1月、<https://www.rfc-editor.org/info/rfc8040 >。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xml-20081126] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <https://www.w3.org/TR/2008/REC-xml-20081126>.",
      "ja": "[W3C.REC-XML-20081126]ブレイ、T.、パオリ、J.、Sperberg-マックイーン、M.、MALER、E.、およびF. Yergeau、 \"拡張マークアップ言語（XML）1.0（第5版）\"、 World Wide Web Consortium（W3C）の勧告REC-XML-20081126、2008年11月、<https://www.w3.org/TR/2008/REC-xml-20081126>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[NETMOD-Operational] Bjorklund, M. and L. Lhotka, \"Operational Data in NETCONF and YANG\", Work in Progress, draft-bjorklund-netmod-operational-00, October 2012.",
      "ja": "[NETMOD  - 動作] Bjorklund、M.およびL. Lhotka、 \"NETCONFとYANGにおけるオペレーショナルデータ\" が進行中で働いて、ドラフトbjorklund-netmod-運用-00、2012年10月。"
    },
    {
      "indent": 3,
      "text": "[OpState-Enhance] Watsen, K., Bierman, A., Bjorklund, M., and J. Schoenwaelder, \"Operational State Enhancements for YANG, NETCONF, and RESTCONF\", Work in Progress, draft-kwatsen-netmod-opstate-02, February 2016.",
      "ja": "【のOpStateエンハンス] Watsen、K.、Bierman、A.、Bjorklund、M.、およびJ. Schoenwaelder、 \"YANG、NETCONF、及びRESTCONFの運用状態の強化\"、進行中で働いて、ドラフトkwatsen-netmod-opstate- 02、2016年2月。"
    },
    {
      "indent": 3,
      "text": "[OpState-Modeling] Shakir, R., Shaikh, A., and M. Hines, \"Consistent Modeling of Operational State Data in YANG\", Work in Progress, draft-openconfig-netmod-opstate-01, July 2015.",
      "ja": "[のOpState-モデル] Shakir、R.、シェイク、A.、およびM.ハインズ、 \"YANGにおけるオペレーショナル状態データの一貫性のあるモデル\" が進行中で働いて、ドラフトopenconfig-netmod-のOpState-01、2015月。"
    },
    {
      "indent": 3,
      "text": "[OpState-Reqs] Watsen, K. and T. Nadeau, \"Terminology and Requirements for Enhanced Handling of Operational State\", Work in Progress, draft-ietf-netmod-opstate-reqs-04, January 2016.",
      "ja": "[のOpState-要求数] Watsen、K.およびT.ナドー、 \"用語や動作状態を強化取扱いのための要件\" が進行中で働いて、ドラフト-IETF-netmod-のOpState-REQS-04、2016年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, DOI 10.17487/RFC3688, January 2004, <https://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、DOI 10.17487 / RFC3688、2004年1月、<https://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <https://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M.、エド、 \"YANG  - ネットワーク構成プロトコルのためのデータモデリング言語（NETCONF）\"、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<HTTPS：。//www.rfc-editor。組織/情報/ rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC6244] Shafer, P., \"An Architecture for Network Management Using NETCONF and YANG\", RFC 6244, DOI 10.17487/RFC6244, June 2011, <https://www.rfc-editor.org/info/rfc6244>.",
      "ja": "[RFC6244]シェーファー、P.、 \"NETCONFとYANGを使用したネットワーク管理のためのアーキテクチャ\"、RFC 6244、DOI 10.17487 / RFC6244、2011年6月、<https://www.rfc-editor.org/info/rfc6244>。"
    },
    {
      "indent": 3,
      "text": "[RFC8343] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 8343, DOI 10.17487/RFC8343, March 2018, <https://www.rfc-editor.org/info/rfc8343>.",
      "ja": "[RFC8343] Bjorklund、M.、 \"インターフェイスの管理のためのYANGデータモデル\"、RFC 8343、DOI 10.17487 / RFC8343、2018年3月、<https://www.rfc-editor.org/info/rfc8343>。"
    },
    {
      "indent": 3,
      "text": "[RFC8344] Bjorklund, M., \"A YANG Data Model for IP Management\", RFC 8344, DOI 10.17487/RFC8344, March 2018, <https://www.rfc-editor.org/info/rfc8344>.",
      "ja": "[RFC8344] Bjorklund、M.、 \"IP管理のためのYANGデータモデル\"、RFC 8344、DOI 10.17487 / RFC8344、2018年3月、<https://www.rfc-editor.org/info/rfc8344>。"
    },
    {
      "indent": 3,
      "text": "[With-config-state] Wilton, R., \"\"With-config-state\" Capability for NETCONF/RESTCONF\", Work in Progress, draft-wilton-netmod-opstate-yang-02, December 2015.",
      "ja": "[WITH-config設定状態]ウィルトン、R.、 \"NETCONF / RESTCONF用\" で-config設定状態 \"能力\" が進行中で働いて、ドラフト・ウィルトン・netmod-のOpState陽-02、2015年12月。"
    },
    {
      "indent": 3,
      "text": "[YANG-SEC] IETF, \"YANG Security Guidelines\", <https://trac.ietf.org/ trac/ops/wiki/yang-security-guidelines>.",
      "ja": "[SEC] IETF、 \"セキュリティガイドライン\"、<https://trac.ietf.org/ tracの/ OPS /ウィキ/セキュリティ・ガイドライン>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Guidelines for Defining Datastores",
      "ja": "定義データストアのための付録A.ガイドライン"
    },
    {
      "indent": 3,
      "text": "The definition of a new datastore in this architecture should be provided in a document (e.g., an RFC) purposed for defining the datastore. When it makes sense, more than one datastore may be defined in the same document (e.g., when the datastores are logically connected). Each datastore's definition should address the points specified in the subsections below.",
      "ja": "このアーキテクチャで新しいデータストアの定義は、データストアを定義するための目的とドキュメント（例えば、RFC）に提供されるべきです。それは理にかなっている場合、複数のデータストアが同一の文書内に定義されてもよい（例えば、データストアは、論理的に接続されている場合）。各データストアの定義は、以下のサブセクションで指定されたポイントに対処すべきです。"
    },
    {
      "indent": 0,
      "text": "A.1. Define Which YANG Modules Can Be Used in the Datastore",
      "ja": "A.1。 YANGモジュールは、データストアで使用することができるかを定義"
    },
    {
      "indent": 3,
      "text": "Not all YANG modules may be used in all datastores. Some datastores may constrain which data models can be used in them. If it is desirable that a subset of all modules can be targeted to the datastore, then the documentation defining the datastore must indicate this.",
      "ja": "すべてYANGモジュールはすべてのデータストアで使用できるわけではありません。いくつかのデータストアは、データモデルがそれらに使用できる制約することがあります。それはすべてのモジュールのサブセットがデータストアを標的とすることができることが望ましい場合には、データストアを定義するドキュメントでは、このことを示す必要があります。"
    },
    {
      "indent": 0,
      "text": "A.2. Define Which Subset of YANG-Modeled Data Applies",
      "ja": "A.2。 YANG-モデル化されたデータのサブセットが適用される定義"
    },
    {
      "indent": 3,
      "text": "By default, the data in a datastore is modeled by all YANG statements in the available YANG modules. However, it is possible to specify criteria that YANG statements must satisfy in order to be present in a datastore. For instance, maybe only \"config true\" nodes, or \"config false\" nodes that also have a specific YANG extension, are present in the datastore.",
      "ja": "デフォルトでは、データストア内のデータが利用可能YANGモジュール内のすべてのYANG文によってモデル化されます。しかし、YANG文がデータストアに存在するために満たさなければならない条件を指定することが可能です。例えば、また、特定のYANG拡張子を持っているかもしれない唯一の「コンフィグ真」ノード、または「コンフィグ偽」のノードは、データストアに存在しています。"
    },
    {
      "indent": 0,
      "text": "A.3. Define How Data Is Actualized",
      "ja": "A.3。データは実現してどのように定義します"
    },
    {
      "indent": 3,
      "text": "The new datastore must specify how it interacts with other datastores.",
      "ja": "新しいデータストアは、他のデータストアとどのように相互作用するかを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, the diagram in Section 5 depicts dynamic configuration datastores feeding into <operational>. How this interaction occurs has to be defined by the particular dynamic configuration datastores. In some cases, it may occur implicitly, as soon as the data is put into the dynamic configuration datastore, while in other cases an explicit action (e.g., an RPC) may be required to trigger the application of the datastore's data.",
      "ja": "例えば、第5の図は、<動作>に供給動的構成データストアを示しています。どのようにこの相互作用が発生することは、特定の動的構成データストアで定義する必要があります。データは、動的構成データストアに置かれるように、他の場合には明示的なアクション（例えば、RPC）は、データストアのデータのアプリケーションをトリガするために必要とされるかもしれないいくつかのケースでは、それは、とすぐに、暗黙的に起こり得ます。"
    },
    {
      "indent": 0,
      "text": "A.4. Define Which Protocols Can Be Used",
      "ja": "A.4。プロトコルを使用できる定義"
    },
    {
      "indent": 3,
      "text": "By default, it is assumed that both the NETCONF and RESTCONF protocols can be used to interact with a datastore. However, it may be that only a specific protocol can be used (e.g., Forwarding and Control Element Separation (ForCES)) or that a subset of all protocol operations or capabilities are available (e.g., no locking or no XPath-based filtering).",
      "ja": "デフォルトでは、NETCONFとRESTCONF両方のプロトコルは、データストアと対話するために使用できるものとします。しかし、それだけで特定のプロトコル（例えば、転送および制御素子分離（力））を使用することができることであってもよいし、すべてのプロトコル操作または機能のサブセット（例えば、ノーロック又は全くXPathベースのフィルタリング）が利用可能であること。"
    },
    {
      "indent": 0,
      "text": "A.5. Define YANG Identities for the Datastore",
      "ja": "A.5。データストア用YANGアイデンティティを定義します。"
    },
    {
      "indent": 3,
      "text": "The datastore must be defined with a YANG identity that uses the \"ds:datastore\" identity, or one of its derived identities, as its base. This identity is necessary, so that the datastore can be referenced in protocol operations (e.g., <get-data>).",
      "ja": "そのベースとして、アイデンティティ、またはその派生IDのいずれか：データストアは、「データストアDS」を使用していますYANG IDで定義する必要があります。データストアは、プロトコル動作（例えば、<GETデータ>）で参照することができるように、この同一性は、必要です。"
    },
    {
      "indent": 3,
      "text": "The datastore may also be defined with an identity that uses the \"or:origin\" identity, or one of its derived identities, as its base. This identity is needed if the datastore interacts with <operational>, so that data originating from the datastore can be identified as such via the \"origin\" metadata attribute defined in Section 7.",
      "ja": "そのベースとして、「起源または」同一性、又はその派生IDのいずれかのデータストアも使用アイデンティティと定義することができます。データストアからのデータは、第7節で定義された「起源」メタデータ属性を経由してそのように識別できるように、データストアは、<運用>と相互作用している場合、このアイデンティティが必要とされています。"
    },
    {
      "indent": 3,
      "text": "An example of these guidelines in use is provided in Appendix B.",
      "ja": "使用中のこれらのガイドラインの例は、付録Bに提供され"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example of an Ephemeral Dynamic Configuration Datastore",
      "ja": "エフェメラル動的構成データストアの付録B.例"
    },
    {
      "indent": 3,
      "text": "This section defines documentation for an example dynamic configuration datastore using the guidelines provided in Appendix A. For brevity, only a terse example is provided; it is expected that a standalone RFC would be written when this type of scenario is fully considered.",
      "ja": "このセクションでは、簡潔にするために、付録Aに提供されるガイドラインを使用して、例えば動的構成データストアのドキュメントを定義し、だけ簡潔な例が提供されます。このタイプのシナリオが十分考慮されたときに、スタンドアロンのRFCが書かれることが期待されます。"
    },
    {
      "indent": 3,
      "text": "This example defines a dynamic configuration datastore called \"ephemeral\", which is loosely modeled after the work done in the I2RS Working Group.",
      "ja": "この例では緩くI2RSワーキンググループで行われた作業の後にモデル化された「はかない」と呼ばれる動的な構成データストアを定義します。"
    },
    {
      "indent": 3,
      "text": "+--------------------+----------------------------------------------+\n| Name               | Value                                        |\n+--------------------+----------------------------------------------+\n| Name               | ephemeral                                    |\n|                    |                                              |\n| YANG modules       | all (default)                                |\n|                    |                                              |\n| YANG nodes         | all \"config true\" data nodes                 |\n|                    |                                              |\n| How applied        | changes automatically propagated to          |\n|                    | <operational>                                |\n|                    |                                              |\n| Protocols          | NETCONF/RESTCONF (default)                   |\n|                    |                                              |\n| Defining YANG      | \"example-ds-ephemeral\"                       |\n| module             |                                              |\n+--------------------+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Properties of the Example \"ephemeral\" Datastore",
      "ja": "例「はかない」データストアのプロパティ"
    },
    {
      "indent": 3,
      "text": "module example-ds-ephemeral {\n  yang-version 1.1;\n  namespace \"urn:example:ds-ephemeral\";\n  prefix eph;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "import ietf-datastores {\n  prefix ds;\n}\nimport ietf-origin {\n  prefix or;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "// datastore identity\nidentity ds-ephemeral {\n  base ds:dynamic;\n  description\n    \"The ephemeral dynamic configuration datastore.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  // origin identity\n  identity or-ephemeral {\n    base or:dynamic;\n    description\n      \"Denotes data from the ephemeral dynamic configuration\n       datastore.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Data",
      "ja": "付録C.データ例"
    },
    {
      "indent": 3,
      "text": "The use of datastores is complex, and many of the subtle effects are more easily presented using examples. This section presents a series of example data models with some sample contents of the various datastores.",
      "ja": "データストアの使用は複雑であり、微妙な効果の多くは、より簡単に例を使用して提示されています。このセクションでは、さまざまなデータストアのいくつかのサンプル内容と例のデータモデルのシリーズを提示しています。"
    },
    {
      "indent": 3,
      "text": "The XML [W3C.REC-xml-20081126] snippets that follow are provided as examples only.",
      "ja": "フォローは例としてのみ提供されているXML [W3C.REC-XML-20081126]スニペット。"
    },
    {
      "indent": 0,
      "text": "C.1. System Example",
      "ja": "C.1。システム例"
    },
    {
      "indent": 3,
      "text": "In this example, the following fictional module is used:",
      "ja": "この例では、次の架空のモジュールが使用されます。"
    },
    {
      "indent": 3,
      "text": "module example-system {\n  yang-version 1.1;\n  namespace urn:example:system;\n  prefix sys;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "import ietf-inet-types { prefix inet; }",
      "ja": "IETF-INET-タイプ{プレフィックスINETインポート。 }"
    },
    {
      "indent": 5,
      "text": "container system { leaf hostname { type string; }",
      "ja": "容器システム{葉ホスト{文字列型。 }"
    },
    {
      "indent": 7,
      "text": "list interface { key name;",
      "ja": "リストインターフェース{キー名。"
    },
    {
      "indent": 9,
      "text": "leaf name { type string; }",
      "ja": "葉名{文字列型。 }"
    },
    {
      "indent": 9,
      "text": "container auto-negotiation {\n  leaf enabled {\n    type boolean;\n    default true;\n  }\n  leaf speed {\n    type uint32;\n    units mbps;\n    description\n      \"The advertised speed, in Mbps.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "leaf speed {\n  type uint32;\n  units mbps;\n  config false;\n  description\n    \"The speed of the interface, in Mbps.\";\n} list address {\n  key ip;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        leaf ip {\n          type inet:ip-address;\n        }\n        leaf prefix-length {\n          type uint8;\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The operator has configured the hostname and two interfaces, so the contents of <intended> are:",
      "ja": "オペレータは、ホスト名と二つのインターフェース、そう<意図>であるの内容を設定しています。"
    },
    {
      "indent": 3,
      "text": "<system xmlns=\"urn:example:system\">",
      "ja": "<システムのxmlns = \"URN：例：システム\">"
    },
    {
      "indent": 5,
      "text": "<hostname>foo.example.com</hostname>",
      "ja": "<ホスト名> foo.example.com </ホスト名>"
    },
    {
      "indent": 5,
      "text": "<interface> <name>eth0</name> <auto-negotiation> <speed>1000</speed> </auto-negotiation> <address> <ip>2001:db8::10</ip> <prefix-length>64</prefix-length> </address> </interface>",
      "ja": "<インターフェース> <名前>はeth0 </名前> <オートネゴシエーション> <スピード> 1000年</スピード> </自動ネゴシエーション> <アドレス> <IP> 2001：DB8 :: 10 </ IP> <プレフィックス長> 64 </プレフィックス長> </アドレス> </インターフェース>"
    },
    {
      "indent": 5,
      "text": "<interface> <name>eth1</name> <address> <ip>2001:db8::20</ip> <prefix-length>64</prefix-length> </address> </interface>",
      "ja": "<インターフェース> <名前> eth1の</名前> <アドレス> <IP> 2001：DB8 :: 20 </ IP> <プレフィックス長> 64 </プレフィックス長> </アドレス> </インターフェイス>"
    },
    {
      "indent": 3,
      "text": "</system>",
      "ja": "</システム>"
    },
    {
      "indent": 3,
      "text": "The system has detected that the hardware for one of the configured interfaces (\"eth1\") is not yet present, so the configuration for that interface is not applied. Further, the system has received a hostname and an additional IP address for \"eth0\" over DHCP. In addition to filling in the default value for the auto-negotiation enabled leaf, a loopback interface entry is also automatically instantiated by the system. All of this is reflected in <operational>. Note how the \"origin\" metadata attribute for several \"config true\" data nodes is inherited from their parent data nodes.",
      "ja": "システムは、設定されたインターフェイスのためのハードウェア（「eth1が」）はまだ存在しないので、そのインターフェイスの構成が適用されていないことを検出しました。さらに、システムは、ホスト名とDHCPオーバー「はeth0」のための追加のIPアドレスを受信しました。自動ネゴシエーションが有効葉のデフォルト値を記入することに加えて、ループバックインターフェイスのエントリもシステムによって自動的にインスタンス化されます。このすべては、<運用>に反映されています。いくつかの「コンフィグ真」データノードのための「起源」のメタデータ属性は、親データノードから継承されるかに注意してください。"
    },
    {
      "indent": 3,
      "text": "<system xmlns=\"urn:example:system\" xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\">",
      "ja": "<システムのxmlns = \"URN：例：システム\" のxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF原点\">"
    },
    {
      "indent": 5,
      "text": "<hostname or:origin=\"or:learned\">bar.example.com</hostname>",
      "ja": "<ホスト名または：起源= \"または：学んだ\"> bar.example.com </ホスト名>"
    },
    {
      "indent": 5,
      "text": "<interface or:origin=\"or:intended\"> <name>eth0</name> <auto-negotiation> <enabled or:origin=\"or:default\">true</enabled> <speed>1000</speed> </auto-negotiation> <speed>100</speed> <address> <ip>2001:db8::10</ip> <prefix-length>64</prefix-length> </address> <address or:origin=\"or:learned\"> <ip>2001:db8::1:100</ip> <prefix-length>64</prefix-length> </address> </interface>",
      "ja": "<インターフェイスまたは：起源= \"または：意図\"> <名前>はeth0 </名前> <オートネゴシエーション> <有効か：起源= \"または：デフォルト\">真<スピード> 1000年</スピード> </有効化> </自動ネゴシエーション> <スピード> 100 </スピード> <アドレス> <IP> 2001：DB8 :: 10 </ IP> <プレフィックス長> 64 </プレフィックス長> </アドレス> <アドレスまたは：起源= \"または：学んだ\"> <IP> 2001：DB8 :: 1：100 </ IP> <プレフィックス長> 64 </プレフィックス長> </アドレス> </インターフェイス>"
    },
    {
      "indent": 5,
      "text": "<interface or:origin=\"or:system\"> <name>lo0</name> <address> <ip>::1</ip> <prefix-length>128</prefix-length> </address> </interface>",
      "ja": "<インターフェイスまたは：起源= \"または：システム\"> <名前> LO0 </名前> <アドレス> <IP> :: 1 </ IP> <プレフィックス長> 128 </プレフィックス長> </アドレス> < /インターフェイス>"
    },
    {
      "indent": 3,
      "text": "</system>",
      "ja": "</システム>"
    },
    {
      "indent": 0,
      "text": "C.2. BGP Example",
      "ja": "C.2。 BGP例"
    },
    {
      "indent": 3,
      "text": "Consider the following fragment of a fictional BGP module:",
      "ja": "架空のBGPモジュールの次のコードを考えてみましょう。"
    },
    {
      "indent": 7,
      "text": "container bgp {\n  leaf local-as {\n    type uint32;\n  }\n  leaf peer-as {\n    type uint32;\n  }\n  list peer {\n    key name;\n    leaf name {\n      type inet:ip-address;\n    }\n    leaf local-as {\n      type uint32;\n      description\n        \"... Defaults to ../local-as.\";\n    }\n    leaf peer-as {\n      type uint32;\n      description\n        \"... Defaults to ../peer-as.\";\n    }\n    leaf local-port {\n      type inet:port;\n    }\n    leaf remote-port {\n      type inet:port;\n      default 179;\n    }\n    leaf state {\n      config false;\n      type enumeration {\n        enum init;\n        enum established;\n        enum closing;\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this example model, both bgp/peer/local-as and bgp/peer/peer-as have complex hierarchical values, allowing the user to specify default values for all peers in a single location.",
      "ja": "この例のモデルでは、両方のBGP /ピア/ローカル-ASおよびBGP /ピア/ピアように、ユーザが単一の場所にあるすべてのピアのデフォルト値を指定することができ、複雑な階層値を有します。"
    },
    {
      "indent": 3,
      "text": "The model also follows the pattern of fully integrating state (\"config false\") nodes with configuration (\"config true\") nodes. There is no separate \"bgp-state\" hierarchy, with the accompanying repetition of containment and naming nodes. This makes the model simpler and more readable.",
      "ja": "モデルはまた、コンフィギュレーション（「コンフィグ真」）ノードと完全に統合する状態（「コンフィグ偽」）ノードのパターンに従います。別途「BGP-状態」の階層は、封じ込めおよびノー​​ドを命名添付の繰り返しで、ありません。このモデルは、よりシンプルで読みやすくなります。"
    },
    {
      "indent": 0,
      "text": "C.2.1. Datastores",
      "ja": "C.2.1。データストア"
    },
    {
      "indent": 3,
      "text": "Each datastore represents differing views of these nodes. <running> will hold the configuration provided by the operator -- for example, a single BGP peer. <intended> will conceptually hold the data as validated, after the removal of data not intended for validation and after any local template mechanisms are performed. <operational> will show data from <intended> as well as any \"config false\" nodes.",
      "ja": "各データストアは、これらのノードの異なる見解を表しています。 <実行>オペレータによって提供される構成を保持する - 例えば、単一のBGPピアを。検証として<意図>概念的検証のため、任意のローカル・テンプレート・メカニズムが実行された後に意図していないデータを除去した後、データを保持します。 <操作> <意図>だけでなく、任意の「コンフィグ偽」のノードからのデータが表示されます。"
    },
    {
      "indent": 0,
      "text": "C.2.2. Adding a Peer",
      "ja": "C.2.2。ピアを追加します"
    },
    {
      "indent": 3,
      "text": "If the user configures a single BGP peer, then that peer will be visible in both <running> and <intended>. It may also appear in <candidate> if the server supports the candidate configuration datastore. Retrieving the peer will return only the user-specified values.",
      "ja": "ユーザは、単一のBGPピアを構成した場合、そのピアは、両方の<実行>と<意図>に表示されます。サーバは候補コンフィギュレーションデータストアをサポートしている場合にも、<候補>に表示される場合があります。ピアを取得すると、ユーザー指定の値のみを返します。"
    },
    {
      "indent": 3,
      "text": "No time delay should exist between the appearance of the peer in <running> and <intended>.",
      "ja": "何時間遅延は、<実行>にピアの出現との間に存在しないと<意図>すべきです。"
    },
    {
      "indent": 3,
      "text": "In this scenario, we've added the following to <running>:",
      "ja": "このシナリオでは、我々は<ランニング>に以下を追加しました："
    },
    {
      "indent": 5,
      "text": "<bgp> <local-as>64501</local-as> <peer-as>64502</peer-as> <peer> <name>2001:db8::2:3</name> </peer> </bgp>",
      "ja": "<BGP> <ローカル-AS> 64501 </ローカル-AS> <ピアとして> 64502 </ピアとして> <ピア> <名前> 2001：DB8 :: 2：3 </名前> </ピア> < / BGP>"
    },
    {
      "indent": 0,
      "text": "C.2.2.1. <operational>",
      "ja": "C.2.2.1。 <運用>"
    },
    {
      "indent": 3,
      "text": "The operational datastore will contain the fully expanded peer data, including \"config false\" nodes. In our example, this means that the \"state\" node will appear.",
      "ja": "オペレーショナルデータストアは、「コンフィグ偽」ノードを含め完全に拡張されたピアデータを、含まれています。この例では、これは「状態」ノードが表示されることを意味します。"
    },
    {
      "indent": 3,
      "text": "In addition, <operational> will contain the \"currently in use\" values for all nodes. This means that local-as and peer-as will be populated even if they are not given values in <intended>. The value of bgp/local-as will be used if bgp/peer/local-as is not provided; bgp/peer-as and bgp/peer/peer-as will have the same relationship. In the operational view, this means that every peer will have values for their local-as and peer-as, even if those values are not explicitly configured but are provided by bgp/local-as and bgp/peer-as.",
      "ja": "また、<運用>すべてのノードに対して、「現在使用中」の値が含まれます。これは、それらが<意図>の値が与えられていない場合でもとしてローカルおよびピアが-として取り込まれることを意味します。ローカルとしてBGP /ピア/ローカルとして提供されていない場合に使用されるBGP /の値; BGP /ピアなどとBGP /ピア/同じ関係を持つことになりますピアとして。運用ビューでは、これはすべてのピアが地元-などとそれらの値が明示的に設定されていないが、ローカル-としてBGP /およびBGP /ピアなどによって提供されている場合でも、ピアなどの値を持つことになります。"
    },
    {
      "indent": 3,
      "text": "Each BGP peer has a TCP connection associated with it, using the values of local-port and remote-port from <intended>. If those values are not supplied, the system will select values. When the connection is established, <operational> will contain the current values for the local-port and remote-port nodes regardless of the origin. If the system has chosen the values, the \"origin\" attribute will be set to \"system\". Before the connection is established, one or both of the nodes may not appear, since the system may not yet have their values.",
      "ja": "各BGPピアは<意図>からローカルポート及びリモートポートの値を使用して、それに関連付けられたTCP接続を有します。これらの値が提供されていない場合は、システムが値を選択します。接続が確立されると、<動作>にかかわらず起源のローカルポート及びリモートポートノードの現在の値を含むであろう。システムが値を選択した場合は、「起源」属性は「システム」に設定されます。接続が確立される前にシステムがまだそれらの値を有していなくてもよいので、ノードの一方または両方は、表示されないことがあります。"
    },
    {
      "indent": 5,
      "text": "<bgp xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\" or:origin=\"or:intended\"> <local-as>64501</local-as> <peer-as>64502</peer-as> <peer> <name>2001:db8::2:3</name> <local-as or:origin=\"or:default\">64501</local-as> <peer-as or:origin=\"or:default\">64502</peer-as> <local-port or:origin=\"or:system\">60794</local-port> <remote-port or:origin=\"or:default\">179</remote-port> <state>established</state> </peer> </bgp>",
      "ja": "<BGPのxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF-起源\" または：原点= \"または：意図\"> <ローカル-AS> 64501 </ローカル-AS> <ピアとして> 64502 </ピアなど> <ピア> <名前> 2001：DB8 :: 2：3 </名前> <ローカル-として、あるいは：起源= \"または：デフォルト\"> 64501 </ローカル-など> <ピアなど又は：原点=「またはデフォルト」> 64502 </ピアとして> <ローカルポートまたは：原点=「または：システム」> 60794 </ローカルポート> <リモートポートまたは：原点= \"またはデフォルト「> 179 </リモートポート> <状態> </状態> </ピア> </ BGP>確立"
    },
    {
      "indent": 0,
      "text": "C.2.3. Removing a Peer",
      "ja": "C.2.3。ピアを削除します"
    },
    {
      "indent": 3,
      "text": "Changes to configuration may take time to percolate through the various software components involved. During this period, it is imperative to continue to give an accurate view of the working of the device. <operational> will contain nodes for both the previous and current configuration, as closely as possible tracking the current operation of the device.",
      "ja": "設定の変更が含まれる様々なソフトウェアコンポーネントを通じて浸透するには時間がかかることがあります。この期間中には、デバイスの動作の正確なビューを提供し続けることが不可欠です。 <動作>デバイスの現在の動作を追跡可能な限り厳密に、以前と現在の設定の両方のノードを含むであろう。"
    },
    {
      "indent": 3,
      "text": "Consider the scenario where a client removes a BGP peer. When a peer is removed, the operational state will continue to reflect the existence of that peer until the peer's resources are released, including closing the peer's connection. During this period, the current data values will continue to be visible in <operational>, with the \"origin\" attribute set to indicate the origin of the original data.",
      "ja": "クライアントは、BGPピアを削除するシナリオを考えてみましょう。ピアが除去されると、ピアのリソースが解放されるまで、動作状態は、ピアの接続を閉じる含め、そのピアの存在を反映していきます。この期間中、現在のデータ値は、元のデータの出所を示すために設定された「起源」属性で、<運用>に表示されていきます。"
    },
    {
      "indent": 5,
      "text": "<bgp xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\" or:origin=\"or:intended\"> <local-as>64501</local-as> <peer-as>64502</peer-as> <peer> <name>2001:db8::2:3</name> <local-as or:origin=\"or:default\">64501</local-as> <peer-as or:origin=\"or:default\">64502</peer-as> <local-port or:origin=\"or:system\">60794</local-port> <remote-port or:origin=\"or:default\">179</remote-port> <state>closing</state> </peer> </bgp>",
      "ja": "<BGPのxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF-起源\" または：原点= \"または：意図\"> <ローカル-AS> 64501 </ローカル-AS> <ピアとして> 64502 </ピアなど> <ピア> <名前> 2001：DB8 :: 2：3 </名前> <ローカル-として、あるいは：起源= \"または：デフォルト\"> 64501 </ローカル-など> <ピアなど又は：原点=「またはデフォルト」> 64502 </ピアとして> <ローカルポートまたは：原点=「または：システム」> 60794 </ローカルポート> <リモートポートまたは：原点= \"またはデフォルト「> 179 </リモートポート> <状態>閉鎖</状態> </ピア> </ BGP>"
    },
    {
      "indent": 3,
      "text": "Once resources are released and the connection is closed, the peer's data is removed from <operational>.",
      "ja": "リソースが解放され、接続が閉じられると、ピアのデータは、<運用>から削除されます。"
    },
    {
      "indent": 0,
      "text": "C.3. Interface Example",
      "ja": "C.3。インタフェースの例"
    },
    {
      "indent": 3,
      "text": "In this section, we will use this simple interface data model:",
      "ja": "この節では、このシンプルなインタフェースのデータモデルを使用します。"
    },
    {
      "indent": 5,
      "text": "container interfaces {\n  list interface {\n    key name;\n    leaf name {\n      type string;\n    }\n    leaf description {\n      type string;\n    }\n    leaf mtu {\n      type uint16;\n    }\n    leaf-list ip-address {\n      type inet:ip-address;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.3.1. Pre-provisioned Interfaces",
      "ja": "C.3.1。事前プロビジョニングされたインタフェース"
    },
    {
      "indent": 3,
      "text": "One common issue in networking devices is the support of Field Replaceable Units (FRUs) that can be inserted and removed from the device without requiring a reboot or interfering with normal operation. These FRUs are typically interface cards, and the devices support pre-provisioning of these interfaces.",
      "ja": "ネットワーキングデバイスは、1つの共通の問題は、再起動を必要とするか、通常の動作に干渉することなく挿入し、デバイスから除去することができる現場交換可能ユニット（FRU）のサポートです。これらのFRUは、典型的には、インタフェースカードであり、デバイスは、これらのインターフェイスの事前プロビジョニングをサポートします。"
    },
    {
      "indent": 3,
      "text": "If a client creates an interface \"et-0/0/0\" but the interface does not physically exist at this point, then <intended> might contain the following:",
      "ja": "クライアントは、「ET-0/0/0」のインターフェースを作成しますが、インターフェイスが物理的にこの時点では存在しない場合、<意図>以下が含まれる場合があります。"
    },
    {
      "indent": 5,
      "text": "<interfaces> <interface> <name>et-0/0/0</name> <description>Test interface</description> </interface> </interfaces>",
      "ja": "<インターフェース> <インターフェース> <名前> ET-0/0/0 </名前> <説明>テストインタフェース</記述> </インターフェイス> </インターフェイス>"
    },
    {
      "indent": 3,
      "text": "Since the interface does not exist, this data does not appear in <operational>.",
      "ja": "インタフェースが存在しないため、このデータは、<運用>には表示されません。"
    },
    {
      "indent": 3,
      "text": "When a FRU containing this interface is inserted, the system will detect it and process the associated configuration. <operational> will contain the data from <intended>, as well as nodes added by the system, such as the current value of the interface's MTU.",
      "ja": "このインタフェースを含むFRUが挿入されると、システムはそれを検出し、関連する設定を処理します。 <動作> <意図>からのデータが含まれ、ならびにインターフェースのMTUの現在の値としてシステムによって追加されたノード。"
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\" or:origin=\"or:intended\"> <interface> <name>et-0/0/0</name> <description>Test interface</description> <mtu or:origin=\"or:system\">1500</mtu> </interface> </interfaces>",
      "ja": "<インターフェイスのxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF-起源\" または：原点= \"または：意図\"> <インターフェース> <名前> ET-0/0/0 </名前> <説明>テストインタフェース</記述> <MTUまたは：原点= \"または：システム\"> 1500 </ MTU> </インターフェイス> </インターフェイス>"
    },
    {
      "indent": 3,
      "text": "If the FRU is removed, the interface data is removed from <operational>.",
      "ja": "FRUが削除されている場合は、インターフェイスデータは、<運用>から削除されます。"
    },
    {
      "indent": 0,
      "text": "C.3.2. System-Provided Interface",
      "ja": "C.3.2。システム提供のインターフェース"
    },
    {
      "indent": 3,
      "text": "Imagine that the system provides a loopback interface (named \"lo0\") with a default IPv4 address of \"127.0.0.1\" and a default IPv6 address of \"::1\". The system will only provide configuration for this interface if there is no data for it in <intended>.",
      "ja": "システムは「127.0.0.1」のデフォルトIPv4アドレスと「:: 1」のデフォルトのIPv6アドレスを使用して（「LO0」という名前の）ループバックインターフェイスを提供することを想像してみてください。 <意図>でそれのためのデータがない場合、システムはこのインターフェイスのコンフィギュレーションを提供します。"
    },
    {
      "indent": 3,
      "text": "When no configuration for \"lo0\" appears in <intended>, <operational> will show the system-provided data:",
      "ja": "「LO0」のための設定はで表示されていない場合は、<意図>、<運用>システム提供のデータが表示されます："
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\" or:origin=\"or:intended\"> <interface or:origin=\"or:system\"> <name>lo0</name> <ip-address>127.0.0.1</ip-address> <ip-address>::1</ip-address> </interface> </interfaces>",
      "ja": "<インターフェイスのxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF-起源\" または：原点= \"または：意図\"> <インターフェイスまたは：原点= \"または：システム\"> <名前> LO0 < /名前> <IPアドレス> 127.0.0.1 </ IPアドレス> <IPアドレス> :: 1 </ IPアドレス> </インターフェイス> </インターフェイス>"
    },
    {
      "indent": 3,
      "text": "When configuration for \"lo0\" does appear in <intended>, <operational> will show that data with the origin set to \"intended\". If the \"ip-address\" is not provided, then the system-provided value will appear as follows:",
      "ja": "「lo0で」の設定は、<意図>に表示されない場合は、<操作>は、原点とデータが「意図」に設定されていることを示します。 「IPアドレス」が提供されていない場合は、次のようにシステム提供の値が表示されます。"
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\" or:origin=\"or:intended\"> <interface> <name>lo0</name> <description>loopback</description> <ip-address or:origin=\"or:system\">127.0.0.1</ip-address> <ip-address>::1</ip-address> </interface> </interfaces>",
      "ja": "<インターフェイスのxmlns：OR = \"URN：IETF：paramsは：XML：NS：陽：IETF-起源\" または：原点= \"または：意図\"> <インターフェース> <名前> LO0 </名前> <説明>ループバック</説明> <IPアドレスまたは：原点= \"または：システム\"> 127.0.0.1 </ IPアドレス> <IPアドレス> :: 1 </ IPアドレス> </インターフェイス> </インターフェイス>"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document grew out of many discussions that took place since 2010. Several documents ([NETMOD-Operational] [With-config-state] [OpState-Reqs] [OpState-Enhance] [OpState-Modeling], as well as [RFC6244]), touched on some of the problems of the original datastore model. The following people were authors of these works in progress or were otherwise actively involved in the discussions that led to this document:",
      "ja": "この文書では、以来、行われた多くの議論の中から生まれた2010年、いくつかの文書（[NETMOD  - 動作] [WITH-config設定状態] [のOpState-要求数] [のOpState-強化] [のOpState-モデル]と同様に、[RFC6244] ）、元のデータストアモデルの問題のいくつかに触れました。次の人は進行中のこれらの作品の作者だったか、そうでない場合は積極的にこの文書につながった議論に関与していました。"
    },
    {
      "indent": 3,
      "text": "o Lou Berger, LabN Consulting, L.L.C., <lberger@labn.net>",
      "ja": "Oルー・バーガー、Labnコンサルティング、L.L.C. <lberger@labn.net>"
    },
    {
      "indent": 3,
      "text": "o Andy Bierman, YumaWorks, <andy@yumaworks.com>",
      "ja": "OアンディBierman、YumaWorks、<andy@yumaworks.com>"
    },
    {
      "indent": 3,
      "text": "o Marcus Hines, Google, <hines@google.com>",
      "ja": "Oマーカス・ハインズ、グーグル、<hines@google.com>"
    },
    {
      "indent": 3,
      "text": "o Christian Hopps, Deutsche Telekom, <chopps@chopps.org>",
      "ja": "OクリスチャンHoppsが、ドイツテレコム、<chopps@chopps.org>"
    },
    {
      "indent": 3,
      "text": "o Balazs Lengyel, Ericsson, <balazs.lengyel@ericsson.com>",
      "ja": "バラージュP. Lengyel、エリクソン、<balazs.lengyel@ericsson.com>"
    },
    {
      "indent": 3,
      "text": "o Ladislav Lhotka, CZ.NIC, <lhotka@nic.cz>",
      "ja": "ラディスラフLhotka、CZ.NICによって、<lhotka@nic.cz>"
    },
    {
      "indent": 3,
      "text": "o Acee Lindem, Cisco Systems, <acee@cisco.com>",
      "ja": "O ACEE Lindem、シスコシステムズ、<acee@cisco.com>"
    },
    {
      "indent": 3,
      "text": "o Thomas Nadeau, Brocade Networks, <tnadeau@lucidvision.com>",
      "ja": "Oトーマスナドー、ブロケード・ネットワーク、<tnadeau@lucidvision.com>"
    },
    {
      "indent": 3,
      "text": "o Tom Petch, Engineering Networks Ltd, <ietfc@btconnect.com>",
      "ja": "Oトム・ペッチ、エンジニアリングネットワークス株式会社、<ietfc@btconnect.com>"
    },
    {
      "indent": 3,
      "text": "o Anees Shaikh, Google, <aashaikh@google.com>",
      "ja": "O Aneesシェイク、グーグル、<આશાઈખ@ગૂગલે.કોમ>"
    },
    {
      "indent": 3,
      "text": "o Rob Shakir, Google, <robjs@google.com>",
      "ja": "OロブShakir、グーグル、<robjs@google.com>"
    },
    {
      "indent": 3,
      "text": "o Jason Sterne, Nokia, <jason.sterne@nokia.com>",
      "ja": "Oジェイソンの星、ノキア、<jason.sterne@nokia.com>"
    },
    {
      "indent": 3,
      "text": "Juergen Schoenwaelder was partly funded by Flamingo, a Network of Excellence project (ICT-318488) supported by the European Commission under its Seventh Framework Programme.",
      "ja": "ユルゲンSchoenwaelderの一部フラミンゴ、その第七次フレームワーク計画の下で、欧州委員会によってサポートされるネットワーク・エクセレンスのプロジェクト（ICT-318488）によって賄われていました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Bjorklund Tail-f Systems",
      "ja": "マーティンBjorklundテール-Fシステム"
    },
    {
      "indent": 3,
      "text": "Email: mbj@tail-f.com",
      "ja": "メール：mbj@tail-f.com"
    },
    {
      "indent": 3,
      "text": "Juergen Schoenwaelder Jacobs University",
      "ja": "ユルゲンSchoenwaelderジェイコブス大学"
    },
    {
      "indent": 3,
      "text": "Email: j.schoenwaelder@jacobs-university.de",
      "ja": "メール：j.schoenwaelder@jacobs-university.de"
    },
    {
      "indent": 3,
      "text": "Phil Shafer Juniper Networks",
      "ja": "フィル・シェーファージュニパーネットワークス"
    },
    {
      "indent": 3,
      "text": "Email: phil@juniper.net",
      "ja": "メール：phil@juniper.net"
    },
    {
      "indent": 3,
      "text": "Kent Watsen Juniper Networks",
      "ja": "ケントWatsenジュニパーネットワークス"
    },
    {
      "indent": 3,
      "text": "Email: kwatsen@juniper.net",
      "ja": "メール：kwatsen@juniper.net"
    },
    {
      "indent": 3,
      "text": "Robert Wilton Cisco Systems",
      "ja": "ロバート・ウィルトンシスコシステムズ"
    },
    {
      "indent": 3,
      "text": "Email: rwilton@cisco.com",
      "ja": "メール：rwilton@cisco.com"
    }
  ]
}