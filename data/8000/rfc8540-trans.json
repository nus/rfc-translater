{
  "title": {
    "text": "RFC 8540 - Stream Control Transmission Protocol: Errata and Issues in RFC 4960",
    "ja": "RFC 8540 - ストリーム制御伝送プロトコル：RFC 4960での正誤表と課題"
  },
  "number": 8540,
  "created_at": "2019-10-29 20:57:12.310787+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        R. Stewart\nRequest for Comments: 8540                                 Netflix, Inc.\nCategory: Informational                                        M. Tuexen\nISSN: 2070-1721                         Muenster Univ. of Appl. Sciences\n                                                              M. Proshin\n                                                                Ericsson\n                                                           February 2019",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Stream Control Transmission Protocol:\n    Errata and Issues in",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document is a compilation of issues found since the publication of RFC 4960 in September 2007, based on experience with implementing, testing, and using the Stream Control Transmission Protocol (SCTP) along with the suggested fixes. This document provides deltas to RFC 4960 and is organized in a time-ordered way. The issues are listed in the order in which they were brought up. Because some text is changed several times, the last delta in the text is the one that should be applied. In addition to the deltas, a description of each problem and the details of the solution for each are also provided.",
      "ja": "この文書は、実装、テスト、および提案の修正と一緒にストリーム制御伝送プロトコル（SCTP）を使用しての経験をもとに、2007年9月にRFC 4960の出版以来、見つかった問題をまとめたものです。この文書は、RFC 4960にデルタを提供し、時間順の方法で編成されます。問題は、彼らが育った順にリストされています。いくつかのテキストが複数回変更されているので、テキストの最後のデルタが適用されるべきものです。デルタに加えて、各問題の説明とそれぞれのソリューションの詳細も提供されます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書はインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8540.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8540で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2019 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Corrections to RFC 4960 . . . . . . . . . . . . . . . . . . .   4\n  3.1.  Path Error Counter Threshold Handling . . . . . . . . . .   4\n  3.2.  Upper-Layer Protocol Shutdown Request Handling  . . . . .   5\n  3.3.  Registration of New Chunk Types . . . . . . . . . . . . .   6\n  3.4.  Variable Parameters for INIT Chunks . . . . . . . . . . .   7\n  3.5.  CRC32c Sample Code on 64-Bit Platforms  . . . . . . . . .   8\n  3.6.  Endpoint Failure Detection  . . . . . . . . . . . . . . .   9\n  3.7.  Data Transmission Rules . . . . . . . . . . . . . . . . .  10\n  3.8.  T1-Cookie Timer . . . . . . . . . . . . . . . . . . . . .  11\n  3.9.  Miscellaneous Typos . . . . . . . . . . . . . . . . . . .  12\n  3.10. CRC32c Sample Code  . . . . . . . . . . . . . . . . . . .  19\n  3.11. partial_bytes_acked after T3-rtx Expiration . . . . . . .  19\n  3.12. Order of Adjustments of partial_bytes_acked and cwnd  . .  20\n  3.13. HEARTBEAT ACK and the Association Error Counter . . . . .  21\n  3.14. Path for Fast Retransmission  . . . . . . . . . . . . . .  22\n  3.15. Transmittal in Fast Recovery  . . . . . . . . . . . . . .  23\n  3.16. Initial Value of ssthresh . . . . . . . . . . . . . . . .  24\n  3.17. Automatically CONFIRMED Addresses . . . . . . . . . . . .  25\n  3.18. Only One Packet after Retransmission Timeout  . . . . . .  26\n  3.19. INIT ACK Path for INIT in COOKIE-WAIT State . . . . . . .  27\n  3.20. Zero Window Probing and Unreachable Primary Path  . . . .  28\n  3.21. Normative Language in Section 10 of RFC 4960  . . . . . .  29\n  3.22. Increase of partial_bytes_acked in Congestion Avoidance .  32\n  3.23. Inconsistent Handling of Notifications  . . . . . . . . .  33\n  3.24. SACK.Delay Not Listed as a Protocol Parameter . . . . . .  37\n  3.25. Processing of Chunks in an Incoming SCTP Packet . . . . .  39\n  3.26. Increasing the cwnd in the Congestion Avoidance Phase . .  41\n  3.27. Refresh of cwnd and ssthresh after Idle Period  . . . . .  43\n  3.28. Window Updates after Receiver Window Opens Up . . . . . .  45",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  3.29. Path of DATA and Reply Chunks . . . . . . . . . . . . . .  46\n  3.30. \"Outstanding Data\", \"Flightsize\", and \"Data in Flight\"\n        Key Terms . . . . . . . . . . . . . . . . . . . . . . . .  47\n  3.31. Degradation of cwnd due to Max.Burst  . . . . . . . . . .  49\n  3.32. Reduction of RTO.Initial  . . . . . . . . . . . . . . . .  50\n  3.33. Ordering of Bundled SACK and ERROR Chunks . . . . . . . .  51\n  3.34. Undefined Parameter Returned by RECEIVE Primitive . . . .  52\n  3.35. DSCP Changes  . . . . . . . . . . . . . . . . . . . . . .  53\n  3.36. Inconsistent Handling of ICMPv4 and ICMPv6 Messages . . .  55\n  3.37. Handling of Soft Errors . . . . . . . . . . . . . . . . .  56\n  3.38. Honoring cwnd . . . . . . . . . . . . . . . . . . . . . .  57\n  3.39. Zero Window Probing . . . . . . . . . . . . . . . . . . .  58\n  3.40. Updating References regarding ECN . . . . . . . . . . . .  60\n  3.41. Host Name Address Parameter Deprecated  . . . . . . . . .  62\n  3.42. Conflicting Text regarding the 'Supported Address Types'\n        Parameter . . . . . . . . . . . . . . . . . . . . . . . .  66\n  3.43. Integration of RFC 6096 . . . . . . . . . . . . . . . . .  67\n  3.44. Integration of RFC 6335 . . . . . . . . . . . . . . . . .  70\n  3.45. Integration of RFC 7053 . . . . . . . . . . . . . . . . .  72\n  3.46. CRC32c Code Improvements  . . . . . . . . . . . . . . . .  76\n  3.47. Clarification of Gap Ack Blocks in SACK Chunks  . . . . .  87\n  3.48. Handling of SSN Wraparounds . . . . . . . . . . . . . . .  89\n  3.49. Update to RFC 2119 Boilerplate Text . . . . . . . . . . .  90\n  3.50. Removal of Text (Previously Missed in RFC 4960) . . . . .  91\n4.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  91\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  92\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  92\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  92\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  92\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  94\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  94",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document contains a compilation of all defects for [RFC4960] (\"Stream Control Transmission Protocol\") that were found up until the publication of this document. These defects may be of an editorial or technical nature. This document may be thought of as a companion document to be used in the implementation of the Stream Control Transmission Protocol (SCTP) to clarify errors in the original SCTP document.",
      "ja": "この文書では、この文書の公表まで発見された[RFC4960]（「ストリーム制御伝送プロトコル」）のために、すべての欠陥のコンパイルが含まれています。これらの欠陥は、編集上または技術的な性質のものであってもよいです。この文書は、元のSCTP文書内のエラーを明確にするためにストリーム制御伝送プロトコル（SCTP）の実装に使用される仲間ドキュメントと考えることができます。"
    },
    {
      "indent": 3,
      "text": "This document provides a history of the changes that will be compiled into a bis document for [RFC4960]. It is structured similarly to [RFC4460].",
      "ja": "このドキュメントは[RFC4960]のためのビス文書にコンパイルされる変更の履歴を提供します。これは[RFC4460]と同様に構成されています。"
    },
    {
      "indent": 3,
      "text": "Each error will be detailed within this document in the form of:",
      "ja": "各エラーは次の形式で、この文書の中に詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "o The problem description,",
      "ja": "O問題の説明、"
    },
    {
      "indent": 3,
      "text": "o The text quoted from [RFC4960],",
      "ja": "O [RFC4960]から引用したテキスト、"
    },
    {
      "indent": 3,
      "text": "o The replacement text that should be placed into an upcoming bis document, and",
      "ja": "今後のビスドキュメントに配置する必要があります置換テキストO、および"
    },
    {
      "indent": 3,
      "text": "o A description of the solution.",
      "ja": "溶液の説明O。"
    },
    {
      "indent": 3,
      "text": "Note that when reading this document one must use care to ensure that a field or item is not updated later on within the document. Since this document is a historical record of the sequential changes that have been found necessary at various interop events and through discussion on the Transport Area Working Group mailing list, the last delta in the text is the one that should be applied.",
      "ja": "この文書を読むときに1フィールドまたはアイテムは文書内の後に更新されないように注意して使用しなければならないことに注意してください。この文書は、様々な相互運用イベントで交通地域ワーキンググループのメーリングリストでの議論を通じて、必要な発見されているシーケンシャル変化の歴史的な記録であるので、テキストの最後のデルタが適用されるべきものです。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2.表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 1,
      "text": "3. Corrections to",
      "section_title": true,
      "ja": "3.訂正へ"
    },
    {
      "indent": 0,
      "text": "3.1. Path Error Counter Threshold Handling",
      "section_title": true,
      "ja": "3.1。パスのエラーカウンタ閾値取り扱い"
    },
    {
      "indent": 0,
      "text": "3.1.1. Description of the Problem",
      "section_title": true,
      "ja": "3.1.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The handling of the 'Path.Max.Retrans' parameter is described in Sections 8.2 and 8.3 of [RFC4960] in an inconsistent way. Whereas Section 8.2 of [RFC4960] says that a path is marked inactive when the path error counter exceeds the threshold, Section 8.3 of [RFC4960] says that the path is marked inactive when the path error counter reaches the threshold.",
      "ja": "「Path.Max.Retrans」パラメータの取り扱いは、一貫性のない方法で、[RFC4960]のセクション8.2および8.3に記載されています。 [RFC4960]のセクション8.2は、パスのエラーカウンタがしきい値を超えた場合にパスが非アクティブとマークされていることを述べているのに対し、[RFC4960]のセクション8.3は、パスのエラーカウンタがしきい値に達したときにパスが非アクティブにマークされていることを述べています。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 1440.",
      "ja": "この問題は、正誤表ID 1440と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.1.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the value of this counter reaches the protocol parameter 'Path.Max.Retrans', the endpoint should mark the corresponding destination address as inactive if it is not so marked, and may also optionally report to the upper layer the change of reachability of this destination address. After this, the endpoint should continue HEARTBEAT on this destination address but should stop increasing the counter.",
      "ja": "このカウンタの値はプロトコルパラメータ「Path.Max.Retrans」に達したときに、エンドポイントは、それがそのようにマークされていない場合、非アクティブとして対応する宛先アドレスをマークする必要があり、また、必要に応じて上位レイヤにこの到達可能性の変化を報告すること宛先アドレス。この後、エンドポイントは、この宛先アドレスにHEARTBEATを続けるべきであるが、カウンタが増加停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the value of this counter exceeds the protocol parameter 'Path.Max.Retrans', the endpoint SHOULD mark the corresponding destination address as inactive if it is not so marked and MAY also optionally report to the upper layer the change in reachability of this destination address. After this, the endpoint SHOULD continue HEARTBEAT on this destination address but SHOULD stop increasing the counter.",
      "ja": "このカウンタの値はプロトコルパラメータ「Path.Max.Retrans」を超えたときに、エンドポイントは、それがそのようにマークされていない場合、非アクティブとして対応する宛先アドレスをマークする必要があり、また、必要に応じて上位レイヤにこの先の到達性の変化を報告すること住所。この後、エンドポイントは、この宛先アドレスにHEARTBEATを続けるべきであるが、カウンタが増加停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.23.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.23に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Solution Description",
      "section_title": true,
      "ja": "3.1.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The intended state change should happen when the threshold is exceeded.",
      "ja": "しきい値を超えたときに意図した状態変化が起こるはず。"
    },
    {
      "indent": 0,
      "text": "3.2. Upper-Layer Protocol Shutdown Request Handling",
      "section_title": true,
      "ja": "3.2。上位層プロトコルシャットダウン要求の処理"
    },
    {
      "indent": 0,
      "text": "3.2.1. Description of the Problem",
      "section_title": true,
      "ja": "3.2.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 9.2 of [RFC4960] describes the handling of received SHUTDOWN chunks in the SHUTDOWN-RECEIVED state instead of the handling of shutdown requests from its upper layer in this state.",
      "ja": "[RFC4960]のセクション9.2は、SHUTDOWN-RECEIVED状態で受信されたSHUTDOWNチャンクの処理の代わりに、この状態で、その上位層からシャットダウン要求の処理を記載しています。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 1574.",
      "ja": "この問題は、正誤表ID 1574と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.2.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT send a SHUTDOWN in response to a ULP request, and should discard subsequent SHUTDOWN chunks.",
      "ja": "エンドポイントがSHUTDOWN-RECEIVED状態に達したら、それはULPの要求に応じてSHUTDOWNを送ってはいけません、そしてそれに続くSHUTDOWNチャンクを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST ignore ULP shutdown requests but MUST continue responding to SHUTDOWN chunks from its peer.",
      "ja": "エンドポイントがSHUTDOWN-RECEIVED状態に達したら、それはULPシャットダウン要求を無視しなければならないが、そのピアからSHUTDOWNチャンクに対応し続ける必要があります。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Solution Description",
      "section_title": true,
      "ja": "3.2.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text never intended that the SCTP endpoint ignore SHUTDOWN chunks from its peer. If it did, the endpoints could never gracefully terminate associations in some cases.",
      "ja": "テキストは、SCTP端末がピアからSHUTDOWNチャンクを無視していることを意図することはありません。それがなかった場合、エンドポイントは優雅にいくつかのケースでは関連を終了することができませんでした。"
    },
    {
      "indent": 0,
      "text": "3.3. Registration of New Chunk Types",
      "section_title": true,
      "ja": "3.3。新しいチャンクタイプの登録"
    },
    {
      "indent": 0,
      "text": "3.3.1. Description of the Problem",
      "section_title": true,
      "ja": "3.3.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 14.1 of [RFC4960] should deal with new chunk types; however, the text only refers to parameter types.",
      "ja": "[RFC4960]のセクション14.1には、新しいチャンクの種類を扱う必要があります。ただし、テキストは、唯一のパラメータの種類を指します。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 2592.",
      "ja": "この問題は、正誤表ID 2592と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.3.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 14.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action, as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されるように、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk type codes is done through an IETF Consensus action, as defined in [RFC8126]. Documentation for the chunk type MUST contain the following information:",
      "ja": "[RFC8126]で定義されるように、新しいチャンクタイプコードの割り当ては、IETFコンセンサス作用を介して行われます。チャンクタイプのドキュメントは、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.43.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.43に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Solution Description",
      "section_title": true,
      "ja": "3.3.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text refers to chunk types as intended and changes the reference to [RFC8126].",
      "ja": "新しいテキストが意図したとおり、チャンクタイプを参照し、[RFC8126]への参照を変更します。"
    },
    {
      "indent": 0,
      "text": "3.4. Variable Parameters for INIT Chunks",
      "section_title": true,
      "ja": "3.4。 INITチャンクのための可変パラメータ"
    },
    {
      "indent": 0,
      "text": "3.4.1. Description of the Problem",
      "section_title": true,
      "ja": "3.4.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "In Section 3.3.2 of [RFC4960], newlines in wrong places break the layout of the table of variable parameters for the INIT chunk.",
      "ja": "[RFC4960]のセクション3.3.2には、間違った場所で改行はINITチャンクのための可変パラメータのテーブルのレイアウトを破ります。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 3291 and Errata ID 3804.",
      "ja": "この問題は、正誤表ID 3291と正誤表ID 3804と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.4.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nIPv4 Address (Note 1)               Optional    5 IPv6 Address\n(Note 1)               Optional    6 Cookie Preservative\nOptional    9 Reserved for ECN Capable (Note 2)   Optional\n32768 (0x8000) Host Name Address (Note 3)          Optional\n11 Supported Address Types (Note 4)    Optional    12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nIPv4 Address (Note 1)               Optional    5\nIPv6 Address (Note 1)               Optional    6\nCookie Preservative                 Optional    9\nReserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\nHost Name Address (Note 3)          Optional    11\nSupported Address Types (Note 4)    Optional    12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.4.3. Solution Description",
      "section_title": true,
      "ja": "3.4.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The formatting of the table is corrected.",
      "ja": "表の書式が修正されます。"
    },
    {
      "indent": 0,
      "text": "3.5. CRC32c Sample Code on 64-Bit Platforms",
      "section_title": true,
      "ja": "3.5。 64ビットプラットフォームではCRC32Cサンプルコード"
    },
    {
      "indent": 0,
      "text": "3.5.1. Description of the Problem",
      "section_title": true,
      "ja": "3.5.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The sample code for CRC32c computation, as provided in [RFC4960], assumes that a variable of type unsigned long uses 32 bits. This is not true on some 64-bit platforms (for example, platforms that use LP64).",
      "ja": "CRC32C計算のためのサンプルコードは、[RFC4960]に提供されるような、unsigned long型の変数は、32ビットを使用することを想定しています。これは（例えば、LP64を使用するプラットフォーム）いくつかの64ビットプラットフォームでは真実ではありません。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 3423.",
      "ja": "この問題は、正誤表ID 3423と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.5.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "unsigned long\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  unsigned long crc32 = ~0L;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "unsigned long\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  unsigned long crc32 = 0xffffffffL;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.10 and again in Section 3.46.",
      "ja": "このテキストは、複数の正誤表で変更されています。それは、さらに3.10にし、再びセクション3.46に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.5.3. Solution Description",
      "section_title": true,
      "ja": "3.5.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text uses 0xffffffffL instead of ~0L; this gives the same value on platforms using 32 bits or 64 bits for variables of type unsigned long.",
      "ja": "新しいテキストではなく〜0Lの0xffffffffLを使用しています。これは、32ビットまたはunsigned long型の変数の64ビットを使用してプラットフォーム上で同じ値を与えます。"
    },
    {
      "indent": 0,
      "text": "3.6. Endpoint Failure Detection",
      "section_title": true,
      "ja": "3.6。エンドポイントの障害検出"
    },
    {
      "indent": 0,
      "text": "3.6.1. Description of the Problem",
      "section_title": true,
      "ja": "3.6.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The handling of the association error counter defined in Section 8.1 of [RFC4960] can result in an association failure even if the path used for data transmission is available (but idle).",
      "ja": "[RFC4960]のセクション8.1で定義された関連のエラーカウンタの処理はデータ送信のために使用されるパスが利用可能で（ただし、アイドル）であっても関連障害をもたらすことができます。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 3788.",
      "ja": "この問題は、正誤表ID 3788と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.6.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (this includes retransmissions to all the destination transport addresses of the peer if it is multi-homed), including unacknowledged HEARTBEAT chunks.",
      "ja": "エンドポイントは、未確認HEARTBEATチャンクを含む、（マルチホームである場合、これは、ピアのすべての宛先トランスポートアドレスへの再送信を含む）ピアへの連続再送信の総数カウンタを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD keep a counter on the total number of consecutive retransmissions to its peer (this includes data retransmissions to all the destination transport addresses of the peer if it is multi-homed), including the number of unacknowledged HEARTBEAT chunks observed on the path that is currently used for data transfer. Unacknowledged HEARTBEAT chunks observed on paths different from the path currently used for data transfer SHOULD NOT increment the association error counter, as this could lead to association closure even if the path that is currently used for data transfer is available (but idle).",
      "ja": "エンドポイントは、その経路上で観察未確認HEARTBEATチャンクの数を含むそのピアに連続再送信の総数（それはマルチホームされている場合、これは、ピアのすべての宛先トランスポートアドレスへのデータ再送信を含む）にカウンタを維持すべきです現在のデータ転送に使用されます。これは、現在のデータ転送に使用されるパスが利用可能で（ただし、アイドル）であっても、関連の閉鎖につながる可能性として、現在のデータ転送に使用されるパスと異なるパスで観察未確認HEARTBEATチャンクは、アソシエーション・エラー・カウンタを増分すべきではありません。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.23.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.23に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.6.3. Solution Description",
      "section_title": true,
      "ja": "3.6.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "A more refined handling of the association error counter is defined.",
      "ja": "関連のエラーカウンタのより洗練された処理が定義されています。"
    },
    {
      "indent": 0,
      "text": "3.7. Data Transmission Rules",
      "section_title": true,
      "ja": "3.7。データ伝送のルール"
    },
    {
      "indent": 0,
      "text": "3.7.1. Description of the Problem",
      "section_title": true,
      "ja": "3.7.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When integrating the changes to Section 6.1 A) of [RFC2960] as described in Section 2.15.2 of [RFC4460], some text was duplicated and became the final paragraph of Section 6.1 A) of [RFC4960].",
      "ja": "[RFC4460]のセクション2.15.2に記載されているように[RFC2960]のセクション6.1 A）への変更を統合する場合、いくつかのテキストが複製され、[RFC4960]のセクション6.1 A）の最後の段落になりました。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 4071.",
      "ja": "この問題は、正誤表ID 4071と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.7.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.7.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1 A))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in [RFC0813]. The algorithm can be similar to the one described in Section 4.2.3.4 of [RFC1122].",
      "ja": "送信者はまた、[RFC0813]に記載されているように愚かなウィンドウ症候群（SWS）を避けるために、新しいデータチャンクを送信するためのアルゴリズムがなければなりません。アルゴリズムは、[RFC1122]のセクション4.2.3.4に記載したものと同様とすることができます。"
    },
    {
      "indent": 3,
      "text": "However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK having been lost in transit from the data receiver to the data sender.",
      "ja": "CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下ルールBを参照）。このルールは、送信者は送信者が原因のデータ送信側にデータの受信機からのトランジットで失われたSACKに逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1 A))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in [RFC1122]. The algorithm can be similar to the algorithm described in Section 4.2.3.4 of [RFC1122].",
      "ja": "送信者はまた、[RFC1122]に記載されているように愚かなウィンドウ症候群（SWS）を避けるために、新しいデータチャンクを送信するためのアルゴリズムがなければなりません。アルゴリズムは、[RFC1122]のセクション4.2.3.4に説明されたアルゴリズムと同様とすることができます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.7.3. Solution Description",
      "section_title": true,
      "ja": "3.7.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The last paragraph of Section 6.1 A) is removed, as had been intended in Section 2.15.2 of [RFC4460].",
      "ja": "[RFC4460]のセクション2.15.2に意図されていたとして、6.1節A）の最後の段落は、削除されます。"
    },
    {
      "indent": 0,
      "text": "3.8. T1-Cookie Timer",
      "section_title": true,
      "ja": "3.8。タイマーT1クッキー"
    },
    {
      "indent": 0,
      "text": "3.8.1. Description of the Problem",
      "section_title": true,
      "ja": "3.8.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Figure 4 of [RFC4960] illustrates the SCTP association setup. However, it incorrectly shows that the T1-init timer is used in the COOKIE-ECHOED state, whereas the T1-cookie timer should have been used instead.",
      "ja": "[RFC4960]の図4は、SCTPアソシエーションのセットアップを示します。しかし、それは間違ってT1-クッキータイマーが代わりに使用されている必要があり、一方、T1-INITタイマーは、COOKIE-ECHOED状態で使用されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 4400.",
      "ja": "この問題は、正誤表ID 4400と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.8.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.6, Figure 4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "COOKIE ECHO [Cookie_Z] ------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                      state)\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.6, Figure 4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "COOKIE ECHO [Cookie_Z] ------\\\n(Start T1-cookie timer)       \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB, enter ESTABLISHED\n                                      state)\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-cookie timer, <---/\n enter ESTABLISHED state)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.9.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.9に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.8.3. Solution Description",
      "section_title": true,
      "ja": "3.8.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The figure is changed such that the T1-cookie timer is used instead of the T1-init timer.",
      "ja": "図は、T1-クッキータイマーではなくT1-INITタイマーの使用されるように変更されました。"
    },
    {
      "indent": 0,
      "text": "3.9. Miscellaneous Typos",
      "section_title": true,
      "ja": "3.9。その他のタイプミス"
    },
    {
      "indent": 0,
      "text": "3.9.1. Description of the Problem",
      "section_title": true,
      "ja": "3.9.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "While processing [RFC4960], some typos were not caught.",
      "ja": "[RFC4960]の処理中に、いくつかのタイプミスをキャッチされませんでした。"
    },
    {
      "indent": 3,
      "text": "One typo was reported as an errata for [RFC4960] with Errata ID 5003.",
      "ja": "一つのタイプミスはエラータID 5003と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.9.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.9.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 1.6)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Numbers wrap around when they reach 2**32 - 1. That is, the next TSN a DATA chunk MUST use after transmitting TSN = 2*32 - 1 is TSN = 0.",
      "ja": "彼らは2 ** 32に達したとき、送信シーケンス番号がラップアラウンド -  1 TSN = 0  -  1であることを、次のTSNがDATAチャンクがTSN = 2 * 32を送信した後に使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 1.6)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Numbers wrap around when they reach 2**32 - 1. That is, the next TSN a DATA chunk MUST use after transmitting TSN = 2**32 - 1 is TSN = 0.",
      "ja": "彼らは2 ** 32に達したとき、送信シーケンス番号がラップアラウンド -  1 TSN = 0  -  1であることを、次のTSNがDATAチャンクがTSN = 2 ** 32を送信した後に使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.10.9)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "No User Data: This error cause is returned to the originator of a",
      "ja": "ユーザデータ：このエラーの原因は、Aの元に返されません"
    },
    {
      "indent": 3,
      "text": "DATA chunk if a received DATA chunk has no user data.",
      "ja": "受信したデータチャンクはユーザデータを持っていない場合、データの塊。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.10.9)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "No User Data: This error cause is returned to the originator of a DATA chunk if a received DATA chunk has no user data.",
      "ja": "ユーザデータは：このエラーの原因は、受信したデータチャンクはユーザデータを持っていない場合は、DATAチャンクの元に返されません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.7, Figure 9)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Endpoint A                                    Endpoint Z {App\nsends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------\n-----> (ack delayed) (Start T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                            immediately send ack)\n                                /----- SACK [TSN Ack=6,Block=1,\n                               /             Start=2,End=2]\n                        <-----/ (remove 6 from out-queue,\n and mark 7 as \"1\" missing report)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.7, Figure 9)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Endpoint A                                    Endpoint Z\n{App sends 3 messages; strm 0}\nDATA [TSN=6,Strm=0,Seq=2] ---------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                            immediately send ack)\n                                /----- SACK [TSN Ack=6,Block=1,\n                               /             Start=2,End=2]\n                        <-----/\n(remove 6 from out-queue,\n and mark 7 as \"1\" missing report)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.10)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint bundles chunks by simply including multiple chunks in one outbound SCTP packet. The total size of the resultant IP datagram,",
      "ja": "エンドポイントは、単に1つのアウトバウンドSCTPパケットで複数のチャンクを含むことにより、チャンクをバンドルしています。結果としてIPデータグラムの合計サイズ、"
    },
    {
      "indent": 3,
      "text": "including the SCTP packet and IP headers, MUST be less that or equal to the current Path MTU.",
      "ja": "SCTPパケットとIPヘッダを含む、より少ないこと、または現在のパスMTUに等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.10)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint bundles chunks by simply including multiple chunks in one outbound SCTP packet. The total size of the resultant IP datagram, including the SCTP packet and IP headers, MUST be less than or equal to the current Path MTU (PMTU).",
      "ja": "エンドポイントは、単に1つのアウトバウンドSCTPパケットで複数のチャンクを含むことにより、チャンクをバンドルしています。 SCTPパケットとIPヘッダを含む得られたIPデータグラムの合計サイズは、現在のパスMTU（PMTU）より小さいか等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 O))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Receive Unacknowledged Message",
      "ja": "O未確認のメッセージが表示されます"
    },
    {
      "indent": 6,
      "text": "Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer size, [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "フォーマット：RECEIVE_UNACKED（データ検索ID、バッファアドレス、バッファのサイズ、[、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [、ペイロードプロトコルID]）"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 O))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "O) Receive Unacknowledged Message",
      "ja": "O）未確認のメッセージが表示されます"
    },
    {
      "indent": 6,
      "text": "Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer size [,stream id] [,stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "フォーマット：RECEIVE_UNACKED（データ検索ID、バッファアドレス、バッファサイズ[、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [、ペイロードプロトコルID]）"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 M))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M) Set Protocol Parameters",
      "ja": "M）セットのプロトコル・パラメータ"
    },
    {
      "indent": 6,
      "text": "Format: SETPROTOCOLPARAMETERS(association id, [,destination transport address,] protocol parameter list)",
      "ja": "フォーマット：SETPROTOCOLPARAMETERS（アソシエーションID、[、送信先トランスポート・アドレス、]プロトコルパラメータリスト）"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 M))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M) Set Protocol Parameters",
      "ja": "M）セットのプロトコル・パラメータ"
    },
    {
      "indent": 6,
      "text": "Format: SETPROTOCOLPARAMETERS(association id, [destination transport address,] protocol parameter list)",
      "ja": "フォーマット：SETPROTOCOLPARAMETERS（アソシエーションID、[宛先トランスポートアドレス、]プロトコルパラメータリスト）"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP2) An implementation MAY ignore all ICMPv6 messages where the type field is not \"Destination Unreachable\", \"Parameter Problem\",, or \"Packet Too Big\".",
      "ja": "ICMP2）の実装は、「パラメータ問題」,,または「パケット過大」をタイプフィールドは「宛先到達不能」ではない、すべてのICMPv6メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP2) An implementation MAY ignore all ICMPv6 messages where the type field is not \"Destination Unreachable\", \"Parameter Problem\", or \"Packet Too Big\".",
      "ja": "ICMP2）の実装は、「パラメータ問題」、または「パケット過大」をタイプフィールドは「宛先到達不能」ではない、すべてのICMPv6メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP7) If the ICMP message is either a v6 \"Packet Too Big\" or a v4 \"Fragmentation Needed\", an implementation MAY process this information as defined for PATH MTU discovery.",
      "ja": "ICMPメッセージはv6の「パケット過大」またはV4「断片化が必要」のいずれかである場合はPATH MTUの発見のために定義されているようICMP7）、実装はこの情報を処理することができます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP7) If the ICMP message is either a v6 \"Packet Too Big\" or a v4 \"Fragmentation Needed\", an implementation MAY process this information as defined for PMTU discovery.",
      "ja": "ICMPメッセージはv6の「パケット過大」またはV4「断片化が必要」のいずれかである場合にPMTU発見のために定義されているようICMP7）、実装はこの情報を処理することができます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2) For the receiver of the COOKIE ECHO, the only CONFIRMED address is the one to which the INIT-ACK was sent.",
      "ja": "2）COOKIE ECHOの受信機のための、唯一の確認された住所は、INIT-ACKが送信されたものです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2) For the receiver of the COOKIE ECHO, the only CONFIRMED address is the address to which the INIT ACK was sent.",
      "ja": "2）COOKIE ECHOの受信機のための、唯一の確認された住所は、INIT ACKが送信されたアドレスです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.6, Figure 4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "COOKIE ECHO [Cookie_Z] ------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                      state)\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.6, Figure 4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "COOKIE ECHO [Cookie_Z] ------\\\n(Start T1-cookie timer)       \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB, enter ESTABLISHED\n                                      state)\n                               /---- COOKIE ACK\n                              /\n(Cancel T1-cookie timer, <---/\n enter ESTABLISHED state)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.8. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.8からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.2.5. Handle Duplicate COOKIE-ACK.",
      "section_title": true,
      "ja": "5.2.5。重複COOKIE-ACKを処理します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.2.5. Handle Duplicate COOKIE ACK.",
      "section_title": true,
      "ja": "5.2.5。重複COOKIE A​​CKを処理します。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es). HEARTBEAT sending MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either SHUTDOWN or SHUTDOWN-ACK. A receiver of a HEARTBEAT MUST respond to a HEARTBEAT with a HEARTBEAT-ACK after entering the COOKIE-ECHOED state (INIT sender) or the ESTABLISHED state (INIT receiver), up until reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-ACK-SENT state (SHUTDOWN receiver).",
      "ja": "デフォルトでは、SCTP終点は、宛先トランスポートアドレス（ES）に定期的にHEARTBEATチャンクを送信することによって、そのピアのアイドル先トランスポートアドレス（ES）の到達性を監視する必要があります。送信HEARTBEATがESTABLISHED状態に達したときに開始することとSHUTDOWNやSHUTDOWN-ACKのいずれかを送った後に中止されます。 HEARTBEATの受信機がSHUTDOWN-SENT状態（SHUTDOWN送信者）またはSHUTDOWNに達するまで、（INITの送信者）または確立された状態（INIT受信機）COOKIE-ECHOED状態に入った後HEARTBEAT-ACKとHEARTBEATに応答しなければなりません-ACK-SENT状態（SHUTDOWN受信機）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es). HEARTBEAT sending MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either SHUTDOWN or SHUTDOWN ACK. A receiver of a HEARTBEAT MUST respond to a HEARTBEAT with a HEARTBEAT ACK after entering the COOKIE-ECHOED state (INIT sender) or the ESTABLISHED state (INIT receiver), up until reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-ACK-SENT state (SHUTDOWN receiver).",
      "ja": "デフォルトでは、SCTP終点は、宛先トランスポートアドレス（ES）に定期的にHEARTBEATチャンクを送信することによって、そのピアのアイドル先トランスポートアドレス（ES）の到達性を監視する必要があります。送信HEARTBEATがESTABLISHED状態に達したときに開始することと、どちらかSHUTDOWNやSHUTDOWN ACKを送った後に中止されます。 HEARTBEATの受信機がSHUTDOWN-SENT状態（SHUTDOWN送信者）に達するまで、（INITの送信者）または確立された状態（INIT受信機）COOKIE-ECHOED状態に入るまたはSHUTDOWN-後ハートビートACKとHEARTBEATに応答しなければなりませんACK-SENT状態（SHUTDOWN受信機）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.9.3. Solution Description",
      "section_title": true,
      "ja": "3.9.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Several typos have been fixed.",
      "ja": "いくつかの誤字が修正されました。"
    },
    {
      "indent": 0,
      "text": "3.10. CRC32c Sample Code",
      "section_title": true,
      "ja": "3.10。 CRC32Cサンプルコード"
    },
    {
      "indent": 0,
      "text": "3.10.1. Description of the Problem",
      "section_title": true,
      "ja": "3.10.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The CRC32c computation is described in Appendix B of [RFC4960]. However, the corresponding sample code and its explanation appear at the end of Appendix C of [RFC4960], which deals with ICMP handling.",
      "ja": "CRC32C計算は[RFC4960]の付録Bに記載されています。しかし、対応するサンプルコードとその説明は、ICMP処理を扱う[RFC4960]の付録Cの終わりに現れます。"
    },
    {
      "indent": 0,
      "text": "3.10.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.10.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "The text in Appendix C of [RFC4960], starting with the following sentence, needs to be moved to the end of Appendix B.",
      "ja": "[RFC4960]の付録Cのテキストは、次の文で始まる、付録Bの端まで移動させる必要があります"
    },
    {
      "indent": 6,
      "text": "The following non-normative sample code is taken from an open-source CRC generator [WILLIAMS93], using the \"mirroring\" technique and yielding a lookup table for SCTP CRC32c with 256 entries, each 32 bits wide.",
      "ja": "以下の非規範的なサンプル・コードは、「ミラーリング」技術を使用して256のエントリ、広い各32ビットでSCTPのCRC32Cのルックアップテーブルをもたらす、オープンソースのCRC生成器[WILLIAMS93]から取られます。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.5. It is further updated in Section 3.46.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.5からの変更が含まれます。それはさらに、セクション3.46に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.10.3. Solution Description",
      "section_title": true,
      "ja": "3.10.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text is moved to the appropriate location.",
      "ja": "テキストは、適切な場所に移動されます。"
    },
    {
      "indent": 0,
      "text": "3.11. partial_bytes_acked after T3-rtx Expiration",
      "section_title": true,
      "ja": "3.11。 T3-RTX有効期限後partial_bytes_acked"
    },
    {
      "indent": 0,
      "text": "3.11.1. Description of the Problem",
      "section_title": true,
      "ja": "3.11.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 7.2.3 of [RFC4960] explicitly states that partial_bytes_acked should be reset to 0 after packet loss detection from selective acknowledgment (SACK), but this information is not accounted for in the case of T3-rtx timer expiration.",
      "ja": "[RFC4960]のセクション7.2.3は、明示的に選択的確認応答（SACK）からパケットロス検出の後に0にリセットpartial_bytes_ackedなければならないと述べたが、この情報は、T3-RTXタイマ満了した場合に計上されません。"
    },
    {
      "indent": 0,
      "text": "3.11.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.11.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = 1*MTU",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = 1 * MTU"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP SHOULD perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = 1*MTU partial_bytes_acked = 0",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = 1 * MTU partial_bytes_acked = 0"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.11.3. Solution Description",
      "section_title": true,
      "ja": "3.11.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text specifies that partial_bytes_acked should be reset to 0 after T3-rtx timer expiration.",
      "ja": "新しいテキストは、T3-RTXタイマ満了後に0にリセットpartial_bytes_ackedであることを指定します。"
    },
    {
      "indent": 0,
      "text": "3.12. Order of Adjustments of partial_bytes_acked and cwnd",
      "section_title": true,
      "ja": "3.12。 partial_bytes_ackedとのcwndの調整の順序"
    },
    {
      "indent": 0,
      "text": "3.12.1. Description of the Problem",
      "section_title": true,
      "ja": "3.12.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 7.2.2 of [RFC4960] likely implies the wrong order of adjustments applied to partial_bytes_acked and cwnd in the congestion avoidance phase.",
      "ja": "[RFC4960]のセクション7.2.2は、おそらく輻輳回避フェーズでpartial_bytes_ackedとcwndのために適用される調整の誤った順序を意味します。"
    },
    {
      "indent": 0,
      "text": "3.12.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.12.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o When partial_bytes_acked is equal to or greater than cwnd and before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before arrival of the SACK, flightsize was greater than or equal to cwnd), increase cwnd by MTU, and reset partial_bytes_acked to (partial_bytes_acked - cwnd).",
      "ja": "partial_bytes_acked場合、O（すなわち、SACKの到着前に、flightsizeはcwndを以上であった）、MTUによってCWNDが増加に等しいかCWNDより大きく、送信者が未処理データのバイトをcwndを以上たSACKの到着の前にありますpartial_bytes_acked、リセット（partial_bytes_acked  -  CWND）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o (1) when partial_bytes_acked is equal to or greater than cwnd and (2) before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before the arrival of the SACK, flightsize was greater than or equal to cwnd), partial_bytes_acked is reset to (partial_bytes_acked - cwnd). Next, cwnd is increased by 1*MTU.",
      "ja": "partial_bytes_ackedときにO（1）CWND以上であると（2）SACKの到着前に、送信者はcwndをした、または未処理データの複数のバイトを（すなわち、SACKの到着前に、flightsizeがより大きいか等しいましたcwnd） -  CWND）、（partial_bytes_ackedにリセットされpartial_bytes_acked。次に、CWNDは1つの* MTU増加しています。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.26.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.26に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.12.3. Solution Description",
      "section_title": true,
      "ja": "3.12.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text defines the exact order of adjustments of partial_bytes_acked and cwnd in the congestion avoidance phase.",
      "ja": "新しいテキストは、輻輳回避フェーズでpartial_bytes_ackedとのcwndの調整の正確な順序を定義します。"
    },
    {
      "indent": 0,
      "text": "3.13. HEARTBEAT ACK and the Association Error Counter",
      "section_title": true,
      "ja": "3.13。 HEARTBEAT ACKと協会のエラーカウンタ"
    },
    {
      "indent": 0,
      "text": "3.13.1. Description of the Problem",
      "section_title": true,
      "ja": "3.13.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Sections 8.1 and 8.3 of [RFC4960] prescribe that the receiver of a HEARTBEAT ACK must reset the association overall error count. In some circumstances, e.g., when a router discards DATA chunks but not HEARTBEAT chunks due to the larger size of the DATA chunk, it might be better to not clear the association error counter on reception of the HEARTBEAT ACK and reset it only on reception of the SACK to avoid stalling the association.",
      "ja": "セクション8.1と[RFC4960]の8.3 HEARTBEAT ACKの受信機は、関連全体のエラーカウントをリセットしなければならないことを規定しています。ルータはDATAチャンクが、データチャンクの大きなサイズに起因しないHEARTBEATチャンクを破棄し、いくつかの状況、例えば、で、HEARTBEAT ACKの受信に関連するエラーカウンタをクリアして唯一の受信時に、それをリセットしない方が良いかもしれません関連付けを失速回避するためにSACK。"
    },
    {
      "indent": 0,
      "text": "3.13.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.13.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK) or a HEARTBEAT ACK is received from the peer endpoint.",
      "ja": "カウンタ又はACKがピア・エンドポイントから受信されたHEARTBEAT（SACKの受信によって）そのピアエンドポイントに送信されたデータチャンクが確認されるたびにリセットされなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The counter MUST be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK). When a HEARTBEAT ACK is received from the peer endpoint, the counter SHOULD also be reset. The receiver of the HEARTBEAT ACK MAY choose not to clear the counter if there is outstanding data on the association. This allows for handling the possible difference in reachability based on DATA chunks and HEARTBEAT chunks.",
      "ja": "カウンタは、そのピアエンドポイントに送信されたデータチャンクは（SACKの受信によって）承認されるたびにリセットされなければなりません。ハートビートACKがピアエンドポイントから受信されると、カウンタもリセットされるべきです。 HEARTBEAT ACKの受信機は、関連性の優れたデータがある場合、カウンタをクリアしないこともできます。これは、データの塊とHEARTBEATチャンクをもとに到達可能性の違いを処理することができます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT should clear the error counter of the destination transport address to which the HEARTBEAT was sent, and mark the destination transport address as active if it is not so marked. The endpoint may optionally report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also clear the association overall error count as well (as defined in Section 8.1).",
      "ja": "HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送られた先のトランスポートアドレスのエラーカウンタをクリアする必要があり、それはそうとマークされていない場合は、アクティブとして、宛先トランスポートアドレスをマーク。非アクティブな宛先アドレスが原因最新HEARTBEAT ACKの受信にアクティブとしてマークされている場合、エンドポイントは、必要に応じて上位層に報告することができます。 HEARTBEAT ACKの受信機は、（セクション8.1で定義されるように）同様にカウントアソシエーション全体のエラーをクリアしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT MUST clear the error counter of the destination transport address to which the HEARTBEAT was sent and mark the destination transport address as active if it is not so marked. The endpoint MAY optionally report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK SHOULD also clear the association overall error count (as defined in Section 8.1).",
      "ja": "HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送られた先のトランスポートアドレスのエラーカウンタをクリアし、それがそのようにマークされていないかのように、アクティブ先輸送アドレスをマークする必要があります。非アクティブな宛先アドレスが原因最新のHEARTBEAT ACKの受信にアクティブとしてマークされている場合、エンドポイントは、必要に応じて上位層に報告することがあります。 （セクション8.1で定義されるように）HEARTBEAT ACKの受信機は、関連全体のエラーカウントをクリアする必要があります。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.23.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.23に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.13.3. Solution Description",
      "section_title": true,
      "ja": "3.13.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text provides the possibility of not resetting the association overall error count when a HEARTBEAT ACK is received if there are valid reasons for not doing so.",
      "ja": "新しいテキストはそうではない正当な理由がある場合にHEARTBEAT ACKが受信されたときに関連全体のエラーカウントをリセットしない可能性を提供します。"
    },
    {
      "indent": 0,
      "text": "3.14. Path for Fast Retransmission",
      "section_title": true,
      "ja": "3.14。高速再送信のためのパス"
    },
    {
      "indent": 0,
      "text": "3.14.1. Description of the Problem",
      "section_title": true,
      "ja": "3.14.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] clearly describes where to retransmit data that is timed out when the peer is multi-homed, but the same is not stated for fast retransmissions.",
      "ja": "[RFC4960]は明らかピアがマルチホームである場合にタイムアウトしたデータを再送する場合について説明したが、同じことは、高速再送信のために述べられていません。"
    },
    {
      "indent": 0,
      "text": "3.14.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.14.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "そのピアがマルチホームである場合さらに、エンドポイントは、データチャンクが送信されたために、最後の宛先アドレスと異なるアクティブ宛先トランスポートアドレスにタイムアウトチャンクを再送するようにしてください。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "そのピアがマルチホームである場合さらに、エンドポイントは、データチャンクが送信されたために、最後の宛先アドレスと異なるアクティブ宛先トランスポートアドレスにタイムアウトチャンクを再送するようにしてください。"
    },
    {
      "indent": 3,
      "text": "When its peer is multi-homed, an endpoint SHOULD send fast retransmissions to the same destination transport address to which the original data was sent. If the primary path has been changed and the original data was sent to the old primary path before the Fast Retransmit, the implementation MAY send it to the new primary path.",
      "ja": "そのピアがマルチホームである場合、エンドポイントは、元のデータが送られたために、同じ宛先トランスポートアドレスへの高速再送を送るべきです。プライマリパスが変更された、元のデータは、高速再送信する前に、古いプライマリパスに送信された場合、実装は、新しいプライマリパスにそれを送るかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.14.3. Solution Description",
      "section_title": true,
      "ja": "3.14.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clarifies where to send fast retransmissions.",
      "ja": "新しいテキストは、どこの高速再送信の送信先を明確にしています。"
    },
    {
      "indent": 0,
      "text": "3.15. Transmittal in Fast Recovery",
      "section_title": true,
      "ja": "3.15。高速リカバリで送付"
    },
    {
      "indent": 0,
      "text": "3.15.1. Description of the Problem",
      "section_title": true,
      "ja": "3.15.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The Fast Retransmit on Gap Reports algorithm intends that only the very first packet may be sent regardless of cwnd in the Fast Recovery phase, but rule 3) in Section 7.2.4 of [RFC4960] misses this clarification.",
      "ja": "ギャップの高速再送アルゴリズムは非常に最初のパケットは関係なく、高速リカバリ相中のcwndの送られたが、3ルール）[RFC4960]のセクション7.2.4でこの明確化をミスすることができることを意図し報告します。"
    },
    {
      "indent": 0,
      "text": "3.15.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.15.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet. When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.",
      "ja": "3）最も初期の何を決定する（すなわち、再送信のためにマークされた最も低いTSN）DATA塊は、パケットが送信された送付先輸送アドレスの経路MTUの制約を受ける単一のパケットに収まります。 K.は、単一のパケットでそれらのK DATAチャンクを再送この値を呼び出します。高速再送信が実行されている場合は、送信者はCWNDの値を無視すべきであり、この単一のパケットの再送信を遅らせるべきではありません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3) If not in Fast Recovery, determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the PMTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet. When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.",
      "ja": "ない高速リカバリ中ならば3）、パケットが送信される先のトランスポートアドレスのPMTUの制約を受け、単一のパケットに収まるどのように多くの再送信のためにマーク早い（すなわち、最低TSN）DATAチャンクの決定。 K.は、単一のパケットでそれらのK DATAチャンクを再送この値を呼び出します。高速再送信が実行されている場合は、送信者はCWNDの値を無視すべきであり、この単一のパケットの再送信を遅らせるべきではありません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.15.3. Solution Description",
      "section_title": true,
      "ja": "3.15.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text explicitly specifies that only the first packet in the Fast Recovery phase be sent and that the cwnd limitations be disregarded.",
      "ja": "新しいテキストは、明示的に高速リカバリ相の唯一の最初のパケットが送信されていることとのcwndの制限を無視することを指定します。"
    },
    {
      "indent": 0,
      "text": "3.16. Initial Value of ssthresh",
      "section_title": true,
      "ja": "3.16。 SSTHRESHの初期値"
    },
    {
      "indent": 0,
      "text": "3.16.1. Description of the Problem",
      "section_title": true,
      "ja": "3.16.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The initial value of ssthresh should be set arbitrarily high. Using the advertised receiver window of the peer is inappropriate if the peer increases its window after the handshake. Furthermore, a higher requirement level needs to be used, since not following the advice may result in performance problems.",
      "ja": "SSTHRESHの初期値は、任意に高く設定する必要があります。ピアが握手した後、そのウィンドウを増加させる場合は、ピアの広告された受信機ウィンドウを使用することは不適切です。さらに、より高い要求レベルは、パフォーマンス上の問題をもたらす可能性がアドバイスに従わないので、使用される必要があります。"
    },
    {
      "indent": 0,
      "text": "3.16.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.16.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial value of ssthresh MAY be arbitrarily high (for example, implementations MAY use the size of the receiver advertised window).",
      "ja": "SSTHRESHの初期値を任意に高くてもよいO（例えば、実装は、受信機のサイズがウィンドウをアドバタイズ使用してもよいです）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial value of ssthresh SHOULD be arbitrarily high (e.g., the size of the largest possible advertised window).",
      "ja": "SSTHRESHの初期値を任意に高くあるべきであるO（例えば、最大の可能な広告ウィンドウのサイズ）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.16.3. Solution Description",
      "section_title": true,
      "ja": "3.16.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The same value as the value suggested in [RFC5681], Section 3.1, is now used as an appropriate initial value. Also, the same requirement level is used.",
      "ja": "[RFC5681]で提案されている値は、3.1節と同様の値が、ここで適切な初期値として使用されます。また、同一の要求レベルが使用されます。"
    },
    {
      "indent": 0,
      "text": "3.17. Automatically CONFIRMED Addresses",
      "section_title": true,
      "ja": "3.17。自動的に確認アドレス"
    },
    {
      "indent": 0,
      "text": "3.17.1. Description of the Problem",
      "section_title": true,
      "ja": "3.17.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The Path Verification procedure of [RFC4960] prescribes that any address passed to the sender of the INIT by its upper layer be automatically CONFIRMED. This, however, is unclear if (1) only addresses in the request to initiate association establishment or (2) any addresses provided by the upper layer in any requests (e.g., in 'Set Primary') are considered.",
      "ja": "[RFC4960]のパス検証の手順では、その上位層でINITの送信者に渡された任意のアドレスを自動的に確認することを規定しています。これは、しかし、（1）要求にのみアドレスはアソシエーションの確立を開始する場合は不明であるか、（2）（「セットプライマリ」で例えば、）すべての要求に上位層によって提供されるアドレスが考慮されます。"
    },
    {
      "indent": 0,
      "text": "3.17.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.17.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "1) Any address passed to the sender of the INIT by its upper layer is automatically considered to be CONFIRMED.",
      "ja": "1）その上位層によってINITの送信者に渡されたアドレスが自動的に確認されていると考えられます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "1) Any addresses passed to the sender of the INIT by its upper layer in the request to initialize an association are automatically considered to be CONFIRMED.",
      "ja": "1）関連付けを初期化する要求にその上層によってINITの送信者に渡されたアドレスが自動的に確認されていると考えられます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.17.3. Solution Description",
      "section_title": true,
      "ja": "3.17.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clarifies that only addresses provided by the upper layer in the request to initialize an association are automatically CONFIRMED.",
      "ja": "新しいテキストは、関連付けを初期化する要求に上位層によって提供される唯一のアドレスが自動的に確認されていることを明確にしています。"
    },
    {
      "indent": 0,
      "text": "3.18. Only One Packet after Retransmission Timeout",
      "section_title": true,
      "ja": "3.18。再送信のタイムアウト後に一つのパケットのみ"
    },
    {
      "indent": 0,
      "text": "3.18.1. Description of the Problem",
      "section_title": true,
      "ja": "3.18.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] is not completely clear when it describes data transmission after T3-rtx timer expiration. Section 7.2.1 of [RFC4960] does not specify how many packets are allowed to be sent after T3-rtx timer expiration if more than one packet fits into cwnd. At the same time, Section 7.2.3 of [RFC4960] has text without normative language saying that SCTP should ensure that no more than one packet will be in flight after T3-rtx timer expiration until successful acknowledgement. The text is therefore inconsistent.",
      "ja": "それはT3-RTXタイマ満了後のデータ伝送を説明するとき[RFC4960]は完全に明らかではありません。 [RFC4960]のセクション7.2.1には、複数のパケットは、cwndはに収まる場合はT3-RTXタイマ満了後に送信することが許可されているどのように多くのパケット指定されていません。同時に、[RFC4960]のセクション7.2.3は、SCTPが1個以下のパケットが成功承認するまでT3-RTXタイマ満了後の飛行になることを保証しなければならないという規範的な言語ずにテキストを持っています。テキストは、したがって、矛盾しています。"
    },
    {
      "indent": 0,
      "text": "3.18.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.18.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial cwnd after a retransmission timeout MUST be no more than 1*MTU.",
      "ja": "O再送タイムアウト後の初期のcwndはこれ以上* 1よりMTUでなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial cwnd after a retransmission timeout MUST be no more than 1*MTU, and only one packet is allowed to be in flight until successful acknowledgement.",
      "ja": "oを再送タイムアウト後の初期のcwndはこれ以上* 1よりMTUでなければならない、とだけ1つのパケットが成功承認するまで飛行にあることが許可されています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.18.3. Solution Description",
      "section_title": true,
      "ja": "3.18.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clearly specifies that only one packet is allowed to be sent after T3-rtx timer expiration until successful acknowledgement.",
      "ja": "新しいテキストは明らかに一つだけのパケットが成功承認するまでT3-RTXタイマ満了後に送信することを許可することを指定します。"
    },
    {
      "indent": 0,
      "text": "3.19. INIT ACK Path for INIT in COOKIE-WAIT State",
      "section_title": true,
      "ja": "3.19。 COOKIE-WAIT状態にINITのためのINIT ACKのパス"
    },
    {
      "indent": 0,
      "text": "3.19.1. Description of the Problem",
      "section_title": true,
      "ja": "3.19.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "In the case of an INIT received in the COOKIE-WAIT state, [RFC4960] prescribes that an INIT ACK be sent to the same destination address to which the original INIT has been sent. [RFC4960] does not address the possibility of the upper layer providing multiple remote IP addresses while requesting the association establishment. If the upper layer has provided multiple IP addresses and only a subset of these addresses are supported by the peer, then the destination address of the original INIT may be absent in the incoming INIT and sending an INIT ACK to that address is useless.",
      "ja": "INITの場合、COOKIE-WAIT状態で受信された、[RFC4960]はINIT ACKを元INITが送信されてきたために、同じ宛先アドレスに送信することを規定しています。 [RFC4960]はアソシエーションの確立を要求しながら、複数のリモートIPアドレスを提供する上層の可能性に対処していません。上層が複数のIPアドレスを提供しており、これらのアドレスのサブセットのみがピアによってサポートされている場合、元のINITの宛先アドレスは、着信INITに存在しなくても、そのアドレスにINIT ACKを送信することは無駄であることができます。"
    },
    {
      "indent": 0,
      "text": "3.19.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.19.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged). When responding, the endpoint MUST send the INIT ACK back to the same address that the original INIT (sent by this endpoint) was sent.",
      "ja": "COOKIE-WAIT状態でINITを受信すると、エンドポイントは、（変化しない、その開始タグを含む）は、元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません。応答する場合、エンドポイントは（このエンドポイントによって送信された）オリジナルのINITが送られたのと同じアドレスに戻すINIT ACKを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged). When responding, the following rules MUST be applied:",
      "ja": "COOKIE-WAIT状態でINITを受信すると、エンドポイントは、（変化しない、その開始タグを含む）は、元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません。応答するときは、次の規則が適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) The INIT ACK MUST only be sent to an address passed by the upper layer in the request to initialize the association.",
      "ja": "1）INIT ACKのみの関連付けを初期化する要求に上位層によって渡されたアドレスに送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2) The INIT ACK MUST only be sent to an address reported in the incoming INIT.",
      "ja": "2）INIT ACKのみを受信INITに報告アドレスに送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3) The INIT ACK SHOULD be sent to the source address of the received INIT.",
      "ja": "3）INIT ACKは、受信したINITの送信元アドレスに送信されるべきです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.19.3. Solution Description",
      "section_title": true,
      "ja": "3.19.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text requires sending an INIT ACK to a destination address that is passed by the upper layer and reported in the incoming INIT. If the source address of the INIT meets these conditions, sending the INIT ACK to the source address of the INIT is the preferred behavior.",
      "ja": "新しいテキストは、上位層から渡された、着信INITで報告された宛先アドレスにINIT ACKを送信する必要があります。 INITの送信元アドレスは、これらの条件を満たしている場合、INITの送信元アドレスにINIT ACKを送信することは望ましい動作です。"
    },
    {
      "indent": 0,
      "text": "3.20. Zero Window Probing and Unreachable Primary Path",
      "section_title": true,
      "ja": "3.20。ゼロウィンドウプロービングと到達不能プライマリパス"
    },
    {
      "indent": 0,
      "text": "3.20.1. Description of the Problem",
      "section_title": true,
      "ja": "3.20.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 6.1 of [RFC4960] states that when sending zero window probes, SCTP should neither increment the association counter nor increment the destination address error counter if it continues to receive new packets from the peer. However, the reception of new packets from the peer does not guarantee the peer's reachability, and if the destination address becomes unreachable during zero window probing, SCTP cannot get an updated rwnd until it switches the destination address for probes.",
      "ja": "[RFC4960]のセクション6.1は、ゼロウィンドウプローブを送信するとき、SCTPアソシエーションのカウンタをインクリメントないはずどちらも、それがピアから新しいパケットを受信し続ける場合、宛先アドレス・エラー・カウンタをインクリメントすることを述べています。しかし、ピアからの新しいパケットの受信は、ピアの到達可能性を保証するものではありません、と宛先アドレスは、プロービングゼロウィンドウの中に到達不能になった場合、それがプローブの宛先アドレスを切り替えまで、SCTPは、更新さRWNDを取得することはできません。"
    },
    {
      "indent": 0,
      "text": "3.20.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.20.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1 A))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the sender continues to receive new packets from the receiver while doing zero window probing, the unacknowledged window probes should not increment the error counter for the association or any destination transport address. This is because the receiver MAY keep its window closed for an indefinite time. Refer to Section 6.2 on the receiver behavior when it advertises a zero window.",
      "ja": "プロービングゼロウィンドウをしている間、送信者が受信機から新しいパケットを受信し続ける場合、未確認ウィンドウプローブは結合または任意の宛先トランスポートアドレスのエラーカウンタを増分しないはずです。受信機は、そのウィンドウは無期限のため閉鎖続ける可能性があるためです。それがゼロウィンドウをアドバタイズするとき受信機の動作上のセクション6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1 A))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the sender continues to receive SACKs from the peer while doing zero window probing, the unacknowledged window probes SHOULD NOT increment the error counter for the association or any destination transport address. This is because the receiver could keep its window closed for an indefinite time. Section 6.2 describes the receiver behavior when it advertises a zero window.",
      "ja": "プロービングゼロウィンドウをしながら送信側がピアから袋を受信し続ける場合、未確認ウィンドウプローブは結合または任意の宛先トランスポートアドレスのエラーカウンタを増分すべきではありません。受信機は、そのウィンドウは無期限のため閉鎖保つことができるためです。それがゼロウィンドウをアドバタイズするとき、セクション6.2には、受信機の動作を説明します。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.20.3. Solution Description",
      "section_title": true,
      "ja": "3.20.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clarifies that if the receiver continues to send SACKs, the sender of probes should not increment the error counter of the association and the destination address even if the SACKs do not acknowledge the probes.",
      "ja": "新しいテキストは、受信者が袋を送信し続けた場合、プローブの送信者が関連のエラーカウンタおよびサックがプローブを認識していない場合でも、送信先アドレスをインクリメントしてはならないことを明確にしています。"
    },
    {
      "indent": 1,
      "text": "3.21. Normative Language in",
      "section_title": true,
      "ja": "3.21。で規範的言語"
    },
    {
      "indent": 0,
      "text": "3.21.1. Description of the Problem",
      "section_title": true,
      "ja": "3.21.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 10 of [RFC4960] is informative. Therefore, normative language such as MUST and MAY cannot be used there. However, there are several places in Section 10 of [RFC4960] where MUST and MAY are used.",
      "ja": "[RFC4960]のセクション10は有益です。したがって、このようなMUSTおよびMAYなどの規範的言語を使用することができません。しかし、MUSTとMAYが使用されている[RFC4960]のセクション10にはいくつかの場所があります。"
    },
    {
      "indent": 0,
      "text": "3.21.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.21.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 E))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o no-bundle flag - instructs SCTP not to bundle this user data with other outbound DATA chunks. SCTP MAY still bundle even when this flag is present, when faced with network congestion.",
      "ja": "無バンドルフラグ○ - 他のアウトバウンド・データチャンクと、このユーザデータをバンドルしないSCTPを指示します。ネットワークの混雑に直面したとき、このフラグは、存在する場合でも、SCTPはまだバンドルするかもしれません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 E))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o no-bundle flag - instructs SCTP not to bundle this user data with other outbound DATA chunks. When faced with network congestion, SCTP may still bundle the data, even when this flag is present.",
      "ja": "無バンドルフラグ○ - 他のアウトバウンド・データチャンクと、このユーザデータをバンドルしないSCTPを指示します。ネットワーク輻輳に直面したとき、SCTPは、依然としてこのフラグが存在する場合でも、データをバンドルすることができます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 G))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - the Stream Sequence Number assigned by the sending SCTP peer.",
      "ja": "Oストリームシーケンス番号 - 送信SCTPピアによって割り当てられたストリームシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this Receive contains a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、これは受信メッセージ全体の一部の配信を含んでいます。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 G))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o stream sequence number - the Stream Sequence Number assigned by the sending SCTP peer.",
      "ja": "Oストリーム・シーケンス番号 - 送信SCTPピアによって割り当てられたストリーム・シーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this primitive contains a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number must accompany this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このプリミティブは、メッセージ全体の部分的送達を含んでいます。このフラグが設定されている場合、ストリームID及びストリームシーケンス番号がこのプリミティブを添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリーム・シーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 N))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリームシーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 N))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o stream sequence number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリーム・シーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number must accompany this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリームシーケンス番号がこのプリミティブを添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリーム・シーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 O))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリームシーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 O))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o stream sequence number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリーム・シーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and stream sequence number must accompany this primitive. When this flag is set to 0, it indicates that no more deliveries will be received for this stream sequence number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリームシーケンス番号がこのプリミティブを添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリーム・シーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.21.3. Solution Description",
      "section_title": true,
      "ja": "3.21.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The normative language is removed from Section 10. In addition, the consistency of the text has been improved.",
      "ja": "規範的な言語は、テキストの一貫性が改善されている、また、セクション10から除去されます。"
    },
    {
      "indent": 0,
      "text": "3.22. Increase of partial_bytes_acked in Congestion Avoidance",
      "section_title": true,
      "ja": "3.22。輻輳回避中partial_bytes_ackedの増加"
    },
    {
      "indent": 0,
      "text": "3.22.1. Description of the Problem",
      "section_title": true,
      "ja": "3.22.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Two issues have been discovered in the text in Section 7.2.2 of [RFC4960] regarding partial_bytes_acked handling:",
      "ja": "2つの問題がpartial_bytes_acked取り扱いに関する[RFC4960]のセクション7.2.2のテキストで発見されています："
    },
    {
      "indent": 3,
      "text": "o If the Cumulative TSN Ack Point is not advanced but the SACK chunk acknowledges new TSNs in the Gap Ack Blocks, these newly acknowledged TSNs are not considered for partial_bytes_acked even though these TSNs were successfully received by the peer.",
      "ja": "累積TSN Ackをポイントが進んでいないですが、SACKチャンクはギャップAckブロックで新しいのTSNを認識した場合は、O、これらの新たに認めたTSNは、これらのTSNが正常にピアによって受信されたにもかかわらずpartial_bytes_ackedのために考慮されていません。"
    },
    {
      "indent": 3,
      "text": "o Duplicate TSNs are not considered in partial_bytes_acked even though they confirm that the DATA chunks were successfully received by the peer.",
      "ja": "O重複のTSNは、それらがDATAチャンクが正常にピアによって受信されたことを確認していてもpartial_bytes_ackedでは考慮されません。"
    },
    {
      "indent": 0,
      "text": "3.22.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.22.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival that advances the Cumulative TSN Ack Point, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK including chunks acknowledged by the new Cumulative TSN Ack and by Gap Ack Blocks.",
      "ja": "OたびCWNDが累積TSNのAckポイントを進める各SACKの到着時に、新たな累積TSNのAckによって、およびギャップAckブロックによって認めチャンクを含むことSACKに認めすべての新しいチャンクのバイトの総数によってpartial_bytes_acked、増加SSTHRESHより大きい。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK, including chunks acknowledged by the new Cumulative TSN Ack, by Gap Ack Blocks, and by the number of bytes of duplicated chunks reported in Duplicate TSNs.",
      "ja": "CWNDがSSTHRESHよりも大きいときはいつでも、O、各SACKの到着時に、増加はギャップAckブロックによって、および数によって、新たな累積TSNのAckによって承認チャンクを含むことSACKに認めすべての新しいチャンクのバイトの総数によってpartial_bytes_acked重複したTSNに報告された重複チャンクのバイト。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.26.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.26に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.22.3. Solution Description",
      "section_title": true,
      "ja": "3.22.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "In the new text, partial_bytes_acked is increased by TSNs reported as duplicated, as well as TSNs newly acknowledged in Gap Ack Blocks, even if the Cumulative TSN Ack Point is not advanced.",
      "ja": "新しいテキストでは、累積TSN Ackをポイントが進んでいない場合でも、新たにギャップAckブロックに認め重複として報告するTSN、などのTSNによって増加するpartial_bytes_acked。"
    },
    {
      "indent": 0,
      "text": "3.23. Inconsistent Handling of Notifications",
      "section_title": true,
      "ja": "3.23。通知の一貫性のない取扱い"
    },
    {
      "indent": 0,
      "text": "3.23.1. Description of the Problem",
      "section_title": true,
      "ja": "3.23.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] uses inconsistent normative and non-normative language when describing rules for sending notifications to the upper layer. For example, Section 8.2 of [RFC4960] says that when a destination address becomes inactive due to an unacknowledged DATA chunk or HEARTBEAT chunk, SCTP SHOULD send a notification to the upper layer; however, Section 8.3 of [RFC4960] says that when a destination address becomes inactive due to an unacknowledged HEARTBEAT chunk, SCTP may send a notification to the upper layer.",
      "ja": "上位層に通知を送信するためのルールを記述する際に[RFC4960]は矛盾規範的及び非規範的な言語を使用します。例えば、[RFC4960]のセクション8.2は、宛先アドレスが原因未確認データチャンクまたはHEARTBEATチャンクに非アクティブになったときに、SCTPは、上位層に通知を送信すべきであると述べています。しかしながら、[RFC4960]のセクション8.3は、宛先アドレスが原因未確認HEARTBEATチャンクに非アクティブになったときに、SCTPは、上位層に通知を送信することができると述べています。"
    },
    {
      "indent": 3,
      "text": "These inconsistent descriptions need to be corrected.",
      "ja": "これらの矛盾した記述を修正する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.23.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.23.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (this includes retransmissions to all the destination transport addresses of the peer if it is multi-homed), including unacknowledged HEARTBEAT chunks.",
      "ja": "エンドポイントは、未確認HEARTBEATチャンクを含む、（マルチホームである場合、これは、ピアのすべての宛先トランスポートアドレスへの再送信を含む）ピアへの連続再送信の総数カウンタを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD keep a counter on the total number of consecutive retransmissions to its peer (this includes data retransmissions to all the destination transport addresses of the peer if it is multi-homed), including the number of unacknowledged HEARTBEAT chunks observed on the path that is currently used for data transfer. Unacknowledged HEARTBEAT chunks observed on paths different from the path currently used for data transfer SHOULD NOT increment the association error counter, as this could lead to association closure even if the path that is currently used for data transfer is available (but idle). If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint SHOULD consider the peer endpoint unreachable and SHALL stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint SHOULD report the failure to the upper layer and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、その経路上で観察未確認HEARTBEATチャンクの数を含むそのピアに連続再送信の総数（それはマルチホームされている場合、これは、ピアのすべての宛先トランスポートアドレスへのデータ再送信を含む）にカウンタを維持すべきです現在のデータ転送に使用されます。これは、現在のデータ転送に使用されるパスが利用可能で（ただし、アイドル）であっても、関連の閉鎖につながる可能性として、現在のデータ転送に使用されるパスと異なるパスで観察未確認HEARTBEATチャンクは、アソシエーション・エラー・カウンタを増分すべきではありません。このカウンタの値は、プロトコルパラメータ「Association.Max.Retrans」で示さ限界を超えた場合、エンドポイントは、ピアエンドポイントが到達不能に考慮する必要があり、それは（従って関連が閉状態になる）にそれ以上データを送信停止しなければなりません。加えて、エンドポイントは、上位層に失敗を報告し、必要に応じてその送信キューに残っているすべての未処理のユーザデータをバック報告すべきです。ピアエンドポイントが到達不能になったときに関連付けは自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.6. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.6からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When an outstanding TSN is acknowledged or a HEARTBEAT sent to that address is acknowledged with a HEARTBEAT ACK, the endpoint shall clear the error counter of the destination transport address to which the DATA chunk was last sent (or HEARTBEAT was sent). When the peer endpoint is multi-homed and the last chunk sent to it was a retransmission to an alternate address, there exists an ambiguity as to whether or not the acknowledgement should be credited to the address of the last chunk sent. However, this ambiguity does not seem to bear any significant consequence to SCTP behavior. If this ambiguity is undesirable, the transmitter may choose not to clear the error counter if the last chunk sent was a retransmission.",
      "ja": "優れたTSNが認められているか、そのアドレスに送信されたHEARTBEATがHEARTBEATのACKで承認された場合、エンドポイントは、どのデータチャンクが送信された最後だったし（またはHEARTBEATが送られた）先のトランスポートアドレスのエラーカウンタをクリアしなければなりません。ピアエンドポイントである場合にマルチホームおよびそれに送信された最後のチャンクは、肯定応答が送信された最後のチャンクのアドレスに入金されるべきか否かの代替アドレスに再送が、曖昧さが存在しました。しかし、この曖昧さは、SCTPの動作に重大な結果を負担していないようです。このあいまいさが望ましくない場合は、送信機は、送信された最後のチャンクが再送信であった場合、エラーカウンタをクリアしないこともできます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When an outstanding TSN is acknowledged or a HEARTBEAT sent to that address is acknowledged with a HEARTBEAT ACK, the endpoint SHOULD clear the error counter of the destination transport address to which the DATA chunk was last sent (or HEARTBEAT was sent) and SHOULD also report to the upper layer when an inactive destination address is marked as active. When the peer endpoint is multi-homed and the last chunk sent to it was a retransmission to an alternate address, there exists an ambiguity as to whether or not the acknowledgement could be credited to the address of the last chunk sent. However, this ambiguity does not seem to have significant consequences for SCTP behavior. If this ambiguity is undesirable, the transmitter MAY choose not to clear the error counter if the last chunk sent was a retransmission.",
      "ja": "優れたTSNが認められているか、そのアドレスに送信されたHEARTBEATがハートビートACKを受け付けた場合、エンドポイントは、DATAチャンクが最後に送信された（またはHEARTBEATが送られた）先の先のトランスポートアドレスのエラーカウンタをクリアする必要がありますし、また報告しなければなりません上位層に非アクティブな宛先アドレスはアクティブとしてマークされている場合。ピアエンドポイントがマルチホームであり、それに送られた最後のチャンクが代替アドレスに再送た場合、確認応答が送信された最後のチャンクのアドレスに入金することができたか否かの曖昧さが存在します。しかし、この曖昧さは、SCTPの行動に大きな影響を持っていないようです。このあいまいさが望ましくない場合は、送信機は、送信された最後のチャンクが再送信であった場合、エラーカウンタをクリアしないこともできます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the value of this counter reaches the protocol parameter 'Path.Max.Retrans', the endpoint should mark the corresponding destination address as inactive if it is not so marked, and may also optionally report to the upper layer the change of reachability of this destination address. After this, the endpoint should continue HEARTBEAT on this destination address but should stop increasing the counter.",
      "ja": "このカウンタの値はプロトコルパラメータ「Path.Max.Retrans」に達したときに、エンドポイントは、それがそのようにマークされていない場合、非アクティブとして対応する宛先アドレスをマークする必要があり、また、必要に応じて上位レイヤにこの到達可能性の変化を報告すること宛先アドレス。この後、エンドポイントは、この宛先アドレスにHEARTBEATを続けるべきであるが、カウンタが増加停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the value of this counter exceeds the protocol parameter 'Path.Max.Retrans', the endpoint SHOULD mark the corresponding destination address as inactive if it is not so marked and SHOULD also report to the upper layer the change in reachability of this destination address. After this, the endpoint SHOULD continue HEARTBEAT on this destination address but SHOULD stop increasing the counter.",
      "ja": "このカウンタの値はプロトコルパラメータ「Path.Max.Retrans」を超えたときに、エンドポイントは、それがそのようにマークされていない場合、非アクティブとして対応する宛先アドレスをマークする必要があり、また、上位レイヤにこの宛先アドレスの到達性の変化を報告しなければなりません。この後、エンドポイントは、この宛先アドレスにHEARTBEATを続けるべきであるが、カウンタが増加停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.1. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.1からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT should clear the error counter of the destination transport address to which the HEARTBEAT was sent, and mark the destination transport address as active if it is not so marked. The endpoint may optionally report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also clear the association overall error count as well (as defined in Section 8.1).",
      "ja": "HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送られた先のトランスポートアドレスのエラーカウンタをクリアする必要があり、それはそうとマークされていない場合は、アクティブとして、宛先トランスポートアドレスをマーク。非アクティブな宛先アドレスが原因最新HEARTBEAT ACKの受信にアクティブとしてマークされている場合、エンドポイントは、必要に応じて上位層に報告することができます。 HEARTBEAT ACKの受信機は、（セクション8.1で定義されるように）同様にカウントアソシエーション全体のエラーをクリアしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT SHOULD clear the error counter of the destination transport address to which the HEARTBEAT was sent and mark the destination transport address as active if it is not so marked. The endpoint SHOULD report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK SHOULD also clear the association overall error count (as defined in Section 8.1).",
      "ja": "HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送られた先のトランスポートアドレスのエラーカウンタをクリアし、それがそのようにマークされていないかのように、アクティブ先輸送アドレスをマークすべきです。非アクティブな宛先アドレスが原因最新のHEARTBEAT ACKの受信にアクティブとしてマークされている場合、エンドポイントは、上位層に報告する必要があります。 （セクション8.1で定義されるように）HEARTBEAT ACKの受信機は、関連全体のエラーカウントをクリアする必要があります。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.13. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.13からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint should limit the number of retransmissions of the SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint should destroy the TCB and MUST report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "エンドポイントは、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWNチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告しなければならない（したがって、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD limit the number of retransmissions of the SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "エンドポイントは、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWNチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告しなければならない（従って、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN ACK should limit the number of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint should destroy the TCB and may report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "SHUTDOWN ACKの送信者は、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWN ACKチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告することができる（したがって、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN ACK SHOULD limit the number of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint SHOULD destroy the TCB and SHOULD report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "SHUTDOWN ACKの送信者は、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWN ACKチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告しなければならない（従って、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.23.3. Solution Description",
      "section_title": true,
      "ja": "3.23.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The inconsistencies are removed by consistently using SHOULD.",
      "ja": "矛盾が一貫SHOULDを使用して除去されます。"
    },
    {
      "indent": 0,
      "text": "3.24. SACK.Delay Not Listed as a Protocol Parameter",
      "section_title": true,
      "ja": "3.24。プロトコルパラメータとしてリストされていないSACK.Delay"
    },
    {
      "indent": 0,
      "text": "3.24.1. Description of the Problem",
      "section_title": true,
      "ja": "3.24.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "SCTP as specified in [RFC4960] supports delaying SACKs. The timer value for this is a parameter, and Section 6.2 of [RFC4960] specifies a default and maximum value for it. However, (1) defining a name for this parameter and (2) listing it in the table of protocol parameters in Section 15 of [RFC4960] are missing.",
      "ja": "[RFC4960]で指定されているSCTPは、袋を遅らせるサポートしています。このため、タイマ値はパラメータであり、[RFC4960]の6.2節には、それのデフォルト値と最大値を指定します。しかし、（1）このパラメータの名前を定義し、（2）[RFC4960]のセクション15のプロトコルパラメータのテーブルでそれをリストが不足しています。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as an errata for [RFC4960] with Errata ID 4656.",
      "ja": "この問題は、正誤表ID 4656と[RFC4960]の正誤表として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.24.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.24.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT allow the maximum delay to be configured to be more than 500 ms. In other words, an implementation MAY lower this value below 500 ms but MUST NOT raise it above 500 ms.",
      "ja": "実装は、最大遅延は500以上のミリ秒であるように構成されることを可能にしてはいけません。言い換えれば、実装は500ミリ秒以下、この値を下げるかもしれませんが、500ミリ秒を超える、それを発生させてはなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT allow the maximum delay (protocol parameter 'SACK.Delay') to be configured to be more than 500 ms. In other words, an implementation MAY lower the value of SACK.Delay below 500 ms but MUST NOT raise it above 500 ms.",
      "ja": "実装は、最大遅延（プロトコルパラメータ「SACK.Delay」）が500以上のミリ秒であるように構成されることを可能にしてはいけません。言い換えれば、実装は500ミリ秒以下SACK.Delayの値を低下させることができるが、500ミリ秒を超える、それを発生させてはなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 15)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 6,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds Max.Burst - 4 RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds HB.Max.Burst - 1",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  4 RTO.Alpha  -   -  Max.Burst 60秒1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans -  10試みるPath.Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.interval  -  30秒HB.Max.Burst  -  1"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 15)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 6,
      "text": "RTO.Initial: 3 seconds RTO.Min: 1 second RTO.Max: 60 seconds Max.Burst: 4 RTO.Alpha: 1/8 RTO.Beta: 1/4 Valid.Cookie.Life: 60 seconds Association.Max.Retrans: 10 attempts Path.Max.Retrans: 5 attempts (per destination address) Max.Init.Retransmits: 8 attempts HB.interval: 30 seconds HB.Max.Burst: 1 SACK.Delay: 200 milliseconds",
      "ja": "RTO.Initial：3秒RTO.Min：1秒RTO.Max：60秒Max.Burst：4 RTO.Alpha：1/8 RTO.Beta：1/4 Valid.Cookie.Life：60秒Association.Max.Retrans ：10試みるPath.Max.Retrans：（宛先アドレスごと）5つの試みMax.Init.Retransmits：8つの試みHB.interval：30秒HB.Max.Burst：1 SACK.Delay：200ミリ秒"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.32.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.32に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.24.3. Solution Description",
      "section_title": true,
      "ja": "3.24.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The parameter is given the name 'SACK.Delay' and added to the list of protocol parameters.",
      "ja": "パラメータは名「SACK.Delay」を与えられ、プロトコルパラメータのリストに追加されます。"
    },
    {
      "indent": 0,
      "text": "3.25. Processing of Chunks in an Incoming SCTP Packet",
      "section_title": true,
      "ja": "3.25。着信SCTPパケット内のチャンクの処理"
    },
    {
      "indent": 0,
      "text": "3.25.1. Description of the Problem",
      "section_title": true,
      "ja": "3.25.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "There are a few places in [RFC4960] where text specifies that the receiver of a packet must discard it while processing the chunks of the packet. Whether or not the receiver has to roll back state changes already performed while processing the packet is unclear.",
      "ja": "テキストは、パケットの塊を処理している間、パケットの受信機は、それを破棄しなければならないことを指定し、[RFC4960]でいくつかの場所があります。か否かを受信機がパケットを処理することは不明であるが既に実行状態の変更をロールバックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The intention of [RFC4960] is to process an incoming packet chunk by chunk and not to perform any prescreening of chunks in the received packet. Thus, by discarding one chunk, the receiver also causes the discarding of all further chunks.",
      "ja": "[RFC4960]の意図は、チャンクによって着信パケットチャンクを処理し、受信したパケット内のチャンクの任意のプレスクリーニングを実行しないです。したがって、1つのチャンクを破棄することによって、受信機は、すべてさらにチャンクの廃棄を引き起こします。"
    },
    {
      "indent": 0,
      "text": "3.25.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.25.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized chunk in an 'Unrecognized Chunk Type'.",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、「認識できないチャンクタイプ」で認識されていないチャンクを報告しません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet; discard the unrecognized chunk and all further chunks.",
      "ja": "00  - このSCTPパケットの処理を停止。認識できないチャンクと、すべてさらにチャンクを破棄します。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet, discard the unrecognized chunk and all further chunks, and report the unrecognized chunk in an 'Unrecognized Chunk Type'.",
      "ja": "01  - このSCTPパケットの処理を停止し、認識できないチャンクと、すべてさらにチャンクを破棄し、「認識できないチャンクタイプ」で認識されていないチャンクを報告しています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 11.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to [RFC1858]). Accordingly, we stress the requirements, stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled with any other chunk in a packet, and (2) a packet containing an INIT chunk MUST have a zero Verification Tag. Furthermore, we require that the receiver of an INIT chunk MUST enforce these rules by silently discarding an arriving packet with an INIT chunk that is bundled with other chunks or has a non-zero verification tag and contains an INIT-chunk.",
      "ja": "それらは断片化されたSCTPパケットのちょうど最初のフラグメントを検査し、明確にそれがINITチャンクに対応するか否かを判断することができる場合、それはいくつかのファイアウォールのために有用である（詳細については、[RFC1858]を参照）。したがって、我々は要件を強調し、（1）INITチャンクはパケット内の他のチャンクとバンドルしてはならない、と（2）INITチャンクを含むパケットがゼロの検証タグを持たなければならないことを、3.1節で述べました。さらに、我々は、INITチャンクの受信機が静かに他のチャンクにバンドルまたは非ゼロの検証タグを有し、INITチャンクを含んでいるINITチャンクで到着するパケットを廃棄することによって、これらのルールを適用しなければならないことを要求します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 11.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to [RFC1858]). Accordingly, we stress the requirements, as stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled with any other chunk in a packet and (2) a packet containing an INIT chunk MUST have a zero Verification Tag. The receiver of an INIT chunk MUST silently discard the INIT chunk and all further chunks if the INIT chunk is bundled with other chunks or the packet has a non-zero Verification Tag.",
      "ja": "それらは断片化されたSCTPパケットのちょうど最初のフラグメントを検査し、明確にそれがINITチャンクに対応するか否かを判断することができる場合、それはいくつかのファイアウォールのために有用である（詳細については、[RFC1858]を参照）。 3.1節で述べたようによって、我々は、（1）INITチャンクはパケット内の他のチャンクとバンドルしてはならない、（2）INITチャンクを含むパケットがゼロの検証タグを持たなければならないことを、要件を強調しています。 INITチャンクは他のチャンクにバンドルされているまたはパケットが非ゼロ検証タグを有する場合INITチャンクの受信機は静かINITチャンク及びすべてのさらなる塊を捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.25.3. Solution Description",
      "section_title": true,
      "ja": "3.25.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text makes it clear that chunks can be processed from the beginning to the end and that no rollback or prescreening is required.",
      "ja": "新しいテキストは、それを明確チャンクは最初から最後までと全くロールバックまたはプレスクリーニングが必要とされないことを処理できることになります。"
    },
    {
      "indent": 0,
      "text": "3.26. Increasing the cwnd in the Congestion Avoidance Phase",
      "section_title": true,
      "ja": "3.26。輻輳回避フェーズでのcwndを増やします"
    },
    {
      "indent": 0,
      "text": "3.26.1. Description of the Problem",
      "section_title": true,
      "ja": "3.26.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 7.2.2 of [RFC4960] prescribes that cwnd be increased by 1*MTU per RTT if the sender has cwnd or more bytes of data outstanding to the corresponding address in the congestion avoidance phase. However, this is described without normative language. Moreover, Section 7.2.2 of [RFC4960] includes an algorithm that specifies how an implementation can achieve this, but this algorithm is underspecified and actually allows increasing cwnd by more than 1*MTU per RTT.",
      "ja": "[RFC4960]のセクション7.2.2は、送信者が輻輳回避フェーズに対応するアドレスに未処理のデータのバイトをcwndを以上いる場合CWNDがRTTあたり1つの* MTUによって増加されることを規定します。しかし、これは規範的な言語なしで記述されています。また、[RFC4960]のセクション7.2.2は、実装がこれを達成することができる方法を指定するアルゴリズムを含むが、このアルゴリズムは、不足のある、実際RTTあたり1つの以上* MTUによって増加CWNDを可能にします。"
    },
    {
      "indent": 0,
      "text": "3.26.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.26.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When cwnd is greater than ssthresh, cwnd should be incremented by 1*MTU per RTT if the sender has cwnd or more bytes of data outstanding for the corresponding transport address.",
      "ja": "CWNDがSSTHRESHより大きい場合、送信者はcwndをまたは対応するトランスポート・アドレスのための未処理データの複数のバイトた場合、CWNDは、RTTあたり1つの* MTUだけインクリメントされるべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When cwnd is greater than ssthresh, cwnd SHOULD be incremented by 1*MTU per RTT if the sender has cwnd or more bytes of data outstanding for the corresponding transport address. The basic guidelines for incrementing cwnd during congestion avoidance are as follows:",
      "ja": "CWNDがSSTHRESHより大きい場合、送信者はcwndをまたは対応するトランスポート・アドレスのための未処理データの複数のバイトた場合、CWNDは、RTTあたり1つの* MTUインクリメントされるべきです。次のように輻輳回避中にcwndをインクリメントするための基本的なガイドラインは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o SCTP MAY increment cwnd by 1*MTU.",
      "ja": "O SCTPは1つの* MTUでのcwndを増加してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "o SCTP SHOULD increment cwnd by 1*MTU once per RTT when the sender has cwnd or more bytes of data outstanding for the corresponding transport address.",
      "ja": "送信者がcwndを、または対応するトランスポート・アドレスのための優れたデータの多くのバイトしていたときにO SCTPは* MTU一度RTTあたり1でのcwndをインクリメントすべきです。"
    },
    {
      "indent": 3,
      "text": "o SCTP MUST NOT increment cwnd by more than 1*MTU per RTT.",
      "ja": "O SCTPはRTTごとに複数1つの* MTUでのcwndを増加してはなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival that advances the Cumulative TSN Ack Point, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK including chunks acknowledged by the new Cumulative TSN Ack and by Gap Ack Blocks.",
      "ja": "OたびCWNDが累積TSNのAckポイントを進める各SACKの到着時に、新たな累積TSNのAckによって、およびギャップAckブロックによって認めチャンクを含むことSACKに認めすべての新しいチャンクのバイトの総数によってpartial_bytes_acked、増加SSTHRESHより大きい。"
    },
    {
      "indent": 3,
      "text": "o When partial_bytes_acked is equal to or greater than cwnd and before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before arrival of the SACK, flightsize was greater than or equal to cwnd), increase cwnd by MTU, and reset partial_bytes_acked to (partial_bytes_acked - cwnd).",
      "ja": "partial_bytes_acked場合、O（すなわち、SACKの到着前に、flightsizeはcwndを以上であった）、MTUによってCWNDが増加に等しいかCWNDより大きく、送信者が未処理データのバイトをcwndを以上たSACKの到着の前にありますpartial_bytes_acked、リセット（partial_bytes_acked  -  CWND）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK, including chunks acknowledged by the new Cumulative TSN Ack, by Gap Ack Blocks, and by the number of bytes of duplicated chunks reported in Duplicate TSNs.",
      "ja": "CWNDがSSTHRESHよりも大きいときはいつでも、O、各SACKの到着時に、増加はギャップAckブロックによって、および数によって、新たな累積TSNのAckによって承認チャンクを含むことSACKに認めすべての新しいチャンクのバイトの総数によってpartial_bytes_acked重複したTSNに報告された重複チャンクのバイト。"
    },
    {
      "indent": 3,
      "text": "o (1) when partial_bytes_acked is greater than cwnd and (2) before the arrival of the SACK the sender had less than cwnd bytes of data outstanding (i.e., before the arrival of the SACK, flightsize was less than cwnd), reset partial_bytes_acked to cwnd.",
      "ja": "O partial_bytes_acked場合（1）CWNDより大きく、（2）SACKの到着前に、送信者が未処理データのCWNDバイト未満であった（すなわち、SACKの到着前に、flightsizeがCWND未満であった）にpartial_bytes_ackedリセットCWND。"
    },
    {
      "indent": 3,
      "text": "o (1) when partial_bytes_acked is equal to or greater than cwnd and (2) before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before the arrival of the SACK, flightsize was greater than or equal to cwnd), partial_bytes_acked is reset to (partial_bytes_acked - cwnd). Next, cwnd is increased by 1*MTU.",
      "ja": "partial_bytes_ackedときにO（1）CWND以上であると（2）SACKの到着前に、送信者はcwndをした、または未処理データの複数のバイトを（すなわち、SACKの到着前に、flightsizeがより大きいか等しいましたcwnd） -  CWND）、（partial_bytes_ackedにリセットされpartial_bytes_acked。次に、CWNDは1つの* MTU増加しています。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Sections 3.12 and 3.22. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.12および3.22からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.26.3. Solution Description",
      "section_title": true,
      "ja": "3.26.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The basic guidelines for incrementing cwnd during the congestion avoidance phase are added into Section 7.2.2. The guidelines include the normative language and are aligned with [RFC5681].",
      "ja": "輻輳回避フェーズ中にcwndをインクリメントするための基本的なガイドラインは、7.2.2項に追加されます。ガイドラインでは、規範的な言語が含まれており、[RFC5681]と一致しています。"
    },
    {
      "indent": 3,
      "text": "The algorithm from Section 7.2.2 is improved and now does not allow increasing cwnd by more than 1*MTU per RTT.",
      "ja": "7.2.2からのアルゴリズムが改善され、今RTTあたり以上1つの* MTUでのcwndを増やすことはできません。"
    },
    {
      "indent": 0,
      "text": "3.27. Refresh of cwnd and ssthresh after Idle Period",
      "section_title": true,
      "ja": "3.27。アイドル期間の後のcwndとSSTHRESHのリフレッシュ"
    },
    {
      "indent": 0,
      "text": "3.27.1. Description of the Problem",
      "section_title": true,
      "ja": "3.27.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] prescribes that cwnd per RTO be adjusted if the endpoint does not transmit data on a given transport address. In addition to that, it prescribes that cwnd be set to the initial value after a sufficiently long idle period. The latter is excessive. Moreover, what is considered a sufficiently long idle period is unclear.",
      "ja": "[RFC4960]は、エンドポイントが与えられたトランスポートアドレスにデータを送信しない場合RTOあたりCWNDを調整することを規定しています。それに加えて、それはcwndのは十分長いアイドル期間の後に初期値に設定することを規定しています。後者は過剰です。また、何が十分に長いアイドル期間が不明であると考えられています。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] doesn't specify the handling of ssthresh in the idle case. If ssthresh is reduced due to packet loss, ssthresh is never recovered. So, traffic can end up in congestion avoidance all the time, resulting in a low sending rate and bad performance. The problem is even more serious for SCTP: in a multi-homed SCTP association, traffic that switches back to the previously failed primary path will also lead to the situation where traffic ends up in congestion avoidance.",
      "ja": "[RFC4960]は、アイドルの場合にはSSTHRESHの取り扱いを指定していません。 SSTHRESHは、パケットロスに起因して減少している場合は、SSTHRESHが回収されることはありません。だから、トラフィックが低く、送信速度と悪いパフォーマンスで、その結果、輻輳回避にすべての時間を終わることができます。問題はさらに深刻SCTPのためにある：マルチホームのSCTPアソシエーションでは、以前に失敗したプライマリパスに切り替わり、トラフィックは、トラフィックが輻輳回避で終わるような状況につながります。"
    },
    {
      "indent": 0,
      "text": "3.27.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.27.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial cwnd before DATA transmission or after a sufficiently long idle period MUST be set to min(4*MTU, max (2*MTU, 4380 bytes)).",
      "ja": "Oデータの送信前又は十分長いアイドル期間後の初期CWND（4 * MTU、MAX（2 * MTU、4380バイト））最小に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The initial cwnd before data transmission MUST be set to min(4*MTU, max (2*MTU, 4380 bytes)).",
      "ja": "Oデータ伝送前の初期CWND（4 * MTU、MAX（2 * MTU、4380バイト））最小に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o When the endpoint does not transmit data on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd/2, 4*MTU) per RTO.",
      "ja": "エンドポイントが与えられたトランスポートアドレスにデータを送信しない場合には、O、トランスポート・アドレスのCWNDは、MAXに調整しなければならない（CWND / 2、4 * MTU）RTOあたり。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o While the endpoint does not transmit data on a given transport address, the cwnd of the transport address SHOULD be adjusted to max(cwnd/2, 4*MTU) once per RTO. Before the first cwnd adjustment, the ssthresh of the transport address SHOULD be set to the cwnd.",
      "ja": "エンドポイントが与えられたトランスポートアドレスにデータを送信しないもののO、トランスポート・アドレスのCWNDは（* MTU CWND / 2、4）一度RTOあたりmaxまで調整されるべきです。最初のcwnd調整する前に、トランスポート・アドレスのSSTHRESHはcwndのに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.27.3. Solution Description",
      "section_title": true,
      "ja": "3.27.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "A rule about cwnd adjustment after a sufficiently long idle period is removed.",
      "ja": "十分長いアイドル期間後にcwnd調整についてのルールが削除されます。"
    },
    {
      "indent": 3,
      "text": "The text is updated to describe the handling of ssthresh. When the idle period is detected, the cwnd value is copied to ssthresh.",
      "ja": "テキストはSSTHRESHの取り扱いを説明するために更新されます。アイドル期間が検出されると、CWNDの値がSSTHRESHにコピーされます。"
    },
    {
      "indent": 0,
      "text": "3.28. Window Updates after Receiver Window Opens Up",
      "section_title": true,
      "ja": "3.28。ウィンドウが更新レシーバウィンドウが開いた後"
    },
    {
      "indent": 0,
      "text": "3.28.1. Description of the Problem",
      "section_title": true,
      "ja": "3.28.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The sending of SACK chunks for window updates is only indirectly referenced in Section 6.2 of [RFC4960], which states that an SCTP receiver must not generate more than one SACK for every incoming packet, other than to update the offered window.",
      "ja": "ウィンドウの更新のためのSACKチャンクの送信のみ間接的に提供ウィンドウを更新するよりも、SCTP受信機は、他のすべての着信パケットに複数のSACKを生成してはならないと述べている[RFC4960]のセクション6.2で参照されています。"
    },
    {
      "indent": 3,
      "text": "However, to avoid performance problems, it is necessary to send the window updates when the receiver window opens up.",
      "ja": "しかし、パフォーマンスの問題を回避するために、受信ウィンドウが開いたときに、ウィンドウの更新を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.28.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.28.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An SCTP receiver MUST NOT generate more than one SACK for every incoming packet, other than to update the offered window as the receiving application consumes new data.",
      "ja": "SCTPの受信機は、受信側のアプリケーションは、新しいデータを消費として提供ウィンドウを更新するよりも、他のすべての着信パケットに複数のSACKを発生させてはいけません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An SCTP receiver MUST NOT generate more than one SACK for every incoming packet, other than to update the offered window as the receiving application consumes new data. When the window opens up, an SCTP receiver SHOULD send additional SACK chunks to update the window even if no new data is received. The receiver MUST avoid sending a large number of window updates -- in particular, large bursts of them. One way to achieve this is to send a window update only if the window can be increased by at least a quarter of the receive buffer size of the association.",
      "ja": "SCTPの受信機は、受信側のアプリケーションは、新しいデータを消費として提供ウィンドウを更新するよりも、他のすべての着信パケットに複数のSACKを発生させてはいけません。ウィンドウが開くと、SCTPの受信機は、新しいデータが受信されない場合でも、ウィンドウを更新するために、追加のSACKチャンクを送るべきです。それらの特定、大規模なバーストで - 受信機は、ウィンドウの更新を大量に送信しないようしなければなりません。これを達成する1つの方法は、ウィンドウが協会の受信バッファサイズの少なくとも四半期に増加させることができる場合にのみ、ウィンドウ更新を送信することです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.28.3. Solution Description",
      "section_title": true,
      "ja": "3.28.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text makes it clear that additional SACK chunks for window updates should be sent as long as excessive bursts are avoided.",
      "ja": "新しいテキストは、ウィンドウの更新のための追加SACKチャンクがいる限り、過度のバーストが回避されると送信されるべきであること、それが明らかになります。"
    },
    {
      "indent": 0,
      "text": "3.29. Path of DATA and Reply Chunks",
      "section_title": true,
      "ja": "3.29。 DATAおよび返信チャンクのパス"
    },
    {
      "indent": 0,
      "text": "3.29.1. Description of the Problem",
      "section_title": true,
      "ja": "3.29.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 6.4 of [RFC4960] describes the transmission policy for multi-homed SCTP endpoints. However, this policy has the following issues:",
      "ja": "[RFC4960]のセクション6.4は、マルチホームSCTPエンドポイントの送信ポリシーを記述する。しかし、この方針は、次の問題があります。"
    },
    {
      "indent": 3,
      "text": "o It states that a SACK should be sent to the source address of an incoming DATA. However, it is known that other SACK policies (e.g., always sending SACKs to the primary path) may be more beneficial in some situations.",
      "ja": "OそれはSACKが受信データの送信元アドレスに送信されなければならないと述べています。しかしながら、他のSACKポリシー（例えば、常にプライマリパスに袋を送る）がいくつかの状況では、より有益であり得ることが知られています。"
    },
    {
      "indent": 3,
      "text": "o Also, it initially states that an endpoint should always transmit DATA chunks to the primary path but then states that the rule for the transmittal of reply chunks should also be followed if the endpoint is bundling DATA chunks together with the reply chunk. The second statement contradicts the first statement. Some implementations were having problems with it and sent DATA chunks bundled with reply chunks to a different destination address than the primary path, causing many gaps.",
      "ja": "Oまた、最初にエンドポイントが常にプライマリパスへのデータチャンクを送信しなければならないと述べているが、その後、エンドポイントが応答チャンクと共にDATA塊を束ねている場合、応答チャンクの伝送のためのルールも従うべきであると述べています。 2番目のステートメントは、最初の文と矛盾します。いくつかの実装は、多くのギャップを引き起こして、プライマリパスとは異なる宛先アドレスに応答チャンクにバンドルされ、それに伴う問題と送信されたデータチャンクを有しました。"
    },
    {
      "indent": 0,
      "text": "3.29.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.29.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK, etc.) to the same destination transport address from which it received the DATA or control chunk to which it is replying. This rule should also be followed if the endpoint is bundling DATA chunks together with the reply chunk.",
      "ja": "エンドポイントは、それが返信されたデータまたは制御チャンクを受け、そこから同じ宛先トランスポートアドレスへ（例えば、SACK、HEARTBEAT ACK等）を返信チャンクを送信しなければなりません。エンドポイントが応答チャンクと一緒DATAチャンクをバンドルされている場合は、このルールにも従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, when acknowledging multiple DATA chunks received in packets from different source addresses in a single SACK, the SACK chunk may be transmitted to one of the destination transport addresses from which the DATA or control chunks being acknowledged were received.",
      "ja": "単一のSACKに異なる送信元アドレスからのパケットで受信した複数のデータチャンクを認める場合しかし、SACKチャンクは、データまたは制御チャンクが受信された肯定応答され、そこから先輸送アドレスの1つに送信することができます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD transmit reply chunks (e.g., INIT ACK, COOKIE ACK, HEARTBEAT ACK) in response to control chunks to the same destination transport address from which it received the control chunk to which it is replying.",
      "ja": "エンドポイントは、それが返信された制御チャンクを受け、そこから同じ宛先トランスポートアドレスにチャンクを制御するために応じて（例えば、INIT ACK、COOKIE A​​CK、HEARTBEAT ACK）応答チャンクを送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The selection of the destination transport address for packets containing SACK chunks is implementation dependent. However, an endpoint SHOULD NOT vary the destination transport address of a SACK when it receives DATA chunks coming from the same source address.",
      "ja": "SACKチャンクを含むパケットの宛先トランスポートアドレスの選択は実装依存です。それは、同じ送信元アドレスからのデータのチャンクを受信した場合しかし、エンドポイントは、SACKの宛先トランスポートアドレスを変えるべきではありません。"
    },
    {
      "indent": 3,
      "text": "When acknowledging multiple DATA chunks received in packets from different source addresses in a single SACK, the SACK chunk MAY be transmitted to one of the destination transport addresses from which the DATA or control chunks being acknowledged were received.",
      "ja": "単一のSACKに異なる送信元アドレスからのパケットで受信した複数のデータチャンクを認める場合、SACKチャンクは、データまたは制御チャンクが受信された肯定応答され、そこから先輸送アドレスの1つに送信することができます。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.29.3. Solution Description",
      "section_title": true,
      "ja": "3.29.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The SACK transmission policy is left implementation dependent, but the new text now specifies that the policy not vary the destination address of a packet containing a SACK chunk unless there are reasons for not doing so, as varying the destination address may negatively impact RTT measurement.",
      "ja": "SACK送信ポリシーは実装依存のままであるが、新しいテキストは、現在のポリシーが負RTT測定値に影響を与える可能性が宛先アドレスを変化させるように、そうしない理由がない限りSACKチャンクを含むパケットの宛先アドレスを変更しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "New text removes a confusing statement that prescribes following the rule for transmittal of reply chunks when the endpoint is bundling DATA chunks together with the reply chunk.",
      "ja": "新しいテキストは、エンドポイントが応答チャンクと一緒DATAチャンクをバンドルしたときの応答チャンクの送付のためのルールを以下の規定紛らわしい文を削除します。"
    },
    {
      "indent": 0,
      "text": "3.30. \"Outstanding Data\", \"Flightsize\", and \"Data in Flight\" Key Terms",
      "section_title": true,
      "ja": "3.30。 「フライトデータ」「の未処理データ」、「Flightsize」、および重要な用語"
    },
    {
      "indent": 0,
      "text": "3.30.1. Description of the Problem",
      "section_title": true,
      "ja": "3.30.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] uses the key terms \"outstanding data\", \"flightsize\", and \"data in flight\" in formulas and statements, but Section 1.3 (\"Key Terms\") of [RFC4960] does not provide their definitions. Furthermore, outstanding data does not include DATA chunks that are classified as lost but that have not yet been retransmitted, and there is a paragraph in Section 6.1 of [RFC4960] where this statement is broken.",
      "ja": "[RFC4960]は、「優れたデータ」、「flightsize」主要な用語を使用し、「飛行中のデータ」式や文ではなく、[RFC4960]のセクション1.3（「キー規約」）は、その定義を提供していません。さらに、優れたデータが失われたとして分類されているが、それはまだ再送されていない、とこのステートメントが壊れている[RFC4960]の6.1節で段落がある。DATAチャンクが含まれていません。"
    },
    {
      "indent": 0,
      "text": "3.30.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.30.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 1.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Congestion window (cwnd): An SCTP variable that limits the data, in number of bytes, a sender can send to a particular destination transport address before receiving an acknowledgement.",
      "ja": "O輻輳ウィンドウ（CWND）：バイト数で、データを制限するSCTP変数は、送信者が確認応答を受信する前に、特定の送付先輸送アドレスに送信することができます。"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 3,
      "text": "o Outstanding TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) that has been sent by the endpoint but for which it has not yet received an acknowledgement.",
      "ja": "O優れたTSN（SCTPエンドポイントで）：エンドポイントではなく、それはまだ確認応答を受信しなかったために送信されたTSN（および関連するデータチャンク）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 1.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Congestion window (cwnd): An SCTP variable that limits outstanding data, in number of bytes, that a sender can send to a particular destination transport address before receiving an acknowledgement.",
      "ja": "O輻輳ウィンドウ（CWND）：送信者が確認応答を受信する前に、特定の送付先輸送アドレスに送信することができることは、バイト数で、未処理のデータを制限するSCTP変数。"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 3,
      "text": "o Flightsize: The amount of bytes of outstanding data to a particular destination transport address at any given time.",
      "ja": "O Flightsize：任意の時点で特定の宛先トランスポートアドレスへ未処理データのバイト数。"
    },
    {
      "indent": 3,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 3,
      "text": "o Outstanding data (or \"data outstanding\" or \"data in flight\"): The total amount of the DATA chunks associated with outstanding TSNs. A retransmitted DATA chunk is counted once in outstanding data. A DATA chunk that is classified as lost but that has not yet been retransmitted is not in outstanding data.",
      "ja": "Oの未処理データ（または「未処理データ」または「飛行中のデータ」）：未処理のTSNに関連付けられたデータチャンクの合計量。再送されたデータチャンクは、優れたデータに一回カウントされます。失われたとして分類されているが、それはまだ再送されていないデータのチャンクは、優れたデータではありません。"
    },
    {
      "indent": 3,
      "text": "o Outstanding TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) that has been sent by the endpoint but for which it has not yet received an acknowledgement.",
      "ja": "O優れたTSN（SCTPエンドポイントで）：エンドポイントではなく、それはまだ確認応答を受信しなかったために送信されたTSN（および関連するデータチャンク）。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C) When the time comes for the sender to transmit, before sending new DATA chunks, the sender MUST first transmit any outstanding DATA chunks that are marked for retransmission (limited by the current cwnd).",
      "ja": "送信者が送信するための時間が来るとC）、新しいデータチャンクを送信する前に、送信者は、まず現在のcwndによって制限された再送（）のためにマークされているすべての未処理データチャンクを伝えなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C) When the time comes for the sender to transmit, before sending new DATA chunks, the sender MUST first transmit any DATA chunks that are marked for retransmission (limited by the current cwnd).",
      "ja": "送信者が送信するための時間が来るとC）、新しいデータチャンクを送信する前に、送信者は、まず現在のcwndによって制限された再送（）のためにマークされている任意のデータチャンクを伝えなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.30.3. Solution Description",
      "section_title": true,
      "ja": "3.30.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Section 1.3 is corrected to include explanations of the key terms \"outstanding data\", \"data in flight\", and \"flightsize\". Section 6.1 is corrected to now use \"any DATA chunks\" instead of \"any outstanding DATA chunks\".",
      "ja": "第1.3節は、主要な用語「卓越したデータ」、「飛行中のデータ」、および「flightsize」の説明を含めるように修正されます。 6.1節では、今の代わりに「未解決のDATAチャンク」の「すべてのデータの塊」を使用して補正しています。"
    },
    {
      "indent": 0,
      "text": "3.31. Degradation of cwnd due to Max.Burst",
      "section_title": true,
      "ja": "3.31。 Max.BurstによるCWNDの分解"
    },
    {
      "indent": 0,
      "text": "3.31.1. Description of the Problem",
      "section_title": true,
      "ja": "3.31.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Some implementations were experiencing a degradation of cwnd because of the Max.Burst limit. This was due to misinterpretation of the suggestion in Section 6.1 of [RFC4960] regarding how to use the Max.Burst parameter when calculating the number of packets to transmit.",
      "ja": "いくつかの実装があるためMax.Burst制限のcwndの低下を経験していました。これは、送信するパケットの数を計算する際Max.Burstパラメータを使用する方法については、[RFC4960]の6.1節で提案の誤解によるものでした。"
    },
    {
      "indent": 0,
      "text": "3.31.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.31.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D) When the time comes for the sender to transmit new DATA chunks, the protocol parameter Max.Burst SHOULD be used to limit the number of packets sent. The limit MAY be applied by adjusting cwnd as follows:",
      "ja": "時刻が新しいデータチャンクを送信する送信者となるとD）、プロトコルパラメータMax.Burstは、送信されたパケットの数を制限するために使用されるべきです。制限は次のようにCWNDを調整することによって適用することができます。"
    },
    {
      "indent": 6,
      "text": "if((flightsize + Max.Burst*MTU) < cwnd) cwnd = flightsize + Max.Burst*MTU",
      "ja": "IF（（flightsize + Max.Burst * MTU）<CWND）CWND = flightsize + Max.Burst * MTU"
    },
    {
      "indent": 6,
      "text": "Or it MAY be applied by strictly limiting the number of packets emitted by the output routine.",
      "ja": "それとも、厳密に出力ルーチンによって放出されたパケットの数を制限することによって適用することもできます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D) When the time comes for the sender to transmit new DATA chunks, the protocol parameter Max.Burst SHOULD be used to limit the number of packets sent. The limit MAY be applied by adjusting cwnd temporarily, as follows:",
      "ja": "時刻が新しいデータチャンクを送信する送信者となるとD）、プロトコルパラメータMax.Burstは、送信されたパケットの数を制限するために使用されるべきです。次のように制限は、一時的にCWNDを調整することによって適用することができます。"
    },
    {
      "indent": 6,
      "text": "if ((flightsize + Max.Burst*MTU) < cwnd) cwnd = flightsize + Max.Burst*MTU",
      "ja": "IF（（flightsize + Max.Burst * MTU）<CWND）CWND = flightsize + Max.Burst * MTU"
    },
    {
      "indent": 6,
      "text": "Or, it MAY be applied by strictly limiting the number of packets emitted by the output routine. When calculating the number of packets to transmit, and particularly when using the formula above, cwnd SHOULD NOT be changed permanently.",
      "ja": "それとも、それは厳密に出力ルーチンによって放出されたパケットの数を制限することによって適用することもできます。送信するパケットの数を計算する場合、上記の式を用いて、特にとき、CWNDが永久変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.31.3. Solution Description",
      "section_title": true,
      "ja": "3.31.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clarifies that cwnd should not be changed when applying the Max.Burst limit. This mitigates packet bursts related to the reception of SACK chunks but not bursts related to an application sending a burst of user messages.",
      "ja": "新しいテキストはMax.Burstの制限を適用するときにcwndを変更すべきではないことを明確にしています。これは、ユーザ・メッセージのバーストを送信するアプリケーションに関連SACKチャンクではなくバーストの受信に関連するパケットバーストを軽減します。"
    },
    {
      "indent": 0,
      "text": "3.32. Reduction of RTO.Initial",
      "section_title": true,
      "ja": "3.32。 RTO.Initialの削減"
    },
    {
      "indent": 0,
      "text": "3.32.1. Description of the Problem",
      "section_title": true,
      "ja": "3.32.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] uses 3 seconds as the default value for RTO.Initial in accordance with Section 4.2.3.1 of [RFC1122]. [RFC6298] updates [RFC1122] and lowers the initial value of the retransmission timer from 3 seconds to 1 second.",
      "ja": "[RFC4960]は[RFC1122]のセクション4.2.3.1に従ってRTO.Initialのデフォルト値として3秒を使用します。 [RFC6298]アップデート[RFC1122]と3秒から1秒まで再送タイマの初期値を低下させます。"
    },
    {
      "indent": 0,
      "text": "3.32.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.32.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 15)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 6,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds Max.Burst - 4 RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds HB.Max.Burst - 1",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  4 RTO.Alpha  -   -  Max.Burst 60秒1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans -  10試みるPath.Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.interval  -  30秒HB.Max.Burst  -  1"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 15)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 6,
      "text": "RTO.Initial: 1 second RTO.Min: 1 second RTO.Max: 60 seconds Max.Burst: 4 RTO.Alpha: 1/8 RTO.Beta: 1/4 Valid.Cookie.Life: 60 seconds Association.Max.Retrans: 10 attempts Path.Max.Retrans: 5 attempts (per destination address) Max.Init.Retransmits: 8 attempts HB.interval: 30 seconds HB.Max.Burst: 1 SACK.Delay: 200 milliseconds",
      "ja": "RTO.Initial：1秒RTO.Min：1秒RTO.Max：60秒Max.Burst：4 RTO.Alpha：1/8 RTO.Beta：1/4 Valid.Cookie.Life：60秒Association.Max.Retrans ：10試みるPath.Max.Retrans：（宛先アドレスごと）5つの試みMax.Init.Retransmits：8つの試みHB.interval：30秒HB.Max.Burst：1 SACK.Delay：200ミリ秒"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.24. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.24からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.32.3. Solution Description",
      "section_title": true,
      "ja": "3.32.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The default value for RTO.Initial has been lowered to 1 second to be in tune with [RFC6298].",
      "ja": "RTO.Initialのデフォルト値は[RFC6298]と曲になるように1秒に低下しています。"
    },
    {
      "indent": 0,
      "text": "3.33. Ordering of Bundled SACK and ERROR Chunks",
      "section_title": true,
      "ja": "3.33。バンドルSACKとERRORチャンクの注文"
    },
    {
      "indent": 0,
      "text": "3.33.1. Description of the Problem",
      "section_title": true,
      "ja": "3.33.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When an SCTP endpoint receives a DATA chunk with an invalid stream identifier, it shall acknowledge it by sending a SACK chunk and indicate that the stream identifier was invalid by sending an ERROR chunk. These two chunks may be bundled. However, in the case of bundling, [RFC4960] requires that the ERROR chunk follow the SACK chunk. This restriction regarding the ordering of the chunks is not necessary and might limit interoperability.",
      "ja": "SCTP終点が無効なストリーム識別子とデータチャンクを受信すると、SACKチャンクを送信することによって、それを承認し、ストリーム識別子はERRORチャンクを送信することにより無効であることを示すものとします。これらの2つのチャンクをバンドルすることができます。ただし、同梱の場合は、[RFC4960]はERRORチャンクがSACKチャンクに従うことが必要です。チャンクの順序に関するこの制限は必要ではなく、相互運用性を制限される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.33.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.33.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Every DATA chunk MUST carry a valid stream identifier. If an endpoint receives a DATA chunk with an invalid stream identifier, it shall acknowledge the reception of the DATA chunk following the normal procedure, immediately send an ERROR chunk with cause set to \"Invalid Stream Identifier\" (see Section 3.3.10), and discard the DATA chunk. The endpoint may bundle the ERROR chunk in the same packet as the SACK as long as the ERROR follows the SACK.",
      "ja": "すべてのデータ・チャンクは有効なストリーム識別子を運ばなければなりません。エンドポイントが無効なストリーム識別子とデータチャンクを受信した場合、それはすぐに「無効なストリーム識別子」に設定し、原因とERRORチャンクを送って、通常の手順以下のDATAチャンクの受信を確認しなければならない（セクション3.3.10を参照）、およびデータチャンクを破棄します。エンドポイントは、限りERRORがSACKを次のようにSACKと同じパケットにERRORチャンクをバンドルすることがあります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Every DATA chunk MUST carry a valid stream identifier. If an endpoint receives a DATA chunk with an invalid stream identifier, it SHOULD acknowledge the reception of the DATA chunk following the normal procedure, immediately send an ERROR chunk with cause set to \"Invalid Stream Identifier\" (see Section 3.3.10), and discard the DATA chunk. The endpoint MAY bundle the ERROR chunk and the SACK chunk in the same packet.",
      "ja": "すべてのデータ・チャンクは有効なストリーム識別子を運ばなければなりません。エンドポイントが無効なストリーム識別子とデータチャンクを受信した場合、それはすぐに「無効なストリーム識別子」に設定し、原因とERRORチャンクを送って、通常の手順以下のDATAチャンクの受信を確認すべきである（セクション3.3.10を参照）、およびデータチャンクを破棄します。エンドポイントは、同じパケットにERRORチャンクとSACKチャンクをバンドルするかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.33.3. Solution Description",
      "section_title": true,
      "ja": "3.33.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The unnecessary restriction regarding the ordering of the SACK and ERROR chunks has been removed.",
      "ja": "SACKとERRORチャンクの順序に関する不必要な制限が削除されました。"
    },
    {
      "indent": 0,
      "text": "3.34. Undefined Parameter Returned by RECEIVE Primitive",
      "section_title": true,
      "ja": "3.34。未定義のパラメータは、プリミティブRECEIVEによって返さ"
    },
    {
      "indent": 0,
      "text": "3.34.1. Description of the Problem",
      "section_title": true,
      "ja": "3.34.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] provides a description of an abstract API. In the definition of the RECEIVE primitive, an optional parameter with name \"delivery number\" is mentioned. However, no definition of this parameter is given in [RFC4960], and the parameter is unnecessary.",
      "ja": "[RFC4960]はアブストラクトAPIの説明を提供します。定義に記載されている、名称「伝票番号」のオプションのパラメータをプリミティブ受信します。しかし、このパラメータのない定義は、[RFC4960]に与えられていない、およびパラメータが不要です。"
    },
    {
      "indent": 0,
      "text": "3.34.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.34.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 G))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "G) Receive",
      "ja": "G）を受信"
    },
    {
      "indent": 3,
      "text": "Format: RECEIVE(association id, buffer address, buffer size [,stream id]) -> byte count [,transport address] [,stream id] [,stream sequence number] [,partial flag] [,delivery number] [,payload protocol-id]",
      "ja": "フォーマット：受信（アソシエーションID、バッファアドレス、バッファサイズ[、ストリームID]） - >バイト数〔、トランスポートアドレス] [、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [伝票番号] [ペイロードプロトコルID]"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 G))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "G) Receive",
      "ja": "G）を受信"
    },
    {
      "indent": 3,
      "text": "Format: RECEIVE(association id, buffer address, buffer size [,stream id]) -> byte count [,transport address] [,stream id] [,stream sequence number] [,partial flag] [,payload protocol-id]",
      "ja": "フォーマット：受信（アソシエーションID、バッファアドレス、バッファサイズ[、ストリームID]） - >バイト数〔、トランスポートアドレス] [、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [、ペイロードプロトコルID]"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.34.3. Solution Description",
      "section_title": true,
      "ja": "3.34.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The undefined parameter has been removed.",
      "ja": "未定義のパラメータが削除されました。"
    },
    {
      "indent": 0,
      "text": "3.35. DSCP Changes",
      "section_title": true,
      "ja": "3.35。 DSCPの変更"
    },
    {
      "indent": 0,
      "text": "3.35.1. Description of the Problem",
      "section_title": true,
      "ja": "3.35.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The upper layer can change the Differentiated Services Code Point (DSCP) used for packets being sent. Changing the DSCP can result in packets hitting different queues on the path. Therefore, congestion control should be initialized when the DSCP is changed by the upper layer. This is not described in [RFC4960].",
      "ja": "上位レイヤは、パケットのために使用される差別化サービスコードポイント（DSCP）が送信されて変更することができます。 DSCPを変更すると、パス上の異なるキューを打つパケットになります。 DSCPが上層により変更されたときしたがって、輻輳制御は、初期化されなければなりません。これは、[RFC4960]に記載されていません。"
    },
    {
      "indent": 0,
      "text": "3.35.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.35.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.5. Making Changes to Differentiated Services Code Points",
      "section_title": true,
      "ja": "7.2.5。 DiffServコードポイントの変更"
    },
    {
      "indent": 6,
      "text": "SCTP implementations MAY allow an application to configure the Differentiated Services Code Point (DSCP) used for sending packets. If a DSCP change might result in outgoing packets being queued in different queues, the congestion control parameters for all affected destination addresses MUST be reset to their initial values.",
      "ja": "SCTPの実装は、アプリケーションがパケットを送信するために使用される差別化サービスコードポイント（DSCP）を設定することを可能にします。 DSCPの変更は、異なるキューにキューイングされた発信パケットにつながる可能性がある場合、影響を受けるすべての宛先アドレスのための輻輳制御パラメータが初期値にリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 M))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o protocol parameter list - the specific names and values of the protocol parameters (e.g., Association.Max.Retrans; see Section 15) that the SCTP user wishes to customize.",
      "ja": "Oプロトコルパラメータリスト - プロトコルパラメータの特定の名前と値（例えば、Association.Max.Retrans、セクション15を参照）をSCTPユーザがカスタマイズすることを望みます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 M))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o protocol parameter list - the specific names and values of the protocol parameters (e.g., Association.Max.Retrans (see Section 15), or other parameters like the DSCP) that the SCTP user wishes to customize.",
      "ja": "Oプロトコルパラメータリスト -  SCTPユーザがカスタマイズしたいプロトコルのパラメータ（例えば、Association.Max.Retrans（セクション15を参照）、またはDSCPのような他のパラメータ）の特定の名前と値。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.35.3. Solution Description",
      "section_title": true,
      "ja": "3.35.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Text describing the required action for DSCP changes has been added.",
      "ja": "DSCPの変更のために必要なアクションを記述したテキストが追加されました。"
    },
    {
      "indent": 0,
      "text": "3.36. Inconsistent Handling of ICMPv4 and ICMPv6 Messages",
      "section_title": true,
      "ja": "3.36。 ICMPv4のとICMPv6のメッセージの一貫性のない取扱い"
    },
    {
      "indent": 0,
      "text": "3.36.1. Description of the Problem",
      "section_title": true,
      "ja": "3.36.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Appendix C of [RFC4960] describes the handling of ICMPv4 and ICMPv6 messages. The handling of ICMP messages indicating that the port number is unreachable, as described in the enumerated procedures, is not consistent with the description given in [RFC4960] after the procedures. Furthermore, the text explicitly describes the handling of ICMPv6 packets indicating reachability problems but does not do the same for the corresponding ICMPv4 packets.",
      "ja": "[RFC4960]の付録CはのICMPv4とICMPv6のメッセージの処理を記述します。列挙された手順に記載されているようにポート番号が、到達不能であることを示すICMPメッセージの処理は、手順の後に[RFC4960]での説明と一致しません。さらに、テキストは明示的に到達可能性の問題を示すのICMPv6パケットの処理を記述しますが、対応するICMPv4のパケットに対して同じことをしていません。"
    },
    {
      "indent": 0,
      "text": "3.36.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.36.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP3) An implementation MAY ignore any ICMPv4 messages where the code does not indicate \"Protocol Unreachable\" or \"Fragmentation Needed\".",
      "ja": "ICMP3）実装では、コードは「プロトコル到達不能」または「断片化必要」を示すものではありません任意のICMPv4のメッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP3) An implementation SHOULD ignore any ICMP messages where the code indicates \"Port Unreachable\".",
      "ja": "ICMP3）実装では、コードが「ポート到達不能」を示す任意のICMPメッセージを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMPv6 code is \"Destination Unreachable\", the implementation MAY mark the destination into the unreachable state or alternatively increment the path error counter.",
      "ja": "ICMP9 ICMPv6のコードが「到達不能宛先」である場合）、実装が到達不能状態に宛先をマーク又は代替パス・エラー・カウンタをインクリメントするかもしれません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMP type is \"Destination Unreachable\", the implementation MAY move the destination to the unreachable state or, alternatively, increment the path error counter.",
      "ja": "ICMP9 ICMPタイプが「到達不能宛先」である場合）、実装がパス・エラー・カウンタをインクリメント、あるいは、到達不能な状態に宛先を移動したりしてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It is further updated in Section 3.37.",
      "ja": "このテキストは、複数の正誤表で変更されています。それはさらに、セクション3.37に更新されます。"
    },
    {
      "indent": 0,
      "text": "3.36.3. Solution Description",
      "section_title": true,
      "ja": "3.36.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text has been changed to describe the intended handling of ICMP messages indicating that the port number is unreachable by replacing the third rule. Also, the limitation to ICMPv6 in the ninth rule has been removed.",
      "ja": "テキストは、ポート番号が3番目のルールを置き換えることによって到達不能であることを示すICMPメッセージの意図された処理を記述するために変更されています。また、第九のルールでのICMPv6に制限が除去されています。"
    },
    {
      "indent": 0,
      "text": "3.37. Handling of Soft Errors",
      "section_title": true,
      "ja": "3.37。ソフトエラーの取り扱い"
    },
    {
      "indent": 0,
      "text": "3.37.1. Description of the Problem",
      "section_title": true,
      "ja": "3.37.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC1122] defines the handling of soft errors and hard errors for TCP. Appendix C of [RFC4960] only deals with hard errors.",
      "ja": "[RFC1122]はTCPのためのソフト・エラーとハードエラーの処理を定義します。 [RFC4960]の付録Cはハードエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "3.37.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.37.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMPv6 code is \"Destination Unreachable\", the implementation MAY mark the destination into the unreachable state or alternatively increment the path error counter.",
      "ja": "ICMP9 ICMPv6のコードが「到達不能宛先」である場合）、実装が到達不能状態に宛先をマーク又は代替パス・エラー・カウンタをインクリメントするかもしれません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMP type is \"Destination Unreachable\", the implementation MAY move the destination to the unreachable state or, alternatively, increment the path error counter. SCTP MAY provide information to the upper layer indicating the reception of ICMP messages when reporting a network status change.",
      "ja": "ICMP9 ICMPタイプが「到達不能宛先」である場合）、実装がパス・エラー・カウンタをインクリメント、あるいは、到達不能な状態に宛先を移動したりしてもよい（MAY）。 SCTPは、ネットワークの状態変化を報告するときにICMPメッセージの受信を示す上位層に情報を提供することができます。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.36. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.36からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.37.3. Solution Description",
      "section_title": true,
      "ja": "3.37.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Text has been added allowing SCTP to notify the application in the case of soft errors.",
      "ja": "テキストは、SCTPは、ソフトエラーの場合にアプリケーションに通知できるように追加されています。"
    },
    {
      "indent": 0,
      "text": "3.38. Honoring cwnd",
      "section_title": true,
      "ja": "3.38。尊重のcwnd"
    },
    {
      "indent": 0,
      "text": "3.38.1. Description of the Problem",
      "section_title": true,
      "ja": "3.38.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When using the slow start algorithm, SCTP increases the congestion window only when it is being fully utilized. Since SCTP uses DATA chunks and does not use the congestion window to fragment user messages, this requires that some overbooking of the congestion window be allowed.",
      "ja": "スロースタートアルゴリズムを使用する場合、SCTPは、それが完全に利用されているだけ混雑ウィンドウを増加させます。 SCTPがDATAチャンクを使用して、ユーザーメッセージを断片化するために輻輳ウィンドウを使用していないので、これは輻輳ウィンドウのいくつかのオーバーブッキングが許可されている必要があります。"
    },
    {
      "indent": 0,
      "text": "3.38.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.38.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.",
      "ja": "それはcwndをまたはそのトランスポートアドレスへの未処理データのより多くのバイトをしている場合B）任意の時点で、送信者は、与えられた輸送アドレスに新しいデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd + (PMTU - 1) or more bytes of data outstanding to that transport address. If data is available, the sender SHOULD exceed cwnd by up to (PMTU - 1) bytes on a new data transmission if the flightsize does not currently reach cwnd. The breach of cwnd MUST constitute one packet only.",
      "ja": "そのトランスポートアドレスへの未処理データの1）バイト以上 - それは+（PMTU cwndをしている場合B）任意の時点で、送信者は、与えられた輸送アドレスに新しいデータを送信してはなりません。 flightsizeが現在のcwndに到達しない場合 - （1 PMTU）、新たなデータ伝送にバイトのデータが利用可能な場合、送信者は最大でのcwndを超えている必要があります。 cwndの違反は、一つのパケットのみを構成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd bytes of data outstanding on that transport address.",
      "ja": "CWNDがゼロよりも大きいときはいつでも、O、エンドポイントは、そのトランスポートアドレス上の未処理データのcwndのバイトを持つことが許されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd bytes of data outstanding on that transport address. A limited overbooking as described in Section 6.1 B) SHOULD be supported.",
      "ja": "CWNDがゼロよりも大きいときはいつでも、O、エンドポイントは、そのトランスポートアドレス上の未処理データのcwndのバイトを持つことが許されます。セクション6.1 B）に記載のように限られたオーバーブッキングがサポートされるべきです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.38.3. Solution Description",
      "section_title": true,
      "ja": "3.38.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Text was added to clarify how the cwnd limit should be handled.",
      "ja": "テキストはcwndの制限をどのように処理するかを明確にするために追加されました。"
    },
    {
      "indent": 0,
      "text": "3.39. Zero Window Probing",
      "section_title": true,
      "ja": "3.39。プロービングゼロウィンドウ"
    },
    {
      "indent": 0,
      "text": "3.39.1. Description of the Problem",
      "section_title": true,
      "ja": "3.39.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The text in Section 6.1 of [RFC4960] that describes zero window probing does not clearly address the case where the window is not zero but is too small for the next DATA chunk to be transmitted. Even in this case, zero window probing has to be performed to avoid deadlocks.",
      "ja": "プロービングゼロウィンドウを記述する[RFC4960]のセクション6.1のテキストが明確にウィンドウがゼロではなく、送信されるべき次のデータチャンクに対して小さすぎる場合には対応していません。この場合であっても、プロービングゼロウィンドウがデッドロックを回避するために実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.39.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.39.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0; see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B, below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK's having been lost in transit from the data receiver to the data sender.",
      "ja": "セクション6.2.1を参照）;そのピアのRWNDピア（すなわち、RWNDが0でないバッファスペースを有していないことを示す場合A）は、任意の所与の時点で、データ送信者は任意の宛先トランスポートアドレスに新しいデータを送信してはいけません。 CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下、ルールBを参照）。このルールは、送信者は送信者が原因SACKのデータ送信側にデータ受信機から輸送中に紛失されていたこと逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 6,
      "text": "When the receiver's advertised window is zero, this probe is called a zero window probe. Note that a zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight. Zero window probing MUST be supported.",
      "ja": "受信機の広告ウィンドウがゼロの場合、このプローブは、ゼロウィンドウプローブと呼ばれています。すべての未処理データのチャンクが累積的に認められているとはデータのチャンクが飛行中でないときにゼロウィンドウプローブのみが送信されるべきであることに注意してください。プロービングゼロウィンドウをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is smaller than the size of the next DATA chunk; see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B, below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK's having been lost in transit from the data receiver to the data sender.",
      "ja": "そのピアのRWNDは、ピアが何のバッファ・スペースを持っていないことを示す場合A）任意の時点で、データの送信者はすなわち、RWNDは、次のデータチャンクのサイズよりも小さくなっている（任意の宛先トランスポートアドレスに新しいデータを送信してはならない;セクション6.2を参照してください0.1）。 CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下、ルールBを参照）。このルールは、送信者は送信者が原因SACKのデータ送信側にデータ受信機から輸送中に紛失されていたこと逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 6,
      "text": "When the receiver has no buffer space, this probe is called a zero window probe. Note that a zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight. Zero window probing MUST be supported.",
      "ja": "受信機は何のバッファスペースを有していない場合、このプローブは、ゼロウィンドウプローブと呼ばれています。すべての未処理データのチャンクが累積的に認められているとはデータのチャンクが飛行中でないときにゼロウィンドウプローブのみが送信されるべきであることに注意してください。プロービングゼロウィンドウをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.39.3. Solution Description",
      "section_title": true,
      "ja": "3.39.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The terminology is used in a cleaner way.",
      "ja": "専門用語は、きれいな方法で使用されています。"
    },
    {
      "indent": 0,
      "text": "3.40. Updating References regarding ECN",
      "section_title": true,
      "ja": "3.40。 ECNについての更新参照"
    },
    {
      "indent": 0,
      "text": "3.40.1. Description of the Problem",
      "section_title": true,
      "ja": "3.40.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "For Explicit Congestion Notification (ECN), [RFC4960] refers only to [RFC3168], which has been updated by [RFC8311]. This needs to be reflected in the text when referring to ECN.",
      "ja": "明示的輻輳通知（ECN）のために、[RFC4960]は[RFC8311]で更新された[RFC3168]にだけ指します。これは、ECNを参照するときにテキストに反映させる必要があります。"
    },
    {
      "indent": 0,
      "text": "3.40.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.40.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ECN [RFC3168] describes a proposed extension to IP that details a method to become aware of congestion outside of datagram loss.",
      "ja": "ECN [RFC3168]は、データグラムの損失の外輻輳の自覚する方法を詳述IPに提案された拡張を記述しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ECN as specified in [RFC3168] (updated by [RFC8311]) describes an extension to IP that details a method for becoming aware of congestion outside of datagram loss.",
      "ja": "[RFC3168]（[RFC8311]によって更新）に指定されているECNは、データグラム損失の外渋滞の認識になるための方法を詳細にIPへの拡張を記述しています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In general, [RFC3168] should be followed with the following exceptions.",
      "ja": "一般的には、[RFC3168]は以下の例外を除いて従うべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In general, [RFC3168] (updated by [RFC8311]) SHOULD be followed, with the following exceptions.",
      "ja": "一般的には、（[RFC8311]によって更新）[RFC3168]は以下の例外を除いて、追跡するべきです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] details negotiation of ECN during the SYN and SYN-ACK stages of a TCP connection.",
      "ja": "[RFC3168]はTCP接続のSYNおよびSYN-ACK段階でECNのネゴシエーションを詳述します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] (updated by [RFC8311]) details the negotiation of ECN during the SYN and SYN-ACK stages of a TCP connection.",
      "ja": "[RFC3168]（[RFC8311]によって更新）は、TCP接続のSYNおよびSYN-ACK段階でECNのネゴシエーションを詳述します。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] details a specific bit for a receiver to send back in its TCP acknowledgements to notify the sender of the Congestion Experienced (CE) bit having arrived from the network.",
      "ja": "[RFC3168]は、受信機が経験輻輳の送信者に通知するために、そのTCP確認応答で返送するための特定のビットを詳細（CE）ビットがネットワークから到着しました。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] (updated by [RFC8311]) details a specific bit for a receiver to send back in its TCP acknowledgements to notify the sender of the Congestion Experienced (CE) bit that the CE bit has arrived from the network.",
      "ja": "[RFC3168]（[RFC8311]によって更新）輻輳経験（CE）の送信者に通知するために、そのTCP確認応答に返信する受信機のための特定のビットを詳細CEビットがネットワークから到着したそのビット。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] details a specific bit for a sender to send in the header of its next outbound TCP segment to indicate to its peer that it has reduced its congestion window.",
      "ja": "[RFC3168]は、その輻輳ウィンドウを減少させたことをピアに示すために、その次のアウトバウンドTCPセグメントのヘッダに送信する送信者の特定のビットを詳述します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix A)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC3168] (updated by [RFC8311]) details a specific bit for a sender to send in the header of its next outbound TCP segment to indicate to its peer that it has reduced its congestion window.",
      "ja": "[RFC3168]（[RFC8311]によって更新）は、その輻輳ウィンドウを減少させたことをピアに示すために、その次のアウトバウンドTCPセグメントのヘッダに送信する送信者の特定のビットを詳述します。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.40.3. Solution Description",
      "section_title": true,
      "ja": "3.40.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "References to [RFC8311] have been added. Some wordsmithing was also done while making those updates.",
      "ja": "[RFC8311]への参照が追加されました。これらの更新をしながらいくつかのwordsmithingも行われました。"
    },
    {
      "indent": 0,
      "text": "3.41. Host Name Address Parameter Deprecated",
      "section_title": true,
      "ja": "3.41。名前アドレスパラメータの非推奨ホスト"
    },
    {
      "indent": 0,
      "text": "3.41.1. Description of the Problem",
      "section_title": true,
      "ja": "3.41.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC4960] defines three types of address parameters to be used with INIT and INIT ACK chunks:",
      "ja": "[RFC4960]はINITとINIT ACKチャンクで使用するアドレスパラメータの三種類を定義しています。"
    },
    {
      "indent": 3,
      "text": "1. IPv4 Address parameters.",
      "section_title": true,
      "ja": "1. IPv4アドレスパラメータ。"
    },
    {
      "indent": 3,
      "text": "2. IPv6 Address parameters.",
      "section_title": true,
      "ja": "2. IPv6アドレスパラメータ。"
    },
    {
      "indent": 3,
      "text": "3. Host Name Address parameters.",
      "section_title": true,
      "ja": "3.ホスト名アドレスパラメータ。"
    },
    {
      "indent": 3,
      "text": "The first two parameter types are supported by the SCTP kernel implementations of FreeBSD, Linux, and Solaris, but the third is not. In addition, the first two were successfully tested in all nine interoperability tests for SCTP, but the third has never been successfully tested. Therefore, the Host Name Address parameter should be deprecated.",
      "ja": "最初の2つのパラメータのタイプは、FreeBSD、Linux、およびSolarisのSCTPカーネルの実装によってサポートされていますが、第三ではありません。また、最初の二つが正常にSCTPのための9回のすべての相互運用性テストで試験したが、第三は、正常にテストされていません。そのため、ホスト名Addressパラメータは廃止されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.41.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.41.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT chunk MUST NOT contain more than one Host Name Address parameter. Moreover, the sender of the INIT MUST NOT combine any other address types with the Host Name Address in the INIT. The receiver of INIT MUST ignore any other address types if the Host Name Address parameter is present in the received INIT chunk.",
      "ja": "注3：INITチャンクは、複数のホスト名Addressパラメータを含めることはできません。また、INITの送信者はINITでのホスト名のアドレスを他のアドレスタイプを組み合わせるてはなりません。ホスト名アドレスパラメータが受信INITチャンクに存在する場合にINITの受信者は、他のアドレスタイプを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT chunk MUST NOT contain the Host Name Address parameter. The receiver of an INIT chunk containing a Host Name Address parameter MUST send an ABORT and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "注3：INITチャンクはホスト名アドレスパラメータを含めることはできません。ホスト名アドレスパラメータを含むINITチャンクの受信機は、ABORTを送らなければなりませんし、「解決できないアドレス」のエラー原因を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of INIT uses this parameter to pass its Host Name (in place of its IP addresses) to its peer. The peer is responsible for resolving the name. Using this parameter might make it more likely for the association to work across a NAT box.",
      "ja": "INITの送信者は、そのピアに（そのIPアドレスの代わりに）そのホスト名を渡すために、このパラメータを使用しています。ピアは名前を解決する責任があります。このパラメータを使用すると、それは可能性が高い関連がNATボックスを越えて動作できるようにするためかもしれません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of an INIT chunk MUST NOT include this parameter. The usage of the Host Name Address parameter is deprecated.",
      "ja": "INITチャンクの送信者は、このパラメータを含んではいけません。ホスト名のAddressパラメータの使用は推奨されません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type: 16 bits (unsigned integer)",
      "ja": "アドレスタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is filled with the type value of the corresponding address TLV (e.g., IPv4 = 5, IPv6 = 6, Host name = 11).",
      "ja": "これは、対応するアドレスTLV（例えば、= 5のIPv4、IPv6の= 6、ホスト名= 11）の型の値で満たされています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type: 16 bits (unsigned integer)",
      "ja": "アドレスタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is filled with the type value of the corresponding address TLV (e.g., IPv4 = 5, IPv6 = 6). The value indicating the Host Name Address parameter (Host name = 11) MUST NOT be used.",
      "ja": "これは、対応するアドレスTLVのタイプの値（例えば、IPv4の= 5、IPv6の= 6）が充填されています。ホスト名アドレスパラメータ（ホスト名= 11）を示す値を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 3: The INIT ACK chunks MUST NOT contain more than one Host Name Address parameter. Moreover, the sender of the INIT ACK MUST NOT combine any other address types with the Host Name Address in the INIT ACK. The receiver of the INIT ACK MUST ignore any other address types if the Host Name Address parameter is present.",
      "ja": "注3：INITのACKチャンクは、複数のホスト名Addressパラメータを含めることはできません。また、INIT ACKの送信者はINIT ACKでのホスト名のアドレスを他のアドレスタイプを組み合わせるてはなりません。ホスト名アドレスパラメータが存在する場合はINIT ACKの受信機は、他のアドレスの種類を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT ACK chunk MUST NOT contain the Host Name Address parameter. The receiver of INIT ACK chunks containing a Host Name Address parameter MUST send an ABORT and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "注3：INIT ACKチャンクはホスト名アドレスパラメータを含めることはできません。ホスト名アドレスパラメータを含むINITのACKチャンクの受信機は、ABORTを送らなければなりませんし、「解決できないアドレス」のエラー原因を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) If there is a Host Name parameter present in the received INIT or INIT ACK chunk, the endpoint shall resolve that host name to a list of IP address(es) and derive the transport address(es) of this peer by combining the resolved IP address(es) with the SCTP source port.",
      "ja": "受信INITまたはINIT ACKチャンクに存在するホスト名パラメータがある場合はB）、エンドポイントは、IPアドレス（複数可）のリストにそのホスト名を解決し、解決を組み合わせることにより、このピアのトランスポートアドレス（複数可）を導出するものSCTPソースポートとIPアドレス（複数可）。"
    },
    {
      "indent": 6,
      "text": "The endpoint MUST ignore any other IP Address parameters if they are also present in the received INIT or INIT ACK chunk.",
      "ja": "彼らはまた、受信したINITまたはINIT ACKチャンクに存在している場合、エンドポイントは、他のIPアドレスのパラメータを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The time at which the receiver of an INIT resolves the host name has potential security implications to SCTP. If the receiver of an INIT resolves the host name upon the reception of the chunk, and the mechanism the receiver uses to resolve the host name involves potential long delay (e.g., DNS query), the receiver may open itself up to resource attacks for the period of time while it is waiting for the name resolution results before it can build the State Cookie and release local resources.",
      "ja": "INITの受信者は、ホスト名を解決する時間は、SCTPへの潜在的なセキュリティ上の意味を持ちます。 INITの受信機は、チャンクの受信時にホスト名を解決し、受信機は、ホスト名を解決するために使用するメカニズムは、潜在的な長時間の遅延（例えば、DNSクエリ）を含み、受信機は、のために攻撃を資源に自分自身を開く可能性がある場合それは国家クッキーを構築し、ローカルリソースを解放することができます前に、それは名前解決の結果を待っている期間。"
    },
    {
      "indent": 6,
      "text": "Therefore, in cases where the name translation involves potential long delay, the receiver of the INIT MUST postpone the name resolution till the reception of the COOKIE ECHO chunk from the peer. In such a case, the receiver of the INIT SHOULD build the State Cookie using the received Host Name (instead of destination transport addresses) and send the INIT ACK to the source IP address from which the INIT was received.",
      "ja": "したがって、名前変換は、潜在的に長い遅延を伴う場合には、INITの受信ピアからCOOKIE ECHOチャンクの受信までの名前解決を延期しなければなりません。このような場合には、（代わりに送付先輸送アドレスの）受信したホスト名を使用して状態クッキーを構築する必要がありINITの受信機とは、INITが受信された送信元IPアドレスにINIT ACKを送信します。"
    },
    {
      "indent": 6,
      "text": "The receiver of an INIT ACK shall always immediately attempt to resolve the name upon the reception of the chunk.",
      "ja": "INIT ACKの受信機は、常にすぐにチャンクを受信すると、名前を解決しようとするもの。"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT or INIT ACK MUST NOT send user data (piggy-backed or stand-alone) to its peer until the host name is successfully resolved.",
      "ja": "ホスト名が正常に解決されるまで、INITまたはINIT ACKの受信機は、そのピアに（ピギーバックまたはスタンドアロン）のユーザデータを送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "If the name resolution is not successful, the endpoint MUST immediately send an ABORT with \"Unresolvable Address\" error cause to its peer. The ABORT shall be sent to the source IP address from which the last peer packet was received.",
      "ja": "名前解決が成功しなかった場合、エンドポイントは、すぐにそのピアに「解決できないアドレス」エラーの原因とABORTを送らなければなりません。 ABORTは最後のピア・パケットが受信された送信元のIPアドレスに送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) If there is a Host Name Address parameter present in the received INIT or INIT ACK chunk, the endpoint MUST immediately send an ABORT and MAY include an \"Unresolvable Address\" error cause to its peer. The ABORT SHALL be sent to the source IP address from which the last peer packet was received.",
      "ja": "受信INITまたはINIT ACKチャンクに存在するホスト名Addressパラメータがある場合はB）、エンドポイントはすぐにABORTを送らなければなりませんし、そのピアに「解決できないアドレス」のエラー原因を含むかもしれません。 ABORTは、最後のピア・パケットが受信された送信元IPアドレスに送付されなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 11.2.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The use of the host name feature in the INIT chunk could be used to flood a target DNS server. A large backlog of DNS queries, resolving the host name received in the INIT chunk to IP addresses, could be accomplished by sending INITs to multiple hosts in a given domain. In addition, an attacker could use the host name feature in an indirect attack on a third party by sending large numbers of INITs to random hosts containing the host name of the target. In addition to the strain on DNS resources, this could also result in large numbers of INIT ACKs being sent to the target. One method to protect against this type of attack is to verify that the IP addresses received from DNS include the source IP address of the original INIT. If the list of IP addresses received from DNS does not include the source IP address of the INIT, the endpoint MAY silently discard the INIT. This last option will not protect against the attack against the DNS.",
      "ja": "INITチャンクのホスト名機能を使用すると、ターゲットDNSサーバーをあふれさせるために使用することができます。 DNSクエリの大きなバックログは、IPアドレスにINITチャンクに受信したホスト名を解決し、特定のドメイン内の複数のホストへのINIT送信することによって達成することができます。また、攻撃者は、ターゲットのホスト名を含むランダムホストへのINITを大量に送信することにより、第三者への間接的な攻撃のホスト名機能を使用することができます。 DNSリソース上の歪みに加えて、これはまた、ターゲットに送信されたINIT ACKの多数につながる可能性があります。このタイプの攻撃から保護するための一つの方法は、DNSから受信したIPアドレスは、元のINITの送信元IPアドレスを含めることを確認することです。 DNSから受信したIPアドレスのリストは、INITの送信元IPアドレスが含まれていない場合、エンドポイントは、静かにINITを捨てるかもしれ。この最後のオプションは、DNSへの攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 11.2.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Support for the Host Name Address parameter has been removed from the protocol. Endpoints receiving INIT or INIT ACK chunks containing the Host Name Address parameter MUST send an ABORT chunk in response and MAY include an \"Unresolvable Address\" error cause.",
      "ja": "ホスト名のAddressパラメータのサポートは、プロトコルから削除されました。ホスト名アドレスパラメータを含むINITまたはINIT ACKチャンクを受信エンドポイントは応答でABORTチャンクを送らなければなりませんし、「解決できないアドレス」のエラー原因を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.41.3. Solution Description",
      "section_title": true,
      "ja": "3.41.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The usage of the Host Name Address parameter has been deprecated.",
      "ja": "ホスト名のAddressパラメータの使用法は廃止されました。"
    },
    {
      "indent": 0,
      "text": "3.42. Conflicting Text regarding the 'Supported Address Types' Parameter",
      "ja": "3.42。 「サポートされているアドレス型」パラメータに関する矛盾するテキスト"
    },
    {
      "indent": 0,
      "text": "3.42.1. Description of the Problem",
      "section_title": true,
      "ja": "3.42.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 5.1.2 of [RFC4960] contains conflicting text regarding the receipt of an SCTP packet containing an INIT chunk sent from an address for which the corresponding address type is not listed in the 'Supported Address Types' parameter. The text states that the association MUST be aborted, but it also states that the association SHOULD be established and there SHOULD NOT be any error indication.",
      "ja": "[RFC4960]のセクション5.1.2には、対応するアドレスの種類が「サポートされているアドレス型」パラメータで指定されたされていないアドレスから送信されたINITチャンクを含むSCTPパケットの受信に関する矛盾するテキストが含まれています。テキストは、関連付けが中止されなければならないと述べているが、それはまたアソシエーションが確立されるべきであるし、任意のエラー表示があってはならないと述べています。"
    },
    {
      "indent": 0,
      "text": "3.42.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.42.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of INIT may include a 'Supported Address Types' parameter in the INIT to indicate what types of address are acceptable. When this parameter is present, the receiver of INIT (initiate) MUST either use one of the address types indicated in the Supported Address Types parameter when responding to the INIT, or abort the association with an \"Unresolvable Address\" error cause if it is unwilling or incapable of using any of the address types indicated by its peer.",
      "ja": "INITの送信者は、許容されるどのようなアドレスの種類を示すために、INITの「サポートされているアドレス型」パラメータを含むことができます。このパラメータが存在する場合、INIT（初期化）の受信機は、INITに応答するときにサポートされるアドレスタイプパラメータで示されるアドレスのタイプのいずれかを使用しなければならないか、それが不本意である場合、「解決不能アドレス」エラー原因との関連付けを中止しますまたはそのピアによって示されるアドレスのタイプのいずれかを使用することができません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender of INIT chunks MAY include a 'Supported Address Types' parameter in the INIT to indicate what types of addresses are acceptable.",
      "ja": "INITチャンクの送信者は、アドレスの種類が許容可能であるかを示すために、INITの「サポートされているアドレス型」パラメータを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.42.3. Solution Description",
      "section_title": true,
      "ja": "3.42.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The conflicting text has been removed.",
      "ja": "競合のテキストは削除されました。"
    },
    {
      "indent": 1,
      "text": "3.43. Integration of",
      "section_title": true,
      "ja": "3.43。の統合"
    },
    {
      "indent": 0,
      "text": "3.43.1. Description of the Problem",
      "section_title": true,
      "ja": "3.43.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC6096] updates [RFC4960] by adding the \"Chunk Flags\" registry. This should be integrated into the base specification.",
      "ja": "「チャンクフラグ」のレジストリを追加することにより、[RFC6096]の更新[RFC4960]。これは、基本仕様に統合されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.43.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.43.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 14.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14.1. IETF-Defined Chunk Extension",
      "section_title": true,
      "ja": "14.1。 IETF定義のチャンク拡張"
    },
    {
      "indent": 6,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action, as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されるように、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "a) A long and short name for the new chunk type.",
      "ja": "A）新しいチャンクタイプのために長いと短い名前。"
    },
    {
      "indent": 6,
      "text": "b) A detailed description of the structure of the chunk, which MUST conform to the basic structure defined in Section 3.2.",
      "ja": "B）セクション3.2で定義された基本構造に従わなければなりませんチャンクの構造の詳細な説明。"
    },
    {
      "indent": 6,
      "text": "c) A detailed definition and description of the intended use of each field within the chunk, including the chunk flags if any.",
      "ja": "C）もしあればチャンクフラグを含むチャンク内の各フィールドの用途の詳細な定義および説明。"
    },
    {
      "indent": 6,
      "text": "d) A detailed procedural description of the use of the new chunk type within the operation of the protocol.",
      "ja": "D）プロトコルの動作中に新しいチャンクタイプの使用の詳細な手続き説明。"
    },
    {
      "indent": 6,
      "text": "The last chunk type (255) is reserved for future extension if necessary.",
      "ja": "必要に応じて、最後のチャンクタイプ（255）は、将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14.1. IETF-Defined Chunk Extension",
      "section_title": true,
      "ja": "14.1。 IETF定義のチャンク拡張"
    },
    {
      "indent": 6,
      "text": "The assignment of new chunk type codes is done through an IETF Review action, as defined in [RFC8126]. Documentation for a new chunk MUST contain the following information:",
      "ja": "[RFC8126]で定義されるように、新しいチャンクタイプコードの割り当ては、IETFレビュー作用を介して行われます。新しいチャンクのためのマニュアルは、以下の情報を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "a) A long and short name for the new chunk type.",
      "ja": "A）新しいチャンクタイプのために長いと短い名前。"
    },
    {
      "indent": 6,
      "text": "b) A detailed description of the structure of the chunk, which MUST conform to the basic structure defined in Section 3.2.",
      "ja": "B）セクション3.2で定義された基本構造に従わなければなりませんチャンクの構造の詳細な説明。"
    },
    {
      "indent": 6,
      "text": "c) A detailed definition and description of the intended use of each field within the chunk, including the chunk flags (if any). Defined chunk flags will be used as initial entries in the chunk flags table for the new chunk type.",
      "ja": "C）チャンクフラグ（もしあれば）を含むチャンク内の各フィールドの用途の詳細な定義および説明。定義のチャンクフラグは、新しいチャンクタイプのチャンクフラグテーブルの最初のエントリとして使用されます。"
    },
    {
      "indent": 6,
      "text": "d) A detailed procedural description of the use of the new chunk type within the operation of the protocol.",
      "ja": "D）プロトコルの動作中に新しいチャンクタイプの使用の詳細な手続き説明。"
    },
    {
      "indent": 6,
      "text": "The last chunk type (255) is reserved for future extension if necessary.",
      "ja": "必要に応じて、最後のチャンクタイプ（255）は、将来の拡張のために予約されています。"
    },
    {
      "indent": 6,
      "text": "For each new chunk type, IANA creates a registration table for the chunk flags of that type. The procedure for registering particular chunk flags is described in Section 14.2.",
      "ja": "それぞれの新しいチャンクタイプのために、IANAは、そのタイプのチャンクフラグのための登録テーブルを作成します。特定のチャンクフラグを登録するための手順は、セクション14.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.3. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これはセクション3.3からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14.2. New IETF Chunk Flags Registration",
      "section_title": true,
      "ja": "14.2。新しいIETFチャンクフラグ登録"
    },
    {
      "indent": 6,
      "text": "The assignment of new chunk flags is done through an RFC Required action, as defined in [RFC8126]. Documentation for the chunk flags MUST contain the following information:",
      "ja": "[RFC8126]で定義されるように、新しいチャンクフラグの割り当ては、RFC必要な作用を介して行われます。チャンクフラグのドキュメントは、以下の情報を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "a) A name for the new chunk flag.",
      "ja": "A）新しいチャンクフラグの名前を入力します。"
    },
    {
      "indent": 6,
      "text": "b) A detailed procedural description of the use of the new chunk flag within the operation of the protocol. It MUST be considered that implementations not supporting the flag will send '0' on transmit and just ignore it on receipt.",
      "ja": "B）プロトコルの動作中に新しいチャンクフラグの使用の詳細な手続き説明。フラグをサポートしない実装は、送信に「0」を送信し、ちょうどレシート上でそれを無視することを考えなければなりません。"
    },
    {
      "indent": 6,
      "text": "IANA selects a chunk flags value. This MUST be one of 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, or 0x80, which MUST be unique within the chunk flag values for the specific chunk type.",
      "ja": "IANAは、チャンクフラグ値を選択します。これは、特定のチャンクタイプのチャンクフラグ値内で一意でなければならないが0x01のいずれか、0x02の、0x04を、0x08に、0x10を、0x20に、0x40の、または0x80のでなければなりません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "Please note that Sections 14.2, 14.3, 14.4, and 14.5 as shown in [RFC4960] will need to be renumbered when [RFC4960] is updated.",
      "ja": "[RFC4960]が更新されたときに、[RFC4960]に示すように、セクション14.2、14.3、14.4、14.5を再番号付けする必要がありますのでご注意ください。"
    },
    {
      "indent": 0,
      "text": "3.43.3. Solution Description",
      "section_title": true,
      "ja": "3.43.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "[RFC6096] has been integrated, and the reference has been updated to [RFC8126].",
      "ja": "[RFC6096]は統合されており、参考文献[RFC8126]にアップデートされています。"
    },
    {
      "indent": 1,
      "text": "3.44. Integration of",
      "section_title": true,
      "ja": "3.44。の統合"
    },
    {
      "indent": 0,
      "text": "3.44.1. Description of the Problem",
      "section_title": true,
      "ja": "3.44.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC6335] updates [RFC4960] by updating procedures for the \"Service Name and Transport Protocol Port Number Registry\". This should be integrated into the base specification. Also, the \"Guidelines for Writing an IANA Considerations Section in RFCs\" reference needs to be changed to [RFC8126].",
      "ja": "「サービス名とトランスポートプロトコルポート番号登録」の手続きを更新することによって、[RFC6335]の更新[RFC4960]。これは、基本仕様に統合されるべきです。また、「RFCでIANA問題部に書くためのガイドライン」は、参照は、[RFC8126]に変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.44.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.44.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 14.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SCTP services may use contact port numbers to provide service to unknown callers, as in TCP and UDP. IANA is therefore requested to open the existing Port Numbers registry for SCTP using the following rules, which we intend to mesh well with existing Port Numbers registration procedures. An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port allocation requests, according to the procedure defined in [RFC2434].",
      "ja": "SCTPサービスは、TCPやUDPのように、未知の発信者にサービスを提供するために、連絡先のポート番号を使用することができます。 IANAは、したがって、我々は既存のポート番号の登録手順とよくメッシュしようとする次のルールを使用して、SCTPのための既存のポート番号のレジストリを開くように要求されています。 IESG-任命エキスパートレビュー[RFC2434]で定義された手順に従って、SCTPポート割り当て要求を評価する際にIANAをサポートしています。"
    },
    {
      "indent": 3,
      "text": "Port numbers are divided into three ranges. The Well Known Ports are those from 0 through 1023, the Registered Ports are those from 1024 through 49151, and the Dynamic and/or Private Ports are those from 49152 through 65535. Well Known and Registered Ports are intended for use by server applications that desire a default contact point on a system. On most systems, Well Known Ports can only be used by system (or root) processes or by programs executed by privileged users, while Registered Ports can be used by ordinary user processes or programs executed by ordinary users. Dynamic and/or Private Ports are intended for temporary use, including client-side ports, out-of-band negotiated ports, and application testing prior to registration of a dedicated port; they MUST NOT be registered.",
      "ja": "ポート番号は、3つの範囲に分割されています。ウェルノウンポートが1023の0からのものであり、登録されたポートは、1024から49151によるものであり、かつ動的および/またはプライベートポート、よく知られており、登録されたポートは、サーバーアプリケーションでの使用を目的としている〜65535 49152からのものであり、望むことシステムのデフォルトの接触点。登録ポートは、通常のユーザープロセスか、通常のユーザーによって実行されるプログラムで使用することができながら、ほとんどのシステムでは、ウェルノウンポートのみが、システム（またはルート）プロセスによって、または特権ユーザーによって実行されるプログラムで使用することができます。動的および/またはプライベートポートは一時的な使用のために意図されている、専用ポートの登録に先立って、クライアント側のポート、アウトバンド交渉し、ポート、およびアプリケーションのテストを含みます。彼らは、登録してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Port Numbers registry should accept registrations for SCTP ports in the Well Known Ports and Registered Ports ranges. Well Known and Registered Ports SHOULD NOT be used without registration. Although in some cases -- such as porting an application from TCP to SCTP -- it may seem natural to use an SCTP port before registration completes, we emphasize that IANA will not guarantee registration of particular Well Known and Registered Ports. Registrations should be requested as early as possible.",
      "ja": "ポート番号のレジストリは、ウェルノウンポートと登録済みポートの範囲のSCTPポートの登録を受け入れる必要があります。よく知られており、登録されたポートは、登録なしで使用されるべきではありません。このようTCPからSCTPにアプリケーションを移植など -   - いくつかのケースではあるが、それは登録が完了する前に、SCTPポートを使用するように自然に見えるかもしれませんが、私たちは、IANAが特定のよく知られており、登録されたポートの登録を保証するものではありませんことを強調する。登録は可能な限り早期に要求されるべき。"
    },
    {
      "indent": 3,
      "text": "Each port registration SHALL include the following information:",
      "ja": "各ポートの登録は、以下の情報を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o  A short port name, consisting entirely of letters (A-Z and a-z),\n   digits (0-9), and punctuation characters from \"-_+./*\" (not\n   including the quotes).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The port number that is requested for registration.",
      "ja": "登録のために要求されているポート番号O。"
    },
    {
      "indent": 3,
      "text": "o A short English phrase describing the port's purpose.",
      "ja": "ポートの目的を説明する短い英語フレーズO。"
    },
    {
      "indent": 3,
      "text": "o Name and contact information for the person or entity performing the registration, and possibly a reference to a document defining the port's use. Registrations coming from IETF working groups need only name the working group, but indicating a contact person is recommended.",
      "ja": "Oの名前と、おそらく個人または団体登録を実行し、ポートの使用を定義するドキュメントへの参照のための連絡先情報。 IETFワーキンググループからの登録は、ワーキンググループに名前を付ける必要はなく、担当者を示すことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Registrants are encouraged to follow these guidelines when submitting a registration.",
      "ja": "登録者は、登録を提出する際のガイドラインに従うことを奨励されています。"
    },
    {
      "indent": 3,
      "text": "o A port name SHOULD NOT be registered for more than one SCTP port number.",
      "ja": "Oポート名は、複数のSCTPポート番号に登録されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o A port name registered for TCP MAY be registered for SCTP as well. Any such registration SHOULD use the same port number as the existing TCP registration.",
      "ja": "O TCPのために登録されているポート名は、同様にSCTPのために登録することも可能です。任意のそのような登録は、既存のTCP登録と同じポート番号を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Concrete intent to use a port SHOULD precede port registration. For example, existing TCP ports SHOULD NOT be registered in advance of any intent to use those ports for SCTP.",
      "ja": "Oポートを使用するための具体的な目的は、ポートの登録を先行すべき。例えば、既存のTCPポートは、SCTPのためにこれらのポートを使用するように任意の意思を事前に登録されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14.5)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SCTP services can use contact port numbers to provide service to unknown callers, as in TCP and UDP. IANA is therefore requested to open the existing \"Service Name and Transport Protocol Port Number Registry\" for SCTP using the following rules, which we intend to mesh well with existing port-number registration procedures. An IESG-appointed expert reviewer supports IANA in evaluating SCTP port allocation requests, according to the procedure defined in [RFC8126]. The details of this process are defined in [RFC6335].",
      "ja": "SCTPサービスは、TCPやUDPのように、未知の発信者にサービスを提供するために、連絡先のポート番号を使用することができます。 IANAは、したがって、我々は既存のポート番号の登録手続きとよくメッシュしようとする次のルールを使用して、SCTPのために既存の「サービス名とトランスポートプロトコルポート番号レジストリ」を開くことが要求されています。 IESGが任命し、専門家のレビューは、[RFC8126]で定義された手順に従って、SCTPポート割り当て要求を評価する際にIANAをサポートしています。この処理の詳細は[RFC6335]で定義されています。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.44.3. Solution Description",
      "section_title": true,
      "ja": "3.44.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "[RFC6335] has been integrated, and the reference has been updated to [RFC8126].",
      "ja": "[RFC6335]は統合されており、参考文献[RFC8126]にアップデートされています。"
    },
    {
      "indent": 1,
      "text": "3.45. Integration of",
      "section_title": true,
      "ja": "3.45。の統合"
    },
    {
      "indent": 0,
      "text": "3.45.1. Description of the Problem",
      "section_title": true,
      "ja": "3.45.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "[RFC7053] updates [RFC4960] by adding the I bit to the DATA chunk. This should be integrated into the base specification.",
      "ja": "DATAチャンクにIビットを追加することにより、[RFC7053]アップデート[RFC4960]。これは、基本仕様に統合されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.45.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.45.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following format MUST be used for the DATA chunk:",
      "ja": "次の形式は、DATAチャンクを使用しなければなりません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 0    | Reserved|U|B|E|    Length                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Stream Identifier S      |   Stream Sequence Number n    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Payload Protocol Identifier                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                 User Data (seq n of Stream S)                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reserved: 5 bits",
      "ja": "予約：5ビット"
    },
    {
      "indent": 6,
      "text": "Should be set to all '0's and ignored by the receiver.",
      "ja": "すべての「0に設定され、受信機によって無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following format MUST be used for the DATA chunk:",
      "ja": "次の形式は、DATAチャンクを使用しなければなりません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 0    |  Res  |I|U|B|E|    Length                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Stream Identifier S      |   Stream Sequence Number n    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Payload Protocol Identifier                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                 User Data (seq n of Stream S)                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Res: 4 bits",
      "ja": "RES：4ビット"
    },
    {
      "indent": 6,
      "text": "SHOULD be set to all '0's and ignored by the receiver.",
      "ja": "すべての「0に設定され、受信機によって無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "I bit: 1 bit",
      "ja": "私はビット：1ビットを"
    },
    {
      "indent": 6,
      "text": "The (I)mmediate bit MAY be set by the sender whenever the sender of a DATA chunk can benefit from the corresponding SACK chunk being sent back without delay. See Section 4 of [RFC7053] for a discussion of the benefits.",
      "ja": "（I）mmediateビットはDATAチャンクの送信者が遅滞なく返送され、対応するSACKチャンクから利益を得ることができるたびに、送信者によって設定されてもよいです。利点の議論については、[RFC7053]のセクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Append to Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Whenever the sender of a DATA chunk can benefit from the corresponding SACK chunk being sent back without delay, the sender MAY set the I bit in the DATA chunk header. Please note that why the sender has set the I bit is irrelevant to the receiver.",
      "ja": "DATAチャンクの送信者がバック遅延なく送信される対応するSACKチャンクから利益を得ることができるたびに、送信者はデータチャンクヘッダ内のIビットを設定することができます。送信者が設定した理由Iビットが受信機には無関係であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Reasons for setting the I bit include, but are not limited to, the following (see Section 4 of [RFC7053] for a discussion of the benefits):",
      "ja": "Iビットを設定するための理由は、（ベネフィットの議論については、[RFC7053]のセクション4を参照）、これらに限定されないが、以下："
    },
    {
      "indent": 3,
      "text": "o The application requests that the I bit of the last DATA chunk of a user message be set when providing the user message to the SCTP implementation (see Section 7).",
      "ja": "SCTP実装にユーザー・メッセージを提供する際に、ユーザメッセージの最後のデータチャンクのIビットが設定されるアプリケーション要求O（セクション7参照）。"
    },
    {
      "indent": 3,
      "text": "o The sender is in the SHUTDOWN-PENDING state.",
      "ja": "O送信者はSHUTDOWN-PENDING状態になっています。"
    },
    {
      "indent": 3,
      "text": "o The sending of a DATA chunk fills the congestion or receiver window.",
      "ja": "DATAチャンクの送信oを輻輳又は受信ウィンドウを満たします。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the endpoint should use a SACK instead of the SHUTDOWN chunk to acknowledge DATA chunks received out of order.",
      "ja": "注意：SHUTDOWNチャンクはギャップAckブロックフィールドが含まれていません。そのため、エンドポイントは、順不同で受信したデータチャンクを確認するためにSACKの代わりに、SHUTDOWNチャンクを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the endpoint SHOULD use a SACK instead of the SHUTDOWN chunk to acknowledge DATA chunks received out of order.",
      "ja": "注意：SHUTDOWNチャンクはギャップAckブロックフィールドが含まれていません。したがって、エンドポイントは、順不同で受信したデータチャンクを確認するためにSHUTDOWNチャンクの代わりにSACKを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an SCTP packet containing a DATA chunk with the I bit set, the receiver SHOULD NOT delay the sending of the corresponding SACK chunk, i.e., the receiver SHOULD immediately respond with the corresponding SACK chunk.",
      "ja": "Iビットセットを有するデータチャンクを含むSCTPパケットを受信すると、受信機は、対応するSACKチャンクの送信を遅らせるべきではない、すなわち、受信機は直ちに対応SACKチャンクで応答すべきです。"
    },
    {
      "indent": 3,
      "text": "Please note that this change is only about adding a paragraph.",
      "ja": "この変更は、段落を追加する方法についてのみであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1 E))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "E) Send",
      "ja": "E）を送信"
    },
    {
      "indent": 4,
      "text": "Format: SEND(association id, buffer address, byte count [,context] [,stream id] [,life time] [,destination transport address] [,unordered flag] [,no-bundle flag] [,payload protocol-id] ) -> result",
      "ja": "フォーマット：（アソシエーションID、バッファアドレス、バイトカウント[コンテキスト] [、ストリームID] [ライフタイム] [、送信先トランスポートアドレス] [、順不同フラグ] [無バンドルフラグ] [、ペイロードプロトコル-IDを送信します]） - >結果"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1 E))\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "E) Send",
      "ja": "E）を送信"
    },
    {
      "indent": 4,
      "text": "Format: SEND(association id, buffer address, byte count [,context] [,stream id] [,life time] [,destination transport address] [,unordered flag] [,no-bundle flag] [,payload protocol-id] [,sack-immediately]) -> result",
      "ja": "フォーマット：（アソシエーションID、バッファアドレス、バイトカウント[コンテキスト] [、ストリームID] [ライフタイム] [、送信先トランスポートアドレス] [、順不同フラグ] [無バンドルフラグ] [、ペイロードプロトコル-IDを送信します] [、袋直ちに]） - >結果"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Append optional parameter in item E) of Section 10.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o sack-immediately flag - set the I bit on the last DATA chunk used for the user message to be transmitted.",
      "ja": "O袋直ちにフラグ - 送信すべきユーザ・メッセージに使用される最後のデータチャンクのIビットを設定します。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.45.3. Solution Description",
      "section_title": true,
      "ja": "3.45.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "[RFC7053] has been integrated.",
      "ja": "[RFC7053]は統合されています。"
    },
    {
      "indent": 0,
      "text": "3.46. CRC32c Code Improvements",
      "section_title": true,
      "ja": "3.46。 CRC32Cコードの改善"
    },
    {
      "indent": 0,
      "text": "3.46.1. Description of the Problem",
      "section_title": true,
      "ja": "3.46.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The code given for the CRC32c computations uses types such as \"long\", which may have different lengths on different operating systems or processors. Therefore, the code needs to be changed, so that it uses specific types such as uint32_t.",
      "ja": "CRC32C計算のために与えられたコードは、異なるオペレーティング・システムまたはプロセッサ上の異なる長さを有していてもよく、そのような「長い」などの種類を使用します。そのようなのuint32_tなどの特定のタイプを使用するように、したがって、コードが、変更される必要があります。"
    },
    {
      "indent": 3,
      "text": "Some syntax errors and a comment also need to be fixed.",
      "ja": "いくつかの構文エラーやコメントも固定する必要があります。"
    },
    {
      "indent": 3,
      "text": "We remind the reader that per Section 3.10.2 of this document most of Appendix C of RFC 4960 will be moved to Appendix B in the bis document (thus the \"Old text: (Appendix C)\" and \"New text: (Appendix B)\" items in this section).",
      "ja": "私たちは、このドキュメントのセクション3.10.2あたりのRFC 4960の付録Cのほとんどが（ビスドキュメントの付録Bに移動されることを読者に思い出させるため「オールド・テキスト：（付録C）」と「新テキスト：（付録Bこのセクションの）」の項目）。"
    },
    {
      "indent": 0,
      "text": "3.46.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.46.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*************************************************************/\n/* Note Definition for Ross Williams table generator would   */\n/* be: TB_WIDTH=4, TB_POLLY=0x1EDC6F41, TB_REVER=TRUE        */\n/* For Mr. Williams direct calculation code use the settings */\n/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,      */\n/* cm_refin=TRUE, cm_refot=TRUE, cm_xorort=0x00000000        */\n/*************************************************************/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of the crc table file */\n#ifndef __crc32cr_table_h__\n#define __crc32cr_table_h__",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define CRC32C_POLY 0x1EDC6F41 #define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])",
      "ja": "#define CRC32C_POLY 0x1EDC6F41に#define CRC32C（C、D）（C =（C >> 8）^ crc_c [（C ^（D））＆0xFFで]）"
    },
    {
      "indent": 3,
      "text": "unsigned long crc_c[256] = { 0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL, 0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL, 0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,",
      "ja": "unsigned long型crc_c [256] = {0x00000000L、0xF26B8303L、0xE13B70F7L、0x1350F3F4L、0xC79A971FL、0x35F1141CL、0x26A1E7E8L、0xD4CA64EBL、0x8AD958CFL、0x78B2DBCCL、0x6BE22838L、0x9989AB3BL、0x4D43CFD0L、0xBF284CD3L、0xAC78BF27L、0x5E133C24L、0x105EC76FL、0xE235446CL、0xF165B798L、0x030E349BL、0xD7C45070L、 0x25AFD373L、0x36FF2087L、0xC494A384L、0x9A879FA0L、0x68EC1CA3L、0x7BBCEF57L、0x89D76C54L、0x5D1D08BFL、0xAF768BBCL、0xBC267848L、0x4E4DFB4BL、0x20BD8EDEL、0xD2D60DDDL、0xC186FE29L、0x33ED7D2AL、0xE72719C1L、0x154C9AC2L、0x061C6936L、0xF477EA35L、0xAA64D611L、0x580F5512L、0x4B5FA6E6L、0xB93425E5L、0x6DFE410EL、0x9F95C20DL、 0x8CC531F9L、0x7EAEB2FAL、0x30E349B1L、0xC288CAB2L、0xD1D83946L、0x23B3BA45L、"
    },
    {
      "indent": 3,
      "text": "0xF779DEAEL, 0x05125DADL, 0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L, 0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L,",
      "ja": "0xF779DEAEL、0x05125DADL、0x1642AE59L、0xE4292D5AL、0xBA3A117EL、0x4851927DL、0x5B016189L、0xA96AE28AL、0x7DA08661L、0x8FCB0562L、0x9C9BF696L、0x6EF07595L、0x417B1DBCL、0xB3109EBFL、0xA0406D4BL、0x522BEE48L、0x86E18AA3L、0x748A09A0L、0x67DAFA54L、0x95B17957L、0xCBA24573L、0x39C9C670L、0x2A993584L、0xD8F2B687L、0x0C38D26CL、 0xFE53516FL、0xED03A29BL、0x1F682198L、0x5125DAD3L、0xA34E59D0L、0xB01EAA24L、0x42752927L、0x96BF4DCCL、0x64D4CECFL、0x77843D3BL、0x85EFBE38L、0xDBFC821CL、0x2997011FL、0x3AC7F2EBL、0xC8AC71E8L、0x1C661503L、0xEE0D9600L、0xFD5D65F4L、0x0F36E6F7L、"
    },
    {
      "indent": 3,
      "text": "0x61C69362L, 0x93AD1061L, 0x80FDE395L, 0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L, 0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L, 0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL, 0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL, 0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L, 0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL, 0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L, 0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L, 0xE03E9C81L,",
      "ja": "0x61C69362L、0x93AD1061L、0x80FDE395L、0x72966096L、0xA65C047DL、0x5437877EL、0x4767748AL、0xB50CF789L、0xEB1FCBADL、0x197448AEL、0x0A24BB5AL、0xF84F3859L、0x2C855CB2L、0xDEEEDFB1L、0xCDBE2C45L、0x3FD5AF46L、0x7198540DL、0x83F3D70EL、0x90A324FAL、0x62C8A7F9L、0xB602C312L、0x44694011L、0x5739B3E5L、0xA55230E6L、0xFB410CC2L、 0x092A8FC1L、0x1A7A7C35L、0xE811FF36L、0x3CDB9BDDL、0xCEB018DEL、0xDDE0EB2AL、0x2F8B6829L、0x82F63B78L、0x709DB87BL、0x63CD4B8FL、0x91A6C88CL、0x456CAC67L、0xB7072F64L、0xA457DC90L、0x563C5F93L、0x082F63B7L、0xFA44E0B4L、0xE9141340L、0x1B7F9043L、0xCFB5F4A8L、0x3DDE77ABL、0x2E8E845FL、0xDCE5075CL、0x92A8FC17L、0x60C37F14L、 0x73938CE0L、0x81F80FE3L、0x55326B08L、0xA759E80BL、0xB4091BFFL、0x466298FCL、0x1871A4D8L、0xEA1A27DBL、0xF94AD42FL、0x0B21572CL、0xDFEB33C7L、0x2D80B0C4L、0x3ED04330L、0xCCBBC033L、0xA24BB5A6L、0x502036A5L、0x4370C551L、0xB11B4652L、0x65D122B9L、0x97BAA1BAL、0x84EA524EL、0x7681D14DL、0x2892ED69L、0xDAF96E6AL、0xC9A99D9EL、 0x3BC21E9DL、0xEF087A76L、 0x1D63F975L、0x0E330A81L、0xFC588982L、0xB21572C9L、0x407EF1CAL、0x532E023EL、0xA145813DL、0x758FE5D6L、0x87E466D5L、0x94B49521L、0x66DF1622L、0x38CC2A06L、0xCAA7A905L、0xD9F75AF1L、0x2B9CD9F2L、0xFF56BD19L、0x0D3D3E1AL、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、 0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、 0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、"
    },
    {
      "indent": 3,
      "text": "0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL, 0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L, };",
      "ja": "0x34F4F86AL、0xC69F7B69L、0xD5CF889DL、0x27A40B9EL、0x79B737BAL、0x8BDCB4B9L、0x988C474DL、0x6AE7C44EL、0xBE2DA0A5L、0x4C4623A6L、0x5F16D052L、0xAD7D5351L、}。"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix B)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n/****************************************************************/\n/* Note: The definitions for Ross Williams's table generator    */\n/* would be TB_WIDTH=4, TB_POLY=0x1EDC6F41, TB_REVER=TRUE.      */\n/* For Mr. Williams's direct calculation code, use the settings */\n/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,         */\n/* cm_refin=TRUE, cm_refot=TRUE, cm_xorot=0x00000000.           */\n/****************************************************************/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of the crc table file */\n#ifndef __crc32cr_h__\n#define __crc32cr_h__",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define CRC32C_POLY 0x1EDC6F41UL #define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])",
      "ja": "#define CRC32C_POLY 0x1EDC6F41ULに#define CRC32C（C、D）（C =（C >> 8）^ crc_c [（C ^（D））＆0xFFで]）"
    },
    {
      "indent": 3,
      "text": "uint32_t crc_c[256] = { 0x00000000UL, 0xF26B8303UL, 0xE13B70F7UL, 0x1350F3F4UL, 0xC79A971FUL, 0x35F1141CUL, 0x26A1E7E8UL, 0xD4CA64EBUL, 0x8AD958CFUL, 0x78B2DBCCUL, 0x6BE22838UL, 0x9989AB3BUL, 0x4D43CFD0UL, 0xBF284CD3UL, 0xAC78BF27UL, 0x5E133C24UL, 0x105EC76FUL, 0xE235446CUL, 0xF165B798UL, 0x030E349BUL, 0xD7C45070UL, 0x25AFD373UL, 0x36FF2087UL, 0xC494A384UL, 0x9A879FA0UL, 0x68EC1CA3UL, 0x7BBCEF57UL, 0x89D76C54UL, 0x5D1D08BFUL, 0xAF768BBCUL, 0xBC267848UL, 0x4E4DFB4BUL, 0x20BD8EDEUL, 0xD2D60DDDUL, 0xC186FE29UL, 0x33ED7D2AUL, 0xE72719C1UL, 0x154C9AC2UL, 0x061C6936UL, 0xF477EA35UL, 0xAA64D611UL, 0x580F5512UL, 0x4B5FA6E6UL, 0xB93425E5UL, 0x6DFE410EUL, 0x9F95C20DUL, 0x8CC531F9UL, 0x7EAEB2FAUL, 0x30E349B1UL, 0xC288CAB2UL, 0xD1D83946UL, 0x23B3BA45UL, 0xF779DEAEUL, 0x05125DADUL, 0x1642AE59UL, 0xE4292D5AUL, 0xBA3A117EUL, 0x4851927DUL, 0x5B016189UL, 0xA96AE28AUL, 0x7DA08661UL, 0x8FCB0562UL, 0x9C9BF696UL, 0x6EF07595UL, 0x417B1DBCUL, 0xB3109EBFUL, 0xA0406D4BUL, 0x522BEE48UL, 0x86E18AA3UL, 0x748A09A0UL, 0x67DAFA54UL, 0x95B17957UL, 0xCBA24573UL, 0x39C9C670UL, 0x2A993584UL, 0xD8F2B687UL, 0x0C38D26CUL, 0xFE53516FUL, 0xED03A29BUL, 0x1F682198UL, 0x5125DAD3UL, 0xA34E59D0UL, 0xB01EAA24UL, 0x42752927UL, 0x96BF4DCCUL, 0x64D4CECFUL, 0x77843D3BUL, 0x85EFBE38UL, 0xDBFC821CUL, 0x2997011FUL, 0x3AC7F2EBUL, 0xC8AC71E8UL, 0x1C661503UL, 0xEE0D9600UL, 0xFD5D65F4UL, 0x0F36E6F7UL, 0x61C69362UL, 0x93AD1061UL, 0x80FDE395UL, 0x72966096UL, 0xA65C047DUL, 0x5437877EUL, 0x4767748AUL, 0xB50CF789UL,",
      "ja": "uint32_t crc_c [256] = {0x00000000UL、0xF26B8303UL、0xE13B70F7UL、0x1350F3F4UL、0xC79A971FUL、0x35F1141CUL、0x26A1E7E8UL、0xD4CA64EBUL、0x8AD958CFUL、0x78B2DBCCUL、0x6BE22838UL、0x9989AB3BUL、0x4D43CFD0UL、0xBF284CD3UL、0xAC78BF27UL、0x5E133C24UL、0x105EC76FUL、0xE235446CUL、0xF165B798UL、0x030E349BUL、0xD7C45070UL、0x25AFD373UL 、0x36FF2087UL、0xC494A384UL、0x9A879FA0UL、0x68EC1CA3UL、0x7BBCEF57UL、0x89D76C54UL、0x5D1D08BFUL、0xAF768BBCUL、0xBC267848UL、0x4E4DFB4BUL、0x20BD8EDEUL、0xD2D60DDDUL、0xC186FE29UL、0x33ED7D2AUL、0xE72719C1UL、0x154C9AC2UL、0x061C6936UL、0xF477EA35UL、0xAA64D611UL、0x580F5512UL、0x4B5FA6E6UL、0xB93425E5UL、0x6DFE410EUL、0x9F95C20DUL、0x8CC531F9UL 、0x7EAEB2FAUL、0x30E349B1UL、0xC288CAB2UL、0xD1D83946UL、0x23B3BA45UL、0xF779DEAEUL、0x05125DADUL、0x1642AE59UL、0xE4292D5AUL、0xBA3A117EUL、0x4851927DUL、0x5B016189UL、0xA96AE28AUL、0x7DA08661UL、0x8FCB0562UL、0x9C9BF696UL、0x6EF07595UL、0x417B1DBCUL、0xB3109EBFUL、0xA0406D4BUL、0x522BEE48UL、0x86E18AA3UL、0x748A09A0 UL、0x67DAFA54UL、0x95B17957UL、0xCBA24573UL、0x39C9C670UL、0x2A993584UL、0xD8F2B687UL、0x0C38D26CUL、0xFE53516FUL、0xED03A29BUL、0x1F682198UL、0x5125DAD3UL、0xA34E59D0UL、0xB01EAA24UL、0x42752927UL、0x96BF4DCCUL、0x64D4CECFUL、0x77843D3BUL、0x85EFBE38UL、0xDBFC821CUL、0x2997011FUL、0x3AC7F2EBUL、0xC8AC71E8UL、0x1C661503UL、0xEE0D9600UL、 0xFD5D65F4UL、0x0F36E6F7UL、0x61C69362UL、0x93AD1061UL、0x80FDE395UL、0x72966096UL、0xA65C047DUL、0x5437877EUL、0x4767748AUL、0xB50CF789UL、"
    },
    {
      "indent": 3,
      "text": "0xEB1FCBADUL, 0x197448AEUL, 0x0A24BB5AUL, 0xF84F3859UL, 0x2C855CB2UL, 0xDEEEDFB1UL, 0xCDBE2C45UL, 0x3FD5AF46UL, 0x7198540DUL, 0x83F3D70EUL, 0x90A324FAUL, 0x62C8A7F9UL, 0xB602C312UL, 0x44694011UL, 0x5739B3E5UL, 0xA55230E6UL, 0xFB410CC2UL, 0x092A8FC1UL, 0x1A7A7C35UL, 0xE811FF36UL, 0x3CDB9BDDUL, 0xCEB018DEUL, 0xDDE0EB2AUL, 0x2F8B6829UL, 0x82F63B78UL, 0x709DB87BUL, 0x63CD4B8FUL, 0x91A6C88CUL, 0x456CAC67UL, 0xB7072F64UL, 0xA457DC90UL, 0x563C5F93UL, 0x082F63B7UL, 0xFA44E0B4UL, 0xE9141340UL, 0x1B7F9043UL, 0xCFB5F4A8UL, 0x3DDE77ABUL, 0x2E8E845FUL, 0xDCE5075CUL, 0x92A8FC17UL, 0x60C37F14UL, 0x73938CE0UL, 0x81F80FE3UL, 0x55326B08UL, 0xA759E80BUL, 0xB4091BFFUL, 0x466298FCUL, 0x1871A4D8UL, 0xEA1A27DBUL, 0xF94AD42FUL, 0x0B21572CUL, 0xDFEB33C7UL, 0x2D80B0C4UL, 0x3ED04330UL, 0xCCBBC033UL, 0xA24BB5A6UL, 0x502036A5UL, 0x4370C551UL, 0xB11B4652UL, 0x65D122B9UL, 0x97BAA1BAUL, 0x84EA524EUL, 0x7681D14DUL, 0x2892ED69UL, 0xDAF96E6AUL, 0xC9A99D9EUL, 0x3BC21E9DUL, 0xEF087A76UL, 0x1D63F975UL, 0x0E330A81UL, 0xFC588982UL, 0xB21572C9UL, 0x407EF1CAUL, 0x532E023EUL, 0xA145813DUL, 0x758FE5D6UL, 0x87E466D5UL, 0x94B49521UL, 0x66DF1622UL, 0x38CC2A06UL, 0xCAA7A905UL, 0xD9F75AF1UL, 0x2B9CD9F2UL, 0xFF56BD19UL, 0x0D3D3E1AUL, 0x1E6DCDEEUL, 0xEC064EEDUL, 0xC38D26C4UL, 0x31E6A5C7UL, 0x22B65633UL, 0xD0DDD530UL, 0x0417B1DBUL, 0xF67C32D8UL, 0xE52CC12CUL, 0x1747422FUL, 0x49547E0BUL, 0xBB3FFD08UL, 0xA86F0EFCUL, 0x5A048DFFUL, 0x8ECEE914UL, 0x7CA56A17UL, 0x6FF599E3UL, 0x9D9E1AE0UL, 0xD3D3E1ABUL, 0x21B862A8UL, 0x32E8915CUL, 0xC083125FUL, 0x144976B4UL, 0xE622F5B7UL, 0xF5720643UL, 0x07198540UL, 0x590AB964UL, 0xAB613A67UL, 0xB831C993UL, 0x4A5A4A90UL, 0x9E902E7BUL, 0x6CFBAD78UL, 0x7FAB5E8CUL, 0x8DC0DD8FUL, 0xE330A81AUL, 0x115B2B19UL, 0x020BD8EDUL, 0xF0605BEEUL, 0x24AA3F05UL, 0xD6C1BC06UL, 0xC5914FF2UL, 0x37FACCF1UL, 0x69E9F0D5UL, 0x9B8273D6UL, 0x88D28022UL, 0x7AB90321UL, 0xAE7367CAUL, 0x5C18E4C9UL, 0x4F48173DUL, 0xBD23943EUL, 0xF36E6F75UL, 0x0105EC76UL, 0x12551F82UL, 0xE03E9C81UL, 0x34F4F86AUL, 0xC69F7B69UL, 0xD5CF889DUL, 0x27A40B9EUL, 0x79B737BAUL, 0x8BDCB4B9UL, 0x988C474DUL, 0x6AE7C44EUL, 0xBE2DA0A5UL, 0x4C4623A6UL, 0x5F16D052UL, 0xAD7D5351UL, };",
      "ja": "0xEB1FCBADUL、0x197448AEUL、0x0A24BB5AUL、0xF84F3859UL、0x2C855CB2UL、0xDEEEDFB1UL、0xCDBE2C45UL、0x3FD5AF46UL、0x7198540DUL、0x83F3D70EUL、0x90A324FAUL、0x62C8A7F9UL、0xB602C312UL、0x44694011UL、0x5739B3E5UL、0xA55230E6UL、0xFB410CC2UL、0x092A8FC1UL、0x1A7A7C35UL、0xE811FF36UL、0x3CDB9BDDUL、0xCEB018DEUL、0xDDE0EB2AUL、0x2F8B6829UL、0x82F63B78UL、 0x709DB87BUL、0x63CD4B8FUL、0x91A6C88CUL、0x456CAC67UL、0xB7072F64UL、0xA457DC90UL、0x563C5F93UL、0x082F63B7UL、0xFA44E0B4UL、0xE9141340UL、0x1B7F9043UL、0xCFB5F4A8UL、0x3DDE77ABUL、0x2E8E845FUL、0xDCE5075CUL、0x92A8FC17UL、0x60C37F14UL、0x73938CE0UL、0x81F80FE3UL、0x55326B08UL、0xA759E80BUL、0xB4091BFFUL、0x466298FCUL、0x1871A4D8UL、0xEA1A27DBUL、 0xF94AD42FUL、0x0B21572CUL、0xDFEB33C7UL、0x2D80B0C4UL、0x3ED04330UL、0xCCBBC033UL、0xA24BB5A6UL、0x502036A5UL、0x4370C551UL、0xB11B4652UL、0x65D122B9UL、0x97BAA1BAUL、0x84EA524EUL、0x7681D14DUL、0x2892ED69UL、0xDAF96E6AUL、0xC9A99D9EUL、0x3BC21E9DUL、0xEF087A76UL、0x1D63F975UL、0x0E330A81UL、0xFC58 8982UL、0xB21572C9UL、0x407EF1CAUL、0x532E023EUL、0xA145813DUL、0x758FE5D6UL、0x87E466D5UL、0x94B49521UL、0x66DF1622UL、0x38CC2A06UL、0xCAA7A905UL、0xD9F75AF1UL、0x2B9CD9F2UL、0xFF56BD19UL、0x0D3D3E1AUL、0x1E6DCDEEUL、0xEC064EEDUL、0xC38D26C4UL、0x31E6A5C7UL、0x22B65633UL、0xD0DDD530UL、0x0417B1DBUL、0xF67C32D8UL、0xE52CC12CUL、0x1747422FUL、 0x49547E0BUL、0xBB3FFD08UL、0xA86F0EFCUL、0x5A04​​8DFFUL、0x8ECEE914UL、0x7CA56A17UL、0x6FF599E3UL、0x9D9E1AE0UL、0xD3D3E1ABUL、0x21B862A8UL、0x32E8915CUL、0xC083125FUL、0x144976B4UL、0xE622F5B7UL、0xF5720643UL、0x07198540UL、0x590AB964UL、0xAB613A67UL、0xB831C993UL、0x4A5A4A90UL、0x9E902E7BUL、0x6CFBAD78UL、0x7FAB5E8CUL、0x8DC0DD8FUL、0xE330A81AUL、 0x115B2B19UL、0x020BD8EDUL、0xF0605BEEUL、0x24AA3F05UL、0xD6C1BC06UL、0xC5914FF2UL、0x37FACCF1UL、0x69E9F0D5UL、0x9B8273D6UL、0x88D28022UL、0x7AB90321UL、0xAE7367CAUL、0x5C18E4C9UL、0x4F48173DUL、0xBD23943EUL、0xF36E6F75UL、0x0105EC76UL、0x12551F82UL、0xE03E9C81UL、0x34F4F86AUL、0xC69F7B69UL、0xD5CF889DUL 、0x27A40B9EUL、0x79B737BAUL、0x8BDCB4B9UL、0x988C474DUL、0x6AE7C44EUL、0xBE2DA0A5UL、0x4C4623A6UL、0x5F16D052UL、0xAD7D5351UL、}。"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.10. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.10からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of table build routine */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include <stdio.h> #include <stdlib.h>",
      "ja": "書式#include <stdio.hに>する#include <stdlib.h>に含ま"
    },
    {
      "indent": 3,
      "text": "#define OUTPUT_FILE   \"crc32cr.h\"\n#define CRC32C_POLY    0x1EDC6F41L\nFILE *tf;\nunsigned long\nreflect_32 (unsigned long b)\n{\n  int i;\n  unsigned long rw = 0L;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 32; i++){\n      if (b & 1)\n        rw |= 1 << (31 - i);\n      b >>= 1;\n  }\n  return (rw);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "unsigned long\nbuild_crc_table (int index)\n{\n  int i;\n  unsigned long rb;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rb = reflect_32 (index);",
      "ja": "RB = reflect_32（インデックス）"
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 8; i++){\n      if (rb & 0x80000000L)\n       rb = (rb << 1) ^ CRC32C_POLY;\n      else\n       rb <<= 1;\n  }\n  return (reflect_32 (rb));\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "main ()",
      "ja": "メイン（）"
    },
    {
      "indent": 3,
      "text": "{ int i;",
      "ja": "{iがint型。"
    },
    {
      "indent": 5,
      "text": "printf (\"\\nGenerating CRC-32c table file <%s>\\n\",\nOUTPUT_FILE);\nif ((tf = fopen (OUTPUT_FILE, \"w\")) == NULL){\n    printf (\"Unable to open %s\\n\", OUTPUT_FILE);\n    exit (1);\n}\nfprintf (tf, \"#ifndef __crc32cr_table_h__\\n\");\nfprintf (tf, \"#define __crc32cr_table_h__\\n\\n\");\nfprintf (tf, \"#define CRC32C_POLY 0x%08lX\\n\",\nCRC32C_POLY);\nfprintf (tf,\n\"#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\\n\");\nfprintf (tf, \"\\nunsigned long  crc_c[256] =\\n{\\n\");\nfor (i = 0; i < 256; i++){\n    fprintf (tf, \"0x%08lXL, \", build_crc_table (i));\n    if ((i & 3) == 3)\n      fprintf (tf, \"\\n\");\n}\nfprintf (tf, \"};\\n\\n#endif\\n\");",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  if (fclose (tf) != 0)\n    printf (\"Unable to close <%s>.\" OUTPUT_FILE);\n  else\n    printf (\"\\nThe CRC-32c table has been written to <%s>.\\n\",\n      OUTPUT_FILE);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix B)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of table build routine */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include <stdio.h> #include <stdlib.h>",
      "ja": "書式#include <stdio.hに>する#include <stdlib.h>に含ま"
    },
    {
      "indent": 3,
      "text": "#define OUTPUT_FILE \"crc32cr.h\" #define CRC32C_POLY 0x1EDC6F41UL",
      "ja": "#define OUTPUT_FILE \"crc32cr.h\" の#define CRC32C_POLY 0x1EDC6F41UL"
    },
    {
      "indent": 3,
      "text": "static FILE *tf;",
      "ja": "静的FILE *のTF。"
    },
    {
      "indent": 3,
      "text": "static uint32_t\nreflect_32(uint32_t b)\n{\n  int i;\n  uint32_t rw = 0UL;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < 32; i++) {",
      "ja": "用（i = 0; iは32 <; iは++）{"
    },
    {
      "indent": 3,
      "text": "      if (b & 1)\n        rw |= 1 << (31 - i);\n      b >>= 1;\n  }\n  return (rw);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "static uint32_t\nbuild_crc_table (int index)\n{\n  int i;\n  uint32_t rb;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rb = reflect_32(index);",
      "ja": "RB = reflect_32（インデックス）"
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 8; i++) {\n      if (rb & 0x80000000UL)\n       rb = (rb << 1) ^ (uint32_t)CRC32C_POLY;\n      else\n       rb <<= 1;\n  }\n  return (reflect_32(rb));\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int main (void) { int i;",
      "ja": "メインINT（ボイド）{iはint型。"
    },
    {
      "indent": 5,
      "text": "printf(\"\\nGenerating CRC32c table file <%s>.\\n\",\nOUTPUT_FILE);\nif ((tf = fopen(OUTPUT_FILE, \"w\")) == NULL) {\n    printf(\"Unable to open %s.\\n\", OUTPUT_FILE);\n    exit (1);\n}\nfprintf(tf, \"#ifndef __crc32cr_h__\\n\");\nfprintf(tf, \"#define __crc32cr_h__\\n\\n\");\nfprintf(tf, \"#define CRC32C_POLY 0x%08XUL\\n\",\n  (uint32_t)CRC32C_POLY);\nfprintf(tf,\n  \"#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\\n\");\nfprintf(tf, \"\\nuint32_t crc_c[256] =\\n{\\n\");\nfor (i = 0; i < 256; i++) {\n    fprintf(tf, \"0x%08XUL,\", build_crc_table (i));\n    if ((i & 3) == 3)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "      fprintf(tf, \"\\n\");\n    else\n      fprintf(tf, \" \");\n}\nfprintf(tf, \"};\\n\\n#endif\\n\");",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  if (fclose(tf) != 0)\n    printf(\"Unable to close <%s>.\\n\", OUTPUT_FILE);\n  else\n    printf(\"\\nThe CRC32c table has been written to <%s>.\\n\",\n      OUTPUT_FILE);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Section 3.10. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これは、セクション3.10からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of crc insertion */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include \"crc32cr.h\"",
      "ja": "#include \"crc32cr.h\""
    },
    {
      "indent": 3,
      "text": "unsigned long\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  unsigned long crc32 = ~0L;\n  unsigned long result;\n  unsigned char byte0,byte1,byte2,byte3;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < length; i++){ CRC32C(crc32, buffer[i]); }",
      "ja": "用（i = 0; iは長さ<; iは++）{CRC32C（CRC32は、緩衝液[I]）。 }"
    },
    {
      "indent": 5,
      "text": "result = ~crc32;",
      "ja": "結果=〜CRC32。"
    },
    {
      "indent": 5,
      "text": "/*  result now holds the negated polynomial remainder;\n *  since the table and algorithm is \"reflected\" [williams95].\n *  That is, result has the same value as if we mapped the message\n *  to a polynomial, computed the host-bit-order polynomial\n *  remainder, performed final negation, then did an end-for-end\n *  bit-reversal.\n *  Note that a 32-bit bit-reversal is identical to four inplace\n *  8-bit reversals followed by an end-for-end byteswap.\n *  In other words, the bytes of each bit are in the right order,",
      "raw": true
    },
    {
      "indent": 6,
      "text": "* but the bytes have been byteswapped. So we now do an explicit * byteswap. On a little-endian machine, this byteswap and * the final ntohl cancel out and could be elided. */",
      "ja": "*しかし、バイトがbyteswappedされています。だから我々は今、明示的な*バイトスワップを行います。リトルエンディアンのマシンでは、このバイトスワップおよび*最終ntohlは相殺と省略されることができました。 * /"
    },
    {
      "indent": 3,
      "text": "  byte0 = result & 0xff;\n  byte1 = (result>>8) & 0xff;\n  byte2 = (result>>16) & 0xff;\n  byte3 = (result>>24) & 0xff;\n  crc32 = ((byte0 << 24) |\n           (byte1 << 16) |\n           (byte2 << 8)  |\n           byte3);\n  return ( crc32 );\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int\ninsert_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned long crc32;\n  message = (SCTP_message *) buffer;\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer,length);\n  /* and insert it into the message */\n  message->common_header.checksum = htonl(crc32);\n  return 1;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int\nvalidate_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned int i;\n  unsigned long original_crc32;\n  unsigned long crc32 = ~0L;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  /* save and zero checksum */\n  message = (SCTP_message *) buffer;\n  original_crc32 = ntohl(message->common_header.checksum);\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer,length);\n  return ((original_crc32 == crc32)? 1 : -1);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix B)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of crc insertion */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include \"crc32cr.h\"",
      "ja": "#include \"crc32cr.h\""
    },
    {
      "indent": 3,
      "text": "uint32_t\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  uint32_t crc32 = 0xffffffffUL;\n  uint32_t result;\n  uint8_t byte0, byte1, byte2, byte3;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < length; i++) { CRC32C(crc32, buffer[i]); }",
      "ja": "用（i = 0; iは長さ<; iは++）{CRC32C（CRC32は、緩衝液[I]）。 }"
    },
    {
      "indent": 5,
      "text": "result = ~crc32;",
      "ja": "結果=〜CRC32。"
    },
    {
      "indent": 5,
      "text": "/*  result now holds the negated polynomial remainder,\n *  since the table and algorithm are \"reflected\" [williams95].\n *  That is, result has the same value as if we mapped the message\n *  to a polynomial, computed the host-bit-order polynomial\n *  remainder, performed final negation, and then did an\n *  end-for-end bit-reversal.\n *  Note that a 32-bit bit-reversal is identical to four in-place\n *  8-bit bit-reversals followed by an end-for-end byteswap.\n *  In other words, the bits of each byte are in the right order,\n *  but the bytes have been byteswapped.  So, we now do an explicit\n *  byteswap.  On a little-endian machine, this byteswap and\n *  the final ntohl cancel out and could be elided.\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  byte0 = result & 0xff;\n  byte1 = (result>>8) & 0xff;\n  byte2 = (result>>16) & 0xff;\n  byte3 = (result>>24) & 0xff;\n  crc32 = ((byte0 << 24) |\n           (byte1 << 16) |\n           (byte2 << 8)  |\n           byte3);\n  return (crc32);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int insert_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  uint32_t crc32;\n  message = (SCTP_message *) buffer;\n  message->common_header.checksum = 0UL;\n  crc32 = generate_crc32c(buffer,length);\n  /* and insert it into the message */\n  message->common_header.checksum = htonl(crc32);\n  return 1;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int\nvalidate_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned int i;\n  uint32_t original_crc32;\n  uint32_t crc32;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  /* save and zero checksum */\n  message = (SCTP_message *)buffer;\n  original_crc32 = ntohl(message->common_header.checksum);\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer, length);\n  return ((original_crc32 == crc32)? 1 : -1);\n}\n<CODE ENDS>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text has been modified by multiple errata. It includes modifications from Sections 3.5 and 3.10. It is in final form and is not further updated in this document.",
      "ja": "このテキストは、複数の正誤表で変更されています。これはセクション3.5及び3.10からの変更が含まれます。それは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.46.3. Solution Description",
      "section_title": true,
      "ja": "3.46.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The code was changed to use platform-independent types.",
      "ja": "コードはプラットフォームに依存しないタイプを使用するように変更されました。"
    },
    {
      "indent": 0,
      "text": "3.47. Clarification of Gap Ack Blocks in SACK Chunks",
      "section_title": true,
      "ja": "3.47。 SACKチャンクでのギャップAckブロックの明確化"
    },
    {
      "indent": 0,
      "text": "3.47.1. Description of the Problem",
      "section_title": true,
      "ja": "3.47.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The Gap Ack Blocks in the SACK chunk are intended to be isolated. However, this is not mentioned with normative text.",
      "ja": "SACKチャンク内のギャップAckブロックを単離することが意図されています。しかし、これは規範的なテキストに記載されていません。"
    },
    {
      "indent": 3,
      "text": "This issue was reported as part of an errata for [RFC4960] with Errata ID 5202.",
      "ja": "この問題は、正誤表ID 5202と[RFC4960]の正誤表の一部として報告されました。"
    },
    {
      "indent": 0,
      "text": "3.47.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.47.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SACK also contains zero or more Gap Ack Blocks. Each Gap Ack Block acknowledges a subsequence of TSNs received following a break in the sequence of received TSNs. By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the value of the Cumulative TSN Ack.",
      "ja": "SACKもゼロ以上のギャップAckブロックが含まれています。各ギャップAckブロックはなTSNのサブシーケンスは、受信したTSNの順にブレーク次受け取っ認めています。定義では、ギャップAckブロックによって承認すべてのTSNは累積TSN Ackをの値よりも大きいです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SACK also contains zero or more Gap Ack Blocks. Each Gap Ack Block acknowledges a subsequence of TSNs received following a break in the sequence of received TSNs. The Gap Ack Blocks SHOULD be isolated. This means that the TSN just before each Gap Ack Block and the TSN just after each Gap Ack Block have not been received. By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the value of the Cumulative TSN Ack.",
      "ja": "SACKもゼロ以上のギャップAckブロックが含まれています。各ギャップAckブロックはなTSNのサブシーケンスは、受信したTSNの順にブレーク次受け取っ認めています。ギャップAckブロックを分離する必要があります。これはちょうど、各ギャップAckブロックとちょうど各ギャップAckブロックの後TSN前にTSNを受信して​​いないことを意味します。定義では、ギャップAckブロックによって承認すべてのTSNは累積TSN Ackをの値よりも大きいです。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks:",
      "ja": "ギャップAckブロック："
    },
    {
      "indent": 6,
      "text": "These fields contain the Gap Ack Blocks. They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks defined in the Number of Gap Ack Blocks field. All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack Block are assumed to have been received correctly.",
      "ja": "これらのフィールドはギャップAckブロックが含まれています。彼らは、ギャップAckブロックフィールドの数で定義されたギャップAckブロックの数まで、各ギャップAckブロックごとに繰り返されます。以上（累積TSNのAck +ギャップAckブロックスタート）に等しく、以下の各ギャップAckブロックの（累積TSNのAck +ギャップAckブロックエンド）に等しいTSNを有するすべてのデータチャンクが正しく受信されているものとします。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks:",
      "ja": "ギャップAckブロック："
    },
    {
      "indent": 6,
      "text": "These fields contain the Gap Ack Blocks. They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks defined in the Number of Gap Ack Blocks field. All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack Block are assumed to have been received correctly. Gap Ack Blocks SHOULD be isolated. This means that the DATA chunks with TSNs equal to (Cumulative TSN Ack + Gap Ack Block Start - 1) and (Cumulative TSN Ack + Gap Ack Block End + 1) have not been received.",
      "ja": "これらのフィールドはギャップAckブロックが含まれています。彼らは、ギャップAckブロックフィールドの数で定義されたギャップAckブロックの数まで、各ギャップAckブロックごとに繰り返されます。以上（累積TSNのAck +ギャップAckブロックスタート）に等しく、以下の各ギャップAckブロックの（累積TSNのAck +ギャップAckブロックエンド）に等しいTSNを有するすべてのデータチャンクが正しく受信されているものとします。ギャップAckブロックを分離する必要があります。これは、に等しいTSNを有するデータチャンクことを意味する（累積TSNのAck +ギャップAckブロックスタート -  1）及び（累積TSNのAck +ギャップAckブロックエンド+ 1）受信されていません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.47.3. Solution Description",
      "section_title": true,
      "ja": "3.47.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Normative text describing the intended usage of Gap Ack Blocks has been added.",
      "ja": "ギャップAckブロックの使用目的を記述規定テキストが追加されました。"
    },
    {
      "indent": 0,
      "text": "3.48. Handling of SSN Wraparounds",
      "section_title": true,
      "ja": "3.48。 SSNラップアラウンドの取扱い"
    },
    {
      "indent": 0,
      "text": "3.48.1. Description of the Problem",
      "section_title": true,
      "ja": "3.48.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The Stream Sequence Number (SSN) is used for preserving the ordering of user messages within each SCTP stream. The SSN is limited to 16 bits. Therefore, multiple wraparounds of the SSN might happen within the current send window. To allow the receiver to deliver ordered user messages in the correct sequence, the sender should limit the number of user messages per stream.",
      "ja": "ストリームシーケンス番号（SSN）は、各SCTPストリーム内のユーザメッセージの順序を保存するために使用されます。 SSNは16ビットに制限されています。したがって、SSNの複数のラップアラウンドは、現在の送信ウィンドウ内で発生する可能性があります。受信機が正しい順序で並べられたユーザメッセージを配信できるようにするには、送信側は、ストリームごとのユーザーのメッセージ数を制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.48.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.48.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window.",
      "ja": "注意：データの送信者は2 ** 31以上であるTSN使うべきではありません -  1現在の送信ウィンドウの開始TSNの上を。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window. Note: For each stream, the data sender SHOULD NOT have more than 2**16 - 1 ordered user messages in the current send window.",
      "ja": "注意：データの送信者は2 ** 31以上であるTSN使うべきではありません -  1現在の送信ウィンドウの開始TSNの上を。注： -  1現在の送信ウィンドウでユーザーメッセージを命じた各ストリームについて、データの送信者は、以上の2 ** 16は持つべきではありません。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.48.3. Solution Description",
      "section_title": true,
      "ja": "3.48.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The data sender is required to limit the number of ordered user messages within the current send window.",
      "ja": "データ送信側は、現在の送信ウィンドウ内命じたユーザメッセージの数を制限するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "3.49. Update to Boilerplate Text",
      "section_title": true,
      "ja": "3.49。ボイラープレート・テキストへのアップデート"
    },
    {
      "indent": 0,
      "text": "3.49.1. Description of the Problem",
      "section_title": true,
      "ja": "3.49.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The text to be used to refer to the terms (\"key words\") defined in [RFC2119] has been updated by [RFC8174]. This needs to be integrated into the base specification.",
      "ja": "テキストが[RFC2119]で定義された用語（「キーワード」）を指すために使用されるように[RFC8174]で更新されています。これは、基本仕様に統合する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.49.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.49.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.49.3. Solution Description",
      "section_title": true,
      "ja": "3.49.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text has been updated to the text specified in [RFC8174].",
      "ja": "テキストは、[RFC8174]で指定したテキストに更新されました。"
    },
    {
      "indent": 0,
      "text": "3.50. Removal of Text (Previously Missed in )",
      "section_title": true,
      "ja": "3.50。テキストの除去（以前で逃しました）"
    },
    {
      "indent": 0,
      "text": "3.50.1. Description of the Problem",
      "section_title": true,
      "ja": "3.50.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When integrating the changes to Section 7.2.4 of [RFC2960] as described in Section 2.8.2 of [RFC4460], some text was not removed and is therefore still in [RFC4960].",
      "ja": "[RFC4460]のセクション2.8.2に記載したように[RFC2960]のセクション7.2.4に変更を統合する場合、いくつかのテキストを除去し、[RFC4960]にまだことであるありませんでした。"
    },
    {
      "indent": 0,
      "text": "3.50.2. Text Changes to the Document",
      "section_title": true,
      "ja": "3.50.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A straightforward implementation of the above keeps a counter for each TSN hole reported by a SACK. The counter increments for each consecutive SACK reporting the TSN hole. After reaching 3 and starting the Fast-Retransmit procedure, the counter resets to 0. Because cwnd in SCTP indirectly bounds the number of outstanding TSN's, the effect of TCP Fast Recovery is achieved automatically with no adjustment to the congestion control window size.",
      "ja": "上記の簡単な実装はSACKによって報告された各TSN穴用のカウンタを保持します。 TSN穴を報告各連続SACKのカウンタをインクリメント。 SCTPにおけるCWNDが間接的発行済TSNの数、輻輳制御ウィンドウサイズを調整なしで自動的に達成されるTCP高速回復の効果を境界ので高速再送信手順を3に到達すると開始した後、カウンタが0にリセットします。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This text is in final form and is not further updated in this document.",
      "ja": "このテキストは、最終的な形態であり、さらに、このドキュメントでは更新されません。"
    },
    {
      "indent": 0,
      "text": "3.50.3. Solution Description",
      "section_title": true,
      "ja": "3.50.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text has finally been removed.",
      "ja": "テキストは最終的に削除されました。"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 3.44 of this document suggests new text that would update the \"Service Name and Transport Protocol Port Number Registry\" for SCTP to be consistent with [RFC6335].",
      "ja": "このドキュメントのセクション3.44は、[RFC6335]と一致するようにSCTPのための「サービス名とトランスポートプロトコルポート番号レジストリ」を更新してしまう新しいテキストを示唆しています。"
    },
    {
      "indent": 3,
      "text": "IANA has confirmed that it is OK to make the proposed text change in an upcoming Standards Track document that will update [RFC4960]. IANA is not asked to perform any other action, and this document does not request that IANA make a change to any registry.",
      "ja": "IANAは、[RFC4960]を更新します今後の標準化過程文書で提案されているテキストの変更を行うことがOKであることを確認しました。 IANAは、他のアクションを実行するように要求されていない、と本書は、IANAがどのレジストリに変更を加えることを要求しません。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not add any security considerations to those given in [RFC4960].",
      "ja": "この文書では、[RFC4960]で与えられたものに任意のセキュリティ上の考慮事項を追加しません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <https://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960]スチュワート、R.、エド。、 \"ストリーム制御伝送プロトコル\"、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<https://www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC1858] Ziemba, G., Reed, D., and P. Traina, \"Security Considerations for IP Fragment Filtering\", RFC 1858, DOI 10.17487/RFC1858, October 1995, <https://www.rfc-editor.org/info/rfc1858>.",
      "ja": "[RFC1858] Ziemba、G.、リード、D.、およびP. Trainaの、 \"IPフラグメントフィルタリングのためのセキュリティの考慮事項\"、RFC 1858、DOI 10.17487 / RFC1858、1995年10月、<https://www.rfc-editor.org /情報/ rfc1858>。"
    },
    {
      "indent": 3,
      "text": "[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, DOI 10.17487/RFC2960, October 2000, <https://www.rfc-editor.org/info/rfc2960>.",
      "ja": "[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、DOI 10.17487 / RFC2960、2000年10月、<https://www.rfc-editor.org/info/rfc2960>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <https://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：//でWWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC4460] Stewart, R., Arias-Rodriguez, I., Poon, K., Caro, A., and M. Tuexen, \"Stream Control Transmission Protocol (SCTP) Specification Errata and Issues\", RFC 4460, DOI 10.17487/RFC4460, April 2006, <https://www.rfc-editor.org/info/rfc4460>.",
      "ja": "[RFC4460]スチュワート、R.、アリアス - ロドリゲス、I.、プーン、K.、カロ、A.、およびM. Tuexen、 \"ストリーム制御伝送プロトコル（SCTP）仕様正誤表と課題\"、RFC 4460、DOI 10.17487 / RFC4460、2006年4月、<https://www.rfc-editor.org/info/rfc4460>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <https://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<https://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC6096] Tuexen, M. and R. Stewart, \"Stream Control Transmission Protocol (SCTP) Chunk Flags Registration\", RFC 6096, DOI 10.17487/RFC6096, January 2011, <https://www.rfc-editor.org/info/rfc6096>.",
      "ja": "[RFC6096] Tuexen、M.およびR.スチュワート、 \"ストリーム制御伝送プロトコル（SCTP）チャンクフラグ登録\"、RFC 6096、DOI 10.17487 / RFC6096、2011年1月、<https://www.rfc-editor.org/info / rfc6096>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<HTTPS：//www.rfc- editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, <https://www.rfc-editor.org/info/rfc6335>.",
      "ja": "[RFC6335]コットン、M.、エッゲルト、L.、タッチ、J.、ウェスター、M.、およびS.チェシャー、「IANA（Internet Assigned Numbers Authority）のサービス名とトランスポートプロトコルポート番号レジストリの管理のための手順」、BCP 165、RFC 6335、DOI 10.17487 / RFC6335、2011年8月、<https://www.rfc-editor.org/info/rfc6335>。"
    },
    {
      "indent": 3,
      "text": "[RFC7053] Tuexen, M., Ruengeler, I., and R. Stewart, \"SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol\", RFC 7053, DOI 10.17487/RFC7053, November 2013, <https://www.rfc-editor.org/info/rfc7053>.",
      "ja": "[RFC7053] Tuexen、M.、Ruengeler、I.、およびR.スチュワート、 \"SACK-すぐにストリーム制御伝送プロトコルのための拡張\"、RFC 7053、DOI 10.17487 / RFC7053、2013年11月、<HTTPS：//www.rfc -editor.org/info/rfc7053>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126]綿、M.、Leiba、B.、およびT. Narten氏、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：//でWWW .rfc-editor.org /情報/ rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8311] Black, D., \"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation\", RFC 8311, DOI 10.17487/RFC8311, January 2018, <https://www.rfc-editor.org/info/rfc8311>.",
      "ja": "[RFC8311]ブラック、D.、 \"明示的輻輳通知でリラックス制限（ECN）実験\"、RFC 8311、DOI 10.17487 / RFC8311、2018年1月、<https://www.rfc-editor.org/info/rfc8311>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Pontus Andersson, Eric W. Biederman, Cedric Bonnet, Spencer Dawkins, Gorry Fairhurst, Benjamin Kaduk, Mirja Kuehlewind, Peter Lei, Gyula Marosi, Lionel Morand, Jeff Morriss, Karen E. E. Nielsen, Tom Petch, Kacheong Poon, Julien Pourtet, Irene Ruengeler, Michael Welzl, and Qiaobing Xie for their invaluable comments.",
      "ja": "著者は、ポントス・アンダーソン、エリック・W. Biederman、セドリックボンネット、スペンサードーキンスGorry Fairhurst、ベンジャミンKaduk、Mirja Kuehlewind、ピーター・レイ、ジュラMarosi、ライオネル・モラン、ジェフMorriss、カレンEEニールセン、トム・ペッチ、Kacheongプーンに感謝したいです彼らの貴重なコメントのためのジュリアン・Pourtet、アイリーンRuengeler、マイケルWelzl、およびQiaobing謝。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Netflix, Inc. Chapin, SC 29036 United States of America",
      "ja": "ランドールR.スチュワートネットフリックス社アメリカのチャピン、SC 29036米国"
    },
    {
      "indent": 3,
      "text": "Email: randall@lakerest.net",
      "ja": "メール：randall@lakerest.net"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster University of Applied Sciences Stegerwaldstrasse 39 48565 Steinfurt Germany",
      "ja": "応用科学Stegerwaldstrasse 39 48565シュタインフルトドイツのマイケルTuexenミュンスター大学"
    },
    {
      "indent": 3,
      "text": "Email: tuexen@fh-muenster.de",
      "ja": "メール：tuexen@fh-muenster.de"
    },
    {
      "indent": 3,
      "text": "Maksim Proshin Ericsson Kistavaegen 25 Stockholm 164 80 Sweden",
      "ja": "マキシムProshin Kistavaegenエリクソン164 25ストックホルムスウェーデン80"
    },
    {
      "indent": 3,
      "text": "Email: mproshin@tieto.mera.ru",
      "ja": "メール：mproshin@tieto.mera.ru"
    }
  ]
}