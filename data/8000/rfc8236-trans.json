{
  "title": {
    "text": "RFC 8236 - J-PAKE: Password-Authenticated Key Exchange by Juggling",
    "ja": "RFC 8236 - J-PAKE：ジャグリングによってパスワード認証鍵交換"
  },
  "number": 8236,
  "created_at": "2019-10-27 07:06:54.893625+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                       F. Hao, Ed.\nRequest for Comments: 8236                     Newcastle University (UK)\nCategory: Informational                                   September 2017\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 8,
      "text": "J-PAKE: Password-Authenticated Key Exchange by Juggling",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a Password-Authenticated Key Exchange by Juggling (J-PAKE) protocol. This protocol allows the establishment of a secure end-to-end communication channel between two remote parties over an insecure network solely based on a shared password, without requiring a Public Key Infrastructure (PKI) or any trusted third party.",
      "ja": "この文書では、ジャグリング（J-PAKE）プロトコルによるパスワード認証鍵交換を指定します。このプロトコルは、公開鍵基盤（PKI）または任意の信頼できる第三者を必要とせずに、単に共有パスワードに基づいて、安全でないネットワーク上の2つのリモート当事者間の安全なエンド・ツー・エンドの通信チャネルの確立を可能にします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8236.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8236で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3\n  1.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  J-PAKE over Finite Field  . . . . . . . . . . . . . . . . . .   4\n  2.1.  Protocol Setup  . . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  Two-Round Key Exchange  . . . . . . . . . . . . . . . . .   5\n  2.3.  Computational Cost  . . . . . . . . . . . . . . . . . . .   6\n3.  J-PAKE over Elliptic Curve  . . . . . . . . . . . . . . . . .   7\n  3.1.  Protocol Setup  . . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Two-Round Key Exchange  . . . . . . . . . . . . . . . . .   7\n  3.3.  Computational Cost  . . . . . . . . . . . . . . . . . . .   8\n4.  Three-Pass Variant  . . . . . . . . . . . . . . . . . . . . .   8\n5.  Key Confirmation  . . . . . . . . . . . . . . . . . . . . . .   9\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  11\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  12\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  14\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  15\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  15",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Password-Authenticated Key Exchange (PAKE) is a technique that aims to establish secure communication between two remote parties solely based on their shared password, without relying on a Public Key Infrastructure or any trusted third party [BM92]. The first PAKE protocol, called Encrypted Key Exchange (EKE), was proposed by Steven Bellovin and Michael Merrit in 1992 [BM92]. Other well-known PAKE protocols include Simple Password Exponential Key Exchange (SPEKE) by David Jablon in 1996 [Jab96] and Secure Remote Password (SRP) by Tom Wu in 1998 [Wu98]. SRP has been revised several times to address reported security and efficiency issues. In particular, the version 6 of SRP, commonly known as SRP-6, is specified in [RFC5054].",
      "ja": "パスワード認証鍵交換（PAKE）は、公開鍵インフラストラクチャまたは任意の信頼できるサードパーティ製[BM92]に頼ることなく、もっぱらその共有のパスワードに基づいて2つのリモート当事者間の安全な通信を確立することを目指して技術です。暗号化キー交換（EKE）と呼ばれる最初のPAKEプロトコルは、1992年にスティーブンBellovin氏とマイケルMerritで[BM92]を提案しました。他のよく知られたPAKEプロトコルは[Wu98] [Jab96] 1996年にデビッド・Jablonことにより、簡単なパスワード指数キー交換（SPEKE）を含めると、1998年にトム・ウーによってリモートパスワード（SRP）を固定します。 SRPは、報告されたセキュリティと効率性の問題に対処するために何度か改訂されています。具体的には、一般にSRP-6として知られているSRPのバージョン6は、[RFC5054]で指定されています。"
    },
    {
      "indent": 3,
      "text": "This document specifies a PAKE protocol called Password-Authenticated Key Exchange by Juggling (J-PAKE), which was designed by Feng Hao and Peter Ryan in 2008 [HR08]. There are a few factors that may be considered in favor of J-PAKE. First, J-PAKE has security proofs, while equivalent proofs are lacking in EKE, SPEKE and SRP-6. Second, J-PAKE follows a completely different design approach from all other PAKE protocols, and is built upon a well-established Zero Knowledge Proof (ZKP) primitive: Schnorr NIZK proof [RFC8235]. Third, J-PAKE adopts novel engineering techniques to optimize the use of ZKP so that overall the protocol is sufficiently efficient for practical use. Fourth, J-PAKE is designed to work generically in both the finite field and elliptic curve settings (i.e., DSA and ECDSA-like groups, respectively). Unlike SPEKE, it does not require any extra primitive to hash passwords onto a designated elliptic curve. Unlike SPAKE2 [AP05] and SESPAKE [SOAA15], it does not require a trusted setup (i.e., the so-called common reference model) to define a pair of generators whose discrete logarithm must be unknown. Finally, J-PAKE has been used in real-world applications at a relatively large scale, e.g., Firefox sync [MOZILLA], Pale moon sync [PALEMOON], and Google Nest products [ABM15]. It has been included into widely distributed open source libraries such as OpenSSL [BOINC], Network Security Services (NSS) [MOZILLA_NSS], and the Bouncy Castle [BOUNCY]. Since 2015, J-PAKE has been included in Thread [THREAD] as a standard key agreement mechanism for IoT (Internet of Things) applications, and also included in ISO/IEC 11770-4:2017 [ISO.11770-4].",
      "ja": "この文書は、2008年に風水ハオ、ピーター・ライアンによって設計されましたジャグリング（J-PAKE）によるパスワード認証鍵交換と呼ばれるPAKEプロトコル[HR08]を指定します。 J-PAKEに有利に考慮することができるいくつかの要因があります。まず、J-PAKEは同等の証明がEKE、SPEKEおよびSRP-6に欠けている一方で、セキュリティ証明を持っています。第二に、J-PAKEは、他のすべてのPAKEプロトコルとは全く異なる設計アプローチに従い、十分に確立されたゼロ知識証明（ZKP）プリミティブに基づいて構築される：シュノールNIZKプルーフ[RFC8235]。第三に、J-PAKEは、全体的なプロトコルは、実用上十分に効率的であるようZKPの使用を最適化するために、新規な工学技術を採用しています。第四に、J-PAKEは有限体と楕円曲線設定（すなわち、DSAおよびECDSA状基、それぞれ）の両方において一般的に動作するように設計されています。 SPEKEとは異なり、それは指定された楕円曲線上にパスワードをハッシュする余分なプリミティブを必要としません。 SPAKE2 [AP05]とSESPAKE [SOAA15]とは異なり、それは離散対数不明でなければならない発電機のペアを定義するために、信頼できるセットアップ（すなわち、いわゆる一般的な参照モデル）を必要としません。最後に、J-PAKEは[ABM15]例えば、Firefoxの同期[MOZILLA]、ペールムーン同期[PALEMOON]、およびGoogleの巣製品、比較的大規模で実際のアプリケーションで使用されてきました。このようなOpenSSLの[BOINC]、ネットワークセキュリティサービス（NSS）[MOZILLA_NSS]、および弾む城[弾む]として広く分布しているオープンソースのライブラリに含まれています。 [ISO.11770-4] 2017：2015年以来、J-PAKEは、スレッドでのIoT（モノのインターネット）アプリケーションのための標準的なキー合意メカニズムとして[スレッド]を含めており、また、ISO / IEC 11770から4に含まれています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。"
    },
    {
      "indent": 0,
      "text": "1.2. Notation",
      "section_title": true,
      "ja": "1.2。表記法"
    },
    {
      "indent": 3,
      "text": "The following notation is used in this document:",
      "ja": "以下の表記は、このドキュメントで使用されます。"
    },
    {
      "indent": 3,
      "text": "o Alice: the assumed identity of the prover in the protocol",
      "ja": "Oアリス：プロトコルでの証明の前提とアイデンティティ"
    },
    {
      "indent": 3,
      "text": "o Bob: the assumed identity of the verifier in the protocol",
      "ja": "Oボブ：プロトコルにおける検証の仮定アイデンティティ"
    },
    {
      "indent": 3,
      "text": "o s: a low-entropy secret shared between Alice and Bob",
      "ja": "O S：低エントロピーの秘密は、アリスとボブの間で共有しました"
    },
    {
      "indent": 3,
      "text": "o a | b: a divides b",
      "ja": "O | B：AはBを分割します"
    },
    {
      "indent": 3,
      "text": "o a || b: concatenation of a and b",
      "ja": "O || B：aとbの連結"
    },
    {
      "indent": 3,
      "text": "o [a, b]: the interval of integers between and including a and b",
      "ja": "O [A、B]とを含むとBとの間の整数の間隔"
    },
    {
      "indent": 3,
      "text": "o H: a secure cryptographic hash function",
      "ja": "O H：セキュアな暗号学的ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "o p: a large prime",
      "ja": "OのP：大きな素数"
    },
    {
      "indent": 3,
      "text": "o q: a large prime divisor of p-1, i.e., q | p-1",
      "ja": "O Q：P-1の大きな素数除数、すなわち、Q | P-1"
    },
    {
      "indent": 3,
      "text": "o Zp*: a multiplicative group of integers modulo p o Gq: a subgroup of Zp* with prime order q",
      "ja": "OのZp *：GqのoをPを法の整数の乗法群：プライム次数qとのZp *のサブグループ"
    },
    {
      "indent": 3,
      "text": "o g: a generator of Gq",
      "ja": "O G：のGqの発生を"
    },
    {
      "indent": 3,
      "text": "o g^d: g raised to the power of d",
      "ja": "O G ^ D：G D乗"
    },
    {
      "indent": 3,
      "text": "o a mod b: a modulo b",
      "ja": "モジュロB：MOD B O"
    },
    {
      "indent": 3,
      "text": "o Fp: a finite field of p elements, where p is a prime",
      "ja": "O FP：pは素数であるp要素の有限体、"
    },
    {
      "indent": 3,
      "text": "o E(Fp): an elliptic curve defined over Fp",
      "ja": "入出力E（FP）：Fpの上に定義された楕円曲線"
    },
    {
      "indent": 3,
      "text": "o G: a generator of the subgroup over E(Fp) with prime order n",
      "ja": "O G：プライム次数nを有するE上のサブグループのジェネレータ（FP）"
    },
    {
      "indent": 3,
      "text": "o n: the order of G",
      "ja": "O N：Gの順序"
    },
    {
      "indent": 3,
      "text": "o h: the cofactor of the subgroup generated by G, which is equal to the order of the elliptic curve divided by n",
      "ja": "OのH：nで割った楕円曲線の次数に等しいGによって生成されたサブグループの補因子"
    },
    {
      "indent": 3,
      "text": "o P x [b]: multiplication of a point P with a scalar b over E(Fp)",
      "ja": "O P X [B]：E上スカラBと点Pの乗算（FP）"
    },
    {
      "indent": 3,
      "text": "o KDF(a): Key Derivation Function with input a",
      "ja": "O KDF（A）：入力Aと鍵導出関数"
    },
    {
      "indent": 3,
      "text": "o MAC(MacKey, MacData): MAC function with MacKey as the key and MacData as the input data",
      "ja": "O MAC（マッキー、MacData）：マッキーとMAC関数の入力データとしてキーとMacDataとして"
    },
    {
      "indent": 0,
      "text": "2. J-PAKE over Finite Field",
      "section_title": true,
      "ja": "有限体上の2 J-PAKE"
    },
    {
      "indent": 0,
      "text": "2.1. Protocol Setup",
      "section_title": true,
      "ja": "2.1。プロトコルの設定"
    },
    {
      "indent": 3,
      "text": "When implemented over a finite field, J-PAKE may use the same group parameters as DSA [FIPS186-4]. Let p and q be two large primes such that q | p-1. Let Gq denote a subgroup of Zp* with prime order q. Let g be a generator for Gq. Any non-identity element in Gq can be a generator. The two communicating parties, Alice and Bob, both agree on (p, q, g), which can be hard-wired in the software code. They can also use the method in NIST FIPS 186-4, Appendix A [FIPS186-4] to generate (p, q, g). Here, DSA group parameters are used only as an example. Other multiplicative groups suitable for cryptography can also be used for the implementation, e.g., groups defined in [RFC4419]. A group setting that provides 128-bit security or above is recommended. The security proof of J-PAKE depends on the Decisional Diffie-Hellman (DDH) problem being intractable in the considered group.",
      "ja": "有限体上に実装された場合、J-PAKEは[FIPS186-4] DSAと同じグループのパラメータを使用してもよいです。 pとqは二つの大きな素数ように、Qとします| P-1。 Gqのはプライム次数qとのZp *のサブグループを表すとします。 gはGqのための発電機とします。 Gqの中の任意の非同一の要素には、発電することができます。 2つの通信当事者、アリスとボブの両方は、ソフトウェアコードにハードワイヤードされることができる、（P、Q、G）について合意します。彼らはまた、付録A [FIPS186-4]（P、Q、G）を生成するために、NIST FIPS 186から4方法を使用することができます。ここで、DSA基パラメータは例としてのみ使用されています。暗号化するのに適した他の乗法グループはまた、[RFC4419]で定義された基、例えば、実装のために使用することができます。上記128ビットのセキュリティを提供するか、グループの設定が推奨されます。 J-PAKEのセキュリティ証明は考えグループに難治性である。判断ディフィー・ヘルマン（DDH）問題に依存します。"
    },
    {
      "indent": 3,
      "text": "Let s be a secret value derived from a low-entropy password shared between Alice and Bob. The value of s is REQUIRED to fall within the range of [1, q-1]. (Note that s must not be 0 for any non-empty secret.) This range is defined as a necessary condition in [HR08] for proving the \"on-line dictionary attack resistance\", since s, s+q, s+2q, ..., are all considered equivalent values as far as the protocol specification is concerned. In a practical implementation, one may obtain s by taking a cryptographic hash of the password and wrapping the result with respect to modulo q. Alternatively, one may simply treat the password as an octet string and convert the string to an integer modulo q by following the method defined in Section 2.3.8 of [SEC1]. In either case, one MUST ensure s is not equal to 0 modulo q.",
      "ja": "sがアリスとボブの間で共有低エントロピーパスワードから派生秘密値とします。 sの値は[1、Q-1]の範囲内にする必要があります。 （すなわち、Sは空でない秘密のために0でない必要があります。）この範囲は、S、S + 1、Q、S + 2Qので、「オンライン辞書攻撃性」を立証するための[HR08]における必要条件として定義されます、...、すべての限りプロトコル仕様が懸念している同等の値とみなされます。実用的な実装では、一つのパスワードの暗号化ハッシュを取り、モジュロQに対して結果をラップすることによってSを得ることができます。あるいは、単にオクテットストリングとしてパスワードを治療し、[SEC1]のセクション2.3.8で定義された方法に従って、整数モジュロqに文字列を変換することができます。いずれの場合においても、一つはsは0モジュロQに等しくないことを確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Two-Round Key Exchange",
      "section_title": true,
      "ja": "2.2。 2ラウンドの鍵交換"
    },
    {
      "indent": 3,
      "text": "Round 1: Alice selects an ephemeral private key x1 uniformly at random from [0, q-1] and another ephemeral private key x2 uniformly at random from [1, q-1]. Similarly, Bob selects an ephemeral private key x3 uniformly at random from [0, q-1] and another ephemeral private key x4 uniformly at random from [1, q-1].",
      "ja": "ラウンド1：アリスからランダムに一様からランダムに一様にエフェメラル秘密鍵X1を選択する[0、Q-1]及び別のエフェメラルプライベートキーX2 [1、Q-1]。同様に、ボブは[0、Q-1]からランダムに一様に別のエフェメラル秘密鍵X4 [1、Q-1]からランダムに一様にエフェメラルプライベートキーX3を選択します。"
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: g1 = g^x1 mod p, g2 = g^x2 mod p and ZKPs for x1 and x2",
      "ja": "Oアリス - >ボブ：x1とx2のためのG1 = G ^ X1モッズP、G2 = G ^ x2のモッズpとZKPs"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: g3 = g^x3 mod p, g4 = g^x4 mod p and ZKPs for x3 and x4",
      "ja": "Oボブ - >アリス：X3及びX4のためG3 = G ^ X3 MOD P、G4 = G ^ X4 MOD pおよびZKPs"
    },
    {
      "indent": 3,
      "text": "In this round, the sender must send zero knowledge proofs to demonstrate the knowledge of the ephemeral private keys. A suitable technique is to use the Schnorr NIZK proof [RFC8235]. As an example, suppose one wishes to prove the knowledge of the exponent for D = g^d mod p. The generated Schnorr NIZK proof will contain: {UserID, V = g^v mod p, r = v - d * c mod q}, where UserID is the unique identifier for the prover, v is a number chosen uniformly at random from [0, q-1] and c = H(g || V || D || UserID). The \"uniqueness\" of UserID is defined from the user's perspective -- for example, if Alice communicates with several parties, she shall associate a unique identity with each party. Upon receiving a Schnorr NIZK proof, Alice shall check the prover's UserID is a valid identity and is different from her own identity. During the key exchange process using J-PAKE, each party shall ensure that the other party has been consistently using the same identity throughout the protocol execution. Details about the Schnorr NIZK proof, including the generation and the verification procedures, can be found in [RFC8235].",
      "ja": "このラウンドでは、送信者ははかない秘密鍵の知識を証明するためにゼロ知識証明を送信する必要があります。適切な技術は、シュノールNIZKプルーフ[RFC8235]を使用することです。一例として、一つはD = G ^ D MOD pの指数の知識を証明することを望むと仮定する。生成シュノールNIZK証拠が含まれています：{ユーザID、V = G ^ V MOD P、R = V  - のD *のC MOD Q}、ユーザーIDは、証明者の一意の識別子であり、vは[からランダムに一様に選択された数であります0、Q-1]、C = H（G || V || D || USERID）。ユーザーIDの「独自性」は、ユーザの視点から定義される - アリスは、いくつかの政党と通信する場合、たとえば、彼女は各当事者に固有のIDを関連付けるものとします。シュNIZK証明を受信すると、アリスは、証明者のユーザーIDが有効なIDで、彼女自身のアイデンティティと異なってチェックしなければなりません。 J-PAKEを使用して鍵交換プロセス中、各当事者は、相手方が一貫プロトコル実行全体で同じIDを使用していたことを確認しなければなりません。生成および検証手順を含むシュノールNIZK証明についての詳細は、[RFC8235]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "When this round finishes, Alice verifies the received ZKPs as specified in [RFC8235] and also checks that g4 != 1 mod p. Similarly, Bob verifies the received ZKPs and also checks that g2 != 1 mod p. If any of these checks fails, this session should be aborted.",
      "ja": "また、[RFC8235]で指定され、このラウンドが終了すると、アリスが受信ZKPsを検証するときG4！= 1 MOD Pことをチェックします。同様に、ボブは受信ZKPsを検証し、また、そのG2をチェック！= 1 MOD P。これらのチェックのいずれかが失敗した場合、このセッションは中止されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Round 2:",
      "ja": "ラウンド2："
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: A = (g1*g3*g4)^(x2*s) mod p and a ZKP for x2*s",
      "ja": "Oアリス - >ボブ：A =（G1 * G3 * G4）^（×2 *秒）のmod pと×2 * sのZKP"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: B = (g1*g2*g3)^(x4*s) mod p and a ZKP for x4*s",
      "ja": "Oボブ - >アリス：B =（G1 * G2 * G3）^（X4 *秒）MOD pおよびX4の* sのZKP"
    },
    {
      "indent": 3,
      "text": "In this round, the Schnorr NIZK proof is computed in the same way as in the previous round except that the generator is different. For Alice, the generator used is (g1*g3*g4) instead of g; for Bob, the generator is (g1*g2*g3) instead of g. Since any non-identity element in Gq can be used as a generator, Alice and Bob just need to ensure g1*g3*g4 != 1 mod p and g1*g2*g3 != 1 mod p. With overwhelming probability, these inequalities are statistically guaranteed even when the user is communicating with an adversary (i.e., in an active attack). Nonetheless, for absolute guarantee, the receiving party shall explicitly check if these inequalities hold, and abort the session in case such a check fails.",
      "ja": "このラウンドでは、シュノールNIZK証明は、発電機が異なること以外は前のラウンドと同じ方法で計算されます。アリスのために、使用される発電機ではなく、Gの（G1 * G3 * G4）です。ボブのために、発電機ではなく、Gの（G1 * G2の*のG3）です。 Gqの内の任意の非同一の要素を発電機として使用することができますので、アリスとボブはちょうど* G3 * G4！= 1のmod pとG1 * G2 * G3 G1を確保する必要があります！= 1つのmod P。圧倒的な確率で、これらの不等式は、統計的に、ユーザが（すなわち、アクティブな攻撃に）敵と通信している場合にも保証されています。それにもかかわらず、これらの不等式が保持している場合絶対的な保証のために、受信側は、明示的にチェックしなければならない、そして、そのようなチェックが失敗した場合にセッションを中止します。"
    },
    {
      "indent": 3,
      "text": "When the second round finishes, Alice and Bob verify the received ZKPs. If the verification fails, the session is aborted. Otherwise, the two parties compute the common key material as follows:",
      "ja": "第二ラウンドが終了すると、アリスとボブは、受信ZKPsを確認します。検証が失敗した場合、セッションは中止されます。次のようにそれ以外の場合は、両当事者は、共通鍵材料を計算します。"
    },
    {
      "indent": 3,
      "text": "o Alice computes Ka = (B/g4^(x2*s))^x2 mod p",
      "ja": "Oアリスがka =（B / G4 ^（×2 *秒））^ X2のmod Pを計算します"
    },
    {
      "indent": 3,
      "text": "o Bob computes Kb = (A/g2^(x4*s))^x4 mod p",
      "ja": "OボブはKB =（A / G2 ^（×4 *秒））^ X4のmod Pを計算します"
    },
    {
      "indent": 3,
      "text": "Here, Ka = Kb = g^((x1+x3)*x2*x4*s) mod p. Let K denote the same key material held by both parties. Using K as input, Alice and Bob then apply a Key Derivation Function (KDF) to derive a common session key k. If the subsequent secure communication uses a symmetric cipher in an authenticated mode (say AES-GCM), then one key is sufficient, i.e., k = KDF(K). Otherwise, the session key should comprise an encryption key (for confidentiality) and a MAC key (for integrity), i.e., k = k_enc || k_mac, where k_enc = KDF(K || \"JPAKE_ENC\") and k_mac = KDF(K || \"JPAKE_MAC\"). The exact choice of the KDF is left to specific applications to define.",
      "ja": "ここでは、カー= KB = G ^（（X1 + X3）*×2 *×4の*秒）モッズのp。 Kは、両当事者が保有同じ鍵材料を示すものとします。入力としてKを使用して、アリスとボブは、共通セッション鍵Kを導出するために鍵導出関数（KDF）を適用します。その後の安全な通信は、認証されたモード（たとえばAES-GCM）での対称暗号を使用する場合、一つのキーは十分、即ち、K = KDF（K）です。そうでなければ、セッションキー（機密性のために）暗号化鍵と（完全性）MAC鍵、すなわち、K = k_enc ||を含むべきですk_mac、k_enc = KDF（K || \"JPAKE_ENC\"）とk_mac = KDF（K || \"JPAKE_MAC\"）。 KDFの正確な選択は、定義するために、特定のアプリケーションに任されています。"
    },
    {
      "indent": 0,
      "text": "2.3. Computational Cost",
      "section_title": true,
      "ja": "2.3。計算コスト"
    },
    {
      "indent": 3,
      "text": "The computational cost is estimated based on counting the number of modular exponentiations since they are the predominant cost factors. Note that it takes one exponentiation to generate a Schnorr NIZK proof and two to verify it [RFC8235]. For Alice, she needs to perform 8 exponentiations in the first round, 4 in the second round, and 2 in the final computation of the session key. Hence, that is 14 modular exponentiations in total. Based on the symmetry, the computational cost for Bob is exactly the same.",
      "ja": "計算コストは​​、それらが支配的なコスト要因であるため、モジュールの累乗の数を数えることに基づいて推定されます。それを確認するシュノールNIZK証明二つを生成するために1つの累乗を取ることに注意してください[RFC8235]。アリスは、彼女は、セッション鍵の最終的な計算に8つの第二ラウンドの最初のラウンド、4で累乗、および2を実行する必要があります。したがって、それは、合計で14件のモジュラ累乗です。対称性に基づいて、ボブのための計算コストは​​まったく同じです。"
    },
    {
      "indent": 0,
      "text": "3. J-PAKE over Elliptic Curve",
      "section_title": true,
      "ja": "楕円曲線オーバー3. J-PAKE"
    },
    {
      "indent": 0,
      "text": "3.1. Protocol Setup",
      "section_title": true,
      "ja": "3.1。プロトコルの設定"
    },
    {
      "indent": 3,
      "text": "The J-PAKE protocol works basically the same in the elliptic curve (EC) setting, except that the underlying multiplicative group over a finite field is replaced by an additive group over an elliptic curve. Nonetheless, the EC version of J-PAKE is specified here for completeness.",
      "ja": "J-PAKEプロトコルは、有限体上の下層の乗法群は、楕円曲線上加法基で置き換えられていることを除いて、基本的に楕円曲線（EC）の設定で同じ動作します。それにもかかわらず、J-PAKEのECバージョンは完全を期すために、ここで指定されています。"
    },
    {
      "indent": 3,
      "text": "When implemented over an elliptic curve, J-PAKE may use the same EC parameters as ECDSA [FIPS186-4]. The FIPS 186-4 standard [FIPS186-4] defines three types of curves suitable for ECDSA: pseudorandom curves over prime fields, pseudorandom curves over binary fields, and special curves over binary fields called Koblitz curves or anomalous binary curves. All these curves that are suitable for ECDSA can also be used to implement J-PAKE. However, for illustration purposes, only curves over prime fields are described in this document. Typically, such curves include NIST P-256, P-384, and P-521. When choosing a curve, a level of 128-bit security or above is recommended. Let E(Fp) be an elliptic curve defined over a finite field Fp, where p is a large prime. Let G be a generator for the subgroup over E(Fp) of prime order n. Here, the NIST curves are used only as an example. Other secure curves such as Curve25519 are also suitable for implementation. The security proof of J-PAKE relies on the assumption that the DDH problem is intractable in the considered group.",
      "ja": "楕円曲線上に実装された場合、J-PAKEはECDSA [FIPS186-4]と同じECパラメータを使用してもよいです。 FIPSは、186から4標準[FIPS186-4] ECDSA適し曲線の3種類の定義：プライムフィールドにわたって擬似ランダム曲線、バイナリフィールド上擬似ランダム曲線、およびバイナリフィールド上に特殊な曲線は、Koblitz曲線又は異常バイナリ曲線と呼ばれます。 ECDSAに適しているこれらのすべての曲線もJ-PAKEを実装するために使用することができます。しかし、説明のために、素体上の唯一の曲線は、このドキュメントで説明されています。典型的には、このような曲線は、NIST P-256、P-384およびP-521が挙げられます。曲線を選択する際に、上記128ビットのセキュリティまたはレベルが推奨されます。 E（FP）は、pは大きな素数である有限体Fpは、上に定義された楕円曲線とします。 Gが素数次数nのE（FP）を介してサブグループのジェネレータとします。ここで、NIST曲線は、例としてのみ使用されています。このようCurve25519などの他の安全な曲線も実装に適しています。 J-PAKEのセキュリティ証明はDDH問題が考えられ、グループ内の難治性であるという仮定に依存しています。"
    },
    {
      "indent": 3,
      "text": "As before, let s denote the shared secret between Alice and Bob. The value of s falls within [1, n-1]. In particular, note that s MUST not be equal to 0 mod n.",
      "ja": "前と同様に、Sはアリスとボブの間の共有秘密を表してみましょう。 sの値は[1、N-1]内に入ります。具体的には、sは0 mod nを等しくあってはならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2. Two-Round Key Exchange",
      "section_title": true,
      "ja": "3.2。 2ラウンドの鍵交換"
    },
    {
      "indent": 3,
      "text": "Round 1: Alice selects ephemeral private keys x1 and x2 uniformly at random from [1, n-1]. Similarly, Bob selects ephemeral private keys x3 and x4 uniformly at random from [1, n-1].",
      "ja": "ラウンド1：アリスから一様にランダムにはかない秘密鍵x1とx2のを選択し、[1、N-1]。同様に、ボブは[1、N-1]からランダムに一様にエフェメラルプライベートキーX3及びX4を選択します。"
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: G1 = G x [x1], G2 = G x [x2] and ZKPs for x1 and x2",
      "ja": "Oアリス - >ボブ：G1 = G Xの[X1]、G2 = G Xの[X2]とZKPs X1およびX2のために"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: G3 = G x [x3], G4 = G x [x4] and ZKPs for x3 and x4",
      "ja": "Oボブ - >アリス：G3 = GのX [X3]、G4 = GのX [X4]及びX3及びX4のためZKPs"
    },
    {
      "indent": 3,
      "text": "When this round finishes, Alice and Bob verify the received ZKPs as specified in [RFC8235]. As an example, to prove the knowledge of the discrete logarithm of D = G x [d] with respect to the base point G, the ZKP contains: {UserID, V = G x [v], r = v - d * c mod n}, where UserID is the unique identifier for the prover, v is a number chosen uniformly at random from [1, n-1] and c = H(G || V || D || UserID).",
      "ja": "[RFC8235]で指定されるように、このラウンドが終了すると、アリスとボブは、受信ZKPsを確認します。一例として、D = G xの離散対数の知識を証明するために[D]ベースポイントGに対して、ZKPが含ま：{ユーザーID、V = G X [V]、R = V  - のD * cをユーザIDは、証明者の一意の識別子であるMOD nは}、vが[1、N-1]からランダムに一様に選択された数であり、c = H（G || V || D || USERID）。"
    },
    {
      "indent": 3,
      "text": "The verifier shall check the prover's UserID is a valid identity and is different from its own identity. If the verification of the ZKP fails, the session is aborted.",
      "ja": "検証者は、証明者のユーザーIDをチェックしなければならない有効なIDで、独自のアイデンティティと異なっています。 ZKPの検証が失敗した場合、セッションは中止されます。"
    },
    {
      "indent": 3,
      "text": "Round 2:",
      "ja": "ラウンド2："
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: A = (G1 + G3 + G4) x [x2*s] and a ZKP for x2*s",
      "ja": "Oアリス - >ボブ：A =（G1 + G3 + G4）X [×2 *のS]とx2の* sのZKP"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: B = (G1 + G2 + G3) x [x4*s] and a ZKP for x4*s",
      "ja": "Oボブ - >アリス：B =（G1 + G2 + G3）X [×4 *秒]とのx4 * sのZKP"
    },
    {
      "indent": 3,
      "text": "When the second round finishes, Alice and Bob verify the received ZKPs. The ZKPs are computed in the same way as in the previous round except that the generator is different. For Alice, the new generator is G1 + G3 + G4; for Bob, it is G1 + G2 + G3. Alice and Bob shall check that these new generators are not points at infinity. If any of these checks fails, the session is aborted. Otherwise, the two parties compute the common key material as follows:",
      "ja": "第二ラウンドが終了すると、アリスとボブは、受信ZKPsを確認します。 ZKPsは、発電機が異なること以外は前のラウンドと同じ方法で計算されます。アリスは、新しい発電機はG1 + G3 + G4です。ボブのために、それはG1 + G2 + G3です。アリスとボブは、これらの新しい発電機が無限遠点ではないことをチェックしなければなりません。これらのチェックのいずれかが失敗した場合、セッションは中止されます。次のようにそれ以外の場合は、両当事者は、共通鍵材料を計算します。"
    },
    {
      "indent": 3,
      "text": "o Alice computes Ka = (B - (G4 x [x2*s])) x [x2]",
      "ja": "Oアリスがkaを計算=（B  - （G4のX [×2 *秒]））X [X2]"
    },
    {
      "indent": 3,
      "text": "o Bob computes Kb = (A - (G2 x [x4*s])) x [x4]",
      "ja": "（ - （G2 X [X4 * S]）A）X [X4] OボブはKB =を計算します"
    },
    {
      "indent": 3,
      "text": "Here, Ka = Kb = G x [(x1+x3)*(x2*x4*s)]. Let K denote the same key material held by both parties. Using K as input, Alice and Bob then apply a Key Derivation Function (KDF) to derive a common session key k.",
      "ja": "ここで、カ= KB = G第X [（X1 + X3）*（X2 *×4 *秒）]。 Kは、両当事者が保有同じ鍵材料を示すものとします。入力としてKを使用して、アリスとボブは、共通セッション鍵Kを導出するために鍵導出関数（KDF）を適用します。"
    },
    {
      "indent": 0,
      "text": "3.3. Computational Cost",
      "section_title": true,
      "ja": "3.3。計算コスト"
    },
    {
      "indent": 3,
      "text": "In the EC setting, the computational cost of J-PAKE is estimated based on counting the number of scalar multiplications over the elliptic curve. Note that it takes one multiplication to generate a Schnorr NIZK proof and one to verify it [RFC8235]. For Alice, she has to perform 6 multiplications in the first round, 3 in the second round, and 2 in the final computation of the session key. Hence, that is 11 multiplications in total. Based on the symmetry, the computational cost for Bob is exactly the same.",
      "ja": "EC設定では、J-PAKEの計算コストは​​、楕円曲線上のスカラー乗算の数を数えることに基づいて推定されます。それを確認するために、シュNIZKの証拠と1を生成するために、1回の乗算を取ることに注意してください[RFC8235]。アリスは、彼女は、セッション鍵の最終的な計算に6回の第二ラウンドの最初のラウンド3で乗算、および2を実行しなければなりません。したがって、それは、合計で11回の乗算です。対称性に基づいて、ボブのための計算コストは​​まったく同じです。"
    },
    {
      "indent": 0,
      "text": "4. Three-Pass Variant",
      "section_title": true,
      "ja": "4.三峠バリアント"
    },
    {
      "indent": 3,
      "text": "The two-round J-PAKE protocol is completely symmetric, which significantly simplifies the security analysis. In practice, one party normally initiates the communication and the other party responds. In that case, the protocol will be completed in three passes instead of two rounds. The two-round J-PAKE protocol can be trivially changed to three passes without losing security. Take the finite field setting as an example, and assume Alice initiates the key exchange. The three-pass variant works as follows:",
      "ja": "2ラウンドのJ-PAKEプロトコルは大幅セキュリティ分析を簡素化している、完全に対称です。実際には、一方の当事者は、通常の通信を開始し、相手が応答します。その場合、プロトコルは、3つのパスの代わりに2回で完了されます。 2ラウンドのJ-PAKEプロトコルは、自明のセキュリティを失うことなく、3つのパスに変更することができます。一例として、有限フィールドの設定を取り、そしてアリスは鍵交換を開始前提としています。次のように3パスバリアントは動作します："
    },
    {
      "indent": 3,
      "text": "1. Alice -> Bob: g1 = g^x1 mod p, g2 = g^x2 mod p, ZKPs for x1 and x2.",
      "ja": "1.アリス - >ボブ：x1とx2のためのG1 = G ^ X1モッズP、G2 = G ^ x2のモッズP、ZKPs。"
    },
    {
      "indent": 3,
      "text": "2. Bob -> Alice: g3 = g^x3 mod p, g4 = g^x4 mod p, B = (g1*g2*g3)^(x4*s) mod p, ZKPs for x3, x4, and x4*s.",
      "ja": "2.ボブ - >アリス：G3 = G ^ X3 MOD P、G4 = G ^ X4 MOD P、B =（G1 * G2 * G3）^（X4 *秒）MOD P、X 3、X 4、およびX 4のためZKPs *秒。"
    },
    {
      "indent": 3,
      "text": "3. Alice -> Bob: A = (g1*g3*g4)^(x2*s) mod p and a ZKP for x2*s.",
      "section_title": true,
      "ja": "3.アリス - >ボブ：A =（G1 * G3 * G4）^（×2 *秒）のmod pと×2 * sのZKP。"
    },
    {
      "indent": 3,
      "text": "Both parties compute the session keys in exactly the same way as before.",
      "ja": "両当事者は、前と全く同じ方法でセッションキーを計算します。"
    },
    {
      "indent": 0,
      "text": "5. Key Confirmation",
      "section_title": true,
      "ja": "5.鍵確認"
    },
    {
      "indent": 3,
      "text": "The two-round J-PAKE protocol (or the three-pass variant) provides cryptographic guarantee that only the authenticated party who used the same password at the other end is able to compute the same session key. So far, the authentication is only implicit. The key confirmation is also implicit [Stinson06]. The two parties may use the derived key straight away to start secure communication by encrypting messages in an authenticated mode. Only the party with the same derived session key will be able to decrypt and read those messages.",
      "ja": "2ラウンドのJ-PAKEプロトコル（または3パスバリアントは）もう一方の端に同じパスワードを使用するだけで認証されたパーティーが同じセッション鍵を計算することができ、暗号保証を提供します。これまでのところ、認証が唯一の暗黙的です。キーの確認また、[Stinson06]暗黙的です。両当事者は、認証モードでメッセージを暗号化することで安全な通信を開始するためにすぐに派生キーを使用することができます。同じ派生セッションキーを持つ唯一の政党は、それらのメッセージを復号化して読むことができるようになります。"
    },
    {
      "indent": 3,
      "text": "For achieving explicit authentication, an additional key confirmation procedure should be performed. This provides explicit assurance that the other party has actually derived the same key. In this case, the key confirmation is explicit [Stinson06].",
      "ja": "明示的な認証を実現するために、追加のキーの確認手順を実行する必要があります。これは、他の当事者が実際に同じ鍵を導出していることを明示的な保証を提供します。この場合、キーの確認は、[Stinson06]明示的です。"
    },
    {
      "indent": 3,
      "text": "In J-PAKE, explicit key confirmation is recommended whenever the network bandwidth allows it. It has the benefit of providing explicit and immediate confirmation if the two parties have derived the same key and hence are authenticated to each other. This allows a practical implementation of J-PAKE to effectively detect online dictionary attacks (if any), and stop them accordingly by setting a threshold for the consecutively failed connection attempts.",
      "ja": "ネットワーク帯域幅がそれを可能にするたびJ-PAKEでは、明示的なキーの確認をお勧めします。これは、2人のパーティーが同じ鍵を導出しているので、相互に認証された場合、明示的かつ即時の確認を提供するという利点を持っています。これは（もしあれば）J-PAKEの実用化が効果的にオンライン辞書攻撃を検出することができ、そして連続失敗した接続試行のしきい値を設定することによって、それに応じてそれらを停止します。"
    },
    {
      "indent": 3,
      "text": "To achieve explicit key confirmation, there are several methods available. They are generically applicable to all key exchange protocols, not just J-PAKE. In general, it is recommended that a different key from the session key be used for key confirmation -- say, k' = KDF(K || \"JPAKE_KC\"). The advantage of using a different key for key confirmation is that the session key remains indistinguishable from random after the key confirmation process. (However, this perceived advantage is actually subtle and only theoretical.) Two explicit key confirmation methods are presented here.",
      "ja": "明示的なキーの確認を達成するために、利用可能ないくつかの方法があります。彼らはすべての鍵交換プロトコルだけでなく、J-PAKEに一般的に適用されます。 、言うK」= KDF（K || 『JPAKE_KC』） - 一般的には、セッション鍵とは異なる鍵が鍵確認のために使用することが推奨されます。鍵確認のために異なる鍵を使用する利点は、セッションキーはキー確認処理の後にランダムと区別がつかないままであることです。 （ただし、これに知覚利点は、実際に微妙と理論のみである。）二つの明示的なキーの確認方法がここに提示されています。"
    },
    {
      "indent": 3,
      "text": "The first method is based on the one used in the SPEKE protocol [Jab96]. Suppose Alice initiates the key confirmation. Alice sends to Bob H(H(k')), which Bob will verify. If the verification is successful, Bob sends back to Alice H(k'), which Alice will verify. This key confirmation procedure needs to be completed in two rounds, as shown below.",
      "ja": "第1の方法はSPEKEプロトコル[Jab96]で使用されるものに基づいています。アリスは鍵確認を開始したとします。アリスは、ボブが検証するボブH（H（K '））に送信します。検証に成功した場合、ボブはアリスが確認しますアリスH（K '）に送り返します。このキーの確認手順は、以下に示すように、2ラウンドで完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Alice -> Bob: H(H(k'))",
      "section_title": true,
      "ja": "1.アリス - >ボブ：H（H（K '））"
    },
    {
      "indent": 3,
      "text": "2. Bob -> Alice: H(k')",
      "section_title": true,
      "ja": "2.ボブ - >アリス：H（K '）"
    },
    {
      "indent": 3,
      "text": "The above procedure requires two rounds instead of one, because the second message depends on the first. If both parties attempt to send the first message at the same time without an agreed order, they cannot tell if the message that they receive is a genuine challenge or a replayed message, and consequently may enter a deadlock.",
      "ja": "第2のメッセージは、最初に依存するため、上記手順が、代わりに一方の2ラウンドを必要とします。両当事者が合意された順序なしで同時に最初のメッセージを送信しようとすると、彼らは、彼らが受け取るメッセージが本物チャレンジまたはリプレイのメッセージであれば言うことができない、その結果、デッドロックを入力することができます。"
    },
    {
      "indent": 3,
      "text": "The second method is based on the unilateral key confirmation scheme specified in NIST SP 800-56A Revision 1 [BJS07]. Alice and Bob send to each other a MAC tag, which they will verify accordingly. This key confirmation procedure can be completed in one round.",
      "ja": "第二の方法は、NIST SP 800-56Aリビジョン1 [BJS07]で指定片側キー確認方式に基づいています。アリスとボブは、彼らがそれに応じて検証する互いにMACタグに送信します。このキーの確認手順は、1ラウンドで完了することができます。"
    },
    {
      "indent": 3,
      "text": "In the finite field setting, it works as follows.",
      "ja": "次のように有限の設定では、それが動作します。"
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: MacTagAlice = MAC(k', \"KC_1_U\" || Alice || Bob || g1 || g2 || g3 || g4)",
      "ja": "アリス - >ボブ：MacTagAlice = MAC（K '' KC_1_U「|| ||アリス、ボブ|| || G1 G2 G3 || || G4）"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: MacTagBob = MAC(k', \"KC_1_U\" || Bob || Alice || g3 || g4 || g1 || g2)",
      "ja": "Oボブ - >アリス：MacTagBob = MAC（K」、 \"KC_1_U\" || ||ボブアリス|| || G3 G4 || || G1、G2）"
    },
    {
      "indent": 3,
      "text": "In the EC setting, the key confirmation works basically the same.",
      "ja": "ECの設定では、キーの確認は基本的に同じ動作します。"
    },
    {
      "indent": 3,
      "text": "o Alice -> Bob: MacTagAlice = MAC(k', \"KC_1_U\" || Alice || Bob || G1 || G2 || G3 || G4)",
      "ja": "アリス - >ボブ：MacTagAlice = MAC（K '' KC_1_U「|| ||アリス、ボブ|| || G1 G2 G3 || || G4）"
    },
    {
      "indent": 3,
      "text": "o Bob -> Alice: MacTagBob = MAC(k', \"KC_1_U\" || Bob || Alice || G3 || G4 || G1 || G2)",
      "ja": "Oボブ - >アリス：MacTagBob = MAC（K」、 \"KC_1_U\" || ||ボブアリス|| || G3 G4 || || G1 G2）"
    },
    {
      "indent": 3,
      "text": "The second method assumes an additional secure MAC function (e.g., one may use HMAC) and is slightly more complex than the first method. However, it can be completed within one round and it preserves the overall symmetry of the protocol implementation. For this reason, the second method is RECOMMENDED.",
      "ja": "第二の方法は、追加の安全なMAC機能を想定し（例えば、一方はHMACを使用することができる）と少し複雑最初の方法よりも長いです。しかし、それは1ラウンド以内に完了することができ、プロトコル実装の全体的な対称性を維持します。このため、第二の方法が推奨されます。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "A PAKE protocol is designed to provide two functions in one protocol execution. The first one is to provide zero-knowledge authentication of a password. It is called \"zero knowledge\" because at the end of the protocol, the two communicating parties will learn nothing more than one bit information: whether the passwords supplied at two ends are equal. Therefore, a PAKE protocol is naturally resistant against phishing attacks. The second function is to provide session key establishment if the two passwords are equal. The session key will be used to protect the confidentiality and integrity of the subsequent communication.",
      "ja": "PAKEプロトコルは、プロトコルの実行に二つの機能を提供するように設計されています。一つ目は、パスワードのゼロ知識認証を提供することです。両端に指定したパスワードが等しいかどうか：プロトコルの終わりに、2人の通信当事者が1ビットの情報以上のものを学びませんので、それは「ゼロ知識」と呼ばれています。したがって、PAKEプロトコルは、フィッシング攻撃に対して天然に耐性です。第二の機能は、二つのパスワードが等しい場合はセッション鍵の確立を提供することです。セッションキーは、その後の通信の機密性と完全性を保護するために使用されます。"
    },
    {
      "indent": 3,
      "text": "More concretely, a secure PAKE protocol shall satisfy the following security requirements [HR10].",
      "ja": "より具体的には、安全なPAKEプロトコルは、以下のセキュリティ要件[HR10]を満足しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. Offline dictionary attack resistance: It does not leak any information that allows a passive/active attacker to perform offline exhaustive search of the password.",
      "ja": "1.オフライン辞書攻撃耐性：それは、パッシブ/アクティブ、攻撃者がパスワードのオフライン徹底的な検索を実行することを可能にする任意の情報を漏洩しません。"
    },
    {
      "indent": 3,
      "text": "2. Forward secrecy: It produces session keys that remain secure even when the password is later disclosed.",
      "ja": "フォワード2.秘密：それはパスワードが後に開示された場合でも、安全なままのセッション鍵を生成します。"
    },
    {
      "indent": 3,
      "text": "3. Known-key security: It prevents a disclosed session key from affecting the security of other sessions.",
      "ja": "3.既知の鍵セキュリティ：それは他のセッションのセキュリティに影響を与えることから、開示されたセッション鍵を防ぎます。"
    },
    {
      "indent": 3,
      "text": "4. Online dictionary attack resistance: It limits an active attacker to test only one password per protocol execution.",
      "ja": "4.オンライン辞書攻撃耐性：それは、プロトコルの実行ごとに1つだけパスワードをテストするために、アクティブな攻撃を制限します。"
    },
    {
      "indent": 3,
      "text": "First, a PAKE protocol must resist offline dictionary attacks. A password is inherently weak. Typically, it has only about 20-30 bits entropy. This level of security is subject to exhaustive search. Therefore, in the PAKE protocol, the communication must not reveal any data that allows an attacker to learn the password through offline exhaustive search.",
      "ja": "まず、PAKEプロトコルは、オフライン辞書攻撃に抵抗しなければなりません。パスワードは、本質的に弱いです。典型的には、それだけで約20〜30ビットのエントロピーを有しています。このセキュリティレベルは、徹底的な検索の対象となります。したがって、PAKEプロトコルでは、通信は、攻撃者がオフラインの徹底的な検索を通じてパスワードを学ぶことができます任意のデータを明らかにしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Second, a PAKE protocol must provide forward secrecy. The key exchange is authenticated based on a shared password. However, there is no guarantee on the long-term secrecy of the password. A secure PAKE scheme shall protect past session keys even when the password is later disclosed. This property also implies that if an attacker knows the password but only passively observes the key exchange, he cannot learn the session key.",
      "ja": "第二に、PAKEプロトコルは前進の秘密保持を提供する必要があります。鍵交換は、共有パスワードに基づいて認証されます。しかし、パスワードの長期的な秘密の保証はありません。安全なPAKE方式はパスワードが後に開示されていても、過去のセッション鍵を保護しなければなりません。このプロパティは、攻撃者がパスワードを知っているだけで受動的に鍵交換を観測した場合、彼はセッションキーを学ぶことができないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Third, a PAKE protocol must provide known key security. A session key lasts throughout the session. An exposed session key must not cause any global impact on the system, affecting the security of other sessions.",
      "ja": "第三に、PAKEプロトコルが知られている主要なセキュリティを提供する必要があります。セッション鍵は、セッションを通じて持続します。公開セッションキーは、他のセッションのセキュリティに影響を与え、システム上の任意のグローバルインパクトを引き起こしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Finally, a PAKE protocol must resist online dictionary attacks. If the attacker is directly engaging in the key exchange, there is no way to prevent such an attacker trying a random guess of the password. However, a secure PAKE scheme should minimize the effect of the online attack. In the best case, the attacker can only guess exactly one password per impersonation attempt. Consecutively failed attempts can be easily detected, and the subsequent attempts shall be thwarted accordingly. It is recommended that the false authentication counter be handled in such a way that any error (which causes the session to fail during the key exchange or key confirmation) leads to incrementing the false authentication counter.",
      "ja": "最後に、PAKEプロトコルは、オンライン辞書攻撃に抵抗しなければなりません。攻撃者は直接鍵交換に従事されている場合は、パスワードのランダムな推測をしようと、このような攻撃を防止する方法はありません。しかし、安全なPAKEスキームは、オンライン攻撃の影響を最小限に抑える必要があります。最良のケースでは、攻撃者は偽装の試みごとに1つのパスワードを推測することができます。連続して失敗した試みを容易に検出することができ、その後の試みは、それに応じて阻止しなければなりません。偽の認証カウンタが（セッションが鍵交換や鍵確認中に失敗する原因となる）何らかのエラーが偽の認証カウンタをインクリメントにつながるような方法で処理されることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It has been proven in [HR10] that J-PAKE satisfies all of the four requirements based on the assumptions that the Decisional Diffie-Hellman problem is intractable and the underlying Schnorr NIZK proof is secure. An independent study that proves security of J-PAKE in a model with algebraic adversaries and random oracles can be found in [ABM15]. By comparison, it has been known that EKE has the problem of leaking partial information about the password to a passive attacker, hence not satisfying the first requirement [Jas96]. For SPEKE and SRP-6, an attacker may be able to test more than one password in one online dictionary attack (see [Zha04] and [Hao10]), hence they do not satisfy the fourth requirement in the strict theoretical sense. Furthermore, SPEKE is found vulnerable to an impersonation attack and a key-malleability attack [HS14]. These two attacks affect the SPEKE protocol specified in Jablon's original 1996 paper [Jab96] as well in the D26 draft of IEEE P1363.2 and the ISO/ IEC 11770-4:2006 standard. As a result, the specification of SPEKE in ISO/IEC 11770-4:2006 has been revised to address the identified problems.",
      "ja": "J-PAKEは。判断のDiffie-Hellman問題は難治性で、基礎となるシュノールNIZKの証明が安全であることを前提に基づいて、4つの要件をすべて満たしていることを[HR10]で証明されています。代数敵とランダムオラクルとモデルにJ-PAKEのセキュリティを証明している独立した研究では、[ABM15]で見つけることができます。比較することにより、EKEは、したがって最初の要件[Jas96]を満足しない、受動的攻撃者にパスワードについての部分的な情報漏洩の問題があることが知られています。 SPEKEとSRP-6の場合、攻撃者は、1回のオンライン辞書攻撃で複数のパスワードをテストすることができるかもしれない（[Zha04]を参照し、[Hao10]）、それゆえ彼らは、厳密な理論的な意味での第四の要件を満たしていません。さらに、SPEKEは、偽装攻撃とキー展性攻撃[HS14]に対する脆弱性が見出されています。 2006標準：これら二つの攻撃は、IEEE P1363.2のD26ドラフトおよびISO / IEC 11770から4にも同様に[Jab96] Jablonのオリジナルの1996年論文で指定SPEKEプロトコルに影響を与えます。その結果、ISO / IEC 11770から4でSPEKEの仕様：2006は、特定された問題に対処するために改訂されました。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not require any IANA actions.",
      "ja": "このドキュメントは、IANAのアクションを必要としません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ABM15] Abdalla, M., Benhamouda, F., and P. MacKenzie, \"Security of the J-PAKE Password-Authenticated Key Exchange Protocol\", 2015 IEEE Symposium on Security and Privacy, DOI 10.1109/sp.2015.41, May 2015.",
      "ja": "[ABM15]アブダラ、M.、Benhamouda、F.、およびP.マッケンジー、2015年のセキュリティとプライバシーに関するIEEEシンポジウム、DOI 10.1109 / sp.2015.41、2015年5月 \"J-PAKEのパスワード認証鍵交換プロトコルのセキュリティ\" 。"
    },
    {
      "indent": 3,
      "text": "[BM92] Bellovin, S. and M. Merrit, \"Encrypted Key Exchange: Password-based Protocols Secure against Dictionary Attacks\", IEEE Symposium on Security and Privacy, DOI 10.1109/risp.1992.213269, May 1992.",
      "ja": "セキュリティとプライバシー上、IEEEシンポジウム、DOI 10.1109 / risp.1992.213269、1992年5月：[BM92] Bellovin氏、S.とM. Merrit、 \"パスワードベースのプロトコル辞書攻撃に対して安全な暗号化キーの交換\"。"
    },
    {
      "indent": 3,
      "text": "[HR08] Hao, F. and P. Ryan, \"Password Authenticated Key Exchange by Juggling\", Lecture Notes in Computer Science, pp. 159-171, from 16th Security Protocols Workshop (SPW '08), DOI 10.1007/978-3-642-22137-8_23, 2011.",
      "ja": "[HR08]ハオ、F.およびP.ライアン、「ジャグリングにより、パスワード認証鍵交換」、コンピュータサイエンスの講義ノート、頁159から171まで、第16回セキュリティプロトコルワークショップ（SPW '08）から、DOI 10.1007 / 978から3 -642-22137-8_23、2011。"
    },
    {
      "indent": 3,
      "text": "[HR10] Hao, F. and P. Ryan, \"J-PAKE: Authenticated Key Exchange Without PKI\", Transactions on Computational Science XI, pp. 192-206, DOI 10.1007/978-3-642-17697-5_10, 2010.",
      "ja": "[HR10]ハオ、F.およびP.ライアン、 \"J-PAKE：認証鍵交換PKIなし\"、計算科学XI、頁上の取引192から206、DOI 10.1007 / 978-3-642-17697-5_10、2010。 。"
    },
    {
      "indent": 3,
      "text": "[HS14] Hao, F. and S. Shahandashti, \"The SPEKE Protocol Revisited\", Security Standardisation Research, pp. 26-38, DOI 10.1007/978-3-319-14054-4_2, December 2014.",
      "ja": "[HS14]ハオ、F.およびS. Shahandashti、 \"SPEKE議定再訪\"、セキュリティ標準化研究、PP。26-38、DOI 10.1007 / 978-3-319-14054-4_2、2014年12月。"
    },
    {
      "indent": 3,
      "text": "[Jab96] Jablon, D., \"Strong Password-Only Authenticated Key Exchange\", ACM SIGCOMM Computer Communication Review, Vol. 26, pp. 5-26, DOI 10.1145/242896.242897, October 1996.",
      "ja": "[Jab96] Jablon、D.、 \"強力なパスワードのみによる認証鍵交換\"、ACM SIGCOMMコンピュータコミュニケーションレビュー、巻。 26頁5-26、DOI 10.1145 / 242896.242897、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5054] Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, \"Using the Secure Remote Password (SRP) Protocol for TLS Authentication\", RFC 5054, DOI 10.17487/RFC5054, November 2007, <https://www.rfc-editor.org/info/rfc5054>.",
      "ja": "[RFC5054]テイラー、D.、呉、T.、Mavrogiannopoulos、N.、およびT.ペリン、 \"TLS認証のためのセキュアリモートパスワードの使い方（SRP）プロトコル\"、RFC 5054、DOI 10.17487 / RFC5054、2007年11月、< https://www.rfc-editor.org/info/rfc5054>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B.、 \"RFC 2119個のキーワードに小文字VS大文字の曖昧さ\"、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8235] Hao, F., Ed., \"Schnorr Non-interactive Zero Knowledge Proof\", RFC 8235, DOI 10.17487/RFC8235, September 2017, <https://www.rfc-editor.org/info/rfc8235>.",
      "ja": "[RFC8235]ハオ、F.、エド。、 \"シュノール非対話ゼロ知識証明\"、RFC 8235、DOI 10.17487 / RFC8235、2017年9月、<https://www.rfc-editor.org/info/rfc8235>。"
    },
    {
      "indent": 3,
      "text": "[SEC1] \"Standards for Efficient Cryptography. SEC 1: Elliptic Curve Cryptography\", SECG SEC1-v2, May 2009, <http://www.secg.org/sec1-v2.pdf>.",
      "ja": "[SEC1] \"効率的な暗号化のための基準SEC 1：楕円曲線暗号\"、SECG SEC1-V2、2009年5月、<http://www.secg.org/sec1-v2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Stinson06] Stinson, D., \"Cryptography: Theory and Practice\", 3rd Edition, CRC, 2006.",
      "ja": "[Stinson06]スティンソン、D.、 \"暗号：理論と実践\"、第3版、CRC、2006。"
    },
    {
      "indent": 3,
      "text": "[Wu98] Wu, T., \"The Secure Remote Password Protocol\", Internet Society Symposium on Network and Distributed System Security, March 1998.",
      "ja": "[Wu98]呉、T.、「セキュアリモートパスワードプロトコル」、ネットワーク上のインターネット協会シンポジウムと分散システムセキュリティ、1998年3月。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[AP05] Abdalla, M. and D. Pointcheval, \"Simple Password-Based Encrypted Key Exchange Protocols\", Topics in Cryptology CT-RSA, DOI 10.1007/978-3-540-30574-3_14, 2005.",
      "ja": "[AP05]アブダラ、M.とD. Pointcheval、 \"単純なパスワードベースの暗号化鍵交換プロトコル\"、暗号学CT-RSA、DOI 10.1007 / 978-3-540-30574-3_14、2005年のトピック。"
    },
    {
      "indent": 3,
      "text": "[BJS07] Barker, E., Johnson, D., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007, <http://csrc.nist.gov/publications/nistpubs/800-56A/ SP800-56A_Revision1_Mar08-2007.pdf>.",
      "ja": "[BJS07]バーカー、E.、ジョンソン、D.、およびM. SMID、 \"使用してペアワイズ鍵確立スキームのための勧告離散対数暗号（改訂版）\"、は、NIST Special Publication 800-56A、2007年3月、<のhttp：/ /csrc.nist.gov/publications/nistpubs/800-56A/ SP800-56A_Revision1_Mar08-2007.pdf>。"
    },
    {
      "indent": 3,
      "text": "[BOINC] BOINC, \"Index of /android-boinc/libssl/crypto/jpake\", February 2011, <http://boinc.berkeley.edu/ android-boinc/libssl/crypto/jpake/>.",
      "ja": "[BOINC] BOINC、 \"/アンドロイド-BOINC /のlibssl /暗号/ jpakeのインデックス\"、2011年2月、<http://boinc.berkeley.edu/アンドロイド-BOINC /のlibssl /暗号/ jpake />。"
    },
    {
      "indent": 3,
      "text": "[BOUNCY] Bouncy Castle Cryptography Library, \"org.bouncycastle.crypto.agreement.jpake (Bouncy Castle Library 1.57 API Specification)\", May 2017, <https://www.bouncycastle.org/docs/docs1.5on/org/ bouncycastle/crypto/agreement/jpake/package-summary.html>.",
      "ja": "[弾む] Bouncy Castleの暗号化ライブラリ、 \"org.bouncycastle.crypto.agreement.jpake（Bouncy Castleのライブラリ1.57 API仕様）\"、2017年5月、<https://www.bouncycastle.org/docs/docs1.5on/org/ BouncyCastle /暗号/契約/ jpake /パッケージ-summary.htmlに>。"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[FIPS186-4]米国国立標準技術研究所、 \"デジタル署名標準（DSS）\"、FIPS PUBの186から4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月、<のhttp：//nvlpubs.nist。 GOV / nistpubs / FIPS / NIST.FIPS.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Hao10] Hao, F., \"On Small Subgroup Non-Confinement Attacks\", IEEE Conference on Computer and Information Technology, DOI 10.1109/CIT.2010.187, 2010.",
      "ja": "[Hao10]ハオ、F.、コンピュータと情報技術、DOI 10.1109 / CIT.2010.187、2010年にIEEE会議 \"小サブグループ非閉じ込め攻撃に\"。"
    },
    {
      "indent": 3,
      "text": "[ISO.11770-4] ISO/IEC, \"Information technology -- Security techniques -- Key management -- Part 4: Mechanisms based on weak secrets\", (under development), July 2017, <https://www.iso.org/standard/67933.html>.",
      "ja": "[ISO.11770-4] ISO / IEC、 \"情報技術 - セキュリティ技術 - 鍵管理 - 第4部：弱い秘密に基づくメカニズム\"、（開発中）、2017年7月、<HTTPS：//www.iso .ORG /標準/ 67933.html>。"
    },
    {
      "indent": 3,
      "text": "[Jas96] Jaspan, B., \"Dual-Workfactor Encrypted Key Exchange: Efficiently Preventing Password Chaining and Dictionary Attacks\", USENIX Symposium on Security, July 1996.",
      "ja": "[Jas96] Jaspan、B.、「デュアルWorkfactor暗号化鍵交換：効率的に防止パスワードチェーンや辞書攻撃」、セキュリティ、1996年7月のUSENIXシンポジウム。"
    },
    {
      "indent": 3,
      "text": "[MOZILLA] Mozilla Wiki, \"Services/KeyExchange\", August 2011, <https://wiki.mozilla.org/index.php?title=Services/ KeyExchange&oldid=343704>.",
      "ja": "[MOZILLA] MozillaのWikiの、 \"サービス/ KeyExchange\"、2011年8月、<https://wiki.mozilla.org/index.php?title=Services/ KeyExchange＆oldid = 343704>。"
    },
    {
      "indent": 3,
      "text": "[MOZILLA_NSS] Mozilla Central, \"jpake.c - DXR\", August 2016, <https://dxr.mozilla.org/mozilla-central/source/ security/nss/lib/freebl/jpake.c>.",
      "ja": "[MOZILLA_NSS] Mozillaの中央、 \"jpake.c  -  DXR\"、2016年8月、<https://dxr.mozilla.org/mozilla-central/source/セキュリティ/ NSS / libに/ freebl / jpake.c>。"
    },
    {
      "indent": 3,
      "text": "[PALEMOON] Moonchild Productions, \"Pale Moon Sync\", <https://www.palemoon.org/sync/>.",
      "ja": "[PALEMOON] Moonchildプロダクション、 \"ペール・ムーン同期\"、<https://www.palemoon.org/sync/>。"
    },
    {
      "indent": 3,
      "text": "[RFC4419] Friedl, M., Provos, N., and W. Simpson, \"Diffie-Hellman Group Exchange for the Secure Shell (SSH) Transport Layer Protocol\", RFC 4419, DOI 10.17487/RFC4419, March 2006, <https://www.rfc-editor.org/info/rfc4419>.",
      "ja": "[RFC4419] Friedlの、M.、プロボス氏、N.、およびW.シンプソン、 \"セキュアシェル（SSH）トランスポート層プロトコルのためのDiffie-Hellmanのグループ交換\"、RFC 4419、DOI 10.17487 / RFC4419、2006年3月、<HTTPS： //www.rfc-editor.org/info/rfc4419>。"
    },
    {
      "indent": 3,
      "text": "[SOAA15] Smyshlyaev, S., Oshkin, I., Alekseev, E., and L. Ahmetzyanova, \"On the Security of One Password Authenticated Key Exchange Protocol\", 2015, <http://eprint.iacr.org/2015/1237.pdf>.",
      "ja": "[SOAA15] Smyshlyaev、S.、Oshkin、I.、 \"1つのパスワード認証鍵交換プロトコルのセキュリティに\" アレクセイエフ、E.、およびL. Ahmetzyanova、2015年、<http://eprint.iacr.org/2015 /1237.pdf>。"
    },
    {
      "indent": 3,
      "text": "[THREAD] Thread, \"Thread Commissioning\", White Paper, July 2015, <https://portal.threadgroup.org/DesktopModules/ Inventures_Document/FileDownload.aspx?ContentID=658>.",
      "ja": "[スレッド]スレッド、 \"試運転スレッド\"、ホワイトペーパー、2015年7月、<https://portal.threadgroup.org/DesktopModules/ Inventures_Document / FileDownload.aspx？コンテンツID = 658>。"
    },
    {
      "indent": 3,
      "text": "[Zha04] Zhang, M., \"Analysis of the SPEKE Password-Authenticated Key Exchange Protocol\", IEEE Communications Letters, Vol. 8, pp. 63-65, DOI 10.1109/lcomm.2003.822506, January 2004.",
      "ja": "[Zha04]チャン、M.、IEEEコミュニケーションズレター集「SPEKEパスワード認証鍵交換プロトコルの分析」。 8頁63-65、DOI 10.1109 / lcomm.2003.822506、2004年1月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor would like to thank Dylan Clarke, Siamak Shahandashti, Robert Cragie, Stanislav Smyshlyaev, and Russ Housley for many useful comments. This work is supported by EPSRC First Grant (EP/J011541/1) and ERC Starting Grant (No. 306994).",
      "ja": "エディタは、多くの有用なコメントをディラン・クラーク、Siamak Shahandashti、ロバートCragie、スタニスラフSmyshlyaev、とラスHousleyに感謝したいと思います。この作品は、EPSRCまずグラント（EP / J011541 / 1）とERC開始グラント（番号306994）によってサポートされています。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Feng Hao (editor) Newcastle University (UK) Urban Sciences Building, School of Computing, Newcastle University Newcastle Upon Tyne United Kingdom",
      "ja": "風水ハオ（エディタ）ニューカッスル大学（UK）アーバン・サイエンスビル、コンピューティングの学校、ニューカッスル大学ニューカッスル・アポン・タインイギリスの際"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)191-208-6384 Email: feng.hao@ncl.ac.uk",
      "ja": "電話：+44（0）191-208-6384 Eメール：feng.hao@ncl.ac.uk"
    }
  ]
}